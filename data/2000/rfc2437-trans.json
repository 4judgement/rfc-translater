{
  "title": {
    "text": "RFC 2437 - PKCS #1: RSA Cryptography Specifications Version 2.0",
    "ja": "RFC 2437 - PKCS＃1：RSA暗号化仕様バージョン2.0"
  },
  "number": 2437,
  "created_at": "2020-08-16 17:09:39.332929+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         B. Kaliski\nRequest for Comments: 2437                                    J. Staddon\nObsoletes: 2313                                         RSA Laboratories\nCategory: Informational                                     October 1998",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "PKCS #1: RSA Cryptography Specifications Version 2.0",
      "ja": "PKCS＃1：RSA暗号化仕様バージョン2.0"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準も規定していません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.       Introduction.....................................2\n1.1      Overview.........................................3\n2.       Notation.........................................3\n3.       Key types........................................5\n3.1      RSA public key...................................5\n3.2      RSA private key..................................5\n4.       Data conversion primitives.......................6\n4.1      I2OSP............................................6\n4.2      OS2IP............................................7\n5.       Cryptographic primitives.........................8\n5.1      Encryption and decryption primitives.............8\n5.1.1    RSAEP............................................8\n5.1.2    RSADP............................................9\n5.2      Signature and verification primitives...........10\n5.2.1    RSASP1..........................................10\n5.2.2    RSAVP1..........................................11\n6.       Overview of schemes.............................11\n7.       Encryption schemes..............................12\n7.1      RSAES-OAEP......................................13\n7.1.1    Encryption operation............................13\n7.1.2    Decryption operation............................14\n7.2      RSAES-PKCS1-v1_5................................15\n7.2.1    Encryption operation............................17\n7.2.2    Decryption operation............................17\n8.       Signature schemes with appendix.................18\n8.1      RSASSA-PKCS1-v1_5...............................19\n8.1.1    Signature generation operation..................20",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "8.1.2    Signature verification operation................21\n9.       Encoding methods................................22\n9.1      Encoding methods for encryption.................22\n9.1.1    EME-OAEP........................................22\n9.1.2    EME-PKCS1-v1_5..................................24\n9.2      Encoding methods for signatures with appendix...26\n9.2.1    EMSA-PKCS1-v1_5.................................26\n10.      Auxiliary Functions.............................27\n10.1     Hash Functions..................................27\n10.2     Mask Generation Functions.......................28\n10.2.1   MGF1............................................28\n11.      ASN.1 syntax....................................29\n11.1     Key representation..............................29\n11.1.1   Public-key syntax...............................30\n11.1.2   Private-key syntax..............................30\n11.2     Scheme identification...........................31\n11.2.1   Syntax for RSAES-OAEP...........................31\n11.2.2   Syntax for RSAES-PKCS1-v1_5.....................32\n11.2.3   Syntax for RSASSA-PKCS1-v1_5....................33\n12       Patent Statement................................33\n12.1     Patent statement for the RSA algorithm..........34\n13.      Revision history................................35\n14.      References......................................35\n         Security Considerations.........................37\n         Acknowledgements................................37\n         Authors' Addresses..............................38\n         Full Copyright Statement........................39",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo is the successor to RFC 2313. This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm [18], covering the following aspects:",
      "ja": "このメモはRFC 2313の後継です。このドキュメントは、RSAアルゴリズム[18]に基づく公開鍵暗号化の実装に関する推奨事項を提供し、次の側面をカバーしています。"
    },
    {
      "indent": 6,
      "text": "-cryptographic primitives -encryption schemes -signature schemes with appendix -ASN.1 syntax for representing keys and for identifying the schemes",
      "ja": "-暗号プリミティブ-暗号化スキーム-付録付きの署名スキーム-キーを表現し、スキームを識別するためのASN.1構文"
    },
    {
      "indent": 3,
      "text": "The recommendations are intended for general application within computer and communications systems, and as such include a fair amount of flexibility. It is expected that application standards based on these specifications may include additional constraints. The recommendations are intended to be compatible with draft standards currently being developed by the ANSI X9F1 [1] and IEEE P1363 working groups [14]. This document supersedes PKCS #1 version 1.5 [20].",
      "ja": "推奨事項は、コンピューターおよび通信システム内の一般的なアプリケーションを対象としているため、かなりの柔軟性が含まれています。これらの仕様に基づくアプリケーション標準には、追加の制約が含まれる場合があります。推奨事項は、ANSI X9F1 [1]およびIEEE P1363ワーキンググループ[14]によって現在開発されているドラフト規格との互換性を目的としています。このドキュメントは、PKCS＃1バージョン1.5 [20]に優先します。"
    },
    {
      "indent": 3,
      "text": "Editor's note. It is expected that subsequent versions of PKCS #1 may cover other aspects of the RSA algorithm such as key size, key generation, key validation, and signature schemes with message recovery.",
      "ja": "編集者のメモ。 PKCS＃1の後続のバージョンは、RSAアルゴリズムの他の側面（鍵のサイズ、鍵の生成、鍵の検証、メッセージ回復を伴う署名方式など）をカバーすることが期待されています。"
    },
    {
      "indent": 0,
      "text": "1.1 Overview",
      "section_title": true,
      "ja": "1.1 概観"
    },
    {
      "indent": 3,
      "text": "The organization of this document is as follows:",
      "ja": "このドキュメントの構成は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "-Section 1 is an introduction. -Section 2 defines some notation used in this document. -Section 3 defines the RSA public and private key types. -Sections 4 and 5 define several primitives, or basic mathematical operations. Data conversion primitives are in Section 4, and cryptographic primitives (encryption-decryption, signature-verification) are in Section 5. -Section 6, 7 and 8 deal with the encryption and signature schemes in this document. Section 6 gives an overview. Section 7 defines an OAEP-based [2] encryption scheme along with the method found in PKCS #1 v1.5. Section 8 defines a signature scheme with appendix; the method is identical to that of PKCS #1 v1.5. -Section 9 defines the encoding methods for the encryption and signature schemes in Sections 7 and 8. -Section 10 defines the hash functions and the mask generation function used in this document. -Section 11 defines the ASN.1 syntax for the keys defined in Section 3 and the schemes gives in Sections 7 and 8. -Section 12 outlines the revision history of PKCS #1. -Section 13 contains references to other publications and standards.",
      "ja": "-セクション1は紹介です。セクション2では、このドキュメントで使用される表記法をいくつか定義しています。 -セクション3では、RSA公開鍵と秘密鍵のタイプを定義しています。 -セクション4と5は、いくつかのプリミティブ、または基本的な数学演算を定義します。データ変換プリミティブはセクション4にあり、暗号化プリミティブ（暗号化-復号化、署名検証）はセクション5にあります。-セクション6、7、8は、このドキュメントの暗号化および署名スキームを扱います。セクション6に概要を示します。セクション7では、OAEPベースの[2]暗号化スキームと、PKCS＃1 v1.5にある方法を定義しています。セクション8では、付録で署名方式を定義します。この方法は、PKCS＃1 v1.5の方法と同じです。 -セクション9は、セクション7および8の暗号化および署名スキームのエンコード方式を定義します。-セクション10は、このドキュメントで使用されるハッシュ関数とマスク生成関数を定義します。 -セクション11は、セクション3で定義されたキーのASN.1構文を定義し、スキームはセクション7および8で提供します。-セクション12は、PKCS＃1の改訂履歴の概要です。 -セクション13には、他の出版物や規格への参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "2. Notation",
      "section_title": true,
      "ja": "2. 表記"
    },
    {
      "indent": 3,
      "text": "(n, e) RSA public key",
      "ja": "（n、e）RSA公開鍵"
    },
    {
      "indent": 3,
      "text": "c ciphertext representative, an integer between 0 and n-1",
      "ja": "c暗号文の代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "C ciphertext, an octet string",
      "ja": "C暗号文、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "d private exponent",
      "ja": "dプライベート指数"
    },
    {
      "indent": 3,
      "text": "dP p's exponent, a positive integer such that: e(dP)\\equiv 1 (mod(p-1))",
      "ja": "dP pの指数、次のような正の整数：e（dP）\\ equiv 1（mod（p-1））"
    },
    {
      "indent": 3,
      "text": "dQ q's exponent, a positive integer such that: e(dQ)\\equiv 1 (mod(q-1))",
      "ja": "dQ qの指数、次のような正の整数：e（dQ）\\ equiv 1（mod（q-1））"
    },
    {
      "indent": 0,
      "text": " e public exponent EM encoded message, an octet string",
      "ja": "e公開指数EMエンコードメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "emLen intended length in octets of an encoded message",
      "ja": "エンコードされたメッセージのオクテット単位のemLen意図された長さ"
    },
    {
      "indent": 3,
      "text": "H hash value, an output of Hash",
      "ja": "Hハッシュ値、Hashの出力"
    },
    {
      "indent": 3,
      "text": "Hash hash function",
      "ja": "ハッシュハッシュ関数"
    },
    {
      "indent": 3,
      "text": "hLen output length in octets of hash function Hash",
      "ja": "ハッシュ関数Hashのオクテット単位のhLen出力長"
    },
    {
      "indent": 3,
      "text": "K RSA private key",
      "ja": "K RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "k length in octets of the modulus",
      "ja": "モジュラスのオクテット単位のk長"
    },
    {
      "indent": 3,
      "text": "l intended length of octet string",
      "ja": "lオクテット文字列の意図された長さ"
    },
    {
      "indent": 3,
      "text": "lcm(.,.) least common multiple of two nonnegative integers",
      "ja": "lcm（。、。）2つの負でない整数の最小公倍数"
    },
    {
      "indent": 3,
      "text": "m message representative, an integer between 0 and n-1",
      "ja": "mメッセージの代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "M message, an octet string",
      "ja": "Mメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "MGF mask generation function",
      "ja": "MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "n modulus",
      "ja": "n係数"
    },
    {
      "indent": 3,
      "text": "P encoding parameters, an octet string",
      "ja": "Pエンコーディングパラメータ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "p,q prime factors of the modulus",
      "ja": "モジュラスのp、q素因数"
    },
    {
      "indent": 3,
      "text": "qInv CRT coefficient, a positive integer less than p such: q(qInv)\\equiv 1 (mod p)",
      "ja": "qInv CRT係数、p未満の正の整数：q（qInv）\\ equiv 1（mod p）"
    },
    {
      "indent": 3,
      "text": "s signature representative, an integer between 0 and n-1",
      "ja": "s代表的な署名、0からn-1までの整数"
    },
    {
      "indent": 3,
      "text": "S signature, an octet string",
      "ja": "S署名、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "x a nonnegative integer",
      "ja": "xは負でない整数"
    },
    {
      "indent": 3,
      "text": "X an octet string corresponding to x",
      "ja": "X xに対応するオクテット文字列"
    },
    {
      "indent": 3,
      "text": "\\xor bitwise exclusive-or of two octet strings",
      "ja": "\\ xor 2つのオクテット文字列のビット単位の排他的論理和"
    },
    {
      "indent": 3,
      "text": "\\lambda(n)    lcm(p-1, q-1), where n = pq",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|| concatenation operator",
      "ja": "||連結演算子"
    },
    {
      "indent": 3,
      "text": "||.|| octet length operator",
      "ja": "||。||オクテット長演算子"
    },
    {
      "indent": 0,
      "text": "3. Key types",
      "section_title": true,
      "ja": "3. キーのタイプ"
    },
    {
      "indent": 3,
      "text": "Two key types are employed in the primitives and schemes defined in this document: RSA public key and RSA private key. Together, an RSA public key and an RSA private key form an RSA key pair.",
      "ja": "このドキュメントで定義されているプリミティブとスキームでは、RSA公開鍵とRSA秘密鍵の2つの鍵タイプが採用されています。 RSA公開鍵とRSA秘密鍵を組み合わせて、RSA鍵ペアを形成します。"
    },
    {
      "indent": 0,
      "text": "3.1 RSA public key",
      "section_title": true,
      "ja": "3.1 RSA公開鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA public key consists of two components:",
      "ja": "このドキュメントでは、RSA公開鍵は2つのコンポーネントで構成されています。"
    },
    {
      "indent": 3,
      "text": "n, the modulus, a nonnegative integer e, the public exponent, a nonnegative integer",
      "ja": "n、係数、非負の整数e、公開指数、非負の整数"
    },
    {
      "indent": 3,
      "text": "In a valid RSA public key, the modulus n is a product of two odd primes p and q, and the public exponent e is an integer between 3 and n-1 satisfying gcd (e, \\lambda(n)) = 1, where \\lambda(n) = lcm (p-1,q-1). A recommended syntax for interchanging RSA public keys between implementations is given in Section 11.1.1; an implementation's internal representation may differ.",
      "ja": "有効なRSA公開鍵では、係数nは2つの奇数素数pとqの積であり、公開指数eは3とn-1の間の整数で、gcd（e、\\ lambda（n））= 1を満たします。 \\ lambda（n）= lcm（p-1、q-1）。実装間でRSA公開鍵を交換するための推奨構文は、セクション11.1.1に記載されています。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2 RSA private key",
      "section_title": true,
      "ja": "3.2 RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA private key may have either of two representations.",
      "ja": "このドキュメントでは、RSA秘密鍵は2つの表現のいずれかを持つ場合があります。"
    },
    {
      "indent": 3,
      "text": "1. The first representation consists of the pair (n, d), where the components have the following meanings:",
      "ja": "1. 最初の表現は、ペア（n、d）で構成されます。ここで、コンポーネントには次の意味があります。"
    },
    {
      "indent": 3,
      "text": "n, the modulus, a nonnegative integer d, the private exponent, a nonnegative integer",
      "ja": "n、係数、非負の整数d、プライベート指数、非負の整数"
    },
    {
      "indent": 3,
      "text": "2. The second representation consists of a quintuple (p, q, dP, dQ, qInv), where the components have the following meanings:",
      "ja": "2. 2番目の表現は、5要素（p、q、dP、dQ、qInv）で構成されます。ここで、コンポーネントには次の意味があります。"
    },
    {
      "indent": 3,
      "text": "p, the first factor, a nonnegative integer q, the second factor, a nonnegative integer dP, the first factor's exponent, a nonnegative integer dQ, the second factor's exponent, a nonnegative integer qInv, the CRT coefficient, a nonnegative integer",
      "ja": "p、最初の因子、非負の整数q、2番目の因子、非負の整数dP、最初の因子の指数、非負の整数dQ、2番目の因子の指数、非負の整数qInv、CRT係数、非負の整数"
    },
    {
      "indent": 0,
      "text": " In a valid RSA private key with the first representation, the modulus n is the same as in the corresponding public key and is the product of two odd primes p and q, and the private exponent d is a positive integer less than n satisfying:",
      "ja": "最初の表現の有効なRSA秘密鍵では、係数nは対応する公開鍵の場合と同じであり、2つの奇数素数pとqの積であり、秘密指数dはnより小さい正の整数で、次の条件を満たす。"
    },
    {
      "indent": 3,
      "text": "ed \\equiv 1 (mod \\lambda(n))",
      "ja": "ed \\ equiv 1（mod \\ lambda（n））"
    },
    {
      "indent": 3,
      "text": "where e is the corresponding public exponent and \\lambda(n) is as defined above.",
      "ja": "ここで、eは対応する公開指数であり、\\ lambda（n）は上記で定義したとおりです。"
    },
    {
      "indent": 3,
      "text": "In a valid RSA private key with the second representation, the two factors p and q are the prime factors of the modulus n, the exponents dP and dQ are positive integers less than p and q respectively satisfying",
      "ja": "2番目の表現を持つ有効なRSA秘密鍵では、2つの因数pおよびqは係数nの素因数であり、指数dPおよびdQはpおよびqより小さい正の整数であり、それぞれ次の条件を満たす"
    },
    {
      "indent": 3,
      "text": "e(dP)\\equiv 1(mod(p-1)) e(dQ)\\equiv 1(mod(q-1)),",
      "ja": "e（dP）\\ equiv 1（mod（p-1））e（dQ）\\ equiv 1（mod（q-1））、"
    },
    {
      "indent": 3,
      "text": "and the CRT coefficient qInv is a positive integer less than p satisfying:",
      "ja": "また、CRT係数qInvは、次の条件を満たすpより小さい正の整数です。"
    },
    {
      "indent": 3,
      "text": "q(qInv)\\equiv 1 (mod p).",
      "ja": "q（qInv）\\ equiv 1（mod p）。"
    },
    {
      "indent": 3,
      "text": "A recommended syntax for interchanging RSA private keys between implementations, which includes components from both representations, is given in Section 11.1.2; an implementation's internal representation may differ.",
      "ja": "実装間でRSA秘密鍵を交換するための推奨構文は、両方の表現からのコンポーネントを含み、セクション11.1.2に示されています。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Data conversion primitives",
      "section_title": true,
      "ja": "4. データ変換プリミティブ"
    },
    {
      "indent": 3,
      "text": "Two data conversion primitives are employed in the schemes defined in this document:",
      "ja": "このドキュメントで定義されているスキームでは、2つのデータ変換プリミティブが採用されています。"
    },
    {
      "indent": 3,
      "text": "I2OSP: Integer-to-Octet-String primitive OS2IP: Octet-String-to-Integer primitive",
      "ja": "I2OSP：Integer-to-Octet-StringプリミティブOS2IP：Octet-String-to-Integerプリミティブ"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, and consistent with ASN.1 syntax, an octet string is an ordered sequence of octets (eight-bit bytes). The sequence is indexed from first (conventionally, leftmost) to last (rightmost). For purposes of conversion to and from integers, the first octet is considered the most significant in the following conversion primitives",
      "ja": "このドキュメントの目的のために、ASN.1構文と一致して、オクテット文字列はオクテット（8ビットバイト）の順序付けられたシーケンスです。シーケンスには、最初（通常は左端）から最後（右端）までインデックスが付けられます。整数との間の変換のために、最初のオクテットは次の変換プリミティブで最も重要であると見なされます"
    },
    {
      "indent": 0,
      "text": "4.1 I2OSP",
      "section_title": true,
      "ja": "4.1 I2OSP"
    },
    {
      "indent": 3,
      "text": "I2OSP converts a nonnegative integer to an octet string of a specified length.",
      "ja": "I2OSPは、負でない整数を指定された長さのオクテット文字列に変換します。"
    },
    {
      "indent": 0,
      "text": " I2OSP (x, l) Input: x nonnegative integer to be converted l intended length of the resulting octet string",
      "ja": "I2OSP（x、l）入力：変換されるx非負整数l結果のオクテット文字列の意図された長さ"
    },
    {
      "indent": 3,
      "text": "Output: X corresponding octet string of length l; or \"integer too large\"",
      "ja": "出力：長さlのX対応オクテット文字列。または「整数が大きすぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If x>=256^l, output \"integer too large\" and stop.",
      "ja": "1. x> = 256 ^ lの場合、「整数が大きすぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Write the integer x in its unique l-digit representation base 256:",
      "ja": "2. 整数xを、256をベースとする一意のl桁表現で記述します。"
    },
    {
      "indent": 3,
      "text": "x = x_{l-1}256^{l-1} + x_{l-2}256^{l-2} +... + x_1 256 + x_0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where 0 <= x_i < 256 (note that one or more leading digits will be zero if x < 256^{l-1}).",
      "ja": "ここで、0 <= x_i <256（x <256 ^ {l-1}の場合、1つ以上の先行桁はゼロになることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "3. Let the octet X_i have the value x_{l-i} for 1 <= i <= l. Output the octet string:",
      "ja": "3. オクテットX_iに1 <= i <= lの値x_ {l-i}があるとします。オクテット文字列を出力します。"
    },
    {
      "indent": 3,
      "text": "X = X_1 X_2 ... X_l.",
      "ja": "X = X_1 X_2 ... X_l。"
    },
    {
      "indent": 0,
      "text": "4.2 OS2IP",
      "section_title": true,
      "ja": "4.2 OS2IP"
    },
    {
      "indent": 3,
      "text": "OS2IP converts an octet string to a nonnegative integer.",
      "ja": "OS2IPは、オクテット文字列を非負の整数に変換します。"
    },
    {
      "indent": 3,
      "text": "OS2IP (X)",
      "ja": "OS2IP（X）"
    },
    {
      "indent": 3,
      "text": "Input: X octet string to be converted",
      "ja": "入力：変換されるXオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: x corresponding nonnegative integer",
      "ja": "出力：xに対応する負でない整数"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. Let X_1 X_2 ... X_l be the octets of X from first to last, and let x{l-i} have value X_i for 1<= i <= l.",
      "ja": "1. X_1 X_2 ... X_lを最初から最後までのXのオクテットとし、x {l-i}に1 <= i <= lの値X_iを与えます。"
    },
    {
      "indent": 3,
      "text": "2. Let x = x{l-1} 256^{l-1} + x_{l-2} 256^{l-2} +...+ x_1 256 + x_0.",
      "ja": "2. x = x {l-1} 256 ^ {l-1} + x_ {l-2} 256 ^ {l-2} + ... + x_1 256 + x_0とします。"
    },
    {
      "indent": 3,
      "text": "3. Output x.",
      "ja": "3. 出力x。"
    },
    {
      "indent": 0,
      "text": "5. Cryptographic primitives",
      "section_title": true,
      "ja": "5. 暗号プリミティブ"
    },
    {
      "indent": 3,
      "text": "Cryptographic primitives are basic mathematical operations on which cryptographic schemes can be built. They are intended for implementation in hardware or as software modules, and are not intended to provide security apart from a scheme.",
      "ja": "暗号プリミティブは、暗号スキームを構築できる基本的な数学演算です。これらは、ハードウェアまたはソフトウェアモジュールとしての実装を目的としており、スキーム以外のセキュリティを提供することを目的としていません。"
    },
    {
      "indent": 3,
      "text": "Four types of primitive are specified in this document, organized in pairs: encryption and decryption; and signature and verification.",
      "ja": "このドキュメントでは、4つのタイプのプリミティブがペアで編成されて指定されています。暗号化と復号化。署名と検証。"
    },
    {
      "indent": 3,
      "text": "The specifications of the primitives assume that certain conditions are met by the inputs, in particular that public and private keys are valid.",
      "ja": "プリミティブの仕様は、特定の条件が入力によって満たされていること、特に公開鍵と秘密鍵が有効であることを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.1 Encryption and decryption primitives",
      "section_title": true,
      "ja": "5.1 暗号化および復号化プリミティブ"
    },
    {
      "indent": 3,
      "text": "An encryption primitive produces a ciphertext representative from a message representative under the control of a public key, and a decryption primitive recovers the message representative from the ciphertext representative under the control of the corresponding private key.",
      "ja": "暗号化プリミティブは、公開鍵の制御下でメッセージ代表から暗号文代表を生成し、復号化プリミティブは、対応する秘密鍵の制御下で暗号文代表からメッセージ代表を復元します。"
    },
    {
      "indent": 3,
      "text": "One pair of encryption and decryption primitives is employed in the encryption schemes defined in this document and is specified here: RSAEP/RSADP. RSAEP and RSADP involve the same mathematical operation, with different keys as input.",
      "ja": "このドキュメントで定義されている暗号化スキームでは、1組の暗号化および復号化プリミティブが採用されており、RSAEP / RSADPで指定されています。 RSAEPとRSADPは、入力として異なるキーを使用して、同じ数学演算を実行します。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as in the draft IEEE P1363 and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されているプリミティブは、IEEE P1363ドラフトと同じであり、PKCS＃1 v1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation.",
      "ja": "各プリミティブの主な数学演算は、べき乗です。"
    },
    {
      "indent": 0,
      "text": "5.1.1 RSAEP",
      "section_title": true,
      "ja": "5.1.1 RSAEP"
    },
    {
      "indent": 3,
      "text": "RSAEP((n, e), m)",
      "ja": "RSAEP（（n、e）、m）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key m message representative, an integer between 0 and n-1",
      "ja": "入力：（n、e）RSA公開鍵mメッセージの代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "Output: c ciphertext representative, an integer between 0 and n-1; or \"message representative out of range\"",
      "ja": "出力：c暗号文の代表、0〜n-1の整数。または「範囲外のメッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "前提：公開鍵（n、e）は有効です"
    },
    {
      "indent": 0,
      "text": " Steps: 1. If the message representative m is not between 0 and n-1, output message representative out of range and stop.",
      "ja": "手順：1.メッセージ代表mが0とn-1の間にない場合、範囲外のメッセージを出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Let c = m^e mod n.",
      "ja": "2. c = m ^ e mod nとします。"
    },
    {
      "indent": 3,
      "text": "3. Output c.",
      "ja": "3. 出力c。"
    },
    {
      "indent": 0,
      "text": "5.1.2 RSADP",
      "section_title": true,
      "ja": "5.1.2 RSADP"
    },
    {
      "indent": 3,
      "text": "RSADP (K, c)",
      "ja": "RSADP（K、c）"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "K RSA private key, where K has one of the following forms -a pair (n, d) -a quintuple (p, q, dP, dQ, qInv) c ciphertext representative, an integer between 0 and n-1",
      "ja": "K RSA秘密鍵、ここでKは次の形式のいずれか-aペア（n、d）-5組（p、q、dP、dQ、qInv）c暗号文の代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n-1; or \"ciphertext representative out of range\"",
      "ja": "出力：メッセージを表すm、0〜n-1の整数。または「範囲外の暗号文の代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: private key K is valid",
      "ja": "前提：秘密鍵Kは有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the ciphertext representative c is not between 0 and n-1, output \"ciphertext representative out of range\" and stop.",
      "ja": "1. 暗号文の代表cが0とn-1の間にない場合は、「暗号文の代表が範囲外です」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. If the first form (n, d) of K is used:",
      "ja": "2. Kの最初の形式（n、d）が使用される場合："
    },
    {
      "indent": 3,
      "text": "2.1 Let m = c^d mod n. Else, if the second form (p, q, dP, dQ, qInv) of K is used:",
      "ja": "2.1 m = c ^ d mod nとします。または、Kの2番目の形式（p、q、dP、dQ、qInv）が使用されている場合："
    },
    {
      "indent": 3,
      "text": "2.2 Let m_1 = c^dP mod p.",
      "ja": "2.2 m_1 = c ^ dP mod pとします。"
    },
    {
      "indent": 3,
      "text": "2.3 Let m_2 = c^dQ mod q.",
      "ja": "2.3 m_2 = c ^ dQ mod qとします。"
    },
    {
      "indent": 3,
      "text": "2.4 Let h = qInv ( m_1 - m_2 ) mod p.",
      "ja": "2.4 h = qInv（m_1-m_2）mod pとします。"
    },
    {
      "indent": 3,
      "text": "2.5 Let m = m_2 + hq.",
      "ja": "2.5 m = m_2 + hqとします。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "ja": "3. 出力m。"
    },
    {
      "indent": 0,
      "text": "5.2 Signature and verification primitives",
      "section_title": true,
      "ja": "5.2 署名および検証プリミティブ"
    },
    {
      "indent": 3,
      "text": "A signature primitive produces a signature representative from a message representative under the control of a private key, and a verification primitive recovers the message representative from the signature representative under the control of the corresponding public key. One pair of signature and verification primitives is employed in the signature schemes defined in this document and is specified here: RSASP1/RSAVP1.",
      "ja": "署名プリミティブは、秘密鍵の制御下でメッセージ代表から署名代表を生成し、検証プリミティブは、対応する公開鍵の制御下で署名代表からメッセージ代表を回復します。署名および検証プリミティブの1つのペアは、このドキュメントで定義されている署名方式で使用され、RSASP1 / RSAVP1で指定されています。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as in the draft IEEE P1363 and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されているプリミティブは、IEEE P1363ドラフトと同じであり、PKCS＃1 v1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation, as in the encryption and decryption primitives of Section 5.1. RSASP1 and RSAVP1 are the same as RSADP and RSAEP except for the names of their input and output arguments; they are distinguished as they are intended for different purposes.",
      "ja": "各プリミティブの主な数学演算は、セクション5.1の暗号化および復号化プリミティブと同様に、べき乗です。 RSASP1とRSAVP1は、入力引数と出力引数の名前を除いて、RSADPとRSAEPと同じです。それらは異なる目的を意図しているため区別されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1 RSASP1",
      "section_title": true,
      "ja": "5.2.1 RSASP1"
    },
    {
      "indent": 3,
      "text": "RSASP1 (K, m)",
      "ja": "RSASP1（K、m）"
    },
    {
      "indent": 3,
      "text": "Input: K RSA private key, where K has one of the following forms: -a pair (n, d) -a quintuple (p, q, dP, dQ, qInv)",
      "ja": "入力：K RSA秘密鍵。Kの形式は次のいずれかです。-aペア（n、d）-a 5組（p、q、dP、dQ、qInv）"
    },
    {
      "indent": 3,
      "text": "m message representative, an integer between 0 and n-1",
      "ja": "mメッセージの代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "Output: s signature representative, an integer between 0 and n-1, or \"message representative out of range\"",
      "ja": "出力：s代表的な署名、0からn-1までの整数、または「範囲外のメッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: private key K is valid",
      "ja": "前提：秘密鍵Kは有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the message representative m is not between 0 and n-1, output \"message representative out of range\" and stop.",
      "ja": "1. メッセージ代表mが0とn-1の間にない場合、「範囲外メッセージ代表」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. If the first form (n, d) of K is used:",
      "ja": "2. Kの最初の形式（n、d）が使用される場合："
    },
    {
      "indent": 0,
      "text": " 2.1 Let s = m^d mod n. Else, if the second form (p, q, dP, dQ, qInv) of K is used: 2.2 Let s_1 = m^dP mod p.",
      "ja": "2.1 s = m ^ d mod nとします。そうでない場合、Kの2番目の形式（p、q、dP、dQ、qInv）が使用される場合：2.2 s_1 = m ^ dP mod pとします。"
    },
    {
      "indent": 3,
      "text": "2.3 Let s_2 = m^dQ mod q.",
      "ja": "2.3 s_2 = m ^ dQ mod qとします。"
    },
    {
      "indent": 3,
      "text": "2.4 Let h = qInv ( s_1 - s_2 ) mod p.",
      "ja": "2.4 h = qInv（s_1-s_2）mod pとします。"
    },
    {
      "indent": 3,
      "text": "2.5 Let s = s_2 + hq.",
      "ja": "2.5 s = s_2 + hqとします。"
    },
    {
      "indent": 3,
      "text": "3. Output S.",
      "ja": "3. 出力S"
    },
    {
      "indent": 0,
      "text": "5.2.2 RSAVP1",
      "section_title": true,
      "ja": "5.2.2 RSAVP1"
    },
    {
      "indent": 3,
      "text": "RSAVP1 ((n, e), s)",
      "ja": "RSAVP1（（n、e）、s）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key s signature representative, an integer between 0 and n-1",
      "ja": "入力：（n、e）RSA公開鍵の署名代表、0〜n-1の整数"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n-1; or \"invalid\"",
      "ja": "出力：メッセージを表すm、0〜n-1の整数。または「無効」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "前提：公開鍵（n、e）は有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the signature representative s is not between 0 and n-1, output \"invalid\" and stop.",
      "ja": "1. 署名の代表sが0とn-1の間にない場合、「無効」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Let m = s^e mod n.",
      "ja": "2. m = s ^ e mod nとします。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "ja": "3. 出力m。"
    },
    {
      "indent": 0,
      "text": "6. Overview of schemes",
      "section_title": true,
      "ja": "6. スキームの概要"
    },
    {
      "indent": 3,
      "text": "A scheme combines cryptographic primitives and other techniques to achieve a particular security goal. Two types of scheme are specified in this document: encryption schemes and signature schemes with appendix.",
      "ja": "スキームは、特定のセキュリティ目標を達成するために、暗号プリミティブと他の技術を組み合わせています。このドキュメントでは、暗号化スキームと付録付きの署名スキームの2種類のスキームが指定されています。"
    },
    {
      "indent": 3,
      "text": "The schemes specified in this document are limited in scope in that their operations consist only of steps to process data with a key, and do not include steps for obtaining or validating the key. Thus, in addition to the scheme operations, an application will typically include key management operations by which parties may select public and private keys for a scheme operation. The specific additional operations and other details are outside the scope of this document.",
      "ja": "このドキュメントで指定されているスキームは、その操作がキーでデータを処理するステップのみで構成され、キーを取得または検証するステップを含まないという点で範囲が制限されています。したがって、スキーム操作に加えて、アプリケーションには通常、関係者がスキーム操作の公開鍵と秘密鍵を選択できる鍵管理操作が含まれます。特定の追加操作およびその他の詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "As was the case for the cryptographic primitives (Section 5), the specifications of scheme operations assume that certain conditions are met by the inputs, in particular that public and private keys are valid. The behavior of an implementation is thus unspecified when a key is invalid. The impact of such unspecified behavior depends on the application. Possible means of addressing key validation include explicit key validation by the application; key validation within the public-key infrastructure; and assignment of liability for operations performed with an invalid key to the party who generated the key.",
      "ja": "暗号プリミティブ（セクション5）の場合と同様に、スキーム操作の仕様は、特定の条件が入力によって満たされること、特に公開鍵と秘密鍵が有効であることを前提としています。したがって、キーが無効な場合の実装の動作は規定されていません。このような不特定の動作の影響は、アプリケーションによって異なります。キーの検証に対処するための可能な手段には、アプリケーションによる明示的なキーの検証が含まれます。公開鍵インフラストラクチャ内の鍵の検証。無効なキーで実行された操作に対する責任の、キーを生成した当事者への割り当て。"
    },
    {
      "indent": 0,
      "text": "7. Encryption schemes",
      "section_title": true,
      "ja": "7. 暗号化スキーム"
    },
    {
      "indent": 3,
      "text": "An encryption scheme consists of an encryption operation and a decryption operation, where the encryption operation produces a ciphertext from a message with a recipient's public key, and the decryption operation recovers the message from the ciphertext with the recipient's corresponding private key.",
      "ja": "暗号化スキームは、暗号化操作と復号化操作で構成されます。暗号化操作では、受信者の公開鍵を含むメッセージから暗号文が生成され、復号化操作によって、受信者の対応する秘密鍵を含む暗号文からメッセージが復元されます。"
    },
    {
      "indent": 3,
      "text": "An encryption scheme can be employed in a variety of applications. A typical application is a key establishment protocol, where the message contains key material to be delivered confidentially from one party to another. For instance, PKCS #7 [21] employs such a protocol to deliver a content-encryption key from a sender to a recipient; the encryption schemes defined here would be suitable key-encryption algorithms in that context.",
      "ja": "暗号化スキームは、さまざまなアプリケーションで使用できます。典型的なアプリケーションは鍵確立プロトコルであり、メッセージには、ある当事者から別の当事者に秘密裏に配信される鍵素材が含まれています。たとえば、PKCS＃7 [21]は、このようなプロトコルを使用して、コンテンツ暗号化キーを送信者から受信者に配信します。ここで定義されている暗号化スキームは、そのコンテキストで適切なキー暗号化アルゴリズムになります。"
    },
    {
      "indent": 3,
      "text": "Two encryption schemes are specified in this document: RSAES-OAEP and RSAES-PKCS1-v1_5. RSAES-OAEP is recommended for new applications; RSAES-PKCS1-v1_5 is included only for compatibility with existing applications, and is not recommended for new applications.",
      "ja": "このドキュメントでは、RSAES-OAEPとRSAES-PKCS1-v1_5の2つの暗号化スキームを指定しています。 RSAES-OAEPは新しいアプリケーションに推奨されます。 RSAES-PKCS1-v1_5は、既存のアプリケーションとの互換性のためにのみ含まれており、新しいアプリケーションには推奨されません。"
    },
    {
      "indent": 3,
      "text": "The encryption schemes given here follow a general model similar to that employed in IEEE P1363, by combining encryption and decryption primitives with an encoding method for encryption. The encryption operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. An encryption primitive is applied to the message representative to produce the ciphertext. Reversing this, the decryption operations apply a decryption primitive to the ciphertext to recover a message representative, which is then converted to an octet string encoded message. A message decoding operation is applied to the encoded message to recover the message and verify the correctness of the decryption.",
      "ja": "ここで示す暗号化方式は、IEEE P1363で採用されているものと同様の一般的なモデルに従い、暗号化および復号化プリミティブと暗号化のエンコード方式を組み合わせています。暗号化操作は、メッセージエンコード操作をメッセージに適用して、エンコードされたメッセージを生成します。その後、エンコードされたメッセージは、整数のメッセージ表現に変換されます。暗号化プリミティブがメッセージ代表に適用され、暗号文が生成されます。これを逆にすると、解読操作は解読プリミティブを暗号文に適用してメッセージの代表を復元し、次にそれをオクテットストリングでエンコードされたメッセージに変換します。エンコードされたメッセージにメッセージデコード操作を適用して、メッセージを復元し、復号の正当性を検証します。"
    },
    {
      "indent": 0,
      "text": "7.1 RSAES-OAEP",
      "section_title": true,
      "ja": "7.1 RSAES-OAEP"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME-OAEP encoding method (Section 9.1.1) EME-OAEP is based on the method found in [2]. It is compatible with the IFES scheme defined in the draft P1363 where the encryption and decryption primitives are IFEP-RSA and IFDP-RSA and the message encoding method is EME-OAEP. RSAES-OAEP can operate on messages of length up to k-2- 2hLen octets, where hLen is the length of the hash function output for EME-OAEP and k is the length in octets of the recipient's RSA modulus. Assuming that the hash function in EME-OAEP has appropriate properties, and the key size is sufficiently large, RSAEP-OAEP provides \"plaintext-aware encryption,\" meaning that it is computationally infeasible to obtain full or partial information about a message from a ciphertext, and computationally infeasible to generate a valid ciphertext without knowing the corresponding message. Therefore, a chosen-ciphertext attack is ineffective against a plaintext-aware encryption scheme such as RSAES-OAEP.",
      "ja": "RSAES-OAEPは、RSAEPおよびRSADPプリミティブ（セクション5.1.1および5.1.2）とEME-OAEPエンコーディング方式（セクション9.1.1）を組み合わせたものです。EME-OAEPは、[2]にある方法に基づいています。これは、P1363ドラフトで定義されているIFESスキームと互換性があり、暗号化および復号化プリミティブはIFEP-RSAおよびIFDP-RSAであり、メッセージエンコーディング方式はEME-OAEPです。 RSAES-OAEPは、最大k-2-2hLenオクテットの長さのメッセージを操作できます。hLenはEME-OAEPのハッシュ関数出力の長さであり、kは受信者のRSAモジュラスのオクテット単位の長さです。 EME-OAEPのハッシュ関数に適切なプロパティがあり、キーサイズが十分に大きいと仮定すると、RSAEP-OAEPは「プレーンテキスト対応の暗号化」を提供します。つまり、暗号文からメッセージに関する完全または部分的な情報を取得することは計算上不可能です。 、および対応するメッセージを知らずに有効な暗号文を生成することは計算上不可能です。したがって、選択された暗号文攻撃は、RSAES-OAEPなどの平文対応の暗号化スキームに対しては効果がありません。"
    },
    {
      "indent": 3,
      "text": "Both the encryption and the decryption operations of RSAES-OAEP take the value of the parameter string P as input. In this version of PKCS #1, P is an octet string that is specified explicitly. See Section 11.2.1 for the relevant ASN.1 syntax. We briefly note that to receive the full security benefit of RSAES-OAEP, it should not be used in a protocol involving RSAES-PKCS1-v1_5. It is possible that in a protocol on which both encryption schemes are present, an adaptive chosen ciphertext attack such as [4] would be useful.",
      "ja": "RSAES-OAEPの暗号化操作と復号化操作はどちらも、パラメーター文字列Pの値を入力として受け取ります。このバージョンのPKCS＃1では、Pは明示的に指定されたオクテット文字列です。関連するASN.1構文については、セクション11.2.1を参照してください。 RSAES-OAEPの完全なセキュリティ上の利点を享受するために、RSAES-PKCS1-v1_5を含むプロトコルでは使用しないでください。両方の暗号化スキームが存在するプロトコルでは、[4]のような適応選択暗号文攻撃が役立つ可能性があります。"
    },
    {
      "indent": 3,
      "text": "Both the encryption and the decryption operations of RSAES-OAEP take the value of the parameter string P as input. In this version of PKCS #1, P is an octet string that is specified explicitly. See Section 11.2.1 for the relevant ASN.1 syntax.",
      "ja": "RSAES-OAEPの暗号化操作と復号化操作はどちらも、パラメーター文字列Pの値を入力として受け取ります。このバージョンのPKCS＃1では、Pは明示的に指定されたオクテット文字列です。関連するASN.1構文については、セクション11.2.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.1 Encryption operation",
      "section_title": true,
      "ja": "7.1.1 暗号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-ENCRYPT ((n, e), M, P)",
      "ja": "RSAES-OAEP-ENCRYPT（（n、e）、M、P）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key",
      "ja": "入力：（n、e）受信者のRSA公開鍵"
    },
    {
      "indent": 3,
      "text": "M message to be encrypted, an octet string of length at most k-2-2hLen, where k is the length in octets of the modulus n and hLen is the length in octets of the hash function output for EME-OAEP",
      "ja": "暗号化されるMメッセージ、長さが最大でk-2-2hLenのオクテット文字列。ここで、kはモジュラスnのオクテット単位の長さ、hLenはEME-OAEPのハッシュ関数出力のオクテット単位の長さ"
    },
    {
      "indent": 0,
      "text": " P encoding parameters, an octet string that may be empty Output: C ciphertext, an octet string of length k; or \"message too long\"",
      "ja": "Pエンコーディングパラメータ、空のオクテット文字列出力：C暗号文、長さkのオクテット文字列。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "前提：公開鍵（n、e）は有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. Apply the EME-OAEP encoding operation (Section 9.1.1.2) to the message M and the encoding parameters P to produce an encoded message EM of length k-1 octets:",
      "ja": "1. EME-OAEPエンコーディング操作（セクション9.1.1.2）をメッセージMおよびエンコーディングパラメータPに適用して、長さk-1オクテットのエンコードされたメッセージEMを生成します。"
    },
    {
      "indent": 3,
      "text": "EM = EME-OAEP-ENCODE (M, P, k-1)",
      "ja": "EM = EME-OAEP-ENCODE（M、P、k-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop.",
      "ja": "エンコード操作で「メッセージが長すぎます」と出力された場合は、「メッセージが長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "2. エンコードされたメッセージEMを整数のメッセージ代表mに変換します。m= OS2IP（EM）"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAEP encryption primitive (Section 5.1.1) to the public key (n, e) and the message representative m to produce an integer ciphertext representative c:",
      "ja": "3. RSAEP暗号化プリミティブ（セクション5.1.1）を公開鍵（n、e）およびメッセージ代表mに適用して、整数の暗号文代表cを生成します。"
    },
    {
      "indent": 3,
      "text": "c = RSAEP ((n, e), m)",
      "ja": "c = RSAEP（（n、e）、m）"
    },
    {
      "indent": 3,
      "text": "4. Convert the ciphertext representative c to a ciphertext C of length k octets: C = I2OSP (c, k)",
      "ja": "4. 暗号文の代表cを長さkオクテットの暗号文Cに変換します。C= I2OSP（c、k）"
    },
    {
      "indent": 3,
      "text": "5. Output the ciphertext C.",
      "ja": "5. 暗号文Cを出力します。"
    },
    {
      "indent": 0,
      "text": "7.1.2 Decryption operation",
      "section_title": true,
      "ja": "7.1.2 復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-DECRYPT (K, C, P)",
      "ja": "RSAES-OAEP-DECRYPT（K、C、P）"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key C ciphertext to be decrypted, an octet string of length k, where k is the length in octets of the modulus n P encoding parameters, an octet string that may be empty",
      "ja": "入力：復号化されるK受信者のRSA秘密鍵C暗号文、長さkのオクテット文字列、ここでkはモジュラスn Pエンコードパラメーターのオクテット単位の長さ、空のオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length at most k-2-2hLen, where hLen is the length in octets of the hash function output for EME-OAEP; or \"decryption error\"",
      "ja": "出力：Mメッセージ、最大k-2-2hLenの長さのオクテット文字列。ここで、hLenはEME-OAEPのハッシュ関数出力のオクテット単位の長さです。または「復号化エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of the ciphertext C is not k octets, output \"decryption error\" and stop.",
      "ja": "1. 暗号文Cの長さがkオクテットでない場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Convert the ciphertext C to an integer ciphertext representative c: c = OS2IP (C).",
      "ja": "2. 暗号文Cを整数の暗号文代表cに変換します：c = OS2IP（C）。"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSADP decryption primitive (Section 5.1.2) to the private key K and the ciphertext representative c to produce an integer message representative m:",
      "ja": "3. RSADP復号プリミティブ（セクション5.1.2）を秘密鍵Kと暗号文の代表cに適用して、整数のメッセージ代表mを生成します。"
    },
    {
      "indent": 3,
      "text": "m = RSADP (K, c)",
      "ja": "m = RSADP（K、c）"
    },
    {
      "indent": 3,
      "text": "If RSADP outputs \"ciphertext out of range,\" then output \"decryption error\" and stop.",
      "ja": "RSADPが「範囲外の暗号文」を出力した場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "4. メッセージ代表mを、長さk-1オクテットのエンコードされたメッセージEMに変換します。EM= I2OSP（m、k-1）"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"decryption error\" and stop.",
      "ja": "I2OSPが「整数が大きすぎる」と出力した場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EME-OAEP decoding operation to the encoded message EM and the encoding parameters P to recover a message M:",
      "ja": "5. EME-OAEPデコード操作をエンコードされたメッセージEMとエンコードパラメーターPに適用して、メッセージMを復元します。"
    },
    {
      "indent": 3,
      "text": "M = EME-OAEP-DECODE (EM, P)",
      "ja": "M = EME-OAEP-DECODE（EM、P）"
    },
    {
      "indent": 3,
      "text": "If the decoding operation outputs \"decoding error,\" then output \"decryption error\" and stop.",
      "ja": "復号化操作が「復号化エラー」を出力した場合、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "6. Output the message M.",
      "ja": "6. メッセージMを出力します。"
    },
    {
      "indent": 3,
      "text": "Note. It is important that the error messages output in steps 4 and 5 be the same, otherwise an adversary may be able to extract useful information from the type of error message received. Error message information is used to mount a chosen-ciphertext attack on PKCS #1 v1.5 encrypted messages in [4].",
      "ja": "注意。手順4と5で出力されるエラーメッセージが同じであることが重要です。そうでない場合、攻撃者は受信したエラーメッセージのタイプから有用な情報を抽出できる可能性があります。エラーメッセージ情報は、[4]で選択された暗号文攻撃をPKCS＃1 v1.5暗号化メッセージにマウントするために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.2 RSAES-PKCS1-v1_5",
      "section_title": true,
      "ja": "7.2 RSAES-PKCS1-v1_5"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives with the EME-PKCS1-v1_5 encoding method. It is the same as the encryption scheme in PKCS #1 v1.5. RSAES-PKCS1-v1_5 can operate on messages of length up to k-11 octets, although care should be taken to avoid certain attacks on low-exponent RSA due to Coppersmith, et al. when long messages are encrypted (see the third bullet in the notes below and [7]).",
      "ja": "RSAES-PKCS1-v1_5は、RSAEPおよびRSADPプリミティブとEME-PKCS1-v1_5エンコーディング方式を組み合わせたものです。 PKCS＃1 v1.5の暗号化スキームと同じです。 RSAES-PKCS1-v1_5は、k-11オクテットまでの長さのメッセージを操作できますが、Coppersmithなどによる低指数RSAへの特定の攻撃を回避するように注意する必要があります。長いメッセージが暗号化される場合（下記の注の3番目の箇条書きと[7]を参照）。"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-v1_5 does not provide \"plaintext aware\" encryption. In particular, it is possible to generate valid ciphertexts without knowing the corresponding plaintexts, with a reasonable probability of success. This ability can be exploited in a chosen ciphertext attack as shown in [4]. Therefore, if RSAES-PKCS1-v1_5 is to be used, certain easily implemented countermeasures should be taken to thwart the attack found in [4]. The addition of structure to the data to be encoded, rigorous checking of PKCS #1 v1.5 conformance and other redundancy in decrypted messages, and the consolidation of error messages in a client-server protocol based on PKCS #1 v1.5 can all be effective countermeasures and don't involve changes to a PKCS #1 v1.5-based protocol. These and other countermeasures are discussed in [5].",
      "ja": "RSAES-PKCS1-v1_5は「プレーンテキスト対応」の暗号化を提供しません。特に、妥当な成功確率で、対応する平文を知らなくても有効な暗号文を生成することが可能です。この能力は、[4]に示すように、選択した暗号文攻撃で悪用される可能性があります。したがって、RSAES-PKCS1-v1_5を使用する場合、[4]にある攻撃を阻止するために、簡単に実装できる特定の対策を講じる必要があります。エンコードされるデータへの構造の追加、PKCS＃1 v1.5への厳密なチェック、および復号化されたメッセージにおけるその他の冗長性、およびPKCS＃1 v1.5に基づくクライアント/サーバープロトコルでのエラーメッセージの統合効果的な対策を行い、PKCS＃1 v1.5ベースのプロトコルへの変更を含まない。これらおよびその他の対策については、[5]で説明します。"
    },
    {
      "indent": 3,
      "text": "Notes. The following passages describe some security recommendations pertaining to the use of RSAES-PKCS1-v1_5. Recommendations from version 1.5 of this document are included as well as new recommendations motivated by cryptanalytic advances made in the intervening years.",
      "ja": "ノート。次の節では、RSAES-PKCS1-v1_5の使用に関するセキュリティの推奨事項について説明します。このドキュメントのバージョン1.5からの推奨事項に加えて、その間の年に行われた暗号解読の進歩によって動機付けられた新しい推奨事項が含まれています。"
    },
    {
      "indent": 3,
      "text": "-It is recommended that the pseudorandom octets in EME-PKCS1-v1_5 be generated independently for each encryption process, especially if the same data is input to more than one encryption process. Hastad's results [13] are one motivation for this recommendation.",
      "ja": "-特に同じデータが複数の暗号化プロセスに入力される場合は、EME-PKCS1-v1_5の疑似ランダムオクテットを暗号化プロセスごとに個別に生成することをお勧めします。ハスタッドの結果[13]は、この勧告の1つの動機です。"
    },
    {
      "indent": 3,
      "text": "-The padding string PS in EME-PKCS1-v1_5 is at least eight octets long, which is a security condition for public-key operations that prevents an attacker from recovering data by trying all possible encryption blocks.",
      "ja": "-EME-PKCS1-v1_5のパディング文字列PSは、少なくとも8オクテットの長さです。これは、攻撃者がすべての可能な暗号化ブロックを試行してデータを回復できないようにする公開鍵操作のセキュリティ条件です。"
    },
    {
      "indent": 3,
      "text": "-The pseudorandom octets can also help thwart an attack due to Coppersmith et al. [7] when the size of the message to be encrypted is kept small. The attack works on low-exponent RSA when similar messages are encrypted with the same public key. More specifically, in one flavor of the attack, when two inputs to RSAEP agree on a large fraction of bits (8/9) and low-exponent RSA (e = 3) is used to encrypt both of them, it may be possible to recover both inputs with the attack. Another flavor of the attack is successful in decrypting a single ciphertext when a large fraction (2/3) of the input to RSAEP is already known. For typical applications, the message to be encrypted is short (e.g., a 128-bit symmetric key) so not enough information will be known or common between two messages to enable the attack. However, if a long message is encrypted, or if part of a message is known, then the attack may be a concern. In any case, the RSAEP-OAEP scheme overcomes the attack.",
      "ja": "-疑似ランダムオクテットは、Coppersmithらによる攻撃の阻止にも役立ちます。 [7]暗号化するメッセージのサイズを小さく保つ場合。同様のメッセージが同じ公開鍵で暗号化されている場合、攻撃は低指数RSAで機能します。より具体的には、攻撃の1つのフレーバーで、RSAEPへの2つの入力がビットの大部分（8/9）に一致し、低指数RSA（e = 3）が両方の暗号化に使用される場合、攻撃で両方の入力を回復します。 RSAEPへの入力の大部分（2/3）が既知である場合、別の種類の攻撃は単一の暗号文の復号化に成功します。一般的なアプリケーションの場合、暗号化されるメッセージは短いため（128ビットの対称キーなど）、攻撃を可能にするために2つのメッセージ間で十分な情報が知られていないか、共通ではありません。ただし、長いメッセージが暗号化されている場合、またはメッセージの一部が既知である場合、攻撃が懸念される場合があります。いずれの場合でも、RSAEP-OAEPスキームは攻撃を克服します。"
    },
    {
      "indent": 0,
      "text": "7.2.1 Encryption operation",
      "section_title": true,
      "ja": "7.2.1 暗号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)",
      "ja": "RSAES-PKCS1-V1_5-ENCRYPT（（n、e）、M）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key M message to be encrypted, an octet string of length at most k-11 octets, where k is the length in octets of the modulus n",
      "ja": "入力：（n、e）暗号化される受信者のRSA公開鍵Mメッセージ、長さが最大でk-11オクテットのオクテット文字列。kはモジュラスnのオクテット単位の長さ"
    },
    {
      "indent": 3,
      "text": "Output: C ciphertext, an octet string of length k; or \"message too long\"",
      "ja": "出力：C暗号文、長さkのオクテット文字列。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. Apply the EME-PKCS1-v1_5 encoding operation (Section 9.1.2.1) to the message M to produce an encoded message EM of length k-1 octets:",
      "ja": "1. EME-PKCS1-v1_5エンコード操作（9.1.2.1節）をメッセージMに適用して、長さk-1オクテットのエンコードされたメッセージEMを生成します。"
    },
    {
      "indent": 3,
      "text": "EM = EME-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "EM = EME-PKCS1-V1_5-ENCODE（M、k-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop.",
      "ja": "エンコード操作で「メッセージが長すぎます」と出力された場合は、「メッセージが長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "2. エンコードされたメッセージEMを整数のメッセージ代表mに変換します。m= OS2IP（EM）"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAEP encryption primitive (Section 5.1.1) to the public key (n, e) and the message representative m to produce an integer ciphertext representative c: c = RSAEP ((n, e), m)",
      "ja": "3. RSAEP暗号化プリミティブ（セクション5.1.1）を公開鍵（n、e）およびメッセージ代表mに適用して、整数の暗号文代表cを生成します。c = RSAEP（（n、e）、m）"
    },
    {
      "indent": 3,
      "text": "4. Convert the ciphertext representative c to a ciphertext C of length k octets: C = I2OSP (c, k)",
      "ja": "4. 暗号文の代表cを長さkオクテットの暗号文Cに変換します。C= I2OSP（c、k）"
    },
    {
      "indent": 3,
      "text": "5. Output the ciphertext C.",
      "ja": "5. 暗号文Cを出力します。"
    },
    {
      "indent": 0,
      "text": "7.2.2 Decryption operation",
      "section_title": true,
      "ja": "7.2.2 復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-DECRYPT (K, C)",
      "ja": "RSAES-PKCS1-V1_5-DECRYPT（K、C）"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key C ciphertext to be decrypted, an octet string of length k, where k is the length in octets of the modulus n",
      "ja": "入力：復号化されるK受信者のRSA秘密鍵C暗号文、長さkのオクテット文字列。ここで、kはモジュラスnのオクテット単位の長さ"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length at most k-11; or \"decryption error\"",
      "ja": "出力：Mメッセージ、長さが最大でk-11のオクテット文字列。または「復号化エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of the ciphertext C is not k octets, output \"decryption error\" and stop.",
      "ja": "1. 暗号文Cの長さがkオクテットでない場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Convert the ciphertext C to an integer ciphertext representative c: c = OS2IP (C).",
      "ja": "2. 暗号文Cを整数の暗号文代表cに変換します：c = OS2IP（C）。"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSADP decryption primitive to the private key (n, d) and the ciphertext representative c to produce an integer message representative m: m = RSADP ((n, d), c).",
      "ja": "3. RSADP復号化プリミティブを秘密鍵（n、d）と暗号文代表cに適用して、整数メッセージ代表mを生成します。m = RSADP（（n、d）、c）。"
    },
    {
      "indent": 3,
      "text": "If RSADP outputs \"ciphertext out of range,\" then output \"decryption error\" and stop.",
      "ja": "RSADPが「範囲外の暗号文」を出力した場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "4. メッセージ代表mを、長さk-1オクテットのエンコードされたメッセージEMに変換します。EM= I2OSP（m、k-1）"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"decryption error\" and stop.",
      "ja": "I2OSPが「整数が大きすぎる」と出力した場合は、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EME-PKCS1-v1_5 decoding operation to the encoded message EM to recover a message M: M = EME-PKCS1-V1_5-DECODE (EM).",
      "ja": "5. Apply the EME-PKCS1-v1_5 decoding operation to the encoded message EM to recover a message M: M = EME-PKCS1-V1_5-DECODE (EM)."
    },
    {
      "indent": 3,
      "text": "If the decoding operation outputs \"decoding error,\" then output \"decryption error\" and stop.",
      "ja": "復号化操作が「復号化エラー」を出力した場合、「復号化エラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "6. Output the message M.",
      "ja": "6. メッセージMを出力します。"
    },
    {
      "indent": 3,
      "text": "Note. It is important that only one type of error message is output by EME-PKCS1-v1_5, as ensured by steps 4 and 5. If this is not done, then an adversary may be able to use information extracted form the type of error message received to mount a chosen-ciphertext attack such as the one found in [4].",
      "ja": "Note. It is important that only one type of error message is output by EME-PKCS1-v1_5, as ensured by steps 4 and 5. If this is not done, then an adversary may be able to use information extracted form the type of error message received to mount a chosen-ciphertext attack such as the one found in [4]."
    },
    {
      "indent": 0,
      "text": "8. Signature schemes with appendix",
      "section_title": true,
      "ja": "8. 付録付きの署名スキーム"
    },
    {
      "indent": 3,
      "text": "A signature scheme with appendix consists of a signature generation operation and a signature verification operation, where the signature generation operation produces a signature from a message with a signer's private key, and the signature verification operation verifies the signature on the message with the signer's corresponding public key. To verify a signature constructed with this type of scheme it is necessary to have the message itself. In this way, signature schemes with appendix are distinguished from signature schemes with message recovery, which are not supported in this document.",
      "ja": "付録付きの署名スキームは、署名生成操作と署名検証操作で構成されます。署名生成操作は、署名者の秘密鍵を使用してメッセージから署名を生成し、署名検証操作は、署名者の対応するパブリックでメッセージの署名を検証しますキー。このタイプのスキームで構築された署名を検証するには、メッセージ自体が必要です。このように、付録付きの署名スキームは、このドキュメントではサポートされていないメッセージ回復付きの署名スキームと区別されます。"
    },
    {
      "indent": 3,
      "text": "A signature scheme with appendix can be employed in a variety of applications. For instance, X.509 [6] employs such a scheme to authenticate the content of a certificate; the signature scheme with appendix defined here would be a suitable signature algorithm in that context. A related signature scheme could be employed in PKCS #7 [21], although for technical reasons, the current version of PKCS #7 separates a hash function from a signature scheme, which is different than what is done here.",
      "ja": "付録付きの署名スキームは、さまざまなアプリケーションで使用できます。たとえば、X.509 [6]は、証明書のコンテンツを認証するためにこのようなスキームを採用しています。ここで定義されている付録付きの署名スキームは、そのコンテキストでの適切な署名アルゴリズムです。技術的な理由により、PKCS＃7の現在のバージョンではハッシュ方式が署名方式から分離されていますが、関連する署名方式をPKCS＃7で使用できます[21]。これは、ここで行われているものとは異なります。"
    },
    {
      "indent": 3,
      "text": "One signature scheme with appendix is specified in this document: RSASSA-PKCS1-v1_5.",
      "ja": "このドキュメントでは、付録を含む1つの署名方式RSASSA-PKCS1-v1_5を指定しています。"
    },
    {
      "indent": 3,
      "text": "The signature scheme with appendix given here follows a general model similar to that employed in IEEE P1363, by combining signature and verification primitives with an encoding method for signatures. The signature generation operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. A signature primitive is then applied to the message representative to produce the signature. The signature verification operations apply a signature verification primitive to the signature to recover a message representative, which is then converted to an octet string. The message encoding operation is again applied to the message, and the result is compared to the recovered octet string. If there is a match, the signature is considered valid. (Note that this approach assumes that the signature and verification primitives have the message-recovery form and the encoding method is deterministic, as is the case for RSASP1/RSAVP1 and EMSA-PKCS1-v1_5. The signature generation and verification operations have a different form in P1363 for other primitives and encoding methods.)",
      "ja": "ここに示す付録の署名方式は、IEEE P1363で採用されているものと同様の一般的なモデルに従い、署名と検証プリミティブを署名のエンコード方法と組み合わせています。署名生成操作は、メッセージエンコード操作をメッセージに適用して、エンコードされたメッセージを生成します。その後、エンコードされたメッセージは、整数のメッセージ表現に変換されます。次に、署名プリミティブがメッセージ代表に適用され、署名が生成されます。署名検証操作では、署名検証プリミティブを署名に適用してメッセージの代表を復元し、メッセージ代表をオクテット文字列に変換します。メッセージのエンコード操作が再びメッセージに適用され、結果が復元されたオクテット文字列と比較されます。一致する場合、署名は有効と見なされます。 （このアプローチは、RSASP1 / RSAVP1およびEMSA-PKCS1-v1_5の場合と同様に、署名および検証プリミティブがメッセージ回復形式を持ち、エンコード方式が決定的であることを前提としています。署名の生成および検証操作は、異なる形式です他のプリミティブおよびエンコーディング方法についてはP1363に記載されています。）"
    },
    {
      "indent": 3,
      "text": "Editor's note. RSA Laboratories is investigating the possibility of including a scheme based on the PSS encoding methods specified in [3], which would be recommended for new applications.",
      "ja": "編集者のメモ。 RSA Laboratoriesは、[3]で指定されたPSSエンコード方式に基づくスキームを含める可能性を調査しています。これは、新しいアプリケーションに推奨されます。"
    },
    {
      "indent": 0,
      "text": "8.1 RSASSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "8.1 RSASSA-PKCS1-v1_5"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives with the EME-PKCS1-v1_5 encoding method. It is compatible with the IFSSA scheme defined in the draft P1363 where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1 and the message encoding method is EMSA-PKCS1-v1_5 (which is not defined in P1363). The length of messages on which RSASSA-PKCS1-v1_5 can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the message encoding method.",
      "ja": "RSASSA-PKCS1-v1_5は、RSASP1およびRSAVP1プリミティブとEME-PKCS1-v1_5エンコーディング方式を組み合わせたものです。署名および検証プリミティブがIFSP-RSA1およびIFVP-RSA1であり、メッセージエンコーディング方式がEMSA-PKCS1-v1_5（P1363で定義されていない）である、ドラフトP1363で定義されたIFSSAスキームと互換性があります。 RSASSA-PKCS1-v1_5が操作できるメッセージの長さは、メッセージエンコーディング方式の基礎となるハッシュ関数に応じて、制限されないか、非常に大きな数によって制約されます。"
    },
    {
      "indent": 3,
      "text": "Assuming that the hash function in EMSA-PKCS1-v1_5 has appropriate properties and the key size is sufficiently large, RSASSA-PKCS1-v1_5 provides secure signatures, meaning that it is computationally infeasible to generate a signature without knowing the private key, and computationally infeasible to find a message with a given signature or two messages with the same signature. Also, in the encoding method EMSA-PKCS1-v1_5, a hash function identifier is embedded in the encoding. Because of this feature, an adversary must invert or find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary.",
      "ja": "Assuming that the hash function in EMSA-PKCS1-v1_5 has appropriate properties and the key size is sufficiently large, RSASSA-PKCS1-v1_5 provides secure signatures, meaning that it is computationally infeasible to generate a signature without knowing the private key, and computationally infeasible to find a message with a given signature or two messages with the same signature. Also, in the encoding method EMSA-PKCS1-v1_5, a hash function identifier is embedded in the encoding. Because of this feature, an adversary must invert or find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary."
    },
    {
      "indent": 0,
      "text": "8.1.1 Signature generation operation",
      "section_title": true,
      "ja": "8.1.1 署名生成操作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-SIGN (K, M) Input: K signer's RSA private ke M message to be signed, an octet string",
      "ja": "RSASSA-PKCS1-V1_5-SIGN（K、M）入力：署名されるK署名者のRSAプライベートke Mメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: S signature, an octet string of length k, where k is the length in octets of the modulus n; \"message too long\" or \"modulus too short\" Steps:",
      "ja": "出力：S署名、長さkのオクテット文字列。ここで、kはモジュラスnのオクテット単位の長さです。 「メッセージが長すぎる」または「係数が短すぎる」手順："
    },
    {
      "indent": 3,
      "text": "1. Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2.1) to the message M to produce an encoded message EM of length k-1 octets:",
      "ja": "1. EMSA-PKCS1-v1_5エンコード操作（セクション9.2.1）をメッセージMに適用して、長さk-1オクテットのエンコードされたメッセージEMを生成します。"
    },
    {
      "indent": 3,
      "text": "EM = EMSA-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "EM = EMSA-PKCS1-V1_5-ENCODE（M、k-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short\" then output \"modulus too short\".",
      "ja": "エンコード操作で「メッセージが長すぎます」と出力された場合は、「メッセージが長すぎます」と出力して停止します。エンコード操作で「意図したエンコードメッセージの長さが短すぎる」と出力された場合は、「係数が短すぎます」と出力されます。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "2. エンコードされたメッセージEMを整数のメッセージ代表mに変換します。m= OS2IP（EM）"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSASP1 signature primitive (Section 5.2.1) to the private key K and the message representative m to produce an integer signature representative s: s = RSASP1 (K, m)",
      "ja": "3. RSASP1署名プリミティブ（セクション5.2.1）を秘密鍵Kとメッセージ代表mに適用して、整数署名代表sを生成します。s = RSASP1（K、m）"
    },
    {
      "indent": 3,
      "text": "4. Convert the signature representative s to a signature S of length k octets: S = I2OSP (s, k)",
      "ja": "4. 署名代表sを長さkオクテットの署名Sに変換します。S= I2OSP（s、k）"
    },
    {
      "indent": 3,
      "text": "5. Output the signature S.",
      "ja": "5. 署名Sを出力します。"
    },
    {
      "indent": 0,
      "text": "8.1.2 Signature verification operation",
      "section_title": true,
      "ja": "8.1.2 署名検証操作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)",
      "ja": "RSASSA-PKCS1-V1_5-VERIFY（（n、e）、M、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) signer's RSA public key M message whose signature is to be verified, an octet string S signature to be verified, an octet string of length k, where k is the length in octets of the modulus n",
      "ja": "入力：（n、e）署名が検証される署名者のRSA公開鍵Mメッセージ、検証されるオクテット文字列S署名、長さkのオクテット文字列、ここでkは係数nのオクテット単位の長さ"
    },
    {
      "indent": 3,
      "text": "Output: \"valid signature,\" \"invalid signature,\" or \"message too long\", or \"modulus too short\"",
      "ja": "出力：「有効な署名」、「無効な署名」、または「メッセージが長すぎます」、または「係数が短すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of the signature S is not k octets, output \"invalid signature\" and stop.",
      "ja": "1. 署名Sの長さがkオクテットでない場合は、「無効な署名」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Convert the signature S to an integer signature representative s:",
      "ja": "2. 署名Sを整数の署名代表sに変換します。"
    },
    {
      "indent": 3,
      "text": "s = OS2IP (S)",
      "ja": "s = OS2IP（S）"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAVP1 verification primitive (Section 5.2.2) to the public key (n, e) and the signature representative s to produce an integer message representative m:",
      "ja": "3. RSAVP1検証プリミティブ（セクション5.2.2）を公開鍵（n、e）と署名代表sに適用して、整数メッセージ代表mを生成します。"
    },
    {
      "indent": 3,
      "text": "m = RSAVP1 ((n, e), s) If RSAVP1 outputs \"invalid\" then output \"invalid signature\" and stop.",
      "ja": "m = RSAVP1（（n、e）、s）RSAVP1が「無効」を出力した場合、「無効な署名」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "4. メッセージ代表mを、長さk-1オクテットのエンコードされたメッセージEMに変換します。EM= I2OSP（m、k-1）"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"invalid signature\" and stop.",
      "ja": "I2OSPが「整数が大きすぎる」と出力した場合は、「無効な署名」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2.1) to the message M to produce a second encoded message EM' of length k-1 octets:",
      "ja": "5. EMSA-PKCS1-v1_5エンコード操作（セクション9.2.1）をメッセージMに適用して、長さk-1オクテットの2番目のエンコードされたメッセージEM 'を生成します。"
    },
    {
      "indent": 3,
      "text": "EM' = EMSA-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "EM '= EMSA-PKCS1-V1_5-ENCODE（M、k-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short\" then output \"modulus too short\".",
      "ja": "エンコード操作で「メッセージが長すぎます」と出力された場合は、「メッセージが長すぎます」と出力して停止します。エンコード操作で「意図したエンコードメッセージの長さが短すぎる」と出力された場合は、「係数が短すぎます」と出力されます。"
    },
    {
      "indent": 3,
      "text": "6. Compare the encoded message EM and the second encoded message EM'. If they are the same, output \"valid signature\"; otherwise, output \"invalid signature.\"",
      "ja": "6. エンコードされたメッセージEMと2番目のエンコードされたメッセージEM 'を比較します。同じ場合は、「有効な署名」を出力します。それ以外の場合は、「無効な署名」を出力します。"
    },
    {
      "indent": 0,
      "text": "9. Encoding methods",
      "section_title": true,
      "ja": "9. エンコーディング方法"
    },
    {
      "indent": 3,
      "text": "Encoding methods consist of operations that map between octet string messages and integer message representatives.",
      "ja": "エンコーディング方法は、オクテット文字列メッセージと整数メッセージ代表の間でマッピングする操作で構成されます。"
    },
    {
      "indent": 3,
      "text": "Two types of encoding method are considered in this document: encoding methods for encryption, encoding methods for signatures with appendix.",
      "ja": "このドキュメントでは、2種類のエンコード方式が検討されています。暗号化のエンコード方式、付録付きの署名のエンコード方式です。"
    },
    {
      "indent": 0,
      "text": "9.1 Encoding methods for encryption",
      "section_title": true,
      "ja": "9.1 暗号化のエンコード方法"
    },
    {
      "indent": 3,
      "text": "An encoding method for encryption consists of an encoding operation and a decoding operation. An encoding operation maps a message M to a message representative EM of a specified length; the decoding operation maps a message representative EM back to a message. The encoding and decoding operations are inverses.",
      "ja": "暗号化の符号化方式は、符号化演算と復号化演算からなる。エンコード操作は、メッセージMを指定された長さのEMを表すメッセージにマップします。デコード操作により、メッセージを表すEMがメッセージにマッピングされます。エンコードとデコードの操作は逆です。"
    },
    {
      "indent": 3,
      "text": "The message representative EM will typically have some structure that can be verified by the decoding operation; the decoding operation will output \"decoding error\" if the structure is not present. The encoding operation may also introduce some randomness, so that different applications of the encoding operation to the same message will produce different representatives.",
      "ja": "メッセージを表すEMは通常、デコード操作で検証できる構造を持っています。構造が存在しない場合、デコード操作は「デコードエラー」を出力します。符号化操作は、ある程度のランダム性を導入することもあるので、同じメッセージに対する符号化操作の異なるアプリケーションは、異なる代表を生成します。"
    },
    {
      "indent": 3,
      "text": "Two encoding methods for encryption are employed in the encryption schemes and are specified here: EME-OAEP and EME-PKCS1-v1_5.",
      "ja": "暗号化スキームでは、暗号化に2つのエンコード方式が採用されており、ここで指定されています。EME-OAEPとEME-PKCS1-v1_5。"
    },
    {
      "indent": 0,
      "text": "9.1.1 EME-OAEP",
      "section_title": true,
      "ja": "9.1.1 EME-OAEP"
    },
    {
      "indent": 3,
      "text": "This encoding method is parameterized by the choice of hash function and mask generation function. Suggested hash and mask generation functions are given in Section 10. This encoding method is based on the method found in [2].",
      "ja": "このエンコード方式は、ハッシュ関数とマスク生成関数の選択によってパラメーター化されます。推奨されるハッシュおよびマスク生成関数は、セクション10に記載されています。このエンコード方法は、[2]にある方法に基づいています。"
    },
    {
      "indent": 0,
      "text": "9.1.1.1 Encoding operation",
      "section_title": true,
      "ja": "9.1.1.1 エンコード操作"
    },
    {
      "indent": 3,
      "text": "EME-OAEP-ENCODE (M, P, emLen)",
      "ja": "EME-OAEP-ENCODE（M、P、emLen）"
    },
    {
      "indent": 0,
      "text": " Options: Hash hash function (hLen denotes the length in octet of the hash function output) MGF mask generation function Input: M message to be encoded, an octet string of length at most emLen-1-2hLen P encoding parameters, an octet string emLen intended length in octets of the encoded message, at least 2hLen+1",
      "ja": "オプション：ハッシュハッシュ関数（hLenはハッシュ関数出力のオクテットの長さを示します）MGFマスク生成関数入力：エンコードされるMメッセージ、最大で長さのオクテット文字列emLen-1-2hLen Pエンコードパラメーター、オクテット文字列emLenエンコードされたメッセージのオクテット単位の意図された長さ、少なくとも2hLen + 1"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; \"message too long\" or \"parameter string too long\"",
      "ja": "出力：EMエンコードされたメッセージ、長さemLenのオクテット文字列。 「メッセージが長すぎる」または「パラメータ文字列が長すぎる」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of P is greater than the input limitation for the hash function (2^61-1 octets for SHA-1) then output \"parameter string too long\" and stop.",
      "ja": "1. Pの長さがハッシュ関数の入力制限（SHA-1の場合は2 ^ 61-1オクテット）より大きい場合は、「パラメーター文字列が長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. If ||M|| > emLen-2hLen-1 then output \"message too long\" and stop.",
      "ja": "2. || M ||の場合> emLen-2hLen-1は「メッセージが長すぎます」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "3. Generate an octet string PS consisting of emLen-||M||-2hLen-1 zero octets. The length of PS may be 0.",
      "ja": "3. emLen- || M || -2hLen-1のゼロオクテットで構成されるオクテットストリングPSを生成します。 PSの長さが0の場合があります。"
    },
    {
      "indent": 3,
      "text": "4. Let pHash = Hash(P), an octet string of length hLen.",
      "ja": "4. pHash = Hash（P）、長さhLenのオクテット文字列とします。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate pHash, PS, the message M, and other padding to form a data block DB as: DB = pHash || PS || 01 || M",
      "ja": "5. pHash、PS、メッセージM、およびその他のパディングを連結して、次のようにデータブロックDBを形成します。DB = pHash || PS || 01 || M"
    },
    {
      "indent": 3,
      "text": "6. Generate a random octet string seed of length hLen.",
      "ja": "6. 長さhLenのランダムなオクテット文字列シードを生成します。"
    },
    {
      "indent": 3,
      "text": "7. Let dbMask = MGF(seed, emLen-hLen).",
      "ja": "7. dbMask = MGF（seed、emLen-hLen）とします。"
    },
    {
      "indent": 3,
      "text": "8. Let maskedDB = DB \\xor dbMask.",
      "ja": "8. maskedDB = DB \\ xor dbMaskとします。"
    },
    {
      "indent": 3,
      "text": "9. Let seedMask = MGF(maskedDB, hLen).",
      "ja": "9. seedMask = MGF（maskedDB、hLen）とします。"
    },
    {
      "indent": 3,
      "text": "10. Let maskedSeed = seed \\xor seedMask.",
      "ja": "10. maskedSeed = seed \\ xor seedMaskとします。"
    },
    {
      "indent": 3,
      "text": "11. Let EM = maskedSeed || maskedDB.",
      "ja": "11. EM = maskedSeed ||としますmaskedDB。"
    },
    {
      "indent": 3,
      "text": "12. Output EM.",
      "ja": "12. 出力EM。"
    },
    {
      "indent": 0,
      "text": "9.1.1.2 Decoding operation EME-OAEP-DECODE (EM, P)",
      "section_title": true,
      "ja": "9.1.1.2 デコード操作EME-OAEP-DECODE（EM、P）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octet of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（hLenはハッシュ関数出力のオクテット単位の長さを示します）"
    },
    {
      "indent": 0,
      "text": " MGF mask generation function Input:",
      "ja": "MGFマスク生成関数入力："
    },
    {
      "indent": 3,
      "text": "EM encoded message, an octet string of length at least 2hLen+1 P encoding parameters, an octet string",
      "ja": "EMエンコードされたメッセージ、2hLen + 1 P以上のエンコードパラメータの長さのオクテット文字列、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: M recovered message, an octet string of length at most ||EM||-1-2hLen; or \"decoding error\"",
      "ja": "出力：M個の復元されたメッセージ、最大長が|| EM || -1-2hLenのオクテット文字列。または「デコードエラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of P is greater than the input limitation for the hash function (2^61-1 octets for SHA-1) then output \"parameter string too long\" and stop.",
      "ja": "1. Pの長さがハッシュ関数の入力制限（SHA-1の場合は2 ^ 61-1オクテット）より大きい場合は、「パラメーター文字列が長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. If ||EM|| < 2hLen+1, then output \"decoding error\" and stop.",
      "ja": "2. || EM ||の場合<2hLen + 1の場合、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "3. Let maskedSeed be the first hLen octets of EM and let maskedDB be the remaining ||EM|| - hLen octets.",
      "ja": "3. maskedSeedをEMの最初のhLenオクテットとし、maskedDBを残りの|| EM ||とします。 -hLenオクテット。"
    },
    {
      "indent": 3,
      "text": "4. Let seedMask = MGF(maskedDB, hLen).",
      "ja": "4. seedMask = MGF（maskedDB、hLen）とします。"
    },
    {
      "indent": 3,
      "text": "5. Let seed = maskedSeed \\xor seedMask.",
      "ja": "5. シード= maskedSeed \\ xor seedMaskとします。"
    },
    {
      "indent": 3,
      "text": "6. Let dbMask = MGF(seed, ||EM|| - hLen).",
      "ja": "6. dbMask = MGF（seed、|| EM ||-hLen）とします。"
    },
    {
      "indent": 3,
      "text": "7. Let DB = maskedDB \\xor dbMask.",
      "ja": "7. DB = maskedDB \\ xor dbMaskとします。"
    },
    {
      "indent": 3,
      "text": "8. Let pHash = Hash(P), an octet string of length hLen.",
      "ja": "8. pHash = Hash（P）、長さhLenのオクテット文字列とします。"
    },
    {
      "indent": 3,
      "text": "9. Separate DB into an octet string pHash' consisting of the first hLen octets of DB, a (possibly empty) octet string PS consisting of consecutive zero octets following pHash', and a message M as:",
      "ja": "9. DBを、DBの最初のhLenオクテットで構成されるオクテット文字列pHash '、pHash'に続く連続するゼロオクテットで構成される（場合によっては空の）オクテット文字列PS、およびメッセージMに次のように分離します。"
    },
    {
      "indent": 3,
      "text": "DB = pHash' || PS || 01 || M",
      "ja": "Dab = floor '|| PS || 01 || M"
    },
    {
      "indent": 3,
      "text": "If there is no 01 octet to separate PS from M, output \"decoding error\" and stop.",
      "ja": "PSをMから分離する01オクテットがない場合は、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "10. If pHash' does not equal pHash, output \"decoding error\" and stop.",
      "ja": "10. pHash 'がpHashと等しくない場合は、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "11. Output M.",
      "ja": "11. 出力M"
    },
    {
      "indent": 0,
      "text": "9.1.2 EME-PKCS1-v1_5",
      "section_title": true,
      "ja": "9.1.2 EME-PKCS1-v1_5"
    },
    {
      "indent": 3,
      "text": "This encoding method is the same as in PKCS #1 v1.5, Section 8: Encryption Process.",
      "ja": "このエンコード方式は、PKCS＃1 v1.5、セクション8：暗号化プロセスと同じです。"
    },
    {
      "indent": 0,
      "text": "9.1.2.1 Encoding operation",
      "section_title": true,
      "ja": "9.1.2.1 エンコード操作"
    },
    {
      "indent": 3,
      "text": "EME-PKCS1-V1_5-ENCODE (M, emLen)",
      "ja": "EME-PKCS1-V1_5-ENCODE（M、emLen）"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded, an octet string of length at most emLen-10 emLen intended length in octets of the encoded message",
      "ja": "入力：エンコードされるMメッセージ、最大でemLen-10 emLenの長さのオクテット文字列、エンコードされたメッセージのオクテットでの意図された長さ"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; or \"message too long\"",
      "ja": "出力：EMエンコードされたメッセージ、長さemLenのオクテット文字列。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of the message M is greater than emLen - 10 octets, output \"message too long\" and stop.",
      "ja": "1. メッセージMの長さがemLen-10オクテットより大きい場合、「メッセージが長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Generate an octet string PS of length emLen-||M||-2 consisting of pseudorandomly generated nonzero octets. The length of PS will be at least 8 octets.",
      "ja": "2. 疑似ランダムに生成されたゼロ以外のオクテットで構成される長さemLen- || M || -2のオクテット文字列PSを生成します。 PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 3,
      "text": "3. Concatenate PS, the message M, and other padding to form the encoded message EM as:",
      "ja": "3. PS、メッセージM、およびその他のパディングを連結して、エンコードされたメッセージEMを次のように形成します。"
    },
    {
      "indent": 3,
      "text": "EM = 02 || PS || 00 || M",
      "ja": "EM = 02 || PS || 00 || M"
    },
    {
      "indent": 3,
      "text": "4. Output EM.",
      "ja": "4. 出力EM。"
    },
    {
      "indent": 0,
      "text": "9.1.2.2 Decoding operation",
      "section_title": true,
      "ja": "9.1.2.2 デコード操作"
    },
    {
      "indent": 3,
      "text": "EME-PKCS1-V1_5-DECODE (EM)",
      "ja": "EME-PKCS1-V1_5-DECODE（EM）"
    },
    {
      "indent": 3,
      "text": "Input: EM encoded message, an octet string of length at least 10",
      "ja": "入力：EMエンコードされたメッセージ、長さが10以上のオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: M recovered message, an octet string of length at most ||EM||-10; or \"decoding error\"",
      "ja": "出力：M個の復元されたメッセージ、最大長が|| EM || -10のオクテット文字列。または「デコードエラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. If the length of the encoded message EM is less than 10, output \"decoding error\" and stop.",
      "ja": "1. エンコードされたメッセージEMの長さが10未満の場合、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2. Separate the encoded message EM into an octet string PS consisting of nonzero octets and a message M as: EM = 02 || PS || 00 || M.",
      "ja": "2. エンコードされたメッセージEMを、次のようにゼロ以外のオクテットとメッセージMで構成されるオクテットストリングPSに分離します。 PS || 00 || M."
    },
    {
      "indent": 3,
      "text": "If the first octet of EM is not 02, or if there is no 00 octet to separate PS from M, output \"decoding error\" and stop.",
      "ja": "EMの最初のオクテットが02でない場合、またはPSをMから分離する00オクテットがない場合は、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "3. If the length of PS is less than 8 octets, output \"decoding error\" and stop.",
      "ja": "3. PSの長さが8オクテット未満の場合は、「デコードエラー」を出力して停止します。"
    },
    {
      "indent": 3,
      "text": "4. Output M.",
      "ja": "4. 出力M"
    },
    {
      "indent": 0,
      "text": "9.2 Encoding methods for signatures with appendix",
      "section_title": true,
      "ja": "9.2 付録を使用した署名のエンコード方法"
    },
    {
      "indent": 3,
      "text": "An encoding method for signatures with appendix, for the purposes of this document, consists of an encoding operation. An encoding operation maps a message M to a message representative EM of a specified length. (In future versions of this document, encoding methods may be added that also include a decoding operation.)",
      "ja": "このドキュメントでは、付録付きの署名のエンコード方式は、エンコード操作で構成されています。エンコード操作は、メッセージMを指定された長さのメッセージ代表EMにマップします。 （このドキュメントの将来のバージョンでは、デコード操作も含むエンコード方法が追加される可能性があります。）"
    },
    {
      "indent": 3,
      "text": "One encoding method for signatures with appendix is employed in the encryption schemes and is specified here: EMSA-PKCS1-v1_5.",
      "ja": "付録を使用した署名の1つのエンコード方式は、暗号化スキームで採用されており、EMSA-PKCS1-v1_5で指定されています。"
    },
    {
      "indent": 0,
      "text": "9.2.1 EMSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "9.2.1 EMSA-PKCS1-v1_5"
    },
    {
      "indent": 3,
      "text": "This encoding method only has an encoding operation.",
      "ja": "このエンコード方式にはエンコード操作のみがあります。"
    },
    {
      "indent": 3,
      "text": "EMSA-PKCS1-v1_5-ENCODE (M, emLen)",
      "ja": "EMSA-PKCS1-v1_5-ENCODE（M、emLen）"
    },
    {
      "indent": 3,
      "text": "Option: Hash hash function (hLen denotes the length in octet of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（hLenはハッシュ関数出力のオクテット単位の長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded emLen intended length in octets of the encoded message, at least ||T|| + 10, where T is the DER encoding of a certain value computed during the encoding operation",
      "ja": "入力：エンコードされるMメッセージemLenエンコードされたメッセージのオクテットでの意図された長さ、少なくとも|| T || + 10、ここでTは、エンコード操作中に計算された特定の値のDERエンコードです。"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; or \"message too long\" or \"intended encoded message length too short\"",
      "ja": "出力：EMエンコードされたメッセージ、長さemLenのオクテット文字列。または「メッセージが長すぎる」または「意図したエンコードされたメッセージの長さが短すぎる」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1. Apply the hash function to the message M to produce a hash value H:",
      "ja": "1. ハッシュ関数をメッセージMに適用して、ハッシュ値Hを生成します。"
    },
    {
      "indent": 3,
      "text": "H = Hash(M).",
      "ja": "H =ハッシュ（M）。"
    },
    {
      "indent": 3,
      "text": "If the hash function outputs \"message too long,\" then output \"message too long\".",
      "ja": "ハッシュ関数が「メッセージが長すぎます」を出力する場合、「メッセージが長すぎます」を出力します。"
    },
    {
      "indent": 3,
      "text": "2. Encode the algorithm ID for the hash function and the hash value into an ASN.1 value of type DigestInfo (see Section 11) with the Distinguished Encoding Rules (DER), where the type DigestInfo has the syntax",
      "ja": "2. ハッシュ関数のアルゴリズムIDとハッシュ値を、DigestInfo型の構文を持つDistinguished Encoding Rules（DER）を使用して、DigestInfo型（セクション11を参照）のASN.1値にエンコードします。"
    },
    {
      "indent": 3,
      "text": "DigestInfo::=SEQUENCE{\n  digestAlgorithm  AlgorithmIdentifier,\n  digest OCTET STRING }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first field identifies the hash function and the second contains the hash value. Let T be the DER encoding.",
      "ja": "最初のフィールドはハッシュ関数を識別し、2番目のフィールドはハッシュ値を含みます。 TをDERエンコーディングとします。"
    },
    {
      "indent": 3,
      "text": "3. If emLen is less than ||T|| + 10 then output \"intended encoded message length too short\".",
      "ja": "3. emLenが|| T ||より小さい場合+ 10次に、「意図したエンコードメッセージの長さが短すぎます」を出力します。"
    },
    {
      "indent": 3,
      "text": "4. Generate an octet string PS consisting of emLen-||T||-2 octets with value FF (hexadecimal). The length of PS will be at least 8 octets.",
      "ja": "4. 値FF（16進数）のemLen- || T || -2オクテットで構成されるオクテット文字列PSを生成します。 PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as: EM = 01 || PS || 00 || T",
      "ja": "5. PS、DERエンコードT、およびその他のパディングを連結して、エンコードされたメッセージEMを次のように形成します。 PS || 00 || T"
    },
    {
      "indent": 3,
      "text": "6. Output EM.",
      "ja": "6. 出力EM。"
    },
    {
      "indent": 0,
      "text": "10. Auxiliary Functions",
      "section_title": true,
      "ja": "10. 補助機能"
    },
    {
      "indent": 3,
      "text": "This section specifies the hash functions and the mask generation functions that are mentioned in the encoding methods (Section 9).",
      "ja": "このセクションでは、エンコード方法（セクション9）で言及されているハッシュ関数とマスク生成関数を指定します。"
    },
    {
      "indent": 0,
      "text": "10.1 Hash Functions",
      "section_title": true,
      "ja": "10.1 ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "Hash functions are used in the operations contained in Sections 7, 8 and 9. Hash functions are deterministic, meaning that the output is completely determined by the input. Hash functions take octet strings of variable length, and generate fixed length octet strings. The hash functions used in the operations contained in Sections 7, 8 and 9 should be collision resistant. This means that it is infeasible to find two distinct inputs to the hash function that produce the same output. A collision resistant hash function also has the desirable property of being one-way; this means that given an output, it is infeasible to find an input whose hash is the specified output. The property of collision resistance is especially desirable for RSASSA-PKCS1-v1_5, as it makes it infeasible to forge signatures. In addition to the requirements, the hash function should yield a mask generation function (Section 10.2) with pseudorandom output.",
      "ja": "ハッシュ関数は、セクション7、8、9に含まれる演算で使用されます。ハッシュ関数は決定論的です。つまり、出力は入力によって完全に決定されます。ハッシュ関数は、可変長のオクテット文字列を受け取り、固定長のオクテット文字列を生成します。セクション7、8、および9に含まれる操作で使用されるハッシュ関数は、衝突耐性を備えている必要があります。これは、同じ出力を生成するハッシュ関数への2つの異なる入力を見つけることが実行不可能であることを意味します。衝突耐性のあるハッシュ関数には、一方向であるという望ましい特性もあります。つまり、出力が与えられた場合、指定された出力がハッシュである入力を見つけることは不可能です。 RSASSA-PKCS1-v1_5は、シグネチャを偽造することが不可能であるため、衝突耐性の特性が特に望ましいです。要件に加えて、ハッシュ関数は、疑似ランダム出力を備えたマスク生成関数（セクション10.2）を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Three hash functions are recommended for the encoding methods in this document: MD2 [15], MD5 [17], and SHA-1 [16]. For the EME-OAEP encoding method, only SHA-1 is recommended. For the EMSA-PKCS1-v1_5 encoding method, SHA-1 is recommended for new applications. MD2 and MD5 are recommended only for compatibility with existing applications based on PKCS #1 v1.5.",
      "ja": "このドキュメントのエンコード方式には、MD2 [15]、MD5 [17]、SHA-1 [16]の3つのハッシュ関数が推奨されます。 EME-OAEPエンコード方式の場合、SHA-1のみが推奨されます。 EMSA-PKCS1-v1_5エンコーディング方式の場合、新しいアプリケーションにはSHA-1が推奨されます。 MD2およびMD5は、PKCS＃1 v1.5に基づく既存のアプリケーションとの互換性のためにのみ推奨されます。"
    },
    {
      "indent": 3,
      "text": "The hash functions themselves are not defined here; readers are referred to the appropriate references ([15], [17] and [16]).",
      "ja": "ハッシュ関数自体はここでは定義されていません。読者は適切なリファレンス（[15]、[17]、および[16]）を参照されます。"
    },
    {
      "indent": 3,
      "text": "Note. Version 1.5 of this document also allowed for the use of MD4 in signature schemes. The cryptanalysis of MD4 has progressed significantly in the intervening years. For example, Dobbertin [10] demonstrated how to find collisions for MD4 and that the first two rounds of MD4 are not one-way [11]. Because of these results and others (e.g. [9]), MD4 is no longer recommended. There have also been advances in the cryptanalysis of MD2 and MD5, although not enough to warrant removal from existing applications. Rogier and Chauvaud [19] demonstrated how to find collisions in a modified version of MD2. No one has demonstrated how to find collisions for the full MD5 algorithm, although partial results have been found (e.g. [8]). For new applications, to address these concerns, SHA-1 is preferred.",
      "ja": "注意。このドキュメントのバージョン1.5では、署名方式でのMD4の使用も許可されていました。 MD4の暗号解読は、その後数年間で大幅に進歩しました。たとえば、Dobbertin [10]は、MD4の衝突を見つける方法と、MD4の最初の2ラウンドが一方向ではないことを示しました[11]。これらの結果やその他の結果（[9]など）のため、MD4は推奨されなくなりました。既存のアプリケーションからの削除を保証するのに十分ではありませんが、MD2とMD5の暗号解読にも進歩がありました。 RogierとChauvaud [19]は、MD2の修正バージョンで衝突を見つける方法を示しました。完全なMD5アルゴリズムの衝突を見つける方法は誰も示していませんが、部分的な結果は見つかっています（たとえば[8]）。新しいアプリケーションでは、これらの懸念に対処するために、SHA-1が推奨されます。"
    },
    {
      "indent": 0,
      "text": "10.2 Mask Generation Functions",
      "section_title": true,
      "ja": "10.2 マスク生成関数"
    },
    {
      "indent": 3,
      "text": "A mask generation function takes an octet string of variable length and a desired output length as input, and outputs an octet string of the desired length. There may be restrictions on the length of the input and output octet strings, but such bounds are generally very large. Mask generation functions are deterministic; the octet string output is completely determined by the input octet string. The output of a mask generation function should be pseudorandom, that is, if the seed to the function is unknown, it should be infeasible to distinguish the output from a truly random string. The plaintext-awareness of RSAES-OAEP relies on the random nature of the output of the mask generation function, which in turn relies on the random nature of the underlying hash.",
      "ja": "マスク生成関数は、可変長のオクテット文字列と希望の出力長を入力として受け取り、希望の長さのオクテット文字列を出力します。入力と出力のオクテット文字列の長さに制限があるかもしれませんが、そのような境界は一般に非常に大きいです。マスク生成関数は確定的です。オクテット文字列の出力は、入力オクテット文字列によって完全に決定されます。マスク生成関数の出力は疑似ランダムでなければなりません。つまり、関数へのシードが不明な場合、出力を真にランダムな文字列から区別することは不可能です。 RSAES-OAEPの平文認識は、マスク生成関数の出力のランダムな性質に依存しています。これは、基礎となるハッシュのランダムな性質に依存しています。"
    },
    {
      "indent": 3,
      "text": "One mask generation function is recommended for the encoding methods in this document, and is defined here: MGF1, which is based on a hash function. Future versions of this document may define other mask generation functions.",
      "ja": "このドキュメントのエンコード方式には1つのマスク生成関数が推奨され、ここで定義されています：MGF1、これはハッシュ関数に基づいています。このドキュメントの将来のバージョンでは、他のマスク生成関数を定義する可能性があります。"
    },
    {
      "indent": 0,
      "text": "10.2.1 MGF1",
      "section_title": true,
      "ja": "10.2.1 MGF1"
    },
    {
      "indent": 3,
      "text": "MGF1 is a Mask Generation Function based on a hash function.",
      "ja": "MGF1は、ハッシュ関数に基づくマスク生成関数です。"
    },
    {
      "indent": 0,
      "text": " MGF1 (Z, l) Options: Hash hash function (hLen denotes the length in octets of the hash function output)",
      "ja": "MGF1（Z、l）オプション：ハッシュハッシュ関数（hLenは、ハッシュ関数出力のオクテット単位の長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: Z seed from which mask is generated, an octet string l intended length in octets of the mask, at most 2^32(hLen)",
      "ja": "入力：マスクが生成されるZシード、オクテット文字列lマスクのオクテット単位の意図された長さ、最大2 ^ 32（hLen）"
    },
    {
      "indent": 3,
      "text": "Output: mask mask, an octet string of length l; or \"mask too long\"",
      "ja": "出力：マスクマスク、長さlのオクテット文字列。または「マスクが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 3,
      "text": "1.If l > 2^32(hLen), output \"mask too long\" and stop.",
      "ja": "1. l> 2 ^ 32（hLen）の場合、「マスクが長すぎます」と出力して停止します。"
    },
    {
      "indent": 3,
      "text": "2.Let T be the empty octet string.",
      "ja": "2. Tを空のオクテット文字列にします。"
    },
    {
      "indent": 3,
      "text": "3.For counter from 0 to \\lceil{l / hLen}\\rceil-1, do the following:",
      "ja": "3. 0から\\ lceil {l / hLen} \\ rceil-1までのカウンターについては、次のようにします。"
    },
    {
      "indent": 3,
      "text": "a.Convert counter to an octet string C of length 4 with the primitive I2OSP: C = I2OSP (counter, 4)",
      "ja": "a。プリミティブI2OSPを使用して、カウンターを長さ4のオクテット文字列Cに変換します。C= I2OSP（counter、4）"
    },
    {
      "indent": 3,
      "text": "b.Concatenate the hash of the seed Z and C to the octet string T: T = T || Hash (Z || C)",
      "ja": "b。シードZとCのハッシュをオクテット文字列Tに連結します。T= T ||ハッシュ（Z || C）"
    },
    {
      "indent": 3,
      "text": "4.Output the leading l octets of T as the octet string mask.",
      "ja": "4. Tの先頭のlオクテットをオクテット文字列マスクとして出力します。"
    },
    {
      "indent": 0,
      "text": "11. ASN.1 syntax",
      "section_title": true,
      "ja": "11. ASN.1構文"
    },
    {
      "indent": 0,
      "text": "11.1 Key representation",
      "section_title": true,
      "ja": "11.1 キー表現"
    },
    {
      "indent": 3,
      "text": "This section defines ASN.1 object identifiers for RSA public and private keys, and defines the types RSAPublicKey and RSAPrivateKey. The intended application of these definitions includes X.509 certificates, PKCS #8 [22], and PKCS #12 [23].",
      "ja": "このセクションでは、RSA公開鍵と秘密鍵のASN.1オブジェクト識別子を定義し、タイプRSAPublicKeyおよびRSAPrivateKeyを定義します。これらの定義の意図されたアプリケーションには、X.509証明書、PKCS＃8 [22]、およびPKCS＃12 [23]が含まれます。"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption identifies RSA public and private keys as defined in Sections 11.1.1 and 11.1.2. The parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL.",
      "ja": "オブジェクト識別子rsaEncryptionは、セクション11.1.1および11.1.2で定義されているRSA公開鍵と秘密鍵を識別します。 AlgorithmIdentifierでこのOIDに関連付けられているパラメーターフィールドのタイプはNULLです。"
    },
    {
      "indent": 3,
      "text": "rsaEncryption OBJECT IDENTIFIER ::= {pkcs-1 1}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All of the definitions in this section are the same as in PKCS #1 v1.5.",
      "ja": "このセクションのすべての定義は、PKCS＃1 v1.5と同じです。"
    },
    {
      "indent": 0,
      "text": "11.1.1 Public-key syntax",
      "section_title": true,
      "ja": "11.1.1 公開鍵構文"
    },
    {
      "indent": 3,
      "text": "An RSA public key should be represented with the ASN.1 type RSAPublicKey:",
      "ja": "RSA公開鍵は、ASN.1タイプのRSAPublicKeyで表す必要があります。"
    },
    {
      "indent": 3,
      "text": "RSAPublicKey::=SEQUENCE{\n  modulus INTEGER, -- n\n  publicExponent INTEGER -- e }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(This type is specified in X.509 and is retained here for compatibility.)",
      "ja": "（このタイプはX.509で指定されており、互換性のためにここに保持されています。）"
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPublicKey have the following meanings: -modulus is the modulus n. -publicExponent is the public exponent e.",
      "ja": "タイプRSAPublicKeyのフィールドには次の意味があります。-modulusは係数nです。 -publicExponentは、公開指数eです。"
    },
    {
      "indent": 0,
      "text": "11.1.2 Private-key syntax",
      "section_title": true,
      "ja": "11.1.2 秘密鍵構文"
    },
    {
      "indent": 3,
      "text": "An RSA private key should be represented with ASN.1 type RSAPrivateKey:",
      "ja": "RSA秘密鍵は、ASN.1タイプのRSAPrivateKeyで表す必要があります。"
    },
    {
      "indent": 3,
      "text": "RSAPrivateKey ::= SEQUENCE {\n  version Version,\n  modulus INTEGER, -- n\n  publicExponent INTEGER, -- e\n  privateExponent INTEGER, -- d\n  prime1 INTEGER, -- p\n  prime2 INTEGER, -- q\n  exponent1 INTEGER, -- d mod (p-1)\n  exponent2 INTEGER, -- d mod (q-1)\n  coefficient INTEGER -- (inverse of q) mod p }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Version ::= INTEGER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPrivateKey have the following meanings:",
      "ja": "タイプRSAPrivateKeyのフィールドには、以下の意味があります。"
    },
    {
      "indent": 3,
      "text": "-version is the version number, for compatibility with future revisions of this document. It shall be 0 for this version of the document. -modulus is the modulus n. -publicExponent is the public exponent e. -privateExponent is the private exponent d. -prime1 is the prime factor p of n. -prime2 is the prime factor q of n. -exponent1 is d mod (p-1). -exponent2 is d mod (q-1). -coefficient is the Chinese Remainder Theorem coefficient q-1 mod p.",
      "ja": "-versionは、このドキュメントの将来のリビジョンとの互換性を保つためのバージョン番号です。このバージョンのドキュメントでは0になります。 -modulusは係数nです。 -publicExponentは、公開指数eです。 -privateExponentはプライベート指数dです。 -prime1は、nの素因数pです。 -prime2はnの素因数qです。 -exponent1はd mod（p-1）です。 -exponent2はd mod（q-1）です。 -係数は、中国の剰余定理係数q-1 mod pです。"
    },
    {
      "indent": 0,
      "text": "11.2 Scheme identification",
      "section_title": true,
      "ja": "11.2 スキームの識別"
    },
    {
      "indent": 3,
      "text": "This section defines object identifiers for the encryption and signature schemes. The schemes compatible with PKCS #1 v1.5 have the same definitions as in PKCS #1 v1.5. The intended application of these definitions includes X.509 certificates and PKCS #7.",
      "ja": "このセクションでは、暗号化および署名スキームのオブジェクト識別子を定義します。 PKCS＃1 v1.5と互換性のあるスキームには、PKCS＃1 v1.5と同じ定義があります。これらの定義の対象となるアプリケーションには、X.509証明書とPKCS＃7が含まれます。"
    },
    {
      "indent": 0,
      "text": "11.2.1 Syntax for RSAES-OAEP",
      "section_title": true,
      "ja": "11.2.1 RSAES-OAEPの構文"
    },
    {
      "indent": 3,
      "text": "The object identifier id-RSAES-OAEP identifies the RSAES-OAEP encryption scheme.",
      "ja": "オブジェクト識別子id-RSAES-OAEPは、RSAES-OAEP暗号化スキームを識別します。"
    },
    {
      "indent": 3,
      "text": "id-RSAES-OAEP OBJECT IDENTIFIER ::= {pkcs-1 7}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in an AlgorithmIdentifier shall have type RSAEP-OAEP-params:",
      "ja": "AlgorithmIdentifierでこのOIDに関連付けられているパラメーターフィールドのタイプはRSAEP-OAEP-paramsです。"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-params ::=  SEQUENCE {\n  hashFunc [0] AlgorithmIdentifier {{oaepDigestAlgorithms}}\n    DEFAULT sha1Identifier,\n  maskGenFunc [1] AlgorithmIdentifier {{pkcs1MGFAlgorithms}}\n    DEFAULT mgf1SHA1Identifier,\n  pSourceFunc [2] AlgorithmIdentifier\n    {{pkcs1pSourceAlgorithms}}\n    DEFAULT pSpecifiedEmptyIdentifier }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields of type RSAES-OAEP-params have the following meanings:",
      "ja": "タイプRSAES-OAEP-paramsのフィールドには、次の意味があります。"
    },
    {
      "indent": 3,
      "text": "-hashFunc identifies the hash function. It shall be an algorithm ID with an OID in the set oaepDigestAlgorithms, which for this version shall consist of id-sha1, identifying the SHA-1 hash function. The parameters field for id-sha1 shall have type NULL.",
      "ja": "-hashFuncはハッシュ関数を識別します。これは、セットaaepDigestAlgorithmsにOIDが含まれるアルゴリズムIDである必要があります。このバージョンでは、ID-sha1で構成され、SHA-1ハッシュ関数を識別します。 id-sha1のパラメーターフィールドのタイプはNULLです。"
    },
    {
      "indent": 3,
      "text": "oaepDigestAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {NULL IDENTIFIED BY id-sha1} }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "id-sha1 OBJECT IDENTIFIER ::=\n  {iso(1) identified-organization(3) oiw(14) secsig(3)\n    algorithms(2) 26}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The default hash function is SHA-1:\nsha1Identifier ::= AlgorithmIdentifier {id-sha1, NULL}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-maskGenFunc identifies the mask generation function. It shall be an algorithm ID with an OID in the set pkcs1MGFAlgorithms, which for this version shall consist of id-mgf1, identifying the MGF1 mask generation function (see Section 10.2.1). The parameters field for",
      "ja": "-maskGenFuncは、マスク生成関数を識別します。これは、セットpkcs1MGFAlgorithmsにOIDを持つアルゴリズムIDである必要があります。このバージョンでは、id-mgf1で構成され、MGF1マスク生成関数を識別します（セクション10.2.1を参照）。パラメータフィールド"
    },
    {
      "indent": 3,
      "text": "id-mgf1 shall have type AlgorithmIdentifier, identifying the hash function on which MGF1 is based, where the OID for the hash function shall be in the set oaepDigestAlgorithms.",
      "ja": "id-mgf1のタイプはAlgorithmIdentifierで、MGF1のベースとなるハッシュ関数を識別します。ハッシュ関数のOIDは、セットoaepDigestAlgorithmsに含まれます。"
    },
    {
      "indent": 3,
      "text": "pkcs1MGFAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {AlgorithmIdentifier {{oaepDigestAlgorithms}} IDENTIFIED\n    BY id-mgf1} }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "id-mgf1 OBJECT IDENTIFIER ::= {pkcs-1 8}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The default mask generation function is MGF1 with SHA-1:",
      "ja": "デフォルトのマスク生成関数は、SHA-1を備えたMGF1です。"
    },
    {
      "indent": 3,
      "text": "mgf1SHA1Identifier ::= AlgorithmIdentifier {\n  id-mgf1, sha1Identifier }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-pSourceFunc identifies the source (and possibly the value) of the encoding parameters P. It shall be an algorithm ID with an OID in the set pkcs1pSourceAlgorithms, which for this version shall consist of id-pSpecified, indicating that the encoding parameters are specified explicitly. The parameters field for id-pSpecified shall have type OCTET STRING, containing the encoding parameters.",
      "ja": "-pSourceFuncは、エンコードパラメータPのソース（および場合によっては値）を識別します。これは、セットpkcs1pSourceAlgorithms内のOIDを持つアルゴリズムIDである必要があります。これは、このバージョンではid-pSpecifiedで構成され、エンコードパラメータが明示的に指定されていることを示します。 。 id-pSpecifiedのパラメーターフィールドは、エンコーディングパラメーターを含むOCTET STRING型でなければなりません。"
    },
    {
      "indent": 3,
      "text": "pkcs1pSourceAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {OCTET STRING IDENTIFIED BY id-pSpecified} }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "id-pSpecified OBJECT IDENTIFIER ::= {pkcs-1 9}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The default encoding parameters is an empty string (so that pHash in EME-OAEP will contain the hash of the empty string):",
      "ja": "デフォルトのエンコードパラメータは空の文字列です（EME-OAEPのpHashに空の文字列のハッシュが含まれるようにするため）。"
    },
    {
      "indent": 3,
      "text": "pSpecifiedEmptyIdentifier ::= AlgorithmIdentifier {\n  id-pSpecified, OCTET STRING SIZE (0) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If all of the default values of the fields in RSAES-OAEP-params are used, then the algorithm identifier will have the following value:",
      "ja": "RSAES-OAEP-paramsのフィールドのデフォルト値がすべて使用されている場合、アルゴリズム識別子は次の値になります。"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-Default-Identifier ::= AlgorithmIdentifier {\n  id-RSAES-OAEP,\n  {sha1Identifier,\n   mgf1SHA1Identifier,\n   pSpecifiedEmptyIdentifier } }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2.2 Syntax for RSAES-PKCS1-v1_5",
      "section_title": true,
      "ja": "11.2.2 RSAES-PKCS1-v1_5の構文"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption (Section 11.1) identifies the RSAES-PKCS1-v1_5 encryption scheme. The parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL. This is the same as in PKCS #1 v1.5.",
      "ja": "オブジェクト識別子rsaEncryption（セクション11.1）は、RSAES-PKCS1-v1_5暗号化スキームを識別します。 AlgorithmIdentifierでこのOIDに関連付けられているパラメーターフィールドのタイプはNULLです。これは、PKCS＃1 v1.5と同じです。"
    },
    {
      "indent": 3,
      "text": "RsaEncryption   OBJECT IDENTIFIER ::= {PKCS-1 1}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2.3 Syntax for RSASSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "11.2.3 RSASSA-PKCS1-v1_5の構文"
    },
    {
      "indent": 3,
      "text": "The object identifier for RSASSA-PKCS1-v1_5 shall be one of the following. The choice of OID depends on the choice of hash algorithm: MD2, MD5 or SHA-1. Note that if either MD2 or MD5 is used then the OID is just as in PKCS #1 v1.5. For each OID, the parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL.",
      "ja": "RSASSA-PKCS1-v1_5のオブジェクト識別子は、次のいずれかになります。 OIDの選択は、ハッシュアルゴリズムの選択（MD2、MD5、またはSHA-1）によって異なります。 MD2またはMD5が使用されている場合、OIDはPKCS＃1 v1.5と同じであることに注意してください。 OIDごとに、AlgorithmIdentifierでこのOIDに関連付けられているパラメーターフィールドのタイプはNULLになります。"
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is MD2, then the OID should be:",
      "ja": "使用するハッシュ関数がMD2の場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "md2WithRSAEncryption ::= {PKCS-1 2}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is MD5, then the OID should be:",
      "ja": "使用するハッシュ関数がMD5の場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "md5WithRSAEncryption ::= {PKCS-1 4}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is SHA-1, then the OID should be:",
      "ja": "使用するハッシュ関数がSHA-1の場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "sha1WithRSAEncryption ::= {pkcs-1 5}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the digestInfo type mentioned in Section 9.2.1 the OIDS for the digest algorithm are the following:",
      "ja": "セクション9.2.1で説明したdigestInfoタイプでは、ダイジェストアルゴリズムのOIDSは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "id-SHA1 OBJECT IDENTIFIER ::=\n        {iso(1) identified-organization(3) oiw(14) secsig(3)\n         algorithms(2) 26 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "md2 OBJECT IDENTIFIER ::=\n        {iso(1) member-body(2) US(840) rsadsi(113549)\n         digestAlgorithm(2) 2}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "md5 OBJECT IDENTIFIER ::=\n        {iso(1) member-body(2) US(840) rsadsi(113549)\n         digestAlgorithm(2) 5}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parameters field of the digest algorithm has ASN.1 type NULL for these OIDs.",
      "ja": "ダイジェストアルゴリズムのパラメーターフィールドには、これらのOIDのASN.1タイプNULLがあります。"
    },
    {
      "indent": 0,
      "text": "12. Patent statement",
      "section_title": true,
      "ja": "12. 特許ステートメント"
    },
    {
      "indent": 3,
      "text": "The Internet Standards Process as defined in RFC 1310 requires a written statement from the Patent holder that a license will be made available to applicants under reasonable terms and conditions prior to approving a specification as a Proposed, Draft or Internet Standard.",
      "ja": "RFC 1310で定義されているインターネット標準プロセスでは、仕様を提案、ドラフト、またはインターネット標準として承認する前に、合理的な条件の下で申請者がライセンスを利用できるようにするという特許権者からの書面による声明が必要です。"
    },
    {
      "indent": 3,
      "text": "The Internet Society, Internet Architecture Board, Internet Engineering Steering Group and the Corporation for National Research Initiatives take no position on the validity or scope of the following patents and patent applications, nor on the appropriateness of the terms of the assurance. The Internet Society and other groups mentioned above have not made any determination as to any other intellectual property rights which may apply to the practice of this standard. Any further consideration of these matters is the user's responsibility.",
      "ja": "Internet Society、Internet Architecture Board、Internet Engineering Steering Group、およびCorporation for National Research Initiativesは、以下の特許および特許出願の有効性または範囲について、また保証の条件の妥当性について、いかなる立場も持ちません。上記のインターネットソサエティおよびその他のグループは、この標準の実施に適用される可能性のあるその他の知的財産権については何も決定していません。これらの事項についてさらに検討することは、ユーザーの責任です。"
    },
    {
      "indent": 0,
      "text": "12.1 Patent statement for the RSA algorithm",
      "section_title": true,
      "ja": "12.1 RSAアルゴリズムの特許ステートメント"
    },
    {
      "indent": 3,
      "text": "The Massachusetts Institute of Technology has granted RSA Data Security, Inc., exclusive sub-licensing rights to the following patent issued in the United States:",
      "ja": "マサチューセッツ工科大学はRSA Data Security、Inc.に、米国で発行された次の特許の独占的サブライセンス権を付与しました。"
    },
    {
      "indent": 3,
      "text": "Cryptographic Communications System and Method (\"RSA\"), No. 4,405,829",
      "ja": "暗号通信システムおよび方法（「RSA」）、No。4,405,829"
    },
    {
      "indent": 3,
      "text": "RSA Data Security, Inc. has provided the following statement with regard to this patent:",
      "ja": "RSA Data Security、Inc.は、この特許に関して次の声明を発表しています。"
    },
    {
      "indent": 3,
      "text": "It is RSA's business practice to make licenses to its patents available on reasonable and nondiscriminatory terms. Accordingly, RSA is willing, upon request, to grant non-exclusive licenses to such patent on reasonable and non-discriminatory terms and conditions to those who respect RSA's intellectual property rights and subject to RSA's then current royalty rate for the patent licensed. The royalty rate for the RSA patent is presently set at 2% of the licensee's selling price for each product covered by the patent. Any requests for license information may be directed to:",
      "ja": "RSAのビジネス慣行では、その特許のライセンスを合理的で差別のない条件で利用できるようにします。したがって、RSAは、要求に応じて、RSAの知的財産権を尊重し、RSAの当時のライセンスを受けた特許の現在のロイヤルティレートを条件として、合理的かつ非差別的な契約条件に基づいて、そのような特許の非独占的ライセンスを付与する意思があります。 RSA特許のロイヤルティレートは現在、特許の対象となる各製品のライセンシーの販売価格の2％に設定されています。ライセンス情報の要求は、次の宛先に送信される場合があります。"
    },
    {
      "indent": 12,
      "text": "Director of Licensing RSA Data Security, Inc. 2955 Campus Drive Suite 400 San Mateo, CA 94403",
      "ja": "RSA Data Security、Inc. 2955 Campus Drive Suite 400ライセンスのディレクター、カリフォルニア州サンマテオ94403"
    },
    {
      "indent": 3,
      "text": "A license under RSA's patent(s) does not include any rights to know-how or other technical information or license under other intellectual property rights. Such license does not extend to any activities which constitute infringement or inducement thereto. A licensee must make his own determination as to whether a license is necessary under patents of others.",
      "ja": "RSAの特許に基づくライセンスには、ノウハウまたはその他の技術情報に対する権利、またはその他の知的財産権に基づくライセンスは含まれません。そのようなライセンスは、それに対する侵害または誘導を構成するいかなる活動にも及びません。ライセンシーは、他人の特許の下でライセンスが必要かどうかについて、自分で決定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13. Revision history",
      "section_title": true,
      "ja": "13. 改訂履歴"
    },
    {
      "indent": 3,
      "text": "Versions 1.0-1.3",
      "ja": "バージョン1.0-1.3"
    },
    {
      "indent": 3,
      "text": "Versions 1.0-1.3 were distributed to participants in RSA Data Security, Inc.'s Public-Key Cryptography Standards meetings in February and March 1991.",
      "ja": "バージョン1.0〜1.3は、1991年2月と3月にRSA Data Security、Inc.の公開鍵暗号規格会議の参加者に配布されました。"
    },
    {
      "indent": 3,
      "text": "Version 1.4",
      "ja": "バージョン1.4"
    },
    {
      "indent": 3,
      "text": "Version 1.4 was part of the June 3, 1991 initial public release of PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop document SEC-SIG-91-18.",
      "ja": "バージョン1.4は、1991年6月3日のPKCSの最初のパブリックリリースの一部でした。バージョン1.4は、NIST / OSI実装者向けワークショップドキュメントSEC-SIG-91-18として公開されました。"
    },
    {
      "indent": 3,
      "text": "Version 1.5",
      "ja": "バージョン1.5"
    },
    {
      "indent": 3,
      "text": "Version 1.5 incorporates several editorial changes, including updates to the references and the addition of a revision history. The following substantive changes were made: -Section 10: \"MD4 with RSA\" signature and verification processes were added.",
      "ja": "バージョン1.5には、参照の更新や改訂履歴の追加など、いくつかの編集上の変更が組み込まれています。次の実質的な変更が行われました。-セクション10：「RSAを使用するMD4」の署名および検証プロセスが追加されました。"
    },
    {
      "indent": 3,
      "text": "-Section 11: md4WithRSAEncryption object identifier was added.",
      "ja": "-セクション11：md4WithRSAEncryptionオブジェクト識別子が追加されました。"
    },
    {
      "indent": 3,
      "text": "Version 2.0 [DRAFT]",
      "ja": "バージョン2.0 [ドラフト]"
    },
    {
      "indent": 3,
      "text": "Version 2.0 incorporates major editorial changes in terms of the document structure, and introduces the RSAEP-OAEP encryption scheme. This version continues to support the encryption and signature processes in version 1.5, although the hash algorithm MD4 is no longer allowed due to cryptanalytic advances in the intervening years.",
      "ja": "バージョン2.0では、ドキュメント構造の点で主要な編集上の変更が組み込まれており、RSAEP-OAEP暗号化スキームが導入されています。このバージョンはバージョン1.5の暗号化および署名プロセスを引き続きサポートしますが、ハッシュアルゴリズムMD4は、その間の年の暗号解読の進歩により許可されなくなりました。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14. 参考文献"
    },
    {
      "indent": 3,
      "text": "[1] ANSI, ANSI X9.44: Key Management Using Reversible Public Key Cryptography for the Financial Services Industry. Work in Progress.",
      "ja": "[1] ANSI、ANSI X9.44：金融サービス業界向けのリバーシブル公開キー暗号化を使用したキー管理。進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[2] M. Bellare and P. Rogaway. Optimal Asymmetric Encryption - How to Encrypt with RSA. In Advances in Cryptology-Eurocrypt '94, pp. 92-111, Springer-Verlag, 1994.",
      "ja": "[2] M.ベラレとP.ロガウェイ。最適な非対称暗号化-RSAで暗号化する方法。 In Advances in Cryptology-Eurocrypt '94、pp.92-111、Springer-Verlag、1994。"
    },
    {
      "indent": 3,
      "text": "[3] M. Bellare and P. Rogaway. The Exact Security of Digital Signatures - How to Sign with RSA and Rabin. In Advances in Cryptology-Eurocrypt '96, pp. 399-416, Springer-Verlag, 1996.",
      "ja": "[3] M.ベラレとP.ロガウェイ。デジタル署名の正確なセキュリティ-RSAとRabinで署名する方法。 In Advances in Cryptology-Eurocrypt '96、pp。399-416、Springer-Verlag、1996。"
    },
    {
      "indent": 3,
      "text": "[4] D. Bleichenbacher. Chosen Ciphertext Attacks against Protocols Based on the RSA Encryption Standard PKCS #1. To appear in Advances in Cryptology-Crypto '98.",
      "ja": "[4] D.ブライヘンバッハー。 RSA暗号化標準PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃。 Advances in Cryptology-Crypto '98に掲載されます。"
    },
    {
      "indent": 3,
      "text": "[5] D. Bleichenbacher, B. Kaliski and J. Staddon. Recent Results on PKCS #1: RSA Encryption Standard. RSA Laboratories' Bulletin, Number 7, June 24, 1998.",
      "ja": "[5] D.ブライチェンバッハー、B。カリスキ、J。スタドン。 PKCS＃1の最近の結果：RSA暗号化標準。 RSA Laboratories 'Bulletin、第7号、1998年6月24日。"
    },
    {
      "indent": 3,
      "text": "[6] CCITT. Recommendation X.509: The Directory-Authentication Framework. 1988.",
      "ja": "[6] CCITT。推奨事項X.509：ディレクトリ認証フレームワーク。 1988。"
    },
    {
      "indent": 3,
      "text": "[7] D. Coppersmith, M. Franklin, J. Patarin and M. Reiter. Low-Exponent RSA with Related Messages. In Advances in Cryptology-Eurocrypt '96, pp. 1-9, Springer-Verlag, 1996",
      "ja": "[7] D.コッパースミス、M。フランクリン、J。パタリン、M。ライター。関連メッセージのある低指数RSA。暗号学の進歩-Eurocrypt '96、1-9ページ、Springer-Verlag、1996"
    },
    {
      "indent": 3,
      "text": "[8] B. Den Boer and Bosselaers. Collisions for the Compression Function of MD5. In Advances in Cryptology-Eurocrypt '93, pp 293-304, Springer-Verlag, 1994.",
      "ja": "[8] B. Den BoerとBosselaers。 MD5の圧縮機能の衝突。 In Advances in Cryptology-Eurocrypt '93、pp 293-304、Springer-Verlag、1994。"
    },
    {
      "indent": 3,
      "text": "[9] B. den Boer, and A. Bosselaers. An Attack on the Last Two Rounds of MD4. In Advances in Cryptology-Crypto '91, pp.194-203, Springer-Verlag, 1992.",
      "ja": "[9] B. den Boer、およびA. Bosselaers。 MD4の最後の2ラウンドへの攻撃。 Advances in Cryptology-Crypto '91、pp.194-203、Springer-Verlag、1992。"
    },
    {
      "indent": 3,
      "text": "[10] H. Dobbertin. Cryptanalysis of MD4. Fast Software Encryption. Lecture Notes in Computer Science, Springer-Verlag 1996, pp. 55-72.",
      "ja": "[10] H.ドベルティン。 MD4の暗号解析。高速ソフトウェア暗号化。コンピュータサイエンスの講義ノート、Springer-Verlag 1996、55-72ページ。"
    },
    {
      "indent": 3,
      "text": "[11] H. Dobbertin. Cryptanalysis of MD5 Compress. Presented at the rump session of Eurocrypt `96, May 14, 1996",
      "ja": "[11] H.ドベルティン。 MD5 Compressの暗号解読。 1996年5月14日、Eurocrypt `96のランプセッションで発表"
    },
    {
      "indent": 3,
      "text": "[12] H. Dobbertin.The First Two Rounds of MD4 are Not One-Way. Fast Software Encryption. Lecture Notes in Computer Science, Springer-Verlag 1998, pp. 284-292.",
      "ja": "[12] H.ドベルティン。MD4の最初の2つのラウンドは一方向ではありません。高速ソフトウェア暗号化。コンピュータサイエンスの講義ノート、Springer-Verlag 1998、pp。284-292。"
    },
    {
      "indent": 3,
      "text": "[13] J. Hastad. Solving Simultaneous Modular Equations of Low Degree. SIAM Journal of Computing, 17, 1988, pp. 336-341.",
      "ja": "[13] J.ハスタッド。低次数の同時モジュラ方程式を解くSIAM Journal of Computing、17、1988、pp.336-341。"
    },
    {
      "indent": 3,
      "text": "[14] IEEE. IEEE P1363: Standard Specifications for Public Key Cryptography. Draft Version 4.",
      "ja": "[14] IEEE。 IEEE P1363：公開鍵暗号の標準仕様。ドラフトバージョン4。"
    },
    {
      "indent": 3,
      "text": "[15] Kaliski, B., \"The MD2 Message-Digest Algorithm\", RFC 1319, April 1992.",
      "ja": "[15] Kaliski、B。、「MD2メッセージダイジェストアルゴリズム」、RFC 1319、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[16] National Institute of Standards and Technology (NIST). FIPS Publication 180-1: Secure Hash Standard. April 1994.",
      "ja": "[16] 国立標準技術研究所（NIST）。 FIPS Publication 180-1：Secure Hash Standard。 1994年4月。"
    },
    {
      "indent": 3,
      "text": "[17] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[17] Rivest、R。、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[18] R. Rivest, A. Shamir and L. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Communications of the ACM, 21(2), pp. 120-126, February 1978.",
      "ja": "[18] R.リベスト、A。シャミール、L。アドルマン。デジタル署名と公開鍵暗号システムを取得する方法。 ACMの通信、21（2）、120-126ページ、1978年2月。"
    },
    {
      "indent": 3,
      "text": "[19] N. Rogier and P. Chauvaud. The Compression Function of MD2 is not Collision Free. Presented at Selected Areas of Cryptography `95. Carleton University, Ottawa, Canada. May 18-19, 1995.",
      "ja": "[19] N. RogierおよびP. Chauvaud。 MD2の圧縮機能は衝突なしではありません。暗号化の選択された領域'95で発表されました。カナダのオタワにあるカールトン大学。 1995年5月18日〜19日。"
    },
    {
      "indent": 3,
      "text": "[20] RSA Laboratories. PKCS #1: RSA Encryption Standard. Version 1.5, November 1993.",
      "ja": "[20] RSA Laboratories。 PKCS＃1：RSA暗号化標準。バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[21] RSA Laboratories. PKCS #7: Cryptographic Message Syntax Standard. Version 1.5, November 1993.",
      "ja": "[21] RSA Laboratories。 PKCS＃7：暗号メッセージ構文標準。バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[22] RSA Laboratories. PKCS #8: Private-Key Information Syntax Standard. Version 1.2, November 1993.",
      "ja": "[22] RSA Laboratories。 PKCS＃8：秘密鍵情報構文標準。バージョン1.2、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[23] RSA Laboratories. PKCS #12: Personal Information Exchange Syntax Standard. Version 1.0, Work in Progress, April 1997.",
      "ja": "[23] RSA Laboratories。 PKCS＃12：個人情報交換構文標準。バージョン1.0、作業中、1997年4月。"
    },
    {
      "indent": 0,
      "text": "Security Considerations",
      "ja": "セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ全体で議論されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is based on a contribution of RSA Laboratories, a division of RSA Data Security, Inc. Any substantial use of the text from this document must acknowledge RSA Data Security, Inc. RSA Data Security, Inc. requests that all material mentioning or referencing this document identify this as \"RSA Data Security, Inc. PKCS #1 v2.0\".",
      "ja": "このドキュメントは、RSA Data Security、Incの一部門であるRSA Laboratoriesの寄稿に基づいています。このドキュメントのテキストを実質的に使用する場合は、RSA Data Security、Inc.に同意する必要があります。RSAData Security、Inc.は、すべての資料について言及または参照することを要求します。このドキュメントでは、これを「RSA Data Security、Inc. PKCS＃1 v2.0」として識別します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Burt Kaliski RSA Laboratories East 20 Crosby Drive Bedford, MA 01730",
      "ja": "Burt Kaliski RSA Laboratories East 20 Crosby Drive Bedford、MA 01730"
    },
    {
      "indent": 3,
      "text": "Phone: (617) 687-7000 EMail: burt@rsa.com",
      "ja": "電話：（617）687-7000メール：burt@rsa.com"
    },
    {
      "indent": 3,
      "text": "Jessica Staddon RSA Laboratories West 2955 Campus Drive Suite 400 San Mateo, CA 94403",
      "ja": "Jessica Staddon RSA Laboratories West 2955 Campus Drive Suite 400 San Mateo、CA 94403"
    },
    {
      "indent": 3,
      "text": "Phone: (650) 295-7600 EMail: jstaddon@rsa.com",
      "ja": "電話：（650）295-7600メール：jstaddon@rsa.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができますただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されないいかなる保証も含め、一切の保証を否認します。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。"
    }
  ]
}