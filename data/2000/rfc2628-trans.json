{
  "title": {
    "text": "RFC 2628 - Simple Cryptographic Program Interface (Crypto API)",
    "ja": "RFC 2628 - シンプルな暗号化プログラムインターフェイス（Crypto API）"
  },
  "number": 2628,
  "created_at": "2020-08-22 18:03:44.002739+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         V. Smyslov\nRequest for Comments: 2628                                           TWS\nCategory: Informational                                        June 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Simple Cryptographic Program Interface (Crypto API)",
      "ja": "シンプルな暗号化プログラムインターフェイス（Crypto API）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準も規定していません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a simple Application Program Interface to cryptographic functions. The main purpose of such an interface is to separate cryptographic libraries from internet applications, thus allowing an independent development of both. It can be used in various internet applications such as [IPsec], [ISAKMP], [IKE], [TLS].",
      "ja": "このドキュメントでは、暗号化機能への簡単なアプリケーションプログラムインターフェイスについて説明します。そのようなインターフェースの主な目的は、暗号化ライブラリをインターネットアプリケーションから分離することであり、それによって両方の独立した開発を可能にします。 [IPsec]、[ISAKMP]、[IKE]、[TLS]などのさまざまなインターネットアプリケーションで使用できます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction. . . . . . . . . . . . . . . . . . . . . . . . . .  2\n1.1. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . .  2\n1.2. Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  2\n1.3. Objectives of Development . . . . . . . . . . . . . . . . . .  3\n2. Cryptoplugin Structure. . . . . . . . . . . . . . . . . . . . .  3\n3. Program Interface . . . . . . . . . . . . . . . . . . . . . . .  4\n3.1. Cryptoplugin Initialization Function. . . . . . . . . . . . .  4\n3.1.1. Description of CryptoPluginInfo structure . . . . . . . . .  6\n3.1.2. Description of CryptoAlgInfo structure. . . . . . . . . . .  6\n3.2. Cryptoplugin Deinitialization Function. . . . . . . . . . . .  9\n3.3. Cryptographic Context Opening Function. . . . . . . . . . . . 10\n3.4. Cryptographic Context Reopening Function. . . . . . . . . . . 11\n3.5. Cryptographic Context Closing Function. . . . . . . . . . . . 12\n3.6. Key Verification Function . . . . . . . . . . . . . . . . . . 12\n3.7. Data Transformation Function. . . . . . . . . . . . . . . . . 13\n3.7.1. For CRYPTO_TYPE_ENCRYPT Algorithm Type. . . . . . . . . . . 13\n3.7.2. For CRYPTO_TYPE_DECRYPT Algorithm Type. . . . . . . . . . . 14\n3.7.3. For CRYPTO_TYPE_SIGN Algorithm Type . . . . . . . . . . . . 15\n3.7.4. For CRYPTO_TYPE_VERIFY Algorithm Type . . . . . . . . . . . 17\n3.7.5. For CRYPTO_TYPE_COMPRESS Algorithm Type . . . . . . . . . . 18",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3.7.6. For CRYPTO_TYPE_UNCOMPRESS Algorithm Type . . . . . . . . . 18\n3.7.7. For CRYPTO_TYPE_HASH Algorithm Type . . . . . . . . . . . . 19\n3.7.8. For CRYPTO_TYPE_RANDOM Algorithm Type.  . . . . . . . . . . 21\n3.8. Cryptographic Context Control Function. . . . . . . . . . . . 22\n4. Cryptoplugin Registration Procedure . . . . . . . . . . . . . . 23\n5. Security Considerations . . . . . . . . . . . . . . . . . . . . 23\n6. References. . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n7. Author's Address  . . . . . . . . . . . . . . . . . . . . . . . 24\nAppendix A. The interface specification as a C header file . . . . 25\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 30",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Summary",
      "section_title": true,
      "ja": "1.1. 概要"
    },
    {
      "indent": 3,
      "text": "Nowadays internet applications that require cryptographic functions at the level of operating system kernel, use the method that assumes the libraries must be compiled/linked together with the module (driver) which provides product functionality. For the sake of possibility of independent development of the cryptographic modules and in order to provide a simple, effective and universal (suitable for application and as well kernel level of operating system) solution this specification offers the method to extract encrypting algorithms to the separate cryptographic modules.",
      "ja": "現在、オペレーティングシステムカーネルのレベルで暗号化機能を必要とするインターネットアプリケーションでは、製品の機能を提供するモジュール（ドライバー）と共にライブラリをコンパイル/リンクする必要があると想定する方法を使用します。暗号化モジュールの独立した開発の可能性のために、シンプルで効果的でユニバーサルな（アプリケーションおよびオペレーティングシステムのカーネルレベルに適した）ソリューションを提供するために、この仕様は、暗号化アルゴリズムを個別の暗号化に抽出する方法を提供しますモジュール。"
    },
    {
      "indent": 3,
      "text": "This document describes simple open interface (Crypto API) to external cryptographic libraries optimized both for the application and kernel level of the operating system.",
      "ja": "このドキュメントでは、アプリケーションとオペレーティングシステムのカーネルレベルの両方に最適化された外部暗号化ライブラリへのシンプルなオープンインターフェース（Crypto API）について説明します。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "Cryptoplugin",
      "ja": "暗号プラグイン"
    },
    {
      "indent": 6,
      "text": "Operation system unit (driver, shared library, module) that provides cryptographic functions via well-defined (but OS-specific) interface.",
      "ja": "明確に定義された（ただしOS固有の）インターフェースを介して暗号化機能を提供するオペレーションシステムユニット（ドライバー、共有ライブラリ、モジュール）。"
    },
    {
      "indent": 3,
      "text": "Cryptolibrary",
      "ja": "暗号図書館"
    },
    {
      "indent": 6,
      "text": "Part of cryptoplugin that provides its cryptographic functionality via Crypto API.",
      "ja": "Crypto APIを介して暗号機能を提供する暗号プラグインの一部。"
    },
    {
      "indent": 3,
      "text": "Wrapper",
      "ja": "ラッパー"
    },
    {
      "indent": 6,
      "text": "Part of cryptoplugin that provides interfaces translation between Crypto API and OS-specific interface.",
      "ja": "Crypto APIとOS固有のインターフェース間のインターフェース変換を提供する暗号プラグインの一部。"
    },
    {
      "indent": 3,
      "text": "Definition of all cryptography related terms can be found in [Schneier].",
      "ja": "暗号化に関連するすべての用語の定義は、[Schneier]にあります。"
    },
    {
      "indent": 0,
      "text": "1.3. Objectives of Development",
      "section_title": true,
      "ja": "1.3. 開発の目的"
    },
    {
      "indent": 3,
      "text": "The objectives of Simple CryptoAPI development are as follows:",
      "ja": "Simple CryptoAPI開発の目的は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "1) To extract program implementations of encryption, one-way hash function, digital signature and random numbers generation algorithms to separate, independently developed modules.",
      "ja": "1）暗号化、一方向ハッシュ関数、デジタル署名、乱数生成アルゴリズムのプログラム実装を抽出して、独立して開発されたモジュールを分離します。"
    },
    {
      "indent": 6,
      "text": "2) To provide version independence between using encryption modules and external cryptoplugin.",
      "ja": "2）暗号化モジュールと外部暗号プラグインの使用の間でバージョンに依存しないようにするため。"
    },
    {
      "indent": 6,
      "text": "3) To ensure platform independent developments of encrypting algorithm modules with portable source code.",
      "ja": "3）ポータブルソースコードを使用した暗号化アルゴリズムモジュールのプラットフォームに依存しない開発を保証する。"
    },
    {
      "indent": 6,
      "text": "4) To enable independent development of modules and compatibility of modules developed independently.",
      "ja": "4）モジュールの独立した開発および独立して開発されたモジュールの互換性を可能にする。"
    },
    {
      "indent": 0,
      "text": "2. Cryptoplugin Structure",
      "section_title": true,
      "ja": "2. 暗号プラグインの構造"
    },
    {
      "indent": 3,
      "text": "In order to provide fast exchange between the cryptoplugin and its client the cryptoplugin is implemented as a separate driver (or module) of the particular operating system (Fig.1). Cryptoplugin consists of two parts (Fig.2):",
      "ja": "暗号プラグインとそのクライアント間の高速交換を提供するために、暗号プラグインは特定のオペレーティングシステムの個別のドライバー（またはモジュール）として実装されます（図1）。 Cryptopluginは2つの部分で構成されています（図2）。"
    },
    {
      "indent": 6,
      "text": "1) cryptolibrary itself (1)",
      "ja": "1）暗号ライブラリ自体（1）"
    },
    {
      "indent": 6,
      "text": "2) system-dependent module (wrapper) for interaction between cryptolibrary and its client (2)",
      "ja": "2）暗号ライブラリとそのクライアントの間の相互作用のためのシステム依存モジュール（ラッパー）（2）"
    },
    {
      "indent": 5,
      "text": "                                  Cryptoplugin initialization\n                                / by the operating system\n                                |\n                                |\n+------------------+          +-|-+-------------+\n|                  |          |   |             |\n|  Cryptoplugin's  | -------> |                 |\n|                  |          |  Cryptoplugin   |\n|     client       | <------- |                 |\n|                  |          |   |             |\n+------------------+     |    +---+-------------+\n                         |\n                         \\\n                          \\ System-dependent CPI",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Fig. 1 Interaction between cryptoplugin and its client",
      "ja": "図1クリプトプラグインとそのクライアント間の相互作用"
    },
    {
      "indent": 5,
      "text": "+---------------+-------------------------------+\n|               |                               |\n|              -->       Submodule of           |\n|  Submodule -  |                               |\n|               |   encrypting algorithms (1)   |\n|  wrapper (2)  |                               |\n|              <--       (cryptolibrary)        |\n|               |                               |\n+---------------+-------------------------------+\n                |\n                \\\n                 \\ Cryptographic Program Interface",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Fig. 2 Cryptoplugin structure",
      "ja": "図2暗号プラグインの構造"
    },
    {
      "indent": 3,
      "text": "The system-dependent module (wrapper) is delivered by the driver-client developer in the form of source code or in the form of libraries (for example, in the form of object files) for particular operating system. The wrapper is intended for translation of system-independent application interface to the particular system-dependent interface with the cryptoplugin's client. The wrapper context does not include components specific to cryptoplugin's client functionality or to some cryptographic algorithm. The interface described in section 3 is the standard for interaction between the submodules (1) and (2).",
      "ja": "システム依存のモジュール（ラッパー）は、特定のオペレーティングシステム用に、ソースコードの形式またはライブラリーの形式（オブジェクトファイルの形式など）でドライバーとクライアントの開発者によって提供されます。ラッパーは、システムに依存しないアプリケーションインターフェイスを、暗号プラグインのクライアントを使用する特定のシステムに依存するインターフェイスに変換することを目的としています。ラッパーコンテキストには、cryptopluginのクライアント機能または一部の暗号化アルゴリズムに固有のコンポーネントは含まれていません。セクション3で説明するインターフェースは、サブモジュール（1）と（2）間の相互作用の標準です。"
    },
    {
      "indent": 3,
      "text": "A cryptoplugin can contain a number of different algorithms. Moreover, it can contain some different implementations of one particular algorithm.",
      "ja": "暗号プラグインには、さまざまなアルゴリズムを含めることができます。さらに、1つの特定のアルゴリズムのいくつかの異なる実装を含めることができます。"
    },
    {
      "indent": 0,
      "text": "3. Program Interface",
      "section_title": true,
      "ja": "3. プログラムインターフェース"
    },
    {
      "indent": 3,
      "text": "The CPI (Cryptographic Program Interface) consists of a set of functions exported by encrypting algorithm submodule (cryptolibrary). The interface functions are described below (see also Appendix A).",
      "ja": "CPI（Cryptographic Program Interface）は、暗号化アルゴリズムサブモジュール（cryptolibrary）によってエクスポートされた一連の関数で構成されています。インターフェース機能については以下で説明します（付録Aも参照）。"
    },
    {
      "indent": 0,
      "text": "3.1. Cryptoplugin Initialization Function",
      "section_title": true,
      "ja": "3.1. Cryptoplugin初期化関数"
    },
    {
      "indent": 3,
      "text": "The function is intended for cryptoplugin initialization and obtaining information about algorithms contained in cryptoplugin. The function is called once before the beginning of cryptoplugin operation.",
      "ja": "この関数は、cryptopluginの初期化と、cryptopluginに含まれるアルゴリズムに関する情報の取得を目的としています。この関数は、cryptopluginの動作が始まる前に一度呼び出されます。"
    },
    {
      "indent": 3,
      "text": "/* CryptoPlugin initialization. Returns pointer to CryptoPluginInfo\nstructure on success or NULL on fatal error. */\nCryptoPluginInfo *CryptoPluginInit(\n                void            *param);/* Ptr to OS parameters\n                                           (platform-specific) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Description of parameters:",
      "ja": "パラメータの説明："
    },
    {
      "indent": 6,
      "text": "param - pointer to system-dependent parameters transmitted to cryptoplugin by the operating system. Intention and format of parameters are specific to each operating system and should be described in documentation on the cryptoplugin wrapper.",
      "ja": "param-オペレーティングシステムによって暗号プラグインに送信されるシステム依存のパラメーターへのポインター。パラメータの意図と形式は各オペレーティングシステムに固有であり、cryptopluginラッパーのドキュメントに記載する必要があります。"
    },
    {
      "indent": 3,
      "text": "The function is called at the moment of cryptoplugin initialization. If succeeded it returns the pointer to CryptoPluginInfo structure that describes the module and algorithms implemented in the cryptolibrary. If function call did not succeed, function will return NULL or appropriate error code in CryptoPluginInfo structure status field. If the initialization is partially succeeded then the cryptoplugin either returns CryptoPluginInfo structure transformed so that it contains only successfully initialized algorithms or returns appropriate error code in status field of CryptoAlgInfo structures that describes the reason for the failure.",
      "ja": "関数は、cryptopluginの初期化時に呼び出されます。成功した場合は、cryptolibraryに実装されているモジュールとアルゴリズムを記述するCryptoPluginInfo構造体へのポインターを返します。関数呼び出しが成功しなかった場合、関数はNULLまたは適切なエラーコードをCryptoPluginInfo構造ステータスフィールドに返します。初期化が部分的に成功した場合、cryptopluginは正常に初期化されたアルゴリズムのみを含むように変換されたCryptoPluginInfo構造を返すか、CryptoAlgInfo構造のステータスフィールドに失敗の理由を説明する適切なエラーコードを返します。"
    },
    {
      "indent": 3,
      "text": "Error codes for the function:",
      "ja": "関数のエラーコード："
    },
    {
      "indent": 6,
      "text": "NULL - fatal unsuccessful cryptoplugin initialization. The module is unable even to indicate the reason of failure.",
      "ja": "NULL-致命的に失敗した暗号プラグインの初期化。モジュールは、失敗の理由を示すことさえできません。"
    },
    {
      "indent": 3,
      "text": "The pointer to cryptoplugin description structure in the case of full or partial success. The status fields in CryptoPluginInfo structure and in comprised CryptoAlgInfo structures can be set to the following values:",
      "ja": "完全または部分的な成功の場合の暗号プラグイン記述構造へのポインター。 CryptoPluginInfo構造および構成されたCryptoAlgInfo構造のステータスフィールドは、次の値に設定できます。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - cryptoplugin (algorithm) is initialized successfully.",
      "ja": "CRYPTO_OK-cryptoplugin（アルゴリズム）が正常に初期化されました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NOT_SUPPORTED - (only for algorithm) - the algorithm is not supported by the module at the moment.",
      "ja": "CRYPTO_ERR_NOT_SUPPORTED-（アルゴリズムのみ）-現在、アルゴリズムはモジュールでサポートされていません。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_HARDWARE - error of hardware initialization.",
      "ja": "CRYPTO_ERR_HARDWARE-ハードウェア初期化のエラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Description of CryptoPluginInfo structure",
      "section_title": true,
      "ja": "3.1.1. CryptoPluginInfo構造の説明"
    },
    {
      "indent": 3,
      "text": "The CryptoPluginInfo structure consists of header of fixed size that generally describes cryptoplugin and array of CryptoAlgInfo structures following the header. Each structure describes particular algorithm implemented in the cryptolibrary (see Appendix A)",
      "ja": "CryptoPluginInfo構造は、一般的に暗号プラグインを記述する固定サイズのヘッダーと、ヘッダーに続くCryptoAlgInfo構造の配列で構成されます。各構造は、暗号ライブラリに実装された特定のアルゴリズムを記述します（付録Aを参照）"
    },
    {
      "indent": 3,
      "text": "Structure fields description:",
      "ja": "構造フィールドの説明："
    },
    {
      "indent": 6,
      "text": "cpi_version - CPI version (should be CRYPTO_VER (1,0)). CPI version determines both functions set and fields layout in CryptoPluginInfo/CryptoAlgInfo structures.",
      "ja": "cpi_version-CPIバージョン（CRYPTO_VER（1,0）でなければなりません）。 CPIバージョンは、CryptoPluginInfo / CryptoAlgInfo構造体の関数セットとフィールドレイアウトの両方を決定します。"
    },
    {
      "indent": 6,
      "text": "status - returns the error code if cryptoplugin initialization failed (otherwise should be CRYPTO_OK)",
      "ja": "status-cryptopluginの初期化が失敗した場合はエラーコードを返します（そうでない場合はCRYPTO_OKである必要があります）"
    },
    {
      "indent": 6,
      "text": "name - text cryptoplugin description (ASCII-7 characters only; all unused bytes must be set to 0).",
      "ja": "name-テキスト暗号プラグインの説明（ASCII-7文字のみ。未使用のバイトはすべて0に設定する必要があります）。"
    },
    {
      "indent": 6,
      "text": "version - cryptoplugin version (CRYPTO_VER(maj,min)).",
      "ja": "version-暗号プラグインのバージョン（CRYPTO_VER（5月、分））。"
    },
    {
      "indent": 6,
      "text": "flags - various flags that characterize the cryptoplugin.",
      "ja": "flags-暗号プラグインを特徴付けるさまざまなフラグ。"
    },
    {
      "indent": 6,
      "text": "number_of_algs - number of algorithms the cryptolibrary comprises of (i.e. the number of consequent CryptoAlgInfo structures).",
      "ja": "number_of_algs-暗号ライブラリが構成するアルゴリズムの数（つまり、結果として生じるCryptoAlgInfo構造の数）。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Description of CryptoAlgInfo structure",
      "section_title": true,
      "ja": "3.1.2. CryptoAlgInfo構造の説明"
    },
    {
      "indent": 3,
      "text": "Structure fields description",
      "ja": "構造フィールドの説明"
    },
    {
      "indent": 6,
      "text": "status - returns the error code if particular algorithm initialization failed (otherwise should be CRYPTO_OK).",
      "ja": "status-特定のアルゴリズムの初期化が失敗した場合にエラーコードを返します（それ以外の場合はCRYPTO_OKである必要があります）。"
    },
    {
      "indent": 6,
      "text": "id - algorithm identifier (CRYPTO_A_XXX). Values in the range of 0..249 are reserved; Values in the range of 250..32767 indicate algorithms not enrolled in standard list. It should be emphasized that algorithm IDs are independent for each algorithm type. But it is considered that pairs of types CRYPTO_TYPE_ENCRYPT and CRYPTO_TYPE_DECRYPT, CRYPTO_TYPE_SIGN and CRYPTO_TYPE_VERIFY, CRYPTO_TYPE_COMPRESS and CRYPTO_TYPE_UNCOMPRESS are equivalent because they define reverse actions of the same nature.",
      "ja": "id-アルゴリズム識別子（CRYPTO_A_XXX）。 0..249の範囲の値は予約されています。 250..32767の範囲の値は、標準リストに登録されていないアルゴリズムを示します。アルゴリズムIDは、アルゴリズムタイプごとに独立していることを強調しておく必要があります。ただし、タイプCRYPTO_TYPE_ENCRYPTとCRYPTO_TYPE_DECRYPT、CRYPTO_TYPE_SIGNとCRYPTO_TYPE_VERIFY、CRYPTO_TYPE_COMPRESSとCRYPTO_TYPE_UNCOMPRESSのペアは、同じ性質の逆のアクションを定義するため、同等であると見なされます。"
    },
    {
      "indent": 6,
      "text": "group - algorithm implementation group (variants algorithm implementations with various parameters not covered by CryptoAlgInfo structure). Values in the range of 0..32767 are well-known numbers defined in Appendix A; vendors may arbitrarily use values in the range of 32768..65535.",
      "ja": "group-アルゴリズム実装グループ（CryptoAlgInfo構造ではカバーされないさまざまなパラメーターを持つバリアントアルゴリズム実装）。 0..32767の範囲の値は、付録Aで定義されている既知の数値です。ベンダーは、32768..65535の範囲の値を任意に使用できます。"
    },
    {
      "indent": 6,
      "text": "type - algorithm type (CRYPTO_TYPE_XXX). Unambiguously determines algorithm application.",
      "ja": "type-アルゴリズムのタイプ（CRYPTO_TYPE_XXX）。アルゴリズムの適用を明確に決定します。"
    },
    {
      "indent": 6,
      "text": "version - version of algorithm implementation (CRYPTO_VER (maj,min)).",
      "ja": "version-アルゴリズム実装のバージョン（CRYPTO_VER（maj、min））。"
    },
    {
      "indent": 6,
      "text": "flags - flags that characterize the algorithm and its implementation. All bits, that are not defined in Appendix A, must be zeroed.",
      "ja": "flags-アルゴリズムとその実装を特徴付けるフラグ。付録Aで定義されていないすべてのビットはゼロにする必要があります。"
    },
    {
      "indent": 6,
      "text": "maxcontexts - maximum cryptographic contexts number that are simultaneously supported by the algorithm implementation (0 if the number is unlimited or is limited only by environmental conditions like memory size).",
      "ja": "maxcontexts-アルゴリズム実装によって同時にサポートされる最大の暗号化コンテキスト数（数値が無制限であるか、メモリサイズなどの環境条件によってのみ制限される場合は0）。"
    },
    {
      "indent": 6,
      "text": "name - text algorithm name (ASCII characters use only; all unused bytes must be set to 0).",
      "ja": "name-テキストアルゴリズム名（ASCII文字のみ使用。未使用のバイトはすべて0に設定する必要があります）。"
    },
    {
      "indent": 3,
      "text": "The next information depends on algorithm type:",
      "ja": "次の情報は、アルゴリズムのタイプによって異なります。"
    },
    {
      "indent": 3,
      "text": "For encryption algorithms (CRYPTO_TYPE_ENCRYPT and CRYPTO_TYPE_DECRYPT):",
      "ja": "暗号化アルゴリズム（CRYPTO_TYPE_ENCRYPTおよびCRYPTO_TYPE_DECRYPT）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - data block length in bytes (value 1 must be used for stream cipher algorithms).",
      "ja": "blocklen-バイト単位のデータブロック長（ストリーム暗号アルゴリズムには値1を使用する必要があります）。"
    },
    {
      "indent": 6,
      "text": "keylen - encrypting (or decrypting) key length in bytes.",
      "ja": "keylen-キーの長さをバイト単位で暗号化（または復号化）します。"
    },
    {
      "indent": 6,
      "text": "outlen - output data size for conversion of one input data block in bytes. Usually it is equal to blocklen. When prediction of this value is impossible zero value must be indicated.",
      "ja": "outlen-1つの入力データブロックを変換するための出力データサイズ（バイト単位）。通常はblocklenと同じです。この値の予測が不可能な場合は、ゼロ値を指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "milen - size of initialization vector (for block algorithms) or message indicator (for stream algorithms) in bytes. For block algorithms zero value of the parameter means that the algorithm implements ECB encoding. Non-zero milen parameter means that the algorithm implements CBC encoding. For stream algorithms zero value of the parameter means that the message indicator is not required.",
      "ja": "milen-初期化ベクトル（ブロックアルゴリズムの場合）またはメッセージインジケーター（ストリームアルゴリズムの場合）のサイズ（バイト単位）。ブロックアルゴリズムの場合、パラメーターのゼロ値は、アルゴリズムがECBエンコーディングを実装することを意味します。ゼロ以外のmilenパラメータは、アルゴリズムがCBCエンコーディングを実装することを意味します。ストリームアルゴリズムの場合、パラメーターの値がゼロの場合、メッセージインジケーターは必要ありません。"
    },
    {
      "indent": 3,
      "text": "For signature algorithms (CRYPTO_TYPE_SIGN):",
      "ja": "署名アルゴリズム（CRYPTO_TYPE_SIGN）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - block size in bytes. The length of input signature data will be padded up to this value. When there is no need in padding the value of 1 must be set.",
      "ja": "blocklen-バイト単位のブロックサイズ。入力署名データの長さは、この値まで埋め込まれます。パディングする必要がない場合は、値1を設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "keylen - private key length in bytes.",
      "ja": "keylen-バイト単位の秘密鍵の長さ。"
    },
    {
      "indent": 6,
      "text": "outlen - signature length in bytes. When prediction of this value is impossible 0 value must be indicated. If the signature consists of several values then the total length is indicated.",
      "ja": "outlen-バイト単位の署名の長さ。この値の予測が不可能な場合は、0値を指定する必要があります。署名が複数の値で構成されている場合は、全長が示されます。"
    },
    {
      "indent": 6,
      "text": "milen - non-zero value specifies signature parameter length (random number), zero value indicates that the parameter is not required.",
      "ja": "milen-ゼロ以外の値は署名パラメーターの長さ（乱数）を指定し、ゼロの値はパラメーターが不要であることを示します。"
    },
    {
      "indent": 3,
      "text": "For signature verification algorithms (CRYPTO_TYPE_VERIFY):",
      "ja": "署名検証アルゴリズム（CRYPTO_TYPE_VERIFY）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - is not used.",
      "ja": "blocklen-使用されません。"
    },
    {
      "indent": 6,
      "text": "keylen - length of public key in bytes.",
      "ja": "keylen-公開鍵の長さ（バイト単位）。"
    },
    {
      "indent": 6,
      "text": "outlen - signature length in bytes. When prediction of this value is impossible 0 value must be indicated. If the signature consists of several values then the total length is indicated.",
      "ja": "outlen-バイト単位の署名の長さ。この値の予測が不可能な場合は、0値を指定する必要があります。署名が複数の値で構成されている場合は、全長が示されます。"
    },
    {
      "indent": 6,
      "text": "milen - is not used.",
      "ja": "milen-使用されません。"
    },
    {
      "indent": 3,
      "text": "For data compression algorithms (CRYPTO_TYPE_COMPRESS):",
      "ja": "データ圧縮アルゴリズム（CRYPTO_TYPE_COMPRESS）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - see outlen.",
      "ja": "blocklen-outlenを参照してください。"
    },
    {
      "indent": 6,
      "text": "keylen - is not used.",
      "ja": "keylen-使用されません。"
    },
    {
      "indent": 6,
      "text": "outlen - if the algorithm provides the fixed compression with known value then it is indicated as blocklen/outlen ratio. The values can be arbitrary. If the compression value is not known then outlen is set to 0 and blocklen is not used.",
      "ja": "outlen-アルゴリズムが既知の値で固定圧縮を提供する場合、それはblocklen / outlen比として示されます。値は任意にすることができます。圧縮値が不明な場合、outlenは0に設定され、blocklenは使用されません。"
    },
    {
      "indent": 6,
      "text": "milen - is not used.",
      "ja": "milen-使用されません。"
    },
    {
      "indent": 3,
      "text": "For data uncompressing algorithms (CRYPTO_TYPE_UNCOMPRESS):",
      "ja": "データ圧縮解除アルゴリズム（CRYPTO_TYPE_UNCOMPRESS）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - see outlen.",
      "ja": "blocklen-outlenを参照してください。"
    },
    {
      "indent": 6,
      "text": "keylen - is not used.",
      "ja": "keylen-使用されません。"
    },
    {
      "indent": 6,
      "text": "outlen - if the algorithm provides the fixed compression with known value then it is indicated as blocklen/outlen ratio. The values can be arbitrary. It is natural that the ratio will be reverse to the similar value for the same algorithm but of CRYPTO_TYPE_COMPRESS type. If the compression value is not known then outlen is set to 0 and blocklen is not used.",
      "ja": "outlen-アルゴリズムが既知の値で固定圧縮を提供する場合、それはblocklen / outlen比として示されます。値は任意にすることができます。同じアルゴリズムの比率がCRYPTO_TYPE_COMPRESSタイプの比率と逆になるのは当然です。圧縮値が不明な場合、outlenは0に設定され、blocklenは使用されません。"
    },
    {
      "indent": 6,
      "text": "milen - is not used.",
      "ja": "milen-使用されません。"
    },
    {
      "indent": 3,
      "text": "For one-way hash function algorithms (CRYPTO_TYPE_HASH):",
      "ja": "一方向ハッシュ関数アルゴリズム（CRYPTO_TYPE_HASH）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - block size in bytes. The length of input data will be padded up to this value. When there is no need in padding value 1 should be used.",
      "ja": "blocklen-バイト単位のブロックサイズ。入力データの長さは、この値まで埋め込まれます。パディングの必要がない場合は、値1を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "keylen - is not used.",
      "ja": "keylen-使用されません。"
    },
    {
      "indent": 6,
      "text": "outlen - resulting hash value length in bytes.",
      "ja": "outlen-結果のハッシュ値の長さ（バイト単位）。"
    },
    {
      "indent": 6,
      "text": "milen - is not used.",
      "ja": "milen-使用されません。"
    },
    {
      "indent": 3,
      "text": "For random number generation algorithms (CRYPTO_TYPE_RANDOM):",
      "ja": "乱数生成アルゴリズム（CRYPTO_TYPE_RANDOM）の場合："
    },
    {
      "indent": 6,
      "text": "blocklen - is not used.",
      "ja": "blocklen-使用されません。"
    },
    {
      "indent": 6,
      "text": "keylen - initial seed length (0 - if not required, for example in a physical effects based generators).",
      "ja": "keylen-初期シード長（0-物理エフェクトベースのジェネレーターなどで必要でない場合は0）。"
    },
    {
      "indent": 6,
      "text": "outlen - resulting random number length in bytes (0 - arbitrary)",
      "ja": "outlen-結果のバイト単位の乱数の長さ（0-任意）"
    },
    {
      "indent": 6,
      "text": "milen - is not used.",
      "ja": "milen-使用されません。"
    },
    {
      "indent": 0,
      "text": "3.2. Cryptoplugin Deinitialization Function",
      "section_title": true,
      "ja": "3.2. Craptoplugin非初期化関数"
    },
    {
      "indent": 3,
      "text": "/* Plugin deinitialization */\nCRYPTO_STATUS   CryptoPluginFini(void);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function is called before the cryptoplugin operation is to be terminated. Function execution causes closing of all open cryptographic contexts, system resources deallocation and hardware deinitialization. The value returned is informational only.",
      "ja": "この関数は、cryptoplugin操作が終了する前に呼び出されます。関数の実行により、開いているすべての暗号化コンテキストが閉じられ、システムリソースの割り当てが解除され、ハードウェアの初期化が解除されます。返される値は情報のみです。"
    },
    {
      "indent": 3,
      "text": "Return codes for the function:",
      "ja": "関数の戻りコード："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - cryptoplugin is deinitialized successfully.",
      "ja": "CRYPTO_OK-cryptopluginは正常に非初期化されました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_UNCLOSED_HANDLES - warning that there were open cryptographic contexts during cryptoplugin deinitialization. The warning is informational only. The open contexts are destroyed anyway.",
      "ja": "CRYPTO_ERR_UNCLOSED_HANDLES-暗号化プラグインの初期化解除中に開いている暗号化コンテキストがあったという警告。警告は情報のみです。とにかく、開いているコンテキストは破棄されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Cryptographic Context Opening Function",
      "section_title": true,
      "ja": "3.3. 暗号コンテキストオープン関数"
    },
    {
      "indent": 3,
      "text": "New algorithm instance (cipher state) */ CRYPTO_STATUS CryptoOpen(",
      "ja": "新しいアルゴリズムインスタンス（暗号状態）* / CRYPTO_STATUS CryptoOpen（"
    },
    {
      "indent": 9,
      "text": "CRYPTO_HANDLE   *state, /* Pointer to cipher state\n                           handle (filled on exit) */\nlong            algnum, /* Algorithm number in\n                           CryptoPluginInfo structure */\nconst char      *key);  /* key (in plain) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function creates cryptographic context copy inside cryptoplugin and initializes it with the provided key. Later the handle of the context is used in calls of other algorithm functions.",
      "ja": "この関数は、cryptoplugin内に暗号化コンテキストのコピーを作成し、提供されたキーで初期化します。後でコンテキストのハンドルは、他のアルゴリズム関数の呼び出しで使用されます。"
    },
    {
      "indent": 3,
      "text": "Description of parameters:",
      "ja": "パラメータの説明："
    },
    {
      "indent": 6,
      "text": "state - pointer to the variable that will be set to the handle of the context created if succeeded. NULL parameter value should result in the CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "state-成功した場合に作成されたコンテキストのハンドルに設定される変数へのポインター。 NULLパラメータ値は、関数によって返されるCRYPTO_ERR_BAD_PARAMSコードになる必要があります。"
    },
    {
      "indent": 6,
      "text": "algnum - algorithm number in the cryptoplugin. It is equal to the number of CryptoAlgInfo structure (that describes the algorithm) in CryptoPluginInfo structure. The number begins with zero value. It should be taken into account that it is not an algorithm identifier but its number in the cryptoplugin.",
      "ja": "algnum-暗号プラグインのアルゴリズム番号。これは、CryptoPluginInfo構造内の（アルゴリズムを説明する）CryptoAlgInfo構造の数と同じです。数値はゼロ値で始まります。これはアルゴリズム識別子ではなく、cryptoplugin内の番号であることを考慮する必要があります。"
    },
    {
      "indent": 6,
      "text": "key - pointer to the key (if it is required) or to the seed (for random number generation algorithm).",
      "ja": "key-キー（必要な場合）またはシード（乱数生成アルゴリズムの場合）へのポインター。"
    },
    {
      "indent": 0,
      "text": "Notes.",
      "ja": "ノート。"
    },
    {
      "indent": 3,
      "text": "1. Generated cryptographic context is stored inside the cryptoplugin until it will be destroyed by the CryptoAlgClose function call. The maximum number of cryptographic contexts supported by cryptoplugin can be indicated in algorithm parameters description. If maximum number of cryptographic contexts equals to zero then the cryptographic contexts number is either unlimited (for example, for stateless algorithms like random number generators and one-way hash functions) or it is limited by external factors only (like memory size).",
      "ja": "1. 生成された暗号コンテキストは、CryptoAlgClose関数呼び出しによって破棄されるまで、cryptoplugin内に保存されます。 cryptopluginでサポートされる暗号化コンテキストの最大数は、アルゴリズムパラメーターの説明で指定できます。暗号化コンテキストの最大数がゼロに等しい場合、暗号化コンテキストの数は無制限（たとえば、乱数ジェネレーターや一方向ハッシュ関数などのステートレスアルゴリズムの場合）か、外部要素（メモリサイズなど）のみによって制限されます。"
    },
    {
      "indent": 6,
      "text": "Return codes for the function:",
      "ja": "関数の戻りコード："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters (invalid algorithm number, zero pointer to the handle or to key (seed) if it is required.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター（無効なアルゴリズム番号、ハンドルまたはキー（シード）へのゼロポインター）（必要な場合）。"
    },
    {
      "indent": 0,
      "text": "3.4. Cryptographic Context Reopening Function",
      "section_title": true,
      "ja": "3.4. 暗号化コンテキストの再開機能"
    },
    {
      "indent": 0,
      "text": "/* Reinitialize algorithm instance */\nCRYPTO_STATUS   CryptoReOpen(\n                CRYPTO_HANDLE   state, /* current cipher state handle */\n                const char      *key);  /* key (in plain) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function reinitializes an existing context. This function is used for key change without new system resources allocation. The function parameters are handle of opened earlier context and pointer to a new key.",
      "ja": "この関数は、既存のコンテキストを再初期化します。この機能は、新しいシステムリソースを割り当てずにキーを変更するために使用されます。関数パラメーターは、開いている以前のコンテキストのハンドルと新しいキーへのポインターです。"
    },
    {
      "indent": 3,
      "text": "Return codes for the function:",
      "ja": "関数の戻りコード："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般に反する"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module may release system memory and try function call once more.",
      "ja": "CRYPTO_ERR_NO_RESOURCESエラーこのコードは、呼び出し側モジュールがシステムメモリを解放し、関数呼び出しをもう一度試みることを前提としています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters (invalid algorithm number, zero pointer to the handle or to key (seed) if it is required.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター（無効なアルゴリズム番号、ハンドルまたはキー（シード）へのゼロポインター）（必要な場合）。"
    },
    {
      "indent": 0,
      "text": "3.5. Cryptographic Context Closing Function",
      "section_title": true,
      "ja": "3.5. 暗号コンテキスト終了関数"
    },
    {
      "indent": 0,
      "text": "/* Destroy algorithm instance */\nCRYPTO_STATUS   CryptoClose(\n                CRYPTO_HANDLE   state); /* Handle of cipher state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function provides cryptographic context destruction. The cryptographic context handle is its parameter. The value returned is informational only.",
      "ja": "この関数は、暗号化コンテキストの破棄を提供します。暗号化コンテキストハンドルはそのパラメーターです。返される値は情報のみです。"
    },
    {
      "indent": 3,
      "text": "Return codes for the function:",
      "ja": "関数の戻りコード："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 0,
      "text": "3.6. Key Verification Function",
      "section_title": true,
      "ja": "3.6. キー検証機能"
    },
    {
      "indent": 6,
      "text": "/* Check key for possible weakness */\nCRYPTO_STATUS   CryptoCheckForWeakKey(\n              long            algnum, /* Algorithm number in\n                              CryptoPluginInfo structure */\n              const char      *key);  /* Proposed key */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function verifies key material whether it is weak (from the algorithm's point of view). The function is actual for encryption/decryption or signing/verification algorithms only. Algorithm number (similar to CryptoAlgOpen) and pointer to the key to be verified are the parameters.",
      "ja": "この関数は、（アルゴリズムの観点から）鍵素材が弱いかどうかを検証します。この関数は、暗号化/復号化または署名/検証アルゴリズムのみで実際のものです。アルゴリズム番号（CryptoAlgOpenと同様）および検証する鍵へのポインターがパラメーターです。"
    },
    {
      "indent": 3,
      "text": "Return codes for the function:",
      "ja": "関数の戻りコード："
    },
    {
      "indent": 6,
      "text": "CRYPTO_O - the key has passed the test.",
      "ja": "CRYPTO_O-キーはテストに合格しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_WEAK_KEY - the key has not passed the test (being weak or possibly weak).",
      "ja": "CRYPTO_ERR_WEAK_KEY-キーはテストに合格していません（弱い、またはおそらく弱い）。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NOT_SUPPORTED - is not supported.",
      "ja": "CRYPTO_ERR_NOT_SUPPORTED-サポートされていません。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 0,
      "text": "3.7. Data Transformation Function",
      "section_title": true,
      "ja": "3.7. データ変換機能"
    },
    {
      "indent": 0,
      "text": "/* Perform CryptoTransform (depends on cipher state type) */\nCRYPTO_STATUS   CryptoTransform(\n                CRYPTO_HANDLE   state,  /* Cipher state */\n                const char      *inbuff,/* input data */\n                long            inlen,  /* input data length */\n                char            *outbuff,/* output buffer */\n                long            *outlen,/* On entry - output buffer\n                                          length, on exit -  number of\n                                          bytes written to outbuff */\n                char            *mi);   /* Message indicator  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This is a cryptographic data transformation function. Function call results and function parameters are dependent on algorithm type. For algorithm types CRYTO_TYPE_ENCRYPT, CRYPTO_TYPE_DECRYPT, CRYPTO_TYPE_SIGN and CRYPTO_TYPE_VERIFY (items 3.7.1 - 3.7.4) function call results are history independent.",
      "ja": "暗号データ​​変換機能です。関数呼び出しの結果と関数パラメーターは、アルゴリズムのタイプによって異なります。アルゴリズムタイプCRYTO_TYPE_ENCRYPT、CRYPTO_TYPE_DECRYPT、CRYPTO_TYPE_SIGN、およびCRYPTO_TYPE_VERIFY（アイテム3.7.1〜3.7.4）の関数呼び出しの結果は、履歴に依存しません。"
    },
    {
      "indent": 3,
      "text": "Note. Stream encryption algorithms may seem an \"exception\". However the same cryptoalgorithm handle must hide its history dependence. For algorithm types CRYPTO_TYPE_COMPRESS, CRYPTO_TYPE_UNCOMPRESS and CRYPTO_TYPE_HASH (items 3.7.5 - 3.7.7) function calls are history dependent. For the CRYPTO_TYPE_RANDOM algorithm function call may be for different implementations either dependent or independent on the history.",
      "ja": "注意。ストリーム暗号化アルゴリズムは「例外」のように見えるかもしれません。ただし、同じ暗号アルゴリズムハンドルは、その履歴依存性を隠す必要があります。アルゴリズムタイプCRYPTO_TYPE_COMPRESS、CRYPTO_TYPE_UNCOMPRESS、およびCRYPTO_TYPE_HASH（アイテム3.7.5-3.7.7）の関数呼び出しは、履歴に依存します。 CRYPTO_TYPE_RANDOMアルゴリズムの場合、関数呼び出しは、履歴に依存するか、または依存しない、異なる実装の場合があります。"
    },
    {
      "indent": 0,
      "text": "3.7.1. For CRYPTO_TYPE_ENCRYPT Algorithm Type:",
      "ja": "3.7.1. CRYPTO_TYPE_ENCRYPTアルゴリズムタイプの場合："
    },
    {
      "indent": 6,
      "text": "The function encrypts input data. Its parameters are intended for:",
      "ja": "この関数は、入力データを暗号化します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data. If this parameter is equal to NULL then the function should return the CRYPTO_ERR_BAD_PARAMS error code.",
      "ja": "inbuff-入力データへのポインター。このパラメーターがNULLの場合、関数はCRYPTO_ERR_BAD_PARAMSエラーコードを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). If the size indicated in algorithm description is divisible by blocklen then padding is not carried out. Otherwise the algorithm either caries out padding according to the algorithm standard or returns appropriate error code (CRYPTO_ERR_BAD_PARAMS). The zero parameter is allowed so that the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。アルゴリズムの説明に示されているサイズがblocklenで割り切れる場合、パディングは実行されません。そうでない場合、アルゴリズムはアルゴリズム標準に従ってパディングを実行するか、適切なエラーコード（CRYPTO_ERR_BAD_PARAMS）を返します。関数がすぐに終了してCRYPTO_OKコードを返すように、ゼロパラメータを使用できます。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data buffer. NULL parameter value results in the outlen parameter setting to output buffer size required to encrypt the input buffer represented. In this case the CRYPTO_ERR_SMALL_BUFFER error should not be returned.",
      "ja": "outbuff-出力データバッファー。 NULLパラメータ値は、表される入力バッファの暗号化に必要な出力バッファサイズへのoutlenパラメータ設定になります。この場合、CRYPTO_ERR_SMALL_BUFFERエラーは返されません。"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 6,
      "text": "mi - message indicator. Its content depends on whether the block or stream algorithm is applied. In the block algorithm case it is set to the last block encrypted. When the first block is encrypted mi parameter specifies initial initialization vector. In the stream algorithm case it is set to the offset of the first byte encrypted in the stream. If the algorithm uses the message indicator and the mi parameter value is set to NULL then function should return CRYPTO_ERR_BAD_PARAMS. If the algorithm (ECB Mode encrypting as an example) does not apply the message indicator then NULL value of mi is acceptable while non-NULL value should be ignored.",
      "ja": "mi-メッセージインジケータ。その内容は、ブロックアルゴリズムとストリームアルゴリズムのどちらが適用されているかによって異なります。ブロックアルゴリズムの場合は、暗号化された最後のブロックに設定されます。最初のブロックが暗号化されるとき、miパラメータは初期初期化ベクトルを指定します。ストリームアルゴリズムの場合は、ストリームで暗号化された最初のバイトのオフセットに設定されます。アルゴリズムがメッセージインジケーターを使用し、miパラメーター値がNULLに設定されている場合、関数はCRYPTO_ERR_BAD_PARAMSを返す必要があります。アルゴリズム（例としてECBモード暗号化）がメッセージインジケーターを適用しない場合、非NULL値は無視する必要がありますが、miのNULL値は許容されます。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.2. For CRYPTO_TYPE_DECRYPT Algorithm Type:",
      "ja": "3.7.2. CRYPTO_TYPE_DECRYPTアルゴリズムタイプの場合："
    },
    {
      "indent": 3,
      "text": "The function decrypts the input data. Its parameters are intended for:",
      "ja": "関数は、入力データを復号化します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data. If the parameter is equal to NULL then the function should return the CRYPTO_ERR_BAD_PARAMS error code.",
      "ja": "inbuff-入力データへのポインター。パラメータがNULLの場合、関数はCRYPTO_ERR_BAD_PARAMSエラーコードを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). When the parameter is set to zero the function quits at once and CRYPTO_OK code is returned.",
      "ja": "inlen-入力データサイズ（バイト単位）。パラメータがゼロに設定されると、関数はすぐに終了し、CRYPTO_OKコードが返されます。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data buffer. NULL parameter value results in the outlen parameter setting to output buffer size required to decrypt the input buffer represented. In this case the CRYPTO_ERR_SMALL_BUFFER error should not be returned.",
      "ja": "outbuff-出力データバッファー。パラメータ値がNULLの場合、outlenパラメータは、表示された入力バッファを復号化するために必要な出力バッファサイズに設定されます。この場合、CRYPTO_ERR_SMALL_BUFFERエラーは返されません。"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 6,
      "text": "mi - message indicator. The content depends on whether the block or stream algorithm is applied. In the block algorithm case it is set to the last block encrypted. When the first block is decrypted mi specifies initial initialization vector. In the stream algorithm case it is set to the offset of the first byte decrypted in the stream. If the algorithm uses the message indicator and the mi parameter is set to NULL then function should return CRYPTO_ERR_BAD_PARAMS. If the algorithm (ECB Mode as an example) does not apply the message indicator then NULL value of mi is acceptable while non-NULL value should be ignored.",
      "ja": "mi-メッセージインジケータ。内容は、ブロックアルゴリズムとストリームアルゴリズムのどちらが適用されているかによって異なります。ブロックアルゴリズムの場合は、暗号化された最後のブロックに設定されます。最初のブロックが復号化されると、miは初期初期化ベクトルを指定します。ストリームアルゴリズムの場合は、ストリームで復号化された最初のバイトのオフセットに設定されます。アルゴリズムがメッセージインジケーターを使用し、miパラメーターがNULLに設定されている場合、関数はCRYPTO_ERR_BAD_PARAMSを返す必要があります。アルゴリズム（例としてECBモード）がメッセージインジケーターを適用しない場合、非NULL値は無視する必要がありますが、miのNULL値は許容されます。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.3. For CRYPTO_TYPE_SIGN Type Algorithm:",
      "ja": "3.7.3. CRYPTO_TYPE_SIGNタイプアルゴリズムの場合："
    },
    {
      "indent": 0,
      "text": " The function signs the input data. Its parameters are intended for: inbuff - pointer to the input data. If the parameter is equal to NULL then the function should return the CRYPTO_ERR_BAD_PARAMS code error.",
      "ja": "関数は入力データに署名します。そのパラメーターは、以下を対象としています。inbuff-入力データへのポインター。パラメータがNULLの場合、関数はCRYPTO_ERR_BAD_PARAMSコードエラーを返します。"
    },
    {
      "indent": 3,
      "text": "inlen - input data size (in bytes). If the size indicated in algorithm description is divisible by blocklen then padding is not carried out. Otherwise the algorithm either caries out padding according to the algorithm standard or returns appropriate error code (CRYPTO_ERR_BAD_PARAMS). The zero parameter is allowed so that the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。アルゴリズムの説明に示されているサイズがblocklenで割り切れる場合、パディングは実行されません。そうでない場合、アルゴリズムはアルゴリズム標準に従ってパディングを実行するか、適切なエラーコード（CRYPTO_ERR_BAD_PARAMS）を返します。関数がすぐに終了してCRYPTO_OKコードを返すように、ゼロパラメータを使用できます。"
    },
    {
      "indent": 3,
      "text": "outbuff - output data buffer. NULL parameter value results in the outlen parameter setting to output buffer size required to sign the input buffer represented. In this case the CRYPTO_ERR_SMALL_BUFFER error should not be returned.",
      "ja": "outbuff-出力データバッファー。 NULLパラメータ値は、表される入力バッファに署名するために必要な出力バッファサイズへのoutlenパラメータ設定になります。この場合、CRYPTO_ERR_SMALL_BUFFERエラーは返されません。"
    },
    {
      "indent": 3,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 3,
      "text": "mi - pointer to signature parameter (random number usually) if milen parameter in algorithm description is non-zero. In this case zero mi parameter indicates that the parameter should be chosen (generated) inside the algorithm. If milen parameter in algorithm description is set to zero then mi parameter is ignored.",
      "ja": "mi-アルゴリズムの説明のmilenパラメータがゼロ以外の場合、署名パラメータへのポインタ（通常は乱数）。この場合、ゼロmiパラメーターは、パラメーターがアルゴリズム内で選択（生成）される必要があることを示します。アルゴリズムの説明のmilenパラメータがゼロに設定されている場合、miパラメータは無視されます。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.4. For CRYPTO_TYPE_VERIFY Algorithm Type:",
      "ja": "3.7.4. CRYPTO_TYPE_VERIFYアルゴリズムタイプの場合："
    },
    {
      "indent": 3,
      "text": "The function verifies input data signature. Its parameters are intended for:",
      "ja": "関数は入力データの署名を検証します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data. If the parameter is equal to NULL then the function should return the CRYPTO_ERR_BAD_PARAMS code error.",
      "ja": "inbuff-入力データへのポインター。パラメータがNULLの場合、関数はCRYPTO_ERR_BAD_PARAMSコードエラーを返します。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). The zero parameter is allowed so that the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。関数がすぐに終了してCRYPTO_OKコードを返すように、ゼロパラメータを使用できます。"
    },
    {
      "indent": 6,
      "text": "outbuff -pointer to the signature. If the parameter is set to NULL then the function returns CRYPTO_ERR_BAD_PARAMS error code. If the signature consists of several parts then they are combined to one array.",
      "ja": "outbuff-署名へのポインター。パラメータがNULLに設定されている場合、関数はCRYPTO_ERR_BAD_PARAMSエラーコードを返します。署名が複数の部分で構成されている場合、それらは1つの配列に結合されます。"
    },
    {
      "indent": 6,
      "text": "outlen - specifies the signature length if the signature length is set to zero in algorithm description structure. If non-zero value is specified in algorithm description structure then the parameter is ignored. If the signature consists of several parts then the maximum part length multiplied by the number of parts is specified.",
      "ja": "outlen-アルゴリズムの説明構造で署名の長さがゼロに設定されている場合、署名の長さを指定します。アルゴリズムの説明構造でゼロ以外の値が指定されている場合、パラメーターは無視されます。署名が複数のパーツで構成されている場合は、最大パーツ長にパーツ数を掛けた値が指定されます。"
    },
    {
      "indent": 6,
      "text": "mi - is not used.",
      "ja": "mi-使用されません。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_INVALID_SIGNATURE - invalid signature.",
      "ja": "CRYPTO_ERR_INVALID_SIGNATURE-無効な署名。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.5. For CRYPTO_TYPE_COMPRESS Algorithm Type:",
      "ja": "3.7.5. CRYPTO_TYPE_COMPRESSアルゴリズムタイプの場合："
    },
    {
      "indent": 3,
      "text": "The function compresses the input data. Its parameters are intended for:",
      "ja": "関数は入力データを圧縮します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data.",
      "ja": "inbuff-入力データへのポインター。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). The zero parameter is allowed so that the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。関数がすぐに終了してCRYPTO_OKコードを返すように、ゼロパラメータを使用できます。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data buffer. NULL parameter value results in the outlen parameter setting to output buffer size required to compress the input buffer represented. In this case the CRYPTO_ERR_SMALL_BUFFER error should not be returned.",
      "ja": "outbuff-出力データバッファー。 NULLパラメータ値は、表される入力バッファを圧縮するために必要な出力バッファサイズへのoutlenパラメータ設定になります。この場合、CRYPTO_ERR_SMALL_BUFFERエラーは返されません。"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 6,
      "text": "mi - is not used.",
      "ja": "mi-使用されません。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不足していますCRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.6. For CRYPTO_TYPE_UNCOMPRESS Algorithm Type:",
      "ja": "3.7.6. CRYPTO_TYPE_UNCOMPRESSアルゴリズムタイプの場合："
    },
    {
      "indent": 6,
      "text": "The function decompresses the input data. Its parameters are intended for:",
      "ja": "関数は、入力データを解凍します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data.",
      "ja": "inbuff-入力データへのポインター。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). The zero parameter is allowed so that the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。関数がすぐに終了してCRYPTO_OKコードを返すように、ゼロパラメータを使用できます。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data buffer. NULL parameter value results in the outlen parameter setting to output buffer size required to decompress the input buffer represented. In this case the CRYPTO_ERR_SMALL_BUFFER error should not be returned.",
      "ja": "outbuff-出力データバッファー。パラメータ値がNULLの場合、outlenパラメータ設定は、表示された入力バッファを解凍するために必要な出力バッファサイズになります。この場合、CRYPTO_ERR_SMALL_BUFFERエラーは返されません。"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 6,
      "text": "mi - is not used.",
      "ja": "mi-使用されません。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.7. For CRYPTO_TYPE_HASH Algorithm Type:",
      "ja": "3.7.7. CRYPTO_TYPE_HASHアルゴリズムタイプの場合："
    },
    {
      "indent": 3,
      "text": "The function calculates the hash value of the input data. Its parameters are intended for:",
      "ja": "この関数は、入力データのハッシュ値を計算します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 0,
      "text": " inbuff - pointer to the input data. If the parameter is of NULL value then the function calculates cumulative hash value for the data represented (taking into account all previous data represented). If total length of all the data represented by the moment is divisible by blocklen and outbuff is non-NULL then it is returned to outbuff. Nothing is written in outbuff when the length is not divisible by blocklen. NULL inbuff indicates the last conversion when the input data is padded up to the blocklen size and the result is written to outbuff address. The padding procedure is defined for the algorithm.",
      "ja": "inbuff-入力データへのポインター。パラメータがNULL値の場合、関数は、表されたデータの累積ハッシュ値を計算します（表された以前のすべてのデータを考慮に入れて）。モーメントによって表されるすべてのデータの全長がblocklenで割り切れ、outbuffがNULLでない場合、outbuffに返されます。長さがblocklenで割り切れない場合、outbuffには何も書き込まれません。 NULL inbuffは、入力データがblocklenサイズまでパディングされ、結果がoutbuffアドレスに書き込まれるときの最後の変換を示します。パディング手順は、アルゴリズムに対して定義されています。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes). The zero parameter is allowed when the function quits at once and returns CRYPTO_OK code.",
      "ja": "inlen-入力データサイズ（バイト単位）。関数がすぐに終了してCRYPTO_OKコードを返す場合、ゼロパラメータが許可されます。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data buffer.",
      "ja": "outbuff-出力データバッファー。"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. If intermediate conversion value (inbuff is not NULL) and total length of data represented by the moment are not divisible by blocklen then outlen is set to zero and the hash value is not written in outbuff. Both the NULL parameter value and the zero value addressed result in CRYPTO_ERR_BAD_PARAMS code returned by the function.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。中間変換値（inbuffがNULLではない）とモーメントによって表されるデータの全長がblocklenで割り切れない場合、outlenはゼロに設定され、ハッシュ値はoutbuffに書き込まれません。 NULLパラメータ値とアドレス指定されたゼロ値の両方により、関数からCRYPTO_ERR_BAD_PARAMSコードが返されます。"
    },
    {
      "indent": 6,
      "text": "mi - is not used.",
      "ja": "mi-使用されません。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.7.8. For CRYPTO_TYPE_RANDOM Algorithm Type:",
      "ja": "3.7.8. CRYPTO_TYPE_RANDOMアルゴリズムタイプの場合："
    },
    {
      "indent": 3,
      "text": "The function generates a random number. Its parameters are intended for:",
      "ja": "この関数は乱数を生成します。そのパラメーターは、以下を対象としています。"
    },
    {
      "indent": 6,
      "text": "inbuff - pointer to the input data used for generation (when one of the pseudorandom algorithms is implemented). NULL parameter indicates absence of the input data.",
      "ja": "inbuff-生成に使用される入力データへのポインター（擬似ランダムアルゴリズムの1つが実装されている場合）。 NULLパラメータは、入力データがないことを示します。"
    },
    {
      "indent": 6,
      "text": "inlen - input data size (in bytes).",
      "ja": "inlen-入力データサイズ（バイト単位）。"
    },
    {
      "indent": 6,
      "text": "outbuff - output data",
      "ja": "outbuff-出力データ"
    },
    {
      "indent": 6,
      "text": "outlen - Output buffer size is an input function parameter while the number of bytes written in the output buffer is the output parameter. If zero (i.e. arbitrary) generated number size is set in the algorithm description then the outlen value determines the number of random bytes required by the calling procedure.",
      "ja": "outlen-出力バッファーサイズは入力関数パラメーターですが、出力バッファーに書き込まれるバイト数は出力パラメーターです。アルゴリズムの説明でゼロ（つまり、任意）の生成された数値サイズが設定されている場合、outlen値によって、呼び出し側のプロシージャで必要なランダムバイトの数が決まります。"
    },
    {
      "indent": 6,
      "text": "mi - is not used.",
      "ja": "mi-使用されません。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般的なCRYPTO_ERR_NO_RESOURCESエラーとは異なり、このコードは、呼び出し元のモジュールがシステムメモリを解放して（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "3.8. Cryptographic Context Control Function",
      "section_title": true,
      "ja": "3.8. 暗号コンテキスト制御機能"
    },
    {
      "indent": 0,
      "text": "/* Algorithm control */\nCRYPTO_STATUS   CryptoControl(\n                CRYPTO_HANDLE   state,  /* Cipher state handle */\n                long            cmd,    /* Control command */\n                long            param,  /* Parameter id */\n                char            val,    /* Parameter value */\n                long            *len);  /* For CRYPTO_GET: on entry -\n                                           val buffer length, on exit -\n                                           number of bytes written to\n                                           val; for CRYPTO_SET: length\n                                           of value to set */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function provides cryptographic context internal parameters management. It may be used to check context parameters or to change the context state, for example it may return information about cryptoalgorithm (is given context uses hardware encryption facilities), or it may \"scroll\" stream algorithms context if necessary, etc.",
      "ja": "この関数は、暗号化コンテキストの内部パラメーター管理を提供します。これは、コンテキストパラメータのチェックやコンテキスト状態の変更に使用できます。たとえば、暗号アルゴリズムに関する情報を返す場合（コンテキストにハードウェア暗号化機能が使用されている場合）、または必要に応じてストリームアルゴリズムコンテキストを「スクロール」する場合などです。"
    },
    {
      "indent": 3,
      "text": "Description of parameters:",
      "ja": "パラメータの説明："
    },
    {
      "indent": 6,
      "text": "state - cryptographic context handle.",
      "ja": "状態-暗号化コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "cmd - command (CRYPTO_GET or CRYPTO_SET).",
      "ja": "cmd-コマンド（CRYPTO_GETまたはCRYPTO_SET）。"
    },
    {
      "indent": 3,
      "text": "param - identifier of parameter. Values in the range of 0..32767 are assigned well-known numbers for all algorithms. Values in the range of 32768..65535 mean various variables for various algorithms (may be arbitrarily used by cryptolibrary developer).",
      "ja": "param-パラメータの識別子。 0..32767の範囲の値には、すべてのアルゴリズムの既知の番号が割り当てられます。 32768..65535の範囲の値は、さまざまなアルゴリズムのさまざまな変数を意味します（暗号ライブラリの開発者が任意に使用できます）。"
    },
    {
      "indent": 3,
      "text": "val - pointer to the data buffer.",
      "ja": "val-データバッファへのポインタ。"
    },
    {
      "indent": 3,
      "text": "len - data size (in bytes).",
      "ja": "len-データサイズ（バイト単位）。"
    },
    {
      "indent": 3,
      "text": "Returned values:",
      "ja": "戻り値："
    },
    {
      "indent": 6,
      "text": "CRYPTO_OK - successful completion.",
      "ja": "CRYPTO_OK-正常に完了しました。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_GENERAL - internal error.",
      "ja": "CRYPTO_ERR_GENERAL-内部エラー。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.",
      "ja": "CRYPTO_ERR_BAD_HANDLE-無効な暗号コンテキストハンドル。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.",
      "ja": "CRYPTO_ERR_NO_RESOURCES-内部リソースが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general",
      "ja": "CRYPTO_ERR_NO_MEMORY-メモリが不足しています。一般に反する"
    },
    {
      "indent": 9,
      "text": "CRYPTO_ERR_NO_RESOURCES error this code assumes that the calling module can release system memory (if it is in position to) and try to call the function once again.",
      "ja": "CRYPTO_ERR_NO_RESOURCESエラーこのコードは、呼び出し元のモジュールがシステムメモリを解放し（適切な位置にある場合）、関数をもう一度呼び出せると想定しています。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.",
      "ja": "CRYPTO_ERR_SMALL_BUFFER-出力バッファサイズが不十分です。"
    },
    {
      "indent": 6,
      "text": "CRYPTO_ERR_BAD_PARAMS - invalid parameters.",
      "ja": "CRYPTO_ERR_BAD_PARAMS-無効なパラメーター。"
    },
    {
      "indent": 0,
      "text": "4. Cryptoplugin Registration Procedure",
      "section_title": true,
      "ja": "4. 暗号プラグイン登録手順"
    },
    {
      "indent": 3,
      "text": "Cryptoplugin should be linked together with the cryptoplugin wrapper library delivered by the cryptoplugin's client developer according to the rules specified by the module-client developer for each platform. It should result in a driver (module) of appropriate operating system that implements the cryptolibrary functions. The driver should be one of the drivers loaded during operating system boot. The procedure of cryptoplugin driver installation should be defined, documented, and automated when necessary, by the cryptoplugin developer. At the beginning of operation the driver-client determines cryptoplugin driver availability and establishes interconnection with it. Both module-client configuration and current security policy determine data conversion algorithms to be chosen.",
      "ja": "暗号プラグインは、各プラットフォームのモジュールクライアント開発者が指定したルールに従って、暗号プラグインのクライアント開発者が提供する暗号プラグインラッパーライブラリとリンクする必要があります。これにより、暗号ライブラリ機能を実装する適切なオペレーティングシステムのドライバー（モジュール）が生成されます。ドライバーは、オペレーティングシステムの起動時に読み込まれるドライバーの1つである必要があります。 cryptopluginドライバーのインストール手順は、cryptoplugin開発者が定義、文書化し、必要に応じて自動化する必要があります。動作の開始時に、ドライバークライアントは暗号プラグインドライバーの可用性を決定し、それとの相互接続を確立します。モジュールクライアント構成と現在のセキュリティポリシーの両方が、選択するデータ変換アルゴリズムを決定します。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are addressed throughout this memo.",
      "ja": "セキュリティに関する問題は、このメモ全体で取り上げられています。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Schneier] Bruce Schneier, Applied Cryptography - Protocols, Algorithms, and Source Code in C (Second Edition), John Wiley & Sons, Inc., 1996.",
      "ja": "[Schneier] Bruce Schneier、Applied Cryptography-Protocols、Algorithms、and Source Code in C（Second Edition）、John Wiley＆Sons、Inc.、1996。"
    },
    {
      "indent": 3,
      "text": "[IPsec] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[IPsec] Kent、S。およびR. Atkinson、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[ISAKMP] Maughhan, D., Schertler, M. Schneider, M. and J. Turner, \"Internet Security Association and Key Management Protocol (ISAKMP)\", RFC 2408, November 1998.",
      "ja": "[ISAKMP] Maughhan、D.、Schertler、M。Schneider、M。、およびJ. Turner、「インターネットセキュリティアソシエーションおよびキー管理プロトコル（ISAKMP）」、RFC 2408、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[IKE] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "ja": "[IKE] Harkins、D。およびD. Carrel、「The Internet Key Exchange（IKE）」、RFC 2409、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and C. Allen, \"The TLS protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS] Dierks、T。およびC. Allen、「The TLS protocol Version 1.0」、RFC 2246、1999年1月。"
    },
    {
      "indent": 0,
      "text": "7. Author's Address",
      "section_title": true,
      "ja": "7. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Valery Smyslov TWS Centralny prospekt, 11, Moscow, Russia",
      "ja": "Valery Smyslov TWS Central Prospect、11、モスクワ、ロシア"
    },
    {
      "indent": 3,
      "text": "Phone: +7 (095) 531 4633\nFax:   +7 (095) 531 2403\nEMail: svan@trustworks.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. The interface specification as a C header file",
      "section_title": true,
      "ja": "付録A. Cヘッダーファイルとしてのインターフェース仕様"
    },
    {
      "indent": 0,
      "text": "#ifndef __CRYPTPI_H\n#define __CRYPTPI_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define CRYPTO_VER(maj,min)     (((maj & 0xff) << 8) | (min & 0xff))\n#define CRYPTO_MAJ_VER(ver)     ((ver >> 8) & 0xff)\n#define CRYPTO_MIN_VER(ver)     (ver & 0xff)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define CRYPTO_PLUGIN_NAME_LEN  64      /* Must be multiple of 4 to */\n#define CRYPTO_ALG_NAME_LEN     32      /* avoid alignment problems */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifndef CRYPTO_HANDLE\n#define CRYPTO_HANDLE           void*   /* cipher state handle */\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "typedef enum tag_CRYPTO_STATUS {\n        CRYPTO_OK = 1,                  /* success */\n        CRYPTO_ERR_GENERAL,             /* undefined (internal) error */\n        CRYPTO_ERR_NOT_SUPPORTED,       /* unsupported */\n        CRYPTO_ERR_BAD_HANDLE,          /* invalid handle */\n        CRYPTO_ERR_SMALL_BUFFER,        /* insufficient output buffer\n                                           size */\n        CRYPTO_ERR_WEAK_KEY,            /* key is considered to be weak\n                                           (semiweak, pseudoweak) */\n        CRYPTO_ERR_NO_RESOURCES,        /* insufficient resources to\n                                           perform operation */\n        CRYPTO_ERR_NO_MEMORY,           /* insufficient memory to\n                                           perform operation */\n        CRYPTO_ERR_BAD_PARAMS,          /* invalid parameters */\n        CRYPTO_ERR_HARDWARE,            /* hardware error */\n        CRYPTO_ERR_INVALID_SIGNATURE,   /* invalid signature */\n        CRYPTO_ERR_UNCLOSED_HANDLES     /* unclosed handles exist while\n                                           plugin deinitializises */\n} CRYPTO_STATUS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* CryptoControl commands */\n#define CRYPTO_GET                      1       /* get parameter */\n#define CRYPTO_SET                      2       /* set parameter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm types */\n#define CRYPTO_TYPE_ENCRYPT             1\n#define CRYPTO_TYPE_DECRYPT             2\n#define CRYPTO_TYPE_SIGN                3\n#define CRYPTO_TYPE_VERIFY              4\n#define CRYPTO_TYPE_COMPRESS            5\n#define CRYPTO_TYPE_UNCOMPRESS          6\n#define CRYPTO_TYPE_HASH                7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define CRYPTO_TYPE_RANDOM 8",
      "ja": "#define CRYPTO_TYPE_RANDOM 8"
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_ENCRYPT & CRYPTO_TYPE_DECRYPT) */\n#define CRYPTO_AE_DUMMY                 1       /* no encryption */\n#define CRYPTO_AE_DES                   2       /* DES-CBC */\n#define CRYPTO_AE_3DES_EDE              3       /* Triple DES-EDE-CBC */\n#define CRYPTO_AE_IDEA                  4       /* IDEA-CBC */\n#define CRYPTO_AE_RC2                   5       /* RC2 */\n#define CRYPTO_AE_RC4                   6       /* RC4 */\n#define CRYPTO_AE_RC5                   7       /* RC5 */\n#define CRYPTO_AE_SAFER                 8       /* SAFER */\n#define CRYPTO_AE_CAST                  9       /* CAST */\n#define CRYPTO_AE_BLOWFISH              10      /* Blowfish */\n#define CRYPTO_AE_RSA                   11      /* RSA */\n#define CRYPTO_AE_GOST                  12      /* GOST */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_SIGN & CRYPTO_TYPE_VERIFY) */\n#define CRYPTO_AS_RSA                   2       /* RSA */\n#define CRYPTO_AS_DSA                   3       /* DSA */\n#define CRYPTO_AS_GOST                  4       /* GOST */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_COMPRESS & CRYPTO_TYPE_UNCOMPRESS) */\n#define CRYPTO_AC_DUMMY                 1       /* no compression */\n#define CRYPTO_AC_DEFLATE               2       /* Deflate */\n#define CRYPTO_AC_LZS                   3       /* LZS */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm IDs (for type CRYPTO_TYPE_HASH) */\n#define CRYPTO_AH_MD5                   1       /* MD5 */\n#define CRYPTO_AH_SHA                   2       /* SHA-1 */\n#define CRYPTO_AH_GOST                  3       /* GOST */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm IDs (for type CRYPTO_TYPE_RANDOM) */\n#define         CRYPTO_AR_UNKNOWN       1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined plugin flags */\n#define CRYPTO_PLUGIN_HARDWARE          1       /* plugin uses hdw */\n/* TBD more */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined algorithm flags */\n#define CRYPTO_ALG_HARDWARE             1       /* algorithm implemented\n                                                   in hardware */\n#define CRYPTO_ALG_MULTITHREADED        2       /* implementation allows\n                                                   multithreading */\n/* TBD more */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Currently defined parameters identifiers for CryptoControl */\n#define CRYPTO_PARAM_KEY                1       /* Only for CRYPTO_GET -\n                                                   get current key */\n/* TBD more */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "typedef struct  tag_CryptoAlgInfo {\n        long    status;                 /* Algorithm status */\n        long    type;                   /* algorithm type (One of\n                                           CRYPTO_TYPE_XXX) */\n        long    id;                     /* algorithm ID */\n        long    group;                  /* algorithm group */\n        long    version;                /* algorithm version\n                                           (CRYPTO_VER) */\n        long    flags;                  /* algorithm flags\n                                           (CRYPTO_ALG_XXX) */\n        long    maxcontexts;            /* max number of cipher states\n                                           supported (0 - any) */\n        char    name[CRYPTO_ALG_NAME_LEN];      /* algorithm name */\n                          /* CRYPT   SIGN    COMPRESS HASH    RANDOM  */\n                          /* DECRYPT VERIFY                           */\n        long    blocklen; /* blklen (blklen)  inlen   blklen    -     */\n        long    keylen;   /* keylen  keylen     -       -     seedlen */\n        long    outlen;   /* outlen (signlen) outlen  hashlen randlen */\n        long    milen;    /* milen   (param)    -       -       -     */\n} CryptoAlgInfo;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "typedef struct  tag_CryptoPluginInfo {\n        long    cpi_version;            /* Crypto PI version (currently\n                                           CRYPTO_VER(1,0)) */\n        long    status;                 /* Plugin status */\n        char    name[CRYPTO_PLUGIN_NAME_LEN];   /* plugin text\n                                                   description */\n        long    version;                /* plugin version\n                                           (CRYPTO_VER) */\n        long    flags;                  /* plugin flags\n                                           (CRYPTO_PLUGIN_XXX) */\n        long    number_of_algs;         /* number of AlgInfo structures\n                                           followed (min 1) */\n        CryptoAlgInfo   algs[1];        /* array of AlgInfo structures\n                                           (min 1) */\n} CryptoPluginInfo;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifdef __cplusplus\nextern \"C\" {\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* CryptoPlugin initialization. Returns pointer to CryptoPluginInfo\nstructure on success or NULL on fatal error. */\nCryptoPluginInfo *CryptoPluginInit(\n                void            *param);/* Ptr to OS parameters\n                                           (platform-specific) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Plugin deinitialization */\nCRYPTO_STATUS   CryptoPluginFini(void);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Get new algorithm instance (cipher state) */\nCRYPTO_STATUS   CryptoOpen(\n                CRYPTO_HANDLE   *state, /* Pointer to cipher state\n                                            handle (filled on exit) */\n                 long            algnum, /* Algorithm number in\n                                            CryptoPluginInfo structure */\n                 const char      *key);  /* key (in plain) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/* Reinitialize algorithm instance */\nCRYPTO_STATUS   CryptoReOpen(\n                CRYPTO_HANDLE   state, /* current cipher state handle */\n                const char      *key);  /* key (in plain) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/* Destroy algorithm instance */\nCRYPTO_STATUS   CryptoClose(\n                CRYPTO_HANDLE   state); /* Handle of cipher state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/* Check key for possible weakness */\nCRYPTO_STATUS   CryptoCheckForWeakKey(\n                long            algnum, /* Algorithm number in\n                                           CryptoPluginInfo structure */\n                const char      *key);  /* Proposed key */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/* Perform CryptoTransform (depends on cipher state type) */\nCRYPTO_STATUS   CryptoTransform(\n                CRYPTO_HANDLE   state,  /* Cipher state handle */\n                const char      *inbuff,/* input data */\n                long            inlen,  /* input data length */\n                char            *outbuff,/* output buffer */\n                long            *outlen,/* On entry - output buffer\n                                          length, on exit -  number of\n                                          bytes written to outbuff */\n                char            *mi);   /* Message indicator  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/* Algorithm control */\nCRYPTO_STATUS   CryptoControl(\n                CRYPTO_HANDLE   state,  /* Cipher state handle */\n                long            cmd,    /* Control command */\n                long            param,  /* Parameter id */\n                char            val,    /* Parameter value */\n                long            *len);  /* For CRYPTO_GET: on entry -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 44,
      "text": "val buffer length, on exit -\nnumber of bytes written to\nval; for CRYPTO_SET: length\nof value to set */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "#ifdef __cplusplus\n}\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "#endif  /* __CRYPTPI_H */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright (C) The Internet Society (1999). All Rights Reserved."
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する派生物を、全体または一部を問わず、準備、コピー、公開、配布することができます。ただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されない一切の保証を含みません。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能への資金提供は、現在Internet Societyから提供されています。"
    }
  ]
}