{
  "title": {
    "text": "RFC 2396 - Uniform Resource Identifiers (URI): Generic Syntax",
    "ja": "RFC 2396 - Uniform Resource Identifiers（URI）：ジェネリック構文"
  },
  "number": 2396,
  "created_at": "2020-08-15 08:31:56.398525+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                     T. Berners-Lee\nRequest for Comments: 2396                                       MIT/LCS\nUpdates: 1808, 1738                                          R. Fielding\nCategory: Standards Track                                    U.C. Irvine\n                                                             L. Masinter\n                                                       Xerox Corporation\n                                                             August 1998",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Uniform Resource Identifiers (URI): Generic Syntax",
      "ja": "Uniform Resource Identifiers（URI）：ジェネリック構文"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESG Note"
    },
    {
      "indent": 3,
      "text": "This paper describes a \"superset\" of operations that can be applied to URI. It consists of both a grammar and a description of basic functionality for URI. To understand what is a valid URI, both the grammar and the associated description have to be studied. Some of the functionality described is not applicable to all URI schemes, and some operations are only possible when certain media types are retrieved using the URI, regardless of the scheme used.",
      "ja": "このペーパーでは、URIに適用できる操作の「スーパーセット」について説明します。文法とURIの基本機能の説明の両方で構成されています。有効なURIを理解するには、文法と関連する説明の両方を調査する必要があります。説明されている機能の一部は、すべてのURIスキームに適用できるわけではありません。一部の操作は、使用されているスキームに関係なく、URIを使用して特定のメディアタイプを取得した場合にのみ可能です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "A Uniform Resource Identifier (URI) is a compact string of characters for identifying an abstract or physical resource. This document defines the generic syntax of URI, including both absolute and relative forms, and guidelines for their use; it revises and replaces the generic definitions in RFC 1738 and RFC 1808.",
      "ja": "Uniform Resource Identifier（URI）は、抽象リソースまたは物理リソースを識別するためのコンパクトな文字列です。このドキュメントでは、絶対形式と相対形式の両方を含むURIの一般的な構文と、それらの使用に関するガイドラインを定義しています。 RFC 1738およびRFC 1808の一般的な定義を改訂して置き換えます。"
    },
    {
      "indent": 3,
      "text": "This document defines a grammar that is a superset of all valid URI, such that an implementation can parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier type. This document does not define a generative grammar for URI; that task will be performed by the individual specifications of each URI scheme.",
      "ja": "このドキュメントでは、すべての有効なURIのスーパーセットである文法を定義しています。これにより、実装は、考えられるすべての識別子タイプのスキーマ固有の要件を知らなくても、URI参照の共通コンポーネントを解析できます。このドキュメントでは、URIの生成文法を定義していません。そのタスクは、各URIスキームの個別の仕様によって実行されます。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Uniform Resource Identifiers (URI) provide a simple and extensible means for identifying a resource. This specification of URI syntax and semantics is derived from concepts introduced by the World Wide Web global information initiative, whose use of such objects dates from 1990 and is described in \"Universal Resource Identifiers in WWW\" [RFC1630]. The specification of URI is designed to meet the recommendations laid out in \"Functional Recommendations for Internet Resource Locators\" [RFC1736] and \"Functional Requirements for Uniform Resource Names\" [RFC1737].",
      "ja": "Uniform Resource Identifiers（URI）は、リソースを識別するためのシンプルで拡張可能な手段を提供します。このURI構文とセマンティクスの仕様は、World Wide Webグローバル情報イニシアチブによって導入された概念から派生しています。そのようなオブジェクトの使用は1990年に始まり、「WWWのユニバーサルリソース識別子」[RFC1630]で説明されています。 URIの仕様は、「インターネットリソースロケータの機能上の推奨事項」[RFC1736]および「ユニフォームリソース名の機能上の要件」[RFC1737]に示されている推奨事項を満たすように設計されています。"
    },
    {
      "indent": 3,
      "text": "This document updates and merges \"Uniform Resource Locators\" [RFC1738] and \"Relative Uniform Resource Locators\" [RFC1808] in order to define a single, generic syntax for all URI. It excludes those portions of RFC 1738 that defined the specific syntax of individual URL schemes; those portions will be updated as separate documents, as will the process for registration of new URI schemes. This document does not discuss the issues and recommendation for dealing with characters outside of the US-ASCII character set [ASCII]; those recommendations are discussed in a separate document.",
      "ja": "このドキュメントでは、「Uniform Resource Locators」[RFC1738]と「Relative Uniform Resource Locators」[RFC1808]を更新およびマージして、すべてのURIに単一の汎用構文を定義しています。個々のURLスキームの特定の構文を定義したRFC 1738の部分は除外されています。これらの部分は、新しいURIスキームの登録プロセスと同様に、個別のドキュメントとして更新されます。このドキュメントでは、US-ASCII文字セット[ASCII]以外の文字を処理するための問題と推奨事項については説明しません。これらの推奨事項は、別のドキュメントで説明されています。"
    },
    {
      "indent": 3,
      "text": "All significant changes from the prior RFCs are noted in Appendix G.",
      "ja": "以前のRFCからのすべての重要な変更は、付録Gに記載されています。"
    },
    {
      "indent": 0,
      "text": "1.1 Overview of URI",
      "section_title": true,
      "ja": "1.1 URIの概要"
    },
    {
      "indent": 3,
      "text": "URI are characterized by the following definitions:",
      "ja": "URIは次の定義によって特徴付けられます。"
    },
    {
      "indent": 6,
      "text": "Uniform Uniformity provides several benefits: it allows different types of resource identifiers to be used in the same context, even when the mechanisms used to access those resources may differ; it allows uniform semantic interpretation of common syntactic conventions across different types of resource identifiers; it allows introduction of new types of resource identifiers without interfering with the way that existing identifiers are used; and, it allows the identifiers to be reused in many different contexts, thus permitting new applications or protocols to leverage a pre-existing, large, and widely-used set of resource identifiers.",
      "ja": "Uniform Uniformityにはいくつかの利点があります。これらのリソースへのアクセスに使用されるメカニズムが異なる場合でも、同じタイプのリソース識別子を同じコンテキストで使用できます。これにより、さまざまなタイプのリソース識別子全体で共通の構文規則の意味的な解釈を統一できます。既存の識別子の使用方法を妨げることなく、新しいタイプのリソース識別子を導入できます。また、識別子をさまざまなコンテキストで再利用できるため、新しいアプリケーションやプロトコルで、既存の大規模で広く使用されているリソース識別子のセットを活用できます。"
    },
    {
      "indent": 6,
      "text": "Resource A resource can be anything that has identity. Familiar examples include an electronic document, an image, a service (e.g., \"today's weather report for Los Angeles\"), and a collection of other resources. Not all resources are network \"retrievable\"; e.g., human beings, corporations, and bound books in a library can also be considered resources.",
      "ja": "リソースリソースは、アイデンティティを持つものなら何でもかまいません。身近な例としては、電子ドキュメント、画像、サービス（「ロサンゼルスの今日の天気予報」など）、その他のリソースのコレクションなどがあります。すべてのリソースがネットワークで「取得可能」であるとは限りません。たとえば、人間、企業、図書館の製本もリソースと見なすことができます。"
    },
    {
      "indent": 9,
      "text": "The resource is the conceptual mapping to an entity or set of\nentities, not necessarily the entity which corresponds to that\nmapping at any particular instance in time.  Thus, a resource\ncan remain constant even when its content---the entities to\nwhich it currently corresponds---changes over time, provided\nthat the conceptual mapping is not changed in the process.",
      "ja": "リソースは、エンティティまたはエンティティのセットへの概念的なマッピングであり、必ずしも特定のインスタンスのマッピングに対応するエンティティである必要はありません。 したがって、プロセスで概念マッピングが変更されていなければ、リソースのコンテンツ（現在対応しているエンティティ）が時間とともに変化しても、リソースは一定のままです。"
    },
    {
      "indent": 6,
      "text": "Identifier An identifier is an object that can act as a reference to something that has identity. In the case of URI, the object is a sequence of characters with a restricted syntax.",
      "ja": "識別子識別子は、アイデンティティを持つ何かへの参照として機能できるオブジェクトです。 URIの場合、オブジェクトは構文が制限された文字のシーケンスです。"
    },
    {
      "indent": 3,
      "text": "Having identified a resource, a system may perform a variety of operations on the resource, as might be characterized by such words as `access', `update', `replace', or `find attributes'.",
      "ja": "リソースを特定すると、「アクセス」、「更新」、「置換」、「属性の検索」などの単語で特徴付けられるように、システムはリソースに対してさまざまな操作を実行できます。"
    },
    {
      "indent": 0,
      "text": "1.2. URI, URL, and URN",
      "section_title": true,
      "ja": "1.2. URI、URL、およびURN"
    },
    {
      "indent": 3,
      "text": "A URI can be further classified as a locator, a name, or both. The term \"Uniform Resource Locator\" (URL) refers to the subset of URI that identify resources via a representation of their primary access mechanism (e.g., their network \"location\"), rather than identifying the resource by name or by some other attribute(s) of that resource. The term \"Uniform Resource Name\" (URN) refers to the subset of URI that are required to remain globally unique and persistent even when the resource ceases to exist or becomes unavailable.",
      "ja": "URIは、ロケーター、名前、またはその両方にさらに分類できます。 「Uniform Resource Locator」（URL）という用語は、名前やその他の属性()によってリソースを識別するのではなく、プライマリアクセスメカニズム（ネットワークの「場所」など）の表現を介してリソースを識別するURIのサブセットを指します（ s）そのリソース。 「Uniform Resource Name」（URN）という用語は、リソースが存在しなくなった場合や利用できなくなった場合でも、グローバルに一意で永続的である必要があるURIのサブセットを指します。"
    },
    {
      "indent": 3,
      "text": "The URI scheme (Section 3.1) defines the namespace of the URI, and thus may further restrict the syntax and semantics of identifiers using that scheme. This specification defines those elements of the URI syntax that are either required of all URI schemes or are common to many URI schemes. It thus defines the syntax and semantics that are needed to implement a scheme-independent parsing mechanism for URI references, such that the scheme-dependent handling of a URI can be postponed until the scheme-dependent semantics are needed. We use the term URL below when describing syntax or semantics that only apply to locators.",
      "ja": "URIスキーム（セクション3.1）はURIの名前空間を定義するため、そのスキームを使用する識別子の構文とセマンティクスをさらに制限する場合があります。この仕様は、すべてのURIスキームに必要であるか、または多くのURIスキームに共通するURI構文の要素を定義します。したがって、スキーマに依存したURIの解析メカニズムを実装するために必要な構文とセマンティクスを定義し、スキーマに依存したセマンティクスが必要になるまで、URIのスキーマに依存した処理を延期できるようにします。ロケーターにのみ適用される構文またはセマンティクスを説明する場合、以下のURLを使用します。"
    },
    {
      "indent": 3,
      "text": "Although many URL schemes are named after protocols, this does not imply that the only way to access the URL's resource is via the named protocol. Gateways, proxies, caches, and name resolution services might be used to access some resources, independent of the protocol of their origin, and the resolution of some URL may require the use of more than one protocol (e.g., both DNS and HTTP are typically used to access an \"http\" URL's resource when it can't be found in a local cache).",
      "ja": "多くのURLスキームはプロトコルにちなんで名付けられていますが、これは、URLのリソースにアクセスする唯一の方法が名前付きプロトコルを経由することを意味するわけではありません。ゲートウェイ、プロキシ、キャッシュ、および名前解決サービスを使用して、元のプロトコルに関係なく一部のリソースにアクセスできます。一部のURLの解決には、複数のプロトコルの使用が必要になる場合があります（たとえば、DNSとHTTPの両方が通常ローカルキャッシュに見つからない場合に「http」URLのリソースにアクセスするために使用されます）。"
    },
    {
      "indent": 3,
      "text": "A URN differs from a URL in that it's primary purpose is persistent labeling of a resource with an identifier. That identifier is drawn from one of a set of defined namespaces, each of which has its own set name structure and assignment procedures. The \"urn\" scheme has been reserved to establish the requirements for a standardized URN namespace, as defined in \"URN Syntax\" [RFC2141] and its related specifications.",
      "ja": "URNは、主な目的が識別子によるリソースの永続的なラベル付けであるという点でURLとは異なります。その識別子は、それぞれが独自のセット名の構造と割り当て手順を持つ、定義された名前空間のセットの1つから取得されます。 「urn」スキームは、「URN構文」[RFC2141]とその関連仕様で定義されている、標準化されたURN名前空間の要件を確立するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Most of the examples in this specification demonstrate URL, since they allow the most varied use of the syntax and often have a hierarchical namespace. A parser of the URI syntax is capable of parsing both URL and URN references as a generic URI; once the scheme is determined, the scheme-specific parsing can be performed on the generic URI components. In other words, the URI syntax is a superset of the syntax of all URI schemes.",
      "ja": "この仕様のほとんどの例は、構文の最も多様な使用を可能にし、階層的な名前空間を持つことが多いため、URLを示しています。 URI構文のパーサーは、URLとURNの両方の参照を汎用URIとして解析できます。スキームが決定したら、スキーム固有の解析を汎用URIコンポーネントで実行できます。つまり、URI構文はすべてのURIスキームの構文のスーパーセットです。"
    },
    {
      "indent": 0,
      "text": "1.3. Example URI",
      "section_title": true,
      "ja": "1.3. URIの例"
    },
    {
      "indent": 3,
      "text": "The following examples illustrate URI that are in common use.",
      "ja": "次の例は、一般的に使用されているURIを示しています。"
    },
    {
      "indent": 3,
      "text": "ftp://ftp.is.co.za/rfc/rfc1808.txt\n   -- ftp scheme for File Transfer Protocol services",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles\n   -- gopher scheme for Gopher and Gopher+ Protocol services",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "http://www.math.uio.no/faq/compression-faq/part1.html\n   -- http scheme for Hypertext Transfer Protocol services",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "mailto:mduerst@ifi.unizh.ch -- mailto scheme for electronic mail addresses",
      "ja": "mailto：mduerst@ifi.unizh.ch-電子メールアドレスのmailtoスキーム"
    },
    {
      "indent": 3,
      "text": "news:comp.infosystems.www.servers.unix -- news scheme for USENET news groups and articles",
      "ja": "news：comp.infosystems.www.servers.unix-USENETニュースグループおよび記事のニューススキーム"
    },
    {
      "indent": 3,
      "text": "telnet://melvyl.ucop.edu/\n   -- telnet scheme for interactive services via the TELNET Protocol",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1.4. Hierarchical URI and Relative Forms",
      "section_title": true,
      "ja": "1.4. 階層URIと相対フォーム"
    },
    {
      "indent": 3,
      "text": "An absolute identifier refers to a resource independent of the context in which the identifier is used. In contrast, a relative identifier refers to a resource by describing the difference within a hierarchical namespace between the current context and an absolute identifier of the resource.",
      "ja": "絶対識別子は、識別子が使用されるコンテキストに依存しないリソースを指します。対照的に、相対識別子は、現在のコンテキストとリソースの絶対識別子の間の階層的な名前空間内の違いを記述することによってリソースを参照します。"
    },
    {
      "indent": 3,
      "text": "Some URI schemes support a hierarchical naming system, where the hierarchy of the name is denoted by a \"/\" delimiter separating the components in the scheme. This document defines a scheme-independent `relative' form of URI reference that can be used in conjunction with a `base' URI (of a hierarchical scheme) to produce another URI. The syntax of hierarchical URI is described in Section 3; the relative URI calculation is described in Section 5.",
      "ja": "一部のURIスキーマは、名前の階層がスキーマ内のコンポーネントを区切る「/」区切り文字で示される階層ネーミングシステムをサポートしています。このドキュメントでは、スキーマに依存しない「相対」形式のURI参照を定義しています。これは、（階層スキーマの）「ベース」URIと組み合わせて使用​​して、別のURIを生成できます。階層URIの構文については、セクション3で説明します。相対URIの計算については、セクション5で説明します。"
    },
    {
      "indent": 0,
      "text": "1.5. URI Transcribability",
      "section_title": true,
      "ja": "1.5. URI転写性"
    },
    {
      "indent": 3,
      "text": "The URI syntax was designed with global transcribability as one of its main concerns. A URI is a sequence of characters from a very limited set, i.e. the letters of the basic Latin alphabet, digits, and a few special characters. A URI may be represented in a variety of ways: e.g., ink on paper, pixels on a screen, or a sequence of octets in a coded character set. The interpretation of a URI depends only on the characters used and not how those characters are represented in a network protocol.",
      "ja": "URI構文は、主要な懸念事項の1つとしてグローバルな文字変換が可能なように設計されています。 URIは、非常に限られたセットの文字のシーケンスです。つまり、基本的なラテンアルファベットの文字、数字、およびいくつかの特殊文字です。 URIはさまざまな方法で表すことができます。たとえば、紙のインク、画面のピクセル、またはコード化された文字セットのオクテットのシーケンスなどです。 URIの解釈は、使用される文字のみに依存し、ネットワークプロトコルでのそれらの文字の表現方法には依存しません。"
    },
    {
      "indent": 3,
      "text": "The goal of transcribability can be described by a simple scenario. Imagine two colleagues, Sam and Kim, sitting in a pub at an international conference and exchanging research ideas. Sam asks Kim for a location to get more information, so Kim writes the URI for the research site on a napkin. Upon returning home, Sam takes out the napkin and types the URI into a computer, which then retrieves the information to which Kim referred.",
      "ja": "文字起こしの目標は、単純なシナリオで説明できます。サムとキムの2人の同僚が、国際会議でパブに座って、研究のアイデアを交換しているところを想像してみてください。サムはキムに詳細情報を入手する場所を要求するため、キムは研究サイトのURIをナプキンに書き込みます。家に帰ると、サムはナプキンを取り出してURIをコンピューターに入力し、コンピューターはキムが参照した情報を取得します。"
    },
    {
      "indent": 3,
      "text": "There are several design concerns revealed by the scenario:",
      "ja": "シナリオによって明らかになった設計上の懸念がいくつかあります。"
    },
    {
      "indent": 6,
      "text": "o A URI is a sequence of characters, which is not always represented as a sequence of octets.",
      "ja": "o URIは文字のシーケンスであり、常にオクテットのシーケンスとして表されるわけではありません。"
    },
    {
      "indent": 6,
      "text": "o A URI may be transcribed from a non-network source, and thus should consist of characters that are most likely to be able to be typed into a computer, within the constraints imposed by keyboards (and related input devices) across languages and locales.",
      "ja": "o URIは非ネットワークソースから転記される可能性があるため、言語やロケールに関係なくキーボード（および関連する入力デバイス）によって課せられる制約の範囲内で、コンピューターに入力できる可能性が最も高い文字で構成する必要があります。"
    },
    {
      "indent": 6,
      "text": "o A URI often needs to be remembered by people, and it is easier for people to remember a URI when it consists of meaningful components.",
      "ja": "o URIは多くの場合、ユーザーが覚えておく必要があります。URIは、意味のあるコンポーネントで構成されていると、覚えやすくなります。"
    },
    {
      "indent": 3,
      "text": "These design concerns are not always in alignment. For example, it is often the case that the most meaningful name for a URI component would require characters that cannot be typed into some systems. The ability to transcribe the resource identifier from one medium to another was considered more important than having its URI consist of the most meaningful of components. In local and regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined in this document.",
      "ja": "これらの設計上の懸念は常に一致しているわけではありません。たとえば、URIコンポーネントの最も意味のある名前には、一部のシステムに入力できない文字が必要になる場合がよくあります。あるメディアから別のメディアにリソース識別子を転記する機能は、そのURIを最も意味のあるコンポーネントで構成するよりも重要であると考えられていました。地域および地域の状況において、テクノロジーの向上により、ユーザーはより幅広い範囲のキャラクターを使用できることから利益を得る可能性があります。このような使用法はこのドキュメントでは定義されていません。"
    },
    {
      "indent": 0,
      "text": "1.6. Syntax Notation and Common Elements",
      "section_title": true,
      "ja": "1.6. 構文表記と共通要素"
    },
    {
      "indent": 3,
      "text": "This document uses two conventions to describe and define the syntax for URI. The first, called the layout form, is a general description of the order of components and component separators, as in",
      "ja": "このドキュメントでは、URIの構文を説明および定義するために2つの規則を使用しています。 1つ目はレイアウトフォームと呼ばれ、次のようにコンポーネントとコンポーネントセパレータの順序の一般的な説明です。"
    },
    {
      "indent": 6,
      "text": "<first>/<second>;<third>?<fourth>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators. Whitespace should be ignored. These descriptions are used informally and do not define the syntax requirements.",
      "ja": "コンポーネント名は山括弧で囲まれ、山括弧の外の文字はリテラル区切り文字です。空白は無視する必要があります。これらの説明は非公式に使用され、構文要件を定義するものではありません。"
    },
    {
      "indent": 3,
      "text": "The second convention is a BNF-like grammar, used to define the formal URI syntax. The grammar is that of [RFC822], except that \"|\" is used to designate alternatives. Briefly, rules are separated from definitions by an equal \"=\", indentation is used to continue a rule definition over more than one line, literals are quoted with \"\", parentheses \"(\" and \")\" are used to group elements, optional elements are enclosed in \"[\" and \"]\" brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.",
      "ja": "2番目の規則はBNFのような文法であり、正式なURI構文を定義するために使用されます。文法は、[|]を除いて、[RFC822]の文法です。代替を指定するために使用されます。簡単に言うと、ルールは定義と等号「=」で区切られ、インデントはルール定義を複数行に続けるために使用され、リテラルは「」で引用され、括弧「（」と「）」は要素をグループ化するために使用されます要素は \"[\"と \"]\"の括弧で囲まれ、要素の前に<n> *を付けると、後続の要素のn回以上の繰り返しを指定できます。 nのデフォルトは0です。"
    },
    {
      "indent": 3,
      "text": "Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters. Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set. How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.",
      "ja": "BNFのような文法を使用してプロトコルで許可されるバイト（オクテット）を定義する多くの仕様とは異なり、URI文法は文字で定義されます。文法の各リテラルは、特定のコード化文字セットの文字のオク​​テットエンコーディングではなく、それが表す文字に対応しています。ワイヤー上のビットとバイトの観点からURIがどのように表されるかは、それを転送するために使用されるプロトコルの文字エンコーディング、またはそれを含むドキュメントの文字セットに依存します。"
    },
    {
      "indent": 3,
      "text": "The following definitions are common to many elements:",
      "ja": "次の定義は多くの要素に共通です。"
    },
    {
      "indent": 6,
      "text": "alpha = lowalpha | upalpha",
      "ja": "アルファ=低アルファ|アップアルファ"
    },
    {
      "indent": 6,
      "text": "lowalpha = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"",
      "ja": "lowalpha = \"a\" | 「b」| 「c」| 「d」| 「e」| \"f\" | \"g\" | 「h」| 「私」| 「j」| 「k」| \"l\" | 「m」| 「n」| 「o」| \"p\" | \"q\" | 「r」| 「s」| 「t」| 「u」| 「v」| 「w」| 「x」| 「y」| 「z」"
    },
    {
      "indent": 6,
      "text": "upalpha = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"",
      "ja": "upalpha = \"A\" | 「B」| 「C」| 「D」| 「E」| 「F」| 「G」| 「H」| 「私」| 「J」| 「K」| 「L」| 「M」| 「N」| 「O」| 「P」| 「Q」| 「R」| 「S」| 「T」| 「U」| 「V」| 「W」| 「X」| 「Y」| 「Z」"
    },
    {
      "indent": 6,
      "text": "digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"",
      "ja": "数字= \"0\" | 「1」| 「2」| 「3」| 「4」| 「5」| 「6」| 「7」| 「8」| 「9」"
    },
    {
      "indent": 6,
      "text": "alphanum = alpha | digit",
      "ja": "alphanum = alpha |桁"
    },
    {
      "indent": 3,
      "text": "The complete URI syntax is collected in Appendix A.",
      "ja": "完全なURI構文は付録Aにまとめられています。"
    },
    {
      "indent": 0,
      "text": "2. URI Characters and Escape Sequences",
      "section_title": true,
      "ja": "2. URI文字とエスケープシーケンス"
    },
    {
      "indent": 3,
      "text": "URI consist of a restricted set of characters, primarily chosen to aid transcribability and usability both in computer systems and in non-computer communications. Characters used conventionally as delimiters around URI were excluded. The restricted set of characters consists of digits, letters, and a few graphic symbols were chosen from those common to most of the character encodings and input facilities available to Internet users.",
      "ja": "URIは制限された文字セットで構成され、主にコンピューターシステムと非コンピューター通信の両方で文字起こしと使いやすさを支援するために選択されます。 URIを囲む区切り文字として従来使用されていた文字は除外されました。制限された文字のセットは、数字、文字、およびいくつかのグラフィックシンボルで構成され、インターネットユーザーが使用できるほとんどの文字エンコーディングと入力機能に共通のものから選択されました。"
    },
    {
      "indent": 6,
      "text": "uric = reserved | unreserved | escaped",
      "ja": "uric =予約済み|予約なし|脱出した"
    },
    {
      "indent": 3,
      "text": "Within a URI, characters are either used as delimiters, or to represent strings of data (octets) within the delimited portions. Octets are either represented directly by a character (using the US-ASCII character for that octet [ASCII]) or by an escape encoding. This representation is elaborated below.",
      "ja": "URI内では、文字は区切り文字として使用されるか、または区切られた部分内のデータ（オクテット）のストリングを表すために使用されます。オクテットは、文字（そのオクテットのUS-ASCII文字[ASCII]を使用）によって直接表されるか、またはエスケープエンコーディングによって表されます。この表現については、以下で詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "2.1 URI and non-ASCII characters",
      "section_title": true,
      "ja": "2.1 URIと非ASCII文字"
    },
    {
      "indent": 3,
      "text": "The relationship between URI and characters has been a source of confusion for characters that are not part of US-ASCII. To describe the relationship, it is useful to distinguish between a \"character\" (as a distinguishable semantic entity) and an \"octet\" (an 8-bit byte). There are two mappings, one from URI characters to octets, and a second from octets to original characters:",
      "ja": "URIと文字の関係は、US-ASCIIの一部ではない文字の混乱の原因となっています。関係を説明するには、「識別可能な意味エンティティとしての」「文字」と「オクテット」（8ビットバイト）を区別すると便利です。 2つのマッピングがあります。1つはURI文字からオクテット、もう1つはオクテットから元の文字です。"
    },
    {
      "indent": 3,
      "text": "URI character sequence->octet sequence->original character sequence",
      "ja": "URI文字シーケンス->オクテットシーケンス->元の文字シーケンス"
    },
    {
      "indent": 3,
      "text": "A URI is represented as a sequence of characters, not as a sequence of octets. That is because URI might be \"transported\" by means that are not through a computer network, e.g., printed on paper, read over the radio, etc.",
      "ja": "URIは、オクテットのシーケンスとしてではなく、文字のシーケンスとして表されます。これは、紙に印刷したり、ラジオで読んだりするなど、コンピュータネットワークを介さない方法でURIが「転送」される可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "A URI scheme may define a mapping from URI characters to octets; whether this is done depends on the scheme. Commonly, within a delimited component of a URI, a sequence of characters may be used to represent a sequence of octets. For example, the character \"a\" represents the octet 97 (decimal), while the character sequence \"%\", \"0\", \"a\" represents the octet 10 (decimal).",
      "ja": "URIスキームでは、URI文字からオクテットへのマッピングを定義できます。これが行われるかどうかは、スキームに依存します。通常、URIの区切られたコンポーネント内では、文字のシーケンスを使用してオクテットのシーケンスを表すことができます。たとえば、文字「a」はオクテット97（10進数）を表し、文字シーケンス「％」、「0」、「a」はオクテット10（10進数）を表します。"
    },
    {
      "indent": 3,
      "text": "There is a second translation for some resources: the sequence of octets defined by a component of the URI is subsequently used to represent a sequence of characters. A 'charset' defines this mapping. There are many charsets in use in Internet protocols. For example, UTF-8 [UTF-8] defines a mapping from sequences of octets to sequences of characters in the repertoire of ISO 10646.",
      "ja": "一部のリソースには2番目の変換があります。URIのコンポーネントによって定義されたオクテットのシーケンスは、その後、文字のシーケンスを表すために使用されます。 「charset」はこのマッピングを定義します。インターネットプロトコルで使用されている多くの文字セットがあります。たとえば、UTF-8 [UTF-8]は、ISO 10646のレパートリーで、オクテットのシーケンスから文字のシーケンスへのマッピングを定義します。"
    },
    {
      "indent": 3,
      "text": "In the simplest case, the original character sequence contains only characters that are defined in US-ASCII, and the two levels of mapping are simple and easily invertible: each 'original character' is represented as the octet for the US-ASCII code for it, which is, in turn, represented as either the US-ASCII character, or else the \"%\" escape sequence for that octet.",
      "ja": "最も単純なケースでは、元の文字シーケンスにはUS-ASCIIで定義された文字のみが含まれ、マッピングの2つのレベルは単純で簡単に反転可能です。各「元の文字」はUS-ASCIIコードのオクテットとして表されますは、US-ASCII文字、またはそのオクテットの「％」エスケープシーケンスとして表されます。"
    },
    {
      "indent": 3,
      "text": "For original character sequences that contain non-ASCII characters, however, the situation is more difficult. Internet protocols that transmit octet sequences intended to represent character sequences are expected to provide some way of identifying the charset used, if there might be more than one [RFC2277]. However, there is currently no provision within the generic URI syntax to accomplish this identification. An individual URI scheme may require a single charset, define a default charset, or provide a way to indicate the charset used.",
      "ja": "ただし、ASCII以外の文字を含む元の文字シーケンスの場合、状況はより困難になります。文字シーケンスを表すことを意図したオクテットシーケンスを送信するインターネットプロトコルは、複数の[RFC2277]がある場合、使用される文字セットを識別する何らかの方法を提供することが期待されています。ただし、現在、この識別を行うための汎用URI構文内の規定はありません。個々のURIスキームは、単一の文字セットを必要とする場合、デフォルトの文字セットを定義する場合、または使用される文字セットを示す方法を提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that a systematic treatment of character encoding within URI will be developed as a future modification of this specification.",
      "ja": "この仕様の将来の修正として、URI内の文字エンコーディングの体系的な処理が開発されることが期待されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Reserved Characters",
      "section_title": true,
      "ja": "2.2. 予約文字"
    },
    {
      "indent": 3,
      "text": "Many URI include components consisting of or delimited by, certain special characters. These characters are called \"reserved\", since their usage within the URI component is limited to their reserved purpose. If the data for a URI component would conflict with the reserved purpose, then the conflicting data must be escaped before forming the URI.",
      "ja": "多くのURIには、特定の特殊文字で構成される、または特定の特殊文字で区切られたコンポーネントが含まれます。これらの文字は、URIコンポーネント内での使用が予約された目的に限定されているため、「予約済み」と呼ばれます。 URIコンポーネントのデータが予約済みの目的と競合する場合は、URIを形成する前に競合するデータをエスケープする必要があります。"
    },
    {
      "indent": 6,
      "text": "reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\n              \"$\" | \",\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"reserved\" syntax class above refers to those characters that are allowed within a URI, but which may not be allowed within a particular component of the generic URI syntax; they are used as delimiters of the components described in Section 3.",
      "ja": "上記の「予約済み」構文クラスは、URI内では許可されているが、汎用URI構文の特定のコンポーネント内では許可されていない可能性がある文字を指します。これらは、セクション3で説明するコンポーネントの区切り文字として使用されます。"
    },
    {
      "indent": 3,
      "text": "Characters in the \"reserved\" set are not reserved in all contexts. The set of characters actually reserved within any given URI component is defined by that component. In general, a character is reserved if the semantics of the URI changes if the character is replaced with its escaped US-ASCII encoding.",
      "ja": "「予約済み」セットの文字は、すべてのコンテキストで予約されているわけではありません。特定のURIコンポーネント内で実際に予約されている文字のセットは、そのコンポーネントによって定義されます。一般に、文字がエスケープされたUS-ASCIIエンコーディングで置き換えられた場合にURIのセマンティクスが変更されると、文字は予約されます。"
    },
    {
      "indent": 0,
      "text": "2.3. Unreserved Characters",
      "section_title": true,
      "ja": "2.3. 予約されていない文字"
    },
    {
      "indent": 3,
      "text": "Data characters that are allowed in a URI but do not have a reserved purpose are called unreserved. These include upper and lower case letters, decimal digits, and a limited set of punctuation marks and symbols.",
      "ja": "URIで許可されているが、予約された目的がないデータ文字は、予約されていないと呼ばれます。これには、大文字と小文字、10進数、および句読点と記号の限定されたセットが含まれます。"
    },
    {
      "indent": 6,
      "text": "unreserved = alphanum | mark",
      "ja": "予約なし= alphanum |マーク"
    },
    {
      "indent": 6,
      "text": "mark        = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unreserved characters can be escaped without changing the semantics of the URI, but this should not be done unless the URI is being used in a context that does not allow the unescaped character to appear.",
      "ja": "予約されていない文字は、URIのセマンティクスを変更せずにエスケープできますが、エスケープされていない文字が表示されないコンテキストでURIが使用されている場合を除き、これを行わないでください。"
    },
    {
      "indent": 0,
      "text": "2.4. Escape Sequences",
      "section_title": true,
      "ja": "2.4. エスケープシーケンス"
    },
    {
      "indent": 3,
      "text": "Data must be escaped if it does not have a representation using an unreserved character; this includes data that does not correspond to a printable character of the US-ASCII coded character set, or that corresponds to any US-ASCII character that is disallowed, as explained below.",
      "ja": "予約されていない文字を使用した表現がない場合は、データをエスケープする必要があります。これには、以下で説明するように、US-ASCIIコード化文字セットの印刷可能文字に対応しない、または許可されていないUS-ASCII文字に対応するデータが含まれます。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Escaped Encoding",
      "section_title": true,
      "ja": "2.4.1. エスケープエンコーディング"
    },
    {
      "indent": 3,
      "text": "An escaped octet is encoded as a character triplet, consisting of the percent character \"%\" followed by the two hexadecimal digits representing the octet code. For example, \"%20\" is the escaped encoding for the US-ASCII space character.",
      "ja": "エスケープされたオクテットは、パーセント文字「％」とそれに続くオクテットコードを表す2つの16進数で構成される文字トリプレットとしてエンコードされます。たとえば、「％20」はUS-ASCIIスペース文字のエスケープされたエンコーディングです。"
    },
    {
      "indent": 6,
      "text": "escaped = \"%\" hex hex hex = digit | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"",
      "ja": "エスケープ= \"％\" hex hex hex = digit | 「A」| 「B」| 「C」| 「D」| 「E」| 「F」| 「a」| 「b」| 「c」| 「d」| 「e」| 「f」"
    },
    {
      "indent": 0,
      "text": "2.4.2. When to Escape and Unescape",
      "section_title": true,
      "ja": "2.4.2. エスケープとエスケープ解除のタイミング"
    },
    {
      "indent": 3,
      "text": "A URI is always in an \"escaped\" form, since escaping or unescaping a completed URI might change its semantics. Normally, the only time escape encodings can safely be made is when the URI is being created from its component parts; each component may have its own set of characters that are reserved, so only the mechanism responsible for generating or interpreting that component can determine whether or not escaping a character will change its semantics. Likewise, a URI must be separated into its components before the escaped characters within those components can be safely decoded.",
      "ja": "完成したURIをエスケープまたはエスケープ解除するとセマンティクスが変わる可能性があるため、URIは常に「エスケープ」形式になります。通常、安全にエスケープエンコーディングを作成できるのは、URIがそのコンポーネント部分から作成されているときだけです。各コンポーネントには、予約された独自の文字セットがある場合があります。そのため、そのコンポーネントの生成または解釈を担当するメカニズムのみが、文字をエスケープしてその意味を変更するかどうかを判断できます。同様に、これらのコンポーネント内のエスケープ文字を安全にデコードするには、URIをコンポーネントに分離する必要があります。"
    },
    {
      "indent": 3,
      "text": "In some cases, data that could be represented by an unreserved character may appear escaped; for example, some of the unreserved \"mark\" characters are automatically escaped by some systems. If the given URI scheme defines a canonicalization algorithm, then unreserved characters may be unescaped according to that algorithm. For example, \"%7e\" is sometimes used instead of \"~\" in an http URL path, but the two are equivalent for an http URL.",
      "ja": "場合によっては、予約されていない文字で表されるデータがエスケープされて表示されることがあります。たとえば、一部のシステムでは、予約されていない「マーク」文字の一部が自動的にエスケープされます。指定されたURIスキームが正規化アルゴリズムを定義している場合、予約されていない文字はそのアルゴリズムに従ってエスケープ解除される可能性があります。たとえば、http URLパスでは「〜」の代わりに「％7e」が使用されることがありますが、2つはhttp URLと同等です。"
    },
    {
      "indent": 3,
      "text": "Because the percent \"%\" character always has the reserved purpose of being the escape indicator, it must be escaped as \"%25\" in order to be used as data within a URI. Implementers should be careful not to escape or unescape the same string more than once, since unescaping an already unescaped string might lead to misinterpreting a percent data character as another escaped character, or vice versa in the case of escaping an already escaped string.",
      "ja": "パーセント「％」文字は常にエスケープインジケーターとしての目的を持っているため、URI内でデータとして使用するには、「％25」としてエスケープする必要があります。実装者は、同じ文字列を2回以上エスケープまたはアンエスケープしないように注意する必要があります。既にエスケープされていない文字列をエスケープ解除すると、パーセントデータ文字が別のエスケープ文字として誤って解釈される可能性があり、すでにエスケープされている文字列をエスケープする場合はその逆です。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Excluded US-ASCII Characters",
      "section_title": true,
      "ja": "2.4.3. 除外されたUS-ASCII文字"
    },
    {
      "indent": 3,
      "text": "Although they are disallowed within the URI syntax, we include here a description of those US-ASCII characters that have been excluded and the reasons for their exclusion.",
      "ja": "URI構文内では許可されていませんが、ここでは、除外されたUS-ASCII文字とその除外の理由について説明します。"
    },
    {
      "indent": 3,
      "text": "The control characters in the US-ASCII coded character set are not used within a URI, both because they are non-printable and because they are likely to be misinterpreted by some control mechanisms.",
      "ja": "US-ASCIIコード化文字セットの制御文字は、印刷できないため、および一部の制御メカニズムによって誤って解釈される可能性があるため、URI内では使用されません。"
    },
    {
      "indent": 3,
      "text": "control     = <US-ASCII coded characters 00-1F and 7F hexadecimal>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The space character is excluded because significant spaces may disappear and insignificant spaces may be introduced when URI are transcribed or typeset or subjected to the treatment of word-processing programs. Whitespace is also used to delimit URI in many contexts.",
      "ja": "スペース文字は除外されます。URIが転記またはタイプセットされたとき、またはワープロプログラムの処理を受けたときに、重要なスペースが消え、重要でないスペースが導入される可能性があるためです。空白は、多くのコンテキストでURIを区切るためにも使用されます。"
    },
    {
      "indent": 3,
      "text": "space       = <US-ASCII coded character 20 hexadecimal>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The angle-bracket \"<\" and \">\" and double-quote (\") characters are excluded because they are often used as the delimiters around URI in text documents and protocol fields. The character \"#\" is excluded because it is used to delimit a URI from a fragment identifier in URI references (Section 4). The percent character \"%\" is excluded because it is used for the encoding of escaped characters.",
      "ja": "山かっこ「<」と「>」および二重引用符（ \"）文字は、テキストドキュメントおよびプロトコルフィールドでURIを囲む区切り文字としてよく使用されるため、除外されます。文字「＃」は、 URI参照のURIをフラグメント識別子から区切る（セクション4）パーセント文字「％」はエスケープ文字のエンコードに使用されるため、除外されます。"
    },
    {
      "indent": 3,
      "text": "delims = \"<\" | \">\" | \"#\" | \"%\" | <\"> Other characters are excluded because gateways and other transport agents are known to sometimes modify such characters, or they are used as delimiters.",
      "ja": "delims = \"<\" | \">\" | 「＃」| 「％」| <\">ゲートウェイやその他のトランスポートエージェントは、そのような文字を変更することがあるか、区切り文字として使用されるため、その他の文字は除外されます。"
    },
    {
      "indent": 3,
      "text": "unwise      = \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Data corresponding to excluded characters must be escaped in order to be properly represented within a URI.",
      "ja": "除外された文字に対応するデータは、URI内で適切に表現されるようにエスケープする必要があります。"
    },
    {
      "indent": 0,
      "text": "3. URI Syntactic Components",
      "section_title": true,
      "ja": "3. URI構文コンポーネント"
    },
    {
      "indent": 3,
      "text": "The URI syntax is dependent upon the scheme. In general, absolute URI are written as follows:",
      "ja": "URI構文はスキームに依存します。一般に、絶対URIは次のように記述されます。"
    },
    {
      "indent": 6,
      "text": "<scheme>:<scheme-specific-part>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An absolute URI contains the name of the scheme being used (<scheme>) followed by a colon (\":\") and then a string (the <scheme-specific-part>) whose interpretation depends on the scheme.",
      "ja": "絶対URIには、使用されているスキームの名前（<scheme>）に続いてコロン（ \"：\"）が続き、その解釈はスキームに依存する文字列（<scheme-specific-part>）が含まれます。"
    },
    {
      "indent": 3,
      "text": "The URI syntax does not require that the scheme-specific-part have any general structure or set of semantics which is common among all URI. However, a subset of URI do share a common syntax for representing hierarchical relationships within the namespace. This \"generic URI\" syntax consists of a sequence of four main components:",
      "ja": "URI構文では、scheme-specific-partがすべてのURIに共通する一般的な構造またはセマンティクスのセットを持つ必要はありません。ただし、URIのサブセットは、名前空間内の階層関係を表すための共通の構文を共有します。この「汎用URI」構文は、4つの主要コンポーネントのシーケンスで構成されています。"
    },
    {
      "indent": 6,
      "text": "<scheme>://<authority><path>?<query>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "each of which, except <scheme>, may be absent from a particular URI. For example, some URI schemes do not allow an <authority> component, and others do not use a <query> component.",
      "ja": "<scheme>を除いて、それぞれが特定のURIに存在しない場合があります。たとえば、一部のURIスキームは<authority>コンポーネントを許可せず、他のスキームは<query>コンポーネントを使用しません。"
    },
    {
      "indent": 6,
      "text": "absoluteURI = scheme \":\" ( hier_part | opaque_part )",
      "ja": "absoluteURI =スキーム \"：\"（hier_part | opaque_part）"
    },
    {
      "indent": 3,
      "text": "URI that are hierarchical in nature use the slash \"/\" character for separating hierarchical components. For some file systems, a \"/\" character (used to denote the hierarchical structure of a URI) is the delimiter used to construct a file name hierarchy, and thus the URI path will look similar to a file pathname. This does NOT imply that the resource is a file or that the URI maps to an actual filesystem pathname.",
      "ja": "本来階層的なURIは、スラッシュ \"/\"文字を使用して、階層コンポーネントを分離します。一部のファイルシステムでは、「/」文字（URIの階層構造を示すために使用）がファイル名階層の構築に使用される区切り文字であるため、URIパスはファイルパス名に似ています。これは、リソースがファイルであること、またはURIが実際のファイルシステムのパス名にマップされていることを意味するものではありません。"
    },
    {
      "indent": 6,
      "text": "hier_part     = ( net_path | abs_path ) [ \"?\" query ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "net_path      = \"//\" authority [ abs_path ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "abs_path = \"/\" path_segments",
      "ja": "abs_path = \"/\" path_segments"
    },
    {
      "indent": 3,
      "text": "URI that do not make use of the slash \"/\" character for separating hierarchical components are considered opaque by the generic URI parser.",
      "ja": "階層コンポーネントを区切るためにスラッシュ「/」文字を使用しないURIは、汎用URIパーサーによって不透明と見なされます。"
    },
    {
      "indent": 6,
      "text": "opaque_part = uric_no_slash *uric",
      "ja": "opaque_part = uric_no_slash * uric"
    },
    {
      "indent": 6,
      "text": "uric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\n                \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We use the term <path> to refer to both the <abs_path> and <opaque_part> constructs, since they are mutually exclusive for any given URI and can be parsed as a single component.",
      "ja": "<abs_path>と<opaque_part>の両方の構造を指すために<path>という用語を使用します。これらは、特定のURIに対して相互に排他的であり、単一のコンポーネントとして解析できるためです。"
    },
    {
      "indent": 0,
      "text": "3.1. Scheme Component",
      "section_title": true,
      "ja": "3.1. スキームコンポーネント"
    },
    {
      "indent": 3,
      "text": "Just as there are many different methods of access to resources, there are a variety of schemes for identifying such resources. The URI syntax consists of a sequence of components separated by reserved characters, with the first component defining the semantics for the remainder of the URI string.",
      "ja": "リソースへのアクセスにはさまざまな方法があるように、そのようなリソースを識別するためのさまざまなスキームがあります。 URI構文は、予約文字で区切られた一連のコンポーネントで構成され、最初のコンポーネントが残りのURI文字列のセマンティクスを定義します。"
    },
    {
      "indent": 3,
      "text": "Scheme names consist of a sequence of characters beginning with a lower case letter and followed by any combination of lower case letters, digits, plus (\"+\"), period (\".\"), or hyphen (\"-\"). For resiliency, programs interpreting URI should treat upper case letters as equivalent to lower case in scheme names (e.g., allow \"HTTP\" as well as \"http\").",
      "ja": "スキーム名は、小文字で始まり、小文字、数字、プラス（ \"+\"）、ピリオド（ \"。\"）、またはハイフン（ \"-\"）の任意の組み合わせが続く一連の文字で構成されます。回復力のために、URIを解釈するプログラムは、大文字をスキーム名の小文字と同等に扱う必要があります（たとえば、「HTTP」と「http」を許可します）。"
    },
    {
      "indent": 6,
      "text": "scheme        = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Relative URI references are distinguished from absolute URI in that they do not begin with a scheme name. Instead, the scheme is inherited from the base URI, as described in Section 5.2.",
      "ja": "相対URI参照は、スキーム名で始まらないという点で絶対URIと区別されます。代わりに、セクション5.2で説明されているように、スキームはベースURIから継承されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Authority Component",
      "section_title": true,
      "ja": "3.2. 権限コンポーネント"
    },
    {
      "indent": 3,
      "text": "Many URI schemes include a top hierarchical element for a naming authority, such that the namespace defined by the remainder of the URI is governed by that authority. This authority component is typically defined by an Internet-based server or a scheme-specific registry of naming authorities.",
      "ja": "多くのURIスキームには命名機関の最上位階層要素が含まれており、残りのURIで定義された名前空間はその機関によって管理されます。この権限コンポーネントは通常、インターネットベースのサーバーまたは命名機関のスキーム固有のレジストリによって定義されます。"
    },
    {
      "indent": 6,
      "text": "authority = server | reg_name",
      "ja": "権限=サーバー| reg_name"
    },
    {
      "indent": 3,
      "text": "The authority component is preceded by a double slash \"//\" and is terminated by the next slash \"/\", question-mark \"?\", or by the end of the URI. Within the authority component, the characters \";\", \":\", \"@\", \"?\", and \"/\" are reserved.",
      "ja": "権限コンポーネントの前には二重スラッシュ「//」があり、次のスラッシュ「/」、疑問符「？」、またはURIの終わりで終了します。権限コンポーネント内では、文字「;」、「：」、「@」、「？」、および「/」は予約されています。"
    },
    {
      "indent": 3,
      "text": "An authority component is not required for a URI scheme to make use of relative references. A base URI without an authority component implies that any relative reference will also be without an authority component.",
      "ja": "URIスキームが相対参照を利用するために、権限コンポーネントは必要ありません。権限コンポーネントのないベースURIは、相対参照にも権限コンポーネントがないことを意味します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Registry-based Naming Authority",
      "section_title": true,
      "ja": "3.2.1. レジストリベースの命名機関"
    },
    {
      "indent": 3,
      "text": "The structure of a registry-based naming authority is specific to the URI scheme, but constrained to the allowed characters for an authority component.",
      "ja": "レジストリベースのネーミングオーソリティの構造はURIスキームに固有ですが、オーソリティコンポーネントに許可されている文字に制限されています。"
    },
    {
      "indent": 6,
      "text": "reg_name      = 1*( unreserved | escaped | \"$\" | \",\" |\n                    \";\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.2. Server-based Naming Authority",
      "section_title": true,
      "ja": "3.2.2. サーバーベースの命名機関"
    },
    {
      "indent": 3,
      "text": "URL schemes that involve the direct use of an IP-based protocol to a specified server on the Internet use a common syntax for the server component of the URI's scheme-specific data:",
      "ja": "インターネット上の指定されたサーバーに対してIPベースのプロトコルを直接使用するURLスキームでは、URIのスキーム固有のデータのサーバーコンポーネントに共通の構文を使用します。"
    },
    {
      "indent": 6,
      "text": "<userinfo>@<host>:<port>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where <userinfo> may consist of a user name and, optionally, scheme-specific information about how to gain authorization to access the server. The parts \"<userinfo>@\" and \":<port>\" may be omitted.",
      "ja": "ここで、<userinfo>は、ユーザー名と、オプションで、サーバーへのアクセス許可を取得する方法に関するスキーマ固有の情報で構成されます。 「<userinfo> @」と「：<port>」の部分は省略できます。"
    },
    {
      "indent": 6,
      "text": "server        = [ [ userinfo \"@\" ] hostport ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The user information, if present, is followed by a commercial at-sign \"@\".",
      "ja": "ユーザー情報がある場合は、その後にコマーシャルアットマーク「@」が続きます。"
    },
    {
      "indent": 6,
      "text": "userinfo      = *( unreserved | escaped |\n                   \";\" | \":\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Some URL schemes use the format \"user:password\" in the userinfo field. This practice is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.",
      "ja": "一部のURLスキームでは、userinfoフィールドで「user：password」の形式を使用しています。クリアテキスト（URIなど）での認証情報の受け渡しは、それが使用されているほとんどすべてのケースでセキュリティリスクであることが証明されているため、この方法は推奨されません。"
    },
    {
      "indent": 3,
      "text": "The host is a domain name of a network host, or its IPv4 address as a set of four decimal digit groups separated by \".\". Literal IPv6 addresses are not supported.",
      "ja": "ホストは、ネットワークホストのドメイン名、または \"。\"で区切られた4つの10進数グループのセットとしてのIPv4アドレスです。リテラルIPv6アドレスはサポートされていません。"
    },
    {
      "indent": 6,
      "text": "hostport      = host [ \":\" port ]\nhost          = hostname | IPv4address\nhostname      = *( domainlabel \".\" ) toplabel [ \".\" ]\ndomainlabel   = alphanum | alphanum *( alphanum | \"-\" ) alphanum\ntoplabel      = alpha | alpha *( alphanum | \"-\" ) alphanum IPv4address   = 1*digit \".\" 1*digit \".\" 1*digit \".\" 1*digit\nport          = *digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hostnames take the form described in Section 3 of [RFC1034] and Section 2.1 of [RFC1123]: a sequence of domain labels separated by \".\", each domain label starting and ending with an alphanumeric character and possibly also containing \"-\" characters. The rightmost domain label of a fully qualified domain name will never start with a digit, thus syntactically distinguishing domain names from IPv4 addresses, and may be followed by a single \".\" if it is necessary to distinguish between the complete domain name and any local domain. To actually be \"Uniform\" as a resource locator, a URL hostname should be a fully qualified domain name. In practice, however, the host component may be a local domain literal.",
      "ja": "ホスト名は、[RFC1034]のセクション3と[RFC1123]のセクション2.1で説明されている形式を取ります。「。」で区切られた一連のドメインラベル。各ドメインラベルは英数字で始まり、末尾に「-」文字が含まれる場合があります。完全修飾ドメイン名の右端のドメインラベルは数字で始まることはないため、構文的にドメイン名とIPv4アドレスを区別し、その後に単一の「。」を付けることができます。完全なドメイン名とローカルドメインを区別する必要がある場合。リソースロケータとして実際に「均一」であるためには、URLホスト名は完全修飾ドメイン名である必要があります。ただし、実際には、ホストコンポーネントはローカルドメインリテラルである場合があります。"
    },
    {
      "indent": 6,
      "text": "Note: A suitable representation for including a literal IPv6 address as the host part of a URL is desired, but has not yet been determined or implemented in practice.",
      "ja": "注：URLのホスト部分としてリテラルIPv6アドレスを含めるための適切な表現が望まれますが、実際にはまだ決定または実装されていません。"
    },
    {
      "indent": 3,
      "text": "The port is the network port number for the server. Most schemes designate protocols that have a default port number. Another port number may optionally be supplied, in decimal, separated from the host by a colon. If the port is omitted, the default port number is assumed.",
      "ja": "ポートは、サーバーのネットワークポート番号です。ほとんどのスキームは、デフォルトのポート番号を持つプロトコルを指定します。別のポート番号をオプションで10進数で指定し、ホストとコロンで区切ることができます。ポートを省略すると、デフォルトのポート番号が使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Path Component",
      "section_title": true,
      "ja": "3.3. パスコンポーネント"
    },
    {
      "indent": 3,
      "text": "The path component contains data, specific to the authority (or the scheme if there is no authority component), identifying the resource within the scope of that scheme and authority.",
      "ja": "パスコンポーネントには、権限（または権限コンポーネントがない場合はスキーム）に固有のデータが含まれ、そのスキームと権限の範囲内でリソースを識別します。"
    },
    {
      "indent": 6,
      "text": "path          = [ abs_path | opaque_part ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "path_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "pchar         = unreserved | escaped |\n                \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The path may consist of a sequence of path segments separated by a single slash \"/\" character. Within a path segment, the characters \"/\", \";\", \"=\", and \"?\" are reserved. Each path segment may include a sequence of parameters, indicated by the semicolon \";\" character. The parameters are not significant to the parsing of relative references.",
      "ja": "パスは、単一のスラッシュ「/」文字で区切られた一連のパスセグメントで構成されます。パスセグメント内の文字「/」、「;」、「=」、「？」予約されています。各パスセグメントには、セミコロン「;」で示される一連のパラメータを含めることができます。キャラクター。パラメータは、相対参照の解析には重要ではありません。"
    },
    {
      "indent": 0,
      "text": "3.4. Query Component",
      "section_title": true,
      "ja": "3.4. クエリコンポーネント"
    },
    {
      "indent": 3,
      "text": "The query component is a string of information to be interpreted by the resource.",
      "ja": "クエリコンポーネントは、リソースによって解釈される情報の文字列です。"
    },
    {
      "indent": 6,
      "text": "query         = *uric",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Within a query component, the characters \";\", \"/\", \"?\", \":\", \"@\", \"&\", \"=\", \"+\", \",\", and \"$\" are reserved.",
      "ja": "クエリコンポーネント内では、文字「;」、「/」、「？」、「：」、「@」、「＆」、「=」、「+」、「、」、および「$」は予約されています。"
    },
    {
      "indent": 0,
      "text": "4. URI References",
      "section_title": true,
      "ja": "4. URI参照"
    },
    {
      "indent": 3,
      "text": "The term \"URI-reference\" is used here to denote the common usage of a resource identifier. A URI reference may be absolute or relative, and may have additional information attached in the form of a fragment identifier. However, \"the URI\" that results from such a reference includes only the absolute URI after the fragment identifier (if any) is removed and after any relative URI is resolved to its absolute form. Although it is possible to limit the discussion of URI syntax and semantics to that of the absolute result, most usage of URI is within general URI references, and it is impossible to obtain the URI from such a reference without also parsing the fragment and resolving the relative form.",
      "ja": "「URI参照」という用語は、リソース識別子の一般的な使用法を示すためにここで使用されています。 URI参照は絶対または相対であり、フラグメント識別子の形式で追加情報が添付されている場合があります。ただし、そのような参照から生じる「URI」には、フラグメント識別子（存在する場合）が削除され、相対URIが絶対形式に解決された後の絶対URIのみが含まれます。 URI構文とセマンティクスの議論を絶対結果の議論に制限することは可能ですが、URIのほとんどの使用は一般的なURI参照内にあり、フラグメントを解析して解決しない限り、そのような参照からURIを取得することは不可能です。相対的な形。"
    },
    {
      "indent": 6,
      "text": "URI-reference = [ absoluteURI | relativeURI ] [ \"#\" fragment ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The syntax for relative URI is a shortened form of that for absolute URI, where some prefix of the URI is missing and certain path components (\".\" and \"..\") have a special meaning when, and only when, interpreting a relative path. The relative URI syntax is defined in Section 5.",
      "ja": "相対URIの構文は、絶対URIの構文の短縮形であり、URIの一部のプレフィックスが欠落しており、特定のパスコンポーネント（ \"。\"および \"..\"）は、相対を解釈する場合にのみ特別な意味を持っています道。相対URI構文はセクション5で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Fragment Identifier",
      "section_title": true,
      "ja": "4.1. フラグメント識別"
    },
    {
      "indent": 3,
      "text": "When a URI reference is used to perform a retrieval action on the identified resource, the optional fragment identifier, separated from the URI by a crosshatch (\"#\") character, consists of additional reference information to be interpreted by the user agent after the retrieval action has been successfully completed. As such, it is not part of a URI, but is often used in conjunction with a URI.",
      "ja": "URI参照を使用して識別されたリソースで取得アクションを実行する場合、オプションのフラグメント識別子は、クロスハッチ（「＃」）文字によってURIから分離され、取得後にユーザーエージェントによって解釈される追加の参照情報で構成されますアクションは正常に完了しました。そのため、URIの一部ではありませんが、URIと組み合わせて使用​​されることがよくあります。"
    },
    {
      "indent": 6,
      "text": "fragment      = *uric",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The semantics of a fragment identifier is a property of the data resulting from a retrieval action, regardless of the type of URI used in the reference. Therefore, the format and interpretation of fragment identifiers is dependent on the media type [RFC2046] of the retrieval result. The character restrictions described in Section 2",
      "ja": "フラグメント識別子のセマンティクスは、参照で使用されているURIのタイプに関係なく、取得アクションの結果のデータのプロパティです。したがって、フラグメント識別子の形式と解釈は、検索結果のメディアタイプ[RFC2046]によって異なります。セクション2で説明されている文字制限"
    },
    {
      "indent": 3,
      "text": "for URI also apply to the fragment in a URI-reference. Individual media types may define additional restrictions or structure within the fragment for specifying different types of \"partial views\" that can be identified within that media type.",
      "ja": "URIは、URI参照のフラグメントにも適用されます。個々のメディアタイプは、そのメディアタイプ内で識別できるさまざまなタイプの「部分ビュー」を指定するために、フラグメント内に追加の制限または構造を定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "A fragment identifier is only meaningful when a URI reference is intended for retrieval and the result of that retrieval is a document for which the identified fragment is consistently defined.",
      "ja": "フラグメント識別子は、URI参照が検索を目的としており、その検索の結果が、識別されたフラグメントが一貫して定義されているドキュメントである場合にのみ意味があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Same-document References",
      "section_title": true,
      "ja": "4.2. 同じドキュメントの参照"
    },
    {
      "indent": 3,
      "text": "A URI reference that does not contain a URI is a reference to the current document. In other words, an empty URI reference within a document is interpreted as a reference to the start of that document, and a reference containing only a fragment identifier is a reference to the identified fragment of that document. Traversal of such a reference should not result in an additional retrieval action. However, if the URI reference occurs in a context that is always intended to result in a new request, as in the case of HTML's FORM element, then an empty URI reference represents the base URI of the current document and should be replaced by that URI when transformed into a request.",
      "ja": "URIを含まないURI参照は、現在のドキュメントへの参照です。つまり、ドキュメント内の空のURI参照はそのドキュメントの先頭への参照として解釈され、フラグメント識別子のみを含む参照はそのドキュメントの識別されたフラグメントへの参照です。そのような参照のトラバーサルによって、追加の検索アクションが発生することはありません。ただし、HTMLのFORM要素の場合のように、URI参照が常に新しいリクエストをもたらすことを意図したコンテキストで発生する場合、空のURI参照は現在のドキュメントのベースURIを表し、そのURIで置き換える必要がありますリクエストに変換されたとき。"
    },
    {
      "indent": 0,
      "text": "4.3. Parsing a URI Reference",
      "section_title": true,
      "ja": "4.3. URI参照の解析"
    },
    {
      "indent": 3,
      "text": "A URI reference is typically parsed according to the four main components and fragment identifier in order to determine what components are present and whether the reference is relative or absolute. The individual components are then parsed for their subparts and, if not opaque, to verify their validity.",
      "ja": "URI参照は通常、4つの主要コンポーネントとフラグメント識別子に従って解析され、存在するコンポーネントと、参照が相対か絶対かを判別します。次に、個々のコンポーネントがそれらのサブパートについて解析され、不透明でない場合は、それらの有効性を検証します。"
    },
    {
      "indent": 3,
      "text": "Although the BNF defines what is allowed in each component, it is ambiguous in terms of differentiating between an authority component and a path component that begins with two slash characters. The greedy algorithm is used for disambiguation: the left-most matching rule soaks up as much of the URI reference string as it is capable of matching. In other words, the authority component wins.",
      "ja": "BNFは各コンポーネントで許可されるものを定義しますが、オーソリティコンポーネントと2つのスラッシュ文字で始まるパスコンポーネントを区別するという点ではあいまいです。あいまいさを解消するために貪欲なアルゴリズムが使用されます。左端のマッチングルールは、URI参照文字列を、マッチングが可能な限り吸収します。つまり、オーソリティコンポーネントが優先されます。"
    },
    {
      "indent": 3,
      "text": "Readers familiar with regular expressions should see Appendix B for a concrete parsing example and test oracle.",
      "ja": "正規表現に慣れている読者は、具体的な解析例とテストオラクルについて付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Relative URI References",
      "section_title": true,
      "ja": "5. 相対URI参照"
    },
    {
      "indent": 3,
      "text": "It is often the case that a group or \"tree\" of documents has been constructed to serve a common purpose; the vast majority of URI in these documents point to resources within the tree rather than outside of it. Similarly, documents located at a particular site are much more likely to refer to other resources at that site than to resources at remote sites.",
      "ja": "多くの場合、ドキュメントのグループまたは「ツリー」は、共通の目的に役立つように構築されています。これらのドキュメントのURIの大部分は、ツリーの外部ではなく、ツリー内のリソースを指しています。同様に、特定のサイトにあるドキュメントは、リモートサイトのリソースよりもそのサイトの他のリソースを参照する可能性がはるかに高くなります。"
    },
    {
      "indent": 3,
      "text": "Relative addressing of URI allows document trees to be partially independent of their location and access scheme. For instance, it is possible for a single set of hypertext documents to be simultaneously accessible and traversable via each of the \"file\", \"http\", and \"ftp\" schemes if the documents refer to each other using relative URI. Furthermore, such document trees can be moved, as a whole, without changing any of the relative references. Experience within the WWW has demonstrated that the ability to perform relative referencing is necessary for the long-term usability of embedded URI.",
      "ja": "URIの相対アドレッシングにより、ドキュメントツリーをその場所やアクセススキームから部分的に独立させることができます。たとえば、ドキュメントが相対URIを使用して相互に参照している場合、「テキスト」、「http」、および「ftp」の各スキームを介して、1組のハイパーテキストドキュメントに同時にアクセスおよびトラバースできる可能性があります。さらに、このようなドキュメントツリーは、相対的な参照を変更することなく、全体として移動できます。 WWW内での経験から、埋め込まれたURIを長期間使用するには、相対参照を実行する機能が必要であることが実証されています。"
    },
    {
      "indent": 3,
      "text": "The syntax for relative URI takes advantage of the <hier_part> syntax of <absoluteURI> (Section 3) in order to express a reference that is relative to the namespace of another hierarchical URI.",
      "ja": "相対URIの構文は、<absoluteURI>（セクション3）の<hier_part>構文を利用して、別の階層URIの名前空間に関連する参照を表現します。"
    },
    {
      "indent": 6,
      "text": "relativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A relative reference beginning with two slash characters is termed a network-path reference, as defined by <net_path> in Section 3. Such references are rarely used.",
      "ja": "2つのスラッシュ文字で始まる相対参照は、セクション3の<net_path>で定義されているように、ネットワークパス参照と呼ばれます。このような参照はほとんど使用されません。"
    },
    {
      "indent": 3,
      "text": "A relative reference beginning with a single slash character is termed an absolute-path reference, as defined by <abs_path> in Section 3.",
      "ja": "1つのスラッシュ文字で始まる相対参照は、セクション3の<abs_path>で定義されているように、絶対パス参照と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "A relative reference that does not begin with a scheme name or a slash character is termed a relative-path reference.",
      "ja": "スキーム名またはスラッシュ文字で始まらない相対参照は、相対パス参照と呼ばれます。"
    },
    {
      "indent": 6,
      "text": "rel_path = rel_segment [ abs_path ]",
      "ja": "rel_path = rel_segment [abs_path]"
    },
    {
      "indent": 6,
      "text": "rel_segment   = 1*( unreserved | escaped |\n                    \";\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Within a relative-path reference, the complete path segments \".\" and \"..\" have special meanings: \"the current hierarchy level\" and \"the level above this hierarchy level\", respectively. Although this is very similar to their use within Unix-based filesystems to indicate directory levels, these path components are only considered special when resolving a relative-path reference to its absolute form (Section 5.2).",
      "ja": "相対パス参照内では、完全なパスセグメント「。」 「..」と「..」は、それぞれ「現在の階層レベル」と「この階層レベルの上のレベル」という特別な意味を持っています。これは、ディレクトリレベルを示すUnixベースのファイルシステム内での使用と非常に似ていますが、これらのパスコンポーネントは、相対パス参照を絶対形式に解決するときにのみ特別と見なされます（セクション5.2）。"
    },
    {
      "indent": 3,
      "text": "Authors should be aware that a path segment which contains a colon character cannot be used as the first segment of a relative URI path (e.g., \"this:that\"), because it would be mistaken for a scheme name.",
      "ja": "作成者は、コロン文字を含むパスセグメントを相対URIパスの最初のセグメント（たとえば、「this：that」）として使用できないことに注意してください。これは、スキーム名と間違われるためです。"
    },
    {
      "indent": 3,
      "text": "It is therefore necessary to precede such segments with other segments (e.g., \"./this:that\") in order for them to be referenced as a relative path.",
      "ja": "したがって、これらのセグメントを相対パスとして参照するには、そのようなセグメントの前に他のセグメント（たとえば、「./ this：that」）を付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "It is not necessary for all URI within a given scheme to be restricted to the <hier_part> syntax, since the hierarchical properties of that syntax are only necessary when relative URI are used within a particular document. Documents can only make use of relative URI when their base URI fits within the <hier_part> syntax. It is assumed that any document which contains a relative reference will also have a base URI that obeys the syntax. In other words, relative URI cannot be used within a document that has an unsuitable base URI.",
      "ja": "特定のドキュメント内で相対URIが使用されている場合にのみ構文の階層プロパティが必要になるため、特定のスキーム内のすべてのURIを<hier_part>構文に制限する必要はありません。ドキュメントは、ベースURIが<hier_part>構文内に収まる場合にのみ相対URIを使用できます。相対参照を含むすべてのドキュメントにも、構文に従うベースURIがあると想定されています。つまり、不適切なベースURIを持つドキュメント内では相対URIを使用できません。"
    },
    {
      "indent": 3,
      "text": "Some URI schemes do not allow a hierarchical syntax matching the <hier_part> syntax, and thus cannot use relative references.",
      "ja": "一部のURIスキームでは、<hier_part>構文に一致する階層構文を使用できないため、相対参照を使用できません。"
    },
    {
      "indent": 0,
      "text": "5.1. Establishing a Base URI",
      "section_title": true,
      "ja": "5.1. ベースURIの確立"
    },
    {
      "indent": 3,
      "text": "The term \"relative URI\" implies that there exists some absolute \"base URI\" against which the relative reference is applied. Indeed, the base URI is necessary to define the semantics of any relative URI reference; without it, a relative reference is meaningless. In order for relative URI to be usable within a document, the base URI of that document must be known to the parser.",
      "ja": "「相対URI」という用語は、相対参照が適用される絶対的な「ベースURI」が存在することを意味します。実際、ベースURIは、相対URI参照のセマンティクスを定義するために必要です。それがなければ、相対参照は意味がありません。相対URIをドキュメント内で使用できるようにするには、そのドキュメントのベースURIがパーサーに認識されている必要があります。"
    },
    {
      "indent": 3,
      "text": "The base URI of a document can be established in one of four ways, listed below in order of precedence. The order of precedence can be thought of in terms of layers, where the innermost defined base URI has the highest precedence. This can be visualized graphically as:",
      "ja": "ドキュメントのベースURIは、4つの方法のいずれかで確立できます。優先順位は、層の観点から考えることができます。最も内側に定義されたベースURIが最も優先されます。これは次のようにグラフィカルに視覚化できます。"
    },
    {
      "indent": 6,
      "text": ".----------------------------------------------------------.\n|  .----------------------------------------------------.  |\n|  |  .----------------------------------------------.  |  |\n|  |  |  .----------------------------------------.  |  |  |\n|  |  |  |  .----------------------------------.  |  |  |  |\n|  |  |  |  |       <relative_reference>       |  |  |  |  |\n|  |  |  |  `----------------------------------'  |  |  |  |\n|  |  |  | (5.1.1) Base URI embedded in the       |  |  |  |\n|  |  |  |         document's content             |  |  |  |\n|  |  |  `----------------------------------------'  |  |  |\n|  |  | (5.1.2) Base URI of the encapsulating entity |  |  |\n|  |  |         (message, document, or none).        |  |  |\n|  |  `----------------------------------------------'  |  |\n|  | (5.1.3) URI used to retrieve the entity            |  |\n|  `----------------------------------------------------'  |\n| (5.1.4) Default Base URI is application-dependent        |\n`----------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.1. Base URI within Document Content",
      "section_title": true,
      "ja": "5.1.1. ドキュメントコンテンツ内のベースURI"
    },
    {
      "indent": 3,
      "text": "Within certain document media types, the base URI of the document can be embedded within the content itself such that it can be readily obtained by a parser. This can be useful for descriptive documents, such as tables of content, which may be transmitted to others through protocols other than their usual retrieval context (e.g., E-Mail or USENET news).",
      "ja": "特定のドキュメントメディアタイプ内では、パーサーが簡単に取得できるように、ドキュメント自体のベースURIをコンテンツ自体に埋め込むことができます。これは、通常の検索コンテキスト以外のプロトコル（電子メールやUSENETニュースなど）を介して他の人に送信される可能性のある、目次などの説明的なドキュメントに役立ちます。"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this document to specify how, for each media type, the base URI can be embedded. It is assumed that user agents manipulating such media types will be able to obtain the appropriate syntax from that media type's specification. An example of how the base URI can be embedded in the Hypertext Markup Language (HTML) [RFC1866] is provided in Appendix D.",
      "ja": "メディアタイプごとにベースURIを埋め込む方法を指定することは、このドキュメントの範囲外です。このようなメディアタイプを操作するユーザーエージェントは、そのメディアタイプの仕様から適切な構文を取得できると想定されています。ベースURIをハイパーテキストマークアップ言語（HTML）[RFC1866]に埋め込む方法の例を付録Dに示します。"
    },
    {
      "indent": 3,
      "text": "A mechanism for embedding the base URI within MIME container types (e.g., the message and multipart types) is defined by MHTML [RFC2110]. Protocols that do not use the MIME message header syntax, but which do allow some form of tagged metainformation to be included within messages, may define their own syntax for defining the base URI as part of a message.",
      "ja": "MIMEコンテナタイプ（メッセージやマルチパートタイプなど）内にベースURIを埋め込むためのメカニズムは、MHTML [RFC2110]で定義されています。 MIMEメッセージヘッダー構文を使用しないが、何らかの形式のタグ付きメタ情報をメッセージ内に含めることができるプロトコルでは、メッセージの一部としてベースURIを定義するための独自の構文を定義できます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Base URI from the Encapsulating Entity",
      "section_title": true,
      "ja": "5.1.2. カプセル化エンティティからのベースURI"
    },
    {
      "indent": 3,
      "text": "If no base URI is embedded, the base URI of a document is defined by the document's retrieval context. For a document that is enclosed within another entity (such as a message or another document), the retrieval context is that entity; thus, the default base URI of the document is the base URI of the entity in which the document is encapsulated.",
      "ja": "ベースURIが埋め込まれていない場合、ドキュメントのベースURIはドキュメントの取得コンテキストによって定義されます。別のエンティティ（メッセージや別のドキュメントなど）に囲まれているドキュメントの場合、取得コンテキストはそのエンティティです。したがって、ドキュメントのデフォルトのベースURIは、ドキュメントがカプセル化されているエンティティのベースURIです。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Base URI from the Retrieval URI",
      "section_title": true,
      "ja": "5.1.3. 取得URIからのベースURI"
    },
    {
      "indent": 3,
      "text": "If no base URI is embedded and the document is not encapsulated within some other entity (e.g., the top level of a composite entity), then, if a URI was used to retrieve the base document, that URI shall be considered the base URI. Note that if the retrieval was the result of a redirected request, the last URI used (i.e., that which resulted in the actual retrieval of the document) is the base URI.",
      "ja": "ベースURIが埋め込まれておらず、ドキュメントが他のエンティティ（たとえば、複合エンティティの最上位）内にカプセル化されていない場合、URIを使用してベースドキュメントを取得すると、そのURIはベースURIと見なされます。検索がリダイレクトされた要求の結果であった場合、最後に使用されたURI（つまり、ドキュメントの実際の検索をもたらしたもの）がベースURIであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Default Base URI",
      "section_title": true,
      "ja": "5.1.4. デフォルトのベースURI"
    },
    {
      "indent": 3,
      "text": "If none of the conditions described in Sections 5.1.1--5.1.3 apply, then the base URI is defined by the context of the application. Since this definition is necessarily application-dependent, failing to define the base URI using one of the other methods may result in the same content being interpreted differently by different types of application.",
      "ja": "セクション5.1.1から5.1.3で説明されている条件のいずれにも該当しない場合、ベースURIはアプリケーションのコンテキストによって定義されます。この定義は必ずアプリケーションに依存するため、他の方法のいずれかを使用してベースURIを定義しないと、同じコンテンツが異なるタイプのアプリケーションによって異なる解釈をされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the distributor(s) of a document containing relative URI to ensure that the base URI for that document can be established. It must be emphasized that relative URI cannot be used reliably in situations where the document's base URI is not well-defined.",
      "ja": "相対URIを含むドキュメントの配布者は、そのドキュメントのベースURIを確立できるようにする必要があります。ドキュメントのベースURIが明確に定義されていない状況では、相対URIを確実に使用できないことを強調しておく必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Resolving Relative References to Absolute Form",
      "section_title": true,
      "ja": "5.2. 絶対参照への相対参照の解決"
    },
    {
      "indent": 3,
      "text": "This section describes an example algorithm for resolving URI references that might be relative to a given base URI.",
      "ja": "このセクションでは、特定のベースURIに関連している可能性があるURI参照を解決するためのアルゴリズムの例について説明します。"
    },
    {
      "indent": 3,
      "text": "The base URI is established according to the rules of Section 5.1 and parsed into the four main components as described in Section 3. Note that only the scheme component is required to be present in the base URI; the other components may be empty or undefined. A component is undefined if its preceding separator does not appear in the URI reference; the path component is never undefined, though it may be empty. The base URI's query component is not used by the resolution algorithm and may be discarded.",
      "ja": "ベースURIはセクション5.1のルールに従って確立され、セクション3で説明されているように4つの主要コンポーネントに解析されます。ベースURIに存在する必要があるのはスキームコンポーネントのみであることに注意してください。他のコンポーネントは空または未定義の場合があります。前のセパレーターがURI参照にない場合、コンポーネントは未定義です。パスコンポーネントは空である可能性がありますが、未定義になることはありません。ベースURIのクエリコンポーネントは、解決アルゴリズムでは使用されず、破棄される場合があります。"
    },
    {
      "indent": 3,
      "text": "For each URI reference, the following steps are performed in order:",
      "ja": "各URI参照について、次の手順が順番に実行されます。"
    },
    {
      "indent": 3,
      "text": "1) The URI reference is parsed into the potential four components and fragment identifier, as described in Section 4.3.",
      "ja": "1）セクション4.3で説明されているように、URI参照は、潜在的な4つのコンポーネントとフラグメント識別子に解析されます。"
    },
    {
      "indent": 3,
      "text": "2) If the path component is empty and the scheme, authority, and query components are undefined, then it is a reference to the current document and we are done. Otherwise, the reference URI's query and fragment components are defined as found (or not found) within the URI reference and not inherited from the base URI.",
      "ja": "2）パスコンポーネントが空で、スキーム、権限、およびクエリコンポーネントが定義されていない場合、それは現在のドキュメントへの参照であり、これで完了です。それ以外の場合、参照URIのクエリおよびフラグメントコンポーネントは、URI参照内で見つかった（または見つからなかった）と定義され、ベースURIから継承されません。"
    },
    {
      "indent": 3,
      "text": "3) If the scheme component is defined, indicating that the reference starts with a scheme name, then the reference is interpreted as an absolute URI and we are done. Otherwise, the reference URI's scheme is inherited from the base URI's scheme component.",
      "ja": "3）スキームコンポーネントが定義されていて、参照がスキーム名で始まることを示している場合、参照は絶対URIとして解釈され、完了です。それ以外の場合、参照URIのスキーマは、ベースURIのスキーマコンポーネントから継承されます。"
    },
    {
      "indent": 6,
      "text": "Due to a loophole in prior specifications [RFC1630], some parsers allow the scheme name to be present in a relative URI if it is the same as the base URI scheme. Unfortunately, this can conflict with the correct parsing of non-hierarchical URI. For backwards compatibility, an implementation may work around such references by removing the scheme if it matches that of the base URI and the scheme is known to always use the <hier_part> syntax. The parser can then continue with the steps below for the remainder of the reference components. Validating parsers should mark such a misformed relative reference as an error.",
      "ja": "以前の仕様[RFC1630]の抜け穴のため、一部のパーサーは、スキーマ名がベースURIスキームと同じである場合に、相対URIに存在することを許可しています。残念ながら、これは非階層URIの正しい解析と競合する可能性があります。下位互換性のために、実装は、ベースURIのスキームと一致し、スキームが常に<hier_part>構文を使用することがわかっている場合、スキームを削除することにより、このような参照を回避できます。その後、パーサーは残りの参照コンポーネントについて以下の手順を続行できます。検証パーサーは、このような誤った形式の相対参照をエラーとしてマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "4) If the authority component is defined, then the reference is a network-path and we skip to step 7. Otherwise, the reference URI's authority is inherited from the base URI's authority component, which will also be undefined if the URI scheme does not use an authority component.",
      "ja": "4）権限コンポーネントが定義されている場合、参照はnetwork-pathであり、ステップ7にスキップします。それ以外の場合、参照URIの権限は、ベースURIの権限コンポーネントから継承されます。URIスキームがそうでない場合も、未定義になります権限コンポーネントを使用します。"
    },
    {
      "indent": 3,
      "text": "5) If the path component begins with a slash character (\"/\"), then the reference is an absolute-path and we skip to step 7.",
      "ja": "5）パスコンポーネントがスラッシュ文字（ \"/\"）で始まる場合、参照は絶対パスであり、手順7にスキップします。"
    },
    {
      "indent": 3,
      "text": "6) If this step is reached, then we are resolving a relative-path reference. The relative path needs to be merged with the base URI's path. Although there are many ways to do this, we will describe a simple method using a separate string buffer.",
      "ja": "6）このステップに達した場合、相対パス参照を解決しています。相対パスは、ベースURIのパスとマージする必要があります。これには多くの方法がありますが、個別の文字列バッファを使用する簡単な方法について説明します。"
    },
    {
      "indent": 6,
      "text": "a) All but the last segment of the base URI's path component is copied to the buffer. In other words, any characters after the last (right-most) slash character, if any, are excluded.",
      "ja": "a) ベースURIのパスコンポーネントの最後のセグメントを除くすべてがバッファにコピーされます。つまり、最後の（右端の）スラッシュ文字の後の文字があれば、それは除外されます。"
    },
    {
      "indent": 6,
      "text": "b) The reference's path component is appended to the buffer string.",
      "ja": "b) 参照のパスコンポーネントがバッファ文字列に追加されます。"
    },
    {
      "indent": 6,
      "text": "c) All occurrences of \"./\", where \".\" is a complete path segment, are removed from the buffer string.",
      "ja": "c) 「./」のすべての出現、「。」完全なパスセグメントです。バッファ文字列から削除されます。"
    },
    {
      "indent": 6,
      "text": "d) If the buffer string ends with \".\" as a complete path segment, that \".\" is removed.",
      "ja": "d) バッファ文字列が「。」で終わる場合完全なパスセグメントとして、「。」削除されます。"
    },
    {
      "indent": 6,
      "text": "e) All occurrences of \"<segment>/../\", where <segment> is a complete path segment not equal to \"..\", are removed from the buffer string. Removal of these path segments is performed iteratively, removing the leftmost matching pattern on each iteration, until no matching pattern remains.",
      "ja": "e) \"<segment> /../\"のすべての出現は、<。segment>が \"..\"と等しくない完全なパスセグメントであり、バッファー文字列から削除されます。これらのパスセグメントの削除は繰り返し実行され、一致するパターンがなくなるまで、各反復で左端の一致するパターンが削除されます。"
    },
    {
      "indent": 6,
      "text": "f) If the buffer string ends with \"<segment>/..\", where <segment> is a complete path segment not equal to \"..\", that \"<segment>/..\" is removed.",
      "ja": "f) バッファ文字列が「<segment> / ..」で終わっている場合、<segment>は「..」に等しくない完全なパスセグメントであり、「<segment> / ..」は削除されます。"
    },
    {
      "indent": 6,
      "text": "g) If the resulting buffer string still begins with one or more complete path segments of \"..\", then the reference is considered to be in error. Implementations may handle this error by retaining these components in the resolved path (i.e., treating them as part of the final URI), by removing them from the resolved path (i.e., discarding relative levels above the root), or by avoiding traversal of the reference.",
      "ja": "g) 結果のバッファ文字列がまだ「..」の1つ以上の完全なパスセグメントで始まっている場合、参照はエラーと見なされます。実装は、これらのコンポーネントを解決済みパスに保持する（つまり、最終的なURIの一部として扱う）、解決済みパスからコンポーネントを削除する（つまり、ルートより上の相対レベルを破棄する）か、または参照。"
    },
    {
      "indent": 6,
      "text": "h) The remaining buffer string is the reference URI's new path component.",
      "ja": "h) 残りのバッファ文字列は、参照URIの新しいパスコンポーネントです。"
    },
    {
      "indent": 3,
      "text": "7) The resulting URI components, including any inherited from the base URI, are recombined to give the absolute form of the URI reference. Using pseudocode, this would be",
      "ja": "7）ベースURIから継承されたものを含む、結果のURIコンポーネントは、URI参照の絶対形式を提供するために再結合されます。擬似コードを使用すると、これは"
    },
    {
      "indent": 9,
      "text": "result = \"\"",
      "ja": "結果= \"\""
    },
    {
      "indent": 9,
      "text": "if scheme is defined then append scheme to result append \":\" to result",
      "ja": "スキームが定義されている場合、結果にスキームを追加し、結果に「：」を追加します"
    },
    {
      "indent": 9,
      "text": "if authority is defined then append \"//\" to result append authority to result",
      "ja": "権限が定義されている場合は、結果に「//」を追加し、結果に権限を追加します"
    },
    {
      "indent": 9,
      "text": "append path to result",
      "ja": "結果にパスを追加"
    },
    {
      "indent": 9,
      "text": "if query is defined then append \"?\" to result append query to result",
      "ja": "クエリが定義されている場合は、「？」を追加します結果にクエリを追加する"
    },
    {
      "indent": 9,
      "text": "if fragment is defined then append \"#\" to result append fragment to result",
      "ja": "フラグメントが定義されている場合は、「＃」を結果に追加し、フラグメントを結果に追加します"
    },
    {
      "indent": 9,
      "text": "return result",
      "ja": "結果を返す"
    },
    {
      "indent": 6,
      "text": "Note that we must be careful to preserve the distinction between a component that is undefined, meaning that its separator was not present in the reference, and a component that is empty, meaning that the separator was present and was immediately followed by the next component separator or the end of the reference.",
      "ja": "未定義のコンポーネント（参照にセパレーターが存在しないことを意味する）と空のコンポーネント（セパレーターが存在し、直後に次のコンポーネントセパレーターが続いていることを意味する）の違いを維持するように注意する必要があることに注意してください。または参照の終わり。"
    },
    {
      "indent": 3,
      "text": "The above algorithm is intended to provide an example by which the output of implementations can be tested -- implementation of the algorithm itself is not required. For example, some systems may find it more efficient to implement step 6 as a pair of segment stacks being merged, rather than as a series of string pattern replacements.",
      "ja": "上記のアルゴリズムは、実装の出力をテストできる例を提供することを目的としています。アルゴリズム自体の実装は必要ありません。たとえば、システムによっては、手順6を一連の文字列パターン置換ではなく、1組のセグメントスタックとしてマージする方が効率的である場合があります。"
    },
    {
      "indent": 6,
      "text": "Note: Some WWW client applications will fail to separate the reference's query component from its path component before merging the base and reference paths in step 6 above. This may result in a loss of information if the query component contains the strings \"/../\" or \"/./\".",
      "ja": "注：一部のWWWクライアントアプリケーションは、上記の手順6でベースパスと参照パスをマージする前に、参照のクエリコンポーネントをパスコンポーネントから分離できません。これにより、クエリコンポーネントに文字列「/../」または「/./」が含まれている場合、情報が失われる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Resolution examples are provided in Appendix C.",
      "ja": "解決例は付録Cにあります。"
    },
    {
      "indent": 0,
      "text": "6. URI Normalization and Equivalence",
      "section_title": true,
      "ja": "6. URIの正規化と同等性"
    },
    {
      "indent": 3,
      "text": "In many cases, different URI strings may actually identify the identical resource. For example, the host names used in URL are actually case insensitive, and the URL <http://www.XEROX.com> is equivalent to <http://www.xerox.com>. In general, the rules for equivalence and definition of a normal form, if any, are scheme dependent. When a scheme uses elements of the common syntax, it will also use the common syntax equivalence rules, namely that the scheme and hostname are case insensitive and a URL with an explicit \":port\", where the port is the default for the scheme, is equivalent to one where the port is elided.",
      "ja": "多くの場合、異なるURI文字列は実際には同一のリソースを識別します。たとえば、URLで使用されるホスト名は実際には大文字と小文字を区別せず、URL <http://www.XEROX.com>は<http://www.xerox.com>と同等です。一般に、正規形の等価性と定義の規則は、もしあれば、スキームに依存します。スキームが共通の構文の要素を使用する場合、スキームとホスト名は大文字と小文字を区別せず、明示的に \"：port\"のURLを使用するという共通の構文等価ルールも使用します。ポートはスキームのデフォルトです。ポートを省略した場合と同じです。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A URI does not in itself pose a security threat. Users should beware that there is no general guarantee that a URL, which at one time located a given resource, will continue to do so. Nor is there any guarantee that a URL will not locate a different resource at some later point in time, due to the lack of any constraint on how a given authority apportions its namespace. Such a guarantee can only be obtained from the person(s) controlling that namespace and the resource in question. A specific URI scheme may include additional semantics, such as name persistence, if those semantics are required of all naming authorities for that scheme.",
      "ja": "URI自体はセキュリティ上の脅威にはなりません。ユーザーは、特定のリソースを一度に見つけたURLが引き続きそうであるという一般的な保証はないことに注意する必要があります。また、特定の機関がその名前空間を割り当てる方法に制約がないため、URLが後から別のリソースを見つけられないという保証もありません。このような保証は、その名前空間と問題のリソースを制御する人からのみ取得できます。特定のURIスキームには、そのスキームのすべての命名機関に必要なセマンティクスがある場合、名前の永続性などの追加のセマンティクスが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "It is sometimes possible to construct a URL such that an attempt to perform a seemingly harmless, idempotent operation, such as the retrieval of an entity associated with the resource, will in fact cause a possibly damaging remote operation to occur. The unsafe URL is typically constructed by specifying a port number other than that reserved for the network protocol in question. The client unwittingly contacts a site that is in fact running a different protocol. The content of the URL contains instructions that, when interpreted according to this other protocol, cause an unexpected operation. An example has been the use of a gopher URL to cause an unintended or impersonating message to be sent via a SMTP server.",
      "ja": "リソースに関連付けられたエンティティの取得など、一見無害なべき等の操作を実行しようとすると、実際に損傷を与える可能性のあるリモート操作が発生するように、URLを構築できる場合があります。安全でないURLは通常、問題のネットワークプロトコル用に予約されているポート番号以外のポート番号を指定することによって構築されます。クライアントは、実際には別のプロトコルを実行しているサイトに無意識のうちに連絡します。 URLのコンテンツには、この他のプロトコルに従って解釈されたときに予期しない操作を引き起こす指示が含まれています。例としては、Gopher URLを使用して、意図しないメッセージまたは偽装メッセージをSMTPサーバー経由で送信することが挙げられます。"
    },
    {
      "indent": 3,
      "text": "Caution should be used when using any URL that specifies a port number other than the default for the protocol, especially when it is a number within the reserved space.",
      "ja": "プロトコルのデフォルト以外のポート番号を指定するURLを使用する場合、特に予約されたスペース内のポート番号である場合は注意が必要です。"
    },
    {
      "indent": 3,
      "text": "Care should be taken when a URL contains escaped delimiters for a given protocol (for example, CR and LF characters for telnet protocols) that these are not unescaped before transmission. This might violate the protocol, but avoids the potential for such characters to be used to simulate an extra operation or parameter in that protocol, which might lead to an unexpected and possibly harmful remote operation to be performed.",
      "ja": "URLに特定のプロトコルのエスケープ区切り文字（たとえば、TelnetプロトコルのCRおよびLF文字）が含まれている場合は、転送前にエスケープしないように注意する必要があります。これはプロトコルに違反する可能性がありますが、そのような文字がそのプロトコルの追加の操作またはパラメーターをシミュレートするために使用される可能性を回避します。これにより、予期しない有害なリモート操作が実行される可能性があります。"
    },
    {
      "indent": 3,
      "text": "It is clearly unwise to use a URL that contains a password which is intended to be secret. In particular, the use of a password within the 'userinfo' component of a URL is strongly disrecommended except in those rare cases where the 'password' parameter is intended to be public.",
      "ja": "秘密にすることを目的としたパスワードを含むURLを使用することは明らかに賢明ではありません。特に、URLの「userinfo」コンポーネント内でのパスワードの使用は、「password」パラメーターが公開されることが意図されているまれな場合を除いて、強くお勧めできません。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document was derived from RFC 1738 [RFC1738] and RFC 1808 [RFC1808]; the acknowledgements in those specifications still apply. In addition, contributions by Gisle Aas, Martin Beet, Martin Duerst, Jim Gettys, Martijn Koster, Dave Kristol, Daniel LaLiberte, Foteos Macrides, James Marshall, Ryan Moats, Keith Moore, and Lauren Wood are gratefully acknowledged.",
      "ja": "このドキュメントは、RFC 1738 [RFC1738]およびRFC 1808 [RFC1808]から派生しました。これらの仕様の承認は引き続き適用されます。さらに、Gisle Aas、Martin Beet、Martin Duerst、Jim Gettys、Martijn Koster、Dave Kristol、Daniel LaLiberte、Foteos Macrides、James Marshall、Ryan Moats、Keith Moore、およびLauren Woodによる貢献に感謝します。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2277] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[RFC2277] Alvestrand、H。、「文字セットと言語に関するIETFポリシー」、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC1630] Berners-Lee, T., \"Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web\", RFC 1630, June 1994.",
      "ja": "[RFC1630] Berners-Lee、T。、「WWWのユニバーサルリソース識別子：World-Wide Webで使用されるネットワーク上のオブジェクトの名前とアドレスの表現の統一構文」、RFC 1630、1994年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, Editors, \"Uniform Resource Locators (URL)\", RFC 1738, December 1994.",
      "ja": "[RFC1738] Berners-Lee、T.、Masinter、L。、およびM. McCahill、編集者、「Uniform Resource Locators（URL）」、RFC 1738、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1866] Berners-Lee T., and D. Connolly, \"HyperText Markup Language Specification -- 2.0\", RFC 1866, November 1995.",
      "ja": "[RFC1866] Berners-Lee T.、およびD. Connolly、「HyperText Markup Language Specification-2.0」、RFC 1866、1995年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., Editor, \"Requirements for Internet Hosts -- Application and Support\", STD 3, RFC 1123, October 1989.",
      "ja": "[RFC1123] Braden、R。、編集者、「インターネットホストの要件-アプリケーションとサポート」、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC822] Crocker, D., \"Standard for the Format of ARPA Internet Text Messages\", STD 11, RFC 822, August 1982.",
      "ja": "[RFC822] Crocker、D。、「ARPAインターネットテキストメッセージのフォーマットの標準」、STD 11、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1808] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808, June 1995.",
      "ja": "[RFC1808]フィールディング、R。、「Relative Uniform Resource Locators」、RFC 1808、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2046] Freed, N., and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, November 1996.",
      "ja": "[RFC2046] Freed、N。、およびN. Borenstein、「Multipurpose Internet Mail Extensions（MIME）Part Two：Media Types」、RFC 2046、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1736] Kunze, J., \"Functional Recommendations for Internet Resource Locators\", RFC 1736, February 1995.",
      "ja": "[RFC1736] Kunze、J。、「Functional Recommendations for Internet Resource Locators」、RFC 1736、1995年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2141] Moats, R., \"URN Syntax\", RFC 2141, May 1997.",
      "ja": "[RFC2141] Moats、R。、「URN Syntax」、RFC 2141、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain Names - Concepts and Facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2110] Palme, J., and A. Hopmann, \"MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March 1997.",
      "ja": "[RFC2110] Palme、J。、およびA. Hopmann、「HTML（MHTML）などの集約ドキュメントのMIME電子メールカプセル化」、RFC 2110、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1737] Sollins, K., and L. Masinter, \"Functional Requirements for Uniform Resource Names\", RFC 1737, December 1994.",
      "ja": "[RFC1737] Sollins、K。、およびL. Masinter、「Uniform Resource Namesの機能要件」、RFC 1737、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[ASCII] US-ASCII. \"Coded Character Set -- 7-bit American Standard Code for Information Interchange\", ANSI X3.4-1986.",
      "ja": "[ASCII] US-ASCII。 「コード化文字セット-情報交換のための7ビットのアメリカ標準コード」、ANSI X3.4-1986。"
    },
    {
      "indent": 3,
      "text": "[UTF-8] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[UTF-8] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、RFC 2279、1998年1月。"
    },
    {
      "indent": 0,
      "text": "10. Authors' Addresses",
      "section_title": true,
      "ja": "10. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tim Berners-Lee World Wide Web Consortium MIT Laboratory for Computer Science, NE43-356 545 Technology Square Cambridge, MA 02139",
      "ja": "Tim Berners-LeeワールドワイドウェブコンソーシアムMITコンピュータサイエンス研究所、NE43-356 545 Technology Square Cambridge、MA 02139"
    },
    {
      "indent": 3,
      "text": "Fax: +1(617)258-8682\nEMail: timbl@w3.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding Department of Information and Computer Science University of California, Irvine Irvine, CA 92697-3425",
      "ja": "ロイT.フィールディングカリフォルニア大学アーバイン校情報およびコンピュータサイエンス学部アーバイン、カリフォルニア州92697-3425"
    },
    {
      "indent": 3,
      "text": "Fax: +1(949)824-1715\nEMail: fielding@ics.uci.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Larry Masinter Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94034",
      "ja": "Larry Masinter Xerox PARC 3333 Coyote Hill Road Palo Alto、CA 94034"
    },
    {
      "indent": 3,
      "text": "Fax: +1(415)812-4333\nEMail: masinter@parc.xerox.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A. Collected BNF for URI",
      "ja": "A. URI用に収集されたBNF"
    },
    {
      "indent": 6,
      "text": "URI-reference = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\nabsoluteURI   = scheme \":\" ( hier_part | opaque_part )\nrelativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "hier_part     = ( net_path | abs_path ) [ \"?\" query ]\nopaque_part   = uric_no_slash *uric",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "uric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\n                \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "net_path      = \"//\" authority [ abs_path ]\nabs_path      = \"/\"  path_segments\nrel_path      = rel_segment [ abs_path ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "rel_segment   = 1*( unreserved | escaped |\n                    \";\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "scheme        = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "authority = server | reg_name",
      "ja": "権限=サーバー| reg_name"
    },
    {
      "indent": 6,
      "text": "reg_name      = 1*( unreserved | escaped | \"$\" | \",\" |\n                    \";\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "server        = [ [ userinfo \"@\" ] hostport ]\nuserinfo      = *( unreserved | escaped |\n                   \";\" | \":\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "hostport      = host [ \":\" port ]\nhost          = hostname | IPv4address\nhostname      = *( domainlabel \".\" ) toplabel [ \".\" ]\ndomainlabel   = alphanum | alphanum *( alphanum | \"-\" ) alphanum\ntoplabel      = alpha | alpha *( alphanum | \"-\" ) alphanum\nIPv4address   = 1*digit \".\" 1*digit \".\" 1*digit \".\" 1*digit\nport          = *digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "path          = [ abs_path | opaque_part ]\npath_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar\npchar         = unreserved | escaped |\n                \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "query         = *uric",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "fragment      = *uric uric          = reserved | unreserved | escaped\nreserved      = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\n                \"$\" | \",\"\nunreserved    = alphanum | mark\nmark          = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" |\n                \"(\" | \")\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "escaped = \"%\" hex hex hex = digit | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"",
      "ja": "エスケープ= \"％\" hex hex hex = digit | 「A」| 「B」| 「C」| 「D」| 「E」| 「F」| 「a」| 「b」| 「c」| 「d」| 「e」| 「f」"
    },
    {
      "indent": 6,
      "text": "alphanum = alpha | digit alpha = lowalpha | upalpha",
      "ja": "alphanum = alpha |数字alpha = lowalpha |アップアルファ"
    },
    {
      "indent": 6,
      "text": "lowalpha = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" upalpha = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"",
      "ja": "lowalpha = \"a\" | 「b」| 「c」| 「d」| 「e」| \"f\" | \"g\" | 「h」| 「私」| 「j」| 「k」| \"l\" | 「m」| 「n」| 「o」| \"p\" | \"q\" | 「r」| 「s」| 「t」| 「u」| 「v」| 「w」| 「x」| 「y」| \"z\" upalpha = \"A\" | 「B」| 「C」| 「D」| 「E」| 「F」| 「G」| 「H」| 「私」| 「J」| 「K」| 「L」| 「M」| 「N」| 「O」| 「P」| 「Q」| 「R」| 「S」| 「T」| 「U」| 「V」| 「W」| 「X」| 「Y」| 「Z」桁=「0」| 「1」| 「2」| 「3」| 「4」| 「5」| 「6」| 「7」| 「8」| 「9」"
    },
    {
      "indent": 0,
      "text": "B. Parsing a URI Reference with a Regular Expression",
      "ja": "B.正規表現によるURI参照の解析"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.3, the generic URI syntax is not sufficient to disambiguate the components of some forms of URI. Since the \"greedy algorithm\" described in that section is identical to the disambiguation method used by POSIX regular expressions, it is natural and commonplace to use a regular expression for parsing the potential four components and fragment identifier of a URI reference.",
      "ja": "セクション4.3で説明されているように、汎用URI構文は、URIの一部の形式のコンポーネントを明確にするのに十分ではありません。そのセクションで説明されている「貪欲なアルゴリズム」はPOSIX正規表現で使用される曖昧性解消方法と同じであるため、URI参照の潜在的な4つのコンポーネントとフラグメント識別子を解析するために正規表現を使用することは自然で一般的です。"
    },
    {
      "indent": 3,
      "text": "The following line is the regular expression for breaking-down a URI reference into its components.",
      "ja": "次の行は、URI参照をコンポーネントに分解するための正規表現です。"
    },
    {
      "indent": 6,
      "text": "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n 12            3  4          5       6  7        8 9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The numbers in the second line above are only to assist readability; they indicate the reference points for each subexpression (i.e., each paired parenthesis). We refer to the value matched for subexpression <n> as $<n>. For example, matching the above expression to",
      "ja": "上記の2行目の数値は、読みやすくするためのものです。それらは、各部分式（つまり、各対の括弧）の参照点を示します。部分式<n>に一致する値を$ <n>と呼びます。たとえば、上記の式を"
    },
    {
      "indent": 6,
      "text": "http://www.ics.uci.edu/pub/ietf/uri/#Related",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "results in the following subexpression matches:",
      "ja": "次の部分式が一致します。"
    },
    {
      "indent": 6,
      "text": "$1 = http:\n$2 = http\n$3 = //www.ics.uci.edu\n$4 = www.ics.uci.edu\n$5 = /pub/ietf/uri/\n$6 = <undefined>\n$7 = <undefined>\n$8 = #Related\n$9 = Related",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where <undefined> indicates that the component is not present, as is the case for the query component in the above example. Therefore, we can determine the value of the four components and fragment as",
      "ja": "<undefined>は、上記の例のクエリコンポーネントの場合と同様に、コンポーネントが存在しないことを示します。したがって、4つのコンポーネントとフラグメントの値を次のように決定できます。"
    },
    {
      "indent": 6,
      "text": "scheme = $2 authority = $4 path = $5 query = $7 fragment = $9",
      "ja": "スキーム= $ 2機関= $ 4パス= $ 5クエリ= $ 7フラグメント= $ 9"
    },
    {
      "indent": 3,
      "text": "and, going in the opposite direction, we can recreate a URI reference from its components using the algorithm in step 7 of Section 5.2.",
      "ja": "反対の方向に進むと、セクション5.2のステップ7のアルゴリズムを使用して、そのコンポーネントからURI参照を再作成できます。"
    },
    {
      "indent": 0,
      "text": "C. Examples of Resolving Relative URI References",
      "ja": "C.相対URI参照を解決する例"
    },
    {
      "indent": 3,
      "text": "Within an object with a well-defined base URI of",
      "ja": "明確に定義されたベースURIを持つオブジェクト内"
    },
    {
      "indent": 6,
      "text": "http://a/b/c/d;p?q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the relative URI would be resolved as follows:",
      "ja": "相対URIは次のように解決されます。"
    },
    {
      "indent": 0,
      "text": "C.1. Normal Examples",
      "section_title": true,
      "ja": "C.1. 通常の例"
    },
    {
      "indent": 6,
      "text": "g:h           =  g:h\ng             =  http://a/b/c/g\n./g           =  http://a/b/c/g\ng/            =  http://a/b/c/g/\n/g            =  http://a/g\n//g           =  http://g\n?y            =  http://a/b/c/?y\ng?y           =  http://a/b/c/g?y\n#s            =  (current document)#s\ng#s           =  http://a/b/c/g#s\ng?y#s         =  http://a/b/c/g?y#s\n;x            =  http://a/b/c/;x\ng;x           =  http://a/b/c/g;x\ng;x?y#s       =  http://a/b/c/g;x?y#s\n.             =  http://a/b/c/\n./            =  http://a/b/c/\n..            =  http://a/b/\n../           =  http://a/b/\n../g          =  http://a/b/g\n../..         =  http://a/\n../../        =  http://a/\n../../g       =  http://a/g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. Abnormal Examples",
      "section_title": true,
      "ja": "C.2. 異常な例"
    },
    {
      "indent": 3,
      "text": "Although the following abnormal examples are unlikely to occur in normal practice, all URI parsers should be capable of resolving them consistently. Each example uses the same base as above.",
      "ja": "次の異常な例は通常の実行では起こりそうにありませんが、すべてのURIパーサーはそれらを一貫して解決できる必要があります。各例では、上記と同じベースを使用しています。"
    },
    {
      "indent": 3,
      "text": "An empty reference refers to the start of the current document.",
      "ja": "空の参照は、現在のドキュメントの先頭を指します。"
    },
    {
      "indent": 6,
      "text": "<>            =  (current document)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Parsers must be careful in handling the case where there are more relative path \"..\" segments than there are hierarchical levels in the base URI's path. Note that the \"..\" syntax cannot be used to change the authority component of a URI.",
      "ja": "パーサーは、ベースURIのパスに階層レベルよりも相対的なパス \"..\"セグメントが多い場合の取り扱いに注意する必要があります。 「..」構文を使用して、URIの権限コンポーネントを変更することはできません。"
    },
    {
      "indent": 6,
      "text": "../../../g    =  http://a/../g\n../../../../g =  http://a/../../g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In practice, some implementations strip leading relative symbolic elements (\".\", \"..\") after applying a relative URI calculation, based on the theory that compensating for obvious author errors is better than allowing the request to fail. Thus, the above two references will be interpreted as \"http://a/g\" by some implementations.",
      "ja": "実際には、実装によっては、明らかな作成者のエラーを補正するほうがリクエストが失敗するよりも良いという理論に基づいて、相対URI計算を適用した後に、先行する相対シンボリック要素（ \"。\"、 \"..\"）を取り除きます。したがって、上記の2つの参照は、一部の実装では「http：// a / g」として解釈されます。"
    },
    {
      "indent": 3,
      "text": "Similarly, parsers must avoid treating \".\" and \"..\" as special when they are not complete components of a relative path.",
      "ja": "同様に、パーサーは「。」の扱いを避けなければなりません。および「..」は、相対パスの完全なコンポーネントではない場合に特別です。"
    },
    {
      "indent": 6,
      "text": "/./g          =  http://a/./g\n/../g         =  http://a/../g\ng.            =  http://a/b/c/g.\n.g            =  http://a/b/c/.g\ng..           =  http://a/b/c/g..\n..g           =  http://a/b/c/..g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Less likely are cases where the relative URI uses unnecessary or nonsensical forms of the \".\" and \"..\" complete path segments.",
      "ja": "相対URIが \"。\"の不必要な形式または無意味な形式を使用する場合は、あまりありません。および「..」完全パスセグメント。"
    },
    {
      "indent": 6,
      "text": "./../g        =  http://a/b/g\n./g/.         =  http://a/b/c/g/\ng/./h         =  http://a/b/c/g/h\ng/../h        =  http://a/b/c/h\ng;x=1/./y     =  http://a/b/c/g;x=1/y\ng;x=1/../y    =  http://a/b/c/y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All client applications remove the query component from the base URI before resolving relative URI. However, some applications fail to separate the reference's query and/or fragment components from a relative path before merging it with the base path. This error is rarely noticed, since typical usage of a fragment never includes the hierarchy (\"/\") character, and the query component is not normally used within relative references.",
      "ja": "すべてのクライアントアプリケーションは、相対URIを解決する前に、ベースURIからクエリコンポーネントを削除します。ただし、一部のアプリケーションでは、参照のクエリやフラグメントコンポーネントをベースパスとマージする前に相対パスから分離できません。フラグメントの一般的な使用法には階層（ \"/\"）文字が含まれず、クエリコンポーネントは通常、相対参照内では使用されないため、このエラーはほとんど発生しません。"
    },
    {
      "indent": 6,
      "text": "g?y/./x       =  http://a/b/c/g?y/./x\ng?y/../x      =  http://a/b/c/g?y/../x\ng#s/./x       =  http://a/b/c/g#s/./x\ng#s/../x      =  http://a/b/c/g#s/../x",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Some parsers allow the scheme name to be present in a relative URI if it is the same as the base URI scheme. This is considered to be a loophole in prior specifications of partial URI [RFC1630]. Its use should be avoided.",
      "ja": "一部のパーサーでは、ベースURIスキームと同じ場合、スキーム名を相対URIに含めることができます。これは、部分URIの以前の仕様[RFC1630]の抜け穴と見なされます。その使用は避けてください。"
    },
    {
      "indent": 6,
      "text": "http:g        =  http:g           ; for validating parsers\n              |  http://a/b/c/g   ; for backwards compatibility",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D. Embedding the Base URI in HTML documents",
      "ja": "D. HTMLドキュメントにベースURIを埋め込む"
    },
    {
      "indent": 3,
      "text": "It is useful to consider an example of how the base URI of a document can be embedded within the document's content. In this appendix, we describe how documents written in the Hypertext Markup Language (HTML) [RFC1866] can include an embedded base URI. This appendix does not form a part of the URI specification and should not be considered as anything more than a descriptive example.",
      "ja": "ドキュメントのベースURIをドキュメントのコンテンツ内に埋め込む方法の例を検討すると便利です。この付録では、ハイパーテキストマークアップ言語（HTML）[RFC1866]で記述されたドキュメントに埋め込みベースURIを含める方法について説明します。この付録は、URI仕様の一部を構成するものではなく、説明的な例以外のものと見なしてはなりません。"
    },
    {
      "indent": 3,
      "text": "HTML defines a special element \"BASE\" which, when present in the \"HEAD\" portion of a document, signals that the parser should use the BASE element's \"HREF\" attribute as the base URI for resolving any relative URI. The \"HREF\" attribute must be an absolute URI. Note that, in HTML, element and attribute names are case-insensitive. For example:",
      "ja": "HTMLは特別な要素「BASE」を定義します。これは、ドキュメントの「HEAD」部分にある場合、パーサーがBASE要素の「HREF」属性を相対URIを解決するためのベースURIとして使用する必要があることを通知します。 「HREF」属性は絶対URIでなければなりません。 HTMLでは、要素と属性の名前は大文字と小文字が区別されないことに注意してください。例えば："
    },
    {
      "indent": 6,
      "text": "<!doctype html public \"-//IETF//DTD HTML//EN\">\n<HTML><HEAD>\n<TITLE>An example HTML document</TITLE>\n<BASE href=\"http://www.ics.uci.edu/Test/a/b/c\">\n</HEAD><BODY>\n... <A href=\"../x\">a hypertext anchor</A> ...\n</BODY></HTML>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A parser reading the example document should interpret the given relative URI \"../x\" as representing the absolute URI",
      "ja": "例のドキュメントを読むパーサーは、指定された相対URI \"../x\"を絶対URIを表すものとして解釈する必要があります"
    },
    {
      "indent": 6,
      "text": "<http://www.ics.uci.edu/Test/a/x>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "regardless of the context in which the example document was obtained.",
      "ja": "サンプルドキュメントが取得されたコンテキストに関係なく。"
    },
    {
      "indent": 0,
      "text": "E. Recommendations for Delimiting URI in Context",
      "ja": "E.コンテキストでURIを区切るための推奨事項"
    },
    {
      "indent": 3,
      "text": "URI are often transmitted through formats that do not provide a clear context for their interpretation. For example, there are many occasions when URI are included in plain text; examples include text sent in electronic mail, USENET news messages, and, most importantly, printed on paper. In such cases, it is important to be able to delimit the URI from the rest of the text, and in particular from punctuation marks that might be mistaken for part of the URI.",
      "ja": "URIは、解釈のための明確なコンテキストを提供しない形式で送信されることがよくあります。たとえば、URIがプレーンテキストに含まれている場合が多くあります。例としては、電子メールで送信されたテキスト、USENETニュースメッセージ、最も重要なのは紙に印刷されたテキストなどがあります。このような場合、URIを残りのテキストから、特にURIの一部と間違われる可能性がある句読点から区切ることができることが重要です。"
    },
    {
      "indent": 3,
      "text": "In practice, URI are delimited in a variety of ways, but usually\nwithin double-quotes \"http://test.com/\", angle brackets\n<http://test.com/>, or just using whitespace",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "http://test.com/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These wrappers do not form part of the URI.",
      "ja": "これらのラッパーはURIの一部を形成しません。"
    },
    {
      "indent": 3,
      "text": "In the case where a fragment identifier is associated with a URI reference, the fragment would be placed within the brackets as well (separated from the URI with a \"#\" character).",
      "ja": "フラグメント識別子がURI参照に関連付けられている場合、フラグメントも括弧内に配置されます（「＃」文字でURIから分離されます）。"
    },
    {
      "indent": 3,
      "text": "In some cases, extra whitespace (spaces, linebreaks, tabs, etc.) may need to be added to break long URI across lines. The whitespace should be ignored when extracting the URI.",
      "ja": "行間で長いURIを分割するために、余分な空白（スペース、改行、タブなど）を追加する必要がある場合があります。 URIを抽出するときは、空白を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "No whitespace should be introduced after a hyphen (\"-\") character. Because some typesetters and printers may (erroneously) introduce a hyphen at the end of line when breaking a line, the interpreter of a URI containing a line break immediately after a hyphen should ignore all unescaped whitespace around the line break, and should be aware that the hyphen may or may not actually be part of the URI.",
      "ja": "ハイフン（ \"-\"）文字の後に空白を入れてはいけません。一部のタイプセッターおよびプリンターは、行を改行するときに行末にハイフンを（誤って）導入する可能性があるため、ハイフンの直後の改行を含むURIのインタープリターは、改行の周りのエスケープされていない空白をすべて無視し、次のことに注意する必要があります。ハイフンは実際にはURIの一部である場合とそうでない場合があります。"
    },
    {
      "indent": 3,
      "text": "Using <> angle brackets around each URI is especially recommended as a delimiting style for URI that contain whitespace.",
      "ja": "各URIの前後に<>山かっこを使用することは、空白を含むURIの区切りスタイルとして特に推奨されます。"
    },
    {
      "indent": 3,
      "text": "The prefix \"URL:\" (with or without a trailing space) was recommended as a way to used to help distinguish a URL from other bracketed designators, although this is not common in practice.",
      "ja": "接頭辞 \"URL：\"（後続スペースの有無にかかわらず）は、URLを他の括弧で囲まれた指定子と区別するのに役立つ方法として推奨されましたが、これは実際には一般的ではありません。"
    },
    {
      "indent": 3,
      "text": "For robustness, software that accepts user-typed URI should attempt to recognize and strip both delimiters and embedded whitespace.",
      "ja": "堅牢性のために、ユーザーが入力したURIを受け入れるソフトウェアは、区切り文字と埋め込まれた空白の両方を認識して除去する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the text:",
      "ja": "たとえば、テキスト："
    },
    {
      "indent": 6,
      "text": "Yes, Jim, I found it under \"http://www.w3.org/Addressing/\", but you can probably pick it up from <ftp://ds.internic. net/rfc/>. Note the warning in <http://www.ics.uci.edu/pub/ ietf/uri/historical.html#WARNING>.",
      "ja": "はい、ジム、「http://www.w3.org/Addressing/」の下で見つけましたが、おそらく<ftp：//ds.internicから入手できます。 net / rfc />。 <http://www.ics.uci.edu/pub/ ietf / uri / historical.html＃WARNING>の警告に注意してください。"
    },
    {
      "indent": 3,
      "text": "contains the URI references",
      "ja": "URI参照が含まれています"
    },
    {
      "indent": 6,
      "text": "http://www.w3.org/Addressing/\nftp://ds.internic.net/rfc/\nhttp://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "F. Abbreviated URLs",
      "ja": "F.省略されたURL"
    },
    {
      "indent": 3,
      "text": "The URL syntax was designed for unambiguous reference to network resources and extensibility via the URL scheme. However, as URL identification and usage have become commonplace, traditional media (television, radio, newspapers, billboards, etc.) have increasingly used abbreviated URL references. That is, a reference consisting of only the authority and path portions of the identified resource, such as",
      "ja": "URL構文は、URLスキームによるネットワークリソースと拡張性への明確な参照のために設計されました。ただし、URLの識別と使用が一般的になるにつれ、従来のメディア（テレビ、ラジオ、新聞、看板など）で短縮URL参照が使用されるようになりました。つまり、次のように、識別されたリソースの権限部分とパス部分のみで構成される参照"
    },
    {
      "indent": 6,
      "text": "www.w3.org/Addressing/",
      "ja": "ｗっｗ。ｗ３。おｒｇ／あっｄれっしんｇ／"
    },
    {
      "indent": 3,
      "text": "or simply the DNS hostname on its own. Such references are primarily intended for human interpretation rather than machine, with the assumption that context-based heuristics are sufficient to complete the URL (e.g., most hostnames beginning with \"www\" are likely to have a URL prefix of \"http://\"). Although there is no standard set of heuristics for disambiguating abbreviated URL references, many client implementations allow them to be entered by the user and heuristically resolved. It should be noted that such heuristics may change over time, particularly when new URL schemes are introduced.",
      "ja": "または単にそれ自体のDNSホスト名。このような参照は、主にマシンではなく人間による解釈を目的としており、URLを完成させるにはコンテキストベースのヒューリスティックスで十分であると想定しています（たとえば、「www」で始まるほとんどのホスト名には「http：//」のプレフィックスが付いている可能性があります。 ）。省略されたURL参照を明確にするためのヒューリスティックの標準セットはありませんが、多くのクライアント実装では、ユーザーがそれらを入力してヒューリスティックに解決できます。特に新しいURLスキームが導入されると、そのようなヒューリスティックは時間とともに変化する可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since an abbreviated URL has the same syntax as a relative URL path, abbreviated URL references cannot be used in contexts where relative URLs are expected. This limits the use of abbreviated URLs to places where there is no defined base URL, such as dialog boxes and off-line advertisements.",
      "ja": "短縮URLの構文は相対URLパスと同じであるため、短縮URL参照は、相対URLが期待されるコンテキストでは使用できません。これにより、省略されたURLの使用が、ダイアログボックスやオフライン広告など、定義済みのベースURLがない場所に制限されます。"
    },
    {
      "indent": 0,
      "text": "G. Summary of Non-editorial Changes",
      "ja": "G.非編集上の変更の概要"
    },
    {
      "indent": 0,
      "text": "G.1. Additions",
      "section_title": true,
      "ja": "G.1. 追加"
    },
    {
      "indent": 3,
      "text": "Section 4 (URI References) was added to stem the confusion regarding \"what is a URI\" and how to describe fragment identifiers given that they are not part of the URI, but are part of the URI syntax and parsing concerns. In addition, it provides a reference definition for use by other IETF specifications (HTML, HTTP, etc.) that have previously attempted to redefine the URI syntax in order to account for the presence of fragment identifiers in URI references.",
      "ja": "セクション4（URI参照）は、「URIとは」、およびURIの一部ではなく、URI構文と解析の問題の一部である場合にフラグメント識別子を記述する方法に関する混乱を避けるために追加されました。さらに、URI参照内のフラグメント識別子の存在を明らかにするために、以前にURI構文を再定義しようとした他のIETF仕様（HTML、HTTPなど）で使用するための参照定義を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 2.4 was rewritten to clarify a number of misinterpretations and to leave room for fully internationalized URI.",
      "ja": "セクション2.4は、多くの誤解を明確にし、完全に国際化されたURIの余地を残すために書き直されました。"
    },
    {
      "indent": 3,
      "text": "Appendix F on abbreviated URLs was added to describe the shortened references often seen on television and magazine advertisements and explain why they are not used in other contexts.",
      "ja": "短縮URLに関する付録Fが追加され、テレビや雑誌の広告でよく見られる短縮されたリファレンスを説明し、それらが他のコンテキストで使用されない理由を説明します。"
    },
    {
      "indent": 0,
      "text": "G.2. Modifications from both RFC 1738 and RFC 1808",
      "section_title": true,
      "ja": "G.2. RFC 1738とRFC 1808の両方からの変更"
    },
    {
      "indent": 3,
      "text": "Changed to URI syntax instead of just URL.",
      "ja": "URLだけでなくURI構文に変更されました。"
    },
    {
      "indent": 3,
      "text": "Confusion regarding the terms \"character encoding\", the URI \"character set\", and the escaping of characters with %<hex><hex> equivalents has (hopefully) been reduced. Many of the BNF rule names regarding the character sets have been changed to more accurately describe their purpose and to encompass all \"characters\" rather than just US-ASCII octets. Unless otherwise noted here, these modifications do not affect the URI syntax.",
      "ja": "「文字エンコーディング」、URI「文字セット」、および同等の％<hex> <hex>による文字のエスケープに関する混乱は、（うまくいけば）削減されました。文字セットに関するBNFルール名の多くは、目的をより正確に説明し、US-ASCIIオクテットだけでなくすべての「文字」を包含するように変更されました。ここで特に注記がない限り、これらの変更はURI構文に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "Both RFC 1738 and RFC 1808 refer to the \"reserved\" set of characters as if URI-interpreting software were limited to a single set of characters with a reserved purpose (i.e., as meaning something other than the data to which the characters correspond), and that this set was fixed by the URI scheme. However, this has not been true in practice; any character that is interpreted differently when it is escaped is, in effect, reserved. Furthermore, the interpreting engine on a HTTP server is often dependent on the resource, not just the URI scheme. The description of reserved characters has been changed accordingly.",
      "ja": "RFC 1738とRFC 1808は、「予約された」文字セットを、URI解釈ソフトウェアが予約された目的を持つ単一の文字セットに制限されているかのように参照します（つまり、文字が対応するデータ以外のものを意味します）。また、このセットはURIスキームによって修正されました。ただし、これは実際には当てはまりません。エスケープされたときに解釈が異なる文字は、事実上予約されています。さらに、HTTPサーバー上の解釈エンジンは、URIスキームだけでなく、リソースにも依存していることがよくあります。それに応じて予約文字の説明が変更されました。"
    },
    {
      "indent": 3,
      "text": "The plus \"+\", dollar \"$\", and comma \",\" characters have been added to those in the \"reserved\" set, since they are treated as reserved within the query component.",
      "ja": "プラス \"+\"、ドル \"$\"、およびコンマ \"、\"文字は、クエリコンポーネント内で予約済みとして扱われるため、 \"予約済み\"セットの文字に追加されました。"
    },
    {
      "indent": 3,
      "text": "The tilde \"~\" character was added to those in the \"unreserved\" set, since it is extensively used on the Internet in spite of the difficulty to transcribe it with some keyboards.",
      "ja": "チルダ「〜」文字は、「予約されていない」セットの文字に追加されました。これは、一部のキーボードで文字を書き写すことが難しいにもかかわらず、インターネットで広く使用されているためです。"
    },
    {
      "indent": 3,
      "text": "The syntax for URI scheme has been changed to require that all schemes begin with an alpha character.",
      "ja": "URIスキームの構文は、すべてのスキームが英字で始まる必要があるように変更されました。"
    },
    {
      "indent": 3,
      "text": "The \"user:password\" form in the previous BNF was changed to a \"userinfo\" token, and the possibility that it might be \"user:password\" made scheme specific. In particular, the use of passwords in the clear is not even suggested by the syntax.",
      "ja": "以前のBNFの「user：password」フォームが「userinfo」トークンに変更され、「user：password」である可能性があるため、スキームが固有になりました。特に、パスワードを平文で使用することは、構文では提案されていません。"
    },
    {
      "indent": 3,
      "text": "The question-mark \"?\" character was removed from the set of allowed characters for the userinfo in the authority component, since testing showed that many applications treat it as reserved for separating the query component from the rest of the URI.",
      "ja": "疑問符「？」テストでは、多くのアプリケーションがクエリコンポーネントを残りのURIから分離するために予約されているものとして扱うことが判明したため、authorityコンポーネントのuserinfoで許可されている文字のセットから文字が削除されました。"
    },
    {
      "indent": 3,
      "text": "The semicolon \";\" character was added to those stated as being reserved within the authority component, since several new schemes are using it as a separator within userinfo to indicate the type of user authentication.",
      "ja": "セミコロン「;」いくつかの新しいスキームがユーザー認証のタイプを示すためにuserinfo内のセパレーターとして使用しているため、権限コンポーネント内で予約されていると記載されているものに文字が追加されました。"
    },
    {
      "indent": 3,
      "text": "RFC 1738 specified that the path was separated from the authority portion of a URI by a slash. RFC 1808 followed suit, but with a fudge of carrying around the separator as a \"prefix\" in order to describe the parsing algorithm. RFC 1630 never had this problem, since it considered the slash to be part of the path. In writing this specification, it was found to be impossible to accurately describe and retain the difference between the two URI <foo:/bar> and <foo:bar> without either considering the slash to be part of the path (as corresponds to actual practice) or creating a separate component just to hold that slash. We chose the former.",
      "ja": "RFC 1738は、パスがURIの権限部分とスラッシュで区切られていることを規定しています。 RFC 1808も同様に続きましたが、解析アルゴリズムを説明するために、セパレーターを「プレフィックス」として持ち歩くのはややこしくなりました。 RFC 1630は、スラッシュをパスの一部と見なしていたため、この問題が発生することはありませんでした。この仕様を書いているとき、スラッシュをパスの一部と見なすことなく、2つのURI <foo：/ bar>と<foo：bar>の違いを正確に記述して保持することは不可能であることがわかりました（実際の練習）またはそのスラッシュを保持するためだけに別のコンポーネントを作成します。前者を選びました。"
    },
    {
      "indent": 0,
      "text": "G.3. Modifications from RFC 1738",
      "section_title": true,
      "ja": "G.3. RFC 1738からの変更"
    },
    {
      "indent": 3,
      "text": "The definition of specific URL schemes and their scheme-specific syntax and semantics has been moved to separate documents.",
      "ja": "特定のURLスキームの定義とそれらのスキーム固有の構文およびセマンティクスは、個別のドキュメントに移動されました。"
    },
    {
      "indent": 3,
      "text": "The URL host was defined as a fully-qualified domain name. However, many URLs are used without fully-qualified domain names (in contexts for which the full qualification is not necessary), without any host (as in some file URLs), or with a host of \"localhost\".",
      "ja": "URLホストは完全修飾ドメイン名として定義されました。ただし、多くのURLは、完全修飾ドメイン名なし（完全修飾が不要なコンテキスト）、ホストなし（一部のファイルURLなど）、または「localhost」のホストで使用されます。"
    },
    {
      "indent": 3,
      "text": "The URL port is now *digit instead of 1*digit, since systems are expected to handle the case where the \":\" separator between host and port is supplied without a port.",
      "ja": "ホストとポートの間の「：」区切り文字がポートなしで提供されるケースをシステムが処理することが期待されるため、URLポートは1 *桁ではなく*桁になりました。"
    },
    {
      "indent": 3,
      "text": "The recommendations for delimiting URI in context (Appendix E) have been adjusted to reflect current practice.",
      "ja": "コンテキストでURIを区切るための推奨事項（付録E）は、現在の慣行を反映するように調整されています。"
    },
    {
      "indent": 0,
      "text": "G.4. Modifications from RFC 1808",
      "section_title": true,
      "ja": "G.4. RFC 1808からの変更"
    },
    {
      "indent": 3,
      "text": "RFC 1808 (Section 4) defined an empty URL reference (a reference containing nothing aside from the fragment identifier) as being a reference to the base URL. Unfortunately, that definition could be interpreted, upon selection of such a reference, as a new retrieval action on that resource. Since the normal intent of such references is for the user agent to change its view of the current document to the beginning of the specified fragment within that document, not to make an additional request of the resource, a description of how to correctly interpret an empty reference has been added in Section 4.",
      "ja": "RFC 1808（セクション4）は、空のURL参照（フラグメント識別子以外に何も含まない参照）をベースURLへの参照として定義しました。残念ながら、その定義は、そのような参照を選択すると、そのリソースに対する新しい取得アクションとして解釈される可能性があります。このような参照の通常の目的は、ユーザーエージェントが現在のドキュメントのビューをそのドキュメント内の指定されたフラグメントの先頭に変更することであり、リソースの追加リクエストを作成することではないため、空を正しく解釈する方法の説明参照はセクション4に追加されました。"
    },
    {
      "indent": 3,
      "text": "The description of the mythical Base header field has been replaced with a reference to the Content-Location header field defined by MHTML [RFC2110].",
      "ja": "神話的なBaseヘッダーフィールドの説明は、MHTML [RFC2110]で定義されているContent-Locationヘッダーフィールドへの参照に置き換えられました。"
    },
    {
      "indent": 3,
      "text": "RFC 1808 described various schemes as either having or not having the properties of the generic URI syntax. However, the only requirement is that the particular document containing the relative references have a base URI that abides by the generic URI syntax, regardless of the URI scheme, so the associated description has been updated to reflect that.",
      "ja": "RFC 1808は、さまざまなスキームを、汎用URI構文のプロパティを持つか持たないかのいずれかとして説明しました。ただし、唯一の要件は、相対参照を含む特定のドキュメントに、URIスキームに関係なく、一般的なURI構文に従う基本URIがあることです。そのため、関連する説明が更新され、それが反映されています。"
    },
    {
      "indent": 3,
      "text": "The BNF term <net_loc> has been replaced with <authority>, since the latter more accurately describes its use and purpose. Likewise, the authority is no longer restricted to the IP server syntax.",
      "ja": "BNFの用語<net_loc>は、<authority>に置き換えられました。後者は、その使用法と目的をより正確に説明しているためです。同様に、権限はIPサーバー構文に制限されなくなりました。"
    },
    {
      "indent": 3,
      "text": "Extensive testing of current client applications demonstrated that the majority of deployed systems do not use the \";\" character to indicate trailing parameter information, and that the presence of a semicolon in a path segment does not affect the relative parsing of that segment. Therefore, parameters have been removed as a separate component and may now appear in any path segment. Their influence has been removed from the algorithm for resolving a relative URI reference. The resolution examples in Appendix C have been modified to reflect this change.",
      "ja": "現在のクライアントアプリケーションの広範なテストでは、展開されたシステムの大部分が「;」を使用しないことが実証されました。末尾のパラメータ情報を示す文字。パスセグメントにセミコロンが存在しても、そのセグメントの相対的な解析には影響しません。そのため、パラメータは個別のコンポーネントとして削除されており、どのパスセグメントにも表示される可能性があります。それらの影響は、相対URI参照を解決するためのアルゴリズムから削除されました。付録Cの解決例は、この変更を反映するように変更されています。"
    },
    {
      "indent": 3,
      "text": "Implementations are now allowed to work around misformed relative references that are prefixed by the same scheme as the base URI, but only for schemes known to use the <hier_part> syntax.",
      "ja": "<urier_part>構文を使用することがわかっているスキームに対してのみ、ベースURIと同じスキームがプレフィックスとして付けられた誤った形式の相対参照を実装が回避できるようになりました。"
    },
    {
      "indent": 0,
      "text": "H. Full Copyright Statement",
      "ja": "H.完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができます。 、ただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されないいかなる保証も含め、一切の保証を否認します。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。"
    }
  ]
}
