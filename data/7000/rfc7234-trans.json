{
  "title": {
    "text": "RFC 7234 - Hypertext Transfer Protocol (HTTP/1.1): Caching",
    "ja": "RFC 7234 - ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ"
  },
  "number": 7234,
  "created_at": "2020-08-15 15:18:23.631104+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  R. Fielding, Ed.\nRequest for Comments: 7234                                         Adobe\nObsoletes: 2616                                       M. Nottingham, Ed.\nCategory: Standards Track                                         Akamai\nISSN: 2070-1721                                          J. Reschke, Ed.\n                                                              greenbytes\n                                                               June 2014",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Hypertext Transfer Protocol (HTTP/1.1): Caching",
      "ja": "ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散型の協調型ハイパーテキスト情報システム用のステートレスアプリケーションレベルプロトコルです。このドキュメントでは、HTTPキャッシュと、キャッシュの動作を制御したり、キャッシュ可能な応答メッセージを示したりする関連ヘッダーフィールドを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7234.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7234で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2014 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。この素材の一部で著作権を管理している人が、IETFトラストにそのような素材の変更を許可する権利を付与していない可能性がありますIETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得せずに、このドキュメントをIETF標準プロセス外で変更したり、その派生物をIETF標準プロセス外で作成したりすることはできません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Conformance and Error Handling .............................4\n   1.2. Syntax Notation ............................................4\n        1.2.1. Delta Seconds .......................................5\n2. Overview of Cache Operation .....................................5\n3. Storing Responses in Caches .....................................6\n   3.1. Storing Incomplete Responses ...............................7\n   3.2. Storing Responses to Authenticated Requests ................7\n   3.3. Combining Partial Content ..................................8\n4. Constructing Responses from Caches ..............................8\n   4.1. Calculating Secondary Keys with Vary .......................9\n   4.2. Freshness .................................................11\n        4.2.1. Calculating Freshness Lifetime .....................12\n        4.2.2. Calculating Heuristic Freshness ....................13\n        4.2.3. Calculating Age ....................................13\n        4.2.4. Serving Stale Responses ............................15\n   4.3. Validation ................................................16\n        4.3.1. Sending a Validation Request .......................16\n        4.3.2. Handling a Received Validation Request .............16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        4.3.3. Handling a Validation Response .....................18\n        4.3.4. Freshening Stored Responses upon Validation ........18\n        4.3.5. Freshening Responses via HEAD ......................19\n   4.4. Invalidation ..............................................20\n5. Header Field Definitions .......................................21\n   5.1. Age .......................................................21\n   5.2. Cache-Control .............................................21\n        5.2.1. Request Cache-Control Directives ...................22\n        5.2.2. Response Cache-Control Directives ..................24\n        5.2.3. Cache Control Extensions ...........................27\n   5.3. Expires ...................................................28\n   5.4. Pragma ....................................................29\n   5.5. Warning ...................................................29\n        5.5.1. Warning: 110 - \"Response is Stale\" .................31\n        5.5.2. Warning: 111 - \"Revalidation Failed\" ...............31\n        5.5.3. Warning: 112 - \"Disconnected Operation\" ............31\n        5.5.4. Warning: 113 - \"Heuristic Expiration\" ..............31\n        5.5.5. Warning: 199 - \"Miscellaneous Warning\" .............32\n        5.5.6. Warning: 214 - \"Transformation Applied\" ............32\n        5.5.7. Warning: 299 - \"Miscellaneous Persistent Warning\" ..32\n6. History Lists ..................................................32\n7. IANA Considerations ............................................32\n   7.1. Cache Directive Registry ..................................32\n        7.1.1. Procedure ..........................................32\n        7.1.2. Considerations for New Cache Control Directives ....33\n        7.1.3. Registrations ......................................33\n   7.2. Warn Code Registry ........................................34\n        7.2.1. Procedure ..........................................34\n        7.2.2. Registrations ......................................34\n   7.3. Header Field Registration .................................34\n8. Security Considerations ........................................35\n9. Acknowledgments ................................................36\n10. References ....................................................36\n   10.1. Normative References .....................................36\n   10.2. Informative References ...................................37\nAppendix A. Changes from RFC 2616 .................................38\nAppendix B. Imported ABNF .........................................39\nAppendix C. Collected ABNF ........................................39\nIndex .............................................................41",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. This document defines aspects of HTTP/1.1 related to caching and reusing response messages.",
      "ja": "HTTPは通常、応答キャッシュを使用することでパフォーマンスを向上できる分散情報システムに使用されます。このドキュメントでは、応答メッセージのキャッシュと再利用に関連するHTTP / 1.1の側面を定義します。"
    },
    {
      "indent": 3,
      "text": "An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server that is acting as a tunnel.",
      "ja": "HTTPキャッシュは、応答メッセージのローカルストアであり、その中のメッセージの格納、取得、および削除を制御するサブシステムです。キャッシュは、将来の同等の要求での応答時間とネットワーク帯域幅の消費を削減するために、キャッシュ可能な応答を格納します。トンネルとして機能しているサーバーはキャッシュを使用できませんが、クライアントまたはサーバーはキャッシュを使用できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "A shared cache is a cache that stores responses to be reused by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary. A private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.",
      "ja": "共有キャッシュは、複数のユーザーが再利用する応答を格納するキャッシュです。共有キャッシュは通常（常にではありませんが）仲介者の一部として配備されます。対照的に、プライベートキャッシュは1人のユーザー専用です。多くの場合、ユーザーエージェントのコンポーネントとして展開されます。"
    },
    {
      "indent": 3,
      "text": "The goal of caching in HTTP/1.1 is to significantly improve performance by reusing a prior response message to satisfy a current request. A stored response is considered \"fresh\", as defined in Section 4.2, if the response can be reused without \"validation\" (checking with the origin server to see if the cached response remains valid for this request). A fresh response can therefore reduce both latency and network overhead each time it is reused. When a cached response is not fresh, it might still be reusable if it can be freshened by validation (Section 4.3) or if the origin is unavailable (Section 4.2.4).",
      "ja": "HTTP / 1.1でのキャッシングの目的は、現在の要求を満たすために以前の応答メッセージを再利用することにより、パフォーマンスを大幅に改善することです。保存された応答は、「検証」なしで応答を再利用できる場合（キャッシュされた応答がこの要求に対して有効かどうかを確認するためにオリジンサーバーに確認する）、セクション4.2で定義されているように「新鮮」と見なされます。したがって、新しい応答は、再利用されるたびに、待ち時間とネットワークオーバーヘッドの両方を削減できます。キャッシュされた応答がフレッシュでない場合でも、検証によって更新できる場合（セクション4.3）、または発信元が使用できない場合（セクション4.2.4）は、再利用できる可能性があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Conformance and Error Handling",
      "section_title": true,
      "ja": "1.1. 適合性とエラー処理"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].",
      "ja": "エラー処理に関する適合基準と考慮事項は、[RFC7230]のセクション2.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Syntax Notation",
      "section_title": true,
      "ja": "1.2. 構文表記"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7 of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix B describes rules imported from other documents. Appendix C shows the collected grammar with all list operators expanded to standard ABNF notation.",
      "ja": "この仕様では、[RFC7230]のセクション7で定義されているリスト拡張子付きの[RFC5234]の拡張バッカスナウア記法（ABNF）表記を使用して、「＃」演算子を使用したコンマ区切りリストのコンパクトな定義を可能にしています（ 「*」演算子が繰り返しを示す方法）。付録Bでは、他のドキュメントからインポートされたルールについて説明します。付録Cは、すべてのリスト演算子が標準のABNF表記に拡張された、収集された文法を示しています。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Delta Seconds",
      "section_title": true,
      "ja": "1.2.1. デルタ秒"
    },
    {
      "indent": 3,
      "text": "The delta-seconds rule specifies a non-negative integer, representing time in seconds.",
      "ja": "delta-secondsルールは、秒数で時間を表す負でない整数を指定します。"
    },
    {
      "indent": 5,
      "text": "delta-seconds = 1*DIGIT",
      "ja": "デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "A recipient parsing a delta-seconds value and converting it to binary form ought to use an arithmetic type of at least 31 bits of non-negative integer range. If a cache receives a delta-seconds value greater than the greatest integer it can represent, or if any of its subsequent calculations overflows, the cache MUST consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.",
      "ja": "デルタ秒の値を解析してバイナリ形式に変換する受信者は、少なくとも31ビットの非負の整数範囲の算術型を使用する必要があります。キャッシュが表すことができる最大の整数より大きいデルタ秒の値を受け取った場合、または後続の計算のいずれかがオーバーフローした場合、キャッシュは値を2147483648（2 ^ 31）または都合のよい最大の正の整数のいずれかと見なさなければなりません（MUST）。表す。"
    },
    {
      "indent": 6,
      "text": "Note: The value 2147483648 is here for historical reasons, effectively represents infinity (over 68 years), and does not need to be stored in binary form; an implementation could produce it as a canned string if any overflow occurs, even if the calculations are performed with an arithmetic type incapable of directly representing that number. What matters here is that an overflow be detected and not treated as a negative value in later calculations.",
      "ja": "注：値2147483648は歴史的な理由でここにあり、事実上無限（68年以上）を表し、バイナリ形式で格納する必要はありません。実装は、オーバーフローが発生した場合、その数値を直接表すことができない算術型で計算が実行された場合でも、これを既定の文字列として生成できます。ここで重要なのは、オーバーフローが検出され、後の計算で負の値として扱われないことです。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Cache Operation",
      "section_title": true,
      "ja": "2. キャッシュ操作の概要"
    },
    {
      "indent": 3,
      "text": "Proper cache operation preserves the semantics of HTTP transfers ([RFC7231]) while eliminating the transfer of information already held in the cache. Although caching is an entirely OPTIONAL feature of HTTP, it can be assumed that reusing a cached response is desirable and that such reuse is the default behavior when no requirement or local configuration prevents it. Therefore, HTTP cache requirements are focused on preventing a cache from either storing a non-reusable response or reusing a stored response inappropriately, rather than mandating that caches always store and reuse particular responses.",
      "ja": "適切なキャッシュ操作は、HTTP転送（[RFC7231]）のセマンティクスを保持しながら、すでにキャッシュに保持されている情報の転送を排除します。キャッシングはHTTPの完全にオプションの機能ですが、キャッシュされた応答の再利用が望ましいこと、および要件やローカル構成がそれを妨げない場合のそのような再利用がデフォルトの動作であると想定できます。したがって、HTTPキャッシュの要件は、キャッシュが特定の応答を常に格納して再利用することを強制するのではなく、キャッシュが再利用できない応答を格納したり、格納された応答を不適切に再利用したりしないようにすることに重点を置いています。"
    },
    {
      "indent": 3,
      "text": "Each cache entry consists of a cache key and one or more HTTP responses corresponding to prior requests that used the same key. The most common form of cache entry is a successful result of a retrieval request: i.e., a 200 (OK) response to a GET request, which contains a representation of the resource identified by the request target (Section 4.3.1 of [RFC7231]). However, it is also possible to cache permanent redirects, negative results (e.g., 404 (Not Found)), incomplete results (e.g., 206 (Partial Content)), and responses to methods other than GET if the method's definition allows such caching and defines something suitable for use as a cache key.",
      "ja": "各キャッシュエントリは、キャッシュキーと、同じキーを使用した以前のリクエストに対応する1つ以上のHTTP応答で構成されます。キャッシュエントリの最も一般的な形式は、取得リクエストの成功結果です。つまり、GETリクエストに対する200（OK）レスポンスで、リクエストターゲットによって識別されるリソースの表現が含まれています（[RFC7231]のセクション4.3.1）。 ）。ただし、永続的なリダイレクト、否定的な結果（404（Not Found）など）、不完全な結果（206（Partial Content）など）、およびGET以外のメソッドへの応答をキャッシュすることもできます。キャッシュキーとして使用するのに適したものを定義します。"
    },
    {
      "indent": 3,
      "text": "The primary cache key consists of the request method and target URI. However, since HTTP caches in common use today are typically limited to caching responses to GET, many caches simply decline other methods and use only the URI as the primary cache key.",
      "ja": "プライマリキャッシュキーは、リクエストメソッドとターゲットURIで構成されます。ただし、現在一般的に使用されているHTTPキャッシュは通常、GETへの応答のキャッシュに限定されているため、多くのキャッシュは他のメソッドを拒否し、URIのみをプライマリキャッシュキーとして使用します。"
    },
    {
      "indent": 3,
      "text": "If a request target is subject to content negotiation, its cache entry might consist of multiple stored responses, each differentiated by a secondary key for the values of the original request's selecting header fields (Section 4.1).",
      "ja": "リクエストターゲットがコンテンツネゴシエーションの対象である場合、そのキャッシュエントリは複数の保存されたレスポンスで構成され、それぞれが元のリクエストの選択ヘッダーフィールドの値のセカンダリキーで区別されます（セクション4.1）。"
    },
    {
      "indent": 0,
      "text": "3. Storing Responses in Caches",
      "section_title": true,
      "ja": "3. キャッシュへの応答の保存"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT store a response to any request, unless:",
      "ja": "次の場合を除き、キャッシュはリクエストへの応答を保存してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o The request method is understood by the cache and defined as being cacheable, and",
      "ja": "o リクエストメソッドはキャッシュによって理解され、キャッシュ可能として定義されます。"
    },
    {
      "indent": 3,
      "text": "o the response status code is understood by the cache, and",
      "ja": "o 応答ステータスコードはキャッシュによって認識されます。"
    },
    {
      "indent": 3,
      "text": "o the \"no-store\" cache directive (see Section 5.2) does not appear in request or response header fields, and",
      "ja": "o 「ストアなし」キャッシュディレクティブ（セクション5.2を参照）が要求または応答ヘッダーフィールドに表示されない。"
    },
    {
      "indent": 3,
      "text": "o the \"private\" response directive (see Section 5.2.2.6) does not appear in the response, if the cache is shared, and",
      "ja": "o キャッシュが共有されている場合、「プライベート」応答ディレクティブ（セクション5.2.2.6を参照）は応答に表示されません。"
    },
    {
      "indent": 3,
      "text": "o the Authorization header field (see Section 4.2 of [RFC7235]) does not appear in the request, if the cache is shared, unless the response explicitly allows it (see Section 3.2), and",
      "ja": "o キャッシュが共有されている場合、レスポンスで明示的に許可されていない限り（セクション3.2を参照）、Authorizationヘッダーフィールド（[RFC7235]のセクション4.2を参照）はリクエストに表示されません。"
    },
    {
      "indent": 3,
      "text": "o the response either:",
      "ja": "o 応答のいずれか："
    },
    {
      "indent": 6,
      "text": "* contains an Expires header field (see Section 5.3), or",
      "ja": "* Expiresヘッダーフィールドが含まれている（セクション5.3を参照）、または"
    },
    {
      "indent": 6,
      "text": "* contains a max-age response directive (see Section 5.2.2.8), or",
      "ja": "* max-age応答ディレクティブが含まれている（セクション5.2.2.8を参照）、または"
    },
    {
      "indent": 6,
      "text": "* contains a s-maxage response directive (see Section 5.2.2.9) and the cache is shared, or",
      "ja": "* s-maxage応答ディレクティブが含まれ（セクション5.2.2.9を参照）、キャッシュが共有されている、または"
    },
    {
      "indent": 6,
      "text": "* contains a Cache Control Extension (see Section 5.2.3) that allows it to be cached, or",
      "ja": "* キャッシュできるようにするキャッシュ制御拡張機能（セクション5.2.3を参照）が含まれている、または"
    },
    {
      "indent": 6,
      "text": "* has a status code that is defined as cacheable by default (see Section 4.2.2), or",
      "ja": "* デフォルトでキャッシュ可能として定義されているステータスコード（セクション4.2.2を参照）、または"
    },
    {
      "indent": 6,
      "text": "* contains a public response directive (see Section 5.2.2.5).",
      "ja": "* 公開応答ディレクティブが含まれています（セクション5.2.2.5を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.",
      "ja": "上記の要件はすべて、キャッシュ制御拡張機能によって上書きされる可能性があることに注意してください。セクション5.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "In this context, a cache has \"understood\" a request method or a response status code if it recognizes it and implements all specified caching-related behavior.",
      "ja": "このコンテキストでは、キャッシュがリクエストメソッドまたは応答ステータスコードを認識し、指定されたすべてのキャッシュ関連の動作を実装している場合、キャッシュはそれを \"理解\"しています。"
    },
    {
      "indent": 3,
      "text": "Note that, in normal operation, some caches will not store a response that has neither a cache validator nor an explicit expiration time, as such responses are not usually useful to store. However, caches are not prohibited from storing such responses.",
      "ja": "通常の操作では、一部のキャッシュはキャッシュバリデーターも明示的な有効期限も持たない応答を保存しないことに注意してください。そのような応答は通常は保存に役立ちません。ただし、キャッシュはそのような応答の格納を禁止されていません。"
    },
    {
      "indent": 0,
      "text": "3.1. Storing Incomplete Responses",
      "section_title": true,
      "ja": "3.1. 不完全な応答の保存"
    },
    {
      "indent": 3,
      "text": "A response message is considered complete when all of the octets indicated by the message framing ([RFC7230]) are received prior to the connection being closed. If the request method is GET, the response status code is 200 (OK), and the entire response header section has been received, a cache MAY store an incomplete response message body if the cache entry is recorded as incomplete. Likewise, a 206 (Partial Content) response MAY be stored as if it were an incomplete 200 (OK) cache entry. However, a cache MUST NOT store incomplete or partial-content responses if it does not support the Range and Content-Range header fields or if it does not understand the range units used in those fields.",
      "ja": "接続が閉じられる前に、メッセージフレーミング（[RFC7230]）によって示されるすべてのオクテットが受信されると、応答メッセージは完了したと見なされます。リクエストメソッドがGETで、レスポンスステータスコードが200（OK）で、レスポンスヘッダーセクション全体が受信された場合、キャッシュエントリが不完全であると記録されていれば、キャッシュは不完全なレスポンスメッセージ本文を格納できます。同様に、206（Partial Content）レスポンスは、不完全な200（OK）キャッシュエントリであるかのように格納できます（MAY）。ただし、RangeおよびContent-Rangeヘッダーフィールドをサポートしていない場合、またはこれらのフィールドで使用されている範囲の単位を理解していない場合、キャッシュは不完全または部分的なコンテンツ応答を格納してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "A cache MAY complete a stored incomplete response by making a subsequent range request ([RFC7233]) and combining the successful response with the stored entry, as defined in Section 3.3. A cache MUST NOT use an incomplete response to answer requests unless the response has been made complete or the request is partial and specifies a range that is wholly within the incomplete response. A cache MUST NOT send a partial response to a client without explicitly marking it as such using the 206 (Partial Content) status code.",
      "ja": "キャッシュは、セクション3.3で定義されているように、後続の範囲リクエスト（[RFC7233]）を行い、成功した応答と格納されたエントリを組み合わせることにより、格納された不完全な応答を完了できます（MAY）。キャッシュが不完全な応答を使用してリクエストに応答することはできません。ただし、応答が完全に行われた場合、またはリクエストが部分的であり、不完全な応答内に完全に含まれる範囲を指定している場合を除きます。キャッシュは、206（Partial Content）ステータスコードを使用して明示的にマークしない限り、クライアントに部分応答を送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "3.2. Storing Responses to Authenticated Requests",
      "section_title": true,
      "ja": "3.2. 認証済みリクエストへの応答の保存"
    },
    {
      "indent": 3,
      "text": "A shared cache MUST NOT use a cached response to a request with an Authorization header field (Section 4.2 of [RFC7235]) to satisfy any subsequent request unless a cache directive that allows such responses to be stored is present in the response.",
      "ja": "共有キャッシュは、Authorizationヘッダーフィールド（[RFC7235]のセクション4.2）を含むリクエストへのキャッシュされた応答を使用して、そのような応答の格納を許可するキャッシュディレクティブが応答に存在しない限り、後続の要求を満たすことはできません。"
    },
    {
      "indent": 3,
      "text": "In this specification, the following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.",
      "ja": "この仕様では、次のCache-Control応答ディレクティブ（セクション5.2.2）がそのような効果を持っています：must-revalidate、public、およびs-maxage。"
    },
    {
      "indent": 3,
      "text": "Note that cached responses that contain the \"must-revalidate\" and/or \"s-maxage\" response directives are not allowed to be served stale (Section 4.2.4) by shared caches. In particular, a response with either \"max-age=0, must-revalidate\" or \"s-maxage=0\" cannot be used to satisfy a subsequent request without revalidating it on the origin server.",
      "ja": "「must-revalidate」または「s-maxage」応答ディレクティブを含むキャッシュされた応答は、共有キャッシュによる古い状態（セクション4.2.4）での提供が許可されないことに注意してください。特に、「max-age = 0、must-revalidate」または「s-maxage = 0」のいずれかの応答は、オリジンサーバーで再検証しない限り、後続の要求を満たすために使用できません。"
    },
    {
      "indent": 0,
      "text": "3.3. Combining Partial Content",
      "section_title": true,
      "ja": "3.3. 部分的なコンテンツの結合"
    },
    {
      "indent": 3,
      "text": "A response might transfer only a partial representation if the connection closed prematurely or if the request used one or more Range specifiers ([RFC7233]). After several such transfers, a cache might have received several ranges of the same representation. A cache MAY combine these ranges into a single stored response, and reuse that response to satisfy later requests, if they all share the same strong validator and the cache complies with the client requirements in Section 4.3 of [RFC7233].",
      "ja": "接続が時期尚早に閉じられた場合、または要求が1つ以上の範囲指定子（[RFC7233]）を使用した場合、応答は部分的な表現のみを転送する可能性があります。このような転送を数回行った後、キャッシュは同じ表現の複数の範囲を受け取った可能性があります。すべてのキャッシュが同じ強力なバリデーターを共有し、キャッシュが[RFC7233]のセクション4.3のクライアント要件に準拠している場合、キャッシュはこれらの範囲を1つの格納された応答に結合し、その後の要求を満たすためにその応答を再利用できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "When combining the new response with one or more stored responses, a cache MUST:",
      "ja": "新しい応答を1つ以上の格納された応答と組み合わせる場合、キャッシュは次の条件を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "o 保存されている応答のwarn-code 1xxを持つ警告ヘッダーフィールドを削除します（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "o 保存された応答の警告ヘッダーフィールドをwarn-code 2xxで保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.",
      "ja": "o Content-Rangeとは別に、新しい応答で提供される他のヘッダーフィールドを使用して、格納されている応答の対応するヘッダーフィールドのすべてのインスタンスを置き換えます。"
    },
    {
      "indent": 0,
      "text": "4. Constructing Responses from Caches",
      "section_title": true,
      "ja": "4. キャッシュからの応答の作成"
    },
    {
      "indent": 3,
      "text": "When presented with a request, a cache MUST NOT reuse a stored response, unless:",
      "ja": "リクエストが提示された場合、以下の場合を除いて、キャッシュは保存されたレスポンスを再利用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o The presented effective request URI (Section 5.5 of [RFC7230]) and that of the stored response match, and",
      "ja": "o 提示された有効なリクエストURI（[RFC7230]のセクション5.5）と保存されている応答が一致する"
    },
    {
      "indent": 3,
      "text": "o the request method associated with the stored response allows it to be used for the presented request, and",
      "ja": "o 保存された応答に関連付けられた要求メソッドは、提示された要求に使用できるようにします。"
    },
    {
      "indent": 3,
      "text": "o selecting header fields nominated by the stored response (if any) match those presented (see Section 4.1), and",
      "ja": "o 保存された応答（存在する場合）によって指定されたヘッダーフィールドを選択すると、提示されたものと一致します（セクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive (Section 5.2.1), unless the stored response is successfully validated (Section 4.3), and",
      "ja": "o 保存された応答が正常に検証されない限り（セクション4.3）、提示されたリクエストには、キャッシュなしプラグマ（セクション5.4）も、キャッシュなしキャッシュディレクティブ（セクション5.2.1）も含まれません。"
    },
    {
      "indent": 3,
      "text": "o the stored response does not contain the no-cache cache directive (Section 5.2.2.2), unless it is successfully validated (Section 4.3), and",
      "ja": "o 正常に検証されない限り（セクション4.3）、保存された応答にはno-cache cacheディレクティブが含まれません（セクション5.2.2.2）。"
    },
    {
      "indent": 3,
      "text": "o the stored response is either:",
      "ja": "o 保存された応答は次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "* fresh (see Section 4.2), or",
      "ja": "* 新鮮（セクション4.2を参照）、または"
    },
    {
      "indent": 6,
      "text": "* allowed to be served stale (see Section 4.2.4), or",
      "ja": "* 失効したサービスを提供することが許可されている（セクション4.2.4を参照）、または"
    },
    {
      "indent": 6,
      "text": "* successfully validated (see Section 4.3).",
      "ja": "* 検証に成功しました（セクション4.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.",
      "ja": "上記の要件はすべて、キャッシュ制御拡張機能によって上書きされる可能性があることに注意してください。セクション5.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a stored response is used to satisfy a request without validation, a cache MUST generate an Age header field (Section 5.1), replacing any present in the response with a value equal to the stored response's current_age; see Section 4.2.3.",
      "ja": "保存された応答が検証なしで要求を満たすために使用される場合、キャッシュはAgeヘッダーフィールド（セクション5.1）を生成し（MUST）、応答に存在するものをすべて、保存された応答のcurrent_ageと等しい値で置き換えます。セクション4.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "A cache MUST write through requests with methods that are unsafe (Section 4.2.1 of [RFC7231]) to the origin server; i.e., a cache is not allowed to generate a reply to such a request before having forwarded the request and having received a corresponding response.",
      "ja": "キャッシュは、安全でないメソッド（[RFC7231]のセクション4.2.1）を使用して、リクエストを介してオリジンサーバーに書き込む必要があります。つまり、要求を転送して対応する応答を受信する前に、キャッシュがそのような要求に対する応答を生成することは許可されていません。"
    },
    {
      "indent": 3,
      "text": "Also, note that unsafe requests might invalidate already-stored responses; see Section 4.4.",
      "ja": "また、安全でないリクエストは、すでに保存されているレスポンスを無効にする可能性があることに注意してください。セクション4.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "When more than one suitable response is stored, a cache MUST use the most recent response (as determined by the Date header field). It can also forward the request with \"Cache-Control: max-age=0\" or \"Cache-Control: no-cache\" to disambiguate which response to use.",
      "ja": "複数の適切な応答が格納されている場合、キャッシュは最新の応答を使用する必要があります（日付ヘッダーフィールドによって決定されます）。また、「Cache-Control：max-age = 0」または「Cache-Control：no-cache」を使用してリクエストを転送し、使用する応答を明確にすることもできます。"
    },
    {
      "indent": 3,
      "text": "A cache that does not have a clock available MUST NOT use stored responses without revalidating them upon every use.",
      "ja": "使用可能なクロックがないキャッシュは、使用するたびに再検証せずに、格納された応答を使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "4.1. Calculating Secondary Keys with Vary",
      "section_title": true,
      "ja": "4.1. Varyを使用したセカンダリキーの計算"
    },
    {
      "indent": 3,
      "text": "When a cache receives a request that can be satisfied by a stored response that has a Vary header field (Section 7.1.4 of [RFC7231]), it MUST NOT use that response unless all of the selecting header fields nominated by the Vary header field match in both the original request (i.e., that associated with the stored response), and the presented request.",
      "ja": "キャッシュが、Varyヘッダーフィールド（[RFC7231]のセクション7.1.4）を持つ保存された応答で満たすことができる要求を受信した場合、Varyヘッダーフィールドによって指定されたすべての選択ヘッダーフィールドがない限り、その応答を使用してはなりません（MUST NOT）。元の要求（つまり、格納されている応答に関連付けられている要求）と提示された要求の両方で一致します。"
    },
    {
      "indent": 3,
      "text": "The selecting header fields from two requests are defined to match if and only if those in the first request can be transformed to those in the second request by applying any of the following:",
      "ja": "2つの要求からの選択ヘッダーフィールドは、次のいずれかを適用することにより、最初の要求のヘッダーフィールドを2番目の要求のフィールドに変換できる場合にのみ一致するように定義されます。"
    },
    {
      "indent": 3,
      "text": "o adding or removing whitespace, where allowed in the header field's syntax",
      "ja": "o ヘッダーフィールドの構文で許可されている場合、空白の追加または削除"
    },
    {
      "indent": 3,
      "text": "o combining multiple header fields with the same field name (see Section 3.2 of [RFC7230])",
      "ja": "o 複数のヘッダーフィールドを同じフィールド名で組み合わせる（[RFC7230]のセクション3.2を参照）"
    },
    {
      "indent": 3,
      "text": "o normalizing both header field values in a way that is known to have identical semantics, according to the header field's specification (e.g., reordering field values when order is not significant; case-normalization, where values are defined to be case-insensitive)",
      "ja": "o ヘッダーフィールドの仕様に従って、両方のヘッダーフィールド値を同一のセマンティクスを持つことがわかっている方法で正規化します（たとえば、順序が重要でない場合のフィールド値の並べ替え、大文字と小文字を区別しないように値が定義されている場合の正規化）"
    },
    {
      "indent": 3,
      "text": "If (after any normalization that might take place) a header field is absent from a request, it can only match another request if it is also absent there.",
      "ja": "（行われる可能性のある正規化の後で）ヘッダーフィールドがリクエストに存在しない場合、そこにも存在しない場合にのみ、別のリクエストと一致できます。"
    },
    {
      "indent": 3,
      "text": "A Vary header field-value of \"*\" always fails to match.",
      "ja": "「*」のVaryヘッダーフィールド値は常に一致しません。"
    },
    {
      "indent": 3,
      "text": "The stored response with matching selecting header fields is known as the selected response.",
      "ja": "一致する選択ヘッダーフィールドを持つ保存された応答は、選択された応答と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "If multiple selected responses are available (potentially including responses without a Vary header field), the cache will need to choose one to use. When a selecting header field has a known mechanism for doing so (e.g., qvalues on Accept and similar request header fields), that mechanism MAY be used to select preferred responses; of the remainder, the most recent response (as determined by the Date header field) is used, as per Section 4.",
      "ja": "選択された複数の応答が使用可能な場合（Varyヘッダーフィールドのない応答を含む可能性があります）、キャッシュは使用するものを選択する必要があります。選択ヘッダーフィールドにそのための既知のメカニズム（たとえば、Acceptのqvaluesおよび同様のリクエストヘッダーフィールド）がある場合、そのメカニズムを使用して優先応答を選択できます。残りのセクションでは、セクション4に従って、最新の応答（Dateヘッダーフィールドによって決定される）が使用されます。"
    },
    {
      "indent": 3,
      "text": "If no selected response is available, the cache cannot satisfy the presented request. Typically, it is forwarded to the origin server in a (possibly conditional; see Section 4.3) request.",
      "ja": "選択した応答がない場合、キャッシュは提示された要求を満たすことができません。通常、これは（おそらく条件付き。セクション4.3を参照）要求でオリジンサーバーに転送されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Freshness",
      "section_title": true,
      "ja": "4.2. 鮮度"
    },
    {
      "indent": 3,
      "text": "A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.",
      "ja": "フレッシュレスポンスとは、年齢がまだフレッシュネスライフタイムを超えていないレスポンスです。逆に、古くなった応答は、それが持っている応答です。"
    },
    {
      "indent": 3,
      "text": "A response's freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.",
      "ja": "応答のフレッシュネスライフタイムは、元のサーバーによる応答の生成から有効期限までの時間です。明示的な有効期限は、オリジンサーバーが、保存された応答がそれ以上の検証なしにキャッシュで使用できなくなることを意図する時間です。一方、ヒューリスティックな有効期限は、明示的な有効期限がない場合にキャッシュによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "A response's age is the time that has passed since it was generated by, or successfully validated with, the origin server.",
      "ja": "応答の経過時間は、元のサーバーによって生成された、または正常に検証されてから経過した時間です。"
    },
    {
      "indent": 3,
      "text": "When a response is \"fresh\" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.",
      "ja": "応答がキャッシュ内で「新鮮」な場合、それを使用して、オリジンサーバーに接続せずに後続の要求を満たすことができるため、効率が向上します。"
    },
    {
      "indent": 3,
      "text": "The primary mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using either the Expires header field (Section 5.3) or the max-age response directive (Section 5.2.2.8). Generally, origin servers will assign future explicit expiration times to responses in the belief that the representation is not likely to change in a semantically significant way before the expiration time is reached.",
      "ja": "鮮度を判断するための主なメカニズムは、元のサーバーがExpiresヘッダーフィールド（セクション5.3）またはmax-age応答ディレクティブ（セクション5.2.2.8）を使用して、将来の明示的な有効期限を提供することです。一般に、オリジンサーバーは、有効期限に達する前に表現が意味的に重要な方法で変更される可能性は低いと考えて、将来の明示的な有効期限を応答に割り当てます。"
    },
    {
      "indent": 3,
      "text": "If an origin server wishes to force a cache to validate every request, it can assign an explicit expiration time in the past to indicate that the response is already stale. Compliant caches will normally validate a stale cached response before reusing it for subsequent requests (see Section 4.2.4).",
      "ja": "オリジンサーバーがすべてのリクエストをキャッシュで検証するように強制したい場合は、過去の有効期限を明示的に割り当てて、応答がすでに古くなっていることを示すことができます。準拠キャッシュは通常、後続のリクエストに再利用する前に、古いキャッシュされた応答を検証します（セクション4.2.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Since origin servers do not always provide explicit expiration times, caches are also allowed to use a heuristic to determine an expiration time under certain circumstances (see Section 4.2.2).",
      "ja": "オリジンサーバーは常に明示的な有効期限を提供するわけではないため、キャッシュは特定の状況で有効期限を決定するためにヒューリスティックを使用することもできます（セクション4.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The calculation to determine if a response is fresh is:",
      "ja": "応答が新鮮かどうかを判断する計算は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "response_is_fresh = (freshness_lifetime > current_age)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "freshness_lifetime is defined in Section 4.2.1; current_age is defined in Section 4.2.3.",
      "ja": "freshness_lifetimeはセクション4.2.1で定義されています。 current_ageはセクション4.2.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Clients can send the max-age or min-fresh cache directives in a request to constrain or relax freshness calculations for the corresponding response (Section 5.2.1).",
      "ja": "クライアントは、リクエストでmax-ageまたはmin-freshキャッシュディレクティブを送信して、対応する応答のフレッシュネス計算を制約または緩和できます（セクション5.2.1）。"
    },
    {
      "indent": 3,
      "text": "When calculating freshness, to avoid common problems in date parsing:",
      "ja": "鮮度を計算するとき、日付の解析における一般的な問題を回避するには："
    },
    {
      "indent": 3,
      "text": "o Although all date formats are specified to be case-sensitive, a cache recipient SHOULD match day, week, and time-zone names case-insensitively.",
      "ja": "o すべての日付形式は大文字と小文字を区別するように指定されていますが、キャッシュの受信者は、日、週、およびタイムゾーンの名前を大文字と小文字を区別せずに一致させる必要があります。"
    },
    {
      "indent": 3,
      "text": "o If a cache recipient's internal implementation of time has less resolution than the value of an HTTP-date, the recipient MUST internally represent a parsed Expires date as the nearest time equal to or earlier than the received value.",
      "ja": "o キャッシュ受信者の時間の内部実装がHTTP-dateの値よりも解像度が低い場合、受信者は解析されたExpires日付を、受信した値と同じかそれよりも前の最も近い時間として内部的に表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A cache recipient MUST NOT allow local time zones to influence the calculation or comparison of an age or expiration time.",
      "ja": "o キャッシュの受信者は、ローカルタイムゾーンが経過時間または有効期限の計算または比較に影響を与えることを許可してはなりません。"
    },
    {
      "indent": 3,
      "text": "o A cache recipient SHOULD consider a date with a zone abbreviation other than GMT or UTC to be invalid for calculating expiration.",
      "ja": "o キャッシュの受信者は、GMTまたはUTC以外のゾーン省略形の日付を有効期限の計算に無効であると見なすべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note that freshness applies only to cache operation; it cannot be used to force a user agent to refresh its display or reload a resource. See Section 6 for an explanation of the difference between caches and history mechanisms.",
      "ja": "鮮度はキャッシュ操作にのみ適用されることに注意してください。ユーザーエージェントに表示を強制的に更新したり、リソースを再読み込みしたりするために使用することはできません。キャッシュと履歴メカニズムの違いについては、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Calculating Freshness Lifetime",
      "section_title": true,
      "ja": "4.2.1. 鮮度寿命の計算"
    },
    {
      "indent": 3,
      "text": "A cache can calculate the freshness lifetime (denoted as freshness_lifetime) of a response by using the first match of the following:",
      "ja": "キャッシュは、次の最初の一致を使用して、応答の鮮度の有効期間（freshness_lifetimeとして示される）を計算できます。"
    },
    {
      "indent": 3,
      "text": "o If the cache is shared and the s-maxage response directive (Section 5.2.2.9) is present, use its value, or",
      "ja": "o キャッシュが共有され、s-maxage応答ディレクティブ（5.2.2.9項）が存在する場合は、その値を使用するか、"
    },
    {
      "indent": 3,
      "text": "o If the max-age response directive (Section 5.2.2.8) is present, use its value, or",
      "ja": "o max-age応答ディレクティブ（セクション5.2.2.8）が存在する場合は、その値を使用するか、"
    },
    {
      "indent": 3,
      "text": "o If the Expires response header field (Section 5.3) is present, use its value minus the value of the Date response header field, or",
      "ja": "o Expires応答ヘッダーフィールド（セクション5.3）が存在する場合は、その値から日付応答ヘッダーフィールドの値を引いた値を使用します。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, no explicit expiration time is present in the response. A heuristic freshness lifetime might be applicable; see Section 4.2.2.",
      "ja": "o それ以外の場合、応答に明示的な有効期限はありません。ヒューリスティックな鮮度有効期間が適用される場合があります。セクション4.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that this calculation is not vulnerable to clock skew, since all of the information comes from the origin server.",
      "ja": "すべての情報はオリジンサーバーから取得されるため、この計算はクロックスキューに対して脆弱ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives), the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale.",
      "ja": "特定のディレクティブに複数の値が存在する場合（2つのExpiresヘッダーフィールド、複数のCache-Control：max-ageディレクティブなど）、ディレクティブの値は無効と見なされます。キャッシュは、無効な鮮度情報を持つ応答を古くなっていると見なすことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Calculating Heuristic Freshness",
      "section_title": true,
      "ja": "4.2.2. ヒューリスティックな鮮度の計算"
    },
    {
      "indent": 3,
      "text": "Since origin servers do not always provide explicit expiration times, a cache MAY assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other header field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but does impose worst-case constraints on their results.",
      "ja": "起点サーバーは常に明示的な有効期限を提供するわけではないため、明示的な時間が指定されていない場合、キャッシュはヒューリスティックな有効期限を割り当て、他のヘッダーフィールド値（Last-Modified時間など）を使用して妥当な有効期限を見積もることができます（MAY）。 。この仕様は特定のアルゴリズムを提供しませんが、結果に最悪の場合の制約を課します。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3, this means that, effectively, heuristics can only be used on responses without explicit freshness whose status codes are defined as cacheable by default (see Section 6.1 of [RFC7231]), and those responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a \"public\" response directive).",
      "ja": "キャッシュは、保存された応答に明示的な有効期限が存在する場合に、ヒューリスティックを使用して鮮度を判断してはなりません（MUST NOT）。セクション3の要件により、これは事実上、ヒューリスティックはステータスコードがデフォルトでキャッシュ可能として定義されている明示的な鮮度なしの応答（[RFC7231]のセクション6.1を参照）と、明示的な鮮度なしの応答でのみ使用できることを意味します。明示的にキャッシュ可能としてマークされている（たとえば、「パブリック」応答ディレクティブで）。"
    },
    {
      "indent": 3,
      "text": "If the response has a Last-Modified header field (Section 2.2 of [RFC7232]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.",
      "ja": "応答にLast-Modifiedヘッダーフィールドが含まれている場合（[RFC7232]のセクション2.2）、キャッシュは、その時間以降の間隔の一部にすぎないヒューリスティックな有効期限値を使用することをお勧めします。この割合の一般的な設定は10％です。"
    },
    {
      "indent": 3,
      "text": "When a heuristic is used to calculate freshness lifetime, a cache SHOULD generate a Warning header field with a 113 warn-code (see Section 5.5.4) in the response if its current_age is more than 24 hours and such a warning is not already present.",
      "ja": "ヒューリスティックを使用して鮮度の有効期間を計算する場合、そのcurrent_ageが24時間を超えていて、そのような警告がまだ存在していない場合、キャッシュは、応答に113 warn-code（セクション5.5.4を参照）を含む警告ヘッダーフィールドを生成する必要があります（SHOULD）。 。"
    },
    {
      "indent": 6,
      "text": "Note: Section 13.9 of [RFC2616] prohibited caches from calculating heuristic freshness for URIs with query components (i.e., those containing '?'). In practice, this has not been widely implemented. Therefore, origin servers are encouraged to send explicit directives (e.g., Cache-Control: no-cache) if they wish to preclude caching.",
      "ja": "注：[RFC2616]のセクション13.9は、クエリコンポーネント（つまり、「？」を含むもの）を持つURIのヒューリスティックフレッシュネスをキャッシュが計算することを禁止していました。実際には、これは広く実装されていません。したがって、オリジンサーバーは、キャッシュを排除したい場合は、明示的なディレクティブ（Cache-Control：no-cacheなど）を送信することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Calculating Age",
      "section_title": true,
      "ja": "4.2.3. 年齢の計算"
    },
    {
      "indent": 3,
      "text": "The Age header field is used to convey an estimated age of the response message when obtained from a cache. The Age field value is the cache's estimate of the number of seconds since the response was generated or validated by the origin server. In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.",
      "ja": "Ageヘッダーフィールドは、キャッシュから取得した応答メッセージの推定経過時間を伝えるために使用されます。 Ageフィールドの値は、応答がオリジンサーバーによって生成または検証されてからのキャッシュの推定秒数です。本質的に、Age値は、応答が起点サーバーからのパスに沿って各キャッシュに常駐していた時間と、ネットワークパスに沿って転送されていた時間の合計です。"
    },
    {
      "indent": 3,
      "text": "The following data is used for the age calculation:",
      "ja": "年齢の計算には次のデータが使用されます。"
    },
    {
      "indent": 3,
      "text": "age_value",
      "ja": "age_value"
    },
    {
      "indent": 6,
      "text": "The term \"age_value\" denotes the value of the Age header field (Section 5.1), in a form appropriate for arithmetic operation; or 0, if not available.",
      "ja": "「age_value」という用語は、Ageヘッダーフィールド（セクション5.1）の値を、算術演算に適した形式で示します。利用できない場合は0。"
    },
    {
      "indent": 3,
      "text": "date_value",
      "ja": "date_value"
    },
    {
      "indent": 6,
      "text": "The term \"date_value\" denotes the value of the Date header field, in a form appropriate for arithmetic operations. See Section 7.1.1.2 of [RFC7231] for the definition of the Date header field, and for requirements regarding responses without it.",
      "ja": "「date_value」という用語は、算術演算に適した形式で、Dateヘッダーフィールドの値を示します。 Dateヘッダーフィールドの定義、およびそれなしの応答に関する要件については、[RFC7231]のセクション7.1.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "now",
      "ja": "今"
    },
    {
      "indent": 6,
      "text": "The term \"now\" means \"the current value of the clock at the host performing the calculation\". A host ought to use NTP ([RFC5905]) or some similar protocol to synchronize its clocks to Coordinated Universal Time.",
      "ja": "「今」という用語は、「計算を実行しているホストでのクロックの現在の値」を意味します。ホストは、NTP（[RFC5905]）または類似のプロトコルを使用して、時計を協定世界時に同期させる必要があります。"
    },
    {
      "indent": 3,
      "text": "request_time",
      "ja": "request_time"
    },
    {
      "indent": 6,
      "text": "The current value of the clock at the host at the time the request resulting in the stored response was made.",
      "ja": "格納された応答をもたらす要求が行われたときのホストのクロックの現在の値。"
    },
    {
      "indent": 3,
      "text": "response_time",
      "ja": "反応時間"
    },
    {
      "indent": 6,
      "text": "The current value of the clock at the host at the time the response was received.",
      "ja": "応答が受信されたときのホストのクロックの現在の値。"
    },
    {
      "indent": 3,
      "text": "A response's age can be calculated in two entirely independent ways:",
      "ja": "応答の年齢は、2つの完全に独立した方法で計算できます。"
    },
    {
      "indent": 3,
      "text": "1. the \"apparent_age\": response_time minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.",
      "ja": "1. 「apparent_age」：response_timeからdate_valueを差し引いたもの。ローカルクロックが元のサーバーのクロックに適切に同期されている場合。結果が負の場合、結果はゼロに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "2. the \"corrected_age_value\", if all of the caches along the response path implement HTTP/1.1. A cache MUST interpret this value relative to the time the request was initiated, not the time that the response was received.",
      "ja": "2. 応答パス上のすべてのキャッシュがHTTP / 1.1を実装している場合は、「corrected_age_value」。キャッシュは、応答が受信された時間ではなく、要求が開始された時間に関連してこの値を解釈する必要があります。"
    },
    {
      "indent": 5,
      "text": "apparent_age = max(0, response_time - date_value);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "response_delay = response_time - request_time;\ncorrected_age_value = age_value + response_delay;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These are combined as",
      "ja": "これらは、"
    },
    {
      "indent": 5,
      "text": "corrected_initial_age = max(apparent_age, corrected_age_value);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "unless the cache is confident in the value of the Age header field (e.g., because there are no HTTP/1.0 hops in the Via header field), in which case the corrected_age_value MAY be used as the corrected_initial_age.",
      "ja": "キャッシュがAgeヘッダーフィールドの値に自信がない場合（たとえば、ViaヘッダーフィールドにHTTP / 1.0ホップがないため）。この場合、corrected_age_valueはcorrected_initial_ageとして使用できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "The current_age of a stored response can then be calculated by adding the amount of time (in seconds) since the stored response was last validated by the origin server to the corrected_initial_age.",
      "ja": "保存された応答のcurrent_ageは、保存された応答が起点サーバーによって最後に検証されてからの時間（秒単位）をcorrected_initial_ageに追加することで計算できます。"
    },
    {
      "indent": 5,
      "text": "resident_time = now - response_time;\ncurrent_age = corrected_initial_age + resident_time;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.4. Serving Stale Responses",
      "section_title": true,
      "ja": "4.2.4. 古い応答の提供"
    },
    {
      "indent": 3,
      "text": "A \"stale\" response is one that either has explicit expiry information or is allowed to have heuristic expiry calculated, but is not fresh according to the calculations in Section 4.2.",
      "ja": "「古い」応答とは、明示的な有効期限情報を持っているか、ヒューリスティックな有効期限の計算を許可されているが、セクション4.2の計算によれば新鮮ではない応答のことです。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT generate a stale response if it is prohibited by an explicit in-protocol directive (e.g., by a \"no-store\" or \"no-cache\" cache directive, a \"must-revalidate\" cache-response-directive, or an applicable \"s-maxage\" or \"proxy-revalidate\" cache-response-directive; see Section 5.2.2).",
      "ja": "明示的なプロトコル内ディレクティブ（たとえば、 \"no-store\"または \"no-cache\"キャッシュディレクティブ、 \"must-revalidate\" cache-response-directive）によって禁止されている場合、キャッシュは古い応答を生成してはなりません（MUST NOT）。または、該当する「s-maxage」または「proxy-revalidate」のcache-response-directive（セクション5.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT send stale responses unless it is disconnected (i.e., it cannot contact the origin server or otherwise find a forward path) or doing so is explicitly allowed (e.g., by the max-stale request directive; see Section 5.2.1).",
      "ja": "キャッシュは、切断される（つまり、元のサーバーに接続できない、または転送パスを見つけることができない）か、明示的に許可されていない（たとえば、max-staleリクエストディレクティブにより、セクション5.2.1を参照）場合を除き、古い応答を送信してはなりません（MUST NOT）。 。"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate a Warning header field with the 110 warn-code (see Section 5.5.1) in stale responses. Likewise, a cache SHOULD generate a 112 warn-code (see Section 5.5.3) in stale responses if the cache is disconnected.",
      "ja": "キャッシュは、古くなった応答で110 warn-code（セクション5.5.1を参照）を含む警告ヘッダーフィールドを生成する必要があります（SHOULD）。同様に、キャッシュが切断された場合、キャッシュは失効した応答で112警告コード（セクション5.5.3を参照）を生成する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD NOT generate a new Warning header field when forwarding a response that does not have an Age header field, even if the response is already stale. A cache need not validate a response that merely became stale in transit.",
      "ja": "キャッシュは、Ageヘッダーフィールドのない応答を転送するときに、応答がすでに古くなっている場合でも、新しい警告ヘッダーフィールドを生成するべきではありません（SHOULD NOT）。キャッシュは、転送中に陳腐化した応答を検証する必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.3. Validation",
      "section_title": true,
      "ja": "4.3. 検証"
    },
    {
      "indent": 3,
      "text": "When a cache has one or more stored responses for a requested URI, but cannot serve any of them (e.g., because they are not fresh, or one cannot be selected; see Section 4.1), it can use the conditional request mechanism [RFC7232] in the forwarded request to give the next inbound server an opportunity to select a valid stored response to use, updating the stored metadata in the process, or to replace the stored response(s) with a new response. This process is known as \"validating\" or \"revalidating\" the stored response.",
      "ja": "キャッシュに、リクエストされたURIに対して1つ以上の格納された応答があるが、それらのいずれも提供できない場合（たとえば、フレッシュでない、または選択できないため、セクション4.1を参照）、条件付きリクエストメカニズムを使用できます[RFC7232]次のインバウンドサーバーに、使用する有効な保存済み応答を選択する機会、プロセス内の保存済みメタデータを更新する機会、または保存済み応答を新しい応答で置き換える機会を与えるために、転送された要求で。このプロセスは、保存された応答の「検証」または「再検証」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Sending a Validation Request",
      "section_title": true,
      "ja": "4.3.1. 検証リクエストの送信"
    },
    {
      "indent": 3,
      "text": "When sending a conditional request for cache validation, a cache sends one or more precondition header fields containing validator metadata from its stored response(s), which is then compared by recipients to determine whether a stored response is equivalent to a current representation of the resource.",
      "ja": "キャッシュ検証の条件付きリクエストを送信する場合、キャッシュは、保存された応答からのバリデータメタデータを含む1つ以上の前提条件ヘッダーフィールドを送信し、受信者はこれを比較して、保存された応答がリソースの現在の表現と等しいかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "One such validator is the timestamp given in a Last-Modified header field (Section 2.2 of [RFC7232]), which can be used in an If-Modified-Since header field for response validation, or in an If-Unmodified-Since or If-Range header field for representation selection (i.e., the client is referring specifically to a previously obtained representation with that timestamp).",
      "ja": "そのようなバリデーターの1つは、Last-Modifiedヘッダーフィールド（[RFC7232]のセクション2.2）で指定されたタイムスタンプです。これは、応答検証のIf-Modified-Sinceヘッダーフィールド、またはIf-Unmodified-SinceまたはIfで使用できます。 -表現選択のための範囲ヘッダーフィールド（つまり、クライアントは、以前に取得したそのタイムスタンプを持つ表現を具体的に参照しています）。"
    },
    {
      "indent": 3,
      "text": "Another validator is the entity-tag given in an ETag header field (Section 2.3 of [RFC7232]). One or more entity-tags, indicating one or more stored responses, can be used in an If-None-Match header field for response validation, or in an If-Match or If-Range header field for representation selection (i.e., the client is referring specifically to one or more previously obtained representations with the listed entity-tags).",
      "ja": "別のバリデーターは、ETagヘッダーフィールドで指定されたエンティティタグです（[RFC7232]のセクション2.3）。 1つ以上の格納された応答を示す1つ以上のエンティティタグは、応答検証の場合はIf-None-Matchヘッダーフィールドで、表現選択の場合はIf-MatchまたはIf-Rangeヘッダーフィールドで使用できます（つまり、クライアントリストされたエンティティタグを使用して、以前に取得した1つ以上の表現を具体的に参照しています。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Handling a Received Validation Request",
      "section_title": true,
      "ja": "4.3.2. 受け取った検証リクエストの処理"
    },
    {
      "indent": 3,
      "text": "Each client in the request chain may have its own cache, so it is common for a cache at an intermediary to receive conditional requests from other (outbound) caches. Likewise, some user agents make use of conditional requests to limit data transfers to recently modified representations or to complete the transfer of a partially retrieved representation.",
      "ja": "リクエストチェーンの各クライアントには独自のキャッシュがある場合があるため、中間のキャッシュが他の（送信）キャッシュから条件付きリクエストを受信するのが一般的です。同様に、一部のユーザーエージェントは、条件付き要求を使用して、データ転送を最近変更された表現に制限するか、部分的に取得された表現の転送を完了します。"
    },
    {
      "indent": 3,
      "text": "If a cache receives a request that can be satisfied by reusing one of its stored 200 (OK) or 206 (Partial Content) responses, the cache SHOULD evaluate any applicable conditional header field preconditions received in that request with respect to the corresponding validators contained within the selected response. A cache MUST NOT evaluate conditional header fields that are only applicable to an origin server, found in a request with semantics that cannot be satisfied with a cached response, or applied to a target resource for which it has no stored responses; such preconditions are likely intended for some other (inbound) server.",
      "ja": "キャッシュが、格納されている200（OK）または206（Partial Content）応答のいずれかを再利用することで満たすことができる要求を受信した場合、そのキャッシュで含まれる対応するバリデーターに関して、その要求で受信した適用可能な条件ヘッダーフィールドの前提条件を評価する必要があります（SHOULD）。選択した応答。キャッシュは、オリジンサーバーにのみ適用可能な条件付きヘッダーフィールド、キャッシュされた応答では満足できないセマンティクスの要求で見つかった、または格納された応答がないターゲットリソースに適用された条件付きヘッダーフィールドを評価してはなりません（MUST NOT）。そのような前提条件は、おそらく他の（インバウンド）サーバーを対象としています。"
    },
    {
      "indent": 3,
      "text": "The proper evaluation of conditional requests by a cache depends on the received precondition header fields and their precedence, as defined in Section 6 of [RFC7232]. The If-Match and If-Unmodified-Since conditional header fields are not applicable to a cache.",
      "ja": "[RFC7232]のセクション6で定義されているように、キャッシュによる条件付きリクエストの適切な評価は、受信した前提条件ヘッダーフィールドとその優先度に依存します。 If-MatchおよびIf-Unmodified-Since条件付きヘッダーフィールドは、キャッシュには適用されません。"
    },
    {
      "indent": 3,
      "text": "A request containing an If-None-Match header field (Section 3.2 of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses in comparison to whichever stored response is selected by the cache. If the field-value is \"*\", or if the field-value is a list of entity-tags and at least one of them matches the entity-tag of the selected stored response, a cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) instead of sending that stored response.",
      "ja": "If-None-Matchヘッダーフィールド（[RFC7232]のセクション3.2）を含むリクエストは、クライアントが1つ以上の独自の保存されたレスポンスを、キャッシュによって選択された保存されたレスポンスと比較して検証したいことを示します。フィールド値が「*」の場合、またはフィールド値がエンティティタグのリストであり、それらの少なくとも1つが、選択した保存済み応答のエンティティタグと一致する場合、キャッシュ受信者は304（Not Modified ）その保存された応答を送信する代わりに（選択された保存された応答のメタデータを使用して）応答。"
    },
    {
      "indent": 3,
      "text": "When a cache decides to revalidate its own stored responses for a request that contains an If-None-Match list of entity-tags, the cache MAY combine the received list with a list of entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement If-None-Match header field value in the forwarded request. If a stored response contains only partial content, the cache MUST NOT include its entity-tag in the union unless the request is for a range that would be fully satisfied by that partial stored response. If the response to the forwarded request is 304 (Not Modified) and has an ETag header field value with an entity-tag that is not in the client's list, the cache MUST generate a 200 (OK) response for the client by reusing its corresponding stored response, as updated by the 304 response metadata (Section 4.3.4).",
      "ja": "キャッシュがエンティティタグのIf-None-Matchリストを含むリクエストの独自の格納された応答を再検証することを決定した場合、キャッシュは、受信したリストを、格納された独自の応答セットのエンティティタグのリスト（新しいまたは古い）、2つのリストの和集合を、転送されたリクエストの置換If-None-Matchヘッダーフィールド値として送信します。格納された応答に部分的なコンテンツのみが含まれる場合、リクエストがその部分的な格納された応答によって完全に満たされる範囲に対するものでない限り、キャッシュはそのエンティティタグをユニオンに含めてはなりません（MUST NOT）。転送されたリクエストへの応答が304（Not Modified）で、ETagヘッダーフィールド値にクライアントのリストにないエンティティタグが含まれている場合、キャッシュは対応するクライアントを再利用して200（OK）応答を生成する必要があります304応答メタデータによって更新された、保存された応答（セクション4.3.4）。"
    },
    {
      "indent": 3,
      "text": "If an If-None-Match header field is not present, a request containing an If-Modified-Since header field (Section 3.3 of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses by modification date. A cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) if one of the following cases is true: 1) the selected stored response has a Last-Modified field-value that is earlier than or equal to the conditional timestamp; 2) no Last-Modified field is present in the selected stored response, but it has a Date field-value that is earlier than or equal to the conditional timestamp; or, 3) neither Last-Modified nor Date is present in the selected stored response, but the cache recorded it as having been received at a time earlier than or equal to the conditional timestamp.",
      "ja": "If-None-Matchヘッダーフィールドが存在しない場合、If-Modified-Sinceヘッダーフィールド（[RFC7232]のセクション3.3）を含むリクエストは、クライアントが変更日によって独自の保存された応答の1つ以上を検証したいことを示します。次のいずれかの場合に当てはまる場合、キャッシュ受信者は304（変更されていない）応答を生成する必要があります（選択された保存済み応答のメタデータを使用）：1）選択された格納済み応答のLast-Modifiedフィールド値が条件付きタイムスタンプに等しい。 2）選択した保存済み応答にLast-Modifiedフィールドがありませんが、条件付きタイムスタンプ以前の日付フィールド値があります。または、3）Last-ModifiedもDateも選択された保存済み応答に存在しないが、条件付きタイムスタンプ以前の時間に受信されたものとしてキャッシュが記録した。"
    },
    {
      "indent": 3,
      "text": "A cache that implements partial responses to range requests, as defined in [RFC7233], also needs to evaluate a received If-Range header field (Section 3.2 of [RFC7233]) with respect to its selected stored response.",
      "ja": "[RFC7233]で定義されているように、範囲リクエストへの部分的な応答を実装するキャッシュも、受信したIf-Rangeヘッダーフィールド（[RFC7233]のセクション3.2）を、選択した保存済みの応答に関して評価する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Handling a Validation Response",
      "section_title": true,
      "ja": "4.3.3. 検証応答の処理"
    },
    {
      "indent": 3,
      "text": "Cache handling of a response to a conditional request is dependent upon its status code:",
      "ja": "条件付き要求への応答のキャッシュ処理は、そのステータスコードに依存します。"
    },
    {
      "indent": 3,
      "text": "o A 304 (Not Modified) response status code indicates that the stored response can be updated and reused; see Section 4.3.4.",
      "ja": "o 304（Not Modified）レスポンスステータスコードは、保存されたレスポンスを更新して再利用できることを示します。セクション4.3.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A full response (i.e., one with a payload body) indicates that none of the stored responses nominated in the conditional request is suitable. Instead, the cache MUST use the full response to satisfy the request and MAY replace the stored response(s).",
      "ja": "o 完全な応答（つまり、ペイロード本文を含む応答）は、条件付き要求で指定された保存済み応答が適切でないことを示します。代わりに、キャッシュは要求を満たすために完全な応答を使用しなければならず（MUST）、格納された応答を置き換えてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "o However, if a cache receives a 5xx (Server Error) response while attempting to validate a response, it can either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, the cache MAY send a previously stored response (see Section 4.2.4).",
      "ja": "o ただし、キャッシュが応答の検証を試行中に5xx（サーバーエラー）応答を受信した場合、キャッシュはこの応答を要求元のクライアントに転送するか、サーバーが応答に失敗したかのように動作します。後者の場合、キャッシュは以前に保存された応答を送信してもよい（セクション4.2.4を参照）。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Freshening Stored Responses upon Validation",
      "section_title": true,
      "ja": "4.3.4. 検証時の保存済み応答の更新"
    },
    {
      "indent": 3,
      "text": "When a cache receives a 304 (Not Modified) response and already has one or more stored 200 (OK) responses for the same cache key, the cache needs to identify which of the stored responses are updated by this new response and then update the stored response(s) with the new information provided in the 304 response.",
      "ja": "キャッシュが304（Not Modified）レスポンスを受信し、同じキャッシュキーに対して1つ以上の保存された200（OK）レスポンスを既に持っている場合、キャッシュは、この新しいレスポンスによって更新された保存済みレスポンスを識別してから、保存済みの更新を更新する必要があります。 304応答で提供された新しい情報を含む応答。"
    },
    {
      "indent": 3,
      "text": "The stored response to update is identified by using the first match (if any) of the following:",
      "ja": "保存された更新への応答は、次の最初の一致（存在する場合）を使用して識別されます。"
    },
    {
      "indent": 3,
      "text": "o If the new response contains a strong validator (see Section 2.1 of [RFC7232]), then that strong validator identifies the selected representation for update. All of the stored responses with the same strong validator are selected. If none of the stored responses contain the same strong validator, then the cache MUST NOT use the new response to update any stored responses.",
      "ja": "o 新しい応答に強力なバリデーターが含まれている場合（[RFC7232]のセクション2.1を参照）、その強力なバリデーターは更新用に選択された表現を識別します。同じ強力なバリデーターで保存されたすべての応答が選択されます。保存された応答のいずれにも同じ強力なバリデーターが含まれていない場合、キャッシュは、保存された応答を更新するために新しい応答を使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o If the new response contains a weak validator and that validator corresponds to one of the cache's stored responses, then the most recent of those matching stored responses is selected for update.",
      "ja": "o 新しい応答に弱いバリデーターが含まれていて、そのバリデーターがキャッシュの格納された応答の1つに対応する場合、一致する格納された応答のうち最新のものが更新用に選択されます。"
    },
    {
      "indent": 3,
      "text": "o If the new response does not include any form of validator (such as in the case where a client generates an If-Modified-Since request from a source other than the Last-Modified response header field), and there is only one stored response, and that stored response also lacks a validator, then that stored response is selected for update.",
      "ja": "o 新しい応答に形式のバリデーターが含まれておらず（クライアントがLast-Modified応答ヘッダーフィールド以外のソースからIf-Modified-Since要求を生成する場合など）、格納されている応答が1つしかない場合、その格納された応答にもバリデーターが欠けている場合、その格納された応答が更新のために選択されます。"
    },
    {
      "indent": 3,
      "text": "If a stored response is selected for update, the cache MUST:",
      "ja": "保存された応答が更新のために選択された場合、キャッシュは次のことをしなければなりません："
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "o 保存されている応答のwarn-code 1xxを持つ警告ヘッダーフィールドを削除します（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "o 保存された応答の警告ヘッダーフィールドをwarn-code 2xxで保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the 304 (Not Modified) response to replace all instances of the corresponding header fields in the stored response.",
      "ja": "o 304（Not Modified）レスポンスで提供される他のヘッダーフィールドを使用して、保存されたレスポンスの対応するヘッダーフィールドのすべてのインスタンスを置き換えます。"
    },
    {
      "indent": 0,
      "text": "4.3.5. Freshening Responses via HEAD",
      "section_title": true,
      "ja": "4.3.5. HEADによるレスポンスの更新"
    },
    {
      "indent": 3,
      "text": "A response to the HEAD method is identical to what an equivalent request made with a GET would have been, except it lacks a body. This property of HEAD responses can be used to invalidate or update a cached GET response if the more efficient conditional GET request mechanism is not available (due to no validators being present in the stored response) or if transmission of the representation body is not desired even if it has changed.",
      "ja": "HEADメソッドへの応答は、本文が欠落していることを除いて、GETで行われた同等のリクエストと同じです。 HEADレスポンスのこのプロパティは、より効率的な条件付きGETリクエストメカニズムが利用できない場合（保存されたレスポンスにバリデータが存在しないため）、またはリプレゼンテーションボディの送信が不要な場合に、キャッシュされたGETレスポンスを無効化または更新するために使用できます。変更された場合。"
    },
    {
      "indent": 3,
      "text": "When a cache makes an inbound HEAD request for a given request target and receives a 200 (OK) response, the cache SHOULD update or invalidate each of its stored GET responses that could have been selected for that request (see Section 4.1).",
      "ja": "キャッシュが所定のリクエストターゲットに対してインバウンドHEADリクエストを作成し、200（OK）レスポンスを受信すると、キャッシュは、そのリクエストに対して選択された可能性のある格納された各GETレスポンスを更新または無効化する必要があります（セクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "For each of the stored responses that could have been selected, if the stored response and HEAD response have matching values for any received validator fields (ETag and Last-Modified) and, if the HEAD response has a Content-Length header field, the value of Content-Length matches that of the stored response, the cache SHOULD update the stored response as described below; otherwise, the cache SHOULD consider the stored response to be stale.",
      "ja": "選択された可能性のある格納された応答のそれぞれについて、格納された応答とHEAD応答が受信したバリデータフィールド（ETagとLast-Modified）に一致する値を持ち、HEAD応答にContent-Lengthヘッダーフィールドがある場合、値Content-Lengthが格納された応答のそれと一致する場合、キャッシュは、以下に説明するように格納された応答を更新する必要があります（SHOULD）。それ以外の場合、キャッシュは、格納された応答を古いものと見なす必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If a cache updates a stored response with the metadata provided in a HEAD response, the cache MUST:",
      "ja": "キャッシュがHEAD応答で提供されたメタデータで保存された応答を更新する場合、キャッシュは以下を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "o 保存されている応答のwarn-code 1xxを持つ警告ヘッダーフィールドを削除します（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "o 保存された応答の警告ヘッダーフィールドをwarn-code 2xxで保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the HEAD response to replace all instances of the corresponding header fields in the stored response and append new header fields to the stored response's header section unless otherwise restricted by the Cache-Control header field.",
      "ja": "o HEAD応答で提供される他のヘッダーフィールドを使用して、格納された応答内の対応するヘッダーフィールドのすべてのインスタンスを置き換え、Cache-Controlヘッダーフィールドによる制限がない限り、格納された応答のヘッダーセクションに新しいヘッダーフィールドを追加します。"
    },
    {
      "indent": 0,
      "text": "4.4. Invalidation",
      "section_title": true,
      "ja": "4.4. 無効化"
    },
    {
      "indent": 3,
      "text": "Because unsafe request methods (Section 4.2.1 of [RFC7231]) such as PUT, POST or DELETE have the potential for changing state on the origin server, intervening caches can use them to keep their contents up to date.",
      "ja": "PUT、POST、DELETEなどの安全でないリクエストメソッド（[RFC7231]のセクション4.2.1）は、配信元サーバーの状態を変更する可能性があるため、介在するキャッシュは、それらを使用してコンテンツを最新に保つことができます。"
    },
    {
      "indent": 3,
      "text": "A cache MUST invalidate the effective Request URI (Section 5.5 of [RFC7230]) as well as the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.",
      "ja": "への応答でエラー以外のステータスコードが受信された場合、キャッシュは、有効なリクエストURI（[RFC7230]のセクション5.5）と、LocationおよびContent-Location応答ヘッダーフィールド（存在する場合）のURIを無効にする必要があります。安全でない要求メソッド。"
    },
    {
      "indent": 3,
      "text": "However, a cache MUST NOT invalidate a URI from a Location or Content-Location response header field if the host part of that URI differs from the host part in the effective request URI (Section 5.5 of [RFC7230]). This helps prevent denial-of-service attacks.",
      "ja": "ただし、そのURIのホスト部分が有効な要求URIのホスト部分と異なる場合（[RFC7230]のセクション5.5）、キャッシュはLocationまたはContent-Location応答ヘッダーフィールドからURIを無効にしてはなりません（MUST NOT）。これにより、サービス拒否攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "A cache MUST invalidate the effective request URI (Section 5.5 of [RFC7230]) when it receives a non-error response to a request with a method whose safety is unknown.",
      "ja": "キャッシュは、安全性が不明なメソッドを含むリクエストに対するエラー以外の応答を受信した場合、有効なリクエストURI（[RFC7230]のセクション5.5）を無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Here, a \"non-error response\" is one with a 2xx (Successful) or 3xx (Redirection) status code. \"Invalidate\" means that the cache will either remove all stored responses related to the effective request URI or will mark these as \"invalid\" and in need of a mandatory validation before they can be sent in response to a subsequent request.",
      "ja": "ここで、「非エラー応答」とは、2xx（成功）または3xx（リダイレクト）のステータスコードを持つ応答です。 「無効化」とは、キャッシュが有効なリクエストURIに関連するすべての保存された応答を削除するか、これらを「無効」としてマークし、後続のリクエストに応答して送信する前に必須の検証が必要であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that this does not guarantee that all appropriate responses are invalidated. For example, a state-changing request might invalidate responses in the caches it travels through, but relevant responses still might be stored in other caches that it has not.",
      "ja": "これは、すべての適切な応答が無効になることを保証するものではないことに注意してください。たとえば、状態変更要求は、通過するキャッシュ内の応答を無効にする可能性がありますが、関連する応答は、そうでない他のキャッシュに保存される可能性があります。"
    },
    {
      "indent": 0,
      "text": "5. Header Field Definitions",
      "section_title": true,
      "ja": "5. ヘッダーフィールドの定義"
    },
    {
      "indent": 3,
      "text": "This section defines the syntax and semantics of HTTP/1.1 header fields related to caching.",
      "ja": "このセクションでは、キャッシングに関連するHTTP / 1.1ヘッダーフィールドの構文とセマンティクスを定義します。"
    },
    {
      "indent": 0,
      "text": "5.1. Age",
      "section_title": true,
      "ja": "5.1. 上げ"
    },
    {
      "indent": 3,
      "text": "The \"Age\" header field conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server. Age values are calculated as specified in Section 4.2.3.",
      "ja": "\"Age\"ヘッダーフィールドは、送信元のサーバーで応答が生成または検証されてからの送信者の推定時間を伝えます。年齢の値は、セクション4.2.3の指定に従って計算されます。"
    },
    {
      "indent": 5,
      "text": "Age = delta-seconds",
      "ja": "年齢=デルタ秒"
    },
    {
      "indent": 3,
      "text": "The Age field-value is a non-negative integer, representing time in seconds (see Section 1.2.1).",
      "ja": "Ageフィールド値は、秒単位の時間を表す負でない整数です（セクション1.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The presence of an Age header field implies that the response was not generated or validated by the origin server for this request. However, lack of an Age header field does not imply the origin was contacted, since the response might have been received from an HTTP/1.0 cache that does not implement Age.",
      "ja": "Ageヘッダーフィールドが存在するということは、この要求に対してオリジンサーバーが応答を生成または検証しなかったことを意味します。ただし、Ageを実装していないHTTP / 1.0キャッシュから応答が受信された可能性があるため、Ageヘッダーフィールドがなくても、発信元にアクセスしたことを意味するわけではありません。"
    },
    {
      "indent": 0,
      "text": "5.2. Cache-Control",
      "section_title": true,
      "ja": "5.2. キャッシュ制御"
    },
    {
      "indent": 3,
      "text": "The \"Cache-Control\" header field is used to specify directives for caches along the request/response chain. Such cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.",
      "ja": "「Cache-Control」ヘッダーフィールドは、要求/応答チェーンに沿ったキャッシュのディレクティブを指定するために使用されます。このようなキャッシュディレクティブは、要求内のディレクティブの存在が同じディレクティブが応答で与えられることを意味しないという点で、単一方向です。"
    },
    {
      "indent": 3,
      "text": "A cache MUST obey the requirements of the Cache-Control directives defined in this section. See Section 5.2.3 for information about how Cache-Control directives defined elsewhere are handled.",
      "ja": "キャッシュは、このセクションで定義されているCache-Controlディレクティブの要件に従う必要があります。他の場所で定義されたCache-Controlディレクティブの処理方法については、セクション5.2.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: Some HTTP/1.0 caches might not implement Cache-Control.",
      "ja": "注：一部のHTTP / 1.0キャッシュは、Cache-Controlを実装しない場合があります。"
    },
    {
      "indent": 3,
      "text": "A proxy, whether or not it implements a cache, MUST pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to target a directive to a specific cache.",
      "ja": "ディレクティブは要求/応答チェーン上のすべての受信者に適用できるため、プロキシは、キャッシュを実装するかどうかに関係なく、アプリケーションへの重要性に関係なく、転送されたメッセージでキャッシュディレクティブを渡す必要があります。ディレクティブを特定のキャッシュにターゲティングすることはできません。"
    },
    {
      "indent": 3,
      "text": "Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument, that can use both token and quoted-string syntax. For the directives defined below that define arguments, recipients ought to accept both forms, even if one is documented to be preferred. For any directive not defined by this specification, a recipient MUST accept both forms.",
      "ja": "キャッシュディレクティブは、大文字と小文字を区別せずに比較されるトークンによって識別され、トークンと引用符付き文字列構文の両方を使用できるオプションの引数を持っています。引数を定義する以下で定義されているディレクティブの場合、受信者は、一方が優先されることが文書化されている場合でも、両方の形式を受け入れる必要があります。この仕様で定義されていないディレクティブについては、受信者は両方の形式を受け入れる必要があります。"
    },
    {
      "indent": 5,
      "text": "Cache-Control = 1#cache-directive",
      "ja": "Cache-Control = 1＃cache-directive"
    },
    {
      "indent": 5,
      "text": "cache-directive = token [ \"=\" ( token / quoted-string ) ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.",
      "ja": "以下で定義されているキャッシュディレクティブの場合、特に明記されていない限り、引数は定義されていません（許可されていません）。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Request Cache-Control Directives",
      "section_title": true,
      "ja": "5.2.1. キャッシュ制御ディレクティブのリクエスト"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. max-age",
      "section_title": true,
      "ja": "5.2.1.1. 最大年齢"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（セクション1.2.1を参照）"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" request directive indicates that the client is unwilling to accept a response whose age is greater than the specified number of seconds. Unless the max-stale request directive is also present, the client is not willing to accept a stale response.",
      "ja": "「max-age」リクエストディレクティブは、クライアントが、指定された秒数を超える経過時間の応答を受け入れたくないことを示します。 max-stale要求ディレクティブも存在しない限り、クライアントは古い応答を受け入れる用意はありません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age=\"5\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "このディレクティブは、引数の構文のトークン形式を使用します（例： 'max-age = \"5\"ではなく' max-age = 5 '）。送信者は引用文字列形式を生成してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. max-stale",
      "section_title": true,
      "ja": "5.2.1.2. max-stale"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（セクション1.2.1を参照）"
    },
    {
      "indent": 3,
      "text": "The \"max-stale\" request directive indicates that the client is willing to accept a response that has exceeded its freshness lifetime. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its freshness lifetime by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.",
      "ja": "「max-stale」リクエストディレクティブは、クライアントがフレッシュネスライフタイムを超えた応答を受け入れる用意があることを示します。 max-staleに値が割り当てられている場合、クライアントは、フレッシュネスライフタイムが指定された秒数を超えていない応答を受け入れる用意があります。 max-staleに値が割り当てられていない場合、クライアントは任意の年齢の古い応答を受け入れてもかまいません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-stale=10' not 'max-stale=\"10\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "このディレクティブは、引数構文のトークン形式を使用します（例： 'max-stale = \"10\"ではなく' max-stale = 10 '）。送信者は引用文字列形式を生成してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. min-fresh",
      "section_title": true,
      "ja": "5.2.1.3. マットレス"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（セクション1.2.1を参照）"
    },
    {
      "indent": 3,
      "text": "The \"min-fresh\" request directive indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.",
      "ja": "「min-fresh」リクエストディレクティブは、フレッシュネスライフタイムが現在の経過時間と指定された時間（秒単位）を足したもの以上である応答をクライアントが受け入れる用意があることを示します。つまり、クライアントは、少なくとも指定された秒数の間、まだ新鮮な応答を望んでいます。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'min-fresh=20' not 'min-fresh=\"20\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "このディレクティブは、引数構文のトークン形式を使用します（例： 'min-fresh = \"20\"ではなく' min-fresh = 20 '）。送信者は引用文字列形式を生成してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. no-cache",
      "section_title": true,
      "ja": "5.2.1.4. キャッシュなし"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" request directive indicates that a cache MUST NOT use a stored response to satisfy the request without successful validation on the origin server.",
      "ja": "「no-cache」リクエストディレクティブは、キャッシュが保存された応答を使用して、オリジンサーバーでの検証に成功せずにリクエストを満たす必要がないことを示します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.5. no-store",
      "section_title": true,
      "ja": "5.2.1.5. ノーストア"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches. \"MUST NOT store\" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.",
      "ja": "「no-store」リクエストディレクティブは、キャッシュがこのリクエストまたはリクエストへの応答のいずれの部分も保存してはならないことを示します。このディレクティブは、プライベートキャッシュと共有キャッシュの両方に適用されます。この場合の「保存しない」とは、キャッシュが情報を意図的に不揮発性ストレージに保存してはならず、情報を転送した後、できるだけ早く揮発性ストレージから情報を削除するよう最善を尽くさなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.",
      "ja": "この指令は、プライバシーを確​​保するための信頼できるまたは十分なメカニズムではありません。特に、悪意のある、または侵害されたキャッシュはこのディレクティブを認識または従わず、通信ネットワークは盗聴に対して脆弱である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that if a request containing this directive is satisfied from a cache, the no-store request directive does not apply to the already stored response.",
      "ja": "このディレクティブを含むリクエストがキャッシュから満たされる場合、ストアなしリクエストディレクティブはすでに保存されているレスポンスには適用されないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.1.6. no-transform",
      "section_title": true,
      "ja": "5.2.1.6. 変換なし"
    },
    {
      "indent": 3,
      "text": "The \"no-transform\" request directive indicates that an intermediary (whether or not it implements a cache) MUST NOT transform the payload, as defined in Section 5.7.2 of [RFC7230].",
      "ja": "[no-transform]リクエストディレクティブは、[RFC7230]のセクション5.7.2で定義されているように、中間（キャッシュを実装しているかどうかにかかわらず）がペイロードを変換してはならないことを示します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.7. only-if-cached",
      "section_title": true,
      "ja": "5.2.1.7. キャッシュされた場合のみ"
    },
    {
      "indent": 3,
      "text": "The \"only-if-cached\" request directive indicates that the client only wishes to obtain a stored response. If it receives this directive, a cache SHOULD either respond using a stored response that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status code. If a group of caches is being operated as a unified system with good internal connectivity, a member cache MAY forward such a request within that group of caches.",
      "ja": "「only-if-cached」リクエストディレクティブは、クライアントが保存された応答の取得のみを望んでいることを示します。このディレクティブを受信した場合、キャッシュは、リクエストの他の制約と一致する格納された応答を使用して応答するか、または504（ゲートウェイタイムアウト）ステータスコードで応答する必要があります（SHOULD）。キャッシュのグループが内部接続が良好な統合システムとして運用されている場合、メンバーキャッシュはそのようなリクエストをキャッシュのグループ内で転送できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Response Cache-Control Directives",
      "section_title": true,
      "ja": "5.2.2. 応答キャッシュ制御ディレクティブ"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. must-revalidate",
      "section_title": true,
      "ja": "5.2.2.1. 再検証する必要があります"
    },
    {
      "indent": 3,
      "text": "The \"must-revalidate\" response directive indicates that once it has become stale, a cache MUST NOT use the response to satisfy subsequent requests without successful validation on the origin server.",
      "ja": "\"must-revalidate\"応答ディレクティブは、古くなったら、キャッシュが応答を使用して、元のサーバーでの検証に成功せずに後続の要求を満たす必要がないことを示します。"
    },
    {
      "indent": 3,
      "text": "The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances a cache MUST obey the must-revalidate directive; in particular, if a cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.",
      "ja": "特定のプロトコル機能の信頼できる操作をサポートするには、再検証が必要なディレクティブが必要です。すべての状況で、キャッシュは再検証が必要なディレクティブに従う必要があります。特に、キャッシュが何らかの理由でオリジンサーバーに到達できない場合は、504（ゲートウェイタイムアウト）応答を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The must-revalidate directive ought to be used by servers if and only if failure to validate a request on the representation could result in incorrect operation, such as a silently unexecuted financial transaction.",
      "ja": "再検証が必要なディレクティブは、表現に対する要求の検証に失敗すると、黙って実行されない金融トランザクションなどの不正な操作が発生する可能性がある場合にのみ、サーバーで使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. no-cache",
      "section_title": true,
      "ja": "5.2.2.2. キャッシュなし"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "#field-name",
      "ja": "＃フィールド名"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" response directive indicates that the response MUST NOT be used to satisfy a subsequent request without successful validation on the origin server. This allows an origin server to prevent a cache from using it to satisfy a request without contacting it, even by caches that have been configured to send stale responses.",
      "ja": "\"no-cache\"応答ディレクティブは、オリジンサーバーでの検証が成功しない限り、後続の要求を満たすために応答を使用してはならないことを示します。これにより、元のサーバーは、古くなった応答を送信するように構成されたキャッシュによっても、キャッシュがそれを使用せずに、要求に応じることなく要求に応じることができなくなります。"
    },
    {
      "indent": 3,
      "text": "If the no-cache response directive specifies one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, any header fields in the response that have the field-name(s) listed MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.",
      "ja": "no-cache応答ディレクティブが1つ以上のフィールド名を指定する場合、キャッシュは、キャッシュに対する他の制限に従って、後続の要求を満たすために応答を使用する場合があります（MAY）。ただし、フィールド名がリストされている応答のヘッダーフィールドは、オリジンサーバーでの再検証に成功せずに、後続の要求への応答で送信してはなりません（MUST NOT）。これにより、オリジンサーバーは、応答内の特定のヘッダーフィールドの再利用を防ぎながら、残りの応答のキャッシュを許可できます。"
    },
    {
      "indent": 3,
      "text": "The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.",
      "ja": "指定されたフィールド名は、この仕様で定義されているヘッダーフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).",
      "ja": "このディレクティブは、引数構文の引用文字列形式を使用します。送信者は、トークンフォームを生成してはなりません（単一エントリのリストに引用が必要ないように見える場合でも）。"
    },
    {
      "indent": 3,
      "text": "Note: Although it has been back-ported to many implementations, some HTTP/1.0 caches will not recognize or obey this directive. Also, no-cache response directives with field-names are often handled by caches as if an unqualified no-cache directive was received; i.e., the special handling for the qualified form is not widely implemented.",
      "ja": "注：これは多くの実装にバックポートされていますが、一部のHTTP / 1.0キャッシュはこのディレクティブを認識または従いません。また、フィールド名を持つキャッシュなし応答ディレクティブは、修飾されていないキャッシュなしディレクティブが受信されたかのように、キャッシュによって処理されることがよくあります。つまり、修飾されたフォームの特別な処理は広く実装されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.3. no-store",
      "section_title": true,
      "ja": "5.2.2.3. ノーストア"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" response directive indicates that a cache MUST NOT store any part of either the immediate request or response. This directive applies to both private and shared caches. \"MUST NOT store\" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.",
      "ja": "「no-store」応答ディレクティブは、キャッシュが即時の要求または応答のいずれの部分も格納してはならないことを示します。このディレクティブは、プライベートキャッシュと共有キャッシュの両方に適用されます。この場合の「保存しない」とは、キャッシュが情報を意図的に不揮発性ストレージに保存してはならず、情報を転送した後、できるだけ早く揮発性ストレージから情報を削除するよう最善を尽くさなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.",
      "ja": "この指令は、プライバシーを確​​保するための信頼できるまたは十分なメカニズムではありません。特に、悪意のある、または侵害されたキャッシュはこのディレクティブを認識または従わず、通信ネットワークは盗聴に対して脆弱である可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2.4. no-transform",
      "section_title": true,
      "ja": "5.2.2.4. 変換なし"
    },
    {
      "indent": 3,
      "text": "The \"no-transform\" response directive indicates that an intermediary (regardless of whether it implements a cache) MUST NOT transform the payload, as defined in Section 5.7.2 of [RFC7230].",
      "ja": "[no-transform]レスポンスディレクティブは、[RFC7230]のセクション5.7.2で定義されているように、仲介者が（キャッシュを実装しているかどうかに関係なく）ペイロードを変換してはならないことを示します。"
    },
    {
      "indent": 0,
      "text": "5.2.2.5. public",
      "section_title": true,
      "ja": "5.2.2.5. 公衆"
    },
    {
      "indent": 3,
      "text": "The \"public\" response directive indicates that any cache MAY store the response, even if the response would normally be non-cacheable or cacheable only within a private cache. (See Section 3.2 for additional details related to the use of public in response to a request containing Authorization, and Section 3 for details of how public affects responses that would normally not be stored, due to their status codes not being defined as cacheable by default; see Section 4.2.2.)",
      "ja": "\"public\"応答ディレクティブは、応答が通常はキャッシュ不可またはプライベートキャッシュ内でのみキャッシュ可能であっても、キャッシュが応答を格納してもよいことを示します。 （承認を含むリクエストに対するパブリックの使用に関する追加の詳細についてはセクション3.2を参照してください。ステータスコードがデフォルトでキャッシュ可能として定義されていないために通常は保存されないレスポンスにパブリックがどのように影響するかについての詳細はセクション3を参照してください。 ;セクション4.2.2を参照。）"
    },
    {
      "indent": 0,
      "text": "5.2.2.6. private",
      "section_title": true,
      "ja": "5.2.2.6. 民間"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "#field-name",
      "ja": "＃フィールド名"
    },
    {
      "indent": 3,
      "text": "The \"private\" response directive indicates that the response message is intended for a single user and MUST NOT be stored by a shared cache. A private cache MAY store the response and reuse it for later requests, even if the response would normally be non-cacheable.",
      "ja": "「プライベート」応答ディレクティブは、応答メッセージが単一のユーザーを対象としており、共有キャッシュによって格納されてはならないことを示します。プライベートキャッシュは、応答が通常キャッシュ不可であっても、応答を格納し、後の要求に再利用する場合があります。"
    },
    {
      "indent": 3,
      "text": "If the private response directive specifies one or more field-names, this requirement is limited to the field-values associated with the listed response header fields. That is, a shared cache MUST NOT store the specified field-names(s), whereas it MAY store the remainder of the response message.",
      "ja": "プライベート応答ディレクティブが1つ以上のフィールド名を指定する場合、この要件は、リストされた応答ヘッダーフィールドに関連付けられたフィールド値に制限されます。つまり、共有キャッシュは指定されたフィールド名を格納してはいけません（MUST NOT）、それはそれが応答メッセージの残りを格納するかもしれません（MAY）。"
    },
    {
      "indent": 3,
      "text": "The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.",
      "ja": "指定されたフィールド名は、この仕様で定義されているヘッダーフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).",
      "ja": "このディレクティブは、引数構文の引用文字列形式を使用します。送信者は、トークンフォームを生成してはなりません（単一エントリのリストに引用が必要ないように見える場合でも）。"
    },
    {
      "indent": 3,
      "text": "Note: This usage of the word \"private\" only controls where the response can be stored; it cannot ensure the privacy of the message content. Also, private response directives with field-names are often handled by caches as if an unqualified private directive was received; i.e., the special handling for the qualified form is not widely implemented.",
      "ja": "注：この「プライベート」という語の使用は、応答を格納できる場所のみを制御します。メッセージコンテンツのプライバシーを保証することはできません。また、フィールド名を持つプライベート応答ディレクティブは、修飾されていないプライベートディレクティブが受信されたかのように、キャッシュによって処理されることがよくあります。つまり、修飾されたフォームの特別な処理は広く実装されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.7. proxy-revalidate",
      "section_title": true,
      "ja": "5.2.2.7. プロキシ再検証"
    },
    {
      "indent": 3,
      "text": "The \"proxy-revalidate\" response directive has the same meaning as the must-revalidate response directive, except that it does not apply to private caches.",
      "ja": "「proxy-revalidate」応答ディレクティブは、プライベートキャッシュに適用されないことを除いて、require-revalidate応答ディレクティブと同じ意味です。"
    },
    {
      "indent": 0,
      "text": "5.2.2.8. max-age",
      "section_title": true,
      "ja": "5.2.2.8. 最大年齢"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（セクション1.2.1を参照）"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" response directive indicates that the response is to be considered stale after its age is greater than the specified number of seconds.",
      "ja": "「max-age」応答ディレクティブは、その経過時間が指定された秒数を超えると応答が古くなったと見なされることを示します。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age=\"5\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "このディレクティブは、引数の構文のトークン形式を使用します（例： 'max-age = \"5\"ではなく' max-age = 5 '）。送信者は引用文字列形式を生成してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.9. s-maxage",
      "section_title": true,
      "ja": "5.2.2.9. s-maxage"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（セクション1.2.1を参照）"
    },
    {
      "indent": 3,
      "text": "The \"s-maxage\" response directive indicates that, in shared caches, the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header field. The s-maxage directive also implies the semantics of the proxy-revalidate response directive.",
      "ja": "「s-m​​axage」応答ディレクティブは、共有キャッシュ内で、このディレクティブによって指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーフィールドで指定された最大経過時間を上書きすることを示します。 s-maxageディレクティブは、proxy-revalidate応答ディレクティブのセマンティクスも意味します。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 's-maxage=10' not 's-maxage=\"10\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "このディレクティブは、引数構文のトークン形式を使用します。たとえば、「s-maxage = \"10\"」ではなく「s-maxage = 10」です。送信者は引用文字列形式を生成してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Cache Control Extensions",
      "section_title": true,
      "ja": "5.2.3. キャッシュ制御拡張"
    },
    {
      "indent": 3,
      "text": "The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional value. A cache MUST ignore unrecognized cache directives.",
      "ja": "Cache-Controlヘッダーフィールドは、それぞれオプションの値を持つ1つ以上のキャッシュ拡張トークンを使用して拡張できます。キャッシュは、認識されないキャッシュディレクティブを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Informational extensions (those that do not require a change in cache behavior) can be added without changing the semantics of other directives.",
      "ja": "情報拡張機能（キャッシュの動作を変更する必要がない拡張機能）は、他のディレクティブのセマンティクスを変更せずに追加できます。"
    },
    {
      "indent": 3,
      "text": "Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the old directive are supplied, such that applications that do not understand the new directive will default to the behavior specified by the old directive, and those that understand the new directive will recognize it as modifying the requirements associated with the old directive. In this way, extensions to the existing cache-control directives can be made without breaking deployed caches.",
      "ja": "動作拡張機能は、キャッシュディレクティブの既存のベースに対する修飾子として機能するように設計されています。新しいディレクティブと古いディレクティブの両方が提供され、新しいディレクティブを理解しないアプリケーションはデフォルトで古いディレクティブによって指定された動作になり、新しいディレクティブを理解するアプリケーションは古いディレクティブに関連する要件を変更するものとしてそれを認識します指令。このようにして、配備されたキャッシュを壊すことなく、既存のキャッシュ制御ディレクティブへの拡張を行うことができます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a hypothetical new response directive called \"community\" that acts as a modifier to the private directive: in addition to private caches, any cache that is shared only by members of the named community is allowed to cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including",
      "ja": "たとえば、プライベートディレクティブの修飾子として機能する「コミュニティ」と呼ばれる架空の新しいレスポンスディレクティブについて考えてみましょう。プライベートキャッシュに加えて、名前付きコミュニティのメンバーだけが共有するキャッシュは、レスポンスのキャッシュを許可されます。 UCIコミュニティが共有キャッシュで他の方法でプライベートな応答を使用できるようにしたいオリジンサーバーは、"
    },
    {
      "indent": 5,
      "text": "Cache-Control: private, community=\"UCI\"",
      "ja": "Cache-Control：private、community = \"UCI\""
    },
    {
      "indent": 3,
      "text": "A cache that recognizes such a community cache-extension could broaden its behavior in accordance with that extension. A cache that does not recognize the community cache-extension would ignore it and adhere to the private directive.",
      "ja": "このようなコミュニティキャッシュ拡張機能を認識するキャッシュは、その拡張機能に従ってその動作を広げることができます。コミュニティキャッシュ拡張機能を認識しないキャッシュは、それを無視してプライベートディレクティブに従います。"
    },
    {
      "indent": 0,
      "text": "5.3. Expires",
      "section_title": true,
      "ja": "5.3. 期限切れ"
    },
    {
      "indent": 3,
      "text": "The \"Expires\" header field gives the date/time after which the response is considered stale. See Section 4.2 for further discussion of the freshness model.",
      "ja": "「Expires」ヘッダーフィールドには、応答が古くなったと見なされるまでの日時が示されます。鮮度モデルの詳細については、セクション4.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.",
      "ja": "Expiresフィールドの存在は、元のリソースがその時間に、その前に、またはその後に変更または存在しなくなることを意味しません。"
    },
    {
      "indent": 3,
      "text": "The Expires value is an HTTP-date timestamp, as defined in Section 7.1.1.1 of [RFC7231].",
      "ja": "Expires値は、[RFC7231]のセクション7.1.1.1で定義されているHTTP日付のタイムスタンプです。"
    },
    {
      "indent": 5,
      "text": "Expires = HTTP-date",
      "ja": "Expires = HTTP-date"
    },
    {
      "indent": 3,
      "text": "For example",
      "ja": "例えば"
    },
    {
      "indent": 5,
      "text": "Expires: Thu, 01 Dec 1994 16:00:00 GMT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").",
      "ja": "キャッシュの受信者は、無効な日付形式、特に値「0」を過去の時刻を表すものとして解釈する必要があります（つまり、「期限切れ」）。"
    },
    {
      "indent": 3,
      "text": "If a response includes a Cache-Control field with the max-age directive (Section 5.2.2.8), a recipient MUST ignore the Expires field. Likewise, if a response includes the s-maxage directive (Section 5.2.2.9), a shared cache recipient MUST ignore the Expires field. In both these cases, the value in Expires is only intended for recipients that have not yet implemented the Cache-Control field.",
      "ja": "応答にmax-ageディレクティブのあるCache-Controlフィールドが含まれている場合（セクション5.2.2.8）、受信者はExpiresフィールドを無視する必要があります。同様に、応答にs-maxageディレクティブ（セクション5.2.2.9）が含まれている場合、共有キャッシュの受信者はExpiresフィールドを無視する必要があります。これらのどちらの場合でも、Expiresの値は、Cache-Controlフィールドをまだ実装していない受信者のみを対象としています。"
    },
    {
      "indent": 3,
      "text": "An origin server without a clock MUST NOT generate an Expires field unless its value represents a fixed time in the past (always expired) or its value has been associated with the resource by a system or user with a reliable clock.",
      "ja": "クロックのないオリジンサーバーは、その値が過去の固定時間（常に期限切れ）を表すか、またはその値が信頼できるクロックを持つシステムまたはユーザーによってリソースに関連付けられていない限り、Expiresフィールドを生成してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Historically, HTTP required the Expires field-value to be no more than a year in the future. While longer freshness lifetimes are no longer prohibited, extremely large values have been demonstrated to cause problems (e.g., clock overflows due to use of 32-bit integers for time values), and many caches will evict a response far sooner than that.",
      "ja": "歴史的に、HTTPではExpiresフィールドの値を1年以内にする必要がありました。フレッシュネスの寿命が長くなることはもはや禁止されていませんが、非常に大きな値は問題を引き起こすことが実証されており（たとえば、時間値に32ビット整数を使用することによるクロックオーバーフロー）、多くのキャッシュはそれよりもはるかに早く応答を追い出します。"
    },
    {
      "indent": 0,
      "text": "5.4. Pragma",
      "section_title": true,
      "ja": "5.4. もの"
    },
    {
      "indent": 3,
      "text": "The \"Pragma\" header field allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a \"no-cache\" request that they will understand (as Cache-Control was not defined until HTTP/1.1). When the Cache-Control header field is also present and understood in a request, Pragma is ignored.",
      "ja": "「プラグマ」ヘッダーフィールドは、HTTP / 1.0キャッシュとの下位互換性を可能にし、クライアントが理解できる「キャッシュなし」リクエストを指定できるようにします（Cache-ControlはHTTP / 1.1まで定義されていなかったため）。 Cache-Controlヘッダーフィールドもリクエストに存在し、理解されている場合、Pragmaは無視されます。"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.0, Pragma was defined as an extensible field for implementation-specified directives for recipients. This specification deprecates such extensions to improve interoperability.",
      "ja": "HTTP / 1.0では、プラグマは、受信者向けの実装指定のディレクティブ用の拡張可能なフィールドとして定義されていました。この仕様は、相互運用性を向上させるために、そのような拡張を廃止します。"
    },
    {
      "indent": 5,
      "text": "Pragma           = 1#pragma-directive\npragma-directive = \"no-cache\" / extension-pragma\nextension-pragma = token [ \"=\" ( token / quoted-string ) ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).",
      "ja": "Cache-Controlヘッダーフィールドがリクエストに存在しない場合、キャッシュはno-cacheリクエストプラグマディレクティブが「Cache-Control：no-cache」が存在する場合と同じ効果があると見なす必要があります（セクション5.2.1を参照）。 。"
    },
    {
      "indent": 3,
      "text": "When sending a no-cache request, a client ought to include both the pragma and cache-control directives, unless Cache-Control: no-cache is purposefully omitted to target other Cache-Control response directives at HTTP/1.1 caches. For example:",
      "ja": "キャッシュなしリクエストを送信するとき、クライアントはプラグマとキャッシュ制御ディレクティブの両方を含める必要があります。ただし、Cache-Control：no-cacheは、HTTP / 1.1キャッシュで他のキャッシュ制御応答ディレクティブをターゲットにするために意図的に省略されています。例えば："
    },
    {
      "indent": 5,
      "text": "GET / HTTP/1.1\nHost: www.example.com\nCache-Control: max-age=30\nPragma: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "will constrain HTTP/1.1 caches to serve a response no older than 30 seconds, while precluding implementations that do not understand Cache-Control from serving a cached response.",
      "ja": "Cache-Controlを理解しない実装がキャッシュされた応答を処理することを防ぎながら、HTTP / 1.1キャッシュを制限して30秒以内の応答を処理します。"
    },
    {
      "indent": 6,
      "text": "Note: Because the meaning of \"Pragma: no-cache\" in responses is not specified, it does not provide a reliable replacement for \"Cache-Control: no-cache\" in them.",
      "ja": "注：レスポンスでの「プラグマ：no-cache」の意味は指定されていないため、それらの「Cache-Control：no-cache」の信頼できる代替は提供されません。"
    },
    {
      "indent": 0,
      "text": "5.5. Warning",
      "section_title": true,
      "ja": "5.5. 警告"
    },
    {
      "indent": 3,
      "text": "The \"Warning\" header field is used to carry additional information about the status or transformation of a message that might not be reflected in the status code. This information is typically used to warn about possible incorrectness introduced by caching operations or transformations applied to the payload of the message.",
      "ja": "「警告」ヘッダーフィールドは、ステータスコードに反映されない可能性があるメッセージのステータスまたは変換に関する追加情報を伝えるために使用されます。この情報は通常、メッセージのペイロードに適用されるキャッシング操作または変換によって導入される可能性のある不正確さについて警告するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Warnings can be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguishes these responses from true failures.",
      "ja": "警告は、キャッシュ関連およびその他の目的で使用できます。エラーステータスコードではなく警告を使用することで、これらの応答を実際の障害と区別します。"
    },
    {
      "indent": 3,
      "text": "Warning header fields can in general be applied to any message, however some warn-codes are specific to caches and can only be applied to response messages.",
      "ja": "警告ヘッダーフィールドは一般にどのメッセージにも適用できますが、一部の警告コードはキャッシュに固有であり、応答メッセージにのみ適用できます。"
    },
    {
      "indent": 5,
      "text": "Warning = 1#warning-value",
      "ja": "警告= 1＃warning-value"
    },
    {
      "indent": 5,
      "text": "warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date ]",
      "ja": "警告値= warn-code SP warn-agent SP warn-text [SP warn-date]"
    },
    {
      "indent": 5,
      "text": "warn-code  = 3DIGIT\nwarn-agent = ( uri-host [ \":\" port ] ) / pseudonym\n                ; the name or pseudonym of the server adding\n                ; the Warning header field, for use in debugging\n                ; a single \"-\" is recommended when agent unknown\nwarn-text  = quoted-string\nwarn-date  = DQUOTE HTTP-date DQUOTE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Multiple warnings can be generated in a response (either by the origin server or by a cache), including multiple warnings with the same warn-code number that only differ in warn-text.",
      "ja": "warn-textのみが異なる、同じwarn-code番号を持つ複数の警告を含む、複数の警告が（オリジンサーバーまたはキャッシュによって）応答で生成されます。"
    },
    {
      "indent": 3,
      "text": "A user agent that receives one or more Warning header fields SHOULD inform the user of as many of them as possible, in the order that they appear in the response. Senders that generate multiple Warning header fields are encouraged to order them with this user agent behavior in mind. A sender that generates new Warning header fields MUST append them after any existing Warning header fields.",
      "ja": "1つ以上の警告ヘッダーフィールドを受け取るユーザーエージェントは、応答に表示される順序で、可能な限り多くの警告ヘッダーフィールドをユーザーに通知する必要があります（SHOULD）。複数の警告ヘッダーフィールドを生成する送信者は、このユーザーエージェントの動作を考慮してそれらを注文することをお勧めします。新しい警告ヘッダーフィールドを生成する送信者は、既存の警告ヘッダーフィールドの後にそれらを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning is required to be deleted from a stored response after validation:",
      "ja": "警告には3桁の警告コードが割り当てられています。 1桁目は、検証後に保存された応答から警告を削除する必要があるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o 1xx warn-codes describe the freshness or validation status of the response, and so they MUST be deleted by a cache after validation. They can only be generated by a cache when validating a cached entry, and MUST NOT be generated in any other situation.",
      "ja": "o 1xx warn-codesは、応答の鮮度または検証ステータスを説明するため、検証後にキャッシュによって削除する必要があります。これらは、キャッシュされたエントリを検証するときにのみキャッシュによって生成でき、他の状況では生成してはいけません。"
    },
    {
      "indent": 3,
      "text": "o 2xx warn-codes describe some aspect of the representation that is not rectified by a validation (for example, a lossy compression of the representation) and they MUST NOT be deleted by a cache after validation, unless a full response is sent, in which case they MUST be.",
      "ja": "o 2xx warn-codesは、検証によって修正されない表現の一部の側面（たとえば、表現の非可逆圧縮）を記述し、完全な応答が送信されない限り、検証後にキャッシュによって削除されてはなりません（MUST）。彼らはする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a sender generates one or more 1xx warn-codes in a message to be sent to a recipient known to implement only HTTP/1.0, the sender MUST include in each corresponding warning-value a warn-date that matches the Date header field in the message. For example:",
      "ja": "送信者がHTTP / 1.0のみを実装することがわかっている受信者に送信されるメッセージに1つ以上の1xx警告コードを生成する場合、送信者は、対応する各警告値に、日付ヘッダーフィールドに一致する警告日付を含める必要があります。メッセージ。例えば："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK\nDate: Sat, 25 Aug 2012 23:34:45 GMT\nWarning: 112 - \"network down\" \"Sat, 25 Aug 2012 23:34:45 GMT\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Warnings have accompanying warn-text that describes the error, e.g., for logging. It is advisory only, and its content does not affect interpretation of the warn-code.",
      "ja": "警告には、ロギングなどのエラーを説明する警告テキストが付随しています。これは助言のみであり、その内容は警告コードの解釈に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "If a recipient that uses, evaluates, or displays Warning header fields receives a warn-date that is different from the Date value in the same message, the recipient MUST exclude the warning-value containing that warn-date before storing, forwarding, or using the message. This allows recipients to exclude warning-values that were improperly retained after a cache validation. If all of the warning-values are excluded, the recipient MUST exclude the Warning header field as well.",
      "ja": "Warningヘッダーフィールドを使用、評価、または表示する受信者が同じメッセージの日付値とは異なるwarn-dateを受け取った場合、受信者は、保存、転送、または使用する前に、そのwarn-dateを含む警告値を除外する必要があります。メッセージ。これにより、受信者はキャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値が除外される場合、受信者は警告ヘッダーフィールドも除外する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following warn-codes are defined by this specification, each with a recommended warn-text in English, and a description of its meaning. The procedure for defining additional warn codes is described in Section 7.2.1.",
      "ja": "以下の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順については、セクション7.2.1で説明します。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Warning: 110 - \"Response is Stale\"",
      "section_title": true,
      "ja": "5.5.1. 警告：110-「応答が古くなっています」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this whenever the sent response is stale.",
      "ja": "送信された応答が古くなると、キャッシュはこれを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Warning: 111 - \"Revalidation Failed\"",
      "section_title": true,
      "ja": "5.5.2. 警告：111-「再検証に失敗しました」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this when sending a stale response because an attempt to validate the response failed, due to an inability to reach the server.",
      "ja": "キャッシュは、サーバーに到達できないために応答の検証に失敗したため、古い応答を送信するときにこれを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Warning: 112 - \"Disconnected Operation\"",
      "section_title": true,
      "ja": "5.5.3. 警告：112-「切断された操作」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this if it is intentionally disconnected from the rest of the network for a period of time.",
      "ja": "キャッシュは、意図的に一定期間ネットワークの残りの部分から切断されている場合、これを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.5.4. Warning: 113 - \"Heuristic Expiration\"",
      "section_title": true,
      "ja": "5.5.4. 警告：113-「ヒューリスティックな有効期限」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this if it heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.",
      "ja": "キャッシュは、ヒューリスティックに24時間を超えるフレッシュネスライフタイムを選択し、応答の経過時間が24時間を超える場合、これを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.5.5. Warning: 199 - \"Miscellaneous Warning\"",
      "section_title": true,
      "ja": "5.5.5. 警告：199-「その他の警告」"
    },
    {
      "indent": 3,
      "text": "The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.",
      "ja": "警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受け取るシステムは、ユーザーに警告を表示する以外に、自動化されたアクションを実行してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.5.6. Warning: 214 - \"Transformation Applied\"",
      "section_title": true,
      "ja": "5.5.6. 警告：214-「変換が適用されました」"
    },
    {
      "indent": 3,
      "text": "This Warning code MUST be added by a proxy if it applies any transformation to the representation, such as changing the content-coding, media-type, or modifying the representation data, unless this Warning code already appears in the response.",
      "ja": "この警告コードがすでに応答に含まれていない限り、コンテンツコーディング、メディアタイプの変更、または表現データの変更など、表現に変換を適用する場合は、プロキシによってこの警告コードを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.7. Warning: 299 - \"Miscellaneous Persistent Warning\"",
      "section_title": true,
      "ja": "5.5.7. 警告：299-「その他の永続的な警告」"
    },
    {
      "indent": 3,
      "text": "The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action.",
      "ja": "警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受信するシステムは、自動化されたアクションを実行してはなりません。"
    },
    {
      "indent": 0,
      "text": "6. History Lists",
      "section_title": true,
      "ja": "6. 履歴リスト"
    },
    {
      "indent": 3,
      "text": "User agents often have history mechanisms, such as \"Back\" buttons and history lists, that can be used to redisplay a representation retrieved earlier in a session.",
      "ja": "多くの場合、ユーザーエージェントには、「戻る」ボタンや履歴リストなどの履歴メカニズムがあり、セッションの初期に取得した表現を再表示するために使用できます。"
    },
    {
      "indent": 3,
      "text": "The freshness model (Section 4.2) does not necessarily apply to history mechanisms. That is, a history mechanism can display a previous representation even if it has expired.",
      "ja": "鮮度モデル（セクション4.2）は必ずしも履歴メカニズムに適用されません。つまり、履歴メカニズムは、期限が切れていても以前の表現を表示できます。"
    },
    {
      "indent": 3,
      "text": "This does not prohibit the history mechanism from telling the user that a view might be stale or from honoring cache directives (e.g., Cache-Control: no-store).",
      "ja": "これは、ビューが古くなっている可能性があることをユーザーに通知したり、キャッシュディレクティブ（たとえば、Cache-Control：no-store）を尊重したりすることを履歴メカニズムが禁止するものではありません。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Cache Directive Registry",
      "section_title": true,
      "ja": "7.1. キャッシュディレクティブレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Cache Directive Registry\" defines the namespace for the cache directives. It has been created and is now maintained at <http://www.iana.org/assignments/http-cache-directives>.",
      "ja": "「ハイパーテキスト転送プロトコル（HTTP）キャッシュディレクティブレジストリ」は、キャッシュディレクティブの名前空間を定義します。これは作成され、現在<http://www.iana.org/assignments/http-cache-directives>で保守されています。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Procedure",
      "section_title": true,
      "ja": "7.1.1. 手順"
    },
    {
      "indent": 3,
      "text": "A registration MUST include the following fields:",
      "ja": "登録には次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Cache Directive Name o Pointer to specification text",
      "ja": "o キャッシュディレクティブ名o仕様テキストへのポインター"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).",
      "ja": "この名前空間に追加される値には、IETFレビューが必要です（[RFC5226]、セクション4.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Considerations for New Cache Control Directives",
      "section_title": true,
      "ja": "7.1.2. 新しいキャッシュ制御ディレクティブに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "New extension directives ought to consider defining:",
      "ja": "新しい拡張ディレクティブは次の定義を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "o What it means for a directive to be specified multiple times,",
      "ja": "o ディレクティブを複数回指定することの意味、"
    },
    {
      "indent": 3,
      "text": "o When the directive does not take an argument, what it means when an argument is present,",
      "ja": "o ディレクティブが引数を取らない場合、引数が存在する場合の意味は、"
    },
    {
      "indent": 3,
      "text": "o When the directive requires an argument, what it means when it is missing,",
      "ja": "o ディレクティブが引数を必要とする場合、それが欠落している場合の意味、"
    },
    {
      "indent": 3,
      "text": "o Whether the directive is specific to requests, responses, or able to be used in either.",
      "ja": "o ディレクティブが要求、応答に固有であるか、またはいずれかで使用できるかどうか。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.2.3.",
      "ja": "セクション5.2.3も参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Registrations",
      "section_title": true,
      "ja": "7.1.3. 登録"
    },
    {
      "indent": 3,
      "text": "The registry has been populated with the registrations below:",
      "ja": "レジストリには、以下の登録が含まれています。"
    },
    {
      "indent": 3,
      "text": "+------------------------+----------------------------------+\n| Cache Directive        | Reference                        |\n+------------------------+----------------------------------+\n| max-age                | Section 5.2.1.1, Section 5.2.2.8 |\n| max-stale              | Section 5.2.1.2                  |\n| min-fresh              | Section 5.2.1.3                  |\n| must-revalidate        | Section 5.2.2.1                  |\n| no-cache               | Section 5.2.1.4, Section 5.2.2.2 |\n| no-store               | Section 5.2.1.5, Section 5.2.2.3 |\n| no-transform           | Section 5.2.1.6, Section 5.2.2.4 |\n| only-if-cached         | Section 5.2.1.7                  |\n| private                | Section 5.2.2.6                  |\n| proxy-revalidate       | Section 5.2.2.7                  |\n| public                 | Section 5.2.2.5                  |\n| s-maxage               | Section 5.2.2.9                  |\n| stale-if-error         | [RFC5861], Section 4             |\n| stale-while-revalidate | [RFC5861], Section 3             |\n+------------------------+----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. Warn Code Registry",
      "section_title": true,
      "ja": "7.2. 警告コードレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Warn Codes\" registry defines the namespace for warn codes. It has been created and is now maintained at <http://www.iana.org/assignments/http-warn-codes>.",
      "ja": "「ハイパーテキスト転送プロトコル（HTTP）警告コード」レジストリは、警告コードの名前空間を定義します。これは作成され、現在<http://www.iana.org/assignments/http-warn-codes>で維持されています。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Procedure",
      "section_title": true,
      "ja": "7.2.1. 手順"
    },
    {
      "indent": 3,
      "text": "A registration MUST include the following fields:",
      "ja": "登録には次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Warn Code (3 digits)",
      "ja": "o 警告コード（3桁）"
    },
    {
      "indent": 3,
      "text": "o Short Description",
      "ja": "o 簡単な説明"
    },
    {
      "indent": 3,
      "text": "o Pointer to specification text",
      "ja": "o 仕様テキストへのポインタ"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).",
      "ja": "この名前空間に追加される値には、IETFレビューが必要です（[RFC5226]、セクション4.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Registrations",
      "section_title": true,
      "ja": "7.2.2. 登録"
    },
    {
      "indent": 3,
      "text": "The registry has been populated with the registrations below:",
      "ja": "レジストリには、以下の登録が含まれています。"
    },
    {
      "indent": 3,
      "text": "+-----------+----------------------------------+---------------+\n| Warn Code | Short Description                | Reference     |\n+-----------+----------------------------------+---------------+\n| 110       | Response is Stale                | Section 5.5.1 |\n| 111       | Revalidation Failed              | Section 5.5.2 |\n| 112       | Disconnected Operation           | Section 5.5.3 |\n| 113       | Heuristic Expiration             | Section 5.5.4 |\n| 199       | Miscellaneous Warning            | Section 5.5.5 |\n| 214       | Transformation Applied           | Section 5.5.6 |\n| 299       | Miscellaneous Persistent Warning | Section 5.5.7 |\n+-----------+----------------------------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3. Header Field Registration",
      "section_title": true,
      "ja": "7.3. ヘッダーフィールドの登録"
    },
    {
      "indent": 3,
      "text": "HTTP header fields are registered within the \"Message Headers\" registry maintained at <http://www.iana.org/assignments/message-headers/>.",
      "ja": "HTTPヘッダーフィールドは、<http://www.iana.org/assignments/message-headers/>で管理されている「メッセージヘッダー」レジストリ内に登録されます。"
    },
    {
      "indent": 3,
      "text": "This document defines the following HTTP header fields, so the \"Permanent Message Header Field Names\" registry has been updated accordingly (see [BCP90]).",
      "ja": "このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、「Permanent Message Header Field Names」レジストリはそれに応じて更新されています（[BCP90]を参照）。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------+----------+-------------+\n| Header Field Name | Protocol | Status   | Reference   |\n+-------------------+----------+----------+-------------+\n| Age               | http     | standard | Section 5.1 |\n| Cache-Control     | http     | standard | Section 5.2 |\n| Expires           | http     | standard | Section 5.3 |\n| Pragma            | http     | standard | Section 5.4 |\n| Warning           | http     | standard | Section 5.5 |\n+-------------------+----------+----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The change controller is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "変更管理者は、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform developers, information providers, and users of known security concerns specific to HTTP caching. More general security considerations are addressed in HTTP messaging [RFC7230] and semantics [RFC7231].",
      "ja": "このセクションは、HTTPキャッシングに固有の既知のセキュリティ問題を開発者、情報プロバイダー、およびユーザーに通知することを目的としています。セキュリティに関するより一般的な考慮事項は、HTTPメッセージング[RFC7230]およびセマンティクス[RFC7231]で対処されています。"
    },
    {
      "indent": 3,
      "text": "Caches expose additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents need to be protected as sensitive information.",
      "ja": "キャッシュの内容は悪意のある悪用の魅力的なターゲットであるため、キャッシュは潜在的な脆弱性をさらけ出します。キャッシュの内容はHTTPリクエストの完了後も存続するため、ユーザーがネットワークから情報が削除されたとユーザーが信じた後も、キャッシュへの攻撃によって情報が明らかになる可能性があります。したがって、キャッシュの内容は機密情報として保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, various attacks might be amplified by being stored in a shared cache; such \"cache poisoning\" attacks use the cache to distribute a malicious payload to many clients, and are especially effective when an attacker can use implementation flaws, elevated privileges, or other techniques to insert such a response into a cache. One common attack vector for cache poisoning is to exploit differences in message parsing on proxies and in user agents; see Section 3.3.3 of [RFC7230] for the relevant requirements.",
      "ja": "特に、さまざまな攻撃が共有キャッシュに格納されることで増幅される可能性があります。このような「キャッシュポイズニング」攻撃は、キャッシュを使用して悪意のあるペイロードを多くのクライアントに配布します。特に攻撃者が実装の欠陥、昇格された特権、またはその他の手法を使用してそのような応答をキャッシュに挿入できる場合に効果的です。キャッシュポイズニングの一般的な攻撃方法の1つは、プロキシとユーザーエージェントのメッセージ解析の違いを悪用することです。関連要件については、[RFC7230]のセクション3.3.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Likewise, implementation flaws (as well as misunderstanding of cache operation) might lead to caching of sensitive information (e.g., authentication credentials) that is thought to be private, exposing it to unauthorized parties.",
      "ja": "同様に、実装の欠陥（およびキャッシュ操作の誤解）は、機密であると考えられる機密情報（認証資格情報など）のキャッシングにつながり、それを無許可の第三者に公開する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the very use of a cache can bring about privacy concerns. For example, if two users share a cache, and the first one browses to a site, the second may be able to detect that the other has been to that site, because the resources from it load more quickly, thanks to the cache.",
      "ja": "さらに、キャッシュの使用そのものがプライバシーの問題を引き起こす可能性があります。たとえば、2人のユーザーがキャッシュを共有し、最初のユーザーがサイトを閲覧した場合、2番目のユーザーは、もう1人がそのサイトにアクセスしたことを検出できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that the Set-Cookie response header field [RFC6265] does not inhibit caching; a cacheable response with a Set-Cookie header field can be (and often is) used to satisfy subsequent requests to caches. Servers who wish to control caching of these responses are encouraged to emit appropriate Cache-Control response header fields.",
      "ja": "Set-Cookie応答ヘッダーフィールド[RFC6265]はキャッシュを抑制しないことに注意してください。 Set-Cookieヘッダーフィールドを持つキャッシュ可能な応答は、キャッシュへの後続の要求を満たすために使用できます（多くの場合、使用されます）。これらの応答のキャッシュを制御するサーバーは、適切なCache-Control応答ヘッダーフィールドを発行することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "See Section 10 of [RFC7230].",
      "ja": "[RFC7230]のセクション10をご覧ください。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, June 2014.",
      "ja": "[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014.",
      "ja": "[RFC7231]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, June 2014.",
      "ja": "[RFC7232]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Conditional Requests」、RFC 7232、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, June 2014.",
      "ja": "[RFC7233] Fielding、R。、編、Lafon、Y。、編、およびJ. Reschke、編、「Hypertext Transfer Protocol（HTTP / 1.1）：Range Requests」、RFC 7233、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014.",
      "ja": "[RFC7235]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Authentication」、RFC 7235、2014年6月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BCP90] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[BCP90] Klyne、G.、Nottingham、M。、およびJ. Mogul、「メッセージヘッダーフィールドの登録手順」、BCP 90、RFC 3864、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。、およびT. Berners-Lee、「ハイパーテキスト転送プロトコル-HTTP / 1.1」 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5861] Nottingham, M., \"HTTP Cache-Control Extensions for Stale Content\", RFC 5861, April 2010.",
      "ja": "[RFC5861] Nottingham、M。、「HTTP Cache-Control Extensions for Stale Content」、RFC 5861、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, June 2010.",
      "ja": "[RFC5905] Mills、D.、Martin、J.、Ed。、Burbank、J。、およびW. Kasch、「Network Time Protocol Version 4：Protocol and Algorithms Specification」、RFC 5905、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011.",
      "ja": "[RFC6265]バース、A。、「HTTP状態管理メカニズム」、RFC 6265、2011年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Changes from RFC 2616",
      "section_title": true,
      "ja": "付録A. RFC 2616からの変更点"
    },
    {
      "indent": 3,
      "text": "The specification has been substantially rewritten for clarity.",
      "ja": "仕様は明確にするために大幅に書き直されました。"
    },
    {
      "indent": 3,
      "text": "The conditions under which an authenticated response can be cached have been clarified. (Section 3.2)",
      "ja": "認証済み応答をキャッシュできる条件が明確になりました。 （セクション3.2）"
    },
    {
      "indent": 3,
      "text": "New status codes can now define that caches are allowed to use heuristic freshness with them. Caches are now allowed to calculate heuristic freshness for URIs with query components. (Section 4.2.2)",
      "ja": "新しいステータスコードで、キャッシュがヒューリスティックな鮮度を使用できるように定義できるようになりました。キャッシュは、クエリコンポーネントを使用してURIのヒューリスティックな鮮度を計算できるようになりました。 （セクション4.2.2）"
    },
    {
      "indent": 3,
      "text": "The algorithm for calculating age is now less conservative. Caches are now required to handle dates with time zones as if they're invalid, because it's not possible to accurately guess. (Section 4.2.3)",
      "ja": "年齢を計算するアルゴリズムは保守的ではなくなりました。正確に推測することができないため、キャッシュは、タイムゾーンのある日付を無効であるかのように処理する必要があります。 （セクション4.2.3）"
    },
    {
      "indent": 3,
      "text": "The Content-Location response header field is no longer used to determine the appropriate response to use when validating. (Section 4.3)",
      "ja": "Content-Location応答ヘッダーフィールドは、検証時に使用する適切な応答を決定するために使用されなくなりました。 （セクション4.3）"
    },
    {
      "indent": 3,
      "text": "The algorithm for selecting a cached negotiated response to use has been clarified in several ways. In particular, it now explicitly allows header-specific canonicalization when processing selecting header fields. (Section 4.1)",
      "ja": "キャッシュされたネゴシエートされた応答を選択して使用するアルゴリズムは、いくつかの方法で明確にされています。特に、ヘッダーフィールドの選択を処理するときに、ヘッダー固有の正規化を明示的に許可するようになりました。 （セクション4.1）"
    },
    {
      "indent": 3,
      "text": "Requirements regarding denial-of-service attack avoidance when performing invalidation have been clarified. (Section 4.4)",
      "ja": "無効化を実行する際のサービス拒否攻撃の回避に関する要件が明確になりました。 （セクション4.4）"
    },
    {
      "indent": 3,
      "text": "Cache invalidation only occurs when a successful response is received. (Section 4.4)",
      "ja": "キャッシュの無効化は、正常な応答が受信された場合にのみ発生します。 （セクション4.4）"
    },
    {
      "indent": 3,
      "text": "Cache directives are explicitly defined to be case-insensitive. Handling of multiple instances of cache directives when only one is expected is now defined. (Section 5.2)",
      "ja": "キャッシュディレクティブは、大文字と小文字を区別しないように明示的に定義されています。キャッシュディレクティブのインスタンスが1つだけ必要な場合の複数のインスタンスの処理が定義されました。 （セクション5.2）"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" request directive doesn't apply to responses; i.e., a cache can satisfy a request with no-store on it and does not invalidate it. (Section 5.2.1.5)",
      "ja": "\"no-store\"リクエストディレクティブはレスポンスには適用されません。つまり、キャッシュはストアを持たないリクエストに対応でき、キャッシュを無効化しません。 （セクション5.2.1.5）"
    },
    {
      "indent": 3,
      "text": "The qualified forms of the private and no-cache cache directives are noted to not be widely implemented; for example, \"private=foo\" is interpreted by many caches as simply \"private\". Additionally, the meaning of the qualified form of no-cache has been clarified. (Section 5.2.2)",
      "ja": "限定された形式のプライベートおよび非キャッシュキャッシュディレクティブは、広く実装されていないことが注記されています。たとえば、「private = foo」は、多くのキャッシュによって単に「private」と解釈されます。さらに、ノーキャッシュの修飾形式の意味が明確になりました。 （セクション5.2.2）"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" response directive's meaning has been clarified. (Section 5.2.2.2)",
      "ja": "「キャッシュなし」応答ディレクティブの意味が明確になりました。 （セクション5.2.2.2）"
    },
    {
      "indent": 3,
      "text": "The one-year limit on Expires header field values has been removed; instead, the reasoning for using a sensible value is given. (Section 5.3)",
      "ja": "Expiresヘッダーフィールド値の1年間の制限が削除されました。代わりに、実用的な値を使用する理由が与えられます。 （セクション5.3）"
    },
    {
      "indent": 3,
      "text": "The Pragma header field is now only defined for backwards compatibility; future pragmas are deprecated. (Section 5.4)",
      "ja": "Pragmaヘッダーフィールドは、下位互換性のためにのみ定義されています。将来のプラグマは非推奨です。 （5.4節）"
    },
    {
      "indent": 3,
      "text": "Some requirements regarding production and processing of the Warning header fields have been relaxed, as it is not widely implemented. Furthermore, the Warning header field no longer uses RFC 2047 encoding, nor does it allow multiple languages, as these aspects were not implemented. (Section 5.5)",
      "ja": "Warningヘッダーフィールドの生成と処理に関するいくつかの要件は、広く実装されていないため、緩和されています。さらに、WarningヘッダーフィールドはRFC 2047エンコーディングを使用しなくなりました。また、これらの側面が実装されていなかったため、複数の言語を許可していません。 （セクション5.5）"
    },
    {
      "indent": 3,
      "text": "This specification introduces the Cache Directive and Warn Code Registries, and defines considerations for new cache directives. (Section 7.1 and Section 7.2)",
      "ja": "この仕様では、キャッシュディレクティブと警告コードレジストリを紹介し、新しいキャッシュディレクティブに関する考慮事項を定義します。 （セクション7.1およびセクション7.2）"
    },
    {
      "indent": 0,
      "text": "Appendix B. Imported ABNF",
      "section_title": true,
      "ja": "付録B.インポートされたABNF"
    },
    {
      "indent": 3,
      "text": "The following core rules are included by reference, as defined in Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII character).",
      "ja": "[RFC5234]の付録B.1で定義されている次のコアルールが参照として含まれています：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（目に見えるUS-ASCII文字） ）。"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in [RFC7230]:",
      "ja": "以下のルールは[RFC7230]で定義されています："
    },
    {
      "indent": 5,
      "text": "OWS           = <OWS, see [RFC7230], Section 3.2.3>\nfield-name    = <field-name, see [RFC7230], Section 3.2>\nquoted-string = <quoted-string, see [RFC7230], Section 3.2.6>\ntoken         = <token, see [RFC7230], Section 3.2.6>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "port          = <port, see [RFC7230], Section 2.7>\npseudonym     = <pseudonym, see [RFC7230], Section 5.7.1>\nuri-host      = <uri-host, see [RFC7230], Section 2.7>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The rules below are defined in other parts:",
      "ja": "以下のルールは他の部分で定義されています："
    },
    {
      "indent": 5,
      "text": "HTTP-date     = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Collected ABNF",
      "section_title": true,
      "ja": "付録C.収集されたABNF"
    },
    {
      "indent": 3,
      "text": "In the collected ABNF below, list rules are expanded as per Section 1.2 of [RFC7230].",
      "ja": "以下の収集されたABNFでは、リストルールが[RFC7230]のセクション1.2に従って拡張されています。"
    },
    {
      "indent": 3,
      "text": "Age = delta-seconds",
      "ja": "年齢=デルタ秒"
    },
    {
      "indent": 3,
      "text": "Cache-Control = *( \",\" OWS ) cache-directive *( OWS \",\" [ OWS\n cache-directive ] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Expires = HTTP-date",
      "ja": "Expires = HTTP-date"
    },
    {
      "indent": 3,
      "text": "HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OWS = <OWS, see [RFC7230], Section 3.2.3>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pragma = *( \",\" OWS ) pragma-directive *( OWS \",\" [ OWS\n pragma-directive ] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Warning = *( \",\" OWS ) warning-value *( OWS \",\" [ OWS warning-value ]\n )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cache-directive = token [ \"=\" ( token / quoted-string ) ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "delta-seconds = 1*DIGIT",
      "ja": "デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "extension-pragma = token [ \"=\" ( token / quoted-string ) ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "field-name = <field-name, see [RFC7230], Section 3.2>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "port = <port, see [RFC7230], Section 2.7>\npragma-directive = \"no-cache\" / extension-pragma\npseudonym = <pseudonym, see [RFC7230], Section 5.7.1>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "token = <token, see [RFC7230], Section 3.2.6>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uri-host = <uri-host, see [RFC7230], Section 2.7>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "warn-agent = ( uri-host [ \":\" port ] ) / pseudonym\nwarn-code = 3DIGIT\nwarn-date = DQUOTE HTTP-date DQUOTE\nwarn-text = quoted-string\nwarning-value = warn-code SP warn-agent SP warn-text [ SP warn-date\n ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "索引"
    },
    {
      "indent": 3,
      "text": "1 110 (warn-code) 31 111 (warn-code) 31 112 (warn-code) 31 113 (warn-code) 31 199 (warn-code) 32",
      "ja": "1 110（警告コード）31111（警告コード）31112（警告コード）31113（警告コード）31 199（警告コード）32"
    },
    {
      "indent": 3,
      "text": "2 214 (warn-code) 32 299 (warn-code) 32",
      "ja": "2214（警告コード）32299（警告コード）32"
    },
    {
      "indent": 3,
      "text": "A age 11 Age header field 21",
      "ja": "11歳のヘッダーフィールド21"
    },
    {
      "indent": 3,
      "text": "C cache 4 cache entry 5 cache key 5-6 Cache-Control header field 21",
      "ja": "Cキャッシュ4キャッシュエントリ5キャッシュキー5-6キャッシュ制御ヘッダーフィールド21"
    },
    {
      "indent": 3,
      "text": "D Disconnected Operation (warn-text) 31",
      "ja": "D切断された操作（警告テキスト）31"
    },
    {
      "indent": 3,
      "text": "E Expires header field 28 explicit expiration time 11",
      "ja": "E Expiresヘッダーフィールド28明示的な有効期限11"
    },
    {
      "indent": 3,
      "text": "F fresh 11 freshness lifetime 11",
      "ja": "Fフレッシュ11フレッシュネスライフタイム11"
    },
    {
      "indent": 3,
      "text": "G Grammar Age 21 Cache-Control 22 cache-directive 22 delta-seconds 5 Expires 28 extension-pragma 29 Pragma 29 pragma-directive 29 warn-agent 29 warn-code 29 warn-date 29 warn-text 29 Warning 29 warning-value 29",
      "ja": "G文法年齢21キャッシュ制御22キャッシュ指令22デルタ秒5有効期限28拡張プラグマ29プラグマ29プラグマ指令29 warn-agent 29 warn-code 29 warn-date 29 warn-text 29 Warning 29 warning-value 29"
    },
    {
      "indent": 3,
      "text": "H Heuristic Expiration (warn-text) 31 heuristic expiration time 11 M max-age (cache directive) 22, 26 max-stale (cache directive) 22 min-fresh (cache directive) 22 Miscellaneous Persistent Warning (warn-text) 32 Miscellaneous Warning (warn-text) 32 must-revalidate (cache directive) 24",
      "ja": "Hヒューリスティックな有効期限（警告テキスト）31ヒューリスティックな有効期限11 M max-age（キャッシュディレクティブ）22、26 max-stale（キャッシュディレクティブ）22 min-fresh（キャッシュディレクティブ）22その他の永続的な警告（warn-text）32その他警告（warn-text）32再検証が必要（キャッシュディレクティブ）24"
    },
    {
      "indent": 3,
      "text": "N no-cache (cache directive) 23, 25 no-store (cache directive) 23, 24 no-transform (cache directive) 23, 25",
      "ja": "Nキャッシュなし（キャッシュディレクティブ）23、25非ストア（キャッシュディレクティブ）23、24非変換（キャッシュディレクティブ）23、25"
    },
    {
      "indent": 3,
      "text": "O only-if-cached (cache directive) 23",
      "ja": "O only-if-cached（キャッシュディレクティブ）23"
    },
    {
      "indent": 3,
      "text": "P Pragma header field 29 private (cache directive) 25 private cache 4 proxy-revalidate (cache directive) 26 public (cache directive) 25",
      "ja": "Pプラグマヘッダーフィールド29プライベート（キャッシュディレクティブ）25プライベートキャッシュ4プロキシ再検証（キャッシュディレクティブ）26パブリック（キャッシュディレクティブ）25"
    },
    {
      "indent": 3,
      "text": "R Response is Stale (warn-text) 30 Revalidation Failed (warn-text) 31",
      "ja": "R応答が古くなっています（警告テキスト）30再検証に失敗しました（警告テキスト）31"
    },
    {
      "indent": 3,
      "text": "S s-maxage (cache directive) 27 shared cache 4 stale 11 strong validator 18",
      "ja": "S s-maxage（キャッシュディレクティブ）27共有キャッシュ4古くなった11強力なバリデーター18"
    },
    {
      "indent": 3,
      "text": "T Transformation Applied (warn-text) 32",
      "ja": "T Transformation Applied（warn-text）32"
    },
    {
      "indent": 3,
      "text": "V validator 16",
      "ja": "バリデーター16へ"
    },
    {
      "indent": 3,
      "text": "W Warning header field 29",
      "ja": "W警告ヘッダーフィールド29"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding (editor) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA",
      "ja": "ロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USA"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com\nURI:   http://roy.gbiv.com/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mark Nottingham (editor) Akamai",
      "ja": "マーク・ノッティンガム（編集者）アカマイ"
    },
    {
      "indent": 3,
      "text": "EMail: mnot@mnot.net\nURI:   http://www.mnot.net/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "Julian F. Reschke（編集者）greenbytes GmbH Hafenweg 16 Muenster、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de\nURI:   http://greenbytes.de/tech/webdav/",
      "raw": true,
      "ja": ""
    }
  ]
}