{
  "title": {
    "text": "RFC 7861 - Remote Procedure Call (RPC) Security Version 3",
    "ja": "RFC 7861 - リモートプロシージャコール（RPC）セキュリティバージョン3"
  },
  "number": 7861,
  "created_at": "2020-08-29 16:48:29.564028+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        W. Adamson\nRequest for Comments: 7861                                        NetApp\nUpdates: 5403                                                N. Williams\nCategory: Standards Track                                   Cryptonector\nISSN: 2070-1721                                            November 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Remote Procedure Call (RPC) Security Version 3",
      "ja": "リモートプロシージャコール（RPC）セキュリティバージョン3"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies version 3 of the Remote Procedure Call (RPC) security protocol (RPCSEC_GSS). This protocol provides support for multi-principal authentication of client hosts and user principals to a server (constructed by generic composition), security label assertions for multi-level security and type enforcement, structured privilege assertions, and channel bindings. This document updates RFC 5403.",
      "ja": "このドキュメントでは、リモートプロシージャコール（RPC）セキュリティプロトコル（RPCSEC_GSS）のバージョン3について説明します。このプロトコルは、サーバーへのクライアントホストとユーザープリンシパルのマルチプリンシパル認証（一般的な構成によって構築）、マルチレベルのセキュリティとタイプの実施のためのセキュリティラベルアサーション、構造化された特権アサーション、およびチャネルバインディングをサポートします。このドキュメントはRFC 5403を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7861.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7861で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction and Motivation .....................................2\n   1.1. Requirements Language ......................................3\n   1.2. Added Functionality ........................................4\n   1.3. XDR Code Extraction ........................................5\n2. The RPCSEC_GSSv3 Protocol .......................................6\n   2.1. Compatibility with RPCSEC_GSSv2 ............................6\n   2.2. Version Negotiation ........................................6\n   2.3. New Reply Verifier .........................................7\n   2.4. XDR Code Preliminaries .....................................8\n   2.5. RPCSEC_GSS_BIND_CHANNEL Operation .........................10\n   2.6. New auth_stat Values ......................................10\n   2.7. New Control Procedures ....................................10\n        2.7.1. New Control Procedure - RPCSEC_GSS_CREATE ..........12\n        2.7.2. New Control Procedure - RPCSEC_GSS_LIST ............20\n   2.8. Extensibility .............................................21\n3. Operational Recommendation for Deployment ......................21\n4. Security Considerations ........................................21\n5. IANA Considerations ............................................22\n   5.1. New RPC Authentication Status Numbers .....................22\n   5.2. Structured Privilege Name Definitions .....................23\n        5.2.1. Initial Registry ...................................24\n        5.2.2. Updating Registrations .............................24\n6. References .....................................................25\n   6.1. Normative References ......................................25\n   6.2. Informative References ....................................26\nAcknowledgments ...................................................26\nAuthors' Addresses ................................................26",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction and Motivation",
      "section_title": true,
      "ja": "1. 紹介と動機"
    },
    {
      "indent": 3,
      "text": "The original Remote Procedure Call (RPC) security protocol (RPCSEC_GSS) [RFC2203] provided for authentication of RPC clients and servers to each other using the Generic Security Service Application Programming Interface (GSS-API) [RFC2743]. The second version of RPCSEC_GSS [RFC5403] added support for channel bindings [RFC5056].",
      "ja": "元のリモートプロシージャコール（RPC）セキュリティプロトコル（RPCSEC_GSS）[RFC2203]は、Generic Security Serviceアプリケーションプログラミングインターフェイス（GSS-API）[RFC2743]を使用してRPCクライアントとサーバーを相互に認証するために提供されていました。 RPCSEC_GSS [RFC5403]の2番目のバージョンでは、チャネルバインディングのサポート[RFC5056]が追加されました。"
    },
    {
      "indent": 3,
      "text": "Existing GSS-API mechanisms are insufficient for communicating certain authorization and authentication information to a server. The GSS-API and its mechanisms certainly could be extended to address this shortcoming. However, it is addressed here at the application layer, i.e., in RPCSEC_GSS.",
      "ja": "既存のGSS-APIメカニズムは、特定の承認および認証情報をサーバーに伝達するには不十分です。 GSS-APIとそのメカニズムは、この欠点に対処するために確実に拡張できます。ただし、ここではアプリケーション層、つまりRPCSEC_GSSで対処されます。"
    },
    {
      "indent": 3,
      "text": "A major motivation for version 3 of RPCSEC_GSS (RPCSEC_GSSv3) is to add support for multi-level (labeled) security and server-side copy for NFSv4.",
      "ja": "RPCSEC_GSS（RPCSEC_GSSv3）のバージョン3の主な動機は、マルチレベル（ラベル付き）セキュリティとNFSv4のサーバー側コピーのサポートを追加することです。"
    },
    {
      "indent": 3,
      "text": "Multi-Level Security (MLS) is a traditional model where subjects (processes) are given a security level (Unclassified, Secret, Top Secret, etc.) and objects (files) are given security labels that mandate the access of the subject to the object (see Section 9.1 of [RFC7862]).",
      "ja": "マルチレベルセキュリティ（MLS）は、サブジェクト（プロセス）にセキュリティレベル（未分類、シークレット、トップシークレットなど）が付与され、オブジェクト（ファイル）にサブジェクトへのアクセスを義務付けるセキュリティラベルが付与される従来のモデルです。オブジェクト（[RFC7862]のセクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS (see Section 9 of [RFC7862]) uses an MLS policy with Mandatory Access Control (MAC) systems as defined in [RFC4949]. Labeled NFS stores MAC file object labels on the NFS server and enables client Guest Mode MAC as described in Section 9.5.3 of [RFC7862]. RPCSEC_GSSv3 label assertions assert client MAC process subject labels to enable Full Mode MAC when combined with Labeled NFS as described in Section 9.5.1 of [RFC7862].",
      "ja": "ラベル付きNFS（[RFC7862]のセクション9を参照）は、[RFC4949]で定義されている強制アクセス制御（MAC）システムでMLSポリシーを使用します。 [RFC7862]のセクション9.5.3で説明されているように、ラベル付きNFSは、NFSサーバーにMACファイルオブジェクトラベルを保存し、クライアントゲストモードMACを有効にします。 [RFC7862]のセクション9.5.1で説明されているように、RPCSEC_GSSv3ラベルアサーションは、クライアントのMACプロセスサブジェクトラベルをアサートして、ラベル付きNFSと組み合わせるとフルモードMACを有効にします。"
    },
    {
      "indent": 3,
      "text": "A traditional inter-server file copy entails the user gaining access to a file on the source, reading it, and writing it to a file on the destination. In secure NFSv4 inter-server server-side copy (see Section 4 of [RFC7862]), the user first secures access to both source and destination files and then uses NFSv4.2-defined RPCSEC_GSSv3 structured privileges to authorize the destination to copy the file from the source on behalf of the user.",
      "ja": "従来のサーバー間ファイルコピーでは、ユーザーがソース上のファイルにアクセスし、それを読み取り、宛先上のファイルに書き込む必要がありました。安全なNFSv4サーバー間サーバー側コピー（[RFC7862]のセクション4を参照）では、ユーザーはまずソースファイルと宛先ファイルの両方へのアクセスを保護し、次にNFSv4.2で定義されたRPCSEC_GSSv3構造化特権を使用して宛先にファイルのコピーを許可しますユーザーに代わってソースから。"
    },
    {
      "indent": 3,
      "text": "Multi-principal authentication can be used to address shared cache poisoning attacks (see Section 9 of [AFS-RXGK]) on the client cache by a user. As described in Section 7 of [AFS-RXGK], multi-user machines with a single cache manager can fetch and cache data on a user's behalf and re-display it for another user from the cache without refetching the data from the server. The initial data acquisition is authenticated by the first user's credentials, and if only that user's credentials are used, it may be possible for a malicious user or users to \"poison\" the cache for other users by introducing bogus data into the cache.",
      "ja": "マルチプリンシパル認証は、ユーザーによるクライアントキャッシュでの共有キャッシュポイズニング攻撃（[AFS-RXGK]のセクション9を参照）に対処するために使用できます。 [AFS-RXGK]のセクション7で説明されているように、単一のキャッシュマネージャーを備えたマルチユーザーマシンは、ユーザーに代わってデータをフェッチしてキャッシュし、サーバーからデータを再フェッチすることなく別のユーザーにキャッシュから再表示できます。最初のデータ取得は最初のユーザーの資格情報によって認証され、そのユーザーの資格情報のみが使用されている場合、悪意のあるユーザーが偽のデータをキャッシュに導入することにより、他のユーザーのキャッシュを「汚染」する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Another use of the multi-principal assertion is the secure conveyance of privilege information for processes running with more (or even with less) privilege than the user normally would be accorded.",
      "ja": "マルチプリンシパルアサーションの別の用途は、ユーザーが通常付与されるよりも多い（または少ない場合でも）特権で実行されているプロセスの特権情報の安全な伝達です。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Added Functionality",
      "section_title": true,
      "ja": "1.2. 追加された機能"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 (RPCSEC_GSSv3) is the same as RPCSEC_GSSv2 [RFC5403], except that the following assertions of authority have been added:",
      "ja": "RPCSEC_GSSバージョン3（RPCSEC_GSSv3）はRPCSEC_GSSv2 [RFC5403]と同じですが、以下の権限の表明が追加されています。"
    },
    {
      "indent": 3,
      "text": "o Security labels for Full Mode security type enforcement, and other labeled security models (see Section 9.5.1 of [RFC7862]).",
      "ja": "o フルモードのセキュリティタイプの実施のためのセキュリティラベル、およびその他のラベル付きセキュリティモデル（[RFC7862]のセクション9.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o Application-specific structured privileges. These allow an RPC application client to pass structured information to the corresponding application code in a server to control the use of the privilege and/or the conditions in which the privilege may be exercised. For an example, see server-side copy as described in [RFC7862].",
      "ja": "o アプリケーション固有の構造化特権。これらにより、RPCアプリケーションクライアントは、構造化された情報をサーバー内の対応するアプリケーションコードに渡して、特権の使用や特権が行使される条件を制御できます。例については、[RFC7862]で説明されているサーバー側のコピーを参照してください。"
    },
    {
      "indent": 3,
      "text": "o Multi-principal authentication of the client host and user to the server, done by binding two RPCSEC_GSS handles.",
      "ja": "o 2つのRPCSEC_GSSハンドルをバインドして行われる、クライアントホストとユーザーのサーバーへのマルチプリンシパル認証。"
    },
    {
      "indent": 3,
      "text": "o Simplified channel binding.",
      "ja": "o 簡略化されたチャネルバインディング。"
    },
    {
      "indent": 3,
      "text": "Assertions of labels and privileges are evaluated by the server, which may then map the asserted values to other values, all according to server-side policy. See [RFC7862].",
      "ja": "ラベルと権限のアサーションはサーバーによって評価され、サーバー側のポリシーに従って、アサートされた値を他の値にマッピングする場合があります。 [RFC7862]を参照してください。"
    },
    {
      "indent": 3,
      "text": "An option for enumerating server-supported Label Format Specifiers (LFSs) is provided. See Section 9.1 of [RFC7862].",
      "ja": "サーバーがサポートするラベル形式指定子（LFS）を列挙するオプションが提供されます。 [RFC7862]のセクション9.1をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Note that there is no RPCSEC_GSS_CREATE payload that is REQUIRED to implement. RPCSEC_GSSv3 implementations are feature driven. Besides implementing the RPCSEC_GSS_CREATE operation and payloads for the desired features, all RPCSEC_GSSv3 implementations MUST implement:",
      "ja": "実装が必要なRPCSEC_GSS_CREATEペイロードはないことに注意してください。 RPCSEC_GSSv3の実装は機能主導です。 RPCSEC_GSS_CREATE操作と目的の機能のペイロードを実装するほかに、すべてのRPCSEC_GSSv3実装は以下を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The new RPCSEC_GSS version number (Section 2.2).",
      "ja": "o 新しいRPCSEC_GSSバージョン番号（セクション2.2）。"
    },
    {
      "indent": 3,
      "text": "o The new reply verifier (Section 2.3).",
      "ja": "o 新しい返信ベリファイア（セクション2.3）。"
    },
    {
      "indent": 3,
      "text": "o The new auth_stat values (Section 2.6).",
      "ja": "o 新しいauth_stat値（セクション2.6）。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 targets implementing a desired feature MUST also implement the RPCSEC_GSS_LIST operation, and the RPCSEC_GSS_CREATE operation replies for unsupported features as follows:",
      "ja": "目的の機能を実装するRPCSEC_GSSv3ターゲットは、RPCSEC_GSS_LIST操作も実装する必要があり、RPCSEC_GSS_CREATE操作は、サポートされていない機能に対して次のように応答します。"
    },
    {
      "indent": 3,
      "text": "o For label assertions, the target indicates no support by returning the new RPCSEC_GSS_LABEL_PROBLEM auth_stat value (see Section 2.7.1.3).",
      "ja": "o ラベルアサーションの場合、ターゲットは新しいRPCSEC_GSS_LABEL_PROBLEM auth_stat値（セクション2.7.1.3を参照）を返すことにより、サポートがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o For structured privilege assertions, the target indicates no support by returning the new RPCSEC_GSS_UNKNOWN_MESSAGE auth_stat value (see Section 2.7.1.4).",
      "ja": "o 構造化された特権アサーションの場合、ターゲットは新しいRPCSEC_GSS_UNKNOWN_MESSAGE auth_stat値を返すことにより、サポートがないことを示します（セクション2.7.1.4を参照）。"
    },
    {
      "indent": 3,
      "text": "o For multi-principal authentication (Section 2.7.1.1), the target indicates no support by not including an rgss3_gss_mp_auth value in the rgss3_create_res.",
      "ja": "o マルチプリンシパル認証（セクション2.7.1.1）の場合、ターゲットは、rgss3_create_resにrgss3_gss_mp_auth値を含めないことにより、サポートがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o For channel bindings (Section 2.7.1.2), the target indicates no support by not including an rgss3_chan_binding value in the rgss3_create_res.",
      "ja": "o チャネルバインディング（セクション2.7.1.2）の場合、ターゲットは、rgss3_create_resにrgss3_chan_binding値を含めないことにより、サポートがないことを示します。"
    },
    {
      "indent": 0,
      "text": "1.3. XDR Code Extraction",
      "section_title": true,
      "ja": "1.3. XDRコード抽出"
    },
    {
      "indent": 3,
      "text": "This document contains the External Data Representation (XDR) [RFC4506] definitions for the RPCSEC_GSSv3 protocol. The XDR description is provided in this document in a way that makes it simple for the reader to extract it into a form that is ready to compile. The reader can feed this document in the following shell script to produce the machine-readable XDR description of RPCSEC_GSSv3:",
      "ja": "このドキュメントには、RPCSEC_GSSv3プロトコルの外部データ表現（XDR）[RFC4506]定義が含まれています。このドキュメントでは、XDRの説明を、読者が簡単にコンパイルできる形式に抽出できるように提供しています。読者は、このドキュメントを次のシェルスクリプトでフィードして、RPCSEC_GSSv3の機械可読なXDR記述を生成できます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh\ngrep \"^  *///\" | sed 's?^  */// ??' | sed 's?^  *///$??'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "That is, if the above script is stored in a file called \"extract.sh\" and this document is in a file called \"spec.txt\", then the reader can do:",
      "ja": "つまり、上記のスクリプトが「extract.sh」というファイルに保存され、このドキュメントが「spec.txt」というファイルにある場合、リーダーは次のことを実行できます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 4,
      "text": "sh extract.sh < spec.txt > rpcsec_gss_v3.x",
      "ja": "sh extract.sh <spec.txt> rpcsec_gss_v3.x"
    },
    {
      "indent": 0,
      "text": " <CODE ENDS> The effect of the script is to remove leading white space from each line, plus a sentinel sequence of \"///\".",
      "ja": "<CODE ENDS>スクリプトの効果は、各行の先頭の空白と、 \"///\"のセンチネルシーケンスを削除することです。"
    },
    {
      "indent": 0,
      "text": "2. The RPCSEC_GSSv3 Protocol",
      "section_title": true,
      "ja": "2. RPCSEC_GSSv3プロトコル"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 (RPCSEC_GSSv3) is very similar to RPCSEC_GSS version 2 (RPCSEC_GSSv2) [RFC5403]. The difference is that the new support for assertions and channel bindings is implemented via a different mechanism.",
      "ja": "RPCSEC_GSSバージョン3（RPCSEC_GSSv3）は、RPCSEC_GSSバージョン2（RPCSEC_GSSv2）[RFC5403]とよく似ています。違いは、アサーションとチャネルバインディングの新しいサポートが別のメカニズムを介して実装されることです。"
    },
    {
      "indent": 3,
      "text": "The entire RPCSEC_GSSv3 protocol is not presented here. Only the differences between RPCSEC_GSSv3 and RPCSEC_GSSv2 are shown.",
      "ja": "ここでは、RPCSEC_GSSv3プロトコル全体は示していません。 RPCSEC_GSSv3とRPCSEC_GSSv2の違いのみが示されています。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 is implemented as follows:",
      "ja": "RPCSEC_GSSv3は次のように実装されます。"
    },
    {
      "indent": 3,
      "text": "o A client uses an existing RPCSEC_GSSv3 context handle established in the usual manner (see Section 5.2 of [RFC2203]) to protect RPCSEC_GSSv3 exchanges; this will be termed the \"parent\" handle.",
      "ja": "o クライアントは、通常の方法で確立された既存のRPCSEC_GSSv3コンテキストハンドル（[RFC2203]のセクション5.2を参照）を使用して、RPCSEC_GSSv3交換を保護します。これは「親」ハンドルと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o The server issues a \"child\" RPCSEC_GSSv3 handle in the RPCSEC_GSS_CREATE response, which uses the underlying GSS-API security context of the parent handle in all subsequent exchanges that use the child handle.",
      "ja": "o サーバーは、RPCSEC_GSS_CREATE応答で「子」RPCSEC_GSSv3ハンドルを発行します。これは、子ハンドルを使用する後続のすべての交換で親ハンドルの基盤となるGSS-APIセキュリティコンテキストを使用します。"
    },
    {
      "indent": 3,
      "text": "o An RPCSEC_GSSv3 child handle MUST NOT be used as the parent handle in an RPCSEC_GSS3_CREATE control message.",
      "ja": "o RPCSEC_GSSv3子ハンドルは、RPCSEC_GSS3_CREATEコントロールメッセージの親ハンドルとして使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "2.1. Compatibility with RPCSEC_GSSv2",
      "section_title": true,
      "ja": "2.1. RPCSEC_GSSv2との互換性"
    },
    {
      "indent": 3,
      "text": "The functionality of RPCSEC_GSSv2 [RFC5403] is fully supported by RPCSEC_GSSv3, with the exception of the RPCSEC_GSS_BIND_CHANNEL operation, which is not supported when RPCSEC_GSSv3 is in use (see Section 2.5).",
      "ja": "RPCSEC_GSSv2 [RFC5403]の機能はRPCSEC_GSSv3で完全にサポートされていますが、RPCSEC_GSS_BIND_CHANNELオペレーションはRPCSEC_GSSv3が使用されている場合はサポートされません（セクション2.5を参照）。"
    },
    {
      "indent": 0,
      "text": "2.2. Version Negotiation",
      "section_title": true,
      "ja": "2.2. バージョン交渉"
    },
    {
      "indent": 3,
      "text": "An initiator that supports version 3 of RPCSEC_GSS simply issues an RPCSEC_GSS request with the rgc_version field set to RPCSEC_GSS_VERS_3. If the target does not recognize RPCSEC_GSS_VERS_3, the target will return an RPC error per Section 5.1 of [RFC2203].",
      "ja": "RPCSEC_GSSのバージョン3をサポートするイニシエーターは、rgc_versionフィールドをRPCSEC_GSS_VERS_3に設定してRPCSEC_GSS要求を発行するだけです。ターゲットがRPCSEC_GSS_VERS_3を認識しない場合、ターゲットは[RFC2203]のセクション5.1に従ってRPCエラーを返します。"
    },
    {
      "indent": 3,
      "text": "The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned by version 3 of a target with version 1 or version 2 of the same target. The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned by version 1 or version 2 of a target with version 3 of the same target.",
      "ja": "イニシエーターは、同じターゲットのバージョン1またはバージョン2のターゲットのバージョン3によって返されたRPCSEC_GSSハンドルの使用を試みてはなりません（MUST NOT）。イニシエータは、バージョン1またはバージョン2のターゲットから返されたRPCSEC_GSSハンドルを、同じターゲットのバージョン3とともに使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "2.3. New Reply Verifier",
      "section_title": true,
      "ja": "2.3. 新しい返信検証"
    },
    {
      "indent": 3,
      "text": "A new reply verifier is needed for RPCSEC_GSSv3 because of a situation that arises from the use of the same GSS context by child and parent handles. Because the RPCSEC_GSSv3 child handle uses the same GSS context as the parent handle, a child and parent RPCSEC_GSSv3 handle could have the same RPCSEC_GSS sequence numbers. Since the reply verifier of previous versions of RPCSEC_GSS computes a Message Integrity Code (MIC) on just the sequence number, this provides opportunities for man-in-the-middle attacks.",
      "ja": "子と親のハンドルによる同じGSSコンテキストの使用から生じる状況のため、RPCSEC_GSSv3には新しい応答ベリファイアが必要です。 RPCSEC_GSSv3子ハンドルは親ハンドルと同じGSSコンテキストを使用するため、子と親のRPCSEC_GSSv3ハンドルは同じRPCSEC_GSSシーケンス番号を持つことができます。以前のバージョンのRPCSEC_GSSの応答ベリファイアはシーケンス番号のみでメッセージ整合性コード（MIC）を計算するため、これは中間者攻撃の機会を提供します。"
    },
    {
      "indent": 3,
      "text": "This issue is addressed in RPCSEC_GSS version 3 by computing the verifier using exactly the same input as the information used to compute the request verifier, except that the mtype is changed from CALL to REPLY. The new reply verifier computes a MIC over the following RPC reply header data:",
      "ja": "この問題は、RPCSEC_GSSバージョン3で、mtypeがCALLからREPLYに変更されていることを除いて、要求ベリファイアの計算に使用される情報とまったく同じ入力を使用してベリファイアを計算することで解決されています。新しい応答ベリファイアは、次のRPC応答ヘッダーデータに対してMICを計算します。"
    },
    {
      "indent": 5,
      "text": "unsigned int xid;\nmsg_type mtype;    /* set to REPLY */\nunsigned int rpcvers;\nunsigned int prog;\nunsigned int vers;\nunsigned int proc;\nopaque_auth  cred; /* binds the RPCSEC_GSS handle */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.4. XDR Code Preliminaries",
      "section_title": true,
      "ja": "2.4. XDRコードの予備"
    },
    {
      "indent": 3,
      "text": "The following code fragment replaces the corresponding preliminary code shown in Figure 1 of [RFC5403]. The values in the code fragment in Section 2.6 are additions to the auth_stat enumeration. Subsequent code fragments are additions to the code for version 2 that support the new procedures defined in version 3.",
      "ja": "次のコードフラグメントは、[RFC5403]の図1に示されている対応する予備コードを置き換えます。セクション2.6のコードフラグメントの値は、auth_stat列挙型への追加です。後続のコードフラグメントは、バージョン3で定義された新しいプロシージャをサポートするバージョン2のコードへの追加です。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///  /*\n///   * Copyright (c) 2016 IETF Trust and the persons\n///   * identified as the authors.  All rights reserved.\n///   *\n///   * The authors of the code are identified in RFC 2203,\n///   * RFC 5403, and RFC 7861.\n///   *\n///   * Redistribution and use in source and binary forms,\n///   * with or without modification, are permitted\n///   * provided that the following conditions are met:\n///   *\n///   * o Redistributions of source code must retain the above\n///   *   copyright notice, this list of conditions and the\n///   *   following disclaimer.\n///   *\n///   * o Redistributions in binary form must reproduce the\n///   *   above copyright notice, this list of\n///   *   conditions and the following disclaimer in\n///   *   the documentation and/or other materials\n///   *   provided with the distribution.\n///   *\n///   * o Neither the name of Internet Society, IETF or IETF\n///   *   Trust, nor the names of specific contributors, may be\n///   *   used to endorse or promote products derived from this\n///   *   software without specific prior written permission.\n///   *\n///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///   *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///   */\n///\n///  /*\n///   * This code was derived from RFC 2203, RFC 5403,\n///   * and RFC 7861.  Please reproduce this note if possible.\n///   */\n///\n///  enum rpc_gss_service_t {\n///          /* Note: The enumerated value for 0 is reserved. */\n///          rpc_gss_svc_none         = 1,\n///          rpc_gss_svc_integrity    = 2,\n///          rpc_gss_svc_privacy      = 3,\n///          rpc_gss_svc_channel_prot = 4\n///  };\n///\n///  enum rpc_gss_proc_t {\n///           RPCSEC_GSS_DATA          = 0,\n///           RPCSEC_GSS_INIT          = 1,\n///           RPCSEC_GSS_CONTINUE_INIT = 2,\n///           RPCSEC_GSS_DESTROY       = 3,\n///           RPCSEC_GSS_BIND_CHANNEL  = 4, /* Not used */\n///           RPCSEC_GSS_CREATE        = 5, /* New */\n///           RPCSEC_GSS_LIST          = 6  /* New */\n///  };\n///\n///  struct rpc_gss_cred_vers_1_t {\n///          rpc_gss_proc_t    gss_proc; /* Control procedure */\n///          unsigned int      seq_num;  /* Sequence number */\n///          rpc_gss_service_t service;  /* Service used */\n///          opaque            handle<>; /* Context handle */\n///  };\n///\n///  const RPCSEC_GSS_VERS_1 = 1;\n///  const RPCSEC_GSS_VERS_2 = 2;\n///  const RPCSEC_GSS_VERS_3 = 3; /* New */\n///\n///  union rpc_gss_cred_t switch (unsigned int rgc_version) {\n///  case RPCSEC_GSS_VERS_1:\n///  case RPCSEC_GSS_VERS_2:\n///  case RPCSEC_GSS_VERS_3: /* New */\n///          rpc_gss_cred_vers_1_t rgc_cred_v1;\n///  };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " <CODE ENDS> As seen above, the RPCSEC_GSSv3 credential has the same format as the RPCSEC_GSSv1 [RFC2203] and RPCSEC_GSSv2 [RFC5403] credential. Setting the rgc_version field to 3 indicates that the initiator and target support the new RPCSEC_GSSv3 control procedures.",
      "ja": "<コード終了>上記のように、RPCSEC_GSSv3クレデンシャルは、RPCSEC_GSSv1 [RFC2203]およびRPCSEC_GSSv2 [RFC5403]クレデンシャルと同じ形式です。 rgc_versionフィールドを3に設定すると、イニシエーターとターゲットが新しいRPCSEC_GSSv3制御手順をサポートすることを示します。"
    },
    {
      "indent": 0,
      "text": "2.5. RPCSEC_GSS_BIND_CHANNEL Operation",
      "section_title": true,
      "ja": "2.5. RPCSEC_GSS_BIND_CHANNELオペレーション"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 provides a channel-binding assertion that replaces the RPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL operation.",
      "ja": "RPCSEC_GSSv3は、RPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL操作に代わるチャネルバインディングアサーションを提供します。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_BIND_CHANNEL operation is not supported on RPCSEC_GSS version 3 handles. If a server receives an RPCSEC_GSS_BIND_CHANNEL operation on an RPCSEC_GSSv3 handle, it MUST return a reply status of MSG_ACCEPTED with an accept_stat of PROC_UNAVAIL [RFC5531].",
      "ja": "RPCSEC_GSS_BIND_CHANNEL操作は、RPCSEC_GSSバージョン3ハンドルではサポートされていません。サーバーがRPCSEC_GSSv3ハンドルでRPCSEC_GSS_BIND_CHANNEL操作を受信した場合、サーバーはAccept_statがPROC_UNAVAIL [RFC5531]のMSG_ACCEPTEDの応答ステータスを返さなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "2.6. New auth_stat Values",
      "section_title": true,
      "ja": "2.6. 新しいauth_stat値"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 requires the addition of several values to the auth_stat enumerated type definition. The use of these new auth_stat values is explained throughout this document.",
      "ja": "RPCSEC_GSSv3では、auth_stat列挙型定義にいくつかの値を追加する必要があります。これらの新しいauth_stat値の使用については、このドキュメント全体で説明されています。"
    },
    {
      "indent": 14,
      "text": "enum auth_stat {\n        ...\n        /*\n         * RPCSEC_GSSv3 errors\n         */\n        RPCSEC_GSS_INNER_CREDPROBLEM = 15,\n        RPCSEC_GSS_LABEL_PROBLEM     = 16,\n        RPCSEC_GSS_PRIVILEGE_PROBLEM = 17,\n        RPCSEC_GSS_UNKNOWN_MESSAGE   = 18\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.7. New Control Procedures",
      "section_title": true,
      "ja": "2.7. 新しい管理手順"
    },
    {
      "indent": 3,
      "text": "There are two new RPCSEC_GSSv3 control procedures: RPCSEC_GSS_CREATE and RPCSEC_GSS_LIST.",
      "ja": "2つの新しいRPCSEC_GSSv3制御プロシージャ：RPCSEC_GSS_CREATEおよびRPCSEC_GSS_LISTがあります。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_CREATE procedure binds any combination of assertions -- multi-principal authentication, labels, structured privileges, or channel bindings -- to a new RPCSEC_GSSv3 context returned in the rgss3_create_res rcr_handle field.",
      "ja": "RPCSEC_GSS_CREATEプロシージャは、アサーションの任意の組み合わせ（マルチプリンシパル認証、ラベル、構造化特権、またはチャネルバインディング）を、rgss3_create_res rcr_handleフィールドで返される新しいRPCSEC_GSSv3コンテキストにバインドします。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_LIST procedure queries the target for supported assertions.",
      "ja": "RPCSEC_GSS_LISTプロシージャは、サポートされているアサーションをターゲットに照会します。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 control messages are similar to the RPCSEC_GSS version 1 and version 2 RPCSEC_GSS_DESTROY control message (see Section 5.4 of [RFC2203]) in that the sequence number in the request must be valid and the header checksum in the verifier must be valid. As in RPCSEC_GSS version 1 and version 2, the RPCSEC_GSS version 3 control messages may contain call data following the verifier in the body of the NULLPROC procedure. In other words, they look a lot like an RPCSEC_GSS data message with the header procedure set to NULLPROC.",
      "ja": "RPCSEC_GSSバージョン3の制御メッセージは、リクエストのシーケンス番号が有効であり、ベリファイアのヘッダーチェックサムが有効である必要があるという点で、RPCSEC_GSSバージョン1およびバージョン2のRPCSEC_GSS_DESTROY制御メッセージ（[RFC2203]のセクション5.4を参照）と同様です。 RPCSEC_GSSバージョン1およびバージョン2と同様に、RPCSEC_GSSバージョン3制御メッセージには、NULLPROCプロシージャの本文のベリファイアに続く呼び出しデータが含まれる場合があります。つまり、ヘッダープロシージャがNULLPROCに設定されたRPCSEC_GSSデータメッセージによく似ています。"
    },
    {
      "indent": 3,
      "text": "The client MUST use one of the following security services to protect the RPCSEC_GSS_CREATE or RPCSEC_GSS_LIST control message:",
      "ja": "クライアントは、RPCSEC_GSS_CREATEまたはRPCSEC_GSS_LIST制御メッセージを保護するために、次のセキュリティサービスのいずれかを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o rpc_gss_svc_integrity",
      "ja": "o rpc_gss_svc_integrity"
    },
    {
      "indent": 3,
      "text": "o rpc_gss_svc_privacy",
      "ja": "o rpc_gss_svc_privacy"
    },
    {
      "indent": 3,
      "text": "Specifically, the client MUST NOT use rpc_gss_svc_none.",
      "ja": "具体的には、クライアントはrpc_gss_svc_noneを使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS_LIST can also use rpc_gss_svc_channel_prot (see RPCSEC_GSSv2 [RFC5403]) if the request is sent using an RPCSEC_GSSv3 child handle with channel bindings enabled as described in Section 2.7.1.2.",
      "ja": "RPCSEC_GSS_LISTは、セクション2.7.1.2で説明されているようにチャネルバインディングが有効になっているRPCSEC_GSSv3子ハンドルを使用して要求が送信される場合、rpc_gss_svc_channel_prot（RPCSEC_GSSv2 [RFC5403]を参照）も使用できます。"
    },
    {
      "indent": 0,
      "text": "2.7.1. New Control Procedure - RPCSEC_GSS_CREATE",
      "section_title": true,
      "ja": "2.7.1. 新しい制御プロシージャ-RPCSEC_GSS_CREATE"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///  struct rgss3_create_args {\n///          rgss3_gss_mp_auth    *rca_mp_auth;\n///          rgss3_chan_binding   *rca_chan_bind_mic;\n///          rgss3_assertion_u    rca_assertions<>;\n///  };\n///\n///  struct rgss3_create_res {\n///          opaque               rcr_handle<>;\n///          rgss3_gss_mp_auth    *rcr_mp_auth;\n///          rgss3_chan_binding   *rcr_chan_bind_mic;\n///          rgss3_assertion_u    rcr_assertions<>;\n///  };\n///\n///  enum rgss3_assertion_type {\n///          LABEL = 0,\n///          PRIVS = 1\n///  };\n///\n///  union rgss3_assertion_u\n///        switch (rgss3_assertion_type atype) {\n///  case LABEL:\n///          rgss3_label  rau_label;\n///  case PRIVS:\n///          rgss3_privs  rau_privs;\n///  default:\n///          opaque       rau_ext<>;\n///  };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "The call data for an RPCSEC_GSS_CREATE request consists of an rgss3_create_args, which binds one or more items of several kinds to the returned rcr_handle RPCSEC_GSSv3 context handle (the child handle):",
      "ja": "RPCSEC_GSS_CREATE要求の呼び出しデータは、rgss3_create_argsで構成されます。これは、いくつかの種類の1つ以上の項目を、返されたrcr_handle RPCSEC_GSSv3コンテキストハンドル（子ハンドル）にバインドします。"
    },
    {
      "indent": 3,
      "text": "o Multi-principal authentication: another RPCSEC_GSS context handle",
      "ja": "o マルチプリンシパル認証：別のRPCSEC_GSSコンテキストハンドル"
    },
    {
      "indent": 3,
      "text": "o A channel binding",
      "ja": "o チャネルバインディング"
    },
    {
      "indent": 0,
      "text": " o Authorization assertions: labels and/or privileges The reply to this message consists of either an error or an rgss3_create_res structure. As noted in Sections 2.7.1.3 and 2.7.1.4, successful rgss3_assertions are enumerated in rcr_assertions and are REQUIRED to be enumerated in the same order as they appeared in the rca_assertions argument.",
      "ja": "o承認アサーション：ラベルまたは特権、あるいはその両方このメッセージへの応答は、エラーまたはrgss3_create_res構造体で構成されています。セクション2.7.1.3と2.7.1.4で述べたように、成功したrgss3_assertionsはrcr_assertionsに列挙され、rca_assertions引数に現れたのと同じ順序で列挙する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon a successful RPCSEC_GSS_CREATE, both the client and the server need to associate the resultant child rcr_handle context handle with the parent context handle in their GSS context caches so as to be able to reference the parent context given the child context handle.",
      "ja": "RPCSEC_GSS_CREATEが成功すると、クライアントとサーバーの両方が、結果の子rcr_handleコンテキストハンドルをGSSコンテキストキャッシュ内の親コンテキストハンドルに関連付けて、子コンテキストハンドルが指定された親コンテキストを参照できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 child handles MUST be destroyed upon the destruction of the associated parent handle.",
      "ja": "RPCSEC_GSSv3子ハンドルは、関連する親ハンドルの破棄時に破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Server implementation and policy MAY result in labels, privileges, and identities being mapped to concepts and values that are local to the server. Server policies should take into account the identity of the client and/or user as authenticated via the GSS-API.",
      "ja": "サーバーの実装とポリシーにより、ラベル、特権、およびIDがサーバーに対してローカルな概念と値にマッピングされる場合があります。サーバーポリシーでは、GSS-APIを介して認証されたクライアントやユーザーのIDを考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.7.1.1. Multi-Principal Authentication",
      "section_title": true,
      "ja": "2.7.1.1. マルチプリンシパル認証"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///\n///  struct rgss3_gss_mp_auth {\n///          opaque          rgmp_handle<>; /* Inner handle */\n///          opaque          rgmp_rpcheader_mic<>;\n///  };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a multi-principal authentication of the RPC client host principal and a user principal. This feature is needed, for example, when an RPC client host wishes to use authority assertions that the server may only grant if a user and an RPC client host are authenticated together to the server. Thus, a server may refuse to grant requested authority to a user acting alone (e.g., via an unprivileged user-space program) or to an RPC client host acting alone (e.g., when an RPC client host is acting on behalf of a user) but may grant requested authority to an RPC client host acting on behalf of a user if the server identifies the user and trusts the RPC client host.",
      "ja": "RPCSEC_GSSv3クライアントは、RPCクライアントのホストプリンシパルとユーザープリンシパルのマルチプリンシパル認証をアサートできます（MAY）。この機能は、たとえば、RPCクライアントホストが、ユーザーとRPCクライアントホストがサーバーに対して一緒に認証された場合にのみサーバーが許可する権限アサーションを使用する場合に必要です。したがって、サーバーは、要求された権限を、単独で動作するユーザー（たとえば、非特権ユーザー空間プログラムを介して）または単独で動作するRPCクライアントホストに許可することを拒否する場合があります（たとえば、RPCクライアントホストがユーザーに代わって動作している場合）ただし、サーバーがユーザーを識別し、RPCクライアントホストを信頼している場合は、要求された権限をユーザーに代わって動作するRPCクライアントホストに付与できます。"
    },
    {
      "indent": 3,
      "text": "It is assumed that an unprivileged user-space program would not have access to RPC client host credentials needed to establish a GSS-API security context authenticating the RPC client host to the server; therefore, an unprivileged user-space program could not create an RPCSEC_GSSv3 RPCSEC_GSS_CREATE message that successfully binds an RPC client host and a user security context.",
      "ja": "非特権ユーザー空間プログラムは、サーバーに対してRPCクライアントホストを認証するGSS-APIセキュリティコンテキストを確立するために必要なRPCクライアントホスト資格情報にアクセスできないと想定されています。したがって、非特権ユーザー空間プログラムは、RPCクライアントホストとユーザーセキュリティコンテキストを正常にバインドするRPCSEC_GSSv3 RPCSEC_GSS_CREATEメッセージを作成できませんでした。"
    },
    {
      "indent": 3,
      "text": "In addition to the parent handle (Section 2), the multi-principal authentication call data has an RPCSEC_GSS version 3 handle referenced via the rgmp_handle field termed the \"inner\" handle. Clients using RPCSEC_GSSv3 multi-principal authentication MUST use an RPCSEC_GSSv3 context handle that corresponds to a GSS-API security context that authenticates the RPC client host for the parent handle. The inner context handle of the multi-principal authentication assertion MUST use an RPCSEC_GSSv3 context handle that corresponds to a GSS-API security context that authenticates the user. The reverse (parent handle authenticates user, inner context handle authenticates an RPC client host) MUST NOT be used. Other multi-principal parent and inner context handle uses might eventually make sense, but they would need to be introduced in a new revision of the RPCSEC_GSS protocol.",
      "ja": "親ハンドル（セクション2）に加えて、マルチプリンシパル認証呼び出しデータには、「内部」ハンドルと呼ばれるrgmp_handleフィールドを介して参照されるRPCSEC_GSSバージョン3ハンドルがあります。 RPCSEC_GSSv3マルチプリンシパル認証を使用するクライアントは、親ハンドルのRPCクライアントホストを認証するGSS-APIセキュリティコンテキストに対応するRPCSEC_GSSv3コンテキストハンドルを使用する必要があります。マルチプリンシパル認証アサーションの内部コンテキストハンドルは、ユーザーを認証するGSS-APIセキュリティコンテキストに対応するRPCSEC_GSSv3コンテキストハンドルを使用する必要があります。逆（親ハンドルはユーザーを認証し、内部コンテキストハンドルはRPCクライアントホストを認証する）を使用してはならない（MUST NOT）。他のマルチプリンシパル親および内部コンテキストハンドルの使用は、最終的には意味をなすかもしれませんが、RPCSEC_GSSプロトコルの新しいリビジョンで導入する必要があります。"
    },
    {
      "indent": 3,
      "text": "The child context handle returned by a successful multi-principal assertion binds the inner RPCSEC_GSSv3 context handle to the parent RPCSEC_GSS context handle and MUST be treated by servers as authenticating the GSS-API initiator principal authenticated by the inner context handle's GSS-API security context. This principal may be mapped to a server-side notion of user or principal.",
      "ja": "成功したマルチプリンシパルアサーションによって返された子コンテキストハンドルは、内部RPCSEC_GSSv3コンテキストハンドルを親RPCSEC_GSSコンテキストハンドルにバインドし、サーバーによって、内部コンテキストハンドルのGSS-APIセキュリティコンテキストによって認証されたGSS-APIイニシエータープリンシパルを認証するものとして扱われる必要があります。このプリンシパルは、ユーザーまたはプリンシパルのサーバー側の概念にマップできます。"
    },
    {
      "indent": 3,
      "text": "Multi-principal binding is done by including an assertion of type rgss3_gss_mp_auth in the RPCSEC_GSS_CREATE rgss3_create_args call data. The inner context handle is placed in the rgmp_handle field. A MIC of the RPC header, up to and including the credential, is computed using the GSS-API security context associated with the inner context handle and is placed in the rgmp_rpcheader_mic field. Note that the rgmp_rpcheader_mic only identifies the client host GSS context by its context handle (the parent context handle) in the RPC header.",
      "ja": "マルチプリンシパルバインディングは、RPCSEC_GSS_CREATE rgss3_create_args呼び出しデータにタイプrgss3_gss_mp_authのアサーションを含めることによって行われます。内部コンテキストハンドルは、rgmp_handleフィールドに配置されます。資格情報までのRPCヘッダーのMICは、内部コンテキストハンドルに関連付けられたGSS-APIセキュリティコンテキストを使用して計算され、rgmp_rpcheader_micフィールドに配置されます。 rgmp_rpcheader_micは、RPCヘッダーのコンテキストハンドル（親コンテキストハンドル）によってのみクライアントホストGSSコンテキストを識別することに注意してください。"
    },
    {
      "indent": 3,
      "text": "An RPCSEC_GSS_CREATE control procedure with a multi-principal authentication payload MUST use the rpc_gss_svc_privacy security service for protection. This prevents an attacker from intercepting the RPCSEC_GSS_CREATE control procedure, reassigning the (parent) context handle, and stealing the user's identity.",
      "ja": "マルチプリンシパル認証ペイロードを持つRPCSEC_GSS_CREATE制御プロシージャは、保護のためにrpc_gss_svc_privacyセキュリティサービスを使用する必要があります。これにより、攻撃者がRPCSEC_GSS_CREATE制御プロシージャを傍受し、（親）コンテキストハンドルを再割り当てし、ユーザーのIDを盗むのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "The target verifies the multi-principal authentication by first confirming that the parent context used is an RPC client host context; the target then verifies the rgmp_rpcheader_mic using the GSS-API security context associated with the rgmp_handle field.",
      "ja": "ターゲットは、使用される親コンテキストがRPCクライアントホストコンテキストであることを最初に確認することにより、マルチプリンシパル認証を確認します。次に、ターゲットは、rgmp_handleフィールドに関連付けられたGSS-APIセキュリティコンテキストを使用してrgmp_rpcheader_micを検証します。"
    },
    {
      "indent": 3,
      "text": "On successful verification, the rgss3_gss_mp_auth field in the rgss3_create_res reply MUST be filled in with the inner RPCSEC_GSSv3 context handle as the rgmp_handle and a MIC computed over the RPC reply header (see Section 2.3) using the GSS-API security context associated with the inner handle.",
      "ja": "検証が成功した場合、rgss3_create_res応答のrgss3_gss_mp_authフィールドに、内部RPCSEC_GSSv3コンテキストハンドルをrgmp_handleとして入力し、内部ハンドルに関連付けられたGSS-APIセキュリティコンテキストを使用してRPC応答ヘッダー（セクション2.3を参照）で計算したMICを入力する必要があります。 。"
    },
    {
      "indent": 3,
      "text": "On failure, the rgss3_gss_mp_auth field is not sent (rgss3_gss_mp_auth is an optional field). A MSG_DENIED reply to the RPCSEC_GSS_CREATE call is formulated as usual.",
      "ja": "失敗した場合、rgss3_gss_mp_authフィールドは送信されません（rgss3_gss_mp_authはオプションのフィールドです）。 RPCSEC_GSS_CREATE呼び出しへのMSG_DENIED応答は、通常どおりに作成されます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.3.3.3 of [RFC2203], the server maintains a list of contexts for the clients that are currently in session with it. When a client request comes in, there may not be a context corresponding to its handle. When this occurs on an RPCSEC_GSS3_CREATE request processing of the parent handle, the server rejects the request with a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_CREDPROBLEM.",
      "ja": "[RFC2203]のセクション5.3.3.3で説明されているように、サーバーは、現在セッションを行っているクライアントのコンテキストのリストを保持しています。クライアント要求が入ってくると、そのハンドルに対応するコンテキストがない場合があります。これが親ハンドルのRPCSEC_GSS3_CREATE要求処理で発生すると、サーバーは、MSG_DENIEDの応答ステータスがAUTH_ERRORで、auth_stat値がRPCSEC_GSS_CREDPROBLEMである要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "A new value, RPCSEC_GSS_INNER_CREDPROBLEM, has been added to the auth_stat type. With a multi-principal authorization request, the server must also have a context corresponding to the inner context handle. When the server does not have a context handle corresponding to the inner context handle of a multi-principal authorization request, the server sends a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_INNER_CREDPROBLEM.",
      "ja": "新しい値RPCSEC_GSS_INNER_CREDPROBLEMがauth_statタイプに追加されました。マルチプリンシパル認証リクエストの場合、サーバーには内部コンテキストハンドルに対応するコンテキストも必要です。サーバーがマルチプリンシパル認証要求の内部コンテキストハンドルに対応するコンテキストハンドルを持たない場合、サーバーはMSG_DENIEDの応答ステータスを送信し、reject_statはAUTH_ERRORで、auth_stat値はRPCSEC_GSS_INNER_CREDPROBLEMです。"
    },
    {
      "indent": 3,
      "text": "When processing the multi-principal authentication request, if the GSS_VerifyMIC() call on the rgmp_rpcheader_mic fails to return GSS_S_COMPLETE, the server sends a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_INNER_CREDPROBLEM.",
      "ja": "マルチプリンシパル認証要求を処理するときに、rgmp_rpcheader_micのGSS_VerifyMIC()呼び出しがGSS_S_COMPLETEを返さない場合、サーバーは、MSG_DENIEDの応答ステータスを送信し、reject_statをAUTH_ERRORにして、auth_stat値をRPCSEC_GSS_INNER_CREDPROBLEMにします。"
    },
    {
      "indent": 0,
      "text": "2.7.1.2. Channel Binding",
      "section_title": true,
      "ja": "2.7.1.2. チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///\n///  typedef opaque rgss3_chan_binding<>;\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 provides a different way to do channel binding than RPCSEC_GSSv2 [RFC5403]. Specifically:",
      "ja": "RPCSEC_GSSv3は、RPCSEC_GSSv2 [RFC5403]とは異なるチャネルバインディングを行う方法を提供します。具体的には："
    },
    {
      "indent": 3,
      "text": "a. RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing, established context handles rather than providing a different RPC security flavor for establishing context handles.",
      "ja": "a. RPCSEC_GSSv3は、コンテキストハンドルを確立するための別のRPCセキュリティフレーバーを提供するのではなく、既存の確立されたコンテキストハンドルを再利用することにより、RPCSEC_GSSv1に基づいて構築されます。"
    },
    {
      "indent": 3,
      "text": "b. Channel-bindings data is not hashed because there is now general agreement that it is the secure channel's responsibility to produce channel-bindings data of manageable size.",
      "ja": "b. 管理可能なサイズのチャネルバインディングデータを生成するのはセキュアチャネルの責任であるという一般的な合意があるため、チャネルバインディングデータはハッシュされません。"
    },
    {
      "indent": 3,
      "text": "(a) is useful in keeping RPCSEC_GSSv3 simple in general, not just for channel binding. (b) is useful in keeping RPCSEC_GSSv3 simple specifically for channel binding.",
      "ja": "（a）は、チャネルバインディングだけでなく、RPCSEC_GSSv3を一般的にシンプルに保つのに役立ちます。 （b）チャネルバインディング専用のRPCSEC_GSSv3をシンプルに保つのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Channel binding is accomplished as follows. The client prefixes the channel-bindings data octet string with the channel type as described in [RFC5056]; then, the client calls GSS_GetMIC() to get a MIC of the resulting octet string, using the parent RPCSEC_GSSv3 context handle's GSS-API security context. The MIC is then placed in the rca_chan_bind_mic field of RPCSEC_GSS_CREATE arguments (rgss3_create_args).",
      "ja": "チャネルバインディングは次のように実行されます。 [RFC5056]で説明されているように、クライアントはチャネルタイプをチャネルバインディングデータオクテット文字列の前に付けます。次に、クライアントはGSS_GetMIC()を呼び出し、親RPCSEC_GSSv3コンテキストハンドルのGSS-APIセキュリティコンテキストを使用して、結果のオクテット文字列のMICを取得します。次に、MICはRPCSEC_GSS_CREATE引数（rgss3_create_args）のrca_chan_bind_micフィールドに配置されます。"
    },
    {
      "indent": 3,
      "text": "If the rca_chan_bind_mic field of the arguments of an RPCSEC_GSS_CREATE control message is set, then the server MUST verify the client's channel-binding MIC if the server supports this feature. If channel-binding verification succeeds, then the server MUST generate a new MIC of the same channel bindings and place it in the rcr_chan_bind_mic field of the RPCSEC_GSS_CREATE rgss3_create_res results. If channel-binding verification fails or the server doesn't support channel binding, then the server MUST indicate this in its reply by not including an rgss3_chan_binding value in rgss3_create_res (rgss3_chan_binding is an optional field).",
      "ja": "RPCSEC_GSS_CREATE制御メッセージの引数のrca_chan_bind_micフィールドが設定されている場合、サーバーがこの機能をサポートしている場合、サーバーはクライアントのチャネルバインディングMICを確認する必要があります。チャネルバインディングの検証が成功した場合、サーバーは同じチャネルバインディングの新しいMICを生成し、RPCSEC_GSS_CREATE rgss3_create_res結果のrcr_chan_bind_micフィールドに配置する必要があります。チャネルバインディングの検証に失敗した場合、またはサーバーがチャネルバインディングをサポートしていない場合、サーバーは、rgss3_create_resにrgss3_chan_bindingの値を含めないことで、応答でこれを示す必要があります（rgss3_chan_bindingはオプションフィールドです）。"
    },
    {
      "indent": 0,
      "text": " The client MUST verify the result's rcr_chan_bind_mic value by calling GSS_VerifyMIC() with the given MIC and the channel-bindings data (including the channel-type prefix). If client-side channel-binding verification fails, then the client MUST call RPCSEC_GSS_DESTROY. If the client requested channel binding but the server did not include an rcr_chan_binding_mic field in the results, then the client MAY continue to use the resulting context handle as though channel binding had never been requested. If the client considers channel binding critical, it MUST call RPCSEC_GSS_DESTROY.",
      "ja": "クライアントは、指定されたMICおよびチャネルバインディングデータ（チャネルタイププレフィックスを含む）を使用してGSS_VerifyMIC()を呼び出すことにより、結果のrcr_chan_bind_mic値を検証する必要があります。クライアント側のチャネルバインディング検証が失敗した場合、クライアントはRPCSEC_GSS_DESTROYを呼び出す必要があります。クライアントがチャネルバインディングを要求したが、サーバーが結果にrcr_chan_binding_micフィールドを含めなかった場合、クライアントは、チャネルバインディングが要求されなかったかのように、結果のコンテキストハンドルを引き続き使用できます（MAY）。クライアントがチャネルバインディングを重要であると考える場合、RPCSEC_GSS_DESTROYを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "As per RPCSEC_GSSv2 [RFC5403]:",
      "ja": "RPCSEC_GSSv2 [RFC5403]によると："
    },
    {
      "indent": 6,
      "text": "Once a successful [channel-binding] procedure has been performed on an [RPCSEC_GSSv3] context handle, the initiator's implementation may map application requests for rpc_gss_svc_none and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials. And if the secure channel has privacy enabled, requests for rpc_gss_svc_privacy can also be mapped to rpc_gss_svc_channel_prot.",
      "ja": "[RPCSEC_GSSv3]コンテキストハンドルで[channel-binding]プロシージャが正常に実行されると、イニシエーターの実装は、rpc_gss_svc_noneおよびrpc_gss_svc_integrityのアプリケーション要求をrpc_gss_svc_channel_prot資格情報にマップできます。また、セキュアチャネルでプライバシーが有効になっている場合は、rpc_gss_svc_privacyのリクエストをrpc_gss_svc_channel_protにマッピングすることもできます。"
    },
    {
      "indent": 3,
      "text": "Any RPCSEC_GSSv3 child context handle that has been bound to a secure channel in this way SHOULD be used only with the rpc_gss_svc_channel_prot and SHOULD NOT be used with rpc_gss_svc_none or rpc_gss_svc_integrity -- if the secure channel does not provide privacy protection, then the client MAY use rpc_gss_svc_privacy where privacy protection is needed or desired.",
      "ja": "この方法でセキュアチャネルにバインドされているRPCSEC_GSSv3子コンテキストハンドルは、rpc_gss_svc_channel_protでのみ使用する必要があり（SHOULD）、rpc_gss_svc_noneまたはrpc_gss_svc_integrityでは使用しないでください-セキュアチャネルがプライバシー保護を提供しない場合、クライアントはrpc_prisプライバシー保護が必要または望まれる場所。"
    },
    {
      "indent": 0,
      "text": "2.7.1.3. Label Assertions",
      "section_title": true,
      "ja": "2.7.1.3. ラベルアサーション"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///  struct rgss3_label {\n///          rgss3_lfs       rl_lfs;\n///          opaque          rl_label<>;\n///  };\n///\n///  struct rgss3_lfs {\n///          unsigned int rlf_lfs_id;\n///          unsigned int rlf_pi_id;\n///  };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "The client discovers, via the RPCSEC_GSS_LIST control message, which LFSs the server supports. Full Mode MAC is enabled when an RPCSEC_GSS version 3 process subject label assertion is combined with a file object label provided by the NFSv4.2 sec_label attribute.",
      "ja": "クライアントは、RPCSEC_GSS_LIST制御メッセージを介して、サーバーがサポートするLFSを検出します。 RPCSEC_GSSバージョン3プロセスサブジェクトラベルアサーションがNFSv4.2 sec_l​​abel属性によって提供されるファイルオブジェクトラベルと組み合わされると、フルモードMACが有効になります。"
    },
    {
      "indent": 0,
      "text": " Label encoding is specified to mirror the NFSv4.2 sec_label attribute described in Section 12.2.4 of [RFC7862]. The LFS is an identifier used by the client to establish the syntactic format of the security label and the semantic meaning of its components. The Policy Identifier (PI) is an optional part of the definition of an LFS that allows clients and the server to identify specific security policies. The opaque label field (rgss3_label) is dependent on the MAC model to interpret and enforce.",
      "ja": "[RFC7862]のセクション12.2.4で説明されているNFSv4.2 sec_l​​abel属性を反映するようにラベルエンコーディングが指定されています。 LFSは、セキュリティラベルの構文形式とそのコンポーネントの意味の意味を確立するためにクライアントが使用する識別子です。ポリシー識別子（PI）は、クライアントとサーバーが特定のセキュリティポリシーを識別できるようにするLFSの定義のオプションの部分です。不透明なラベルフィールド（rgss3_label）は、解釈および適用するMACモデルに依存しています。"
    },
    {
      "indent": 3,
      "text": "If a label itself requires privacy protection (i.e., requires that the user can assert that the label is a secret), then the client MUST use the rpc_gss_svc_privacy protection service for the RPCSEC_GSS_CREATE request.",
      "ja": "ラベル自体がプライバシー保護を必要とする場合（つまり、ユーザーがラベルがシークレットであることをアサートできる必要がある場合）、クライアントはRPCSEC_GSS_CREATE要求に対してrpc_gss_svc_privacy保護サービスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a set of subject security labels in some LFS by binding a label assertion to the RPCSEC_GSSv3 child context handle. This is done by including an assertion of type rgss3_label in the RPCSEC_GSS_CREATE rgss3_create_args rca_assertions call data. The label assertion payload is the set of subject labels asserted by the calling NFS client process. The resultant child context is used for NFS requests asserting the client process subject labels. The NFS server process that handles such requests then asserts the (client) process subject label(s) as it attempts to access a file that has associated Labeled NFS object labels.",
      "ja": "RPCSEC_GSSv3クライアントは、RPCSEC_GSSv3子コンテキストハンドルにラベルアサーションをバインドすることにより、一部のLFSでサブジェクトセキュリティラベルのセットをアサートできます（MAY）。これは、RPCSEC_GSS_CREATE rgss3_create_args rca_assertions呼び出しデータにタイプrgss3_labelのアサーションを含めることによって行われます。ラベルアサーションペイロードは、呼び出し元のNFSクライアントプロセスによってアサートされたサブジェクトラベルのセットです。結果の子コンテキストは、クライアントプロセスのサブジェクトラベルをアサートするNFS要求に使用されます。そのような要求を処理するNFSサーバープロセスは、関連するラベル付きNFSオブジェクトラベルを持つファイルにアクセスしようとするときに、（クライアント）プロセスサブジェクトラベルをアサートします。"
    },
    {
      "indent": 3,
      "text": "Servers that support labeling in the requested LFS MAY map the requested subject label to a different subject label as a result of server-side policy evaluation.",
      "ja": "要求されたLFSでのラベル付けをサポートするサーバーは、サーバー側のポリシー評価の結果として、要求されたサブジェクトラベルを別のサブジェクトラベルにマップしてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "The labels that are accepted by the target and bound to the RPCSEC_GSSv3 context MUST be enumerated in the rcr_assertions field of the rgss3_create_res RPCSEC_GSS_CREATE reply.",
      "ja": "ターゲットによって受け入れられ、RPCSEC_GSSv3コンテキストにバインドされたラベルは、rgss3_create_res RPCSEC_GSS_CREATE応答のrcr_assertionsフィールドに列挙する必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers that do not support labeling or that do not support the requested LFS reject the label assertion with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_LABEL_PROBLEM.",
      "ja": "ラベル付けをサポートしていないサーバー、または要求されたLFSをサポートしていないサーバーは、MSG_DENIEDの返信ステータス、AUTH_ERRORのreject_status、RPCSEC_GSS_LABEL_PROBLEMのauth_statでラベルアサーションを拒否します。"
    },
    {
      "indent": 0,
      "text": "2.7.1.4. Structured Privilege Assertions",
      "section_title": true,
      "ja": "2.7.1.4. 構造化された特権アサーション"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///\n///  typedef opaque utf8string<>;   /* UTF-8 encoding */\n///  typedef utf8string utf8str_cs; /* Case-sensitive UTF-8 */\n///\n///  struct rgss3_privs {\n///          utf8str_cs      rp_name<>;\n///          opaque          rp_privilege<>;\n///  };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "A structured privilege is a capability defined by a specific RPC application. To support the assertion of this privilege, by a client using the application, in a server that also supports the application, the application may define a private data structure that is understood by clients and servers implementing the RPC application.",
      "ja": "構造化された特権は、特定のRPCアプリケーションによって定義される機能です。アプリケーションを使用するクライアントによるこの特権の表明をサポートするために、アプリケーションもサポートするサーバーで、アプリケーションは、RPCアプリケーションを実装するクライアントとサーバーが理解するプライベートデータ構造を定義できます。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a structured privilege by binding the privilege to the RPCSEC_GSSv3 context handle. This is done by including an assertion of type rgss3_privs in the RPCSEC_GSS_CREATE rgss3_create_args rca_assertions call data.",
      "ja": "RPCSEC_GSSv3クライアントは、RPCSEC_GSSv3コンテキストハンドルに特権をバインドすることにより、構造化特権をアサートできます（MAY）。これは、RPCSEC_GSS_CREATE rgss3_create_args rca_assertions呼び出しデータにタイプrgss3_privsのアサーションを含めることによって行われます。"
    },
    {
      "indent": 3,
      "text": "The privilege is identified by the description string that is used by RPCSEC_GSSv3 to identify the privilege and communicate the private data between the relevant RPC application-specific code without needing to be aware of the details of the structure used. Thus, as far as RPCSEC_GSSv3 is concerned, the defined structure is passed between client and server as opaque data encoded in the rpc_gss3_privs rp_privilege field.",
      "ja": "特権は、RPCSEC_GSSv3で使用される説明文字列によって識別され、特権を識別し、使用される構造の詳細を意識することなく、関連するRPCアプリケーション固有のコード間でプライベートデータを通信します。したがって、RPCSEC_GSSv3に関する限り、定義された構造は、rpc_gss3_privs rp_privilegeフィールドにエンコードされた不透明なデータとしてクライアントとサーバーの間で渡されます。"
    },
    {
      "indent": 3,
      "text": "Encoding, server verification, and any server policies for structured privileges are described by the RPC application definition. The rp_name field of rpc_gss3_privs carries the description string used to identify and list the privilege. The utf8str_cs definition is from [RFC7530].",
      "ja": "エンコード、サーバー検証、および構造化特権のサーバーポリシーは、RPCアプリケーション定義で記述されています。 rpc_gss3_privsのrp_nameフィールドには、特権の識別と一覧表示に使用される説明文字列が含まれています。 utf8str_cs定義は、[RFC7530]からのものです。"
    },
    {
      "indent": 3,
      "text": "A successful structured privilege assertion MUST be enumerated in the rcr_assertions field of the rgss3_create_res RPCSEC_GSS_CREATE reply.",
      "ja": "成功した構造化された特権の表明は、rgss3_create_res RPCSEC_GSS_CREATE応答のrcr_assertionsフィールドに列挙する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server receives a structured privilege assertion that it does not recognize, the assertion is rejected with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_UNKNOWN_MESSAGE.",
      "ja": "サーバーが認識しない構造化された特権アサーションを受信した場合、そのアサーションはMSG_DENIEDの応答ステータス、AUTH_ERRORのreject_status、およびRPCSEC_GSS_UNKNOWN_MESSAGEのauth_statで拒否されます。"
    },
    {
      "indent": 3,
      "text": "It is assumed that a client asserting more than one structured privilege to be bound to a context handle would not require all the privilege assertions to succeed.",
      "ja": "コンテキストハンドルにバインドされる複数の構造化された特権をアサートするクライアントは、成功するためにすべての特権アサーションを必要としないと想定されています。"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT reject RPCSEC_GSS_CREATE requests containing supported structured privilege assertions, even if some of those assertions are rejected (e.g., for local policy reasons).",
      "ja": "サーバーは、サポートされている構造化された特権アサーションを含むRPCSEC_GSS_CREATE要求を拒否してはなりません（それらのアサーションの一部が拒否された場合でも（たとえば、ローカルポリシーの理由で）。"
    },
    {
      "indent": 3,
      "text": "If a server receives an RPCSEC_GSS_CREATE request containing one or more unsupported structured privilege assertions, the request MUST be rejected with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_PRIVILEGE_PROBLEM.",
      "ja": "サーバーが1つ以上のサポートされていない構造化特権アサーションを含むRPCSEC_GSS_CREATE要求を受信した場合、要求は、応答ステータスMSG_DENIED、reject_status AUTH_ERROR、およびauth_statのRPCSEC_GSS_PRIVILEGE_PROBLEMで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 4.9.1.1 of [RFC7862] (\"Inter-Server Copy via ONC RPC with RPCSEC_GSSv3\") shows an example of structured privilege definition and use.",
      "ja": "[RFC7862]のセクション4.9.1.1（「RPCSEC_GSSv3を使用したONC RPCによるサーバー間コピー」）は、構造化された特権の定義と使用の例を示しています。"
    },
    {
      "indent": 0,
      "text": "2.7.2. New Control Procedure - RPCSEC_GSS_LIST",
      "section_title": true,
      "ja": "2.7.2. 新しい制御手順-RPCSEC_GSS_LIST"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 6,
      "text": "///  enum rgss3_list_item {\n///          LABEL = 0,\n///          PRIVS = 1\n///  };\n///\n///  struct rgss3_list_args {\n///          rgss3_list_item      rla_list_what<>;\n///  };\n///\n///  union rgss3_list_item_u\n///        switch (rgss3_list_item itype) {\n///  case LABEL:\n///          rgss3_label          rli_labels<>;\n///  case PRIVS:\n///          rgss3_privs          rli_privs<>;\n///  default:\n///          opaque               rli_ext<>;\n///  };\n///\n///  typedef rgss3_list_item_u rgss3_list_res<>;\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 3,
      "text": "The call data for an RPCSEC_GSS_LIST request consists of a list of integers (rla_list_what) indicating what assertions are to be listed, and the reply consists of an error or the requested list.",
      "ja": "RPCSEC_GSS_LIST要求の呼び出しデータは、リストするアサーションを示す整数のリスト（rla_list_what）で構成され、応答はエラーまたは要求されたリストで構成されます。"
    },
    {
      "indent": 3,
      "text": "The result of requesting a list of rgss3_list_item LABEL objects is a list of LFSs supported by the server. The client can then use the LFS list to assert labels via the RPCSEC_GSS_CREATE label assertions. See Section 2.7.1.3.",
      "ja": "rgss3_list_item LABELオブジェクトのリストを要求した結果は、サーバーがサポートするLFSのリストです。クライアントはLFSリストを使用して、RPCSEC_GSS_CREATEラベルアサーションを介してラベルをアサートできます。セクション2.7.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.8. Extensibility",
      "section_title": true,
      "ja": "2.8. 拡張性"
    },
    {
      "indent": 3,
      "text": "Assertion types may be added in the future by adding arms to the \"rgss3_assertion_u\" union (Section 2.7.1) and the \"rgss3_list_item_u\" union (Section 2.7.2). Examples of other potential assertion types include:",
      "ja": "「rgss3_assertion_u」共用体（セクション2.7.1）および「rgss3_list_item_u」共用体（セクション2.7.2）にアームを追加することにより、将来、アサーションタイプが追加される可能性があります。その他の潜在的なアサーションタイプの例には次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o Client-side assertions of identity:",
      "ja": "o IDのクライアント側アサーション："
    },
    {
      "indent": 6,
      "text": "* Primary client/user identity.",
      "ja": "* プライマリクライアント/ユーザーID。"
    },
    {
      "indent": 6,
      "text": "* Supplementary group memberships of the client/user, including support for specifying deltas to the membership list as seen on the server.",
      "ja": "* サーバー上で見られるメンバーシップリストへのデルタの指定のサポートを含む、クライアント/ユーザーの補足グループメンバーシップ。"
    },
    {
      "indent": 0,
      "text": "3. Operational Recommendation for Deployment",
      "section_title": true,
      "ja": "3. 展開の運用に関する推奨事項"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 is a superset of RPCSEC_GSSv2 [RFC5403], which in turn is a superset of RPCSEC_GSSv1 [RFC2203], and so can be used in all situations where RPCSEC_GSSv2 is used, or where RPCSEC_GSSv1 is used and channel-bindings functionality is not needed. RPCSEC_GSSv3 should be used when the new functionality is needed.",
      "ja": "RPCSEC_GSSv3はRPCSEC_GSSv2 [RFC5403]のスーパーセットであり、RPCSEC_GSSv1 [RFC2203]のスーパーセットであり、RPCSEC_GSSv2が使用されるすべての状況、またはRPCSEC_GSSv1が使用され、チャネルバインディング機能が不要な状況で使用できます。 RPCSEC_GSSv3は、新しい機能が必要な場合に使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document deals with security issues.",
      "ja": "このドキュメント全体では、セキュリティの問題を扱います。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSSv3 protocol allows for client-side assertions of data that is relevant to server-side authorization decisions. These assertions must be evaluated by the server in the context of whether the client and/or user are authenticated, whether multi-principal authentication was used, whether the client is trusted, what ranges of assertions are allowed for the client and the user (separately or together), and any relevant server-side policy.",
      "ja": "RPCSEC_GSSv3プロトコルは、サーバー側の承認決定に関連するデータのクライアント側のアサーションを可能にします。これらのアサーションは、クライアントやユーザーが認証されているかどうか、マルチプリンシパル認証が使用されているかどうか、クライアントが信頼されているかどうか、クライアントとユーザーに許可されるアサーションの範囲（個別に）のコンテキストでサーバーによって評価される必要がありますまたは一緒に）、および関連するサーバー側のポリシー。"
    },
    {
      "indent": 3,
      "text": "The security semantics of assertions carried by RPCSEC_GSSv3 are application protocol-specific.",
      "ja": "RPCSEC_GSSv3によって伝達されるアサーションのセキュリティセマンティクスは、アプリケーションプロトコル固有です。"
    },
    {
      "indent": 3,
      "text": "Note that RPCSEC_GSSv3 is not a complete solution for labeling: it conveys the labels of actors but not the labels of objects. RPC application protocols may require extending in order to carry object label information.",
      "ja": "RPCSEC_GSSv3は、ラベル付けの完全なソリューションではないことに注意してください。これは、アクターのラベルを伝達しますが、オブジェクトのラベルを伝達しません。 RPCアプリケーションプロトコルでは、オブジェクトラベル情報を伝達するために拡張が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "There may be interactions with NFSv4's callback security scheme and NFSv4.1's [RFC5661] GSS SSV (Secret State Verifier) mechanisms. Specifically, the NFSv4 callback scheme requires that the server initiate GSS-API security contexts, which does not work well in practice; in the context of client-side processes running as the same user but with different privileges and security labels, the NFSv4 callback security scheme seems particularly unlikely to work well. NFSv4.1 has the server use an existing, client-initiated RPCSEC_GSS context handle to protect server-initiated callback RPCs. The NFSv4.1 callback security scheme lacks all the problems of the NFSv4 scheme; however, it is important that the server pick an appropriate RPCSEC_GSS context handle to protect any callbacks. Specifically, it is important that the server use RPCSEC_GSS context handles that authenticate the client to protect any callbacks related to server state initiated by RPCs protected by RPCSEC_GSSv3 contexts.",
      "ja": "NFSv4のコールバックセキュリティスキームとNFSv4.1の[RFC5661] GSS SSV（Secret State Verifier）メカニズムとの相互作用があるかもしれません。具体的には、NFSv4コールバックスキームでは、サーバーがGSS-APIセキュリティコンテキストを開始する必要がありますが、実際にはうまく機能しません。同じユーザーとして実行されているが、権限とセキュリティラベルが異なるクライアント側プロセスのコンテキストでは、NFSv4コールバックセキュリティスキームが特にうまく機能する可能性は低いようです。 NFSv4.1では、サーバーが既存のクライアントが開始したRPCSEC_GSSコンテキストハンドルを使用して、サーバーが開始したコールバックRPCを保護します。 NFSv4.1コールバックセキュリティスキームには、NFSv4スキームのすべての問題がありません。ただし、コールバックを保護するには、サーバーが適切なRPCSEC_GSSコンテキストハンドルを選択することが重要です。具体的には、サーバーがクライアントを認証するRPCSEC_GSSコンテキストハンドルを使用して、RPCSEC_GSSv3コンテキストで保護されたRPCによって開始されたサーバー状態に関連するコールバックを保護することが重要です。"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.10.10 of [RFC5661], the client is permitted to associate multiple RPCSEC_GSS handles with a single SSV GSS context. RPCSEC_GSSv3 handles will work well with SSV in that the man-in-the-middle attacks described in Section 2.10.10 of [RFC5661] are solved by the new reply verifier (Section 2.3). Using an RPCSEC_GSSv3 handle backed by a GSS-SSV mechanism context as a parent handle in an RPCSEC_GSS_CREATE call, while permitted, is complicated by the lifetime rules of SSV contexts and their associated RPCSEC_GSS handles.",
      "ja": "[RFC5661]のセクション2.10.10で説明されているように、クライアントは複数のRPCSEC_GSSハンドルを単一のSSV GSSコンテキストに関連付けることが許可されています。 [RFC5661]のセクション2.10.10で説明されている中間者攻撃は、新しい返信ベリファイア（セクション2.3）によって解決されるという点で、RPCSEC_GSSv3ハンドルはSSVでうまく機能します。 RPCSEC_GSS_CREATE呼び出しの親ハンドルとしてGSS-SSVメカニズムコンテキストによってサポートされるRPCSEC_GSSv3ハンドルを使用することは、許可されている場合、SSVコンテキストのライフタイムルールとそれに関連するRPCSEC_GSSハンドルによって複雑になります。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section uses terms that are defined in [RFC5226].",
      "ja": "このセクションでは、[RFC5226]で定義されている用語を使用します。"
    },
    {
      "indent": 0,
      "text": "5.1. New RPC Authentication Status Numbers",
      "section_title": true,
      "ja": "5.1. 新しいRPC認証ステータス番号"
    },
    {
      "indent": 3,
      "text": "The following new RPC Authentication Status Numbers have been added to the IANA registry:",
      "ja": "以下の新しいRPC認証ステータス番号がIANAレジストリに追加されました。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_INNER_CREDPROBLEM (15) \"No credentials for multi-principal assertion inner context user\". See Section 2.7.1.1.",
      "ja": "o RPCSEC_GSS_INNER_CREDPROBLEM（15）「マルチプリンシパルアサーション内部コンテキストユーザーの資格情報がありません」。セクション2.7.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_LABEL_PROBLEM (16) \"Problem with label assertion\". See Section 2.7.1.3.",
      "ja": "o RPCSEC_GSS_LABEL_PROBLEM（16）「ラベルアサーションの問題」。セクション2.7.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_PRIVILEGE_PROBLEM (17) \"Problem with structured privilege assertion\". See Section 2.7.1.4.",
      "ja": "o RPCSEC_GSS_PRIVILEGE_PROBLEM（17）「構造化された特権アサーションの問題」。セクション2.7.1.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_UNKNOWN_MESSAGE (18) \"Unknown structured privilege assertion\". See Section 2.7.1.4.",
      "ja": "o RPCSEC_GSS_UNKNOWN_MESSAGE（18）「不明な構造化特権アサーション」。セクション2.7.1.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2. Structured Privilege Name Definitions",
      "section_title": true,
      "ja": "5.2. 構造化された特権名の定義"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry called the \"RPCSEC_GSS Structured Privilege Names Registry\".",
      "ja": "IANAは、「RPCSEC_GSS構造化特権名レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Structured privilege assertions (Section 2.7.1.4) are defined by a specific RPC application. The namespace identifiers for these assertions (the rp_name) are defined as string names. The RPCSEC_GSSv3 protocol does not define the specific assignment of the namespace for these structured privilege assertion names. The IANA registry promotes interoperability where common interests exist. While RPC application developers are allowed to define and use structured privileges as needed, they are encouraged to register structured privilege assertion names with IANA.",
      "ja": "構造化された特権アサーション（セクション2.7.1.4）は、特定のRPCアプリケーションによって定義されます。これらのアサーション（rp_name）の名前空間識別子は、文字列名として定義されます。 RPCSEC_GSSv3プロトコルは、これらの構造化された特権アサーション名の名前空間の特定の割り当てを定義していません。 IANAレジストリは、共通の利益が存在する場合の相互運用性を促進します。 RPCアプリケーション開発者は、必要に応じて構造化特権を定義して使用することができますが、構造化特権アサーション名をIANAに登録することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The registry is to be maintained using the Standards Action policy as defined in Section 4.1 of [RFC5226].",
      "ja": "レジストリは、[RFC5226]のセクション4.1で定義されている標準アクションポリシーを使用して維持されます。"
    },
    {
      "indent": 3,
      "text": "Under the RPCSEC_GSS version 3 specification, the name of a structured privilege can in theory be up to 2^32 - 1 bytes in length, but in practice RPC application clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a structured privilege name that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use, the prefix \"EXPE\" is Reserved. The structured privilege with a zero-length name is Reserved.",
      "ja": "RPCSEC_GSSバージョン3仕様では、構造化された特権の名前は理論的には最大2 ^ 32-1バイトですが、実際にはRPCアプリケーションのクライアントとサーバーはその長さの文字列を処理できません。 IANAは、128 UTF-8文字を超える構造化された特権名を持つ割り当て要求を拒否する必要があります。 IESGに実験的使用の割り当てのベースを設定する柔軟性を与えるために、接頭辞「EXPE」は予約されています。長さがゼロの構造化特権は予約済みです。"
    },
    {
      "indent": 3,
      "text": "The prefix \"PRIV\" is allocated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA's registry should use the prefix \"PRIV\" in all of its structured privilege assertion names.",
      "ja": "接頭辞「PRIV」は私的使用のために割り当てられます。 IANAのレジストリでの割り当てと競合するリスクなしに未登録の名前付き属性を利用したいサイトは、構造化された特権アサーション名のすべてで接頭辞「PRIV」を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because some RPC application clients and servers have case-insensitive semantics, the fifteen additional lower-case and mixed-case permutations of each of \"EXPE\" and \"PRIV\" are Reserved (e.g., \"expe\", \"expE\", and \"exPe\" are Reserved). Similarly, IANA must not allow two assignments that would conflict if both structured privilege names were converted to a common case.",
      "ja": "一部のRPCアプリケーションクライアントとサーバーは大文字と小文字を区別しないセマンティクスを持っているため、「EXPE」と「PRIV」のそれぞれの15の追加の小文字と大文字と小文字の組み合わせは予約されています（たとえば、「expe」、「expE」、「exPe」 \"は予約されています）。同様に、IANAは、構造化された両方の特権名が共通のケースに変換された場合に競合する2つの割り当てを許可してはなりません。"
    },
    {
      "indent": 3,
      "text": "The registry of structured privilege names is a list of assignments, each containing three fields for each assignment.",
      "ja": "構造化された特権名のレジストリは割り当てのリストであり、割り当てにはそれぞれ3つのフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "1. A US-ASCII string name that is the actual name of the structured privilege. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.",
      "ja": "1. 構造化された特権の実際の名前であるUS-ASCII文字列名。この名前は一意である必要があります。この文字列名には、1〜128文字のUTF-8文字を使用できます。"
    },
    {
      "indent": 3,
      "text": "2. A reference to the specification of the RPC-application-defined structured privilege. The reference can consume up to 256 bytes (or more if IANA permits).",
      "ja": "2. RPCアプリケーション定義の構造化特権の仕様への参照。参照は最大256バイト（IANAが許可する場合はそれ以上）を消費できます。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3. 登録者の連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Initial Registry",
      "section_title": true,
      "ja": "5.2.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry consists of the three structured privileges defined in [RFC7862].",
      "ja": "初期レジストリは、[RFC7862]で定義されている3つの構造化された特権で構成されています。"
    },
    {
      "indent": 3,
      "text": "1. NAME: copy_to_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "1. 名前：copy_to_auth、参照：RFC 7862、連絡先：ウィリアムA.（アンディ）アダムソン、andros @ netapp.com"
    },
    {
      "indent": 3,
      "text": "2. NAME: copy_from_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "2. 名前：copy_from_auth、参照：RFC 7862、連絡先：William A.（Andy）Adamson、andros @ netapp.com"
    },
    {
      "indent": 3,
      "text": "3. NAME: copy_confirm_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "3. NAME：copy_confirm_auth、REFERENCE：RFC 7862、CONTACT：William A.（Andy）Adamson、andros @ netapp.com"
    },
    {
      "indent": 0,
      "text": "5.2.2. Updating Registrations",
      "section_title": true,
      "ja": "5.2.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is always permitted to update the point of contact field. To make any other change will require Expert Review or IESG Approval.",
      "ja": "登録者は、連絡先フィールドの更新を常に許可されています。その他の変更を行うには、エキスパートレビューまたはIESG承認が必要です。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2203] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, DOI 10.17487/RFC2203, September 1997, <http://www.rfc-editor.org/info/rfc2203>.",
      "ja": "[RFC2203] Eisler、M.、Chiu、A。、およびL. Ling、「RPCSEC_GSS Protocol Specification」、RFC 2203、DOI 10.17487 / RFC2203、1997年9月、<http://www.rfc-editor.org/info/ rfc2203>。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <http://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[RFC2743] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<http://www.rfc-editor.org/info/rfc2743> 。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <http://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<http://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <http://www.rfc-editor.org/info/rfc5056>.",
      "ja": "[RFC5056]ウィリアムズN.、「セキュアチャネルへのチャネルバインディングの使用について」、RFC 5056、DOI 10.17487 / RFC5056、2007年11月、<http://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5403] Eisler, M., \"RPCSEC_GSS Version 2\", RFC 5403, DOI 10.17487/RFC5403, February 2009, <http://www.rfc-editor.org/info/rfc5403>.",
      "ja": "[RFC5403] Eisler、M。、「RPCSEC_GSSバージョン2」、RFC 5403、DOI 10.17487 / RFC5403、2009年2月、<http://www.rfc-editor.org/info/rfc5403>。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <http://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 \"Network File System（NFS）Version 4 Minor Version 1 Protocol\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<http://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC7530] Haynes, T., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <http://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[RFC7530] Haynes、T。、編、およびD. Noveck、編、「Network File System（NFS）Version 4 Protocol」、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<http：//www.rfc -editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[RFC7862] Haynes, T., \"Network File System (NFS) Version 4 Minor Version 2 Protocol\", RFC 7862, DOI 10.17487/RFC7862, November 2016, <http://www.rfc-editor.org/info/rfc7862>.",
      "ja": "[RFC7862]ヘインズ、T。、「ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル」、RFC 7862、DOI 10.17487 / RFC7862、2016年11月、<http://www.rfc-editor.org/info/rfc7862 >。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AFS-RXGK] Wilkinson, S. and B. Kaduk, \"Integrating rxgk with AFS\", Work in Progress, draft-wilkinson-afs3-rxgk-afs-08, May 2015.",
      "ja": "[AFS-RXGK] Wilkinson、S.およびB. Kaduk、「rxgkとAFSの統合」、作業中、draft-wilkinson-afs3-rxgk-afs-08、2015年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org / info / rfc5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5531] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <http://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[RFC5531] Thurlow、R。、「RPC：Remote Procedure Call Protocol Specification Version 2」、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、<http://www.rfc-editor.org/info/rfc5531>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Andy Adamson would like to thank NetApp, Inc. for its funding of his time on this project.",
      "ja": "Andy Adamsonは、このプロジェクトに費やしたNetApp、Inc.に感謝します。"
    },
    {
      "indent": 3,
      "text": "We thank Lars Eggert, Mike Eisler, Ben Kaduk, Bruce Fields, Tom Haynes, and Dave Noveck for their most helpful reviews.",
      "ja": "Lars Eggert、Mike Eisler、Ben Kaduk、Bruce Fields、Tom Haynes、およびDave Noveckの最も役立つレビューに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "William A. (Andy) Adamson NetApp 3629 Wagner Ridge Ct. Ann Arbor, MI 48103 United States of America",
      "ja": "William A.（Andy）Adamson NetApp 3629 Wagner Ridge Ct。アナーバー、MI 48103アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 734 665 1204\nEmail: andros@netapp.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nico Williams cryptonector.com 13115 Tamayo Dr. Austin, TX 78729 United States of America",
      "ja": "Nico Williams cryptonector.com 13115 Tamayo Dr. Austin、TX 78729アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: nico@cryptonector.com",
      "raw": true,
      "ja": ""
    }
  ]
}