{
  "title": {
    "text": "RFC 7616 - HTTP Digest Access Authentication",
    "ja": "RFC 7616 - HTTPダイジェストアクセス認証"
  },
  "number": 7616,
  "created_at": "2020-08-30 14:19:05.200812+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)               R. Shekh-Yusef, Ed.\nRequest for Comments: 7616                                         Avaya\nObsoletes: 2617                                                D. Ahrens\nCategory: Standards Track                                    Independent\nISSN: 2070-1721                                                S. Bremer\n                                                             Netzkonform\n                                                          September 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "HTTP Digest Access Authentication",
      "ja": "HTTPダイジェストアクセス認証"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、サーバーがクライアント要求にチャレンジするために使用したり、クライアントが認証情報を提供したりするために使用できる単純なチャレンジ/レスポンス認証メカニズムを提供します。このドキュメントでは、HTTP認証メカニズムで使用できるHTTPダイジェスト認証スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7616.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7616で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。 IETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得せずに、このドキュメントをIETF標準プロセス外で変更したり、その派生物をIETF標準プロセス外で作成したりすることはできません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Syntax Convention . . . . . . . . . . . . . . . . . . . . . .   4\n  2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Digest Access Authentication Scheme . . . . . . . . . . . . .   5\n  3.1.  Overall Operation . . . . . . . . . . . . . . . . . . . .   5\n  3.2.  Representation of Digest Values . . . . . . . . . . . . .   5\n  3.3.  The WWW-Authenticate Response Header Field  . . . . . . .   5\n  3.4.  The Authorization Header Field  . . . . . . . . . . . . .   9\n    3.4.1.  Response  . . . . . . . . . . . . . . . . . . . . . .  11\n    3.4.2.  A1  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n    3.4.3.  A2  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n    3.4.4.  Username Hashing  . . . . . . . . . . . . . . . . . .  12\n    3.4.5.  Parameter Values and Quoted-String  . . . . . . . . .  12\n    3.4.6.  Various Considerations  . . . . . . . . . . . . . . .  13\n  3.5.  The Authentication-Info and Proxy-Authentication-Info\n        Header Fields . . . . . . . . . . . . . . . . . . . . . .  14\n  3.6.  Digest Operation  . . . . . . . . . . . . . . . . . . . .  15\n  3.7.  Security Protocol Negotiation . . . . . . . . . . . . . .  16\n  3.8.  Proxy-Authenticate and Proxy-Authorization  . . . . . . .  17\n  3.9.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .  18\n    3.9.1.  Example with SHA-256 and MD5  . . . . . . . . . . . .  18\n    3.9.2.  Example with SHA-512-256, Charset, and Userhash . . .  19\n4.  Internationalization Considerations . . . . . . . . . . . . .  20\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  21\n  5.1.  Limitations . . . . . . . . . . . . . . . . . . . . . . .  21\n  5.2.  Storing Passwords . . . . . . . . . . . . . . . . . . . .  21\n  5.3.  Authentication of Clients Using Digest Authentication . .  22\n  5.4.  Limited-Use Nonce Values  . . . . . . . . . . . . . . . .  23\n  5.5.  Replay Attacks  . . . . . . . . . . . . . . . . . . . . .  23\n  5.6.  Weakness Created by Multiple Authentication Schemes . . .  24\n  5.7.  Online Dictionary Attacks . . . . . . . . . . . . . . . .  24\n  5.8.  Man-in-the-Middle Attacks . . . . . . . . . . . . . . . .  25\n  5.9.  Chosen Plaintext Attacks  . . . . . . . . . . . . . . . .  25\n  5.10. Precomputed Dictionary Attacks  . . . . . . . . . . . . .  26\n  5.11. Batch Brute-Force Attacks . . . . . . . . . . . . . . . .  26\n  5.12. Parameter Randomness  . . . . . . . . . . . . . . . . . .  26\n  5.13. Summary . . . . . . . . . . . . . . . . . . . . . . . . .  26\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  27\n  6.1.  Hash Algorithms for HTTP Digest Authentication  . . . . .  27\n  6.2.  Digest Scheme Registration  . . . . . . . . . . . . . . .  28\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  28\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  28\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  30\nAppendix A.  Changes from RFC 2617  . . . . . . . . . . . . . . .  31",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  32",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.",
      "ja": "HTTPは、サーバーがクライアント要求にチャレンジするために使用したり、クライアントが認証情報を提供したりするために使用できる単純なチャレンジ/レスポンス認証メカニズムを提供します。このドキュメントでは、HTTP認証メカニズムで使用できるHTTPダイジェスト認証スキームを定義します。"
    },
    {
      "indent": 3,
      "text": "This document extends but is generally backward compatible with [RFC2617]. See Appendix A for the new capabilities introduced by this specification.",
      "ja": "このドキュメントは拡張されますが、一般に[RFC2617]との下位互換性があります。この仕様で導入された新機能については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "The details of the challenge-response authentication mechanism are specified in the \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\" [RFC7235].",
      "ja": "チャレンジ/レスポンス認証メカニズムの詳細は、「ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証」[RFC7235]で指定されています。"
    },
    {
      "indent": 3,
      "text": "The combination of this document with the definition of the \"Basic\" authentication scheme [RFC7617], \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\" [RFC7615], and \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\" [RFC7235] obsolete [RFC2617].",
      "ja": "このドキュメントと「基本」認証スキームの定義[RFC7617]、「HTTP Authentication-InfoおよびProxy-Authentication-Info応答ヘッダーフィールド」[RFC7615]、および「ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証」の組み合わせ「[RFC7235]廃止[RFC2617]。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこの文書の \"は、[RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Syntax Convention",
      "section_title": true,
      "ja": "2. 構文規則"
    },
    {
      "indent": 0,
      "text": "2.1. Examples",
      "section_title": true,
      "ja": "2.1. 例"
    },
    {
      "indent": 3,
      "text": "In the interest of clarity and readability, the extended parameters or the header fields and parameters in the examples in this document might be broken into multiple lines. Any line that is indented in this document is a continuation of the preceding line.",
      "ja": "明確さと読みやすさのために、このドキュメントの例の拡張パラメーターまたはヘッダーフィールドとパラメーターは、複数の行に分割される場合があります。このドキュメントでインデントされている行は、前の行の続きです。"
    },
    {
      "indent": 0,
      "text": "2.2. ABNF",
      "section_title": true,
      "ja": "2.2. ABNF"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] and the ABNF List Extension of [RFC7230].",
      "ja": "この仕様では、[RFC5234]のAugmented Backus-Naur Form（ABNF）表記と[RFC7230]のABNFリスト拡張を使用しています。"
    },
    {
      "indent": 0,
      "text": "3. Digest Access Authentication Scheme",
      "section_title": true,
      "ja": "3. ダイジェストアクセス認証スキーム"
    },
    {
      "indent": 0,
      "text": "3.1. Overall Operation",
      "section_title": true,
      "ja": "3.1. 全体の操作"
    },
    {
      "indent": 3,
      "text": "The Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges using a nonce value and might indicate that username hashing is supported. A valid response contains an unkeyed digest of the username, the password, the given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear, and the username can be hashed, depending on the indication received from the server. The username and password must be prearranged in some fashion not addressed by this document.",
      "ja": "ダイジェストスキームは、単純なチャレンジ/レスポンスパラダイムに基づいています。ダイジェストスキームはnonce値を使用してチャレンジし、ユーザー名のハッシュがサポートされていることを示す場合があります。有効な応答には、ユーザー名、パスワード、指定されたナンス値、HTTPメソッド、および要求されたURIのキーなしダイジェストが含まれています。この方法では、パスワードが平文で送信されることはなく、サーバーから受信した指示に応じて、ユーザー名をハッシュ化できます。ユーザー名とパスワードは、このドキュメントでは扱わない方法で事前に準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Representation of Digest Values",
      "section_title": true,
      "ja": "3.2. ダイジェスト値の表現"
    },
    {
      "indent": 3,
      "text": "An optional header field allows the server to specify the algorithm used to create the unkeyed digest or digest. This document adds SHA-256 and SHA-512/256 algorithms. To maintain backwards compatibility with [RFC2617], the MD5 algorithm is still supported but NOT RECOMMENDED.",
      "ja": "オプションのヘッダーフィールドを使用すると、サーバーは、キーなしダイジェストまたはダイジェストの作成に使用されるアルゴリズムを指定できます。このドキュメントでは、SHA-256およびSHA-512 / 256アルゴリズムを追加します。 [RFC2617]との下位互換性を維持するために、MD5アルゴリズムは引き続きサポートされますが、推奨されません。"
    },
    {
      "indent": 3,
      "text": "The size of the digest depends on the algorithm used. The bits in the digest are converted from the most significant to the least significant bit, four bits at a time, to the ASCII representation as follows. Each sequence of four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef; that is, binary 0000 is represented by the character '0', 0001 by '1' and so on up to the representation of 1111 as 'f'. If the MD5 algorithm is used to calculate the digest, then the MD5 digest will be represented as 32 hexadecimal characters, while SHA-256 and SHA-512/256 are represented as 64 hexadecimal characters.",
      "ja": "ダイジェストのサイズは、使用するアルゴリズムによって異なります。ダイジェストのビットは、次のように一度に4ビットずつ、最上位ビットから最下位ビットに変換されます。 4ビットの各シーケンスは、文字0123456789abcdefからのよく知られた16進表記で表されます。つまり、バイナリ0000は文字「0」で表され、0001は「1」で表され、1111が「f」として表されるまで続きます。 MD5アルゴリズムを使用してダイジェストを計算する場合、MD5ダイジェストは32桁の16進文字として表され、SHA-256およびSHA-512 / 256は64桁の16進文字として表されます。"
    },
    {
      "indent": 0,
      "text": "3.3. The WWW-Authenticate Response Header Field",
      "section_title": true,
      "ja": "3.3. WWW-Authenticate応答ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "If a server receives a request for an access-protected object, and an acceptable Authorization header field is not sent, the server responds with a \"401 Unauthorized\" status code and a WWW-Authenticate header field with Digest scheme as per the framework defined above. The value of the header field can include parameters from the following list:",
      "ja": "サーバーがアクセス保護されたオブジェクトの要求を受信し、受け入れ可能なAuthorizationヘッダーフィールドが送信されない場合、サーバーは、「401 Unauthorized」ステータスコードと、上記で定義されたフレームワークに従ってダイジェスト方式のWWW-Authenticateヘッダーフィールドで応答します。 。ヘッダーフィールドの値には、次のリストのパラメーターを含めることができます。"
    },
    {
      "indent": 3,
      "text": "realm",
      "ja": "領域"
    },
    {
      "indent": 0,
      "text": " A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access. An example is \"registered_users@example.com\". (See Section 2.2 of [RFC7235] for more details.)",
      "ja": "使用するユーザー名とパスワードをユーザーに知らせるためにユーザーに表示する文字列。この文字列には、少なくとも認証を実行するホストの名前が含まれている必要があり、さらにアクセス権を持つ可能性のあるユーザーのコレクションを示す場合もあります。例は「registered_users@example.com」です。 （詳細については、[RFC7235]のセクション2.2をご覧ください）。"
    },
    {
      "indent": 3,
      "text": "domain",
      "ja": "ドメイン"
    },
    {
      "indent": 6,
      "text": "A quoted, space-separated list of URIs, as specified in [RFC3986], that define the protection space. If a URI is a path-absolute, it is relative to the canonical root URL. (See Section 2.2 of [RFC7235].) An absolute-URI in this list may refer to a different server than the web-origin [RFC6454]. The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI that has a URI in this list as a prefix (after both have been made absolute) MAY be assumed to be in the same protection space. If this parameter is omitted or its value is empty, the client SHOULD assume that the protection space consists of all URIs on the web-origin.",
      "ja": "[RFC3986]で指定されている、保護スペースを定義する、引用符で区切られたURIのリスト。 URIが絶対パスである場合、それは正規のルートURLを基準にしています。 （[RFC7235]のセクション2.2を参照してください。）このリストの絶対URIは、web-origin [RFC6454]とは異なるサーバーを参照する場合があります。クライアントはこのリストを使用して、同じ認証情報を送信できるURIのセットを決定できます。このリストのURIをプレフィックスとして持つすべてのURI（両方を絶対にした後）は同じであると見なすことができます保護スペース。このパラメーターが省略されている場合、またはその値が空の場合、クライアントは、保護スペースがweb-origin上のすべてのURIで構成されていると想定する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "This parameter is not meaningful in Proxy-Authenticate header fields, for which the protection space is always the entire proxy; if present, it MUST be ignored.",
      "ja": "このパラメーターは、保護スペースが常にプロキシ全体であるProxy-Authenticateヘッダーフィールドでは意味がありません。存在する場合は、無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "nonce",
      "ja": "nuncio"
    },
    {
      "indent": 6,
      "text": "A server-specified string which should be uniquely generated each time a 401 response is made. It is advised that this string be Base64 or hexadecimal data. Specifically, since the string is passed in the header field lines as a quoted string, the double-quote character is not allowed, unless suitably escaped.",
      "ja": "401応答が行われるたびに一意に生成されるサーバー指定の文字列。この文字列はBase64または16進データであることが推奨されます。具体的には、文字列は引用符付きの文字列としてヘッダーフィールドの行に渡されるため、適切にエスケープしない限り、二重引用符は使用できません。"
    },
    {
      "indent": 6,
      "text": "The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce might, for example, be constructed as the Base64 encoding of",
      "ja": "nonceの内容は実装に依存します。実装の品質は、適切な選択に依存します。 nonceは、たとえば、次のBase64エンコーディングとして構築されます。"
    },
    {
      "indent": 12,
      "text": "timestamp H(timestamp \":\" ETag \":\" secret-data)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " where timestamp is a server-generated time, which preferably includes micro- or nanoseconds, or other non-repeating values; ETag is the value of the HTTP ETag header field associated with the requested entity; and secret-data is data known only to the server. With a nonce of this form, a server would recalculate the hash portion after receiving the client authentication header field and reject the request if it did not match the nonce from that header field or if the timestamp value is not recent enough. In this way, the server can limit the time of the nonce's validity. The inclusion of the ETag prevents a replay request for an updated version of the resource. Including the IP address of the client in the nonce would appear to offer the server the ability to limit the reuse of the nonce to the same client that originally got it. However, that would break because requests from a single user often go through different proxies. Also, IP address spoofing is not that hard.",
      "ja": "ここで、タイムスタンプはサーバーが生成した時間であり、マイクロ秒またはナノ秒、または他の繰り返されない値を含むことが好ましい。 ETagは、要求されたエンティティに関連付けられたHTTP ETagヘッダーフィールドの値です。秘密データはサーバーだけが知っているデータです。この形式のナンスを使用すると、サーバーはクライアント認証ヘッダーフィールドを受信した後にハッシュ部分を再計算し、そのヘッダーフィールドからのナンスと一致しない場合、またはタイムスタンプ値が十分に新しい場合、要求を拒否します。このようにして、サーバーはnonceの有効期間を制限できます。 ETagを含めることにより、更新されたバージョンのリソースの再生要求を防ぐことができます。 nonceにクライアントのIPアドレスを含めると、nonceの再利用を最初に取得したのと同じクライアントに制限する機能がサーバーに提供されます。ただし、1人のユーザーからの要求がさまざまなプロキシを経由することが多いため、これはうまくいきません。また、IPアドレスのなりすましはそれほど難しくありません。"
    },
    {
      "indent": 6,
      "text": "An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a timestamp for GET requests. For more details on the issues involved, see Section 5 of this document.",
      "ja": "実装は、リプレイ攻撃から保護するために、以前に使用されたナンスまたは以前に使用されたダイジェストを受け入れないことを選択する場合があります。または、実装では、POSTまたはPUT要求に1回限りのナンスまたはダイジェストを使用し、GET要求にタイムスタンプを使用することを選択できます。関連する問題の詳細については、このドキュメントのセクション5を参照してください。"
    },
    {
      "indent": 6,
      "text": "The nonce is opaque to the client.",
      "ja": "nonceはクライアントに対して不透明です。"
    },
    {
      "indent": 3,
      "text": "opaque",
      "ja": "不透明な"
    },
    {
      "indent": 6,
      "text": "A string of data, specified by the server, that SHOULD be returned by the client unchanged in the Authorization header field of subsequent requests with URIs in the same protection space. It is RECOMMENDED that this string be Base64 or hexadecimal data.",
      "ja": "サーバーによって指定されたデータの文字列で、同じ保護スペース内のURIを使用する後続のリクエストのAuthorizationヘッダーフィールドで変更されずにクライアントから返される必要があります。この文字列はBase64または16進データであることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "stale",
      "ja": "まだ"
    },
    {
      "indent": 6,
      "text": "A case-insensitive flag indicating that the previous request from the client was rejected because the nonce value was stale. If stale is true, the client may wish to simply retry the request with a new encrypted response, without re-prompting the user for a new username and password. The server SHOULD only set stale to true if it receives a request for which the nonce is invalid. If stale is false, or anything other than true, or the stale parameter is not present, the username and/or password are invalid, and new values MUST be obtained.",
      "ja": "nonce値が古いため、クライアントからの前の要求が拒否されたことを示す、大文字小文字を区別しないフラグ。 staleがtrueの場合、クライアントは、ユーザーに新しいユーザー名とパスワードの再入力を求めずに、新しい暗号化された応答で要求を再試行することを望む場合があります。サーバーは、ナンスが無効なリクエストを受信した場合にのみ、staleをtrueに設定する必要があります（SHOULD）。 staleがfalse、true以外の場合、またはstaleパラメーターが存在しない場合、ユーザー名またはパスワード、あるいはその両方が無効であり、新しい値を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "algorithm",
      "ja": "アルゴリズム"
    },
    {
      "indent": 6,
      "text": "A string indicating an algorithm used to produce the digest and an unkeyed digest. If this is not present, it is assumed to be \"MD5\". If the algorithm is not understood, the challenge SHOULD be ignored (and a different one used, if there is more than one).",
      "ja": "ダイジェストとキーなしダイジェストを生成するために使用されるアルゴリズムを示す文字列。これが存在しない場合は、「MD5」と見なされます。アルゴリズムが理解されていない場合、チャレンジは無視する必要があります（複数ある場合は別のチャレンジを使用する必要があります）。"
    },
    {
      "indent": 6,
      "text": "When used with the Digest mechanism, each one of the algorithms has two variants: Session variant and non-Session variant. The non-Session variant is denoted by \"<algorithm>\", e.g., \"SHA-256\", and the Session variant is denoted by \"<algorithm>-sess\", e.g., \"SHA-256-sess\".",
      "ja": "ダイジェストメカニズムと共に使用すると、アルゴリズムにはそれぞれ、セッションバリアントと非セッションバリアントの2つのバリアントがあります。非セッションバリアントは「<アルゴリズム>」、たとえば「SHA-256」で示され、セッションバリアントは「<アルゴリズム> -sess」、たとえば「SHA-256-sess」で示されます。"
    },
    {
      "indent": 0,
      "text": " In this document, the string obtained by applying the digest algorithm to the data \"data\" with secret \"secret\" will be denoted by KD(secret, data), and the string obtained by applying the unkeyed digest algorithm to the data \"data\" will be denoted H(data). KD stands for Keyed Digest, and the notation unq(X) means the value of the quoted-string X without the surrounding quotes and with quoting slashes removed.",
      "ja": "このドキュメントでは、秘密の「秘密」を持つデータ「データ」にダイジェストアルゴリズムを適用して得られる文字列をKD（secret、data）と表し、データ「データ」にキーなしのダイジェストアルゴリズムを適用して得られる文字列を表記しますH（データ）と表記します。 KDはキー付きダイジェストを表し、表記unq（X）は、引用符で囲まれた文字列Xの値を意味します。"
    },
    {
      "indent": 8,
      "text": "For \"<algorithm>\" and \"<algorithm>-sess\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "H(data) = <algorithm>(data)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 12,
      "text": "KD(secret, data) = H(concat(secret, \":\", data))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 8,
      "text": "For the \"SHA-256\" and \"SHA-256-sess\" algorithms",
      "ja": "「SHA-256」および「SHA-256-sess」アルゴリズムの場合"
    },
    {
      "indent": 12,
      "text": "H(data) = SHA-256(data)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "i.e., the digest is the \"<algorithm>\" of the secret concatenated with a colon concatenated with the data. The \"<algorithm>-sess\" is intended to allow efficient third-party authentication servers; for the difference in usage, see the description in Section 3.4.2.",
      "ja": "つまり、ダイジェストは、データと連結されたコロンで連結された秘密の「<アルゴリズム>」です。 「<algorithm> -sess」は、効率的なサードパーティ認証サーバーを許可することを目的としています。使用方法の違いについては、3.4.2項の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "錫"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. It is a quoted string of one or more tokens indicating the \"quality of protection\" values supported by the server. The value \"auth\" indicates authentication; the value \"auth-int\" indicates authentication with integrity protection. See the descriptions below for calculating the response parameter value for the application of this choice. Unrecognized options MUST be ignored.",
      "ja": "このパラメーターは、すべての実装で使用する必要があります。これは、サーバーでサポートされている「保護品質」の値を示す1つ以上のトークンの引用符付き文字列です。値「auth」は認証を示します。値「auth-int」は、整合性保護を伴う認証を示します。この選択のアプリケーションの応答パラメーター値の計算については、以下の説明を参照してください。認識されないオプションは無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "charset",
      "ja": "文字コード"
    },
    {
      "indent": 6,
      "text": "This is an OPTIONAL parameter that is used by the server to indicate the encoding scheme it supports. The only allowed value is \"UTF-8\".",
      "ja": "これは、サーバーがサポートするエンコード方式を示すためにサーバーが使用するOPTIONALパラメーターです。許可される値は「UTF-8」のみです。"
    },
    {
      "indent": 3,
      "text": "userhash",
      "ja": "ユーザーハッシュ"
    },
    {
      "indent": 6,
      "text": "This is an OPTIONAL parameter that is used by the server to indicate that it supports username hashing. Valid values are: \"true\" or \"false\". Default value is \"false\".",
      "ja": "これは、ユーザー名ハッシュをサポートすることを示すためにサーバーが使用するOPTIONALパラメーターです。有効な値は、「true」または「false」です。デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax values for the following parameters: realm, domain, nonce, opaque, and qop.",
      "ja": "歴史的な理由から、送信者は、レルム、ドメイン、ノンス、不透明、およびqopのパラメーターの引用文字列構文値のみを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax values for the following parameters: stale and algorithm.",
      "ja": "歴史的な理由により、送信者は次のパラメーターの引用文字列構文値を生成してはなりません（古く、アルゴリズム）。"
    },
    {
      "indent": 0,
      "text": "3.4. The Authorization Header Field",
      "section_title": true,
      "ja": "3.4. Authorizationヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The client is expected to retry the request, passing an Authorization header field line with Digest scheme, which is defined according to the framework above. The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header field for the entity being requested.",
      "ja": "クライアントは、リクエストを再試行し、上記のフレームワークに従って定義されたダイジェストスキームを含むAuthorizationヘッダーフィールド行を渡すことが期待されます。不透明フィールドとアルゴリズムフィールドの値は、要求されているエンティティのWWW-Authenticate応答ヘッダーフィールドで指定された値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The request can include parameters from the following list:",
      "ja": "リクエストには、次のリストのパラメータを含めることができます。"
    },
    {
      "indent": 3,
      "text": "response",
      "ja": "応答"
    },
    {
      "indent": 6,
      "text": "A string of the hex digits computed as defined below; it proves that the user knows a password.",
      "ja": "以下で定義されているように計算された16進数の文字列。ユーザーがパスワードを知っていることを証明します。"
    },
    {
      "indent": 3,
      "text": "username",
      "ja": "ユーザー名"
    },
    {
      "indent": 6,
      "text": "The user's name in the specified realm. The quoted string contains the name in plaintext or the hash code in hexadecimal notation. If the username contains characters not allowed inside the ABNF quoted-string production, the username* parameter can be used. Sending both username and username* in the same header option MUST be treated as an error.",
      "ja": "指定されたレルム内のユーザーの名前。引用符で囲まれた文字列には、プレーンテキストの名前または16進表記のハッシュコードが含まれます。ユーザー名に、ABNF引用文字列の生成で許可されていない文字が含まれている場合は、username *パラメーターを使用できます。同じヘッダーオプションでユーザー名とユーザー名*の両方を送信すると、エラーとして扱われる必要があります。"
    },
    {
      "indent": 3,
      "text": "username*",
      "ja": "ユーザー名*"
    },
    {
      "indent": 6,
      "text": "If the userhash parameter value is set \"false\" and the username contains characters not allowed inside the ABNF quoted-string production, the user's name can be sent with this parameter, using the extended notation defined in [RFC5987].",
      "ja": "userhashパラメータ値が \"false\"に設定されていて、ユーザー名にABNF引用文字列プロダクション内で許可されていない文字が含まれている場合、[RFC5987]で定義されている拡張表記を使用して、ユーザーの名前をこのパラメータで送信できます。"
    },
    {
      "indent": 3,
      "text": "realm",
      "ja": "領域"
    },
    {
      "indent": 6,
      "text": "See \"realm\" definition in Section 3.3.",
      "ja": "セクション3.3の「レルム」の定義を参照してください。"
    },
    {
      "indent": 3,
      "text": "uri",
      "ja": "売り"
    },
    {
      "indent": 6,
      "text": "The Effective Request URI (Section 5.5 of [RFC7230]) of the HTTP request; duplicated here because proxies are allowed to change the request target (\"request-target\", Section 3.1.1 of [RFC7230]) in transit.",
      "ja": "HTTPリクエストの有効なリクエストURI（[RFC7230]のセクション5.5）。プロキシは転送中にリクエストターゲット（「request-target」、[RFC7230]のセクション3.1.1）を変更できるため、ここで複製されます。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "錫"
    },
    {
      "indent": 6,
      "text": "Indicates what \"quality of protection\" the client has applied to the message. Its value MUST be one of the alternatives the server indicated it supports in the WWW-Authenticate header field. These values affect the computation of the response. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.",
      "ja": "クライアントがメッセージに適用した「保護品質」を示します。その値は、サーバーがWWW-Authenticateヘッダーフィールドでサポートすることを示した代替の1つでなければなりません。これらの値は、応答の計算に影響します。これは単一のトークンであり、WWW-Authenticateのような代替の引用リストではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "cnonce",
      "ja": "cnonce"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. The cnonce value is an opaque quoted ASCII-only string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of the rspauth and response values.",
      "ja": "このパラメーターは、すべての実装で使用する必要があります。 cnonce値は、クライアントによって提供される不透明な引用ASCIIのみの文字列値であり、選択された平文攻撃を回避し、相互認証を提供し、メッセージの完全性を保護するためにクライアントとサーバーの両方で使用されます。 rspauthと応答値の計算については、以下の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "nc",
      "ja": "nc"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. The nc parameter stands for \"nonce count\". The nc value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request. For example, in the first request sent in response to a given nonce value, the client sends \"nc=00000001\". The purpose of this parameter is to allow the server to detect request replays by maintaining its own copy of this count -- if the same nc value is seen twice, then the request is a replay. See the description below of the construction of the response value.",
      "ja": "このパラメーターは、すべての実装で使用する必要があります。 ncパラメータは「ノンスカウント」を表します。 nc値は、クライアントがこの要求のnonce値で送信した要求（現在の要求を含む）の数の16進数です。たとえば、指定されたナンス値に応答して送信される最初の要求では、クライアントは「nc = 00000001」を送信します。このパラメーターの目的は、サーバーがこのカウントの独自のコピーを維持することにより、要求の再生を検出できるようにすることです。同じnc値が2回見られる場合、要求は再生です。応答値の構成については、以下の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "userhash",
      "ja": "ユーザーハッシュ"
    },
    {
      "indent": 6,
      "text": "This OPTIONAL parameter is used by the client to indicate that the username has been hashed. Valid values are: \"true\" or \"false\". Default value is \"false\".",
      "ja": "このOPTIONALパラメータは、ユーザー名がハッシュされたことを示すためにクライアントによって使用されます。有効な値は、「true」または「false」です。デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax for the following parameters: username, realm, nonce, uri, response, cnonce, and opaque.",
      "ja": "歴史的な理由により、送信者は次のパラメーターの引用符付き文字列構文のみを生成する必要があります：ユーザー名、レルム、ノンス、uri、応答、cnonce、および不透明。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax for the following parameters: algorithm, qop, and nc.",
      "ja": "歴史的な理由により、送信者は次のパラメーターの引用符付き文字列構文を生成してはなりません（MUST NOT）：アルゴリズム、qop、およびnc。"
    },
    {
      "indent": 0,
      "text": " If a parameter or its value is improper, or required parameters are missing, the proper response is a 4xx error code. If the response is invalid, then a login failure SHOULD be logged, since repeated login failures from a single client may indicate an attacker attempting to guess passwords. The server implementation SHOULD be careful with the information being logged so that it won't put a cleartext password (e.g., entered into the username field) into the log.",
      "ja": "パラメータまたはその値が不適切であるか、必要なパラメータが欠落している場合、適切な応答は4xxエラーコードです。応答が無効な場合は、ログイン失敗を記録する必要があります。これは、単一のクライアントからのログイン失敗が繰り返されると、攻撃者がパスワードを推測しようとする可能性があるためです。サーバーの実装では、ログに記録される情報に注意して、クリアテキストのパスワード（ユーザー名フィールドに入力されたパスワードなど）がログに記録されないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The definition of the response above indicates the encoding for its value. The following definitions show how the value is computed.",
      "ja": "上記の応答の定義は、その値のエンコーディングを示しています。次の定義は、値の計算方法を示しています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Response",
      "section_title": true,
      "ja": "3.4.1. 応答"
    },
    {
      "indent": 3,
      "text": "If the qop value is \"auth\" or \"auth-int\":",
      "ja": "qop値が「auth」または「auth-int」の場合："
    },
    {
      "indent": 9,
      "text": "response = <\"> < KD ( H(A1), unq(nonce)\n                             \":\" nc\n                             \":\" unq(cnonce)\n                             \":\" unq(qop)\n                             \":\" H(A2)\n                    ) <\">",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "See below for the definitions for A1 and A2.",
      "ja": "A1とA2の定義については、以下を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.2. A1",
      "section_title": true,
      "ja": "3.4.2. A1"
    },
    {
      "indent": 3,
      "text": "If the algorithm parameter's value is \"<algorithm>\", e.g., \"SHA-256\", then A1 is:",
      "ja": "アルゴリズムパラメータの値が「<アルゴリズム>」、たとえば「SHA-256」の場合、A1は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A1       = unq(username) \":\" unq(realm) \":\" passwd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "ただし"
    },
    {
      "indent": 9,
      "text": "passwd   = < user's password >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the algorithm parameter's value is \"<algorithm>-sess\", e.g., \"SHA-256-sess\", then A1 is calculated using the nonce value provided in the challenge from the server, and cnonce value from the request by the client following receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, herein called nonce-prime, and the client nonce value from the response, herein called cnonce-prime, to construct A1 as follows:",
      "ja": "アルゴリズムパラメータの値が「<algorithm> -sess」、たとえば「SHA-256-sess」の場合、A1は、サーバーからのチャレンジで提供されたnonce値と、次のクライアントによるリクエストからのcnonce値を使用して計算されます。サーバーからのWWW-Authenticateチャレンジの受信。次のようにA1を構築するために、ここではnonce-primeと呼ばれるそのチャレンジからのサーバーnonceと、ここではcnonce-primeと呼ばれる応答からのクライアントnonce値を使用します。"
    },
    {
      "indent": 9,
      "text": "A1       = H( unq(username) \":\" unq(realm) \":\" passwd )\n               \":\" unq(nonce-prime) \":\" unq(cnonce-prime)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " This creates a \"session key\" for the authentication of subsequent requests and responses that is different for each \"authentication session\", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication session in Section 3.6.) Because the server needs only use the hash of the user credentials in order to create the A1 value, this construction could be used in conjunction with a third-party authentication service so that the web server would not need the actual password value. The specification of such a protocol is beyond the scope of this specification.",
      "ja": "これにより、「認証セッション」ごとに異なる後続の要求と応答の認証用の「セッションキー」が作成され、1つのキーでハッシュされるマテリアルの量が制限されます。 （注：セクション3.6の認証セッションの詳細な説明を参照してください。）サーバーはA1値を作成するためにユーザー資格情報のハッシュのみを使用する必要があるため、この構成はサードパーティの認証サービスと組み合わせて使用​​できます。 Webサーバーが実際のパスワード値を必要としないこと。このようなプロトコルの仕様は、この仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "3.4.3. A2",
      "section_title": true,
      "ja": "3.4.3. ああ"
    },
    {
      "indent": 3,
      "text": "If the qop parameter's value is \"auth\" or is unspecified, then A2 is:",
      "ja": "qopパラメータの値が「auth」または指定されていない場合、A2は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A2 = Method \":\" request-uri",
      "ja": "A2 =メソッド \"：\" request-uri"
    },
    {
      "indent": 3,
      "text": "If the qop value is \"auth-int\", then A2 is:",
      "ja": "qop値が「auth-int」の場合、A2は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A2       = Method \":\" request-uri \":\" H(entity-body)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.4.4. Username Hashing",
      "section_title": true,
      "ja": "3.4.4. ユーザー名のハッシュ"
    },
    {
      "indent": 3,
      "text": "To protect the transport of the username from the client to the server, the server SHOULD set the userhash parameter with the value of \"true\" in the WWW-Authentication header field.",
      "ja": "クライアントからサーバーへのユーザー名のトランスポートを保護するために、サーバーはWHW-Authenticationヘッダーフィールドの値「true」でuserhashパラメータを設定する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If the client supports the userhash parameter, and the userhash parameter value in the WWW-Authentication header field is set to \"true\", then the client MUST calculate a hash of the username after any other hash calculation and include the userhash parameter with the value of \"true\" in the Authorization header field. If the client does not provide the username as a hash value or the userhash parameter with the value of \"true\", the server MAY reject the request.",
      "ja": "クライアントがuserhashパラメーターをサポートし、WWW-Authenticationヘッダーフィールドのuserhashパラメーター値が「true」に設定されている場合、クライアントは他のハッシュ計算の後にユーザー名のハッシュを計算し、その値にuserhashパラメーターを含める必要がありますAuthorizationヘッダーフィールドの「true」。クライアントがユーザー名をハッシュ値として提供しないか、値が「true」のuserhashパラメーターを提供しない場合、サーバーは要求を拒否できます。"
    },
    {
      "indent": 3,
      "text": "The following is the operation that the client will perform to hash the username, using the same algorithm used to hash the credentials:",
      "ja": "以下は、資格情報のハッシュに使用されるのと同じアルゴリズムを使用して、ユーザー名をハッシュするためにクライアントが実行する操作です。"
    },
    {
      "indent": 6,
      "text": "username = H( unq(username) \":\" unq(realm) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.4.5. Parameter Values and Quoted-String",
      "section_title": true,
      "ja": "3.4.5. パラメータ値と引用文字列"
    },
    {
      "indent": 3,
      "text": "Note that the value of many of the parameters, such as username value, are defined as a \"quoted-string\". However, the \"unq\" notation indicates that surrounding quotation marks are removed in forming the string A1. Thus, if the Authorization header field includes the fields",
      "ja": "ユーザー名の値など、多くのパラメータの値は「引用文字列」として定義されていることに注意してください。ただし、 \"unq\"表記は、文字列A1を形成するときに周囲の引用符が削除されることを示します。したがって、Authorizationヘッダーフィールドにフィールドが含まれている場合"
    },
    {
      "indent": 6,
      "text": "username=\"Mufasa\", realm=\"myhost@example.com\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the user Mufasa has password \"Circle Of Life\", then H(A1) would be H(Mufasa:myhost@example.com:Circle Of Life) with no quotation marks in the digested string.",
      "ja": "ユーザーMufasaのパスワードが「Circle Of Life」の場合、H（A1）はH（Mufasa：myhost@example.com：Circle Of Life）となり、ダイジェストされた文字列に引用符は含まれません。"
    },
    {
      "indent": 3,
      "text": "No white space is allowed in any of the strings to which the digest function H() is applied, unless that white space exists in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated above must be",
      "ja": "ダイジェスト関数H()が適用される文字列には、引用符で囲まれた文字列またはダイジェスト対象の文字列を構成する内容を持つエンティティ本体に空白が存在しない限り、空白は許可されません。たとえば、上記の文字列A1は、"
    },
    {
      "indent": 6,
      "text": "Mufasa:myhost@example.com:Circle Of Life",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise, the other strings digested by H() must not have white space on either side of the colons that delimit their fields, unless that white space was in the quoted strings or entity body being digested.",
      "ja": "コロンの両側に空白はありませんが、パスワード値で使用される単語の間に空白があります。同様に、H()でダイジェストされた他の文字列は、引用符で囲まれた文字列またはダイジェストされるエンティティ本体に空白がない限り、フィールドを区切るコロンの両側にスペースがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "Also, note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -- it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded header fields in each part of any multipart content-type.",
      "ja": "また、整合性保護が適用されている場合（qop = auth-int）、H（entity-body）はエンティティ本文のハッシュであり、メッセージ本文ではありません。これは、送信者が転送エンコーディングを適用する前に計算されます。受信者によって削除された後。これには、マルチパートコンテンツタイプの各パートのマルチパート境界と埋め込みヘッダーフィールドが含まれることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Various Considerations",
      "section_title": true,
      "ja": "3.4.6. さまざまな考慮事項"
    },
    {
      "indent": 3,
      "text": "The \"Method\" value is the HTTP request method, in US-ASCII letters, as specified in Section 3.1.1 of [RFC7230]. The \"request-target\" value is the request-target from the request line as specified in Section 3.1.1 of [RFC7230]. This MAY be \"*\", an \"absolute-URI\", or an \"absolute-path\" as specified in Section 2.7 of [RFC7230], but it MUST agree with the request-target. In particular, it MUST be an \"absolute-URI\" if the request-target is an \"absolute-URI\". The cnonce value is a client-chosen value whose purpose is to foil chosen plaintext attacks.",
      "ja": "[メソッド]値は、[RFC7230]のセクション3.1.1で指定されているUS-ASCII文字のHTTPリクエストメソッドです。 「request-target」の値は、[RFC7230]のセクション3.1.1で指定されているリクエストラインからのリクエストターゲットです。これは、[RFC7230]のセクション2.7で指定されている「*」、「absolute-URI」、または「absolute-path」である場合がありますが、要求ターゲットと一致する必要があります。特に、request-targetが「absolute-URI」の場合、「absolute-URI」でなければなりません。 cnonce値はクライアントが選択した値であり、その目的は選択された平文攻撃を阻止することです。"
    },
    {
      "indent": 3,
      "text": "The authenticating server MUST assure that the resource designated by the \"uri\" parameter is the same as the resource specified in the Request-Line; if they are not, the server SHOULD return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would not result in the same digest as that calculated by the client.",
      "ja": "認証サーバーは、「uri」パラメーターで指定されたリソースがRequest-Lineで指定されたリソースと同じであることを保証する必要があります。そうでない場合、サーバーは400 Bad Requestエラーを返す必要があります（SHOULD）。 （これは攻撃の兆候である可能性があるため、サーバー実装者はそのようなエラーのロギングを検討することをお勧めします。）このフィールドの要求URLから情報を複製する目的は、中間プロキシがクライアントの要求を変更する可能性に対処することです。ライン。この変更された（ただし、おそらく意味的に同等の）要求は、クライアントによって計算されたものと同じダイジェストにはなりません。"
    },
    {
      "indent": 3,
      "text": "Implementers should be aware of how authenticated transactions need to interact with shared caches (see [RFC7234]).",
      "ja": "実装者は、認証されたトランザクションがどのように共有キャッシュと対話する必要があるかを認識している必要があります（[RFC7234]を参照）。"
    },
    {
      "indent": 0,
      "text": "3.5. The Authentication-Info and Proxy-Authentication-Info Header Fields",
      "ja": "3.5. Authentication-InfoおよびProxy-Authentication-Infoヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header field and the Proxy-Authentication-Info header field [RFC7615] are generic fields that MAY be used by a server to communicate some information regarding the successful authentication of a client response.",
      "ja": "Authentication-InfoヘッダーフィールドとProxy-Authentication-Infoヘッダーフィールド[RFC7615]は、クライアント応答の認証の成功に関するいくつかの情報を通信するためにサーバーが使用できる一般的なフィールドです。"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication scheme MAY add the Authentication-Info header field in the confirmation request and include parameters from the following list:",
      "ja": "ダイジェスト認証スキームは、確認リクエストにAuthentication-Infoヘッダーフィールドを追加して、次のリストのパラメータを含めることができます："
    },
    {
      "indent": 3,
      "text": "nextnonce",
      "ja": "次の"
    },
    {
      "indent": 6,
      "text": "The value of the nextnonce parameter is the nonce the server wishes the client to use for a future authentication response. The server MAY send the Authentication-Info header field with a nextnonce field as a means of implementing one-time nonces or otherwise changing nonces. If the nextnonce field is present, the client SHOULD use it when constructing the Authorization header field for its next request. Failure of the client to do so MAY result in a request to re-authenticate from the server with the \"stale=true\".",
      "ja": "nextnonceパラメータの値は、サーバーがクライアントに将来の認証応答に使用することを望むナンスです。サーバーは、1回限りのナンスを実装するか、ナンスを変更する手段として、nextnonceフィールドを含むAuthentication-Infoヘッダーフィールドを送信する場合があります。 nextnonceフィールドが存在する場合、クライアントは次のリクエストのAuthorizationヘッダーフィールドを構築するときにそれを使用する必要があります（SHOULD）。クライアントがそうしないと、「stale = true」を使用してサーバーから再認証を要求される場合があります。"
    },
    {
      "indent": 9,
      "text": "Server implementations SHOULD carefully consider the performance implications of the use of this mechanism; pipelined requests will not be possible if every response includes a nextnonce parameter that MUST be used on the next request received by the server. Consideration SHOULD be given to the performance vs. security tradeoffs of allowing an old nonce value to be used for a limited time to permit request pipelining. Use of the nc parameter can retain most of the security advantages of a new server nonce without the deleterious effects on pipelining.",
      "ja": "サーバーの実装では、このメカニズムの使用によるパフォーマンスへの影響を注意深く検討する必要があります。サーバーが受信する次の要求で使用する必要があるnextnonceパラメーターがすべての応答に含まれている場合、パイプライン化された要求は不可能になります。要求のパイプライン化を許可するために、限られた時間に古いナンス値を使用できるようにすることのパフォーマンスとセキュリティのトレードオフについて検討する必要があります。 ncパラメータを使用すると、パイプライン化に悪影響を与えることなく、新しいサーバーnonceのセキュリティ上の利点のほとんどを保持できます。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "錫"
    },
    {
      "indent": 6,
      "text": "Indicates the \"quality of protection\" options applied to the response by the server. The value \"auth\" indicates authentication; the value \"auth-int\" indicates authentication with integrity protection. The server SHOULD use the same value for the qop parameter in the response as was sent by the client in the corresponding request.",
      "ja": "サーバーによって応答に適用される「保護品質」オプションを示します。値「auth」は認証を示します。値「auth-int」は、整合性保護を伴う認証を示します。サーバーは、対応する要求でクライアントによって送信されたものと同じ値を応答のqopパラメーターに使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "rspauth",
      "ja": "rspauth"
    },
    {
      "indent": 6,
      "text": "The optional response digest in the rspauth parameter supports mutual authentication -- the server proves that it knows the user's secret, and with qop=auth-int also provides limited integrity protection of the response. The rspauth value is calculated as for the response in the Authorization header field, except that if qop is set to \"auth\" or is not specified in the Authorization header field for the request, A2 is",
      "ja": "rspauthパラメータのオプションの応答ダイジェストは相互認証をサポートします-サーバーはユーザーの秘密を知っていることを証明し、qop = auth-intを使用すると応答の完全性保護が制限されます。 rspauth値は、Authorizationヘッダーフィールドの応答と同様に計算されます。ただし、qopが \"auth\"に設定されているか、要求のAuthorizationヘッダーフィールドで指定されていない場合、A2は"
    },
    {
      "indent": 9,
      "text": "A2 = \":\" request-uri",
      "ja": "A2 = \"：\" request-uri"
    },
    {
      "indent": 6,
      "text": "and if \"qop=auth-int\", then A2 is",
      "ja": "「qop = auth-int」の場合、A2は"
    },
    {
      "indent": 9,
      "text": "A2       = \":\" request-uri \":\" H(entity-body)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cnonce and nc",
      "ja": "cnonceとnc"
    },
    {
      "indent": 6,
      "text": "The cnonce value and nc value MUST be the ones for the client request to which this message is the response. The rspauth, cnonce, and nc parameters MUST be present if \"qop=auth\" or \"qop=auth-int\" is specified.",
      "ja": "cnonce値とnc値は、このメッセージが応答であるクライアント要求の値でなければなりません。 \"qop = auth\"または \"qop = auth-int\"が指定されている場合、rspauth、cnonce、およびncパラメータが存在している必要があります。"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header field is allowed in the trailer of an HTTP message transferred via chunked transfer coding.",
      "ja": "Authentication-Infoヘッダーフィールドは、チャンク転送コーディングを介して転送されるHTTPメッセージのトレーラーで許可されます。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax for the following parameters: nextnonce, rspauth, and cnonce.",
      "ja": "歴史的な理由から、送信者は、nextnonce、rspauth、およびcnonceのパラメーターの引用文字列構文のみを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax for the following parameters: qop and nc.",
      "ja": "歴史的な理由により、送信者は次のパラメーターの引用符付き文字列構文を生成してはいけません：qopおよびnc。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, the nc value MUST be exactly 8 hexadecimal digits.",
      "ja": "歴史的な理由により、nc値は正確に8桁の16進数でなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Digest Operation",
      "section_title": true,
      "ja": "3.6. ダイジェスト操作"
    },
    {
      "indent": 3,
      "text": "Upon receiving the Authorization header field, the server MAY check its validity by looking up the password that corresponds to the submitted username. Then, the server MUST perform the same digest operation (e.g., MD5, SHA-256) performed by the client and compare the result to the given response value.",
      "ja": "Authorizationヘッダーフィールドを受信すると、サーバーは、送信されたユーザー名に対応するパスワードを検索して、その有効性をチェックできます。次に、サーバーはクライアントが実行したのと同じダイジェスト操作（MD5、SHA-256など）を実行し、その結果を指定された応答値と比較する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the server, the validity of an Authorization header field can be verified.",
      "ja": "HTTPサーバーが実際にユーザーのクリアテキストのパスワードを知っている必要はないことに注意してください。 H（A1）がサーバーで使用可能である限り、Authorizationヘッダーフィールドの有効性を確認できます。"
    },
    {
      "indent": 3,
      "text": "The client response to a WWW-Authenticate challenge for a protection space starts an authentication session with that protection space. The authentication session lasts until the client receives another WWW-Authenticate challenge from any server in the protection space. A client SHOULD remember the username, password, nonce, nonce count, and opaque values associated with an authentication session to use to construct the Authorization header field in future requests within that protection space. The Authorization header field MAY be included preemptively; doing so improves server efficiency and avoids extra round trips for authentication challenges. The server MAY choose to accept the old Authorization header field information, even though the nonce value included might not be fresh. Alternatively, the server MAY return a 401 response with a new nonce value in the WWW-Authenticate header field, causing the client to retry the request; by specifying \"stale=true\" with this response, the server tells the client to retry with the new nonce, but without prompting for a new username and password.",
      "ja": "保護スペースに対するWWW-Authenticateチャレンジに対するクライアントの応答は、その保護スペースとの認証セッションを開始します。認証セッションは、クライアントが保護スペース内のサーバーから別のWWW-Authenticateチャレンジを受信するまで続きます。クライアントは、認証セッションに関連付けられたユーザー名、パスワード、nonce、nonceカウント、および不透明な値を覚えておくべきであり、その保護スペース内の将来のリクエストでAuthorizationヘッダーフィールドを構築するために使用します。 Authorizationヘッダーフィールドはプリエンプティブに含めることができます。そうすることで、サーバーの効率が向上し、認証の課題による余分なラウンドトリップが回避されます。含まれているnonce値が新鮮でない場合でも、サーバーは古いAuthorizationヘッダーフィールド情報を受け入れることを選択できます（MAY）。あるいは、サーバーは、WWW-Authenticateヘッダーフィールドに新しいnonce値を含む401応答を返し、クライアントに要求を再試行させる場合があります。この応答で \"stale = true\"を指定することにより、サーバーはクライアントに新しいナンスで再試行するように指示しますが、新しいユーザー名とパスワードの入力は求められません。"
    },
    {
      "indent": 3,
      "text": "Because the client is required to return the value of the opaque parameter given to it by the server for the duration of a session, the opaque data can be used to transport authentication session state information. (Note that any such use can also be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for authenticating content that actually sits on another server. It would achieve this by having the first 401 response include a domain parameter whose value includes a URI on the second server, and an opaque parameter whose value contains the state information. The client will retry the request, at which time the server might respond with \"HTTP Redirection\" (Section 6.4 of [RFC7231]), pointing to the URI on the second server. The client will follow the redirection and pass an Authorization header field, including the <opaque> data.",
      "ja": "クライアントはセッション中にサーバーから指定された不透明なパラメーターの値を返す必要があるため、不透明なデータを使用して認証セッションの状態情報を転送できます。 （そのような使用は、nonceに状態を含めることで、より簡単かつ安全に実行できることに注意してください。）たとえば、サーバーは、実際に別のサーバーにあるコンテンツを認証する責任があります。これは、最初の401応答に、値に2番目のサーバーのURIが含まれるドメインパラメータと、値に状態情報が含まれる不透明なパラメータを含めることで実現します。クライアントはリクエストを再試行します。その際、サーバーは「HTTPリダイレクト」（[RFC7231]のセクション6.4）で応答し、2番目のサーバーのURIをポイントします。クライアントはリダイレクトに従い、<opaque>データを含むAuthorizationヘッダーフィールドを渡します。"
    },
    {
      "indent": 3,
      "text": "Proxies MUST be completely transparent in the Digest access authentication scheme. That is, they MUST forward the WWW-Authenticate, Authentication-Info, and Authorization header fields untouched. If a proxy wants to authenticate a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization header fields described in Section 3.8 below.",
      "ja": "ダイジェストアクセス認証スキームでは、プロキシは完全に透過的である必要があります。つまり、WWW-Authenticate、Authentication-Info、およびAuthorizationヘッダーフィールドをそのまま転送する必要があります。リクエストがサーバーに転送される前にプロキシがクライアントを認証したい場合は、以下のセクション3.8で説明するProxy-AuthenticateおよびProxy-Authorizationヘッダーフィールドを使用して行うことができます。"
    },
    {
      "indent": 0,
      "text": "3.7. Security Protocol Negotiation",
      "section_title": true,
      "ja": "3.7. セキュリティプロトコルネゴシエーション"
    },
    {
      "indent": 3,
      "text": "It is useful for a server to be able to know which security schemes a client is capable of handling.",
      "ja": "サーバーがクライアントがどのセキュリティスキームを処理できるかを知ることができると便利です。"
    },
    {
      "indent": 0,
      "text": " It is possible that a server wants to require Digest as its authentication method, even if the server does not know that the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot handle.",
      "ja": "サーバーがクライアントがサポートしていることをサーバーが認識していない場合でも、サーバーが認証方法としてダイジェストを要求することを望んでいる可能性があります。サーバーが処理できない認証スキームのみを指定した場合、クライアントは正常に失敗することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "When a server receives a request to access a resource, the server might challenge the client by responding with \"401 Unauthorized\" response and include one or more WWW-Authenticate header fields. If the server responds with multiple challenges, then each one of these challenges MUST use a different digest algorithm. The server MUST add these challenges to the response in order of preference, starting with the most preferred algorithm, followed by the less preferred algorithm.",
      "ja": "サーバーがリソースへのアクセス要求を受信すると、サーバーは \"401 Unauthorized\"応答で応答してクライアントにチャレンジし、1つ以上のWWW-Authenticateヘッダーフィールドを含めることができます。サーバーが複数のチャレンジで応答する場合、これらのチャレンジはそれぞれ異なるダイジェストアルゴリズムを使用する必要があります。サーバーは、これらのチャレンジを優先順位の高い順に応答に追加する必要があります。優先順位の最も高いアルゴリズムから始まり、優先順位の低いアルゴリズムが続きます。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following algorithms:",
      "ja": "この仕様では、次のアルゴリズムを定義しています。"
    },
    {
      "indent": 3,
      "text": "o SHA2-256 (mandatory to implement)",
      "ja": "o SHA2-256（実装が必須）"
    },
    {
      "indent": 3,
      "text": "o SHA2-512/256 (as a backup algorithm)",
      "ja": "o SHA2-512 / 256（バックアップアルゴリズムとして）"
    },
    {
      "indent": 3,
      "text": "o MD5 (for backward compatibility).",
      "ja": "o MD5（下位互換性のため）。"
    },
    {
      "indent": 3,
      "text": "When the client receives the first challenge, it SHOULD use the first challenge it supports, unless a local policy dictates otherwise.",
      "ja": "クライアントが最初のチャレンジを受信すると、ローカルポリシーで別の指示がない限り、サポートする最初のチャレンジを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.8. Proxy-Authenticate and Proxy-Authorization",
      "section_title": true,
      "ja": "3.8. プロキシ認証とプロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication scheme can also be used for authenticating users to proxies, proxies to proxies, or proxies to origin servers by use of the Proxy-Authenticate and Proxy-Authorization header fields. These header fields are instances of the Proxy-Authenticate and Proxy-Authorization header fields specified in Sections 4.3 and 4.4 of the HTTP/1.1 specification [RFC7235], and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar to those already described. Upon receiving a request that requires authentication, the proxy/server MUST issue the \"407 Proxy Authentication Required\" response with a \"Proxy-Authenticate\" header field. The digest-challenge used in the Proxy-Authenticate header field is the same as that for the WWW-Authenticate header field as defined above in Section 3.3.",
      "ja": "ダイジェスト認証スキームは、Proxy-AuthenticateおよびProxy-Authorizationヘッダーフィールドを使用して、ユーザーをプロキシ、プロキシからプロキシ、またはオリジンサーバーへのプロキシに認証するためにも使用できます。これらのヘッダーフィールドは、HTTP / 1.1仕様[RFC7235]のセクション4.3および4.4で指定されたProxy-AuthenticateおよびProxy-Authorizationヘッダーフィールドのインスタンスであり、それらの動作はそこで説明されている制限に従います。プロキシ認証のトランザクションは、すでに説明したものと非常に似ています。認証を必要とする要求を受信すると、プロキシ/サーバーは「Proxy-Authenticate」ヘッダーフィールドを含む「407 Proxy Authentication Required」応答を発行する必要があります。 Proxy-Authenticateヘッダーフィールドで使用されるダイジェストチャレンジは、セクション3.3で定義したWWW-Authenticateヘッダーフィールドのダイジェストチャレンジと同じです。"
    },
    {
      "indent": 3,
      "text": "The client/proxy MUST then reissue the request with a Proxy-Authorization header field, with parameters as specified for the Authorization header field in Section 3.4 above.",
      "ja": "次にクライアント/プロキシは、上記のセクション3.4のAuthorizationヘッダーフィールドに指定されたパラメーターを使用して、Proxy-Authorizationヘッダーフィールドを使用して要求を再発行する必要があります。"
    },
    {
      "indent": 3,
      "text": "On subsequent responses, the server sends Proxy-Authentication-Info with parameters the same as those for the Authentication-Info header field.",
      "ja": "その後の応答では、サーバーはAuthentication-Infoヘッダーフィールドのパラメーターと同じパラメーターを使用してProxy-Authentication-Infoを送信します。"
    },
    {
      "indent": 3,
      "text": "Note that, in principle, a client could be asked to authenticate itself to both a proxy and an end-server, but never in the same response.",
      "ja": "原則として、クライアントはプロキシとエンドサーバーの両方に対して自身を認証するように求められる可能性がありますが、同じ応答では決してありません。"
    },
    {
      "indent": 0,
      "text": "3.9. Examples",
      "section_title": true,
      "ja": "3.9. 例"
    },
    {
      "indent": 0,
      "text": "3.9.1. Example with SHA-256 and MD5",
      "section_title": true,
      "ja": "3.9.1. SHA-256およびMD5の例"
    },
    {
      "indent": 3,
      "text": "The following example assumes that an access-protected document is being requested from the server via a GET request. The URI of the document is \"http://www.example.org/dir/index.html\". Both client and server know that the username for this document is \"Mufasa\" and the password is \"Circle of Life\" (with one space between each of the three words).",
      "ja": "次の例では、アクセス保護されたドキュメントがGETリクエストを介してサーバーからリクエストされていると想定しています。ドキュメントのURIは「http://www.example.org/dir/index.html」です。クライアントとサーバーの両方が、このドキュメントのユーザー名が「Mufasa」であり、パスワードが「Circle of Life」であることを知っています（3つの単語の間にスペースが1つあります）。"
    },
    {
      "indent": 3,
      "text": "The first time the client requests the document, no Authorization header field is sent, so the server responds with:",
      "ja": "クライアントが初めてドキュメントを要求するとき、Authorizationヘッダーフィールドは送信されないため、サーバーは次のように応答します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Digest\n    realm=\"http-auth@example.org\",\n    qop=\"auth, auth-int\",\n    algorithm=SHA-256,\n    nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\",\n    opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"\nWWW-Authenticate: Digest\n    realm=\"http-auth@example.org\",\n    qop=\"auth, auth-int\",\n    algorithm=MD5,\n    nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\",\n    opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client can prompt the user for their username and password, after which it will respond with a new request, including the following Authorization header field if the client chooses MD5 digest:",
      "ja": "クライアントはユーザーにユーザー名とパスワードの入力を要求できます。その後、クライアントがMD5ダイジェストを選択した場合、次のAuthorizationヘッダーフィールドを含む新しいリクエストで応答します。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username=\"Mufasa\",\n    realm=\"http-auth@example.org\",\n    uri=\"/dir/index.html\",\n    algorithm=MD5,\n    nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\",\n    nc=00000001,\n    cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\",\n    qop=auth,\n    response=\"8ca523f5e9506fed4657c9700eebdbec\",\n    opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the client chooses to use the SHA-256 algorithm for calculating the response, the client responds with a new request including the following Authorization header field:",
      "ja": "クライアントが応答の計算にSHA-256アルゴリズムを使用することを選択した場合、クライアントは次のAuthorizationヘッダーフィールドを含む新しい要求で応答します。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username=\"Mufasa\",\n    realm=\"http-auth@example.org\",\n    uri=\"/dir/index.html\",\n    algorithm=SHA-256,\n    nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\",\n    nc=00000001,\n    cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\",\n    qop=auth,\n    response=\"753927fa0e85d155564e2e272a28d1802ca10daf449\n       6794697cf8db5856cb6c1\",\n    opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.9.2. Example with SHA-512-256, Charset, and Userhash",
      "section_title": true,
      "ja": "3.9.2. SHA-512-256、Charset、およびUserhashの例"
    },
    {
      "indent": 3,
      "text": "The following example assumes that an access-protected document is being requested from the server via a GET request. The URI for the request is \"http://api.example.org/doe.json\". Both client and server know the userhash of the username, support the UTF-8 character encoding scheme, and use the SHA-512-256 algorithm. The username for the request is a variation of \"Jason Doe\", where the 'a' actually is Unicode code point U+00E4 (\"LATIN SMALL LETTER A WITH DIAERESIS\"), and the first 'o' is Unicode code point U+00F8 (\"LATIN SMALL LETTER O WITH STROKE\"), leading to the octet sequence using the UTF-8 encoding scheme:",
      "ja": "次の例では、アクセス保護されたドキュメントがGETリクエストを介してサーバーからリクエストされていると想定しています。リクエストのURIは「http://api.example.org/doe.json」です。クライアントとサーバーの両方がユーザー名のユーザーハッシュを認識し、UTF-8文字エンコードスキームをサポートし、SHA-512-256アルゴリズムを使用します。リクエストのユーザー名は「Jason Doe」のバリエーションであり、「a」は実際にはUnicodeコードポイントU + 00E4（「ラテン小文字Aダイアレット付き」）であり、最初の「o」はUnicodeコードポイントU +です。 00F8（「ラテン小文字Oストロークあり」）、UTF-8エンコード方式を使用したオクテットシーケンスにつながる："
    },
    {
      "indent": 6,
      "text": "J U+00E4 s U+00F8 n D o e 4A C3A4 73 C3B8 6E 20 44 6F 65",
      "ja": "Ｊ う＋００え４ ｓ う＋００Ｆ８ ん Ｄ お え ４あ Ｃ３あ４ ７３ Ｃ３Ｂ８ ６え ２０ ４４ ６Ｆ ６５"
    },
    {
      "indent": 3,
      "text": "The password is \"Secret, or not?\".",
      "ja": "パスワードは「シークレットかどうか」です。"
    },
    {
      "indent": 3,
      "text": "The first time the client requests the document, no Authorization header field is sent, so the server responds with:",
      "ja": "クライアントが初めてドキュメントを要求するとき、Authorizationヘッダーフィールドは送信されないため、サーバーは次のように応答します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Digest\n    realm=\"api@example.org\",\n    qop=\"auth\",\n    algorithm=SHA-512-256,\n    nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\",\n    opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\",\n    charset=UTF-8,\n    userhash=true",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client can prompt the user for the required credentials and send a new request with following Authorization header field:",
      "ja": "クライアントはユーザーに必要な資格情報を要求し、次のAuthorizationヘッダーフィールドを使用して新しいリクエストを送信できます。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest\n    username=\"488869477bf257147b804c45308cd62ac4e25eb717\n       b12b298c79e62dcea254ec\",\n    realm=\"api@example.org\",\n    uri=\"/doe.json\",\n    algorithm=SHA-512-256,\n    nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\",\n    nc=00000001,\n    cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\",\n    qop=auth,\n    response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d\n       6c861229025f607a79dd\",\n    opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\",\n    userhash=true",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the client cannot provide a hashed username for any reason, the client can try a request with this Authorization header field:",
      "ja": "クライアントが何らかの理由でハッシュ化されたユーザー名を提供できない場合、クライアントは次のAuthorizationヘッダーフィールドを使用してリクエストを試行できます。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest\n    username*=UTF-8''J%C3%A4s%C3%B8n%20Doe,\n    realm=\"api@example.org\",\n    uri=\"/doe.json\",\n    algorithm=SHA-512-256,\n    nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\",\n    nc=00000001,\n    cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\",\n    qop=auth,\n    response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d\n       6c861229025f607a79dd\",\n    opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\",\n    userhash=false",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Internationalization Considerations",
      "section_title": true,
      "ja": "4. 国際化に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In challenges, servers SHOULD use the \"charset\" authentication parameter (case-insensitive) to express the character encoding they expect the user agent to use when generating A1 (see Section 3.4.2) and username hashing (see Section 3.4.4).",
      "ja": "課題では、サーバーは「charset」認証パラメータ（大文字と小文字を区別しない）を使用して、A1（3.4.2を参照）およびユーザー名のハッシュ（3.4.4を参照）を生成するときにユーザーエージェントが使用すると予想される文字エンコーディングを表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "The only allowed value is \"UTF-8\", to be matched case-insensitively (see Section 2.3 in [RFC2978]). It indicates that the server expects the username and password to be converted to Unicode Normalization Form C (\"NFC\", see Section 3 of [RFC5198]) and to be encoded into octets using the UTF-8 character encoding scheme [RFC3629].",
      "ja": "許可される値は「UTF-8」のみで、大文字と小文字を区別せずに照合されます（[RFC2978]のセクション2.3を参照）。これは、サーバーがユーザー名とパスワードがUnicode正規化フォームC（「NFC」、[RFC5198]のセクション3を参照）に変換され、UTF-8文字エンコードスキーム[RFC3629]を使用してオクテットにエンコードされることを期待していることを示しています。"
    },
    {
      "indent": 3,
      "text": "For the username, recipients MUST support all characters defined in the \"UsernameCasePreserved\" profile defined in Section 3.3 of [RFC7613], with the exception of the colon (\":\") character.",
      "ja": "ユーザー名の場合、受信者は、[RFC7613]のセクション3.3で定義されている「UsernameCasePreserved」プロファイルで定義されている、コロン（ \"：\"）文字を除くすべての文字をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For the password, recipients MUST support all characters defined in the \"OpaqueString\" profile defined in Section 4.2 of [RFC7613].",
      "ja": "パスワードについて、受信者は[RFC7613]のセクション4.2で定義された「OpaqueString」プロファイルで定義されたすべての文字をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the user agent does not support the encoding indicated by the server, it can fail the request.",
      "ja": "ユーザーエージェントがサーバーによって示されているエンコーディングをサポートしていない場合、リクエストが失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "When usernames cannot be sent hashed and include non-ASCII characters, clients can include the username* parameter instead (using the value encoding defined in [RFC5987]).",
      "ja": "ユーザー名をハッシュ化して送信できず、ASCII以外の文字が含まれている場合、クライアントは代わりにユーザー名*パラメータを含めることができます（[RFC5987]で定義されている値のエンコーディングを使用）。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. Limitations",
      "section_title": true,
      "ja": "5.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "HTTP Digest Authentication, when used with human-memorable passwords, is vulnerable to dictionary attacks. Such attacks are much easier than cryptographic attacks on any widely used algorithm, including those that are no longer considered secure. In other words, algorithm agility does not make this usage any more secure.",
      "ja": "HTTPダイジェスト認証は、人間が記憶できるパスワードと共に使用されると、辞書攻撃に対して脆弱です。このような攻撃は、安全と見なされなくなったものを含め、広く使用されているアルゴリズムに対する暗号化攻撃よりもはるかに簡単です。言い換えれば、アルゴリズムの俊敏性はこの使用法をこれ以上安全にしません。"
    },
    {
      "indent": 3,
      "text": "As a result, Digest Authentication SHOULD be used only with passwords that have a reasonable amount of entropy, e.g., 128-bit or more. Such passwords typically cannot be memorized by humans but can be used for automated web services.",
      "ja": "その結果、ダイジェスト認証は、妥当な量のエントロピー（128ビット以上など）を持つパスワードでのみ使用する必要があります（SHOULD）。このようなパスワードは通常、人間が記憶することはできませんが、自動化されたWebサービスに使用できます。"
    },
    {
      "indent": 3,
      "text": "If Digest Authentication is being used, it SHOULD be over a secure channel like HTTPS [RFC2818].",
      "ja": "ダイジェスト認証が使用されている場合、HTTPS [RFC2818]のような安全なチャネル上にある必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Storing Passwords",
      "section_title": true,
      "ja": "5.2. パスワードの保存"
    },
    {
      "indent": 3,
      "text": "Digest Authentication requires that the authenticating agent (usually the server) store some data derived from the user's name and password in a \"password file\" associated with a given realm. Normally, this might contain pairs consisting of username and H(A1), where H(A1) is the digested value of the username, realm, and password as described above.",
      "ja": "ダイジェスト認証では、認証エージェント（通常はサーバー）が、ユーザーの名前とパスワードから取得したデータを、特定のレルムに関連付けられた「パスワードファイル」に格納する必要があります。通常、これには、ユーザー名とH（A1）で構成されるペアが含まれる場合があります。H（A1）は、上記のようにユーザー名、レルム、パスワードのダイジェスト値です。"
    },
    {
      "indent": 0,
      "text": " The security implications of this are that if this password file is compromised, then an attacker gains immediate access to documents on the server using this realm. Unlike, say, a standard UNIX password file, this information needs not be decrypted in order to access documents in the server realm associated with this file. On the other hand, decryption, or more likely a brute-force attack, would be necessary to obtain the user's password. This is the reason that the realm is part of the digested data stored in the password file. It means that if one Digest Authentication password file is compromised, it does not automatically compromise others with the same username and password (though it does expose them to brute-force attack).",
      "ja": "このセキュリティ上の意味は、このパスワードファイルが侵害された場合、攻撃者はこのレルムを使用してサーバー上のドキュメントに即座にアクセスできることです。たとえば、標準のUNIXパスワードファイルとは異なり、このファイルに関連付けられたサーバーレルム内のドキュメントにアクセスするために、この情報を復号化する必要はありません。一方、ユーザーのパスワードを取得するには、解読、またはおそらくブルートフォース攻撃が必要になります。これが、レルムがパスワードファイルに格納されたダイジェストデータの一部である理由です。つまり、1つのダイジェスト認証パスワードファイルが危険にさらされても、同じユーザー名とパスワードで他のファイルが自動的に危険にさらされることはありません（ただし、ブルートフォース攻撃にさらされます）。"
    },
    {
      "indent": 3,
      "text": "There are two important security consequences of this. First, the password file must be protected as if it contained unencrypted passwords, because, for the purpose of accessing documents in its realm, it effectively does.",
      "ja": "これには2つの重要なセキュリティ上の影響があります。まず、パスワードファイルは、暗号化されていないパスワードが含まれているかのように保護する必要があります。これは、レルム内のドキュメントにアクセスする目的で効果的に行うためです。"
    },
    {
      "indent": 3,
      "text": "A second consequence of this is that the realm string SHOULD be unique among all realms that any single user is likely to use. In particular, a realm string SHOULD include the name of the host doing the authentication. The inability of the client to authenticate the server is a weakness of Digest Authentication.",
      "ja": "これの2番目の結果は、単一のユーザーが使用する可能性が高いすべてのレルム間でレルム文字列が一意であることです。特に、レルム文字列には、認証を行うホストの名前を含める必要があります（SHOULD）。クライアントがサーバーを認証できないことは、ダイジェスト認証の弱点です。"
    },
    {
      "indent": 0,
      "text": "5.3. Authentication of Clients Using Digest Authentication",
      "section_title": true,
      "ja": "5.3. ダイジェスト認証を使用したクライアントの認証"
    },
    {
      "indent": 3,
      "text": "Digest Authentication does not provide a strong authentication mechanism, when compared to public-key-based mechanisms, for example.",
      "ja": "たとえば公開鍵ベースのメカニズムと比較すると、ダイジェスト認証は強力な認証メカニズムを提供しません。"
    },
    {
      "indent": 3,
      "text": "However, it is significantly stronger than, e.g., CRAM-MD5, which has been proposed for use with Lightweight Directory Access Protocol (LDAP) [RFC4513] and IMAP/POP (see [RFC2195]). It was intended to replace the much weaker and even more dangerous Basic mechanism.",
      "ja": "ただし、ライトウェイトディレクトリアクセスプロトコル（LDAP）[RFC4513]およびIMAP / POP（[RFC2195]を参照）での使用が提案されているCRAM-MD5などよりもはるかに強力です。非常に弱く、さらに危険なBasicメカニズムを置き換えることを目的としていました。"
    },
    {
      "indent": 3,
      "text": "Digest Authentication offers no confidentiality protection beyond protecting the actual username and password. All of the rest of the request and response are available to an eavesdropper.",
      "ja": "ダイジェスト認証では、実際のユーザー名とパスワードを保護する以外に機密保護は提供されません。リクエストとレスポンスの残りのすべては、盗聴者が利用できます。"
    },
    {
      "indent": 3,
      "text": "Digest Authentication offers only limited integrity protection for the messages in either direction. If the \"qop=auth-int\" mechanism is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response parameter values (see Section 3.2 above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.",
      "ja": "ダイジェスト認証は、どちらの方向のメッセージに対しても限定的な完全性保護を提供します。 「qop = auth-int」メカニズムが使用される場合、WWW-AuthenticateおよびAuthorizationヘッダーフィールドの応答パラメーター値（上記のセクション3.2を参照）の計算に使用されるメッセージのこれらの部分は保護されます。ほとんどのヘッダーフィールドとその値は、中間者攻撃の一部として変更される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Many needs for secure HTTP transactions cannot be met by Digest Authentication. For those needs, TLS is a more appropriate protocol. In particular, Digest Authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless, many functions remain for which Digest Authentication is both useful and appropriate.",
      "ja": "安全なHTTPトランザクションに対する多くのニーズは、ダイジェスト認証では満たすことができません。これらのニーズには、TLSがより適切なプロトコルです。特に、機密保護を必要とするトランザクションにはダイジェスト認証を使用できません。それにもかかわらず、ダイジェスト認証が有用かつ適切である多くの機能が残っています。"
    },
    {
      "indent": 0,
      "text": "5.4. Limited-Use Nonce Values",
      "section_title": true,
      "ja": "5.4. 限定使用ナンス値"
    },
    {
      "indent": 3,
      "text": "The Digest scheme uses a server-specified nonce to seed the generation of the response value (as specified in Section 3.4.1 above). As shown in the example nonce in Section 3.3, the server is free to construct the nonce such that it MAY only be used from a particular client, for a particular resource, for a limited period of time or number of uses, or any other restrictions. Doing so strengthens the protection provided against, for example, replay attacks (see Section 5.5). However, it should be noted that the method chosen for generating and checking the nonce also has performance and resource implications. For example, a server MAY choose to allow each nonce value to be used only once by maintaining a record of whether or not each recently issued nonce has been returned and sending a next-nonce parameter in the Authentication-Info header field of every response. This protects against even an immediate replay attack, but it has a high cost due to checking nonce values; perhaps more important, it will cause authentication failures for any pipelined requests (presumably returning a stale nonce indication). Similarly, incorporating a request-specific element such as the ETag value for a resource limits the use of the nonce to that version of the resource and also defeats pipelining. Thus, it MAY be useful to do so for methods with side effects but have unacceptable performance for those that do not.",
      "ja": "ダイジェスト方式では、サーバー指定のナンスを使用して、応答値の生成をシードします（上記のセクション3.4.1で指定）。セクション3.3のノンスの例に示されているように、サーバーは、特定のクライアントから、特定のリソースに対して、限られた期間または使用回数、またはその他の制限のみで使用できるようにノンスを自由に構築できます。 。そうすることで、たとえばリプレイ攻撃に対して提供される保護が強化されます（セクション5.5を参照）。ただし、ナンスを生成およびチェックするために選択された方法は、パフォーマンスとリソースに影響を与えることにも注意してください。たとえば、サーバーは、最近発行された各nonceが返されたかどうかの記録を維持し、すべての応答のAuthentication-Infoヘッダーフィールドにnext-nonceパラメーターを送信することにより、各nonce値を1回だけ使用できるようにすることを選択できます（MAY）。これは即時のリプレイ攻撃からも保護しますが、ナンス値をチェックするために高コストになります。おそらくより重要なのは、パイプライン化された要求に対して認証失敗を引き起こすことです（おそらく古いナンス表示を返します）。同様に、リソースのETag値などのリクエスト固有の要素を組み込むと、ナンスの使用がリソースのそのバージョンに制限され、パイプライン化も無効になります。したがって、副作用のあるメソッドに対してはそうすることは有用ですが、そうでないメソッドに対しては許容できないパフォーマンスがあります。"
    },
    {
      "indent": 0,
      "text": "5.5. Replay Attacks",
      "section_title": true,
      "ja": "5.5. リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "A replay attack against Digest Authentication would usually be pointless for a simple GET request since an eavesdropper would already have seen the only document he could obtain with a replay. This is because the URI of the requested document is digested in the client request, and the server will only deliver that document. By contrast, under Basic Authentication, once the eavesdropper has the user's password, any document protected by that password is open to him.",
      "ja": "盗聴者はリプレイで取得できる唯一のドキュメントをすでに盗聴しているため、ダイジェスト認証に対するリプレイ攻撃は通常、単純なGETリクエストには無意味です。これは、リクエストされたドキュメントのURIがクライアントリクエストでダイジェストされ、サーバーがそのドキュメントのみを配信するためです。対照的に、基本認証では、盗聴者がユーザーのパスワードを取得すると、そのパスワードで保護されたすべてのドキュメントがユーザーに公開されます。"
    },
    {
      "indent": 3,
      "text": "Thus, for some purposes, it is necessary to protect against replay attacks. A good Digest implementation can do this in various ways. The server-created \"nonce\" value is implementation dependent, but if it contains a digest of the client IP, a timestamp, the resource ETag, and a private server key (as recommended above), then a replay attack is not simple. An attacker must convince the server that the request is coming from a false IP address and must cause the server to deliver the document to an IP address different from the address to which it believes it is sending the document. An attack can only succeed in the period before the timestamp expires. Digesting the client IP and timestamp in the nonce permits an implementation that does not maintain state between transactions.",
      "ja": "したがって、一部の目的では、リプレイ攻撃から保護する必要があります。優れたDigest実装は、さまざまな方法でこれを実行できます。サーバーで作成された「nonce」値は実装に依存しますが、クライアントIPのダイジェスト、タイムスタンプ、リソースETag、およびプライベートサーバーキー（上記で推奨）が含まれている場合、リプレイ攻撃は単純ではありません。攻撃者は、リクエストが偽のIPアドレスからのものであることをサーバーに知らせ、サーバーがドキュメントを送信していると思われるアドレスとは異なるIPアドレスにドキュメントを配信させる必要があります。攻撃は、タイムスタンプが期限切れになる前の期間にのみ成功します。 nonceでクライアントIPとタイムスタンプをダイジェストすると、トランザクション間の状態を維持しない実装が可能になります。"
    },
    {
      "indent": 3,
      "text": "For applications where no possibility of replay attack can be tolerated, the server can use one-time nonce values that will not be honored for a second use. This requires the overhead of the server remembering which nonce values have been used until the nonce timestamp (and hence the digest built with it) has expired, but it effectively protects against replay attacks.",
      "ja": "リプレイ攻撃の可能性が許容されないアプリケーションの場合、サーバーは、2回目の使用では受け入れられない1回限りのナンス値を使用できます。これには、サーバーのオーバーヘッドが必要であり、ナンスタイムスタンプ（およびそれによって構築されたダイジェスト）が期限切れになるまで、どのナンス値が使用されたかを記憶する必要がありますが、リプレイ攻撃から効果的に保護します。"
    },
    {
      "indent": 3,
      "text": "An implementation must give special attention to the possibility of replay attacks with POST and PUT requests. Unless the server employs one-time or otherwise limited-use nonces and/or insists on the use of the integrity protection of \"qop=auth-int\", an attacker could replay valid credentials from a successful request with counterfeit data or other message body. Even with the use of integrity protection, most metadata in header fields is not protected. Proper nonce generation and checking provides some protection against replay of previously used valid credentials, but see Section 5.8.",
      "ja": "実装では、POSTおよびPUTリクエストによるリプレイ攻撃の可能性に特別な注意を払う必要があります。サーバーが1回限りの使用または制限付きの使用nonceを使用するか、「qop = auth-int」の整合性保護の使用を要求しない限り、攻撃者は偽造データまたはその他のメッセージ本文を含む成功した要求から有効な資格情報を再生する可能性があります。整合性保護を使用しても、ヘッダーフィールドのほとんどのメタデータは保護されません。適切なナンスの生成とチェックは、以前に使用された有効な資格情報の再生に対する保護を提供しますが、セクション5.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6. Weakness Created by Multiple Authentication Schemes",
      "section_title": true,
      "ja": "5.6. 複数の認証スキームによって作成される弱点"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 server MAY return multiple challenges with a 401 (Authenticate) response, and each challenge MAY use a different auth-scheme. A user agent MUST choose to use the strongest auth-scheme it understands and request credentials from the user based upon that challenge.",
      "ja": "HTTP / 1.1サーバーは、401（認証）応答で複数のチャレンジを返す場合があり、各チャレンジは異なる認証方式を使用する場合があります（MAY）。ユーザーエージェントは、それが理解する最も強力なauth-schemeを使用することを選択し、そのチャレンジに基づいてユーザーに資格情報を要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server offers choices of authentication schemes using the WWW-Authenticate header field, the strength of the resulting authentication is only as good as that of the of the weakest of the authentication schemes. See Section 5.7 below for discussion of particular attack scenarios that exploit multiple authentication schemes.",
      "ja": "サーバーがWWW-Authenticateヘッダーフィールドを使用して認証スキームの選択肢を提供する場合、結果として得られる認証の強度は、最も弱い認証スキームの強度と同じです。複数の認証スキームを悪用する特定の攻撃シナリオについては、以下のセクション5.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.7. Online Dictionary Attacks",
      "section_title": true,
      "ja": "5.7. オンライン辞書攻撃"
    },
    {
      "indent": 3,
      "text": "If the attacker can eavesdrop, then it can test any overheard nonce/ response pairs against a list of common words. Such a list is usually much smaller than the total number of possible passwords. The cost of computing the response for each password on the list is paid once for each challenge.",
      "ja": "攻撃者が盗聴できる場合、傍受されたnonce /応答のペアを一般的な単語のリストに対してテストできます。このようなリストは、通常、可能なパスワードの総数よりもはるかに小さくなります。リストの各パスワードの応答を計算するコストは、チャレンジごとに1回支払われます。"
    },
    {
      "indent": 3,
      "text": "The server can mitigate this attack by not allowing users to select passwords that are in a dictionary.",
      "ja": "サーバーは、ユーザーが辞書にあるパスワードを選択できないようにすることで、この攻撃を緩和できます。"
    },
    {
      "indent": 0,
      "text": "5.8. Man-in-the-Middle Attacks",
      "section_title": true,
      "ja": "5.8. 中間者攻撃"
    },
    {
      "indent": 3,
      "text": "Digest Authentication is vulnerable to man-in-the-middle (MITM) attacks, for example, from a hostile or compromised proxy. Clearly, this would present all the problems of eavesdropping. But, it also offers some additional opportunities to the attacker.",
      "ja": "ダイジェスト認証は、たとえば、悪意のある、または侵害されたプロキシからの中間者（MITM）攻撃に対して脆弱です。明らかに、これは盗聴のすべての問題を提示します。しかし、それはまた、攻撃者にいくつかの追加の機会を提供します。"
    },
    {
      "indent": 3,
      "text": "A possible man-in-the-middle attack would be to add a weak authentication scheme to the set of choices, hoping that the client will use one that exposes the user's credentials (e.g., password). For this reason, the client SHOULD always use the strongest scheme that it understands from the choices offered.",
      "ja": "中間者攻撃の可能性としては、選択肢のセットに弱い認証スキームを追加し、クライアントがユーザーの資格情報（パスワードなど）を公開するものを使用することを期待しています。このため、クライアントは常に、提供された選択肢から理解できる最も強力なスキームを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "An even better MITM attack would be to remove all offered choices, replacing them with a challenge that requests only Basic authentication, then uses the cleartext credentials from the Basic authentication to authenticate to the origin server using the stronger scheme it requested. A particularly insidious way to mount such a MITM attack would be to offer a \"free\" proxy caching service to gullible users.",
      "ja": "さらに優れたMITM攻撃は、提供されたすべての選択肢を削除し、基本認証のみを要求するチャレンジに置き換え、次に、基本認証のクリアテキスト資格情報を使用して、要求したより強力なスキームを使用してオリジンサーバーを認証します。このようなMITM攻撃を仕掛ける特に油断のならない方法は、だまされやすいユーザーに「無料の」プロキシキャッシングサービスを提供することです。"
    },
    {
      "indent": 3,
      "text": "User agents should consider measures such as presenting a visual indication at the time of the credentials request of what authentication scheme is to be used, or remembering the strongest authentication scheme ever requested by a server and producing a warning message before using a weaker one. It might also be a good idea for the user agent to be configured to demand Digest authentication in general or from specific sites.",
      "ja": "ユーザーエージェントは、使用する認証スキームの資格情報要求時に視覚的な表示を提示する、またはサーバーがこれまでに要求した最も強力な認証スキームを記憶しておき、弱いものを使用する前に警告メッセージを生成するなどの対策を検討する必要があります。また、一般的にダイジェスト認証を要求するように、または特定のサイトからダイジェスト認証を要求するようにユーザーエージェントを構成することもお勧めします。"
    },
    {
      "indent": 3,
      "text": "Or, a hostile proxy might spoof the client into making a request the attacker wanted rather than one the client wanted. Of course, this is still much harder than a comparable attack against Basic Authentication.",
      "ja": "または、悪意のあるプロキシがクライアントになりすまして、攻撃者が要求した要求ではなく、攻撃者が要求した要求を行う可能性があります。もちろん、これは基本認証に対する同等の攻撃よりもはるかに困難です。"
    },
    {
      "indent": 0,
      "text": "5.9. Chosen Plaintext Attacks",
      "section_title": true,
      "ja": "5.9. 選択された平文攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, a MITM or a malicious server can arbitrarily choose the nonce that the client will use to compute the response. This is called a \"chosen plaintext\" attack. The ability to choose the nonce is known to make cryptanalysis much easier.",
      "ja": "ダイジェスト認証を使用すると、MITMまたは悪意のあるサーバーが、クライアントが応答の計算に使用するナンスを任意に選択できます。これは「選択された平文」攻撃と呼ばれます。ナンスを選択する機能は、暗号解読をはるかに簡単にすることが知られています。"
    },
    {
      "indent": 3,
      "text": "However, a method to analyze the one-way functions used by Digest using chosen plaintext is not currently known.",
      "ja": "しかしながら、選択された平文を使用してダイジェストによって使用される一方向関数を分析する方法は現在知られていない。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter; this allows the client to vary the input to the hash in a way not chosen by the attacker.",
      "ja": "この攻撃に対する対策は、クライアントがcnonceパラメータを使用することです。これにより、クライアントは攻撃者が選択しない方法でハッシュへの入力を変更できます。"
    },
    {
      "indent": 0,
      "text": "5.10. Precomputed Dictionary Attacks",
      "section_title": true,
      "ja": "5.10. 事前計算された辞書攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, if the attacker can execute a chosen plaintext attack, the attacker can precompute the response for many common words to a nonce of its choice and store a dictionary of response/password pairs. Such precomputation can often be done in parallel on many machines. It can then use the chosen plaintext attack to acquire a response corresponding to that challenge and just look up the password in the dictionary. Even if most passwords are not in the dictionary, some might be. Since the attacker gets to pick the challenge, the cost of computing the response for each password on the list can be amortized over finding many passwords. A dictionary with 100 million password/response pairs would take about 3.2 gigabytes of disk storage.",
      "ja": "ダイジェスト認証を使用すると、攻撃者が選択したプレーンテキスト攻撃を実行できる場合、攻撃者は多くの一般的な単語に対する応答をその選択したナンスに事前計算し、応答/パスワードのペアの辞書を保存できます。このような事前計算は、多くのマシンで並行して実行できることがよくあります。次に、選択したプレーンテキスト攻撃を使用して、そのチャレンジに対応する応答を取得し、辞書でパスワードを検索します。ほとんどのパスワードが辞書にない場合でも、一部のパスワードは含まれている可能性があります。攻撃者がチャレンジを選択するので、リストの各パスワードの応答を計算するコストは、多くのパスワードを見つけることよりも少なくなります。 1億のパスワードと応答のペアを持つディクショナリは、約3.2ギガバイトのディスクストレージを必要とします。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter.",
      "ja": "この攻撃に対する対策は、クライアントがcnonceパラメータを使用することです。"
    },
    {
      "indent": 0,
      "text": "5.11. Batch Brute-Force Attacks",
      "section_title": true,
      "ja": "5.11. 総当たり攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, a MITM can execute a chosen plaintext attack and can gather responses from many users to the same nonce. It can then find all the passwords within any subset of password space that would generate one of the nonce/response pairs in a single pass over that space. It also reduces the time to find the first password by a factor equal to the number of nonce/response pairs gathered. This search of the password space can often be done in parallel on many machines, and even a single machine can search large subsets of the password space very quickly -- reports exist of searching all passwords with six or fewer letters in a few hours.",
      "ja": "ダイジェスト認証を使用すると、MITMは選択されたプレーンテキスト攻撃を実行し、同じナンスに対する多くのユーザーからの応答を収集できます。次に、そのスペースの1回のパスでnonce / responseペアの1つを生成するパスワードスペースのサブセット内のすべてのパスワードを検索できます。また、収集されたnonce / responseペアの数に等しい係数によって、最初のパスワードを見つける時間も短縮されます。このパスワードスペースの検索は多くのマシンで並行して実行できることが多く、1台のマシンでもパスワードスペースの大きなサブセットを非常に迅速に検索できます。6時間以内のすべてのパスワードを数時間で検索するレポートが存在します。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter.",
      "ja": "この攻撃に対する対策は、クライアントがcnonceパラメータを使用することです。"
    },
    {
      "indent": 0,
      "text": "5.12. Parameter Randomness",
      "section_title": true,
      "ja": "5.12. パラメータのランダム性"
    },
    {
      "indent": 3,
      "text": "The security of this protocol is critically dependent on the randomness of the randomly chosen parameters, such as client and server nonces. These should be generated by a strong random or properly seeded pseudorandom source (see [RFC4086]).",
      "ja": "このプロトコルのセキュリティは、クライアントやサーバーのナンスなど、ランダムに選択されたパラメーターのランダム性に大きく依存しています。これらは、強力なランダムまたは適切にシードされた疑似ランダムソースによって生成される必要があります（[RFC4086]を参照）。"
    },
    {
      "indent": 0,
      "text": "5.13. Summary",
      "section_title": true,
      "ja": "5.13. 概要"
    },
    {
      "indent": 0,
      "text": " By modern cryptographic standards, Digest Authentication is weak. But, for a large range of purposes, it is valuable as a replacement for Basic Authentication. It remedies some, but not all, weaknesses of Basic Authentication. Its strength may vary depending on the implementation. In particular, the structure of the nonce (which is dependent on the server implementation) may affect the ease of mounting a replay attack. A range of server options is appropriate since, for example, some implementations may be willing to accept the server overhead of one-time nonces or digests to eliminate the possibility of replay. Others may be satisfied with a nonce like the one recommended above, i.e., restricted to a single IP address and a single ETag or with a limited lifetime.",
      "ja": "現代の暗号規格では、ダイジェスト認証は脆弱です。ただし、幅広い目的で、基本認証の代わりとして役立ちます。すべてではありませんが、基本認証の弱点を改善します。その強さは実装によって異なります。特に、ナンスの構造（サーバーの実装に依存）は、リプレイ攻撃の実装のしやすさに影響を与える可能性があります。たとえば、一部の実装では、1回限りのナンスまたはダイジェストのサーバーオーバーヘッドを受け入れて再生の可能性を排除する場合があるため、サーバーオプションの範囲は適切です。他のユーザーは、上記で推奨されているようなnonce、つまり、単一のIPアドレスと単一のETagに制限されているか、制限付きのライフタイムで満足できる場合があります。"
    },
    {
      "indent": 3,
      "text": "The bottom line is that *any* compliant implementation will be relatively weak by cryptographic standards, but *any* compliant implementation will be far superior to Basic Authentication.",
      "ja": "結論としては、*標準*に準拠した実装は暗号化標準によって比較的脆弱ですが、*任意*に準拠した実装は基本認証よりもはるかに優れています。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Hash Algorithms for HTTP Digest Authentication",
      "section_title": true,
      "ja": "6.1. HTTPダイジェスト認証のハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry named \"Hash Algorithms for HTTP Digest Authentication\" under the existing \"Hypertext Transfer Protocol (HTTP) Digest Algorithm Values\" category. This registry lists the hash algorithms that can be used in HTTP Digest Authentication.",
      "ja": "この仕様は、既存の「ハイパーテキスト転送プロトコル（HTTP）ダイジェストアルゴリズムの値」カテゴリの下に「HTTPダイジェスト認証のハッシュアルゴリズム」という名前の新しいIANAレジストリを作成します。このレジストリには、HTTPダイジェスト認証で使用できるハッシュアルゴリズムがリストされています。"
    },
    {
      "indent": 3,
      "text": "When registering a new hash algorithm, the following information MUST be provided:",
      "ja": "新しいハッシュアルゴリズムを登録するときは、次の情報を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Hash Algorithm",
      "ja": "ハッシュアルゴリズム"
    },
    {
      "indent": 6,
      "text": "The textual name of the hash algorithm.",
      "ja": "ハッシュアルゴリズムのテキスト名。"
    },
    {
      "indent": 3,
      "text": "Digest Size",
      "ja": "ダイジェストサイズ"
    },
    {
      "indent": 6,
      "text": "The size of the algorithm's output in bits.",
      "ja": "アルゴリズムの出力サイズ（ビット単位）。"
    },
    {
      "indent": 3,
      "text": "Reference",
      "ja": "参照"
    },
    {
      "indent": 6,
      "text": "A reference to the specification adding the algorithm to this registry.",
      "ja": "このレジストリにアルゴリズムを追加する仕様への参照。"
    },
    {
      "indent": 3,
      "text": "The update policy for this registry shall be Specification Required [RFC5226].",
      "ja": "このレジストリの更新ポリシーは、仕様が必要です[RFC5226]。"
    },
    {
      "indent": 3,
      "text": "The initial registry contains the following entries:",
      "ja": "初期レジストリには、次のエントリが含まれています。"
    },
    {
      "indent": 15,
      "text": "+----------------+-------------+-----------+\n| Hash Algorithm | Digest Size | Reference |\n+----------------+-------------+-----------+\n| \"MD5\"          | 128         | RFC 7616  |\n| \"SHA-512-256\"  | 256         | RFC 7616  |\n| \"SHA-256\"      | 256         | RFC 7616  |\n+----------------+-------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each one of the algorithms defined in the registry might have a \"-sess\" variant, e.g., MD5-sess, SHA-256-sess, etc.",
      "ja": "レジストリで定義されている各アルゴリズムには、「-sess」バリアント（MD5-sess、SHA-256-sessなど）がある場合があります。"
    },
    {
      "indent": 3,
      "text": "To clarify the purpose of the existing \"HTTP Digest Algorithm Values\" registry and to avoid confusion between the two registries, IANA has added the following description to the existing \"HTTP Digest Algorithm Values\" registry:",
      "ja": "既存の「HTTPダイジェストアルゴリズム値」レジストリの目的を明確にし、2つのレジストリ間の混乱を避けるために、IANAは次の説明を既存の「HTTPダイジェストアルゴリズム値」レジストリに追加しました。"
    },
    {
      "indent": 6,
      "text": "This registry lists the algorithms that can be used when creating digests of an HTTP message body, as specified in RFC 3230.",
      "ja": "このレジストリには、RFC 3230で指定されているHTTPメッセージ本文のダイジェストを作成するときに使用できるアルゴリズムがリストされています。"
    },
    {
      "indent": 0,
      "text": "6.2. Digest Scheme Registration",
      "section_title": true,
      "ja": "6.2. ダイジェストスキームの登録"
    },
    {
      "indent": 3,
      "text": "This specification updates the existing entry of the Digest scheme in the \"Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry\" and adds a new reference to this specification.",
      "ja": "この仕様は、「ハイパーテキスト転送プロトコル（HTTP）認証方式レジストリ」のダイジェスト方式の既存のエントリを更新し、この仕様への新しい参照を追加します。"
    },
    {
      "indent": 6,
      "text": "Authentication Scheme Name: Digest",
      "ja": "認証スキーム名：ダイジェスト"
    },
    {
      "indent": 6,
      "text": "Pointer to specification text: RFC 7616",
      "ja": "仕様テキストへのポインター：RFC 7616"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2978] Freed, N. and J. Postel, \"IANA Charset Registration Procedures\", BCP 19, RFC 2978, DOI 10.17487/RFC2978, October 2000, <http://www.rfc-editor.org/info/rfc2978>.",
      "ja": "[RFC2978] Freed、N。およびJ. Postel、「IANA Charset Registration Procedures」、BCP 19、RFC 2978、DOI 10.17487 / RFC2978、2000年10月、<http://www.rfc-editor.org/info/rfc2978> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<http：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 \"Randomness Requirements for Security\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、June 2005、<http：//www.rfc-editor .org / info / rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC5198] Klensin, J. and M. Padlipsky, \"Unicode Format for Network Interchange\", RFC 5198, DOI 10.17487/RFC5198, March 2008, <http://www.rfc-editor.org/info/rfc5198>.",
      "ja": "[RFC5198] Klensin、J。およびM. Padlipsky、「Network InterchangeのUnicode形式」、RFC 5198、DOI 10.17487 / RFC5198、2008年3月、<http://www.rfc-editor.org/info/rfc5198>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5987] Reschke, J., \"Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters\", RFC 5987, DOI 10.17487/RFC5987, August 2010, <http://www.rfc-editor.org/info/rfc5987>.",
      "ja": "[RFC5987] Reschke、J。、「ハイパーテキスト転送プロトコル（HTTP）ヘッダーフィールドパラメーターの文字セットと言語エンコード」、RFC 5987、DOI 10.17487 / RFC5987、2010年8月、<http://www.rfc-editor.org/ info / rfc5987>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454] Barth、A。、「The Web Origin Concept」、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, DOI 10.17487/RFC7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234] Fielding、R.、Ed。、Nottingham、M.、Ed。、and J. Reschke、Ed。、 \"Hypertext Transfer Protocol（HTTP / 1.1）：Caching\"、RFC 7234、DOI 10.17487 / RFC7234、June 2014 、<http://www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Authentication」、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7613] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 7613, DOI 10.17487/RFC7613, August 2015, <http://www.rfc-editor.org/info/rfc7613>.",
      "ja": "[RFC7613] Saint-Andre、P。およびA. Melnikov、「ユーザー名とパスワードを表す国際化された文字列の準備、適用、比較」、RFC 7613、DOI 10.17487 / RFC7613、2015年8月、<http：//www.rfc- editor.org/info/rfc7613>。"
    },
    {
      "indent": 3,
      "text": "[RFC7615] Reschke, J., \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\", RFC 7615, DOI 10.17487/RFC7615, September 2015, <http://www.rfc-editor.org/info/rfc7615>.",
      "ja": "[RFC7615] Reschke、J。、「HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields」、RFC 7615、DOI 10.17487 / RFC7615、2015年9月、<http://www.rfc-editor.org/info/ rfc7615>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC2195] Klensin, J., Catoe, R., and P. Krumviede, \"IMAP/POP AUTHorize Extension for Simple Challenge/Response\", RFC 2195, DOI 10.17487/RFC2195, September 1997, <http://www.rfc-editor.org/info/rfc2195>.",
      "ja": "[RFC2195] Klensin、J.、Catoe、R。、およびP. Krumviede、「IMAP / POP AUTHorize Extension for Simple Challenge / Response」、RFC 2195、DOI 10.17487 / RFC2195、1997年9月、<http：//www.rfc -editor.org/info/rfc2195>。"
    },
    {
      "indent": 3,
      "text": "[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, DOI 10.17487/RFC2617, June 1999, <http://www.rfc-editor.org/info/rfc2617>.",
      "ja": "[RFC2617] Franks、J.、Hallam-Baker、P.、Hostetler、J.、Lawrence、S.、Leach、P.、Luotonen、A。、およびL. Stewart、「HTTP Authentication：Basic and Digest Access Authentication」 、RFC 2617、DOI 10.17487 / RFC2617、1999年6月、<http://www.rfc-editor.org/info/rfc2617>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <http://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818] Rescorla、E。、「HTTP Over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC4513] Harrison, R., Ed., \"Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms\", RFC 4513, DOI 10.17487/RFC4513, June 2006, <http://www.rfc-editor.org/info/rfc4513>.",
      "ja": "[RFC4513] Harrison、R。、編、「Lightweight Directory Access Protocol（LDAP）：Authentication Methods and Security Mechanisms」、RFC 4513、DOI 10.17487 / RFC4513、2006年6月、<http://www.rfc-editor.org / info / rfc4513>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org / info / rfc5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, DOI 10.17487/RFC7617, September 2015, <http://www.rfc-editor.org/info/rfc7617>.",
      "ja": "[RFC7617] Reschke、J。、「The 'Basic' HTTP Authentication Scheme」、RFC 7617、DOI 10.17487 / RFC7617、2015年9月、<http://www.rfc-editor.org/info/rfc7617>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Changes from RFC 2617",
      "section_title": true,
      "ja": "付録A. RFC 2617からの変更点"
    },
    {
      "indent": 3,
      "text": "This document introduces the following changes:",
      "ja": "このドキュメントでは、次の変更を紹介します。"
    },
    {
      "indent": 3,
      "text": "o Adds support for two new algorithms, SHA2-256 as mandatory and SHA2-512/256 as a backup, and defines the proper algorithm negotiation. The document keeps the MD5 algorithm support but only for backward compatibility.",
      "ja": "o SHA2-256を必須として、SHA2-512 / 256をバックアップとして2つの新しいアルゴリズムのサポートを追加し、適切なアルゴリズムネゴシエーションを定義します。このドキュメントはMD5アルゴリズムのサポートを維持していますが、下位互換性のためにのみです。"
    },
    {
      "indent": 3,
      "text": "o Introduces the username hashing capability and the parameter associated with that, mainly for privacy reasons.",
      "ja": "o 主にプライバシー上の理由から、ユーザー名のハッシュ機能とそれに関連するパラメーターを紹介します。"
    },
    {
      "indent": 3,
      "text": "o Adds various internationalization considerations that impact the A1 calculation and username and password encoding.",
      "ja": "o A1の計算、ユーザー名とパスワードのエンコードに影響を与えるさまざまな国際化の考慮事項を追加します。"
    },
    {
      "indent": 3,
      "text": "o Introduces a new IANA registry, \"Hash Algorithms for HTTP Digest Authentication\", that lists the hash algorithms that can be used in HTTP Digest Authentication.",
      "ja": "o 新しいIANAレジストリ「HTTPダイジェスト認証のハッシュアルゴリズム」が導入され、HTTPダイジェスト認証で使用できるハッシュアルゴリズムがリストされています。"
    },
    {
      "indent": 3,
      "text": "o Deprecates backward compatibility with RFC 2069.",
      "ja": "o RFC 2069との下位互換性を廃止します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "To provide a complete description for the Digest mechanism and its operation, this document borrows text heavily from [RFC2617]. The authors of this document would like to thank John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for their work on that specification.",
      "ja": "ダイジェストメカニズムとその動作の完全な説明を提供するために、このドキュメントでは[RFC2617]からテキストを多用しています。このドキュメントの作成者は、ジョンフランクス、フィリップM.ハラムベイカー、ジェフリーL.ホセトラー、スコットD.ローレンス、ポールJ.リーチ、アリルオトネン、およびローレンスC.スチュワートにその仕様の作成に感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Special thanks to Julian Reschke for his many reviews, comments, suggestions, and text provided to various areas in this document.",
      "ja": "このドキュメントのさまざまな領域に提供された多くのレビュー、コメント、提案、およびテキストについて、Julian Reschkeに特に感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Stephen Farrell, Yoav Nir, Phillip Hallam-Baker, Manu Sporny, Paul Hoffman, Yaron Sheffer, Sean Turner, Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann, Martin Durst, Peter Saint-Andre, Michael Sweet, Daniel Stenberg, Brett Tate, Paul Leach, Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk, Kathleen Moriarty, Francis Dupont, Hilarie Orman, and Ben Campbell for their careful review and comments.",
      "ja": "著者は、Stephen Farrell、Yoav Nir、Phillip Hallam-Baker、Manu Sporny、Paul Hoffman、Yaron Sheffer、Sean Turner、Geoff Baskwill、Eric Cooper、Bjoern Hoehrmann、Martin Durst、Peter Saint-Andre、Michael Sweet、Danielに感謝します。 Stenberg、Brett Tate、Paul Leach、Ilari Liusvaara、Gary Mort、Alexey Melnikov、Benjamin Kaduk、Kathleen Moriarty、Francis Dupont、Hilarie Orman、Ben Campbellの慎重なレビューとコメント。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Jonathan Stoke, Nico Williams, Harry Halpin, and Phil Hunt for their comments on the mailing list when discussing various aspects of this document.",
      "ja": "このドキュメントのさまざまな側面について議論する際のメーリングリストへのコメントについて、著者はJonathan Stoke、Nico Williams、Harry Halpin、およびPhil Huntに感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Paul Kyzivat and Dale Worley for their careful review and feedback on some aspects of this document.",
      "ja": "著者は、このドキュメントのいくつかの側面に関する慎重なレビューとフィードバックを提供してくれたPaul KyzivatとDale Worleyに感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Barry Leiba for his help with the registry.",
      "ja": "著者は、レジストリでの彼の助けのためにバリー・レイバに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Rifaat Shekh-Yusef (editor) Avaya 250 Sidney Street Belleville, Ontario Canada",
      "ja": "Rifat Sheikh-Youssef（editor）Sydney Street Belleville、Ontario Canada"
    },
    {
      "indent": 3,
      "text": "Phone: +1-613-967-5267\nEmail: rifaat.ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Ahrens Independent California United States",
      "ja": "デビッドアーレンス独立カリフォルニア州アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: ahrensdc@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sophie Bremer Netzkonform Germany",
      "ja": "ソフィーブレマーネッツコンフォームドイツ"
    },
    {
      "indent": 3,
      "text": "Email: sophie.bremer@netzkonform.de",
      "raw": true,
      "ja": ""
    }
  ]
}