{
  "title": {
    "text": "RFC 7712 - Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)",
    "ja": "RFC 7712 - Extensible Messaging and Presence Protocol（XMPP）のドメイン名の関連付け（DNA）"
  },
  "number": 7712,
  "created_at": "2020-08-30 08:22:20.681474+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    P. Saint-Andre\nRequest for Comments: 7712                                          &yet\nCategory: Standards Track                                      M. Miller\nISSN: 2070-1721                                      Cisco Systems, Inc.\n                                                               P. Hancke\n                                                                    &yet\n                                                           November 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": " Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)",
      "ja": "Extensible Messaging and Presence Protocol（XMPP）のドメイン名の関連付け（DNA）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document improves the security of the Extensible Messaging and Presence Protocol (XMPP) in two ways. First, it specifies how to establish a strong association between a domain name and an XML stream, using the concept of \"prooftypes\". Second, it describes how to securely delegate a service domain name (e.g., example.com) to a target server hostname (e.g., hosting.example.net); this is especially important in multi-tenanted environments where the same target server hosts a large number of domains.",
      "ja": "このドキュメントは、2つの方法でExtensible Messaging and Presence Protocol（XMPP）のセキュリティを向上させます。まず、「プルーフタイプ」の概念を使用して、ドメイン名とXMLストリームの間に強い関連付けを確立する方法を指定します。次に、サービスドメイン名（example.comなど）をターゲットサーバーのホスト名（hosting.example.netなど）に安全に委任する方法について説明します。これは、同じターゲットサーバーが多数のドメインをホストするマルチテナント環境で特に重要です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7712.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7712で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Terminology .....................................................4\n3. Client-to-Server (C2S) DNA ......................................4\n   3.1. C2S Flow ...................................................4\n   3.2. C2S Description ............................................5\n4. Server-to-Server (S2S) DNA ......................................5\n   4.1. S2S Flow ...................................................6\n   4.2. A Simple S2S Scenario .....................................10\n   4.3. No Mutual PKIX Authentication .............................12\n   4.4. Piggybacking ..............................................13\n        4.4.1. Assertion ..........................................13\n        4.4.2. Supposition ........................................15\n5. Alternative Prooftypes .........................................16\n   5.1. DANE ......................................................16\n   5.2. POSH ......................................................17\n6. Secure Delegation and Multi-Tenancy ............................18\n7. Prooftype Model ................................................18\n8. Guidance for Server Operators ..................................19\n9. IANA Considerations ............................................20\n   9.1. POSH Service Name for xmpp-client Service .................20\n   9.2. POSH Service Name for xmpp-server Service .................20\n10. Security Considerations .......................................20\n11. References ....................................................21\n   11.1. Normative References .....................................21\n   11.2. Informative References ...................................23\nAcknowledgements ..................................................24\nAuthors' Addresses ................................................24",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In systems that use the Extensible Messaging and Presence Protocol (XMPP) [RFC6120], it is important to establish a strong association between the DNS domain name of an XMPP service (e.g., example.com) and the XML stream that a client or peer server initiates with that service. In other words, the client or peer server needs to verify the identity of the server to which it connects. Additionally, servers need to verify incoming connections from other servers.",
      "ja": "Extensible Messaging and Presence Protocol（XMPP）[RFC6120]を使用するシステムでは、XMPPサービスのDNSドメイン名（example.comなど）とクライアントまたはピアが使用するXMLストリームとの間に強い関連付けを確立することが重要ですサーバーはそのサービスで開始します。つまり、クライアントまたはピアサーバーは、接続先のサーバーのIDを確認する必要があります。さらに、サーバーは他のサーバーからの着信接続を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "To date, such verification has been established based on information obtained from the Domain Name System (DNS), the Public Key Infrastructure (PKI), or similar sources. In particular, XMPP as defined in [RFC6120] assumed that Domain Name Associations (DNA) are to be proved using the \"PKIX prooftype\"; that is, the server's proof consists of a PKIX certificate that is checked according to the XMPP profile of the matching rules from [RFC6125] (and the overall validation rules from [RFC5280]), the client's verification material is obtained out of band in the form of a trusted root, and secure DNS is not necessary.",
      "ja": "現在までに、このような検証は、ドメインネームシステム（DNS）、公開キー基盤（PKI）、または類似のソースから取得した情報に基づいて確立されています。特に、[RFC6120]で定義されているXMPPは、ドメイン名の関連付け（DNA）が「PKIX prooftype」を使用して証明されることを想定しています。つまり、サーバーの証明は、[RFC6125]のマッチングルール（および[RFC5280]の全体的な検証ルール）のXMPPプロファイルに従ってチェックされるPKIX証明書で構成され、クライアントの検証資料は、信頼されたルートの形式であり、安全なDNSは必要ありません。"
    },
    {
      "indent": 3,
      "text": "By extending the concept of a domain name association within XMPP, this document does the following:",
      "ja": "XMPP内のドメイン名の関連付けの概念を拡張することにより、このドキュメントは次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Generalizes the model currently in use so that additional prooftypes can be defined if needed.",
      "ja": "1. 現在使用中のモデルを一般化して、必要に応じて追加の証明タイプを定義できるようにします。"
    },
    {
      "indent": 3,
      "text": "2. Provides a basis for modernizing some prooftypes to reflect progress in underlying technologies such as DNS Security [RFC4033].",
      "ja": "2. DNSセキュリティ[RFC4033]などの基盤となるテクノロジーの進歩を反映するために、いくつかのプルーフタイプを最新化するための基礎を提供します。"
    },
    {
      "indent": 3,
      "text": "3. Describes the flow of operations for establishing a domain name association.",
      "ja": "3. ドメイン名の関連付けを確立するための操作のフローについて説明します。"
    },
    {
      "indent": 3,
      "text": "This document also provides guidelines for secure delegation of a service domain name (e.g., example.com) to a target server hostname (e.g., hosting.example.net). The need for secure delegation arises because the process for resolving the domain name of an XMPP service into the IP address at which an XML stream will be negotiated (see [RFC6120]) can involve delegation of a service domain name to a target server hostname using technologies such as DNS SRV records [RFC2782]. A more detailed description of the delegation problem can be found in [RFC7711]. The domain name association can be verified only if the delegation is done in a secure manner.",
      "ja": "このドキュメントでは、サービスドメイン名（example.comなど）をターゲットサーバーのホスト名（hosting.example.netなど）に安全に委任するためのガイドラインも提供します。 XMPPサービスのドメイン名を、XMLストリームがネゴシエートされるIPアドレスに解決するプロセス（[RFC6120]を参照）では、サービスドメイン名をターゲットサーバーのホスト名に委任する必要があるため、安全な委任が必要になります。 DNS SRVレコードなどのテクノロジー[RFC2782]。委任問題のより詳細な説明は[RFC7711]にあります。ドメイン名の関連付けは、委任が安全な方法で行われた場合にのみ確認できます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "This document inherits XMPP terminology from [RFC6120] and [XEP-0220]; DNS terminology from [RFC1034], [RFC1035], [RFC2782], and [RFC4033]; and security terminology from [RFC4949] and [RFC5280]. The terms \"reference identity\" and \"presented identity\" are used as defined in the \"CertID\" specification [RFC6125]. For the sake of consistency with [RFC7673], this document uses the terms \"service domain name\" and \"target server hostname\" to refer to the same entities identified by the terms \"source domain\" and \"derived domain\" from [RFC6125].",
      "ja": "このドキュメントは、[RFC6120]と[XEP-0220]からXMPP用語を継承しています。 [RFC1034]、[RFC1035]、[RFC2782]、および[RFC4033]のDNS用語。 [RFC4949]および[RFC5280]のセキュリティ用語。 「参照ID」および「提示されたID」という用語は、「CertID」仕様[RFC6125]で定義されているとおりに使用されます。 [RFC7673]との一貫性を保つため、このドキュメントでは「サービスドメイン名」と「ターゲットサーバーのホスト名」という用語を使用して、[RFC6125]の「ソースドメイン」と「派生ドメイン」という用語で識別される同じエンティティを指します。"
    },
    {
      "indent": 0,
      "text": "3. Client-to-Server (C2S) DNA",
      "section_title": true,
      "ja": "3. クライアントからサーバー（C2S）DNA"
    },
    {
      "indent": 3,
      "text": "The client-to-server case is much simpler than the server-to-server case because the client does not assert a domain name; this means that verification happens in only one direction. Therefore, we describe this case first to help the reader understand domain name associations in XMPP.",
      "ja": "クライアントがドメイン名をアサートしないため、クライアントからサーバーへのケースはサーバーからサーバーへのケースよりもはるかに簡単です。つまり、検証は一方向でのみ行われます。したがって、読者がXMPPでのドメイン名の関連付けを理解できるように、最初にこのケースについて説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. C2S Flow",
      "section_title": true,
      "ja": "3.1. C2Sフロー"
    },
    {
      "indent": 3,
      "text": "The following flow chart illustrates the protocol flow for establishing a domain name association for an XML stream from a client (C) to a server (S) using the standard PKIX prooftype specified in [RFC6120].",
      "ja": "次のフローチャートは、[RFC6120]で指定されている標準のPKIX証明タイプを使用して、クライアント（C）からサーバー（S）へのXMLストリームのドメイン名の関連付けを確立するためのプロトコルフローを示しています。"
    },
    {
      "indent": 3,
      "text": "                        |\n                DNS RESOLUTION ETC.\n                        |\n+-----------------STREAM HEADERS---------------------+\n|                                                    |\n|  C: <stream to='a.example'>                        |\n|                                                    |\n|  S: <stream from='a.example'>                      |\n|                                                    |\n+----------------------------------------------------+\n                        |\n+-----------------TLS NEGOTIATION--------------------+\n|                                                    |\n|  S: Server Certificate                             |\n|                                                    |\n+----------------------------------------------------+\n                        |\n          (client checks certificate and\n           establishes DNA for a.example)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. C2S Description",
      "section_title": true,
      "ja": "3.2. C2Sの説明"
    },
    {
      "indent": 3,
      "text": "The simplified order of events (see [RFC6120] for details) in establishing an XML stream from a client (user@a.example) to a server (a.example) is as follows:",
      "ja": "クライアント（user@a.example）からサーバー（a.example）へのXMLストリームを確立する際のイベントの単純化された順序（詳細は[RFC6120]を参照）は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The client resolves via DNS the service _xmpp-client._tcp.a.example.",
      "ja": "1. クライアントはDNSを介してサービス_xmpp-client._tcp.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. The client opens a TCP connection to the resolved IP address.",
      "ja": "2. クライアントは、解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. The client sends an initial stream header to the server:",
      "ja": "3. クライアントはサーバーに初期ストリームヘッダーを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream to='a.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4. The server sends a response stream header to the client, asserting that it is a.example:",
      "ja": "4. サーバーはクライアントに応答ストリームヘッダーを送信し、それがa.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "5. The parties attempt TLS negotiation, during which the XMPP server (acting as a TLS server) presents a PKIX certificate proving that it is a.example.",
      "ja": "5. 当事者はTLSネゴシエーションを試行し、その間にXMPPサーバー（TLSサーバーとして機能）は、それが例であることを証明するPKIX証明書を提示します。"
    },
    {
      "indent": 3,
      "text": "6. The client checks the PKIX certificate that the server provided; if the proof is consistent with the XMPP profile of the matching rules from [RFC6125] and the certificate is otherwise valid according to [RFC5280], the client accepts that there is a strong domain name association between its stream to the target server and the DNS domain name of the XMPP service.",
      "ja": "6. クライアントは、サーバーが提供したPKIX証明書をチェックします。証明が[RFC6125]の一致ルールのXMPPプロファイルと一致し、証明書が[RFC5280]に従って有効である場合、クライアントは、ターゲットサーバーへのストリームとDNSの間に強いドメイン名の関連付けがあることを受け入れますXMPPサービスのドメイン名。"
    },
    {
      "indent": 3,
      "text": "The certificate that the server presents might not be acceptable to the client. As one example, the server might be hosting multiple domains and secure delegation as described in Section 6 is necessary. As another example, the server might present a self-signed certificate, which requires the client to either (1) apply the fallback process described in Section 6.6.4 of [RFC6125] or (2) prompt the user to accept an unauthenticated connection as described in Section 3.4 of [RFC7590].",
      "ja": "サーバーが提示する証明書は、クライアントに受け入れられない場合があります。一例として、サーバーは複数のドメインをホストしている場合があり、セクション6で説明されている安全な委任が必要です。別の例として、サーバーは自己署名証明書を提示する場合があります。この場合、クライアントは（1）[RFC6125]のセクション6.6.4で説明されているフォールバックプロセスを適用するか、または（2）非認証接続を受け入れるようにユーザーに要求します。 [RFC7590]のセクション3.4で説明されています。"
    },
    {
      "indent": 0,
      "text": "4. Server-to-Server (S2S) DNA",
      "section_title": true,
      "ja": "4. サーバー間（S2S）DNA"
    },
    {
      "indent": 3,
      "text": "The server-to-server case is significantly more complex than the client-to-server case, and it involves the checking of domain name associations in both directions along with other \"wrinkles\" described in the following sections. In some parts of the flow, server-to-server communications use the Server Dialback protocol first specified in (the now obsolete) [RFC3920] and since moved to",
      "ja": "サーバーからサーバーへのケースは、クライアントからサーバーへのケースよりもはるかに複雑であり、次のセクションで説明する他の「しわ」とともに、双方向でのドメイン名の関連付けのチェックが含まれます。フローの一部では、サーバー間通信は（現在は廃止された）[RFC3920]で最初に指定され、それ以降に移行されるサーバーダイヤルバックプロトコルを使用します。"
    },
    {
      "indent": 3,
      "text": "[XEP-0220]. See \"Impact of TLS and DNSSEC on Dialback\" [XEP-0344] for considerations when using it together with TLS and DNSSEC. Also, \"Bidirectional Server-to-Server Connections\" [XEP-0288] provides a way to use the server-to-server connections for bidirectional exchange of XML stanzas, which reduces the complexity of some of the processes involved.",
      "ja": "[XEP-0220]。 TLSおよびDNSSECと一緒に使用する場合の考慮事項については、「ダイヤルバックに対するTLSおよびDNSSECの影響」[XEP-0344]を参照してください。また、「双方向サーバー間接続」[XEP-0288]は、XMLスタンザの双方向交換にサーバー間接続を使用する方法を提供します。これにより、関連する一部のプロセスの複雑さが軽減されます。"
    },
    {
      "indent": 0,
      "text": "4.1. S2S Flow",
      "section_title": true,
      "ja": "4.1. S2Sフロー"
    },
    {
      "indent": 3,
      "text": "The following flow charts illustrate the protocol flow for establishing domain name associations between Server 1 (the initiating entity) and Server 2 (the receiving entity), as described in the remaining sections of this document.",
      "ja": "次のフローチャートは、このドキュメントの残りのセクションで説明するように、サーバー1（開始エンティティ）とサーバー2（受信エンティティ）の間にドメイン名の関連付けを確立するためのプロトコルフローを示しています。"
    },
    {
      "indent": 3,
      "text": "A simple S2S scenario would be as follows:",
      "ja": "単純なS2Sシナリオは次のようになります。"
    },
    {
      "indent": 3,
      "text": "                    |\n             DNS RESOLUTION ETC.\n                    |\n+-------------STREAM HEADERS--------------------+\n|                                               |\n|  A: <stream from='a.example' to='b.example'>  |\n|                                               |\n|  B: <stream from='b.example' to='a.example'>  |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------------TLS NEGOTIATION-------------------+\n|                                               |\n|  B: Server Certificate                        |\n|  B: Certificate Request                       |\n|  A: Client Certificate                        |\n|                                               |\n+-----------------------------------------------+\n                    |\n    (A establishes DNA for b.example)\n                    |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After the domain name association has been established in one direction, it is possible to perform mutual authentication using the Simple Authentication and Security Layer (SASL) [RFC4422] and thus establish domain name associations in both directions.",
      "ja": "ドメイン名の関連付けが一方向で確立された後、Simple Authentication and Security Layer（SASL）[RFC4422]を使用して相互認証を実行し、双方向でドメイン名の関連付けを確立することができます。"
    },
    {
      "indent": 3,
      "text": "                    |\n+-------------AUTHENTICATION--------------------+\n|                   |                           |\n|       {valid client certificate?} --+         |\n|                   |                 |         |\n|                   | yes         no  |         |\n|                   v                 |         |\n|             SASL EXTERNAL           |         |\n|             (mutual auth)           |         |\n|   (B establishes DNA for a.example) |         |\n+-------------------------------------|---------+\n                                      |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "However, if mutual authentication cannot be completed using SASL, the receiving server needs to establish a domain name association in another way. This scenario is described in Section 4.3.",
      "ja": "ただし、SASLを使用して相互認証を完了できない場合、受信サーバーは別の方法でドメイン名の関連付けを確立する必要があります。このシナリオについては、セクション4.3で説明します。"
    },
    {
      "indent": 3,
      "text": "                                      |\n                    +-----------------+\n                    |\n        (Section 4.3: No Mutual PKIX Authentication)\n                    |\n                    | B needs to establish DNA\n                    | for this stream from a.example,\n                    | so A asserts its identity\n                    |\n+----------DIALBACK IDENTITY ASSERTION----------+\n|                                               |\n|  A: <db:result from='a.example'               |\n|                to='b.example'>                |\n|       some-dialback-key                       |\n|     </db:result>                              |\n|                                               |\n+-----------------------------------------------+\n                    |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "             DNS RESOLUTION ETC.\n                    |\n+-------------STREAM HEADERS--------------------+\n|                                               |\n|  B: <stream from='b.example' to='a.example'>  |\n|                                               |\n|  A: <stream from='a.example' to='b.example'>  |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------------TLS NEGOTIATION-------------------+\n|                                               |\n|  A: Server Certificate                        |\n|                                               |\n+-----------------------------------------------+\n                    |\n+----------DIALBACK IDENTITY VERIFICATION-------+\n|                                               |\n|  B: <db:verify from='b.example'               |\n|                to='a.example'                 |\n|                id='...'>                      |\n|       some-dialback-key                       |\n|     </db:verify>                              |\n|                                               |\n|  A: <db:verify from='a.example'               |\n|                to='b.example'                 |\n|                type='valid'                   |\n|                id='...'>                      |\n|                                               |\n+-----------------------------------------------+\n                    |\n    (B establishes DNA for a.example)\n                    |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If one of the servers hosts additional service names (e.g., Server 2 might host c.example in addition to b.example and Server 1 might host rooms.a.example in addition to a.example), then the servers can use Server Dialback \"piggybacking\" to establish additional domain name associations for the stream, as described in Section 4.4.",
      "ja": "サーバーの1つが追加のサービス名をホストしている場合（たとえば、サーバー2がb.exampleに加えてc.exampleをホストし、サーバー1がa.exampleに加えてrooms.a.exampleをホストしている場合）、サーバーはサーバーダイヤルバックを使用できます。 「ピギーバック」により、セクション4.4で説明されているように、ストリームの追加のドメイン名の関連付けを確立します。"
    },
    {
      "indent": 3,
      "text": "There are two varieties of piggybacking. The first is here called \"assertion\".",
      "ja": "ピギーバックには2種類あります。最初はここで「アサーション」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "                    |\n      (Section 4.4.1: Piggybacking Assertion)\n                    |\n+----------DIALBACK IDENTITY ASSERTION----------+\n|                                               |\n|  B: <db:result from='c.example'               |\n|                to='a.example'/>               |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------DNA ESTABLISHMENT AS ABOVE--------------+\n|                                               |\n|    DNS RESOLUTION, STREAM HEADERS,            |\n|    TLS NEGOTIATION, AUTHENTICATION            |\n|                                               |\n+-----------------------------------------------+\n                    |\n+----------DIALBACK IDENTITY VERIFICATION-------+\n|                                               |\n|  A: <db:result from='a.example'               |\n|                to='c.example'                 |\n|                type='valid'/>                 |\n|                                               |\n+-----------------------------------------------+\n                    |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second variety of piggybacking is here called \"supposition\".",
      "ja": "ここでは、ピギーバッキングの2番目の種類を「想定」と呼びます。"
    },
    {
      "indent": 3,
      "text": "                    |\n      (Section 4.4.2: Piggybacking Supposition)\n                    |\n+-----------SUBSEQUENT CONNECTION---------------+\n|                                               |\n|  B: <stream from='c.example'                  |\n|             to='rooms.a.example'>             |\n|                                               |\n|  A: <stream from='rooms.a.example'            |\n|             to='c.example'>                   |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------DNA ESTABLISHMENT AS ABOVE--------------+\n|                                               |\n|    DNS RESOLUTION, STREAM HEADERS,            |\n|    TLS NEGOTIATION, AUTHENTICATION            |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-----------DIALBACK OPTIMIZATION---------------+\n|                                               |\n|  B: <db:result from='c.example'               |\n|                to='rooms.a.example'/>         |\n|                                               |\n|  B: <db:result from='rooms.a.example'         |\n|                to='c.example'                 |\n|                type='valid'/>                 |\n|                                               |\n+-----------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. A Simple S2S Scenario",
      "section_title": true,
      "ja": "4.2. 単純なS2Sシナリオ"
    },
    {
      "indent": 3,
      "text": "To illustrate the problem, consider the simplified order of events (see [RFC6120] for details) in establishing an XML stream between Server 1 (a.example) and Server 2 (b.example):",
      "ja": "問題を説明するために、サーバー1（a.example）とサーバー2（b.example）の間でXMLストリームを確立する際のイベントの単純化された順序（詳細は[RFC6120]を参照）を検討してください。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 resolves via DNS the service _xmpp-server._tcp.b.example.",
      "ja": "1. サーバー1は、DNSを介してサービス_xmpp-server._tcp.b.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 1 opens a TCP connection to the resolved IP address.",
      "ja": "2. サーバー1は、解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. Server 1 sends an initial stream header to Server 2, asserting that it is a.example:",
      "ja": "3. サーバー1は初期ストリームヘッダーをサーバー2に送信し、それがa.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='b.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends a response stream header to Server 1, asserting that it is b.example:",
      "ja": "4. サーバー2はサーバー1に応答ストリームヘッダーを送信し、それがb.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='b.example' to='a.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "5. The servers attempt TLS negotiation, during which Server 2 (acting as a TLS server) presents a PKIX certificate proving that it is b.example and Server 1 (acting as a TLS client) presents a PKIX certificate proving that it is a.example.",
      "ja": "5. サーバーはTLSネゴシエーションを試行し、その間にサーバー2（TLSサーバーとして機能）はそれがb.exampleであることを証明するPKIX証明書を提示し、サーバー1（TLSクライアントとして機能）はそれがa.exampleであることを証明するPKIX証明書を提示します。"
    },
    {
      "indent": 3,
      "text": "6. Server 1 checks the PKIX certificate that Server 2 provided, and Server 2 checks the PKIX certificate that Server 1 provided; if these proofs are consistent with the XMPP profile of the matching rules from [RFC6125] and are otherwise valid according to [RFC5280], each server accepts that there is a strong domain name association between its stream to the other party and the DNS domain name of the other party (i.e., mutual authentication is achieved).",
      "ja": "6. サーバー1はサーバー2が提供したPKIX証明書をチェックし、サーバー2はサーバー1が提供したPKIX証明書をチェックします。これらの証明が[RFC6125]の一致ルールのXMPPプロファイルと一致し、それ以外の場合は[RFC5280]に従って有効である場合、各サーバーは、相手へのストリームとDNSドメイン名の間に強いドメイン名の関連付けがあることを受け入れます相手の（すなわち、相互認証が達成される）。"
    },
    {
      "indent": 3,
      "text": "Several simplifying assumptions underlie the \"happy path\" scenario just outlined:",
      "ja": "単純化されたいくつかの仮定が、ここで概説した「ハッピーパス」シナリオの根底にあります。"
    },
    {
      "indent": 3,
      "text": "o The PKIX certificate presented by Server 2 during TLS negotiation is acceptable to Server 1 and matches the expected identity.",
      "ja": "o TLSネゴシエーション中にサーバー2によって提示されたPKIX証明書はサーバー1に受け入れられ、予期されるIDと一致します。"
    },
    {
      "indent": 3,
      "text": "o The PKIX certificate presented by Server 1 during TLS negotiation is acceptable to Server 2; this enables the parties to complete mutual authentication.",
      "ja": "o TLSネゴシエーション中にサーバー1によって提示されたPKIX証明書はサーバー2に受け入れられます。これにより、当事者は相互認証を完了することができます。"
    },
    {
      "indent": 3,
      "text": "o There are no additional domains associated with Server 1 and Server 2 (say, a sub-domain rooms.a.example on Server 1 or a second domain c.example on Server 2).",
      "ja": "o サーバー1とサーバー2に関連付けられた追加のドメインはありません（たとえば、サーバー1のサブドメインrooms.a.exampleまたはサーバー2の2番目のドメインc.example）。"
    },
    {
      "indent": 3,
      "text": "o The server administrators are able to obtain PKIX certificates issued by a widely accepted Certification Authority (CA) in the first place.",
      "ja": "o サーバー管理者は、広く受け入れられている証明機関（CA）が発行したPKIX証明書を最初に取得できます。"
    },
    {
      "indent": 3,
      "text": "o The server administrators are running their own XMPP servers, rather than using hosting services.",
      "ja": "o サーバー管理者は、ホスティングサービスを使用するのではなく、独自のXMPPサーバーを実行しています。"
    },
    {
      "indent": 3,
      "text": "Let's consider each of these \"wrinkles\" in turn.",
      "ja": "これらの「しわ」を順番に検討してみましょう。"
    },
    {
      "indent": 0,
      "text": "4.3. No Mutual PKIX Authentication",
      "section_title": true,
      "ja": "4.3. 相互PKIX認証なし"
    },
    {
      "indent": 3,
      "text": "If the PKIX certificate presented by Server 1 during TLS negotiation is not acceptable to Server 2, Server 2 is unable to mutually authenticate Server 1. Therefore, Server 2 needs to verify the asserted identity of Server 1 by other means.",
      "ja": "TLSネゴシエーション中にサーバー1によって提示されたPKIX証明書がサーバー2に受け入れられない場合、サーバー2はサーバー1を相互認証できません。したがって、サーバー2は他の方法でサーバー1のアサートされたIDを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 asserts that it is a.example using the Server Dialback protocol:",
      "ja": "1. サーバー1は、サーバーダイヤルバックプロトコルを使用した例であることを表明します。"
    },
    {
      "indent": 7,
      "text": "<db:result from='a.example' to='b.example'>\n           some-dialback-key</db:result>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "2. Server 2 resolves via DNS the service _xmpp-server._tcp.a.example.",
      "ja": "2. サーバー2はDNSを介してサービス_xmpp-server._tcp.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "3. Server 2 opens a TCP connection to the resolved IP address.",
      "ja": "3. サーバー2は、解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends an initial stream header to Server 1, asserting that it is b.example:",
      "ja": "4. サーバー2はサーバー1に初期ストリームヘッダーを送信し、それがb.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='b.example' to='a.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "5. Server 1 sends a response stream header to Server 2, asserting that it is a.example:",
      "ja": "5. サーバー1はサーバー2に応答ストリームヘッダーを送信し、それがa.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='b.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "6. The servers attempt TLS negotiation, during which Server 1 (acting as a TLS server) presents a PKIX certificate.",
      "ja": "6. サーバーはTLSネゴシエーションを試行し、その間にサーバー1（TLSサーバーとして機能）がPKIX証明書を提示します。"
    },
    {
      "indent": 3,
      "text": "7. Server 2 checks the PKIX certificate that Server 1 provided (this might be the same certificate presented by Server 1 as a client certificate in the initial connection). However, Server 2 does not accept this certificate as proving that Server 1 is authorized as a.example and therefore uses another method (here, the Server Dialback protocol) to establish the domain name association.",
      "ja": "7. サーバー2は、サーバー1が提供したPKIX証明書をチェックします（これは、サーバー1によって最初の接続でクライアント証明書として提示されたものと同じ証明書である可能性があります）。ただし、サーバー2はこの証明書を受け入れません。これは、サーバー1が例として承認されていることを証明するため、別の方法（ここではサーバーダイヤルバックプロトコル）を使用してドメイン名の関連付けを確立します。"
    },
    {
      "indent": 3,
      "text": "8. Server 2 proceeds with Server Dialback in order to establish the domain name association. In order to do this, it sends a request for verification as described in [XEP-0220]:",
      "ja": "8. サーバー2は、ドメイン名の関連付けを確立するためにサーバーダイヤルバックを続行します。これを行うには、[XEP-0220]で説明されているように、検証要求を送信します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='b.example' to='a.example'\n           id='...'>some-dialback-key</db:verify>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "9. Server 1 responds to this:",
      "ja": "9. サーバー1はこれに応答します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='a.example' to='b.example' id='...' type='valid/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "allowing Server 2 to establish the domain name association.",
      "ja": "サーバー2がドメイン名の関連付けを確立できるようにします。"
    },
    {
      "indent": 3,
      "text": "In some situations (e.g., if the Authoritative Server in Server Dialback presents the same certificate as the Originating Server), it is the practice of some XMPP server implementations to skip steps 8 and 9. These situations are discussed in \"Impact of TLS and DNSSEC on Dialback\" [XEP-0344].",
      "ja": "状況によっては（たとえば、サーバーダイヤルバックの権威サーバーが元のサーバーと同じ証明書を提示する場合）、手順8および9をスキップするのが一部のXMPPサーバー実装の慣例です。これらの状況については、「TLSとDNSSECの影響」で説明します。 on Dialback」[XEP-0344]。"
    },
    {
      "indent": 0,
      "text": "4.4. Piggybacking",
      "section_title": true,
      "ja": "4.4. ピギーバッキング"
    },
    {
      "indent": 0,
      "text": "4.4.1. Assertion",
      "section_title": true,
      "ja": "4.4.1. アサーション"
    },
    {
      "indent": 3,
      "text": "Consider the common scenario in which Server 2 hosts not only b.example but also a second domain c.example (often called a \"multi-tenanted\" environment). If a user of Server 2 associated with c.example wishes to communicate with a friend at a.example, Server 2 needs to send XMPP stanzas from the domain c.example rather than b.example. Although Server 2 could open a new TCP connection and negotiate new XML streams for the domain pair of c.example and a.example, that is wasteful (especially if Server 2 hosts a large number of domains). Server 2 already has a connection to a.example, so how can it assert that it would like to add a new domain pair to the existing connection?",
      "ja": "サーバー2がb.exampleだけでなく、2番目のドメインc.example（しばしば「マルチテナント」環境と呼ばれる）もホストするという一般的なシナリオを考えてみましょう。 c.exampleに関連付けられたサーバー2のユーザーがa.exampleの友達と通信したい場合、サーバー2は、b.exampleではなくドメインc.exampleからXMPPスタンザを送信する必要があります。サーバー2は新しいTCP接続を開いてc.exampleとa.exampleのドメインペアの新しいXMLストリームをネゴシエートできますが、それは無駄です（特にサーバー2が多数のドメインをホストしている場合）。サーバー2はすでにa.exampleへの接続を持っているので、既存の接続に新しいドメインペアを追加したいことをどのように表明できますか？"
    },
    {
      "indent": 3,
      "text": "The traditional method for doing so is the Server Dialback protocol [XEP-0220]. Here, Server 2 can send a <db:result/> element for the new domain pair over the existing stream.",
      "ja": "これを行うための従来の方法は、サーバーダイヤルバックプロトコル[XEP-0220]です。ここで、サーバー2は、既存のストリームを介して新しいドメインペアの<db：result />要素を送信できます。"
    },
    {
      "indent": 7,
      "text": "<db:result from='c.example' to='a.example'>\n  some-dialback-key\n</db:result>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This <db:result/> element functions as Server 2's assertion that it is (also) c.example (thus, the element is functionally equivalent to the 'from' address of an initial stream header as previously described).",
      "ja": "この<db：result />要素は、c.example（また）であるというサーバー2のアサーションとして機能します（したがって、この要素は、前述のように、初期ストリームヘッダーの「from」アドレスと機能的に同等です）。"
    },
    {
      "indent": 3,
      "text": "In response to this assertion, Server 1 needs to obtain some kind of proof that Server 2 really is also c.example. If the certificate presented by Server 2 is also valid for c.example, then no further action is necessary. However, if not, then Server 1 needs to do a bit more work. Specifically, Server 1 can pursue the same strategy it used before:",
      "ja": "このアサーションに応答して、サーバー1はサーバー2が本当にc.exampleであることを証明する必要があります。サーバー2によって提示された証明書がc.exampleに対しても有効である場合、それ以上のアクションは必要ありません。ただし、そうでない場合、サーバー1はもう少し作業を行う必要があります。具体的には、サーバー1は以前に使用したのと同じ戦略を実行できます。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 resolves via DNS the service _xmpp-server._tcp.c.example.",
      "ja": "1. サーバー1は、DNS経由でサービス_xmpp-server._tcp.c.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 1 opens a TCP connection to the resolved IP address (which might be the same IP address as for b.example).",
      "ja": "2. サーバー1は、解決されたIPアドレス（b.exampleと同じIPアドレスである場合があります）へのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. Server 1 sends an initial stream header to Server 2, asserting that it is a.example:",
      "ja": "3. サーバー1は初期ストリームヘッダーをサーバー2に送信し、それがa.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='c.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends a response stream header to Server 1, asserting that it is c.example:",
      "ja": "4. サーバー2はサーバー1に応答ストリームヘッダーを送信し、それがc.exampleであることを表明します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='c.example' to='a.example'>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "5. The servers attempt TLS negotiation, during which Server 2 (acting as a TLS server) presents a PKIX certificate proving that it is c.example.",
      "ja": "5. サーバーはTLSネゴシエーションを試行し、その間にサーバー2（TLSサーバーとして機能）はそれがc.exampleであることを証明するPKIX証明書を提示します。"
    },
    {
      "indent": 3,
      "text": "6. At this point, Server 1 needs to establish that, despite different certificates, c.example is associated with the origin of the request. This is done using Server Dialback [XEP-0220]:",
      "ja": "6. この時点で、サーバー1は、証明書が異なっていても、c.exampleが要求の発信元に関連付けられていることを確認する必要があります。これはサーバーダイヤルバック[XEP-0220]を使用して行われます。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='a.example' to='c.example'\n           id='...'>some-dialback-key</db:verify>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "7. Server 2 responds to this:",
      "ja": "7. サーバー2はこれに応答します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='c.example' to='a.example' id='...' type='valid/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "allowing Server 1 to establish the domain name association.",
      "ja": "サーバー1がドメイン名の関連付けを確立できるようにします。"
    },
    {
      "indent": 3,
      "text": "Now that Server 1 accepts the domain name association, it informs Server 2 of that fact:",
      "ja": "サーバー1がドメイン名の関連付けを受け入れると、サーバー2にその事実が通知されます。"
    },
    {
      "indent": 7,
      "text": "<db:result from='a.example' to='c.example' type='valid'/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parties can then terminate the second connection, because it was used only for Server 1 to associate a stream with the domain name c.example (the dialback key links the original stream to the new association).",
      "ja": "2番目の接続は、サーバー1がストリームをドメイン名c.exampleに関連付けるためにのみ使用されたので、当事者は2番目の接続を終了できます（ダイヤルバックキーは元のストリームを新しい関連付けにリンクします）。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Supposition",
      "section_title": true,
      "ja": "4.4.2. 仮定"
    },
    {
      "indent": 3,
      "text": "Piggybacking can also occur in the other direction. Consider the common scenario in which Server 1 provides XMPP services not only for a.example but also for a sub-domain such as a Multi-User Chat [XEP-0045] service at rooms.a.example. If a user from c.example at Server 2 wishes to join a room on the groupchat service, Server 2 needs to send XMPP stanzas from the domain c.example to the domain rooms.a.example rather than a.example.",
      "ja": "ピギーバッキングは逆方向にも発生する可能性があります。サーバー1がa.exampleだけでなく、rooms.a.exampleのマルチユーザーチャット[XEP-0045]サービスなどのサブドメインにもXMPPサービスを提供する一般的なシナリオを考えてみます。サーバー2のc.exampleのユーザーがgroupchatサービスのルームに参加したい場合、サーバー2はXMPPスタンザをドメインc.exampleからa.exampleではなくドメインのrooms.a.exampleに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "First, Server 2 needs to determine whether it can piggyback the domain rooms.a.example on the connection to a.example:",
      "ja": "まず、サーバー2は、a.exampleへの接続でドメインrooms.a.exampleを便乗できるかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Server 2 resolves via DNS the service _xmpp-server._tcp.rooms.a.example.",
      "ja": "1. サーバー2はDNSを介してサービス_xmpp-server._tcp.rooms.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 2 determines that this resolves to an IP address and port to which it is already connected.",
      "ja": "2. サーバー2は、これが、既に接続されているIPアドレスとポートに解決されると判断します。"
    },
    {
      "indent": 3,
      "text": "3. Server 2 determines that the PKIX certificate for that active connection would also be valid for the rooms.a.example domain and that Server 1 has announced support for dialback errors.",
      "ja": "3. サーバー2は、そのアクティブな接続のPKIX証明書がrooms.a.exampleドメインでも有効であり、サーバー1がダイヤルバックエラーのサポートを発表していると判断します。"
    },
    {
      "indent": 3,
      "text": "Server 2 sends a dialback key to Server 1 over the existing connection:",
      "ja": "サーバー2は、既存の接続を介してダイヤルバックキーをサーバー1に送信します。"
    },
    {
      "indent": 7,
      "text": "<db:result from='c.example' to='rooms.a.example'>\n  some-dialback-key\n</db:result>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Server 1 then informs Server 2 that it accepts the domain name association:",
      "ja": "次に、サーバー1はサーバー2に、ドメイン名の関連付けを受け入れることを通知します。"
    },
    {
      "indent": 7,
      "text": "<db:result from='rooms.a.example' to='c.example' type='valid'/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Alternative Prooftypes",
      "section_title": true,
      "ja": "5. 代替の証明タイプ"
    },
    {
      "indent": 3,
      "text": "The foregoing protocol flows assumed that domain name associations were proved using the PKIX prooftype. However, sometimes XMPP server administrators are unable or unwilling to obtain valid PKIX certificates for all of the domains they host at their servers. For example:",
      "ja": "前述のプロトコルフローは、ドメイン名の関連付けがPKIX prooftypeを使用して証明されていることを前提としています。ただし、XMPPサーバー管理者は、サーバーでホストするすべてのドメインの有効なPKIX証明書を取得できない、または取得したくない場合があります。例えば："
    },
    {
      "indent": 3,
      "text": "o In order to issue a PKIX certificate, a CA might try to send email messages to authoritative mailbox names [RFC2142], but the administrator of a subsidiary service such as im.cs.podunk.example cannot receive email sent to hostmaster@podunk.example.",
      "ja": "o PKIX証明書を発行するために、CAは権限のあるメールボックス名[RFC2142]に電子メールメッセージを送信しようとする場合がありますが、im.cs.podunk.exampleなどの補助サービスの管理者はhostmaster@podunk.exampleに送信された電子メールを受信できません。"
    },
    {
      "indent": 3,
      "text": "o A hosting provider such as hosting.example.net might not want to take on the liability of holding the certificate and private key for a tenant such as example.com (or the tenant might not want the hosting provider to hold its certificate and private key).",
      "ja": "o hosting.example.netなどのホスティングプロバイダーは、example.comなどのテナントの証明書と秘密キーを保持する責任を負わない場合があります（または、テナントがホスティングプロバイダーに証明書と秘密キーを保持することを望まない場合があります） ）。"
    },
    {
      "indent": 3,
      "text": "o Even if PKIX certificates for each tenant can be obtained, the management of so many certificates can introduce a large administrative load.",
      "ja": "o 各テナントのPKIX証明書を取得できたとしても、非常に多くの証明書を管理すると、大きな管理負荷が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "(Additional discussion can be found in [RFC7711].)",
      "ja": "（追加の議論は[RFC7711]で見つけることができます。）"
    },
    {
      "indent": 3,
      "text": "In these circumstances, prooftypes other than PKIX are desirable or necessary. As described below, two alternatives have been defined so far: DNS-Based Authentication of Named Entities (DANE) and PKIX over Secure HTTP (POSH).",
      "ja": "これらの状況では、PKIX以外のプルーフタイプが望ましいまたは必要です。以下で説明するように、これまでに2つの選択肢が定義されています。名前付きエンティティのDNSベースの認証（DANE）とPKIX over Secure HTTP（POSH）です。"
    },
    {
      "indent": 0,
      "text": "5.1. DANE",
      "section_title": true,
      "ja": "5.1. データ"
    },
    {
      "indent": 3,
      "text": "The DANE prooftype is defined as follows:",
      "ja": "DANE prooftypeは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "1. The server's proof consists of either a service certificate or domain-issued certificate (TLSA usage PKIX-EE or DANE-EE; see [RFC6698] and [RFC7218]).",
      "ja": "1. サーバーの証明は、サービス証明書またはドメイン発行の証明書で構成されます（TLSA使用法PKIX-EEまたはDANE-EE。[RFC6698]および[RFC7218]を参照）。"
    },
    {
      "indent": 3,
      "text": "2. The proof is checked by verifying an exact match or a hash of either the SubjectPublicKeyInfo or the full certificate.",
      "ja": "2. 証明は、SubjectPublicKeyInfoまたは完全な証明書のいずれかの完全一致またはハッシュを検証することによってチェックされます。"
    },
    {
      "indent": 3,
      "text": "3. The client's verification material is obtained via secure DNS [RFC4033] as described in [RFC7673].",
      "ja": "3. [RFC7673]で説明されているように、クライアントの検証資料はセキュアDNS [RFC4033]を介して取得されます。"
    },
    {
      "indent": 3,
      "text": "4. Secure DNS is necessary in order to effectively establish an alternative chain of trust from the service certificate or domain-issued certificate to the DNS root.",
      "ja": "4. セキュアDNSは、サービス証明書またはドメイン発行の証明書からDNSルートへの代替の信頼チェーンを効果的に確立するために必要です。"
    },
    {
      "indent": 3,
      "text": "The DANE prooftype makes use of DNS-Based Authentication of Named Entities [RFC6698], specifically the use of DANE with DNS SRV records [RFC7673]. For XMPP purposes, the following rules apply:",
      "ja": "DANE prooftypeは、名前付きエンティティのDNSベースの認証[RFC6698]、特にDNS SRVレコードでのDANEの使用[RFC7673]を利用します。 XMPPの目的で、次のルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "o If there is no SRV resource record, pursue the fallback methods described in [RFC6120].",
      "ja": "o SRVリソースレコードがない場合は、[RFC6120]で説明されているフォールバックメソッドを実行してください。"
    },
    {
      "indent": 3,
      "text": "o Use the 'to' address of the initial stream header to determine the domain name of the TLS client's reference identifier (because the use of the Server Name Indication extension (TLS SNI) [RFC6066] is purely discretionary in XMPP, as mentioned in [RFC6120]).",
      "ja": "o [RFC6120]で説明されているように、XMPPではサーバー名表示拡張（TLS SNI）[RFC6066]の使用は完全に自由裁量であるため、初期ストリームヘッダーの「to」アドレスを使用してTLSクライアントの参照識別子のドメイン名を決定します。 ]）。"
    },
    {
      "indent": 0,
      "text": "5.2. POSH",
      "section_title": true,
      "ja": "5.2. ポッシュ"
    },
    {
      "indent": 3,
      "text": "The POSH prooftype is defined as follows:",
      "ja": "POSH prooftypeは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "1. The server's proof consists of a PKIX certificate.",
      "ja": "1. サーバーの証明はPKIX証明書で構成されます。"
    },
    {
      "indent": 3,
      "text": "2. The proof is checked according to the rules from [RFC6120] and [RFC6125].",
      "ja": "2. 証明は、[RFC6120]と[RFC6125]の規則に従ってチェックされます。"
    },
    {
      "indent": 3,
      "text": "3. The client's verification material is obtained by retrieving a hash of the PKIX certificate over HTTPS at a well-known URI [RFC5785].",
      "ja": "3. クライアントの検証資料は、よく知られているURI [RFC5785]でHTTPSを介してPKIX証明書のハッシュを取得することによって取得されます。"
    },
    {
      "indent": 3,
      "text": "4. Secure DNS is not necessary, because the HTTPS retrieval mechanism relies on the chain of trust from the public key infrastructure.",
      "ja": "4. HTTPS取得メカニズムは公開鍵インフラストラクチャからの信頼チェーンに依存しているため、安全なDNSは必要ありません。"
    },
    {
      "indent": 3,
      "text": "POSH is defined in [RFC7711]. For XMPP purposes, the following rules apply:",
      "ja": "POSHは[RFC7711]で定義されています。 XMPPの目的で、次のルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "o If no verification material is found via POSH, pursue the fallback methods described in [RFC6120].",
      "ja": "o POSHを介して検証資料が見つからない場合は、[RFC6120]で説明されているフォールバック方法を実行してください。"
    },
    {
      "indent": 3,
      "text": "o Use the 'to' address of the initial stream header to determine the domain name of the TLS client's reference identifier (because the use of TLS SNI [RFC6066] is purely discretionary in XMPP, as mentioned in [RFC6120]).",
      "ja": "o 初期ストリームヘッダーの「to」アドレスを使用して、TLSクライアントの参照識別子のドメイン名を決定します（TLS SNI [RFC6066]の使用は、[RFC6120]で述べられているように、XMPPでは完全に裁量的であるため）。"
    },
    {
      "indent": 3,
      "text": "The well-known URIs [RFC5785] to be used for POSH are:",
      "ja": "POSHに使用される既知のURI [RFC5785]は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o \"/.well-known/posh/xmpp-client.json\" for client-to-server connections",
      "ja": "o \"/.well-known/posh/xmpp-client.json\"（クライアントからサーバーへの接続用）"
    },
    {
      "indent": 3,
      "text": "o \"/.well-known/posh/xmpp-server.json\" for server-to-server connections",
      "ja": "o サーバー間接続の場合は「/.well-known/posh/xmpp-server.json」"
    },
    {
      "indent": 0,
      "text": "6. Secure Delegation and Multi-Tenancy",
      "section_title": true,
      "ja": "6. 安全な委任とマルチテナンシー"
    },
    {
      "indent": 3,
      "text": "One common method for deploying XMPP services is multi-tenancy: e.g., XMPP services for the service domain name example.com are actually hosted at the target server hosting.example.net. Such an arrangement is relatively convenient in XMPP given the use of DNS SRV records [RFC2782], such as the following delegation from example.com to hosting.example.net:",
      "ja": "XMPPサービスをデプロイする一般的な方法の1つはマルチテナンシーです。たとえば、サービスドメイン名example.comのXMPPサービスは実際にはターゲットサーバーhosting.example.netでホストされています。このような配置は、example.comからhosting.example.netへの次の委任など、DNS SRVレコード[RFC2782]を使用する場合、XMPPでは比較的便利です。"
    },
    {
      "indent": 3,
      "text": "_xmpp-server._tcp.example.com. 0 IN SRV 0 0 5269 hosting.example.net",
      "ja": "_xmpp-server._tcp.example.com。 0 IN SRV 0 0 5269 hosting.example.net"
    },
    {
      "indent": 3,
      "text": "Secure connections with multi-tenancy can work using the PKIX prooftype on a small scale if the provider itself wishes to host several domains (e.g., related domains such as jabber-de.example and jabber-ch.example). However, in practice the security of multi-tenancy has been found to be unwieldy when the provider hosts large numbers of XMPP services on behalf of multiple tenants (see [RFC7711] for a detailed description). There are two possible results: either (1) server-to-server communications to example.com are unencrypted or (2) the communications are TLS-encrypted but the certificates are not checked (which is functionally equivalent to a connection using an anonymous key exchange). This is also true of client-to-server communications, forcing end users to override certificate warnings or configure their clients to accept or \"pin\" certificates for hosting.example.net instead of example.com. The fundamental problem here is that if DNSSEC is not used, then the act of delegation via DNS SRV records is inherently insecure.",
      "ja": "プロバイダー自体が複数のドメイン（jabber-de.exampleやjabber-ch.exampleなどの関連ドメイン）をホストしたい場合は、マルチテナンシーの安全な接続でPKIX prooftypeを使用すると小規模で機能します。ただし、実際には、プロバイダーが複数のテナントに代わって多数のXMPPサービスをホストする場合、マルチテナントのセキュリティは扱いにくいことが判明しています（詳細については、[RFC7711]を参照してください）。次の2つの結果が考えられます。（1）example.comへのサーバー間通信は暗号化されていない、または（2）通信はTLS暗号化されているが、証明書はチェックされない（匿名キーを使用した接続と機能的に同等）両替）。これはクライアントからサーバーへの通信にも当てはまり、エンドユーザーは証明書の警告を上書きするか、example.comの代わりにhosting.example.netの証明書を受け入れるか「固定」するようにクライアントを構成する必要があります。ここでの根本的な問題は、DNSSECが使用されない場合、DNS SRVレコードを介した委任の行為は本質的に安全ではないということです。"
    },
    {
      "indent": 3,
      "text": "The specification for the use of SRV records with DANE [RFC7673] explains how to use DNSSEC for secure delegation with the DANE prooftype, and the POSH specification [RFC7711] explains how to use HTTPS redirects for secure delegation with the POSH prooftype.",
      "ja": "DANEでのSRVレコードの使用に関する仕様[RFC7673]では、DNSSECを使用してDANE prooftypeによる安全な委任を行う方法を説明し、POSH仕様[RFC7711]では、HTTPSリダイレクトを使用してPOSH prooftypeによる安全な委任について説明します。"
    },
    {
      "indent": 0,
      "text": "7. Prooftype Model",
      "section_title": true,
      "ja": "7. 証明型モデル"
    },
    {
      "indent": 3,
      "text": "In general, a Domain Name Association (DNA) prooftype conforms to the following definition:",
      "ja": "一般に、ドメイン名関連付け（DNA）のプルーフタイプは、次の定義に準拠しています。"
    },
    {
      "indent": 3,
      "text": "prooftype: A mechanism for proving an association between a domain name and an XML stream, where the mechanism defines (1) the nature of the server's proof, (2) the matching rules for comparing the client's verification material against the server's proof, (3) how the client obtains its verification material, and (4) whether or not the mechanism depends on secure DNS.",
      "ja": "prooftype：ドメイン名とXMLストリーム間の関連付けを証明するためのメカニズム。このメカニズムでは、（1）サーバーの証明の性質、（2）クライアントの検証資料をサーバーの証明と比較するための一致ルール、（3）を定義します。 ）クライアントが検証資料を取得する方法、および（4）メカニズムがセキュアDNSに依存しているかどうか。"
    },
    {
      "indent": 0,
      "text": " The PKIX, DANE, and POSH prooftypes adhere to this model. (Some prooftypes depend on, or are enhanced by, secure DNS [RFC4033] and thus also need to describe how they ensure secure delegation.) Other prooftypes are possible; examples might include TLS with Pretty Good Privacy (PGP) keys [RFC6091], a token mechanism such as Kerberos [RFC4120] or OAuth [RFC6749], and Server Dialback keys [XEP-0220].",
      "ja": "PKIX、DANE、およびPOSHプルーフタイプは、このモデルに準拠しています。 （一部のプルーフタイプは、セキュアDNS [RFC4033]に依存するか、それによって拡張されるため、セキュアな委任を保証する方法を説明する必要もあります。）他のプルーフタイプも可能です。例としては、Pretty Good Privacy（PGP）キーを使用したTLS [RFC6091]、Kerberos [RFC4120]またはOAuth [RFC6749]などのトークンメカニズム、サーバーダイヤルバックキー[XEP-0220]などがあります。"
    },
    {
      "indent": 3,
      "text": "Although the PKIX prooftype reuses the syntax of the XMPP Server Dialback protocol [XEP-0220] for signaling between servers, this framework document does not define how the generation and validation of Server Dialback keys (also specified in [XEP-0220]) constitute a DNA prooftype. However, nothing in this document prevents the continued use of Server Dialback for signaling, and a future specification (or an updated version of [XEP-0220]) might define a DNA prooftype for Server Dialback keys in a way that is consistent with this framework.",
      "ja": "PKIX prooftypeは、サーバー間のシグナリングにXMPPサーバーダイヤルバックプロトコル[XEP-0220]の構文を再利用しますが、このフレームワークドキュメントでは、サーバーダイヤルバックキー（[XEP-0220]でも指定）の生成と検証がDNAプルーフタイプ。ただし、このドキュメントでは、シグナリング用のサーバーダイヤルバックの継続的な使用を妨げるものはなく、将来の仕様（または[XEP-0220]の更新バージョン）は、このフレームワークと一貫した方法でサーバーダイヤルバックキーのDNA証明タイプを定義する可能性があります。"
    },
    {
      "indent": 0,
      "text": "8. Guidance for Server Operators",
      "section_title": true,
      "ja": "8. サーバーオペレーター向けガイダンス"
    },
    {
      "indent": 3,
      "text": "This document introduces the concept of a prooftype in order to explain and generalize the approach to establishing a strong association between the DNS domain name of an XMPP service and the XML stream that a client or peer server initiates with that service.",
      "ja": "このドキュメントでは、XMPPサービスのDNSドメイン名と、クライアントまたはピアサーバーがそのサービスで開始するXMLストリームとの間に強い関連付けを確立する方法を説明および一般化するために、プルーフタイプの概念を紹介します。"
    },
    {
      "indent": 3,
      "text": "The operations and management implications of DNA prooftypes will depend on the particular prooftypes that an operator supports. For example:",
      "ja": "DNAプルーフタイプの運用と管理への影響は、オペレーターがサポートする特定のプルーフタイプに依存します。例えば："
    },
    {
      "indent": 3,
      "text": "o To support the PKIX prooftype [RFC6120], an operator needs to obtain certificates for the XMPP server from a Certification Authority (CA). However, DNS Security is not required.",
      "ja": "o PKIX prooftype [RFC6120]をサポートするには、オペレーターは認証局（CA）からXMPPサーバーの証明書を取得する必要があります。ただし、DNSセキュリティは必須ではありません。"
    },
    {
      "indent": 3,
      "text": "o To support the DANE prooftype [RFC7673], an operator can generate its own certificates for the XMPP server or obtain them from a CA. In addition, DNS Security is required.",
      "ja": "o DANE prooftype [RFC7673]をサポートするために、オペレーターはXMPPサーバー用に独自の証明書を生成するか、CAから取得できます。さらに、DNSセキュリティが必要です。"
    },
    {
      "indent": 3,
      "text": "o To support the POSH prooftype [RFC7711], an operator can generate its own certificates for the XMPP server or obtain them from a CA, but in addition needs to deploy the web server for POSH files with certificates obtained from a CA. However, DNS Security is not required.",
      "ja": "o POSH prooftype [RFC7711]をサポートするために、オペレーターはXMPPサーバー用に独自の証明書を生成するか、CAから取得できますが、さらに、CAから取得した証明書を含むPOSHファイル用のWebサーバーを展開する必要があります。ただし、DNSセキュリティは必須ではありません。"
    },
    {
      "indent": 3,
      "text": "Considerations for the use of the foregoing prooftypes are explained in the relevant specifications. See in particular Section 13.7 of [RFC6120], Section 6 of [RFC7673], and Section 7 of [RFC7711].",
      "ja": "前述のプルーフタイプの使用に関する考慮事項は、関連する仕様で説明されています。特に、[RFC6120]のセクション13.7、[RFC7673]のセクション6、および[RFC7711]のセクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": " Naturally, these operations and management considerations are additive: if an operator wishes to use multiple prooftypes, the complexity of deployment increases (e.g., the operator might want to obtain a PKIX certificate from a CA for use in the PKIX prooftype and generate its own certificate for use in the DANE prooftype). This is an unavoidable aspect of supporting as many prooftypes as needed in order to ensure that domain name associations can be established in the largest possible percentage of cases.",
      "ja": "当然、これらの操作と管理の考慮事項は付加的です：オペレーターが複数のプルーフタイプを使用したい場合、展開の複雑さが増加します（例えば、オペレーターは、PKIXプルーフタイプで使用するためにCAからPKIX証明書を取得し、独自の証明書を生成したい場合があります。 DANEプルーフタイプで使用するため）。これは、ドメイン名の関連付けを可能な限り最大の割合で確立できるようにするために、必要な数のプルーフタイプをサポートすることの避けられない側面です。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The POSH specification [RFC7711] establishes the \"POSH Service Names\" registry for use in well-known URIs [RFC5785]. This specification registers two such service names for use in XMPP: \"xmpp-client\" and \"xmpp-server\". The completed registration templates follow.",
      "ja": "POSH仕様[RFC7711]は、既知のURI [RFC5785]で使用するための「POSHサービス名」レジストリを確立します。この仕様は、XMPPで使用する2つのサービス名「xmpp-client」と「xmpp-server」を登録しています。完成した登録テンプレートは次のとおりです。"
    },
    {
      "indent": 0,
      "text": "9.1. POSH Service Name for xmpp-client Service",
      "section_title": true,
      "ja": "9.1. xmpp-clientサービスのPOSHサービス名"
    },
    {
      "indent": 3,
      "text": "Service name: xmpp-client",
      "ja": "サービス名：xmpp-client"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "コントローラの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Definition and usage: Specifies the location of a POSH file containing verification material or a reference thereto that enables a client to verify the identity of a server for a client-to-server stream in XMPP",
      "ja": "定義と使用法：クライアントがXMPPのクライアントからサーバーへのストリームのサーバーのIDを確認できるようにする検証資料またはその参照を含むPOSHファイルの場所を指定します"
    },
    {
      "indent": 3,
      "text": "Specification: RFC 7712 (this document)",
      "ja": "仕様：RFC 7712（このドキュメント）"
    },
    {
      "indent": 0,
      "text": "9.2. POSH Service Name for xmpp-server Service",
      "section_title": true,
      "ja": "9.2. xmpp-serverサービスのPOSHサービス名"
    },
    {
      "indent": 3,
      "text": "Service name: xmpp-server",
      "ja": "サービス名：xmpp-server"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "コントローラの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Definition and usage: Specifies the location of a POSH file containing verification material or a reference thereto that enables a server to verify the identity of a peer server for a server-to-server stream in XMPP",
      "ja": "定義と使用法：サーバーがXMPPのサーバー間ストリームのピアサーバーのIDを確認できるようにする検証資料またはその参照を含むPOSHファイルの場所を指定します"
    },
    {
      "indent": 3,
      "text": "Specification: RFC 7712 (this document)",
      "ja": "仕様：RFC 7712（このドキュメント）"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "With regard to the PKIX prooftype, this document supplements but does not supersede the security considerations of [RFC6120] and [RFC6125].",
      "ja": "PKIX prooftypeに関しては、このドキュメントは[RFC6120]と[RFC6125]のセキュリティの考慮事項を補足しますが、それに取って代わりません。"
    },
    {
      "indent": 3,
      "text": "With regard to the DANE and POSH prooftypes, the reader is referred to [RFC7673] and [RFC7711], respectively.",
      "ja": "DANEおよびPOSHプルーフタイプに関しては、読者はそれぞれ[RFC7673]および[RFC7711]を参照します。"
    },
    {
      "indent": 3,
      "text": "Any future prooftypes need to thoroughly describe how they conform to the prooftype model specified in Section 7 of this document.",
      "ja": "今後のプルーフタイプは、このドキュメントのセクション7で指定されたプルーフタイプモデルにどのように準拠するかを完全に説明する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987, <http://www.rfc-editor.org/info/rfc1034>.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、DOI 10.17487 / RFC1034、1987年11月、<http://www.rfc-editor.org/info/rfc1034>。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <http://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名-実装および仕様」、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、<http://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, DOI 10.17487/RFC2782, February 2000, <http://www.rfc-editor.org/info/rfc2782>.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<http：// www.rfc-editor.org/info/rfc2782>。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, DOI 10.17487/RFC4033, March 2005, <http://www.rfc-editor.org/info/rfc4033>.",
      "ja": "[RFC4033] Arends、R.、Austein、R.、Larson、M.、Massey、D。、およびS. Rose、「DNSセキュリティの概要と要件」、RFC 4033、DOI 10.17487 / RFC4033、2005年3月、<http： //www.rfc-editor.org/info/rfc4033>。"
    },
    {
      "indent": 3,
      "text": "[RFC4422] Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple Authentication and Security Layer (SASL)\", RFC 4422, DOI 10.17487/RFC4422, June 2006, <http://www.rfc-editor.org/info/rfc4422>.",
      "ja": "[RFC4422] Melnikov、A.、Ed。およびK. Zeilenga、Ed。、 \"Simple Authentication and Security Layer（SASL）\"、RFC 4422、DOI 10.17487 / RFC4422、June 2006、<http：//www.rfc- editor.org/info/rfc4422>。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, DOI 10.17487/RFC5785, April 2010, <http://www.rfc-editor.org/info/rfc5785>.",
      "ja": "[RFC5785]ノッティンガム、M。およびE.ハマーラハブ、「Defining Well-Known Uniform Resource Identifiers（URIs）」、RFC 5785、DOI 10.17487 / RFC5785、2010年4月、<http://www.rfc-editor.org / info / rfc5785>。"
    },
    {
      "indent": 3,
      "text": "[RFC6120] Saint-Andre, P., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 6120, DOI 10.17487/RFC6120, March 2011, <http://www.rfc-editor.org/info/rfc6120>.",
      "ja": "[RFC6120] Saint-Andre、P。、「Extensible Messaging and Presence Protocol（XMPP）：Core」、RFC 6120、DOI 10.17487 / RFC6120、2011年3月、<http://www.rfc-editor.org/info/rfc6120 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<http://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, DOI 10.17487/RFC6698, August 2012, <http://www.rfc-editor.org/info/rfc6698>.",
      "ja": "[RFC6698] Hoffman、P。およびJ. Schlyter、「DNSベースの名前付きエンティティ（DANE）トランスポート層セキュリティ（TLS）プロトコルの認証：TLSA」、RFC 6698、DOI 10.17487 / RFC6698、2012年8月、<http：/ /www.rfc-editor.org/info/rfc6698>。"
    },
    {
      "indent": 3,
      "text": "[RFC7218] Gudmundsson, O., \"Adding Acronyms to Simplify Conversations about DNS-Based Authentication of Named Entities (DANE)\", RFC 7218, DOI 10.17487/RFC7218, April 2014, <http://www.rfc-editor.org/info/rfc7218>.",
      "ja": "[RFC7218] Gudmundsson、O。、「名前付きエンティティのDNSベースの認証（DANE）に関する会話を簡素化するための頭字語の追加」、RFC 7218、DOI 10.17487 / RFC7218、2014年4月、<http://www.rfc-editor.org / info / rfc7218>。"
    },
    {
      "indent": 3,
      "text": "[RFC7673] Finch, T., Miller, M., and P. Saint-Andre, \"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records\", RFC 7673, DOI 10.17487/RFC7673, October 2015, <http://www.rfc-editor.org/info/rfc7673>.",
      "ja": "[RFC7673] Finch、T.、Miller、M。、およびP. Saint-Andre、「DNSベースの名前付きエンティティの認証（DANE）TLSAレコードとSRVレコードの使用」、RFC 7673、DOI 10.17487 / RFC7673、2015年10月、 <http://www.rfc-editor.org/info/rfc7673>。"
    },
    {
      "indent": 3,
      "text": "[RFC7711] Miller, M. and P. Saint-Andre, \"PKIX over Secure HTTP (POSH)\", RFC 7711, DOI 10.17487/RFC7711, November 2015, <http://www.rfc-editor.org/info/rfc7711>.",
      "ja": "[RFC7711] Miller、M。およびP. Saint-Andre、「PKIX over Secure HTTP（POSH）」、RFC 7711、DOI 10.17487 / RFC7711、2015年11月、<http://www.rfc-editor.org/info/ rfc7711>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0220] Miller, J., Saint-Andre, P., and P. Hancke, \"Server Dialback\", XSF XEP 0220, August 2014, <http://xmpp.org/extensions/xep-0220.html>.",
      "ja": "[XEP-0220] Miller、J.、Saint-Andre、P。、およびP. Hancke、「Server Dialback」、XSF XEP 0220、2014年8月、<http://xmpp.org/extensions/xep-0220.html >。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC2142] Crocker, D., \"Mailbox Names for Common Services, Roles and Functions\", RFC 2142, DOI 10.17487/RFC2142, May 1997, <http://www.rfc-editor.org/info/rfc2142>.",
      "ja": "[RFC2142] Crocker、D。、「Common Services、Roles and Functionsのメールボックス名」、RFC 2142、DOI 10.17487 / RFC2142、1997年5月、<http://www.rfc-editor.org/info/rfc2142>。"
    },
    {
      "indent": 3,
      "text": "[RFC3920] Saint-Andre, P., Ed., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 3920, DOI 10.17487/RFC3920, October 2004, <http://www.rfc-editor.org/info/rfc3920>.",
      "ja": "[RFC3920] Saint-Andre、P。、編、「Extensible Messaging and Presence Protocol（XMPP）：Core」、RFC 3920、DOI 10.17487 / RFC3920、2004年10月、<http://www.rfc-editor.org/ info / rfc3920>。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, DOI 10.17487/RFC4120, July 2005, <http://www.rfc-editor.org/info/rfc4120>.",
      "ja": "[RFC4120] Neuman、C.、Yu、T.、Hartman、S。、およびK. Raeburn、「The Kerberos Network Authentication Service（V5）」、RFC 4120、DOI 10.17487 / RFC4120、2005年7月、<http：// www.rfc-editor.org/info/rfc4120>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication\", RFC 6091, DOI 10.17487/RFC6091, February 2011, <http://www.rfc-editor.org/info/rfc6091>.",
      "ja": "[RFC6091] Mavrogiannopoulos、N。およびD. Gillmor、「OpenPGP Keys for Transport Layer Security（TLS）Authentication」、RFC 6091、DOI 10.17487 / RFC6091、2011年2月、<http://www.rfc-editor.org/ info / rfc6091>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <http://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D。、編、「The OAuth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<http://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC7590] Saint-Andre, P. and T. Alkemade, \"Use of Transport Layer Security (TLS) in the Extensible Messaging and Presence Protocol (XMPP)\", RFC 7590, DOI 10.17487/RFC7590, June 2015, <http://www.rfc-editor.org/info/rfc7590>.",
      "ja": "[RFC7590] Saint-Andre、P。およびT. Alkemade、「Extensible Messaging and Presence Protocol（XMPP）でのトランスポート層セキュリティ（TLS）の使用」、RFC 7590、DOI 10.17487 / RFC7590、2015年6月、<http：/ /www.rfc-editor.org/info/rfc7590>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0045] Saint-Andre, P., \"Multi-User Chat\", XSF XEP 0045, February 2012, <http://xmpp.org/extensions/xep-0045.html>.",
      "ja": "[XEP-0045] Saint-Andre、P。、「マルチユーザーチャット」、XSF XEP 0045、2012年2月、<http://xmpp.org/extensions/xep-0045.html>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0288] Hancke, P. and D. Cridland, \"Bidirectional Server-to-Server Connections\", XSF XEP 0288, September 2013, <http://xmpp.org/extensions/xep-0288.html>.",
      "ja": "[XEP-0288] Hancke、P。およびD. Cridland、「双方向サーバー間接続」、XSF XEP 0288、2013年9月、<http://xmpp.org/extensions/xep-0288.html>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0344] Hancke, P. and D. Cridland, \"Impact of TLS and DNSSEC on Dialback\", XSF XEP 0344, March 2015, <http://xmpp.org/extensions/xep-0344.html>.",
      "ja": "[XEP-0344] Hancke、P。およびD.クリドランド、「ダイヤルバックに対するTLSおよびDNSSECの影響」、XSF XEP 0344、2015年3月、<http://xmpp.org/extensions/xep-0344.html>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Richard Barnes, Stephen Farrell, and Jonas Lindberg contributed as co-authors to earlier draft versions of this document.",
      "ja": "Richard Barnes、Stephen Farrell、およびJonas Lindbergは、このドキュメントの以前のドラフトバージョンの共著者として貢献しました。"
    },
    {
      "indent": 3,
      "text": "Derek Atkins, Mahesh Jethanandani, and Dan Romascanu reviewed the document on behalf of the Security Directorate, the Operations and Management Directorate, and the General Area Review Team, respectively.",
      "ja": "Derek Atkins、Mahesh Jethanandani、およびDan Romascanuは、それぞれセキュリティ総局、運用および管理総局、および一般地域レビューチームに代わってドキュメントをレビューしました。"
    },
    {
      "indent": 3,
      "text": "During IESG review, Stephen Farrell and Barry Leiba provided helpful input that led to improvements in the specification.",
      "ja": "IESGのレビュー中に、Stephen FarrellとBarry Leibaは、仕様の改善につながる有益な情報を提供しました。"
    },
    {
      "indent": 3,
      "text": "Thanks to Dave Cridland as document shepherd, Joe Hildebrand as working group chair, and Ben Campbell as area director.",
      "ja": "ドキュメントシェパードとしてのDave Cridland、ワーキンググループチェアとしてのJoe Hildebrand、およびエリアディレクターとしてのBen Campbellに感謝します。"
    },
    {
      "indent": 3,
      "text": "Peter Saint-Andre wishes to acknowledge Cisco Systems, Inc., for employing him during his work on earlier draft versions of this document.",
      "ja": "Peter Saint-Andreは、このドキュメントの以前のドラフトバージョンでの作業中に彼を採用したCisco Systems、Inc.を認めたいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Peter Saint-Andre &yet",
      "ja": "ピーターサンタンドレ＆まだ"
    },
    {
      "indent": 3,
      "text": "Email: peter@andyet.com\nURI:   https://andyet.com/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Matthew Miller Cisco Systems, Inc. 1899 Wynkoop Street, Suite 600 Denver, CO 80202 United States",
      "ja": "Matthew Miller Cisco Systems、Inc. 1899 Wynkoop Street、Suite 600 Denver、CO 80202 United States"
    },
    {
      "indent": 3,
      "text": "Email: mamille2@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Philipp Hancke &yet",
      "ja": "フィリップ・ハンケ＆まだ"
    },
    {
      "indent": 3,
      "text": "Email: fippo@andyet.com\nURI:   https://andyet.com/",
      "raw": true,
      "ja": ""
    }
  ]
}