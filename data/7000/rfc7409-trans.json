{
  "title": {
    "text": "RFC 7409 - Forwarding and Control Element Separation (ForCES) Packet Parallelization",
    "ja": "RFC 7409 - 転送および制御要素分離（ForCES）パケットの並列化"
  },
  "number": 7409,
  "created_at": "2020-08-31 20:16:24.307185+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     E. Haleplidis\nRequest for Comments: 7409                          University of Patras\nCategory: Experimental                                        J. Halpern\nISSN: 2070-1721                                                 Ericsson\n                                                           November 2014",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Forwarding and Control Element Separation (ForCES) Packet Parallelization",
      "ja": "転送および制御要素分離（ForCES）パケットの並列化"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Many network devices support parallel packet processing. This document describes how Forwarding and Control Element Separation (ForCES) can model a network device's parallelization datapath using constructs defined by the ForCES model (RFC 5812) and controlled via the ForCES protocol (RFC 5810).",
      "ja": "多くのネットワークデバイスは、並列パケット処理をサポートしています。このドキュメントでは、Forwarding and Control Element Separation（ForCES）が、ForCESモデル（RFC 5812）で定義され、ForCESプロトコル（RFC 5810）で制御される構成要素を使用して、ネットワークデバイスの並列化データパスをモデル化する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7409.",
      "ja": "このドキュメントの現在のステータス、エラッタ、フィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7409で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2014 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Packet Parallelization  . . . . . . . . . . . . . . . . . . .   5\n  2.1.  CoreParallelization LFB . . . . . . . . . . . . . . . . .   7\n  2.2.  Parallelization Metadata  . . . . . . . . . . . . . . . .  10\n3.  Parallel Base Types . . . . . . . . . . . . . . . . . . . . .  11\n  3.1.  Frame Types . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.2.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.3.  Metadata Types  . . . . . . . . . . . . . . . . . . . . .  12\n4.  Parallel LFBs . . . . . . . . . . . . . . . . . . . . . . . .  12\n  4.1.  Splitter  . . . . . . . . . . . . . . . . . . . . . . . .  12\n    4.1.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  13\n    4.1.2.  Components  . . . . . . . . . . . . . . . . . . . . .  13\n    4.1.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  13\n    4.1.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  13\n  4.2.  Merger  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n    4.2.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  14\n    4.2.2.  Components  . . . . . . . . . . . . . . . . . . . . .  15\n    4.2.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  15\n    4.2.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  16\n  4.3.  CoreParallelization . . . . . . . . . . . . . . . . . . .  16\n    4.3.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  16\n    4.3.2.  Components  . . . . . . . . . . . . . . . . . . . . .  16\n    4.3.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  16\n    4.3.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  17\n5.  XML for Parallel LFB Library  . . . . . . . . . . . . . . . .  17\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  25\n  6.1.  LFB Class Names and LFB Class Identifiers . . . . . . . .  25\n  6.2.  Metadata ID . . . . . . . . . . . . . . . . . . . . . . .  26\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  26\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  26\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  26\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  27\nAcknowledgments   . . . . . . . . . . . . . . . . . . . . . . . .  27\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  27",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A lot of network devices can process packets in a parallel manner. The Forwarding and Control Element Separation (ForCES) model [RFC5812] presents a formal way to describe the Forwarding Plane's datapath with Logical Function Blocks (LFBs) using XML. This document describes how packet parallelization can be described with the ForCES model.",
      "ja": "多くのネットワークデバイスは、並行してパケットを処理できます。 Forwarding and Control Element Separation（ForCES）モデル[RFC5812]は、XMLを使用して論理機能ブロック（LFB）で転送プレーンのデータパスを記述する正式な方法を提供します。このドキュメントでは、ForCESモデルでパケットの並列化を説明する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The modeling concept has been influenced by Cilk [Cilk]. Cilk is a programming language that has been in development since 1994 at the Massachusetts Institute of Technology (MIT) Laboratory. Cilk allows programmers to identify elements that can be executed in parallel. The two Cilk concepts used in this document are \"spawn\" and \"sync\": spawn being the place where parallel tasks can start and sync being the place where the parallel task finishes and must collect all parallel output (see Section 1.2 for the definitions of both \"task\" and \"task correclator\").",
      "ja": "モデリングのコンセプトは、Cilk [Cilk]の影響を受けています。 Cilkは、1994年からマサチューセッツ工科大学（MIT）研究所で開発されているプログラミング言語です。プログラマーはCilkを使用して、並行して実行できる要素を識別できます。このドキュメントで使用されている2つのCilkの概念は、「spawn」と「sync」です。spawnは並列タスクを開始できる場所であり、syncは並列タスクが終了し、すべての並列出力を収集する必要がある場所です（定義についてはセクション1.2を参照） 「タスク」と「タスクコリレータ」の両方）。"
    },
    {
      "indent": 3,
      "text": "This document is Experimental; thus, the LFB Class IDs will not be included in the Standard Action's values. Therefore, the LFB Class IDs must have a value larger than 65535, and the LFB names must begin with the prefix 'Ext-'. However, for brevity, when we refer to the LFB Class names in the text of this document (not the formal definitions), the 'Ext-' prefix will be omitted.",
      "ja": "このドキュメントは実験的なものです。したがって、LFBクラスIDは標準アクションの値に含まれません。したがって、LFBクラスIDは65535より大きい値を持つ必要があり、LFB名は接頭辞「Ext-」で始まる必要があります。ただし、簡潔にするために、このドキュメントのテキストでLFBクラス名（正式な定義ではない）を参照する場合、「Ext-」プレフィックスは省略されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "ja": "1.2. 定義"
    },
    {
      "indent": 3,
      "text": "This document follows the terminology defined by the ForCES model in [RFC5812]. In particular, the reader is expected to be familiar with the following terms:",
      "ja": "このドキュメントは、[RFC5812]のForCESモデルで定義された用語に従います。特に、読者は次の用語に精通している必要があります。"
    },
    {
      "indent": 6,
      "text": "FE",
      "ja": "で"
    },
    {
      "indent": 6,
      "text": "CE",
      "ja": "この"
    },
    {
      "indent": 6,
      "text": "FE Model",
      "ja": "モデルで"
    },
    {
      "indent": 6,
      "text": "LFB Class (or type)",
      "ja": "LFBクラス（またはタイプ）"
    },
    {
      "indent": 0,
      "text": " LFB Instance LFB Model",
      "ja": "LFBインスタンスLFBモデル"
    },
    {
      "indent": 6,
      "text": "Element",
      "ja": "素子"
    },
    {
      "indent": 6,
      "text": "Attribute",
      "ja": "属性"
    },
    {
      "indent": 6,
      "text": "LFB Metadata",
      "ja": "LFBメタデータ"
    },
    {
      "indent": 6,
      "text": "ForCES Component",
      "ja": "ForCESコンポーネント"
    },
    {
      "indent": 6,
      "text": "LFB Class Library",
      "ja": "LFBクラスライブラリ"
    },
    {
      "indent": 3,
      "text": "This document also introduces the following terms:",
      "ja": "このドキュメントでは、次の用語も紹介しています。"
    },
    {
      "indent": 3,
      "text": "Chunk: Pieces of a packet.",
      "ja": "チャンク：パケットの断片。"
    },
    {
      "indent": 3,
      "text": "Task: Grouping of packets or chunks belonging to the same packet that are processed in parallel.",
      "ja": "タスク：並列処理される同じパケットに属するパケットまたはチャンクのグループ化。"
    },
    {
      "indent": 3,
      "text": "Task Correlator: A 32-bit identifier that uniquely distinguishes tasks.",
      "ja": "Task Correlator：タスクを一意に区別する32ビットの識別子。"
    },
    {
      "indent": 3,
      "text": "Split Type: A parallel type where the packets are split into chunks to be processed in parallel. Each task in a split type is composed only of chunks.",
      "ja": "分割タイプ：パケットがチャンクに分割されて並列処理される並列タイプ。分割タイプの各タスクは、チャンクのみで構成されています。"
    },
    {
      "indent": 3,
      "text": "Flood Type: A parallel type where the packets are copied as-is to downstream LFBs to be processed in parallel. Each task in a flood type is composed only of packets.",
      "ja": "洪水タイプ：パケットがそのまま下流のLFBにコピーされて並列処理される並列タイプ。フラッドタイプの各タスクは、パケットのみで構成されます。"
    },
    {
      "indent": 0,
      "text": "2. Packet Parallelization",
      "section_title": true,
      "ja": "2. パケットの並列化"
    },
    {
      "indent": 3,
      "text": "This document addresses the following two types of packet parallelization:",
      "ja": "このドキュメントでは、次の2種類のパケット並列化について説明します。"
    },
    {
      "indent": 3,
      "text": "1. Flood: Where a copy of a packet is sent to multiple LFBs to be processed in parallel.",
      "ja": "1. フラッド：パケットのコピーが複数のLFBに送信され、並行して処理されます。"
    },
    {
      "indent": 3,
      "text": "2. Split: Where the packet will be split into chunks of equal size specified by the CE and sent to multiple LFB instances, probably of the same LFB class, to be processed in parallel.",
      "ja": "2. 分割：パケットがCEによって指定された同じサイズのチャンクに分割され、並列処理されるように、おそらく同じLFBクラスの複数のLFBインスタンスに送信されます。"
    },
    {
      "indent": 0,
      "text": " It must be noted that the process of copying the packet in the flood parallel type is implementation dependent and is loosely defined here. An implementer may either decide to physically copy the packet and send all packets on the parallel paths or decide to logically copy the packet by simply sending, for example, pointers to the same packet provided that the necessary interlocks are taken into account. The implementer has to take into account the device's characteristics to decide which approach fits best to the device.",
      "ja": "フラッドパラレルタイプでパケットをコピーするプロセスは実装に依存し、ここでは大まかに定義されていることに注意してください。実装者は、パケットを物理的にコピーしてすべてのパケットを並列パスに送信するか、または必要なインターロックが考慮されている場合に、たとえば同じパケットへのポインタを送信するだけでパケットを論理的にコピーするかを決定できます。実装者は、デバイスの特性を考慮して、デバイスに最適なアプローチを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the split parallel type, while harder, the implementer may also decide to logically split the packet and send, for example, pointers to parts of the packet, provided that the necessary interlocks are managed. In addition, how chunks are distributed to the LFBs (e.g., which chunk to which LFB) is implementation dependent. For example, while usually chunks are sent to the same LFB class, the number of LFB instances may not be equal to the number of chunks. It is up to the implementer to decide how these chunks will be sent, for example, in a round-robin fashion.",
      "ja": "分割並列タイプでは、より困難ですが、必要なインターロックが管理されている場合、実装者はパケットを論理的に分割して、たとえばパケットの一部へのポインターを送信することもできます。さらに、チャンクがLFBにどのように分散されるか（どのチャンクがどのLFBに割り当てられるかなど）は、実装に依存します。たとえば、通常、チャンクは同じLFBクラスに送信されますが、LFBインスタンスの数はチャンクの数と等しくない場合があります。これらのチャンクをどのように送信するかは、たとえば、ラウンドロビン方式で実装者が決定します。"
    },
    {
      "indent": 3,
      "text": "This document introduces two LFBs that are used before and after the parallelization occurs:",
      "ja": "このドキュメントでは、並列化が行われる前後に使用される2つのLFBを紹介します。"
    },
    {
      "indent": 3,
      "text": "1. Splitter: Similar to Cilk's spawn, a splitter is an LFB that will split the path of a packet that will be sent to multiple downstream LFBs to be processed in parallel.",
      "ja": "1. スプリッター：Cilkのスポーンと同様に、スプリッターは、並列に処理される複数のダウンストリームLFBに送信されるパケットのパスを分割するLFBです。"
    },
    {
      "indent": 3,
      "text": "2. Merger: Similar to Cilk's sync, a merger is an LFB that will receive packets or chunks of the same initial packet and merge them and the results into one packet.",
      "ja": "2. マージ：Cilkの同期と同様に、マージは同じ初期パケットのパケットまたはチャンクを受信し、それらと結果を1つのパケットにマージするLFBです。"
    },
    {
      "indent": 3,
      "text": "Both parallel packet distribution types can currently be achieved with the ForCES model. The Splitter LFB has one group output that produces either chunks or packets to be sent to LFBs for processing, and the Merger LFB has one group input that expects either packets or chunks to aggregate all the parallel packets or chunks and produce a single packet.",
      "ja": "現在、両方の並列パケット分散タイプは、ForCESモデルで実現できます。 Splitter LFBには、処理のためにLFBに送信されるチャンクまたはパケットを生成する1つのグループ出力があり、Merger LFBには、パケットまたはチャンクがすべての並列パケットまたはチャンクを集約して単一のパケットを生成することを期待する1つのグループ入力があります。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a simple example of a split parallel datapath along with the Splitter and Merger LFB. The example in Figure 1 depicts multiple regular expression (regex) match LFBs that perform match operations on parts of the original packet. Figure 2 shows an example of a flood parallel datapath along with the Splitter and Merger LFB. The example in Figure 2 depicts a path that will classify an IPv4 packet while also performing metering; on the other path, the IPv4 Time to Live (TTL) field will be decremented.",
      "ja": "図1は、スプリッターおよびマージャーLFBと共にスプリットパラレルデータパスの簡単な例を示しています。図1の例は、元のパケットの一部に対して一致操作を実行する複数の正規表現（regex）一致LFBを示しています。図2は、スプリッターおよびマージLFBと共にフラッドパラレルデータパスの例を示しています。図2の例は、メータリングも実行しながらIPv4パケットを分類するパスを示しています。他のパスでは、IPv4 Time to Live（TTL）フィールドは減少します。"
    },
    {
      "indent": 4,
      "text": "                  C1+M   +------------+  C1+M\n                   +---->| Regex LFB  |----+\n    +----------+   |     +------------+    |       +----------+\n    |          |---+                       +------>|          |\n P  |          |  C2+M   +------------+  C2+M      |          | P\n--->| Splitter |-------->| Regex LFB  |----------->|  Merger  |--->\n    |   LFB    |  CN+M   +------------+  CN+M      |   LFB    |\n    |          |---+                       +------>|          |\n    +----------+   |     +------------+    |       +----------+\n                   +---->| Regex LFB  |----+\n                         +------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 1: Simple Split Parallel Processing",
      "ja": "図1：単純な分割並列処理"
    },
    {
      "indent": 4,
      "text": "    +----------+    +------------+    +-------+    +----------+\n    |          |P+M | Classifier |P+M | Meter |P+M |          |\n P  |          |--->|     LFB    |--->|  LFB  |--->|          | P\n--->| Splitter |    +------------+    +-------+    |  Merger  |--->\n    |   LFB    |                                   |   LFB    |\n    |          |P+M       +------------+       P+M |          |\n    |          |--------->|  IPv4 TTL  |---------->|          |\n    +----------+          |  Decrement |           +----------+\n                          |    LFB     |\n                          +------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 2: Simple Flood Parallel Processing",
      "ja": "図2：単純なフラッド並列処理"
    },
    {
      "indent": 3,
      "text": "This version of the modeling framework does not allow for nested parallel datapath topologies. This decision was reached by the authors and the ForCES working group, as there was no strong use case or need at decision time. This led to a simpler metadata definition, which is required to be transported between the splitter and the corresponding merger. If there is a need for nested parallel datapaths, a new version of a splitter and merger will need to be defined, as well as an augmentation to the defined metadata.",
      "ja": "このバージョンのモデリングフレームワークでは、ネストされた並列データパストポロジを使用できません。この決定は、決定時に強力なユースケースまたはニーズがなかったため、著者とForCESワーキンググループによって達されました。これにより、よりシンプルなメタデータ定義が作成されました。これは、スプリッターと対応するマージャーの間で転送する必要があります。ネストされた並列データパスが必要な場合は、新しいバージョンのスプリッターとマージを定義する必要があります。また、定義されたメタデータを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. CoreParallelization LFB",
      "section_title": true,
      "ja": "2.1. CoreParallelization LFB"
    },
    {
      "indent": 3,
      "text": "One important element to a developer is the ability to define which LFBs can be used in a parallel mode, which LFBs can be parallelized with which, as well as the order in which parallel LFBs can be assembled.",
      "ja": "開発者にとって重要な要素の1つは、並列モードで使用できるLFB、並列化できるLFB、および並列LFBをアセンブルできる順序を定義する機能です。"
    },
    {
      "indent": 0,
      "text": " To access the parallelization details, we opted for defining a new LFB class: the CoreParallelization LFB. This choice was an alternative to making another change to the core FEObject LFB. The CoreParallelization exists merely to define the capabilities for an FE's LFB parallelization. A CE using the ForCES protocol [RFC5810] can check the existence of this LFB class in the FEObject's SupportedLFBs component. The existence of the CoreParallelization LFB will indicate to the CE that the specific FE supports parallelization. There MUST be only one instance of the CoreParallelization LFB per FE.",
      "ja": "並列化の詳細にアクセスするために、新しいLFBクラスであるCoreParallelization LFBを定義することにしました。この選択は、コアFEObject LFBに別の変更を加える代わりに使用されました。 CoreParallelizationは、FEのLFB並列化の機能を定義するためだけに存在します。 ForCESプロトコル[RFC5810]を使用するCEは、FEObjectのSupportedLFBsコンポーネントにこのLFBクラスが存在するかどうかを確認できます。 CoreParallelization LFBの存在は、特定のFEが並列化をサポートしていることをCEに示します。 FEごとにCoreParallelization LFBのインスタンスは1つだけ存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "The topology of the parallel datapath can be deferred and manipulated from the FEObject LFB's LFBTopology.",
      "ja": "パラレルデータパスのトポロジは、FEObject LFBのLFBTopologyから延期および操作できます。"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization requires only one capability in order to specify each LFB that can be used in a parallel mode:",
      "ja": "CoreParallelizationは、並列モードで使用できる各LFBを指定するために1つの機能のみを必要とします。"
    },
    {
      "indent": 3,
      "text": "o The Name of the LFB.",
      "ja": "o LFBの名前。"
    },
    {
      "indent": 3,
      "text": "o The Class ID of the LFB.",
      "ja": "o LFBのクラスID。"
    },
    {
      "indent": 3,
      "text": "o The Version of the LFB.",
      "ja": "o LFBのバージョン。"
    },
    {
      "indent": 3,
      "text": "o The number of instances that class can support in parallel.",
      "ja": "o クラスが並行してサポートできるインスタンスの数。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "ja": "o 並列パスのパイプラインでこのLFBクラスをたどることができるLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "ja": "o 並列パスのパイプラインでこのLFBクラスの前に存在できるLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "ja": "o このLFBクラスと並行してパケットまたはチャンクを処理できるLFBクラスのリスト。"
    },
    {
      "indent": 6,
      "text": "<!-- Datatype -->\n<dataTypeDef>\n   <name>ParallelLFBType</name>\n   <synopsis>Table entry for parallel LFBs</synopsis>\n   <struct>\n      <component componentID=\"1\">\n         <name>LFBName</name>\n         <synopsis>The name of an LFB Class</synopsis>\n         <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"2\">\n         <name>LFBClassID</name>\n         <synopsis>The id of the LFB Class</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n         <name>LFBVersion</name>\n         <synopsis>The version of the LFB Class used by this FE\n         </synopsis>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "         <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"4\">\n         <name>LFBParallelOccurrenceLimit</name>\n         <synopsis>The upper limit of instances of the same\n            parallel LFBs of this class</synopsis>\n         <optional />\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"5\">\n         <name>AllowedParallelAfters</name>\n         <synopsis>List of LFB Classes that can follow this LFB\n            in a parallel pipeline</synopsis>\n         <optional />\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n      <component componentID=\"6\">\n         <name>AllowedParallelBefores</name>\n         <synopsis>List of LFB Classes that this LFB class can\n            follow in a parallel pipeline</synopsis>\n         <optional />\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n      <component componentID=\"7\">\n         <name>AllowedParallel</name>\n         <synopsis>List of LFB Classes that this LFB class can run\n            in parallel with</synopsis>\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n   </struct>\n</dataTypeDef>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<!-- Capability -->\n      <capability componentID=\"32\">\n         <name>ParallelLFBs</name>\n         <synopsis>List of all supported parallel LFBs</synopsis>\n         <array type=\"Variable-size\">\n            <typeRef>ParallelLFBType</typeRef>\n         </array>\n      </capability>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 3: XML Definitions for CoreParallelization LFB",
      "ja": "図3：CoreParallelization LFBのXML定義"
    },
    {
      "indent": 0,
      "text": "2.2. Parallelization Metadata",
      "section_title": true,
      "ja": "2.2. 並列化メタデータ"
    },
    {
      "indent": 3,
      "text": "It is expected that the splitting and merging mechanisms are an implementation issue. This document plays the role of defining the operational parameters for the splitting and merging: namely, the size of the chunks, what happens if a packet or chunk has been marked as invalid, and whether the merge LFB should wait for all packets or chunks to arrive. The following metadata set is defined as a struct:",
      "ja": "分割とマージのメカニズムは実装の問題であると予想されます。このドキュメントは、分割とマージの操作パラメーターを定義する役割を果たします。つまり、チャンクのサイズ、パケットまたはチャンクが無効としてマークされた場合に何が起こるか、マージLFBがすべてのパケットまたはチャンクを待機するかどうか到着。次のメタデータセットは構造体として定義されています。"
    },
    {
      "indent": 3,
      "text": "1. ParallelType - Flood or split",
      "ja": "1. ParallelType-フラッドまたは分割"
    },
    {
      "indent": 3,
      "text": "2. TaskCorrelator - Identify packets or chunks that belonged to the initial packet that entered the Splitter LFB",
      "ja": "2. TaskCorrelator-スプリッターLFBに入った最初のパケットに属していたパケットまたはチャンクを識別します"
    },
    {
      "indent": 3,
      "text": "3. ParallelNum - Sequence number of the packet or the chunk for a specific task",
      "ja": "3. ParallelNum-特定のタスクのパケットまたはチャンクのシーケンス番号"
    },
    {
      "indent": 3,
      "text": "4. ParallelPartsCount - Total number of packets or chunks for a specific task",
      "ja": "4. ParallelPartsCount-特定のタスクのパケットまたはチャンクの総数"
    },
    {
      "indent": 3,
      "text": "This metadata is produced from the Splitter LFB, is opaque to LFBs in parallel paths, and is passed along to the Merger LFB without being consumed.",
      "ja": "このメタデータはスプリッターLFBから生成され、並列パスのLFBに対して不透明であり、消費されることなくMerger LFBに渡されます。"
    },
    {
      "indent": 3,
      "text": "In the case in which an LFB decides that a packet/chunk has to be dropped, the LFB MAY drop the packet/chunk, but the metadata MUST be sent to the Merger LFB's InvalidIn input port for merging purposes.",
      "ja": "パケット/チャンクをドロップする必要があるとLFBが判断した場合、LFBはパケット/チャンクをドロップできますが、マージのためにメタデータをマージャーLFBのInvalidIn入力ポートに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additional metadata produced by LFBs inside a datapath MAY be aggregated within the Merger LFB and sent on after the merging process. In case of receiving the same metadata definition with multiple values, the Merger LFB MUST keep the first received from a valid packet or chunk.",
      "ja": "データパス内のLFBによって生成された追加のメタデータは、Merger LFB内で集約され、マージプロセスの後に送信される場合があります。複数の値を持つ同じメタデータ定義を受信する場合、Merger LFBは、有効なパケットまたはチャンクから最初に受信したものを維持する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Parallel Base Types",
      "section_title": true,
      "ja": "3. 並列ベースタイプ"
    },
    {
      "indent": 0,
      "text": "3.1. Frame Types",
      "section_title": true,
      "ja": "3.1. フレームタイプ"
    },
    {
      "indent": 3,
      "text": "One frame type has been defined in this library.",
      "ja": "このライブラリでは、1つのフレームタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------------------------------------------------------+\n| Frame     | Synopsis                                              |\n| Name      |                                                       |\n+-----------+-------------------------------------------------------+\n| Chunk     | A chunk is a frame that is part of an original larger |\n|           | frame.                                                |\n+-----------+-------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Parallel Frame Types",
      "ja": "平行フレームタイプ"
    },
    {
      "indent": 0,
      "text": "3.2. Data Types",
      "section_title": true,
      "ja": "3.2. データ型"
    },
    {
      "indent": 3,
      "text": "One data type has been defined in this library.",
      "ja": "このライブラリでは1つのデータ型が定義されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+------------------------+--------------------------+\n| DataType Name | Type                   | Synopsis                 |\n+---------------+------------------------+--------------------------+\n| ParallelTypes | Atomic uchar.  Special | The type of              |\n|               | Values Flood (0),      | parallelization this     |\n|               | Split (1).             | packet will go through.  |\n+---------------+------------------------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Parallel Data Types",
      "ja": "並列データ型"
    },
    {
      "indent": 0,
      "text": "3.3. Metadata Types",
      "section_title": true,
      "ja": "3.3. メタデータタイプ"
    },
    {
      "indent": 3,
      "text": "The following metadata structure with ID 16, using the ForCES model extension [RFC7408], is defined for the parallelization library:",
      "ja": "ForCESモデル拡張[RFC7408]を使用した、ID 16の次のメタデータ構造が、並列化ライブラリ用に定義されています。"
    },
    {
      "indent": 3,
      "text": "+--------------------+--------+----+--------------------------------+\n|   Metadata Name    |  Type  | ID |            Synopsis            |\n+--------------------+--------+----+--------------------------------+\n|    ParallelType    | uchar  | 1  |  The type of parallelization   |\n|                    |        |    | this packet will go through. 0 |\n|                    |        |    |    for flood, 1 for split.     |\n|                    |        |    |                                |\n|   TaskCorrelator   | uint32 | 2  |  An identification number to   |\n|                    |        |    |   specify that a packet or a   |\n|                    |        |    |   chunk belongs to the same    |\n|                    |        |    |         parallel task.         |\n|                    |        |    |                                |\n|    ParallelNum     | uint32 | 3  |    Defines the number of a     |\n|                    |        |    | specific packet or chunk of a  |\n|                    |        |    |         specific task.         |\n|                    |        |    |                                |\n| ParallelPartsCount | uint32 | 4  |  Defines the total number of   |\n|                    |        |    |    packets or chunks for a     |\n|                    |        |    |         specific task.         |\n+--------------------+--------+----+--------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Metadata Structure for Merging",
      "ja": "マージのメタデータ構造"
    },
    {
      "indent": 0,
      "text": "4. Parallel LFBs",
      "section_title": true,
      "ja": "4. 並列LFB"
    },
    {
      "indent": 0,
      "text": "4.1. Splitter",
      "section_title": true,
      "ja": "4.1. スプリッター"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB takes part in parallelizing the processing datapath by sending either the same packet (Figure 2) or chunks (Figure 1) of the same packet to multiple LFBs.",
      "ja": "Splitter LFBは、同じパケット（図2）または同じパケットのチャンク（図1）を複数のLFBに送信することにより、処理データパスの並列化に参加します。"
    },
    {
      "indent": 18,
      "text": "           +---------------+\nSplitterIn |               | SplitterOut\n---------->| Splitter LFB  |------------->\n           |               |\n           +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 4: Splitter LFB",
      "ja": "図4：スプリッターLFB"
    },
    {
      "indent": 0,
      "text": "4.1.1. Data Handling",
      "section_title": true,
      "ja": "4.1.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB receives any kind of packet via the singleton input, Input. Depending upon the CE's configuration of the ParallelType component, if the parallel type is of type flood (0), the same packet MUST be sent through all instances of the group output \"SplitterOut\". If the parallel type is of type split (1), then the packet will be split into same size chunks except for the last, which MAY be smaller, with the max size being defined by the ChunkSize component. Chunks MAY be sent out in a round-robin fashion through instances of the group output \"ParallelOut\" or in any other way defined by the implementer. Each packet or chunk will be accompanied by the following metadata set as a struct:",
      "ja": "スプリッターLFBは、シングルトン入力である入力を介してあらゆる種類のパケットを受信します。 CEのParallelTypeコンポーネントの構成に応じて、パラレルタイプのタイプがフラッド（0）の場合、同じパケットをグループ出力「SplitterOut」のすべてのインスタンスから送信する必要があります。並列タイプがタイプsplit（1）の場合、パケットは、最後のサイズを除いて同じサイズのチャンクに分割されます。最大サイズはChunkSizeコンポーネントで定義されます。チャンクは、グループ出力「ParallelOut」のインスタンスを介して、または実装者によって定義された他の方法でラウンドロビン方式で送信される場合があります。各パケットまたはチャンクには、構造体として設定された次のメタデータが付随します。"
    },
    {
      "indent": 3,
      "text": "o ParallelType - The parallel type: split or flood.",
      "ja": "o ParallelType-並列タイプ：スプリットまたはフラッド。"
    },
    {
      "indent": 3,
      "text": "o ParallelID - Generated by the Splitter LFB to identify which chunks or packets belong to the same parallel task.",
      "ja": "o ParallelID-Splitter LFBによって生成され、同じチャンクまたはパケットが同じ並列タスクに属していることを識別します。"
    },
    {
      "indent": 3,
      "text": "o ParallelNum - Each chunk or packet of a parallel ID will be assigned a number in order for the Merger LFB to know when it has gathered them all along with the ParallelPartsCount metadata.",
      "ja": "o ParallelNum-並列LIDの各チャンクまたはパケットには番号が割り当てられ、Merger LFBは、ParallelPartsCountメタデータとともにそれらをすべて収集したタイミングを認識します。"
    },
    {
      "indent": 3,
      "text": "o ParallelPartsCount - The number of chunks or packets for the specific task.",
      "ja": "o ParallelPartsCount-特定のタスクのチャンクまたはパケットの数。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Components",
      "section_title": true,
      "ja": "4.1.2. 部品"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB has only two components. The first is the ParallelType, a uint32 that defines how the packet will be processed by the Splitter LFB. The second is the ChunkSize, a uint32 that specifies the size of each chunk when a packet is split into multiple same-size chunks. The last chunk MAY be smaller than the value of the ChunkSize.",
      "ja": "Splitter LFBには2つのコンポーネントしかありません。 1つ目はParallelTypeです。uint32は、スプリッターLFBによるパケットの処理方法を定義します。 2つ目は、パケットが複数の同じサイズのチャンクに分割されるときに各チャンクのサイズを指定するuint32であるChunkSizeです。最後のチャンクは、ChunkSizeの値よりも小さい場合があります。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Capabilities",
      "section_title": true,
      "ja": "4.1.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified; the MinMaxChunkSize is a struct of two uint32s to specify the minimum and maximum chunk size.",
      "ja": "このLFBには1つの機能しか指定されていません。 MinMaxChunkSizeは、最小および最大のチャンクサイズを指定する2つのuint32の構造体です。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Events",
      "section_title": true,
      "ja": "4.1.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB has no events specified.",
      "ja": "このLFBにはイベントが指定されていません。"
    },
    {
      "indent": 0,
      "text": "4.2. Merger",
      "section_title": true,
      "ja": "4.2. 合併"
    },
    {
      "indent": 3,
      "text": "The Merger LFB is the synchronization point for multiple packets or packet chunks of the same task emanating out of the parallel path, as illustrated in Figure 1 and Figure 2.",
      "ja": "マージLFBは、図1および図2に示すように、並列パスから発生する同じタスクの複数のパケットまたはパケットチャンクの同期ポイントです。"
    },
    {
      "indent": 21,
      "text": "          +-------------+\n MergerIn |             |\n--------->|             | MergerOut\n          | Merger LFB  |----------->\nInvalidIn |             |\n--------->|             |\n          +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 5: Merger LFB",
      "ja": "図5：合併LFB"
    },
    {
      "indent": 0,
      "text": "4.2.1. Data Handling",
      "section_title": true,
      "ja": "4.2.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The Merger LFB receives either a packet or a chunk via the group input ParallelIn, along with the ParallelType metadata, the TaskCorrelator, the ParallelNum, and the ParallelPartsCount.",
      "ja": "Merger LFBは、ParallelTypeメタデータ、TaskCorrelator、ParallelNum、およびParallelPartsCountとともに、グループ入力ParallelInを介してパケットまたはチャンクを受信します。"
    },
    {
      "indent": 3,
      "text": "In the case in which an upstream LFB has dropped a packet or a chunk, the Merger LFB MAY receive only the metadata, both the metadata and the packet, or the chunk through the InvalidIn group input port. It SHOULD receive a metadata specifying the error code. Currently defined metadata in the Base LFB Library [RFC6956] are the ExceptionID and the ValidateErrorID.",
      "ja": "アップストリームLFBがパケットまたはチャンクをドロップした場合、Merger LFBは、InvalidInグループ入力ポートを介して、メタデータのみ、メタデータとパケットの両方、またはチャンクを受信できます（MAY）。エラーコードを指定するメタデータを受信する必要があります。ベースLFBライブラリ[RFC6956]で現在定義されているメタデータは、ExceptionIDとValidateErrorIDです。"
    },
    {
      "indent": 3,
      "text": "If the MergeWaitType is set to false, the Merger LFB will initiate the merge process upon receiving the first packet. If false, for each task identified by the task correlator, it will wait for all packets/chunks to arrive unless the MergeWaitTimeoutTimer timer expires. If the MergeWaitTimeoutTimer has expired, the Merger MUST consider the rest of the packets/chunks that have not been received as invalid, and it MUST handle the packets according to the InvalidAction value.",
      "ja": "MergeWaitTypeがfalseに設定されている場合、Merger LFBは最初のパケットを受信するとマージプロセスを開始します。 falseの場合、タスクコリレータによって識別された各タスクについて、MergeWaitTimeoutTimerタイマーが期限切れにならない限り、すべてのパケット/チャンクが到着するまで待機します。 MergeWaitTimeoutTimerの有効期限が切れている場合、Mergerは受信されなかった残りのパケット/チャンクを無効と見なしなければならず、InvalidAction値に従ってパケットを処理しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "If one packet or chunk has been received through the InvalidIn port, then the merging procedure will handle the packets/chunks according to the InvalidAction value. If the InvalidAction component has been set to 0, then if one packet or chunk is not valid, all will be dropped or else the process will initiate. Once the merging process has been completed, the resulting packet will be sent via the singleton output port MergerOut.",
      "ja": "1つのパケットまたはチャンクがInvalidInポートを介して受信された場合、マージ手順はInvalidAction値に従ってパケット/チャンクを処理します。 InvalidActionコンポーネントが0に設定されている場合、1つのパケットまたはチャンクが有効でないと、すべてがドロップされるか、プロセスが開始されます。マージプロセスが完了すると、結果のパケットはシングルトン出力ポートMergerOut経由で送信されます。"
    },
    {
      "indent": 3,
      "text": "If the Merger LFB receives different values for the same metadata from different packets or chunks that have the same task correlator, then the Merger LFB will use the first metadata from a packet or chunk that entered the LFB through the MergerIn input port.",
      "ja": "Merger LFBが、同じタスクコリレーターを持つ異なるパケットまたはチャンクから同じメタデータの異なる値を受け取る場合、Merger LFBは、MergerIn入力ポートを介してLFBに入ったパケットまたはチャンクの最初のメタデータを使用します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Components",
      "section_title": true,
      "ja": "4.2.2. 部品"
    },
    {
      "indent": 3,
      "text": "This LFB has the following components specified:",
      "ja": "このLFBには、次のコンポーネントが指定されています。"
    },
    {
      "indent": 3,
      "text": "1. InvalidAction: A uchar defining what the Merge LFB will do if an invalid chunk or packet is received. If set to 0 (DropAll), the merge will be considered invalid and all chunks or packets will be dropped. If set to 1 (Continue), the merge will continue.",
      "ja": "1. InvalidAction：無効なチャンクまたはパケットが受信された場合にMerge LFBが実行することを定義するuchar。 0（DropAll）に設定すると、マージは無効と見なされ、すべてのチャンクまたはパケットがドロップされます。 1（続行）に設定すると、マージが続行されます。"
    },
    {
      "indent": 3,
      "text": "2. MergeWaitTimeoutTimer: A uint32 defining the amount of time, in milliseconds, that the Merger will wait for all packets or chunks within the same task to arrive before considering them invalid. The MergeWaitTimeoutTimer starts as soon as the first chunk or packet of a parallel task arrives.",
      "ja": "2. MergeWaitTimeoutTimer：マージが同じタスク内のすべてのパケットまたはチャンクが無効であると見なす前に到着するまで待機する時間（ミリ秒単位）を定義するuint32。 MergeWaitTimeoutTimerは、並列タスクの最初のチャンクまたはパケットが到着するとすぐに開始します。"
    },
    {
      "indent": 3,
      "text": "3. MergeWaitType: A boolean. If true, the Merger LFB will wait for all packets or chunks to be received prior to performing the merge. If false, when one packet or a chunk with a response is received by the merge LFB, it will start with the merge process.",
      "ja": "3. MergeWaitType：ブール値。 trueの場合、マージLFBは、マージを実行する前に、すべてのパケットまたはチャンクが受信されるのを待ちます。 falseの場合、1つのパケットまたは応答のあるチャンクがマージLFBによって受信されると、マージプロセスから開始されます。"
    },
    {
      "indent": 3,
      "text": "4. InvalidMergesCounter: A uint32 that counts the number of merges where there is at least one packet or chunk that entered the Merger LFB through the InvalidIn input port.",
      "ja": "4. InvalidMergesCounter：InvalidIn入力ポートを介してMerger LFBに入ったパケットまたはチャンクが少なくとも1つあるマージの数をカウントするuint32。"
    },
    {
      "indent": 3,
      "text": "5. InvalidTotalCounter: A uint32 that counts the number of merges where all packets/chunks entered the Merger LFB through the InvalidIn input port.",
      "ja": "5. InvalidTotalCounter：すべてのパケット/チャンクがInvalidIn入力ポートを介してマージLFBに入ったマージの数をカウントするuint32。"
    },
    {
      "indent": 3,
      "text": "6. InvalidIDCounters: A struct of two arrays. Each array has a uint32 per row. Each array counts the number of invalid merges where at least one packet or chunk entered through InvalidID per error ID. The first array is the InvalidExceptionID and the second is the InvalidValidateErrorID.",
      "ja": "6. InvalidIDCounters：2つの配列の構造体。各配列には、行ごとにuint32があります。各配列は、エラーIDごとに少なくとも1つのパケットまたはチャンクがInvalidIDを介して入力された無効なマージの数をカウントします。最初の配列はInvalidExceptionIDで、2番目の配列はInvalidValidateErrorIDです。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Capabilities",
      "section_title": true,
      "ja": "4.2.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has no capabilities specified.",
      "ja": "このLFBには機能が指定されていません。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Events",
      "section_title": true,
      "ja": "4.2.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB specifies only two events. The first detects whether the InvalidMergesCounter has exceeded a specific value, and the second detects whether the InvalidAllCounter has exceeded a specific value. Both error reports will send the respective counter value. Event Filters can be used to limit the number of messages",
      "ja": "このLFBは2つのイベントのみを指定します。 1つ目はInvalidMergesCounterが特定の値を超えたかどうかを検出し、2つ目はInvalidAllCounterが特定の値を超えたかどうかを検出します。両方のエラーレポートは、それぞれのカウンター値を送信します。イベントフィルターを使用してメッセージの数を制限できます。"
    },
    {
      "indent": 0,
      "text": "4.3. CoreParallelization",
      "section_title": true,
      "ja": "4.3. CoreParallelization"
    },
    {
      "indent": 3,
      "text": "A core LFB that specifies that the FE supports parallelization instead of updating the FEObject LFB",
      "ja": "FEがFEObject LFBを更新する代わりに並列化をサポートすることを指定するコアLFB"
    },
    {
      "indent": 0,
      "text": "4.3.1. Data Handling",
      "section_title": true,
      "ja": "4.3.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization does not handle data.",
      "ja": "CoreParallelizationはデータを処理しません。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Components",
      "section_title": true,
      "ja": "4.3.2. 部品"
    },
    {
      "indent": 3,
      "text": "This LFB has no components specified.",
      "ja": "このLFBにはコンポーネントが指定されていません。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Capabilities",
      "section_title": true,
      "ja": "4.3.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified. The ParallelLFBs is a table which lists all the LFBs that can be parallelized. Each row of the table contains:",
      "ja": "このLFBには、1つの機能のみが指定されています。 ParallelLFBは、並列化できるすべてのLFBをリストするテーブルです。テーブルの各行には以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "1. LFBName: A string. The Name of the parallel LFB.",
      "ja": "1. LFBName：文字列。並列LFBの名前。"
    },
    {
      "indent": 3,
      "text": "2. LFBClassID: A uint32. The Class ID of the parallel LFB.",
      "ja": "2. LFBClassID：uint32。並列LFBのクラスID。"
    },
    {
      "indent": 3,
      "text": "3. LFBVersion: A string. The Version of the parallel LFB.",
      "ja": "3. LFBVersion：文字列。並列LFBのバージョン。"
    },
    {
      "indent": 3,
      "text": "4. LFBParallelOccurrenceLimit: A uint32. The upper limit of instances of the same parallel LFBs of this class.",
      "ja": "4. LFBParallelOccurrenceLimit：uint32。このクラスの同じ並列LFBのインスタンスの上限。"
    },
    {
      "indent": 3,
      "text": "5. AllowedParallelAfters: A table of uint32s (LFB Class IDs). A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "ja": "5. AllowedParallelAfters：uint32（LFBクラスID）のテーブル。並列パスのパイプラインでこのLFBクラスをたどることができるLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "6. AllowedParallelBefores: A table of uint32s (LFB Class IDs). A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "ja": "6. 許可された並列前：int32（LFBクラスIs）のテーブル。並列パスのパイプラインでこのLFBクラスの前に存在できるLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "7. AllowedParallel: A table of uint32s (LFB Class IDs). A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "ja": "7. 許可される並列：int32（LFBクラスIs）のテーブル。このLFBクラスと並行してパケットまたはチャンクを処理できるLFBクラスのリスト。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Events",
      "section_title": true,
      "ja": "4.3.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB specifies no events.",
      "ja": "このLFBはイベントを指定しません。"
    },
    {
      "indent": 0,
      "text": "5. XML for Parallel LFB Library",
      "section_title": true,
      "ja": "5. 並列LFBライブラリのXML"
    },
    {
      "indent": 2,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   provides=\"Parallel\">\n  <load library=\"BaseTypeLibrary\" location=\"BaseTypeLibrary.LFB\"/>\n  <frameDefs>\n    <frameDef>\n      <name>Chunk</name>\n      <synopsis>A chunk is a frame that is part of an original\n            larger frame</synopsis>\n    </frameDef>\n  </frameDefs>\n  <dataTypeDefs>\n    <dataTypeDef>\n      <name>ParallelTypes</name>\n      <synopsis>The type of parallelization this packet will go\n            through</synopsis>\n      <atomic>\n        <baseType>uchar</baseType>\n        <specialValues>\n          <specialValue value=\"0\">\n            <name>Flood</name>\n            <synopsis>The packet/chunk has been sent as a whole\n                     to multiple recipients</synopsis>\n          </specialValue>\n          <specialValue value=\"1\">\n            <name>Split</name>\n            <synopsis>The packet/chunk has been split into\n                     multiple chunks and sent to recipients</synopsis>\n          </specialValue>\n        </specialValues>\n      </atomic>\n    </dataTypeDef>\n    <dataTypeDef>\n      <name>ParallelLFBType</name>\n      <synopsis>Table entry for parallel LFBs</synopsis>\n      <struct>\n        <component componentID=\"1\">\n          <name>LFBName</name>\n          <synopsis>The name of an LFB Class</synopsis>\n          <typeRef>string</typeRef>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "      </component>\n      <component componentID=\"2\">\n        <name>LFBClassID</name>\n        <synopsis>The ID of the LFB Class</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n        <name>LFBVersion</name>\n        <synopsis>The version of the LFB Class used by this FE\n           </synopsis>\n        <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"4\">\n        <name>LFBParallelOccurrenceLimit</name>\n        <synopsis>The upper limit of instances of the same\n              parallel LFBs of this class</synopsis>\n        <optional/>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"5\">\n        <name>AllowedParallelAfters</name>\n        <synopsis>List of LFB Classes that can follow this LFB\n              in a parallel pipeline</synopsis>\n        <optional/>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"6\">\n        <name>AllowedParallelBefores</name>\n        <synopsis>List of LFB Classes that this LFB Class can\n              follow in a parallel pipeline</synopsis>\n        <optional/>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"7\">\n        <name>AllowedParallel</name>\n        <synopsis>List of LFB Classes that this LFB Class can be run\n              in parallel with</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n    </struct>\n  </dataTypeDef>\n</dataTypeDefs>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "<metadataDefs>\n  <metadataDef>\n    <name>ParallelMetadataSet</name>\n    <synopsis>A metadata set for parallelization-related LFBs\n       </synopsis>\n    <metadataID>32</metadataID>\n    <struct>\n      <component componentID=\"1\">\n        <name>ParallelType</name>\n        <synopsis>The type of parallelization this packet/chunk\n                has gone through</synopsis>\n        <typeRef>ParallelTypes</typeRef>\n      </component>\n      <component componentID=\"2\">\n        <name>TaskCorrelator</name>\n        <synopsis>An identification number to specify that\n                packets or chunks originate from the same packet.\n             </synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n        <name>ParallelNum</name>\n        <synopsis>Defines the number of the specific packet or\n                chunk of the specific parallel ID.</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"4\">\n        <name>ParallelPartsCount</name>\n        <synopsis>Defines the total number of packets or chunks\n                for the specific parallel ID.</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n    </struct>\n  </metadataDef>\n</metadataDefs>\n<LFBClassDefs>\n  <LFBClassDef LFBClassID=\"65537\">\n    <name>Ext-Splitter</name>\n    <synopsis>A Splitter LFB takes part in parallelizing the\n          processing datapath.  It will either send the same packet\n          or chunks of one packet to multiple LFBs</synopsis>\n    <version>1.0</version>\n    <inputPorts>\n      <inputPort>\n        <name>SplitterIn</name>\n        <synopsis>An input port expecting any kind of frame\n             </synopsis>\n        <expectation>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "      <frameExpected>\n        <ref>Arbitrary</ref>\n      </frameExpected>\n    </expectation>\n  </inputPort>\n</inputPorts>\n<outputPorts>\n  <outputPort group=\"true\">\n    <name>SplitterOut</name>\n    <synopsis>A parallel output port that sends the same\n            packet to all output instances or chunks of the same\n            packet to output instances.  Each chunk is sent only\n            once by the LFB.</synopsis>\n    <product>\n      <frameProduced>\n        <ref>Arbitrary</ref>\n        <ref>Chunk</ref>\n      </frameProduced>\n      <metadataProduced>\n        <ref>ParallelMetadataSet</ref>\n      </metadataProduced>\n    </product>\n  </outputPort>\n</outputPorts>\n<components>\n  <component componentID=\"1\" access=\"read-write\">\n    <name>ParallelType</name>\n    <synopsis>The type of parallelization this packet will\n            go through</synopsis>\n    <typeRef>ParallelTypes</typeRef>\n  </component>\n  <component componentID=\"2\" access=\"read-write\">\n    <name>ChunkSize</name>\n    <synopsis>The size of a chunk when a packet is split\n            into multiple chunks of the same size</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n</components>\n<capabilities>\n  <capability componentID=\"31\">\n    <name>MinMaxChunkSize</name>\n    <synopsis>The minimum and maximum size of a chunk\n            capable of split by this LFB</synopsis>\n    <struct>\n      <component componentID=\"1\">\n        <name>MinChunkSize</name>\n        <synopsis>Minimum chunk size</synopsis>\n        <optional/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "          <typeRef>uint32</typeRef>\n        </component>\n        <component componentID=\"2\">\n          <name>MaxChunkSize</name>\n          <synopsis>Maximum chunk size</synopsis>\n          <typeRef>uint32</typeRef>\n        </component>\n      </struct>\n    </capability>\n  </capabilities>\n</LFBClassDef>\n<LFBClassDef LFBClassID=\"65538\">\n  <name>Ext-Merger</name>\n  <synopsis>A Merger LFB receives multiple packets or multiple\n        chunks of the same packet and merge them into one merged\n        packet</synopsis>\n  <version>1.0</version>\n  <inputPorts>\n    <inputPort group=\"true\">\n      <name>MergerIn</name>\n      <synopsis>A parallel input port that accepts packets\n              or chunks from all output instances</synopsis>\n      <expectation>\n        <frameExpected>\n          <ref>Arbitrary</ref>\n          <ref>Chunk</ref>\n        </frameExpected>\n        <metadataExpected>\n          <ref>ParallelMetadataSet</ref>\n        </metadataExpected>\n      </expectation>\n    </inputPort>\n    <inputPort group=\"true\">\n      <name>InvalidIn</name>\n      <synopsis>When a packet is sent out of an error port of\n              an LFB in a parallel path, it will be sent to this\n              output port in the Merger LFB</synopsis>\n      <expectation>\n        <frameExpected>\n          <ref>Arbitrary</ref>\n          <ref>Chunk</ref>\n        </frameExpected>\n        <metadataExpected>\n          <one-of>\n            <ref>ExceptionID</ref>\n            <ref>ValidateErrorID</ref>\n          </one-of>\n        </metadataExpected>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "    </expectation>\n  </inputPort>\n</inputPorts>\n<outputPorts>\n  <outputPort>\n    <name>MergerOut</name>\n    <synopsis>An output port expecting any kind of frame\n         </synopsis>\n    <product>\n      <frameProduced>\n        <ref>Arbitrary</ref>\n      </frameProduced>\n    </product>\n  </outputPort>\n</outputPorts>\n<components>\n  <component componentID=\"1\" access=\"read-write\">\n    <name>InvalidAction</name>\n    <synopsis>What the Merge LFB will do if an invalid\n            chunk or packet is received</synopsis>\n    <atomic>\n      <baseType>uchar</baseType>\n      <specialValues>\n        <specialValue value=\"0\">\n          <name>DropAll</name>\n          <synopsis>Drop all packets or chunks\n                  </synopsis>\n        </specialValue>\n        <specialValue value=\"1\">\n          <name>Continue</name>\n          <synopsis>Continue with the merge</synopsis>\n        </specialValue>\n      </specialValues>\n    </atomic>\n  </component>\n  <component componentID=\"2\" access=\"read-write\">\n    <name>MergeWaitType</name>\n    <synopsis>Whether the Merge LFB will wait for all\n            packets or chunks to be received prior to sending\n            out a response</synopsis>\n    <typeRef>boolean</typeRef>\n  </component>\n  <component componentID=\"3\" access=\"read-write\">\n    <name>MergeWaitTimeoutTimer</name>\n    <synopsis>The time that the Merger will wait\n    for all packets or chunks within the same task to arrive\n    before considering them invalid.</synopsis>\n    <typeRef>uint32</typeRef>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "  </component>\n  <component componentID=\"4\" access=\"read-reset\">\n    <name>InvalidMergesCounter</name>\n    <synopsis>Counts the number of merges where there is at\n            least one packet/chunk that entered the Merger LFB\n            through the InvalidIn input port</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n  <component componentID=\"5\" access=\"read-reset\">\n    <name>InvalidTotalCounter</name>\n    <synopsis>Counts the number of merges where all\n            packets/chunks entered the Merger LFB through the\n            InvalidIn input port</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n  <component componentID=\"6\" access=\"read-reset\">\n    <name>InvalidIDCounters</name>\n    <synopsis>Counts the number of invalid merges where at\n            least one packet/chunk entered through InvalidID per\n            error ID</synopsis>\n    <struct>\n      <component componentID=\"1\">\n        <name>InvalidExceptionID</name>\n        <synopsis>Per Exception ID</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"2\">\n        <name>InvalidValidateErrorID</name>\n        <synopsis>Per Validate Error ID</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n    </struct>\n  </component>\n</components>\n<events baseID=\"30\">\n  <event eventID=\"1\">\n    <name>ManyInvalids</name>\n    <synopsis>An event that specifies if there are too many\n            invalids</synopsis>\n    <eventTarget>\n      <eventField>InvalidCounter</eventField>\n    </eventTarget>\n    <eventGreaterThan/>\n    <eventReports>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "            <eventReport>\n              <eventField>InvalidMergesCounter</eventField>\n            </eventReport>\n          </eventReports>\n        </event>\n        <event eventID=\"2\">\n          <name>ManyTotalInvalids</name>\n          <synopsis>An event that specifies if there are too many\n                  invalids</synopsis>\n          <eventTarget>\n            <eventField>InvalidTotalCounter</eventField>\n          </eventTarget>\n          <eventGreaterThan/>\n          <eventReports>\n            <eventReport>\n              <eventField>InvalidTotalCounter</eventField>\n            </eventReport>\n          </eventReports>\n        </event>\n      </events>\n    </LFBClassDef>\n    <LFBClassDef LFBClassID=\"65539\">\n      <name>Ext-CoreParallelization</name>\n      <synopsis>A core LFB that specifies that the FE supports\n        parallelization instead of updating the FEObject\n        LFB</synopsis>\n      <version>1.0</version>\n      <capabilities>\n        <capability componentID=\"10\">\n          <name>ParallelLFBs</name>\n          <synopsis>A table that lists all the LFBs that can be\n              parallelized</synopsis>\n          <array>\n            <typeRef>ParallelLFBType</typeRef>\n          </array>\n        </capability>\n      </capabilities>\n    </LFBClassDef>\n  </LFBClassDefs>\n</LFBLibrary>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 6: Parallel LFB Library",
      "ja": "図6：並列LFBライブラリ"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. LFB Class Names and LFB Class Identifiers",
      "section_title": true,
      "ja": "6.1. LFBクラス名とLFBクラス識別子"
    },
    {
      "indent": 3,
      "text": "LFB classes defined by this document do not belong to LFBs defined by Standards Action. As such, the corresponding values assigned in the \"Logical Functional Block (LFB) Class Names and Class Identifiers\" registry at <http://www.iana.org/assignments/forces> are above 65535.",
      "ja": "このドキュメントで定義されているLFBクラスは、標準アクションで定義されているLFBに属していません。そのため、<http://www.iana.org/assignments/forces>の「Logical Functional Block（LFB）Class Names and Class Identifiers」レジストリに割り当てられている対応する値は、65535を超えています。"
    },
    {
      "indent": 3,
      "text": "This specification includes the following LFB class names and LFB class identifiers:",
      "ja": "この仕様には、以下のLFBクラス名とLFBクラス識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "+-------+---------------------+-------+-----------------+---------+\n| LFB   |  LFB Class Name     |  LFB  |  Description    |   Ref   |\n| Class |                     |Version|                 |         |\n| ID    |                     |       |                 |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65537 |   Ext-Splitter      |  1.0  | A Splitter LFB  |   RFC   |\n|       |                     |       |  will send      |   7409  |\n|       |                     |       |either the same  |         |\n|       |                     |       |   packet or     |         |\n|       |                     |       | chunks of one   |         |\n|       |                     |       |   packet to     |         |\n|       |                     |       | multiple LFBs.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65538 |    Ext-Merger       |   1.0 |  A Merger LFB   |   RFC   |\n|       |                     |       |    receives     |   7409  |\n|       |                     |       |    multiple     |         |\n|       |                     |       |   packets or    |         |\n|       |                     |       |    multiple     |         |\n|       |                     |       | chunks of the   |         |\n|       |                     |       |  same packet    |         |\n|       |                     |       |   and merges    |         |\n|       |                     |       | them into one.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65539 | Ext-                |   1.0 | A core LFB to   |   RFC   |\n|       | CoreParallelization |       | signify the     |   7409  |\n|       |                     |       | parallelization |         |\n|       |                     |       |   capability    |         |\n+-------+---------------------+-------+-----------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Logical Functional Block (LFB) Class Names and Class Identifiers",
      "ja": "論理機能ブロック（LFB）のクラス名とクラス識別子"
    },
    {
      "indent": 0,
      "text": "6.2. Metadata ID",
      "section_title": true,
      "ja": "6.2. メタデータID"
    },
    {
      "indent": 3,
      "text": "The Metadata ID namespace is 32-bits long. Values assigned by this specification are:",
      "ja": "メタデータID名前空間は32ビット長です。この仕様によって割り当てられる値は次のとおりです。"
    },
    {
      "indent": 13,
      "text": "+------------+---------------------+-----------+\n|   Value    |         Name        | Reference |\n+------------+---------------------+-----------+\n| 0x00000010 | ParallelMetadataSet |  RFC 7409 |\n+------------+---------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Metadata ID Assigned by this Specification",
      "ja": "この仕様によって割り当てられたメタデータID"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not alter either the ForCES model [RFC5812] or the ForCES protocol [RFC5810]. As such, it has no impact on their security considerations. This document simply defines the operational parameters and capabilities of LFBs that perform parallelization and not how parallelization is implemented. Finally, this document does not attempt to analyze the presence or possibility of security interactions created by allowing parallel operations on packets. Any such issues, if they exist, are for the designers of the particular data path, not the general mechanism.",
      "ja": "このドキュメントは、ForCESモデル[RFC5812]またはForCESプロトコル[RFC5810]のいずれも変更しません。そのため、セキュリティに関する考慮事項には影響しません。このドキュメントでは、並列化の実装方法ではなく、並列化を実行するLFBの操作パラメーターと機能を簡単に定義します。最後に、このドキュメントでは、パケットでの並列操作を許可することによって作成されるセキュリティ相互作用の存在や可能性を分析することは試みていません。このような問題が存在する場合、それは特定のデータパスの設計者向けであり、一般的なメカニズムではありません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010, <http://www.rfc-editor.org/info/rfc5810>.",
      "ja": "[RFC5810] Doria、A.、Hadi Salim、J.、Haas、R.、Khosravi、H.、Wang、W.、Dong、L.、Gopal、R。、およびJ. Halpern、「転送および制御要素の分離（ForCES）プロトコル仕様」、RFC 5810、2010年3月、<http://www.rfc-editor.org/info/rfc5810>。"
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010, <http://www.rfc-editor.org/info/rfc5812>.",
      "ja": "[RFC5812] Halpern、J。およびJ. Hadi Salim、「Forwarding and Control Element Separation（ForCES）Forwarding Element Model」、RFC 5812、2010年3月、<http://www.rfc-editor.org/info/rfc5812> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6956] Wang, W., Haleplidis, E., Ogawa, K., Li, C., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Logical Function Block (LFB) Library\", RFC 6956, June 2013, <http://www.rfc-editor.org/info/rfc6956>.",
      "ja": "[RFC6956] Wang、W.、Haleplidis、E.、Ogawa、K.、Li、C。、およびJ. Halpern、「Forwarding and Control Element Separation（ForCES）Logical Function Block（LFB）Library」、RFC 6956、6月2013、<http://www.rfc-editor.org/info/rfc6956>。"
    },
    {
      "indent": 3,
      "text": "[RFC7408] Haleplidis, E., \"Forwarding and Control Element Separation (ForCES) Model Extension\", RFC 7408, November 2014, <http://www.rfc-editor.org/info/rfc7408>.",
      "ja": "[RFC7408] Haleplidis、E。、「Forwarding and Control Element Separation（ForCES）Model Extension」、RFC 7408、2014年11月、<http://www.rfc-editor.org/info/rfc7408>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Cilk] Massachusetts Institute of Technology, \"The Cilk Project\", <http://supertech.csail.mit.edu/cilk/>.",
      "ja": "[Cilk]マサチューセッツ工科大学、「The Cilk Project」、<http://supertech.csail.mit.edu/cilk/>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Edward Crabbe for the initial discussion that led to the creation of this document. They also thank Jamal Hadi Salim and Dave Hood for comments and discussions and Adrian Farrel for his AD review that made this document better. Finally, the authors thank Francis Dupont for his Gen-Art review and Magnus Nystroem for his security review both of which refined this document to its final shape.",
      "ja": "このドキュメントの作成につながった最初の議論について、著者はEdward Crabbeに感謝します。彼らはまた、コメントと議論をしてくれたJamal Hadi SalimとDave Hoodと、この文書をより良くしたADレビューをしてくれたAdrian Farrelに感謝します。最後に、著者はGen-ArtレビューをしてくれたFrancis DupontとセキュリティレビューをしてくれたMagnus Nystroemに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical and Computer Engineering Patras 26500 Greece",
      "ja": "エヴァンジェロスハレプリディスパトラス大学電気電子工学科パトラス26500ギリシャ"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Joel Halpern Ericsson P.O. Box 6049 Leesburg, VA 20178 United States",
      "ja": "ジョエルハルパーンエリクソンP.O. Box 6049 Leesburg、VA 20178アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 703 371 3043\nEMail: joel.halpern@ericsson.com",
      "raw": true,
      "ja": ""
    }
  ]
}