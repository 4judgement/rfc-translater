{
  "title": {
    "text": "RFC 7925 - Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things",
    "ja": "RFC 7925 - モノのインターネット向けのトランスポート層セキュリティ（TLS）/データグラムトランスポート層セキュリティ（DTLS）プロファイル"
  },
  "number": 7925,
  "created_at": "2020-08-29 13:07:00.753940+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                H. Tschofenig, Ed.\nRequest for Comments: 7925                                      ARM Ltd.\nCategory: Standards Track                                     T. Fossati\nISSN: 2070-1721                                                    Nokia\n                                                               July 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": " Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things",
      "ja": "モノのインターネット向けのトランスポート層セキュリティ（TLS）/データグラムトランスポート層セキュリティ（DTLS）プロファイル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "A common design pattern in Internet of Things (IoT) deployments is the use of a constrained device that collects data via sensors or controls actuators for use in home automation, industrial control systems, smart cities, and other IoT deployments.",
      "ja": "モノのインターネット（IoT）展開の一般的な設計パターンは、センサーを介してデータを収集するか、アクチュエーターを制御して、ホームオートメーション、産業用制御システム、スマートシティ、およびその他のIoT展開で使用する制約付きデバイスの使用です。"
    },
    {
      "indent": 3,
      "text": "This document defines a Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) 1.2 profile that offers communications security for this data exchange thereby preventing eavesdropping, tampering, and message forgery. The lack of communication security is a common vulnerability in IoT products that can easily be solved by using these well-researched and widely deployed Internet security protocols.",
      "ja": "このドキュメントでは、このデータ交換に通信セキュリティを提供し、盗聴、改ざん、およびメッセージの偽造を防止するトランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）1.2プロファイルを定義します。通信セキュリティの欠如は、よく研究され広く配備されているインターネットセキュリティプロトコルを使用することで簡単に解決できるIoT製品の一般的な脆弱性です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7925.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7925で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  TLS and DTLS  . . . . . . . . . . . . . . . . . . . . . .   5\n  3.2.  Communication Models  . . . . . . . . . . . . . . . . . .   6\n  3.3.  The Ciphersuite Concept . . . . . . . . . . . . . . . . .  20\n4.  Credential Types  . . . . . . . . . . . . . . . . . . . . . .  21\n  4.1.  Preconditions . . . . . . . . . . . . . . . . . . . . . .  21\n  4.2.  Pre-Shared Secret . . . . . . . . . . . . . . . . . . . .  23\n  4.3.  Raw Public Key  . . . . . . . . . . . . . . . . . . . . .  25\n  4.4.  Certificates  . . . . . . . . . . . . . . . . . . . . . .  27\n5.  Signature Algorithm Extension . . . . . . . . . . . . . . . .  32\n6.  Error Handling  . . . . . . . . . . . . . . . . . . . . . . .  32\n7.  Session Resumption  . . . . . . . . . . . . . . . . . . . . .  34\n8.  Compression . . . . . . . . . . . . . . . . . . . . . . . . .  35\n9.  Perfect Forward Secrecy . . . . . . . . . . . . . . . . . . .  35\n10. Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n11. Timeouts  . . . . . . . . . . . . . . . . . . . . . . . . . .  38\n12. Random Number Generation  . . . . . . . . . . . . . . . . . .  39\n13. Truncated MAC and Encrypt-then-MAC Extension  . . . . . . . .  40\n14. Server Name Indication (SNI)  . . . . . . . . . . . . . . . .  40\n15. Maximum Fragment Length Negotiation . . . . . . . . . . . . .  41\n16. Session Hash  . . . . . . . . . . . . . . . . . . . . . . . .  41\n17. Renegotiation Attacks . . . . . . . . . . . . . . . . . . . .  42\n18. Downgrading Attacks . . . . . . . . . . . . . . . . . . . . .  42\n19. Crypto Agility  . . . . . . . . . . . . . . . . . . . . . . .  43\n20. Key Length Recommendations  . . . . . . . . . . . . . . . . .  44\n21. False Start . . . . . . . . . . . . . . . . . . . . . . . . .  45\n22. Privacy Considerations  . . . . . . . . . . . . . . . . . . .  45\n23. Security Considerations . . . . . . . . . . . . . . . . . . .  46\n24. References  . . . . . . . . . . . . . . . . . . . . . . . . .  47\n  24.1.  Normative References . . . . . . . . . . . . . . . . . .  47\n  24.2.  Informative References . . . . . . . . . . . . . . . . .  48\nAppendix A.  Conveying DTLS over SMS  . . . . . . . . . . . . . .  56\n  A.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  56\n  A.2.  Message Segmentation and Reassembly . . . . . . . . . . .  57\n  A.3.  Multiplexing Security Associations  . . . . . . . . . . .  57\n  A.4.  Timeout . . . . . . . . . . . . . . . . . . . . . . . . .  58\nAppendix B.  DTLS Record Layer Per-Packet Overhead  . . . . . . .  59\nAppendix C.  DTLS Fragmentation . . . . . . . . . . . . . . . . .  60\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  60\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  61",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "An engineer developing an Internet of Things (IoT) device needs to investigate the security threats and decide about the security services that can be used to mitigate these threats.",
      "ja": "モノのインターネット（IoT）デバイスを開発するエンジニアは、セキュリティの脅威を調査し、これらの脅威を軽減するために使用できるセキュリティサービスについて決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Enabling IoT devices to exchange data often requires authentication of the two endpoints and the ability to provide integrity and confidentiality protection of exchanged data. While these security services can be provided at different layers in the protocol stack, the use of Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) has been very popular with many application protocols, and it is likely to be useful for IoT scenarios as well.",
      "ja": "多くの場合、IoTデバイスがデータを交換できるようにするには、2つのエンドポイントの認証と、交換されたデータの整合性と機密保護を提供する機能が必要です。これらのセキュリティサービスはプロトコルスタックのさまざまな層で提供できますが、トランスポート層セキュリティ（TLS）/データグラムトランスポート層セキュリティ（DTLS）の使用は多くのアプリケーションプロトコルで非常に人気があり、IoTに役立つ可能性が高いですシナリオも。"
    },
    {
      "indent": 3,
      "text": "Fitting Internet protocols into constrained devices can be difficult, but thanks to the standardization efforts, new profiles and protocols are available, such as the Constrained Application Protocol (CoAP) [RFC7252]. CoAP messages are mainly carried over UDP/DTLS, but other transports can be utilized, such as SMS (as described in Appendix A) or TCP (as currently being proposed with [COAP-TCP-TLS]).",
      "ja": "制約のあるデバイスにインターネットプロトコルを適合させることは困難な場合がありますが、標準化の取り組みのおかげで、制約付きアプリケーションプロトコル（CoAP）[RFC7252]などの新しいプロファイルとプロトコルを利用できます。 CoAPメッセージは主にUDP / DTLSを介して伝送されますが、SMS（付録Aで説明）またはTCP（[COAP-TCP-TLS]で現在提案されている）などの他のトランスポートを利用できます。"
    },
    {
      "indent": 3,
      "text": "While the main goal for this document is to protect CoAP messages using DTLS 1.2 [RFC6347], the information contained in the following sections is not limited to CoAP nor to DTLS itself.",
      "ja": "このドキュメントの主な目的は、DTLS 1.2 [RFC6347]を使用してCoAPメッセージを保護することですが、以下のセクションに含まれる情報は、CoAPにもDTLS自体にも限定されません。"
    },
    {
      "indent": 3,
      "text": "Instead, this document defines a profile of DTLS 1.2 [RFC6347] and TLS 1.2 [RFC5246] that offers communication security services for IoT applications and is reasonably implementable on many constrained devices. Profile thereby means that available configuration options and protocol extensions are utilized to best support the IoT environment. This document does not alter TLS/DTLS specifications and does not introduce any new TLS/DTLS extension.",
      "ja": "代わりに、このドキュメントは、IoTアプリケーションに通信セキュリティサービスを提供し、多くの制約されたデバイスに合理的に実装可能なDTLS 1.2 [RFC6347]およびTLS 1.2 [RFC5246]のプロファイルを定義します。したがって、プロファイルは、使用可能な構成オプションとプロトコル拡張がIoT環境を最もよくサポートするために利用されることを意味します。このドキュメントはTLS / DTLS仕様を変更せず、新しいTLS / DTLS拡張機能を紹介しません。"
    },
    {
      "indent": 3,
      "text": "The main target audience for this document is the embedded system developer configuring and using a TLS/DTLS stack. This document may, however, also help those developing or selecting a suitable TLS/DTLS stack for an IoT product. If you are familiar with (D)TLS, then skip ahead to Section 4.",
      "ja": "このドキュメントの主な対象読者は、TLS / DTLSスタックを構成して使用する組み込みシステム開発者です。ただし、このドキュメントは、IoT製品に適したTLS / DTLSスタックを開発または選択するユーザーにも役立つ場合があります。 （D）TLSに精通している場合は、セクション4に進んでください。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの \"は、RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification refers to TLS as well as DTLS and particularly to version 1.2, which is the most recent version at the time of writing.",
      "ja": "この仕様は、TLSとDTLSに言及し、特に、執筆時点での最新バージョンであるバージョン1.2に言及しています。"
    },
    {
      "indent": 3,
      "text": "We refer to TLS/DTLS whenever the text is applicable to both versions of the protocol and to TLS or DTLS when there are differences between the two protocols. Note that TLS 1.3 is being developed, but it is not expected that this profile will \"just work\" due to the significant changes being done to TLS for version 1.3.",
      "ja": "テキストがプロトコルの両方のバージョンに適用できる場合は常にTLS / DTLSを参照し、2つのプロトコルの間に相違がある場合はTLSまたはDTLSを参照します。 TLS 1.3は開発中ですが、バージョン1.3のTLSに大幅な変更が加えられているため、このプロファイルが「そのまま機能する」とは予想されていません。"
    },
    {
      "indent": 3,
      "text": "Note that \"client\" and \"server\" in this document refer to TLS/DTLS roles, where the client initiates the handshake. This does not restrict the interaction pattern of the protocols on top of DTLS since the record layer allows bidirectional communication. This aspect is further described in Section 3.2.",
      "ja": "このドキュメントの「クライアント」と「サーバー」は、クライアントがハンドシェイクを開始するTLS / DTLSロールを指すことに注意してください。レコードレイヤーは双方向通信を許可するため、これはDTLS上のプロトコルの相互作用パターンを制限しません。この点については、セクション3.2で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "RFC 7228 [RFC7228] introduces the notion of constrained-node networks, which are made of small devices with severe constraints on power, memory, and processing resources. The terms constrained devices and IoT devices are used interchangeably.",
      "ja": "RFC 7228 [RFC7228]は、電力、メモリ、および処理リソースに厳しい制約がある小さなデバイスで構成される制約付きノードネットワークの概念を導入しています。制約付きデバイスとIoTデバイスは同じ意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "The terms \"certification authority\" (CA) and \"distinguished name\" (DN) are taken from [RFC5280]. The terms \"trust anchor\" and \"trust anchor store\" are defined in [RFC6024] as:",
      "ja": "「認証局」（CA）および「識別名」（DN）という用語は、[RFC5280]からとられています。 「トラストアンカー」および「トラストアンカーストア」という用語は、[RFC6024]で次のように定義されています。"
    },
    {
      "indent": 6,
      "text": "A trust anchor represents an authoritative entity via a public key and associated data. The public key is used to verify digital signatures, and the associated data is used to constrain the types of information for which the trust anchor is authoritative.",
      "ja": "トラストアンカーは、公開キーと関連データを介して信頼できるエンティティを表します。公開鍵はデジタル署名を検証するために使用され、関連データはトラストアンカーが信頼できる情報のタイプを制約するために使用されます。"
    },
    {
      "indent": 6,
      "text": "A trust anchor store is a set of one or more trust anchors stored\nin a device.... A device may have more than one trust anchor\nstore, each of which may be used by one or more applications.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概観"
    },
    {
      "indent": 0,
      "text": "3.1. TLS and DTLS",
      "section_title": true,
      "ja": "3.1. TLSおよびDTLS"
    },
    {
      "indent": 3,
      "text": "The TLS protocol [RFC5246] provides authenticated, confidentiality-and integrity-protected communication between two endpoints. The protocol is composed of two layers: the Record Protocol and the handshaking protocols. At the lowest level, layered on top of a reliable transport protocol (e.g., TCP), is the Record Protocol. It provides connection security by using symmetric cryptography for confidentiality, data origin authentication, and integrity protection. The Record Protocol is used for encapsulation of various higher-level protocols. The handshaking protocols consist of three subprotocols -- namely, the handshake protocol, the change cipher spec protocol, and the alert protocol. The handshake protocol allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives data.",
      "ja": "TLSプロトコル[RFC5246]は、2つのエンドポイント間で認証され、機密性と整合性が保護された通信を提供します。プロトコルは、レコードプロトコルとハンドシェイクプロトコルの2つの層で構成されています。最下位レベルでは、信頼できるトランスポートプロトコル（TCPなど）の上に階層化されているのがレコードプロトコルです。機密性、データ発信元認証、および整合性保護のために対称暗号を使用することにより、接続セキュリティを提供します。 Record Protocolは、さまざまな上位プロトコルのカプセル化に使用されます。ハンドシェイクプロトコルは、3つのサブプロトコル（ハンドシェイクプロトコル、暗号仕様変更プロトコル、アラートプロトコル）で構成されています。ハンドシェイクプロトコルにより、サーバーとクライアントは相互に認証し、アプリケーションプロトコルがデータを送受信する前に暗号化アルゴリズムと暗号化キーをネゴシエートできます。"
    },
    {
      "indent": 3,
      "text": "The design of DTLS [RFC6347] is intentionally very similar to TLS. However, since DTLS operates on top of an unreliable datagram transport, it must explicitly cope with the absence of reliable and ordered delivery assumptions made by TLS. RFC 6347 explains these differences in great detail. As a short summary, for those not familiar with DTLS, the differences are:",
      "ja": "DTLS [RFC6347]の設計は、意図的にTLSに非常に似ています。ただし、DTLSは信頼性の低いデータグラムトランスポート上で動作するため、TLSによる信頼性の高い順序付けられた配信の前提条件が存在しないことに明示的に対処する必要があります。 RFC 6347はこれらの違いを非常に詳細に説明しています。簡単にまとめると、DTLSに慣れていない人のために、違いは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o An explicit sequence number and an epoch field is included in the Record Protocol. Section 4.1 of RFC 6347 explains the processing rules for these two new fields. The value used to compute the Message Authentication Code (MAC) is the 64-bit value formed by concatenating the epoch and the sequence number.",
      "ja": "o 明示的なシーケンス番号とエポックフィールドは、レコードプロトコルに含まれています。 RFC 6347のセクション4.1では、これら2つの新しいフィールドの処理ルールについて説明しています。メッセージ認証コード（MAC）の計算に使用される値は、エポックとシーケンス番号を連結して形成される64ビット値です。"
    },
    {
      "indent": 3,
      "text": "o Stream ciphers must not be used with DTLS. The only stream cipher defined for TLS 1.2 is RC4, and due to cryptographic weaknesses, it is not recommended anymore even for use with TLS [RFC7465]. Note that the term \"stream cipher\" is a technical term in the TLS specification. Section 4.7 of RFC 5246 defines stream ciphers in TLS as follows: \"In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.\"",
      "ja": "o ストリーム暗号はDTLSでは使用できません。 TLS 1.2に対して定義されている唯一のストリーム暗号はRC4であり、暗号の脆弱性のため、TLS [RFC7465]で使用することも推奨されなくなりました。 「ストリーム暗号」という用語は、TLS仕様の技術用語であることに注意してください。 RFC 5246のセクション4.7は、TLSでのストリーム暗号を次のように定義しています。"
    },
    {
      "indent": 3,
      "text": "o The TLS handshake protocol has been enhanced to include a stateless cookie exchange for Denial-of-Service (DoS) resistance. For this purpose, a new handshake message, the HelloVerifyRequest, was added to DTLS. This handshake message is sent by the server and includes a stateless cookie, which is returned in a ClientHello message back to the server. Although the exchange is optional for the server to execute, a client implementation has to be prepared to respond to it. Furthermore, the handshake message format has been extended to deal with message loss, reordering, and fragmentation.",
      "ja": "o TLSハンドシェイクプロトコルは、サービス拒否（DoS）耐性のためのステートレスCookie交換を含むように拡張されました。この目的のために、新しいハンドシェイクメッセージであるHelloVerifyRequestがDTLSに追加されました。このハンドシェイクメッセージはサーバーによって送信され、ClientHelloメッセージでサーバーに返されるステートレスCookieが含まれます。サーバーが実行する交換はオプションですが、クライアントの実装はそれに応答するように準備する必要があります。さらに、ハンドシェイクメッセージ形式は、メッセージの損失、並べ替え、および断片化に対処するために拡張されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Communication Models",
      "section_title": true,
      "ja": "3.2. コミュニケーションモデル"
    },
    {
      "indent": 3,
      "text": "This document describes a profile of DTLS and, to be useful, it has to make assumptions about the envisioned communication architecture.",
      "ja": "このドキュメントでは、DTLSのプロファイルについて説明します。DTLSが役立つためには、想定される通信アーキテクチャについて想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Two communication architectures (and consequently two profiles) are described in this document.",
      "ja": "このドキュメントでは、2つの通信アーキテクチャ（およびその結果として2つのプロファイル）について説明します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Constrained TLS/DTLS Clients",
      "section_title": true,
      "ja": "3.2.1. 制約付きTLS / DTLSクライアント"
    },
    {
      "indent": 3,
      "text": "The communication architecture shown in Figure 1 assumes a unicast communication interaction with an IoT device utilizing a constrained TLS/DTLS client interacting with one or multiple TLS/DTLS servers.",
      "ja": "図1に示す通信アーキテクチャーは、1つまたは複数のTLS / DTLSサーバーと対話する制約付きTLS / DTLSクライアントを利用したIoTデバイスとのユニキャスト通信対話を想定しています。"
    },
    {
      "indent": 3,
      "text": "Before a client can initiate the TLS/DTLS handshake, it needs to know the IP address of that server and what credentials to use. Application-layer protocols, such as CoAP, which is conveyed on top of DTLS, may be configured with URIs of the endpoints to which CoAP needs to register and publish data. This configuration information (including non-confidential credentials, like certificates) may be conveyed to clients as part of a firmware/software package or via a configuration protocol. The following credential types are supported by this profile:",
      "ja": "クライアントがTLS / DTLSハンドシェイクを開始する前に、そのサーバーのIPアドレスと使用する資格情報を知る必要があります。 DTLSの上で伝達されるCoAPなどのアプリケーション層プロトコルは、CoAPがデータを登録および公開する必要があるエンドポイントのURIで構成できます。この構成情報（証明書などの非機密の資格情報を含む）は、ファームウェア/ソフトウェアパッケージの一部として、または構成プロトコルを介してクライアントに伝達されます。このプロファイルでは、次の資格情報タイプがサポートされています。"
    },
    {
      "indent": 3,
      "text": "o For authentication based on the Pre-Shared Key (PSK) (see Section 4.2), this includes the paired \"PSK identity\" and shared secret to be used with each server.",
      "ja": "o 事前共有キー（PSK）（セクション4.2を参照）に基づく認証の場合、これには、各サーバーで使用されるペアの「PSK ID」と共有秘密が含まれます。"
    },
    {
      "indent": 3,
      "text": "o For authentication based on the raw public key (see Section 4.3), this includes either the server's public key or the hash of the server's public key.",
      "ja": "o 生の公開鍵に基づく認証（セクション4.3を参照）の場合、これにはサーバーの公開鍵またはサーバーの公開鍵のハッシュが含まれます。"
    },
    {
      "indent": 3,
      "text": "o For certificate-based authentication (see Section 4.4), this includes a pre-populated trust anchor store that allows the DTLS stack to perform path validation for the certificate obtained during the handshake with the server.",
      "ja": "o 証明書ベースの認証（セクション4.4を参照）の場合、これには、DTLSスタックがサーバーとのハンドシェイク中に取得した証明書のパス検証を実行できるようにする事前入力されたトラストアンカーストアが含まれます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows example configuration information stored at the constrained client for use with respective servers.",
      "ja": "図1は、それぞれのサーバーで使用するために、制約付きクライアントに保管されている構成情報の例を示しています。"
    },
    {
      "indent": 3,
      "text": "This document focuses on the description of the DTLS client-side functionality but, quite naturally, the equivalent server-side support has to be available.",
      "ja": "このドキュメントでは、DTLSのクライアント側機能の説明に焦点を当てていますが、当然のことながら、同等のサーバー側サポートが利用可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "           +////////////////////////////////////+\n           |          Configuration             |\n           |////////////////////////////////////|\n           | Server A --> PSK Identity, PSK     |\n           |                                    |\n           | Server B --> Public Key (Server B),|\n           |              Public/Private Key    |\n           |              (for Client)          |\n           |                                    |\n           | Server C --> Public/Private Key    |\n           |              (for Client)          |\n           |              Trust Anchor Store    |\n           +------------------------------------+\n             oo\n       oooooo\n      o\n+-----------+\n|Constrained|\n|TLS/DTLS   |\n|Client     |-\n+-----------+ \\\n               \\  ,-------.\n                ,'         `.            +------+\n               /  IP-Based   \\           |Server|\n              (    Network    )          |  A   |\n               \\             /           +------+\n                `.         ,'\n                  '---+---'                  +------+\n                      |                      |Server|\n                      |                      |  B   |\n                      |                      +------+\n                      |\n                      |                  +------+\n                      +----------------->|Server|\n                                         |  C   |\n                                         +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 1: Constrained Client Profile",
      "ja": "図1：制約付きクライアントプロファイル"
    },
    {
      "indent": 0,
      "text": "3.2.1.1. Examples of Constrained Client Exchanges",
      "section_title": true,
      "ja": "3.2.1.1. 制約付きクライアント交換の例"
    },
    {
      "indent": 0,
      "text": "3.2.1.1.1. Network Access Authentication Example",
      "section_title": true,
      "ja": "3.2.1.1.1. ネットワークアクセス認証の例"
    },
    {
      "indent": 3,
      "text": "Reuse is a recurring theme when considering constrained environments and is behind a lot of the directions taken in developments for constrained environments. The corollary of reuse is to not add functionality if it can be avoided. An example relevant to the use of TLS is network access authentication, which takes place when a device connects to a network and needs to go through an authentication and access control procedure before it is allowed to communicate with other devices or connect to the Internet.",
      "ja": "再利用は、制約された環境を検討する場合に繰り返し発生するテーマであり、制約された環境の開発で取られた多くの指示の背後にあります。再利用の当然の結果は、回避できる場合は機能を追加しないことです。 TLSの使用に関連する例は、ネットワークアクセス認証です。これは、デバイスがネットワークに接続し、他のデバイスとの通信やインターネットへの接続を許可される前に認証およびアクセス制御手順を実行する必要がある場合に行われます。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows the network access architecture with the IoT device initiating the communication to an access point in the network using the procedures defined for a specific physical layer. Since credentials may be managed and stored centrally, in the Authentication, Authorization, and Accounting (AAA) server, the security protocol exchange may need to be relayed via the Authenticator, i.e., functionality running on the access point to the AAA server. The authentication and key exchange protocol itself is encapsulated within a container, the Extensible Authentication Protocol (EAP) [RFC3748], and messages are conveyed back and forth between the EAP endpoints, namely the EAP peer located on the IoT device and the EAP server located on the AAA server or the access point. To route EAP messages from the access point, acting as a AAA client, to the AAA server requires an adequate protocol mechanism, namely RADIUS [RFC2865] or Diameter [RFC6733].",
      "ja": "図2は、特定の物理層に対して定義された手順を使用して、IoTデバイスがネットワーク内のアクセスポイントへの通信を開始するネットワークアクセスアーキテクチャを示しています。資格情報は、認証、承認、およびアカウンティング（AAA）サーバーで一元的に管理および保存できるため、セキュリティプロトコルの交換は、オーセンティケーター、つまりアクセスポイントで実行されている機能を介してAAAサーバーに中継する必要がある場合があります。認証および鍵交換プロトコル自体は、コンテナであるExtensible Authentication Protocol（EAP）[RFC3748]内にカプセル化され、メッセージはEAPエンドポイント、つまりIoTデバイスにあるEAPピアとAAAサーバーまたはアクセスポイント。 AAAクライアントとして機能するアクセスポイントからAAAサーバーにEAPメッセージをルーティングするには、適切なプロトコルメカニズム、つまりRADIUS [RFC2865]またはDiameter [RFC6733]が必要です。"
    },
    {
      "indent": 3,
      "text": "More details about the concepts and a description about the terminology can be found in RFC 5247 [RFC5247].",
      "ja": "概念の詳細と用語の説明は、RFC 5247 [RFC5247]にあります。"
    },
    {
      "indent": 4,
      "text": "                                            +--------------+\n                                            |Authentication|\n                                            |Authorization |\n                                            |Accounting    |\n                                            |Server        |\n                                            |(EAP Server)  |\n                                            |              |\n                                            +-^----------^-+\n                                              * EAP      o RADIUS/\n                                              *          o Diameter\n                                            --v----------v--\n                                         ///                \\\\\\\n                                       //                      \\\\\n                                      |        Federation        |\n                                      |        Substrate         |\n                                       \\\\                      //\n                                         \\\\\\                ///\n                                            --^----------^--\n                                              * EAP      o RADIUS/\n                                              *          o Diameter\n+-------------+                             +-v----------v--+\n|             |      EAP/EAP Method         |               |\n| Internet of |<***************************>| Access Point  |\n| Things      |                             |(Authenticator)|\n| Device      |    EAP Lower Layer and      |(AAA Client)   |\n| (EAP Peer)  | Secure Association Protocol |               |\n|             |<--------------------------->|               |\n|             |                             |               |\n|             |      Physical Layer         |               |\n|             |<===========================>|               |\n+-------------+                             +---------------+\n  Legend:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "<****>: Device-to-AAA-Server Exchange\n<---->: Device-to-Authenticator Exchange\n<oooo>: AAA-Client-to-AAA-Server Exchange\n<====>: Physical layer like IEEE 802.11/802.15.4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 2: Network Access Architecture",
      "ja": "図2：ネットワークアクセスアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "One standardized EAP method is EAP-TLS, defined in RFC 5216 [RFC5216], which reuses the TLS-based protocol exchange and encapsulates it inside the EAP payload. In terms of reuse, this allows many components of the TLS protocol to be shared between the network access security functionality and the TLS functionality needed for securing application-layer traffic. In the EAP-TLS exchange shown in Figure 3, the IoT device as the EAP peer acts as a TLS client.",
      "ja": "標準化された1つのEAP方式は、RFC 5216 [RFC5216]で定義されているEAP-TLSで、TLSベースのプロトコル交換を再利用し、それをEAPペイロード内にカプセル化します。再利用に関しては、これにより、TLSプロトコルの多くのコンポーネントを、ネットワークアクセスセキュリティ機能と、アプリケーション層のトラフィックを保護するために必要なTLS機能との間で共有できます。図3に示すEAP-TLS交換では、EAPピアとしてのIoTデバイスがTLSクライアントとして機能します。"
    },
    {
      "indent": 6,
      "text": "Authenticating Peer     Authenticator\n-------------------     -------------\n                        <- EAP-Request/\n                        Identity\nEAP-Response/\nIdentity (MyID) ->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS Start)\nEAP-Response/\nEAP-Type=EAP-TLS\n(TLS client_hello)->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS server_hello,\n                         TLS certificate,\n                         [TLS server_key_exchange,]\n                         TLS certificate_request,\n                         TLS server_hello_done)\nEAP-Response/\nEAP-Type=EAP-TLS\n(TLS certificate,\n TLS client_key_exchange,\n TLS certificate_verify,\n TLS change_cipher_spec,\n TLS finished) ->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS change_cipher_spec,\n                         TLS finished)\nEAP-Response/\nEAP-Type=EAP-TLS ->\n                        <- EAP-Success",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 3: EAP-TLS Exchange",
      "ja": "図3：EAP-TLS交換"
    },
    {
      "indent": 3,
      "text": "The guidance in this document also applies to the use of EAP-TLS for network access authentication. An IoT device using a network access authentication solution based on TLS can reuse most parts of the code for the use of DTLS/TLS at the application layer, thereby saving a significant amount of flash memory. Note, however, that the credentials used for network access authentication and those used for application-layer security are very likely different.",
      "ja": "このドキュメントのガイダンスは、ネットワークアクセス認証でのEAP-TLSの使用にも適用されます。 TLSに基づくネットワークアクセス認証ソリューションを使用するIoTデバイスは、アプリケーションレイヤーでDTLS / TLSを使用するためにコードのほとんどの部分を再利用できるため、フラッシュメモリを大幅に節約できます。ただし、ネットワークアクセス認証に使用される資格情報とアプリケーション層のセキュリティに使用される資格情報は、非常に異なる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2.1.1.2. CoAP-Based Data Exchange Example",
      "section_title": true,
      "ja": "3.2.1.1.2. CoAPベースのデータ交換の例"
    },
    {
      "indent": 3,
      "text": "When a constrained client uploads sensor data to a server infrastructure, it may use CoAP by pushing the data via a POST message to a preconfigured endpoint on the server. In certain circumstances, this might be too limiting and additional functionality is needed, as shown in Figures 4 and 5, where the IoT device itself runs a CoAP server hosting the resource that is made accessible to other entities. Despite running a CoAP server on the IoT device, it is still the DTLS client on the IoT device that initiates the interaction with the non-constrained resource server in our scenario.",
      "ja": "制約されたクライアントがセンサーデータをサーバーインフラストラクチャにアップロードするとき、サーバーの事前構成されたエンドポイントにPOSTメッセージを介してデータをプッシュすることにより、CoAPを使用できます。特定の状況では、これは制限が多すぎる可能性があり、追加の機能が必要になります。図4および5に示すように、IoTデバイス自体が、他のエンティティからアクセス可能になるリソースをホストするCoAPサーバーを実行します。 IoTデバイスでCoAPサーバーを実行しているにもかかわらず、このシナリオでは、制約のないリソースサーバーとの対話を開始するのは、IoTデバイスのDTLSクライアントです。"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows a sensor starting a DTLS exchange with a resource directory and uses CoAP to register available resources in Figure 5. [CoRE-RD] defines the resource directory (RD) as a web entity that stores information about web resources and implements Representational State Transfer (REST) interfaces for registration and lookup of those resources. Note that the described exchange is borrowed from the Open Mobile Alliance (OMA) Lightweight Machine-to-Machine (LWM2M) specification [LWM2M] that uses RD but adds proxy functionality.",
      "ja": "図4は、センサーがリソースディレクトリとのDTLS交換を開始し、CoAPを使用して図5で利用可能なリソースを登録することを示しています。これらのリソースの登録と検索のための転送（REST）インターフェース。説明されている交換は、RDを使用するがプロキシ機能を追加するOpen Mobile Alliance（OMA）Lightweight Machine-to-Machine（LWM2M）仕様[LWM2M]から借用されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The initial DTLS interaction between the sensor, acting as a DTLS client, and the resource directory, acting as a DTLS server, will be a full DTLS handshake. Once this handshake is complete, both parties have established the DTLS record layer. Subsequently, the CoAP client can securely register at the resource directory.",
      "ja": "DTLSクライアントとして機能するセンサーとDTLSサーバーとして機能するリソースディレクトリの間の最初のDTLS対話は、完全なDTLSハンドシェイクになります。このハンドシェイクが完了すると、両方の当事者がDTLSレコード層を確立しました。その後、CoAPクライアントはリソースディレクトリに安全に登録できます。"
    },
    {
      "indent": 3,
      "text": "After some time (assuming that the client regularly refreshes its registration), the resource directory receives a request from an application to retrieve the temperature information from the sensor. This request is relayed by the resource directory to the sensor using a GET message exchange. The already established DTLS record layer can be used to secure the message exchange.",
      "ja": "しばらくすると（クライアントが定期的に登録を更新すると想定）、リソースディレクトリはアプリケーションからリクエストを受け取り、センサーから温度情報を取得します。このリクエストは、GETメッセージ交換を使用してリソースディレクトリからセンサーにリレーされます。すでに確立されているDTLSレコード層を使用して、メッセージ交換を保護できます。"
    },
    {
      "indent": 7,
      "text": "                                             Resource\nSensor                                       Directory\n------                                       ---------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " +---\n |\n | ClientHello             -------->\n | #client_certificate_type#\nF| #server_certificate_type#\nU|\nL|                         <-------    HelloVerifyRequest\nL|\n | ClientHello             -------->\nD| #client_certificate_type#\nT| #server_certificate_type#\nL|\nS|                                            ServerHello\n |                               #client_certificate_type#\nH|                               #server_certificate_type#\nA|                                            Certificate\nN|                                      ServerKeyExchange\nD|                                     CertificateRequest\nS|                         <--------      ServerHelloDone\nH|\nA| Certificate\nK| ClientKeyExchange\nE| CertificateVerify\n | [ChangeCipherSpec]\n | Finished                -------->\n |\n |                                     [ChangeCipherSpec]\n |                         <--------             Finished\n +---",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Note: Extensions marked with \"#\" were introduced with RFC 7250.",
      "ja": "注：「＃」でマークされた拡張機能は、RFC 7250で導入されました。"
    },
    {
      "indent": 10,
      "text": "Figure 4: DTLS/CoAP Exchange Using Resource Directory:\n               Part 1 -- DTLS Handshake",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 5 shows the DTLS-secured communication between the sensor and the resource directory using CoAP.",
      "ja": "図5は、CoAPを使用したセンサーとリソースディレクトリ間のDTLSで保護された通信を示しています。"
    },
    {
      "indent": 7,
      "text": "                                             Resource\nSensor                                       Directory\n------                                       ---------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[[==============DTLS-Secured Communication===================]]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " +---                                                  ///+\nC|                                                        \\ D\nO| Req: POST coap://rd.example.com/rd?ep=node1            \\ T\nA| Payload:                                               \\ L\nP| </temp>;ct=41;                                         \\ S\n |    rt=\"temperature-c\";if=\"sensor\",                     \\\nR| </light>;ct=41;                                        \\ R\nD|    rt=\"light-lux\";if=\"sensor\"                          \\ E\n |                         -------->                      \\ C\nR|                                                        \\ O\nE|                                                        \\ R\nG|                                     Res: 2.01 Created  \\ D\n |                         <--------  Location: /rd/4521  \\\n |                                                        \\ L\n +---                                                     \\ A\n                                                          \\ Y\n                          *                               \\ E\n                          * (time passes)                 \\ R\n                          *                               \\\n +---                                                     \\ P\nC|                                                        \\ R\nO|              Req: GET coaps://sensor.example.com/temp  \\ O\nA|                         <--------                      \\ T\nP|                                                        \\ E\n | Res:  2.05 Content                                     \\ C\nG| Payload:                                               \\ T\nE| 25.5                     -------->                     \\ E\nT|                                                        \\ D\n +---                                                  ///+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 5: DTLS/CoAP Exchange Using Resource Directory:\n              Part 2 -- CoAP/RD Exchange",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the CoAP GET message transmitted from the resource server is protected using the previously established DTLS record layer.",
      "ja": "リソースサーバーから送信されたCoAP GETメッセージは、以前に確立されたDTLSレコードレイヤーを使用して保護されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Constrained TLS/DTLS Servers",
      "section_title": true,
      "ja": "3.2.2. 制約付きTLS / DTLSサーバー"
    },
    {
      "indent": 3,
      "text": "Section 3.2.1 illustrates a deployment model where the TLS/DTLS client is constrained and efforts need to be taken to improve memory utilization, bandwidth consumption, reduce performance impacts, etc. In this section, we assume a scenario where constrained devices run TLS/DTLS servers to secure access to application-layer services running on top of CoAP, HTTP, or other protocols. Figure 6 illustrates a possible deployment whereby a number of constrained servers are waiting for regular clients to access their resources. The entire process is likely, but not necessarily, controlled by a third party, the authentication and authorization server. This authentication and authorization server is responsible for holding authorization policies that govern the access to resources and distribution of keying material.",
      "ja": "セクション3.2.1は、TLS / DTLSクライアントが制約され、メモリ使用率、帯域幅の消費を改善し、パフォーマンスへの影響を軽減するなどの努力が必要な配備モデルを示しています。このセクションでは、制約されたデバイスがTLS / CoAP、HTTP、またはその他のプロトコル上で実行されているアプリケーション層サービスへのアクセスを保護するためのDTLSサーバー。図6は、いくつかの制約されたサーバーが、通常のクライアントがリソースにアクセスするのを待機している可能な配置を示しています。プロセス全体は、サードパーティの認証および承認サーバーによって制御される可能性がありますが、必ずしもそうとは限りません。この認証および承認サーバーは、リソースへのアクセスとキー情報の配布を管理する承認ポリシーを保持する責任があります。"
    },
    {
      "indent": 3,
      "text": "         +////////////////////////////////////+\n         |          Configuration             |\n         |////////////////////////////////////|\n         | Credentials                        |\n         |    Client A  -> Public Key         |\n         |    Server S1 -> Symmetric Key      |\n         |    Server S2 -> Certificate        |\n         |    Server S3 -> Public Key         |\n         | Trust Anchor Store                 |\n         | Access Control Lists               |\n         |    Resource X: Client A / GET      |\n         |    Resource Y: Client A / PUT      |\n         +------------------------------------+\n             oo\n       oooooo\n      o\n+---------------+                +-----------+\n|Authentication |      +-------->|TLS/DTLS   |\n|& Authorization|      |         |Client A   |\n|Server         |      |         +-----------+\n+---------------+     ++\n             ^        |                  +-----------+\n              \\       |                  |Constrained|\n               \\  ,-------.              | Server S1 |\n                ,'         `.            +-----------+\n               /    Local    \\\n              (    Network    )\n               \\             /        +-----------+\n                `.         ,'         |Constrained|\n                  '---+---'           | Server S2 |\n                      |               +-----------+\n                      |\n                      |                   +-----------+\n                      +-----------------> |Constrained|\n                                          | Server S3 |\n                                          +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 6: Constrained Server Profile",
      "ja": "図6：制約付きサーバープロファイル"
    },
    {
      "indent": 3,
      "text": "A deployment with constrained servers has to overcome several challenges. Below we explain how these challenges can be solved with CoAP, as an example. Other protocols may offer similar capabilities. While the requirements for the TLS/DTLS protocol profile change only slightly when run on a constrained server (in comparison to running it on a constrained client), several other ecosystem factors will impact deployment.",
      "ja": "制約のあるサーバーを使用した展開では、いくつかの課題を克服する必要があります。以下では、例として、CoAPを使用してこれらの課題を解決する方法を説明します。他のプロトコルが同様の機能を提供する場合があります。 TLS / DTLSプロトコルプロファイルの要件は、制約付きサーバーで実行した場合（制約付きクライアントで実行した場合と比較して）ほんのわずかしか変化しませんが、他のいくつかのエコシステム要素が展開に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "There are several challenges that need to be addressed:",
      "ja": "対処する必要があるいくつかの課題があります。"
    },
    {
      "indent": 3,
      "text": "Discovery and Reachability:",
      "ja": "発見と到達可能性："
    },
    {
      "indent": 6,
      "text": "A client must first and foremost discover the server before initiating a connection to it. Once it has been discovered, reachability to the device needs to be maintained.",
      "ja": "クライアントは、サーバーへの接続を開始する前に、まずサーバーを検出する必要があります。発見されたら、デバイスへの到達可能性を維持する必要があります。"
    },
    {
      "indent": 6,
      "text": "In CoAP, the discovery of resources offered by servers is accomplished by sending a unicast or multicast CoAP GET to a well-known URI. The Constrained RESTful Environments (CoRE) Link Format specification [RFC6690] describes the use case (see Section 1.2.1) and reserves the URI (see Section 7.1). Section 7 of the CoAP specification [RFC7252] describes the discovery procedure. [RFC7390] describes the use case for discovering CoAP servers using multicast (see Section 3.3) and specifies the protocol processing rules for CoAP group communications (see Section 2.7).",
      "ja": "CoAPでは、サーバーによって提供されるリソースの検出は、既知のURIにユニキャストまたはマルチキャストCoAP GETを送信することによって行われます。制約付きRESTful環境（CoRE）リンク形式の仕様[RFC6690]は、ユースケースを記述し（セクション1.2.1を参照）、URIを予約します（セクション7.1を参照）。 CoAP仕様[RFC7252]のセクション7では、検出手順について説明しています。 [RFC7390]は、マルチキャスト（セクション3.3を参照）を使用してCoAPサーバーを検出するための使用例を説明し、CoAPグループ通信（セクション2.7を参照）のプロトコル処理ルールを指定します。"
    },
    {
      "indent": 6,
      "text": "The use of RD [CoRE-RD] is yet another possibility for discovering registered servers and their resources. Since RD is usually not a proxy, clients can discover links registered with the RD and then access them directly.",
      "ja": "RD [CoRE-RD]の使用は、登録済みサーバーとそのリソースを検出するためのもう1つの可能性です。通常、RDはプロキシではないため、クライアントはRDに登録されているリンクを検出し、それらに直接アクセスできます。"
    },
    {
      "indent": 3,
      "text": "Authentication:",
      "ja": "認証："
    },
    {
      "indent": 6,
      "text": "The next challenge concerns the provisioning of authentication credentials to the clients as well as servers. In Section 3.2.1, we assume that credentials (and other configuration information) are provisioned to the device, and that those can be used with the authorization servers. Of course, this leads to a very static relationship between the clients and their server-side infrastructure but poses fewer challenges from a deployment point of view, as described in Section 2 of [RFC7452]. In any case, engineers and product designers have to determine how the relevant credentials are distributed to the respective parties. For example, shared secrets may need to be provisioned to clients and the constrained servers for subsequent use of TLS/DTLS PSK. In other deployments, certificates, private keys, and trust anchors for use with certificate-based authentication may need to be utilized.",
      "ja": "次の課題は、クライアントとサーバーへの認証資格情報のプロビジョニングに関するものです。セクション3.2.1では、資格情報（およびその他の構成情報）がデバイスにプロビジョニングされており、それらを認証サーバーで使用できると想定しています。 [RFC7452]のセクション2で説明されているように、これはクライアントとサーバー側インフラストラクチャの間の非常に静的な関係につながりますが、デプロイメントの観点から見ると、課題は少なくなります。いずれの場合も、エンジニアと製品設計者は、関連する資格情報がそれぞれの関係者にどのように配布されるかを決定する必要があります。たとえば、TLS / DTLS PSKを後で使用するには、共有シークレットをクライアントと制約付きサーバーにプロビジョニングする必要がある場合があります。他の展開では、証明書ベースの認証で使用する証明書、秘密鍵、トラストアンカーを使用する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": " Practical solutions use either pairing (also called imprinting) or a trusted third party. With pairing, two devices execute a special protocol exchange that is unauthenticated to establish a shared key (for example, using an unauthenticated Diffie-Hellman (DH) exchange). To avoid man-in-the-middle attacks, an out-of-band channel is used to verify that nobody has tampered with the exchanged protocol messages. This out-of-band channel can come in many forms, including:",
      "ja": "実用的なソリューションでは、ペアリング（インプリンティングとも呼ばれます）または信頼できるサードパーティを使用します。ペアリングでは、2つのデバイスが認証されていない特別なプロトコル交換を実行して、共有キーを確立します（たとえば、認証されていないDiffie-Hellman（DH）交換を使用）。中間者攻撃を回避するために、帯域外チャネルを使用して、交換されたプロトコルメッセージが改ざんされていないことを確認します。この帯域外チャネルは、次のようなさまざまな形式で提供されます。"
    },
    {
      "indent": 6,
      "text": "* Human involvement by comparing hashed keys, entering passkeys, and scanning QR codes",
      "ja": "* ハッシュされたキーの比較、パスキーの入力、QRコードのスキャンによる人間の関与"
    },
    {
      "indent": 6,
      "text": "* The use of alternative wireless communication channels (e.g., infrared communication in addition to Wi-Fi)",
      "ja": "* 代替ワイヤレス通信チャネルの使用（例：Wi-Fiに加えて赤外線通信）"
    },
    {
      "indent": 6,
      "text": "* Proximity-based information",
      "ja": "* 近接ベースの情報"
    },
    {
      "indent": 6,
      "text": "More details about these different pairing/imprinting techniques can be found in the Smart Object Security Workshop report [RFC7397] and various position papers submitted on that topic, such as [ImprintingSurvey]. The use of a trusted third party follows a different approach and is subject to ongoing standardization efforts in the Authentication and Authorization for Constrained Environments (ACE) working group [ACE-WG].",
      "ja": "これらのさまざまなペアリング/インプリンティング手法の詳細については、スマートオブジェクトセキュリティワークショップレポート[RFC7397]と、そのトピックについて提出されたさまざまなポジションペーパー（[ImprintingSurvey]など）を参照してください。信頼できるサードパーティの使用は異なるアプローチに従い、制約付き環境の認証と承認（ACE）ワーキンググループ[ACE-WG]で進行中の標準化の取り組みの対象となります。"
    },
    {
      "indent": 3,
      "text": "Authorization",
      "ja": "認可"
    },
    {
      "indent": 6,
      "text": "The last challenge is the ability for the constrained server to make an authorization decision when clients access protected resources. Pre-provisioning access control information to constrained servers may be one option but works only in a small scale, less dynamic environment. For a finer-grained and more dynamic access control solution, the reader is referred to the ongoing work in the IETF ACE working group.",
      "ja": "最後の課題は、クライアントが保護されたリソースにアクセスするときに、制約されたサーバーが承認を決定する機能です。制約されたサーバーへのアクセス制御情報の事前プロビジョニングは1つのオプションですが、小規模で動的でない環境でのみ機能します。よりきめ細かく、より動的なアクセス制御ソリューションについては、読者はIETF ACEワーキンググループで進行中の作業を参照されます。"
    },
    {
      "indent": 3,
      "text": "Figure 7 shows an example interaction whereby a device, a thermostat in our case, searches in the local network for discoverable resources and accesses those. The thermostat starts the procedure using a link-local discovery message using the \"All CoAP Nodes\" multicast address by utilizing the link format per RFC 6690 [RFC6690]. The IPv6 multicast address used for CoAP link-local discovery is FF02::FD. As a result, a temperature sensor and a fan respond. These responses allow the thermostat to subsequently read temperature information from the temperature sensor with a CoAP GET request issued to the previously learned endpoint. In this example we assume that accessing the temperature sensor readings and controlling the fan requires authentication and authorization of the thermostat and TLS is used to authenticate both endpoints and to secure the communication.",
      "ja": "図7は、デバイス（この例ではサーモスタット）がローカルネットワークで検出可能なリソースを検索し、それらにアクセスする例の相互作用を示しています。サーモスタットは、RFC 6690 [RFC6690]のリンク形式を利用して、「All CoAP Nodes」マルチキャストアドレスを使用するリンクローカルディスカバリメッセージを使用して手順を開始します。 CoAPリンクローカルディスカバリに使用されるIPv6マルチキャストアドレスはFF02 :: FDです。その結果、温度センサーとファンが応答します。これらの応答により、サーモスタットは、以前に学習したエンドポイントに発行されたCoAP GET要求を使用して、温度センサーから温度情報を読み取ることができます。この例では、温度センサーの読み取り値にアクセスしてファンを制御するために、サーモスタットの認証と承認が必要であり、TLSを使用して両方のエンドポイントを認証し、通信を保護すると想定しています。"
    },
    {
      "indent": 5,
      "text": "                            Temperature\nThermostat                     Sensor              Fan\n----------                   ---------             ---",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Discovery\n-------------------->\nGET coap://[FF02::FD]/.well-known/core",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "               CoAP 2.05 Content\n<-------------------------------\n</3303/0/5700>;rt=\"temperature\";\n               if=\"sensor\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                                  CoAP 2.05 Content\n<--------------------------------------------------\n                     </fan>;rt=\"fan\";if=\"actuation\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\\ Protocol steps to obtain access token or keying        /\n\\ material for access to the temperature sensor and fan. /\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Read Sensor Data\n(authenticated/authorized)\n------------------------------->\nGET /3303/0/5700",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "               CoAP 2.05 Content\n<-------------------------------\n                          22.5 C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Configure Actuator\n(authenticated/authorized)\n------------------------------------------------->\nPUT /fan?on-off=true\n                                 CoAP 2.04 Changed\n<-------------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 7: Local Discovery and Resource Access",
      "ja": "図7：ローカル検出とリソースアクセス"
    },
    {
      "indent": 0,
      "text": "3.3. The Ciphersuite Concept",
      "section_title": true,
      "ja": "3.3. Ciphersuiteのコンセプト"
    },
    {
      "indent": 3,
      "text": "TLS (and consequently DTLS) support ciphersuites, and an IANA registry [IANA-TLS] was created to register the suites. A ciphersuite (and the specification that defines it) contains the following information:",
      "ja": "TLS（およびその結果DTLS）は暗号スイートをサポートし、スイートを登録するためにIANAレジストリ[IANA-TLS]が作成されました。暗号スイート（およびそれを定義する仕様）には、次の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Authentication and key exchange algorithm (e.g., PSK)",
      "ja": "o 認証および鍵交換アルゴリズム（PSKなど）"
    },
    {
      "indent": 3,
      "text": "o Cipher and key length (e.g., Advanced Encryption Standard (AES) with 128-bit keys [AES])",
      "ja": "o 暗号とキーの長さ（128ビットキーを使用したAdvanced Encryption Standard（AES）[AES]など）"
    },
    {
      "indent": 3,
      "text": "o Mode of operation (e.g., Counter with CBC-MAC (CCM) mode for AES) [RFC3610]",
      "ja": "o 動作モード（AESのCBC-MAC（CCM）モードのカウンターなど）[RFC3610]"
    },
    {
      "indent": 3,
      "text": "o Hash algorithm for integrity protection, such as the Secure Hash Algorithm (SHA) in combination with Keyed-Hashing for Message Authentication (HMAC) (see [RFC2104] and [RFC6234])",
      "ja": "o Secure Hash Algorithm（SHA）とKeyed-Hashing for Message Authentication（HMAC）（[RFC2104]および[RFC6234]を参照）を組み合わせた、整合性保護のためのハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "o Hash algorithm for use with pseudorandom functions (e.g., HMAC with the SHA-256)",
      "ja": "o 擬似ランダム関数で使用するハッシュアルゴリズム（SHA-256を使用したHMACなど）"
    },
    {
      "indent": 3,
      "text": "o Misc information (e.g., length of authentication tags)",
      "ja": "o その他の情報（認証タグの長さなど）"
    },
    {
      "indent": 3,
      "text": "o Information whether the ciphersuite is suitable for DTLS or only for TLS",
      "ja": "o 暗号スイートがDTLSに適しているか、TLSにの​​み適しているかに関する情報"
    },
    {
      "indent": 3,
      "text": "The TLS ciphersuite TLS_PSK_WITH_AES_128_CCM_8, for example, uses a pre-shared authentication and key exchange algorithm. [RFC6655] defines this ciphersuite. It uses the AES encryption algorithm, which is a block cipher. Since the AES algorithm supports different key lengths (such as 128, 192, and 256 bits), this information has to be specified as well, and the selected ciphersuite supports 128-bit keys. A block cipher encrypts plaintext in fixed-size blocks, and AES operates on a block size of 128 bits. For messages exceeding 128 bits, the message is partitioned into 128-bit blocks, and the AES cipher is applied to these input blocks with appropriate chaining, which is called mode of operation.",
      "ja": "たとえば、TLS暗号スイートTLS_PSK_WITH_AES_128_CCM_8は、事前共有認証とキー交換アルゴリズムを使用します。 [RFC6655]はこの暗号スイートを定義しています。これは、ブロック暗号であるAES暗号化アルゴリズムを使用します。 AESアルゴリズムはさまざまな鍵の長さ（128、192、256ビットなど）をサポートするため、この情報も指定する必要があり、選択した暗号スイートは128ビットの鍵をサポートします。ブロック暗号は固定サイズのブロックで平文を暗号化し、AESは128ビットのブロックサイズで動作します。 128ビットを超えるメッセージの場合、メッセージは128ビットのブロックに分割され、AES暗号が適切なチェーンでこれらの入力ブロックに適用されます。これは操作モードと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 introduced Authenticated Encryption with Associated Data (AEAD) ciphersuites (see [RFC5116] and [RFC6655]). AEAD is a class of block cipher modes that encrypt (parts of) the message and authenticate the message simultaneously. AES-CCM [RFC6655] is an example of such a mode.",
      "ja": "TLS 1.2は、Authenticated Encryption with Associated Data（AEAD）暗号スイートを導入しました（[RFC5116]および[RFC6655]を参照）。 AEADは、メッセージ（の一部）を暗号化し、同時にメッセージを認証するブロック暗号モードのクラスです。 AES-CCM [RFC6655]はそのようなモードの例です。"
    },
    {
      "indent": 0,
      "text": " Some AEAD ciphersuites have shorter authentication tags (i.e., message authentication codes) and are therefore more suitable for networks with low bandwidth where small message size matters. The TLS_PSK_WITH_AES_128_CCM_8 ciphersuite that ends in \"_8\" has an 8-octet authentication tag, while the regular CCM ciphersuites have, at the time of writing, 16-octet authentication tags. The design of CCM and the security properties are described in [CCM].",
      "ja": "一部のAEAD暗号スイートは、短い認証タグ（つまり、メッセージ認証コード）を持っているため、小さいメッセージサイズが問題となる低帯域幅のネットワークに適しています。 「_8」で終わるTLS_PSK_WITH_AES_128_CCM_8暗号スイートには8オクテットの認証タグがありますが、通常のCCM暗号スイートには、現時点では16オクテットの認証タグがあります。 CCMの設計とセキュリティプロパティは、[CCM]で説明されています。"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 also replaced the combination of MD5/SHA-1 hash functions in the TLS pseudorandom function (PRF) used in earlier versions of TLS with ciphersuite-specified PRFs. For this reason, authors of more recent TLS 1.2 ciphersuite specifications explicitly indicate the MAC algorithm and the hash functions used with the TLS PRF.",
      "ja": "TLS 1.2では、以前のバージョンのTLSで使用されていたTLS疑似ランダム関数（PRF）のMD5 / SHA-1ハッシュ関数の組み合わせも、暗号スイート指定のPRFに置き換えられました。このため、最近のTLS 1.2 ciphersuite仕様の作成者は、TLS PRFで使用されるMACアルゴリズムとハッシュ関数を明示的に示しています。"
    },
    {
      "indent": 0,
      "text": "4. Credential Types",
      "section_title": true,
      "ja": "4. 資格情報のタイプ"
    },
    {
      "indent": 3,
      "text": "The mandatory-to-implement functionality will depend on the credential type used with IoT devices. The subsections below describe the implications of three different credential types, namely pre-shared secrets, raw public keys, and certificates.",
      "ja": "実装に必須の機能は、IoTデバイスで使用される資格情報の種類によって異なります。以下のサブセクションでは、3つの異なる資格情報タイプ、つまり事前共有秘密、生の公開鍵、証明書の影響について説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Preconditions",
      "section_title": true,
      "ja": "4.1. 前提条件"
    },
    {
      "indent": 3,
      "text": "All exchanges described in the subsequent sections assume that some information has been distributed before the TLS/DTLS interaction starts. The credentials are used to authenticate the client to the server, and vice versa. What information items have to be distributed depends on the chosen credential types. In all cases, the IoT device needs to know what algorithms to prefer, particularly if there are multiple algorithm choices available as part of the implemented ciphersuites, as well as information about the other communication endpoint (for example, in the form of a URI) a particular credential has to be used with.",
      "ja": "以降のセクションで説明するすべての交換では、TLS / DTLS対話が開始する前に一部の情報が配布されていることを前提としています。資格情報は、サーバーに対してクライアントを認証するために使用され、その逆も同様です。配布する必要がある情報アイテムは、選択した資格情報の種類によって異なります。すべての場合において、IoTデバイスは、特に実装された暗号スイートの一部として利用可能な複数のアルゴリズムの選択肢と、他の通信エンドポイントに関する情報（たとえば、URIの形式）がある場合、どのアルゴリズムを優先するかを知る必要があります。特定の資格情報を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Pre-Shared Secrets: In this case, a shared secret together with an identifier needs to be made available to the device as well as to the other communication party.",
      "ja": "事前共有シークレット：この場合、識別子と一緒に共有シークレットをデバイスだけでなく他の通信パーティでも使用できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Raw Public Keys: A public key together with a private key are stored on the device and typically associated with some identifier. To authenticate the other communication party, the appropriate credential has to be known. If the other end uses raw public keys as well, then their public key needs to be provisioned (out of band) to the device.",
      "ja": "未加工の公開鍵：公開鍵と秘密鍵はデバイスに保存され、通常はいくつかの識別子に関連付けられます。他の通信パーティを認証するには、適切なクレデンシャルを知っている必要があります。もう一方の端も未加工の公開鍵を使用する場合、それらの公開鍵を（帯域外で）デバイスにプロビジョニングする必要があります。"
    },
    {
      "indent": 0,
      "text": " Certificates: The use of certificates requires the device to store the public key (as part of the certificate) as well as the private key. The certificate will contain the identifier of the device as well as various other attributes. Both communication parties are assumed to be in possession of a trust anchor store that contains CA certificates and, in case of certificate pinning, end-entity certificates. Similar to the other credentials, the IoT device needs information about which entity to use which certificate with. Without a trust anchor store on the IoT device, it will not be possible to perform certificate validation.",
      "ja": "証明書：証明書を使用するには、デバイスが公開鍵（証明書の一部として）と秘密鍵を保管する必要があります。証明書には、デバイスの識別子およびその他のさまざまな属性が含まれます。両方の通信パーティは、CA証明書を含むトラストアンカーストアと、証明書のピン留めの場合はエンドエンティティ証明書を所有していると想定されます。他の資格情報と同様に、IoTデバイスには、どの証明書をどのエンティティで使用するかに関する情報が必要です。 IoTデバイスにトラストアンカーストアがないと、証明書の検証を実行できません。"
    },
    {
      "indent": 3,
      "text": "We call the above-listed information \"device credentials\" and these device credentials may be provisioned to the device already during the manufacturing time or later in the process, depending on the envisioned business and deployment model. These initial credentials are often called \"root of trust\". Whatever process is chosen for generating these initial device credentials, it MUST be ensured that a different key pair is provisioned for each device and installed in as secure a manner as possible. For example, it is preferable to generate public/private keys on the IoT device itself rather than generating them outside the device. Since an IoT device is likely to interact with various other parties, the initial device credential may only be used with some dedicated entities, and configuring further configuration and credentials to the device is left to a separate interaction. An example of a dedicated protocol used to distribute credentials, access control lists, and configure information is the LWM2M protocol [LWM2M].",
      "ja": "上記の情報を「デバイスクレデンシャル」と呼びます。これらのデバイスクレデンシャルは、想定されるビジネスおよび展開モデルに応じて、製造時またはプロセスの後の段階ですでにデバイスにプロビジョニングされる場合があります。これらの最初の資格情報は、「信頼のルート」と呼ばれることがよくあります。これらの初期デバイスクレデンシャルを生成するためにどのようなプロセスが選択されても、デバイスごとに異なるキーペアがプロビジョニングされ、できるだけ安全な方法でインストールされるようにする必要があります。たとえば、公開鍵/秘密鍵は、デバイスの外部で生成するのではなく、IoTデバイス自体で生成することが推奨されます。 IoTデバイスは他のさまざまな関係者と対話する可能性が高いため、最初のデバイスの認証情報は一部の専用エンティティでのみ使用でき、デバイスの追加の構成と認証情報の構成は個別の対話に任されます。資格情報、アクセス制御リスト、および構成情報の配布に使用される専用プロトコルの例は、LWM2Mプロトコル[LWM2M]です。"
    },
    {
      "indent": 3,
      "text": "For all the credentials listed above, there is a chance that those may need to be replaced or deleted. While separate protocols have been developed to check the status of these credentials and to manage these credentials, such as the Trust Anchor Management Protocol (TAMP) [RFC5934], their usage is, however, not envisioned in the IoT context so far. IoT devices are assumed to have a software update mechanism built-in, and it will allow updates of low-level device information, including credentials and configuration parameters. This document does, however, not mandate a specific software/firmware update protocol.",
      "ja": "上記のすべての資格情報について、それらを置き換えるか削除する必要がある可能性があります。 Trust Anchor Management Protocol（TAMP）[RFC5934]など、これらの資格情報のステータスをチェックし、これらの資格情報を管理するための個別のプロトコルが開発されていますが、現在のところ、IoTコンテキストでの使用は想定されていません。 IoTデバイスにはソフトウェア更新メカニズムが組み込まれていると想定されており、資格情報や構成パラメーターなどの低レベルのデバイス情報を更新できます。ただし、このドキュメントでは、特定のソフトウェア/ファームウェア更新プロトコルを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "With all credentials used as input to TLS/DTLS authentication, it is important that these credentials have been generated with care. When using a pre-shared secret, a critical consideration is using sufficient entropy during the key generation, as discussed in [RFC4086]. Deriving a shared secret from a password, some device identifiers, or other low-entropy sources is not secure. A low-entropy secret, or password, is subject to dictionary attacks. Attention also has to be paid when generating public/private key pairs since the lack of randomness can result in the same key pair being used in many devices. This topic is also discussed in Section 12 since keys are generated during the TLS/DTLS exchange itself as well, and the same considerations apply.",
      "ja": "すべての資格情報がTLS / DTLS認証への入力として使用されるため、これらの資格情報が慎重に生成されていることが重要です。事前共有秘密を使用する場合、重要な考慮事項は、[RFC4086]で説明されているように、鍵の生成中に十分なエントロピーを使用することです。パスワード、一部のデバイス識別子、またはその他の低エントロピーソースから共有シークレットを取得することは安全ではありません。エントロピーの低いシークレット、つまりパスワードは、辞書攻撃の対象になります。公開鍵と秘密鍵のペアを生成する際にも注意が必要です。ランダム性がないと、同じ鍵のペアが多くのデバイスで使用される可能性があるためです。 TLS / DTLSの交換中にもキーが生成され、同じ考慮事項が適用されるため、このトピックはセクション12でも説明されています。"
    },
    {
      "indent": 0,
      "text": "4.2. Pre-Shared Secret",
      "section_title": true,
      "ja": "4.2. 事前共有秘密"
    },
    {
      "indent": 3,
      "text": "The use of pre-shared secrets is one of the most basic techniques for TLS/DTLS since it is both computationally efficient and bandwidth conserving. Authentication based on pre-shared secrets was introduced to TLS in RFC 4279 [RFC4279].",
      "ja": "事前共有秘密の使用は、計算効率が高く、帯域幅を節約できるため、TLS / DTLSの最も基本的な手法の1つです。事前共有秘密に基づく認証は、RFC 4279 [RFC4279]でTLSに導入されました。"
    },
    {
      "indent": 3,
      "text": "Figure 8 illustrates the DTLS exchange including the cookie exchange. While the server is not required to initiate a cookie exchange with every handshake, the client is required to implement and to react on it when challenged, as defined in RFC 6347 [RFC6347]. The cookie exchange allows the server to react to flooding attacks.",
      "ja": "図8は、Cookie交換を含むDTLS交換を示しています。サーバーはすべてのハンドシェイクとのCookie交換を開始する必要はありませんが、RFC 6347 [RFC6347]で定義されているように、クライアントは実装され、要求されたときにそれに応答する必要があります。 Cookie交換により、サーバーはフラッディング攻撃に対応できます。"
    },
    {
      "indent": 9,
      "text": "Client                                               Server\n------                                               ------\nClientHello                 -------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 37,
      "text": "<--------    HelloVerifyRequest\n              (contains cookie)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "ClientHello                  -------->\n(with cookie)\n                                                ServerHello\n                                         *ServerKeyExchange\n                             <--------      ServerHelloDone\nClientKeyExchange\nChangeCipherSpec\nFinished                     -------->\n                                           ChangeCipherSpec\n                             <--------             Finished",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Application Data             <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 3,
      "text": "* indicates an optional message payload",
      "ja": "* オプションのメッセージペイロードを示します"
    },
    {
      "indent": 6,
      "text": "Figure 8: DTLS PSK Authentication Including the Cookie Exchange",
      "ja": "図8：Cookie交換を含むDTLS PSK認証"
    },
    {
      "indent": 0,
      "text": " Note that [RFC4279] used the term \"PSK identity\" to refer to the identifier used to refer to the appropriate secret. While \"identifier\" would be more appropriate in this context, we reuse the terminology defined in RFC 4279 to avoid confusion. RFC 4279 does not mandate the use of any particular type of PSK identity, and the client and server have to agree on the identities and keys to be used. The UTF-8 encoding of identities described in Section 5.1 of RFC 4279 aims to improve interoperability for those cases where the identity is configured by a human using some management interface provided by a web browser. However, many IoT devices do not have a user interface, and most of their credentials are bound to the device rather than to the user. Furthermore, credentials are often provisioned into hardware modules or provisioned alongside with firmware. As such, the encoding considerations are not applicable to this usage environment. For use with this profile, the PSK identities SHOULD NOT assume a structured format (such as domain names, distinguished names, or IP addresses), and a byte-by-byte comparison operation MUST be used by the server for any operation related to the PSK identity. These types of identifiers are called \"absolute\" per RFC 6943 [RFC6943].",
      "ja": "[RFC4279]は、「PSK ID」という用語を使用して、適切なシークレットを参照するために使用される識別子を参照していることに注意してください。この状況では「識別子」がより適切ですが、混乱を避けるために、RFC 4279で定義された用語を再利用しています。 RFC 4279は、特定のタイプのPSK IDの使用を義務付けておらず、クライアントとサーバーは、使用されるIDとキーに同意する必要があります。 RFC 4279のセクション5.1で説明されているIDのUTF-8エンコードは、Webブラウザーが提供する管理インターフェースを使用して人間がIDを構成する場合の相互運用性の向上を目的としています。ただし、多くのIoTデバイスにはユーザーインターフェイスがなく、それらのほとんどの資格情報はユーザーではなくデバイスにバインドされています。さらに、資格情報は多くの場合、ハードウェアモジュールにプロビジョニングされるか、ファームウェアと共にプロビジョニングされます。そのため、エンコードに関する考慮事項は、この使用環境には適用されません。このプロファイルで使用するために、PSK IDは構造化された形式（ドメイン名、識別名、IPアドレスなど）を想定してはならず（SHOULD NOT）、バイトごとの比較操作は、 PSK ID。これらのタイプの識別子は、RFC 6943 [RFC6943]に従って「絶対」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Protocol-wise, the client indicates which key it uses by including a \"PSK identity\" in the ClientKeyExchange message. As described in Section 3.2, clients may have multiple pre-shared keys with a single server, for example, in a hosting context. The TLS Server Name Indication (SNI) extension allows the client to convey the name of the server it is contacting. A server implementation needs to guide the selection based on a received SNI value from the client.",
      "ja": "プロトコル的には、クライアントはClientKeyExchangeメッセージに「PSK ID」を含めることで、使用するキーを示します。セクション3.2で説明したように、クライアントは、たとえばホスティングコンテキストで、単一のサーバーと複数の事前共有キーを持つ場合があります。 TLSサーバー名表示（SNI）拡張により、クライアントは、接続しているサーバーの名前を伝えることができます。サーバー実装は、クライアントから受信したSNI値に基づいて選択をガイドする必要があります。"
    },
    {
      "indent": 3,
      "text": "RFC 4279 requires TLS implementations supporting PSK ciphersuites to support arbitrary PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. This is a useful assumption for TLS stacks used in the desktop and mobile environments where management interfaces are used to provision identities and keys. Implementations in compliance with this profile MAY use PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. The use of shorter PSK identities is RECOMMENDED.",
      "ja": "RFC 4279では、最大128オクテットまでの任意のPSK IDと最大64オクテットまでの任意のPSKをサポートするために、PSK暗号スイートをサポートするTLS実装が必要です。これは、管理インターフェイスを使用してIDとキーをプロビジョニングするデスクトップおよびモバイル環境で使用されるTLSスタックの有用な前提条件です。このプロファイルに準拠した実装は、長さが最大128オクテットのPSK IDと長さが最大64オクテットの任意のPSKを使用できます。より短いPSK IDの使用が推奨されます。"
    },
    {
      "indent": 3,
      "text": "\"The Constrained Application Protocol (CoAP)\" [RFC7252] currently specifies TLS_PSK_WITH_AES_128_CCM_8 as the mandatory-to-implement ciphersuite for use with shared secrets. This ciphersuite uses the AES algorithm with 128 bit keys and CCM as the mode of operation. The label \"_8\" indicates that an 8-octet authentication tag is used. Note that the shorted authentication tag increases the chance that an adversary with no knowledge of the secret key can present a message with a MAC that will pass the verification procedure. The likelihood of accepting forged data is explained in Section 5.3.5 of [SP800-107-rev1] and depends on the lengths of the authentication tag and allowed numbers of MAC verifications using a given key.",
      "ja": "「Constrained Application Protocol（CoAP）」[RFC7252]は現在、共有シークレットで使用するために必須の暗号スイートとしてTLS_PSK_WITH_AES_128_CCM_8を指定しています。この暗号スイートは、動作モードとして128ビットキーとCCMを使用するAESアルゴリズムを使用します。ラベル「_8」は、8オクテット認証タグが使用されていることを示します。認証タグが短絡していると、秘密鍵を知らない攻撃者が、検証手順に合格するMACを含むメッセージを提示できる可能性が高くなることに注意してください。偽造データを受け入れる可能性は、[SP800-107-rev1]のセクション5.3.5で説明されており、認証タグの長さと、所定のキーを使用して許可されるMAC検証の数に依存します。"
    },
    {
      "indent": 3,
      "text": "This ciphersuite makes use of the default TLS 1.2 PRF, which uses an HMAC with the SHA-256 hash function. Note: Starting with TLS 1.2 (and consequently DTLS 1.2), ciphersuites have to specify the PRF. RFC 5246 states that \"New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function.\" The ciphersuites recommended in this document use the SHA-256 construct defined in Section 5 of RFC 5246.",
      "ja": "この暗号スイートは、SHA-256ハッシュ関数でHMACを使用するデフォルトのTLS 1.2 PRFを利用します。注：TLS 1.2（および結果的にDTLS 1.2）以降、暗号スイートはPRFを指定する必要があります。 RFC 5246では、「新しい暗号スイートはPRFを明示的に指定する必要があり、一般に、SHA-256またはより強力な標準ハッシュ関数でTLS PRFを使用する必要があります。」このドキュメントで推奨されている暗号スイートは、RFC 5246のセクション5で定義されているSHA-256構成を使用しています。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_PSK_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションのプロファイルに準拠するデバイスは、TLS_PSK_WITH_AES_128_CCM_8を実装し、このセクションのガイダンスに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Raw Public Key",
      "section_title": true,
      "ja": "4.3. 生の公開鍵"
    },
    {
      "indent": 3,
      "text": "The use of raw public keys with TLS/DTLS, as defined in [RFC7250], is the first entry point into public key cryptography without having to pay the price of certificates and a public key infrastructure (PKI). The specification reuses the existing Certificate message to convey the raw public key encoded in the SubjectPublicKeyInfo structure. To indicate support, two new extensions had been defined, as shown in Figure 9, namely the server_certificate_type and the client_certificate_type.",
      "ja": "[RFC7250]で定義されているように、TLS / DTLSで生の公開鍵を使用することは、証明書や公開鍵インフラストラクチャ（PKI）の価格を支払う必要がない公開鍵暗号化への最初のエントリポイントです。この仕様では、既存の証明書メッセージを再利用して、SubjectPublicKeyInfo構造でエンコードされた生の公開鍵を伝達します。サポートを示すために、図9に示すように、server_certificate_typeとclient_certificate_typeという2つの新しい拡張が定義されています。"
    },
    {
      "indent": 4,
      "text": "Client                                          Server\n------                                          ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ClientHello             -------->\n#client_certificate_type#\n#server_certificate_type#",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "                   ServerHello\n     #client_certificate_type#\n     #server_certificate_type#\n                   Certificate\n             ServerKeyExchange\n            CertificateRequest\n<--------      ServerHelloDone",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Certificate\nClientKeyExchange\nCertificateVerify\n[ChangeCipherSpec]\nFinished                -------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "            [ChangeCipherSpec]\n<--------             Finished",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: Extensions marked with \"#\" were introduced with RFC 7250.",
      "ja": "注：「＃」でマークされた拡張機能は、RFC 7250で導入されました。"
    },
    {
      "indent": 18,
      "text": "Figure 9: DTLS Raw Public Key Exchange",
      "ja": "図9：DTLS生の公開鍵交換"
    },
    {
      "indent": 0,
      "text": " The CoAP-recommended ciphersuite for use with this credential type is TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]. This AES-CCM TLS ciphersuite based on elliptic curve cryptography (ECC) uses the Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) as the key establishment mechanism and an Elliptic Curve Digital Signature Algorithm (ECDSA) for authentication. The named DH groups [FFDHE-TLS] are not applicable to this profile since it relies on the ECC-based counterparts. This ciphersuite makes use of the AEAD capability in DTLS 1.2 and utilizes an 8-octet authentication tag. The use of a DH key exchange provides perfect forward secrecy (PFS). More details about PFS can be found in Section 9.",
      "ja": "この認証情報タイプで使用するためにCoAPで推奨される暗号スイートは、TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]です。楕円曲線暗号（ECC）に基づくこのAES-CCM TLS暗号スイートは、鍵確立メカニズムとしてEphemeral Elliptic Curve Diffie-Hellman（ECDHE）を使用し、認証には楕円曲線デジタル署名アルゴリズム（ECDSA）を使用します。名前付きDHグループ[FFDHE-TLS]は、ECCベースの対応物に依存しているため、このプロファイルには適用されません。この暗号スイートは、DTLS 1.2のAEAD機能を利用し、8オクテットの認証タグを利用します。 DH鍵交換を使用すると、Perfect Forward Secrecy（PFS）が提供されます。 PFSの詳細については、セクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] provides valuable information for implementing ECC algorithms, particularly for choosing methods that have been available in the literature for a long time (i.e., 20 years and more).",
      "ja": "[RFC6090]は、ECCアルゴリズムの実装、特に文献で長い間（つまり、20年以上）利用可能な方法を選択するための貴重な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションのプロファイルに準拠するデバイスは、TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8を実装し、このセクションのガイダンスに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Certificates",
      "section_title": true,
      "ja": "4.4. 証明書"
    },
    {
      "indent": 3,
      "text": "The use of mutual certificate-based authentication is shown in Figure 10, which makes use of the \"cached_info\" extension [RFC7924]. Support of the \"cached_info\" extension is REQUIRED. Caching certificate chains allows the client to reduce the communication overhead significantly, otherwise the server would provide the end-entity certificate and the certificate chain with every full DTLS handshake.",
      "ja": "相互証明書ベースの認証の使用を図10に示します。これは、「cached_info」拡張[RFC7924]を利用しています。 「cached_info」拡張のサポートが必要です。証明書チェーンをキャッシュすると、クライアントは通信オーバーヘッドを大幅に削減できます。そうしないと、サーバーがエンドエンティティ証明書と証明書チェーンをすべての完全なDTLSハンドシェイクに提供します。"
    },
    {
      "indent": 4,
      "text": "Client                                          Server\n------                                          ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ClientHello             -------->\n*cached_info*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "                   ServerHello\n                 *cached_info*\n                   Certificate\n             ServerKeyExchange\n            CertificateRequest\n<--------      ServerHelloDone",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Certificate\nClientKeyExchange\nCertificateVerify\n[ChangeCipherSpec]\nFinished                -------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "            [ChangeCipherSpec]\n<--------             Finished",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: Extensions marked with \"*\" were introduced with RFC 7924.",
      "ja": "注：「*」でマークされた拡張機能は、RFC 7924で導入されました。"
    },
    {
      "indent": 10,
      "text": "Figure 10: DTLS Mutual Certificate-Based Authentication",
      "ja": "図10：DTLS相互証明書ベースの認証"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS offers a lot of choices when selecting ECC-based ciphersuites. This document restricts the use to named curves defined in RFC 4492 [RFC4492]. At the time of writing, the recommended curve is secp256r1, and the use of uncompressed points follows the recommendation in CoAP. Note that standardization for Curve25519 (for ECDHE) is ongoing (see [RFC7748]), and support for this curve will likely be required in the future.",
      "ja": "TLS / DTLSは、ECCベースの暗号スイートを選択するときに多くの選択肢を提供します。このドキュメントでは、RFC 4492 [RFC4492]で定義されている名前付き曲線の使用を制限しています。執筆時点では、推奨される曲線はsecp256r1であり、非圧縮ポイントの使用はCoAPの推奨に従います。 Curve25519（ECDHE用）の標準化が進行中であり（[RFC7748]を参照）、この曲線のサポートが将来必要になる可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションのプロファイルに準拠するデバイスは、TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8を実装し、このセクションのガイダンスに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Certificates Used by Servers",
      "section_title": true,
      "ja": "4.4.1. サーバーが使用する証明書"
    },
    {
      "indent": 3,
      "text": "The algorithm for verifying the service identity, as described in RFC 6125 [RFC6125], is essential for ensuring proper security when certificates are used. As a summary, the algorithm contains the following steps:",
      "ja": "RFC 6125 [RFC6125]で説明されているように、サービスIDを検証するアルゴリズムは、証明書が使用されるときに適切なセキュリティを確保するために不可欠です。要約すると、アルゴリズムには次のステップが含まれます。"
    },
    {
      "indent": 3,
      "text": "1. The client constructs a list of acceptable reference identifiers based on the source domain and, optionally, the type of service to which the client is connecting.",
      "ja": "1. クライアントは、ソースドメインと、オプションで、クライアントが接続しているサービスのタイプに基づいて、受け入れ可能な参照識別子のリストを作成します。"
    },
    {
      "indent": 3,
      "text": "2. The server provides its identifiers in the form of a PKIX certificate.",
      "ja": "2. サーバーは、PKIX証明書の形式で識別子を提供します。"
    },
    {
      "indent": 3,
      "text": "3. The client checks each of its reference identifiers against the presented identifiers for the purpose of finding a match.",
      "ja": "3. クライアントは、一致を見つけるために、提示された識別子に対して各参照識別子をチェックします。"
    },
    {
      "indent": 3,
      "text": "4. When checking a reference identifier against a presented identifier, the client matches the source domain of the identifiers and, optionally, their application service type.",
      "ja": "4. 提示された識別子に対して参照識別子をチェックするとき、クライアントは識別子のソースドメインと、オプションでそれらのアプリケーションサービスタイプを照合します。"
    },
    {
      "indent": 3,
      "text": "For various terms used in the algorithm shown above, consult RFC 6125. It is important to highlight that comparing the reference identifier against the presented identifier obtained from the certificate is required to ensure the client is communicating with the intended server.",
      "ja": "上記のアルゴリズムで使用されるさまざまな用語については、RFC 6125を参照してください。クライアントが目的のサーバーと通信していることを確認するには、参照識別子を証明書から取得した提示された識別子と比較する必要があることを強調することが重要です。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that the algorithm description and the text in RFC 6125 assumes that fully qualified DNS domain names are used. If a server node is provisioned with a fully qualified DNS domain, then the server certificate MUST contain the fully qualified DNS domain name or \"FQDN\" as dNSName [RFC5280]. For CoAP, the coaps URI scheme is described in Section 6.2 of [RFC7252]. This FQDN is stored in the SubjectAltName or in the leftmost Common Name (CN) component of the subject name, as explained in Section 9.1.3.3 of [RFC7252], and used by the client to match it against the FQDN used during the lookup process, as described in [RFC6125]. For other protocols, the appropriate URI scheme specification has to be consulted.",
      "ja": "アルゴリズムの説明とRFC 6125のテキストでは、完全修飾DNSドメイン名が使用されていると想定していることに注意してください。サーバーノードが完全修飾DNSドメインでプロビジョニングされている場合、サーバー証明書には完全修飾DNSドメイン名または「FQDN」がdNSName [RFC5280]として含まれている必要があります。 CoAPの場合、coaps URIスキームは[RFC7252]のセクション6.2で説明されています。このFQDNは、[RFC7252]のセクション9.1.3.3で説明されているように、SubjectAltNameまたはサブジェクト名の左端のCommon Name（CN）コンポーネントに格納され、ルックアッププロセス中に使用されるFQDNと照合するためにクライアントによって使用されます。 、[RFC6125]で説明されています。他のプロトコルについては、適切なURIスキーム仕様を参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following recommendation is provided:",
      "ja": "以下の推奨事項が提供されています。"
    },
    {
      "indent": 3,
      "text": "1. Certificates MUST NOT use DNS domain names in the CN of certificates and instead use the subjectAltName attribute, as described in the previous paragraph.",
      "ja": "1. 前の段落で説明したように、証明書は証明書のCNでDNSドメイン名を使用してはならず、代わりにsubjectAltName属性を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Certificates MUST NOT contain domain names with wildcard characters.",
      "ja": "2. 証明書には、ワイルドカード文字を含むドメイン名を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "3. Certificates MUST NOT contain multiple names (e.g., more than one dNSName field).",
      "ja": "3. 証明書に複数の名前を含めることはできません（例：複数のdNSNameフィールド）。"
    },
    {
      "indent": 3,
      "text": "Note that there will be servers that are not provisioned for use with DNS domain names, for example, IoT devices that offer resources to nearby devices in a local area network, as shown in Figure 7. When such constrained servers are used, then the use of certificates as described in Section 4.4.2 is applicable. Note that the SNI extension cannot be used in this case since SNI does not offer the ability to convey a 64-bit Extended Unique Identifier (EUI-64) [EUI64]. Note that this document does not recommend use of IP addresses in certificates nor does it discuss the implications of placing IP addresses in certificates.",
      "ja": "図7に示すように、ローカルエリアネットワーク内の近くのデバイスにリソースを提供するIoTデバイスなど、DNSドメイン名で使用するようにプロビジョニングされていないサーバーがあることに注意してください。このような制約されたサーバーが使用されている場合、セクション4.4.2で説明されている証明書が適用されます。この場合、SNIは64ビット拡張一意識別子（EUI-64）[EUI64]を伝達する機能を提供しないため、SNI拡張は使用できません。このドキュメントでは、証明書でのIPアドレスの使用は推奨されておらず、証明書にIPアドレスを配置することの影響については説明されていません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Certificates Used by Clients",
      "section_title": true,
      "ja": "4.4.2. クライアントが使用する証明書"
    },
    {
      "indent": 3,
      "text": "For client certificates, the identifier used in the SubjectAltName or in the leftmost CN component of subject name MUST be an EUI-64.",
      "ja": "クライアント証明書の場合、SubjectAltNameまたはサブジェクト名の左端のCNコンポーネントで使用される識別子はEUI-64である必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Certificate Revocation",
      "section_title": true,
      "ja": "4.4.3. 証明書の失効"
    },
    {
      "indent": 3,
      "text": "For certificate revocation, neither the Online Certificate Status Protocol (OCSP) nor Certificate Revocation Lists (CRLs) are used. Instead, this profile relies on a software update mechanism to provision information about revoked certificates. While multiple OCSP stapling [RFC6961] has recently been introduced as a mechanism to piggyback OCSP request/responses inside the DTLS/TLS handshake (to avoid the cost of a separate protocol handshake), further investigations are needed to determine its suitability for the IoT environment.",
      "ja": "証明書失効では、オンライン証明書ステータスプロトコル（OCSP）も証明書失効リスト（CRL）も使用されません。代わりに、このプロファイルは、ソフトウェア更新メカニズムに依存して、取り消された証明書に関する情報をプロビジョニングします。複数のOCSPステープリング[RFC6961]は、DTLS / TLSハンドシェイク内のOCSP要求/応答を便乗させるメカニズムとして最近導入されましたが（個別のプロトコルハンドシェイクのコストを回避するため）、IoT環境への適合性を判断するにはさらに調査が必要です。"
    },
    {
      "indent": 3,
      "text": "As stated earlier in this section, modifications to the trust anchor store depends on a software update mechanism as well. There are limitations to the use of a software update mechanism because of the potential inability to change certain types of keys, such as those provisioned during manufacturing. For this reason, manufacturer-provisioned credentials are typically employed only to obtain further certificates (for example, via a key distribution server) for use with servers the IoT device is finally communicating with.",
      "ja": "このセクションで前述したように、トラストアンカーストアへの変更は、ソフトウェアの更新メカニズムにも依存します。製造時にプロビジョニングされたキーなど、特定のタイプのキーを変更できない可能性があるため、ソフトウェア更新メカニズムの使用には制限があります。このため、製造元がプロビジョニングした資格情報は、通常、IoTデバイスが最終的に通信するサーバーで使用するための追加の証明書（たとえば、キー配布サーバー経由）を取得するためにのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Certificate Content",
      "section_title": true,
      "ja": "4.4.4. 証明書の内容"
    },
    {
      "indent": 3,
      "text": "All certificate elements listed in Table 1 MUST be implemented by clients and servers claiming support for certificate-based authentication. No other certificate elements are used by this specification.",
      "ja": "表1にリストされているすべての証明書要素は、証明書ベースの認証のサポートを要求するクライアントとサーバーによって実装されなければなりません（MUST）。この仕様では他の証明書要素は使用されません。"
    },
    {
      "indent": 3,
      "text": "When using certificates, IoT devices MUST provide support for a server certificate chain of at least 3, not including the trust anchor, and MAY reject connections from servers offering chains longer than 3. IoT devices MAY have client certificate chains of any length. Obviously, longer chains require more digital signature verification operations to perform and lead to larger certificate messages in the TLS handshake.",
      "ja": "証明書を使用する場合、IoTデバイスは、トラストアンカーを含まない、少なくとも3のサーバー証明書チェーンをサポートする必要があり、3より長いチェーンを提供するサーバーからの接続を拒否することができます（IoTデバイスは、任意の長さのクライアント証明書チェーンを持つことができます）。明らかに、チェーンが長くなるほど、TLSハンドシェイクで実行する証明書メッセージが大きくなり、証明書メッセージが大きくなるため、より多くのデジタル署名検証操作が必要になります。"
    },
    {
      "indent": 3,
      "text": "Table 1 provides a summary of the elements in a certificate for use with this profile.",
      "ja": "表1は、このプロファイルで使用する証明書の要素の概要を示しています。"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n|       Element        |                   Notes                    |\n+----------------------+--------------------------------------------+\n|       version        |  This profile uses X.509 v3 certificates   |\n|                      |                 [RFC5280].                 |\n|                      |                                            |\n|     serialNumber     |  Positive integer unique per certificate.  |\n|                      |                                            |\n|      signature       |     This field contains the signature      |\n|                      |  algorithm, and this profile uses ecdsa-   |\n|                      |     with-SHA256 or stronger [RFC5758].     |\n|                      |                                            |\n|        issuer        |     Contains the DN of the issuing CA.     |\n|                      |                                            |\n|       validity       | Values expressed as UTC time in notBefore  |\n|                      |  and notAfter fields.  No validity period  |\n|                      |                 mandated.                  |\n|                      |                                            |\n|       subject        |    See rules outlined in this section.     |\n|                      |                                            |\n| subjectPublicKeyInfo |     The SubjectPublicKeyInfo structure     |\n|                      | indicates the algorithm and any associated |\n|                      |  parameters for the ECC public key.  This  |\n|                      | profile uses the id-ecPublicKey algorithm  |\n|                      |  identifier for ECDSA signature keys, as   |\n|                      |    defined and specified in [RFC5480].     |\n|                      |                                            |\n|  signatureAlgorithm  | The ECDSA signature algorithm with ecdsa-  |\n|                      |          with-SHA256 or stronger.          |\n|                      |                                            |\n|    signatureValue    |     Bit string containing the digital      |\n|                      |                 signature.                 |\n|                      |                                            |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|      Extension:      |    See rules outlined in this section.     |\n|    subjectAltName    |                                            |\n|                      |                                            |\n|      Extension:      |    Indicates whether the subject of the    |\n|   BasicConstraints   | certificate is a CA and the maximum depth  |\n|                      | of valid certification paths that include  |\n|                      | this certificate.  This extension is used  |\n|                      |  for CA certs only, and then the value of  |\n|                      |    the \"cA\" field is set to TRUE.  The     |\n|                      |             default is FALSE.              |\n|                      |                                            |\n| Extension: Key Usage | The KeyUsage field MAY have the following  |\n|                      |   values in the context of this profile:   |\n|                      |     digitalSignature or keyAgreement,      |\n|                      |  keyCertSign for verifying signatures on   |\n|                      |          public key certificates.          |\n|                      |                                            |\n| Extension: Extended  |  The ExtKeyUsageSyntax field MAY have the  |\n|      Key Usage       |    following values in context of this     |\n|                      |    profile: id-kp-serverAuth for server    |\n|                      |    authentication, id-kp-clientAuth for    |\n|                      |  client authentication, id-kp-codeSigning  |\n|                      |   for code signing (for software update    |\n|                      |   mechanism), and id-kp-OCSPSigning for    |\n|                      |         future OCSP usage in TLS.          |\n+----------------------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 1: Certificate Content",
      "ja": "表1：証明書の内容"
    },
    {
      "indent": 3,
      "text": "There are various cryptographic algorithms available to sign digital certificates; those algorithms include RSA, the Digital Signature Algorithm (DSA), and ECDSA. As Table 1 shows, certificates are signed using ECDSA in this profile. This is not only true for the end-entity certificates but also for all other certificates in the chain, including CA certificates. This profiling reduces the amount of flash memory needed on an IoT device to store the code of several algorithm implementations due to the smaller number of options.",
      "ja": "デジタル証明書の署名に使用できるさまざまな暗号化アルゴリズムがあります。これらのアルゴリズムには、RSA、デジタル署名アルゴリズム（DSA）、およびECDSAが含まれます。表1に示すように、証明書はこのプロファイルでECDSAを使用して署名されます。これは、エンドエンティティ証明書だけでなく、チェーン内の他のすべての証明書（CA証明書を含む）にも当てはまります。このプロファイリングでは、オプションの数が少ないため、IoTデバイスでいくつかのアルゴリズム実装のコードを格納するために必要なフラッシュメモリの量が削減されます。"
    },
    {
      "indent": 3,
      "text": "Further details about X.509 certificates can be found in Section 9.1.3.3 of [RFC7252].",
      "ja": "X.509証明書の詳細については、[RFC7252]のセクション9.1.3.3をご覧ください。"
    },
    {
      "indent": 0,
      "text": "4.4.5. Client Certificate URLs",
      "section_title": true,
      "ja": "4.4.5. クライアント証明書のURL"
    },
    {
      "indent": 3,
      "text": "RFC 6066 [RFC6066] allows the sending of client-side certificates to be avoided and uses URLs instead. This reduces the over-the-air transmission. Note that the TLS \"cached_info\" extension does not provide any help with caching client certificates.",
      "ja": "RFC 6066 [RFC6066]では、クライアント側の証明書の送信を回避でき、代わりにURLを使用します。これにより、無線送信が減少します。 TLSの「cached_info」拡張機能は、クライアント証明書のキャッシングに関するヘルプを提供しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS clients MUST implement support for client certificate URLs for those environments where client-side certificates are used and the server-side is not constrained. For constrained servers this functionality is NOT RECOMMENDED since it forces the server to execute an additional protocol exchange, potentially using a protocol it does not even support. The use of this extension also increases the risk of a DoS attack against the constrained server due to the additional workload.",
      "ja": "TLS / DTLSクライアントは、クライアント側の証明書が使用され、サーバー側が制約されていない環境のクライアント証明書URLのサポートを実装する必要があります。制約されたサーバーの場合、サポートされていないプロトコルを使用する可能性がある追加のプロトコル交換をサーバーに実行させるため、この機能は推奨されません。この拡張機能を使用すると、追加のワークロードにより、制約されたサーバーに対するDoS攻撃のリスクも増加します。"
    },
    {
      "indent": 0,
      "text": "4.4.6. Trusted CA Indication",
      "section_title": true,
      "ja": "4.4.6. 信頼できるCA表示"
    },
    {
      "indent": 3,
      "text": "RFC 6066 [RFC6066] allows clients to indicate what trust anchor they support. With certificate-based authentication, a DTLS server conveys its end-entity certificate to the client during the DTLS handshake. Since the server does not necessarily know what trust anchors the client has stored, to facilitate certification path construction and validation, it includes intermediate CA certs in the certificate payload.",
      "ja": "RFC 6066 [RFC6066]では、クライアントがサポートするトラストアンカーを示すことができます。証明書ベースの認証では、DTLSサーバーは、DTLSハンドシェイク中にエンドエンティティ証明書をクライアントに伝達します。サーバーは、クライアントが保存しているトラストアンカーを必ずしも認識していないため、証明書パスの構築と検証を容易にするために、証明書ペイロードに中間CA証明書が含まれています。"
    },
    {
      "indent": 3,
      "text": "Today, in most IoT deployments there is a fairly static relationship between the IoT device (and the software running on them) and the server-side infrastructure. For these deployments where IoT devices interact with a fixed, preconfigured set of servers, this extension is NOT RECOMMENDED.",
      "ja": "今日、ほとんどのIoT展開では、IoTデバイス（およびIoTデバイス上で実行されているソフトウェア）とサーバー側インフラストラクチャの間にかなり静的な関係があります。 IoTデバイスが事前に構成された固定のサーバーセットとやり取りするこれらの展開では、この拡張機能は推奨されません。"
    },
    {
      "indent": 3,
      "text": "In cases where clients interact with dynamically discovered TLS/DTLS servers, for example, in the use cases described in Section 3.2.2, the use of this extension is RECOMMENDED.",
      "ja": "クライアントが動的に検出されたTLS / DTLSサーバーとやり取りする場合、たとえば、セクション3.2.2で説明されている使用例では、この拡張機能の使用が推奨されます。"
    },
    {
      "indent": 0,
      "text": "5. Signature Algorithm Extension",
      "section_title": true,
      "ja": "5. 署名アルゴリズム拡張"
    },
    {
      "indent": 3,
      "text": "The \"signature_algorithms\" extension, defined in Section 7.4.1.4.1 of RFC 5246 [RFC5246], allows the client to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The client MUST send this extension to select the use of SHA-256, otherwise if this extension is absent, RFC 5246 defaults to SHA-1 / ECDSA for the ECDH_ECDSA and the ECDHE_ECDSA key exchange algorithms.",
      "ja": "RFC 5246 [RFC5246]のセクション7.4.1.4.1で定義されている「signature_algorithms」拡張機能を使用すると、クライアントは、デジタル署名で使用できる署名/ハッシュアルゴリズムのペアをサーバーに示すことができます。クライアントはこの拡張を送信してSHA-256の使用を選択する必要があります。そうでない場合、この拡張が存在しない場合、RFC 5246はデフォルトでECDH_ECDSAおよびECDHE_ECDSA鍵交換アルゴリズムのSHA-1 / ECDSAに設定されます。"
    },
    {
      "indent": 3,
      "text": "The \"signature_algorithms\" extension is not applicable to the PSK-based ciphersuite described in Section 4.2.",
      "ja": "「signature_algorithms」拡張は、セクション4.2で説明されているPSKベースの暗号スイートには適用されません。"
    },
    {
      "indent": 0,
      "text": "6. Error Handling",
      "section_title": true,
      "ja": "6. エラー処理"
    },
    {
      "indent": 0,
      "text": " TLS/DTLS uses the alert protocol to convey errors and specifies a long list of error types. However, not all error messages defined in the TLS/DTLS specification are applicable to this profile. In general, there are two categories of errors (as defined in Section 7.2 of RFC 5246), namely fatal errors and warnings. Alert messages with a level of \"fatal\" result in the immediate termination of the connection. If possible, developers should try to develop strategies to react to those fatal errors, such as restarting the handshake or informing the user using the (often limited) user interface. Warnings may be ignored by the application since many IoT devices will have either limited ways to log errors or no ability at all. In any case, implementers have to carefully evaluate the impact of errors and ways to remedy the situation since a commonly used approach for delegating decision making to users is difficult (or impossible) to accomplish in a timely fashion.",
      "ja": "TLS / DTLSは、アラートプロトコルを使用してエラーを伝え、エラータイプの長いリストを指定します。ただし、TLS / DTLS仕様で定義されているすべてのエラーメッセージがこのプロファイルに適用できるわけではありません。一般に、エラーには2つのカテゴリがあります（RFC 5246のセクション7.2で定義されています）。つまり、致命的なエラーと警告です。 「致命的」のレベルのアラートメッセージは、接続を即座に終了させます。可能であれば、開発者は、ハンドシェイクの再起動や（多くの場合は制限されている）ユーザーインターフェイスを使用したユーザーへの通知など、これらの致命的なエラーに対応する戦略を開発する必要があります。多くのIoTデバイスには、エラーをログに記録する方法が限られているか、まったく機能しないため、警告はアプリケーションによって無視される場合があります。いずれにせよ、ユーザーに意思決定を委任するために一般的に使用されるアプローチはタイムリーに達成することが困難（または不可能）であるため、実装者はエラーの影響と状況を改善する方法を慎重に評価する必要があります。"
    },
    {
      "indent": 3,
      "text": "All error messages marked as RESERVED are only supported for backwards compatibility with the Secure Socket Layer (SSL) and MUST NOT be used with this profile. Those include decryption_failed_RESERVED, no_certificate_RESERVED, and export_restriction_RESERVED.",
      "ja": "RESERVEDとマークされたすべてのエラーメッセージは、Secure Socket Layer（SSL）との下位互換性のためにのみサポートされており、このプロファイルでは使用しないでください。それらには、decryption_failed_RESERVED、no_certificate_RESERVED、およびexport_restriction_RESERVEDが含まれます。"
    },
    {
      "indent": 3,
      "text": "A number of the error messages MUST only be used for certificate-based ciphersuites. Hence, the following error messages MUST NOT be used with PSK and raw public key authentication:",
      "ja": "いくつかのエラーメッセージは、証明書ベースの暗号スイートにのみ使用する必要があります。したがって、次のエラーメッセージはPSKおよび生の公開鍵認証で使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o bad_certificate,",
      "ja": "o bad_certificate、"
    },
    {
      "indent": 3,
      "text": "o unsupported_certificate,",
      "ja": "o unsupported_certificate、"
    },
    {
      "indent": 3,
      "text": "o certificate_revoked,",
      "ja": "o certificate_revoked、"
    },
    {
      "indent": 3,
      "text": "o certificate_expired,",
      "ja": "o certificate_expired、"
    },
    {
      "indent": 3,
      "text": "o certificate_unknown,",
      "ja": "o certificate_unknown、"
    },
    {
      "indent": 3,
      "text": "o unknown_ca, and",
      "ja": "o unknown_ca、および"
    },
    {
      "indent": 3,
      "text": "o access_denied.",
      "ja": "o アクセスが拒否されました。"
    },
    {
      "indent": 3,
      "text": "Since this profile does not make use of compression at the TLS layer, the decompression_failure error message MUST NOT be used either.",
      "ja": "このプロファイルはTLSレイヤーで圧縮を利用しないため、decompression_failureエラーメッセージも使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "RFC 4279 introduced the new alert message \"unknown_psk_identity\" for PSK ciphersuites. As stated in Section 2 of RFC 4279, the decrypt_error error message may also be used instead. For this profile, the TLS server MUST return the decrypt_error error message instead of the unknown_psk_identity since the two mechanisms exist and provide the same functionality.",
      "ja": "RFC 4279では、PSK暗号スイート用の新しい警告メッセージ「unknown_psk_identity」が導入されました。 RFC 4279のセクション2に記載されているように、代わりに、decrypt_errorエラーメッセージを使用することもできます。このプロファイルでは、2つのメカニズムが存在し、同じ機能を提供するため、TLSサーバーはunknown_psk_identityではなく、decrypt_errorエラーメッセージを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the following errors should not occur with devices and servers supporting this specification, but implementations MUST be prepared to process these errors to deal with servers that are not compliant to the profiles in this document:",
      "ja": "さらに、この仕様をサポートするデバイスとサーバーでは次のエラーは発生しませんが、このドキュメントのプロファイルに準拠していないサーバーを処理するには、これらのエラーを処理するための実装を準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "protocol_version: While this document focuses only on one version of the TLS/DTLS protocol, namely version 1.2, ongoing work on TLS/ DTLS 1.3 is in progress at the time of writing.",
      "ja": "protocol_version：このドキュメントはTLS / DTLSプロトコルの1つのバージョン、つまりバージョン1.2のみに焦点を当てていますが、執筆時点でTLS / DTLS 1.3に関する進行中の作業が進行中です。"
    },
    {
      "indent": 3,
      "text": "insufficient_security: This error message indicates that the server requires ciphers to be more secure. This document specifies only one ciphersuite per profile, but it is likely that additional ciphersuites will get added over time.",
      "ja": "不十分なセキュリティ：このエラーメッセージは、サーバーがより安全な暗号を必要とすることを示します。このドキュメントでは、プロファイルごとに1つの暗号スイートのみを指定していますが、今後、追加の暗号スイートが追加される可能性があります。"
    },
    {
      "indent": 3,
      "text": "user_canceled: Many IoT devices are unattended and hence this error message is unlikely to occur.",
      "ja": "user_canceled：多くのIoTデバイスは無人であるため、このエラーメッセージはほとんど発生しません。"
    },
    {
      "indent": 0,
      "text": "7. Session Resumption",
      "section_title": true,
      "ja": "7. セッション再開"
    },
    {
      "indent": 3,
      "text": "Session resumption is a feature of the core TLS/DTLS specifications that allows a client to continue with an earlier established session state. The resulting exchange is shown in Figure 11. In addition, the server may choose not to do a cookie exchange when a session is resumed. Still, clients have to be prepared to do a cookie exchange with every handshake. The cookie exchange is not shown in the figure.",
      "ja": "セッション再開は、クライアントが以前に確立されたセッション状態を続行できるようにするコアTLS / DTLS仕様の機能です。結果の交換を図11に示します。さらに、サーバーは、セッションが再開されたときにCookie交換を行わないことを選択する場合があります。それでも、クライアントはすべてのハンドシェイクでCookieを交換する準備をする必要があります。 Cookie交換は図には示されていません。"
    },
    {
      "indent": 9,
      "text": "Client                                               Server\n------                                               ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "ClientHello                   -------->\n                                                 ServerHello\n                                          [ChangeCipherSpec]\n                              <--------             Finished\n[ChangeCipherSpec]\nFinished                      -------->\nApplication Data              <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 11: DTLS Session Resumption",
      "ja": "図11：DTLSセッションの再開"
    },
    {
      "indent": 3,
      "text": "Constrained clients MUST implement session resumption to improve the performance of the handshake. This will lead to a reduced number of message exchanges, lower computational overhead (since only symmetric cryptography is used during a session resumption exchange), and session resumption requires less bandwidth.",
      "ja": "制約付きクライアントは、ハンドシェイクのパフォーマンスを向上させるためにセッション再開を実装する必要があります。これにより、メッセージ交換の数が減り、計算オーバーヘッドが減少します（セッション再開交換中に対称暗号化のみが使用されるため）、セッション再開に必要な帯域幅が少なくなります。"
    },
    {
      "indent": 0,
      "text": " For cases where the server is constrained (but not the client), the client MUST implement RFC 5077 [RFC5077]. Note that the constrained server refers to a device that has limitations in terms of RAM and flash memory, which place restrictions on the amount of TLS/DTLS security state information that can be stored on such a device. RFC 5077 specifies a version of TLS/DTLS session resumption that does not require per-session state information to be maintained by the constrained server. This is accomplished by using a ticket-based approach.",
      "ja": "サーバーが（クライアントではなく）制約されている場合、クライアントはRFC 5077 [RFC5077]を実装しなければなりません（MUST）。制約付きサーバーとは、RAMやフラッシュメモリに関して制限のあるデバイスを指し、そのようなデバイスに保存できるTLS / DTLSセキュリティ状態情報の量に制限を課すことに注意してください。 RFC 5077は、セッションごとの状態情報を制約付きサーバーで維持する必要がないTLS / DTLSセッション再開のバージョンを指定しています。これは、チケットベースのアプローチを使用して実現されます。"
    },
    {
      "indent": 3,
      "text": "If both the client and the server are constrained devices, both devices SHOULD implement RFC 5077 and MUST implement basic session resumption. Clients that do not want to use session resumption are always able to send a ClientHello message with an empty session_id to revert to a full handshake.",
      "ja": "クライアントとサーバーの両方が制約されたデバイスである場合、両方のデバイスはRFC 5077を実装する必要があり（SHOULD）、基本的なセッション再開を実装する必要があります（MUST）。セッションの再開を使用したくないクライアントは、完全なハンドシェイクに戻すために、常に空のsession_idを使用してClientHelloメッセージを送信できます。"
    },
    {
      "indent": 0,
      "text": "8. Compression",
      "section_title": true,
      "ja": "8. 圧縮"
    },
    {
      "indent": 3,
      "text": "Section 3.3 of [RFC7525] recommends disabling TLS-/DTLS-level compression due to attacks, such as CRIME [CRIME]. For IoT applications, compression at the TLS/DTLS layer is not needed since application-layer protocols are highly optimized, and the compression algorithms at the DTLS layer increases code size and complexity.",
      "ja": "[RFC7525]のセクション3.3では、CRIME [CRIME]などの攻撃によるTLSレベル/ DTLSレベルの圧縮を無効にすることを推奨しています。 IoTアプリケーションの場合、アプリケーション層プロトコルが高度に最適化されているため、TLS / DTLS層での圧縮は必要ありません。DTLS層での圧縮アルゴリズムにより、コードのサイズと複雑さが増します。"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS layer compression is NOT RECOMMENDED by this TLS/DTLS profile.",
      "ja": "TLS / DTLSレイヤー圧縮は、このTLS / DTLSプロファイルでは推奨されません。"
    },
    {
      "indent": 0,
      "text": "9. Perfect Forward Secrecy",
      "section_title": true,
      "ja": "9. 完全転送秘密"
    },
    {
      "indent": 3,
      "text": "PFS is a property that preserves the confidentiality of past protocol interactions even in situations where the long-term secret is compromised.",
      "ja": "PFSは、長期的な秘密が危険にさらされている状況でも、過去のプロトコル相互作用の機密性を保持するプロパティです。"
    },
    {
      "indent": 3,
      "text": "The PSK ciphersuite recommended in Section 4.2 does not offer this property since it does not utilize a DH exchange. New ciphersuites that support PFS for PSK-based authentication, such as proposed in [PSK-AES-CCM-TLS], might become available as a standardized ciphersuite in the (near) future. The recommended PSK-based ciphersuite offers excellent performance, a very small memory footprint, and has the lowest on the wire overhead at the expense of not using any public cryptography. For deployments where public key cryptography is acceptable, the use of raw public keys might offer a middle ground between the PSK ciphersuite in terms of out-of-band validation and the functionality offered by asymmetric cryptography.",
      "ja": "セクション4.2で推奨されているPSK暗号スイートは、DH交換を利用しないため、このプロパティを提供していません。 [PSK-AES-CCM-TLS]で提案されているような、PSKベースの認証用のPFSをサポートする新しい暗号スイートは、標準化された暗号スイートとして（近い将来）利用できるようになる可能性があります。推奨されるPSKベースの暗号スイートは、優れたパフォーマンス、非常に小さなメモリフットプリントを提供し、パブリック暗号化を使用しないという犠牲を払って、オーバーヘッドを最小限に抑えます。公開キー暗号化が許容される展開の場合、未加工の公開キーを使用すると、帯域外検証の点でPSK暗号スイートと非対称暗号化によって提供される機能の中間点が提供される可能性があります。"
    },
    {
      "indent": 0,
      "text": " Physical attacks create additional opportunities to gain access to the crypto material stored on IoT devices. A PFS ciphersuite prevents an attacker from obtaining the communication content exchanged prior to a successful long-term key compromise; however, an implementation that (for performance or energy efficiency reasons) has been reusing the same ephemeral DH keys over multiple different sessions partially defeats PFS, thus increasing the damage extent. For this reason, implementations SHOULD NOT reuse ephemeral DH keys over multiple protocol exchanges.",
      "ja": "物理的な攻撃は、IoTデバイスに保存されている暗号化された素材へのアクセスを獲得する追加の機会を生み出します。 PFS暗号スイートは、長期的な鍵の侵害に成功する前に、攻撃者が交換された通信コンテンツを取得することを防ぎます。ただし、（パフォーマンスまたはエネルギー効率の理由で）複数の異なるセッションで同じ一時的なDHキーを再利用している実装では、PFSが部分的に無効になり、損傷の範囲が拡大します。このため、実装では、複数のプロトコル交換で一時的なDHキーを再利用しないでください。"
    },
    {
      "indent": 3,
      "text": "The impact of the disclosure of past communication interactions and the desire to increase the cost for pervasive monitoring (as demanded by [RFC7258]) has to be taken into account when selecting a ciphersuite that does not support the PFS property.",
      "ja": "PFSプロパティをサポートしない暗号スイートを選択するときは、過去の通信相互作用の開示の影響と、（[RFC7258]で要求されているように）広範な監視のコストを増やしたいという要望を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Client implementations claiming support of this profile MUST implement the ciphersuites listed in Section 4 according to the selected credential type.",
      "ja": "このプロファイルのサポートを要求するクライアントの実装は、選択された資格情報の種類に従って、セクション4に記載されている暗号スイートを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Keep-Alive",
      "section_title": true,
      "ja": "10. 生き続ける"
    },
    {
      "indent": 3,
      "text": "Application-layer communication may create state at the endpoints, and this state may expire at some time. For this reason, applications define ways to refresh state, if necessary. While the application-layer exchanges are largely outside the scope of the underlying TLS/DTLS exchange, similar state considerations also play a role at the level of TLS/DTLS. While TLS/DTLS also creates state in the form of a security context (see the security parameter described in Appendix A.6 in RFC 5246) at the client and the server, this state information does not expire. However, network intermediaries may also allocate state and require this state to be kept alive. Failure to keep state alive at a stateful packet filtering firewall or at a NAT may result in the inability for one node to reach the other since packets will get blocked by these middleboxes. Periodic keep-alive messages exchanged between the TLS/ DTLS client and server keep state at these middleboxes alive. According to measurements described in [HomeGateway], there is some variance in state management practices used in residential gateways, but the timeouts are heavily impacted by the choice of the transport-layer protocol: timeouts for UDP are typically much shorter than those for TCP.",
      "ja": "アプリケーション層の通信により、エンドポイントで状態が作成され、この状態がいつか期限切れになる場合があります。このため、アプリケーションは、必要に応じて状態を更新する方法を定義します。アプリケーション層の交換は基本的にTLS / DTLS交換の範囲外ですが、同様の状態に関する考慮事項もTLS / DTLSのレベルで役割を果たします。 TLS / DTLSは、クライアントとサーバーでセキュリティコンテキスト（RFC 5246の付録A.6で説明されているセキュリティパラメータを参照）の形で状態も作成しますが、この状態情報は期限切れになりません。ただし、ネットワーク仲介者が状態を割り当て、この状態を維持する必要がある場合もあります。ステートフルパケットフィルタリングファイアウォールまたはNATで状態を維持できない場合、パケットがこれらのミドルボックスによってブロックされるため、一方のノードが他方のノードに到達できなくなる可能性があります。 TLS / DTLSクライアントとサーバー間で交換される定期的なキープアライブメッセージは、これらのミドルボックスの状態を維持します。 [HomeGateway]で説明されている測定によると、レジデンシャルゲートウェイで使用される状態管理手法にはいくつかの違いがありますが、タイムアウトはトランスポート層プロトコルの選択によって大きく影響を受けます。UDPのタイムアウトは、通常、TCPのタイムアウトよりもはるかに短いです。"
    },
    {
      "indent": 3,
      "text": "RFC 6520 [RFC6520] defines a heartbeat mechanism to test whether the other peer is still alive. As an additional feature, the same mechanism can also be used to perform Path Maximum Transmission Unit (MTU) Discovery.",
      "ja": "RFC 6520 [RFC6520]は、他のピアがまだ生きているかどうかをテストするハートビートメカニズムを定義しています。追加機能として、同じメカニズムを使用してパス最大伝送ユニット（MTU）の検出を実行することもできます。"
    },
    {
      "indent": 0,
      "text": " A recommendation about the use of RFC 6520 depends on the type of message exchange an IoT device performs and the number of messages the application needs to exchange as part of their application functionality. There are three types of exchanges that need to be analyzed: Client-Initiated, One-Shot Messages",
      "ja": "RFC 6520の使用に関する推奨事項は、IoTデバイスが実行するメッセージ交換のタイプと、アプリケーション機能の一部としてアプリケーションが交換する必要があるメッセージの数によって異なります。分析する必要のある交換には、3つのタイプがあります。クライアントが開始した、ワンショットメッセージ"
    },
    {
      "indent": 6,
      "text": "This is a common communication pattern where IoT devices upload data to a server on the Internet on an irregular basis. The communication may be triggered by specific events, such as opening a door.",
      "ja": "これは、IoTデバイスが不定期にインターネット上のサーバーにデータをアップロードする一般的な通信パターンです。通信は、ドアを開けるなどの特定のイベントによってトリガーされる場合があります。"
    },
    {
      "indent": 6,
      "text": "The DTLS handshake may need to be restarted (ideally using session resumption, if possible) in case of an IP address change.",
      "ja": "IPアドレスが変更された場合は、DTLSハンドシェイクの再起動が必要な場合があります（可能であれば、セッション再開を使用するのが理想的です）。"
    },
    {
      "indent": 6,
      "text": "In this case, there is no use for a keep-alive extension for this scenario.",
      "ja": "この場合、このシナリオではキープアライブ拡張は使用できません。"
    },
    {
      "indent": 3,
      "text": "Client-Initiated, Regular Data Uploads",
      "ja": "クライアントが開始する定期的なデータアップロード"
    },
    {
      "indent": 6,
      "text": "This is a variation of the previous case whereby data gets uploaded on a regular basis, for example, based on frequent temperature readings. If neither NAT bindings nor IP address changes occurred, then the record layer will not notice any changes. For the case where the IP address and port number changes, it is necessary to recreate the record layer using session resumption.",
      "ja": "これは、データが定期的に、たとえば、頻繁な温度の読み取りに基づいてアップロードされる、前のケースのバリエーションです。 NATバインディングもIPアドレスの変更も発生しなかった場合、レコードレイヤーは変更を認識しません。 IPアドレスとポート番号が変更された場合は、セッション再開を利用してレコード層を再作成する必要があります。"
    },
    {
      "indent": 6,
      "text": "In this scenario, there is no use for a keep-alive extension. It is also very likely that the device will enter a sleep cycle in between data transmissions to keep power consumption low.",
      "ja": "このシナリオでは、キープアライブ拡張の使用はありません。また、デバイスがデータ送信の間にスリープサイクルに入り、電力消費を低く抑える可能性も高くなります。"
    },
    {
      "indent": 3,
      "text": "Server-Initiated Messages",
      "ja": "サーバー起動メッセージ"
    },
    {
      "indent": 6,
      "text": "In the two previous scenarios, the client initiates the protocol interaction and maintains it. Since messages to the client may get blocked by middleboxes, the initial connection setup is triggered by the client and then kept alive by the server.",
      "ja": "前の2つのシナリオでは、クライアントはプロトコルの相互作用を開始し、それを維持します。クライアントへのメッセージはミドルボックスによってブロックされる可能性があるため、初期接続セットアップはクライアントによってトリガーされ、サーバーによって維持されます。"
    },
    {
      "indent": 6,
      "text": "For this message exchange pattern, the use of DTLS heartbeat messages is quite useful but may have to be coordinated with application exchanges (for example, when the CoAP resource directory is used) to avoid redundant keep-alive message exchanges. The MTU discovery mechanism, which is also part of [RFC6520], is less likely to be relevant since for many IoT deployments, the most constrained link is the wireless interface between the IoT device and the network itself (rather than some links along the end-to-end path). Only in more complex network topologies, such as multi-hop mesh networks, path MTU discovery might be appropriate. It also has to be noted that DTLS itself already provides a basic path discovery mechanism (see Section 4.1.1.1 of RFC 6347) by using the fragmentation capability of the handshake protocol.",
      "ja": "このメッセージ交換パターンの場合、DTLSハートビートメッセージの使用は非常に便利ですが、冗長なキープアライブメッセージ交換を回避するために、アプリケーション交換（CoAPリソースディレクトリが使用される場合など）と調整する必要がある場合があります。 [RFC6520]の一部でもあるMTU検出メカニズムは、多くのIoT展開で最も制約のあるリンクがIoTデバイスとネットワーク自体の間の無線インターフェースであるため、関連性が低くなります（エンドに沿ったいくつかのリンクではありません） -to-endパス）。マルチホップメッシュネットワークなどのより複雑なネットワークトポロジでのみ、パスMTU検出が適切な場合があります。また、DTLS自体は、ハンドシェイクプロトコルのフラグメンテーション機能を使用して、基本的なパス検出メカニズム（RFC 6347のセクション4.1.1.1を参照）をすでに提供していることにも注意してください。"
    },
    {
      "indent": 3,
      "text": "For server-initiated messages, the heartbeat extension is RECOMMENDED.",
      "ja": "サーバー起動メッセージの場合、ハートビート拡張はRECOMMENDEDです。"
    },
    {
      "indent": 0,
      "text": "11. Timeouts",
      "section_title": true,
      "ja": "11. タイムアウト"
    },
    {
      "indent": 3,
      "text": "A variety of wired and wireless technologies are available to connect devices to the Internet. Many of the low-power radio technologies, such as IEEE 802.15.4 or Bluetooth Smart, only support small frame sizes (e.g., 127 bytes in case of IEEE 802.15.4 as explained in [RFC4919]). Other radio technologies, such as the Global System for Mobile Communications (GSM) using the short messaging service (SMS), have similar constraints in terms of payload sizes, such as 140 bytes without the optional segmentation and reassembly scheme known as \"Concatenated SMS\", but show higher latency.",
      "ja": "デバイスをインターネットに接続するために、さまざまな有線および無線テクノロジを利用できます。 IEEE 802.15.4やBluetooth Smartなどの低電力無線技術の多くは、小さなフレームサイズ（たとえば、[RFC4919]で説明されているIEEE 802.15.4の場合は127バイト）のみをサポートしています。ショートメッセージングサービス（SMS）を使用するモバイルシステムのグローバルシステム（GSM）などの他の無線技術には、ペイロードサイズの点で同様の制約があります。たとえば、「連結SMS」として知られるオプションのセグメンテーションと再構成スキームがない140バイトなどです。 、しかしより長い待ち時間を示しています。"
    },
    {
      "indent": 3,
      "text": "The DTLS handshake protocol adds a fragmentation and reassembly mechanism to the TLS handshake protocol since each DTLS record must fit within a single transport layer datagram, as described in Section 4.2.3 of [RFC6347]. Since handshake messages are potentially bigger than the maximum record size, the mechanism fragments a handshake message over a number of DTLS records, each of which can be transmitted separately.",
      "ja": "[RFC6347]のセクション4.2.3で説明されているように、各DTLSレコードは単一のトランスポート層データグラム内に収まる必要があるため、DTLSハンドシェイクプロトコルはTLSハンドシェイクプロトコルにフラグメンテーションおよび再構成メカニズムを追加します。ハンドシェイクメッセージは最大レコードサイズよりも大きくなる可能性があるため、メカニズムは、ハンドシェイクメッセージを複数のDTLSレコードにフラグメント化し、それぞれを個別に送信できます。"
    },
    {
      "indent": 3,
      "text": "To deal with the unreliable message delivery provided by UDP, DTLS adds timeouts and \"per-flight\" retransmissions, as described in Section 4.2.4 of [RFC6347]. Although the timeout values are implementation specific, recommendations are provided in Section 4.2.4.1 of [RFC6347], with an initial timer value of 1 second and double the value at each retransmission, up to no less than 60 seconds.",
      "ja": "[RFC6347]のセクション4.2.4で説明されているように、UDPが提供する信頼性の低いメッセージ配信に対処するために、DTLSはタイムアウトと「フライ​​トごとの」再送信を追加します。タイムアウト値は実装固有ですが、推奨事項は[RFC6347]のセクション4.2.4.1で提供されており、タイマーの初期値は1秒で、再送信のたびに値が2倍になり、最大60秒です。"
    },
    {
      "indent": 3,
      "text": "TLS protocol steps can take longer due to higher processing time on the constrained side. On the other hand, the way DTLS handles retransmission, which is per-flight instead of per-segment, tends to interact poorly with low-bandwidth networks.",
      "ja": "制約された側の処理時間が長くなるため、TLSプロトコルのステップは長くかかる場合があります。一方、DTLSがセグメントごとではなくフライトごとの再送信を処理する方法は、低帯域幅ネットワークとの相互作用が不十分になる傾向があります。"
    },
    {
      "indent": 3,
      "text": "For these reasons, it's essential that the probability of a spurious retransmit is minimized and, on timeout, the sending endpoint does not react too aggressively. The latter is particularly relevant when the Wireless Sensor Network (WSN) is temporarily congested: if lost packets are reinjected too quickly, congestion worsens.",
      "ja": "これらの理由により、スプリアス再送信の可能性を最小限に抑え、タイムアウト時に送信エンドポイントがあまり積極的に反応しないことが重要です。後者は、ワイヤレスセンサーネットワーク（WSN）が一時的に輻輳している場合に特に関係があります。失われたパケットがあまりに速く再注入されると、輻輳が悪化します。"
    },
    {
      "indent": 3,
      "text": "An initial timer value of 9 seconds with exponential back off up to no less then 60 seconds is therefore RECOMMENDED.",
      "ja": "したがって、9秒の初期タイマー値と60秒以上の指数関数的バックオフが推奨されます。"
    },
    {
      "indent": 0,
      "text": " This value is chosen big enough to absorb large latency variance due to either slow computation on constrained endpoints or intrinsic network characteristics (e.g., GSM-SMS), as well as to produce a low number of retransmission events and relax the pacing between them. Its worst case wait time is the same as using 1s timeout (i.e., 63s), while triggering less than half of the retransmissions (2 instead of 5).",
      "ja": "この値は、制約されたエンドポイントでの遅い計算または固有のネットワーク特性（GSM-SMSなど）による遅いレイテンシの変動を吸収し、少ない数の再送信イベントを生成してそれらの間のペーシングを緩和するのに十分な大きさに選択されます。最悪の場合の待機時間は、1秒のタイムアウト（つまり63秒）を使用する場合と同じですが、再送信の半分未満（5ではなく2）をトリガーします。"
    },
    {
      "indent": 3,
      "text": "In order to minimize the wake time during DTLS handshake, sleepy nodes might decide to select a lower threshold and, consequently, a smaller initial timeout value. If this is the case, the implementation MUST keep into account the considerations about network stability described in this section.",
      "ja": "DTLSハンドシェイク中のウェイク時間を最小限に抑えるために、スリープ状態のノードは、より低いしきい値を選択し、その結果、より小さな初期タイムアウト値を選択する場合があります。この場合、実装では、このセクションで説明するネットワークの安定性に関する考慮事項を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Random Number Generation",
      "section_title": true,
      "ja": "12. 乱数生成"
    },
    {
      "indent": 3,
      "text": "The TLS/DTLS protocol requires random numbers to be available during the protocol run. For example, during the ClientHello and the ServerHello exchange, the client and the server exchange random numbers. Also, the use of the DH exchange requires random numbers during the key pair generation.",
      "ja": "TLS / DTLSプロトコルでは、プロトコルの実行中に乱数を使用できる必要があります。たとえば、ClientHelloとServerHelloの交換中に、クライアントとサーバーは乱数を交換します。また、DH交換を使用するには、鍵ペアの生成中に乱数が必要です。"
    },
    {
      "indent": 3,
      "text": "It is important to note that sources contributing to the randomness pool on laptops or desktop PCs are not available on many IoT devices, such as mouse movement, timing of keystrokes, air turbulence on the movement of hard drive heads, etc. Other sources have to be found or dedicated hardware has to be added.",
      "ja": "ラップトップまたはデスクトップPCのランダムプールに寄与するソースは、マウスの動き、キーストロークのタイミング、ハードドライブヘッドの動きの乱気流など、多くのIoTデバイスでは利用できないことに注意することが重要です。その他のソースは、または専用のハードウェアを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "Lacking sources of randomness in an embedded system may lead to the same keys generated again and again.",
      "ja": "組み込みシステムにランダム性のソースがないと、同じキーが何度も生成される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The ClientHello and the ServerHello messages contain the \"Random\" structure, which has two components: gmt_unix_time and a sequence of 28 random bytes. gmt_unix_time holds the current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT). Since many IoT devices do not have access to an accurate clock, it is RECOMMENDED that the receiver of a ClientHello or ServerHello does not assume that the value in \"Random.gmt_unix_time\" is an accurate representation of the current time and instead treats it as an opaque random string.",
      "ja": "ClientHelloメッセージとServerHelloメッセージには、「ランダム」構造が含まれています。これには、gmt_unix_timeと28個のランダムバイトのシーケンスの2つのコンポーネントがあります。 gmt_unix_timeは、現在の時刻と日付を標準のUNIX 32ビット形式で保持します（GMT、1970年1月1日から始まる午前0時からの秒数）。多くのIoTデバイスは正確なクロックにアクセスできないため、ClientHelloまたはServerHelloの受信者は「Random.gmt_unix_time」の値が現在の時刻の正確な表現であると想定せず、代わりにそれを不透明なランダム文字列。"
    },
    {
      "indent": 3,
      "text": "When TLS is used with certificate-based authentication, the availability of time information is needed to check the validity of a certificate. Higher-layer protocols may provide secure time information. The gmt_unix_time component of the ServerHello is not used for this purpose.",
      "ja": "証明書ベースの認証でTLSを使用する場合、証明書の有効性をチェックするために時間情報の可用性が必要です。上位層プロトコルは、安全な時間情報を提供する場合があります。 ServerHelloのgmt_unix_timeコンポーネントは、この目的には使用されません。"
    },
    {
      "indent": 0,
      "text": " IoT devices using TLS/DTLS must offer ways to generate quality random numbers. There are various implementation choices for integrating a hardware-based random number generator into a product: an implementation inside the microcontroller itself is one option, but dedicated crypto chips are also reasonable choices. The best choice will depend on various factors outside the scope of this document. Guidelines and requirements for random number generation can be found in RFC 4086 [RFC4086] and in the NIST Special Publication 800-90a [SP800-90A].",
      "ja": "TLS / DTLSを使用するIoTデバイスは、高品質の乱数を生成する方法を提供する必要があります。ハードウェアベースの乱数ジェネレーターを製品に統合するには、さまざまな実装の選択肢があります。マイクロコントローラー自体への実装は1つのオプションですが、専用の暗号化チップも妥当な選択肢です。最適な選択は、このドキュメントの範囲外のさまざまな要因によって異なります。乱数生成のガイドラインと要件は、RFC 4086 [RFC4086]およびNIST Special Publication 800-90a [SP800-90A]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Chip manufacturers are highly encouraged to provide sufficient documentation of their design for random number generators so that customers can have confidence about the quality of the generated random numbers. The confidence can be increased by providing information about the procedures that have been used to verify the randomness of numbers generated by the hardware modules. For example, NIST Special Publication 800-22b [SP800-22b] describes statistical tests that can be used to verify random number generators.",
      "ja": "チップメーカーは、生成された乱数の品質について顧客が信頼できるように、乱数ジェネレーターの設計に関する十分な文書を提供することを強くお勧めします。ハードウェアモジュールによって生成された数値のランダム性を検証するために使用された手順に関する情報を提供することにより、信頼性を高めることができます。たとえば、NIST Special Publication 800-22b [SP800-22b]は、乱数ジェネレータの検証に使用できる統計的検定について説明しています。"
    },
    {
      "indent": 0,
      "text": "13. Truncated MAC and Encrypt-then-MAC Extension",
      "section_title": true,
      "ja": "13. 切り詰められたMACおよび暗号化後MAC拡張"
    },
    {
      "indent": 3,
      "text": "The truncated MAC extension was introduced in RFC 6066 [RFC6066] with the goal to reduce the size of the MAC used at the record layer. This extension was developed for TLS ciphersuites that used older modes of operation where the MAC and the encryption operation were performed independently.",
      "ja": "切り捨てられたMAC拡張は、レコード層で使用されるMACのサイズを削減することを目的として、RFC 6066 [RFC6066]で導入されました。この拡張機能は、MACと暗号化操作が独立して実行される古い操作モードを使用したTLS暗号スイート用に開発されました。"
    },
    {
      "indent": 3,
      "text": "The recommended ciphersuites in this document use the newer AEAD construct, namely the CCM mode with 8-octet authentication tags, and are therefore not applicable to the truncated MAC extension.",
      "ja": "このドキュメントで推奨される暗号スイートは、新しいAEADコンストラクト、つまり8オクテット認証タグ付きのCCMモードを使用しているため、切り詰められたMAC拡張には適用されません。"
    },
    {
      "indent": 3,
      "text": "RFC 7366 [RFC7366] introduced the encrypt-then-MAC extension (instead of the previously used MAC-then-encrypt) since the MAC-then-encrypt mechanism has been the subject of a number of security vulnerabilities. RFC 7366 is, however, also not applicable to the AEAD ciphers recommended in this document.",
      "ja": "RFC 7366 [RFC7366]は、MAC-then-encryptメカニズムが多くのセキュリティ脆弱性の対象となっているため、（以前に使用されていたMAC-then-encryptの代わりに）encrypt-then-MAC拡張を導入しました。ただし、RFC 7366は、このドキュメントで推奨されているAEAD暗号にも適用されません。"
    },
    {
      "indent": 3,
      "text": "Implementations conformant to this specification MUST use AEAD ciphers. RFC 7366 (\"encrypt-then-MAC\") and RFC 6066 (\"truncated MAC extension\") are not applicable to this specification and MUST NOT be used.",
      "ja": "この仕様に準拠した実装では、AEAD暗号を使用する必要があります。 RFC 7366（ \"encrypt-then-MAC\"）およびRFC 6066（ \"truncated MAC extension\"）はこの仕様には適用されないため、使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14. Server Name Indication (SNI)",
      "section_title": true,
      "ja": "14. サーバー名表示（SNI）"
    },
    {
      "indent": 3,
      "text": "The SNI extension [RFC6066] defines a mechanism for a client to tell a TLS/DTLS server the name of the server it wants to contact. This is a useful extension for many hosting environments where multiple virtual servers are run on a single IP address.",
      "ja": "SNI拡張[RFC6066]は、クライアントがTLS / DTLSサーバーに、接続したいサーバーの名前を通知するメカニズムを定義しています。これは、複数の仮想サーバーが単一のIPアドレスで実行される多くのホスティング環境に役立つ拡張機能です。"
    },
    {
      "indent": 3,
      "text": "Implementing the Server Name Indication extension is REQUIRED unless it is known that a TLS/DTLS client does not interact with a server in a hosting environment.",
      "ja": "サーバー名表示拡張機能の実装は、TLS / DTLSクライアントがホスティング環境のサーバーと対話しないことがわかっている場合を除き、必須です。"
    },
    {
      "indent": 0,
      "text": "15. Maximum Fragment Length Negotiation",
      "section_title": true,
      "ja": "15. 最大フラグメント長ネゴシエーション"
    },
    {
      "indent": 3,
      "text": "This RFC 6066 extension lowers the maximum fragment length support needed for the record layer from 2^14 bytes to 2^9 bytes.",
      "ja": "このRFC 6066拡張により、レコードレイヤーに必要な最大フラグメント長のサポートが2 ^ 14バイトから2 ^ 9バイトに引き下げられました。"
    },
    {
      "indent": 3,
      "text": "This is a very useful extension that allows the client to indicate to the server how much maximum memory buffers it uses for incoming messages. Ultimately, the main benefit of this extension is to allow client implementations to lower their RAM requirements since the client does not need to accept packets of large size (such as 16K packets as required by plain TLS/DTLS).",
      "ja": "これは、クライアントが着信メッセージに使用する最大メモリバッファーの量をサーバーに示すことができる非常に便利な拡張機能です。最終的に、この拡張の主な利点は、クライアントが大きなサイズのパケット（プレーンなTLS / DTLSで要求される16Kパケットなど）を受け入れる必要がないため、クライアント実装でRAM要件を下げることができることです。"
    },
    {
      "indent": 3,
      "text": "Client implementations MUST support this extension.",
      "ja": "クライアント実装はこの拡張をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "16. Session Hash",
      "section_title": true,
      "ja": "16. セッションハッシュ"
    },
    {
      "indent": 3,
      "text": "In order to begin connection protection, the Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The algorithm for computing the master secret is defined in Section 8.1 of RFC 5246, but it only includes a small number of parameters exchanged during the handshake and does not include parameters like the client and server identities. This can be utilized by an attacker to mount a man-in-the-middle attack since the master secret is not guaranteed to be unique across sessions, as discovered in the \"triple handshake\" attack [Triple-HS].",
      "ja": "接続保護を開始するために、レコードプロトコルでは、一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。マスターシークレットを計算するためのアルゴリズムは、RFC 5246のセクション8.1で定義されていますが、ハンドシェイク中に交換される少数のパラメーターのみが含まれ、クライアントやサーバーのIDなどのパラメーターは含まれていません。 「トリプルハンドシェイク」攻撃[Triple-HS]で発見されたように、マスターシークレットはセッション間で一意であることが保証されていないため、攻撃者はこれを利用して中間者攻撃を開始できます。"
    },
    {
      "indent": 3,
      "text": "[RFC7627] defines a TLS extension that binds the master secret to a log of the full handshake that computes it, thus preventing such attacks.",
      "ja": "[RFC7627]は、マスターシークレットを、それを計算する完全なハンドシェイクのログにバインドするTLS拡張を定義し、そのような攻撃を防ぎます。"
    },
    {
      "indent": 3,
      "text": "Client implementations SHOULD implement this extension even though the ciphersuites recommended by this profile are not vulnerable to this attack. For DH-based ciphersuites, the keying material is contributed by both parties and in case of the pre-shared secret key ciphersuite, both parties need to be in possession of the shared secret to ensure that the handshake completes successfully. It is, however, possible that some application-layer protocols will tunnel other authentication protocols on top of DTLS making this attack relevant again.",
      "ja": "このプロファイルで推奨されている暗号スイートがこの攻撃に対して脆弱ではない場合でも、クライアント実装はこの拡張を実装する必要があります（SHOULD）。 DHベースの暗号スイートの場合、キー生成情報は両方の当事者によって提供され、事前共有秘密鍵暗号スイートの場合、ハンドシェイクが正常に完了するように、両方の当事者が共有秘密を所有している必要があります。ただし、一部のアプリケーション層プロトコルがDTLSの上に他の認証プロトコルをトンネルし、この攻撃を再び関連させる可能性があります。"
    },
    {
      "indent": 0,
      "text": "17. Renegotiation Attacks",
      "section_title": true,
      "ja": "17. 再交渉攻撃"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS allows a client and a server that already have a TLS/DTLS connection to negotiate new parameters, generate new keys, etc., by using the renegotiation feature. Renegotiation happens in the existing connection, with the new handshake packets being encrypted along with application data. Upon completion of the renegotiation procedure, the new channel replaces the old channel.",
      "ja": "TLS / DTLSを使用すると、すでにTLS / DTLS接続を持っているクライアントとサーバーは、再ネゴシエーション機能を使用して、新しいパラメーターのネゴシエート、新しいキーの生成などを行うことができます。再ネゴシエーションは既存の接続で行われ、新しいハンドシェイクパケットはアプリケーションデータとともに暗号化されます。再ネゴシエーション手順が完了すると、新しいチャネルが古いチャネルを置き換えます。"
    },
    {
      "indent": 3,
      "text": "As described in RFC 5746 [RFC5746], there is no cryptographic binding between the two handshakes, although the new handshake is carried out using the cryptographic parameters established by the original handshake.",
      "ja": "RFC 5746 [RFC5746]で説明されているように、新しいハンドシェイクは元のハンドシェイクによって確立された暗号化パラメータを使用して実行されますが、2つのハンドシェイクの間に暗号バインディングはありません。"
    },
    {
      "indent": 3,
      "text": "To prevent the renegotiation attack [RFC5746], this specification REQUIRES the TLS renegotiation feature to be disabled. Clients MUST respond to server-initiated renegotiation attempts with an alert message (no_renegotiation), and clients MUST NOT initiate them.",
      "ja": "再ネゴシエーション攻撃[RFC5746]を防ぐために、この仕様では、TLS再ネゴシエーション機能を無効にする必要があります。クライアントは、サーバーが開始した再ネゴシエーションの試行にアラートメッセージ（no_renegotiation）で応答する必要があり、クライアントはそれらを開始してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "18. Downgrading Attacks",
      "section_title": true,
      "ja": "18. ダウングレード攻撃"
    },
    {
      "indent": 3,
      "text": "When a client sends a ClientHello with a version higher than the highest version known to the server, the server is supposed to reply with ServerHello.version equal to the highest version known to the server, and then the handshake can proceed. This behavior is known as version tolerance. Version intolerance is when the server (or a middlebox) breaks the handshake when it sees a ClientHello.version higher than what it knows about. This is the behavior that leads some clients to rerun the handshake with a lower version. As a result, a potential security vulnerability is introduced when a system is running an old TLS/SSL version (e.g., because of the need to integrate with legacy systems). In the worst case, this allows an attacker to downgrade the protocol handshake to SSL 3.0. SSL 3.0 is so broken that there is no secure cipher available for it (see [RFC7568]).",
      "ja": "クライアントがサーバーに認識されている最も高いバージョンよりも高いバージョンのClientHelloを送信すると、サーバーはサーバーに認識されている最も高いバージョンに等しいServerHello.versionで応答し、ハンドシェイクを続行できます。この動作は、バージョントレランスと呼ばれます。バージョン不寛容とは、サーバー（またはミドルボックス）が把握しているよりも高いClientHello.versionを検出したときにハンドシェイクを中断することです。これは、一部のクライアントが古いバージョンでハンドシェイクを再実行するように導く動作です。その結果、システムが古いTLS / SSLバージョンを実行しているときに、潜在的なセキュリティの脆弱性が導入されます（たとえば、レガシーシステムと統合する必要があるため）。最悪の場合、これにより攻撃者はプロトコルハンドシェイクをSSL 3.0にダウングレードできます。 SSL 3.0は非常に壊れているため、利用できる安全な暗号はありません（[RFC7568]を参照）。"
    },
    {
      "indent": 3,
      "text": "The above-described downgrade vulnerability is solved by the TLS Fallback Signaling Cipher Suite Value (SCSV) [RFC7507] extension. However, the solution is not applicable to implementations conforming to this profile since the version negotiation MUST use TLS/DTLS version 1.2 (or higher). More specifically, this implies:",
      "ja": "上記のダウングレードの脆弱性は、TLS Fallback Signaling Cipher Suite Value（SCSV）[RFC7507]拡張機能によって解決されます。ただし、バージョンネゴシエーションはTLS / DTLSバージョン1.2（またはそれ以上）を使用する必要があるため、このソリューションはこのプロファイルに準拠する実装には適用できません。より具体的には、これは次のことを意味します。"
    },
    {
      "indent": 3,
      "text": "o Clients MUST NOT send a TLS/DTLS version lower than version 1.2 in the ClientHello.",
      "ja": "o クライアントは、ClientHelloでバージョン1.2より前のTLS / DTLSバージョンを送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o Clients MUST NOT retry a failed negotiation offering a TLS/DTLS version lower than 1.2.",
      "ja": "o クライアントは、1.2より前のTLS / DTLSバージョンを提供して失敗したネゴシエーションを再試行してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o Servers MUST fail the handshake by sending a protocol_version fatal alert if a TLS/DTLS version >= 1.2 cannot be negotiated. Note that the aborted connection is non-resumable.",
      "ja": "o サーバーは、TLS / DTLSバージョン> = 1.2をネゴシエートできない場合、protocol_versionの致命的なアラートを送信してハンドシェイクに失敗する必要があります。中止された接続は再開できないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "19. Crypto Agility",
      "section_title": true,
      "ja": "19. 暗号アジリティ"
    },
    {
      "indent": 3,
      "text": "This document recommends that software and chip manufacturers implement AES and the CCM mode of operation. This document references the CoAP-recommended ciphersuite choices, which have been selected based on implementation and deployment experience from the IoT community. Over time, the preference for algorithms will, however, change. Not all components of a ciphersuite are likely to change at the same speed. Changes are more likely expected for ciphers, the mode of operation, and the hash algorithms. The recommended key lengths have to be adjusted over time as well. Some deployment environments will also be impacted by local regulation, which might dictate a certain algorithm and key size combination. Ongoing discussions regarding the choice of specific ECC curves will also likely impact implementations. Note that this document does not recommend or mandate a specific ECC curve.",
      "ja": "このドキュメントでは、ソフトウェアおよびチップの製造元がAESおよびCCM動作モードを実装することを推奨しています。このドキュメントは、IoTコミュニティからの実装と展開の経験に基づいて選択された、CoAP推奨の暗号スイートの選択を参照しています。ただし、時間の経過とともに、アルゴリズムの設定は変更されます。暗号スイートのすべてのコンポーネントが同じ速度で変化するとは限りません。変更は、暗号、操作モード、およびハッシュアルゴリズムに対してより可能性が高いです。推奨されるキーの長さも時間とともに調整する必要があります。一部の展開環境は、特定のアルゴリズムとキーサイズの組み合わせを決定する可能性がある地域の規制の影響も受けます。特定のECC曲線の選択に関する継続的な議論も、実装に影響を与える可能性があります。このドキュメントは特定のECC曲線を推奨または義務付けていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The following recommendations can be made to chip manufacturers:",
      "ja": "以下の推奨事項をチップメーカーに行うことができます。"
    },
    {
      "indent": 3,
      "text": "o Make any AES hardware-based crypto implementation accessible to developers working on security implementations at higher layers in the protocol stack. Sometimes hardware implementations are added to microcontrollers to offer support for functionality needed at the link layer and are only available to the on-chip link-layer protocol implementation. Such a setup does not allow application developers to reuse the hardware-based AES implementation.",
      "ja": "o プロトコルスタックの上位層でセキュリティ実装に取り​​組んでいる開発者が、AESハードウェアベースの暗号実装にアクセスできるようにします。リンク層で必要な機能をサポートするためにハードウェア実装がマイクロコントローラーに追加され、オンチップリンク層プロトコル実装でのみ使用できる場合があります。このような設定では、アプリケーション開発者はハードウェアベースのAES実装を再利用できません。"
    },
    {
      "indent": 3,
      "text": "o Provide flexibility for the use of the crypto function with future extensibility in mind. For example, making an AES-CCM implementation available to developers is a first step but such an implementation may not be usable due to parameter differences between an AES-CCM implementation. AES-CCM in IEEE 802.15.4 and Bluetooth Smart use a nonce length of 13 octets while DTLS uses a nonce length of 12 octets. Hardware implementations of AES-CCM for IEEE 802.15.4 and Bluetooth Smart are therefore not reusable by a DTLS stack.",
      "ja": "o 将来の拡張性を考慮して、暗号機能の使用に柔軟性を提供します。たとえば、開発者がAES-CCM実装を利用できるようにすることは最初のステップですが、AES-CCM実装間のパラメーターの違いにより、そのような実装は使用できない場合があります。 IEEE 802.15.4およびBluetooth SmartのAES-CCMは13オクテットのノンス長を使用し、DTLSは12オクテットのノンス長を使用します。したがって、IEEE 802.15.4およびBluetooth Smart用のAES-CCMのハードウェア実装は、DTLSスタックで再利用できません。"
    },
    {
      "indent": 3,
      "text": "o Offer access to building blocks in addition (or as an alternative) to the complete functionality. For example, a chip manufacturer who gives developers access to the AES crypto function can use it to build an efficient AES-GCM implementation. Another example is to make a special instruction available that increases the speed of speed-up carryless multiplications.",
      "ja": "o 完全な機能に加えて（または代替として）ビルディングブロックへのアクセスを提供します。たとえば、AES暗号機能へのアクセスを開発者に提供するチップメーカーは、それを使用して効率的なAES-GCM実装を構築できます。別の例は、キャリーレス乗算の高速化の速度を上げる特別な命令を使用可能にすることです。"
    },
    {
      "indent": 3,
      "text": "As a recommendation for developers and product architects, we suggest that sufficient headroom is provided to allow an upgrade to a newer cryptographic algorithm over the lifetime of the product. As an example, while AES-CCM is recommended throughout this specification, future products might use the ChaCha20 cipher in combination with the Poly1305 authenticator [RFC7539]. The assumption is made that a robust software update mechanism is offered.",
      "ja": "開発者および製品アーキテクトへの推奨事項として、製品のライフタイムを通じて新しい暗号化アルゴリズムにアップグレードできるように十分なヘッドルームを設けることをお勧めします。例として、この仕様全体でAES-CCMが推奨されていますが、将来の製品では、ChaCha20暗号をPoly1305認証システム[RFC7539]と組み合わせて使用​​する可能性があります。堅牢なソフトウェア更新メカニズムが提供されていることを前提としています。"
    },
    {
      "indent": 0,
      "text": "20. Key Length Recommendations",
      "section_title": true,
      "ja": "20. キーの長さの推奨事項"
    },
    {
      "indent": 3,
      "text": "RFC 4492 [RFC4492] gives approximate comparable key sizes for symmetric- and asymmetric-key cryptosystems based on the best-known algorithms for attacking them. While other publications suggest slightly different numbers, such as [Keylength], the approximate relationship still holds true. Figure 12 illustrates the comparable key sizes in bits.",
      "ja": "RFC 4492 [RFC4492]は、それらを攻撃するための最もよく知られているアルゴリズムに基づいて、対称および非対称鍵暗号システムのおおよその同等の鍵サイズを示しています。他の出版物は[Keylength]のようなわずかに異なる数値を提案していますが、おおよその関係はまだ当てはまります。図12は、比較可能なキーのサイズをビットで示しています。"
    },
    {
      "indent": 22,
      "text": " Symmetric  |   ECC   |  DH/DSA/RSA\n------------+---------+-------------\n     80     |   163   |     1024\n    112     |   233   |     2048\n    128     |   283   |     3072\n    192     |   409   |     7680\n    256     |   571   |    15360",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 12: Comparable Key Sizes (in Bits) Based on RFC 4492",
      "ja": "図12：RFC 4492に基づく比較可能なキーサイズ（ビット）"
    },
    {
      "indent": 3,
      "text": "At the time of writing, the key size recommendations for use with TLS-based ciphers found in [RFC7525] recommend DH key lengths of at least 2048 bits, which corresponds to a 112-bit symmetric key and a 233-bit ECC key. These recommendations are roughly in line with those from other organizations, such as the National Institute of Standards and Technology (NIST) or the European Network and Information Security Agency (ENISA). The authors of [ENISA-Report2013] add that a 80-bit symmetric key is sufficient for legacy applications for the coming years, but a 128-bit symmetric key is the minimum requirement for new systems being deployed. The authors further note that one needs to also take into account the length of time data needs to be kept secure for. The use of 80-bit symmetric keys for transactional data may be acceptable for the near future while one has to insist on 128-bit symmetric keys for long-lived data.",
      "ja": "これを書いている時点では、[RFC7525]にあるTLSベースの暗号で使用するためのキーサイズの推奨では、少なくとも2048ビットのDHキーの長さを推奨しています。これは、112ビットの対称キーと233ビットのECCキーに対応します。これらの推奨事項は、国立標準技術研究所（NIST）や欧州ネットワーク情報セキュリティ局（ENISA）などの他の組織からの推奨事項とほぼ一致しています。 [ENISA-Report2013]の作成者は、今後数年間はレガシーアプリケーションでは80ビットの対称鍵で十分であると述べていますが、128ビットの対称鍵は新しいシステムを導入するための最小要件です。著者はさらに、データを安全に保つ必要がある時間の長さも考慮する必要があることに注意します。トランザクションデータに80ビット対称キーを使用することは、近い将来に受け入れられる可能性がありますが、長期間有効なデータには128ビット対称キーを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": " Note that the recommendations for 112-bit symmetric keys are chosen conservatively under the assumption that IoT devices have a long expected lifetime (such as 10+ years) and that this key length recommendation refers to the long-term keys used for device authentication. Keys, which are provisioned dynamically, for the protection of transactional data (such as ephemeral DH keys used in various TLS/DTLS ciphersuites) may be shorter considering the sensitivity of the exchanged data.",
      "ja": "112ビット対称キーの推奨事項は、IoTデバイスの予想寿命が長い（10年以上など）と想定して控えめに選択されており、このキー長の推奨事項はデバイス認証に使用される長期キーを参照していることに注意してください。トランザクションデータを保護するために動的にプロビジョニングされるキー（さまざまなTLS / DTLS暗号スイートで使用される一時的なDHキーなど）は、交換されるデータの機密性を考慮すると短くなる場合があります。"
    },
    {
      "indent": 0,
      "text": "21. False Start",
      "section_title": true,
      "ja": "21. 誤ったスタート"
    },
    {
      "indent": 3,
      "text": "A full TLS handshake as specified in [RFC5246] requires two full protocol rounds (four flights) before the handshake is complete and the protocol parties may begin to send application data.",
      "ja": "[RFC5246]で指定されている完全なTLSハンドシェイクでは、ハンドシェイクが完了してプロトコルパーティがアプリケーションデータの送信を開始する前に、2回の完全なプロトコルラウンド（4フライト）が必要です。"
    },
    {
      "indent": 3,
      "text": "An abbreviated handshake (resuming an earlier TLS session) is complete after three flights, thus adding just one round-trip time if the client sends application data first.",
      "ja": "省略されたハンドシェイク（以前のTLSセッションを再開する）は、3つのフライトの後に完了します。したがって、クライアントが最初にアプリケーションデータを送信する場合、往復時間が1つだけ追加されます。"
    },
    {
      "indent": 3,
      "text": "If the conditions outlined in [TLS-FALSESTART] are met, application data can be transmitted when the sender has sent its own \"ChangeCipherSpec\" and \"Finished\" messages. This achieves an improvement of one round-trip time for full handshakes if the client sends application data first and for abbreviated handshakes if the server sends application data first.",
      "ja": "[TLS-FALSESTART]で概説されている条件が満たされている場合、送信者が独自の「ChangeCipherSpec」および「Finished」メッセージを送信したときに、アプリケーションデータを送信できます。これにより、クライアントが最初にアプリケーションデータを送信する場合は完全なハンドシェイク、サーバーが最初にアプリケーションデータを送信する場合は省略されたハンドシェイクの1回のラウンドトリップ時間が短縮されます。"
    },
    {
      "indent": 3,
      "text": "The conditions for using the TLS False Start mechanism are met by the public-key-based ciphersuites in this document. In summary, the conditions are:",
      "ja": "TLS False Startメカニズムを使用するための条件は、このドキュメントの公開鍵ベースの暗号スイートによって満たされます。要約すると、条件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Modern symmetric ciphers with an effective key length of 128 bits, such as AES-128-CCM",
      "ja": "o AES-128-CCMなど、有効なキーの長さが128ビットの最新の対称暗号"
    },
    {
      "indent": 3,
      "text": "o Client certificate types, such as ecdsa_sign",
      "ja": "o ecdsa_signなどのクライアント証明書タイプ"
    },
    {
      "indent": 3,
      "text": "o Key exchange methods, such as ECDHE_ECDSA",
      "ja": "o ECDHE_ECDSAなどの鍵交換方式"
    },
    {
      "indent": 3,
      "text": "Based on the improvement over a full round-trip for the full TLS/DTLS exchange, this specification RECOMMENDS the use of the False Start mechanism when clients send application data first.",
      "ja": "完全なTLS / DTLS交換の完全なラウンドトリップに対する改善に基づいて、この仕様は、クライアントが最初にアプリケーションデータを送信するときのFalse Startメカニズムの使用を推奨します。"
    },
    {
      "indent": 0,
      "text": "22. Privacy Considerations",
      "section_title": true,
      "ja": "22. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The DTLS handshake exchange conveys various identifiers, which can be observed by an on-path eavesdropper. For example, the DTLS PSK exchange reveals the PSK identity, the supported extensions, the session ID, algorithm parameters, etc. When session resumption is used, then individual TLS sessions can be correlated by an on-path adversary. With many IoT deployments, it is likely that keying material and their identifiers are persistent over a longer period of time due to the cost of updating software on these devices.",
      "ja": "DTLSハンドシェイク交換は、パス上の盗聴者が監視できるさまざまな識別子を伝達します。たとえば、DTLS PSK交換により、PSK ID、サポートされる拡張機能、セッションID、アルゴリズムパラメータなどが明らかになります。セッション再開が使用される場合、個々のTLSセッションは、パス上の攻撃者によって関連付けられます。多くのIoT展開では、これらのデバイスのソフトウェアを更新するコストが原因で、キー情報とその識別子が長期間にわたって持続する可能性があります。"
    },
    {
      "indent": 3,
      "text": "User participation poses a challenge in many IoT deployments since many of the IoT devices operate unattended, even though they are initially provisioned by a human. The ability to control data sharing and to configure preferences will have to be provided at a system level rather than at the level of the DTLS exchange itself, which is the scope of this document. Quite naturally, the use of DTLS with mutual authentication will allow a TLS server to collect authentication information about the IoT device (likely over a long period of time). While this strong form of authentication will prevent misattribution, it also allows strong identification. Device-related data collection (e.g., sensor recordings) associated with other data types will prove to be truly useful, but this extra data might include personal information about the owner of the device or data about the environment it senses. Consequently, the data stored on the server side will be vulnerable to stored data compromise. For the communication between the client and the server, this specification prevents eavesdroppers from gaining access to the communication content. While the PSK-based ciphersuite does not provide PFS, the asymmetric versions do. This prevents an adversary from obtaining past communication content when access to a long-term secret has been gained. Note that no extra effort to make traffic analysis more difficult is provided by the recommendations made in this document.",
      "ja": "多くのIoTデバイスは、最初は人間によってプロビジョニングされていますが、無人で動作するため、ユーザーの参加は多くのIoT展開で課題となります。データ共有を制御し、設定を構成する機能は、このドキュメントの範囲であるDTLS交換自体のレベルではなく、システムレベルで提供する必要があります。当然のことながら、相互認証でDTLSを使用すると、TLSサーバーはIoTデバイスに関する認証情報を（おそらく長期間にわたって）収集できます。この強力な形式の認証は誤帰属を防ぐ一方で、強力な識別を可能にします。他のデータタイプに関連付けられているデバイス関連のデータ収集（例：センサーの記録）は本当に役立つことが判明しますが、この追加のデータには、デバイスの所有者に関する個人情報やデバイスが感知する環境に関するデータが含まれる場合があります。その結果、サーバー側に保存されたデータは、保存されたデータの侵害に対して脆弱になります。クライアントとサーバー間の通信では、この仕様により、盗聴者が通信コンテンツにアクセスすることを防ぎます。 PSKベースの暗号スイートはPFSを提供しませんが、非対称バージョンは提供します。これにより、長期的な秘密へのアクセスが取得されたときに、攻撃者が過去の通信コンテンツを取得することを防ぎます。このドキュメントでの推奨事項によって、トラフィック分析をさらに困難にするための追加の努力は提供されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that the absence or presence of communication itself might reveal information to an adversary. For example, a presence sensor may initiate messaging when a person enters a building. While TLS/ DTLS would offer confidentiality protection of the transmitted information, it does not help to conceal all communication patterns. Furthermore, the IP header, which is not protected by TLS/DTLS, additionally reveals information about the other communication endpoint. For applications where such privacy concerns exist, additional safeguards are required, such as injecting dummy traffic and onion routing. A detailed treatment of such solutions is outside the scope of this document and requires a system-level view.",
      "ja": "コミュニケーションの不在または存在自体が敵に情報を明らかにする可能性があることに注意してください。たとえば、人が建物に入ると、人感センサーがメッセージングを開始します。 TLS / DTLSは送信された情報の機密保護を提供しますが、すべての通信パターンを隠すのに役立ちません。さらに、TLS / DTLSによって保護されていないIPヘッダーは、他の通信エンドポイントに関する情報をさらに明らかにします。このようなプライバシーの問題が存在するアプリケーションでは、ダミートラフィックの注入やオニオンルーティングなどの追加の保護手段が必要です。このようなソリューションの詳細な処理はこのドキュメントの範囲外であり、システムレベルのビューが必要です。"
    },
    {
      "indent": 0,
      "text": "23. Security Considerations",
      "section_title": true,
      "ja": "23. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document is about security.",
      "ja": "このドキュメント全体はセキュリティに関するものです。"
    },
    {
      "indent": 3,
      "text": "We would also like to point out that designing a software update mechanism into an IoT system is crucial to ensure that both functionality can be enhanced and that potential vulnerabilities can be fixed. This software update mechanism is important for changing configuration information, for example, trust anchors and other keying-related information. Such a suitable software update mechanism is available with the LWM2M protocol published by the OMA [LWM2M].",
      "ja": "また、IoTシステムにソフトウェア更新メカニズムを設計することは、両方の機能を確実に強化し、潜在的な脆弱性を修正できるようにするために重要です。このソフトウェア更新メカニズムは、トラストアンカーやその他のキーイング関連情報などの構成情報を変更するために重要です。そのような適切なソフトウェア更新メカニズムは、OMA [LWM2M]によって公開されたLWM2Mプロトコルで利用できます。"
    },
    {
      "indent": 0,
      "text": "24. References",
      "section_title": true,
      "ja": "24. 参考文献"
    },
    {
      "indent": 0,
      "text": "24.1. Normative References",
      "section_title": true,
      "ja": "24.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[EUI64] IEEE, \"Guidelines for 64-bit Global Identifier (EUI-64)\", Registration Authority, <https://standards.ieee.org/regauth/ oui/tutorials/EUI64.html>.",
      "ja": "[EUI64] IEEE、「64ビットグローバルID（EUI-64）のガイドライン」、登録機関、<https://standards.ieee.org/regauth/ oui / tutorials / EUI64.html>。"
    },
    {
      "indent": 3,
      "text": "[GSM-SMS] ETSI, \"3rd Generation Partnership Project; Technical Specification Group Core Network and Terminals; Technical realization of the Short Message Service (SMS) (Release 13)\", 3GPP TS 23.040 V13.1.0, March 2016.",
      "ja": "[GSM-SMS] ETSI、「3rd Generation Partnership Project; Technical Specification Group Core Network and Terminals; Technical realization of the Short Message Service（Release 13）」、3GPP TS 23.040 V13.1.0、2016年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4279] Eronen, P., Ed. and H. Tschofenig, Ed., \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, DOI 10.17487/RFC4279, December 2005, <http://www.rfc-editor.org/info/rfc4279>.",
      "ja": "[RFC4279] Eronen、P.、Ed。およびH. Tschofenig編、「トランスポート層セキュリティ（TLS）の事前共有鍵暗号」、RFC 4279、DOI 10.17487 / RFC4279、2005年12月、<http://www.rfc-editor.org/info/rfc4279 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5746] Rescorla, E., Ray, M., Dispensa, S., and N. Oskov, \"Transport Layer Security (TLS) Renegotiation Indication Extension\", RFC 5746, DOI 10.17487/RFC5746, February 2010, <http://www.rfc-editor.org/info/rfc5746>.",
      "ja": "[RFC5746] Rescorla、E.、Ray、M.、Dispensa、S。、およびN. Oskov、「Transport Layer Security（TLS）Renegotiation Indication Extension」、RFC 5746、DOI 10.17487 / RFC5746、2010年2月、<http：/ /www.rfc-editor.org/info/rfc5746>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<http://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, \"Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension\", RFC 6520, DOI 10.17487/RFC6520, February 2012, <http://www.rfc-editor.org/info/rfc6520>.",
      "ja": "[RFC6520] Seggelmann、R.、Tuexen、M。、およびM. Williams、「Transport Layer Security（TLS）and Datagram Transport Layer Security（DTLS）Heartbeat Extension」、RFC 6520、DOI 10.17487 / RFC6520、2012年2月、<http ：//www.rfc-editor.org/info/rfc6520>。"
    },
    {
      "indent": 3,
      "text": "[RFC7250] Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J., Weiler, S., and T. Kivinen, \"Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", RFC 7250, DOI 10.17487/RFC7250, June 2014, <http://www.rfc-editor.org/info/rfc7250>.",
      "ja": "[RFC7250] Wouters、P.、Ed。、Tschofenig、H.、Ed。、Gilmore、J.、Weiler、S.、and T. Kivinen、 \"Using Raw Public Keys in Transport Layer Security（TLS）and Datagram Transport Layerセキュリティ（DTLS）」、RFC 7250、DOI 10.17487 / RFC7250、2014年6月、<http://www.rfc-editor.org/info/rfc7250>。"
    },
    {
      "indent": 3,
      "text": "[RFC7251] McGrew, D., Bailey, D., Campagna, M., and R. Dugal, \"AES-CCM Elliptic Curve Cryptography (ECC) Cipher Suites for TLS\", RFC 7251, DOI 10.17487/RFC7251, June 2014, <http://www.rfc-editor.org/info/rfc7251>.",
      "ja": "[RFC7251] McGrew、D.、Bailey、D.、Campagna、M。、およびR. Dugal、「AES-CCM Elliptic Curve Cryptography（ECC）Cipher Suites for TLS」、RFC 7251、DOI 10.17487 / RFC7251、2014年6月、 <http://www.rfc-editor.org/info/rfc7251>。"
    },
    {
      "indent": 3,
      "text": "[RFC7627] Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A., Langley, A., and M. Ray, \"Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension\", RFC 7627, DOI 10.17487/RFC7627, September 2015, <http://www.rfc-editor.org/info/rfc7627>.",
      "ja": "[RFC7627] Bhargavan、K.、Ed。、Delignat-Lavaud、A.、Pironti、A.、Langley、A.、and M. Ray、 \"Transport Layer Security（TLS）Session Hash and Extended Master Secret Extension\"、RFC 7627、DOI 10.17487 / RFC7627、2015年9月、<http://www.rfc-editor.org/info/rfc7627>。"
    },
    {
      "indent": 3,
      "text": "[RFC7924] Santesson, S. and H. Tschofenig, \"Transport Layer Security (TLS) Cached Information Extension\", RFC 7924, DOI 10.17487/RFC7924, July 2016, <http://www.rfc-editor.org/info/rfc7924>.",
      "ja": "[RFC7924] Santesson、S。およびH. Tschofenig、「Transport Layer Security（TLS）Cached Information Extension」、RFC 7924、DOI 10.17487 / RFC7924、2016年7月、<http://www.rfc-editor.org/info/ rfc7924>。"
    },
    {
      "indent": 3,
      "text": "[WAP-WDP] Open Mobile Alliance, \"Wireless Datagram Protocol\", Wireless Application Protocol, WAP-259-WDP, June 2001.",
      "ja": "[WAP-WDP] Open Mobile Alliance、「Wireless Datagram Protocol」、Wireless Application Protocol、WAP-259-WDP、2001年6月。"
    },
    {
      "indent": 0,
      "text": "24.2. Informative References",
      "section_title": true,
      "ja": "24.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ACE-WG] IETF, \"Authentication and Authorization for Constrained Environments (ACE) Working Group\", <https://datatracker.ietf.org/wg/ace/charter>.",
      "ja": "[ACE-WG] IETF、「認証と承認の制約環境（ACE）ワーキンググループ」、<https://datatracker.ietf.org/wg/ace/charter>。"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", NIST FIPS PUB 197, November 2001, <http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[AES]米国国立標準技術研究所、「Advanced Encryption Standard（AES）」、NIST FIPS PUB 197、2001年11月、<http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[CCM] National Institute of Standards and Technology, \"Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality\", NIST Special Publication 800-38C, May 2004, <http://csrc.nist.gov/publications/nistpubs/800-38C/ SP800-38C_updated-July20_2007.pdf>.",
      "ja": "[CCM] National Institute of Standards and Technology、「Block Cipher Modes of Operation：The CCM Mode for Authentication and Confidentiality」、NIST Special Publication 800-38C、May 2004、<http://csrc.nist.gov/publications / nistpubs / 800-38C / SP800-38C_updated-July20_2007.pdf>。"
    },
    {
      "indent": 3,
      "text": "[COAP-TCP-TLS] Bormann, C., Lemay, S., Tschofenig, H., Hartke, K., Silverajan, B., and B. Raymor, \"CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets\", Work in Progress, draft-ietf-core-coap-tcp-tls-03, July 2016.",
      "ja": "[COAP-TCP-TLS] Bormann、C.、Lemay、S.、Tschofenig、H.、Hartke、K.、Silverajan、B.、and B. Raymor、 \"CoAP（Constrained Application Protocol）over TCP、TLS、and WebSockets」、Work in Progress、draft-ietf-core-coap-tcp-tls-03、July 2016。"
    },
    {
      "indent": 3,
      "text": "[CoRE-RD] Shelby, Z., Koster, M., Bormann, C., and P. Stok, \"CoRE Resource Directory\", Work in Progress, draft-ietf-core-resource-directory-08, July 2016.",
      "ja": "[CoRE-RD]シェルビー、Z。、コスター、M。、ボルマン、C。、およびP.ストク、「CoRE Resource Directory」、Work in Progress、draft-ietf-core-resource-directory-08、2016年7月。"
    },
    {
      "indent": 3,
      "text": "[CRIME] Wikipedia, \"CRIME\", May 2016, <https://en.wikipedia.org/w/ index.php?title=CRIME&oldid=721665716>.",
      "ja": "[CRIME]ウィキペディア、「CRIME」、2016年5月、<https://en.wikipedia.org/w/ index.php？title = CRIME＆oldid = 721665716>。"
    },
    {
      "indent": 3,
      "text": "[ENISA-Report2013] ENISA, \"Algorithms, Key Sizes and Parameters Report - 2013\", October 2013, <https://www.enisa.europa.eu/ activities/identity-and-trust/library/deliverables/ algorithms-key-sizes-and-parameters-report>.",
      "ja": "[ENISA-Report2013] ENISA、「アルゴリズム、キーサイズとパラメータレポート-2013」、2013年10月、<https://www.enisa.europa.eu/activity/identity-and-trust/library/deliverables/ algorithm-key -sizes-and-parameters-report>。"
    },
    {
      "indent": 3,
      "text": "[FFDHE-TLS] Gillmor, D., \"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS\", Work in Progress, draft-ietf-tls-negotiated-ff-dhe-10, June 2015.",
      "ja": "[FFDHE-TLS] Gillmor、D。、「ネゴシエートされたTLSの有限フィールドDiffie-Hellman一時パラメータ」、進行中の作業、draft-ietf-tls-negotiated-ff-dhe-10、2015年6月。"
    },
    {
      "indent": 3,
      "text": "[HomeGateway] Eggert, L., Hatoen, S., Kojo, M., Nyrhinen, A., Sarolahti, P., and S. Strowes, \"An Experimental Study of Home Gateway Characteristics\", In Proceedings of the 10th ACM SIGCOMM conference on Internet measurement, DOI 10.1145/1879141.1879174, 2010, <http://conferences.sigcomm.org/imc/2010/papers/p260.pdf>.",
      "ja": "[HomeGateway] Eggert、L.、Hatoen、S.、Kojo、M.、Nyrhinen、A.、Sarolahti、P。、およびS. Strowes、「ホームゲートウェイの特性の実験的研究」、第10回ACM SIGCOMMの議事録インターネット測定に関する会議、DOI 10.1145 / 1879141.1879174、2010、<http://conferences.sigcomm.org/imc/2010/papers/p260.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IANA-TLS] IANA, \"Transport Layer Security (TLS) Parameters\", <https://www.iana.org/assignments/tls-parameters>.",
      "ja": "[IANA-TLS] IANA、「Transport Layer Security（TLS）Parameters」、<https://www.iana.org/assignments/tls-parameters>。"
    },
    {
      "indent": 3,
      "text": "[ImprintingSurvey] Chilton, E., \"A Brief Survey of Imprinting Options for Constrained Devices\", March 2012, <http://www.lix.polytechnique.fr/hipercom/ SmartObjectSecurity/papers/EricRescorla.pdf>.",
      "ja": "[ImprintingSurvey] Chilton、E.、 \"A Brief Survey of Imprinting Options for Constrained Devices\"、March 2012、<http://www.lix.polytechnique.fr/hipercom/ SmartObjectSecurity / papers / EricRescorla.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Keylength] Giry, D., \"Cryptographic Key Length Recommendations\", September 2015, <http://www.keylength.com>.",
      "ja": "[キー長] Giry、D。、「暗号キーの長さの推奨事項」、2015年9月、<http://www.keylength.com>。"
    },
    {
      "indent": 3,
      "text": "[LWM2M] Open Mobile Alliance, \"Lightweight Machine-to-Machine Requirements\", Candidate Version 1.0, OMA-RD-LightweightM2M-V1_0-20131210-C, December 2013, <http://openmobilealliance.org/about-oma/work-program/ m2m-enablers>.",
      "ja": "[LWM2M] Open Mobile Alliance、「Lightweight Machine-to-Machine Requirements」、Candidate Version 1.0、OMA-RD-LightweightM2M-V1_0-20131210-C、December 2013、<http://openmobilealliance.org/about-oma/work -program / m2m-enablers>。"
    },
    {
      "indent": 3,
      "text": "[PSK-AES-CCM-TLS] Schmertmann, L. and C. Bormann, \"ECDHE-PSK AES-CCM Cipher Suites with Forward Secrecy for Transport Layer Security (TLS)\", Work in Progress, draft-schmertmann-dice-ccm-psk-pfs-01, August 2014.",
      "ja": "[PSK-AES-CCM-TLS] Schmertmann、L。、およびC. Bormann、「トランスポート層セキュリティ（TLS）のための前方機密性を備えたECDHE-PSK AES-CCM暗号スイート」、進行中の作業、draft-schmertmann-dice-ccm -psk-pfs-01、2014年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August 1996, <http://www.rfc-editor.org/info/rfc1981>.",
      "ja": "[RFC1981] McCann、J.、Deering、S。、およびJ. Mogul、「Path MTU Discovery for IP version 6」、RFC 1981、DOI 10.17487 / RFC1981、1996年8月、<http：//www.rfc-editor。 org / info / rfc1981>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<http：//www.rfc-editor .org / info / rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, DOI 10.17487/RFC2865, June 2000, <http://www.rfc-editor.org/info/rfc2865>.",
      "ja": "[RFC2865] Rigney、C.、Willens、S.、Rubens、A。、およびW. Simpson、「Remote Authentication Dial In User Service（RADIUS）」、RFC 2865、DOI 10.17487 / RFC2865、2000年6月、<http：/ /www.rfc-editor.org/info/rfc2865>。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] Whiting, D., Housley, R., and N. Ferguson, \"Counter with CBC-MAC (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September 2003, <http://www.rfc-editor.org/info/rfc3610>.",
      "ja": "[RFC3610] Whiting、D.、Housley、R。、およびN. Ferguson、「Counter with CBC-MAC（CCM）」、RFC 3610、DOI 10.17487 / RFC3610、2003年9月、<http：//www.rfc-editor .org / info / rfc3610>。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\", RFC 3748, DOI 10.17487/RFC3748, June 2004, <http://www.rfc-editor.org/info/rfc3748>.",
      "ja": "[RFC3748] Aboba、B.、Blunk、L.、Vollbrecht、J.、Carlson、J。、およびH. Levkowetz、編、「Extensible Authentication Protocol（EAP）」、RFC 3748、DOI 10.17487 / RFC3748、2004年6月、<http://www.rfc-editor.org/info/rfc3748>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 \"Randomness Requirements for Security\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、June 2005、<http：//www.rfc-editor .org / info / rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4492] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)\", RFC 4492, DOI 10.17487/RFC4492, May 2006, <http://www.rfc-editor.org/info/rfc4492>.",
      "ja": "[RFC4492] Blake-Wilson、S.、Bolyard、N.、Gupta、V.、Hawk、C。、およびB. Moeller、「Elliptic Curve Cryptography（ECC）Cipher Suites for Transport Layer Security（TLS）」、RFC 4492 、DOI 10.17487 / RFC4492、2006年5月、<http://www.rfc-editor.org/info/rfc4492>。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <http://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<http://www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC4919] Kushalnagar, N., Montenegro, G., and C. Schumacher, \"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals\", RFC 4919, DOI 10.17487/RFC4919, August 2007, <http://www.rfc-editor.org/info/rfc4919>.",
      "ja": "[RFC4919] Kushalnagar、N。、モンテネグロ、G。、およびC. Schumacher、「IPv6 over Low-Power Wireless Personal Area Networks（6LoWPANs）：Overview、Assumptions、Problem Statement、and Goals」、RFC 4919、DOI 10.17487 / RFC4919 、2007年8月、<http://www.rfc-editor.org/info/rfc4919>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <http://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、Zhou、H.、Eronen、P。、およびH. Tschofenig、「Transport Layer Security（TLS）Session Resumption without server-Side State」、RFC 5077、DOI 10.17487 / RFC5077、January 2008、 <http://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <http://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<http://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5216] Simon, D., Aboba, B., and R. Hurst, \"The EAP-TLS Authentication Protocol\", RFC 5216, DOI 10.17487/RFC5216, March 2008, <http://www.rfc-editor.org/info/rfc5216>.",
      "ja": "[RFC5216]サイモン、D。、アボバ、B。、およびR.ハースト、「EAP-TLS認証プロトコル」、RFC 5216、DOI 10.17487 / RFC5216、2008年3月、<http://www.rfc-editor.org / info / rfc5216>。"
    },
    {
      "indent": 3,
      "text": "[RFC5247] Aboba, B., Simon, D., and P. Eronen, \"Extensible Authentication Protocol (EAP) Key Management Framework\", RFC 5247, DOI 10.17487/RFC5247, August 2008, <http://www.rfc-editor.org/info/rfc5247>.",
      "ja": "[RFC5247] Aboba、B.、Simon、D.、P。Eronen、「Extensible Authentication Protocol（EAP）Key Management Framework」、RFC 5247、DOI 10.17487 / RFC5247、2008年8月、<http：//www.rfc- editor.org/info/rfc5247>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5288] Salowey, J., Choudhury, A., and D. McGrew, \"AES Galois Counter Mode (GCM) Cipher Suites for TLS\", RFC 5288, DOI 10.17487/RFC5288, August 2008, <http://www.rfc-editor.org/info/rfc5288>.",
      "ja": "[RFC5288] Salowey、J.、Choudhury、A。、およびD. McGrew、「TLS用のAES Galois Counter Mode（GCM）Cipher Suites for TLS」、RFC 5288、DOI 10.17487 / RFC5288、2008年8月、<http：// www。 rfc-editor.org/info/rfc5288>。"
    },
    {
      "indent": 3,
      "text": "[RFC5480] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, \"Elliptic Curve Cryptography Subject Public Key Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009, <http://www.rfc-editor.org/info/rfc5480>.",
      "ja": "[RFC5480]ターナー、S。、ブラウン、D。、ユウ、K。、ハウズリー、R。、およびT.ポーク、「楕円曲線暗号サブジェクト公開鍵情報」、RFC 5480、DOI 10.17487 / RFC5480、2009年3月、< http://www.rfc-editor.org/info/rfc5480>。"
    },
    {
      "indent": 3,
      "text": "[RFC5758] Dang, Q., Santesson, S., Moriarty, K., Brown, D., and T. Polk, \"Internet X.509 Public Key Infrastructure: Additional Algorithms and Identifiers for DSA and ECDSA\", RFC 5758, DOI 10.17487/RFC5758, January 2010, <http://www.rfc-editor.org/info/rfc5758>.",
      "ja": "[RFC5758] Dang、Q.、Santesson、S.、Moriarty、K.、Brown、D。、およびT. Polk、「Internet X.509 Public Key Infrastructure：Additional Algorithms and Identifiers for DSA and ECDSA」、RFC 5758、 DOI 10.17487 / RFC5758、2010年1月、<http://www.rfc-editor.org/info/rfc5758>。"
    },
    {
      "indent": 3,
      "text": "[RFC5934] Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor Management Protocol (TAMP)\", RFC 5934, DOI 10.17487/RFC5934, August 2010, <http://www.rfc-editor.org/info/rfc5934>.",
      "ja": "[RFC5934] Housley、R.、Ashmore、S。、およびC. Wallace、「Trust Anchor Management Protocol（TAMP）」、RFC 5934、DOI 10.17487 / RFC5934、2010年8月、<http：//www.rfc-editor。 org / info / rfc5934>。"
    },
    {
      "indent": 3,
      "text": "[RFC6024] Reddy, R. and C. Wallace, \"Trust Anchor Management Requirements\", RFC 6024, DOI 10.17487/RFC6024, October 2010, <http://www.rfc-editor.org/info/rfc6024>.",
      "ja": "[RFC6024] Reddy、R。およびC. Wallace、「Trust Anchor Management Requirements」、RFC 6024、DOI 10.17487 / RFC6024、2010年10月、<http://www.rfc-editor.org/info/rfc6024>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「Fundamental Elliptic Curve Cryptography Algorithms」、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/ info / rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<http：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6655] McGrew, D. and D. Bailey, \"AES-CCM Cipher Suites for Transport Layer Security (TLS)\", RFC 6655, DOI 10.17487/RFC6655, July 2012, <http://www.rfc-editor.org/info/rfc6655>.",
      "ja": "[RFC6655] McGrew、D。およびD. Bailey、「トランスポート層セキュリティ（TLS）のAES-CCM暗号スイート」、RFC 6655、DOI 10.17487 / RFC6655、2012年7月、<http://www.rfc-editor.org / info / rfc6655>。"
    },
    {
      "indent": 3,
      "text": "[RFC6690] Shelby, Z., \"Constrained RESTful Environments (CoRE) Link Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012, <http://www.rfc-editor.org/info/rfc6690>.",
      "ja": "[RFC6690] Shelby、Z。、「Constrained RESTful Environments（CoRE）Link Format」、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、<http://www.rfc-editor.org/info/rfc6690>。"
    },
    {
      "indent": 3,
      "text": "[RFC6733] Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn, Ed., \"Diameter Base Protocol\", RFC 6733, DOI 10.17487/RFC6733, October 2012, <http://www.rfc-editor.org/info/rfc6733>.",
      "ja": "[RFC6733] Fajardo、V.、Ed。、Arkko、J.、Loughney、J.、and G. Zorn、Ed。、 \"Diameter Base Protocol\"、RFC 6733、DOI 10.17487 / RFC6733、October 2012、<http：/ /www.rfc-editor.org/info/rfc6733>。"
    },
    {
      "indent": 3,
      "text": "[RFC6943] Thaler, D., Ed., \"Issues in Identifier Comparison for Security Purposes\", RFC 6943, DOI 10.17487/RFC6943, May 2013, <http://www.rfc-editor.org/info/rfc6943>.",
      "ja": "[RFC6943] Thaler、D。、編、「セキュリティ上の目的での識別子比較の問題」、RFC 6943、DOI 10.17487 / RFC6943、2013年5月、<http://www.rfc-editor.org/info/rfc6943>。"
    },
    {
      "indent": 3,
      "text": "[RFC6961] Pettersen, Y., \"The Transport Layer Security (TLS) Multiple Certificate Status Request Extension\", RFC 6961, DOI 10.17487/RFC6961, June 2013, <http://www.rfc-editor.org/info/rfc6961>.",
      "ja": "[RFC6961] Pettersen、Y。、「The Transport Layer Security（TLS）Multiple Certificate Status Request Extension」、RFC 6961、DOI 10.17487 / RFC6961、2013年6月、<http://www.rfc-editor.org/info/rfc6961 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <http://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228] Bormann、C.、Ersue、M.、and A. Keranen、 \"Terminology for Constrained-Node Networks\"、RFC 7228、DOI 10.17487 / RFC7228、May 2014、<http://www.rfc-editor.org / info / rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252] Shelby、Z.、Hartke、K。、およびC. Bormann、「The Constrained Application Protocol（CoAP）」、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<http：//www.rfc-editor。 org / info / rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014, <http://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[RFC7258] Farrell、S。およびH. Tschofenig、「Pervasive Monitoring Is a Attack」、BCP 188、RFC 7258、DOI 10.17487 / RFC7258、2014年5月、<http://www.rfc-editor.org/info/rfc7258 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7366] Gutmann, P., \"Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", RFC 7366, DOI 10.17487/RFC7366, September 2014, <http://www.rfc-editor.org/info/rfc7366>.",
      "ja": "[RFC7366] Gutmann、P。、「トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）の暗号化後MAC」、RFC 7366、DOI 10.17487 / RFC7366、2014年9月、<http：//www.rfc -editor.org/info/rfc7366>。"
    },
    {
      "indent": 3,
      "text": "[RFC7390] Rahman, A., Ed. and E. Dijk, Ed., \"Group Communication for the Constrained Application Protocol (CoAP)\", RFC 7390, DOI 10.17487/RFC7390, October 2014, <http://www.rfc-editor.org/info/rfc7390>.",
      "ja": "[RFC7390]ラーマン、A。、エド。 E. Dijk編、「制約付きアプリケーションプロトコル（CoAP）のグループ通信」、RFC 7390、DOI 10.17487 / RFC7390、2014年10月、<http://www.rfc-editor.org/info/rfc7390>。"
    },
    {
      "indent": 3,
      "text": "[RFC7397] Gilger, J. and H. Tschofenig, \"Report from the Smart Object Security Workshop\", RFC 7397, DOI 10.17487/RFC7397, December 2014, <http://www.rfc-editor.org/info/rfc7397>.",
      "ja": "[RFC7397] Gilger、J。およびH. Tschofenig、「スマートオブジェクトセキュリティワークショップからのレポート」、RFC 7397、DOI 10.17487 / RFC7397、2014年12月、<http://www.rfc-editor.org/info/rfc7397> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7400] Bormann, C., \"6LoWPAN-GHC: Generic Header Compression for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs)\", RFC 7400, DOI 10.17487/RFC7400, November 2014, <http://www.rfc-editor.org/info/rfc7400>.",
      "ja": "[RFC7400] Bormann、C。、「6LoWPAN-GHC：Generic Header Compression over IPv6 over Low-Power Wireless Personal Area Networks（6LoWPANs）」、RFC 7400、DOI 10.17487 / RFC7400、2014年11月、<http：//www.rfc -editor.org/info/rfc7400>。"
    },
    {
      "indent": 3,
      "text": "[RFC7452] Tschofenig, H., Arkko, J., Thaler, D., and D. McPherson, \"Architectural Considerations in Smart Object Networking\", RFC 7452, DOI 10.17487/RFC7452, March 2015, <http://www.rfc-editor.org/info/rfc7452>.",
      "ja": "[RFC7452] Tschofenig、H.、Arkko、J.、Thaler、D。、およびD. McPherson、「Architectural Considerations in Smart Object Networking」、RFC 7452、DOI 10.17487 / RFC7452、2015年3月、<http：// www。 rfc-editor.org/info/rfc7452>。"
    },
    {
      "indent": 3,
      "text": "[RFC7465] Popov, A., \"Prohibiting RC4 Cipher Suites\", RFC 7465, DOI 10.17487/RFC7465, February 2015, <http://www.rfc-editor.org/info/rfc7465>.",
      "ja": "[RFC7465] Popov、A。、「Prohibiting RC4 Cipher Suites」、RFC 7465、DOI 10.17487 / RFC7465、2015年2月、<http://www.rfc-editor.org/info/rfc7465>。"
    },
    {
      "indent": 3,
      "text": "[RFC7507] Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks\", RFC 7507, DOI 10.17487/RFC7507, April 2015, <http://www.rfc-editor.org/info/rfc7507>.",
      "ja": "[RFC7507] Moeller、B。およびA. Langley、「プロトコルダウングレード攻撃を防止するためのTLSフォールバックシグナリング暗号スイート値（SCSV）」、RFC 7507、DOI 10.17487 / RFC7507、2015年4月、<http：//www.rfc-editor .org / info / rfc7507>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <http://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<http://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7539] Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF Protocols\", RFC 7539, DOI 10.17487/RFC7539, May 2015, <http://www.rfc-editor.org/info/rfc7539>.",
      "ja": "[RFC7539] Nir、Y。およびA. Langley、「IETFプロトコル用のChaCha20およびPoly1305」、RFC 7539、DOI 10.17487 / RFC7539、2015年5月、<http://www.rfc-editor.org/info/rfc7539>。"
    },
    {
      "indent": 3,
      "text": "[RFC7568] Barnes, R., Thomson, M., Pironti, A., and A. Langley, \"Deprecating Secure Sockets Layer Version 3.0\", RFC 7568, DOI 10.17487/RFC7568, June 2015, <http://www.rfc-editor.org/info/rfc7568>.",
      "ja": "[RFC7568] Barnes、R.、Thomson、M.、Pironti、A。、およびA. Langley、「Deprecating Secure Sockets Layer Version 3.0」、RFC 7568、DOI 10.17487 / RFC7568、2015年6月、<http：// www。 rfc-editor.org/info/rfc7568>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <http://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A。、ハンブルク、M。、およびS.ターナー、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<http://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 3,
      "text": "[SP800-107-rev1] National Institute of Standards and Technology, \"Recommendation for Applications Using Approved Hash Algorithms\", NIST Special Publication 800-107, Revision 1, DOI 10.6028/NIST.SP.800-107r1, August 2012, <http://csrc.nist.gov/publications/nistpubs/800-107-rev1/ sp800-107-rev1.pdf>.",
      "ja": "[SP800-107-rev1] National Institute of Standards and Technology、「Recommendation for Applications Using Approved Hash Algorithms」、NIST Special Publication 800-107、Revision 1、DOI 10.6028 / NIST.SP.800-107r1、2012年8月、<http ：//csrc.nist.gov/publications/nistpubs/800-107-rev1/sp800-107-rev1.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-22b] National Institute of Standards and Technology, \"A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications\", NIST Special Publication 800-22, Revision 1a, April 2010, <http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/ SP800-22rev1a.pdf>.",
      "ja": "[SP800-22b]米国国立標準技術研究所、「暗号化アプリケーション用のランダムおよび疑似乱数ジェネレータ用の統計的テストスイート」、NIST Special Publication 800-22、Revision 1a、2010年4月、<http：//csrc.nist。 gov / publications / nistpubs / 800-22-rev1a / SP800-22rev1a.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-90A] National Institute of Standards and Technology, \"Recommendation for Random Number Generation Using Deterministic Random Bit Generators\", NIST Special Publication 800-90A Revision 1, DOI 10.6028/NIST.SP.800-90Ar1, June 2015, <http://csrc.nist.gov/publications/drafts/800-90/ sp800-90a_r1_draft_november2014_ver.pdf>.",
      "ja": "[SP800-90A]米国国立標準技術研究所、「確定的ランダムビットジェネレーターを使用した乱数生成の推奨」、NIST Special Publication 800-90A Revision 1、DOI 10.6028 / NIST.SP.800-90Ar1、2015年6月、<http ：//csrc.nist.gov/publications/drafts/800-90/ sp800-90a_r1_draft_november2014_ver.pdf>。"
    },
    {
      "indent": 3,
      "text": "[TLS-FALSESTART] Langley, A., Modadugu, N., and B. Moeller, \"Transport Layer Security (TLS) False Start\", Work in Progress, draft-ietf-tls-falsestart-02, May 2016.",
      "ja": "[TLS-FALSESTART] Langley、A.、Modadugu、N。、およびB. Moeller、「Transport Layer Security（TLS）False Start」、Work in Progress、draft-ietf-tls-falsestart-02、May 2016。"
    },
    {
      "indent": 3,
      "text": "[Triple-HS] Bhargavan, K., Delignat-Lavaud, C., Pironti, A., and P. Yves Strub, \"Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS\", In Proceedings of the IEEE Symposium on Security and Privacy, Pages 98-113, DOI 10.1109/SP.2014.14, 2014.",
      "ja": "[Triple-HS] Bhargavan、K.、Delignat-Lavaud、C.、Pironti、A。、およびP. Yves Strub、「Triple Handshakes and Cookie Cutters：Breaking and Fixing Authentication over TLS over」、Proceedings of the IEEE Symposium onセキュリティとプライバシー、ページ98-113、DOI 10.1109 / SP.2014.14、2014。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Conveying DTLS over SMS",
      "section_title": true,
      "ja": "付録A. DTLS over SMSの伝達"
    },
    {
      "indent": 3,
      "text": "This section is normative for the use of DTLS over SMS. Timer recommendations are already outlined in Section 11 and also applicable to the transport of DTLS over SMS.",
      "ja": "このセクションは、DTLS over SMSの使用に関する規範です。タイマーの推奨事項はセクション11で既に概説されており、SMSを介したDTLSの転送にも適用できます。"
    },
    {
      "indent": 3,
      "text": "This section requires readers to be familiar with the terminology and concepts described in [GSM-SMS] and [WAP-WDP].",
      "ja": "このセクションでは、読者が[GSM-SMS]と[WAP-WDP]で説明されている用語と概念に精通している必要があります。"
    },
    {
      "indent": 3,
      "text": "The remainder of this section assumes Mobile Stations are capable of producing and consuming Transport Protocol Data Units (TPDUs) encoded as 8-bit binary data.",
      "ja": "このセクションの残りの部分では、モバイルステーションが8ビットバイナリデータとしてエンコードされたトランスポートプロトコルデータユニット（TPDU）を生成および消費できることを前提としています。"
    },
    {
      "indent": 0,
      "text": "A.1. Overview",
      "section_title": true,
      "ja": "A.1. 概観"
    },
    {
      "indent": 3,
      "text": "DTLS adds an additional round-trip to the TLS [RFC5246] handshake to serve as a return-routability test for protection against certain types of DoS attacks. Thus, a full-blown DTLS handshake comprises up to 6 \"flights\" (i.e., logical message exchanges), each of which is then mapped on to one or more DTLS records using the segmentation and reassembly (SaR) scheme described in Section 4.2.3 of [RFC6347]. The overhead for said scheme is 6 bytes per handshake message which, given a realistic 10+ messages handshake, would amount to around 60 bytes across the whole handshake sequence.",
      "ja": "DTLSは、TLS [RFC5246]ハンドシェイクに追加のラウンドトリップを追加して、特定のタイプのDoS攻撃に対する保護のためのリターンルーティング可能性テストとして機能します。したがって、本格的なDTLSハンドシェイクは最大6つの「フライト」（つまり、論理メッセージ交換）で構成され、それぞれがセクション4.2で説明されているセグメンテーションと再構成（SaR）スキームを使用して1つ以上のDTLSレコードにマッピングされます。 [RFC6347]の3。前記方式のオーバーヘッドは、ハンドシェイクメッセージごとに6バイトであり、現実的な10以上のメッセージハンドシェイクが与えられると、ハンドシェイクシーケンス全体で約60バイトになります。"
    },
    {
      "indent": 3,
      "text": "Note that the DTLS SaR scheme is defined for handshake messages only. In fact, DTLS records are never fragmented and MUST fit within a single transport layer datagram.",
      "ja": "DTLS SaRスキームは、ハンドシェイクメッセージに対してのみ定義されていることに注意してください。実際、DTLSレコードは断片化されることはなく、単一のトランスポート層データグラム内に収まる必要があります。"
    },
    {
      "indent": 3,
      "text": "SMS provides an optional segmentation and reassembly scheme as well, known as Concatenated short messages (see Section 9.2.3.24.1 of [GSM-SMS]). However, since the SaR scheme in DTLS cannot be circumvented, the Concatenated short messages mechanism SHOULD NOT be used during handshake to avoid redundant overhead. Before starting the handshake phase (either actively or passively), the DTLS implementation MUST be explicitly configured with the Path MTU (PMTU) of the SMS transport in order to correctly instrument its SaR function. The PMTU SHALL be 133 bytes if multiplexing based on the Wireless Datagram Protocol (WDP) is used (see Appendix A.3); 140 bytes otherwise.",
      "ja": "SMSは、オプションのセグメンテーションおよび再構成スキームも提供します。これは、連結ショートメッセージと呼ばれます（[GSM-SMS]のセクション9.2.3.24.1を参照）。ただし、DTLSのSaRスキームは回避できないため、冗長なオーバーヘッドを回避するために、ハンドシェイク中に連結ショートメッセージメカニズムを使用しないでください。 SaR機能を正しく計測するために、ハンドシェイクフェーズを（アクティブまたはパッシブに）開始する前に、SMSトランスポートのパスMTU（PMTU）でDTLS実装を明示的に構成する必要があります。ワイヤレスデータグラムプロトコル（WDP）に基づく多重化を使用する場合、PMTUは133バイトにする必要があります（付録A.3を参照）。それ以外の場合は140バイト。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the established security context over the longest possible period be used (possibly until a Closure Alert message is received or after a very long inactivity timeout) to avoid the expensive re-establishment of the security association.",
      "ja": "セキュリティアソシエーションのコストのかかる再確立を回避するために、可能な限り長い期間にわたって確立されたセキュリティコンテキストを使用することをお勧めします（おそらくクロージャアラートメッセージが受信されるまで、または非常に長い非アクティブタイムアウトの後）。"
    },
    {
      "indent": 0,
      "text": "A.2. Message Segmentation and Reassembly",
      "section_title": true,
      "ja": "A.2. メッセージのセグメンテーションと再組み立て"
    },
    {
      "indent": 3,
      "text": "The content of an SMS message is carried in the TP-UserData field, and its size may be up to 140 bytes. As already mentioned in Appendix A.1, longer (i.e., up to 34170 bytes) messages can be sent using Concatenated SMS.",
      "ja": "SMSメッセージのコンテンツはTP-UserDataフィールドで伝達され、そのサイズは最大140バイトです。付録A.1で既に述べたように、より長い（つまり、34170バイトまで）メッセージは、連結SMSを使用して送信できます。"
    },
    {
      "indent": 3,
      "text": "This scheme consumes 6-7 bytes (depending on whether the short or long segmentation format is used) of the TP-UserData field, thus reducing the space available for the actual content of the SMS message to 133-134 bytes per TPDU.",
      "ja": "このスキームは、TP-UserDataフィールドの6〜7バイト（短いまたは長いセグメンテーションフォーマットのどちらを使用するかに応じて）を消費するため、SMSメッセージの実際のコンテンツに使用可能なスペースがTPDUあたり133〜134バイトに減少します。"
    },
    {
      "indent": 3,
      "text": "Though in principle a PMTU value higher than 140 bytes could be used, which may look like an appealing option given its more efficient use of the transport, there are disadvantages to consider. First, there is an additional overhead of 7 bytes per TPDU to be paid to the SaR function (which is in addition to the overhead introduced by the DTLS SaR mechanism. Second, some networks only partially support the Concatenated SMS function, and others do not support it at all.",
      "ja": "原則として、140バイトを超えるPMTU値を使用できますが、トランスポートをより効率的に使用できるため、魅力的なオプションのように見えるかもしれませんが、考慮すべき欠点があります。 1つ目は、SaR機能に支払われるTPDUあたり7バイトの追加オーバーヘッドです（これは、DTLS SaRメカニズムによって導入されるオーバーヘッドに加えてです。2つ目は、一部のネットワークは連結SMS機能を部分的にしかサポートしておらず、他のネットワークはサポートしていません。それをサポートします。"
    },
    {
      "indent": 3,
      "text": "For these reasons, the Concatenated short messages mechanism SHOULD NOT be used, and it is RECOMMENDED to leave the same PMTU settings used during the handshake phase, i.e., 133 bytes if WDP-based multiplexing is enabled; 140 bytes otherwise.",
      "ja": "これらの理由により、連結ショートメッセージメカニズムは使用すべきではなく（SHOULD NOT）、ハンドシェイクフェーズ中に使用されたものと同じPMTU設定（つまり、WDPベースの多重化が有効な場合は133バイト）を残すことをお勧めします。それ以外の場合は140バイト。"
    },
    {
      "indent": 3,
      "text": "Note that, after the DTLS handshake has completed, any fragmentation and reassembly logic that pertains the application layer (e.g., segmenting CoAP messages into DTLS records and reassembling them after the crypto operations have been successfully performed) needs to be handled by the application that uses the established DTLS tunnel.",
      "ja": "DTLSハンドシェイクが完了した後、アプリケーション層に関連する断片化と再構成のロジック（たとえば、CoAPメッセージをDTLSレコードにセグメント化し、暗号化操作が正常に実行された後にそれらを再構成すること）を使用するアプリケーションで処理する必要があることに注意してください確立されたDTLSトンネル。"
    },
    {
      "indent": 0,
      "text": "A.3. Multiplexing Security Associations",
      "section_title": true,
      "ja": "A.3. セキュリティアソシエーションの多重化"
    },
    {
      "indent": 3,
      "text": "Unlike IPsec Encapsulating Security Payload (ESP) / Authentication Header (AH), DTLS records do not contain any association identifiers. Applications must arrange to multiplex between associations on the same endpoint which, when using UDP/IP, is usually done with the host/port number.",
      "ja": "IPsecカプセル化セキュリティペイロード（ESP）/認証ヘッダー（AH）とは異なり、DTLSレコードには関連付け識別子が含まれていません。アプリケーションは、同じエンドポイント上のアソシエーション間で多重化するように調整する必要があります。UDP/ IPを使用する場合、通常はホスト/ポート番号を使用して行われます。"
    },
    {
      "indent": 0,
      "text": " If the DTLS server allows more than one client to be active at any given time, then the Wireless Application Protocol (WAP) User Datagram Protocol [WAP-WDP] can be used to achieve multiplexing of the different security associations. (The use of WDP provides the additional benefit that upper-layer protocols can operate independently of the underlying wireless network, hence achieving application-agnostic transport handover.) The total overhead cost for encoding the WDP source and destination ports is either 5 or 7 bytes out of the total available for the SMS content depending on if 1-byte or 2-byte port identifiers are used, as shown in Figures 13 and 14.",
      "ja": "DTLSサーバーが同時に複数のクライアントをアクティブにすることを許可している場合、ワイヤレスアプリケーションプロトコル（WAP）ユーザーデータグラムプロトコル[WAP-WDP]を使用して、さまざまなセキュリティアソシエーションの多重化を実現できます。 （WDPを使用すると、上位層のプロトコルが基盤のワイヤレスネットワークとは独立して動作できるため、アプリケーションに依存しないトランスポートハンドオーバーを実現できるという追加の利点があります。）WDPの送信元ポートと宛先ポートをエンコードするための総オーバーヘッドコストは、5または7バイトです。図13および14に示すように、1バイトまたは2バイトのポート識別子が使用されているかどうかに応じて、SMSコンテンツで利用可能な合計のうち。"
    },
    {
      "indent": 3,
      "text": "0        1        2        3        4\n+--------+--------+--------+--------+--------+\n| ...    | 0x04   | 2      | ...    | ...    |\n+--------+--------+--------+--------+--------+\n  UDH      IEI      IE       Dest     Source\n  Length            Length   Port     Port",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Legend: UDH = user data header IEI = information element identifier",
      "ja": "凡例：UDH =ユーザーデータヘッダーIEI =情報要素識別子"
    },
    {
      "indent": 7,
      "text": "Figure 13: Application Port Addressing Scheme (8-Bit Address)",
      "ja": "図13：アプリケーションポートアドレス指定方式（8ビットアドレス）"
    },
    {
      "indent": 3,
      "text": "0        1        2        3        4        5        6\n+--------+--------+--------+--------+--------+--------+--------+\n| ...    | 0x05   | 4      |       ...       |       ...       |\n+--------+--------+--------+--------+--------+--------+--------+\n  UDH      IEI      IE       Dest              Source\n  Length            Length   Port              Port",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 14: Application Port Addressing Scheme (16-Bit Address)",
      "ja": "図14：アプリケーションポートアドレス指定スキーム（16ビットアドレス）"
    },
    {
      "indent": 3,
      "text": "The receiving side of the communication gets the source address from the originator address (TP-OA) field of the SMS-DELIVER TPDU. This way, a unique 4-tuple identifying the security association can be reconstructed at both ends. (When replying to its DTLS peer, the sender will swap the TP-OA and destination address (TP-DA) parameters and the source and destination ports in the WDP.)",
      "ja": "通信の受信側は、SMS-DELIVER TPDUの発信元アドレス（TP-OA）フィールドからソースアドレスを取得します。このようにして、セキュリティアソシエーションを識別する一意の4タプルを両端で再構築できます。 （DTLSピアに返信するとき、送信者はTP-OAと宛先アドレス（TP-DA）パラメーター、およびWDPの送信元ポートと宛先ポートを交換します。）"
    },
    {
      "indent": 0,
      "text": "A.4. Timeout",
      "section_title": true,
      "ja": "A.4. タイムアウト"
    },
    {
      "indent": 3,
      "text": "If SMS-STATUS-REPORT messages are enabled, their receipt is not to be interpreted as the signal that the specific handshake message has been acted upon by the receiving party. Therefore, it MUST NOT be taken into account by the DTLS timeout and retransmission function.",
      "ja": "SMS-STATUS-REPORTメッセージが有効になっている場合、その受信は、特定のハンドシェイクメッセージが受信側によって処理されたことを示す信号として解釈されません。したがって、それはDTLSタイムアウトと再送信機能によって考慮されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Handshake messages MUST carry a validity period (TP-VP parameter in a SMS-SUBMIT TPDU) that is not less than the current value of the retransmission timeout. In order to avoid persisting messages in the network that will be discarded by the receiving party, handshake messages SHOULD carry a validity period that is the same as, or just slightly higher than, the current value of the retransmission timeout.",
      "ja": "ハンドシェイクメッセージは、再送信タイムアウトの現在の値以上の有効期間（SMS-SUBMIT TPDUのTP-VPパラメータ）を伝える必要があります。受信側によって破棄されるネットワーク内のメッセージの永続化を回避するために、ハンドシェイクメッセージは、再送信タイムアウトの現在の値と同じか、それよりわずかに高い有効期間を伝える必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "Appendix B. DTLS Record Layer Per-Packet Overhead",
      "section_title": true,
      "ja": "付録B. DTLSレコードレイヤーのパケットごとのオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "Figure 15 shows the overhead for the DTLS record layer for protecting data traffic when AES-128-CCM with an 8-octet Integrity Check Value (ICV) is used.",
      "ja": "図15は、8オクテットの整合性チェック値（ICV）を備えたAES-128-CCMが使用されている場合に、データトラフィックを保護するためのDTLSレコードレイヤーのオーバーヘッドを示しています。"
    },
    {
      "indent": 3,
      "text": "DTLS Record Layer Header................13 bytes\nNonce (Explicit).........................8 bytes\nICV..................................... 8 bytes\n------------------------------------------------\nOverhead................................29 bytes\n------------------------------------------------",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 15: AES-128-CCM-8 DTLS Record Layer Per-Packet Overhead",
      "ja": "図15：AES-128-CCM-8 DTLSレコードレイヤーのパケットごとのオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "The DTLS record layer header has 13 octets and consists of:",
      "ja": "DTLSレコードレイヤーヘッダーは13オクテットで、次のもので構成されています。"
    },
    {
      "indent": 3,
      "text": "o 1-octet content type field,",
      "ja": "o 1オクテットのコンテンツタイプフィールド"
    },
    {
      "indent": 3,
      "text": "o 2-octet version field,",
      "ja": "o 2オクテットバージョンフィールド"
    },
    {
      "indent": 3,
      "text": "o 2-octet epoch field,",
      "ja": "o 2オクテットエポックフィールド、"
    },
    {
      "indent": 3,
      "text": "o 6-octet sequence number, and",
      "ja": "o 6オクテットのシーケンス番号、および"
    },
    {
      "indent": 3,
      "text": "o 2-octet length field.",
      "ja": "o 2オクテットの長さフィールド。"
    },
    {
      "indent": 3,
      "text": "The \"nonce\" input to the AEAD algorithm is exactly that of [RFC5288], i.e., 12 bytes long. It consists of two values, namely a 4-octet salt and an 8-octet nonce_explicit:",
      "ja": "AEADアルゴリズムへの「ノンス」入力は、[RFC5288]とまったく同じ、つまり12バイトの長さです。これは、2つの値、つまり4オクテットのソルトと8オクテットのnonce_explicitで構成されています。"
    },
    {
      "indent": 6,
      "text": "The salt is the \"implicit\" part and is not sent in the packet. Instead, the salt is generated as part of the handshake process.",
      "ja": "ソルトは「暗黙の」部分であり、パケットで送信されません。代わりに、塩はハンドシェイクプロセスの一部として生成されます。"
    },
    {
      "indent": 6,
      "text": "The nonce_explicit value is 8 octets long and it is chosen by the sender and carried in each TLS record. RFC 6655 [RFC6655] allows the nonce_explicit to be a sequence number or something else. This document makes this use more restrictive for use with DTLS: the 64-bit none_explicit value MUST be the 16-bit epoch concatenated with the 48-bit seq_num. The sequence number component of the nonce_explicit field at the AES-CCM layer is an exact copy of the sequence number in the record layer header field. This leads to a duplication of 8-bytes per record.",
      "ja": "nonce_explicit値は8オクテット長で、送信者によって選択され、各TLSレコードで伝達されます。 RFC 6655 [RFC6655]では、nonce_explicitをシーケンス番号またはその他の何かにすることができます。このドキュメントでは、この使用をDTLSでの使用に対してより制限的にしています。64ビットのnone_explicit値は、48ビットのseq_numと連結された16ビットのエポックである必要があります。 AES-CCMレイヤーのnonce_explicitフィールドのシーケンス番号コンポーネントは、レコードレイヤーヘッダーフィールドのシーケンス番号の正確なコピーです。これにより、レコードごとに8バイトの重複が発生します。"
    },
    {
      "indent": 0,
      "text": " To avoid this 8-byte duplication, RFC 7400 [RFC7400] provides help with the use of the generic header compression technique for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs). Note that this header compression technique is not available when DTLS is exchanged over transports that do not use IPv6 or 6LoWPAN, such as the SMS transport described in Appendix A of this document.",
      "ja": "この8バイトの重複を避けるために、RFC 7400 [RFC7400]は、IPv6 over Low-Power Wireless Personal Area Networks（6LoWPANs）の一般的なヘッダー圧縮技術の使用を支援します。このヘッダー圧縮技術は、このドキュメントの付録Aで説明されているSMSトランスポートなど、IPv6または6LoWPANを使用しないトランスポートを介してDTLSが交換される場合は使用できないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "Appendix C. DTLS Fragmentation",
      "section_title": true,
      "ja": "付録C. DTLSフラグメンテーション"
    },
    {
      "indent": 3,
      "text": "Section 4.2.3 of [RFC6347] advises DTLS implementations to not produce overlapping fragments. However, it requires receivers to be able to cope with them. The need for the latter requisite is explained in Section 4.1.1.1 of [RFC6347]: accurate PMTU estimation may be traded for shorter handshake completion time.",
      "ja": "[RFC6347]のセクション4.2.3は、DTLS実装が重複フラグメントを生成しないようにアドバイスしています。ただし、受信者がそれらに対処できる必要があります。後者の要件の必要性は、[RFC6347]のセクション4.1.1.1で説明されています。正確なPMTU推定は、ハンドシェイク完了時間の短縮と引き換えに使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "In many cases, the cost of handling fragment overlaps has proved to be unaffordable for constrained implementations, particularly because of the increased complexity in buffer management.",
      "ja": "多くの場合、特にバッファ管理の複雑さが増しているため、フラグメントのオーバーラップを処理するコストは、制約のある実装では手頃な価格ではないことが判明しています。"
    },
    {
      "indent": 3,
      "text": "In order to reduce the likelihood of producing different fragment sizes and consequent overlaps within the same handshake, this document RECOMMENDs:",
      "ja": "同じハンドシェイク内で異なるフラグメントサイズとその結果として生じるオーバーラップを生成する可能性を減らすために、このドキュメントでは次のことを推奨しています。"
    },
    {
      "indent": 3,
      "text": "o clients (handshake initiators) to use reliable PMTU information for the intended destination; and",
      "ja": "o クライアント（ハンドシェイクイニシエーター）は、目的の宛先に信頼できるPMTU情報を使用します。そして"
    },
    {
      "indent": 3,
      "text": "o servers to mirror the fragment size selected by their clients.",
      "ja": "o クライアントが選択したフラグメントサイズをミラーリングするサーバー。"
    },
    {
      "indent": 3,
      "text": "The PMTU information comes from either a \"fresh enough\" discovery performed by the client [RFC1981] [RFC4821] or some other reliable out-of-band channel.",
      "ja": "PMTU情報は、クライアント[RFC1981] [RFC4821]または他の信頼できる帯域外チャネルによって実行された「十分に新鮮な」発見から得られます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Derek Atkins, Paul Bakker, Olaf Bergmann, Carsten Bormann, Ben Campbell, Brian Carpenter, Robert Cragie, Spencer Dawkins, Russ Housley, Rene Hummen, Jayaraghavendran K, Sye Loong Keoh, Matthias Kovatsch, Sandeep Kumar, Barry Leiba, Simon Lemay, Alexey Melnikov, Gabriel Montenegro, Manuel Pegourie-Gonnard, Akbar Rahman, Eric Rescorla, Michael Richardson, Ludwig Seitz, Zach Shelby, Michael StJohns, Rene Struik, Tina Tsou, and Sean Turner for their helpful comments and discussions that have shaped the document.",
      "ja": "Derek Atkins、Paul Bakker、Olaf Bergmann、Carsten Bormann、Ben Campbell、Brian Carpenter、Robert Cragie、Spencer Dawkins、Russ Housley、Rene Hummen、Jayaraghavendran K、Sye Loong Keoh、Matthias Kovatsch、Sandeep Kumar、Barry Lemaya、Simon 、アレクセイメルニコフ、ガブリエルモンテネグロ、マヌエルペゴリーゴナード、アクバルラーマン、エリックレスコーラ、マイケルリチャードソン、ルートヴィヒセイツ、ザックシェルビー、マイケルセントジョーク、ルネストゥルーク、ティナツウウ、およびショーンターナー。"
    },
    {
      "indent": 3,
      "text": "A big thanks also to Klaus Hartke, who wrote the initial draft version of this document.",
      "ja": "また、このドキュメントの最初のドラフトバージョンを作成したKlaus Hartkeにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Finally, we would like to thank our area director (Stephen Farrell) and our working group chairs (Zach Shelby and Dorothy Gellert) for their support.",
      "ja": "最後に、エリアディレクター（Stephen Farrell）とワーキンググループチェア（Zach ShelbyとDorothy Gellert）のサポートに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig (editor) ARM Ltd. 110 Fulbourn Rd Cambridge CB1 9NJ United Kingdom",
      "ja": "Hannes Tschofenig（editor）ARM Ltd.110 Fulbourn Rd Cambridge CB1 9NJ United Kingdom"
    },
    {
      "indent": 3,
      "text": "Email: Hannes.tschofenig@gmx.net\nURI:   http://www.tschofenig.priv.at",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Thomas Fossati Nokia 3 Ely Road Milton, Cambridge CB24 6DD United Kingdom",
      "ja": "Thomas Fossati Nokia 3 Ely Roadミルトン、ケンブリッジCB24 6DDイギリス"
    },
    {
      "indent": 3,
      "text": "Email: thomas.fossati@nokia.com",
      "raw": true,
      "ja": ""
    }
  ]
}