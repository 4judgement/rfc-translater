{
  "title": {
    "text": "RFC 7950 - The YANG 1.1 Data Modeling Language",
    "ja": "RFC 7950 - YANG 1.1データモデリング言語"
  },
  "number": 7950,
  "created_at": "2020-08-21 21:58:43.190143+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.\nRequest for Comments: 7950                                Tail-f Systems\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "The YANG 1.1 Data Modeling Language",
      "ja": "YANG 1.1データモデリング言語"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols. This document describes the syntax and semantics of version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification. There are a small number of backward incompatibilities from YANG version 1. This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).",
      "ja": "YANGは、ネットワーク管理プロトコルの構成データ、状態データ、リモートプロシージャコール、および通知をモデル化するために使用されるデータモデリング言語です。このドキュメントでは、YANG言語のバージョン1.1の構文とセマンティクスについて説明します。 YANGバージョン1.1は、YANG言語のメンテナンスリリースであり、元の仕様のあいまいさと欠陥に対処しています。 YANGバージョン1からの下位互換性の問題はいくつかあります。このドキュメントでは、ネットワーク構成プロトコル（NETCONF）へのYANGマッピングも指定しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7950.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7950で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれている場合があります。 IETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得しない限り、このドキュメントはIETF標準プロセス外で変更できません。また、その派生物は、IETF標準プロセス外で作成できません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................9\n   1.1. Summary of Changes from RFC 6020 ..........................10\n2. Key Words ......................................................12\n3. Terminology ....................................................12\n   3.1. A Note on Examples ........................................16\n4. YANG Overview ..................................................16\n   4.1. Functional Overview .......................................16\n   4.2. Language Overview .........................................18\n        4.2.1. Modules and Submodules .............................18\n        4.2.2. Data Modeling Basics ...............................19\n        4.2.3. Configuration and State Data .......................23\n        4.2.4. Built-In Types .....................................24\n        4.2.5. Derived Types (typedef) ............................25\n        4.2.6. Reusable Node Groups (grouping) ....................25\n        4.2.7. Choices ............................................27\n        4.2.8. Extending Data Models (augment) ....................28\n        4.2.9. Operation Definitions ..............................29\n        4.2.10. Notification Definitions ..........................31\n5. Language Concepts ..............................................32\n   5.1. Modules and Submodules ....................................32\n        5.1.1. Import and Include by Revision .....................33\n        5.1.2. Module Hierarchies .................................34\n   5.2. File Layout ...............................................36\n   5.3. XML Namespaces ............................................36\n        5.3.1. YANG XML Namespace .................................36\n   5.4. Resolving Grouping, Type, and Identity Names ..............37\n   5.5. Nested Typedefs and Groupings .............................37\n   5.6. Conformance ...............................................38\n        5.6.1. Basic Behavior .....................................38\n        5.6.2. Optional Features ..................................38\n        5.6.3. Deviations .........................................39\n        5.6.4. Announcing Conformance Information in NETCONF ......40\n        5.6.5. Implementing a Module ..............................40\n   5.7. Datastore Modification ....................................44\n6. YANG Syntax ....................................................44\n   6.1. Lexical Tokenization ......................................45\n        6.1.1. Comments ...........................................45\n        6.1.2. Tokens .............................................45\n        6.1.3. Quoting ............................................45\n   6.2. Identifiers ...............................................47\n        6.2.1. Identifiers and Their Namespaces ...................47\n   6.3. Statements ................................................48\n        6.3.1. Language Extensions ................................48\n   6.4. XPath Evaluations .........................................49\n        6.4.1. XPath Context ......................................50\n   6.5. Schema Node Identifier ....................................54",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "7. YANG Statements ................................................55\n   7.1. The \"module\" Statement ....................................55\n        7.1.1. The module's Substatements .........................56\n        7.1.2. The \"yang-version\" Statement .......................57\n        7.1.3. The \"namespace\" Statement ..........................57\n        7.1.4. The \"prefix\" Statement .............................57\n        7.1.5. The \"import\" Statement .............................58\n        7.1.6. The \"include\" Statement ............................59\n        7.1.7. The \"organization\" Statement .......................60\n        7.1.8. The \"contact\" Statement ............................60\n        7.1.9. The \"revision\" Statement ...........................60\n        7.1.10. Usage Example .....................................61\n   7.2. The \"submodule\" Statement .................................62\n        7.2.1. The submodule's Substatements ......................63\n        7.2.2. The \"belongs-to\" Statement .........................63\n        7.2.3. Usage Example ......................................64\n   7.3. The \"typedef\" Statement ...................................65\n        7.3.1. The typedef's Substatements ........................65\n        7.3.2. The typedef's \"type\" Statement .....................65\n        7.3.3. The \"units\" Statement ..............................65\n        7.3.4. The typedef's \"default\" Statement ..................66\n        7.3.5. Usage Example ......................................66\n   7.4. The \"type\" Statement ......................................66\n        7.4.1. The type's Substatements ...........................67\n   7.5. The \"container\" Statement .................................67\n        7.5.1. Containers with Presence ...........................67\n        7.5.2. The container's Substatements ......................68\n        7.5.3. The \"must\" Statement ...............................69\n        7.5.4. The must's Substatements ...........................70\n        7.5.5. The \"presence\" Statement ...........................71\n        7.5.6. The container's Child Node Statements ..............71\n        7.5.7. XML Encoding Rules .................................71\n        7.5.8. NETCONF <edit-config> Operations ...................72\n        7.5.9. Usage Example ......................................72\n   7.6. The \"leaf\" Statement ......................................73\n        7.6.1. The leaf's Default Value ...........................74\n        7.6.2. The leaf's Substatements ...........................75\n        7.6.3. The leaf's \"type\" Statement ........................75\n        7.6.4. The leaf's \"default\" Statement .....................75\n        7.6.5. The leaf's \"mandatory\" Statement ...................76\n        7.6.6. XML Encoding Rules .................................76\n        7.6.7. NETCONF <edit-config> Operations ...................76\n        7.6.8. Usage Example ......................................77\n   7.7. The \"leaf-list\" Statement .................................77\n        7.7.1. Ordering ...........................................78\n        7.7.2. The leaf-list's Default Values .....................79\n        7.7.3. The leaf-list's Substatements ......................80\n        7.7.4. The leaf-list's \"default\" Statement ................80",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "     7.7.5. The \"min-elements\" Statement .......................80\n     7.7.6. The \"max-elements\" Statement .......................81\n     7.7.7. The \"ordered-by\" Statement .........................81\n     7.7.8. XML Encoding Rules .................................82\n     7.7.9. NETCONF <edit-config> Operations ...................82\n     7.7.10. Usage Example .....................................83\n7.8. The \"list\" Statement ......................................84\n     7.8.1. The list's Substatements ...........................85\n     7.8.2. The list's \"key\" Statement .........................85\n     7.8.3. The list's \"unique\" Statement ......................86\n     7.8.4. The list's Child Node Statements ...................87\n     7.8.5. XML Encoding Rules .................................88\n     7.8.6. NETCONF <edit-config> Operations ...................88\n     7.8.7. Usage Example ......................................90\n7.9. The \"choice\" Statement ....................................93\n     7.9.1. The choice's Substatements .........................94\n     7.9.2. The choice's \"case\" Statement ......................94\n     7.9.3. The choice's \"default\" Statement ...................96\n     7.9.4. The choice's \"mandatory\" Statement .................98\n     7.9.5. XML Encoding Rules .................................98\n     7.9.6. Usage Example ......................................99\n7.10. The \"anydata\" Statement .................................100\n     7.10.1. The anydata's Substatements ......................100\n     7.10.2. XML Encoding Rules ...............................101\n     7.10.3. NETCONF <edit-config> Operations .................101\n     7.10.4. Usage Example ....................................101\n7.11. The \"anyxml\" Statement ..................................102\n     7.11.1. The anyxml's Substatements .......................103\n     7.11.2. XML Encoding Rules ...............................103\n     7.11.3. NETCONF <edit-config> Operations .................103\n     7.11.4. Usage Example ....................................104\n7.12. The \"grouping\" Statement ................................104\n     7.12.1. The grouping's Substatements .....................105\n     7.12.2. Usage Example ....................................105\n7.13. The \"uses\" Statement ....................................106\n     7.13.1. The uses's Substatements .........................106\n     7.13.2. The \"refine\" Statement ...........................106\n     7.13.3. XML Encoding Rules ...............................107\n     7.13.4. Usage Example ....................................107\n7.14. The \"rpc\" Statement .....................................108\n     7.14.1. The rpc's Substatements ..........................109\n     7.14.2. The \"input\" Statement ............................109\n     7.14.3. The \"output\" Statement ...........................110\n     7.14.4. NETCONF XML Encoding Rules .......................111\n     7.14.5. Usage Example ....................................112",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   7.15. The \"action\" Statement ..................................113\n        7.15.1. The action's Substatements .......................114\n        7.15.2. NETCONF XML Encoding Rules .......................114\n        7.15.3. Usage Example ....................................115\n   7.16. The \"notification\" Statement ............................116\n        7.16.1. The notification's Substatements .................117\n        7.16.2. NETCONF XML Encoding Rules .......................117\n        7.16.3. Usage Example ....................................118\n   7.17. The \"augment\" Statement .................................119\n        7.17.1. The augment's Substatements ......................121\n        7.17.2. XML Encoding Rules ...............................121\n        7.17.3. Usage Example ....................................122\n   7.18. The \"identity\" Statement ................................124\n        7.18.1. The identity's Substatements .....................124\n        7.18.2. The \"base\" Statement .............................124\n        7.18.3. Usage Example ....................................125\n   7.19. The \"extension\" Statement ...............................126\n        7.19.1. The extension's Substatements ....................126\n        7.19.2. The \"argument\" Statement .........................127\n        7.19.3. Usage Example ....................................127\n   7.20. Conformance-Related Statements ..........................128\n        7.20.1. The \"feature\" Statement ..........................128\n        7.20.2. The \"if-feature\" Statement .......................130\n        7.20.3. The \"deviation\" Statement ........................131\n   7.21. Common Statements .......................................134\n        7.21.1. The \"config\" Statement ...........................134\n        7.21.2. The \"status\" Statement ...........................135\n        7.21.3. The \"description\" Statement ......................136\n        7.21.4. The \"reference\" Statement ........................136\n        7.21.5. The \"when\" Statement .............................136\n8. Constraints ...................................................138\n   8.1. Constraints on Data ......................................138\n   8.2. Configuration Data Modifications .........................139\n   8.3. NETCONF Constraint Enforcement Model .....................139\n        8.3.1. Payload Parsing ...................................139\n        8.3.2. NETCONF <edit-config> Processing ..................140\n        8.3.3. Validation ........................................141\n9. Built-In Types ................................................141\n   9.1. Canonical Representation .................................141\n   9.2. The Integer Built-In Types ...............................142\n        9.2.1. Lexical Representation ............................142\n        9.2.2. Canonical Form ....................................143\n        9.2.3. Restrictions ......................................143\n        9.2.4. The \"range\" Statement .............................143\n        9.2.5. Usage Example .....................................144",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "9.3. The decimal64 Built-In Type ..............................144\n     9.3.1. Lexical Representation ............................145\n     9.3.2. Canonical Form ....................................145\n     9.3.3. Restrictions ......................................145\n     9.3.4. The \"fraction-digits\" Statement ...................145\n     9.3.5. Usage Example .....................................146\n9.4. The string Built-In Type .................................146\n     9.4.1. Lexical Representation ............................146\n     9.4.2. Canonical Form ....................................147\n     9.4.3. Restrictions ......................................147\n     9.4.4. The \"length\" Statement ............................147\n     9.4.5. The \"pattern\" Statement ...........................148\n     9.4.6. The \"modifier\" Statement ..........................148\n     9.4.7. Usage Example .....................................149\n9.5. The boolean Built-In Type ................................150\n     9.5.1. Lexical Representation ............................150\n     9.5.2. Canonical Form ....................................150\n     9.5.3. Restrictions ......................................150\n9.6. The enumeration Built-In Type ............................150\n     9.6.1. Lexical Representation ............................150\n     9.6.2. Canonical Form ....................................151\n     9.6.3. Restrictions ......................................151\n     9.6.4. The \"enum\" Statement ..............................151\n     9.6.5. Usage Example .....................................152\n9.7. The bits Built-In Type ...................................154\n     9.7.1. Restrictions ......................................154\n     9.7.2. Lexical Representation ............................154\n     9.7.3. Canonical Form ....................................154\n     9.7.4. The \"bit\" Statement ...............................155\n     9.7.5. Usage Example .....................................156\n9.8. The binary Built-In Type .................................157\n     9.8.1. Restrictions ......................................157\n     9.8.2. Lexical Representation ............................157\n     9.8.3. Canonical Form ....................................157\n9.9. The leafref Built-In Type ................................157\n     9.9.1. Restrictions ......................................158\n     9.9.2. The \"path\" Statement ..............................158\n     9.9.3. The \"require-instance\" Statement ..................159\n     9.9.4. Lexical Representation ............................159\n     9.9.5. Canonical Form ....................................159\n     9.9.6. Usage Example .....................................159\n9.10. The identityref Built-In Type ...........................163\n     9.10.1. Restrictions .....................................163\n     9.10.2. The identityref's \"base\" Statement ...............163\n     9.10.3. Lexical Representation ...........................163\n     9.10.4. Canonical Form ...................................164\n     9.10.5. Usage Example ....................................164",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   9.11. The empty Built-In Type .................................165\n        9.11.1. Restrictions .....................................165\n        9.11.2. Lexical Representation ...........................165\n        9.11.3. Canonical Form ...................................165\n        9.11.4. Usage Example ....................................166\n   9.12. The union Built-In Type .................................166\n        9.12.1. Restrictions .....................................166\n        9.12.2. Lexical Representation ...........................166\n        9.12.3. Canonical Form ...................................167\n        9.12.4. Usage Example ....................................167\n   9.13. The instance-identifier Built-In Type ...................168\n        9.13.1. Restrictions .....................................168\n        9.13.2. Lexical Representation ...........................169\n        9.13.3. Canonical Form ...................................169\n        9.13.4. Usage Example ....................................169\n10. XPath Functions ..............................................170\n   10.1. Function for Node Sets ..................................170\n        10.1.1. current() ........................................170\n   10.2. Function for Strings ....................................170\n        10.2.1. re-match() .......................................170\n   10.3. Function for the YANG Types \"leafref\" and\n         \"instance-identifier\" ...................................171\n        10.3.1. deref() ..........................................171\n   10.4. Functions for the YANG Type \"identityref\" ...............172\n        10.4.1. derived-from() ...................................172\n        10.4.2. derived-from-or-self() ...........................174\n   10.5. Function for the YANG Type \"enumeration\" ................174\n        10.5.1. enum-value() .....................................174\n   10.6. Function for the YANG Type \"bits\" .......................175\n        10.6.1. bit-is-set() .....................................175\n11. Updating a Module ............................................176\n12. Coexistence with YANG Version 1 ..............................179\n13. YIN ..........................................................179\n   13.1. Formal YIN Definition ...................................180\n        13.1.1. Usage Example ....................................182\n14. YANG ABNF Grammar ............................................184\n15. NETCONF Error Responses for YANG-Related Errors ..............211\n   15.1. Error Message for Data That Violates a \"unique\"\n         Statement ...............................................211\n   15.2. Error Message for Data That Violates a\n         \"max-elements\" Statement ................................211\n   15.3. Error Message for Data That Violates a\n         \"min-elements\" Statement ................................211\n   15.4. Error Message for Data That Violates a \"must\"\n         Statement ...............................................212\n   15.5. Error Message for Data That Violates a\n         \"require-instance\" Statement ............................212",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   15.6. Error Message for Data That Violates a Mandatory\n         \"choice\" Statement ......................................212\n   15.7. Error Message for the \"insert\" Operation ................212\n16. IANA Considerations ..........................................213\n17. Security Considerations ......................................213\n18. References ...................................................214\n   18.1. Normative References ....................................214\n   18.2. Informative References ..................................215\nAcknowledgements .................................................217\nContributors .....................................................217\nAuthor's Address .................................................217",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language originally designed to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF notifications [RFC6241]. Since the publication of YANG version 1 [RFC6020], YANG has been used or proposed to be used for other protocols (e.g., RESTCONF [RESTCONF] and the Constrained Application Protocol (CoAP) Management Interface (CoMI) [CoMI]). Further, encodings other than XML have been proposed (e.g., JSON [RFC7951]).",
      "ja": "YANGは、もともとネットワーク構成プロトコル（NETCONF）、NETCONFリモートプロシージャコール、およびNETCONF通知[RFC6241]によって操作される構成および状態データをモデル化するために設計されたデータモデリング言語です。 YANGバージョン1 [RFC6020]の公開以来、YANGは他のプロトコル（RESTCONF [RESTCONF]やConstrained Application Protocol（CoAP）Management Interface（CoMI）[CoMI]など）で使用または使用が提案されています。さらに、XML以外のエンコーディングも提案されています（JSON [RFC7951]など）。"
    },
    {
      "indent": 3,
      "text": "This document describes the syntax and semantics of version 1.1 of the YANG language. It also describes how a data model defined in a YANG module is encoded in the Extensible Markup Language (XML) [XML] and how NETCONF operations are used to manipulate the data. Other protocols and encodings are possible but are out of scope for this specification.",
      "ja": "このドキュメントでは、YANG言語のバージョン1.1の構文とセマンティクスについて説明します。また、YANGモジュールで定義されたデータモデルがExtensible Markup Language（XML）[XML]でエンコードされる方法と、NETCONF操作を使用してデータを操作する方法についても説明します。他のプロトコルとエンコーディングも可能ですが、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In terms of developing YANG data models, [YANG-Guidelines] provides some guidelines and recommendations.",
      "ja": "YANGデータモデルの開発に関して、[YANG-Guidelines]はいくつかのガイドラインと推奨事項を提供します。"
    },
    {
      "indent": 3,
      "text": "Note that this document does not obsolete RFC 6020 [RFC6020].",
      "ja": "このドキュメントはRFC 6020 [RFC6020]を廃止するものではないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "1.1. Summary of Changes from RFC 6020",
      "section_title": true,
      "ja": "1.1. RFC 6020からの変更の概要"
    },
    {
      "indent": 3,
      "text": "This document defines version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification [RFC6020].",
      "ja": "このドキュメントは、YANG言語のバージョン1.1を定義しています。 YANGバージョン1.1は、YANG言語のメンテナンスリリースであり、元の仕様[RFC6020]のあいまいさと欠陥に対処しています。"
    },
    {
      "indent": 3,
      "text": "The following changes are not backward compatible with YANG version 1:",
      "ja": "次の変更は、YANGバージョン1との下位互換性がありません。"
    },
    {
      "indent": 3,
      "text": "o Changed the rules for the interpretation of escaped characters in double-quoted strings. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses a character sequence that is now illegal, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "ja": "o 二重引用符で囲まれた文字列のエスケープ文字の解釈に関するルールを変更しました。これは、YANGバージョン1からの下位互換性のない変更です。YANGバージョン1モジュールを1.1に更新し、モジュールが不正になった文字シーケンスを使用する場合、新しいルールに一致するように文字列を変更する必要があります。詳細については、セクション6.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o An unquoted string cannot contain any single or double quote characters. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses such quote characters, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "ja": "o 引用符で囲まれていない文字列には、一重引用符または二重引用符を含めることはできません。これは、YANGバージョン1からの下位互換性のない変更です。YANGバージョン1モジュールを1.1に更新し、モジュールがそのような引用文字を使用する場合、新しいルールに一致するように文字列を変更する必要があります。詳細については、セクション6.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Made \"when\" and \"if-feature\" illegal on list keys. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses these constructs, they must be removed to match the new rules.",
      "ja": "o 「いつ」と「if-feature」がリストキーで違法になりました。これは、YANGバージョン1からの下位互換性のない変更です。YANGバージョン1モジュールを1.1に更新し、モジュールがこれらの構成を使用する場合、新しい規則に一致するように削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Defined the legal characters in YANG modules. When updating a YANG version 1 module to 1.1, any characters that are now illegal must be removed. See Section 6 for details.",
      "ja": "o YANGモジュールで有効な文字を定義しました。 YANGバージョン1モジュールを1.1に更新する場合、現在は不正な文字を削除する必要があります。詳細については、セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Made noncharacters illegal in the built-in type \"string\". This change affects the runtime behavior of YANG-based protocols.",
      "ja": "o 組み込み型「文字列」で文字以外を無効にしました。この変更は、YANGベースのプロトコルの実行時の動作に影響します。"
    },
    {
      "indent": 3,
      "text": "The following additional changes have been done to YANG:",
      "ja": "YANGには、以下の追加の変更が加えられています。"
    },
    {
      "indent": 3,
      "text": "o Changed the YANG version from \"1\" to \"1.1\".",
      "ja": "o YANGのバージョンを「1」から「1.1」に変更しました。"
    },
    {
      "indent": 3,
      "text": "o Made the \"yang-version\" statement mandatory in YANG version \"1.1\".",
      "ja": "o YANGバージョン \"1.1\"で \"yang-version\"ステートメントを必須にしました。"
    },
    {
      "indent": 3,
      "text": "o Extended the \"if-feature\" syntax to be a boolean expression over feature names.",
      "ja": "o 「if-feature」構文を機能名に対するブール式に拡張しました。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"bit\", \"enum\", and \"identity\".",
      "ja": "o 「bit」、「enum」、「identity」で「if-feature」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"refine\".",
      "ja": "o 「refine」で「if-feature」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"choice\" as a shorthand \"case\" statement (see Section 7.9.2).",
      "ja": "o 「選択」を省略形の「ケース」ステートメントとして許可します（セクション7.9.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o Added a new substatement \"modifier\" to the \"pattern\" statement (see Section 9.4.6).",
      "ja": "o 「パターン」ステートメントに新しいサブステートメント「修飾子」を追加しました（セクション9.4.6を参照）。"
    },
    {
      "indent": 3,
      "text": "o Allow \"must\" in \"input\", \"output\", and \"notification\".",
      "ja": "o 「入力」、「出力」、および「通知」で「必須」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"require-instance\" in leafref.",
      "ja": "o leafrefで「require-instance」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"description\" and \"reference\" in \"import\" and \"include\".",
      "ja": "o 「インポート」と「インクルード」で「説明」と「参照」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow imports of multiple revisions of a module.",
      "ja": "o モジュールの複数のリビジョンのインポートを許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"augment\" to add conditionally mandatory nodes (see Section 7.17).",
      "ja": "o 「augment」で条件付き必須ノードを追加できるようにします（セクション7.17を参照）。"
    },
    {
      "indent": 3,
      "text": "o Added a set of new XML Path Language (XPath) functions in Section 10.",
      "ja": "o セクション10に一連の新しいXMLパス言語（XPath）関数を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Clarified the XPath context's tree in Section 6.4.1.",
      "ja": "o セクション6.4.1でXPathコンテキストのツリーを明確にしました。"
    },
    {
      "indent": 3,
      "text": "o Defined the string value of an identityref in XPath expressions (see Section 9.10).",
      "ja": "o XPath式でidentityrefの文字列値を定義しました（セクション9.10を参照）。"
    },
    {
      "indent": 3,
      "text": "o Clarified what unprefixed names mean in leafrefs in typedefs (see Sections 6.4.1 and 9.9.2).",
      "ja": "o typedefのリーフ参照で接頭辞のない名前が何を意味するかを明確にしました（セクション6.4.1および9.9.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o Allow identities to be derived from multiple base identities (see Sections 7.18 and 9.10).",
      "ja": "o IDが複数の基本IDから派生できるようにします（セクション7.18および9.10を参照）。"
    },
    {
      "indent": 3,
      "text": "o Allow enumerations and bits to be subtyped (see Sections 9.6 and 9.7).",
      "ja": "o 列挙型とビットをサブタイプ化できるようにします（セクション9.6および9.7を参照）。"
    },
    {
      "indent": 3,
      "text": "o Allow leaf-lists to have default values (see Section 7.7.2).",
      "ja": "o リーフリストにデフォルト値を持たせる（セクション7.7.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o Allow non-unique values in non-configuration leaf-lists (see Section 7.7).",
      "ja": "o 非構成リーフリストで非一意の値を許可します（セクション7.7を参照）。"
    },
    {
      "indent": 3,
      "text": "o Use syntax for case-sensitive strings (as per [RFC7405]) in the grammar.",
      "ja": "o 文法では、[RFC7405]のように、大文字と小文字を区別する文字列の構文を使用します。"
    },
    {
      "indent": 3,
      "text": "o Changed the module advertisement mechanism (see Section 5.6.4).",
      "ja": "o モジュール通知メカニズムを変更しました（5.6.4項を参照）。"
    },
    {
      "indent": 3,
      "text": "o Changed the scoping rules for definitions in submodules. A submodule can now reference all definitions in all submodules that belong to the same module, without using the \"include\" statement.",
      "ja": "o サブモジュールの定義のスコープ規則を変更しました。サブモジュールは、「include」ステートメントを使用せずに、同じモジュールに属するすべてのサブモジュールのすべての定義を参照できるようになりました。"
    },
    {
      "indent": 3,
      "text": "o Added a new statement \"action\", which is used to define operations tied to data nodes.",
      "ja": "o データノードに関連付けられた操作を定義するために使用される新しいステートメント「アクション」を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Allow notifications to be tied to data nodes.",
      "ja": "o 通知をデータノードに関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "o Added a new data definition statement \"anydata\" (see Section 7.10), which is RECOMMENDED to be used instead of \"anyxml\" when the data can be modeled in YANG.",
      "ja": "o 新しいデータ定義ステートメント「anydata」（セクション7.10を参照）が追加されました。これは、データをYANGでモデル化できる場合に「anyxml」の代わりに使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Allow types \"empty\" and \"leafref\" in unions.",
      "ja": "o 共用体でタイプ「空」と「葉」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow type \"empty\" in a key.",
      "ja": "o キーに「空」のタイプを許可します。"
    },
    {
      "indent": 3,
      "text": "o Removed the restriction that identifiers could not start with the characters \"xml\".",
      "ja": "o 識別子が文字「xml」で開始できないという制限を削除しました。"
    },
    {
      "indent": 3,
      "text": "The following changes have been done to the NETCONF mapping:",
      "ja": "NETCONFマッピングに次の変更が加えられました。"
    },
    {
      "indent": 3,
      "text": "o A server advertises support for YANG 1.1 modules by using ietf-yang-library [RFC7895] instead of listing them as capabilities in the <hello> message.",
      "ja": "o サーバーは、<hello>メッセージに機能としてリストする代わりに、ietf-yang-library [RFC7895]を使用して、YANG 1.1モジュールのサポートをアドバタイズします。"
    },
    {
      "indent": 0,
      "text": "2. Key Words",
      "section_title": true,
      "ja": "2. キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119].",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの \"は、BCP 14 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "The following terms are used within this document:",
      "ja": "このドキュメントでは、次の用語が使用されています。"
    },
    {
      "indent": 3,
      "text": "o action: An operation defined for a node in the data tree.",
      "ja": "o アクション：データツリーのノードに対して定義された操作。"
    },
    {
      "indent": 3,
      "text": "o anydata: A data node that can contain an unknown set of nodes that can be modeled by YANG, except anyxml.",
      "ja": "o anydata：anyxmlを除き、YANGでモデル化できる不明なノードのセットを含むことができるデータノード。"
    },
    {
      "indent": 3,
      "text": "o anyxml: A data node that can contain an unknown chunk of XML data.",
      "ja": "o anyxml：不明なXMLデータのチャンクを含むことができるデータノード。"
    },
    {
      "indent": 3,
      "text": "o augment: Adds new schema nodes to a previously defined schema node.",
      "ja": "o augment：以前に定義されたスキーマノードに新しいスキーマノードを追加します。"
    },
    {
      "indent": 3,
      "text": "o base type: The type from which a derived type was derived, which may be either a built-in type or another derived type.",
      "ja": "o 基本型：派生型の派生元の型。組み込み型または別の派生型のいずれかです。"
    },
    {
      "indent": 3,
      "text": "o built-in type: A YANG data type defined in the YANG language, such as uint32 or string.",
      "ja": "o 組み込み型：uint32やstringなど、YANG言語で定義されたYANGデータ型。"
    },
    {
      "indent": 3,
      "text": "o choice: A schema node where only one of a number of identified alternatives is valid.",
      "ja": "o 選択：識別された複数の選択肢のうち1つだけが有効なスキーマノード。"
    },
    {
      "indent": 3,
      "text": "o client: An entity that can access YANG-defined data on a server, over some network management protocol.",
      "ja": "o クライアント：ネットワーク管理プロトコルを介してサーバー上のYANG定義データにアクセスできるエンティティ。"
    },
    {
      "indent": 3,
      "text": "o conformance: A measure of how accurately a server follows a data model.",
      "ja": "o 適合性：サーバーがデータモデルにどれだけ正確に従うかを示す尺度。"
    },
    {
      "indent": 3,
      "text": "o container: An interior data node that exists in at most one instance in the data tree. A container has no value, but rather a set of child nodes.",
      "ja": "o コンテナー：データツリーの最大1つのインスタンスに存在する内部データノード。コンテナには値はありませんが、子ノードのセットがあります。"
    },
    {
      "indent": 3,
      "text": "o data definition statement: A statement that defines new data nodes. One of \"container\", \"leaf\", \"leaf-list\", \"list\", \"choice\", \"case\", \"augment\", \"uses\", \"anydata\", and \"anyxml\".",
      "ja": "o データ定義ステートメント：新しいデータノードを定義するステートメント。 「container」、「leaf」、「leaf-list」、「list」、「choice」、「case」、「augment」、「uses」、「anydata」、「anyxml」のいずれか。"
    },
    {
      "indent": 3,
      "text": "o data model: A data model describes how data is represented and accessed.",
      "ja": "o データモデル：データモデルは、データの表現方法とアクセス方法を記述します。"
    },
    {
      "indent": 3,
      "text": "o data node: A node in the schema tree that can be instantiated in a data tree. One of container, leaf, leaf-list, list, anydata, and anyxml.",
      "ja": "o データノード：データツリーでインスタンス化できるスキーマツリーのノード。コンテナ、リーフ、リーフリスト、リスト、anydata、anyxmlのいずれか。"
    },
    {
      "indent": 3,
      "text": "o data tree: An instantiated tree of any data modeled with YANG, e.g., configuration data, state data, combined configuration and state data, RPC or action input, RPC or action output, or notification.",
      "ja": "o データツリー：YANGでモデル化されたデータのインスタンス化されたツリー。たとえば、構成データ、状態データ、構成と状態の組み合わせデータ、RPCまたはアクション入力、RPCまたはアクション出力、または通知"
    },
    {
      "indent": 3,
      "text": "o derived type: A type that is derived from a built-in type (such as uint32) or another derived type.",
      "ja": "o 派生型：組み込み型（uint32など）または別の派生型から派生した型。"
    },
    {
      "indent": 3,
      "text": "o extension: An extension attaches non-YANG semantics to statements. The \"extension\" statement defines new statements to express these semantics.",
      "ja": "o 拡張：拡張は、非YANGセマンティクスをステートメントに付加します。 「拡張」ステートメントは、これらのセマンティクスを表現するための新しいステートメントを定義します。"
    },
    {
      "indent": 3,
      "text": "o feature: A mechanism for marking a portion of the model as optional. Definitions can be tagged with a feature name and are only valid on servers that support that feature.",
      "ja": "o 機能：モデルの一部をオプションとしてマークするためのメカニズム。定義は機能名でタグ付けでき、その機能をサポートするサーバーでのみ有効です。"
    },
    {
      "indent": 3,
      "text": "o grouping: A reusable set of schema nodes, which may be used locally in the module and by other modules that import from it. The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "ja": "o グループ化：再利用可能なスキーマノードのセット。モジュール内でローカルに使用したり、モジュールからインポートする他のモジュールで使用したりできます。 「グループ化」ステートメントはデータ定義ステートメントではないため、スキーマツリーのノードを定義しません。"
    },
    {
      "indent": 3,
      "text": "o identifier: A string used to identify different kinds of YANG items by name.",
      "ja": "o identifier：さまざまな種類のYANGアイテムを名前で識別するために使用される文字列。"
    },
    {
      "indent": 3,
      "text": "o identity: A globally unique, abstract, and untyped name.",
      "ja": "o identity：グローバルに一意で、抽象的で型付けされていない名前。"
    },
    {
      "indent": 3,
      "text": "o instance identifier: A mechanism for identifying a particular node in a data tree.",
      "ja": "o インスタンス識別子：データツリー内の特定のノードを識別するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "o interior node: Nodes within a hierarchy that are not leaf nodes.",
      "ja": "o 内部ノード：葉ノードではない階層内のノード。"
    },
    {
      "indent": 3,
      "text": "o leaf: A data node that exists in at most one instance in the data tree. A leaf has a value but no child nodes.",
      "ja": "o リーフ：データツリー内の多くても1つのインスタンスに存在するデータノード。リーフには値がありますが、子ノードはありません。"
    },
    {
      "indent": 3,
      "text": "o leaf-list: Like the leaf node but defines a set of uniquely identifiable nodes rather than a single node. Each node has a value but no child nodes.",
      "ja": "o 葉リスト：葉ノードと同様ですが、単一のノードではなく、一意に識別可能なノードのセットを定義します。各ノードには値がありますが、子ノードはありません。"
    },
    {
      "indent": 3,
      "text": "o list: An interior data node that may exist in multiple instances in the data tree. A list has no value, but rather a set of child nodes.",
      "ja": "o リスト：データツリーの複数のインスタンスに存在する可能性のある内部データノード。リストには値はありませんが、子ノードのセットがあります。"
    },
    {
      "indent": 3,
      "text": "o mandatory node: A mandatory node is one of:",
      "ja": "o 必須ノード：必須ノードは次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "* A leaf, choice, anydata, or anyxml node with a \"mandatory\" statement with the value \"true\".",
      "ja": "* リーフ、チョイス、anydata、またはanyxmlノードで、値が「true」の「必須」ステートメント。"
    },
    {
      "indent": 6,
      "text": "* A list or leaf-list node with a \"min-elements\" statement with a value greater than zero.",
      "ja": "* ゼロより大きい値を持つ「min-elements」ステートメントを持つリストまたはリーフリストノード。"
    },
    {
      "indent": 6,
      "text": "* A container node without a \"presence\" statement and that has at least one mandatory node as a child.",
      "ja": "* 「プレゼンス」ステートメントがなく、子として少なくとも1つの必須ノードがあるコンテナノード。"
    },
    {
      "indent": 3,
      "text": "o module: A YANG module defines hierarchies of schema nodes. With its definitions and the definitions it imports or includes from elsewhere, a module is self-contained and \"compilable\".",
      "ja": "o module：YANGモジュールは、スキーマノードの階層を定義します。モジュールの定義と、インポートまたは他の場所からの定義により、モジュールは自己完結型で「コンパイル可能」です。"
    },
    {
      "indent": 3,
      "text": "o non-presence container: A container that has no meaning of its own, existing only to contain child nodes.",
      "ja": "o 非存在コンテナ：独自の意味を持たないコンテナで、子ノードを含むためだけに存在します。"
    },
    {
      "indent": 3,
      "text": "o presence container: A container where the presence of the container itself carries some meaning.",
      "ja": "o プレゼンスコンテナ：コンテナ自体のプレゼンスが何らかの意味を持つコンテナ。"
    },
    {
      "indent": 3,
      "text": "o RPC: A Remote Procedure Call.",
      "ja": "o RPC：リモートプロシージャコール。"
    },
    {
      "indent": 3,
      "text": "o RPC operation: A specific Remote Procedure Call.",
      "ja": "o RPC操作：特定のリモートプロシージャコール。"
    },
    {
      "indent": 3,
      "text": "o schema node: A node in the schema tree. One of action, container, leaf, leaf-list, list, choice, case, rpc, input, output, notification, anydata, and anyxml.",
      "ja": "o スキーマノード：スキーマツリーのノード。 action、container、leaf、leaf-list、list、choice、case、rpc、input、output、notification、anydata、anyxmlのいずれか。"
    },
    {
      "indent": 3,
      "text": "o schema node identifier: A mechanism for identifying a particular node in the schema tree.",
      "ja": "o スキーマノード識別子：スキーマツリー内の特定のノードを識別するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "o schema tree: The definition hierarchy specified within a module.",
      "ja": "o スキーマツリー：モジュール内で指定された定義階層。"
    },
    {
      "indent": 3,
      "text": "o server: An entity that provides access to YANG-defined data to a client, over some network management protocol.",
      "ja": "o サーバー：一部のネットワーク管理プロトコルを介して、クライアントにYANG定義のデータへのアクセスを提供するエンティティ。"
    },
    {
      "indent": 3,
      "text": "o server deviation: A failure of the server to implement a module faithfully.",
      "ja": "o サーバーの逸脱：サーバーがモジュールを忠実に実装できないこと。"
    },
    {
      "indent": 3,
      "text": "o submodule: A partial module definition that contributes derived types, groupings, data nodes, RPCs, actions, and notifications to a module. A YANG module can be constructed from a number of submodules.",
      "ja": "o サブモジュール：派生型、グループ化、データノード、RPC、アクション、および通知をモジュールに提供する部分的なモジュール定義。 YANGモジュールは、いくつかのサブモジュールから構築できます。"
    },
    {
      "indent": 3,
      "text": "o top-level data node: A data node where there is no other data node between it and a \"module\" or \"submodule\" statement.",
      "ja": "o トップレベルのデータノード：「モジュール」または「サブモジュール」ステートメントとの間に他のデータノードがないデータノード。"
    },
    {
      "indent": 3,
      "text": "o uses: The \"uses\" statement is used to instantiate the set of schema nodes defined in a \"grouping\" statement. The instantiated nodes may be refined and augmented to tailor them to any specific needs.",
      "ja": "o 用途：「uses」ステートメントは、「grouping」ステートメントで定義されたスキーマノードのセットをインスタンス化するために使用されます。インスタンス化されたノードは、特定のニーズに合わせて調整および拡張することができます。"
    },
    {
      "indent": 3,
      "text": "o value space: For a data type; the set of values permitted by the data type. For a leaf or leaf-list instance; the value space of its data type.",
      "ja": "o 値スペース：データ型の場合。データ型で許可されている値のセット。リーフまたはリーフリストのインスタンスの場合。そのデータ型の値空間。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "ja": "以下の用語は[RFC6241]で定義されています："
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "ja": "o 設定データ"
    },
    {
      "indent": 3,
      "text": "o configuration datastore",
      "ja": "o 構成データストア"
    },
    {
      "indent": 3,
      "text": "o datastore",
      "ja": "o データストア"
    },
    {
      "indent": 3,
      "text": "o state data",
      "ja": "o 状態データ"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a datastore is realized as an instantiated data tree.",
      "ja": "YANGでモデル化すると、データストアはインスタンス化されたデータツリーとして実現されます。"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a configuration datastore is realized as an instantiated data tree with configuration data.",
      "ja": "YANGでモデル化すると、構成データストアは、構成データを含むインスタンス化されたデータツリーとして実現されます。"
    },
    {
      "indent": 0,
      "text": "3.1. A Note on Examples",
      "section_title": true,
      "ja": "3.1. 例に関する注記"
    },
    {
      "indent": 3,
      "text": "Throughout this document, there are many examples of YANG statements. These examples are supposed to illustrate certain features and are not supposed to be complete, valid YANG modules.",
      "ja": "このドキュメント全体を通して、YANGステートメントの多くの例があります。これらの例は、特定の機能を説明するためのものであり、完全で有効なYANGモジュールではありません。"
    },
    {
      "indent": 0,
      "text": "4. YANG Overview",
      "section_title": true,
      "ja": "4. ヤンの概要"
    },
    {
      "indent": 3,
      "text": "This non-normative section is intended to give a high-level overview of YANG to first-time readers.",
      "ja": "この非規範的なセクションは、初めての読者にYANGの概要を説明することを目的としています。"
    },
    {
      "indent": 0,
      "text": "4.1. Functional Overview",
      "section_title": true,
      "ja": "4.1. 機能の概要"
    },
    {
      "indent": 3,
      "text": "YANG is a language originally designed to model data for the NETCONF protocol. A YANG module defines hierarchies of data that can be used for NETCONF-based operations, including configuration, state data, RPCs, and notifications. This allows a complete description of all data sent between a NETCONF client and server. Although out of scope for this specification, YANG can also be used with protocols other than NETCONF.",
      "ja": "YANGは、もともとNETCONFプロトコルのデータをモデル化するために設計された言語です。 YANGモジュールは、構成、状態データ、RPC、通知など、NETCONFベースの操作に使用できるデータの階層を定義します。これにより、NETCONFクライアントとサーバーの間で送信されるすべてのデータの完全な説明が可能になります。この仕様の範囲外ですが、YANGはNETCONF以外のプロトコルでも使用できます。"
    },
    {
      "indent": 3,
      "text": "YANG models the hierarchical organization of data as a tree in which each node has a name, and either a value or a set of child nodes. YANG provides clear and concise descriptions of the nodes, as well as the interaction between those nodes.",
      "ja": "YANGは、データの階層構造をツリーとしてモデル化します。各ノードには名前があり、値または子ノードのセットがあります。 YANGは、ノードの明確で簡潔な説明、およびそれらのノード間の相互作用を提供します。"
    },
    {
      "indent": 3,
      "text": "YANG structures data models into modules and submodules. A module can import definitions from other external modules and can include definitions from submodules. The hierarchy can be augmented, allowing one module to add data nodes to the hierarchy defined in another module. This augmentation can be conditional, with new nodes appearing only if certain conditions are met.",
      "ja": "YANGは、データモデルをモジュールとサブモジュールに構造化します。モジュールは他の外部モジュールから定義をインポートでき、サブモジュールからの定義を含めることができます。階層を拡張して、あるモジュールが別のモジュールで定義された階層にデータノードを追加できるようにすることができます。この拡張は条件付きにすることができ、特定の条件が満たされた場合にのみ新しいノードが表示されます。"
    },
    {
      "indent": 3,
      "text": "YANG data models can describe constraints to be enforced on the data, restricting the presence or value of nodes based on the presence or value of other nodes in the hierarchy. These constraints are enforceable by either the client or the server.",
      "ja": "YANGデータモデルは、データに適用される制約を記述し、階層内の他のノードの存在または値に基づいてノードの存在または値を制限できます。これらの制約は、クライアントまたはサーバーのいずれかによって実施できます。"
    },
    {
      "indent": 3,
      "text": "YANG defines a set of built-in types and has a type mechanism through which additional types may be defined. Derived types can restrict their base type's set of valid values using mechanisms like range or pattern restrictions that can be enforced by clients or servers. They can also define usage conventions for use of the derived type, such as a string-based type that contains a hostname.",
      "ja": "YANGは組み込み型のセットを定義し、追加の型を定義できる型メカニズムを備えています。派生型は、クライアントやサーバーによって強制できる範囲やパターンの制限などのメカニズムを使用して、基本型の有効な値のセットを制限できます。また、ホスト名を含む文字列ベースの型など、派生型を使用するための使用規則を定義することもできます。"
    },
    {
      "indent": 3,
      "text": "YANG permits the definition of reusable groupings of nodes. The usage of these groupings can refine or augment the nodes, allowing it to tailor the nodes to its particular needs. Derived types and groupings can be defined in one module and used in either the same module or another module that imports it.",
      "ja": "YANGでは、再利用可能なノードのグループ化を定義できます。これらのグループ化を使用すると、ノードを調整または拡張して、特定のニーズに合わせてノードを調整できます。派生型とグループ化は、1つのモジュールで定義して、同じモジュールまたはそれをインポートする別のモジュールで使用できます。"
    },
    {
      "indent": 3,
      "text": "YANG data hierarchy constructs include defining lists where list entries are identified by keys that distinguish them from each other. Such lists may be defined as either sorted by user or automatically sorted by the system. For user-sorted lists, operations are defined for manipulating the order of the list entries.",
      "ja": "YANGデータ階層構造には、リストエントリが互いに区別するキーによって識別されるリストの定義が含まれます。そのようなリストは、ユーザーによってソートされるか、システムによって自動的にソートされるかのいずれかとして定義されます。ユーザーがソートしたリストの場合、操作はリストエントリの順序を操作するために定義されます。"
    },
    {
      "indent": 3,
      "text": "YANG modules can be translated into an equivalent XML syntax called YANG Independent Notation (YIN) (Section 13), allowing applications using XML parsers and Extensible Stylesheet Language Transformations (XSLT) scripts to operate on the models. The conversion from YANG to YIN is semantically lossless, so content in YIN can be round-tripped back into YANG.",
      "ja": "YANGモジュールは、YANG Independent Notation（YIN）（セクション13）と呼ばれる同等のXML構文に変換できるため、XMLパーサーとExtensible Stylesheet Language Transformations（XSLT）スクリプトを使用するアプリケーションでモデルを操作できます。 YANGからYINへの変換はセマンティックスロスレスであるため、YINのコンテンツをYANGに戻すことができます。"
    },
    {
      "indent": 3,
      "text": "YANG is an extensible language, allowing extensions to be defined by standards bodies, vendors, and individuals. The statement syntax allows these extensions to coexist with standard YANG statements in a natural way, while extensions in a YANG module stand out sufficiently for the reader to notice them.",
      "ja": "YANGは拡張可能な言語であり、標準化団体、ベンダー、および個人が拡張機能を定義できるようにします。ステートメント構文により、これらの拡張機能は標準のYANGステートメントと自然に共存できますが、YANGモジュールの拡張機能は、読者がそれらに気付くのに十分なほど目立ちます。"
    },
    {
      "indent": 3,
      "text": "YANG resists the tendency to solve all possible problems, limiting the problem space to allow expression of data models for network management protocols such as NETCONF, not arbitrary XML documents or arbitrary data models.",
      "ja": "YANGは、あらゆる問題を解決する傾向に抵抗し、問題のスペースを制限して、任意のXML文書や任意のデータモデルではなく、NETCONFなどのネットワーク管理プロトコルのデータモデルを表現できるようにします。"
    },
    {
      "indent": 3,
      "text": "To the extent possible, YANG maintains compatibility with the Simple Network Management Protocol's (SNMP's) SMIv2 (Structure of Management Information version 2 [RFC2578] [RFC2579]). SMIv2-based MIB modules can be automatically translated into YANG modules for read-only access [RFC6643]. However, YANG is not concerned with reverse translation from YANG to SMIv2.",
      "ja": "YANGは、可能な限り、Simple Network Management Protocol（SNMP）のSMIv2（Structure of Management Information version 2 [RFC2578] [RFC2579]）との互換性を維持しています。 SMIv2ベースのMIBモジュールは、読み取り専用アクセス用に自動的にYANGモジュールに変換できます[RFC6643]。ただし、YANGは、YANGからSMIv2への逆変換には関係しません。"
    },
    {
      "indent": 0,
      "text": "4.2. Language Overview",
      "section_title": true,
      "ja": "4.2. 言語の概要"
    },
    {
      "indent": 3,
      "text": "This section introduces some important constructs used in YANG that will aid in the understanding of the language specifics in later sections.",
      "ja": "このセクションでは、YANGで使用されるいくつかの重要な構成要素を紹介します。これは、後のセクションで言語の詳細を理解するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Modules and Submodules",
      "section_title": true,
      "ja": "4.2.1. モジュールとサブモジュール"
    },
    {
      "indent": 3,
      "text": "YANG data models are defined in modules. A module contains a collection of related definitions.",
      "ja": "YANGデータモデルはモジュールで定義されます。モジュールには、関連する定義のコレクションが含まれています。"
    },
    {
      "indent": 3,
      "text": "A module contains three types of statements: module header statements, \"revision\" statements, and definition statements. The module header statements describe the module and give information about the module itself, the \"revision\" statements give information about the history of the module, and the definition statements are the body of the module where the data model is defined.",
      "ja": "モジュールには、モジュールヘッダーステートメント、「改訂」ステートメント、定義ステートメントの3種類のステートメントが含まれています。モジュールヘッダーステートメントはモジュールを説明し、モジュール自体に関する情報を提供します。「リビジョン」ステートメントはモジュールの履歴に関する情報を提供し、定義ステートメントはデータモデルが定義されているモジュールの本体です。"
    },
    {
      "indent": 3,
      "text": "A server may implement a number of modules, allowing multiple views of the same data or multiple views of disjoint subsections of the server's data. Alternatively, the server may implement only one module that defines all available data.",
      "ja": "サーバーは、いくつかのモジュールを実装して、同じデータの複数のビュー、またはサーバーのデータの互いに素なサブセクションの複数のビューを許可できます。または、サーバーは、使用可能なすべてのデータを定義するモジュールを1つだけ実装することもできます。"
    },
    {
      "indent": 3,
      "text": "A module may have portions of its definitions separated into submodules, based on the needs of the module designer. The external view remains that of a single module, regardless of the presence or size of its submodules.",
      "ja": "モジュールは、モジュール設計者のニーズに基づいて、その定義の一部をサブモジュールに分割することができます。サブモジュールの存在やサイズに関係なく、外観は1つのモジュールの外観のままです。"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement allows a module or submodule to reference definitions defined in other modules.",
      "ja": "「インポート」ステートメントにより、モジュールまたはサブモジュールは、他のモジュールで定義された定義を参照できます。"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used in a module to identify each submodule that belongs to it.",
      "ja": "「include」ステートメントは、モジュールに使用され、それに属する各サブモジュールを識別します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Data Modeling Basics",
      "section_title": true,
      "ja": "4.2.2. データモデリングの基本"
    },
    {
      "indent": 3,
      "text": "YANG defines four main types of data nodes for data modeling. In each of the following subsections, the examples show the YANG syntax as well as a corresponding XML encoding. The syntax of YANG statements is defined in Section 6.3.",
      "ja": "YANGは、データモデリング用に4つの主要なタイプのデータノードを定義しています。次の各サブセクションの例では、YANG構文と対応するXMLエンコーディングを示しています。 YANGステートメントの構文はセクション6.3で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Leaf Nodes",
      "section_title": true,
      "ja": "4.2.2.1. 葉ノード"
    },
    {
      "indent": 3,
      "text": "A leaf instance contains simple data like an integer or a string. It has exactly one value of a particular type and no child nodes.",
      "ja": "リーフインスタンスには、整数や文字列などの単純なデータが含まれます。特定のタイプの値が1つだけあり、子ノードはありません。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "leaf host-name {\n  type string;\n  description\n    \"Hostname for this system.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<host-name>my.example.com</host-name>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is covered in Section 7.6.",
      "ja": "「リーフ」ステートメントについては、セクション7.6で説明します。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Leaf-List Nodes",
      "section_title": true,
      "ja": "4.2.2.2. リーフリストノード"
    },
    {
      "indent": 3,
      "text": "A leaf-list defines a sequence of values of a particular type.",
      "ja": "リーフリストは、特定のタイプの値のシーケンスを定義します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<domain-search>high.example.com</domain-search>\n<domain-search>low.example.com</domain-search>\n<domain-search>everywhere.example.com</domain-search>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"leaf-list\" statement is covered in Section 7.7.",
      "ja": "「リーフリスト」ステートメントについては、セクション7.7で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Container Nodes",
      "section_title": true,
      "ja": "4.2.2.3. コンテナノード"
    },
    {
      "indent": 3,
      "text": "A container is used to group related nodes in a subtree. A container has only child nodes and no value. A container may contain any number of child nodes of any type (leafs, lists, containers, leaf-lists, actions, and notifications).",
      "ja": "コンテナは、関連するノードをサブツリーにグループ化するために使用されます。コンテナには子ノードのみがあり、値はありません。コンテナーには、任意のタイプ（リーフ、リスト、コンテナー、リーフリスト、アクション、および通知）の子ノードをいくつでも含めることができます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "container system {\n  container login {\n    leaf message {\n      type string;\n      description\n        \"Message given at start of login session.\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <login>\n    <message>Good morning</message>\n  </login>\n</system>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is covered in Section 7.5.",
      "ja": "「コンテナ」ステートメントについては、セクション7.5で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.4. List Nodes",
      "section_title": true,
      "ja": "4.2.2.4. ノードのリスト"
    },
    {
      "indent": 3,
      "text": "A list defines a sequence of list entries. Each entry is like a container and is uniquely identified by the values of its key leafs if it has any key leafs defined. A list can define multiple key leafs and may contain any number of child nodes of any type (including leafs, lists, containers, etc.).",
      "ja": "リストは、リストエントリのシーケンスを定義します。各エントリはコンテナのようなものであり、キーリーフが定義されている場合、そのキーリーフの値によって一意に識別されます。リストは複数のキーリーフを定義でき、任意のタイプ（リーフ、リスト、コンテナなどを含む）の子ノードをいくつでも含めることができます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n  leaf class {\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>glocks</name>\n  <full-name>Goldie Locks</full-name>\n  <class>intruder</class>\n</user>\n<user>\n  <name>snowey</name>\n  <full-name>Snow White</full-name>\n  <class>free-loader</class>\n</user>\n<user>\n  <name>rzell</name>\n  <full-name>Rapun Zell</full-name>\n  <class>tower</class>\n</user>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is covered in Section 7.8.",
      "ja": "「list」ステートメントについては、セクション7.8で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.5. Example Module",
      "section_title": true,
      "ja": "4.2.2.5. モジュールの例"
    },
    {
      "indent": 3,
      "text": "These statements are combined to define the module:",
      "ja": "これらのステートメントを組み合わせて、モジュールを定義します。"
    },
    {
      "indent": 5,
      "text": "// Contents of \"example-system.yang\"\nmodule example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\";\ncontact \"joe@example.com\";\ndescription\n  \"The module for entities implementing the Example system.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "container system {\n  leaf host-name {\n    type string;\n    description\n      \"Hostname for this system.\";\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "         container login {\n           leaf message {\n             type string;\n             description\n               \"Message given at start of login session.\";\n           }\n           list user {\n             key \"name\";\n             leaf name {\n               type string;\n             }\n             leaf full-name {\n               type string;\n             }\n             leaf class {\n               type string;\n             }\n           }\n         }\n       }\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.3. Configuration and State Data",
      "section_title": true,
      "ja": "4.2.3. 構成および状態データ"
    },
    {
      "indent": 3,
      "text": "YANG can model state data, as well as configuration data, based on the \"config\" statement. When a node is tagged with \"config false\", its subhierarchy is flagged as state data. If it is tagged with \"config true\", its subhierarchy is flagged as configuration data. Parent containers, lists, and key leafs are reported also, giving the context for the state data.",
      "ja": "YANGは、「config」ステートメントに基づいて、状態データと構成データをモデル化できます。ノードに「config false」のタグが付けられると、そのサブ階層に状態データとしてフラグが立てられます。 「config true」のタグが付いている場合、そのサブ階層には構成データとしてフラグが立てられます。親コンテナー、リスト、およびキーリーフも報告され、状態データのコンテキストが提供されます。"
    },
    {
      "indent": 3,
      "text": "In this example, two leafs are defined for each interface, a configured speed and an observed speed.",
      "ja": "この例では、構成された速度と観測された速度の2つのリーフが各インターフェイスに定義されています。"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  config true;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf speed {\n    type enumeration {\n      enum 10m;\n      enum 100m;\n      enum auto;\n    }\n  }\n  leaf observed-speed {\n    type uint32;\n    config false;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"config\" statement is covered in Section 7.21.1.",
      "ja": "「config」ステートメントについては、セクション7.21.1で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Built-In Types",
      "section_title": true,
      "ja": "4.2.4. 組み込み型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements of network management. The following table summarizes the built-in types discussed in Section 9:",
      "ja": "YANGには、多くのプログラミング言語に似た組み込み型のセットがありますが、ネットワーク管理の特別な要件による違いがあります。次の表は、セクション9で説明されている組み込み型をまとめたものです。"
    },
    {
      "indent": 7,
      "text": "+---------------------+-------------------------------------+\n| Name                | Description                         |\n+---------------------+-------------------------------------+\n| binary              | Any binary data                     |\n| bits                | A set of bits or flags              |\n| boolean             | \"true\" or \"false\"                   |\n| decimal64           | 64-bit signed decimal number        |\n| empty               | A leaf that does not have any value |\n| enumeration         | One of an enumerated set of strings |\n| identityref         | A reference to an abstract identity |\n| instance-identifier | A reference to a data tree node     |\n| int8                | 8-bit signed integer                |\n| int16               | 16-bit signed integer               |\n| int32               | 32-bit signed integer               |\n| int64               | 64-bit signed integer               |\n| leafref             | A reference to a leaf instance      |\n| string              | A character string                  |\n| uint8               | 8-bit unsigned integer              |\n| uint16              | 16-bit unsigned integer             |\n| uint32              | 32-bit unsigned integer             |\n| uint64              | 64-bit unsigned integer             |\n| union               | Choice of member types              |\n+---------------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"type\" statement is covered in Section 7.4.",
      "ja": "「type」ステートメントについては、セクション7.4で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.5. Derived Types (typedef)",
      "section_title": true,
      "ja": "4.2.5. 派生型（typedef）"
    },
    {
      "indent": 3,
      "text": "YANG can define derived types from base types using the \"typedef\" statement. A base type can be either a built-in type or a derived type, allowing a hierarchy of derived types.",
      "ja": "YANGは、「typedef」ステートメントを使用して、基本型からの派生型を定義できます。基本型は組み込み型または派生型のいずれかであり、派生型の階層を可能にします。"
    },
    {
      "indent": 3,
      "text": "A derived type can be used as the argument for the \"type\" statement.",
      "ja": "派生型は、「type」ステートメントの引数として使用できます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "typedef percent {\n  type uint8 {\n    range \"0 .. 100\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "leaf completed {\n  type percent;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<completed>20</completed>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement is covered in Section 7.3.",
      "ja": "「typedef」ステートメントについては、セクション7.3で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.6. Reusable Node Groups (grouping)",
      "section_title": true,
      "ja": "4.2.6. 再利用可能なノードグループ（グループ化）"
    },
    {
      "indent": 3,
      "text": "Groups of nodes can be assembled into reusable collections using the \"grouping\" statement. A grouping defines a set of nodes that are instantiated with the \"uses\" statement.",
      "ja": "ノードのグループは、「グループ化」ステートメントを使用して再利用可能なコレクションにアセンブルできます。グループ化は、「uses」ステートメントでインスタンス化されるノードのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 0,
      "text": "     grouping target {\n       leaf address {\n         type inet:ip-address;\n         description \"Target IP address.\";\n       }\n       leaf port {\n         type inet:port-number;\n          description \"Target port number.\";\n       }\n     }\n     container peer {\n       container destination {\n         uses target;\n       }\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<peer>\n  <destination>\n    <address>2001:db8::2</address>\n    <port>830</port>\n  </destination>\n</peer>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The grouping can be refined as it is used, allowing certain statements to be overridden. In this example, the description is refined:",
      "ja": "使用時にグループ化を調整して、特定のステートメントを上書きすることができます。この例では、説明が洗練されています。"
    },
    {
      "indent": 5,
      "text": "container connection {\n  container source {\n    uses target {\n      refine \"address\" {\n        description \"Source IP address.\";\n      }\n      refine \"port\" {\n        description \"Source port number.\";\n      }\n    }\n  }\n  container destination {\n    uses target {\n      refine \"address\" {\n        description \"Destination IP address.\";\n      }\n      refine \"port\" {\n        description \"Destination port number.\";\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is covered in Section 7.12.",
      "ja": "「グループ化」ステートメントについては、セクション7.12で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Choices",
      "section_title": true,
      "ja": "4.2.7. 選択肢"
    },
    {
      "indent": 3,
      "text": "YANG allows the data model to segregate incompatible nodes into distinct choices using the \"choice\" and \"case\" statements. The \"choice\" statement contains a set of \"case\" statements that define sets of schema nodes that cannot appear together. Each \"case\" may contain multiple nodes, but each node may appear in only one \"case\" under a \"choice\".",
      "ja": "YANGを使用すると、データモデルは「choice」および「case」ステートメントを使用して、互換性のないノードを異なる選択肢に分離できます。 「choice」ステートメントには、一緒に表示できないスキーマノードのセットを定義する「case」ステートメントのセットが含まれています。各「ケース」には複数のノードが含まれる場合がありますが、各ノードは「選択」の下の1つの「ケース」にしか表示されません。"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes appear only in the schema tree and not in the data tree. The additional levels of hierarchy are not needed beyond the conceptual schema. The presence of a case is indicated by the presence of one or more of the nodes within it.",
      "ja": "選択ノードとケースノードはスキーマツリーにのみ表示され、データツリーには表示されません。概念的なスキーマを超えて、階層の追加レベルは必要ありません。ケースの存在は、ケース内の1つ以上のノードの存在によって示されます。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time, when a node from one case is created in the data tree, all nodes from all other cases are implicitly deleted. The server handles the enforcement of the constraint, preventing incompatibilities from existing in the configuration.",
      "ja": "常に有効なのは選択肢のケースの1つだけなので、1つのケースのノードがデータツリーに作成されると、他のすべてのケースのすべてのノードが暗黙的に削除されます。サーバーは制約の適用を処理し、構成に非互換性が存在しないようにします。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "container food {\n  choice snack {\n    case sports-arena {\n      leaf pretzel {\n        type empty;\n      }\n      leaf beer {\n        type empty;\n      }\n    }\n    case late-night {\n      leaf chocolate {\n        type enumeration {\n          enum dark;\n          enum milk;\n          enum first-available;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<food>\n  <pretzel/>\n  <beer/>\n</food>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement is covered in Section 7.9.",
      "ja": "「選択」ステートメントについては、セクション7.9で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.8. Extending Data Models (augment)",
      "section_title": true,
      "ja": "4.2.8. データモデルの拡張（拡張）"
    },
    {
      "indent": 3,
      "text": "YANG allows a module to insert additional nodes into data models, including both the current module (and its submodules) and an external module. This is useful, for example, for vendors to add vendor-specific parameters to standard data models in an interoperable way.",
      "ja": "YANGにより、モジュールは、現在のモジュール（およびそのサブモジュール）と外部モジュールの両方を含む追加のノードをデータモデルに挿入できます。これは、たとえば、ベンダーが相互運用可能な方法でベンダー固有のパラメーターを標準データモデルに追加する場合に役立ちます。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement defines the location in the data model hierarchy where new nodes are inserted, and the \"when\" statement defines the conditions when the new nodes are valid.",
      "ja": "「augment」ステートメントは、新しいノードが挿入されるデータモデル階層内の場所を定義し、「when」ステートメントは、新しいノードが有効なときの条件を定義します。"
    },
    {
      "indent": 3,
      "text": "When a server implements a module containing an \"augment\" statement, that implies that the server's implementation of the augmented module contains the additional nodes.",
      "ja": "サーバーが「拡張」ステートメントを含むモジュールを実装する場合、それは、サーバーの拡張モジュールの実装に追加のノードが含まれることを意味します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "augment /system/login/user {\n  when \"class != 'wheel'\";\n  leaf uid {\n    type uint16 {\n      range \"1000 .. 30000\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This example defines a \"uid\" node that is valid only when the user's \"class\" is not \"wheel\".",
      "ja": "この例では、ユーザーの「クラス」が「ホイール」ではない場合にのみ有効な「uid」ノードを定義しています。"
    },
    {
      "indent": 3,
      "text": "If a module augments another module, the XML elements that are added to the encoding are in the namespace of the augmenting module. For example, if the above augmentation were in a module with prefix \"other\", the XML would look like:",
      "ja": "モジュールが別のモジュールを拡張する場合、エンコーディングに追加されるXML要素は、拡張モジュールの名前空間にあります。たとえば、上記の拡張が「other」という接頭辞を持つモジュール内にある場合、XMLは次のようになります。"
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコードの例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>alicew</name>\n  <full-name>Alice N. Wonderland</full-name>\n  <class>drop-out</class>\n  <other:uid>1024</other:uid>\n</user>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement is covered in Section 7.17.",
      "ja": "「拡張」ステートメントについては、セクション7.17で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.2.9. Operation Definitions",
      "section_title": true,
      "ja": "4.2.9. 操作の定義"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of operations. The operations' names, input parameters, and output parameters are modeled using YANG data definition statements. Operations on the top level in a module are defined with the \"rpc\" statement. Operations can also be tied to a container or list data node. Such operations are defined with the \"action\" statement.",
      "ja": "YANGは操作の定義を可能にします。操作の名前、入力パラメーター、および出力パラメーターは、YANGデータ定義ステートメントを使用してモデル化されます。モジュールの最上位の操作は、「rpc」ステートメントで定義されます。操作は、コンテナまたはリストデータノードに関連付けることもできます。このような操作は、「アクション」ステートメントで定義されます。"
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation at the top level:",
      "ja": "トップレベルでの操作のYANGの例："
    },
    {
      "indent": 5,
      "text": "rpc activate-software-image {\n  input {\n    leaf image-name {\n      type string;\n    }\n  }\n  output {\n    leaf status {\n      type string;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <activate-software-image xmlns=\"http://example.com/system\">\n    <image-name>example-fw-2.3</image-name>\n  </activate-software-image>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <status xmlns=\"http://example.com/system\">\n    The image example-fw-2.3 is being installed.\n  </status>\n</rpc-reply>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation tied to a list data node:",
      "ja": "リストデータノードに関連付けられた操作のYANGの例："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "leaf name {\n  type string;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  action ping {\n    input {\n      leaf destination {\n        type inet:ip-address;\n      }\n    }\n    output {\n      leaf packet-loss {\n        type uint8;\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n    <interface xmlns=\"http://example.com/system\">\n      <name>eth1</name>\n      <ping>\n        <destination>192.0.2.1</destination>\n      </ping>\n    </interface>\n  </action>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"102\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n           xmlns:sys=\"http://example.com/system\">\n  <sys:packet-loss>60</sys:packet-loss>\n</rpc-reply>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is covered in Section 7.14, and the \"action\" statement is covered in Section 7.15.",
      "ja": "「rpc」ステートメントはセクション7.14で説明されており、「アクション」ステートメントはセクション7.15で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.2.10. Notification Definitions",
      "section_title": true,
      "ja": "4.2.10. 通知の定義"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of notifications. YANG data definition statements are used to model the content of the notification.",
      "ja": "YANGは通知の定義を許可します。 YANGデータ定義ステートメントは、通知の内容をモデル化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "YANGの例："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  description\n    \"A link failure has been detected.\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf if-admin-status {\n    type admin-status;\n  }\n  leaf if-oper-status {\n    type oper-status;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<notification\n    xmlns=\"urn:ietf:params:netconf:capability:notification:1.0\">\n  <eventTime>2007-09-01T10:00:00Z</eventTime>\n  <link-failure xmlns=\"urn:example:system\">\n    <if-name>so-1/2/3.0</if-name>\n    <if-admin-status>up</if-admin-status>\n    <if-oper-status>down</if-oper-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is covered in Section 7.16.",
      "ja": "「通知」ステートメントについては、セクション7.16で説明しています。"
    },
    {
      "indent": 0,
      "text": "5. Language Concepts",
      "section_title": true,
      "ja": "5. 言語の概念"
    },
    {
      "indent": 0,
      "text": "5.1. Modules and Submodules",
      "section_title": true,
      "ja": "5.1. モジュールとサブモジュール"
    },
    {
      "indent": 3,
      "text": "The module is the base unit of definition in YANG. A module defines a single data model. A module can also augment an existing data model with additional nodes.",
      "ja": "モジュールは、YANGでの定義の基本単位です。モジュールは単一のデータモデルを定義します。モジュールは、追加のノードで既存のデータモデルを補強することもできます。"
    },
    {
      "indent": 3,
      "text": "Submodules are partial modules that contribute definitions to a module. A module may include any number of submodules, but each submodule may belong to only one module.",
      "ja": "サブモジュールは、モジュールに定義を提供する部分的なモジュールです。モジュールには任意の数のサブモジュールを含めることができますが、各サブモジュールは1つのモジュールにのみ属することができます。"
    },
    {
      "indent": 3,
      "text": "Developers of YANG modules and submodules are RECOMMENDED to choose names for their modules that will have a low probability of colliding with standard or other enterprise modules, e.g., by using the enterprise or organization name as a prefix for the module name. Within a server, all module names MUST be unique.",
      "ja": "YANGモジュールおよびサブモジュールの開発者は、標準または他のエンタープライズモジュールと競合する可能性が低いモジュールの名前を選択することをお勧めします。たとえば、モジュール名のプレフィックスとしてエンタープライズ名または組織名を使用します。サーバー内では、すべてのモジュール名が一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "A module uses the \"include\" statement to list all its submodules. A module, or submodule belonging to that module, can reference definitions in the module and all submodules included by the module.",
      "ja": "モジュールは「include」ステートメントを使用して、そのすべてのサブモジュールをリストします。モジュール、またはそのモジュールに属するサブモジュールは、モジュール内の定義およびモジュールに含まれるすべてのサブモジュールを参照できます。"
    },
    {
      "indent": 3,
      "text": "A module or submodule uses the \"import\" statement to reference external modules. Statements in the module or submodule can reference definitions in the external module using the prefix specified in the \"import\" statement.",
      "ja": "モジュールまたはサブモジュールは、「インポート」ステートメントを使用して外部モジュールを参照します。モジュールまたはサブモジュールのステートメントは、 \"import\"ステートメントで指定されたプレフィックスを使用して、外部モジュールの定義を参照できます。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule MAY use the \"include\" statement to reference other submodules within its module, but this is not necessary in YANG version 1.1. A submodule can reference any definition in the module it belongs to and in all submodules included by the module. A submodule MUST NOT include different revisions of other submodules than the revisions that its module includes.",
      "ja": "YANGバージョン1との下位互換性のために、サブモジュールは「include」ステートメントを使用してモジュール内の他のサブモジュールを参照できますが、これはYANGバージョン1.1では必要ありません。サブモジュールは、それが属するモジュール内の定義、およびモジュールに含まれるすべてのサブモジュール内の任意の定義を参照できます。サブモジュールには、そのモジュールに含まれているリビジョンとは異なる他のサブモジュールのリビジョンを含めてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "A module or submodule MUST NOT include submodules from other modules, and a submodule MUST NOT import its own module.",
      "ja": "モジュールまたはサブモジュールには、他のモジュールのサブモジュールを含めてはならず（MUST NOT）、サブモジュールは独自のモジュールをインポートしてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The \"import\" and \"include\" statements are used to make definitions available from other modules:",
      "ja": "\"import\"および \"include\"ステートメントは、他のモジュールから定義を利用できるようにするために使用されます。"
    },
    {
      "indent": 3,
      "text": "o For a module or submodule to reference definitions in an external module, the external module MUST be imported.",
      "ja": "o モジュールまたはサブモジュールが外部モジュールの定義を参照するには、外部モジュールをインポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o A module MUST include all its submodules.",
      "ja": "o モジュールには、そのすべてのサブモジュールを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o A module, or submodule belonging to that module, MAY reference definitions in the module and all submodules included by the module.",
      "ja": "o モジュール、またはそのモジュールに属するサブモジュールは、モジュールおよびモジュールに含まれるすべてのサブモジュール内の定義を参照できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of imports. For example, if module \"a\" imports module \"b\", \"b\" cannot import \"a\".",
      "ja": "インポートの循環チェーンがあってはなりません。たとえば、モジュール「a」がモジュール「b」をインポートする場合、「b」は「a」をインポートできません。"
    },
    {
      "indent": 3,
      "text": "When a definition in an external module is referenced, a locally defined prefix MUST be used, followed by a colon (\":\") and then the external identifier. References to definitions in the local module MAY use the prefix notation. Since built-in data types do not belong to any module and have no prefix, references to built-in data types (e.g., int32) cannot use the prefix notation. The syntax for a reference to a definition is formally defined by the rule \"identifier-ref\" in Section 14.",
      "ja": "外部モジュールの定義が参照される場合、ローカルで定義された接頭辞を使用しなければならず、その後にコロン（ \"：\"）が続き、その後に外部識別子が続きます。ローカルモジュールの定義への参照では、プレフィックス表記を使用できます。組み込みデータ型はどのモジュールにも属しておらず、プレフィックスもないため、組み込みデータ型（int32など）への参照ではプレフィックス表記を使用できません。定義への参照の構文は、セクション14のルール「identifier-ref」によって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Import and Include by Revision",
      "section_title": true,
      "ja": "5.1.1. リビジョンごとにインポートして含める"
    },
    {
      "indent": 3,
      "text": "Published modules evolve independently over time. In order to allow for this evolution, modules can be imported using specific revisions. Initially, a module imports the revisions of other modules that are current when the module is written. As future revisions of the imported modules are published, the importing module is unaffected and its contents are unchanged. When the author of the module is prepared to move to the most recently published revision of an imported module, the module is republished with an updated \"import\" statement. By republishing with the new revision, the authors explicitly indicate their acceptance of any changes in the imported module.",
      "ja": "公開されたモジュールは、時間の経過とともに独立して進化します。この進化を可能にするために、特定のリビジョンを使用してモジュールをインポートできます。最初に、モジュールは、モジュールの作成時に最新である他のモジュールのリビジョンをインポートします。インポートされたモジュールの将来の改訂版が公​​開されるため、インポートモジュールは影響を受けず、その内容は変更されません。モジュールの作成者が、インポートされたモジュールの最新の発行済みリビジョンに移動する準備ができると、モジュールは更新された「インポート」ステートメントで再発行されます。新しいリビジョンで再公開することにより、作成者は、インポートされたモジュールの変更の受け入れを明示的に示します。"
    },
    {
      "indent": 3,
      "text": "For submodules, the issue is related but simpler. A module or submodule that includes submodules may specify the revision of the included submodules. If a submodule changes, any module or submodule that includes it by revision needs to be updated to reference the new revision.",
      "ja": "サブモジュールの場合、問題は関連していますがより単純です。サブモジュールを含むモジュールまたはサブモジュールは、含まれるサブモジュールのリビジョンを指定できます。サブモジュールが変更された場合、リビジョンごとにそれを含むモジュールまたはサブモジュールは、新しいリビジョンを参照するように更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, module \"b\" imports module \"a\".",
      "ja": "たとえば、モジュール「b」はモジュール「a」をインポートします。"
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  revision 2008-01-01 { ... }\n  grouping a {\n    leaf eh { .... }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import a {\n  prefix \"p\";\n  revision-date 2008-01-01;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container bee {\n    uses p:a;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the author of \"a\" publishes a new revision, the changes may not be acceptable to the author of \"b\". If the new revision is acceptable, the author of \"b\" can republish with an updated revision in the \"import\" statement.",
      "ja": "「a」の作成者が新しいリビジョンを公開すると、「b」の作成者は変更を受け入れられない場合があります。新しいリビジョンが受け入れられる場合、「b」の作成者は「import」ステートメントの更新されたリビジョンで再発行できます。"
    },
    {
      "indent": 3,
      "text": "If a module is not imported with a specific revision, it is undefined which revision is used.",
      "ja": "モジュールが特定のリビジョンでインポートされない場合、どのリビジョンが使用されるかは未定義です。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Module Hierarchies",
      "section_title": true,
      "ja": "5.1.2. モジュール階層"
    },
    {
      "indent": 3,
      "text": "YANG allows modeling of data in multiple hierarchies, where data may have more than one top-level node. Each top-level data node in a module defines a separate hierarchy. Models that have multiple top-level nodes are sometimes convenient and are supported by YANG.",
      "ja": "YANGを使用すると、データに複数の最上位ノードが存在する可能性がある複数の階層のデータをモデル化できます。モジュールの各最上位データノードは、個別の階層を定義します。複数の最上位ノードを持つモデルは便利な場合があり、YANGでサポートされています。"
    },
    {
      "indent": 0,
      "text": "5.1.2.1. NETCONF XML Encoding",
      "section_title": true,
      "ja": "5.1.2.1. NETCONF XMLエンコーディング"
    },
    {
      "indent": 3,
      "text": "NETCONF is capable of carrying any XML content as the payload in the <config> and <data> elements. The top-level nodes of YANG modules are encoded as child elements, in any order, within these elements. This encapsulation guarantees that the corresponding NETCONF messages are always well-formed XML documents.",
      "ja": "NETCONFは、任意のXMLコンテンツを<config>および<data>要素のペイロードとして運ぶことができます。 YANGモジュールの最上位ノードは、これらの要素内の子要素として、任意の順序でエンコードされます。このカプセル化により、対応するNETCONFメッセージが常に整形式のXMLドキュメントであることが保証されます。"
    },
    {
      "indent": 3,
      "text": "For example, an instance of:",
      "ja": "たとえば、次のインスタンス："
    },
    {
      "indent": 5,
      "text": "module example-config {\n  yang-version 1.1;\n  namespace \"urn:example:config\";\n  prefix \"co\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container system { ... }\n  container routing { ... }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "could be encoded in NETCONF as:",
      "ja": "NETCONFで次のようにエンコードできます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <!-- system data here -->\n      </system>\n      <routing xmlns=\"urn:example:config\">\n        <!-- routing data here -->\n      </routing>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2. File Layout",
      "section_title": true,
      "ja": "5.2. ファイルのレイアウト"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are typically stored in files, one \"module\" or \"submodule\" statement per file. The name of the file SHOULD be of the form:",
      "ja": "YANGモジュールとサブモジュールは通常、ファイルに1つの「モジュール」または「サブモジュール」ステートメントで保存されます。ファイルの名前は次の形式である必要があります。"
    },
    {
      "indent": 5,
      "text": "module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )",
      "ja": "module-or-submodule-name ['@' revision-date]（ '.yang' / '.yin'）"
    },
    {
      "indent": 3,
      "text": "\"module-or-submodule-name\" is the name of the module or submodule, and the optional \"revision-date\" is the latest revision of the module or submodule, as defined by the \"revision\" statement (Section 7.1.9).",
      "ja": "\"module-or-submodule-name\"はモジュールまたはサブモジュールの名前で、オプションの \"revision-date\"は \"revision\"ステートメントで定義されているモジュールまたはサブモジュールの最新リビジョンです（セクション7.1.9）。 。"
    },
    {
      "indent": 3,
      "text": "The file extension \".yang\" denotes that the contents of the file are written with YANG syntax (Section 6), and \".yin\" denotes that the contents of the file are written with YIN syntax (Section 13).",
      "ja": "ファイル拡張子 \".yang\"は、ファイルの内容がYANG構文（セクション6）で記述されていることを示し、 \"。yin\"は、ファイルの内容がYIN構文（セクション13）で記述されていることを示します。"
    },
    {
      "indent": 3,
      "text": "YANG parsers can find imported modules and included submodules via this convention.",
      "ja": "YANGパーサーは、この規則を使用して、インポートされたモジュールと含まれているサブモジュールを見つけることができます。"
    },
    {
      "indent": 0,
      "text": "5.3. XML Namespaces",
      "section_title": true,
      "ja": "5.3. XML名前空間"
    },
    {
      "indent": 3,
      "text": "All YANG definitions are specified within a module. Each module is bound to a distinct XML namespace [XML-NAMES], which is a globally unique URI [RFC3986]. A NETCONF client or server uses the namespace during XML encoding of data.",
      "ja": "すべてのYANG定義はモジュール内で指定されます。各モジュールは、グローバルに一意のURI [RFC3986]である個別のXML名前空間[XML-NAMES]にバインドされています。 NETCONFクライアントまたはサーバーは、データのXMLエンコーディング中にネームスペースを使用します。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリーム[RFC4844]で公開されているモジュールのXML名前空間は、IANAによって割り当てられる必要があります。 [RFC6020]のセクション14をご覧ください。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for private modules are assigned by the organization owning the module without a central registry. Namespace URIs MUST be chosen so they cannot collide with standard or other enterprise namespaces -- for example, by using the enterprise or organization name in the namespace.",
      "ja": "プライベートモジュールのXML名前空間は、中央レジストリのないモジュールを所有する組織によって割り当てられます。ネームスペースURIは、標準または他のエンタープライズネームスペースと衝突しないように選択する必要があります（たとえば、ネームスペースでエンタープライズ名または組織名を使用するなど）。"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement is covered in Section 7.1.3.",
      "ja": "「名前空間」ステートメントについては、セクション7.1.3で説明しています。"
    },
    {
      "indent": 0,
      "text": "5.3.1. YANG XML Namespace",
      "section_title": true,
      "ja": "5.3.1. XML名前空間"
    },
    {
      "indent": 3,
      "text": "YANG defines an XML namespace for NETCONF <edit-config> operations, <error-info> content, and the <action> element. The name of this namespace is \"urn:ietf:params:xml:ns:yang:1\".",
      "ja": "YANGは、NETCONF <edit-config>操作、<error-info>コンテンツ、および<action>要素のXML名前空間を定義します。この名前空間の名前は「urn：ietf：params：xml：ns：yang：1」です。"
    },
    {
      "indent": 0,
      "text": "5.4. Resolving Grouping, Type, and Identity Names",
      "section_title": true,
      "ja": "5.4. グループ化、タイプ、およびID名の解決"
    },
    {
      "indent": 3,
      "text": "Grouping, type, and identity names are resolved in the context in which they are defined, rather than the context in which they are used. Users of groupings, typedefs, and identities are not required to import modules or include submodules to satisfy all references made by the original definition. This behaves like static scoping in a conventional programming language.",
      "ja": "グループ化、タイプ、およびID名は、それらが使用されるコンテキストではなく、それらが定義されているコンテキストで解決されます。グループ、typedef、およびIDのユーザーは、元の定義によって行われたすべての参照を満たすために、モジュールをインポートしたり、サブモジュールを組み込んだりする必要はありません。これは、従来のプログラミング言語での静的スコープのように動作します。"
    },
    {
      "indent": 3,
      "text": "For example, if a module defines a grouping in which a type is referenced, when the grouping is used in a second module, the type is resolved in the context of the original module, not the second module. There is no ambiguity if both modules define the type.",
      "ja": "たとえば、モジュールが型を参照するグループを定義している場合、そのグループが2番目のモジュールで使用されると、型は2番目のモジュールではなく、元のモジュールのコンテキストで解決されます。両方のモジュールがタイプを定義する場合、あいまいさはありません。"
    },
    {
      "indent": 0,
      "text": "5.5. Nested Typedefs and Groupings",
      "section_title": true,
      "ja": "5.5. ネストされたTypedefとグループ化"
    },
    {
      "indent": 3,
      "text": "Typedefs and groupings may appear nested under many YANG statements, allowing these to be lexically scoped by the statement hierarchy under which they appear. This allows types and groupings to be defined near where they are used, rather than placing them at the top level of the hierarchy. The close proximity increases readability.",
      "ja": "Typedefとグループ化は、多くのYANGステートメントの下にネストされて表示され、それらが表示されるステートメント階層によってレキシカルにスコープを設定できるようにします。これにより、タイプおよびグループ化を、階層の最上位に配置するのではなく、使用される場所の近くに定義できます。近接することで読みやすさが向上します。"
    },
    {
      "indent": 3,
      "text": "Scoping also allows types to be defined without concern for naming conflicts between types in different submodules. Type names can be specified without adding leading strings designed to prevent name collisions within large modules.",
      "ja": "スコープ設定により、異なるサブモジュール内のタイプ間の名前の競合を気にすることなく、タイプを定義することもできます。大きなモジュール内での名前の衝突を防ぐように設計された先行文字列を追加せずにタイプ名を指定できます。"
    },
    {
      "indent": 3,
      "text": "Finally, scoping allows the module author to keep types and groupings private to their module or submodule, preventing their reuse. Since only top-level types and groupings (i.e., those appearing as substatements to a \"module\" or \"submodule\" statement) can be used outside the module or submodule, the developer has more control over what pieces of their module are presented to the outside world, supporting the need to hide internal information and maintaining a boundary between what is shared with the outside world and what is kept private.",
      "ja": "最後に、スコーピングにより、モジュールの作成者はタイプやグループをモジュールまたはサブモジュールに対してプライベートに保ち、再利用を防ぐことができます。トップレベルのタイプとグループ（つまり、「モジュール」または「サブモジュール」ステートメントのサブステートメントとして表示されるもの）のみがモジュールまたはサブモジュールの外部で使用できるため、開発者はモジュールのどの部分を外部の世界、内部の情報を隠す必要性をサポートし、外部の世界と共有されるものと非公開にされるものの間の境界を維持する。"
    },
    {
      "indent": 3,
      "text": "Scoped definitions MUST NOT shadow definitions at a higher scope. A type or grouping cannot be defined if a higher level in the statement hierarchy has a definition with a matching identifier.",
      "ja": "スコープ定義は、より高いスコープで定義をシャドウすることはできません。ステートメント階層の上位レベルに一致するIDの定義がある場合、タイプまたはグループ化は定義できません。"
    },
    {
      "indent": 3,
      "text": "A reference to an unprefixed type or grouping, or one that uses the prefix of the current module, is resolved by locating the matching \"typedef\" or \"grouping\" statement among the immediate substatements of each ancestor statement.",
      "ja": "接頭辞のない型またはグループ化、または現在のモジュールの接頭辞を使用するものへの参照は、各祖先ステートメントの直接のサブステートメントの中で一致する「typedef」または「グループ化」ステートメントを見つけることによって解決されます。"
    },
    {
      "indent": 0,
      "text": "5.6. Conformance",
      "section_title": true,
      "ja": "5.6. 適合"
    },
    {
      "indent": 3,
      "text": "Conformance to a model is a measure of how accurately a server follows the model. Generally speaking, servers are responsible for implementing the model faithfully, allowing applications to treat servers that implement the model identically. Deviations from the model can reduce the utility of the model and increase the fragility of applications that use it.",
      "ja": "モデルへの適合性は、サーバーがモデルにどれだけ正確に従うかを示す尺度です。一般的に言って、サーバーはモデルを忠実に実装する責任があり、アプリケーションはモデルを実装するサーバーを同様に扱うことができます。モデルからの逸脱は、モデルの有用性を低下させ、それを使用するアプリケーションの脆弱性を増大させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "YANG modelers have three mechanisms for conformance:",
      "ja": "YANGモデラーには、3つの適合メカニズムがあります。"
    },
    {
      "indent": 3,
      "text": "o the basic behavior of the model",
      "ja": "o モデルの基本的な動作"
    },
    {
      "indent": 3,
      "text": "o optional features that are part of the model",
      "ja": "o モデルの一部であるオプション機能"
    },
    {
      "indent": 3,
      "text": "o deviations from the model",
      "ja": "o モデルからの逸脱"
    },
    {
      "indent": 3,
      "text": "We will consider each of these in sequence.",
      "ja": "これらのそれぞれを順番に検討します。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Basic Behavior",
      "section_title": true,
      "ja": "5.6.1. 基本的な行動"
    },
    {
      "indent": 3,
      "text": "The model defines a contract between a YANG-based client and server; this contract allows both parties to have faith that the other knows the syntax and semantics behind the modeled data. The strength of YANG lies in the strength of this contract.",
      "ja": "モデルは、YANGベースのクライアントとサーバー間の契約を定義します。この契約により、両当事者は、モデル化されたデータの背後にある構文とセマンティクスを他方が知っているという信頼を持つことができます。 YANGの強みは、この契約の強さにあります。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Optional Features",
      "section_title": true,
      "ja": "5.6.2. オプション機能"
    },
    {
      "indent": 3,
      "text": "In many models, the modeler will allow sections of the model to be conditional. The server controls whether these conditional portions of the model are supported or valid for that particular server.",
      "ja": "多くのモデルでは、モデラーはモデルのセクションを条件付きにすることができます。サーバーは、モデルのこれらの条件付き部分がサポートされているか、その特定のサーバーで有効であるかを制御します。"
    },
    {
      "indent": 3,
      "text": "For example, a syslog data model may choose to include the ability to save logs locally, but the modeler will realize that this is only possible if the server has local storage. If there is no local storage, an application should not tell the server to save logs.",
      "ja": "たとえば、syslogデータモデルはログをローカルに保存する機能を含めることを選択できますが、モデラーはこれがサーバーにローカルストレージがある場合にのみ可能であることを理解します。ローカルストレージがない場合、アプリケーションはログを保存するようサーバーに指示するべきではありません。"
    },
    {
      "indent": 3,
      "text": "YANG supports this conditional mechanism using a construct called \"feature\". Features give the modeler a mechanism for making portions of the module conditional in a manner that is controlled by the server. The model can express constructs that are not universally present in all servers. These features are included in the model definition, allowing a consistent view and allowing applications to learn which features are supported and tailor their behavior to the server.",
      "ja": "YANGは、「機能」と呼ばれる構造を使用して、この条件付きメカニズムをサポートしています。機能は、サーバーによって制御される方法でモジュールの一部を条件付きにするためのメカニズムをモデラーに提供します。モデルは、すべてのサーバーに普遍的に存在するわけではない構成を表現できます。これらの機能はモデル定義に含まれているため、一貫したビューが可能になり、アプリケーションはサポートされている機能を学習して、サーバーに合わせて動作を調整できます。"
    },
    {
      "indent": 3,
      "text": "A module may declare any number of features, identified by simple strings, and may make portions of the module optional based on those features. If the server supports a feature, then the corresponding portions of the module are valid for that server. If the server doesn't support the feature, those parts of the module are not valid, and applications should behave accordingly.",
      "ja": "モジュールは、単純な文字列で識別される任意の数の機能を宣言し、それらの機能に基づいてモジュールの一部をオプションにすることができます。サーバーが機能をサポートしている場合、モジュールの対応する部分はそのサーバーに対して有効です。サーバーが機能をサポートしていない場合、モジュールのそれらの部分は無効であり、アプリケーションはそれに応じて動作するはずです。"
    },
    {
      "indent": 3,
      "text": "Features are defined using the \"feature\" statement. Definitions in the module that are conditional to the feature are noted by the \"if-feature\" statement.",
      "ja": "機能は「feature」ステートメントを使用して定義されます。機能を条件とするモジュール内の定義は、「if-feature」ステートメントで示されます。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.1.",
      "ja": "詳細については、セクション7.20.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Deviations",
      "section_title": true,
      "ja": "5.6.3. 偏差"
    },
    {
      "indent": 3,
      "text": "In an ideal world, all servers would be required to implement the model exactly as defined, and deviations from the model would not be allowed. But in the real world, servers are often not able or designed to implement the model as written. For YANG-based automation to deal with these server deviations, a mechanism must exist for servers to inform applications of the specifics of such deviations.",
      "ja": "理想的な世界では、すべてのサーバーが定義どおりにモデルを実装する必要があり、モデルからの逸脱は許可されません。しかし、現実の世界では、サーバーは、記述されたモデルを実装することができないか、設計されていないことがよくあります。 YANGベースの自動化がこれらのサーバーの逸脱に対処するには、サーバーがそのような逸脱の詳細をアプリケーションに通知するメカニズムが必要です。"
    },
    {
      "indent": 3,
      "text": "For example, a BGP module may allow any number of BGP peers, but a particular server may only support 16 BGP peers. Any application configuring the 17th peer will receive an error. While an error may suffice to let the application know it cannot add another peer, it would be far better if the application had prior knowledge of this limitation and could prevent the user from starting down the path that could not succeed.",
      "ja": "たとえば、BGPモジュールは任意の数のBGPピアを許可しますが、特定のサーバーは16のBGPピアしかサポートしない場合があります。 17番目のピアを構成するアプリケーションはエラーを受け取ります。エラーでアプリケーションに別のピアを追加できないことを通知するのに十分な場合がありますが、アプリケーションがこの制限を事前に認識していて、ユーザーが成功しなかったパスを開始できない場合は、はるかに良いでしょう。"
    },
    {
      "indent": 3,
      "text": "Server deviations are declared using the \"deviation\" statement, which takes as its argument a string that identifies a node in the schema tree. The contents of the statement detail the manner in which the server implementation deviates from the contract as defined in the module.",
      "ja": "サーバーの偏差は、スキーマツリー内のノードを識別する文字列を引数として取る「偏差」ステートメントを使用して宣言されます。ステートメントの内容は、サーバー実装がモジュールで定義されているコントラクトから逸脱する方法を詳しく説明しています。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.3.",
      "ja": "詳細については、セクション7.20.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6.4. Announcing Conformance Information in NETCONF",
      "section_title": true,
      "ja": "5.6.4. NETCONFでの適合性情報の発表"
    },
    {
      "indent": 3,
      "text": "This document defines the following mechanism for announcing conformance information. Other mechanisms may be defined by future specifications.",
      "ja": "このドキュメントでは、適合情報を発表するための次のメカニズムを定義しています。その他のメカニズムは、将来の仕様で定義される可能性があります。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server MUST announce the modules it implements (see Section 5.6.5) by implementing the YANG module \"ietf-yang-library\" defined in [RFC7895] and listing all implemented modules in the \"/modules-state/module\" list.",
      "ja": "NETCONFサーバーは、[RFC7895]で定義されているYANGモジュール「ietf-yang-library」を実装し、実装されているすべてのモジュールを「/ modules-state / module」リストにリストすることで、実装するモジュール（セクション5.6.5を参照）を通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server also MUST advertise the following capability in the <hello> message (line breaks and whitespaces are used for formatting reasons only):",
      "ja": "サーバーは、<hello>メッセージで次の機能もアドバタイズする必要があります（改行と空白はフォーマット上の理由でのみ使用されます）。"
    },
    {
      "indent": 5,
      "text": "urn:ietf:params:netconf:capability:yang-library:1.0?\n  revision=<date>&module-set-id=<id>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parameter \"revision\" has the same value as the revision date of the \"ietf-yang-library\" module implemented by the server. This parameter MUST be present.",
      "ja": "パラメータ「revision」は、サーバーによって実装された「ietf-yang-library」モジュールの改訂日と同じ値を持っています。このパラメーターは存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameter \"module-set-id\" has the same value as the leaf \"/modules-state/module-set-id\" from \"ietf-yang-library\". This parameter MUST be present.",
      "ja": "パラメータ「module-set-id」は、「ietf-yang-library」のリーフ「/ modules-state / module-set-id」と同じ値です。このパラメーターは存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "With this mechanism, a client can cache the supported modules for a server and only update the cache if the \"module-set-id\" value in the <hello> message changes.",
      "ja": "このメカニズムにより、クライアントはサーバーでサポートされているモジュールをキャッシュして、<hello>メッセージの「module-set-id」値が変更された場合にのみキャッシュを更新できます。"
    },
    {
      "indent": 0,
      "text": "5.6.5. Implementing a Module",
      "section_title": true,
      "ja": "5.6.5. モジュールの実装"
    },
    {
      "indent": 3,
      "text": "A server implements a module if it implements the module's data nodes, RPCs, actions, notifications, and deviations.",
      "ja": "サーバーは、モジュールのデータノード、RPC、アクション、通知、および偏差を実装する場合、モジュールを実装します。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT implement more than one revision of a module.",
      "ja": "サーバーは、モジュールの複数のリビジョンを実装してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module B, and A uses any node from B in an \"augment\" or \"path\" statement that the server supports, then the server MUST implement a revision of module B that has these nodes defined. This is regardless of whether module B is imported by revision or not.",
      "ja": "サーバーがモジュールBをインポートするモジュールAを実装し、Aがサーバーがサポートする「拡張」または「パス」ステートメントでBのノードを使用する場合、サーバーはこれらのノードが定義されているモジュールBのリビジョンを実装する必要があります。 。これは、モジュールBがリビジョンによってインポートされるかどうかに関係ありません。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module C without specifying the revision date of module C and the server does not implement C (e.g., if C only defines some typedefs), the server MUST list module C in the \"/modules-state/module\" list from \"ietf-yang-library\" [RFC7895], and it MUST set the leaf \"conformance-type\" to \"import\" for this module.",
      "ja": "サーバーがモジュールCのリビジョン日付を指定せずにモジュールCをインポートするモジュールAを実装し、サーバーがCを実装しない場合（たとえば、Cが一部のtypedefのみを定義する場合）、サーバーはモジュールCを「/ modules- 「ietf-yang-library」[RFC7895]の「状態/モジュール」リスト。このモジュールのリーフ「適合タイプ」を「インポート」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server lists a module C in the \"/modules-state/module\" list from \"ietf-yang-library\" and there are other modules Ms listed that import C without specifying the revision date of module C, the server MUST use the definitions from the most recent revision of C listed for modules Ms.",
      "ja": "サーバーが「ietf-yang-library」の「/ modules-state / module」リストにモジュールCをリストし、モジュールCの改訂日を指定せずにCをインポートする他のモジュールMがリストされている場合、サーバーはモジュールMsにリストされているCの最新リビジョンの定義。"
    },
    {
      "indent": 3,
      "text": "The reason for these rules is that clients need to be able to know the specific data model structure and types of all leafs and leaf-lists implemented in a server.",
      "ja": "これらのルールの理由は、クライアントが、サーバーに実装されているすべてのリーフとリーフリストの特定のデータモデル構造とタイプを認識できる必要があるためです。"
    },
    {
      "indent": 3,
      "text": "For example, with these modules:",
      "ja": "たとえば、次のモジュールの場合："
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import b {\n  revision-date 2015-01-01;\n}\nimport c;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "ja": "改訂2015-01-01;"
    },
    {
      "indent": 7,
      "text": "feature foo;",
      "ja": "機能foo;"
    },
    {
      "indent": 7,
      "text": "augment \"/b:x\" {\n  if-feature foo;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "  leaf y {\n    type b:myenum;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "       container a {\n         leaf x {\n           type c:bar;\n         }\n       }\n     }\n     module b {\n       yang-version 1.1;\n       namespace \"urn:example:b\";\n       prefix \"b\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "ja": "改訂2015-01-01;"
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container x {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2015-04-04;\nrevision 2015-01-01;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero; // added in 2015-01-01\n    enum one;  // added in 2015-04-04\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container x {  // added in 2015-01-01\n    container y; // added in 2015-04-04\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "module c {\n  yang-version 1.1;\n  namespace \"urn:example:c\";\n  prefix \"c\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2015-02-02;",
      "ja": "改訂2015-02-02;"
    },
    {
      "indent": 0,
      "text": "       typedef bar {\n         ...\n       }\n     }\n     module c {\n       yang-version 1.1;\n       namespace \"urn:example:c\";\n       prefix \"c\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "revision 2015-03-03;\nrevision 2015-02-02;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  typedef bar {\n    ...\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" and supports feature \"foo\" can implement revision \"2015-01-01\" or \"2015-04-04\" of module \"b\". Since \"b\" was imported by revision, the type of leaf \"/b:x/a:y\" is the same, regardless of which revision of \"b\" the server implements.",
      "ja": "モジュール「a」のリビジョン「2015-01-01」を実装し、機能「foo」をサポートするサーバーは、モジュール「b」のリビジョン「2015-01-01」または「2015-04-04」を実装できます。 「b」はリビジョンによってインポートされたため、サーバーが実装する「b」のリビジョンに関係なく、リーフ「/ b：x / a：y」のタイプは同じです。"
    },
    {
      "indent": 3,
      "text": "A server that implements module \"a\" but does not support feature \"foo\" does not have to implement module \"b\".",
      "ja": "モジュール「a」を実装しているが、機能「foo」をサポートしていないサーバーは、モジュール「b」を実装する必要はありません。"
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" picks any revision of module \"c\" and lists it in the \"/modules-state/module\" list from \"ietf-yang-library\".",
      "ja": "モジュール「a」のリビジョン「2015-01-01」を実装するサーバーは、モジュール「c」のリビジョンを選択し、「ietf-yang-library」の「/ modules-state / module」リストにリストします。"
    },
    {
      "indent": 3,
      "text": "The following XML encoding example shows valid data for the \"/modules-state/module\" list for a server that implements module \"a\":",
      "ja": "次のXMLエンコードの例は、モジュール「a」を実装するサーバーの「/ modules-state / module」リストの有効なデータを示しています。"
    },
    {
      "indent": 5,
      "text": "<modules-state\n    xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-library\">\n  <module-set-id>ee1ecb017370cafd</module-set-id>\n  <module>\n    <name>a</name>\n    <revision>2015-01-01</revision>\n    <namespace>urn:example:a</namespace>\n    <feature>foo</feature>\n    <conformance-type>implement</conformance-type>\n  </module>\n  <module>\n    <name>b</name>\n    <revision>2015-04-04</revision>\n    <namespace>urn:example:b</namespace>\n    <conformance-type>implement</conformance-type>\n  </module>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  <module>\n    <name>c</name>\n    <revision>2015-02-02</revision>\n    <namespace>urn:example:c</namespace>\n    <conformance-type>import</conformance-type>\n  </module>\n</modules-state>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.7. Datastore Modification",
      "section_title": true,
      "ja": "5.7. データストアの変更"
    },
    {
      "indent": 3,
      "text": "Data models may allow the server to alter the configuration datastore in ways not explicitly directed via network management protocol messages. For example, a data model may define leafs that are assigned system-generated values when the client does not provide one. A formal mechanism for specifying the circumstances where these changes are allowed is out of scope for this specification.",
      "ja": "データモデルにより、サーバーはネットワーク管理プロトコルメッセージを介して明示的に指示されない方法で構成データストアを変更できます。たとえば、データモデルは、クライアントが提供しないときにシステム生成値が割り当てられるリーフを定義する場合があります。これらの変更が許可される状況を指定する正式なメカニズムは、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. YANG Syntax",
      "section_title": true,
      "ja": "6. YANG構文"
    },
    {
      "indent": 3,
      "text": "The YANG syntax is similar to that of SMIng [RFC3780] and programming languages like C and C++. This C-like syntax was chosen specifically for its readability, since YANG values the time and effort of the readers of models above those of modules writers and YANG tool-chain developers. This section introduces the YANG syntax.",
      "ja": "YANGの構文は、SMIng [RFC3780]や、CやC ++などのプログラミング言語の構文に似ています。このCのような構文は、YANGがモジュールライターおよびYANGツールチェーン開発者よりもモデルのリーダーの時間と労力を重視しているため、特にその可読性のために選択されました。このセクションでは、YANG構文を紹介します。"
    },
    {
      "indent": 3,
      "text": "Legal characters in YANG modules are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The character syntax is formally defined by the rule \"yang-char\" in Section 14.",
      "ja": "YANGモジュールの有効な文字は、UnicodeおよびISO / IEC 10646 [ISO.10646]文字で、タブ、キャリッジリターン、ラインフィードが含まれますが、他のC0制御文字、サロゲートブロック、および非文字は含まれません。文字構文は、セクション14のルール「yang-char」によって正式に定義されています。"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are stored in files using the UTF-8 [RFC3629] character encoding.",
      "ja": "YANGモジュールとサブモジュールは、UTF-8 [RFC3629]文字エンコーディングを使用してファイルに保存されます。"
    },
    {
      "indent": 3,
      "text": "Lines in a YANG module end with a carriage return-line feed combination or with a line feed alone. A carriage return that is not followed by a line feed may only appear inside a quoted string (Section 6.1.3). Note that carriage returns and line feeds that appear inside quoted strings become part of the value of the string without modification; the value of a multi-line quoted string contains the same form of line ends as those lines of the YANG module.",
      "ja": "YANGモジュールの行は、キャリッジリターンとラインフィードの組み合わせ、またはラインフィードのみで終了します。改行が続かないキャリッジリターンは、引用符で囲まれた文字列（セクション6.1.3）内にのみ表示できます。引用符で囲まれた文字列内に表示される改行と改行は、変更されずに文字列の値の一部になることに注意してください。複数行の引用符付き文字列の値には、YANGモジュールの行と同じ形式の行末が含まれます。"
    },
    {
      "indent": 0,
      "text": "6.1. Lexical Tokenization",
      "section_title": true,
      "ja": "6.1. 字句トークン化"
    },
    {
      "indent": 3,
      "text": "YANG modules are parsed as a series of tokens. This section details the rules for recognizing tokens from an input stream. YANG tokenization rules are both simple and powerful. The simplicity is driven by a need to keep the parsers easy to implement, while the power is driven by the fact that modelers need to express their models in readable formats.",
      "ja": "YANGモジュールは一連のトークンとして解析されます。このセクションでは、入力ストリームからトークンを認識するためのルールについて詳しく説明します。 YANGトークン化ルールはシンプルかつ強力です。シンプルさは、パーサーを簡単に実装できるようにする必要があるために推進されますが、モデラーは、モデルを読み取り可能な形式で表現する必要があるという事実によって推進されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Comments",
      "section_title": true,
      "ja": "6.1.1. コメント"
    },
    {
      "indent": 3,
      "text": "Comments are C++ style. A single line comment starts with \"//\" and ends at the end of the line. A block comment starts with \"/*\" and ends with the nearest following \"*/\".",
      "ja": "コメントはC ++スタイルです。単一行のコメントは「//」で始まり、行の終わりで終わります。ブロックコメントは「/ *」で始まり、最も近い後続の「* /」で終わります。"
    },
    {
      "indent": 3,
      "text": "Note that inside a quoted string (Section 6.1.3), these character pairs are never interpreted as the start or end of a comment.",
      "ja": "引用符で囲まれた文字列（セクション6.1.3）内では、これらの文字ペアがコメントの開始または終了として解釈されることはありません。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Tokens",
      "section_title": true,
      "ja": "6.1.2. トークン"
    },
    {
      "indent": 3,
      "text": "A token in YANG is either a keyword, a string, a semicolon (\";\"), or braces (\"{\" or \"}\"). A string can be quoted or unquoted. A keyword is either one of the YANG keywords defined in this document, or a prefix identifier, followed by a colon (\":\"), followed by a language extension keyword. Keywords are case sensitive. See Section 6.2 for a formal definition of identifiers.",
      "ja": "YANGのトークンは、キーワード、文字列、セミコロン（ \";\"）、または中括弧（ \"{\"または \"}\"）のいずれかです。文字列は引用符で囲んだり、引用符で囲んだりできます。キーワードは、このドキュメントで定義されているYANGキーワードのいずれか、または接頭辞識別子の後にコロン（ \"：\"）が続き、その後に言語拡張キーワードが続きます。キーワードでは大文字と小文字が区別されます。識別子の正式な定義については、セクション6.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Quoting",
      "section_title": true,
      "ja": "6.1.3. 引用"
    },
    {
      "indent": 3,
      "text": "An unquoted string is any sequence of characters that does not contain any space, tab, carriage return, or line feed characters, a single or double quote character, a semicolon (\";\"), braces (\"{\" or \"}\"), or comment sequences (\"//\", \"/*\", or \"*/\").",
      "ja": "引用符で囲まれていない文字列は、スペース、タブ、キャリッジリターン、またはラインフィード文字、一重引用符または二重引用符、セミコロン（ \";\"）、中かっこ（ \"{\"または \"}\"）を含まない文字のシーケンスです。 、またはコメントシーケンス（ \"//\"、 \"/ *\"、または \"* /\"）。"
    },
    {
      "indent": 3,
      "text": "Note that any keyword can legally appear as an unquoted string.",
      "ja": "すべてのキーワードは、引用符で囲まれていない文字列として合法的に表示できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Within an unquoted string, every character is preserved. Note that this means that the backslash character does not have any special meaning in an unquoted string.",
      "ja": "引用符で囲まれていない文字列内では、すべての文字が保持されます。これは、引用符で囲まれていない文字列では円記号が特別な意味を持たないことを意味します。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains a line break followed by space or tab characters that are used to indent the text according to the layout in the YANG file, this leading whitespace is stripped from the string, up to and including the column of the starting double quote character, or to the first non-whitespace character, whichever occurs first. Any tab character in a succeeding line that must be examined for stripping is first converted into 8 space characters.",
      "ja": "二重引用符で囲まれた文字列に、YANGファイルのレイアウトに従ってテキストをインデントするために使用される改行とそれに続くスペースまたはタブ文字が含まれている場合、この先頭の空白は、文字列から先頭の列まで削除されます二重引用符文字、または最初の空白以外の最初の文字のいずれか。ストリッピングを検査する必要がある次の行のタブ文字は、最初に8つのスペース文字に変換されます。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains space or tab characters before a line break, this trailing whitespace is stripped from the string.",
      "ja": "二重引用符で囲まれた文字列に改行の前にスペースまたはタブ文字が含まれている場合、この末尾の空白は文字列から削除されます。"
    },
    {
      "indent": 3,
      "text": "A single-quoted string (enclosed within ' ') preserves each character within the quotes. A single quote character cannot occur in a single-quoted string, even when preceded by a backslash.",
      "ja": "単一引用符で囲まれた文字列（ ''で囲まれている）は、引用符内の各文字を保持します。単一引用符は、バックスラッシュが前に付いている場合でも、単一引用符付き文字列では使用できません。"
    },
    {
      "indent": 3,
      "text": "Within a double-quoted string (enclosed within \" \"), a backslash character introduces a representation of a special character, which depends on the character that immediately follows the backslash:",
      "ja": "二重引用符で囲まれた文字列（ \"\"で囲まれている）内では、バックスラッシュ文字が特殊文字の表現を導入します。これは、バックスラッシュの直後の文字に依存します。"
    },
    {
      "indent": 4,
      "text": "\\n newline \\t a tab character \\\" a double quote \\\\ a single backslash",
      "ja": "\\ n改行\\ tタブ文字\\ \"二重引用符\\\\単一のバックスラッシュ"
    },
    {
      "indent": 3,
      "text": "The backslash MUST NOT be followed by any other character.",
      "ja": "バックスラッシュの後には他の文字を続けてはいけません。"
    },
    {
      "indent": 3,
      "text": "If a quoted string is followed by a plus character (\"+\"), followed by another quoted string, the two strings are concatenated into one string, allowing multiple concatenations to build one string. Whitespace, line breaks, and comments are allowed between the quoted strings and the plus character.",
      "ja": "引用符付き文字列の後にプラス文字（ \"+\"）が続き、別の引用符付き文字列が続く場合、2つの文字列は1つの文字列に連結され、複数の連結で1つの文字列を作成できます。引用符で囲まれた文字列とプラス記号の間には、空白、改行、コメントを入れることができます。"
    },
    {
      "indent": 3,
      "text": "In double-quoted strings, whitespace trimming is done before substitution of backslash-escaped characters. Concatenation is performed as the last step.",
      "ja": "二重引用符で囲まれた文字列では、バックスラッシュでエスケープされた文字を置き換える前に、空白のトリミングが行われます。最後のステップとして連結が実行されます。"
    },
    {
      "indent": 0,
      "text": "6.1.3.1. Quoting Examples",
      "section_title": true,
      "ja": "6.1.3.1. 引用例"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "ja": "次の文字列は同等です。"
    },
    {
      "indent": 5,
      "text": "hello \"hello\" 'hello' \"hel\" + \"lo\" 'hel' + \"lo\"",
      "ja": "hello \"hello\" 'hello' \"hell\" + \"lo\" 'hel' + \"lo\""
    },
    {
      "indent": 3,
      "text": "The following examples show some special strings:",
      "ja": "次の例は、いくつかの特別な文字列を示しています。"
    },
    {
      "indent": 5,
      "text": "\"\\\"\" - string containing a double quote '\"' - string containing a double quote \"\\n\" - string containing a newline character '\\n' - string containing a backslash followed by the character n",
      "ja": "\"\\\" \"-二重引用符を含む文字列 '\"'-二重引用符を含む文字列 \"\\ n\"-改行文字を含む文字列 '\\ n'-バックスラッシュとそれに続く文字nを含む文字列"
    },
    {
      "indent": 3,
      "text": "The following examples show some illegal strings:",
      "ja": "次の例は、いくつかの不正な文字列を示しています。"
    },
    {
      "indent": 5,
      "text": "'''' - a single-quoted string cannot contain single quotes \"\"\" - a double quote must be escaped in a double-quoted string",
      "ja": "'' ''-単一引用符で囲まれた文字列に単一引用符を含めることはできません \"\" \"-二重引用符は二重引用符で囲まれた文字列でエスケープする必要があります"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "ja": "次の文字列は同等です。"
    },
    {
      "indent": 9,
      "text": "\"first line second line\"",
      "ja": "「1行目2行目」"
    },
    {
      "indent": 5,
      "text": "\"first line\\n\" + \" second line\"",
      "ja": "\"1行目\\ n\" + \"2行目\""
    },
    {
      "indent": 0,
      "text": "6.2. Identifiers",
      "section_title": true,
      "ja": "6.2. 識別子"
    },
    {
      "indent": 3,
      "text": "Identifiers are used to identify different kinds of YANG items by name. Each identifier starts with an uppercase or lowercase ASCII letter or an underscore character, followed by zero or more ASCII letters, digits, underscore characters, hyphens, and dots. Implementations MUST support identifiers up to 64 characters in length and MAY support longer identifiers. Identifiers are case sensitive. The identifier syntax is formally defined by the rule \"identifier\" in Section 14. Identifiers can be specified as quoted or unquoted strings.",
      "ja": "識別子は、さまざまな種類のYANGアイテムを名前で識別するために使用されます。各識別子は、大文字または小文字のASCII文字またはアンダースコア文字で始まり、0個以上のASCII文字、数字、アンダースコア文字、ハイフン、ドットが続きます。実装は、長さが最大64文字の識別子をサポートする必要があり、より長い識別子をサポートする場合があります。識別子は大文字と小文字が区別されます。識別子の構文は、セクション14のルール「identifier」によって正式に定義されています。識別子は、引用符付きまたは引用符なしの文字列として指定できます。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Identifiers and Their Namespaces",
      "section_title": true,
      "ja": "6.2.1. 識別子とその名前空間"
    },
    {
      "indent": 3,
      "text": "Each identifier is valid in a namespace that depends on the type of the YANG item being defined. All identifiers defined in a namespace MUST be unique.",
      "ja": "各識別子は、定義されているYANGアイテムのタイプに依存するネームスペースで有効です。名前空間で定義されたすべての識別子は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "o All module and submodule names share the same global module identifier namespace.",
      "ja": "o すべてのモジュールとサブモジュールの名前は、同じグローバルモジュール識別子の名前空間を共有します。"
    },
    {
      "indent": 3,
      "text": "o All extension names defined in a module and its submodules share the same extension identifier namespace.",
      "ja": "o モジュールとそのサブモジュールで定義されたすべての拡張名は、同じ拡張識別子の名前空間を共有します。"
    },
    {
      "indent": 3,
      "text": "o All feature names defined in a module and its submodules share the same feature identifier namespace.",
      "ja": "o モジュールとそのサブモジュールで定義されたすべての機能名は、同じ機能識別子名前空間を共有します。"
    },
    {
      "indent": 3,
      "text": "o All identity names defined in a module and its submodules share the same identity identifier namespace.",
      "ja": "o モジュールとそのサブモジュールで定義されたすべてのID名は、同じID識別子の名前空間を共有します。"
    },
    {
      "indent": 3,
      "text": "o All derived type names defined within a parent node or at the top level of the module or its submodules share the same type identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that typedef, and it MUST NOT define a typedef with the same name.",
      "ja": "o 親ノード内、またはモジュールまたはそのサブモジュールの最上位に定義されているすべての派生型名は、同じ型識別子の名前空間を共有します。この名前空間のスコープは、親ノードまたはモジュールのすべての子孫ノードです。これは、すべての子孫ノードがそのtypedefを使用する可能性があり、同じ名前でtypedefを定義してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "o All grouping names defined within a parent node or at the top level of the module or its submodules share the same grouping identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that grouping, and it MUST NOT define a grouping with the same name.",
      "ja": "o 親ノード内、またはモジュールまたはそのサブモジュールの最上位で定義されたすべてのグループ化名は、同じグループ化識別子名前空間を共有します。この名前空間のスコープは、親ノードまたはモジュールのすべての子孫ノードです。これは、すべての子孫ノードがそのグループを使用できることを意味し、同じ名前でグループを定義してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o All leafs, leaf-lists, lists, containers, choices, rpcs, actions, notifications, anydatas, and anyxmls defined (directly or through a \"uses\" statement) within a parent node or at the top level of the module or its submodules share the same identifier namespace. This namespace is scoped to the parent node or module, unless the parent node is a case node. In that case, the namespace is scoped to the closest ancestor node that is not a case or choice node.",
      "ja": "o 親ノード内またはモジュールの最上位レベルまたはそのサブモジュール共有で（直接または「uses」ステートメントを介して）定義されたすべてのリーフ、リーフリスト、リスト、コンテナー、選択、rpcs、アクション、通知、anydata、およびanyxml同じ識別子の名前空間。親ノードがケースノードでない限り、この名前空間のスコープは親ノードまたはモジュールです。その場合、名前空間は、ケースノードや選択ノードではない、最も近い祖先ノードにスコープされます。"
    },
    {
      "indent": 3,
      "text": "o All cases within a choice share the same case identifier namespace. This namespace is scoped to the parent choice node.",
      "ja": "o 選択肢内のすべてのケースは、同じケース識別子の名前空間を共有します。この名前空間のスコープは、親の選択ノードです。"
    },
    {
      "indent": 3,
      "text": "Forward references are allowed in YANG.",
      "ja": "YANGでは前方参照が許可されています。"
    },
    {
      "indent": 0,
      "text": "6.3. Statements",
      "section_title": true,
      "ja": "6.3. ステートメント"
    },
    {
      "indent": 3,
      "text": "A YANG module contains a sequence of statements. Each statement starts with a keyword, followed by zero or one argument, followed by either a semicolon (\";\") or a block of substatements enclosed within braces (\"{ }\"):",
      "ja": "YANGモジュールには、一連のステートメントが含まれています。各ステートメントはキーワードで始まり、その後にゼロまたは1つの引数が続き、その後にセミコロン（ \";\"）または中括弧（ \"{}\"）で囲まれたサブステートメントのブロックが続きます。"
    },
    {
      "indent": 5,
      "text": "statement = keyword [argument] (\";\" / \"{\" *statement \"}\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The argument is a string, as defined in Section 6.1.2.",
      "ja": "引数は、6.1.2項で定義されている文字列です。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Language Extensions",
      "section_title": true,
      "ja": "6.3.1. 言語拡張"
    },
    {
      "indent": 3,
      "text": "A module can introduce YANG extensions by using the \"extension\" keyword (see Section 7.19). The extensions can be imported by other modules with the \"import\" statement (see Section 7.1.5). When an imported extension is used, the extension's keyword MUST be qualified using the prefix with which the extension's module was imported. If an extension is used in the module where it is defined, the extension's keyword MUST be qualified with the prefix of this module.",
      "ja": "モジュールは \"extension\"キーワードを使用してYANG拡張を導入できます（セクション7.19を参照）。拡張機能は、 \"import\"ステートメントを使用して他のモジュールによってインポートできます（セクション7.1.5を参照）。インポートされた拡張機能が使用される場合、拡張機能のモジュールがインポートされたときの接頭辞を使用して、拡張機能のキーワードを修飾する必要があります。拡張が定義されているモジュールで拡張が使用されている場合、拡張のキーワードは、このモジュールの接頭辞で修飾する必要があります。"
    },
    {
      "indent": 3,
      "text": "The processing of extensions depends on whether support for those extensions is claimed for a given YANG parser or the tool set in which it is embedded. An unsupported extension appearing in a YANG module as an unknown-statement (see Section 14) MAY be ignored in its entirety. Any supported extension MUST be processed in accordance with the specification governing that extension.",
      "ja": "拡張機能の処理は、それらの拡張機能のサポートが、特定のYANGパーサーまたはそれが組み込まれているツールセットに対して要求されているかどうかによって異なります。 YANGモジュールで不明なステートメント（セクション14を参照）として表示されるサポートされていない拡張機能は、その全体が無視される場合があります。サポートされる拡張機能はすべて、その拡張機能を管理する仕様に従って処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Care must be taken when defining extensions so that modules that use the extensions are meaningful also for applications that do not support the extensions.",
      "ja": "拡張機能を定義するときは、拡張機能を使用するモジュールが、拡張機能をサポートしないアプリケーションでも意味を持つように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. XPath Evaluations",
      "section_title": true,
      "ja": "6.4. XPath評価"
    },
    {
      "indent": 3,
      "text": "YANG relies on XML Path Language (XPath) 1.0 [XPATH] as a notation for specifying many inter-node references and dependencies. An implementation is not required to implement an XPath interpreter but MUST ensure that the requirements encoded in the data model are enforced. The manner of enforcement is an implementation decision. The XPath expressions MUST be syntactically correct, and all prefixes used MUST be present in the XPath context (see Section 6.4.1). An implementation may choose to implement them by hand, rather than using the XPath expression directly.",
      "ja": "YANGは、多くのノード間参照と依存関係を指定するための表記として、XMLパス言語（XPath）1.0 [XPATH]に依存しています。 XPathインタープリターを実装するための実装は必須ではありませんが、データモデルにエンコードされた要件が確実に適用されるようにする必要があります。実施の仕方は実装の決定です。 XPath式は構文的に正しい必要があり、使用されるすべての接頭辞はXPathコンテキストに存在する必要があります（セクション6.4.1を参照）。実装では、XPath式を直接使用するのではなく、手動で実装することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The data model used in the XPath expressions is the same as that used in XPath 1.0 [XPATH], with the same extension for root node children as used by XSLT 1.0 (see Section 3.1 in [XSLT]). Specifically, it means that the root node may have any number of element nodes as its children.",
      "ja": "XPath式で使用されるデータモデルは、XPath 1.0 [XPATH]で使用されるデータモデルと同じですが、XSLT 1.0で使用されるのと同じルートノードの子の拡張機能があります（[XSLT]のセクション3.1を参照）。具体的には、ルートノードは子として任意の数の要素ノードを持つことができることを意味します。"
    },
    {
      "indent": 3,
      "text": "The data tree has no concept of document order. An implementation needs to choose some document order, but how it is done is an implementation decision. This means that XPath expressions in YANG modules SHOULD NOT rely on any specific document order.",
      "ja": "データツリーには、ドキュメントの順序という概念はありません。実装ではドキュメントの順序を選択する必要がありますが、その方法は実装の決定です。これは、YANGモジュールのXPath式が特定のドキュメントの順序に依存してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Numbers in XPath 1.0 are IEEE 754 [IEEE754-2008] double-precision floating-point values; see Section 3.5 in [XPATH]. This means that some values of int64, uint64, and decimal64 types (see Sections 9.2 and 9.3) cannot be exactly represented in XPath expressions. Therefore, due caution should be exercised when using nodes with 64-bit numeric values in XPath expressions. In particular, numerical comparisons involving equality may yield unexpected results.",
      "ja": "XPath 1.0の数値は、IEEE 754 [IEEE754-2008]倍精度浮動小数点値です。 [XPATH]のセクション3.5を参照してください。これは、int64、uint64、およびdecimal64型の値（セクション9.2および9.3を参照）がXPath式で正確に表現できないことを意味します。したがって、XPath式で64ビットの数値を持つノードを使用する場合は、十分な注意が必要です。特に、等式を含む数値比較では、予期しない結果が生じる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following definition:",
      "ja": "たとえば、次の定義を考えてみます。"
    },
    {
      "indent": 5,
      "text": "leaf lxiv {\n  type decimal64 {\n    fraction-digits 18;\n  }\n  must \". <= 10\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An instance of the \"lxiv\" leaf having the value of 10.0000000000000001 will then successfully pass validation.",
      "ja": "値が10.0000000000000001の「lxiv」リーフのインスタンスは、検証に成功します。"
    },
    {
      "indent": 0,
      "text": "6.4.1. XPath Context",
      "section_title": true,
      "ja": "6.4.1. XPathコンテキスト"
    },
    {
      "indent": 3,
      "text": "All YANG XPath expressions share the following XPath context definition:",
      "ja": "すべてのYANG XPath式は、次のXPathコンテキスト定義を共有します。"
    },
    {
      "indent": 3,
      "text": "o The set of namespace declarations is the set of all \"import\" statements' prefix and namespace pairs in the module where the XPath expression is specified, and the \"prefix\" statement's prefix for the \"namespace\" statement's URI.",
      "ja": "o 名前空間宣言のセットは、XPath式が指定されているモジュール内のすべての「インポート」ステートメントの接頭辞と名前空間のペアのセット、および「名前空間」ステートメントのURIに対する「接頭辞」ステートメントの接頭辞です。"
    },
    {
      "indent": 3,
      "text": "o Names without a namespace prefix belong to the same namespace as the identifier of the current node. Inside a grouping, that namespace is affected by where the grouping is used (see Section 7.13). Inside a typedef, that namespace is affected by where the typedef is referenced. If a typedef is defined and referenced within a grouping, the namespace is affected by where the grouping is used (see Section 7.13).",
      "ja": "o 名前空間接頭辞のない名前は、現在のノードの識別子と同じ名前空間に属しています。グループ化の内部では、その名前空間はグループ化が使用される場所に影響されます（セクション7.13を参照）。 typedef内では、その名前空間はtypedefが参照される場所によって影響を受けます。 typedefがグループ化内で定義および参照される場合、名前空間はグループ化が使用される場所に影響されます（セクション7.13を参照）。"
    },
    {
      "indent": 3,
      "text": "o The function library is the core function library defined in [XPATH] and the functions defined in Section 10.",
      "ja": "o 関数ライブラリは、[XPATH]で定義されたコア関数ライブラリであり、セクション10で定義された関数です。"
    },
    {
      "indent": 3,
      "text": "o The set of variable bindings is empty.",
      "ja": "o 変数バインディングのセットが空です。"
    },
    {
      "indent": 3,
      "text": "The mechanism for handling unprefixed names is adopted from XPath 2.0 [XPATH2.0] and helps simplify XPath expressions in YANG. No ambiguity may ever arise, because YANG node identifiers are always qualified names with a non-null namespace URI.",
      "ja": "接頭辞なしの名前を処理するメカニズムはXPath 2.0 [XPATH2.0]から採用されており、YANGでのXPath式の簡素化に役立ちます。 YANGノード識別子は常にnull以外の名前空間URIで修飾された名前であるため、あいまいさが発生することはありません。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on where the statement with the XPath expression is defined:",
      "ja": "アクセス可能なツリーは、XPath式を含むステートメントが定義されている場所によって異なります。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents configuration, the accessible tree is the data in the datastore where the context node exists. The root node has all top-level configuration data nodes in all modules as children.",
      "ja": "o XPath式が構成を表すデータノードのサブステートメントで定義されている場合、アクセス可能なツリーは、コンテキストノードが存在するデータストア内のデータです。ルートノードには、すべてのモジュールのすべての最上位の構成データノードが子として含まれます。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents state data, the accessible tree is all state data in the server, and the running configuration datastore. The root node has all top-level data nodes in all modules as children.",
      "ja": "o XPath式が状態データを表すデータノードのサブステートメントで定義されている場合、アクセス可能なツリーは、サーバー内のすべての状態データと実行中の構成データストアです。ルートノードには、すべてのモジュールのすべての最上位データノードが子として含まれます。"
    },
    {
      "indent": 0,
      "text": " o If the XPath expression is defined in a substatement to a \"notification\" statement, the accessible tree is the notification instance, all state data in the server, and the running configuration datastore. If the notification is defined on the top level in a module, then the root node has the node representing the notification being defined and all top-level data nodes in all modules as children. Otherwise, the root node has all top-level data nodes in all modules as children.",
      "ja": "o XPath式が「通知」ステートメントのサブステートメントで定義されている場合、アクセス可能なツリーは、通知インスタンス、サーバー内のすべての状態データ、および実行中の構成データストアです。通知がモジュールの最上位で定義されている場合、ルートノードには、定義されている通知を表すノードと、すべてのモジュールのすべての最上位のデータノードが子として含まれます。それ以外の場合、ルートノードはすべてのモジュールのすべての最上位データノードを子として持ちます。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"input\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's input parameters as children.",
      "ja": "o XPath式が「rpc」または「action」ステートメントの「input」ステートメントのサブステートメントで定義されている場合、アクセス可能なツリーは、RPCまたはアクション操作インスタンス、サーバー内のすべての状態データ、および実行中の構成データストアです。ルートノードには、すべてのモジュールで子として最上位のデータノードがあります。さらに、RPCの場合、ルートノードには、RPC操作を表すノードが子として定義されています。定義されている操作を表すノードには、子としての操作の入力パラメーターがあります。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"output\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's output parameters as children.",
      "ja": "o XPath式が「rpc」または「action」ステートメントの「output」ステートメントのサブステートメントで定義されている場合、アクセス可能なツリーは、RPCまたはアクション操作インスタンス、サーバー内のすべての状態データ、および実行中の構成データストアです。ルートノードには、すべてのモジュールで子として最上位のデータノードがあります。さらに、RPCの場合、ルートノードには、RPC操作を表すノードが子として定義されています。定義されている操作を表すノードには、子として操作の出力パラメーターがあります。"
    },
    {
      "indent": 3,
      "text": "In the accessible tree, all leafs and leaf-lists with default values in use exist (see Sections 7.6.1 and 7.7.2).",
      "ja": "アクセス可能なツリーには、デフォルト値が使用されているすべてのリーフとリーフリストが存在します（セクション7.6.1および7.7.2を参照）。"
    },
    {
      "indent": 3,
      "text": "If a node that exists in the accessible tree has a non-presence container as a child, then the non-presence container also exists in the accessible tree.",
      "ja": "アクセス可能なツリーに存在するノードが子として存在しないコンテナを持っている場合、存在しないコンテナもアクセス可能なツリーに存在します。"
    },
    {
      "indent": 3,
      "text": "The context node varies with the YANG XPath expression and is specified where the YANG statement with the XPath expression is defined.",
      "ja": "コンテキストノードは、YANG XPath式によって異なり、XPath式を含むYANGステートメントが定義されている場所で指定されます。"
    },
    {
      "indent": 0,
      "text": "6.4.1.1. Examples",
      "section_title": true,
      "ja": "6.4.1.1. 例"
    },
    {
      "indent": 3,
      "text": "Given the following module:",
      "ja": "次のモジュールがあるとします。"
    },
    {
      "indent": 5,
      "text": "module example-a {\n  yang-version 1.1;\n  namespace urn:example:a;\n  prefix a;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container a {\n    list b {\n      key id;\n      leaf id {\n        type string;\n      }\n      notification down {\n        leaf reason {\n          type string;\n        }\n      }\n      action reset {\n        input {\n          leaf delay {\n            type uint32;\n          }\n        }\n        output {\n          leaf result {\n            type string;\n          }\n        }\n      }\n    }\n  }\n  notification failure {\n    leaf b-ref {\n      type leafref {\n        path \"/a/b/id\";\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and given the following data tree, specified in XML:",
      "ja": "そして、XMLで指定された次のデータツリーが与えられます："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"down\" on /a/b[id=\"2\"] is:",
      "ja": "/ a / b [id = \"2\"]の「ダウン」通知のアクセス可能なツリーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n    <down>\n      <reason>error</reason>\n    </down>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The accessible tree for an action invocation of \"reset\" on /a/b[id=\"1\"] with the \"when\" parameter set to \"10\" would be:",
      "ja": "/ a / b [id = \"1\"]の \"reset\"のアクション呼び出しのアクセス可能なツリーは、 \"when\"パラメータを \"10\"に設定して次のようになります。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n    <reset>\n      <delay>10</delay>\n    </reset>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The accessible tree for the action output of this action is:",
      "ja": "このアクションのアクション出力のアクセス可能なツリーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n    <reset>\n      <result>ok</result>\n    </reset>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"failure\" could be:",
      "ja": "通知「失敗」のアクセス可能なツリーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n<failure>\n  <b-ref>2</b-ref>\n</failure>\n// possibly other top-level nodes here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.5. Schema Node Identifier",
      "section_title": true,
      "ja": "6.5. Ｓちぇま ので いでんちふぃえｒ"
    },
    {
      "indent": 3,
      "text": "A schema node identifier is a string that identifies a node in the schema tree. It has two forms, \"absolute\" and \"descendant\", defined by the rules \"absolute-schema-nodeid\" and \"descendant-schema-nodeid\" in Section 14, respectively. A schema node identifier consists of a path of identifiers, separated by slashes (\"/\"). In an absolute schema node identifier, the first identifier after the leading slash is any top-level schema node in the local module or in an imported module.",
      "ja": "スキーマノード識別子は、スキーマツリー内のノードを識別する文字列です。セクション14の規則「absolute-schema-nodeid」と「descendant-schema-nodeid」でそれぞれ定義されている「absolute」と「descendant」の2つの形式があります。スキーマノード識別子は、スラッシュ（ \"/\"）で区切られた識別子のパスで構成されます。絶対スキーマノード識別子では、先頭のスラッシュの後の最初の識別子は、ローカルモジュールまたはインポートされたモジュール内の任意の最上位スキーマノードです。"
    },
    {
      "indent": 3,
      "text": "References to identifiers defined in external modules MUST be qualified with appropriate prefixes, and references to identifiers defined in the current module and its submodules MAY use a prefix.",
      "ja": "外部モジュールで定義された識別子への参照は、適切なプレフィックスで修飾する必要があり、現在のモジュールとそのサブモジュールで定義された識別子への参照には、プレフィックスを使用できます。"
    },
    {
      "indent": 3,
      "text": "For example, to identify the child node \"b\" of top-level node \"a\", the string \"/a/b\" can be used.",
      "ja": "たとえば、最上位ノード「a」の子ノード「b」を識別するには、文字列「/ a / b」を使用できます。"
    },
    {
      "indent": 0,
      "text": "7. YANG Statements",
      "section_title": true,
      "ja": "7. THATステートメント"
    },
    {
      "indent": 3,
      "text": "The following sections describe all of the YANG statements.",
      "ja": "次のセクションでは、すべてのYANGステートメントについて説明します。"
    },
    {
      "indent": 3,
      "text": "Note that even a statement that does not have any substatements defined in YANG can have vendor-specific extensions as substatements. For example, the \"description\" statement does not have any substatements defined in YANG, but the following is legal:",
      "ja": "YANGでサブステートメントが定義されていないステートメントでも、ベンダー固有の拡張機能をサブステートメントとして使用できることに注意してください。たとえば、「description」ステートメントには、YANGで定義されたサブステートメントはありませんが、以下は有効です。"
    },
    {
      "indent": 5,
      "text": "description \"Some text.\" {\n  ex:documentation-flag 5;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1. The \"module\" Statement",
      "section_title": true,
      "ja": "7.1. 「モジュール」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"module\" statement defines the module's name and groups all statements that belong to the module together. The \"module\" statement's argument is the name of the module, followed by a block of substatements that holds detailed module information. The module name is an identifier (see Section 6.2).",
      "ja": "「モジュール」ステートメントは、モジュールの名前を定義し、モジュールに属するすべてのステートメントをグループ化します。 「モジュール」ステートメントの引数は、モジュールの名前であり、その後に詳細なモジュール情報を保持するサブステートメントのブロックが続きます。モジュール名は識別子です（セクション6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Names of modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリーム[RFC4844]で公開されているモジュールの名前は、IANAによって割り当てられる必要があります。 [RFC6020]のセクション14をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Private module names are assigned by the organization owning the module without a central registry. See Section 5.1 for recommendations on how to name modules.",
      "ja": "プライベートモジュール名は、中央レジストリのないモジュールを所有する組織によって割り当てられます。モジュールの命名方法に関する推奨事項については、セクション5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "A module typically has the following layout:",
      "ja": "通常、モジュールのレイアウトは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "module <module-name> {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// header information\n<yang-version statement>\n<namespace statement>\n<prefix statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// linkage statements\n<import statements>\n<include statements>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// meta-information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  // module definitions\n  <other statements>\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1.1. The module's Substatements",
      "section_title": true,
      "ja": "7.1.1. モジュールのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| namespace    | 7.1.3   | 1           |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| prefix       | 7.1.4   | 1           |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1.2. The \"yang-version\" Statement",
      "section_title": true,
      "ja": "7.1.2. 「陽バージョン」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"yang-version\" statement specifies which version of the YANG language was used in developing the module. The statement's argument is a string. It MUST contain the value \"1.1\" for YANG modules defined based on this specification.",
      "ja": "「yang-version」ステートメントは、モジュールの開発に使用されたYANG言語のバージョンを指定します。ステートメントの引数は文字列です。この仕様に基づいて定義されたYANGモジュールの値「1.1」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "A module or submodule that doesn't contain the \"yang-version\" statement, or one that contains the value \"1\", is developed for YANG version 1, defined in [RFC6020].",
      "ja": "「yang-version」ステートメントを含まないモジュールまたはサブモジュール、または値「1」を含むものは、[RFC6020]で定義されているYANGバージョン1用に開発されています。"
    },
    {
      "indent": 3,
      "text": "Handling of the \"yang-version\" statement for versions other than \"1.1\" (the version defined here) is out of scope for this specification. Any document that defines a higher version will need to define the backward compatibility of such a higher version.",
      "ja": "「1.1」（ここで定義されているバージョン）以外のバージョンの「yang-version」ステートメントの処理は、この仕様の範囲外です。より高いバージョンを定義するドキュメントは、そのようなより高いバージョンの下位互換性を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "For compatibility between YANG versions 1 and 1.1, see Section 12.",
      "ja": "YANGバージョン1と1.1の互換性については、セクション12を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.3. The \"namespace\" Statement",
      "section_title": true,
      "ja": "7.1.3. 「名前空間」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement defines the XML namespace that all identifiers defined by the module are qualified by in the XML encoding, with the exception of identifiers for data nodes, action nodes, and notification nodes defined inside a grouping (see Section 7.13 for details). The argument to the \"namespace\" statement is the URI of the namespace.",
      "ja": "「namespace」ステートメントは、モジュールによって定義されたすべての識別子がXMLエンコーディングで修飾されるXML名前空間を定義します。ただし、グループ内で定義されたデータノード、アクションノード、通知ノードの識別子は除きます（詳細については、セクション7.13を参照してください）。 。 「namespace」ステートメントの引数は、名前空間のURIです。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.3.",
      "ja": "セクション5.3も参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.4. The \"prefix\" Statement",
      "section_title": true,
      "ja": "7.1.4. 「プレフィックス」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"prefix\" statement is used to define the prefix associated with the module and its namespace. The \"prefix\" statement's argument is the prefix string that is used as a prefix to access a module. The prefix string MAY be used with the module to refer to definitions contained in the module, e.g., \"if:ifName\". A prefix is an identifier (see Section 6.2).",
      "ja": "「接頭辞」ステートメントは、モジュールとその名前空間に関連付けられた接頭辞を定義するために使用されます。 \"prefix\"ステートメントの引数は、モジュールにアクセスするためのプレフィックスとして使用されるプレフィックス文字列です。プレフィックス文字列は、モジュールに含まれている定義を参照するためにモジュールで使用される場合があります（例： \"if：ifName\"）。接頭辞は識別子です（セクション6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"module\" statement, the \"prefix\" statement defines the prefix suggested to be used when this module is imported.",
      "ja": "「モジュール」ステートメント内で使用する場合、「プレフィックス」ステートメントは、このモジュールのインポート時に使用することが推奨されるプレフィックスを定義します。"
    },
    {
      "indent": 3,
      "text": "To improve readability of the NETCONF XML, a NETCONF client or server that generates XML or XPath that uses prefixes SHOULD use the prefix defined by the module as the XML namespace prefix, unless there is a conflict.",
      "ja": "NETCONF XMLの読みやすさを向上させるために、プレフィックスを使用するXMLまたはXPathを生成するNETCONFクライアントまたはサーバーは、競合がない限り、モジュールによって定義されたプレフィックスをXML名前空間プレフィックスとして使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"import\" statement, the \"prefix\" statement defines the prefix to be used when accessing definitions inside the imported module. When a reference to an identifier from the imported module is used, the prefix string for the imported module followed by a colon (\":\") and the identifier is used, e.g., \"if:ifIndex\". To improve readability of YANG modules, the prefix defined by a module SHOULD be used when the module is imported, unless there is a conflict. If there is a conflict, i.e., two different modules that both have defined the same prefix are imported, at least one of them MUST be imported with a different prefix.",
      "ja": "「インポート」ステートメント内で使用される場合、「プレフィックス」ステートメントは、インポートされたモジュール内の定義にアクセスするときに使用されるプレフィックスを定義します。インポートされたモジュールの識別子への参照が使用される場合、インポートされたモジュールの接頭辞文字列の後にコロン（ \"：\"）と識別子が使用されます（例： \"if：ifIndex\"）。 YANGモジュールの読みやすさを向上させるために、競合がない限り、モジュールのインポート時にモジュールで定義されたプレフィックスを使用する必要があります（SHOULD）。競合がある場合、つまり、両方とも同じ接頭辞を定義している2つの異なるモジュールがインポートされる場合、少なくとも1つは異なる接頭辞でインポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "All prefixes, including the prefix for the module itself, MUST be unique within the module or submodule.",
      "ja": "モジュール自体のプレフィックスを含むすべてのプレフィックスは、モジュールまたはサブモジュール内で一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.5. The \"import\" Statement",
      "section_title": true,
      "ja": "7.1.5. 「インポート」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement makes definitions from one module available inside another module or submodule. The argument is the name of the module to import, and the statement is followed by a block of substatements that holds detailed import information. When a module is imported, the importing module may:",
      "ja": "「インポート」ステートメントは、あるモジュールの定義を別のモジュールまたはサブモジュール内で使用できるようにします。引数はインポートするモジュールの名前で、ステートメントの後には詳細なインポート情報を保持するサブステートメントのブロックが続きます。モジュールがインポートされると、インポートモジュールは次のことを実行できます。"
    },
    {
      "indent": 3,
      "text": "o use any grouping and typedef defined at the top level in the imported module or its submodules.",
      "ja": "o インポートされたモジュールまたはそのサブモジュールの最上位で定義されているグループ化とtypedefを使用します。"
    },
    {
      "indent": 3,
      "text": "o use any extension, feature, and identity defined in the imported module or its submodules.",
      "ja": "o インポートされたモジュールまたはそのサブモジュールで定義されている拡張機能、機能、およびIDを使用します。"
    },
    {
      "indent": 3,
      "text": "o use any node in the imported module's schema tree in \"must\", \"path\", and \"when\" statements, or as the target node in \"augment\" and \"deviation\" statements.",
      "ja": "o インポートされたモジュールのスキーマツリー内の任意のノードを「must」、「path」、および「when」ステートメントで使用するか、「augment」および「deviation」ステートメントでターゲットノードとして使用します。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the imported module that is scoped to the importing module or submodule. Multiple \"import\" statements may be specified to import from different modules.",
      "ja": "必須の「プレフィックス」サブステートメントは、インポートモジュールまたはサブモジュールをスコープとするインポートモジュールのプレフィックスを割り当てます。複数の「インポート」ステートメントを指定して、異なるモジュールからインポートすることができます。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, any typedef, grouping, extension, feature, and identity referenced by definitions in the local module are taken from the specified revision of the imported module. It is an error if the specified revision of the imported module does not exist. If no \"revision-date\" substatement is present, it is undefined from which revision of the module they are taken.",
      "ja": "オプションの \"revision-date\"サブステートメントが存在する場合、ローカルモジュールの定義によって参照されるtypedef、グループ化、拡張、機能、およびIDは、インポートされたモジュールの指定されたリビジョンから取得されます。インポートされたモジュールの指定されたリビジョンが存在しない場合はエラーになります。 「revision-date」サブステートメントが存在しない場合、それらが取得されるモジュールのリビジョンからは未定義です。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same module can be imported, provided that different prefixes are used.",
      "ja": "異なる接頭辞が使用されている場合、同じモジュールの複数のリビジョンをインポートできます。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| prefix        | 7.1.4   | 1           |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "The import's Substatements",
      "ja": "インポートのサブステートメント"
    },
    {
      "indent": 0,
      "text": "7.1.5.1. The import's \"revision-date\" Statement",
      "section_title": true,
      "ja": "7.1.5.1. インポートの「改訂日」ステートメント"
    },
    {
      "indent": 3,
      "text": "The import's \"revision-date\" statement is used to specify the version of the module to import.",
      "ja": "インポートの「改訂日」ステートメントは、インポートするモジュールのバージョンを指定するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.1.6. The \"include\" Statement",
      "section_title": true,
      "ja": "7.1.6. 「include」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used to make content from a submodule available to that submodule's parent module. The argument is an identifier that is the name of the submodule to include. Modules are only allowed to include submodules that belong to that module, as defined by the \"belongs-to\" statement (see Section 7.2.2).",
      "ja": "「include」ステートメントは、サブモジュールのコンテンツをそのサブモジュールの親モジュールで利用できるようにするために使用されます。引数は、含めるサブモジュールの名前である識別子です。モジュールには、「belongs-to」ステートメントで定義されているように、そのモジュールに属するサブモジュールのみを含めることができます（セクション7.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "When a module includes a submodule, it incorporates the contents of the submodule into the node hierarchy of the module.",
      "ja": "モジュールにサブモジュールが含まれている場合、サブモジュールのコンテンツがモジュールのノード階層に組み込まれます。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule is allowed to include another submodule belonging to the same module, but this is not necessary in YANG version 1.1 (see Section 5.1).",
      "ja": "YANGバージョン1との下位互換性のために、サブモジュールは同じモジュールに属する別のサブモジュールを含めることができますが、これはYANGバージョン1.1では必要ありません（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, the specified revision of the submodule is included in the module. It is an error if the specified revision of the submodule does not exist. If no \"revision-date\" substatement is present, it is undefined which revision of the submodule is included.",
      "ja": "オプションの \"revision-date\"サブステートメントが存在する場合、サブモジュールの指定されたリビジョンがモジュールに含まれます。サブモジュールの指定されたリビジョンが存在しない場合はエラーになります。 「改訂日」サブステートメントが存在しない場合、サブモジュールのどのリビジョンが含まれるかは定義されていません。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same submodule MUST NOT be included.",
      "ja": "同じサブモジュールの複数のリビジョンを含めることはできません。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "The includes's Substatements",
      "ja": "インクルードのサブステートメント"
    },
    {
      "indent": 0,
      "text": "7.1.7. The \"organization\" Statement",
      "section_title": true,
      "ja": "7.1.7. 「組織」声明"
    },
    {
      "indent": 3,
      "text": "The \"organization\" statement defines the party responsible for this module. The argument is a string that is used to specify a textual description of the organization(s) under whose auspices this module was developed.",
      "ja": "「組織」ステートメントは、このモジュールの責任者を定義します。引数は、このモジュールが開発された組織の下で組織のテキストによる説明を指定するために使用される文字列です。"
    },
    {
      "indent": 0,
      "text": "7.1.8. The \"contact\" Statement",
      "section_title": true,
      "ja": "7.1.8. 「連絡」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"contact\" statement provides contact information for the module. The argument is a string that is used to specify contact information for the person or persons to whom technical queries concerning this module should be sent, such as their name, postal address, telephone number, and electronic mail address.",
      "ja": "「連絡先」ステートメントは、モジュールの連絡先情報を提供します。引数は、名前、住所、電話番号、電子メールアドレスなど、このモジュールに関する技術的なクエリの送信先の連絡先情報を指定するために使用される文字列です。"
    },
    {
      "indent": 0,
      "text": "7.1.9. The \"revision\" Statement",
      "section_title": true,
      "ja": "7.1.9. 「改訂」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"revision\" statement specifies the editorial revision history of the module, including the initial revision. A series of \"revision\" statements detail the changes in the module's definition. The argument is a date string in the format \"YYYY-MM-DD\", followed by a block of substatements that holds detailed revision information. A module SHOULD have at least one \"revision\" statement. For every published editorial change, a new one SHOULD be added in front of the revisions sequence so that all revisions are in reverse chronological order.",
      "ja": "「改訂」ステートメントは、最初の改訂を含む、モジュールの編集改訂履歴を指定します。一連の「改訂」ステートメントは、モジュールの定義の変更を詳述しています。引数は、「YYYY-MM-DD」の形式の日付文字列であり、その後に詳細なリビジョン情報を保持するサブステートメントのブロックが続きます。モジュールには少なくとも1つの「改訂」ステートメントが必要です（SHOULD）。公開された編集上の変更ごとに、新しいものをリビジョンシーケンスの前に追加して、すべてのリビジョンが新しい順になるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.9.1. The revision's Substatements",
      "section_title": true,
      "ja": "7.1.9.1. 改訂のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1.10. Usage Example",
      "section_title": true,
      "ja": "7.1.10. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example relies on [RFC6991].",
      "ja": "次の例は、[RFC6991]に依存しています。"
    },
    {
      "indent": 5,
      "text": "module example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n  reference \"RFC 6991: Common YANG Data Types\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "include example-types;",
      "ja": "example-typesを含めます。"
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "ja": "組織「Example Inc.」; 「Joe L. User"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "ja": "Example Inc. 42 Anywhere Drive Nowhere、CA 95134 USA"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100\nEmail: joe@example.com\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "description \"The module for entities implementing the Example system.\";",
      "ja": "説明「サンプルシステムを実装するエンティティのモジュール。」;"
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "ja": "//定義が続きます...}"
    },
    {
      "indent": 0,
      "text": "7.2. The \"submodule\" Statement",
      "section_title": true,
      "ja": "7.2. 「サブモジュール」ステートメント"
    },
    {
      "indent": 3,
      "text": "While the primary unit in YANG is a module, a YANG module can itself be constructed out of several submodules. Submodules allow a module designer to split a complex model into several pieces where all the submodules contribute to a single namespace, which is defined by the module that includes the submodules.",
      "ja": "YANGのプライマリユニットはモジュールですが、YANGモジュール自体は複数のサブモジュールから構成できます。モジュール設計者はサブモジュールを使用して、複雑なモデルをいくつかの部分に分割できます。すべてのサブモジュールは、サブモジュールを含むモジュールによって定義される単一の名前空間に寄与します。"
    },
    {
      "indent": 3,
      "text": "The \"submodule\" statement defines the submodule's name, and it groups all statements that belong to the submodule together. The \"submodule\" statement's argument is the name of the submodule, followed by a block of substatements that holds detailed submodule information. The submodule name is an identifier (see Section 6.2).",
      "ja": "「サブモジュール」ステートメントはサブモジュールの名前を定義し、サブモジュールに属するすべてのステートメントをグループ化します。 「サブモジュール」ステートメントの引数は、サブモジュールの名前であり、その後にサブモジュールの詳細情報を保持するサブステートメントのブロックが続きます。サブモジュール名は識別子です（セクション6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Names of submodules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリーム[RFC4844]で公開されているサブモジュールの名前は、IANAによって割り当てられる必要があります。 [RFC6020]のセクション14をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Private submodule names are assigned by the organization owning the submodule without a central registry. See Section 5.1 for recommendations on how to name submodules.",
      "ja": "プライベートサブモジュール名は、中央レジストリのないサブモジュールを所有する組織によって割り当てられます。サブモジュールの命名方法に関する推奨事項については、セクション5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "A submodule typically has the following layout:",
      "ja": "サブモジュールは通常、次のレイアウトになっています。"
    },
    {
      "indent": 5,
      "text": "submodule <module-name> {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "<yang-version statement>",
      "ja": "<バージョンステートメント>"
    },
    {
      "indent": 7,
      "text": "// module identification\n<belongs-to statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// linkage statements\n<import statements>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// meta-information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  // module definitions\n  <other statements>\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.1. The submodule's Substatements",
      "section_title": true,
      "ja": "7.2.1. サブモジュールのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| belongs-to   | 7.2.2   | 1           |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.2. The \"belongs-to\" Statement",
      "section_title": true,
      "ja": "7.2.2. 「所属」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"belongs-to\" statement specifies the module to which the submodule belongs. The argument is an identifier that is the name of the module.",
      "ja": "「belongs-to」ステートメントは、サブモジュールが属するモジュールを指定します。引数は、モジュールの名前である識別子です。"
    },
    {
      "indent": 3,
      "text": "A submodule MUST only be included by either the module to which it belongs or another submodule that belongs to that module.",
      "ja": "サブモジュールは、それが属するモジュールまたはそのモジュールに属する別のサブモジュールのいずれかによってのみ含まれる必要があります。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the module to which the submodule belongs. All definitions in the module that the submodule belongs to and all its submodules can be accessed by using the prefix.",
      "ja": "必須の「プレフィックス」サブステートメントは、サブモジュールが属するモジュールのプレフィックスを割り当てます。サブモジュールが属するモジュール内のすべての定義とそのすべてのサブモジュールには、プレフィックスを使用してアクセスできます。"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| prefix       | 7.1.4   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "The belongs-to's Substatement",
      "ja": "所属先のサブステートメント"
    },
    {
      "indent": 0,
      "text": "7.2.3. Usage Example",
      "section_title": true,
      "ja": "7.2.3. 使用例"
    },
    {
      "indent": 5,
      "text": "submodule example-types {\n  yang-version 1.1;\n  belongs-to \"example-system\" {\n    prefix \"sys\";\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "ja": "組織「Example Inc.」; 「Joe L. User"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "ja": "Example Inc. 42 Anywhere Drive Nowhere、CA 95134 USA"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100\nEmail: joe@example.com\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "description \"This submodule defines common Example types.\";",
      "ja": "説明 \"このサブモジュールは一般的なサンプルタイプを定義します。\";"
    },
    {
      "indent": 7,
      "text": "revision \"2007-06-09\" {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "ja": "//定義が続きます...}"
    },
    {
      "indent": 0,
      "text": "7.3. The \"typedef\" Statement",
      "section_title": true,
      "ja": "7.3. 「typedef」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement defines a new type that may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. The new type is called the \"derived type\", and the type from which it was derived is called the \"base type\". All derived types can be traced back to a YANG built-in type.",
      "ja": "「typedef」ステートメントは、セクション5.5のルールに従って、モジュールまたはサブモジュールでローカルに、およびそこからインポートする他のモジュールで使用できる新しいタイプを定義します。新しい型は「派生型」と呼ばれ、派生元の型は「基本型」と呼ばれます。すべての派生型は、YANG組み込み型までさかのぼることができます。"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement's argument is an identifier that is the name of the type to be defined and MUST be followed by a block of substatements that holds detailed typedef information.",
      "ja": "「typedef」ステートメントの引数は、定義されるタイプの名前である識別子であり、その後に詳細なtypedef情報を保持するサブステートメントのブロックが続く必要があります。"
    },
    {
      "indent": 3,
      "text": "The name of the type MUST NOT be one of the YANG built-in types. If the typedef is defined at the top level of a YANG module or submodule, the name of the type to be defined MUST be unique within the module.",
      "ja": "タイプの名前は、YANG組み込みタイプの1つであってはなりません。 typedefがYANGモジュールまたはサブモジュールのトップレベルで定義されている場合、定義されるタイプの名前はモジュール内で一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.1. The typedef's Substatements",
      "section_title": true,
      "ja": "7.3.1. typedefのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| default      | 7.3.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.3.2   | 1           |\n| units        | 7.3.3   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3.2. The typedef's \"type\" Statement",
      "section_title": true,
      "ja": "7.3.2. typedefの「type」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, defines the base type from which this type is derived. See Section 7.4 for details.",
      "ja": "「type」ステートメントは必ず存在しなければならず、このタイプの派生元となる基本タイプを定義します。詳細については、セクション7.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3.3. The \"units\" Statement",
      "section_title": true,
      "ja": "7.3.3. 「ユニット」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"units\" statement, which is optional, takes as an argument a string that contains a textual definition of the units associated with the type.",
      "ja": "オプションの「units」ステートメントは、タイプに関連付けられた単位のテキスト定義を含む文字列を引数として受け取ります。"
    },
    {
      "indent": 0,
      "text": "7.3.4. The typedef's \"default\" Statement",
      "section_title": true,
      "ja": "7.3.4. typedefの「デフォルト」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement takes as an argument a string that contains a default value for the new type.",
      "ja": "「デフォルト」ステートメントは、新しいタイプのデフォルト値を含む文字列を引数として受け取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the \"type\" statement.",
      "ja": "「デフォルト」ステートメントの値は、「タイプ」ステートメントで指定されたタイプに従って有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the base type has a default value and the new derived type does not specify a new default value, the base type's default value is also the default value of the new derived type.",
      "ja": "基本タイプにデフォルト値があり、新しい派生タイプが新しいデフォルト値を指定していない場合、基本タイプのデフォルト値は新しい派生タイプのデフォルト値でもあります。"
    },
    {
      "indent": 3,
      "text": "If the type's default value is not valid according to the new restrictions specified in a derived type or leaf definition, the derived type or leaf definition MUST specify a new default value compatible with the restrictions.",
      "ja": "タイプのデフォルト値が派生タイプまたはリーフ定義で指定された新しい制限に従って有効でない場合、派生タイプまたはリーフ定義は制限と互換性のある新しいデフォルト値を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.5. Usage Example",
      "section_title": true,
      "ja": "7.3.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef listen-ipv4-address {\n  type inet:ipv4-address;\n  default \"0.0.0.0\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4. The \"type\" Statement",
      "section_title": true,
      "ja": "7.4. 「タイプ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement takes as an argument a string that is the name of a YANG built-in type (see Section 9) or a derived type (see Section 7.3), followed by an optional block of substatements that is used to put further restrictions on the type.",
      "ja": "「type」ステートメントは、YANG組み込み型（セクション9を参照）または派生型（セクション7.3を参照）の名前である文字列を引数として取り、その後にオプションのサブステートメントブロックを続けてさらに記述します。タイプの制限。"
    },
    {
      "indent": 3,
      "text": "The restrictions that can be applied depend on the type being restricted. The restriction statements for all built-in types are described in the subsections of Section 9.",
      "ja": "適用できる制限は、制限されるタイプによって異なります。すべての組み込みタイプの制限ステートメントについては、セクション9のサブセクションで説明しています。"
    },
    {
      "indent": 0,
      "text": "7.4.1. The type's Substatements",
      "section_title": true,
      "ja": "7.4.1. タイプのサブステートメント"
    },
    {
      "indent": 15,
      "text": "+------------------+---------+-------------+\n| substatement     | section | cardinality |\n+------------------+---------+-------------+\n| base             | 7.18.2  | 0..n        |\n| bit              | 9.7.4   | 0..n        |\n| enum             | 9.6.4   | 0..n        |\n| fraction-digits  | 9.3.4   | 0..1        |\n| length           | 9.4.4   | 0..1        |\n| path             | 9.9.2   | 0..1        |\n| pattern          | 9.4.5   | 0..n        |\n| range            | 9.2.4   | 0..1        |\n| require-instance | 9.9.3   | 0..1        |\n| type             | 7.4     | 0..n        |\n+------------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5. The \"container\" Statement",
      "section_title": true,
      "ja": "7.5. 「コンテナ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is used to define an interior data node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed container information.",
      "ja": "「container」ステートメントは、スキーマツリーの内部データノードを定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細なコンテナー情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "A container node does not have a value, but it has a list of child nodes in the data tree. The child nodes are defined in the container's substatements.",
      "ja": "コンテナノードには値はありませんが、データツリーに子ノードのリストがあります。子ノードは、コンテナのサブステートメントで定義されます。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Containers with Presence",
      "section_title": true,
      "ja": "7.5.1. 存在感のあるコンテナ"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles of containers, those that exist only for organizing the hierarchy of data nodes and those whose presence in the data tree has an explicit meaning.",
      "ja": "YANGは、データノードの階層を編成するためにのみ存在するコンテナと、データツリー内の存在が明確な意味を持つコンテナの2つのスタイルをサポートしています。"
    },
    {
      "indent": 3,
      "text": "In the first style, the container has no meaning of its own, existing only to contain child nodes. In particular, the presence of the container node with no child nodes is semantically equivalent to the absence of the container node. YANG calls this style a \"non-presence container\". This is the default style.",
      "ja": "最初のスタイルでは、コンテナはそれ自体には意味がなく、子ノードを含むためだけに存在します。特に、子ノードのないコンテナノードの存在は、意味的にはコンテナノードの不在と同等です。 YANGはこのスタイルを「非存在コンテナ」と呼んでいます。これがデフォルトのスタイルです。"
    },
    {
      "indent": 3,
      "text": "For example, the set of scrambling options for Synchronous Optical Network (SONET) interfaces may be placed inside a \"scrambling\" container to enhance the organization of the configuration hierarchy and to keep these nodes together. The \"scrambling\" node itself has no meaning, so removing the node when it becomes empty relieves the user from performing this task.",
      "ja": "たとえば、同期光ネットワーク（SONET）インターフェイスのスクランブルオプションのセットを「スクランブル」コンテナ内に配置して、構成階層の編成を強化し、これらのノードをまとめて維持することができます。 「スクランブル」ノード自体には意味がないため、ノードが空になったときにノードを削除しても、ユーザーはこのタスクを実行する必要がありません。"
    },
    {
      "indent": 3,
      "text": "In the second style, the presence of the container itself carries some meaning, representing a single bit of data.",
      "ja": "2番目のスタイルでは、コンテナー自体の存在が何らかの意味を持ち、1ビットのデータを表します。"
    },
    {
      "indent": 3,
      "text": "For configuration data, the container acts as both a configuration knob and a means of organizing related configuration nodes. These containers are explicitly created and deleted.",
      "ja": "構成データの場合、コンテナは構成ノブと、関連する構成ノードを編成する手段の両方として機能します。これらのコンテナは明示的に作成および削除されます。"
    },
    {
      "indent": 3,
      "text": "YANG calls this style a \"presence container\", and it is indicated using the \"presence\" statement, which takes as its argument a text string indicating what the presence of the node means.",
      "ja": "YANGはこのスタイルを「プレゼンスコンテナ」と呼び、「プレゼンス」ステートメントを使用して示されます。これは、ノードの存在が何を意味するかを示すテキスト文字列を引数として取ります。"
    },
    {
      "indent": 3,
      "text": "For example, an \"ssh\" container may turn on the ability to log into the server using Secure SHell (SSH) but can also contain any SSH-related configuration knobs, such as connection rates or retry limits.",
      "ja": "たとえば、「ssh」コンテナは、Secure SHell（SSH）を使用してサーバーにログインする機能をオンにすることができますが、接続速度や再試行制限などのSSH関連の設定ノブを含めることもできます。"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement (see Section 7.5.5) is used to give semantics to the existence of the container in the data tree.",
      "ja": "「存在」ステートメント（セクション7.5.5を参照）は、データツリー内のコンテナの存在に意味を与えるために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.5.2. The container's Substatements",
      "section_title": true,
      "ja": "7.5.2. コンテナのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| presence     | 7.5.5   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.3. The \"must\" Statement",
      "section_title": true,
      "ja": "7.5.3. 「必須」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"must\" statement, which is optional, takes as an argument a string that contains an XPath expression (see Section 6.4). It is used to formally declare a constraint on valid data. The constraint is enforced according to the rules in Section 8.",
      "ja": "オプションの「必須」ステートメントは、XPath式を含む文字列を引数として受け取ります（6.4節を参照）。有効なデータに対する制約を正式に宣言するために使用されます。制約は、セクション8のルールに従って実施されます。"
    },
    {
      "indent": 3,
      "text": "When a datastore is validated, all \"must\" constraints are conceptually evaluated once for each node in the accessible tree (see Section 6.4.1).",
      "ja": "データストアが検証されると、すべての「必須」制約は、アクセス可能なツリー内のノードごとに1回概念的に評価されます（セクション6.4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "All such constraints MUST evaluate to \"true\" for the data to be valid.",
      "ja": "データが有効であるためには、そのような制約はすべて「真」と評価されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "XPath式は、セクション6.4.1の定義に加えて、次のコンテキストで概念的に評価されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of a \"notification\" statement, the context node is the node representing the notification in the accessible tree.",
      "ja": "o 「必須」ステートメントが「通知」ステートメントのサブステートメントである場合、コンテキストノードは、アクセス可能なツリーで通知を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"input\" statement, the context node is the node representing the operation in the accessible tree.",
      "ja": "o 「必須」ステートメントが「入力」ステートメントのサブステートメントである場合、コンテキストノードは、アクセス可能なツリー内の操作を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"output\" statement, the context node is the node representing the operation in the accessible tree.",
      "ja": "o 「必須」ステートメントが「出力」ステートメントのサブステートメントである場合、コンテキストノードは、アクセス可能なツリー内の操作を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the accessible tree for which the \"must\" statement is defined.",
      "ja": "o それ以外の場合、コンテキストノードは、「必須」ステートメントが定義されているアクセス可能なツリー内のノードです。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "ja": "XPath式の結果は、標準のXPathルールを使用してブール値に変換されます。"
    },
    {
      "indent": 3,
      "text": "Note that since all leaf values in the data tree are conceptually stored in their canonical form (see Section 9.1), any XPath comparisons are done on the canonical value.",
      "ja": "データツリーのすべてのリーフ値は概念的には正規の形式で格納されているため（セクション9.1を参照）、XPathの比較はすべて正規の値で行われます。"
    },
    {
      "indent": 3,
      "text": "Also note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. How the evaluation is done in practice is an implementation decision.",
      "ja": "また、XPath式は概念的に評価されることに注意してください。これは、実装がサーバーでXPathエバリュエーターを使用する必要がないことを意味します。評価が実際にどのように行われるかは、実装の決定です。"
    },
    {
      "indent": 0,
      "text": "7.5.4. The must's Substatements",
      "section_title": true,
      "ja": "7.5.4. マストのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.4.1. The \"error-message\" Statement",
      "section_title": true,
      "ja": "7.5.4.1. 「エラーメッセージ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"error-message\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-message> in the <rpc-error> in NETCONF.",
      "ja": "オプションの「error-message」ステートメントは、引数として文字列を取ります。制約が「false」と評価された場合、文字列はNETCONFの<rpc-error>で<error-message>として渡されます。"
    },
    {
      "indent": 0,
      "text": "7.5.4.2. The \"error-app-tag\" Statement",
      "section_title": true,
      "ja": "7.5.4.2. 「error-app-tag」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"error-app-tag\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-app-tag> in the <rpc-error> in NETCONF.",
      "ja": "「error-app-tag」ステートメントはオプションであり、ストリングを引数として取ります。制約が「false」と評価された場合、文字列はNETCONFの<rpc-error>で<error-app-tag>として渡されます。"
    },
    {
      "indent": 0,
      "text": "7.5.4.3. Usage Example of must and error-message",
      "section_title": true,
      "ja": "7.5.4.3. mustとerror-messageの使用例"
    },
    {
      "indent": 5,
      "text": "container interface {\n  leaf ifType {\n    type enumeration {\n      enum ethernet;\n      enum atm;\n    }\n  }\n  leaf ifMTU {\n    type uint32;\n  }\n  must 'ifType != \"ethernet\" or ifMTU = 1500' {\n    error-message \"An Ethernet MTU must be 1500\";\n  }\n  must 'ifType != \"atm\" or'\n     + ' (ifMTU <= 17966 and ifMTU >= 64)' {\n    error-message \"An ATM MTU must be 64 .. 17966\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.5. The \"presence\" Statement",
      "section_title": true,
      "ja": "7.5.5. 「プレゼンス」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement assigns a meaning to the presence of a container in the data tree. It takes as an argument a string that contains a textual description of what the node's presence means.",
      "ja": "「存在」ステートメントは、データツリー内のコンテナーの存在に意味を割り当てます。これは引数として、ノードの存在が何を意味するかを説明するテキストを含む文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "If a container has the \"presence\" statement, the container's existence in the data tree carries some meaning. Otherwise, the container is used to give some structure to the data, and it carries no meaning by itself.",
      "ja": "コンテナに「存在」ステートメントがある場合、データツリー内でのコンテナの存在には意味があります。それ以外の場合、コンテナはデータに何らかの構造を与えるために使用され、それ自体は意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "See Section 7.5.1 for additional information.",
      "ja": "追加情報については、セクション7.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.5.6. The container's Child Node Statements",
      "section_title": true,
      "ja": "7.5.6. コンテナの子ノードステートメント"
    },
    {
      "indent": 3,
      "text": "Within a container, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the container.",
      "ja": "コンテナ内では、「container」、「leaf」、「list」、「leaf-list」、「uses」、「choice」、「anydata」、および「anyxml」ステートメントを使用して、コンテナに子ノードを定義できます。 。"
    },
    {
      "indent": 0,
      "text": "7.5.7. XML Encoding Rules",
      "section_title": true,
      "ja": "7.5.7. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "A container node is encoded as an XML element. The element's local name is the container's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "コンテナノードはXML要素としてエンコードされます。要素のローカル名はコンテナの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The container's child nodes are encoded as subelements to the container element. If the container defines RPC or action input or output parameters, these subelements are encoded in the same order as they are defined within the \"container\" statement. Otherwise, the subelements are encoded in any order.",
      "ja": "コンテナの子ノードは、コンテナ要素のサブ要素としてエンコードされます。コンテナーがRPCまたはアクションの入力または出力パラメーターを定義する場合、これらのサブエレメントは、「コンテナー」ステートメント内で定義されているのと同じ順序でエンコードされます。それ以外の場合、サブ要素は任意の順序でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the container is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "ja": "コンテナのサブ要素間の空白は重要ではありません。つまり、実装はサブ要素間に空白文字を挿入できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "If a non-presence container does not have any child nodes, the container may or may not be present in the XML encoding.",
      "ja": "非プレゼンスコンテナに子ノードがない場合、コンテナはXMLエンコーディングに存在する場合と存在しない場合があります。"
    },
    {
      "indent": 0,
      "text": "7.5.8. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.5.8. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "Containers can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute (see Section 7.2 in [RFC6241]) in the container's XML element.",
      "ja": "コンテナーは、コンテナーのXML要素の「operation」属性（[RFC6241]のセクション7.2を参照）を使用して、<edit-config>で作成、削除、置換、および変更できます。"
    },
    {
      "indent": 3,
      "text": "If a container does not have a \"presence\" statement and the last child node is deleted, the NETCONF server MAY delete the container.",
      "ja": "コンテナーに「存在」ステートメントがなく、最後の子ノードが削除された場合、NETCONFサーバーはコンテナーを削除できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the container node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>リクエストを処理する場合、コンテナーノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist.",
      "ja": "o 操作が「マージ」または「置換」の場合、ノードが存在しない場合は作成されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、ノードが存在しなければ作成されます。ノードがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、ノードが存在すると削除されます。ノードが存在しない場合、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.5.9. Usage Example",
      "section_title": true,
      "ja": "7.5.9. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following container definition:",
      "ja": "次のコンテナ定義があるとします。"
    },
    {
      "indent": 5,
      "text": "container system {\n  description\n    \"Contains various system parameters.\";\n  container services {\n    description\n      \"Configure externally available services.\";\n    container \"ssh\" {\n      presence \"Enables SSH\";\n      description\n        \"SSH service-specific configuration.\";\n      // more leafs, containers, and stuff here...\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <services>\n    <ssh/>\n  </services>\n</system>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since the <ssh> element is present, SSH is enabled.",
      "ja": "<ssh>要素が存在するため、SSHが有効になっています。"
    },
    {
      "indent": 3,
      "text": "To delete a container with an <edit-config>:",
      "ja": "<edit-config>でコンテナを削除するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh nc:operation=\"delete\"/>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.6. The \"leaf\" Statement",
      "section_title": true,
      "ja": "7.6. 「リーフ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a leaf node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf information.",
      "ja": "「leaf」ステートメントは、スキーマツリーでリーフノードを定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細なリーフ情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "A leaf node has a value, but no child nodes, in the data tree. Conceptually, the value in the data tree is always in the canonical form (see Section 9.1).",
      "ja": "リーフノードにはデータツリーの値がありますが、子ノードはありません。概念的には、データツリーの値は常に標準形式です（セクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A leaf node exists in zero or one instance in the data tree.",
      "ja": "リーフノードは、データツリーの0または1つのインスタンスに存在します。"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a scalar variable of a particular built-in or derived type.",
      "ja": "「リーフ」ステートメントは、特定の組み込み型または派生型のスカラー変数を定義するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.6.1. The leaf's Default Value",
      "section_title": true,
      "ja": "7.6.1. 葉のデフォルト値"
    },
    {
      "indent": 3,
      "text": "The default value of a leaf is the value that the server uses if the leaf does not exist in the data tree. The usage of the default value depends on the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "葉のデフォルト値は、葉がデータツリーに存在しない場合にサーバーが使用する値です。デフォルト値の使用法は、存在しないコンテナではないスキーマツリー内のリーフの最も近い祖先ノードに依存します（セクション7.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default value MUST be used.",
      "ja": "o そのような祖先がスキーマツリーに存在しない場合は、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default value MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "ja": "o それ以外の場合、この祖先がケースノードである場合、ケースのノードがデータツリーに存在するか、ケースノードが選択肢のデフォルトケースであり、他のケースのノードがデータツリーに存在しない場合、デフォルト値を使用する必要があります。 。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default value MUST be used if the ancestor node exists in the data tree.",
      "ja": "o それ以外の場合、祖先ノードがデータツリーに存在する場合は、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default value is said to be in use.",
      "ja": "これらの場合、デフォルト値が使用中であると言われます。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default value is not in use.",
      "ja": "リーフまたはその祖先のいずれかに「when」条件または「false」と評価される「if-feature」式がある場合、デフォルト値は使用されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the default value is in use, the server MUST operationally behave as if the leaf was present in the data tree with the default value as its value.",
      "ja": "デフォルト値が使用されている場合、サーバーは、葉がデータツリーに存在しているかのように、デフォルト値をその値として使用して動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf has a \"default\" statement, the leaf's default value is the value of the \"default\" statement. Otherwise, if the leaf's type has a default value and the leaf is not mandatory, then the leaf's default value is the type's default value. In all other cases, the leaf does not have a default value.",
      "ja": "リーフに「デフォルト」ステートメントがある場合、リーフのデフォルト値は「デフォルト」ステートメントの値です。それ以外の場合、リーフのタイプにデフォルト値があり、リーフが必須ではない場合、リーフのデフォルト値はタイプのデフォルト値です。他のすべての場合、リーフにはデフォルト値がありません。"
    },
    {
      "indent": 0,
      "text": "7.6.2. The leaf's Substatements",
      "section_title": true,
      "ja": "7.6.2. 葉のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.6.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.6.3   | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.6.3. The leaf's \"type\" Statement",
      "section_title": true,
      "ja": "7.6.3. 葉の「タイプ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, takes as an argument the name of an existing built-in or derived type. The optional substatements specify restrictions on this type. See Section 7.4 for details.",
      "ja": "「type」ステートメントは必ず存在しなければならず、既存の組み込み型または派生型の名前を引数として取ります。オプションのサブステートメントは、このタイプの制限を指定します。詳細については、セクション7.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.6.4. The leaf's \"default\" Statement",
      "section_title": true,
      "ja": "7.6.4. 葉の「デフォルト」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf.",
      "ja": "オプションの「デフォルト」ステートメントは、リーフのデフォルト値を含む文字列を引数として受け取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf's \"type\" statement.",
      "ja": "「デフォルト」ステートメントの値は、リーフの「タイプ」ステートメントで指定されたタイプに従って有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"mandatory\" is \"true\".",
      "ja": "「デフォルト」ステートメントは、「必須」が「true」であるノードに存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The definition of the default value MUST NOT be marked with an \"if-feature\" statement. For example, the following is illegal:",
      "ja": "デフォルト値の定義は、「if-feature」ステートメントでマークしてはなりません。たとえば、以下は不正です。"
    },
    {
      "indent": 5,
      "text": "leaf color {\n  type enumeration {\n    enum blue { if-feature blue; }\n    ...\n  }\n  default blue; // illegal - enum value is conditional\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.6.5. The leaf's \"mandatory\" Statement",
      "section_title": true,
      "ja": "7.6.5. リーフの「必須」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If not specified, the default is \"false\".",
      "ja": "オプションの「必須」ステートメントは、ストリングとして「true」または「false」を引数として取り、有効なデータに制約を課します。指定しない場合、デフォルトは「false」です。"
    },
    {
      "indent": 3,
      "text": "If \"mandatory\" is \"true\", the behavior of the constraint depends on the type of the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "「必須」が「true」の場合、制約の動作は、非存在コンテナではないスキーマツリー内のリーフの最も近い祖先ノードのタイプに依存します（セクション7.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the leaf MUST exist.",
      "ja": "o そのような祖先がスキーマツリーに存在しない場合、リーフが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the leaf MUST exist if any node from the case exists in the data tree.",
      "ja": "o それ以外の場合、この祖先がケースノードである場合、ケースからのノードがデータツリーに存在する場合、リーフが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the leaf MUST exist if the ancestor node exists in the data tree.",
      "ja": "o それ以外の場合、祖先ノードがデータツリーに存在する場合、リーフが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "This constraint is enforced according to the rules in Section 8.",
      "ja": "この制約は、セクション8のルールに従って実施されます。"
    },
    {
      "indent": 0,
      "text": "7.6.6. XML Encoding Rules",
      "section_title": true,
      "ja": "7.6.6. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "A leaf node is encoded as an XML element. The element's local name is the leaf's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "リーフノードは、XML要素としてエンコードされます。要素のローカル名はリーフの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The value of the leaf node is encoded to XML according to the type and is sent as character data in the element.",
      "ja": "リーフノードの値は、タイプに従ってXMLにエンコードされ、要素内の文字データとして送信されます。"
    },
    {
      "indent": 3,
      "text": "See Section 7.6.8 for an example.",
      "ja": "例については、セクション7.6.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.6.7. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.6.7. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the leaf node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>要求を処理するとき、リーフノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the value found in the XML RPC data.",
      "ja": "o 操作が「マージ」または「置換」の場合、ノードが存在しない場合はノードが作成され、その値はXML RPCデータで見つかった値に設定されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、ノードが存在しなければ作成されます。ノードがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、ノードが存在すると削除されます。ノードが存在しない場合、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.6.8. Usage Example",
      "section_title": true,
      "ja": "7.6.8. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"leaf\" statement, placed in the previously defined \"ssh\" container (see Section 7.5.9):",
      "ja": "以前に定義された「ssh」コンテナに配置された次の「リーフ」ステートメントがあると仮定します（セクション7.5.9を参照）。"
    },
    {
      "indent": 5,
      "text": "leaf port {\n  type inet:port-number;\n  default 22;\n  description\n    \"The port to which the SSH server listens.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<port>2022</port>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To set the value of a leaf with an <edit-config>:",
      "ja": "<edit-config>でリーフの値を設定するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <port>2022</port>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.7. The \"leaf-list\" Statement",
      "section_title": true,
      "ja": "7.7. 「リーフリスト」ステートメント"
    },
    {
      "indent": 3,
      "text": "Where the \"leaf\" statement is used to define a simple scalar variable of a particular type, the \"leaf-list\" statement is used to define an array of a particular type. The \"leaf-list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf-list information.",
      "ja": "「leaf」ステートメントを使用して特定のタイプの単純なスカラー変数を定義する場合、「leaf-list」ステートメントを使用して特定のタイプの配列を定義します。 「リーフリスト」ステートメントは、1つの引数（識別子）を取り、その後に詳細なリーフリスト情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "In configuration data, the values in a leaf-list MUST be unique.",
      "ja": "構成データでは、リーフリストの値は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "The definitions of the default values MUST NOT be marked with an \"if-feature\" statement.",
      "ja": "デフォルト値の定義は、「if-feature」ステートメントでマークしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the values in the data tree MUST be in the canonical form (see Section 9.1).",
      "ja": "概念的には、データツリーの値は標準的な形式でなければなりません（セクション9.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Ordering",
      "section_title": true,
      "ja": "7.7.1. ご注文"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles for ordering the entries within lists and leaf-lists. In many lists, the order of list entries does not impact the implementation of the list's configuration, and the server is free to sort the list entries in any reasonable order. The \"description\" string for the list may suggest an order to the server implementor. YANG calls this style of list \"system ordered\"; such lists are indicated with the statement \"ordered-by system\".",
      "ja": "YANGは、リストおよびリーフリスト内のエントリを順序付けるための2つのスタイルをサポートしています。多くのリストでは、リストエントリの順序はリストの構成の実装に影響を与えず、サーバーはリストエントリを適切な順序で自由にソートできます。リストの「説明」文字列は、サーバーの実装者に注文を示唆する場合があります。 YANGはこのスタイルのリストを「システム注文」と呼んでいます。このようなリストは、「ordered-by system」という文で示されます。"
    },
    {
      "indent": 3,
      "text": "For example, a list of valid users would typically be sorted alphabetically, since the order in which the users appeared in the configuration would not impact the creation of those users' accounts.",
      "ja": "たとえば、有効なユーザーのリストは通常​​、アルファベット順にソートされます。これは、ユーザーが構成に表示される順序は、それらのユーザーのアカウントの作成には影響しないためです。"
    },
    {
      "indent": 3,
      "text": "In the other style of lists, the order of list entries matters for the implementation of the list's configuration and the user is responsible for ordering the entries, while the server maintains that order. YANG calls this style of list \"user ordered\"; such lists are indicated with the statement \"ordered-by user\".",
      "ja": "他のスタイルのリストでは、リストエントリの順序がリストの構成の実装にとって重要であり、サーバーがその順序を維持しながら、ユーザーはエントリの順序付けを担当します。 YANGはこのスタイルのリストを「ユーザー注文」と呼んでいます。そのようなリストは、「ordered-by user」というステートメントで示されます。"
    },
    {
      "indent": 3,
      "text": "For example, the order in which packet filter entries are applied to incoming traffic may affect how that traffic is filtered. The user would need to decide if the filter entry that discards all TCP traffic should be applied before or after the filter entry that allows all traffic from trusted interfaces. The choice of order would be crucial.",
      "ja": "たとえば、パケットフィルターエントリが着信トラフィックに適用される順序は、そのトラフィックのフィルター方法に影響する場合があります。ユーザーは、すべてのTCPトラフィックを破棄するフィルターエントリを、信頼できるインターフェイスからのすべてのトラフィックを許可するフィルターエントリの前または後に適用するかどうかを決定する必要があります。順序の選択は重要です。"
    },
    {
      "indent": 3,
      "text": "YANG provides a rich set of facilities within NETCONF's <edit-config> operation that allows the order of list entries in user-ordered lists to be controlled. List entries may be inserted or rearranged, positioned as the first or last entry in the list, or positioned before or after another specific entry.",
      "ja": "YANGは、NETCONFの<edit-config>操作内に豊富な機能セットを提供し、ユーザーが指定したリスト内のリストエントリの順序を制御できるようにします。リストエントリは、挿入または再配置したり、リストの最初または最後のエントリとして配置したり、別の特定のエントリの前または後に配置したりできます。"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement is covered in Section 7.7.7.",
      "ja": "「ordered-by」ステートメントについては、セクション7.7.7で説明しています。"
    },
    {
      "indent": 0,
      "text": "7.7.2. The leaf-list's Default Values",
      "section_title": true,
      "ja": "7.7.2. リーフリストのデフォルト値"
    },
    {
      "indent": 3,
      "text": "The default values of a leaf-list are the values that the server uses if the leaf-list does not exist in the data tree. The usage of the default values depends on the leaf-list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "リーフリストのデフォルト値は、データツリーにリーフリストが存在しない場合にサーバーが使用する値です。デフォルト値の使用法は、存在しないコンテナではないスキーマツリー内のリーフリストの最も近い祖先ノードに依存します（セクション7.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default values MUST be used.",
      "ja": "o そのような祖先がスキーマツリーに存在しない場合は、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default values MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "ja": "o それ以外の場合、この祖先がケースノードである場合、ケースのいずれかのノードがデータツリーに存在するか、ケースノードが選択肢のデフォルトケースであり、他のケースのノードがデータツリーに存在しない場合、デフォルト値を使用する必要があります。 。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default values MUST be used if the ancestor node exists in the data tree.",
      "ja": "o それ以外の場合、祖先ノードがデータツリーに存在する場合は、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default values are said to be in use.",
      "ja": "これらの場合、デフォルト値が使用中であると言われます。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf-list or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default values are not in use.",
      "ja": "リーフリストまたはその祖先に「when」条件または「false」と評価される「if-feature」式がある場合、デフォルト値は使用されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the default values are in use, the server MUST operationally behave as if the leaf-list was present in the data tree with the default values as its values.",
      "ja": "デフォルト値が使用されている場合、サーバーは、デフォルト値を値として持つリーフリストがデータツリーに存在するかのように操作上動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list has one or more \"default\" statements, the leaf-list's default values are the values of the \"default\" statements, and if the leaf-list is user ordered, the default values are used in the order of the \"default\" statements. Otherwise, if the leaf-list's type has a default value and the leaf-list does not have a \"min-elements\" statement with a value greater than or equal to one, then the leaf-list's default value is one instance of the type's default value. In all other cases, the leaf-list does not have any default values.",
      "ja": "リーフリストに1つ以上の「デフォルト」ステートメントがある場合、リーフリストのデフォルト値は「デフォルト」ステートメントの値であり、リーフリストがユーザー順である場合、デフォルト値は「デフォルト」ステートメント。それ以外の場合、リーフリストのタイプにデフォルト値があり、リーフリストに1以上の値を持つ「min-elements」ステートメントがない場合、リーフリストのデフォルト値はタイプの1つのインスタンスです。デフォルト値。他のすべての場合では、リーフリストにデフォルト値はありません。"
    },
    {
      "indent": 0,
      "text": "7.7.3. The leaf-list's Substatements",
      "section_title": true,
      "ja": "7.7.3. リーフリストのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.7.4   | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.4     | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.7.4. The leaf-list's \"default\" Statement",
      "section_title": true,
      "ja": "7.7.4. リーフリストの「デフォルト」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf-list.",
      "ja": "オプションの「デフォルト」ステートメントは、リーフリストのデフォルト値を含む文字列を引数として受け取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf-list's \"type\" statement.",
      "ja": "「デフォルト」ステートメントの値は、リーフリストの「タイプ」ステートメントで指定されたタイプに従って有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"min-elements\" has a value greater than or equal to one.",
      "ja": "「デフォルト」ステートメントは、「min-elements」が1以上の値を持つノードに存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "7.7.5. The \"min-elements\" Statement",
      "section_title": true,
      "ja": "7.7.5. 「min-elements」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"min-elements\" statement, which is optional, takes as an argument a non-negative integer that puts a constraint on valid list entries. A valid leaf-list or list MUST have at least min-elements entries.",
      "ja": "オプションの「min-elements」ステートメントは、有効なリストエントリに制約を課す負でない整数を引数として取ります。有効なリーフリストまたはリストには、少なくともmin-elementsエントリが必要です。"
    },
    {
      "indent": 3,
      "text": "If no \"min-elements\" statement is present, it defaults to zero.",
      "ja": "「min-elements」ステートメントが存在しない場合、デフォルトでゼロになります。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the leaf-list's or list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "制約の動作は、存在しないコンテナではないスキーマツリー内のリーフリストまたはリストの最も近い祖先ノードのタイプに依存します（セクション7.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "ja": "o そのような祖先がスキーマツリーに存在しない場合、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "ja": "o それ以外の場合、この祖先がケースノードの場合、ケースの他のノードが存在する場合に制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "ja": "o それ以外の場合、祖先ノードが存在する場合は強制されます。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "ja": "制約は、セクション8のルールに従ってさらに適用されます。"
    },
    {
      "indent": 0,
      "text": "7.7.6. The \"max-elements\" Statement",
      "section_title": true,
      "ja": "7.7.6. 「max-elements」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" statement, which is optional, takes as an argument a positive integer or the string \"unbounded\", which puts a constraint on valid list entries. A valid leaf-list or list always has at most max-elements entries.",
      "ja": "「max-elements」ステートメントはオプションであり、有効なリストエントリに制約を課す正の整数または文字列「unbounded」を引数として取ります。有効なリーフリストまたはリストには、常に最大でmax-elements個のエントリがあります。"
    },
    {
      "indent": 3,
      "text": "If no \"max-elements\" statement is present, it defaults to \"unbounded\".",
      "ja": "「max-elements」ステートメントが存在しない場合、デフォルトは「無制限」になります。"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" constraint is enforced according to the rules in Section 8.",
      "ja": "「max-elements」制約は、セクション8のルールに従って適用されます。"
    },
    {
      "indent": 0,
      "text": "7.7.7. The \"ordered-by\" Statement",
      "section_title": true,
      "ja": "7.7.7. 「ordered-by」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement defines whether the order of entries within a list are determined by the user or the system. The argument is one of the strings \"system\" or \"user\". If not present, ordering defaults to \"system\".",
      "ja": "「ordered-by」ステートメントは、リスト内のエントリーの順序がユーザーとシステムのどちらによって決定されるかを定義します。引数は、文字列「system」または「user」のいずれかです。存在しない場合、順序付けはデフォルトで「システム」になります。"
    },
    {
      "indent": 3,
      "text": "This statement is ignored if the list represents state data, RPC output parameters, or notification content.",
      "ja": "リストが状態データ、RPC出力パラメーター、または通知コンテンツを表す場合、このステートメントは無視されます。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.1 for additional information.",
      "ja": "追加情報については、セクション7.7.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.7.1. ordered-by system",
      "section_title": true,
      "ja": "7.7.7.1. 注文システム"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order determined by the system. The \"description\" string for the list may suggest an order to the server implementor. If not, an implementation is free to order the entries in any order. An implementation SHOULD use the same order for the same data, regardless of how the data were created. Using a deterministic order will make comparisons possible using simple tools like \"diff\".",
      "ja": "リストのエントリは、システムによって決定された順序に従って並べられます。リストの「説明」文字列は、サーバーの実装者に注文を示唆する場合があります。そうでない場合、実装はエントリを任意の順序で自由に順序付けできます。実装では、データの作成方法に関係なく、同じデータに同じ順序を使用する必要があります（SHOULD）。確定的な順序を使用すると、「diff」などの単純なツールを使用して比較が可能になります。"
    },
    {
      "indent": 3,
      "text": "This is the default order.",
      "ja": "これがデフォルトの順序です。"
    },
    {
      "indent": 0,
      "text": "7.7.7.2. ordered-by user",
      "section_title": true,
      "ja": "7.7.7.2. 注文したユーザー"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order defined by the user. In NETCONF, this order is controlled by using special XML attributes in the <edit-config> request. See Section 7.7.9 for details.",
      "ja": "リストのエントリは、ユーザーが定義した順序に従って並べられます。 NETCONFでは、この順序は<edit-config>リクエストで特別なXML属性を使用して制御されます。詳細については、セクション7.7.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.8. XML Encoding Rules",
      "section_title": true,
      "ja": "7.7.8. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "A leaf-list node is encoded as a series of XML elements. Each element's local name is the leaf-list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "リーフリストノードは、一連のXML要素としてエンコードされます。各要素のローカル名はリーフリストの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The value of each leaf-list entry is encoded to XML according to the type and is sent as character data in the element.",
      "ja": "各リーフリストエントリの値は、タイプに従ってXMLにエンコードされ、要素内の文字データとして送信されます。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing leaf-list entries MUST appear in the order specified by the user if the leaf-list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing leaf-list entries MAY be interleaved with elements for siblings of the leaf-list, unless the leaf-list defines RPC or action input or output parameters.",
      "ja": "リーフリストが「ordered-by user」の場合、リーフリストエントリを表すXML要素は、ユーザーが指定した順序で出現する必要があります。それ以外の場合、順序は実装に依存します。リーフリストがRPCまたはアクションの入力または出力パラメーターを定義していない限り、リーフリストエントリを表すXML要素は、リーフリストの兄弟の要素とインターリーブされる場合があります。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.10 for an example.",
      "ja": "例については、7.7.10項を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.9. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.7.9. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "Leaf-list entries can be created and deleted, but not modified, through <edit-config>, by using the \"operation\" attribute in the leaf-list entry's XML element.",
      "ja": "リーフリストエントリは、<edit-config>を通じて、リーフリストエントリのXML要素の \"operation\"属性を使用して作成および削除できますが、変更はできません。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" leaf-list, the attributes \"insert\" and \"value\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the leaf-list the entry is inserted. These can be used during \"create\" operations to insert a new leaf-list entry, or during \"merge\" or \"replace\" operations to insert a new leaf-list entry or move an existing one.",
      "ja": "\"ordered-by user\"リーフリストでは、YANG XML名前空間（セクション5.3.1）の属性 \"insert\"および \"value\"を使用して、リーフリストのどこにエントリを挿入するかを制御できます。これらは、新しいリーフリストエントリを挿入する「作成」操作、または新しいリーフリストエントリを挿入するか、既存のエントリを移動する「マージ」または「置換」操作中に使用できます。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"value\" attribute MUST also be used to specify an existing entry in the leaf-list.",
      "ja": "「挿入」属性は、「最初」、「最後」、「前」、および「後」の値を取ることができます。値が「before」または「after」の場合、「value」属性を使用して、リーフリストの既存のエントリを指定する必要もあります。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "ja": "「作成」操作に「挿入」属性が存在しない場合、デフォルトで「最後」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" leaf-list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "ja": "「ordered-by user」リーフリストの複数のエントリが同じ<edit-config>リクエストで変更された場合、エントリはリクエストのXML要素の順序で一度に1つずつ変更されます。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire leaf-list, the leaf-list order is the same as the order of the XML elements in the request.",
      "ja": "<copy-config>または<edit-config>で、リーフリスト全体を対象とする「replace」操作では、リーフリストの順序は、リクエスト内のXML要素の順序と同じです。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a leaf-list node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>要求を処理するとき、リーフリストノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the leaf-list entry is created if it does not exist.",
      "ja": "o 操作が「マージ」または「置換」の場合、リーフリストエントリが存在しない場合は作成されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the leaf-list entry is created if it does not exist. If the leaf-list entry already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、リーフリストエントリが存在しない場合は作成されます。リーフリストエントリがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the leaf-list if it exists. If the leaf-list entry does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、エントリはリーフリストから削除されます（存在する場合）。リーフリストエントリが存在しない場合、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.7.10. Usage Example",
      "section_title": true,
      "ja": "7.7.10. 使用例"
    },
    {
      "indent": 5,
      "text": "leaf-list allow-user {\n  type string;\n  description\n    \"A list of user name patterns to allow.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<allow-user>alice</allow-user>\n<allow-user>bob</allow-user>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To create a new element in this list, using the default <edit-config> operation \"merge\":",
      "ja": "このリストに新しい要素を作成するには、デフォルトの<edit-config>操作「merge」を使用します。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <allow-user>eric</allow-user>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user leaf-list:",
      "ja": "次のordered-byユーザーリーフリストがあるとします。"
    },
    {
      "indent": 5,
      "text": "leaf-list cipher {\n  type string;\n  ordered-by user;\n  description\n    \"A list of ciphers.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new cipher \"blowfish-cbc\" after \"3des-cbc\":",
      "ja": "以下は、「3des-cbc」の後に新しい暗号「blowfish-cbc」を挿入するために使用されます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <cipher nc:operation=\"create\"\n                    yang:insert=\"after\"\n                    yang:value=\"3des-cbc\">blowfish-cbc</cipher>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.8. The \"list\" Statement",
      "section_title": true,
      "ja": "7.8. 「リスト」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is used to define an interior data node in the schema tree. A list node may exist in multiple instances in the data tree. Each such instance is known as a list entry. The \"list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed list information.",
      "ja": "「list」ステートメントは、スキーマツリーの内部データノードを定義するために使用されます。リストノードは、データツリーの複数のインスタンスに存在する場合があります。このような各インスタンスは、リストエントリと呼ばれます。 「リスト」ステートメントは、1つの引数（識別子）を受け取り、その後に詳細なリスト情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "A list entry is uniquely identified by the values of the list's keys, if defined.",
      "ja": "リストエントリは、定義されている場合、リストのキーの値によって一意に識別されます。"
    },
    {
      "indent": 0,
      "text": "7.8.1. The list's Substatements",
      "section_title": true,
      "ja": "7.8.1. リストのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| key          | 7.8.2   | 0..1        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| unique       | 7.8.3   | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.8.2. The list's \"key\" Statement",
      "section_title": true,
      "ja": "7.8.2. リストの「キー」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"key\" statement, which MUST be present if the list represents configuration and MAY be present otherwise, takes as an argument a string that specifies a space-separated list of one or more leaf identifiers of this list. A leaf identifier MUST NOT appear more than once in the key. Each such leaf identifier MUST refer to a child leaf of the list. The leafs can be defined directly in substatements to the list or in groupings used in the list.",
      "ja": "「key」ステートメントは、リストが構成を表す場合は必ず存在し、そうでない場合は存在する場合がありますが、このリストの1つ以上のリーフ識別子のスペース区切りリストを指定する文字列を引数として取ります。リーフ識別子は、キーに複数回出現してはなりません（MUST NOT）。このようなリーフ識別子はそれぞれ、リストの子リーフを参照する必要があります。リーフは、リストのサブステートメントまたはリストで使用されるグループで直接定義できます。"
    },
    {
      "indent": 3,
      "text": "The combined values of all the leafs specified in the key are used to uniquely identify a list entry. All key leafs MUST be given values when a list entry is created. Thus, any default values in the key leafs or their types are ignored. Any \"mandatory\" statements in the key leafs are ignored.",
      "ja": "キーで指定されたすべての葉の値を組み合わせて、リストエントリを一意に識別します。リストエントリの作成時に、すべてのキーリーフに値を指定する必要があります。したがって、キーリーフのデフォルト値またはそのタイプは無視されます。キーリーフの「必須」ステートメントは無視されます。"
    },
    {
      "indent": 3,
      "text": "A leaf that is part of the key can be of any built-in or derived type.",
      "ja": "キーの一部であるリーフは、任意の組み込み型または派生型にすることができます。"
    },
    {
      "indent": 3,
      "text": "All key leafs in a list MUST have the same value for their \"config\" as the list itself.",
      "ja": "リスト内のすべてのキーリーフは、 \"config\"にリスト自体と同じ値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "The key string syntax is formally defined by the rule \"key-arg\" in Section 14.",
      "ja": "キー文字列の構文は、セクション14のルール「key-arg」によって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "7.8.3. The list's \"unique\" Statement",
      "section_title": true,
      "ja": "7.8.3. リストの「ユニークな」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"unique\" statement is used to put constraints on valid list entries. It takes as an argument a string that contains a space-separated list of schema node identifiers, which MUST be given in the descendant form (see the rule \"descendant-schema-nodeid\" in Section 14). Each such schema node identifier MUST refer to a leaf.",
      "ja": "「ユニーク」ステートメントは、有効なリストエントリに制約を課すために使用されます。引数として、スキーマノード識別子のスペースで区切られたリストを含む文字列を受け取ります。これは、子孫の形式で指定する必要があります（セクション14の「descendant-schema-nodeid」のルールを参照）。このような各スキーマノード識別子はリーフを参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "If one of the referenced leafs represents configuration data, then all of the referenced leafs MUST represent configuration data.",
      "ja": "参照されるリーフの1つが構成データを表す場合、参照されるすべてのリーフが構成データを表す必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"unique\" constraint specifies that the combined values of all the leaf instances specified in the argument string, including leafs with default values, MUST be unique within all list entry instances in which all referenced leafs exist or have default values. The constraint is enforced according to the rules in Section 8.",
      "ja": "「一意の」制約は、デフォルト値のリーフを含む、引数文字列で指定されたすべてのリーフインスタンスの結合値が、参照されるすべてのリーフが存在するすべてのリストエントリインスタンス内で一意であるか、デフォルト値を持つ必要があることを指定します。制約は、セクション8のルールに従って実施されます。"
    },
    {
      "indent": 3,
      "text": "The unique string syntax is formally defined by the rule \"unique-arg\" in Section 14.",
      "ja": "一意の文字列構文は、セクション14のルール「unique-arg」によって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "7.8.3.1. Usage Example",
      "section_title": true,
      "ja": "7.8.3.1. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "ja": "次のリストで："
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"name\";\n  unique \"ip port\";\n  leaf name {\n    type string;\n  }\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following configuration is not valid:",
      "ja": "次の構成は無効です。"
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following configuration is valid, since the \"http\" and \"ftp\" list entries do not have a value for all referenced leafs and are thus not taken into account when the \"unique\" constraint is enforced:",
      "ja": "「http」と「ftp」のリストエントリには、参照されるすべてのリーフの値がないため、「一意」の制約が適用されている場合は考慮されないため、次の構成は有効です。"
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>ftp</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.8.4. The list's Child Node Statements",
      "section_title": true,
      "ja": "7.8.4. リストの子ノードステートメント"
    },
    {
      "indent": 3,
      "text": "Within a list, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the list.",
      "ja": "リスト内では、「container」、「leaf」、「list」、「leaf-list」、「uses」、「choice」、「anydata」、および「anyxml」ステートメントを使用して、リストに子ノードを定義できます。 。"
    },
    {
      "indent": 0,
      "text": "7.8.5. XML Encoding Rules",
      "section_title": true,
      "ja": "7.8.5. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "A list is encoded as a series of XML elements, one for each entry in the list. Each element's local name is the list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). There is no XML element surrounding the list as a whole.",
      "ja": "リストは一連のXML要素としてエンコードされ、リストの各エントリに1つずつ含まれます。各要素のローカル名はリストの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。リスト全体を囲むXML要素はありません。"
    },
    {
      "indent": 3,
      "text": "The list's key nodes are encoded as subelements to the list's identifier element, in the same order as they are defined within the \"key\" statement.",
      "ja": "リストのキーノードは、 \"key\"ステートメント内で定義されているのと同じ順序で、リストの識別子要素のサブ要素としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "The rest of the list's child nodes are encoded as subelements to the list element, after the keys. If the list defines RPC or action input or output parameters, the subelements are encoded in the same order as they are defined within the \"list\" statement. Otherwise, the subelements are encoded in any order.",
      "ja": "リストの残りの子ノードは、キーの後、リスト要素のサブ要素としてエンコードされます。リストがRPCまたはアクションの入力または出力パラメーターを定義している場合、サブエレメントは、「list」ステートメント内で定義されているのと同じ順序でエンコードされます。それ以外の場合、サブ要素は任意の順序でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the list entry is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "ja": "リストエントリのサブ要素間の空白は重要ではありません。つまり、実装はサブ要素間に空白文字を挿入できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing list entries MUST appear in the order specified by the user if the list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing list entries MAY be interleaved with elements for siblings of the list, unless the list defines RPC or action input or output parameters.",
      "ja": "リストが「ordered-by user」の場合、リストエントリを表すXML要素は、ユーザーが指定した順序で出現する必要があります。それ以外の場合、順序は実装に依存します。リストがRPCまたはアクションの入力または出力パラメーターを定義していない限り、リストエントリを表すXML要素は、リストの兄弟の要素とインターリーブされる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.8.6. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.8.6. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "List entries can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute in the list's XML element. In each case, the values of all keys are used to uniquely identify a list entry. If all keys are not specified for a list entry, a \"missing-element\" error is returned.",
      "ja": "リストのエントリは、<edit-config>でリストのXML要素の「operation」属性を使用して作成、削除、置換、および変更できます。いずれの場合も、すべてのキーの値を使用して、リストエントリを一意に識別します。リストエントリにすべてのキーが指定されていない場合、「missing-element」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" list, the attributes \"insert\" and \"key\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the list the entry is inserted. These can be used during \"create\" operations to insert a new list entry, or during \"merge\" or \"replace\" operations to insert a new list entry or move an existing one.",
      "ja": "\"ordered-by user\"リストでは、YANG XML名前空間（セクション5.3.1）の属性 \"insert\"および \"key\"を使用して、リストのどこにエントリを挿入するかを制御できます。これらは、「作成」操作中に新しいリストエントリを挿入するとき、または「マージ」または「置換」操作中に新しいリストエントリを挿入するか、既存のリストエントリを移動するときに使用できます。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"key\" attribute MUST also be used, to specify an existing element in the list. The value of the \"key\" attribute is the key predicates of the full instance identifier (see Section 9.13) for the list entry.",
      "ja": "「挿入」属性は、「最初」、「最後」、「前」、および「後」の値を取ることができます。値が「before」または「after」の場合、「key」属性も使用して、リスト内の既存の要素を指定する必要があります。 「key」属性の値は、リストエントリの完全なインスタンス識別子（9.13項を参照）のキー述語です。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "ja": "「作成」操作に「挿入」属性が存在しない場合、デフォルトで「最後」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "ja": "「ordered-by user」リストの複数のエントリが同じ<edit-config>リクエストで変更される場合、エントリはリクエストのXML要素の順序で一度に1つずつ変更されます。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire list, the list entry order is the same as the order of the XML elements in the request.",
      "ja": "<copy-config>またはリスト全体を対象とする「replace」操作を含む<edit-config>では、リストエントリの順序は、リクエスト内のXML要素の順序と同じです。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a list node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>要求を処理する場合、リストノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the list entry is created if it does not exist. If the list entry already exists and the \"insert\" and \"key\" attributes are present, the list entry is moved according to the values of the \"insert\" and \"key\" attributes. If the list entry exists and the \"insert\" and \"key\" attributes are not present, the list entry is not moved.",
      "ja": "o 操作が「マージ」または「置換」の場合、リストエントリが存在しない場合は作成されます。リストエントリがすでに存在し、「挿入」および「キー」属性が存在する場合、リストエントリは「挿入」および「キー」属性の値に従って移動されます。リストエントリが存在し、 \"insert\"および \"key\"属性が存在しない場合、リストエントリは移動されません。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the list entry is created if it does not exist. If the list entry already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、リストエントリが存在しない場合は作成されます。リストエントリがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the list if it exists. If the list entry does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、エントリが存在する場合はリストから削除されます。リストエントリが存在しない場合は、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.8.7. Usage Example",
      "section_title": true,
      "ja": "7.8.7. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following list:",
      "ja": "次のリストがあるとします。"
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  config true;\n  description\n    \"This is a list of users in the system.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>fred</name>\n  <type>admin</type>\n  <full-name>Fred Flintstone</full-name>\n</user>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To create a new user \"barney\":",
      "ja": "新しいユーザー「barney」を作成するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <user nc:operation=\"create\">\n          <name>barney</name>\n          <type>admin</type>\n          <full-name>Barney Rubble</full-name>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To change the type of \"fred\" to \"superuser\":",
      "ja": "「fred」のタイプを「スーパーユーザー」に変更するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <user>\n          <name>fred</name>\n          <type>superuser</type>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user list:",
      "ja": "次のordered-byユーザーリストがあるとします。"
    },
    {
      "indent": 5,
      "text": "list user {\n  description\n    \"This is a list of users in the system.\";\n  ordered-by user;\n  config true;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "key \"first-name surname\";",
      "ja": "キー「姓」;"
    },
    {
      "indent": 5,
      "text": "  leaf first-name {\n    type string;\n  }\n  leaf surname {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new user \"barney rubble\" after the user \"fred flintstone\":",
      "ja": "以下は、ユーザー「fred flintstone」の後に新しいユーザー「barney rubble」を挿入するために使用されます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\"\n           xmlns:ex=\"urn:example:config\">\n        <user nc:operation=\"create\"\n              yang:insert=\"after\"\n              yang:key=\"[ex:first-name='fred']\n                        [ex:surname='flintstone']\">\n          <first-name>barney</first-name>\n          <surname>rubble</surname>\n          <type>admin</type>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following would be used to move the user \"barney rubble\" before the user \"fred flintstone\":",
      "ja": "次のコードは、ユーザー「frney flintstone」の前にユーザー「barney rubble」を移動するために使用されます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\"\n           xmlns:ex=\"urn:example:config\">\n        <user nc:operation=\"merge\"\n              yang:insert=\"before\"\n              yang:key=\"[ex:name='fred']\n                        [ex:surname='flintstone']\">\n          <first-name>barney</first-name>\n          <surname>rubble</surname>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.9. The \"choice\" Statement",
      "section_title": true,
      "ja": "7.9. 「選択」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement defines a set of alternatives, only one of which may be present in any one data tree. The argument is an identifier, followed by a block of substatements that holds detailed choice information. The identifier is used to identify the choice node in the schema tree. A choice node does not exist in the data tree.",
      "ja": "「選択」ステートメントは、一連の代替案を定義します。そのうちの1つだけが、任意の1つのデータツリーに存在できます。引数は識別子であり、その後に詳細な選択情報を保持するサブステートメントのブロックが続きます。識別子は、スキーマツリーで選択ノードを識別するために使用されます。選択ノードがデータツリーに存在しません。"
    },
    {
      "indent": 3,
      "text": "A choice consists of a number of branches, each defined with a \"case\" substatement. Each branch contains a number of child nodes. The nodes from at most one of the choice's branches exist at the same time.",
      "ja": "選択肢は、それぞれが「ケース」サブステートメントで定義されたいくつかのブランチで構成されます。各ブランチには、いくつかの子ノードが含まれています。選択肢の最大で1つのブランチからのノードが同時に存在します。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time in the data tree, the creation of a node from one case implicitly deletes all nodes from all other cases. If a request creates a node from a case, the server will delete any existing nodes that are defined in other cases inside the choice.",
      "ja": "データツリーではいつでも選択肢の1つのケースのみが有効であるため、1つのケースからノードを作成すると、他のすべてのケースからすべてのノードが暗黙的に削除されます。リクエストがケースからノードを作成する場合、サーバーは、他のケースで選択内に定義されている既存のノードを削除します。"
    },
    {
      "indent": 0,
      "text": "7.9.1. The choice's Substatements",
      "section_title": true,
      "ja": "7.9.1. 選択のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| default      | 7.9.3   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| mandatory    | 7.9.4   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.9.2. The choice's \"case\" Statement",
      "section_title": true,
      "ja": "7.9.2. 選択の「ケース」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"case\" statement is used to define branches of the choice. It takes as an argument an identifier, followed by a block of substatements that holds detailed case information.",
      "ja": "「case」ステートメントは、選択したブランチを定義するために使用されます。引数として識別子を受け取り、その後に詳細なケース情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The identifier is used to identify the case node in the schema tree. A case node does not exist in the data tree.",
      "ja": "識別子は、スキーマツリーでケースノードを識別するために使用されます。ケースノードがデータツリーに存在しません。"
    },
    {
      "indent": 3,
      "text": "Within a \"case\" statement, the \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", \"leaf-list\", and \"uses\" statements can be used to define child nodes to the case node. The identifiers of all these child nodes MUST be unique within all cases in a choice. For example, the following is illegal:",
      "ja": "「case」ステートメント内では、「anydata」、「anyxml」、「choice」、「container」、「leaf」、「list」、「leaf-list」、および「uses」ステートメントを使用して子ノードを定義できます。ケースノードに。これらすべての子ノードの識別子は、選択されたすべてのケースで一意である必要があります。たとえば、以下は不正です。"
    },
    {
      "indent": 5,
      "text": "choice interface-type {     // This example is illegal YANG\n  case a {\n    leaf ethernet { ... }\n  }\n  case b {\n    container ethernet { ...}\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As a shorthand, the \"case\" statement can be omitted if the branch contains a single \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", or \"leaf-list\" statement. In this case, the case node still exists in the schema tree, and its identifier is the same as the identifier of the child node. Schema node identifiers (Section 6.5) MUST always explicitly include case node identifiers. The following example:",
      "ja": "省略形として、ブランチに単一の「anydata」、「anyxml」、「choice」、「container」、「leaf」、「list」、または「leaf-list」ステートメントが含まれている場合、「case」ステートメントは省略できます。この場合、ケースノードはスキーマツリーにまだ存在し、その識別子は子ノードの識別子と同じです。スキーマノード識別子（セクション6.5）には、常に明示的にケースノード識別子を含める必要があります。次の例："
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n  container ethernet { ... }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is equivalent to:",
      "ja": "以下と同等です。"
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n  case ethernet {\n    container ethernet { ... }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The case identifier MUST be unique within a choice.",
      "ja": "ケース識別子は選択肢内で一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "7.9.2.1. The case's Substatements",
      "section_title": true,
      "ja": "7.9.2.1. ケースのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.9.3. The choice's \"default\" Statement",
      "section_title": true,
      "ja": "7.9.3. 選択の「デフォルト」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement indicates if a case should be considered as the default if no child nodes from any of the choice's cases exist. The argument is the identifier of the default \"case\" statement. If the \"default\" statement is missing, there is no default case.",
      "ja": "「デフォルト」ステートメントは、選択のいずれかのケースの子ノードが存在しない場合に、ケースをデフォルトと見なす必要があるかどうかを示します。引数は、デフォルトの「case」ステートメントの識別子です。 「デフォルト」ステートメントがない場合、デフォルトのケースはありません。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on choices where \"mandatory\" is \"true\".",
      "ja": "「デフォルト」ステートメントは、「必須」が「true」である選択肢に存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The default case is only important when considering the \"default\" statements of nodes under the cases (i.e., default values of leafs and leaf-lists, and default cases of nested choices). The default values and nested default cases under the default case are used if none of the nodes under any of the cases are present.",
      "ja": "デフォルトのケースは、ケースの下のノードの「デフォルト」ステートメント（つまり、リーフとリーフリストのデフォルト値、およびネストされた選択肢のデフォルトのケース）を検討する場合にのみ重要です。いずれのケースにもノードが存在しない場合、デフォルト値とデフォルトケースの下にネストされたデフォルトケースが使用されます。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any mandatory nodes (Section 3) directly under the default case.",
      "ja": "デフォルトのケースの直下に必須ノード（セクション3）があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Default values for child nodes under a case are only used if one of the nodes under that case is present or if that case is the default case. If none of the nodes under a case are present and the case is not the default case, the default values of the cases' child nodes are ignored.",
      "ja": "ケースの下の子ノードのデフォルト値は、そのケースの下のノードの1つが存在する場合、またはそのケースがデフォルトのケースである場合にのみ使用されます。ケースの下にノードが存在せず、ケースがデフォルトのケースでない場合、ケースの子ノードのデフォルト値は無視されます。"
    },
    {
      "indent": 3,
      "text": "In this example, the choice defaults to \"interval\", and the default value will be used if none of \"daily\", \"time-of-day\", or \"manual\" are present. If \"daily\" is present, the default value for \"time-of-day\" will be used.",
      "ja": "この例では、デフォルトで「interval」が選択され、「daily」、「time-of-day」、または「manual」が存在しない場合はデフォルト値が使用されます。 「毎日」が存在する場合、「時刻」のデフォルト値が使用されます。"
    },
    {
      "indent": 5,
      "text": "container transfer {\n  choice how {\n    default interval;\n    case interval {\n      leaf interval {\n        type uint16;\n        units minutes;\n        default 30;\n      }\n    }\n    case daily {\n      leaf daily {\n        type empty;\n      }\n      leaf time-of-day {\n        type string;\n        units 24-hour-clock;\n        default \"01.00\";\n      }\n    }\n    case manual {\n      leaf manual {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.9.4. The choice's \"mandatory\" Statement",
      "section_title": true,
      "ja": "7.9.4. 選択の「必須」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If \"mandatory\" is \"true\", at least one node from exactly one of the choice's case branches MUST exist.",
      "ja": "オプションの「必須」ステートメントは、ストリングとして「true」または「false」を引数として取り、有効なデータに制約を課します。 「必須」が「真」の場合、選択のケースブランチの1つからのノードが少なくとも1つ存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "If not specified, the default is \"false\".",
      "ja": "指定しない場合、デフォルトは「false」です。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the choice's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "制約の動作は、非存在コンテナではないスキーマツリー内の選択の最も近い祖先ノードのタイプに依存します（セクション7.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "ja": "o そのような祖先がスキーマツリーに存在しない場合、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "ja": "o それ以外の場合、この祖先がケースノードの場合、ケースの他のノードが存在する場合に制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "ja": "o それ以外の場合、祖先ノードが存在する場合は強制されます。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "ja": "制約は、セクション8のルールに従ってさらに適用されます。"
    },
    {
      "indent": 0,
      "text": "7.9.5. XML Encoding Rules",
      "section_title": true,
      "ja": "7.9.5. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes are not visible in XML.",
      "ja": "選択ノードとケースノードはXMLでは表示されません。"
    },
    {
      "indent": 3,
      "text": "The child nodes of the selected \"case\" statement MUST be encoded in the same order as they are defined in the \"case\" statement if they are part of an RPC or action input or output parameter definition. Otherwise, the subelements are encoded in any order.",
      "ja": "選択した「case」ステートメントの子ノードは、RPCまたはアクションの入力または出力パラメーター定義の一部である場合、「case」ステートメントで定義されているのと同じ順序でエンコードする必要があります。それ以外の場合、サブ要素は任意の順序でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.9.6. Usage Example",
      "section_title": true,
      "ja": "7.9.6. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following choice:",
      "ja": "次の選択肢があるとします。"
    },
    {
      "indent": 5,
      "text": "container protocol {\n  choice name {\n    case a {\n      leaf udp {\n        type empty;\n      }\n    }\n    case b {\n      leaf tcp {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<protocol>\n  <tcp/>\n</protocol>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To change the protocol from TCP to UDP:",
      "ja": "プロトコルをTCPからUDPに変更するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <protocol>\n          <udp nc:operation=\"create\"/>\n        </protocol>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.10. The \"anydata\" Statement",
      "section_title": true,
      "ja": "7.10. 「anydata」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anydata information.",
      "ja": "「anydata」ステートメントは、スキーマツリーの内部ノードを定義します。 1つの引数（識別子）を受け取り、その後に詳細なanydata情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement is used to represent an unknown set of nodes that can be modeled with YANG, except anyxml, but for which the data model is not known at module design time. It is possible, though not required, for the data model for anydata content to become known through protocol signaling or other means that are outside the scope of this document.",
      "ja": "「anydata」ステートメントは、anyxmlを除いて、YANGでモデル化できるノードの未知のセットを表すために使用されますが、データモデルはモジュール設計時に不明です。必須ではありませんが、データコンテンツのデータモデルが、このドキュメントの範囲外であるプロトコルシグナリングまたはその他の手段によって認識される可能性があります。"
    },
    {
      "indent": 3,
      "text": "An example of where anydata can be useful is a list of received notifications where the specific notifications are not known at design time.",
      "ja": "anydataが役立つ例としては、特定の通知が設計時に不明な場合に受信される通知のリストがあります。"
    },
    {
      "indent": 3,
      "text": "An anydata node cannot be augmented (see Section 7.17).",
      "ja": "anydataノードは拡張できません（セクション7.17を参照）。"
    },
    {
      "indent": 3,
      "text": "An anydata node exists in zero or one instance in the data tree.",
      "ja": "anydataノードは、データツリーの0または1つのインスタンスに存在します。"
    },
    {
      "indent": 3,
      "text": "An implementation may or may not know the data model used to model a specific instance of an anydata node.",
      "ja": "実装は、anydataノードの特定のインスタンスをモデル化するために使用されるデータモデルを知っている場合と知らない場合があります。"
    },
    {
      "indent": 3,
      "text": "Since the use of anydata limits the manipulation of the content, the \"anydata\" statement SHOULD NOT be used to define configuration data.",
      "ja": "anydataを使用するとコンテンツの操作が制限されるため、「anydata」ステートメントを使用して構成データを定義することはできません（SHOULD NOT）。"
    },
    {
      "indent": 0,
      "text": "7.10.1. The anydata's Substatements",
      "section_title": true,
      "ja": "7.10.1. anydataのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.10.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.10.2. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "An anydata node is encoded as an XML element. The element's local name is the anydata's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anydata node is a set of nodes, which are encoded as XML subelements to the anydata element.",
      "ja": "anydataノードは、XML要素としてエンコードされます。要素のローカル名はanydataの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。 anydataノードの値はノードのセットであり、XMLサブエレメントとしてanydataエレメントにエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.10.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.10.3. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "An anydata node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "ja": "anydataノードは、不透明なデータのチャンクとして扱われます。このデータは、全体のみを変更できます。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anydata node are ignored by the NETCONF server.",
      "ja": "anydataノードのサブエレメントに存在する「操作」属性は、NETCONFサーバーによって無視されます。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anydata node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>要求を処理するとき、anydataノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data.",
      "ja": "o 操作が「マージ」または「置換」の場合、ノードが存在しない場合はノードが作成され、その値はXML RPCデータで見つかったanydataノードのサブ要素に設定されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、ノードが存在しない場合はノードが作成され、その値はXML RPCデータで見つかったanydataノードのサブ要素に設定されます。ノードがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、ノードが存在すると削除されます。ノードが存在しない場合、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.10.4. Usage Example",
      "section_title": true,
      "ja": "7.10.4. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anydata\" statement:",
      "ja": "次の「anydata」ステートメントがあるとします。"
    },
    {
      "indent": 5,
      "text": "list logged-notification {\n  key time;\n  leaf time {\n    type yang:date-and-time;\n  }\n  anydata data;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following is a valid encoding of such a list instance:",
      "ja": "以下は、そのようなリストインスタンスの有効なエンコーディングです。"
    },
    {
      "indent": 5,
      "text": "<logged-notification>\n  <time>2014-07-29T13:43:12Z</time>\n  <data>\n    <notification\n      xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n      <eventTime>2014-07-29T13:43:01Z</eventTime>\n      <event xmlns=\"urn:example:event\">\n        <event-class>fault</event-class>\n        <reporting-entity>\n          <card>Ethernet0</card>\n        </reporting-entity>\n        <severity>major</severity>\n      </event>\n    </notification>\n  </data>\n</logged-notification>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.11. The \"anyxml\" Statement",
      "section_title": true,
      "ja": "7.11. 「anyxml」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anyxml information.",
      "ja": "「anyxml」ステートメントは、スキーマツリーの内部ノードを定義します。識別子である引数を1つ取り、その後に詳細なanyxml情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement is used to represent an unknown chunk of XML. No restrictions are placed on the XML. This can be useful, for example, in RPC replies. An example is the <filter> parameter in the <get-config> operation in NETCONF.",
      "ja": "「anyxml」ステートメントは、未知のXMLチャンクを表すために使用されます。 XMLに制限はありません。これは、RPC応答などで役立ちます。例は、NETCONFの<get-config>操作の<filter>パラメータです。"
    },
    {
      "indent": 3,
      "text": "An anyxml node cannot be augmented (see Section 7.17).",
      "ja": "anyxmlノードは拡張できません（セクション7.17を参照）。"
    },
    {
      "indent": 3,
      "text": "An anyxml node exists in zero or one instance in the data tree.",
      "ja": "anyxmlノードは、データツリーのゼロまたは1つのインスタンスに存在します。"
    },
    {
      "indent": 3,
      "text": "Since the use of anyxml limits the manipulation of the content, the \"anyxml\" statement SHOULD NOT be used to define configuration data.",
      "ja": "anyxmlを使用するとコンテンツの操作が制限されるため、「anyxml」ステートメントを使用して構成データを定義しないでください。"
    },
    {
      "indent": 3,
      "text": "It should be noted that in YANG version 1, \"anyxml\" was the only statement that could model an unknown hierarchy of data. In many cases, this unknown hierarchy of data is actually modeled in YANG, but the specific YANG data model is not known at design time. In these situations, it is RECOMMENDED to use \"anydata\" (Section 7.10) instead of \"anyxml\".",
      "ja": "YANGバージョン1では、「anyxml」がデータの不明な階層をモデル化できる唯一のステートメントであったことに注意してください。多くの場合、この未知のデータ階層は実際にはYANGでモデル化されていますが、特定のYANGデータモデルは設計時には不明です。これらの状況では、「anyxml」の代わりに「anydata」（セクション7.10）を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.11.1. The anyxml's Substatements",
      "section_title": true,
      "ja": "7.11.1. anyxmlのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.11.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.11.2. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "An anyxml node is encoded as an XML element. The element's local name is the anyxml's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anyxml node is encoded as XML content of this element.",
      "ja": "anyxmlノードは、XML要素としてエンコードされます。要素のローカル名はanyxmlの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。 anyxmlノードの値は、この要素のXMLコンテンツとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Note that any XML prefixes used in the encoding are local to each instance encoding. This means that the same XML may be encoded differently by different implementations.",
      "ja": "エンコーディングで使用されるXMLプレフィックスは、各インスタンスのエンコーディングに対してローカルであることに注意してください。これは、同じXMLが異なる実装によって異なる方法でエンコードされる可能性があることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.11.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.11.3. NETCONF <edit-config>操作"
    },
    {
      "indent": 3,
      "text": "An anyxml node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "ja": "anyxmlノードは、不透明なデータのチャンクとして扱われます。このデータは、全体のみを変更できます。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anyxml node are ignored by the NETCONF server.",
      "ja": "anyxmlノードのサブ要素に存在する「操作」属性は、NETCONFサーバーによって無視されます。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anyxml node are as follows:",
      "ja": "NETCONFサーバーが<edit-config>リクエストを処理する場合、anyxmlノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data.",
      "ja": "o 操作が「マージ」または「置換」の場合、ノードが存在しない場合はノードが作成され、その値はXML RPCデータにあるanyxmlノードのXMLコンテンツに設定されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "o 操作が「作成」の場合、ノードが存在しない場合はノードが作成され、その値はXML RPCデータにあるanyxmlノードのXMLコンテンツに設定されます。ノードがすでに存在する場合、「data-exists」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "o 操作が「削除」の場合、ノードが存在すると削除されます。ノードが存在しない場合、「データ欠落」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.11.4. Usage Example",
      "section_title": true,
      "ja": "7.11.4. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anyxml\" statement:",
      "ja": "次の「anyxml」ステートメントがあるとします。"
    },
    {
      "indent": 5,
      "text": "anyxml html-info;",
      "ja": "anyxml html-info;"
    },
    {
      "indent": 3,
      "text": "The following are two valid encodings of the same anyxml value:",
      "ja": "以下は、同じanyxml値の2つの有効なエンコーディングです。"
    },
    {
      "indent": 6,
      "text": "<html-info>\n  <p xmlns=\"http://www.w3.org/1999/xhtml\">\n    This is <em>very</em> cool.\n  </p>\n</html-info>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<html-info>\n  <x:p xmlns:x=\"http://www.w3.org/1999/xhtml\">\n    This is <x:em>very</x:em> cool.\n  </x:p>\n</html-info>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.12. The \"grouping\" Statement",
      "section_title": true,
      "ja": "7.12. 「グループ化」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is used to define a reusable block of nodes, which may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed grouping information.",
      "ja": "「グループ化」ステートメントは、セクション5.5のルールに従って、モジュールまたはサブモジュールでローカルに使用できる、ノードから再利用可能なノードのブロックを定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細なグループ化情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "ja": "「グループ化」ステートメントはデータ定義ステートメントではないため、スキーマツリーのノードを定義しません。"
    },
    {
      "indent": 3,
      "text": "A grouping is like a \"structure\" or a \"record\" in conventional programming languages.",
      "ja": "グループ化は、従来のプログラミング言語の「構造」または「レコード」のようなものです。"
    },
    {
      "indent": 3,
      "text": "Once a grouping is defined, it can be referenced in a \"uses\" statement (see Section 7.13). A grouping MUST NOT reference itself, neither directly nor indirectly through a chain of other groupings.",
      "ja": "グループ化が定義されると、「uses」ステートメントで参照できます（セクション7.13を参照）。グループ化は、他のグループ化のチェーンを介して直接的または間接的にそれ自体を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the grouping is defined at the top level of a YANG module or submodule, the grouping's identifier MUST be unique within the module.",
      "ja": "グループ化がYANGモジュールまたはサブモジュールのトップレベルで定義されている場合、グループ化の識別子はモジュール内で一意である必要があります。"
    },
    {
      "indent": 0,
      "text": " A grouping is more than just a mechanism for textual substitution; it also defines a collection of nodes. Identifiers appearing inside the grouping are resolved relative to the scope in which the grouping is defined, not where it is used. Prefix mappings, type names, grouping names, and extension usage are evaluated in the hierarchy where the \"grouping\" statement appears. For extensions, this means that extensions defined as direct children to a \"grouping\" statement are applied to the grouping itself.",
      "ja": "グループ化は、単なるテキストの置換メカニズムではありません。ノードのコレクションも定義します。グループ内に表示される識別子は、グループが使用されている場所ではなく、グループが定義されているスコープに関連して解決されます。接頭辞マッピング、タイプ名、グループ化名、および拡張機能の使用は、「グループ化」ステートメントが表示される階層で評価されます。拡張機能の場合、これは「グループ化」ステートメントの直接の子として定義された拡張機能がグループ化自体に適用されることを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that if a grouping defines an action or a notification node in its hierarchy, then it cannot be used in all contexts. For example, it cannot be used in an rpc definition. See Sections 7.15 and 7.16.",
      "ja": "グループ化がその階層内でアクションまたは通知ノードを定義する場合、すべてのコンテキストで使用できるわけではないことに注意してください。たとえば、rpc定義では使用できません。セクション7.15および7.16を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.12.1. The grouping's Substatements",
      "section_title": true,
      "ja": "7.12.1. グループのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.12.2. Usage Example",
      "section_title": true,
      "ja": "7.12.2. 使用例"
    },
    {
      "indent": 5,
      "text": "import ietf-inet-types {\n  prefix \"inet\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "grouping endpoint {\n  description \"A reusable endpoint group.\";\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.13. The \"uses\" Statement",
      "section_title": true,
      "ja": "7.13. 「使用」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"uses\" statement is used to reference a \"grouping\" definition. It takes one argument, which is the name of the grouping.",
      "ja": "「uses」ステートメントは、「グループ化」定義を参照するために使用されます。これは、グループ化の名前である1つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The effect of a \"uses\" reference to a grouping is that the nodes defined by the grouping are copied into the current schema tree and are then updated according to the \"refine\" and \"augment\" statements.",
      "ja": "グループ化への「使用」参照の効果は、グループ化によって定義されたノードが現在のスキーマツリーにコピーされ、「refine」および「augment」ステートメントに従って更新されることです。"
    },
    {
      "indent": 3,
      "text": "The identifiers defined in the grouping are not bound to a namespace until the contents of the grouping are added to the schema tree via a \"uses\" statement that does not appear inside a \"grouping\" statement, at which point they are bound to the namespace of the current module.",
      "ja": "グループ化で定義された識別子は、「グループ化」ステートメント内に表示されない「uses」ステートメントを介してグループ化の内容がスキーマツリーに追加されるまで、名前空間にバインドされません。現在のモジュールの。"
    },
    {
      "indent": 0,
      "text": "7.13.1. The uses's Substatements",
      "section_title": true,
      "ja": "7.13.1. 使用のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| augment      | 7.17    | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| refine       | 7.13.2  | 0..n        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.13.2. The \"refine\" Statement",
      "section_title": true,
      "ja": "7.13.2. 「洗練」ステートメント"
    },
    {
      "indent": 3,
      "text": "Some of the properties of each node in the grouping can be refined with the \"refine\" statement. The argument is a string that identifies a node in the grouping. This node is called the refine's target node. If a node in the grouping is not present as a target node of a \"refine\" statement, it is not refined and thus is used exactly as it was defined in the grouping.",
      "ja": "グループ化の各ノードのプロパティの一部は、「refine」ステートメントで調整できます。引数は、グループ内のノードを識別する文字列です。このノードは、リファインのターゲットノードと呼ばれます。グループ化のノードが「refine」ステートメントのターゲットノードとして存在しない場合、ノードは精製されないため、グループ化で定義されたとおりに使用されます。"
    },
    {
      "indent": 3,
      "text": "The argument string is a descendant schema node identifier (see Section 6.5).",
      "ja": "引数文字列は、子孫のスキーマノード識別子です（6.5節を参照）。"
    },
    {
      "indent": 3,
      "text": "The following refinements can be done:",
      "ja": "次の改良を行うことができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf or choice node may get a default value, or a new default value if it already had one.",
      "ja": "o 葉ノードまたは選択ノードは、デフォルト値を取得するか、すでに存在する場合は新しいデフォルト値を取得します。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list node may get a set of default values, or a new set of default values if it already had defaults; i.e., the set of refined default values replaces the defaults already given.",
      "ja": "o リーフリストノードは、デフォルト値のセットを取得するか、すでにデフォルト値が設定されている場合は新しいデフォルト値のセットを取得します。つまり、洗練されたデフォルト値のセットは、すでに与えられているデフォルトを置き換えます。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"description\" string.",
      "ja": "o どのノードも、特殊な「説明」文字列を取得できます。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"reference\" string.",
      "ja": "o どのノードも特殊な「参照」文字列を取得できます。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a different \"config\" statement.",
      "ja": "o どのノードも異なる「config」ステートメントを取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A leaf, anydata, anyxml, or choice node may get a different \"mandatory\" statement.",
      "ja": "o リーフ、anydata、anyxml、またはchoiceノードは、異なる「必須」ステートメントを取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A container node may get a \"presence\" statement.",
      "ja": "o コンテナノードは「存在」ステートメントを取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, anydata, or anyxml node may get additional \"must\" expressions.",
      "ja": "o リーフ、リーフリスト、リスト、コンテナ、anydata、またはanyxmlノードは、追加の「必須」式を取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list or list node may get a different \"min-elements\" or \"max-elements\" statement.",
      "ja": "o リーフリストまたはリストノードは、異なる「最小要素」または「最大要素」ステートメントを取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, choice, case, anydata, or anyxml node may get additional \"if-feature\" expressions.",
      "ja": "o リーフ、リーフリスト、リスト、コンテナ、選択、ケース、anydata、またはanyxmlノードは、追加の「if-feature」式を取得する場合があります。"
    },
    {
      "indent": 3,
      "text": "o Any node can get refined extensions, if the extension allows refinement. See Section 7.19 for details.",
      "ja": "o 拡張で絞り込みが許可されている場合は、どのノードでも絞り込みを行うことができます。詳細については、セクション7.19を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.13.3. XML Encoding Rules",
      "section_title": true,
      "ja": "7.13.3. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "Each node in the grouping is encoded as if it was defined inline, even if it is imported from another module with another XML namespace.",
      "ja": "グループ化の各ノードは、別のXML名前空間を持つ別のモジュールからインポートされた場合でも、インラインで定義されているかのようにエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.13.4. Usage Example",
      "section_title": true,
      "ja": "7.13.4. 使用例"
    },
    {
      "indent": 3,
      "text": "To use the \"endpoint\" grouping defined in Section 7.12.2 in a definition of an HTTP server in some other module, we can do:",
      "ja": "セクション7.12.2で定義された「エンドポイント」グループを他のモジュールのHTTPサーバーの定義で使用するには、次のようにします。"
    },
    {
      "indent": 5,
      "text": "import example-system {\n  prefix \"sys\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<http-server>\n  <name>extern-web</name>\n  <ip>192.0.2.1</ip>\n  <port>80</port>\n</http-server>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If port 80 should be the default for the HTTP server, a default can be added:",
      "ja": "ポート80をHTTPサーバーのデフォルトにする必要がある場合は、デフォルトを追加できます。"
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint {\n    refine port {\n      default 80;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If we want to define a list of servers and each server has \"ip\" and \"port\" as keys, we can do:",
      "ja": "サーバーのリストを定義し、各サーバーがキーとして「ip」と「port」を持っている場合、次のようにできます。"
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"ip port\";\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following is an error:",
      "ja": "以下はエラーです。"
    },
    {
      "indent": 5,
      "text": "container http-server {\n  uses sys:endpoint;\n  leaf ip {          // illegal - same identifier \"ip\" used twice\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.14. The \"rpc\" Statement",
      "section_title": true,
      "ja": "7.14. 「rpc」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is used to define an RPC operation. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed rpc information. This argument is the name of the RPC.",
      "ja": "「rpc」ステートメントは、RPC操作を定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細なRPC情報を保持するサブステートメントのブロックが続きます。この引数はRPCの名前です。"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement defines an rpc node in the schema tree. Under the rpc node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "ja": "「rpc」ステートメントは、スキーマツリーでrpcノードを定義します。 rpcノードの下には、「input」という名前のスキーマノードと「output」という名前のスキーマノードも定義されています。ノード「入力」と「出力」は、モジュールの名前空間で定義されます。"
    },
    {
      "indent": 0,
      "text": "7.14.1. The rpc's Substatements",
      "section_title": true,
      "ja": "7.14.1. RPCのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.14.2. The \"input\" Statement",
      "section_title": true,
      "ja": "7.14.2. 「入力」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"input\" statement, which is optional, is used to define input parameters to the operation. It does not take an argument. The substatements to \"input\" define nodes under the operation's input node.",
      "ja": "オプションの「input」ステートメントは、操作への入力パラメーターを定義するために使用されます。引数は取りません。 「入力」のサブステートメントは、操作の入力ノードの下のノードを定義します。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC invocation.",
      "ja": "入力ツリーのリーフに値「true」の「必須」ステートメントがある場合、そのリーフはRPC呼び出しに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a default value, the server MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the server MUST operationally behave as if the leaf was present in the RPC invocation with the default value as its value.",
      "ja": "入力ツリーのリーフにデフォルト値がある場合、サーバーは、セクション7.6.1で説明されているのと同じケースでこの値を使用する必要があります。これらの場合、サーバーは、葉がRPC呼び出しにデフォルト値を値として持つRPC呼び出しのように動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the input tree has one or more default values, the server MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the server MUST operationally behave as if the leaf-list was present in the RPC invocation with the default values as its values.",
      "ja": "入力ツリーのリーフリストに1つ以上のデフォルト値がある場合、サーバーは、セクション7.7.2で説明されているのと同じケースでこれらの値を使用する必要があります。これらの場合、サーバーは、リーフリストがデフォルト値を値としてRPC呼び出しに存在しているかのように動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the input tree is not part of any datastore, all \"config\" statements for nodes in the input tree are ignored.",
      "ja": "入力ツリーはデータストアの一部ではないため、入力ツリーのノードのすべての「config」ステートメントは無視されます。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the input tree.",
      "ja": "いずれかのノードに「false」と評価される「when」ステートメントがある場合、このノードは入力ツリーに存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "7.14.2.1. The input's Substatements",
      "section_title": true,
      "ja": "7.14.2.1. 入力のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.14.3. The \"output\" Statement",
      "section_title": true,
      "ja": "7.14.3. 「出力」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"output\" statement, which is optional, is used to define output parameters to the RPC operation. It does not take an argument. The substatements to \"output\" define nodes under the operation's output node.",
      "ja": "オプションの「output」ステートメントは、RPC操作の出力パラメーターを定義するために使用されます。引数は取りません。 「出力」のサブステートメントは、操作の出力ノードの下のノードを定義します。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC reply.",
      "ja": "出力ツリーのリーフに値「true」の「必須」ステートメントがある場合、リーフはRPC応答に存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the RPC reply with the default value as its value.",
      "ja": "出力ツリーのリーフにデフォルト値がある場合、クライアントは、7.6.1項で説明されているのと同じケースでこの値を使用する必要があります。これらの場合、クライアントは、デフォルト値を値として持つRPC応答にリーフが存在するかのように操作上動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the output tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the RPC reply with the default values as its values.",
      "ja": "出力ツリーのリーフリストに1つ以上のデフォルト値がある場合、クライアントはセクション7.7.2で説明されているのと同じケースでこれらの値を使用する必要があります。これらの場合、クライアントは、リーフリストがデフォルト値をその値として持つRPC応答に存在するかのように操作上動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the output tree is not part of any datastore, all \"config\" statements for nodes in the output tree are ignored.",
      "ja": "出力ツリーはデータストアの一部ではないため、出力ツリーのノードのすべての「config」ステートメントは無視されます。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the output tree.",
      "ja": "いずれかのノードに「false」と評価される「when」ステートメントがある場合、このノードは出力ツリーに存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "7.14.3.1. The output's Substatements",
      "section_title": true,
      "ja": "7.14.3.1. 出力のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.14.4. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.14.4. NETCONF XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "An rpc node is encoded as a child XML element to the <rpc> element, as designated by the substitution group \"rpcOperation\" in [RFC6241]. The element's local name is the rpc's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "[RFC6241]の置換グループ「rpcOperation」で指定されているように、rpcノードは<rpc>要素の子XML要素としてエンコードされます。要素のローカル名はrpcの識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Input parameters are encoded as child XML elements to the rpc node's XML element, in the same order as they are defined within the \"input\" statement.",
      "ja": "入力パラメーターは、rpcノードのXMLエレメントへの子XMLエレメントとして、「input」ステートメント内で定義されているのと同じ順序でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "If the RPC operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "ja": "RPC操作の呼び出しが成功し、出力パラメーターが返されない場合、<rpc-reply>には、[RFC6241]で定義されている単一の<ok />要素が含まれています。出力パラメーターが返される場合、それらは[output]ステートメント内で定義されているのと同じ順序で、[RFC6241]で定義されている<rpc-reply>要素の子要素としてエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.14.5. Usage Example",
      "section_title": true,
      "ja": "7.14.5. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines an RPC operation:",
      "ja": "次の例では、RPC操作を定義しています。"
    },
    {
      "indent": 5,
      "text": "module example-rock {\n  yang-version 1.1;\n  namespace \"urn:example:rock\";\n  prefix \"rock\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  rpc rock-the-house {\n    input {\n      leaf zip-code {\n        type string;\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "ja": "完全なrpcおよびrpc-replyの対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <rock-the-house xmlns=\"urn:example:rock\">\n    <zip-code>27606-0100</zip-code>\n  </rock-the-house>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <ok/>\n</rpc-reply>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.15. The \"action\" Statement",
      "section_title": true,
      "ja": "7.15. 「アクション」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement is used to define an operation connected to a specific container or list data node. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed action information. The argument is the name of the action.",
      "ja": "「アクション」ステートメントは、特定のコンテナーまたはリストデータノードに接続された操作を定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細なアクション情報を保持するサブステートメントのブロックが続きます。引数はアクションの名前です。"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement defines an action node in the schema tree. Under the action node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "ja": "「アクション」ステートメントは、スキーマツリーのアクションノードを定義します。アクションノードの下には、「input」という名前のスキーマノードと「output」という名前のスキーマノードも定義されています。ノード「入力」と「出力」は、モジュールの名前空間で定義されます。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT be defined within an rpc, another action, or a notification, i.e., an action node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains an action somewhere in its node hierarchy is used in a notification definition.",
      "ja": "アクションは、rpc、別のアクション、または通知内で定義してはなりません（MUST NOT）。つまり、アクションノードには、スキーマツリー内の祖先の1つとしてrpc、アクション、または通知ノードがあってはなりません。たとえば、これは、ノード階層のどこかにアクションを含むグループが通知定義で使用されている場合、エラーであることを意味します。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "ja": "アクションには、「キー」ステートメントのないリストノードである祖先ノードがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "Since an action cannot be defined at the top level of a module or in a \"case\" statement, it is an error if a grouping that contains an action at the top of its node hierarchy is used at the top level of a module or in a case definition.",
      "ja": "アクションはモジュールの最上位または「case」ステートメントで定義できないため、ノード階層の最上位にアクションを含むグループ化がモジュールの最上位または内部で使用されると、エラーになります。ケース定義。"
    },
    {
      "indent": 3,
      "text": "The difference between an action and an rpc is that an action is tied to a node in the datastore, whereas an rpc is not. When an action is invoked, the node in the datastore is specified along with the name of the action and the input parameters.",
      "ja": "アクションとRPCの違いは、アクションはデータストアのノードに関連付けられているのに対し、RPCは関連付けられていないことです。アクションが呼び出されると、データストア内のノードがアクションの名前と入力パラメーターとともに指定されます。"
    },
    {
      "indent": 0,
      "text": "7.15.1. The action's Substatements",
      "section_title": true,
      "ja": "7.15.1. アクションのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.15.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.15.2. NETCONF XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "When an action is invoked, an element with the local name \"action\" in the namespace \"urn:ietf:params:xml:ns:yang:1\" (see Section 5.3.1) is encoded as a child XML element to the <rpc> element defined in [RFC6241], as designated by the substitution group \"rpcOperation\" in [RFC6241].",
      "ja": "アクションが呼び出されると、名前空間「urn：ietf：params：xml：ns：yang：1」（セクション5.3.1を参照）のローカル名が「action」の要素が子XML要素として<にエンコードされます。 [RFC6241]の置換グループ「rpcOperation」で指定されている、[RFC6241]で定義されているrpc>要素。"
    },
    {
      "indent": 3,
      "text": "The <action> element contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes in the direct path from the top level down to the list or container containing the action. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined action. Within this element, the input parameters are encoded as child XML elements, in the same order as they are defined within the \"input\" statement.",
      "ja": "<action>要素には、データストア内のノードを識別するノードの階層が含まれています。最上位からアクションを含むリストまたはコンテナまでの直接パスにあるすべてのコンテナとリストノードを含める必要があります。リストの場合、すべてのキーリーフも含める必要があります。最も内側のコンテナまたはリストには、定義されたアクションの名前を保持するXML要素が含まれています。この要素内では、入力パラメーターは、「input」ステートメント内で定義されているのと同じ順序で子XML要素としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Only one action can be invoked in one <rpc>. If more than one action is present in the <rpc>, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "ja": "1つの<rpc>で呼び出すことができるアクションは1つだけです。 <rpc>に複数のアクションが存在する場合、サーバーは、<rpc-error>の「bad-element」<error-tag>で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the action operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "ja": "アクション操作の呼び出しが成功し、出力パラメーターが返されない場合、<rpc-reply>には、[RFC6241]で定義されている単一の<ok />要素が含まれています。出力パラメーターが返される場合、それらは[output]ステートメント内で定義されているのと同じ順序で、[RFC6241]で定義されている<rpc-reply>要素の子要素としてエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.15.3. Usage Example",
      "section_title": true,
      "ja": "7.15.3. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines an action to reset one server at a server farm:",
      "ja": "次の例では、サーバーファームで1つのサーバーをリセットするアクションを定義しています。"
    },
    {
      "indent": 5,
      "text": "module example-server-farm {\n  yang-version 1.1;\n  namespace \"urn:example:server-farm\";\n  prefix \"sfarm\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " list server {\n   key name;\n   leaf name {\n     type string;\n   }\n   action reset {\n     input {\n       leaf reset-at {\n         type yang:date-and-time;\n         mandatory true;\n        }\n      }\n      output {\n        leaf reset-finished-at {\n          type yang:date-and-time;\n          mandatory true;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "ja": "完全なrpcおよびrpc-replyの対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n    <server xmlns=\"urn:example:server-farm\">\n      <name>apache-1</name>\n      <reset>\n        <reset-at>2014-07-29T13:42:00Z</reset-at>\n      </reset>\n    </server>\n  </action>\n</rpc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <reset-finished-at xmlns=\"urn:example:server-farm\">\n    2014-07-29T13:42:12Z\n  </reset-finished-at>\n</rpc-reply>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.16. The \"notification\" Statement",
      "section_title": true,
      "ja": "7.16. 「通知」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is used to define a notification. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed notification information. The \"notification\" statement defines a notification node in the schema tree.",
      "ja": "「通知」ステートメントは、通知を定義するために使用されます。 1つの引数（識別子）を受け取り、その後に詳細な通知情報を保持するサブステートメントのブロックが続きます。 「通知」ステートメントは、スキーマツリーの通知ノードを定義します。"
    },
    {
      "indent": 3,
      "text": "A notification can be defined at the top level of a module, or connected to a specific container or list data node in the schema tree.",
      "ja": "通知は、モジュールの最上位で定義するか、スキーマツリーの特定のコンテナーまたはリストデータノードに接続できます。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT be defined within an rpc, action, or another notification, i.e., a notification node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains a notification somewhere in its node hierarchy is used in an rpc definition.",
      "ja": "通知は、rpc、アクション、または別の通知内で定義してはなりません（MUST NOT）。つまり、通知ノードは、スキーマツリー内の祖先の1つとしてrpc、アクション、または通知ノードを持ってはなりません。たとえば、これは、ノード階層のどこかに通知を含むグループがrpc定義で使用されている場合、エラーであることを意味します。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "ja": "通知には、「キー」ステートメントのないリストノードである祖先ノードがあってはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Since a notification cannot be defined in a \"case\" statement, it is an error if a grouping that contains a notification at the top of its node hierarchy is used in a case definition.",
      "ja": "通知は「case」ステートメントで定義できないため、ノード階層の最上位に通知を含むグループ化をケース定義で使用すると、エラーになります。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a notification instance.",
      "ja": "通知ツリーのリーフに値「true」の「必須」ステートメントがある場合、リーフは通知インスタンスに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the notification instance with the default value as its value.",
      "ja": "通知ツリーのリーフにデフォルト値がある場合、クライアントはセクション7.6.1で説明されているのと同じケースでこの値を使用する必要があります。これらの場合、クライアントは、リーフが通知インスタンスに存在し、デフォルト値がその値として存在するかのように動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the notification tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the notification instance with the default values as its values.",
      "ja": "通知ツリーのリーフリストに1つ以上のデフォルト値がある場合、クライアントは、セクション7.7.2で説明されているのと同じケースでこれらの値を使用する必要があります。これらの場合、クライアントは、リーフインスタンスがデフォルト値をその通知インスタンスとして通知インスタンスに存在しているかのように操作上動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the notification tree is not part of any datastore, all \"config\" statements for nodes in the notification tree are ignored.",
      "ja": "通知ツリーはデータストアの一部ではないため、通知ツリー内のノードのすべての「config」ステートメントは無視されます。"
    },
    {
      "indent": 0,
      "text": "7.16.1. The notification's Substatements",
      "section_title": true,
      "ja": "7.16.1. 通知のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.16.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.16.2. NETCONF XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "A notification node that is defined on the top level of a module is encoded as a child XML element to the <notification> element defined in \"NETCONF Event Notifications\" [RFC5277]. The element's local name is the notification's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "モジュールのトップレベルで定義されている通知ノードは、「NETCONFイベント通知」[RFC5277]で定義されている<notification>要素への子XML要素としてエンコードされます。要素のローカル名は通知の識別子であり、その名前空間はモジュールのXML名前空間です（セクション7.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "When a notification node is defined as a child to a data node, the <notification> element defined in [RFC5277] contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes from the top level down to the list or container containing the notification. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined notification.",
      "ja": "通知ノードがデータノードの子として定義されている場合、[RFC5277]で定義されている<notification>要素には、データストア内のノードを識別するノードの階層が含まれています。最上位から通知を含むリストまたはコンテナまでのすべてのコンテナとリストノードを含める必要があります。リストの場合、すべてのキーリーフも含める必要があります。最も内側のコンテナまたはリストには、定義された通知の名前を保持するXML要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "The notification's child nodes are encoded as subelements to the notification node's XML element, in any order.",
      "ja": "通知の子ノードは、通知ノードのXML要素のサブ要素として任意の順序でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.16.3. Usage Example",
      "section_title": true,
      "ja": "7.16.3. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines a notification at the top level of a module:",
      "ja": "次の例では、モジュールのトップレベルで通知を定義しています。"
    },
    {
      "indent": 5,
      "text": "module example-event {\n  yang-version 1.1;\n  namespace \"urn:example:event\";\n  prefix \"ev\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  notification event {\n    leaf event-class {\n      type string;\n    }\n    leaf reporting-entity {\n      type instance-identifier;\n    }\n    leaf severity {\n      type string;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "ja": "完全な通知の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-07-08T00:01:00Z</eventTime>\n  <event xmlns=\"urn:example:event\">\n    <event-class>fault</event-class>\n    <reporting-entity>\n      /ex:interface[ex:name='Ethernet0']\n    </reporting-entity>\n    <severity>major</severity>\n  </event>\n</notification>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following example defines a notification in a data node:",
      "ja": "次の例では、データノードで通知を定義します。"
    },
    {
      "indent": 5,
      "text": "module example-interface-module {\n  yang-version 1.1;\n  namespace \"urn:example:interface-module\";\n  prefix \"if\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    list interface {\n      key \"name\";\n      leaf name {\n        type string;\n      }\n      notification interface-enabled {\n        leaf by-user {\n          type string;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "ja": "完全な通知の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-07-08T00:01:00Z</eventTime>\n  <interfaces xmlns=\"urn:example:interface-module\">\n    <interface>\n      <name>eth1</name>\n      <interface-enabled>\n        <by-user>fred</by-user>\n      </interface-enabled>\n    </interface>\n  </interfaces>\n</notification>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.17. The \"augment\" Statement",
      "section_title": true,
      "ja": "7.17. 「拡張」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement allows a module or submodule to add to a schema tree defined in an external module, or in the current module and its submodules, and to add to the nodes from a grouping in a \"uses\" statement. The argument is a string that identifies a node in the schema tree. This node is called the augment's target node. The target node MUST be either a container, list, choice, case, input, output, or notification node. It is augmented with the nodes defined in the substatements that follow the \"augment\" statement.",
      "ja": "「augment」ステートメントにより、モジュールまたはサブモジュールは、外部モジュール、または現在のモジュールとそのサブモジュールで定義されたスキーマツリーに追加し、「uses」ステートメントのグループからノードに追加できます。引数は、スキーマツリー内のノードを識別する文字列です。このノードは、拡張のターゲットノードと呼ばれます。ターゲットノードは、コンテナ、リスト、選択、ケース、入力、出力、または通知ノードのいずれかである必要があります。 「augment」ステートメントに続くサブステートメントで定義されたノードで拡張されます。"
    },
    {
      "indent": 3,
      "text": "The argument string is a schema node identifier (see Section 6.5). If the \"augment\" statement is on the top level in a module or submodule, the absolute form (defined by the rule \"absolute-schema-nodeid\" in Section 14) of a schema node identifier MUST be used. If the \"augment\" statement is a substatement to the \"uses\" statement, the descendant form (defined by the rule \"descendant-schema-nodeid\" in Section 14) MUST be used.",
      "ja": "引数文字列はスキーマノード識別子です（6.5節を参照）。 「augment」ステートメントがモジュールまたはサブモジュールの最上位にある場合、スキーマノード識別子の絶対形式（セクション14の「absolute-schema-nodeid」のルールで定義）を使用する必要があります。 「augment」ステートメントが「uses」ステートメントのサブステートメントである場合は、子孫フォーム（セクション14の「descendant-schema-nodeid」ルールで定義）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container, list, case, input, output, or notification node, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", and \"choice\" statements can be used within the \"augment\" statement.",
      "ja": "ターゲットノードがコンテナ、リスト、ケース、入力、出力、または通知ノードの場合、「container」、「leaf」、「list」、「leaf-list」、「uses」、および「choice」ステートメントは「augment」ステートメント内で使用されます。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container or list node, the \"action\" and \"notification\" statements can be used within the \"augment\" statement.",
      "ja": "ターゲットノードがコンテナノードまたはリストノードである場合、「アクション」および「通知」ステートメントを「拡張」ステートメント内で使用できます。"
    },
    {
      "indent": 3,
      "text": "If the target node is a choice node, the \"case\" statement or a shorthand \"case\" statement (see Section 7.9.2) can be used within the \"augment\" statement.",
      "ja": "ターゲットノードが選択ノードの場合、「case」ステートメントまたは省略形の「case」ステートメント（7.9.2を参照）を「augment」ステートメント内で使用できます。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement MUST NOT add multiple nodes with the same name from the same module to the target node.",
      "ja": "\"augment\"ステートメントは、同じモジュールから同じ名前の複数のノードをターゲットノードに追加してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "If the augmentation adds mandatory nodes (see Section 3) that represent configuration to a target node in another module, the augmentation MUST be made conditional with a \"when\" statement. Care must be taken when defining the \"when\" expression so that clients that do not know about the augmenting module do not break.",
      "ja": "オーグメンテーションが別のモジュールのターゲットノードへの構成を表す必須ノード（セクション3を参照）を追加する場合、オーグメンテーションは \"when\"ステートメントで条件付きにする必要があります。 「いつ」式を定義するときは、拡張モジュールについて知らないクライアントが壊れないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the following example, it is OK to augment the \"interface\" entry with \"mandatory-leaf\" because the augmentation depends on support for \"some-new-iftype\". The old client does not know about this type, so it would never select this type and would therefore not be adding a mandatory data node.",
      "ja": "次の例では、「interface-」エントリに「mandatory-leaf」を追加しても問題ありません。拡張は「some-new-iftype」のサポートに依存しているためです。古いクライアントはこのタイプを認識しないため、このタイプを選択することはなく、必須のデータノードを追加しません。"
    },
    {
      "indent": 5,
      "text": "module example-augment {\n  yang-version 1.1;\n  namespace \"urn:example:augment\";\n  prefix mymod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import ietf-interfaces {\n  prefix if;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "       identity some-new-iftype {\n          base if:interface-type;\n       }\n       augment \"/if:interfaces/if:interface\" {\n          when 'derived-from-or-self(if:type, \"mymod:some-new-iftype\")';",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "     leaf mandatory-leaf {\n        mandatory true;\n        type string;\n     }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.17.1. The augment's Substatements",
      "section_title": true,
      "ja": "7.17.1. 拡張のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.17.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.17.2. XMLエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "All data nodes defined in the \"augment\" statement are defined as XML elements in the XML namespace of the module where the \"augment\" is specified.",
      "ja": "「augment」ステートメントで定義されているすべてのデータノードは、「augment」が指定されているモジュールのXML名前空間のXML要素として定義されています。"
    },
    {
      "indent": 3,
      "text": "When a node is augmented, the augmenting child nodes are encoded as subelements to the augmented node, in any order.",
      "ja": "ノードが拡張されると、拡張される子ノードは、拡張されるノードへのサブエレメントとして、任意の順序でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "7.17.3. Usage Example",
      "section_title": true,
      "ja": "7.17.3. 使用例"
    },
    {
      "indent": 3,
      "text": "In namespace urn:example:interface-module, we have:",
      "ja": "名前空間urn：example：interface-moduleでは、次のようになります。"
    },
    {
      "indent": 5,
      "text": "container interfaces {\n  list ifEntry {\n    key \"ifIndex\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    leaf ifIndex {\n      type uint32;\n    }\n    leaf ifDescr {\n      type string;\n    }\n    leaf ifType {\n      type iana:IfType;\n    }\n    leaf ifMtu {\n      type int32;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Then, in namespace urn:example:ds0, we have:",
      "ja": "次に、名前空間urn：example：ds0に、次のようにします。"
    },
    {
      "indent": 5,
      "text": "import example-interface-module {\n  prefix \"if\";\n}\naugment \"/if:interfaces/if:ifEntry\" {\n  when \"if:ifType='ds0'\";\n  leaf ds0ChannelNumber {\n    type ChannelNumber;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns=\"urn:example:interface-module\"\n            xmlns:ds0=\"urn:example:ds0\">\n  <ifEntry>\n    <ifIndex>1</ifIndex>\n    <ifDescr>Flintstone Inc Ethernet A562</ifDescr>\n    <ifType>ethernetCsmacd</ifType>\n    <ifMtu>1500</ifMtu>\n  </ifEntry>\n  <ifEntry>\n    <ifIndex>2</ifIndex>\n    <ifDescr>Flintstone Inc DS0</ifDescr>\n    <ifType>ds0</ifType>\n    <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>\n  </ifEntry>\n</interfaces>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As another example, suppose we have the choice defined in Section 7.9.6. The following construct can be used to extend the protocol definition:",
      "ja": "別の例として、セクション7.9.6で定義された選択肢があるとします。次の構文を使用して、プロトコル定義を拡張できます。"
    },
    {
      "indent": 5,
      "text": "augment /ex:system/ex:protocol/ex:name {\n  case c {\n    leaf smtp {\n      type empty;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <ex:tcp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <other:smtp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.18. The \"identity\" Statement",
      "section_title": true,
      "ja": "7.18. 「アイデンティティ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"identity\" statement is used to define a new globally unique, abstract, and untyped identity. The identity's only purpose is to denote its name, semantics, and existence. An identity can be either defined from scratch or derived from one or more base identities. The identity's argument is an identifier that is the name of the identity. It is followed by a block of substatements that holds detailed identity information.",
      "ja": "「identity」ステートメントは、グローバルに一意で抽象的で型付けされていない新しいアイデンティティを定義するために使用されます。アイデンティティの唯一の目的は、名前、セマンティクス、および存在を示すことです。 IDは、最初から定義するか、1つ以上の基本IDから派生させることができます。アイデンティティの引数は、アイデンティティの名前である識別子です。その後に、詳細なID情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The built-in datatype \"identityref\" (see Section 9.10) can be used to reference identities within a data model.",
      "ja": "組み込みデータ型「identityref」（セクション9.10を参照）を使用して、データモデル内のIDを参照できます。"
    },
    {
      "indent": 0,
      "text": "7.18.1. The identity's Substatements",
      "section_title": true,
      "ja": "7.18.1. アイデンティティのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| base         | 7.18.2  | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.18.2. The \"base\" Statement",
      "section_title": true,
      "ja": "7.18.2. 「ベース」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is optional, takes as an argument a string that is the name of an existing identity, from which the new identity is derived. If no \"base\" statement is present, the identity is defined from scratch. If multiple \"base\" statements are present, the identity is derived from all of them.",
      "ja": "「base」ステートメントはオプションであり、既存のIDの名前であるストリングを引数として取り、そこから新しいIDが派生します。 「ベース」ステートメントがない場合、IDは最初から定義されます。複数の「基本」ステートメントが存在する場合、IDはそれらすべてから派生します。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on the base name, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "プレフィックスがベース名に存在する場合、そのプレフィックスでインポートされたモジュールで定義されたID、またはプレフィックスがローカルモジュールのプレフィックスと一致する場合はローカルモジュールを指します。それ以外の場合、一致する名前のIDは、現在のモジュールまたは含まれているサブモジュールで定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "An identity MUST NOT reference itself, neither directly nor indirectly through a chain of other identities.",
      "ja": "アイデンティティは、他のアイデンティティのチェーンを介して直接的または間接的に自分自身を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "The derivation of identities has the following properties:",
      "ja": "アイデンティティの導出には、次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o It is irreflexive, which means that an identity is not derived from itself.",
      "ja": "o それは非反射的です。つまり、アイデンティティはそれ自体から派生したものではありません。"
    },
    {
      "indent": 3,
      "text": "o It is transitive, which means that if identity B is derived from A and C is derived from B, then C is also derived from A.",
      "ja": "o これは推移的です。つまり、アイデンティティBがAから派生し、CがBから派生した場合、CもAから派生します。"
    },
    {
      "indent": 0,
      "text": "7.18.3. Usage Example",
      "section_title": true,
      "ja": "7.18.3. 使用例"
    },
    {
      "indent": 5,
      "text": "module example-crypto-base {\n  yang-version 1.1;\n  namespace \"urn:example:crypto-base\";\n  prefix \"crypto\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "identity crypto-alg {\n  description\n    \"Base identity from which all crypto algorithms\n     are derived.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "identity symmetric-key {\n  description\n    \"Base identity used to identify symmetric-key crypto\n     algorithms.\";\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  identity public-key {\n    description\n      \"Base identity used to identify public-key crypto\n       algorithms.\";\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "module example-des {\n  yang-version 1.1;\n  namespace \"urn:example:des\";\n  prefix \"des\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" {\n  prefix \"crypto\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "       identity des {\n         base \"crypto:crypto-alg\";\n         base \"crypto:symmetric-key\";\n         description \"DES crypto algorithm.\";\n       }\n       identity des3 {\n         base \"crypto:crypto-alg\";\n         base \"crypto:symmetric-key\";\n         description \"Triple DES crypto algorithm.\";\n       }\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.19. The \"extension\" Statement",
      "section_title": true,
      "ja": "7.19. 「拡張」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement allows the definition of new statements within the YANG language. This new statement definition can be imported and used by other modules.",
      "ja": "「拡張」ステートメントでは、YANG言語内で新しいステートメントを定義できます。この新しいステートメント定義をインポートして、他のモジュールで使用できます。"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement's argument is an identifier that is the new keyword for the extension and must be followed by a block of substatements that holds detailed extension information. The purpose of the \"extension\" statement is to define a keyword so that it can be imported and used by other modules.",
      "ja": "「拡張」ステートメントの引数は、拡張の新しいキーワードである識別子であり、その後に詳細な拡張情報を保持するサブステートメントのブロックが続く必要があります。 「拡張」ステートメントの目的は、他のモジュールでインポートして使用できるようにキーワードを定義することです。"
    },
    {
      "indent": 3,
      "text": "The extension can be used like a normal YANG statement, with the statement name followed by an argument if one is defined by the \"extension\" statement, and an optional block of substatements. The statement's name is created by combining the prefix of the module in which the extension was defined, a colon (\":\"), and the extension's keyword, with no interleaving whitespace. The substatements of an extension are defined by the \"extension\" statement, using some mechanism outside the scope of this specification. Syntactically, the substatements MUST be YANG statements, including extensions defined using \"extension\" statements. YANG statements in extensions MUST follow the syntactical rules in Section 14.",
      "ja": "拡張機能は通常のYANGステートメントのように使用できます。「拡張機能」ステートメントで定義されている場合はステートメント名の後に引数が続き、オプションでサブステートメントのブロックが続きます。ステートメントの名前は、拡張機能が定義されたモジュールのプレフィックス、コロン（ \"：\"）、および拡張機能のキーワードを組み合わせることによって作成され、空白は挿入されません。エクステンションのサブステートメントは、この仕様の範囲外のメカニズムを使用して、「エクステンション」ステートメントによって定義されます。構文的には、サブステートメントは、「拡張」ステートメントを使用して定義された拡張を含むYANGステートメントでなければなりません。拡張機能のYANGステートメントは、セクション14の構文規則に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "An extension can allow refinement (see Section 7.13.2) and deviations (Section 7.20.3.2), but the mechanism for how this is defined is outside the scope of this specification.",
      "ja": "拡張機能は、改良（セクション7.13.2を参照）および偏差（セクション7.20.3.2を参照）を許可できますが、これを定義するメカニズムはこの仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "7.19.1. The extension's Substatements",
      "section_title": true,
      "ja": "7.19.1. 拡張機能のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| argument     | 7.19.2  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.19.2. The \"argument\" Statement",
      "section_title": true,
      "ja": "7.19.2. 「引数」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"argument\" statement, which is optional, takes as an argument a string that is the name of the argument to the keyword. If no \"argument\" statement is present, the keyword expects no argument when it is used.",
      "ja": "「引数」ステートメントはオプションであり、キーワードの引数の名前であるストリングを引数として受け取ります。 「引数」ステートメントが存在しない場合、キーワードは、使用時に引数を期待しません。"
    },
    {
      "indent": 3,
      "text": "The argument's name is used in the YIN mapping, where it is used as an XML attribute or element name, depending on the argument's \"yin-element\" statement.",
      "ja": "引数の名前はYINマッピングで使用され、引数の「yin-element」ステートメントに応じて、XML属性または要素名として使用されます。"
    },
    {
      "indent": 0,
      "text": "7.19.2.1. The argument's Substatement",
      "section_title": true,
      "ja": "7.19.2.1. 引数のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| yin-element  | 7.19.2.2 | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.19.2.2. The \"yin-element\" Statement",
      "section_title": true,
      "ja": "7.19.2.2. 「陰要素」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"yin-element\" statement, which is optional, takes as an argument the string \"true\" or \"false\". This statement indicates whether the argument is mapped to an XML element in YIN or to an XML attribute (see Section 13).",
      "ja": "オプションの「yin-element」ステートメントは、ストリング「true」または「false」を引数として取ります。このステートメントは、引数がYINのXML要素にマップされるか、XML属性にマップされるかを示します（セクション13を参照）。"
    },
    {
      "indent": 3,
      "text": "If no \"yin-element\" statement is present, it defaults to \"false\".",
      "ja": "「yin-element」ステートメントがない場合、デフォルトで「false」になります。"
    },
    {
      "indent": 0,
      "text": "7.19.3. Usage Example",
      "section_title": true,
      "ja": "7.19.3. 使用例"
    },
    {
      "indent": 3,
      "text": "To define an extension:",
      "ja": "拡張を定義するには："
    },
    {
      "indent": 5,
      "text": "module example-extensions {\n  yang-version 1.1;\n  ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  extension c-define {\n    description\n      \"Takes as an argument a name string.\n       Makes the code generator use the given name\n       in the #define.\";\n    argument \"name\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To use the extension:",
      "ja": "拡張機能を使用するには："
    },
    {
      "indent": 5,
      "text": "module example-interfaces {\n  yang-version 1.1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "...\nimport example-extensions {\n  prefix \"myext\";\n}\n...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    ...\n    myext:c-define \"MY_INTERFACES\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.20. Conformance-Related Statements",
      "section_title": true,
      "ja": "7.20. 適合性関連のステートメント"
    },
    {
      "indent": 3,
      "text": "This section defines statements related to conformance, as described in Section 5.6.",
      "ja": "このセクションでは、セクション5.6で説明されているように、適合性に関連するステートメントを定義します。"
    },
    {
      "indent": 0,
      "text": "7.20.1. The \"feature\" Statement",
      "section_title": true,
      "ja": "7.20.1. 「機能」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"feature\" statement is used to define a mechanism by which portions of the schema are marked as conditional. A feature name is defined that can later be referenced using the \"if-feature\" statement (see Section 7.20.2). Schema nodes tagged with an \"if-feature\" statement are ignored by the server unless the server supports the given feature expression. This allows portions of the YANG module to be conditional based on conditions in the server. The model can represent the abilities of the server within the model, giving a richer model that allows for differing server abilities and roles.",
      "ja": "「機能」ステートメントは、スキーマの一部を条件付きとしてマークするメカニズムを定義するために使用されます。機能名は、「if-feature」ステートメントを使用して後で参照できるように定義されます（セクション7.20.2を参照）。 「if-feature」ステートメントでタグ付けされたスキーマノードは、サーバーが指定された機能式をサポートしていない限り、サーバーによって無視されます。これにより、YANGモジュールの一部をサーバーの条件に基づいて条件付きにすることができます。モデルは、モデル内のサーバーの能力を表すことができ、さまざまなサーバーの能力と役割を可能にするより豊富なモデルを提供します。"
    },
    {
      "indent": 3,
      "text": "The argument to the \"feature\" statement is the name of the new feature and follows the rules for identifiers in Section 6.2. This name is used by the \"if-feature\" statement to tie the schema nodes to the feature.",
      "ja": "「機能」ステートメントへの引数は、新しい機能の名前であり、セクション6.2の識別子の規則に従います。この名前は、スキーマノードを機能に関連付けるために「if-feature」ステートメントで使用されます。"
    },
    {
      "indent": 3,
      "text": "In this example, a feature called \"local-storage\" represents the ability for a server to store syslog messages on local storage of some sort. This feature is used to make the \"local-storage-limit\" leaf conditional on the presence of some sort of local storage. If the server does not report that it supports this feature, the \"local-storage-limit\" node is not supported.",
      "ja": "この例では、「local-storage」と呼ばれる機能は、サーバーがなんらかのローカルストレージにsyslogメッセージを保存する機能を表しています。この機能は、「local-storage-limit」リーフをある種のローカルストレージの存在を条件とするために使用されます。サーバーがこの機能をサポートしていることを報告しない場合、「local-storage-limit」ノードはサポートされません。"
    },
    {
      "indent": 5,
      "text": "module example-syslog {\n  yang-version 1.1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "...\nfeature local-storage {\n  description\n    \"This feature means that the server supports local\n     storage (memory, flash, or disk) that can be used to\n     store syslog messages.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container syslog {\n    leaf local-storage-limit {\n      if-feature local-storage;\n      type uint64;\n      units \"kilobyte\";\n      config false;\n      description\n        \"The amount of local storage that can be\n         used to hold syslog messages.\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement can be used in many places within the YANG syntax. Definitions tagged with \"if-feature\" are ignored when the server does not support that feature.",
      "ja": "「if-feature」ステートメントは、YANG構文内の多くの場所で使用できます。 「if-feature」でタグ付けされた定義は、サーバーがその機能をサポートしていない場合は無視されます。"
    },
    {
      "indent": 3,
      "text": "A feature MUST NOT reference itself, neither directly nor indirectly through a chain of other features.",
      "ja": "機能は、他の機能のチェーンを通じて直接的または間接的にそれ自体を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "In order for a server to support a feature that is dependent on any other features (i.e., the feature has one or more \"if-feature\" substatements), the server MUST also support all the dependent features.",
      "ja": "サーバーが他の機能に依存する機能をサポートする（つまり、機能に1つ以上の「if-feature」サブステートメントがある）ために、サーバーはすべての依存機能もサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.20.1.1. The feature's Substatements",
      "section_title": true,
      "ja": "7.20.1.1. 機能のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.20.2. The \"if-feature\" Statement",
      "section_title": true,
      "ja": "7.20.2. 「if-feature」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement makes its parent statement conditional. The argument is a boolean expression over feature names. In this expression, a feature name evaluates to \"true\" if and only if the feature is supported by the server. The parent statement is implemented by servers where the boolean expression evaluates to \"true\".",
      "ja": "「if-feature」ステートメントは、その親ステートメントを条件付きにします。引数は、機能名に対するブール式です。この式では、機能がサーバーでサポートされている場合にのみ、機能名が「true」と評価されます。親ステートメントは、ブール式が「true」と評価されるサーバーによって実装されます。"
    },
    {
      "indent": 3,
      "text": "The if-feature boolean expression syntax is formally defined by the rule \"if-feature-expr\" in Section 14. Parentheses are used to group expressions. When the expression is evaluated, the order of precedence is (highest precedence first): grouping (parentheses), \"not\", \"and\", \"or\".",
      "ja": "if-featureブール式構文は、セクション14のルール「if-feature-expr」によって正式に定義されています。括弧は、式をグループ化するために使用されます。式が評価されるときの優先順位は、グループ化（括弧）、「not」、「and」、「or」（優先順位が最初）です。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on a feature name in the boolean expression, the prefixed name refers to a feature defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, a feature with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "ブール式の機能名に接頭辞が存在する場合、接頭辞付きの名前は、その接頭辞を使用してインポートされたモジュールで定義された機能、または接頭辞がローカルモジュールの接頭辞と一致する場合はローカルモジュールを参照します。それ以外の場合、名前が一致する機能は、現在のモジュールまたは含まれているサブモジュールで定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have any \"if-feature\" statements.",
      "ja": "リストキーであるリーフには、「if-feature」ステートメントを含めることはできません。"
    },
    {
      "indent": 0,
      "text": "7.20.2.1. Usage Example",
      "section_title": true,
      "ja": "7.20.2.1. 使用例"
    },
    {
      "indent": 3,
      "text": "In this example, the container \"target\" is implemented if either the \"outbound-tls\" or \"outbound-ssh\" feature is supported by the server.",
      "ja": "この例では、「outbound-tls」または「outbound-ssh」機能のいずれかがサーバーでサポートされている場合、コンテナー「target」が実装されます。"
    },
    {
      "indent": 5,
      "text": "container target {\n  if-feature \"outbound-tls or outbound-ssh\";\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following examples are equivalent:",
      "ja": "次の例は同等です。"
    },
    {
      "indent": 5,
      "text": "if-feature \"not foo or bar and baz\";",
      "ja": "if-feature \"fooやbar and bazではない\";"
    },
    {
      "indent": 5,
      "text": "if-feature \"(not foo) or (bar and baz)\";",
      "ja": "if-feature \"（not foo）or（bar and baz）\";"
    },
    {
      "indent": 0,
      "text": "7.20.3. The \"deviation\" Statement",
      "section_title": true,
      "ja": "7.20.3. 「偏差」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"deviation\" statement defines a hierarchy of a module that the server does not implement faithfully. The argument is a string that identifies the node in the schema tree where a deviation from the module occurs. This node is called the deviation's target node. The contents of the \"deviation\" statement give details about the deviation.",
      "ja": "「偏差」ステートメントは、サーバーが忠実に実装していないモジュールの階層を定義します。引数は、モジュールからの逸脱が発生するスキーマツリー内のノードを識別する文字列です。このノードは、偏差のターゲットノードと呼ばれます。 「偏差」ステートメントの内容は、偏差に関する詳細を示します。"
    },
    {
      "indent": 3,
      "text": "The argument string is an absolute schema node identifier (see Section 6.5).",
      "ja": "引数文字列は、絶対スキーマノード識別子です（6.5節を参照）。"
    },
    {
      "indent": 3,
      "text": "Deviations define the way a server or class of servers deviate from a standard. This means that deviations MUST never be part of a published standard, since they are the mechanism for learning how implementations vary from the standards.",
      "ja": "偏差は、サーバーまたはサーバーのクラスが標準から逸脱する方法を定義します。これは、偏差が実装が標準とどのように異なるかを学習するためのメカニズムであるため、偏差が公開された標準の一部であってはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Server deviations are strongly discouraged and MUST only be used as a last resort. Telling the application how a server fails to follow a standard is no substitute for implementing the standard correctly. A server that deviates from a module is not fully compliant with the module.",
      "ja": "サーバーの逸脱は強くお勧めできません。最後の手段としてのみ使用してください。サーバーが標準に準拠しない方法をアプリケーションに通知することは、標準を正しく実装することの代わりにはなりません。モジュールから逸脱しているサーバーは、モジュールに完全には準拠していません。"
    },
    {
      "indent": 3,
      "text": "However, in some cases, a particular device may not have the hardware or software ability to support parts of a standard module. When this occurs, the server makes a choice to either treat attempts to configure unsupported parts of the module as an error that is reported back to the unsuspecting application or ignore those incoming requests. Neither choice is acceptable.",
      "ja": "ただし、特定のデバイスには、標準モジュールの一部をサポートするハードウェアまたはソフトウェアの機能がない場合があります。これが発生すると、サーバーは、モジュールのサポートされていない部分を構成する試みを、疑いを持たないアプリケーションに報告されるエラーとして扱うか、それらの着信要求を無視するかを選択します。どちらの選択も受け入れられません。"
    },
    {
      "indent": 3,
      "text": "Instead, YANG allows servers to document portions of a base module that are not supported, or that are supported but with different syntax, by using the \"deviation\" statement.",
      "ja": "代わりに、YANGは、サーバーが「偏差」ステートメントを使用することにより、サポートされていない、またはサポートされているが構文が異なる基本モジュールの部分を文書化できるようにします。"
    },
    {
      "indent": 3,
      "text": "After applying all deviations announced by a server, in any order, the resulting data model MUST still be valid.",
      "ja": "サーバーによって発表されたすべての逸脱を任意の順序で適用した後、結果のデータモデルは依然として有効である必要があります。"
    },
    {
      "indent": 0,
      "text": "7.20.3.1. The deviation's Substatements",
      "section_title": true,
      "ja": "7.20.3.1. 偏差のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| description  | 7.21.3   | 0..1        |\n| deviate      | 7.20.3.2 | 1..n        |\n| reference    | 7.21.4   | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.20.3.2. The \"deviate\" Statement",
      "section_title": true,
      "ja": "7.20.3.2. 「逸脱」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"deviate\" statement defines how the server's implementation of the target node deviates from its original definition. The argument is one of the strings \"not-supported\", \"add\", \"replace\", or \"delete\".",
      "ja": "「deviate」ステートメントは、ターゲットノードのサーバーの実装が元の定義からどのように逸脱するかを定義します。引数は、文字列「サポートされていない」、「追加」、「置換」、または「削除」のいずれかです。"
    },
    {
      "indent": 3,
      "text": "The argument \"not-supported\" indicates that the target node is not implemented by this server.",
      "ja": "引数「サポートされていません」は、ターゲットノードがこのサーバーによって実装されていないことを示します。"
    },
    {
      "indent": 3,
      "text": "The argument \"add\" adds properties to the target node. The properties to add are identified by substatements to the \"deviate\" statement. If a property can only appear once, the property MUST NOT exist in the target node.",
      "ja": "引数「add」は、ターゲットノードにプロパティを追加します。追加するプロパティは、「deviate」ステートメントのサブステートメントによって識別されます。プロパティが1度しか出現できない場合、そのプロパティはターゲットノードに存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The argument \"replace\" replaces properties of the target node. The properties to replace are identified by substatements to the \"deviate\" statement. The properties to replace MUST exist in the target node.",
      "ja": "引数「replace」は、ターゲットノードのプロパティを置き換えます。置き換えるプロパティは、「deviate」ステートメントのサブステートメントによって識別されます。置き換えるプロパティは、ターゲットノードに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "The argument \"delete\" deletes properties from the target node. The properties to delete are identified by substatements to the \"delete\" statement. The substatement's keyword MUST match a corresponding keyword in the target node, and the argument's string MUST be equal to the corresponding keyword's argument string in the target node.",
      "ja": "引数「delete」は、ターゲットノードからプロパティを削除します。削除するプロパティは、「delete」ステートメントのサブステートメントによって識別されます。サブステートメントのキーワードは、ターゲットノードの対応するキーワードと一致する必要があり、引数の文字列は、ターゲットノードの対応するキーワードの引数文字列と等しい必要があります。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| substatement | section      | cardinality |\n+--------------+--------------+-------------+\n| config       | 7.21.1       | 0..1        |\n| default      | 7.6.4, 7.7.4 | 0..n        |\n| mandatory    | 7.6.5        | 0..1        |\n| max-elements | 7.7.6        | 0..1        |\n| min-elements | 7.7.5        | 0..1        |\n| must         | 7.5.3        | 0..n        |\n| type         | 7.4          | 0..1        |\n| unique       | 7.8.3        | 0..n        |\n| units        | 7.3.3        | 0..1        |\n+--------------+--------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "The deviate's Substatements",
      "ja": "逸脱者のサブステートメント"
    },
    {
      "indent": 3,
      "text": "If the target node has a property defined by an extension, this property can be deviated if the extension allows deviations. See Section 7.19 for details.",
      "ja": "ターゲットノードに拡張機能で定義されたプロパティがある場合、拡張機能で逸脱が許可されていると、このプロパティが逸脱する可能性があります。詳細については、セクション7.19を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.20.3.3. Usage Example",
      "section_title": true,
      "ja": "7.20.3.3. 使用例"
    },
    {
      "indent": 3,
      "text": "In this example, the server is informing client applications that it does not support the \"daytime\" service in the style of RFC 867.",
      "ja": "この例では、サーバーはクライアントアプリケーションに、RFC 867のスタイルの \"daytime\"サービスをサポートしていないことを通知しています。"
    },
    {
      "indent": 5,
      "text": "module example-deviations {\n  yang-version 1.1;\n  namespace \"urn:example:deviations\";\n  prefix md;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import example-base {\n  prefix base;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  deviation /base:system/base:daytime {\n    deviate not-supported;\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A server would advertise both modules \"example-base\" and \"example-deviations\".",
      "ja": "サーバーは、「example-base」と「example-deviations」の両方のモジュールを通知します。"
    },
    {
      "indent": 3,
      "text": "The following example sets a server-specific default value to a leaf that does not have a default value defined:",
      "ja": "次の例では、サーバー固有のデフォルト値を、デフォルト値が定義されていないリーフに設定しています。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:user/base:type {\n  deviate add {\n    default \"admin\"; // new users are 'admin' by default\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this example, the server limits the number of name servers to 3:",
      "ja": "この例では、サーバーはネームサーバーの数を3に制限しています。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:name-server {\n  deviate replace {\n    max-elements 3;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the original definition is:",
      "ja": "元の定義が次の場合："
    },
    {
      "indent": 5,
      "text": "container system {\n  must \"daytime or time\";\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "a server might remove this \"must\" constraint by doing:",
      "ja": "サーバーは次のようにして、この「必須」の制約を削除する場合があります。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system {\n  deviate delete {\n    must \"daytime or time\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.21. Common Statements",
      "section_title": true,
      "ja": "7.21. 共通の声明"
    },
    {
      "indent": 3,
      "text": "This section defines substatements common to several other statements.",
      "ja": "このセクションでは、他のいくつかのステートメントに共通するサブステートメントを定義します。"
    },
    {
      "indent": 0,
      "text": "7.21.1. The \"config\" Statement",
      "section_title": true,
      "ja": "7.21.1. 「config」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"config\" statement takes as an argument the string \"true\" or \"false\". If \"config\" is \"true\", the definition represents configuration. Data nodes representing configuration are part of configuration datastores.",
      "ja": "「config」ステートメントは、ストリング「true」または「false」を引数として取ります。 「config」が「true」の場合、定義は構成を表します。構成を表すデータノードは、構成データストアの一部です。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is \"false\", the definition represents state data. Data nodes representing state data are not part of configuration datastores.",
      "ja": "「config」が「false」の場合、定義は状態データを表します。状態データを表すデータノードは、構成データストアの一部ではありません。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is not specified, the default is the same as the parent schema node's \"config\" value. If the parent node is a case node, the value is the same as the case node's parent choice node.",
      "ja": "「config」が指定されていない場合、デフォルトは親スキーマノードの「config」値と同じです。親ノードがケースノードの場合、値はケースノードの親選択ノードと同じです。"
    },
    {
      "indent": 3,
      "text": "If the top node does not specify a \"config\" statement, the default is \"true\".",
      "ja": "最上位ノードが「config」ステートメントを指定しない場合、デフォルトは「true」です。"
    },
    {
      "indent": 3,
      "text": "If a node has \"config\" set to \"false\", no node underneath it can have \"config\" set to \"true\".",
      "ja": "ノードの「config」が「false」に設定されている場合、その下のノードで「config」を「true」に設定することはできません。"
    },
    {
      "indent": 0,
      "text": "7.21.2. The \"status\" Statement",
      "section_title": true,
      "ja": "7.21.2. 「ステータス」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"status\" statement takes as an argument one of the strings \"current\", \"deprecated\", or \"obsolete\".",
      "ja": "「ステータス」ステートメントは、「現在」、「非推奨」、「廃止」のいずれかの文字列を引数として取ります。"
    },
    {
      "indent": 3,
      "text": "o \"current\" means that the definition is current and valid.",
      "ja": "o 「現在」とは、定義が最新かつ有効であることを意味します。"
    },
    {
      "indent": 3,
      "text": "o \"deprecated\" indicates an obsolete definition, but it permits new/continued implementation in order to foster interoperability with older/existing implementations.",
      "ja": "o 「非推奨」は廃止された定義を示しますが、古い/既存の実装との相互運用性を促進するために、新しい/継続的な実装を許可します。"
    },
    {
      "indent": 3,
      "text": "o \"obsolete\" means that the definition is obsolete and SHOULD NOT be implemented and/or can be removed from implementations.",
      "ja": "o 「廃止された」とは、定義が廃止されており、実装すべきではない、および/または実装から削除できることを意味します。"
    },
    {
      "indent": 3,
      "text": "If no status is specified, the default is \"current\".",
      "ja": "ステータスを指定しない場合、デフォルトは「現在」です。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"current\", it MUST NOT reference a \"deprecated\" or \"obsolete\" definition within the same module.",
      "ja": "定義が「現在の」ものである場合、同じモジュール内の「非推奨」または「廃止された」定義を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"deprecated\", it MUST NOT reference an \"obsolete\" definition within the same module.",
      "ja": "定義が「非推奨」である場合、同じモジュール内の「廃止された」定義を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the following is illegal:",
      "ja": "たとえば、以下は不正です。"
    },
    {
      "indent": 5,
      "text": "typedef my-type {\n  status deprecated;\n  type int32;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "leaf my-leaf {\n  status current;\n  type my-type; // illegal, since my-type is deprecated\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.21.3. The \"description\" Statement",
      "section_title": true,
      "ja": "7.21.3. 「説明」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement takes as an argument a string that contains a human-readable textual description of this definition. The text is provided in a language (or languages) chosen by the module developer; for the sake of interoperability, it is RECOMMENDED to choose a language that is widely understood among the community of network administrators who will use the module.",
      "ja": "「description」ステートメントは、この定義の人間が読めるテキスト記述を含む文字列を引数として取ります。テキストは、モジュール開発者が選択した1つまたは複数の言語で提供されます。相互運用性のために、モジュールを使用するネットワーク管理者のコミュニティの間で広く理解されている言語を選択することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.21.4. The \"reference\" Statement",
      "section_title": true,
      "ja": "7.21.4. 「参照」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"reference\" statement takes as an argument a string that is a human-readable cross-reference to an external document -- either another module that defines related management information or a document that provides additional information relevant to this definition.",
      "ja": "「参照」ステートメントは、外部ドキュメントへの人間が読み取り可能な相互参照である文字列を引数として取ります。関連する管理情報を定義する別のモジュールか、この定義に関連する追加情報を提供するドキュメントです。"
    },
    {
      "indent": 3,
      "text": "For example, a typedef for a \"uri\" data type could look like:",
      "ja": "たとえば、 \"uri\"データ型のtypedefは次のようになります。"
    },
    {
      "indent": 5,
      "text": "typedef uri {\n  type string;\n  reference\n    \"RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\";\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.21.5. The \"when\" Statement",
      "section_title": true,
      "ja": "7.21.5. 「いつ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"when\" statement makes its parent data definition statement conditional. The node defined by the parent data definition statement is only valid when the condition specified by the \"when\" statement is satisfied. The statement's argument is an XPath expression (see Section 6.4), which is used to formally specify this condition. If the XPath expression conceptually evaluates to \"true\" for a particular instance, then the node defined by the parent data definition statement is valid; otherwise, it is not.",
      "ja": "「いつ」ステートメントは、その親データ定義ステートメントを条件付きにします。親データ定義ステートメントで定義されたノードは、 \"when\"ステートメントで指定された条件が満たされた場合にのみ有効です。ステートメントの引数は、この条件を正式に指定するために使用されるXPath式（6.4項を参照）です。 XPath式が特定のインスタンスに対して概念的に「true」と評価される場合、親データ定義ステートメントによって定義されたノードは有効です。そうでなければ、そうではありません。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have a \"when\" statement.",
      "ja": "リストキーであるリーフには、「when」ステートメントを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "If a key leaf is defined in a grouping that is used in a list, the \"uses\" statement MUST NOT have a \"when\" statement.",
      "ja": "キーリーフがリストで使用されているグループで定義されている場合、「uses」ステートメントに「when」ステートメントを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "See Section 8.3.2 for additional information.",
      "ja": "詳細については、セクション8.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "XPath式は、セクション6.4.1の定義に加えて、次のコンテキストで概念的に評価されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of an \"augment\" statement, then the context node is the augment's target node in the data tree, if the target node is a data node. Otherwise, the context node is the closest ancestor node to the target node that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"augment\" statement.",
      "ja": "o 「when」ステートメントが「augment」ステートメントの子である場合、ターゲットノードがデータノードであれば、コンテキストノードはデータツリー内のaugmentのターゲットノードです。それ以外の場合、コンテキストノードは、データノードでもあるターゲットノードに最も近い祖先ノードです。そのようなノードが存在しない場合、コンテキストノードはルートノードです。アクセス可能なツリーは、「拡張」ステートメントによって追加されたノードのすべてのインスタンス（存在する場合）を削除することにより、XPath式の処理中に一時的に変更されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of a \"uses\", \"choice\", or \"case\" statement, then the context node is the closest ancestor node to the node with the \"when\" statement that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"uses\", \"choice\", or \"case\" statement.",
      "ja": "o \"when\"ステートメントが \"uses\"、 \"choice\"、または \"case\"ステートメントの子である場合、コンテキストノードは、データノードでもある \"when\"ステートメントを持つノードに最も近い祖先ノードです。そのようなノードが存在しない場合、コンテキストノードはルートノードです。アクセス可能なツリーは、XPath式の処理中に、「uses」、「choice」、または「case」ステートメントによって追加されたノードのすべてのインスタンス（存在する場合）を削除することにより、一時的に変更されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of any other data definition statement, the accessible tree is tentatively altered during the processing of the XPath expression by replacing all instances of the data node for which the \"when\" statement is defined with a single dummy node with the same name, but with no value and no children. If no such instance exists, the dummy node is tentatively created. The context node is this dummy node.",
      "ja": "o 「when」ステートメントが他のデータ定義ステートメントの子である場合、アクセス可能なツリーは、「when」ステートメントが定義されているデータノードのすべてのインスタンスを単一のダミーで置き換えることにより、XPath式の処理中に一時的に変更されます。同じ名前で、値も子もないノード。そのようなインスタンスが存在しない場合、ダミーノードが一時的に作成されます。コンテキストノードはこのダミーノードです。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "ja": "XPath式の結果は、標準のXPathルールを使用してブール値に変換されます。"
    },
    {
      "indent": 3,
      "text": "If the XPath expression references any node that also has associated \"when\" statements, those \"when\" expressions MUST be evaluated first. There MUST NOT be any circular dependencies among \"when\" expressions.",
      "ja": "XPath式が「when」ステートメントも関連付けられているノードを参照する場合、それらの「when」式を最初に評価する必要があります。 「when」式の間に循環依存関係があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. The \"when\" statement can very well be implemented with specially written code.",
      "ja": "XPath式は概念的に評価されることに注意してください。これは、実装がサーバーでXPathエバリュエーターを使用する必要がないことを意味します。 \"when\"ステートメントは、特別に書かれたコードで非常にうまく実装できます。"
    },
    {
      "indent": 0,
      "text": "8. Constraints",
      "section_title": true,
      "ja": "8. 制約"
    },
    {
      "indent": 0,
      "text": "8.1. Constraints on Data",
      "section_title": true,
      "ja": "8.1. データの制約"
    },
    {
      "indent": 3,
      "text": "Several YANG statements define constraints on valid data. These constraints are enforced in different ways, depending on what type of data the statement defines.",
      "ja": "いくつかのYANGステートメントは、有効なデータの制約を定義しています。これらの制約は、ステートメントが定義するデータのタイプに応じて、さまざまな方法で適用されます。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on configuration data, it MUST be true in a valid configuration data tree.",
      "ja": "o 制約が構成データで定義されている場合、有効な構成データツリーでtrueでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on state data, it MUST be true in a valid state data tree.",
      "ja": "o 制約が状態データに定義されている場合、有効な状態データツリーでtrueでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on notification content, it MUST be true in any notification data tree.",
      "ja": "o 制約が通知コンテンツで定義されている場合、通知データツリーでtrueにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action input parameters, it MUST be true in an invocation of the RPC or action operation.",
      "ja": "o 制約がRPCまたはアクション入力パラメーターで定義されている場合、RPCまたはアクション操作の呼び出しで制約がtrueでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action output parameters, it MUST be true in the RPC or action reply.",
      "ja": "o 制約がRPCまたはアクション出力パラメーターで定義されている場合、RPCまたはアクション応答でtrueでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in all data trees:",
      "ja": "次のプロパティは、すべてのデータツリーに当てはまります。"
    },
    {
      "indent": 3,
      "text": "o All leaf data values MUST match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties.",
      "ja": "o すべてのリーフデータ値は、タイプの「範囲」、「長さ」、および「パターン」プロパティで定義されたものを含め、リーフのタイプ制約と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o All key leafs MUST be present for all list entries.",
      "ja": "o すべてのキーリーフは、すべてのリストエントリに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Nodes MUST be present for at most one case branch in all choices.",
      "ja": "o ノードは、すべての選択肢で最大1つのケースブランチに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"if-feature\" present if the \"if-feature\" expression evaluates to \"false\" in the server.",
      "ja": "o 「if-feature」式がサーバーで「false」と評価される場合、「if-feature」でタグ付けされたノードが存在してはなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"when\" present if the \"when\" condition evaluates to \"false\" in the data tree.",
      "ja": "o 「when」条件がデータツリーで「false」と評価される場合、「when」でタグ付けされたノードが存在してはなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in a valid data tree:",
      "ja": "次のプロパティは、有効なデータツリーでtrueです。"
    },
    {
      "indent": 3,
      "text": "o All \"must\" constraints MUST evaluate to \"true\".",
      "ja": "o すべての「必須」制約は「真」に評価される必要があります。"
    },
    {
      "indent": 3,
      "text": "o All referential integrity constraints defined via the \"path\" statement MUST be satisfied.",
      "ja": "o 「パス」ステートメントを介して定義されたすべての参照整合性制約が満たされる必要があります。"
    },
    {
      "indent": 3,
      "text": "o All \"unique\" constraints on lists MUST be satisfied.",
      "ja": "o リストに対する「一意の」制約はすべて満たされなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"mandatory\" constraint is enforced for leafs and choices, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "ja": "o 「必須」制約は、ノードまたはその祖先のいずれかに「false」と評価される「when」条件または「if-feature」式がない限り、葉と選択肢に適用されます。"
    },
    {
      "indent": 3,
      "text": "o The \"min-elements\" and \"max-elements\" constraints are enforced for lists and leaf-lists, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "ja": "o 「min-elements」および「max-elements」制約は、ノードまたはその祖先に「false」と評価される「when」条件または「if-feature」式がない限り、リストおよびリーフリストに適用されます。"
    },
    {
      "indent": 3,
      "text": "The running configuration datastore MUST always be valid.",
      "ja": "実行中の構成データストアは常に有効でなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2. Configuration Data Modifications",
      "section_title": true,
      "ja": "8.2. 構成データの変更"
    },
    {
      "indent": 3,
      "text": "o If a request creates configuration data nodes under a choice, any existing nodes from other case branches in the data tree are deleted by the server.",
      "ja": "o リクエストが選択の下に構成データノードを作成する場合、データツリー内の他のケースブランチからの既存のノードはサーバーによって削除されます。"
    },
    {
      "indent": 3,
      "text": "o If a request modifies a configuration data node such that any node's \"when\" expression becomes false, then the node in the data tree with the \"when\" expression is deleted by the server.",
      "ja": "o ノードの「when」式がfalseになるようにリクエストが構成データノードを変更すると、「when」式を含むデータツリー内のノードがサーバーによって削除されます。"
    },
    {
      "indent": 0,
      "text": "8.3. NETCONF Constraint Enforcement Model",
      "section_title": true,
      "ja": "8.3. NETCONF制約適用モデル"
    },
    {
      "indent": 3,
      "text": "For configuration data, there are three windows when constraints MUST be enforced:",
      "ja": "構成データの場合、制約を強制する必要がある場合は3つのウィンドウがあります。"
    },
    {
      "indent": 3,
      "text": "o during parsing of RPC payloads",
      "ja": "o RPCペイロードの解析中"
    },
    {
      "indent": 3,
      "text": "o during processing of the <edit-config> operation",
      "ja": "o <edit-config>操作の処理中"
    },
    {
      "indent": 3,
      "text": "o during validation",
      "ja": "o 検証中"
    },
    {
      "indent": 3,
      "text": "Each of these scenarios is considered in the following sections.",
      "ja": "次のセクションでは、これらの各シナリオについて検討します。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Payload Parsing",
      "section_title": true,
      "ja": "8.3.1. ペイロードの解析"
    },
    {
      "indent": 3,
      "text": "When content arrives in RPC payloads, it MUST be well-formed XML, following the hierarchy and content rules defined by the set of models the server implements.",
      "ja": "コンテンツがRPCペイロードで到着するときは、サーバーが実装する一連のモデルによって定義された階層とコンテンツルールに従って、整形式のXMLである必要があります。"
    },
    {
      "indent": 3,
      "text": "o If a leaf data value does not match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties, the server MUST reply with an \"invalid-value\" <error-tag> in the <rpc-error>, and with the error-app-tag (Section 7.5.4.2) and error-message (Section 7.5.4.1) associated with the constraint, if any exist.",
      "ja": "o タイプの「範囲」、「長さ」、および「パターン」プロパティで定義されたものを含め、リーフデータ値がリーフのタイプ制約と一致しない場合、サーバーは「無効な値」<エラータグで応答する必要があります> <rpc-error>内、および存在する場合は、制約に関連付けられたerror-app-tag（セクション7.5.4.2）およびerror-message（セクション7.5.4.1）"
    },
    {
      "indent": 3,
      "text": "o If all keys of a list entry are not present, the server MUST reply with a \"missing-element\" <error-tag> in the <rpc-error>.",
      "ja": "o リストエントリのすべてのキーが存在しない場合、サーバーは<rpc-error>の「missing-element」<error-tag>で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If data for more than one case branch of a choice is present, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "ja": "o 選択の複数のケースブランチのデータが存在する場合、サーバーは<rpc-error>の「bad-element」<error-tag>で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"if-feature\" is present and the \"if-feature\" expression evaluates to \"false\" in the server, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "o 「if-feature」でタグ付けされたノードのデータが存在し、「if-feature」式がサーバーで「false」と評価された場合、サーバーは<に「unknown-element」<error-tag>で応答する必要がありますrpc-error>。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"when\" is present and the \"when\" condition evaluates to \"false\", the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "o 「when」でタグ付けされたノードのデータが存在し、「when」条件が「false」と評価された場合、サーバーは<rpc-error>の「unknown-element」<error-tag>で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "o For insert handling, if the values for the attributes \"before\" and \"after\" are not valid for the type of the appropriate key leafs, the server MUST reply with a \"bad-attribute\" <error-tag> in the <rpc-error>.",
      "ja": "o 挿入処理の場合、「before」および「after」属性の値が適切なキーリーフのタイプに対して有効でない場合、サーバーは<rpc-の「bad-attribute」<error-tag>で応答する必要があります。エラー>。"
    },
    {
      "indent": 3,
      "text": "o If the attributes \"before\" and \"after\" appear in any element that is not a list whose \"ordered-by\" property is \"user\", the server MUST reply with an \"unknown-attribute\" <error-tag> in the <rpc-error>.",
      "ja": "o \"before\"および \"after\"属性が、 \"ordered-by\"プロパティが \"user\"であるリストではない要素にある場合、サーバーは、<内の \"unknown-attribute\" <error-tag>で応答する必要があります。 rpc-error>。"
    },
    {
      "indent": 0,
      "text": "8.3.2. NETCONF <edit-config> Processing",
      "section_title": true,
      "ja": "8.3.2. NETCONF <edit-config>処理"
    },
    {
      "indent": 3,
      "text": "After the incoming data is parsed, the NETCONF server performs the <edit-config> operation by applying the data to the configuration datastore. During this processing, the following errors MUST be detected:",
      "ja": "着信データが解析された後、NETCONFサーバーは、データを構成データストアに適用することにより、<edit-config>操作を実行します。この処理中に、次のエラーを検出する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Delete requests for non-existent data.",
      "ja": "o 存在しないデータに対するリクエストを削除します。"
    },
    {
      "indent": 3,
      "text": "o Create requests for existent data.",
      "ja": "o 既存のデータに対するリクエストを作成します。"
    },
    {
      "indent": 3,
      "text": "o Insert requests with \"before\" or \"after\" parameters that do not exist.",
      "ja": "o 存在しない「before」または「after」パラメータを含むリクエストを挿入します。"
    },
    {
      "indent": 3,
      "text": "o Modification requests for nodes tagged with \"when\", and the \"when\" condition evaluates to \"false\". In this case, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "o 「いつ」というタグが付けられたノードの変更リクエスト、および「いつ」条件は「false」と評価されます。この場合、サーバーは<rpc-error>内の「unknown-element」<error-tag>で応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Validation",
      "section_title": true,
      "ja": "8.3.3. 検証"
    },
    {
      "indent": 3,
      "text": "When datastore processing is complete, the final contents MUST obey all validation constraints. This validation processing is performed at differing times according to the datastore. If the datastore is \"running\" or \"startup\", these constraints MUST be enforced at the end of the <edit-config> or <copy-config> operation. If the datastore is \"candidate\", the constraint enforcement is delayed until a <commit> or <validate> operation takes place.",
      "ja": "データストア処理が完了すると、最終的なコンテンツはすべての検証制約に従う必要があります。この検証処理は、データストアに応じて異なるタイミングで実行されます。データストアが「実行中」または「起動」の場合、これらの制約は<edit-config>または<copy-config>操作の最後に適用する必要があります。データストアが「候補」の場合、制約の適用は、<commit>または<validate>操作が行われるまで遅延されます。"
    },
    {
      "indent": 0,
      "text": "9. Built-In Types",
      "section_title": true,
      "ja": "9. 組み込み型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements from the management information model.",
      "ja": "YANGには、多くのプログラミング言語に似た組み込み型のセットがありますが、管理情報モデルからの特別な要件による違いがあります。"
    },
    {
      "indent": 3,
      "text": "Additional types may be defined that are derived from those built-in types or from other derived types. Derived types may use subtyping to formally restrict the set of possible values.",
      "ja": "これらの組み込み型または他の派生型から派生した追加の型を定義できます。派生型は、サブタイピングを使用して、可能な値のセットを正式に制限できます。"
    },
    {
      "indent": 3,
      "text": "The different built-in types and their derived types allow different kinds of subtyping, namely length and regular expression restrictions of strings (Sections 9.4.4 and 9.4.5) and range restrictions of numeric types (Section 9.2.4).",
      "ja": "さまざまな組み込み型とそれらの派生型により、さまざまな種類のサブタイピングが可能になります。つまり、文字列の長さと正規表現の制限（セクション9.4.4および9.4.5）と数値型の範囲の制限（セクション9.2.4）です。"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a value of a certain type is used in the XML encoding and when specifying default values and numerical ranges in YANG modules.",
      "ja": "特定のタイプの値の字句表現は、XMLエンコーディングで、およびYANGモジュールでデフォルト値と数値範囲を指定するときに使用されます。"
    },
    {
      "indent": 0,
      "text": "9.1. Canonical Representation",
      "section_title": true,
      "ja": "9.1. 正規表現"
    },
    {
      "indent": 3,
      "text": "For most types, there is a single canonical representation of the type's values. Some types allow multiple lexical representations of the same value; for example, the positive integer \"17\" can be represented as \"+17\" or \"17\". Implementations MUST support all lexical representations specified in this document.",
      "ja": "ほとんどのタイプでは、タイプの値の単一の正規表現があります。一部のタイプでは、同じ値の複数の字句表現が許可されています。たとえば、正の整数「17」は「+17」または「17」と表すことができます。実装は、このドキュメントで指定されているすべての字句表現をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a server sends XML-encoded data, it MUST use the canonical form defined in this section. Other encodings may introduce alternate representations. Note, however, that values in the data tree are conceptually stored in the canonical representation as defined in this section. In particular, any XPath expression evaluations are done using the canonical form if the data type has a canonical form. If the data type does not have a canonical form, the format of the value MUST match the data type's lexical representation, but the exact format is implementation dependent.",
      "ja": "サーバーがXMLでエンコードされたデータを送信する場合、このセクションで定義されている正規形式を使用する必要があります。他のエンコーディングでは、代替表現が導入される場合があります。ただし、データツリーの値は、このセクションで定義されているように、概念的には正規表現に格納されます。特に、データ型が標準形式である場合、XPath式の評価は標準形式を使用して行われます。データ型が標準形式を持たない場合、値の形式はデータ型の字句表現と一致する必要がありますが、正確な形式は実装に依存します。"
    },
    {
      "indent": 3,
      "text": "Some types have a lexical representation that depends on the encoding, e.g., the XML context in which they occur. These types do not have a canonical form.",
      "ja": "一部のタイプには、エンコーディングに依存する字句表現があります（例：発生するXMLコンテキスト）。これらの型には、標準形式はありません。"
    },
    {
      "indent": 0,
      "text": "9.2. The Integer Built-In Types",
      "section_title": true,
      "ja": "9.2. 整数の組み込み型"
    },
    {
      "indent": 3,
      "text": "The integer built-in types are int8, int16, int32, int64, uint8, uint16, uint32, and uint64. They represent signed and unsigned integers of different sizes:",
      "ja": "組み込み整数型は、int8、int16、int32、int64、uint8、uint16、uint32、およびuint64です。これらは、異なるサイズの符号付きおよび符号なし整数を表します。"
    },
    {
      "indent": 3,
      "text": "int8 represents integer values between -128 and 127, inclusively.",
      "ja": "int8は、-128から127までの整数値を表します。"
    },
    {
      "indent": 3,
      "text": "int16 represents integer values between -32768 and 32767, inclusively.",
      "ja": "int16は、-32768から32767までの整数値を表します。"
    },
    {
      "indent": 3,
      "text": "int32 represents integer values between -2147483648 and 2147483647, inclusively.",
      "ja": "int32は、-2147483648〜2147483647の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "int64 represents integer values between -9223372036854775808 and 9223372036854775807, inclusively.",
      "ja": "int64は、-9223372036854775808から9223372036854775807までの整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint8 represents integer values between 0 and 255, inclusively.",
      "ja": "uint8は、0〜255の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint16 represents integer values between 0 and 65535, inclusively.",
      "ja": "uint16は、0〜65535の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint32 represents integer values between 0 and 4294967295, inclusively.",
      "ja": "uint32は、0から4294967295までの整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint64 represents integer values between 0 and 18446744073709551615, inclusively.",
      "ja": "uint64は、0から18446744073709551615までの整数値を表します。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Lexical Representation",
      "section_title": true,
      "ja": "9.2.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "An integer value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "ja": "整数値は、オプションの符号（ \"+\"または \"-\"）とその後に続く10進数の数字として字句的に表現されます。符号が指定されていない場合、「+」が想定されます。"
    },
    {
      "indent": 3,
      "text": "For convenience, when specifying a default value for an integer in a YANG module, an alternative lexical representation can be used that represents the value in a hexadecimal or octal notation. The hexadecimal notation consists of an optional sign (\"+\" or \"-\"), followed by the characters \"0x\", followed by a number of hexadecimal digits where letters may be uppercase or lowercase. The octal notation consists of an optional sign (\"+\" or \"-\"), followed by the character \"0\", followed by a number of octal digits.",
      "ja": "便宜上、YANGモジュールで整数のデフォルト値を指定する場合、16進または8進表記で値を表す代替字句表現を使用できます。 16進表記は、オプションの符号（「+」​​または「-」）の後に文字「0x」が続き、その後に文字が大文字または小文字の16進数の数字が続きます。 8進表記は、オプションの符号（「+」​​または「-」）と、それに続く文字「0」、それに続く8進数の数で構成されます。"
    },
    {
      "indent": 3,
      "text": "Note that if a default value in a YANG module has a leading zero (\"0\"), it is interpreted as an octal number. In the XML encoding, an integer is always interpreted as a decimal number, and leading zeros are allowed.",
      "ja": "YANGモジュールのデフォルト値に先行ゼロ（ \"0\"）がある場合、それは8進数として解釈されることに注意してください。 XMLエンコーディングでは、整数は常に10進数として解釈され、先行ゼロが許可されます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "// legal values\n+4711                       // legal positive value\n4711                        // legal positive value\n-123                        // legal negative value\n0xf00f                      // legal positive hexadecimal value\n-0xf                        // legal negative hexadecimal value\n052                         // legal positive octal value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// illegal values\n- 1                         // illegal intermediate space",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2.2. Canonical Form",
      "section_title": true,
      "ja": "9.2.2. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive integer does not include the sign \"+\". Leading zeros are prohibited. The value zero is represented as \"0\".",
      "ja": "正の整数の正規形には、符号「+」は含まれません。先行ゼロは禁止されています。値ゼロは「0」として表されます。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Restrictions",
      "section_title": true,
      "ja": "9.2.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "All integer types can be restricted with the \"range\" statement (Section 9.2.4).",
      "ja": "すべての整数型は、「範囲」ステートメント（セクション9.2.4）で制限できます。"
    },
    {
      "indent": 0,
      "text": "9.2.4. The \"range\" Statement",
      "section_title": true,
      "ja": "9.2.4. 「範囲」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"range\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a range expression string. It is used to restrict integer and decimal built-in types, or types derived from them.",
      "ja": "「type」ステートメントのオプションのサブステートメントである「range」ステートメントは、範囲式ストリングを引数として取ります。これは、整数および10進数の組み込み型、またはそれらから派生した型を制限するために使用されます。"
    },
    {
      "indent": 0,
      "text": " A range consists of an explicit value, or a lower-inclusive bound, two consecutive dots \"..\", and an upper-inclusive bound. Multiple values or ranges can be given, separated by \"|\". If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a range restriction is applied to a type that is already range-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit values or ranges, or splitting ranges into multiple ranges with intermediate gaps. Each explicit value and range boundary value given in the range expression MUST match the type being restricted or be one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum values accepted for the type being restricted, respectively.",
      "ja": "範囲は、明示的な値、または下限を含む境界、2つの連続するドット「..」、および上限を含む境界で構成されます。複数の値または範囲を「|」で区切って指定できます。複数の値または範囲が指定されている場合、それらはすべてばらばらである必要があり、昇順でなければなりません。範囲の制限がすでに範囲制限されているタイプに適用される場合、新しい制限は同様に制限またはより制限的でなければなりません（つまり、下限を上げる、上限を下げる、明示的な値または範囲を削除する、または範囲を複数に分割する）中間ギャップのある範囲。範囲式で指定される各明示的な値と範囲境界値は、制限されるタイプと一致するか、特別な値「min」または「max」のいずれかである必要があります。 「min」と「max」は、それぞれ制限されるタイプで受け入れられる最小値と最大値を意味します。"
    },
    {
      "indent": 3,
      "text": "The range expression syntax is formally defined by the rule \"range-arg\" in Section 14.",
      "ja": "範囲式の構文は、セクション14の「range-arg」ルールによって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "9.2.4.1. The range's Substatements",
      "section_title": true,
      "ja": "9.2.4.1. 範囲のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2.5. Usage Example",
      "section_title": true,
      "ja": "9.2.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef my-base-int32-type {\n  type int32 {\n    range \"1..4 | 10..20\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "typedef my-type1 {\n  type my-base-int32-type {\n    // legal range restriction\n    range \"11..max\"; // 11..20\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "typedef my-type2 {\n  type my-base-int32-type {\n    // illegal range restriction\n    range \"11..100\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.3. The decimal64 Built-In Type",
      "section_title": true,
      "ja": "9.3. decimal64組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The decimal64 built-in type represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal64 is the set of numbers that can be obtained by multiplying a 64-bit signed integer by a negative power of ten, i.e., expressible as \"i x 10^-n\" where i is an integer64 and n is an integer between 1 and 18, inclusively.",
      "ja": "decimal64組み込み型は実数のサブセットを表し、10進数で表すことができます。 decimal64の値空間は、64ビットの符号付き整数に10の負のべき乗を掛けることによって取得できる数値のセットです。つまり、「ix 10 ^ -n」として表現できます。ここで、iはinteger64で、nは整数です。 1から18まで。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Lexical Representation",
      "section_title": true,
      "ja": "9.3.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "A decimal64 value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits, optionally followed by a period ('.') as a decimal indicator and a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "ja": "decimal64値は、字句的にオプションの符号（ \"+\"または \"-\"）として表現され、その後に一連の10進数字が続き、オプションでその後にピリオド（ '。'）が10進標識として続き、一連の10進数字が続きます。符号が指定されていない場合、「+」が想定されます。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Canonical Form",
      "section_title": true,
      "ja": "9.3.2. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive decimal64 value does not include the sign \"+\". The decimal point is required. Leading and trailing zeros are prohibited, subject to the rule that there MUST be at least one digit before and after the decimal point. The value zero is represented as \"0.0\".",
      "ja": "正のdecimal64値の正規形式には、記号「+」は含まれません。小数点が必要です。先頭と末尾のゼロは禁止されていますが、小数点の前後に少なくとも1桁はなければならないという規則に従います。値ゼロは「0.0」と表されます。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Restrictions",
      "section_title": true,
      "ja": "9.3.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A decimal64 type can be restricted with the \"range\" statement (Section 9.2.4).",
      "ja": "decimal64型は、「範囲」ステートメント（セクション9.2.4）で制限できます。"
    },
    {
      "indent": 0,
      "text": "9.3.4. The \"fraction-digits\" Statement",
      "section_title": true,
      "ja": "9.3.4. 「小数桁」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"fraction-digits\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"decimal64\". It takes as an argument an integer between 1 and 18, inclusively. It controls the size of the minimum difference between values of a decimal64 type by restricting the value space to numbers that are expressible as \"i x 10^-n\" where n is the fraction-digits argument.",
      "ja": "タイプが「decimal64」の場合は、「type」ステートメントのサブステートメントである「fraction-digits」ステートメントが存在する必要があります。 1から18までの整数を引数として取ります。これは、値スペースを \"i x 10 ^ -n\"で表される数値に制限することにより、decimal64タイプの値間の最小差のサイズを制御します。ここで、nは小数桁引数です。"
    },
    {
      "indent": 3,
      "text": "The following table lists the minimum and maximum values for each fraction-digit value:",
      "ja": "次の表に、各小数桁の値の最小値と最大値を示します。"
    },
    {
      "indent": 5,
      "text": "+----------------+-----------------------+----------------------+\n| fraction-digit | min                   | max                  |\n+----------------+-----------------------+----------------------+\n| 1              | -922337203685477580.8 | 922337203685477580.7 |\n| 2              | -92233720368547758.08 | 92233720368547758.07 |\n| 3              | -9223372036854775.808 | 9223372036854775.807 |\n| 4              | -922337203685477.5808 | 922337203685477.5807 |\n| 5              | -92233720368547.75808 | 92233720368547.75807 |\n| 6              | -9223372036854.775808 | 9223372036854.775807 |\n| 7              | -922337203685.4775808 | 922337203685.4775807 |\n| 8              | -92233720368.54775808 | 92233720368.54775807 |\n| 9              | -9223372036.854775808 | 9223372036.854775807 |\n| 10             | -922337203.6854775808 | 922337203.6854775807 |\n| 11             | -92233720.36854775808 | 92233720.36854775807 |\n| 12             | -9223372.036854775808 | 9223372.036854775807 |\n| 13             | -922337.2036854775808 | 922337.2036854775807 |\n| 14             | -92233.72036854775808 | 92233.72036854775807 |\n| 15             | -9223.372036854775808 | 9223.372036854775807 |\n| 16             | -922.3372036854775808 | 922.3372036854775807 |\n| 17             | -92.23372036854775808 | 92.23372036854775807 |\n| 18             | -9.223372036854775808 | 9.223372036854775807 |\n+----------------+-----------------------+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.3.5. Usage Example",
      "section_title": true,
      "ja": "9.3.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef my-decimal {\n  type decimal64 {\n    fraction-digits 2;\n    range \"1 .. 3.14 | 10 | 20..max\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.4. The string Built-In Type",
      "section_title": true,
      "ja": "9.4. 文字列の組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The string built-in type represents human-readable strings in YANG. Legal characters are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The string syntax is formally defined by the rule \"yang-string\" in Section 14.",
      "ja": "文字列組み込み型は、YANGで人間が読める文字列を表します。有効な文字は、UnicodeおよびISO / IEC 10646 [ISO.10646]文字で、タブ、キャリッジリターン、ラインフィードを含みますが、他のC0制御文字、サロゲートブロック、および非文字を除きます。文字列の構文は、セクション14の「yang-string」というルールによって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Lexical Representation",
      "section_title": true,
      "ja": "9.4.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "A string value is lexically represented as character data in the XML encoding.",
      "ja": "文字列値は、XMLエンコーディングで字句的に文字データとして表されます。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Canonical Form",
      "section_title": true,
      "ja": "9.4.2. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation. No Unicode normalization of string values is performed.",
      "ja": "正規形は字句表現と同じです。文字列値のUnicode正規化は実行されません。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Restrictions",
      "section_title": true,
      "ja": "9.4.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A string can be restricted with the \"length\" (Section 9.4.4) and \"pattern\" (Section 9.4.5) statements.",
      "ja": "文字列は、 \"length\"（セクション9.4.4）および \"pattern\"（セクション9.4.5）ステートメントで制限できます。"
    },
    {
      "indent": 0,
      "text": "9.4.4. The \"length\" Statement",
      "section_title": true,
      "ja": "9.4.4. 「長さ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"length\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a length expression string. It is used to restrict the built-in types \"string\" and \"binary\" or types derived from them.",
      "ja": "「type」ステートメントのオプションのサブステートメントである「length」ステートメントは、長さ式ストリングを引数として取ります。これは、組み込み型「文字列」と「バイナリ」またはそれらから派生した型を制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A \"length\" statement restricts the number of Unicode characters in the string.",
      "ja": "「長さ」ステートメントは、文字列内のUnicode文字の数を制限します。"
    },
    {
      "indent": 3,
      "text": "A length range consists of an explicit value, or a lower bound, two consecutive dots \"..\", and an upper bound. Multiple values or ranges can be given, separated by \"|\". Length-restricting values MUST NOT be negative. If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a length restriction is applied to a type that is already length-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit length values or ranges, or splitting ranges into multiple ranges with intermediate gaps. A length value is a non-negative integer or one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum lengths accepted for the type being restricted, respectively. An implementation is not required to support a length value larger than 18446744073709551615.",
      "ja": "長さの範囲は、明示的な値または下限、2つの連続するドット「..」、および上限で構成されます。複数の値または範囲を「|」で区切って指定できます。長さ制限値は負であってはなりません。複数の値または範囲が指定されている場合、それらはすべてばらばらである必要があり、昇順でなければなりません。長さ制限がすでに長さ制限されているタイプに適用される場合、新しい制限は同様に制限またはより制限されている必要があります。つまり、下限を上げる、上限を下げる、明示的な長さの値または範囲を削除する、または範囲を中間ギャップのある複数の範囲。長さの値は、負でない整数、または特別な値「min」または「max」のいずれかです。 「min」と「max」は、制限されているタイプで受け入れられる最小長と最大長をそれぞれ意味します。 18446744073709551615より大きい長さの値をサポートするための実装は必要ありません。"
    },
    {
      "indent": 3,
      "text": "The length expression syntax is formally defined by the rule \"length-arg\" in Section 14.",
      "ja": "長さ式の構文は、セクション14のルール「length-arg」によって正式に定義されています。"
    },
    {
      "indent": 0,
      "text": "9.4.4.1. The length's Substatements",
      "section_title": true,
      "ja": "9.4.4.1. 長さのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.4.5. The \"pattern\" Statement",
      "section_title": true,
      "ja": "9.4.5. 「パターン」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"pattern\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a regular expression string, as defined in [XSD-TYPES]. It is used to restrict the built-in type \"string\", or types derived from \"string\", to values that match the pattern.",
      "ja": "「type」ステートメントのオプションのサブステートメントである「pattern」ステートメントは、[XSD-TYPES]で定義されているように、引数として正規表現文字列を取ります。これは、組み込み型「string」または「string」から派生した型を、パターンに一致する値に制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the type has multiple \"pattern\" statements, the expressions are ANDed together, i.e., all such expressions have to match.",
      "ja": "タイプに複数の「パターン」ステートメントがある場合、式はAND演算されます。つまり、そのような式はすべて一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a pattern restriction is applied to a type that is already pattern-restricted, values must match all patterns in the base type, in addition to the new patterns.",
      "ja": "パターン制限がすでにパターン制限されているタイプに適用される場合、値は、新しいパターンに加えて、基本タイプのすべてのパターンに一致する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.4.5.1. The pattern's Substatements",
      "section_title": true,
      "ja": "9.4.5.1. パターンのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| modifier      | 9.4.6   | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.4.6. The \"modifier\" Statement",
      "section_title": true,
      "ja": "9.4.6. 「修飾子」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"modifier\" statement, which is an optional substatement to the \"pattern\" statement, takes as an argument the string \"invert-match\".",
      "ja": "「パターン」ステートメントのオプションのサブステートメントである「修飾子」ステートメントは、ストリング「invert-match」を引数として受け取ります。"
    },
    {
      "indent": 3,
      "text": "If a pattern has the \"invert-match\" modifier present, the type is restricted to values that do not match the pattern.",
      "ja": "パターンに「invert-match」修飾子が存在する場合、タイプはパターンに一致しない値に制限されます。"
    },
    {
      "indent": 0,
      "text": "9.4.7. Usage Example",
      "section_title": true,
      "ja": "9.4.7. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "ja": "次のtypedefを使用します。"
    },
    {
      "indent": 5,
      "text": "typedef my-base-str-type {\n  type string {\n    length \"1..255\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "ja": "次の改良は合法です："
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n  // legal length refinement\n  length \"11 | 42..max\"; // 11 | 42..255\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "次の改良は違法です："
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n  // illegal length refinement\n  length \"1..999\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "ja": "次のタイプで："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"0..4\";\n  pattern \"[0-9a-fA-F]*\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following strings match:",
      "ja": "次の文字列が一致します。"
    },
    {
      "indent": 5,
      "text": "AB          // legal\n9A00        // legal",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "ja": "次の文字列は一致しません："
    },
    {
      "indent": 5,
      "text": "00ABAB      // illegal, too long\nxx00        // illegal, bad characters",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "ja": "次のタイプで："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"1..max\";\n  pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';\n  pattern '[xX][mM][lL].*' {\n    modifier invert-match;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following string matches:",
      "ja": "次の文字列が一致します。"
    },
    {
      "indent": 5,
      "text": "enabled // legal",
      "ja": "有効//法的"
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "ja": "次の文字列は一致しません："
    },
    {
      "indent": 5,
      "text": "10-mbit     // illegal, starts with a number\nxml-element // illegal, starts with illegal sequence",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.5. The boolean Built-In Type",
      "section_title": true,
      "ja": "9.5. ブール組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The boolean built-in type represents a boolean value.",
      "ja": "ブールの組み込みタイプはブール値を表します。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Lexical Representation",
      "section_title": true,
      "ja": "9.5.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a boolean value is a string with a value of \"true\" or \"false\". These values MUST be in lowercase.",
      "ja": "ブール値の字句表現は、「true」または「false」の値を持つ文字列です。これらの値は小文字でなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Canonical Form",
      "section_title": true,
      "ja": "9.5.2. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation.",
      "ja": "正規形は字句表現と同じです。"
    },
    {
      "indent": 0,
      "text": "9.5.3. Restrictions",
      "section_title": true,
      "ja": "9.5.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A boolean cannot be restricted.",
      "ja": "ブール値は制限できません。"
    },
    {
      "indent": 0,
      "text": "9.6. The enumeration Built-In Type",
      "section_title": true,
      "ja": "9.6. 列挙型組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The enumeration built-in type represents values from a set of assigned names.",
      "ja": "列挙型組み込みタイプは、割り当てられた名前のセットからの値を表します。"
    },
    {
      "indent": 0,
      "text": "9.6.1. Lexical Representation",
      "section_title": true,
      "ja": "9.6.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of an enumeration value is the assigned name string.",
      "ja": "列挙値の字句表現は、割り当てられた名前の文字列です。"
    },
    {
      "indent": 0,
      "text": "9.6.2. Canonical Form",
      "section_title": true,
      "ja": "9.6.2. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the assigned name string.",
      "ja": "正規形式は、割り当てられた名前の文字列です。"
    },
    {
      "indent": 0,
      "text": "9.6.3. Restrictions",
      "section_title": true,
      "ja": "9.6.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "An enumeration can be restricted with one or more \"enum\" (Section 9.6.4) statements, which enumerate a subset of the values for the base type.",
      "ja": "列挙は、基本タイプの値のサブセットを列挙する1つ以上の「列挙」（セクション9.6.4）ステートメントで制限できます。"
    },
    {
      "indent": 0,
      "text": "9.6.4. The \"enum\" Statement",
      "section_title": true,
      "ja": "9.6.4. 「列挙型」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"enum\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"enumeration\". It is repeatedly used to specify each assigned name of an enumeration type. It takes as an argument a string that is the assigned name. The string MUST NOT be zero-length and MUST NOT have any leading or trailing whitespace characters (any Unicode character with the \"White_Space\" property). The use of Unicode control codes SHOULD be avoided.",
      "ja": "タイプが「列挙」の場合、「タイプ」ステートメントのサブステートメントである「列挙」ステートメントが存在する必要があります。これは、列挙型の割り当てられた各名前を指定するために繰り返し使用されます。割り当てられた名前である文字列を引数として受け取ります。文字列は長さ0であってはならず、先頭または末尾の空白文字（ \"White_Space\"プロパティを持つUnicode文字）があってはなりません（MUST NOT）。 Unicode制御コードの使用は避けてください。"
    },
    {
      "indent": 3,
      "text": "The statement is optionally followed by a block of substatements that holds detailed enum information.",
      "ja": "ステートメントの後には、オプションの詳細な列挙情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "All assigned names in an enumeration MUST be unique.",
      "ja": "列挙で割り当てられたすべての名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The value of such an assigned name MUST NOT be changed.",
      "ja": "既存の列挙型が制限されている場合、新しい型の割り当てられた名前のセットは、基本型の割り当てられた名前のセットのサブセットである必要があります。そのような割り当てられた名前の値は変更してはなりません。"
    },
    {
      "indent": 0,
      "text": "9.6.4.1. The enum's Substatements",
      "section_title": true,
      "ja": "9.6.4.1. 列挙型のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| value        | 9.6.4.2 | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.6.4.2. The \"value\" Statement",
      "section_title": true,
      "ja": "9.6.4.2. 「値」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"value\" statement, which is optional, is used to associate an integer value with the assigned name for the enum. This integer value MUST be in the range -2147483648 to 2147483647, and it MUST be unique within the enumeration type.",
      "ja": "オプションの「value」ステートメントは、整数値をenumに割り当てられた名前に関連付けるために使用されます。この整数値は-2147483648〜2147483647の範囲内である必要があり、列挙型内で一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "If a value is not specified, then one will be automatically assigned. If the \"enum\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest enum value (i.e., the highest enum value, implicit or explicit, prior to the current \"enum\" substatement in the parent \"type\" statement).",
      "ja": "値が指定されていない場合は、自動的に割り当てられます。 「列挙型」サブステートメントが最初に定義されたものである場合、割り当てられる値はゼロ（0）です。それ以外の場合、割り当てられた値は、現在の最高列挙値（つまり、親「type」ステートメントの現在の「列挙」サブステートメントの前の暗黙または明示の最高列挙値）より1つ大きくなります。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in an \"enum\" statement does not affect the automatically assigned value.",
      "ja": "「enum」ステートメントに「if-feature」ステートメントが存在しても、自動的に割り当てられる値には影響しません。"
    },
    {
      "indent": 3,
      "text": "If the current highest value is equal to 2147483647, then an enum value MUST be specified for \"enum\" substatements following the one with the current highest value.",
      "ja": "現在の最高値が2147483647に等しい場合は、現在の最高値を持つサブステートメントに続く「列挙」サブステートメントに列挙値を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the \"value\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "ja": "既存の列挙型が制限されている場合、「値」ステートメントは基本タイプと同じ値を持つか、存在しない必要があります。この場合、値は基本タイプと同じです。"
    },
    {
      "indent": 0,
      "text": "9.6.5. Usage Example",
      "section_title": true,
      "ja": "9.6.5. 使用例"
    },
    {
      "indent": 5,
      "text": "leaf myenum {\n  type enumeration {\n    enum zero;\n    enum one;\n    enum seven {\n      value 7;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The lexical representation of the leaf \"myenum\" with value \"seven\" is:",
      "ja": "値「seven」を持つリーフ「myenum」の字句表現は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<myenum>seven</myenum>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "ja": "次のtypedefを使用します。"
    },
    {
      "indent": 5,
      "text": "typedef my-base-enumeration-type {\n  type enumeration {\n    enum white {\n      value 1;\n    }\n    enum yellow {\n      value 2;\n    }\n    enum red {\n      value 3;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "ja": "次の改良は合法です："
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type {\n  // legal enum refinement\n  enum yellow;\n  enum red {\n    value 3;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "次の改良は違法です："
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type {\n  // illegal enum refinement\n  enum yellow {\n    value 4; // illegal value change\n  }\n  enum black; // illegal addition of new name\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following example shows how an \"enum\" can be tagged with \"if-feature\", making the value legal only on servers that advertise the corresponding feature:",
      "ja": "次の例は、「列挙型」に「if-feature」のタグを付け、対応する機能をアドバタイズするサーバーでのみ値を正当にする方法を示しています。"
    },
    {
      "indent": 5,
      "text": "type enumeration {\n  enum tcp;\n  enum ssh {\n    if-feature ssh;\n  }\n  enum tls {\n    if-feature tls;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.7. The bits Built-In Type",
      "section_title": true,
      "ja": "9.7. ビット組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The bits built-in type represents a bit set. That is, a bits value is a set of flags identified by small integer position numbers starting at 0. Each bit number has an assigned name.",
      "ja": "ビット組み込み型はビットセットを表します。つまり、ビット値は、0から始まる小さな整数の位置番号によって識別されるフラグのセットです。各ビット番号には名前が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The bit position of such an assigned name MUST NOT be changed.",
      "ja": "既存のビットタイプが制限されている場合、新しいタイプの割り当てられた名前のセットは、基本タイプの割り当てられた名前のセットのサブセットである必要があります。そのような割り当てられた名前のビット位置は変更してはなりません。"
    },
    {
      "indent": 0,
      "text": "9.7.1. Restrictions",
      "section_title": true,
      "ja": "9.7.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A bits type can be restricted with the \"bit\" (Section 9.7.4) statement.",
      "ja": "ビットタイプは、「ビット」（セクション9.7.4）ステートメントで制限できます。"
    },
    {
      "indent": 0,
      "text": "9.7.2. Lexical Representation",
      "section_title": true,
      "ja": "9.7.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of the bits type is a space-separated list of the names of the bits that are set. A zero-length string thus represents a value where no bits are set.",
      "ja": "ビットタイプの字句表現は、設定されているビットの名前のスペース区切りリストです。したがって、長さがゼロの文字列は、ビットが設定されていない値を表します。"
    },
    {
      "indent": 0,
      "text": "9.7.3. Canonical Form",
      "section_title": true,
      "ja": "9.7.3. 正規形"
    },
    {
      "indent": 3,
      "text": "In the canonical form, the bit values are separated by a single space character and they appear ordered by their position (see Section 9.7.4.2).",
      "ja": "正規形式では、ビット値は1つのスペース文字で区切られ、位置順に並べられて表示されます（セクション9.7.4.2を参照）。"
    },
    {
      "indent": 0,
      "text": "9.7.4. The \"bit\" Statement",
      "section_title": true,
      "ja": "9.7.4. 「ビット」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"bit\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"bits\". It is repeatedly used to specify each assigned named bit of a bits type. It takes as an argument a string that is the assigned name of the bit. It is followed by a block of substatements that holds detailed bit information. The assigned name follows the same syntax rules as an identifier (see Section 6.2).",
      "ja": "タイプが「ビット」の場合は、「タイプ」ステートメントのサブステートメントである「ビット」ステートメントが存在する必要があります。これは、ビット型の割り当てられた名前付きビットをそれぞれ指定するために繰り返し使用されます。これは、ビットの割り当てられた名前であるストリングを引数として取ります。その後に、詳細なビット情報を保持するサブステートメントのブロックが続きます。割り当てられた名前は、識別子と同じ構文規則に従います（セクション6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in a bits type MUST be unique.",
      "ja": "ビットタイプで割り当てられたすべての名前は一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "9.7.4.1. The bit's Substatements",
      "section_title": true,
      "ja": "9.7.4.1. ビットのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| position     | 9.7.4.2 | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.7.4.2. The \"position\" Statement",
      "section_title": true,
      "ja": "9.7.4.2. 「ポジション」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"position\" statement, which is optional, takes as an argument a non-negative integer value that specifies the bit's position within a hypothetical bit field. The position value MUST be in the range 0 to 4294967295, and it MUST be unique within the bits type.",
      "ja": "「position」ステートメントはオプションであり、仮想ビットフィールド内のビットの位置を指定する負でない整数値を引数として取ります。位置の値は0から4294967295の範囲でなければならず、ビットタイプ内で一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "If a bit position is not specified, then one will be automatically assigned. If the \"bit\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest bit position (i.e., the highest bit position, implicit or explicit, prior to the current \"bit\" substatement in the parent \"type\" statement).",
      "ja": "ビット位置が指定されていない場合は、自動的に割り当てられます。 「ビット」サブステートメントが最初に定義されたものである場合、割り当てられる値はゼロ（0）です。それ以外の場合、割り当てられる値は、現在の最高ビット位置（つまり、親「type」ステートメントの現在の「ビット」サブステートメントの前の暗黙的または明示的な最高ビット位置）より1つ大きくなります。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in a \"bit\" statement does not affect the automatically assigned position.",
      "ja": "「bit」ステートメントに「if-feature」ステートメントが存在しても、自動的に割り当てられる位置には影響しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the current highest bit position value is equal to 4294967295, then a position value MUST be specified for \"bit\" substatements following the one with the current highest position value.",
      "ja": "現在の最高のビット位置値が4294967295に等しい場合、現在の最高の位置値を持つサブステートメントに続く「ビット」サブステートメントに位置値を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the \"position\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "ja": "既存のビットタイプが制限されている場合、「position」ステートメントは基本タイプと同じ値を持つか、存在しない必要があります。この場合、値は基本タイプと同じです。"
    },
    {
      "indent": 0,
      "text": "9.7.5. Usage Example",
      "section_title": true,
      "ja": "9.7.5. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following typedef and leaf:",
      "ja": "次のtypedefとリーフがあるとします。"
    },
    {
      "indent": 5,
      "text": "typedef mybits-type {\n  type bits {\n    bit disable-nagle {\n      position 0;\n    }\n    bit auto-sense-speed {\n      position 1;\n    }\n    bit ten-mb-only {\n      position 2;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "leaf mybits {\n  type mybits-type;\n  default \"auto-sense-speed\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The lexical representation of this leaf with bit values disable-nagle and ten-mb-only set would be:",
      "ja": "このリーフの字句表現は、ビット値がdisable-nagleで、10 mbのみが設定されています。"
    },
    {
      "indent": 5,
      "text": "<mybits>disable-nagle ten-mb-only</mybits>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following example shows a legal refinement of this type:",
      "ja": "次の例は、このタイプの法的改良を示しています。"
    },
    {
      "indent": 5,
      "text": "type mybits-type {\n  // legal bit refinement\n  bit disable-nagle {\n    position 0;\n  }\n  bit auto-sense-speed {\n    position 1;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "次の改良は違法です："
    },
    {
      "indent": 5,
      "text": "type mybits-type {\n  // illegal bit refinement\n  bit disable-nagle {\n    position 2; // illegal position change\n  }\n  bit hundred-mb-only; // illegal addition of new name\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.8. The binary Built-In Type",
      "section_title": true,
      "ja": "9.8. バイナリ組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The binary built-in type represents any binary data, i.e., a sequence of octets.",
      "ja": "バイナリ組み込みタイプは、任意のバイナリデータ、つまりオクテットのシーケンスを表します。"
    },
    {
      "indent": 0,
      "text": "9.8.1. Restrictions",
      "section_title": true,
      "ja": "9.8.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A binary type can be restricted with the \"length\" (Section 9.4.4) statement. The length of a binary value is the number of octets it contains.",
      "ja": "バイナリ型は、 \"length\"（セクション9.4.4）ステートメントで制限できます。バイナリ値の長さは、含まれるオクテットの数です。"
    },
    {
      "indent": 0,
      "text": "9.8.2. Lexical Representation",
      "section_title": true,
      "ja": "9.8.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "Binary values are encoded with the base64 encoding scheme (see Section 4 in [RFC4648]).",
      "ja": "バイナリ値は、base64エンコードスキームでエンコードされます（[RFC4648]のセクション4を参照）。"
    },
    {
      "indent": 0,
      "text": "9.8.3. Canonical Form",
      "section_title": true,
      "ja": "9.8.3. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a binary value follows the rules of \"Base 64 Encoding\" in [RFC4648].",
      "ja": "バイナリ値の標準形式は、[RFC4648]の「Base 64エンコーディング」の規則に従います。"
    },
    {
      "indent": 0,
      "text": "9.9. The leafref Built-In Type",
      "section_title": true,
      "ja": "9.9. leafref組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The leafref built-in type is restricted to the value space of some leaf or leaf-list node in the schema tree and optionally further restricted by corresponding instance nodes in the data tree. The \"path\" substatement (Section 9.9.2) is used to identify the referred leaf or leaf-list node in the schema tree. The value space of the referring node is the value space of the referred node.",
      "ja": "leafref組み込みタイプは、スキーマツリー内の一部のリーフまたはリーフリストノードの値スペースに制限され、オプションで、データツリー内の対応するインスタンスノードによってさらに制限されます。 「パス」サブステートメント（セクション9.9.2）は、スキーマツリーで参照されているリーフまたはリーフリストノードを識別するために使用されます。参照ノードの値空間は、参照ノードの値空間です。"
    },
    {
      "indent": 3,
      "text": "If the \"require-instance\" property (Section 9.9.3) is \"true\", there MUST exist a node in the data tree, or a node with a default value in use (see Sections 7.6.1 and 7.7.2), of the referred schema tree leaf or leaf-list node with the same value as the leafref value in a valid data tree.",
      "ja": "「require-instance」プロパティ（セクション9.9.3）が「true」の場合、データツリーにノード、またはデフォルト値が使用されているノードが存在している必要があります（セクション7.6.1および7.7.2を参照）。有効なデータツリーのleafref値と同じ値を持つ、参照されたスキーマツリーリーフまたはリーフリストノードの。"
    },
    {
      "indent": 3,
      "text": "If the referring node represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the referred node MUST also represent configuration.",
      "ja": "参照ノードが構成データを表し、「require-instance」プロパティ（セクション9.9.3）が「true」の場合、参照ノードも構成を表す必要があります。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of leafrefs.",
      "ja": "葉参照の循環チェーンがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "If the leaf that the leafref refers to is conditional based on one or more features (see Section 7.20.2), then the leaf with the leafref type MUST also be conditional based on at least the same set of features.",
      "ja": "leafrefが参照するリーフが1つ以上の機能に基づいて条件付きである場合（セクション7.20.2を参照）、leafrefタイプのリーフも、少なくとも同じ機能セットに基づいて条件付きである必要があります。"
    },
    {
      "indent": 0,
      "text": "9.9.1. Restrictions",
      "section_title": true,
      "ja": "9.9.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A leafref can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "ja": "leafrefは、「require-instance」ステートメント（セクション9.9.3）で制限できます。"
    },
    {
      "indent": 0,
      "text": "9.9.2. The \"path\" Statement",
      "section_title": true,
      "ja": "9.9.2. 「パス」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"path\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"leafref\". It takes as an argument a string that MUST refer to a leaf or leaf-list node.",
      "ja": "「type」ステートメントのサブステートメントである「path」ステートメントは、タイプが「leafref」の場合に存在する必要があります。リーフまたはリーフリストノードを参照する必要がある文字列を引数として受け取ります。"
    },
    {
      "indent": 3,
      "text": "The syntax for a path argument is a subset of the XPath abbreviated syntax. Predicates are used only for constraining the values for the key nodes for list entries. Each predicate consists of exactly one equality test per key, and multiple adjacent predicates MAY be present if a list has multiple keys. The syntax is formally defined by the rule \"path-arg\" in Section 14.",
      "ja": "パス引数の構文は、XPath省略構文のサブセットです。述語は、リストエントリのキーノードの値を制約するためにのみ使用されます。各述語はキーごとに厳密に1つの等価性テストで構成され、リストに複数のキーがある場合、隣接する複数の述語が存在する場合があります。構文は、セクション14のルール「path-arg」によって正式に定義されています。"
    },
    {
      "indent": 3,
      "text": "The predicates are only used when more than one key reference is needed to uniquely identify a leaf instance. This occurs if a list has multiple keys or a reference to a leaf other than the key in a list is needed. In these cases, multiple leafrefs are typically specified, and predicates are used to tie them together.",
      "ja": "述語は、リーフインスタンスを一意に識別するために複数のキー参照が必要な場合にのみ使用されます。これは、リストに複数のキーがあるか、リスト内のキー以外のリーフへの参照が必要な場合に発生します。これらの場合、通常は複数のリーフ参照が指定され、述語を使用してそれらを結合します。"
    },
    {
      "indent": 3,
      "text": "The \"path\" expression evaluates to a node set consisting of zero, one, or more nodes. If the \"require-instance\" property is \"true\", this node set MUST be non-empty.",
      "ja": "「パス」式は、0、1、またはそれ以上のノードで構成されるノードセットに評価されます。 「require-instance」プロパティが「true」の場合、このノードセットは空ではない必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"path\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "「パス」XPath式は、セクション6.4.1の定義に加えて、次のコンテキストで概念的に評価されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"path\" statement is defined within a typedef, the context node is the leaf or leaf-list node in the data tree that references the typedef.",
      "ja": "o 「パス」ステートメントがtypedef内で定義されている場合、コンテキストノードは、typedefを参照するデータツリーのリーフノードまたはリーフリストノードです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the data tree for which the \"path\" statement is defined.",
      "ja": "o それ以外の場合、コンテキストノードは、「パス」ステートメントが定義されているデータツリー内のノードです。"
    },
    {
      "indent": 0,
      "text": "9.9.3. The \"require-instance\" Statement",
      "section_title": true,
      "ja": "9.9.3. 「require-instance」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"require-instance\" statement, which is a substatement to the \"type\" statement, MAY be present if the type is \"instance-identifier\" or \"leafref\". It takes as an argument the string \"true\" or \"false\". If this statement is not present, it defaults to \"true\".",
      "ja": "「require-instance」ステートメントは、「type」ステートメントのサブステートメントであり、タイプが「instance-identifier」または「leafref」の場合に存在する場合があります。引数として文字列「true」または「false」を取ります。このステートメントが存在しない場合、デフォルトで「true」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"true\", it means that the instance being referred to MUST exist for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "ja": "「require-instance」が「true」の場合、データが有効であるためには、参照されているインスタンスが存在しなければならないことを意味します。この制約は、セクション8のルールに従って実施されます。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"false\", it means that the instance being referred to MAY exist in valid data.",
      "ja": "「require-instance」が「false」の場合、参照されているインスタンスが有効なデータに存在する可能性があることを意味します。"
    },
    {
      "indent": 0,
      "text": "9.9.4. Lexical Representation",
      "section_title": true,
      "ja": "9.9.4. 字句表現"
    },
    {
      "indent": 3,
      "text": "A leafref value is lexically represented the same way as the leaf it references represents its value.",
      "ja": "leafref値は、参照する葉がその値を表すのと同じ方法で字句的に表現されます。"
    },
    {
      "indent": 0,
      "text": "9.9.5. Canonical Form",
      "section_title": true,
      "ja": "9.9.5. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a leafref is the same as the canonical form of the leaf it references.",
      "ja": "leafrefの標準形は、参照する葉の標準形と同じです。"
    },
    {
      "indent": 0,
      "text": "9.9.6. Usage Example",
      "section_title": true,
      "ja": "9.9.6. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "ja": "次のリストで："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf admin-status {\n    type admin-status;\n  }\n  list address {\n    key \"ip\";\n    leaf ip {\n      type yang:ip-address;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following leafref refers to an existing interface:",
      "ja": "次のleafrefは既存のインターフェースを参照しています。"
    },
    {
      "indent": 5,
      "text": "leaf mgmt-interface {\n  type leafref {\n    path \"../interface/name\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n</interface>\n<interface>\n  <name>lo</name>\n</interface>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<mgmt-interface>eth0</mgmt-interface>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following leafrefs refer to an existing address of an interface:",
      "ja": "次のleafrefsは、インターフェースの既存のアドレスを参照します。"
    },
    {
      "indent": 5,
      "text": "container default-address {\n  leaf ifname {\n    type leafref {\n      path \"../../interface/name\";\n    }\n  }\n  leaf address {\n    type leafref {\n      path \"../../interface[name = current()/../ifname]\"\n         + \"/address/ip\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>\n<interface>\n  <name>lo</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>127.0.0.1</ip>\n  </address>\n</interface>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<default-address>\n  <ifname>eth0</ifname>\n  <address>192.0.2.2</address>\n</default-address>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following list uses a leafref for one of its keys. This is similar to a foreign key in a relational database.",
      "ja": "次のリストでは、キーの1つにleafrefを使用しています。これは、リレーショナルデータベースの外部キーに似ています。"
    },
    {
      "indent": 5,
      "text": "list packet-filter {\n  key \"if-name filter-id\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf filter-id {\n    type uint32;\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>1</filter-id>\n  ...\n</packet-filter>\n<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>2</filter-id>\n  ...\n</packet-filter>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following notification defines two leafrefs to refer to an existing admin-status:",
      "ja": "次の通知は、既存の管理ステータスを参照する2つのleafrefを定義しています。"
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf admin-status {\n    type leafref {\n      path \"/interface[name = current()/../if-name]\"\n         + \"/admin-status\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML notification:",
      "ja": "対応するXML通知の例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-04-01T00:01:00Z</eventTime>\n  <link-failure xmlns=\"urn:example:system\">\n    <if-name>eth0</if-name>\n    <admin-status>up</admin-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.10. The identityref Built-In Type",
      "section_title": true,
      "ja": "9.10. identityref組み込み型"
    },
    {
      "indent": 3,
      "text": "The identityref built-in type is used to reference an existing identity (see Section 7.18).",
      "ja": "identityref組み込みタイプは、既存のIDを参照するために使用されます（7.18節を参照）。"
    },
    {
      "indent": 0,
      "text": "9.10.1. Restrictions",
      "section_title": true,
      "ja": "9.10.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An identityref cannot be restricted.",
      "ja": "identityrefを制限することはできません。"
    },
    {
      "indent": 0,
      "text": "9.10.2. The identityref's \"base\" Statement",
      "section_title": true,
      "ja": "9.10.2. identityrefの「ベース」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is a substatement to the \"type\" statement, MUST be present at least once if the type is \"identityref\". The argument is the name of an identity, as defined by an \"identity\" statement. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "「type」ステートメントのサブステートメントである「base」ステートメントは、タイプが「identityref」の場合、少なくとも1回存在する必要があります。引数は、「identity」ステートメントで定義されているIDの名前です。 ID名にプレフィックスが存在する場合は、そのプレフィックスを使用してインポートされたモジュールで定義されたIDを参照します。それ以外の場合、一致する名前のIDは、現在のモジュールまたは含まれているサブモジュールで定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "Valid values for an identityref are any identities derived from all the identityref's base identities. On a particular server, the valid values are further restricted to the set of identities defined in the modules implemented by the server.",
      "ja": "identityrefの有効な値は、すべてのidentityrefの基本IDから派生したIDです。特定のサーバーでは、有効な値は、サーバーによって実装されたモジュールで定義されたIDのセットにさらに制限されます。"
    },
    {
      "indent": 0,
      "text": "9.10.3. Lexical Representation",
      "section_title": true,
      "ja": "9.10.3. 字句表現"
    },
    {
      "indent": 3,
      "text": "An identityref is lexically represented as the referred identity's qualified name as defined in [XML-NAMES]. If the prefix is not present, the namespace of the identityref is the default namespace in effect on the element that contains the identityref value.",
      "ja": "identityrefは、[XML-NAMES]で定義されているように、参照されるIDの修飾名として字句的に表現されます。プレフィックスが存在しない場合、identityrefの名前空間は、identityref値を含む要素に有効なデフォルトの名前空間です。"
    },
    {
      "indent": 0,
      "text": " When an identityref is given a default value using the \"default\" statement, the identity name in the default value MAY have a prefix. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix, or the prefix for the current module if the identity is defined in the current module or one of its submodules. Otherwise, an identity with the matching name MUST be defined in the current module or one of its submodules.",
      "ja": "identityrefに「default」ステートメントを使用してデフォルト値を指定すると、デフォルト値のID名にプレフィックスが付いている場合があります。 ID名にプレフィックスが存在する場合、そのプレフィックスでインポートされたモジュールで定義されたID、または現在のモジュールまたはそのサブモジュールの1つでIDが定義されている場合は現在のモジュールのプレフィックスを指します。それ以外の場合、一致する名前のIDは、現在のモジュールまたはそのサブモジュールの1つで定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The string value of a node of type \"identityref\" in a \"must\" or \"when\" XPath expression is the referred identity's qualified name with the prefix present. If the referred identity is defined in an imported module, the prefix in the string value is the prefix defined in the corresponding \"import\" statement. Otherwise, the prefix in the string value is the prefix for the current module.",
      "ja": "「必須」または「いつ」のXPath式におけるタイプ「identityref」のノードのストリング値は、プレフィックスが存在する参照IDの修飾名です。参照されたIDがインポートされたモジュールで定義されている場合、文字列値のプレフィックスは、対応する「インポート」ステートメントで定義されたプレフィックスです。それ以外の場合、文字列値のプレフィックスは現在のモジュールのプレフィックスです。"
    },
    {
      "indent": 0,
      "text": "9.10.4. Canonical Form",
      "section_title": true,
      "ja": "9.10.4. 正規形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "ja": "字句形式は値が発生するXMLコンテキストに依存するため、この型には標準形式がありません。"
    },
    {
      "indent": 0,
      "text": "9.10.5. Usage Example",
      "section_title": true,
      "ja": "9.10.5. 使用例"
    },
    {
      "indent": 3,
      "text": "With the identity definitions in Section 7.18.3 and the following module:",
      "ja": "セクション7.18.3のID定義と次のモジュールを使用します。"
    },
    {
      "indent": 5,
      "text": "module example-my-crypto {\n  yang-version 1.1;\n  namespace \"urn:example:my-crypto\";\n  prefix mc;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" {\n  prefix \"crypto\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "identity aes {\n  base \"crypto:crypto-alg\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "leaf crypto {\n  type identityref {\n    base \"crypto:crypto-alg\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  container aes-parameters {\n    when \"../crypto = 'mc:aes'\";\n    ...\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is an example of how the leaf \"crypto\" can be encoded, if the value is the \"des3\" identity defined in the \"des\" module:",
      "ja": "以下は、値が「des」モジュールで定義された「des3」識別である場合、リーフ「crypto」をエンコードする方法の例です。"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:des=\"urn:example:des\">des:des3</crypto>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same identityref may be encoded differently by different implementations. For example, the following example encodes the same leaf as above:",
      "ja": "エンコーディングで使用されるプレフィックスは、各インスタンスのエンコーディングに対してローカルです。つまり、同じidentityrefは、実装によって異なる方法でエンコードされる可能性があります。たとえば、次の例は上記と同じリーフをエンコードします。"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:x=\"urn:example:des\">x:des3</crypto>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the \"crypto\" leaf's value is instead \"aes\", defined in the \"example-my-crypto\" module, it can be encoded as:",
      "ja": "「crypto」リーフの値が「example-my-crypto」モジュールで定義されている「aes」ではなく、次のようにエンコードできます。"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:mc=\"urn:example:my-crypto\">mc:aes</crypto>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or, using the default namespace:",
      "ja": "または、デフォルトの名前空間を使用します。"
    },
    {
      "indent": 5,
      "text": "<crypto>aes</crypto>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.11. The empty Built-In Type",
      "section_title": true,
      "ja": "9.11. 空の組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The empty built-in type represents a leaf that does not have any value; it conveys information by its presence or absence.",
      "ja": "空の組み込みタイプは、値を持たないリーフを表します。それはその存在または不在によって情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "An empty type cannot have a default value.",
      "ja": "空のタイプにデフォルト値を設定することはできません。"
    },
    {
      "indent": 0,
      "text": "9.11.1. Restrictions",
      "section_title": true,
      "ja": "9.11.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An empty type cannot be restricted.",
      "ja": "空のタイプは制限できません。"
    },
    {
      "indent": 0,
      "text": "9.11.2. Lexical Representation",
      "section_title": true,
      "ja": "9.11.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "ja": "適用できません。"
    },
    {
      "indent": 0,
      "text": "9.11.3. Canonical Form",
      "section_title": true,
      "ja": "9.11.3. 正規形"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "ja": "適用できません。"
    },
    {
      "indent": 0,
      "text": "9.11.4. Usage Example",
      "section_title": true,
      "ja": "9.11.4. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following leaf:",
      "ja": "次の葉を持つ："
    },
    {
      "indent": 5,
      "text": "leaf enable-qos {\n  type empty;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is an example of a valid encoding if the leaf exists:",
      "ja": "以下は、リーフが存在する場合の有効なエンコードの例です。"
    },
    {
      "indent": 5,
      "text": "<enable-qos/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.12. The union Built-In Type",
      "section_title": true,
      "ja": "9.12. ユニオン組み込み型"
    },
    {
      "indent": 3,
      "text": "The union built-in type represents a value that corresponds to one of its member types.",
      "ja": "ユニオン組み込み型は、そのメンバー型の1つに対応する値を表します。"
    },
    {
      "indent": 3,
      "text": "When the type is \"union\", the \"type\" statement (Section 7.4) MUST be present. It is repeatedly used to specify each member type of the union. It takes as an argument a string that is the name of a member type.",
      "ja": "タイプが「共用体」である場合、「タイプ」ステートメント（セクション7.4）が存在しなければなりません（MUST）。ユニオンの各メンバータイプを指定するために繰り返し使用されます。引数として、メンバー型の名前である文字列を受け取ります。"
    },
    {
      "indent": 3,
      "text": "A member type can be of any built-in or derived type.",
      "ja": "メンバー型は、任意の組み込み型または派生型にすることができます。"
    },
    {
      "indent": 3,
      "text": "When generating an XML encoding, a value is encoded according to the rules of the member type to which the value belongs. When interpreting an XML encoding, a value is validated consecutively against each member type, in the order they are specified in the \"type\" statement, until a match is found. The type that matched will be the type of the value for the node that was validated, and the encoding is interpreted according to the rules for that type.",
      "ja": "XMLエンコードを生成するとき、値は、その値が属するメンバータイプのルールに従ってエンコードされます。 XMLエンコーディングを解釈するとき、一致が見つかるまで、「type」ステートメントで指定された順序で、各メンバータイプに対して値が連続的に検証されます。一致したタイプは、検証されたノードの値のタイプになり、エンコーディングはそのタイプのルールに従って解釈されます。"
    },
    {
      "indent": 3,
      "text": "Any default value or \"units\" property defined in the member types is not inherited by the union type.",
      "ja": "メンバータイプで定義されているデフォルト値または「units」プロパティは、共用体タイプには継承されません。"
    },
    {
      "indent": 0,
      "text": "9.12.1. Restrictions",
      "section_title": true,
      "ja": "9.12.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A union cannot be restricted. However, each member type can be restricted, based on the rules defined in Section 9.",
      "ja": "労働組合を制限することはできません。ただし、セクション9で定義されたルールに基づいて、各メンバータイプを制限できます。"
    },
    {
      "indent": 0,
      "text": "9.12.2. Lexical Representation",
      "section_title": true,
      "ja": "9.12.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a union is a value that corresponds to the representation of any one of the member types.",
      "ja": "共用体の字句表現は、メンバー型のいずれかの表現に対応する値です。"
    },
    {
      "indent": 0,
      "text": "9.12.3. Canonical Form",
      "section_title": true,
      "ja": "9.12.3. 正規形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a union value is the same as the canonical form of the member type of the value.",
      "ja": "共用体値の標準形は、値のメンバー型の標準形と同じです。"
    },
    {
      "indent": 0,
      "text": "9.12.4. Usage Example",
      "section_title": true,
      "ja": "9.12.4. 使用例"
    },
    {
      "indent": 3,
      "text": "The following is a union of an int32 and an enumeration:",
      "ja": "以下は、int32と列挙の結合です。"
    },
    {
      "indent": 5,
      "text": "type union {\n  type int32;\n  type enumeration {\n    enum \"unbounded\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Care must be taken when a member type is a leafref where the \"require-instance\" property (Section 9.9.3) is \"true\". If a leaf of such a type refers to an existing instance, the leaf's value must be revalidated if the target instance is deleted. For example, with the following definitions:",
      "ja": "メンバータイプが \"require-instance\"プロパティ（セクション9.9.3）が \"true\"であるleafrefである場合は注意が必要です。このようなタイプのリーフが既存のインスタンスを参照している場合、ターゲットインスタンスが削除されると、リーフの値を再検証する必要があります。たとえば、次の定義の場合："
    },
    {
      "indent": 5,
      "text": "list filter {\n  key name;\n  leaf name {\n    type string;\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "leaf outbound-filter {\n  type union {\n    type leafref {\n      path \"/filter/name\";\n    }\n    type enumeration {\n      enum default-filter;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "assume that there exists an entry in the filter list with the name \"http\" and that the outbound-filter leaf has this value:",
      "ja": "フィルターリストに \"http\"という名前のエントリがあり、outbound-filterリーフに次の値があると仮定します。"
    },
    {
      "indent": 5,
      "text": "<filter>\n  <name>http</name>\n</filter>\n<outbound-filter>http</outbound-filter>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the filter entry \"http\" is removed, the outbound-filter leaf's value doesn't match the leafref, and the next member type is checked. The current value (\"http\") doesn't match the enumeration, so the resulting configuration is invalid.",
      "ja": "フィルターエントリ「http」が削除された場合、outbound-filterリーフの値がleafrefと一致せず、次のメンバータイプがチェックされます。現在の値（ \"http\"）が列挙と一致しないため、結果の構成は無効です。"
    },
    {
      "indent": 3,
      "text": "If the second member type in the union had been of type \"string\" instead of an enumeration, the current value would have matched, and the resulting configuration would have been valid.",
      "ja": "ユニオンの2番目のメンバーの型が列挙型ではなく「文字列」であった場合、現在の値は一致し、結果の構成は有効でした。"
    },
    {
      "indent": 0,
      "text": "9.13. The instance-identifier Built-In Type",
      "section_title": true,
      "ja": "9.13. インスタンス識別子の組み込みタイプ"
    },
    {
      "indent": 3,
      "text": "The instance-identifier built-in type is used to uniquely identify a particular instance node in the data tree.",
      "ja": "インスタンス識別子の組み込みタイプは、データツリー内の特定のインスタンスノードを一意に識別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The syntax for an instance-identifier is a subset of the XPath abbreviated syntax, formally defined by the rule \"instance-identifier\" in Section 14. It is used to uniquely identify a node in the data tree. Predicates are used only for specifying the values for the key nodes for list entries, a value of a leaf-list entry, or a positional index for a list without keys. For identifying list entries with keys, each predicate consists of one equality test per key, and each key MUST have a corresponding predicate. If a key is of type \"empty\", it is represented as a zero-length string (\"\").",
      "ja": "instance-identifierの構文は、セクション14のルール「instance-identifier」によって正式に定義されたXPath省略構文のサブセットです。これは、データツリー内のノードを一意に識別するために使用されます。述語は、リストエントリのキーノードの値、リーフリストエントリの値、またはキーのないリストの位置インデックスの指定にのみ使用されます。キーを持つリストエントリを識別するために、各述語はキーごとに1つの等価テストで構成され、各キーには対応する述語が必要です。キーのタイプが「空」の場合、長さゼロの文字列（ \"\"）として表されます。"
    },
    {
      "indent": 3,
      "text": "If the leaf with the instance-identifier type represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the node it refers to MUST also represent configuration. Such a leaf puts a constraint on valid data. All such leaf nodes MUST reference existing nodes or leaf or leaf-list nodes with their default value in use (see Sections 7.6.1 and 7.7.2) for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "ja": "instance-identifierタイプのリーフが構成データを表し、「require-instance」プロパティー（セクション9.9.3）が「true」の場合、参照するノードも構成を表す必要があります。このようなリーフは、有効なデータに制約を課します。そのようなすべてのリーフノードは、データが有効であるために、使用中のデフォルト値（セクション7.6.1および7.7.2を参照）で既存のノードまたはリーフまたはリーフリストノードを参照する必要があります。この制約は、セクション8のルールに従って実施されます。"
    },
    {
      "indent": 3,
      "text": "The \"instance-identifier\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "「インスタンス識別子」のXPath式は、セクション6.4.1の定義に加えて、次のコンテキストで概念的に評価されます。"
    },
    {
      "indent": 3,
      "text": "o The context node is the root node in the accessible tree.",
      "ja": "o コンテキストノードは、アクセス可能なツリーのルートノードです。"
    },
    {
      "indent": 0,
      "text": "9.13.1. Restrictions",
      "section_title": true,
      "ja": "9.13.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An instance-identifier can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "ja": "インスタンス識別子は、「require-instance」ステートメント（セクション9.9.3）で制限できます。"
    },
    {
      "indent": 0,
      "text": "9.13.2. Lexical Representation",
      "section_title": true,
      "ja": "9.13.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "An instance-identifier value is lexically represented as a string. All node names in an instance-identifier value MUST be qualified with explicit namespace prefixes, and these prefixes MUST be declared in the XML namespace scope in the instance-identifier's XML element.",
      "ja": "インスタンス識別子の値は、字句的に文字列として表されます。インスタンス識別子の値のすべてのノード名は、明示的な名前空間プレフィックスで修飾する必要があり、これらのプレフィックスは、インスタンス識別子のXML要素のXML名前空間スコープで宣言する必要があります。"
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same instance-identifier may be encoded differently by different implementations.",
      "ja": "エンコーディングで使用されるプレフィックスは、各インスタンスのエンコーディングに対してローカルです。つまり、同じインスタンス識別子は、実装によって異なる方法でエンコードされる可能性があります。"
    },
    {
      "indent": 0,
      "text": "9.13.3. Canonical Form",
      "section_title": true,
      "ja": "9.13.3. 正規形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "ja": "字句形式は値が発生するXMLコンテキストに依存するため、この型には標準形式がありません。"
    },
    {
      "indent": 0,
      "text": "9.13.4. Usage Example",
      "section_title": true,
      "ja": "9.13.4. 使用例"
    },
    {
      "indent": 3,
      "text": "The following are examples of instance identifiers:",
      "ja": "以下はインスタンス識別子の例です。"
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a container */\n/ex:system/ex:services/ex:ssh",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf */\n/ex:system/ex:services/ex:ssh/ex:port",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry */\n/ex:system/ex:user[ex:name='fred']",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf in a list entry */\n/ex:system/ex:user[ex:name='fred']/ex:type",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry with two keys */\n/ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry where the second\n   key (\"enabled\") is of type \"empty\" */\n/ex:system/ex:service[ex:name='foo'][ex:enabled='']",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf-list entry */\n/ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry without keys */\n/ex:stats/ex:port[3]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. XPath Functions",
      "section_title": true,
      "ja": "10. XPath Functions"
    },
    {
      "indent": 3,
      "text": "This document defines two generic XPath functions and five YANG type-specific XPath functions. The function signatures are specified with the syntax used in [XPATH].",
      "ja": "このドキュメントでは、2つの汎用XPath関数と5つのYANGタイプ固有のXPath関数を定義しています。関数のシグネチャは、[XPATH]で使用される構文で指定されます。"
    },
    {
      "indent": 0,
      "text": "10.1. Function for Node Sets",
      "section_title": true,
      "ja": "10.1. ノードセットの機能"
    },
    {
      "indent": 0,
      "text": "10.1.1. current()",
      "section_title": true,
      "ja": "10.1.1. 電流()"
    },
    {
      "indent": 5,
      "text": "node-set current()",
      "ja": "ノードセットcurrent()"
    },
    {
      "indent": 3,
      "text": "The current() function takes no input parameters and returns a node set with the initial context node as its only member.",
      "ja": "current()関数は入力パラメーターをとらず、初期コンテキストノードを唯一のメンバーとして持つノードセットを返します。"
    },
    {
      "indent": 0,
      "text": "10.1.1.1. Usage Example",
      "section_title": true,
      "ja": "10.1.1.1. 使用例"
    },
    {
      "indent": 3,
      "text": "With this list:",
      "ja": "このリストで："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  ...\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following leaf defines a \"must\" expression that ensures that the referred interface is enabled:",
      "ja": "次のリーフは、参照されるインターフェースが有効であることを保証する「必須」の式を定義しています。"
    },
    {
      "indent": 5,
      "text": "leaf outgoing-interface {\n  type leafref {\n    path \"/interface/name\";\n  }\n  must '/interface[name=current()]/enabled = \"true\"';\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.2. Function for Strings",
      "section_title": true,
      "ja": "10.2. 文字列用の関数"
    },
    {
      "indent": 0,
      "text": "10.2.1. re-match()",
      "section_title": true,
      "ja": "10.2.1. 再戦()"
    },
    {
      "indent": 5,
      "text": "boolean re-match(string subject, string pattern)",
      "ja": "ブール再照合（文字列の件名、文字列のパターン）"
    },
    {
      "indent": 3,
      "text": "The re-match() function returns \"true\" if the \"subject\" string matches the regular expression \"pattern\"; otherwise, it returns \"false\".",
      "ja": "re-match()関数は、「subject」文字列が正規表現「pattern」と一致する場合に「true」を返します。それ以外の場合は「false」を返します。"
    },
    {
      "indent": 3,
      "text": "The re-match() function checks to see if a string matches a given regular expression. The regular expressions used are the XML Schema regular expressions [XSD-TYPES]. Note that this includes implicit anchoring of the regular expression at the head and tail.",
      "ja": "re-match()関数は、文字列が指定された正規表現に一致するかどうかを確認します。使用される正規表現は、XMLスキーマの正規表現[XSD-TYPES]です。これには、先​​頭と末尾での正規表現の暗黙的なアンカーが含まれることに注意してください。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1. Usage Example",
      "section_title": true,
      "ja": "10.2.1.1. 使用例"
    },
    {
      "indent": 3,
      "text": "The expression:",
      "ja": "The expression:"
    },
    {
      "indent": 5,
      "text": "re-match(\"1.22.333\", \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "returns \"true\".",
      "ja": "「true」を返します。"
    },
    {
      "indent": 3,
      "text": "To count all logical interfaces called eth0.<number>, do:",
      "ja": "eth0。<number>と呼ばれるすべての論理インターフェースをカウントするには、次のようにします。"
    },
    {
      "indent": 5,
      "text": "count(/interface[re-match(name, \"eth0\\.\\d+\")])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.3. Function for the YANG Types \"leafref\" and \"instance-identifier\"",
      "section_title": true,
      "ja": "10.3. YANGタイプ「leafref」および「instance-identifier」の関数"
    },
    {
      "indent": 0,
      "text": "10.3.1. deref()",
      "section_title": true,
      "ja": "10.3.1. deref()"
    },
    {
      "indent": 5,
      "text": "node-set deref(node-set nodes)",
      "ja": "ノードセットderef（ノードセットノード）"
    },
    {
      "indent": 3,
      "text": "The deref() function follows the reference defined by the first node in document order in the argument \"nodes\" and returns the nodes it refers to.",
      "ja": "deref()関数は、引数「nodes」のドキュメント順で最初のノードによって定義された参照に従い、参照するノードを返します。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"instance-identifier\", the function returns a node set that contains the single node that the instance identifier refers to, if it exists. If no such node exists, an empty node set is returned.",
      "ja": "最初の引数ノードのタイプが「インスタンス識別子」の場合、この関数は、インスタンス識別子が存在する場合、インスタンス識別子が参照する単一ノードを含むノードセットを返します。そのようなノードが存在しない場合、空のノードセットが返されます。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"leafref\", the function returns a node set that contains the nodes that the leafref refers to. Specifically, this set contains the nodes selected by the leafref's \"path\" statement (Section 9.9.2) that have the same value as the first argument node.",
      "ja": "最初の引数ノードのタイプが「leafref」の場合、関数は、leafrefが参照するノードを含むノードセットを返します。具体的には、このセットには、最初の引数ノードと同じ値を持つ、leafrefの「パス」ステートメント（セクション9.9.2）によって選択されたノードが含まれます。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of any other type, an empty node set is returned.",
      "ja": "最初の引数ノードが他のタイプの場合、空のノードセットが返されます。"
    },
    {
      "indent": 0,
      "text": "10.3.1.1. Usage Example",
      "section_title": true,
      "ja": "10.3.1.1. Usage Example"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name type\";\n  leaf name { ... }\n  leaf type { ... }\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "container mgmt-interface {\n  leaf name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf type {\n    type leafref {\n      path \"/interface[name=current()/../name]/type\";\n    }\n    must 'deref(.)/../enabled = \"true\"' {\n      error-message\n        \"The management interface cannot be disabled.\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.4. Functions for the YANG Type \"identityref\"",
      "section_title": true,
      "ja": "10.4. Functions for the YANG Type \"identityref\""
    },
    {
      "indent": 0,
      "text": "10.4.1. derived-from()",
      "section_title": true,
      "ja": "10.4.1. に由来する()"
    },
    {
      "indent": 5,
      "text": "boolean derived-from(node-set nodes, string identity)",
      "ja": "ブール派生-（ノードセットノード、文字列ID）"
    },
    {
      "indent": 3,
      "text": "The derived-from() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "ja": "The derived-from() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\"."
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "ja": "パラメータ「identity」は、セクション14のルール「identifier-ref」に一致する文字列です。アイデンティティにプレフィックスが存在する場合、そのプレフィックスを使用してインポートされたモジュールで定義されたアイデンティティを参照します。プレフィックスは、ローカルモジュールのプレフィックスと一致します。プレフィックスが存在しない場合、IDは現在のモジュールまたは含まれているサブモジュールで定義されているIDを参照します。"
    },
    {
      "indent": 0,
      "text": "10.4.1.1. Usage Example",
      "section_title": true,
      "ja": "10.4.1.1. 使用例"
    },
    {
      "indent": 5,
      "text": "module example-interface {\n  yang-version 1.1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "... identity interface-type;",
      "ja": "... IDインターフェースタイプ。"
    },
    {
      "indent": 7,
      "text": "identity ethernet {\n  base interface-type;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "identity fast-ethernet {\n  base ethernet;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "identity gigabit-ethernet {\n  base ethernet;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "list interface {\n  key name;\n  ...\n  leaf type {\n    type identityref {\n      base interface-type;\n    }\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  augment \"/interface\" {\n    when 'derived-from(type, \"exif:ethernet\")';\n    // generic Ethernet definitions here\n  }\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.4.2. derived-from-or-self()",
      "section_title": true,
      "ja": "10.4.2. 派生元または自己()"
    },
    {
      "indent": 5,
      "text": "boolean derived-from-or-self(node-set nodes, string identity)",
      "ja": "booleanderived-from-from-self（node-set nodes、string identity）"
    },
    {
      "indent": 3,
      "text": "The derived-from-or-self() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is equal to or derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "ja": "引数「nodes」のいずれかのノードが「identityref」タイプのノードであり、その値が等しいか、またはそれから派生したアイデンティティである場合、derived-from-or-self()関数は「true」を返します（7.18節を参照してください。 2）アイデンティティ「アイデンティティ」;それ以外の場合は「false」を返します。"
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "ja": "パラメータ「identity」は、セクション14のルール「identifier-ref」に一致する文字列です。アイデンティティにプレフィックスが存在する場合、そのプレフィックスを使用してインポートされたモジュールで定義されたアイデンティティを参照します。プレフィックスは、ローカルモジュールのプレフィックスと一致します。プレフィックスが存在しない場合、IDは現在のモジュールまたは含まれているサブモジュールで定義されているIDを参照します。"
    },
    {
      "indent": 0,
      "text": "10.4.2.1. Usage Example",
      "section_title": true,
      "ja": "10.4.2.1. 使用例"
    },
    {
      "indent": 3,
      "text": "The module defined in Section 10.4.1.1 might also have:",
      "ja": "セクション10.4.1.1で定義されたモジュールには、次のものも含まれる可能性があります。"
    },
    {
      "indent": 7,
      "text": "augment \"/interface\" {\n  when 'derived-from-or-self(type, \"exif:fast-ethernet\");\n  // Fast-Ethernet-specific definitions here\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.5. Function for the YANG Type \"enumeration\"",
      "section_title": true,
      "ja": "10.5. YANGタイプ「列挙型」の関数"
    },
    {
      "indent": 0,
      "text": "10.5.1. enum-value()",
      "section_title": true,
      "ja": "10.5.1. enum-value()"
    },
    {
      "indent": 5,
      "text": "number enum-value(node-set nodes)",
      "ja": "列挙値（ノードセットノード）"
    },
    {
      "indent": 3,
      "text": "The enum-value() function checks to see if the first node in document order in the argument \"nodes\" is a node of type \"enumeration\" and returns the enum's integer value. If the \"nodes\" node set is empty or if the first node in \"nodes\" is not of type \"enumeration\", it returns NaN (not a number).",
      "ja": "enum-value()関数は、引数「nodes」のドキュメント順の最初のノードが「enumeration」タイプのノードであるかどうかを確認し、enumの整数値を返します。 「nodes」ノードセットが空の場合、または「nodes」の最初のノードが「列挙型」ではない場合、NaN（非数）を返します。"
    },
    {
      "indent": 0,
      "text": "10.5.1.1. Usage Example",
      "section_title": true,
      "ja": "10.5.1.1. 使用例"
    },
    {
      "indent": 3,
      "text": "With this data model:",
      "ja": "このデータモデルでは："
    },
    {
      "indent": 5,
      "text": "list alarm {\n  ...\n  leaf severity {\n    type enumeration {\n      enum cleared {\n        value 1;\n      }\n      enum indeterminate {\n        value 2;\n      }\n      enum minor {\n        value 3;\n      }\n      enum warning {\n        value 4;\n      }\n      enum major {\n        value 5;\n      }\n      enum critical {\n        value 6;\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following XPath expression selects only alarms that are of severity \"major\" or higher:",
      "ja": "次のXPath式は、「メジャー」以上の重大度のアラームのみを選択します。"
    },
    {
      "indent": 5,
      "text": "/alarm[enum-value(severity) >= 5]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.6. Function for the YANG Type \"bits\"",
      "section_title": true,
      "ja": "10.6. YANGタイプ「ビット」の関数"
    },
    {
      "indent": 0,
      "text": "10.6.1. bit-is-set()",
      "section_title": true,
      "ja": "10.6.1. bit-is-set()"
    },
    {
      "indent": 5,
      "text": "boolean bit-is-set(node-set nodes, string bit-name)",
      "ja": "boolean bit-is-set（node-set nodes、string bit-name）"
    },
    {
      "indent": 3,
      "text": "The bit-is-set() function returns \"true\" if the first node in document order in the argument \"nodes\" is a node of type \"bits\" and its value has the bit \"bit-name\" set; otherwise, it returns \"false\".",
      "ja": "引数「nodes」のドキュメント順の最初のノードがタイプ「bits」のノードであり、その値にビット「bit-name」が設定されている場合、bit-is-set()関数は「true」を返します。それ以外の場合は「false」を返します。"
    },
    {
      "indent": 0,
      "text": "10.6.1.1. Usage Example",
      "section_title": true,
      "ja": "10.6.1.1. 使用例"
    },
    {
      "indent": 3,
      "text": "If an interface has this leaf:",
      "ja": "インターフェイスにこのリーフがある場合："
    },
    {
      "indent": 5,
      "text": "leaf flags {\n  type bits {\n    bit UP;\n    bit PROMISCUOUS\n    bit DISABLED;\n  }\n }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following XPath expression can be used to select all interfaces with the UP flag set:",
      "ja": "次のXPath式を使用して、UPフラグが設定されたすべてのインターフェースを選択できます。"
    },
    {
      "indent": 5,
      "text": "/interface[bit-is-set(flags, \"UP\")]",
      "ja": "/ interface [bit-is-set（flags、 \"UP\"）]"
    },
    {
      "indent": 0,
      "text": "11. Updating a Module",
      "section_title": true,
      "ja": "11. Updating a Module"
    },
    {
      "indent": 3,
      "text": "As experience is gained with a module, it may be desirable to revise that module. However, changes to published modules are not allowed if they have any potential to cause interoperability problems between a client using an original specification and a server using an updated specification.",
      "ja": "モジュールの経験が得られたら、そのモジュールを修正することが望ましい場合があります。ただし、元の仕様を使用するクライアントと更新された仕様を使用するサーバーの間で相互運用性の問題を引き起こす可能性がある場合、公開されたモジュールへの変更は許可されません。"
    },
    {
      "indent": 3,
      "text": "For any published change, a new \"revision\" statement (Section 7.1.9) MUST be included in front of the existing \"revision\" statements. If there are no existing \"revision\" statements, then one MUST be added to identify the new revision. Furthermore, any necessary changes MUST be applied to any metadata statements, including the \"organization\" and \"contact\" statements (Sections 7.1.7 and 7.1.8).",
      "ja": "公開された変更については、新しい「改訂」ステートメント（セクション7.1.9）を既存の「改訂」ステートメントの前に含める必要があります。既存の「改訂」ステートメントがない場合は、新しい改訂を識別するために1つ追加する必要があります。さらに、必要な変更は、「組織」および「連絡先」ステートメントを含むすべてのメタデータステートメントに適用する必要があります（セクション7.1.7および7.1.8）。"
    },
    {
      "indent": 3,
      "text": "Note that definitions contained in a module are available to be imported by any other module and are referenced in \"import\" statements via the module name. Thus, a module name MUST NOT be changed. Furthermore, the \"namespace\" statement MUST NOT be changed, since all XML elements are qualified by the namespace.",
      "ja": "モジュールに含まれる定義は、他のモジュールからインポートすることができ、モジュール名を介して「インポート」ステートメントで参照されることに注意してください。したがって、モジュール名は変更してはなりません。さらに、すべてのXML要素は名前空間によって修飾されるため、「namespace」ステートメントを変更してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Obsolete definitions MUST NOT be removed from published modules, since their identifiers may still be referenced by other modules.",
      "ja": "Obsolete definitions MUST NOT be removed from published modules, since their identifiers may still be referenced by other modules."
    },
    {
      "indent": 3,
      "text": "A definition in a published module may be revised in any of the following ways:",
      "ja": "公開されたモジュールの定義は、次のいずれかの方法で変更できます。"
    },
    {
      "indent": 3,
      "text": "o An \"enumeration\" type may have new enums added, provided the old enums's values do not change. Note that inserting a new enum before an existing enum or reordering existing enums will result in new values for the existing enums, unless they have explicit values assigned to them.",
      "ja": "o 「列挙」タイプには、古い列挙の値が変更されない限り、新しい列挙が追加される場合があります。既存の列挙型の前に新しい列挙型を挿入したり、既存の列挙型を並べ替えたりすると、明示的な値が割り当てられていない限り、既存の列挙型の新しい値になります。"
    },
    {
      "indent": 3,
      "text": "o A \"bits\" type may have new bits added, provided the old bit positions do not change. Note that inserting a new bit before an existing bit or reordering existing bits will result in new positions for the existing bits, unless they have explicit positions assigned to them.",
      "ja": "o 「ビット」タイプには、古いビット位置が変更されない限り、新しいビットが追加される場合があります。既存のビットの前に新しいビットを挿入したり、既存のビットを並べ替えたりすると、明示的な位置が割り当てられていない限り、既存のビットの新しい位置になります。"
    },
    {
      "indent": 3,
      "text": "o A \"range\", \"length\", or \"pattern\" statement may expand the allowed value space.",
      "ja": "o 「範囲」、「長さ」、または「パターン」ステートメントは、許容値スペースを拡張する場合があります。"
    },
    {
      "indent": 3,
      "text": "o A \"default\" statement may be added to a leaf that does not have a default value (either directly or indirectly through its type).",
      "ja": "o 「デフォルト」ステートメントは、デフォルト値を持たないリーフに（直接またはそのタイプを介して間接的に）追加できます。"
    },
    {
      "indent": 3,
      "text": "o A \"units\" statement may be added.",
      "ja": "o A \"units\" statement may be added."
    },
    {
      "indent": 3,
      "text": "o A \"reference\" statement may be added or updated.",
      "ja": "o 「参照」ステートメントが追加または更新される場合があります。"
    },
    {
      "indent": 3,
      "text": "o A \"must\" statement may be removed or its constraint relaxed.",
      "ja": "o 「必須」ステートメントを削除するか、その制約を緩和することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"when\" statement may be removed or its constraint relaxed.",
      "ja": "o 「いつ」ステートメントが削除されるか、その制約が緩和されます。"
    },
    {
      "indent": 3,
      "text": "o A \"mandatory\" statement may be removed or changed from \"true\" to \"false\".",
      "ja": "o A \"mandatory\" statement may be removed or changed from \"true\" to \"false\"."
    },
    {
      "indent": 3,
      "text": "o A \"min-elements\" statement may be removed, or changed to require fewer elements.",
      "ja": "o 「min-elements」ステートメントは削除されるか、必要なエレメント数が少なくなるように変更されます。"
    },
    {
      "indent": 3,
      "text": "o A \"max-elements\" statement may be removed, or changed to allow more elements.",
      "ja": "o 「max-elements」ステートメントは、削除するか、より多くの要素を許可するように変更できます。"
    },
    {
      "indent": 3,
      "text": "o A \"description\" statement may be added or changed without changing the semantics of the definition.",
      "ja": "o 「説明」ステートメントは、定義のセマンティクスを変更せずに追加または変更できます。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be added to an \"identity\" statement.",
      "ja": "o 「ベース」ステートメントを「アイデンティティ」ステートメントに追加できます。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be removed from an \"identityref\" type, provided there is at least one \"base\" statement left.",
      "ja": "o 「base」ステートメントは、「identityref」タイプから削除できます。ただし、「base」ステートメントが少なくとも1つ残っています。"
    },
    {
      "indent": 3,
      "text": "o New typedefs, groupings, rpcs, notifications, extensions, features, and identities may be added.",
      "ja": "o 新しいtypedef、グループ、rpcs、通知、拡張機能、機能、およびIDが追加される場合があります。"
    },
    {
      "indent": 3,
      "text": "o New data definition statements may be added if they do not add mandatory nodes (Section 3) to existing nodes or at the top level in a module or submodule, or if they are conditionally dependent on a new feature (i.e., have an \"if-feature\" statement that refers to a new feature).",
      "ja": "o 新しいデータ定義ステートメントは、必須ノード（セクション3）を既存のノードに追加しない場合、またはモジュールやサブモジュールの最上位に追加しない場合、または条件付きで新しい機能に依存している場合（つまり、「if-新機能を参照する「機能」ステートメント）。"
    },
    {
      "indent": 3,
      "text": "o A new \"case\" statement may be added.",
      "ja": "o 新しい「ケース」ステートメントが追加される場合があります。"
    },
    {
      "indent": 3,
      "text": "o A node that represented state data may be changed to represent configuration, provided it is not mandatory (Section 3).",
      "ja": "o 状態データを表すノードは、必須ではない場合（セクション3）、構成を表すように変更できます。"
    },
    {
      "indent": 3,
      "text": "o An \"if-feature\" statement may be removed, provided its node is not mandatory (Section 3).",
      "ja": "o 「if-feature」ステートメントは、そのノードが必須ではない場合に削除できます（セクション3）。"
    },
    {
      "indent": 3,
      "text": "o A \"status\" statement may be added, or changed from \"current\" to \"deprecated\" or \"obsolete\", or changed from \"deprecated\" to \"obsolete\".",
      "ja": "o 「status」ステートメントが追加されるか、「current」から「deprecated」または「obsolete」に変更されるか、「deprecated」から「obsolete」に変更される場合があります。"
    },
    {
      "indent": 3,
      "text": "o A \"type\" statement may be replaced with another \"type\" statement that does not change the syntax or semantics of the type. For example, an inline type definition may be replaced with a typedef, but an int8 type cannot be replaced by an int16, since the syntax would change.",
      "ja": "o 「タイプ」ステートメントは、タイプの構文またはセマンティクスを変更しない別の「タイプ」ステートメントに置き換えることができます。たとえば、インライン型定義はtypedefに置き換えることができますが、構文が変わるため、int8型をint16に置き換えることはできません。"
    },
    {
      "indent": 3,
      "text": "o Any set of data definition nodes may be replaced with another set of syntactically and semantically equivalent nodes. For example, a set of leafs may be replaced by a \"uses\" statement of a grouping with the same leafs.",
      "ja": "o データ定義ノードの任意のセットは、構文的および意味的に等価なノードの別のセットに置き換えることができます。たとえば、葉のセットは、同じ葉を持つグループの「uses」ステートメントで置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "o A module may be split into a set of submodules or a submodule may be removed, provided the definitions in the module do not change in any way other than those allowed here.",
      "ja": "o モジュール内の定義がここで許可されている以外の方法で変更されない場合、モジュールをサブモジュールのセットに分割するか、サブモジュールを削除できます。"
    },
    {
      "indent": 3,
      "text": "o The \"prefix\" statement may be changed, provided all local uses of the prefix are also changed.",
      "ja": "o 接頭辞のすべてのローカル使用も変更されている場合、「接頭辞」ステートメントは変更される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the semantics of any previous definition are changed (i.e., if a non-editorial change is made to any definition other than those specifically allowed above), then this MUST be achieved by a new definition with a new identifier.",
      "ja": "それ以外の場合、以前の定義のセマンティクスが変更された場合（つまり、上記で特に許可されたもの以外の定義に編集上の変更が加えられた場合）、これは新しい識別子を持つ新しい定義によって達成されなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "In statements that have any data definition statements as substatements, those data definition substatements MUST NOT be reordered. If new data definition statements are added, they can be added anywhere in the sequence of existing substatements.",
      "ja": "サブステートメントとしてデータ定義ステートメントを含むステートメントでは、それらのデータ定義サブステートメントを並べ替えてはなりません（MUST NOT）。新しいデータ定義ステートメントが追加された場合、既存のサブステートメントのシーケンスのどこにでも追加できます。"
    },
    {
      "indent": 0,
      "text": "12. Coexistence with YANG Version 1",
      "section_title": true,
      "ja": "12. YANGバージョン1との共存"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module MUST NOT include a YANG version 1 submodule, and a YANG version 1 module MUST NOT include a YANG version 1.1 submodule.",
      "ja": "YANGバージョン1.1モジュールにYANGバージョン1サブモジュールを含めてはならず、YANGバージョン1モジュールにYANGバージョン1.1サブモジュールを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1 module or submodule MUST NOT import a YANG version 1.1 module by revision.",
      "ja": "YANGバージョン1モジュールまたはサブモジュールは、リビジョンによってYANGバージョン1.1モジュールをインポートしてはなりません。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module or submodule MAY import a YANG version 1 module by revision.",
      "ja": "A YANG version 1.1 module or submodule MAY import a YANG version 1 module by revision."
    },
    {
      "indent": 3,
      "text": "If a YANG version 1 module A imports module B without revision and module B is updated to YANG version 1.1, a server MAY implement both of these modules (A and B) at the same time. In such cases, a NETCONF server MUST advertise both modules using the rules defined in Section 5.6.4, and SHOULD advertise module A and the latest revision of module B that is specified with YANG version 1 according to the rules defined in [RFC6020].",
      "ja": "If a YANG version 1 module A imports module B without revision and module B is updated to YANG version 1.1, a server MAY implement both of these modules (A and B) at the same time. In such cases, a NETCONF server MUST advertise both modules using the rules defined in Section 5.6.4, and SHOULD advertise module A and the latest revision of module B that is specified with YANG version 1 according to the rules defined in [RFC6020]."
    },
    {
      "indent": 3,
      "text": "This rule exists in order to allow implementations of existing YANG version 1 modules together with YANG version 1.1 modules. Without this rule, updating a single module to YANG version 1.1 would have a cascading effect on modules that import it, requiring all of them to also be updated to YANG version 1.1, and so on.",
      "ja": "このルールは、既存のYANGバージョン1モジュールをYANGバージョン1.1モジュールと一緒に実装できるようにするために存在します。このルールがないと、単一のモジュールをYANGバージョン1.1に更新すると、それをインポートするモジュールにカスケード効果が生じ、すべてのモジュールをYANGバージョン1.1に更新する必要があり、以下同様です。"
    },
    {
      "indent": 0,
      "text": "13. YIN",
      "section_title": true,
      "ja": "13. 陰"
    },
    {
      "indent": 3,
      "text": "A YANG module can be translated into an alternative XML-based syntax called YIN. The translated module is called a YIN module. This section describes bidirectional mapping rules between the two formats.",
      "ja": "YANGモジュールは、YINと呼ばれる代替のXMLベースの構文に変換できます。翻訳されたモジュールはYINモジュールと呼ばれます。このセクションでは、2つのフォーマット間の双方向マッピングルールについて説明します。"
    },
    {
      "indent": 3,
      "text": "The YANG and YIN formats contain equivalent information using different notations. The YIN notation enables developers to represent YANG data models in XML and therefore use the rich set of XML-based tools for data filtering and validation, automated generation of code and documentation, and other tasks. Tools like XSLT or XML validators can be utilized.",
      "ja": "YANGおよびYIN形式には、異なる表記法を使用した同等の情報が含まれています。 YIN表記を使用すると、開発者はYANGデータモデルをXMLで表すことができるため、データのフィルタリングと検証、コードとドキュメントの自動生成、その他のタスクに豊富なXMLベースのツールセットを使用できます。 XSLTやXMLバリデーターなどのツールを利用できます。"
    },
    {
      "indent": 3,
      "text": "The mapping between YANG and YIN does not modify the information content of the model. Comments and whitespace are not preserved.",
      "ja": "YANGとYINの間のマッピングは、モデルの情報コンテンツを変更しません。コメントと空白は保持されません。"
    },
    {
      "indent": 0,
      "text": "13.1. Formal YIN Definition",
      "section_title": true,
      "ja": "13.1. 正式なYINの定義"
    },
    {
      "indent": 3,
      "text": "There is a one-to-one correspondence between YANG keywords and YIN elements. The local name of a YIN element is identical to the corresponding YANG keyword. This means, in particular, that the document element (root) of a YIN document is always <module> or <submodule>.",
      "ja": "There is a one-to-one correspondence between YANG keywords and YIN elements. The local name of a YIN element is identical to the corresponding YANG keyword. This means, in particular, that the document element (root) of a YIN document is always <module> or <submodule>."
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to the YANG keywords belong to the namespace whose associated URI is \"urn:ietf:params:xml:ns:yang:yin:1\".",
      "ja": "YANGキーワードに対応するYIN要素は、関連するURIが「urn：ietf：params：xml：ns：yang：yin：1」であるネームスペースに属しています。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to extension keywords belong to the namespace of the YANG module where the extension keyword is declared via the \"extension\" statement.",
      "ja": "拡張キーワードに対応するYIN要素は、拡張キーワードが「拡張」ステートメントを介して宣言されているYANGモジュールの名前空間に属しています。"
    },
    {
      "indent": 3,
      "text": "The names of all YIN elements MUST be properly qualified with their namespaces (as specified above) using the standard mechanisms of [XML-NAMES], i.e., \"xmlns\" and \"xmlns:xxx\" attributes.",
      "ja": "すべてのYIN要素の名前は、[XML-NAMES]の標準メカニズム、つまり「xmlns」属性と「xmlns：xxx」属性を使用して、名前空間（上記で指定）で適切に修飾する必要があります。"
    },
    {
      "indent": 3,
      "text": "The argument of a YANG statement is represented in YIN as either an XML attribute or a subelement of the keyword element. Table 1 defines the mapping for the set of YANG keywords. For extensions, the argument mapping is specified within the \"extension\" statement (see Section 7.19). The following rules hold for arguments:",
      "ja": "The argument of a YANG statement is represented in YIN as either an XML attribute or a subelement of the keyword element. Table 1 defines the mapping for the set of YANG keywords. For extensions, the argument mapping is specified within the \"extension\" statement (see Section 7.19). The following rules hold for arguments:"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an attribute, this attribute has no namespace.",
      "ja": "o 引数が属性として表される場合、この属性には名前空間がありません。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it is qualified by the same namespace as its parent keyword element.",
      "ja": "o 引数が要素として表される場合、その引数は、その親キーワード要素と同じ名前空間によって修飾されます。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it MUST be the first child of the keyword element.",
      "ja": "o 引数が要素として表される場合、それはキーワード要素の最初の子でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Substatements of a YANG statement are represented as (additional) children of the keyword element, and their relative order MUST be the same as the order of substatements in YANG.",
      "ja": "YANGステートメントのサブステートメントは、キーワード要素の（追加の）子として表され、それらの相対的な順序は、YANGのサブステートメントの順序と同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Comments in YANG MAY be mapped to XML comments.",
      "ja": "YANGのコメントはXMLコメントにマップされる場合があります。"
    },
    {
      "indent": 12,
      "text": "+------------------+---------------+-------------+\n| keyword          | argument name | yin-element |\n+------------------+---------------+-------------+\n| action           | name          | false       |\n| anydata          | name          | false       |\n| anyxml           | name          | false       |\n| argument         | name          | false       |\n| augment          | target-node   | false       |\n| base             | name          | false       |\n| belongs-to       | module        | false       |\n| bit              | name          | false       |\n| case             | name          | false       |\n| choice           | name          | false       |\n| config           | value         | false       |\n| contact          | text          | true        |\n| container        | name          | false       |\n| default          | value         | false       |\n| description      | text          | true        |\n| deviate          | value         | false       |\n| deviation        | target-node   | false       |\n| enum             | name          | false       |\n| error-app-tag    | value         | false       |\n| error-message    | value         | true        |\n| extension        | name          | false       |\n| feature          | name          | false       |\n| fraction-digits  | value         | false       |\n| grouping         | name          | false       |\n| identity         | name          | false       |\n| if-feature       | name          | false       |\n| import           | module        | false       |\n| include          | module        | false       |\n| input            | <no argument> | n/a         |\n| key              | value         | false       |\n| leaf             | name          | false       |\n| leaf-list        | name          | false       |\n| length           | value         | false       |\n| list             | name          | false       |\n| mandatory        | value         | false       |\n| max-elements     | value         | false       |\n| min-elements     | value         | false       |\n| modifier         | value         | false       |\n| module           | name          | false       |\n| must             | condition     | false       |\n| namespace        | uri           | false       |\n| notification     | name          | false       |\n| ordered-by       | value         | false       |\n| organization     | text          | true        |\n| output           | <no argument> | n/a         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "| path             | value         | false       |\n| pattern          | value         | false       |\n| position         | value         | false       |\n| prefix           | value         | false       |\n| presence         | value         | false       |\n| range            | value         | false       |\n| reference        | text          | true        |\n| refine           | target-node   | false       |\n| require-instance | value         | false       |\n| revision         | date          | false       |\n| revision-date    | date          | false       |\n| rpc              | name          | false       |\n| status           | value         | false       |\n| submodule        | name          | false       |\n| type             | name          | false       |\n| typedef          | name          | false       |\n| unique           | tag           | false       |\n| units            | name          | false       |\n| uses             | name          | false       |\n| value            | value         | false       |\n| when             | condition     | false       |\n| yang-version     | value         | false       |\n| yin-element      | value         | false       |\n+------------------+---------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 1: Mapping of Arguments of the YANG Statements",
      "ja": "表1：YANGステートメントの引数のマッピング"
    },
    {
      "indent": 0,
      "text": "13.1.1. Usage Example",
      "section_title": true,
      "ja": "13.1.1. Usage Example"
    },
    {
      "indent": 3,
      "text": "The following YANG module:",
      "ja": "次のYANGモジュール："
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  yang-version 1.1;\n  namespace \"urn:example:foo\";\n  prefix \"foo\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "import example-extensions {\n  prefix \"myext\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "       list interface {\n         key \"name\";\n         leaf name {\n           type string;\n         }\n         leaf mtu {\n           type uint32;\n           description \"The MTU of the interface.\";\n           myext:c-define \"MY_MTU\";\n         }\n       }\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where the extension \"c-define\" is defined in Section 7.19.3, is translated into the following YIN:",
      "ja": "拡張「c-define」はセクション7.19.3で定義されており、次のYINに変換されます。"
    },
    {
      "indent": 5,
      "text": "<module name=\"example-foo\"\n        xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\"\n        xmlns:foo=\"urn:example:foo\"\n        xmlns:myext=\"urn:example:extensions\">",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "<namespace uri=\"urn:example:foo\"/>\n<prefix value=\"foo\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "<import module=\"example-extensions\">\n  <prefix value=\"myext\"/>\n</import>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  <list name=\"interface\">\n    <key value=\"name\"/>\n    <leaf name=\"name\">\n      <type name=\"string\"/>\n    </leaf>\n    <leaf name=\"mtu\">\n      <type name=\"uint32\"/>\n      <description>\n        <text>The MTU of the interface.</text>\n      </description>\n      <myext:c-define name=\"MY_MTU\"/>\n    </leaf>\n  </list>\n</module>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14. YANG ABNF Grammar",
      "section_title": true,
      "ja": "14. ABNF文法"
    },
    {
      "indent": 3,
      "text": "In YANG, almost all statements are unordered. The ABNF grammar [RFC5234] [RFC7405] defines the canonical order. To improve module readability, it is RECOMMENDED that clauses be entered in this order.",
      "ja": "YANGでは、ほとんどすべてのステートメントは順不同です。 ABNF文法[RFC5234] [RFC7405]は標準的な順序を定義します。モジュールを読みやすくするために、句はこの順序で入力することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Within the ABNF grammar, unordered statements are marked with comments.",
      "ja": "ABNF文法では、順序付けられていないステートメントはコメントでマークされます。"
    },
    {
      "indent": 3,
      "text": "This grammar assumes that the scanner replaces YANG comments with a single space character.",
      "ja": "この文法は、スキャナーがYANGコメントを単一のスペース文字で置き換えることを前提としています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"yang.abnf\"",
      "ja": "<CODE BEGINS>ファイル \"yang.abnf\""
    },
    {
      "indent": 3,
      "text": "module-stmt = optsep module-keyword sep identifier-arg-str optsep \"{\" stmtsep module-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "ja": "module-stmt = optsep module-keyword sep identifier-arg-str optsep \"{\" stmtsep module-header-stmts link-stmts meta-stmts revision-stmts body-stmts \"}\" optsep"
    },
    {
      "indent": 3,
      "text": "submodule-stmt = optsep submodule-keyword sep identifier-arg-str optsep \"{\" stmtsep submodule-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "ja": "submodule-stmt = optsep submodule-keyword sep identifier-arg-str optsep \"{\" stmtsep submodule-header-stmts binding-stmts meta-stmts revision-stmts body-stmts \"}\" optsep"
    },
    {
      "indent": 3,
      "text": "module-header-stmts = ;; these stmts can appear in any order yang-version-stmt namespace-stmt prefix-stmt",
      "ja": "module-header-stmts = ;;これらのstmtは、任意の順序で表示できますyang-version-stmt namespace-stmt prefix-stmt"
    },
    {
      "indent": 3,
      "text": "submodule-header-stmts = ;; these stmts can appear in any order yang-version-stmt belongs-to-stmt",
      "ja": "submodule-header-stmts = ;;これらのstmtは任意の順序で表示できますyang-version-stmt belongs-to-stmt"
    },
    {
      "indent": 3,
      "text": "meta-stmts          = ;; these stmts can appear in any order\n                      [organization-stmt]\n                      [contact-stmt]\n                      [description-stmt]\n                      [reference-stmt]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "linkage-stmts       = ;; these stmts can appear in any order\n                      *import-stmt\n                      *include-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "revision-stmts      = *revision-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "body-stmts          = *(extension-stmt /\n                        feature-stmt /\n                        identity-stmt /\n                        typedef-stmt /\n                        grouping-stmt /\n                        data-def-stmt /\n                        augment-stmt /\n                        rpc-stmt /\n                        notification-stmt /\n                        deviation-stmt)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "data-def-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / choice-stmt / anydata-stmt / anyxml-stmt / uses-stmt",
      "ja": "data-def-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / choice-stmt / anydata-stmt / anyxml-stmt / uses-stmt"
    },
    {
      "indent": 3,
      "text": "yang-version-stmt = yang-version-keyword sep yang-version-arg-str stmtend",
      "ja": "yang-version-stmt = yang-version-keyword sep yang-version-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "yang-version-arg-str = < a string that matches the rule >\n                       < yang-version-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "yang-version-arg = \"1.1\"",
      "ja": "yang-version-arg = \"1.1\""
    },
    {
      "indent": 3,
      "text": "import-stmt         = import-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          prefix-stmt\n                          [revision-date-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                      \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "include-stmt        = include-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [revision-date-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "namespace-stmt      = namespace-keyword sep uri-str stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uri-str             = < a string that matches the rule >\n                      < URI in RFC 3986 >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "prefix-stmt = prefix-keyword sep prefix-arg-str stmtend",
      "ja": "prefix-stmt = prefix-keyword sep prefix-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "belongs-to-stmt = belongs-to-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt \"}\" stmtsep",
      "ja": "belongs-to-stmt = belongs-to-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "organization-stmt   = organization-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "contact-stmt        = contact-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "description-stmt    = description-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "reference-stmt      = reference-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "units-stmt          = units-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "revision-stmt = revision-keyword sep revision-date optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "revision-stmt = revision-keyword sep revision-date optsep（ \";\" / \"{\" stmtsep ;;これらのstmtは任意の順序で表示できます[description-stmt] [reference-stmt] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "revision-date       = date-arg-str",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   revision-date-stmt  = revision-date-keyword sep revision-date stmtend\n   extension-stmt      = extension-keyword sep identifier-arg-str optsep\n                         (\";\" /\n                          \"{\" stmtsep\n                              ;; these stmts can appear in any order\n                              [argument-stmt]\n                              [status-stmt]\n                              [description-stmt]\n                              [reference-stmt]\n                          \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "argument-stmt = argument-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [yin-element-stmt] \"}\") stmtsep",
      "ja": "argument-stmt = argument-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [yin-element-stmt] \"}\") stmtsep"
    },
    {
      "indent": 3,
      "text": "yin-element-stmt = yin-element-keyword sep yin-element-arg-str stmtend",
      "ja": "yin-element-stmt = yin-element-keyword sep yin-element-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "yin-element-arg-str = < a string that matches the rule >\n                      < yin-element-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "yin-element-arg     = true-keyword / false-keyword",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identity-stmt       = identity-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *base-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "base-stmt = base-keyword sep identifier-ref-arg-str stmtend",
      "ja": "base-stmt = base-keyword sep identifier-ref-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "feature-stmt        = feature-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if-feature-stmt = if-feature-keyword sep if-feature-expr-str stmtend",
      "ja": "if-feature-stmt = if-feature-keyword sep if-feature-expr-str stmtend"
    },
    {
      "indent": 3,
      "text": "if-feature-expr-str = < a string that matches the rule >\n                      < if-feature-expr >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if-feature-expr = if-feature-term [sep or-keyword sep if-feature-expr]",
      "ja": "if-feature-expr = if-feature-term [sepまたはキーワードsep if-feature-expr]"
    },
    {
      "indent": 3,
      "text": "if-feature-term = if-feature-factor [sep and-keyword sep if-feature-term]",
      "ja": "if-feature-term = if-feature-factor [sep and-keyword sep if-feature-term]"
    },
    {
      "indent": 3,
      "text": "if-feature-factor = not-keyword sep if-feature-factor / \"(\" optsep if-feature-expr optsep \")\" / identifier-ref-arg",
      "ja": "if-feature-factor = not-keyword sep if-feature-factor / \"(\" optsep if-feature-expr optsep \")\" / identifier-ref-arg"
    },
    {
      "indent": 3,
      "text": "typedef-stmt        = typedef-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          type-stmt\n                          [units-stmt]\n                          [default-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type-stmt = type-keyword sep identifier-ref-arg-str optsep (\";\" / \"{\" stmtsep [type-body-stmts] \"}\") stmtsep",
      "ja": "type-stmt = type-keyword sep identifier-ref-arg-str optsep（ \";\" / \"{\" stmtsep [type-body-stmts] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "type-body-stmts = numerical-restrictions / decimal64-specification / string-restrictions / enum-specification / leafref-specification / identityref-specification / instance-identifier-specification / bits-specification / union-specification / binary-specification",
      "ja": "type-body-stmts = numeric-restrictions / decimal64-specification / string-restrictions / enum-specification / leafref-specification / identityref-specification / instance-identifier-specification / bits-specification / union-specification / binary-specification"
    },
    {
      "indent": 3,
      "text": "numerical-restrictions = [range-stmt]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "range-stmt          = range-keyword sep range-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "decimal64-specification = ;; these stmts can appear in any order fraction-digits-stmt [range-stmt]",
      "ja": "decimal64仕様= ;;これらのstmtは、任意の順序で表示できます。fraction-digits-stmt[range-stmt]"
    },
    {
      "indent": 3,
      "text": "fraction-digits-stmt = fraction-digits-keyword sep fraction-digits-arg-str stmtend",
      "ja": "小数桁-stmt =小数桁-キーワードsep小数桁-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg-str = < a string that matches the rule >\n                          < fraction-digits-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg = (\"1\" [\"0\" / \"1\" / \"2\" / \"3\" / \"4\" /\n                            \"5\" / \"6\" / \"7\" / \"8\"])\n                      / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "string-restrictions = ;; these stmts can appear in any order [length-stmt] *pattern-stmt",
      "ja": "string-restrictions = ;;これらのstmtは任意の順序で表示できます[length-stmt] * pattern-stmt"
    },
    {
      "indent": 3,
      "text": "length-stmt         = length-keyword sep length-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pattern-stmt        = pattern-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [modifier-stmt]\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "modifier-stmt = modifier-keyword sep modifier-arg-str stmtend",
      "ja": "modifier-stmt = modifier-keyword sep modifier-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "modifier-arg-str    = < a string that matches the rule >\n                      < modifier-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "modifier-arg        = invert-match-keyword",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "default-stmt        = default-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum-specification  = 1*enum-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum-stmt           = enum-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [value-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "leafref-specification = ;; these stmts can appear in any order path-stmt [require-instance-stmt]",
      "ja": "leafref-specification = ;;これらのstmtは任意の順序で表示できますpath-stmt [require-instance-stmt]"
    },
    {
      "indent": 3,
      "text": "path-stmt           = path-keyword sep path-arg-str stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "require-instance-stmt = require-instance-keyword sep require-instance-arg-str stmtend",
      "ja": "require-instance-stmt = require-instance-keyword sep require-instance-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "require-instance-arg-str = < a string that matches the rule >\n                           < require-instance-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " require-instance-arg = true-keyword / false-keyword instance-identifier-specification = [require-instance-stmt]",
      "ja": "require-instance-arg = true-keyword / false-keyword instance-identifier-specification = [require-instance-stmt]"
    },
    {
      "indent": 3,
      "text": "identityref-specification =\n                      1*base-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union-specification = 1*type-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "binary-specification = [length-stmt]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "bits-specification  = 1*bit-stmt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "bit-stmt            = bit-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [position-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "position-stmt = position-keyword sep position-value-arg-str stmtend",
      "ja": "position-stmt = position-keyword sep position-value-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "position-value-arg-str = < a string that matches the rule >\n                         < position-value-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "position-value-arg  = non-negative-integer-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "status-stmt = status-keyword sep status-arg-str stmtend",
      "ja": "status-stmt = status-keyword sep status-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "status-arg-str      = < a string that matches the rule >\n                      < status-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "status-arg = current-keyword / obsolete-keyword / deprecated-keyword",
      "ja": "status-arg = current-keyword / obsolete-keyword / deprecated-keyword"
    },
    {
      "indent": 3,
      "text": "config-stmt = config-keyword sep config-arg-str stmtend",
      "ja": "config-stmt = config-keyword sep config-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "config-arg-str      = < a string that matches the rule >\n                      < config-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " config-arg = true-keyword / false-keyword mandatory-stmt = mandatory-keyword sep mandatory-arg-str stmtend",
      "ja": "config-arg = true-keyword / false-keyword必須-stmt =必須キーワードsep必須-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "mandatory-arg-str   = < a string that matches the rule >\n                      < mandatory-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "mandatory-arg       = true-keyword / false-keyword",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "presence-stmt       = presence-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ordered-by-stmt = ordered-by-keyword sep ordered-by-arg-str stmtend",
      "ja": "ordered-by-stmt = ordered-by-keyword sep ordered-by-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "ordered-by-arg-str  = < a string that matches the rule >\n                      < ordered-by-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ordered-by-arg      = user-keyword / system-keyword",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "must-stmt           = must-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "error-message-stmt  = error-message-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "error-app-tag-stmt  = error-app-tag-keyword sep string stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "min-elements-stmt = min-elements-keyword sep min-value-arg-str stmtend",
      "ja": "min-elements-stmt = min-elements-keyword sep min-value-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "min-value-arg-str   = < a string that matches the rule >\n                      < min-value-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "min-value-arg       = non-negative-integer-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "max-elements-stmt = max-elements-keyword sep max-value-arg-str stmtend",
      "ja": "max-elements-stmt = max-elements-keyword sep max-value-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "max-value-arg-str   = < a string that matches the rule >\n                      < max-value-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "max-value-arg = unbounded-keyword / positive-integer-value",
      "ja": "max-value-arg = unbounded-keyword /正の整数値"
    },
    {
      "indent": 3,
      "text": "value-stmt = value-keyword sep integer-value-str stmtend",
      "ja": "value-stmt = value-keyword sep integer-value-str stmtend"
    },
    {
      "indent": 3,
      "text": "integer-value-str   = < a string that matches the rule >\n                      < integer-value >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "grouping-stmt       = grouping-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                           *action-stmt\n                           *notification-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "container-stmt      = container-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [presence-stmt]\n                           [config-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                           *action-stmt\n                           *notification-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "leaf-stmt           = leaf-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          type-stmt\n                          [units-stmt]\n                          *must-stmt\n                          [default-stmt]\n                          [config-stmt]\n                          [mandatory-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          type-stmt stmtsep\n                          [units-stmt]\n                          *must-stmt\n                          *default-stmt\n                          [config-stmt]\n                          [min-elements-stmt]\n                          [max-elements-stmt]\n                          [ordered-by-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "list-stmt           = list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          *must-stmt\n                          [key-stmt]\n                          *unique-stmt\n                          [config-stmt]\n                          [min-elements-stmt]\n                          [max-elements-stmt]\n                          [ordered-by-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                          *action-stmt\n                          *notification-stmt\n                       \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key-stmt            = key-keyword sep key-arg-str stmtend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key-arg-str         = < a string that matches the rule >\n                      < key-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key-arg = node-identifier *(sep node-identifier)",
      "ja": "けｙーあｒｇ ＝ のでーいでんちふぃえｒ ＊（せｐ のでーいでんちふぃえｒ）"
    },
    {
      "indent": 3,
      "text": "unique-stmt = unique-keyword sep unique-arg-str stmtend",
      "ja": "unique-stmt =一意のキーワードsep unique-arg-str stmtend"
    },
    {
      "indent": 3,
      "text": "unique-arg-str      = < a string that matches the rule >\n                      < unique-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "unique-arg = descendant-schema-nodeid *(sep descendant-schema-nodeid)",
      "ja": "unique-arg = descendant-schema-nodeid *（sep descendant-schema-nodeid）"
    },
    {
      "indent": 3,
      "text": "choice-stmt         = choice-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [default-stmt]\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(short-case-stmt / case-stmt)\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "short-case-stmt = choice-stmt / container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / anydata-stmt / anyxml-stmt",
      "ja": "short-case-stmt = choice-stmt / container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / anydata-stmt / anyxml-stmt"
    },
    {
      "indent": 3,
      "text": "case-stmt           = case-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *data-def-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "anydata-stmt        = anydata-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "anyxml-stmt         = anyxml-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uses-stmt           = uses-keyword sep identifier-ref-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *refine-stmt\n                           *uses-augment-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "refine-stmt         = refine-keyword sep refine-arg-str optsep\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *must-stmt\n                           [presence-stmt]\n                           *default-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                         \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "refine-arg-str      = < a string that matches the rule >\n                      < refine-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "refine-arg          = descendant-schema-nodeid",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uses-augment-stmt   = augment-keyword sep uses-augment-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                          1*(data-def-stmt / case-stmt /\n                             action-stmt / notification-stmt)\n                       \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uses-augment-arg-str = < a string that matches the rule >\n                       < uses-augment-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   uses-augment-arg    = descendant-schema-nodeid\n   augment-stmt        = augment-keyword sep augment-arg-str optsep\n                         \"{\" stmtsep\n                             ;; these stmts can appear in any order\n                             [when-stmt]\n                             *if-feature-stmt\n                             [status-stmt]\n                             [description-stmt]\n                             [reference-stmt]\n                             1*(data-def-stmt / case-stmt /\n                                action-stmt / notification-stmt)\n                          \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "augment-arg-str     = < a string that matches the rule >\n                      < augment-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "augment-arg         = absolute-schema-nodeid",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "when-stmt = when-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "when-stmt = when-keyword sep string optsep（ \";\" / \"{\" stmtsep ;;これらのstmtは任意の順序で表示できます[description-stmt] [reference-stmt] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "rpc-stmt            = rpc-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           [input-stmt]\n                           [output-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "action-stmt         = action-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           [input-stmt]\n                           [output-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "input-stmt          = input-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *must-stmt\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                      \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "output-stmt         = output-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *must-stmt\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                      \"}\" stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "notification-stmt   = notification-keyword sep\n                      identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *must-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "deviation-stmt = deviation-keyword sep deviation-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] (deviate-not-supported-stmt / 1*(deviate-add-stmt / deviate-replace-stmt / deviate-delete-stmt)) \"}\" stmtsep",
      "ja": "偏差-stmt =偏差-キーワードsep偏差-arg-str optsep \"{\" stmtsep ;;これらのstmtは任意の順序で表示できます[description-stmt] [reference-stmt]（deviate-not-supported-stmt / 1 *（deviate-add-stmt / deviate-replace-stmt / deviate-delete-stmt）） \"} \"stmtsep"
    },
    {
      "indent": 3,
      "text": "deviation-arg-str   = < a string that matches the rule >\n                      < deviation-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "deviation-arg       = absolute-schema-nodeid",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "deviate-not-supported-stmt = deviate-keyword sep not-supported-keyword-str stmtend",
      "ja": "deviate-not-supported-stmt = deviate-keyword sep not-supported-keyword-str stmtend"
    },
    {
      "indent": 3,
      "text": "deviate-add-stmt    = deviate-keyword sep add-keyword-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [units-stmt]\n                           *must-stmt\n                           *unique-stmt\n                           *default-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "deviate-delete-stmt = deviate-keyword sep delete-keyword-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [units-stmt] *must-stmt *unique-stmt *default-stmt \"}\") stmtsep",
      "ja": "deviate-delete-stmt = deviate-keyword sep delete-keyword-str optsep（ \";\" / \"{\" stmtsep ;;これらのstmtは任意の順序で表示できます[units-stmt] * must-stmt * unique-stmt * default- stmt \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "deviate-replace-stmt = deviate-keyword sep replace-keyword-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [type-stmt]\n                           [units-stmt]\n                           [default-stmt]\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "not-supported-keyword-str = < a string that matches the rule >\n                            < not-supported-keyword >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "add-keyword-str     = < a string that matches the rule >\n                      < add-keyword >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "delete-keyword-str  = < a string that matches the rule >\n                      < delete-keyword >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "replace-keyword-str = < a string that matches the rule >\n                      < replace-keyword >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; represents the usage of an extension\nunknown-statement   = prefix \":\" identifier [sep string] optsep\n                      (\";\" /\n                       \"{\" optsep\n                           *((yang-stmt / unknown-statement) optsep)\n                        \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " yang-stmt = action-stmt / anydata-stmt / anyxml-stmt / argument-stmt / augment-stmt / base-stmt / belongs-to-stmt / bit-stmt / case-stmt / choice-stmt / config-stmt / contact-stmt / container-stmt / default-stmt / description-stmt / deviate-add-stmt / deviate-delete-stmt / deviate-not-supported-stmt / deviate-replace-stmt / deviation-stmt / enum-stmt / error-app-tag-stmt / error-message-stmt / extension-stmt / feature-stmt / fraction-digits-stmt / grouping-stmt / identity-stmt / if-feature-stmt / import-stmt / include-stmt / input-stmt / key-stmt / leaf-list-stmt / leaf-stmt / length-stmt / list-stmt / mandatory-stmt / max-elements-stmt / min-elements-stmt / modifier-stmt / module-stmt / must-stmt / namespace-stmt / notification-stmt / ordered-by-stmt / organization-stmt / output-stmt / path-stmt / pattern-stmt / position-stmt / prefix-stmt / presence-stmt / range-stmt / reference-stmt / refine-stmt / require-instance-stmt / revision-date-stmt / revision-stmt / rpc-stmt / status-stmt / submodule-stmt / typedef-stmt / type-stmt / unique-stmt / units-stmt / uses-augment-stmt / uses-stmt / value-stmt / when-stmt / yang-version-stmt / yin-element-stmt",
      "ja": "yang-stmt = action-stmt / anydata-stmt / anyxml-stmt / argument-stmt / augment-stmt / base-stmt / belongs-to-stmt / bit-stmt / case-stmt / choice-stmt / config-stmt / contact-stmt / container-stmt / default-stmt / description-stmt / deviate-add-stmt / deviate-delete-stmt / deviate-not-supported-stmt / deviate-replace-stmt /偏差-stmt / enum-stmt / error-app-tag-stmt / error-message-stmt / extension-stmt / feature-stmt / fraction-digits-stmt / grouping-stmt / identity-stmt / if-feature-stmt / import-stmt / include-stmt / input-stmt / key-stmt / leaf-list-stmt / leaf-stmt / length-stmt / list-stmt / required-stmt / max-elements-stmt / min-elements-stmt / modifier-stmt / module-stmt / must-stmt / namespace-stmt / notification-stmt / ordered-by-stmt / organization-stmt / output-stmt / path-stmt / pattern-stmt / position-stmt / prefix-stmt / presents-stmt / range-stmt / reference-stmt / refine-stmt / require-instance-stmt / revision-date-stmt / revision-stmt / rpc-stmt / status-stmt / submodule-stmt / typedef-stmt / type-stmt / unique-stmt / units-stmt / uses-augment-stmt / uses-stmt / value-stmt / when-stmt / yang-version-stmt / yin-element-stmt"
    },
    {
      "indent": 3,
      "text": ";; Ranges",
      "ja": ";;範囲"
    },
    {
      "indent": 3,
      "text": "range-arg-str       = < a string that matches the rule >\n                      < range-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "range-arg = range-part *(optsep \"|\" optsep range-part)",
      "ja": "range-arg = range-part *（optsep \"|\" optsep range-part）"
    },
    {
      "indent": 3,
      "text": "range-part = range-boundary [optsep \"..\" optsep range-boundary]",
      "ja": "range-part = range-boundary [optsep \"..\" optsep range-boundary]"
    },
    {
      "indent": 3,
      "text": "range-boundary      = min-keyword / max-keyword /\n                      integer-value / decimal-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; Lengths",
      "ja": ";;長さ"
    },
    {
      "indent": 3,
      "text": "length-arg-str      = < a string that matches the rule >\n                      < length-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "length-arg = length-part *(optsep \"|\" optsep length-part)",
      "ja": "length-arg = length-part *（optsep \"|\" optsep length-part）"
    },
    {
      "indent": 3,
      "text": "length-part = length-boundary [optsep \"..\" optsep length-boundary]",
      "ja": "length-part = length-boundary [optsep \"..\" optsep length-boundary]"
    },
    {
      "indent": 3,
      "text": "length-boundary = min-keyword / max-keyword / non-negative-integer-value",
      "ja": "length-boundary = min-keyword / max-keyword / non-negative-integer-value"
    },
    {
      "indent": 3,
      "text": ";; Date",
      "ja": ";;日付"
    },
    {
      "indent": 3,
      "text": "date-arg-str        = < a string that matches the rule >\n                      < date-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "date-arg = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT",
      "ja": "日付引数= 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT"
    },
    {
      "indent": 3,
      "text": ";; Schema Node Identifiers",
      "ja": ";;スキーマノード識別子"
    },
    {
      "indent": 3,
      "text": "schema-nodeid = absolute-schema-nodeid / descendant-schema-nodeid",
      "ja": "schema-nodeid = absolute-schema-nodeid / descendant-schema-nodeid"
    },
    {
      "indent": 0,
      "text": "   absolute-schema-nodeid = 1*(\"/\" node-identifier)\n   descendant-schema-nodeid =\n                         node-identifier\n                         [absolute-schema-nodeid]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "node-identifier     = [prefix \":\"] identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; Instance Identifiers",
      "ja": ";;インスタンス識別子"
    },
    {
      "indent": 3,
      "text": "instance-identifier = 1*(\"/\" (node-identifier\n                              [1*key-predicate /\n                               leaf-list-predicate /\n                               pos]))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key-predicate       = \"[\" *WSP key-predicate-expr *WSP \"]\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key-predicate-expr  = node-identifier *WSP \"=\" *WSP quoted-string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate = \"[\" *WSP leaf-list-predicate-expr *WSP \"]\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate-expr = \".\" *WSP \"=\" *WSP quoted-string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pos                 = \"[\" *WSP positive-integer-value *WSP \"]\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "quoted-string       = (DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; leafref path",
      "ja": ";; leafrefパス"
    },
    {
      "indent": 3,
      "text": "path-arg-str        = < a string that matches the rule >\n                      < path-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "path-arg            = absolute-path / relative-path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "absolute-path       = 1*(\"/\" (node-identifier *path-predicate))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "relative-path       = 1*(\"../\") descendant-path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "descendant-path = node-identifier [*path-predicate absolute-path]",
      "ja": "descendant-path = node-identifier [* path-predicate absolute-path]"
    },
    {
      "indent": 3,
      "text": "path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n                      rel-path-keyexpr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n                      *(node-identifier *WSP \"/\" *WSP)\n                      node-identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";;; Keywords, using the syntax for case-sensitive strings (RFC 7405)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   ;; statement keywords\n   action-keyword           = %s\"action\"\n   anydata-keyword          = %s\"anydata\"\n   anyxml-keyword           = %s\"anyxml\"\n   argument-keyword         = %s\"argument\"\n   augment-keyword          = %s\"augment\"\n   base-keyword             = %s\"base\"\n   belongs-to-keyword       = %s\"belongs-to\"\n   bit-keyword              = %s\"bit\"\n   case-keyword             = %s\"case\"\n   choice-keyword           = %s\"choice\"\n   config-keyword           = %s\"config\"\n   contact-keyword          = %s\"contact\"\n   container-keyword        = %s\"container\"\n   default-keyword          = %s\"default\"\n   description-keyword      = %s\"description\"\n   deviate-keyword          = %s\"deviate\"\n   deviation-keyword        = %s\"deviation\"\n   enum-keyword             = %s\"enum\"\n   error-app-tag-keyword    = %s\"error-app-tag\"\n   error-message-keyword    = %s\"error-message\"\n   extension-keyword        = %s\"extension\"\n   feature-keyword          = %s\"feature\"\n   fraction-digits-keyword  = %s\"fraction-digits\"\n   grouping-keyword         = %s\"grouping\"\n   identity-keyword         = %s\"identity\"\n   if-feature-keyword       = %s\"if-feature\"\n   import-keyword           = %s\"import\"\n   include-keyword          = %s\"include\"\n   input-keyword            = %s\"input\"\n   key-keyword              = %s\"key\"\n   leaf-keyword             = %s\"leaf\"\n   leaf-list-keyword        = %s\"leaf-list\"\n   length-keyword           = %s\"length\"\n   list-keyword             = %s\"list\"\n   mandatory-keyword        = %s\"mandatory\"\n   max-elements-keyword     = %s\"max-elements\"\n   min-elements-keyword     = %s\"min-elements\"\n   modifier-keyword         = %s\"modifier\"\n   module-keyword           = %s\"module\"\n   must-keyword             = %s\"must\"\n   namespace-keyword        = %s\"namespace\"\n   notification-keyword     = %s\"notification\"\n   ordered-by-keyword       = %s\"ordered-by\"\n   organization-keyword     = %s\"organization\"\n   output-keyword           = %s\"output\"\n   path-keyword             = %s\"path\"\n   pattern-keyword          = %s\"pattern\"\n   position-keyword         = %s\"position\"\n   prefix-keyword           = %s\"prefix\"\n   presence-keyword         = %s\"presence\"\n   range-keyword            = %s\"range\"\n   reference-keyword        = %s\"reference\"\n   refine-keyword           = %s\"refine\"\n   require-instance-keyword = %s\"require-instance\"\n   revision-keyword         = %s\"revision\"\n   revision-date-keyword    = %s\"revision-date\"\n   rpc-keyword              = %s\"rpc\"\n   status-keyword           = %s\"status\"\n   submodule-keyword        = %s\"submodule\"\n   type-keyword             = %s\"type\"\n   typedef-keyword          = %s\"typedef\"\n   unique-keyword           = %s\"unique\"\n   units-keyword            = %s\"units\"\n   uses-keyword             = %s\"uses\"\n   value-keyword            = %s\"value\"\n   when-keyword             = %s\"when\"\n   yang-version-keyword     = %s\"yang-version\"\n   yin-element-keyword      = %s\"yin-element\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; other keywords",
      "ja": ";;他のキーワード"
    },
    {
      "indent": 0,
      "text": "   add-keyword              = %s\"add\"\n   current-keyword          = %s\"current\"\n   delete-keyword           = %s\"delete\"\n   deprecated-keyword       = %s\"deprecated\"\n   false-keyword            = %s\"false\"\n   invert-match-keyword     = %s\"invert-match\"\n   max-keyword              = %s\"max\"\n   min-keyword              = %s\"min\"\n   not-supported-keyword    = %s\"not-supported\"\n   obsolete-keyword         = %s\"obsolete\"\n   replace-keyword          = %s\"replace\"\n   system-keyword           = %s\"system\"\n   true-keyword             = %s\"true\"\n   unbounded-keyword        = %s\"unbounded\"\n   user-keyword             = %s\"user\"\n   and-keyword              = %s\"and\"\n   or-keyword               = %s\"or\"\n   not-keyword              = %s\"not\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "current-function-invocation = current-keyword *WSP \"(\" *WSP \")\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";;; Basic Rules",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "prefix-arg-str      = < a string that matches the rule >\n                      < prefix-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "prefix-arg          = prefix",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "prefix              = identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier-arg-str  = < a string that matches the rule >\n                      < identifier-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier-arg      = identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier          = (ALPHA / \"_\")\n                      *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg-str = < a string that matches the rule >\n                         < identifier-ref-arg >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg  = identifier-ref",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "identifier-ref      = [prefix \":\"] identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "string              = < an unquoted string, as returned by >\n                      < the scanner, that matches the rule >\n                      < yang-string >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "yang-string         = *yang-char",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";; any Unicode or ISO/IEC 10646 character, including tab, carriage\n;; return, and line feed but excluding the other C0 control\n;; characters, the surrogate blocks, and the noncharacters\nyang-char = %x09 / %x0A / %x0D / %x20-D7FF /\n                            ; exclude surrogate blocks %xD800-DFFF\n           %xE000-FDCF /    ; exclude noncharacters %xFDD0-FDEF\n           %xFDF0-FFFD /    ; exclude noncharacters %xFFFE-FFFF\n           %x10000-1FFFD /  ; exclude noncharacters %x1FFFE-1FFFF\n           %x20000-2FFFD /  ; exclude noncharacters %x2FFFE-2FFFF\n           %x30000-3FFFD /  ; exclude noncharacters %x3FFFE-3FFFF\n           %x40000-4FFFD /  ; exclude noncharacters %x4FFFE-4FFFF\n           %x50000-5FFFD /  ; exclude noncharacters %x5FFFE-5FFFF\n           %x60000-6FFFD /  ; exclude noncharacters %x6FFFE-6FFFF\n           %x70000-7FFFD /  ; exclude noncharacters %x7FFFE-7FFFF\n           %x80000-8FFFD /  ; exclude noncharacters %x8FFFE-8FFFF\n           %x90000-9FFFD /  ; exclude noncharacters %x9FFFE-9FFFF\n           %xA0000-AFFFD /  ; exclude noncharacters %xAFFFE-AFFFF\n           %xB0000-BFFFD /  ; exclude noncharacters %xBFFFE-BFFFF\n           %xC0000-CFFFD /  ; exclude noncharacters %xCFFFE-CFFFF\n           %xD0000-DFFFD /  ; exclude noncharacters %xDFFFE-DFFFF\n           %xE0000-EFFFD /  ; exclude noncharacters %xEFFFE-EFFFF\n           %xF0000-FFFFD /  ; exclude noncharacters %xFFFFE-FFFFF\n           %x100000-10FFFD  ; exclude noncharacters %x10FFFE-10FFFF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "integer-value       = (\"-\" non-negative-integer-value) /\n                       non-negative-integer-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "non-negative-integer-value = \"0\" / positive-integer-value",
      "ja": "非負の整数値= \"0\" /正の整数値"
    },
    {
      "indent": 3,
      "text": "positive-integer-value = (non-zero-digit *DIGIT)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "zero-integer-value  = 1*DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "stmtend             = optsep (\";\" / \"{\" stmtsep \"}\") stmtsep",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "sep                 = 1*(WSP / line-break)\n                      ; unconditional separator",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "optsep              = *(WSP / line-break)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "stmtsep             = *(WSP / line-break / unknown-statement)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "line-break          = CRLF / LF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "non-zero-digit      = %x31-39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   decimal-value       = integer-value (\".\" zero-integer-value)\n   SQUOTE              = %x27\n                         ; single quote",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ";;; core rules from RFC 5234",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ALPHA               = %x41-5A / %x61-7A\n                      ; A-Z / a-z",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CR                  = %x0D\n                      ; carriage return",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF ; Internet standard newline",
      "ja": "CRLF = CR LF;インターネット標準改行"
    },
    {
      "indent": 3,
      "text": "DIGIT               = %x30-39\n                      ; 0-9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DQUOTE              = %x22\n                      ; double quote",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTAB                = %x09\n                      ; horizontal tab",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LF                  = %x0A\n                      ; line feed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SP                  = %x20\n                      ; space",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WSP = SP / HTAB ; whitespace",
      "ja": "WSP = SP / HTAB;空白"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 0,
      "text": "15. NETCONF Error Responses for YANG-Related Errors",
      "section_title": true,
      "ja": "15. YANG関連エラーのNETCONFエラー応答"
    },
    {
      "indent": 3,
      "text": "A number of NETCONF error responses are defined for error cases related to the data model handling. If the relevant YANG statement has an \"error-app-tag\" substatement, that overrides the default value specified below.",
      "ja": "データモデルの処理に関連するエラーケースに対して、いくつかのNETCONFエラー応答が定義されています。関連するYANGステートメントに「error-app-tag」サブステートメントがある場合、それは以下で指定されたデフォルト値をオーバーライドします。"
    },
    {
      "indent": 0,
      "text": "15.1. Error Message for Data That Violates a \"unique\" Statement",
      "section_title": true,
      "ja": "15.1. Error Message for Data That Violates a \"unique\" Statement"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a \"unique\" constraint is invalidated, the following error MUST be returned:",
      "ja": "NETCONF操作の結果、構成データが「一意の」制約が無効になる場合は、次のエラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: data-not-unique error-info: <non-unique>: Contains an instance identifier that points to a leaf that invalidates the \"unique\" constraint. This element is present once for each non-unique leaf.",
      "ja": "error-tag：operation-failed error-app-tag：data-not-unique error-info：<non-unique>：「一意の」制約を無効にするリーフを指すインスタンス識別子が含まれます。この要素は、一意でない葉ごとに1つ存在します。"
    },
    {
      "indent": 21,
      "text": "The <non-unique> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "ja": "<non-unique>要素はYANGネームスペースにあります（ \"urn：ietf：params：xml：ns：yang：1\"）。"
    },
    {
      "indent": 0,
      "text": "15.2. Error Message for Data That Violates a \"max-elements\" Statement",
      "section_title": true,
      "ja": "15.2. 「max-elements」ステートメントに違反するデータのエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too many entries, the following error MUST be returned:",
      "ja": "NETCONF操作の結果、リストまたはリーフリストのエントリが多すぎる構成データになる場合は、次のエラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-many-elements",
      "ja": "error-tag: operation-failed error-app-tag: too-many-elements"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one extra child present.",
      "ja": "このエラーは1回返され、複数の子が存在する場合でも、エラーパスがリストノードを識別します。"
    },
    {
      "indent": 0,
      "text": "15.3. Error Message for Data That Violates a \"min-elements\" Statement",
      "section_title": true,
      "ja": "15.3. Error Message for Data That Violates a \"min-elements\" Statement"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too few entries, the following error MUST be returned:",
      "ja": "NETCONF操作の結果、リストまたはリーフリストのエントリが少なすぎる構成データになる場合は、次のエラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-few-elements",
      "ja": "error-tag: operation-failed error-app-tag: too-few-elements"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one child missing.",
      "ja": "このエラーは1回返され、複数の子が欠落している場合でも、エラーパスはリストノードを識別します。"
    },
    {
      "indent": 0,
      "text": "15.4. Error Message for Data That Violates a \"must\" Statement",
      "section_title": true,
      "ja": "15.4. 「必須」ステートメントに違反するデータのエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where the restrictions imposed by a \"must\" statement are violated, the following error MUST be returned, unless a specific \"error-app-tag\" substatement is present for the \"must\" statement.",
      "ja": "NETCONF操作の結果、「must」ステートメントによって課された制限に違反する構成データが生じる場合、「must」ステートメントに特定の「error-app-tag」サブステートメントが存在しない限り、次のエラーを返さなければなりません（MUST）。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: must-violation",
      "ja": "エラータグ：操作失敗エラーアプリタグ：違反する必要があります"
    },
    {
      "indent": 0,
      "text": "15.5. Error Message for Data That Violates a \"require-instance\" Statement",
      "ja": "15.5. 「require-instance」ステートメントに違反するデータのエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a leaf of type \"instance-identifier\" or \"leafref\" marked with require-instance \"true\" refers to an instance that does not exist, the following error MUST be returned:",
      "ja": "NETCONF操作の結果、タイプ「instance-identifier」または「leafref」がrequire-instance「true」でマークされたリーフが存在しないインスタンスを参照する構成データになる場合は、次のエラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: instance-required error-path: Path to the instance-identifier or leafref leaf.",
      "ja": "error-tag：データがありませんerror-app-tag：instance-required error-path：instance-identifierまたはleafrefリーフへのパス。"
    },
    {
      "indent": 0,
      "text": "15.6. Error Message for Data That Violates a Mandatory \"choice\" Statement",
      "ja": "15.6. 必須の「選択」ステートメントに違反するデータのエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where no nodes exists in a mandatory choice, the following error MUST be returned:",
      "ja": "NETCONF操作の結果、必須の選択肢にノードが存在しない構成データになる場合は、次のエラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: missing-choice error-path: Path to the element with the missing choice. error-info: <missing-choice>: Contains the name of the missing mandatory choice.",
      "ja": "error-tag：data-missing error-app-tag：missing-choice error-path：欠落している要素を持つ要素へのパス。 error-info：<missing-choice>：欠落している必須の選択肢の名前が含まれています。"
    },
    {
      "indent": 21,
      "text": "The <missing-choice> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "ja": "<missing-choice>要素は、YANGネームスペースにあります（ \"urn：ietf：params：xml：ns：yang：1\"）。"
    },
    {
      "indent": 0,
      "text": "15.7. Error Message for the \"insert\" Operation",
      "section_title": true,
      "ja": "15.7. 「挿入」操作のエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "If the \"insert\" and \"key\" or \"value\" attributes are used in an <edit-config> for a list or leaf-list node and the \"key\" or \"value\" refers to an instance that does not exist, the following error MUST be returned:",
      "ja": "リストノードまたはリーフリストノードの<edit-config>で「挿入」および「キー」または「値」属性が使用され、「キー」または「値」が存在しないインスタンスを参照している場合、次のエラーを返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: bad-attribute error-app-tag: missing-instance",
      "ja": "エラータグ：悪い属性エラーアプリタグ：行方不明のインスタンス"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "ja": "16. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers one capability identifier URN from the \"Network Configuration Protocol (NETCONF) Capability URNs\" registry:",
      "ja": "このドキュメントでは、「ネットワーク構成プロトコル（NETCONF）機能URN」レジストリから機能識別子URNを1つ登録しています。"
    },
    {
      "indent": 5,
      "text": "Index           Capability Identifier\n-------------   ---------------------------------------------------\n:yang-library   urn:ietf:params:netconf:capability:yang-library:1.0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "ja": "17. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines a language with which to write and read descriptions of management information. The language itself has no security impact on the Internet.",
      "ja": "このドキュメントでは、管理情報の説明を読み書きするための言語を定義します。言語自体がインターネットにセキュリティ上の影響を与えることはありません。"
    },
    {
      "indent": 3,
      "text": "The same considerations are relevant as those for the base NETCONF protocol (see Section 9 in [RFC6241]).",
      "ja": "基本的なNETCONFプロトコルと同じ考慮事項が関連しています（[RFC6241]のセクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG might contain sensitive information. RPCs or notifications defined in YANG might transfer sensitive information.",
      "ja": "YANGでモデル化されたデータには、機密情報が含まれている可能性があります。 YANGで定義されたRPCまたは通知は、機密情報を転送する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Security issues are related to the usage of data modeled in YANG. Such issues shall be dealt with in documents describing the data models and documents about the interfaces used to manipulate the data, e.g., the NETCONF documents.",
      "ja": "セキュリティの問題は、YANGでモデル化されたデータの使用に関連しています。このような問題は、データモデルを説明するドキュメントや、データの操作に使用されるインターフェイスに関するドキュメント（NETCONFドキュメントなど）で対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG is dependent upon:",
      "ja": "YANGでモデル化されたデータは、次のものに依存しています。"
    },
    {
      "indent": 3,
      "text": "o the security of the transmission infrastructure used to send sensitive information.",
      "ja": "o 機密情報の送信に使用される送信インフラストラクチャのセキュリティ。"
    },
    {
      "indent": 3,
      "text": "o the security of applications that store or release such sensitive information.",
      "ja": "o そのような機密情報を保存またはリリースするアプリケーションのセキュリティ。"
    },
    {
      "indent": 3,
      "text": "o adequate authentication and access control mechanisms to restrict the usage of sensitive data.",
      "ja": "o 機密データの使用を制限するための適切な認証およびアクセス制御メカニズム。"
    },
    {
      "indent": 3,
      "text": "YANG parsers need to be robust with respect to malformed documents. Reading malformed documents from unknown or untrusted sources could result in an attacker gaining the privileges of the user running the YANG parser. In an extreme situation, the entire machine could be compromised.",
      "ja": "YANGパーサーは、不正な形式のドキュメントに対して堅牢である必要があります。未知または信頼できないソースから不正な形式のドキュメントを読み取ると、攻撃者がYANGパーサーを実行しているユーザーの権限を取得する可能性があります。極端な状況では、マシン全体が危険にさらされる可能性があります。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18. 参考文献"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "ja": "18.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ISO.10646] International Organization for Standardization, \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)\", ISO Standard 10646:2014, 2014.",
      "ja": "[ISO.10646]国際標準化機構、「情報技術-ユニバーサル複数オクテットコード化文字セット（UCS）」、ISO標準10646：2014、2014。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<http：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed., and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234] Crocker, D., Ed., and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>."
    },
    {
      "indent": 3,
      "text": "[RFC5277] Chisholm, S. and H. Trevino, \"NETCONF Event Notifications\", RFC 5277, DOI 10.17487/RFC5277, July 2008, <http://www.rfc-editor.org/info/rfc5277>.",
      "ja": "[RFC5277] Chisholm、S。およびH. Trevino、「NETCONFイベント通知」、RFC 5277、DOI 10.17487 / RFC5277、2008年7月、<http://www.rfc-editor.org/info/rfc5277>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241] Enns、R。、編、Bjorklund、M。、編、Schoenwaelder、J。、編、およびA. Bierman、編、「Network Configuration Protocol（NETCONF）」、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<http://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC7405] Kyzivat, P., \"Case-Sensitive String Support in ABNF\", RFC 7405, DOI 10.17487/RFC7405, December 2014, <http://www.rfc-editor.org/info/rfc7405>.",
      "ja": "[RFC7405] Kyzivat、P。、「ABNFでの大文字と小文字を区別する文字列のサポート」、RFC 7405、DOI 10.17487 / RFC7405、2014年12月、<http://www.rfc-editor.org/info/rfc7405>。"
    },
    {
      "indent": 3,
      "text": "[RFC7895] Bierman, A., Bjorklund, M., and K. Watsen, \"YANG Module Library\", RFC 7895, DOI 10.17487/RFC7895, June 2016, <http://www.rfc-editor.org/info/rfc7895>.",
      "ja": "[RFC7895] Bierman、A.、Bjorklund、M。、およびK. Watsen、「YANG Module Library」、RFC 7895、DOI 10.17487 / RFC7895、2016年6月、<http://www.rfc-editor.org/info/ rfc7895>。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C Recommendation REC-xml-20081126, November 2008, <https://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "ja": "[XML] Bray、T.、Paoli、J.、Sperberg-McQueen、C.、Maler、E。、およびF. Yergeau、「Extensible Markup Language（XML）1.0（Fifth Edition）」、W3C勧告REC-xml- 20081126、2008年11月、<https://www.w3.org/TR/2008/REC-xml-20081126/>。"
    },
    {
      "indent": 3,
      "text": "[XML-NAMES] Bray, T., Hollander, D., Layman, A., Tobin, R., and H. Thompson, \"Namespaces in XML 1.0 (Third Edition)\", World Wide Web Consortium Recommendation REC-xml-names-20091208, December 2009, <http://www.w3.org/TR/2009/REC-xml-names-20091208>.",
      "ja": "[XML-NAMES] Bray, T., Hollander, D., Layman, A., Tobin, R., and H. Thompson, \"Namespaces in XML 1.0 (Third Edition)\", World Wide Web Consortium Recommendation REC-xml-names-20091208, December 2009, <http://www.w3.org/TR/2009/REC-xml-names-20091208>."
    },
    {
      "indent": 3,
      "text": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "ja": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>."
    },
    {
      "indent": 3,
      "text": "[XSD-TYPES] Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "ja": "[XSD-TYPES] Biron、P.およびA. Malhotra、「XML Schema Part 2：Datatypes Second Edition」、World Wide Web Consortium Recommendation REC-xmlschema-2-20041028、2004年10月、<http：//www.w3。 org / TR / 2004 / REC-xmlschema-2-20041028>。"
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "ja": "18.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CoMI] van der Stok, P. and A. Bierman, \"CoAP Management Interface\", Work in Progress, draft-vanderstok-core-comi-09, March 2016.",
      "ja": "[CoMI] van der Stok, P. and A. Bierman, \"CoAP Management Interface\", Work in Progress, draft-vanderstok-core-comi-09, March 2016."
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "ja": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>."
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "ja": "[RESTCONF] Bierman、A.、Bjorklund、M。、およびK. Watsen、「RESTCONF Protocol」、Work in Progress、draft-ietf-netconf-restconf-16、2016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, DOI 10.17487/RFC2578, April 1999, <http://www.rfc-editor.org/info/rfc2578>.",
      "ja": "[RFC2578] McCloghrie、K.、Ed。、Perkins、D.、Ed。、and J. Schoenwaelder、Ed。、 \"Structure of Management Information Version 2（SMIv2）\"、STD 58、RFC 2578、DOI 10.17487 / RFC2578、 1999年4月、<http://www.rfc-editor.org/info/rfc2578>。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Textual Conventions for SMIv2\", STD 58, RFC 2579, DOI 10.17487/RFC2579, April 1999, <http://www.rfc-editor.org/info/rfc2579>.",
      "ja": "[RFC2579] McCloghrie、K.、Ed。、Perkins、D.、Ed。、and J. Schoenwaelder、Ed。、 \"Textual Conventions for SMIv2\"、STD 58、RFC 2579、DOI 10.17487 / RFC2579、April 1999、<http ：//www.rfc-editor.org/info/rfc2579>。"
    },
    {
      "indent": 3,
      "text": "[RFC3780] Strauss, F. and J. Schoenwaelder, \"SMIng - Next Generation Structure of Management Information\", RFC 3780, DOI 10.17487/RFC3780, May 2004, <http://www.rfc-editor.org/info/rfc3780>.",
      "ja": "[RFC3780] Strauss、F.およびJ. Schoenwaelder、「SMIng-Next Generation Structure of Management Information」、RFC 3780、DOI 10.17487 / RFC3780、2004年5月、<http://www.rfc-editor.org/info/rfc3780 >。"
    },
    {
      "indent": 3,
      "text": "[RFC4844] Daigle, L., Ed., and Internet Architecture Board, \"The RFC Series and RFC Editor\", RFC 4844, DOI 10.17487/RFC4844, July 2007, <http://www.rfc-editor.org/info/rfc4844>.",
      "ja": "[RFC4844] Daigle、L.、Ed。、およびInternet Architecture Board、「The RFC Series and RFC Editor」、RFC 4844、DOI 10.17487 / RFC4844、2007年7月、<http://www.rfc-editor.org/info / rfc4844>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M。、編、「YANG-ネットワーク構成プロトコル（NETCONF）のデータモデリング言語」、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<http：//www.rfc-editor。 org / info / rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC6643] Schoenwaelder, J., \"Translation of Structure of Management Information Version 2 (SMIv2) MIB Modules to YANG Modules\", RFC 6643, DOI 10.17487/RFC6643, July 2012, <http://www.rfc-editor.org/info/rfc6643>.",
      "ja": "[RFC6643] Schoenwaelder, J., \"Translation of Structure of Management Information Version 2 (SMIv2) MIB Modules to YANG Modules\", RFC 6643, DOI 10.17487/RFC6643, July 2012, <http://www.rfc-editor.org/info/rfc6643>."
    },
    {
      "indent": 3,
      "text": "[RFC6991] Schoenwaelder, J., Ed., \"Common YANG Data Types\", RFC 6991, DOI 10.17487/RFC6991, July 2013, <http://www.rfc-editor.org/info/rfc6991>.",
      "ja": "[RFC6991] Schoenwaelder、J。、編、「Common YANG Data Types」、RFC 6991、DOI 10.17487 / RFC6991、2013年7月、<http://www.rfc-editor.org/info/rfc6991>。"
    },
    {
      "indent": 3,
      "text": "[RFC7951] Lhotka, L., \"JSON Encoding of Data Modeled with YANG\", RFC 7951, DOI 10.17487/RFC7951, August 2016, <http://www.rfc-editor.org/info/rfc7951>.",
      "ja": "[RFC7951] Lhotka、L。、「YANGでモデル化されたデータのJSONエンコーディング」、RFC 7951、DOI 10.17487 / RFC7951、2016年8月、<http://www.rfc-editor.org/info/rfc7951>。"
    },
    {
      "indent": 3,
      "text": "[XPATH2.0] Berglund, A., Boag, S., Chamberlin, D., Fernandez, M., Kay, M., Robie, J., and J. Simeon, \"XML Path Language (XPath) 2.0 (Second Edition)\", World Wide Web Consortium Recommendation REC-xpath20-20101214, December 2010, <http://www.w3.org/TR/2010/REC-xpath20-20101214>.",
      "ja": "[XPATH2.0] Berglund、A.、Boag、S.、Chamberlin、D.、Fernandez、M.、Kay、M.、Robie、J.、and J. Simeon、 \"XML Path Language（XPath）2.0（Second Edition） \"、World Wide Web Consortium Recommendation REC-xpath20-20101214、December 2010、<http://www.w3.org/TR/2010/REC-xpath20-20101214>。"
    },
    {
      "indent": 3,
      "text": "[XSLT] Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World Wide Web Consortium Recommendation REC-xslt-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xslt-19991116>.",
      "ja": "[XSLT]クラークJ。、「XSL Transformations（XSLT）Version 1.0」、World Wide Web Consortium Recommendation REC-xslt-19991116、1999年11月、<http://www.w3.org/TR/1999/REC-xslt -19991116>。"
    },
    {
      "indent": 3,
      "text": "[YANG-Guidelines] Bierman, A., \"Guidelines for Authors and Reviewers of YANG Data Model Documents\", Work in Progress, draft-ietf-netmod-rfc6087bis-07, July 2016.",
      "ja": "[YANG-Guidelines] Bierman、A。、「YANG Data Model Documentsの作成者とレビューアーのためのガイドライン」、Work in Progress、draft-ietf-netmod-rfc6087bis-07、2016年7月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor wishes to thank the following individuals, who all provided helpful comments on various draft versions of this document: Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson, Ladislav Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom Petch, Randy Presuhn, David Reid, Jernej Tuljak, Kent Watsen, Bert Wijnen, Robert Wilton, and Dale Worley.",
      "ja": "The editor wishes to thank the following individuals, who all provided helpful comments on various draft versions of this document: Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson, Ladislav Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom Petch, Randy Presuhn, David Reid, Jernej Tuljak, Kent Watsen, Bert Wijnen, Robert Wilton, and Dale Worley."
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "The following people all contributed significantly to the initial YANG document:",
      "ja": "The following people all contributed significantly to the initial YANG document:"
    },
    {
      "indent": 4,
      "text": "- Andy Bierman (YumaWorks) - Balazs Lengyel (Ericsson) - David Partain (Ericsson) - Juergen Schoenwaelder (Jacobs University Bremen) - Phil Shafer (Juniper Networks)",
      "ja": "- Andy Bierman (YumaWorks) - Balazs Lengyel (Ericsson) - David Partain (Ericsson) - Juergen Schoenwaelder (Jacobs University Bremen) - Phil Shafer (Juniper Networks)"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Bjorklund (editor) Tail-f Systems",
      "ja": "Martin Bjorklund (editor) Tail-f Systems"
    },
    {
      "indent": 3,
      "text": "Email: mbj@tail-f.com",
      "raw": true,
      "ja": ""
    }
  ]
}