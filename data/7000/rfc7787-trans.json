{
  "title": {
    "text": "RFC 7787 - Distributed Node Consensus Protocol",
    "ja": "RFC 7787 - 分散ノードコンセンサスプロトコル"
  },
  "number": 7787,
  "created_at": "2020-08-29 19:21:05.692429+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       M. Stenberg\nRequest for Comments: 7787                                      S. Barth\nCategory: Standards Track                                    Independent\nISSN: 2070-1721                                               April 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Distributed Node Consensus Protocol",
      "ja": "分散ノードコンセンサスプロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Distributed Node Consensus Protocol (DNCP), a generic state synchronization protocol that uses the Trickle algorithm and hash trees. DNCP is an abstract protocol and must be combined with a specific profile to make a complete implementable protocol.",
      "ja": "このドキュメントでは、トリクルアルゴリズムとハッシュツリーを使用する一般的な状態同期プロトコルである分散ノードコンセンサスプロトコル（DNCP）について説明します。 DNCPは抽象的なプロトコルであり、完全な実装可能なプロトコルを作成するには、特定のプロファイルと組み合わせる必要があります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7787.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7787で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Applicability . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   8\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n4.  Operation . . . . . . . . . . . . . . . . . . . . . . . . . .   9\n  4.1.  Hash Tree . . . . . . . . . . . . . . . . . . . . . . . .   9\n    4.1.1.  Calculating Network State and Node Data Hashes  . . .  10\n    4.1.2.  Updating Network State and Node Data Hashes . . . . .  10\n  4.2.  Data Transport  . . . . . . . . . . . . . . . . . . . . .  10\n  4.3.  Trickle-Driven Status Updates . . . . . . . . . . . . . .  12\n  4.4.  Processing of Received TLVs . . . . . . . . . . . . . . .  13\n  4.5.  Discovering, Adding, and Removing Peers . . . . . . . . .  15\n  4.6.  Data Liveliness Validation  . . . . . . . . . . . . . . .  16\n5.  Data Model  . . . . . . . . . . . . . . . . . . . . . . . . .  17\n6.  Optional Extensions . . . . . . . . . . . . . . . . . . . . .  19\n  6.1.  Keep-Alives . . . . . . . . . . . . . . . . . . . . . . .  19\n    6.1.1.  Data Model Additions  . . . . . . . . . . . . . . . .  20\n    6.1.2.  Per-Endpoint Periodic Keep-Alives . . . . . . . . . .  20\n    6.1.3.  Per-Peer Periodic Keep-Alives . . . . . . . . . . . .  20\n    6.1.4.  Received TLV Processing Additions . . . . . . . . . .  21\n    6.1.5.  Peer Removal  . . . . . . . . . . . . . . . . . . . .  21\n  6.2.  Support for Dense Multicast-Enabled Links . . . . . . . .  21\n7.  Type-Length-Value Objects . . . . . . . . . . . . . . . . . .  22\n  7.1.  Request TLVs  . . . . . . . . . . . . . . . . . . . . . .  23\n    7.1.1.  Request Network State TLV . . . . . . . . . . . . . .  23\n    7.1.2.  Request Node State TLV  . . . . . . . . . . . . . . .  24\n  7.2.  Data TLVs . . . . . . . . . . . . . . . . . . . . . . . .  24\n    7.2.1.  Node Endpoint TLV . . . . . . . . . . . . . . . . . .  24\n    7.2.2.  Network State TLV . . . . . . . . . . . . . . . . . .  25\n    7.2.3.  Node State TLV  . . . . . . . . . . . . . . . . . . .  25\n  7.3.  Data TLVs within Node State TLV . . . . . . . . . . . . .  26\n    7.3.1.  Peer TLV  . . . . . . . . . . . . . . . . . . . . . .  26\n    7.3.2.  Keep-Alive Interval TLV . . . . . . . . . . . . . . .  27\n8.  Security and Trust Management . . . . . . . . . . . . . . . .  27\n  8.1.  Trust Method Based on Pre-Shared Key  . . . . . . . . . .  27\n  8.2.  PKI-Based Trust Method  . . . . . . . . . . . . . . . . .  28\n  8.3.  Certificate-Based Trust Consensus Method  . . . . . . . .  28\n    8.3.1.  Trust Verdicts  . . . . . . . . . . . . . . . . . . .  28\n    8.3.2.  Trust Cache . . . . . . . . . . . . . . . . . . . . .  29\n    8.3.3.  Announcement of Verdicts  . . . . . . . . . . . . . .  30\n    8.3.4.  Bootstrap Ceremonies  . . . . . . . . . . . . . . . .  31\n9.  DNCP Profile-Specific Definitions . . . . . . . . . . . . . .  32\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  34\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n  12.1.  Normative References . . . . . . . . . . . . . . . . . .  36\n  12.2.  Informative References . . . . . . . . . . . . . . . . .  36\nAppendix A.  Alternative Modes of Operation . . . . . . . . . . .  38\n  A.1.  Read-Only Operation . . . . . . . . . . . . . . . . . . .  38\n  A.2.  Forwarding Operation  . . . . . . . . . . . . . . . . . .  38\nAppendix B.  DNCP Profile Additional Guidance . . . . . . . . . .  38\n  B.1.  Unicast Transport -- UDP or TCP?  . . . . . . . . . . . .  38\n  B.2.  (Optional) Multicast Transport  . . . . . . . . . . . . .  39\n  B.3.  (Optional) Transport Security . . . . . . . . . . . . . .  39\nAppendix C.  Example Profile  . . . . . . . . . . . . . . . . . .  40\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  41\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  41",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DNCP is designed to provide a way for each participating node to publish a small set of TLV (Type-Length-Value) tuples (at most 64 KB) and to provide a shared and common view about the data published by every currently bidirectionally reachable DNCP node in a network.",
      "ja": "DNCPは、参加している各ノードがTLV（Type-Length-Value）タプル（最大64 KB）の小さなセットを公開する方法を提供し、現在双方向で到達可能なすべてのDNCPによって公開されたデータに関する共有された共通のビューを提供するように設計されていますネットワーク内のノード。"
    },
    {
      "indent": 3,
      "text": "For state synchronization, a hash tree is used. It is formed by first calculating a hash for the data set published by each node, called node data, and then calculating another hash over those node data hashes. The single resulting hash, called network state hash, is transmitted using the Trickle algorithm [RFC6206] to ensure that all nodes share the same view of the current state of the published data within the network. The use of Trickle with only short network state hashes sent infrequently (in steady state, once the maximum Trickle interval per link or unicast connection has been reached) makes DNCP very thrifty when updates happen rarely.",
      "ja": "状態の同期には、ハッシュツリーが使用されます。これは、最初にノードデータと呼ばれる各ノードによって公開されたデータセットのハッシュを計算し、次にそれらのノードデータハッシュの別のハッシュを計算することによって形成されます。結果の単一のハッシュは、ネットワーク状態ハッシュと呼ばれ、Trickleアルゴリズム[RFC6206]を使用して送信され、すべてのノードがネットワーク内の公開データの現在の状態の同じビューを共有するようにします。 （リンクまたはユニキャスト接続ごとの最大トリクル間隔に到達すると、定常状態で）まれに送信される短いネットワークステートハッシュのみでトリクルを使用すると、更新がほとんど行われないときにDNCPが非常に効率的になります。"
    },
    {
      "indent": 3,
      "text": "For maintaining liveliness of the topology and the data within it, a combination of Trickled network state, keep-alives, and \"other\" means of ensuring reachability are used. The core idea is that if every node ensures its peers are present, transitively, the whole network state also stays up to date.",
      "ja": "トポロジとその中のデータの活性を維持するために、トリクルドネットワークの状態、キープアライブ、および到達可能性を保証する「その他の」手段の組み合わせが使用されます。核となる考えは、すべてのノードがピアが存在することを推移的に確認すると、ネットワーク全体の状態も最新の状態に保たれるということです。"
    },
    {
      "indent": 0,
      "text": "1.1. Applicability",
      "section_title": true,
      "ja": "1.1. 適用性"
    },
    {
      "indent": 3,
      "text": "DNCP is useful for cases like autonomous bootstrapping, discovery, and negotiation of embedded network devices like routers. Furthermore, it can be used as a basis to run distributed algorithms like [RFC7596] or use cases as described in Appendix C. DNCP is abstract, which allows it to be tuned to a variety of applications by defining profiles. These profiles include choices of:",
      "ja": "DNCPは、自律ブートストラップ、検出、ルーターなどの組み込みネットワークデバイスのネゴシエーションなどの場合に役立ちます。さらに、[RFC7596]のような分散アルゴリズムや、付録Cで説明されているユースケースを実行するための基礎として使用できます。DNCPは抽象的であり、プロファイルを定義することでさまざまなアプリケーションに合わせて調整できます。これらのプロファイルには、次の選択肢があります。"
    },
    {
      "indent": 3,
      "text": "- unicast transport: a datagram or stream-oriented protocol (e.g., TCP, UDP, or the Stream Control Transmission Protocol (SCTP)) for generic protocol operation.",
      "ja": "- ユニキャストトランスポート：汎用プロトコル操作用のデータグラムまたはストリーム指向プロトコル（TCP、UDP、またはストリーム制御伝送プロトコル（SCTP）など）。"
    },
    {
      "indent": 3,
      "text": "- optional transport security: whether and when to use security based on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS), if supported over the chosen transport.",
      "ja": "- オプションのトランスポートセキュリティ：トランスポート層セキュリティ（TLS）またはデータグラムトランスポート層セキュリティ（DTLS）に基づくセキュリティを使用するかどうか、いつ使用するか（選択したトランスポートでサポートされている場合）。"
    },
    {
      "indent": 3,
      "text": "- optional multicast transport: a multicast-capable protocol like UDP allowing autonomous peer discovery or more efficient use of multiple access links.",
      "ja": "- オプションのマルチキャストトランスポート：自律的なピアの発見や複数のアクセスリンクのより効率的な使用を可能にするUDPなどのマルチキャスト対応プロトコル。"
    },
    {
      "indent": 3,
      "text": "- communication scopes: using either hop by hop only relying on link-local addressing (e.g., for LANs), addresses with broader scopes (e.g., over WANs or the Internet) relying on an existing routing infrastructure, or a combination of both (e.g., to exchange state between multiple LANs over a WAN or the Internet).",
      "ja": "- 通信スコープ：リンクローカルアドレッシングのみに依存するホップバイホップ（LANなど）、既存のルーティングインフラストラクチャに依存するより広いスコープを持つアドレス（WANやインターネットなど）、または両方の組み合わせ（例： WANまたはインターネットを介して複数のLAN間で状態を交換します）。"
    },
    {
      "indent": 3,
      "text": "- payloads: additional specific payloads (e.g., IANA standardized, enterprise-specific, or private use).",
      "ja": "- ペイロード：追加の特定のペイロード（IANA標準化、企業固有、または私的使用など）。"
    },
    {
      "indent": 3,
      "text": "- extensions: possible protocol extensions, either as predefined in this document or specific for a particular use case.",
      "ja": "- extensions：このドキュメントで事前に定義されているか、特定のユースケースに固有の、可能なプロトコル拡張。"
    },
    {
      "indent": 3,
      "text": "However, there are certain cases where the protocol as defined in this document is a less suitable choice. This list provides an overview while the following paragraphs provide more detailed guidance on the individual matters.",
      "ja": "ただし、このドキュメントで定義されているプロトコルがあまり適していない場合もあります。このリストは概要を提供し、次の段落は個々の問題に関するより詳細なガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "- large amounts of data: nodes are limited to 64 KB of published data.",
      "ja": "- 大量のデータ：ノードは64 KBの公開データに制限されています。"
    },
    {
      "indent": 3,
      "text": "- very dense unicast-only networks: nodes include information about all immediate neighbors as part of their published data.",
      "ja": "- 非常に密度の高いユニキャスト専用ネットワーク：ノードには、公開されたデータの一部として、すべての隣接ノードに関する情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "- predominantly minimal data changes: node data is always transported as is, leading to a relatively large transmission overhead for changes affecting only a small part of it.",
      "ja": "- 主に最小限のデータ変更：ノードデータは常にそのまま転送されるため、変更の一部にのみ影響する変更の送信オーバーヘッドが比較的大きくなります。"
    },
    {
      "indent": 3,
      "text": "- frequently changing data: DNCP with its use of Trickle is optimized for the steady state and less efficient otherwise.",
      "ja": "- 頻繁に変化するデータ：トリクルを使用するDNCPは、定常状態用に最適化されており、それ以外の場合は効率が低下します。"
    },
    {
      "indent": 3,
      "text": "- large amounts of very constrained nodes: DNCP requires each node to store the entirety of the data published by all nodes.",
      "ja": "- 非常に制約された大量のノード：DNCPでは、すべてのノードによってパブリッシュされたデータ全体を各ノードに格納する必要があります。"
    },
    {
      "indent": 3,
      "text": "The topology of the devices is not limited and automatically discovered. When relying on link-local communication exclusively, all links having DNCP nodes need to be at least transitively connected by routers running the protocol on multiple endpoints in order to form a connected network. However, there is no requirement for every device in a physical network to run the protocol. Especially if globally scoped addresses are used, DNCP peers do not need to be on the same or even neighboring physical links. Autonomous discovery features are usually used in local network scenarios; however, with security enabled, DNCP can also be used over unsecured public networks. Network size is restricted merely by the capabilities of the devices, i.e., each DNCP node needs to be able to store the entirety of the data published by all nodes. The data associated with each individual node identifier is limited to about 64 KB in this document; however, protocol extensions could be defined to mitigate this or other protocol limitations if the need arises.",
      "ja": "デバイスのトポロジーは制限されておらず、自動的に検出されます。リンクローカル通信にのみ依存している場合、DNCPノードを持つすべてのリンクは、接続されたネットワークを形成するために、複数のエンドポイントでプロトコルを実行しているルーターによって少なくとも推移的に接続される必要があります。ただし、物理ネットワーク内のすべてのデバイスがプロトコルを実行する必要はありません。特にグローバルスコープのアドレスが使用される場合、DNCPピアは同じまたは隣接する物理リンク上にある必要はありません。自律検出機能は通常、ローカルネットワークシナリオで使用されます。ただし、セキュリティを有効にすると、DNCPはセキュリティで保護されていないパブリックネットワーク上でも使用できます。ネットワークサイズは、デバイスの機能によってのみ制限されます。つまり、各DNCPノードは、すべてのノードによって公開されたデータ全体を保存できる必要があります。このドキュメントでは、個々のノード識別子に関連付けられたデータは約64 KBに制限されています。ただし、必要に応じて、プロトコル拡張を定義して、このプロトコル制限や他のプロトコル制限を緩和できます。"
    },
    {
      "indent": 3,
      "text": "DNCP is most suitable for data that changes only infrequently to gain the maximum benefit from using Trickle. As the network of nodes grows, or the frequency of data changes per node increases, Trickle is eventually used less and less, and the benefit of using DNCP diminishes. In these cases, Trickle just provides extra complexity within the specification and little added value.",
      "ja": "DNCPは、Trickleを使用することから最大の利益を得るために、まれにしか変更されないデータに最適です。ノードのネットワークが拡大するか、ノードごとのデータ変更の頻度が増加するにつれて、Trickleの使用は最終的には少なくなり、DNCPを使用する利点は減少します。これらの場合、Trickleは仕様内で追加の複雑さを提供するだけで、付加価値はほとんどありません。"
    },
    {
      "indent": 3,
      "text": "The suitability of DNCP for a particular application can be roughly evaluated by considering the expected average network-wide state change interval A_NC_I; it is computed by dividing the mean interval at which a node originates a new TLV set by the number of participating nodes. If keep-alives are used, A_NC_I is the minimum of the computed A_NC_I and the keep-alive interval. If A_NC_I is less than the (application-specific) Trickle minimum interval, DNCP is most likely unsuitable for the application as Trickle will not be utilized most of the time.",
      "ja": "特定のアプリケーションに対するDNCPの適合性は、予想されるネットワーク全体の平均状態変化間隔A_NC_Iを考慮することにより、大まかに評価できます。これは、ノードが新しいTLVセットを発信する平均間隔を参加ノードの数で割ることによって計算されます。キープアライブが使用されている場合、A_NC_Iは、計算されたA_NC_Iとキープアライブ間隔の最小値です。 A_NC_Iが（アプリケーション固有の）トリクルの最小間隔よりも短い場合、トリクルはほとんどの時間利用されないため、DNCPはアプリケーションに適さない可能性があります。"
    },
    {
      "indent": 3,
      "text": "If constant rapid state changes are needed, the preferable choice is to use an additional point-to-point channel whose address or locator is published using DNCP. Nevertheless, if doing so does not raise A_NC_I above the (sensibly chosen) Trickle interval parameters for a particular application, using DNCP is probably not suitable for the application.",
      "ja": "絶え間ない急速な状態変化が必要な場合は、DNCPを使用してアドレスまたはロケーターが公開されている追加のポイントツーポイントチャネルを使用することをお勧めします。それにもかかわらず、そのようにしてもA_NC_Iが特定のアプリケーションの（賢明に選択された）トリクル間隔パラメーターを超えない場合、DNCPの使用はおそらくアプリケーションに適していません。"
    },
    {
      "indent": 3,
      "text": "Another consideration is the size of the published TLV set by a node compared to the size of deltas in the TLV set. If the TLV set published by a node is very large, and has frequent small changes, DNCP as currently specified in this specification may be unsuitable as it lacks a delta synchronization scheme to keep implementation simple.",
      "ja": "別の考慮事項は、TLVセット内のデルタのサイズと比較した、ノードによって公開されたTLVセットのサイズです。ノードによって公開されたTLVセットが非常に大きく、小さな変更が頻繁にある場合、この仕様で現在指定されているDNCPは、実装を単純に保つためのデルタ同期スキームがないため、不適切である可能性があります。"
    },
    {
      "indent": 3,
      "text": "DNCP can be used in networks where only unicast transport is available. While DNCP uses the least amount of bandwidth when multicast is utilized, even in pure unicast mode, the use of Trickle (ideally with k < 2) results in a protocol with an exponential backoff timer and fewer transmissions than a simpler protocol not using Trickle.",
      "ja": "DNCPは、ユニキャストトランスポートのみが利用可能なネットワークで使用できます。純粋なユニキャストモードであっても、マルチキャストが利用される場合、DNCPは最小の帯域幅を使用しますが、Trickle（理想的にはk <2）を使用すると、Trickleを使用しない単純なプロトコルよりも指数関数的バックオフタイマーとより少ない送信のプロトコルになります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "DNCP profile the values for the set of parameters given in Section 9. They are prefixed with DNCP_ in this document. The profile also specifies the set of optional DNCP extensions to be used. For a simple example DNCP profile, see Appendix C.",
      "ja": "DNCPは、セクション9で指定された一連のパラメータの値をプロファイルします。このドキュメントでは、DNCP_というプレフィックスが付いています。プロファイルは、使用されるオプションのDNCP拡張のセットも指定します。 DNCPプロファイルの簡単な例については、付録Cを参照してください。"
    },
    {
      "indent": 3,
      "text": "DNCP-based a protocol that provides a DNCP profile, according protocol to Section 9, and zero or more TLV assignments from the per-DNCP profile TLV registry as well as their processing rules.",
      "ja": "セクション9のプロトコルに従ってDNCPプロファイルを提供するDNCPベースのプロトコル、およびDNCPプロファイルごとのTLVレジストリからの0個以上のTLV割り当てとそれらの処理ルール。"
    },
    {
      "indent": 3,
      "text": "DNCP node a single node that runs a DNCP-based protocol.",
      "ja": "DNCPノードは、DNCPベースのプロトコルを実行する単一のノードです。"
    },
    {
      "indent": 3,
      "text": "Link a link-layer media over which directly connected nodes can communicate.",
      "ja": "直接接続されたノードが通信できるリンク層メディアをリンクします。"
    },
    {
      "indent": 3,
      "text": "DNCP network a set of DNCP nodes running a DNCP-based protocol(s) with a matching DNCP profile(s). The set consists of nodes that have discovered each other using the transport method defined in the DNCP profile, via multicast on local links, and/or by using unicast communication.",
      "ja": "DNCPネットワークは、DNCPプロファイルと一致するDNCPベースのプロトコルを実行するDNCPノードのセットです。セットは、DNCPプロファイルで定義された転送方法を使用して、ローカルリンクでのマルチキャストを介して、またはユニキャスト通信を使用して、相互に発見したノードで構成されます。"
    },
    {
      "indent": 3,
      "text": "Node identifier an opaque fixed-length identifier consisting of DNCP_NODE_IDENTIFIER_LENGTH bytes that uniquely identifies a DNCP node within a DNCP network.",
      "ja": "ノード識別子DNCPネットワーク内のDNCPノードを一意に識別するDNCP_NODE_IDENTIFIER_LENGTHバイトで構成される不透明な固定長識別子。"
    },
    {
      "indent": 3,
      "text": "Interface a node's attachment to a particular link.",
      "ja": "ノードのアタッチメントを特定のリンクにインターフェースします。"
    },
    {
      "indent": 3,
      "text": "Address an identifier used as the source or destination of a DNCP message flow, e.g., a tuple (IPv6 address, UDP port) for an IPv6 UDP transport.",
      "ja": "DNCPメッセージフローの送信元または宛先として使用される識別子（IPv6 UDPトランスポートのタプル（IPv6アドレス、UDPポート）など）をアドレス指定します。"
    },
    {
      "indent": 3,
      "text": "Endpoint a locally configured termination point for (potential or established) DNCP message flows. An endpoint is the source and destination for separate unicast message flows to individual nodes and optionally for multicast messages to all thereby reachable nodes (e.g., for node discovery). Endpoints are usually in one of the transport modes specified in Section 4.2.",
      "ja": "エンドポイントローカルに構成された（潜在的または確立された）DNCPメッセージフローの終端ポイント。エンドポイントは、個々のノードへの個別のユニキャストメッセージフローの送信元と宛先であり、オプションで、到達可能なすべてのノードへのマルチキャストメッセージの送信元です（たとえば、ノードの検出用）。エンドポイントは通常、セクション4.2で指定されたトランスポートモードの1つにあります。"
    },
    {
      "indent": 3,
      "text": "Endpoint a 32-bit opaque and locally unique value, which identifier identifies a particular endpoint of a particular DNCP node. The value 0 is reserved for DNCP and DNCP-based protocol purposes and not used to identify an actual endpoint. This definition is in sync with the interface index definition in [RFC3493], as the non-zero small positive integers should comfortably fit within 32 bits.",
      "ja": "エンドポイント32ビットの不透明でローカルに一意の値。この識別子は、特定のDNCPノードの特定のエンドポイントを識別します。値0は、DNCPおよびDNCPベースのプロトコルの目的で予約されており、実際のエンドポイントの識別には使用されません。この定義は、[RFC3493]のインターフェイスインデックス定義と同期しています。ゼロ以外の小さい正の整数は、32ビット内に快適に収まるはずです。"
    },
    {
      "indent": 3,
      "text": "Peer another DNCP node with which a DNCP node communicates using at least one particular local and remote endpoint pair.",
      "ja": "DNCPノードが少なくとも1つの特定のローカルおよびリモートエンドポイントペアを使用して通信する別のDNCPノードをピアリングします。"
    },
    {
      "indent": 3,
      "text": "Node data a set of TLVs published and owned by a node in the DNCP network. Other nodes pass it along as is, even if they cannot fully interpret it.",
      "ja": "ノードデータは、DNCPネットワーク内のノードによって公開および所有される一連のTLVです。他のノードは、完全に解釈できない場合でも、そのまま渡します。"
    },
    {
      "indent": 3,
      "text": "Origination time the (estimated) time when the node data set with the current sequence number was published.",
      "ja": "発生時間現在のシーケンス番号を持つノードデータセットが公開された（推定）時間。"
    },
    {
      "indent": 3,
      "text": "Node state a set of metadata attributes for node data. It includes a sequence number for versioning, a hash value for comparing equality of stored node data, and a timestamp indicating the time passed since its last publication (i.e., since the origination time). The hash function and the length of the hash value are defined in the DNCP profile.",
      "ja": "ノードは、ノードデータのメタデータ属性のセットを示します。これには、バージョニングのシーケンス番号、保存されたノードデータの同等性を比較するためのハッシュ値、および最後のパブリケーションから経過した時間（つまり、オリジネーション時間）を示すタイムスタンプが含まれます。ハッシュ関数とハッシュ値の長さは、DNCPプロファイルで定義されます。"
    },
    {
      "indent": 3,
      "text": "Network state a hash value that represents the current state of hash the network. The hash function and the length of the hash value are defined in the DNCP profile. Whenever a node is added, removed, or updates its published node data, this hash value changes as well. For calculation, please see Section 4.1.",
      "ja": "ネットワーク状態ハッシュの現在の状態を表すハッシュ値。ハッシュ関数とハッシュ値の長さは、DNCPプロファイルで定義されます。ノードが追加、削除、または公開されたノードデータを更新するたびに、このハッシュ値も変更されます。計算については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Trust verdict a statement about the trustworthiness of a certificate announced by a node participating in the certificate-based trust consensus mechanism.",
      "ja": "トラスト評決は、証明書ベースのトラストコンセンサスメカニズムに参加しているノードによって発表された証明書の信頼性に関するステートメントです。"
    },
    {
      "indent": 3,
      "text": "Effective trust the trust verdict with the highest priority within verdict the set of trust verdicts announced for the certificate in the DNCP network.",
      "ja": "DNCPネットワーク内の証明書に対してアナウンスされた信頼判定セットの判定内で最高の優先度を持つ信頼判定を効果的に信頼します。"
    },
    {
      "indent": 3,
      "text": "Topology graph the undirected graph of DNCP nodes produced by retaining only bidirectional peer relationships between nodes.",
      "ja": "トポロジグラフは、ノード間の双方向のピア関係のみを保持することによって生成されるDNCPノードの無向グラフです。"
    },
    {
      "indent": 3,
      "text": "Bidirectionally a peer is locally unidirectionally reachable if a reachable consistent multicast or any unicast DNCP message has been received by the local node (see Section 4.5). If said peer in return also considers the local node unidirectionally reachable, then bidirectionally reachability is established. As this process is based on publishing peer relationships and evaluating the resulting topology graph as described in Section 4.6, this information is available to the whole DNCP network.",
      "ja": "ローカルノードが到達可能な一貫したマルチキャストまたはユニキャストDNCPメッセージを受信した場合、ピアは双方向でローカルに単方向で到達可能です（セクション4.5を参照）。その見返りとして、ピアがローカルノードも一方向に到達可能であると見なすと、双方向の到達可能性が確立されます。このプロセスは、セクション4.6で説明されているように、ピア関係の公開と結果のトポロジグラフの評価に基づいているため、この情報はDNCPネットワーク全体で利用できます。"
    },
    {
      "indent": 3,
      "text": "Trickle instance a distinct Trickle [RFC6206] algorithm state kept by a node (Section 5) and related to an endpoint or a particular (peer, endpoint) tuple with Trickle variables I, t, and c. See Section 4.3.",
      "ja": "Trickleインスタンスは、ノード（セクション5）によって保持され、エンドポイントまたは特定の（ピア、エンドポイント）タプルに関連付けられた、Trickle変数I、t、およびcを持つ個別のTrickle [RFC6206]アルゴリズム状態です。セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの \"は、RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概観"
    },
    {
      "indent": 3,
      "text": "DNCP operates primarily using unicast exchanges between nodes, and it may use multicast for Trickle-based shared state dissemination and topology discovery. If used in pure unicast mode with unreliable transport, Trickle is also used between peers.",
      "ja": "DNCPは主にノード間のユニキャスト交換を使用して動作し、トリクルベースの共有状態の配布とトポロジーの発見にマルチキャストを使用する場合があります。トランスポートの信頼性が低い純粋なユニキャストモードで使用する場合、Trickleはピア間でも使用されます。"
    },
    {
      "indent": 3,
      "text": "DNCP is based on exchanging TLVs (Section 7) and defines a set of mandatory and optional ones for its operation. They are categorized into TLVs for requesting information (Section 7.1), transmitting data (Section 7.2), and being published as data (Section 7.3). DNCP-based protocols usually specify additional ones to extend the capabilities.",
      "ja": "DNCPはTLVの交換（セクション7）に基づいており、その操作のための必須およびオプションのTLVのセットを定義します。それらは、情報の要求（セクション7.1）、データの送信（セクション7.2）、およびデータとしての公開（セクション7.3）のためにTLVに分類されます。 DNCPベースのプロトコルは通常、機能を拡張するために追加のプロトコルを指定します。"
    },
    {
      "indent": 0,
      "text": " DNCP discovers the topology of the nodes in the DNCP network and maintains the liveliness of published node data by ensuring that the publishing node is bidirectionally reachable. New potential peers can be discovered autonomously on multicast-enabled links; their addresses may be manually configured or they may be found by some other means defined in the particular DNCP profile. The DNCP profile may specify, for example, a well-known anycast address or provision the remote address to contact via some other protocol such as DHCPv6 [RFC3315].",
      "ja": "DNCPは、DNCPネットワーク内のノードのトポロジを検出し、公開ノードが双方向で到達可能であることを確認することにより、公開されたノードデータの活性を維持します。新しい潜在的なピアは、マルチキャスト対応リンク上で自律的に発見できます。それらのアドレスは手動で構成することも、特定のDNCPプロファイルで定義された他の手段で見つけることもできます。 DNCPプロファイルは、たとえば、よく知られているエニーキャストアドレスを指定したり、DHCPv6 [RFC3315]などの他のプロトコルを介して接続するリモートアドレスをプロビジョニングしたりできます。"
    },
    {
      "indent": 3,
      "text": "A hash tree of height 1, rooted in itself, is maintained by each node to represent the state of all currently reachable nodes (see Section 4.1), and the Trickle algorithm is used to trigger synchronization (see Section 4.3). The need to check peer nodes for state changes is thereby determined by comparing the current root of their respective hash trees, i.e., their individually calculated network state hashes.",
      "ja": "高さ1のハッシュツリー自体がルートであり、現在到達可能なすべてのノードの状態を表すために各ノードによって維持され（セクション4.1を参照）、Trickleアルゴリズムを使用して同期をトリガーします（セクション4.3を参照）。これにより、ピアノードの状態変化をチェックする必要性は、それぞれのハッシュツリーの現在のルート、つまり、個々に計算されたネットワーク状態のハッシュを比較することによって決定されます。"
    },
    {
      "indent": 3,
      "text": "Before joining a DNCP network, a node starts with a hash tree that has only one leaf if the node publishes some TLVs, and no leaves otherwise. It then announces the network state hash calculated from the hash tree by means of the Trickle algorithm on all its configured endpoints.",
      "ja": "DNCPネットワークに参加する前に、ノードは、ノードがいくつかのTLVを公開している場合はリーフが1つだけで、それ以外の場合はリーフがないハッシュツリーで始まります。次に、構成されたすべてのエンドポイントで、Trickleアルゴリズムを使用してハッシュツリーから計算されたネットワーク状態ハッシュをアナウンスします。"
    },
    {
      "indent": 3,
      "text": "When an update is detected by a node (e.g., by receiving a different network state hash from a peer), the originator of the event is requested to provide a list of the state of all nodes, i.e., all the information it uses to calculate its own hash tree. The node uses the list to determine whether its own information is outdated and -- if necessary -- requests the actual node data that has changed.",
      "ja": "更新がノードによって検出されると（たとえば、ピアから異なるネットワーク状態ハッシュを受信することによって）、イベントの発信者は、すべてのノードの状態のリスト、つまり、ノードが計算に使用するすべての情報を提供するように要求されます独自のハッシュツリー。ノードはリストを使用して、自身の情報が古いかどうかを判別し、必要に応じて、変更された実際のノードデータを要求します。"
    },
    {
      "indent": 3,
      "text": "Whenever a node's local copy of any node data and its hash tree are updated (e.g., due to its own or another node's node state changing or due to a peer being added or removed), its Trickle instances are reset, which eventually causes any update to be propagated to all of its peers.",
      "ja": "ノードのノードデータのローカルコピーとそのハッシュツリーが更新されると（たとえば、そのノードまたは別のノードのノードの状態が変化したり、ピアが追加または削除されたため）、Trickleインスタンスがリセットされ、最終的には更新が発生しますすべてのピアに伝播されます。"
    },
    {
      "indent": 0,
      "text": "4. Operation",
      "section_title": true,
      "ja": "4. 操作"
    },
    {
      "indent": 0,
      "text": "4.1. Hash Tree",
      "section_title": true,
      "ja": "4.1. ハッシュツリー"
    },
    {
      "indent": 3,
      "text": "Each DNCP node maintains an arbitrary width hash tree of height 1. The root of the tree represents the overall network state hash and is used to determine whether the view of the network of two or more nodes is consistent and shared. Each leaf represents one bidirectionally reachable DNCP node. Every time a node is added or removed from the topology graph (Section 4.6), it is likewise added or removed as a leaf. At any time, the leaves of the tree are ordered in ascending order of the node identifiers of the nodes they represent.",
      "ja": "各DNCPノードは、高さ1の任意の幅のハッシュツリーを維持します。ツリーのルートは、全体的なネットワーク状態のハッシュを表し、2つ以上のノードのネットワークのビューが一貫して共有されているかどうかを判断するために使用されます。各リーフは、双方向で到達可能な1つのDNCPノードを表します。ノードがトポロジグラフ（セクション4.6）に追加または削除されるたびに、同様にリーフとして追加または削除されます。いつでも、ツリーの葉は、それらが表すノードのノード識別子の昇順で並べられます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Calculating Network State and Node Data Hashes",
      "section_title": true,
      "ja": "4.1.1. ネットワーク状態とノードデータハッシュの計算"
    },
    {
      "indent": 3,
      "text": "The network state hash and the node data hashes are calculated using the hash function defined in the DNCP profile (Section 9) and truncated to the number of bits specified therein.",
      "ja": "ネットワーク状態ハッシュとノードデータハッシュは、DNCPプロファイル（セクション9）で定義されたハッシュ関数を使用して計算され、そこで指定されたビット数に切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "Individual node data hashes are calculated by applying the function and truncation on the respective node's node data as published in the Node State TLV. Such node data sets are always ordered as defined in Section 7.2.3.",
      "ja": "個々のノードデータハッシュは、ノード状態TLVで公開されている各ノードのノードデータに関数と切り捨てを適用することによって計算されます。このようなノードデータセットは、セクション7.2.3で定義されているように常に順序付けられます。"
    },
    {
      "indent": 3,
      "text": "The network state hash is calculated by applying the function and truncation on the concatenated network state. This state is formed by first concatenating each node's sequence number (in network byte order) with its node data hash to form a per-node datum for each node. These per-node data are then concatenated in ascending order of the respective node's node identifier, i.e., in the order that the nodes appear in the hash tree.",
      "ja": "ネットワーク状態ハッシュは、連結されたネットワーク状態に関数と切り捨てを適用することによって計算されます。この状態は、最初に各ノードのシーケンス番号（ネットワークバイト順）をそのノードデータハッシュと連結して、各ノードのノードごとのデータを形成することによって形成されます。次に、これらのノードごとのデータは、各ノードのノード識別子の昇順、つまり、ノードがハッシュツリーに表示される順序で連結されます。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Updating Network State and Node Data Hashes",
      "section_title": true,
      "ja": "4.1.2. ネットワーク状態とノードデータハッシュの更新"
    },
    {
      "indent": 3,
      "text": "The network state hash and the node data hashes are updated on-demand and whenever any locally stored per-node state changes. This includes local unidirectional reachability encoded in the published Peer TLVs (Section 7.3.1) and -- when combined with remote data -- results in awareness of bidirectional reachability changes.",
      "ja": "ネットワーク状態のハッシュとノードデータのハッシュは、オンデマンドで、ローカルに保存されているノードごとの状態が変化するたびに更新されます。これには、公開されたピアTLV（セクション7.3.1）でエンコードされたローカルの単方向の到達可能性が含まれ、リモートデータと組み合わせると、双方向の到達可能性の変化が認識されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Data Transport",
      "section_title": true,
      "ja": "4.2. 輸送日"
    },
    {
      "indent": 3,
      "text": "DNCP has few requirements for the underlying transport; it requires some way of transmitting either a unicast datagram or stream data to a peer and, if used in multicast mode, a way of sending multicast datagrams. As multicast is used only to identify potential new DNCP nodes and to send status messages that merely notify that a unicast exchange should be triggered, the multicast transport does not have to be secured. If unicast security is desired and one of the built-in security methods is to be used, support for some TLS-derived transport scheme -- such as TLS [RFC5246] on top of TCP or DTLS [RFC6347] on top of UDP -- is also required. They provide for integrity protection and confidentiality of the node data, as well as authentication and authorization using the schemes defined in \"Security and Trust Management\" (Section 8). A specific definition of the transport(s) in use and its parameters MUST be provided by the DNCP profile.",
      "ja": "DNCPには、基になるトランスポートの要件がほとんどありません。ユニキャストデータグラムまたはストリームデータをピアに送信する何らかの方法と、マルチキャストモードで使用する場合はマルチキャストデータグラムを送信する方法が必要です。マルチキャストは潜在的な新しいDNCPノードを識別し、ユニキャスト交換をトリガーする必要があることを通知するだけのステータスメッセージを送信するためにのみ使用されるため、マルチキャストトランスポートを保護する必要はありません。ユニキャストセキュリティが必要で、組み込みのセキュリティメソッドの1つを使用する場合は、TLS派生のトランスポートスキームのサポート-TCP上のTLS [RFC5246]またはUDP上のDTLS [RFC6347]など-も必要です。これらは、ノードデータの整合性保護と機密性、および「セキュリティと信頼管理」（セクション8）で定義されたスキームを使用した認証と承認を提供します。使用中のトランスポートとそのパラメーターの特定の定義は、DNCPプロファイルによって提供される必要があります。"
    },
    {
      "indent": 0,
      "text": " TLVs (Section 7) are sent across the transport as is, and they SHOULD be sent together where, e.g., MTU considerations do not recommend sending them in multiple batches. DNCP does not fragment or reassemble TLVs; thus, it MUST be ensured that the underlying transport performs these operations should they be necessary. If this document indicates sending one or more TLVs, then the sending node does not need to keep track of the packets sent after handing them over to the respective transport, i.e., reliable DNCP operation is ensured merely by the explicitly defined timers and state machines such as Trickle (Section 4.3). TLVs in general are handled individually and statelessly (and thus do not need to be sent in any particular order) with one exception: To form bidirectional peer relationships, DNCP requires identification of the endpoints used for communication. As bidirectional peer relationships are required for validating liveliness of published node data as described in Section 4.6, a DNCP node MUST send a Node Endpoint TLV (Section 7.2.1). When it is sent varies, depending on the underlying transport, but conceptually it should be available whenever processing a Network State TLV:",
      "ja": "TLV（セクション7）はそのままトランスポートを介して送信され、それらは一緒に送信される必要があります（たとえば、MTUの考慮事項により、複数のバッチで送信することは推奨されません）。 DNCPはTLVを断片化または再構成しません。したがって、基礎となるトランスポートがこれらの操作を必要とする場合に確実に実行する必要があります。このドキュメントが1つまたは複数のTLVの送信を示している場合、送信ノードは送信されたパケットをそれぞれのトランスポートに渡した後に追跡する必要はありません。つまり、信頼できるDNCP動作は、明示的に定義されたタイマーとそのようなステートマシンによってのみ保証されます。トリクルとして（セクション4.3）。一般にTLVは個別に、そしてステートレスに処理されます（したがって、特定の順序で送信する必要はありません）。ただし、1つの例外があります。双方向のピア関係を形成するには、DNCPは通信に使用されるエンドポイントの識別を必要とします。セクション4.6で説明されているように、公開されたノードデータの活性を検証するには双方向のピア関係が必要であるため、DNCPノードはノードエンドポイントTLV（セクション7.2.1）を送信する必要があります。送信されるタイミングは、基盤となるトランスポートによって異なりますが、概念的には、ネットワーク状態TLVを処理するときにいつでも使用できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o If using a stream transport, the TLV MUST be sent at least once per connection but SHOULD NOT be sent more than once.",
      "ja": "o ストリーム転送を使用する場合、TLVは接続ごとに少なくとも1回送信する必要がありますが、2回以上送信してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "o If using a datagram transport, it MUST be included in every datagram that also contains a Network State TLV (Section 7.2.2) and MUST be located before any such TLV. It SHOULD also be included in any other datagram to speed up initial peer detection.",
      "ja": "o データグラム転送を使用する場合、それはネットワーク状態TLV（セクション7.2.2）も含むすべてのデータグラムに含まれている必要があり、そのようなTLVの前に配置されている必要があります。また、他のデータグラムに含めて、初期ピア検出を高速化する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Given the assorted transport options as well as potential endpoint configuration, a DNCP endpoint may be used in various transport modes:",
      "ja": "さまざまなトランスポートオプションと潜在的なエンドポイント構成を考えると、DNCPエンドポイントはさまざまなトランスポートモードで使用できます。"
    },
    {
      "indent": 3,
      "text": "Unicast:",
      "ja": "ユニキャスト："
    },
    {
      "indent": 6,
      "text": "* If only reliable unicast transport is used, Trickle is not used at all. Whenever the locally calculated network state hash changes, a single Network State TLV (Section 7.2.2) is sent to every unicast peer. Additionally, recently changed Node State TLVs (Section 7.2.3) MAY be included.",
      "ja": "* 信頼できるユニキャストトランスポートのみが使用されている場合、トリクルはまったく使用されません。ローカルで計算されたネットワーク状態ハッシュが変更されるたびに、単一のネットワーク状態TLV（セクション7.2.2）がすべてのユニキャストピアに送信されます。さらに、最近変更されたノード状態TLV（セクション7.2.3）が含まれる場合があります。"
    },
    {
      "indent": 6,
      "text": "* If only unreliable unicast transport is used, Trickle state is kept per peer, and it is used to send Network State TLVs intermittently, as specified in Section 4.3.",
      "ja": "* 信頼性の低いユニキャストトランスポートのみが使用される場合、Trickle状態はピアごとに保持され、セクション4.3で指定されているように、ネットワーク状態TLVを断続的に送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Multicast+Unicast: If multicast datagram transport is available on an endpoint, Trickle state is only maintained for the endpoint as a whole. It is used to send Network State TLVs periodically, as specified in Section 4.3. Additionally, per-endpoint keep-alives MAY be defined in the DNCP profile, as specified in Section 6.1.2.",
      "ja": "マルチキャスト+ユニキャスト：エンドポイントでマルチキャストデータグラムトランスポートが利用可能な場合、トリクル状態はエンドポイント全体でのみ維持されます。セクション4.3で指定されているように、ネットワーク状態TLVを定期的に送信するために使用されます。さらに、エンドポイントごとのキープアライブは、セクション6.1.2で指定されているように、DNCPプロファイルで定義される場合があります。"
    },
    {
      "indent": 3,
      "text": "MulticastListen+Unicast: Just like unicast, except multicast transmissions are listened to in order to detect changes of the highest node identifier. This mode is used only if the DNCP profile supports dense multicast-enabled link optimization (Section 6.2).",
      "ja": "MulticastListen + Unicast：ユニキャストと同じですが、最高のノード識別子の変更を検出するためにマルチキャスト送信がリッスンされます。このモードは、DNCPプロファイルが高密度マルチキャスト対応リンクの最適化（セクション6.2）をサポートする場合にのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Trickle-Driven Status Updates",
      "section_title": true,
      "ja": "4.3. トリクルドリブンステータスの更新"
    },
    {
      "indent": 3,
      "text": "The Trickle algorithm [RFC6206] is used to ensure protocol reliability over unreliable multicast or unicast transports. For reliable unicast transports, its actual algorithm is unnecessary and omitted (Section 4.2). DNCP maintains multiple Trickle states as defined in Section 5. Each such state can be based on different parameters (see below) and is responsible for ensuring that a specific peer or all peers on the respective endpoint are regularly provided with the node's current locally calculated network state hash for state comparison, i.e., to detect potential divergence in the perceived network state.",
      "ja": "トリクルアルゴリズム[RFC6206]は、信頼性の低いマルチキャストまたはユニキャストトランスポート上でプロトコルの信頼性を確保するために使用されます。信頼性の高いユニキャストトランスポートの場合、その実際のアルゴリズムは不要であり、省略されます（セクション4.2）。 DNCPは、セクション5で定義されているように複数のトリクル状態を維持します。このような状態はそれぞれ異なるパラメーターに基づいており（以下を参照）、それぞれのエンドポイントの特定のピアまたはすべてのピアにノードの現在ローカルで計算されたネットワークが定期的に提供されるようにします。状態比較用の状態ハッシュ。つまり、知覚されたネットワーク状態の潜在的な相違を検出します。"
    },
    {
      "indent": 3,
      "text": "Trickle defines 3 parameters: Imin, Imax, and k. Imin and Imax represent the minimum value for I and the maximum number of doublings of Imin, where I is the time interval during which at least k Trickle updates must be seen on an endpoint to prevent local state transmission. The actual suggested Trickle algorithm parameters are DNCP profile specific, as described in Section 9.",
      "ja": "Trickleは、Imin、Imax、kの3つのパラメーターを定義します。 IminとImaxは、Iの最小値とIminの2倍の最大数を表します。Iは、ローカル状態の送信を防ぐためにエンドポイントで少なくともk回のトリクル更新を確認する必要がある時間間隔です。セクション9で説明されているように、実際に推奨されるトリクルアルゴリズムパラメータはDNCPプロファイル固有です。"
    },
    {
      "indent": 3,
      "text": "The Trickle state for all Trickle instances defined in Section 5 is considered inconsistent and reset if and only if the locally calculated network state hash changes. This occurs either due to a change in the local node's own node data or due to the receipt of more recent data from another node as explained in Section 4.1. A node MUST NOT reset its Trickle state merely based on receiving a Network State TLV (Section 7.2.2) with a network state hash that is different from its locally calculated one.",
      "ja": "セクション5で定義されたすべてのトリクルインスタンスのトリクル状態は不整合と見なされ、ローカルで計算されたネットワーク状態ハッシュが変更された場合にのみリセットされます。これは、ローカルノード自身のノードデータの変更、または4.1節で説明した別のノードからのより最近のデータの受信が原因で発生します。ノードは、ローカルで計算されたものとは異なるネットワーク状態ハッシュを含むネットワーク状態TLV（セクション7.2.2）の受信のみに基づいて、トリクル状態をリセットしてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Every time a particular Trickle instance indicates that an update should be sent, the node MUST send a Network State TLV (Section 7.2.2) if and only if:",
      "ja": "特定のTrickleインスタンスが更新を送信する必要があることを示すたびに、次の場合に限り、ノードはネットワーク状態TLV（セクション7.2.2）を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o the endpoint is in Multicast+Unicast transport mode, in which case the TLV MUST be sent over multicast.",
      "ja": "o エンドポイントはマルチキャスト+ユニキャストトランスポートモードにあります。この場合、TLVはマルチキャストで送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o the endpoint is NOT in Multicast+Unicast transport mode, and the unicast transport is unreliable, in which case the TLV MUST be sent over unicast.",
      "ja": "o エンドポイントはマルチキャスト+ユニキャストトランスポートモードではなく、ユニキャストトランスポートは信頼できません。その場合、TLVはユニキャストで送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A (sub)set of all Node State TLVs (Section 7.2.3) MAY also be included, unless it is defined as undesirable for some reason by the DNCP profile or to avoid exposure of the node state TLVs by transmitting them within insecure multicast when using secure unicast.",
      "ja": "すべてのノード状態TLVの（サブ）セット（セクション7.2.3）も含めることができます。ただし、DNCPプロファイルによって何らかの理由で望ましくないと定義されている場合、または次の場合に安全でないマルチキャスト内でノード状態TLVを送信することによってノード状態TLVの公開を回避することはできません。安全なユニキャストを使用します。"
    },
    {
      "indent": 0,
      "text": "4.4. Processing of Received TLVs",
      "section_title": true,
      "ja": "4.4. 受信したTLVの処理"
    },
    {
      "indent": 3,
      "text": "This section describes how received TLVs are processed. The DNCP profile may specify when to ignore particular TLVs, e.g., to modify security properties -- see Section 9 for what may be safely defined to be ignored in a profile. Any 'reply' mentioned in the steps below denotes the sending of the specified TLV(s) to the originator of the TLV being processed. All such replies MUST be sent using unicast. If the TLV being replied to was received via multicast and it was sent to a multiple access link, the reply MUST be delayed by a random time span in [0, Imin/2], to avoid potential simultaneous replies that may cause problems on some links, unless specified differently in the DNCP profile. The sending of replies MAY also be rate limited or omitted for a short period of time by an implementation. However, if the TLV is not forbidden by the DNCP profile, an implementation MUST reply to retransmissions of the TLV with a non-zero probability to avoid starvation, which would break the state synchronization.",
      "ja": "このセクションでは、受信したTLVの処理方法について説明します。 DNCPプロファイルは、セキュリティプロパティを変更するなど、特定のTLVを無視するタイミングを指定できます。プロファイルで無視するように安全に定義できるものについては、セクション9を参照してください。以下のステップで言及されている「応答」は、指定されたTLVが処理中のTLVの発信者に送信されることを示しています。このような応答はすべてユニキャストを使用して送信する必要があります。応答されているTLVがマルチキャスト経由で受信され、マルチアクセスリンクに送信された場合、[0、Imin / 2]のランダムな時間スパンだけ応答を遅らせて、一部で問題を引き起こす可能性のある同時応答を回避する必要がありますDNCPプロファイルで別様に指定されていない限り、リンク。応答の送信も、レート制限されるか、実装によって短期間省略される場合があります。ただし、TLVがDNCPプロファイルによって禁止されていない場合、実装は、状態同期を壊す飢餓を回避するために、ゼロ以外の確率でTLVの再送信に応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A DNCP node MUST process TLVs received from any valid (e.g., correctly scoped) address, as specified by the DNCP profile and the configuration of a particular endpoint, whether this address is known to be the address of a peer or not. This provision satisfies the needs of monitoring or other host software that needs to discover the DNCP topology without adding to the state in the network.",
      "ja": "DNCPノードは、DNCPプロファイルおよび特定のエンドポイントの構成によって指定された有効な（たとえば、正しくスコープされた）アドレスから受信したTLVを処理する必要があります（このアドレスがピアのアドレスであるかどうかにかかわらず）。このプロビジョニングは、ネットワークの状態に追加することなくDNCPトポロジを検出する必要のある監視またはその他のホストソフトウェアのニーズを満たします。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of:",
      "ja": "受け取り次第："
    },
    {
      "indent": 3,
      "text": "o Request Network State TLV (Section 7.1.1): The receiver MUST reply with a Network State TLV (Section 7.2.2) and a Node State TLV (Section 7.2.3) for each node data used to calculate the network state hash. The Node State TLVs SHOULD NOT contain the optional node data part to avoid redundant transmission of node data, unless explicitly specified in the DNCP profile.",
      "ja": "o ネットワーク状態TLVの要求（セクション7.1.1）：受信者は、ネットワーク状態ハッシュの計算に使用される各ノードデータのネットワーク状態TLV（セクション7.2.2）およびノー​​ド状態TLV（セクション7.2.3）で応答する必要があります。ノード状態TLVには、DNCPプロファイルで明示的に指定されていない限り、ノードデータの冗長な送信を回避するためにオプションのノードデータ部分を含めないでください。"
    },
    {
      "indent": 3,
      "text": "o Request Node State TLV (Section 7.1.2): If the receiver has node data for the corresponding node, it MUST reply with a Node State TLV (Section 7.2.3) for the corresponding node. The optional node data part MUST be included in the TLV.",
      "ja": "o リクエストノードステートTLV（セクション7.1.2）：レシーバーが対応するノードのノードデータを持っている場合、対応するノードのノードステートTLV（セクション7.2.3）で応答する必要があります。オプションのノードデータパーツはTLVに含める必要があります。"
    },
    {
      "indent": 0,
      "text": " o Network State TLV (Section 7.2.2): If the network state hash differs from the locally calculated network state hash, and the receiver is unaware of any particular node state differences with the sender, the receiver MUST reply with a Request Network State TLV (Section 7.1.1). These replies MUST be rate limited to only at most one reply per link per unique network state hash within Imin. The simplest way to ensure this rate limit is a timestamp indicating requests and sending at most one Request Network State TLV (Section 7.1.1) per Imin. To facilitate faster state synchronization, if a Request Network State TLV is sent in a reply, a local, current Network State TLV MAY also be sent.",
      "ja": "oネットワーク状態TLV（セクション7.2.2）：ネットワーク状態ハッシュがローカルに計算されたネットワーク状態ハッシュと異なり、受信者が送信者との特定のノード状態の違いを認識していない場合、受信者は要求ネットワーク状態TLVで応答する必要があります（セクション7.1.1）。これらの応答は、Imin内の一意のネットワーク状態ハッシュごとに、リンクごとに最大1つの応答のみにレート制限する必要があります。このレート制限を確認する最も簡単な方法は、リクエストを示し、1分あたり最大で1つのリクエストネットワーク状態TLV（セクション7.1.1）を送信するタイムスタンプです。より速い状態同期を容易にするために、要求ネットワーク状態TLVが応答で送信される場合、ローカルの現在のネットワーク状態TLVも送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "o Node State TLV (Section 7.2.3):",
      "ja": "o ノード状態TLV（セクション7.2.3）："
    },
    {
      "indent": 6,
      "text": "* If the node identifier matches the local node identifier and the TLV has a greater sequence number than its current local value, or the same sequence number and a different hash, the node SHOULD republish its own node data with a sequence number significantly greater than the received one (e.g., 1000) to reclaim the node identifier. This difference is needed in order to ensure that it is higher than any potentially lingering copies of the node state in the network. This may occur normally once due to the local node restarting and not storing the most recently used sequence number. If this occurs more than once or for nodes not republishing their own node data, the DNCP profile MUST provide guidance on how to handle these situations as it indicates the existence of another active node with the same node identifier.",
      "ja": "* ノード識別子がローカルノード識別子と一致し、TLVのシーケンス番号が現在のローカル値よりも大きい場合、または同じシーケンス番号と異なるハッシュの場合、ノードは、受信したシーケンス番号よりも大幅に大きいシーケンス番号で独自のノードデータを再発行する必要があります（SHOULD）。ノード識別子を再利用するための1つ（たとえば、1000）。この違いは、ネットワーク内のノード状態の潜在的に残っているコピーよりも確実に高くなるようにするために必要です。これは、ローカルノードが再起動し、最後に使用されたシーケンス番号を保存していないために、通常1回発生する可能性があります。これが複数回発生する場合、またはノードが独自のノードデータを再発行しない場合、DNCPプロファイルは、同じノード識別子を持つ別のアクティブノードの存在を示すため、これらの状況を処理する方法に関するガイダンスを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the node identifier does not match the local node identifier, and one or more of the following conditions are true:",
      "ja": "* ノードIDがローカルノードIDと一致せず、次の1つ以上の条件に該当する場合。"
    },
    {
      "indent": 9,
      "text": "+ The local information is outdated for the corresponding node (the local sequence number is less than that within the TLV).",
      "ja": "+ ローカル情報が対応するノードに対して古くなっています（ローカルシーケンス番号はTLV内のシーケンス番号よりも小さいです）。"
    },
    {
      "indent": 9,
      "text": "+ The local information is potentially incorrect (the local sequence number matches but the node data hash differs).",
      "ja": "+ ローカル情報が誤っている可能性があります（ローカルシーケンス番号は一致しますが、ノードデータハッシュは異なります）。"
    },
    {
      "indent": 9,
      "text": "+ There is no data for that node altogether.",
      "ja": "+ そのノードのデータはまったくありません。"
    },
    {
      "indent": 9,
      "text": "Then:",
      "ja": "次に："
    },
    {
      "indent": 9,
      "text": "+ If the TLV contains the Node Data field, it SHOULD also be verified by ensuring that the locally calculated hash of the node data matches the content of the H(Node Data) field within the TLV. If they differ, the TLV SHOULD be ignored and not processed further.",
      "ja": "+ TLVにノードデータフィールドが含まれている場合は、ローカルで計算されたノードデータのハッシュがTLV内のH（ノードデータ）フィールドの内容と一致することを確認して、TLVも検証する必要があります。それらが異なる場合、TLV SHOULDは無視され、それ以上処理されません。"
    },
    {
      "indent": 9,
      "text": "+ If the TLV does not contain the Node Data field, and the H(Node Data) field within the TLV differs from the local node data hash for that node (or there is none), the receiver MUST reply with a Request Node State TLV (Section 7.1.2) for the corresponding node.",
      "ja": "+ TLVにノードデータフィールドが含まれておらず、TLV内のH（ノードデータ）フィールドがそのノードのローカルノードデータハッシュと異なる（または存在しない）場合、受信者は要求ノード状態TLV（セクション7.1.2）対応するノード。"
    },
    {
      "indent": 9,
      "text": "+ Otherwise, the receiver MUST update its locally stored state for that node (node data based on the Node Data field if present, sequence number, and relative time) to match the received TLV.",
      "ja": "+ それ以外の場合、受信者は、そのノードのローカルに保存された状態（存在する場合はノードデータフィールド、シーケンス番号、および相対時間に基づくノードデータ）を更新して、受信したTLVと一致させる必要があります。"
    },
    {
      "indent": 6,
      "text": "For comparison purposes of the sequence number, a looping comparison function MUST be used to avoid problems in case of overflow. The comparison function a < b <=> ((a - b) % (2^32)) & (2^31) != 0 where (a % b) represents the remainder of a modulo b and (a & b) represents bitwise conjunction of a and b is RECOMMENDED unless the DNCP profile defines another.",
      "ja": "シーケンス番号の比較のために、オーバーフローの場合の問題を回避するために、ループ比較関数を使用する必要があります。比較関数a <b <=>（（a-b）％（2 ^ 32））＆（2 ^ 31）！= 0ここで、（a％b）はaの剰余bと（a＆b）の剰余を表しますaとbのビット単位の結合を表し、DNCPプロファイルで別のプロファイルが定義されていない限り、bは推奨されます。"
    },
    {
      "indent": 3,
      "text": "o Any other TLV: TLVs not recognized by the receiver MUST be silently ignored unless they are sent within another TLV (for example, TLVs within the Node Data field of a Node State TLV). TLVs within the Node Data field of the Node State TLV not recognized by the receiver MUST be retained for distribution to other nodes and for calculation of the node data hash as described in Section 7.2.3 but are ignored for other purposes.",
      "ja": "o その他のTLV：レシーバーによって認識されないTLVは、別のTLV内で送信されない限り（たとえば、ノードステートTLVのノードデータフィールド内のTLV）、黙って無視する必要があります。受信者によって認識されないノード状態TLVのノードデータフィールド内のTLVは、他のノードへの配信およびセクション7.2.3で説明されているノードデータハッシュの計算のために保持する必要がありますが、他の目的では無視されます。"
    },
    {
      "indent": 3,
      "text": "If secure unicast transport is configured for an endpoint, any Node State TLVs received over insecure multicast MUST be silently ignored.",
      "ja": "エンドポイントに安全なユニキャストトランスポートが構成されている場合、安全でないマルチキャストを介して受信されたノード状態TLVは、黙って無視される必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5. Discovering, Adding, and Removing Peers",
      "section_title": true,
      "ja": "4.5. ピアの検出、追加、削除"
    },
    {
      "indent": 3,
      "text": "Peer relations are established between neighbors using one or more mutually connected endpoints. Such neighbors exchange information about network state and published data directly, and through transitivity, this information then propagates throughout the network.",
      "ja": "ピア関係は、相互に接続された1つ以上のエンドポイントを使用して、ネイバー間に確立されます。このようなネイバーは、ネットワークの状態と公開されたデータに関する情報を直接交換し、推移性を通じて、この情報はネットワーク全体に伝播します。"
    },
    {
      "indent": 3,
      "text": "New peers are discovered using the regular unicast or multicast transport defined in the DNCP profile (Section 9). This process is not distinguished from peer addition, i.e., an unknown peer is simply discovered by receiving regular DNCP protocol TLVs from it, and dedicated discovery messages or TLVs do not exist. For unicast-only transports, the individual node's transport addresses are preconfigured or obtained using an external service discovery protocol. In the presence of a multicast transport, messages from unknown peers are handled in the same way as multicast messages from peers that are already known; thus, new peers are simply discovered when sending their regular DNCP protocol TLVs using multicast.",
      "ja": "新しいピアは、DNCPプロファイルで定義された通常のユニキャストまたはマルチキャストトランスポートを使用して検出されます（セクション9）。このプロセスはピアの追加と区別されません。つまり、未知のピアは、そこから通常のDNCPプロトコルTLVを受信するだけで検出され、専用の検出メッセージまたはTLVは存在しません。ユニキャストのみのトランスポートの場合、個々のノードのトランスポートアドレスは、事前に構成されているか、外部サービス検出プロトコルを使用して取得されます。マルチキャストトランスポートが存在する場合、不明なピアからのメッセージは、既知のピアからのマルチキャストメッセージと同じ方法で処理されます。したがって、マルチキャストを使用して通常のDNCPプロトコルTLVを送信すると、新しいピアが単に検出されます。"
    },
    {
      "indent": 3,
      "text": "When receiving a Node Endpoint TLV (Section 7.2.1) on an endpoint from an unknown peer:",
      "ja": "不明なピアからエンドポイントでノードエンドポイントTLV（セクション7.2.1）を受信した場合："
    },
    {
      "indent": 3,
      "text": "o If received over unicast, the remote node MUST be added as a peer on the endpoint, and a Peer TLV (Section 7.3.1) MUST be created for it.",
      "ja": "o ユニキャストで受信する場合、リモートノードをエンドポイントのピアとして追加する必要があり、ピアTLV（セクション7.3.1）を作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If received over multicast, the node MAY be sent a (possibly rate-limited) unicast Request Network State TLV (Section 7.1.1).",
      "ja": "o マルチキャストで受信された場合、ノードには（おそらくレート制限された）ユニキャスト要求ネットワーク状態TLV（セクション7.1.1）が送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "If keep-alives specified in Section 6.1 are NOT sent by the peer (either the DNCP profile does not specify the use of keep-alives or the particular peer chooses not to send keep-alives), some other existing local transport-specific means (such as Ethernet carrier detection or TCP keep-alive) MUST be used to ensure its presence. If the peer does not send keep-alives, and no means to verify presence of the peer are available, the peer MUST be considered no longer present, and it SHOULD NOT be added back as a peer until it starts sending keep-alives again. When the peer is no longer present, the Peer TLV and the local DNCP peer state MUST be removed. DNCP does not define an explicit message or TLV for indicating the termination of DNCP operation by the terminating node; however, a derived protocol could specify an extension, if the need arises.",
      "ja": "セクション6.1で指定されたキープアライブがピアによって送信されない場合（DNCPプロファイルでキープアライブの使用が指定されていないか、特定のピアがキープアライブを送信しないことを選択している場合）、他の既存のローカルトランスポート固有の手段（イーサネットキャリア検出またはTCPキープアライブなど）を使用して、その存在を確認する必要があります。ピアがキープアライブを送信せず、ピアの存在を確認する手段がない場合は、ピアは存在しないと見なす必要があり、キープアライブの送信を再開するまでピアとして追加しないでください。ピアが存在しない場合は、ピアTLVとローカルDNCPピア状態を削除する必要があります。 DNCPは、終了ノードによるDNCP操作の終了を示すための明示的なメッセージまたはTLVを定義しません。ただし、必要に応じて、派生プロトコルで拡張子を指定できます。"
    },
    {
      "indent": 3,
      "text": "If the local endpoint is in the Multicast-Listen+Unicast transport mode, a Peer TLV (Section 7.3.1) MUST NOT be published for the peers not having the highest node identifier.",
      "ja": "ローカルエンドポイントがマルチキャストリッスン+ユニキャストトランスポートモードの場合、ピアTLV（セクション7.3.1）は、最高のノード識別子を持たないピアに対して公開してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "4.6. Data Liveliness Validation",
      "section_title": true,
      "ja": "4.6. データの活性検証"
    },
    {
      "indent": 3,
      "text": "Maintenance of the hash tree (Section 4.1) and thereby network state hash updates depend on up-to-date information on bidirectional node reachability derived from the contents of a topology graph. This graph changes whenever nodes are added to or removed from the network or when bidirectional connectivity between existing nodes is established or lost. Therefore, the graph MUST be updated either immediately or with a small delay shorter than the DNCP profile-defined Trickle Imin whenever:",
      "ja": "ハッシュツリーの保守（セクション4.1）、およびそれによるネットワーク状態のハッシュ更新は、トポロジグラフの内容から導出される双方向ノードの到達可能性に関する最新情報に依存します。このグラフは、ノードがネットワークに追加またはネットワークから削除されたとき、または既存のノード間の双方向接続が確立または失われたときに変化します。したがって、次の場合は常に、DNCPプロファイルで定義されたTrickle Iminよりも短い遅延または短い遅延でグラフを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A Peer TLV or a whole node is added or removed, or",
      "ja": "o ピアTLVまたはノード全体が追加または削除された、または"
    },
    {
      "indent": 3,
      "text": "o The origination time (in milliseconds) of some node's node data is less than current time - 2^32 + 2^15.",
      "ja": "o 一部のノードのノードデータの発生時間（ミリ秒単位）が現在の時間-2 ^ 32 + 2 ^ 15未満です。"
    },
    {
      "indent": 3,
      "text": "The artificial upper limit for the origination time is used to gracefully avoid overflows of the origination time and allow for the node to republish its data as noted in Section 7.2.3.",
      "ja": "発信時間の人為的な上限は、発信時間のオーバーフローを適切に回避し、セクション7.2.3に記載されているようにノードがデータを再公開できるようにするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The topology graph update starts with the local node marked as reachable and all other nodes marked as unreachable. Other nodes are then iteratively marked as reachable using the following algorithm: A candidate not-yet-reachable node N with an endpoint NE is marked as reachable if there is a reachable node R with an endpoint RE that meets all of the following criteria:",
      "ja": "トポロジグラフの更新は、到達可能とマークされたローカルノードと到達不能とマークされた他のすべてのノードから始まります。次に、次のアルゴリズムを使用して、他のノードが繰り返し到達可能としてマークされます。エンドポイントNEを持つ到達不能ノードN候補は、次の基準のすべてを満たすエンドポイントREを持つ到達可能ノードRがある場合、到達可能としてマークされます。"
    },
    {
      "indent": 3,
      "text": "o The origination time (in milliseconds) of R's node data is greater than current time - 2^32 + 2^15.",
      "ja": "o Rのノードデータの発生時間（ミリ秒単位）が現在の時間-2 ^ 32 + 2 ^ 15を超えています。"
    },
    {
      "indent": 3,
      "text": "o R publishes a Peer TLV with:",
      "ja": "o Rは次の方法でピアTLVを公開します。"
    },
    {
      "indent": 6,
      "text": "* Peer Node Identifier = N's node identifier",
      "ja": "* ぺえｒ ので いでんちふぃえｒ ＝ んｓ ので いでんちふぃえｒ"
    },
    {
      "indent": 6,
      "text": "* Peer Endpoint Identifier = NE's endpoint identifier",
      "ja": "* ピアエンドポイント識別子= NEのエンドポイント識別子"
    },
    {
      "indent": 6,
      "text": "* Endpoint Identifier = RE's endpoint identifier",
      "ja": "* エンドポイント識別子= REのエンドポイント識別子"
    },
    {
      "indent": 3,
      "text": "o N publishes a Peer TLV with:",
      "ja": "o Nは、ピアTLVを次のように公開します。"
    },
    {
      "indent": 6,
      "text": "* Peer Node Identifier = R's node identifier",
      "ja": "* ピアノード識別子= Rのノード識別子"
    },
    {
      "indent": 6,
      "text": "* Peer Endpoint Identifier = RE's endpoint identifier",
      "ja": "* ピアエンドポイント識別子= REのエンドポイント識別子"
    },
    {
      "indent": 6,
      "text": "* Endpoint Identifier = NE's endpoint identifier",
      "ja": "* エンドポイント識別子= NEのエンドポイント識別子"
    },
    {
      "indent": 3,
      "text": "The algorithm terminates when no more candidate nodes fulfilling these criteria can be found.",
      "ja": "これらの基準を満たす候補ノードが見つからなくなると、アルゴリズムは終了します。"
    },
    {
      "indent": 3,
      "text": "DNCP nodes that have not been reachable in the most recent topology graph traversal MUST NOT be used for calculation of the network state hash, be provided to any applications that need to use the whole TLV graph, or be provided to remote nodes. They MAY be forgotten immediately after the topology graph traversal; however, it is RECOMMENDED to keep them at least briefly to improve the speed of DNCP network state convergence. This reduces the number of queries needed to reconverge during both initial network convergence and when a part of the network loses and regains bidirectional connectivity within that time period.",
      "ja": "最新のトポロジグラフトラバーサルで到達できなかったDNCPノードは、ネットワーク状態ハッシュの計算に使用したり、TLVグラフ全体を使用する必要があるアプリケーションに提供したり、リモートノードに提供したりしてはなりません（MUST NOT）。それらは、トポロジーグラフのトラバーサルの直後に忘れられる場合があります。ただし、DNCPネットワーク状態の収束の速度を向上させるために、それらを少なくとも短時間保持することをお勧めします。これにより、最初のネットワークコンバージェンス時と、ネットワークの一部がその期間内に双方向接続を失い、回復したときの両方で、再コンバージェンスに必要なクエリの数が減少します。"
    },
    {
      "indent": 0,
      "text": "5. Data Model",
      "section_title": true,
      "ja": "5. データ・モデル"
    },
    {
      "indent": 3,
      "text": "This section describes the local data structures a minimal implementation might use. This section is provided only as a convenience for the implementor. Some of the optional extensions (Section 6) describe additional data requirements, and some optional parts of the core protocol may also require more.",
      "ja": "このセクションでは、最小限の実装で使用される可能性のあるローカルデータ構造について説明します。このセクションは、実装者の便宜のためにのみ提供されています。オプションの拡張機能のいくつか（セクション6）は追加のデータ要件を説明し、コアプロトコルの一部のオプションの部分でも追加の要件が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "A DNCP node has:",
      "ja": "DNCPノードには次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o A data structure containing data about the most recently sent Request Network State TLVs (Section 7.1.1). The simplest option is keeping a timestamp of the most recent request (required to fulfill reply rate limiting specified in Section 4.4).",
      "ja": "o 最近送信された要求ネットワーク状態TLVに関するデータを含むデータ構造（セクション7.1.1）。最も単純なオプションは、最新のリクエストのタイムスタンプを保持することです（セクション4.4で指定された応答レート制限を満たすために必要）。"
    },
    {
      "indent": 3,
      "text": "A DNCP node has the following for every DNCP node in the DNCP network:",
      "ja": "DNCPノードには、DNCPネットワーク内のすべてのDNCPノードについて次のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Node identifier: the unique identifier of the node. The length, how it is produced, and how collisions are handled is up to the DNCP profile.",
      "ja": "o ノード識別子：ノードの一意の識別子。長さ、生成方法、および衝突の処理方法は、DNCPプロファイル次第です。"
    },
    {
      "indent": 3,
      "text": "o Node data: the set of TLV tuples published by that particular node. As they are transmitted in a particular order (see Node State TLV (Section 7.2.3) for details), maintaining the order within the data structure here may be reasonable.",
      "ja": "o ノードデータ：その特定のノードによって公開されたTLVタプルのセット。それらは特定の順序で送信されるため（詳細についてはノード状態TLV（セクション7.2.3）を参照）、ここでデータ構造内の順序を維持するのが妥当な場合があります。"
    },
    {
      "indent": 3,
      "text": "o Latest sequence number: the 32-bit sequence number that is incremented any time the TLV set is published. The comparison function used to compare them is described in Section 4.4.",
      "ja": "o 最新のシーケンス番号：TLVセットが公開されるたびにインクリメントされる32ビットのシーケンス番号。それらを比較するために使用される比較関数は、セクション4.4で説明されています。"
    },
    {
      "indent": 3,
      "text": "o Origination time: the (estimated) time when the current TLV set with the current sequence number was published. It is used to populate the Milliseconds Since Origination field in a Node State TLV (Section 7.2.3). Ideally, it also has millisecond accuracy.",
      "ja": "o 発生時間：現在のシーケンス番号で設定された現在のTLVが発行された（推定）時間。これは、ノード状態TLV（セクション7.2.3）の開始からのミリ秒フィールドに入力するために使用されます。理想的には、ミリ秒の精度も備えています。"
    },
    {
      "indent": 3,
      "text": "Additionally, a DNCP node has a set of endpoints for which DNCP is configured to be used. For each such endpoint, a node has:",
      "ja": "さらに、DNCPノードには、DNCPが使用されるように構成されているエンドポイントのセットがあります。このようなエンドポイントごとに、ノードには次のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Endpoint identifier: the 32-bit opaque locally unique value identifying the endpoint within a node. It SHOULD NOT be reused immediately after an endpoint is disabled.",
      "ja": "o エンドポイント識別子：ノード内のエンドポイントを識別する32ビットの不透明なローカルで一意の値。エンドポイントが無効になった直後に再利用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "o Trickle instance: the endpoint's Trickle instance with parameters I, T, and c (only on an endpoint in Multicast+Unicast transport mode).",
      "ja": "o Trickleインスタンス：エンドポイントのパラメーターI、T、cを持つTrickleインスタンス（マルチキャスト+ユニキャストトランスポートモードのエンドポイントのみ）。"
    },
    {
      "indent": 3,
      "text": "and one (or more) of the following:",
      "ja": "および以下の1つ（または複数）："
    },
    {
      "indent": 3,
      "text": "o Interface: the assigned local network interface.",
      "ja": "o インターフェイス：割り当てられたローカルネットワークインターフェイス。"
    },
    {
      "indent": 3,
      "text": "o Unicast address: the DNCP node it should connect with.",
      "ja": "o ユニキャストアドレス：接続先のDNCPノード。"
    },
    {
      "indent": 3,
      "text": "o Set of addresses: the DNCP nodes from which connections are accepted.",
      "ja": "o アドレスのセット：接続が受け入れられるDNCPノード。"
    },
    {
      "indent": 3,
      "text": "For each remote (peer, endpoint) pair detected on a local endpoint, a DNCP node has:",
      "ja": "ローカルエンドポイントで検出されたリモート（ピア、エンドポイント）ペアごとに、DNCPノードには次のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Node identifier: the unique identifier of the peer.",
      "ja": "o ノード識別子：ピアの一意の識別子。"
    },
    {
      "indent": 3,
      "text": "o Endpoint identifier: the unique endpoint identifier used by the peer.",
      "ja": "o エンドポイント識別子：ピアが使用する一意のエンドポイント識別子。"
    },
    {
      "indent": 3,
      "text": "o Peer address: the most recently used address of the peer (authenticated and authorized, if security is enabled).",
      "ja": "o ピアアドレス：最近使用したピアのアドレス（セキュリティが有効になっている場合は、認証および承認済み）。"
    },
    {
      "indent": 3,
      "text": "o Trickle instance: the particular peer's Trickle instance with parameters I, T, and c (only on an endpoint in unicast mode, when using an unreliable unicast transport).",
      "ja": "o Trickleインスタンス：特定のピアのパラメーターI、T、およびcを持つTrickleインスタンス（信頼性の低いユニキャストトランスポートを使用する場合は、ユニキャストモードのエンドポイントのみ）。"
    },
    {
      "indent": 0,
      "text": "6. Optional Extensions",
      "section_title": true,
      "ja": "6. オプションの拡張機能"
    },
    {
      "indent": 3,
      "text": "This section specifies extensions to the core protocol that a DNCP profile may specify to be used.",
      "ja": "このセクションでは、DNCPプロファイルが使用するように指定できるコアプロトコルの拡張を指定します。"
    },
    {
      "indent": 0,
      "text": "6.1. Keep-Alives",
      "section_title": true,
      "ja": "6.1. キープアライブ"
    },
    {
      "indent": 3,
      "text": "While DNCP provides mechanisms for discovery and adding new peers on an endpoint (Section 4.5), as well as state change notifications, another mechanism may be needed to get rid of old, no longer valid peers if the transport or lower layers do not provide one as noted in Section 4.6.",
      "ja": "DNCPは、エンドポイント（セクション4.5）での新しいピアの検出と追加、および状態変更通知のメカニズムを提供しますが、トランスポート層または下位層がピアを提供しない場合、古く有効でないピアを取り除くために別のメカニズムが必要になる場合がありますセクション4.6で述べたように。"
    },
    {
      "indent": 3,
      "text": "If keep-alives are not specified in the DNCP profile, the rest of this subsection MUST be ignored.",
      "ja": "DNCPプロファイルでキープアライブが指定されていない場合は、このサブセクションの残りを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "A DNCP profile MAY specify either per-endpoint (sent using multicast to all DNCP nodes connected to a multicast-enabled link) or per-peer (sent using unicast to each peer individually) keep-alive support.",
      "ja": "DNCPプロファイルは、エンドポイントごと（マルチキャスト対応リンクに接続されたすべてのDNCPノードにマルチキャストを使用して送信）またはピアごと（ユニキャストを使用して各ピアに個別に送信）のキープアライブサポートを指定する場合があります。"
    },
    {
      "indent": 3,
      "text": "For every endpoint that a keep-alive is specified for in the DNCP profile, the endpoint-specific keep-alive interval MUST be maintained. By default, it is DNCP_KEEPALIVE_INTERVAL. If there is a local value that is preferred for that for any reason (configuration, energy conservation, media type, ...), it can be substituted instead. If a non-default keep-alive interval is used on any endpoint, a DNCP node MUST publish an appropriate Keep-Alive Interval TLV(s) (Section 7.3.2) within its node data.",
      "ja": "DNCPプロファイルでキープアライブが指定されているすべてのエンドポイントについて、エンドポイント固有のキープアライブ間隔を維持する必要があります。デフォルトでは、DNCP_KEEPALIVE_INTERVALです。何らかの理由（構成、エネルギー節約、メディアタイプなど）でそのために推奨されるローカル値がある場合は、代わりに置き換えることができます。デフォルト以外のキープアライブ間隔がいずれかのエンドポイントで使用されている場合、DNCPノードは、そのノードデータ内に適切なキープアライブ間隔TLV（セクション7.3.2）を公開する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Data Model Additions",
      "section_title": true,
      "ja": "6.1.1. データモデルの追加"
    },
    {
      "indent": 3,
      "text": "The following additions to the Data Model (Section 5) are needed to support keep-alives:",
      "ja": "キープアライブをサポートするには、データモデル（セクション5）に次の追加が必要です。"
    },
    {
      "indent": 3,
      "text": "For each configured endpoint that has per-endpoint keep-alives enabled:",
      "ja": "エンドポイントごとのキープアライブが有効になっている構成済みのエンドポイントごとに："
    },
    {
      "indent": 3,
      "text": "o Last sent: If a timestamp that indicates the last time a Network State TLV (Section 7.2.2) was sent over that interface.",
      "ja": "o 最終送信：ネットワークステートTLV（セクション7.2.2）がそのインターフェースを介して最後に送信された時刻を示すタイムスタンプの場合。"
    },
    {
      "indent": 3,
      "text": "For each remote (peer, endpoint) pair detected on a local endpoint, a DNCP node has:",
      "ja": "ローカルエンドポイントで検出されたリモート（ピア、エンドポイント）ペアごとに、DNCPノードには次のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Last contact timestamp: A timestamp that indicates the last time a consistent Network State TLV (Section 7.2.2) was received from the peer over multicast or when anything was received over unicast. Failing to update it for a certain amount of time as specified in Section 6.1.5 results in the removal of the peer. When adding a new peer, it is initialized to the current time.",
      "ja": "o 最終連絡タイムスタンプ：一貫したネットワーク状態TLV（セクション7.2.2）がマルチキャスト経由でピアから最後に受信されたとき、またはユニキャスト経由で何かが受信されたときのタイムスタンプ。セクション6.1.5で指定されているように、一定時間更新を行わないと、ピアが削除されます。新しいピアを追加すると、現在の時刻に初期化されます。"
    },
    {
      "indent": 3,
      "text": "o Last sent: If per-peer keep-alives are enabled, a timestamp that indicates the last time a Network State TLV (Section 7.2.2) was sent to that point-to-point peer. When adding a new peer, it is initialized to the current time.",
      "ja": "o 最終送信：ピアごとのキープアライブが有効な場合、そのポイントツーポイントピアにネットワーク状態TLV（セクション7.2.2）が最後に送信された時刻を示すタイムスタンプ。新しいピアを追加すると、現在の時刻に初期化されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Per-Endpoint Periodic Keep-Alives",
      "section_title": true,
      "ja": "6.1.2. エンドポイントごとの定期的なキープアライブ"
    },
    {
      "indent": 3,
      "text": "If per-endpoint keep-alives are enabled on an endpoint in Multicast+Unicast transport mode, and if no traffic containing a Network State TLV (Section 7.2.2) has been sent to a particular endpoint within the endpoint-specific keep-alive interval, a Network State TLV (Section 7.2.2) MUST be sent on that endpoint, and a new Trickle interval started, as specified in step 2 of Section 4.2 of [RFC6206]. The actual sending time SHOULD be further delayed by a random time span in [0, Imin/2].",
      "ja": "エンドポイントごとのキープアライブがマルチキャスト+ユニキャストトランスポートモードのエンドポイントで有効になっていて、ネットワーク状態TLV（セクション7.2.2）を含むトラフィックがエンドポイント固有のキープアライブインターバル内の特定のエンドポイントに送信されていない場合[RFC6206]のセクション4.2のステップ2で指定されているように、そのエンドポイントでネットワーク状態TLV（セクション7.2.2）を送信し、新しいトリクル間隔を開始する必要があります。実際の送信時間は、[0、Imin / 2]のランダムな時間幅だけさらに遅延する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Per-Peer Periodic Keep-Alives",
      "section_title": true,
      "ja": "6.1.3. ピアごとの定期的なキープアライブ"
    },
    {
      "indent": 3,
      "text": "If per-peer keep-alives are enabled on a unicast-only endpoint, and if no traffic containing a Network State TLV (Section 7.2.2) has been sent to a particular peer within the endpoint-specific keep-alive interval, a Network State TLV (Section 7.2.2) MUST be sent to the peer, and a new Trickle interval started, as specified in step 2 of Section 4.2 of [RFC6206].",
      "ja": "ピアごとのキープアライブがユニキャストのみのエンドポイントで有効になっていて、ネットワーク状態TLV（セクション7.2.2）を含むトラフィックがエンドポイント固有のキープアライブ間隔内に特定のピアに送信されていない場合、ネットワーク[RFC6206]のセクション4.2のステップ2で指定されているように、状態TLV（セクション7.2.2）をピアに送信し、新しいトリクル間隔を開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Received TLV Processing Additions",
      "section_title": true,
      "ja": "6.1.4. 受信したTLV処理の追加"
    },
    {
      "indent": 3,
      "text": "If a TLV is received over unicast from the peer, the Last contact timestamp for the peer MUST be updated.",
      "ja": "TLVがユニキャストでピアから受信された場合、ピアの最終連絡タイムスタンプを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Network State TLV (Section 7.2.2) that is consistent with the locally calculated network state hash, the Last contact timestamp for the peer MUST be updated in order to maintain it as a peer.",
      "ja": "ローカルに計算されたネットワーク状態ハッシュと一致するネットワーク状態TLV（セクション7.2.2）を受信すると、ピアとして維持するために、ピアの最終連絡タイムスタンプを更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.5. Peer Removal",
      "section_title": true,
      "ja": "6.1.5. ピアの削除"
    },
    {
      "indent": 3,
      "text": "For every peer on every endpoint, the endpoint-specific keep-alive interval must be calculated by looking for Keep-Alive Interval TLVs (Section 7.3.2) published by the node, and if none exist, use the default value of DNCP_KEEPALIVE_INTERVAL. If the peer's Last contact timestamp has not been updated for at least a locally chosen potentially endpoint-specific keep-alive multiplier (defaults to DNCP_KEEPALIVE_MULTIPLIER) times the peer's endpoint-specific keep-alive interval, the Peer TLV for that peer and the local DNCP peer state MUST be removed.",
      "ja": "すべてのエンドポイントのすべてのピアについて、ノードによって公開されたキープアライブインターバルTLV（セクション7.3.2）を検索して、エンドポイント固有のキープアライブインターバルを計算する必要があります。存在しない場合は、DNCP_KEEPALIVE_INTERVALのデフォルト値を使用します。少なくともローカルで選択された潜在的にエンドポイント固有のキープアライブ乗数（デフォルトはDNCP_KEEPALIVE_MULTIPLIER）のピアの最終連絡タイムスタンプが更新されていない場合、ピアのエンドポイント固有のキープアライブ間隔、そのピアのピアTLV、およびローカルDNCPピア状態を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Support for Dense Multicast-Enabled Links",
      "section_title": true,
      "ja": "6.2. 高密度マルチキャスト対応リンクのサポート"
    },
    {
      "indent": 3,
      "text": "This optimization is needed to avoid a state space explosion. Given a large set of DNCP nodes publishing data on an endpoint that uses multicast on a link, every node will add a Peer TLV (Section 7.3.1) for each peer. While Trickle limits the amount of traffic on the link in stable state to some extent, the total amount of data that is added to and maintained in the DNCP network given N nodes on a multicast-enabled link is O(N^2). Additionally, if per-peer keep-alives are used, there will be O(N^2) keep-alives running on the link if the liveliness of peers is not ensured using some other way (e.g., TCP connection lifetime, Layer 2 notification, or per-endpoint keep-alive).",
      "ja": "この最適化は、状態空間の爆発を回避するために必要です。リンクでマルチキャストを使用するエンドポイントでデータを公開するDNCPノードの大規模なセットが与えられると、すべてのノードが各ピアにピアTLV（セクション7.3.1）を追加します。 Trickleは、安定した状態のリンク上のトラフィック量をある程度制限しますが、マルチキャスト対応リンク上のN個のノードが与えられた場合、DNCPネットワークに追加および維持されるデータの総量はO（N ^ 2）です。さらに、ピアごとのキープアライブが使用されている場合、他の方法（TCP接続の存続時間、レイヤー2通知など）を使用してピアの活性が保証されない場合、リンク上でO（N ^ 2）キープアライブが実行されます。 、またはエンドポイントごとのキープアライブ）。"
    },
    {
      "indent": 3,
      "text": "An upper bound for the number of peers that are allowed for a particular type of link that an endpoint in Multicast+Unicast transport mode is used on SHOULD be provided by a DNCP profile, but it MAY also be chosen at runtime. The main consideration when selecting a bound (if any) for a particular type of link should be whether it supports multicast traffic and whether a too large number of peers case is likely to happen during the use of that DNCP profile on that particular type of link. If neither is likely, there is little point specifying support for this for that particular link type.",
      "ja": "マルチキャスト+ユニキャストトランスポートモードのエンドポイントが使用される特定のタイプのリンクに許可されるピアの数の上限は、DNCPプロファイルによって提供される必要がありますが、実行時に選択することもできます（MAY）。特定のタイプのリンクのバウンド（存在する場合）を選択する際の主な考慮事項は、マルチキャストトラフィックをサポートするかどうか、およびその特定のタイプのリンクでのDNCPプロファイルの使用中にピ​​アケースが多すぎる可能性があるかどうかです。 。どちらも可能性が低い場合、その特定のリンクタイプでこれに対するサポートを指定することはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "If a DNCP profile does not support this extension at all, the rest of this subsection MUST be ignored. This is because when this extension is used, the state within the DNCP network only contains a subset of the full topology of the network. Therefore, every node must be aware of the potential of it being used in a particular DNCP profile.",
      "ja": "DNCPプロファイルがこの拡張をまったくサポートしない場合、このサブセクションの残りは無視されなければなりません（MUST）。これは、この拡張が使用されている場合、DNCPネットワーク内の状態にはネットワークの完全なトポロジのサブセットのみが含まれるためです。したがって、すべてのノードは、特定のDNCPプロファイルで使用される可能性を認識している必要があります。"
    },
    {
      "indent": 3,
      "text": "If the specified upper bound is exceeded for some endpoint in Multicast+Unicast transport mode and if the node does not have the highest node identifier on the link, it SHOULD treat the endpoint as a unicast endpoint connected to the node that has the highest node identifier detected on the link, therefore transitioning to Multicast-listen+Unicast transport mode. See Section 4.2 for implications on the specific endpoint behavior. The nodes in Multicast-listen+Unicast transport mode MUST keep listening to multicast traffic to both receive messages from the node(s) still in Multicast+Unicast mode and react to nodes with a greater node identifier appearing. If the highest node identifier present on the link changes, the remote unicast address of the endpoints in Multicast-Listen+Unicast transport mode MUST be changed. If the node identifier of the local node is the highest one, the node MUST switch back to, or stay in, Multicast+Unicast mode and form peer relationships with all peers as specified in Section 4.5.",
      "ja": "マルチキャスト+ユニキャストトランスポートモードの一部のエンドポイントで指定された上限を超え、ノードがリンク上で最高のノード識別子を持たない場合、エンドポイントを最高のノード識別子を持つノードに接続されたユニキャストエンドポイントとして扱う必要があります（SHOULD）。リンク上で検出されたため、マルチキャストリッスン+ユニキャストトランスポートモードに移行しています。特定のエンドポイントの動作への影響については、セクション4.2を参照してください。マルチキャストリッスン+ユニキャストトランスポートモードのノードは、マルチキャストトラフィックをリッスンし続けて、まだマルチキャスト+ユニキャストモードのノードからメッセージを受信し、より大きなノード識別子が表示されているノードに反応する必要があります。リンクに存在する最上位のノード識別子が変更される場合、マルチキャストリッスン+ユニキャストトランスポートモードのエンドポイントのリモートユニキャストアドレスを変更する必要があります。ローカルノードのノード識別子が最も高い場合、ノードはマルチキャスト+ユニキャストモードに切り替わるか、マルチキャストモードにとどまり、セクション4.5で指定されているすべてのピアとのピア関係を形成する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Type-Length-Value Objects",
      "section_title": true,
      "ja": "7. Type-Length-Valueオブジェクト"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Type               |           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Value (if any) (+padding (if any))              |\n..\n|                     (variable # of bytes)                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     (optional nested TLVs)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each TLV is encoded as:",
      "ja": "各TLVは次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "o a 2-byte Type field",
      "ja": "o 2バイトのTypeフィールド"
    },
    {
      "indent": 3,
      "text": "o a 2-byte Length field, which contains the length of the Value field in bytes; 0 means no value",
      "ja": "o 値フィールドの長さをバイト単位で含む2バイトの長さフィールド。 0は値がないことを意味します"
    },
    {
      "indent": 3,
      "text": "o the value itself (if any)",
      "ja": "o 値自体（存在する場合）"
    },
    {
      "indent": 3,
      "text": "o padding bytes with a value of zero up to the next 4-byte boundary if the Length is not divisible by 4",
      "ja": "o 長さが4で割り切れない場合、次の4バイト境界までゼロの値でバイトをパディングします"
    },
    {
      "indent": 3,
      "text": "While padding bytes MUST NOT be included in the number stored in the Length field of the TLV, if the TLV is enclosed within another TLV, then the padding is included in the enclosing TLV's Length value.",
      "ja": "パディングバイトはTLVの長さフィールドに格納されている数に含まれてはいけませんが、TLVが別のTLV内に含まれている場合、パディングは囲まれたTLVの長さ値に含まれます。"
    },
    {
      "indent": 3,
      "text": "Each TLV that does not define optional fields or variable-length content MAY be sent with additional sub-TLVs appended after the TLV to allow for extensibility. When handling such TLV types, each node MUST accept received TLVs that are longer than the fixed fields specified for the particular type and ignore the sub-TLVs with either unknown types or types not supported within that particular TLV. If any sub-TLVs are present, the Length field of the TLV describes the number of bytes from the first byte of the TLV's own Value (if any) to the last (padding) byte of the last sub-TLV.",
      "ja": "オプションのフィールドや可変長コンテンツを定義しない各TLVは、拡張性を考慮して、TLVの後に追加のサブTLVを追加して送信できます（MAY）。このようなTLVタイプを処理する場合、各ノードは、特定のタイプに指定された固定フィールドよりも長い受信TLVを受け入れ、不明なタイプまたはその特定のTLV内でサポートされていないタイプのサブTLVを無視する必要があります。サブTLVが存在する場合、TLVの長さフィールドは、TLV自体の値（存在する場合）の最初のバイトから最後のサブTLVの最後の（パディング）バイトまでのバイト数を示します。"
    },
    {
      "indent": 3,
      "text": "For example, type=123 (0x7b) TLV with value 'x' (120 = 0x78) is encoded as: 007B 0001 7800 0000. If it were to have a sub-TLV of type=124 (0x7c) with value 'y', it would be encoded as 007B 000C 7800 0000 007C 0001 7900 0000.",
      "ja": "たとえば、値が「x」のtype = 123（0x7b）TLV（120 = 0x78）は次のようにエンコードされます：007B 0001 78000000。値が「y」のtype = 124（0x7c）のサブTLVがある場合、それは007B 000C 7800 0000 007C 0001 7900 0000としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "In this section, the following special notation is used:",
      "ja": "このセクションでは、次の特別な表記が使用されています。"
    },
    {
      "indent": 6,
      "text": ".. = octet string concatenation operation.",
      "ja": ".. =オクテット文字列連結演算。"
    },
    {
      "indent": 6,
      "text": "H(x) = non-cryptographic hash function specified by the DNCP profile.",
      "ja": "H（x）= DNCPプロファイルで指定された非暗号化ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "In addition to the TLV types defined in this document, TLV Types 11-31 and 512-767 are unassigned and may be sequentially registered, starting at 11, by Standards Action [RFC5226] by extensions to DNCP that may be applicable in multiple DNCP profiles.",
      "ja": "このドキュメントで定義されているTLVタイプに加えて、TLVタイプ11〜31および512〜767は割り当てられておらず、標準アクション[RFC5226]により、11から順番に登録され、複数のDNCPプロファイルに適用可能なDNCPの拡張機能によって登録されます。 。"
    },
    {
      "indent": 0,
      "text": "7.1. Request TLVs",
      "section_title": true,
      "ja": "7.1. TLVをリクエストする"
    },
    {
      "indent": 0,
      "text": "7.1.1. Request Network State TLV",
      "section_title": true,
      "ja": "7.1.1. ネットワーク状態TLVの要求"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Type: Request network state (1)|          Length: >= 0         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV is used to request response with a Network State TLV (Section 7.2.2) and all Node State TLVs (Section 7.2.3) (without node data).",
      "ja": "このTLVは、ネットワーク状態TLV（セクション7.2.2）およびすべてのノード状態TLV（セクション7.2.3）（ノードデータなし）で応答を要求するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Request Node State TLV",
      "section_title": true,
      "ja": "7.1.2. ノード状態TLVの要求"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type: Request node state (2)  |          Length: > 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV is used to request a Node State TLV (Section 7.2.3) (including node data) for the node with the matching node identifier.",
      "ja": "このTLVは、一致するノード識別子を持つノードのノード状態TLV（セクション7.2.3）（ノードデータを含む）を要求するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Data TLVs",
      "section_title": true,
      "ja": "7.2. データTLV"
    },
    {
      "indent": 0,
      "text": "7.2.1. Node Endpoint TLV",
      "section_title": true,
      "ja": "7.2.1. ノードエンドポイントTLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type: Node endpoint (3)     |          Length: > 4          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Endpoint Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV identifies both the local node's node identifier, as well as the particular endpoint's endpoint identifier. Section 4.2 specifies when it is sent.",
      "ja": "このTLVは、ローカルノードのノード識別子と特定のエンドポイントのエンドポイント識別子の両方を識別します。セクション4.2では、いつ送信するかを指定します。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Network State TLV",
      "section_title": true,
      "ja": "7.2.2. ネットワーク状態TLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type: Network state (4)    |          Length: > 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     H(sequence number of node 1 .. H(node data of node 1) ..  |\n|    .. sequence number of node N .. H(node data of node N))    |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV contains the current network state hash calculated by its sender (Section 4.1 describes the algorithm).",
      "ja": "このTLVには、送信者によって計算された現在のネットワーク状態ハッシュが含まれています（セクション4.1でアルゴリズムについて説明しています）。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Node State TLV",
      "section_title": true,
      "ja": "7.2.3. ノード状態TLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type: Node state (5)     |          Length: > 8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Sequence Number                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Milliseconds Since Origination                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         H(Node Data)                          |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       (optionally) Node Data (a set of nested TLVs)           |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV represents the local node's knowledge about the published state of a node in the DNCP network identified by the Node Identifier field in the TLV.",
      "ja": "このTLVは、TLVのノード識別子フィールドで識別されるDNCPネットワーク内のノードの公開状態に関するローカルノードの知識を表します。"
    },
    {
      "indent": 0,
      "text": " Every node, including the node publishing the node data, MUST update the Milliseconds Since Origination whenever it sends a Node State TLV based on when the node estimates the data was originally published. This is, e.g., to ensure that any relative timestamps contained within the published node data can be correctly offset and interpreted. Ultimately, what is provided is just an approximation, as transmission delays are not accounted for.",
      "ja": "ノードデータをパブリッシュするノードを含むすべてのノードは、ノードがデータが最初にパブリッシュされたと推定した時点に基づいてノード状態TLVを送信するたびに、発信からのミリ秒を更新する必要があります。これは、たとえば、公開されたノードデータ内に含まれる相対タイムスタンプを正しくオフセットおよび解釈できるようにするためです。送信遅延は考慮されていないため、最終的には、提供されるものは単なる概算です。"
    },
    {
      "indent": 3,
      "text": "Absent any changes, if the originating node notices that the 32-bit Milliseconds Since Origination value would be close to overflow (greater than 2^32 - 2^16), the node MUST republish its TLVs even if there is no change. In other words, absent any other changes, the TLV set MUST be republished roughly every 48 days.",
      "ja": "変更がない場合、元のノードが32ビットのミリ秒からの値がオーバーフローに近い（2 ^ 32-2 ^ 16より大きい）ことに気付いた場合、ノードは変更がない場合でもTLVを再発行する必要があります。つまり、他の変更がない場合、TLVセットはおおよそ48日ごとに再発行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The actual node data of the node may be included within the TLV as well as in the optional Node Data field. The set of TLVs MUST be strictly ordered based on ascending binary content (including TLV type and length). This enables, e.g., efficient state delta processing and no-copy indexing by TLV type by the recipient. The node data content MUST be passed along exactly as it was received. It SHOULD be also verified on receipt that the locally calculated H(Node Data) matches the content of the field within the TLV, and if the hash differs, the TLV SHOULD be ignored.",
      "ja": "ノードの実際のノードデータは、TLV内およびオプションのノードデータフィールドに含めることができます。 TLVのセットは、昇順のバイナリコンテンツ（TLVのタイプと長さを含む）に基づいて厳密に並べる必要があります。これにより、たとえば、効率的な状態デルタ処理と、受信者によるTLVタイプによるコピーなしのインデックス作成が可能になります。ノードデータコンテンツは、受信したとおりに渡す必要があります。また、ローカルで計算されたH（ノードデータ）がTLV内のフィールドの内容と一致することを受信時に確認する必要があります。ハッシュが異なる場合、TLVは無視されるべきです（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "7.3. Data TLVs within Node State TLV",
      "section_title": true,
      "ja": "7.3. ノード状態TLV内のデータTLV"
    },
    {
      "indent": 3,
      "text": "These TLVs are published by the DNCP nodes and are therefore only encoded in the Node Data field of Node State TLVs. If encountered outside Node State TLV, they MUST be silently ignored.",
      "ja": "これらのTLVはDNCPノードによって発行されるため、ノード状態TLVのノードデータフィールドでのみエンコードされます。ノード状態TLVの外で発生した場合は、黙って無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Peer TLV",
      "section_title": true,
      "ja": "7.3.1. ピアTLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Type: Peer (8)          |          Length: > 8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Peer Node Identifier                     |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Peer Endpoint Identifier                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   (Local) Endpoint Identifier                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV indicates that the node in question vouches that the specified peer is reachable by it on the specified local endpoint. The presence of this TLV at least guarantees that the node publishing it has received traffic from the peer recently. For guaranteed up-to-date bidirectional reachability, the existence of both nodes' matching Peer TLVs needs to be checked.",
      "ja": "このTLVは、問題のノードが、指定されたローカルエンドポイントで指定されたピアに到達できることを保証することを示しています。このTLVの存在は、それを公開するノードが最近ピアからトラフィックを受信したことを少なくとも保証します。最新の双方向の到達可能性を保証するには、両方のノードの一致するピアTLVの存在を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Keep-Alive Interval TLV",
      "section_title": true,
      "ja": "7.3.2. キープアライブインターバルTLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type: Keep-alive interval (9) |          Length: >= 8         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Endpoint Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Interval                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This TLV indicates a non-default interval being used to send keep-alives as specified in Section 6.1.",
      "ja": "このTLVは、セクション6.1で指定されているように、キープアライブの送信にデフォルト以外の間隔が使用されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "Endpoint identifier is used to identify the particular (local) endpoint for which the interval applies on the sending node. If 0, it applies for ALL endpoints for which no specific TLV exists.",
      "ja": "エンドポイントIDは、送信ノードで間隔が適用される特定の（ローカル）エンドポイントを識別するために使用されます。 0の場合、特定のTLVが存在しないすべてのエンドポイントに適用されます。"
    },
    {
      "indent": 3,
      "text": "Interval specifies the interval in milliseconds at which the node sends keep-alives. A value of zero means no keep-alives are sent at all; in that case, some lower-layer mechanism that ensures the presence of nodes MUST be available and used.",
      "ja": "間隔は、ノードがキープアライブを送信する間隔をミリ秒単位で指定します。値0は、キープアライブがまったく送信されないことを意味します。その場合、ノードの存在を保証する下位層のメカニズムが利用可能で使用されなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "8. Security and Trust Management",
      "section_title": true,
      "ja": "8. セキュリティと信頼管理"
    },
    {
      "indent": 3,
      "text": "If specified in the DNCP profile, either DTLS [RFC6347] or TLS [RFC5246] may be used to authenticate and encrypt either some (if specified optional in the profile) or all unicast traffic. The following methods for establishing trust are defined, but it is up to the DNCP profile to specify which ones may, should, or must be supported.",
      "ja": "DNCPプロファイルで指定されている場合、DTLS [RFC6347]またはTLS [RFC5246]のいずれかを使用して、一部（プロファイルでオプションで指定されている場合）またはすべてのユニキャストトラフィックを認証および暗号化できます。信頼を確立するための次の方法が定義されていますが、サポートする必要がある、サポートする必要がある、またはサポートする必要があるものを指定するのはDNCPプロファイル次第です。"
    },
    {
      "indent": 0,
      "text": "8.1. Trust Method Based on Pre-Shared Key",
      "section_title": true,
      "ja": "8.1. 事前共有キーに基づく信頼方法"
    },
    {
      "indent": 3,
      "text": "A trust model based on Pre-Shared Key (PSK) is a simple security management mechanism that allows an administrator to deploy devices to an existing network by configuring them with a predefined key, similar to the configuration of an administrator password or Wi-Fi Protected Access (WPA) key. Although limited in nature, it is useful to provide a user-friendly security mechanism for smaller networks.",
      "ja": "事前共有キー（PSK）に基づく信頼モデルは、管理者が既存のネットワークにデバイスを展開するための簡単なセキュリティ管理メカニズムであり、管理者パスワードまたはWi-Fi Protectedの構成と同様に、事前定義されたキーでデバイスを構成できますアクセス（WPA）キー。本質的に制限はありますが、小規模なネットワークにユーザーフレンドリーなセキュリティメカニズムを提供すると便利です。"
    },
    {
      "indent": 0,
      "text": "8.2. PKI-Based Trust Method",
      "section_title": true,
      "ja": "8.2. PKIベースの信頼方式"
    },
    {
      "indent": 3,
      "text": "A PKI-based trust model enables more advanced management capabilities at the cost of increased complexity and bootstrapping effort. However, it allows trust to be managed in a centralized manner and is therefore useful for larger networks with a need for an authoritative trust management.",
      "ja": "PKIベースの信頼モデルは、複雑さとブートストラップ作業の増加を犠牲にして、より高度な管理機能を可能にします。ただし、信頼を一元的に管理できるため、信頼できる信頼管理が必要な大規模ネットワークで役立ちます。"
    },
    {
      "indent": 0,
      "text": "8.3. Certificate-Based Trust Consensus Method",
      "section_title": true,
      "ja": "8.3. 証明書ベースの信頼コンセンサス方式"
    },
    {
      "indent": 3,
      "text": "For some scenarios -- such as bootstrapping a mostly unmanaged network -- the methods described above may not provide a desirable trade-off between security and user experience. This section includes guidance for implementing an opportunistic security [RFC7435] method that DNCP profiles can build upon and adapt for their specific requirements.",
      "ja": "ほとんど管理されていないネットワークのブートストラップなど、一部のシナリオでは、上記の方法では、セキュリティとユーザーエクスペリエンスの望ましいトレードオフが提供されない場合があります。このセクションには、DNCPプロファイルが特定の要件に基づいて構築および適応できる日和見セキュリティ[RFC7435]メソッドの実装に関するガイダンスが含まれています。"
    },
    {
      "indent": 3,
      "text": "The certificate-based consensus model is designed to be a compromise between trust management effort and flexibility. It is based on X.509 certificates and allows each DNCP node to provide a trust verdict on any other certificate, and a consensus is found to determine whether a node using this certificate or any certificate signed by it is to be trusted.",
      "ja": "証明書ベースのコンセンサスモデルは、信頼管理の取り組みと柔軟性の妥協点となるように設計されています。これはX.509証明書に基づいており、各DNCPノードが他の証明書に対する信頼判定を提供できるようにします。また、この証明書を使用するノードまたはそれによって署名された証明書を使用するノードを信頼するかどうかを決定するコンセンサスが見つかります。"
    },
    {
      "indent": 3,
      "text": "A DNCP node not using this security method MUST ignore all announced trust verdicts and MUST NOT announce any such verdicts by itself, i.e., any other normative language in this subsection does not apply to it.",
      "ja": "このセキュリティメソッドを使用しないDNCPノードは、アナウンスされたすべての信頼判定を無視する必要があり、そのような判定をそれ自体でアナウンスしてはなりません。"
    },
    {
      "indent": 3,
      "text": "The current effective trust verdict for any certificate is defined as the one with the highest priority from all trust verdicts announced for said certificate at the time.",
      "ja": "証明書の現在の有効な信頼性判定は、その時点でその証明書に対して発表されたすべての信頼性判定の中で最も優先順位が高いものとして定義されています。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Trust Verdicts",
      "section_title": true,
      "ja": "8.3.1. 信頼評決"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are statements of DNCP nodes about the trustworthiness of X.509 certificates. There are 5 possible trust verdicts in order of ascending priority:",
      "ja": "信頼判定は、X.509証明書の信頼性に関するDNCPノードのステートメントです。優先順位が高い順に5つの信頼できる判定があります。"
    },
    {
      "indent": 6,
      "text": "0 (Neutral): no trust verdict exists, but the DNCP network should determine one.",
      "ja": "0（ニュートラル）：信頼の判定は存在しませんが、DNCPネットワークがそれを決定する必要があります。"
    },
    {
      "indent": 6,
      "text": "1 (Cached Trust): the last known effective trust verdict was Configured or Cached Trust.",
      "ja": "1（キャッシュされた信頼）：最後に確認された有効な信頼の判定は、構成済みまたはキャッシュされた信頼でした。"
    },
    {
      "indent": 6,
      "text": "2 (Cached Distrust): the last known effective trust verdict was Configured or Cached Distrust.",
      "ja": "2（キャッシュされた不信）：最後に確認された有効な信頼の判定は、構成済みまたはキャッシュされた不信です。"
    },
    {
      "indent": 6,
      "text": "3 (Configured Trust): trustworthy based upon an external ceremony or configuration.",
      "ja": "3（構成された信頼）：外部の儀式または構成に基づいて信頼できる。"
    },
    {
      "indent": 6,
      "text": "4 (Configured Distrust): not trustworthy based upon an external ceremony or configuration.",
      "ja": "4（不信任の構成）：外部の儀式または構成に基づいて信頼できない。"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are differentiated in 3 groups:",
      "ja": "信頼判定は3つのグループに分類されます。"
    },
    {
      "indent": 3,
      "text": "o Configured verdicts are used to announce explicit trust verdicts a node has based on any external trust bootstrap or predefined relations a node has formed with a given certificate.",
      "ja": "o 構成された判定は、ノードが特定の証明書で形成した外部の信頼ブートストラップまたは事前定義の関係に基づいてノードが持っている明示的な信頼判定を通知するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o Cached verdicts are used to retain the last known trust state in case all nodes with configured verdicts about a given certificate have been disconnected or turned off.",
      "ja": "o キャッシュされた判定は、特定の証明書について判定が設定されたすべてのノードが切断またはオフにされた場合に、最後の既知の信頼状態を保持するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o The Neutral verdict is used to announce a new node intending to join the network, so a final verdict for it can be found.",
      "ja": "o ニュートラル判定は、ネットワークに参加する予定の新しいノードを通知するために使用されるため、その最終判定を見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The current effective trust verdict for any certificate is defined as the one with the highest priority within the set of trust verdicts announced for the certificate in the DNCP network. A node MUST be trusted for participating in the DNCP network if and only if the current effective trust verdict for its own certificate or any one in its certificate hierarchy is (Cached or Configured) Trust, and none of the certificates in its hierarchy have an effective trust verdict of (Cached or Configured) Distrust. In case a node has a configured verdict, which is different from the current effective trust verdict for a certificate, the current effective trust verdict takes precedence in deciding trustworthiness. Despite that, the node still retains and announces its configured verdict.",
      "ja": "証明書の現在の有効な信頼判定は、DNCPネットワークで証明書に対してアナウンスされた信頼判定のセット内で最高の優先順位を持つものとして定義されます。ノードは、自身の証明書またはその証明書階層内のいずれかに対する現在の有効な信頼判定が（キャッシュまたは構成）信頼であり、その階層内のどの証明書も有効でない場合に限り、DNCPネットワークに参加することを信頼する必要があります（キャッシュまたは構成済み）不信の信頼判定。証明書の現在の有効な信頼の判定とは異なる設定された判定がノードにある場合、現在の有効な信頼の判定が信頼性の決定に優先します。それにもかかわらず、ノードはまだ保持し、構成済みの判定をアナウンスします。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Trust Cache",
      "section_title": true,
      "ja": "8.3.2. 信頼キャッシュ"
    },
    {
      "indent": 3,
      "text": "Each node SHOULD maintain a trust cache containing the current effective trust verdicts for all certificates currently announced in the DNCP network. This cache is used as a backup of the last known state in case there is no node announcing a configured verdict for a known certificate. It SHOULD be saved to a non-volatile memory at reasonable time intervals to survive a reboot or power outage.",
      "ja": "各ノードは、DNCPネットワークで現在発表されているすべての証明書の現在の有効な信頼判定を含む信頼キャッシュを維持する必要があります（SHOULD）。このキャッシュは、既知の証明書に対して構成された判定を通知するノードがない場合に備えて、最後の既知の状態のバックアップとして使用されます。再起動または停電に耐えるために、妥当な時間間隔で不揮発性メモリに保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Every time a node (re)joins the network or detects the change of an effective trust verdict for any certificate, it will synchronize its cache, i.e., store new effective trust verdicts overwriting any previously cached verdicts. Configured verdicts are stored in the cache as their respective cached counterparts. Neutral verdicts are never stored and do not override existing cached verdicts.",
      "ja": "ノードがネットワークに（再）参加するか、証明書の有効な信頼判定の変更を検出するたびに、ノードはキャッシュを同期します。つまり、以前にキャッシュされた判定を上書きして新しい有効な信頼判定を保存します。設定された判定は、それぞれのキャッシュされた対応物としてキャッシュに保存されます。ニュートラルな判定は決して保存されず、既存のキャッシュされた判定を上書きしません。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Announcement of Verdicts",
      "section_title": true,
      "ja": "8.3.3. 評決の発表"
    },
    {
      "indent": 3,
      "text": "A node SHOULD always announce any configured verdicts it has established by itself, and it MUST do so if announcing the configured verdict leads to a change in the current effective trust verdict for the respective certificate. In absence of configured verdicts, it MUST announce Cached Trust verdicts it has stored in its trust cache, if one of the following conditions applies:",
      "ja": "ノードはそれ自体が確立した構成済みの判定を常に通知する必要があり（SHOULD）、構成済みの判定を発表すると、それぞれの証明書の現在の有効な信頼判定が変更される場合は、必ず通知する必要があります。構成された判定がない場合、次のいずれかの条件が当てはまる場合、信頼キャッシュに格納されているキャッシュされた信頼判定を通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The stored trust verdict is Cached Trust, and the current effective trust verdict for the certificate is Neutral or does not exist.",
      "ja": "o 格納されている信頼判定はキャッシュされた信頼であり、証明書の現在有効な信頼判定は中立であるか、存在しません。"
    },
    {
      "indent": 3,
      "text": "o The stored trust verdict is Cached Distrust, and the current effective trust verdict for the certificate is Cached Trust.",
      "ja": "o 保存されている信頼の判定はCached Distrustであり、証明書の現在有効な信頼の判定はCached Trustです。"
    },
    {
      "indent": 3,
      "text": "A node rechecks these conditions whenever it detects changes of announced trust verdicts anywhere in the network.",
      "ja": "ノードは、ネットワーク内のどこかにアナウンスされた信頼判定の変更を検出するたびに、これらの条件を再チェックします。"
    },
    {
      "indent": 3,
      "text": "Upon encountering a node with a hierarchy of certificates for which there is no effective trust verdict, a node adds a Neutral Trust-Verdict TLV to its node data for all certificates found in the hierarchy and publishes it until an effective trust verdict different from Neutral can be found for any of the certificates, or a reasonable amount of time (10 minutes is suggested) with no reaction and no further authentication attempts has passed. Such trust verdicts SHOULD also be limited in rate and number to prevent denial-of-service attacks.",
      "ja": "有効な信頼判定がない証明書の階層を持つノードに遭遇すると、ノードはニュートラルTrust-Verdict TLVを階層内で見つかったすべての証明書のノードデータに追加し、ニュートラルとは異なる有効な信頼判定ができるまでそれを公開します。証明書のいずれか、または妥当な時間（10分を推奨）で検出され、反応がなく、認証の試行がまったく経過していません。そのような信頼判定は、サービス拒否攻撃を防ぐために、レートと数を制限する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are announced using Trust-Verdict TLVs:",
      "ja": "信頼判定は、Trust-Verdict TLVを使用して発表されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type: Trust-Verdict (10)    |        Length: > 36           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Verdict    |                 (reserved)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                                                               |\n|                                                               |\n|                      SHA-256 Fingerprint                      |\n|                                                               |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Common Name                          |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Verdict represents the numerical index of the trust verdict.",
      "ja": "評決は、信頼評決の数値インデックスを表します。"
    },
    {
      "indent": 6,
      "text": "(reserved) is reserved for future additions and MUST be set to 0 when creating TLVs and ignored when parsing them.",
      "ja": "（予約）は将来の追加のために予約されており、TLVの作成時には0に設定し、解析時には無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "SHA-256 Fingerprint contains the SHA-256 [RFC6234] hash value of the certificate in DER format.",
      "ja": "SHA-256 Fingerprintには、DER形式の証明書のSHA-256 [RFC6234]ハッシュ値が含まれています。"
    },
    {
      "indent": 6,
      "text": "Common name contains the variable-length (1-64 bytes) common name of the certificate.",
      "ja": "共通名には、証明書の可変長（1から64バイト）の共通名が含まれます。"
    },
    {
      "indent": 0,
      "text": "8.3.4. Bootstrap Ceremonies",
      "section_title": true,
      "ja": "8.3.4. ブートストラップ式"
    },
    {
      "indent": 3,
      "text": "The following non-exhaustive list of methods describes possible ways to establish trust relationships between DNCP nodes and node certificates. Trust establishment is a two-way process in which the existing network must trust the newly added node, and the newly added node must trust at least one of its peer nodes. It is therefore necessary that both the newly added node and an already trusted node perform such a ceremony to successfully introduce a node into the DNCP network. In all cases, an administrator MUST be provided with external means to identify the node belonging to a certificate based on its fingerprint and a meaningful common name.",
      "ja": "次の網羅的ではない方法のリストは、DNCPノードとノード証明書の間の信頼関係を確立するための可能な方法を説明しています。信頼の確立は、既存のネットワークが新しく追加されたノードを信頼し、新しく追加されたノードが少なくとも1つのピアノードを信頼する必要がある双方向プロセスです。したがって、ノードをDNCPネットワークに正常に導入するには、新しく追加されたノードとすでに信頼されているノードの両方がこのような式を実行する必要があります。すべての場合において、管理者には、フィンガープリントと意味のある共通名に基づいて、証明書に属するノードを識別するための外部手段を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.4.1. Trust by Identification",
      "section_title": true,
      "ja": "8.3.4.1. 識別による信頼"
    },
    {
      "indent": 3,
      "text": "A node implementing certificate-based trust MUST provide an interface to retrieve the current set of effective trust verdicts, fingerprints, and names of all certificates currently known and set configured verdicts to be announced. Alternatively, it MAY provide a companion DNCP node or application with these capabilities with which it has a pre-established trust relationship.",
      "ja": "証明書ベースの信頼を実装するノードは、有効な信頼判定の現在のセット、フィンガープリント、および現在知られているすべての証明書の名前と、アナウンスされる設定された判定を取得するためのインターフェイスを提供する必要があります。あるいは、これは、DNCPノードまたはアプリケーションに、事前に確立された信頼関係を持つこれらの機能を提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "8.3.4.2. Preconfigured Trust",
      "section_title": true,
      "ja": "8.3.4.2. 事前構成された信頼"
    },
    {
      "indent": 3,
      "text": "A node MAY be preconfigured to trust a certain set of node or CA certificates. However, such trust relationships MUST NOT result in unwanted or unrelated trust for nodes not intended to be run inside the same network (e.g., all other devices by the same manufacturer).",
      "ja": "ノードは、特定のノードまたはCA証明書のセットを信頼するように事前構成できます。ただし、そのような信頼関係は、同じネットワーク内で実行されるように意図されていないノード（たとえば、同じ製造元による他のすべてのデバイス）に不要または無関係な信頼を生じてはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "8.3.4.3. Trust on Button Press",
      "section_title": true,
      "ja": "8.3.4.3. ボタンを押すと信頼"
    },
    {
      "indent": 3,
      "text": "A node MAY provide a physical or virtual interface to put one or more of its internal network interfaces temporarily into a mode in which it trusts the certificate of the first DNCP node it can successfully establish a connection with.",
      "ja": "ノードは、1つ以上の内部ネットワークインターフェイスを一時的に、接続を正常に確立できる最初のDNCPノードの証明書を信頼するモードにする物理または仮想インターフェイスを提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "8.3.4.4. Trust on First Use",
      "section_title": true,
      "ja": "8.3.4.4. 初回使用時の信頼"
    },
    {
      "indent": 3,
      "text": "A node that is not associated with any other DNCP node MAY trust the certificate of the first DNCP node it can successfully establish a connection with. This method MUST NOT be used when the node has already associated with any other DNCP node.",
      "ja": "他のDNCPノードに関連付けられていないノードは、接続を正常に確立できる最初のDNCPノードの証明書を信頼してもよい（MAY）。このメソッドは、ノードが他のDNCPノードにすでに関連付けられている場合は使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "9. DNCP Profile-Specific Definitions",
      "section_title": true,
      "ja": "9. DNCPプロファイル固有の定義"
    },
    {
      "indent": 3,
      "text": "Each DNCP profile MUST specify the following aspects:",
      "ja": "各DNCPプロファイルは、次の側面を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Unicast and optionally a multicast transport protocol(s) to be used. If a multicast-based node and status discovery is desired, a datagram-based transport supporting multicast has to be available.",
      "ja": "o 使用するユニキャストおよびオプションのマルチキャストトランスポートプロトコル。マルチキャストベースのノードとステータスの検出が必要な場合は、マルチキャストをサポートするデータグラムベースのトランスポートを使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "o How the chosen transport(s) is secured: Not at all, optionally, or always with the TLS scheme defined here using one or more of the methods, or with something else. If the links with DNCP nodes can be sufficiently secured or isolated, it is possible to run DNCP in a secure manner without using any form of authentication or encryption.",
      "ja": "o 選択したトランスポートのセキュリティ保護方法：1つ以上のメソッドを使用してここで定義されたTLSスキーム、または何か他のものを使用して、まったく、オプションで、または常に。 DNCPノードとのリンクを十分に保護または分離できる場合は、認証や暗号化を一切使用せずに、DNCPを安全な方法で実行できます。"
    },
    {
      "indent": 3,
      "text": "o Transport protocols' parameters such as port numbers to be used or multicast addresses to be used. Unicast, multicast, and secure unicast may each require different parameters, if applicable.",
      "ja": "o 使用するポート番号や使用するマルチキャストアドレスなどのトランスポートプロトコルのパラメーター。ユニキャスト、マルチキャスト、およびセキュアユニキャストは、該当する場合、それぞれ異なるパラメーターを必要とする場合があります。"
    },
    {
      "indent": 3,
      "text": "o When receiving TLVs, what sort of TLVs are ignored in addition -- as specified in Section 4.4 -- e.g., for security reasons. While the security of the node data published within the Node State TLVs is already ensured by the base specification (if secure unicast transport is used, Node State TLVs are sent only via unicast as multicast ones are ignored on receipt), if a profile adds TLVs that are sent outside the node data, a profile should indicate whether or not those TLVs should be ignored if they are received via multicast or non-secured unicast. A DNCP profile may define the following DNCP TLVs to be safely ignored:",
      "ja": "o TLVを受信するとき、セクション4.4で指定されているように、さらに無視されるTLVの種類（セキュリティ上の理由など）。ノードステートTLV内で公開されたノードデータのセキュリティは基本仕様によってすでに確保されています（セキュアユニキャストトランスポートが使用されている場合、ノードステートTLVはユニキャスト経由でのみ送信されます。マルチキャストは受信時に無視されるため）、プロファイルがTLVを追加した場合ノードデータの外部で送信される場合、プロファイルは、それらのTLVがマルチキャストまたは非セキュアユニキャスト経由で受信された場合、それらのTLVを無視するかどうかを示す必要があります。 DNCPプロファイルは、安全に無視される次のDNCP TLVを定義する場合があります。"
    },
    {
      "indent": 6,
      "text": "* Anything received over multicast, except Node Endpoint TLV (Section 7.2.1) and Network State TLV (Section 7.2.2).",
      "ja": "* ノードエンドポイントTLV（セクション7.2.1）とネットワーク状態TLV（セクション7.2.2）を除いて、マルチキャストで受信したもの。"
    },
    {
      "indent": 6,
      "text": "* Any TLVs received over unreliable unicast or multicast at a rate that is that is too high; Trickle will ensure eventual convergence given the rate slows down at some point.",
      "ja": "* 高すぎるレートで信頼できないユニキャストまたはマルチキャストを介して受信されたTLV。トリクルは、ある時点で速度が低下することを考慮して、最終的な収束を保証します。"
    },
    {
      "indent": 3,
      "text": "o How to deal with node identifier collision as described in Section 4.4. Main options are either for one or both nodes to assign new node identifiers to themselves or to notify someone about a fatal error condition in the DNCP network.",
      "ja": "o セクション4.4で説明されているノード識別子の衝突に対処する方法。主なオプションは、一方または両方のノードが新しいノード識別子を自分に割り当てるか、DNCPネットワークの致命的なエラー状態について誰かに通知することです。"
    },
    {
      "indent": 3,
      "text": "o Imin, Imax, and k ranges to be suggested for implementations to be used in the Trickle algorithm. The Trickle algorithm does not require these to be the same across all implementations for it to work, but similar orders of magnitude help implementations of a DNCP profile to behave more consistently and to facilitate estimation of lower and upper bounds for convergence behavior of the network.",
      "ja": "o トリクルアルゴリズムで使用される実装に推奨されるImin、Imax、kの範囲。トリクルアルゴリズムでは、すべての実装でこれらが同じである必要はありませんが、DNCPプロファイルの実装がより一貫して動作し、ネットワークの収束動作の下限と上限の推定を容易にするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "o Hash function H(x) to be used, and how many bits of the output are actually used. The chosen hash function is used to handle both hashing of node data and producing network state hash, which is a hash of node data hashes. SHA-256 defined in [RFC6234] is the recommended default choice, but a non-cryptographic hash function could be used as well. If there is a hash collision in the network state hash, the network will effectively be partitioned to partitions that believe they are up to date but are actually no longer converged. The network will converge either when some node data anywhere in the network changes or when conflicting Node State TLVs get transmitted across the partition (either caused by \"Trickle-Driven Status Updates\" (Section 4.3) or as part of the \"Processing of Received TLVs\" (Section 4.4)). If a node publishes",
      "ja": "o 使用するハッシュ関数H（x）、および実際に使用される出力のビット数。選択されたハッシュ関数は、ノードデータのハッシュと、ノードデータハッシュのハッシュであるネットワーク状態ハッシュの生成の両方を処理するために使用されます。 [RFC6234]で定義されているSHA-256が推奨されるデフォルトの選択ですが、非暗号化ハッシュ関数も使用できます。ネットワーク状態のハッシュにハッシュの衝突がある場合、ネットワークは事実上、最新であるが実際には収束していないと思われるパーティションに分割されます。ネットワークは、ネットワーク内のいずれかのノードデータが変更されたとき、または競合するノード状態TLVがパーティション全体に送信されたとき（「トリクル駆動型ステータス更新」（セクション4.3）が原因）、または「受信TLVの処理の一部として」収束します。 \"（セクション4.4））。ノードが公開する場合"
    },
    {
      "indent": 6,
      "text": "node data with a hash that collides with any previously published node data, the update may not be (fully) propagated, and the old version of node data may be used instead.",
      "ja": "以前に発行されたノードデータと衝突するハッシュを持つノードデータ、更新が（完全に）伝達されない可能性があり、代わりに古いバージョンのノードデータが使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "o DNCP_NODE_IDENTIFIER_LENGTH: The fixed length of a node identifier (in bytes).",
      "ja": "o DNCP_NODE_IDENTIFIER_LENGTH：ノード識別子の固定長（バイト単位）。"
    },
    {
      "indent": 3,
      "text": "o Whether to send keep-alives, and if so, whether it is per-endpoint (requires multicast transport) or per-peer. Keep-alive also has associated parameters:",
      "ja": "o キープアライブを送信するかどうか。送信する場合は、エンドポイントごと（マルチキャストトランスポートが必要）か、ピアごとか。キープアライブには、関連するパラメーターもあります。"
    },
    {
      "indent": 6,
      "text": "* DNCP_KEEPALIVE_INTERVAL: How often keep-alives are to be sent by default (if enabled).",
      "ja": "* DNCP_KEEPALIVE_INTERVAL：デフォルトでキープアライブが送信される頻度（有効な場合）。"
    },
    {
      "indent": 6,
      "text": "* DNCP_KEEPALIVE_MULTIPLIER: How many times the DNCP_KEEPALIVE_INTERVAL (or peer-supplied keep-alive interval value) node may not be heard from to be considered still valid. This is just a default used in absence of any other configuration information or particular per-endpoint configuration.",
      "ja": "* DNCP_KEEPALIVE_MULTIPLIER：DNCP_KEEPALIVE_INTERVAL（またはピア提供のキープアライブインターバル値）ノードが、まだ有効であると見なされるように聞こえない回数。これは、他の構成情報または特定のエンドポイントごとの構成がない場合に使用されるデフォルトです。"
    },
    {
      "indent": 3,
      "text": "o Whether to support dense multicast-enabled link optimization (Section 6.2) or not.",
      "ja": "o 高密度マルチキャスト対応リンクの最適化（セクション6.2）をサポートするかどうか。"
    },
    {
      "indent": 3,
      "text": "For some guidance on choosing transport and security options, please see Appendix B.",
      "ja": "トランスポートおよびセキュリティオプションの選択に関するガイダンスについては、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "DNCP-based protocols may use multicast to indicate DNCP state changes and for keep-alive purposes. However, no actual published data TLVs will be sent across that channel. Therefore, an attacker may only learn hash values of the state within DNCP and may be able to trigger unicast synchronization attempts between nodes on a local link this way. A DNCP node MUST therefore rate limit its reactions to multicast packets.",
      "ja": "DNCPベースのプロトコルは、DNCP状態の変化を示し、キープアライブの目的でマルチキャストを使用できます。ただし、実際に公開されたデータTLVはそのチャネルを介して送信されません。したがって、攻撃者はDNCP内の状態のハッシュ値しか学習できず、この方法でローカルリンク上のノード間でユニキャスト同期の試行をトリガーできる可能性があります。したがって、DNCPノードは、マルチキャストパケットに対する反応をレート制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using DNCP to bootstrap a network, PKI-based solutions may have issues when validating certificates due to potentially unavailable accurate time or due to the inability to use the network to either check Certificate Revocation Lists or perform online validation.",
      "ja": "DNCPを使用してネットワークをブートストラップする場合、PKIベースのソリューションでは、正確な時刻が利用できない可能性があるため、またはネットワークを使用して証明書失効リストをチェックしたり、オンライン検証を実行できなかったりするため、証明書を検証するときに問題が発生することがあります。"
    },
    {
      "indent": 3,
      "text": "The Certificate-based trust consensus mechanism defined in this document allows for a consenting revocation; however, in case of a compromised device, the trust cache may be poisoned before the actual revocation happens allowing the distrusted device to rejoin the network using a different identity. Stopping such an attack might require physical intervention and flushing of the trust caches.",
      "ja": "このドキュメントで定義されている証明書ベースの信頼合意メカニズムは、同意の取り消しを可能にします。ただし、デバイスが侵害された場合、実際の失効が発生する前に信頼キャッシュが汚染され、信頼されていないデバイスが別のIDを使用してネットワークに再度参加できるようになります。このような攻撃を阻止するには、物理​​的な介入と信頼キャッシュのフラッシュが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has set up a registry for the (decimal 16-bit) \"DNCP TLV Types\" under \"Distributed Node Consensus Protocol (DNCP)\". The registration procedure is Standards Action [RFC5226]. The initial contents are:",
      "ja": "IANAは、「分散ノードコンセンサスプロトコル（DNCP）」の下に（10進数の16ビット）「DNCP TLVタイプ」のレジストリを設定しています。登録手続きは、Standards Action [RFC5226]です。初期の内容は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "0: Reserved",
      "ja": "0：予約済み"
    },
    {
      "indent": 6,
      "text": "1: Request network state",
      "ja": "1：ネットワーク状態を要求する"
    },
    {
      "indent": 6,
      "text": "2: Request node state",
      "ja": "2：リクエストノードの状態"
    },
    {
      "indent": 6,
      "text": "3: Node endpoint",
      "ja": "3：ノードのエンドポイント"
    },
    {
      "indent": 6,
      "text": "4: Network state",
      "ja": "4：ネットワークの状態"
    },
    {
      "indent": 6,
      "text": "5: Node state",
      "ja": "５： ので ｓたて"
    },
    {
      "indent": 6,
      "text": "6: Reserved for future use (was: Custom)",
      "ja": "6：将来の使用のために予約済み（以前はカスタム）"
    },
    {
      "indent": 6,
      "text": "7: Reserved for future use (was: Fragment count)",
      "ja": "7：将来の使用のために予約済み（以前はフラグメント数）"
    },
    {
      "indent": 6,
      "text": "8: Peer",
      "ja": "8：ピア"
    },
    {
      "indent": 6,
      "text": "9: Keep-alive interval",
      "ja": "9：キープアライブ間隔"
    },
    {
      "indent": 6,
      "text": "10: Trust-Verdict",
      "ja": "10：信頼判定"
    },
    {
      "indent": 6,
      "text": "11-31: Unassigned",
      "ja": "11-31：未割り当て"
    },
    {
      "indent": 6,
      "text": "32-511: Reserved for per-DNCP profile use",
      "ja": "32-511：DNCPプロファイルごとの使用のために予約済み"
    },
    {
      "indent": 6,
      "text": "512-767: Unassigned",
      "ja": "512-767：未割り当て"
    },
    {
      "indent": 6,
      "text": "768-1023: Reserved for Private Use [RFC5226]",
      "ja": "768-1023：私的使用のために予約済み[RFC5226]"
    },
    {
      "indent": 6,
      "text": "1024-65535: Reserved for future use",
      "ja": "1024-65535：将来の使用のために予約済み"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org / info / rfc5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC6206] Levis, P., Clausen, T., Hui, J., Gnawali, O., and J. Ko, \"The Trickle Algorithm\", RFC 6206, DOI 10.17487/RFC6206, March 2011, <http://www.rfc-editor.org/info/rfc6206>.",
      "ja": "[RFC6206] Levis、P.、Clauseen、T.、Hui、J.、Gnawali、O。、およびJ. Ko、「The Trickle Algorithm」、RFC 6206、DOI 10.17487 / RFC6206、2011年3月、<http：// www.rfc-editor.org/info/rfc6206>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<http：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3315] Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3315, DOI 10.17487/RFC3315, July 2003, <http://www.rfc-editor.org/info/rfc3315>.",
      "ja": "[RFC3315] Droms、R.、Ed。、Bound、J.、Volz、B.、Lemon、T.、Perkins、C.、and M. Carney、 \"Dynamic Host Configuration Protocol for IPv6（DHCPv6）\"、RFC 3315 、DOI 10.17487 / RFC3315、2003年7月、<http://www.rfc-editor.org/info/rfc3315>。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, DOI 10.17487/RFC3493, February 2003, <http://www.rfc-editor.org/info/rfc3493>.",
      "ja": "[RFC3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J.、and W. Stevens、 \"Basic Socket Interface Extensions for IPv6\"、RFC 3493、DOI 10.17487 / RFC3493、February 2003、<http ：//www.rfc-editor.org/info/rfc3493>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC7435] Dukhovni, V., \"Opportunistic Security: Some Protection Most of the Time\", RFC 7435, DOI 10.17487/RFC7435, December 2014, <http://www.rfc-editor.org/info/rfc7435>.",
      "ja": "[RFC7435] Dukhovni、V。、「日和見セキュリティ：ほとんどの場合はある程度の保護」、RFC 7435、DOI 10.17487 / RFC7435、2014年12月、<http://www.rfc-editor.org/info/rfc7435>。"
    },
    {
      "indent": 3,
      "text": "[RFC7596] Cui, Y., Sun, Q., Boucadair, M., Tsou, T., Lee, Y., and I. Farrer, \"Lightweight 4over6: An Extension to the Dual-Stack Lite Architecture\", RFC 7596, DOI 10.17487/RFC7596, July 2015, <http://www.rfc-editor.org/info/rfc7596>.",
      "ja": "[RFC7596] Cui、Y.、Sun、Q.、Boucadair、M.、Tsou、T.、Lee、Y.、I。Farrer、「Lightweight 4over6：An Extension to the Dual-Stack Lite Architecture」、RFC 7596 、DOI 10.17487 / RFC7596、2015年7月、<http://www.rfc-editor.org/info/rfc7596>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Alternative Modes of Operation",
      "section_title": true,
      "ja": "付録A.代替操作モード"
    },
    {
      "indent": 3,
      "text": "Beyond what is described in the main text, the protocol allows for other uses. These are provided as examples.",
      "ja": "本文で説明されているものを超えて、プロトコルは他の用途を可能にします。これらは例として提供されています。"
    },
    {
      "indent": 0,
      "text": "A.1. Read-Only Operation",
      "section_title": true,
      "ja": "A.1. 読み取り専用操作"
    },
    {
      "indent": 3,
      "text": "If a node uses just a single endpoint and does not need to publish any TLVs, full DNCP node functionality is not required. Such a limited node can acquire and maintain a view of the TLV space by implementing the processing logic as specified in Section 4.4. Such node would not need Trickle, peer-maintenance, or even keep-alives at all, as the DNCP nodes' use of it would guarantee eventual receipt of network state hashes, and synchronization of node data, even in the presence of unreliable transport.",
      "ja": "ノードが単一のエンドポイントのみを使用し、TLVを公開する必要がない場合、DNCPノードの完全な機能は必要ありません。このような制限されたノードは、セクション4.4で指定された処理ロジックを実装することにより、TLVスペースのビューを取得して維持できます。 DNCPノードがノードを使用すると、信頼性の低いトランスポートが存在する場合でも、ネットワーク状態のハッシュの最終的な受信とノードデータの同期が保証されるため、このようなノードでは、トリクル、ピアメンテナンス、またはキープアライブはまったく必要ありません。"
    },
    {
      "indent": 0,
      "text": "A.2. Forwarding Operation",
      "section_title": true,
      "ja": "A.2. 転送操作"
    },
    {
      "indent": 3,
      "text": "If a node with a pair of endpoints does not need to publish any TLVs, it can detect (for example) nodes with the highest node identifier on each of the endpoints (if any). Any TLVs received from one of them would be forwarded verbatim as unicast to the other node with the highest node identifier.",
      "ja": "エンドポイントのペアを持つノードがTLVを公開する必要がない場合、（たとえば）各エンドポイント（存在する場合）で最も高いノード識別子を持つノードを検出できます。それらの1つから受信したTLVは、ユニキャストとしてそのまま、最高のノード識別子を持つ他のノードに転送されます。"
    },
    {
      "indent": 3,
      "text": "Any tinkering with the TLVs would remove guarantees of this scheme working; however, passive monitoring would obviously be fine. This type of simple forwarding cannot be chained, as it does not send anything proactively.",
      "ja": "TLVをいじくり回すと、このスキームが機能するという保証がなくなります。ただし、パッシブモニタリングは明らかに問題ありません。このタイプの単純な転送は、プロアクティブに何も送信しないため、連鎖させることはできません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. DNCP Profile Additional Guidance",
      "section_title": true,
      "ja": "付録B. DNCPプロファイルの追加のガイダンス"
    },
    {
      "indent": 3,
      "text": "This appendix explains implications of design choices made when specifying the DNCP profile to use particular transport or security options.",
      "ja": "この付録では、DNCPプロファイルを指定して特定のトランスポートオプションまたはセキュリティオプションを使用する場合の設計選択の影響について説明します。"
    },
    {
      "indent": 0,
      "text": "B.1. Unicast Transport -- UDP or TCP?",
      "section_title": true,
      "ja": "B.1. ユニキャストトランスポート-UDPまたはTCP？"
    },
    {
      "indent": 0,
      "text": " The node data published by a DNCP node is limited to 64 KB due to the 16-bit size of the length field of the TLV it is published within. Some transport choices may decrease this limit; if using, e.g., UDP datagrams for unicast transport, the upper bound of the node data size is whatever the nodes and the underlying network can pass to each other as DNCP does not define its own fragmentation scheme. A profile that chooses UDP has to be limited to small node data (e.g., somewhat smaller than IPv6 default MTU if using IPv6) or specify a minimum that all nodes have to support. Even then, if using non-link-local communications, there is some concern about what middleboxes do to fragmented packets. Therefore, the use of stream transport such as TCP is probably a good idea if either non-link-local communication is desired or fragmentation is expected to cause problems.",
      "ja": "DNCPノードが発行するTLVの長さフィールドのサイズは16ビットであるため、DNCPノードによって発行されるノードデータは64 KBに制限されます。トランスポートの選択によっては、この制限が減少する場合があります。たとえば、ユニキャストトランスポートにUDPデータグラムを使用する場合、ノードデータサイズの上限は、DNCPが独自のフラグメンテーションスキームを定義しないため、ノードと基盤となるネットワークが相互に渡すことができるものです。 UDPを選択するプロファイルは、小さいノードデータ（IPv6を使用する場合はIPv6のデフォルトMTUよりもやや小さいなど）に制限するか、すべてのノードがサポートする必要がある最小値を指定する必要があります。それでも、非リンクローカル通信を使用している場合、ミドルボックスがフラグメント化されたパケットに対して何を行うかについていくつかの懸念があります。したがって、非リンクローカル通信が必要な場合、または断片化が問題の原因になると予想される場合は、TCPなどのストリーム転送を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "TCP also provides some other facilities, such as a relatively long built-in keep-alive, which in conjunction with connection closes occurring from eventual failed retransmissions may be sufficient to avoid the use of in-protocol keep-alive defined in Section 6.1. Additionally, it is reliable, so there is no need for Trickle on such unicast connections.",
      "ja": "TCPは、比較的長い組み込みのキープアライブなどの他のいくつかの機能も提供します。これは、最終的な失敗した再送信から発生する接続のクローズと組み合わせて、セクション6.1で定義されたプロトコル内キープアライブの使用を回避するのに十分です。さらに、信頼性が高いため、このようなユニキャスト接続ではトリクルは必要ありません。"
    },
    {
      "indent": 3,
      "text": "The major downside of using TCP instead of UDP with DNCP-based profiles lies in the loss of control over the time at which TLVs are received; while unreliable UDP datagrams also have some delay, TLVs within reliable stream transport may be delayed significantly due to retransmissions. This is not a problem if no relative time-dependent information is stored within the TLVs in the DNCP-based protocol; for such a protocol, TCP is a reasonable choice for unicast transport if it is available.",
      "ja": "DNCPベースのプロファイルでUDPの代わりにTCPを使用することの主な欠点は、TLVが受信される時間の制御が失われることです。信頼性の低いUDPデータグラムにもある程度の遅延がありますが、信頼性の高いストリームトランスポート内のTLVは、再送信が原因で大幅に遅延する可能性があります。 DNCPベースのプロトコルのTLV内に相対的な時間依存情報が格納されていない場合、これは問題ではありません。このようなプロトコルの場合、ユニキャストトランスポートが利用可能であれば、TCPが合理的な選択肢です。"
    },
    {
      "indent": 0,
      "text": "B.2. (Optional) Multicast Transport",
      "section_title": true,
      "ja": "B.2. （オプション）マルチキャスト転送"
    },
    {
      "indent": 3,
      "text": "Multicast is needed for dynamic peer discovery and to trigger unicast exchanges; for that, unreliable datagram transport (=typically UDP) is the only transport option defined within this specification, although DNCP-based protocols may themselves define some other transport or peer discovery mechanism (e.g., based on Multicast DNS (mDNS) or DNS).",
      "ja": "マルチキャストは、動的なピア検出とユニキャスト交換をトリガーするために必要です。そのため、信頼性の低いデータグラム転送（=通常はUDP）がこの仕様で定義されている唯一の転送オプションですが、DNCPベースのプロトコル自体が他の転送またはピア検出メカニズム（たとえば、マルチキャストDNS（mDNS）またはDNSに基づく）を定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "If multicast is used, a well-known address should be specified and for, e.g., IPv6, respectively, the desired address scopes. In most cases, link-local and possibly site-local are useful scopes.",
      "ja": "マルチキャストを使用する場合は、既知のアドレスを指定する必要があり、たとえば、IPv6の場合はそれぞれ、目的のアドレススコープを指定する必要があります。ほとんどの場合、リンクローカルおよびおそらくサイトローカルが有効なスコープです。"
    },
    {
      "indent": 0,
      "text": "B.3. (Optional) Transport Security",
      "section_title": true,
      "ja": "B.3. （オプション）トランスポートセキュリティ"
    },
    {
      "indent": 3,
      "text": "In terms of provided security, DTLS and TLS are equivalent; they also consume a similar amount of state on the devices. While TLS is on top of a stream protocol, using DTLS also requires relatively long session caching within the DTLS layer to avoid expensive reauthentication/authorization steps if and when any state within the DNCP network changes or per-peer keep-alive (if enabled) is sent.",
      "ja": "提供されるセキュリティの点では、DTLSとTLSは同等です。また、デバイスで同様の量の状態を消費します。 TLSはストリームプロトコルの上にありますが、DNCPネットワーク内の状態が変化したり、ピアごとのキープアライブ（有効になっている場合）がある場合、DTLSを使用するには、DTLSレイヤー内で比較的長いセッションキャッシングが必要になるため、高額な再認証/承認手順を回避できます。送信されます。"
    },
    {
      "indent": 3,
      "text": "TLS implementations (at the time of writing the specification) seem more mature and available (as open source) than DTLS ones. This may be due to a long history of use with HTTPS.",
      "ja": "TLSの実装（仕様書を作成している時点）は、DTLSの実装よりも成熟していて（オープンソースとして）利用できるようです。これは、HTTPSでの使用の長い歴史が原因である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some libraries seem not to support multiplexing between insecure and secure communication on the same port, so specifying distinct ports for secured and unsecured communication may be beneficial.",
      "ja": "一部のライブラリは、同じポートでの安全でない通信と安全な通信の間の多重化をサポートしていないようです。そのため、安全な通信と安全でない通信に異なるポートを指定することは有益です。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Profile",
      "section_title": true,
      "ja": "付録C.プロファイルの例"
    },
    {
      "indent": 3,
      "text": "This is the DNCP profile of SHSP, an experimental (and for the purposes of this document fictional) home automation protocol. The protocol itself is used to make a key-value store published by each of the nodes available to all other nodes for distributed monitoring and control of a home infrastructure. It defines only one additional TLV type: a key=value TLV that contains a single key=value assignment for publication.",
      "ja": "これは、実験的な（このドキュメントでは架空の）ホームオートメーションプロトコルであるSHSPのDNCPプロファイルです。プロトコル自体は、ホームインフラストラクチャの分散型モニタリングと制御のために、他のすべてのノードが利用できる各ノードによって公開されたキーバリューストアを作成するために使用されます。追加のTLVタイプを1つだけ定義します。公開用の単一のkey = value割り当てを含むkey = value TLVです。"
    },
    {
      "indent": 3,
      "text": "o Unicast transport: IPv6 TCP on port EXAMPLE-P1 since only absolute timestamps are used within the key=value data and since it focuses primarily on Linux-based nodes that support both protocols as well. Connections from and to non-link-local addresses are ignored to avoid exposing this protocol outside the secure links.",
      "ja": "o ユニキャストトランスポート：絶対タイムスタンプのみがkey = valueデータ内で使用され、両方のプロトコルをサポートするLinuxベースのノードに主に焦点を当てているため、ポートEXAMPLE-P1上のIPv6 TCP。セキュアリンクの外部でこのプロトコルが公開されないようにするため、非リンクローカルアドレスとの接続は無視されます。"
    },
    {
      "indent": 3,
      "text": "o Multicast transport: IPv6 UDP on port EXAMPLE-P2 to link-local scoped multicast address ff02:EXAMPLE. At least one node per link in the home is assumed to facilitate node discovery without depending on any other infrastructure.",
      "ja": "o マルチキャストトランスポート：ポートEXAMPLE-P2上のIPv6 UDPをリンクローカルスコープのマルチキャストアドレスff02：EXAMPLEに。ホーム内のリンクごとに少なくとも1つのノードは、他のインフラストラクチャに依存することなくノードの検出を容易にするものと想定されています。"
    },
    {
      "indent": 3,
      "text": "o Security: None. It is to be used only on trusted links (WPA2-x wireless, physically secure wired links).",
      "ja": "o セキュリティ：なし。信頼できるリンク（WPA2-xワイヤレス、物理的に安全な有線リンク）でのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "o Additional TLVs to be ignored: None. No DNCP security is specified, and no new TLVs are defined outside of node data.",
      "ja": "o 無視される追加のTLV：なし。 DNCPセキュリティは指定されておらず、ノードデータの外部に新しいTLVは定義されていません。"
    },
    {
      "indent": 3,
      "text": "o Node identifier length (DNCP_NODE_IDENTIFIER_LENGTH): 32 bits that are randomly generated.",
      "ja": "o ノード識別子の長さ（DNCP_NODE_IDENTIFIER_LENGTH）：ランダムに生成される32ビット。"
    },
    {
      "indent": 3,
      "text": "o Node identifier collision handling: Pick new random node identifier.",
      "ja": "o ノード識別子の衝突処理：新しいランダムノード識別子を選択します。"
    },
    {
      "indent": 3,
      "text": "o Trickle parameters: Imin = 200 ms, Imax = 7, k = 1. It means at least one multicast per link in 25 seconds in stable state (0.2 * 2^7).",
      "ja": "o トリクルパラメータ：Imin = 200ミリ秒、Imax = 7、k =1。これは、安定状態（0.2 * 2 ^ 7）で25秒以内にリンクごとに少なくとも1つのマルチキャストを意味します。"
    },
    {
      "indent": 3,
      "text": "o Hash function H(x) + length: SHA-256, only 128 bits used. It's relatively fast, and 128 bits should be plenty to prevent random conflicts (64 bits would most likely be sufficient, too).",
      "ja": "o ハッシュ関数H（x）+長さ：SHA-256、128ビットのみ使用。これは比較的高速であり、ランダムな競合を防ぐには128ビットで十分です（64ビットでも十分です）。"
    },
    {
      "indent": 0,
      "text": " o No in-protocol keep-alives (Section 6.1); TCP keep-alive is to be used. In practice, TCP keep-alive is seldom encountered anyway, as changes in network state cause packets to be sent on the unicast connections, and those that fail sufficiently many retransmissions are dropped much before the keep-alive actually would fire.",
      "ja": "oプロトコル内のキープアライブはありません（セクション6.1）。 TCPキープアライブが使用されます。実際には、TCPキープアライブが発生することはめったにありません。ネットワークの状態が変化すると、パケットがユニキャスト接続で送信され、十分な数の再送信に失敗すると、キープアライブが実際に発動する前に、パケットがドロップされます。"
    },
    {
      "indent": 3,
      "text": "o No support for dense multicast-enabled link optimization (Section 6.2); SHSP is a simple protocol for a few nodes (network wide, not even to mention on a single link) and therefore would not provide any benefit.",
      "ja": "o 高密度マルチキャスト対応リンクの最適化はサポートされていません（セクション6.2）。 SHSPは、いくつかのノード（ネットワーク全体、単一のリンクについても言及されていない）向けの単純なプロトコルであるため、何のメリットもありません。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley, Juliusz Chroboczek, Jiazi Yi, Mikael Abrahamsson, Brian Carpenter, Thomas Clausen, DENG Hui, and Margaret Cullen for their contributions to the document.",
      "ja": "Ole Troan、Pierre Pfister、Mark Ba​​ugher、Mark Townsley、Juliusz Chroboczek、Jiazi Yi、Mikael Abrahamsson、Brian Carpenter、Thomas Clausen、DENG Hui、およびMargaret Cullenのドキュメントへの貢献に感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Kaiwen Jin and Xavier Bonnetain for their related research work.",
      "ja": "関連する研究を行ってくれたKaiwen JinとXavier Bonnetainに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Markus Stenberg Independent Helsinki 00930 Finland",
      "ja": "Markus Stenberg独立ヘルシンキ00930フィンランド"
    },
    {
      "indent": 3,
      "text": "Email: markus.stenberg@iki.fi",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Steven Barth Independent Halle 06114 Germany",
      "ja": "スティーブンバース独立ハレ06114ドイツ"
    },
    {
      "indent": 3,
      "text": "Email: cyrus@openwrt.org",
      "raw": true,
      "ja": ""
    }
  ]
}