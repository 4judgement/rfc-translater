{
  "title": {
    "text": "RFC 7541 - HPACK: Header Compression for HTTP/2",
    "ja": "RFC 7541 - HPACK：HTTP / 2のヘッダー圧縮"
  },
  "number": 7541,
  "created_at": "2020-08-15 15:39:11.932690+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Peon\nRequest for Comments: 7541                                   Google, Inc\nCategory: Standards Track                                     H. Ruellan\nISSN: 2070-1721                                                Canon CRF\n                                                                May 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "HPACK: Header Compression for HTTP/2",
      "ja": "HPACK：HTTP / 2のヘッダー圧縮"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.",
      "ja": "この仕様は、HTTPヘッダーフィールドを効率的に表すための圧縮形式であるHPACKを、HTTP / 2で使用されるように定義しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7541.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7541で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Overview ...................................................4\n   1.2. Conventions ................................................5\n   1.3. Terminology ................................................5\n2. Compression Process Overview ....................................6\n   2.1. Header List Ordering .......................................6\n   2.2. Encoding and Decoding Contexts .............................6\n   2.3. Indexing Tables ............................................6\n        2.3.1. Static Table ........................................6\n        2.3.2. Dynamic Table .......................................6\n        2.3.3. Index Address Space .................................7\n   2.4. Header Field Representation ................................8\n3. Header Block Decoding ...........................................8\n   3.1. Header Block Processing ....................................8\n   3.2. Header Field Representation Processing .....................9\n4. Dynamic Table Management ........................................9\n   4.1. Calculating Table Size ....................................10\n   4.2. Maximum Table Size ........................................10\n   4.3. Entry Eviction When Dynamic Table Size Changes ............11\n   4.4. Entry Eviction When Adding New Entries ....................11\n5. Primitive Type Representations .................................11\n   5.1. Integer Representation ....................................11\n   5.2. String Literal Representation .............................13\n6. Binary Format ..................................................14\n   6.1. Indexed Header Field Representation .......................14\n   6.2. Literal Header Field Representation .......................15\n        6.2.1. Literal Header Field with Incremental Indexing .....15\n        6.2.2. Literal Header Field without Indexing ..............16\n        6.2.3. Literal Header Field Never Indexed .................17\n   6.3. Dynamic Table Size Update .................................18\n7. Security Considerations ........................................19\n   7.1. Probing Dynamic Table State ...............................19\n        7.1.1. Applicability to HPACK and HTTP ....................20\n        7.1.2. Mitigation .........................................20\n        7.1.3. Never-Indexed Literals .............................21\n   7.2. Static Huffman Encoding ...................................22\n   7.3. Memory Consumption ........................................22\n   7.4. Implementation Limits .....................................23\n8. References .....................................................23\n   8.1. Normative References ......................................23\n   8.2. Informative References ....................................24\nAppendix A. Static Table Definition ...............................25\nAppendix B. Huffman Code ..........................................27",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix C. Examples ..............................................33\n  C.1. Integer Representation Examples ............................33\n    C.1.1. Example 1: Encoding 10 Using a 5-Bit Prefix ............33\n    C.1.2. Example 2: Encoding 1337 Using a 5-Bit Prefix ..........33\n    C.1.3. Example 3: Encoding 42 Starting at an Octet Boundary ...34\n  C.2. Header Field Representation Examples .......................34\n    C.2.1. Literal Header Field with Indexing .....................34\n    C.2.2. Literal Header Field without Indexing ..................35\n    C.2.3. Literal Header Field Never Indexed .....................36\n    C.2.4. Indexed Header Field ...................................37\n  C.3. Request Examples without Huffman Coding ....................37\n    C.3.1. First Request ..........................................37\n    C.3.2. Second Request .........................................38\n    C.3.3. Third Request ..........................................39\n  C.4. Request Examples with Huffman Coding .......................41\n    C.4.1. First Request ..........................................41\n    C.4.2. Second Request .........................................42\n    C.4.3. Third Request ..........................................43\n  C.5. Response Examples without Huffman Coding ...................45\n    C.5.1. First Response .........................................45\n    C.5.2. Second Response ........................................46\n    C.5.3. Third Response .........................................47\n  C.6. Response Examples with Huffman Coding ......................49\n    C.6.1. First Response .........................................49\n    C.6.2. Second Response ........................................51\n    C.6.3. Third Response .........................................52\nAcknowledgments ...................................................55\nAuthors' Addresses ................................................55",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.1 (see [RFC7230]), header fields are not compressed. As web pages have grown to require dozens to hundreds of requests, the redundant header fields in these requests unnecessarily consume bandwidth, measurably increasing latency.",
      "ja": "HTTP / 1.1（[RFC7230]を参照）では、ヘッダーフィールドは圧縮されません。 Webページが数十から数百のリクエストを必要とするように成長するにつれて、これらのリクエストの冗長なヘッダーフィールドが不必要に帯域幅を消費し、測定可能なレイテンシが増加します。"
    },
    {
      "indent": 3,
      "text": "SPDY [SPDY] initially addressed this redundancy by compressing header fields using the DEFLATE [DEFLATE] format, which proved very effective at efficiently representing the redundant header fields. However, that approach exposed a security risk as demonstrated by the CRIME (Compression Ratio Info-leak Made Easy) attack (see [CRIME]).",
      "ja": "SPDY [SPDY]は最初、DEFLATE [DEFLATE]フォーマットを使用してヘッダーフィールドを圧縮することでこの冗長性に対処しましたが、冗長ヘッダーフィールドを効率的に表すのに非常に効果的でした。ただし、CRIME（Compression Ratio Info-leak Made Easy）攻撃（[CRIME]を参照）で示されるように、このアプローチはセキュリティリスクを露呈しました。"
    },
    {
      "indent": 3,
      "text": "This specification defines HPACK, a new compressor that eliminates redundant header fields, limits vulnerability to known security attacks, and has a bounded memory requirement for use in constrained environments. Potential security concerns for HPACK are described in Section 7.",
      "ja": "この仕様は、HPACKを定義します。これは、冗長なヘッダーフィールドを排除し、既知のセキュリティ攻撃に対する脆弱性を制限し、制約のある環境で使用するための限られたメモリ要件を持つ新しいコンプレッサーです。 HPACKの潜在的なセキュリティ問題については、セクション7で説明します。"
    },
    {
      "indent": 3,
      "text": "The HPACK format is intentionally simple and inflexible. Both characteristics reduce the risk of interoperability or security issues due to implementation error. No extensibility mechanisms are defined; changes to the format are only possible by defining a complete replacement.",
      "ja": "HPACK形式は、意図的に単純で柔軟性に欠けています。どちらの特性も、実装エラーによる相互運用性やセキュリティの問題のリスクを軽減します。拡張メカニズムは定義されていません。形式の変更は、完全な置換を定義することによってのみ可能です。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview",
      "section_title": true,
      "ja": "1.1. 概観"
    },
    {
      "indent": 3,
      "text": "The format defined in this specification treats a list of header fields as an ordered collection of name-value pairs that can include duplicate pairs. Names and values are considered to be opaque sequences of octets, and the order of header fields is preserved after being compressed and decompressed.",
      "ja": "この仕様で定義されているフォーマットは、ヘッダーフィールドのリストを、重複するペアを含むことができる名前と値のペアの順序付けられたコレクションとして扱います。名前と値はオクテットの不透明なシーケンスであると見なされ、ヘッダーフィールドの順序は圧縮および解凍後も保持されます。"
    },
    {
      "indent": 3,
      "text": "Encoding is informed by header field tables that map header fields to indexed values. These header field tables can be incrementally updated as new header fields are encoded or decoded.",
      "ja": "エンコーディングは、ヘッダーフィールドをインデックス付きの値にマップするヘッダーフィールドテーブルによって通知されます。これらのヘッダーフィールドテーブルは、新しいヘッダーフィールドがエンコードまたはデコードされるときに、増分更新できます。"
    },
    {
      "indent": 3,
      "text": "In the encoded form, a header field is represented either literally or as a reference to a header field in one of the header field tables. Therefore, a list of header fields can be encoded using a mixture of references and literal values.",
      "ja": "エンコードされた形式では、ヘッダーフィールドは文字通り、またはヘッダーフィールドテーブルの1つにあるヘッダーフィールドへの参照として表されます。したがって、ヘッダーフィールドのリストは、参照とリテラル値を組み合わせて使用​​してエンコードできます。"
    },
    {
      "indent": 3,
      "text": "Literal values are either encoded directly or use a static Huffman code.",
      "ja": "リテラル値は直接エンコードされるか、静的ハフマンコードを使用します。"
    },
    {
      "indent": 3,
      "text": "The encoder is responsible for deciding which header fields to insert as new entries in the header field tables. The decoder executes the modifications to the header field tables prescribed by the encoder, reconstructing the list of header fields in the process. This enables decoders to remain simple and interoperate with a wide variety of encoders.",
      "ja": "エンコーダーは、ヘッダーフィールドテーブルに新しいエントリとして挿入するヘッダーフィールドを決定します。デコーダーは、エンコーダーによって指定されたヘッダーフィールドテーブルの変更を実行し、プロセス内のヘッダーフィールドのリストを再構築します。これにより、デコーダーはシンプルなままで、さまざまなエンコーダーと相互運用できます。"
    },
    {
      "indent": 3,
      "text": "Examples illustrating the use of these different mechanisms to represent header fields are available in Appendix C.",
      "ja": "これらのさまざまなメカニズムを使用してヘッダーフィールドを表す例は、付録Cにあります。"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions",
      "section_title": true,
      "ja": "1.2. 規約"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate.",
      "ja": "すべての数値はネットワークバイト順です。特に明記されていない限り、値は符号なしです。リテラル値は、10進数または16進数で適宜提供されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Terminology",
      "section_title": true,
      "ja": "1.3. 用語"
    },
    {
      "indent": 3,
      "text": "This specification uses the following terms:",
      "ja": "この仕様では、次の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Header Field: A name-value pair. Both the name and value are treated as opaque sequences of octets.",
      "ja": "ヘッダーフィールド：名前と値のペア。名前と値の両方がオクテットの不透明なシーケンスとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Dynamic Table: The dynamic table (see Section 2.3.2) is a table that associates stored header fields with index values. This table is dynamic and specific to an encoding or decoding context.",
      "ja": "動的テーブル：動的テーブル（セクション2.3.2を参照）は、格納されたヘッダーフィールドをインデックス値に関連付けるテーブルです。このテーブルは動的であり、エンコードまたはデコードのコンテキストに固有です。"
    },
    {
      "indent": 3,
      "text": "Static Table: The static table (see Section 2.3.1) is a table that statically associates header fields that occur frequently with index values. This table is ordered, read-only, always accessible, and it may be shared amongst all encoding or decoding contexts.",
      "ja": "静的テーブル：静的テーブル（セクション2.3.1を参照）は、頻繁に発生するヘッダーフィールドをインデックス値に静的に関連付けるテーブルです。このテーブルは順序付けされ、読み取り専用で、常にアクセス可能であり、すべてのエンコードまたはデコードコンテキスト間で共有できます。"
    },
    {
      "indent": 3,
      "text": "Header List: A header list is an ordered collection of header fields that are encoded jointly and can contain duplicate header fields. A complete list of header fields contained in an HTTP/2 header block is a header list.",
      "ja": "ヘッダーリスト：ヘッダーリストは、一緒にエンコードされるヘッダーフィールドの順序付けられたコレクションであり、重複するヘッダーフィールドを含めることができます。 HTTP / 2ヘッダーブロックに含まれるヘッダーフィールドの完全なリストは、ヘッダーリストです。"
    },
    {
      "indent": 3,
      "text": "Header Field Representation: A header field can be represented in encoded form either as a literal or as an index (see Section 2.4).",
      "ja": "ヘッダーフィールドの表現：ヘッダーフィールドは、リテラルまたはインデックスとしてエンコードされた形式で表現できます（セクション2.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Header Block: An ordered list of header field representations, which, when decoded, yields a complete header list.",
      "ja": "ヘッダーブロック：ヘッダーフィールド表現の順序付きリスト。デコードすると、完全なヘッダーリストが生成されます。"
    },
    {
      "indent": 0,
      "text": "2. Compression Process Overview",
      "section_title": true,
      "ja": "2. 圧縮プロセスの概要"
    },
    {
      "indent": 3,
      "text": "This specification does not describe a specific algorithm for an encoder. Instead, it defines precisely how a decoder is expected to operate, allowing encoders to produce any encoding that this definition permits.",
      "ja": "この仕様では、エンコーダの特定のアルゴリズムについては説明していません。代わりに、デコーダーがどのように動作することが期待されるかを正確に定義し、エンコーダーがこの定義で許可するエンコードを生成できるようにします。"
    },
    {
      "indent": 0,
      "text": "2.1. Header List Ordering",
      "section_title": true,
      "ja": "2.1. ヘッダーリストの順序"
    },
    {
      "indent": 3,
      "text": "HPACK preserves the ordering of header fields inside the header list. An encoder MUST order header field representations in the header block according to their ordering in the original header list. A decoder MUST order header fields in the decoded header list according to their ordering in the header block.",
      "ja": "HPACKは、ヘッダーリスト内のヘッダーフィールドの順序を保持します。エンコーダーは、元のヘッダーリストの順序に従って、ヘッダーブロックのヘッダーフィールド表現を順序付けする必要があります。デコーダーは、ヘッダーブロックの順序に従って、デコードされたヘッダーリストのヘッダーフィールドを順序付けする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Encoding and Decoding Contexts",
      "section_title": true,
      "ja": "2.2. コンテキストのエンコードとデコード"
    },
    {
      "indent": 3,
      "text": "To decompress header blocks, a decoder only needs to maintain a dynamic table (see Section 2.3.2) as a decoding context. No other dynamic state is needed.",
      "ja": "ヘッダーブロックを解凍するには、デコーダーは動的テーブル（セクション2.3.2を参照）をデコードコンテキストとして維持するだけで済みます。他の動的状態は必要ありません。"
    },
    {
      "indent": 3,
      "text": "When used for bidirectional communication, such as in HTTP, the encoding and decoding dynamic tables maintained by an endpoint are completely independent, i.e., the request and response dynamic tables are separate.",
      "ja": "HTTPなどの双方向通信に使用する場合、エンドポイントによって維持される動的テーブルのエンコードとデコードは完全に独立しています。つまり、要求と応答の動的テーブルは別々です。"
    },
    {
      "indent": 0,
      "text": "2.3. Indexing Tables",
      "section_title": true,
      "ja": "2.3. インデックステーブル"
    },
    {
      "indent": 3,
      "text": "HPACK uses two tables for associating header fields to indexes. The static table (see Section 2.3.1) is predefined and contains common header fields (most of them with an empty value). The dynamic table (see Section 2.3.2) is dynamic and can be used by the encoder to index header fields repeated in the encoded header lists.",
      "ja": "HPACKは2つのテーブルを使用して、ヘッダーフィールドをインデックスに関連付けます。静的テーブル（セクション2.3.1を参照）は事前定義されており、共通のヘッダーフィールド（ほとんどが空の値を持つ）が含まれています。動的テーブル（セクション2.3.2を参照）は動的であり、エンコードされたヘッダーリストで繰り返されるヘッダーフィールドにインデックスを付けるためにエンコーダーで使用できます。"
    },
    {
      "indent": 3,
      "text": "These two tables are combined into a single address space for defining index values (see Section 2.3.3).",
      "ja": "これら2つのテーブルは、インデックス値を定義するために1つのアドレス空間に結合されます（セクション2.3.3を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Static Table",
      "section_title": true,
      "ja": "2.3.1. 静的テーブル"
    },
    {
      "indent": 3,
      "text": "The static table consists of a predefined static list of header fields. Its entries are defined in Appendix A.",
      "ja": "静的テーブルは、ヘッダーフィールドの定義済み静的リストで構成されています。そのエントリは、付録Aで定義されています。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Dynamic Table",
      "section_title": true,
      "ja": "2.3.2. 動的テーブル"
    },
    {
      "indent": 3,
      "text": "The dynamic table consists of a list of header fields maintained in first-in, first-out order. The first and newest entry in a dynamic table is at the lowest index, and the oldest entry of a dynamic table is at the highest index.",
      "ja": "動的テーブルは、先入れ先出しの順序で維持されるヘッダーフィールドのリストで構成されます。動的テーブルの最初で最も新しいエントリは最低のインデックスにあり、動的テーブルの最も古いエントリは最高のインデックスにあります。"
    },
    {
      "indent": 3,
      "text": "The dynamic table is initially empty. Entries are added as each header block is decompressed.",
      "ja": "動的テーブルは最初は空です。各ヘッダーブロックが圧縮解除されると、エントリが追加されます。"
    },
    {
      "indent": 3,
      "text": "The dynamic table can contain duplicate entries (i.e., entries with the same name and same value). Therefore, duplicate entries MUST NOT be treated as an error by a decoder.",
      "ja": "動的テーブルには重複したエントリ（つまり、同じ名前と同じ値のエントリ）を含めることができます。したがって、重複したエントリはデコーダによってエラーとして扱われてはいけません。"
    },
    {
      "indent": 3,
      "text": "The encoder decides how to update the dynamic table and as such can control how much memory is used by the dynamic table. To limit the memory requirements of the decoder, the dynamic table size is strictly bounded (see Section 4.2).",
      "ja": "エンコーダーは動的テーブルを更新する方法を決定するため、動的テーブルが使用するメモリの量を制御できます。デコーダのメモリ要件を制限するために、動的テーブルのサイズは厳密に制限されています（セクション4.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The decoder updates the dynamic table during the processing of a list of header field representations (see Section 3.2).",
      "ja": "デコーダーは、ヘッダーフィールド表現のリストの処理中に動的テーブルを更新します（セクション3.2を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Index Address Space",
      "section_title": true,
      "ja": "2.3.3. インデックスアドレス空間"
    },
    {
      "indent": 3,
      "text": "The static table and the dynamic table are combined into a single index address space.",
      "ja": "静的テーブルと動的テーブルは、単一のインデックスアドレス空間に結合されます。"
    },
    {
      "indent": 3,
      "text": "Indices between 1 and the length of the static table (inclusive) refer to elements in the static table (see Section 2.3.1).",
      "ja": "1と静的テーブルの長さ（両端を含む）の間のインデックスは、静的テーブルの要素を参照します（セクション2.3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Indices strictly greater than the length of the static table refer to elements in the dynamic table (see Section 2.3.2). The length of the static table is subtracted to find the index into the dynamic table.",
      "ja": "静的テーブルの長さよりも厳密に大きいインデックスは、動的テーブルの要素を参照します（セクション2.3.2を参照）。静的テーブルの長さが減算されて、動的テーブルへのインデックスが検索されます。"
    },
    {
      "indent": 3,
      "text": "Indices strictly greater than the sum of the lengths of both tables MUST be treated as a decoding error.",
      "ja": "両方のテーブルの長さの合計よりも厳密に大きいインデックスは、デコードエラーとして処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "For a static table size of s and a dynamic table size of k, the following diagram shows the entire valid index address space.",
      "ja": "静的テーブルサイズがsで動的テーブルサイズがkの場合、次の図は有効なインデックスアドレス空間全体を示しています。"
    },
    {
      "indent": 11,
      "text": "<----------  Index Address Space ---------->\n<-- Static  Table -->  <-- Dynamic Table -->\n+---+-----------+---+  +---+-----------+---+\n| 1 |    ...    | s |  |s+1|    ...    |s+k|\n+---+-----------+---+  +---+-----------+---+\n                       ^                   |\n                       |                   V\n                Insertion Point      Dropping Point",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 1: Index Address Space",
      "ja": "図1：インデックスアドレススペース"
    },
    {
      "indent": 0,
      "text": "2.4. Header Field Representation",
      "section_title": true,
      "ja": "2.4. ヘッダーフィールドの表現"
    },
    {
      "indent": 3,
      "text": "An encoded header field can be represented either as an index or as a literal.",
      "ja": "エンコードされたヘッダーフィールドは、インデックスまたはリテラルとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "An indexed representation defines a header field as a reference to an entry in either the static table or the dynamic table (see Section 6.1).",
      "ja": "インデックス付き表現は、静的テーブルまたは動的テーブルのいずれかのエントリへの参照としてヘッダーフィールドを定義します（セクション6.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A literal representation defines a header field by specifying its name and value. The header field name can be represented literally or as a reference to an entry in either the static table or the dynamic table. The header field value is represented literally.",
      "ja": "リテラル表現は、名前と値を指定してヘッダーフィールドを定義します。ヘッダーフィールド名は、文字どおり、または静的テーブルまたは動的テーブルのエントリへの参照として表すことができます。ヘッダーフィールドの値は文字どおりに表されます。"
    },
    {
      "indent": 3,
      "text": "Three different literal representations are defined:",
      "ja": "3つの異なるリテラル表現が定義されています。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that adds the header field as a new entry at the beginning of the dynamic table (see Section 6.2.1).",
      "ja": "o 動的テーブルの先頭に新しいエントリとしてヘッダーフィールドを追加するリテラル表現（セクション6.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that does not add the header field to the dynamic table (see Section 6.2.2).",
      "ja": "o 動的テーブルにヘッダーフィールドを追加しないリテラル表現（セクション6.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that does not add the header field to the dynamic table, with the additional stipulation that this header field always use a literal representation, in particular when re-encoded by an intermediary (see Section 6.2.3). This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1.3 for more details).",
      "ja": "o 動的フィールドにヘッダーフィールドを追加しないリテラル表現。このヘッダーフィールドでは常にリテラル表現を使用するという追加規定があり、特に仲介者によって再エンコードされる場合（セクション6.2.3を参照）。この表現は、圧縮によってリスクにさらされないヘッダーフィールド値を保護することを目的としています（詳細については、セクション7.1.3を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The selection of one of these literal representations can be guided by security considerations, in order to protect sensitive header field values (see Section 7.1).",
      "ja": "機密性の高いヘッダーフィールド値を保護するために、これらのリテラル表現の1つを選択することは、セキュリティ上の考慮事項によってガイドできます（セクション7.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The literal representation of a header field name or of a header field value can encode the sequence of octets either directly or using a static Huffman code (see Section 5.2).",
      "ja": "ヘッダーフィールド名またはヘッダーフィールド値のリテラル表現は、直接または静的ハフマンコードを使用して、オクテットのシーケンスをエンコードできます（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "3. Header Block Decoding",
      "section_title": true,
      "ja": "3. ヘッダーブロックのデコード"
    },
    {
      "indent": 0,
      "text": "3.1. Header Block Processing",
      "section_title": true,
      "ja": "3.1. ヘッダーブロックの処理"
    },
    {
      "indent": 3,
      "text": "A decoder processes a header block sequentially to reconstruct the original header list.",
      "ja": "デコーダーはヘッダーブロックを順次処理して、元のヘッダーリストを再構築します。"
    },
    {
      "indent": 3,
      "text": "A header block is the concatenation of header field representations. The different possible header field representations are described in Section 6.",
      "ja": "ヘッダーブロックは、ヘッダーフィールド表現を連結したものです。可能なヘッダーフィールドのさまざまな表現については、セクション6で説明します。"
    },
    {
      "indent": 3,
      "text": "Once a header field is decoded and added to the reconstructed header list, the header field cannot be removed. A header field added to the header list can be safely passed to the application.",
      "ja": "ヘッダーフィールドがデコードされ、再構築されたヘッダーリストに追加されると、ヘッダーフィールドは削除できません。ヘッダーリストに追加されたヘッダーフィールドは、アプリケーションに安全に渡すことができます。"
    },
    {
      "indent": 3,
      "text": "By passing the resulting header fields to the application, a decoder can be implemented with minimal transitory memory commitment in addition to the memory required for the dynamic table.",
      "ja": "結果のヘッダーフィールドをアプリケーションに渡すことにより、動的テーブルに必要なメモリに加えて、最小限の一時的なメモリコミットメントでデコーダを実装できます。"
    },
    {
      "indent": 0,
      "text": "3.2. Header Field Representation Processing",
      "section_title": true,
      "ja": "3.2. ヘッダーフィールド表現処理"
    },
    {
      "indent": 3,
      "text": "The processing of a header block to obtain a header list is defined in this section. To ensure that the decoding will successfully produce a header list, a decoder MUST obey the following rules.",
      "ja": "ヘッダーリストを取得するためのヘッダーブロックの処理は、このセクションで定義されます。デコードがヘッダーリストを正常に生成することを保証するために、デコーダーは次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "All the header field representations contained in a header block are processed in the order in which they appear, as specified below. Details on the formatting of the various header field representations and some additional processing instructions are found in Section 6.",
      "ja": "ヘッダーブロックに含まれるすべてのヘッダーフィールド表現は、以下に示すように、出現順に処理されます。さまざまなヘッダーフィールド表現のフォーマットの詳細といくつかの追加の処理命令は、セクション6にあります。"
    },
    {
      "indent": 3,
      "text": "An _indexed representation_ entails the following actions:",
      "ja": "_インデックス付き表現_には、次のアクションが伴います。"
    },
    {
      "indent": 3,
      "text": "o The header field corresponding to the referenced entry in either the static table or dynamic table is appended to the decoded header list.",
      "ja": "o 静的テーブルまたは動的テーブルのいずれかの参照エントリに対応するヘッダーフィールドが、デコードされたヘッダーリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "A _literal representation_ that is _not added_ to the dynamic table entails the following action:",
      "ja": "動的テーブルに追加されていない_リテラル表現_は、次のアクションを伴います。"
    },
    {
      "indent": 3,
      "text": "o The header field is appended to the decoded header list.",
      "ja": "o ヘッダーフィールドは、デコードされたヘッダーリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "A _literal representation_ that is _added_ to the dynamic table entails the following actions:",
      "ja": "動的テーブルに追加された_リテラル表現_には、次のアクションが含まれます。"
    },
    {
      "indent": 3,
      "text": "o The header field is appended to the decoded header list.",
      "ja": "o ヘッダーフィールドは、デコードされたヘッダーリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "o The header field is inserted at the beginning of the dynamic table. This insertion could result in the eviction of previous entries in the dynamic table (see Section 4.4).",
      "ja": "o ヘッダーフィールドは、動的テーブルの先頭に挿入されます。この挿入により、動的テーブルの前のエントリが削除される可能性があります（セクション4.4を参照）。"
    },
    {
      "indent": 0,
      "text": "4. Dynamic Table Management",
      "section_title": true,
      "ja": "4. 動的テーブル管理"
    },
    {
      "indent": 3,
      "text": "To limit the memory requirements on the decoder side, the dynamic table is constrained in size.",
      "ja": "デコーダー側のメモリ要件を制限するために、動的テーブルはサイズに制約があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Calculating Table Size",
      "section_title": true,
      "ja": "4.1. テーブルサイズの計算"
    },
    {
      "indent": 3,
      "text": "The size of the dynamic table is the sum of the size of its entries.",
      "ja": "動的テーブルのサイズは、そのエントリのサイズの合計です。"
    },
    {
      "indent": 3,
      "text": "The size of an entry is the sum of its name's length in octets (as defined in Section 5.2), its value's length in octets, and 32.",
      "ja": "エントリのサイズは、オクテット単位の名前の長さ（セクション5.2で定義）、オクテット単位の値の長さ、および32の合計です。"
    },
    {
      "indent": 3,
      "text": "The size of an entry is calculated using the length of its name and value without any Huffman encoding applied.",
      "ja": "エントリのサイズは、名前と値の長さを使用して計算され、ハフマンエンコーディングは適用されません。"
    },
    {
      "indent": 6,
      "text": "Note: The additional 32 octets account for an estimated overhead associated with an entry. For example, an entry structure using two 64-bit pointers to reference the name and the value of the entry and two 64-bit integers for counting the number of references to the name and value would have 32 octets of overhead.",
      "ja": "注：追加の32オクテットは、エントリに関連する推定オーバーヘッドを考慮しています。たとえば、エントリの名前と値を参照するために2つの64ビットポインタを使用し、名前と値への参照数をカウントするために2つの64ビット整数を使用するエントリ構造には、32オクテットのオーバーヘッドがあります。"
    },
    {
      "indent": 0,
      "text": "4.2. Maximum Table Size",
      "section_title": true,
      "ja": "4.2. 最大テーブルサイズ"
    },
    {
      "indent": 3,
      "text": "Protocols that use HPACK determine the maximum size that the encoder is permitted to use for the dynamic table. In HTTP/2, this value is determined by the SETTINGS_HEADER_TABLE_SIZE setting (see Section 6.5.2 of [HTTP2]).",
      "ja": "HPACKを使用するプロトコルは、エンコーダーが動的テーブルに使用できる最大サイズを決定します。 HTTP / 2では、この値はSETTINGS_HEADER_TABLE_SIZE設定によって決定されます（[HTTP2]のセクション6.5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "An encoder can choose to use less capacity than this maximum size (see Section 6.3), but the chosen size MUST stay lower than or equal to the maximum set by the protocol.",
      "ja": "エンコーダーは、この最大サイズよりも少ない容量を使用することを選択できます（セクション6.3を参照）。ただし、選択したサイズは、プロトコルで設定された最大値以下である必要があります。"
    },
    {
      "indent": 3,
      "text": "A change in the maximum size of the dynamic table is signaled via a dynamic table size update (see Section 6.3). This dynamic table size update MUST occur at the beginning of the first header block following the change to the dynamic table size. In HTTP/2, this follows a settings acknowledgment (see Section 6.5.3 of [HTTP2]).",
      "ja": "動的テーブルの最大サイズの変更は、動的テーブルサイズの更新によって通知されます（セクション6.3を参照）。この動的テーブルサイズの更新は、動的テーブルサイズの変更に続く最初のヘッダーブロックの先頭で発生する必要があります。 HTTP / 2では、これは設定確認応答に従います（[HTTP2]のセクション6.5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Multiple updates to the maximum table size can occur between the transmission of two header blocks. In the case that this size is changed more than once in this interval, the smallest maximum table size that occurs in that interval MUST be signaled in a dynamic table size update. The final maximum size is always signaled, resulting in at most two dynamic table size updates. This ensures that the decoder is able to perform eviction based on reductions in dynamic table size (see Section 4.3).",
      "ja": "2つのヘッダーブロックの送信の間に、最大テーブルサイズに対する複数の更新が発生する可能性があります。この間隔でこのサイズが複数回変更される場合、その間隔で発生する最小の最大テーブルサイズは、動的テーブルサイズの更新で通知される必要があります。最終的な最大サイズは常に通知されるため、最大で2つの動的テーブルサイズが更新されます。これにより、デコーダーは動的テーブルサイズの縮小に基づいてエビクションを実行できるようになります（セクション4.3を参照）。"
    },
    {
      "indent": 3,
      "text": "This mechanism can be used to completely clear entries from the dynamic table by setting a maximum size of 0, which can subsequently be restored.",
      "ja": "このメカニズムを使用すると、最大サイズを0に設定することにより、動的テーブルからエントリを完全にクリアできます。"
    },
    {
      "indent": 0,
      "text": "4.3. Entry Eviction When Dynamic Table Size Changes",
      "section_title": true,
      "ja": "4.3. 動的テーブルサイズが変更されたときのエントリの削除"
    },
    {
      "indent": 3,
      "text": "Whenever the maximum size for the dynamic table is reduced, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the maximum size.",
      "ja": "動的テーブルの最大サイズが小さくなると、動的テーブルのサイズが最大サイズ以下になるまで、動的テーブルの最後からエントリが削除されます。"
    },
    {
      "indent": 0,
      "text": "4.4. Entry Eviction When Adding New Entries",
      "section_title": true,
      "ja": "4.4. 新しいエントリを追加するときのエントリの削除"
    },
    {
      "indent": 3,
      "text": "Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (maximum size - new entry size) or until the table is empty.",
      "ja": "新しいエントリが動的テーブルに追加される前に、動的テーブルのサイズが（最大サイズ-新しいエントリサイズ）以下になるまで、またはテーブルが空になるまで、エントリは動的テーブルの末尾から削除されます。"
    },
    {
      "indent": 3,
      "text": "If the size of the new entry is less than or equal to the maximum size, that entry is added to the table. It is not an error to attempt to add an entry that is larger than the maximum size; an attempt to add an entry larger than the maximum size causes the table to be emptied of all existing entries and results in an empty table.",
      "ja": "新しいエントリのサイズが最大サイズ以下の場合、そのエントリはテーブルに追加されます。最大サイズより大きいエントリを追加しようとしてもエラーではありません。最大サイズよりも大きいエントリを追加しようとすると、テーブルの既存のエントリがすべて空になり、テーブルが空になります。"
    },
    {
      "indent": 3,
      "text": "A new entry can reference the name of an entry in the dynamic table that will be evicted when adding this new entry into the dynamic table. Implementations are cautioned to avoid deleting the referenced name if the referenced entry is evicted from the dynamic table prior to inserting the new entry.",
      "ja": "新しいエントリは、動的テーブルにこの新しいエントリを追加するときに削除される動的テーブルのエントリの名前を参照できます。新しいエントリを挿入する前に、参照されたエントリが動的テーブルから削除された場合、実装は参照された名前を削除しないように警告されます。"
    },
    {
      "indent": 0,
      "text": "5. Primitive Type Representations",
      "section_title": true,
      "ja": "5. プリミティブ型表現"
    },
    {
      "indent": 3,
      "text": "HPACK encoding uses two primitive types: unsigned variable-length integers and strings of octets.",
      "ja": "HPACKエンコーディングは、2つのプリミティブ型を使用します。符号なし可変長整数とオクテットの文字列です。"
    },
    {
      "indent": 0,
      "text": "5.1. Integer Representation",
      "section_title": true,
      "ja": "5.1. 整数表現"
    },
    {
      "indent": 3,
      "text": "Integers are used to represent name indexes, header field indexes, or string lengths. An integer representation can start anywhere within an octet. To allow for optimized processing, an integer representation always finishes at the end of an octet.",
      "ja": "整数は、名前インデックス、ヘッダーフィールドインデックス、または文字列長を表すために使用されます。整数表現はオクテット内のどこからでも開始できます。最適化された処理を可能にするために、整数表現は常にオクテットの終わりで終わります。"
    },
    {
      "indent": 3,
      "text": "An integer is represented in two parts: a prefix that fills the current octet and an optional list of octets that are used if the integer value does not fit within the prefix. The number of bits of the prefix (called N) is a parameter of the integer representation.",
      "ja": "整数は2つの部分で表されます。現在のオクテットを満たすプレフィックスと、整数値がプレフィックス内に収まらない場合に使用されるオクテットのオプションのリストです。接頭辞のビット数（Nと呼ばれます）は、整数表現のパラメーターです。"
    },
    {
      "indent": 3,
      "text": "If the integer value is small enough, i.e., strictly less than 2^N-1, it is encoded within the N-bit prefix.",
      "ja": "整数値が十分に小さい場合、つまり厳密に2 ^ N-1未満の場合、Nビットプレフィックス内でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| ? | ? | ? |       Value       |\n+---+---+---+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 2: Integer Value Encoded within the Prefix (Shown for N = 5)",
      "ja": "図2：プレフィックス内にエンコードされた整数値（N = 5の場合に表示）"
    },
    {
      "indent": 3,
      "text": "Otherwise, all the bits of the prefix are set to 1, and the value, decreased by 2^N-1, is encoded using a list of one or more octets. The most significant bit of each octet is used as a continuation flag: its value is set to 1 except for the last octet in the list. The remaining bits of the octets are used to encode the decreased value.",
      "ja": "それ以外の場合は、プレフィックスのすべてのビットが1に設定され、値は2 ^ N-1だけ減らされて、1つ以上のオクテットのリストを使用してエンコードされます。各オクテットの最上位ビットは継続フラグとして使用されます。リストの最後のオクテットを除いて、その値は1に設定されます。オクテットの残りのビットは、減少した値をエンコードするために使用されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| ? | ? | ? | 1   1   1   1   1 |\n+---+---+---+-------------------+\n| 1 |    Value-(2^N-1) LSB      |\n+---+---------------------------+\n               ...\n+---+---------------------------+\n| 0 |    Value-(2^N-1) MSB      |\n+---+---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 3: Integer Value Encoded after the Prefix (Shown for N = 5)",
      "ja": "図3：プレフィックスの後にエンコードされた整数値（N = 5の場合）"
    },
    {
      "indent": 3,
      "text": "Decoding the integer value from the list of octets starts by reversing the order of the octets in the list. Then, for each octet, its most significant bit is removed. The remaining bits of the octets are concatenated, and the resulting value is increased by 2^N-1 to obtain the integer value.",
      "ja": "オクテットのリストから整数値をデコードするには、まず、リスト内のオクテットの順序を逆にします。次に、各オクテットについて、その最上位ビットが削除されます。オクテットの残りのビットは連結され、結果の値は2 ^ N-1だけ増加して整数値を取得します。"
    },
    {
      "indent": 3,
      "text": "The prefix size, N, is always between 1 and 8 bits. An integer starting at an octet boundary will have an 8-bit prefix.",
      "ja": "プレフィックスサイズNは常に1〜8ビットです。オクテット境界で始まる整数には、8ビットのプレフィックスが付きます。"
    },
    {
      "indent": 3,
      "text": "Pseudocode to represent an integer I is as follows:",
      "ja": "整数Iを表す疑似コードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "if I < 2^N - 1, encode I on N bits\nelse\n    encode (2^N - 1) on N bits\n    I = I - (2^N - 1)\n    while I >= 128\n         encode (I % 128 + 128) on 8 bits\n         I = I / 128\n    encode I on 8 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pseudocode to decode an integer I is as follows:",
      "ja": "整数Iをデコードする疑似コードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "decode I from the next N bits\nif I < 2^N - 1, return I\nelse\n    M = 0\n    repeat\n        B = next octet\n        I = I + (B & 127) * 2^M\n        M = M + 7\n    while B & 128 == 128\n    return I",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Examples illustrating the encoding of integers are available in Appendix C.1.",
      "ja": "整数のエンコーディングを示す例は、付録C.1にあります。"
    },
    {
      "indent": 3,
      "text": "This integer representation allows for values of indefinite size. It is also possible for an encoder to send a large number of zero values, which can waste octets and could be used to overflow integer values. Integer encodings that exceed implementation limits -- in value or octet length -- MUST be treated as decoding errors. Different limits can be set for each of the different uses of integers, based on implementation constraints.",
      "ja": "この整数表現では、サイズが無制限の値を使用できます。エンコーダーが多数のゼロ値を送信することも可能です。これはオクテットを浪費し、整数値のオーバーフローに使用される可能性があります。実装の制限（値またはオクテット長）を超える整数エンコーディングは、デコードエラーとして処理する必要があります。実装の制約に基づいて、整数のさまざまな用途ごとに異なる制限を設定できます。"
    },
    {
      "indent": 0,
      "text": "5.2. String Literal Representation",
      "section_title": true,
      "ja": "5.2. 文字列リテラル表現"
    },
    {
      "indent": 3,
      "text": "Header field names and header field values can be represented as string literals. A string literal is encoded as a sequence of octets, either by directly encoding the string literal's octets or by using a Huffman code (see [HUFFMAN]).",
      "ja": "ヘッダーフィールド名とヘッダーフィールド値は、文字列リテラルとして表すことができます。文字列リテラルは、文字列リテラルのオクテットを直接エンコードするか、ハフマンコードを使用して、オクテットのシーケンスとしてエンコードされます（[HUFFMAN]を参照）。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| H |    String Length (7+)     |\n+---+---------------------------+\n|  String Data (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 4: String Literal Representation",
      "ja": "図4：文字列リテラル表現"
    },
    {
      "indent": 3,
      "text": "A string literal representation contains the following fields:",
      "ja": "文字列リテラル表現には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "H: A one-bit flag, H, indicating whether or not the octets of the string are Huffman encoded.",
      "ja": "H：文字列のオクテットがハフマンエンコードされているかどうかを示す1ビットフラグH。"
    },
    {
      "indent": 3,
      "text": "String Length: The number of octets used to encode the string literal, encoded as an integer with a 7-bit prefix (see Section 5.1).",
      "ja": "文字列の長さ：文字列リテラルのエンコードに使用されるオクテットの数。7ビットのプレフィックスを持つ整数としてエンコードされます（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "String Data: The encoded data of the string literal. If H is '0', then the encoded data is the raw octets of the string literal. If H is '1', then the encoded data is the Huffman encoding of the string literal.",
      "ja": "文字列データ：文字列リテラルのエンコードされたデータ。 Hが '0'の場合、エンコードされたデータは文字列リテラルの生オクテットです。 Hが '1'の場合、エンコードされたデータは文字列リテラルのハフマンエンコードです。"
    },
    {
      "indent": 3,
      "text": "String literals that use Huffman encoding are encoded with the Huffman code defined in Appendix B (see examples for requests in Appendix C.4 and for responses in Appendix C.6). The encoded data is the bitwise concatenation of the codes corresponding to each octet of the string literal.",
      "ja": "ハフマンエンコーディングを使用する文字列リテラルは、付録Bで定義されたハフマンコードでエンコードされます（付録C.4のリクエストと付録C.6のレスポンスの例を参照）。エンコードされたデータは、文字列リテラルの各オクテットに対応するコードのビットごとの連結です。"
    },
    {
      "indent": 3,
      "text": "As the Huffman-encoded data doesn't always end at an octet boundary, some padding is inserted after it, up to the next octet boundary. To prevent this padding from being misinterpreted as part of the string literal, the most significant bits of the code corresponding to the EOS (end-of-string) symbol are used.",
      "ja": "ハフマン符号化されたデータは常にオクテット境界で終了するわけではないので、その次のオクテット境界まで、いくつかのパディングが挿入されます。このパディングが文字列リテラルの一部として誤って解釈されないようにするために、EOS（文字列の終わり）記号に対応するコードの最上位ビットが使用されます。"
    },
    {
      "indent": 3,
      "text": "Upon decoding, an incomplete code at the end of the encoded data is to be considered as padding and discarded. A padding strictly longer than 7 bits MUST be treated as a decoding error. A padding not corresponding to the most significant bits of the code for the EOS symbol MUST be treated as a decoding error. A Huffman-encoded string literal containing the EOS symbol MUST be treated as a decoding error.",
      "ja": "デコード時に、エンコードされたデータの最後にある不完全なコードはパディングと見なされ、破棄されます。厳密に7ビットより長いパディングは、デコードエラーとして扱われる必要があります。 EOSシンボルのコードの最上位ビットに対応しないパディングは、デコードエラーとして扱われる必要があります。 EOSシンボルを含むハフマンエンコードされた文字列リテラルは、デコードエラーとして扱われる必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Binary Format",
      "section_title": true,
      "ja": "6. バイナリ形式"
    },
    {
      "indent": 3,
      "text": "This section describes the detailed format of each of the different header field representations and the dynamic table size update instruction.",
      "ja": "このセクションでは、さまざまなヘッダーフィールド表現と動的テーブルサイズ更新命令のそれぞれの詳細な形式について説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Indexed Header Field Representation",
      "section_title": true,
      "ja": "6.1. インデックス付きヘッダーフィールドの表現"
    },
    {
      "indent": 3,
      "text": "An indexed header field representation identifies an entry in either the static table or the dynamic table (see Section 2.3).",
      "ja": "インデックス付きヘッダーフィールド表現は、静的テーブルまたは動的テーブルのいずれかのエントリを識別します（2.3節を参照）。"
    },
    {
      "indent": 3,
      "text": "An indexed header field representation causes a header field to be added to the decoded header list, as described in Section 3.2.",
      "ja": "セクション3.2で説明するように、インデックス付きヘッダーフィールド表現により、ヘッダーフィールドがデコードされたヘッダーリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1 |        Index (7+)         |\n+---+---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 5: Indexed Header Field",
      "ja": "図5：インデックス付きヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "An indexed header field starts with the '1' 1-bit pattern, followed by the index of the matching header field, represented as an integer with a 7-bit prefix (see Section 5.1).",
      "ja": "インデックス付きヘッダーフィールドは「1」の1ビットパターンで始まり、7ビットのプレフィックス付きの整数として表される一致するヘッダーフィールドのインデックスが続きます（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The index value of 0 is not used. It MUST be treated as a decoding error if found in an indexed header field representation.",
      "ja": "インデックス値0は使用されません。インデックス付きヘッダーフィールド表現で見つかった場合は、デコードエラーとして処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Literal Header Field Representation",
      "section_title": true,
      "ja": "6.2. リテラルヘッダーフィールドの表現"
    },
    {
      "indent": 3,
      "text": "A literal header field representation contains a literal header field value. Header field names are provided either as a literal or by reference to an existing table entry, either from the static table or the dynamic table (see Section 2.3).",
      "ja": "リテラルヘッダーフィールド表現には、リテラルヘッダーフィールド値が含まれます。ヘッダーフィールド名は、リテラルとして、または静的テーブルまたは動的テーブルからの既存のテーブルエントリへの参照によって提供されます（セクション2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "This specification defines three forms of literal header field representations: with indexing, without indexing, and never indexed.",
      "ja": "この仕様では、3つの形式のリテラルヘッダーフィールド表現を定義しています。インデックスあり、インデックスなし、インデックスなし。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Literal Header Field with Incremental Indexing",
      "section_title": true,
      "ja": "6.2.1. インクリメンタルインデックスを使用したリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A literal header field with incremental indexing representation results in appending a header field to the decoded header list and inserting it as a new entry into the dynamic table.",
      "ja": "インクリメンタルインデックス表現を持つリテラルヘッダーフィールドは、デコードされたヘッダーリストにヘッダーフィールドを追加し、それを新しいエントリとして動的テーブルに挿入します。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 1 |      Index (6+)       |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 6: Literal Header Field with Incremental Indexing -- Indexed Name",
      "ja": "図6：インクリメンタルインデックスを使用したリテラルヘッダーフィールド-インデックス名"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 1 |           0           |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 7: Literal Header Field with Incremental Indexing -- New Name",
      "ja": "図7：インクリメンタルインデックスを使用したリテラルヘッダーフィールド-新しい名前"
    },
    {
      "indent": 3,
      "text": "A literal header field with incremental indexing representation starts with the '01' 2-bit pattern.",
      "ja": "インクリメンタルインデックス表現のリテラルヘッダーフィールドは、'01 '2ビットパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the index of the entry is represented as an integer with a 6-bit prefix (see Section 5.1). This value is always non-zero.",
      "ja": "ヘッダーフィールド名が静的テーブルまたは動的テーブルに格納されているエントリのヘッダーフィールド名と一致する場合、ヘッダーフィールド名はそのエントリのインデックスを使用して表すことができます。この場合、エントリのインデックスは、6ビットのプレフィックスを持つ整数として表されます（セクション5.1を参照）。この値は常にゼロ以外です。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the header field name is represented as a string literal (see Section 5.2). A value 0 is used in place of the 6-bit index, followed by the header field name.",
      "ja": "それ以外の場合、ヘッダーフィールド名は文字列リテラルとして表されます（セクション5.2を参照）。 6ビットインデックスの代わりに値0が使用され、その後にヘッダーフィールド名が続きます。"
    },
    {
      "indent": 3,
      "text": "Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).",
      "ja": "どちらの形式のヘッダーフィールド名表現にも、文字列リテラルとして表されたヘッダーフィールド値が続きます（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Literal Header Field without Indexing",
      "section_title": true,
      "ja": "6.2.2. インデックスなしのリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A literal header field without indexing representation results in appending a header field to the decoded header list without altering the dynamic table.",
      "ja": "インデックス表現のないリテラルヘッダーフィールドは、動的テーブルを変更せずに、ヘッダーフィールドをデコードされたヘッダーリストに追加します。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 0 |  Index (4+)   |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 8: Literal Header Field without Indexing -- Indexed Name",
      "ja": "図8：インデックスのないリテラルヘッダーフィールド-インデックス名"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 0 |       0       |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 9: Literal Header Field without Indexing -- New Name",
      "ja": "図9：インデックスのないリテラルヘッダーフィールド-新しい名前"
    },
    {
      "indent": 3,
      "text": "A literal header field without indexing representation starts with the '0000' 4-bit pattern.",
      "ja": "インデックス表現のないリテラルヘッダーフィールドは、「0000」の4ビットパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the index of the entry is represented as an integer with a 4-bit prefix (see Section 5.1). This value is always non-zero.",
      "ja": "ヘッダーフィールド名が静的テーブルまたは動的テーブルに格納されているエントリのヘッダーフィールド名と一致する場合、ヘッダーフィールド名はそのエントリのインデックスを使用して表すことができます。この場合、エントリのインデックスは、4ビットのプレフィックスを持つ整数として表されます（セクション5.1を参照）。この値は常にゼロ以外です。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the header field name is represented as a string literal (see Section 5.2). A value 0 is used in place of the 4-bit index, followed by the header field name.",
      "ja": "それ以外の場合、ヘッダーフィールド名は文字列リテラルとして表されます（セクション5.2を参照）。 4ビットのインデックスの代わりに値0が使用され、その後にヘッダーフィールド名が続きます。"
    },
    {
      "indent": 3,
      "text": "Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).",
      "ja": "どちらの形式のヘッダーフィールド名表現にも、文字列リテラルとして表されたヘッダーフィールド値が続きます（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Literal Header Field Never Indexed",
      "section_title": true,
      "ja": "6.2.3. リテラルヘッダーフィールドがインデックス付けされない"
    },
    {
      "indent": 3,
      "text": "A literal header field never-indexed representation results in appending a header field to the decoded header list without altering the dynamic table. Intermediaries MUST use the same representation for encoding this header field.",
      "ja": "リテラルヘッダーフィールドのインデックスが作成されない表現では、動的テーブルを変更せずに、ヘッダーフィールドがデコードされたヘッダーリストに追加されます。仲介者は、このヘッダーフィールドのエンコードに同じ表現を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 1 |  Index (4+)   |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 10: Literal Header Field Never Indexed -- Indexed Name",
      "ja": "図10：インデックス付けされないリテラルヘッダーフィールド-インデックス付けされた名前"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 1 |       0       |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 11: Literal Header Field Never Indexed -- New Name",
      "ja": "図11：インデックス付けされないリテラルヘッダーフィールド-新しい名前"
    },
    {
      "indent": 3,
      "text": "A literal header field never-indexed representation starts with the '0001' 4-bit pattern.",
      "ja": "リテラルヘッダーフィールドのインデックスなしの表現は、 '0001' 4ビットパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "When a header field is represented as a literal header field never indexed, it MUST always be encoded with this specific literal representation. In particular, when a peer sends a header field that it received represented as a literal header field never indexed, it MUST use the same representation to forward this header field.",
      "ja": "ヘッダーフィールドがインデックス付けされていないリテラルヘッダーフィールドとして表される場合、常にこの特定のリテラル表現でエンコードされる必要があります。特に、ピアが受信したヘッダーフィールドを、インデックス付けされていないリテラルヘッダーフィールドとして表される場合は、このヘッダーフィールドを転送するために同じ表現を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 for more details).",
      "ja": "この表現は、危険にさらされないヘッダーフィールド値を圧縮して保護することを目的としています（詳細については、セクション7.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The encoding of the representation is identical to the literal header field without indexing (see Section 6.2.2).",
      "ja": "表現のエンコーディングは、インデックスがないリテラルヘッダーフィールドと同じです（セクション6.2.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.3. Dynamic Table Size Update",
      "section_title": true,
      "ja": "6.3. 動的テーブルサイズの更新"
    },
    {
      "indent": 3,
      "text": "A dynamic table size update signals a change to the size of the dynamic table.",
      "ja": "動的テーブルサイズの更新は、動的テーブルのサイズの変更を通知します。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 1 |   Max size (5+)   |\n+---+---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 12: Maximum Dynamic Table Size Change",
      "ja": "図12：最大動的テーブルサイズの変更"
    },
    {
      "indent": 3,
      "text": "A dynamic table size update starts with the '001' 3-bit pattern, followed by the new maximum size, represented as an integer with a 5-bit prefix (see Section 5.1).",
      "ja": "動的テーブルサイズの更新は、「001」の3ビットパターンで始まり、その後に5ビットプレフィックス付きの整数として表される新しい最大サイズが続きます（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The new maximum size MUST be lower than or equal to the limit determined by the protocol using HPACK. A value that exceeds this limit MUST be treated as a decoding error. In HTTP/2, this limit is the last value of the SETTINGS_HEADER_TABLE_SIZE parameter (see Section 6.5.2 of [HTTP2]) received from the decoder and acknowledged by the encoder (see Section 6.5.3 of [HTTP2]).",
      "ja": "新しい最大サイズは、HPACKを使用するプロトコルによって決定される制限以下である必要があります。この制限を超える値は、デコードエラーとして処理する必要があります。 HTTP / 2では、この制限は、デコーダーから受信され、エンコーダーによって確認されたSETTINGS_HEADER_TABLE_SIZEパラメーター（[HTTP2]のセクション6.5.2を参照）の最後の値です（[HTTP2]のセクション6.5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Reducing the maximum size of the dynamic table can cause entries to be evicted (see Section 4.3).",
      "ja": "動的テーブルの最大サイズを小さくすると、エントリが削除される場合があります（セクション4.3を参照）。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes potential areas of security concern with HPACK:",
      "ja": "このセクションでは、HPACKのセキュリティ問題の潜在的な領域について説明します。"
    },
    {
      "indent": 3,
      "text": "o Use of compression as a length-based oracle for verifying guesses about secrets that are compressed into a shared compression context.",
      "ja": "o 共有圧縮コンテキストに圧縮された秘密に関する推測を検証するための長さベースのオラクルとしての圧縮の使用。"
    },
    {
      "indent": 3,
      "text": "o Denial of service resulting from exhausting processing or memory capacity at a decoder.",
      "ja": "o デコーダでの処理またはメモリ容量の枯渇に起因するサービス拒否。"
    },
    {
      "indent": 0,
      "text": "7.1. Probing Dynamic Table State",
      "section_title": true,
      "ja": "7.1. 動的テーブル状態の調査"
    },
    {
      "indent": 3,
      "text": "HPACK reduces the length of header field encodings by exploiting the redundancy inherent in protocols like HTTP. The ultimate goal of this is to reduce the amount of data that is required to send HTTP requests or responses.",
      "ja": "HPACKは、HTTPなどのプロトコルに固有の冗長性を利用することにより、ヘッダーフィールドエンコーディングの長さを削減します。これの最終的な目標は、HTTP要求または応答を送信するために必要なデータの量を減らすことです。"
    },
    {
      "indent": 3,
      "text": "The compression context used to encode header fields can be probed by an attacker who can both define header fields to be encoded and transmitted and observe the length of those fields once they are encoded. When an attacker can do both, they can adaptively modify requests in order to confirm guesses about the dynamic table state. If a guess is compressed into a shorter length, the attacker can observe the encoded length and infer that the guess was correct.",
      "ja": "ヘッダーフィールドのエンコードに使用される圧縮コンテキストは、エンコードされて送信されるヘッダーフィールドを定義し、エンコードされるとそれらのフィールドの長さを観察できる攻撃者がプローブできます。攻撃者が両方を実行できる場合、動的テーブルの状態に関する推測を確認するために、要求を適応的に変更できます。推測がより短い長さに圧縮されている場合、攻撃者はエンコードされた長さを観察し、推測が正しいことを推測できます。"
    },
    {
      "indent": 3,
      "text": "This is possible even over the Transport Layer Security (TLS) protocol (see [TLS12]), because while TLS provides confidentiality protection for content, it only provides a limited amount of protection for the length of that content.",
      "ja": "これは、トランスポート層セキュリティ（TLS）プロトコル（[TLS12]を参照）を介しても可能です。TLSはコンテンツの機密保護を提供しますが、そのコンテンツの長さについては限られた量の保護しか提供しません。"
    },
    {
      "indent": 6,
      "text": "Note: Padding schemes only provide limited protection against an attacker with these capabilities, potentially only forcing an increased number of guesses to learn the length associated with a given guess. Padding schemes also work directly against compression by increasing the number of bits that are transmitted.",
      "ja": "注：パディングスキームは、これらの機能を備えた攻撃者に対して限定的な保護を提供するだけであり、特定の推測に関連付けられた長さを学習するために、推測の増加を強制する可能性があります。パディングスキームは、送信されるビット数を増やすことにより、直接圧縮に対しても機能します。"
    },
    {
      "indent": 3,
      "text": "Attacks like CRIME [CRIME] demonstrated the existence of these general attacker capabilities. The specific attack exploited the fact that DEFLATE [DEFLATE] removes redundancy based on prefix matching. This permitted the attacker to confirm guesses a character at a time, reducing an exponential-time attack into a linear-time attack.",
      "ja": "CRIME [CRIME]のような攻撃は、これらの一般的な攻撃者機能の存在を示しました。特定の攻撃は、DEFLATE [DEFLATE]がプレフィックスマッチングに基づいて冗長性を削除するという事実を悪用しました。これにより、攻撃者は一度に文字を推測することを確認でき、指数時間攻撃を線形時間攻撃に減らしました。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Applicability to HPACK and HTTP",
      "section_title": true,
      "ja": "7.1.1. HPACKおよびHTTPへの適用性"
    },
    {
      "indent": 3,
      "text": "HPACK mitigates but does not completely prevent attacks modeled on CRIME [CRIME] by forcing a guess to match an entire header field value rather than individual characters. Attackers can only learn whether a guess is correct or not, so they are reduced to brute-force guesses for the header field values.",
      "ja": "HPACKは、個々の文字ではなくヘッダーフィールド値全体を推測するように強制することにより、CRIME [CRIME]でモデル化された攻撃を軽減しますが、完全には防ぎません。攻撃者は推測が正しいかどうかのみを学習できるため、ヘッダーフィールド値の総当たり推測に減らされます。"
    },
    {
      "indent": 3,
      "text": "The viability of recovering specific header field values therefore depends on the entropy of values. As a result, values with high entropy are unlikely to be recovered successfully. However, values with low entropy remain vulnerable.",
      "ja": "したがって、特定のヘッダーフィールド値を回復できるかどうかは、値のエントロピーに依存します。その結果、エントロピーの高い値が正常に復元される可能性は低くなります。ただし、エントロピーの低い値は脆弱なままです。"
    },
    {
      "indent": 3,
      "text": "Attacks of this nature are possible any time that two mutually distrustful entities control requests or responses that are placed onto a single HTTP/2 connection. If the shared HPACK compressor permits one entity to add entries to the dynamic table and the other to access those entries, then the state of the table can be learned.",
      "ja": "この性質の攻撃は、2つの相互に信頼できないエンティティが単一のHTTP / 2接続に配置された要求または応答を制御する場合にいつでも可能です。共有HPACKコンプレッサーによって、一方のエンティティが動的テーブルにエントリを追加し、もう一方のエンティティがそれらのエントリにアクセスすることが許可されている場合、テーブルの状態を知ることができます。"
    },
    {
      "indent": 3,
      "text": "Having requests or responses from mutually distrustful entities occurs when an intermediary either:",
      "ja": "相互に不信なエンティティからの要求または応答は、仲介者が次のいずれかの場合に発生します。"
    },
    {
      "indent": 3,
      "text": "o sends requests from multiple clients on a single connection toward an origin server, or",
      "ja": "o 単一の接続で複数のクライアントからオリジンサーバーにリクエストを送信する、または"
    },
    {
      "indent": 3,
      "text": "o takes responses from multiple origin servers and places them on a shared connection toward a client.",
      "ja": "o 複数のオリジンサーバーから応答を受け取り、それらをクライアントへの共有接続に配置します。"
    },
    {
      "indent": 3,
      "text": "Web browsers also need to assume that requests made on the same connection by different web origins [ORIGIN] are made by mutually distrustful entities.",
      "ja": "また、Webブラウザーは、異なる接続元[ORIGIN]による同じ接続で行われた要求が相互に信頼できないエンティティーによって行われると想定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Mitigation",
      "section_title": true,
      "ja": "7.1.2. 緩和"
    },
    {
      "indent": 3,
      "text": "Users of HTTP that require confidentiality for header fields can use values with entropy sufficient to make guessing infeasible. However, this is impractical as a general solution because it forces all users of HTTP to take steps to mitigate attacks. It would impose new constraints on how HTTP is used.",
      "ja": "ヘッダーフィールドの機密性を必要とするHTTPのユーザーは、推測を実行不可能にするのに十分なエントロピーの値を使用できます。ただし、これはHTTPのすべてのユーザーに攻撃を緩和するための対策を講じる必要があるため、一般的なソリューションとしては非現実的です。これは、HTTPの使用方法に新しい制約を課します。"
    },
    {
      "indent": 3,
      "text": "Rather than impose constraints on users of HTTP, an implementation of HPACK can instead constrain how compression is applied in order to limit the potential for dynamic table probing.",
      "ja": "HTTPのユーザーに制約を課すのではなく、HPACKの実装は、動的テーブルプローブの可能性を制限するために、圧縮の適用方法を代わりに制限できます。"
    },
    {
      "indent": 3,
      "text": "An ideal solution segregates access to the dynamic table based on the entity that is constructing header fields. Header field values that are added to the table are attributed to an entity, and only the entity that created a particular value can extract that value.",
      "ja": "理想的なソリューションは、ヘッダーフィールドを構成しているエンティティに基づいて、動的テーブルへのアクセスを分離します。テーブルに追加されたヘッダーフィールド値はエンティティに帰属し、特定の値を作成したエンティティのみがその値を抽出できます。"
    },
    {
      "indent": 3,
      "text": "To improve compression performance of this option, certain entries might be tagged as being public. For example, a web browser might make the values of the Accept-Encoding header field available in all requests.",
      "ja": "このオプションの圧縮パフォーマンスを向上させるために、特定のエントリがパブリックとしてタグ付けされている場合があります。たとえば、WebブラウザーはAccept-Encodingヘッダーフィールドの値をすべてのリクエストで使用できるようにする場合があります。"
    },
    {
      "indent": 3,
      "text": "An encoder without good knowledge of the provenance of header fields might instead introduce a penalty for a header field with many different values, such that a large number of attempts to guess a header field value results in the header field no longer being compared to the dynamic table entries in future messages, effectively preventing further guesses.",
      "ja": "ヘッダーフィールドの出所について十分な知識がないエンコーダーは、代わりに多くの異なる値を持つヘッダーフィールドにペナルティをもたらす可能性があり、ヘッダーフィールドの値を推測しようとすると、ヘッダーフィールドが動的フィールドと比較されなくなります今後のメッセージのテーブルエントリ。これ以上の推測を効果的に防ぎます。"
    },
    {
      "indent": 6,
      "text": "Note: Simply removing entries corresponding to the header field from the dynamic table can be ineffectual if the attacker has a reliable way of causing values to be reinstalled. For example, a request to load an image in a web browser typically includes the Cookie header field (a potentially highly valued target for this sort of attack), and web sites can easily force an image to be loaded, thereby refreshing the entry in the dynamic table.",
      "ja": "注：攻撃者が信頼できる方法で値を再インストールする場合、動的テーブルからヘッダーフィールドに対応するエントリを削除するだけでは効果がない場合があります。たとえば、ウェブブラウザに画像を読み込むリクエストには通常Cookieヘッダーフィールド（この種の攻撃では非常に重要なターゲットとなる可能性があります）が含まれており、ウェブサイトは簡単に画像を強制的に読み込むことができるため、動的テーブル。"
    },
    {
      "indent": 3,
      "text": "This response might be made inversely proportional to the length of the header field value. Marking a header field as not using the dynamic table anymore might occur for shorter values more quickly or with higher probability than for longer values.",
      "ja": "この応答は、ヘッダーフィールド値の長さに反比例する場合があります。動的なテーブルを使用しないようにヘッダーフィールドをマークすると、短い値の方が長い値よりも速く、または確率が高くなります。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Never-Indexed Literals",
      "section_title": true,
      "ja": "7.1.3. 索引付けされていないリテラル"
    },
    {
      "indent": 3,
      "text": "Implementations can also choose to protect sensitive header fields by not compressing them and instead encoding their value as literals.",
      "ja": "実装では、機密のヘッダーフィールドを圧縮せずに、その値をリテラルとしてエンコードすることで保護することもできます。"
    },
    {
      "indent": 3,
      "text": "Refusing to generate an indexed representation for a header field is only effective if compression is avoided on all hops. The never-indexed literal (see Section 6.2.3) can be used to signal to intermediaries that a particular value was intentionally sent as a literal.",
      "ja": "ヘッダーフィールドのインデックス付き表現の生成を拒否することは、すべてのホップで圧縮が回避されている場合にのみ有効です。インデックス付けされていないリテラル（セクション6.2.3を参照）を使用して、特定の値が意図的にリテラルとして送信されたことを仲介者に通知できます。"
    },
    {
      "indent": 3,
      "text": "An intermediary MUST NOT re-encode a value that uses the never-indexed literal representation with another representation that would index it. If HPACK is used for re-encoding, the never-indexed literal representation MUST be used.",
      "ja": "仲介者は、インデックス付けされていないリテラル表現を使用する値を、それをインデックス付けする別の表現で再エンコードしてはなりません（MUST NOT）。 HPACKを再エンコードに使用する場合、インデックス付けされていないリテラル表現を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The choice to use a never-indexed literal representation for a header field depends on several factors. Since HPACK doesn't protect against guessing an entire header field value, short or low-entropy values are more readily recovered by an adversary. Therefore, an encoder might choose not to index values with low entropy.",
      "ja": "ヘッダーフィールドにインデックス付けされていないリテラル表現を使用する選択は、いくつかの要因に依存します。 HPACKはヘッダーフィールド値全体の推測を防止しないため、短いエントロピー値または低いエントロピー値は、敵によってより容易に回復されます。したがって、エンコーダーは、エントロピーの低い値にインデックスを付けないことを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "An encoder might also choose not to index values for header fields that are considered to be highly valuable or sensitive to recovery, such as the Cookie or Authorization header fields.",
      "ja": "エンコーダーは、CookieやAuthorizationヘッダーフィールドなど、非常に価値があるか、リカバリに敏感であると考えられるヘッダーフィールドの値にインデックスを付けないことも選択できます。"
    },
    {
      "indent": 3,
      "text": "On the contrary, an encoder might prefer indexing values for header fields that have little or no value if they were exposed. For instance, a User-Agent header field does not commonly vary between requests and is sent to any server. In that case, confirmation that a particular User-Agent value has been used provides little value.",
      "ja": "それどころか、エンコーダーは、それらが公開された場合に値がほとんどまたはまったくないヘッダーフィールドのインデックス値を優先することがあります。たとえば、User-Agentヘッダーフィールドは通常リクエスト間で変化せず、任意のサーバーに送信されます。その場合、特定のUser-Agent値が使用されていることを確認してもほとんど意味がありません。"
    },
    {
      "indent": 3,
      "text": "Note that these criteria for deciding to use a never-indexed literal representation will evolve over time as new attacks are discovered.",
      "ja": "インデックス付けされていないリテラル表現を使用することを決定するこれらの基準は、新しい攻撃が発見されるにつれて、時間とともに進化することに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Static Huffman Encoding",
      "section_title": true,
      "ja": "7.2. 静的ハフマンエンコーディング"
    },
    {
      "indent": 3,
      "text": "There is no currently known attack against a static Huffman encoding. A study has shown that using a static Huffman encoding table created an information leakage; however, this same study concluded that an attacker could not take advantage of this information leakage to recover any meaningful amount of information (see [PETAL]).",
      "ja": "現在、静的ハフマンエンコーディングに対する既知の攻撃はありません。静的なハフマンエンコーディングテーブルを使用すると、情報漏えいが発生することが調査で示されています。ただし、この同じ調査では、攻撃者はこの情報漏えいを利用して意味のある情報を回復することはできないと結論付けています（[PETAL]を参照）。"
    },
    {
      "indent": 0,
      "text": "7.3. Memory Consumption",
      "section_title": true,
      "ja": "7.3. メモリ消費"
    },
    {
      "indent": 3,
      "text": "An attacker can try to cause an endpoint to exhaust its memory. HPACK is designed to limit both the peak and state amounts of memory allocated by an endpoint.",
      "ja": "攻撃者は、エンドポイントのメモリを使い果たすことを試みる可能性があります。 HPACKは、エンドポイントによって割り当てられるメモリのピーク量と状態量の両方を制限するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The amount of memory used by the compressor is limited by the protocol using HPACK through the definition of the maximum size of the dynamic table. In HTTP/2, this value is controlled by the decoder through the setting parameter SETTINGS_HEADER_TABLE_SIZE (see Section 6.5.2 of [HTTP2]). This limit takes into account both the size of the data stored in the dynamic table, plus a small allowance for overhead.",
      "ja": "コンプレッサーが使用するメモリー量は、動的テーブルの最大サイズの定義を通じて、HPACKを使用するプロトコルによって制限されます。 HTTP / 2では、この値は設定パラメーターSETTINGS_HEADER_TABLE_SIZEを介してデコーダーによって制御されます（[HTTP2]のセクション6.5.2を参照）。この制限では、動的テーブルに格納されるデータのサイズに加えて、オーバーヘッドのわずかな許容量の両方が考慮されます。"
    },
    {
      "indent": 3,
      "text": "A decoder can limit the amount of state memory used by setting an appropriate value for the maximum size of the dynamic table. In HTTP/2, this is realized by setting an appropriate value for the SETTINGS_HEADER_TABLE_SIZE parameter. An encoder can limit the amount of state memory it uses by signaling a lower dynamic table size than the decoder allows (see Section 6.3).",
      "ja": "デコーダーは、動的テーブルの最大サイズに適切な値を設定することにより、使用される状態メモリの量を制限できます。 HTTP / 2では、これは、SETTINGS_HEADER_TABLE_SIZEパラメータに適切な値を設定することで実現されます。エンコーダーは、デコーダーが許可するよりも低い動的テーブルサイズを通知することで、使用する状態メモリの量を制限できます（セクション6.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The amount of temporary memory consumed by an encoder or decoder can be limited by processing header fields sequentially. An implementation does not need to retain a complete list of header fields. Note, however, that it might be necessary for an application to retain a complete header list for other reasons; even though HPACK does not force this to occur, application constraints might make this necessary.",
      "ja": "エンコーダーまたはデコーダーによって消費される一時メモリの量は、ヘッダーフィールドを順次処理することによって制限できます。実装では、ヘッダーフィールドの完全なリストを保持する必要はありません。ただし、アプリケーションが他の理由で完全なヘッダーリストを保持する必要がある場合があることに注意してください。 HPACKはこれを強制的に発生させませんが、アプリケーションの制約によりこれが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.4. Implementation Limits",
      "section_title": true,
      "ja": "7.4. 実装制限"
    },
    {
      "indent": 3,
      "text": "An implementation of HPACK needs to ensure that large values for integers, long encoding for integers, or long string literals do not create security weaknesses.",
      "ja": "HPACKの実装では、整数の大きな値、整数の長いエンコーディング、または長い文字列リテラルがセキュリティ上の弱点を引き起こさないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation has to set a limit for the values it accepts for integers, as well as for the encoded length (see Section 5.1). In the same way, it has to set a limit to the length it accepts for string literals (see Section 5.2).",
      "ja": "実装は、整数として受け入れる値とエンコードされた長さの制限を設定する必要があります（セクション5.1を参照）。同様に、文字列リテラルとして受け入れる長さに制限を設定する必要があります（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HTTP2] Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext Transfer Protocol Version 2 (HTTP/2)\", RFC 7540, DOI 10.17487/RFC7540, May 2015, <http://www.rfc-editor.org/info/rfc7540>.",
      "ja": "[HTTP2] Belshe、M.、Peon、R。、およびM. Thomson、編、「Hypertext Transfer Protocol Version 2（HTTP / 2）」、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、<http：// www.rfc-editor.org/info/rfc7540>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CANONICAL] Schwartz, E. and B. Kallick, \"Generating a canonical prefix encoding\", Communications of the ACM, Volume 7 Issue 3, pp. 166-169, March 1964, <https://dl.acm.org/ citation.cfm?id=363991>.",
      "ja": "[CANONICAL] Schwartz、E.、B。Kallick、「Generating a canonical prefix encoding」、Communications of the ACM、Volume 7 Issue 3、pp。166-169、3月1964、<https://dl.acm.org/ citation.cfm？id = 363991>。"
    },
    {
      "indent": 3,
      "text": "[CRIME] Wikipedia, \"CRIME\", May 2015, <http://en.wikipedia.org/w/ index.php?title=CRIME&oldid=660948120>.",
      "ja": "[CRIME] Wikipedia、「CRIME」、2015年5月、<http://en.wikipedia.org/w/ index.php？title = CRIME＆oldid = 660948120>。"
    },
    {
      "indent": 3,
      "text": "[DEFLATE] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, DOI 10.17487/RFC1951, May 1996, <http://www.rfc-editor.org/info/rfc1951>.",
      "ja": "[DEFLATE] Deutsch、P。、「DEFLATE Compressed Data Format Specification version 1.3」、RFC 1951、DOI 10.17487 / RFC1951、1996年5月、<http://www.rfc-editor.org/info/rfc1951>。"
    },
    {
      "indent": 3,
      "text": "[HUFFMAN] Huffman, D., \"A Method for the Construction of Minimum-Redundancy Codes\", Proceedings of the Institute of Radio Engineers, Volume 40, Number 9, pp. 1098-1101, September 1952, <http://ieeexplore.ieee.org/xpl/ articleDetails.jsp?arnumber=4051119>.",
      "ja": "[ハフマン]ハフマン、D。、「最小冗長コードの構築方法」、無線技術者会集、第40巻、第9巻、1098〜1101ページ、1952年9月、<http：// ieeexplore .ieee.org / xpl / articleDetails.jsp？arnumber = 4051119>。"
    },
    {
      "indent": 3,
      "text": "[ORIGIN] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[ORIGIN] Barth、A。、「The Web Origin Concept」、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[PETAL] Tan, J. and J. Nahata, \"PETAL: Preset Encoding Table Information Leakage\", April 2013, <http://www.pdl.cmu.edu/PDL-FTP/associated/ CMU-PDL-13-106.pdf>.",
      "ja": "[PETAL] Tan、J.、J。Nahata、「PETAL：Preset Encoding Table Information Leakage」、2013年4月、<http://www.pdl.cmu.edu/PDL-FTP/related/ CMU-PDL-13- 106.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SPDY] Belshe, M. and R. Peon, \"SPDY Protocol\", Work in Progress, draft-mbelshe-httpbis-spdy-00, February 2012.",
      "ja": "[SPDY] Belshe、M。、およびR. Peon、「SPDY Protocol」、Work in Progress、draft-mbelshe-httpbis-spdy-00、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[TLS12] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[TLS12] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Static Table Definition",
      "section_title": true,
      "ja": "付録A.静的テーブルの定義"
    },
    {
      "indent": 3,
      "text": "The static table (see Section 2.3.1) consists in a predefined and unchangeable list of header fields.",
      "ja": "静的テーブル（セクション2.3.1を参照）は、ヘッダーフィールドの事前定義された変更不可能なリストで構成されています。"
    },
    {
      "indent": 3,
      "text": "The static table was created from the most frequent header fields used by popular web sites, with the addition of HTTP/2-specific pseudo-header fields (see Section 8.1.2.1 of [HTTP2]). For header fields with a few frequent values, an entry was added for each of these frequent values. For other header fields, an entry was added with an empty value.",
      "ja": "静的テーブルは、HTTP / 2固有の疑似ヘッダーフィールド（[HTTP2]のセクション8.1.2.1を参照）を追加して、一般的なWebサイトで最も頻繁に使用されるヘッダーフィールドから作成されました。頻度の値が少ないヘッダーフィールドの場合、これらの頻度の値ごとにエントリが追加されました。他のヘッダーフィールドについては、空の値を持つエントリが追加されました。"
    },
    {
      "indent": 3,
      "text": "Table 1 lists the predefined header fields that make up the static table and gives the index of each entry.",
      "ja": "表1は、静的テーブルを構成する定義済みのヘッダーフィールドの一覧と、各エントリのインデックスを示しています。"
    },
    {
      "indent": 10,
      "text": "+-------+-----------------------------+---------------+\n| Index | Header Name                 | Header Value  |\n+-------+-----------------------------+---------------+\n| 1     | :authority                  |               |\n| 2     | :method                     | GET           |\n| 3     | :method                     | POST          |\n| 4     | :path                       | /             |\n| 5     | :path                       | /index.html   |\n| 6     | :scheme                     | http          |\n| 7     | :scheme                     | https         |\n| 8     | :status                     | 200           |\n| 9     | :status                     | 204           |\n| 10    | :status                     | 206           |\n| 11    | :status                     | 304           |\n| 12    | :status                     | 400           |\n| 13    | :status                     | 404           |\n| 14    | :status                     | 500           |\n| 15    | accept-charset              |               |\n| 16    | accept-encoding             | gzip, deflate |\n| 17    | accept-language             |               |\n| 18    | accept-ranges               |               |\n| 19    | accept                      |               |\n| 20    | access-control-allow-origin |               |\n| 21    | age                         |               |\n| 22    | allow                       |               |\n| 23    | authorization               |               |\n| 24    | cache-control               |               |\n| 25    | content-disposition         |               |\n| 26    | content-encoding            |               |\n| 27    | content-language            |               |\n| 28    | content-length              |               |\n| 29    | content-location            |               |\n| 30    | content-range               |               |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "| 31    | content-type                |               |\n| 32    | cookie                      |               |\n| 33    | date                        |               |\n| 34    | etag                        |               |\n| 35    | expect                      |               |\n| 36    | expires                     |               |\n| 37    | from                        |               |\n| 38    | host                        |               |\n| 39    | if-match                    |               |\n| 40    | if-modified-since           |               |\n| 41    | if-none-match               |               |\n| 42    | if-range                    |               |\n| 43    | if-unmodified-since         |               |\n| 44    | last-modified               |               |\n| 45    | link                        |               |\n| 46    | location                    |               |\n| 47    | max-forwards                |               |\n| 48    | proxy-authenticate          |               |\n| 49    | proxy-authorization         |               |\n| 50    | range                       |               |\n| 51    | referer                     |               |\n| 52    | refresh                     |               |\n| 53    | retry-after                 |               |\n| 54    | server                      |               |\n| 55    | set-cookie                  |               |\n| 56    | strict-transport-security   |               |\n| 57    | transfer-encoding           |               |\n| 58    | user-agent                  |               |\n| 59    | vary                        |               |\n| 60    | via                         |               |\n| 61    | www-authenticate            |               |\n+-------+-----------------------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 1: Static Table Entries",
      "ja": "表1：静的テーブルエントリ"
    },
    {
      "indent": 0,
      "text": "Appendix B. Huffman Code",
      "section_title": true,
      "ja": "付録B.ハフマンコード"
    },
    {
      "indent": 3,
      "text": "The following Huffman code is used when encoding string literals with a Huffman coding (see Section 5.2).",
      "ja": "次のハフマンコードは、文字列リテラルをハフマンコーディングでエンコードするときに使用されます（セクション5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "This Huffman code was generated from statistics obtained on a large sample of HTTP headers. It is a canonical Huffman code (see [CANONICAL]) with some tweaking to ensure that no symbol has a unique code length.",
      "ja": "このハフマンコードは、HTTPヘッダーの大量のサンプルで取得した統計から生成されました。これは正規のハフマンコード（[CANONICAL]を参照）であり、シンボルが一意のコード長を持たないように微調整されています。"
    },
    {
      "indent": 3,
      "text": "Each row in the table defines the code used to represent a symbol:",
      "ja": "テーブルの各行は、シンボルを表すために使用されるコードを定義します。"
    },
    {
      "indent": 3,
      "text": "sym: The symbol to be represented. It is the decimal value of an octet, possibly prepended with its ASCII representation. A specific symbol, \"EOS\", is used to indicate the end of a string literal.",
      "ja": "sym：表現するシンボル。これはオクテットの10進値であり、ASCII表現が前に付加されている可能性があります。特定の記号「EOS」は、文字列リテラルの終わりを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "code as bits: The Huffman code for the symbol represented as a base-2 integer, aligned on the most significant bit (MSB).",
      "ja": "ビットとしてのコード：最上位ビット（MSB）に揃えられた、基数2の整数として表されるシンボルのハフマンコード。"
    },
    {
      "indent": 3,
      "text": "code as hex: The Huffman code for the symbol, represented as a hexadecimal integer, aligned on the least significant bit (LSB).",
      "ja": "16進数としてのコード：16進整数として表され、最下位ビット（LSB）で整列されたシンボルのハフマンコード。"
    },
    {
      "indent": 3,
      "text": "len: The number of bits for the code representing the symbol.",
      "ja": "len：シンボルを表すコードのビット数。"
    },
    {
      "indent": 3,
      "text": "As an example, the code for the symbol 47 (corresponding to the ASCII character \"/\") consists in the 6 bits \"0\", \"1\", \"1\", \"0\", \"0\", \"0\". This corresponds to the value 0x18 (in hexadecimal) encoded in 6 bits.",
      "ja": "例として、記号47のコード（ASCII文字「/」に対応）は、6ビットの「0」、「1」、「1」、「0」、「0」、「0」で構成されています。これは、6ビットでエンコードされた値0x18（16進数）に対応します。"
    },
    {
      "indent": 3,
      "text": "                                                     code\n                       code as bits                 as hex   len\n     sym              aligned to MSB                aligned   in\n                                                    to LSB   bits\n    (  0)  |11111111|11000                             1ff8  [13]\n    (  1)  |11111111|11111111|1011000                7fffd8  [23]\n    (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]\n    (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]\n    (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]\n    (  5)  |11111111|11111111|11111110|0101         fffffe5  [28]\n    (  6)  |11111111|11111111|11111110|0110         fffffe6  [28]\n    (  7)  |11111111|11111111|11111110|0111         fffffe7  [28]\n    (  8)  |11111111|11111111|11111110|1000         fffffe8  [28]\n    (  9)  |11111111|11111111|11101010               ffffea  [24]\n    ( 10)  |11111111|11111111|11111111|111100      3ffffffc  [30]\n    ( 11)  |11111111|11111111|11111110|1001         fffffe9  [28]\n    ( 12)  |11111111|11111111|11111110|1010         fffffea  [28]\n    ( 13)  |11111111|11111111|11111111|111101      3ffffffd  [30] ( 14)  |11111111|11111111|11111110|1011         fffffeb  [28]\n    ( 15)  |11111111|11111111|11111110|1100         fffffec  [28]\n    ( 16)  |11111111|11111111|11111110|1101         fffffed  [28]\n    ( 17)  |11111111|11111111|11111110|1110         fffffee  [28]\n    ( 18)  |11111111|11111111|11111110|1111         fffffef  [28]\n    ( 19)  |11111111|11111111|11111111|0000         ffffff0  [28]\n    ( 20)  |11111111|11111111|11111111|0001         ffffff1  [28]\n    ( 21)  |11111111|11111111|11111111|0010         ffffff2  [28]\n    ( 22)  |11111111|11111111|11111111|111110      3ffffffe  [30]\n    ( 23)  |11111111|11111111|11111111|0011         ffffff3  [28]\n    ( 24)  |11111111|11111111|11111111|0100         ffffff4  [28]\n    ( 25)  |11111111|11111111|11111111|0101         ffffff5  [28]\n    ( 26)  |11111111|11111111|11111111|0110         ffffff6  [28]\n    ( 27)  |11111111|11111111|11111111|0111         ffffff7  [28]\n    ( 28)  |11111111|11111111|11111111|1000         ffffff8  [28]\n    ( 29)  |11111111|11111111|11111111|1001         ffffff9  [28]\n    ( 30)  |11111111|11111111|11111111|1010         ffffffa  [28]\n    ( 31)  |11111111|11111111|11111111|1011         ffffffb  [28]\n' ' ( 32)  |010100                                       14  [ 6]\n'!' ( 33)  |11111110|00                                 3f8  [10]\n'\"' ( 34)  |11111110|01                                 3f9  [10]\n'#' ( 35)  |11111111|1010                               ffa  [12]\n'$' ( 36)  |11111111|11001                             1ff9  [13]\n'%' ( 37)  |010101                                       15  [ 6]\n'&' ( 38)  |11111000                                     f8  [ 8]\n''' ( 39)  |11111111|010                                7fa  [11]\n'(' ( 40)  |11111110|10                                 3fa  [10]\n')' ( 41)  |11111110|11                                 3fb  [10]\n'*' ( 42)  |11111001                                     f9  [ 8]\n'+' ( 43)  |11111111|011                                7fb  [11]\n',' ( 44)  |11111010                                     fa  [ 8]\n'-' ( 45)  |010110                                       16  [ 6]\n'.' ( 46)  |010111                                       17  [ 6]\n'/' ( 47)  |011000                                       18  [ 6]\n'0' ( 48)  |00000                                         0  [ 5]\n'1' ( 49)  |00001                                         1  [ 5]\n'2' ( 50)  |00010                                         2  [ 5]\n'3' ( 51)  |011001                                       19  [ 6]\n'4' ( 52)  |011010                                       1a  [ 6]\n'5' ( 53)  |011011                                       1b  [ 6]\n'6' ( 54)  |011100                                       1c  [ 6]\n'7' ( 55)  |011101                                       1d  [ 6]\n'8' ( 56)  |011110                                       1e  [ 6]\n'9' ( 57)  |011111                                       1f  [ 6]\n':' ( 58)  |1011100                                      5c  [ 7]\n';' ( 59)  |11111011                                     fb  [ 8]\n'<' ( 60)  |11111111|1111100                           7ffc  [15]\n'=' ( 61)  |100000                                       20  [ 6]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "'>' ( 62)  |11111111|1011                               ffb  [12]\n'?' ( 63)  |11111111|00                                 3fc  [10]\n'@' ( 64)  |11111111|11010                             1ffa  [13]\n'A' ( 65)  |100001                                       21  [ 6]\n'B' ( 66)  |1011101                                      5d  [ 7]\n'C' ( 67)  |1011110                                      5e  [ 7]\n'D' ( 68)  |1011111                                      5f  [ 7]\n'E' ( 69)  |1100000                                      60  [ 7]\n'F' ( 70)  |1100001                                      61  [ 7]\n'G' ( 71)  |1100010                                      62  [ 7]\n'H' ( 72)  |1100011                                      63  [ 7]\n'I' ( 73)  |1100100                                      64  [ 7]\n'J' ( 74)  |1100101                                      65  [ 7]\n'K' ( 75)  |1100110                                      66  [ 7]\n'L' ( 76)  |1100111                                      67  [ 7]\n'M' ( 77)  |1101000                                      68  [ 7]\n'N' ( 78)  |1101001                                      69  [ 7]\n'O' ( 79)  |1101010                                      6a  [ 7]\n'P' ( 80)  |1101011                                      6b  [ 7]\n'Q' ( 81)  |1101100                                      6c  [ 7]\n'R' ( 82)  |1101101                                      6d  [ 7]\n'S' ( 83)  |1101110                                      6e  [ 7]\n'T' ( 84)  |1101111                                      6f  [ 7]\n'U' ( 85)  |1110000                                      70  [ 7]\n'V' ( 86)  |1110001                                      71  [ 7]\n'W' ( 87)  |1110010                                      72  [ 7]\n'X' ( 88)  |11111100                                     fc  [ 8]\n'Y' ( 89)  |1110011                                      73  [ 7]\n'Z' ( 90)  |11111101                                     fd  [ 8]\n'[' ( 91)  |11111111|11011                             1ffb  [13]\n'\\' ( 92)  |11111111|11111110|000                     7fff0  [19]\n']' ( 93)  |11111111|11100                             1ffc  [13]\n'^' ( 94)  |11111111|111100                            3ffc  [14]\n'_' ( 95)  |100010                                       22  [ 6]\n'`' ( 96)  |11111111|1111101                           7ffd  [15]\n'a' ( 97)  |00011                                         3  [ 5]\n'b' ( 98)  |100011                                       23  [ 6]\n'c' ( 99)  |00100                                         4  [ 5]\n'd' (100)  |100100                                       24  [ 6]\n'e' (101)  |00101                                         5  [ 5]\n'f' (102)  |100101                                       25  [ 6]\n'g' (103)  |100110                                       26  [ 6]\n'h' (104)  |100111                                       27  [ 6]\n'i' (105)  |00110                                         6  [ 5]\n'j' (106)  |1110100                                      74  [ 7]\n'k' (107)  |1110101                                      75  [ 7]\n'l' (108)  |101000                                       28  [ 6]\n'm' (109)  |101001                                       29  [ 6]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "'n' (110)  |101010                                       2a  [ 6]\n'o' (111)  |00111                                         7  [ 5]\n'p' (112)  |101011                                       2b  [ 6]\n'q' (113)  |1110110                                      76  [ 7]\n'r' (114)  |101100                                       2c  [ 6]\n's' (115)  |01000                                         8  [ 5]\n't' (116)  |01001                                         9  [ 5]\n'u' (117)  |101101                                       2d  [ 6]\n'v' (118)  |1110111                                      77  [ 7]\n'w' (119)  |1111000                                      78  [ 7]\n'x' (120)  |1111001                                      79  [ 7]\n'y' (121)  |1111010                                      7a  [ 7]\n'z' (122)  |1111011                                      7b  [ 7]\n'{' (123)  |11111111|1111110                           7ffe  [15]\n'|' (124)  |11111111|100                                7fc  [11]\n'}' (125)  |11111111|111101                            3ffd  [14]\n'~' (126)  |11111111|11101                             1ffd  [13]\n    (127)  |11111111|11111111|11111111|1100         ffffffc  [28]\n    (128)  |11111111|11111110|0110                    fffe6  [20]\n    (129)  |11111111|11111111|010010                 3fffd2  [22]\n    (130)  |11111111|11111110|0111                    fffe7  [20]\n    (131)  |11111111|11111110|1000                    fffe8  [20]\n    (132)  |11111111|11111111|010011                 3fffd3  [22]\n    (133)  |11111111|11111111|010100                 3fffd4  [22]\n    (134)  |11111111|11111111|010101                 3fffd5  [22]\n    (135)  |11111111|11111111|1011001                7fffd9  [23]\n    (136)  |11111111|11111111|010110                 3fffd6  [22]\n    (137)  |11111111|11111111|1011010                7fffda  [23]\n    (138)  |11111111|11111111|1011011                7fffdb  [23]\n    (139)  |11111111|11111111|1011100                7fffdc  [23]\n    (140)  |11111111|11111111|1011101                7fffdd  [23]\n    (141)  |11111111|11111111|1011110                7fffde  [23]\n    (142)  |11111111|11111111|11101011               ffffeb  [24]\n    (143)  |11111111|11111111|1011111                7fffdf  [23]\n    (144)  |11111111|11111111|11101100               ffffec  [24]\n    (145)  |11111111|11111111|11101101               ffffed  [24]\n    (146)  |11111111|11111111|010111                 3fffd7  [22]\n    (147)  |11111111|11111111|1100000                7fffe0  [23]\n    (148)  |11111111|11111111|11101110               ffffee  [24]\n    (149)  |11111111|11111111|1100001                7fffe1  [23]\n    (150)  |11111111|11111111|1100010                7fffe2  [23]\n    (151)  |11111111|11111111|1100011                7fffe3  [23]\n    (152)  |11111111|11111111|1100100                7fffe4  [23]\n    (153)  |11111111|11111110|11100                  1fffdc  [21]\n    (154)  |11111111|11111111|011000                 3fffd8  [22]\n    (155)  |11111111|11111111|1100101                7fffe5  [23]\n    (156)  |11111111|11111111|011001                 3fffd9  [22]\n    (157)  |11111111|11111111|1100110                7fffe6  [23] (158)  |11111111|11111111|1100111                7fffe7  [23]\n    (159)  |11111111|11111111|11101111               ffffef  [24]\n    (160)  |11111111|11111111|011010                 3fffda  [22]\n    (161)  |11111111|11111110|11101                  1fffdd  [21]\n    (162)  |11111111|11111110|1001                    fffe9  [20]\n    (163)  |11111111|11111111|011011                 3fffdb  [22]\n    (164)  |11111111|11111111|011100                 3fffdc  [22]\n    (165)  |11111111|11111111|1101000                7fffe8  [23]\n    (166)  |11111111|11111111|1101001                7fffe9  [23]\n    (167)  |11111111|11111110|11110                  1fffde  [21]\n    (168)  |11111111|11111111|1101010                7fffea  [23]\n    (169)  |11111111|11111111|011101                 3fffdd  [22]\n    (170)  |11111111|11111111|011110                 3fffde  [22]\n    (171)  |11111111|11111111|11110000               fffff0  [24]\n    (172)  |11111111|11111110|11111                  1fffdf  [21]\n    (173)  |11111111|11111111|011111                 3fffdf  [22]\n    (174)  |11111111|11111111|1101011                7fffeb  [23]\n    (175)  |11111111|11111111|1101100                7fffec  [23]\n    (176)  |11111111|11111111|00000                  1fffe0  [21]\n    (177)  |11111111|11111111|00001                  1fffe1  [21]\n    (178)  |11111111|11111111|100000                 3fffe0  [22]\n    (179)  |11111111|11111111|00010                  1fffe2  [21]\n    (180)  |11111111|11111111|1101101                7fffed  [23]\n    (181)  |11111111|11111111|100001                 3fffe1  [22]\n    (182)  |11111111|11111111|1101110                7fffee  [23]\n    (183)  |11111111|11111111|1101111                7fffef  [23]\n    (184)  |11111111|11111110|1010                    fffea  [20]\n    (185)  |11111111|11111111|100010                 3fffe2  [22]\n    (186)  |11111111|11111111|100011                 3fffe3  [22]\n    (187)  |11111111|11111111|100100                 3fffe4  [22]\n    (188)  |11111111|11111111|1110000                7ffff0  [23]\n    (189)  |11111111|11111111|100101                 3fffe5  [22]\n    (190)  |11111111|11111111|100110                 3fffe6  [22]\n    (191)  |11111111|11111111|1110001                7ffff1  [23]\n    (192)  |11111111|11111111|11111000|00           3ffffe0  [26]\n    (193)  |11111111|11111111|11111000|01           3ffffe1  [26]\n    (194)  |11111111|11111110|1011                    fffeb  [20]\n    (195)  |11111111|11111110|001                     7fff1  [19]\n    (196)  |11111111|11111111|100111                 3fffe7  [22]\n    (197)  |11111111|11111111|1110010                7ffff2  [23]\n    (198)  |11111111|11111111|101000                 3fffe8  [22]\n    (199)  |11111111|11111111|11110110|0            1ffffec  [25]\n    (200)  |11111111|11111111|11111000|10           3ffffe2  [26]\n    (201)  |11111111|11111111|11111000|11           3ffffe3  [26]\n    (202)  |11111111|11111111|11111001|00           3ffffe4  [26]\n    (203)  |11111111|11111111|11111011|110          7ffffde  [27]\n    (204)  |11111111|11111111|11111011|111          7ffffdf  [27]\n    (205)  |11111111|11111111|11111001|01           3ffffe5  [26] (206)  |11111111|11111111|11110001               fffff1  [24]\n    (207)  |11111111|11111111|11110110|1            1ffffed  [25]\n    (208)  |11111111|11111110|010                     7fff2  [19]\n    (209)  |11111111|11111111|00011                  1fffe3  [21]\n    (210)  |11111111|11111111|11111001|10           3ffffe6  [26]\n    (211)  |11111111|11111111|11111100|000          7ffffe0  [27]\n    (212)  |11111111|11111111|11111100|001          7ffffe1  [27]\n    (213)  |11111111|11111111|11111001|11           3ffffe7  [26]\n    (214)  |11111111|11111111|11111100|010          7ffffe2  [27]\n    (215)  |11111111|11111111|11110010               fffff2  [24]\n    (216)  |11111111|11111111|00100                  1fffe4  [21]\n    (217)  |11111111|11111111|00101                  1fffe5  [21]\n    (218)  |11111111|11111111|11111010|00           3ffffe8  [26]\n    (219)  |11111111|11111111|11111010|01           3ffffe9  [26]\n    (220)  |11111111|11111111|11111111|1101         ffffffd  [28]\n    (221)  |11111111|11111111|11111100|011          7ffffe3  [27]\n    (222)  |11111111|11111111|11111100|100          7ffffe4  [27]\n    (223)  |11111111|11111111|11111100|101          7ffffe5  [27]\n    (224)  |11111111|11111110|1100                    fffec  [20]\n    (225)  |11111111|11111111|11110011               fffff3  [24]\n    (226)  |11111111|11111110|1101                    fffed  [20]\n    (227)  |11111111|11111111|00110                  1fffe6  [21]\n    (228)  |11111111|11111111|101001                 3fffe9  [22]\n    (229)  |11111111|11111111|00111                  1fffe7  [21]\n    (230)  |11111111|11111111|01000                  1fffe8  [21]\n    (231)  |11111111|11111111|1110011                7ffff3  [23]\n    (232)  |11111111|11111111|101010                 3fffea  [22]\n    (233)  |11111111|11111111|101011                 3fffeb  [22]\n    (234)  |11111111|11111111|11110111|0            1ffffee  [25]\n    (235)  |11111111|11111111|11110111|1            1ffffef  [25]\n    (236)  |11111111|11111111|11110100               fffff4  [24]\n    (237)  |11111111|11111111|11110101               fffff5  [24]\n    (238)  |11111111|11111111|11111010|10           3ffffea  [26]\n    (239)  |11111111|11111111|1110100                7ffff4  [23]\n    (240)  |11111111|11111111|11111010|11           3ffffeb  [26]\n    (241)  |11111111|11111111|11111100|110          7ffffe6  [27]\n    (242)  |11111111|11111111|11111011|00           3ffffec  [26]\n    (243)  |11111111|11111111|11111011|01           3ffffed  [26]\n    (244)  |11111111|11111111|11111100|111          7ffffe7  [27]\n    (245)  |11111111|11111111|11111101|000          7ffffe8  [27]\n    (246)  |11111111|11111111|11111101|001          7ffffe9  [27]\n    (247)  |11111111|11111111|11111101|010          7ffffea  [27]\n    (248)  |11111111|11111111|11111101|011          7ffffeb  [27]\n    (249)  |11111111|11111111|11111111|1110         ffffffe  [28]\n    (250)  |11111111|11111111|11111101|100          7ffffec  [27]\n    (251)  |11111111|11111111|11111101|101          7ffffed  [27]\n    (252)  |11111111|11111111|11111101|110          7ffffee  [27]\n    (253)  |11111111|11111111|11111101|111          7ffffef  [27] (254)  |11111111|11111111|11111110|000          7fffff0  [27]\n    (255)  |11111111|11111111|11111011|10           3ffffee  [26]\nEOS (256)  |11111111|11111111|11111111|111111      3fffffff  [30]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples",
      "section_title": true,
      "ja": "付録C.例"
    },
    {
      "indent": 3,
      "text": "This appendix contains examples covering integer encoding, header field representation, and the encoding of whole lists of header fields for both requests and responses, with and without Huffman coding.",
      "ja": "この付録には、整数エンコーディング、ヘッダーフィールドの表現、およびリクエストとレスポンスの両方のヘッダーフィールドのリスト全体のエンコーディングをカバーする例が含まれています。"
    },
    {
      "indent": 0,
      "text": "C.1. Integer Representation Examples",
      "section_title": true,
      "ja": "C.1. 整数表現の例"
    },
    {
      "indent": 3,
      "text": "This section shows the representation of integer values in detail (see Section 5.1).",
      "ja": "このセクションでは、整数値の表現を詳細に示します（セクション5.1を参照）。"
    },
    {
      "indent": 0,
      "text": "C.1.1. Example 1: Encoding 10 Using a 5-Bit Prefix",
      "section_title": true,
      "ja": "C.1.1. 例1：5ビットのプレフィックスを使用して10をエンコードする"
    },
    {
      "indent": 3,
      "text": "The value 10 is to be encoded with a 5-bit prefix.",
      "ja": "値10は、5ビットのプレフィックスでエンコードされます。"
    },
    {
      "indent": 3,
      "text": "o 10 is less than 31 (2^5 - 1) and is represented using the 5-bit prefix.",
      "ja": "o 10は31（2 ^ 5-1）未満であり、5ビットのプレフィックスを使用して表されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.2. Example 2: Encoding 1337 Using a 5-Bit Prefix",
      "section_title": true,
      "ja": "C.1.2. 例2：5ビットのプレフィックスを使用して1337をエンコードする"
    },
    {
      "indent": 3,
      "text": "The value I=1337 is to be encoded with a 5-bit prefix.",
      "ja": "値I = 1337は、5ビットのプレフィックスでエンコードされます。"
    },
    {
      "indent": 6,
      "text": "1337 is greater than 31 (2^5 - 1).",
      "ja": "1337は31より大きい（2 ^ 5-1）。"
    },
    {
      "indent": 9,
      "text": "The 5-bit prefix is filled with its max value (31).",
      "ja": "5ビットのプレフィックスは、その最大値（31）で埋められます。"
    },
    {
      "indent": 6,
      "text": "I = 1337 - (2^5 - 1) = 1306.",
      "ja": "I = 1337-（2 ^ 5-1）= 1306。"
    },
    {
      "indent": 9,
      "text": "I (1306) is greater than or equal to 128, so the while loop body executes:",
      "ja": "I（1306）は128以上であるため、whileループ本体が実行されます。"
    },
    {
      "indent": 12,
      "text": "I % 128 == 26",
      "ja": "I％128 == 26"
    },
    {
      "indent": 12,
      "text": "26 + 128 == 154",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "154 is encoded in 8 bits as: 10011010",
      "ja": "154は8ビットでエンコードされます：10011010"
    },
    {
      "indent": 12,
      "text": "I is set to 10 (1306 / 128 == 10) I is no longer greater than or equal to 128, so the while loop terminates.",
      "ja": "私は10（1306/128 == 10）に設定されています。128以上になったため、whileループが終了します。"
    },
    {
      "indent": 9,
      "text": "I, now 10, is encoded in 8 bits as: 00001010.",
      "ja": "私は、現在10で、00001010のように8ビットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "The process ends.",
      "ja": "プロセスは終了します。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306\n| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128\n| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.3. Example 3: Encoding 42 Starting at an Octet Boundary",
      "section_title": true,
      "ja": "C.1.3. 例3：オクテット境界から始まるエンコード42"
    },
    {
      "indent": 3,
      "text": "The value 42 is to be encoded starting at an octet boundary. This implies that a 8-bit prefix is used.",
      "ja": "値42は、オクテット境界から開始してエンコードされます。これは、8ビットのプレフィックスが使用されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "o 42 is less than 255 (2^8 - 1) and is represented using the 8-bit prefix.",
      "ja": "o 42は255（2 ^ 8-1）未満で、8ビットのプレフィックスを使用して表されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |   42 stored on 8 bits\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. Header Field Representation Examples",
      "section_title": true,
      "ja": "C.2. ヘッダーフィールド表現の例"
    },
    {
      "indent": 3,
      "text": "This section shows several independent representation examples.",
      "ja": "このセクションでは、いくつかの独立した表現の例を示します。"
    },
    {
      "indent": 0,
      "text": "C.2.1. Literal Header Field with Indexing",
      "section_title": true,
      "ja": "C.2.1. インデックス付きのリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The header field representation uses a literal name and a literal value. The header field is added to the dynamic table.",
      "ja": "ヘッダーフィールドの表現では、リテラル名とリテラル値を使用します。ヘッダーフィールドが動的テーブルに追加されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "custom-key: custom-header",
      "ja": "custom-key：custom-header"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "400a 6375 7374 6f6d 2d6b 6579 0d63 7573 | @.custom-key.cus 746f 6d2d 6865 6164 6572 | tom-header Decoding process:",
      "ja": "400a 6375 7374 6f6d 2d6b 6579 0d63 7573 | @ .custom-key.cus 746f 6d2d 6865 6164 6572 |トムヘッダーのデコードプロセス："
    },
    {
      "indent": 3,
      "text": "40                                      | == Literal indexed ==\n0a                                      |   Literal name (len = 10)\n6375 7374 6f6d 2d6b 6579                | custom-key\n0d                                      |   Literal value (len = 13)\n6375 7374 6f6d 2d68 6561 6465 72        | custom-header\n                                        | -> custom-key:\n                                        |   custom-header",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 55) custom-key: custom-header Table size: 55",
      "ja": "[1]（s = 55）custom-key：custom-headerテーブルサイズ：55"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "custom-key: custom-header",
      "ja": "custom-key：custom-header"
    },
    {
      "indent": 0,
      "text": "C.2.2. Literal Header Field without Indexing",
      "section_title": true,
      "ja": "C.2.2. インデックスなしのリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The header field representation uses an indexed name and a literal value. The header field is not added to the dynamic table.",
      "ja": "ヘッダーフィールドの表現では、インデックス付きの名前とリテラル値を使用します。ヘッダーフィールドは動的テーブルに追加されません。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":path: /sample/path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "040c 2f73 616d 706c 652f 7061 7468 | ../sample/path",
      "ja": "040c 2f73 616d 706c 652f 7061 7468 | ../sample/path"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "04                                      | == Literal not indexed ==\n                                        |   Indexed name (idx = 4)\n                                        |     :path\n0c                                      |   Literal value (len = 12)\n2f73 616d 706c 652f 7061 7468           | /sample/path\n                                        | -> :path: /sample/path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "動的テーブル（デコード後）：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":path: /sample/path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2.3. Literal Header Field Never Indexed",
      "section_title": true,
      "ja": "C.2.3. リテラルヘッダーフィールドがインデックス付けされない"
    },
    {
      "indent": 3,
      "text": "The header field representation uses a literal name and a literal value. The header field is not added to the dynamic table and must use the same representation if re-encoded by an intermediary.",
      "ja": "ヘッダーフィールドの表現では、リテラル名とリテラル値を使用します。ヘッダーフィールドは動的テーブルに追加されず、中間者によって再エンコードされた場合、同じ表現を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "password: secret",
      "ja": "パスワード：シークレット"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "1008 7061 7373 776f 7264 0673 6563 7265 | ..password.secre 74 | t",
      "ja": "1008 7061 7373 776f 7264 0673 6563 7265 | ..password.secre 74 | t"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "10                                      | == Literal never indexed ==\n08                                      |   Literal name (len = 8)\n7061 7373 776f 7264                     | password\n06                                      |   Literal value (len = 6)\n7365 6372 6574                          | secret\n                                        | -> password: secret",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "動的テーブル（デコード後）：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "password: secret",
      "ja": "パスワード：シークレット"
    },
    {
      "indent": 0,
      "text": "C.2.4. Indexed Header Field",
      "section_title": true,
      "ja": "C.2.4. インデックス付きヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The header field representation uses an indexed header field from the static table.",
      "ja": "ヘッダーフィールド表現は、静的テーブルのインデックス付きヘッダーフィールドを使用します。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET",
      "ja": "：メソッド：GET"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "82 | .",
      "ja": "８２ ｜ 。"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "動的テーブル（デコード後）：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET",
      "ja": "：メソッド：GET"
    },
    {
      "indent": 0,
      "text": "C.3. Request Examples without Huffman Coding",
      "section_title": true,
      "ja": "C.3. ハフマンコーディングなしのリクエスト例"
    },
    {
      "indent": 3,
      "text": "This section shows several consecutive header lists, corresponding to HTTP requests, on the same connection.",
      "ja": "このセクションには、同じ接続でのHTTPリクエストに対応する、いくつかの連続したヘッダーリストが表示されます。"
    },
    {
      "indent": 0,
      "text": "C.3.1. First Request",
      "section_title": true,
      "ja": "C.3.1. 最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 8441 0f77 7777 2e65 7861 6d70 6c65 | ...A.www.example 2e63 6f6d | .com Decoding process:",
      "ja": "8286 8441 0f77 7777 2e65 7861 6d70 6c65 | ... A.www.example 2e63 6f6d | .comデコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n86                                      | == Indexed - Add ==\n                                        |   idx = 6\n                                        | -> :scheme: http\n84                                      | == Indexed - Add ==\n                                        |   idx = 4\n                                        | -> :path: /\n41                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 1)\n                                        |     :authority\n0f                                      |   Literal value (len = 15)\n7777 772e 6578 616d 706c 652e 636f 6d   | www.example.com\n                                        | -> :authority:\n                                        |   www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  57) :authority: www.example.com\n      Table size:  57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3.2. Second Request",
      "section_title": true,
      "ja": "C.3.2. 二つ目の要求"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com\ncache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 84be 5808 6e6f 2d63 6163 6865      | ....X.no-cache Decoding process:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n86                                      | == Indexed - Add ==\n                                        |   idx = 6\n                                        | -> :scheme: http\n84                                      | == Indexed - Add ==\n                                        |   idx = 4\n                                        | -> :path: /\nbe                                      | == Indexed - Add ==\n                                        |   idx = 62\n                                        | -> :authority:\n                                        |   www.example.com\n58                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 24)\n                                        |     cache-control\n08                                      |   Literal value (len = 8)\n6e6f 2d63 6163 6865                     | no-cache\n                                        | -> cache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  53) cache-control: no-cache\n[  2] (s =  57) :authority: www.example.com\n      Table size: 110",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com\ncache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3.3. Third Request",
      "section_title": true,
      "ja": "C.3.3. 3番目のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: https\n:path: /index.html\n:authority: www.example.com\ncustom-key: custom-value Hex dump of encoded data:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "8287 85bf 400a 6375 7374 6f6d 2d6b 6579 | ....@.custom-key\n0c63 7573 746f 6d2d 7661 6c75 65        | .custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n87                                      | == Indexed - Add ==\n                                        |   idx = 7\n                                        | -> :scheme: https\n85                                      | == Indexed - Add ==\n                                        |   idx = 5\n                                        | -> :path: /index.html\nbf                                      | == Indexed - Add ==\n                                        |   idx = 63\n                                        | -> :authority:\n                                        |   www.example.com\n40                                      | == Literal indexed ==\n0a                                      |   Literal name (len = 10)\n6375 7374 6f6d 2d6b 6579                | custom-key\n0c                                      |   Literal value (len = 12)\n6375 7374 6f6d 2d76 616c 7565           | custom-value\n                                        | -> custom-key:\n                                        |   custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  54) custom-key: custom-value\n[  2] (s =  53) cache-control: no-cache\n[  3] (s =  57) :authority: www.example.com\n      Table size: 164",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: https\n:path: /index.html\n:authority: www.example.com\ncustom-key: custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.4. Request Examples with Huffman Coding",
      "section_title": true,
      "ja": "C.4. ハフマンコーディングを使用したリクエストの例"
    },
    {
      "indent": 3,
      "text": "This section shows the same examples as the previous section but uses Huffman encoding for the literal values.",
      "ja": "このセクションでは、前のセクションと同じ例を示していますが、リテラル値にハフマンエンコーディングを使用しています。"
    },
    {
      "indent": 0,
      "text": "C.4.1. First Request",
      "section_title": true,
      "ja": "C.4.1. 最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 | ...A......:k....\nff                                      | .",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n86                                      | == Indexed - Add ==\n                                        |   idx = 6\n                                        | -> :scheme: http\n84                                      | == Indexed - Add ==\n                                        |   idx = 4\n                                        | -> :path: /\n41                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 1)\n                                        |     :authority\n8c                                      |   Literal value (len = 12)\n                                        |     Huffman encoded:\nf1e3 c2e5 f23a 6ba0 ab90 f4ff           | .....:k.....\n                                        |     Decoded:\n                                        | www.example.com\n                                        | -> :authority:\n                                        |   www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  57) :authority: www.example.com\n      Table size:  57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.4.2. Second Request",
      "section_title": true,
      "ja": "C.4.2. 二つ目の要求"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com\ncache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 84be 5886 a8eb 1064 9cbf           | ....X....d..",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n86                                      | == Indexed - Add ==\n                                        |   idx = 6\n                                        | -> :scheme: http\n84                                      | == Indexed - Add ==\n                                        |   idx = 4\n                                        | -> :path: /\nbe                                      | == Indexed - Add ==\n                                        |   idx = 62\n                                        | -> :authority:\n                                        |   www.example.com\n58                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 24)\n                                        |     cache-control\n86                                      |   Literal value (len = 6)\n                                        |     Huffman encoded:\na8eb 1064 9cbf                          | ...d..\n                                        |     Decoded:\n                                        | no-cache\n                                        | -> cache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  53) cache-control: no-cache\n[  2] (s =  57) :authority: www.example.com\n      Table size: 110",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: http\n:path: /\n:authority: www.example.com\ncache-control: no-cache",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.4.3. Third Request",
      "section_title": true,
      "ja": "C.4.3. 3番目のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: https\n:path: /index.html\n:authority: www.example.com\ncustom-key: custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "8287 85bf 4088 25a8 49e9 5ba9 7d7f 8925 | ....@.%.I.[.}..%\na849 e95b b8e8 b4bf                     | .I.[....",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "82                                      | == Indexed - Add ==\n                                        |   idx = 2\n                                        | -> :method: GET\n87                                      | == Indexed - Add ==\n                                        |   idx = 7\n                                        | -> :scheme: https\n85                                      | == Indexed - Add ==\n                                        |   idx = 5\n                                        | -> :path: /index.html\nbf                                      | == Indexed - Add ==\n                                        |   idx = 63\n                                        | -> :authority:\n                                        |   www.example.com\n40                                      | == Literal indexed ==\n88                                      |   Literal name (len = 8)\n                                        |     Huffman encoded:\n25a8 49e9 5ba9 7d7f                     | %.I.[.}.\n                                        |     Decoded:\n                                        | custom-key\n89                                      |   Literal value (len = 9)\n                                        |     Huffman encoded:\n25a8 49e9 5bb8 e8b4 bf                  | %.I.[....\n                                        |     Decoded:\n                                        | custom-value\n                                        | -> custom-key:\n                                        |   custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  54) custom-key: custom-value\n[  2] (s =  53) cache-control: no-cache\n[  3] (s =  57) :authority: www.example.com\n      Table size: 164",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET\n:scheme: https\n:path: /index.html\n:authority: www.example.com\ncustom-key: custom-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5. Response Examples without Huffman Coding",
      "section_title": true,
      "ja": "C.5. ハフマンコーディングなしの応答の例"
    },
    {
      "indent": 3,
      "text": "This section shows several consecutive header lists, corresponding to HTTP responses, on the same connection. The HTTP/2 setting parameter SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some evictions to occur.",
      "ja": "このセクションには、同じ接続での、HTTP応答に対応するいくつかの連続したヘッダーリストが表示されます。 HTTP / 2設定パラメーターSETTINGS_HEADER_TABLE_SIZEが256オクテットの値に設定されているため、一部のエビクションが発生します。"
    },
    {
      "indent": 0,
      "text": "C.5.1. First Response",
      "section_title": true,
      "ja": "C.5.1. 最初の応答"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "4803 3330 3258 0770 7269 7661 7465 611d | H.302X.privatea. 4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013 2032 303a 3133 3a32 3120 474d 546e 1768 | 20:13:21 GMTn.h 7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps://www.examp 6c65 2e63 6f6d | le.com",
      "ja": "4803 3330 3258 0770 7269 7661 7465 611d | H.302X.privatea。 4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | 2013年10月21日（月）2032 303a 3133 3a32 3120 474d 546e 1768 | 20:13:21 GMTn.h 7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps：//www.examp 6c65 2e63 6f6d | le.com"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "48                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 8)\n                                        |     :status\n03                                      |   Literal value (len = 3)\n3330 32                                 | 302\n                                        | -> :status: 302\n58                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 24)\n                                        |     cache-control\n07                                      |   Literal value (len = 7)\n7072 6976 6174 65                       | private\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n1d                                      |   Literal value (len = 29)\n4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013\n2032 303a 3133 3a32 3120 474d 54        |  20:13:21 GMT\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:21 GMT\n6e                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 46)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                                        |     location\n17                                      |   Literal value (len = 23)\n6874 7470 733a 2f2f 7777 772e 6578 616d | https://www.exam\n706c 652e 636f 6d                       | ple.com\n                                        | -> location:\n                                        |   https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  63) location: https://www.example.com\n[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT\n[  3] (s =  52) cache-control: private\n[  4] (s =  42) :status: 302\n      Table size: 222",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5.2. Second Response",
      "section_title": true,
      "ja": "C.5.2. 2番目の応答"
    },
    {
      "indent": 3,
      "text": "The (\":status\", \"302\") header field is evicted from the dynamic table to free space to allow adding the (\":status\", \"307\") header field.",
      "ja": "（ \"：status\"、 \"302\"）ヘッダーフィールドは、動的テーブルから解放され、（ \"：status\"、 \"307\"）ヘッダーフィールドを追加できるようにスペースが解放されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "4803 3330 37c1 c0bf | H.307...",
      "ja": "4803 3330 37c1 c0bf | H.307 ..."
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "48                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 8)\n                                        |     :status\n03                                      |   Literal value (len = 3)\n3330 37                                 | 307\n                                        | - evict: :status: 302\n                                        | -> :status: 307\nc1                                      | == Indexed - Add ==",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                                        |   idx = 65\n                                        | -> cache-control: private\nc0                                      | == Indexed - Add ==\n                                        |   idx = 64\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:21 GMT\nbf                                      | == Indexed - Add ==\n                                        |   idx = 63\n                                        | -> location:\n                                        |   https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  42) :status: 307\n[  2] (s =  63) location: https://www.example.com\n[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT\n[  4] (s =  52) cache-control: private\n      Table size: 222",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5.3. Third Response",
      "section_title": true,
      "ja": "C.5.3. 3番目の応答"
    },
    {
      "indent": 3,
      "text": "Several header fields are evicted from the dynamic table during the processing of this header list.",
      "ja": "このヘッダーリストの処理中に、動的テーブルからいくつかのヘッダーフィールドが削除されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200 cache-control: private date: Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content-encoding: gzip set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1 Hex dump of encoded data:",
      "ja": "：status：200 cache-control：private date：Mon、21 Oct 2013 20:13:22 GMT location：https://www.example.com content-encoding：gzip set-cookie：foo = ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age = 3600; version = 1エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "88c1 611d 4d6f 6e2c 2032 3120 4f63 7420 | ..a.Mon, 21 Oct 3230 3133 2032 303a 3133 3a32 3220 474d | 2013 20:13:22 GM 54c0 5a04 677a 6970 7738 666f 6f3d 4153 | T.Z.gzipw8foo=AS 444a 4b48 514b 425a 584f 5157 454f 5049 | DJKHQKBZXOQWEOPI 5541 5851 5745 4f49 553b 206d 6178 2d61 | UAXQWEOIU; max-a 6765 3d33 3630 303b 2076 6572 7369 6f6e | ge=3600; version 3d31 | =1",
      "ja": "88c1 611d 4d6f 6e2c 2032 3120 4f63 7420 | ..a.Mon、2130年12月3230 3133 2032 303a 3133 3a32 3220 474d | 2013 20:13:22 GM 54c0 5a04 677a 6970 7738 666f 6f3d 4153 | T.Z.gzipw8foo = AS 444a 4b48 514b 425a 584f 5157 454f 5049 | DJKHQKBZXOQWEOPI 5541 5851 5745 4f49 553b 206d 6178 2d61 | UAXQWEOIU; max-a 6765 3d33 3630 303b 2076 6572 7369 6f6e | ge = 3600;バージョン3d31 | = 1"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "88                                      | == Indexed - Add ==\n                                        |   idx = 8\n                                        | -> :status: 200\nc1                                      | == Indexed - Add ==\n                                        |   idx = 65\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n1d                                      |   Literal value (len = 29)\n4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013\n2032 303a 3133 3a32 3220 474d 54        |  20:13:22 GMT\n                                        | - evict: cache-control:\n                                        |   private\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:22 GMT\nc0                                      | == Indexed - Add ==\n                                        |   idx = 64\n                                        | -> location:\n                                        |   https://www.example.com\n5a                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 26)\n                                        |     content-encoding\n04                                      |   Literal value (len = 4)\n677a 6970                               | gzip\n                                        | - evict: date: Mon, 21 Oct\n                                        |    2013 20:13:21 GMT\n                                        | -> content-encoding: gzip\n77                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 55)\n                                        |     set-cookie\n38                                      |   Literal value (len = 56)\n666f 6f3d 4153 444a 4b48 514b 425a 584f | foo=ASDJKHQKBZXO\n5157 454f 5049 5541 5851 5745 4f49 553b | QWEOPIUAXQWEOIU;\n206d 6178 2d61 6765 3d33 3630 303b 2076 |  max-age=3600; v\n6572 7369 6f6e 3d31                     | ersion=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 43,
      "text": "| - evict: location:\n|   https://www.example.com\n| - evict: :status: 307\n| -> set-cookie: foo=ASDJKHQ\n|   KBZXOQWEOPIUAXQWEOIU; ma\n|   x-age=3600; version=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU;\n                 max-age=3600; version=1\n[  2] (s =  52) content-encoding: gzip\n[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT\n      Table size: 215",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:22 GMT\nlocation: https://www.example.com\ncontent-encoding: gzip\nset-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.6. Response Examples with Huffman Coding",
      "section_title": true,
      "ja": "C.6. ハフマンコーディングを使用した応答の例"
    },
    {
      "indent": 3,
      "text": "This section shows the same examples as the previous section but uses Huffman encoding for the literal values. The HTTP/2 setting parameter SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some evictions to occur. The eviction mechanism uses the length of the decoded literal values, so the same evictions occur as in the previous section.",
      "ja": "このセクションでは、前のセクションと同じ例を示していますが、リテラル値にハフマンエンコーディングを使用しています。 HTTP / 2設定パラメーターSETTINGS_HEADER_TABLE_SIZEが256オクテットの値に設定されているため、一部のエビクションが発生します。エビクションメカニズムは、デコードされたリテラル値の長さを使用するため、前のセクションと同じエビクションが発生します。"
    },
    {
      "indent": 0,
      "text": "C.6.1. First Response",
      "section_title": true,
      "ja": "C.6.1. 最初の応答"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "4882 6402 5885 aec3 771a 4b61 96d0 7abe | H.d.X...w.Ka..z.\n9410 54d4 44a8 2005 9504 0b81 66e0 82a6 | ..T.D. .....f...\n2d1b ff6e 919d 29ad 1718 63c7 8f0b 97c8 | -..n..)...c.....\ne9ae 82ae 43d3                          | ....C.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "48                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 8)\n                                        |     :status\n82                                      |   Literal value (len = 2)\n                                        |     Huffman encoded:\n6402                                    | d.\n                                        |     Decoded:\n                                        | 302\n                                        | -> :status: 302\n58                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 24)\n                                        |     cache-control\n85                                      |   Literal value (len = 5)\n                                        |     Huffman encoded:\naec3 771a 4b                            | ..w.K\n                                        |     Decoded:\n                                        | private\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n96                                      |   Literal value (len = 22)\n                                        |     Huffman encoded:\nd07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f\ne082 a62d 1bff                          | ...-..\n                                        |     Decoded:\n                                        | Mon, 21 Oct 2013 20:13:21\n                                        | GMT\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:21 GMT\n6e                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 46)\n                                        |     location\n91                                      |   Literal value (len = 17)\n                                        |     Huffman encoded:\n9d29 ad17 1863 c78f 0b97 c8e9 ae82 ae43 | .)...c.........C\nd3                                      | .\n                                        |     Decoded:\n                                        | https://www.example.com\n                                        | -> location:\n                                        |   https://www.example.com",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  63) location: https://www.example.com\n[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT\n[  3] (s =  52) cache-control: private\n[  4] (s =  42) :status: 302\n      Table size: 222",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.6.2. Second Response",
      "section_title": true,
      "ja": "C.6.2. 2番目の応答"
    },
    {
      "indent": 3,
      "text": "The (\":status\", \"302\") header field is evicted from the dynamic table to free space to allow adding the (\":status\", \"307\") header field.",
      "ja": "（ \"：status\"、 \"302\"）ヘッダーフィールドは、動的テーブルから解放され、（ \"：status\"、 \"307\"）ヘッダーフィールドを追加できるようにスペースが解放されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "4883 640e ffc1 c0bf                     | H.d.....",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "48                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 8)\n                                        |     :status\n83                                      |   Literal value (len = 3)\n                                        |     Huffman encoded:\n640e ff                                 | d..\n                                        |     Decoded:\n                                        | 307\n                                        | - evict: :status: 302\n                                        | -> :status: 307\nc1                                      | == Indexed - Add ==\n                                        |   idx = 65\n                                        | -> cache-control: private\nc0                                      | == Indexed - Add ==\n                                        |   idx = 64",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:21 GMT\nbf                                      | == Indexed - Add ==\n                                        |   idx = 63\n                                        | -> location:\n                                        |   https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  42) :status: 307\n[  2] (s =  63) location: https://www.example.com\n[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT\n[  4] (s =  52) cache-control: private\n      Table size: 222",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:21 GMT\nlocation: https://www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.6.3. Third Response",
      "section_title": true,
      "ja": "C.6.3. 3番目の応答"
    },
    {
      "indent": 3,
      "text": "Several header fields are evicted from the dynamic table during the processing of this header list.",
      "ja": "このヘッダーリストの処理中に、動的テーブルからいくつかのヘッダーフィールドが削除されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードするヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:22 GMT\nlocation: https://www.example.com\ncontent-encoding: gzip\nset-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "エンコードされたデータの16進ダンプ："
    },
    {
      "indent": 3,
      "text": "88c1 6196 d07a be94 1054 d444 a820 0595 | ..a..z...T.D. ..\n040b 8166 e084 a62d 1bff c05a 839b d9ab | ...f...-...Z....\n77ad 94e7 821d d7f2 e6c7 b335 dfdf cd5b | w..........5...[\n3960 d5af 2708 7f36 72c1 ab27 0fb5 291f | 9`..'..6r..'..).\n9587 3160 65c0 03ed 4ee5 b106 3d50 07   | ..1`e...N...=P.",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "デコードプロセス："
    },
    {
      "indent": 3,
      "text": "88                                      | == Indexed - Add ==\n                                        |   idx = 8\n                                        | -> :status: 200\nc1                                      | == Indexed - Add ==\n                                        |   idx = 65\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n96                                      |   Literal value (len = 22)\n                                        |     Huffman encoded:\nd07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f\ne084 a62d 1bff                          | ...-..\n                                        |     Decoded:\n                                        | Mon, 21 Oct 2013 20:13:22\n                                        | GMT\n                                        | - evict: cache-control:\n                                        |   private\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:22 GMT\nc0                                      | == Indexed - Add ==\n                                        |   idx = 64\n                                        | -> location:\n                                        |   https://www.example.com\n5a                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 26)\n                                        |     content-encoding\n83                                      |   Literal value (len = 3)\n                                        |     Huffman encoded:\n9bd9 ab                                 | ...\n                                        |     Decoded:\n                                        | gzip\n                                        | - evict: date: Mon, 21 Oct\n                                        |    2013 20:13:21 GMT\n                                        | -> content-encoding: gzip\n77                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 55)\n                                        |     set-cookie\nad                                      |   Literal value (len = 45)\n                                        |     Huffman encoded:\n94e7 821d d7f2 e6c7 b335 dfdf cd5b 3960 | .........5...[9`\nd5af 2708 7f36 72c1 ab27 0fb5 291f 9587 | ..'..6r..'..)...\n3160 65c0 03ed 4ee5 b106 3d50 07        | 1`e...N...=P.\n                                        |     Decoded:\n                                        | foo=ASDJKHQKBZXOQWEOPIUAXQ\n                                        | WEOIU; max-age=3600; versi",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 43,
      "text": "| on=1\n| - evict: location:\n|   https://www.example.com\n| - evict: :status: 307\n| -> set-cookie: foo=ASDJKHQ\n|   KBZXOQWEOPIUAXQWEOIU; ma\n|   x-age=3600; version=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "動的テーブル（デコード後）："
    },
    {
      "indent": 3,
      "text": "[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU;\n                 max-age=3600; version=1\n[  2] (s =  52) content-encoding: gzip\n[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT\n      Table size: 215",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200\ncache-control: private\ndate: Mon, 21 Oct 2013 20:13:22 GMT\nlocation: https://www.example.com\ncontent-encoding: gzip\nset-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This specification includes substantial input from the following individuals:",
      "ja": "この仕様には、次の個人からの実質的な情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Mike Bishop, Jeff Pinner, Julian Reschke, and Martin Thomson (substantial editorial contributions).",
      "ja": "o Mike Bishop、Jeff Pinner、Julian Reschke、Martin Thomson（編集者による多大な貢献）。"
    },
    {
      "indent": 3,
      "text": "o Johnny Graettinger (Huffman code statistics).",
      "ja": "o Johnny Graettinger（ハフマンコード統計）。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roberto Peon Google, Inc",
      "ja": "Roberto Peon Google、Inc"
    },
    {
      "indent": 3,
      "text": "EMail: fenix@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Herve Ruellan Canon CRF",
      "ja": "Herve Ruellan Canon CRF"
    },
    {
      "indent": 3,
      "text": "EMail: herve.ruellan@crf.canon.fr",
      "raw": true,
      "ja": ""
    }
  ]
}