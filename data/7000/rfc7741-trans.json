{
  "title": {
    "text": "RFC 7741 - RTP Payload Format for VP8 Video",
    "ja": "RFC 7741 - VP8ビデオのRTPペイロード形式"
  },
  "number": 7741,
  "created_at": "2020-08-30 09:01:40.544727+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         P. Westin\nRequest for Comments: 7741                                     H. Lundin\nCategory: Standards Track                                         Google\nISSN: 2070-1721                                                M. Glover\n                                                                 Twitter\n                                                               J. Uberti\n                                                             F. Galligan\n                                                                  Google\n                                                              March 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "RTP Payload Format for VP8 Video",
      "ja": "VP8ビデオのRTPペイロード形式"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This memo describes an RTP payload format for the VP8 video codec. The payload format has wide applicability, as it supports applications from low-bitrate peer-to-peer usage to high-bitrate video conferences.",
      "ja": "このメモは、VP8ビデオコーデックのRTPペイロード形式について説明しています。ペイロード形式は、低ビットレートのピアツーピアの使用から高ビットレートのビデオ会議までのアプリケーションをサポートするため、幅広い適用性があります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7741.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7741で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Conventions, Definitions, and Abbreviations .....................3\n3. Media Format Description ........................................4\n4. Payload Format ..................................................5\n   4.1. RTP Header Usage ...........................................6\n   4.2. VP8 Payload Descriptor .....................................7\n   4.3. VP8 Payload Header ........................................11\n   4.4. Aggregated and Fragmented Payloads ........................12\n   4.5. Example Algorithms ........................................13\n        4.5.1. Frame Reconstruction Algorithm .....................13\n        4.5.2. Partition Reconstruction Algorithm .................13\n   4.6. Examples of VP8 RTP Stream ................................14\n        4.6.1. Key Frame in a Single RTP Packet ...................14\n        4.6.2. Non-discardable VP8 Interframe in a Single\n               RTP Packet; No PictureID ...........................14\n        4.6.3. VP8 Partitions in Separate RTP Packets .............15\n        4.6.4. VP8 Frame Fragmented across RTP Packets ............16\n        4.6.5. VP8 Frame with Long PictureID ......................18\n5. Using VP8 with RPSI and SLI Feedback ...........................18\n   5.1. RPSI ......................................................18\n   5.2. SLI .......................................................19\n   5.3. Example ...................................................19\n6. Payload Format Parameters ......................................21\n   6.1. Media Type Definition .....................................21\n   6.2. SDP Parameters ............................................23\n        6.2.1. Mapping of Media Subtype Parameters to SDP .........23\n        6.2.2. Offer/Answer Considerations ........................23\n7. Security Considerations ........................................24\n8. Congestion Control .............................................24\n9. IANA Considerations ............................................24\n10. References ....................................................25\n   10.1. Normative References .....................................25\n   10.2. Informative References ...................................26\nAuthors' Addresses ................................................28",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo describes an RTP payload specification applicable to the transmission of video streams encoded using the VP8 video codec [RFC6386]. The format described in this document can be used both in peer-to-peer and video-conferencing applications.",
      "ja": "このメモは、VP8ビデオコーデック[RFC6386]を使用してエンコードされたビデオストリームの送信に適用可能なRTPペイロード仕様について説明しています。このドキュメントで説明されている形式は、ピアツーピアアプリケーションとビデオ会議アプリケーションの両方で使用できます。"
    },
    {
      "indent": 3,
      "text": "VP8 is based on the decomposition of frames into square sub-blocks of pixels known as \"macroblocks\" (see Section 2 of [RFC6386]). Prediction of such sub-blocks using previously constructed blocks, and adjustment of such predictions (as well as synthesis of unpredicted blocks) is done using a discrete cosine transform (hereafter abbreviated as DCT). In one special case, however, VP8 uses a \"Walsh-Hadamard\" transform (hereafter abbreviated as WHT) instead of a DCT. An encoded VP8 frame is divided into two or more partitions, as described in [RFC6386]. The first partition (prediction or mode) contains prediction mode parameters and motion vectors for all macroblocks. The remaining partitions all contain the quantized DCT/WHT coefficients for the residuals. There can be 1, 2, 4, or 8 DCT/WHT partitions per frame, depending on encoder settings.",
      "ja": "VP8は、「マクロブロック」と呼ばれるピクセルの正方形のサブブロックへのフレームの分解に基づいています（[RFC6386]のセクション2を参照）。以前に構築されたブロックを使用したそのようなサブブロックの予測、およびそのような予測の調整（および予測されないブロックの合成）は、離散コサイン変換（以下、DCTと略記）を使用して行われます。ただし、1つの特殊なケースでは、VP8はDCTの代わりに「ウォルシュ-アダマール」変換（以下、WHTと略記）を使用します。エンコードされたVP8フレームは、[RFC6386]で説明されているように、2つ以上のパーティションに分割されます。最初のパーティション（予測またはモード）には、すべてのマクロブロックの予測モードパラメータと動きベクトルが含まれています。残りのパーティションにはすべて、残差の量子化されたDCT / WHT係数が含まれています。エンコーダーの設定に応じて、フレームごとに1、2、4、または8個のDCT / WHTパーティションがあります。"
    },
    {
      "indent": 3,
      "text": "In summary, the payload format described in this document enables a number of features in VP8, including:",
      "ja": "要約すると、このドキュメントで説明されているペイロード形式は、VP8で次のような多くの機能を有効にします。"
    },
    {
      "indent": 3,
      "text": "o Taking partition boundaries into consideration, to improve loss robustness and facilitate efficient packet-loss concealment at the decoder.",
      "ja": "o パーティションの境界を考慮して、損失のロバスト性を改善し、デコーダーでのパケット損失の隠蔽を効率化します。"
    },
    {
      "indent": 3,
      "text": "o Temporal scalability.",
      "ja": "o 時間的スケーラビリティ。"
    },
    {
      "indent": 3,
      "text": "o Advanced use of reference frames to enable efficient error recovery.",
      "ja": "o 効率的なエラー回復を可能にする参照フレームの高度な使用。"
    },
    {
      "indent": 3,
      "text": "o Marking of frames that have no impact on the decoding of any other frame, so that these non-reference frames can be discarded in a server or media-aware network element if needed.",
      "ja": "o 他のフレームのデコードに影響を与えないフレームのマーキング。これらの非参照フレームは、必要に応じてサーバーまたはメディア対応ネットワーク要素で破棄できます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions, Definitions, and Abbreviations",
      "section_title": true,
      "ja": "2. 表記法、定義、および略語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the definitions of [RFC6386]. In particular, the following terms are used.",
      "ja": "このドキュメントでは、[RFC6386]の定義を使用しています。特に、次の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "Key frames: Frames that are decoded without reference to any other frame in a sequence (also called intraframes and I-frames).",
      "ja": "キーフレーム：シーケンス内の他のフレームを参照せずにデコードされるフレーム（イントラフレームおよびIフレームとも呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "Interframes: Frames that are encoded with reference to prior frames, specifically all prior frames up to and including the most recent key frame (also called prediction frames and P-frames).",
      "ja": "インターフレーム：前のフレームを参照してエンコードされたフレーム。具体的には、最新のキーフレームまでのすべての前のフレーム（予測フレームおよびPフレームとも呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "Golden and altref frames: alternate prediction frames. Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame.",
      "ja": "ゴールデンフレームとaltrefフレーム：代替予測フレーム。インターフレーム内のブロックは、直前のフレーム内のブロックと最新のゴールデンフレームまたはaltrefフレームを使用して予測できます。すべてのキーフレームは自動的にゴールデンおよびaltrefであり、インターフレームはオプションで最新のゴールデンまたはaltrefフレームを置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "Macroblock: a square array of pixels whose Y (luminance) dimensions are 16x16 pixels and whose U and V (chrominance) dimensions are 8x8 pixels.",
      "ja": "マクロブロック：Y（輝度）次元が16x16ピクセルで、UとV（クロミナンス）次元が8x8ピクセルの正方形のピクセル配列。"
    },
    {
      "indent": 3,
      "text": "Two definitions from [RFC4585] are also used in this document.",
      "ja": "このドキュメントでは、[RFC4585]の2つの定義も使用されています。"
    },
    {
      "indent": 3,
      "text": "RPSI: Reference picture selection indication. A feedback message to let the encoder know that the decoder has correctly decoded a certain frame.",
      "ja": "RPSI：参照画像選択表示。デコーダーが特定のフレームを正しくデコードしたことをエンコーダーに知らせるフィードバックメッセージ。"
    },
    {
      "indent": 3,
      "text": "SLI: Slice loss indication. A feedback message to let a decoder inform an encoder that it has detected the loss or corruption of one or several macroblocks.",
      "ja": "SLI：スライス損失の表示。 1つまたはいくつかのマクロブロックの損失または破損を検出したことをデコーダーにエンコーダーに通知させるフィードバックメッセージ。"
    },
    {
      "indent": 0,
      "text": "3. Media Format Description",
      "section_title": true,
      "ja": "3. メディア形式の説明"
    },
    {
      "indent": 3,
      "text": "The VP8 codec uses three different reference frames for interframe prediction: the previous frame, the golden frame, and the altref frame. Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame. Golden frames and altref frames may also be used to increase the tolerance to dropped frames. The payload specification in this memo has elements that enable advanced use of the reference frames, e.g., for improved loss robustness.",
      "ja": "VP8コーデックは、フレーム間予測に3つの異なる参照フレームを使用します。前のフレーム、ゴールデンフレーム、およびaltrefフレームです。インターフレーム内のブロックは、直前のフレーム内のブロックと最新のゴールデンフレームまたはaltrefフレームを使用して予測できます。すべてのキーフレームは自動的にゴールデンおよびaltrefであり、インターフレームはオプションで最新のゴールデンまたはaltrefフレームを置き換えることができます。ゴールデンフレームとaltrefフレームを使用して、ドロップされたフレームへの耐性を高めることもできます。このメモのペイロード仕様には、参照フレームの高度な使用を可能にする要素が含まれています。"
    },
    {
      "indent": 0,
      "text": " One specific use case of the three reference frame types is temporal scalability. By setting up the reference hierarchy in the appropriate way, up to five temporal layers can be encoded. (How to set up the reference hierarchy for temporal scalability is not within the scope of this memo.) Support for temporal scalability is provided by the optional TL0PICIDX and TID/Y/KEYIDX fields described in Section 4.2. For a general description of temporal scalability for video coding, see [Sch07].",
      "ja": "3つの参照フレームタイプの1つの具体的な使用例は、時間的なスケーラビリティです。適切な方法で参照階層を設定することにより、最大5つの時間レイヤーをエンコードできます。 （時間スケーラビリティの参照階層を設定する方法は、このメモの範囲外です。）時間スケーラビリティのサポートは、セクション4.2で説明されているオプションのTL0PICIDXおよびTID / Y / KEYIDXフィールドによって提供されます。ビデオコーディングの時間的スケーラビリティの一般的な説明については、[Sch07]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Another property of the VP8 codec is that it applies data partitioning to the encoded data. Thus, an encoded VP8 frame can be divided into two or more partitions, as described in \"VP8 Data Format and Decoding Guide\" [RFC6386]. The first partition (prediction or mode) contains prediction mode parameters and motion vectors for all macroblocks. The remaining partitions all contain the transform coefficients for the residuals. The first partition is decodable without the remaining residual partitions. The subsequent partitions may be useful even if some part of the frame is lost. Accordingly, this document RECOMMENDS that the frame be packetized by the sender with each data partition in a separate packet or packets. This may be beneficial for decoder-side error concealment, and the payload format described in Section 4 provides fields that allow the partitions to be identified even if the first partition is not available. The sender can, alternatively, aggregate the data partitions into a single data stream and, optionally, split it into several packets without consideration of the partition boundaries. The receiver can use the length information in the first partition to identify the partitions during decoding.",
      "ja": "VP8コーデックのもう1つの特性は、エンコードされたデータにデータ分割を適用することです。したがって、「VP8データ形式とデコードガイド」[RFC6386]で説明されているように、エンコードされたVP8フレームは2つ以上のパーティションに分割できます。最初のパーティション（予測またはモード）には、すべてのマクロブロックの予測モードパラメータと動きベクトルが含まれています。残りのパーティションにはすべて、残差の変換係数が含まれています。最初のパーティションは、残りの残りのパーティションなしでデコード可能です。フレームの一部が失われた場合でも、後続のパーティションは役立つ場合があります。したがって、このドキュメントでは、送信者がフレームをパケット化し、各データパーティションを個別のパケットにパケット化することを推奨しています。これは、デコーダー側のエラー隠蔽に役立つ可能性があり、セクション4で説明するペイロード形式は、最初のパーティションが利用できない場合でもパーティションを識別できるフィールドを提供します。あるいは、送信側は、データパーティションを単一のデータストリームに集約し、オプションで、パーティションの境界を考慮せずに複数のパケットに分割できます。受信機は、最初のパーティションの長さ情報を使用して、デコード中にパーティションを識別できます。"
    },
    {
      "indent": 3,
      "text": "The format specification is described in Section 4. In Section 5, a method to acknowledge receipt of reference frames using RTCP techniques is described.",
      "ja": "フォーマット仕様については、セクション4で説明します。セクション5では、RTCP技術を使用して参照フレームの受信を確認する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The payload partitioning and the acknowledging method both serve as motivation for three of the fields included in the payload format: the \"PID\", \"1st partition size\", and \"PictureID\" fields. The ability to encode a temporally scalable stream motivates the \"TL0PICIDX\" and \"TID\" fields.",
      "ja": "ペイロードのパーティショニングと確認方法の両方が、ペイロード形式に含まれる3つのフィールド「PID」、「1番目のパーティションサイズ」、および「PictureID」フィールドの動機として機能します。時間的にスケーラブルなストリームをエンコードする機能は、「TL0PICIDX」および「TID」フィールドを動機付けます。"
    },
    {
      "indent": 0,
      "text": "4. Payload Format",
      "section_title": true,
      "ja": "4. ペイロード形式"
    },
    {
      "indent": 3,
      "text": "This section describes how the encoded VP8 bitstream is encapsulated in RTP. To handle network losses, usage of RTP/AVPF [RFC4585] is RECOMMENDED. All integer fields in the specifications are encoded as unsigned integers in network octet order.",
      "ja": "このセクションでは、エンコードされたVP8ビットストリームがRTPにカプセル化される方法について説明します。ネットワーク損失を処理するには、RTP / AVPF [RFC4585]の使用をお勧めします。仕様のすべての整数フィールドは、ネットワークオクテット順の符号なし整数としてエンコードされます。"
    },
    {
      "indent": 0,
      "text": "4.1. RTP Header Usage",
      "section_title": true,
      "ja": "4.1. RTPヘッダーの使用"
    },
    {
      "indent": 3,
      "text": "The general RTP payload format for VP8 is depicted below.",
      "ja": "VP8の一般的なRTPペイロード形式を以下に示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|V=2|P|X|  CC   |M|     PT      |       sequence number         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           synchronization source (SSRC) identifier            |\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n|            contributing source (CSRC) identifiers             |\n|                             ....                              |\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n|            VP8 payload descriptor (integer #octets)           |\n:                                                               :\n|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               : VP8 payload header (3 octets) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| VP8 pyld hdr  :                                               |\n+-+-+-+-+-+-+-+-+                                               |\n:                   Octets 4..N of VP8 payload                  :\n|                                                               |\n|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               :    OPTIONAL RTP padding       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The VP8 payload descriptor and VP8 payload header will be described in Sections 4.2 and 4.3. OPTIONAL RTP padding MUST NOT be included unless the P bit is set. The figure specifically shows the format for the first packet in a frame. Subsequent packets will not contain the VP8 payload header and will have later octets in the frame payload.",
      "ja": "VP8ペイロード記述子とVP8ペイロードヘッダーについては、セクション4.2と4.3で説明します。 Pビットが設定されていない限り、オプションのRTPパディングを含めることはできません。この図は、フレームの最初のパケットのフォーマットを具体的に示しています。後続のパケットにはVP8ペイロードヘッダーが含まれず、フレームペイロードに後のオクテットが含まれます。"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Marker bit (M): MUST be set for the very last packet of each encoded frame in line with the normal use of the M bit in video formats. This enables a decoder to finish decoding the picture, where it otherwise may need to wait for the next packet to explicitly know that the frame is complete.",
      "ja": "マーカービット（M）：ビデオ形式でのMビットの通常の使用に合わせて、各エンコードフレームの最後のパケットに設定する必要があります。これにより、デコーダーは画像のデコードを完了することができます。そうでなければ、フレームが完了したことを次のパケットが明示的に知るのを待つ必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Payload type (PT): The assignment of an RTP payload type for this packet format is outside the scope of this document and will not be specified here.",
      "ja": "ペイロードタイプ（PT）：このパケット形式のRTPペイロードタイプの割り当ては、このドキュメントの範囲外であり、ここでは指定しません。"
    },
    {
      "indent": 3,
      "text": "Timestamp: The RTP timestamp indicates the time when the frame was sampled. The granularity of the clock is 90 kHz, so a delta of 1 represents 1/90,000 of a second.",
      "ja": "タイムスタンプ：RTPタイムスタンプは、フレームがサンプリングされた時刻を示します。クロックの細分性は90 kHzなので、1のデルタは1 / 90,000秒を表します。"
    },
    {
      "indent": 6,
      "text": "The remaining RTP Fixed Header Fields (V, P, X, CC, sequence number, SSRC, and CSRC identifiers) are used as specified in Section 5.1 of [RFC3550].",
      "ja": "残りのRTP固定ヘッダーフィールド（V、P、X、CC、シーケンス番号、SSRC、およびCSRC識別子）は、[RFC3550]のセクション5.1で指定されているとおりに使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2. VP8 Payload Descriptor",
      "section_title": true,
      "ja": "4.2. VP8ペイロード記述子"
    },
    {
      "indent": 3,
      "text": "The first octets after the RTP header are the VP8 payload descriptor, with the following structure. The single-octet version of the PictureID is illustrated to the left (M bit set to 0), while the dual-octet version (M bit set to 1) is shown to the right.",
      "ja": "RTPヘッダーの後の最初のオクテットは、次の構造を持つVP8ペイロード記述子です。左側にPictureIDのシングルオクテットバージョン（Mビットを0に設定）を示し、右側にデュアルオクテットバージョン（Mビットを1に設定）を示します。"
    },
    {
      "indent": 3,
      "text": "      0 1 2 3 4 5 6 7                      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n     |X|R|N|S|R| PID | (REQUIRED)        |X|R|N|S|R| PID | (REQUIRED)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nX:   |I|L|T|K| RSV   | (OPTIONAL)   X:   |I|L|T|K| RSV   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nI:   |M| PictureID   | (OPTIONAL)   I:   |M| PictureID   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nL:   |   TL0PICIDX   | (OPTIONAL)        |   PictureID   |\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nT/K: |TID|Y| KEYIDX  | (OPTIONAL)   L:   |   TL0PICIDX   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n                                    T/K: |TID|Y| KEYIDX  | (OPTIONAL)\n                                         +-+-+-+-+-+-+-+-+\n                              Figure 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "X: Extended control bits present. When set to 1, the extension octet MUST be provided immediately after the mandatory first octet. If the bit is zero, all optional fields MUST be omitted. Note: this X bit is not to be confused with the X bit in the RTP header.",
      "ja": "X：拡張制御ビットが存在します。 1に設定した場合、拡張オクテットは必須の最初のオクテットの直後に提供する必要があります。ビットがゼロの場合、すべてのオプションフィールドを省略しなければなりません。注：このXビットは、RTPヘッダーのXビットと混同しないでください。"
    },
    {
      "indent": 3,
      "text": "R: Bit reserved for future use. MUST be set to 0 and MUST be ignored by the receiver.",
      "ja": "R：ビットは将来の使用のために予約されています。 0に設定する必要があり、レシーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "N: Non-reference frame. When set to 1, the frame can be discarded without affecting any other future or past frames. If the reference status of the frame is unknown, this bit SHOULD be set to 0 to avoid discarding frames needed for reference.",
      "ja": "N：非参照フレーム。 1に設定すると、他の将来のフレームや過去のフレームに影響を与えることなく、フレームを破棄できます。フレームの参照ステータスが不明な場合は、このビットを0に設定して、参照に必要なフレームの破棄を回避する必要があります。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to determine if an encoded frame is non-reference. The reference status of an encoded frame is preferably provided from the encoder implementation.",
      "ja": "参考情報：このドキュメントでは、エンコードされたフレームが非参照であるかどうかを判断する方法については説明していません。符号化されたフレームの参照ステータスは、好ましくは、エンコーダの実装から提供される。"
    },
    {
      "indent": 3,
      "text": "S: Start of VP8 partition. SHOULD be set to 1 when the first payload octet of the RTP packet is the beginning of a new VP8 partition, and MUST NOT be 1 otherwise. The S bit MUST be set to 1 for the first packet of each encoded frame.",
      "ja": "S：VP8パーティションの開始。 RTPパケットの最初のペイロードオクテットが新しいVP8パーティションの始まりである場合は1に設定する必要があり、それ以外の場合は1にしないでください。符号化された各フレームの最初のパケットでは、Sビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "PID: Partition index. Denotes to which VP8 partition the first payload octet of the packet belongs. The first VP8 partition (containing modes and motion vectors) MUST be labeled with PID = 0. PID SHOULD be incremented by 1 for each subsequent partition, but it MAY be kept at 0 for all packets. PID cannot be larger than 7. If more than one packet in an encoded frame contains the same PID, the S bit MUST NOT be set for any packet other than the first packet with that PID.",
      "ja": "PID：パーティションインデックス。パケットの最初のペイロードオクテットが属するVP8パーティションを示します。最初のVP8パーティション（モードとモーションベクトルを含む）には、PID = 0のラベルを付ける必要があります。PIDは、後続のパーティションごとに1ずつインクリメントする必要がありますが、すべてのパケットで0に維持する必要があります。 PIDは7以下にする必要があります。エンコードされたフレームの複数のパケットに同じPIDが含まれている場合、そのPIDを持つ最初のパケット以外のパケットにはSビットを設定してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "When the X bit is set to 1 in the first octet, the Extended Control Bits field octet MUST be provided as the second octet. If the X bit is 0, the Extended Control Bits field octet MUST NOT be present, and no extensions (I, L, T, or K) are permitted.",
      "ja": "最初のオクテットでXビットが1に設定されている場合、拡張制御ビットフィールドオクテットを2番目のオクテットとして提供する必要があります。 Xビットが0の場合、拡張制御ビットフィールドのオクテットは存在してはならず（MUST NOT）、拡張（I、L、T、またはK）は許可されません。"
    },
    {
      "indent": 3,
      "text": "I: PictureID present. When set to 1, the PictureID MUST be present after the extension bit field and specified as below. Otherwise, PictureID MUST NOT be present.",
      "ja": "I：PictureIDが存在します。 1に設定する場合、PictureIDは拡張ビットフィールドの後に存在し、以下のように指定する必要があります。それ以外の場合、PictureIDは存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "L: TL0PICIDX present. When set to 1, the TL0PICIDX MUST be present and specified as below, and the T bit MUST be set to 1. Otherwise, TL0PICIDX MUST NOT be present.",
      "ja": "L：TL0PICIDXが存在します。 1に設定されている場合、TL0PICIDXが存在し、以下のように指定されている必要があり、Tビットは1に設定されている必要があります。それ以外の場合、TL0PICIDXは存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "T: TID present. When set to 1, the TID/Y/KEYIDX octet MUST be present. The TID|Y part of the octet MUST be specified as below. If K (below) is set to 1 but T is set to 0, the TID/Y/KEYIDX octet MUST be present, but the TID field MUST be ignored. If neither T nor K is set to 1, the TID/Y/KEYIDX octet MUST NOT be present.",
      "ja": "T：TIDが存在します。 1に設定されている場合、TID / Y / KEYIDXオクテットが存在する必要があります。オクテットのTID | Y部分は、次のように指定する必要があります。 K（下記）が1に設定され、Tが0に設定されている場合、TID / Y / KEYIDXオクテットが存在しなければなりませんが、TIDフィールドは無視されなければなりません（MUST）。 TもKも1に設定されていない場合、TID / Y / KEYIDXオクテットは存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "K: KEYIDX present. When set to 1, the TID/Y/KEYIDX octet MUST be present. The KEYIDX part of the octet MUST be specified as below. If T (above) is set to 1 but K is set to 0, the TID/Y/KEYIDX octet MUST be present, but the KEYIDX field MUST be ignored. If neither T nor K is set to 1, the TID/Y/KEYIDX octet MUST NOT be present.",
      "ja": "K：KEYIDXが存在します。 1に設定されている場合、TID / Y / KEYIDXオクテットが存在する必要があります。オクテットのKEYIDX部分は、以下のように指定する必要があります。 T（上記）が1に設定され、Kが0に設定されている場合、TID / Y / KEYIDXオクテットが存在しなければなりませんが、KEYIDXフィールドは無視されなければなりません（MUST）。 TもKも1に設定されていない場合、TID / Y / KEYIDXオクテットは存在してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "RSV: Bits reserved for future use. MUST be set to 0 and MUST be ignored by the receiver.",
      "ja": "RSV：将来の使用のために予約されているビット。 0に設定する必要があり、レシーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "After the extension bit field follow the extension data fields that are enabled.",
      "ja": "拡張ビットフィールドの後に、有効になっている拡張データフィールドを続けます。"
    },
    {
      "indent": 3,
      "text": "The PictureID extension: If the I bit is set to 1, the PictureID extension field MUST be present, and it MUST NOT be present otherwise. The field consists of two parts:",
      "ja": "PictureID拡張：Iビットが1に設定されている場合、PictureID拡張フィールドが存在しなければならず、それ以外の場合は存在してはなりません。フィールドは2つの部分で構成されています。"
    },
    {
      "indent": 6,
      "text": "M: The most significant bit of the first octet is an extension flag. If M is set, the remainder of the PictureID field MUST contain 15 bits, else it MUST contain 7 bits. Note: this M bit is not to be confused with the M bit in the RTP header.",
      "ja": "M：最初のオクテットの最上位ビットは拡張フラグです。 Mが設定されている場合、PictureIDフィールドの残りの部分には15​​ビットが含まれている必要があり、そうでない場合は7ビットが含まれている必要があります。注：このMビットは、RTPヘッダーのMビットと混同しないでください。"
    },
    {
      "indent": 6,
      "text": "PictureID: 7 or 15 bits (shown left and right, respectively, in Figure 2) not including the M bit. This is a running index of the frames, which MAY start at a random value, MUST increase by 1 for each subsequent frame, and MUST wrap to 0 after reaching the maximum ID (all bits set). The 7 or 15 bits of the PictureID go from most significant to least significant, beginning with the first bit after the M bit. The sender chooses a 7- or 15-bit index and sets the M bit accordingly. The receiver MUST NOT assume that the number of bits in PictureID stays the same through the session. Having sent a 7-bit PictureID with all bits set to 1, the sender may either wrap the PictureID to 0 or extend to 15 bits and continue incrementing.",
      "ja": "PictureID：7ビットまたは15ビット（図2ではそれぞれ左と右に表示）、Mビットを含まない。これはフレームの実行インデックスであり、ランダムな値で開始することができ、後続の各フレームで1ずつ増加する必要があり、最大ID（すべてのビットセット）に達した後に0にラップする必要があります。 PictureIDの7ビットまたは15ビットは、Mビットの後の最初のビットから始まり、最上位から最下位へと進みます。送信側は7ビットまたは15ビットのインデックスを選択し、それに応じてMビットを設定します。受信者は、PictureIDのビット数がセッションを通じて同じであると想定してはなりません（MUST NOT）。すべてのビットが1に設定された7ビットのPictureIDを送信すると、送信者はPictureIDを0にラップするか、15ビットに拡張して、インクリメントを続行できます。"
    },
    {
      "indent": 3,
      "text": "The TL0PICIDX extension: If the L bit is set to 1, the TL0PICIDX extension field MUST be present, and it MUST NOT be present otherwise. The field consists of one part:",
      "ja": "TL0PICIDX拡張：Lビットが1に設定されている場合、TL0PICIDX拡張フィールドが存在しなければならず、それ以外の場合は存在してはなりません。フィールドは次の1つの部分で構成されています。"
    },
    {
      "indent": 6,
      "text": "TL0PICIDX: 8 bits temporal level zero index. TL0PICIDX is a running index for the temporal base layer frames, i.e., the frames with TID set to 0. If TID is larger than 0, TL0PICIDX indicates on which base-layer frame the current image depends. TL0PICIDX MUST be incremented when TID is 0. The index MAY start at a random value, and it MUST wrap to 0 after reaching the maximum number 255. Use of TL0PICIDX depends on the presence of TID. Therefore, it is RECOMMENDED that the TID be used whenever TL0PICIDX is.",
      "ja": "TL0PICIDX：8ビットの時間レベル0インデックス。 TL0PICIDXは、時間ベースレイヤーフレームの実行インデックスです。つまり、TIDが0に設定されたフレームです。TIDが0より大きい場合、TL0PICIDXは、現在の画像がどのベースレイヤーフレームに依存しているかを示します。 TL0PICIDXは、TIDが0の場合にインクリメントする必要があります。インデックスはランダムな値で開始する場合があり、最大数255に達した後に0にラップする必要があります。TL0PICIDXの使用は、TIDの存在に依存します。したがって、TL0PICIDXを使用する場合は常にTIDを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The TID/Y/KEYIDX extension: If either of the T or K bits are set to 1, the TID/Y/KEYIDX extension field MUST be present. It MUST NOT be present if both T and K are zero. The field consists of three parts:",
      "ja": "TID / Y / KEYIDX拡張：TまたはKビットのいずれかが1に設定されている場合、TID / Y / KEYIDX拡張フィールドが存在している必要があります。 TとKの両方がゼロの場合、存在してはなりません。フィールドは3つの部分で構成されています。"
    },
    {
      "indent": 6,
      "text": "TID: 2 bits temporal-layer index. The TID field MUST be ignored by the receiver when the T bit is set equal to 0. The TID field indicates which temporal layer the packet represents.",
      "ja": "TID：2ビットの時間層インデックス。 Tビットが0に設定されている場合、受信者はTIDフィールドを無視する必要があります。TIDフィールドは、パケットが表す一時レイヤを示します。"
    },
    {
      "indent": 9,
      "text": "The lowest layer, i.e., the base layer, MUST have the TID set to 0. Higher layers SHOULD increment the TID according to their position in the layer hierarchy.",
      "ja": "最下層、つまりベース層は、TIDを0に設定する必要があります。上位層は、層階層内の位置に従ってTIDを増分する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "Y: 1 layer sync bit. The Y bit SHOULD be set to 1 if the current frame depends only on the base layer (TID = 0) frame with TL0PICIDX equal to that of the current frame. The Y bit MUST be set to 0 if the current frame depends on any other frame than the base layer (TID = 0) frame with TL0PICIDX equal to that of the current frame. Additionally, the Y bit MUST be set to 0 if any frame following the current frame depends on a non-base-layer frame older than the base-layer frame with TL0PICIDX equal to that of the current frame. If the Y bit is set when the T bit is equal to 0, the current frame MUST only depend on a past base-layer (TID=0) key frame as signaled by a change in the KEYIDX field. Additionally, this frame MUST NOT depend on any of the three codec buffers (as defined by [RFC6386]) that have been updated since the last time the KEYIDX field was changed.",
      "ja": "Y：1レイヤー同期ビット。現在のフレームが、TL0PICIDXが現在のフレームと等しいベースレイヤー（TID = 0）フレームのみに依存する場合は、Yビットを1に設定する必要があります。現在のフレームが、TL0PICIDXが現在のフレームと等しいベースレイヤー（TID = 0）フレーム以外のフレームに依存する場合は、Yビットを0に設定する必要があります。さらに、現在のフレームに続くフレームが、TL0PICIDXが現在のフレームと等しいベースレイヤーフレームよりも古い非ベースレイヤーフレームに依存している場合は、Yビットを0に設定する必要があります。 Tビットが0のときにYビットが設定されている場合、現在のフレームは、KEYIDXフィールドの変更によって通知された過去のベースレイヤー（TID = 0）キーフレームのみに依存する必要があります。さらに、このフレームは、KEYIDXフィールドが最後に変更されてから更新された3つのコーデックバッファ（[RFC6386]で定義）に依存してはなりません（MUST NOT）。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to determine the dependency status for a frame; this information is preferably provided from the encoder implementation. In the case of unknown status, the Y bit can safely be set to 0.",
      "ja": "参考情報：このドキュメントでは、フレームの依存状態を判断する方法については説明していません。この情報は、好ましくはエンコーダの実装から提供されます。不明なステータスの場合、Yビットを安全に0に設定できます。"
    },
    {
      "indent": 6,
      "text": "KEYIDX: 5 bits temporal key frame index. The KEYIDX field MUST be ignored by the receiver when the K bit is set equal to 0. The KEYIDX field is a running index for key frames. KEYIDX MAY start at a random value, and it MUST wrap to 0 after reaching the maximum number 31. When in use, the KEYIDX SHOULD be present for both key frames and interframes. The sender MUST increment KEYIDX for key frames that convey parameter updates critical to the interpretation of subsequent frames, and it SHOULD leave the KEYIDX unchanged for key frames that do not contain these critical updates. If the KEYIDX is present, a receiver SHOULD NOT decode an interframe if it has not received and decoded a key frame with the same KEYIDX after the last KEYIDX wraparound.",
      "ja": "KEYIDX：5ビットの一時キーフレームインデックス。 Kビットが0に設定されている場合、受信者はKEYIDXフィールドを無視する必要があります。KEYIDXフィールドは、キーフレームの実行中のインデックスです。 KEYIDXはランダムな値で開始する場合があり、最大数31に達した後は0にラップする必要があります。使用中、KEYIDXはキーフレームとインターフレームの両方に存在する必要があります（SHOULD）。送信者は、後続のフレームの解釈に重要なパラメーターの更新を伝えるキーフレームのKEYIDXをインクリメントする必要があり、これらの重要な更新を含まないキーフレームのKEYIDXは変更しないでください。 KEYIDXが存在する場合、最後のKEYIDXラップアラウンド後に同じKEYIDXのキーフレームを受信して​​デコードしていない場合、レシーバーはインターフレームをデコードしてはなりません（SHOULD NOT）。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to determine if a key frame updates critical parameters; this information is preferably provided from the encoder implementation. A sender that does not have this information may either omit the KEYIDX field (set K equal to 0) or increment the KEYIDX on every key frame. The benefit with the latter is that any key-frame loss will be detected by the receiver, which can signal for re-transmission or request a new key frame.",
      "ja": "参考情報：このドキュメントでは、キーフレームが重要なパラメーターを更新するかどうかを判断する方法については説明していません。この情報は、好ましくはエンコーダの実装から提供されます。この情報を持たない送信者は、KEYIDXフィールドを省略するか（Kを0に設定）、すべてのキーフレームでKEYIDXをインクリメントします。後者の利点は、キーフレームの損失がレシーバーによって検出され、再送信の信号を送ったり、新しいキーフレームを要求したりできることです。"
    },
    {
      "indent": 3,
      "text": "Informative note: Implementations doing splicing of VP8 streams will have to make sure the rules for incrementing TL0PICIDX and KEYIDX are obeyed across the splice. This will likely require rewriting values of TL0PICIDX and KEYIDX after the splice.",
      "ja": "参考情報：VP8ストリームのスプライシングを行う実装では、TL0PICIDXおよびKEYIDXをインクリメントするためのルールがスプライス全体で確実に守られるようにする必要があります。これには、スプライス後にTL0PICIDXおよびKEYIDXの値を書き換える必要がある可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.3. VP8 Payload Header",
      "section_title": true,
      "ja": "4.3. VP8ペイロードヘッダー"
    },
    {
      "indent": 3,
      "text": "The beginning of an encoded VP8 frame is referred to as an \"uncompressed data chunk\" in Section 9.1 of [RFC6386], and it also serves as a payload header in this RTP format. The codec bitstream format specifies two different variants of the uncompressed data chunk: a 3-octet version for interframes and a 10-octet version for key frames. The first 3 octets are common to both variants. In the case of a key frame, the remaining 7 octets are considered to be part of the remaining payload in this RTP format. Note that the header is present only in packets that have the S bit equal to one and the PID equal to zero in the payload descriptor. Subsequent packets for the same frame do not carry the payload header.",
      "ja": "エンコードされたVP8フレームの始まりは、[RFC6386]のセクション9.1で「非圧縮データチャンク」と呼ばれ、このRTP形式のペイロードヘッダーとしても機能します。コーデックビットストリーム形式は、非圧縮データチャンクの2つの異なるバリアントを指定します。インターフレームの3オクテットバージョンとキーフレームの10オクテットバージョンです。最初の3オクテットは両方の亜種に共通です。キーフレームの場合、残りの7オクテットは、このRTP形式の残りのペイロードの一部と見なされます。ヘッダーは、ペイロード記述子のSビットが1でPIDがゼロのパケットにのみ存在することに注意してください。同じフレームの後続のパケットには、ペイロードヘッダーは含まれません。"
    },
    {
      "indent": 3,
      "text": "The length of the first partition can always be obtained from the first partition-size parameter in the VP8 payload header. The VP8 bitstream format [RFC6386] specifies that if multiple DCT/WHT partitions are produced, the location of each partition start is found at the end of the first (prediction or mode) partition. In this RTP payload specification, the location offsets are considered to be part of the first partition.",
      "ja": "最初のパーティションの長さは、常にVP8ペイロードヘッダーの最初のパーティションサイズパラメータから取得できます。 VP8ビットストリーム形式[RFC6386]は、複数のDCT / WHTパーティションが作成される場合、各パーティションの開始位置が最初の（予測またはモード）パーティションの最後にあることを指定しています。このRTPペイロード仕様では、ロケーションオフセットは最初のパーティションの一部と見なされます。"
    },
    {
      "indent": 28,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|Size0|H| VER |P|\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..N of|\n| VP8 payload   |\n:               :\n+-+-+-+-+-+-+-+-+\n| OPTIONAL RTP  |\n| padding       |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "A packetizer needs access to the P bit. The other fields are defined in [RFC6386], Section 9.1, and their meanings do not influence the packetization process. None of these fields are modified by the packetization process.",
      "ja": "パケタイザはPビットにアクセスする必要があります。他のフィールドは[RFC6386]、セクション9.1で定義されており、それらの意味はパケット化プロセスに影響しません。これらのフィールドはいずれも、パケット化プロセスによって変更されません。"
    },
    {
      "indent": 3,
      "text": "P: Inverse key frame flag. When set to 0, the current frame is a key frame. When set to 1, the current frame is an interframe. Defined in [RFC6386]",
      "ja": "P：逆キーフレームフラグ。 0に設定すると、現在のフレームがキーフレームになります。 1に設定すると、現在のフレームはインターフレームになります。 [RFC6386]で定義"
    },
    {
      "indent": 0,
      "text": "4.4. Aggregated and Fragmented Payloads",
      "section_title": true,
      "ja": "4.4. 集約および断片化されたペイロード"
    },
    {
      "indent": 3,
      "text": "An encoded VP8 frame can be divided into two or more partitions, as described in Section 1. It is OPTIONAL for a packetizer implementing this RTP specification to pay attention to the partition boundaries within an encoded frame. If packetization of a frame is done without considering the partition boundaries, the PID field MAY be set to 0 for all packets and the S bit MUST NOT be set to 1 for any other packet than the first.",
      "ja": "エンコードされたVP8フレームは、セクション1で説明するように、2つ以上のパーティションに分割できます。このRTP仕様を実装するパケタイザが、エンコードされたフレーム内のパーティション境界に注意を払うのはオプションです。フレームのパケット化がパーティション境界を考慮せずに行われる場合、PIDフィールドはすべてのパケットに対して0に設定されてもよく（MAY）、最初以外のパケットに対してSビットは1に設定されてはいけません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "If the preferred usage suggested in Section 3 is followed, with each packet carrying data from exactly one partition, the S bit and PID fields described in Section 4.2 SHOULD be used to indicate what the packet contains. The PID field should indicate to which partition the first octet of the payload belongs and the S bit indicates that the packet starts on a new partition.",
      "ja": "セクション3で提案されている推奨される使用法に従い、各パケットが1つのパーティションからのデータを運ぶ場合、セクション4.2で説明されているSビットおよびPIDフィールドを使用して、パケットの内容を示す必要があります（SHOULD）。 PIDフィールドは、ペイロードの最初のオクテットが属するパーティションを示し、Sビットは、パケットが新しいパーティションで開始することを示します。"
    },
    {
      "indent": 3,
      "text": "If the packetizer does not pay attention to the partition boundaries, one packet can contain a fragment of a partition, a complete partition, or an aggregate of fragments and partitions. There is no explicit signaling of partition boundaries in the payload, and the partition lengths at the end of the first partition have to be used to identify the boundaries. Partitions MUST be aggregated in decoding order. Two fragments from different partitions MAY be aggregated into the same packet along with one or more complete partitions.",
      "ja": "パケタイザがパーティションの境界に注意を払わない場合、1つのパケットにパーティションのフラグメント、完全なパーティション、またはフラグメントとパーティションの集約を含めることができます。ペイロードにはパーティション境界の明示的なシグナリングはありません。最初のパーティションの最後にあるパーティションの長さを使用して、境界を識別する必要があります。パーティションは、デコード順に集約する必要があります。異なるパーティションからの2つのフラグメントは、1つ以上の完全なパーティションとともに同じパケットに集約される場合があります。"
    },
    {
      "indent": 3,
      "text": "In all cases, the payload of a packet MUST contain data from only one video frame. Consequently, the set of packets carrying the data from a particular frame will contain exactly one VP8 Payload Header (see Section 4.3) carried in the first packet of the frame. The last, or only, packet carrying data for the frame MUST have the M bit set in the RTP header.",
      "ja": "すべての場合において、パケットのペイロードには、1つのビデオフレームからのデータのみが含まれている必要があります。その結果、特定のフレームからのデータを運ぶパケットのセットには、フレームの最初のパケットで運ばれるVP8ペイロードヘッダー（セクション4.3を参照）が1つだけ含まれます。フレームのデータを運ぶ最後の、または唯一のパケットは、RTPヘッダーにMビットが設定されている必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5. Example Algorithms",
      "section_title": true,
      "ja": "4.5. アルゴリズムの例"
    },
    {
      "indent": 0,
      "text": "4.5.1. Frame Reconstruction Algorithm",
      "section_title": true,
      "ja": "4.5.1. フレーム再構成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Example of frame reconstruction algorithm.",
      "ja": "フレーム再構成アルゴリズムの例。"
    },
    {
      "indent": 3,
      "text": "1: Collect all packets with a given RTP timestamp.",
      "ja": "1：特定のRTPタイムスタンプを持つすべてのパケットを収集します。"
    },
    {
      "indent": 3,
      "text": "2: Go through packets in order, sorted by sequence numbers, if packets are missing, send NACK as defined in [RFC4585] or decode with missing partitions, see Section 4.5.2 below.",
      "ja": "2：シーケンス番号でソートされたパケットを順番に調べ、パケットが欠落している場合は、[RFC4585]で定義されているようにNACKを送信するか、欠落しているパーティションでデコードします。以下のセクション4.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "3: A frame is complete if the frame has no missing sequence numbers, the first packet in the frame contains S=1 with partId=0 and the last packet in the frame has the marker bit set.",
      "ja": "3：フレームにシーケンス番号の欠落がなく、フレームの最初のパケットにS = 1（partId = 0）が含まれ、フレームの最後のパケットにマーカービットが設定されている場合、フレームは完全です。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Partition Reconstruction Algorithm",
      "section_title": true,
      "ja": "4.5.2. パーティション再構築アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Example of partition reconstruction algorithm. The algorithm only applies for the RECOMMENDED use case with partitions in separate packets.",
      "ja": "パーティション再構築アルゴリズムの例。このアルゴリズムは、パーティションが個別のパケットにあるRECOMMENDEDユースケースにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "1: Scan for the start of a new partition; S=1.",
      "ja": "1：新しいパーティションの開始をスキャンします。 S = 1。"
    },
    {
      "indent": 3,
      "text": "2: Continue scan to detect end of partition; hence, a new S=1 (previous packet was the end of the partition) is found or the marker bit is set. If a loss is detected before the end of the partition, abandon all packets in this partition and continue the scan repeating from step 1.",
      "ja": "2：パーティションの終わりを検出するためにスキャンを続行します。したがって、新しいS = 1（前のパケットはパーティションの終わりでした）が検出されるか、マーカービットが設定されます。パーティションが終了する前に損失が検出された場合は、このパーティションのすべてのパケットを破棄し、手順1からスキャンを繰り返します。"
    },
    {
      "indent": 3,
      "text": "3: Store the packets in the complete partition, continue the scan repeating from step 1 until end of frame is reached.",
      "ja": "3：パケットを完全なパーティションに保存し、フレームの最後に到達するまでステップ1からスキャンを繰り返します。"
    },
    {
      "indent": 3,
      "text": "4: Send all complete partitions to the decoder. If no complete partition is found discard the whole frame.",
      "ja": "4：すべての完全なパーティションをデコーダに送信します。完全なパーティションが見つからない場合は、フレーム全体を破棄します。"
    },
    {
      "indent": 0,
      "text": "4.6. Examples of VP8 RTP Stream",
      "section_title": true,
      "ja": "4.6. VP8 RTPストリームの例"
    },
    {
      "indent": 3,
      "text": "A few examples of how the VP8 RTP payload can be used are included below.",
      "ja": "VP8 RTPペイロードの使用方法の例をいくつか次に示します。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Key Frame in a Single RTP Packet",
      "section_title": true,
      "ja": "4.6.1. 単一のRTPパケットのキーフレーム"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |0| P = 0\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| VP8 payload   |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.2. Non-discardable VP8 Interframe in a Single RTP Packet; No PictureID",
      "ja": "4.6.2. 単一のRTPパケット内の破棄できないVP8インターフレーム。 PictureIDがありません"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|0|0|0|1|0|0 0 0| X = 0; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| VP8 payload   |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.3. VP8 Partitions in Separate RTP Packets",
      "section_title": true,
      "ja": "4.6.3. 個別のRTPパケット内のVP8パーティション"
    },
    {
      "indent": 3,
      "text": "First RTP packet; complete first partition.",
      "ja": "最初のRTPパケット。最初のパーティションを完成させます。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..L of|\n| first VP8     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Second RTP packet; complete second partition.",
      "ja": "2番目のRTPパケット。完全な2番目のパーティション。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 1| X = 1; S = 1; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Remaining VP8 |\n| partitions    |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.4. VP8 Frame Fragmented across RTP Packets",
      "section_title": true,
      "ja": "4.6.4. RTPパケット全体でフラグメント化されたVP8フレーム"
    },
    {
      "indent": 3,
      "text": "First RTP packet; complete first partition.",
      "ja": "最初のRTPパケット。最初のパーティションを完成させます。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Complete      |\n| first         |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Second RTP packet; first fragment of second partition.",
      "ja": "2番目のRTPパケット。 2番目のパーティションの最初のフラグメント。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 1| X = 1; S = 1; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| First fragment|\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Third RTP packet; second fragment of second partition.",
      "ja": "3番目のRTPパケット。 2番目のパーティションの2番目のフラグメント。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0|0 0 1| X = 1; S = 0; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Mid fragment  |\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Fourth RTP packet; last fragment of second partition.",
      "ja": "4番目のRTPパケット。 2番目のパーティションの最後のフラグメント。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0|0 0 1| X = 1; S = 0; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Last fragment |\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.5. VP8 Frame with Long PictureID",
      "section_title": true,
      "ja": "4.6.5. 長いPictureIDを持つVP8フレーム"
    },
    {
      "indent": 3,
      "text": "PictureID = 4711 = 001001001100111 binary (first 7 bits: 0010010, last 8 bits: 01100111).",
      "ja": "PictureID = 4711 = 001001001100111バイナリ（最初の7ビット：0010010、最後の8ビット：01100111）。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1;\n+-+-+-+-+-+-+-+-+\n|1 0 0 1 0 0 1 0| Long PictureID flag = 1\n|0 1 1 0 0 1 1 1| PictureID = 4711\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1|\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..N of|\n| VP8 payload   |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Using VP8 with RPSI and SLI Feedback",
      "section_title": true,
      "ja": "5. RPSIおよびSLIフィードバックでのVP8の使用"
    },
    {
      "indent": 3,
      "text": "The VP8 payload descriptor defined in Section 4.2 contains an optional PictureID parameter. This parameter is included mainly to enable use of reference picture selection indication (RPSI) and slice loss indication (SLI), both defined in [RFC4585].",
      "ja": "セクション4.2で定義されているVP8ペイロード記述子には、オプションのPictureIDパラメータが含まれています。このパラメータは、主に参照画像選択表示（RPSI）とスライス損失表示（SLI）の使用を可能にするために含まれ、どちらも[RFC4585]で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1. RPSI",
      "section_title": true,
      "ja": "5.1. PSH"
    },
    {
      "indent": 0,
      "text": " The RPSI is a payload-specific feedback message defined within the RTCP-based feedback format. The RPSI message is generated by a receiver and can be used in two ways. Either it can signal a preferred reference picture when a loss has been detected by the decoder -- preferably then a reference that the decoder knows is perfect -- or it can be used as positive feedback information to acknowledge correct decoding of certain reference pictures. The positive-feedback method is useful for VP8 used for point-to-point (unicast) communication. The use of RPSI for VP8 is preferably combined with a special update pattern of the codec's two special reference frames -- the golden frame and the altref frame -- in which they are updated in an alternating leapfrog fashion. When a receiver has received and correctly decoded a golden or altref frame, and that frame has a PictureID in the payload descriptor, the receiver can acknowledge this simply by sending an RPSI message back to the sender. The message body (i.e., the \"native RPSI bit string\" in [RFC4585]) is simply the PictureID of the received frame.",
      "ja": "RPSIは、RTCPベースのフィードバック形式内で定義されたペイロード固有のフィードバックメッセージです。 RPSIメッセージは受信者によって生成され、2つの方法で使用できます。デコーダーによって損失が検出されたときに優先参照画像（できれば、デコーダーが完全に知っている参照）を通知するか、特定の参照画像の正しいデコードを確認するための正のフィードバック情報として使用できます。正帰還方式は、ポイントツーポイント（ユニキャスト）通信に使用されるVP8に役立ちます。 VP8でのRPSIの使用は、コーデックの2つの特別な参照フレーム（ゴールデンフレームとaltrefフレーム）の特別な更新パターンと組み合わせると、交互に飛び跳ねて更新されます。ゴールデンまたはaltrefフレームを受信して​​正しくデコードし、そのフレームのペイロード記述子にPictureIDがある場合、受信者はRPSIメッセージを送信者に送信するだけでこれを確認できます。メッセージ本文（つまり、[RFC4585]の「ネイティブRPSIビット文字列」）は、単に受信したフレームのPictureIDです。"
    },
    {
      "indent": 0,
      "text": "5.2. SLI",
      "section_title": true,
      "ja": "5.2. SLI"
    },
    {
      "indent": 3,
      "text": "The SLI is another payload-specific feedback message defined within the RTCP-based feedback format. The SLI message is generated by the receiver when a loss or corruption is detected in a frame. The format of the SLI message is as follows [RFC4585]:",
      "ja": "SLIは、RTCPベースのフィードバック形式内で定義された別のペイロード固有のフィードバックメッセージです。 SLIメッセージは、フレームで損失または破損が検出されたときに受信者によって生成されます。 SLIメッセージのフォーマットは次のとおりです[RFC4585]："
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         First           |        Number           | PictureID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Here, First is the macroblock address (in scan order) of the first lost block and Number is the number of lost blocks, as defined in [RFC4585]. PictureID is the six least significant bits of the codec-specific picture identifier in which the loss or corruption has occurred. For VP8, this codec-specific identifier is naturally the PictureID of the current frame, as read from the payload descriptor. If the payload descriptor of the current frame does not have a PictureID, the receiver MAY send the last received PictureID+1 in the SLI message. The receiver MAY set the First parameter to 0, and the Number parameter to the total number of macroblocks per frame, even though only part of the frame is corrupted. When the sender receives an SLI message, it can make use of the knowledge from the latest received RPSI message. Knowing that the last golden or altref frame was successfully received, it can encode the next frame with reference to that established reference.",
      "ja": "ここで、[RFC4585]で定義されているように、Firstは最初の失われたブロックのマクロブロックアドレス（スキャン順）、Numberは失われたブロックの数です。 PictureIDは、損失または破損が発生したコーデック固有の画像識別子の最下位6ビットです。 VP8の場合、このコーデック固有の識別子は、ペイロード記述子から読み取られる現在のフレームのPictureIDです。現在のフレームのペイロード記述子にPictureIDがない場合、受信者はSLIメッセージで最後に受信したPictureID + 1を送信できます（MAY）。フレームの一部だけが破損している場合でも、レシーバーはFirstパラメーターを0に設定し、Numberパラメーターをフレームあたりのマクロブロックの総数に設定できます（MAY）。送信者がSLIメッセージを受信すると、最後に受信したRPSIメッセージからの知識を利用できます。最後のゴールデンフレームまたはaltrefフレームが正常に受信されたことがわかっていると、確立された参照を参照して次のフレームをエンコードできます。"
    },
    {
      "indent": 0,
      "text": "5.3. Example",
      "section_title": true,
      "ja": "5.3. 例"
    },
    {
      "indent": 3,
      "text": "The use of RPSI and SLI is best illustrated in an example. In this example, the encoder may not update the altref frame until the last sent golden frame has been acknowledged with an RPSI message. If an update is not received within some time, a new golden frame update is sent instead. Once the new golden frame is established and acknowledged, the same rule applies when updating the altref frame.",
      "ja": "RPSIとSLIの使用は、例に最もよく示されています。この例では、エンコーダは、最後に送信されたゴールデンフレームがRPSIメッセージで確認されるまで、altrefフレームを更新しない場合があります。しばらくして更新が受信されない場合は、代わりに新しいゴールデンフレーム更新が送信されます。新しいゴールデンフレームが確立されて確認されると、altrefフレームの更新時に同じルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "+-------+-------------------+-------------------------+-------------+\n| Event | Sender            | Receiver                | Established |\n|       |                   |                         | reference   |\n+-------+-------------------+-------------------------+-------------+\n| 1000  | Send golden frame |                         |             |\n|       | PictureID = 0     |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      |             |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1001  |                   | Send RPSI(0)            |             |\n|       |                   |                         |             |\n| 1002  | Receive RPSI(0)   |                         | golden      |\n|       |                   |                         |             |\n| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1100  | Send altref frame |                         |             |\n|       | PictureID = 100   |                         |             |\n|       |                   |                         |             |\n|       |                   | Altref corrupted or     | golden      |\n|       |                   | lost                    |             |\n|       |                   |                         |             |\n| 1101  |                   | Send SLI(100)           | golden      |\n|       |                   |                         |             |\n| 1102  | Receive SLI(100)  |                         |             |\n|       |                   |                         |             |\n| 1103  | Send frame with   |                         |             |\n|       | reference to      |                         |             |\n|       | golden            |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | golden      |\n|       |                   | frame (decoder state    |             |\n|       |                   | restored)               |             |\n|       |                   |                         |             |\n| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1200  | Send altref frame |                         |             |\n|       | PictureID = 200   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | golden      |\n|       |                   | altref frame            |             |\n|       |                   |                         |             |\n| 1201  |                   | Send RPSI(200)          |             |\n|       |                   |                         |             |\n| 1202  | Receive RPSI(200) |                         | altref      |\n|       |                   |                         |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1300  | Send golden frame |                         |             |\n|       | PictureID = 300   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | altref      |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1301  |                   | Send RPSI(300)          | altref      |\n|       |                   |                         |             |\n| 1302  | RPSI lost         |                         |             |\n|       |                   |                         |             |\n| 1400  | Send golden frame |                         |             |\n|       | PictureID = 400   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | altref      |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1401  |                   | Send RPSI(400)          |             |\n|       |                   |                         |             |\n| 1402  | Receive RPSI(400) |                         | golden      |\n+-------+-------------------+-------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Table 1: Example Signaling between Sender and Receiver",
      "ja": "表1：送信者と受信者間のシグナリングの例"
    },
    {
      "indent": 3,
      "text": "Note that the scheme is robust to loss of the feedback messages. If the RPSI is lost, the sender will try to update the golden (or altref) again after a while, without releasing the established reference. Also, if an SLI is lost, the receiver can keep sending SLI messages at any interval allowed by the RTCP sending timing restrictions as specified in [RFC4585], as long as the picture is corrupted.",
      "ja": "スキームは、フィードバックメッセージの損失に対して堅牢であることに注意してください。 RPSIが失われた場合、送信者は、確立された参照を解放せずに、しばらくしてからゴールデン（またはaltref）を再度更新しようとします。また、SLIが失われた場合、受信者は、画像が破損している限り、[RFC4585]で指定されているRTCP送信タイミング制限で許可されている間隔でSLIメッセージを送信し続けることができます。"
    },
    {
      "indent": 0,
      "text": "6. Payload Format Parameters",
      "section_title": true,
      "ja": "6. ペイロード形式パラメータ"
    },
    {
      "indent": 3,
      "text": "This payload format has two optional parameters.",
      "ja": "このペイロード形式には、2つのオプションパラメータがあります。"
    },
    {
      "indent": 0,
      "text": "6.1. Media Type Definition",
      "section_title": true,
      "ja": "6.1. メディアタイプの定義"
    },
    {
      "indent": 3,
      "text": "This registration is done using the template defined in [RFC6838] and following [RFC4855].",
      "ja": "この登録は、[RFC6838]および次の[RFC4855]で定義されたテンプレートを使用して行われます。"
    },
    {
      "indent": 3,
      "text": "Type name: video",
      "ja": "タイプ名：ビデオ"
    },
    {
      "indent": 3,
      "text": "Subtype name: VP8",
      "ja": "サブタイプ名：VP8"
    },
    {
      "indent": 3,
      "text": "Required parameters: None.",
      "ja": "必須パラメーター：なし。"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションのパラメーター："
    },
    {
      "indent": 6,
      "text": "These parameters are used to signal the capabilities of a receiver implementation. If the implementation is willing to receive media, both parameters MUST be provided. These parameters MUST NOT be used for any other purpose.",
      "ja": "これらのパラメーターは、レシーバー実装の機能を通知するために使用されます。実装がメディアを受け入れる用意がある場合は、両方のパラメーターを指定する必要があります。これらのパラメーターを他の目的で使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "max-fr: The value of max-fr is an integer indicating the maximum frame rate in units of frames per second that the decoder is capable of decoding.",
      "ja": "max-fr：max-frの値は、デコーダーがデコードできる最大フレームレート（1秒あたりのフレーム数）を示す整数です。"
    },
    {
      "indent": 6,
      "text": "max-fs: The value of max-fs is an integer indicating the maximum frame size in units of macroblocks that the decoder is capable of decoding.",
      "ja": "max-fs：max-fsの値は、デコーダーがデコードできる最大ブロックサイズをマクロブロック単位で示す整数です。"
    },
    {
      "indent": 9,
      "text": "The decoder is capable of decoding this frame size as long as the width and height of the frame in macroblocks are less than int(sqrt(max-fs * 8)). For instance, a max-fs of 1200 (capable of supporting 640x480 resolution) will support widths and heights up to 1552 pixels (97 macroblocks).",
      "ja": "デコーダーは、マクロブロック内のフレームの幅と高さがint（sqrt（max-fs * 8））より小さい限り、このフレームサイズをデコードできます。たとえば、max-fsが1200（640x480の解像度をサポートできる）の場合、幅と高さが1552ピクセル（97マクロブロック）までサポートされます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed in RTP and contains binary data; see Section 4.8 of [RFC6838].",
      "ja": "エンコーディングに関する考慮事項：このメディアタイプはRTPでフレーム化され、バイナリデータを含みます。 [RFC6838]のセクション4.8をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 7 of RFC 7741.",
      "ja": "セキュリティに関する考慮事項：RFC 7741のセクション7をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: VP8 bitstream format [RFC6386] and RFC 7741.",
      "ja": "公開された仕様：VP8ビットストリーム形式[RFC6386]およびRFC 7741。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: For example: Video over IP, video conferencing.",
      "ja": "このメディアタイプを使用するアプリケーション：例：Video over IP、ビデオ会議。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A.",
      "ja": "フラグメント識別子の考慮事項：N / A。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Patrik Westin, patrik.westin@gmail.com",
      "ja": "詳細について連絡する人とメールアドレス：Patrik Westin、patrik.westin @ gmail.com"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "使用目的：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing, and hence it is only defined for transfer via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプはRTPフレーミングに依存するため、RTP [RFC3550]を介した転送に対してのみ定義されます。"
    },
    {
      "indent": 3,
      "text": "Author: Patrik Westin, patrik.westin@gmail.com",
      "ja": "作者：Patrik Westin、patrik.westin @ gmail.com"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Payload Working Group delegated from the IESG.",
      "ja": "変更管理者：IESGから委任されたIETFペイロードワーキンググループ。"
    },
    {
      "indent": 0,
      "text": "6.2. SDP Parameters",
      "section_title": true,
      "ja": "6.2. SDPパラメータ"
    },
    {
      "indent": 3,
      "text": "The receiver MUST ignore any fmtp parameter unspecified in this memo.",
      "ja": "受信者は、このメモで指定されていないfmtpパラメータを無視しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Mapping of Media Subtype Parameters to SDP",
      "section_title": true,
      "ja": "6.2.1. メディアサブタイプパラメータのSDPへのマッピング"
    },
    {
      "indent": 3,
      "text": "The media type video/VP8 string is mapped to fields in the Session Description Protocol (SDP) [RFC4566] as follows:",
      "ja": "メディアタイプvideo / VP8文字列は、Session Description Protocol（SDP）[RFC4566]のフィールドに次のようにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "o The media name in the \"m=\" line of SDP MUST be video.",
      "ja": "o SDPの「m =」行のメディア名はビデオである必要があります。"
    },
    {
      "indent": 3,
      "text": "o The encoding name in the \"a=rtpmap\" line of SDP MUST be VP8 (the media subtype).",
      "ja": "o SDPの「a = rtpmap」行のエンコーディング名はVP8（メディアサブタイプ）である必要があります。"
    },
    {
      "indent": 3,
      "text": "o The clock rate in the \"a=rtpmap\" line MUST be 90000.",
      "ja": "o 「a = rtpmap」行のクロックレートは90000でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The parameters \"max-fs\" and \"max-fr\" MUST be included in the \"a=fmtp\" line if the SDP is used to declare receiver capabilities. These parameters are expressed as a media subtype string, in the form of a semicolon-separated list of parameter=value pairs.",
      "ja": "o SDPを使用してレシーバー機能を宣言する場合は、パラメーター「max-fs」および「max-fr」を「a = fmtp」行に含める必要があります。これらのパラメータは、parameter = valueペアのセミコロンで区切られたリストの形式で、メディアサブタイプ文字列として表されます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Example",
      "section_title": true,
      "ja": "6.2.1.1. 例"
    },
    {
      "indent": 3,
      "text": "An example of media representation in SDP is as follows:",
      "ja": "SDPでのメディア表現の例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "m=video 49170 RTP/AVPF 98\na=rtpmap:98 VP8/90000\na=fmtp:98 max-fr=30; max-fs=3600;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2.2. Offer/Answer Considerations",
      "section_title": true,
      "ja": "6.2.2. オファー/アンサーの考慮事項"
    },
    {
      "indent": 3,
      "text": "The VP8 codec offers a decode complexity that is roughly linear with the number of pixels encoded. The parameters \"max-fr\" and \"max-fs\" are defined in Section 6.1, where the macroblock size is 16x16 pixels as defined in [RFC6386], the max-fs and max-fr parameters MUST be used to establish these limits.",
      "ja": "VP8コーデックは、エンコードされたピクセル数にほぼ比例する複雑なデコードを提供します。パラメータ「max-fr」と「max-fs」はセクション6.1で定義されており、マクロブロックサイズは[RFC6386]で定義されている16x16ピクセルです。これらの制限を確立するには、max-fsパラメータとmax-frパラメータを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [RFC3550], and in any applicable RTP profile such as RTP/AVP [RFC3551], RTP/AVPF [RFC4585], RTP/SAVP [RFC3711], or RTP/ SAVPF [RFC5124]. However, as \"Securing the RTP Protocol Framework: Why RTP Does Not Mandate a Single Media Security Solution\" [RFC7202] discusses, it is not an RTP payload format's responsibility to discuss or mandate what solutions are used to meet the basic security goals like confidentiality, integrity, and source authenticity for RTP in general. This responsibility lays on anyone using RTP in an application. They can find guidance on available security mechanisms and important considerations in \"Options for Securing RTP Sessions\" [RFC7201]. Applications SHOULD use one or more appropriate strong security mechanisms. The rest of this security consideration section discusses the security impacting properties of the payload format itself.",
      "ja": "この仕様で定義されたペイロード形式を使用するRTPパケットは、RTP仕様[RFC3550]、およびRTP / AVP [RFC3551]、RTP / AVPF [RFC4585]、RTP / SAVPなどの該当するRTPプロファイルで説明されているセキュリティの考慮事項に従います。 [RFC3711]、またはRTP / SAVPF [RFC5124]。ただし、「RTPプロトコルフレームワークのセキュリティ保護：RTPが単一のメディアセキュリティソリューションを義務付けない理由」[RFC7202]が説明しているように、機密性などの基本的なセキュリティ目標を達成するために使用されるソリューションについて話し合う、または義務付けることは、RTPペイロード形式の責任ではありません。 、整合性、および一般的なRTPのソースの信頼性。この責任は、アプリケーションでRTPを使用するすべての人にあります。利用可能なセキュリティメカニズムと重要な考慮事項に関するガイダンスは、「RTPセッションを保護するためのオプション」[RFC7201]にあります。アプリケーションは、1つ以上の適切な強力なセキュリティメカニズムを使用する必要があります。このセキュリティの考慮事項セクションの残りの部分では、ペイロード形式自体のセキュリティに影響を与えるプロパティについて説明します。"
    },
    {
      "indent": 3,
      "text": "This RTP payload format and its media decoder do not exhibit any significant difference in the receiver-side computational complexity for packet processing and, thus, are unlikely to pose a denial-of-service threat due to the receipt of pathological data. Nor does the RTP payload format contain any active content.",
      "ja": "このRTPペイロード形式とそのメディアデコーダは、パケット処理の受信側の計算の複雑さに大きな違いを示さないため、病理学的データの受信が原因でサービス拒否の脅威をもたらす可能性はほとんどありません。また、RTPペイロード形式にはアクティブコンテンツが含まれていません。"
    },
    {
      "indent": 0,
      "text": "8. Congestion Control",
      "section_title": true,
      "ja": "8. 輻輳制御"
    },
    {
      "indent": 3,
      "text": "Congestion control for RTP SHALL be used in accordance with RFC 3550 [RFC3550] and with any applicable RTP profile; e.g., RFC 3551 [RFC3551]. The congestion control mechanism can, in a real-time encoding scenario, adapt the transmission rate by instructing the encoder to encode at a certain target rate. Media-aware network elements MAY use the information in the VP8 payload descriptor in Section 4.2 to identify non-reference frames and discard them in order to reduce network congestion. Note that discarding of non-reference frames cannot be done if the stream is encrypted (because the non-reference marker is encrypted).",
      "ja": "RTPの輻輳制御は、RFC 3550 [RFC3550]および適用可能なRTPプロファイルに従って使用する必要があります（SHALL）。例：RFC 3551 [RFC3551]。輻輳制御メカニズムは、リアルタイムのエンコードシナリオで、特定のターゲットレートでエンコードするようにエンコーダーに指示することにより、伝送レートを適応させることができます。メディア対応ネットワーク要素は、セクション4.2のVP8ペイロード記述子の情報を使用して、非参照フレームを識別し、ネットワークの輻輳を軽減するためにそれらを破棄する場合があります。ストリームが暗号化されている場合、非参照フレームの破棄は実行できないことに注意してください（非参照マーカーが暗号化されているため）。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The IANA has registered a media type as described in Section 6.1.",
      "ja": "IANAは、セクション6.1で説明されているようにメディアタイプを登録しています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <http://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <http://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, <http://www.rfc-editor.org/info/rfc3551>.",
      "ja": "[RFC3551] Schulzrinne、H。およびS. Casner、「Minimal Controlを使用した音声およびビデオ会議のRTPプロファイル」、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、<http：//www.rfc-editor。 org / info / rfc3551>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <http://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566] Handley、M.、Jacobson、V。、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<http://www.rfc-editor.org/ info / rfc4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <http://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C。、およびJ. Rey、「​​リアルタイム転送制御プロトコル（RTCP）ベースのフィードバック用の拡張RTPプロファイル（RTP / AVPF） \"、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<http://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC4855] Casner, S., \"Media Type Registration of RTP Payload Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007, <http://www.rfc-editor.org/info/rfc4855>.",
      "ja": "[RFC4855] Casner、S。、「RTPペイロード形式のメディアタイプ登録」、RFC 4855、DOI 10.17487 / RFC4855、2007年2月、<http://www.rfc-editor.org/info/rfc4855>。"
    },
    {
      "indent": 3,
      "text": "[RFC6386] Bankoski, J., Koleszar, J., Quillio, L., Salonen, J., Wilkins, P., and Y. Xu, \"VP8 Data Format and Decoding Guide\", RFC 6386, DOI 10.17487/RFC6386, November 2011, <http://www.rfc-editor.org/info/rfc6386>.",
      "ja": "[RFC6386] Bankoski、J.、Koleszar、J.、Quillio、L.、Salonen、J.、Wilkins、P.、and Y. Xu、 \"VP8 Data Format and Decoding Guide\"、RFC 6386、DOI 10.17487 / RFC6386、 2011年11月、<http://www.rfc-editor.org/info/rfc6386>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <http://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「メディアタイプの仕様と登録手順」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<http：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <http://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711]バウアー、M。、マクルー、D。、ナスルンド、M。、カララ、E。、およびK.ノーマン、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、March 2004、<http://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC5124] Ott, J. and E. Carrara, \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\", RFC 5124, DOI 10.17487/RFC5124, February 2008, <http://www.rfc-editor.org/info/rfc5124>.",
      "ja": "[RFC5124] Ott、J。およびE. Carrara、「リアルタイム転送制御プロトコル（RTCP）ベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<http ：//www.rfc-editor.org/info/rfc5124>。"
    },
    {
      "indent": 3,
      "text": "[RFC7201] Westerlund, M. and C. Perkins, \"Options for Securing RTP Sessions\", RFC 7201, DOI 10.17487/RFC7201, April 2014, <http://www.rfc-editor.org/info/rfc7201>.",
      "ja": "[RFC7201] Westerlund、M。およびC. Perkins、「RTPセッションを保護するためのオプション」、RFC 7201、DOI 10.17487 / RFC7201、2014年4月、<http://www.rfc-editor.org/info/rfc7201>。"
    },
    {
      "indent": 3,
      "text": "[RFC7202] Perkins, C. and M. Westerlund, \"Securing the RTP Framework: Why RTP Does Not Mandate a Single Media Security Solution\", RFC 7202, DOI 10.17487/RFC7202, April 2014, <http://www.rfc-editor.org/info/rfc7202>.",
      "ja": "[RFC7202] Perkins、C。およびM. Westerlund、「RTPフレームワークの保護：RTPが単一のメディアセキュリティソリューションを義務付けない理由」、RFC 7202、DOI 10.17487 / RFC7202、2014年4月、<http：//www.rfc- editor.org/info/rfc7202>。"
    },
    {
      "indent": 3,
      "text": "[Sch07] Schwarz, H., Marpe, D., and T. Wiegand, \"Overview of the Scalable Video Coding Extension of the H.264/AVC Standard\", IEEE Transactions on Circuits and Systems for Video Technology, Volume 17: Issue 9, DOI 10.1109/TCSVT.2007.905532, September 2007, <http://dx.doi.org/10.1109/TCSVT.2007.905532>.",
      "ja": "[Sch07] Schwarz、H.、Marpe、D。、およびT. Wiegand、「H.264 / AVC標準のスケーラブルビデオコーディング拡張機能の概要」、ビデオテクノロジーのための回路およびシステムに関するIEEEトランザクション、第17巻：問題9、DOI 10.1109 / TCSVT.2007.905532、2007年9月、<http://dx.doi.org/10.1109/TCSVT.2007.905532>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Patrik Westin Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "Patrik Westin Google、Inc. 1600 Amphitheatre Parkway Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: patrik.westin@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Henrik F Lundin Google, Inc. Kungsbron 2 Stockholm 11122 Sweden",
      "ja": "Henrik F Lundin Google、Inc. Kungsbron 2ストックホルム11122スウェーデン"
    },
    {
      "indent": 3,
      "text": "Email: hlundin@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Glover Twitter Boston 10 Hemlock Way Durham, NH 03824 United States",
      "ja": "Michael Glover Twitter Boston 10 Hemlock Way Durham、NH 03824 United States"
    },
    {
      "indent": 3,
      "text": "Email: michaelglover262@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Justin Uberti Google, Inc. 747 6th Street South Kirkland, WA 98033 United States",
      "ja": "Justin Uberti Google、Inc. 747 6th Street South Kirkland、WA 98033アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: justin@uberti.name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Frank Galligan Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "フランクガリガンGoogle、Inc. 1600 Amphitheatre Parkway Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: fgalligan@google.com",
      "raw": true,
      "ja": ""
    }
  ]
}