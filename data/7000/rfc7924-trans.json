{
  "title": {
    "text": "RFC 7924 - Transport Layer Security (TLS) Cached Information Extension",
    "ja": "RFC 7924 - トランスポート層セキュリティ（TLS）キャッシュ情報拡張"
  },
  "number": 7924,
  "created_at": "2020-08-15 20:31:12.776453+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      S. Santesson\nRequest for Comments: 7924                               3xA Security AB\nCategory: Standards Track                                  H. Tschofenig\nISSN: 2070-1721                                                 ARM Ltd.\n                                                               July 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Transport Layer Security (TLS) Cached Information Extension",
      "ja": "トランスポート層セキュリティ（TLS）キャッシュ情報拡張"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) handshakes often include fairly static information, such as the server certificate and a list of trusted certification authorities (CAs). This information can be of considerable size, particularly if the server certificate is bundled with a complete certificate chain (i.e., the certificates of intermediate CAs up to the root CA).",
      "ja": "トランスポート層セキュリティ（TLS）ハンドシェイクには、サーバー証明書や信頼できる証明機関（CA）のリストなど、かなり静的な情報が含まれていることがよくあります。特にサーバー証明書が完全な証明書チェーン（つまり、ルートCAまでの中間CAの証明書）にバンドルされている場合、この情報はかなりのサイズになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This document defines an extension that allows a TLS client to inform a server of cached information, thereby enabling the server to omit already available information.",
      "ja": "このドキュメントでは、TLSクライアントがキャッシュされた情報をサーバーに通知できるようにする拡張機能を定義しているため、サーバーはすでに利用可能な情報を省略できます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7924.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7924で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3\n3.  Cached Information Extension  . . . . . . . . . . . . . . . .   3\n4.  Exchange Specification  . . . . . . . . . . . . . . . . . . .   5\n  4.1.  Server Certificate Message  . . . . . . . . . . . . . . .   6\n  4.2.  CertificateRequest Message  . . . . . . . . . . . . . . .   7\n5.  Fingerprint Calculation . . . . . . . . . . . . . . . . . . .   7\n6.  Example . . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  10\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  10\n  8.1.  New Entry to the TLS ExtensionType Registry . . . . . . .  10\n  8.2.  New Registry for CachedInformationType  . . . . . . . . .  11\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  11\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  12\nAppendix A.  Example  . . . . . . . . . . . . . . . . . . . . . .  13\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  18\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  19",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Reducing the amount of information exchanged during a Transport Layer Security handshake to a minimum helps to improve performance in environments where devices are connected to a network with a low bandwidth and lossy radio technology. With the Internet of Things, such environments exist, for example, when devices use IEEE 802.15.4, Bluetooth Low Energy, or low power wide area networks. For more information about the challenges with smart object deployments, please see [RFC6574].",
      "ja": "トランスポート層セキュリティハンドシェイク中に交換される情報量を最小限に抑えると、デバイスが低帯域幅で損失の多い無線技術を使用してネットワークに接続されている環境でのパフォーマンスを向上させることができます。モノのインターネットでは、そのような環境が存在します。たとえば、デバイスがIEEE 802.15.4、Bluetooth Low Energy、または低電力広域ネットワークを使用する場合です。スマートオブジェクトの配置に関する課題の詳細については、[RFC6574]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This specification defines a TLS extension that allows a client and a server to exclude transmission information cached in an earlier TLS handshake.",
      "ja": "この仕様は、クライアントとサーバーが以前のTLSハンドシェイクにキャッシュされた伝送情報を除外できるようにするTLS拡張を定義します。"
    },
    {
      "indent": 3,
      "text": "A typical example exchange may therefore look as follows. First, the client and the server execute the full TLS handshake. The client then caches the certificate provided by the server. When the TLS client connects to the TLS server some time in the future, without using session resumption, it then attaches the \"cached_info\" extension defined in this document to the ClientHello message to indicate that it has cached the certificate, and it provides the fingerprint of it. If the server's certificate has not changed, then the TLS server does not need to send its certificate and the corresponding certificate chain again. In case information has changed, which can be seen from the fingerprint provided by the client, the certificate payload is transmitted to the client to allow the client to update the cache.",
      "ja": "したがって、典型的な交換例は次のようになります。まず、クライアントとサーバーが完全なTLSハンドシェイクを実行します。次に、クライアントはサーバーから提供された証明書をキャッシュします。 TLSクライアントは、セッション再開を使用せずに、将来的にTLSサーバーに接続するときに、このドキュメントで定義されている「cached_info」拡張をClientHelloメッセージに添付して、証明書をキャッシュしたことを示し、フィンガープリントを提供しますそれの。サーバーの証明書が変更されていない場合、TLSサーバーはその証明書と対応する証明書チェーンを再度送信する必要はありません。クライアントによって提供されたフィンガープリントから確認できる情報が変更された場合、証明書ペイロードがクライアントに送信され、クライアントがキャッシュを更新できるようにします。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"MUST\", \"MUST NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「MUST」、「MUST NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document refers to the TLS protocol, but the description is equally applicable to Datagram Transport Layer Security (DTLS) as well.",
      "ja": "このドキュメントではTLSプロトコルについて言及していますが、説明はデータグラムトランスポート層セキュリティ（DTLS）にも同様に適用できます。"
    },
    {
      "indent": 0,
      "text": "3. Cached Information Extension",
      "section_title": true,
      "ja": "3. キャッシュ情報拡張"
    },
    {
      "indent": 3,
      "text": "This document defines a new extension type (cached_info(25)), which is used in ClientHello and ServerHello messages. The extension type is specified as follows.",
      "ja": "このドキュメントでは、ClientHelloメッセージとServerHelloメッセージで使用される新しい拡張タイプ（cached_info（25））を定義します。拡張タイプは次のように指定されます。"
    },
    {
      "indent": 9,
      "text": "enum {\n     cached_info(25), (65535)\n} ExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The extension_data field of this extension, when included in the ClientHello, MUST contain the CachedInformation structure. The client MAY send multiple CachedObjects of the same CachedInformationType. This may, for example, be the case when the client has cached multiple certificates from a server.",
      "ja": "この拡張のextension_dataフィールドは、ClientHelloに含まれている場合、CachedInformation構造を含んでいる必要があります。クライアントは同じCachedInformationTypeの複数のCachedObjectsを送信してもよい（MAY）。これは、たとえば、クライアントがサーバーからの複数の証明書をキャッシュした場合などです。"
    },
    {
      "indent": 9,
      "text": "enum {\n     cert(1), cert_req(2) (255)\n} CachedInformationType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n     select (type) {\n       case client:\n         CachedInformationType type;\n         opaque hash_value<1..255>;\n       case server:\n         CachedInformationType type;\n     } body;\n} CachedObject;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n     CachedObject cached_info<1..2^16-1>;\n} CachedInformation;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This document defines the following two types:",
      "ja": "このドキュメントでは、次の2つのタイプを定義しています。"
    },
    {
      "indent": 3,
      "text": "'cert' type for not sending the complete server certificate message:",
      "ja": "完全なサーバー証明書メッセージを送信しないための「cert」タイプ："
    },
    {
      "indent": 6,
      "text": "With the type field set to 'cert', the client MUST include the fingerprint of the Certificate message in the hash_value field. For this type, the fingerprint MUST be calculated using the procedure described in Section 5 with the Certificate message as input data.",
      "ja": "typeフィールドを「cert」に設定すると、クライアントは、hash_valueフィールドに証明書メッセージのフィンガープリントを含める必要があります。このタイプの場合、フィンガープリントは、入力データとして証明書メッセージを使用してセクション5で説明されている手順を使用して計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "'cert_req' Type for not sending the complete CertificateRequest Message:",
      "ja": "完全なCertificateRequestメッセージを送信しない場合の「cert_req」タイプ："
    },
    {
      "indent": 6,
      "text": "With the type set to 'cert_req', the client MUST include the fingerprint of the CertificateRequest message in the hash_value field. For this type, the fingerprint MUST be calculated using the procedure described in Section 5 with the CertificateRequest message as input data.",
      "ja": "タイプを「cert_req」に設定すると、クライアントは、CertificateRequestメッセージのフィンガープリントをhash_valueフィールドに含める必要があります。このタイプの場合、フィンガープリントは、セクション5で説明されている手順を使用して、CertificateRequestメッセージを入力データとして計算する必要があります。"
    },
    {
      "indent": 0,
      "text": " New cached info types can be added following the policy described in the IANA Considerations (Section 8). New message digest algorithms for use with these types can also be added by registering a new type that makes use of the updated message digest algorithm. For practical reasons, we recommend reusing hash algorithms already available with TLS ciphersuites. To avoid additional code and to keep the collision probability low, new hash algorithms MUST NOT have a collision resistance worse than SHA-256.",
      "ja": "IANAの考慮事項（セクション8）で説明されているポリシーに従って、新しいキャッシュ情報タイプを追加できます。これらのタイプで使用する新しいメッセージダイジェストアルゴリズムは、更新されたメッセージダイジェストアルゴリズムを利用する新しいタイプを登録することによっても追加できます。実用的な理由から、TLS暗号スイートですでに利用可能なハッシュアルゴリズムを再利用することをお勧めします。追加のコードを回避し、衝突の可能性を低く保つために、新しいハッシュアルゴリズムは、SHA-256よりも低い衝突耐性を持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Exchange Specification",
      "section_title": true,
      "ja": "4. 交換仕様"
    },
    {
      "indent": 3,
      "text": "Clients supporting this extension MAY include the \"cached_info\" extension in the (extended) ClientHello. If the client includes the extension, then it MUST contain one or more CachedObject attributes.",
      "ja": "この拡張をサポートするクライアントは、（拡張された）ClientHelloに「cached_info」拡張を含めることができます（MAY）。クライアントに拡張機能が含まれている場合は、1つ以上のCachedObject属性を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "A server supporting this extension MAY include the \"cached_info\" extension in the (extended) ServerHello. By returning the \"cached_info\" extension, the server indicates that it supports the cached info types. For each indicated cached info type, the server MUST alter the transmission of respective payloads, according to the rules outlined with each type. If the server includes the extension, it MUST only include CachedObjects of a type also supported by the client (as expressed in the ClientHello). For example, if a client indicates support for 'cert' and 'cert_req', then the server cannot respond with a \"cached_info\" attribute containing support for ('foo-bar').",
      "ja": "この拡張をサポートするサーバーは、（拡張された）ServerHelloに「cached_info」拡張を含めることができます（MAY）。 「cached_info」拡張を返すことにより、サーバーは、キャッシュされた情報タイプをサポートすることを示します。示されたキャッシュされた情報タイプごとに、サーバーは、各タイプで概説されているルールに従って、それぞれのペイロードの送信を変更しなければなりません（MUST）。サーバーに拡張機能が含まれている場合は、クライアントでサポートされているタイプのCachedObjectsのみを含める必要があります（ClientHelloで表現）。たとえば、クライアントが「cert」と「cert_req」のサポートを示している場合、サーバーは（「foo-bar」）のサポートを含む「cached_info」属性で応答できません。"
    },
    {
      "indent": 3,
      "text": "Since the client includes a fingerprint of information it cached (for each indicated type), the server is able to determine whether cached information is stale. If the server supports this specification and notices a mismatch between the data cached by the client and its own information, then the server MUST include the information in full and MUST NOT list the respective type in the \"cached_info\" extension.",
      "ja": "クライアントには、（示されたタイプごとに）キャッシュした情報のフィンガープリントが含まれているため、サーバーは、キャッシュされた情報が古くなっているかどうかを判断できます。サーバーがこの仕様をサポートし、クライアントによってキャッシュされたデータとそれ自体の情報の不一致に気づいた場合、サーバーは情報を完全に含めなければならず（MUST）、「cached_info」拡張にそれぞれのタイプをリストしてはいけません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Note: If a server is part of a hosting environment, then the client may have cached multiple data items for a single server. To allow the client to select the appropriate information from the cache, it is RECOMMENDED that the client utilizes the Server Name Indication (SNI) extension [RFC6066].",
      "ja": "注：サーバーがホスティング環境の一部である場合、クライアントは単一のサーバーの複数のデータ項目をキャッシュしている可能性があります。クライアントがキャッシュから適切な情報を選択できるようにするには、クライアントがサーバー名表示（SNI）拡張[RFC6066]を利用することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Following a successful exchange of the \"cached_info\" extension in the ClientHello and ServerHello, the server alters sending the corresponding handshake message. How information is altered from the handshake messages and for the types defined in this specification is defined in Sections 4.1 and 4.2, respectively.",
      "ja": "ClientHelloおよびServerHelloの「cached_info」拡張の交換が成功した後、サーバーは対応するハンドシェイクメッセージの送信を変更します。情報がハンドシェイクメッセージからどのように変更されるか、およびこの仕様で定義されているタイプについては、それぞれセクション4.1および4.2で定義されています。"
    },
    {
      "indent": 3,
      "text": "Appendix A shows an example hash calculation, and Section 6 illustrates an example protocol exchange.",
      "ja": "付録Aはハッシュ計算の例を示し、セクション6はプロトコル交換の例を示します。"
    },
    {
      "indent": 0,
      "text": "4.1. Server Certificate Message",
      "section_title": true,
      "ja": "4.1. サーバー証明書メッセージ"
    },
    {
      "indent": 3,
      "text": "When a ClientHello message contains the \"cached_info\" extension with a type set to 'cert', then the server MAY send the Certificate message shown in Figure 1 under the following conditions:",
      "ja": "ClientHelloメッセージにタイプが「cert」に設定された「cached_info」拡張が含まれている場合、サーバーは次の条件下で図1に示す証明書メッセージを送信できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "o The server software implements the \"cached_info\" extension defined in this specification.",
      "ja": "o サーバーソフトウェアは、この仕様で定義されている「cached_info」拡張機能を実装しています。"
    },
    {
      "indent": 3,
      "text": "o The 'cert' \"cached_info\" extension is enabled (for example, a policy allows the use of this extension).",
      "ja": "o 「cert」「cached_info」拡張機能が有効になっている（たとえば、ポリシーでこの拡張機能の使用が許可されている）。"
    },
    {
      "indent": 3,
      "text": "o The server compared the value in the hash_value field of the client-provided \"cached_info\" extension with the fingerprint of the Certificate message it normally sends to clients. This check ensures that the information cached by the client is current. The procedure for calculating the fingerprint is described in Section 5.",
      "ja": "o サーバーは、クライアントが提供する「cached_info」拡張のhash_valueフィールドの値を、サーバーが通常クライアントに送信する証明書メッセージのフィンガープリントと比較しました。このチェックは、クライアントによってキャッシュされた情報が最新であることを確認します。フィンガープリントを計算する手順については、セクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "The original certificate handshake message syntax is defined in [RFC5246] and has been extended with [RFC7250]. RFC 7250 allows the certificate payload to contain only the SubjectPublicKeyInfo instead of the full information typically found in a certificate. Hence, when this specification is used in combination with [RFC7250] and the negotiated certificate type is a raw public key, then the TLS server omits sending a certificate payload that contains an ASN.1 certificate structure with the included SubjectPublicKeyInfo rather than the full certificate chain. As such, this extension is compatible with the raw public key extension defined in RFC 7250. Note: We assume that the server implementation is able to select the appropriate certificate or SubjectPublicKeyInfo from the received hash value. If the SNI extension is used by the client, then the server has additional information to guide the selection of the appropriate cached info.",
      "ja": "オリジナルの証明書ハンドシェイクメッセージの構文は[RFC5246]で定義されており、[RFC7250]で拡張されています。 RFC 7250では、証明書のペイロードに、証明書に通常見られる完全な情報ではなく、SubjectPublicKeyInfoのみを含めることができます。したがって、この仕様が[RFC7250]と組み合わせて使用​​され、ネゴシエートされた証明書タイプが生の公開鍵である場合、TLSサーバーは、完全な証明書ではなく、含まれるSubjectPublicKeyInfoを含むASN.1証明書構造を含む証明書ペイロードの送信を省略します。鎖。そのため、この拡張はRFC 7250で定義された生の公開鍵拡張と互換性があります。注：サーバーの実装は、受信したハッシュ値から適切な証明書またはSubjectPublicKeyInfoを選択できると想定しています。 SNI拡張がクライアントによって使用される場合、サーバーには適切なキャッシュ情報の選択をガイドする追加情報があります。"
    },
    {
      "indent": 3,
      "text": "When the cached info specification is used, then a modified version of the Certificate message is exchanged. The modified structure is shown in Figure 1.",
      "ja": "キャッシュされた情報仕様が使用されると、証明書メッセージの変更されたバージョンが交換されます。変更された構造を図1に示します。"
    },
    {
      "indent": 9,
      "text": "struct {\n    opaque hash_value<1..255>;\n} Certificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 1: Cached Info Certificate Message",
      "ja": "図1：キャッシュされた情報証明書メッセージ"
    },
    {
      "indent": 0,
      "text": "4.2. CertificateRequest Message",
      "section_title": true,
      "ja": "4.2. CertificateRequestメッセージ"
    },
    {
      "indent": 3,
      "text": "When a fingerprint for an object of type 'cert_req' is provided in the ClientHello, the server MAY send the CertificateRequest message shown in Figure 2 under the following conditions:",
      "ja": "タイプ 'cert_req'のオブジェクトのフィンガープリントがClientHelloで提供されると、サーバーは、以下の条件下で図2に示すCertificateRequestメッセージを送信できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "o The server software implements the \"cached_info\" extension defined in this specification.",
      "ja": "o サーバーソフトウェアは、この仕様で定義されている「cached_info」拡張機能を実装しています。"
    },
    {
      "indent": 3,
      "text": "o The 'cert_req' \"cached_info\" extension is enabled (for example, a policy allows the use of this extension).",
      "ja": "o 「cert_req」「cached_info」拡張機能が有効になっている（たとえば、ポリシーでこの拡張機能の使用が許可されている）。"
    },
    {
      "indent": 3,
      "text": "o The server compared the value in the hash_value field of the client-provided \"cached_info\" extension with the fingerprint of the CertificateRequest message it normally sends to clients. This check ensures that the information cached by the client is current. The procedure for calculating the fingerprint is described in Section 5.",
      "ja": "o サーバーは、クライアントが提供する「cached_info」拡張のhash_valueフィールドの値を、通常クライアントに送信するCertificateRequestメッセージのフィンガープリントと比較しました。このチェックは、クライアントによってキャッシュされた情報が最新であることを確認します。フィンガープリントを計算する手順については、セクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "o The server wants to request a certificate from the client.",
      "ja": "o サーバーはクライアントに証明書を要求します。"
    },
    {
      "indent": 3,
      "text": "The original CertificateRequest handshake message syntax is defined in [RFC5246]. The modified structure of the CertificateRequest message is shown in Figure 2.",
      "ja": "元のCertificateRequestハンドシェイクメッセージの構文は、[RFC5246]で定義されています。 CertificateRequestメッセージの変更された構造を図2に示します。"
    },
    {
      "indent": 9,
      "text": "struct {\n    opaque hash_value<1..255>;\n} CertificateRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 2: Cached Info CertificateRequest Message",
      "ja": "図2：キャッシュされたInfo CertificateRequestメッセージ"
    },
    {
      "indent": 3,
      "text": "The CertificateRequest payload is the input parameter to the fingerprint calculation described in Section 5.",
      "ja": "CertificateRequestペイロードは、セクション5で説明するフィンガープリント計算への入力パラメーターです。"
    },
    {
      "indent": 0,
      "text": "5. Fingerprint Calculation",
      "section_title": true,
      "ja": "5. 指紋の計算"
    },
    {
      "indent": 3,
      "text": "The fingerprint for the two cached info objects defined in this document MUST be computed as follows:",
      "ja": "このドキュメントで定義されている2つのキャッシュされた情報オブジェクトのフィンガープリントは、次のように計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Compute the SHA-256 [RFC6234] hash of the input data. The input data depends on the cached info type. This document defines two cached info types, described in Sections 4.1 and in 4.2. Note that the computed hash only covers the input data structure (and not any type and length information of the record layer). Appendix A shows an example.",
      "ja": "1. 入力データのSHA-256 [RFC6234]ハッシュを計算します。入力データは、キャッシュされた情報タイプによって異なります。このドキュメントでは、セクション4.1と4.2で説明されている2つのキャッシュされた情報タイプを定義します。計算されたハッシュは入力データ構造のみをカバーすることに注意してください（レコードレイヤーのタイプと長さの情報はカバーしません）。付録Aに例を示します。"
    },
    {
      "indent": 3,
      "text": "2. Use the output of the SHA-256 hash.",
      "ja": "2. SHA-256ハッシュの出力を使用します。"
    },
    {
      "indent": 3,
      "text": "The purpose of the fingerprint provided by the client is to help the server select the correct information. For example, in case of a Certificate message, the fingerprint identifies the server certificate (and the corresponding private key) for use with the rest of the handshake. Servers may have more than one certificate, and therefore a hash needs to be long enough to keep the probably of hash collisions low. On the other hand, the cached info design aims to reduce the amount of data being exchanged. The security of the handshake depends on the private key and not on the size of the fingerprint. Hence, the fingerprint is a way to prevent the server from accidentally selecting the wrong information. If an attacker injects an incorrect fingerprint, then two outcomes are possible: (1) the fingerprint does not relate to any cached state and the server has to fall back to a full exchange, and (2) if the attacker manages to inject a fingerprint that refers to data the client has not cached, then the exchange will fail later when the client continues with the handshake and aims to verify the digital signature. The signature verification will fail since the public key cached by the client will not correspond to the private key that was used by the server to sign the message.",
      "ja": "クライアントが提供するフィンガープリントの目的は、サーバーが正しい情報を選択できるようにすることです。たとえば、証明書メッセージの場合、フィンガープリントは、残りのハンドシェイクで使用するサーバー証明書（および対応する秘密鍵）を識別します。サーバーには複数の証明書がある場合があるため、ハッシュは、ハッシュの衝突の可能性を低く保つのに十分な長さである必要があります。一方、キャッシュされた情報の設計は、交換されるデータの量を減らすことを目的としています。ハンドシェイクのセキュリティは、指紋のサイズではなく秘密鍵に依存します。したがって、フィンガープリントは、サーバーが誤って間違った情報を選択するのを防ぐ方法です。攻撃者が不正なフィンガープリントを挿入した場合、2つの結果が考えられます：（1）フィンガープリントがキャッシュされた状態に関連せず、サーバーは完全な交換にフォールバックする必要がある、（2）攻撃者がフィンガープリントを注入した場合これは、クライアントがキャッシュしていないデータを参照します。その後、クライアントがハンドシェイクを続行し、デジタル署名の検証を目的とする場合、交換は後で失敗します。クライアントがキャッシュした公開鍵は、サーバーがメッセージの署名に使用した秘密鍵に対応しないため、署名の検証は失敗します。"
    },
    {
      "indent": 0,
      "text": "6. Example",
      "section_title": true,
      "ja": "6. 例"
    },
    {
      "indent": 3,
      "text": "In the regular, full TLS handshake exchange, shown in Figure 3, the TLS server provides its certificate in the certificate payload to the client; see step (1). This allows the client to store the certificate for future use. After some time, the TLS client again interacts with the same TLS server and makes use of the TLS \"cached_info\" extension, as shown in Figure 4. The TLS client indicates support for this specification via the \"cached_info\" extension, see step (2), and indicates that it has stored the certificate from the earlier exchange (by indicating the 'cert' type). With step (3), the TLS server acknowledges the support of the 'cert' type and by including the value in the ServerHello, it informs the client that the content of the certificate payload contains the fingerprint of the certificate instead of the payload, defined in RFC 5246, of the Certificate message; see step (4).",
      "ja": "図3に示すように、通常の完全なTLSハンドシェイク交換では、TLSサーバーは証明書ペイロードの証明書をクライアントに提供します。手順（1）を参照してください。これにより、クライアントは将来使用するために証明書を保存できます。しばらくすると、TLSクライアントは再び同じTLSサーバーと対話し、図4に示すようにTLSの「cached_info」拡張を利用します。TLSクライアントは、「cached_info」拡張を介してこの仕様のサポートを示します。ステップ（2 ）、それが以前の交換からの証明書を格納したことを示します（「証明書」タイプを示すことにより）。ステップ（3）で、TLSサーバーは「cert」タイプのサポートを確認し、ServerHelloに値を含めることで、証明書ペイロードのコンテンツに、定義されたペイロードではなく証明書のフィンガープリントが含まれていることをクライアントに通知します証明書メッセージのRFC 5246で。手順（4）を参照してください。"
    },
    {
      "indent": 3,
      "text": "ClientHello            ->\n                       <-  ServerHello\n                           Certificate* // (1)\n                           ServerKeyExchange*\n                           CertificateRequest*\n                           ServerHelloDone",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Certificate* ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished ->",
      "ja": "証明書* ClientKeyExchange CertificateVerify * [ChangeCipherSpec]完了->"
    },
    {
      "indent": 26,
      "text": "<- [ChangeCipherSpec] Finished",
      "ja": "<-[ChangeCipherSpec]完了"
    },
    {
      "indent": 3,
      "text": "Application Data <-------> Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 3: Example Message Exchange: Initial (Full) Exchange",
      "ja": "図3：メッセージ交換の例：初期（完全）交換"
    },
    {
      "indent": 3,
      "text": "ClientHello cached_info=(cert) -> // (2) <- ServerHello cached_info=(cert) (3) Certificate (4) ServerKeyExchange* ServerHelloDone",
      "ja": "ClientHello cached_info =（cert）-> //（2）<-ServerHello cached_info =（cert）（3）証明書（4）ServerKeyExchange * ServerHelloDone"
    },
    {
      "indent": 3,
      "text": "ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished ->",
      "ja": "ClientKeyExchange CertificateVerify * [ChangeCipherSpec]完了->"
    },
    {
      "indent": 26,
      "text": "<- [ChangeCipherSpec] Finished",
      "ja": "<-[ChangeCipherSpec]完了"
    },
    {
      "indent": 3,
      "text": "Application Data <-------> Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 4: Example Message Exchange: TLS Cached Extension Usage",
      "ja": "図4：メッセージ交換の例：TLSキャッシュ拡張機能の使用"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism to reference stored state using a fingerprint. Sending a fingerprint of cached information in an unencrypted handshake, as the ClientHello and ServerHello does, may allow an attacker or observer to correlate independent TLS exchanges. While some information elements used in this specification, such as server certificates, are public objects and usually do not contain sensitive information, other types that are not yet defined may. Those who implement and deploy this specification should therefore make an informed decision whether the cached information is in line with their security and privacy goals. In case of concerns, it is advised to avoid sending the fingerprint of the data objects in clear.",
      "ja": "この仕様は、フィンガープリントを使用して保存された状態を参照するメカニズムを定義します。暗号化されていないハンドシェイクでキャッシュされた情報のフィンガープリントを送信すると、ClientHelloおよびServerHelloが行うように、攻撃者またはオブザーバーが独立したTLS交換を相関させる可能性があります。この仕様で使用されている一部の情報要素（サーバー証明書など）はパブリックオブジェクトであり、通常は機密情報が含まれていませんが、まだ定義されていない他のタイプは含まれる場合があります。したがって、この仕様を実装して展開する人は、キャッシュされた情報がセキュリティとプライバシーの目標に沿っているかどうかを、十分な情報に基づいて決定する必要があります。懸念がある場合は、データオブジェクトのフィンガープリントを平文で送信しないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The use of the \"cached_info\" extension allows the server to send significantly smaller TLS messages. Consequently, these omitted parts of the messages are not included in the transcript of the handshake in the TLS Finish message. However, since the client and the server communicate the hash values of the cached data in the initial handshake messages, the fingerprints are included in the TLS Finish message.",
      "ja": "「cached_info」拡張を使用すると、サーバーは大幅に小さいTLSメッセージを送信できます。したがって、これらのメッセージの省略された部分は、TLS完了メッセージのハンドシェイクのトランスクリプトには含まれません。ただし、クライアントとサーバーは最初のハンドシェイクメッセージでキャッシュデータのハッシュ値を通信するため、フィンガープリントはTLS完了メッセージに含まれます。"
    },
    {
      "indent": 3,
      "text": "Clients MUST ensure that they only cache information from legitimate sources. For example, when the client populates the cache from a TLS exchange, then it must only cache information after the successful completion of a TLS exchange to ensure that an attacker does not inject incorrect information into the cache. Failure to do so allows for man-in-the-middle attacks.",
      "ja": "クライアントは、正当なソースからの情報のみをキャッシュするようにする必要があります。たとえば、クライアントがTLS交換からキャッシュにデータを入力する場合、攻撃者が不正な情報をキャッシュに注入しないようにするために、TLS交換が正常に完了した後にのみ、情報をキャッシュする必要があります。そうしないと、中間者攻撃が可能になります。"
    },
    {
      "indent": 3,
      "text": "Security considerations for the fingerprint calculation are discussed in Section 5.",
      "ja": "フィンガープリント計算のセキュリティに関する考慮事項については、セクション5で説明します。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. New Entry to the TLS ExtensionType Registry",
      "section_title": true,
      "ja": "8.1. TLS ExtensionTypeレジストリへの新しいエントリ"
    },
    {
      "indent": 3,
      "text": "IANA has added an entry to the existing TLS \"ExtensionType Values\" registry, defined in [RFC5246], for cached_info(25) defined in this document.",
      "ja": "IANAは、このドキュメントで定義されているcached_info（25）について、[RFC5246]で定義されている既存のTLS \"ExtensionType Values\"レジストリにエントリを追加しました。"
    },
    {
      "indent": 0,
      "text": "8.2. New Registry for CachedInformationType",
      "section_title": true,
      "ja": "8.2. CachedInformationTypeの新しいレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has established a registry titled \"TLS CachedInformationType Values\". The entries in the registry are:",
      "ja": "IANAは、「TLS CachedInformationType Values」という名前のレジストリを確立しました。レジストリのエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Description\n-----    -----------\n  0      Reserved\n  1      cert\n  2      cert_req\n224-255  Reserved for Private Use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The policy for adding new values to this registry, following the terminology defined in [RFC5226], is as follows:",
      "ja": "[RFC5226]で定義されている用語に従って、このレジストリに新しい値を追加するためのポリシーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o 0-63 (decimal): Standards Action",
      "ja": "o 0-63（10進数）：標準アクション"
    },
    {
      "indent": 3,
      "text": "o 64-223 (decimal): Specification Required",
      "ja": "o 64-223（10進数）：指定が必要"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<http：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ASN.1-Dump] Gutmann, P., \"ASN.1 Object Dump Program\", November 2010, <http://manpages.ubuntu.com/manpages/precise/man1/ dumpasn1.1.html>.",
      "ja": "[ASN.1-Dump] Gutmann、P。、「ASN.1 Object Dump Program」、2010年11月、<http://manpages.ubuntu.com/manpages/precise/man1/ dumpasn1.1.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org / info / rfc5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC6574] Tschofenig, H. and J. Arkko, \"Report from the Smart Object Workshop\", RFC 6574, DOI 10.17487/RFC6574, April 2012, <http://www.rfc-editor.org/info/rfc6574>.",
      "ja": "[RFC6574] Tschofenig、H。およびJ. Arkko、「Report from the Smart Object Workshop」、RFC 6574、DOI 10.17487 / RFC6574、2012年4月、<http://www.rfc-editor.org/info/rfc6574>。"
    },
    {
      "indent": 3,
      "text": "[RFC7250] Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J., Weiler, S., and T. Kivinen, \"Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", RFC 7250, DOI 10.17487/RFC7250, June 2014, <http://www.rfc-editor.org/info/rfc7250>.",
      "ja": "[RFC7250] Wouters、P.、Ed。、Tschofenig、H.、Ed。、Gilmore、J.、Weiler、S.、and T. Kivinen、 \"Using Raw Public Keys in Transport Layer Security（TLS）and Datagram Transport Layerセキュリティ（DTLS）」、RFC 7250、DOI 10.17487 / RFC7250、2014年6月、<http://www.rfc-editor.org/info/rfc7250>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example",
      "section_title": true,
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "Consider a certificate containing a NIST P256 elliptic curve public key displayed using Peter Gutmann's ASN.1 decoder [ASN.1-Dump] in Figure 5.",
      "ja": "図5のPeter GutmannのASN.1デコーダー[ASN.1-Dump]を使用して表示されたNIST P256楕円曲線公開鍵を含む証明書を考えてみましょう。"
    },
    {
      "indent": 2,
      "text": "  0 556: SEQUENCE {\n  4 434:   SEQUENCE {\n  8   3:     [0] {\n 10   1:       INTEGER 2\n       :       }\n 13   1:     INTEGER 13\n 16  10:     SEQUENCE {\n 18   8:      OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)\n       :       }\n 28  62:     SEQUENCE {\n 30  11:       SET {\n 32   9:         SEQUENCE {\n 34   3:           OBJECT IDENTIFIER countryName (2 5 4 6)\n 39   2:           PrintableString 'NL'\n       :           }\n       :         }\n 43  17:       SET {\n 45  15:         SEQUENCE {\n 47   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)\n 52   8:           PrintableString 'PolarSSL'\n       :           }\n       :         }\n 62  28:       SET {\n 64  26:         SEQUENCE {\n 66   3:           OBJECT IDENTIFIER commonName (2 5 4 3)\n 71  19:           PrintableString 'Polarssl Test EC CA'\n       :           }\n       :         }\n       :       }\n 92  30:     SEQUENCE {\n 94  13:       UTCTime 24/09/2013 15:52:04 GMT\n109  13:       UTCTime 22/09/2023 15:52:04 GMT\n       :       }\n124  65:     SEQUENCE {\n126  11:       SET {\n128   9:         SEQUENCE {\n130   3:           OBJECT IDENTIFIER countryName (2 5 4 6)\n135   2:           PrintableString 'NL'\n       :           }\n       :         }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  139  17:       SET {\n  141  15:         SEQUENCE {\n  143   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)\n  148   8:           PrintableString 'PolarSSL'\n         :           }\n         :         }\n  158  31:       SET {\n  160  29:         SEQUENCE {\n  162   3:           OBJECT IDENTIFIER commonName (2 5 4 3)\n  167  22:           PrintableString 'PolarSSL Test Client 2'\n         :           }\n         :         }\n         :       }\n  191  89:     SEQUENCE {\n  193  19:       SEQUENCE {\n  195   7:         OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)\n  204   8:         OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7)\n         :         }\n  214  66:       BIT STRING\n         :         04 57 E5 AE B1 73 DF D3 AC BB 93 B8 81 FF 12 AE\n         :         EE E6 53 AC CE 55 53 F6 34 0E CC 2E E3 63 25 0B\n         :         DF 98 E2 F3 5C 60 36 96 C0 D5 18 14 70 E5 7F 9F\n         :         D5 4B 45 18 E5 B0 6C D5 5C F8 96 8F 87 70 A3 E4\n         :         C7\n         :       }\n  282 157:     [3] {\n  285 154:       SEQUENCE {\n  288   9:         SEQUENCE {\n  290   3:           OBJECT IDENTIFIER basicConstraints (2 5 29 19)\n  295   2:           OCTET STRING, encapsulates {\n  297   0:             SEQUENCE {}\n         :             }\n         :           }\n  299  29:         SEQUENCE {\n  301   3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)\n  306  22:           OCTET STRING, encapsulates {\n  308  20:             OCTET STRING\n         :              7A 00 5F 86 64 FC E0 5D E5 11 10 3B B2 E6 3B C4\n         :              26 3F CF E2\n         :             }\n         :           }\n  330 110:         SEQUENCE {\n  332   3:          OBJECT IDENTIFIER authorityKeyIdentifier (2 5 29 35)\n  337 103:          OCTET STRING, encapsulates {\n  339 101:             SEQUENCE {\n  341  20:               [0]\n         :               9D 6D 20 24 49 01 3F 2B CB 78 B5 19 BC 7E 24\n         :               C9 DB FB 36 7C\n  363  66:               [1] {\n  365  64:                 [4] {\n  367  62:                   SEQUENCE {\n  369  11:                     SET {\n  371   9:                      SEQUENCE {\n  373   3:                       OBJECT IDENTIFIER countryName (2 5 4 6)\n  378   2:                       PrintableString 'NL'\n         :                       }\n         :                      }\n  382  17:                     SET {\n  384  15:                      SEQUENCE {\n  386   3:                        OBJECT IDENTIFIER organizationName\n         :                               (2 5 4 10)\n  391   8:                        PrintableString 'PolarSSL'\n         :                        }\n         :                      }\n  401  28:                     SET {\n  403  26:                      SEQUENCE {\n  405   3:                       OBJECT IDENTIFIER commonName (2 5 4 3)\n  410  19:                       PrintableString 'Polarssl Test EC CA'\n         :                        }\n         :                      }\n         :                     }\n         :                   }\n         :                 }\n  431   9:               [2] 00 C1 43 E2 7E 62 43 CC E8\n         :               }\n         :             }\n         :           }\n         :         }\n         :       }\n         :     }\n  442  10:   SEQUENCE {\n  444   8:     OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)\n         :     }\n  454 104:   BIT STRING, encapsulates {\n  457 101:     SEQUENCE {\n  459  48:       INTEGER\n         :         4A 65 0D 7B 20 83 A2 99 B9 A8 0F FC 8D EE 8F 3D\n         :         BB 70 4C 96 03 AC 8E 78 70 DD F2 0E A0 B2 16 CB\n         :         65 8E 1A C9 3F 2C 61 7E F8 3C EF AD 1C EE 36 20",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "509  49:       INTEGER\n       :         00 9D F2 27 A6 D5 74 B8 24 AE E1 6A 3F 31 A1 CA\n       :         54 2F 08 D0 8D EE 4F 0C 61 DF 77 78 7D B4 FD FC\n       :         42 49 EE E5 B2 6A C2 CD 26 77 62 8E 28 7C 9E 57\n       :         45\n       :       }\n       :     }\n       :   }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 5: ASN.1-Based Certificate: Example",
      "ja": "図5：ASN.1ベースの証明書：例"
    },
    {
      "indent": 3,
      "text": "To include the certificate shown in Figure 5 in a TLS/DTLS Certificate message, it is prepended with a message header. This Certificate message header in our example is 0b 00 02 36 00 02 33 00 02 00 02 30, which indicates:",
      "ja": "図5に示す証明書をTLS / DTLS証明書メッセージに含めるには、メッセージヘッダーを付加します。この例のこの証明書メッセージヘッダーは0b 00 02 36 00 02 33 00 02 00 02 30で、次のことを示しています。"
    },
    {
      "indent": 3,
      "text": "Message Type: 0b -- 1-byte type field indicating a Certificate message",
      "ja": "メッセージタイプ：0b-証明書メッセージを示す1バイトのタイプフィールド"
    },
    {
      "indent": 3,
      "text": "Length: 00 02 36 -- 3-byte length field indicating a 566-byte payload",
      "ja": "長さ：00 02 36-566バイトのペイロードを示す3バイトの長さフィールド"
    },
    {
      "indent": 3,
      "text": "Certificates Length: 00 02 33 -- 3-byte length field indicating 563 bytes for the entire certificates_list structure, which may contain multiple certificates. In our example, only one certificate is included.",
      "ja": "証明書の長さ：00 02 33-3バイトの長さフィールド。複数の証明書を含む可能性のある、certificates_list構造全体の563バイトを示します。この例では、証明書が1つだけ含まれています。"
    },
    {
      "indent": 3,
      "text": "Certificate Length:  00 02 30 -- 3-byte length field indicating 560\n   bytes of the actual certificate following immediately afterwards.\n   In our example, this is the certificate content with 30 82 02 ....\n   9E 57 45 shown in Figure 6.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The hex encoding of the ASN.1-encoded certificate payload shown in Figure 5 leads to the following encoding.",
      "ja": "図5に示すASN.1でエンコードされた証明書ペイロードの16進エンコーディングは、次のエンコーディングになります。"
    },
    {
      "indent": 13,
      "text": "30 82 02 2C 30 82 01 B2  A0 03 02 01 02 02 01 0D\n30 0A 06 08 2A 86 48 CE  3D 04 03 02 30 3E 31 0B\n30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06\n03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1C\n30 1A 06 03 55 04 03 13  13 50 6F 6C 61 72 73 73\n6C 20 54 65 73 74 20 45  43 20 43 41 30 1E 17 0D\n31 33 30 39 32 34 31 35  35 32 30 34 5A 17 0D 32\n33 30 39 32 32 31 35 35  32 30 34 5A 30 41 31 0B\n30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06\n03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1F\n30 1D 06 03 55 04 03 13  16 50 6F 6C 61 72 53 53\n4C 20 54 65 73 74 20 43  6C 69 65 6E 74 20 32 30\n59 30 13 06 07 2A 86 48  CE 3D 02 01 06 08 2A 86\n48 CE 3D 03 01 07 03 42  00 04 57 E5 AE B1 73 DF\nD3 AC BB 93 B8 81 FF 12  AE EE E6 53 AC CE 55 53\nF6 34 0E CC 2E E3 63 25  0B DF 98 E2 F3 5C 60 36\n96 C0 D5 18 14 70 E5 7F  9F D5 4B 45 18 E5 B0 6C\nD5 5C F8 96 8F 87 70 A3  E4 C7 A3 81 9D 30 81 9A\n30 09 06 03 55 1D 13 04  02 30 00 30 1D 06 03 55\n1D 0E 04 16 04 14 7A 00  5F 86 64 FC E0 5D E5 11\n10 3B B2 E6 3B C4 26 3F  CF E2 30 6E 06 03 55 1D\n23 04 67 30 65 80 14 9D  6D 20 24 49 01 3F 2B CB\n78 B5 19 BC 7E 24 C9 DB  FB 36 7C A1 42 A4 40 30\n3E 31 0B 30 09 06 03 55  04 06 13 02 4E 4C 31 11\n30 0F 06 03 55 04 0A 13  08 50 6F 6C 61 72 53 53\n4C 31 1C 30 1A 06 03 55  04 03 13 13 50 6F 6C 61\n72 73 73 6C 20 54 65 73  74 20 45 43 20 43 41 82\n09 00 C1 43 E2 7E 62 43  CC E8 30 0A 06 08 2A 86\n48 CE 3D 04 03 02 03 68  00 30 65 02 30 4A 65 0D\n7B 20 83 A2 99 B9 A8 0F  FC 8D EE 8F 3D BB 70 4C\n96 03 AC 8E 78 70 DD F2  0E A0 B2 16 CB 65 8E 1A\nC9 3F 2C 61 7E F8 3C EF  AD 1C EE 36 20 02 31 00\n9D F2 27 A6 D5 74 B8 24  AE E1 6A 3F 31 A1 CA 54\n2F 08 D0 8D EE 4F 0C 61  DF 77 78 7D B4 FD FC 42\n49 EE E5 B2 6A C2 CD 26  77 62 8E 28 7C 9E 57 45",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 6: Hex Encoding of the Example Certificate",
      "ja": "図6：証明書例の16進エンコーディング"
    },
    {
      "indent": 3,
      "text": "Applying the SHA-256 hash function to the Certificate message, which starts with 0b 00 02 and ends with 9E 57 45, produces 0x086eefb4859adfe977defac494fff6b73033b4ce1f86b8f2a9fc0c6bf98605af.",
      "ja": "0b 00 02で始まり9E 57 45で終わる証明書メッセージにSHA-256ハッシュ関数を適用すると、0x086eefb4859adfe977defac494fff6b73033b4ce1f86b8f2a9fc0c6bf98605afが生成されます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank the following persons for your detailed document reviews:",
      "ja": "詳細なドキュメントレビューを提供してくださった以下の方々に感謝いたします。"
    },
    {
      "indent": 3,
      "text": "o Paul Wouters and Nikos Mavrogiannopoulos (December 2011)",
      "ja": "o ポールウォーターズとニコスマブロジアンノプロス（2011年12月）"
    },
    {
      "indent": 3,
      "text": "o Rob Stradling (February 2012)",
      "ja": "o ロブ・ストラドリング（2012年2月）"
    },
    {
      "indent": 3,
      "text": "o Ondrej Mikle (March 2012)",
      "ja": "o オンドレイ・ミクル（2012年3月）"
    },
    {
      "indent": 3,
      "text": "o Ilari Liusvaara, Adam Langley, and Eric Rescorla (July 2014)",
      "ja": "o Ilari Liusvaara、Adam Langley、Eric Rescorla（2014年7月）"
    },
    {
      "indent": 3,
      "text": "o Sean Turner (August 2014)",
      "ja": "o ショーンターナー（2014年8月）"
    },
    {
      "indent": 3,
      "text": "o Martin Thomson (August 2015)",
      "ja": "o マーティン・トムソン（2015年8月）"
    },
    {
      "indent": 3,
      "text": "o Jouni Korhonen (November 2015)",
      "ja": "o Jouni Korhonen（2015年11月）"
    },
    {
      "indent": 3,
      "text": "o Dave Garrett (December 2015)",
      "ja": "o デイブ・ギャレット（2015年12月）"
    },
    {
      "indent": 3,
      "text": "o Matt Miller (December 2015)",
      "ja": "o マット・ミラー（2015年12月）"
    },
    {
      "indent": 3,
      "text": "o Anirudh Ramachandran (March 2016)",
      "ja": "o アニルッダラマチャンドラン（2017年3月）"
    },
    {
      "indent": 3,
      "text": "We would also to thank Martin Thomson, Karthikeyan Bhargavan, Sankalp Bagaria, and Eric Rescorla for their feedback regarding the fingerprint calculation.",
      "ja": "フィンガープリント計算に関するフィードバックを提供してくれたMartin Thomson、Karthikeyan Bhargavan、Sankalp Bagaria、およびEric Rescorlaにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Finally, we would like to thank the TLS working group chairs, Sean Turner and Joe Salowey, as well as the responsible Security Area Director, Stephen Farrell, for their support and their reviews.",
      "ja": "最後に、TLSワーキンググループの議長であるSean TurnerとJoe Salowey、および担当のセキュリティエリアディレクターであるStephen Farrellのサポートとレビューに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stefan Santesson 3xA Security AB Forskningsbyn Ideon Lund 223 70 Sweden",
      "ja": "Stefan Santesson 3xA Security AB Forskningsbyn Ideon Lund 223 70スウェーデン"
    },
    {
      "indent": 3,
      "text": "Email: sts@aaa-sec.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig ARM Ltd. Hall in Tirol 6060 Austria",
      "ja": "Hannes Tschofenig ARM Ltd. Hall in Tirol 6060オーストリア"
    },
    {
      "indent": 3,
      "text": "Email: Hannes.tschofenig@gmx.net\nURI:   http://www.tschofenig.priv.at",
      "raw": true,
      "ja": ""
    }
  ]
}