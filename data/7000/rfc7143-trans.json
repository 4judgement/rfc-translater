{
  "title": {
    "text": "RFC 7143",
    "zh-cn": "RFC 7143"
  },
  "number": 7143,
  "created_at": "2021-08-19 20:34:19.987356+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    M. Chadalapaka\nRequest for Comments: 7143                                     Microsoft\nObsoletes: 3720, 3980, 4850, 5048                              J. Satran\nUpdates: 3721                                             Infinidat Ltd.\nCategory: Standards Track                                        K. Meth\nISSN: 2070-1721                                                      IBM\n                                                                D. Black\n                                                                     EMC\n                                                              April 2014",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 7,
      "text": "Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)",
      "zh-cn": "Internet 小型计算机系统接口 (iSCSI) 协议（合并）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-cn": "摘要"
    },
    {
      "indent": 3,
      "text": "This document describes a transport protocol for SCSI that works on top of TCP. The iSCSI protocol aims to be fully compliant with the standardized SCSI Architecture Model (SAM-2). RFC 3720 defined the original iSCSI protocol. RFC 3721 discusses iSCSI naming examples and discovery techniques. Subsequently, RFC 3980 added an additional naming format to the iSCSI protocol. RFC 4850 followed up by adding a new public extension key to iSCSI. RFC 5048 offered a number of clarifications as well as a few improvements and corrections to the original iSCSI protocol.",
      "zh-cn": "本文档描述了在 TCP 上工作的 SCSI 传输协议。 iSCSI 协议旨在完全符合标准化的 SCSI 架构模型 (SAM-2)。 RFC 3720 定义了最初的 iSCSI 协议。 RFC 3721 讨论了 iSCSI 命名示例和发现技术。随后，RFC 3980 向 iSCSI 协议添加了额外的命名格式。 RFC 4850 紧随其后，向 iSCSI 添加了一个新的公共扩展密钥。 RFC 5048 对原始 iSCSI 协议进行了大量澄清以及一些改进和更正。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFCs 3720, 3980, 4850, and 5048 by consolidating them into a single document and making additional updates to the consolidated specification. This document also updates RFC 3721. The text in this document thus supersedes the text in all the noted RFCs wherever there is a difference in semantics.",
      "zh-cn": "本文档通过将 RFC 3720、3980、4850 和 5048 合并为一个文档并对合并的规范进行额外更新来废弃 RFC 3720、3980、4850 和 5048。本文档还更新了 RFC 3721。因此，本文档中的文本将取代所有提到的 RFC 中存在语义差异的文本。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-cn": "本备忘录的状态"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "zh-cn": "这是一个 Internet 标准跟踪文档。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "zh-cn": "本文档是 Internet 工程任务组 (IETF) 的产品。它代表了 IETF 社区的共识。它已接受公众审查，并已被互联网工程指导组 (IESG) 批准出版。有关 Internet 标准的更多信息，请参阅 RFC 5741 的第 2 节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7143.",
      "zh-cn": "有关本文档的当前状态、任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc7143。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-cn": "著作权"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-cn": "版权所有 (c) 2014 IETF Trust 和确定为文档作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-cn": "本文档受 BCP 78 和 IETF Trust 的与 IETF 文档相关的法律规定 (http://trustee.ietf.org/license-info) 的约束，在本文档发布之日生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文档中提取的代码组件必须包含 Trust Legal Provisions 第 4.e 节中所述的简化 BSD 许可文本，并且不提供如简化 BSD 许可中所述的保证。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-cn": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ...................................................11\n2. Acronyms, Definitions, and Document Summary ....................11\n   2.1. Acronyms ..................................................11\n   2.2. Definitions ...............................................13\n   2.3. Summary of Changes ........................................19\n   2.4. Conventions ...............................................20\n3. UML Conventions ................................................20\n   3.1. UML Conventions Overview ..................................20\n   3.2. Multiplicity Notion .......................................21\n   3.3. Class Diagram Conventions .................................22\n   3.4. Class Diagram Notation for Associations ...................23\n   3.5. Class Diagram Notation for Aggregations ...................24\n   3.6. Class Diagram Notation for Generalizations ................25\n4. Overview .......................................................25\n   4.1. SCSI Concepts .............................................25\n   4.2. iSCSI Concepts and Functional Overview ....................26\n        4.2.1. Layers and Sessions ................................27\n        4.2.2. Ordering and iSCSI Numbering .......................28\n               4.2.2.1. Command Numbering and Acknowledging .......28\n               4.2.2.2. Response/Status Numbering and\n                        Acknowledging .............................32\n               4.2.2.3. Response Ordering .........................32\n                        4.2.2.3.1. Need for Response Ordering .....32\n                        4.2.2.3.2. Response Ordering Model\n                                   Description ....................33\n                        4.2.2.3.3. iSCSI Semantics with\n                                   the Interface Model ............33\n                        4.2.2.3.4. Current List of Fenced\n                                   Response Use Cases .............34\n               4.2.2.4. Data Sequencing ...........................35",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "     4.2.3. iSCSI Task Management ..............................36\n            4.2.3.1. Task Management Overview ..................36\n            4.2.3.2. Notion of Affected Tasks ..................36\n            4.2.3.3. Standard Multi-Task Abort Semantics .......37\n            4.2.3.4. FastAbort Multi-Task Abort Semantics ......38\n            4.2.3.5. Affected Tasks Shared across\n                     Standard and FastAbort Sessions ...........40\n            4.2.3.6. Rationale behind the FastAbort Semantics ..41\n     4.2.4. iSCSI Login ........................................42\n     4.2.5. iSCSI Full Feature Phase ...........................44\n            4.2.5.1. Command Connection Allegiance .............44\n            4.2.5.2. Data Transfer Overview ....................45\n            4.2.5.3. Tags and Integrity Checks .................46\n            4.2.5.4. SCSI Task Management during iSCSI\n                     Full Feature Phase ........................47\n     4.2.6. iSCSI Connection Termination .......................47\n     4.2.7. iSCSI Names ........................................47\n            4.2.7.1. iSCSI Name Properties .....................48\n            4.2.7.2. iSCSI Name Encoding .......................50\n            4.2.7.3. iSCSI Name Structure ......................51\n            4.2.7.4. Type \"iqn.\" (iSCSI Qualified Name) ........52\n            4.2.7.5. Type \"eui.\" (IEEE EUI-64 Format) ..........53\n            4.2.7.6. Type \"naa.\" (Network Address Authority) ...54\n     4.2.8. Persistent State ...................................55\n     4.2.9. Message Synchronization and Steering ...............55\n            4.2.9.1. Sync/Steering and iSCSI PDU Length ........56\n4.3. iSCSI Session Types .......................................56\n4.4. SCSI-to-iSCSI Concepts Mapping Model ......................57\n     4.4.1. iSCSI Architecture Model ...........................58\n     4.4.2. SCSI Architecture Model ............................59\n     4.4.3. Consequences of the Model ..........................61\n            4.4.3.1. I_T Nexus State ...........................62\n            4.4.3.2. Reservations ..............................63\n4.5. iSCSI UML Model ...........................................64\n4.6. Request/Response Summary ..................................66\n     4.6.1. Request/Response Types Carrying SCSI Payload .......66\n            4.6.1.1. SCSI Command ..............................66\n            4.6.1.2. SCSI Response .............................66\n            4.6.1.3. Task Management Function Request ..........67\n            4.6.1.4. Task Management Function Response .........68\n            4.6.1.5. SCSI Data-Out and SCSI Data-In ............68\n            4.6.1.6. Ready To Transfer (R2T) ...................69\n     4.6.2. Requests/Responses Carrying SCSI and iSCSI\n            Payload ............................................69\n            4.6.2.1. Asynchronous Message ......................69",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "        4.6.3. Requests/Responses Carrying iSCSI-Only Payload .....69\n               4.6.3.1. Text Requests and Text Responses ..........69\n               4.6.3.2. Login Requests and Login Responses ........70\n               4.6.3.3. Logout Requests and Logout Responses ......71\n               4.6.3.4. SNACK Request .............................71\n               4.6.3.5. Reject ....................................71\n               4.6.3.6. NOP-Out Request and NOP-In Response .......71\n5. SCSI Mode Parameters for iSCSI .................................72\n6. Login and Full Feature Phase Negotiation .......................72\n   6.1. Text Format ...............................................73\n   6.2. Text Mode Negotiation .....................................76\n        6.2.1. List Negotiations ..................................80\n        6.2.2. Simple-Value Negotiations ..........................80\n   6.3. Login Phase ...............................................81\n        6.3.1. Login Phase Start ..................................84\n        6.3.2. iSCSI Security Negotiation .........................87\n        6.3.3. Operational Parameter Negotiation during\n               the Login Phase ....................................87\n        6.3.4. Connection Reinstatement ...........................88\n        6.3.5. Session Reinstatement, Closure, and Timeout ........89\n               6.3.5.1. Loss of Nexus Notification ................90\n        6.3.6. Session Continuation and Failure ...................90\n   6.4. Operational Parameter Negotiation outside the\n        Login Phase ...............................................90\n7. iSCSI Error Handling and Recovery ..............................92\n   7.1. Overview ..................................................92\n        7.1.1. Background .........................................92\n        7.1.2. Goals ..............................................92\n        7.1.3. Protocol Features and State Expectations ...........93\n        7.1.4. Recovery Classes ...................................94\n               7.1.4.1. Recovery Within-command ...................95\n               7.1.4.2. Recovery Within-connection ................96\n               7.1.4.3. Connection Recovery .......................96\n               7.1.4.4. Session Recovery ..........................97\n        7.1.5. Error Recovery Hierarchy ...........................97\n   7.2. Retry and Reassign in Recovery ............................99\n        7.2.1. Usage of Retry .....................................99\n        7.2.2. Allegiance Reassignment ...........................100\n   7.3. Usage of Reject PDU in Recovery ..........................101\n   7.4. Error Recovery Considerations for Discovery Sessions .....102\n        7.4.1. ErrorRecoveryLevel for Discovery Sessions .........102\n        7.4.2. Reinstatement Semantics for Discovery Sessions ....102\n               7.4.2.1. Unnamed Discovery Sessions ...............103\n               7.4.2.2. Named Discovery Sessions .................103\n        7.4.3. Target PDUs during Discovery ......................103",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "   7.5. Connection Timeout Management ............................104\n        7.5.1. Timeouts on Transport Exception Events ............104\n        7.5.2. Timeouts on Planned Decommissioning ...............104\n   7.6. Implicit Termination of Tasks ............................104\n   7.7. Format Errors ............................................105\n   7.8. Digest Errors ............................................106\n   7.9. Sequence Errors ..........................................107\n   7.10. Message Error Checking ..................................108\n   7.11. SCSI Timeouts ...........................................108\n   7.12. Negotiation Failures ....................................109\n   7.13. Protocol Errors .........................................110\n   7.14. Connection Failures .....................................110\n   7.15. Session Errors ..........................................111\n8. State Transitions .............................................112\n   8.1. Standard Connection State Diagrams .......................112\n        8.1.1. State Descriptions for Initiators and Targets .....112\n        8.1.2. State Transition Descriptions for\n               Initiators and Targets ............................114\n        8.1.3. Standard Connection State Diagram for an\n               Initiator .........................................118\n        8.1.4. Standard Connection State Diagram for a Target ....120\n   8.2. Connection Cleanup State Diagram for Initiators\n        and Targets ..............................................122\n        8.2.1. State Descriptions for Initiators and Targets .....124\n        8.2.2. State Transition Descriptions for\n               Initiators and Targets ............................124\n   8.3. Session State Diagrams ...................................126\n        8.3.1. Session State Diagram for an Initiator ............126\n        8.3.2. Session State Diagram for a Target ................127\n        8.3.3. State Descriptions for Initiators and Targets .....129\n        8.3.4. State Transition Descriptions for\n               Initiators and Targets ............................129\n9. Security Considerations .......................................131\n   9.1. iSCSI Security Mechanisms ................................132\n   9.2. In-Band Initiator-Target Authentication ..................132\n        9.2.1. CHAP Considerations ...............................134\n        9.2.2. SRP Considerations ................................136\n        9.2.3. Kerberos Considerations ...........................136\n   9.3. IPsec ....................................................137\n        9.3.1. Data Authentication and Integrity .................137\n        9.3.2. Confidentiality ...................................138\n        9.3.3. Policy, Security Associations, and\n               Cryptographic Key Management ......................139\n   9.4. Security Considerations for the X#NodeArchitecture Key ...141\n   9.5. SCSI Access Control Considerations .......................143",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "10. Notes to Implementers ........................................143\n   10.1. Multiple Network Adapters ...............................143\n        10.1.1. Conservative Reuse of ISIDs ......................143\n        10.1.2. iSCSI Name, ISID, and TPGT Use ...................144\n   10.2. Autosense and Auto Contingent Allegiance (ACA) ..........146\n   10.3. iSCSI Timeouts ..........................................146\n   10.4. Command Retry and Cleaning Old Command Instances ........147\n   10.5. Sync and Steering Layer, and Performance ................147\n   10.6. Considerations for State-Dependent Devices and\n         Long-Lasting SCSI Operations ............................147\n        10.6.1. Determining the Proper ErrorRecoveryLevel ........148\n   10.7. Multi-Task Abort Implementation Considerations ..........149\n11. iSCSI PDU Formats ............................................150\n   11.1. iSCSI PDU Length and Padding ............................150\n   11.2. PDU Template, Header, and Opcodes .......................150\n        11.2.1. Basic Header Segment (BHS) .......................152\n               11.2.1.1. I (Immediate) Bit .......................152\n               11.2.1.2. Opcode ..................................152\n               11.2.1.3. F (Final) Bit ...........................154\n               11.2.1.4. Opcode-Specific Fields ..................154\n               11.2.1.5. TotalAHSLength ..........................154\n               11.2.1.6. DataSegmentLength .......................154\n               11.2.1.7. LUN .....................................154\n               11.2.1.8. Initiator Task Tag ......................154\n        11.2.2. Additional Header Segment (AHS) ..................155\n               11.2.2.1. AHSType .................................155\n               11.2.2.2. AHSLength ...............................155\n               11.2.2.3. Extended CDB AHS ........................156\n               11.2.2.4. Bidirectional Read Expected Data\n                         Transfer Length AHS .....................156\n        11.2.3. Header Digest and Data Digest ....................156\n        11.2.4. Data Segment .....................................157\n   11.3. SCSI Command ............................................158\n        11.3.1. Flags and Task Attributes (Byte 1) ...............159\n        11.3.2. CmdSN - Command Sequence Number ..................159\n        11.3.3. ExpStatSN ........................................160\n        11.3.4. Expected Data Transfer Length ....................160\n        11.3.5. CDB - SCSI Command Descriptor Block ..............160\n        11.3.6. Data Segment - Command Data ......................161\n   11.4. SCSI Response ...........................................161\n        11.4.1. Flags (Byte 1) ...................................162\n        11.4.2. Status ...........................................163\n        11.4.3. Response .........................................163\n        11.4.4. SNACK Tag ........................................164",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "     11.4.5. Residual Count ...................................164\n            11.4.5.1. Field Semantics .........................164\n            11.4.5.2. Residuals Concepts Overview .............164\n            11.4.5.3. SCSI REPORT LUNS Command and\n                      Residual Overflow .......................165\n     11.4.6. Bidirectional Read Residual Count ................166\n     11.4.7. Data Segment - Sense and Response Data Segment ...167\n            11.4.7.1. SenseLength .............................167\n            11.4.7.2. Sense Data ..............................168\n     11.4.8. ExpDataSN ........................................168\n     11.4.9. StatSN - Status Sequence Number ..................168\n     11.4.10. ExpCmdSN - Next Expected CmdSN from This\n              Initiator .......................................169\n     11.4.11. MaxCmdSN - Maximum CmdSN from This Initiator ....169\n11.5. Task Management Function Request ........................170\n     11.5.1. Function .........................................170\n     11.5.2. TotalAHSLength and DataSegmentLength .............173\n     11.5.3. LUN ..............................................173\n     11.5.4. Referenced Task Tag ..............................173\n     11.5.5. RefCmdSN .........................................174\n     11.5.6. ExpDataSN ........................................174\n11.6. Task Management Function Response .......................175\n     11.6.1. Response .........................................176\n     11.6.2. TotalAHSLength and DataSegmentLength .............177\n11.7. SCSI Data-Out and SCSI Data-In ..........................178\n     11.7.1. F (Final) Bit ....................................180\n     11.7.2. A (Acknowledge) Bit ..............................180\n     11.7.3. Flags (Byte 1) ...................................181\n     11.7.4. Target Transfer Tag and LUN ......................181\n     11.7.5. DataSN ...........................................182\n     11.7.6. Buffer Offset ....................................182\n     11.7.7. DataSegmentLength ................................182\n11.8. Ready To Transfer (R2T) .................................183\n     11.8.1. TotalAHSLength and DataSegmentLength .............184\n     11.8.2. R2TSN ............................................184\n     11.8.3. StatSN ...........................................185\n     11.8.4. Desired Data Transfer Length and Buffer Offset ...185\n     11.8.5. Target Transfer Tag ..............................185\n11.9. Asynchronous Message ....................................186\n     11.9.1. AsyncEvent .......................................187\n     11.9.2. AsyncVCode .......................................189\n     11.9.3. LUN ..............................................189\n     11.9.4. Sense Data and iSCSI Event Data ..................190\n            11.9.4.1. SenseLength .............................190",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "11.10. Text Request ...........................................191\n     11.10.1. F (Final) Bit ...................................192\n     11.10.2. C (Continue) Bit ................................192\n     11.10.3. Initiator Task Tag ..............................192\n     11.10.4. Target Transfer Tag .............................192\n     11.10.5. Text ............................................193\n11.11. Text Response ..........................................194\n     11.11.1. F (Final) Bit ...................................194\n     11.11.2. C (Continue) Bit ................................195\n     11.11.3. Initiator Task Tag ..............................195\n     11.11.4. Target Transfer Tag .............................195\n     11.11.5. StatSN ..........................................196\n     11.11.6. Text Response Data ..............................196\n11.12. Login Request ..........................................196\n     11.12.1. T (Transit) Bit .................................197\n     11.12.2. C (Continue) Bit ................................197\n     11.12.3. CSG and NSG .....................................198\n     11.12.4. Version .........................................198\n            11.12.4.1. Version-max ............................198\n            11.12.4.2. Version-min ............................198\n     11.12.5. ISID ............................................199\n     11.12.6. TSIH ............................................200\n     11.12.7. Connection ID (CID) .............................200\n     11.12.8. CmdSN ...........................................201\n     11.12.9. ExpStatSN .......................................201\n     11.12.10. Login Parameters ...............................201\n11.13. Login Response .........................................202\n     11.13.1. Version-max .....................................202\n     11.13.2. Version-active ..................................203\n     11.13.3. TSIH ............................................203\n     11.13.4. StatSN ..........................................203\n     11.13.5. Status-Class and Status-Detail ..................203\n     11.13.6. T (Transit) Bit .................................206\n     11.13.7. C (Continue) Bit ................................206\n     11.13.8. Login Parameters ................................207\n11.14. Logout Request .........................................207\n     11.14.1. Reason Code .....................................209\n     11.14.2. TotalAHSLength and DataSegmentLength ............209\n     11.14.3. CID .............................................210\n     11.14.4. ExpStatSN .......................................210\n     11.14.5. Implicit Termination of Tasks ...................210\n11.15. Logout Response ........................................211\n     11.15.1. Response ........................................212\n     11.15.2. TotalAHSLength and DataSegmentLength ............212\n     11.15.3. Time2Wait .......................................212\n     11.15.4. Time2Retain .....................................212",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "   11.16. SNACK Request ..........................................213\n        11.16.1. Type ............................................214\n        11.16.2. Data Acknowledgment .............................215\n        11.16.3. Resegmentation ..................................215\n        11.16.4. Initiator Task Tag ..............................216\n        11.16.5. Target Transfer Tag or SNACK Tag ................216\n        11.16.6. BegRun ..........................................216\n        11.16.7. RunLength .......................................216\n   11.17. Reject .................................................217\n        11.17.1. Reason ..........................................218\n        11.17.2. DataSN/R2TSN ....................................219\n        11.17.3. StatSN, ExpCmdSN, and MaxCmdSN ..................219\n        11.17.4. Complete Header of Bad PDU ......................219\n   11.18. NOP-Out ................................................220\n        11.18.1. Initiator Task Tag ..............................221\n        11.18.2. Target Transfer Tag .............................221\n        11.18.3. Ping Data .......................................221\n   11.19. NOP-In .................................................222\n        11.19.1. Target Transfer Tag .............................223\n        11.19.2. StatSN ..........................................223\n        11.19.3. LUN .............................................223\n12. iSCSI Security Text Keys and Authentication Methods ..........223\n   12.1. AuthMethod ..............................................224\n        12.1.1. Kerberos .........................................226\n        12.1.2. Secure Remote Password (SRP) .....................226\n        12.1.3. Challenge Handshake Authentication\n                Protocol (CHAP) ..................................228\n13. Login/Text Operational Text Keys .............................229\n   13.1. HeaderDigest and DataDigest .............................230\n   13.2. MaxConnections ..........................................232\n   13.3. SendTargets .............................................232\n   13.4. TargetName ..............................................232\n   13.5. InitiatorName ...........................................233\n   13.6. TargetAlias .............................................233\n   13.7. InitiatorAlias ..........................................234\n   13.8. TargetAddress ...........................................234\n   13.9. TargetPortalGroupTag ....................................235\n   13.10. InitialR2T .............................................236\n   13.11. ImmediateData ..........................................236\n   13.12. MaxRecvDataSegmentLength ...............................237\n   13.13. MaxBurstLength .........................................238\n   13.14. FirstBurstLength .......................................238\n   13.15. DefaultTime2Wait .......................................239\n   13.16. DefaultTime2Retain .....................................239\n   13.17. MaxOutstandingR2T ......................................239\n   13.18. DataPDUInOrder .........................................240\n   13.19. DataSequenceInOrder ....................................240\n   13.20. ErrorRecoveryLevel .....................................241",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "   13.21. SessionType ............................................241\n   13.22. The Private Extension Key Format .......................242\n   13.23. TaskReporting ..........................................242\n   13.24. iSCSIProtocolLevel Negotiation .........................243\n   13.25. Obsoleted Keys .........................................243\n   13.26. X#NodeArchitecture .....................................244\n        13.26.1. Definition ......................................244\n        13.26.2. Implementation Requirements .....................244\n14. Rationale for Revised IANA Considerations ....................245\n15. IANA Considerations ..........................................246\n16. References ...................................................248\n   16.1. Normative References ....................................248\n   16.2. Informative References ..................................251\nAppendix A. Examples .............................................254\n  A.1. Read Operation Example ....................................254\n  A.2. Write Operation Example ...................................255\n  A.3. R2TSN/DataSN Use Examples .................................256\n       A.3.1. Output (Write) Data DataSN/R2TSN Example ...........256\n       A.3.2. Input (Read) Data DataSN Example ...................257\n       A.3.3. Bidirectional DataSN Example .......................258\n       A.3.4. Unsolicited and Immediate Output (Write) Data\n              with DataSN Example ................................259\n  A.4. CRC Examples ..............................................259\nAppendix B. Login Phase Examples .................................261\nAppendix C. SendTargets Operation ................................268\nAppendix D. Algorithmic Presentation of Error Recovery\n            Classes ..............................................272\n  D.1. General Data Structure and Procedure Description ..........273\n  D.2. Within-command Error Recovery Algorithms ..................274\n       D.2.1. Procedure Descriptions .............................274\n       D.2.2. Initiator Algorithms ...............................275\n       D.2.3. Target Algorithms ..................................277\n  D.3. Within-connection Recovery Algorithms .....................279\n       D.3.1. Procedure Descriptions .............................279\n       D.3.2. Initiator Algorithms ...............................280\n       D.3.3. Target Algorithms ..................................283\n  D.4. Connection Recovery Algorithms ............................283\n       D.4.1. Procedure Descriptions .............................283\n       D.4.2. Initiator Algorithms ...............................284\n       D.4.3. Target Algorithms ..................................286\nAppendix E. Clearing Effects of Various Events on Targets ........288\n  E.1. Clearing Effects on iSCSI Objects .........................288\n  E.2. Clearing Effects on SCSI Objects ..........................293\nAcknowledgments ..................................................294",
      "raw": true,
      "toc": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-cn": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The Small Computer System Interface (SCSI) is a popular family of protocols for communicating with I/O devices, especially storage devices. SCSI is a client-server architecture. Clients of a SCSI interface are called \"initiators\". Initiators issue SCSI \"commands\" to request services from components -- logical units of a server known as a \"target\". A \"SCSI transport\" maps the client-server SCSI protocol to a specific interconnect. An initiator is one endpoint of a SCSI transport, and a target is the other endpoint.",
      "zh-cn": "小型计算机系统接口 (SCSI) 是用于与 I/O 设备（尤其是存储设备）进行通信的流行协议系列。 SCSI 是一种客户端-服务器架构。 SCSI 接口的客户端称为“启动器”。启动器发出 SCSI“命令”以从组件（称为“目标”的服务器的逻辑单元）请求服务。 “SCSI 传输”将客户端-服务器 SCSI 协议映射到特定的互连。启动器是 SCSI 传输的一个端点，目标是另一个端点。"
    },
    {
      "indent": 3,
      "text": "The SCSI protocol has been mapped over various transports, including Parallel SCSI, Intelligent Peripheral Interface (IPI), IEEE 1394 (FireWire), and Fibre Channel. These transports are I/O-specific and have limited distance capabilities.",
      "zh-cn": "SCSI 协议已映射到各种传输，包括并行 SCSI、智能外设接口 (IPI)、IEEE 1394 (FireWire) 和光纤通道。这些传输是特定于 I/O 的并且具有有限的距离能力。"
    },
    {
      "indent": 3,
      "text": "The iSCSI protocol defined in this document describes a means of transporting SCSI packets over TCP/IP, providing for an interoperable solution that can take advantage of existing Internet infrastructure, Internet management facilities, and address distance limitations.",
      "zh-cn": "本文档中定义的 iSCSI 协议描述了一种通过 TCP/IP 传输 SCSI 数据包的方法，提供了一种可互操作的解决方案，可以利用现有的 Internet 基础设施、Internet 管理设施和地址距离限制。"
    },
    {
      "indent": 0,
      "text": "2. Acronyms, Definitions, and Document Summary",
      "section_title": true,
      "zh-cn": "2. 首字母缩略词、定义和文档摘要"
    },
    {
      "indent": 0,
      "text": "2.1. Acronyms",
      "section_title": true,
      "zh-cn": "2.1. 缩略语"
    },
    {
      "indent": 3,
      "text": "Acronym     Definition\n--------------------------------------------------------------\n3DES        Triple Data Encryption Standard\nACA         Auto Contingent Allegiance\nAEN         Asynchronous Event Notification\nAES         Advanced Encryption Standard\nAH          Additional Header (not the IPsec AH!)\nAHS         Additional Header Segment\nAPI         Application Programming Interface\nASC         Additional Sense Code\nASCII       American Standard Code for Information Interchange\nASCQ        Additional Sense Code Qualifier\nATA         AT Attachment\nBHS         Basic Header Segment\nCBC         Cipher Block Chaining\nCD          Compact Disk\nCDB         Command Descriptor Block\nCHAP        Challenge Handshake Authentication Protocol\nCID         Connection ID\nCO          Connection Only\nCRC         Cyclic Redundancy Check\nCRL         Certificate Revocation List\nCSG         Current Stage",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "CSM Connection State Machine DES Data Encryption Standard DNS Domain Name Server DOI Domain of Interpretation DVD Digital Versatile Disk EDTL Expected Data Transfer Length ESP Encapsulating Security Payload EUI Extended Unique Identifier FFP Full Feature Phase FFPO Full Feature Phase Only HBA Host Bus Adapter HMAC Hashed Message Authentication Code I_T Initiator_Target I_T_L Initiator_Target_LUN IANA Internet Assigned Numbers Authority IB InfiniBand ID Identifier IDN Internationalized Domain Name IEEE Institute of Electrical and Electronics Engineers IETF Internet Engineering Task Force IKE Internet Key Exchange I/O Input-Output IO Initialize Only IP Internet Protocol IPsec Internet Protocol Security IPv4 Internet Protocol Version 4 IPv6 Internet Protocol Version 6 IQN iSCSI Qualified Name iSCSI Internet SCSI iSER iSCSI Extensions for RDMA (see [RFC7145]) ISID Initiator Session ID iSNS Internet Storage Name Service (see [RFC4171]) ITN iSCSI Target Name ITT Initiator Task Tag KRB5 Kerberos V5 LFL Lower Functional Layer LTDS Logical-Text-Data-Segment LO Leading Only LU Logical Unit LUN Logical Unit Number MAC Message Authentication Code NA Not Applicable NAA Network Address Authority NIC Network Interface Card NOP No Operation NSG Next Stage OCSP Online Certificate Status Protocol OS Operating System",
      "zh-cn": "CSM 连接状态机 DES 数据加密标准 DNS 域名服务器 DOI 解释域 DVD 数字通用磁盘 EDTL 预期数据传输长度 ESP 封装安全有效载荷 EUI 扩展唯一标识符 FFP 全功能阶段 FFPO 全功能阶段 仅 HBA 主机总线适配器 HMAC 散列消息认证代码 I_T Initiator_Target I_T_L Initiator_Target_LUN IANA Internet Assigned Numbers Authority IB InfiniBand ID Identifier IDN 国际化域名 IEEE Institute of Electrical and Electronics Engineers IETF Internet Engineering Task Force IKE Internet Key Exchange I/O Input-Output IO Initialize Only IP Internet Protocol IPsec Internet Protocol Security IPv4 Internet 协议第 4 版 IPv6 Internet 协议第 6 版 IQN iSCSI 限定名称 iSCSI Internet SCSI iSER iSCSI 扩展 RDMA（请参阅 [RFC7145]） ISID 发起程序会话 ID iSNS Internet 存储名称服务（请参阅 [RFC4171]） ITN iSCSI 目标名称 ITT 发起程序任务标记 KRB5 ros V5 LFL 低功能层 LTDS Logical-Text-Data-Segment LO 仅前导 LU 逻辑单元 LUN 逻辑单元号 MAC 消息认证代码 NA 不适用 NAA 网络地址授权 NIC 网络接口卡 NOP 无操作 NSG Next Stage OCSP 在线证书状态协议操作系统"
    },
    {
      "indent": 3,
      "text": "PDU Protocol Data Unit PKI Public Key Infrastructure R2T Ready To Transfer R2TSN Ready To Transfer Sequence Number RDMA Remote Direct Memory Access RFC Request For Comments SA Security Association SAM SCSI Architecture Model SAM-2 SCSI Architecture Model - 2 SAN Storage Area Network SAS Serial Attached SCSI SATA Serial AT Attachment SCSI Small Computer System Interface SLP Service Location Protocol SN Sequence Number SNACK Selective Negative Acknowledgment - also Sequence Number Acknowledgement for data SPDTL SCSI-Presented Data Transfer Length SPKM Simple Public-Key Mechanism SRP Secure Remote Password SSID Session ID SW Session-Wide TCB Task Control Block TCP Transmission Control Protocol TMF Task Management Function TPGT Target Portal Group Tag TSIH Target Session Identifying Handle TTT Target Transfer Tag UA Unit Attention UFL Upper Functional Layer ULP Upper Level Protocol URN Uniform Resource Name UTF Universal Transformation Format WG Working Group",
      "zh-cn": "PDU 协议数据单元 PKI 公钥基础设施 R2T 准备传输 R2TSN 准备传输序列号 RDMA 远程直接内存访问 RFC 征求意见 SA 安全协会 SAM SCSI 架构模型 SAM-2 SCSI 架构模型 - 2 SAN 存储区域网络 SAS 串行连接 SCSI SATA 串行 AT 附件 SCSI 小型计算机系统接口 SLP 服务位置协议 SN 序列号 SNACK 选择性否定确认 - 也是数据的序列号确认 SPDTL SCSI 呈现的数据传输长度 SPKM 简单公钥机制 SRP 安全远程密码 SSID 会话 ID SW 会话-宽 TCB 任务控制块 TCP 传输控制协议 TMF 任务管理功能 TPGT 目标门户组标记 TSIH 目标会话识别句柄 TTT 目标传输标记 UA 单元注意 UFL 上层功能层 ULP 上层协议 URN 统一资源名称 UTF 通用转换格式 WG 工作组"
    },
    {
      "indent": 0,
      "text": "2.2. Definitions",
      "section_title": true,
      "zh-cn": "2.2. 定义"
    },
    {
      "indent": 3,
      "text": "- Alias: An alias string can also be associated with an iSCSI node. The alias allows an organization to associate a user-friendly string with the iSCSI name. However, the alias string is not a substitute for the iSCSI name.",
      "zh-cn": "- 别名：别名字符串也可以与 iSCSI 节点相关联。别名允许组织将用户友好的字符串与 iSCSI 名称相关联。但是，别名字符串不能替代 iSCSI 名称。"
    },
    {
      "indent": 3,
      "text": "- CID (connection ID): Connections within a session are identified by a connection ID. It is a unique ID for this connection within the session for the initiator. It is generated by the initiator and presented to the target during Login Requests and during logouts that close connections.",
      "zh-cn": "- CID（连接 ID）：会话中的连接由连接 ID 标识。它是发起方会话中此连接的唯一 ID。它由发起者生成并在登录请求期间和关闭连接的注销期间呈现给目标。"
    },
    {
      "indent": 3,
      "text": "- Connection: A connection is a TCP connection. Communication between the initiator and target occurs over one or more TCP connections. The TCP connections carry control messages, SCSI commands, parameters, and data within iSCSI Protocol Data Units (iSCSI PDUs).",
      "zh-cn": "- 连接：连接是 TCP 连接。发起者和目标之间的通信发生在一个或多个 TCP 连接上。 TCP 连接在 iSCSI 协议数据单元 (iSCSI PDU) 内传送控制消息、SCSI 命令、参数和数据。"
    },
    {
      "indent": 3,
      "text": "- I/O Buffer: An I/O Buffer is a buffer that is used in a SCSI read or write operation so SCSI data may be sent from or received into that buffer. For a read or write data transfer to take place for a task, an I/O Buffer is required on the initiator and at least one is required on the target.",
      "zh-cn": "- I/O 缓冲区：I/O 缓冲区是在 SCSI 读取或写入操作中使用的缓冲区，因此可以从该缓冲区发送或接收 SCSI 数据。要为任务进行读或写数据传输，启动器上需要一个 I/O 缓冲区，目标上至少需要一个 I/O 缓冲区。"
    },
    {
      "indent": 3,
      "text": "- INCITS: \"INCITS\" stands for InterNational Committee for Information Technology Standards. The INCITS has a broad standardization scope within the field of Information and Communications Technologies (ICT), encompassing storage, processing, transfer, display, management, organization, and retrieval of information. INCITS serves as ANSI's Technical Advisory Group for the ISO/IEC Joint Technical Committee 1 (JTC 1). See <http://www.incits.org>.",
      "zh-cn": "- INCITS：“INCITS”代表国际信息技术标准委员会。 INCITS 在信息和通信技术 (ICT) 领域具有广泛的标准化范围，包括信息的存储、处理、传输、显示、管理、组织和检索。 INCITS 作为 ANSI 的 ISO/IEC 联合技术委员会 1 (JTC 1) 的技术咨询小组。见 <http://www.incits.org>。"
    },
    {
      "indent": 3,
      "text": "- InfiniBand: InfiniBand is an I/O architecture originally intended to replace Peripheral Component Interconnect (PCI) and address high-performance server interconnectivity [IB].",
      "zh-cn": "- InfiniBand：InfiniBand 是一种 I/O 架构，最初旨在取代外围组件互连 (PCI) 并解决高性能服务器互连 [IB]。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Device: An iSCSI device is a SCSI device using an iSCSI service delivery subsystem. The Service Delivery Subsystem is defined by [SAM2] as a transport mechanism for SCSI commands and responses.",
      "zh-cn": "- iSCSI 设备：iSCSI 设备是使用 iSCSI 服务交付子系统的 SCSI 设备。服务交付子系统由 [SAM2] 定义为 SCSI 命令和响应的传输机制。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Initiator Name: The iSCSI Initiator Name specifies the worldwide unique name of the initiator.",
      "zh-cn": "- iSCSI 启动器名称：iSCSI 启动器名称指定启动器的全球唯一名称。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Initiator Node: An iSCSI initiator node is the \"initiator\" device. The word \"initiator\" has been appropriately qualified as either a port or a device in the rest of the document when the context is ambiguous. All unqualified usages of \"initiator\" refer to an initiator port (or device), depending on the context.",
      "zh-cn": "- iSCSI 发起方节点：iSCSI 发起方节点是“发起方”设备。当上下文不明确时，“启动器”一词在文档的其余部分已被适当地限定为端口或设备。 “启动器”的所有非限定用法都是指启动器端口（或设备），具体取决于上下文。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Layer: This layer builds/receives iSCSI PDUs and relays/receives them to/from one or more TCP connections that form an initiator-target \"session\".",
      "zh-cn": "- iSCSI 层：这一层构建/接收 iSCSI PDU 并将它们中继/接收到一个或多个 TCP 连接，这些连接形成一个发起方-目标“会话”。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Name: This is the name of an iSCSI initiator or iSCSI target.",
      "zh-cn": "- iSCSI 名称：这是 iSCSI 启动器或 iSCSI 目标的名称。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Node: The iSCSI node represents a single iSCSI initiator or iSCSI target, or a single instance of each. There are one or more iSCSI nodes within a Network Entity. The iSCSI node is accessible via one or more Network Portals. An iSCSI node is identified by",
      "zh-cn": "- iSCSI 节点：iSCSI 节点代表单个 iSCSI 启动器或 iSCSI 目标，或每个的单个实例。一个网络实体中有一个或多个 iSCSI 节点。 iSCSI 节点可通过一个或多个网络门户访问。 iSCSI 节点由"
    },
    {
      "indent": 5,
      "text": "its iSCSI name. The separation of the iSCSI name from the addresses used by and for the iSCSI node allows multiple iSCSI nodes to use the same address and the same iSCSI node to use multiple addresses.",
      "zh-cn": "它的 iSCSI 名称。将 iSCSI 名称与 iSCSI 节点使用的地址分开，允许多个 iSCSI 节点使用相同的地址，并且同一 iSCSI 节点使用多个地址。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Target Name: The iSCSI Target Name specifies the worldwide unique name of the target.",
      "zh-cn": "- iSCSI 目标名称：iSCSI 目标名称指定目标的全球唯一名称。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Target Node: The iSCSI target node is the \"target\" device. The word \"target\" has been appropriately qualified as either a port or a device in the rest of the document when the context is ambiguous. All unqualified usages of \"target\" refer to a target port (or device), depending on the context.",
      "zh-cn": "- iSCSI 目标节点：iSCSI 目标节点是“目标”设备。当上下文不明确时，“目标”一词在文档的其余部分已被适当地限定为端口或设备。 “目标”的所有非限定用法都是指目标端口（或设备），具体取决于上下文。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Task: An iSCSI task is an iSCSI request for which a response is expected.",
      "zh-cn": "- iSCSI 任务：iSCSI 任务是需要响应的 iSCSI 请求。"
    },
    {
      "indent": 3,
      "text": "- iSCSI Transfer Direction: The iSCSI transfer direction is defined with regard to the initiator. Outbound or outgoing transfers are transfers from the initiator to the target, while inbound or incoming transfers are from the target to the initiator.",
      "zh-cn": "- iSCSI 传输方向：iSCSI 传输方向是针对启动器定义的。出站或出站传输是从发起者到目标的传输，而入站或入站传输是从目标到发起者的传输。"
    },
    {
      "indent": 3,
      "text": "- ISID: The ISID is the initiator part of the session identifier. It is explicitly specified by the initiator during login.",
      "zh-cn": "- ISID：ISID 是会话标识符的发起者部分。它在登录期间由发起者明确指定。"
    },
    {
      "indent": 3,
      "text": "- I_T Nexus: According to [SAM2], the I_T nexus is a relationship between a SCSI initiator port and a SCSI target port. For iSCSI, this relationship is a session, defined as a relationship between an iSCSI initiator's end of the session (SCSI initiator port) and the iSCSI target's portal group. The I_T nexus can be identified by the conjunction of the SCSI port names; that is, the I_T nexus identifier is the tuple (iSCSI Initiator Name + ',i,' + ISID, iSCSI Target Name + ',t,' + Target Portal Group Tag).",
      "zh-cn": "- I_T Nexus：根据 [SAM2]，I_T 关系是 SCSI 发起方端口和 SCSI 目标方端口之间的关系。对于 iSCSI，此关系是一个会话，定义为 iSCSI 发起方的会话结束（SCSI 发起方端口）与 iSCSI 目标的门户组之间的关系。 I_T 连接可以通过 SCSI 端口名称的连接来识别；即，I_T 关联标识符是元组（iSCSI 发起方名称 + ',i,' + ISID，iSCSI 目标名称 + ',t,' + 目标门户组标签）。"
    },
    {
      "indent": 3,
      "text": "- I_T_L Nexus: An I_T_L nexus is a SCSI concept and is defined as the relationship between a SCSI initiator port, a SCSI target port, and a Logical Unit (LU).",
      "zh-cn": "- I_T_L Nexus：I_T_L 连接是 SCSI 概念，定义为 SCSI 发起方端口、SCSI 目标方端口和逻辑单元 (LU) 之间的关系。"
    },
    {
      "indent": 3,
      "text": "- NAA: \"NAA\" refers to Network Address Authority, a naming format defined by the INCITS T11 Fibre Channel protocols [FC-FS3].",
      "zh-cn": "- NAA：“NAA”指的是网络地址授权，一种由 INCITS T11 光纤通道协议 [FC-FS3] 定义的命名格式。"
    },
    {
      "indent": 3,
      "text": "- Network Entity: The Network Entity represents a device or gateway that is accessible from the IP network. A Network Entity must have one or more Network Portals, each of which can be used to gain access to the IP network by some iSCSI nodes contained in that Network Entity.",
      "zh-cn": "- 网络实体：网络实体代表可从 IP 网络访问的设备或网关。一个网络实体必须有一个或多个网络门户，每个网络门户都可用于通过该网络实体中包含的某些 iSCSI 节点访问 IP 网络。"
    },
    {
      "indent": 3,
      "text": "- Network Portal: The Network Portal is a component of a Network Entity that has a TCP/IP network address and that may be used by an iSCSI node within that Network Entity for the connection(s) within one of its iSCSI sessions. A Network Portal in an initiator is identified by its IP address. A Network Portal in a target is identified by its IP address and its listening TCP port.",
      "zh-cn": "- 网络门户：网络门户是具有 TCP/IP 网络地址的网络实体的一个组件，并且可由该网络实体内的 iSCSI 节点用于其 iSCSI 会话之一内的连接。发起方中的网络门户由其 IP 地址标识。目标中的网络门户由其 IP 地址和侦听 TCP 端口标识。"
    },
    {
      "indent": 3,
      "text": "- Originator: In a negotiation or exchange, the originator is the party that initiates the negotiation or exchange.",
      "zh-cn": "- 发起方：在协商或交换中，发起方是发起协商或交换的一方。"
    },
    {
      "indent": 3,
      "text": "- PDU (Protocol Data Unit): The initiator and target divide their communications into messages. The term \"iSCSI Protocol Data Unit\" (iSCSI PDU) is used for these messages.",
      "zh-cn": "- PDU（协议数据单元）：发起方和目标方将他们的通信分成消息。术语“iSCSI 协议数据单元”(iSCSI PDU) 用于这些消息。"
    },
    {
      "indent": 3,
      "text": "- Portal Groups: iSCSI supports multiple connections within the same session; some implementations will have the ability to combine connections in a session across multiple Network Portals. A portal group defines a set of Network Portals within an iSCSI Network Entity that collectively supports the capability of coordinating a session with connections spanning these portals. Not all Network Portals within a portal group need participate in every session connected through that portal group. One or more portal groups may provide access to an iSCSI node. Each Network Portal, as utilized by a given iSCSI node, belongs to exactly one portal group within that node.",
      "zh-cn": "- Portal Groups: iSCSI supports multiple connections within the same session; some implementations will have the ability to combine connections in a session across multiple Network Portals. A portal group defines a set of Network Portals within an iSCSI Network Entity that collectively supports the capability of coordinating a session with connections spanning these portals. Not all Network Portals within a portal group need participate in every session connected through that portal group. One or more portal groups may provide access to an iSCSI node. Each Network Portal, as utilized by a given iSCSI node, belongs to exactly one portal group within that node."
    },
    {
      "indent": 3,
      "text": "- Portal Group Tag: This 16-bit quantity identifies a portal group within an iSCSI node. All Network Portals with the same Portal Group Tag in the context of a given iSCSI node are in the same portal group.",
      "zh-cn": "- Portal Group Tag: This 16-bit quantity identifies a portal group within an iSCSI node. All Network Portals with the same Portal Group Tag in the context of a given iSCSI node are in the same portal group."
    },
    {
      "indent": 3,
      "text": "- Recovery R2T: A recovery R2T is an R2T generated by a target upon detecting the loss of one or more Data-Out PDUs through one of the following means: a digest error, a sequence error, or a sequence reception timeout. A recovery R2T carries the next unused R2TSN but requests all or part of the data burst that an earlier R2T (with a lower R2TSN) had already requested.",
      "zh-cn": "- Recovery R2T: A recovery R2T is an R2T generated by a target upon detecting the loss of one or more Data-Out PDUs through one of the following means: a digest error, a sequence error, or a sequence reception timeout. A recovery R2T carries the next unused R2TSN but requests all or part of the data burst that an earlier R2T (with a lower R2TSN) had already requested."
    },
    {
      "indent": 3,
      "text": "- Responder: In a negotiation or exchange, the responder is the party that responds to the originator of the negotiation or exchange.",
      "zh-cn": "- Responder: In a negotiation or exchange, the responder is the party that responds to the originator of the negotiation or exchange."
    },
    {
      "indent": 3,
      "text": "- SAS: The Serial Attached SCSI (SAS) standard contains both a physical layer compatible with Serial ATA, and protocols for transporting SCSI commands to SAS devices and ATA commands to SATA devices [SAS] [SPL].",
      "zh-cn": "- SAS: The Serial Attached SCSI (SAS) standard contains both a physical layer compatible with Serial ATA, and protocols for transporting SCSI commands to SAS devices and ATA commands to SATA devices [SAS] [SPL]."
    },
    {
      "indent": 3,
      "text": "- SCSI Device: This is the SAM-2 term for an entity that contains one or more SCSI ports that are connected to a service delivery subsystem and supports a SCSI application protocol. For example, a SCSI initiator device contains one or more SCSI initiator ports and zero or more application clients. A target device contains one or more SCSI target ports and one or more device servers and associated LUs. For iSCSI, the SCSI device is the component within an iSCSI node that provides the SCSI functionality. As such, there can be at most one SCSI device within a given iSCSI node. Access to the SCSI device can only be achieved in an iSCSI Normal operational session. The SCSI device name is defined to be the iSCSI name of the node.",
      "zh-cn": "- SCSI Device: This is the SAM-2 term for an entity that contains one or more SCSI ports that are connected to a service delivery subsystem and supports a SCSI application protocol. For example, a SCSI initiator device contains one or more SCSI initiator ports and zero or more application clients. A target device contains one or more SCSI target ports and one or more device servers and associated LUs. For iSCSI, the SCSI device is the component within an iSCSI node that provides the SCSI functionality. As such, there can be at most one SCSI device within a given iSCSI node. Access to the SCSI device can only be achieved in an iSCSI Normal operational session. The SCSI device name is defined to be the iSCSI name of the node."
    },
    {
      "indent": 3,
      "text": "- SCSI Layer: This builds/receives SCSI CDBs (Command Descriptor Blocks) and relays/receives them with the remaining Execute Command [SAM2] parameters to/from the iSCSI Layer.",
      "zh-cn": "- SCSI Layer: This builds/receives SCSI CDBs (Command Descriptor Blocks) and relays/receives them with the remaining Execute Command [SAM2] parameters to/from the iSCSI Layer."
    },
    {
      "indent": 3,
      "text": "- Session: The group of TCP connections that link an initiator with a target form a session (loosely equivalent to a SCSI I_T nexus). TCP connections can be added and removed from a session. Across all connections within a session, an initiator sees one and the same target.",
      "zh-cn": "- Session: The group of TCP connections that link an initiator with a target form a session (loosely equivalent to a SCSI I_T nexus). TCP connections can be added and removed from a session. Across all connections within a session, an initiator sees one and the same target."
    },
    {
      "indent": 3,
      "text": "- SCSI Port: This is the SAM-2 term for an entity in a SCSI device that provides the SCSI functionality to interface with a service delivery subsystem. For iSCSI, the definitions of the SCSI initiator port and the SCSI target port are different.",
      "zh-cn": "- SCSI Port: This is the SAM-2 term for an entity in a SCSI device that provides the SCSI functionality to interface with a service delivery subsystem. For iSCSI, the definitions of the SCSI initiator port and the SCSI target port are different."
    },
    {
      "indent": 3,
      "text": "- SCSI Initiator Port: This maps to the endpoint of an iSCSI Normal operational session. An iSCSI Normal operational session is negotiated through the login process between an iSCSI initiator node and an iSCSI target node. At successful completion of this process, a SCSI initiator port is created within the SCSI initiator device. The SCSI initiator port name and SCSI initiator port identifier are both defined to be the iSCSI Initiator Name together with (a) a label that identifies it as an initiator port name/identifier and (b) the ISID portion of the session identifier.",
      "zh-cn": "- SCSI Initiator Port: This maps to the endpoint of an iSCSI Normal operational session. An iSCSI Normal operational session is negotiated through the login process between an iSCSI initiator node and an iSCSI target node. At successful completion of this process, a SCSI initiator port is created within the SCSI initiator device. The SCSI initiator port name and SCSI initiator port identifier are both defined to be the iSCSI Initiator Name together with (a) a label that identifies it as an initiator port name/identifier and (b) the ISID portion of the session identifier."
    },
    {
      "indent": 3,
      "text": "- SCSI Port Name: This is a name consisting of UTF-8 [RFC3629] encoding of Unicode [UNICODE] characters and includes the iSCSI name + 'i' or 't' + ISID or Target Portal Group Tag.",
      "zh-cn": "- SCSI Port Name: This is a name consisting of UTF-8 [RFC3629] encoding of Unicode [UNICODE] characters and includes the iSCSI name + 'i' or 't' + ISID or Target Portal Group Tag."
    },
    {
      "indent": 3,
      "text": "- SCSI-Presented Data Transfer Length (SPDTL): SPDTL is the aggregate data length of the data that the SCSI layer logically \"presents\" to the iSCSI layer for a Data-In or Data-Out transfer in the context of a SCSI task. For a bidirectional task, there are two SPDTL values -- one for Data-In and one for Data-Out. Note that the notion of \"presenting\" includes immediate data per the data",
      "zh-cn": "- SCSI-Presented Data Transfer Length (SPDTL): SPDTL is the aggregate data length of the data that the SCSI layer logically \"presents\" to the iSCSI layer for a Data-In or Data-Out transfer in the context of a SCSI task. For a bidirectional task, there are two SPDTL values -- one for Data-In and one for Data-Out. Note that the notion of \"presenting\" includes immediate data per the data"
    },
    {
      "indent": 5,
      "text": "transfer model in [SAM2] and excludes overlapping data transfers, if any, requested by the SCSI layer.",
      "zh-cn": "transfer model in [SAM2] and excludes overlapping data transfers, if any, requested by the SCSI layer."
    },
    {
      "indent": 3,
      "text": "- SCSI Target Port: This maps to an iSCSI target portal group.",
      "zh-cn": "- SCSI Target Port: This maps to an iSCSI target portal group."
    },
    {
      "indent": 3,
      "text": "- SCSI Target Port Name and SCSI Target Port Identifier: These are both defined to be the iSCSI Target Name together with (a) a label that identifies it as a target port name/identifier and (b) the Target Portal Group Tag.",
      "zh-cn": "- SCSI Target Port Name and SCSI Target Port Identifier: These are both defined to be the iSCSI Target Name together with (a) a label that identifies it as a target port name/identifier and (b) the Target Portal Group Tag."
    },
    {
      "indent": 3,
      "text": "- SSID (Session ID): A session between an iSCSI initiator and an iSCSI target is defined by a session ID that is a tuple composed of an initiator part (ISID) and a target part (Target Portal Group Tag). The ISID is explicitly specified by the initiator at session establishment. The Target Portal Group Tag is implied by the initiator through the selection of the TCP endpoint at connection establishment. The TargetPortalGroupTag key must also be returned by the target as a confirmation during connection establishment.",
      "zh-cn": "- SSID (Session ID): A session between an iSCSI initiator and an iSCSI target is defined by a session ID that is a tuple composed of an initiator part (ISID) and a target part (Target Portal Group Tag). The ISID is explicitly specified by the initiator at session establishment. The Target Portal Group Tag is implied by the initiator through the selection of the TCP endpoint at connection establishment. The TargetPortalGroupTag key must also be returned by the target as a confirmation during connection establishment."
    },
    {
      "indent": 3,
      "text": "- T10: T10 is a technical committee within INCITS that develops standards and technical reports on I/O interfaces, particularly the series of SCSI (Small Computer System Interface) standards. See <http://www.t10.org>.",
      "zh-cn": "- T10: T10 is a technical committee within INCITS that develops standards and technical reports on I/O interfaces, particularly the series of SCSI (Small Computer System Interface) standards. See <http://www.t10.org>."
    },
    {
      "indent": 3,
      "text": "- T11: T11 is a technical committee within INCITS responsible for standards development in the areas of Intelligent Peripheral Interface (IPI), High-Performance Parallel Interface (HIPPI), and Fibre Channel (FC). See <http://www.t11.org>.",
      "zh-cn": "- T11: T11 is a technical committee within INCITS responsible for standards development in the areas of Intelligent Peripheral Interface (IPI), High-Performance Parallel Interface (HIPPI), and Fibre Channel (FC). See <http://www.t11.org>."
    },
    {
      "indent": 3,
      "text": "- Target Portal Group Tag: This is a numerical identifier (16-bit) for an iSCSI target portal group.",
      "zh-cn": "- Target Portal Group Tag: This is a numerical identifier (16-bit) for an iSCSI target portal group."
    },
    {
      "indent": 3,
      "text": "- Target Transfer Tag (TTT): The TTT is an iSCSI protocol field used in a few iSCSI PDUs (e.g., R2T, NOP-In) that is always sent from the target to the initiator first and then quoted as a reference in initiator-sent PDUs back to the target relating to the same task/exchange. Therefore, the TTT effectively acts as an opaque handle to an existing task/exchange to help the target associate the incoming PDUs from the initiator to the proper execution context.",
      "zh-cn": "- Target Transfer Tag (TTT): The TTT is an iSCSI protocol field used in a few iSCSI PDUs (e.g., R2T, NOP-In) that is always sent from the target to the initiator first and then quoted as a reference in initiator-sent PDUs back to the target relating to the same task/exchange. Therefore, the TTT effectively acts as an opaque handle to an existing task/exchange to help the target associate the incoming PDUs from the initiator to the proper execution context."
    },
    {
      "indent": 3,
      "text": "- Third-party: This term is used in this document as a qualifier to nexus objects (I_T or I_T_L) and iSCSI sessions, to indicate that these objects and sessions reap the side effects of actions that take place in the context of a separate iSCSI session. One example of a third-party session is an iSCSI session discovering that its I_T_L nexus to a LU got reset due to a LU reset operation orchestrated via a separate I_T nexus.",
      "zh-cn": "- Third-party: This term is used in this document as a qualifier to nexus objects (I_T or I_T_L) and iSCSI sessions, to indicate that these objects and sessions reap the side effects of actions that take place in the context of a separate iSCSI session. One example of a third-party session is an iSCSI session discovering that its I_T_L nexus to a LU got reset due to a LU reset operation orchestrated via a separate I_T nexus."
    },
    {
      "indent": 3,
      "text": "- TSIH (Target Session Identifying Handle): This is a target-assigned tag for a session with a specific named initiator. The target generates it during session establishment. Other than defining it as a 16-bit binary string, its internal format and content are not defined by this protocol but for the value with all bits set to 0 that is reserved and used by the initiator to indicate a new session. It is given to the target during additional connection establishment for the same session.",
      "zh-cn": "- TSIH (Target Session Identifying Handle): This is a target-assigned tag for a session with a specific named initiator. The target generates it during session establishment. Other than defining it as a 16-bit binary string, its internal format and content are not defined by this protocol but for the value with all bits set to 0 that is reserved and used by the initiator to indicate a new session. It is given to the target during additional connection establishment for the same session."
    },
    {
      "indent": 0,
      "text": "2.3. Summary of Changes",
      "section_title": true,
      "zh-cn": "2.3. Summary of Changes"
    },
    {
      "indent": 3,
      "text": "1) Consolidated RFCs 3720, 3980, 4850, and 5048, and made the necessary editorial changes.",
      "zh-cn": "1) Consolidated RFCs 3720, 3980, 4850, and 5048, and made the necessary editorial changes."
    },
    {
      "indent": 3,
      "text": "2) Specified iSCSIProtocolLevel as \"1\" in Section 13.24 and added a related normative reference to [RFC7144].",
      "zh-cn": "2) Specified iSCSIProtocolLevel as \"1\" in Section 13.24 and added a related normative reference to [RFC7144]."
    },
    {
      "indent": 3,
      "text": "3) Removed markers and related keys.",
      "zh-cn": "3) Removed markers and related keys."
    },
    {
      "indent": 3,
      "text": "4) Removed SPKM authentication and related keys.",
      "zh-cn": "4) Removed SPKM authentication and related keys."
    },
    {
      "indent": 3,
      "text": "5) Added a new Section 13.25 on responding to obsoleted keys.",
      "zh-cn": "5) Added a new Section 13.25 on responding to obsoleted keys."
    },
    {
      "indent": 3,
      "text": "6) Have explicitly allowed initiator+target implementations throughout the text.",
      "zh-cn": "6) Have explicitly allowed initiator+target implementations throughout the text."
    },
    {
      "indent": 3,
      "text": "7) Clarified in Section 4.2.7 that implementations SHOULD NOT rely on SLP-based discovery.",
      "zh-cn": "7) Clarified in Section 4.2.7 that implementations SHOULD NOT rely on SLP-based discovery."
    },
    {
      "indent": 3,
      "text": "8) Added Unified Modeling Language (UML) diagrams and related conventions in Section 3.",
      "zh-cn": "8) Added Unified Modeling Language (UML) diagrams and related conventions in Section 3."
    },
    {
      "indent": 3,
      "text": "9) Made FastAbort implementation a \"SHOULD\" requirement in Section 4.2.3.4, rather than the previous \"MUST\" requirement.",
      "zh-cn": "9) Made FastAbort implementation a \"SHOULD\" requirement in Section 4.2.3.4, rather than the previous \"MUST\" requirement."
    },
    {
      "indent": 3,
      "text": "10) Required in Section 4.2.7.1 that iSCSI Target Name be the same as iSCSI Initiator Name for SCSI (composite) devices with both roles.",
      "zh-cn": "10) Required in Section 4.2.7.1 that iSCSI Target Name be the same as iSCSI Initiator Name for SCSI (composite) devices with both roles."
    },
    {
      "indent": 3,
      "text": "11) Changed the \"MUST NOT\" to \"should be avoided\" in Section 4.2.7.2 regarding usage of characters such as punctuation marks in iSCSI names.",
      "zh-cn": "11) Changed the \"MUST NOT\" to \"should be avoided\" in Section 4.2.7.2 regarding usage of characters such as punctuation marks in iSCSI names."
    },
    {
      "indent": 3,
      "text": "12) Updated Section 9.3 to require the following: MUST implement IPsec, 2400-series RFCs (IPsec v2, IKEv1); and SHOULD implement IPsec, 4300-series RFCs (IPsec v3, IKEv2).",
      "zh-cn": "12) Updated Section 9.3 to require the following: MUST implement IPsec, 2400-series RFCs (IPsec v2, IKEv1); and SHOULD implement IPsec, 4300-series RFCs (IPsec v3, IKEv2)."
    },
    {
      "indent": 3,
      "text": "13) Clarified in Section 10.2 that ACA is a \"SHOULD\" only for iSCSI targets.",
      "zh-cn": "13) Clarified in Section 10.2 that ACA is a \"SHOULD\" only for iSCSI targets."
    },
    {
      "indent": 3,
      "text": "14) Prohibited usage of X# name prefix for new public keys in Section 6.2.",
      "zh-cn": "14) Prohibited usage of X# name prefix for new public keys in Section 6.2."
    },
    {
      "indent": 3,
      "text": "15) Prohibited usage of Y# name prefix for new digest extensions in Section 13.1 and Z# name prefix for new authentication method extensions in Section 12.1.",
      "zh-cn": "15) Prohibited usage of Y# name prefix for new digest extensions in Section 13.1 and Z# name prefix for new authentication method extensions in Section 12.1."
    },
    {
      "indent": 3,
      "text": "16) Added a \"SHOULD\" in Section 6.2 that initiators and targets support at least six (6) exchanges during text negotiation.",
      "zh-cn": "16) Added a \"SHOULD\" in Section 6.2 that initiators and targets support at least six (6) exchanges during text negotiation."
    },
    {
      "indent": 3,
      "text": "17) Added a clarification that Appendix C is normative.",
      "zh-cn": "17) Added a clarification that Appendix C is normative."
    },
    {
      "indent": 3,
      "text": "18) Added a normative requirement on [RFC7146] and made a few related changes in Section 9.3 to align the text in this document with that of [RFC7146].",
      "zh-cn": "18) Added a normative requirement on [RFC7146] and made a few related changes in Section 9.3 to align the text in this document with that of [RFC7146]."
    },
    {
      "indent": 3,
      "text": "19) Added a new Section 9.2.3 covering Kerberos authentication considerations.",
      "zh-cn": "19) Added a new Section 9.2.3 covering Kerberos authentication considerations."
    },
    {
      "indent": 3,
      "text": "20) Added text in Section 9.3.3 noting that OCSP is now allowed for checking certificates used with IPsec in addition to the use of CRLs.",
      "zh-cn": "20) Added text in Section 9.3.3 noting that OCSP is now allowed for checking certificates used with IPsec in addition to the use of CRLs."
    },
    {
      "indent": 3,
      "text": "21) Added text in Section 9.3.1 specifying that extended sequence numbers (ESNs) are now required for ESPv2 (part of IPsec v2).",
      "zh-cn": "21) Added text in Section 9.3.1 specifying that extended sequence numbers (ESNs) are now required for ESPv2 (part of IPsec v2)."
    },
    {
      "indent": 0,
      "text": "2.4. Conventions",
      "section_title": true,
      "zh-cn": "2.4. 公约"
    },
    {
      "indent": 3,
      "text": "In examples, \"I->\" and \"T->\" show iSCSI PDUs sent by the initiator and target, respectively.",
      "zh-cn": "In examples, \"I->\" and \"T->\" show iSCSI PDUs sent by the initiator and target, respectively."
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "zh-cn": "关键字 \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", 和 \"OPTIONAL\" 应按照 rfc 2119 [rfc2119] 中的描述进行解释。"
    },
    {
      "indent": 0,
      "text": "3. UML Conventions",
      "section_title": true,
      "zh-cn": "3. UML Conventions"
    },
    {
      "indent": 0,
      "text": "3.1. UML Conventions Overview",
      "section_title": true,
      "zh-cn": "3.1. UML Conventions Overview"
    },
    {
      "indent": 3,
      "text": "The SCSI Architecture Model (SAM) uses class diagrams and object diagrams with notation that is based on the Unified Modeling Language [UML]. Therefore, this document also uses UML to model the relationships for SCSI and iSCSI objects.",
      "zh-cn": "The SCSI Architecture Model (SAM) uses class diagrams and object diagrams with notation that is based on the Unified Modeling Language [UML]. Therefore, this document also uses UML to model the relationships for SCSI and iSCSI objects."
    },
    {
      "indent": 3,
      "text": "A treatise on the graphical notation used in UML is beyond the scope of this document. However, given the use of ASCII drawing for UML static class diagrams, a description of the notational conventions used in this document is included in the remainder of this section.",
      "zh-cn": "A treatise on the graphical notation used in UML is beyond the scope of this document. However, given the use of ASCII drawing for UML static class diagrams, a description of the notational conventions used in this document is included in the remainder of this section."
    },
    {
      "indent": 0,
      "text": "3.2. Multiplicity Notion",
      "section_title": true,
      "zh-cn": "3.2. Multiplicity Notion"
    },
    {
      "indent": 3,
      "text": "Not specified The number of instances of an attribute is not specified.",
      "zh-cn": "Not specified The number of instances of an attribute is not specified."
    },
    {
      "indent": 15,
      "text": "1 One instance of the class or attribute exists.",
      "zh-cn": "1 One instance of the class or attribute exists."
    },
    {
      "indent": 12,
      "text": "0..* Zero or more instances of the class or attribute exist.",
      "zh-cn": "0..* Zero or more instances of the class or attribute exist."
    },
    {
      "indent": 12,
      "text": "1..* One or more instances of the class or attribute exist.",
      "zh-cn": "1..* One or more instances of the class or attribute exist."
    },
    {
      "indent": 12,
      "text": "0..1 Zero or one instance of the class or attribute exists.",
      "zh-cn": "0..1 Zero or one instance of the class or attribute exists."
    },
    {
      "indent": 12,
      "text": "n..m n to m instances of the class or attribute exist (e.g., 2..8).",
      "zh-cn": "n..m n to m instances of the class or attribute exist (e.g., 2..8)."
    },
    {
      "indent": 9,
      "text": "x, n..m Multiple disjoint instances of the class or attribute exist (e.g., 2, 8..15).",
      "zh-cn": "x, n..m Multiple disjoint instances of the class or attribute exist (e.g., 2, 8..15)."
    },
    {
      "indent": 0,
      "text": "3.3. Class Diagram Conventions",
      "section_title": true,
      "zh-cn": "3.3. Class Diagram Conventions"
    },
    {
      "indent": 5,
      "text": "+--------------+    +--------------+       +--------------+\n|  Class Name  |    |  Class Name  |       |  Class Name  |\n+--------------+    +--------------+       +--------------+\n|              |    |              |\n+--------------+    +--------------+\n|              |\n+--------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The previous three diagrams are examples of a class with no attributes and with no operations.",
      "zh-cn": "The previous three diagrams are examples of a class with no attributes and with no operations."
    },
    {
      "indent": 5,
      "text": "+-------------------+    +-------------------+\n|    Class Name     |    |    Class Name     |\n+-------------------+    +-------------------+\n| attribute 01[1]   |    |   attribute 01[1] |\n| attribute 02[1]   |    |   attribute 02[1] |\n+-------------------+    +-------------------+\n|                   |\n+-------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding two diagrams are examples of a class with attributes and with no operations.",
      "zh-cn": "The preceding two diagrams are examples of a class with attributes and with no operations."
    },
    {
      "indent": 5,
      "text": "+------------------------+\n|      Class Name        |\n+------------------------+\n|    attribute 01[1..*]  |\n|    attribute 02[1]     |\n+------------------------+\n|    operation 01()      |\n|    operation 02()      |\n+------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example of a class with attributes that have a specified multiplicity and operations.",
      "zh-cn": "The preceding diagram is an example of a class with attributes that have a specified multiplicity and operations."
    },
    {
      "indent": 0,
      "text": "3.4. Class Diagram Notation for Associations",
      "section_title": true,
      "zh-cn": "3.4. Class Diagram Notation for Associations"
    },
    {
      "indent": 5,
      "text": "+-----------------+\n|     Class A     |\n+-----------------+ association_name   +-----------------+\n| attribute 01[1] |<------------------>|     Class B     |\n| attribute 02[1] | 1..*          0..1 +-----------------+\n+-----------------+                    | attribute 03[1] |\n| operation 1()   |                    +-----------------+\n+-----------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where Class A knows about Class B (i.e., read as \"Class A association_name Class B\") and Class B knows about Class A (i.e., read as \"Class B association_name Class A\"). The use of association_name is optional. The multiplicity notation (1..* and 0..1) indicates the number of instances of the object.",
      "zh-cn": "The preceding diagram is an example where Class A knows about Class B (i.e., read as \"Class A association_name Class B\") and Class B knows about Class A (i.e., read as \"Class B association_name Class A\"). The use of association_name is optional. The multiplicity notation (1..* and 0..1) indicates the number of instances of the object."
    },
    {
      "indent": 5,
      "text": "+--------------------+\n|      Class A       |\n+--------------------+              +--------------------+\n| attribute 01[1]    |<-------------|      Class B       |\n| attribute 02[1]    | 1      0..1  +--------------------+\n+--------------------+              | attribute 03[1]    |\n| operation 1()      |              +--------------------+\n+--------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where Class B knows about Class A (i.e., read as \"Class B knows about Class A\") but Class A does not know about Class B.",
      "zh-cn": "The preceding diagram is an example where Class B knows about Class A (i.e., read as \"Class B knows about Class A\") but Class A does not know about Class B."
    },
    {
      "indent": 5,
      "text": "+----------------------+\n|       Class A        |\n+----------------------+            +--------------------+\n|   attribute 01[1]    |----------->|      Class B       |\n|   attribute 02[1]    | 0..*     1 +--------------------+\n+----------------------+            | attribute 03[1]    |\n|    operation 1()     |            +--------------------+\n+----------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where Class A knows about Class B (i.e., read as \"Class A knows about Class B\") but Class B does not know about Class A.",
      "zh-cn": "The preceding diagram is an example where Class A knows about Class B (i.e., read as \"Class A knows about Class B\") but Class B does not know about Class A."
    },
    {
      "indent": 0,
      "text": "3.5. Class Diagram Notation for Aggregations",
      "section_title": true,
      "zh-cn": "3.5. Class Diagram Notation for Aggregations"
    },
    {
      "indent": 5,
      "text": "+---------------+             +--------------+\n|  Class whole  |o------------|  Class part  |\n+---------------+             +--------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where Class whole is an aggregate that contains Class part and where Class part may continue to exist even if Class whole is removed (i.e., read as \"the whole contains the part\").",
      "zh-cn": "The preceding diagram is an example where Class whole is an aggregate that contains Class part and where Class part may continue to exist even if Class whole is removed (i.e., read as \"the whole contains the part\")."
    },
    {
      "indent": 5,
      "text": "+---------------+             +--------------+\n|  Class whole  |@------------|  Class part  |\n+---------------+             +--------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where Class whole is an aggregate that contains Class part where Class part only belongs to one Class whole, and the Class part does not continue to exist if the Class whole is removed (i.e., read as \"the whole contains the part\").",
      "zh-cn": "The preceding diagram is an example where Class whole is an aggregate that contains Class part where Class part only belongs to one Class whole, and the Class part does not continue to exist if the Class whole is removed (i.e., read as \"the whole contains the part\")."
    },
    {
      "indent": 5,
      "text": "+-------------+\n|             |\n+-------------+\n   |       |\n   + =(a)= +\n   |       |",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where there is a constraint between the associations, where the (a) footnote describes the constraint.",
      "zh-cn": "The preceding diagram is an example where there is a constraint between the associations, where the (a) footnote describes the constraint."
    },
    {
      "indent": 0,
      "text": "3.6. Class Diagram Notation for Generalizations",
      "section_title": true,
      "zh-cn": "3.6. Class Diagram Notation for Generalizations"
    },
    {
      "indent": 5,
      "text": "+---------------+\n|  Superclass   |\n+-------^-------+\n       /_\\\n        |\n+---------------+\n|    Subclass   |\n+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "The preceding diagram is an example where the subclass is a kind of superclass. A subclass shares all the attributes and operations of the superclass (i.e., the subclass inherits from the superclass).",
      "zh-cn": "The preceding diagram is an example where the subclass is a kind of superclass. A subclass shares all the attributes and operations of the superclass (i.e., the subclass inherits from the superclass)."
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "zh-cn": "4. Overview"
    },
    {
      "indent": 0,
      "text": "4.1. SCSI Concepts",
      "section_title": true,
      "zh-cn": "4.1. SCSI Concepts"
    },
    {
      "indent": 3,
      "text": "The SCSI Architecture Model - 2 [SAM2] describes in detail the architecture of the SCSI family of I/O protocols. This section provides a brief background of the SCSI architecture and is intended to familiarize readers with its terminology.",
      "zh-cn": "The SCSI Architecture Model - 2 [SAM2] describes in detail the architecture of the SCSI family of I/O protocols. This section provides a brief background of the SCSI architecture and is intended to familiarize readers with its terminology."
    },
    {
      "indent": 3,
      "text": "At the highest level, SCSI is a family of interfaces for requesting services from I/O devices, including hard drives, tape drives, CD and DVD drives, printers, and scanners. In SCSI terminology, an individual I/O device is called a \"logical unit\" (LU).",
      "zh-cn": "At the highest level, SCSI is a family of interfaces for requesting services from I/O devices, including hard drives, tape drives, CD and DVD drives, printers, and scanners. In SCSI terminology, an individual I/O device is called a \"logical unit\" (LU)."
    },
    {
      "indent": 3,
      "text": "SCSI is a client-server architecture. Clients of a SCSI interface are called \"initiators\". Initiators issue SCSI \"commands\" to request services from components -- LUs of a server known as a \"target\". The \"device server\" on the LU accepts SCSI commands and processes them.",
      "zh-cn": "SCSI is a client-server architecture. Clients of a SCSI interface are called \"initiators\". Initiators issue SCSI \"commands\" to request services from components -- LUs of a server known as a \"target\". The \"device server\" on the LU accepts SCSI commands and processes them."
    },
    {
      "indent": 3,
      "text": "A \"SCSI transport\" maps the client-server SCSI protocol to a specific interconnect. The initiator is one endpoint of a SCSI transport. The \"target\" is the other endpoint. A target can contain multiple LUs. Each LU has an address within a target called a Logical Unit Number (LUN).",
      "zh-cn": "A \"SCSI transport\" maps the client-server SCSI protocol to a specific interconnect. The initiator is one endpoint of a SCSI transport. The \"target\" is the other endpoint. A target can contain multiple LUs. Each LU has an address within a target called a Logical Unit Number (LUN)."
    },
    {
      "indent": 3,
      "text": "A SCSI task is a SCSI command or possibly a linked set of SCSI commands. Some LUs support multiple pending (queued) tasks, but the queue of tasks is managed by the LU. The target uses an initiator-provided \"task tag\" to distinguish between tasks. Only one command in a task can be outstanding at any given time.",
      "zh-cn": "A SCSI task is a SCSI command or possibly a linked set of SCSI commands. Some LUs support multiple pending (queued) tasks, but the queue of tasks is managed by the LU. The target uses an initiator-provided \"task tag\" to distinguish between tasks. Only one command in a task can be outstanding at any given time."
    },
    {
      "indent": 3,
      "text": "Each SCSI command results in an optional data phase and a required response phase. In the data phase, information can travel from the initiator to the target (e.g., write), from the target to the initiator (e.g., read), or in both directions. In the response phase, the target returns the final status of the operation, including any errors.",
      "zh-cn": "Each SCSI command results in an optional data phase and a required response phase. In the data phase, information can travel from the initiator to the target (e.g., write), from the target to the initiator (e.g., read), or in both directions. In the response phase, the target returns the final status of the operation, including any errors."
    },
    {
      "indent": 3,
      "text": "Command Descriptor Blocks (CDBs) are the data structures used to contain the command parameters that an initiator sends to a target. The CDB content and structure are defined by [SAM2] and device-type specific SCSI standards.",
      "zh-cn": "Command Descriptor Blocks (CDBs) are the data structures used to contain the command parameters that an initiator sends to a target. The CDB content and structure are defined by [SAM2] and device-type specific SCSI standards."
    },
    {
      "indent": 0,
      "text": "4.2. iSCSI Concepts and Functional Overview",
      "section_title": true,
      "zh-cn": "4.2. iSCSI Concepts and Functional Overview"
    },
    {
      "indent": 3,
      "text": "The iSCSI protocol is a mapping of the SCSI command, event, and task management model (see [SAM2]) over the TCP protocol. SCSI commands are carried by iSCSI requests, and SCSI responses and status are carried by iSCSI responses. iSCSI also uses the request-response mechanism for iSCSI protocol mechanisms.",
      "zh-cn": "The iSCSI protocol is a mapping of the SCSI command, event, and task management model (see [SAM2]) over the TCP protocol. SCSI commands are carried by iSCSI requests, and SCSI responses and status are carried by iSCSI responses. iSCSI also uses the request-response mechanism for iSCSI protocol mechanisms."
    },
    {
      "indent": 3,
      "text": "For the remainder of this document, the terms \"initiator\" and \"target\" refer to \"iSCSI initiator node\" and \"iSCSI target node\", respectively (see iSCSI), unless otherwise qualified.",
      "zh-cn": "For the remainder of this document, the terms \"initiator\" and \"target\" refer to \"iSCSI initiator node\" and \"iSCSI target node\", respectively (see iSCSI), unless otherwise qualified."
    },
    {
      "indent": 3,
      "text": "As its title suggests, Section 4 presents an overview of the iSCSI concepts, and later sections in the rest of the specification contain the normative requirements -- in many cases covering the same concepts discussed in Section 4. Such normative requirements text overrides the overview text in Section 4 if there is a disagreement between the two.",
      "zh-cn": "As its title suggests, Section 4 presents an overview of the iSCSI concepts, and later sections in the rest of the specification contain the normative requirements -- in many cases covering the same concepts discussed in Section 4. Such normative requirements text overrides the overview text in Section 4 if there is a disagreement between the two."
    },
    {
      "indent": 3,
      "text": "In keeping with similar protocols, the initiator and target divide their communications into messages. This document uses the term \"iSCSI Protocol Data Unit\" (iSCSI PDU) for these messages.",
      "zh-cn": "In keeping with similar protocols, the initiator and target divide their communications into messages. This document uses the term \"iSCSI Protocol Data Unit\" (iSCSI PDU) for these messages."
    },
    {
      "indent": 3,
      "text": "For performance reasons, iSCSI allows a \"phase-collapse\". A command and its associated data may be shipped together from initiator to target, and data and responses may be shipped together from targets.",
      "zh-cn": "For performance reasons, iSCSI allows a \"phase-collapse\". A command and its associated data may be shipped together from initiator to target, and data and responses may be shipped together from targets."
    },
    {
      "indent": 3,
      "text": "The iSCSI transfer direction is defined with respect to the initiator. Outbound or outgoing transfers are transfers from an initiator to a target, while inbound or incoming transfers are from a target to an initiator.",
      "zh-cn": "The iSCSI transfer direction is defined with respect to the initiator. Outbound or outgoing transfers are transfers from an initiator to a target, while inbound or incoming transfers are from a target to an initiator."
    },
    {
      "indent": 3,
      "text": "An iSCSI task is an iSCSI request for which a response is expected.",
      "zh-cn": "An iSCSI task is an iSCSI request for which a response is expected."
    },
    {
      "indent": 3,
      "text": "In this document, \"iSCSI request\", \"iSCSI command\", request, or (unqualified) command have the same meaning. Also, unless otherwise specified, status, response, or numbered response have the same meaning.",
      "zh-cn": "In this document, \"iSCSI request\", \"iSCSI command\", request, or (unqualified) command have the same meaning. Also, unless otherwise specified, status, response, or numbered response have the same meaning."
    },
    {
      "indent": 0,
      "text": "4.2.1. Layers and Sessions",
      "section_title": true,
      "zh-cn": "4.2.1. Layers and Sessions"
    },
    {
      "indent": 3,
      "text": "The following conceptual layering model is used to specify initiator and target actions and the way in which they relate to transmitted and received Protocol Data Units:",
      "zh-cn": "The following conceptual layering model is used to specify initiator and target actions and the way in which they relate to transmitted and received Protocol Data Units:"
    },
    {
      "indent": 6,
      "text": "- The SCSI layer builds/receives SCSI CDBs (Command Descriptor Blocks) and passes/receives them with the remaining Execute Command [SAM2] parameters to/from",
      "zh-cn": "- The SCSI layer builds/receives SCSI CDBs (Command Descriptor Blocks) and passes/receives them with the remaining Execute Command [SAM2] parameters to/from"
    },
    {
      "indent": 6,
      "text": "- the iSCSI layer that builds/receives iSCSI PDUs and relays/receives them to/from one or more TCP connections; the group of connections form an initiator-target \"session\".",
      "zh-cn": "- the iSCSI layer that builds/receives iSCSI PDUs and relays/receives them to/from one or more TCP connections; the group of connections form an initiator-target \"session\"."
    },
    {
      "indent": 3,
      "text": "Communication between the initiator and target occurs over one or more TCP connections. The TCP connections carry control messages, SCSI commands, parameters, and data within iSCSI Protocol Data Units (iSCSI PDUs). The group of TCP connections that link an initiator with a target form a session (equivalent to a SCSI I_T nexus; see Section 4.4.2). A session is defined by a session ID that is composed of an initiator part and a target part. TCP connections can be added and removed from a session. Each connection within a session is identified by a connection ID (CID).",
      "zh-cn": "Communication between the initiator and target occurs over one or more TCP connections. The TCP connections carry control messages, SCSI commands, parameters, and data within iSCSI Protocol Data Units (iSCSI PDUs). The group of TCP connections that link an initiator with a target form a session (equivalent to a SCSI I_T nexus; see Section 4.4.2). A session is defined by a session ID that is composed of an initiator part and a target part. TCP connections can be added and removed from a session. Each connection within a session is identified by a connection ID (CID)."
    },
    {
      "indent": 3,
      "text": "Across all connections within a session, an initiator sees one \"target image\". All target-identifying elements, such as a LUN, are the same. A target also sees one \"initiator image\" across all connections within a session. Initiator-identifying elements, such as the Initiator Task Tag, are global across the session, regardless of the connection on which they are sent or received.",
      "zh-cn": "Across all connections within a session, an initiator sees one \"target image\". All target-identifying elements, such as a LUN, are the same. A target also sees one \"initiator image\" across all connections within a session. Initiator-identifying elements, such as the Initiator Task Tag, are global across the session, regardless of the connection on which they are sent or received."
    },
    {
      "indent": 3,
      "text": "iSCSI targets and initiators MUST support at least one TCP connection and MAY support several connections in a session. For error recovery purposes, targets and initiators that support a single active connection in a session SHOULD support two connections during recovery.",
      "zh-cn": "iSCSI targets and initiators MUST support at least one TCP connection and MAY support several connections in a session. For error recovery purposes, targets and initiators that support a single active connection in a session SHOULD support two connections during recovery."
    },
    {
      "indent": 0,
      "text": "4.2.2. Ordering and iSCSI Numbering",
      "section_title": true,
      "zh-cn": "4.2.2. Ordering and iSCSI Numbering"
    },
    {
      "indent": 3,
      "text": "iSCSI uses command and status numbering schemes and a data sequencing scheme.",
      "zh-cn": "iSCSI uses command and status numbering schemes and a data sequencing scheme."
    },
    {
      "indent": 3,
      "text": "Command numbering is session-wide and is used for ordered command delivery over multiple connections. It can also be used as a mechanism for command flow control over a session.",
      "zh-cn": "Command numbering is session-wide and is used for ordered command delivery over multiple connections. It can also be used as a mechanism for command flow control over a session."
    },
    {
      "indent": 3,
      "text": "Status numbering is per connection and is used to enable missing status detection and recovery in the presence of transient or permanent communication errors.",
      "zh-cn": "Status numbering is per connection and is used to enable missing status detection and recovery in the presence of transient or permanent communication errors."
    },
    {
      "indent": 3,
      "text": "Data sequencing is per command or part of a command (R2T-triggered sequence) and is used to detect missing data and/or R2T PDUs due to header digest errors.",
      "zh-cn": "Data sequencing is per command or part of a command (R2T-triggered sequence) and is used to detect missing data and/or R2T PDUs due to header digest errors."
    },
    {
      "indent": 3,
      "text": "Typically, fields in the iSCSI PDUs communicate the sequence numbers between the initiator and target. During periods when traffic on a connection is unidirectional, iSCSI NOP-Out/NOP-In PDUs may be utilized to synchronize the command and status ordering counters of the target and initiator.",
      "zh-cn": "Typically, fields in the iSCSI PDUs communicate the sequence numbers between the initiator and target. During periods when traffic on a connection is unidirectional, iSCSI NOP-Out/NOP-In PDUs may be utilized to synchronize the command and status ordering counters of the target and initiator."
    },
    {
      "indent": 3,
      "text": "The iSCSI session abstraction is equivalent to the SCSI I_T nexus, and the iSCSI session provides an ordered command delivery from the SCSI initiator to the SCSI target. For detailed design considerations that led to the iSCSI session model as it is defined here and how it relates the SCSI command ordering features defined in SCSI specifications to the iSCSI concepts, see [RFC3783].",
      "zh-cn": "The iSCSI session abstraction is equivalent to the SCSI I_T nexus, and the iSCSI session provides an ordered command delivery from the SCSI initiator to the SCSI target. For detailed design considerations that led to the iSCSI session model as it is defined here and how it relates the SCSI command ordering features defined in SCSI specifications to the iSCSI concepts, see [RFC3783]."
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Command Numbering and Acknowledging",
      "section_title": true,
      "zh-cn": "4.2.2.1. Command Numbering and Acknowledging"
    },
    {
      "indent": 3,
      "text": "iSCSI performs ordered command delivery within a session. All commands (initiator-to-target PDUs) in transit from the initiator to the target are numbered.",
      "zh-cn": "iSCSI performs ordered command delivery within a session. All commands (initiator-to-target PDUs) in transit from the initiator to the target are numbered."
    },
    {
      "indent": 3,
      "text": "iSCSI considers a task to be instantiated on the target in response to every request issued by the initiator. A set of task management operations, including abort and reassign (see Section 11.5), may be performed on an iSCSI task; however, an abort operation cannot be performed on a task management operation, and usage of reassign operations has certain constraints. See Section 11.5.1 for details.",
      "zh-cn": "iSCSI considers a task to be instantiated on the target in response to every request issued by the initiator. A set of task management operations, including abort and reassign (see Section 11.5), may be performed on an iSCSI task; however, an abort operation cannot be performed on a task management operation, and usage of reassign operations has certain constraints. See Section 11.5.1 for details."
    },
    {
      "indent": 3,
      "text": "Some iSCSI tasks are SCSI tasks, and many SCSI activities are related to a SCSI task ([SAM2]). In all cases, the task is identified by the Initiator Task Tag for the life of the task.",
      "zh-cn": "Some iSCSI tasks are SCSI tasks, and many SCSI activities are related to a SCSI task ([SAM2]). In all cases, the task is identified by the Initiator Task Tag for the life of the task."
    },
    {
      "indent": 3,
      "text": "The command number is carried by the iSCSI PDU as the CmdSN (command sequence number). The numbering is session-wide. Outgoing iSCSI PDUs carry this number. The iSCSI initiator allocates CmdSNs with a 32-bit unsigned counter (modulo 2**32). Comparisons and arithmetic on CmdSNs use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.",
      "zh-cn": "The command number is carried by the iSCSI PDU as the CmdSN (command sequence number). The numbering is session-wide. Outgoing iSCSI PDUs carry this number. The iSCSI initiator allocates CmdSNs with a 32-bit unsigned counter (modulo 2**32). Comparisons and arithmetic on CmdSNs use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32."
    },
    {
      "indent": 3,
      "text": "Commands meant for immediate delivery are marked with an immediate delivery flag; they MUST also carry the current CmdSN. The CmdSN MUST NOT advance after a command marked for immediate delivery is sent.",
      "zh-cn": "Commands meant for immediate delivery are marked with an immediate delivery flag; they MUST also carry the current CmdSN. The CmdSN MUST NOT advance after a command marked for immediate delivery is sent."
    },
    {
      "indent": 3,
      "text": "Command numbering starts with the first Login Request on the first connection of a session (the leading login on the leading connection), and the CmdSN MUST be incremented by 1 in a Serial Number Arithmetic sense, as defined in [RFC1982], for every non-immediate command issued afterwards.",
      "zh-cn": "Command numbering starts with the first Login Request on the first connection of a session (the leading login on the leading connection), and the CmdSN MUST be incremented by 1 in a Serial Number Arithmetic sense, as defined in [RFC1982], for every non-immediate command issued afterwards."
    },
    {
      "indent": 3,
      "text": "If immediate delivery is used with task management commands, these commands may reach the target before the tasks on which they are supposed to act. However, their CmdSN serves as a marker of their position in the stream of commands. The initiator and target MUST ensure that the SCSI task management functions specified in [SAM2] act in accordance with the [SAM2] specification. For example, both commands and responses appear as if delivered in order. Whenever the CmdSN for an outgoing PDU is not specified by an explicit rule, the CmdSN will carry the current value of the local CmdSN variable (see later in this section).",
      "zh-cn": "If immediate delivery is used with task management commands, these commands may reach the target before the tasks on which they are supposed to act. However, their CmdSN serves as a marker of their position in the stream of commands. The initiator and target MUST ensure that the SCSI task management functions specified in [SAM2] act in accordance with the [SAM2] specification. For example, both commands and responses appear as if delivered in order. Whenever the CmdSN for an outgoing PDU is not specified by an explicit rule, the CmdSN will carry the current value of the local CmdSN variable (see later in this section)."
    },
    {
      "indent": 3,
      "text": "The means by which an implementation decides to mark a PDU for immediate delivery or by which iSCSI decides by itself to mark a PDU for immediate delivery are beyond the scope of this document.",
      "zh-cn": "The means by which an implementation decides to mark a PDU for immediate delivery or by which iSCSI decides by itself to mark a PDU for immediate delivery are beyond the scope of this document."
    },
    {
      "indent": 3,
      "text": "The number of commands used for immediate delivery is not limited, and their delivery to execution is not acknowledged through the numbering scheme. An iSCSI target MAY reject immediate commands, e.g., due to lack of resources to accommodate additional commands. An iSCSI target MUST be able to handle at least one immediate task management command and one immediate non-task-management iSCSI command per connection at any time.",
      "zh-cn": "The number of commands used for immediate delivery is not limited, and their delivery to execution is not acknowledged through the numbering scheme. An iSCSI target MAY reject immediate commands, e.g., due to lack of resources to accommodate additional commands. An iSCSI target MUST be able to handle at least one immediate task management command and one immediate non-task-management iSCSI command per connection at any time."
    },
    {
      "indent": 3,
      "text": "In this document, delivery for execution means delivery to the SCSI execution engine or an iSCSI protocol-specific execution engine (e.g., for Text Requests with public or private extension keys involving an execution component). With the exception of the commands marked for immediate delivery, the iSCSI target layer MUST deliver the commands for execution in the order specified by the CmdSN. Commands marked for immediate delivery may be delivered by",
      "zh-cn": "In this document, delivery for execution means delivery to the SCSI execution engine or an iSCSI protocol-specific execution engine (e.g., for Text Requests with public or private extension keys involving an execution component). With the exception of the commands marked for immediate delivery, the iSCSI target layer MUST deliver the commands for execution in the order specified by the CmdSN. Commands marked for immediate delivery may be delivered by"
    },
    {
      "indent": 3,
      "text": "the iSCSI target layer for execution as soon as detected. iSCSI may avoid delivering some commands to the SCSI target layer if required by a prior SCSI or iSCSI action (e.g., a CLEAR TASK SET task management request received before all the commands on which it was supposed to act).",
      "zh-cn": "the iSCSI target layer for execution as soon as detected. iSCSI may avoid delivering some commands to the SCSI target layer if required by a prior SCSI or iSCSI action (e.g., a CLEAR TASK SET task management request received before all the commands on which it was supposed to act)."
    },
    {
      "indent": 3,
      "text": "On any connection, the iSCSI initiator MUST send the commands in increasing order of CmdSN, except for commands that are retransmitted due to digest error recovery and connection recovery.",
      "zh-cn": "On any connection, the iSCSI initiator MUST send the commands in increasing order of CmdSN, except for commands that are retransmitted due to digest error recovery and connection recovery."
    },
    {
      "indent": 3,
      "text": "For the numbering mechanism, the initiator and target maintain the following three variables for each session:",
      "zh-cn": "For the numbering mechanism, the initiator and target maintain the following three variables for each session:"
    },
    {
      "indent": 6,
      "text": "- CmdSN: the current command sequence number, advanced by 1 on each command shipped except for commands marked for immediate delivery as discussed above. The CmdSN always contains the number to be assigned to the next command PDU.",
      "zh-cn": "- CmdSN: the current command sequence number, advanced by 1 on each command shipped except for commands marked for immediate delivery as discussed above. The CmdSN always contains the number to be assigned to the next command PDU."
    },
    {
      "indent": 6,
      "text": "- ExpCmdSN: the next expected command by the target. The target acknowledges all commands up to, but not including, this number. The initiator treats all commands with a CmdSN less than the ExpCmdSN as acknowledged. The target iSCSI layer sets the ExpCmdSN to the largest non-immediate CmdSN that it can deliver for execution \"plus 1\" per [RFC1982]. There MUST NOT be any holes in the acknowledged CmdSN sequence.",
      "zh-cn": "- ExpCmdSN: the next expected command by the target. The target acknowledges all commands up to, but not including, this number. The initiator treats all commands with a CmdSN less than the ExpCmdSN as acknowledged. The target iSCSI layer sets the ExpCmdSN to the largest non-immediate CmdSN that it can deliver for execution \"plus 1\" per [RFC1982]. There MUST NOT be any holes in the acknowledged CmdSN sequence."
    },
    {
      "indent": 6,
      "text": "- MaxCmdSN: the maximum number to be shipped. The queuing capacity of the receiving iSCSI layer is MaxCmdSN - ExpCmdSN + 1.",
      "zh-cn": "- MaxCmdSN: the maximum number to be shipped. The queuing capacity of the receiving iSCSI layer is MaxCmdSN - ExpCmdSN + 1."
    },
    {
      "indent": 3,
      "text": "The initiator's ExpCmdSN and MaxCmdSN are derived from target-to-initiator PDU fields. Comparisons and arithmetic on the ExpCmdSN and MaxCmdSN MUST use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.",
      "zh-cn": "The initiator's ExpCmdSN and MaxCmdSN are derived from target-to-initiator PDU fields. Comparisons and arithmetic on the ExpCmdSN and MaxCmdSN MUST use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32."
    },
    {
      "indent": 3,
      "text": "The target MUST NOT transmit a MaxCmdSN that is less than ExpCmdSN - 1. For non-immediate commands, the CmdSN field can take any value from the ExpCmdSN to the MaxCmdSN inclusive. The target MUST silently ignore any non-immediate command outside of this range or non-immediate duplicates within the range. The CmdSN carried by immediate commands may lie outside the ExpCmdSN-to-MaxCmdSN range. For example, if the initiator has previously sent a non-immediate command carrying the CmdSN equal to the MaxCmdSN, the target window is closed. For group task management commands issued as immediate commands, the CmdSN indicates the scope of the group action (e.g., an ABORT TASK SET indicates which commands are to be aborted).",
      "zh-cn": "The target MUST NOT transmit a MaxCmdSN that is less than ExpCmdSN - 1. For non-immediate commands, the CmdSN field can take any value from the ExpCmdSN to the MaxCmdSN inclusive. The target MUST silently ignore any non-immediate command outside of this range or non-immediate duplicates within the range. The CmdSN carried by immediate commands may lie outside the ExpCmdSN-to-MaxCmdSN range. For example, if the initiator has previously sent a non-immediate command carrying the CmdSN equal to the MaxCmdSN, the target window is closed. For group task management commands issued as immediate commands, the CmdSN indicates the scope of the group action (e.g., an ABORT TASK SET indicates which commands are to be aborted)."
    },
    {
      "indent": 3,
      "text": "MaxCmdSN and ExpCmdSN fields are processed by the initiator as follows:",
      "zh-cn": "MaxCmdSN and ExpCmdSN fields are processed by the initiator as follows:"
    },
    {
      "indent": 6,
      "text": "- If the PDU MaxCmdSN is less than the PDU ExpCmdSN - 1 (in a Serial Number Arithmetic sense), they are both ignored.",
      "zh-cn": "- If the PDU MaxCmdSN is less than the PDU ExpCmdSN - 1 (in a Serial Number Arithmetic sense), they are both ignored."
    },
    {
      "indent": 6,
      "text": "- If the PDU MaxCmdSN is greater than the local MaxCmdSN (in a Serial Number Arithmetic sense), it updates the local MaxCmdSN; otherwise, it is ignored.",
      "zh-cn": "- If the PDU MaxCmdSN is greater than the local MaxCmdSN (in a Serial Number Arithmetic sense), it updates the local MaxCmdSN; otherwise, it is ignored."
    },
    {
      "indent": 6,
      "text": "- If the PDU ExpCmdSN is greater than the local ExpCmdSN (in a Serial Number Arithmetic sense), it updates the local ExpCmdSN; otherwise, it is ignored.",
      "zh-cn": "- If the PDU ExpCmdSN is greater than the local ExpCmdSN (in a Serial Number Arithmetic sense), it updates the local ExpCmdSN; otherwise, it is ignored."
    },
    {
      "indent": 3,
      "text": "This sequence is required because updates may arrive out of order (e.g., the updates are sent on different TCP connections).",
      "zh-cn": "This sequence is required because updates may arrive out of order (e.g., the updates are sent on different TCP connections)."
    },
    {
      "indent": 3,
      "text": "iSCSI initiators and targets MUST support the command numbering scheme.",
      "zh-cn": "iSCSI initiators and targets MUST support the command numbering scheme."
    },
    {
      "indent": 3,
      "text": "A numbered iSCSI request will not change its allocated CmdSN, regardless of the number of times and circumstances in which it is reissued (see Section 7.2.1). At the target, the CmdSN is only relevant while the command has not created any state related to its execution (execution state); afterwards, the CmdSN becomes irrelevant. Testing for the execution state (represented by identifying the Initiator Task Tag) MUST precede any other action at the target. If no execution state is found, it is followed by ordering and delivery. If an execution state is found, it is followed by delivery if it has not already been delivered.",
      "zh-cn": "A numbered iSCSI request will not change its allocated CmdSN, regardless of the number of times and circumstances in which it is reissued (see Section 7.2.1). At the target, the CmdSN is only relevant while the command has not created any state related to its execution (execution state); afterwards, the CmdSN becomes irrelevant. Testing for the execution state (represented by identifying the Initiator Task Tag) MUST precede any other action at the target. If no execution state is found, it is followed by ordering and delivery. If an execution state is found, it is followed by delivery if it has not already been delivered."
    },
    {
      "indent": 3,
      "text": "If an initiator issues a command retry for a command with CmdSN R on a connection when the session CmdSN value is Q, it MUST NOT advance the CmdSN past R + 2**31 - 1 unless",
      "zh-cn": "If an initiator issues a command retry for a command with CmdSN R on a connection when the session CmdSN value is Q, it MUST NOT advance the CmdSN past R + 2**31 - 1 unless"
    },
    {
      "indent": 6,
      "text": "- the connection is no longer operational (i.e., it has returned to the FREE state; see Section 8.1.3),",
      "zh-cn": "- the connection is no longer operational (i.e., it has returned to the FREE state; see Section 8.1.3),"
    },
    {
      "indent": 6,
      "text": "- the connection has been reinstated (see Section 6.3.4), or",
      "zh-cn": "- the connection has been reinstated (see Section 6.3.4), or"
    },
    {
      "indent": 6,
      "text": "- a non-immediate command with a CmdSN equal to or greater than Q was issued subsequent to the command retry on the same connection and the reception of that command is acknowledged by the target (see Section 10.4).",
      "zh-cn": "- a non-immediate command with a CmdSN equal to or greater than Q was issued subsequent to the command retry on the same connection and the reception of that command is acknowledged by the target (see Section 10.4)."
    },
    {
      "indent": 3,
      "text": "A target command response or Data-In PDU with status MUST NOT precede the command acknowledgment. However, the acknowledgment MAY be included in the response or the Data-In PDU.",
      "zh-cn": "A target command response or Data-In PDU with status MUST NOT precede the command acknowledgment. However, the acknowledgment MAY be included in the response or the Data-In PDU."
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Response/Status Numbering and Acknowledging",
      "section_title": true,
      "zh-cn": "4.2.2.2. Response/Status Numbering and Acknowledging"
    },
    {
      "indent": 3,
      "text": "Responses in transit from the target to the initiator are numbered. The StatSN (status sequence number) is used for this purpose. The StatSN is a counter maintained per connection. The ExpStatSN is used by the initiator to acknowledge status. The status sequence number space is 32-bit unsigned integers, and the arithmetic operations are the regular mod(2**32) arithmetic.",
      "zh-cn": "Responses in transit from the target to the initiator are numbered. The StatSN (status sequence number) is used for this purpose. The StatSN is a counter maintained per connection. The ExpStatSN is used by the initiator to acknowledge status. The status sequence number space is 32-bit unsigned integers, and the arithmetic operations are the regular mod(2**32) arithmetic."
    },
    {
      "indent": 3,
      "text": "Status numbering starts with the Login Response to the first Login Request of the connection. The Login Response includes an initial value for status numbering (any initial value is valid).",
      "zh-cn": "Status numbering starts with the Login Response to the first Login Request of the connection. The Login Response includes an initial value for status numbering (any initial value is valid)."
    },
    {
      "indent": 3,
      "text": "To enable command recovery, the target MAY maintain enough state information for data and status recovery after a connection failure. A target doing so can safely discard all of the state information maintained for recovery of a command after the delivery of the status for the command (numbered StatSN) is acknowledged through the ExpStatSN.",
      "zh-cn": "To enable command recovery, the target MAY maintain enough state information for data and status recovery after a connection failure. A target doing so can safely discard all of the state information maintained for recovery of a command after the delivery of the status for the command (numbered StatSN) is acknowledged through the ExpStatSN."
    },
    {
      "indent": 3,
      "text": "A large absolute difference between the StatSN and the ExpStatSN may indicate a failed connection. Initiators MUST undertake recovery actions if the difference is greater than an implementation-defined constant that MUST NOT exceed 2**31 - 1.",
      "zh-cn": "A large absolute difference between the StatSN and the ExpStatSN may indicate a failed connection. Initiators MUST undertake recovery actions if the difference is greater than an implementation-defined constant that MUST NOT exceed 2**31 - 1."
    },
    {
      "indent": 3,
      "text": "Initiators and targets MUST support the response-numbering scheme.",
      "zh-cn": "Initiators and targets MUST support the response-numbering scheme."
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Response Ordering",
      "section_title": true,
      "zh-cn": "4.2.2.3. Response Ordering"
    },
    {
      "indent": 0,
      "text": "4.2.2.3.1. Need for Response Ordering",
      "section_title": true,
      "zh-cn": "4.2.2.3.1. Need for Response Ordering"
    },
    {
      "indent": 3,
      "text": "Whenever an iSCSI session is composed of multiple connections, the Response PDUs (task responses or TMF Responses) originating in the target SCSI layer are distributed onto the multiple connections by the target iSCSI layer according to iSCSI connection allegiance rules. This process generally may not preserve the ordering of the responses by the time they are delivered to the initiator SCSI layer.",
      "zh-cn": "Whenever an iSCSI session is composed of multiple connections, the Response PDUs (task responses or TMF Responses) originating in the target SCSI layer are distributed onto the multiple connections by the target iSCSI layer according to iSCSI connection allegiance rules. This process generally may not preserve the ordering of the responses by the time they are delivered to the initiator SCSI layer."
    },
    {
      "indent": 3,
      "text": "Since ordering is not expected across SCSI Response PDUs anyway, this approach works fine in the general case. However, to address the special cases where some ordering is desired by the SCSI layer, we introduce the notion of a \"Response Fence\": a Response Fence is logically the attribute/property of a SCSI response message handed off to a target iSCSI layer that indicates that there are special SCSI-level ordering considerations associated with this particular response message. Whenever a Response Fence is set or required on a",
      "zh-cn": "Since ordering is not expected across SCSI Response PDUs anyway, this approach works fine in the general case. However, to address the special cases where some ordering is desired by the SCSI layer, we introduce the notion of a \"Response Fence\": a Response Fence is logically the attribute/property of a SCSI response message handed off to a target iSCSI layer that indicates that there are special SCSI-level ordering considerations associated with this particular response message. Whenever a Response Fence is set or required on a"
    },
    {
      "indent": 3,
      "text": "SCSI response message, we define the semantics in Section 4.2.2.3.2 with respect to the target iSCSI layer's handling of such SCSI response messages.",
      "zh-cn": "SCSI response message, we define the semantics in Section 4.2.2.3.2 with respect to the target iSCSI layer's handling of such SCSI response messages."
    },
    {
      "indent": 0,
      "text": "4.2.2.3.2. Response Ordering Model Description",
      "section_title": true,
      "zh-cn": "4.2.2.3.2. Response Ordering Model Description"
    },
    {
      "indent": 3,
      "text": "The target SCSI protocol layer hands off the SCSI response messages to the target iSCSI layer by invoking the \"Send Command Complete\" protocol data service ([SAM2], Clause 5.4.2) and \"Task Management Function Executed\" ([SAM2], Clause 6.9) service. On receiving the SCSI response message, the iSCSI layer exhibits the Response Fence behavior for certain SCSI response messages (Section 4.2.2.3.4 describes the specific instances where the semantics must be realized).",
      "zh-cn": "The target SCSI protocol layer hands off the SCSI response messages to the target iSCSI layer by invoking the \"Send Command Complete\" protocol data service ([SAM2], Clause 5.4.2) and \"Task Management Function Executed\" ([SAM2], Clause 6.9) service. On receiving the SCSI response message, the iSCSI layer exhibits the Response Fence behavior for certain SCSI response messages (Section 4.2.2.3.4 describes the specific instances where the semantics must be realized)."
    },
    {
      "indent": 3,
      "text": "Whenever the Response Fence behavior is required for a SCSI response message, the target iSCSI layer MUST ensure that the following conditions are met in delivering the response message to the initiator iSCSI layer:",
      "zh-cn": "Whenever the Response Fence behavior is required for a SCSI response message, the target iSCSI layer MUST ensure that the following conditions are met in delivering the response message to the initiator iSCSI layer:"
    },
    {
      "indent": 6,
      "text": "- A response with a Response Fence MUST be delivered chronologically after all the \"preceding\" responses on the I_T_L nexus, if the preceding responses are delivered at all, to the initiator iSCSI layer.",
      "zh-cn": "- A response with a Response Fence MUST be delivered chronologically after all the \"preceding\" responses on the I_T_L nexus, if the preceding responses are delivered at all, to the initiator iSCSI layer."
    },
    {
      "indent": 6,
      "text": "- A response with a Response Fence MUST be delivered chronologically prior to all the \"following\" responses on the I_T_L nexus.",
      "zh-cn": "- A response with a Response Fence MUST be delivered chronologically prior to all the \"following\" responses on the I_T_L nexus."
    },
    {
      "indent": 3,
      "text": "The notions of \"preceding\" and \"following\" refer to the order of handoff of a response message from the target SCSI protocol layer to the target iSCSI layer.",
      "zh-cn": "The notions of \"preceding\" and \"following\" refer to the order of handoff of a response message from the target SCSI protocol layer to the target iSCSI layer."
    },
    {
      "indent": 0,
      "text": "4.2.2.3.3. iSCSI Semantics with the Interface Model",
      "section_title": true,
      "zh-cn": "4.2.2.3.3. iSCSI Semantics with the Interface Model"
    },
    {
      "indent": 3,
      "text": "Whenever the TaskReporting key (Section 13.23) is negotiated to ResponseFence or FastAbort for an iSCSI session and the Response Fence behavior is required for a SCSI response message, the target iSCSI layer MUST perform the actions described in this section for that session.",
      "zh-cn": "Whenever the TaskReporting key (Section 13.23) is negotiated to ResponseFence or FastAbort for an iSCSI session and the Response Fence behavior is required for a SCSI response message, the target iSCSI layer MUST perform the actions described in this section for that session."
    },
    {
      "indent": 6,
      "text": "a) If it is a single-connection session, no special processing is required. The standard SCSI Response PDU build and dispatch process happens.",
      "zh-cn": "a) If it is a single-connection session, no special processing is required. The standard SCSI Response PDU build and dispatch process happens."
    },
    {
      "indent": 6,
      "text": "b) If it is a multi-connection session, the target iSCSI layer takes note of the last-sent and unacknowledged StatSN on each of the connections in the iSCSI session, and waits for an",
      "zh-cn": "b) If it is a multi-connection session, the target iSCSI layer takes note of the last-sent and unacknowledged StatSN on each of the connections in the iSCSI session, and waits for an"
    },
    {
      "indent": 9,
      "text": "acknowledgment (NOP-In PDUs MAY be used to solicit acknowledgments as needed in order to accelerate this process) of each such StatSN to clear the fence. The SCSI Response PDU requiring the Response Fence behavior MUST NOT be sent to the initiator before acknowledgments are received for each of the unacknowledged StatSNs.",
      "zh-cn": "acknowledgment (NOP-In PDUs MAY be used to solicit acknowledgments as needed in order to accelerate this process) of each such StatSN to clear the fence. The SCSI Response PDU requiring the Response Fence behavior MUST NOT be sent to the initiator before acknowledgments are received for each of the unacknowledged StatSNs."
    },
    {
      "indent": 6,
      "text": "c) The target iSCSI layer must wait for an acknowledgment of the SCSI Response PDU that carried the SCSI response requiring the Response Fence behavior. The fence MUST be considered cleared only after receiving the acknowledgment.",
      "zh-cn": "c) The target iSCSI layer must wait for an acknowledgment of the SCSI Response PDU that carried the SCSI response requiring the Response Fence behavior. The fence MUST be considered cleared only after receiving the acknowledgment."
    },
    {
      "indent": 6,
      "text": "d) All further status processing for the LU is resumed only after clearing the fence. If any new responses for the I_T_L nexus are received from the SCSI layer before the fence is cleared, those Response PDUs MUST be held and queued at the iSCSI layer until the fence is cleared.",
      "zh-cn": "d) All further status processing for the LU is resumed only after clearing the fence. If any new responses for the I_T_L nexus are received from the SCSI layer before the fence is cleared, those Response PDUs MUST be held and queued at the iSCSI layer until the fence is cleared."
    },
    {
      "indent": 0,
      "text": "4.2.2.3.4. Current List of Fenced Response Use Cases",
      "section_title": true,
      "zh-cn": "4.2.2.3.4. Current List of Fenced Response Use Cases"
    },
    {
      "indent": 3,
      "text": "This section lists the situations in which fenced response behavior is REQUIRED in iSCSI target implementations. Note that the following list is an exhaustive enumeration as currently identified -- it is expected that as SCSI protocol specifications evolve, the specifications will enumerate when response fencing is required on a case-by-case basis.",
      "zh-cn": "This section lists the situations in which fenced response behavior is REQUIRED in iSCSI target implementations. Note that the following list is an exhaustive enumeration as currently identified -- it is expected that as SCSI protocol specifications evolve, the specifications will enumerate when response fencing is required on a case-by-case basis."
    },
    {
      "indent": 3,
      "text": "Whenever the TaskReporting key (Section 13.23) is negotiated to ResponseFence or FastAbort for an iSCSI session, the target iSCSI layer MUST assume that the Response Fence is required for the following SCSI completion messages:",
      "zh-cn": "Whenever the TaskReporting key (Section 13.23) is negotiated to ResponseFence or FastAbort for an iSCSI session, the target iSCSI layer MUST assume that the Response Fence is required for the following SCSI completion messages:"
    },
    {
      "indent": 6,
      "text": "a) The first completion message carrying the UA after the multi-task abort on issuing and third-party sessions. See Section 4.2.3.2 for related TMF discussion.",
      "zh-cn": "a) The first completion message carrying the UA after the multi-task abort on issuing and third-party sessions. See Section 4.2.3.2 for related TMF discussion."
    },
    {
      "indent": 6,
      "text": "b) The TMF Response carrying the multi-task TMF Response on the issuing session.",
      "zh-cn": "b) The TMF Response carrying the multi-task TMF Response on the issuing session."
    },
    {
      "indent": 6,
      "text": "c) The completion message indicating ACA establishment on the issuing session.",
      "zh-cn": "c) The completion message indicating ACA establishment on the issuing session."
    },
    {
      "indent": 6,
      "text": "d) The first completion message carrying the ACA ACTIVE status after ACA establishment on issuing and third-party sessions.",
      "zh-cn": "d) The first completion message carrying the ACA ACTIVE status after ACA establishment on issuing and third-party sessions."
    },
    {
      "indent": 6,
      "text": "e) The TMF Response carrying the CLEAR ACA response on the issuing session.",
      "zh-cn": "e) The TMF Response carrying the CLEAR ACA response on the issuing session."
    },
    {
      "indent": 6,
      "text": "f) The response to a PERSISTENT RESERVE OUT/PREEMPT AND ABORT command.",
      "zh-cn": "f) The response to a PERSISTENT RESERVE OUT/PREEMPT AND ABORT command."
    },
    {
      "indent": 3,
      "text": "Notes:",
      "zh-cn": "Notes:"
    },
    {
      "indent": 6,
      "text": "- Due to the absence of ACA-related fencing requirements in [RFC3720], initiator implementations SHOULD NOT use ACA on multi-connection iSCSI sessions with targets complying only with [RFC3720]. This can be determined via TaskReporting key (Section 13.23) negotiation -- when the negotiation results in either \"RFC3720\" or \"NotUnderstood\".",
      "zh-cn": "- Due to the absence of ACA-related fencing requirements in [RFC3720], initiator implementations SHOULD NOT use ACA on multi-connection iSCSI sessions with targets complying only with [RFC3720]. This can be determined via TaskReporting key (Section 13.23) negotiation -- when the negotiation results in either \"RFC3720\" or \"NotUnderstood\"."
    },
    {
      "indent": 6,
      "text": "- Initiators that want to employ ACA on multi-connection iSCSI sessions SHOULD first assess response-fencing behavior via negotiating for the \"ResponseFence\" or \"FastAbort\" value for the TaskReporting (Section 13.23) key.",
      "zh-cn": "- Initiators that want to employ ACA on multi-connection iSCSI sessions SHOULD first assess response-fencing behavior via negotiating for the \"ResponseFence\" or \"FastAbort\" value for the TaskReporting (Section 13.23) key."
    },
    {
      "indent": 0,
      "text": "4.2.2.4. Data Sequencing",
      "section_title": true,
      "zh-cn": "4.2.2.4. Data Sequencing"
    },
    {
      "indent": 3,
      "text": "Data and R2T PDUs transferred as part of some command execution MUST be sequenced. The DataSN field is used for data sequencing. For input (read) data PDUs, the DataSN starts with 0 for the first data PDU of an input command and advances by 1 for each subsequent data PDU. For output data PDUs, the DataSN starts with 0 for the first data PDU of a sequence (the initial unsolicited sequence or any data PDU sequence issued to satisfy an R2T) and advances by 1 for each subsequent data PDU. R2Ts are also sequenced per command. For example, the first R2T has an R2TSN of 0 and advances by 1 for each subsequent R2T. For bidirectional commands, the target uses the DataSN/R2TSN to sequence Data-In and R2T PDUs in one continuous sequence (undifferentiated). Unlike command and status, data PDUs and R2Ts are not acknowledged by a field in regular outgoing PDUs. Data-In PDUs can be acknowledged on demand by a special form of the SNACK PDU. Data and R2T PDUs are implicitly acknowledged by status for the command. The DataSN/R2TSN field enables the initiator to detect missing data or R2T PDUs.",
      "zh-cn": "Data and R2T PDUs transferred as part of some command execution MUST be sequenced. The DataSN field is used for data sequencing. For input (read) data PDUs, the DataSN starts with 0 for the first data PDU of an input command and advances by 1 for each subsequent data PDU. For output data PDUs, the DataSN starts with 0 for the first data PDU of a sequence (the initial unsolicited sequence or any data PDU sequence issued to satisfy an R2T) and advances by 1 for each subsequent data PDU. R2Ts are also sequenced per command. For example, the first R2T has an R2TSN of 0 and advances by 1 for each subsequent R2T. For bidirectional commands, the target uses the DataSN/R2TSN to sequence Data-In and R2T PDUs in one continuous sequence (undifferentiated). Unlike command and status, data PDUs and R2Ts are not acknowledged by a field in regular outgoing PDUs. Data-In PDUs can be acknowledged on demand by a special form of the SNACK PDU. Data and R2T PDUs are implicitly acknowledged by status for the command. The DataSN/R2TSN field enables the initiator to detect missing data or R2T PDUs."
    },
    {
      "indent": 3,
      "text": "For any read or bidirectional command, a target MUST issue less than 2**32 combined R2T and Data-In PDUs. Any output data sequence MUST contain less than 2**32 Data-Out PDUs.",
      "zh-cn": "For any read or bidirectional command, a target MUST issue less than 2**32 combined R2T and Data-In PDUs. Any output data sequence MUST contain less than 2**32 Data-Out PDUs."
    },
    {
      "indent": 0,
      "text": "4.2.3. iSCSI Task Management",
      "section_title": true,
      "zh-cn": "4.2.3. iSCSI Task Management"
    },
    {
      "indent": 0,
      "text": "4.2.3.1. Task Management Overview",
      "section_title": true,
      "zh-cn": "4.2.3.1. Task Management Overview"
    },
    {
      "indent": 3,
      "text": "iSCSI task management features allow an initiator to control the active iSCSI tasks on an operational iSCSI session that it has with an iSCSI target. Section 11.5 defines the task management function types that this specification defines -- ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, TARGET COLD RESET, and TASK REASSIGN.",
      "zh-cn": "iSCSI task management features allow an initiator to control the active iSCSI tasks on an operational iSCSI session that it has with an iSCSI target. Section 11.5 defines the task management function types that this specification defines -- ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, TARGET COLD RESET, and TASK REASSIGN."
    },
    {
      "indent": 3,
      "text": "Out of these function types, ABORT TASK and TASK REASSIGN functions manage a single active task, whereas ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET functions can each potentially affect multiple active tasks.",
      "zh-cn": "Out of these function types, ABORT TASK and TASK REASSIGN functions manage a single active task, whereas ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET functions can each potentially affect multiple active tasks."
    },
    {
      "indent": 0,
      "text": "4.2.3.2. Notion of Affected Tasks",
      "section_title": true,
      "zh-cn": "4.2.3.2. Notion of Affected Tasks"
    },
    {
      "indent": 3,
      "text": "This section defines the notion of \"affected tasks\" in multi-task abort scenarios. Scope definitions in this section apply to both the standard multi-task abort semantics (Section 4.2.3.3) and the FastAbort multi-task abort semantics behavior (Section 4.2.3.4).",
      "zh-cn": "This section defines the notion of \"affected tasks\" in multi-task abort scenarios. Scope definitions in this section apply to both the standard multi-task abort semantics (Section 4.2.3.3) and the FastAbort multi-task abort semantics behavior (Section 4.2.3.4)."
    },
    {
      "indent": 3,
      "text": "ABORT TASK SET: All outstanding tasks for the I_T_L nexus identified by the LUN field in the ABORT TASK SET TMF Request PDU.",
      "zh-cn": "ABORT TASK SET: All outstanding tasks for the I_T_L nexus identified by the LUN field in the ABORT TASK SET TMF Request PDU."
    },
    {
      "indent": 3,
      "text": "CLEAR TASK SET: All outstanding tasks in the task set for the LU identified by the LUN field in the CLEAR TASK SET TMF Request PDU. See [SPC3] for the definition of a \"task set\".",
      "zh-cn": "CLEAR TASK SET: All outstanding tasks in the task set for the LU identified by the LUN field in the CLEAR TASK SET TMF Request PDU. See [SPC3] for the definition of a \"task set\"."
    },
    {
      "indent": 3,
      "text": "LOGICAL UNIT RESET: All outstanding tasks from all initiators for the LU identified by the LUN field in the LOGICAL UNIT RESET Request PDU.",
      "zh-cn": "LOGICAL UNIT RESET: All outstanding tasks from all initiators for the LU identified by the LUN field in the LOGICAL UNIT RESET Request PDU."
    },
    {
      "indent": 3,
      "text": "TARGET WARM RESET/TARGET COLD RESET: All outstanding tasks from all initiators across all LUs to which the TMF-issuing session has access on the SCSI target device hosting the iSCSI session.",
      "zh-cn": "TARGET WARM RESET/TARGET COLD RESET: All outstanding tasks from all initiators across all LUs to which the TMF-issuing session has access on the SCSI target device hosting the iSCSI session."
    },
    {
      "indent": 3,
      "text": "Usage: An \"ABORT TASK SET TMF Request PDU\" in the preceding text is an iSCSI TMF Request PDU with the \"Function\" field set to \"ABORT TASK SET\" as defined in Section 11.5. Similar usage is employed for other scope descriptions.",
      "zh-cn": "Usage: An \"ABORT TASK SET TMF Request PDU\" in the preceding text is an iSCSI TMF Request PDU with the \"Function\" field set to \"ABORT TASK SET\" as defined in Section 11.5. Similar usage is employed for other scope descriptions."
    },
    {
      "indent": 0,
      "text": "4.2.3.3. Standard Multi-Task Abort Semantics",
      "section_title": true,
      "zh-cn": "4.2.3.3. Standard Multi-Task Abort Semantics"
    },
    {
      "indent": 3,
      "text": "All iSCSI implementations MUST support the protocol behavior defined in this section as the default behavior. The execution of ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET TMF Requests consists of the following sequence of actions in the specified order on the specified party.",
      "zh-cn": "All iSCSI implementations MUST support the protocol behavior defined in this section as the default behavior. The execution of ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET TMF Requests consists of the following sequence of actions in the specified order on the specified party."
    },
    {
      "indent": 3,
      "text": "The initiator iSCSI layer:",
      "zh-cn": "The initiator iSCSI layer:"
    },
    {
      "indent": 6,
      "text": "a) MUST continue to respond to each TTT received for the affected tasks.",
      "zh-cn": "a) MUST continue to respond to each TTT received for the affected tasks."
    },
    {
      "indent": 6,
      "text": "b) SHOULD process any responses received for affected tasks in the normal fashion. This is acceptable because the responses are guaranteed to have been sent prior to the TMF Response.",
      "zh-cn": "b) SHOULD process any responses received for affected tasks in the normal fashion. This is acceptable because the responses are guaranteed to have been sent prior to the TMF Response."
    },
    {
      "indent": 6,
      "text": "c) SHOULD receive the TMF Response concluding all the tasks in the set of affected tasks, unless the initiator has done something (e.g., LU reset, connection drop) that may prevent the TMF Response from being sent or received. The initiator MUST thus conclude all affected tasks as part of this step in either case and MUST discard any TMF Response received after the affected tasks are concluded.",
      "zh-cn": "c) SHOULD receive the TMF Response concluding all the tasks in the set of affected tasks, unless the initiator has done something (e.g., LU reset, connection drop) that may prevent the TMF Response from being sent or received. The initiator MUST thus conclude all affected tasks as part of this step in either case and MUST discard any TMF Response received after the affected tasks are concluded."
    },
    {
      "indent": 3,
      "text": "The target iSCSI layer:",
      "zh-cn": "The target iSCSI layer:"
    },
    {
      "indent": 6,
      "text": "a) MUST wait for responses on currently valid Target Transfer Tags of the affected tasks from the issuing initiator. MAY wait for responses on currently valid Target Transfer Tags of the affected tasks from third-party initiators.",
      "zh-cn": "a) MUST wait for responses on currently valid Target Transfer Tags of the affected tasks from the issuing initiator. MAY wait for responses on currently valid Target Transfer Tags of the affected tasks from third-party initiators."
    },
    {
      "indent": 6,
      "text": "b) MUST wait (concurrent with the wait in Step a) for all commands of the affected tasks to be received based on the CmdSN ordering. SHOULD NOT wait for new commands on third-party affected sessions -- only the instantiated tasks have to be considered for the purpose of determining the affected tasks. However, in the case of target-scoped requests (i.e., TARGET WARM RESET and TARGET COLD RESET), all of the commands that are not yet received on the issuing session in the command stream can be considered to have been received with no command waiting period -- i.e., the entire CmdSN space up to the CmdSN of the task management function can be \"plugged\".",
      "zh-cn": "b) MUST wait (concurrent with the wait in Step a) for all commands of the affected tasks to be received based on the CmdSN ordering. SHOULD NOT wait for new commands on third-party affected sessions -- only the instantiated tasks have to be considered for the purpose of determining the affected tasks. However, in the case of target-scoped requests (i.e., TARGET WARM RESET and TARGET COLD RESET), all of the commands that are not yet received on the issuing session in the command stream can be considered to have been received with no command waiting period -- i.e., the entire CmdSN space up to the CmdSN of the task management function can be \"plugged\"."
    },
    {
      "indent": 6,
      "text": "c) MUST propagate the TMF Request to, and receive the response from, the target SCSI layer.",
      "zh-cn": "c) MUST propagate the TMF Request to, and receive the response from, the target SCSI layer."
    },
    {
      "indent": 6,
      "text": "d) MUST provide the Response Fence behavior for the TMF Response on the issuing session as specified in Section 4.2.2.3.2.",
      "zh-cn": "d) MUST provide the Response Fence behavior for the TMF Response on the issuing session as specified in Section 4.2.2.3.2."
    },
    {
      "indent": 6,
      "text": "e) MUST provide the Response Fence behavior on the first post-TMF Response on third-party sessions as specified in Section 4.2.2.3.3. If some tasks originate from non-iSCSI I_T_L nexuses, then the means by which the target ensures that all affected tasks have returned their status to the initiator are defined by the specific non-iSCSI transport protocol(s).",
      "zh-cn": "e) MUST provide the Response Fence behavior on the first post-TMF Response on third-party sessions as specified in Section 4.2.2.3.3. If some tasks originate from non-iSCSI I_T_L nexuses, then the means by which the target ensures that all affected tasks have returned their status to the initiator are defined by the specific non-iSCSI transport protocol(s)."
    },
    {
      "indent": 3,
      "text": "Technically, the TMF servicing is complete in Step d). Data transfers corresponding to terminated tasks may, however, still be in progress on third-party iSCSI sessions even at the end of Step e). The TMF Response MUST NOT be sent by the target iSCSI layer before the end of Step d) and MAY be sent at the end of Step d) despite these outstanding data transfers until after Step e).",
      "zh-cn": "Technically, the TMF servicing is complete in Step d). Data transfers corresponding to terminated tasks may, however, still be in progress on third-party iSCSI sessions even at the end of Step e). The TMF Response MUST NOT be sent by the target iSCSI layer before the end of Step d) and MAY be sent at the end of Step d) despite these outstanding data transfers until after Step e)."
    },
    {
      "indent": 0,
      "text": "4.2.3.4. FastAbort Multi-Task Abort Semantics",
      "section_title": true,
      "zh-cn": "4.2.3.4. FastAbort Multi-Task Abort Semantics"
    },
    {
      "indent": 3,
      "text": "Protocol behavior defined in this section SHOULD be implemented by all iSCSI implementations complying with this document, noting that some steps below may not be compatible with [RFC3720] semantics. However, protocol behavior defined in this section MUST be exhibited by iSCSI implementations on an iSCSI session when they negotiate the TaskReporting (Section 13.23) key to \"FastAbort\" on that session. The execution of ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET TMF Requests consists of the following sequence of actions in the specified order on the specified party.",
      "zh-cn": "Protocol behavior defined in this section SHOULD be implemented by all iSCSI implementations complying with this document, noting that some steps below may not be compatible with [RFC3720] semantics. However, protocol behavior defined in this section MUST be exhibited by iSCSI implementations on an iSCSI session when they negotiate the TaskReporting (Section 13.23) key to \"FastAbort\" on that session. The execution of ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET TMF Requests consists of the following sequence of actions in the specified order on the specified party."
    },
    {
      "indent": 3,
      "text": "The initiator iSCSI layer:",
      "zh-cn": "The initiator iSCSI layer:"
    },
    {
      "indent": 6,
      "text": "a) MUST NOT send any more Data-Out PDUs for affected tasks on the issuing connection of the issuing iSCSI session once the TMF is sent to the target.",
      "zh-cn": "a) MUST NOT send any more Data-Out PDUs for affected tasks on the issuing connection of the issuing iSCSI session once the TMF is sent to the target."
    },
    {
      "indent": 6,
      "text": "b) SHOULD process any responses received for affected tasks in the normal fashion. This is acceptable because the responses are guaranteed to have been sent prior to the TMF Response.",
      "zh-cn": "b) SHOULD process any responses received for affected tasks in the normal fashion. This is acceptable because the responses are guaranteed to have been sent prior to the TMF Response."
    },
    {
      "indent": 6,
      "text": "c) MUST respond to each Async Message PDU with a Task Termination AsyncEvent (5) as defined in Section 11.9.",
      "zh-cn": "c) MUST respond to each Async Message PDU with a Task Termination AsyncEvent (5) as defined in Section 11.9."
    },
    {
      "indent": 6,
      "text": "d) MUST treat the TMF Response as terminating all affected tasks for which responses have not been received and MUST discard any responses for affected tasks received after the TMF Response is passed to the SCSI layer (although the semantics defined in this section ensure that such an out-of-order scenario will never happen with a compliant target implementation).",
      "zh-cn": "d) MUST treat the TMF Response as terminating all affected tasks for which responses have not been received and MUST discard any responses for affected tasks received after the TMF Response is passed to the SCSI layer (although the semantics defined in this section ensure that such an out-of-order scenario will never happen with a compliant target implementation)."
    },
    {
      "indent": 3,
      "text": "The target iSCSI layer:",
      "zh-cn": "The target iSCSI layer:"
    },
    {
      "indent": 6,
      "text": "a) MUST wait for all commands of the affected tasks to be received based on the CmdSN ordering on the issuing session. SHOULD NOT wait for new commands on third-party affected sessions -- only the instantiated tasks have to be considered for the purpose of determining the affected tasks. In the case of target-scoped requests (i.e., TARGET WARM RESET and TARGET COLD RESET), all the commands that are not yet received on the issuing session in the command stream can be considered to have been received with no command waiting period -- i.e., the entire CmdSN space up to the CmdSN of the task management function can be \"plugged\".",
      "zh-cn": "a) MUST wait for all commands of the affected tasks to be received based on the CmdSN ordering on the issuing session. SHOULD NOT wait for new commands on third-party affected sessions -- only the instantiated tasks have to be considered for the purpose of determining the affected tasks. In the case of target-scoped requests (i.e., TARGET WARM RESET and TARGET COLD RESET), all the commands that are not yet received on the issuing session in the command stream can be considered to have been received with no command waiting period -- i.e., the entire CmdSN space up to the CmdSN of the task management function can be \"plugged\"."
    },
    {
      "indent": 6,
      "text": "b) MUST propagate the TMF Request to, and receive the response from, the target SCSI layer.",
      "zh-cn": "b) MUST propagate the TMF Request to, and receive the response from, the target SCSI layer."
    },
    {
      "indent": 6,
      "text": "c) MUST leave all active \"affected TTTs\" (i.e., active TTTs associated with affected tasks) valid.",
      "zh-cn": "c) MUST leave all active \"affected TTTs\" (i.e., active TTTs associated with affected tasks) valid."
    },
    {
      "indent": 6,
      "text": "d) MUST send an Asynchronous Message PDU with AsyncEvent=5 (Section 11.9) on:",
      "zh-cn": "d) MUST send an Asynchronous Message PDU with AsyncEvent=5 (Section 11.9) on:"
    },
    {
      "indent": 9,
      "text": "1) each connection of each third-party session to which at least one affected task is allegiant if TaskReporting=FastAbort is operational on that third-party session, and",
      "zh-cn": "1) each connection of each third-party session to which at least one affected task is allegiant if TaskReporting=FastAbort is operational on that third-party session, and"
    },
    {
      "indent": 9,
      "text": "2) each connection except the issuing connection of the issuing session that has at least one allegiant affected task.",
      "zh-cn": "2) each connection except the issuing connection of the issuing session that has at least one allegiant affected task."
    },
    {
      "indent": 12,
      "text": "If there are multiple affected LUs (say, due to a target reset), then one Async Message PDU MUST be sent for each such LU on each connection that has at least one allegiant affected task. The LUN field in the Asynchronous Message PDU MUST be set to match the LUN for each such LU.",
      "zh-cn": "If there are multiple affected LUs (say, due to a target reset), then one Async Message PDU MUST be sent for each such LU on each connection that has at least one allegiant affected task. The LUN field in the Asynchronous Message PDU MUST be set to match the LUN for each such LU."
    },
    {
      "indent": 6,
      "text": "e) MUST address the Response Fence flag on the TMF Response on the issuing session as defined in Section 4.2.2.3.3.",
      "zh-cn": "e) MUST address the Response Fence flag on the TMF Response on the issuing session as defined in Section 4.2.2.3.3."
    },
    {
      "indent": 6,
      "text": "f) MUST address the Response Fence flag on the first post-TMF Response on third-party sessions as defined in Section 4.2.2.3.3. If some tasks originate from non-iSCSI I_T_L nexuses, then the means by which the target ensures that all affected tasks have returned their status to the initiator are defined by the specific non-iSCSI transport protocol(s).",
      "zh-cn": "f) MUST address the Response Fence flag on the first post-TMF Response on third-party sessions as defined in Section 4.2.2.3.3. If some tasks originate from non-iSCSI I_T_L nexuses, then the means by which the target ensures that all affected tasks have returned their status to the initiator are defined by the specific non-iSCSI transport protocol(s)."
    },
    {
      "indent": 6,
      "text": "g) MUST free up the affected TTTs (and STags for iSER, if applicable) and the corresponding buffers, if any, once it receives each associated NOP-Out acknowledgment that the initiator generated in response to each Async Message.",
      "zh-cn": "g) MUST free up the affected TTTs (and STags for iSER, if applicable) and the corresponding buffers, if any, once it receives each associated NOP-Out acknowledgment that the initiator generated in response to each Async Message."
    },
    {
      "indent": 3,
      "text": "Technically, the TMF servicing is complete in Step e). Data transfers corresponding to terminated tasks may, however, still be in progress even at the end of Step f). A TMF Response MUST NOT be sent by the target iSCSI layer before the end of Step e) and MAY be sent at the end of Step e) despite these outstanding Data transfers until Step g). Step g) specifies an event to free up any such resources that may have been reserved to support outstanding data transfers.",
      "zh-cn": "Technically, the TMF servicing is complete in Step e). Data transfers corresponding to terminated tasks may, however, still be in progress even at the end of Step f). A TMF Response MUST NOT be sent by the target iSCSI layer before the end of Step e) and MAY be sent at the end of Step e) despite these outstanding Data transfers until Step g). Step g) specifies an event to free up any such resources that may have been reserved to support outstanding data transfers."
    },
    {
      "indent": 0,
      "text": "4.2.3.5. Affected Tasks Shared across Standard and FastAbort Sessions",
      "section_title": true,
      "zh-cn": "4.2.3.5. Affected Tasks Shared across Standard and FastAbort Sessions"
    },
    {
      "indent": 3,
      "text": "If an iSCSI target implementation is capable of supporting TaskReporting=FastAbort functionality (Section 13.23), it may end up in a situation where some sessions have TaskReporting=RFC3720 operational (RFC 3720 sessions) while some other sessions have TaskReporting=FastAbort operational (FastAbort sessions) even while accessing a shared set of affected tasks (Section 4.2.3.2). If the issuing session is an RFC 3720 session, the iSCSI target implementation is FastAbort-capable, and the third-party affected session is a FastAbort session, the following behavior SHOULD be exhibited by the iSCSI target layer:",
      "zh-cn": "If an iSCSI target implementation is capable of supporting TaskReporting=FastAbort functionality (Section 13.23), it may end up in a situation where some sessions have TaskReporting=RFC3720 operational (RFC 3720 sessions) while some other sessions have TaskReporting=FastAbort operational (FastAbort sessions) even while accessing a shared set of affected tasks (Section 4.2.3.2). If the issuing session is an RFC 3720 session, the iSCSI target implementation is FastAbort-capable, and the third-party affected session is a FastAbort session, the following behavior SHOULD be exhibited by the iSCSI target layer:"
    },
    {
      "indent": 6,
      "text": "a) Between Steps c) and d) of the target behavior in Section 4.2.3.3, send an Asynchronous Message PDU with AsyncEvent=5 (Section 11.9) on each connection of each third-party session to which at least one affected task is allegiant. If there are multiple affected LUs, then send one Async Message PDU for each such LU on each connection that has at least one allegiant affected task. When sent, the LUN field in the Asynchronous Message PDU MUST be set to match the LUN for each such LU.",
      "zh-cn": "a) Between Steps c) and d) of the target behavior in Section 4.2.3.3, send an Asynchronous Message PDU with AsyncEvent=5 (Section 11.9) on each connection of each third-party session to which at least one affected task is allegiant. If there are multiple affected LUs, then send one Async Message PDU for each such LU on each connection that has at least one allegiant affected task. When sent, the LUN field in the Asynchronous Message PDU MUST be set to match the LUN for each such LU."
    },
    {
      "indent": 6,
      "text": "b) After Step e) of the target behavior in Section 4.2.3.3, free up the affected TTTs (and STags for iSER, if applicable) and the corresponding buffers, if any, once each associated NOP-Out acknowledgment is received that the third-party initiator generated in response to each Async Message sent in Step a).",
      "zh-cn": "b) After Step e) of the target behavior in Section 4.2.3.3, free up the affected TTTs (and STags for iSER, if applicable) and the corresponding buffers, if any, once each associated NOP-Out acknowledgment is received that the third-party initiator generated in response to each Async Message sent in Step a)."
    },
    {
      "indent": 3,
      "text": "If the issuing session is a FastAbort session, the iSCSI target implementation is FastAbort-capable, and the third-party affected session is an RFC 3720 session, the iSCSI target layer MUST NOT send Asynchronous Message PDUs on the third-party session to prompt the FastAbort behavior.",
      "zh-cn": "If the issuing session is a FastAbort session, the iSCSI target implementation is FastAbort-capable, and the third-party affected session is an RFC 3720 session, the iSCSI target layer MUST NOT send Asynchronous Message PDUs on the third-party session to prompt the FastAbort behavior."
    },
    {
      "indent": 3,
      "text": "If the third-party affected session is a FastAbort session and the issuing session is a FastAbort session, the initiator in the third-party role MUST respond to each Async Message PDU with AsyncEvent=5 as defined in Section 11.9. Note that an initiator MAY thus receive these Async Messages on a third-party affected session even if the session is a single-connection session.",
      "zh-cn": "If the third-party affected session is a FastAbort session and the issuing session is a FastAbort session, the initiator in the third-party role MUST respond to each Async Message PDU with AsyncEvent=5 as defined in Section 11.9. Note that an initiator MAY thus receive these Async Messages on a third-party affected session even if the session is a single-connection session."
    },
    {
      "indent": 0,
      "text": "4.2.3.6. Rationale behind the FastAbort Semantics",
      "section_title": true,
      "zh-cn": "4.2.3.6. Rationale behind the FastAbort Semantics"
    },
    {
      "indent": 3,
      "text": "There are fundamentally three basic objectives behind the semantics specified in Sections 4.2.3.3 and 4.2.3.4.",
      "zh-cn": "There are fundamentally three basic objectives behind the semantics specified in Sections 4.2.3.3 and 4.2.3.4."
    },
    {
      "indent": 6,
      "text": "a) Maintaining an ordered command flow I_T nexus abstraction to the target SCSI layer even with multi-connection sessions.",
      "zh-cn": "a) Maintaining an ordered command flow I_T nexus abstraction to the target SCSI layer even with multi-connection sessions."
    },
    {
      "indent": 9,
      "text": "- Target iSCSI processing of a TMF Request must maintain the single flow illusion. The target behavior in Step b) of Section 4.2.3.3 and the target behavior in Step a) of Section 4.2.3.4 correspond to this objective.",
      "zh-cn": "- Target iSCSI processing of a TMF Request must maintain the single flow illusion. The target behavior in Step b) of Section 4.2.3.3 and the target behavior in Step a) of Section 4.2.3.4 correspond to this objective."
    },
    {
      "indent": 6,
      "text": "b) Maintaining a single ordered response flow I_T nexus abstraction to the initiator SCSI layer even with multi-connection sessions when one response (i.e., TMF Response) could imply the status of other unfinished tasks from the initiator's perspective.",
      "zh-cn": "b) Maintaining a single ordered response flow I_T nexus abstraction to the initiator SCSI layer even with multi-connection sessions when one response (i.e., TMF Response) could imply the status of other unfinished tasks from the initiator's perspective."
    },
    {
      "indent": 9,
      "text": "- The target must ensure that the initiator does not see \"old\" task responses (that were placed on the wire chronologically earlier than the TMF Response) after seeing the TMF Response. The target behavior in Step d) of Section 4.2.3.3 and the target behavior in Step e) of Section 4.2.3.4 correspond to this objective.",
      "zh-cn": "- The target must ensure that the initiator does not see \"old\" task responses (that were placed on the wire chronologically earlier than the TMF Response) after seeing the TMF Response. The target behavior in Step d) of Section 4.2.3.3 and the target behavior in Step e) of Section 4.2.3.4 correspond to this objective."
    },
    {
      "indent": 9,
      "text": "- Whenever the result of a TMF action is visible across multiple I_T_L nexuses, [SAM2] requires the SCSI device server to trigger a UA on each of the other I_T_L nexuses. Once an initiator is notified of such a UA, the application client on the receiving initiator is required to clear its task state (Clause 5.5 of [SAM2]) for the affected tasks. It would thus be inappropriate to deliver a SCSI Response for a task after the task state is cleared on the initiator, i.e., after the UA is notified. The UA notification contained in",
      "zh-cn": "- Whenever the result of a TMF action is visible across multiple I_T_L nexuses, [SAM2] requires the SCSI device server to trigger a UA on each of the other I_T_L nexuses. Once an initiator is notified of such a UA, the application client on the receiving initiator is required to clear its task state (Clause 5.5 of [SAM2]) for the affected tasks. It would thus be inappropriate to deliver a SCSI Response for a task after the task state is cleared on the initiator, i.e., after the UA is notified. The UA notification contained in"
    },
    {
      "indent": 11,
      "text": "the first SCSI Response PDU on each affected third-party I_T_L nexus after the TMF action thus MUST NOT pass the affected task responses on any of the iSCSI sessions accessing the LU. The target behavior in Step e) of Section 4.2.3.3 and the target behavior in Step f) of Section 4.2.3.4 correspond to this objective.",
      "zh-cn": "the first SCSI Response PDU on each affected third-party I_T_L nexus after the TMF action thus MUST NOT pass the affected task responses on any of the iSCSI sessions accessing the LU. The target behavior in Step e) of Section 4.2.3.3 and the target behavior in Step f) of Section 4.2.3.4 correspond to this objective."
    },
    {
      "indent": 6,
      "text": "c) Draining all active TTTs corresponding to affected tasks in a deterministic fashion.",
      "zh-cn": "c) Draining all active TTTs corresponding to affected tasks in a deterministic fashion."
    },
    {
      "indent": 9,
      "text": "- Data-Out PDUs with stale TTTs arriving after the tasks are terminated can create a buffer management problem even for traditional iSCSI implementations and is fatal for the connection for iSCSI/iSER implementations. Either the termination of affected tasks should be postponed until the TTTs are retired (as in Step a) of Section 4.2.3.3), or the TTTs and the buffers should stay allocated beyond task termination to be deterministically freed up later (as in Steps c) and g) of Section 4.2.3.4).",
      "zh-cn": "- Data-Out PDUs with stale TTTs arriving after the tasks are terminated can create a buffer management problem even for traditional iSCSI implementations and is fatal for the connection for iSCSI/iSER implementations. Either the termination of affected tasks should be postponed until the TTTs are retired (as in Step a) of Section 4.2.3.3), or the TTTs and the buffers should stay allocated beyond task termination to be deterministically freed up later (as in Steps c) and g) of Section 4.2.3.4)."
    },
    {
      "indent": 3,
      "text": "The only other notable optimization is the plugging. If all tasks on an I_T nexus will be aborted anyway (as with a target reset), there is no need to wait to receive all commands to plug the CmdSN holes. The target iSCSI layer can simply plug all missing CmdSN slots and move on with TMF processing. The first objective (maintaining a single ordered command flow) is still met with this optimization because the target SCSI layer only sees ordered commands.",
      "zh-cn": "The only other notable optimization is the plugging. If all tasks on an I_T nexus will be aborted anyway (as with a target reset), there is no need to wait to receive all commands to plug the CmdSN holes. The target iSCSI layer can simply plug all missing CmdSN slots and move on with TMF processing. The first objective (maintaining a single ordered command flow) is still met with this optimization because the target SCSI layer only sees ordered commands."
    },
    {
      "indent": 0,
      "text": "4.2.4. iSCSI Login",
      "section_title": true,
      "zh-cn": "4.2.4. iSCSI Login"
    },
    {
      "indent": 3,
      "text": "The purpose of the iSCSI login is to enable a TCP connection for iSCSI use, authentication of the parties, negotiation of the session's parameters, and marking of the connection as belonging to an iSCSI session.",
      "zh-cn": "The purpose of the iSCSI login is to enable a TCP connection for iSCSI use, authentication of the parties, negotiation of the session's parameters, and marking of the connection as belonging to an iSCSI session."
    },
    {
      "indent": 3,
      "text": "A session is used to identify to a target all the connections with a given initiator that belong to the same I_T nexus. (For more details on how a session relates to an I_T nexus, see Section 4.4.2.)",
      "zh-cn": "A session is used to identify to a target all the connections with a given initiator that belong to the same I_T nexus. (For more details on how a session relates to an I_T nexus, see Section 4.4.2.)"
    },
    {
      "indent": 3,
      "text": "The targets listen on a well-known TCP port or other TCP port for incoming connections. The initiator begins the login process by connecting to one of these TCP ports.",
      "zh-cn": "The targets listen on a well-known TCP port or other TCP port for incoming connections. The initiator begins the login process by connecting to one of these TCP ports."
    },
    {
      "indent": 3,
      "text": "As part of the login process, the initiator and target SHOULD authenticate each other and MAY set a security association protocol for the session. This can occur in many different ways and is subject to negotiation; see Section 12.",
      "zh-cn": "As part of the login process, the initiator and target SHOULD authenticate each other and MAY set a security association protocol for the session. This can occur in many different ways and is subject to negotiation; see Section 12."
    },
    {
      "indent": 3,
      "text": "To protect the TCP connection, an IPsec security association MAY be established before the Login Request. For information on using IPsec security for iSCSI, see Section 9, [RFC3723], and [RFC7146].",
      "zh-cn": "To protect the TCP connection, an IPsec security association MAY be established before the Login Request. For information on using IPsec security for iSCSI, see Section 9, [RFC3723], and [RFC7146]."
    },
    {
      "indent": 3,
      "text": "The iSCSI Login Phase is carried through Login Requests and Responses. Once suitable authentication has occurred and operational parameters have been set, the session transitions to the Full Feature Phase and the initiator may start to send SCSI commands. The security policy for whether and by what means a target chooses to authorize an initiator is beyond the scope of this document. For a more detailed description of the Login Phase, see Section 6.",
      "zh-cn": "The iSCSI Login Phase is carried through Login Requests and Responses. Once suitable authentication has occurred and operational parameters have been set, the session transitions to the Full Feature Phase and the initiator may start to send SCSI commands. The security policy for whether and by what means a target chooses to authorize an initiator is beyond the scope of this document. For a more detailed description of the Login Phase, see Section 6."
    },
    {
      "indent": 3,
      "text": "The login PDU includes the ISID part of the session ID (SSID). The target portal group that services the login is implied by the selection of the connection endpoint. For a new session, the TSIH is zero. As part of the response, the target generates a TSIH.",
      "zh-cn": "The login PDU includes the ISID part of the session ID (SSID). The target portal group that services the login is implied by the selection of the connection endpoint. For a new session, the TSIH is zero. As part of the response, the target generates a TSIH."
    },
    {
      "indent": 3,
      "text": "During session establishment, the target identifies the SCSI initiator port (the \"I\" in the \"I_T nexus\") through the value pair (InitiatorName, ISID). We describe InitiatorName later in this section. Any persistent state (e.g., persistent reservations) on the target that is associated with a SCSI initiator port is identified based on this value pair. Any state associated with the SCSI target port (the \"T\" in the \"I_T nexus\") is identified externally by the TargetName and Target Portal Group Tag (see Section 4.4.1). The ISID is subject to reuse restrictions because it is used to identify a persistent state (see Section 4.4.3).",
      "zh-cn": "During session establishment, the target identifies the SCSI initiator port (the \"I\" in the \"I_T nexus\") through the value pair (InitiatorName, ISID). We describe InitiatorName later in this section. Any persistent state (e.g., persistent reservations) on the target that is associated with a SCSI initiator port is identified based on this value pair. Any state associated with the SCSI target port (the \"T\" in the \"I_T nexus\") is identified externally by the TargetName and Target Portal Group Tag (see Section 4.4.1). The ISID is subject to reuse restrictions because it is used to identify a persistent state (see Section 4.4.3)."
    },
    {
      "indent": 3,
      "text": "Before the Full Feature Phase is established, only Login Request and Login Response PDUs are allowed. Login Requests and Responses MUST be used exclusively during login. On any connection, the Login Phase MUST immediately follow TCP connection establishment, and a subsequent Login Phase MUST NOT occur before tearing down the connection.",
      "zh-cn": "Before the Full Feature Phase is established, only Login Request and Login Response PDUs are allowed. Login Requests and Responses MUST be used exclusively during login. On any connection, the Login Phase MUST immediately follow TCP connection establishment, and a subsequent Login Phase MUST NOT occur before tearing down the connection."
    },
    {
      "indent": 3,
      "text": "A target receiving any PDU except a Login Request before the Login Phase is started MUST immediately terminate the connection on which the PDU was received. Once the Login Phase has started, if the target receives any PDU except a Login Request, it MUST send a Login reject (with Status \"invalid during login\") and then disconnect. If the initiator receives any PDU except a Login Response, it MUST immediately terminate the connection.",
      "zh-cn": "A target receiving any PDU except a Login Request before the Login Phase is started MUST immediately terminate the connection on which the PDU was received. Once the Login Phase has started, if the target receives any PDU except a Login Request, it MUST send a Login reject (with Status \"invalid during login\") and then disconnect. If the initiator receives any PDU except a Login Response, it MUST immediately terminate the connection."
    },
    {
      "indent": 0,
      "text": "4.2.5. iSCSI Full Feature Phase",
      "section_title": true,
      "zh-cn": "4.2.5. iSCSI Full Feature Phase"
    },
    {
      "indent": 3,
      "text": "Once the two sides successfully conclude the login on the first -- also called the leading -- connection in the session, the iSCSI session is in the iSCSI Full Feature Phase. A connection is in the Full Feature Phase if the session is in the Full Feature Phase and the connection login has completed successfully. An iSCSI connection is not in the Full Feature Phase when",
      "zh-cn": "Once the two sides successfully conclude the login on the first -- also called the leading -- connection in the session, the iSCSI session is in the iSCSI Full Feature Phase. A connection is in the Full Feature Phase if the session is in the Full Feature Phase and the connection login has completed successfully. An iSCSI connection is not in the Full Feature Phase when"
    },
    {
      "indent": 6,
      "text": "a) it does not have an established transport connection, or",
      "zh-cn": "a) it does not have an established transport connection, or"
    },
    {
      "indent": 6,
      "text": "b) when it has a valid transport connection, but a successful login was not performed or the connection is currently logged out.",
      "zh-cn": "b) when it has a valid transport connection, but a successful login was not performed or the connection is currently logged out."
    },
    {
      "indent": 3,
      "text": "In a normal Full Feature Phase, the initiator may send SCSI commands and data to the various LUs on the target by encapsulating them in iSCSI PDUs that go over the established iSCSI session.",
      "zh-cn": "In a normal Full Feature Phase, the initiator may send SCSI commands and data to the various LUs on the target by encapsulating them in iSCSI PDUs that go over the established iSCSI session."
    },
    {
      "indent": 0,
      "text": "4.2.5.1. Command Connection Allegiance",
      "section_title": true,
      "zh-cn": "4.2.5.1. Command Connection Allegiance"
    },
    {
      "indent": 3,
      "text": "For any iSCSI request issued over a TCP connection, the corresponding response and/or other related PDU(s) MUST be sent over the same connection. We call this \"connection allegiance\". If the original connection fails before the command is completed, the connection allegiance of the command may be explicitly reassigned to a different transport connection as described in detail in Section 7.2.",
      "zh-cn": "For any iSCSI request issued over a TCP connection, the corresponding response and/or other related PDU(s) MUST be sent over the same connection. We call this \"connection allegiance\". If the original connection fails before the command is completed, the connection allegiance of the command may be explicitly reassigned to a different transport connection as described in detail in Section 7.2."
    },
    {
      "indent": 3,
      "text": "Thus, if an initiator issues a read command, the target MUST send the requested data, if any, followed by the status, to the initiator over the same TCP connection that was used to deliver the SCSI command. If an initiator issues a write command, the initiator MUST send the data, if any, for that command over the same TCP connection that was used to deliver the SCSI command. The target MUST return Ready To Transfer (R2T), if any, and the status over the same TCP connection that was used to deliver the SCSI command. Retransmission requests (SNACK PDUs), and the data and status that they generate, MUST also use the same connection.",
      "zh-cn": "Thus, if an initiator issues a read command, the target MUST send the requested data, if any, followed by the status, to the initiator over the same TCP connection that was used to deliver the SCSI command. If an initiator issues a write command, the initiator MUST send the data, if any, for that command over the same TCP connection that was used to deliver the SCSI command. The target MUST return Ready To Transfer (R2T), if any, and the status over the same TCP connection that was used to deliver the SCSI command. Retransmission requests (SNACK PDUs), and the data and status that they generate, MUST also use the same connection."
    },
    {
      "indent": 3,
      "text": "However, consecutive commands that are part of a SCSI linked command-chain task (see [SAM2]) MAY use different connections. Connection allegiance is strictly per command and not per task. During the iSCSI Full Feature Phase, the initiator and target MAY interleave unrelated SCSI commands, their SCSI data, and responses over the session.",
      "zh-cn": "However, consecutive commands that are part of a SCSI linked command-chain task (see [SAM2]) MAY use different connections. Connection allegiance is strictly per command and not per task. During the iSCSI Full Feature Phase, the initiator and target MAY interleave unrelated SCSI commands, their SCSI data, and responses over the session."
    },
    {
      "indent": 0,
      "text": "4.2.5.2. Data Transfer Overview",
      "section_title": true,
      "zh-cn": "4.2.5.2. Data Transfer Overview"
    },
    {
      "indent": 3,
      "text": "Outgoing SCSI data (initiator-to-target user data or command parameters) is sent as either solicited data or unsolicited data. Solicited data are sent in response to R2T PDUs. Unsolicited data can be sent as part of an iSCSI Command PDU (\"immediate data\") or in separate iSCSI data PDUs.",
      "zh-cn": "Outgoing SCSI data (initiator-to-target user data or command parameters) is sent as either solicited data or unsolicited data. Solicited data are sent in response to R2T PDUs. Unsolicited data can be sent as part of an iSCSI Command PDU (\"immediate data\") or in separate iSCSI data PDUs."
    },
    {
      "indent": 3,
      "text": "Immediate data are assumed to originate at offset 0 in the initiator SCSI write-buffer (outgoing data buffer). All other data PDUs have the buffer offset set explicitly in the PDU header.",
      "zh-cn": "Immediate data are assumed to originate at offset 0 in the initiator SCSI write-buffer (outgoing data buffer). All other data PDUs have the buffer offset set explicitly in the PDU header."
    },
    {
      "indent": 3,
      "text": "An initiator may send unsolicited data up to FirstBurstLength (see Section 13.14) as immediate (up to the negotiated maximum PDU length), in a separate PDU sequence, or both. All subsequent data MUST be solicited. The maximum length of an individual data PDU or the immediate-part of the first unsolicited burst MAY be negotiated at login.",
      "zh-cn": "An initiator may send unsolicited data up to FirstBurstLength (see Section 13.14) as immediate (up to the negotiated maximum PDU length), in a separate PDU sequence, or both. All subsequent data MUST be solicited. The maximum length of an individual data PDU or the immediate-part of the first unsolicited burst MAY be negotiated at login."
    },
    {
      "indent": 3,
      "text": "The maximum amount of unsolicited data that can be sent with a command is negotiated at login through the FirstBurstLength (see Section 13.14) key. A target MAY separately enable immediate data (through the ImmediateData key) without enabling the more general (separate data PDUs) form of unsolicited data (through the InitialR2T key).",
      "zh-cn": "The maximum amount of unsolicited data that can be sent with a command is negotiated at login through the FirstBurstLength (see Section 13.14) key. A target MAY separately enable immediate data (through the ImmediateData key) without enabling the more general (separate data PDUs) form of unsolicited data (through the InitialR2T key)."
    },
    {
      "indent": 3,
      "text": "Unsolicited data for a write are meant to reduce the effect of latency on throughput (no R2T is needed to start sending data). In addition, immediate data is meant to reduce the protocol overhead (both bandwidth and execution time).",
      "zh-cn": "Unsolicited data for a write are meant to reduce the effect of latency on throughput (no R2T is needed to start sending data). In addition, immediate data is meant to reduce the protocol overhead (both bandwidth and execution time)."
    },
    {
      "indent": 3,
      "text": "An iSCSI initiator MAY choose not to send unsolicited data, only immediate data or FirstBurstLength bytes of unsolicited data with a command. If any non-immediate unsolicited data is sent, the total unsolicited data MUST be either FirstBurstLength or all of the data, if the total amount is less than the FirstBurstLength.",
      "zh-cn": "An iSCSI initiator MAY choose not to send unsolicited data, only immediate data or FirstBurstLength bytes of unsolicited data with a command. If any non-immediate unsolicited data is sent, the total unsolicited data MUST be either FirstBurstLength or all of the data, if the total amount is less than the FirstBurstLength."
    },
    {
      "indent": 3,
      "text": "It is considered an error for an initiator to send unsolicited data PDUs to a target that operates in R2T mode (only solicited data are allowed). It is also an error for an initiator to send more unsolicited data, whether immediate or as separate PDUs, than FirstBurstLength.",
      "zh-cn": "It is considered an error for an initiator to send unsolicited data PDUs to a target that operates in R2T mode (only solicited data are allowed). It is also an error for an initiator to send more unsolicited data, whether immediate or as separate PDUs, than FirstBurstLength."
    },
    {
      "indent": 3,
      "text": "An initiator MUST honor an R2T data request for a valid outstanding command (i.e., carrying a valid Initiator Task Tag) and deliver all the requested data, provided the command is supposed to deliver",
      "zh-cn": "An initiator MUST honor an R2T data request for a valid outstanding command (i.e., carrying a valid Initiator Task Tag) and deliver all the requested data, provided the command is supposed to deliver"
    },
    {
      "indent": 3,
      "text": "outgoing data and the R2T specifies data within the command bounds. The initiator action is unspecified for receiving an R2T request that specifies data, all or in part, outside of the bounds of the command.",
      "zh-cn": "outgoing data and the R2T specifies data within the command bounds. The initiator action is unspecified for receiving an R2T request that specifies data, all or in part, outside of the bounds of the command."
    },
    {
      "indent": 3,
      "text": "A target SHOULD NOT silently discard data and then request retransmission through R2T. Initiators SHOULD NOT keep track of the data transferred to or from the target (scoreboarding). SCSI targets perform residual count calculation to check how much data was actually transferred to or from the device by a command. This may differ from the amount the initiator sent and/or received for reasons such as retransmissions and errors. Read or bidirectional commands implicitly solicit the transmission of the entire amount of data covered by the command. SCSI data packets are matched to their corresponding SCSI commands by using tags specified in the protocol.",
      "zh-cn": "A target SHOULD NOT silently discard data and then request retransmission through R2T. Initiators SHOULD NOT keep track of the data transferred to or from the target (scoreboarding). SCSI targets perform residual count calculation to check how much data was actually transferred to or from the device by a command. This may differ from the amount the initiator sent and/or received for reasons such as retransmissions and errors. Read or bidirectional commands implicitly solicit the transmission of the entire amount of data covered by the command. SCSI data packets are matched to their corresponding SCSI commands by using tags specified in the protocol."
    },
    {
      "indent": 3,
      "text": "In addition, iSCSI initiators and targets MUST enforce some ordering rules. When unsolicited data is used, the order of the unsolicited data on each connection MUST match the order in which the commands on that connection are sent. Command and unsolicited data PDUs may be interleaved on a single connection as long as the ordering requirements of each are maintained (e.g., command N + 1 MAY be sent before the unsolicited Data-Out PDUs for command N, but the unsolicited Data-Out PDUs for command N MUST precede the unsolicited Data-Out PDUs of command N + 1). A target that receives data out of order MAY terminate the session.",
      "zh-cn": "In addition, iSCSI initiators and targets MUST enforce some ordering rules. When unsolicited data is used, the order of the unsolicited data on each connection MUST match the order in which the commands on that connection are sent. Command and unsolicited data PDUs may be interleaved on a single connection as long as the ordering requirements of each are maintained (e.g., command N + 1 MAY be sent before the unsolicited Data-Out PDUs for command N, but the unsolicited Data-Out PDUs for command N MUST precede the unsolicited Data-Out PDUs of command N + 1). A target that receives data out of order MAY terminate the session."
    },
    {
      "indent": 0,
      "text": "4.2.5.3. Tags and Integrity Checks",
      "section_title": true,
      "zh-cn": "4.2.5.3. Tags and Integrity Checks"
    },
    {
      "indent": 3,
      "text": "Initiator tags for pending commands are unique initiator-wide for a session. Target tags are not strictly specified by the protocol. It is assumed that target tags are used by the target to tag (alone or in combination with the LUN) the solicited data. Target tags are generated by the target and \"echoed\" by the initiator.",
      "zh-cn": "Initiator tags for pending commands are unique initiator-wide for a session. Target tags are not strictly specified by the protocol. It is assumed that target tags are used by the target to tag (alone or in combination with the LUN) the solicited data. Target tags are generated by the target and \"echoed\" by the initiator."
    },
    {
      "indent": 3,
      "text": "These mechanisms are designed to accomplish efficient data delivery along with a large degree of control over the data flow.",
      "zh-cn": "These mechanisms are designed to accomplish efficient data delivery along with a large degree of control over the data flow."
    },
    {
      "indent": 3,
      "text": "As the Initiator Task Tag is used to identify a task during its execution, the iSCSI initiator and target MUST verify that all other fields used in task-related PDUs have values that are consistent with the values used at the task instantiation, based on the Initiator Task Tag (e.g., the LUN used in an R2T PDU MUST be the same as the one used in the SCSI Command PDU used to instantiate the task). Using inconsistent field values is considered a protocol error.",
      "zh-cn": "As the Initiator Task Tag is used to identify a task during its execution, the iSCSI initiator and target MUST verify that all other fields used in task-related PDUs have values that are consistent with the values used at the task instantiation, based on the Initiator Task Tag (e.g., the LUN used in an R2T PDU MUST be the same as the one used in the SCSI Command PDU used to instantiate the task). Using inconsistent field values is considered a protocol error."
    },
    {
      "indent": 0,
      "text": "4.2.5.4. SCSI Task Management during iSCSI Full Feature Phase",
      "section_title": true,
      "zh-cn": "4.2.5.4. SCSI Task Management during iSCSI Full Feature Phase"
    },
    {
      "indent": 3,
      "text": "SCSI task management assumes that individual tasks and task groups can be aborted based solely on the task tags (for individual tasks) or the timing of the task management command (for task groups) and that the task management action is executed synchronously -- i.e., no message involving an aborted task will be seen by the SCSI initiator after receiving the task management response. In iSCSI, initiators and targets interact asynchronously over several connections. iSCSI specifies the protocol mechanism and implementation requirements needed to present a synchronous SCSI view while using an asynchronous iSCSI infrastructure.",
      "zh-cn": "SCSI task management assumes that individual tasks and task groups can be aborted based solely on the task tags (for individual tasks) or the timing of the task management command (for task groups) and that the task management action is executed synchronously -- i.e., no message involving an aborted task will be seen by the SCSI initiator after receiving the task management response. In iSCSI, initiators and targets interact asynchronously over several connections. iSCSI specifies the protocol mechanism and implementation requirements needed to present a synchronous SCSI view while using an asynchronous iSCSI infrastructure."
    },
    {
      "indent": 0,
      "text": "4.2.6. iSCSI Connection Termination",
      "section_title": true,
      "zh-cn": "4.2.6. iSCSI Connection Termination"
    },
    {
      "indent": 3,
      "text": "An iSCSI connection may be terminated via a transport connection shutdown or a transport reset. A transport reset is assumed to be an exceptional event.",
      "zh-cn": "An iSCSI connection may be terminated via a transport connection shutdown or a transport reset. A transport reset is assumed to be an exceptional event."
    },
    {
      "indent": 3,
      "text": "Graceful TCP connection shutdowns are done by sending TCP FINs. A graceful transport connection shutdown SHOULD only be initiated by either party when the connection is not in the iSCSI Full Feature Phase. A target MAY terminate a Full Feature Phase connection on internal exception events, but it SHOULD announce the fact through an Asynchronous Message PDU. Connection termination with outstanding commands may require recovery actions.",
      "zh-cn": "Graceful TCP connection shutdowns are done by sending TCP FINs. A graceful transport connection shutdown SHOULD only be initiated by either party when the connection is not in the iSCSI Full Feature Phase. A target MAY terminate a Full Feature Phase connection on internal exception events, but it SHOULD announce the fact through an Asynchronous Message PDU. Connection termination with outstanding commands may require recovery actions."
    },
    {
      "indent": 3,
      "text": "If a connection is terminated while in the Full Feature Phase, connection cleanup (see Section 7.14) is required prior to recovery. By doing connection cleanup before starting recovery, the initiator and target will avoid receiving stale PDUs after recovery.",
      "zh-cn": "If a connection is terminated while in the Full Feature Phase, connection cleanup (see Section 7.14) is required prior to recovery. By doing connection cleanup before starting recovery, the initiator and target will avoid receiving stale PDUs after recovery."
    },
    {
      "indent": 0,
      "text": "4.2.7. iSCSI Names",
      "section_title": true,
      "zh-cn": "4.2.7. iSCSI Names"
    },
    {
      "indent": 3,
      "text": "Both targets and initiators require names for the purpose of identification. In addition, names enable iSCSI storage resources to be managed, regardless of location (address). An iSCSI Node Name is also the SCSI device name contained in the iSCSI node. The iSCSI name of a SCSI device is the principal object used in authentication of targets to initiators and initiators to targets. This name is also used to identify and manage iSCSI storage resources.",
      "zh-cn": "Both targets and initiators require names for the purpose of identification. In addition, names enable iSCSI storage resources to be managed, regardless of location (address). An iSCSI Node Name is also the SCSI device name contained in the iSCSI node. The iSCSI name of a SCSI device is the principal object used in authentication of targets to initiators and initiators to targets. This name is also used to identify and manage iSCSI storage resources."
    },
    {
      "indent": 3,
      "text": "iSCSI names must be unique within the operation domain of the end user. However, because the operation domain of an IP network is potentially worldwide, the iSCSI name formats are architected to be worldwide unique. To assist naming authorities in the construction of worldwide unique names, iSCSI provides three name formats for different types of naming authorities.",
      "zh-cn": "iSCSI names must be unique within the operation domain of the end user. However, because the operation domain of an IP network is potentially worldwide, the iSCSI name formats are architected to be worldwide unique. To assist naming authorities in the construction of worldwide unique names, iSCSI provides three name formats for different types of naming authorities."
    },
    {
      "indent": 3,
      "text": "iSCSI names are associated with iSCSI nodes, and not iSCSI network adapter cards, to ensure that the replacement of network adapter cards does not require reconfiguration of all SCSI and iSCSI resource allocation information.",
      "zh-cn": "iSCSI names are associated with iSCSI nodes, and not iSCSI network adapter cards, to ensure that the replacement of network adapter cards does not require reconfiguration of all SCSI and iSCSI resource allocation information."
    },
    {
      "indent": 3,
      "text": "Some SCSI commands require that protocol-specific identifiers be communicated within SCSI CDBs. See Section 2.2 for the definition of the SCSI port name/identifier for iSCSI ports.",
      "zh-cn": "Some SCSI commands require that protocol-specific identifiers be communicated within SCSI CDBs. See Section 2.2 for the definition of the SCSI port name/identifier for iSCSI ports."
    },
    {
      "indent": 3,
      "text": "An initiator may discover the iSCSI Target Names to which it has access, along with their addresses, using the SendTargets Text Request, or other techniques discussed in [RFC3721].",
      "zh-cn": "An initiator may discover the iSCSI Target Names to which it has access, along with their addresses, using the SendTargets Text Request, or other techniques discussed in [RFC3721]."
    },
    {
      "indent": 3,
      "text": "iSCSI equipment that needs discovery functions beyond SendTargets SHOULD implement iSNS (see [RFC4171]) for extended discovery management capabilities and interoperability. Although [RFC3721] implies an SLP ([RFC2608]) implementation requirement, SLP has not been widely implemented or deployed for use with iSCSI in practice. iSCSI implementations therefore SHOULD NOT rely on SLP-based discovery interoperability.",
      "zh-cn": "iSCSI equipment that needs discovery functions beyond SendTargets SHOULD implement iSNS (see [RFC4171]) for extended discovery management capabilities and interoperability. Although [RFC3721] implies an SLP ([RFC2608]) implementation requirement, SLP has not been widely implemented or deployed for use with iSCSI in practice. iSCSI implementations therefore SHOULD NOT rely on SLP-based discovery interoperability."
    },
    {
      "indent": 0,
      "text": "4.2.7.1. iSCSI Name Properties",
      "section_title": true,
      "zh-cn": "4.2.7.1. iSCSI Name Properties"
    },
    {
      "indent": 3,
      "text": "Each iSCSI node, whether it is an initiator, a target, or both, MUST have an iSCSI name. Whenever an iSCSI node contains an iSCSI initiator node and an iSCSI target node, the iSCSI Initiator Name MUST be the same as the iSCSI Target Name for the contained Nodes such that there is only one iSCSI Node Name for the iSCSI node overall. Note the related requirements in Section 9.2.1 on how to map CHAP names to iSCSI names in such a scenario.",
      "zh-cn": "Each iSCSI node, whether it is an initiator, a target, or both, MUST have an iSCSI name. Whenever an iSCSI node contains an iSCSI initiator node and an iSCSI target node, the iSCSI Initiator Name MUST be the same as the iSCSI Target Name for the contained Nodes such that there is only one iSCSI Node Name for the iSCSI node overall. Note the related requirements in Section 9.2.1 on how to map CHAP names to iSCSI names in such a scenario."
    },
    {
      "indent": 3,
      "text": "Initiators and targets MUST support the receipt of iSCSI names of up to the maximum length of 223 bytes.",
      "zh-cn": "Initiators and targets MUST support the receipt of iSCSI names of up to the maximum length of 223 bytes."
    },
    {
      "indent": 3,
      "text": "The initiator MUST present both its iSCSI Initiator Name and the iSCSI Target Name to which it wishes to connect in the first Login Request of a new session or connection. The only exception is if a Discovery session (see Section 4.3) is to be established. In this case, the iSCSI Initiator Name is still required, but the iSCSI Target Name MAY be omitted.",
      "zh-cn": "The initiator MUST present both its iSCSI Initiator Name and the iSCSI Target Name to which it wishes to connect in the first Login Request of a new session or connection. The only exception is if a Discovery session (see Section 4.3) is to be established. In this case, the iSCSI Initiator Name is still required, but the iSCSI Target Name MAY be omitted."
    },
    {
      "indent": 3,
      "text": "iSCSI names have the following properties:",
      "zh-cn": "iSCSI names have the following properties:"
    },
    {
      "indent": 6,
      "text": "- iSCSI names are globally unique. No two initiators or targets can have the same name.",
      "zh-cn": "- iSCSI names are globally unique. No two initiators or targets can have the same name."
    },
    {
      "indent": 6,
      "text": "- iSCSI names are permanent. An iSCSI initiator node or target node has the same name for its lifetime.",
      "zh-cn": "- iSCSI names are permanent. An iSCSI initiator node or target node has the same name for its lifetime."
    },
    {
      "indent": 6,
      "text": "- iSCSI names do not imply a location or address. An iSCSI initiator or target can move or have multiple addresses. A change of address does not imply a change of name.",
      "zh-cn": "- iSCSI names do not imply a location or address. An iSCSI initiator or target can move or have multiple addresses. A change of address does not imply a change of name."
    },
    {
      "indent": 6,
      "text": "- iSCSI names do not rely on a central name broker; the naming authority is distributed.",
      "zh-cn": "- iSCSI names do not rely on a central name broker; the naming authority is distributed."
    },
    {
      "indent": 6,
      "text": "- iSCSI names support integration with existing unique naming schemes.",
      "zh-cn": "- iSCSI names support integration with existing unique naming schemes."
    },
    {
      "indent": 6,
      "text": "- iSCSI names rely on existing naming authorities. iSCSI does not create any new naming authority.",
      "zh-cn": "- iSCSI names rely on existing naming authorities. iSCSI does not create any new naming authority."
    },
    {
      "indent": 3,
      "text": "The encoding of an iSCSI name has the following properties:",
      "zh-cn": "The encoding of an iSCSI name has the following properties:"
    },
    {
      "indent": 6,
      "text": "- iSCSI names have the same encoding method, regardless of the underlying protocols.",
      "zh-cn": "- iSCSI names have the same encoding method, regardless of the underlying protocols."
    },
    {
      "indent": 6,
      "text": "- iSCSI names are relatively simple to compare. The algorithm for comparing two iSCSI names for equivalence does not rely on an external server.",
      "zh-cn": "- iSCSI names are relatively simple to compare. The algorithm for comparing two iSCSI names for equivalence does not rely on an external server."
    },
    {
      "indent": 6,
      "text": "- iSCSI names are composed only of printable ASCII and Unicode characters. iSCSI names allow the use of international character sets, but uppercase characters are prohibited. The iSCSI stringprep profile [RFC3722] maps uppercase characters to lowercase and SHOULD be used to prepare iSCSI names from input that may include uppercase characters. No whitespace characters are used in iSCSI names; see [RFC3722] for details.",
      "zh-cn": "- iSCSI names are composed only of printable ASCII and Unicode characters. iSCSI names allow the use of international character sets, but uppercase characters are prohibited. The iSCSI stringprep profile [RFC3722] maps uppercase characters to lowercase and SHOULD be used to prepare iSCSI names from input that may include uppercase characters. No whitespace characters are used in iSCSI names; see [RFC3722] for details."
    },
    {
      "indent": 6,
      "text": "- iSCSI names may be transported using both binary and ASCII-based protocols.",
      "zh-cn": "- iSCSI names may be transported using both binary and ASCII-based protocols."
    },
    {
      "indent": 3,
      "text": "An iSCSI name really names a logical software entity and is not tied to a port or other hardware that can be changed. For instance, an Initiator Name should name the iSCSI initiator node, not a particular NIC or HBA. When multiple NICs are used, they should generally all present the same iSCSI Initiator Name to the targets, because they are simply paths to the same SCSI layer. In most operating systems, the named entity is the operating system image.",
      "zh-cn": "An iSCSI name really names a logical software entity and is not tied to a port or other hardware that can be changed. For instance, an Initiator Name should name the iSCSI initiator node, not a particular NIC or HBA. When multiple NICs are used, they should generally all present the same iSCSI Initiator Name to the targets, because they are simply paths to the same SCSI layer. In most operating systems, the named entity is the operating system image."
    },
    {
      "indent": 3,
      "text": "Similarly, a target name should not be tied to hardware interfaces that can be changed. A target name should identify the logical target and must be the same for the target, regardless of the physical portion being addressed. This assists iSCSI initiators in determining that the two targets it has discovered are really two paths to the same target.",
      "zh-cn": "Similarly, a target name should not be tied to hardware interfaces that can be changed. A target name should identify the logical target and must be the same for the target, regardless of the physical portion being addressed. This assists iSCSI initiators in determining that the two targets it has discovered are really two paths to the same target."
    },
    {
      "indent": 3,
      "text": "The iSCSI name is designed to fulfill the functional requirements for Uniform Resource Names (URNs) [RFC1737]. For example, it is required that the name have a global scope, be independent of address or location, and be persistent and globally unique. Names must be extensible and scalable with the use of naming authorities. The name encoding should be both human and machine readable. See [RFC1737] for further requirements.",
      "zh-cn": "The iSCSI name is designed to fulfill the functional requirements for Uniform Resource Names (URNs) [RFC1737]. For example, it is required that the name have a global scope, be independent of address or location, and be persistent and globally unique. Names must be extensible and scalable with the use of naming authorities. The name encoding should be both human and machine readable. See [RFC1737] for further requirements."
    },
    {
      "indent": 0,
      "text": "4.2.7.2. iSCSI Name Encoding",
      "section_title": true,
      "zh-cn": "4.2.7.2. iSCSI Name Encoding"
    },
    {
      "indent": 3,
      "text": "An iSCSI name MUST be a UTF-8 (see [RFC3629]) encoding of a string of Unicode characters with the following properties:",
      "zh-cn": "An iSCSI name MUST be a UTF-8 (see [RFC3629]) encoding of a string of Unicode characters with the following properties:"
    },
    {
      "indent": 6,
      "text": "- It is in Normalization Form C (see \"Unicode Normalization Forms\" [UNICODE]).",
      "zh-cn": "- It is in Normalization Form C (see \"Unicode Normalization Forms\" [UNICODE])."
    },
    {
      "indent": 6,
      "text": "- It only contains characters allowed by the output of the iSCSI stringprep template (described in [RFC3722]).",
      "zh-cn": "- It only contains characters allowed by the output of the iSCSI stringprep template (described in [RFC3722])."
    },
    {
      "indent": 6,
      "text": "- The following characters are used for formatting iSCSI names:",
      "zh-cn": "- The following characters are used for formatting iSCSI names:"
    },
    {
      "indent": 11,
      "text": "dash ('-'=U+002d)",
      "zh-cn": "dash ('-'=U+002d)"
    },
    {
      "indent": 11,
      "text": "dot ('.'=U+002e)",
      "zh-cn": "dot ('.'=U+002e)"
    },
    {
      "indent": 11,
      "text": "colon (':'=U+003a)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "- The UTF-8 encoding of the name is not larger than 223 bytes.",
      "zh-cn": "- The UTF-8 encoding of the name is not larger than 223 bytes."
    },
    {
      "indent": 3,
      "text": "The stringprep process is described in [RFC3454]; iSCSI's use of the stringprep process is described in [RFC3722]. The stringprep process is a method designed by the Internationalized Domain Name (IDN) working group to translate human-typed strings into a format that can be compared as opaque strings. iSCSI names are expected to be used by administrators for purposes such as system configuration; for this reason, characters that may lead to human confusion among different iSCSI names (e.g., punctuation, spacing, diacritical marks) should be avoided, even when such characters are allowed as stringprep processing output by [RFC3722]. The stringprep process also converts strings into equivalent strings of lowercase characters.",
      "zh-cn": "The stringprep process is described in [RFC3454]; iSCSI's use of the stringprep process is described in [RFC3722]. The stringprep process is a method designed by the Internationalized Domain Name (IDN) working group to translate human-typed strings into a format that can be compared as opaque strings. iSCSI names are expected to be used by administrators for purposes such as system configuration; for this reason, characters that may lead to human confusion among different iSCSI names (e.g., punctuation, spacing, diacritical marks) should be avoided, even when such characters are allowed as stringprep processing output by [RFC3722]. The stringprep process also converts strings into equivalent strings of lowercase characters."
    },
    {
      "indent": 3,
      "text": "The stringprep process does not need to be implemented if the names are generated using only characters allowed as output by the stringprep processing specified in [RFC3722]. Those allowed characters include all ASCII lowercase and numeric characters, as well as lowercase Unicode characters as specified in [RFC3722]. Once iSCSI names encoded in UTF-8 are \"normalized\" as described in this section, they may be safely compared byte for byte.",
      "zh-cn": "The stringprep process does not need to be implemented if the names are generated using only characters allowed as output by the stringprep processing specified in [RFC3722]. Those allowed characters include all ASCII lowercase and numeric characters, as well as lowercase Unicode characters as specified in [RFC3722]. Once iSCSI names encoded in UTF-8 are \"normalized\" as described in this section, they may be safely compared byte for byte."
    },
    {
      "indent": 0,
      "text": "4.2.7.3. iSCSI Name Structure",
      "section_title": true,
      "zh-cn": "4.2.7.3. iSCSI Name Structure"
    },
    {
      "indent": 3,
      "text": "An iSCSI name consists of two parts -- a type designator followed by a unique name string.",
      "zh-cn": "An iSCSI name consists of two parts -- a type designator followed by a unique name string."
    },
    {
      "indent": 3,
      "text": "iSCSI uses three existing naming authorities in constructing globally unique iSCSI names. The type designator in an iSCSI name indicates the naming authority on which the name is based. The three iSCSI name formats are the following:",
      "zh-cn": "iSCSI uses three existing naming authorities in constructing globally unique iSCSI names. The type designator in an iSCSI name indicates the naming authority on which the name is based. The three iSCSI name formats are the following:"
    },
    {
      "indent": 6,
      "text": "a) iSCSI-Qualified Name: based on domain names to identify a naming authority",
      "zh-cn": "a) iSCSI-Qualified Name: based on domain names to identify a naming authority"
    },
    {
      "indent": 6,
      "text": "b) NAA format Name: based on a naming format defined by [FC-FS3] for constructing globally unique identifiers, referred to as the Network Address Authority (NAA)",
      "zh-cn": "b) NAA format Name: based on a naming format defined by [FC-FS3] for constructing globally unique identifiers, referred to as the Network Address Authority (NAA)"
    },
    {
      "indent": 6,
      "text": "c) EUI format Name: based on EUI names, where the IEEE Registration Authority assists in the formation of worldwide unique names (EUI-64 format)",
      "zh-cn": "c) EUI format Name: based on EUI names, where the IEEE Registration Authority assists in the formation of worldwide unique names (EUI-64 format)"
    },
    {
      "indent": 3,
      "text": "The corresponding type designator strings currently defined are:",
      "zh-cn": "The corresponding type designator strings currently defined are:"
    },
    {
      "indent": 6,
      "text": "a) iqn. - iSCSI Qualified name",
      "zh-cn": "a) iqn. - iSCSI Qualified name"
    },
    {
      "indent": 6,
      "text": "b) naa. - Remainder of the string is an INCITS T11-defined Network Address Authority identifier, in ASCII-encoded hexadecimal",
      "zh-cn": "b) naa. - Remainder of the string is an INCITS T11-defined Network Address Authority identifier, in ASCII-encoded hexadecimal"
    },
    {
      "indent": 6,
      "text": "c) eui. - Remainder of the string is an IEEE EUI-64 identifier, in ASCII-encoded hexadecimal",
      "zh-cn": "c) eui. - Remainder of the string is an IEEE EUI-64 identifier, in ASCII-encoded hexadecimal"
    },
    {
      "indent": 3,
      "text": "These three naming authority designators were considered sufficient at the time of writing this document. The creation of additional naming type designators for iSCSI may be considered by the IETF and detailed in separate RFCs.",
      "zh-cn": "These three naming authority designators were considered sufficient at the time of writing this document. The creation of additional naming type designators for iSCSI may be considered by the IETF and detailed in separate RFCs."
    },
    {
      "indent": 3,
      "text": "The following table summarizes the current SCSI transport protocols and their naming formats.",
      "zh-cn": "The following table summarizes the current SCSI transport protocols and their naming formats."
    },
    {
      "indent": 5,
      "text": "   SCSI Transport Protocol       Naming Format\n+----------------------------+-------+-----+----+\n|                            | EUI-64| NAA |IQN |\n|----------------------------|-------|-----|----|\n| iSCSI (Internet SCSI)      |   X   |  X  | X  |\n|----------------------------|-------|-----|----|\n| FCP (Fibre Channel)        |       |  X  |    |\n|----------------------------|-------|-----|----|\n| SAS (Serial Attached SCSI) |       |  X  |    |\n+----------------------------+-------+-----+----+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "4.2.7.4. Type \"iqn.\" (iSCSI Qualified Name)",
      "section_title": true,
      "zh-cn": "4.2.7.4. Type \"iqn.\" (iSCSI Qualified Name)"
    },
    {
      "indent": 3,
      "text": "This iSCSI name type can be used by any organization that owns a domain name. This naming format is useful when an end user or service provider wishes to assign iSCSI names for targets and/or initiators.",
      "zh-cn": "This iSCSI name type can be used by any organization that owns a domain name. This naming format is useful when an end user or service provider wishes to assign iSCSI names for targets and/or initiators."
    },
    {
      "indent": 3,
      "text": "To generate names of this type, the person or organization generating the name must own a registered domain name. This domain name does not have to resolve to an address; it just needs to be reserved to prevent others from generating iSCSI names using the same domain name.",
      "zh-cn": "To generate names of this type, the person or organization generating the name must own a registered domain name. This domain name does not have to resolve to an address; it just needs to be reserved to prevent others from generating iSCSI names using the same domain name."
    },
    {
      "indent": 3,
      "text": "Since a domain name can expire, be acquired by another entity, or may be used to generate iSCSI names by both owners, the domain name must be additionally qualified by a date during which the naming authority owned the domain name. A date code is provided as part of the \"iqn.\" format for this reason.",
      "zh-cn": "Since a domain name can expire, be acquired by another entity, or may be used to generate iSCSI names by both owners, the domain name must be additionally qualified by a date during which the naming authority owned the domain name. A date code is provided as part of the \"iqn.\" format for this reason."
    },
    {
      "indent": 3,
      "text": "The iSCSI qualified name string consists of:",
      "zh-cn": "The iSCSI qualified name string consists of:"
    },
    {
      "indent": 6,
      "text": "- The string \"iqn.\", used to distinguish these names from \"eui.\" formatted names.",
      "zh-cn": "- The string \"iqn.\", used to distinguish these names from \"eui.\" formatted names."
    },
    {
      "indent": 6,
      "text": "- A date code, in yyyy-mm format. This date MUST be a date during which the naming authority owned the domain name used in this format and SHOULD be the first month in which the domain name was owned by this naming authority at 00:01 GMT of the first day of the month. This date code uses the Gregorian calendar. All four digits in the year must be present. Both digits of the month must be present, with January == \"01\" and December == \"12\". The dash must be included.",
      "zh-cn": "- A date code, in yyyy-mm format. This date MUST be a date during which the naming authority owned the domain name used in this format and SHOULD be the first month in which the domain name was owned by this naming authority at 00:01 GMT of the first day of the month. This date code uses the Gregorian calendar. All four digits in the year must be present. Both digits of the month must be present, with January == \"01\" and December == \"12\". The dash must be included."
    },
    {
      "indent": 6,
      "text": "- A dot \".\"",
      "zh-cn": "- A dot \".\""
    },
    {
      "indent": 6,
      "text": "- The reverse domain name of the naming authority (person or organization) creating this iSCSI name.",
      "zh-cn": "- The reverse domain name of the naming authority (person or organization) creating this iSCSI name."
    },
    {
      "indent": 6,
      "text": "- An optional, colon (:)-prefixed string within the character set and length boundaries that the owner of the domain name deems appropriate. This may contain product types, serial numbers, host identifiers, or software keys (e.g., it may include colons to separate organization boundaries). With the exception of the colon prefix, the owner of the domain name can assign everything after the reverse domain name as desired. It is the responsibility of the entity that is the naming authority to ensure that the iSCSI names it assigns are worldwide unique. For example, \"Example Storage Arrays, Inc.\" might own the domain name \"example.com\".",
      "zh-cn": "- An optional, colon (:)-prefixed string within the character set and length boundaries that the owner of the domain name deems appropriate. This may contain product types, serial numbers, host identifiers, or software keys (e.g., it may include colons to separate organization boundaries). With the exception of the colon prefix, the owner of the domain name can assign everything after the reverse domain name as desired. It is the responsibility of the entity that is the naming authority to ensure that the iSCSI names it assigns are worldwide unique. For example, \"Example Storage Arrays, Inc.\" might own the domain name \"example.com\"."
    },
    {
      "indent": 3,
      "text": "The following are examples of iSCSI qualified names that might be generated by \"EXAMPLE Storage Arrays, Inc.\"",
      "zh-cn": "The following are examples of iSCSI qualified names that might be generated by \"EXAMPLE Storage Arrays, Inc.\""
    },
    {
      "indent": 6,
      "text": "              Naming     String defined by\nType  Date     Auth      \"example.com\" naming authority\n+--++-----+ +---------+ +--------------------------------+\n| ||      | |         | |                                |",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "iqn.2001-04.com.example:storage:diskarrays-sn-a8675309 iqn.2001-04.com.example iqn.2001-04.com.example:storage.tape1.sys1.xyz iqn.2001-04.com.example:storage.disk2.sys1.xyz",
      "zh-cn": "iqn.2001-04.com.example:storage:diskarrays-sn-a8675309 iqn.2001-04.com.example iqn.2001-04.com.example:storage.tape1.sys1.xyz iqn.2001-04.com.example:storage.disk2.sys1.xyz"
    },
    {
      "indent": 0,
      "text": "4.2.7.5. Type \"eui.\" (IEEE EUI-64 Format)",
      "section_title": true,
      "zh-cn": "4.2.7.5. Type \"eui.\" (IEEE EUI-64 Format)"
    },
    {
      "indent": 3,
      "text": "The IEEE Registration Authority provides a service for assigning globally unique identifiers [EUI]. The EUI-64 format is used to build a global identifier in other network protocols. For example, Fibre Channel defines a method of encoding it into a WorldWideName. For more information on registering for EUI identifiers, see [OUI].",
      "zh-cn": "The IEEE Registration Authority provides a service for assigning globally unique identifiers [EUI]. The EUI-64 format is used to build a global identifier in other network protocols. For example, Fibre Channel defines a method of encoding it into a WorldWideName. For more information on registering for EUI identifiers, see [OUI]."
    },
    {
      "indent": 3,
      "text": "The format is \"eui.\" followed by an EUI-64 identifier (16 ASCII-encoded hexadecimal digits).",
      "zh-cn": "The format is \"eui.\" followed by an EUI-64 identifier (16 ASCII-encoded hexadecimal digits)."
    },
    {
      "indent": 6,
      "text": "Example iSCSI name:",
      "zh-cn": "Example iSCSI name:"
    },
    {
      "indent": 9,
      "text": "Type   EUI-64 identifier (ASCII-encoded hexadecimal)\n+--++--------------+\n|  ||              |\neui.02004567A425678D",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The IEEE EUI-64 iSCSI name format might be used when a manufacturer is already registered with the IEEE Registration Authority and uses EUI-64 formatted worldwide unique names for its products.",
      "zh-cn": "The IEEE EUI-64 iSCSI name format might be used when a manufacturer is already registered with the IEEE Registration Authority and uses EUI-64 formatted worldwide unique names for its products."
    },
    {
      "indent": 3,
      "text": "More examples of name construction are discussed in [RFC3721].",
      "zh-cn": "More examples of name construction are discussed in [RFC3721]."
    },
    {
      "indent": 0,
      "text": "4.2.7.6. Type \"naa.\" (Network Address Authority)",
      "section_title": true,
      "zh-cn": "4.2.7.6. Type \"naa.\" (Network Address Authority)"
    },
    {
      "indent": 3,
      "text": "The INCITS T11 Framing and Signaling Specification [FC-FS3] defines a format called the Network Address Authority (NAA) format for constructing worldwide unique identifiers that use various identifier registration authorities. This identifier format is used by the Fibre Channel and SAS SCSI transport protocols. As FC and SAS constitute a large fraction of networked SCSI ports, the NAA format is a widely used format for SCSI transports. The objective behind iSCSI supporting a direct representation of an NAA format Name is to facilitate construction of a target device name that translates easily across multiple namespaces for a SCSI storage device containing ports served by different transports. More specifically, this format allows implementations wherein one NAA identifier can be assigned as the basis for the SCSI device name for a SCSI target with both SAS ports and iSCSI ports.",
      "zh-cn": "The INCITS T11 Framing and Signaling Specification [FC-FS3] defines a format called the Network Address Authority (NAA) format for constructing worldwide unique identifiers that use various identifier registration authorities. This identifier format is used by the Fibre Channel and SAS SCSI transport protocols. As FC and SAS constitute a large fraction of networked SCSI ports, the NAA format is a widely used format for SCSI transports. The objective behind iSCSI supporting a direct representation of an NAA format Name is to facilitate construction of a target device name that translates easily across multiple namespaces for a SCSI storage device containing ports served by different transports. More specifically, this format allows implementations wherein one NAA identifier can be assigned as the basis for the SCSI device name for a SCSI target with both SAS ports and iSCSI ports."
    },
    {
      "indent": 3,
      "text": "The iSCSI NAA naming format is \"naa.\", followed by an NAA identifier represented in ASCII-encoded hexadecimal digits.",
      "zh-cn": "The iSCSI NAA naming format is \"naa.\", followed by an NAA identifier represented in ASCII-encoded hexadecimal digits."
    },
    {
      "indent": 3,
      "text": "An example of an iSCSI name with a 64-bit NAA value follows:",
      "zh-cn": "An example of an iSCSI name with a 64-bit NAA value follows:"
    },
    {
      "indent": 6,
      "text": "Type  NAA identifier (ASCII-encoded hexadecimal)\n+--++--------------+\n|  ||              |\nnaa.52004567BA64678D",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "An example of an iSCSI name with a 128-bit NAA value follows:",
      "zh-cn": "An example of an iSCSI name with a 128-bit NAA value follows:"
    },
    {
      "indent": 6,
      "text": "Type  NAA identifier (ASCII-encoded hexadecimal)\n+--++------------------------------+\n|  ||                              |\nnaa.62004567BA64678D0123456789ABCDEF",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The iSCSI NAA naming format might be used in an implementation when the infrastructure for generating NAA worldwide unique names is already in place because the device contains both SAS and iSCSI SCSI ports.",
      "zh-cn": "The iSCSI NAA naming format might be used in an implementation when the infrastructure for generating NAA worldwide unique names is already in place because the device contains both SAS and iSCSI SCSI ports."
    },
    {
      "indent": 3,
      "text": "The NAA identifier formatted in an ASCII-hexadecimal representation has a maximum size of 32 characters (128-bit NAA format). As a result, there is no issue with this naming format exceeding the maximum size for iSCSI Node Names.",
      "zh-cn": "The NAA identifier formatted in an ASCII-hexadecimal representation has a maximum size of 32 characters (128-bit NAA format). As a result, there is no issue with this naming format exceeding the maximum size for iSCSI Node Names."
    },
    {
      "indent": 0,
      "text": "4.2.8. Persistent State",
      "section_title": true,
      "zh-cn": "4.2.8. Persistent State"
    },
    {
      "indent": 3,
      "text": "iSCSI does not require any persistent state maintenance across sessions. However, in some cases, SCSI requires persistent identification of the SCSI initiator port name (see Sections 4.4.2 and 4.4.3.)",
      "zh-cn": "iSCSI does not require any persistent state maintenance across sessions. However, in some cases, SCSI requires persistent identification of the SCSI initiator port name (see Sections 4.4.2 and 4.4.3.)"
    },
    {
      "indent": 3,
      "text": "iSCSI sessions do not persist through power cycles and boot operations.",
      "zh-cn": "iSCSI sessions do not persist through power cycles and boot operations."
    },
    {
      "indent": 3,
      "text": "All iSCSI session and connection parameters are reinitialized on session and connection creation.",
      "zh-cn": "All iSCSI session and connection parameters are reinitialized on session and connection creation."
    },
    {
      "indent": 3,
      "text": "Commands persist beyond connection termination if the session persists and command recovery within the session is supported. However, when a connection is dropped, command execution, as perceived by iSCSI (i.e., involving iSCSI protocol exchanges for the affected task), is suspended until a new allegiance is established by the \"TASK REASSIGN\" task management function. See Section 11.5.",
      "zh-cn": "Commands persist beyond connection termination if the session persists and command recovery within the session is supported. However, when a connection is dropped, command execution, as perceived by iSCSI (i.e., involving iSCSI protocol exchanges for the affected task), is suspended until a new allegiance is established by the \"TASK REASSIGN\" task management function. See Section 11.5."
    },
    {
      "indent": 0,
      "text": "4.2.9. Message Synchronization and Steering",
      "section_title": true,
      "zh-cn": "4.2.9. Message Synchronization and Steering"
    },
    {
      "indent": 3,
      "text": "iSCSI presents a mapping of the SCSI protocol onto TCP. This encapsulation is accomplished by sending iSCSI PDUs of varying lengths. Unfortunately, TCP does not have a built-in mechanism for signaling message boundaries at the TCP layer. iSCSI overcomes this obstacle by placing the message length in the iSCSI message header. This serves to delineate the end of the current message as well as the beginning of the next message.",
      "zh-cn": "iSCSI presents a mapping of the SCSI protocol onto TCP. This encapsulation is accomplished by sending iSCSI PDUs of varying lengths. Unfortunately, TCP does not have a built-in mechanism for signaling message boundaries at the TCP layer. iSCSI overcomes this obstacle by placing the message length in the iSCSI message header. This serves to delineate the end of the current message as well as the beginning of the next message."
    },
    {
      "indent": 3,
      "text": "In situations where IP packets are delivered in order from the network, iSCSI message framing is not an issue and messages are processed one after the other. In the presence of IP packet reordering (i.e., frames being dropped), legacy TCP implementations store the \"out of order\" TCP segments in temporary buffers until the missing TCP segments arrive, at which time the data must be copied to the application buffers. In iSCSI, it is desirable to steer the SCSI data within these out-of-order TCP segments into the preallocated SCSI buffers rather than store them in temporary buffers. This decreases the need for dedicated reassembly buffers as well as the latency and bandwidth related to extra copies.",
      "zh-cn": "In situations where IP packets are delivered in order from the network, iSCSI message framing is not an issue and messages are processed one after the other. In the presence of IP packet reordering (i.e., frames being dropped), legacy TCP implementations store the \"out of order\" TCP segments in temporary buffers until the missing TCP segments arrive, at which time the data must be copied to the application buffers. In iSCSI, it is desirable to steer the SCSI data within these out-of-order TCP segments into the preallocated SCSI buffers rather than store them in temporary buffers. This decreases the need for dedicated reassembly buffers as well as the latency and bandwidth related to extra copies."
    },
    {
      "indent": 3,
      "text": "Relying solely on the \"message length\" information from the iSCSI message header may make it impossible to find iSCSI message boundaries in subsequent TCP segments due to the loss of a TCP segment that contains the iSCSI message length. The missing TCP segment(s) must be received before any of the following segments can be steered to the correct SCSI buffers (due to the inability to determine the iSCSI message boundaries). Since these segments cannot be steered to the correct location, they must be saved in temporary buffers that must then be copied to the SCSI buffers.",
      "zh-cn": "Relying solely on the \"message length\" information from the iSCSI message header may make it impossible to find iSCSI message boundaries in subsequent TCP segments due to the loss of a TCP segment that contains the iSCSI message length. The missing TCP segment(s) must be received before any of the following segments can be steered to the correct SCSI buffers (due to the inability to determine the iSCSI message boundaries). Since these segments cannot be steered to the correct location, they must be saved in temporary buffers that must then be copied to the SCSI buffers."
    },
    {
      "indent": 3,
      "text": "Different schemes can be used to recover synchronization. The details of any such schemes are beyond this protocol specification, but it suffices to note that [RFC4297] provides an overview of the direct data placement problem on IP networks, and [RFC5046] specifies a protocol extension for iSCSI that facilitates this direct data placement objective. The rest of this document refers to any such direct data placement protocol usage as an example of a \"Sync and Steering layer\".",
      "zh-cn": "Different schemes can be used to recover synchronization. The details of any such schemes are beyond this protocol specification, but it suffices to note that [RFC4297] provides an overview of the direct data placement problem on IP networks, and [RFC5046] specifies a protocol extension for iSCSI that facilitates this direct data placement objective. The rest of this document refers to any such direct data placement protocol usage as an example of a \"Sync and Steering layer\"."
    },
    {
      "indent": 3,
      "text": "Under normal circumstances (no PDU loss or data reception out of order), iSCSI data steering can be accomplished by using the identifying tag and the data offset fields in the iSCSI header in addition to the TCP sequence number from the TCP header. The identifying tag helps associate the PDU with a SCSI buffer address, while the data offset and TCP sequence number are used to determine the offset within the buffer.",
      "zh-cn": "Under normal circumstances (no PDU loss or data reception out of order), iSCSI data steering can be accomplished by using the identifying tag and the data offset fields in the iSCSI header in addition to the TCP sequence number from the TCP header. The identifying tag helps associate the PDU with a SCSI buffer address, while the data offset and TCP sequence number are used to determine the offset within the buffer."
    },
    {
      "indent": 0,
      "text": "4.2.9.1. Sync/Steering and iSCSI PDU Length",
      "section_title": true,
      "zh-cn": "4.2.9.1. Sync/Steering and iSCSI PDU Length"
    },
    {
      "indent": 3,
      "text": "When a large iSCSI message is sent, the TCP segment(s) that contains the iSCSI header may be lost. The remaining TCP segment(s) up to the next iSCSI message must be buffered (in temporary buffers) because the iSCSI header that indicates to which SCSI buffers the data are to be steered was lost. To minimize the amount of buffering, it is recommended that the iSCSI PDU length be restricted to a small value (perhaps a few TCP segments in length). During login, each end of the iSCSI session specifies the maximum iSCSI PDU length it will accept.",
      "zh-cn": "When a large iSCSI message is sent, the TCP segment(s) that contains the iSCSI header may be lost. The remaining TCP segment(s) up to the next iSCSI message must be buffered (in temporary buffers) because the iSCSI header that indicates to which SCSI buffers the data are to be steered was lost. To minimize the amount of buffering, it is recommended that the iSCSI PDU length be restricted to a small value (perhaps a few TCP segments in length). During login, each end of the iSCSI session specifies the maximum iSCSI PDU length it will accept."
    },
    {
      "indent": 0,
      "text": "4.3. iSCSI Session Types",
      "section_title": true,
      "zh-cn": "4.3. iSCSI Session Types"
    },
    {
      "indent": 3,
      "text": "iSCSI defines two types of sessions:",
      "zh-cn": "iSCSI defines two types of sessions:"
    },
    {
      "indent": 6,
      "text": "a) Normal operational session - an unrestricted session.",
      "zh-cn": "a) Normal operational session - an unrestricted session."
    },
    {
      "indent": 6,
      "text": "b) Discovery session - a session only opened for target discovery. The target MUST ONLY accept Text Requests with the SendTargets key and a Logout Request with reason \"close the session\". All other requests MUST be rejected.",
      "zh-cn": "b) Discovery session - a session only opened for target discovery. The target MUST ONLY accept Text Requests with the SendTargets key and a Logout Request with reason \"close the session\". All other requests MUST be rejected."
    },
    {
      "indent": 3,
      "text": "The session type is defined during login with the SessionType=value parameter in the login command.",
      "zh-cn": "The session type is defined during login with the SessionType=value parameter in the login command."
    },
    {
      "indent": 0,
      "text": "4.4. SCSI-to-iSCSI Concepts Mapping Model",
      "section_title": true,
      "zh-cn": "4.4. SCSI-to-iSCSI Concepts Mapping Model"
    },
    {
      "indent": 3,
      "text": "The following diagram shows an example of how multiple iSCSI nodes (targets in this case) can coexist within the same Network Entity and can share Network Portals (IP addresses and TCP ports). Other more complex configurations are also possible. For detailed descriptions of the components of these diagrams, see Section 4.4.1.",
      "zh-cn": "The following diagram shows an example of how multiple iSCSI nodes (targets in this case) can coexist within the same Network Entity and can share Network Portals (IP addresses and TCP ports). Other more complex configurations are also possible. For detailed descriptions of the components of these diagrams, see Section 4.4.1."
    },
    {
      "indent": 17,
      "text": "+-----------------------------------+\n| Network Entity (iSCSI Client)     |\n|                                   |\n|          +-------------+          |\n|          | iSCSI Node  |          |\n|          | (Initiator) |          |\n|          +-------------+          |\n|              |      |             |\n| +--------------+ +--------------+ |\n| |Network Portal| |Network Portal| |\n| |   192.0.2.4  | |   192.0.2.5  | |\n+-+--------------+-+--------------+-+\n         |                  |\n         |   IP Networks    |\n         |                  |\n+-+--------------+-+--------------+-+\n| |Network Portal| |Network Portal| |\n| |198.51.100.21 | |198.51.100.3  | |\n| | TCP Port 3260| | TCP Port 3260| |\n| +--------------+ +--------------+ |\n|        |                  |       |\n|         ------------------        |\n|            |          |           |\n| +-------------+ +--------------+  |\n| | iSCSI Node  | | iSCSI Node   |  |\n| | (Target)    | | (Target)     |  |\n| +-------------+ +--------------+  |\n|                                   |\n|   Network Entity (iSCSI Server)   |\n+-----------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "4.4.1. iSCSI Architecture Model",
      "section_title": true,
      "zh-cn": "4.4.1. iSCSI Architecture Model"
    },
    {
      "indent": 3,
      "text": "This section describes the part of the iSCSI Architecture Model that has the most bearing on the relationship between iSCSI and the SCSI Architecture Model.",
      "zh-cn": "This section describes the part of the iSCSI Architecture Model that has the most bearing on the relationship between iSCSI and the SCSI Architecture Model."
    },
    {
      "indent": 6,
      "text": "- Network Entity - represents a device or gateway that is accessible from the IP network. A Network Entity must have one or more Network Portals (see the \"Network Portal\" item below), each of which can be used by some iSCSI nodes (see the next item) contained in that Network Entity to gain access to the IP network.",
      "zh-cn": "- Network Entity - represents a device or gateway that is accessible from the IP network. A Network Entity must have one or more Network Portals (see the \"Network Portal\" item below), each of which can be used by some iSCSI nodes (see the next item) contained in that Network Entity to gain access to the IP network."
    },
    {
      "indent": 6,
      "text": "- iSCSI Node - represents a single iSCSI initiator or iSCSI target, or an instance of each. There are one or more iSCSI nodes within a Network Entity. The iSCSI node is accessible via one or more Network Portals (see below). An iSCSI node is identified by its iSCSI name (see Sections 4.2.7 and 13). The separation of the iSCSI name from the addresses used by and for the iSCSI node allows multiple iSCSI nodes to use the same addresses and allows the same iSCSI node to use multiple addresses.",
      "zh-cn": "- iSCSI Node - represents a single iSCSI initiator or iSCSI target, or an instance of each. There are one or more iSCSI nodes within a Network Entity. The iSCSI node is accessible via one or more Network Portals (see below). An iSCSI node is identified by its iSCSI name (see Sections 4.2.7 and 13). The separation of the iSCSI name from the addresses used by and for the iSCSI node allows multiple iSCSI nodes to use the same addresses and allows the same iSCSI node to use multiple addresses."
    },
    {
      "indent": 6,
      "text": "- An alias string may also be associated with an iSCSI node. The alias allows an organization to associate a user-friendly string with the iSCSI name. However, the alias string is not a substitute for the iSCSI name.",
      "zh-cn": "- An alias string may also be associated with an iSCSI node. The alias allows an organization to associate a user-friendly string with the iSCSI name. However, the alias string is not a substitute for the iSCSI name."
    },
    {
      "indent": 6,
      "text": "- Network Portal - a component of a Network Entity that has a TCP/IP network address and that may be used by an iSCSI node within that Network Entity for the connection(s) within one of its iSCSI sessions. In an initiator, it is identified by its IP address. In a target, it is identified by its IP address and its listening TCP port.",
      "zh-cn": "- Network Portal - a component of a Network Entity that has a TCP/IP network address and that may be used by an iSCSI node within that Network Entity for the connection(s) within one of its iSCSI sessions. In an initiator, it is identified by its IP address. In a target, it is identified by its IP address and its listening TCP port."
    },
    {
      "indent": 6,
      "text": "- Portal Groups - iSCSI supports multiple connections within the same session; some implementations will have the ability to combine connections in a session across multiple Network Portals. A portal group defines a set of Network Portals within an iSCSI node that collectively supports the capability of coordinating a session with connections that span these portals. Not all Network Portals within a portal group need to participate in every session connected through that portal group. One or more portal groups may provide access to an iSCSI node. Each Network Portal, as utilized by a given iSCSI node, belongs to exactly one portal group within that node. Portal groups are identified within an iSCSI node by a Portal Group Tag, a simple unsigned integer between 0 and 65535 (see",
      "zh-cn": "- Portal Groups - iSCSI supports multiple connections within the same session; some implementations will have the ability to combine connections in a session across multiple Network Portals. A portal group defines a set of Network Portals within an iSCSI node that collectively supports the capability of coordinating a session with connections that span these portals. Not all Network Portals within a portal group need to participate in every session connected through that portal group. One or more portal groups may provide access to an iSCSI node. Each Network Portal, as utilized by a given iSCSI node, belongs to exactly one portal group within that node. Portal groups are identified within an iSCSI node by a Portal Group Tag, a simple unsigned integer between 0 and 65535 (see"
    },
    {
      "indent": 8,
      "text": "Section 13.9). All Network Portals with the same Portal Group Tag in the context of a given iSCSI node are in the same portal group.",
      "zh-cn": "Section 13.9). All Network Portals with the same Portal Group Tag in the context of a given iSCSI node are in the same portal group."
    },
    {
      "indent": 8,
      "text": "Both iSCSI initiators and iSCSI targets have portal groups, though only the iSCSI target portal groups are used directly in the iSCSI protocol (e.g., in SendTargets). For references to the initiator portal Groups, see Section 10.1.2.",
      "zh-cn": "Both iSCSI initiators and iSCSI targets have portal groups, though only the iSCSI target portal groups are used directly in the iSCSI protocol (e.g., in SendTargets). For references to the initiator portal Groups, see Section 10.1.2."
    },
    {
      "indent": 6,
      "text": "- Portals within a portal group should support similar session parameters, because they may participate in a common session.",
      "zh-cn": "- Portals within a portal group should support similar session parameters, because they may participate in a common session."
    },
    {
      "indent": 3,
      "text": "The following diagram shows an example of one such configuration on a target and how a session that shares Network Portals within a portal group may be established.",
      "zh-cn": "The following diagram shows an example of one such configuration on a target and how a session that shares Network Portals within a portal group may be established."
    },
    {
      "indent": 5,
      "text": "  ----------------------------IP Network---------------------\n         |                |                  |\n    +----|----------------|----+        +----|---------+\n    | +---------+ +---------+  |        | +---------+  |\n    | | Network | | Network |  |        | | Network |  |\n    | | Portal  | | Portal  |  |        | | Portal  |  |\n    | +---------+ +---------+  |        | +---------+  |\n    |    |                |    |        |    |         |\n    |    |    Portal      |    |        |    | Portal  |\n    |    |    Group 1     |    |        |    | Group 2 |\n    +--------------------------+        +--------------+\n         |                |                  |\n+--------|----------------|------------------|------------------+\n|        |                |                  |                  |\n| +----------------------------+ +----------------------------+ |\n| | iSCSI Session (Target side)| | iSCSI Session (Target side)| |\n| |                            | |                            | |\n| |        (TSIH = 56)         | |        (TSIH = 48)         | |\n| +----------------------------+ +----------------------------+ |\n|                                                               |\n|                      iSCSI Target Node                        |\n|             (within Network Entity, not shown)                |\n+---------------------------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "4.4.2. SCSI Architecture Model",
      "section_title": true,
      "zh-cn": "4.4.2. SCSI Architecture Model"
    },
    {
      "indent": 3,
      "text": "This section describes the relationship between the SCSI Architecture Model [SAM2] and constructs of the SCSI device, SCSI port and I_T nexus, and the iSCSI constructs described in Section 4.4.1.",
      "zh-cn": "This section describes the relationship between the SCSI Architecture Model [SAM2] and constructs of the SCSI device, SCSI port and I_T nexus, and the iSCSI constructs described in Section 4.4.1."
    },
    {
      "indent": 3,
      "text": "This relationship implies implementation requirements in order to conform to the SAM-2 model and other SCSI operational functions.",
      "zh-cn": "This relationship implies implementation requirements in order to conform to the SAM-2 model and other SCSI operational functions."
    },
    {
      "indent": 3,
      "text": "These requirements are detailed in Section 4.4.3.",
      "zh-cn": "These requirements are detailed in Section 4.4.3."
    },
    {
      "indent": 3,
      "text": "The following list outlines mappings of SCSI architectural elements to iSCSI.",
      "zh-cn": "The following list outlines mappings of SCSI architectural elements to iSCSI."
    },
    {
      "indent": 6,
      "text": "a) SCSI Device - This is the SAM-2 term for an entity that contains one or more SCSI ports that are connected to a service delivery subsystem and supports a SCSI application protocol. For example, a SCSI initiator device contains one or more SCSI initiator ports and zero or more application clients. A SCSI target device contains one or more SCSI target ports and one or more LUs. For iSCSI, the SCSI device is the component within an iSCSI node that provides the SCSI functionality. As such, there can be at most one SCSI device within an iSCSI node. Access to the SCSI device can only be achieved in an iSCSI Normal operational session (see Section 4.3). The SCSI device name is defined to be the iSCSI name of the node and MUST be used in the iSCSI protocol.",
      "zh-cn": "a) SCSI Device - This is the SAM-2 term for an entity that contains one or more SCSI ports that are connected to a service delivery subsystem and supports a SCSI application protocol. For example, a SCSI initiator device contains one or more SCSI initiator ports and zero or more application clients. A SCSI target device contains one or more SCSI target ports and one or more LUs. For iSCSI, the SCSI device is the component within an iSCSI node that provides the SCSI functionality. As such, there can be at most one SCSI device within an iSCSI node. Access to the SCSI device can only be achieved in an iSCSI Normal operational session (see Section 4.3). The SCSI device name is defined to be the iSCSI name of the node and MUST be used in the iSCSI protocol."
    },
    {
      "indent": 6,
      "text": "b) SCSI Port - This is the SAM-2 term for an entity in a SCSI device that provides the SCSI functionality to interface with a service delivery subsystem or transport. For iSCSI, the definitions of the SCSI initiator port and the SCSI target port are different.",
      "zh-cn": "b) SCSI Port - This is the SAM-2 term for an entity in a SCSI device that provides the SCSI functionality to interface with a service delivery subsystem or transport. For iSCSI, the definitions of the SCSI initiator port and the SCSI target port are different."
    },
    {
      "indent": 9,
      "text": "SCSI initiator port: This maps to one endpoint of an iSCSI Normal operational session (see Section 4.3). An iSCSI Normal operational session is negotiated through the login process between an iSCSI initiator node and an iSCSI target node. At successful completion of this process, a SCSI initiator port is created within the SCSI initiator device. The SCSI initiator port Name and SCSI initiator port Identifier are both defined to be the iSCSI Initiator Name together with (a) a label that identifies it as an initiator port name/identifier and (b) the ISID portion of the session identifier.",
      "zh-cn": "SCSI initiator port: This maps to one endpoint of an iSCSI Normal operational session (see Section 4.3). An iSCSI Normal operational session is negotiated through the login process between an iSCSI initiator node and an iSCSI target node. At successful completion of this process, a SCSI initiator port is created within the SCSI initiator device. The SCSI initiator port Name and SCSI initiator port Identifier are both defined to be the iSCSI Initiator Name together with (a) a label that identifies it as an initiator port name/identifier and (b) the ISID portion of the session identifier."
    },
    {
      "indent": 9,
      "text": "SCSI target port: This maps to an iSCSI target portal group. The SCSI Target Port Name and the SCSI Target Port Identifier are both defined to be the iSCSI Target Name together with (a) a label that identifies it as a target port name/identifier and (b) the Target Portal Group Tag.",
      "zh-cn": "SCSI target port: This maps to an iSCSI target portal group. The SCSI Target Port Name and the SCSI Target Port Identifier are both defined to be the iSCSI Target Name together with (a) a label that identifies it as a target port name/identifier and (b) the Target Portal Group Tag."
    },
    {
      "indent": 9,
      "text": "The SCSI port name MUST be used in iSCSI. When used in SCSI parameter data, the SCSI port name MUST be encoded as:",
      "zh-cn": "The SCSI port name MUST be used in iSCSI. When used in SCSI parameter data, the SCSI port name MUST be encoded as:"
    },
    {
      "indent": 9,
      "text": "1) the iSCSI name in UTF-8 format, followed by",
      "zh-cn": "1) the iSCSI name in UTF-8 format, followed by"
    },
    {
      "indent": 9,
      "text": "2) a comma separator (1 byte), followed by",
      "zh-cn": "2) a comma separator (1 byte), followed by"
    },
    {
      "indent": 9,
      "text": "3) the ASCII character 'i' (for SCSI initiator port) or the ASCII character 't' (for SCSI target port) (1 byte), followed by",
      "zh-cn": "3) the ASCII character 'i' (for SCSI initiator port) or the ASCII character 't' (for SCSI target port) (1 byte), followed by"
    },
    {
      "indent": 9,
      "text": "4) a comma separator (1 byte), followed by",
      "zh-cn": "4) a comma separator (1 byte), followed by"
    },
    {
      "indent": 9,
      "text": "5) a text encoding as a hex-constant (see Section 6.1) of the ISID (for SCSI initiator port) or the Target Portal Group Tag (for SCSI target port), including the initial 0X or 0x and the terminating null (15 bytes for iSCSI initiator port, 7 bytes for iSCSI target port).",
      "zh-cn": "5) a text encoding as a hex-constant (see Section 6.1) of the ISID (for SCSI initiator port) or the Target Portal Group Tag (for SCSI target port), including the initial 0X or 0x and the terminating null (15 bytes for iSCSI initiator port, 7 bytes for iSCSI target port)."
    },
    {
      "indent": 12,
      "text": "The ASCII character 'i' or 't' is the label that identifies this port as either a SCSI initiator port or a SCSI target port.",
      "zh-cn": "The ASCII character 'i' or 't' is the label that identifies this port as either a SCSI initiator port or a SCSI target port."
    },
    {
      "indent": 6,
      "text": "c) I_T nexus - This indicates a relationship between a SCSI initiator port and a SCSI target port, according to [SAM2]. For iSCSI, this relationship is a session, defined as a relationship between an iSCSI initiator's end of the session (SCSI initiator port) and the iSCSI target's portal group. The I_T nexus can be identified by the conjunction of the SCSI port names or by the iSCSI session identifier (SSID). iSCSI defines the I_T nexus identifier to be the tuple (iSCSI Initiator Name + \",i,0x\" + ISID in text format, iSCSI Target Name + \",t,0x\" + Target Portal Group Tag in text format). An uppercase hex prefix \"0X\" may alternatively be used in place of \"0x\".",
      "zh-cn": "c) I_T nexus - This indicates a relationship between a SCSI initiator port and a SCSI target port, according to [SAM2]. For iSCSI, this relationship is a session, defined as a relationship between an iSCSI initiator's end of the session (SCSI initiator port) and the iSCSI target's portal group. The I_T nexus can be identified by the conjunction of the SCSI port names or by the iSCSI session identifier (SSID). iSCSI defines the I_T nexus identifier to be the tuple (iSCSI Initiator Name + \",i,0x\" + ISID in text format, iSCSI Target Name + \",t,0x\" + Target Portal Group Tag in text format). An uppercase hex prefix \"0X\" may alternatively be used in place of \"0x\"."
    },
    {
      "indent": 9,
      "text": "NOTE: The I_T nexus identifier is not equal to the SSID.",
      "zh-cn": "NOTE: The I_T nexus identifier is not equal to the SSID."
    },
    {
      "indent": 0,
      "text": "4.4.3. Consequences of the Model",
      "section_title": true,
      "zh-cn": "4.4.3. Consequences of the Model"
    },
    {
      "indent": 3,
      "text": "This section describes implementation and behavioral requirements that result from the mapping of SCSI constructs to the iSCSI constructs defined above. Between a given SCSI initiator port and a given SCSI target port, only one I_T nexus (session) can exist. No more than one nexus relationship (parallel nexus) is allowed by [SAM2]. Therefore, at any given time, only one session with the same SSID can exist between a given iSCSI initiator node and an iSCSI target node.",
      "zh-cn": "This section describes implementation and behavioral requirements that result from the mapping of SCSI constructs to the iSCSI constructs defined above. Between a given SCSI initiator port and a given SCSI target port, only one I_T nexus (session) can exist. No more than one nexus relationship (parallel nexus) is allowed by [SAM2]. Therefore, at any given time, only one session with the same SSID can exist between a given iSCSI initiator node and an iSCSI target node."
    },
    {
      "indent": 3,
      "text": "These assumptions lead to the following conclusions and requirements:",
      "zh-cn": "These assumptions lead to the following conclusions and requirements:"
    },
    {
      "indent": 3,
      "text": "ISID RULE: Between a given iSCSI initiator and iSCSI target portal group (SCSI target port), there can only be one session with a given value for the ISID that identifies the SCSI initiator port. See Section 11.12.5.",
      "zh-cn": "ISID RULE: Between a given iSCSI initiator and iSCSI target portal group (SCSI target port), there can only be one session with a given value for the ISID that identifies the SCSI initiator port. See Section 11.12.5."
    },
    {
      "indent": 3,
      "text": "The structure of the ISID that contains a naming authority component (see Section 11.12.5 and [RFC3721]) provides a mechanism to facilitate compliance with the ISID RULE. See Section 10.1.1.",
      "zh-cn": "The structure of the ISID that contains a naming authority component (see Section 11.12.5 and [RFC3721]) provides a mechanism to facilitate compliance with the ISID RULE. See Section 10.1.1."
    },
    {
      "indent": 3,
      "text": "The iSCSI initiator node should manage the assignment of ISIDs prior to session initiation. The \"ISID RULE\" does not preclude the use of the same ISID from the same iSCSI initiator with different target portal groups on the same iSCSI target or on other iSCSI targets (see Section 10.1.1). Allowing this would be analogous to a single SCSI initiator port having relationships (nexus) with multiple SCSI target ports on the same SCSI target device or SCSI target ports on other SCSI target devices. It is also possible to have multiple sessions with different ISIDs to the same target portal group. Each such session would be considered to be with a different initiator even when the sessions originate from the same initiator device. The same ISID may be used by a different iSCSI initiator because it is the iSCSI name together with the ISID that identifies the SCSI initiator port.",
      "zh-cn": "The iSCSI initiator node should manage the assignment of ISIDs prior to session initiation. The \"ISID RULE\" does not preclude the use of the same ISID from the same iSCSI initiator with different target portal groups on the same iSCSI target or on other iSCSI targets (see Section 10.1.1). Allowing this would be analogous to a single SCSI initiator port having relationships (nexus) with multiple SCSI target ports on the same SCSI target device or SCSI target ports on other SCSI target devices. It is also possible to have multiple sessions with different ISIDs to the same target portal group. Each such session would be considered to be with a different initiator even when the sessions originate from the same initiator device. The same ISID may be used by a different iSCSI initiator because it is the iSCSI name together with the ISID that identifies the SCSI initiator port."
    },
    {
      "indent": 3,
      "text": "NOTE: A consequence of the ISID RULE and the specification for the I_T nexus identifier is that two nexuses with the same identifier should never exist at the same time.",
      "zh-cn": "NOTE: A consequence of the ISID RULE and the specification for the I_T nexus identifier is that two nexuses with the same identifier should never exist at the same time."
    },
    {
      "indent": 3,
      "text": "TSIH RULE: The iSCSI target selects a non-zero value for the TSIH at session creation (when an initiator presents a 0 value at login). After being selected, the same TSIH value MUST be used whenever the initiator or target refers to the session and a TSIH is required.",
      "zh-cn": "TSIH RULE: The iSCSI target selects a non-zero value for the TSIH at session creation (when an initiator presents a 0 value at login). After being selected, the same TSIH value MUST be used whenever the initiator or target refers to the session and a TSIH is required."
    },
    {
      "indent": 0,
      "text": "4.4.3.1. I_T Nexus State",
      "section_title": true,
      "zh-cn": "4.4.3.1. I_T Nexus State"
    },
    {
      "indent": 3,
      "text": "Certain nexus relationships contain an explicit state (e.g., initiator-specific mode pages) that may need to be preserved by the device server [SAM2] in a LU through changes or failures in the iSCSI layer (e.g., session failures). In order for that state to be restored, the iSCSI initiator should reestablish its session (re-login) to the same target portal group using the previous ISID. That is, it should reinstate the session via iSCSI session reinstatement (Section 6.3.5) or continue via session continuation (Section 6.3.6). This is because the SCSI initiator port identifier and the SCSI target port identifier (or relative target port) form the datum that the SCSI LU device server uses to identify the I_T nexus.",
      "zh-cn": "Certain nexus relationships contain an explicit state (e.g., initiator-specific mode pages) that may need to be preserved by the device server [SAM2] in a LU through changes or failures in the iSCSI layer (e.g., session failures). In order for that state to be restored, the iSCSI initiator should reestablish its session (re-login) to the same target portal group using the previous ISID. That is, it should reinstate the session via iSCSI session reinstatement (Section 6.3.5) or continue via session continuation (Section 6.3.6). This is because the SCSI initiator port identifier and the SCSI target port identifier (or relative target port) form the datum that the SCSI LU device server uses to identify the I_T nexus."
    },
    {
      "indent": 0,
      "text": "4.4.3.2. Reservations",
      "section_title": true,
      "zh-cn": "4.4.3.2. Reservations"
    },
    {
      "indent": 3,
      "text": "There are two reservation management methods defined in the SCSI standards: reserve/release reservations, based on the RESERVE and RELEASE commands [SPC2]; and persistent reservations, based on the PERSISTENT RESERVE IN and PERSISTENT RESERVE OUT commands [SPC3]. Reserve/release reservations are obsolete [SPC3] and should not be used. Persistent reservations are suggested as an alternative; see Annex B of [SPC4].",
      "zh-cn": "There are two reservation management methods defined in the SCSI standards: reserve/release reservations, based on the RESERVE and RELEASE commands [SPC2]; and persistent reservations, based on the PERSISTENT RESERVE IN and PERSISTENT RESERVE OUT commands [SPC3]. Reserve/release reservations are obsolete [SPC3] and should not be used. Persistent reservations are suggested as an alternative; see Annex B of [SPC4]."
    },
    {
      "indent": 3,
      "text": "State for persistent reservations is required to persist through changes and failures at the iSCSI layer that result in I_T nexus failures; see [SPC3] for details and specific requirements.",
      "zh-cn": "State for persistent reservations is required to persist through changes and failures at the iSCSI layer that result in I_T nexus failures; see [SPC3] for details and specific requirements."
    },
    {
      "indent": 3,
      "text": "In contrast, [SPC2] does not specify detailed persistence requirements for reserve/release reservation state after an I_T nexus failure. Nonetheless, when reserve/release reservations are supported by an iSCSI target, the preferred implementation approach is to preserve reserve/release reservation state for iSCSI session reinstatement (see Section 6.3.5) or session continuation (see Section 6.3.6).",
      "zh-cn": "In contrast, [SPC2] does not specify detailed persistence requirements for reserve/release reservation state after an I_T nexus failure. Nonetheless, when reserve/release reservations are supported by an iSCSI target, the preferred implementation approach is to preserve reserve/release reservation state for iSCSI session reinstatement (see Section 6.3.5) or session continuation (see Section 6.3.6)."
    },
    {
      "indent": 3,
      "text": "Two additional caveats apply to reserve/release reservations:",
      "zh-cn": "Two additional caveats apply to reserve/release reservations:"
    },
    {
      "indent": 6,
      "text": "- Retention of a failed session's reserve/release reservation state by an iSCSI target, even after that failed iSCSI session is not reinstated or continued, may require an initiator to issue a reset (e.g., LOGICAL UNIT RESET; see Section 11.5) in order to remove that reservation state.",
      "zh-cn": "- Retention of a failed session's reserve/release reservation state by an iSCSI target, even after that failed iSCSI session is not reinstated or continued, may require an initiator to issue a reset (e.g., LOGICAL UNIT RESET; see Section 11.5) in order to remove that reservation state."
    },
    {
      "indent": 6,
      "text": "- Reserve/release reservations may not behave as expected when persistent reservations are also used on the same LU; see the discussion of \"Exceptions to SPC-2 RESERVE and RELEASE behavior\" in [SPC4].",
      "zh-cn": "- Reserve/release reservations may not behave as expected when persistent reservations are also used on the same LU; see the discussion of \"Exceptions to SPC-2 RESERVE and RELEASE behavior\" in [SPC4]."
    },
    {
      "indent": 0,
      "text": "4.5. iSCSI UML Model",
      "section_title": true,
      "zh-cn": "4.5. iSCSI UML Model"
    },
    {
      "indent": 3,
      "text": "This section presents the application of the UML modeling concepts discussed in Section 3 to the iSCSI and SCSI Architecture Model discussed in Section 4.4.",
      "zh-cn": "This section presents the application of the UML modeling concepts discussed in Section 3 to the iSCSI and SCSI Architecture Model discussed in Section 4.4."
    },
    {
      "indent": 5,
      "text": "                  +----------------+\n                  | Network Entity |\n                  +----------------+\n                       @ 1     @ 1\n                       |       |\n+----------------------+       |\n|                              |\n|                              | 0..*\n|                   +------------------+\n|                   | iSCSI Node       |\n|                   +------------------+\n|                       @       @\n|                       |       |\n|           +-----------+ =(a)= +-----------+\n|           |                               |\n|           | 0..1                          | 0..1\n| +------------------------+       +----------------------+\n| |    iSCSI Target Node   |       | iSCSI Initiator Node |\n| +------------------------+       +----------------------+\n|             @ 1                            @ 1\n|             +---------------+              |\n|                        1..* |              | 1..*\n|                    +-----------------------------+\n|                    |         Portal Group        |\n|                    +-----------------------------+\n|                                     O 1\n|                                     |\n|                                     | 1..*\n|               1..* +------------------------+\n+--------------------|        Network Portal  |\n                     +------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(a) Each instance of an iSCSI node class MUST contain one iSCSI target node instance, one iSCSI initiator node instance, or both.",
      "zh-cn": "(a) Each instance of an iSCSI node class MUST contain one iSCSI target node instance, one iSCSI initiator node instance, or both."
    },
    {
      "indent": 3,
      "text": "                 +----------------+\n                 | Network Entity |\n                 +----------------+\n                      @ 1         @ 1\n                      |           |              +------------------+\n+---------------------+           |              |   iSCSI Session  |\n|                                 |              +------------------+\n|                                 | 0..*         |     SSID[1]      |\n|                  +--------------------+        |     ISID[1]      |\n|                  |      iSCSI Node    |        +------------------+\n|                  +--------------------+                   @ 1\n|                  | iSCSI Node Name[1] |                   |\n|                  |    Alias [0..1]    |                   | 0..*\n|                  +--------------------+        +------------------+\n|                  |                    |        | iSCSI Connection |\n|                  +--------------------+        +------------------+\n|                         @ 1         @ 1        |      CID[1]      |\n|                         |           |          +------------------+\n|           +-------------+ ==(b)==   +---------+              0..* |\n|           | 1                                 | 1                 |\n| +------------------------+             +------------------------+ |\n| |   iSCSI Target Node    |             | iSCSI Initiator Node   | |\n| +------------------------+             +------------------------+ |\n| | iSCSI Target Name [1]  |             |iSCSI Initiator Name [1]| |\n| +------------------------+             +------------------------+ |\n|            @ 1                                    @ 1             |\n|            | 1..*                                 | 1..*          |\n| +--------------------------+           +------------------------+ |\n| |   Target Portal Group    |           | Initiator Portal Group | |\n| +--------------------------+           +------------------------+ |\n| |Target Portal Group Tag[1]|           | Portal Group Tag[1]    | |\n| +--------------------------+           +------------------------+ |\n|            o 1                                    o 1             |\n|            +------------+              +----------+               |\n|                    1..* |              | 1..*                     |\n|                +-------------------------+                        |\n|                |          Network Portal |                        |\n|                +-------------------------+                        |\n|          1..*  |         IP Address [1]  | 1                      |\n+----------------|         TCP Port [0..1] |<-----------------------+\n                 +-------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(b) Each instance of an iSCSI node class MUST contain one iSCSI target node instance, one iSCSI initiator node instance, or both. However, in all scenarios, note that an iSCSI node MUST only have a single iSCSI name. Note the related requirement in Section 4.2.7.1.",
      "zh-cn": "(b) Each instance of an iSCSI node class MUST contain one iSCSI target node instance, one iSCSI initiator node instance, or both. However, in all scenarios, note that an iSCSI node MUST only have a single iSCSI name. Note the related requirement in Section 4.2.7.1."
    },
    {
      "indent": 0,
      "text": "4.6. Request/Response Summary",
      "section_title": true,
      "zh-cn": "4.6. Request/Response Summary"
    },
    {
      "indent": 3,
      "text": "This section lists and briefly describes all the iSCSI PDU types (requests and responses).",
      "zh-cn": "This section lists and briefly describes all the iSCSI PDU types (requests and responses)."
    },
    {
      "indent": 3,
      "text": "All iSCSI PDUs are built as a set of one or more header segments (basic and auxiliary) and zero or one data segments. The header group and the data segment may each be followed by a CRC (digest).",
      "zh-cn": "All iSCSI PDUs are built as a set of one or more header segments (basic and auxiliary) and zero or one data segments. The header group and the data segment may each be followed by a CRC (digest)."
    },
    {
      "indent": 3,
      "text": "The basic header segment has a fixed length of 48 bytes.",
      "zh-cn": "The basic header segment has a fixed length of 48 bytes."
    },
    {
      "indent": 0,
      "text": "4.6.1. Request/Response Types Carrying SCSI Payload",
      "section_title": true,
      "zh-cn": "4.6.1. Request/Response Types Carrying SCSI Payload"
    },
    {
      "indent": 0,
      "text": "4.6.1.1. SCSI Command",
      "section_title": true,
      "zh-cn": "4.6.1.1. SCSI Command"
    },
    {
      "indent": 3,
      "text": "This request carries the SCSI CDB and all the other SCSI Execute Command [SAM2] procedure call IN arguments, such as task attributes, Expected Data Transfer Length for one or both transfer directions (the latter for bidirectional commands), and a task tag (as part of the I_T_L_x nexus). The I_T_L nexus is derived by the initiator and target from the LUN field in the request, and the I_T nexus is implicit in the session identification.",
      "zh-cn": "This request carries the SCSI CDB and all the other SCSI Execute Command [SAM2] procedure call IN arguments, such as task attributes, Expected Data Transfer Length for one or both transfer directions (the latter for bidirectional commands), and a task tag (as part of the I_T_L_x nexus). The I_T_L nexus is derived by the initiator and target from the LUN field in the request, and the I_T nexus is implicit in the session identification."
    },
    {
      "indent": 3,
      "text": "In addition, the SCSI Command PDU carries information required for the proper operation of the iSCSI protocol -- the command sequence number (CmdSN) and the expected status sequence number (ExpStatSN) on the connection it is issued.",
      "zh-cn": "In addition, the SCSI Command PDU carries information required for the proper operation of the iSCSI protocol -- the command sequence number (CmdSN) and the expected status sequence number (ExpStatSN) on the connection it is issued."
    },
    {
      "indent": 3,
      "text": "All or part of the SCSI output (write) data associated with the SCSI command may be sent as part of the SCSI Command PDU as a data segment.",
      "zh-cn": "All or part of the SCSI output (write) data associated with the SCSI command may be sent as part of the SCSI Command PDU as a data segment."
    },
    {
      "indent": 0,
      "text": "4.6.1.2. SCSI Response",
      "section_title": true,
      "zh-cn": "4.6.1.2. SCSI Response"
    },
    {
      "indent": 3,
      "text": "The SCSI Response carries all the SCSI Execute Command procedure call (see [SAM2]) OUT arguments and the SCSI Execute Command procedure call return value.",
      "zh-cn": "The SCSI Response carries all the SCSI Execute Command procedure call (see [SAM2]) OUT arguments and the SCSI Execute Command procedure call return value."
    },
    {
      "indent": 3,
      "text": "The SCSI Response contains the residual counts from the operation, if any; an indication of whether the counts represent an overflow or an underflow; and the SCSI status if the status is valid or a response code (a non-zero return value for the Execute Command procedure call) if the status is not valid.",
      "zh-cn": "The SCSI Response contains the residual counts from the operation, if any; an indication of whether the counts represent an overflow or an underflow; and the SCSI status if the status is valid or a response code (a non-zero return value for the Execute Command procedure call) if the status is not valid."
    },
    {
      "indent": 3,
      "text": "For a valid status that indicates that the command has been processed but resulted in an exception (e.g., a SCSI CHECK CONDITION), the PDU data segment contains the associated sense data. The use of Autosense ([SAM2]) is REQUIRED by iSCSI.",
      "zh-cn": "For a valid status that indicates that the command has been processed but resulted in an exception (e.g., a SCSI CHECK CONDITION), the PDU data segment contains the associated sense data. The use of Autosense ([SAM2]) is REQUIRED by iSCSI."
    },
    {
      "indent": 3,
      "text": "Some data segment content may also be associated (in the data segment) with a non-zero response code.",
      "zh-cn": "Some data segment content may also be associated (in the data segment) with a non-zero response code."
    },
    {
      "indent": 3,
      "text": "In addition, the SCSI Response PDU carries information required for the proper operation of the iSCSI protocol:",
      "zh-cn": "In addition, the SCSI Response PDU carries information required for the proper operation of the iSCSI protocol:"
    },
    {
      "indent": 6,
      "text": "- ExpDataSN - the number of Data-In PDUs that a target has sent (to enable the initiator to check that all have arrived)",
      "zh-cn": "- ExpDataSN - the number of Data-In PDUs that a target has sent (to enable the initiator to check that all have arrived)"
    },
    {
      "indent": 6,
      "text": "- StatSN - the status sequence number on this connection",
      "zh-cn": "- StatSN - the status sequence number on this connection"
    },
    {
      "indent": 6,
      "text": "- ExpCmdSN - the next expected command sequence number at the target",
      "zh-cn": "- ExpCmdSN - the next expected command sequence number at the target"
    },
    {
      "indent": 6,
      "text": "- MaxCmdSN - the maximum CmdSN acceptable at the target from this initiator",
      "zh-cn": "- MaxCmdSN - the maximum CmdSN acceptable at the target from this initiator"
    },
    {
      "indent": 0,
      "text": "4.6.1.3. Task Management Function Request",
      "section_title": true,
      "zh-cn": "4.6.1.3. Task Management Function Request"
    },
    {
      "indent": 3,
      "text": "The Task Management Function Request provides an initiator with a way to explicitly control the execution of one or more SCSI tasks or iSCSI functions. The PDU carries a function identifier (i.e., which task management function to perform) and enough information to unequivocally identify the task or task set on which to perform the action, even if the task(s) to act upon has not yet arrived or has been discarded due to an error.",
      "zh-cn": "The Task Management Function Request provides an initiator with a way to explicitly control the execution of one or more SCSI tasks or iSCSI functions. The PDU carries a function identifier (i.e., which task management function to perform) and enough information to unequivocally identify the task or task set on which to perform the action, even if the task(s) to act upon has not yet arrived or has been discarded due to an error."
    },
    {
      "indent": 3,
      "text": "The referenced tag identifies an individual task if the function refers to an individual task.",
      "zh-cn": "The referenced tag identifies an individual task if the function refers to an individual task."
    },
    {
      "indent": 3,
      "text": "The I_T_L nexus identifies task sets. In iSCSI, the I_T_L nexus is identified by the LUN and the session identification (the session identifies an I_T nexus).",
      "zh-cn": "The I_T_L nexus identifies task sets. In iSCSI, the I_T_L nexus is identified by the LUN and the session identification (the session identifies an I_T nexus)."
    },
    {
      "indent": 3,
      "text": "For task sets, the CmdSN of the Task Management Function Request helps identify the tasks upon which to act, namely all tasks associated with a LUN and having a CmdSN preceding the Task Management Function Request CmdSN.",
      "zh-cn": "For task sets, the CmdSN of the Task Management Function Request helps identify the tasks upon which to act, namely all tasks associated with a LUN and having a CmdSN preceding the Task Management Function Request CmdSN."
    },
    {
      "indent": 3,
      "text": "For a task management function, the coordination between responses to the tasks affected and the Task Management Function Response is done by the target.",
      "zh-cn": "For a task management function, the coordination between responses to the tasks affected and the Task Management Function Response is done by the target."
    },
    {
      "indent": 0,
      "text": "4.6.1.4. Task Management Function Response",
      "section_title": true,
      "zh-cn": "4.6.1.4. Task Management Function Response"
    },
    {
      "indent": 3,
      "text": "The Task Management Function Response carries an indication of function completion for a Task Management Function Request, including how it completed (response and qualifier) and additional information for failure responses.",
      "zh-cn": "The Task Management Function Response carries an indication of function completion for a Task Management Function Request, including how it completed (response and qualifier) and additional information for failure responses."
    },
    {
      "indent": 3,
      "text": "After the Task Management Function Response indicates task management function completion, the initiator will not receive any additional responses from the affected tasks.",
      "zh-cn": "After the Task Management Function Response indicates task management function completion, the initiator will not receive any additional responses from the affected tasks."
    },
    {
      "indent": 0,
      "text": "4.6.1.5. SCSI Data-Out and SCSI Data-In",
      "section_title": true,
      "zh-cn": "4.6.1.5. SCSI Data-Out and SCSI Data-In"
    },
    {
      "indent": 3,
      "text": "SCSI Data-Out and SCSI Data-In are the main vehicles by which SCSI data payload is carried between the initiator and target. Data payload is associated with a specific SCSI command through the Initiator Task Tag. For target convenience, outgoing solicited data also carries a Target Transfer Tag (copied from R2T) and the LUN. Each PDU contains the payload length and the data offset relative to the buffer address contained in the SCSI Execute Command procedure call.",
      "zh-cn": "SCSI Data-Out and SCSI Data-In are the main vehicles by which SCSI data payload is carried between the initiator and target. Data payload is associated with a specific SCSI command through the Initiator Task Tag. For target convenience, outgoing solicited data also carries a Target Transfer Tag (copied from R2T) and the LUN. Each PDU contains the payload length and the data offset relative to the buffer address contained in the SCSI Execute Command procedure call."
    },
    {
      "indent": 3,
      "text": "In each direction, the data transfer is split into \"sequences\". An end-of-sequence is indicated by the F bit.",
      "zh-cn": "In each direction, the data transfer is split into \"sequences\". An end-of-sequence is indicated by the F bit."
    },
    {
      "indent": 3,
      "text": "An outgoing sequence is either unsolicited (only the first sequence can be unsolicited) or consists of all the Data-Out PDUs sent in response to an R2T.",
      "zh-cn": "An outgoing sequence is either unsolicited (only the first sequence can be unsolicited) or consists of all the Data-Out PDUs sent in response to an R2T."
    },
    {
      "indent": 3,
      "text": "Input sequences enable the switching of direction for bidirectional commands as required.",
      "zh-cn": "Input sequences enable the switching of direction for bidirectional commands as required."
    },
    {
      "indent": 3,
      "text": "For input, the target may request positive acknowledgment of input data. This is limited to sessions that support error recovery and is implemented through the A bit in the SCSI Data-In PDU header.",
      "zh-cn": "For input, the target may request positive acknowledgment of input data. This is limited to sessions that support error recovery and is implemented through the A bit in the SCSI Data-In PDU header."
    },
    {
      "indent": 3,
      "text": "Data-In and Data-Out PDUs also carry the DataSN to enable the initiator and target to detect missing PDUs (discarded due to an error).",
      "zh-cn": "Data-In and Data-Out PDUs also carry the DataSN to enable the initiator and target to detect missing PDUs (discarded due to an error)."
    },
    {
      "indent": 3,
      "text": "In addition, the StatSN is carried by the Data-In PDUs.",
      "zh-cn": "In addition, the StatSN is carried by the Data-In PDUs."
    },
    {
      "indent": 3,
      "text": "To enable a SCSI command to be processed while involving a minimum number of messages, the last SCSI Data-In PDU passed for a command may also contain the status if the status indicates termination with no exceptions (no sense or response involved).",
      "zh-cn": "To enable a SCSI command to be processed while involving a minimum number of messages, the last SCSI Data-In PDU passed for a command may also contain the status if the status indicates termination with no exceptions (no sense or response involved)."
    },
    {
      "indent": 0,
      "text": "4.6.1.6. Ready To Transfer (R2T)",
      "section_title": true,
      "zh-cn": "4.6.1.6. Ready To Transfer (R2T)"
    },
    {
      "indent": 3,
      "text": "R2T is the mechanism by which the SCSI target \"requests\" the initiator for output data. R2T specifies to the initiator the offset of the requested data relative to the buffer address from the Execute Command procedure call and the length of the solicited data.",
      "zh-cn": "R2T is the mechanism by which the SCSI target \"requests\" the initiator for output data. R2T specifies to the initiator the offset of the requested data relative to the buffer address from the Execute Command procedure call and the length of the solicited data."
    },
    {
      "indent": 3,
      "text": "To help the SCSI target associate the resulting Data-Out with an R2T, the R2T carries a Target Transfer Tag that will be copied by the initiator in the solicited SCSI Data-Out PDUs. There are no protocol-specific requirements with regard to the value of these tags, but it is assumed that together with the LUN, they will enable the target to associate data with an R2T.",
      "zh-cn": "To help the SCSI target associate the resulting Data-Out with an R2T, the R2T carries a Target Transfer Tag that will be copied by the initiator in the solicited SCSI Data-Out PDUs. There are no protocol-specific requirements with regard to the value of these tags, but it is assumed that together with the LUN, they will enable the target to associate data with an R2T."
    },
    {
      "indent": 3,
      "text": "R2T also carries information required for proper operation of the iSCSI protocol, such as:",
      "zh-cn": "R2T also carries information required for proper operation of the iSCSI protocol, such as:"
    },
    {
      "indent": 6,
      "text": "- R2TSN (to enable an initiator to detect a missing R2T)",
      "zh-cn": "- R2TSN (to enable an initiator to detect a missing R2T)"
    },
    {
      "indent": 6,
      "text": "- StatSN",
      "zh-cn": "- StatSN"
    },
    {
      "indent": 6,
      "text": "- ExpCmdSN",
      "zh-cn": "- ExpCmdSN"
    },
    {
      "indent": 6,
      "text": "- MaxCmdSN",
      "zh-cn": "- MaxCmdSN"
    },
    {
      "indent": 0,
      "text": "4.6.2. Requests/Responses Carrying SCSI and iSCSI Payload",
      "section_title": true,
      "zh-cn": "4.6.2. Requests/Responses Carrying SCSI and iSCSI Payload"
    },
    {
      "indent": 0,
      "text": "4.6.2.1. Asynchronous Message",
      "section_title": true,
      "zh-cn": "4.6.2.1. Asynchronous Message"
    },
    {
      "indent": 3,
      "text": "Asynchronous Message PDUs are used to carry SCSI asynchronous event notifications (AENs) and iSCSI asynchronous messages.",
      "zh-cn": "Asynchronous Message PDUs are used to carry SCSI asynchronous event notifications (AENs) and iSCSI asynchronous messages."
    },
    {
      "indent": 3,
      "text": "When carrying an AEN, the event details are reported as sense data in the data segment.",
      "zh-cn": "When carrying an AEN, the event details are reported as sense data in the data segment."
    },
    {
      "indent": 0,
      "text": "4.6.3. Requests/Responses Carrying iSCSI-Only Payload",
      "section_title": true,
      "zh-cn": "4.6.3. Requests/Responses Carrying iSCSI-Only Payload"
    },
    {
      "indent": 0,
      "text": "4.6.3.1. Text Requests and Text Responses",
      "section_title": true,
      "zh-cn": "4.6.3.1. Text Requests and Text Responses"
    },
    {
      "indent": 3,
      "text": "Text Requests and Responses are designed as a parameter negotiation vehicle and as a vehicle for future extension.",
      "zh-cn": "Text Requests and Responses are designed as a parameter negotiation vehicle and as a vehicle for future extension."
    },
    {
      "indent": 3,
      "text": "In the data segment, Text Requests/Responses carry text information using a simple \"key=value\" syntax.",
      "zh-cn": "In the data segment, Text Requests/Responses carry text information using a simple \"key=value\" syntax."
    },
    {
      "indent": 3,
      "text": "Text Requests/Responses may form extended sequences using the same Initiator Task Tag. The initiator uses the F (Final) flag bit in the Text Request header to indicate its readiness to terminate a sequence. The target uses the F bit in the Text Response header to indicate its consent to sequence termination.",
      "zh-cn": "Text Requests/Responses may form extended sequences using the same Initiator Task Tag. The initiator uses the F (Final) flag bit in the Text Request header to indicate its readiness to terminate a sequence. The target uses the F bit in the Text Response header to indicate its consent to sequence termination."
    },
    {
      "indent": 3,
      "text": "Text Requests and Responses also use the Target Transfer Tag to indicate continuation of an operation or a new beginning. A target that wishes to continue an operation will set the Target Transfer Tag in a Text Response to a value different from the default 0xffffffff. An initiator willing to continue will copy this value into the Target Transfer Tag of the next Text Request. If the initiator wants to restart the current target negotiation (start fresh), it will set the Target Transfer Tag to 0xffffffff.",
      "zh-cn": "Text Requests and Responses also use the Target Transfer Tag to indicate continuation of an operation or a new beginning. A target that wishes to continue an operation will set the Target Transfer Tag in a Text Response to a value different from the default 0xffffffff. An initiator willing to continue will copy this value into the Target Transfer Tag of the next Text Request. If the initiator wants to restart the current target negotiation (start fresh), it will set the Target Transfer Tag to 0xffffffff."
    },
    {
      "indent": 3,
      "text": "Although a complete exchange is always started by the initiator, specific parameter negotiations may be initiated by the initiator or target.",
      "zh-cn": "Although a complete exchange is always started by the initiator, specific parameter negotiations may be initiated by the initiator or target."
    },
    {
      "indent": 0,
      "text": "4.6.3.2. Login Requests and Login Responses",
      "section_title": true,
      "zh-cn": "4.6.3.2. Login Requests and Login Responses"
    },
    {
      "indent": 3,
      "text": "Login Requests and Responses are used exclusively during the Login Phase of each connection to set up the session and connection parameters. (The Login Phase consists of a sequence of Login Requests and Responses carrying the same Initiator Task Tag.)",
      "zh-cn": "Login Requests and Responses are used exclusively during the Login Phase of each connection to set up the session and connection parameters. (The Login Phase consists of a sequence of Login Requests and Responses carrying the same Initiator Task Tag.)"
    },
    {
      "indent": 3,
      "text": "A connection is identified by an arbitrarily selected connection ID (CID) that is unique within a session.",
      "zh-cn": "A connection is identified by an arbitrarily selected connection ID (CID) that is unique within a session."
    },
    {
      "indent": 3,
      "text": "Similar to the Text Requests and Responses, Login Requests/Responses carry key=value text information with a simple syntax in the data segment.",
      "zh-cn": "Similar to the Text Requests and Responses, Login Requests/Responses carry key=value text information with a simple syntax in the data segment."
    },
    {
      "indent": 3,
      "text": "The Login Phase proceeds through several stages (security negotiation, operational parameter negotiation) that are selected with two binary coded fields in the header -- the Current Stage (CSG) and the Next Stage (NSG) -- with the appearance of the latter being signaled by the \"Transit\" flag (T).",
      "zh-cn": "The Login Phase proceeds through several stages (security negotiation, operational parameter negotiation) that are selected with two binary coded fields in the header -- the Current Stage (CSG) and the Next Stage (NSG) -- with the appearance of the latter being signaled by the \"Transit\" flag (T)."
    },
    {
      "indent": 3,
      "text": "The first Login Phase of a session plays a special role, called the leading login, which determines some header fields (e.g., the version number, the maximum number of connections, and the session identification).",
      "zh-cn": "The first Login Phase of a session plays a special role, called the leading login, which determines some header fields (e.g., the version number, the maximum number of connections, and the session identification)."
    },
    {
      "indent": 3,
      "text": "The CmdSN initial value is also set by the leading login.",
      "zh-cn": "The CmdSN initial value is also set by the leading login."
    },
    {
      "indent": 3,
      "text": "The StatSN for each connection is initiated by the connection login.",
      "zh-cn": "The StatSN for each connection is initiated by the connection login."
    },
    {
      "indent": 3,
      "text": "A Login Request may indicate an implied logout (cleanup) of the connection to be logged in (a connection restart) by using the same connection ID (CID) as an existing connection as well as the same session-identifying elements of the session to which the old connection was associated.",
      "zh-cn": "A Login Request may indicate an implied logout (cleanup) of the connection to be logged in (a connection restart) by using the same connection ID (CID) as an existing connection as well as the same session-identifying elements of the session to which the old connection was associated."
    },
    {
      "indent": 0,
      "text": "4.6.3.3. Logout Requests and Logout Responses",
      "section_title": true,
      "zh-cn": "4.6.3.3. Logout Requests and Logout Responses"
    },
    {
      "indent": 3,
      "text": "Logout Requests and Responses are used for the orderly closing of connections for recovery or maintenance. The Logout Request may be issued following a target prompt (through an Asynchronous Message) or at an initiator's initiative. When issued on the connection to be logged out, no other request may follow it.",
      "zh-cn": "Logout Requests and Responses are used for the orderly closing of connections for recovery or maintenance. The Logout Request may be issued following a target prompt (through an Asynchronous Message) or at an initiator's initiative. When issued on the connection to be logged out, no other request may follow it."
    },
    {
      "indent": 3,
      "text": "The Logout Response indicates that the connection or session cleanup is completed and no other responses will arrive on the connection (if received on the logging-out connection). In addition, the Logout Response indicates how long the target will continue to hold resources for recovery (e.g., command execution that continues on a new connection) in the Time2Retain field and how long the initiator must wait before proceeding with recovery in the Time2Wait field.",
      "zh-cn": "The Logout Response indicates that the connection or session cleanup is completed and no other responses will arrive on the connection (if received on the logging-out connection). In addition, the Logout Response indicates how long the target will continue to hold resources for recovery (e.g., command execution that continues on a new connection) in the Time2Retain field and how long the initiator must wait before proceeding with recovery in the Time2Wait field."
    },
    {
      "indent": 0,
      "text": "4.6.3.4. SNACK Request",
      "section_title": true,
      "zh-cn": "4.6.3.4. SNACK Request"
    },
    {
      "indent": 3,
      "text": "With the SNACK Request, the initiator requests retransmission of numbered responses or data from the target. A single SNACK Request covers a contiguous set of missing items, called a run, of a given type of items. The type is indicated in a type field in the PDU header. The run is composed of an initial item (StatSN, DataSN, R2TSN) and the number of missed Status, Data, or R2T PDUs. For long Data-In sequences, the target may request (at predefined minimum intervals) a positive acknowledgment for the data sent. A SNACK Request with a type field that indicates ACK and the number of Data-In PDUs acknowledged conveys this positive acknowledgment.",
      "zh-cn": "With the SNACK Request, the initiator requests retransmission of numbered responses or data from the target. A single SNACK Request covers a contiguous set of missing items, called a run, of a given type of items. The type is indicated in a type field in the PDU header. The run is composed of an initial item (StatSN, DataSN, R2TSN) and the number of missed Status, Data, or R2T PDUs. For long Data-In sequences, the target may request (at predefined minimum intervals) a positive acknowledgment for the data sent. A SNACK Request with a type field that indicates ACK and the number of Data-In PDUs acknowledged conveys this positive acknowledgment."
    },
    {
      "indent": 0,
      "text": "4.6.3.5. Reject",
      "section_title": true,
      "zh-cn": "4.6.3.5. Reject"
    },
    {
      "indent": 3,
      "text": "Reject enables the target to report an iSCSI error condition (e.g., protocol, unsupported option) that uses a Reason field in the PDU header and includes the complete header of the bad PDU in the Reject PDU data segment.",
      "zh-cn": "Reject enables the target to report an iSCSI error condition (e.g., protocol, unsupported option) that uses a Reason field in the PDU header and includes the complete header of the bad PDU in the Reject PDU data segment."
    },
    {
      "indent": 0,
      "text": "4.6.3.6. NOP-Out Request and NOP-In Response",
      "section_title": true,
      "zh-cn": "4.6.3.6. NOP-Out Request and NOP-In Response"
    },
    {
      "indent": 3,
      "text": "This request/response pair may be used by an initiator and target as a \"ping\" mechanism to verify that a connection/session is still active and all of its components are operational. Such a ping may be",
      "zh-cn": "This request/response pair may be used by an initiator and target as a \"ping\" mechanism to verify that a connection/session is still active and all of its components are operational. Such a ping may be"
    },
    {
      "indent": 3,
      "text": "triggered by the initiator or target. The triggering party indicates that it wants a reply by setting a value different from the default 0xffffffff in the corresponding Initiator/Target Transfer Tag.",
      "zh-cn": "triggered by the initiator or target. The triggering party indicates that it wants a reply by setting a value different from the default 0xffffffff in the corresponding Initiator/Target Transfer Tag."
    },
    {
      "indent": 3,
      "text": "NOP-In/NOP-Out may also be used in \"unidirectional\" fashion to convey to the initiator/target command, status, or data counter values when there is no other \"carrier\" and there is a need to update the initiator/target.",
      "zh-cn": "NOP-In/NOP-Out may also be used in \"unidirectional\" fashion to convey to the initiator/target command, status, or data counter values when there is no other \"carrier\" and there is a need to update the initiator/target."
    },
    {
      "indent": 0,
      "text": "5. SCSI Mode Parameters for iSCSI",
      "section_title": true,
      "zh-cn": "5. SCSI Mode Parameters for iSCSI"
    },
    {
      "indent": 3,
      "text": "There are no iSCSI-specific mode pages.",
      "zh-cn": "There are no iSCSI-specific mode pages."
    },
    {
      "indent": 0,
      "text": "6. Login and Full Feature Phase Negotiation",
      "section_title": true,
      "zh-cn": "6. Login and Full Feature Phase Negotiation"
    },
    {
      "indent": 3,
      "text": "iSCSI parameters are negotiated at session or connection establishment by using Login Requests and Responses (see Section 4.2.4) and during the Full Feature Phase (Section 4.2.5) by using Text Requests and Responses. In both cases, the mechanism used is an exchange of iSCSI-text-key=value pairs. For brevity, iSCSI-text-keys are called just \"keys\" in the rest of this document.",
      "zh-cn": "iSCSI parameters are negotiated at session or connection establishment by using Login Requests and Responses (see Section 4.2.4) and during the Full Feature Phase (Section 4.2.5) by using Text Requests and Responses. In both cases, the mechanism used is an exchange of iSCSI-text-key=value pairs. For brevity, iSCSI-text-keys are called just \"keys\" in the rest of this document."
    },
    {
      "indent": 3,
      "text": "Keys are either declarative or require negotiation, and the key description indicates whether the key is declarative or requires negotiation.",
      "zh-cn": "Keys are either declarative or require negotiation, and the key description indicates whether the key is declarative or requires negotiation."
    },
    {
      "indent": 3,
      "text": "For the declarative keys, the declaring party sets a value for the key. The key specification indicates whether the key can be declared by the initiator, the target, or both.",
      "zh-cn": "For the declarative keys, the declaring party sets a value for the key. The key specification indicates whether the key can be declared by the initiator, the target, or both."
    },
    {
      "indent": 3,
      "text": "For the keys that require negotiation, one of the parties (the proposing party) proposes a value or set of values by including the key=value in the data part of a Login or Text Request or Response. The other party (the accepting party) makes a selection based on the value or list of values proposed and includes the selected value in a key=value in the data part of the following Login or Text Response or Request. For most of the keys, both the initiator and target can be proposing parties.",
      "zh-cn": "For the keys that require negotiation, one of the parties (the proposing party) proposes a value or set of values by including the key=value in the data part of a Login or Text Request or Response. The other party (the accepting party) makes a selection based on the value or list of values proposed and includes the selected value in a key=value in the data part of the following Login or Text Response or Request. For most of the keys, both the initiator and target can be proposing parties."
    },
    {
      "indent": 3,
      "text": "The login process proceeds in two stages -- the security negotiation stage and the operational parameter negotiation stage. Both stages are optional, but at least one of them has to be present to enable setting some mandatory parameters.",
      "zh-cn": "The login process proceeds in two stages -- the security negotiation stage and the operational parameter negotiation stage. Both stages are optional, but at least one of them has to be present to enable setting some mandatory parameters."
    },
    {
      "indent": 3,
      "text": "If present, the security negotiation stage precedes the operational parameter negotiation stage.",
      "zh-cn": "If present, the security negotiation stage precedes the operational parameter negotiation stage."
    },
    {
      "indent": 3,
      "text": "Progression from stage to stage is controlled by the T (Transit) bit in the Login Request/Response PDU header. Through the T bit set to 1, the initiator indicates that it would like to transition. The target agrees to the transition (and selects the next stage) when ready. A field in the Login PDU header indicates the current stage (CSG), and during transition, another field indicates the next stage (NSG) proposed (initiator) and selected (target).",
      "zh-cn": "Progression from stage to stage is controlled by the T (Transit) bit in the Login Request/Response PDU header. Through the T bit set to 1, the initiator indicates that it would like to transition. The target agrees to the transition (and selects the next stage) when ready. A field in the Login PDU header indicates the current stage (CSG), and during transition, another field indicates the next stage (NSG) proposed (initiator) and selected (target)."
    },
    {
      "indent": 3,
      "text": "The text negotiation process is used to negotiate or declare operational parameters. The negotiation process is controlled by the F (Final) bit in the PDU header. During text negotiations, the F bit is used by the initiator to indicate that it is ready to finish the negotiation and by the target to acquiesce the end of negotiation.",
      "zh-cn": "The text negotiation process is used to negotiate or declare operational parameters. The negotiation process is controlled by the F (Final) bit in the PDU header. During text negotiations, the F bit is used by the initiator to indicate that it is ready to finish the negotiation and by the target to acquiesce the end of negotiation."
    },
    {
      "indent": 3,
      "text": "Since some key=value pairs may not fit entirely in a single PDU, the C (Continue) bit is used (both in Login and Text) to indicate that \"more follows\".",
      "zh-cn": "Since some key=value pairs may not fit entirely in a single PDU, the C (Continue) bit is used (both in Login and Text) to indicate that \"more follows\"."
    },
    {
      "indent": 3,
      "text": "The text negotiation uses an additional mechanism by which a target may deliver larger amounts of data to an inquiring initiator. The target sets a Target Task Tag to be used as a bookmark that, when returned by the initiator, means \"go on\". If reset to a \"neutral value\", it means \"forget about the rest\".",
      "zh-cn": "The text negotiation uses an additional mechanism by which a target may deliver larger amounts of data to an inquiring initiator. The target sets a Target Task Tag to be used as a bookmark that, when returned by the initiator, means \"go on\". If reset to a \"neutral value\", it means \"forget about the rest\"."
    },
    {
      "indent": 3,
      "text": "This section details the types of keys and values used, the syntax rules for parameter formation, and the negotiation schemes to be used with different types of parameters.",
      "zh-cn": "This section details the types of keys and values used, the syntax rules for parameter formation, and the negotiation schemes to be used with different types of parameters."
    },
    {
      "indent": 0,
      "text": "6.1. Text Format",
      "section_title": true,
      "zh-cn": "6.1. Text Format"
    },
    {
      "indent": 3,
      "text": "The initiator and target send a set of key=value pairs encoded in UTF-8 Unicode. All the text keys and text values specified in this document are case sensitive; they are to be presented and interpreted as they appear in this document without change of case.",
      "zh-cn": "The initiator and target send a set of key=value pairs encoded in UTF-8 Unicode. All the text keys and text values specified in this document are case sensitive; they are to be presented and interpreted as they appear in this document without change of case."
    },
    {
      "indent": 3,
      "text": "The following character symbols are used in this document for text items (the hexadecimal values represent Unicode code points):",
      "zh-cn": "The following character symbols are used in this document for text items (the hexadecimal values represent Unicode code points):"
    },
    {
      "indent": 3,
      "text": "(a-z, A-Z) (0x61-0x7a, 0x41-0x5a) - letters\n                (0-9) (0x30-0x39) - digits\n                       \" \" (0x20) - space\n                       \".\" (0x2e) - dot\n                       \"-\" (0x2d) - minus\n                       \"+\" (0x2b) - plus\n                       \"@\" (0x40) - commercial at\n                       \"_\" (0x5f) - underscore\n                       \"=\" (0x3d) - equal\n                       \":\" (0x3a) - colon",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 25,
      "text": " \"/\" (0x2f) - solidus or slash\n \"[\" (0x5b) - left bracket\n \"]\" (0x5d) - right bracket\nnull (0x00) - null separator\n \",\" (0x2c) - comma\n \"~\" (0x7e) - tilde",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Key=value pairs may span PDU boundaries. An initiator or target that sends partial key=value text within a PDU indicates that more text follows by setting the C bit in the Text or Login Request or the Text or Login Response to 1. Data segments in a series of PDUs that have the C bit set to 1 and end with a PDU that has the C bit set to 0, or that include a single PDU that has the C bit set to 0, have to be considered as forming a single logical-text-data-segment (LTDS).",
      "zh-cn": "Key=value pairs may span PDU boundaries. An initiator or target that sends partial key=value text within a PDU indicates that more text follows by setting the C bit in the Text or Login Request or the Text or Login Response to 1. Data segments in a series of PDUs that have the C bit set to 1 and end with a PDU that has the C bit set to 0, or that include a single PDU that has the C bit set to 0, have to be considered as forming a single logical-text-data-segment (LTDS)."
    },
    {
      "indent": 3,
      "text": "Every key=value pair, including the last or only pair in a LTDS, MUST be followed by one null (0x00) delimiter.",
      "zh-cn": "Every key=value pair, including the last or only pair in a LTDS, MUST be followed by one null (0x00) delimiter."
    },
    {
      "indent": 3,
      "text": "A key-name is whatever precedes the first \"=\" in the key=value pair. The term \"key\" is used frequently in this document in place of \"key-name\".",
      "zh-cn": "A key-name is whatever precedes the first \"=\" in the key=value pair. The term \"key\" is used frequently in this document in place of \"key-name\"."
    },
    {
      "indent": 3,
      "text": "A value is whatever follows the first \"=\" in the key=value pair up to the end of the key=value pair, but not including the null delimiter.",
      "zh-cn": "A value is whatever follows the first \"=\" in the key=value pair up to the end of the key=value pair, but not including the null delimiter."
    },
    {
      "indent": 3,
      "text": "The following definitions will be used in the rest of this document:",
      "zh-cn": "The following definitions will be used in the rest of this document:"
    },
    {
      "indent": 6,
      "text": "- standard-label: A string of one or more characters that consists of letters, digits, dot, minus, plus, commercial at, or underscore. A standard-label MUST begin with a capital letter and must not exceed 63 characters.",
      "zh-cn": "- standard-label: A string of one or more characters that consists of letters, digits, dot, minus, plus, commercial at, or underscore. A standard-label MUST begin with a capital letter and must not exceed 63 characters."
    },
    {
      "indent": 6,
      "text": "- key-name: A standard-label.",
      "zh-cn": "- key-name: A standard-label."
    },
    {
      "indent": 6,
      "text": "- text-value: A string of zero or more characters that consists of letters, digits, dot, minus, plus, commercial at, underscore, slash, left bracket, right bracket, or colon.",
      "zh-cn": "- text-value: A string of zero or more characters that consists of letters, digits, dot, minus, plus, commercial at, underscore, slash, left bracket, right bracket, or colon."
    },
    {
      "indent": 6,
      "text": "- iSCSI-name-value: A string of one or more characters that consists of minus, dot, colon, or any character allowed by the output of the iSCSI stringprep template as specified in [RFC3722] (see also Section 4.2.7.2).",
      "zh-cn": "- iSCSI-name-value: A string of one or more characters that consists of minus, dot, colon, or any character allowed by the output of the iSCSI stringprep template as specified in [RFC3722] (see also Section 4.2.7.2)."
    },
    {
      "indent": 6,
      "text": "- iSCSI-local-name-value: A UTF-8 string; no null characters are allowed in the string. This encoding is to be used for localized (internationalized) aliases.",
      "zh-cn": "- iSCSI-local-name-value: A UTF-8 string; no null characters are allowed in the string. This encoding is to be used for localized (internationalized) aliases."
    },
    {
      "indent": 6,
      "text": "- boolean-value: The string \"Yes\" or \"No\".",
      "zh-cn": "- boolean-value: The string \"Yes\" or \"No\"."
    },
    {
      "indent": 6,
      "text": "- hex-constant: A hexadecimal constant encoded as a string that starts with \"0x\" or \"0X\" followed by one or more digits or the letters a, b, c, d, e, f, A, B, C, D, E, or F. Hex-constants are used to encode numerical values or binary strings. When used to encode numerical values, the excessive use of leading 0 digits is discouraged. The string following 0X (or 0x) represents a base16 number that starts with the most significant base16 digit, followed by all other digits in decreasing order of significance and ending with the least significant base16 digit. When used to encode binary strings, hexadecimal constants have an implicit byte-length that includes four bits for every hexadecimal digit of the constant, including leading zeroes. For example, a hex-constant of n hexadecimal digits has a byte-length of (the integer part of) (n + 1)/2.",
      "zh-cn": "- hex-constant: A hexadecimal constant encoded as a string that starts with \"0x\" or \"0X\" followed by one or more digits or the letters a, b, c, d, e, f, A, B, C, D, E, or F. Hex-constants are used to encode numerical values or binary strings. When used to encode numerical values, the excessive use of leading 0 digits is discouraged. The string following 0X (or 0x) represents a base16 number that starts with the most significant base16 digit, followed by all other digits in decreasing order of significance and ending with the least significant base16 digit. When used to encode binary strings, hexadecimal constants have an implicit byte-length that includes four bits for every hexadecimal digit of the constant, including leading zeroes. For example, a hex-constant of n hexadecimal digits has a byte-length of (the integer part of) (n + 1)/2."
    },
    {
      "indent": 6,
      "text": "- decimal-constant: An unsigned decimal number with the digit 0 or a string of one or more digits that starts with a non-zero digit. Decimal-constants are used to encode numerical values or binary strings. Decimal-constants can only be used to encode binary strings if the string length is explicitly specified. There is no implicit length for decimal strings. Decimal-constants MUST NOT be used for parameter values if the values can be equal to or greater than 2**64 (numerical) or for binary strings that can be longer than 64 bits.",
      "zh-cn": "- decimal-constant: An unsigned decimal number with the digit 0 or a string of one or more digits that starts with a non-zero digit. Decimal-constants are used to encode numerical values or binary strings. Decimal-constants can only be used to encode binary strings if the string length is explicitly specified. There is no implicit length for decimal strings. Decimal-constants MUST NOT be used for parameter values if the values can be equal to or greater than 2**64 (numerical) or for binary strings that can be longer than 64 bits."
    },
    {
      "indent": 6,
      "text": "- base64-constant: Base64 constant encoded as a string that starts with \"0b\" or \"0B\" followed by 1 or more digits, letters, plus sign, slash, or equals sign. The encoding is done according to [RFC4648].",
      "zh-cn": "- base64-constant: Base64 constant encoded as a string that starts with \"0b\" or \"0B\" followed by 1 or more digits, letters, plus sign, slash, or equals sign. The encoding is done according to [RFC4648]."
    },
    {
      "indent": 6,
      "text": "- numerical-value: An unsigned integer always less than 2**64 encoded as a decimal-constant or a hex-constant. Unsigned integer arithmetic applies to numerical-values.",
      "zh-cn": "- numerical-value: An unsigned integer always less than 2**64 encoded as a decimal-constant or a hex-constant. Unsigned integer arithmetic applies to numerical-values."
    },
    {
      "indent": 6,
      "text": "- large-numerical-value: An unsigned integer that can be larger than or equal to 2**64 encoded as a hex-constant or base64-constant. Unsigned integer arithmetic applies to large-numerical-values.",
      "zh-cn": "- large-numerical-value: An unsigned integer that can be larger than or equal to 2**64 encoded as a hex-constant or base64-constant. Unsigned integer arithmetic applies to large-numerical-values."
    },
    {
      "indent": 6,
      "text": "- numerical-range: Two numerical-values separated by a tilde, where the value to the right of the tilde must not be lower than the value to the left.",
      "zh-cn": "- numerical-range: Two numerical-values separated by a tilde, where the value to the right of the tilde must not be lower than the value to the left."
    },
    {
      "indent": 6,
      "text": "- regular-binary-value: A binary string not longer than 64 bits encoded as a decimal-constant, hex-constant, or base64-constant. The length of the string is either specified by the key definition or is the implicit byte-length of the encoded string.",
      "zh-cn": "- regular-binary-value: A binary string not longer than 64 bits encoded as a decimal-constant, hex-constant, or base64-constant. The length of the string is either specified by the key definition or is the implicit byte-length of the encoded string."
    },
    {
      "indent": 6,
      "text": "- large-binary-value: A binary string longer than 64 bits encoded as a hex-constant or base64-constant. The length of the string is either specified by the key definition or is the implicit byte-length of the encoded string.",
      "zh-cn": "- large-binary-value: A binary string longer than 64 bits encoded as a hex-constant or base64-constant. The length of the string is either specified by the key definition or is the implicit byte-length of the encoded string."
    },
    {
      "indent": 6,
      "text": "- binary-value: A regular-binary-value or a large-binary-value. Operations on binary values are key-specific.",
      "zh-cn": "- binary-value: A regular-binary-value or a large-binary-value. Operations on binary values are key-specific."
    },
    {
      "indent": 6,
      "text": "- simple-value: Text-value, iSCSI-name-value, boolean-value, numerical-value, a numerical-range, or a binary-value.",
      "zh-cn": "- simple-value: Text-value, iSCSI-name-value, boolean-value, numerical-value, a numerical-range, or a binary-value."
    },
    {
      "indent": 6,
      "text": "- list-of-values: A sequence of text-values separated by a comma.",
      "zh-cn": "- list-of-values: A sequence of text-values separated by a comma."
    },
    {
      "indent": 3,
      "text": "If not otherwise specified, the maximum length of a simple-value (not its encoded representation) is 255 bytes, not including the delimiter (comma or zero byte).",
      "zh-cn": "If not otherwise specified, the maximum length of a simple-value (not its encoded representation) is 255 bytes, not including the delimiter (comma or zero byte)."
    },
    {
      "indent": 3,
      "text": "Any iSCSI target or initiator MUST support receiving at least 8192 bytes of key=value data in a negotiation sequence. When proposing or accepting authentication methods that explicitly require support for very long authentication items, the initiator and target MUST support receiving at least 64 kilobytes of key=value data.",
      "zh-cn": "Any iSCSI target or initiator MUST support receiving at least 8192 bytes of key=value data in a negotiation sequence. When proposing or accepting authentication methods that explicitly require support for very long authentication items, the initiator and target MUST support receiving at least 64 kilobytes of key=value data."
    },
    {
      "indent": 0,
      "text": "6.2. Text Mode Negotiation",
      "section_title": true,
      "zh-cn": "6.2. Text Mode Negotiation"
    },
    {
      "indent": 3,
      "text": "During login, and thereafter, some session or connection parameters are either declared or negotiated through an exchange of textual information.",
      "zh-cn": "During login, and thereafter, some session or connection parameters are either declared or negotiated through an exchange of textual information."
    },
    {
      "indent": 3,
      "text": "The initiator starts the negotiation and/or declaration through a Text or Login Request and indicates when it is ready for completion (by setting the F bit to 1 and keeping it at 1 in a Text Request, or the T bit in the Login Request). As negotiation text may span PDU boundaries, a Text or Login Request or a Text or Login Response PDU that has the C bit set to 1 MUST NOT have the F bit or T bit set to 1.",
      "zh-cn": "The initiator starts the negotiation and/or declaration through a Text or Login Request and indicates when it is ready for completion (by setting the F bit to 1 and keeping it at 1 in a Text Request, or the T bit in the Login Request). As negotiation text may span PDU boundaries, a Text or Login Request or a Text or Login Response PDU that has the C bit set to 1 MUST NOT have the F bit or T bit set to 1."
    },
    {
      "indent": 3,
      "text": "A target receiving a Text or Login Request with the C bit set to 1 MUST answer with a Text or Login Response with no data segment (DataSegmentLength 0). An initiator receiving a Text or Login Response with the C bit set to 1 MUST answer with a Text or Login Request with no data segment (DataSegmentLength 0).",
      "zh-cn": "A target receiving a Text or Login Request with the C bit set to 1 MUST answer with a Text or Login Response with no data segment (DataSegmentLength 0). An initiator receiving a Text or Login Response with the C bit set to 1 MUST answer with a Text or Login Request with no data segment (DataSegmentLength 0)."
    },
    {
      "indent": 3,
      "text": "A target or initiator SHOULD NOT use a Text or Login Response or a Text or Login Request with no data segment (DataSegmentLength 0) unless explicitly required by a general or a key-specific negotiation rule.",
      "zh-cn": "A target or initiator SHOULD NOT use a Text or Login Response or a Text or Login Request with no data segment (DataSegmentLength 0) unless explicitly required by a general or a key-specific negotiation rule."
    },
    {
      "indent": 3,
      "text": "There MUST NOT be more than one outstanding Text Request, or Text Response PDU on an iSCSI connection. An outstanding PDU in this context is one that has not been acknowledged by the remote iSCSI side.",
      "zh-cn": "There MUST NOT be more than one outstanding Text Request, or Text Response PDU on an iSCSI connection. An outstanding PDU in this context is one that has not been acknowledged by the remote iSCSI side."
    },
    {
      "indent": 3,
      "text": "The format of a declaration is:",
      "zh-cn": "The format of a declaration is:"
    },
    {
      "indent": 6,
      "text": "Declarer-> <key>=<valuex>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The general format of text negotiation is:",
      "zh-cn": "The general format of text negotiation is:"
    },
    {
      "indent": 6,
      "text": "Proposer-> <key>=<valuex>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "Acceptor-> <key>={<valuey>|NotUnderstood|Irrelevant|Reject}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Thus, a declaration is a one-way textual exchange (unless the key is not understood by the receiver), while a negotiation is a two-way exchange.",
      "zh-cn": "Thus, a declaration is a one-way textual exchange (unless the key is not understood by the receiver), while a negotiation is a two-way exchange."
    },
    {
      "indent": 3,
      "text": "The proposer or declarer can be either the initiator or the target, and the acceptor can be either the target or initiator, respectively. Targets are not limited to respond to key=value pairs as proposed by the initiator. The target may propose key=value pairs of its own.",
      "zh-cn": "The proposer or declarer can be either the initiator or the target, and the acceptor can be either the target or initiator, respectively. Targets are not limited to respond to key=value pairs as proposed by the initiator. The target may propose key=value pairs of its own."
    },
    {
      "indent": 3,
      "text": "All negotiations are explicit (i.e., the result MUST only be based on newly exchanged or declared values). There are no implicit proposals. If a proposal is not made, then a reply cannot be expected. Conservative design also requires that default values should not be relied upon when the use of some other value has serious consequences.",
      "zh-cn": "All negotiations are explicit (i.e., the result MUST only be based on newly exchanged or declared values). There are no implicit proposals. If a proposal is not made, then a reply cannot be expected. Conservative design also requires that default values should not be relied upon when the use of some other value has serious consequences."
    },
    {
      "indent": 3,
      "text": "The value proposed or declared can be a numerical-value, a numerical-range defined by the lower and upper value with both integers separated by a tilde, a binary value, a text-value, an iSCSI-name-value, an iSCSI-local-name-value, a boolean-value (Yes or No), or a list of comma-separated text-values. A range, a large-numerical-value, an iSCSI-name-value, and an iSCSI-local-name-value MAY ONLY be used if explicitly allowed. An accepted value can be a numerical-value, a large-numerical-value, a text-value, or a boolean-value.",
      "zh-cn": "The value proposed or declared can be a numerical-value, a numerical-range defined by the lower and upper value with both integers separated by a tilde, a binary value, a text-value, an iSCSI-name-value, an iSCSI-local-name-value, a boolean-value (Yes or No), or a list of comma-separated text-values. A range, a large-numerical-value, an iSCSI-name-value, and an iSCSI-local-name-value MAY ONLY be used if explicitly allowed. An accepted value can be a numerical-value, a large-numerical-value, a text-value, or a boolean-value."
    },
    {
      "indent": 3,
      "text": "If a specific key is not relevant for the current negotiation, the acceptor may answer with the constant \"Irrelevant\" for all types of negotiations. However, the negotiation is not considered to have failed if the answer is \"Irrelevant\". The \"Irrelevant\" answer is meant for those cases in which several keys are presented by a proposing party but the selection made by the acceptor for one of the",
      "zh-cn": "If a specific key is not relevant for the current negotiation, the acceptor may answer with the constant \"Irrelevant\" for all types of negotiations. However, the negotiation is not considered to have failed if the answer is \"Irrelevant\". The \"Irrelevant\" answer is meant for those cases in which several keys are presented by a proposing party but the selection made by the acceptor for one of the"
    },
    {
      "indent": 3,
      "text": "keys makes other keys irrelevant. The following example illustrates the use of \"Irrelevant\":",
      "zh-cn": "keys makes other keys irrelevant. The following example illustrates the use of \"Irrelevant\":"
    },
    {
      "indent": 6,
      "text": "I->T InitialR2T=No,ImmediateData=Yes,FirstBurstLength=4192\nT->I InitialR2T=Yes,ImmediateData=No,FirstBurstLength=Irrelevant\nI->T X-rdname-vkey1=(bla,alb,None), X-rdname-vkey2=(bla,alb)\nT->I X-rdname-vkey1=None, X-rdname-vkey2=Irrelevant",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Any key not understood by the acceptor may be ignored by the acceptor without affecting the basic function. However, the answer for a key that is not understood MUST be key=NotUnderstood. Note that NotUnderstood is a valid answer for both declarative and negotiated keys. The general iSCSI philosophy is that comprehension precedes processing for any iSCSI key. A proposer of an iSCSI key, negotiated or declarative, in a text key exchange MUST thus be able to properly handle a NotUnderstood response.",
      "zh-cn": "Any key not understood by the acceptor may be ignored by the acceptor without affecting the basic function. However, the answer for a key that is not understood MUST be key=NotUnderstood. Note that NotUnderstood is a valid answer for both declarative and negotiated keys. The general iSCSI philosophy is that comprehension precedes processing for any iSCSI key. A proposer of an iSCSI key, negotiated or declarative, in a text key exchange MUST thus be able to properly handle a NotUnderstood response."
    },
    {
      "indent": 3,
      "text": "The proper way to handle a NotUnderstood response depends on where the key is specified and whether the key is declarative or negotiated. An iSCSI implementation MUST comprehend all text keys defined in this document. Returning a NotUnderstood response on any of these text keys therefore MUST be considered a protocol error and handled accordingly. For all other \"later\" keys, i.e., text keys defined in later specifications, a NotUnderstood answer concludes the negotiation for a negotiated key, whereas for a declarative key a NotUnderstood answer simply informs the declarer of a lack of comprehension by the receiver.",
      "zh-cn": "The proper way to handle a NotUnderstood response depends on where the key is specified and whether the key is declarative or negotiated. An iSCSI implementation MUST comprehend all text keys defined in this document. Returning a NotUnderstood response on any of these text keys therefore MUST be considered a protocol error and handled accordingly. For all other \"later\" keys, i.e., text keys defined in later specifications, a NotUnderstood answer concludes the negotiation for a negotiated key, whereas for a declarative key a NotUnderstood answer simply informs the declarer of a lack of comprehension by the receiver."
    },
    {
      "indent": 3,
      "text": "In either case, a NotUnderstood answer always requires that the protocol behavior associated with that key not be used within the scope of the key (connection/session) by either side.",
      "zh-cn": "In either case, a NotUnderstood answer always requires that the protocol behavior associated with that key not be used within the scope of the key (connection/session) by either side."
    },
    {
      "indent": 3,
      "text": "The constants \"None\", \"Reject\", \"Irrelevant\", and \"NotUnderstood\" are reserved and MUST ONLY be used as described here. Violation of this rule is a protocol error (in particular, the use of \"Reject\", \"Irrelevant\", and \"NotUnderstood\" as proposed values).",
      "zh-cn": "The constants \"None\", \"Reject\", \"Irrelevant\", and \"NotUnderstood\" are reserved and MUST ONLY be used as described here. Violation of this rule is a protocol error (in particular, the use of \"Reject\", \"Irrelevant\", and \"NotUnderstood\" as proposed values)."
    },
    {
      "indent": 3,
      "text": "\"Reject\" or \"Irrelevant\" are legitimate negotiation options where allowed, but their excessive use is discouraged. A negotiation is considered complete when the acceptor has sent the key value pair even if the value is \"Reject\", \"Irrelevant\", or \"NotUnderstood\". Sending the key again would be a renegotiation and is forbidden for many keys.",
      "zh-cn": "\"Reject\" or \"Irrelevant\" are legitimate negotiation options where allowed, but their excessive use is discouraged. A negotiation is considered complete when the acceptor has sent the key value pair even if the value is \"Reject\", \"Irrelevant\", or \"NotUnderstood\". Sending the key again would be a renegotiation and is forbidden for many keys."
    },
    {
      "indent": 3,
      "text": "If the acceptor sends \"Reject\" as an answer, the negotiated key is left at its current value (or default if no value was set). If the current value is not acceptable to the proposer on the connection or to the session in which it is sent, the proposer MAY choose to terminate the connection or session.",
      "zh-cn": "If the acceptor sends \"Reject\" as an answer, the negotiated key is left at its current value (or default if no value was set). If the current value is not acceptable to the proposer on the connection or to the session in which it is sent, the proposer MAY choose to terminate the connection or session."
    },
    {
      "indent": 3,
      "text": "All keys in this document MUST be supported by iSCSI initiators and targets when used as specified here. If used as specified, these keys MUST NOT be answered with NotUnderstood.",
      "zh-cn": "All keys in this document MUST be supported by iSCSI initiators and targets when used as specified here. If used as specified, these keys MUST NOT be answered with NotUnderstood."
    },
    {
      "indent": 3,
      "text": "Implementers may introduce new private keys by prefixing them with X-followed by their (reverse) domain name, or with new public keys registered with IANA. For example, the entity owning the domain example.com can issue:",
      "zh-cn": "Implementers may introduce new private keys by prefixing them with X-followed by their (reverse) domain name, or with new public keys registered with IANA. For example, the entity owning the domain example.com can issue:"
    },
    {
      "indent": 6,
      "text": "X-com.example.bar.foo.do_something=3",
      "zh-cn": "X-com.example.bar.foo.do_something=3"
    },
    {
      "indent": 3,
      "text": "Each new public key in the course of standardization MUST define the acceptable responses to the key, including NotUnderstood as appropriate. Unlike [RFC3720], note that this document prohibits the X# prefix for new public keys. Based on iSCSI implementation experience, we know that there is no longer a need for a standard name prefix for keys that allow a NotUnderstood response. Note that NotUnderstood will generally have to be allowed for new public keys for backwards compatibility, as well as for private X- keys. Thus, the name prefix \"X#\" in new public key-names does not carry any significance. To avoid confusion, new public key-names MUST NOT begin with an \"X#\" prefix.",
      "zh-cn": "Each new public key in the course of standardization MUST define the acceptable responses to the key, including NotUnderstood as appropriate. Unlike [RFC3720], note that this document prohibits the X# prefix for new public keys. Based on iSCSI implementation experience, we know that there is no longer a need for a standard name prefix for keys that allow a NotUnderstood response. Note that NotUnderstood will generally have to be allowed for new public keys for backwards compatibility, as well as for private X- keys. Thus, the name prefix \"X#\" in new public key-names does not carry any significance. To avoid confusion, new public key-names MUST NOT begin with an \"X#\" prefix."
    },
    {
      "indent": 3,
      "text": "Implementers MAY also introduce new values, but ONLY for new keys or authentication methods (see Section 12) or digests (see Section 13.1).",
      "zh-cn": "Implementers MAY also introduce new values, but ONLY for new keys or authentication methods (see Section 12) or digests (see Section 13.1)."
    },
    {
      "indent": 3,
      "text": "Whenever parameter actions or acceptance are dependent on other parameters, the dependency rules and parameter sequence must be specified with the parameters.",
      "zh-cn": "Whenever parameter actions or acceptance are dependent on other parameters, the dependency rules and parameter sequence must be specified with the parameters."
    },
    {
      "indent": 3,
      "text": "In the Login Phase (see Section 6.3), every stage is a separate negotiation. In the Full Feature Phase, a Text Request/Response sequence is a negotiation. Negotiations MUST be handled as atomic operations. For example, all negotiated values go into effect after the negotiation concludes in agreement or are ignored if the negotiation fails.",
      "zh-cn": "In the Login Phase (see Section 6.3), every stage is a separate negotiation. In the Full Feature Phase, a Text Request/Response sequence is a negotiation. Negotiations MUST be handled as atomic operations. For example, all negotiated values go into effect after the negotiation concludes in agreement or are ignored if the negotiation fails."
    },
    {
      "indent": 3,
      "text": "Some parameters may be subject to integrity rules (e.g., parameter-x must not exceed parameter-y, or parameter-u not 1 implies that parameter-v be Yes). Whenever required, integrity rules are specified with the keys. Checking for compliance with the integrity",
      "zh-cn": "Some parameters may be subject to integrity rules (e.g., parameter-x must not exceed parameter-y, or parameter-u not 1 implies that parameter-v be Yes). Whenever required, integrity rules are specified with the keys. Checking for compliance with the integrity"
    },
    {
      "indent": 3,
      "text": "rule must only be performed after all the parameters are available (the existent and the newly negotiated). An iSCSI target MUST perform integrity checking before the new parameters take effect. An initiator MAY perform integrity checking.",
      "zh-cn": "rule must only be performed after all the parameters are available (the existent and the newly negotiated). An iSCSI target MUST perform integrity checking before the new parameters take effect. An initiator MAY perform integrity checking."
    },
    {
      "indent": 3,
      "text": "An iSCSI initiator or target MAY terminate a negotiation that does not terminate within an implementation-specific reasonable time or number of exchanges but SHOULD allow at least six (6) exchanges.",
      "zh-cn": "An iSCSI initiator or target MAY terminate a negotiation that does not terminate within an implementation-specific reasonable time or number of exchanges but SHOULD allow at least six (6) exchanges."
    },
    {
      "indent": 0,
      "text": "6.2.1. List Negotiations",
      "section_title": true,
      "zh-cn": "6.2.1. List Negotiations"
    },
    {
      "indent": 3,
      "text": "In list negotiation, the originator sends a list of values (which may include \"None\"), in order of preference.",
      "zh-cn": "In list negotiation, the originator sends a list of values (which may include \"None\"), in order of preference."
    },
    {
      "indent": 3,
      "text": "The responding party MUST respond with the same key and the first value that it supports (and is allowed to use for the specific originator) selected from the originator list.",
      "zh-cn": "The responding party MUST respond with the same key and the first value that it supports (and is allowed to use for the specific originator) selected from the originator list."
    },
    {
      "indent": 3,
      "text": "The constant \"None\" MUST always be used to indicate a missing function. However, \"None\" is only a valid selection if it is explicitly proposed. When \"None\" is proposed as a selection item in a negotiation for a key, it indicates to the responder that not supporting any functionality related to that key is legal, and if \"None\" is the negotiation result for such a key, it means that key-specific semantics are not operational for the negotiation scope (connection or session) of that key.",
      "zh-cn": "The constant \"None\" MUST always be used to indicate a missing function. However, \"None\" is only a valid selection if it is explicitly proposed. When \"None\" is proposed as a selection item in a negotiation for a key, it indicates to the responder that not supporting any functionality related to that key is legal, and if \"None\" is the negotiation result for such a key, it means that key-specific semantics are not operational for the negotiation scope (connection or session) of that key."
    },
    {
      "indent": 3,
      "text": "If an acceptor does not understand any particular value in a list, it MUST ignore it. If an acceptor does not support, does not understand, or is not allowed to use any of the proposed options with a specific originator, it may use the constant \"Reject\" or terminate the negotiation. The selection of a value not proposed MUST be handled by the originator as a protocol error.",
      "zh-cn": "If an acceptor does not understand any particular value in a list, it MUST ignore it. If an acceptor does not support, does not understand, or is not allowed to use any of the proposed options with a specific originator, it may use the constant \"Reject\" or terminate the negotiation. The selection of a value not proposed MUST be handled by the originator as a protocol error."
    },
    {
      "indent": 0,
      "text": "6.2.2. Simple-Value Negotiations",
      "section_title": true,
      "zh-cn": "6.2.2. Simple-Value Negotiations"
    },
    {
      "indent": 3,
      "text": "For simple-value negotiations, the accepting party MUST answer with the same key. The value it selects becomes the negotiation result.",
      "zh-cn": "For simple-value negotiations, the accepting party MUST answer with the same key. The value it selects becomes the negotiation result."
    },
    {
      "indent": 3,
      "text": "Proposing a value not admissible (e.g., not within the specified bounds) MAY be answered with the constant \"Reject\"; otherwise, the acceptor MUST select an admissible value.",
      "zh-cn": "Proposing a value not admissible (e.g., not within the specified bounds) MAY be answered with the constant \"Reject\"; otherwise, the acceptor MUST select an admissible value."
    },
    {
      "indent": 3,
      "text": "The selection, by the acceptor, of a value not admissible under the selection rules is considered a protocol error. The selection rules are key-specific.",
      "zh-cn": "The selection, by the acceptor, of a value not admissible under the selection rules is considered a protocol error. The selection rules are key-specific."
    },
    {
      "indent": 3,
      "text": "For a numerical range, the value selected MUST be an integer within the proposed range or \"Reject\" (if the range is unacceptable).",
      "zh-cn": "For a numerical range, the value selected MUST be an integer within the proposed range or \"Reject\" (if the range is unacceptable)."
    },
    {
      "indent": 3,
      "text": "For Boolean negotiations (i.e., keys taking the values \"Yes\" or \"No\"), the accepting party MUST answer with the same key and the result of the negotiation when the received value does not determine that result by itself. The last value transmitted becomes the negotiation result. The rules for selecting the value with which to answer are expressed as Boolean functions of the value received, and the value that the accepting party would have selected if given a choice.",
      "zh-cn": "For Boolean negotiations (i.e., keys taking the values \"Yes\" or \"No\"), the accepting party MUST answer with the same key and the result of the negotiation when the received value does not determine that result by itself. The last value transmitted becomes the negotiation result. The rules for selecting the value with which to answer are expressed as Boolean functions of the value received, and the value that the accepting party would have selected if given a choice."
    },
    {
      "indent": 3,
      "text": "Specifically, the two cases in which answers are OPTIONAL are:",
      "zh-cn": "Specifically, the two cases in which answers are OPTIONAL are:"
    },
    {
      "indent": 6,
      "text": "- The Boolean function is \"AND\" and the value \"No\" is received. The outcome of the negotiation is \"No\".",
      "zh-cn": "- The Boolean function is \"AND\" and the value \"No\" is received. The outcome of the negotiation is \"No\"."
    },
    {
      "indent": 6,
      "text": "- The Boolean function is \"OR\" and the value \"Yes\" is received. The outcome of the negotiation is \"Yes\".",
      "zh-cn": "- The Boolean function is \"OR\" and the value \"Yes\" is received. The outcome of the negotiation is \"Yes\"."
    },
    {
      "indent": 3,
      "text": "Responses are REQUIRED in all other cases, and the value chosen and sent by the acceptor becomes the outcome of the negotiation.",
      "zh-cn": "Responses are REQUIRED in all other cases, and the value chosen and sent by the acceptor becomes the outcome of the negotiation."
    },
    {
      "indent": 0,
      "text": "6.3. Login Phase",
      "section_title": true,
      "zh-cn": "6.3. Login Phase"
    },
    {
      "indent": 3,
      "text": "The Login Phase establishes an iSCSI connection between an initiator and a target; it also creates a new session or associates the connection to an existing session. The Login Phase sets the iSCSI protocol parameters and security parameters, and authenticates the initiator and target to each other.",
      "zh-cn": "The Login Phase establishes an iSCSI connection between an initiator and a target; it also creates a new session or associates the connection to an existing session. The Login Phase sets the iSCSI protocol parameters and security parameters, and authenticates the initiator and target to each other."
    },
    {
      "indent": 3,
      "text": "The Login Phase is only implemented via Login Requests and Responses. The whole Login Phase is considered as a single task and has a single Initiator Task Tag (similar to the linked SCSI commands).",
      "zh-cn": "The Login Phase is only implemented via Login Requests and Responses. The whole Login Phase is considered as a single task and has a single Initiator Task Tag (similar to the linked SCSI commands)."
    },
    {
      "indent": 3,
      "text": "There MUST NOT be more than one outstanding Login Request or Login Response on an iSCSI connection. An outstanding PDU in this context is one that has not been acknowledged by the remote iSCSI side.",
      "zh-cn": "There MUST NOT be more than one outstanding Login Request or Login Response on an iSCSI connection. An outstanding PDU in this context is one that has not been acknowledged by the remote iSCSI side."
    },
    {
      "indent": 3,
      "text": "The default MaxRecvDataSegmentLength is used during login.",
      "zh-cn": "The default MaxRecvDataSegmentLength is used during login."
    },
    {
      "indent": 3,
      "text": "The Login Phase sequence of requests and responses proceeds as follows:",
      "zh-cn": "The Login Phase sequence of requests and responses proceeds as follows:"
    },
    {
      "indent": 6,
      "text": "- Login initial request",
      "zh-cn": "- Login initial request"
    },
    {
      "indent": 6,
      "text": "- Login partial response (optional)",
      "zh-cn": "- Login partial response (optional)"
    },
    {
      "indent": 6,
      "text": "- More Login Requests and Responses (optional)",
      "zh-cn": "- More Login Requests and Responses (optional)"
    },
    {
      "indent": 6,
      "text": "- Login Final-Response (mandatory)",
      "zh-cn": "- Login Final-Response (mandatory)"
    },
    {
      "indent": 3,
      "text": "The initial Login Request of any connection MUST include the InitiatorName key=value pair. The initial Login Request of the first connection of a session MAY also include the SessionType key=value pair. For any connection within a session whose type is not \"Discovery\", the first Login Request MUST also include the TargetName key=value pair.",
      "zh-cn": "The initial Login Request of any connection MUST include the InitiatorName key=value pair. The initial Login Request of the first connection of a session MAY also include the SessionType key=value pair. For any connection within a session whose type is not \"Discovery\", the first Login Request MUST also include the TargetName key=value pair."
    },
    {
      "indent": 3,
      "text": "The Login Final-Response accepts or rejects the Login Request.",
      "zh-cn": "The Login Final-Response accepts or rejects the Login Request."
    },
    {
      "indent": 3,
      "text": "The Login Phase MAY include a SecurityNegotiation stage and a LoginOperationalNegotiation stage and MUST include at least one of them, but the included stage MAY be empty except for the mandatory names.",
      "zh-cn": "The Login Phase MAY include a SecurityNegotiation stage and a LoginOperationalNegotiation stage and MUST include at least one of them, but the included stage MAY be empty except for the mandatory names."
    },
    {
      "indent": 3,
      "text": "The Login Requests and Responses contain a field (CSG) that indicates the current negotiation stage (SecurityNegotiation or LoginOperationalNegotiation). If both stages are used, the SecurityNegotiation MUST precede the LoginOperationalNegotiation.",
      "zh-cn": "The Login Requests and Responses contain a field (CSG) that indicates the current negotiation stage (SecurityNegotiation or LoginOperationalNegotiation). If both stages are used, the SecurityNegotiation MUST precede the LoginOperationalNegotiation."
    },
    {
      "indent": 3,
      "text": "Some operational parameters can be negotiated outside the login through Text Requests and Responses.",
      "zh-cn": "Some operational parameters can be negotiated outside the login through Text Requests and Responses."
    },
    {
      "indent": 3,
      "text": "Authentication-related security keys (Section 12) MUST be completely negotiated within the Login Phase. The use of underlying IPsec security is specified in Section 9.3, in [RFC3723], and in [RFC7146]. iSCSI support for security within the protocol only consists of authentication in the Login Phase.",
      "zh-cn": "Authentication-related security keys (Section 12) MUST be completely negotiated within the Login Phase. The use of underlying IPsec security is specified in Section 9.3, in [RFC3723], and in [RFC7146]. iSCSI support for security within the protocol only consists of authentication in the Login Phase."
    },
    {
      "indent": 3,
      "text": "In some environments, a target or an initiator is not interested in authenticating its counterpart. It is possible to bypass authentication through the Login Request and Response.",
      "zh-cn": "In some environments, a target or an initiator is not interested in authenticating its counterpart. It is possible to bypass authentication through the Login Request and Response."
    },
    {
      "indent": 3,
      "text": "The initiator and target MAY want to negotiate iSCSI authentication parameters. Once this negotiation is completed, the channel is considered secure.",
      "zh-cn": "The initiator and target MAY want to negotiate iSCSI authentication parameters. Once this negotiation is completed, the channel is considered secure."
    },
    {
      "indent": 3,
      "text": "Most of the negotiation keys are only allowed in a specific stage. The keys used during the SecurityNegotiation stage are listed in Section 12, and the keys used during the LoginOperationalNegotiation stage are discussed in Section 13. Only a limited set of keys (marked as Any-Stage in Section 13) may be used in either of the two stages.",
      "zh-cn": "Most of the negotiation keys are only allowed in a specific stage. The keys used during the SecurityNegotiation stage are listed in Section 12, and the keys used during the LoginOperationalNegotiation stage are discussed in Section 13. Only a limited set of keys (marked as Any-Stage in Section 13) may be used in either of the two stages."
    },
    {
      "indent": 3,
      "text": "Any given Login Request or Response belongs to a specific stage; this determines the negotiation keys allowed with the request or response. Sending a key that is not allowed in the current stage is considered a protocol error.",
      "zh-cn": "Any given Login Request or Response belongs to a specific stage; this determines the negotiation keys allowed with the request or response. Sending a key that is not allowed in the current stage is considered a protocol error."
    },
    {
      "indent": 3,
      "text": "Stage transition is performed through a command exchange (request/response) that carries the T bit and the same CSG code. During this exchange, the next stage is selected by the target via the Next Stage code (NSG). The selected NSG MUST NOT exceed the value stated by the initiator. The initiator can request a transition whenever it is ready, but a target can only respond with a transition after one is proposed by the initiator.",
      "zh-cn": "Stage transition is performed through a command exchange (request/response) that carries the T bit and the same CSG code. During this exchange, the next stage is selected by the target via the Next Stage code (NSG). The selected NSG MUST NOT exceed the value stated by the initiator. The initiator can request a transition whenever it is ready, but a target can only respond with a transition after one is proposed by the initiator."
    },
    {
      "indent": 3,
      "text": "In a negotiation sequence, the T bit settings in one Login Request-Login Response pair have no bearing on the T bit settings of the next pair. An initiator that has the T bit set to 1 in one pair and is answered with a T bit setting of 0 may issue the next request with the T bit set to 0.",
      "zh-cn": "In a negotiation sequence, the T bit settings in one Login Request-Login Response pair have no bearing on the T bit settings of the next pair. An initiator that has the T bit set to 1 in one pair and is answered with a T bit setting of 0 may issue the next request with the T bit set to 0."
    },
    {
      "indent": 3,
      "text": "When a transition is requested by the initiator and acknowledged by the target, both the initiator and target switch to the selected stage.",
      "zh-cn": "When a transition is requested by the initiator and acknowledged by the target, both the initiator and target switch to the selected stage."
    },
    {
      "indent": 3,
      "text": "Targets MUST NOT submit parameters that require an additional initiator Login Request in a Login Response with the T bit set to 1.",
      "zh-cn": "Targets MUST NOT submit parameters that require an additional initiator Login Request in a Login Response with the T bit set to 1."
    },
    {
      "indent": 3,
      "text": "Stage transitions during login (including entering and exit) are only possible as outlined in the following table:",
      "zh-cn": "Stage transitions during login (including entering and exit) are only possible as outlined in the following table:"
    },
    {
      "indent": 5,
      "text": "+-----------------------------------------------------------+\n|From      To ->  | Security    | Operational | FullFeature |\n| |               |             |             |             |\n| V               |             |             |             |\n+-----------------------------------------------------------+\n| (start)         | yes         | yes         | no          |\n+-----------------------------------------------------------+\n| Security        | no          | yes         | yes         |\n+-----------------------------------------------------------+\n| Operational     | no          | no          | yes         |\n+-----------------------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The Login Final-Response that accepts a Login Request can only come as a response to a Login Request with the T bit set to 1, and both the request and response MUST indicate FullFeaturePhase as the next phase via the NSG field.",
      "zh-cn": "The Login Final-Response that accepts a Login Request can only come as a response to a Login Request with the T bit set to 1, and both the request and response MUST indicate FullFeaturePhase as the next phase via the NSG field."
    },
    {
      "indent": 3,
      "text": "Neither the initiator nor the target should attempt to declare or negotiate a parameter more than once during login, except for responses to specific keys that explicitly allow repeated key declarations (e.g., TargetAddress). An attempt to renegotiate/redeclare parameters not specifically allowed MUST be detected by the initiator and target. If such an attempt is detected by the target, the target MUST respond with a Login reject (initiator error); if detected by the initiator, the initiator MUST drop the connection.",
      "zh-cn": "Neither the initiator nor the target should attempt to declare or negotiate a parameter more than once during login, except for responses to specific keys that explicitly allow repeated key declarations (e.g., TargetAddress). An attempt to renegotiate/redeclare parameters not specifically allowed MUST be detected by the initiator and target. If such an attempt is detected by the target, the target MUST respond with a Login reject (initiator error); if detected by the initiator, the initiator MUST drop the connection."
    },
    {
      "indent": 0,
      "text": "6.3.1. Login Phase Start",
      "section_title": true,
      "zh-cn": "6.3.1. Login Phase Start"
    },
    {
      "indent": 3,
      "text": "The Login Phase starts with a Login Request from the initiator to the target. The initial Login Request includes:",
      "zh-cn": "The Login Phase starts with a Login Request from the initiator to the target. The initial Login Request includes:"
    },
    {
      "indent": 6,
      "text": "- Protocol version supported by the initiator",
      "zh-cn": "- Protocol version supported by the initiator"
    },
    {
      "indent": 6,
      "text": "- iSCSI Initiator Name and iSCSI Target Name",
      "zh-cn": "- iSCSI Initiator Name and iSCSI Target Name"
    },
    {
      "indent": 6,
      "text": "- ISID, TSIH, and connection IDs",
      "zh-cn": "- ISID, TSIH, and connection IDs"
    },
    {
      "indent": 6,
      "text": "- Negotiation stage that the initiator is ready to enter",
      "zh-cn": "- Negotiation stage that the initiator is ready to enter"
    },
    {
      "indent": 3,
      "text": "A login may create a new session, or it may add a connection to an existing session. Between a given iSCSI initiator node (selected only by an InitiatorName) and a given iSCSI target defined by an iSCSI TargetName and a Target Portal Group Tag, the login results are defined by the following table:",
      "zh-cn": "A login may create a new session, or it may add a connection to an existing session. Between a given iSCSI initiator node (selected only by an InitiatorName) and a given iSCSI target defined by an iSCSI TargetName and a Target Portal Group Tag, the login results are defined by the following table:"
    },
    {
      "indent": 4,
      "text": "+----------------------------------------------------------------+\n|ISID    | TSIH        | CID    |   Target Action                |\n+----------------------------------------------------------------+\n|new     | non-zero    | any    |   fail the login               |\n|        |             |        |   (\"session does not exist\")   |\n+----------------------------------------------------------------+\n|new     | zero        | any    |   instantiate a new session    |\n+----------------------------------------------------------------+\n|existing| zero        | any    |   do session reinstatement     |\n|        |             |        |   (see Section 6.3.5)          |\n+----------------------------------------------------------------+\n|existing| non-zero    | new    |   add a new connection to      |\n|        | existing    |        |   the session                  |\n+----------------------------------------------------------------+\n|existing| non-zero    |existing|   do connection reinstatement  |\n|        | existing    |        |   (see Section 7.1.4.3)        |\n+----------------------------------------------------------------+\n|existing| non-zero    | any    |   fail the login               |\n|        | new         |        |   (\"session does not exist\")   |\n+----------------------------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The determination of \"existing\" or \"new\" is made by the target.",
      "zh-cn": "The determination of \"existing\" or \"new\" is made by the target."
    },
    {
      "indent": 3,
      "text": "Optionally, the Login Request may include:",
      "zh-cn": "Optionally, the Login Request may include:"
    },
    {
      "indent": 6,
      "text": "- Security parameters OR",
      "zh-cn": "- Security parameters OR"
    },
    {
      "indent": 6,
      "text": "- iSCSI operational parameters AND/OR",
      "zh-cn": "- iSCSI operational parameters AND/OR"
    },
    {
      "indent": 6,
      "text": "- The next negotiation stage that the initiator is ready to enter",
      "zh-cn": "- The next negotiation stage that the initiator is ready to enter"
    },
    {
      "indent": 3,
      "text": "The target can answer the login in the following ways:",
      "zh-cn": "The target can answer the login in the following ways:"
    },
    {
      "indent": 6,
      "text": "- Login Response with Login reject. This is an immediate rejection from the target that causes the connection to terminate and the session to terminate if this is the first (or only) connection of a new session. The T bit, the CSG field, and the NSG field are reserved.",
      "zh-cn": "- Login Response with Login reject. This is an immediate rejection from the target that causes the connection to terminate and the session to terminate if this is the first (or only) connection of a new session. The T bit, the CSG field, and the NSG field are reserved."
    },
    {
      "indent": 6,
      "text": "- Login Response with Login accept as the Final-Response (T bit set to 1 and the NSG in both request and response is set to FullFeaturePhase). The response includes the protocol version supported by the target and the session ID and may include iSCSI operational or security parameters (that depend on the current stage).",
      "zh-cn": "- Login Response with Login accept as the Final-Response (T bit set to 1 and the NSG in both request and response is set to FullFeaturePhase). The response includes the protocol version supported by the target and the session ID and may include iSCSI operational or security parameters (that depend on the current stage)."
    },
    {
      "indent": 6,
      "text": "- Login Response with Login accept as a partial response (NSG not set to FullFeaturePhase in both request and response) that indicates the start of a negotiation sequence. The response includes the protocol version supported by the target and either security or iSCSI parameters (when no security mechanism is chosen) supported by the target.",
      "zh-cn": "- Login Response with Login accept as a partial response (NSG not set to FullFeaturePhase in both request and response) that indicates the start of a negotiation sequence. The response includes the protocol version supported by the target and either security or iSCSI parameters (when no security mechanism is chosen) supported by the target."
    },
    {
      "indent": 3,
      "text": "If the initiator decides to forego the SecurityNegotiation stage, it issues the Login with the CSG set to LoginOperationalNegotiation, and the target may reply with a Login Response that indicates that it is unwilling to accept the connection (see Section 11.13) without SecurityNegotiation and will terminate the connection with a response of Authentication failure (see Section 11.13.5).",
      "zh-cn": "If the initiator decides to forego the SecurityNegotiation stage, it issues the Login with the CSG set to LoginOperationalNegotiation, and the target may reply with a Login Response that indicates that it is unwilling to accept the connection (see Section 11.13) without SecurityNegotiation and will terminate the connection with a response of Authentication failure (see Section 11.13.5)."
    },
    {
      "indent": 3,
      "text": "If the initiator is willing to negotiate iSCSI security, but is unwilling to make the initial parameter proposal and may accept a connection without iSCSI security, it issues the Login with the T bit set to 1, the CSG set to SecurityNegotiation, and the NSG set to LoginOperationalNegotiation. If the target is also ready to skip security, the Login Response only contains the TargetPortalGroupTag key (see Section 13.9), the T bit set to 1, the CSG set to SecurityNegotiation, and the NSG set to LoginOperationalNegotiation.",
      "zh-cn": "If the initiator is willing to negotiate iSCSI security, but is unwilling to make the initial parameter proposal and may accept a connection without iSCSI security, it issues the Login with the T bit set to 1, the CSG set to SecurityNegotiation, and the NSG set to LoginOperationalNegotiation. If the target is also ready to skip security, the Login Response only contains the TargetPortalGroupTag key (see Section 13.9), the T bit set to 1, the CSG set to SecurityNegotiation, and the NSG set to LoginOperationalNegotiation."
    },
    {
      "indent": 3,
      "text": "An initiator that chooses to operate without iSCSI security and with all the operational parameters taking the default values issues the Login with the T bit set to 1, the CSG set to LoginOperationalNegotiation, and the NSG set to FullFeaturePhase. If the target is also ready to forego security and can finish its LoginOperationalNegotiation, the Login Response has the T bit set to 1, the CSG set to LoginOperationalNegotiation, and the NSG set to FullFeaturePhase in the next stage.",
      "zh-cn": "An initiator that chooses to operate without iSCSI security and with all the operational parameters taking the default values issues the Login with the T bit set to 1, the CSG set to LoginOperationalNegotiation, and the NSG set to FullFeaturePhase. If the target is also ready to forego security and can finish its LoginOperationalNegotiation, the Login Response has the T bit set to 1, the CSG set to LoginOperationalNegotiation, and the NSG set to FullFeaturePhase in the next stage."
    },
    {
      "indent": 3,
      "text": "During the Login Phase, the iSCSI target MUST return the TargetPortalGroupTag key with the first Login Response PDU with which it is allowed to do so (i.e., the first Login Response issued after the first Login Request with the C bit set to 0) for all session types. The TargetPortalGroupTag key value indicates the iSCSI portal group servicing the Login Request PDU. If the reconfiguration of iSCSI portal groups is a concern in a given environment, the iSCSI initiator should use this key to ascertain that it had indeed initiated the Login Phase with the intended target portal group.",
      "zh-cn": "During the Login Phase, the iSCSI target MUST return the TargetPortalGroupTag key with the first Login Response PDU with which it is allowed to do so (i.e., the first Login Response issued after the first Login Request with the C bit set to 0) for all session types. The TargetPortalGroupTag key value indicates the iSCSI portal group servicing the Login Request PDU. If the reconfiguration of iSCSI portal groups is a concern in a given environment, the iSCSI initiator should use this key to ascertain that it had indeed initiated the Login Phase with the intended target portal group."
    },
    {
      "indent": 0,
      "text": "6.3.2. iSCSI Security Negotiation",
      "section_title": true,
      "zh-cn": "6.3.2. iSCSI Security Negotiation"
    },
    {
      "indent": 3,
      "text": "The security exchange sets the security mechanism and authenticates the initiator and the target to each other. The exchange proceeds according to the authentication method chosen in the negotiation phase and is conducted using the key=value parameters carried in the Login Requests and Responses.",
      "zh-cn": "The security exchange sets the security mechanism and authenticates the initiator and the target to each other. The exchange proceeds according to the authentication method chosen in the negotiation phase and is conducted using the key=value parameters carried in the Login Requests and Responses."
    },
    {
      "indent": 3,
      "text": "An initiator-directed negotiation proceeds as follows:",
      "zh-cn": "An initiator-directed negotiation proceeds as follows:"
    },
    {
      "indent": 6,
      "text": "- The initiator sends a Login Request with an ordered list of the options it supports (authentication algorithm). The options are listed in the initiator's order of preference. The initiator MAY also send private or public extension options.",
      "zh-cn": "- The initiator sends a Login Request with an ordered list of the options it supports (authentication algorithm). The options are listed in the initiator's order of preference. The initiator MAY also send private or public extension options."
    },
    {
      "indent": 6,
      "text": "- The target MUST reply with the first option in the list it supports and is allowed to use for the specific initiator, unless it does not support any, in which case it MUST answer with \"Reject\" (see Section 6.2). The parameters are encoded in UTF-8 as key=value. For security parameters, see Section 12.",
      "zh-cn": "- The target MUST reply with the first option in the list it supports and is allowed to use for the specific initiator, unless it does not support any, in which case it MUST answer with \"Reject\" (see Section 6.2). The parameters are encoded in UTF-8 as key=value. For security parameters, see Section 12."
    },
    {
      "indent": 6,
      "text": "- When the initiator considers itself ready to conclude the SecurityNegotiation stage, it sets the T bit to 1 and the NSG to what it would like the next stage to be. The target will then set the T bit to 1 and set the NSG to the next stage in the Login Response when it finishes sending its security keys. The next stage selected will be the one the target selected. If the next stage is FullFeaturePhase, the target MUST reply with a Login Response with the TSIH value.",
      "zh-cn": "- When the initiator considers itself ready to conclude the SecurityNegotiation stage, it sets the T bit to 1 and the NSG to what it would like the next stage to be. The target will then set the T bit to 1 and set the NSG to the next stage in the Login Response when it finishes sending its security keys. The next stage selected will be the one the target selected. If the next stage is FullFeaturePhase, the target MUST reply with a Login Response with the TSIH value."
    },
    {
      "indent": 3,
      "text": "If the security negotiation fails at the target, then the target MUST send the appropriate Login Response PDU. If the security negotiation fails at the initiator, the initiator SHOULD close the connection.",
      "zh-cn": "If the security negotiation fails at the target, then the target MUST send the appropriate Login Response PDU. If the security negotiation fails at the initiator, the initiator SHOULD close the connection."
    },
    {
      "indent": 3,
      "text": "It should be noted that the negotiation might also be directed by the target if the initiator does support security but is not ready to direct the negotiation (propose options); see Appendix B for an example.",
      "zh-cn": "It should be noted that the negotiation might also be directed by the target if the initiator does support security but is not ready to direct the negotiation (propose options); see Appendix B for an example."
    },
    {
      "indent": 0,
      "text": "6.3.3. Operational Parameter Negotiation during the Login Phase",
      "section_title": true,
      "zh-cn": "6.3.3. Operational Parameter Negotiation during the Login Phase"
    },
    {
      "indent": 3,
      "text": "Operational parameter negotiation during the Login Phase MAY be done:",
      "zh-cn": "Operational parameter negotiation during the Login Phase MAY be done:"
    },
    {
      "indent": 6,
      "text": "- starting with the first Login Request if the initiator does not propose any security/integrity option.",
      "zh-cn": "- starting with the first Login Request if the initiator does not propose any security/integrity option."
    },
    {
      "indent": 6,
      "text": "- starting immediately after the security negotiation if the initiator and target perform such a negotiation.",
      "zh-cn": "- starting immediately after the security negotiation if the initiator and target perform such a negotiation."
    },
    {
      "indent": 3,
      "text": "Operational parameter negotiation MAY involve several Login Request-Login Response exchanges started and terminated by the initiator. The initiator MUST indicate its intent to terminate the negotiation by setting the T bit to 1; the target sets the T bit to 1 on the last response.",
      "zh-cn": "Operational parameter negotiation MAY involve several Login Request-Login Response exchanges started and terminated by the initiator. The initiator MUST indicate its intent to terminate the negotiation by setting the T bit to 1; the target sets the T bit to 1 on the last response."
    },
    {
      "indent": 3,
      "text": "Even when the initiator indicates its intent to switch stages by setting the T bit to 1 in a Login Request, the target MAY respond with a Login Response with the T bit set to 0. In that case, the initiator SHOULD continue to set the T bit to 1 in subsequent Login Requests (even empty requests) that it sends, until the target sends a Login Response with the T bit set to 1 or sends a key that requires the initiator to set the T bit to 0.",
      "zh-cn": "Even when the initiator indicates its intent to switch stages by setting the T bit to 1 in a Login Request, the target MAY respond with a Login Response with the T bit set to 0. In that case, the initiator SHOULD continue to set the T bit to 1 in subsequent Login Requests (even empty requests) that it sends, until the target sends a Login Response with the T bit set to 1 or sends a key that requires the initiator to set the T bit to 0."
    },
    {
      "indent": 3,
      "text": "Some session-specific parameters can only be specified during the Login Phase of the first connection of a session (i.e., begun by a Login Request that contains a zero-valued TSIH) -- the leading Login Phase (e.g., the maximum number of connections that can be used for this session).",
      "zh-cn": "Some session-specific parameters can only be specified during the Login Phase of the first connection of a session (i.e., begun by a Login Request that contains a zero-valued TSIH) -- the leading Login Phase (e.g., the maximum number of connections that can be used for this session)."
    },
    {
      "indent": 3,
      "text": "A session is operational once it has at least one connection in the Full Feature Phase. New or replacement connections can only be added to a session after the session is operational.",
      "zh-cn": "A session is operational once it has at least one connection in the Full Feature Phase. New or replacement connections can only be added to a session after the session is operational."
    },
    {
      "indent": 3,
      "text": "For operational parameters, see Section 13.",
      "zh-cn": "For operational parameters, see Section 13."
    },
    {
      "indent": 0,
      "text": "6.3.4. Connection Reinstatement",
      "section_title": true,
      "zh-cn": "6.3.4. Connection Reinstatement"
    },
    {
      "indent": 3,
      "text": "Connection reinstatement is the process of an initiator logging in with an ISID-TSIH-CID combination that is possibly active from the target's perspective, which causes the implicit logging out of the connection corresponding to the CID and reinstatement of a new Full Feature Phase iSCSI connection in its place (with the same CID). Thus, the TSIH in the Login Request PDU MUST be non-zero, and the CID does not change during a connection reinstatement. The Login Request performs the logout function of the old connection if an explicit logout was not performed earlier. In sessions with a single connection, this may imply the opening of a second connection with the sole purpose of cleaning up the first. Targets MUST support opening a second connection even when they do not support multiple connections in the Full Feature Phase if ErrorRecoveryLevel is 2 and SHOULD support opening a second connection if ErrorRecoveryLevel is less than 2.",
      "zh-cn": "Connection reinstatement is the process of an initiator logging in with an ISID-TSIH-CID combination that is possibly active from the target's perspective, which causes the implicit logging out of the connection corresponding to the CID and reinstatement of a new Full Feature Phase iSCSI connection in its place (with the same CID). Thus, the TSIH in the Login Request PDU MUST be non-zero, and the CID does not change during a connection reinstatement. The Login Request performs the logout function of the old connection if an explicit logout was not performed earlier. In sessions with a single connection, this may imply the opening of a second connection with the sole purpose of cleaning up the first. Targets MUST support opening a second connection even when they do not support multiple connections in the Full Feature Phase if ErrorRecoveryLevel is 2 and SHOULD support opening a second connection if ErrorRecoveryLevel is less than 2."
    },
    {
      "indent": 3,
      "text": "If the operational ErrorRecoveryLevel is 2, connection reinstatement enables future task reassignment. If the operational ErrorRecoveryLevel is less than 2, connection reinstatement is the",
      "zh-cn": "If the operational ErrorRecoveryLevel is 2, connection reinstatement enables future task reassignment. If the operational ErrorRecoveryLevel is less than 2, connection reinstatement is the"
    },
    {
      "indent": 3,
      "text": "replacement of the old CID without enabling task reassignment. In this case, all the tasks that were active on the old CID must be immediately terminated without further notice to the initiator.",
      "zh-cn": "replacement of the old CID without enabling task reassignment. In this case, all the tasks that were active on the old CID must be immediately terminated without further notice to the initiator."
    },
    {
      "indent": 3,
      "text": "The initiator connection state MUST be CLEANUP_WAIT (Section 8.1.3) when the initiator attempts a connection reinstatement.",
      "zh-cn": "The initiator connection state MUST be CLEANUP_WAIT (Section 8.1.3) when the initiator attempts a connection reinstatement."
    },
    {
      "indent": 3,
      "text": "In practical terms, in addition to the implicit logout of the old connection, reinstatement is equivalent to a new connection login.",
      "zh-cn": "In practical terms, in addition to the implicit logout of the old connection, reinstatement is equivalent to a new connection login."
    },
    {
      "indent": 0,
      "text": "6.3.5. Session Reinstatement, Closure, and Timeout",
      "section_title": true,
      "zh-cn": "6.3.5. Session Reinstatement, Closure, and Timeout"
    },
    {
      "indent": 3,
      "text": "Session reinstatement is the process of an initiator logging in with an ISID that is possibly active from the target's perspective for that initiator, thus implicitly logging out the session that corresponds to the ISID and reinstating a new iSCSI session in its place (with the same ISID). Therefore, the TSIH in the Login PDU MUST be zero to signal session reinstatement. Session reinstatement causes all the tasks that were active on the old session to be immediately terminated by the target without further notice to the initiator.",
      "zh-cn": "Session reinstatement is the process of an initiator logging in with an ISID that is possibly active from the target's perspective for that initiator, thus implicitly logging out the session that corresponds to the ISID and reinstating a new iSCSI session in its place (with the same ISID). Therefore, the TSIH in the Login PDU MUST be zero to signal session reinstatement. Session reinstatement causes all the tasks that were active on the old session to be immediately terminated by the target without further notice to the initiator."
    },
    {
      "indent": 3,
      "text": "The initiator session state MUST be FAILED (Section 8.3) when the initiator attempts a session reinstatement.",
      "zh-cn": "The initiator session state MUST be FAILED (Section 8.3) when the initiator attempts a session reinstatement."
    },
    {
      "indent": 3,
      "text": "Session closure is an event defined to be one of the following:",
      "zh-cn": "Session closure is an event defined to be one of the following:"
    },
    {
      "indent": 6,
      "text": "- a successful \"session close\" logout.",
      "zh-cn": "- a successful \"session close\" logout."
    },
    {
      "indent": 6,
      "text": "- a successful \"connection close\" logout for the last Full Feature Phase connection when no other connection in the session is waiting for cleanup (Section 8.2) and no tasks in the session are waiting for reassignment.",
      "zh-cn": "- a successful \"connection close\" logout for the last Full Feature Phase connection when no other connection in the session is waiting for cleanup (Section 8.2) and no tasks in the session are waiting for reassignment."
    },
    {
      "indent": 3,
      "text": "Session timeout is an event defined to occur when the last connection state timeout expires and no tasks are waiting for reassignment. This takes the session to the FREE state (see the session state diagrams in Section 8.3).",
      "zh-cn": "Session timeout is an event defined to occur when the last connection state timeout expires and no tasks are waiting for reassignment. This takes the session to the FREE state (see the session state diagrams in Section 8.3)."
    },
    {
      "indent": 0,
      "text": "6.3.5.1. Loss of Nexus Notification",
      "section_title": true,
      "zh-cn": "6.3.5.1. Loss of Nexus Notification"
    },
    {
      "indent": 3,
      "text": "The iSCSI layer provides the SCSI layer with the \"I_T nexus loss\" notification when any one of the following events happens:",
      "zh-cn": "The iSCSI layer provides the SCSI layer with the \"I_T nexus loss\" notification when any one of the following events happens:"
    },
    {
      "indent": 6,
      "text": "- successful completion of session reinstatement",
      "zh-cn": "- successful completion of session reinstatement"
    },
    {
      "indent": 6,
      "text": "- session closure event",
      "zh-cn": "- session closure event"
    },
    {
      "indent": 6,
      "text": "- session timeout event",
      "zh-cn": "- session timeout event"
    },
    {
      "indent": 3,
      "text": "Certain SCSI object clearing actions may result due to the notification in the SCSI end nodes, as documented in Appendix E.",
      "zh-cn": "Certain SCSI object clearing actions may result due to the notification in the SCSI end nodes, as documented in Appendix E."
    },
    {
      "indent": 0,
      "text": "6.3.6. Session Continuation and Failure",
      "section_title": true,
      "zh-cn": "6.3.6. Session Continuation and Failure"
    },
    {
      "indent": 3,
      "text": "Session continuation is the process by which the state of a preexisting session continues to be used by connection reinstatement (Section 6.3.4) or by adding a connection with a new CID. Either of these actions associates the new transport connection with the session state.",
      "zh-cn": "Session continuation is the process by which the state of a preexisting session continues to be used by connection reinstatement (Section 6.3.4) or by adding a connection with a new CID. Either of these actions associates the new transport connection with the session state."
    },
    {
      "indent": 3,
      "text": "Session failure is an event where the last Full Feature Phase connection reaches the CLEANUP_WAIT state (Section 8.2) or completes a successful recovery logout, thus causing all active tasks (that are formerly allegiant to the connection) to start waiting for task reassignment.",
      "zh-cn": "Session failure is an event where the last Full Feature Phase connection reaches the CLEANUP_WAIT state (Section 8.2) or completes a successful recovery logout, thus causing all active tasks (that are formerly allegiant to the connection) to start waiting for task reassignment."
    },
    {
      "indent": 0,
      "text": "6.4. Operational Parameter Negotiation outside the Login Phase",
      "section_title": true,
      "zh-cn": "6.4. Operational Parameter Negotiation outside the Login Phase"
    },
    {
      "indent": 3,
      "text": "Some operational parameters MAY be negotiated outside (after) the Login Phase.",
      "zh-cn": "Some operational parameters MAY be negotiated outside (after) the Login Phase."
    },
    {
      "indent": 3,
      "text": "Parameter negotiation in the Full Feature Phase is done through Text Requests and Responses. Operational parameter negotiation MAY involve several Text Request-Text Response exchanges, all of which use the same Initiator Task Tag; the initiator always starts and terminates each of these exchanges. The initiator MUST indicate its intent to finish the negotiation by setting the F bit to 1; the target sets the F bit to 1 on the last response.",
      "zh-cn": "Parameter negotiation in the Full Feature Phase is done through Text Requests and Responses. Operational parameter negotiation MAY involve several Text Request-Text Response exchanges, all of which use the same Initiator Task Tag; the initiator always starts and terminates each of these exchanges. The initiator MUST indicate its intent to finish the negotiation by setting the F bit to 1; the target sets the F bit to 1 on the last response."
    },
    {
      "indent": 3,
      "text": "If the target responds to a Text Request with the F bit set to 1 with a Text Response with the F bit set to 0, the initiator should keep sending the Text Request (even empty requests) with the F bit set to 1 while it still wants to finish the negotiation, until it receives the Text Response with the F bit set to 1. Responding to a Text Request with the F bit set to 1 with an empty (no key=value pairs) response with the F bit set to 0 is discouraged.",
      "zh-cn": "If the target responds to a Text Request with the F bit set to 1 with a Text Response with the F bit set to 0, the initiator should keep sending the Text Request (even empty requests) with the F bit set to 1 while it still wants to finish the negotiation, until it receives the Text Response with the F bit set to 1. Responding to a Text Request with the F bit set to 1 with an empty (no key=value pairs) response with the F bit set to 0 is discouraged."
    },
    {
      "indent": 3,
      "text": "Even when the initiator indicates its intent to finish the negotiation by setting the F bit to 1 in a Text Request, the target MAY respond with a Text Response with the F bit set to 0. In that case, the initiator SHOULD continue to set the F bit to 1 in subsequent Text Requests (even empty requests) that it sends, until the target sends the final Text Response with the F bit set to 1. Note that in the same case of a Text Request with the F bit set to 1, the target SHOULD NOT respond with an empty (no key=value pairs) Text Response with the F bit set to 0, because such a response may cause the initiator to abandon the negotiation.",
      "zh-cn": "Even when the initiator indicates its intent to finish the negotiation by setting the F bit to 1 in a Text Request, the target MAY respond with a Text Response with the F bit set to 0. In that case, the initiator SHOULD continue to set the F bit to 1 in subsequent Text Requests (even empty requests) that it sends, until the target sends the final Text Response with the F bit set to 1. Note that in the same case of a Text Request with the F bit set to 1, the target SHOULD NOT respond with an empty (no key=value pairs) Text Response with the F bit set to 0, because such a response may cause the initiator to abandon the negotiation."
    },
    {
      "indent": 3,
      "text": "Targets MUST NOT submit parameters that require an additional initiator Text Request in a Text Response with the F bit set to 1.",
      "zh-cn": "Targets MUST NOT submit parameters that require an additional initiator Text Request in a Text Response with the F bit set to 1."
    },
    {
      "indent": 3,
      "text": "In a negotiation sequence, the F bit settings in one Text Request-Text Response pair have no bearing on the F bit settings of the next pair. An initiator that has the F bit set to 1 in a request and is being answered with an F bit setting of 0 may issue the next request with the F bit set to 0.",
      "zh-cn": "In a negotiation sequence, the F bit settings in one Text Request-Text Response pair have no bearing on the F bit settings of the next pair. An initiator that has the F bit set to 1 in a request and is being answered with an F bit setting of 0 may issue the next request with the F bit set to 0."
    },
    {
      "indent": 3,
      "text": "Whenever the target responds with the F bit set to 0, it MUST set the Target Transfer Tag to a value other than the default 0xffffffff.",
      "zh-cn": "Whenever the target responds with the F bit set to 0, it MUST set the Target Transfer Tag to a value other than the default 0xffffffff."
    },
    {
      "indent": 3,
      "text": "An initiator MAY reset an operational parameter negotiation by issuing a Text Request with the Target Transfer Tag set to the value 0xffffffff after receiving a response with the Target Transfer Tag set to a value other than 0xffffffff. A target may reset an operational parameter negotiation by answering a Text Request with a Reject PDU.",
      "zh-cn": "An initiator MAY reset an operational parameter negotiation by issuing a Text Request with the Target Transfer Tag set to the value 0xffffffff after receiving a response with the Target Transfer Tag set to a value other than 0xffffffff. A target may reset an operational parameter negotiation by answering a Text Request with a Reject PDU."
    },
    {
      "indent": 3,
      "text": "Neither the initiator nor the target should attempt to declare or negotiate a parameter more than once during any negotiation sequence, except for responses to specific keys that explicitly allow repeated key declarations (e.g., TargetAddress). If such an attempt is detected by the target, the target MUST respond with a Reject PDU with a reason of \"Protocol Error\". The initiator MUST reset the negotiation as outlined above.",
      "zh-cn": "Neither the initiator nor the target should attempt to declare or negotiate a parameter more than once during any negotiation sequence, except for responses to specific keys that explicitly allow repeated key declarations (e.g., TargetAddress). If such an attempt is detected by the target, the target MUST respond with a Reject PDU with a reason of \"Protocol Error\". The initiator MUST reset the negotiation as outlined above."
    },
    {
      "indent": 3,
      "text": "Parameters negotiated by a text exchange negotiation sequence only become effective after the negotiation sequence is completed.",
      "zh-cn": "Parameters negotiated by a text exchange negotiation sequence only become effective after the negotiation sequence is completed."
    },
    {
      "indent": 0,
      "text": "7. iSCSI Error Handling and Recovery",
      "section_title": true,
      "zh-cn": "7. iSCSI Error Handling and Recovery"
    },
    {
      "indent": 0,
      "text": "7.1. Overview",
      "section_title": true,
      "zh-cn": "7.1. Overview"
    },
    {
      "indent": 0,
      "text": "7.1.1. Background",
      "section_title": true,
      "zh-cn": "7.1.1. Background"
    },
    {
      "indent": 3,
      "text": "The following two considerations prompted the design of much of the error recovery functionality in iSCSI:",
      "zh-cn": "The following two considerations prompted the design of much of the error recovery functionality in iSCSI:"
    },
    {
      "indent": 6,
      "text": "- An iSCSI PDU may fail the digest check and be dropped, despite being received by the TCP layer. The iSCSI layer must optionally be allowed to recover such dropped PDUs.",
      "zh-cn": "- An iSCSI PDU may fail the digest check and be dropped, despite being received by the TCP layer. The iSCSI layer must optionally be allowed to recover such dropped PDUs."
    },
    {
      "indent": 6,
      "text": "- A TCP connection may fail at any time during the data transfer. All the active tasks must optionally be allowed to be continued on a different TCP connection within the same session.",
      "zh-cn": "- A TCP connection may fail at any time during the data transfer. All the active tasks must optionally be allowed to be continued on a different TCP connection within the same session."
    },
    {
      "indent": 3,
      "text": "Implementations have considerable flexibility in deciding what degree of error recovery to support, when to use it, and by which mechanisms to achieve the required behavior. Only the externally visible actions of the error recovery mechanisms must be standardized to ensure interoperability.",
      "zh-cn": "Implementations have considerable flexibility in deciding what degree of error recovery to support, when to use it, and by which mechanisms to achieve the required behavior. Only the externally visible actions of the error recovery mechanisms must be standardized to ensure interoperability."
    },
    {
      "indent": 3,
      "text": "This section describes a general model for recovery in support of interoperability. See Appendix D for further details on how the described model may be implemented. Compliant implementations do not have to match the implementation details of this model as presented, but the external behavior of such implementations must correspond to the externally observable characteristics of the presented model.",
      "zh-cn": "This section describes a general model for recovery in support of interoperability. See Appendix D for further details on how the described model may be implemented. Compliant implementations do not have to match the implementation details of this model as presented, but the external behavior of such implementations must correspond to the externally observable characteristics of the presented model."
    },
    {
      "indent": 0,
      "text": "7.1.2. Goals",
      "section_title": true,
      "zh-cn": "7.1.2. Goals"
    },
    {
      "indent": 3,
      "text": "The major design goals of the iSCSI error recovery scheme are as follows:",
      "zh-cn": "The major design goals of the iSCSI error recovery scheme are as follows:"
    },
    {
      "indent": 6,
      "text": "- Allow iSCSI implementations to meet different requirements by defining a collection of error recovery mechanisms from which implementations may choose.",
      "zh-cn": "- Allow iSCSI implementations to meet different requirements by defining a collection of error recovery mechanisms from which implementations may choose."
    },
    {
      "indent": 6,
      "text": "- Ensure interoperability between any two implementations supporting different sets of error recovery capabilities.",
      "zh-cn": "- Ensure interoperability between any two implementations supporting different sets of error recovery capabilities."
    },
    {
      "indent": 6,
      "text": "- Define the error recovery mechanisms to ensure command ordering even in the face of errors, for initiators that demand ordering.",
      "zh-cn": "- Define the error recovery mechanisms to ensure command ordering even in the face of errors, for initiators that demand ordering."
    },
    {
      "indent": 6,
      "text": "- Do not make additions in the fast path, but allow moderate complexity in the error recovery path.",
      "zh-cn": "- Do not make additions in the fast path, but allow moderate complexity in the error recovery path."
    },
    {
      "indent": 6,
      "text": "- Prevent both the initiator and target from attempting to recover the same set of PDUs at the same time. For example, there must be a clear \"error recovery functionality distribution\" between the initiator and target.",
      "zh-cn": "- Prevent both the initiator and target from attempting to recover the same set of PDUs at the same time. For example, there must be a clear \"error recovery functionality distribution\" between the initiator and target."
    },
    {
      "indent": 0,
      "text": "7.1.3. Protocol Features and State Expectations",
      "section_title": true,
      "zh-cn": "7.1.3. Protocol Features and State Expectations"
    },
    {
      "indent": 3,
      "text": "The initiator mechanisms defined in connection with error recovery are:",
      "zh-cn": "The initiator mechanisms defined in connection with error recovery are:"
    },
    {
      "indent": 6,
      "text": "a) NOP-Out to probe sequence numbers of the target (Section 11.18)",
      "zh-cn": "a) NOP-Out to probe sequence numbers of the target (Section 11.18)"
    },
    {
      "indent": 6,
      "text": "b) Command retry (Section 7.2.1)",
      "zh-cn": "b) Command retry (Section 7.2.1)"
    },
    {
      "indent": 6,
      "text": "c) Recovery R2T support (Section 7.8)",
      "zh-cn": "c) Recovery R2T support (Section 7.8)"
    },
    {
      "indent": 6,
      "text": "d) Requesting retransmission of status/data/R2T using the SNACK facility (Section 11.16)",
      "zh-cn": "d) Requesting retransmission of status/data/R2T using the SNACK facility (Section 11.16)"
    },
    {
      "indent": 6,
      "text": "e) Acknowledging the receipt of the data (Section 11.16)",
      "zh-cn": "e) Acknowledging the receipt of the data (Section 11.16)"
    },
    {
      "indent": 6,
      "text": "f) Reassigning the connection allegiance of a task to a different TCP connection (Section 7.2.2)",
      "zh-cn": "f) Reassigning the connection allegiance of a task to a different TCP connection (Section 7.2.2)"
    },
    {
      "indent": 6,
      "text": "g) Terminating the entire iSCSI session to start afresh (Section 7.1.4.4)",
      "zh-cn": "g) Terminating the entire iSCSI session to start afresh (Section 7.1.4.4)"
    },
    {
      "indent": 3,
      "text": "The target mechanisms defined in connection with error recovery are:",
      "zh-cn": "The target mechanisms defined in connection with error recovery are:"
    },
    {
      "indent": 6,
      "text": "a) NOP-In to probe sequence numbers of the initiator (Section 11.19)",
      "zh-cn": "a) NOP-In to probe sequence numbers of the initiator (Section 11.19)"
    },
    {
      "indent": 6,
      "text": "b) Requesting retransmission of data using the recovery R2T feature (Section 7.8)",
      "zh-cn": "b) Requesting retransmission of data using the recovery R2T feature (Section 7.8)"
    },
    {
      "indent": 6,
      "text": "c) SNACK support (Section 11.16)",
      "zh-cn": "c) SNACK support (Section 11.16)"
    },
    {
      "indent": 6,
      "text": "d) Requesting that parts of read data be acknowledged (Section 11.7.2)",
      "zh-cn": "d) Requesting that parts of read data be acknowledged (Section 11.7.2)"
    },
    {
      "indent": 6,
      "text": "e) Allegiance reassignment support (Section 7.2.2)",
      "zh-cn": "e) Allegiance reassignment support (Section 7.2.2)"
    },
    {
      "indent": 6,
      "text": "f) Terminating the entire iSCSI session to force the initiator to start over (Section 7.1.4.4)",
      "zh-cn": "f) Terminating the entire iSCSI session to force the initiator to start over (Section 7.1.4.4)"
    },
    {
      "indent": 3,
      "text": "For any outstanding SCSI command, it is assumed that iSCSI, in conjunction with SCSI at the initiator, is able to keep enough information to be able to rebuild the command PDU and that outgoing",
      "zh-cn": "For any outstanding SCSI command, it is assumed that iSCSI, in conjunction with SCSI at the initiator, is able to keep enough information to be able to rebuild the command PDU and that outgoing"
    },
    {
      "indent": 3,
      "text": "data is available (in host memory) for retransmission while the command is outstanding. It is also assumed that at the target, incoming data (read data) MAY be kept for recovery, or it can be reread from a device server.",
      "zh-cn": "data is available (in host memory) for retransmission while the command is outstanding. It is also assumed that at the target, incoming data (read data) MAY be kept for recovery, or it can be reread from a device server."
    },
    {
      "indent": 3,
      "text": "It is further assumed that a target will keep the \"status and sense\" for a command it has executed if it supports status retransmission.",
      "zh-cn": "It is further assumed that a target will keep the \"status and sense\" for a command it has executed if it supports status retransmission."
    },
    {
      "indent": 3,
      "text": "A target that agrees to support data retransmission is expected to be prepared to retransmit the outgoing data (i.e., Data-In) on request until either the status for the completed command is acknowledged or the data in question has been separately acknowledged.",
      "zh-cn": "A target that agrees to support data retransmission is expected to be prepared to retransmit the outgoing data (i.e., Data-In) on request until either the status for the completed command is acknowledged or the data in question has been separately acknowledged."
    },
    {
      "indent": 0,
      "text": "7.1.4. Recovery Classes",
      "section_title": true,
      "zh-cn": "7.1.4. Recovery Classes"
    },
    {
      "indent": 3,
      "text": "iSCSI enables the following classes of recovery (in the order of increasing scope of affected iSCSI tasks):",
      "zh-cn": "iSCSI enables the following classes of recovery (in the order of increasing scope of affected iSCSI tasks):"
    },
    {
      "indent": 6,
      "text": "- within a command (i.e., without requiring command restart)",
      "zh-cn": "- within a command (i.e., without requiring command restart)"
    },
    {
      "indent": 6,
      "text": "- within a connection (i.e., without requiring the connection to be rebuilt, but perhaps requiring command restart)",
      "zh-cn": "- within a connection (i.e., without requiring the connection to be rebuilt, but perhaps requiring command restart)"
    },
    {
      "indent": 6,
      "text": "- connection recovery (i.e., perhaps requiring connections to be rebuilt and commands to be reissued)",
      "zh-cn": "- connection recovery (i.e., perhaps requiring connections to be rebuilt and commands to be reissued)"
    },
    {
      "indent": 6,
      "text": "- session recovery",
      "zh-cn": "- session recovery"
    },
    {
      "indent": 3,
      "text": "The recovery scenarios detailed in the rest of this section are representative rather than exclusive. In every case, they detail the lowest recovery class that MAY be attempted. The implementer is left to decide under which circumstances to escalate to the next recovery class and/or what recovery classes to implement. Both the iSCSI target and initiator MAY escalate the error handling to an error recovery class, which impacts a larger number of iSCSI tasks in any of the cases identified in the following discussion.",
      "zh-cn": "The recovery scenarios detailed in the rest of this section are representative rather than exclusive. In every case, they detail the lowest recovery class that MAY be attempted. The implementer is left to decide under which circumstances to escalate to the next recovery class and/or what recovery classes to implement. Both the iSCSI target and initiator MAY escalate the error handling to an error recovery class, which impacts a larger number of iSCSI tasks in any of the cases identified in the following discussion."
    },
    {
      "indent": 3,
      "text": "In all classes, the implementer has the choice of deferring errors to the SCSI initiator (with an appropriate response code), in which case the task, if any, has to be removed from the target and all the side effects, such as ACA, must be considered.",
      "zh-cn": "In all classes, the implementer has the choice of deferring errors to the SCSI initiator (with an appropriate response code), in which case the task, if any, has to be removed from the target and all the side effects, such as ACA, must be considered."
    },
    {
      "indent": 3,
      "text": "The use of within-connection and within-command recovery classes MUST NOT be attempted before the connection is in the Full Feature Phase.",
      "zh-cn": "The use of within-connection and within-command recovery classes MUST NOT be attempted before the connection is in the Full Feature Phase."
    },
    {
      "indent": 3,
      "text": "In the detailed description of the recovery classes, the mandating terms (MUST, SHOULD, MAY, etc.) indicate normative actions to be executed if the recovery class is supported (see Section 7.1.5 for the related negotiation semantics) and used.",
      "zh-cn": "In the detailed description of the recovery classes, the mandating terms (MUST, SHOULD, MAY, etc.) indicate normative actions to be executed if the recovery class is supported (see Section 7.1.5 for the related negotiation semantics) and used."
    },
    {
      "indent": 0,
      "text": "7.1.4.1. Recovery Within-command",
      "section_title": true,
      "zh-cn": "7.1.4.1. Recovery Within-command"
    },
    {
      "indent": 3,
      "text": "At the target, the following cases lend themselves to within-command recovery:",
      "zh-cn": "At the target, the following cases lend themselves to within-command recovery:"
    },
    {
      "indent": 6,
      "text": "Lost data PDU - realized through one of the following:",
      "zh-cn": "Lost data PDU - realized through one of the following:"
    },
    {
      "indent": 6,
      "text": "a) Data digest error - dealt with as specified in Section 7.8, using the option of a recovery R2T",
      "zh-cn": "a) Data digest error - dealt with as specified in Section 7.8, using the option of a recovery R2T"
    },
    {
      "indent": 6,
      "text": "b) Sequence reception timeout (no data or partial-data-and-no-F-bit) - considered an implicit sequence error and dealt with as specified in Section 7.9, using the option of a recovery R2T",
      "zh-cn": "b) Sequence reception timeout (no data or partial-data-and-no-F-bit) - considered an implicit sequence error and dealt with as specified in Section 7.9, using the option of a recovery R2T"
    },
    {
      "indent": 6,
      "text": "c) Header digest error, which manifests as a sequence reception timeout or a sequence error - dealt with as specified in Section 7.9, using the option of a recovery R2T",
      "zh-cn": "c) Header digest error, which manifests as a sequence reception timeout or a sequence error - dealt with as specified in Section 7.9, using the option of a recovery R2T"
    },
    {
      "indent": 3,
      "text": "At the initiator, the following cases lend themselves to within-command recovery:",
      "zh-cn": "At the initiator, the following cases lend themselves to within-command recovery:"
    },
    {
      "indent": 6,
      "text": "Lost data PDU or lost R2T - realized through one of the following:",
      "zh-cn": "Lost data PDU or lost R2T - realized through one of the following:"
    },
    {
      "indent": 6,
      "text": "a) Data digest error - dealt with as specified in Section 7.8, using the option of a SNACK",
      "zh-cn": "a) Data digest error - dealt with as specified in Section 7.8, using the option of a SNACK"
    },
    {
      "indent": 6,
      "text": "b) Sequence reception timeout (no status) or response reception timeout - dealt with as specified in Section 7.9, using the option of a SNACK",
      "zh-cn": "b) Sequence reception timeout (no status) or response reception timeout - dealt with as specified in Section 7.9, using the option of a SNACK"
    },
    {
      "indent": 6,
      "text": "c) Header digest error, which manifests as a sequence reception timeout or a sequence error - dealt with as specified in Section 7.9, using the option of a SNACK",
      "zh-cn": "c) Header digest error, which manifests as a sequence reception timeout or a sequence error - dealt with as specified in Section 7.9, using the option of a SNACK"
    },
    {
      "indent": 3,
      "text": "To avoid a race with the target, which may already have a recovery R2T or a termination response on its way, an initiator SHOULD NOT originate a SNACK for an R2T based on its internal timeouts (if any). Recovery in this case is better left to the target.",
      "zh-cn": "To avoid a race with the target, which may already have a recovery R2T or a termination response on its way, an initiator SHOULD NOT originate a SNACK for an R2T based on its internal timeouts (if any). Recovery in this case is better left to the target."
    },
    {
      "indent": 3,
      "text": "The timeout values used by the initiator and target are outside the scope of this document. A sequence reception timeout is generally a large enough value to allow the data sequence transfer to be complete.",
      "zh-cn": "The timeout values used by the initiator and target are outside the scope of this document. A sequence reception timeout is generally a large enough value to allow the data sequence transfer to be complete."
    },
    {
      "indent": 0,
      "text": "7.1.4.2. Recovery Within-connection",
      "section_title": true,
      "zh-cn": "7.1.4.2. Recovery Within-connection"
    },
    {
      "indent": 3,
      "text": "At the initiator, the following cases lend themselves to within-connection recovery:",
      "zh-cn": "At the initiator, the following cases lend themselves to within-connection recovery:"
    },
    {
      "indent": 6,
      "text": "a) Requests not acknowledged for a long time. Requests are acknowledged explicitly through the ExpCmdSN or implicitly by receiving data and/or status. The initiator MAY retry non-acknowledged commands as specified in Section 7.2.",
      "zh-cn": "a) Requests not acknowledged for a long time. Requests are acknowledged explicitly through the ExpCmdSN or implicitly by receiving data and/or status. The initiator MAY retry non-acknowledged commands as specified in Section 7.2."
    },
    {
      "indent": 6,
      "text": "b) Lost iSCSI numbered response. It is recognized by either identifying a data digest error on a Response PDU or a Data-In PDU carrying the status, or receiving a Response PDU with a higher StatSN than expected. In the first case, digest error handling is done as specified in Section 7.8, using the option of a SNACK. In the second case, sequence error handling is done as specified in Section 7.9, using the option of a SNACK.",
      "zh-cn": "b) Lost iSCSI numbered response. It is recognized by either identifying a data digest error on a Response PDU or a Data-In PDU carrying the status, or receiving a Response PDU with a higher StatSN than expected. In the first case, digest error handling is done as specified in Section 7.8, using the option of a SNACK. In the second case, sequence error handling is done as specified in Section 7.9, using the option of a SNACK."
    },
    {
      "indent": 3,
      "text": "At the target, the following cases lend themselves to within-connection recovery:",
      "zh-cn": "At the target, the following cases lend themselves to within-connection recovery:"
    },
    {
      "indent": 6,
      "text": "- Status/Response not acknowledged for a long time. The target MAY issue a NOP-In (with a valid Target Transfer Tag or otherwise) that carries the next status sequence number it is going to use in the StatSN field. This helps the initiator detect any missing StatSN(s) and issue a SNACK for the status.",
      "zh-cn": "- Status/Response not acknowledged for a long time. The target MAY issue a NOP-In (with a valid Target Transfer Tag or otherwise) that carries the next status sequence number it is going to use in the StatSN field. This helps the initiator detect any missing StatSN(s) and issue a SNACK for the status."
    },
    {
      "indent": 3,
      "text": "The timeout values used by the initiator and the target are outside the scope of this document.",
      "zh-cn": "The timeout values used by the initiator and the target are outside the scope of this document."
    },
    {
      "indent": 0,
      "text": "7.1.4.3. Connection Recovery",
      "section_title": true,
      "zh-cn": "7.1.4.3. Connection Recovery"
    },
    {
      "indent": 3,
      "text": "At an iSCSI initiator, the following cases lend themselves to connection recovery:",
      "zh-cn": "At an iSCSI initiator, the following cases lend themselves to connection recovery:"
    },
    {
      "indent": 6,
      "text": "a) TCP connection failure: The initiator MUST close the connection. It then MUST either implicitly or explicitly log out the failed connection with the reason code \"remove the connection for recovery\" and reassign connection allegiance for all commands still in progress associated with the failed connection on one or more connections (some or all of which MAY be newly established connections) using the \"TASK REASSIGN\" task management function (see Section 11.5.1). For an initiator, a command is in progress as long as it has not received a response or a Data-In PDU including status.",
      "zh-cn": "a) TCP connection failure: The initiator MUST close the connection. It then MUST either implicitly or explicitly log out the failed connection with the reason code \"remove the connection for recovery\" and reassign connection allegiance for all commands still in progress associated with the failed connection on one or more connections (some or all of which MAY be newly established connections) using the \"TASK REASSIGN\" task management function (see Section 11.5.1). For an initiator, a command is in progress as long as it has not received a response or a Data-In PDU including status."
    },
    {
      "indent": 9,
      "text": "Note: The logout function is mandatory. However, a new connection establishment is only mandatory if the failed connection was the last or only connection in the session.",
      "zh-cn": "Note: The logout function is mandatory. However, a new connection establishment is only mandatory if the failed connection was the last or only connection in the session."
    },
    {
      "indent": 6,
      "text": "b) Receiving an Asynchronous Message that indicates that one or all connections in a session have been dropped. The initiator MUST handle it as a TCP connection failure for the connection(s) referred to in the message.",
      "zh-cn": "b) Receiving an Asynchronous Message that indicates that one or all connections in a session have been dropped. The initiator MUST handle it as a TCP connection failure for the connection(s) referred to in the message."
    },
    {
      "indent": 3,
      "text": "At an iSCSI target, the following cases lend themselves to connection recovery:",
      "zh-cn": "At an iSCSI target, the following cases lend themselves to connection recovery:"
    },
    {
      "indent": 6,
      "text": "- TCP connection failure: The target MUST close the connection and, if more than one connection is available, the target SHOULD send an Asynchronous Message that indicates that it has dropped the connection. Then, the target will wait for the initiator to continue recovery.",
      "zh-cn": "- TCP connection failure: The target MUST close the connection and, if more than one connection is available, the target SHOULD send an Asynchronous Message that indicates that it has dropped the connection. Then, the target will wait for the initiator to continue recovery."
    },
    {
      "indent": 0,
      "text": "7.1.4.4. Session Recovery",
      "section_title": true,
      "zh-cn": "7.1.4.4. Session Recovery"
    },
    {
      "indent": 3,
      "text": "Session recovery should be performed when all other recovery attempts have failed. Very simple initiators and targets MAY perform session recovery on all iSCSI errors and rely on recovery on the SCSI layer and above.",
      "zh-cn": "Session recovery should be performed when all other recovery attempts have failed. Very simple initiators and targets MAY perform session recovery on all iSCSI errors and rely on recovery on the SCSI layer and above."
    },
    {
      "indent": 3,
      "text": "Session recovery implies the closing of all TCP connections, internally aborting all executing and queued tasks for the given initiator at the target, terminating all outstanding SCSI commands with an appropriate SCSI service response at the initiator, and restarting a session on a new set of connection(s) (TCP connection establishment and login on all new connections).",
      "zh-cn": "Session recovery implies the closing of all TCP connections, internally aborting all executing and queued tasks for the given initiator at the target, terminating all outstanding SCSI commands with an appropriate SCSI service response at the initiator, and restarting a session on a new set of connection(s) (TCP connection establishment and login on all new connections)."
    },
    {
      "indent": 3,
      "text": "For possible clearing effects of session recovery on SCSI and iSCSI objects, refer to Appendix E.",
      "zh-cn": "For possible clearing effects of session recovery on SCSI and iSCSI objects, refer to Appendix E."
    },
    {
      "indent": 0,
      "text": "7.1.5. Error Recovery Hierarchy",
      "section_title": true,
      "zh-cn": "7.1.5. Error Recovery Hierarchy"
    },
    {
      "indent": 3,
      "text": "The error recovery classes described so far are organized into a hierarchy for ease in understanding and to limit the complexity of the implementation. With a few well-defined recovery levels, interoperability is easier to achieve. The attributes of this hierarchy are as follows:",
      "zh-cn": "The error recovery classes described so far are organized into a hierarchy for ease in understanding and to limit the complexity of the implementation. With a few well-defined recovery levels, interoperability is easier to achieve. The attributes of this hierarchy are as follows:"
    },
    {
      "indent": 6,
      "text": "a) Each level is a superset of the capabilities of the previous level. For example, Level 1 support implies supporting all capabilities of Level 0 and more.",
      "zh-cn": "a) Each level is a superset of the capabilities of the previous level. For example, Level 1 support implies supporting all capabilities of Level 0 and more."
    },
    {
      "indent": 6,
      "text": "b) As a corollary, supporting a higher error recovery level means increased sophistication and possibly an increase in resource requirements.",
      "zh-cn": "b) As a corollary, supporting a higher error recovery level means increased sophistication and possibly an increase in resource requirements."
    },
    {
      "indent": 6,
      "text": "c) Supporting error recovery level \"n\" is advertised and negotiated by each iSCSI entity by exchanging the text key \"ErrorRecoveryLevel=n\". The lower of the two exchanged values is the operational ErrorRecoveryLevel for the session.",
      "zh-cn": "c) Supporting error recovery level \"n\" is advertised and negotiated by each iSCSI entity by exchanging the text key \"ErrorRecoveryLevel=n\". The lower of the two exchanged values is the operational ErrorRecoveryLevel for the session."
    },
    {
      "indent": 3,
      "text": "The following diagram represents the error recovery hierarchy.",
      "zh-cn": "The following diagram represents the error recovery hierarchy."
    },
    {
      "indent": 21,
      "text": "       +\n      / \\\n     / 2 \\      <-- Connection recovery\n    +-----+\n   /   1   \\    <-- Digest failure recovery\n  +---------+\n /     0     \\  <-- Session failure recovery\n+-------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The following table lists the error recovery (ER) capabilities expected from the implementations that support each error recovery level.",
      "zh-cn": "The following table lists the error recovery (ER) capabilities expected from the implementations that support each error recovery level."
    },
    {
      "indent": 4,
      "text": "+-------------------+--------------------------------------------+\n|ErrorRecoveryLevel | Associated Error Recovery Capabilities     |\n+-------------------+--------------------------------------------+\n|        0          | Session recovery class                     |\n|                   | (Session Recovery)                         |\n+-------------------+--------------------------------------------+\n|        1          | Digest failure recovery (see Note below)   |\n|                   | plus the capabilities of ER Level 0        |\n+-------------------+--------------------------------------------+\n|        2          | Connection recovery class                  |\n|                   | (Connection Recovery)                      |\n|                   | plus the capabilities of ER Level 1        |\n+-------------------+--------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Note: Digest failure recovery is comprised of two recovery classes: the Within-connection recovery class (recovery within-connection) and the Within-command recovery class (recovery within-command).",
      "zh-cn": "Note: Digest failure recovery is comprised of two recovery classes: the Within-connection recovery class (recovery within-connection) and the Within-command recovery class (recovery within-command)."
    },
    {
      "indent": 3,
      "text": "When a defined value of ErrorRecoveryLevel is proposed by an originator in a text negotiation, the originator MUST support the functionality defined for the proposed value and, additionally, functionality corresponding to any defined value numerically less than the proposed value. When a defined value of ErrorRecoveryLevel",
      "zh-cn": "When a defined value of ErrorRecoveryLevel is proposed by an originator in a text negotiation, the originator MUST support the functionality defined for the proposed value and, additionally, functionality corresponding to any defined value numerically less than the proposed value. When a defined value of ErrorRecoveryLevel"
    },
    {
      "indent": 3,
      "text": "is returned by a responder in a text negotiation, the responder MUST support the functionality corresponding to the ErrorRecoveryLevel it is accepting.",
      "zh-cn": "is returned by a responder in a text negotiation, the responder MUST support the functionality corresponding to the ErrorRecoveryLevel it is accepting."
    },
    {
      "indent": 3,
      "text": "When either party attempts to use error recovery functionality beyond what is negotiated, the recovery attempts MAY fail, unless an a priori agreement outside the scope of this document exists between the two parties to provide such support.",
      "zh-cn": "When either party attempts to use error recovery functionality beyond what is negotiated, the recovery attempts MAY fail, unless an a priori agreement outside the scope of this document exists between the two parties to provide such support."
    },
    {
      "indent": 3,
      "text": "Implementations MUST support error recovery level \"0\", while the rest are OPTIONAL to implement. In implementation terms, the above striation means that the following incremental sophistication with each level is required:",
      "zh-cn": "Implementations MUST support error recovery level \"0\", while the rest are OPTIONAL to implement. In implementation terms, the above striation means that the following incremental sophistication with each level is required:"
    },
    {
      "indent": 4,
      "text": "+-------------------+--------------------------------------------+\n| Level Transition  | Incremental Requirement                    |\n+-------------------+--------------------------------------------+\n|        0->1       | PDU retransmissions on the same connection |\n+-------------------+--------------------------------------------+\n|        1->2       | Retransmission across connections and      |\n|                   | allegiance reassignment                    |\n+-------------------+--------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "7.2. Retry and Reassign in Recovery",
      "section_title": true,
      "zh-cn": "7.2. Retry and Reassign in Recovery"
    },
    {
      "indent": 3,
      "text": "This section summarizes two important and somewhat related iSCSI protocol features used in error recovery.",
      "zh-cn": "This section summarizes two important and somewhat related iSCSI protocol features used in error recovery."
    },
    {
      "indent": 0,
      "text": "7.2.1. Usage of Retry",
      "section_title": true,
      "zh-cn": "7.2.1. Usage of Retry"
    },
    {
      "indent": 3,
      "text": "By resending the same iSCSI Command PDU (\"retry\") in the absence of a command acknowledgment (by way of an ExpCmdSN update) or a response, an initiator attempts to \"plug\" (what it thinks are) the discontinuities in CmdSN ordering on the target end. Discarded command PDUs, due to digest errors, may have created these discontinuities.",
      "zh-cn": "By resending the same iSCSI Command PDU (\"retry\") in the absence of a command acknowledgment (by way of an ExpCmdSN update) or a response, an initiator attempts to \"plug\" (what it thinks are) the discontinuities in CmdSN ordering on the target end. Discarded command PDUs, due to digest errors, may have created these discontinuities."
    },
    {
      "indent": 3,
      "text": "Retry MUST NOT be used for reasons other than plugging command sequence gaps and, in particular, cannot be used for requesting PDU retransmissions from a target. Any such PDU retransmission requests for a currently allegiant command in progress may be made using the SNACK mechanism described in Section 11.16, although the usage of SNACK is OPTIONAL.",
      "zh-cn": "Retry MUST NOT be used for reasons other than plugging command sequence gaps and, in particular, cannot be used for requesting PDU retransmissions from a target. Any such PDU retransmission requests for a currently allegiant command in progress may be made using the SNACK mechanism described in Section 11.16, although the usage of SNACK is OPTIONAL."
    },
    {
      "indent": 3,
      "text": "If initiators, as part of plugging command sequence gaps as described above, inadvertently issue retries for allegiant commands already in progress (i.e., targets did not see the discontinuities in CmdSN ordering), the duplicate commands are silently ignored by targets as specified in Section 4.2.2.1.",
      "zh-cn": "If initiators, as part of plugging command sequence gaps as described above, inadvertently issue retries for allegiant commands already in progress (i.e., targets did not see the discontinuities in CmdSN ordering), the duplicate commands are silently ignored by targets as specified in Section 4.2.2.1."
    },
    {
      "indent": 3,
      "text": "When an iSCSI command is retried, the command PDU MUST carry the original Initiator Task Tag and the original operational attributes (e.g., flags, function names, LUN, CDB, etc.) as well as the original CmdSN. The command being retried MUST be sent on the same connection as the original command, unless the original connection was already successfully logged out.",
      "zh-cn": "When an iSCSI command is retried, the command PDU MUST carry the original Initiator Task Tag and the original operational attributes (e.g., flags, function names, LUN, CDB, etc.) as well as the original CmdSN. The command being retried MUST be sent on the same connection as the original command, unless the original connection was already successfully logged out."
    },
    {
      "indent": 0,
      "text": "7.2.2. Allegiance Reassignment",
      "section_title": true,
      "zh-cn": "7.2.2. Allegiance Reassignment"
    },
    {
      "indent": 3,
      "text": "By issuing a \"TASK REASSIGN\" task management request (Section 11.5.1), the initiator signals its intent to continue an already active command (but with no current connection allegiance) as part of connection recovery. This means that a new connection allegiance is requested for the command, which seeks to associate it to the connection on which the task management request is being issued. Before the allegiance reassignment is attempted for a task, an implicit or explicit Logout with the reason code \"remove the connection for recovery\" (see Section 11.14.1) MUST be successfully completed for the previous connection to which the task was allegiant.",
      "zh-cn": "By issuing a \"TASK REASSIGN\" task management request (Section 11.5.1), the initiator signals its intent to continue an already active command (but with no current connection allegiance) as part of connection recovery. This means that a new connection allegiance is requested for the command, which seeks to associate it to the connection on which the task management request is being issued. Before the allegiance reassignment is attempted for a task, an implicit or explicit Logout with the reason code \"remove the connection for recovery\" (see Section 11.14.1) MUST be successfully completed for the previous connection to which the task was allegiant."
    },
    {
      "indent": 3,
      "text": "In reassigning connection allegiance for a command, the target SHOULD continue the command from its current state. For example, when reassigning read commands, the target SHOULD take advantage of the ExpDataSN field provided by the Task Management Function Request (which must be set to 0 if there was no data transfer) and bring the read command to completion by sending the remaining data and sending (or resending) the status. The ExpDataSN acknowledges all data sent up to, but not including, the Data-In PDU and/or R2T with the DataSN (or R2TSN) equal to the ExpDataSN. However, targets may choose to send/receive all unacknowledged data or all of the data on a reassignment of connection allegiance if unable to recover or maintain accurate state. Initiators MUST NOT subsequently request data retransmission through Data SNACK for PDUs numbered less than the ExpDataSN (i.e., prior to the acknowledged sequence number). For all types of commands, a reassignment request implies that the task is still considered in progress by the initiator, and the target must conclude the task appropriately if the target returns the \"Function complete\" response to the reassignment request. This might possibly involve retransmission of data/R2T/status PDUs as necessary but MUST involve the (re)transmission of the status PDU.",
      "zh-cn": "In reassigning connection allegiance for a command, the target SHOULD continue the command from its current state. For example, when reassigning read commands, the target SHOULD take advantage of the ExpDataSN field provided by the Task Management Function Request (which must be set to 0 if there was no data transfer) and bring the read command to completion by sending the remaining data and sending (or resending) the status. The ExpDataSN acknowledges all data sent up to, but not including, the Data-In PDU and/or R2T with the DataSN (or R2TSN) equal to the ExpDataSN. However, targets may choose to send/receive all unacknowledged data or all of the data on a reassignment of connection allegiance if unable to recover or maintain accurate state. Initiators MUST NOT subsequently request data retransmission through Data SNACK for PDUs numbered less than the ExpDataSN (i.e., prior to the acknowledged sequence number). For all types of commands, a reassignment request implies that the task is still considered in progress by the initiator, and the target must conclude the task appropriately if the target returns the \"Function complete\" response to the reassignment request. This might possibly involve retransmission of data/R2T/status PDUs as necessary but MUST involve the (re)transmission of the status PDU."
    },
    {
      "indent": 3,
      "text": "It is OPTIONAL for targets to support the allegiance reassignment. This capability is negotiated via the ErrorRecoveryLevel text key during the login time. When a target does not support allegiance reassignment, it MUST respond with a task management response code of \"Task allegiance reassignment not supported\". If allegiance reassignment is supported by the target but the task is still allegiant to a different connection, or a successful recovery Logout of the previously allegiant connection was not performed, the target MUST respond with a task management response code of \"Task still allegiant\".",
      "zh-cn": "It is OPTIONAL for targets to support the allegiance reassignment. This capability is negotiated via the ErrorRecoveryLevel text key during the login time. When a target does not support allegiance reassignment, it MUST respond with a task management response code of \"Task allegiance reassignment not supported\". If allegiance reassignment is supported by the target but the task is still allegiant to a different connection, or a successful recovery Logout of the previously allegiant connection was not performed, the target MUST respond with a task management response code of \"Task still allegiant\"."
    },
    {
      "indent": 3,
      "text": "If allegiance reassignment is supported by the target, the task management response to the reassignment request MUST be issued before the reassignment becomes effective.",
      "zh-cn": "If allegiance reassignment is supported by the target, the task management response to the reassignment request MUST be issued before the reassignment becomes effective."
    },
    {
      "indent": 3,
      "text": "If a SCSI command that involves data input is reassigned, any SNACK Tag it holds for a final response from the original connection is deleted, and the default value of 0 MUST be used instead.",
      "zh-cn": "If a SCSI command that involves data input is reassigned, any SNACK Tag it holds for a final response from the original connection is deleted, and the default value of 0 MUST be used instead."
    },
    {
      "indent": 0,
      "text": "7.3. Usage of Reject PDU in Recovery",
      "section_title": true,
      "zh-cn": "7.3. Usage of Reject PDU in Recovery"
    },
    {
      "indent": 3,
      "text": "Targets MUST NOT implicitly terminate an active task by sending a Reject PDU for any PDU exchanged during the life of the task. If the target decides to terminate the task, a Response PDU (SCSI, Text, Task, etc.) must be returned by the target to conclude the task. If the task had never been active before the Reject (i.e., the Reject is on the command PDU), targets should not send any further responses because the command itself is being discarded.",
      "zh-cn": "Targets MUST NOT implicitly terminate an active task by sending a Reject PDU for any PDU exchanged during the life of the task. If the target decides to terminate the task, a Response PDU (SCSI, Text, Task, etc.) must be returned by the target to conclude the task. If the task had never been active before the Reject (i.e., the Reject is on the command PDU), targets should not send any further responses because the command itself is being discarded."
    },
    {
      "indent": 3,
      "text": "The above rule means that the initiator can eventually expect a response on receiving Rejects, if the received Reject is for a PDU other than the command PDU itself. The non-command Rejects only have diagnostic value in logging the errors, and they can be used for retransmission decisions by the initiators.",
      "zh-cn": "The above rule means that the initiator can eventually expect a response on receiving Rejects, if the received Reject is for a PDU other than the command PDU itself. The non-command Rejects only have diagnostic value in logging the errors, and they can be used for retransmission decisions by the initiators."
    },
    {
      "indent": 3,
      "text": "The CmdSN of the rejected command PDU (if it is a non-immediate command) MUST NOT be considered received by the target (i.e., a command sequence gap must be assumed for the CmdSN), even though the CmdSN of the rejected command PDU may be reliably ascertained. Upon receiving the Reject, the initiator MUST plug the CmdSN gap in order to continue to use the session. The gap may be plugged by either transmitting a command PDU with the same CmdSN or aborting the task (see Section 7.11 for information regarding how an abort may plug a CmdSN gap).",
      "zh-cn": "The CmdSN of the rejected command PDU (if it is a non-immediate command) MUST NOT be considered received by the target (i.e., a command sequence gap must be assumed for the CmdSN), even though the CmdSN of the rejected command PDU may be reliably ascertained. Upon receiving the Reject, the initiator MUST plug the CmdSN gap in order to continue to use the session. The gap may be plugged by either transmitting a command PDU with the same CmdSN or aborting the task (see Section 7.11 for information regarding how an abort may plug a CmdSN gap)."
    },
    {
      "indent": 3,
      "text": "When a data PDU is rejected and its DataSN can be ascertained, a target MUST advance the ExpDataSN for the current data burst if a recovery R2T is being generated. The target MAY advance its ExpDataSN if it does not attempt to recover the lost data PDU.",
      "zh-cn": "When a data PDU is rejected and its DataSN can be ascertained, a target MUST advance the ExpDataSN for the current data burst if a recovery R2T is being generated. The target MAY advance its ExpDataSN if it does not attempt to recover the lost data PDU."
    },
    {
      "indent": 0,
      "text": "7.4. Error Recovery Considerations for Discovery Sessions",
      "section_title": true,
      "zh-cn": "7.4. Error Recovery Considerations for Discovery Sessions"
    },
    {
      "indent": 0,
      "text": "7.4.1. ErrorRecoveryLevel for Discovery Sessions",
      "section_title": true,
      "zh-cn": "7.4.1. ErrorRecoveryLevel for Discovery Sessions"
    },
    {
      "indent": 3,
      "text": "The negotiation of the key ErrorRecoveryLevel is not required for Discovery sessions -- i.e., for sessions that negotiated \"SessionType=Discovery\" -- because the default value of 0 is necessary and sufficient for Discovery sessions. It is, however, possible that some legacy iSCSI implementations might attempt to negotiate the ErrorRecoveryLevel key on Discovery sessions. When such a negotiation attempt is made by the remote side, a compliant iSCSI implementation MUST propose a value of 0 (zero) in response. The operational ErrorRecoveryLevel for Discovery sessions thus MUST be 0. This naturally follows from the functionality constraints that Section 4.3 imposes on Discovery sessions.",
      "zh-cn": "The negotiation of the key ErrorRecoveryLevel is not required for Discovery sessions -- i.e., for sessions that negotiated \"SessionType=Discovery\" -- because the default value of 0 is necessary and sufficient for Discovery sessions. It is, however, possible that some legacy iSCSI implementations might attempt to negotiate the ErrorRecoveryLevel key on Discovery sessions. When such a negotiation attempt is made by the remote side, a compliant iSCSI implementation MUST propose a value of 0 (zero) in response. The operational ErrorRecoveryLevel for Discovery sessions thus MUST be 0. This naturally follows from the functionality constraints that Section 4.3 imposes on Discovery sessions."
    },
    {
      "indent": 0,
      "text": "7.4.2. Reinstatement Semantics for Discovery Sessions",
      "section_title": true,
      "zh-cn": "7.4.2. Reinstatement Semantics for Discovery Sessions"
    },
    {
      "indent": 3,
      "text": "Discovery sessions are intended to be relatively short-lived. Initiators are not expected to establish multiple Discovery sessions to the same iSCSI Network Portal. An initiator may use the same iSCSI Initiator Name and ISID when establishing different unique sessions with different targets and/or different portal groups. This behavior is discussed in Section 10.1.1 and is, in fact, encouraged as conservative reuse of ISIDs.",
      "zh-cn": "Discovery sessions are intended to be relatively short-lived. Initiators are not expected to establish multiple Discovery sessions to the same iSCSI Network Portal. An initiator may use the same iSCSI Initiator Name and ISID when establishing different unique sessions with different targets and/or different portal groups. This behavior is discussed in Section 10.1.1 and is, in fact, encouraged as conservative reuse of ISIDs."
    },
    {
      "indent": 3,
      "text": "The ISID RULE in Section 4.4.3 states that there must not be more than one session with a matching 4-tuple: <InitiatorName, ISID, TargetName, TargetPortalGroupTag>. While the spirit of the ISID RULE applies to Discovery sessions the same as it does for Normal sessions, note that some Discovery sessions differ from the Normal sessions in two important aspects:",
      "zh-cn": "The ISID RULE in Section 4.4.3 states that there must not be more than one session with a matching 4-tuple: <InitiatorName, ISID, TargetName, TargetPortalGroupTag>. While the spirit of the ISID RULE applies to Discovery sessions the same as it does for Normal sessions, note that some Discovery sessions differ from the Normal sessions in two important aspects:"
    },
    {
      "indent": 6,
      "text": "a) Because Appendix C allows a Discovery session to be established without specifying a TargetName key in the Login Request PDU (let us call such a session an \"Unnamed\" Discovery session), there is no target node context to enforce the ISID RULE.",
      "zh-cn": "a) Because Appendix C allows a Discovery session to be established without specifying a TargetName key in the Login Request PDU (let us call such a session an \"Unnamed\" Discovery session), there is no target node context to enforce the ISID RULE."
    },
    {
      "indent": 6,
      "text": "b) Portal groups are defined only in the context of a target node. When the TargetName key is NULL-valued (i.e., not specified), the TargetPortalGroupTag thus cannot be ascertained to enforce the ISID RULE.",
      "zh-cn": "b) Portal groups are defined only in the context of a target node. When the TargetName key is NULL-valued (i.e., not specified), the TargetPortalGroupTag thus cannot be ascertained to enforce the ISID RULE."
    },
    {
      "indent": 3,
      "text": "The following two sections describe Unnamed Discovery sessions and Named Discovery sessions, respectively.",
      "zh-cn": "The following two sections describe Unnamed Discovery sessions and Named Discovery sessions, respectively."
    },
    {
      "indent": 0,
      "text": "7.4.2.1. Unnamed Discovery Sessions",
      "section_title": true,
      "zh-cn": "7.4.2.1. Unnamed Discovery Sessions"
    },
    {
      "indent": 3,
      "text": "For Unnamed Discovery sessions, neither the TargetName nor the TargetPortalGroupTag is available to the targets in order to enforce the ISID RULE. Therefore, the following rule applies.",
      "zh-cn": "For Unnamed Discovery sessions, neither the TargetName nor the TargetPortalGroupTag is available to the targets in order to enforce the ISID RULE. Therefore, the following rule applies."
    },
    {
      "indent": 3,
      "text": "UNNAMED ISID RULE: Targets MUST enforce the uniqueness of the following 4-tuple for Unnamed Discovery sessions: <InitiatorName, ISID, NULL, TargetAddress>. The following semantics are implied by this uniqueness requirement.",
      "zh-cn": "UNNAMED ISID RULE: Targets MUST enforce the uniqueness of the following 4-tuple for Unnamed Discovery sessions: <InitiatorName, ISID, NULL, TargetAddress>. The following semantics are implied by this uniqueness requirement."
    },
    {
      "indent": 3,
      "text": "Targets SHOULD allow concurrent establishment of one Discovery session with each of its Network Portals by the same initiator port with a given iSCSI Node Name and an ISID. Each of the concurrent Discovery sessions, if established by the same initiator port to other Network Portals, MUST be treated as independent sessions -- i.e., one session MUST NOT reinstate the other.",
      "zh-cn": "Targets SHOULD allow concurrent establishment of one Discovery session with each of its Network Portals by the same initiator port with a given iSCSI Node Name and an ISID. Each of the concurrent Discovery sessions, if established by the same initiator port to other Network Portals, MUST be treated as independent sessions -- i.e., one session MUST NOT reinstate the other."
    },
    {
      "indent": 3,
      "text": "A new Unnamed Discovery session that has a matching <InitiatorName, ISID, NULL, TargetAddress> to an existing Discovery session MUST reinstate the existing Unnamed Discovery session. Note thus that only an Unnamed Discovery session may reinstate another Unnamed Discovery session.",
      "zh-cn": "A new Unnamed Discovery session that has a matching <InitiatorName, ISID, NULL, TargetAddress> to an existing Discovery session MUST reinstate the existing Unnamed Discovery session. Note thus that only an Unnamed Discovery session may reinstate another Unnamed Discovery session."
    },
    {
      "indent": 0,
      "text": "7.4.2.2. Named Discovery Sessions",
      "section_title": true,
      "zh-cn": "7.4.2.2. Named Discovery Sessions"
    },
    {
      "indent": 3,
      "text": "For Named Discovery sessions, the TargetName key is specified by the initiator, and thus the target can unambiguously ascertain the TargetPortalGroupTag as well. Since all the four elements of the 4-tuple are known, the ISID RULE MUST be enforced by targets with no changes from Section 4.4.3 semantics. A new session with a matching <InitiatorName, ISID, TargetName, TargetPortalGroupTag> thus will reinstate an existing session. Note in this case that any new iSCSI session (Discovery or Normal) with the matching 4-tuple may reinstate an existing Named Discovery iSCSI session.",
      "zh-cn": "For Named Discovery sessions, the TargetName key is specified by the initiator, and thus the target can unambiguously ascertain the TargetPortalGroupTag as well. Since all the four elements of the 4-tuple are known, the ISID RULE MUST be enforced by targets with no changes from Section 4.4.3 semantics. A new session with a matching <InitiatorName, ISID, TargetName, TargetPortalGroupTag> thus will reinstate an existing session. Note in this case that any new iSCSI session (Discovery or Normal) with the matching 4-tuple may reinstate an existing Named Discovery iSCSI session."
    },
    {
      "indent": 0,
      "text": "7.4.3. Target PDUs during Discovery",
      "section_title": true,
      "zh-cn": "7.4.3. Target PDUs during Discovery"
    },
    {
      "indent": 3,
      "text": "Targets SHOULD NOT send any responses other than a Text Response and Logout Response on a Discovery session, once in the Full Feature Phase.",
      "zh-cn": "Targets SHOULD NOT send any responses other than a Text Response and Logout Response on a Discovery session, once in the Full Feature Phase."
    },
    {
      "indent": 3,
      "text": "Implementation Note: A target may simply drop the connection in a Discovery session when it would have requested a Logout via an Async Message on Normal sessions.",
      "zh-cn": "Implementation Note: A target may simply drop the connection in a Discovery session when it would have requested a Logout via an Async Message on Normal sessions."
    },
    {
      "indent": 0,
      "text": "7.5. Connection Timeout Management",
      "section_title": true,
      "zh-cn": "7.5. Connection Timeout Management"
    },
    {
      "indent": 3,
      "text": "iSCSI defines two session-global timeout values (in seconds) -- Time2Wait and Time2Retain -- that are applicable when an iSCSI Full Feature Phase connection is taken out of service either intentionally or by an exception. Time2Wait is the initial \"respite time\" before attempting an explicit/implicit Logout for the CID in question or task reassignment for the affected tasks (if any). Time2Retain is the maximum time after the initial respite interval that the task and/or connection state(s) is/are guaranteed to be maintained on the target to cater to a possible recovery attempt. Recovery attempts for the connection and/or task(s) SHOULD NOT be made before Time2Wait seconds but MUST be completed within Time2Retain seconds after that initial Time2Wait waiting period.",
      "zh-cn": "iSCSI defines two session-global timeout values (in seconds) -- Time2Wait and Time2Retain -- that are applicable when an iSCSI Full Feature Phase connection is taken out of service either intentionally or by an exception. Time2Wait is the initial \"respite time\" before attempting an explicit/implicit Logout for the CID in question or task reassignment for the affected tasks (if any). Time2Retain is the maximum time after the initial respite interval that the task and/or connection state(s) is/are guaranteed to be maintained on the target to cater to a possible recovery attempt. Recovery attempts for the connection and/or task(s) SHOULD NOT be made before Time2Wait seconds but MUST be completed within Time2Retain seconds after that initial Time2Wait waiting period."
    },
    {
      "indent": 0,
      "text": "7.5.1. Timeouts on Transport Exception Events",
      "section_title": true,
      "zh-cn": "7.5.1. Timeouts on Transport Exception Events"
    },
    {
      "indent": 3,
      "text": "A transport connection shutdown or a transport reset without any preceding iSCSI protocol interactions informing the endpoints of the fact causes a Full Feature Phase iSCSI connection to be abruptly terminated. The timeout values to be used in this case are the negotiated values of DefaultTime2Wait (Section 13.15) and DefaultTime2Retain (Section 13.16) text keys for the session.",
      "zh-cn": "A transport connection shutdown or a transport reset without any preceding iSCSI protocol interactions informing the endpoints of the fact causes a Full Feature Phase iSCSI connection to be abruptly terminated. The timeout values to be used in this case are the negotiated values of DefaultTime2Wait (Section 13.15) and DefaultTime2Retain (Section 13.16) text keys for the session."
    },
    {
      "indent": 0,
      "text": "7.5.2. Timeouts on Planned Decommissioning",
      "section_title": true,
      "zh-cn": "7.5.2. Timeouts on Planned Decommissioning"
    },
    {
      "indent": 3,
      "text": "Any planned decommissioning of a Full Feature Phase iSCSI connection is preceded by either a Logout Response PDU or an Async Message PDU. The Time2Wait and Time2Retain field values (Section 11.15) in a Logout Response PDU, and the Parameter2 and Parameter3 fields of an Async Message (AsyncEvent types \"drop the connection\" or \"drop all the connections\"; see Section 11.9.1), specify the timeout values to be used in each of these cases.",
      "zh-cn": "Any planned decommissioning of a Full Feature Phase iSCSI connection is preceded by either a Logout Response PDU or an Async Message PDU. The Time2Wait and Time2Retain field values (Section 11.15) in a Logout Response PDU, and the Parameter2 and Parameter3 fields of an Async Message (AsyncEvent types \"drop the connection\" or \"drop all the connections\"; see Section 11.9.1), specify the timeout values to be used in each of these cases."
    },
    {
      "indent": 3,
      "text": "These timeout values are only applicable for the affected connection and the tasks active on that connection. These timeout values have no bearing on initiator timers (if any) that are already running on connections or tasks associated with that session.",
      "zh-cn": "These timeout values are only applicable for the affected connection and the tasks active on that connection. These timeout values have no bearing on initiator timers (if any) that are already running on connections or tasks associated with that session."
    },
    {
      "indent": 0,
      "text": "7.6. Implicit Termination of Tasks",
      "section_title": true,
      "zh-cn": "7.6. Implicit Termination of Tasks"
    },
    {
      "indent": 3,
      "text": "A target implicitly terminates the active tasks due to iSCSI protocol dynamics in the following cases:",
      "zh-cn": "A target implicitly terminates the active tasks due to iSCSI protocol dynamics in the following cases:"
    },
    {
      "indent": 6,
      "text": "a) When a connection is implicitly or explicitly logged out with the reason code \"close the connection\" and there are active tasks allegiant to that connection.",
      "zh-cn": "a) When a connection is implicitly or explicitly logged out with the reason code \"close the connection\" and there are active tasks allegiant to that connection."
    },
    {
      "indent": 6,
      "text": "b) When a connection fails and eventually the connection state times out (state transition M1 in Section 8.2.2), and there are active tasks allegiant to that connection.",
      "zh-cn": "b) When a connection fails and eventually the connection state times out (state transition M1 in Section 8.2.2), and there are active tasks allegiant to that connection."
    },
    {
      "indent": 6,
      "text": "c) When a successful Logout with the reason code \"remove the connection for recovery\" is performed while there are active tasks allegiant to that connection, and those tasks eventually time out after the Time2Wait and Time2Retain periods without allegiance reassignment.",
      "zh-cn": "c) When a successful Logout with the reason code \"remove the connection for recovery\" is performed while there are active tasks allegiant to that connection, and those tasks eventually time out after the Time2Wait and Time2Retain periods without allegiance reassignment."
    },
    {
      "indent": 6,
      "text": "d) When a connection is implicitly or explicitly logged out with the reason code \"close the session\" and there are active tasks in that session.",
      "zh-cn": "d) When a connection is implicitly or explicitly logged out with the reason code \"close the session\" and there are active tasks in that session."
    },
    {
      "indent": 3,
      "text": "If the tasks terminated in cases a), b), c), and d) above are SCSI tasks, they must be internally terminated as if with CHECK CONDITION status. This status is only meaningful for appropriately handling the internal SCSI state and SCSI side effects with respect to ordering, because this status is never communicated back as a terminating status to the initiator. However, additional actions may have to be taken at the SCSI level, depending on the SCSI context as defined by the SCSI standards (e.g., queued commands and ACA; UA for the next command on the I_T nexus in cases a), b), and c); etc. -- see [SAM2] and [SPC3]).",
      "zh-cn": "If the tasks terminated in cases a), b), c), and d) above are SCSI tasks, they must be internally terminated as if with CHECK CONDITION status. This status is only meaningful for appropriately handling the internal SCSI state and SCSI side effects with respect to ordering, because this status is never communicated back as a terminating status to the initiator. However, additional actions may have to be taken at the SCSI level, depending on the SCSI context as defined by the SCSI standards (e.g., queued commands and ACA; UA for the next command on the I_T nexus in cases a), b), and c); etc. -- see [SAM2] and [SPC3])."
    },
    {
      "indent": 0,
      "text": "7.7. Format Errors",
      "section_title": true,
      "zh-cn": "7.7. Format Errors"
    },
    {
      "indent": 3,
      "text": "The following two explicit violations of PDU layout rules are format errors:",
      "zh-cn": "The following two explicit violations of PDU layout rules are format errors:"
    },
    {
      "indent": 6,
      "text": "a) Illegal contents of any PDU header field except the Opcode (legal values are specified in Section 11).",
      "zh-cn": "a) Illegal contents of any PDU header field except the Opcode (legal values are specified in Section 11)."
    },
    {
      "indent": 6,
      "text": "b) Inconsistent field contents (consistent field contents are specified in Section 11).",
      "zh-cn": "b) Inconsistent field contents (consistent field contents are specified in Section 11)."
    },
    {
      "indent": 3,
      "text": "Format errors indicate a major implementation flaw in one of the parties.",
      "zh-cn": "Format errors indicate a major implementation flaw in one of the parties."
    },
    {
      "indent": 3,
      "text": "When a target or an initiator receives an iSCSI PDU with a format error, it MUST immediately terminate all transport connections in the session with either a connection close or a connection reset, and escalate the format error to session recovery (see Section 7.1.4.4).",
      "zh-cn": "When a target or an initiator receives an iSCSI PDU with a format error, it MUST immediately terminate all transport connections in the session with either a connection close or a connection reset, and escalate the format error to session recovery (see Section 7.1.4.4)."
    },
    {
      "indent": 3,
      "text": "All initiator-detected PDU construction errors MUST be considered as format errors. Some examples of such errors are:",
      "zh-cn": "All initiator-detected PDU construction errors MUST be considered as format errors. Some examples of such errors are:"
    },
    {
      "indent": 6,
      "text": "- NOP-In with a valid TTT but an invalid LUN",
      "zh-cn": "- NOP-In with a valid TTT but an invalid LUN"
    },
    {
      "indent": 6,
      "text": "- NOP-In with a valid ITT (i.e., a NOP-In response) and also a valid TTT",
      "zh-cn": "- NOP-In with a valid ITT (i.e., a NOP-In response) and also a valid TTT"
    },
    {
      "indent": 6,
      "text": "- SCSI Response PDU with Status=CHECK CONDITION, but DataSegmentLength = 0",
      "zh-cn": "- SCSI Response PDU with Status=CHECK CONDITION, but DataSegmentLength = 0"
    },
    {
      "indent": 0,
      "text": "7.8. Digest Errors",
      "section_title": true,
      "zh-cn": "7.8. Digest Errors"
    },
    {
      "indent": 3,
      "text": "The discussion below regarding the legal choices in handling digest errors excludes session recovery as an explicit option, but either party detecting a digest error may choose to escalate the error to session recovery.",
      "zh-cn": "The discussion below regarding the legal choices in handling digest errors excludes session recovery as an explicit option, but either party detecting a digest error may choose to escalate the error to session recovery."
    },
    {
      "indent": 3,
      "text": "When a target or an initiator receives any iSCSI PDU with a header digest error, it MUST either discard the header and all data up to the beginning of a later PDU or close the connection. Because the digest error indicates that the length field of the header may have been corrupted, the location of the beginning of a later PDU needs to be reliably ascertained by other means, such as the operation of a Sync and Steering layer.",
      "zh-cn": "When a target or an initiator receives any iSCSI PDU with a header digest error, it MUST either discard the header and all data up to the beginning of a later PDU or close the connection. Because the digest error indicates that the length field of the header may have been corrupted, the location of the beginning of a later PDU needs to be reliably ascertained by other means, such as the operation of a Sync and Steering layer."
    },
    {
      "indent": 3,
      "text": "When a target receives any iSCSI PDU with a payload digest error, it MUST answer with a Reject PDU with a reason code of Data-Digest-Error and discard the PDU.",
      "zh-cn": "When a target receives any iSCSI PDU with a payload digest error, it MUST answer with a Reject PDU with a reason code of Data-Digest-Error and discard the PDU."
    },
    {
      "indent": 3,
      "text": "- If the discarded PDU is a solicited or unsolicited iSCSI data PDU (for immediate data in a command PDU, the non-data PDU rule below applies), the target MUST do one of the following:",
      "zh-cn": "- If the discarded PDU is a solicited or unsolicited iSCSI data PDU (for immediate data in a command PDU, the non-data PDU rule below applies), the target MUST do one of the following:"
    },
    {
      "indent": 5,
      "text": "a) Request retransmission with a recovery R2T.",
      "zh-cn": "a) Request retransmission with a recovery R2T."
    },
    {
      "indent": 5,
      "text": "b) Terminate the task with a SCSI Response PDU with a CHECK CONDITION Status and an iSCSI Condition of \"Protocol Service CRC error\" (Section 11.4.7.2). If the target chooses to implement this option, it MUST wait to receive all the data (signaled by a data PDU with the Final bit set for all outstanding R2Ts) before sending the SCSI Response PDU. A task management command (such as an ABORT TASK) from the initiator during this wait may also conclude the task.",
      "zh-cn": "b) Terminate the task with a SCSI Response PDU with a CHECK CONDITION Status and an iSCSI Condition of \"Protocol Service CRC error\" (Section 11.4.7.2). If the target chooses to implement this option, it MUST wait to receive all the data (signaled by a data PDU with the Final bit set for all outstanding R2Ts) before sending the SCSI Response PDU. A task management command (such as an ABORT TASK) from the initiator during this wait may also conclude the task."
    },
    {
      "indent": 3,
      "text": "- No further action is necessary for targets if the discarded PDU is a non-data PDU. In the case of immediate data being present on a discarded command, the immediate data is implicitly recovered when the task is retried (see Section 7.2.1), followed by the entire data transfer for the task.",
      "zh-cn": "- No further action is necessary for targets if the discarded PDU is a non-data PDU. In the case of immediate data being present on a discarded command, the immediate data is implicitly recovered when the task is retried (see Section 7.2.1), followed by the entire data transfer for the task."
    },
    {
      "indent": 3,
      "text": "When an initiator receives any iSCSI PDU with a payload digest error, it MUST discard the PDU.",
      "zh-cn": "When an initiator receives any iSCSI PDU with a payload digest error, it MUST discard the PDU."
    },
    {
      "indent": 6,
      "text": "- If the discarded PDU is an iSCSI data PDU, the initiator MUST do one of the following:",
      "zh-cn": "- If the discarded PDU is an iSCSI data PDU, the initiator MUST do one of the following:"
    },
    {
      "indent": 8,
      "text": "a) Request the desired data PDU through SNACK. In response to the SNACK, the target MUST either resend the data PDU or reject the SNACK with a Reject PDU with a reason code of \"SNACK reject\", in which case:",
      "zh-cn": "a) Request the desired data PDU through SNACK. In response to the SNACK, the target MUST either resend the data PDU or reject the SNACK with a Reject PDU with a reason code of \"SNACK reject\", in which case:"
    },
    {
      "indent": 11,
      "text": "a.1) If the status has not already been sent for the command, the target MUST terminate the command with a CHECK CONDITION Status and an iSCSI Condition of \"SNACK rejected\" (Section 11.4.7.2).",
      "zh-cn": "a.1) If the status has not already been sent for the command, the target MUST terminate the command with a CHECK CONDITION Status and an iSCSI Condition of \"SNACK rejected\" (Section 11.4.7.2)."
    },
    {
      "indent": 11,
      "text": "a.2) If the status was already sent, no further action is necessary for the target. The initiator in this case MUST wait for the status to be received and then discard it, so as to internally signal the completion with CHECK CONDITION Status and an iSCSI Condition of \"Protocol Service CRC error\" (Section 11.4.7.2).",
      "zh-cn": "a.2) If the status was already sent, no further action is necessary for the target. The initiator in this case MUST wait for the status to be received and then discard it, so as to internally signal the completion with CHECK CONDITION Status and an iSCSI Condition of \"Protocol Service CRC error\" (Section 11.4.7.2)."
    },
    {
      "indent": 8,
      "text": "b) Abort the task and terminate the command with an error.",
      "zh-cn": "b) Abort the task and terminate the command with an error."
    },
    {
      "indent": 6,
      "text": "- If the discarded PDU is a response PDU or an unsolicited PDU (e.g., Async, Reject), the initiator MUST do one of the following:",
      "zh-cn": "- If the discarded PDU is a response PDU or an unsolicited PDU (e.g., Async, Reject), the initiator MUST do one of the following:"
    },
    {
      "indent": 8,
      "text": "a) Request PDU retransmission with a status of SNACK.",
      "zh-cn": "a) Request PDU retransmission with a status of SNACK."
    },
    {
      "indent": 8,
      "text": "b) Log out the connection for recovery, and continue the tasks on a different connection instance as described in Section 7.2.",
      "zh-cn": "b) Log out the connection for recovery, and continue the tasks on a different connection instance as described in Section 7.2."
    },
    {
      "indent": 8,
      "text": "c) Log out to close the connection (abort all the commands associated with the connection).",
      "zh-cn": "c) Log out to close the connection (abort all the commands associated with the connection)."
    },
    {
      "indent": 6,
      "text": "Note that an unsolicited PDU carries the next StatSN value on an iSCSI connection, thereby advancing the StatSN. When an initiator discards one of these PDUs due to a payload digest error, the entire PDU, including the header, MUST be discarded. Consequently, the initiator MUST treat the exception like a loss of any other solicited response PDU.",
      "zh-cn": "Note that an unsolicited PDU carries the next StatSN value on an iSCSI connection, thereby advancing the StatSN. When an initiator discards one of these PDUs due to a payload digest error, the entire PDU, including the header, MUST be discarded. Consequently, the initiator MUST treat the exception like a loss of any other solicited response PDU."
    },
    {
      "indent": 0,
      "text": "7.9. Sequence Errors",
      "section_title": true,
      "zh-cn": "7.9. Sequence Errors"
    },
    {
      "indent": 3,
      "text": "When an initiator receives an iSCSI R2T/data PDU with an out-of-order R2TSN/DataSN or a SCSI Response PDU with an ExpDataSN that implies missing data PDU(s), it means that the initiator must have detected a header or payload digest error on one or more earlier R2T/data PDUs.",
      "zh-cn": "When an initiator receives an iSCSI R2T/data PDU with an out-of-order R2TSN/DataSN or a SCSI Response PDU with an ExpDataSN that implies missing data PDU(s), it means that the initiator must have detected a header or payload digest error on one or more earlier R2T/data PDUs."
    },
    {
      "indent": 3,
      "text": "The initiator MUST address these implied digest errors as described in Section 7.8. When a target receives a data PDU with an out-of-order DataSN, it means that the target must have hit a header or payload digest error on at least one of the earlier data PDUs. The target MUST address these implied digest errors as described in Section 7.8.",
      "zh-cn": "The initiator MUST address these implied digest errors as described in Section 7.8. When a target receives a data PDU with an out-of-order DataSN, it means that the target must have hit a header or payload digest error on at least one of the earlier data PDUs. The target MUST address these implied digest errors as described in Section 7.8."
    },
    {
      "indent": 3,
      "text": "When an initiator receives an iSCSI status PDU with an out-of-order StatSN that implies missing responses, it MUST address the one or more missing status PDUs as described in Section 7.8. As a side effect of receiving the missing responses, the initiator may discover missing data PDUs. If the initiator wants to recover the missing data for a command, it MUST NOT acknowledge the received responses that start from the StatSN of the relevant command until it has completed receiving all the data PDUs of the command.",
      "zh-cn": "When an initiator receives an iSCSI status PDU with an out-of-order StatSN that implies missing responses, it MUST address the one or more missing status PDUs as described in Section 7.8. As a side effect of receiving the missing responses, the initiator may discover missing data PDUs. If the initiator wants to recover the missing data for a command, it MUST NOT acknowledge the received responses that start from the StatSN of the relevant command until it has completed receiving all the data PDUs of the command."
    },
    {
      "indent": 3,
      "text": "When an initiator receives duplicate R2TSNs (due to proactive retransmission of R2Ts by the target) or duplicate DataSNs (due to proactive SNACKs by the initiator), it MUST discard the duplicates.",
      "zh-cn": "When an initiator receives duplicate R2TSNs (due to proactive retransmission of R2Ts by the target) or duplicate DataSNs (due to proactive SNACKs by the initiator), it MUST discard the duplicates."
    },
    {
      "indent": 0,
      "text": "7.10. Message Error Checking",
      "section_title": true,
      "zh-cn": "7.10. Message Error Checking"
    },
    {
      "indent": 3,
      "text": "In iSCSI implementations to date, there has been some uncertainty regarding the extent to which incoming messages have to be checked for protocol errors, beyond what is strictly required for processing the inbound message. This section addresses this question.",
      "zh-cn": "In iSCSI implementations to date, there has been some uncertainty regarding the extent to which incoming messages have to be checked for protocol errors, beyond what is strictly required for processing the inbound message. This section addresses this question."
    },
    {
      "indent": 3,
      "text": "Unless this document requires it, an iSCSI implementation is not required to do an exhaustive protocol conformance check on an incoming iSCSI PDU. The iSCSI implementation in particular is not required to double-check the remote iSCSI implementation's conformance to protocol requirements.",
      "zh-cn": "Unless this document requires it, an iSCSI implementation is not required to do an exhaustive protocol conformance check on an incoming iSCSI PDU. The iSCSI implementation in particular is not required to double-check the remote iSCSI implementation's conformance to protocol requirements."
    },
    {
      "indent": 0,
      "text": "7.11. SCSI Timeouts",
      "section_title": true,
      "zh-cn": "7.11. SCSI Timeouts"
    },
    {
      "indent": 3,
      "text": "An iSCSI initiator MAY attempt to plug a command sequence gap on the target end (in the absence of an acknowledgment of the command by way of the ExpCmdSN) before the ULP timeout by retrying the unacknowledged command, as described in Section 7.2.",
      "zh-cn": "An iSCSI initiator MAY attempt to plug a command sequence gap on the target end (in the absence of an acknowledgment of the command by way of the ExpCmdSN) before the ULP timeout by retrying the unacknowledged command, as described in Section 7.2."
    },
    {
      "indent": 3,
      "text": "On a ULP timeout for a command (that carried a CmdSN of n), if the iSCSI initiator intends to continue the session it MUST abort the command by using either an appropriate Task Management Function Request for the specific command or a \"close the connection\" logout.",
      "zh-cn": "On a ULP timeout for a command (that carried a CmdSN of n), if the iSCSI initiator intends to continue the session it MUST abort the command by using either an appropriate Task Management Function Request for the specific command or a \"close the connection\" logout."
    },
    {
      "indent": 3,
      "text": "When using an ABORT TASK, if the ExpCmdSN is still less than (n + 1), the target may see the abort request while missing the original command itself, due to one of the following reasons:",
      "zh-cn": "When using an ABORT TASK, if the ExpCmdSN is still less than (n + 1), the target may see the abort request while missing the original command itself, due to one of the following reasons:"
    },
    {
      "indent": 6,
      "text": "- The original command was dropped due to digest error.",
      "zh-cn": "- The original command was dropped due to digest error."
    },
    {
      "indent": 6,
      "text": "- The connection on which the original command was sent was successfully logged out. On logout, the unacknowledged commands issued on the connection being logged out are discarded.",
      "zh-cn": "- The connection on which the original command was sent was successfully logged out. On logout, the unacknowledged commands issued on the connection being logged out are discarded."
    },
    {
      "indent": 3,
      "text": "If the abort request is received and the original command is missing, targets MUST consider the original command with that RefCmdSN as received and issue a task management response with the response code \"Function complete\". This response concludes the task on both ends. If the abort request is received and the target can determine (based on the Referenced Task Tag) that the command was received and executed, and also that the response was sent prior to the abort, then the target MUST respond with the response code \"Task Does Not Exist\".",
      "zh-cn": "If the abort request is received and the original command is missing, targets MUST consider the original command with that RefCmdSN as received and issue a task management response with the response code \"Function complete\". This response concludes the task on both ends. If the abort request is received and the target can determine (based on the Referenced Task Tag) that the command was received and executed, and also that the response was sent prior to the abort, then the target MUST respond with the response code \"Task Does Not Exist\"."
    },
    {
      "indent": 0,
      "text": "7.12. Negotiation Failures",
      "section_title": true,
      "zh-cn": "7.12. Negotiation Failures"
    },
    {
      "indent": 3,
      "text": "Text Request and Response sequences, when used to set/negotiate operational parameters, constitute the negotiation/parameter setting. A negotiation failure is considered to be one or more of the following:",
      "zh-cn": "Text Request and Response sequences, when used to set/negotiate operational parameters, constitute the negotiation/parameter setting. A negotiation failure is considered to be one or more of the following:"
    },
    {
      "indent": 6,
      "text": "- For a negotiated key, none of the choices are acceptable to one of the sides in the negotiation.",
      "zh-cn": "- For a negotiated key, none of the choices are acceptable to one of the sides in the negotiation."
    },
    {
      "indent": 6,
      "text": "- For a declarative key, the declared value is not acceptable to the other side in the negotiation.",
      "zh-cn": "- For a declarative key, the declared value is not acceptable to the other side in the negotiation."
    },
    {
      "indent": 6,
      "text": "- The Text Request timed out and possibly terminated.",
      "zh-cn": "- The Text Request timed out and possibly terminated."
    },
    {
      "indent": 6,
      "text": "- The Text Request was answered with a Reject PDU.",
      "zh-cn": "- The Text Request was answered with a Reject PDU."
    },
    {
      "indent": 3,
      "text": "The following two rules should be used to address negotiation failures:",
      "zh-cn": "The following two rules should be used to address negotiation failures:"
    },
    {
      "indent": 6,
      "text": "a) During login, any failure in negotiation MUST be considered a login process failure; the Login Phase, along with the connection, MUST be terminated. If the target detects the failure, it must terminate the login with the appropriate Login response code.",
      "zh-cn": "a) During login, any failure in negotiation MUST be considered a login process failure; the Login Phase, along with the connection, MUST be terminated. If the target detects the failure, it must terminate the login with the appropriate Login response code."
    },
    {
      "indent": 6,
      "text": "b) A failure in negotiation during the Full Feature Phase will terminate the entire negotiation sequence, which may consist of a series of Text Requests that use the same Initiator Task Tag. The operational parameters of the session or the connection MUST continue to be the values agreed upon during an earlier successful negotiation (i.e., any partial results of this unsuccessful negotiation MUST NOT take effect and MUST be discarded).",
      "zh-cn": "b) A failure in negotiation during the Full Feature Phase will terminate the entire negotiation sequence, which may consist of a series of Text Requests that use the same Initiator Task Tag. The operational parameters of the session or the connection MUST continue to be the values agreed upon during an earlier successful negotiation (i.e., any partial results of this unsuccessful negotiation MUST NOT take effect and MUST be discarded)."
    },
    {
      "indent": 0,
      "text": "7.13. Protocol Errors",
      "section_title": true,
      "zh-cn": "7.13. Protocol Errors"
    },
    {
      "indent": 3,
      "text": "Mapping framed messages over a \"streaming\" connection such as TCP makes the proposed mechanisms vulnerable to simple software framing errors. On the other hand, the introduction of framing mechanisms to limit the effects of these errors may be onerous on performance for simple implementations. Command sequence numbers and the mechanisms for dropping and reestablishing connections (discussed earlier in Section 7 and its subsections) help handle this type of mapping errors.",
      "zh-cn": "Mapping framed messages over a \"streaming\" connection such as TCP makes the proposed mechanisms vulnerable to simple software framing errors. On the other hand, the introduction of framing mechanisms to limit the effects of these errors may be onerous on performance for simple implementations. Command sequence numbers and the mechanisms for dropping and reestablishing connections (discussed earlier in Section 7 and its subsections) help handle this type of mapping errors."
    },
    {
      "indent": 3,
      "text": "All violations of iSCSI PDU exchange sequences specified in this document are also protocol errors. This category of errors can only be addressed by fixing the implementations; iSCSI defines Reject and response codes to enable this.",
      "zh-cn": "All violations of iSCSI PDU exchange sequences specified in this document are also protocol errors. This category of errors can only be addressed by fixing the implementations; iSCSI defines Reject and response codes to enable this."
    },
    {
      "indent": 0,
      "text": "7.14. Connection Failures",
      "section_title": true,
      "zh-cn": "7.14. Connection Failures"
    },
    {
      "indent": 3,
      "text": "iSCSI can keep a session in operation if it is able to keep/establish at least one TCP connection between the initiator and the target in a timely fashion. Targets and/or initiators may recognize a failing connection by either transport-level means (TCP), a gap in the command sequence number, a response stream that is not filled for a long time, or a failing iSCSI NOP (acting as a ping). The latter MAY be used periodically to increase the speed and likelihood of detecting connection failures. As an example for transport-level means, initiators and targets MAY also use the keep-alive option (see [RFC1122]) on the TCP connection to enable early link failure detection on otherwise idle links.",
      "zh-cn": "iSCSI can keep a session in operation if it is able to keep/establish at least one TCP connection between the initiator and the target in a timely fashion. Targets and/or initiators may recognize a failing connection by either transport-level means (TCP), a gap in the command sequence number, a response stream that is not filled for a long time, or a failing iSCSI NOP (acting as a ping). The latter MAY be used periodically to increase the speed and likelihood of detecting connection failures. As an example for transport-level means, initiators and targets MAY also use the keep-alive option (see [RFC1122]) on the TCP connection to enable early link failure detection on otherwise idle links."
    },
    {
      "indent": 3,
      "text": "On connection failure, the initiator and target MUST do one of the following:",
      "zh-cn": "On connection failure, the initiator and target MUST do one of the following:"
    },
    {
      "indent": 6,
      "text": "a) Attempt connection recovery within the session (Connection Recovery).",
      "zh-cn": "a) Attempt connection recovery within the session (Connection Recovery)."
    },
    {
      "indent": 6,
      "text": "b) Log out the connection with the reason code \"close the connection\" (Section 11.14.5), reissue missing commands, and implicitly terminate all active commands. This option requires support for the Within-connection recovery class (recovery within-connection).",
      "zh-cn": "b) Log out the connection with the reason code \"close the connection\" (Section 11.14.5), reissue missing commands, and implicitly terminate all active commands. This option requires support for the Within-connection recovery class (recovery within-connection)."
    },
    {
      "indent": 6,
      "text": "c) Perform session recovery (Session Recovery).",
      "zh-cn": "c) Perform session recovery (Session Recovery)."
    },
    {
      "indent": 3,
      "text": "Either side may choose to escalate to session recovery (via the initiator dropping all the connections or via an Async Message that announces the similar intent from a target), and the other side MUST give it precedence. On a connection failure, a target MUST terminate and/or discard all of the active immediate commands, regardless of which of the above options is used (i.e., immediate commands are not recoverable across connection failures).",
      "zh-cn": "Either side may choose to escalate to session recovery (via the initiator dropping all the connections or via an Async Message that announces the similar intent from a target), and the other side MUST give it precedence. On a connection failure, a target MUST terminate and/or discard all of the active immediate commands, regardless of which of the above options is used (i.e., immediate commands are not recoverable across connection failures)."
    },
    {
      "indent": 0,
      "text": "7.15. Session Errors",
      "section_title": true,
      "zh-cn": "7.15. Session Errors"
    },
    {
      "indent": 3,
      "text": "If all of the connections of a session fail and cannot be reestablished in a short time, or if initiators detect protocol errors repeatedly, an initiator may choose to terminate a session and establish a new session.",
      "zh-cn": "If all of the connections of a session fail and cannot be reestablished in a short time, or if initiators detect protocol errors repeatedly, an initiator may choose to terminate a session and establish a new session."
    },
    {
      "indent": 3,
      "text": "In this case, the initiator takes the following actions:",
      "zh-cn": "In this case, the initiator takes the following actions:"
    },
    {
      "indent": 6,
      "text": "- Resets or closes all the transport connections.",
      "zh-cn": "- Resets or closes all the transport connections."
    },
    {
      "indent": 6,
      "text": "- Terminates all outstanding requests with an appropriate response before initiating a new session. If the same I_T nexus is intended to be reestablished, the initiator MUST employ session reinstatement (see Section 6.3.5).",
      "zh-cn": "- Terminates all outstanding requests with an appropriate response before initiating a new session. If the same I_T nexus is intended to be reestablished, the initiator MUST employ session reinstatement (see Section 6.3.5)."
    },
    {
      "indent": 3,
      "text": "When the session timeout (the connection state timeout for the last failed connection) happens on the target, it takes the following actions:",
      "zh-cn": "When the session timeout (the connection state timeout for the last failed connection) happens on the target, it takes the following actions:"
    },
    {
      "indent": 6,
      "text": "- Resets or closes the TCP connections (closes the session).",
      "zh-cn": "- Resets or closes the TCP connections (closes the session)."
    },
    {
      "indent": 6,
      "text": "- Terminates all active tasks that were allegiant to the connection(s) that constituted the session.",
      "zh-cn": "- Terminates all active tasks that were allegiant to the connection(s) that constituted the session."
    },
    {
      "indent": 3,
      "text": "A target MUST also be prepared to handle a session reinstatement request from the initiator that may be addressing session errors.",
      "zh-cn": "A target MUST also be prepared to handle a session reinstatement request from the initiator that may be addressing session errors."
    },
    {
      "indent": 0,
      "text": "8. State Transitions",
      "section_title": true,
      "zh-cn": "8. State Transitions"
    },
    {
      "indent": 3,
      "text": "iSCSI connections and iSCSI sessions go through several well-defined states from the time they are created to the time they are cleared.",
      "zh-cn": "iSCSI connections and iSCSI sessions go through several well-defined states from the time they are created to the time they are cleared."
    },
    {
      "indent": 3,
      "text": "The connection state transitions are described in two separate but dependent sets of state diagrams for ease in understanding. The first set of diagrams, \"standard connection state diagrams\", describes the connection state transitions when the iSCSI connection is not waiting for, or undergoing, a cleanup by way of an explicit or implicit logout. The second set, \"connection cleanup state diagram\", describes the connection state transitions while performing the iSCSI connection cleanup. While the first set has two diagrams -- one each for initiator and target -- the second set has a single diagram applicable to both initiators and targets.",
      "zh-cn": "The connection state transitions are described in two separate but dependent sets of state diagrams for ease in understanding. The first set of diagrams, \"standard connection state diagrams\", describes the connection state transitions when the iSCSI connection is not waiting for, or undergoing, a cleanup by way of an explicit or implicit logout. The second set, \"connection cleanup state diagram\", describes the connection state transitions while performing the iSCSI connection cleanup. While the first set has two diagrams -- one each for initiator and target -- the second set has a single diagram applicable to both initiators and targets."
    },
    {
      "indent": 3,
      "text": "The \"session state diagram\" describes the state transitions an iSCSI session would go through during its lifetime, and it depends on the states of possibly multiple iSCSI connections that participate in the session.",
      "zh-cn": "The \"session state diagram\" describes the state transitions an iSCSI session would go through during its lifetime, and it depends on the states of possibly multiple iSCSI connections that participate in the session."
    },
    {
      "indent": 3,
      "text": "States and transitions are described in text, tables, and diagrams. The diagrams are used for illustration. The text and the tables are the governing specification.",
      "zh-cn": "States and transitions are described in text, tables, and diagrams. The diagrams are used for illustration. The text and the tables are the governing specification."
    },
    {
      "indent": 0,
      "text": "8.1. Standard Connection State Diagrams",
      "section_title": true,
      "zh-cn": "8.1. Standard Connection State Diagrams"
    },
    {
      "indent": 0,
      "text": "8.1.1. State Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.1.1. State Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "State descriptions for the standard connection state diagram are as follows:",
      "zh-cn": "State descriptions for the standard connection state diagram are as follows:"
    },
    {
      "indent": 3,
      "text": "S1: FREE",
      "zh-cn": "S1: FREE"
    },
    {
      "indent": 7,
      "text": "- initiator: State on instantiation, or after successful connection closure.",
      "zh-cn": "- initiator: State on instantiation, or after successful connection closure."
    },
    {
      "indent": 7,
      "text": "- target: State on instantiation, or after successful connection closure.",
      "zh-cn": "- target: State on instantiation, or after successful connection closure."
    },
    {
      "indent": 3,
      "text": "S2: XPT_WAIT",
      "zh-cn": "S2: XPT_WAIT"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for a response to its transport connection establishment request.",
      "zh-cn": "- initiator: Waiting for a response to its transport connection establishment request."
    },
    {
      "indent": 7,
      "text": "- target: Illegal.",
      "zh-cn": "- target: Illegal."
    },
    {
      "indent": 3,
      "text": "S3: XPT_UP",
      "zh-cn": "S3: XPT_UP"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the login process to commence.",
      "zh-cn": "- target: Waiting for the login process to commence."
    },
    {
      "indent": 3,
      "text": "S4: IN_LOGIN",
      "zh-cn": "S4: IN_LOGIN"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for the login process to conclude, possibly involving several PDU exchanges.",
      "zh-cn": "- initiator: Waiting for the login process to conclude, possibly involving several PDU exchanges."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the login process to conclude, possibly involving several PDU exchanges.",
      "zh-cn": "- target: Waiting for the login process to conclude, possibly involving several PDU exchanges."
    },
    {
      "indent": 3,
      "text": "S5: LOGGED_IN",
      "zh-cn": "S5: LOGGED_IN"
    },
    {
      "indent": 7,
      "text": "- initiator: In the Full Feature Phase, waiting for all internal, iSCSI, and transport events.",
      "zh-cn": "- initiator: In the Full Feature Phase, waiting for all internal, iSCSI, and transport events."
    },
    {
      "indent": 7,
      "text": "- target: In the Full Feature Phase, waiting for all internal, iSCSI, and transport events.",
      "zh-cn": "- target: In the Full Feature Phase, waiting for all internal, iSCSI, and transport events."
    },
    {
      "indent": 3,
      "text": "S6: IN_LOGOUT",
      "zh-cn": "S6: IN_LOGOUT"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for a Logout Response.",
      "zh-cn": "- initiator: Waiting for a Logout Response."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for an internal event signaling completion of logout processing.",
      "zh-cn": "- target: Waiting for an internal event signaling completion of logout processing."
    },
    {
      "indent": 3,
      "text": "S7: LOGOUT_REQUESTED",
      "zh-cn": "S7: LOGOUT_REQUESTED"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for an internal event signaling readiness to proceed with Logout.",
      "zh-cn": "- initiator: Waiting for an internal event signaling readiness to proceed with Logout."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the Logout process to start after having requested a Logout via an Async Message.",
      "zh-cn": "- target: Waiting for the Logout process to start after having requested a Logout via an Async Message."
    },
    {
      "indent": 3,
      "text": "S8: CLEANUP_WAIT",
      "zh-cn": "S8: CLEANUP_WAIT"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for the context and/or resources to initiate the cleanup processing for this CSM.",
      "zh-cn": "- initiator: Waiting for the context and/or resources to initiate the cleanup processing for this CSM."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the cleanup process to start for this CSM.",
      "zh-cn": "- target: Waiting for the cleanup process to start for this CSM."
    },
    {
      "indent": 0,
      "text": "8.1.2. State Transition Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.1.2. State Transition Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "T1:",
      "zh-cn": "T1:"
    },
    {
      "indent": 7,
      "text": "- initiator: Transport connect request was made (e.g., TCP SYN sent).",
      "zh-cn": "- initiator: Transport connect request was made (e.g., TCP SYN sent)."
    },
    {
      "indent": 7,
      "text": "- target: Illegal.",
      "zh-cn": "- target: Illegal."
    },
    {
      "indent": 3,
      "text": "T2:",
      "zh-cn": "T2:"
    },
    {
      "indent": 7,
      "text": "- initiator: Transport connection request timed out, a transport reset was received, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "- initiator: Transport connection request timed out, a transport reset was received, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "- target: Illegal.",
      "zh-cn": "- target: Illegal."
    },
    {
      "indent": 3,
      "text": "T3:",
      "zh-cn": "T3:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: Received a valid transport connection request that establishes the transport connection.",
      "zh-cn": "- target: Received a valid transport connection request that establishes the transport connection."
    },
    {
      "indent": 3,
      "text": "T4:",
      "zh-cn": "T4:"
    },
    {
      "indent": 7,
      "text": "- initiator: Transport connection established, thus prompting the initiator to start the iSCSI Login.",
      "zh-cn": "- initiator: Transport connection established, thus prompting the initiator to start the iSCSI Login."
    },
    {
      "indent": 7,
      "text": "- target: Initial iSCSI Login Request was received.",
      "zh-cn": "- target: Initial iSCSI Login Request was received."
    },
    {
      "indent": 3,
      "text": "T5:",
      "zh-cn": "T5:"
    },
    {
      "indent": 7,
      "text": "- initiator: The final iSCSI Login Response with a Status-Class of zero was received.",
      "zh-cn": "- initiator: The final iSCSI Login Response with a Status-Class of zero was received."
    },
    {
      "indent": 7,
      "text": "- target: The final iSCSI Login Request to conclude the Login Phase was received, thus prompting the target to send the final iSCSI Login Response with a Status-Class of zero.",
      "zh-cn": "- target: The final iSCSI Login Request to conclude the Login Phase was received, thus prompting the target to send the final iSCSI Login Response with a Status-Class of zero."
    },
    {
      "indent": 3,
      "text": "T6:",
      "zh-cn": "T6:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: Timed out waiting for an iSCSI Login, transport disconnect indication was received, transport reset was received, or an internal event indicating a transport timeout was received. In all these cases, the connection is to be closed.",
      "zh-cn": "- target: Timed out waiting for an iSCSI Login, transport disconnect indication was received, transport reset was received, or an internal event indicating a transport timeout was received. In all these cases, the connection is to be closed."
    },
    {
      "indent": 3,
      "text": "T7:",
      "zh-cn": "T7:"
    },
    {
      "indent": 7,
      "text": "- initiator: One of the following events caused the transition:",
      "zh-cn": "- initiator: One of the following events caused the transition:"
    },
    {
      "indent": 9,
      "text": "a) The final iSCSI Login Response was received with a non-zero Status-Class.",
      "zh-cn": "a) The final iSCSI Login Response was received with a non-zero Status-Class."
    },
    {
      "indent": 9,
      "text": "b) Login timed out.",
      "zh-cn": "b) Login timed out."
    },
    {
      "indent": 9,
      "text": "c) A transport disconnect indication was received.",
      "zh-cn": "c) A transport disconnect indication was received."
    },
    {
      "indent": 9,
      "text": "d) A transport reset was received.",
      "zh-cn": "d) A transport reset was received."
    },
    {
      "indent": 9,
      "text": "e) An internal event indicating a transport timeout was received.",
      "zh-cn": "e) An internal event indicating a transport timeout was received."
    },
    {
      "indent": 9,
      "text": "f) An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "f) An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "In all these cases, the transport connection is closed.",
      "zh-cn": "In all these cases, the transport connection is closed."
    },
    {
      "indent": 7,
      "text": "- target: One of the following events caused the transition:",
      "zh-cn": "- target: One of the following events caused the transition:"
    },
    {
      "indent": 9,
      "text": "a) The final iSCSI Login Request to conclude the Login Phase was received, prompting the target to send the final iSCSI Login Response with a non-zero Status-Class.",
      "zh-cn": "a) The final iSCSI Login Request to conclude the Login Phase was received, prompting the target to send the final iSCSI Login Response with a non-zero Status-Class."
    },
    {
      "indent": 9,
      "text": "b) Login timed out.",
      "zh-cn": "b) Login timed out."
    },
    {
      "indent": 9,
      "text": "c) A transport disconnect indication was received.",
      "zh-cn": "c) A transport disconnect indication was received."
    },
    {
      "indent": 9,
      "text": "d) A transport reset was received.",
      "zh-cn": "d) A transport reset was received."
    },
    {
      "indent": 9,
      "text": "e) An internal event indicating a transport timeout was received.",
      "zh-cn": "e) An internal event indicating a transport timeout was received."
    },
    {
      "indent": 9,
      "text": "f) On another connection, a \"close the session\" Logout Request was received.",
      "zh-cn": "f) On another connection, a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "In all these cases, the connection is to be closed.",
      "zh-cn": "In all these cases, the connection is to be closed."
    },
    {
      "indent": 3,
      "text": "T8:",
      "zh-cn": "T8:"
    },
    {
      "indent": 7,
      "text": "- initiator: An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, thus closing this connection and requiring no further cleanup.",
      "zh-cn": "- initiator: An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, thus closing this connection and requiring no further cleanup."
    },
    {
      "indent": 7,
      "text": "- target: An internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, or an internal event of a successful connection/session reinstatement was received, thus prompting the target to close this connection cleanly.",
      "zh-cn": "- target: An internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, or an internal event of a successful connection/session reinstatement was received, thus prompting the target to close this connection cleanly."
    },
    {
      "indent": 3,
      "text": "T9, T10:",
      "zh-cn": "T9, T10:"
    },
    {
      "indent": 7,
      "text": "- initiator: An internal event that indicates the readiness to start the Logout process was received, thus prompting an iSCSI Logout to be sent by the initiator.",
      "zh-cn": "- initiator: An internal event that indicates the readiness to start the Logout process was received, thus prompting an iSCSI Logout to be sent by the initiator."
    },
    {
      "indent": 7,
      "text": "- target: An iSCSI Logout Request was received.",
      "zh-cn": "- target: An iSCSI Logout Request was received."
    },
    {
      "indent": 3,
      "text": "T11, T12:",
      "zh-cn": "T11, T12:"
    },
    {
      "indent": 7,
      "text": "- initiator: An Async PDU with AsyncEvent \"Request Logout\" was received.",
      "zh-cn": "- initiator: An Async PDU with AsyncEvent \"Request Logout\" was received."
    },
    {
      "indent": 7,
      "text": "- target: An internal event that requires the decommissioning of the connection was received, thus causing an Async PDU with an AsyncEvent \"Request Logout\" to be sent.",
      "zh-cn": "- target: An internal event that requires the decommissioning of the connection was received, thus causing an Async PDU with an AsyncEvent \"Request Logout\" to be sent."
    },
    {
      "indent": 3,
      "text": "T13:",
      "zh-cn": "T13:"
    },
    {
      "indent": 7,
      "text": "- initiator: An iSCSI Logout Response (success) was received, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "- initiator: An iSCSI Logout Response (success) was received, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "- target: An internal event was received that indicates successful processing of the Logout, which prompts an iSCSI Logout Response (success) to be sent; an internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received; or",
      "zh-cn": "- target: An internal event was received that indicates successful processing of the Logout, which prompts an iSCSI Logout Response (success) to be sent; an internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received; or"
    },
    {
      "indent": 9,
      "text": "an internal event of a successful connection/session reinstatement was received. In all these cases, the transport connection is closed.",
      "zh-cn": "an internal event of a successful connection/session reinstatement was received. In all these cases, the transport connection is closed."
    },
    {
      "indent": 3,
      "text": "T14:",
      "zh-cn": "T14:"
    },
    {
      "indent": 7,
      "text": "- initiator: An Async PDU with AsyncEvent \"Request Logout\" was received again.",
      "zh-cn": "- initiator: An Async PDU with AsyncEvent \"Request Logout\" was received again."
    },
    {
      "indent": 7,
      "text": "- target: Illegal.",
      "zh-cn": "- target: Illegal."
    },
    {
      "indent": 3,
      "text": "T15, T16:",
      "zh-cn": "T15, T16:"
    },
    {
      "indent": 7,
      "text": "- initiator: One or more of the following events caused this transition:",
      "zh-cn": "- initiator: One or more of the following events caused this transition:"
    },
    {
      "indent": 9,
      "text": "a) An internal event that indicates a transport connection timeout was received, thus prompting a transport reset or transport connection closure.",
      "zh-cn": "a) An internal event that indicates a transport connection timeout was received, thus prompting a transport reset or transport connection closure."
    },
    {
      "indent": 9,
      "text": "b) A transport reset was received.",
      "zh-cn": "b) A transport reset was received."
    },
    {
      "indent": 9,
      "text": "c) A transport disconnect indication was received.",
      "zh-cn": "c) A transport disconnect indication was received."
    },
    {
      "indent": 9,
      "text": "d) An Async PDU with AsyncEvent \"Drop connection\" (for this CID) was received.",
      "zh-cn": "d) An Async PDU with AsyncEvent \"Drop connection\" (for this CID) was received."
    },
    {
      "indent": 9,
      "text": "e) An Async PDU with AsyncEvent \"Drop all connections\" was received.",
      "zh-cn": "e) An Async PDU with AsyncEvent \"Drop all connections\" was received."
    },
    {
      "indent": 7,
      "text": "- target: One or more of the following events caused this transition:",
      "zh-cn": "- target: One or more of the following events caused this transition:"
    },
    {
      "indent": 9,
      "text": "a) Internal event that indicates that a transport connection timeout was received, thus prompting a transport reset or transport connection closure.",
      "zh-cn": "a) Internal event that indicates that a transport connection timeout was received, thus prompting a transport reset or transport connection closure."
    },
    {
      "indent": 9,
      "text": "b) An internal event of a failed connection/session reinstatement was received.",
      "zh-cn": "b) An internal event of a failed connection/session reinstatement was received."
    },
    {
      "indent": 9,
      "text": "c) A transport reset was received.",
      "zh-cn": "c) A transport reset was received."
    },
    {
      "indent": 9,
      "text": "d) A transport disconnect indication was received.",
      "zh-cn": "d) A transport disconnect indication was received."
    },
    {
      "indent": 9,
      "text": "e) An internal emergency cleanup event was received, which prompts an Async PDU with AsyncEvent \"Drop connection\" (for this CID), or event \"Drop all connections\".",
      "zh-cn": "e) An internal emergency cleanup event was received, which prompts an Async PDU with AsyncEvent \"Drop connection\" (for this CID), or event \"Drop all connections\"."
    },
    {
      "indent": 3,
      "text": "T17:",
      "zh-cn": "T17:"
    },
    {
      "indent": 7,
      "text": "- initiator: One or more of the following events caused this transition:",
      "zh-cn": "- initiator: One or more of the following events caused this transition:"
    },
    {
      "indent": 9,
      "text": "a) A Logout Response (failure, i.e., a non-zero status) was received, or Logout timed out.",
      "zh-cn": "a) A Logout Response (failure, i.e., a non-zero status) was received, or Logout timed out."
    },
    {
      "indent": 9,
      "text": "b) Any of the events specified for T15 and T16 occurred.",
      "zh-cn": "b) Any of the events specified for T15 and T16 occurred."
    },
    {
      "indent": 7,
      "text": "- target: One or more of the following events caused this transition:",
      "zh-cn": "- target: One or more of the following events caused this transition:"
    },
    {
      "indent": 9,
      "text": "a) An internal event that indicates a failure of the Logout processing was received, which prompts a Logout Response (failure, i.e., a non-zero status) to be sent.",
      "zh-cn": "a) An internal event that indicates a failure of the Logout processing was received, which prompts a Logout Response (failure, i.e., a non-zero status) to be sent."
    },
    {
      "indent": 9,
      "text": "b) Any of the events specified for T15 and T16 occurred.",
      "zh-cn": "b) Any of the events specified for T15 and T16 occurred."
    },
    {
      "indent": 3,
      "text": "T18:",
      "zh-cn": "T18:"
    },
    {
      "indent": 7,
      "text": "- initiator: An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "- initiator: An internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "- target: An internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, or an internal event of a successful connection/session reinstatement was received. In both these cases, the connection is closed.",
      "zh-cn": "- target: An internal event of sending a Logout Response (success) on another connection for a \"close the session\" Logout Request was received, or an internal event of a successful connection/session reinstatement was received. In both these cases, the connection is closed."
    },
    {
      "indent": 3,
      "text": "The CLEANUP_WAIT state (S8) implies that there are possible iSCSI tasks that have not reached conclusion and are still considered busy.",
      "zh-cn": "The CLEANUP_WAIT state (S8) implies that there are possible iSCSI tasks that have not reached conclusion and are still considered busy."
    },
    {
      "indent": 0,
      "text": "8.1.3. Standard Connection State Diagram for an Initiator",
      "section_title": true,
      "zh-cn": "8.1.3. Standard Connection State Diagram for an Initiator"
    },
    {
      "indent": 3,
      "text": "Symbolic names for states:",
      "zh-cn": "Symbolic names for states:"
    },
    {
      "indent": 6,
      "text": "S1: FREE",
      "zh-cn": "S1: FREE"
    },
    {
      "indent": 6,
      "text": "S2: XPT_WAIT",
      "zh-cn": "S2: XPT_WAIT"
    },
    {
      "indent": 6,
      "text": "S4: IN_LOGIN",
      "zh-cn": "S4: IN_LOGIN"
    },
    {
      "indent": 6,
      "text": "S5: LOGGED_IN",
      "zh-cn": "S5: LOGGED_IN"
    },
    {
      "indent": 6,
      "text": "S6: IN_LOGOUT",
      "zh-cn": "S6: IN_LOGOUT"
    },
    {
      "indent": 6,
      "text": "S7: LOGOUT_REQUESTED",
      "zh-cn": "S7: LOGOUT_REQUESTED"
    },
    {
      "indent": 6,
      "text": "S8: CLEANUP_WAIT",
      "zh-cn": "S8: CLEANUP_WAIT"
    },
    {
      "indent": 3,
      "text": "States S5, S6, and S7 constitute the Full Feature Phase operation of the connection.",
      "zh-cn": "States S5, S6, and S7 constitute the Full Feature Phase operation of the connection."
    },
    {
      "indent": 3,
      "text": "The state diagram is as follows:",
      "zh-cn": "The state diagram is as follows:"
    },
    {
      "indent": 9,
      "text": "               -------<-------------+\n   +--------->/ S1    \\<----+       |\nT13|       +->\\       /<-+   \\      |\n   |      /    ---+---    \\   \\     |\n   |     /        |     T2 \\   |    |\n   |  T8 |        |T1       |  |    |\n   |     |        |        /   |T7  |\n   |     |        |       /    |    |\n   |     |        |      /     |    |\n   |     |        V     /     /     |\n   |     |     ------- /     /      |\n   |     |    / S2    \\     /       |\n   |     |    \\       /    /        |\n   |     |     ---+---    /         |\n   |     |        |T4    /          |\n   |     |        V     /           | T18\n   |     |     ------- /            |\n   |     |    / S4    \\             |\n   |     |    \\       /             |\n   |     |     ---+---              |         T15\n   |     |        |T5      +--------+---------+\n   |     |        |       /T16+-----+------+  |\n   |     |        |      /   -+-----+--+   |  |\n   |     |        |     /   /  S7   \\  |T12|  |\n   |     |        |    / +->\\       /<-+   V  V\n   |     |        |   / /    -+-----       -------\n   |     |        |  / /T11   |T10        /  S8   \\\n   |     |        V / /       V  +----+   \\       /\n   |     |      ---+-+-      ----+--  |    -------\n   |     |     / S5    \\T9  / S6    \\<+      ^\n   |     +-----\\       /--->\\       / T14    |\n   |            -------      --+---+---------+T17\n   +---------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The following state transition table represents the above diagram. Each row represents the starting state for a given transition, which, after taking a transition marked in a table cell, would end in the state represented by the column of the cell. For example, from state S1, the connection takes the T1 transition to arrive at state S2. The fields marked \"-\" correspond to undefined transitions.",
      "zh-cn": "The following state transition table represents the above diagram. Each row represents the starting state for a given transition, which, after taking a transition marked in a table cell, would end in the state represented by the column of the cell. For example, from state S1, the connection takes the T1 transition to arrive at state S2. The fields marked \"-\" correspond to undefined transitions."
    },
    {
      "indent": 3,
      "text": "   +----+---+---+---+---+----+---+\n   |S1  |S2 |S4 |S5 |S6 |S7  |S8 |\n---+----+---+---+---+---+----+---+\n S1| -  |T1 | - | - | - | -  | - |\n---+----+---+---+---+---+----+---+\n S2|T2  |-  |T4 | - | - | -  | - |\n---+----+---+---+---+---+----+---+\n S4|T7  |-  |-  |T5 | - | -  | - |\n---+----+---+---+---+---+----+---+\n S5|T8  |-  |-  | - |T9 |T11 |T15|\n---+----+---+---+---+---+----+---+\n S6|T13 |-  |-  | - |T14|-   |T17|\n---+----+---+---+---+---+----+---+\n S7|T18 |-  |-  | - |T10|T12 |T16|\n---+----+---+---+---+---+----+---+\n S8| -  |-  |-  | - | - | -  | - |\n---+----+---+---+---+---+----+---+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "8.1.4. Standard Connection State Diagram for a Target",
      "section_title": true,
      "zh-cn": "8.1.4. Standard Connection State Diagram for a Target"
    },
    {
      "indent": 3,
      "text": "Symbolic names for states:",
      "zh-cn": "Symbolic names for states:"
    },
    {
      "indent": 6,
      "text": "S1: FREE",
      "zh-cn": "S1: FREE"
    },
    {
      "indent": 6,
      "text": "S3: XPT_UP",
      "zh-cn": "S3: XPT_UP"
    },
    {
      "indent": 6,
      "text": "S4: IN_LOGIN",
      "zh-cn": "S4: IN_LOGIN"
    },
    {
      "indent": 6,
      "text": "S5: LOGGED_IN",
      "zh-cn": "S5: LOGGED_IN"
    },
    {
      "indent": 6,
      "text": "S6: IN_LOGOUT",
      "zh-cn": "S6: IN_LOGOUT"
    },
    {
      "indent": 6,
      "text": "S7: LOGOUT_REQUESTED",
      "zh-cn": "S7: LOGOUT_REQUESTED"
    },
    {
      "indent": 6,
      "text": "S8: CLEANUP_WAIT",
      "zh-cn": "S8: CLEANUP_WAIT"
    },
    {
      "indent": 3,
      "text": "States S5, S6, and S7 constitute the Full Feature Phase operation of the connection.",
      "zh-cn": "States S5, S6, and S7 constitute the Full Feature Phase operation of the connection."
    },
    {
      "indent": 3,
      "text": "The state diagram is as follows:",
      "zh-cn": "The state diagram is as follows:"
    },
    {
      "indent": 12,
      "text": "               -------<-------------+\n   +--------->/ S1    \\<----+       |\nT13|       +->\\       /<-+   \\      |\n   |      /    ---+---    \\   \\     |\n   |     /        |     T6 \\   |    |\n   |  T8 |        |T3       |  |    |\n   |     |        |        /   |T7  |\n   |     |        |       /    |    |\n   |     |        |      /     |    |\n   |     |        V     /     /     |\n   |     |     ------- /     /      |\n   |     |    / S3    \\     /       |\n   |     |    \\       /    /        | T18\n   |     |     ---+---    /         |\n   |     |        |T4    /          |\n   |     |        V     /           |\n   |     |     ------- /            |\n   |     |    / S4    \\             |\n   |     |    \\       /             |\n   |     |     ---+---         T15  |\n   |     |        |T5      +--------+---------+\n   |     |        |       /T16+-----+------+  |\n   |     |        |      /  -+-----+---+   |  |\n   |     |        |     /   /  S7   \\  |T12|  |\n   |     |        |    / +->\\       /<-+   V  V\n   |     |        |   / /    -+-----       -------\n   |     |        |  / /T11   |T10        /  S8   \\\n   |     |        V / /       V           \\       /\n   |     |      ---+-+-      -------       -------\n   |     |     / S5    \\T9  / S6    \\        ^\n   |     +-----\\       /--->\\       /        |\n   |            -------      --+---+---------+T17\n   +---------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The following state transition table represents the above diagram and follows the conventions described for the initiator diagram.",
      "zh-cn": "The following state transition table represents the above diagram and follows the conventions described for the initiator diagram."
    },
    {
      "indent": 3,
      "text": "   +----+---+---+---+---+----+---+\n   |S1  |S3 |S4 |S5 |S6 |S7  |S8 |\n---+----+---+---+---+---+----+---+\n S1| -  |T3 | - | - | - | -  | - |\n---+----+---+---+---+---+----+---+\n S3|T6  |-  |T4 | - | - | -  | - |\n---+----+---+---+---+---+----+---+\n S4|T7  |-  |-  |T5 | - | -  | - |\n---+----+---+---+---+---+----+---+\n S5|T8  |-  |-  | - |T9 |T11 |T15|\n---+----+---+---+---+---+----+---+\n S6|T13 |-  |-  | - |-  |-   |T17|\n---+----+---+---+---+---+----+---+\n S7|T18 |-  |-  | - |T10|T12 |T16|\n---+----+---+---+---+---+----+---+\n S8| -  |-  |-  | - | - | -  | - |\n---+----+---+---+---+---+----+---+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "8.2. Connection Cleanup State Diagram for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.2. Connection Cleanup State Diagram for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "Symbolic names for states:",
      "zh-cn": "Symbolic names for states:"
    },
    {
      "indent": 6,
      "text": "R1: CLEANUP_WAIT (same as S8)",
      "zh-cn": "R1: CLEANUP_WAIT (same as S8)"
    },
    {
      "indent": 6,
      "text": "R2: IN_CLEANUP",
      "zh-cn": "R2: IN_CLEANUP"
    },
    {
      "indent": 6,
      "text": "R3: FREE (same as S1)",
      "zh-cn": "R3: FREE (same as S1)"
    },
    {
      "indent": 3,
      "text": "Whenever a connection state machine in cleanup (let's call it CSM-C) enters the CLEANUP_WAIT state (S8), it must go through the state transitions described in the connection cleanup state diagram, using either a) a separate Full Feature Phase connection (let's call it CSM-E, for explicit) in the LOGGED_IN state in the same session or b) a new transport connection (let's call it CSM-I, for implicit) in the FREE state that is to be added to the same session. In the CSM-E case, an explicit logout for the CID that corresponds to CSM-C (as either a connection or session logout) needs to be performed to complete the cleanup. In the CSM-I case, an implicit logout for the CID that corresponds to CSM-C needs to be performed by way of connection reinstatement (Section 6.3.4) for that CID. In either case, the protocol exchanges on CSM-E or CSM-I determine the state transitions for CSM-C. Therefore, this cleanup state diagram is only applicable to the instance of the connection in cleanup (i.e., CSM-C). In the case of an implicit logout, for example, CSM-C",
      "zh-cn": "Whenever a connection state machine in cleanup (let's call it CSM-C) enters the CLEANUP_WAIT state (S8), it must go through the state transitions described in the connection cleanup state diagram, using either a) a separate Full Feature Phase connection (let's call it CSM-E, for explicit) in the LOGGED_IN state in the same session or b) a new transport connection (let's call it CSM-I, for implicit) in the FREE state that is to be added to the same session. In the CSM-E case, an explicit logout for the CID that corresponds to CSM-C (as either a connection or session logout) needs to be performed to complete the cleanup. In the CSM-I case, an implicit logout for the CID that corresponds to CSM-C needs to be performed by way of connection reinstatement (Section 6.3.4) for that CID. In either case, the protocol exchanges on CSM-E or CSM-I determine the state transitions for CSM-C. Therefore, this cleanup state diagram is only applicable to the instance of the connection in cleanup (i.e., CSM-C). In the case of an implicit logout, for example, CSM-C"
    },
    {
      "indent": 3,
      "text": "reaches FREE (R3) at the time CSM-I reaches LOGGED_IN. In the case of an explicit logout, CSM-C reaches FREE (R3) when CSM-E receives a successful Logout Response while continuing to be in the LOGGED_IN state.",
      "zh-cn": "reaches FREE (R3) at the time CSM-I reaches LOGGED_IN. In the case of an explicit logout, CSM-C reaches FREE (R3) when CSM-E receives a successful Logout Response while continuing to be in the LOGGED_IN state."
    },
    {
      "indent": 3,
      "text": "An initiator must initiate an explicit or implicit connection logout for a connection in the CLEANUP_WAIT state, if the initiator intends to continue using the associated iSCSI session.",
      "zh-cn": "An initiator must initiate an explicit or implicit connection logout for a connection in the CLEANUP_WAIT state, if the initiator intends to continue using the associated iSCSI session."
    },
    {
      "indent": 3,
      "text": "The following state diagram applies to both initiators and targets. (M1, M2, M3, and M4 are defined in Section 8.2.2.)",
      "zh-cn": "The following state diagram applies to both initiators and targets. (M1, M2, M3, and M4 are defined in Section 8.2.2.)"
    },
    {
      "indent": 17,
      "text": "          ---------\n         / R1      \\\n     +---\\         /<-+\n    /     ----+----    \\\n   /          |         \\ M3\nM1 |          |M2        |\n   |          |         /\n   |          |        /\n   |          |       /\n   |          V      /\n   |       ---------/\n   |      / R2      \\\n   |      \\         /\n   |       ---------\n   |          |\n   |          |M4\n   |          |\n   |          |\n   |          |\n   |          V\n   |       --------\n   |      / R3     \\\n   +----->\\        /\n           --------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The following state transition table represents the above diagram and follows the same conventions as in earlier sections.",
      "zh-cn": "The following state transition table represents the above diagram and follows the same conventions as in earlier sections."
    },
    {
      "indent": 3,
      "text": "     +----+----+----+\n     |R1  |R2  |R3  |\n-----+----+----+----+\n R1  | -  |M2  |M1  |\n-----+----+----+----+\n R2  |M3  | -  |M4  |\n-----+----+----+----+\n R3  | -  | -  | -  |\n-----+----+----+----+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "8.2.1. State Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.2.1. State Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "R1: CLEANUP_WAIT (same as S8)",
      "zh-cn": "R1: CLEANUP_WAIT (same as S8)"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for the internal event to initiate the cleanup processing for CSM-C.",
      "zh-cn": "- initiator: Waiting for the internal event to initiate the cleanup processing for CSM-C."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the cleanup process to start for CSM-C.",
      "zh-cn": "- target: Waiting for the cleanup process to start for CSM-C."
    },
    {
      "indent": 3,
      "text": "R2: IN_CLEANUP",
      "zh-cn": "R2: IN_CLEANUP"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for the connection cleanup process to conclude for CSM-C.",
      "zh-cn": "- initiator: Waiting for the connection cleanup process to conclude for CSM-C."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for the connection cleanup process to conclude for CSM-C.",
      "zh-cn": "- target: Waiting for the connection cleanup process to conclude for CSM-C."
    },
    {
      "indent": 3,
      "text": "R3: FREE (same as S1)",
      "zh-cn": "R3: FREE (same as S1)"
    },
    {
      "indent": 7,
      "text": "- initiator: End state for CSM-C.",
      "zh-cn": "- initiator: End state for CSM-C."
    },
    {
      "indent": 7,
      "text": "- target: End state for CSM-C.",
      "zh-cn": "- target: End state for CSM-C."
    },
    {
      "indent": 0,
      "text": "8.2.2. State Transition Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.2.2. State Transition Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "M1: One or more of the following events was received:",
      "zh-cn": "M1: One or more of the following events was received:"
    },
    {
      "indent": 7,
      "text": "- initiator:",
      "zh-cn": "- initiator:"
    },
    {
      "indent": 9,
      "text": "* An internal event that indicates connection state timeout.",
      "zh-cn": "* An internal event that indicates connection state timeout."
    },
    {
      "indent": 9,
      "text": "* An internal event of receiving a successful Logout Response on a different connection for a \"close the session\" Logout.",
      "zh-cn": "* An internal event of receiving a successful Logout Response on a different connection for a \"close the session\" Logout."
    },
    {
      "indent": 7,
      "text": "- target:",
      "zh-cn": "- target:"
    },
    {
      "indent": 9,
      "text": "* An internal event that indicates connection state timeout.",
      "zh-cn": "* An internal event that indicates connection state timeout."
    },
    {
      "indent": 9,
      "text": "* An internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request.",
      "zh-cn": "* An internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request."
    },
    {
      "indent": 3,
      "text": "M2: An implicit/explicit logout process was initiated by the initiator.",
      "zh-cn": "M2: An implicit/explicit logout process was initiated by the initiator."
    },
    {
      "indent": 7,
      "text": "- In CSM-I usage:",
      "zh-cn": "- In CSM-I usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: An internal event requesting the connection (or session) reinstatement was received, thus prompting a connection (or session) reinstatement Login to be sent, transitioning CSM-I to state IN_LOGIN.",
      "zh-cn": "* initiator: An internal event requesting the connection (or session) reinstatement was received, thus prompting a connection (or session) reinstatement Login to be sent, transitioning CSM-I to state IN_LOGIN."
    },
    {
      "indent": 9,
      "text": "* target: A connection/session reinstatement Login was received while in state XPT_UP.",
      "zh-cn": "* target: A connection/session reinstatement Login was received while in state XPT_UP."
    },
    {
      "indent": 7,
      "text": "- In CSM-E usage:",
      "zh-cn": "- In CSM-E usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: An internal event was received that indicates that an explicit logout was sent for this CID in state LOGGED_IN.",
      "zh-cn": "* initiator: An internal event was received that indicates that an explicit logout was sent for this CID in state LOGGED_IN."
    },
    {
      "indent": 9,
      "text": "* target: An explicit logout was received for this CID in state LOGGED_IN.",
      "zh-cn": "* target: An explicit logout was received for this CID in state LOGGED_IN."
    },
    {
      "indent": 3,
      "text": "M3: Logout failure was detected.",
      "zh-cn": "M3: Logout failure was detected."
    },
    {
      "indent": 7,
      "text": "- In CSM-I usage:",
      "zh-cn": "- In CSM-I usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: CSM-I failed to reach LOGGED_IN and arrived into FREE instead.",
      "zh-cn": "* initiator: CSM-I failed to reach LOGGED_IN and arrived into FREE instead."
    },
    {
      "indent": 9,
      "text": "* target: CSM-I failed to reach LOGGED_IN and arrived into FREE instead.",
      "zh-cn": "* target: CSM-I failed to reach LOGGED_IN and arrived into FREE instead."
    },
    {
      "indent": 7,
      "text": "- In CSM-E usage:",
      "zh-cn": "- In CSM-E usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: either CSM-E moved out of LOGGED_IN, or Logout timed out and/or aborted, or Logout Response (failure) was received.",
      "zh-cn": "* initiator: either CSM-E moved out of LOGGED_IN, or Logout timed out and/or aborted, or Logout Response (failure) was received."
    },
    {
      "indent": 9,
      "text": "* target: either CSM-E moved out of LOGGED_IN, Logout timed out and/or aborted, or an internal event that indicates that a failed Logout processing was received. A Logout Response (failure) was sent in the last case.",
      "zh-cn": "* target: either CSM-E moved out of LOGGED_IN, Logout timed out and/or aborted, or an internal event that indicates that a failed Logout processing was received. A Logout Response (failure) was sent in the last case."
    },
    {
      "indent": 3,
      "text": "M4: Successful implicit/explicit logout was performed.",
      "zh-cn": "M4: Successful implicit/explicit logout was performed."
    },
    {
      "indent": 7,
      "text": "- In CSM-I usage:",
      "zh-cn": "- In CSM-I usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: CSM-I reached state LOGGED_IN, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "* initiator: CSM-I reached state LOGGED_IN, or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 9,
      "text": "* target: CSM-I reached state LOGGED_IN, or an internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "* target: CSM-I reached state LOGGED_IN, or an internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 7,
      "text": "- In CSM-E usage:",
      "zh-cn": "- In CSM-E usage:"
    },
    {
      "indent": 9,
      "text": "* initiator: CSM-E stayed in LOGGED_IN and received a Logout Response (success), or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "* initiator: CSM-E stayed in LOGGED_IN and received a Logout Response (success), or an internal event of receiving a Logout Response (success) on another connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 9,
      "text": "* target: CSM-E stayed in LOGGED_IN and an internal event indicating a successful Logout processing was received, or an internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request was received.",
      "zh-cn": "* target: CSM-E stayed in LOGGED_IN and an internal event indicating a successful Logout processing was received, or an internal event of sending a Logout Response (success) on a different connection for a \"close the session\" Logout Request was received."
    },
    {
      "indent": 0,
      "text": "8.3. Session State Diagrams",
      "section_title": true,
      "zh-cn": "8.3. Session State Diagrams"
    },
    {
      "indent": 0,
      "text": "8.3.1. Session State Diagram for an Initiator",
      "section_title": true,
      "zh-cn": "8.3.1. Session State Diagram for an Initiator"
    },
    {
      "indent": 3,
      "text": "Symbolic names for states:",
      "zh-cn": "Symbolic names for states:"
    },
    {
      "indent": 6,
      "text": "Q1: FREE",
      "zh-cn": "Q1: FREE"
    },
    {
      "indent": 6,
      "text": "Q3: LOGGED_IN",
      "zh-cn": "Q3: LOGGED_IN"
    },
    {
      "indent": 6,
      "text": "Q4: FAILED",
      "zh-cn": "Q4: FAILED"
    },
    {
      "indent": 3,
      "text": "State Q3 represents the Full Feature Phase operation of the session.",
      "zh-cn": "State Q3 represents the Full Feature Phase operation of the session."
    },
    {
      "indent": 3,
      "text": "The state diagram is as follows. (N1, N3, N4, N5, and N6 are defined in Section 8.3.4.)",
      "zh-cn": "The state diagram is as follows. (N1, N3, N4, N5, and N6 are defined in Section 8.3.4.)"
    },
    {
      "indent": 16,
      "text": "                   ---------\n                  / Q1      \\\n      +---------->\\         /<-+\n     /             ----+----   |\n    /                  |       |N3\nN6  |                  |N1     |\n    |                  |       |\n    |       N4         |       |\n    | +------------+   |      /\n    | |            |   |     /\n    | |            |   |    /\n    | |            V   V   /\n  --+-+---         -------+-\n / Q4     \\ N5    / Q3      \\\n \\        /<------\\         /\n  --------         ---------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The state transition table is as follows:",
      "zh-cn": "The state transition table is as follows:"
    },
    {
      "indent": 3,
      "text": "     +---+---+---+\n     |Q1 |Q3 |Q4 |\n-----+---+---+---+\n Q1  | - |N1 | - |\n-----+---+---+---+\n Q3  |N3 | - |N5 |\n-----+---+---+---+\n Q4  |N6 |N4 | - |\n-----+---+---+---+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "8.3.2. Session State Diagram for a Target",
      "section_title": true,
      "zh-cn": "8.3.2. Session State Diagram for a Target"
    },
    {
      "indent": 3,
      "text": "Symbolic names for states:",
      "zh-cn": "Symbolic names for states:"
    },
    {
      "indent": 6,
      "text": "Q1: FREE",
      "zh-cn": "Q1: FREE"
    },
    {
      "indent": 6,
      "text": "Q2: ACTIVE",
      "zh-cn": "Q2: ACTIVE"
    },
    {
      "indent": 6,
      "text": "Q3: LOGGED_IN",
      "zh-cn": "Q3: LOGGED_IN"
    },
    {
      "indent": 6,
      "text": "Q4: FAILED",
      "zh-cn": "Q4: FAILED"
    },
    {
      "indent": 6,
      "text": "Q5: IN_CONTINUE",
      "zh-cn": "Q5: IN_CONTINUE"
    },
    {
      "indent": 3,
      "text": "State Q3 represents the Full Feature Phase operation of the session.",
      "zh-cn": "State Q3 represents the Full Feature Phase operation of the session."
    },
    {
      "indent": 3,
      "text": "The state diagram is as follows:",
      "zh-cn": "The state diagram is as follows:"
    },
    {
      "indent": 17,
      "text": "                          ---------\n    +------------------->/ Q1      \\\n   /     +-------------->\\         /<-+\n   |     |                ---+-----   |\n   |     |                 ^ |        |N3\nN6 |     |N11            N9| V N1     |\n   |     |                 +--------  |\n   |     |                / Q2      \\ |\n   |     |                \\         / |\n   |  ---+-----            +--+-----  |\n   | / Q5      \\              |       |\n   | \\         / N10          |       |\n   |  -+-+----+-----------+   | N2   /\n   |   ^ |                |   |     /\n   | N7| |N8              |   |    /\n   |   | |                |   V   /\n --+---+-V                V------+-\n/ Q4      \\ N5           / Q3      \\\n\\         /<-------------\\         /\n ---------                ---------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The state transition table is as follows:",
      "zh-cn": "The state transition table is as follows:"
    },
    {
      "indent": 3,
      "text": "     +----+----+----+----+----+\n     |Q1  |Q2  |Q3  |Q4  |Q5  |\n-----+----+----+----+----+----+\n Q1  | -  |N1  | -  | -  | -  |\n-----+----+----+----+----+----+\n Q2  |N9  | -  |N2  | -  | -  |\n-----+----+----+----+----+----+\n Q3  |N3  | -  | -  |N5  | -  |\n-----+----+----+----+----+----+\n Q4  |N6  | -  | -  | -  |N7  |\n-----+----+----+----+----+----+\n Q5  |N11 | -  |N10 |N8  | -  |\n-----+----+----+----+----+----+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "8.3.3. State Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.3.3. State Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "Q1: FREE",
      "zh-cn": "Q1: FREE"
    },
    {
      "indent": 7,
      "text": "- initiator: State on instantiation or after cleanup.",
      "zh-cn": "- initiator: State on instantiation or after cleanup."
    },
    {
      "indent": 7,
      "text": "- target: State on instantiation or after cleanup.",
      "zh-cn": "- target: State on instantiation or after cleanup."
    },
    {
      "indent": 3,
      "text": "Q2: ACTIVE",
      "zh-cn": "Q2: ACTIVE"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: The first iSCSI connection in the session transitioned to IN_LOGIN, waiting for it to complete the login process.",
      "zh-cn": "- target: The first iSCSI connection in the session transitioned to IN_LOGIN, waiting for it to complete the login process."
    },
    {
      "indent": 3,
      "text": "Q3: LOGGED_IN",
      "zh-cn": "Q3: LOGGED_IN"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for all session events.",
      "zh-cn": "- initiator: Waiting for all session events."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for all session events.",
      "zh-cn": "- target: Waiting for all session events."
    },
    {
      "indent": 3,
      "text": "Q4: FAILED",
      "zh-cn": "Q4: FAILED"
    },
    {
      "indent": 7,
      "text": "- initiator: Waiting for session recovery or session continuation.",
      "zh-cn": "- initiator: Waiting for session recovery or session continuation."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for session recovery or session continuation.",
      "zh-cn": "- target: Waiting for session recovery or session continuation."
    },
    {
      "indent": 3,
      "text": "Q5: IN_CONTINUE",
      "zh-cn": "Q5: IN_CONTINUE"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: Waiting for session continuation attempt to reach a conclusion.",
      "zh-cn": "- target: Waiting for session continuation attempt to reach a conclusion."
    },
    {
      "indent": 0,
      "text": "8.3.4. State Transition Descriptions for Initiators and Targets",
      "section_title": true,
      "zh-cn": "8.3.4. State Transition Descriptions for Initiators and Targets"
    },
    {
      "indent": 3,
      "text": "N1:",
      "zh-cn": "N1:"
    },
    {
      "indent": 7,
      "text": "- initiator: At least one transport connection reached the LOGGED_IN state.",
      "zh-cn": "- initiator: At least one transport connection reached the LOGGED_IN state."
    },
    {
      "indent": 7,
      "text": "- target: The first iSCSI connection in the session had reached the IN_LOGIN state.",
      "zh-cn": "- target: The first iSCSI connection in the session had reached the IN_LOGIN state."
    },
    {
      "indent": 3,
      "text": "N2:",
      "zh-cn": "N2:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: At least one iSCSI connection reached the LOGGED_IN state.",
      "zh-cn": "- target: At least one iSCSI connection reached the LOGGED_IN state."
    },
    {
      "indent": 3,
      "text": "N3:",
      "zh-cn": "N3:"
    },
    {
      "indent": 7,
      "text": "- initiator: Graceful closing of the session via session closure (Section 6.3.6).",
      "zh-cn": "- initiator: Graceful closing of the session via session closure (Section 6.3.6)."
    },
    {
      "indent": 7,
      "text": "- target: Graceful closing of the session via session closure (Section 6.3.6) or a successful session reinstatement cleanly closed the session.",
      "zh-cn": "- target: Graceful closing of the session via session closure (Section 6.3.6) or a successful session reinstatement cleanly closed the session."
    },
    {
      "indent": 3,
      "text": "N4:",
      "zh-cn": "N4:"
    },
    {
      "indent": 7,
      "text": "- initiator: A session continuation attempt succeeded.",
      "zh-cn": "- initiator: A session continuation attempt succeeded."
    },
    {
      "indent": 7,
      "text": "- target: Illegal.",
      "zh-cn": "- target: Illegal."
    },
    {
      "indent": 3,
      "text": "N5: - initiator: Session failure (Section 6.3.6) occurred.",
      "zh-cn": "N5: - initiator: Session failure (Section 6.3.6) occurred."
    },
    {
      "indent": 7,
      "text": "- target: Session failure (Section 6.3.6) occurred.",
      "zh-cn": "- target: Session failure (Section 6.3.6) occurred."
    },
    {
      "indent": 3,
      "text": "N6:",
      "zh-cn": "N6:"
    },
    {
      "indent": 7,
      "text": "- initiator: Session state timeout occurred, or a session reinstatement cleared this session instance. This results in the freeing of all associated resources, and the session state is discarded.",
      "zh-cn": "- initiator: Session state timeout occurred, or a session reinstatement cleared this session instance. This results in the freeing of all associated resources, and the session state is discarded."
    },
    {
      "indent": 7,
      "text": "- target: Session state timeout occurred, or a session reinstatement cleared this session instance. This results in the freeing of all associated resources, and the session state is discarded.",
      "zh-cn": "- target: Session state timeout occurred, or a session reinstatement cleared this session instance. This results in the freeing of all associated resources, and the session state is discarded."
    },
    {
      "indent": 3,
      "text": "N7:",
      "zh-cn": "N7:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: A session continuation attempt was initiated.",
      "zh-cn": "- target: A session continuation attempt was initiated."
    },
    {
      "indent": 3,
      "text": "N8:",
      "zh-cn": "N8:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: The last session continuation attempt failed.",
      "zh-cn": "- target: The last session continuation attempt failed."
    },
    {
      "indent": 3,
      "text": "N9:",
      "zh-cn": "N9:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: Login attempt on the leading connection failed.",
      "zh-cn": "- target: Login attempt on the leading connection failed."
    },
    {
      "indent": 3,
      "text": "N10:",
      "zh-cn": "N10:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: A session continuation attempt succeeded.",
      "zh-cn": "- target: A session continuation attempt succeeded."
    },
    {
      "indent": 3,
      "text": "N11:",
      "zh-cn": "N11:"
    },
    {
      "indent": 7,
      "text": "- initiator: Illegal.",
      "zh-cn": "- initiator: Illegal."
    },
    {
      "indent": 7,
      "text": "- target: A successful session reinstatement cleanly closed the session.",
      "zh-cn": "- target: A successful session reinstatement cleanly closed the session."
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "zh-cn": "9. Security Considerations"
    },
    {
      "indent": 3,
      "text": "Historically, native storage systems have not had to consider security, because their environments offered minimal security risks. That is, these environments consisted of storage devices either directly attached to hosts or connected via a Storage Area Network (SAN) distinctly separate from the communications network. The use of storage protocols, such as SCSI, over IP networks requires that security concerns be addressed. iSCSI implementations must provide means of protection against active attacks (e.g., pretending to be another identity; message insertion, deletion, modification, and replaying) and passive attacks (e.g., eavesdropping, gaining advantage by analyzing the data sent over the line).",
      "zh-cn": "Historically, native storage systems have not had to consider security, because their environments offered minimal security risks. That is, these environments consisted of storage devices either directly attached to hosts or connected via a Storage Area Network (SAN) distinctly separate from the communications network. The use of storage protocols, such as SCSI, over IP networks requires that security concerns be addressed. iSCSI implementations must provide means of protection against active attacks (e.g., pretending to be another identity; message insertion, deletion, modification, and replaying) and passive attacks (e.g., eavesdropping, gaining advantage by analyzing the data sent over the line)."
    },
    {
      "indent": 3,
      "text": "Although technically possible, iSCSI SHOULD NOT be configured without security, specifically in-band authentication; see Section 9.2. iSCSI configured without security should be confined to closed environments that have very limited and well-controlled security risks. [RFC3723] specifies the mechanisms that must be used in order to mitigate risks fully described in that document.",
      "zh-cn": "Although technically possible, iSCSI SHOULD NOT be configured without security, specifically in-band authentication; see Section 9.2. iSCSI configured without security should be confined to closed environments that have very limited and well-controlled security risks. [RFC3723] specifies the mechanisms that must be used in order to mitigate risks fully described in that document."
    },
    {
      "indent": 3,
      "text": "The following section describes the security mechanisms provided by an iSCSI implementation.",
      "zh-cn": "The following section describes the security mechanisms provided by an iSCSI implementation."
    },
    {
      "indent": 0,
      "text": "9.1. iSCSI Security Mechanisms",
      "section_title": true,
      "zh-cn": "9.1. iSCSI Security Mechanisms"
    },
    {
      "indent": 3,
      "text": "The entities involved in iSCSI security are the initiator, target, and the IP communication endpoints. iSCSI scenarios in which multiple initiators or targets share a single communication endpoint are expected. To accommodate such scenarios, iSCSI supports two separate security mechanisms: in-band authentication between the initiator and the target at the iSCSI connection level (carried out by exchange of iSCSI Login PDUs), and packet protection (integrity, authentication, and confidentiality) by IPsec at the IP level. The two security mechanisms complement each other. The in-band authentication provides end-to-end trust (at login time) between the iSCSI initiator and the target, while IPsec provides a secure channel between the IP communication endpoints. iSCSI can be used to access sensitive information for which significant security protection is appropriate. As further specified in the rest of this security considerations section, both iSCSI security mechanisms are mandatory to implement (MUST). The use of in-band authentication is strongly recommended (SHOULD). In contrast, the use of IPsec is optional (MAY), as the security risks that it addresses may only be present over a subset of the networks used by an iSCSI connection or a session; a specific example is that when an iSCSI session spans data centers, IPsec VPN gateways at the data center boundaries to protect the WAN connectivity between data centers may be appropriate in combination with in-band iSCSI authentication.",
      "zh-cn": "The entities involved in iSCSI security are the initiator, target, and the IP communication endpoints. iSCSI scenarios in which multiple initiators or targets share a single communication endpoint are expected. To accommodate such scenarios, iSCSI supports two separate security mechanisms: in-band authentication between the initiator and the target at the iSCSI connection level (carried out by exchange of iSCSI Login PDUs), and packet protection (integrity, authentication, and confidentiality) by IPsec at the IP level. The two security mechanisms complement each other. The in-band authentication provides end-to-end trust (at login time) between the iSCSI initiator and the target, while IPsec provides a secure channel between the IP communication endpoints. iSCSI can be used to access sensitive information for which significant security protection is appropriate. As further specified in the rest of this security considerations section, both iSCSI security mechanisms are mandatory to implement (MUST). The use of in-band authentication is strongly recommended (SHOULD). In contrast, the use of IPsec is optional (MAY), as the security risks that it addresses may only be present over a subset of the networks used by an iSCSI connection or a session; a specific example is that when an iSCSI session spans data centers, IPsec VPN gateways at the data center boundaries to protect the WAN connectivity between data centers may be appropriate in combination with in-band iSCSI authentication."
    },
    {
      "indent": 3,
      "text": "Further details on typical iSCSI scenarios and the relationship between the initiators, targets, and the communication endpoints can be found in [RFC3723].",
      "zh-cn": "Further details on typical iSCSI scenarios and the relationship between the initiators, targets, and the communication endpoints can be found in [RFC3723]."
    },
    {
      "indent": 0,
      "text": "9.2. In-Band Initiator-Target Authentication",
      "section_title": true,
      "zh-cn": "9.2. In-Band Initiator-Target Authentication"
    },
    {
      "indent": 3,
      "text": "During login, the target MAY authenticate the initiator and the initiator MAY authenticate the target. The authentication is performed on every new iSCSI connection by an exchange of iSCSI Login PDUs using a negotiated authentication method.",
      "zh-cn": "During login, the target MAY authenticate the initiator and the initiator MAY authenticate the target. The authentication is performed on every new iSCSI connection by an exchange of iSCSI Login PDUs using a negotiated authentication method."
    },
    {
      "indent": 3,
      "text": "The authentication method cannot assume an underlying IPsec protection, because IPsec is optional to use. An attacker should gain as little advantage as possible by inspecting the authentication phase PDUs. Therefore, a method using cleartext (or equivalent) passwords MUST NOT be used; on the other hand, identity protection is not strictly required.",
      "zh-cn": "The authentication method cannot assume an underlying IPsec protection, because IPsec is optional to use. An attacker should gain as little advantage as possible by inspecting the authentication phase PDUs. Therefore, a method using cleartext (or equivalent) passwords MUST NOT be used; on the other hand, identity protection is not strictly required."
    },
    {
      "indent": 3,
      "text": "The authentication mechanism protects against an unauthorized login to storage resources by using a false identity (spoofing). Once the authentication phase is completed, if the underlying IPsec is not used, all PDUs are sent and received in the clear. The",
      "zh-cn": "The authentication mechanism protects against an unauthorized login to storage resources by using a false identity (spoofing). Once the authentication phase is completed, if the underlying IPsec is not used, all PDUs are sent and received in the clear. The"
    },
    {
      "indent": 3,
      "text": "authentication mechanism alone (without underlying IPsec) should only be used when there is no risk of eavesdropping or of message insertion, deletion, modification, and replaying.",
      "zh-cn": "authentication mechanism alone (without underlying IPsec) should only be used when there is no risk of eavesdropping or of message insertion, deletion, modification, and replaying."
    },
    {
      "indent": 3,
      "text": "Section 12 defines several authentication methods and the exact steps that must be followed in each of them, including the iSCSI-text-keys and their allowed values in each step. Whenever an iSCSI initiator gets a response whose keys, or their values, are not according to the step definition, it MUST abort the connection.",
      "zh-cn": "Section 12 defines several authentication methods and the exact steps that must be followed in each of them, including the iSCSI-text-keys and their allowed values in each step. Whenever an iSCSI initiator gets a response whose keys, or their values, are not according to the step definition, it MUST abort the connection."
    },
    {
      "indent": 3,
      "text": "Whenever an iSCSI target gets a request or response whose keys, or their values, are not according to the step definition, it MUST answer with a Login reject with the \"Initiator Error\" or \"Missing Parameter\" status. These statuses are not intended for cryptographically incorrect values such as the CHAP response, for which the \"Authentication Failure\" status MUST be specified. The importance of this rule can be illustrated in CHAP with target authentication (see Section 12.1.3), where the initiator would have been able to conduct a reflection attack by omitting its response key (CHAP_R), using the same CHAP challenge as the target and reflecting the target's response back to the target. In CHAP, this is prevented because the target must answer the missing CHAP_R key with a Login reject with the \"Missing Parameter\" status.",
      "zh-cn": "Whenever an iSCSI target gets a request or response whose keys, or their values, are not according to the step definition, it MUST answer with a Login reject with the \"Initiator Error\" or \"Missing Parameter\" status. These statuses are not intended for cryptographically incorrect values such as the CHAP response, for which the \"Authentication Failure\" status MUST be specified. The importance of this rule can be illustrated in CHAP with target authentication (see Section 12.1.3), where the initiator would have been able to conduct a reflection attack by omitting its response key (CHAP_R), using the same CHAP challenge as the target and reflecting the target's response back to the target. In CHAP, this is prevented because the target must answer the missing CHAP_R key with a Login reject with the \"Missing Parameter\" status."
    },
    {
      "indent": 3,
      "text": "For some of the authentication methods, a key specifies the identity of the iSCSI initiator or target for authentication purposes. The value associated with that key MAY be different from the iSCSI name and SHOULD be configurable (CHAP_N: see Section 12.1.3; SRP_U: see Section 12.1.2). For this reason, iSCSI implementations SHOULD manage authentication in a way that impersonation across iSCSI names via these authentication identities is not possible. Specifically, implementations SHOULD allow configuration of an authentication identity for a Name if different, and authentication credentials for that identity. During the login time, implementations SHOULD verify the Name-to-identity relationship in addition to authenticating the identity through the negotiated authentication method.",
      "zh-cn": "For some of the authentication methods, a key specifies the identity of the iSCSI initiator or target for authentication purposes. The value associated with that key MAY be different from the iSCSI name and SHOULD be configurable (CHAP_N: see Section 12.1.3; SRP_U: see Section 12.1.2). For this reason, iSCSI implementations SHOULD manage authentication in a way that impersonation across iSCSI names via these authentication identities is not possible. Specifically, implementations SHOULD allow configuration of an authentication identity for a Name if different, and authentication credentials for that identity. During the login time, implementations SHOULD verify the Name-to-identity relationship in addition to authenticating the identity through the negotiated authentication method."
    },
    {
      "indent": 3,
      "text": "When an iSCSI session has multiple TCP connections, either concurrently or sequentially, the authentication method and identities should not vary among the connections. Therefore, all connections in an iSCSI session SHOULD use the same authentication method, iSCSI name, and authentication identity (for authentication methods that use an authentication identity). Implementations SHOULD check this and cause an authentication failure on a new connection that uses a different authentication method, iSCSI name, or authentication identity from those already used in the session. In",
      "zh-cn": "When an iSCSI session has multiple TCP connections, either concurrently or sequentially, the authentication method and identities should not vary among the connections. Therefore, all connections in an iSCSI session SHOULD use the same authentication method, iSCSI name, and authentication identity (for authentication methods that use an authentication identity). Implementations SHOULD check this and cause an authentication failure on a new connection that uses a different authentication method, iSCSI name, or authentication identity from those already used in the session. In"
    },
    {
      "indent": 3,
      "text": "addition, implementations SHOULD NOT support both authenticated and unauthenticated TCP connections in the same iSCSI session, added either concurrently or sequentially to the session.",
      "zh-cn": "addition, implementations SHOULD NOT support both authenticated and unauthenticated TCP connections in the same iSCSI session, added either concurrently or sequentially to the session."
    },
    {
      "indent": 0,
      "text": "9.2.1. CHAP Considerations",
      "section_title": true,
      "zh-cn": "9.2.1. CHAP Considerations"
    },
    {
      "indent": 3,
      "text": "Compliant iSCSI initiators and targets MUST implement the CHAP authentication method [RFC1994] (according to Section 12.1.3, including the target authentication option).",
      "zh-cn": "Compliant iSCSI initiators and targets MUST implement the CHAP authentication method [RFC1994] (according to Section 12.1.3, including the target authentication option)."
    },
    {
      "indent": 3,
      "text": "When CHAP is performed over a non-encrypted channel, it is vulnerable to an off-line dictionary attack. Implementations MUST support the use of up to 128-bit random CHAP secrets, including the means to generate such secrets and to accept them from an external generation source. Implementations MUST NOT provide secret generation (or expansion) means other than random generation.",
      "zh-cn": "When CHAP is performed over a non-encrypted channel, it is vulnerable to an off-line dictionary attack. Implementations MUST support the use of up to 128-bit random CHAP secrets, including the means to generate such secrets and to accept them from an external generation source. Implementations MUST NOT provide secret generation (or expansion) means other than random generation."
    },
    {
      "indent": 3,
      "text": "An administrative entity of an environment in which CHAP is used with a secret that has less than 96 random bits MUST enforce IPsec encryption (according to the implementation requirements in Section 9.3.2) to protect the connection. Moreover, in this case, IKE authentication with group pre-shared cryptographic keys SHOULD NOT be used unless it is not essential to protect group members against off-line dictionary attacks by other members.",
      "zh-cn": "An administrative entity of an environment in which CHAP is used with a secret that has less than 96 random bits MUST enforce IPsec encryption (according to the implementation requirements in Section 9.3.2) to protect the connection. Moreover, in this case, IKE authentication with group pre-shared cryptographic keys SHOULD NOT be used unless it is not essential to protect group members against off-line dictionary attacks by other members."
    },
    {
      "indent": 3,
      "text": "CHAP secrets MUST be an integral number of bytes (octets). A compliant implementation SHOULD NOT continue with the login step in which it should send a CHAP response (CHAP_R; see Section 12.1.3) unless it can verify that the CHAP secret is at least 96 bits or that IPsec encryption is being used to protect the connection.",
      "zh-cn": "CHAP secrets MUST be an integral number of bytes (octets). A compliant implementation SHOULD NOT continue with the login step in which it should send a CHAP response (CHAP_R; see Section 12.1.3) unless it can verify that the CHAP secret is at least 96 bits or that IPsec encryption is being used to protect the connection."
    },
    {
      "indent": 3,
      "text": "Any CHAP secret used for initiator authentication MUST NOT be configured for authentication of any target, and any CHAP secret used for target authentication MUST NOT be configured for authentication of any initiator. If the CHAP response received by one end of an iSCSI connection is the same as the CHAP response that the receiving endpoint would have generated for the same CHAP challenge, the response MUST be treated as an authentication failure and cause the connection to close (this ensures that the same CHAP secret is not used for authentication in both directions). Also, if an iSCSI implementation can function as both initiator and target, different CHAP secrets and identities MUST be configured for these two roles. The following is an example of the attacks prevented by the above requirements:",
      "zh-cn": "Any CHAP secret used for initiator authentication MUST NOT be configured for authentication of any target, and any CHAP secret used for target authentication MUST NOT be configured for authentication of any initiator. If the CHAP response received by one end of an iSCSI connection is the same as the CHAP response that the receiving endpoint would have generated for the same CHAP challenge, the response MUST be treated as an authentication failure and cause the connection to close (this ensures that the same CHAP secret is not used for authentication in both directions). Also, if an iSCSI implementation can function as both initiator and target, different CHAP secrets and identities MUST be configured for these two roles. The following is an example of the attacks prevented by the above requirements:"
    },
    {
      "indent": 6,
      "text": "a) \"Rogue\" wants to impersonate \"Storage\" to Alice and knows that a single secret is used for both directions of Storage-Alice authentication.",
      "zh-cn": "a) \"Rogue\" wants to impersonate \"Storage\" to Alice and knows that a single secret is used for both directions of Storage-Alice authentication."
    },
    {
      "indent": 6,
      "text": "b) Rogue convinces Alice to open two connections to itself and identifies itself as Storage on both connections.",
      "zh-cn": "b) Rogue convinces Alice to open two connections to itself and identifies itself as Storage on both connections."
    },
    {
      "indent": 6,
      "text": "c) Rogue issues a CHAP challenge on Connection 1, waits for Alice to respond, and then reflects Alice's challenge as the initial challenge to Alice on Connection 2.",
      "zh-cn": "c) Rogue issues a CHAP challenge on Connection 1, waits for Alice to respond, and then reflects Alice's challenge as the initial challenge to Alice on Connection 2."
    },
    {
      "indent": 6,
      "text": "d) If Alice doesn't check for the reflection across connections, Alice's response on Connection 2 enables Rogue to impersonate Storage on Connection 1, even though Rogue does not know the Alice-Storage CHAP secret.",
      "zh-cn": "d) If Alice doesn't check for the reflection across connections, Alice's response on Connection 2 enables Rogue to impersonate Storage on Connection 1, even though Rogue does not know the Alice-Storage CHAP secret."
    },
    {
      "indent": 3,
      "text": "Originators MUST NOT reuse the CHAP challenge sent by the responder for the other direction of a bidirectional authentication. Responders MUST check for this condition and close the iSCSI TCP connection if it occurs.",
      "zh-cn": "Originators MUST NOT reuse the CHAP challenge sent by the responder for the other direction of a bidirectional authentication. Responders MUST check for this condition and close the iSCSI TCP connection if it occurs."
    },
    {
      "indent": 3,
      "text": "The same CHAP secret SHOULD NOT be configured for authentication of multiple initiators or multiple targets, as this enables any of them to impersonate any other one of them, and compromising one of them enables the attacker to impersonate any of them. It is recommended that iSCSI implementations check for the use of identical CHAP secrets by different peers when this check is feasible and take appropriate measures to warn users and/or administrators when this is detected.",
      "zh-cn": "The same CHAP secret SHOULD NOT be configured for authentication of multiple initiators or multiple targets, as this enables any of them to impersonate any other one of them, and compromising one of them enables the attacker to impersonate any of them. It is recommended that iSCSI implementations check for the use of identical CHAP secrets by different peers when this check is feasible and take appropriate measures to warn users and/or administrators when this is detected."
    },
    {
      "indent": 3,
      "text": "When an iSCSI initiator or target authenticates itself to counterparts in multiple administrative domains, it SHOULD use a different CHAP secret for each administrative domain to avoid propagating security compromises across domains.",
      "zh-cn": "When an iSCSI initiator or target authenticates itself to counterparts in multiple administrative domains, it SHOULD use a different CHAP secret for each administrative domain to avoid propagating security compromises across domains."
    },
    {
      "indent": 3,
      "text": "Within a single administrative domain:",
      "zh-cn": "Within a single administrative domain:"
    },
    {
      "indent": 6,
      "text": "- A single CHAP secret MAY be used for authentication of an initiator to multiple targets.",
      "zh-cn": "- A single CHAP secret MAY be used for authentication of an initiator to multiple targets."
    },
    {
      "indent": 6,
      "text": "- A single CHAP secret MAY be used for an authentication of a target to multiple initiators when the initiators use an external server (e.g., RADIUS [RFC2865]) to verify the target's CHAP responses and do not know the target's CHAP secret.",
      "zh-cn": "- A single CHAP secret MAY be used for an authentication of a target to multiple initiators when the initiators use an external server (e.g., RADIUS [RFC2865]) to verify the target's CHAP responses and do not know the target's CHAP secret."
    },
    {
      "indent": 3,
      "text": "If an external response verification server (e.g., RADIUS) is not used, employing a single CHAP secret for authentication of a target to multiple initiators requires that all such initiators know that target's secret. Any of these initiators can impersonate the target to any other such initiator, and compromise of such an initiator enables an attacker to impersonate the target to all such initiators. Targets SHOULD use separate CHAP secrets for authentication to each",
      "zh-cn": "If an external response verification server (e.g., RADIUS) is not used, employing a single CHAP secret for authentication of a target to multiple initiators requires that all such initiators know that target's secret. Any of these initiators can impersonate the target to any other such initiator, and compromise of such an initiator enables an attacker to impersonate the target to all such initiators. Targets SHOULD use separate CHAP secrets for authentication to each"
    },
    {
      "indent": 3,
      "text": "initiator when such risks are of concern; in this situation, it may be useful to configure a separate logical iSCSI target with its own iSCSI Node Name for each initiator or group of initiators among which such separation is desired.",
      "zh-cn": "initiator when such risks are of concern; in this situation, it may be useful to configure a separate logical iSCSI target with its own iSCSI Node Name for each initiator or group of initiators among which such separation is desired."
    },
    {
      "indent": 3,
      "text": "The above requirements strengthen the security properties of CHAP authentication for iSCSI by comparison to the basic CHAP authentication mechanism [RFC1994]. It is very important to adhere to these requirements, especially the requirements for strong (large randomly generated) CHAP secrets, as iSCSI implementations and deployments that fail to use strong CHAP secrets are likely to be highly vulnerable to off-line dictionary attacks on CHAP secrets.",
      "zh-cn": "The above requirements strengthen the security properties of CHAP authentication for iSCSI by comparison to the basic CHAP authentication mechanism [RFC1994]. It is very important to adhere to these requirements, especially the requirements for strong (large randomly generated) CHAP secrets, as iSCSI implementations and deployments that fail to use strong CHAP secrets are likely to be highly vulnerable to off-line dictionary attacks on CHAP secrets."
    },
    {
      "indent": 3,
      "text": "Replacement of CHAP with a better authentication mechanism is anticipated in a future version of iSCSI. The FC-SP-2 standard [FC-SP-2] has specified the Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) authentication mechanism [RFC5433] as an alternative to (and possible future replacement for) Fibre Channel's similar usage of strengthened CHAP. Another possible replacement for CHAP is a secure password mechanism, e.g., an updated version of iSCSI's current SRP authentication mechanism.",
      "zh-cn": "Replacement of CHAP with a better authentication mechanism is anticipated in a future version of iSCSI. The FC-SP-2 standard [FC-SP-2] has specified the Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) authentication mechanism [RFC5433] as an alternative to (and possible future replacement for) Fibre Channel's similar usage of strengthened CHAP. Another possible replacement for CHAP is a secure password mechanism, e.g., an updated version of iSCSI's current SRP authentication mechanism."
    },
    {
      "indent": 0,
      "text": "9.2.2. SRP Considerations",
      "section_title": true,
      "zh-cn": "9.2.2. SRP Considerations"
    },
    {
      "indent": 3,
      "text": "The strength of the SRP authentication method (specified in [RFC2945]) is dependent on the characteristics of the group being used (i.e., the prime modulus N and generator g). As described in [RFC2945], N is required to be a Sophie Germain prime (of the form N = 2q + 1, where q is also prime) and the generator g is a primitive root of GF(N). In iSCSI authentication, the prime modulus N MUST be at least 768 bits.",
      "zh-cn": "The strength of the SRP authentication method (specified in [RFC2945]) is dependent on the characteristics of the group being used (i.e., the prime modulus N and generator g). As described in [RFC2945], N is required to be a Sophie Germain prime (of the form N = 2q + 1, where q is also prime) and the generator g is a primitive root of GF(N). In iSCSI authentication, the prime modulus N MUST be at least 768 bits."
    },
    {
      "indent": 3,
      "text": "The list of allowed SRP groups is provided in [RFC3723].",
      "zh-cn": "The list of allowed SRP groups is provided in [RFC3723]."
    },
    {
      "indent": 0,
      "text": "9.2.3. Kerberos Considerations",
      "section_title": true,
      "zh-cn": "9.2.3. Kerberos Considerations"
    },
    {
      "indent": 3,
      "text": "iSCSI uses raw Kerberos V5 [RFC4120] for authenticating a client (iSCSI initiator) principal to a service (iSCSI target) principal. Note that iSCSI does not use the Generic Security Service Application Program Interface (GSS-API) [RFC2743] or the Kerberos V5 GSS-API security mechanism [RFC4121]. This means that iSCSI implementations supporting the KRB5 AuthMethod (Section 12.1) are directly involved in the Kerberos protocol. When Kerberos V5 is used for authentication, the following actions MUST be performed as specified in [RFC4120]:",
      "zh-cn": "iSCSI uses raw Kerberos V5 [RFC4120] for authenticating a client (iSCSI initiator) principal to a service (iSCSI target) principal. Note that iSCSI does not use the Generic Security Service Application Program Interface (GSS-API) [RFC2743] or the Kerberos V5 GSS-API security mechanism [RFC4121]. This means that iSCSI implementations supporting the KRB5 AuthMethod (Section 12.1) are directly involved in the Kerberos protocol. When Kerberos V5 is used for authentication, the following actions MUST be performed as specified in [RFC4120]:"
    },
    {
      "indent": 6,
      "text": "- The target MUST validate KRB_AP_REQ to ensure that the initiator can be trusted.",
      "zh-cn": "- The target MUST validate KRB_AP_REQ to ensure that the initiator can be trusted."
    },
    {
      "indent": 6,
      "text": "- When mutual authentication is selected, the initiator MUST validate KRB_AP_REP to determine the outcome of mutual authentication.",
      "zh-cn": "- When mutual authentication is selected, the initiator MUST validate KRB_AP_REP to determine the outcome of mutual authentication."
    },
    {
      "indent": 3,
      "text": "As Kerberos V5 is capable of providing mutual authentication, implementations SHOULD support mutual authentication by default for login authentication.",
      "zh-cn": "As Kerberos V5 is capable of providing mutual authentication, implementations SHOULD support mutual authentication by default for login authentication."
    },
    {
      "indent": 3,
      "text": "Note, however, that Kerberos authentication only assures that the server (iSCSI target) can be trusted by the Kerberos client (initiator) and vice versa; an initiator should employ appropriately secured service discovery techniques (e.g., iSNS; see Section 4.2.7) to ensure that it is talking to the intended target principal.",
      "zh-cn": "Note, however, that Kerberos authentication only assures that the server (iSCSI target) can be trusted by the Kerberos client (initiator) and vice versa; an initiator should employ appropriately secured service discovery techniques (e.g., iSNS; see Section 4.2.7) to ensure that it is talking to the intended target principal."
    },
    {
      "indent": 3,
      "text": "iSCSI does not use Kerberos v5 for either integrity or confidentiality protection of the iSCSI protocol. iSCSI uses IPsec for those purposes as specified in Section 9.3.",
      "zh-cn": "iSCSI does not use Kerberos v5 for either integrity or confidentiality protection of the iSCSI protocol. iSCSI uses IPsec for those purposes as specified in Section 9.3."
    },
    {
      "indent": 0,
      "text": "9.3. IPsec",
      "section_title": true,
      "zh-cn": "9.3. IPsec"
    },
    {
      "indent": 3,
      "text": "iSCSI uses the IPsec mechanism for packet protection (cryptographic integrity, authentication, and confidentiality) at the IP level between the iSCSI communicating endpoints. The following sections describe the IPsec protocols that must be implemented for data authentication and integrity; confidentiality; and cryptographic key management.",
      "zh-cn": "iSCSI uses the IPsec mechanism for packet protection (cryptographic integrity, authentication, and confidentiality) at the IP level between the iSCSI communicating endpoints. The following sections describe the IPsec protocols that must be implemented for data authentication and integrity; confidentiality; and cryptographic key management."
    },
    {
      "indent": 3,
      "text": "An iSCSI initiator or target may provide the required IPsec support fully integrated or in conjunction with an IPsec front-end device. In the latter case, the compliance requirements with regard to IPsec support apply to the \"combined device\". Only the \"combined device\" is to be considered an iSCSI device.",
      "zh-cn": "An iSCSI initiator or target may provide the required IPsec support fully integrated or in conjunction with an IPsec front-end device. In the latter case, the compliance requirements with regard to IPsec support apply to the \"combined device\". Only the \"combined device\" is to be considered an iSCSI device."
    },
    {
      "indent": 3,
      "text": "Detailed considerations and recommendations for using IPsec for iSCSI are provided in [RFC3723] as updated by [RFC7146]. The IPsec requirements are reproduced here for convenience and are intended to match those in [RFC7146]; in the event of a discrepancy, the requirements in [RFC7146] apply.",
      "zh-cn": "Detailed considerations and recommendations for using IPsec for iSCSI are provided in [RFC3723] as updated by [RFC7146]. The IPsec requirements are reproduced here for convenience and are intended to match those in [RFC7146]; in the event of a discrepancy, the requirements in [RFC7146] apply."
    },
    {
      "indent": 0,
      "text": "9.3.1. Data Authentication and Integrity",
      "section_title": true,
      "zh-cn": "9.3.1. Data Authentication and Integrity"
    },
    {
      "indent": 3,
      "text": "Data authentication and integrity are provided by a cryptographic keyed Message Authentication Code in every sent packet. This code protects against message insertion, deletion, and modification. Protection against message replay is realized by using a sequence counter.",
      "zh-cn": "Data authentication and integrity are provided by a cryptographic keyed Message Authentication Code in every sent packet. This code protects against message insertion, deletion, and modification. Protection against message replay is realized by using a sequence counter."
    },
    {
      "indent": 3,
      "text": "An iSCSI-compliant initiator or target MUST provide data authentication and integrity by implementing IPsec v2 [RFC2401] with ESPv2 [RFC2406] in tunnel mode, SHOULD provide data authentication and integrity by implementing IPsec v3 [RFC4301] with ESPv3 [RFC4303] in tunnel mode, and MAY provide data authentication and integrity by implementing either IPsec v2 or v3 with the appropriate version of ESP in transport mode. The IPsec implementation MUST fulfill the following iSCSI-specific requirements:",
      "zh-cn": "An iSCSI-compliant initiator or target MUST provide data authentication and integrity by implementing IPsec v2 [RFC2401] with ESPv2 [RFC2406] in tunnel mode, SHOULD provide data authentication and integrity by implementing IPsec v3 [RFC4301] with ESPv3 [RFC4303] in tunnel mode, and MAY provide data authentication and integrity by implementing either IPsec v2 or v3 with the appropriate version of ESP in transport mode. The IPsec implementation MUST fulfill the following iSCSI-specific requirements:"
    },
    {
      "indent": 6,
      "text": "- HMAC-SHA1 MUST be implemented in the specific form of HMAC-SHA-1-96 [RFC2404].",
      "zh-cn": "- HMAC-SHA1 MUST be implemented in the specific form of HMAC-SHA-1-96 [RFC2404]."
    },
    {
      "indent": 6,
      "text": "- AES CBC MAC with XCBC extensions using 128-bit keys SHOULD be implemented [RFC3566].",
      "zh-cn": "- AES CBC MAC with XCBC extensions using 128-bit keys SHOULD be implemented [RFC3566]."
    },
    {
      "indent": 6,
      "text": "- Implementations that support IKEv2 [RFC5996] SHOULD also implement AES Galois Message Authentication Code (GMAC) [RFC4543] using 128-bit keys.",
      "zh-cn": "- Implementations that support IKEv2 [RFC5996] SHOULD also implement AES Galois Message Authentication Code (GMAC) [RFC4543] using 128-bit keys."
    },
    {
      "indent": 3,
      "text": "The ESP anti-replay service MUST also be implemented.",
      "zh-cn": "The ESP anti-replay service MUST also be implemented."
    },
    {
      "indent": 3,
      "text": "At the high speeds at which iSCSI is expected to operate, a single IPsec SA could rapidly exhaust the ESP 32-bit sequence number space, requiring frequent rekeying of the SA, as rollover of the ESP sequence number within a single SA is prohibited for both ESPv2 [RFC2406] and ESPv3 [RFC4303]. In order to provide the means to avoid this potentially undesirable frequent rekeying, implementations that are capable of operating at speeds of 1 gigabit/second or higher MUST implement extended (64-bit) sequence numbers for ESPv2 (and ESPv3, if supported) and SHOULD use extended sequence numbers for all iSCSI traffic. Extended sequence number negotiation as part of security association establishment is specified in [RFC4304] for IKEv1 and [RFC5996] for IKEv2.",
      "zh-cn": "At the high speeds at which iSCSI is expected to operate, a single IPsec SA could rapidly exhaust the ESP 32-bit sequence number space, requiring frequent rekeying of the SA, as rollover of the ESP sequence number within a single SA is prohibited for both ESPv2 [RFC2406] and ESPv3 [RFC4303]. In order to provide the means to avoid this potentially undesirable frequent rekeying, implementations that are capable of operating at speeds of 1 gigabit/second or higher MUST implement extended (64-bit) sequence numbers for ESPv2 (and ESPv3, if supported) and SHOULD use extended sequence numbers for all iSCSI traffic. Extended sequence number negotiation as part of security association establishment is specified in [RFC4304] for IKEv1 and [RFC5996] for IKEv2."
    },
    {
      "indent": 0,
      "text": "9.3.2. Confidentiality",
      "section_title": true,
      "zh-cn": "9.3.2. Confidentiality"
    },
    {
      "indent": 3,
      "text": "Confidentiality is provided by encrypting the data in every packet. When confidentiality is used, it MUST be accompanied by data authentication and integrity to provide comprehensive protection against eavesdropping and against message insertion, deletion, modification, and replaying.",
      "zh-cn": "Confidentiality is provided by encrypting the data in every packet. When confidentiality is used, it MUST be accompanied by data authentication and integrity to provide comprehensive protection against eavesdropping and against message insertion, deletion, modification, and replaying."
    },
    {
      "indent": 3,
      "text": "An iSCSI-compliant initiator or target MUST provide confidentiality by implementing IPsec v2 [RFC2401] with ESPv2 [RFC2406] in tunnel mode, SHOULD provide confidentiality by implementing IPsec v3 [RFC4301] with ESPv3 [RFC4303] in tunnel mode, and MAY provide",
      "zh-cn": "An iSCSI-compliant initiator or target MUST provide confidentiality by implementing IPsec v2 [RFC2401] with ESPv2 [RFC2406] in tunnel mode, SHOULD provide confidentiality by implementing IPsec v3 [RFC4301] with ESPv3 [RFC4303] in tunnel mode, and MAY provide"
    },
    {
      "indent": 3,
      "text": "confidentiality by implementing either IPsec v2 or v3 with the appropriate version of ESP in transport mode, with the following iSCSI-specific requirements that apply to IPsec v2 and IPsec v3:",
      "zh-cn": "confidentiality by implementing either IPsec v2 or v3 with the appropriate version of ESP in transport mode, with the following iSCSI-specific requirements that apply to IPsec v2 and IPsec v3:"
    },
    {
      "indent": 6,
      "text": "- 3DES in CBC mode MAY be implemented [RFC2451].",
      "zh-cn": "- 3DES in CBC mode MAY be implemented [RFC2451]."
    },
    {
      "indent": 6,
      "text": "- AES in CBC mode with 128-bit keys MUST be implemented [RFC3602]; other key sizes MAY be supported.",
      "zh-cn": "- AES in CBC mode with 128-bit keys MUST be implemented [RFC3602]; other key sizes MAY be supported."
    },
    {
      "indent": 6,
      "text": "- AES in Counter mode MAY be implemented [RFC3686].",
      "zh-cn": "- AES in Counter mode MAY be implemented [RFC3686]."
    },
    {
      "indent": 6,
      "text": "- Implementations that support IKEv2 [RFC5996] SHOULD also implement AES Galois/Counter Mode (GCM) with 128-bit keys [RFC4106]; other key sizes MAY be supported.",
      "zh-cn": "- Implementations that support IKEv2 [RFC5996] SHOULD also implement AES Galois/Counter Mode (GCM) with 128-bit keys [RFC4106]; other key sizes MAY be supported."
    },
    {
      "indent": 3,
      "text": "Due to its inherent weakness, DES in CBC mode MUST NOT be used.",
      "zh-cn": "Due to its inherent weakness, DES in CBC mode MUST NOT be used."
    },
    {
      "indent": 3,
      "text": "The NULL encryption algorithm MUST also be implemented.",
      "zh-cn": "The NULL encryption algorithm MUST also be implemented."
    },
    {
      "indent": 0,
      "text": "9.3.3. Policy, Security Associations, and Cryptographic Key Management",
      "section_title": true,
      "zh-cn": "9.3.3. Policy, Security Associations, and Cryptographic Key Management"
    },
    {
      "indent": 3,
      "text": "A compliant iSCSI implementation MUST meet the cryptographic key management requirements of the IPsec protocol suite. Authentication, security association negotiation, and cryptographic key management MUST be provided by implementing IKE [RFC2409] using the IPsec DOI [RFC2407] and SHOULD be provided by implementing IKEv2 [RFC5996], with the following iSCSI-specific requirements:",
      "zh-cn": "A compliant iSCSI implementation MUST meet the cryptographic key management requirements of the IPsec protocol suite. Authentication, security association negotiation, and cryptographic key management MUST be provided by implementing IKE [RFC2409] using the IPsec DOI [RFC2407] and SHOULD be provided by implementing IKEv2 [RFC5996], with the following iSCSI-specific requirements:"
    },
    {
      "indent": 6,
      "text": "a) Peer authentication using a pre-shared cryptographic key MUST be supported. Certificate-based peer authentication using digital signatures MAY be supported. For IKEv1 ([RFC2409]), peer authentication using the public key encryption methods outlined in Sections 5.2 and 5.3 of [RFC2409] SHOULD NOT be used.",
      "zh-cn": "a) Peer authentication using a pre-shared cryptographic key MUST be supported. Certificate-based peer authentication using digital signatures MAY be supported. For IKEv1 ([RFC2409]), peer authentication using the public key encryption methods outlined in Sections 5.2 and 5.3 of [RFC2409] SHOULD NOT be used."
    },
    {
      "indent": 6,
      "text": "b) When digital signatures are used to achieve authentication, an IKE negotiator SHOULD use IKE Certificate Request Payload(s) to specify the certificate authority. IKE negotiators SHOULD check certificate validity via the pertinent Certificate Revocation List (CRL) or via the use of the Online Certificate Status Protocol (OCSP) [RFC6960] before accepting a PKI certificate for use in IKE authentication procedures. OCSP support within the IKEv2 protocol is specified in [RFC4806]. These checks may not be needed in environments where a small number of certificates are statically configured as trust anchors.",
      "zh-cn": "b) When digital signatures are used to achieve authentication, an IKE negotiator SHOULD use IKE Certificate Request Payload(s) to specify the certificate authority. IKE negotiators SHOULD check certificate validity via the pertinent Certificate Revocation List (CRL) or via the use of the Online Certificate Status Protocol (OCSP) [RFC6960] before accepting a PKI certificate for use in IKE authentication procedures. OCSP support within the IKEv2 protocol is specified in [RFC4806]. These checks may not be needed in environments where a small number of certificates are statically configured as trust anchors."
    },
    {
      "indent": 6,
      "text": "c) Conformant iSCSI implementations of IKEv1 MUST support Main Mode and SHOULD support Aggressive Mode. Main Mode with a pre-shared key authentication method SHOULD NOT be used when either the initiator or the target uses dynamically assigned addresses. While in many cases pre-shared keys offer good security, situations in which dynamically assigned addresses are used force the use of a group pre-shared key, which creates vulnerability to a man-in-the-middle attack.",
      "zh-cn": "c) Conformant iSCSI implementations of IKEv1 MUST support Main Mode and SHOULD support Aggressive Mode. Main Mode with a pre-shared key authentication method SHOULD NOT be used when either the initiator or the target uses dynamically assigned addresses. While in many cases pre-shared keys offer good security, situations in which dynamically assigned addresses are used force the use of a group pre-shared key, which creates vulnerability to a man-in-the-middle attack."
    },
    {
      "indent": 6,
      "text": "d) In the IKEv1 Phase 2 Quick Mode, in exchanges for creating the Phase 2 SA, the Identification Payload MUST be present.",
      "zh-cn": "d) In the IKEv1 Phase 2 Quick Mode, in exchanges for creating the Phase 2 SA, the Identification Payload MUST be present."
    },
    {
      "indent": 6,
      "text": "e) The following identification type requirements apply to IKEv1: ID_IPV4_ADDR, ID_IPV6_ADDR (if the protocol stack supports IPv6), and ID_FQDN Identification Types MUST be supported; ID_USER_FQDN SHOULD be supported. The IP Subnet, IP Address Range, ID_DER_ASN1_DN, and ID_DER_ASN1_GN Identification Types SHOULD NOT be used. The ID_KEY_ID Identification Type MUST NOT be used.",
      "zh-cn": "e) The following identification type requirements apply to IKEv1: ID_IPV4_ADDR, ID_IPV6_ADDR (if the protocol stack supports IPv6), and ID_FQDN Identification Types MUST be supported; ID_USER_FQDN SHOULD be supported. The IP Subnet, IP Address Range, ID_DER_ASN1_DN, and ID_DER_ASN1_GN Identification Types SHOULD NOT be used. The ID_KEY_ID Identification Type MUST NOT be used."
    },
    {
      "indent": 6,
      "text": "f) If IKEv2 is supported, the following identification requirements apply: ID_IPV4_ADDR, ID_IPV6_ADDR (if the protocol stack supports IPv6), and ID_FQDN Identification Types MUST be supported; ID_RFC822_ADDR SHOULD be supported. The ID_DER_ASN1_DN and ID_DER_ASN1_GN Identification Types SHOULD NOT be used. The ID_KEY_ID Identification Type MUST NOT be used.",
      "zh-cn": "f) If IKEv2 is supported, the following identification requirements apply: ID_IPV4_ADDR, ID_IPV6_ADDR (if the protocol stack supports IPv6), and ID_FQDN Identification Types MUST be supported; ID_RFC822_ADDR SHOULD be supported. The ID_DER_ASN1_DN and ID_DER_ASN1_GN Identification Types SHOULD NOT be used. The ID_KEY_ID Identification Type MUST NOT be used."
    },
    {
      "indent": 3,
      "text": "The reasons for the \"MUST NOT\" and \"SHOULD NOT\" for identification type requirements in preceding bullets e) and f) are:",
      "zh-cn": "The reasons for the \"MUST NOT\" and \"SHOULD NOT\" for identification type requirements in preceding bullets e) and f) are:"
    },
    {
      "indent": 6,
      "text": "- IP Subnet and IP Address Range are too broad to usefully identify an iSCSI endpoint.",
      "zh-cn": "- IP Subnet and IP Address Range are too broad to usefully identify an iSCSI endpoint."
    },
    {
      "indent": 6,
      "text": "- The DN and GN types are X.500 identities; it is usually better to use an identity from subjectAltName in a PKI certificate.",
      "zh-cn": "- The DN and GN types are X.500 identities; it is usually better to use an identity from subjectAltName in a PKI certificate."
    },
    {
      "indent": 6,
      "text": "- ID_KEY_ID is not interoperable as specified.",
      "zh-cn": "- ID_KEY_ID is not interoperable as specified."
    },
    {
      "indent": 3,
      "text": "Manual cryptographic keying MUST NOT be used, because it does not provide the necessary rekeying support.",
      "zh-cn": "Manual cryptographic keying MUST NOT be used, because it does not provide the necessary rekeying support."
    },
    {
      "indent": 3,
      "text": "When Diffie-Hellman (DH) groups are used, a DH group of at least 2048 bits SHOULD be offered as a part of all proposals to create IPsec security associations to protect iSCSI traffic, with both IKEv1 and IKEv2.",
      "zh-cn": "When Diffie-Hellman (DH) groups are used, a DH group of at least 2048 bits SHOULD be offered as a part of all proposals to create IPsec security associations to protect iSCSI traffic, with both IKEv1 and IKEv2."
    },
    {
      "indent": 3,
      "text": "When IPsec is used, the receipt of an IKEv1 Phase 2 delete message or an IKEv2 INFORMATIONAL exchange that deletes the SA SHOULD NOT be interpreted as a reason for tearing down the iSCSI TCP connection. If additional traffic is sent on it, a new IKE SA will be created to protect it.",
      "zh-cn": "When IPsec is used, the receipt of an IKEv1 Phase 2 delete message or an IKEv2 INFORMATIONAL exchange that deletes the SA SHOULD NOT be interpreted as a reason for tearing down the iSCSI TCP connection. If additional traffic is sent on it, a new IKE SA will be created to protect it."
    },
    {
      "indent": 3,
      "text": "The method used by the initiator to determine whether the target should be connected using IPsec is regarded as an issue of IPsec policy administration and thus not defined in the iSCSI standard.",
      "zh-cn": "The method used by the initiator to determine whether the target should be connected using IPsec is regarded as an issue of IPsec policy administration and thus not defined in the iSCSI standard."
    },
    {
      "indent": 3,
      "text": "The method used by an initiator that supports both IPsec v2 and v3 to determine which versions of IPsec are supported by the target is also regarded as an issue of IPsec policy administration and thus not defined in the iSCSI standard. If both IPsec v2 and v3 are supported by both the initiator and target, the use of IPsec v3 is recommended.",
      "zh-cn": "The method used by an initiator that supports both IPsec v2 and v3 to determine which versions of IPsec are supported by the target is also regarded as an issue of IPsec policy administration and thus not defined in the iSCSI standard. If both IPsec v2 and v3 are supported by both the initiator and target, the use of IPsec v3 is recommended."
    },
    {
      "indent": 3,
      "text": "If an iSCSI target is discovered via a SendTargets request in a Discovery session not using IPsec, the initiator should assume that it does not need IPsec to establish a session to that target. If an iSCSI target is discovered using a Discovery session that does use IPsec, the initiator SHOULD use IPsec when establishing a session to that target.",
      "zh-cn": "If an iSCSI target is discovered via a SendTargets request in a Discovery session not using IPsec, the initiator should assume that it does not need IPsec to establish a session to that target. If an iSCSI target is discovered using a Discovery session that does use IPsec, the initiator SHOULD use IPsec when establishing a session to that target."
    },
    {
      "indent": 0,
      "text": "9.4. Security Considerations for the X#NodeArchitecture Key",
      "section_title": true,
      "zh-cn": "9.4. Security Considerations for the X#NodeArchitecture Key"
    },
    {
      "indent": 3,
      "text": "The security considerations in this section are specific to the X#NodeArchitecture discussed in Section 13.26.",
      "zh-cn": "The security considerations in this section are specific to the X#NodeArchitecture discussed in Section 13.26."
    },
    {
      "indent": 3,
      "text": "This extension key transmits specific implementation details about the node that sends it; such details may be considered sensitive in some environments. For example, if a certain software or firmware version is known to contain security weaknesses, announcing the presence of that version via this key may not be desirable. The countermeasures for this security concern are:",
      "zh-cn": "This extension key transmits specific implementation details about the node that sends it; such details may be considered sensitive in some environments. For example, if a certain software or firmware version is known to contain security weaknesses, announcing the presence of that version via this key may not be desirable. The countermeasures for this security concern are:"
    },
    {
      "indent": 6,
      "text": "a) sending less detailed information in the key values,",
      "zh-cn": "a) sending less detailed information in the key values,"
    },
    {
      "indent": 6,
      "text": "b) not sending the extension key, or",
      "zh-cn": "b) not sending the extension key, or"
    },
    {
      "indent": 6,
      "text": "c) using IPsec ([RFC4303]) to provide confidentiality for the iSCSI connection on which the key is sent.",
      "zh-cn": "c) using IPsec ([RFC4303]) to provide confidentiality for the iSCSI connection on which the key is sent."
    },
    {
      "indent": 3,
      "text": "To support the first and second countermeasures, all implementations of this extension key MUST provide an administrative mechanism to disable sending the key. In addition, all implementations SHOULD provide an administrative mechanism to configure a verbosity level of the key value, thereby controlling the amount of information sent.",
      "zh-cn": "To support the first and second countermeasures, all implementations of this extension key MUST provide an administrative mechanism to disable sending the key. In addition, all implementations SHOULD provide an administrative mechanism to configure a verbosity level of the key value, thereby controlling the amount of information sent."
    },
    {
      "indent": 3,
      "text": "For example, a lower verbosity level might enable transmission of node architecture component names only, but no version numbers. The choice of which countermeasure is most appropriate depends on the environment. However, sending less detailed information in the key values may be an acceptable countermeasure in many environments, since it provides a compromise between sending too much information and the other more complete countermeasures of not sending the key at all or using IPsec.",
      "zh-cn": "For example, a lower verbosity level might enable transmission of node architecture component names only, but no version numbers. The choice of which countermeasure is most appropriate depends on the environment. However, sending less detailed information in the key values may be an acceptable countermeasure in many environments, since it provides a compromise between sending too much information and the other more complete countermeasures of not sending the key at all or using IPsec."
    },
    {
      "indent": 3,
      "text": "In addition to security considerations involving transmission of the key contents, any logging method(s) used for the key values MUST keep the information secure from intruders. For all implementations, the requirements to address this security concern are as follows:",
      "zh-cn": "In addition to security considerations involving transmission of the key contents, any logging method(s) used for the key values MUST keep the information secure from intruders. For all implementations, the requirements to address this security concern are as follows:"
    },
    {
      "indent": 6,
      "text": "a) Display of the log MUST only be possible with administrative rights to the node.",
      "zh-cn": "a) Display of the log MUST only be possible with administrative rights to the node."
    },
    {
      "indent": 6,
      "text": "b) Options to disable logging to disk and to keep logs for a fixed duration SHOULD be provided.",
      "zh-cn": "b) Options to disable logging to disk and to keep logs for a fixed duration SHOULD be provided."
    },
    {
      "indent": 3,
      "text": "Finally, it is important to note that different nodes may have different levels of risk, and these differences may affect the implementation. The components of risk include assets, threats, and vulnerabilities. Consider the following example iSCSI nodes, which demonstrate differences in assets and vulnerabilities of the nodes, and, as a result, differences in implementation:",
      "zh-cn": "Finally, it is important to note that different nodes may have different levels of risk, and these differences may affect the implementation. The components of risk include assets, threats, and vulnerabilities. Consider the following example iSCSI nodes, which demonstrate differences in assets and vulnerabilities of the nodes, and, as a result, differences in implementation:"
    },
    {
      "indent": 6,
      "text": "a) One iSCSI target based on a special-purpose operating system: Since the iSCSI target controls access to the data storage containing company assets, the asset level is seen as very high. Also, because of the special-purpose operating system, in which vulnerabilities are less well known, the vulnerability level is viewed as low.",
      "zh-cn": "a) One iSCSI target based on a special-purpose operating system: Since the iSCSI target controls access to the data storage containing company assets, the asset level is seen as very high. Also, because of the special-purpose operating system, in which vulnerabilities are less well known, the vulnerability level is viewed as low."
    },
    {
      "indent": 6,
      "text": "b) Multiple iSCSI initiators in a blade farm, each running a general-purpose operating system: The asset level of each node is viewed as low, since blades are replaceable and low cost. However, the vulnerability level is viewed as high, since there may be many well-known vulnerabilities to that general-purpose operating system. For this target, an appropriate implementation might be the logging of received key values but no transmission of the key. For this initiator, an appropriate implementation might be transmission of the key but no logging of received key values.",
      "zh-cn": "b) Multiple iSCSI initiators in a blade farm, each running a general-purpose operating system: The asset level of each node is viewed as low, since blades are replaceable and low cost. However, the vulnerability level is viewed as high, since there may be many well-known vulnerabilities to that general-purpose operating system. For this target, an appropriate implementation might be the logging of received key values but no transmission of the key. For this initiator, an appropriate implementation might be transmission of the key but no logging of received key values."
    },
    {
      "indent": 0,
      "text": "9.5. SCSI Access Control Considerations",
      "section_title": true,
      "zh-cn": "9.5. SCSI Access Control Considerations"
    },
    {
      "indent": 3,
      "text": "iSCSI is a SCSI transport protocol and as such does not apply any access controls on SCSI-level operations such as SCSI task management functions (e.g., LU reset; see Section 11.5.1). SCSI-level access controls (e.g., ACCESS CONTROL OUT; see [SPC3]) have to be appropriately deployed in practice to address SCSI-level security considerations, in addition to security via iSCSI connection and packet protection mechanisms that were already discussed in preceding sections.",
      "zh-cn": "iSCSI is a SCSI transport protocol and as such does not apply any access controls on SCSI-level operations such as SCSI task management functions (e.g., LU reset; see Section 11.5.1). SCSI-level access controls (e.g., ACCESS CONTROL OUT; see [SPC3]) have to be appropriately deployed in practice to address SCSI-level security considerations, in addition to security via iSCSI connection and packet protection mechanisms that were already discussed in preceding sections."
    },
    {
      "indent": 0,
      "text": "10. Notes to Implementers",
      "section_title": true,
      "zh-cn": "10. Notes to Implementers"
    },
    {
      "indent": 3,
      "text": "This section notes some of the performance and reliability considerations of the iSCSI protocol. This protocol was designed to allow efficient silicon and software implementations. The iSCSI task tag mechanism was designed to enable Direct Data Placement (DDP -- a DMA form) at the iSCSI level or lower.",
      "zh-cn": "This section notes some of the performance and reliability considerations of the iSCSI protocol. This protocol was designed to allow efficient silicon and software implementations. The iSCSI task tag mechanism was designed to enable Direct Data Placement (DDP -- a DMA form) at the iSCSI level or lower."
    },
    {
      "indent": 3,
      "text": "The guiding assumption made throughout the design of this protocol is that targets are resource constrained relative to initiators.",
      "zh-cn": "The guiding assumption made throughout the design of this protocol is that targets are resource constrained relative to initiators."
    },
    {
      "indent": 3,
      "text": "Implementers are also advised to consider the implementation consequences of the iSCSI-to-SCSI mapping model as outlined in Section 4.4.3.",
      "zh-cn": "Implementers are also advised to consider the implementation consequences of the iSCSI-to-SCSI mapping model as outlined in Section 4.4.3."
    },
    {
      "indent": 0,
      "text": "10.1. Multiple Network Adapters",
      "section_title": true,
      "zh-cn": "10.1. Multiple Network Adapters"
    },
    {
      "indent": 3,
      "text": "The iSCSI protocol allows multiple connections, not all of which need to go over the same network adapter. If multiple network connections are to be utilized with hardware support, the iSCSI protocol command-data-status allegiance to one TCP connection ensures that there is no need to replicate information across network adapters or otherwise require them to cooperate.",
      "zh-cn": "The iSCSI protocol allows multiple connections, not all of which need to go over the same network adapter. If multiple network connections are to be utilized with hardware support, the iSCSI protocol command-data-status allegiance to one TCP connection ensures that there is no need to replicate information across network adapters or otherwise require them to cooperate."
    },
    {
      "indent": 3,
      "text": "However, some task management commands may require some loose form of cooperation or replication at least on the target.",
      "zh-cn": "However, some task management commands may require some loose form of cooperation or replication at least on the target."
    },
    {
      "indent": 0,
      "text": "10.1.1. Conservative Reuse of ISIDs",
      "section_title": true,
      "zh-cn": "10.1.1. Conservative Reuse of ISIDs"
    },
    {
      "indent": 3,
      "text": "Historically, the SCSI model (and implementations and applications based on that model) has assumed that SCSI ports are static, physical entities. Recent extensions to the SCSI model have taken advantage of persistent worldwide unique names for these ports. In iSCSI, however, the SCSI initiator ports are the endpoints of dynamically created sessions, so the presumptions of \"static and physical\" do not apply. In any case, the \"model\" sections (particularly,",
      "zh-cn": "Historically, the SCSI model (and implementations and applications based on that model) has assumed that SCSI ports are static, physical entities. Recent extensions to the SCSI model have taken advantage of persistent worldwide unique names for these ports. In iSCSI, however, the SCSI initiator ports are the endpoints of dynamically created sessions, so the presumptions of \"static and physical\" do not apply. In any case, the \"model\" sections (particularly,"
    },
    {
      "indent": 3,
      "text": "Section 4.4.1) provide for persistent, reusable names for the iSCSI-type SCSI initiator ports even though there does not need to be any physical entity bound to these names.",
      "zh-cn": "Section 4.4.1) provide for persistent, reusable names for the iSCSI-type SCSI initiator ports even though there does not need to be any physical entity bound to these names."
    },
    {
      "indent": 3,
      "text": "To both minimize the disruption of legacy applications and better facilitate the SCSI features that rely on persistent names for SCSI ports, iSCSI implementations SHOULD attempt to provide a stable presentation of SCSI initiator ports (both to the upper OS layers and the targets to which they connect). This can be achieved in an initiator implementation by conservatively reusing ISIDs. In other words, the same ISID should be used in the login process to multiple target portal groups (of the same iSCSI target or different iSCSI targets). The ISID RULE (Section 4.4.3) only prohibits reuse to the same target portal group. It does not \"preclude\" reuse to other target portal groups. The principle of conservative reuse \"encourages\" reuse to other target portal groups. When a SCSI target device sees the same (InitiatorName, ISID) pair in different sessions to different target portal groups, it can identify the underlying SCSI initiator port on each session as the same SCSI port. In effect, it can recognize multiple paths from the same source.",
      "zh-cn": "To both minimize the disruption of legacy applications and better facilitate the SCSI features that rely on persistent names for SCSI ports, iSCSI implementations SHOULD attempt to provide a stable presentation of SCSI initiator ports (both to the upper OS layers and the targets to which they connect). This can be achieved in an initiator implementation by conservatively reusing ISIDs. In other words, the same ISID should be used in the login process to multiple target portal groups (of the same iSCSI target or different iSCSI targets). The ISID RULE (Section 4.4.3) only prohibits reuse to the same target portal group. It does not \"preclude\" reuse to other target portal groups. The principle of conservative reuse \"encourages\" reuse to other target portal groups. When a SCSI target device sees the same (InitiatorName, ISID) pair in different sessions to different target portal groups, it can identify the underlying SCSI initiator port on each session as the same SCSI port. In effect, it can recognize multiple paths from the same source."
    },
    {
      "indent": 0,
      "text": "10.1.2. iSCSI Name, ISID, and TPGT Use",
      "section_title": true,
      "zh-cn": "10.1.2. iSCSI Name, ISID, and TPGT Use"
    },
    {
      "indent": 3,
      "text": "The designers of the iSCSI protocol are aware that legacy SCSI transports rely on initiator identity to assign access to storage resources. Although newer techniques that simplify access control are available, support for configuration and authentication schemes that are based on initiator identity is deemed important in order to support legacy systems and administration software. iSCSI thus supports the notion that it should be possible to assign access to storage resources based on \"initiator device\" identity.",
      "zh-cn": "The designers of the iSCSI protocol are aware that legacy SCSI transports rely on initiator identity to assign access to storage resources. Although newer techniques that simplify access control are available, support for configuration and authentication schemes that are based on initiator identity is deemed important in order to support legacy systems and administration software. iSCSI thus supports the notion that it should be possible to assign access to storage resources based on \"initiator device\" identity."
    },
    {
      "indent": 3,
      "text": "When there are multiple hardware or software components coordinated as a single iSCSI node, there must be some (logical) entity that represents the iSCSI node that makes the iSCSI Node Name available to all components involved in session creation and login. Similarly, this entity that represents the iSCSI node must be able to coordinate session identifier resources (the ISID for initiators) to enforce both the ISID RULE and the TSIH RULE (see Section 4.4.3).",
      "zh-cn": "When there are multiple hardware or software components coordinated as a single iSCSI node, there must be some (logical) entity that represents the iSCSI node that makes the iSCSI Node Name available to all components involved in session creation and login. Similarly, this entity that represents the iSCSI node must be able to coordinate session identifier resources (the ISID for initiators) to enforce both the ISID RULE and the TSIH RULE (see Section 4.4.3)."
    },
    {
      "indent": 3,
      "text": "For targets, because of the closed environment, implementation of this entity should be straightforward. However, vendors of iSCSI hardware (e.g., NICs or HBAs) intended for targets SHOULD provide mechanisms for configuration of the iSCSI Node Name across the portal groups instantiated by multiple instances of these components within a target.",
      "zh-cn": "For targets, because of the closed environment, implementation of this entity should be straightforward. However, vendors of iSCSI hardware (e.g., NICs or HBAs) intended for targets SHOULD provide mechanisms for configuration of the iSCSI Node Name across the portal groups instantiated by multiple instances of these components within a target."
    },
    {
      "indent": 3,
      "text": "However, complex targets making use of multiple Target Portal Group Tags may reconfigure them to achieve various quality goals. The initiators have two mechanisms at their disposal to discover and/or check reconfiguring targets -- the Discovery session type and a key returned by the target during login to confirm the TPGT. An initiator should attempt to \"rediscover\" the target configuration whenever a session is terminated unexpectedly.",
      "zh-cn": "However, complex targets making use of multiple Target Portal Group Tags may reconfigure them to achieve various quality goals. The initiators have two mechanisms at their disposal to discover and/or check reconfiguring targets -- the Discovery session type and a key returned by the target during login to confirm the TPGT. An initiator should attempt to \"rediscover\" the target configuration whenever a session is terminated unexpectedly."
    },
    {
      "indent": 3,
      "text": "For initiators, in the long term, it is expected that operating system vendors will take on the role of this entity and provide standard APIs that can inform components of their iSCSI Node Name and can configure and/or coordinate ISID allocation, use, and reuse.",
      "zh-cn": "For initiators, in the long term, it is expected that operating system vendors will take on the role of this entity and provide standard APIs that can inform components of their iSCSI Node Name and can configure and/or coordinate ISID allocation, use, and reuse."
    },
    {
      "indent": 3,
      "text": "Recognizing that such initiator APIs are not available today, other implementations of the role of this entity are possible. For example, a human may instantiate the (common) node name as part of the installation process of each iSCSI component involved in session creation and login. This may be done by pointing the component to either a vendor-specific location for this datum or a system-wide location. The structure of the ISID namespace (see Section 11.12.5 and [RFC3721]) facilitates implementation of the ISID coordination by allowing each component vendor to independently (of other vendor's components) coordinate allocation, use, and reuse of its own partition of the ISID namespace in a vendor-specific manner. Partitioning of the ISID namespace within initiator portal groups managed by that vendor allows each such initiator portal group to act independently of all other portal groups when selecting an ISID for a login; this facilitates enforcement of the ISID RULE (see Section 4.4.3) at the initiator.",
      "zh-cn": "Recognizing that such initiator APIs are not available today, other implementations of the role of this entity are possible. For example, a human may instantiate the (common) node name as part of the installation process of each iSCSI component involved in session creation and login. This may be done by pointing the component to either a vendor-specific location for this datum or a system-wide location. The structure of the ISID namespace (see Section 11.12.5 and [RFC3721]) facilitates implementation of the ISID coordination by allowing each component vendor to independently (of other vendor's components) coordinate allocation, use, and reuse of its own partition of the ISID namespace in a vendor-specific manner. Partitioning of the ISID namespace within initiator portal groups managed by that vendor allows each such initiator portal group to act independently of all other portal groups when selecting an ISID for a login; this facilitates enforcement of the ISID RULE (see Section 4.4.3) at the initiator."
    },
    {
      "indent": 3,
      "text": "A vendor of iSCSI hardware (e.g., NICs or HBAs) intended for use in initiators MUST implement a mechanism for configuring the iSCSI Node Name. Vendors and administrators must ensure that iSCSI Node Names are worldwide unique. It is therefore important that when one chooses to reuse the iSCSI Node Name of a disabled unit one does not reassign that name to the original unit unless its worldwide uniqueness can be ascertained again.",
      "zh-cn": "A vendor of iSCSI hardware (e.g., NICs or HBAs) intended for use in initiators MUST implement a mechanism for configuring the iSCSI Node Name. Vendors and administrators must ensure that iSCSI Node Names are worldwide unique. It is therefore important that when one chooses to reuse the iSCSI Node Name of a disabled unit one does not reassign that name to the original unit unless its worldwide uniqueness can be ascertained again."
    },
    {
      "indent": 3,
      "text": "In addition, a vendor of iSCSI hardware must implement a mechanism to configure and/or coordinate ISIDs for all sessions managed by multiple instances of that hardware within a given iSCSI node. Such configuration might be either permanently preassigned at the factory (in a necessarily globally unique way), statically assigned (e.g., partitioned across all the NICs at initialization in a locally unique way), or dynamically assigned (e.g., on-line allocator, also in a locally unique way). In the latter two cases, the configuration may",
      "zh-cn": "In addition, a vendor of iSCSI hardware must implement a mechanism to configure and/or coordinate ISIDs for all sessions managed by multiple instances of that hardware within a given iSCSI node. Such configuration might be either permanently preassigned at the factory (in a necessarily globally unique way), statically assigned (e.g., partitioned across all the NICs at initialization in a locally unique way), or dynamically assigned (e.g., on-line allocator, also in a locally unique way). In the latter two cases, the configuration may"
    },
    {
      "indent": 3,
      "text": "be via public APIs (perhaps driven by an independent vendor's software, such as the OS vendor) or private APIs driven by the vendor's own software.",
      "zh-cn": "be via public APIs (perhaps driven by an independent vendor's software, such as the OS vendor) or private APIs driven by the vendor's own software."
    },
    {
      "indent": 3,
      "text": "The process of name assignment and coordination has to be as encompassing and automated as possible, as years of legacy usage have shown that it is highly error-prone. It should be mentioned that today SCSI has alternative schemes of access control that can be used by all transports, and their security is not dependent on strict naming coordination.",
      "zh-cn": "The process of name assignment and coordination has to be as encompassing and automated as possible, as years of legacy usage have shown that it is highly error-prone. It should be mentioned that today SCSI has alternative schemes of access control that can be used by all transports, and their security is not dependent on strict naming coordination."
    },
    {
      "indent": 0,
      "text": "10.2. Autosense and Auto Contingent Allegiance (ACA)",
      "section_title": true,
      "zh-cn": "10.2. Autosense and Auto Contingent Allegiance (ACA)"
    },
    {
      "indent": 3,
      "text": "\"Autosense\" refers to the automatic return of sense data to the initiator in cases where a command did not complete successfully. iSCSI initiators and targets MUST support and use Autosense.",
      "zh-cn": "\"Autosense\" refers to the automatic return of sense data to the initiator in cases where a command did not complete successfully. iSCSI initiators and targets MUST support and use Autosense."
    },
    {
      "indent": 3,
      "text": "ACA helps preserve ordered command execution in the presence of errors. As there can be many commands in-flight between an initiator and a target, SCSI initiator functionality in some operating systems depends on ACA to enforce ordered command execution during error recovery, and hence iSCSI initiator implementations for those operating systems need to support ACA. In order to support error recovery for these operating systems and iSCSI initiators, iSCSI targets SHOULD support ACA.",
      "zh-cn": "ACA helps preserve ordered command execution in the presence of errors. As there can be many commands in-flight between an initiator and a target, SCSI initiator functionality in some operating systems depends on ACA to enforce ordered command execution during error recovery, and hence iSCSI initiator implementations for those operating systems need to support ACA. In order to support error recovery for these operating systems and iSCSI initiators, iSCSI targets SHOULD support ACA."
    },
    {
      "indent": 0,
      "text": "10.3. iSCSI Timeouts",
      "section_title": true,
      "zh-cn": "10.3. iSCSI Timeouts"
    },
    {
      "indent": 3,
      "text": "iSCSI recovery actions are often dependent on iSCSI timeouts being recognized and acted upon before SCSI timeouts. Determining the right timeouts to use for various iSCSI actions (command acknowledgments expected, status acknowledgments, etc.) is very much dependent on infrastructure (e.g., hardware, links, TCP/IP stack, iSCSI driver). As a guide, the implementer may use an average NOP-Out/NOP-In turnaround delay multiplied by a \"safety factor\" (e.g., 4) as a good estimate for the basic delay of the iSCSI stack for a given connection. The safety factor should account for network load variability. For connection teardown, the implementer may want to also consider TCP common practice for the given infrastructure.",
      "zh-cn": "iSCSI recovery actions are often dependent on iSCSI timeouts being recognized and acted upon before SCSI timeouts. Determining the right timeouts to use for various iSCSI actions (command acknowledgments expected, status acknowledgments, etc.) is very much dependent on infrastructure (e.g., hardware, links, TCP/IP stack, iSCSI driver). As a guide, the implementer may use an average NOP-Out/NOP-In turnaround delay multiplied by a \"safety factor\" (e.g., 4) as a good estimate for the basic delay of the iSCSI stack for a given connection. The safety factor should account for network load variability. For connection teardown, the implementer may want to also consider TCP common practice for the given infrastructure."
    },
    {
      "indent": 3,
      "text": "Text negotiations MAY also be subject to either time limits or limits in the number of exchanges. Those limits SHOULD be generous enough to avoid affecting interoperability (e.g., allowing each key to be negotiated on a separate exchange).",
      "zh-cn": "Text negotiations MAY also be subject to either time limits or limits in the number of exchanges. Those limits SHOULD be generous enough to avoid affecting interoperability (e.g., allowing each key to be negotiated on a separate exchange)."
    },
    {
      "indent": 3,
      "text": "The relationship between iSCSI timeouts and SCSI timeouts should also be considered. SCSI timeouts should be longer than iSCSI timeouts plus the time required for iSCSI recovery whenever iSCSI recovery is",
      "zh-cn": "The relationship between iSCSI timeouts and SCSI timeouts should also be considered. SCSI timeouts should be longer than iSCSI timeouts plus the time required for iSCSI recovery whenever iSCSI recovery is"
    },
    {
      "indent": 3,
      "text": "planned. Alternatively, an implementer may choose to interlock iSCSI timeouts and recovery with SCSI timeouts so that SCSI recovery will become active only where iSCSI is not planned to, or failed to, recover.",
      "zh-cn": "planned. Alternatively, an implementer may choose to interlock iSCSI timeouts and recovery with SCSI timeouts so that SCSI recovery will become active only where iSCSI is not planned to, or failed to, recover."
    },
    {
      "indent": 3,
      "text": "The implementer may also want to consider the interaction between various iSCSI exception events -- such as a digest failure -- and subsequent timeouts. When iSCSI error recovery is active, a digest failure is likely to result in discovering a missing command or data PDU. In these cases, an implementer may want to lower the timeout values to enable faster initiation for recovery procedures.",
      "zh-cn": "The implementer may also want to consider the interaction between various iSCSI exception events -- such as a digest failure -- and subsequent timeouts. When iSCSI error recovery is active, a digest failure is likely to result in discovering a missing command or data PDU. In these cases, an implementer may want to lower the timeout values to enable faster initiation for recovery procedures."
    },
    {
      "indent": 0,
      "text": "10.4. Command Retry and Cleaning Old Command Instances",
      "section_title": true,
      "zh-cn": "10.4. Command Retry and Cleaning Old Command Instances"
    },
    {
      "indent": 3,
      "text": "To avoid having old, retried command instances appear in a valid command window after a command sequence number wraparound, the protocol requires (see Section 4.2.2.1) that on every connection on which a retry has been issued a non-immediate command be issued and acknowledged within an interval of 2**31 - 1 commands from the CmdSN of the retried command. This requirement can be fulfilled by an implementation in several ways.",
      "zh-cn": "To avoid having old, retried command instances appear in a valid command window after a command sequence number wraparound, the protocol requires (see Section 4.2.2.1) that on every connection on which a retry has been issued a non-immediate command be issued and acknowledged within an interval of 2**31 - 1 commands from the CmdSN of the retried command. This requirement can be fulfilled by an implementation in several ways."
    },
    {
      "indent": 3,
      "text": "The simplest technique to use is to send a (non-retry) non-immediate SCSI command (or a NOP if no SCSI command is available for a while) after every command retry on the connection on which the retry was attempted. Because errors are deemed rare events, this technique is probably the most effective, as it does not involve additional checks at the initiator when issuing commands.",
      "zh-cn": "The simplest technique to use is to send a (non-retry) non-immediate SCSI command (or a NOP if no SCSI command is available for a while) after every command retry on the connection on which the retry was attempted. Because errors are deemed rare events, this technique is probably the most effective, as it does not involve additional checks at the initiator when issuing commands."
    },
    {
      "indent": 0,
      "text": "10.5. Sync and Steering Layer, and Performance",
      "section_title": true,
      "zh-cn": "10.5. Sync and Steering Layer, and Performance"
    },
    {
      "indent": 3,
      "text": "While a Sync and Steering layer is optional, an initiator/target that does not have it working against a target/initiator that demands sync and steering may experience performance degradation caused by packet reordering and loss. Providing a sync and steering mechanism is recommended for all high-speed implementations.",
      "zh-cn": "While a Sync and Steering layer is optional, an initiator/target that does not have it working against a target/initiator that demands sync and steering may experience performance degradation caused by packet reordering and loss. Providing a sync and steering mechanism is recommended for all high-speed implementations."
    },
    {
      "indent": 0,
      "text": "10.6. Considerations for State-Dependent Devices and Long-Lasting SCSI Operations",
      "zh-cn": "10.6. Considerations for State-Dependent Devices and Long-Lasting SCSI Operations"
    },
    {
      "indent": 3,
      "text": "Sequential access devices operate on the principle that the position of the device is based on the last command processed. As such, command processing order, and knowledge of whether or not the previous command was processed, are of the utmost importance to maintain data integrity. For example, inadvertent retries of SCSI commands when it is not known if the previous SCSI command was processed is a potential data integrity risk.",
      "zh-cn": "Sequential access devices operate on the principle that the position of the device is based on the last command processed. As such, command processing order, and knowledge of whether or not the previous command was processed, are of the utmost importance to maintain data integrity. For example, inadvertent retries of SCSI commands when it is not known if the previous SCSI command was processed is a potential data integrity risk."
    },
    {
      "indent": 3,
      "text": "For a sequential access device, consider the scenario in which a SCSI SPACE command to backspace one filemark is issued and then reissued due to no status received for the command. If the first SPACE command was actually processed, the reissued SPACE command, if processed, will cause the position to change. Thus, a subsequent write operation will write data to the wrong position, and any previous data at that position will be overwritten.",
      "zh-cn": "For a sequential access device, consider the scenario in which a SCSI SPACE command to backspace one filemark is issued and then reissued due to no status received for the command. If the first SPACE command was actually processed, the reissued SPACE command, if processed, will cause the position to change. Thus, a subsequent write operation will write data to the wrong position, and any previous data at that position will be overwritten."
    },
    {
      "indent": 3,
      "text": "For a medium changer device, consider the scenario in which an EXCHANGE MEDIUM command (the SOURCE ADDRESS and DESTINATION ADDRESS are the same, thus performing a swap) is issued and then reissued due to no status received for the command. If the first EXCHANGE MEDIUM command was actually processed, the reissued EXCHANGE MEDIUM command, if processed, will perform the swap again. The net effect is that no swap was performed, thus putting data integrity at risk.",
      "zh-cn": "For a medium changer device, consider the scenario in which an EXCHANGE MEDIUM command (the SOURCE ADDRESS and DESTINATION ADDRESS are the same, thus performing a swap) is issued and then reissued due to no status received for the command. If the first EXCHANGE MEDIUM command was actually processed, the reissued EXCHANGE MEDIUM command, if processed, will perform the swap again. The net effect is that no swap was performed, thus putting data integrity at risk."
    },
    {
      "indent": 3,
      "text": "All commands that change the state of the device (e.g., SPACE commands for sequential access devices and EXCHANGE MEDIUM commands for medium changer devices) MUST be issued as non-immediate commands for deterministic and ordered delivery to iSCSI targets.",
      "zh-cn": "All commands that change the state of the device (e.g., SPACE commands for sequential access devices and EXCHANGE MEDIUM commands for medium changer devices) MUST be issued as non-immediate commands for deterministic and ordered delivery to iSCSI targets."
    },
    {
      "indent": 3,
      "text": "For many of those state-changing commands, the execution model also assumes that the command is executed exactly once. Devices implementing READ POSITION and LOCATE provide a means for SCSI-level command recovery, and new tape-class devices should support those commands. In their absence, a retry at the SCSI level is difficult, and error recovery at the iSCSI level is advisable.",
      "zh-cn": "For many of those state-changing commands, the execution model also assumes that the command is executed exactly once. Devices implementing READ POSITION and LOCATE provide a means for SCSI-level command recovery, and new tape-class devices should support those commands. In their absence, a retry at the SCSI level is difficult, and error recovery at the iSCSI level is advisable."
    },
    {
      "indent": 3,
      "text": "Devices operating on long-latency delivery subsystems and performing long-lasting SCSI operations may need mechanisms that enable connection replacement while commands are running (e.g., during an extended copy operation).",
      "zh-cn": "Devices operating on long-latency delivery subsystems and performing long-lasting SCSI operations may need mechanisms that enable connection replacement while commands are running (e.g., during an extended copy operation)."
    },
    {
      "indent": 0,
      "text": "10.6.1. Determining the Proper ErrorRecoveryLevel",
      "section_title": true,
      "zh-cn": "10.6.1. Determining the Proper ErrorRecoveryLevel"
    },
    {
      "indent": 3,
      "text": "The implementation and use of a specific ErrorRecoveryLevel should be determined based on the deployment scenarios of a given iSCSI implementation. Generally, the following factors must be considered before deciding on the proper level of recovery:",
      "zh-cn": "The implementation and use of a specific ErrorRecoveryLevel should be determined based on the deployment scenarios of a given iSCSI implementation. Generally, the following factors must be considered before deciding on the proper level of recovery:"
    },
    {
      "indent": 6,
      "text": "a) Application resilience to I/O failures.",
      "zh-cn": "a) Application resilience to I/O failures."
    },
    {
      "indent": 6,
      "text": "b) Required level of availability in the face of transport connection failures.",
      "zh-cn": "b) Required level of availability in the face of transport connection failures."
    },
    {
      "indent": 6,
      "text": "c) Probability of transport-layer \"checksum escape\" (message error undetected by TCP checksum -- see [RFC3385] for related discussion). This in turn decides the iSCSI digest failure frequency and thus the criticality of iSCSI-level error recovery. The details of estimating this probability are outside the scope of this document.",
      "zh-cn": "c) Probability of transport-layer \"checksum escape\" (message error undetected by TCP checksum -- see [RFC3385] for related discussion). This in turn decides the iSCSI digest failure frequency and thus the criticality of iSCSI-level error recovery. The details of estimating this probability are outside the scope of this document."
    },
    {
      "indent": 3,
      "text": "A consideration of the above factors for SCSI tape devices as an example suggests that implementations SHOULD use ErrorRecoveryLevel=1 when transport connection failure is not a concern and SCSI-level recovery is unavailable, and ErrorRecoveryLevel=2 when there is a high likelihood of connection failure during a backup/retrieval.",
      "zh-cn": "A consideration of the above factors for SCSI tape devices as an example suggests that implementations SHOULD use ErrorRecoveryLevel=1 when transport connection failure is not a concern and SCSI-level recovery is unavailable, and ErrorRecoveryLevel=2 when there is a high likelihood of connection failure during a backup/retrieval."
    },
    {
      "indent": 3,
      "text": "For extended copy operations, implementations SHOULD use ErrorRecoveryLevel=2 whenever there is a relatively high likelihood of connection failure.",
      "zh-cn": "For extended copy operations, implementations SHOULD use ErrorRecoveryLevel=2 whenever there is a relatively high likelihood of connection failure."
    },
    {
      "indent": 0,
      "text": "10.7. Multi-Task Abort Implementation Considerations",
      "section_title": true,
      "zh-cn": "10.7. Multi-Task Abort Implementation Considerations"
    },
    {
      "indent": 3,
      "text": "Multi-task abort operations are typically issued in emergencies, such as clearing a device lock-up, HA failover/failback, etc. In these circumstances, it is desirable to rapidly go through the error-handling process as opposed to the target waiting on multiple third-party initiators that may not even be functional anymore -- especially if this emergency is triggered because of one such initiator failure. Therefore, both iSCSI target and initiator implementations SHOULD support FastAbort multi-task abort semantics (Section 4.2.3.4).",
      "zh-cn": "Multi-task abort operations are typically issued in emergencies, such as clearing a device lock-up, HA failover/failback, etc. In these circumstances, it is desirable to rapidly go through the error-handling process as opposed to the target waiting on multiple third-party initiators that may not even be functional anymore -- especially if this emergency is triggered because of one such initiator failure. Therefore, both iSCSI target and initiator implementations SHOULD support FastAbort multi-task abort semantics (Section 4.2.3.4)."
    },
    {
      "indent": 3,
      "text": "Note that in both standard semantics (Section 4.2.3.3) and FastAbort semantics (Section 4.2.3.4) there may be outstanding data transfers even after the TMF completion is reported on the issuing session. In the case of iSCSI/iSER [RFC7145], these would be tagged data transfers for STags not owned by any active tasks. Whether or not real buffers support these data transfers is implementation dependent. However, the data transfers logically MUST be silently discarded by the target iSCSI layer in all cases. A target MAY, on an implementation-defined internal timeout, also choose to drop the connections on which it did not receive the expected Data-Out sequences (Section 4.2.3.3) or NOP-Out acknowledgments (Section 4.2.3.4) so as to reclaim the associated buffer, STag, and TTT resources as appropriate.",
      "zh-cn": "Note that in both standard semantics (Section 4.2.3.3) and FastAbort semantics (Section 4.2.3.4) there may be outstanding data transfers even after the TMF completion is reported on the issuing session. In the case of iSCSI/iSER [RFC7145], these would be tagged data transfers for STags not owned by any active tasks. Whether or not real buffers support these data transfers is implementation dependent. However, the data transfers logically MUST be silently discarded by the target iSCSI layer in all cases. A target MAY, on an implementation-defined internal timeout, also choose to drop the connections on which it did not receive the expected Data-Out sequences (Section 4.2.3.3) or NOP-Out acknowledgments (Section 4.2.3.4) so as to reclaim the associated buffer, STag, and TTT resources as appropriate."
    },
    {
      "indent": 0,
      "text": "11. iSCSI PDU Formats",
      "section_title": true,
      "zh-cn": "11. iSCSI PDU Formats"
    },
    {
      "indent": 3,
      "text": "All multi-byte integers that are specified in formats defined in this document are to be represented in network byte order (i.e., big-endian). Any field that appears in this document assumes that the most significant byte is the lowest numbered byte and the most significant bit (within byte or field) is the lowest numbered bit unless specified otherwise.",
      "zh-cn": "All multi-byte integers that are specified in formats defined in this document are to be represented in network byte order (i.e., big-endian). Any field that appears in this document assumes that the most significant byte is the lowest numbered byte and the most significant bit (within byte or field) is the lowest numbered bit unless specified otherwise."
    },
    {
      "indent": 3,
      "text": "Any compliant sender MUST set all bits not defined and all reserved fields to 0, unless specified otherwise. Any compliant receiver MUST ignore any bit not defined and all reserved fields unless specified otherwise. Receipt of reserved code values in defined fields MUST be reported as a protocol error.",
      "zh-cn": "Any compliant sender MUST set all bits not defined and all reserved fields to 0, unless specified otherwise. Any compliant receiver MUST ignore any bit not defined and all reserved fields unless specified otherwise. Receipt of reserved code values in defined fields MUST be reported as a protocol error."
    },
    {
      "indent": 3,
      "text": "Reserved fields are marked by the word \"reserved\", some abbreviation of \"reserved\", or by \".\" for individual bits when no other form of marking is technically feasible.",
      "zh-cn": "Reserved fields are marked by the word \"reserved\", some abbreviation of \"reserved\", or by \".\" for individual bits when no other form of marking is technically feasible."
    },
    {
      "indent": 0,
      "text": "11.1. iSCSI PDU Length and Padding",
      "section_title": true,
      "zh-cn": "11.1. iSCSI PDU Length and Padding"
    },
    {
      "indent": 3,
      "text": "iSCSI PDUs are padded to the closest integer number of 4-byte words. The padding bytes SHOULD be sent as 0.",
      "zh-cn": "iSCSI PDUs are padded to the closest integer number of 4-byte words. The padding bytes SHOULD be sent as 0."
    },
    {
      "indent": 0,
      "text": "11.2. PDU Template, Header, and Opcodes",
      "section_title": true,
      "zh-cn": "11.2. PDU Template, Header, and Opcodes"
    },
    {
      "indent": 3,
      "text": "All iSCSI PDUs have one or more header segments and, optionally, a data segment. After the entire header segment group, a header digest MAY follow. The data segment MAY also be followed by a data digest.",
      "zh-cn": "All iSCSI PDUs have one or more header segments and, optionally, a data segment. After the entire header segment group, a header digest MAY follow. The data segment MAY also be followed by a data digest."
    },
    {
      "indent": 3,
      "text": "The Basic Header Segment (BHS) is the first segment in all of the iSCSI PDUs. The BHS is a fixed-length 48-byte header segment. It MAY be followed by Additional Header Segments (AHS), a Header-Digest, a Data Segment, and/or a Data-Digest.",
      "zh-cn": "The Basic Header Segment (BHS) is the first segment in all of the iSCSI PDUs. The BHS is a fixed-length 48-byte header segment. It MAY be followed by Additional Header Segments (AHS), a Header-Digest, a Data Segment, and/or a Data-Digest."
    },
    {
      "indent": 3,
      "text": "The overall structure of an iSCSI PDU is as follows:",
      "zh-cn": "The overall structure of an iSCSI PDU is as follows:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0/ Basic Header Segment (BHS)                                    /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48/ Additional Header Segment 1 (AHS) (optional)                  /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  / Additional Header Segment 2 (AHS) (optional)                  /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  +---------------+---------------+---------------+---------------+\n  / Additional Header Segment n (AHS) (optional)                  /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n k/ Header-Digest (optional)                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n l/ Data Segment (optional)                                       /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n m/ Data-Digest (optional)                                        /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "All PDU segments and digests are padded to the closest integer number of 4-byte words. For example, all PDU segments and digests start at a 4-byte word boundary, and the padding ranges from 0 to 3 bytes. The padding bytes SHOULD be sent as 0.",
      "zh-cn": "All PDU segments and digests are padded to the closest integer number of 4-byte words. For example, all PDU segments and digests start at a 4-byte word boundary, and the padding ranges from 0 to 3 bytes. The padding bytes SHOULD be sent as 0."
    },
    {
      "indent": 3,
      "text": "iSCSI Response PDUs do not have AH Segments.",
      "zh-cn": "iSCSI Response PDUs do not have AH Segments."
    },
    {
      "indent": 0,
      "text": "11.2.1. Basic Header Segment (BHS)",
      "section_title": true,
      "zh-cn": "11.2.1. Basic Header Segment (BHS)"
    },
    {
      "indent": 3,
      "text": "The BHS is 48 bytes long. The Opcode and DataSegmentLength fields appear in all iSCSI PDUs. In addition, when used, the Initiator Task Tag and Logical Unit Number always appear in the same location in the header.",
      "zh-cn": "The BHS is 48 bytes long. The Opcode and DataSegmentLength fields appear in all iSCSI PDUs. In addition, when used, the Initiator Task Tag and Logical Unit Number always appear in the same location in the header."
    },
    {
      "indent": 3,
      "text": "The format of the BHS is:",
      "zh-cn": "The format of the BHS is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| Opcode    |F| Opcode-specific fields                      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Opcode-specific fields                                 |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20/ Opcode-specific fields                                        /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.2.1.1. I (Immediate) Bit",
      "section_title": true,
      "zh-cn": "11.2.1.1. I (Immediate) Bit"
    },
    {
      "indent": 3,
      "text": "For Request PDUs, the I bit set to 1 is an immediate delivery marker.",
      "zh-cn": "For Request PDUs, the I bit set to 1 is an immediate delivery marker."
    },
    {
      "indent": 0,
      "text": "11.2.1.2. Opcode",
      "section_title": true,
      "zh-cn": "11.2.1.2. Opcode"
    },
    {
      "indent": 3,
      "text": "The Opcode indicates the type of iSCSI PDU the header encapsulates.",
      "zh-cn": "The Opcode indicates the type of iSCSI PDU the header encapsulates."
    },
    {
      "indent": 3,
      "text": "The Opcodes are divided into two categories: initiator Opcodes and target Opcodes. Initiator Opcodes are in PDUs sent by the initiator (Request PDUs). Target Opcodes are in PDUs sent by the target (Response PDUs).",
      "zh-cn": "The Opcodes are divided into two categories: initiator Opcodes and target Opcodes. Initiator Opcodes are in PDUs sent by the initiator (Request PDUs). Target Opcodes are in PDUs sent by the target (Response PDUs)."
    },
    {
      "indent": 3,
      "text": "Initiators MUST NOT use target Opcodes, and targets MUST NOT use initiator Opcodes.",
      "zh-cn": "Initiators MUST NOT use target Opcodes, and targets MUST NOT use initiator Opcodes."
    },
    {
      "indent": 3,
      "text": "Initiator Opcodes defined in this specification are:",
      "zh-cn": "Initiator Opcodes defined in this specification are:"
    },
    {
      "indent": 6,
      "text": "0x00 NOP-Out",
      "zh-cn": "0x00 NOP-Out"
    },
    {
      "indent": 6,
      "text": "0x01 SCSI Command (encapsulates a SCSI Command Descriptor Block)",
      "zh-cn": "0x01 SCSI Command (encapsulates a SCSI Command Descriptor Block)"
    },
    {
      "indent": 6,
      "text": "0x02 SCSI Task Management Function Request",
      "zh-cn": "0x02 SCSI Task Management Function Request"
    },
    {
      "indent": 6,
      "text": "0x03 Login Request",
      "zh-cn": "0x03 Login Request"
    },
    {
      "indent": 6,
      "text": "0x04 Text Request",
      "zh-cn": "0x04 Text Request"
    },
    {
      "indent": 6,
      "text": "0x05 SCSI Data-Out (for write operations)",
      "zh-cn": "0x05 SCSI Data-Out (for write operations)"
    },
    {
      "indent": 6,
      "text": "0x06 Logout Request",
      "zh-cn": "0x06 Logout Request"
    },
    {
      "indent": 6,
      "text": "0x10 SNACK Request",
      "zh-cn": "0x10 SNACK Request"
    },
    {
      "indent": 6,
      "text": "0x1c-0x1e Vendor-specific codes",
      "zh-cn": "0x1c-0x1e Vendor-specific codes"
    },
    {
      "indent": 3,
      "text": "Target Opcodes are:",
      "zh-cn": "Target Opcodes are:"
    },
    {
      "indent": 6,
      "text": "0x20 NOP-In",
      "zh-cn": "0x20 NOP-In"
    },
    {
      "indent": 6,
      "text": "0x21 SCSI Response - contains SCSI status and possibly sense information or other response information",
      "zh-cn": "0x21 SCSI Response - contains SCSI status and possibly sense information or other response information"
    },
    {
      "indent": 6,
      "text": "0x22 SCSI Task Management Function Response",
      "zh-cn": "0x22 SCSI Task Management Function Response"
    },
    {
      "indent": 6,
      "text": "0x23 Login Response",
      "zh-cn": "0x23 Login Response"
    },
    {
      "indent": 6,
      "text": "0x24 Text Response",
      "zh-cn": "0x24 Text Response"
    },
    {
      "indent": 6,
      "text": "0x25 SCSI Data-In (for read operations)",
      "zh-cn": "0x25 SCSI Data-In (for read operations)"
    },
    {
      "indent": 6,
      "text": "0x26 Logout Response",
      "zh-cn": "0x26 Logout Response"
    },
    {
      "indent": 6,
      "text": "0x31 Ready To Transfer (R2T) - sent by target when it is ready to receive data",
      "zh-cn": "0x31 Ready To Transfer (R2T) - sent by target when it is ready to receive data"
    },
    {
      "indent": 6,
      "text": "0x32 Asynchronous Message - sent by target to indicate certain special conditions",
      "zh-cn": "0x32 Asynchronous Message - sent by target to indicate certain special conditions"
    },
    {
      "indent": 6,
      "text": "0x3c-0x3e Vendor-specific codes",
      "zh-cn": "0x3c-0x3e Vendor-specific codes"
    },
    {
      "indent": 6,
      "text": "0x3f Reject",
      "zh-cn": "0x3f Reject"
    },
    {
      "indent": 3,
      "text": "All other Opcodes are unassigned.",
      "zh-cn": "All other Opcodes are unassigned."
    },
    {
      "indent": 0,
      "text": "11.2.1.3. F (Final) Bit",
      "section_title": true,
      "zh-cn": "11.2.1.3. F (Final) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1 it indicates the final (or only) PDU of a sequence.",
      "zh-cn": "When set to 1 it indicates the final (or only) PDU of a sequence."
    },
    {
      "indent": 0,
      "text": "11.2.1.4. Opcode-Specific Fields",
      "section_title": true,
      "zh-cn": "11.2.1.4. Opcode-Specific Fields"
    },
    {
      "indent": 3,
      "text": "These fields have different meanings for different Opcode types.",
      "zh-cn": "These fields have different meanings for different Opcode types."
    },
    {
      "indent": 0,
      "text": "11.2.1.5. TotalAHSLength",
      "section_title": true,
      "zh-cn": "11.2.1.5. TotalAHSLength"
    },
    {
      "indent": 3,
      "text": "This is the total length of all AHS header segments in units of 4-byte words, including padding, if any.",
      "zh-cn": "This is the total length of all AHS header segments in units of 4-byte words, including padding, if any."
    },
    {
      "indent": 3,
      "text": "The TotalAHSLength is only used in PDUs that have an AHS and MUST be 0 in all other PDUs.",
      "zh-cn": "The TotalAHSLength is only used in PDUs that have an AHS and MUST be 0 in all other PDUs."
    },
    {
      "indent": 0,
      "text": "11.2.1.6. DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.2.1.6. DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "This is the data segment payload length in bytes (excluding padding). The DataSegmentLength MUST be 0 whenever the PDU has no data segment.",
      "zh-cn": "This is the data segment payload length in bytes (excluding padding). The DataSegmentLength MUST be 0 whenever the PDU has no data segment."
    },
    {
      "indent": 0,
      "text": "11.2.1.7. LUN",
      "section_title": true,
      "zh-cn": "11.2.1.7. LUN"
    },
    {
      "indent": 3,
      "text": "Some Opcodes operate on a specific LU. The Logical Unit Number (LUN) field identifies which LU. If the Opcode does not relate to a LU, this field is either ignored or may be used in an Opcode-specific way. The LUN field is 64 bits and should be formatted in accordance with [SAM2]. For example, LUN[0] from [SAM2] is BHS byte 8 and so on up to LUN[7] from [SAM2], which is BHS byte 15.",
      "zh-cn": "Some Opcodes operate on a specific LU. The Logical Unit Number (LUN) field identifies which LU. If the Opcode does not relate to a LU, this field is either ignored or may be used in an Opcode-specific way. The LUN field is 64 bits and should be formatted in accordance with [SAM2]. For example, LUN[0] from [SAM2] is BHS byte 8 and so on up to LUN[7] from [SAM2], which is BHS byte 15."
    },
    {
      "indent": 0,
      "text": "11.2.1.8. Initiator Task Tag",
      "section_title": true,
      "zh-cn": "11.2.1.8. Initiator Task Tag"
    },
    {
      "indent": 3,
      "text": "The initiator assigns a task tag to each iSCSI task it issues. While a task exists, this tag MUST uniquely identify the task session-wide. SCSI may also use the Initiator Task Tag as part of the SCSI task identifier when the timespan during which an iSCSI Initiator Task Tag must be unique extends over the timespan during which a SCSI task tag must be unique. However, the iSCSI Initiator Task Tag must exist and be unique even for untagged SCSI commands.",
      "zh-cn": "The initiator assigns a task tag to each iSCSI task it issues. While a task exists, this tag MUST uniquely identify the task session-wide. SCSI may also use the Initiator Task Tag as part of the SCSI task identifier when the timespan during which an iSCSI Initiator Task Tag must be unique extends over the timespan during which a SCSI task tag must be unique. However, the iSCSI Initiator Task Tag must exist and be unique even for untagged SCSI commands."
    },
    {
      "indent": 3,
      "text": "An ITT value of 0xffffffff is reserved and MUST NOT be assigned for a task by the initiator. The only instance in which it may be seen on the wire is in a target-initiated NOP-In PDU (Section 11.19) and in the initiator response to that PDU, if necessary.",
      "zh-cn": "An ITT value of 0xffffffff is reserved and MUST NOT be assigned for a task by the initiator. The only instance in which it may be seen on the wire is in a target-initiated NOP-In PDU (Section 11.19) and in the initiator response to that PDU, if necessary."
    },
    {
      "indent": 0,
      "text": "11.2.2. Additional Header Segment (AHS)",
      "section_title": true,
      "zh-cn": "11.2.2. Additional Header Segment (AHS)"
    },
    {
      "indent": 3,
      "text": "The general format of an AHS is:",
      "zh-cn": "The general format of an AHS is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0| AHSLength                     | AHSType       | AHS-Specific  |\n  +---------------+---------------+---------------+---------------+\n 4/ AHS-Specific                                                  /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n x",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.2.2.1. AHSType",
      "section_title": true,
      "zh-cn": "11.2.2.1. AHSType"
    },
    {
      "indent": 3,
      "text": "The AHSType field is coded as follows:",
      "zh-cn": "The AHSType field is coded as follows:"
    },
    {
      "indent": 6,
      "text": "bit 0-1 - Reserved",
      "zh-cn": "bit 0-1 - Reserved"
    },
    {
      "indent": 6,
      "text": "bit 2-7 - AHS code",
      "zh-cn": "bit 2-7 - AHS code"
    },
    {
      "indent": 6,
      "text": "0 - Reserved",
      "zh-cn": "0 - Reserved"
    },
    {
      "indent": 6,
      "text": "1 - Extended CDB",
      "zh-cn": "1 - Extended CDB"
    },
    {
      "indent": 6,
      "text": "2 - Bidirectional Read Expected Data Transfer Length",
      "zh-cn": "2 - Bidirectional Read Expected Data Transfer Length"
    },
    {
      "indent": 6,
      "text": "3 - 63 Reserved",
      "zh-cn": "3 - 63 Reserved"
    },
    {
      "indent": 0,
      "text": "11.2.2.2. AHSLength",
      "section_title": true,
      "zh-cn": "11.2.2.2. AHSLength"
    },
    {
      "indent": 3,
      "text": "This field contains the effective length in bytes of the AHS, excluding AHSType and AHSLength and padding, if any. The AHS is padded to the smallest integer number of 4-byte words (i.e., from 0 up to 3 padding bytes).",
      "zh-cn": "This field contains the effective length in bytes of the AHS, excluding AHSType and AHSLength and padding, if any. The AHS is padded to the smallest integer number of 4-byte words (i.e., from 0 up to 3 padding bytes)."
    },
    {
      "indent": 0,
      "text": "11.2.2.3. Extended CDB AHS",
      "section_title": true,
      "zh-cn": "11.2.2.3. Extended CDB AHS"
    },
    {
      "indent": 3,
      "text": "The format of the Extended CDB AHS is:",
      "zh-cn": "The format of the Extended CDB AHS is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0| AHSLength (CDBLength - 15)    | 0x01          |  Reserved     |\n  +---------------+---------------+---------------+---------------+\n 4/ ExtendedCDB...+padding                                        /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n x",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "This type of AHS MUST NOT be used if the CDBLength is less than 17.",
      "zh-cn": "This type of AHS MUST NOT be used if the CDBLength is less than 17."
    },
    {
      "indent": 3,
      "text": "The length includes the reserved byte 3.",
      "zh-cn": "The length includes the reserved byte 3."
    },
    {
      "indent": 0,
      "text": "11.2.2.4. Bidirectional Read Expected Data Transfer Length AHS",
      "section_title": true,
      "zh-cn": "11.2.2.4. Bidirectional Read Expected Data Transfer Length AHS"
    },
    {
      "indent": 3,
      "text": "The format of the Bidirectional Read Expected Data Transfer Length AHS is:",
      "zh-cn": "The format of the Bidirectional Read Expected Data Transfer Length AHS is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0| AHSLength (0x0005)            | 0x02          | Reserved      |\n  +---------------+---------------+---------------+---------------+\n 4| Bidirectional Read Expected Data Transfer Length              |\n  +---------------+---------------+---------------+---------------+\n 8",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.2.3. Header Digest and Data Digest",
      "section_title": true,
      "zh-cn": "11.2.3. Header Digest and Data Digest"
    },
    {
      "indent": 3,
      "text": "Optional header and data digests protect the integrity of the header and data, respectively. The digests, if present, are located, respectively, after the header and PDU-specific data and cover, respectively, the header and the PDU data, each including the padding bytes, if any.",
      "zh-cn": "Optional header and data digests protect the integrity of the header and data, respectively. The digests, if present, are located, respectively, after the header and PDU-specific data and cover, respectively, the header and the PDU data, each including the padding bytes, if any."
    },
    {
      "indent": 3,
      "text": "The existence and type of digests are negotiated during the Login Phase.",
      "zh-cn": "The existence and type of digests are negotiated during the Login Phase."
    },
    {
      "indent": 3,
      "text": "The separation of the header and data digests is useful in iSCSI routing applications, in which only the header changes when a message is forwarded. In this case, only the header digest should be recalculated.",
      "zh-cn": "The separation of the header and data digests is useful in iSCSI routing applications, in which only the header changes when a message is forwarded. In this case, only the header digest should be recalculated."
    },
    {
      "indent": 3,
      "text": "Digests are not included in data or header length fields.",
      "zh-cn": "Digests are not included in data or header length fields."
    },
    {
      "indent": 3,
      "text": "A zero-length Data Segment also implies a zero-length Data-Digest.",
      "zh-cn": "A zero-length Data Segment also implies a zero-length Data-Digest."
    },
    {
      "indent": 0,
      "text": "11.2.4. Data Segment",
      "section_title": true,
      "zh-cn": "11.2.4. Data Segment"
    },
    {
      "indent": 3,
      "text": "The (optional) Data Segment contains PDU-associated data. Its payload effective length is provided in the BHS field -- DataSegmentLength. The Data Segment is also padded to an integer number of 4-byte words.",
      "zh-cn": "The (optional) Data Segment contains PDU-associated data. Its payload effective length is provided in the BHS field -- DataSegmentLength. The Data Segment is also padded to an integer number of 4-byte words."
    },
    {
      "indent": 0,
      "text": "11.3. SCSI Command",
      "section_title": true,
      "zh-cn": "11.3. SCSI Command"
    },
    {
      "indent": 3,
      "text": "The format of the SCSI Command PDU is:",
      "zh-cn": "The format of the SCSI Command PDU is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| 0x01      |F|R|W|. .|ATTR | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| Logical Unit Number (LUN)                                     |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Expected Data Transfer Length                                 |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32/ SCSI Command Descriptor Block (CDB)                           /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48/ AHS (optional)                                                /\n  +---------------+---------------+---------------+---------------+\n x/ Header-Digest (optional)                                      /\n  +---------------+---------------+---------------+---------------+\n y/ (DataSegment, Command Data) (optional)                        /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n z/ Data-Digest (optional)                                        /\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.3.1. Flags and Task Attributes (Byte 1)",
      "section_title": true,
      "zh-cn": "11.3.1. Flags and Task Attributes (Byte 1)"
    },
    {
      "indent": 3,
      "text": "The flags for a SCSI Command PDU are:",
      "zh-cn": "The flags for a SCSI Command PDU are:"
    },
    {
      "indent": 6,
      "text": "bit 0 (F) is set to 1 when no unsolicited SCSI Data-Out PDUs follow this PDU. When F = 1 for a write and if Expected Data Transfer Length is larger than the DataSegmentLength, the target may solicit additional data through R2T.",
      "zh-cn": "bit 0 (F) is set to 1 when no unsolicited SCSI Data-Out PDUs follow this PDU. When F = 1 for a write and if Expected Data Transfer Length is larger than the DataSegmentLength, the target may solicit additional data through R2T."
    },
    {
      "indent": 6,
      "text": "bit 1 (R) is set to 1 when the command is expected to input data.",
      "zh-cn": "bit 1 (R) is set to 1 when the command is expected to input data."
    },
    {
      "indent": 6,
      "text": "bit 2 (W) is set to 1 when the command is expected to output data.",
      "zh-cn": "bit 2 (W) is set to 1 when the command is expected to output data."
    },
    {
      "indent": 6,
      "text": "bit 3-4 Reserved.",
      "zh-cn": "bit 3-4 Reserved."
    },
    {
      "indent": 6,
      "text": "bit 5-7 contains Task Attributes.",
      "zh-cn": "bit 5-7 contains Task Attributes."
    },
    {
      "indent": 3,
      "text": "Task Attributes (ATTR) have one of the following integer values (see [SAM2] for details):",
      "zh-cn": "Task Attributes (ATTR) have one of the following integer values (see [SAM2] for details):"
    },
    {
      "indent": 8,
      "text": "0 - Untagged",
      "zh-cn": "0 - Untagged"
    },
    {
      "indent": 8,
      "text": "1 - Simple",
      "zh-cn": "1 - Simple"
    },
    {
      "indent": 8,
      "text": "2 - Ordered",
      "zh-cn": "2 - Ordered"
    },
    {
      "indent": 8,
      "text": "3 - Head of queue",
      "zh-cn": "3 - Head of queue"
    },
    {
      "indent": 8,
      "text": "4 - ACA",
      "zh-cn": "4 - ACA"
    },
    {
      "indent": 6,
      "text": "5-7 - Reserved",
      "zh-cn": "5-7 - Reserved"
    },
    {
      "indent": 3,
      "text": "At least one of the W and F bits MUST be set to 1.",
      "zh-cn": "At least one of the W and F bits MUST be set to 1."
    },
    {
      "indent": 3,
      "text": "Either or both of R and W MAY be 1 when the Expected Data Transfer Length and/or the Bidirectional Read Expected Data Transfer Length are 0, but they MUST NOT both be 0 when the Expected Data Transfer Length and/or Bidirectional Read Expected Data Transfer Length are not 0 (i.e., when some data transfer is expected, the transfer direction is indicated by the R and/or W bit).",
      "zh-cn": "Either or both of R and W MAY be 1 when the Expected Data Transfer Length and/or the Bidirectional Read Expected Data Transfer Length are 0, but they MUST NOT both be 0 when the Expected Data Transfer Length and/or Bidirectional Read Expected Data Transfer Length are not 0 (i.e., when some data transfer is expected, the transfer direction is indicated by the R and/or W bit)."
    },
    {
      "indent": 0,
      "text": "11.3.2. CmdSN - Command Sequence Number",
      "section_title": true,
      "zh-cn": "11.3.2. CmdSN - Command Sequence Number"
    },
    {
      "indent": 3,
      "text": "The CmdSN enables ordered delivery across multiple connections in a single session.",
      "zh-cn": "The CmdSN enables ordered delivery across multiple connections in a single session."
    },
    {
      "indent": 0,
      "text": "11.3.3. ExpStatSN",
      "section_title": true,
      "zh-cn": "11.3.3. ExpStatSN"
    },
    {
      "indent": 3,
      "text": "Command responses up to ExpStatSN - 1 (modulo 2**32) have been received (acknowledges status) on the connection.",
      "zh-cn": "Command responses up to ExpStatSN - 1 (modulo 2**32) have been received (acknowledges status) on the connection."
    },
    {
      "indent": 0,
      "text": "11.3.4. Expected Data Transfer Length",
      "section_title": true,
      "zh-cn": "11.3.4. Expected Data Transfer Length"
    },
    {
      "indent": 3,
      "text": "For unidirectional operations, the Expected Data Transfer Length field contains the number of bytes of data involved in this SCSI operation. For a unidirectional write operation (W flag set to 1 and R flag set to 0), the initiator uses this field to specify the number of bytes of data it expects to transfer for this operation. For a unidirectional read operation (W flag set to 0 and R flag set to 1), the initiator uses this field to specify the number of bytes of data it expects the target to transfer to the initiator. It corresponds to the SAM-2 byte count.",
      "zh-cn": "For unidirectional operations, the Expected Data Transfer Length field contains the number of bytes of data involved in this SCSI operation. For a unidirectional write operation (W flag set to 1 and R flag set to 0), the initiator uses this field to specify the number of bytes of data it expects to transfer for this operation. For a unidirectional read operation (W flag set to 0 and R flag set to 1), the initiator uses this field to specify the number of bytes of data it expects the target to transfer to the initiator. It corresponds to the SAM-2 byte count."
    },
    {
      "indent": 3,
      "text": "For bidirectional operations (both R and W flags are set to 1), this field contains the number of data bytes involved in the write transfer. For bidirectional operations, an additional header segment MUST be present in the header sequence that indicates the Bidirectional Read Expected Data Transfer Length. The Expected Data Transfer Length field and the Bidirectional Read Expected Data Transfer Length field correspond to the SAM-2 byte count.",
      "zh-cn": "For bidirectional operations (both R and W flags are set to 1), this field contains the number of data bytes involved in the write transfer. For bidirectional operations, an additional header segment MUST be present in the header sequence that indicates the Bidirectional Read Expected Data Transfer Length. The Expected Data Transfer Length field and the Bidirectional Read Expected Data Transfer Length field correspond to the SAM-2 byte count."
    },
    {
      "indent": 3,
      "text": "If the Expected Data Transfer Length for a write and the length of the immediate data part that follows the command (if any) are the same, then no more data PDUs are expected to follow. In this case, the F bit MUST be set to 1.",
      "zh-cn": "If the Expected Data Transfer Length for a write and the length of the immediate data part that follows the command (if any) are the same, then no more data PDUs are expected to follow. In this case, the F bit MUST be set to 1."
    },
    {
      "indent": 3,
      "text": "If the Expected Data Transfer Length is higher than the FirstBurstLength (the negotiated maximum amount of unsolicited data the target will accept), the initiator MUST send the maximum amount of unsolicited data OR ONLY the immediate data, if any.",
      "zh-cn": "If the Expected Data Transfer Length is higher than the FirstBurstLength (the negotiated maximum amount of unsolicited data the target will accept), the initiator MUST send the maximum amount of unsolicited data OR ONLY the immediate data, if any."
    },
    {
      "indent": 3,
      "text": "Upon completion of a data transfer, the target informs the initiator (through residual counts) of how many bytes were actually processed (sent and/or received) by the target.",
      "zh-cn": "Upon completion of a data transfer, the target informs the initiator (through residual counts) of how many bytes were actually processed (sent and/or received) by the target."
    },
    {
      "indent": 0,
      "text": "11.3.5. CDB - SCSI Command Descriptor Block",
      "section_title": true,
      "zh-cn": "11.3.5. CDB - SCSI Command Descriptor Block"
    },
    {
      "indent": 3,
      "text": "There are 16 bytes in the CDB field to accommodate the commonly used CDBs. Whenever the CDB is larger than 16 bytes, an Extended CDB AHS MUST be used to contain the CDB spillover.",
      "zh-cn": "There are 16 bytes in the CDB field to accommodate the commonly used CDBs. Whenever the CDB is larger than 16 bytes, an Extended CDB AHS MUST be used to contain the CDB spillover."
    },
    {
      "indent": 0,
      "text": "11.3.6. Data Segment - Command Data",
      "section_title": true,
      "zh-cn": "11.3.6. Data Segment - Command Data"
    },
    {
      "indent": 3,
      "text": "Some SCSI commands require additional parameter data to accompany the SCSI command. This data may be placed beyond the boundary of the iSCSI header in a data segment. Alternatively, user data (e.g., from a write operation) can be placed in the data segment (both cases are referred to as immediate data). These data are governed by the rules for solicited vs. unsolicited data outlined in Section 4.2.5.2.",
      "zh-cn": "Some SCSI commands require additional parameter data to accompany the SCSI command. This data may be placed beyond the boundary of the iSCSI header in a data segment. Alternatively, user data (e.g., from a write operation) can be placed in the data segment (both cases are referred to as immediate data). These data are governed by the rules for solicited vs. unsolicited data outlined in Section 4.2.5.2."
    },
    {
      "indent": 0,
      "text": "11.4. SCSI Response",
      "section_title": true,
      "zh-cn": "11.4. SCSI Response"
    },
    {
      "indent": 3,
      "text": "The format of the SCSI Response PDU is:",
      "zh-cn": "The format of the SCSI Response PDU is:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x21      |1|. .|o|u|O|U|.| Response      | Status        |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| Reserved                                                      |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| SNACK Tag or Reserved                                         |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| ExpDataSN or Reserved                                         |\n  +---------------+---------------+---------------+---------------+\n40| Bidirectional Read Residual Count or Reserved                 |\n  +---------------+---------------+---------------+---------------+\n44| Residual Count or Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / Data Segment (optional)                                       /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.4.1. Flags (Byte 1)",
      "section_title": true,
      "zh-cn": "11.4.1. Flags (Byte 1)"
    },
    {
      "indent": 3,
      "text": "bit 1-2 Reserved.",
      "zh-cn": "bit 1-2 Reserved."
    },
    {
      "indent": 3,
      "text": "bit 3 - (o) set for Bidirectional Read Residual Overflow. In this case, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator because the initiator's Bidirectional Read Expected Data Transfer Length was not sufficient.",
      "zh-cn": "bit 3 - (o) set for Bidirectional Read Residual Overflow. In this case, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator because the initiator's Bidirectional Read Expected Data Transfer Length was not sufficient."
    },
    {
      "indent": 3,
      "text": "bit 4 - (u) set for Bidirectional Read Residual Underflow. In this case, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator out of the number of bytes expected to be transferred.",
      "zh-cn": "bit 4 - (u) set for Bidirectional Read Residual Underflow. In this case, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator out of the number of bytes expected to be transferred."
    },
    {
      "indent": 3,
      "text": "bit 5 - (O) set for Residual Overflow. In this case, the Residual Count indicates the number of bytes that were not transferred because the initiator's Expected Data Transfer Length was not sufficient. For a bidirectional operation, the Residual Count contains the residual for the write operation.",
      "zh-cn": "bit 5 - (O) set for Residual Overflow. In this case, the Residual Count indicates the number of bytes that were not transferred because the initiator's Expected Data Transfer Length was not sufficient. For a bidirectional operation, the Residual Count contains the residual for the write operation."
    },
    {
      "indent": 3,
      "text": "bit 6 - (U) set for Residual Underflow. In this case, the Residual Count indicates the number of bytes that were not transferred out of the number of bytes that were expected to be transferred. For a bidirectional operation, the Residual Count contains the residual for the write operation.",
      "zh-cn": "bit 6 - (U) set for Residual Underflow. In this case, the Residual Count indicates the number of bytes that were not transferred out of the number of bytes that were expected to be transferred. For a bidirectional operation, the Residual Count contains the residual for the write operation."
    },
    {
      "indent": 3,
      "text": "bit 7 - (0) Reserved.",
      "zh-cn": "bit 7 - (0) Reserved."
    },
    {
      "indent": 3,
      "text": "Bits O and U and bits o and u are mutually exclusive (i.e., having both o and u or O and U set to 1 is a protocol error).",
      "zh-cn": "Bits O and U and bits o and u are mutually exclusive (i.e., having both o and u or O and U set to 1 is a protocol error)."
    },
    {
      "indent": 3,
      "text": "For a response other than \"Command Completed at Target\", bits 3-6 MUST be 0.",
      "zh-cn": "For a response other than \"Command Completed at Target\", bits 3-6 MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.4.2. Status",
      "section_title": true,
      "zh-cn": "11.4.2. Status"
    },
    {
      "indent": 3,
      "text": "The Status field is used to report the SCSI status of the command (as specified in [SAM2]) and is only valid if the response code is Command Completed at Target.",
      "zh-cn": "The Status field is used to report the SCSI status of the command (as specified in [SAM2]) and is only valid if the response code is Command Completed at Target."
    },
    {
      "indent": 3,
      "text": "Some of the status codes defined in [SAM2] are:",
      "zh-cn": "Some of the status codes defined in [SAM2] are:"
    },
    {
      "indent": 6,
      "text": "0x00 GOOD",
      "zh-cn": "0x00 GOOD"
    },
    {
      "indent": 6,
      "text": "0x02 CHECK CONDITION",
      "zh-cn": "0x02 CHECK CONDITION"
    },
    {
      "indent": 6,
      "text": "0x08 BUSY",
      "zh-cn": "0x08 BUSY"
    },
    {
      "indent": 6,
      "text": "0x18 RESERVATION CONFLICT",
      "zh-cn": "0x18 RESERVATION CONFLICT"
    },
    {
      "indent": 6,
      "text": "0x28 TASK SET FULL",
      "zh-cn": "0x28 TASK SET FULL"
    },
    {
      "indent": 6,
      "text": "0x30 ACA ACTIVE",
      "zh-cn": "0x30 ACA ACTIVE"
    },
    {
      "indent": 6,
      "text": "0x40 TASK ABORTED",
      "zh-cn": "0x40 TASK ABORTED"
    },
    {
      "indent": 3,
      "text": "See [SAM2] for the complete list and definitions.",
      "zh-cn": "See [SAM2] for the complete list and definitions."
    },
    {
      "indent": 3,
      "text": "If a SCSI device error is detected while data from the initiator is still expected (the command PDU did not contain all the data and the target has not received a data PDU with the Final bit set), the target MUST wait until it receives a data PDU with the F bit set in the last expected sequence before sending the Response PDU.",
      "zh-cn": "If a SCSI device error is detected while data from the initiator is still expected (the command PDU did not contain all the data and the target has not received a data PDU with the Final bit set), the target MUST wait until it receives a data PDU with the F bit set in the last expected sequence before sending the Response PDU."
    },
    {
      "indent": 0,
      "text": "11.4.3. Response",
      "section_title": true,
      "zh-cn": "11.4.3. Response"
    },
    {
      "indent": 3,
      "text": "This field contains the iSCSI service response.",
      "zh-cn": "This field contains the iSCSI service response."
    },
    {
      "indent": 3,
      "text": "iSCSI service response codes defined in this specification are:",
      "zh-cn": "iSCSI service response codes defined in this specification are:"
    },
    {
      "indent": 6,
      "text": "0x00 - Command Completed at Target",
      "zh-cn": "0x00 - Command Completed at Target"
    },
    {
      "indent": 6,
      "text": "0x01 - Target Failure",
      "zh-cn": "0x01 - Target Failure"
    },
    {
      "indent": 6,
      "text": "0x80-0xff - Vendor specific",
      "zh-cn": "0x80-0xff - Vendor specific"
    },
    {
      "indent": 3,
      "text": "All other response codes are reserved.",
      "zh-cn": "All other response codes are reserved."
    },
    {
      "indent": 3,
      "text": "The Response field is used to report a service response. The mapping of the response code into a SCSI service response code value, if needed, is outside the scope of this document. However, in symbolic terms, response value 0x00 maps to the SCSI service response (see",
      "zh-cn": "The Response field is used to report a service response. The mapping of the response code into a SCSI service response code value, if needed, is outside the scope of this document. However, in symbolic terms, response value 0x00 maps to the SCSI service response (see"
    },
    {
      "indent": 3,
      "text": "[SAM2] and [SPC3]) of TASK COMPLETE or LINKED COMMAND COMPLETE. All other Response values map to the SCSI service response of SERVICE DELIVERY OR TARGET FAILURE.",
      "zh-cn": "[SAM2] and [SPC3]) of TASK COMPLETE or LINKED COMMAND COMPLETE. All other Response values map to the SCSI service response of SERVICE DELIVERY OR TARGET FAILURE."
    },
    {
      "indent": 3,
      "text": "If a SCSI Response PDU does not arrive before the session is terminated, the SCSI service response is SERVICE DELIVERY OR TARGET FAILURE.",
      "zh-cn": "If a SCSI Response PDU does not arrive before the session is terminated, the SCSI service response is SERVICE DELIVERY OR TARGET FAILURE."
    },
    {
      "indent": 3,
      "text": "A non-zero response field indicates a failure to execute the command, in which case the Status and Flag fields are undefined and MUST be ignored on reception.",
      "zh-cn": "A non-zero response field indicates a failure to execute the command, in which case the Status and Flag fields are undefined and MUST be ignored on reception."
    },
    {
      "indent": 0,
      "text": "11.4.4. SNACK Tag",
      "section_title": true,
      "zh-cn": "11.4.4. SNACK Tag"
    },
    {
      "indent": 3,
      "text": "This field contains a copy of the SNACK Tag of the last SNACK Tag accepted by the target on the same connection and for the command for which the response is issued. Otherwise, it is reserved and should be set to 0.",
      "zh-cn": "This field contains a copy of the SNACK Tag of the last SNACK Tag accepted by the target on the same connection and for the command for which the response is issued. Otherwise, it is reserved and should be set to 0."
    },
    {
      "indent": 3,
      "text": "After issuing a R-Data SNACK, the initiator must discard any SCSI status unless contained in a SCSI Response PDU carrying the same SNACK Tag as the last issued R-Data SNACK for the SCSI command on the current connection.",
      "zh-cn": "After issuing a R-Data SNACK, the initiator must discard any SCSI status unless contained in a SCSI Response PDU carrying the same SNACK Tag as the last issued R-Data SNACK for the SCSI command on the current connection."
    },
    {
      "indent": 3,
      "text": "For a detailed discussion on R-Data SNACK, see Section 11.16.3.",
      "zh-cn": "For a detailed discussion on R-Data SNACK, see Section 11.16.3."
    },
    {
      "indent": 0,
      "text": "11.4.5. Residual Count",
      "section_title": true,
      "zh-cn": "11.4.5. Residual Count"
    },
    {
      "indent": 0,
      "text": "11.4.5.1. Field Semantics",
      "section_title": true,
      "zh-cn": "11.4.5.1. Field Semantics"
    },
    {
      "indent": 3,
      "text": "The Residual Count field MUST be valid in the case where either the U bit or the O bit is set. If neither bit is set, the Residual Count field MUST be ignored on reception and SHOULD be set to 0 when sending. Targets may set the residual count, and initiators may use it when the response code is Command Completed at Target (even if the status returned is not GOOD). If the O bit is set, the Residual Count indicates the number of bytes that were not transferred because the initiator's Expected Data Transfer Length was not sufficient. If the U bit is set, the Residual Count indicates the number of bytes that were not transferred out of the number of bytes expected to be transferred.",
      "zh-cn": "The Residual Count field MUST be valid in the case where either the U bit or the O bit is set. If neither bit is set, the Residual Count field MUST be ignored on reception and SHOULD be set to 0 when sending. Targets may set the residual count, and initiators may use it when the response code is Command Completed at Target (even if the status returned is not GOOD). If the O bit is set, the Residual Count indicates the number of bytes that were not transferred because the initiator's Expected Data Transfer Length was not sufficient. If the U bit is set, the Residual Count indicates the number of bytes that were not transferred out of the number of bytes expected to be transferred."
    },
    {
      "indent": 0,
      "text": "11.4.5.2. Residuals Concepts Overview",
      "section_title": true,
      "zh-cn": "11.4.5.2. Residuals Concepts Overview"
    },
    {
      "indent": 3,
      "text": "\"SCSI-Presented Data Transfer Length (SPDTL)\" is the term this document uses (see Section 2.2 for definition) to represent the aggregate data length that the target SCSI layer attempts to transfer using the local iSCSI layer for a task. \"Expected Data Transfer",
      "zh-cn": "\"SCSI-Presented Data Transfer Length (SPDTL)\" is the term this document uses (see Section 2.2 for definition) to represent the aggregate data length that the target SCSI layer attempts to transfer using the local iSCSI layer for a task. \"Expected Data Transfer"
    },
    {
      "indent": 3,
      "text": "Length (EDTL)\" is the iSCSI term that represents the length of data that the iSCSI layer expects to transfer for a task. EDTL is specified in the SCSI Command PDU.",
      "zh-cn": "Length (EDTL)\" is the iSCSI term that represents the length of data that the iSCSI layer expects to transfer for a task. EDTL is specified in the SCSI Command PDU."
    },
    {
      "indent": 3,
      "text": "When SPDTL = EDTL for a task, the target iSCSI layer completes the task with no residuals. Whenever SPDTL differs from EDTL for a task, that task is said to have a residual.",
      "zh-cn": "When SPDTL = EDTL for a task, the target iSCSI layer completes the task with no residuals. Whenever SPDTL differs from EDTL for a task, that task is said to have a residual."
    },
    {
      "indent": 3,
      "text": "If SPDTL > EDTL for a task, iSCSI Overflow MUST be signaled in the SCSI Response PDU as specified in Section 11.4.5.1. The Residual Count MUST be set to the numerical value of (SPDTL - EDTL).",
      "zh-cn": "If SPDTL > EDTL for a task, iSCSI Overflow MUST be signaled in the SCSI Response PDU as specified in Section 11.4.5.1. The Residual Count MUST be set to the numerical value of (SPDTL - EDTL)."
    },
    {
      "indent": 3,
      "text": "If SPDTL < EDTL for a task, iSCSI Underflow MUST be signaled in the SCSI Response PDU as specified in Section 11.4.5.1. The Residual Count MUST be set to the numerical value of (EDTL - SPDTL).",
      "zh-cn": "If SPDTL < EDTL for a task, iSCSI Underflow MUST be signaled in the SCSI Response PDU as specified in Section 11.4.5.1. The Residual Count MUST be set to the numerical value of (EDTL - SPDTL)."
    },
    {
      "indent": 3,
      "text": "Note that the Overflow and Underflow scenarios are independent of Data-In and Data-Out. Either scenario is logically possible in either direction of data transfer.",
      "zh-cn": "Note that the Overflow and Underflow scenarios are independent of Data-In and Data-Out. Either scenario is logically possible in either direction of data transfer."
    },
    {
      "indent": 0,
      "text": "11.4.5.3. SCSI REPORT LUNS Command and Residual Overflow",
      "section_title": true,
      "zh-cn": "11.4.5.3. SCSI REPORT LUNS Command and Residual Overflow"
    },
    {
      "indent": 3,
      "text": "This section discusses the residual overflow issues, citing the example of the SCSI REPORT LUNS command. Note, however, that there are several SCSI commands (e.g., INQUIRY) with ALLOCATION LENGTH fields following the same underlying rules. The semantics in the rest of the section apply to all such SCSI commands.",
      "zh-cn": "This section discusses the residual overflow issues, citing the example of the SCSI REPORT LUNS command. Note, however, that there are several SCSI commands (e.g., INQUIRY) with ALLOCATION LENGTH fields following the same underlying rules. The semantics in the rest of the section apply to all such SCSI commands."
    },
    {
      "indent": 3,
      "text": "The specification of the SCSI REPORT LUNS command requires that the SCSI target limit the amount of data transferred to a maximum size (ALLOCATION LENGTH) provided by the initiator in the REPORT LUNS CDB.",
      "zh-cn": "The specification of the SCSI REPORT LUNS command requires that the SCSI target limit the amount of data transferred to a maximum size (ALLOCATION LENGTH) provided by the initiator in the REPORT LUNS CDB."
    },
    {
      "indent": 3,
      "text": "If the Expected Data Transfer Length (EDTL) in the iSCSI header of the SCSI Command PDU for a REPORT LUNS command is set to at least as large as that ALLOCATION LENGTH, the SCSI-layer truncation prevents an iSCSI Residual Overflow from occurring. A SCSI initiator can detect that such truncation has occurred via other information at the SCSI layer. The rest of the section elaborates on this required behavior.",
      "zh-cn": "If the Expected Data Transfer Length (EDTL) in the iSCSI header of the SCSI Command PDU for a REPORT LUNS command is set to at least as large as that ALLOCATION LENGTH, the SCSI-layer truncation prevents an iSCSI Residual Overflow from occurring. A SCSI initiator can detect that such truncation has occurred via other information at the SCSI layer. The rest of the section elaborates on this required behavior."
    },
    {
      "indent": 3,
      "text": "The SCSI REPORT LUNS command requests a target SCSI layer to return a LU inventory (LUN list) to the initiator SCSI layer (see Clause 6.21 of [SPC3]). The size of this LUN list may not be known to the initiator SCSI layer when it issues the REPORT LUNS command; to avoid transferring more LUN list data than the initiator is prepared for, the REPORT LUNS CDB contains an ALLOCATION LENGTH field to specify the maximum amount of data to be transferred to the initiator for this command. If the initiator SCSI layer has underestimated the",
      "zh-cn": "The SCSI REPORT LUNS command requests a target SCSI layer to return a LU inventory (LUN list) to the initiator SCSI layer (see Clause 6.21 of [SPC3]). The size of this LUN list may not be known to the initiator SCSI layer when it issues the REPORT LUNS command; to avoid transferring more LUN list data than the initiator is prepared for, the REPORT LUNS CDB contains an ALLOCATION LENGTH field to specify the maximum amount of data to be transferred to the initiator for this command. If the initiator SCSI layer has underestimated the"
    },
    {
      "indent": 3,
      "text": "number of LUs at the target, it is possible that the complete LU inventory does not fit in the specified ALLOCATION LENGTH. In this situation, Clause 4.3.4.6 of [SPC3] requires that the target SCSI layer \"shall terminate transfers to the Data-In Buffer\" when the number of bytes specified by the ALLOCATION LENGTH field have been transferred.",
      "zh-cn": "number of LUs at the target, it is possible that the complete LU inventory does not fit in the specified ALLOCATION LENGTH. In this situation, Clause 4.3.4.6 of [SPC3] requires that the target SCSI layer \"shall terminate transfers to the Data-In Buffer\" when the number of bytes specified by the ALLOCATION LENGTH field have been transferred."
    },
    {
      "indent": 3,
      "text": "Therefore, in response to a REPORT LUNS command, the SCSI layer at the target presents at most ALLOCATION LENGTH bytes of data (LU inventory) to iSCSI for transfer to the initiator. For a REPORT LUNS command, if the iSCSI EDTL is at least as large as the ALLOCATION LENGTH, the SCSI truncation ensures that the EDTL will accommodate all of the data to be transferred. If all of the LU inventory data presented to the iSCSI layer -- i.e., the data remaining after any SCSI truncation -- is transferred to the initiator by the iSCSI layer, an iSCSI Residual Overflow has not occurred and the iSCSI (O) bit MUST NOT be set in the SCSI Response or final SCSI Data-Out PDU. Note that this behavior is implied in Section 11.4.5.1, along with the specification of the REPORT LUNS command in [SPC3]. However, if the iSCSI EDTL is larger than the ALLOCATION LENGTH in this scenario, note that the iSCSI Underflow MUST be signaled in the SCSI Response PDU. An iSCSI Underflow MUST also be signaled when the iSCSI EDTL is equal to the ALLOCATION LENGTH but the LU inventory data presented to the iSCSI layer is smaller than the ALLOCATION LENGTH.",
      "zh-cn": "Therefore, in response to a REPORT LUNS command, the SCSI layer at the target presents at most ALLOCATION LENGTH bytes of data (LU inventory) to iSCSI for transfer to the initiator. For a REPORT LUNS command, if the iSCSI EDTL is at least as large as the ALLOCATION LENGTH, the SCSI truncation ensures that the EDTL will accommodate all of the data to be transferred. If all of the LU inventory data presented to the iSCSI layer -- i.e., the data remaining after any SCSI truncation -- is transferred to the initiator by the iSCSI layer, an iSCSI Residual Overflow has not occurred and the iSCSI (O) bit MUST NOT be set in the SCSI Response or final SCSI Data-Out PDU. Note that this behavior is implied in Section 11.4.5.1, along with the specification of the REPORT LUNS command in [SPC3]. However, if the iSCSI EDTL is larger than the ALLOCATION LENGTH in this scenario, note that the iSCSI Underflow MUST be signaled in the SCSI Response PDU. An iSCSI Underflow MUST also be signaled when the iSCSI EDTL is equal to the ALLOCATION LENGTH but the LU inventory data presented to the iSCSI layer is smaller than the ALLOCATION LENGTH."
    },
    {
      "indent": 3,
      "text": "The LUN LIST LENGTH field in the LU inventory (the first field in the inventory) is not affected by truncation of the inventory to fit in ALLOCATION LENGTH; this enables a SCSI initiator to determine that the received inventory is incomplete by noticing that the LUN LIST LENGTH in the inventory is larger than the ALLOCATION LENGTH that was sent in the REPORT LUNS CDB. A common initiator behavior in this situation is to reissue the REPORT LUNS command with a larger ALLOCATION LENGTH.",
      "zh-cn": "The LUN LIST LENGTH field in the LU inventory (the first field in the inventory) is not affected by truncation of the inventory to fit in ALLOCATION LENGTH; this enables a SCSI initiator to determine that the received inventory is incomplete by noticing that the LUN LIST LENGTH in the inventory is larger than the ALLOCATION LENGTH that was sent in the REPORT LUNS CDB. A common initiator behavior in this situation is to reissue the REPORT LUNS command with a larger ALLOCATION LENGTH."
    },
    {
      "indent": 0,
      "text": "11.4.6. Bidirectional Read Residual Count",
      "section_title": true,
      "zh-cn": "11.4.6. Bidirectional Read Residual Count"
    },
    {
      "indent": 3,
      "text": "The Bidirectional Read Residual Count field MUST be valid in the case where either the u bit or the o bit is set. If neither bit is set, the Bidirectional Read Residual Count field is reserved. Targets may set the Bidirectional Read Residual Count, and initiators may use it when the response code is Command Completed at Target. If the o bit is set, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator because the initiator's Bidirectional Read Expected Data Transfer Length was not sufficient. If the u bit is set, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator out of the number of bytes expected to be transferred.",
      "zh-cn": "The Bidirectional Read Residual Count field MUST be valid in the case where either the u bit or the o bit is set. If neither bit is set, the Bidirectional Read Residual Count field is reserved. Targets may set the Bidirectional Read Residual Count, and initiators may use it when the response code is Command Completed at Target. If the o bit is set, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator because the initiator's Bidirectional Read Expected Data Transfer Length was not sufficient. If the u bit is set, the Bidirectional Read Residual Count indicates the number of bytes that were not transferred to the initiator out of the number of bytes expected to be transferred."
    },
    {
      "indent": 0,
      "text": "11.4.7. Data Segment - Sense and Response Data Segment",
      "section_title": true,
      "zh-cn": "11.4.7. Data Segment - Sense and Response Data Segment"
    },
    {
      "indent": 3,
      "text": "iSCSI targets MUST support and enable Autosense. If Status is CHECK CONDITION (0x02), then the data segment MUST contain sense data for the failed command.",
      "zh-cn": "iSCSI targets MUST support and enable Autosense. If Status is CHECK CONDITION (0x02), then the data segment MUST contain sense data for the failed command."
    },
    {
      "indent": 3,
      "text": "For some iSCSI responses, the response data segment MAY contain some response-related information (e.g., for a target failure, it may contain a vendor-specific detailed description of the failure).",
      "zh-cn": "For some iSCSI responses, the response data segment MAY contain some response-related information (e.g., for a target failure, it may contain a vendor-specific detailed description of the failure)."
    },
    {
      "indent": 3,
      "text": "If the DataSegmentLength is not 0, the format of the data segment is as follows:",
      "zh-cn": "If the DataSegmentLength is not 0, the format of the data segment is as follows:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|SenseLength                    | Sense Data                    |\n  +---------------+---------------+---------------+---------------+\n x/ Sense Data                                                    /\n  +---------------+---------------+---------------+---------------+\n y/ Response Data                                                 /\n  /                                                               /\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.4.7.1. SenseLength",
      "section_title": true,
      "zh-cn": "11.4.7.1. SenseLength"
    },
    {
      "indent": 3,
      "text": "This field indicates the length of Sense Data.",
      "zh-cn": "This field indicates the length of Sense Data."
    },
    {
      "indent": 0,
      "text": "11.4.7.2. Sense Data",
      "section_title": true,
      "zh-cn": "11.4.7.2. Sense Data"
    },
    {
      "indent": 3,
      "text": "The Sense Data contains detailed information about a CHECK CONDITION. [SPC3] specifies the format and content of the Sense Data.",
      "zh-cn": "The Sense Data contains detailed information about a CHECK CONDITION. [SPC3] specifies the format and content of the Sense Data."
    },
    {
      "indent": 3,
      "text": "Certain iSCSI conditions result in the command being terminated at the target (response code of Command Completed at Target) with a SCSI CHECK CONDITION Status as outlined in the next table:",
      "zh-cn": "Certain iSCSI conditions result in the command being terminated at the target (response code of Command Completed at Target) with a SCSI CHECK CONDITION Status as outlined in the next table:"
    },
    {
      "indent": 3,
      "text": "+--------------------------+-----------+---------------------------+\n| iSCSI Condition          |Sense      | Additional Sense Code and |\n|                          |Key        | Qualifier                 |\n+--------------------------+-----------+---------------------------+\n| Unexpected unsolicited   |Aborted    | ASC = 0x0c ASCQ = 0x0c    |\n| data                     |Command-0B | Write Error               |\n+--------------------------+-----------+---------------------------+\n| Incorrect amount of data |Aborted    | ASC = 0x0c ASCQ = 0x0d    |\n|                          |Command-0B | Write Error               |\n+--------------------------+-----------+---------------------------+\n| Protocol Service CRC     |Aborted    | ASC = 0x47 ASCQ = 0x05    |\n| error                    |Command-0B | CRC Error Detected        |\n+--------------------------+-----------+---------------------------+\n| SNACK rejected           |Aborted    | ASC = 0x11 ASCQ = 0x13    |\n|                          |Command-0B | Read Error                |\n+--------------------------+-----------+---------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The target reports the \"Incorrect amount of data\" condition if, during data output, the total data length to output is greater than FirstBurstLength and the initiator sent unsolicited non-immediate data but the total amount of unsolicited data is different than FirstBurstLength. The target reports the same error when the amount of data sent as a reply to an R2T does not match the amount requested.",
      "zh-cn": "The target reports the \"Incorrect amount of data\" condition if, during data output, the total data length to output is greater than FirstBurstLength and the initiator sent unsolicited non-immediate data but the total amount of unsolicited data is different than FirstBurstLength. The target reports the same error when the amount of data sent as a reply to an R2T does not match the amount requested."
    },
    {
      "indent": 0,
      "text": "11.4.8. ExpDataSN",
      "section_title": true,
      "zh-cn": "11.4.8. ExpDataSN"
    },
    {
      "indent": 3,
      "text": "This field indicates the number of Data-In (read) PDUs the target has sent for the command.",
      "zh-cn": "This field indicates the number of Data-In (read) PDUs the target has sent for the command."
    },
    {
      "indent": 3,
      "text": "This field MUST be 0 if the response code is not Command Completed at Target or the target sent no Data-In PDUs for the command.",
      "zh-cn": "This field MUST be 0 if the response code is not Command Completed at Target or the target sent no Data-In PDUs for the command."
    },
    {
      "indent": 0,
      "text": "11.4.9. StatSN - Status Sequence Number",
      "section_title": true,
      "zh-cn": "11.4.9. StatSN - Status Sequence Number"
    },
    {
      "indent": 3,
      "text": "The StatSN is a sequence number that the target iSCSI layer generates per connection and that in turn enables the initiator to acknowledge status reception. The StatSN is incremented by 1 for every response/status sent on a connection, except for responses sent as a",
      "zh-cn": "The StatSN is a sequence number that the target iSCSI layer generates per connection and that in turn enables the initiator to acknowledge status reception. The StatSN is incremented by 1 for every response/status sent on a connection, except for responses sent as a"
    },
    {
      "indent": 3,
      "text": "result of a retry or SNACK. In the case of responses sent due to a retransmission request, the StatSN MUST be the same as the first time the PDU was sent, unless the connection has since been restarted.",
      "zh-cn": "result of a retry or SNACK. In the case of responses sent due to a retransmission request, the StatSN MUST be the same as the first time the PDU was sent, unless the connection has since been restarted."
    },
    {
      "indent": 0,
      "text": "11.4.10. ExpCmdSN - Next Expected CmdSN from This Initiator",
      "section_title": true,
      "zh-cn": "11.4.10. ExpCmdSN - Next Expected CmdSN from This Initiator"
    },
    {
      "indent": 3,
      "text": "The ExpCmdSN is a sequence number that the target iSCSI returns to the initiator to acknowledge command reception. It is used to update a local variable with the same name. An ExpCmdSN equal to MaxCmdSN + 1 indicates that the target cannot accept new commands.",
      "zh-cn": "The ExpCmdSN is a sequence number that the target iSCSI returns to the initiator to acknowledge command reception. It is used to update a local variable with the same name. An ExpCmdSN equal to MaxCmdSN + 1 indicates that the target cannot accept new commands."
    },
    {
      "indent": 0,
      "text": "11.4.11. MaxCmdSN - Maximum CmdSN from This Initiator",
      "section_title": true,
      "zh-cn": "11.4.11. MaxCmdSN - Maximum CmdSN from This Initiator"
    },
    {
      "indent": 3,
      "text": "The MaxCmdSN is a sequence number that the target iSCSI returns to the initiator to indicate the maximum CmdSN the initiator can send. It is used to update a local variable with the same name. If the MaxCmdSN is equal to ExpCmdSN - 1, this indicates to the initiator that the target cannot receive any additional commands. When the MaxCmdSN changes at the target while the target has no pending PDUs to convey this information to the initiator, it MUST generate a NOP-In to carry the new MaxCmdSN.",
      "zh-cn": "The MaxCmdSN is a sequence number that the target iSCSI returns to the initiator to indicate the maximum CmdSN the initiator can send. It is used to update a local variable with the same name. If the MaxCmdSN is equal to ExpCmdSN - 1, this indicates to the initiator that the target cannot receive any additional commands. When the MaxCmdSN changes at the target while the target has no pending PDUs to convey this information to the initiator, it MUST generate a NOP-In to carry the new MaxCmdSN."
    },
    {
      "indent": 0,
      "text": "11.5. Task Management Function Request",
      "section_title": true,
      "zh-cn": "11.5. Task Management Function Request"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| 0x02      |1| Function    | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| Logical Unit Number (LUN) or Reserved                         |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Referenced Task Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32| RefCmdSN or Reserved                                          |\n  +---------------+---------------+---------------+---------------+\n36| ExpDataSN or Reserved                                         |\n  +---------------+---------------+---------------+---------------+\n40/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.5.1. Function",
      "section_title": true,
      "zh-cn": "11.5.1. Function"
    },
    {
      "indent": 3,
      "text": "The task management functions provide an initiator with a way to explicitly control the execution of one or more tasks (SCSI and iSCSI tasks). The task management function codes are listed below. For a more detailed description of SCSI task management, see [SAM2].",
      "zh-cn": "The task management functions provide an initiator with a way to explicitly control the execution of one or more tasks (SCSI and iSCSI tasks). The task management function codes are listed below. For a more detailed description of SCSI task management, see [SAM2]."
    },
    {
      "indent": 6,
      "text": "1 ABORT TASK - aborts the task identified by the Referenced Task Tag field.",
      "zh-cn": "1 ABORT TASK - aborts the task identified by the Referenced Task Tag field."
    },
    {
      "indent": 6,
      "text": "2 ABORT TASK SET - aborts all tasks issued via this session on the LU.",
      "zh-cn": "2 ABORT TASK SET - aborts all tasks issued via this session on the LU."
    },
    {
      "indent": 6,
      "text": "3 CLEAR ACA - clears the Auto Contingent Allegiance condition.",
      "zh-cn": "3 CLEAR ACA - clears the Auto Contingent Allegiance condition."
    },
    {
      "indent": 6,
      "text": "4 CLEAR TASK SET - aborts all tasks in the appropriate task set as defined by the TST field in the Control mode page (see [SPC3]).",
      "zh-cn": "4 CLEAR TASK SET - aborts all tasks in the appropriate task set as defined by the TST field in the Control mode page (see [SPC3])."
    },
    {
      "indent": 6,
      "text": "5 LOGICAL UNIT RESET",
      "zh-cn": "5 LOGICAL UNIT RESET"
    },
    {
      "indent": 6,
      "text": "6 TARGET WARM RESET",
      "zh-cn": "6 TARGET WARM RESET"
    },
    {
      "indent": 6,
      "text": "7 TARGET COLD RESET",
      "zh-cn": "7 TARGET COLD RESET"
    },
    {
      "indent": 6,
      "text": "8 TASK REASSIGN - reassigns connection allegiance for the task identified by the Initiator Task Tag field to this connection, thus resuming the iSCSI exchanges for the task.",
      "zh-cn": "8 TASK REASSIGN - reassigns connection allegiance for the task identified by the Initiator Task Tag field to this connection, thus resuming the iSCSI exchanges for the task."
    },
    {
      "indent": 3,
      "text": "Values 9-12 are assigned in [RFC7144]. All other possible values for the Function field are unassigned.",
      "zh-cn": "Values 9-12 are assigned in [RFC7144]. All other possible values for the Function field are unassigned."
    },
    {
      "indent": 3,
      "text": "For all these functions, the Task Management Function Response MUST be returned as detailed in Section 11.6. All these functions apply to the referenced tasks, regardless of whether they are proper SCSI tasks or tagged iSCSI operations. Task management requests must act on all the commands from the same session having a CmdSN lower than the task management CmdSN. LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET may affect commands from other sessions or commands from the same session, regardless of their CmdSN value.",
      "zh-cn": "For all these functions, the Task Management Function Response MUST be returned as detailed in Section 11.6. All these functions apply to the referenced tasks, regardless of whether they are proper SCSI tasks or tagged iSCSI operations. Task management requests must act on all the commands from the same session having a CmdSN lower than the task management CmdSN. LOGICAL UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET may affect commands from other sessions or commands from the same session, regardless of their CmdSN value."
    },
    {
      "indent": 3,
      "text": "If the task management request is marked for immediate delivery, it must be considered immediately for execution, but the operations involved (all or part of them) may be postponed to allow the target to receive all relevant tasks. According to [SAM2], for all the tasks covered by the task management response (i.e., with a CmdSN lower than the task management command CmdSN), except for the task management response to a TASK REASSIGN, additional responses MUST NOT be delivered to the SCSI layer after the task management response. The iSCSI initiator MAY deliver to the SCSI layer all responses received before the task management response (i.e., it is a matter of implementation if the SCSI responses that are received before the task management response but after the task management request was issued are delivered to the SCSI layer by the iSCSI layer in the initiator). The iSCSI target MUST ensure that no responses for the tasks covered by a task management function are delivered to the iSCSI initiator after the task management response, except for a task covered by a TASK REASSIGN.",
      "zh-cn": "If the task management request is marked for immediate delivery, it must be considered immediately for execution, but the operations involved (all or part of them) may be postponed to allow the target to receive all relevant tasks. According to [SAM2], for all the tasks covered by the task management response (i.e., with a CmdSN lower than the task management command CmdSN), except for the task management response to a TASK REASSIGN, additional responses MUST NOT be delivered to the SCSI layer after the task management response. The iSCSI initiator MAY deliver to the SCSI layer all responses received before the task management response (i.e., it is a matter of implementation if the SCSI responses that are received before the task management response but after the task management request was issued are delivered to the SCSI layer by the iSCSI layer in the initiator). The iSCSI target MUST ensure that no responses for the tasks covered by a task management function are delivered to the iSCSI initiator after the task management response, except for a task covered by a TASK REASSIGN."
    },
    {
      "indent": 3,
      "text": "For ABORT TASK SET and CLEAR TASK SET, the issuing initiator MUST continue to respond to all valid Target Transfer Tags (received via R2T, Text Response, NOP-In, or SCSI Data-In PDUs) related to the affected task set, even after issuing the task management request.",
      "zh-cn": "For ABORT TASK SET and CLEAR TASK SET, the issuing initiator MUST continue to respond to all valid Target Transfer Tags (received via R2T, Text Response, NOP-In, or SCSI Data-In PDUs) related to the affected task set, even after issuing the task management request."
    },
    {
      "indent": 3,
      "text": "The issuing initiator SHOULD, however, terminate (i.e., by setting the F bit to 1) these response sequences as quickly as possible. The target for its part MUST wait for responses on all affected Target Transfer Tags before acting on either of these two task management requests. If all or part of the response sequence is not received (due to digest errors) for a valid TTT, the target MAY treat it as a case of a within-command error recovery class (see Section 7.1.4.1) if it is supporting ErrorRecoveryLevel >= 1 or, alternatively, may drop the connection to complete the requested task set function.",
      "zh-cn": "The issuing initiator SHOULD, however, terminate (i.e., by setting the F bit to 1) these response sequences as quickly as possible. The target for its part MUST wait for responses on all affected Target Transfer Tags before acting on either of these two task management requests. If all or part of the response sequence is not received (due to digest errors) for a valid TTT, the target MAY treat it as a case of a within-command error recovery class (see Section 7.1.4.1) if it is supporting ErrorRecoveryLevel >= 1 or, alternatively, may drop the connection to complete the requested task set function."
    },
    {
      "indent": 3,
      "text": "If an ABORT TASK is issued for a task created by an immediate command, then the RefCmdSN MUST be that of the task management request itself (i.e., the CmdSN and RefCmdSN are equal); otherwise, the RefCmdSN MUST be set to the CmdSN of the task to be aborted (lower than the CmdSN).",
      "zh-cn": "If an ABORT TASK is issued for a task created by an immediate command, then the RefCmdSN MUST be that of the task management request itself (i.e., the CmdSN and RefCmdSN are equal); otherwise, the RefCmdSN MUST be set to the CmdSN of the task to be aborted (lower than the CmdSN)."
    },
    {
      "indent": 3,
      "text": "If the connection is still active (i.e., it is not undergoing an implicit or explicit logout), an ABORT TASK MUST be issued on the same connection to which the task to be aborted is allegiant at the time the task management request is issued. If the connection is implicitly or explicitly logged out (i.e., no other request will be issued on the failing connection and no other response will be received on the failing connection), then an ABORT TASK function request may be issued on another connection. This task management request will then establish a new allegiance for the command to be aborted as well as abort it (i.e., the task to be aborted will not have to be retried or reassigned, and its status, if sent but not acknowledged, will be resent followed by the task management response).",
      "zh-cn": "If the connection is still active (i.e., it is not undergoing an implicit or explicit logout), an ABORT TASK MUST be issued on the same connection to which the task to be aborted is allegiant at the time the task management request is issued. If the connection is implicitly or explicitly logged out (i.e., no other request will be issued on the failing connection and no other response will be received on the failing connection), then an ABORT TASK function request may be issued on another connection. This task management request will then establish a new allegiance for the command to be aborted as well as abort it (i.e., the task to be aborted will not have to be retried or reassigned, and its status, if sent but not acknowledged, will be resent followed by the task management response)."
    },
    {
      "indent": 3,
      "text": "At the target, an ABORT TASK function MUST NOT be executed on a task management request; such a request MUST result in a task management response of \"Function rejected\".",
      "zh-cn": "At the target, an ABORT TASK function MUST NOT be executed on a task management request; such a request MUST result in a task management response of \"Function rejected\"."
    },
    {
      "indent": 3,
      "text": "For the LOGICAL UNIT RESET function, the target MUST behave as dictated by the Logical Unit Reset function in [SAM2].",
      "zh-cn": "For the LOGICAL UNIT RESET function, the target MUST behave as dictated by the Logical Unit Reset function in [SAM2]."
    },
    {
      "indent": 3,
      "text": "The implementation of the TARGET WARM RESET function and the TARGET COLD RESET function is OPTIONAL and, when implemented, should act as described below. The TARGET WARM RESET is also subject to SCSI access controls on the requesting initiator as defined in [SPC3]. When authorization fails at the target, the appropriate response as described in Section 11.6.1 MUST be returned by the target. The TARGET COLD RESET function is not subject to SCSI access controls, but its execution privileges may be managed by iSCSI mechanisms such as login authentication.",
      "zh-cn": "The implementation of the TARGET WARM RESET function and the TARGET COLD RESET function is OPTIONAL and, when implemented, should act as described below. The TARGET WARM RESET is also subject to SCSI access controls on the requesting initiator as defined in [SPC3]. When authorization fails at the target, the appropriate response as described in Section 11.6.1 MUST be returned by the target. The TARGET COLD RESET function is not subject to SCSI access controls, but its execution privileges may be managed by iSCSI mechanisms such as login authentication."
    },
    {
      "indent": 3,
      "text": "When executing the TARGET WARM RESET and TARGET COLD RESET functions, the target cancels all pending operations on all LUs known by the issuing initiator. Both functions are equivalent to the TARGET RESET function specified by [SAM2]. They can affect many other initiators logged in with the servicing SCSI target port.",
      "zh-cn": "When executing the TARGET WARM RESET and TARGET COLD RESET functions, the target cancels all pending operations on all LUs known by the issuing initiator. Both functions are equivalent to the TARGET RESET function specified by [SAM2]. They can affect many other initiators logged in with the servicing SCSI target port."
    },
    {
      "indent": 3,
      "text": "Additionally, the target MUST treat the TARGET COLD RESET function as a power-on event, thus terminating all of its TCP connections to all initiators (all sessions are terminated). For this reason, the service response (defined by [SAM2]) for this SCSI task management function may not be reliably delivered to the issuing initiator port.",
      "zh-cn": "Additionally, the target MUST treat the TARGET COLD RESET function as a power-on event, thus terminating all of its TCP connections to all initiators (all sessions are terminated). For this reason, the service response (defined by [SAM2]) for this SCSI task management function may not be reliably delivered to the issuing initiator port."
    },
    {
      "indent": 3,
      "text": "For the TASK REASSIGN function, the target should reassign the connection allegiance to this new connection (and thus resume iSCSI exchanges for the task). TASK REASSIGN MUST ONLY be received by the target after the connection on which the command was previously executing has been successfully logged out. The task management response MUST be issued before the reassignment becomes effective.",
      "zh-cn": "For the TASK REASSIGN function, the target should reassign the connection allegiance to this new connection (and thus resume iSCSI exchanges for the task). TASK REASSIGN MUST ONLY be received by the target after the connection on which the command was previously executing has been successfully logged out. The task management response MUST be issued before the reassignment becomes effective."
    },
    {
      "indent": 3,
      "text": "For additional usage semantics, see Section 7.2.",
      "zh-cn": "For additional usage semantics, see Section 7.2."
    },
    {
      "indent": 3,
      "text": "At the target, a TASK REASSIGN function request MUST NOT be executed to reassign the connection allegiance of a Task Management Function Request, an active text negotiation task, or a Logout task; such a request MUST result in a task management response of \"Function rejected\".",
      "zh-cn": "At the target, a TASK REASSIGN function request MUST NOT be executed to reassign the connection allegiance of a Task Management Function Request, an active text negotiation task, or a Logout task; such a request MUST result in a task management response of \"Function rejected\"."
    },
    {
      "indent": 3,
      "text": "TASK REASSIGN MUST be issued as an immediate command.",
      "zh-cn": "TASK REASSIGN MUST be issued as an immediate command."
    },
    {
      "indent": 0,
      "text": "11.5.2. TotalAHSLength and DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.5.2. TotalAHSLength and DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0.",
      "zh-cn": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.5.3. LUN",
      "section_title": true,
      "zh-cn": "11.5.3. LUN"
    },
    {
      "indent": 3,
      "text": "This field is required for functions that address a specific LU (ABORT TASK, CLEAR TASK SET, ABORT TASK SET, CLEAR ACA, LOGICAL UNIT RESET) and is reserved in all others.",
      "zh-cn": "This field is required for functions that address a specific LU (ABORT TASK, CLEAR TASK SET, ABORT TASK SET, CLEAR ACA, LOGICAL UNIT RESET) and is reserved in all others."
    },
    {
      "indent": 0,
      "text": "11.5.4. Referenced Task Tag",
      "section_title": true,
      "zh-cn": "11.5.4. Referenced Task Tag"
    },
    {
      "indent": 3,
      "text": "This is the Initiator Task Tag of the task to be aborted for the ABORT TASK function or reassigned for the TASK REASSIGN function. For all the other functions, this field MUST be set to the reserved value 0xffffffff.",
      "zh-cn": "This is the Initiator Task Tag of the task to be aborted for the ABORT TASK function or reassigned for the TASK REASSIGN function. For all the other functions, this field MUST be set to the reserved value 0xffffffff."
    },
    {
      "indent": 0,
      "text": "11.5.5. RefCmdSN",
      "section_title": true,
      "zh-cn": "11.5.5. RefCmdSN"
    },
    {
      "indent": 3,
      "text": "If an ABORT TASK is issued for a task created by an immediate command, then the RefCmdSN MUST be that of the task management request itself (i.e., the CmdSN and RefCmdSN are equal).",
      "zh-cn": "If an ABORT TASK is issued for a task created by an immediate command, then the RefCmdSN MUST be that of the task management request itself (i.e., the CmdSN and RefCmdSN are equal)."
    },
    {
      "indent": 3,
      "text": "For an ABORT TASK of a task created by a non-immediate command, the RefCmdSN MUST be set to the CmdSN of the task identified by the Referenced Task Tag field. Targets must use this field as described in Section 11.6.1 when the task identified by the Referenced Task Tag field is not with the target.",
      "zh-cn": "For an ABORT TASK of a task created by a non-immediate command, the RefCmdSN MUST be set to the CmdSN of the task identified by the Referenced Task Tag field. Targets must use this field as described in Section 11.6.1 when the task identified by the Referenced Task Tag field is not with the target."
    },
    {
      "indent": 3,
      "text": "Otherwise, this field is reserved.",
      "zh-cn": "Otherwise, this field is reserved."
    },
    {
      "indent": 0,
      "text": "11.5.6. ExpDataSN",
      "section_title": true,
      "zh-cn": "11.5.6. ExpDataSN"
    },
    {
      "indent": 3,
      "text": "For recovery purposes, the iSCSI target and initiator maintain a data acknowledgment reference number -- the first input DataSN number unacknowledged by the initiator. When issuing a new command, this number is set to 0. If the function is TASK REASSIGN, which establishes a new connection allegiance for a previously issued read or bidirectional command, the ExpDataSN will contain an updated data acknowledgment reference number or the value 0; the latter indicates that the data acknowledgment reference number is unchanged. The initiator MUST discard any data PDUs from the previous execution that it did not acknowledge, and the target MUST transmit all Data-In PDUs (if any) starting with the data acknowledgment reference number. The number of retransmitted PDUs may or may not be the same as the original transmission, depending on if there was a change in MaxRecvDataSegmentLength in the reassignment. The target MAY also send no more Data-In PDUs if all data has been acknowledged.",
      "zh-cn": "For recovery purposes, the iSCSI target and initiator maintain a data acknowledgment reference number -- the first input DataSN number unacknowledged by the initiator. When issuing a new command, this number is set to 0. If the function is TASK REASSIGN, which establishes a new connection allegiance for a previously issued read or bidirectional command, the ExpDataSN will contain an updated data acknowledgment reference number or the value 0; the latter indicates that the data acknowledgment reference number is unchanged. The initiator MUST discard any data PDUs from the previous execution that it did not acknowledge, and the target MUST transmit all Data-In PDUs (if any) starting with the data acknowledgment reference number. The number of retransmitted PDUs may or may not be the same as the original transmission, depending on if there was a change in MaxRecvDataSegmentLength in the reassignment. The target MAY also send no more Data-In PDUs if all data has been acknowledged."
    },
    {
      "indent": 3,
      "text": "The value of ExpDataSN MUST be 0 or higher than the DataSN of the last acknowledged Data-In PDU, but not larger than DataSN + 1 of the last Data-IN PDU sent by the target. Any other value MUST be ignored by the target.",
      "zh-cn": "The value of ExpDataSN MUST be 0 or higher than the DataSN of the last acknowledged Data-In PDU, but not larger than DataSN + 1 of the last Data-IN PDU sent by the target. Any other value MUST be ignored by the target."
    },
    {
      "indent": 3,
      "text": "For other functions, this field is reserved.",
      "zh-cn": "For other functions, this field is reserved."
    },
    {
      "indent": 0,
      "text": "11.6. Task Management Function Response",
      "section_title": true,
      "zh-cn": "11.6. Task Management Function Response"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x22      |1| Reserved    | Response      | Reserved      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------------------------------------------------------+\n 8/ Reserved                                                      /\n  /                                                               /\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "For the functions ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET COLD RESET, TARGET WARM RESET, and TASK REASSIGN, the target performs the requested task management function and sends a task management response back to the initiator. For TASK REASSIGN, the new connection allegiance MUST ONLY become effective at the target after the target issues the task management response.",
      "zh-cn": "For the functions ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET COLD RESET, TARGET WARM RESET, and TASK REASSIGN, the target performs the requested task management function and sends a task management response back to the initiator. For TASK REASSIGN, the new connection allegiance MUST ONLY become effective at the target after the target issues the task management response."
    },
    {
      "indent": 0,
      "text": "11.6.1. Response",
      "section_title": true,
      "zh-cn": "11.6.1. Response"
    },
    {
      "indent": 3,
      "text": "The target provides a response, which may take on the following values:",
      "zh-cn": "The target provides a response, which may take on the following values:"
    },
    {
      "indent": 5,
      "text": " 0 - Function complete 1 - Task does not exist 2 - LUN does not exist 3 - Task still allegiant 4 - Task allegiance reassignment not supported 5 - Task management function not supported 6 - Function authorization failed 255 - Function rejected",
      "zh-cn": " 0 - Function complete 1 - Task does not exist 2 - LUN does not exist 3 - Task still allegiant 4 - Task allegiance reassignment not supported 5 - Task management function not supported 6 - Function authorization failed 255 - Function rejected"
    },
    {
      "indent": 3,
      "text": "In addition to the above values, the value 7 is defined by [RFC7144].",
      "zh-cn": "In addition to the above values, the value 7 is defined by [RFC7144]."
    },
    {
      "indent": 3,
      "text": "For a discussion on the usage of response codes 3 and 4, see Section 7.2.2.",
      "zh-cn": "For a discussion on the usage of response codes 3 and 4, see Section 7.2.2."
    },
    {
      "indent": 3,
      "text": "For the TARGET COLD RESET and TARGET WARM RESET functions, the target cancels all pending operations across all LUs known to the issuing initiator. For the TARGET COLD RESET function, the target MUST then close all of its TCP connections to all initiators (terminates all sessions).",
      "zh-cn": "For the TARGET COLD RESET and TARGET WARM RESET functions, the target cancels all pending operations across all LUs known to the issuing initiator. For the TARGET COLD RESET function, the target MUST then close all of its TCP connections to all initiators (terminates all sessions)."
    },
    {
      "indent": 3,
      "text": "The mapping of the response code into a SCSI service response code value, if needed, is outside the scope of this document. However, in symbolic terms, Response values 0 and 1 map to the SCSI service response of FUNCTION COMPLETE. Response value 2 maps to the SCSI service response of INCORRECT LOGICAL UNIT NUMBER. All other Response values map to the SCSI service response of FUNCTION REJECTED. If a Task Management Function Response PDU does not arrive before the session is terminated, the SCSI service response is SERVICE DELIVERY OR TARGET FAILURE.",
      "zh-cn": "The mapping of the response code into a SCSI service response code value, if needed, is outside the scope of this document. However, in symbolic terms, Response values 0 and 1 map to the SCSI service response of FUNCTION COMPLETE. Response value 2 maps to the SCSI service response of INCORRECT LOGICAL UNIT NUMBER. All other Response values map to the SCSI service response of FUNCTION REJECTED. If a Task Management Function Response PDU does not arrive before the session is terminated, the SCSI service response is SERVICE DELIVERY OR TARGET FAILURE."
    },
    {
      "indent": 3,
      "text": "The response to ABORT TASK SET and CLEAR TASK SET MUST only be issued by the target after all of the commands affected have been received by the target, the corresponding task management functions have been executed by the SCSI target, and the delivery of all responses delivered until the task management function completion has been confirmed (acknowledged through the ExpStatSN) by the initiator on all connections of this session. For the exact timeline of events, refer to Sections 4.2.3.3 and 4.2.3.4.",
      "zh-cn": "The response to ABORT TASK SET and CLEAR TASK SET MUST only be issued by the target after all of the commands affected have been received by the target, the corresponding task management functions have been executed by the SCSI target, and the delivery of all responses delivered until the task management function completion has been confirmed (acknowledged through the ExpStatSN) by the initiator on all connections of this session. For the exact timeline of events, refer to Sections 4.2.3.3 and 4.2.3.4."
    },
    {
      "indent": 3,
      "text": "For the ABORT TASK function,",
      "zh-cn": "For the ABORT TASK function,"
    },
    {
      "indent": 6,
      "text": "a) if the Referenced Task Tag identifies a valid task leading to a successful termination, then targets must return the \"Function complete\" response.",
      "zh-cn": "a) if the Referenced Task Tag identifies a valid task leading to a successful termination, then targets must return the \"Function complete\" response."
    },
    {
      "indent": 6,
      "text": "b) if the Referenced Task Tag does not identify an existing task but the CmdSN indicated by the RefCmdSN field in the Task Management Function Request is within the valid CmdSN window and less than the CmdSN of the Task Management Function Request itself, then targets must consider the CmdSN as received and return the \"Function complete\" response.",
      "zh-cn": "b) if the Referenced Task Tag does not identify an existing task but the CmdSN indicated by the RefCmdSN field in the Task Management Function Request is within the valid CmdSN window and less than the CmdSN of the Task Management Function Request itself, then targets must consider the CmdSN as received and return the \"Function complete\" response."
    },
    {
      "indent": 6,
      "text": "c) if the Referenced Task Tag does not identify an existing task and the CmdSN indicated by the RefCmdSN field in the Task Management Function Request is outside the valid CmdSN window, then targets must return the \"Task does not exist\" response.",
      "zh-cn": "c) if the Referenced Task Tag does not identify an existing task and the CmdSN indicated by the RefCmdSN field in the Task Management Function Request is outside the valid CmdSN window, then targets must return the \"Task does not exist\" response."
    },
    {
      "indent": 3,
      "text": "For response semantics on function types that can potentially impact multiple active tasks on the target, see Section 4.2.3.",
      "zh-cn": "For response semantics on function types that can potentially impact multiple active tasks on the target, see Section 4.2.3."
    },
    {
      "indent": 0,
      "text": "11.6.2. TotalAHSLength and DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.6.2. TotalAHSLength and DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0.",
      "zh-cn": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.7. SCSI Data-Out and SCSI Data-In",
      "section_title": true,
      "zh-cn": "11.7. SCSI Data-Out and SCSI Data-In"
    },
    {
      "indent": 3,
      "text": "The SCSI Data-Out PDU for write operations has the following format:",
      "zh-cn": "The SCSI Data-Out PDU for write operations has the following format:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x05      |F| Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n36| DataSN                                                        |\n  +---------------+---------------+---------------+---------------+\n40| Buffer Offset                                                 |\n  +---------------+---------------+---------------+---------------+\n44| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment                                                   /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The SCSI Data-In PDU for read operations has the following format:",
      "zh-cn": "The SCSI Data-In PDU for read operations has the following format:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x25      |F|A|0 0 0|O|U|S| Reserved      |Status or Rsvd |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| StatSN or Reserved                                            |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| DataSN                                                        |\n  +---------------+---------------+---------------+---------------+\n40| Buffer Offset                                                 |\n  +---------------+---------------+---------------+---------------+\n44| Residual Count                                                |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment                                                   /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Status can accompany the last Data-In PDU if the command did not end with an exception (i.e., the status is \"good status\" -- GOOD, CONDITION MET, or INTERMEDIATE-CONDITION MET). The presence of status (and of a residual count) is signaled via the S flag bit. Although targets MAY choose to send even non-exception status in separate responses, initiators MUST support non-exception status in Data-In PDUs.",
      "zh-cn": "Status can accompany the last Data-In PDU if the command did not end with an exception (i.e., the status is \"good status\" -- GOOD, CONDITION MET, or INTERMEDIATE-CONDITION MET). The presence of status (and of a residual count) is signaled via the S flag bit. Although targets MAY choose to send even non-exception status in separate responses, initiators MUST support non-exception status in Data-In PDUs."
    },
    {
      "indent": 0,
      "text": "11.7.1. F (Final) Bit",
      "section_title": true,
      "zh-cn": "11.7.1. F (Final) Bit"
    },
    {
      "indent": 3,
      "text": "For outgoing data, this bit is 1 for the last PDU of unsolicited data or the last PDU of a sequence that answers an R2T.",
      "zh-cn": "For outgoing data, this bit is 1 for the last PDU of unsolicited data or the last PDU of a sequence that answers an R2T."
    },
    {
      "indent": 3,
      "text": "For incoming data, this bit is 1 for the last input (read) data PDU of a sequence. Input can be split into several sequences, each having its own F bit. Splitting the data stream into sequences does not affect DataSN counting on Data-In PDUs. It MAY be used as a \"change direction\" indication for bidirectional operations that need such a change.",
      "zh-cn": "For incoming data, this bit is 1 for the last input (read) data PDU of a sequence. Input can be split into several sequences, each having its own F bit. Splitting the data stream into sequences does not affect DataSN counting on Data-In PDUs. It MAY be used as a \"change direction\" indication for bidirectional operations that need such a change."
    },
    {
      "indent": 3,
      "text": "DataSegmentLength MUST NOT exceed MaxRecvDataSegmentLength for the direction it is sent, and the total of all the DataSegmentLength of all PDUs in a sequence MUST NOT exceed MaxBurstLength (or FirstBurstLength for unsolicited data). However, the number of individual PDUs in a sequence (or in total) may be higher than the ratio of MaxBurstLength (or FirstBurstLength) to MaxRecvDataSegmentLength (as PDUs may be limited in length by the capabilities of the sender). Using a DataSegmentLength of 0 may increase beyond what is reasonable for the number of PDUs and should therefore be avoided.",
      "zh-cn": "DataSegmentLength MUST NOT exceed MaxRecvDataSegmentLength for the direction it is sent, and the total of all the DataSegmentLength of all PDUs in a sequence MUST NOT exceed MaxBurstLength (or FirstBurstLength for unsolicited data). However, the number of individual PDUs in a sequence (or in total) may be higher than the ratio of MaxBurstLength (or FirstBurstLength) to MaxRecvDataSegmentLength (as PDUs may be limited in length by the capabilities of the sender). Using a DataSegmentLength of 0 may increase beyond what is reasonable for the number of PDUs and should therefore be avoided."
    },
    {
      "indent": 3,
      "text": "For bidirectional operations, the F bit is 1 for both the end of the input sequences and the end of the output sequences.",
      "zh-cn": "For bidirectional operations, the F bit is 1 for both the end of the input sequences and the end of the output sequences."
    },
    {
      "indent": 0,
      "text": "11.7.2. A (Acknowledge) Bit",
      "section_title": true,
      "zh-cn": "11.7.2. A (Acknowledge) Bit"
    },
    {
      "indent": 3,
      "text": "For sessions with ErrorRecoveryLevel=1 or higher, the target sets this bit to 1 to indicate that it requests a positive acknowledgment from the initiator for the data received. The target should use the A bit moderately; it MAY only set the A bit to 1 once every MaxBurstLength bytes, or on the last Data-In PDU that concludes the entire requested read data transfer for the task from the target's perspective, and it MUST NOT do so more frequently. The target MUST NOT set to 1 the A bit for sessions with ErrorRecoveryLevel=0. The initiator MUST ignore the A bit set to 1 for sessions with ErrorRecoveryLevel=0.",
      "zh-cn": "For sessions with ErrorRecoveryLevel=1 or higher, the target sets this bit to 1 to indicate that it requests a positive acknowledgment from the initiator for the data received. The target should use the A bit moderately; it MAY only set the A bit to 1 once every MaxBurstLength bytes, or on the last Data-In PDU that concludes the entire requested read data transfer for the task from the target's perspective, and it MUST NOT do so more frequently. The target MUST NOT set to 1 the A bit for sessions with ErrorRecoveryLevel=0. The initiator MUST ignore the A bit set to 1 for sessions with ErrorRecoveryLevel=0."
    },
    {
      "indent": 3,
      "text": "On receiving a Data-In PDU with the A bit set to 1 on a session with ErrorRecoveryLevel greater than 0, if there are no holes in the read data until that Data-In PDU, the initiator MUST issue a SNACK of type DataACK, except when it is able to acknowledge the status for the task immediately via the ExpStatSN on other outbound PDUs if the status for the task is also received. In the latter case (acknowledgment through the ExpStatSN), sending a SNACK of type DataACK in response to the A bit is OPTIONAL, but if it is done, it must not be sent after the status acknowledgment through the",
      "zh-cn": "On receiving a Data-In PDU with the A bit set to 1 on a session with ErrorRecoveryLevel greater than 0, if there are no holes in the read data until that Data-In PDU, the initiator MUST issue a SNACK of type DataACK, except when it is able to acknowledge the status for the task immediately via the ExpStatSN on other outbound PDUs if the status for the task is also received. In the latter case (acknowledgment through the ExpStatSN), sending a SNACK of type DataACK in response to the A bit is OPTIONAL, but if it is done, it must not be sent after the status acknowledgment through the"
    },
    {
      "indent": 3,
      "text": "ExpStatSN. If the initiator has detected holes in the read data prior to that Data-In PDU, it MUST postpone issuing the SNACK of type DataACK until the holes are filled. An initiator also MUST NOT acknowledge the status for the task before those holes are filled. A status acknowledgment for a task that generated the Data-In PDUs is considered by the target as an implicit acknowledgment of the Data-In PDUs if such an acknowledgment was requested by the target.",
      "zh-cn": "ExpStatSN. If the initiator has detected holes in the read data prior to that Data-In PDU, it MUST postpone issuing the SNACK of type DataACK until the holes are filled. An initiator also MUST NOT acknowledge the status for the task before those holes are filled. A status acknowledgment for a task that generated the Data-In PDUs is considered by the target as an implicit acknowledgment of the Data-In PDUs if such an acknowledgment was requested by the target."
    },
    {
      "indent": 0,
      "text": "11.7.3. Flags (Byte 1)",
      "section_title": true,
      "zh-cn": "11.7.3. Flags (Byte 1)"
    },
    {
      "indent": 3,
      "text": "The last SCSI data packet sent from a target to an initiator for a SCSI command that completed successfully (with a status of GOOD, CONDITION MET, INTERMEDIATE, or INTERMEDIATE-CONDITION MET) may also optionally contain the Status for the data transfer. In this case, Sense Data cannot be sent together with the Command Status. If the command is completed with an error, then the response and sense data MUST be sent in a SCSI Response PDU (i.e., MUST NOT be sent in a SCSI data packet). For bidirectional commands, the status MUST be sent in a SCSI Response PDU.",
      "zh-cn": "The last SCSI data packet sent from a target to an initiator for a SCSI command that completed successfully (with a status of GOOD, CONDITION MET, INTERMEDIATE, or INTERMEDIATE-CONDITION MET) may also optionally contain the Status for the data transfer. In this case, Sense Data cannot be sent together with the Command Status. If the command is completed with an error, then the response and sense data MUST be sent in a SCSI Response PDU (i.e., MUST NOT be sent in a SCSI data packet). For bidirectional commands, the status MUST be sent in a SCSI Response PDU."
    },
    {
      "indent": 6,
      "text": "bit 2-4 - Reserved.",
      "zh-cn": "bit 2-4 - Reserved."
    },
    {
      "indent": 6,
      "text": "bit 5-6 - used the same as in a SCSI Response. These bits are only valid when S is set to 1. For details, see Section 11.4.1.",
      "zh-cn": "bit 5-6 - used the same as in a SCSI Response. These bits are only valid when S is set to 1. For details, see Section 11.4.1."
    },
    {
      "indent": 6,
      "text": "bit 7 S (status) - set to indicate that the Command Status field contains status. If this bit is set to 1, the F bit MUST also be set to 1.",
      "zh-cn": "bit 7 S (status) - set to indicate that the Command Status field contains status. If this bit is set to 1, the F bit MUST also be set to 1."
    },
    {
      "indent": 3,
      "text": "The fields StatSN, Status, and Residual Count only have meaningful content if the S bit is set to 1. The values for these fields are defined in Section 11.4.",
      "zh-cn": "The fields StatSN, Status, and Residual Count only have meaningful content if the S bit is set to 1. The values for these fields are defined in Section 11.4."
    },
    {
      "indent": 0,
      "text": "11.7.4. Target Transfer Tag and LUN",
      "section_title": true,
      "zh-cn": "11.7.4. Target Transfer Tag and LUN"
    },
    {
      "indent": 3,
      "text": "On outgoing data, the Target Transfer Tag is provided to the target if the transfer is honoring an R2T. In this case, the Target Transfer Tag field is a replica of the Target Transfer Tag provided with the R2T.",
      "zh-cn": "On outgoing data, the Target Transfer Tag is provided to the target if the transfer is honoring an R2T. In this case, the Target Transfer Tag field is a replica of the Target Transfer Tag provided with the R2T."
    },
    {
      "indent": 3,
      "text": "On incoming data, the Target Transfer Tag and LUN MUST be provided by the target if the A bit is set to 1; otherwise, they are reserved. The Target Transfer Tag and LUN are copied by the initiator into the SNACK of type DataACK that it issues as a result of receiving a SCSI Data-In PDU with the A bit set to 1.",
      "zh-cn": "On incoming data, the Target Transfer Tag and LUN MUST be provided by the target if the A bit is set to 1; otherwise, they are reserved. The Target Transfer Tag and LUN are copied by the initiator into the SNACK of type DataACK that it issues as a result of receiving a SCSI Data-In PDU with the A bit set to 1."
    },
    {
      "indent": 3,
      "text": "The Target Transfer Tag values are not specified by this protocol, except that the value 0xffffffff is reserved and means that the Target Transfer Tag is not supplied. If the Target Transfer Tag is provided, then the LUN field MUST hold a valid value and be consistent with whatever was specified with the command; otherwise, the LUN field is reserved.",
      "zh-cn": "The Target Transfer Tag values are not specified by this protocol, except that the value 0xffffffff is reserved and means that the Target Transfer Tag is not supplied. If the Target Transfer Tag is provided, then the LUN field MUST hold a valid value and be consistent with whatever was specified with the command; otherwise, the LUN field is reserved."
    },
    {
      "indent": 0,
      "text": "11.7.5. DataSN",
      "section_title": true,
      "zh-cn": "11.7.5. DataSN"
    },
    {
      "indent": 3,
      "text": "For input (read) or bidirectional Data-In PDUs, the DataSN is the input PDU number within the data transfer for the command identified by the Initiator Task Tag.",
      "zh-cn": "For input (read) or bidirectional Data-In PDUs, the DataSN is the input PDU number within the data transfer for the command identified by the Initiator Task Tag."
    },
    {
      "indent": 3,
      "text": "R2T and Data-In PDUs, in the context of bidirectional commands, share the numbering sequence (see Section 4.2.2.4).",
      "zh-cn": "R2T and Data-In PDUs, in the context of bidirectional commands, share the numbering sequence (see Section 4.2.2.4)."
    },
    {
      "indent": 3,
      "text": "For output (write) data PDUs, the DataSN is the Data-Out PDU number within the current output sequence. Either the current output sequence is identified by the Initiator Task Tag (for unsolicited data) or it is a data sequence generated for one R2T (for data solicited through R2T).",
      "zh-cn": "For output (write) data PDUs, the DataSN is the Data-Out PDU number within the current output sequence. Either the current output sequence is identified by the Initiator Task Tag (for unsolicited data) or it is a data sequence generated for one R2T (for data solicited through R2T)."
    },
    {
      "indent": 0,
      "text": "11.7.6. Buffer Offset",
      "section_title": true,
      "zh-cn": "11.7.6. Buffer Offset"
    },
    {
      "indent": 3,
      "text": "The Buffer Offset field contains the offset of this PDU payload data within the complete data transfer. The sum of the buffer offset and length should not exceed the expected transfer length for the command.",
      "zh-cn": "The Buffer Offset field contains the offset of this PDU payload data within the complete data transfer. The sum of the buffer offset and length should not exceed the expected transfer length for the command."
    },
    {
      "indent": 3,
      "text": "The order of data PDUs within a sequence is determined by DataPDUInOrder. When set to Yes, it means that PDUs have to be in increasing buffer offset order and overlays are forbidden.",
      "zh-cn": "The order of data PDUs within a sequence is determined by DataPDUInOrder. When set to Yes, it means that PDUs have to be in increasing buffer offset order and overlays are forbidden."
    },
    {
      "indent": 3,
      "text": "The ordering between sequences is determined by DataSequenceInOrder. When set to Yes, it means that sequences have to be in increasing buffer offset order and overlays are forbidden.",
      "zh-cn": "The ordering between sequences is determined by DataSequenceInOrder. When set to Yes, it means that sequences have to be in increasing buffer offset order and overlays are forbidden."
    },
    {
      "indent": 0,
      "text": "11.7.7. DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.7.7. DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "This is the data payload length of a SCSI Data-In or SCSI Data-Out PDU. The sending of 0-length data segments should be avoided, but initiators and targets MUST be able to properly receive 0-length data segments.",
      "zh-cn": "This is the data payload length of a SCSI Data-In or SCSI Data-Out PDU. The sending of 0-length data segments should be avoided, but initiators and targets MUST be able to properly receive 0-length data segments."
    },
    {
      "indent": 3,
      "text": "The data segments of Data-In and Data-Out PDUs SHOULD be filled to the integer number of 4-byte words (real payload), unless the F bit is set to 1.",
      "zh-cn": "The data segments of Data-In and Data-Out PDUs SHOULD be filled to the integer number of 4-byte words (real payload), unless the F bit is set to 1."
    },
    {
      "indent": 0,
      "text": "11.8. Ready To Transfer (R2T)",
      "section_title": true,
      "zh-cn": "11.8. Ready To Transfer (R2T)"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x31      |1| Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN                                                           |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag                                           |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| R2TSN                                                         |\n  +---------------+---------------+---------------+---------------+\n40| Buffer Offset                                                 |\n  +---------------+---------------+---------------+---------------+\n44| Desired Data Transfer Length                                  |\n  +---------------------------------------------------------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "When an initiator has submitted a SCSI command with data that passes from the initiator to the target (write), the target may specify which blocks of data it is ready to receive. The target may request that the data blocks be delivered in whichever order is convenient for the target at that particular instant. This information is passed from the target to the initiator in the Ready To Transfer (R2T) PDU.",
      "zh-cn": "When an initiator has submitted a SCSI command with data that passes from the initiator to the target (write), the target may specify which blocks of data it is ready to receive. The target may request that the data blocks be delivered in whichever order is convenient for the target at that particular instant. This information is passed from the target to the initiator in the Ready To Transfer (R2T) PDU."
    },
    {
      "indent": 3,
      "text": "In order to allow write operations without an explicit initial R2T, the initiator and target MUST have negotiated the key InitialR2T to No during login.",
      "zh-cn": "In order to allow write operations without an explicit initial R2T, the initiator and target MUST have negotiated the key InitialR2T to No during login."
    },
    {
      "indent": 3,
      "text": "An R2T MAY be answered with one or more SCSI Data-Out PDUs with a matching Target Transfer Tag. If an R2T is answered with a single Data-Out PDU, the buffer offset in the data PDU MUST be the same as",
      "zh-cn": "An R2T MAY be answered with one or more SCSI Data-Out PDUs with a matching Target Transfer Tag. If an R2T is answered with a single Data-Out PDU, the buffer offset in the data PDU MUST be the same as"
    },
    {
      "indent": 3,
      "text": "the one specified by the R2T, and the data length of the data PDU MUST be the same as the Desired Data Transfer Length specified in the R2T. If the R2T is answered with a sequence of data PDUs, the buffer offset and length MUST be within the range of those specified by the R2T, and the last PDU MUST have the F bit set to 1. If the last PDU (marked with the F bit) is received before the Desired Data Transfer Length is transferred, a target MAY choose to reject that PDU with the \"Protocol Error\" reason code. DataPDUInOrder governs the Data-Out PDU ordering. If DataPDUInOrder is set to Yes, the buffer offsets and lengths for consecutive PDUs MUST form a continuous non-overlapping range, and the PDUs MUST be sent in increasing offset order.",
      "zh-cn": "the one specified by the R2T, and the data length of the data PDU MUST be the same as the Desired Data Transfer Length specified in the R2T. If the R2T is answered with a sequence of data PDUs, the buffer offset and length MUST be within the range of those specified by the R2T, and the last PDU MUST have the F bit set to 1. If the last PDU (marked with the F bit) is received before the Desired Data Transfer Length is transferred, a target MAY choose to reject that PDU with the \"Protocol Error\" reason code. DataPDUInOrder governs the Data-Out PDU ordering. If DataPDUInOrder is set to Yes, the buffer offsets and lengths for consecutive PDUs MUST form a continuous non-overlapping range, and the PDUs MUST be sent in increasing offset order."
    },
    {
      "indent": 3,
      "text": "The target may send several R2T PDUs. It therefore can have a number of pending data transfers. The number of outstanding R2T PDUs is limited by the value of the negotiated key MaxOutstandingR2T. Within a task, outstanding R2Ts MUST be fulfilled by the initiator in the order in which they were received.",
      "zh-cn": "The target may send several R2T PDUs. It therefore can have a number of pending data transfers. The number of outstanding R2T PDUs is limited by the value of the negotiated key MaxOutstandingR2T. Within a task, outstanding R2Ts MUST be fulfilled by the initiator in the order in which they were received."
    },
    {
      "indent": 3,
      "text": "R2T PDUs MAY also be used to recover Data-Out PDUs. Such an R2T (Recovery-R2T) is generated by a target upon detecting the loss of one or more Data-Out PDUs due to:",
      "zh-cn": "R2T PDUs MAY also be used to recover Data-Out PDUs. Such an R2T (Recovery-R2T) is generated by a target upon detecting the loss of one or more Data-Out PDUs due to:"
    },
    {
      "indent": 6,
      "text": "- Digest error",
      "zh-cn": "- Digest error"
    },
    {
      "indent": 6,
      "text": "- Sequence error",
      "zh-cn": "- Sequence error"
    },
    {
      "indent": 6,
      "text": "- Sequence reception timeout",
      "zh-cn": "- Sequence reception timeout"
    },
    {
      "indent": 3,
      "text": "A Recovery-R2T carries the next unused R2TSN but requests part of or the entire data burst that an earlier R2T (with a lower R2TSN) had already requested.",
      "zh-cn": "A Recovery-R2T carries the next unused R2TSN but requests part of or the entire data burst that an earlier R2T (with a lower R2TSN) had already requested."
    },
    {
      "indent": 3,
      "text": "DataSequenceInOrder governs the buffer offset ordering in consecutive R2Ts. If DataSequenceInOrder is Yes, then consecutive R2Ts MUST refer to continuous non-overlapping ranges, except for Recovery-R2Ts.",
      "zh-cn": "DataSequenceInOrder governs the buffer offset ordering in consecutive R2Ts. If DataSequenceInOrder is Yes, then consecutive R2Ts MUST refer to continuous non-overlapping ranges, except for Recovery-R2Ts."
    },
    {
      "indent": 0,
      "text": "11.8.1. TotalAHSLength and DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.8.1. TotalAHSLength and DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0.",
      "zh-cn": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.8.2. R2TSN",
      "section_title": true,
      "zh-cn": "11.8.2. R2TSN"
    },
    {
      "indent": 3,
      "text": "R2TSN is the R2T PDU input PDU number within the command identified by the Initiator Task Tag.",
      "zh-cn": "R2TSN is the R2T PDU input PDU number within the command identified by the Initiator Task Tag."
    },
    {
      "indent": 3,
      "text": "For bidirectional commands, R2T and Data-In PDUs share the input PDU numbering sequence (see Section 4.2.2.4).",
      "zh-cn": "For bidirectional commands, R2T and Data-In PDUs share the input PDU numbering sequence (see Section 4.2.2.4)."
    },
    {
      "indent": 0,
      "text": "11.8.3. StatSN",
      "section_title": true,
      "zh-cn": "11.8.3. StatSN"
    },
    {
      "indent": 3,
      "text": "The StatSN field will contain the next StatSN. The StatSN for this connection is not advanced after this PDU is sent.",
      "zh-cn": "The StatSN field will contain the next StatSN. The StatSN for this connection is not advanced after this PDU is sent."
    },
    {
      "indent": 0,
      "text": "11.8.4. Desired Data Transfer Length and Buffer Offset",
      "section_title": true,
      "zh-cn": "11.8.4. Desired Data Transfer Length and Buffer Offset"
    },
    {
      "indent": 3,
      "text": "The target specifies how many bytes it wants the initiator to send because of this R2T PDU. The target may request the data from the initiator in several chunks, not necessarily in the original order of the data. The target therefore also specifies a buffer offset that indicates the point at which the data transfer should begin, relative to the beginning of the total data transfer. The Desired Data Transfer Length MUST NOT be 0 and MUST NOT exceed MaxBurstLength.",
      "zh-cn": "The target specifies how many bytes it wants the initiator to send because of this R2T PDU. The target may request the data from the initiator in several chunks, not necessarily in the original order of the data. The target therefore also specifies a buffer offset that indicates the point at which the data transfer should begin, relative to the beginning of the total data transfer. The Desired Data Transfer Length MUST NOT be 0 and MUST NOT exceed MaxBurstLength."
    },
    {
      "indent": 0,
      "text": "11.8.5. Target Transfer Tag",
      "section_title": true,
      "zh-cn": "11.8.5. Target Transfer Tag"
    },
    {
      "indent": 3,
      "text": "The target assigns its own tag to each R2T request that it sends to the initiator. This tag can be used by the target to easily identify the data it receives. The Target Transfer Tag and LUN are copied in the outgoing data PDUs and are only used by the target. There is no protocol rule about the Target Transfer Tag except that the value 0xffffffff is reserved and MUST NOT be sent by a target in an R2T.",
      "zh-cn": "The target assigns its own tag to each R2T request that it sends to the initiator. This tag can be used by the target to easily identify the data it receives. The Target Transfer Tag and LUN are copied in the outgoing data PDUs and are only used by the target. There is no protocol rule about the Target Transfer Tag except that the value 0xffffffff is reserved and MUST NOT be sent by a target in an R2T."
    },
    {
      "indent": 0,
      "text": "11.9. Asynchronous Message",
      "section_title": true,
      "zh-cn": "11.9. Asynchronous Message"
    },
    {
      "indent": 3,
      "text": "An Asynchronous Message may be sent from the target to the initiator without corresponding to a particular command. The target specifies the reason for the event and sense data.",
      "zh-cn": "An Asynchronous Message may be sent from the target to the initiator without corresponding to a particular command. The target specifies the reason for the event and sense data."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x32      |1| Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| 0xffffffff                                                    |\n  +---------------+---------------+---------------+---------------+\n20| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| AsyncEvent    | AsyncVCode    | Parameter1 or Reserved        |\n  +---------------+---------------+---------------+---------------+\n40| Parameter2 or Reserved        | Parameter3 or Reserved        |\n  +---------------+---------------+---------------+---------------+\n44| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment - Sense Data and iSCSI Event Data                 /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Some Asynchronous Messages are strictly related to iSCSI, while others are related to SCSI [SAM2].",
      "zh-cn": "Some Asynchronous Messages are strictly related to iSCSI, while others are related to SCSI [SAM2]."
    },
    {
      "indent": 3,
      "text": "The StatSN counts this PDU as an acknowledgeable event (the StatSN is advanced), which allows for initiator and target state synchronization.",
      "zh-cn": "The StatSN counts this PDU as an acknowledgeable event (the StatSN is advanced), which allows for initiator and target state synchronization."
    },
    {
      "indent": 0,
      "text": "11.9.1. AsyncEvent",
      "section_title": true,
      "zh-cn": "11.9.1. AsyncEvent"
    },
    {
      "indent": 3,
      "text": "The codes used for iSCSI Asynchronous Messages (events) are:",
      "zh-cn": "The codes used for iSCSI Asynchronous Messages (events) are:"
    },
    {
      "indent": 8,
      "text": "0 (SCSI Async Event) - a SCSI asynchronous event is reported in the sense data. Sense Data that accompanies the report, in the data segment, identifies the condition. The sending of a SCSI event (\"asynchronous event reporting\" in SCSI terminology) is dependent on the target support for SCSI asynchronous event reporting (see [SAM2]) as indicated in the standard INQUIRY data (see [SPC3]). Its use may be enabled by parameters in the SCSI Control mode page (see [SPC3]).",
      "zh-cn": "0 (SCSI Async Event) - a SCSI asynchronous event is reported in the sense data. Sense Data that accompanies the report, in the data segment, identifies the condition. The sending of a SCSI event (\"asynchronous event reporting\" in SCSI terminology) is dependent on the target support for SCSI asynchronous event reporting (see [SAM2]) as indicated in the standard INQUIRY data (see [SPC3]). Its use may be enabled by parameters in the SCSI Control mode page (see [SPC3])."
    },
    {
      "indent": 8,
      "text": "1 (Logout Request) - the target requests Logout. This Async Message MUST be sent on the same connection as the one requesting to be logged out. The initiator MUST honor this request by issuing a Logout as early as possible but no later than Parameter3 seconds. The initiator MUST send a Logout with a reason code of \"close the connection\" OR \"close the session\" to close all the connections. Once this message is received, the initiator SHOULD NOT issue new iSCSI commands on the connection to be logged out. The target MAY reject any new I/O requests that it receives after this message with the reason code \"Waiting for Logout\". If the initiator does not log out in Parameter3 seconds, the target should send an Async PDU with iSCSI event code \"Dropped the connection\" if possible or simply terminate the transport connection. Parameter1 and Parameter2 are reserved.",
      "zh-cn": "1 (Logout Request) - the target requests Logout. This Async Message MUST be sent on the same connection as the one requesting to be logged out. The initiator MUST honor this request by issuing a Logout as early as possible but no later than Parameter3 seconds. The initiator MUST send a Logout with a reason code of \"close the connection\" OR \"close the session\" to close all the connections. Once this message is received, the initiator SHOULD NOT issue new iSCSI commands on the connection to be logged out. The target MAY reject any new I/O requests that it receives after this message with the reason code \"Waiting for Logout\". If the initiator does not log out in Parameter3 seconds, the target should send an Async PDU with iSCSI event code \"Dropped the connection\" if possible or simply terminate the transport connection. Parameter1 and Parameter2 are reserved."
    },
    {
      "indent": 8,
      "text": "2 (Connection Drop Notification) - the target indicates that it will drop the connection.",
      "zh-cn": "2 (Connection Drop Notification) - the target indicates that it will drop the connection."
    },
    {
      "indent": 10,
      "text": "The Parameter1 field indicates the CID of the connection that is going to be dropped.",
      "zh-cn": "The Parameter1 field indicates the CID of the connection that is going to be dropped."
    },
    {
      "indent": 10,
      "text": "The Parameter2 field (Time2Wait) indicates, in seconds, the minimum time to wait before attempting to reconnect or reassign.",
      "zh-cn": "The Parameter2 field (Time2Wait) indicates, in seconds, the minimum time to wait before attempting to reconnect or reassign."
    },
    {
      "indent": 10,
      "text": "The Parameter3 field (Time2Retain) indicates the maximum time allowed to reassign commands after the initial wait (in Parameter2).",
      "zh-cn": "The Parameter3 field (Time2Retain) indicates the maximum time allowed to reassign commands after the initial wait (in Parameter2)."
    },
    {
      "indent": 10,
      "text": "If the initiator does not attempt to reconnect and/or reassign the outstanding commands within the time specified by Parameter3, or if Parameter3 is 0, the target will terminate",
      "zh-cn": "If the initiator does not attempt to reconnect and/or reassign the outstanding commands within the time specified by Parameter3, or if Parameter3 is 0, the target will terminate"
    },
    {
      "indent": 10,
      "text": "all outstanding commands on this connection. In this case, no other responses should be expected from the target for the outstanding commands on this connection.",
      "zh-cn": "all outstanding commands on this connection. In this case, no other responses should be expected from the target for the outstanding commands on this connection."
    },
    {
      "indent": 10,
      "text": "A value of 0 for Parameter2 indicates that reconnect can be attempted immediately.",
      "zh-cn": "A value of 0 for Parameter2 indicates that reconnect can be attempted immediately."
    },
    {
      "indent": 8,
      "text": "3 (Session Drop Notification) - the target indicates that it will drop all the connections of this session.",
      "zh-cn": "3 (Session Drop Notification) - the target indicates that it will drop all the connections of this session."
    },
    {
      "indent": 10,
      "text": "The Parameter1 field is reserved.",
      "zh-cn": "The Parameter1 field is reserved."
    },
    {
      "indent": 10,
      "text": "The Parameter2 field (Time2Wait) indicates, in seconds, the minimum time to wait before attempting to reconnect.",
      "zh-cn": "The Parameter2 field (Time2Wait) indicates, in seconds, the minimum time to wait before attempting to reconnect."
    },
    {
      "indent": 10,
      "text": "The Parameter3 field (Time2Retain) indicates the maximum time allowed to reassign commands after the initial wait (in Parameter2).",
      "zh-cn": "The Parameter3 field (Time2Retain) indicates the maximum time allowed to reassign commands after the initial wait (in Parameter2)."
    },
    {
      "indent": 10,
      "text": "If the initiator does not attempt to reconnect and/or reassign the outstanding commands within the time specified by Parameter3, or if Parameter3 is 0, the session is terminated. In this case, the target will terminate all outstanding commands in this session; no other responses should be expected from the target for the outstanding commands in this session. A value of 0 for Parameter2 indicates that reconnect can be attempted immediately.",
      "zh-cn": "If the initiator does not attempt to reconnect and/or reassign the outstanding commands within the time specified by Parameter3, or if Parameter3 is 0, the session is terminated. In this case, the target will terminate all outstanding commands in this session; no other responses should be expected from the target for the outstanding commands in this session. A value of 0 for Parameter2 indicates that reconnect can be attempted immediately."
    },
    {
      "indent": 8,
      "text": "4 (Negotiation Request) - the target requests parameter negotiation on this connection. The initiator MUST honor this request by issuing a Text Request (that can be empty) on the same connection as early as possible, but no later than Parameter3 seconds, unless a Text Request is already pending on the connection, or by issuing a Logout Request. If the initiator does not issue a Text Request, the target may reissue the Asynchronous Message requesting parameter negotiation.",
      "zh-cn": "4 (Negotiation Request) - the target requests parameter negotiation on this connection. The initiator MUST honor this request by issuing a Text Request (that can be empty) on the same connection as early as possible, but no later than Parameter3 seconds, unless a Text Request is already pending on the connection, or by issuing a Logout Request. If the initiator does not issue a Text Request, the target may reissue the Asynchronous Message requesting parameter negotiation."
    },
    {
      "indent": 8,
      "text": "5 (Task Termination) - all active tasks for a LU with a matching LUN field in the Async Message PDU are being terminated. The receiving initiator iSCSI layer MUST respond to this message by taking the following steps, in order:",
      "zh-cn": "5 (Task Termination) - all active tasks for a LU with a matching LUN field in the Async Message PDU are being terminated. The receiving initiator iSCSI layer MUST respond to this message by taking the following steps, in order:"
    },
    {
      "indent": 10,
      "text": "- Stop Data-Out transfers on that connection for all active TTTs for the affected LUN quoted in the Async Message PDU.",
      "zh-cn": "- Stop Data-Out transfers on that connection for all active TTTs for the affected LUN quoted in the Async Message PDU."
    },
    {
      "indent": 10,
      "text": "- Acknowledge the StatSN of the Async Message PDU via a NOP-Out PDU with ITT=0xffffffff (i.e., non-ping flavor), while copying the LUN field from the Async Message to NOP-Out.",
      "zh-cn": "- Acknowledge the StatSN of the Async Message PDU via a NOP-Out PDU with ITT=0xffffffff (i.e., non-ping flavor), while copying the LUN field from the Async Message to NOP-Out."
    },
    {
      "indent": 10,
      "text": "This value of AsyncEvent, however, MUST NOT be used on an iSCSI session unless the new TaskReporting text key defined in Section 13.23 was negotiated to FastAbort on the session.",
      "zh-cn": "This value of AsyncEvent, however, MUST NOT be used on an iSCSI session unless the new TaskReporting text key defined in Section 13.23 was negotiated to FastAbort on the session."
    },
    {
      "indent": 4,
      "text": "248-255 (Vendor-unique) - vendor-specific iSCSI event. The AsyncVCode details the vendor code, and data MAY accompany the report.",
      "zh-cn": "248-255 (Vendor-unique) - vendor-specific iSCSI event. The AsyncVCode details the vendor code, and data MAY accompany the report."
    },
    {
      "indent": 3,
      "text": "All other event codes are unassigned.",
      "zh-cn": "All other event codes are unassigned."
    },
    {
      "indent": 0,
      "text": "11.9.2. AsyncVCode",
      "section_title": true,
      "zh-cn": "11.9.2. AsyncVCode"
    },
    {
      "indent": 3,
      "text": "AsyncVCode is a vendor-specific detail code that is only valid if the AsyncEvent field indicates a vendor-specific event. Otherwise, it is reserved.",
      "zh-cn": "AsyncVCode is a vendor-specific detail code that is only valid if the AsyncEvent field indicates a vendor-specific event. Otherwise, it is reserved."
    },
    {
      "indent": 0,
      "text": "11.9.3. LUN",
      "section_title": true,
      "zh-cn": "11.9.3. LUN"
    },
    {
      "indent": 3,
      "text": "The LUN field MUST be valid if AsyncEvent is 0. Otherwise, this field is reserved.",
      "zh-cn": "The LUN field MUST be valid if AsyncEvent is 0. Otherwise, this field is reserved."
    },
    {
      "indent": 0,
      "text": "11.9.4. Sense Data and iSCSI Event Data",
      "section_title": true,
      "zh-cn": "11.9.4. Sense Data and iSCSI Event Data"
    },
    {
      "indent": 3,
      "text": "For a SCSI event, this data accompanies the report in the data segment and identifies the condition.",
      "zh-cn": "For a SCSI event, this data accompanies the report in the data segment and identifies the condition."
    },
    {
      "indent": 3,
      "text": "For an iSCSI event, additional vendor-unique data MAY accompany the Async event. Initiators MAY ignore the data when not understood, while processing the rest of the PDU.",
      "zh-cn": "For an iSCSI event, additional vendor-unique data MAY accompany the Async event. Initiators MAY ignore the data when not understood, while processing the rest of the PDU."
    },
    {
      "indent": 3,
      "text": "If the DataSegmentLength is not 0, the format of the DataSegment is as follows:",
      "zh-cn": "If the DataSegmentLength is not 0, the format of the DataSegment is as follows:"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|SenseLength                    | Sense Data                    |\n  +---------------+---------------+---------------+---------------+\n x/ Sense Data                                                    /\n  +---------------+---------------+---------------+---------------+\n y/ iSCSI Event Data                                              /\n  /                                                               /\n  +---------------+---------------+---------------+---------------+\n z|",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.9.4.1. SenseLength",
      "section_title": true,
      "zh-cn": "11.9.4.1. SenseLength"
    },
    {
      "indent": 3,
      "text": "This is the length of Sense Data. When the Sense Data field is empty (e.g., the event is not a SCSI event), SenseLength is 0.",
      "zh-cn": "This is the length of Sense Data. When the Sense Data field is empty (e.g., the event is not a SCSI event), SenseLength is 0."
    },
    {
      "indent": 0,
      "text": "11.10. Text Request",
      "section_title": true,
      "zh-cn": "11.10. Text Request"
    },
    {
      "indent": 3,
      "text": "The Text Request is provided to allow for the exchange of information and for future extensions. It permits the initiator to inform a target of its capabilities or request some special operations.",
      "zh-cn": "The Text Request is provided to allow for the exchange of information and for future extensions. It permits the initiator to inform a target of its capabilities or request some special operations."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| 0x04      |F|C| Reserved                                  |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment (Text)                                            /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "An initiator MUST NOT have more than one outstanding Text Request on a connection at any given time.",
      "zh-cn": "An initiator MUST NOT have more than one outstanding Text Request on a connection at any given time."
    },
    {
      "indent": 3,
      "text": "On a connection failure, an initiator must either explicitly abort any active allegiant text negotiation task or cause such a task to be implicitly terminated by the target.",
      "zh-cn": "On a connection failure, an initiator must either explicitly abort any active allegiant text negotiation task or cause such a task to be implicitly terminated by the target."
    },
    {
      "indent": 0,
      "text": "11.10.1. F (Final) Bit",
      "section_title": true,
      "zh-cn": "11.10.1. F (Final) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that this is the last or only Text Request in a sequence of Text Requests; otherwise, it indicates that more Text Requests will follow.",
      "zh-cn": "When set to 1, this bit indicates that this is the last or only Text Request in a sequence of Text Requests; otherwise, it indicates that more Text Requests will follow."
    },
    {
      "indent": 0,
      "text": "11.10.2. C (Continue) Bit",
      "section_title": true,
      "zh-cn": "11.10.2. C (Continue) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Text Request is not complete (it will be continued on subsequent Text Requests); otherwise, it indicates that this Text Request ends a set of key=value pairs. A Text Request with the C bit set to 1 MUST have the F bit set to 0.",
      "zh-cn": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Text Request is not complete (it will be continued on subsequent Text Requests); otherwise, it indicates that this Text Request ends a set of key=value pairs. A Text Request with the C bit set to 1 MUST have the F bit set to 0."
    },
    {
      "indent": 0,
      "text": "11.10.3. Initiator Task Tag",
      "section_title": true,
      "zh-cn": "11.10.3. Initiator Task Tag"
    },
    {
      "indent": 3,
      "text": "This is the initiator-assigned identifier for this Text Request. If the command is sent as part of a sequence of Text Requests and responses, the Initiator Task Tag MUST be the same for all the requests within the sequence (similar to linked SCSI commands). The I bit for all requests in a sequence also MUST be the same.",
      "zh-cn": "This is the initiator-assigned identifier for this Text Request. If the command is sent as part of a sequence of Text Requests and responses, the Initiator Task Tag MUST be the same for all the requests within the sequence (similar to linked SCSI commands). The I bit for all requests in a sequence also MUST be the same."
    },
    {
      "indent": 0,
      "text": "11.10.4. Target Transfer Tag",
      "section_title": true,
      "zh-cn": "11.10.4. Target Transfer Tag"
    },
    {
      "indent": 3,
      "text": "When the Target Transfer Tag is set to the reserved value 0xffffffff, it tells the target that this is a new request, and the target resets any internal state associated with the Initiator Task Tag (resets the current negotiation state).",
      "zh-cn": "When the Target Transfer Tag is set to the reserved value 0xffffffff, it tells the target that this is a new request, and the target resets any internal state associated with the Initiator Task Tag (resets the current negotiation state)."
    },
    {
      "indent": 3,
      "text": "The target sets the Target Transfer Tag in a Text Response to a value other than the reserved value 0xffffffff whenever it indicates that it has more data to send or more operations to perform that are associated with the specified Initiator Task Tag. It MUST do so whenever it sets the F bit to 0 in the response. By copying the Target Transfer Tag from the response to the next Text Request, the initiator tells the target to continue the operation for the specific Initiator Task Tag. The initiator MUST ignore the Target Transfer Tag in the Text Response when the F bit is set to 1.",
      "zh-cn": "The target sets the Target Transfer Tag in a Text Response to a value other than the reserved value 0xffffffff whenever it indicates that it has more data to send or more operations to perform that are associated with the specified Initiator Task Tag. It MUST do so whenever it sets the F bit to 0 in the response. By copying the Target Transfer Tag from the response to the next Text Request, the initiator tells the target to continue the operation for the specific Initiator Task Tag. The initiator MUST ignore the Target Transfer Tag in the Text Response when the F bit is set to 1."
    },
    {
      "indent": 3,
      "text": "This mechanism allows the initiator and target to transfer a large amount of textual data over a sequence of text-command/text-response exchanges or to perform extended negotiation sequences.",
      "zh-cn": "This mechanism allows the initiator and target to transfer a large amount of textual data over a sequence of text-command/text-response exchanges or to perform extended negotiation sequences."
    },
    {
      "indent": 3,
      "text": "If the Target Transfer Tag is not 0xffffffff, the LUN field MUST be sent by the target in the Text Response.",
      "zh-cn": "If the Target Transfer Tag is not 0xffffffff, the LUN field MUST be sent by the target in the Text Response."
    },
    {
      "indent": 3,
      "text": "A target MAY reset its internal negotiation state if an exchange is stalled by the initiator for a long time or if it is running out of resources.",
      "zh-cn": "A target MAY reset its internal negotiation state if an exchange is stalled by the initiator for a long time or if it is running out of resources."
    },
    {
      "indent": 3,
      "text": "Long Text Responses are handled as shown in the following example:",
      "zh-cn": "Long Text Responses are handled as shown in the following example:"
    },
    {
      "indent": 6,
      "text": "I->T Text SendTargets=All (F = 1, TTT = 0xffffffff)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T->I Text <part 1> (F = 0, TTT = 0x12345678)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I->T Text <empty> (F = 1, TTT = 0x12345678)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T->I Text <part 2> (F = 0, TTT = 0x12345678)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I->T Text <empty> (F = 1, TTT = 0x12345678)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "...",
      "zh-cn": "..."
    },
    {
      "indent": 6,
      "text": "T->I Text <part n> (F = 1, TTT = 0xffffffff)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.10.5. Text",
      "section_title": true,
      "zh-cn": "11.10.5. Text"
    },
    {
      "indent": 3,
      "text": "The data lengths of a Text Request MUST NOT exceed the iSCSI target MaxRecvDataSegmentLength (a parameter that is negotiated per connection and per direction). The text format is specified in Section 6.2.",
      "zh-cn": "The data lengths of a Text Request MUST NOT exceed the iSCSI target MaxRecvDataSegmentLength (a parameter that is negotiated per connection and per direction). The text format is specified in Section 6.2."
    },
    {
      "indent": 3,
      "text": "Sections 12 and 13 list some basic Text key=value pairs, some of which can be used in Login Requests/Responses and some in Text Requests/Responses.",
      "zh-cn": "Sections 12 and 13 list some basic Text key=value pairs, some of which can be used in Login Requests/Responses and some in Text Requests/Responses."
    },
    {
      "indent": 3,
      "text": "A key=value pair can span Text Request or Text Response boundaries. A key=value pair can start in one PDU and continue on the next. In other words, the end of a PDU does not necessarily signal the end of a key=value pair.",
      "zh-cn": "A key=value pair can span Text Request or Text Response boundaries. A key=value pair can start in one PDU and continue on the next. In other words, the end of a PDU does not necessarily signal the end of a key=value pair."
    },
    {
      "indent": 3,
      "text": "The target responds by sending its response back to the initiator. The response text format is similar to the request text format. The Text Response MAY refer to key=value pairs presented in an earlier Text Request, and the text in the request may refer to earlier responses.",
      "zh-cn": "The target responds by sending its response back to the initiator. The response text format is similar to the request text format. The Text Response MAY refer to key=value pairs presented in an earlier Text Request, and the text in the request may refer to earlier responses."
    },
    {
      "indent": 3,
      "text": "Section 6.2 details the rules for the Text Requests and Responses.",
      "zh-cn": "Section 6.2 details the rules for the Text Requests and Responses."
    },
    {
      "indent": 3,
      "text": "Text operations are usually meant for parameter setting/negotiations but can also be used to perform some long-lasting operations.",
      "zh-cn": "Text operations are usually meant for parameter setting/negotiations but can also be used to perform some long-lasting operations."
    },
    {
      "indent": 3,
      "text": "Text operations that take a long time should be placed in their own Text Request.",
      "zh-cn": "Text operations that take a long time should be placed in their own Text Request."
    },
    {
      "indent": 0,
      "text": "11.11. Text Response",
      "section_title": true,
      "zh-cn": "11.11. Text Response"
    },
    {
      "indent": 3,
      "text": "The Text Response PDU contains the target's responses to the initiator's Text Request. The format of the Text field matches that of the Text Request.",
      "zh-cn": "The Text Response PDU contains the target's responses to the initiator's Text Request. The format of the Text field matches that of the Text Request."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x24      |F|C| Reserved                                  |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment (Text)                                            /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.11.1. F (Final) Bit",
      "section_title": true,
      "zh-cn": "11.11.1. F (Final) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, in response to a Text Request with the Final bit set to 1, the F bit indicates that the target has finished the whole operation. Otherwise, if set to 0 in response to a Text Request with the Final Bit set to 1, it indicates that the target has more work to",
      "zh-cn": "When set to 1, in response to a Text Request with the Final bit set to 1, the F bit indicates that the target has finished the whole operation. Otherwise, if set to 0 in response to a Text Request with the Final Bit set to 1, it indicates that the target has more work to"
    },
    {
      "indent": 3,
      "text": "do (invites a follow-on Text Request). A Text Response with the F bit set to 1 in response to a Text Request with the F bit set to 0 is a protocol error.",
      "zh-cn": "do (invites a follow-on Text Request). A Text Response with the F bit set to 1 in response to a Text Request with the F bit set to 0 is a protocol error."
    },
    {
      "indent": 3,
      "text": "A Text Response with the F bit set to 1 MUST NOT contain key=value pairs that may require additional answers from the initiator.",
      "zh-cn": "A Text Response with the F bit set to 1 MUST NOT contain key=value pairs that may require additional answers from the initiator."
    },
    {
      "indent": 3,
      "text": "A Text Response with the F bit set to 1 MUST have a Target Transfer Tag field set to the reserved value 0xffffffff.",
      "zh-cn": "A Text Response with the F bit set to 1 MUST have a Target Transfer Tag field set to the reserved value 0xffffffff."
    },
    {
      "indent": 3,
      "text": "A Text Response with the F bit set to 0 MUST have a Target Transfer Tag field set to a value other than the reserved value 0xffffffff.",
      "zh-cn": "A Text Response with the F bit set to 0 MUST have a Target Transfer Tag field set to a value other than the reserved value 0xffffffff."
    },
    {
      "indent": 0,
      "text": "11.11.2. C (Continue) Bit",
      "section_title": true,
      "zh-cn": "11.11.2. C (Continue) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Text Response is not complete (it will be continued on subsequent Text Responses); otherwise, it indicates that this Text Response ends a set of key=value pairs. A Text Response with the C bit set to 1 MUST have the F bit set to 0.",
      "zh-cn": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Text Response is not complete (it will be continued on subsequent Text Responses); otherwise, it indicates that this Text Response ends a set of key=value pairs. A Text Response with the C bit set to 1 MUST have the F bit set to 0."
    },
    {
      "indent": 0,
      "text": "11.11.3. Initiator Task Tag",
      "section_title": true,
      "zh-cn": "11.11.3. Initiator Task Tag"
    },
    {
      "indent": 3,
      "text": "The Initiator Task Tag matches the tag used in the initial Text Request.",
      "zh-cn": "The Initiator Task Tag matches the tag used in the initial Text Request."
    },
    {
      "indent": 0,
      "text": "11.11.4. Target Transfer Tag",
      "section_title": true,
      "zh-cn": "11.11.4. Target Transfer Tag"
    },
    {
      "indent": 3,
      "text": "When a target has more work to do (e.g., cannot transfer all the remaining text data in a single Text Response or has to continue the negotiation) and has enough resources to proceed, it MUST set the Target Transfer Tag to a value other than the reserved value 0xffffffff. Otherwise, the Target Transfer Tag MUST be set to 0xffffffff.",
      "zh-cn": "When a target has more work to do (e.g., cannot transfer all the remaining text data in a single Text Response or has to continue the negotiation) and has enough resources to proceed, it MUST set the Target Transfer Tag to a value other than the reserved value 0xffffffff. Otherwise, the Target Transfer Tag MUST be set to 0xffffffff."
    },
    {
      "indent": 3,
      "text": "When the Target Transfer Tag is not 0xffffffff, the LUN field may be significant.",
      "zh-cn": "When the Target Transfer Tag is not 0xffffffff, the LUN field may be significant."
    },
    {
      "indent": 3,
      "text": "The initiator MUST copy the Target Transfer Tag and LUN in its next request to indicate that it wants the rest of the data.",
      "zh-cn": "The initiator MUST copy the Target Transfer Tag and LUN in its next request to indicate that it wants the rest of the data."
    },
    {
      "indent": 3,
      "text": "When the target receives a Text Request with the Target Transfer Tag set to the reserved value 0xffffffff, it resets its internal information (resets state) associated with the given Initiator Task Tag (restarts the negotiation).",
      "zh-cn": "When the target receives a Text Request with the Target Transfer Tag set to the reserved value 0xffffffff, it resets its internal information (resets state) associated with the given Initiator Task Tag (restarts the negotiation)."
    },
    {
      "indent": 3,
      "text": "When a target cannot finish the operation in a single Text Response and does not have enough resources to continue, it rejects the Text Request with the appropriate Reject code.",
      "zh-cn": "When a target cannot finish the operation in a single Text Response and does not have enough resources to continue, it rejects the Text Request with the appropriate Reject code."
    },
    {
      "indent": 3,
      "text": "A target may reset its internal state associated with an Initiator Task Tag (the current negotiation state) as expressed through the Target Transfer Tag if the initiator fails to continue the exchange for some time. The target may reject subsequent Text Requests with the Target Transfer Tag set to the \"stale\" value.",
      "zh-cn": "A target may reset its internal state associated with an Initiator Task Tag (the current negotiation state) as expressed through the Target Transfer Tag if the initiator fails to continue the exchange for some time. The target may reject subsequent Text Requests with the Target Transfer Tag set to the \"stale\" value."
    },
    {
      "indent": 0,
      "text": "11.11.5. StatSN",
      "section_title": true,
      "zh-cn": "11.11.5. StatSN"
    },
    {
      "indent": 3,
      "text": "The target StatSN variable is advanced by each Text Response sent.",
      "zh-cn": "The target StatSN variable is advanced by each Text Response sent."
    },
    {
      "indent": 0,
      "text": "11.11.6. Text Response Data",
      "section_title": true,
      "zh-cn": "11.11.6. Text Response Data"
    },
    {
      "indent": 3,
      "text": "The data lengths of a Text Response MUST NOT exceed the iSCSI initiator MaxRecvDataSegmentLength (a parameter that is negotiated per connection and per direction).",
      "zh-cn": "The data lengths of a Text Response MUST NOT exceed the iSCSI initiator MaxRecvDataSegmentLength (a parameter that is negotiated per connection and per direction)."
    },
    {
      "indent": 3,
      "text": "The text in the Text Response Data is governed by the same rules as the text in the Text Request Data (see Section 11.11.2).",
      "zh-cn": "The text in the Text Response Data is governed by the same rules as the text in the Text Request Data (see Section 11.11.2)."
    },
    {
      "indent": 3,
      "text": "Although the initiator is the requesting party and controls the request-response initiation and termination, the target can offer key=value pairs of its own as part of a sequence and not only in response to the initiator.",
      "zh-cn": "Although the initiator is the requesting party and controls the request-response initiation and termination, the target can offer key=value pairs of its own as part of a sequence and not only in response to the initiator."
    },
    {
      "indent": 0,
      "text": "11.12. Login Request",
      "section_title": true,
      "zh-cn": "11.12. Login Request"
    },
    {
      "indent": 3,
      "text": "After establishing a TCP connection between an initiator and a target, the initiator MUST start a Login Phase to gain further access to the target's resources.",
      "zh-cn": "After establishing a TCP connection between an initiator and a target, the initiator MUST start a Login Phase to gain further access to the target's resources."
    },
    {
      "indent": 3,
      "text": "The Login Phase (see Section 6.3) consists of a sequence of Login Requests and Login Responses that carry the same Initiator Task Tag.",
      "zh-cn": "The Login Phase (see Section 6.3) consists of a sequence of Login Requests and Login Responses that carry the same Initiator Task Tag."
    },
    {
      "indent": 3,
      "text": "Login Requests are always considered as immediate.",
      "zh-cn": "Login Requests are always considered as immediate."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|1| 0x03      |T|C|.|.|CSG|NSG| Version-max   | Version-min   |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| ISID                                                          |\n  +                               +---------------+---------------+\n12|                               | TSIH                          |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| CID                           | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN or Reserved                                         |\n  +---------------+---------------+---------------+---------------+\n32| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n36| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n40/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48/ DataSegment - Login Parameters in Text Request Format         /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.12.1. T (Transit) Bit",
      "section_title": true,
      "zh-cn": "11.12.1. T (Transit) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that the initiator is ready to transit to the next stage.",
      "zh-cn": "When set to 1, this bit indicates that the initiator is ready to transit to the next stage."
    },
    {
      "indent": 3,
      "text": "If the T bit is set to 1 and the NSG is set to FullFeaturePhase, then this also indicates that the initiator is ready for the Login Final-Response (see Section 6.3).",
      "zh-cn": "If the T bit is set to 1 and the NSG is set to FullFeaturePhase, then this also indicates that the initiator is ready for the Login Final-Response (see Section 6.3)."
    },
    {
      "indent": 0,
      "text": "11.12.2. C (Continue) Bit",
      "section_title": true,
      "zh-cn": "11.12.2. C (Continue) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Login Request is not complete (it will be continued on subsequent Login Requests); otherwise, it indicates that this Login Request ends a set of key=value pairs. A Login Request with the C bit set to 1 MUST have the T bit set to 0.",
      "zh-cn": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Login Request is not complete (it will be continued on subsequent Login Requests); otherwise, it indicates that this Login Request ends a set of key=value pairs. A Login Request with the C bit set to 1 MUST have the T bit set to 0."
    },
    {
      "indent": 0,
      "text": "11.12.3. CSG and NSG",
      "section_title": true,
      "zh-cn": "11.12.3. CSG and NSG"
    },
    {
      "indent": 3,
      "text": "Through these fields -- Current Stage (CSG) and Next Stage (NSG) -- the Login negotiation requests and responses are associated with a specific stage in the session (SecurityNegotiation, LoginOperationalNegotiation, FullFeaturePhase) and may indicate the next stage to which they want to move (see Section 6.3). The Next Stage value is only valid when the T bit is 1; otherwise, it is reserved.",
      "zh-cn": "Through these fields -- Current Stage (CSG) and Next Stage (NSG) -- the Login negotiation requests and responses are associated with a specific stage in the session (SecurityNegotiation, LoginOperationalNegotiation, FullFeaturePhase) and may indicate the next stage to which they want to move (see Section 6.3). The Next Stage value is only valid when the T bit is 1; otherwise, it is reserved."
    },
    {
      "indent": 3,
      "text": "The stage codes are:",
      "zh-cn": "The stage codes are:"
    },
    {
      "indent": 6,
      "text": "0 - SecurityNegotiation",
      "zh-cn": "0 - SecurityNegotiation"
    },
    {
      "indent": 6,
      "text": "1 - LoginOperationalNegotiation",
      "zh-cn": "1 - LoginOperationalNegotiation"
    },
    {
      "indent": 6,
      "text": "3 - FullFeaturePhase",
      "zh-cn": "3 - FullFeaturePhase"
    },
    {
      "indent": 3,
      "text": "All other codes are reserved.",
      "zh-cn": "All other codes are reserved."
    },
    {
      "indent": 0,
      "text": "11.12.4. Version",
      "section_title": true,
      "zh-cn": "11.12.4. Version"
    },
    {
      "indent": 3,
      "text": "The version number for this document is 0x00. Therefore, both Version-min and Version-max MUST be set to 0x00.",
      "zh-cn": "The version number for this document is 0x00. Therefore, both Version-min and Version-max MUST be set to 0x00."
    },
    {
      "indent": 0,
      "text": "11.12.4.1. Version-max",
      "section_title": true,
      "zh-cn": "11.12.4.1. Version-max"
    },
    {
      "indent": 3,
      "text": "Version-max indicates the maximum version number supported.",
      "zh-cn": "Version-max indicates the maximum version number supported."
    },
    {
      "indent": 3,
      "text": "All Login Requests within the Login Phase MUST carry the same Version-max.",
      "zh-cn": "All Login Requests within the Login Phase MUST carry the same Version-max."
    },
    {
      "indent": 3,
      "text": "The target MUST use the value presented with the first Login Request.",
      "zh-cn": "The target MUST use the value presented with the first Login Request."
    },
    {
      "indent": 0,
      "text": "11.12.4.2. Version-min",
      "section_title": true,
      "zh-cn": "11.12.4.2. Version-min"
    },
    {
      "indent": 3,
      "text": "All Login Requests within the Login Phase MUST carry the same Version-min. The target MUST use the value presented with the first Login Request.",
      "zh-cn": "All Login Requests within the Login Phase MUST carry the same Version-min. The target MUST use the value presented with the first Login Request."
    },
    {
      "indent": 0,
      "text": "11.12.5. ISID",
      "section_title": true,
      "zh-cn": "11.12.5. ISID"
    },
    {
      "indent": 3,
      "text": "This is an initiator-defined component of the session identifier and is structured as follows (see Section 10.1.1 for details):",
      "zh-cn": "This is an initiator-defined component of the session identifier and is structured as follows (see Section 10.1.1 for details):"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 8| T |     A     |              B                |      C        |\n  +---------------+---------------+---------------+---------------+\n12|               D               |\n  +---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The T field identifies the format and usage of A, B, C, and D as indicated below:",
      "zh-cn": "The T field identifies the format and usage of A, B, C, and D as indicated below:"
    },
    {
      "indent": 6,
      "text": "T",
      "zh-cn": "T"
    },
    {
      "indent": 6,
      "text": "00b OUI-Format",
      "zh-cn": "00b OUI-Format"
    },
    {
      "indent": 13,
      "text": "A and B: 22-bit OUI",
      "zh-cn": "A and B: 22-bit OUI"
    },
    {
      "indent": 13,
      "text": "(the I/G and U/L bits are omitted)",
      "zh-cn": "(the I/G and U/L bits are omitted)"
    },
    {
      "indent": 13,
      "text": "C and D: 24-bit Qualifier",
      "zh-cn": "C and D: 24-bit Qualifier"
    },
    {
      "indent": 6,
      "text": "01b EN: Format (IANA Enterprise Number)",
      "zh-cn": "01b EN: Format (IANA Enterprise Number)"
    },
    {
      "indent": 13,
      "text": "A: Reserved",
      "zh-cn": "A: Reserved"
    },
    {
      "indent": 13,
      "text": "B and C: EN (IANA Enterprise Number)",
      "zh-cn": "B and C: EN (IANA Enterprise Number)"
    },
    {
      "indent": 13,
      "text": "D: Qualifier",
      "zh-cn": "D: Qualifier"
    },
    {
      "indent": 6,
      "text": "10b \"Random\"",
      "zh-cn": "10b \"Random\""
    },
    {
      "indent": 13,
      "text": "A: Reserved",
      "zh-cn": "A: Reserved"
    },
    {
      "indent": 13,
      "text": "B and C: Random",
      "zh-cn": "B and C: Random"
    },
    {
      "indent": 13,
      "text": "D: Qualifier",
      "zh-cn": "D: Qualifier"
    },
    {
      "indent": 6,
      "text": "11b A, B, C, and D: Reserved",
      "zh-cn": "11b A, B, C, and D: Reserved"
    },
    {
      "indent": 3,
      "text": "For the T field values 00b and 01b, a combination of A and B (for 00b) or B and C (for 01b) identifies the vendor or organization whose component (software or hardware) generates this ISID. A vendor or",
      "zh-cn": "For the T field values 00b and 01b, a combination of A and B (for 00b) or B and C (for 01b) identifies the vendor or organization whose component (software or hardware) generates this ISID. A vendor or"
    },
    {
      "indent": 3,
      "text": "organization with one or more OUIs, or one or more Enterprise Numbers, MUST use at least one of these numbers and select the appropriate value for the T field when its components generate ISIDs. An OUI or EN MUST be set in the corresponding fields in network byte order (byte big-endian).",
      "zh-cn": "organization with one or more OUIs, or one or more Enterprise Numbers, MUST use at least one of these numbers and select the appropriate value for the T field when its components generate ISIDs. An OUI or EN MUST be set in the corresponding fields in network byte order (byte big-endian)."
    },
    {
      "indent": 3,
      "text": "If the T field is 10b, B and C are set to a random 24-bit unsigned integer value in network byte order (byte big-endian). See [RFC3721] for how this affects the principle of \"conservative reuse\".",
      "zh-cn": "If the T field is 10b, B and C are set to a random 24-bit unsigned integer value in network byte order (byte big-endian). See [RFC3721] for how this affects the principle of \"conservative reuse\"."
    },
    {
      "indent": 3,
      "text": "The Qualifier field is a 16-bit or 24-bit unsigned integer value that provides a range of possible values for the ISID within the selected namespace. It may be set to any value within the constraints specified in the iSCSI protocol (see Sections 4.4.3 and 10.1.1).",
      "zh-cn": "The Qualifier field is a 16-bit or 24-bit unsigned integer value that provides a range of possible values for the ISID within the selected namespace. It may be set to any value within the constraints specified in the iSCSI protocol (see Sections 4.4.3 and 10.1.1)."
    },
    {
      "indent": 3,
      "text": "The T field value of 11b is reserved.",
      "zh-cn": "The T field value of 11b is reserved."
    },
    {
      "indent": 3,
      "text": "If the ISID is derived from something assigned to a hardware adapter or interface by a vendor as a preset default value, it MUST be configurable to a value assigned according to the SCSI port behavior desired by the system in which it is installed (see Sections 10.1.1 and 10.1.2). The resultant ISID MUST also be persistent over power cycles, reboot, card swap, etc.",
      "zh-cn": "If the ISID is derived from something assigned to a hardware adapter or interface by a vendor as a preset default value, it MUST be configurable to a value assigned according to the SCSI port behavior desired by the system in which it is installed (see Sections 10.1.1 and 10.1.2). The resultant ISID MUST also be persistent over power cycles, reboot, card swap, etc."
    },
    {
      "indent": 0,
      "text": "11.12.6. TSIH",
      "section_title": true,
      "zh-cn": "11.12.6. TSIH"
    },
    {
      "indent": 3,
      "text": "The TSIH must be set in the first Login Request. The reserved value 0 MUST be used on the first connection for a new session. Otherwise, the TSIH sent by the target at the conclusion of the successful login of the first connection for this session MUST be used. The TSIH identifies to the target the associated existing session for this new connection.",
      "zh-cn": "The TSIH must be set in the first Login Request. The reserved value 0 MUST be used on the first connection for a new session. Otherwise, the TSIH sent by the target at the conclusion of the successful login of the first connection for this session MUST be used. The TSIH identifies to the target the associated existing session for this new connection."
    },
    {
      "indent": 3,
      "text": "All Login Requests within a Login Phase MUST carry the same TSIH.",
      "zh-cn": "All Login Requests within a Login Phase MUST carry the same TSIH."
    },
    {
      "indent": 3,
      "text": "The target MUST check the value presented with the first Login Request and act as specified in Section 6.3.1.",
      "zh-cn": "The target MUST check the value presented with the first Login Request and act as specified in Section 6.3.1."
    },
    {
      "indent": 0,
      "text": "11.12.7. Connection ID (CID)",
      "section_title": true,
      "zh-cn": "11.12.7. Connection ID (CID)"
    },
    {
      "indent": 3,
      "text": "The CID provides a unique ID for this connection within the session.",
      "zh-cn": "The CID provides a unique ID for this connection within the session."
    },
    {
      "indent": 3,
      "text": "All Login Requests within the Login Phase MUST carry the same CID.",
      "zh-cn": "All Login Requests within the Login Phase MUST carry the same CID."
    },
    {
      "indent": 3,
      "text": "The target MUST use the value presented with the first Login Request.",
      "zh-cn": "The target MUST use the value presented with the first Login Request."
    },
    {
      "indent": 3,
      "text": "A Login Request with a non-zero TSIH and a CID equal to that of an existing connection implies a logout of the connection followed by a login (see Section 6.3.4). For details regarding the implicit Logout Request, see Section 11.14.",
      "zh-cn": "A Login Request with a non-zero TSIH and a CID equal to that of an existing connection implies a logout of the connection followed by a login (see Section 6.3.4). For details regarding the implicit Logout Request, see Section 11.14."
    },
    {
      "indent": 0,
      "text": "11.12.8. CmdSN",
      "section_title": true,
      "zh-cn": "11.12.8. CmdSN"
    },
    {
      "indent": 3,
      "text": "The CmdSN is either the initial command sequence number of a session (for the first Login Request of a session -- the \"leading\" login) or the command sequence number in the command stream if the login is for a new connection in an existing session.",
      "zh-cn": "The CmdSN is either the initial command sequence number of a session (for the first Login Request of a session -- the \"leading\" login) or the command sequence number in the command stream if the login is for a new connection in an existing session."
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 3,
      "text": "- Login on a leading connection: If the leading login carries the CmdSN 123, all other Login Requests in the same Login Phase carry the CmdSN 123, and the first non-immediate command in the Full Feature Phase also carries the CmdSN 123.",
      "zh-cn": "- Login on a leading connection: If the leading login carries the CmdSN 123, all other Login Requests in the same Login Phase carry the CmdSN 123, and the first non-immediate command in the Full Feature Phase also carries the CmdSN 123."
    },
    {
      "indent": 3,
      "text": "- Login on other than a leading connection: If the current CmdSN at the time the first login on the connection is issued is 500, then that PDU carries CmdSN=500. Subsequent Login Requests that are needed to complete this Login Phase may carry a CmdSN higher than 500 if non-immediate requests that were issued on other connections in the same session advance the CmdSN.",
      "zh-cn": "- Login on other than a leading connection: If the current CmdSN at the time the first login on the connection is issued is 500, then that PDU carries CmdSN=500. Subsequent Login Requests that are needed to complete this Login Phase may carry a CmdSN higher than 500 if non-immediate requests that were issued on other connections in the same session advance the CmdSN."
    },
    {
      "indent": 3,
      "text": "If the Login Request is a leading Login Request, the target MUST use the value presented in the CmdSN as the target value for the ExpCmdSN.",
      "zh-cn": "If the Login Request is a leading Login Request, the target MUST use the value presented in the CmdSN as the target value for the ExpCmdSN."
    },
    {
      "indent": 0,
      "text": "11.12.9. ExpStatSN",
      "section_title": true,
      "zh-cn": "11.12.9. ExpStatSN"
    },
    {
      "indent": 3,
      "text": "For the first Login Request on a connection, this is the ExpStatSN for the old connection, and this field is only valid if the Login Request restarts a connection (see Section 6.3.4).",
      "zh-cn": "For the first Login Request on a connection, this is the ExpStatSN for the old connection, and this field is only valid if the Login Request restarts a connection (see Section 6.3.4)."
    },
    {
      "indent": 3,
      "text": "For subsequent Login Requests, it is used to acknowledge the Login Responses with their increasing StatSN values.",
      "zh-cn": "For subsequent Login Requests, it is used to acknowledge the Login Responses with their increasing StatSN values."
    },
    {
      "indent": 0,
      "text": "11.12.10. Login Parameters",
      "section_title": true,
      "zh-cn": "11.12.10. Login Parameters"
    },
    {
      "indent": 3,
      "text": "The initiator MUST provide some basic parameters in order to enable the target to determine if the initiator may use the target's resources and the initial text parameters for the security exchange.",
      "zh-cn": "The initiator MUST provide some basic parameters in order to enable the target to determine if the initiator may use the target's resources and the initial text parameters for the security exchange."
    },
    {
      "indent": 3,
      "text": "All the rules specified in Section 11.10.5 for Text Requests also hold for Login Requests. Keys and their explanations are listed in Section 12 (security negotiation keys) and in Section 13 (operational",
      "zh-cn": "All the rules specified in Section 11.10.5 for Text Requests also hold for Login Requests. Keys and their explanations are listed in Section 12 (security negotiation keys) and in Section 13 (operational"
    },
    {
      "indent": 3,
      "text": "parameter negotiation keys). All keys listed in Section 13, except for the X extension formats, MUST be supported by iSCSI initiators and targets. Keys listed in Section 12 only need to be supported when the function to which they refer is mandatory to implement.",
      "zh-cn": "parameter negotiation keys). All keys listed in Section 13, except for the X extension formats, MUST be supported by iSCSI initiators and targets. Keys listed in Section 12 only need to be supported when the function to which they refer is mandatory to implement."
    },
    {
      "indent": 0,
      "text": "11.13. Login Response",
      "section_title": true,
      "zh-cn": "11.13. Login Response"
    },
    {
      "indent": 3,
      "text": "The Login Response indicates the progress and/or end of the Login Phase.",
      "zh-cn": "The Login Response indicates the progress and/or end of the Login Phase."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x23      |T|C|.|.|CSG|NSG| Version-max   |Version-active |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| ISID                                                          |\n  +                               +---------------+---------------+\n12|                               | TSIH                          |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| Status-Class  | Status-Detail | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n40/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48/ DataSegment - Login Parameters in Text Request Format         /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.13.1. Version-max",
      "section_title": true,
      "zh-cn": "11.13.1. Version-max"
    },
    {
      "indent": 3,
      "text": "This is the highest version number supported by the target.",
      "zh-cn": "This is the highest version number supported by the target."
    },
    {
      "indent": 3,
      "text": "All Login Responses within the Login Phase MUST carry the same Version-max.",
      "zh-cn": "All Login Responses within the Login Phase MUST carry the same Version-max."
    },
    {
      "indent": 3,
      "text": "The initiator MUST use the value presented as a response to the first Login Request.",
      "zh-cn": "The initiator MUST use the value presented as a response to the first Login Request."
    },
    {
      "indent": 0,
      "text": "11.13.2. Version-active",
      "section_title": true,
      "zh-cn": "11.13.2. Version-active"
    },
    {
      "indent": 3,
      "text": "Version-active indicates the highest version supported by the target and initiator. If the target does not support a version within the range specified by the initiator, the target rejects the login and this field indicates the lowest version supported by the target.",
      "zh-cn": "Version-active indicates the highest version supported by the target and initiator. If the target does not support a version within the range specified by the initiator, the target rejects the login and this field indicates the lowest version supported by the target."
    },
    {
      "indent": 3,
      "text": "All Login Responses within the Login Phase MUST carry the same Version-active.",
      "zh-cn": "All Login Responses within the Login Phase MUST carry the same Version-active."
    },
    {
      "indent": 3,
      "text": "The initiator MUST use the value presented as a response to the first Login Request.",
      "zh-cn": "The initiator MUST use the value presented as a response to the first Login Request."
    },
    {
      "indent": 0,
      "text": "11.13.3. TSIH",
      "section_title": true,
      "zh-cn": "11.13.3. TSIH"
    },
    {
      "indent": 3,
      "text": "The TSIH is the target-assigned session-identifying handle. Its internal format and content are not defined by this protocol, except for the value 0, which is reserved. With the exception of the Login Final-Response in a new session, this field should be set to the TSIH provided by the initiator in the Login Request. For a new session, the target MUST generate a non-zero TSIH and ONLY return it in the Login Final-Response (see Section 6.3).",
      "zh-cn": "The TSIH is the target-assigned session-identifying handle. Its internal format and content are not defined by this protocol, except for the value 0, which is reserved. With the exception of the Login Final-Response in a new session, this field should be set to the TSIH provided by the initiator in the Login Request. For a new session, the target MUST generate a non-zero TSIH and ONLY return it in the Login Final-Response (see Section 6.3)."
    },
    {
      "indent": 0,
      "text": "11.13.4. StatSN",
      "section_title": true,
      "zh-cn": "11.13.4. StatSN"
    },
    {
      "indent": 3,
      "text": "For the first Login Response (the response to the first Login Request), this is the starting status sequence number for the connection. The next response of any kind -- including the next Login Response, if any, in the same Login Phase -- will carry this number + 1. This field is only valid if the Status-Class is 0.",
      "zh-cn": "For the first Login Response (the response to the first Login Request), this is the starting status sequence number for the connection. The next response of any kind -- including the next Login Response, if any, in the same Login Phase -- will carry this number + 1. This field is only valid if the Status-Class is 0."
    },
    {
      "indent": 0,
      "text": "11.13.5. Status-Class and Status-Detail",
      "section_title": true,
      "zh-cn": "11.13.5. Status-Class and Status-Detail"
    },
    {
      "indent": 3,
      "text": "The Status returned in a Login Response indicates the execution status of the Login Phase. The status includes:",
      "zh-cn": "The Status returned in a Login Response indicates the execution status of the Login Phase. The status includes:"
    },
    {
      "indent": 6,
      "text": "Status-Class",
      "zh-cn": "Status-Class"
    },
    {
      "indent": 6,
      "text": "Status-Detail",
      "zh-cn": "Status-Detail"
    },
    {
      "indent": 3,
      "text": "A Status-Class of 0 indicates success.",
      "zh-cn": "A Status-Class of 0 indicates success."
    },
    {
      "indent": 3,
      "text": "A non-zero Status-Class indicates an exception. In this case, Status-Class is sufficient for a simple initiator to use when handling exceptions, without having to look at the Status-Detail.",
      "zh-cn": "A non-zero Status-Class indicates an exception. In this case, Status-Class is sufficient for a simple initiator to use when handling exceptions, without having to look at the Status-Detail."
    },
    {
      "indent": 3,
      "text": "The Status-Detail allows finer-grained exception handling for more sophisticated initiators and for better information for logging.",
      "zh-cn": "The Status-Detail allows finer-grained exception handling for more sophisticated initiators and for better information for logging."
    },
    {
      "indent": 3,
      "text": "The Status-Classes are as follows:",
      "zh-cn": "The Status-Classes are as follows:"
    },
    {
      "indent": 6,
      "text": "0 Success - indicates that the iSCSI target successfully received, understood, and accepted the request. The numbering fields (StatSN, ExpCmdSN, MaxCmdSN) are only valid if Status-Class is 0.",
      "zh-cn": "0 Success - indicates that the iSCSI target successfully received, understood, and accepted the request. The numbering fields (StatSN, ExpCmdSN, MaxCmdSN) are only valid if Status-Class is 0."
    },
    {
      "indent": 6,
      "text": "1 Redirection - indicates that the initiator must take further action to complete the request. This is usually due to the target moving to a different address. All of the redirection Status-Class responses MUST return one or more text key parameters of the type \"TargetAddress\", which indicates the target's new address. A redirection response MAY be issued by a target prior to or after completing a security negotiation if a security negotiation is required. A redirection SHOULD be accepted by an initiator, even without having the target complete a security negotiation if any security negotiation is required, and MUST be accepted by the initiator after the completion of the security negotiation if any security negotiation is required.",
      "zh-cn": "1 Redirection - indicates that the initiator must take further action to complete the request. This is usually due to the target moving to a different address. All of the redirection Status-Class responses MUST return one or more text key parameters of the type \"TargetAddress\", which indicates the target's new address. A redirection response MAY be issued by a target prior to or after completing a security negotiation if a security negotiation is required. A redirection SHOULD be accepted by an initiator, even without having the target complete a security negotiation if any security negotiation is required, and MUST be accepted by the initiator after the completion of the security negotiation if any security negotiation is required."
    },
    {
      "indent": 6,
      "text": "2 Initiator Error (not a format error) - indicates that the initiator most likely caused the error. This MAY be due to a request for a resource for which the initiator does not have permission. The request should not be tried again.",
      "zh-cn": "2 Initiator Error (not a format error) - indicates that the initiator most likely caused the error. This MAY be due to a request for a resource for which the initiator does not have permission. The request should not be tried again."
    },
    {
      "indent": 6,
      "text": "3 Target Error - indicates that the target sees no errors in the initiator's Login Request but is currently incapable of fulfilling the request. The initiator may retry the same Login Request later.",
      "zh-cn": "3 Target Error - indicates that the target sees no errors in the initiator's Login Request but is currently incapable of fulfilling the request. The initiator may retry the same Login Request later."
    },
    {
      "indent": 3,
      "text": "The table below shows all of the currently allocated status codes. The codes are in hexadecimal; the first byte is the Status-Class, and the second byte is the status detail.",
      "zh-cn": "The table below shows all of the currently allocated status codes. The codes are in hexadecimal; the first byte is the Status-Class, and the second byte is the status detail."
    },
    {
      "indent": 5,
      "text": "-----------------------------------------------------------------\nStatus        | Code | Description\n              |(hex) |\n-----------------------------------------------------------------\nSuccess       | 0000 | Login is proceeding OK (*1).\n-----------------------------------------------------------------\nTarget moved  | 0101 | The requested iSCSI Target Name (ITN)\ntemporarily   |      | has temporarily moved\n              |      | to the address provided.\n-----------------------------------------------------------------\nTarget moved  | 0102 | The requested ITN has permanently moved\npermanently   |      | to the address provided.\n-----------------------------------------------------------------\nInitiator     | 0200 | Miscellaneous iSCSI initiator\nerror         |      | errors.\n-----------------------------------------------------------------\nAuthentication| 0201 | The initiator could not be\nfailure       |      | successfully authenticated or target\n              |      | authentication is not supported.\n-----------------------------------------------------------------\nAuthorization | 0202 | The initiator is not allowed access\nfailure       |      | to the given target.\n-----------------------------------------------------------------\nNot found     | 0203 | The requested ITN does not\n              |      | exist at this address.\n-----------------------------------------------------------------\nTarget removed| 0204 | The requested ITN has been removed, and\n              |      | no forwarding address is provided.\n-----------------------------------------------------------------\nUnsupported   | 0205 | The requested iSCSI version range is\nversion       |      | not supported by the target.\n-----------------------------------------------------------------\nToo many      | 0206 | Too many connections on this SSID.\nconnections   |      |\n-----------------------------------------------------------------\nMissing       | 0207 | Missing parameters (e.g., iSCSI\nparameter     |      | Initiator Name and/or Target Name).\n-----------------------------------------------------------------\nCan't include | 0208 | Target does not support session\nin session    |      | spanning to this connection (address).\n-----------------------------------------------------------------\nSession type  | 0209 | Target does not support this type of\nnot supported |      | session or not from this initiator.\n-----------------------------------------------------------------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Session does  | 020a | Attempt to add a connection\nnot exist     |      | to a non-existent session.\n-----------------------------------------------------------------\nInvalid during| 020b | Invalid request type during login.\nlogin         |      |\n-----------------------------------------------------------------\nTarget error  | 0300 | Target hardware or software error.\n-----------------------------------------------------------------\nService       | 0301 | The iSCSI service or target is not\nunavailable   |      | currently operational.\n-----------------------------------------------------------------\nOut of        | 0302 | The target has insufficient session,\nresources     |      | connection, or other resources.\n-----------------------------------------------------------------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(*1) If the response T bit is set to 1 in both the request and the matching response, and the NSG is set to FullFeaturePhase in both the request and the matching response, the Login Phase is finished, and the initiator may proceed to issue SCSI commands.",
      "zh-cn": "(*1) If the response T bit is set to 1 in both the request and the matching response, and the NSG is set to FullFeaturePhase in both the request and the matching response, the Login Phase is finished, and the initiator may proceed to issue SCSI commands."
    },
    {
      "indent": 3,
      "text": "If the Status-Class is not 0, the initiator and target MUST close the TCP connection.",
      "zh-cn": "If the Status-Class is not 0, the initiator and target MUST close the TCP connection."
    },
    {
      "indent": 3,
      "text": "If the target wishes to reject the Login Request for more than one reason, it should return the primary reason for the rejection.",
      "zh-cn": "If the target wishes to reject the Login Request for more than one reason, it should return the primary reason for the rejection."
    },
    {
      "indent": 0,
      "text": "11.13.6. T (Transit) Bit",
      "section_title": true,
      "zh-cn": "11.13.6. T (Transit) Bit"
    },
    {
      "indent": 3,
      "text": "The T bit is set to 1 as an indicator of the end of the stage. If the T bit is set to 1 and the NSG is set to FullFeaturePhase, then this is also the Login Final-Response (see Section 6.3). A T bit of 0 indicates a \"partial\" response, which means \"more negotiation needed\".",
      "zh-cn": "The T bit is set to 1 as an indicator of the end of the stage. If the T bit is set to 1 and the NSG is set to FullFeaturePhase, then this is also the Login Final-Response (see Section 6.3). A T bit of 0 indicates a \"partial\" response, which means \"more negotiation needed\"."
    },
    {
      "indent": 3,
      "text": "A Login Response with the T bit set to 1 MUST NOT contain key=value pairs that may require additional answers from the initiator within the same stage.",
      "zh-cn": "A Login Response with the T bit set to 1 MUST NOT contain key=value pairs that may require additional answers from the initiator within the same stage."
    },
    {
      "indent": 3,
      "text": "If the Status-Class is 0, the T bit MUST NOT be set to 1 if the T bit in the request was set to 0.",
      "zh-cn": "If the Status-Class is 0, the T bit MUST NOT be set to 1 if the T bit in the request was set to 0."
    },
    {
      "indent": 0,
      "text": "11.13.7. C (Continue) Bit",
      "section_title": true,
      "zh-cn": "11.13.7. C (Continue) Bit"
    },
    {
      "indent": 3,
      "text": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Login Response is not complete (it will be continued on subsequent Login Responses); otherwise, it indicates that this Login Response ends a set of key=value pairs. A Login Response with the C bit set to 1 MUST have the T bit set to 0.",
      "zh-cn": "When set to 1, this bit indicates that the text (set of key=value pairs) in this Login Response is not complete (it will be continued on subsequent Login Responses); otherwise, it indicates that this Login Response ends a set of key=value pairs. A Login Response with the C bit set to 1 MUST have the T bit set to 0."
    },
    {
      "indent": 0,
      "text": "11.13.8. Login Parameters",
      "section_title": true,
      "zh-cn": "11.13.8. Login Parameters"
    },
    {
      "indent": 3,
      "text": "The target MUST provide some basic parameters in order to enable the initiator to determine if it is connected to the correct port and the initial text parameters for the security exchange.",
      "zh-cn": "The target MUST provide some basic parameters in order to enable the initiator to determine if it is connected to the correct port and the initial text parameters for the security exchange."
    },
    {
      "indent": 3,
      "text": "All the rules specified in Section 11.11.6 for Text Responses also hold for Login Responses. Keys and their explanations are listed in Section 12 (security negotiation keys) and in Section 13 (operational parameter negotiation keys). All keys listed in Section 13, except for the X extension formats, MUST be supported by iSCSI initiators and targets. Keys listed in Section 12 only need to be supported when the function to which they refer is mandatory to implement.",
      "zh-cn": "All the rules specified in Section 11.11.6 for Text Responses also hold for Login Responses. Keys and their explanations are listed in Section 12 (security negotiation keys) and in Section 13 (operational parameter negotiation keys). All keys listed in Section 13, except for the X extension formats, MUST be supported by iSCSI initiators and targets. Keys listed in Section 12 only need to be supported when the function to which they refer is mandatory to implement."
    },
    {
      "indent": 0,
      "text": "11.14. Logout Request",
      "section_title": true,
      "zh-cn": "11.14. Logout Request"
    },
    {
      "indent": 3,
      "text": "The Logout Request is used to perform a controlled closing of a connection.",
      "zh-cn": "The Logout Request is used to perform a controlled closing of a connection."
    },
    {
      "indent": 3,
      "text": "An initiator MAY use a Logout Request to remove a connection from a session or to close an entire session.",
      "zh-cn": "An initiator MAY use a Logout Request to remove a connection from a session or to close an entire session."
    },
    {
      "indent": 3,
      "text": "After sending the Logout Request PDU, an initiator MUST NOT send any new iSCSI requests on the closing connection. If the Logout Request is intended to close the session, new iSCSI requests MUST NOT be sent on any of the connections participating in the session.",
      "zh-cn": "After sending the Logout Request PDU, an initiator MUST NOT send any new iSCSI requests on the closing connection. If the Logout Request is intended to close the session, new iSCSI requests MUST NOT be sent on any of the connections participating in the session."
    },
    {
      "indent": 3,
      "text": "When receiving a Logout Request with the reason code \"close the connection\" or \"close the session\", the target MUST terminate all pending commands, whether acknowledged via the ExpCmdSN or not, on that connection or session, respectively.",
      "zh-cn": "When receiving a Logout Request with the reason code \"close the connection\" or \"close the session\", the target MUST terminate all pending commands, whether acknowledged via the ExpCmdSN or not, on that connection or session, respectively."
    },
    {
      "indent": 3,
      "text": "When receiving a Logout Request with the reason code \"remove the connection for recovery\", the target MUST discard all requests not yet acknowledged via the ExpCmdSN that were issued on the specified connection and suspend all data/status/R2T transfers on behalf of pending commands on the specified connection.",
      "zh-cn": "When receiving a Logout Request with the reason code \"remove the connection for recovery\", the target MUST discard all requests not yet acknowledged via the ExpCmdSN that were issued on the specified connection and suspend all data/status/R2T transfers on behalf of pending commands on the specified connection."
    },
    {
      "indent": 3,
      "text": "The target then issues the Logout Response and half-closes the TCP connection (sends FIN). After receiving the Logout Response and attempting to receive the FIN (if still possible), the initiator MUST completely close the logging-out connection. For the terminated commands, no additional responses should be expected.",
      "zh-cn": "The target then issues the Logout Response and half-closes the TCP connection (sends FIN). After receiving the Logout Response and attempting to receive the FIN (if still possible), the initiator MUST completely close the logging-out connection. For the terminated commands, no additional responses should be expected."
    },
    {
      "indent": 3,
      "text": "A Logout for a CID may be performed on a different transport connection when the TCP connection for the CID has already been terminated. In such a case, only a logical \"closing\" of the iSCSI connection for the CID is implied with a Logout.",
      "zh-cn": "A Logout for a CID may be performed on a different transport connection when the TCP connection for the CID has already been terminated. In such a case, only a logical \"closing\" of the iSCSI connection for the CID is implied with a Logout."
    },
    {
      "indent": 3,
      "text": "All commands that were not terminated or not completed (with status) and acknowledged when the connection is closed completely can be reassigned to a new connection if the target supports connection recovery.",
      "zh-cn": "All commands that were not terminated or not completed (with status) and acknowledged when the connection is closed completely can be reassigned to a new connection if the target supports connection recovery."
    },
    {
      "indent": 3,
      "text": "If an initiator intends to start recovery for a failing connection, it MUST use the Logout Request to \"clean up\" the target end of a failing connection and enable recovery to start, or use the Login Request with a non-zero TSIH and the same CID on a new connection for the same effect. In sessions with a single connection, the connection can be closed and then a new connection reopened. A connection reinstatement login can be used for recovery (see Section 6.3.4).",
      "zh-cn": "If an initiator intends to start recovery for a failing connection, it MUST use the Logout Request to \"clean up\" the target end of a failing connection and enable recovery to start, or use the Login Request with a non-zero TSIH and the same CID on a new connection for the same effect. In sessions with a single connection, the connection can be closed and then a new connection reopened. A connection reinstatement login can be used for recovery (see Section 6.3.4)."
    },
    {
      "indent": 3,
      "text": "A successful completion of a Logout Request with the reason code \"close the connection\" or \"remove the connection for recovery\" results at the target in the discarding of unacknowledged commands received on the connection being logged out. These are commands that have arrived on the connection being logged out but that have not been delivered to SCSI because one or more commands with a smaller CmdSN have not been received by iSCSI. See Section 4.2.2.1. The resulting holes in the command sequence numbers will have to be handled by appropriate recovery (see Section 7), unless the session is also closed.",
      "zh-cn": "A successful completion of a Logout Request with the reason code \"close the connection\" or \"remove the connection for recovery\" results at the target in the discarding of unacknowledged commands received on the connection being logged out. These are commands that have arrived on the connection being logged out but that have not been delivered to SCSI because one or more commands with a smaller CmdSN have not been received by iSCSI. See Section 4.2.2.1. The resulting holes in the command sequence numbers will have to be handled by appropriate recovery (see Section 7), unless the session is also closed."
    },
    {
      "indent": 3,
      "text": "The entire logout discussion in this section is also applicable for an implicit Logout realized by way of a connection reinstatement or session reinstatement. When a Login Request performs an implicit Logout, the implicit Logout is performed as if having the reason codes specified below:",
      "zh-cn": "The entire logout discussion in this section is also applicable for an implicit Logout realized by way of a connection reinstatement or session reinstatement. When a Login Request performs an implicit Logout, the implicit Logout is performed as if having the reason codes specified below:"
    },
    {
      "indent": 5,
      "text": "Reason Code     Type of Implicit Logout\n-------------------------------------------------------------",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 10,
      "text": "0 session reinstatement",
      "zh-cn": "0 session reinstatement"
    },
    {
      "indent": 10,
      "text": "1 connection reinstatement when the operational ErrorRecoveryLevel < 2",
      "zh-cn": "1 connection reinstatement when the operational ErrorRecoveryLevel < 2"
    },
    {
      "indent": 10,
      "text": "2 connection reinstatement when the operational ErrorRecoveryLevel = 2",
      "zh-cn": "2 connection reinstatement when the operational ErrorRecoveryLevel = 2"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| 0x06      |1| Reason Code | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------------------------------------------------------+\n 8/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| CID or Reserved               | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.14.1. Reason Code",
      "section_title": true,
      "zh-cn": "11.14.1. Reason Code"
    },
    {
      "indent": 3,
      "text": "The Reason Code field indicates the reason for Logout as follows:",
      "zh-cn": "The Reason Code field indicates the reason for Logout as follows:"
    },
    {
      "indent": 6,
      "text": "0 - close the session. All commands associated with the session (if any) are terminated.",
      "zh-cn": "0 - close the session. All commands associated with the session (if any) are terminated."
    },
    {
      "indent": 6,
      "text": "1 - close the connection. All commands associated with the connection (if any) are terminated.",
      "zh-cn": "1 - close the connection. All commands associated with the connection (if any) are terminated."
    },
    {
      "indent": 6,
      "text": "2 - remove the connection for recovery. The connection is closed, and all commands associated with it, if any, are to be prepared for a new allegiance.",
      "zh-cn": "2 - remove the connection for recovery. The connection is closed, and all commands associated with it, if any, are to be prepared for a new allegiance."
    },
    {
      "indent": 3,
      "text": "All other values are reserved.",
      "zh-cn": "All other values are reserved."
    },
    {
      "indent": 0,
      "text": "11.14.2. TotalAHSLength and DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.14.2. TotalAHSLength and DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0.",
      "zh-cn": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.14.3. CID",
      "section_title": true,
      "zh-cn": "11.14.3. CID"
    },
    {
      "indent": 3,
      "text": "This is the connection ID of the connection to be closed (including closing the TCP stream). This field is only valid if the reason code is not \"close the session\".",
      "zh-cn": "This is the connection ID of the connection to be closed (including closing the TCP stream). This field is only valid if the reason code is not \"close the session\"."
    },
    {
      "indent": 0,
      "text": "11.14.4. ExpStatSN",
      "section_title": true,
      "zh-cn": "11.14.4. ExpStatSN"
    },
    {
      "indent": 3,
      "text": "This is the last ExpStatSN value for the connection to be closed.",
      "zh-cn": "This is the last ExpStatSN value for the connection to be closed."
    },
    {
      "indent": 0,
      "text": "11.14.5. Implicit Termination of Tasks",
      "section_title": true,
      "zh-cn": "11.14.5. Implicit Termination of Tasks"
    },
    {
      "indent": 3,
      "text": "A target implicitly terminates the active tasks due to the iSCSI protocol in the following cases:",
      "zh-cn": "A target implicitly terminates the active tasks due to the iSCSI protocol in the following cases:"
    },
    {
      "indent": 6,
      "text": "a) When a connection is implicitly or explicitly logged out with the reason code \"close the connection\" and there are active tasks allegiant to that connection.",
      "zh-cn": "a) When a connection is implicitly or explicitly logged out with the reason code \"close the connection\" and there are active tasks allegiant to that connection."
    },
    {
      "indent": 6,
      "text": "b) When a connection fails and eventually the connection state times out (state transition M1 in Section 8.2.2) and there are active tasks allegiant to that connection.",
      "zh-cn": "b) When a connection fails and eventually the connection state times out (state transition M1 in Section 8.2.2) and there are active tasks allegiant to that connection."
    },
    {
      "indent": 6,
      "text": "c) When a successful recovery Logout is performed while there are active tasks allegiant to that connection and those tasks eventually time out after the Time2Wait and Time2Retain periods without allegiance reassignment.",
      "zh-cn": "c) When a successful recovery Logout is performed while there are active tasks allegiant to that connection and those tasks eventually time out after the Time2Wait and Time2Retain periods without allegiance reassignment."
    },
    {
      "indent": 6,
      "text": "d) When a connection is implicitly or explicitly logged out with the reason code \"close the session\" and there are active tasks in that session.",
      "zh-cn": "d) When a connection is implicitly or explicitly logged out with the reason code \"close the session\" and there are active tasks in that session."
    },
    {
      "indent": 3,
      "text": "If the tasks terminated in any of the above cases are SCSI tasks, they must be internally terminated as if with CHECK CONDITION status. This status is only meaningful for appropriately handling the internal SCSI state and SCSI side effects with respect to ordering, because this status is never communicated back as a terminating status to the initiator. However, additional actions may have to be taken at the SCSI level, depending on the SCSI context as defined by the SCSI standards (e.g., queued commands and ACA; UA for the next command on the I_T nexus in cases a), b), and c) above). After the tasks are terminated, the target MUST report a Unit Attention condition on the next command processed on any connection for each affected I_T_L nexus with the status of CHECK CONDITION, the ASC/ASCQ value of 47h/7Fh (\"SOME COMMANDS CLEARED BY ISCSI PROTOCOL EVENT\"), etc.; see [SPC3].",
      "zh-cn": "If the tasks terminated in any of the above cases are SCSI tasks, they must be internally terminated as if with CHECK CONDITION status. This status is only meaningful for appropriately handling the internal SCSI state and SCSI side effects with respect to ordering, because this status is never communicated back as a terminating status to the initiator. However, additional actions may have to be taken at the SCSI level, depending on the SCSI context as defined by the SCSI standards (e.g., queued commands and ACA; UA for the next command on the I_T nexus in cases a), b), and c) above). After the tasks are terminated, the target MUST report a Unit Attention condition on the next command processed on any connection for each affected I_T_L nexus with the status of CHECK CONDITION, the ASC/ASCQ value of 47h/7Fh (\"SOME COMMANDS CLEARED BY ISCSI PROTOCOL EVENT\"), etc.; see [SPC3]."
    },
    {
      "indent": 0,
      "text": "11.15. Logout Response",
      "section_title": true,
      "zh-cn": "11.15. Logout Response"
    },
    {
      "indent": 3,
      "text": "The Logout Response is used by the target to indicate if the cleanup operation for the connection(s) has completed.",
      "zh-cn": "The Logout Response is used by the target to indicate if the cleanup operation for the connection(s) has completed."
    },
    {
      "indent": 3,
      "text": "After Logout, the TCP connection referred by the CID MUST be closed at both ends (or all connections must be closed if the logout reason was session close).",
      "zh-cn": "After Logout, the TCP connection referred by the CID MUST be closed at both ends (or all connections must be closed if the logout reason was session close)."
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x26      |1| Reserved    | Response      | Reserved      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------------------------------------------------------+\n 8/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag                                            |\n  +---------------+---------------+---------------+---------------+\n20| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| Reserved                                                      |\n  +---------------------------------------------------------------+\n40| Time2Wait                     | Time2Retain                   |\n  +---------------+---------------+---------------+---------------+\n44| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "11.15.1. Response",
      "section_title": true,
      "zh-cn": "11.15.1. Response"
    },
    {
      "indent": 3,
      "text": "Response field settings are as follows:",
      "zh-cn": "Response field settings are as follows:"
    },
    {
      "indent": 6,
      "text": "0 - connection or session closed successfully.",
      "zh-cn": "0 - connection or session closed successfully."
    },
    {
      "indent": 6,
      "text": "1 - CID not found.",
      "zh-cn": "1 - CID not found."
    },
    {
      "indent": 6,
      "text": "2 - connection recovery is not supported (i.e., the Logout reason code was \"remove the connection for recovery\" and the target does not support it as indicated by the operational ErrorRecoveryLevel).",
      "zh-cn": "2 - connection recovery is not supported (i.e., the Logout reason code was \"remove the connection for recovery\" and the target does not support it as indicated by the operational ErrorRecoveryLevel)."
    },
    {
      "indent": 6,
      "text": "3 - cleanup failed for various reasons.",
      "zh-cn": "3 - cleanup failed for various reasons."
    },
    {
      "indent": 0,
      "text": "11.15.2. TotalAHSLength and DataSegmentLength",
      "section_title": true,
      "zh-cn": "11.15.2. TotalAHSLength and DataSegmentLength"
    },
    {
      "indent": 3,
      "text": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0.",
      "zh-cn": "For this PDU, TotalAHSLength and DataSegmentLength MUST be 0."
    },
    {
      "indent": 0,
      "text": "11.15.3. Time2Wait",
      "section_title": true,
      "zh-cn": "11.15.3. Time2Wait"
    },
    {
      "indent": 3,
      "text": "If the Logout response code is 0 and the operational ErrorRecoveryLevel is 2, this is the minimum amount of time, in seconds, to wait before attempting task reassignment. If the Logout response code is 0 and the operational ErrorRecoveryLevel is less than 2, this field is to be ignored.",
      "zh-cn": "If the Logout response code is 0 and the operational ErrorRecoveryLevel is 2, this is the minimum amount of time, in seconds, to wait before attempting task reassignment. If the Logout response code is 0 and the operational ErrorRecoveryLevel is less than 2, this field is to be ignored."
    },
    {
      "indent": 3,
      "text": "This field is invalid if the Logout response code is 1.",
      "zh-cn": "This field is invalid if the Logout response code is 1."
    },
    {
      "indent": 3,
      "text": "If the Logout response code is 2 or 3, this field specifies the minimum time to wait before attempting a new implicit or explicit logout.",
      "zh-cn": "If the Logout response code is 2 or 3, this field specifies the minimum time to wait before attempting a new implicit or explicit logout."
    },
    {
      "indent": 3,
      "text": "If Time2Wait is 0, the reassignment or a new Logout may be attempted immediately.",
      "zh-cn": "If Time2Wait is 0, the reassignment or a new Logout may be attempted immediately."
    },
    {
      "indent": 0,
      "text": "11.15.4. Time2Retain",
      "section_title": true,
      "zh-cn": "11.15.4. Time2Retain"
    },
    {
      "indent": 3,
      "text": "If the Logout response code is 0 and the operational ErrorRecoveryLevel is 2, this is the maximum amount of time, in seconds, after the initial wait (Time2Wait) that the target waits for the allegiance reassignment for any active task, after which the task state is discarded. If the Logout response code is 0 and the operational ErrorRecoveryLevel is less than 2, this field is to be ignored.",
      "zh-cn": "If the Logout response code is 0 and the operational ErrorRecoveryLevel is 2, this is the maximum amount of time, in seconds, after the initial wait (Time2Wait) that the target waits for the allegiance reassignment for any active task, after which the task state is discarded. If the Logout response code is 0 and the operational ErrorRecoveryLevel is less than 2, this field is to be ignored."
    },
    {
      "indent": 3,
      "text": "This field is invalid if the Logout response code is 1.",
      "zh-cn": "This field is invalid if the Logout response code is 1."
    },
    {
      "indent": 3,
      "text": "If the Logout response code is 2 or 3, this field specifies the maximum amount of time, in seconds, after the initial wait (Time2Wait) that the target waits for a new implicit or explicit logout.",
      "zh-cn": "If the Logout response code is 2 or 3, this field specifies the maximum amount of time, in seconds, after the initial wait (Time2Wait) that the target waits for a new implicit or explicit logout."
    },
    {
      "indent": 3,
      "text": "If it is the last connection of a session, the whole session state is discarded after Time2Retain.",
      "zh-cn": "If it is the last connection of a session, the whole session state is discarded after Time2Retain."
    },
    {
      "indent": 3,
      "text": "If Time2Retain is 0, the target has already discarded the connection (and possibly the session) state along with the task states. No reassignment or Logout is required in this case.",
      "zh-cn": "If Time2Retain is 0, the target has already discarded the connection (and possibly the session) state along with the task states. No reassignment or Logout is required in this case."
    },
    {
      "indent": 0,
      "text": "11.16. SNACK Request",
      "section_title": true,
      "zh-cn": "11.16. SNACK Request"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x10      |1|.|.|.| Type  | Reserved                      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag or 0xffffffff                              |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or SNACK Tag or 0xffffffff                |\n  +---------------+---------------+---------------+---------------+\n24| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n40| BegRun                                                        |\n  +---------------------------------------------------------------+\n44| RunLength                                                     |\n  +---------------------------------------------------------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the implementation supports ErrorRecoveryLevel greater than zero, it MUST support all SNACK types.",
      "zh-cn": "If the implementation supports ErrorRecoveryLevel greater than zero, it MUST support all SNACK types."
    },
    {
      "indent": 3,
      "text": "The SNACK is used by the initiator to request the retransmission of numbered responses, data, or R2T PDUs from the target. The SNACK Request indicates the numbered responses or data \"runs\" whose retransmission is requested, where the run starts with the first StatSN, DataSN, or R2TSN whose retransmission is requested and indicates the number of Status, Data, or R2T PDUs requested, including the first. 0 has special meaning when used as a starting number and length:",
      "zh-cn": "The SNACK is used by the initiator to request the retransmission of numbered responses, data, or R2T PDUs from the target. The SNACK Request indicates the numbered responses or data \"runs\" whose retransmission is requested, where the run starts with the first StatSN, DataSN, or R2TSN whose retransmission is requested and indicates the number of Status, Data, or R2T PDUs requested, including the first. 0 has special meaning when used as a starting number and length:"
    },
    {
      "indent": 6,
      "text": "- When used in RunLength, it means all PDUs starting with the initial.",
      "zh-cn": "- When used in RunLength, it means all PDUs starting with the initial."
    },
    {
      "indent": 6,
      "text": "- When used in both BegRun and RunLength, it means all unacknowledged PDUs.",
      "zh-cn": "- When used in both BegRun and RunLength, it means all unacknowledged PDUs."
    },
    {
      "indent": 3,
      "text": "The numbered response(s) or R2T(s) requested by a SNACK MUST be delivered as exact replicas of the ones that the target transmitted originally, except for the fields ExpCmdSN, MaxCmdSN, and ExpDataSN, which MUST carry the current values. R2T(s)requested by SNACK MUST also carry the current value of the StatSN.",
      "zh-cn": "The numbered response(s) or R2T(s) requested by a SNACK MUST be delivered as exact replicas of the ones that the target transmitted originally, except for the fields ExpCmdSN, MaxCmdSN, and ExpDataSN, which MUST carry the current values. R2T(s)requested by SNACK MUST also carry the current value of the StatSN."
    },
    {
      "indent": 3,
      "text": "The numbered Data-In PDUs requested by a Data SNACK MUST be delivered as exact replicas of the ones that the target transmitted originally, except for the fields ExpCmdSN and MaxCmdSN, which MUST carry the current values; and except for resegmentation (see Section 11.16.3).",
      "zh-cn": "The numbered Data-In PDUs requested by a Data SNACK MUST be delivered as exact replicas of the ones that the target transmitted originally, except for the fields ExpCmdSN and MaxCmdSN, which MUST carry the current values; and except for resegmentation (see Section 11.16.3)."
    },
    {
      "indent": 3,
      "text": "Any SNACK that requests a numbered response, data, or R2T that was not sent by the target or was already acknowledged by the initiator MUST be rejected with a reason code of \"Protocol Error\".",
      "zh-cn": "Any SNACK that requests a numbered response, data, or R2T that was not sent by the target or was already acknowledged by the initiator MUST be rejected with a reason code of \"Protocol Error\"."
    },
    {
      "indent": 0,
      "text": "11.16.1. Type",
      "section_title": true,
      "zh-cn": "11.16.1. Type"
    },
    {
      "indent": 3,
      "text": "This field encodes the SNACK function as follows:",
      "zh-cn": "This field encodes the SNACK function as follows:"
    },
    {
      "indent": 6,
      "text": "0 - Data/R2T SNACK: requesting retransmission of one or more Data-In or R2T PDUs.",
      "zh-cn": "0 - Data/R2T SNACK: requesting retransmission of one or more Data-In or R2T PDUs."
    },
    {
      "indent": 6,
      "text": "1 - Status SNACK: requesting retransmission of one or more numbered responses.",
      "zh-cn": "1 - Status SNACK: requesting retransmission of one or more numbered responses."
    },
    {
      "indent": 6,
      "text": "2 - DataACK: positively acknowledges Data-In PDUs.",
      "zh-cn": "2 - DataACK: positively acknowledges Data-In PDUs."
    },
    {
      "indent": 6,
      "text": "3 - R-Data SNACK: requesting retransmission of Data-In PDUs with possible resegmentation and status tagging.",
      "zh-cn": "3 - R-Data SNACK: requesting retransmission of Data-In PDUs with possible resegmentation and status tagging."
    },
    {
      "indent": 3,
      "text": "All other values are reserved.",
      "zh-cn": "All other values are reserved."
    },
    {
      "indent": 3,
      "text": "Data/R2T SNACK, Status SNACK, or R-Data SNACK for a command MUST precede status acknowledgment for the given command.",
      "zh-cn": "Data/R2T SNACK, Status SNACK, or R-Data SNACK for a command MUST precede status acknowledgment for the given command."
    },
    {
      "indent": 0,
      "text": "11.16.2. Data Acknowledgment",
      "section_title": true,
      "zh-cn": "11.16.2. Data Acknowledgment"
    },
    {
      "indent": 3,
      "text": "If an initiator operates at ErrorRecoveryLevel 1 or higher, it MUST issue a SNACK of type DataACK after receiving a Data-In PDU with the A bit set to 1. However, if the initiator has detected holes in the input sequence, it MUST postpone issuing the SNACK of type DataACK until the holes are filled. An initiator MAY ignore the A bit if it deems that the bit is being set aggressively by the target (i.e., before the MaxBurstLength limit is reached).",
      "zh-cn": "If an initiator operates at ErrorRecoveryLevel 1 or higher, it MUST issue a SNACK of type DataACK after receiving a Data-In PDU with the A bit set to 1. However, if the initiator has detected holes in the input sequence, it MUST postpone issuing the SNACK of type DataACK until the holes are filled. An initiator MAY ignore the A bit if it deems that the bit is being set aggressively by the target (i.e., before the MaxBurstLength limit is reached)."
    },
    {
      "indent": 3,
      "text": "The DataACK is used to free resources at the target and not to request or imply data retransmission.",
      "zh-cn": "The DataACK is used to free resources at the target and not to request or imply data retransmission."
    },
    {
      "indent": 3,
      "text": "An initiator MUST NOT request retransmission for any data it had already acknowledged.",
      "zh-cn": "An initiator MUST NOT request retransmission for any data it had already acknowledged."
    },
    {
      "indent": 0,
      "text": "11.16.3. Resegmentation",
      "section_title": true,
      "zh-cn": "11.16.3. Resegmentation"
    },
    {
      "indent": 3,
      "text": "If the initiator MaxRecvDataSegmentLength changed between the original transmission and the time the initiator requests retransmission, the initiator MUST issue a R-Data SNACK (see Section 11.16.1). With R-Data SNACK, the initiator indicates that it discards all the unacknowledged data and expects the target to resend it. It also expects resegmentation. In this case, the retransmitted Data-In PDUs MAY be different from the ones originally sent in order to reflect changes in MaxRecvDataSegmentLength. Their DataSN starts with the BegRun of the last DataACK received by the target if any was received; otherwise, it starts with 0 and is increased by 1 for each resent Data-In PDU.",
      "zh-cn": "If the initiator MaxRecvDataSegmentLength changed between the original transmission and the time the initiator requests retransmission, the initiator MUST issue a R-Data SNACK (see Section 11.16.1). With R-Data SNACK, the initiator indicates that it discards all the unacknowledged data and expects the target to resend it. It also expects resegmentation. In this case, the retransmitted Data-In PDUs MAY be different from the ones originally sent in order to reflect changes in MaxRecvDataSegmentLength. Their DataSN starts with the BegRun of the last DataACK received by the target if any was received; otherwise, it starts with 0 and is increased by 1 for each resent Data-In PDU."
    },
    {
      "indent": 3,
      "text": "A target that has received a R-Data SNACK MUST return a SCSI Response that contains a copy of the SNACK Tag field from the R-Data SNACK in the SCSI Response SNACK Tag field as its last or only Response. For example, if it has already sent a response containing another value in the SNACK Tag field or had the status included in the last Data-In PDU, it must send a new SCSI Response PDU. If a target sends more than one SCSI Response PDU due to this rule, all SCSI Response PDUs must carry the same StatSN (see Section 11.4.4). If an initiator attempts to recover a lost SCSI Response (with a Status-SNACK; see Section 11.16.1) when more than one response has been sent, the target will send the SCSI Response with the latest content known to the target, including the last SNACK Tag for the command.",
      "zh-cn": "A target that has received a R-Data SNACK MUST return a SCSI Response that contains a copy of the SNACK Tag field from the R-Data SNACK in the SCSI Response SNACK Tag field as its last or only Response. For example, if it has already sent a response containing another value in the SNACK Tag field or had the status included in the last Data-In PDU, it must send a new SCSI Response PDU. If a target sends more than one SCSI Response PDU due to this rule, all SCSI Response PDUs must carry the same StatSN (see Section 11.4.4). If an initiator attempts to recover a lost SCSI Response (with a Status-SNACK; see Section 11.16.1) when more than one response has been sent, the target will send the SCSI Response with the latest content known to the target, including the last SNACK Tag for the command."
    },
    {
      "indent": 3,
      "text": "For considerations in allegiance reassignment of a task to a connection with a different MaxRecvDataSegmentLength, refer to Section 7.2.2.",
      "zh-cn": "For considerations in allegiance reassignment of a task to a connection with a different MaxRecvDataSegmentLength, refer to Section 7.2.2."
    },
    {
      "indent": 0,
      "text": "11.16.4. Initiator Task Tag",
      "section_title": true,
      "zh-cn": "11.16.4. Initiator Task Tag"
    },
    {
      "indent": 3,
      "text": "For a Status SNACK and DataACK, the Initiator Task Tag MUST be set to the reserved value 0xffffffff. In all other cases, the Initiator Task Tag field MUST be set to the Initiator Task Tag of the referenced command.",
      "zh-cn": "For a Status SNACK and DataACK, the Initiator Task Tag MUST be set to the reserved value 0xffffffff. In all other cases, the Initiator Task Tag field MUST be set to the Initiator Task Tag of the referenced command."
    },
    {
      "indent": 0,
      "text": "11.16.5. Target Transfer Tag or SNACK Tag",
      "section_title": true,
      "zh-cn": "11.16.5. Target Transfer Tag or SNACK Tag"
    },
    {
      "indent": 3,
      "text": "For a R-Data SNACK, this field MUST contain a value that is different from 0 or 0xffffffff and is unique for the task (identified by the Initiator Task Tag). This value MUST be copied by the iSCSI target in the last or only SCSI Response PDU it issues for the command.",
      "zh-cn": "For a R-Data SNACK, this field MUST contain a value that is different from 0 or 0xffffffff and is unique for the task (identified by the Initiator Task Tag). This value MUST be copied by the iSCSI target in the last or only SCSI Response PDU it issues for the command."
    },
    {
      "indent": 3,
      "text": "For DataACK, the Target Transfer Tag MUST contain a copy of the Target Transfer Tag and LUN provided with the SCSI Data-In PDU with the A bit set to 1.",
      "zh-cn": "For DataACK, the Target Transfer Tag MUST contain a copy of the Target Transfer Tag and LUN provided with the SCSI Data-In PDU with the A bit set to 1."
    },
    {
      "indent": 3,
      "text": "In all other cases, the Target Transfer Tag field MUST be set to the reserved value 0xffffffff.",
      "zh-cn": "In all other cases, the Target Transfer Tag field MUST be set to the reserved value 0xffffffff."
    },
    {
      "indent": 0,
      "text": "11.16.6. BegRun",
      "section_title": true,
      "zh-cn": "11.16.6. BegRun"
    },
    {
      "indent": 3,
      "text": "This field indicates the DataSN, R2TSN, or StatSN of the first PDU whose retransmission is requested (Data/R2T and Status SNACK), or the next expected DataSN (DataACK SNACK).",
      "zh-cn": "This field indicates the DataSN, R2TSN, or StatSN of the first PDU whose retransmission is requested (Data/R2T and Status SNACK), or the next expected DataSN (DataACK SNACK)."
    },
    {
      "indent": 3,
      "text": "A BegRun of 0, when used in conjunction with a RunLength of 0, means \"resend all unacknowledged Data-In, R2T or Response PDUs\".",
      "zh-cn": "A BegRun of 0, when used in conjunction with a RunLength of 0, means \"resend all unacknowledged Data-In, R2T or Response PDUs\"."
    },
    {
      "indent": 3,
      "text": "BegRun MUST be 0 for a R-Data SNACK.",
      "zh-cn": "BegRun MUST be 0 for a R-Data SNACK."
    },
    {
      "indent": 0,
      "text": "11.16.7. RunLength",
      "section_title": true,
      "zh-cn": "11.16.7. RunLength"
    },
    {
      "indent": 3,
      "text": "This field indicates the number of PDUs whose retransmission is requested.",
      "zh-cn": "This field indicates the number of PDUs whose retransmission is requested."
    },
    {
      "indent": 3,
      "text": "A RunLength of 0 signals that all Data-In, R2T, or Response PDUs carrying the numbers equal to or greater than BegRun have to be resent.",
      "zh-cn": "A RunLength of 0 signals that all Data-In, R2T, or Response PDUs carrying the numbers equal to or greater than BegRun have to be resent."
    },
    {
      "indent": 3,
      "text": "The RunLength MUST also be 0 for a DataACK SNACK in addition to a R-Data SNACK.",
      "zh-cn": "The RunLength MUST also be 0 for a DataACK SNACK in addition to a R-Data SNACK."
    },
    {
      "indent": 0,
      "text": "11.17. Reject",
      "section_title": true,
      "zh-cn": "11.17. Reject"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x3f      |1| Reserved    | Reason        | Reserved      |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n16| 0xffffffff                                                    |\n  +---------------+---------------+---------------+---------------+\n20| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36| DataSN/R2TSN or Reserved                                      |\n  +---------------+---------------+---------------+---------------+\n40| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n44| Reserved                                                      |\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\nxx/ Complete Header of Bad PDU                                    /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\nyy/Vendor-specific data (if any)                                  /\n  /                                                               /\n  +---------------+---------------+---------------+---------------+\nzz| Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Reject is used to indicate an iSCSI error condition (protocol, unsupported option, etc.).",
      "zh-cn": "Reject is used to indicate an iSCSI error condition (protocol, unsupported option, etc.)."
    },
    {
      "indent": 0,
      "text": "11.17.1. Reason",
      "section_title": true,
      "zh-cn": "11.17.1. Reason"
    },
    {
      "indent": 3,
      "text": "The reject Reason is coded as follows:",
      "zh-cn": "The reject Reason is coded as follows:"
    },
    {
      "indent": 3,
      "text": "+------+----------------------------------------+----------------+\n| Code | Explanation                            |Can the original|\n| (hex)|                                        |PDU be resent?  |\n+------+----------------------------------------+----------------+\n| 0x01 | Reserved                               | no             |\n|      |                                        |                |\n| 0x02 | Data (payload) digest error            | yes (Note 1)   |\n|      |                                        |                |\n| 0x03 | SNACK Reject                           | yes            |\n|      |                                        |                |\n| 0x04 | Protocol Error (e.g., SNACK Request for| no             |\n|      | a status that was already acknowledged)|                |\n|      |                                        |                |\n| 0x05 | Command not supported                  | no             |\n|      |                                        |                |\n| 0x06 | Immediate command reject - too many    | yes            |\n|      | immediate commands                     |                |\n|      |                                        |                |\n| 0x07 | Task in progress                       | no             |\n|      |                                        |                |\n| 0x08 | Invalid data ack                       | no             |\n|      |                                        |                |\n| 0x09 | Invalid PDU field                      | no (Note 2)    |\n|      |                                        |                |\n| 0x0a | Long op reject - Can't generate Target | yes            |\n|      | Transfer Tag - out of resources        |                |\n|      |                                        |                |\n| 0x0b | Deprecated; MUST NOT be used           | N/A (Note 3)   |\n|      |                                        |                |\n| 0x0c | Waiting for Logout                     | no             |\n+------+----------------------------------------+----------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Note 1: For iSCSI, Data-Out PDU retransmission is only done if the target requests retransmission with a recovery R2T. However, if this is the data digest error on immediate data, the initiator may choose to retransmit the whole PDU, including the immediate data.",
      "zh-cn": "Note 1: For iSCSI, Data-Out PDU retransmission is only done if the target requests retransmission with a recovery R2T. However, if this is the data digest error on immediate data, the initiator may choose to retransmit the whole PDU, including the immediate data."
    },
    {
      "indent": 3,
      "text": "Note 2: A target should use this reason code for all invalid values of PDU fields that are meant to describe a task, a response, or a data transfer. Some examples are invalid TTT/ITT, buffer offset, LUN qualifying a TTT, and an invalid sequence number in a SNACK.",
      "zh-cn": "Note 2: A target should use this reason code for all invalid values of PDU fields that are meant to describe a task, a response, or a data transfer. Some examples are invalid TTT/ITT, buffer offset, LUN qualifying a TTT, and an invalid sequence number in a SNACK."
    },
    {
      "indent": 3,
      "text": "Note 3: Reason code 0x0b (\"Negotiation Reset\") as defined in Section 10.17.1 of [RFC3720] is deprecated and MUST NOT be used by implementations. An implementation receiving reason code 0x0b MUST treat it as a negotiation failure that terminates the Login Phase and the TCP connection, as specified in Section 7.12.",
      "zh-cn": "Note 3: Reason code 0x0b (\"Negotiation Reset\") as defined in Section 10.17.1 of [RFC3720] is deprecated and MUST NOT be used by implementations. An implementation receiving reason code 0x0b MUST treat it as a negotiation failure that terminates the Login Phase and the TCP connection, as specified in Section 7.12."
    },
    {
      "indent": 3,
      "text": "All other values for Reason are unassigned.",
      "zh-cn": "All other values for Reason are unassigned."
    },
    {
      "indent": 3,
      "text": "In all the cases in which a pre-instantiated SCSI task is terminated because of the reject, the target MUST issue a proper SCSI command response with CHECK CONDITION as described in Section 11.4.3. In these cases in which a status for the SCSI task was already sent before the reject, no additional status is required. If the error is detected while data from the initiator is still expected (i.e., the command PDU did not contain all the data and the target has not received a Data-Out PDU with the Final bit set to 1 for the unsolicited data, if any, and all outstanding R2Ts, if any), the target MUST wait until it receives the last expected Data-Out PDUs with the F bit set to 1 before sending the Response PDU.",
      "zh-cn": "In all the cases in which a pre-instantiated SCSI task is terminated because of the reject, the target MUST issue a proper SCSI command response with CHECK CONDITION as described in Section 11.4.3. In these cases in which a status for the SCSI task was already sent before the reject, no additional status is required. If the error is detected while data from the initiator is still expected (i.e., the command PDU did not contain all the data and the target has not received a Data-Out PDU with the Final bit set to 1 for the unsolicited data, if any, and all outstanding R2Ts, if any), the target MUST wait until it receives the last expected Data-Out PDUs with the F bit set to 1 before sending the Response PDU."
    },
    {
      "indent": 3,
      "text": "For additional usage semantics of the Reject PDU, see Section 7.3.",
      "zh-cn": "For additional usage semantics of the Reject PDU, see Section 7.3."
    },
    {
      "indent": 0,
      "text": "11.17.2. DataSN/R2TSN",
      "section_title": true,
      "zh-cn": "11.17.2. DataSN/R2TSN"
    },
    {
      "indent": 3,
      "text": "This field is only valid if the rejected PDU is a Data/R2T SNACK and the Reject reason code is \"Protocol Error\" (see Section 11.16). The DataSN/R2TSN is the next Data/R2T sequence number that the target would send for the task, if any.",
      "zh-cn": "This field is only valid if the rejected PDU is a Data/R2T SNACK and the Reject reason code is \"Protocol Error\" (see Section 11.16). The DataSN/R2TSN is the next Data/R2T sequence number that the target would send for the task, if any."
    },
    {
      "indent": 0,
      "text": "11.17.3. StatSN, ExpCmdSN, and MaxCmdSN",
      "section_title": true,
      "zh-cn": "11.17.3. StatSN, ExpCmdSN, and MaxCmdSN"
    },
    {
      "indent": 3,
      "text": "These fields carry their usual values and are not related to the rejected command. The StatSN is advanced after a Reject.",
      "zh-cn": "These fields carry their usual values and are not related to the rejected command. The StatSN is advanced after a Reject."
    },
    {
      "indent": 0,
      "text": "11.17.4. Complete Header of Bad PDU",
      "section_title": true,
      "zh-cn": "11.17.4. Complete Header of Bad PDU"
    },
    {
      "indent": 3,
      "text": "The target returns the header (not including the digest) of the PDU in error as the data of the response.",
      "zh-cn": "The target returns the header (not including the digest) of the PDU in error as the data of the response."
    },
    {
      "indent": 0,
      "text": "11.18. NOP-Out",
      "section_title": true,
      "zh-cn": "11.18. NOP-Out"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|I| 0x00      |1| Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag or 0xffffffff                              |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| CmdSN                                                         |\n  +---------------+---------------+---------------+---------------+\n28| ExpStatSN                                                     |\n  +---------------+---------------+---------------+---------------+\n32/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment - Ping Data (optional)                            /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "NOP-Out may be used by an initiator as a \"ping request\" to verify that a connection/session is still active and all its components are operational. The NOP-In response is the \"ping echo\".",
      "zh-cn": "NOP-Out may be used by an initiator as a \"ping request\" to verify that a connection/session is still active and all its components are operational. The NOP-In response is the \"ping echo\"."
    },
    {
      "indent": 3,
      "text": "A NOP-Out is also sent by an initiator in response to a NOP-In.",
      "zh-cn": "A NOP-Out is also sent by an initiator in response to a NOP-In."
    },
    {
      "indent": 3,
      "text": "A NOP-Out may also be used to confirm a changed ExpStatSN if another PDU will not be available for a long time.",
      "zh-cn": "A NOP-Out may also be used to confirm a changed ExpStatSN if another PDU will not be available for a long time."
    },
    {
      "indent": 3,
      "text": "Upon receipt of a NOP-In with the Target Transfer Tag set to a valid value (not the reserved value 0xffffffff), the initiator MUST respond with a NOP-Out. In this case, the NOP-Out Target Transfer Tag MUST contain a copy of the NOP-In Target Transfer Tag. The initiator",
      "zh-cn": "Upon receipt of a NOP-In with the Target Transfer Tag set to a valid value (not the reserved value 0xffffffff), the initiator MUST respond with a NOP-Out. In this case, the NOP-Out Target Transfer Tag MUST contain a copy of the NOP-In Target Transfer Tag. The initiator"
    },
    {
      "indent": 3,
      "text": "SHOULD NOT send a NOP-Out in response to any other received NOP-In, in order to avoid lengthy sequences of NOP-In and NOP-Out PDUs sent in response to each other.",
      "zh-cn": "SHOULD NOT send a NOP-Out in response to any other received NOP-In, in order to avoid lengthy sequences of NOP-In and NOP-Out PDUs sent in response to each other."
    },
    {
      "indent": 0,
      "text": "11.18.1. Initiator Task Tag",
      "section_title": true,
      "zh-cn": "11.18.1. Initiator Task Tag"
    },
    {
      "indent": 3,
      "text": "The NOP-Out MUST have the Initiator Task Tag set to a valid value only if a response in the form of a NOP-In is requested (i.e., the NOP-Out is used as a ping request). Otherwise, the Initiator Task Tag MUST be set to 0xffffffff.",
      "zh-cn": "The NOP-Out MUST have the Initiator Task Tag set to a valid value only if a response in the form of a NOP-In is requested (i.e., the NOP-Out is used as a ping request). Otherwise, the Initiator Task Tag MUST be set to 0xffffffff."
    },
    {
      "indent": 3,
      "text": "When a target receives the NOP-Out with a valid Initiator Task Tag, it MUST respond with a NOP-In Response (see Section 4.6.3.6).",
      "zh-cn": "When a target receives the NOP-Out with a valid Initiator Task Tag, it MUST respond with a NOP-In Response (see Section 4.6.3.6)."
    },
    {
      "indent": 3,
      "text": "If the Initiator Task Tag contains 0xffffffff, the I bit MUST be set to 1, and the CmdSN is not advanced after this PDU is sent.",
      "zh-cn": "If the Initiator Task Tag contains 0xffffffff, the I bit MUST be set to 1, and the CmdSN is not advanced after this PDU is sent."
    },
    {
      "indent": 0,
      "text": "11.18.2. Target Transfer Tag",
      "section_title": true,
      "zh-cn": "11.18.2. Target Transfer Tag"
    },
    {
      "indent": 3,
      "text": "The Target Transfer Tag is a target-assigned identifier for the operation.",
      "zh-cn": "The Target Transfer Tag is a target-assigned identifier for the operation."
    },
    {
      "indent": 3,
      "text": "The NOP-Out MUST only have the Target Transfer Tag set if it is issued in response to a NOP-In with a valid Target Transfer Tag. In this case, it copies the Target Transfer Tag from the NOP-In PDU. Otherwise, the Target Transfer Tag MUST be set to 0xffffffff.",
      "zh-cn": "The NOP-Out MUST only have the Target Transfer Tag set if it is issued in response to a NOP-In with a valid Target Transfer Tag. In this case, it copies the Target Transfer Tag from the NOP-In PDU. Otherwise, the Target Transfer Tag MUST be set to 0xffffffff."
    },
    {
      "indent": 3,
      "text": "When the Target Transfer Tag is set to a value other than 0xffffffff, the LUN field MUST also be copied from the NOP-In.",
      "zh-cn": "When the Target Transfer Tag is set to a value other than 0xffffffff, the LUN field MUST also be copied from the NOP-In."
    },
    {
      "indent": 0,
      "text": "11.18.3. Ping Data",
      "section_title": true,
      "zh-cn": "11.18.3. Ping Data"
    },
    {
      "indent": 3,
      "text": "Ping data is reflected in the NOP-In Response. The length of the reflected data is limited to MaxRecvDataSegmentLength. The length of ping data is indicated by the DataSegmentLength. 0 is a valid value for the DataSegmentLength and indicates the absence of ping data.",
      "zh-cn": "Ping data is reflected in the NOP-In Response. The length of the reflected data is limited to MaxRecvDataSegmentLength. The length of ping data is indicated by the DataSegmentLength. 0 is a valid value for the DataSegmentLength and indicates the absence of ping data."
    },
    {
      "indent": 0,
      "text": "11.19. NOP-In",
      "section_title": true,
      "zh-cn": "11.19. NOP-In"
    },
    {
      "indent": 3,
      "text": "Byte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|.|.| 0x20      |1| Reserved                                    |\n  +---------------+---------------+---------------+---------------+\n 4|TotalAHSLength | DataSegmentLength                             |\n  +---------------+---------------+---------------+---------------+\n 8| LUN or Reserved                                               |\n  +                                                               +\n12|                                                               |\n  +---------------+---------------+---------------+---------------+\n16| Initiator Task Tag or 0xffffffff                              |\n  +---------------+---------------+---------------+---------------+\n20| Target Transfer Tag or 0xffffffff                             |\n  +---------------+---------------+---------------+---------------+\n24| StatSN                                                        |\n  +---------------+---------------+---------------+---------------+\n28| ExpCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n32| MaxCmdSN                                                      |\n  +---------------+---------------+---------------+---------------+\n36/ Reserved                                                      /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n48| Header-Digest (optional)                                      |\n  +---------------+---------------+---------------+---------------+\n  / DataSegment - Return Ping Data                                /\n +/                                                               /\n  +---------------+---------------+---------------+---------------+\n  | Data-Digest (optional)                                        |\n  +---------------+---------------+---------------+---------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "NOP-In is sent by a target as either a response to a NOP-Out, a \"ping\" to an initiator, or a means to carry a changed ExpCmdSN and/or MaxCmdSN if another PDU will not be available for a long time (as determined by the target).",
      "zh-cn": "NOP-In is sent by a target as either a response to a NOP-Out, a \"ping\" to an initiator, or a means to carry a changed ExpCmdSN and/or MaxCmdSN if another PDU will not be available for a long time (as determined by the target)."
    },
    {
      "indent": 3,
      "text": "When a target receives the NOP-Out with a valid Initiator Task Tag (not the reserved value 0xffffffff), it MUST respond with a NOP-In with the same Initiator Task Tag that was provided in the NOP-Out request. It MUST also duplicate up to the first MaxRecvDataSegmentLength bytes of the initiator-provided Ping Data. For such a response, the Target Transfer Tag MUST be 0xffffffff. The",
      "zh-cn": "When a target receives the NOP-Out with a valid Initiator Task Tag (not the reserved value 0xffffffff), it MUST respond with a NOP-In with the same Initiator Task Tag that was provided in the NOP-Out request. It MUST also duplicate up to the first MaxRecvDataSegmentLength bytes of the initiator-provided Ping Data. For such a response, the Target Transfer Tag MUST be 0xffffffff. The"
    },
    {
      "indent": 3,
      "text": "target SHOULD NOT send a NOP-In in response to any other received NOP-Out in order to avoid lengthy sequences of NOP-In and NOP-Out PDUs sent in response to each other.",
      "zh-cn": "target SHOULD NOT send a NOP-In in response to any other received NOP-Out in order to avoid lengthy sequences of NOP-In and NOP-Out PDUs sent in response to each other."
    },
    {
      "indent": 3,
      "text": "Otherwise, when a target sends a NOP-In that is not a response to a NOP-Out received from the initiator, the Initiator Task Tag MUST be set to 0xffffffff, and the data segment MUST NOT contain any data (DataSegmentLength MUST be 0).",
      "zh-cn": "Otherwise, when a target sends a NOP-In that is not a response to a NOP-Out received from the initiator, the Initiator Task Tag MUST be set to 0xffffffff, and the data segment MUST NOT contain any data (DataSegmentLength MUST be 0)."
    },
    {
      "indent": 0,
      "text": "11.19.1. Target Transfer Tag",
      "section_title": true,
      "zh-cn": "11.19.1. Target Transfer Tag"
    },
    {
      "indent": 3,
      "text": "If the target is responding to a NOP-Out, this field is set to the reserved value 0xffffffff.",
      "zh-cn": "If the target is responding to a NOP-Out, this field is set to the reserved value 0xffffffff."
    },
    {
      "indent": 3,
      "text": "If the target is sending a NOP-In as a ping (intending to receive a corresponding NOP-Out), this field is set to a valid value (not the reserved value 0xffffffff).",
      "zh-cn": "If the target is sending a NOP-In as a ping (intending to receive a corresponding NOP-Out), this field is set to a valid value (not the reserved value 0xffffffff)."
    },
    {
      "indent": 3,
      "text": "If the target is initiating a NOP-In without wanting to receive a corresponding NOP-Out, this field MUST hold the reserved value 0xffffffff.",
      "zh-cn": "If the target is initiating a NOP-In without wanting to receive a corresponding NOP-Out, this field MUST hold the reserved value 0xffffffff."
    },
    {
      "indent": 0,
      "text": "11.19.2. StatSN",
      "section_title": true,
      "zh-cn": "11.19.2. StatSN"
    },
    {
      "indent": 3,
      "text": "The StatSN field will always contain the next StatSN. However, when the Initiator Task Tag is set to 0xffffffff, the StatSN for the connection is not advanced after this PDU is sent.",
      "zh-cn": "The StatSN field will always contain the next StatSN. However, when the Initiator Task Tag is set to 0xffffffff, the StatSN for the connection is not advanced after this PDU is sent."
    },
    {
      "indent": 0,
      "text": "11.19.3. LUN",
      "section_title": true,
      "zh-cn": "11.19.3. LUN"
    },
    {
      "indent": 3,
      "text": "A LUN MUST be set to a correct value when the Target Transfer Tag is valid (not the reserved value 0xffffffff).",
      "zh-cn": "A LUN MUST be set to a correct value when the Target Transfer Tag is valid (not the reserved value 0xffffffff)."
    },
    {
      "indent": 0,
      "text": "12. iSCSI Security Text Keys and Authentication Methods",
      "section_title": true,
      "zh-cn": "12. iSCSI Security Text Keys and Authentication Methods"
    },
    {
      "indent": 3,
      "text": "Only the following keys are used during the SecurityNegotiation stage of the Login Phase:",
      "zh-cn": "Only the following keys are used during the SecurityNegotiation stage of the Login Phase:"
    },
    {
      "indent": 6,
      "text": "SessionType",
      "zh-cn": "SessionType"
    },
    {
      "indent": 6,
      "text": "InitiatorName",
      "zh-cn": "InitiatorName"
    },
    {
      "indent": 6,
      "text": "TargetName",
      "zh-cn": "TargetName"
    },
    {
      "indent": 6,
      "text": "TargetAddress",
      "zh-cn": "TargetAddress"
    },
    {
      "indent": 6,
      "text": "InitiatorAlias",
      "zh-cn": "InitiatorAlias"
    },
    {
      "indent": 6,
      "text": "TargetAlias",
      "zh-cn": "TargetAlias"
    },
    {
      "indent": 6,
      "text": "TargetPortalGroupTag",
      "zh-cn": "TargetPortalGroupTag"
    },
    {
      "indent": 6,
      "text": "AuthMethod and the keys used by the authentication methods specified in Section 12.1, along with all of their associated keys, as well as Vendor-Specific Authentication Methods.",
      "zh-cn": "AuthMethod and the keys used by the authentication methods specified in Section 12.1, along with all of their associated keys, as well as Vendor-Specific Authentication Methods."
    },
    {
      "indent": 3,
      "text": "Other keys MUST NOT be used.",
      "zh-cn": "Other keys MUST NOT be used."
    },
    {
      "indent": 3,
      "text": "SessionType, InitiatorName, TargetName, InitiatorAlias, TargetAlias, and TargetPortalGroupTag are described in Section 13 as they can be used in the OperationalNegotiation stage as well.",
      "zh-cn": "SessionType, InitiatorName, TargetName, InitiatorAlias, TargetAlias, and TargetPortalGroupTag are described in Section 13 as they can be used in the OperationalNegotiation stage as well."
    },
    {
      "indent": 3,
      "text": "All security keys have connection-wide applicability.",
      "zh-cn": "All security keys have connection-wide applicability."
    },
    {
      "indent": 0,
      "text": "12.1. AuthMethod",
      "section_title": true,
      "zh-cn": "12.1. AuthMethod"
    },
    {
      "indent": 3,
      "text": "Use: During Login - Security Negotiation Senders: Initiator and target Scope: connection",
      "zh-cn": "Use: During Login - Security Negotiation Senders: Initiator and target Scope: connection"
    },
    {
      "indent": 3,
      "text": "AuthMethod = <list-of-values>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The main item of security negotiation is the authentication method (AuthMethod).",
      "zh-cn": "The main item of security negotiation is the authentication method (AuthMethod)."
    },
    {
      "indent": 3,
      "text": "The authentication methods that can be used (appear in the list-of-values) are either vendor-unique methods or those listed in the following table:",
      "zh-cn": "The authentication methods that can be used (appear in the list-of-values) are either vendor-unique methods or those listed in the following table:"
    },
    {
      "indent": 4,
      "text": "+--------------------------------------------------------------+\n| Name         | Description                                   |\n+--------------------------------------------------------------+\n| KRB5         | Kerberos V5 - defined in [RFC4120]            |\n+--------------------------------------------------------------+\n| SRP          | Secure Remote Password -                      |\n|              | defined in [RFC2945]                          |\n+--------------------------------------------------------------+\n| CHAP         | Challenge Handshake Authentication Protocol - |\n|              | defined in [RFC1994]                          |\n+--------------------------------------------------------------+\n| None         | No authentication                             |\n+--------------------------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The AuthMethod selection is followed by an \"authentication exchange\" specific to the authentication method selected.",
      "zh-cn": "The AuthMethod selection is followed by an \"authentication exchange\" specific to the authentication method selected."
    },
    {
      "indent": 3,
      "text": "The authentication method proposal may be made by either the initiator or the target. However, the initiator MUST make the first step specific to the selected authentication method as soon as it is selected. It follows that if the target makes the authentication method proposal, the initiator sends the first key(s) of the exchange together with its authentication method selection.",
      "zh-cn": "The authentication method proposal may be made by either the initiator or the target. However, the initiator MUST make the first step specific to the selected authentication method as soon as it is selected. It follows that if the target makes the authentication method proposal, the initiator sends the first key(s) of the exchange together with its authentication method selection."
    },
    {
      "indent": 3,
      "text": "The authentication exchange authenticates the initiator to the target and, optionally, the target to the initiator. Authentication is OPTIONAL to use but MUST be supported by the target and initiator.",
      "zh-cn": "The authentication exchange authenticates the initiator to the target and, optionally, the target to the initiator. Authentication is OPTIONAL to use but MUST be supported by the target and initiator."
    },
    {
      "indent": 3,
      "text": "The initiator and target MUST implement CHAP. All other authentication methods are OPTIONAL.",
      "zh-cn": "The initiator and target MUST implement CHAP. All other authentication methods are OPTIONAL."
    },
    {
      "indent": 3,
      "text": "Private or public extension algorithms MAY also be negotiated for authentication methods. Whenever a private or public extension algorithm is part of the default offer (the offer made in the absence of explicit administrative action), the implementer MUST ensure that CHAP is listed as an alternative in the default offer and \"None\" is not part of the default offer.",
      "zh-cn": "Private or public extension algorithms MAY also be negotiated for authentication methods. Whenever a private or public extension algorithm is part of the default offer (the offer made in the absence of explicit administrative action), the implementer MUST ensure that CHAP is listed as an alternative in the default offer and \"None\" is not part of the default offer."
    },
    {
      "indent": 3,
      "text": "Extension authentication methods MUST be named using one of the following two formats:",
      "zh-cn": "Extension authentication methods MUST be named using one of the following two formats:"
    },
    {
      "indent": 6,
      "text": "1) Z-reversed.vendor.dns_name.do_something=",
      "zh-cn": "1) Z-reversed.vendor.dns_name.do_something="
    },
    {
      "indent": 6,
      "text": "2) New public key with no name prefix constraints",
      "zh-cn": "2) New public key with no name prefix constraints"
    },
    {
      "indent": 3,
      "text": "Authentication methods named using the Z- format are used as private extensions. New public keys must be registered with IANA using the IETF Review process ([RFC5226]). New public extensions for authentication methods MUST NOT use the Z# name prefix.",
      "zh-cn": "Authentication methods named using the Z- format are used as private extensions. New public keys must be registered with IANA using the IETF Review process ([RFC5226]). New public extensions for authentication methods MUST NOT use the Z# name prefix."
    },
    {
      "indent": 3,
      "text": "For all of the public or private extension authentication methods, the method-specific keys MUST conform to the format specified in Section 6.1 for standard-label.",
      "zh-cn": "For all of the public or private extension authentication methods, the method-specific keys MUST conform to the format specified in Section 6.1 for standard-label."
    },
    {
      "indent": 3,
      "text": "To identify the vendor for private extension authentication methods, we suggest using the reversed DNS-name as a prefix to the proper digest names.",
      "zh-cn": "To identify the vendor for private extension authentication methods, we suggest using the reversed DNS-name as a prefix to the proper digest names."
    },
    {
      "indent": 3,
      "text": "The part of digest-name following Z- MUST conform to the format for standard-label specified in Section 6.1.",
      "zh-cn": "The part of digest-name following Z- MUST conform to the format for standard-label specified in Section 6.1."
    },
    {
      "indent": 3,
      "text": "Support for public or private extension authentication methods is OPTIONAL.",
      "zh-cn": "Support for public or private extension authentication methods is OPTIONAL."
    },
    {
      "indent": 3,
      "text": "The following subsections define the specific exchanges for each of the standardized authentication methods. As mentioned earlier, the first step is always done by the initiator.",
      "zh-cn": "The following subsections define the specific exchanges for each of the standardized authentication methods. As mentioned earlier, the first step is always done by the initiator."
    },
    {
      "indent": 0,
      "text": "12.1.1. Kerberos",
      "section_title": true,
      "zh-cn": "12.1.1. Kerberos"
    },
    {
      "indent": 3,
      "text": "For KRB5 (Kerberos V5) [RFC4120] [RFC1964], the initiator MUST use:",
      "zh-cn": "For KRB5 (Kerberos V5) [RFC4120] [RFC1964], the initiator MUST use:"
    },
    {
      "indent": 6,
      "text": "KRB_AP_REQ=<KRB_AP_REQ>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where KRB_AP_REQ is the client message as defined in [RFC4120].",
      "zh-cn": "where KRB_AP_REQ is the client message as defined in [RFC4120]."
    },
    {
      "indent": 3,
      "text": "The default principal name assumed by an iSCSI initiator or target (prior to any administrative configuration action) MUST be the iSCSI Initiator Name or iSCSI Target Name, respectively, prefixed by the string \"iscsi/\".",
      "zh-cn": "The default principal name assumed by an iSCSI initiator or target (prior to any administrative configuration action) MUST be the iSCSI Initiator Name or iSCSI Target Name, respectively, prefixed by the string \"iscsi/\"."
    },
    {
      "indent": 3,
      "text": "If the initiator authentication fails, the target MUST respond with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator has selected the mutual authentication option (by setting MUTUAL-REQUIRED in the ap-options field of the KRB_AP_REQ), the target MUST reply with:",
      "zh-cn": "If the initiator authentication fails, the target MUST respond with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator has selected the mutual authentication option (by setting MUTUAL-REQUIRED in the ap-options field of the KRB_AP_REQ), the target MUST reply with:"
    },
    {
      "indent": 6,
      "text": "KRB_AP_REP=<KRB_AP_REP>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where KRB_AP_REP is the server's response message as defined in [RFC4120].",
      "zh-cn": "where KRB_AP_REP is the server's response message as defined in [RFC4120]."
    },
    {
      "indent": 3,
      "text": "If mutual authentication was selected and target authentication fails, the initiator MUST close the connection.",
      "zh-cn": "If mutual authentication was selected and target authentication fails, the initiator MUST close the connection."
    },
    {
      "indent": 3,
      "text": "KRB_AP_REQ and KRB_AP_REP are binary-values, and their binary length (not the length of the character string that represents them in encoded form) MUST NOT exceed 65536 bytes. Hex or Base64 encoding may be used for KRB_AP_REQ and KRB_AP_REP; see Section 6.1.",
      "zh-cn": "KRB_AP_REQ and KRB_AP_REP are binary-values, and their binary length (not the length of the character string that represents them in encoded form) MUST NOT exceed 65536 bytes. Hex or Base64 encoding may be used for KRB_AP_REQ and KRB_AP_REP; see Section 6.1."
    },
    {
      "indent": 0,
      "text": "12.1.2. Secure Remote Password (SRP)",
      "section_title": true,
      "zh-cn": "12.1.2. Secure Remote Password (SRP)"
    },
    {
      "indent": 3,
      "text": "For SRP [RFC2945], the initiator MUST use:",
      "zh-cn": "For SRP [RFC2945], the initiator MUST use:"
    },
    {
      "indent": 6,
      "text": "SRP_U=<U> TargetAuth=Yes     /* or TargetAuth=No */",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The target MUST answer with a Login reject with the \"Authorization Failure\" status or reply with:",
      "zh-cn": "The target MUST answer with a Login reject with the \"Authorization Failure\" status or reply with:"
    },
    {
      "indent": 6,
      "text": "SRP_GROUP=<G1,G2...> SRP_s=<s>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where G1,G2... are proposed groups, in order of preference.",
      "zh-cn": "where G1,G2... are proposed groups, in order of preference."
    },
    {
      "indent": 3,
      "text": "The initiator MUST either close the connection or continue with:",
      "zh-cn": "The initiator MUST either close the connection or continue with:"
    },
    {
      "indent": 6,
      "text": "SRP_A=<A> SRP_GROUP=<G>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where G is one of G1,G2... that were proposed by the target.",
      "zh-cn": "where G is one of G1,G2... that were proposed by the target."
    },
    {
      "indent": 3,
      "text": "The target MUST answer with a Login reject with the \"Authentication Failure\" status or reply with:",
      "zh-cn": "The target MUST answer with a Login reject with the \"Authentication Failure\" status or reply with:"
    },
    {
      "indent": 6,
      "text": "SRP_B=<B>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The initiator MUST close the connection or continue with:",
      "zh-cn": "The initiator MUST close the connection or continue with:"
    },
    {
      "indent": 6,
      "text": "SRP_M=<M>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication fails, the target MUST answer with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator sent TargetAuth=Yes in the first message (requiring target authentication), the target MUST reply with:",
      "zh-cn": "If the initiator authentication fails, the target MUST answer with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator sent TargetAuth=Yes in the first message (requiring target authentication), the target MUST reply with:"
    },
    {
      "indent": 6,
      "text": "SRP_HM=<H(A | M | K)>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the target authentication fails, the initiator MUST close the connection:",
      "zh-cn": "If the target authentication fails, the initiator MUST close the connection:"
    },
    {
      "indent": 3,
      "text": "where U, s, A, B, M, and H(A | M | K) are defined in [RFC2945] (using the SHA1 hash function, such as SRP-SHA1)",
      "zh-cn": "where U, s, A, B, M, and H(A | M | K) are defined in [RFC2945] (using the SHA1 hash function, such as SRP-SHA1)"
    },
    {
      "indent": 3,
      "text": "and",
      "zh-cn": "and"
    },
    {
      "indent": 3,
      "text": "G,Gn (\"Gn\" stands for G1,G2...) are identifiers of SRP groups specified in [RFC3723].",
      "zh-cn": "G,Gn (\"Gn\" stands for G1,G2...) are identifiers of SRP groups specified in [RFC3723]."
    },
    {
      "indent": 3,
      "text": "G, Gn, and U are text strings; s,A,B,M, and H(A | M | K) are binary-values. The length of s,A,B,M and H(A | M | K) in binary form (not the length of the character string that represents them in encoded form) MUST NOT exceed 1024 bytes. Hex or Base64 encoding may be used for s,A,B,M and H(A | M | K); see Section 6.1.",
      "zh-cn": "G, Gn, and U are text strings; s,A,B,M, and H(A | M | K) are binary-values. The length of s,A,B,M and H(A | M | K) in binary form (not the length of the character string that represents them in encoded form) MUST NOT exceed 1024 bytes. Hex or Base64 encoding may be used for s,A,B,M and H(A | M | K); see Section 6.1."
    },
    {
      "indent": 3,
      "text": "See Appendix B for the related login example.",
      "zh-cn": "See Appendix B for the related login example."
    },
    {
      "indent": 3,
      "text": "For the SRP_GROUP, all the groups specified in [RFC3723] up to 1536 bits (i.e., SRP-768, SRP-1024, SRP-1280, SRP-1536) must be supported by initiators and targets. To guarantee interoperability, targets MUST always offer \"SRP-1536\" as one of the proposed groups.",
      "zh-cn": "For the SRP_GROUP, all the groups specified in [RFC3723] up to 1536 bits (i.e., SRP-768, SRP-1024, SRP-1280, SRP-1536) must be supported by initiators and targets. To guarantee interoperability, targets MUST always offer \"SRP-1536\" as one of the proposed groups."
    },
    {
      "indent": 0,
      "text": "12.1.3. Challenge Handshake Authentication Protocol (CHAP)",
      "section_title": true,
      "zh-cn": "12.1.3. Challenge Handshake Authentication Protocol (CHAP)"
    },
    {
      "indent": 3,
      "text": "For CHAP [RFC1994], the initiator MUST use:",
      "zh-cn": "For CHAP [RFC1994], the initiator MUST use:"
    },
    {
      "indent": 6,
      "text": "CHAP_A=<A1,A2...>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where A1,A2... are proposed algorithms, in order of preference.",
      "zh-cn": "where A1,A2... are proposed algorithms, in order of preference."
    },
    {
      "indent": 3,
      "text": "The target MUST answer with a Login reject with the \"Authentication Failure\" status or reply with:",
      "zh-cn": "The target MUST answer with a Login reject with the \"Authentication Failure\" status or reply with:"
    },
    {
      "indent": 6,
      "text": "CHAP_A=<A> CHAP_I=<I> CHAP_C=<C>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where A is one of A1,A2... that were proposed by the initiator.",
      "zh-cn": "where A is one of A1,A2... that were proposed by the initiator."
    },
    {
      "indent": 3,
      "text": "The initiator MUST continue with:",
      "zh-cn": "The initiator MUST continue with:"
    },
    {
      "indent": 6,
      "text": "CHAP_N=<N> CHAP_R=<R>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "or, if it requires target authentication, with:",
      "zh-cn": "or, if it requires target authentication, with:"
    },
    {
      "indent": 6,
      "text": "CHAP_N=<N> CHAP_R=<R> CHAP_I=<I> CHAP_C=<C>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication fails, the target MUST answer with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator required target authentication, the target MUST either answer with a Login reject with \"Authentication Failure\" or reply with:",
      "zh-cn": "If the initiator authentication fails, the target MUST answer with a Login reject with \"Authentication Failure\" status. Otherwise, if the initiator required target authentication, the target MUST either answer with a Login reject with \"Authentication Failure\" or reply with:"
    },
    {
      "indent": 6,
      "text": "CHAP_N=<N> CHAP_R=<R>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the target authentication fails, the initiator MUST close the connection:",
      "zh-cn": "If the target authentication fails, the initiator MUST close the connection:"
    },
    {
      "indent": 3,
      "text": "where N, (A,A1,A2), I, C, and R are (correspondingly) the Name, Algorithm, Identifier, Challenge, and Response as defined in [RFC1994].",
      "zh-cn": "where N, (A,A1,A2), I, C, and R are (correspondingly) the Name, Algorithm, Identifier, Challenge, and Response as defined in [RFC1994]."
    },
    {
      "indent": 3,
      "text": "N is a text string; A,A1,A2, and I are numbers; C and R are binary-values. Their binary length (not the length of the character string that represents them in encoded form) MUST NOT exceed 1024 bytes. Hex or Base64 encoding may be used for C and R; see Section 6.1.",
      "zh-cn": "N is a text string; A,A1,A2, and I are numbers; C and R are binary-values. Their binary length (not the length of the character string that represents them in encoded form) MUST NOT exceed 1024 bytes. Hex or Base64 encoding may be used for C and R; see Section 6.1."
    },
    {
      "indent": 3,
      "text": "See Appendix B for the related login example.",
      "zh-cn": "See Appendix B for the related login example."
    },
    {
      "indent": 3,
      "text": "For the Algorithm, as stated in [RFC1994], one value is required to be implemented:",
      "zh-cn": "For the Algorithm, as stated in [RFC1994], one value is required to be implemented:"
    },
    {
      "indent": 6,
      "text": "5 (CHAP with MD5)",
      "zh-cn": "5 (CHAP with MD5)"
    },
    {
      "indent": 3,
      "text": "To guarantee interoperability, initiators MUST always offer it as one of the proposed algorithms.",
      "zh-cn": "To guarantee interoperability, initiators MUST always offer it as one of the proposed algorithms."
    },
    {
      "indent": 0,
      "text": "13. Login/Text Operational Text Keys",
      "section_title": true,
      "zh-cn": "13. Login/Text Operational Text Keys"
    },
    {
      "indent": 3,
      "text": "Some session-specific parameters MUST only be carried on the leading connection and cannot be changed after the leading connection login (e.g., MaxConnections -- the maximum number of connections). This holds for a single connection session with regard to connection restart. The keys that fall into this category have the \"use: LO\" (Leading Only).",
      "zh-cn": "Some session-specific parameters MUST only be carried on the leading connection and cannot be changed after the leading connection login (e.g., MaxConnections -- the maximum number of connections). This holds for a single connection session with regard to connection restart. The keys that fall into this category have the \"use: LO\" (Leading Only)."
    },
    {
      "indent": 3,
      "text": "Keys that can only be used during login have the \"use: IO\" (Initialize Only), while those that can be used in both the Login Phase and Full Feature Phase have the \"use: ALL\".",
      "zh-cn": "Keys that can only be used during login have the \"use: IO\" (Initialize Only), while those that can be used in both the Login Phase and Full Feature Phase have the \"use: ALL\"."
    },
    {
      "indent": 3,
      "text": "Keys that can only be used during the Full Feature Phase use FFPO (Full Feature Phase Only).",
      "zh-cn": "Keys that can only be used during the Full Feature Phase use FFPO (Full Feature Phase Only)."
    },
    {
      "indent": 3,
      "text": "Keys marked as Any-Stage may also appear in the SecurityNegotiation stage, while all other keys described in this section are operational keys.",
      "zh-cn": "Keys marked as Any-Stage may also appear in the SecurityNegotiation stage, while all other keys described in this section are operational keys."
    },
    {
      "indent": 3,
      "text": "Keys that do not require an answer are marked as Declarative.",
      "zh-cn": "Keys that do not require an answer are marked as Declarative."
    },
    {
      "indent": 3,
      "text": "Key scope is indicated as session-wide (SW) or connection-only (CO).",
      "zh-cn": "Key scope is indicated as session-wide (SW) or connection-only (CO)."
    },
    {
      "indent": 3,
      "text": "\"Result function\", wherever mentioned, states the function that can be applied to check the validity of the responder selection. \"Minimum\" means that the selected value cannot exceed the offered value. \"Maximum\" means that the selected value cannot be lower than the offered value. \"AND\" means that the selected value must be a possible result of a Boolean \"and\" function with an arbitrary Boolean value (e.g., if the offered value is No the selected value must be No). \"OR\" means that the selected value must be a possible result of a Boolean \"or\" function with an arbitrary Boolean value (e.g., if the offered value is Yes the selected value must be Yes).",
      "zh-cn": "\"Result function\", wherever mentioned, states the function that can be applied to check the validity of the responder selection. \"Minimum\" means that the selected value cannot exceed the offered value. \"Maximum\" means that the selected value cannot be lower than the offered value. \"AND\" means that the selected value must be a possible result of a Boolean \"and\" function with an arbitrary Boolean value (e.g., if the offered value is No the selected value must be No). \"OR\" means that the selected value must be a possible result of a Boolean \"or\" function with an arbitrary Boolean value (e.g., if the offered value is Yes the selected value must be Yes)."
    },
    {
      "indent": 0,
      "text": "13.1. HeaderDigest and DataDigest",
      "section_title": true,
      "zh-cn": "13.1. HeaderDigest and DataDigest"
    },
    {
      "indent": 3,
      "text": "Use: IO\nSenders: Initiator and target\nScope: CO\nHeaderDigest = <list-of-values>\nDataDigest = <list-of-values>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is None for both HeaderDigest and DataDigest.",
      "zh-cn": "Default is None for both HeaderDigest and DataDigest."
    },
    {
      "indent": 3,
      "text": "Digests enable the checking of end-to-end, non-cryptographic data integrity beyond the integrity checks provided by the link layers and the covering of the whole communication path, including all elements that may change the network-level PDUs, such as routers, switches, and proxies.",
      "zh-cn": "Digests enable the checking of end-to-end, non-cryptographic data integrity beyond the integrity checks provided by the link layers and the covering of the whole communication path, including all elements that may change the network-level PDUs, such as routers, switches, and proxies."
    },
    {
      "indent": 3,
      "text": "The following table lists cyclic integrity checksums that can be negotiated for the digests and MUST be implemented by every iSCSI initiator and target. These digest options only have error detection significance.",
      "zh-cn": "The following table lists cyclic integrity checksums that can be negotiated for the digests and MUST be implemented by every iSCSI initiator and target. These digest options only have error detection significance."
    },
    {
      "indent": 5,
      "text": "+---------------------------------------------+\n| Name          | Description     | Generator |\n+---------------------------------------------+\n| CRC32C        | 32-bit CRC      |0x11edc6f41|\n+---------------------------------------------+\n| None          | no digest                   |\n+---------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The generator polynomial G(x) for this digest is given in hexadecimal notation (e.g., \"0x3b\" stands for 0011 1011, and the polynomial is x**5 + x**4 + x**3 + x + 1).",
      "zh-cn": "The generator polynomial G(x) for this digest is given in hexadecimal notation (e.g., \"0x3b\" stands for 0011 1011, and the polynomial is x**5 + x**4 + x**3 + x + 1)."
    },
    {
      "indent": 3,
      "text": "When the initiator and target agree on a digest, this digest MUST be used for every PDU in the Full Feature Phase.",
      "zh-cn": "When the initiator and target agree on a digest, this digest MUST be used for every PDU in the Full Feature Phase."
    },
    {
      "indent": 3,
      "text": "Padding bytes, when present in a segment covered by a CRC, SHOULD be set to 0 and are included in the CRC.",
      "zh-cn": "Padding bytes, when present in a segment covered by a CRC, SHOULD be set to 0 and are included in the CRC."
    },
    {
      "indent": 3,
      "text": "The CRC MUST be calculated by a method that produces the same results as the following process:",
      "zh-cn": "The CRC MUST be calculated by a method that produces the same results as the following process:"
    },
    {
      "indent": 3,
      "text": "- The PDU bits are considered as the coefficients of a polynomial M(x) of degree n - 1; bit 7 of the lowest numbered byte is considered the most significant bit (x**n - 1), followed by bit 6 of the lowest numbered byte through bit 0 of the highest numbered byte (x**0).",
      "zh-cn": "- The PDU bits are considered as the coefficients of a polynomial M(x) of degree n - 1; bit 7 of the lowest numbered byte is considered the most significant bit (x**n - 1), followed by bit 6 of the lowest numbered byte through bit 0 of the highest numbered byte (x**0)."
    },
    {
      "indent": 3,
      "text": "- The most significant 32 bits are complemented.",
      "zh-cn": "- The most significant 32 bits are complemented."
    },
    {
      "indent": 3,
      "text": "- The polynomial is multiplied by x**32, then divided by G(x). The generator polynomial produces a remainder R(x) of degree <= 31.",
      "zh-cn": "- The polynomial is multiplied by x**32, then divided by G(x). The generator polynomial produces a remainder R(x) of degree <= 31."
    },
    {
      "indent": 3,
      "text": "- The coefficients of R(x) are formed into a 32-bit sequence.",
      "zh-cn": "- The coefficients of R(x) are formed into a 32-bit sequence."
    },
    {
      "indent": 3,
      "text": "- The bit sequence is complemented, and the result is the CRC.",
      "zh-cn": "- The bit sequence is complemented, and the result is the CRC."
    },
    {
      "indent": 3,
      "text": "- The CRC bits are mapped into the digest word. The x**31 coefficient is mapped to bit 7 of the lowest numbered byte of the digest, and the mapping continues with successive coefficients and bits so that the x**24 coefficient is mapped to bit 0 of the lowest numbered byte. The mapping continues further with the x**23 coefficient mapped to bit 7 of the next byte in the digest until the x**0 coefficient is mapped to bit 0 of the highest numbered byte of the digest.",
      "zh-cn": "- The CRC bits are mapped into the digest word. The x**31 coefficient is mapped to bit 7 of the lowest numbered byte of the digest, and the mapping continues with successive coefficients and bits so that the x**24 coefficient is mapped to bit 0 of the lowest numbered byte. The mapping continues further with the x**23 coefficient mapped to bit 7 of the next byte in the digest until the x**0 coefficient is mapped to bit 0 of the highest numbered byte of the digest."
    },
    {
      "indent": 3,
      "text": "- Computing the CRC over any segment (data or header) extended to include the CRC built using the generator 0x11edc6f41 will always get the value 0x1c2d19ed as its final remainder (R(x)). This value is given here in its polynomial form (i.e., not mapped as the digest word).",
      "zh-cn": "- Computing the CRC over any segment (data or header) extended to include the CRC built using the generator 0x11edc6f41 will always get the value 0x1c2d19ed as its final remainder (R(x)). This value is given here in its polynomial form (i.e., not mapped as the digest word)."
    },
    {
      "indent": 3,
      "text": "For a discussion about selection criteria for the CRC, see [RFC3385]. For a detailed analysis of the iSCSI polynomial, see [Castagnoli93].",
      "zh-cn": "For a discussion about selection criteria for the CRC, see [RFC3385]. For a detailed analysis of the iSCSI polynomial, see [Castagnoli93]."
    },
    {
      "indent": 3,
      "text": "Private or public extension algorithms MAY also be negotiated for digests. Whenever a private or public digest extension algorithm is part of the default offer (the offer made in the absence of explicit administrative action), the implementer MUST ensure that CRC32C is listed as an alternative in the default offer and \"None\" is not part of the default offer.",
      "zh-cn": "Private or public extension algorithms MAY also be negotiated for digests. Whenever a private or public digest extension algorithm is part of the default offer (the offer made in the absence of explicit administrative action), the implementer MUST ensure that CRC32C is listed as an alternative in the default offer and \"None\" is not part of the default offer."
    },
    {
      "indent": 3,
      "text": "Extension digest algorithms MUST be named using one of the following two formats:",
      "zh-cn": "Extension digest algorithms MUST be named using one of the following two formats:"
    },
    {
      "indent": 6,
      "text": "1) Y-reversed.vendor.dns_name.do_something=",
      "zh-cn": "1) Y-reversed.vendor.dns_name.do_something="
    },
    {
      "indent": 6,
      "text": "2) New public key with no name prefix constraints",
      "zh-cn": "2) New public key with no name prefix constraints"
    },
    {
      "indent": 3,
      "text": "Digests named using the Y- format are used for private purposes (unregistered). New public keys must be registered with IANA using the IETF Review process ([RFC5226]). New public extensions for digests MUST NOT use the Y# name prefix.",
      "zh-cn": "Digests named using the Y- format are used for private purposes (unregistered). New public keys must be registered with IANA using the IETF Review process ([RFC5226]). New public extensions for digests MUST NOT use the Y# name prefix."
    },
    {
      "indent": 3,
      "text": "For private extension digests, to identify the vendor we suggest using the reversed DNS-name as a prefix to the proper digest names.",
      "zh-cn": "For private extension digests, to identify the vendor we suggest using the reversed DNS-name as a prefix to the proper digest names."
    },
    {
      "indent": 3,
      "text": "The part of digest-name following Y- MUST conform to the format for standard-label specified in Section 6.1.",
      "zh-cn": "The part of digest-name following Y- MUST conform to the format for standard-label specified in Section 6.1."
    },
    {
      "indent": 3,
      "text": "Support for public or private extension digests is OPTIONAL.",
      "zh-cn": "Support for public or private extension digests is OPTIONAL."
    },
    {
      "indent": 0,
      "text": "13.2. MaxConnections",
      "section_title": true,
      "zh-cn": "13.2. MaxConnections"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "MaxConnections=<numerical-value-from-1-to-65535>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 1. Result function is Minimum.",
      "zh-cn": "Default is 1. Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the maximum number of connections requested/acceptable.",
      "zh-cn": "The initiator and target negotiate the maximum number of connections requested/acceptable."
    },
    {
      "indent": 0,
      "text": "13.3. SendTargets",
      "section_title": true,
      "zh-cn": "13.3. SendTargets"
    },
    {
      "indent": 3,
      "text": "Use: FFPO Senders: Initiator Scope: SW",
      "zh-cn": "Use: FFPO Senders: Initiator Scope: SW"
    },
    {
      "indent": 3,
      "text": "For a complete description, see Appendix C.",
      "zh-cn": "For a complete description, see Appendix C."
    },
    {
      "indent": 0,
      "text": "13.4. TargetName",
      "section_title": true,
      "zh-cn": "13.4. TargetName"
    },
    {
      "indent": 3,
      "text": "Use: IO by initiator, FFPO by target -- only as response to a SendTargets, Declarative, Any-Stage Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: IO by initiator, FFPO by target -- only as response to a SendTargets, Declarative, Any-Stage Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "TargetName=<iSCSI-name-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678",
      "zh-cn": "TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678"
    },
    {
      "indent": 6,
      "text": "TargetName=eui.020000023B040506",
      "zh-cn": "TargetName=eui.020000023B040506"
    },
    {
      "indent": 6,
      "text": "TargetName=naa.62004567BA64678D0123456789ABCDEF",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The initiator of the TCP connection MUST provide this key to the remote endpoint in the first Login Request if the initiator is not establishing a Discovery session. The iSCSI Target Name specifies the worldwide unique name of the target.",
      "zh-cn": "The initiator of the TCP connection MUST provide this key to the remote endpoint in the first Login Request if the initiator is not establishing a Discovery session. The iSCSI Target Name specifies the worldwide unique name of the target."
    },
    {
      "indent": 3,
      "text": "The TargetName key may also be returned by the SendTargets Text Request (which is its only use when issued by a target).",
      "zh-cn": "The TargetName key may also be returned by the SendTargets Text Request (which is its only use when issued by a target)."
    },
    {
      "indent": 3,
      "text": "The TargetName MUST NOT be redeclared within the Login Phase.",
      "zh-cn": "The TargetName MUST NOT be redeclared within the Login Phase."
    },
    {
      "indent": 0,
      "text": "13.5. InitiatorName",
      "section_title": true,
      "zh-cn": "13.5. InitiatorName"
    },
    {
      "indent": 3,
      "text": "Use: IO, Declarative, Any-Stage Senders: Initiator Scope: SW",
      "zh-cn": "Use: IO, Declarative, Any-Stage Senders: Initiator Scope: SW"
    },
    {
      "indent": 3,
      "text": "InitiatorName=<iSCSI-name-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345",
      "zh-cn": "InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345"
    },
    {
      "indent": 6,
      "text": "InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90",
      "zh-cn": "InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90"
    },
    {
      "indent": 6,
      "text": "InitiatorName=naa.52004567BA64678D",
      "zh-cn": "InitiatorName=naa.52004567BA64678D"
    },
    {
      "indent": 3,
      "text": "The initiator of the TCP connection MUST provide this key to the remote endpoint at the first login of the Login Phase for every connection. The InitiatorName key enables the initiator to identify itself to the remote endpoint.",
      "zh-cn": "The initiator of the TCP connection MUST provide this key to the remote endpoint at the first login of the Login Phase for every connection. The InitiatorName key enables the initiator to identify itself to the remote endpoint."
    },
    {
      "indent": 3,
      "text": "The InitiatorName MUST NOT be redeclared within the Login Phase.",
      "zh-cn": "The InitiatorName MUST NOT be redeclared within the Login Phase."
    },
    {
      "indent": 0,
      "text": "13.6. TargetAlias",
      "section_title": true,
      "zh-cn": "13.6. TargetAlias"
    },
    {
      "indent": 3,
      "text": "Use: ALL, Declarative, Any-Stage Senders: Target Scope: SW",
      "zh-cn": "Use: ALL, Declarative, Any-Stage Senders: Target Scope: SW"
    },
    {
      "indent": 3,
      "text": "TargetAlias=<iSCSI-local-name-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "TargetAlias=Bob-s Disk",
      "zh-cn": "TargetAlias=Bob-s Disk"
    },
    {
      "indent": 6,
      "text": "TargetAlias=Database Server 1 Log Disk",
      "zh-cn": "TargetAlias=Database Server 1 Log Disk"
    },
    {
      "indent": 6,
      "text": "TargetAlias=Web Server 3 Disk 20",
      "zh-cn": "TargetAlias=Web Server 3 Disk 20"
    },
    {
      "indent": 3,
      "text": "If a target has been configured with a human-readable name or description, this name SHOULD be communicated to the initiator during a Login Response PDU if SessionType=Normal (see Section 13.21). This string is not used as an identifier, nor is it meant to be used for authentication or authorization decisions. It can be displayed by the initiator's user interface in a list of targets to which it is connected.",
      "zh-cn": "If a target has been configured with a human-readable name or description, this name SHOULD be communicated to the initiator during a Login Response PDU if SessionType=Normal (see Section 13.21). This string is not used as an identifier, nor is it meant to be used for authentication or authorization decisions. It can be displayed by the initiator's user interface in a list of targets to which it is connected."
    },
    {
      "indent": 0,
      "text": "13.7. InitiatorAlias",
      "section_title": true,
      "zh-cn": "13.7. InitiatorAlias"
    },
    {
      "indent": 3,
      "text": "Use: ALL, Declarative, Any-Stage Senders: Initiator Scope: SW",
      "zh-cn": "Use: ALL, Declarative, Any-Stage Senders: Initiator Scope: SW"
    },
    {
      "indent": 3,
      "text": "InitiatorAlias=<iSCSI-local-name-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "InitiatorAlias=Web Server 4",
      "zh-cn": "InitiatorAlias=Web Server 4"
    },
    {
      "indent": 6,
      "text": "InitiatorAlias=spyalley.nsa.gov",
      "zh-cn": "InitiatorAlias=spyalley.nsa.gov"
    },
    {
      "indent": 6,
      "text": "InitiatorAlias=Exchange Server",
      "zh-cn": "InitiatorAlias=Exchange Server"
    },
    {
      "indent": 3,
      "text": "If an initiator has been configured with a human-readable name or description, it SHOULD be communicated to the target during a Login Request PDU. If not, the host name can be used instead. This string is not used as an identifier, nor is it meant to be used for authentication or authorization decisions. It can be displayed by the target's user interface in a list of initiators to which it is connected.",
      "zh-cn": "If an initiator has been configured with a human-readable name or description, it SHOULD be communicated to the target during a Login Request PDU. If not, the host name can be used instead. This string is not used as an identifier, nor is it meant to be used for authentication or authorization decisions. It can be displayed by the target's user interface in a list of initiators to which it is connected."
    },
    {
      "indent": 0,
      "text": "13.8. TargetAddress",
      "section_title": true,
      "zh-cn": "13.8. TargetAddress"
    },
    {
      "indent": 3,
      "text": "Use: ALL, Declarative, Any-Stage Senders: Target Scope: SW",
      "zh-cn": "Use: ALL, Declarative, Any-Stage Senders: Target Scope: SW"
    },
    {
      "indent": 3,
      "text": "TargetAddress=domainname[:port][,portal-group-tag]",
      "zh-cn": "TargetAddress=domainname[:port][,portal-group-tag]"
    },
    {
      "indent": 3,
      "text": "The domainname can be specified as either a DNS host name, a dotted-decimal IPv4 address, or a bracketed IPv6 address as specified in [RFC3986].",
      "zh-cn": "The domainname can be specified as either a DNS host name, a dotted-decimal IPv4 address, or a bracketed IPv6 address as specified in [RFC3986]."
    },
    {
      "indent": 3,
      "text": "If the TCP port is not specified, it is assumed to be the IANA-assigned default port for iSCSI (see Section 14).",
      "zh-cn": "If the TCP port is not specified, it is assumed to be the IANA-assigned default port for iSCSI (see Section 14)."
    },
    {
      "indent": 3,
      "text": "If the TargetAddress is returned as the result of a redirect status in a Login Response, the comma and portal-group-tag MUST be omitted.",
      "zh-cn": "If the TargetAddress is returned as the result of a redirect status in a Login Response, the comma and portal-group-tag MUST be omitted."
    },
    {
      "indent": 3,
      "text": "If the TargetAddress is returned within a SendTargets response, the portal-group-tag MUST be included.",
      "zh-cn": "If the TargetAddress is returned within a SendTargets response, the portal-group-tag MUST be included."
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.0.0.1:5003,1",
      "zh-cn": "TargetAddress=10.0.0.1:5003,1"
    },
    {
      "indent": 6,
      "text": "TargetAddress=[1080:0:0:0:8:800:200C:417A],65",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "TargetAddress=[1080::8:800:200C:417A]:5003,1",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "TargetAddress=computingcenter.example.com,23",
      "zh-cn": "TargetAddress=computingcenter.example.com,23"
    },
    {
      "indent": 3,
      "text": "The use of the portal-group-tag is described in Appendix C. The formats for the port and portal-group-tag are the same as the one specified in TargetPortalGroupTag.",
      "zh-cn": "The use of the portal-group-tag is described in Appendix C. The formats for the port and portal-group-tag are the same as the one specified in TargetPortalGroupTag."
    },
    {
      "indent": 0,
      "text": "13.9. TargetPortalGroupTag",
      "section_title": true,
      "zh-cn": "13.9. TargetPortalGroupTag"
    },
    {
      "indent": 3,
      "text": "Use: IO by target, Declarative, Any-Stage Senders: Target Scope: SW",
      "zh-cn": "Use: IO by target, Declarative, Any-Stage Senders: Target Scope: SW"
    },
    {
      "indent": 3,
      "text": "TargetPortalGroupTag=<16-bit-binary-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Example:",
      "zh-cn": "Example:"
    },
    {
      "indent": 6,
      "text": "TargetPortalGroupTag=1",
      "zh-cn": "TargetPortalGroupTag=1"
    },
    {
      "indent": 3,
      "text": "The TargetPortalGroupTag key is a 16-bit binary-value that uniquely identifies a portal group within an iSCSI target node. This key carries the value of the tag of the portal group that is servicing the Login Request. The iSCSI target returns this key to the initiator in the Login Response PDU to the first Login Request PDU that has the C bit set to 0 when TargetName is given by the initiator.",
      "zh-cn": "The TargetPortalGroupTag key is a 16-bit binary-value that uniquely identifies a portal group within an iSCSI target node. This key carries the value of the tag of the portal group that is servicing the Login Request. The iSCSI target returns this key to the initiator in the Login Response PDU to the first Login Request PDU that has the C bit set to 0 when TargetName is given by the initiator."
    },
    {
      "indent": 3,
      "text": "[SAM2] notes in its informative text that the TPGT value should be non-zero; note that this is incorrect. A zero value is allowed as a legal value for the TPGT. This discrepancy currently stands corrected in [SAM4].",
      "zh-cn": "[SAM2] notes in its informative text that the TPGT value should be non-zero; note that this is incorrect. A zero value is allowed as a legal value for the TPGT. This discrepancy currently stands corrected in [SAM4]."
    },
    {
      "indent": 3,
      "text": "For the complete usage expectations of this key, see Section 6.3.",
      "zh-cn": "For the complete usage expectations of this key, see Section 6.3."
    },
    {
      "indent": 0,
      "text": "13.10. InitialR2T",
      "section_title": true,
      "zh-cn": "13.10. InitialR2T"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "InitialR2T=<boolean-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "I->InitialR2T=No",
      "zh-cn": "I->InitialR2T=No"
    },
    {
      "indent": 6,
      "text": "T->InitialR2T=No",
      "zh-cn": "T->InitialR2T=No"
    },
    {
      "indent": 3,
      "text": "Default is Yes. Result function is OR.",
      "zh-cn": "Default is Yes. Result function is OR."
    },
    {
      "indent": 3,
      "text": "The InitialR2T key is used to turn off the default use of R2T for unidirectional operations and the output part of bidirectional commands, thus allowing an initiator to start sending data to a target as if it has received an initial R2T with Buffer Offset=Immediate Data Length and Desired Data Transfer Length=(min(FirstBurstLength, Expected Data Transfer Length) - Received Immediate Data Length).",
      "zh-cn": "The InitialR2T key is used to turn off the default use of R2T for unidirectional operations and the output part of bidirectional commands, thus allowing an initiator to start sending data to a target as if it has received an initial R2T with Buffer Offset=Immediate Data Length and Desired Data Transfer Length=(min(FirstBurstLength, Expected Data Transfer Length) - Received Immediate Data Length)."
    },
    {
      "indent": 3,
      "text": "The default action is that R2T is required, unless both the initiator and the target send this key-pair attribute specifying InitialR2T=No. Only the first outgoing data burst (immediate data and/or separate PDUs) can be sent unsolicited (i.e., not requiring an explicit R2T).",
      "zh-cn": "The default action is that R2T is required, unless both the initiator and the target send this key-pair attribute specifying InitialR2T=No. Only the first outgoing data burst (immediate data and/or separate PDUs) can be sent unsolicited (i.e., not requiring an explicit R2T)."
    },
    {
      "indent": 0,
      "text": "13.11. ImmediateData",
      "section_title": true,
      "zh-cn": "13.11. ImmediateData"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "ImmediateData=<boolean-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is Yes. Result function is AND.",
      "zh-cn": "Default is Yes. Result function is AND."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate support for immediate data. To turn immediate data off, the initiator or target must state its desire to do so. ImmediateData can be turned on if both the initiator and target have ImmediateData=Yes.",
      "zh-cn": "The initiator and target negotiate support for immediate data. To turn immediate data off, the initiator or target must state its desire to do so. ImmediateData can be turned on if both the initiator and target have ImmediateData=Yes."
    },
    {
      "indent": 3,
      "text": "If ImmediateData is set to Yes and InitialR2T is set to Yes (default), then only immediate data are accepted in the first burst.",
      "zh-cn": "If ImmediateData is set to Yes and InitialR2T is set to Yes (default), then only immediate data are accepted in the first burst."
    },
    {
      "indent": 3,
      "text": "If ImmediateData is set to No and InitialR2T is set to Yes, then the initiator MUST NOT send unsolicited data and the target MUST reject unsolicited data with the corresponding response code.",
      "zh-cn": "If ImmediateData is set to No and InitialR2T is set to Yes, then the initiator MUST NOT send unsolicited data and the target MUST reject unsolicited data with the corresponding response code."
    },
    {
      "indent": 3,
      "text": "If ImmediateData is set to No and InitialR2T is set to No, then the initiator MUST NOT send unsolicited immediate data but MAY send one unsolicited burst of Data-OUT PDUs.",
      "zh-cn": "If ImmediateData is set to No and InitialR2T is set to No, then the initiator MUST NOT send unsolicited immediate data but MAY send one unsolicited burst of Data-OUT PDUs."
    },
    {
      "indent": 3,
      "text": "If ImmediateData is set to Yes and InitialR2T is set to No, then the initiator MAY send unsolicited immediate data and/or one unsolicited burst of Data-OUT PDUs.",
      "zh-cn": "If ImmediateData is set to Yes and InitialR2T is set to No, then the initiator MAY send unsolicited immediate data and/or one unsolicited burst of Data-OUT PDUs."
    },
    {
      "indent": 3,
      "text": "The following table is a summary of unsolicited data options:",
      "zh-cn": "The following table is a summary of unsolicited data options:"
    },
    {
      "indent": 5,
      "text": "+----------+-------------+------------------+-------------+\n|InitialR2T|ImmediateData|    Unsolicited   |ImmediateData|\n|          |             |   Data-Out PDUs  |             |\n+----------+-------------+------------------+-------------+\n| No       | No          | Yes              | No          |\n+----------+-------------+------------------+-------------+\n| No       | Yes         | Yes              | Yes         |\n+----------+-------------+------------------+-------------+\n| Yes      | No          | No               | No          |\n+----------+-------------+------------------+-------------+\n| Yes      | Yes         | No               | Yes         |\n+----------+-------------+------------------+-------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "13.12. MaxRecvDataSegmentLength",
      "section_title": true,
      "zh-cn": "13.12. MaxRecvDataSegmentLength"
    },
    {
      "indent": 3,
      "text": "Use: ALL, Declarative Senders: Initiator and target Scope: CO",
      "zh-cn": "Use: ALL, Declarative Senders: Initiator and target Scope: CO"
    },
    {
      "indent": 3,
      "text": "MaxRecvDataSegmentLength=<numerical-value-512-to-(2**24 - 1)>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 8192 bytes.",
      "zh-cn": "Default is 8192 bytes."
    },
    {
      "indent": 3,
      "text": "The initiator or target declares the maximum data segment length in bytes it can receive in an iSCSI PDU.",
      "zh-cn": "The initiator or target declares the maximum data segment length in bytes it can receive in an iSCSI PDU."
    },
    {
      "indent": 3,
      "text": "The transmitter (initiator or target) is required to send PDUs with a data segment that does not exceed MaxRecvDataSegmentLength of the receiver.",
      "zh-cn": "The transmitter (initiator or target) is required to send PDUs with a data segment that does not exceed MaxRecvDataSegmentLength of the receiver."
    },
    {
      "indent": 3,
      "text": "A target receiver is additionally limited by MaxBurstLength for solicited data and FirstBurstLength for unsolicited data. An initiator MUST NOT send solicited PDUs exceeding MaxBurstLength nor unsolicited PDUs exceeding FirstBurstLength (or FirstBurstLength-Immediate Data Length if immediate data were sent).",
      "zh-cn": "A target receiver is additionally limited by MaxBurstLength for solicited data and FirstBurstLength for unsolicited data. An initiator MUST NOT send solicited PDUs exceeding MaxBurstLength nor unsolicited PDUs exceeding FirstBurstLength (or FirstBurstLength-Immediate Data Length if immediate data were sent)."
    },
    {
      "indent": 0,
      "text": "13.13. MaxBurstLength",
      "section_title": true,
      "zh-cn": "13.13. MaxBurstLength"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "MaxBurstLength=<numerical-value-512-to-(2**24 - 1)>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 262144 (256 KB). Result function is Minimum.",
      "zh-cn": "Default is 262144 (256 KB). Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the maximum SCSI data payload in bytes in a Data-In or a solicited Data-Out iSCSI sequence. A sequence consists of one or more consecutive Data-In or Data-Out PDUs that end with a Data-In or Data-Out PDU with the F bit set to 1.",
      "zh-cn": "The initiator and target negotiate the maximum SCSI data payload in bytes in a Data-In or a solicited Data-Out iSCSI sequence. A sequence consists of one or more consecutive Data-In or Data-Out PDUs that end with a Data-In or Data-Out PDU with the F bit set to 1."
    },
    {
      "indent": 0,
      "text": "13.14. FirstBurstLength",
      "section_title": true,
      "zh-cn": "13.14. FirstBurstLength"
    },
    {
      "indent": 3,
      "text": "Use: LO\nSenders: Initiator and target\nScope: SW\nIrrelevant when: SessionType=Discovery\nIrrelevant when: ( InitialR2T=Yes and ImmediateData=No )",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "FirstBurstLength=<numerical-value-512-to-(2**24 - 1)>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 65536 (64 KB). Result function is Minimum.",
      "zh-cn": "Default is 65536 (64 KB). Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the maximum amount in bytes of unsolicited data an iSCSI initiator may send to the target during the execution of a single SCSI command. This covers the immediate data (if any) and the sequence of unsolicited Data-Out PDUs (if any) that follow the command.",
      "zh-cn": "The initiator and target negotiate the maximum amount in bytes of unsolicited data an iSCSI initiator may send to the target during the execution of a single SCSI command. This covers the immediate data (if any) and the sequence of unsolicited Data-Out PDUs (if any) that follow the command."
    },
    {
      "indent": 3,
      "text": "FirstBurstLength MUST NOT exceed MaxBurstLength.",
      "zh-cn": "FirstBurstLength MUST NOT exceed MaxBurstLength."
    },
    {
      "indent": 0,
      "text": "13.15. DefaultTime2Wait",
      "section_title": true,
      "zh-cn": "13.15. DefaultTime2Wait"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "DefaultTime2Wait=<numerical-value-0-to-3600>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 2. Result function is Maximum.",
      "zh-cn": "Default is 2. Result function is Maximum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the minimum time, in seconds, to wait before attempting an explicit/implicit logout or an active task reassignment after an unexpected connection termination or a connection reset.",
      "zh-cn": "The initiator and target negotiate the minimum time, in seconds, to wait before attempting an explicit/implicit logout or an active task reassignment after an unexpected connection termination or a connection reset."
    },
    {
      "indent": 3,
      "text": "A value of 0 indicates that logout or active task reassignment can be attempted immediately.",
      "zh-cn": "A value of 0 indicates that logout or active task reassignment can be attempted immediately."
    },
    {
      "indent": 0,
      "text": "13.16. DefaultTime2Retain",
      "section_title": true,
      "zh-cn": "13.16. DefaultTime2Retain"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "DefaultTime2Retain=<numerical-value-0-to-3600>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 20. Result function is Minimum.",
      "zh-cn": "Default is 20. Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the maximum time, in seconds, after an initial wait (Time2Wait), before which an active task reassignment is still possible after an unexpected connection termination or a connection reset.",
      "zh-cn": "The initiator and target negotiate the maximum time, in seconds, after an initial wait (Time2Wait), before which an active task reassignment is still possible after an unexpected connection termination or a connection reset."
    },
    {
      "indent": 3,
      "text": "This value is also the session state timeout if the connection in question is the last LOGGED_IN connection in the session.",
      "zh-cn": "This value is also the session state timeout if the connection in question is the last LOGGED_IN connection in the session."
    },
    {
      "indent": 3,
      "text": "A value of 0 indicates that connection/task state is immediately discarded by the target.",
      "zh-cn": "A value of 0 indicates that connection/task state is immediately discarded by the target."
    },
    {
      "indent": 0,
      "text": "13.17. MaxOutstandingR2T",
      "section_title": true,
      "zh-cn": "13.17. MaxOutstandingR2T"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "MaxOutstandingR2T=<numerical-value-from-1-to-65535>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Irrelevant when: SessionType=Discovery",
      "zh-cn": "Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "Default is 1. Result function is Minimum.",
      "zh-cn": "Default is 1. Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the maximum number of outstanding R2Ts per task, excluding any implied initial R2T that might be part of that task. An R2T is considered outstanding until the last data PDU (with the F bit set to 1) is transferred or a sequence reception timeout (Section 7.1.4.1) is encountered for that data sequence.",
      "zh-cn": "The initiator and target negotiate the maximum number of outstanding R2Ts per task, excluding any implied initial R2T that might be part of that task. An R2T is considered outstanding until the last data PDU (with the F bit set to 1) is transferred or a sequence reception timeout (Section 7.1.4.1) is encountered for that data sequence."
    },
    {
      "indent": 0,
      "text": "13.18. DataPDUInOrder",
      "section_title": true,
      "zh-cn": "13.18. DataPDUInOrder"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "DataPDUInOrder=<boolean-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is Yes. Result function is OR.",
      "zh-cn": "Default is Yes. Result function is OR."
    },
    {
      "indent": 3,
      "text": "\"No\" is used by iSCSI to indicate that the data PDUs within sequences can be in any order. \"Yes\" is used to indicate that data PDUs within sequences have to be at continuously increasing addresses and overlays are forbidden.",
      "zh-cn": "\"No\" is used by iSCSI to indicate that the data PDUs within sequences can be in any order. \"Yes\" is used to indicate that data PDUs within sequences have to be at continuously increasing addresses and overlays are forbidden."
    },
    {
      "indent": 0,
      "text": "13.19. DataSequenceInOrder",
      "section_title": true,
      "zh-cn": "13.19. DataSequenceInOrder"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW Irrelevant when: SessionType=Discovery"
    },
    {
      "indent": 3,
      "text": "DataSequenceInOrder=<boolean-value>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is Yes. Result function is OR.",
      "zh-cn": "Default is Yes. Result function is OR."
    },
    {
      "indent": 3,
      "text": "A data sequence is a sequence of Data-In or Data-Out PDUs that end with a Data-In or Data-Out PDU with the F bit set to 1. A Data-Out sequence is sent either unsolicited or in response to an R2T. Sequences cover an offset-range.",
      "zh-cn": "A data sequence is a sequence of Data-In or Data-Out PDUs that end with a Data-In or Data-Out PDU with the F bit set to 1. A Data-Out sequence is sent either unsolicited or in response to an R2T. Sequences cover an offset-range."
    },
    {
      "indent": 3,
      "text": "If DataSequenceInOrder is set to No, data PDU sequences may be transferred in any order.",
      "zh-cn": "If DataSequenceInOrder is set to No, data PDU sequences may be transferred in any order."
    },
    {
      "indent": 3,
      "text": "If DataSequenceInOrder is set to Yes, data sequences MUST be transferred using continuously non-decreasing sequence offsets (R2T buffer offset for writes, or the smallest SCSI Data-In buffer offset within a read data sequence).",
      "zh-cn": "If DataSequenceInOrder is set to Yes, data sequences MUST be transferred using continuously non-decreasing sequence offsets (R2T buffer offset for writes, or the smallest SCSI Data-In buffer offset within a read data sequence)."
    },
    {
      "indent": 3,
      "text": "If DataSequenceInOrder is set to Yes, a target may retry at most the last R2T, and an initiator may at most request retransmission for the last read data sequence. For this reason, if ErrorRecoveryLevel is not 0 and DataSequenceInOrder is set to Yes, then MaxOutstandingR2T MUST be set to 1.",
      "zh-cn": "If DataSequenceInOrder is set to Yes, a target may retry at most the last R2T, and an initiator may at most request retransmission for the last read data sequence. For this reason, if ErrorRecoveryLevel is not 0 and DataSequenceInOrder is set to Yes, then MaxOutstandingR2T MUST be set to 1."
    },
    {
      "indent": 0,
      "text": "13.20. ErrorRecoveryLevel",
      "section_title": true,
      "zh-cn": "13.20. ErrorRecoveryLevel"
    },
    {
      "indent": 3,
      "text": "Use: LO Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: LO Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "ErrorRecoveryLevel=<numerical-value-0-to-2>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is 0. Result function is Minimum.",
      "zh-cn": "Default is 0. Result function is Minimum."
    },
    {
      "indent": 3,
      "text": "The initiator and target negotiate the recovery level supported.",
      "zh-cn": "The initiator and target negotiate the recovery level supported."
    },
    {
      "indent": 3,
      "text": "Recovery levels represent a combination of recovery capabilities. Each recovery level includes all the capabilities of the lower recovery levels and adds some new ones to them.",
      "zh-cn": "Recovery levels represent a combination of recovery capabilities. Each recovery level includes all the capabilities of the lower recovery levels and adds some new ones to them."
    },
    {
      "indent": 3,
      "text": "In the description of recovery mechanisms, certain recovery classes are specified. Section 7.1.5 describes the mapping between the classes and the levels.",
      "zh-cn": "In the description of recovery mechanisms, certain recovery classes are specified. Section 7.1.5 describes the mapping between the classes and the levels."
    },
    {
      "indent": 0,
      "text": "13.21. SessionType",
      "section_title": true,
      "zh-cn": "13.21. SessionType"
    },
    {
      "indent": 3,
      "text": "Use: LO, Declarative, Any-Stage Senders: Initiator Scope: SW",
      "zh-cn": "Use: LO, Declarative, Any-Stage Senders: Initiator Scope: SW"
    },
    {
      "indent": 3,
      "text": "SessionType=<Discovery|Normal>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is Normal.",
      "zh-cn": "Default is Normal."
    },
    {
      "indent": 3,
      "text": "The initiator indicates the type of session it wants to create. The target can either accept it or reject it.",
      "zh-cn": "The initiator indicates the type of session it wants to create. The target can either accept it or reject it."
    },
    {
      "indent": 3,
      "text": "A Discovery session indicates to the target that the only purpose of this session is discovery. The only requests a target accepts in this type of session are a Text Request with a SendTargets key and a Logout Request with reason \"close the session\".",
      "zh-cn": "A Discovery session indicates to the target that the only purpose of this session is discovery. The only requests a target accepts in this type of session are a Text Request with a SendTargets key and a Logout Request with reason \"close the session\"."
    },
    {
      "indent": 3,
      "text": "The Discovery session implies MaxConnections = 1 and overrides both the default and an explicit setting. As Section 7.4.1 states, ErrorRecoveryLevel MUST be 0 (zero) for Discovery sessions.",
      "zh-cn": "The Discovery session implies MaxConnections = 1 and overrides both the default and an explicit setting. As Section 7.4.1 states, ErrorRecoveryLevel MUST be 0 (zero) for Discovery sessions."
    },
    {
      "indent": 3,
      "text": "Depending on the type of session, a target may decide on resources to allocate, the security to enforce, etc., for the session. If the SessionType key is thus going to be offered as \"Discovery\", it SHOULD be offered in the initial Login Request by the initiator.",
      "zh-cn": "Depending on the type of session, a target may decide on resources to allocate, the security to enforce, etc., for the session. If the SessionType key is thus going to be offered as \"Discovery\", it SHOULD be offered in the initial Login Request by the initiator."
    },
    {
      "indent": 0,
      "text": "13.22. The Private Extension Key Format",
      "section_title": true,
      "zh-cn": "13.22. The Private Extension Key Format"
    },
    {
      "indent": 3,
      "text": "Use: ALL Senders: Initiator and target Scope: specific key dependent",
      "zh-cn": "Use: ALL Senders: Initiator and target Scope: specific key dependent"
    },
    {
      "indent": 3,
      "text": "X-reversed.vendor.dns_name.do_something=",
      "zh-cn": "X-reversed.vendor.dns_name.do_something="
    },
    {
      "indent": 3,
      "text": "Keys with this format are used for private extension purposes. These keys always start with X- if unregistered with IANA (private). New public keys (if registered with IANA via an IETF Review [RFC5226]) no longer have an X# name prefix requirement; implementers may propose any intuitive unique name.",
      "zh-cn": "Keys with this format are used for private extension purposes. These keys always start with X- if unregistered with IANA (private). New public keys (if registered with IANA via an IETF Review [RFC5226]) no longer have an X# name prefix requirement; implementers may propose any intuitive unique name."
    },
    {
      "indent": 3,
      "text": "For unregistered keys, to identify the vendor we suggest using the reversed DNS-name as a prefix to the key-proper.",
      "zh-cn": "For unregistered keys, to identify the vendor we suggest using the reversed DNS-name as a prefix to the key-proper."
    },
    {
      "indent": 3,
      "text": "The part of key-name following X- MUST conform to the format for key-name specified in Section 6.1.",
      "zh-cn": "The part of key-name following X- MUST conform to the format for key-name specified in Section 6.1."
    },
    {
      "indent": 3,
      "text": "Vendor-specific keys MUST ONLY be used in Normal sessions.",
      "zh-cn": "Vendor-specific keys MUST ONLY be used in Normal sessions."
    },
    {
      "indent": 3,
      "text": "Support for public or private extension keys is OPTIONAL.",
      "zh-cn": "Support for public or private extension keys is OPTIONAL."
    },
    {
      "indent": 0,
      "text": "13.23. TaskReporting",
      "section_title": true,
      "zh-cn": "13.23. TaskReporting"
    },
    {
      "indent": 3,
      "text": "Use: LO\nSenders: Initiator and target\nScope: SW\nIrrelevant when: SessionType=Discovery\nTaskReporting=<list-of-values>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is RFC3720.",
      "zh-cn": "Default is RFC3720."
    },
    {
      "indent": 3,
      "text": "This key is used to negotiate the task completion reporting semantics from the SCSI target. The following table describes the semantics that an iSCSI target MUST support for respective negotiated key values. Whenever this key is negotiated, at least the RFC3720 and ResponseFence values MUST be offered as options by the negotiation originator.",
      "zh-cn": "This key is used to negotiate the task completion reporting semantics from the SCSI target. The following table describes the semantics that an iSCSI target MUST support for respective negotiated key values. Whenever this key is negotiated, at least the RFC3720 and ResponseFence values MUST be offered as options by the negotiation originator."
    },
    {
      "indent": 5,
      "text": "+--------------+------------------------------------------+\n| Name         |             Description                  |\n+--------------+------------------------------------------+\n| RFC3720      | RFC 3720-compliant semantics.  Response  |\n|              | fencing is not guaranteed, and fast      |\n|              | completion of multi-task aborting is not |\n|              | supported.                               |\n+--------------+------------------------------------------+\n| ResponseFence| Response Fence (Section 4.2.2.3.3)       |\n|              | semantics MUST be supported in reporting |\n|              | task completions.                        |\n+--------------+------------------------------------------+\n| FastAbort    | Updated fast multi-task abort semantics  |\n|              | defined in Section 4.2.3.4 MUST be       |\n|              | supported.  Support for the Response     |\n|              | Fence is implied -- i.e., semantics as   |\n|              | described in Section 4.2.2.3.3 MUST be   |\n|              | supported as well.                       |\n+--------------+------------------------------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "When TaskReporting is not negotiated to FastAbort, the standard multi-task abort semantics in Section 4.2.3.3 MUST be used.",
      "zh-cn": "When TaskReporting is not negotiated to FastAbort, the standard multi-task abort semantics in Section 4.2.3.3 MUST be used."
    },
    {
      "indent": 0,
      "text": "13.24. iSCSIProtocolLevel Negotiation",
      "section_title": true,
      "zh-cn": "13.24. iSCSIProtocolLevel Negotiation"
    },
    {
      "indent": 3,
      "text": "The iSCSIProtocolLevel associated with this document is \"1\". As a responder or an originator in a negotiation of this key, an iSCSI implementation compliant to this document alone, without any future protocol extensions, MUST use this value as defined by [RFC7144].",
      "zh-cn": "The iSCSIProtocolLevel associated with this document is \"1\". As a responder or an originator in a negotiation of this key, an iSCSI implementation compliant to this document alone, without any future protocol extensions, MUST use this value as defined by [RFC7144]."
    },
    {
      "indent": 0,
      "text": "13.25. Obsoleted Keys",
      "section_title": true,
      "zh-cn": "13.25. Obsoleted Keys"
    },
    {
      "indent": 3,
      "text": "This document obsoletes the following keys defined in [RFC3720]: IFMarker, OFMarker, OFMarkInt, and IFMarkInt. However, iSCSI implementations compliant to this document may still receive these obsoleted keys -- i.e., in a responder role -- in a text negotiation.",
      "zh-cn": "This document obsoletes the following keys defined in [RFC3720]: IFMarker, OFMarker, OFMarkInt, and IFMarkInt. However, iSCSI implementations compliant to this document may still receive these obsoleted keys -- i.e., in a responder role -- in a text negotiation."
    },
    {
      "indent": 3,
      "text": "When an IFMarker or OFMarker key is received, a compliant iSCSI implementation SHOULD respond with the constant \"Reject\" value. The implementation MAY alternatively respond with a \"No\" value.",
      "zh-cn": "When an IFMarker or OFMarker key is received, a compliant iSCSI implementation SHOULD respond with the constant \"Reject\" value. The implementation MAY alternatively respond with a \"No\" value."
    },
    {
      "indent": 3,
      "text": "However, the implementation MUST NOT respond with a \"NotUnderstood\" value for either of these keys.",
      "zh-cn": "However, the implementation MUST NOT respond with a \"NotUnderstood\" value for either of these keys."
    },
    {
      "indent": 3,
      "text": "When an IFMarkInt or OFMarkInt key is received, a compliant iSCSI implementation MUST respond with the constant \"Reject\" value. The implementation MUST NOT respond with a \"NotUnderstood\" value for either of these keys.",
      "zh-cn": "When an IFMarkInt or OFMarkInt key is received, a compliant iSCSI implementation MUST respond with the constant \"Reject\" value. The implementation MUST NOT respond with a \"NotUnderstood\" value for either of these keys."
    },
    {
      "indent": 0,
      "text": "13.26. X#NodeArchitecture",
      "section_title": true,
      "zh-cn": "13.26. X#NodeArchitecture"
    },
    {
      "indent": 0,
      "text": "13.26.1. Definition",
      "section_title": true,
      "zh-cn": "13.26.1. Definition"
    },
    {
      "indent": 3,
      "text": "Use: LO, Declarative Senders: Initiator and target Scope: SW",
      "zh-cn": "Use: LO, Declarative Senders: Initiator and target Scope: SW"
    },
    {
      "indent": 3,
      "text": "X#NodeArchitecture=<list-of-values>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Default is None.",
      "zh-cn": "Default is None."
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 6,
      "text": "X#NodeArchitecture=ExampleOS/v1234,ExampleInc_SW_Initiator/1.05a",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "X#NodeArchitecture=ExampleInc_HW_Initiator/4010,Firmware/2.0.0.5",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "X#NodeArchitecture=ExampleInc_SW_Initiator/2.1,CPU_Arch/i686",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "This document does not define the structure or content of the list of values.",
      "zh-cn": "This document does not define the structure or content of the list of values."
    },
    {
      "indent": 3,
      "text": "The initiator or target declares the details of its iSCSI node architecture to the remote endpoint. These details may include, but are not limited to, iSCSI vendor software, firmware, or hardware versions; the OS version; or hardware architecture. This key may be declared on a Discovery session or a Normal session.",
      "zh-cn": "The initiator or target declares the details of its iSCSI node architecture to the remote endpoint. These details may include, but are not limited to, iSCSI vendor software, firmware, or hardware versions; the OS version; or hardware architecture. This key may be declared on a Discovery session or a Normal session."
    },
    {
      "indent": 3,
      "text": "The length of the key value (total length of the list-of-values) MUST NOT be greater than 255 bytes.",
      "zh-cn": "The length of the key value (total length of the list-of-values) MUST NOT be greater than 255 bytes."
    },
    {
      "indent": 3,
      "text": "X#NodeArchitecture MUST NOT be redeclared during the Login Phase.",
      "zh-cn": "X#NodeArchitecture MUST NOT be redeclared during the Login Phase."
    },
    {
      "indent": 0,
      "text": "13.26.2. Implementation Requirements",
      "section_title": true,
      "zh-cn": "13.26.2. Implementation Requirements"
    },
    {
      "indent": 3,
      "text": "Functional behavior of the iSCSI node (this includes the iSCSI protocol logic -- the SCSI, iSCSI, and TCP/IP protocols) MUST NOT depend on the presence, absence, or content of the X#NodeArchitecture key. The key MUST NOT be used by iSCSI nodes for interoperability or",
      "zh-cn": "Functional behavior of the iSCSI node (this includes the iSCSI protocol logic -- the SCSI, iSCSI, and TCP/IP protocols) MUST NOT depend on the presence, absence, or content of the X#NodeArchitecture key. The key MUST NOT be used by iSCSI nodes for interoperability or"
    },
    {
      "indent": 3,
      "text": "for exclusion of other nodes. To ensure proper use, key values SHOULD be set by the node itself, and there SHOULD NOT be provisions for the key values to contain user-defined text.",
      "zh-cn": "for exclusion of other nodes. To ensure proper use, key values SHOULD be set by the node itself, and there SHOULD NOT be provisions for the key values to contain user-defined text."
    },
    {
      "indent": 3,
      "text": "Nodes implementing this key MUST choose one of the following implementation options:",
      "zh-cn": "Nodes implementing this key MUST choose one of the following implementation options:"
    },
    {
      "indent": 6,
      "text": "- only transmit the key,",
      "zh-cn": "- only transmit the key,"
    },
    {
      "indent": 6,
      "text": "- only log the key values received from other nodes, or",
      "zh-cn": "- only log the key values received from other nodes, or"
    },
    {
      "indent": 6,
      "text": "- both transmit and log the key values.",
      "zh-cn": "- both transmit and log the key values."
    },
    {
      "indent": 3,
      "text": "Each node choosing to implement transmission of the key values MUST be prepared to handle the response of iSCSI nodes that do not understand the key.",
      "zh-cn": "Each node choosing to implement transmission of the key values MUST be prepared to handle the response of iSCSI nodes that do not understand the key."
    },
    {
      "indent": 3,
      "text": "Nodes that implement transmission and/or logging of the key values may also implement administrative mechanisms that disable and/or change the logging and key transmission details (see Section 9.4). Thus, a valid behavior for this key may be that a node is completely silent (the node does not transmit any key value and simply discards any key values it receives without issuing a NotUnderstood response).",
      "zh-cn": "Nodes that implement transmission and/or logging of the key values may also implement administrative mechanisms that disable and/or change the logging and key transmission details (see Section 9.4). Thus, a valid behavior for this key may be that a node is completely silent (the node does not transmit any key value and simply discards any key values it receives without issuing a NotUnderstood response)."
    },
    {
      "indent": 0,
      "text": "14. Rationale for Revised IANA Considerations",
      "section_title": true,
      "zh-cn": "14. Rationale for Revised IANA Considerations"
    },
    {
      "indent": 3,
      "text": "This document makes rather significant changes in this area, and this section outlines the reasons behind the changes. As previously specified in [RFC3720], iSCSI had used text string prefixes, such as X- and X#, to distinguish extended login/text keys, digest algorithms, and authentication methods from their standardized counterparts. Based on experience with other protocols, [RFC6648], however, strongly recommends against this practice, in large part because extensions that use such prefixes may become standard over time, at which point it can be infeasible to change their text string names due to widespread usage under the existing text string name.",
      "zh-cn": "This document makes rather significant changes in this area, and this section outlines the reasons behind the changes. As previously specified in [RFC3720], iSCSI had used text string prefixes, such as X- and X#, to distinguish extended login/text keys, digest algorithms, and authentication methods from their standardized counterparts. Based on experience with other protocols, [RFC6648], however, strongly recommends against this practice, in large part because extensions that use such prefixes may become standard over time, at which point it can be infeasible to change their text string names due to widespread usage under the existing text string name."
    },
    {
      "indent": 3,
      "text": "iSCSI's experience with public extensions supports the recommendations in [RFC6648], as the only extension item ever registered with IANA, the X#NodeArchitecture key, was specified as a standard key in a Standards Track RFC [RFC4850] and hence did not require the X# prefix. In addition, that key is the only public iSCSI extension that has been registered with IANA since RFC 3720 was originally published, so there has been effectively no use of the X#, Y#, and Z# public extension formats.",
      "zh-cn": "iSCSI's experience with public extensions supports the recommendations in [RFC6648], as the only extension item ever registered with IANA, the X#NodeArchitecture key, was specified as a standard key in a Standards Track RFC [RFC4850] and hence did not require the X# prefix. In addition, that key is the only public iSCSI extension that has been registered with IANA since RFC 3720 was originally published, so there has been effectively no use of the X#, Y#, and Z# public extension formats."
    },
    {
      "indent": 3,
      "text": "Therefore, this document makes the following changes to the IANA registration procedures for iSCSI:",
      "zh-cn": "Therefore, this document makes the following changes to the IANA registration procedures for iSCSI:"
    },
    {
      "indent": 6,
      "text": "1) The separate registries for X#, Y#, and Z# public extensions are removed. The single entry in the registry for X# login/text keys (X#NodeArchitecture) is transferred to the main \"iSCSI Login/Text Keys\" registry. IANA has never created the latter two registries because there have been no registration requests for them. These public extension formats (X#, Y#, Z#) MUST NOT be used, with the exception of the existing X#NodeArchitecture key.",
      "zh-cn": "1) The separate registries for X#, Y#, and Z# public extensions are removed. The single entry in the registry for X# login/text keys (X#NodeArchitecture) is transferred to the main \"iSCSI Login/Text Keys\" registry. IANA has never created the latter two registries because there have been no registration requests for them. These public extension formats (X#, Y#, Z#) MUST NOT be used, with the exception of the existing X#NodeArchitecture key."
    },
    {
      "indent": 6,
      "text": "2) The registration procedures for the main \"iSCSI Login/Text Keys\", \"iSCSI digests\", and \"iSCSI authentication methods\" IANA registries are changed to IETF Review [RFC5226] for possible future extensions to iSCSI. This change includes a deliberate decision to remove the possibility of specifying an IANA-registered iSCSI extension in an RFC published via an RFC Editor Independent Submission, as the level of review in that process is insufficient for iSCSI extensions.",
      "zh-cn": "2) The registration procedures for the main \"iSCSI Login/Text Keys\", \"iSCSI digests\", and \"iSCSI authentication methods\" IANA registries are changed to IETF Review [RFC5226] for possible future extensions to iSCSI. This change includes a deliberate decision to remove the possibility of specifying an IANA-registered iSCSI extension in an RFC published via an RFC Editor Independent Submission, as the level of review in that process is insufficient for iSCSI extensions."
    },
    {
      "indent": 6,
      "text": "3) The restriction against registering items using the private extension formats (X-, Y-, Z-) in the main IANA registries is removed. Extensions using these formats MAY be registered under the IETF Review registration procedures, but each format is restricted to the type of extension for which it is specified in this RFC and MUST NOT be used for other types. For example, the X- extension format for extension login/text keys MUST NOT be used for digest algorithms or authentication methods.",
      "zh-cn": "3) The restriction against registering items using the private extension formats (X-, Y-, Z-) in the main IANA registries is removed. Extensions using these formats MAY be registered under the IETF Review registration procedures, but each format is restricted to the type of extension for which it is specified in this RFC and MUST NOT be used for other types. For example, the X- extension format for extension login/text keys MUST NOT be used for digest algorithms or authentication methods."
    },
    {
      "indent": 0,
      "text": "15. IANA Considerations",
      "section_title": true,
      "zh-cn": "15. IANA Considerations"
    },
    {
      "indent": 3,
      "text": "The well-known TCP port number for iSCSI connections assigned by IANA is 3260, and this is the default iSCSI port. Implementations needing a system TCP port number may use port 860, the port assigned by IANA as the iSCSI system port; however, in order to use port 860, it MUST be explicitly specified -- implementations MUST NOT default to the use of port 860, as 3260 is the only allowed default.",
      "zh-cn": "The well-known TCP port number for iSCSI connections assigned by IANA is 3260, and this is the default iSCSI port. Implementations needing a system TCP port number may use port 860, the port assigned by IANA as the iSCSI system port; however, in order to use port 860, it MUST be explicitly specified -- implementations MUST NOT default to the use of port 860, as 3260 is the only allowed default."
    },
    {
      "indent": 3,
      "text": "IANA has replaced the references for ports 860 and 3260, both TCP and UDP, with references to this document. Please see http://www.iana.org/assignments/service-names-port-numbers.",
      "zh-cn": "IANA has replaced the references for ports 860 and 3260, both TCP and UDP, with references to this document. Please see http://www.iana.org/assignments/service-names-port-numbers."
    },
    {
      "indent": 3,
      "text": "IANA has updated all references to RFC 3720, RFC 4850, and RFC 5048 to instead reference this RFC in all of the iSCSI registries that are part of the \"Internet Small Computer System Interface (iSCSI) Parameters\" set of registries. This change reflects the fact that",
      "zh-cn": "IANA has updated all references to RFC 3720, RFC 4850, and RFC 5048 to instead reference this RFC in all of the iSCSI registries that are part of the \"Internet Small Computer System Interface (iSCSI) Parameters\" set of registries. This change reflects the fact that"
    },
    {
      "indent": 3,
      "text": "those three RFCs are obsoleted by this RFC. References to other RFCs that are not being obsoleted (e.g., RFC 3723, RFC 5046) should not be changed.",
      "zh-cn": "those three RFCs are obsoleted by this RFC. References to other RFCs that are not being obsoleted (e.g., RFC 3723, RFC 5046) should not be changed."
    },
    {
      "indent": 3,
      "text": "IANA has performed the following actions on the \"iSCSI Login/Text Keys\" registry:",
      "zh-cn": "IANA has performed the following actions on the \"iSCSI Login/Text Keys\" registry:"
    },
    {
      "indent": 6,
      "text": "- Changed the registration procedure to IETF Review from Standard Required.",
      "zh-cn": "- Changed the registration procedure to IETF Review from Standard Required."
    },
    {
      "indent": 6,
      "text": "- Changed the RFC 5048 reference for the registry to reference this RFC.",
      "zh-cn": "- Changed the RFC 5048 reference for the registry to reference this RFC."
    },
    {
      "indent": 6,
      "text": "- Added the X#NodeArchitecture key from the \"iSCSI extended key\" registry, and changed its reference to this RFC.",
      "zh-cn": "- Added the X#NodeArchitecture key from the \"iSCSI extended key\" registry, and changed its reference to this RFC."
    },
    {
      "indent": 6,
      "text": "- Changed all references to RFC 3720 and RFC 5048 to instead reference this RFC.",
      "zh-cn": "- Changed all references to RFC 3720 and RFC 5048 to instead reference this RFC."
    },
    {
      "indent": 3,
      "text": "IANA has changed the registration procedures for the \"iSCSI authentication methods\" and \"iSCSI digests\" registries to IETF Review from RFC Required.",
      "zh-cn": "IANA has changed the registration procedures for the \"iSCSI authentication methods\" and \"iSCSI digests\" registries to IETF Review from RFC Required."
    },
    {
      "indent": 3,
      "text": "IANA has removed the \"iSCSI extended key\" registry, as its one entry has been added to the \"iSCSI Login/Text Keys\" registry.",
      "zh-cn": "IANA has removed the \"iSCSI extended key\" registry, as its one entry has been added to the \"iSCSI Login/Text Keys\" registry."
    },
    {
      "indent": 3,
      "text": "IANA has marked as obsolete the values 4 and 5 for SPKM1 and SPKM2, respectively, in the \"iSCSI authentication methods\" subregistry of the \"Internet Small Computer System Interface (iSCSI) Parameters\" set of registries.",
      "zh-cn": "IANA has marked as obsolete the values 4 and 5 for SPKM1 and SPKM2, respectively, in the \"iSCSI authentication methods\" subregistry of the \"Internet Small Computer System Interface (iSCSI) Parameters\" set of registries."
    },
    {
      "indent": 3,
      "text": "IANA has added this document to the \"iSCSI Protocol Level\" registry with value 1, as mentioned in Section 13.24.",
      "zh-cn": "IANA has added this document to the \"iSCSI Protocol Level\" registry with value 1, as mentioned in Section 13.24."
    },
    {
      "indent": 3,
      "text": "All the other IANA considerations stated in [RFC3720] and [RFC5048] remain unchanged. The assignments contained in the following subregistries are not repeated in this document:",
      "zh-cn": "All the other IANA considerations stated in [RFC3720] and [RFC5048] remain unchanged. The assignments contained in the following subregistries are not repeated in this document:"
    },
    {
      "indent": 6,
      "text": "- iSCSI authentication methods (from Section 13 of [RFC3720])",
      "zh-cn": "- iSCSI authentication methods (from Section 13 of [RFC3720])"
    },
    {
      "indent": 6,
      "text": "- iSCSI digests (from Section 13 of [RFC3720])",
      "zh-cn": "- iSCSI digests (from Section 13 of [RFC3720])"
    },
    {
      "indent": 3,
      "text": "This document obsoletes the SPKM1 and SPKM2 key values for the AuthMethod text key. Consequently, the SPKM_ text key prefix MUST be treated as obsolete and not be reused.",
      "zh-cn": "This document obsoletes the SPKM1 and SPKM2 key values for the AuthMethod text key. Consequently, the SPKM_ text key prefix MUST be treated as obsolete and not be reused."
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "zh-cn": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "zh-cn": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[EUI] \"Guidelines for 64-bit Global Identifier (EUI-64(TM))\", <http://standards.ieee.org/regauth/oui/tutorials/ EUI64.html>.",
      "zh-cn": "[EUI] \"Guidelines for 64-bit Global Identifier (EUI-64(TM))\", <http://standards.ieee.org/regauth/oui/tutorials/ EUI64.html>."
    },
    {
      "indent": 3,
      "text": "[FC-FS3] INCITS Technical Committee T11, \"Fibre Channel - Framing and Signaling - 3 (FC-FS-3)\", ANSI INCITS 470-2011, 2011.",
      "zh-cn": "[FC-FS3] INCITS Technical Committee T11, \"Fibre Channel - Framing and Signaling - 3 (FC-FS-3)\", ANSI INCITS 470-2011, 2011."
    },
    {
      "indent": 3,
      "text": "[OUI] \"IEEE OUI and \"company_id\" Assignments\", <http://standards.ieee.org/regauth/oui>.",
      "zh-cn": "[OUI] \"IEEE OUI and \"company_id\" Assignments\", <http://standards.ieee.org/regauth/oui>."
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "zh-cn": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989."
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "zh-cn": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996."
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996.",
      "zh-cn": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996."
    },
    {
      "indent": 3,
      "text": "[RFC1994] Simpson, W., \"PPP Challenge Handshake Authentication Protocol (CHAP)\", RFC 1994, August 1996.",
      "zh-cn": "[RFC1994] Simpson, W., \"PPP Challenge Handshake Authentication Protocol (CHAP)\", RFC 1994, August 1996."
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-cn": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997."
    },
    {
      "indent": 3,
      "text": "[RFC2404] Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within ESP and AH\", RFC 2404, November 1998.",
      "zh-cn": "[RFC2404] Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within ESP and AH\", RFC 2404, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2406] Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998.",
      "zh-cn": "[RFC2406] Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2451] Pereira, R. and R. Adams, \"The ESP CBC-Mode Cipher Algorithms\", RFC 2451, November 1998.",
      "zh-cn": "[RFC2451] Pereira, R. and R. Adams, \"The ESP CBC-Mode Cipher Algorithms\", RFC 2451, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2945] Wu, T., \"The SRP Authentication and Key Exchange System\", RFC 2945, September 2000.",
      "zh-cn": "[RFC2945] Wu, T., \"The SRP Authentication and Key Exchange System\", RFC 2945, September 2000."
    },
    {
      "indent": 3,
      "text": "[RFC3454] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002.",
      "zh-cn": "[RFC3454] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002."
    },
    {
      "indent": 3,
      "text": "[RFC3566] Frankel, S. and H. Herbert, \"The AES-XCBC-MAC-96 Algorithm and Its Use With IPsec\", RFC 3566, September 2003.",
      "zh-cn": "[RFC3566] Frankel, S. and H. Herbert, \"The AES-XCBC-MAC-96 Algorithm and Its Use With IPsec\", RFC 3566, September 2003."
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "zh-cn": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003."
    },
    {
      "indent": 3,
      "text": "[RFC3686] Housley, R., \"Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)\", RFC 3686, January 2004.",
      "zh-cn": "[RFC3686] Housley, R., \"Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)\", RFC 3686, January 2004."
    },
    {
      "indent": 3,
      "text": "[RFC3722] Bakke, M., \"String Profile for Internet Small Computer Systems Interface (iSCSI) Names\", RFC 3722, April 2004.",
      "zh-cn": "[RFC3722] Bakke, M., \"String Profile for Internet Small Computer Systems Interface (iSCSI) Names\", RFC 3722, April 2004."
    },
    {
      "indent": 3,
      "text": "[RFC3723] Aboba, B., Tseng, J., Walker, J., Rangan, V., and F. Travostino, \"Securing Block Storage Protocols over IP\", RFC 3723, April 2004.",
      "zh-cn": "[RFC3723] Aboba, B., Tseng, J., Walker, J., Rangan, V., and F. Travostino, \"Securing Block Storage Protocols over IP\", RFC 3723, April 2004."
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "zh-cn": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4106] Viega, J. and D. McGrew, \"The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)\", RFC 4106, June 2005.",
      "zh-cn": "[RFC4106] Viega, J. and D. McGrew, \"The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)\", RFC 4106, June 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "zh-cn": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4171] Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and J. Souza, \"Internet Storage Name Service (iSNS)\", RFC 4171, September 2005.",
      "zh-cn": "[RFC4171] Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and J. Souza, \"Internet Storage Name Service (iSNS)\", RFC 4171, September 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "zh-cn": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006."
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "zh-cn": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "zh-cn": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4304] Kent, S., \"Extended Sequence Number (ESN) Addendum to IPsec Domain of Interpretation (DOI) for Internet Security Association and Key Management Protocol (ISAKMP)\", RFC 4304, December 2005.",
      "zh-cn": "[RFC4304] Kent, S., \"Extended Sequence Number (ESN) Addendum to IPsec Domain of Interpretation (DOI) for Internet Security Association and Key Management Protocol (ISAKMP)\", RFC 4304, December 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4543] McGrew, D. and J. Viega, \"The Use of Galois Message Authentication Code (GMAC) in IPsec ESP and AH\", RFC 4543, May 2006.",
      "zh-cn": "[RFC4543] McGrew, D. and J. Viega, \"The Use of Galois Message Authentication Code (GMAC) in IPsec ESP and AH\", RFC 4543, May 2006."
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "zh-cn": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006."
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "zh-cn": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008."
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "zh-cn": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010."
    },
    {
      "indent": 3,
      "text": "[RFC6960] Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 6960, June 2013.",
      "zh-cn": "[RFC6960] Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 6960, June 2013."
    },
    {
      "indent": 3,
      "text": "[RFC7144] Knight, F. and M. Chadalapaka, \"Internet Small Computer System Interface (iSCSI) SCSI Features Update\", RFC 7144, April 2014.",
      "zh-cn": "[RFC7144] Knight, F. and M. Chadalapaka, \"Internet Small Computer System Interface (iSCSI) SCSI Features Update\", RFC 7144, April 2014."
    },
    {
      "indent": 3,
      "text": "[RFC7145] Ko, M. and A. Nezhinsky, \"Internet Small Computer System Interface (iSCSI) Extensions for the Remote Direct Memory Access (RDMA) Specification\", RFC 7145, April 2014.",
      "zh-cn": "[RFC7145] Ko, M. and A. Nezhinsky, \"Internet Small Computer System Interface (iSCSI) Extensions for the Remote Direct Memory Access (RDMA) Specification\", RFC 7145, April 2014."
    },
    {
      "indent": 3,
      "text": "[RFC7146] Black, D. and P. Koning, \"Securing Block Storage Protocols over IP: RFC 3723 Requirements Update for IPsec v3\", RFC 7146, April 2014.",
      "zh-cn": "[RFC7146] Black, D. and P. Koning, \"Securing Block Storage Protocols over IP: RFC 3723 Requirements Update for IPsec v3\", RFC 7146, April 2014."
    },
    {
      "indent": 3,
      "text": "[SAM2] INCITS Technical Committee T10, \"SCSI Architecture Model - 2 (SAM-2)\", ANSI INCITS 366-2003, ISO/IEC 14776-412, 2003.",
      "zh-cn": "[SAM2] INCITS Technical Committee T10, \"SCSI Architecture Model - 2 (SAM-2)\", ANSI INCITS 366-2003, ISO/IEC 14776-412, 2003."
    },
    {
      "indent": 3,
      "text": "[SAM4] INCITS Technical Committee T10, \"SCSI Architecture Model - 4 (SAM-4)\", ANSI INCITS 447-2008, ISO/IEC 14776-414, 2008.",
      "zh-cn": "[SAM4] INCITS Technical Committee T10, \"SCSI Architecture Model - 4 (SAM-4)\", ANSI INCITS 447-2008, ISO/IEC 14776-414, 2008."
    },
    {
      "indent": 3,
      "text": "[SPC2] INCITS Technical Committee T10, \"SCSI Primary Commands - 2\", ANSI INCITS 351-2001, ISO/IEC 14776-452, 2001.",
      "zh-cn": "[SPC2] INCITS Technical Committee T10, \"SCSI Primary Commands - 2\", ANSI INCITS 351-2001, ISO/IEC 14776-452, 2001."
    },
    {
      "indent": 3,
      "text": "[SPC3] INCITS Technical Committee T10, \"SCSI Primary Commands - 3\", ANSI INCITS 408-2005, ISO/IEC 14776-453, 2005.",
      "zh-cn": "[SPC3] INCITS Technical Committee T10, \"SCSI Primary Commands - 3\", ANSI INCITS 408-2005, ISO/IEC 14776-453, 2005."
    },
    {
      "indent": 3,
      "text": "[UML] ISO, \"Unified Modeling Language (UML) Version 1.4.2\", ISO/IEC 19501:2005.",
      "zh-cn": "[UML] ISO, \"Unified Modeling Language (UML) Version 1.4.2\", ISO/IEC 19501:2005."
    },
    {
      "indent": 3,
      "text": "[UNICODE] The Unicode Consortium, \"Unicode Standard Annex #15: Unicode Normalization Forms\", 2013, <http://www.unicode.org/unicode/reports/tr15>.",
      "zh-cn": "[UNICODE] The Unicode Consortium, \"Unicode Standard Annex #15: Unicode Normalization Forms\", 2013, <http://www.unicode.org/unicode/reports/tr15>."
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "zh-cn": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Castagnoli93] Castagnoli, G., Brauer, S., and M. Herrmann, \"Optimization of Cyclic Redundancy-Check Codes with 24 and 32 Parity Bits\", IEEE Transact. on Communications, Vol. 41, No. 6, June 1993.",
      "zh-cn": "[Castagnoli93] Castagnoli, G., Brauer, S., and M. Herrmann, \"Optimization of Cyclic Redundancy-Check Codes with 24 and 32 Parity Bits\", IEEE Transact. on Communications, Vol. 41, No. 6, June 1993."
    },
    {
      "indent": 3,
      "text": "[FC-SP-2] INCITS Technical Committee T11, \"Fibre Channel Security Protocols 2\", ANSI INCITS 496-2012, 2012.",
      "zh-cn": "[FC-SP-2] INCITS Technical Committee T11, \"Fibre Channel Security Protocols 2\", ANSI INCITS 496-2012, 2012."
    },
    {
      "indent": 3,
      "text": "[IB] InfiniBand, \"InfiniBand(TM) Architecture Specification\", Vol. 1, Rel. 1.2.1, InfiniBand Trade Association, <http://www.infinibandta.org>.",
      "zh-cn": "[IB] InfiniBand, \"InfiniBand(TM) Architecture Specification\", Vol. 1, Rel. 1.2.1, InfiniBand Trade Association, <http://www.infinibandta.org>."
    },
    {
      "indent": 3,
      "text": "[RFC1737] Sollins, K. and L. Masinter, \"Functional Requirements for Uniform Resource Names\", RFC 1737, December 1994.",
      "zh-cn": "[RFC1737] Sollins, K. and L. Masinter, \"Functional Requirements for Uniform Resource Names\", RFC 1737, December 1994."
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "zh-cn": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2407] Piper, D., \"The Internet IP Security Domain of Interpretation for ISAKMP\", RFC 2407, November 1998.",
      "zh-cn": "[RFC2407] Piper, D., \"The Internet IP Security Domain of Interpretation for ISAKMP\", RFC 2407, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "zh-cn": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998."
    },
    {
      "indent": 3,
      "text": "[RFC2608] Guttman, E., Perkins, C., Veizades, J., and M. Day, \"Service Location Protocol, Version 2\", RFC 2608, June 1999.",
      "zh-cn": "[RFC2608] Guttman, E., Perkins, C., Veizades, J., and M. Day, \"Service Location Protocol, Version 2\", RFC 2608, June 1999."
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update \", RFC 2743, January 2000.",
      "zh-cn": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update \", RFC 2743, January 2000."
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000.",
      "zh-cn": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000."
    },
    {
      "indent": 3,
      "text": "[RFC3385] Sheinwald, D., Satran, J., Thaler, P., and V. Cavanna, \"Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations\", RFC 3385, September 2002.",
      "zh-cn": "[RFC3385] Sheinwald, D., Satran, J., Thaler, P., and V. Cavanna, \"Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations\", RFC 3385, September 2002."
    },
    {
      "indent": 3,
      "text": "[RFC3602] Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher Algorithm and Its Use with IPsec\", RFC 3602, September 2003.",
      "zh-cn": "[RFC3602] Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher Algorithm and Its Use with IPsec\", RFC 3602, September 2003."
    },
    {
      "indent": 3,
      "text": "[RFC3720] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and E. Zeidner, \"Internet Small Computer Systems Interface (iSCSI)\", RFC 3720, April 2004.",
      "zh-cn": "[RFC3720] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and E. Zeidner, \"Internet Small Computer Systems Interface (iSCSI)\", RFC 3720, April 2004."
    },
    {
      "indent": 3,
      "text": "[RFC3721] Bakke, M., Hafner, J., Hufferd, J., Voruganti, K., and M. Krueger, \"Internet Small Computer Systems Interface (iSCSI) Naming and Discovery\", RFC 3721, April 2004.",
      "zh-cn": "[RFC3721] Bakke, M., Hafner, J., Hufferd, J., Voruganti, K., and M. Krueger, \"Internet Small Computer Systems Interface (iSCSI) Naming and Discovery\", RFC 3721, April 2004."
    },
    {
      "indent": 3,
      "text": "[RFC3783] Chadalapaka, M. and R. Elliott, \"Small Computer Systems Interface (SCSI) Command Ordering Considerations with iSCSI\", RFC 3783, May 2004.",
      "zh-cn": "[RFC3783] Chadalapaka, M. and R. Elliott, \"Small Computer Systems Interface (SCSI) Command Ordering Considerations with iSCSI\", RFC 3783, May 2004."
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005.",
      "zh-cn": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4297] Romanow, A., Mogul, J., Talpey, T., and S. Bailey, \"Remote Direct Memory Access (RDMA) over IP Problem Statement\", RFC 4297, December 2005.",
      "zh-cn": "[RFC4297] Romanow, A., Mogul, J., Talpey, T., and S. Bailey, \"Remote Direct Memory Access (RDMA) over IP Problem Statement\", RFC 4297, December 2005."
    },
    {
      "indent": 3,
      "text": "[RFC4806] Myers, M. and H. Tschofenig, \"Online Certificate Status Protocol (OCSP) Extensions to IKEv2\", RFC 4806, February 2007.",
      "zh-cn": "[RFC4806] Myers, M. and H. Tschofenig, \"Online Certificate Status Protocol (OCSP) Extensions to IKEv2\", RFC 4806, February 2007."
    },
    {
      "indent": 3,
      "text": "[RFC4850] Wysochanski, D., \"Declarative Public Extension Key for Internet Small Computer Systems Interface (iSCSI) Node Architecture\", RFC 4850, April 2007.",
      "zh-cn": "[RFC4850] Wysochanski, D., \"Declarative Public Extension Key for Internet Small Computer Systems Interface (iSCSI) Node Architecture\", RFC 4850, April 2007."
    },
    {
      "indent": 3,
      "text": "[RFC5046] Ko, M., Chadalapaka, M., Hufferd, J., Elzur, U., Shah, H., and P. Thaler, \"Internet Small Computer System Interface (iSCSI) Extensions for Remote Direct Memory Access (RDMA)\", RFC 5046, October 2007.",
      "zh-cn": "[RFC5046] Ko, M., Chadalapaka, M., Hufferd, J., Elzur, U., Shah, H., and P. Thaler, \"Internet Small Computer System Interface (iSCSI) Extensions for Remote Direct Memory Access (RDMA)\", RFC 5046, October 2007."
    },
    {
      "indent": 3,
      "text": "[RFC5048] Chadalapaka, M., Ed., \"Internet Small Computer System Interface (iSCSI) Corrections and Clarifications\", RFC 5048, October 2007.",
      "zh-cn": "[RFC5048] Chadalapaka, M., Ed., \"Internet Small Computer System Interface (iSCSI) Corrections and Clarifications\", RFC 5048, October 2007."
    },
    {
      "indent": 3,
      "text": "[RFC5433] Clancy, T. and H. Tschofenig, \"Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) Method\", RFC 5433, February 2009.",
      "zh-cn": "[RFC5433] Clancy, T. and H. Tschofenig, \"Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) Method\", RFC 5433, February 2009."
    },
    {
      "indent": 3,
      "text": "[RFC6648] Saint-Andre, P., Crocker, D., and M. Nottingham, \"Deprecating the \"X-\" Prefix and Similar Constructs in Application Protocols\", BCP 178, RFC 6648, June 2012.",
      "zh-cn": "[RFC6648] Saint-Andre, P., Crocker, D., and M. Nottingham, \"Deprecating the \"X-\" Prefix and Similar Constructs in Application Protocols\", BCP 178, RFC 6648, June 2012."
    },
    {
      "indent": 3,
      "text": "[SAS] INCITS Technical Committee T10, \"Serial Attached SCSI - 2.1 (SAS-2.1)\", ANSI INCITS 457-2010, 2010.",
      "zh-cn": "[SAS] INCITS Technical Committee T10, \"Serial Attached SCSI - 2.1 (SAS-2.1)\", ANSI INCITS 457-2010, 2010."
    },
    {
      "indent": 3,
      "text": "[SBC2] INCITS Technical Committee T10, \"SCSI Block Commands - 2 (SBC-2)\", ANSI INCITS 405-2005, ISO/IEC 14776-322, 2005.",
      "zh-cn": "[SBC2] INCITS Technical Committee T10, \"SCSI Block Commands - 2 (SBC-2)\", ANSI INCITS 405-2005, ISO/IEC 14776-322, 2005."
    },
    {
      "indent": 3,
      "text": "[SPC4] INCITS Technical Committee T10, \"SCSI Primary Commands - 4\", ANSI INCITS 513-201x.",
      "zh-cn": "[SPC4] INCITS Technical Committee T10, \"SCSI Primary Commands - 4\", ANSI INCITS 513-201x."
    },
    {
      "indent": 3,
      "text": "[SPL] INCITS Technical Committee T10, \"SAS Protocol Layer - 2 (SPL-2)\", ANSI INCITS 505-2013, ISO/IEC 14776-262, 2013.",
      "zh-cn": "[SPL] INCITS Technical Committee T10, \"SAS Protocol Layer - 2 (SPL-2)\", ANSI INCITS 505-2013, ISO/IEC 14776-262, 2013."
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "section_title": true,
      "zh-cn": "Appendix A. Examples"
    },
    {
      "indent": 0,
      "text": "A.1. Read Operation Example",
      "section_title": true,
      "zh-cn": "A.1. Read Operation Example"
    },
    {
      "indent": 3,
      "text": "+------------------+-----------------------+---------------------+\n|Initiator Function|       PDU Type        |   Target Function   |\n+------------------+-----------------------+---------------------+\n| Command request  |SCSI Command (read)>>> |                     |\n| (read)           |                       |                     |\n+------------------+-----------------------+---------------------+\n|                  |                       |Prepare Data Transfer|\n+------------------+-----------------------+---------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n+------------------+-----------------------+---------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n+------------------+-----------------------+---------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n+------------------+-----------------------+---------------------+\n|                  |   <<< SCSI Response   |Send Status and Sense|\n+------------------+-----------------------+---------------------+\n| Command Complete |                       |                     |\n+------------------+-----------------------+---------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "A.2. Write Operation Example",
      "section_title": true,
      "zh-cn": "A.2. Write Operation Example"
    },
    {
      "indent": 3,
      "text": "+------------------+-----------------------+---------------------+\n|Initiator Function|       PDU Type        |   Target Function   |\n+------------------+-----------------------+---------------------+\n| Command request  |SCSI Command (write)>>>| Receive command     |\n| (write)          |                       | and queue it        |\n+------------------+-----------------------+---------------------+\n|                  |                       | Process old commands|\n+------------------+-----------------------+---------------------+\n|                  |                       | Ready to process    |\n|                  |   <<< R2T             | write command       |\n+------------------+-----------------------+---------------------+\n|   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n+------------------+-----------------------+---------------------+\n|                  |   <<< R2T             | Ready for data      |\n+------------------+-----------------------+---------------------+\n|                  |   <<< R2T             | Ready for data      |\n+------------------+-----------------------+---------------------+\n|   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n+------------------+-----------------------+---------------------+\n|   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n+------------------+-----------------------+---------------------+\n|                  |   <<< SCSI Response   |Send Status and Sense|\n+------------------+-----------------------+---------------------+\n| Command Complete |                       |                     |\n+------------------+-----------------------+---------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "A.3. R2TSN/DataSN Use Examples",
      "section_title": true,
      "zh-cn": "A.3. R2TSN/DataSN Use Examples"
    },
    {
      "indent": 0,
      "text": "A.3.1. Output (Write) Data DataSN/R2TSN Example",
      "section_title": true,
      "zh-cn": "A.3.1. Output (Write) Data DataSN/R2TSN Example"
    },
    {
      "indent": 3,
      "text": "+-------------------+------------------------+---------------------+\n|Initiator Function |  PDU Type and Content  |   Target Function   |\n+-------------------+------------------------+---------------------+\n| Command request   |SCSI Command (write)>>> | Receive command     |\n| (write)           |                        | and queue it        |\n+-------------------+------------------------+---------------------+\n|                   |                        | Process old commands|\n+-------------------+------------------------+---------------------+\n|                   |   <<< R2T              | Ready for data      |\n|                   |   R2TSN = 0            |                     |\n+-------------------+------------------------+---------------------+\n|                   |   <<< R2T              | Ready for more data |\n|                   |   R2TSN = 1            |                     |\n+-------------------+------------------------+---------------------+\n| Send Data         |   SCSI Data-Out >>>    |   Receive Data      |\n| for R2TSN 0       |   DataSN = 0, F = 0    |                     |\n+-------------------+------------------------+---------------------+\n| Send Data         |   SCSI Data-Out >>>    |   Receive Data      |\n| for R2TSN 0       |   DataSN = 1, F = 1    |                     |\n+-------------------+------------------------+---------------------+\n| Send Data         |   SCSI Data >>>        |   Receive Data      |\n| for R2TSN 1       |   DataSN = 0, F = 1    |                     |\n+-------------------+------------------------+---------------------+\n|                   |   <<< SCSI Response    |Send Status and Sense|\n|                   |   ExpDataSN = 0        |                     |\n+-------------------+------------------------+---------------------+\n| Command Complete  |                        |                     |\n+-------------------+------------------------+---------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "A.3.2. Input (Read) Data DataSN Example",
      "section_title": true,
      "zh-cn": "A.3.2. Input (Read) Data DataSN Example"
    },
    {
      "indent": 3,
      "text": "+------------------+-----------------------+----------------------+\n|Initiator Function|        PDU Type       |    Target Function   |\n+------------------+-----------------------+----------------------+\n| Command request  |SCSI Command (read)>>> |                      |\n| (read)           |                       |                      |\n+------------------+-----------------------+----------------------+\n|                  |                       |Prepare Data Transfer |\n+------------------+-----------------------+----------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n|                  |   DataSN = 0, F = 0   |                      |\n+------------------+-----------------------+----------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n|                  |   DataSN = 1, F = 0   |                      |\n+------------------+-----------------------+----------------------+\n|   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n|                  |   DataSN = 2, F = 1   |                      |\n+------------------+-----------------------+----------------------+\n|                  |   <<< SCSI Response   |Send Status and Sense |\n|                  |   ExpDataSN = 3       |                      |\n+------------------+-----------------------+----------------------+\n| Command Complete |                       |                      |\n+------------------+-----------------------+----------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "A.3.3. Bidirectional DataSN Example",
      "section_title": true,
      "zh-cn": "A.3.3. Bidirectional DataSN Example"
    },
    {
      "indent": 3,
      "text": "+------------------+-----------------------+---------------------+\n|Initiator Function|       PDU Type        |   Target Function   |\n+------------------+-----------------------+---------------------+\n| Command request  |SCSI Command >>>       |                     |\n| (Read-Write)     | Read-Write            |                     |\n+------------------+-----------------------+---------------------+\n|                  |                       | Process old commands|\n+------------------+-----------------------+---------------------+\n|                  |   <<< R2T             | Ready to process    |\n|                  |   R2TSN = 0           | write command       |\n+------------------+-----------------------+---------------------+\n| * Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n|                  |   DataSN = 0, F = 0   |                     |\n+------------------+-----------------------+---------------------+\n| * Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n|                  |   DataSN = 1, F = 1   |                     |\n+------------------+-----------------------+---------------------+\n| * Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n| for R2TSN 0      |   DataSN = 0, F = 1   |                     |\n+------------------+-----------------------+---------------------+\n|                  |   <<< SCSI Response   |Send Status and Sense|\n|                  |   ExpDataSN = 2       |                     |\n+------------------+-----------------------+---------------------+\n| Command Complete |                       |                     |\n+------------------+-----------------------+---------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "* Send Data and Receive Data may be transferred simultaneously as in an atomic Read-Old-Write-New or sequentially as in an atomic Read-Update-Write (in the latter case, the R2T may follow the received data).",
      "zh-cn": "* Send Data and Receive Data may be transferred simultaneously as in an atomic Read-Old-Write-New or sequentially as in an atomic Read-Update-Write (in the latter case, the R2T may follow the received data)."
    },
    {
      "indent": 0,
      "text": "A.3.4. Unsolicited and Immediate Output (Write) Data with DataSN Example",
      "zh-cn": "A.3.4. Unsolicited and Immediate Output (Write) Data with DataSN Example"
    },
    {
      "indent": 3,
      "text": "+------------------+------------------------+----------------------+\n|Initiator Function|  PDU Type and Content  |   Target Function    |\n+------------------+------------------------+----------------------+\n| Command request  |SCSI Command (write)>>> | Receive command      |\n| (write)          |F = 0                   | and data             |\n|+ immediate data  |                        | and queue it         |\n+------------------+------------------------+----------------------+\n| Send Unsolicited |    SCSI Write Data >>> | Receive more Data    |\n| Data             |    DataSN = 0, F = 1   |                      |\n+------------------+------------------------+----------------------+\n|                  |                        | Process old commands |\n+------------------+------------------------+----------------------+\n|                  |    <<< R2T             | Ready for more data  |\n|                  |    R2TSN = 0           |                      |\n+------------------+------------------------+----------------------+\n| Send Data        |    SCSI Write Data >>> |   Receive Data       |\n| for R2TSN 0      |    DataSN = 0, F = 1   |                      |\n+------------------+------------------------+----------------------+\n|                  |    <<< SCSI Response   |Send Status and Sense |\n|                  |                        |                      |\n+------------------+------------------------+----------------------+\n| Command Complete |                        |                      |\n+------------------+------------------------+----------------------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "A.4. CRC Examples",
      "section_title": true,
      "zh-cn": "A.4. CRC Examples"
    },
    {
      "indent": 3,
      "text": "Note: All values are hexadecimal.",
      "zh-cn": "Note: All values are hexadecimal."
    },
    {
      "indent": 3,
      "text": "32 bytes of zeroes:",
      "zh-cn": "32 bytes of zeroes:"
    },
    {
      "indent": 6,
      "text": "Byte: 0 1 2 3",
      "zh-cn": "Byte: 0 1 2 3"
    },
    {
      "indent": 7,
      "text": " 0: 00 00 00 00 ... 28: 00 00 00 00",
      "zh-cn": " 0: 00 00 00 00 ... 28: 00 00 00 00"
    },
    {
      "indent": 7,
      "text": "CRC: aa 36 91 8a",
      "zh-cn": "CRC: aa 36 91 8a"
    },
    {
      "indent": 3,
      "text": "32 bytes of ones:",
      "zh-cn": "32 bytes of ones:"
    },
    {
      "indent": 6,
      "text": "Byte: 0 1 2 3",
      "zh-cn": "Byte: 0 1 2 3"
    },
    {
      "indent": 7,
      "text": " 0: ff ff ff ff ... 28: ff ff ff ff",
      "zh-cn": " 0: ff ff ff ff ... 28: ff ff ff ff"
    },
    {
      "indent": 7,
      "text": "CRC: 43 ab a8 62",
      "zh-cn": "CRC: 43 ab a8 62"
    },
    {
      "indent": 3,
      "text": "32 bytes of incrementing 00..1f:",
      "zh-cn": "32 bytes of incrementing 00..1f:"
    },
    {
      "indent": 6,
      "text": "Byte: 0 1 2 3",
      "zh-cn": "Byte: 0 1 2 3"
    },
    {
      "indent": 7,
      "text": " 0: 00 01 02 03 ... 28: 1c 1d 1e 1f",
      "zh-cn": " 0: 00 01 02 03 ... 28: 1c 1d 1e 1f"
    },
    {
      "indent": 7,
      "text": "CRC: 4e 79 dd 46",
      "zh-cn": "CRC: 4e 79 dd 46"
    },
    {
      "indent": 3,
      "text": "32 bytes of decrementing 1f..00:",
      "zh-cn": "32 bytes of decrementing 1f..00:"
    },
    {
      "indent": 6,
      "text": "Byte: 0 1 2 3",
      "zh-cn": "Byte: 0 1 2 3"
    },
    {
      "indent": 7,
      "text": " 0: 1f 1e 1d 1c ... 28: 03 02 01 00",
      "zh-cn": " 0: 1f 1e 1d 1c ... 28: 03 02 01 00"
    },
    {
      "indent": 7,
      "text": "CRC: 5c db 3f 11",
      "zh-cn": "CRC: 5c db 3f 11"
    },
    {
      "indent": 3,
      "text": "An iSCSI - SCSI Read (10) Command PDU:",
      "zh-cn": "An iSCSI - SCSI Read (10) Command PDU:"
    },
    {
      "indent": 5,
      "text": "Byte: 0 1 2 3",
      "zh-cn": "Byte: 0 1 2 3"
    },
    {
      "indent": 7,
      "text": " 0: 01 c0 00 00 4: 00 00 00 00 8: 00 00 00 00 12: 00 00 00 00 16: 14 00 00 00 20: 00 00 04 00 24: 00 00 00 14 28: 00 00 00 18 32: 28 00 00 00 36: 00 00 00 00 40: 02 00 00 00 44: 00 00 00 00",
      "zh-cn": " 0: 01 c0 00 00 4: 00 00 00 00 8: 00 00 00 00 12: 00 00 00 00 16: 14 00 00 00 20: 00 00 04 00 24: 00 00 00 14 28: 00 00 00 18 32: 28 00 00 00 36: 00 00 00 00 40: 02 00 00 00 44: 00 00 00 00"
    },
    {
      "indent": 6,
      "text": "CRC: 56 3a 96 d9",
      "zh-cn": "CRC: 56 3a 96 d9"
    },
    {
      "indent": 0,
      "text": "Appendix B. Login Phase Examples",
      "section_title": true,
      "zh-cn": "Appendix B. Login Phase Examples"
    },
    {
      "indent": 3,
      "text": "In the first example, the initiator and target authenticate each other via Kerberos:",
      "zh-cn": "In the first example, the initiator and target authenticate each other via Kerberos:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,SRP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    AuthMethod=KRB5",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    KRB_AP_REQ=<krb_ap_req>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(krb_ap_req contains the Kerberos V5 ticket and authenticator with MUTUAL-REQUIRED set in the ap-options field)",
      "zh-cn": "(krb_ap_req contains the Kerberos V5 ticket and authenticator with MUTUAL-REQUIRED set in the ap-options field)"
    },
    {
      "indent": 3,
      "text": "If the authentication is successful, the target proceeds with:",
      "zh-cn": "If the authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)\n    KRB_AP_REP=<krb_ap_rep>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(krb_ap_rep is the Kerberos V5 mutual authentication reply)",
      "zh-cn": "(krb_ap_rep is the Kerberos V5 mutual authentication reply)"
    },
    {
      "indent": 3,
      "text": "If the authentication is successful, the initiator may proceed with:",
      "zh-cn": "If the authentication is successful, the initiator may proceed with:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=8192",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=4096\n    MaxBurstLength=8192",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) MaxBurstLength=8192\n    ... more iSCSI Operational Parameters",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... more iSCSI Operational Parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... more iSCSI Operational Parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator's authentication by the target is not successful, the target responds with:",
      "zh-cn": "If the initiator's authentication by the target is not successful, the target responds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login \"login reject\"",
      "zh-cn": "T-> Login \"login reject\""
    },
    {
      "indent": 3,
      "text": "instead of the Login KRB_AP_REP message, and it terminates the connection.",
      "zh-cn": "instead of the Login KRB_AP_REP message, and it terminates the connection."
    },
    {
      "indent": 3,
      "text": "If the target's authentication by the initiator is not successful, the initiator terminates the connection (without responding to the Login KRB_AP_REP message).",
      "zh-cn": "If the target's authentication by the initiator is not successful, the initiator terminates the connection (without responding to the Login KRB_AP_REP message)."
    },
    {
      "indent": 3,
      "text": "In the next example, only the initiator is authenticated by the target via Kerberos:",
      "zh-cn": "In the next example, only the initiator is authenticated by the target via Kerberos:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=SRP,KRB5,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,0 T=0)\n    AuthMethod=KRB5",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    KRB_AP_REQ=krb_ap_req",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "(MUTUAL-REQUIRED not set in the ap-options field of krb_ap_req)",
      "zh-cn": "(MUTUAL-REQUIRED not set in the ap-options field of krb_ap_req)"
    },
    {
      "indent": 3,
      "text": "If the authentication is successful, the target proceeds with:",
      "zh-cn": "If the authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": ". . .",
      "zh-cn": ". . ."
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1)\"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "In the next example, the initiator and target authenticate each other via SRP:",
      "zh-cn": "In the next example, the initiator and target authenticate each other via SRP:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,SRP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,0 T=0)\n    AuthMethod=SRP",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    SRP_U=<user>\n    TargetAuth=Yes",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    SRP_N=<N>\n    SRP_g=<g>\n    SRP_s=<s>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    SRP_A=<A>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    SRP_B=<B>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    SRP_M=<M>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is successful, the target proceeds with:",
      "zh-cn": "If the initiator authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)\n    SRP_HM=<H(A | M | K)>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "where N, g, s, A, B, M, and H(A | M | K) are defined in [RFC2945].",
      "zh-cn": "where N, g, s, A, B, M, and H(A | M | K) are defined in [RFC2945]."
    },
    {
      "indent": 3,
      "text": "If the target authentication is not successful, the initiator terminates the connection; otherwise, it proceeds.",
      "zh-cn": "If the target authentication is not successful, the initiator terminates the connection; otherwise, it proceeds."
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is not successful, the target responds with:",
      "zh-cn": "If the initiator authentication is not successful, the target responds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login \"login reject\"",
      "zh-cn": "T-> Login \"login reject\""
    },
    {
      "indent": 3,
      "text": "instead of the T-> Login SRP_HM=<H(A | M | K)> message, and it terminates the connection.",
      "zh-cn": "instead of the T-> Login SRP_HM=<H(A | M | K)> message, and it terminates the connection."
    },
    {
      "indent": 3,
      "text": "In the next example, only the initiator is authenticated by the target via SRP:",
      "zh-cn": "In the next example, only the initiator is authenticated by the target via SRP:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,SRP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,0 T=0)\n    AuthMethod=SRP",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    SRP_U=<user>\n    TargetAuth=No",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    SRP_N=<N>\n    SRP_g=<g>\n    SRP_s=<s>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    SRP_A=<A>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    SRP_B=<B>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n     SRP_M=<M>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is successful, the target proceeds with:",
      "zh-cn": "If the initiator authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "In the next example, the initiator and target authenticate each other via CHAP:",
      "zh-cn": "In the next example, the initiator and target authenticate each other via CHAP:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,CHAP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,0 T=0)\n    AuthMethod=CHAP",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    CHAP_A=<A1,A2>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    CHAP_A=<A1>\n    CHAP_I=<I>\n    CHAP_C=<C>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    CHAP_N=<N>\n    CHAP_R=<R>\n    CHAP_I=<I>\n    CHAP_C=<C>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is successful, the target proceeds with:",
      "zh-cn": "If the initiator authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)\n    CHAP_N=<N>\n    CHAP_R=<R>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the target authentication is not successful, the initiator aborts the connection; otherwise, it proceeds.",
      "zh-cn": "If the target authentication is not successful, the initiator aborts the connection; otherwise, it proceeds."
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is not successful, the target responds with:",
      "zh-cn": "If the initiator authentication is not successful, the target responds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login \"login reject\"",
      "zh-cn": "T-> Login \"login reject\""
    },
    {
      "indent": 3,
      "text": "instead of the Login CHAP_R=<response> \"proceed and change stage\" message, and it terminates the connection.",
      "zh-cn": "instead of the Login CHAP_R=<response> \"proceed and change stage\" message, and it terminates the connection."
    },
    {
      "indent": 3,
      "text": "In the next example, only the initiator is authenticated by the target via CHAP:",
      "zh-cn": "In the next example, only the initiator is authenticated by the target via CHAP:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=0)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,CHAP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,0 T=0)\n    AuthMethod=CHAP",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,0 T=0)\n    CHAP_A=<A1,A2>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,0 T=0)\n    CHAP_A=<A1>\n    CHAP_I=<I>\n    CHAP_C=<C>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    CHAP_N=<N>\n    CHAP_R=<R>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "If the initiator authentication is successful, the target proceeds with:",
      "zh-cn": "If the initiator authentication is successful, the target proceeds with:"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=0,1 T=1)",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "In the next example, the initiator does not offer any security parameters. It therefore may offer iSCSI parameters on the Login PDU with the T bit set to 1, and the target may respond with a final Login Response PDU immediately:",
      "zh-cn": "In the next example, the initiator does not offer any security parameters. It therefore may offer iSCSI parameters on the Login PDU with the T bit set to 1, and the target may respond with a final Login Response PDU immediately:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    ... iSCSI parameters",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\" ... ISCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\" ... ISCSI parameters"
    },
    {
      "indent": 3,
      "text": "In the next example, the initiator does offer security parameters on the Login PDU, but the target does not choose any (i.e., chooses the \"None\" values):",
      "zh-cn": "In the next example, the initiator does offer security parameters on the Login PDU, but the target does not choose any (i.e., chooses the \"None\" values):"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=0,1 T=1)\n    InitiatorName=iqn.1999-07.com.os:hostid.77\n    TargetName=iqn.1999-07.com.example:diskarray.sn.88\n    AuthMethod=KRB5,SRP,None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "T-> Login-PR (CSG,NSG=0,1 T=1)\n    AuthMethod=None",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters",
      "zh-cn": "T-> Login (CSG,NSG=1,0 T=0) ... iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "And at the end:",
      "zh-cn": "And at the end:"
    },
    {
      "indent": 6,
      "text": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters",
      "zh-cn": "I-> Login (CSG,NSG=1,3 T=1) optional iSCSI parameters"
    },
    {
      "indent": 6,
      "text": "T-> Login (CSG,NSG=1,3 T=1) \"login accept\"",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. SendTargets Operation",
      "section_title": true,
      "zh-cn": "Appendix C. SendTargets Operation"
    },
    {
      "indent": 3,
      "text": "The text in this appendix is a normative part of this document.",
      "zh-cn": "The text in this appendix is a normative part of this document."
    },
    {
      "indent": 3,
      "text": "To reduce the amount of configuration required on an initiator, iSCSI provides the SendTargets Text Request. The initiator uses the SendTargets request to get a list of targets to which it may have access, as well as the list of addresses (IP address and TCP port) on which these targets may be accessed.",
      "zh-cn": "To reduce the amount of configuration required on an initiator, iSCSI provides the SendTargets Text Request. The initiator uses the SendTargets request to get a list of targets to which it may have access, as well as the list of addresses (IP address and TCP port) on which these targets may be accessed."
    },
    {
      "indent": 3,
      "text": "To make use of SendTargets, an initiator must first establish one of two types of sessions. If the initiator establishes the session using the key \"SessionType=Discovery\", the session is a Discovery session, and a target name does not need to be specified. Otherwise, the session is a Normal operational session. The SendTargets command MUST only be sent during the Full Feature Phase of a Normal or Discovery session.",
      "zh-cn": "To make use of SendTargets, an initiator must first establish one of two types of sessions. If the initiator establishes the session using the key \"SessionType=Discovery\", the session is a Discovery session, and a target name does not need to be specified. Otherwise, the session is a Normal operational session. The SendTargets command MUST only be sent during the Full Feature Phase of a Normal or Discovery session."
    },
    {
      "indent": 3,
      "text": "A system that contains targets MUST support Discovery sessions on each of its iSCSI IP address-port pairs and MUST support the SendTargets command on the Discovery session. In a Discovery session, a target MUST return all path information (IP address-port pairs and Target Portal Group Tags) for the targets on the target Network Entity that the requesting initiator is authorized to access.",
      "zh-cn": "A system that contains targets MUST support Discovery sessions on each of its iSCSI IP address-port pairs and MUST support the SendTargets command on the Discovery session. In a Discovery session, a target MUST return all path information (IP address-port pairs and Target Portal Group Tags) for the targets on the target Network Entity that the requesting initiator is authorized to access."
    },
    {
      "indent": 3,
      "text": "A target MUST support the SendTargets command on operational sessions; these will only return path information about the target to which the session is connected and do not need to return information about other target names that may be defined in the responding system.",
      "zh-cn": "A target MUST support the SendTargets command on operational sessions; these will only return path information about the target to which the session is connected and do not need to return information about other target names that may be defined in the responding system."
    },
    {
      "indent": 3,
      "text": "An initiator MAY make use of the SendTargets command as it sees fit.",
      "zh-cn": "An initiator MAY make use of the SendTargets command as it sees fit."
    },
    {
      "indent": 3,
      "text": "A SendTargets command consists of a single Text Request PDU. This PDU contains exactly one text key and value. The text key MUST be SendTargets. The expected response depends upon the value, as well as whether the session is a Discovery session or an operational session.",
      "zh-cn": "A SendTargets command consists of a single Text Request PDU. This PDU contains exactly one text key and value. The text key MUST be SendTargets. The expected response depends upon the value, as well as whether the session is a Discovery session or an operational session."
    },
    {
      "indent": 3,
      "text": "The value must be one of:",
      "zh-cn": "The value must be one of:"
    },
    {
      "indent": 6,
      "text": "All",
      "zh-cn": "All"
    },
    {
      "indent": 9,
      "text": "The initiator is requesting that information on all relevant targets known to the implementation be returned. This value MUST be supported on a Discovery session and MUST NOT be supported on an operational session.",
      "zh-cn": "The initiator is requesting that information on all relevant targets known to the implementation be returned. This value MUST be supported on a Discovery session and MUST NOT be supported on an operational session."
    },
    {
      "indent": 6,
      "text": "<iSCSI-target-name>",
      "zh-cn": "<iSCSI-target-name>"
    },
    {
      "indent": 9,
      "text": "If an iSCSI Target Name is specified, the session should respond with addresses for only the named target, if possible. This value MUST be supported on Discovery sessions. A Discovery session MUST be capable of returning addresses for those targets that would have been returned had value=All been designated.",
      "zh-cn": "If an iSCSI Target Name is specified, the session should respond with addresses for only the named target, if possible. This value MUST be supported on Discovery sessions. A Discovery session MUST be capable of returning addresses for those targets that would have been returned had value=All been designated."
    },
    {
      "indent": 6,
      "text": "<nothing>",
      "zh-cn": "<nothing>"
    },
    {
      "indent": 9,
      "text": "The session should only respond with addresses for the target to which the session is logged in. This MUST be supported on operational sessions and MUST NOT return targets other than the one to which the session is logged in.",
      "zh-cn": "The session should only respond with addresses for the target to which the session is logged in. This MUST be supported on operational sessions and MUST NOT return targets other than the one to which the session is logged in."
    },
    {
      "indent": 3,
      "text": "The response to this command is a Text Response that contains a list of zero or more targets and, optionally, their addresses. Each target is returned as a target record. A target record begins with the TargetName text key, followed by a list of TargetAddress text keys, and bounded by the end of the Text Response or the next TargetName key, which begins a new record. No text keys other than TargetName and TargetAddress are permitted within a SendTargets response.",
      "zh-cn": "The response to this command is a Text Response that contains a list of zero or more targets and, optionally, their addresses. Each target is returned as a target record. A target record begins with the TargetName text key, followed by a list of TargetAddress text keys, and bounded by the end of the Text Response or the next TargetName key, which begins a new record. No text keys other than TargetName and TargetAddress are permitted within a SendTargets response."
    },
    {
      "indent": 3,
      "text": "For the format of the TargetName, see Section 13.4.",
      "zh-cn": "For the format of the TargetName, see Section 13.4."
    },
    {
      "indent": 3,
      "text": "A Discovery session MAY respond to a SendTargets request with its complete list of targets, or with a list of targets that is based on the name of the initiator logged in to the session.",
      "zh-cn": "A Discovery session MAY respond to a SendTargets request with its complete list of targets, or with a list of targets that is based on the name of the initiator logged in to the session."
    },
    {
      "indent": 3,
      "text": "A SendTargets response MUST NOT contain target names if there are no targets for the requesting initiator to access.",
      "zh-cn": "A SendTargets response MUST NOT contain target names if there are no targets for the requesting initiator to access."
    },
    {
      "indent": 3,
      "text": "Each target record returned includes zero or more TargetAddress fields.",
      "zh-cn": "Each target record returned includes zero or more TargetAddress fields."
    },
    {
      "indent": 3,
      "text": "Each target record starts with one text key of the form:",
      "zh-cn": "Each target record starts with one text key of the form:"
    },
    {
      "indent": 6,
      "text": "TargetName=<target-name-goes-here>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "followed by zero or more address keys of the form:",
      "zh-cn": "followed by zero or more address keys of the form:"
    },
    {
      "indent": 3,
      "text": "TargetAddress=<hostname-or-ipaddress>[:<tcp-port>],\n   <portal-group-tag>",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "The hostname-or-ipaddress contains a domain name, IPv4 address, or IPv6 address ([RFC4291]), as specified for the TargetAddress key.",
      "zh-cn": "The hostname-or-ipaddress contains a domain name, IPv4 address, or IPv6 address ([RFC4291]), as specified for the TargetAddress key."
    },
    {
      "indent": 3,
      "text": "A hostname-or-ipaddress duplicated in TargetAddress responses for a given node (the port is absent or equal) would probably indicate that multiple address families are in use at once (IPv6 and IPv4).",
      "zh-cn": "A hostname-or-ipaddress duplicated in TargetAddress responses for a given node (the port is absent or equal) would probably indicate that multiple address families are in use at once (IPv6 and IPv4)."
    },
    {
      "indent": 3,
      "text": "Each TargetAddress belongs to a portal group, identified by its numeric Target Portal Group Tag (see Section 13.9). The iSCSI Target Name, together with this tag, constitutes the SCSI port identifier; the tag only needs to be unique within a given target's name list of addresses.",
      "zh-cn": "Each TargetAddress belongs to a portal group, identified by its numeric Target Portal Group Tag (see Section 13.9). The iSCSI Target Name, together with this tag, constitutes the SCSI port identifier; the tag only needs to be unique within a given target's name list of addresses."
    },
    {
      "indent": 3,
      "text": "Multiple-connection sessions can span iSCSI addresses that belong to the same portal group.",
      "zh-cn": "Multiple-connection sessions can span iSCSI addresses that belong to the same portal group."
    },
    {
      "indent": 3,
      "text": "Multiple-connection sessions cannot span iSCSI addresses that belong to different portal groups.",
      "zh-cn": "Multiple-connection sessions cannot span iSCSI addresses that belong to different portal groups."
    },
    {
      "indent": 3,
      "text": "If a SendTargets response reports an iSCSI address for a target, it SHOULD also report all other addresses in its portal group in the same response.",
      "zh-cn": "If a SendTargets response reports an iSCSI address for a target, it SHOULD also report all other addresses in its portal group in the same response."
    },
    {
      "indent": 3,
      "text": "A SendTargets Text Response can be longer than a single Text Response PDU and makes use of the long Text Responses as specified.",
      "zh-cn": "A SendTargets Text Response can be longer than a single Text Response PDU and makes use of the long Text Responses as specified."
    },
    {
      "indent": 3,
      "text": "After obtaining a list of targets from the Discovery session, an iSCSI initiator may initiate new sessions to log in to the discovered targets for full operation. The initiator MAY keep the Discovery session open and MAY send subsequent SendTargets commands to discover new targets.",
      "zh-cn": "After obtaining a list of targets from the Discovery session, an iSCSI initiator may initiate new sessions to log in to the discovered targets for full operation. The initiator MAY keep the Discovery session open and MAY send subsequent SendTargets commands to discover new targets."
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-cn": "Examples:"
    },
    {
      "indent": 3,
      "text": "This example is the SendTargets response from a single target that has no other interface ports.",
      "zh-cn": "This example is the SendTargets response from a single target that has no other interface ports."
    },
    {
      "indent": 3,
      "text": "The initiator sends a Text Request that contains:",
      "zh-cn": "The initiator sends a Text Request that contains:"
    },
    {
      "indent": 6,
      "text": "SendTargets=All",
      "zh-cn": "SendTargets=All"
    },
    {
      "indent": 3,
      "text": "The target sends a Text Response that contains:",
      "zh-cn": "The target sends a Text Response that contains:"
    },
    {
      "indent": 6,
      "text": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309",
      "zh-cn": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309"
    },
    {
      "indent": 3,
      "text": "All the target had to return in this simple case was the target name. It is assumed by the initiator that the IP address and TCP port for this target are the same as those used on the current connection to the default iSCSI target.",
      "zh-cn": "All the target had to return in this simple case was the target name. It is assumed by the initiator that the IP address and TCP port for this target are the same as those used on the current connection to the default iSCSI target."
    },
    {
      "indent": 3,
      "text": "The next example has two internal iSCSI targets, each accessible via two different ports with different IP addresses. The following is the Text Response:",
      "zh-cn": "The next example has two internal iSCSI targets, each accessible via two different ports with different IP addresses. The following is the Text Response:"
    },
    {
      "indent": 6,
      "text": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309",
      "zh-cn": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.0.45:3000,1",
      "zh-cn": "TargetAddress=10.1.0.45:3000,1"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.1.45:3000,2",
      "zh-cn": "TargetAddress=10.1.1.45:3000,2"
    },
    {
      "indent": 6,
      "text": "TargetName=iqn.1993-11.com.example:diskarray.sn.1234567",
      "zh-cn": "TargetName=iqn.1993-11.com.example:diskarray.sn.1234567"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.0.45:3000,1",
      "zh-cn": "TargetAddress=10.1.0.45:3000,1"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.1.45:3000,2",
      "zh-cn": "TargetAddress=10.1.1.45:3000,2"
    },
    {
      "indent": 3,
      "text": "Both targets share both addresses; the multiple addresses are likely used to provide multi-path support. The initiator may connect to either target name on either address. Each of the addresses has its own Target Portal Group Tag; they do not support spanning multiple-connection sessions with each other. Keep in mind that the Target Portal Group Tags for the two named targets are independent of one another; portal group \"1\" on the first target is not necessarily the same as portal group \"1\" on the second target.",
      "zh-cn": "Both targets share both addresses; the multiple addresses are likely used to provide multi-path support. The initiator may connect to either target name on either address. Each of the addresses has its own Target Portal Group Tag; they do not support spanning multiple-connection sessions with each other. Keep in mind that the Target Portal Group Tags for the two named targets are independent of one another; portal group \"1\" on the first target is not necessarily the same as portal group \"1\" on the second target."
    },
    {
      "indent": 3,
      "text": "In the above example, a DNS host name or an IPv6 address could have been returned instead of an IPv4 address.",
      "zh-cn": "In the above example, a DNS host name or an IPv6 address could have been returned instead of an IPv4 address."
    },
    {
      "indent": 3,
      "text": "The next Text Response shows a target that supports spanning sessions across multiple addresses and further illustrates the use of the Target Portal Group Tags:",
      "zh-cn": "The next Text Response shows a target that supports spanning sessions across multiple addresses and further illustrates the use of the Target Portal Group Tags:"
    },
    {
      "indent": 6,
      "text": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309",
      "zh-cn": "TargetName=iqn.1993-11.com.example:diskarray.sn.8675309"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.0.45:3000,1",
      "zh-cn": "TargetAddress=10.1.0.45:3000,1"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.1.46:3000,1",
      "zh-cn": "TargetAddress=10.1.1.46:3000,1"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.0.47:3000,2",
      "zh-cn": "TargetAddress=10.1.0.47:3000,2"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.1.48:3000,2",
      "zh-cn": "TargetAddress=10.1.1.48:3000,2"
    },
    {
      "indent": 6,
      "text": "TargetAddress=10.1.1.49:3000,3",
      "zh-cn": "TargetAddress=10.1.1.49:3000,3"
    },
    {
      "indent": 3,
      "text": "In this example, any of the target addresses can be used to reach the same target. A single-connection session can be established to any of these TCP addresses. A multiple-connection session could span addresses .45 and .46 or .47 and .48 but cannot span any other combination. A TargetAddress with its own tag (.49) cannot be combined with any other address within the same session.",
      "zh-cn": "In this example, any of the target addresses can be used to reach the same target. A single-connection session can be established to any of these TCP addresses. A multiple-connection session could span addresses .45 and .46 or .47 and .48 but cannot span any other combination. A TargetAddress with its own tag (.49) cannot be combined with any other address within the same session."
    },
    {
      "indent": 3,
      "text": "This SendTargets response does not indicate whether .49 supports multiple connections per session; it is communicated via the MaxConnections text key upon login to the target.",
      "zh-cn": "This SendTargets response does not indicate whether .49 supports multiple connections per session; it is communicated via the MaxConnections text key upon login to the target."
    },
    {
      "indent": 0,
      "text": "Appendix D. Algorithmic Presentation of Error Recovery Classes",
      "section_title": true,
      "zh-cn": "Appendix D. Algorithmic Presentation of Error Recovery Classes"
    },
    {
      "indent": 3,
      "text": "This appendix illustrates the error recovery classes using a pseudo-programming language. The procedure names are chosen to be obvious to most implementers. Each of the recovery classes described has initiator procedures as well as target procedures. These algorithms focus on outlining the mechanics of error recovery classes and do not exhaustively describe all other aspects/cases. Examples of this approach are as follows:",
      "zh-cn": "This appendix illustrates the error recovery classes using a pseudo-programming language. The procedure names are chosen to be obvious to most implementers. Each of the recovery classes described has initiator procedures as well as target procedures. These algorithms focus on outlining the mechanics of error recovery classes and do not exhaustively describe all other aspects/cases. Examples of this approach are as follows:"
    },
    {
      "indent": 6,
      "text": "- Handling for only certain Opcode types is shown.",
      "zh-cn": "- Handling for only certain Opcode types is shown."
    },
    {
      "indent": 6,
      "text": "- Only certain reason codes (e.g., Recovery in Logout command) are outlined.",
      "zh-cn": "- Only certain reason codes (e.g., Recovery in Logout command) are outlined."
    },
    {
      "indent": 6,
      "text": "- Resultant cases, such as recovery of Synchronization on a header digest error, are considered out of scope in these algorithms. In this particular example, a header digest error may lead to connection recovery if some type of Sync and Steering layer is not implemented.",
      "zh-cn": "- Resultant cases, such as recovery of Synchronization on a header digest error, are considered out of scope in these algorithms. In this particular example, a header digest error may lead to connection recovery if some type of Sync and Steering layer is not implemented."
    },
    {
      "indent": 3,
      "text": "These algorithms strive to convey the iSCSI error recovery concepts in the simplest terms and are not designed to be optimal.",
      "zh-cn": "These algorithms strive to convey the iSCSI error recovery concepts in the simplest terms and are not designed to be optimal."
    },
    {
      "indent": 0,
      "text": "D.1. General Data Structure and Procedure Description",
      "section_title": true,
      "zh-cn": "D.1. General Data Structure and Procedure Description"
    },
    {
      "indent": 3,
      "text": "This section defines the procedures and data structures that are commonly used by all the error recovery algorithms. The structures may not be the exhaustive representations of what is required for a typical implementation.",
      "zh-cn": "This section defines the procedures and data structures that are commonly used by all the error recovery algorithms. The structures may not be the exhaustive representations of what is required for a typical implementation."
    },
    {
      "indent": 3,
      "text": "Data structure definitions:",
      "zh-cn": "Data structure definitions:"
    },
    {
      "indent": 3,
      "text": "struct TransferContext {\n        int TargetTransferTag;\n        int ExpectedDataSN;\n};",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "struct TCB {              /* task control block */\n        Boolean SoFarInOrder;\n        int ExpectedDataSN; /* used for both R2Ts and Data */\n        int MissingDataSNList[MaxMissingDPDU];\n        Boolean FbitReceived;\n        Boolean StatusXferd;\n        Boolean CurrentlyAllegiant;\n        int ActiveR2Ts;\n        int Response;\n        char *Reason;\n        struct TransferContext\n                    TransferContextList[MaxOutstandingR2T];\n        int InitiatorTaskTag;\n        int CmdSN;\n        int SNACK_Tag;\n};",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "struct Connection {\n        struct Session SessionReference;\n        Boolean SoFarInOrder;\n        int CID;\n        int State;\n        int CurrentTimeout;\n        int ExpectedStatSN;\n        int MissingStatSNList[MaxMissingSPDU];\n        Boolean PerformConnectionCleanup;\n};",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "struct Session {\n        int NumConnections;\n        int CmdSN;\n        int Maxconnections;\n        int ErrorRecoveryLevel;\n        struct iSCSIEndpoint OtherEndInfo;\n        struct Connection ConnectionList[MaxSupportedConns];\n};",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Procedure descriptions:",
      "zh-cn": "Procedure descriptions:"
    },
    {
      "indent": 3,
      "text": "Receive-an-In-PDU(transport connection, inbound PDU);\ncheck-basic-validity(inbound PDU);\nStart-Timer(timeout handler, argument, timeout value);\nBuild-And-Send-Reject(transport connection, bad PDU, reason code);",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.2. Within-command Error Recovery Algorithms",
      "section_title": true,
      "zh-cn": "D.2. Within-command Error Recovery Algorithms"
    },
    {
      "indent": 0,
      "text": "D.2.1. Procedure Descriptions",
      "section_title": true,
      "zh-cn": "D.2.1. Procedure Descriptions"
    },
    {
      "indent": 3,
      "text": "Recover-Data-if-Possible(last required DataSN, task control block);\nBuild-And-Send-DSnack(task control block);\nBuild-And-Send-RDSnack(task control block);\nBuild-And-Send-Abort(task control block);\nSCSI-Task-Completion(task control block);\nBuild-And-Send-A-Data-Burst(transport connection, data-descriptor,\n   task control block);\nBuild-And-Send-R2T(transport connection, data-descriptor,\n   task control block);\nBuild-And-Send-Status(transport connection, task control block);\nTransfer-Context-Timeout-Handler(transfer context);",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Notes:",
      "zh-cn": "Notes:"
    },
    {
      "indent": 3,
      "text": "- One procedure used in this section: the Handle-Status-SNACK-request is defined in Appendix D.3.",
      "zh-cn": "- One procedure used in this section: the Handle-Status-SNACK-request is defined in Appendix D.3."
    },
    {
      "indent": 3,
      "text": "- The response-processing pseudocode shown in the target algorithms applies to all solicited PDUs that carry the StatSN -- SCSI Response, Text Response, etc.",
      "zh-cn": "- The response-processing pseudocode shown in the target algorithms applies to all solicited PDUs that carry the StatSN -- SCSI Response, Text Response, etc."
    },
    {
      "indent": 0,
      "text": "D.2.2. Initiator Algorithms",
      "section_title": true,
      "zh-cn": "D.2.2. Initiator Algorithms"
    },
    {
      "indent": 3,
      "text": "Recover-Data-if-Possible(LastRequiredDataSN, TCB)\n{\n    if (operational ErrorRecoveryLevel > 0) {\n         if (# of missing PDUs is trackable) {\n               Note the missing DataSNs in TCB.\n               if (the task spanned a change in\n                          MaxRecvDataSegmentLength) {\n                    if (TCB.StatusXferd is TRUE)\n                        drop the status PDU;\n                    Build-And-Send-RDSnack(TCB);\n               } else {\n                    Build-And-Send-DSnack(TCB);\n               }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "         } else {\n             TCB.Reason = \"Protocol Service CRC error\";\n                  }\n    } else {\n          TCB.Reason = \"Protocol Service CRC error\";\n    }\n    if (TCB.Reason == \"Protocol Service CRC error\") {\n          Clear the missing PDU list in the TCB.\n          if (TCB.StatusXferd is not TRUE)\n             Build-And-Send-Abort(TCB);\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Receive-an-In-PDU(Connection, CurrentPDU)\n{\n check-basic-validity(CurrentPDU);\n if (Header-Digest-Bad) discard, return;\n Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n if ((CurrentPDU.type == Data)\n             or (CurrentPDU.type = R2T)) {\n    if (Data-Digest-Bad for Data) {\n              send-data-SNACK = TRUE;\n      LastRequiredDataSN = CurrentPDU.DataSN;\n            } else {\n          if (TCB.SoFarInOrder = TRUE) {\n              if (current DataSN is expected) {\n                   Increment TCB.ExpectedDataSN.\n              } else {\n                      TCB.SoFarInOrder = FALSE;\n                      send-data-SNACK = TRUE;\n                     }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "          } else {\n                  if (current DataSN was considered missing) {\n                     remove current DataSN from missing PDU list.\n                 } else if (current DataSN is higher than expected) {\n                             send-data-SNACK = TRUE;\n                      } else {\n                            discard, return;\n                      }\n                      Adjust TCB.ExpectedDataSN if appropriate.\n             }\n             LastRequiredDataSN = CurrentPDU.DataSN - 1;\n               }\n               if (send-data-SNACK is TRUE and\n                 task is not already considered failed) {\n             Recover-Data-if-Possible(LastRequiredDataSN, TCB);\n    }\n            if (missing data PDU list is empty) {\n               TCB.SoFarInOrder = TRUE;\n            }\n    if (CurrentPDU.type == R2T) {\n       Increment ActiveR2Ts for this task.\n       Create a data-descriptor for the data burst.\n       Build-And-Send-A-Data-Burst(Connection, data-descriptor, TCB);\n     }\n  } else if (CurrentPDU.type == Response) {\n     if (Data-Digest-Bad) {\n                send-status-SNACK = TRUE;\n             } else {\n        TCB.StatusXferd = TRUE;\n        Store the status information in TCB.\n        if (ExpDataSN does not match) {\n             TCB.SoFarInOrder = FALSE;\n             Recover-Data-if-Possible(current DataSN, TCB);\n        }\n                if (missing data PDU list is empty) {\n                     TCB.SoFarInOrder = TRUE;\n                }\n     }\n  } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY, NOT SHOWN */\n  }\n  if ((TCB.SoFarInOrder == TRUE) and\n                        (TCB.StatusXferd == TRUE)) {\n          SCSI-Task-Completion(TCB);\n   }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.2.3. Target Algorithms",
      "section_title": true,
      "zh-cn": "D.2.3. Target Algorithms"
    },
    {
      "indent": 3,
      "text": "Receive-an-In-PDU(Connection, CurrentPDU)\n{\n  check-basic-validity(CurrentPDU);\n  if (Header-Digest-Bad) discard, return;\n  Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n  if (CurrentPDU.type == Data) {\n      Retrieve TContext from CurrentPDU.TargetTransferTag;\n      if (Data-Digest-Bad) {\n                  Build-And-Send-Reject(Connection, CurrentPDU,\n                               Payload-Digest-Error);\n         Note the missing data PDUs in MissingDataRange[].\n                  send-recovery-R2T = TRUE;\n               } else {\n         if (current DataSN is not expected) {\n             Note the missing data PDUs in MissingDataRange[].\n                      send-recovery-R2T = TRUE;\n                  }\n         if (CurrentPDU.Fbit == TRUE) {\n             if (current PDU is solicited) {\n                     Decrement TCB.ActiveR2Ts.\n             }\n             if ((current PDU is unsolicited and\n                     data received is less than I/O length and\n                       data received is less than FirstBurstLength)\n                  or (current PDU is solicited and the length of\n                       this burst is less than expected)) {\n                  send-recovery-R2T = TRUE;\n                  Note the missing data in MissingDataRange[].\n             }\n                  }\n               }\n               Increment TContext.ExpectedDataSN.\n      if (send-recovery-R2T is TRUE and\n                task is not already considered failed) {\n         if (operational ErrorRecoveryLevel > 0) {\n             Increment TCB.ActiveR2Ts.\n             Create a data-descriptor for the data burst\n                        from MissingDataRange.\n             Build-And-Send-R2T(Connection, data-descriptor, TCB);\n         } else {\n              if (current PDU is the last unsolicited)\n                  TCB.Reason = \"Not enough unsolicited data\";\n              else\n                  TCB.Reason = \"Protocol Service CRC error\";\n         }\n      }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "    if (TCB.ActiveR2Ts == 0) {\n       Build-And-Send-Status(Connection, TCB);\n    }\n} else if (CurrentPDU.type == SNACK) {\n    snack-failure = FALSE;\n    if (operational ErrorRecoveryLevel > 0) {\n       if (CurrentPDU.type == Data/R2T) {\n           if (the request is satisfiable) {\n              if (request for Data) {\n                 Create a data-descriptor for the data burst\n                     from BegRun and RunLength.\n                 Build-And-Send-A-Data-Burst(Connection,\n                    data-descriptor, TCB);\n              } else { /* R2T */\n                 Create a data-descriptor for the data burst\n                     from BegRun and RunLength.\n                 Build-And-Send-R2T(Connection, data-descriptor,\n                    TCB);\n               }\n            } else {\n                  snack-failure = TRUE;\n            }\n       } else if (CurrentPDU.type == status) {\n            Handle-Status-SNACK-request(Connection, CurrentPDU);\n       } else if (CurrentPDU.type == DataACK) {\n              Consider all data up to CurrentPDU.BegRun as\n              acknowledged.\n              Free up the retransmission resources for that data.\n         } else if (CurrentPDU.type == R-Data SNACK) {\n                       Create a data descriptor for a data burst\n                       covering all unacknowledged data.\n             Build-And-Send-A-Data-Burst(Connection,\n                data-descriptor, TCB);\n             TCB.SNACK_Tag = CurrentPDU.SNACK_Tag;\n             if (there's no more data to send) {\n                Build-And-Send-Status(Connection, TCB);\n             }\n       }\n    } else { /* operational ErrorRecoveryLevel = 0 */\n             snack-failure = TRUE;\n    }\n    if (snack-failure == TRUE) {\n         Build-And-Send-Reject(Connection, CurrentPDU,\n             SNACK-Reject);\n         if (TCB.StatusXferd != TRUE) {\n             TCB.Reason = \"SNACK rejected\";\n             Build-And-Send-Status(Connection, TCB);\n         }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 9,
      "text": "}",
      "zh-cn": "}"
    },
    {
      "indent": 3,
      "text": "  } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY, NOT SHOWN */\n  }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Transfer-Context-Timeout-Handler(TContext)\n{\n  Retrieve TCB and Connection from TContext.\n  Decrement TCB.ActiveR2Ts.\n  if (operational ErrorRecoveryLevel > 0 and\n                task is not already considered failed) {\n      Note the missing data PDUs in MissingDataRange[].\n      Create a data-descriptor for the data burst\n                        from MissingDataRange[].\n      Build-And-Send-R2T(Connection, data-descriptor, TCB);",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "    } else {\n        TCB.Reason = \"Protocol Service CRC error\";\n        if (TCB.ActiveR2Ts = 0) {\n           Build-And-Send-Status(Connection, TCB);\n        }\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.3. Within-connection Recovery Algorithms",
      "section_title": true,
      "zh-cn": "D.3. Within-connection Recovery Algorithms"
    },
    {
      "indent": 0,
      "text": "D.3.1. Procedure Descriptions",
      "section_title": true,
      "zh-cn": "D.3.1. Procedure Descriptions"
    },
    {
      "indent": 3,
      "text": "Procedure descriptions:",
      "zh-cn": "Procedure descriptions:"
    },
    {
      "indent": 3,
      "text": "Recover-Status-if-Possible(transport connection,\n   currently received PDU);\nEvaluate-a-StatSN(transport connection, currently received PDU);\nRetransmit-Command-if-Possible(transport connection, CmdSN);\nBuild-And-Send-SSnack(transport connection);\nBuild-And-Send-Command(transport connection,\n   task control block);\nCommand-Acknowledge-Timeout-Handler(task control block);\nStatus-Expect-Timeout-Handler(transport connection);\nBuild-And-Send-NOP-Out(transport connection);\nHandle-Status-SNACK-request(transport connection,\n   Status SNACK PDU);\nRetransmit-Status-Burst(Status SNACK, task control block);\nIs-Acknowledged(beginning StatSN, run length);",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Implementation-specific parameters that are tunable:",
      "zh-cn": "Implementation-specific parameters that are tunable:"
    },
    {
      "indent": 3,
      "text": "InitiatorProactiveSNACKEnabled",
      "zh-cn": "InitiatorProactiveSNACKEnabled"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "zh-cn": "Notes:"
    },
    {
      "indent": 3,
      "text": "- The initiator algorithms only deal with unsolicited NOP-In PDUs for generating Status SNACKs. A solicited NOP-In PDU has an assigned StatSN that, when out of order, could trigger the out-of-order StatSN handling in within-command algorithms, again leading to Recover-Status-if-Possible.",
      "zh-cn": "- The initiator algorithms only deal with unsolicited NOP-In PDUs for generating Status SNACKs. A solicited NOP-In PDU has an assigned StatSN that, when out of order, could trigger the out-of-order StatSN handling in within-command algorithms, again leading to Recover-Status-if-Possible."
    },
    {
      "indent": 3,
      "text": "- The pseudocode shown may result in the retransmission of unacknowledged commands in more cases than necessary. This will not, however, affect the correctness of the operation because the target is required to discard the duplicate CmdSNs.",
      "zh-cn": "- The pseudocode shown may result in the retransmission of unacknowledged commands in more cases than necessary. This will not, however, affect the correctness of the operation because the target is required to discard the duplicate CmdSNs."
    },
    {
      "indent": 3,
      "text": "- The procedure Build-And-Send-Async is defined in the connection recovery algorithms.",
      "zh-cn": "- The procedure Build-And-Send-Async is defined in the connection recovery algorithms."
    },
    {
      "indent": 3,
      "text": "- The procedure Status-Expect-Timeout-Handler describes how initiators may proactively attempt to retrieve the Status if they so choose. This procedure is assumed to be triggered much before the standard ULP timeout.",
      "zh-cn": "- The procedure Status-Expect-Timeout-Handler describes how initiators may proactively attempt to retrieve the Status if they so choose. This procedure is assumed to be triggered much before the standard ULP timeout."
    },
    {
      "indent": 0,
      "text": "D.3.2. Initiator Algorithms",
      "section_title": true,
      "zh-cn": "D.3.2. Initiator Algorithms"
    },
    {
      "indent": 5,
      "text": "Recover-Status-if-Possible(Connection, CurrentPDU)\n{\n    if ((Connection.state == LOGGED_IN) and\n                connection is not already considered failed) {\n       if (operational ErrorRecoveryLevel > 0) {\n          if (# of missing PDUs is trackable) {\n                Note the missing StatSNs in Connection\n                that were not already requested with SNACK;\n            Build-And-Send-SSnack(Connection);\n                  } else {\n                    Connection.PerformConnectionCleanup = TRUE;\n          }\n       } else {\n                  Connection.PerformConnectionCleanup = TRUE;\n       }\n       if (Connection.PerformConnectionCleanup == TRUE) {\n          Start-Timer(Connection-Cleanup-Handler, Connection, 0);\n                }\n    }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "}",
      "zh-cn": "}"
    },
    {
      "indent": 5,
      "text": "Retransmit-Command-if-Possible(Connection, CmdSN)\n{\n    if (operational ErrorRecoveryLevel > 0) {\n       Retrieve the InitiatorTaskTag, and thus TCB for the CmdSN.\n       Build-And-Send-Command(Connection, TCB);\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Evaluate-a-StatSN(Connection, CurrentPDU)\n{\n    send-status-SNACK = FALSE;\n    if (Connection.SoFarInOrder == TRUE) {\n       if (current StatSN is the expected) {\n            Increment Connection.ExpectedStatSN.\n       } else {\n                     Connection.SoFarInOrder = FALSE;\n                     send-status-SNACK = TRUE;\n                }\n    } else {\n       if (current StatSN was considered missing) {\n            remove current StatSN from the missing list.\n       } else {\n                     if (current StatSN is higher than expected){\n                         send-status-SNACK = TRUE;\n                     } else {\n                         send-status-SNACK = FALSE;\n                 discard the PDU;\n            }\n       }\n       Adjust Connection.ExpectedStatSN if appropriate.\n       if (missing StatSN list is empty) {\n            Connection.SoFarInOrder = TRUE;\n                }\n    }\n    return send-status-SNACK;\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Receive-an-In-PDU(Connection, CurrentPDU)\n{\n    check-basic-validity(CurrentPDU);\n    if (Header-Digest-Bad) discard, return;\n    Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n    if (CurrentPDU.type == NOP-In) {\n          if (the PDU is unsolicited) {\n                if (current StatSN is not expected) {\n                     Recover-Status-if-Possible(Connection,\n                                  CurrentPDU);\n                }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "                if (current ExpCmdSN is not Session.CmdSN) {\n                     Retransmit-Command-if-Possible(Connection,\n                                  CurrentPDU.ExpCmdSN);\n                }\n          }\n    } else if (CurrentPDU.type == Reject) {\n          if (it is a data digest error on immediate data) {\n                Retransmit-Command-if-Possible(Connection,\n                                  CurrentPDU.BadPDUHeader.CmdSN);\n          }\n    } else if (CurrentPDU.type == Response) {\n         send-status-SNACK = Evaluate-a-StatSN(Connection,\n                                        CurrentPDU);\n         if (send-status-SNACK == TRUE)\n             Recover-Status-if-Possible(Connection, CurrentPDU);\n    } else { /* REST UNRELATED TO WITHIN-CONNECTION-RECOVERY,\n              * NOT SHOWN */\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Command-Acknowledge-Timeout-Handler(TCB)\n{\n    Retrieve the Connection for TCB.\n    Retransmit-Command-if-Possible(Connection, TCB.CmdSN);\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Status-Expect-Timeout-Handler(Connection) {",
      "zh-cn": "Status-Expect-Timeout-Handler(Connection) {"
    },
    {
      "indent": 5,
      "text": "    if (operational ErrorRecoveryLevel > 0) {\n        Build-And-Send-NOP-Out(Connection);\n    } else if (InitiatorProactiveSNACKEnabled){\n        if ((Connection.state == LOGGED_IN) and\n                     connection is not already considered failed) {\n             Build-And-Send-SSnack(Connection);\n        }\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.3.3. Target Algorithms",
      "section_title": true,
      "zh-cn": "D.3.3. Target Algorithms"
    },
    {
      "indent": 3,
      "text": "Handle-Status-SNACK-request(Connection, CurrentPDU)\n  {\n      if (operational ErrorRecoveryLevel > 0) {\n         if (request for an acknowledged run) {\n             Build-And-Send-Reject(Connection, CurrentPDU,\n                                           Protocol-Error);\n         } else if (request for an untransmitted run) {\n             discard, return;\n         } else {\n             Retransmit-Status-Burst(CurrentPDU, TCB);\n         }\n      } else {\n         Build-And-Send-Async(Connection, DroppedConnection,\n                               DefaultTime2Wait, DefaultTime2Retain);\n      }\n  }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.4. Connection Recovery Algorithms",
      "section_title": true,
      "zh-cn": "D.4. Connection Recovery Algorithms"
    },
    {
      "indent": 0,
      "text": "D.4.1. Procedure Descriptions",
      "section_title": true,
      "zh-cn": "D.4.1. Procedure Descriptions"
    },
    {
      "indent": 3,
      "text": "Build-And-Send-Async(transport connection, reason code,\n   minimum time, maximum time);\nPick-A-Logged-In-Connection(session);\nBuild-And-Send-Logout(transport connection,\n   logout connection identifier, reason code);\nPerformImplicitLogout(transport connection,\n   logout connection identifier, target information);\nPerformLogin(transport connection, target information);\nCreateNewTransportConnection(target information);\nBuild-And-Send-Command(transport connection, task control block);\nConnection-Cleanup-Handler(transport connection);\nConnection-Resource-Timeout-Handler(transport connection);\nQuiesce-And-Prepare-for-New-Allegiance(session, task control block);\nBuild-And-Send-Logout-Response(transport connection,\n   CID of connection in recovery, reason code);\nBuild-And-Send-TaskMgmt-Response(transport connection,\n   task mgmt command PDU, response code);\nEstablish-New-Allegiance(task control block, transport connection);\nSchedule-Command-To-Continue(task control block);",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Note:",
      "zh-cn": "Note:"
    },
    {
      "indent": 3,
      "text": "- Transport exception conditions such as unexpected connection termination, connection reset, and hung connection while the connection is in the Full Feature Phase are all assumed to be asynchronously signaled to the iSCSI layer using the Transport_Exception_Handler procedure.",
      "zh-cn": "- Transport exception conditions such as unexpected connection termination, connection reset, and hung connection while the connection is in the Full Feature Phase are all assumed to be asynchronously signaled to the iSCSI layer using the Transport_Exception_Handler procedure."
    },
    {
      "indent": 0,
      "text": "D.4.2. Initiator Algorithms",
      "section_title": true,
      "zh-cn": "D.4.2. Initiator Algorithms"
    },
    {
      "indent": 5,
      "text": "Receive-an-In-PDU(Connection, CurrentPDU)\n{\n    check-basic-validity(CurrentPDU);\n    if (Header-Digest-Bad) discard, return;\n    Retrieve TCB from CurrentPDU.InitiatorTaskTag.\n    if (CurrentPDU.type == Async) {\n        if (CurrentPDU.AsyncEvent == ConnectionDropped) {\n           Retrieve the AffectedConnection for\n              CurrentPDU.Parameter1.\n           AffectedConnection.CurrentTimeout =\n              CurrentPDU.Parameter3;\n          AffectedConnection.State = CLEANUP_WAIT;\n          Start-Timer(Connection-Cleanup-Handler,\n                       AffectedConnection, CurrentPDU.Parameter2);\n        } else if (CurrentPDU.AsyncEvent == LogoutRequest)) {\n          AffectedConnection = Connection;\n          AffectedConnection.State = LOGOUT_REQUESTED;\n          AffectedConnection.PerformConnectionCleanup = TRUE;\n                   AffectedConnection.CurrentTimeout =\n                      CurrentPDU.Parameter3;\n          Start-Timer(Connection-Cleanup-Handler,\n                        AffectedConnection, 0);\n        } else if (CurrentPDU.AsyncEvent == SessionDropped)) {\n          for (each Connection) {\n              Connection.State = CLEANUP_WAIT;\n              Connection.CurrentTimeout = CurrentPDU.Parameter3;\n              Start-Timer(Connection-Cleanup-Handler,\n                        Connection, CurrentPDU.Parameter2);\n          }\n          Session.state = FAILED;\n        }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 9,
      "text": "} else if (CurrentPDU.type == LogoutResponse) {\n    Retrieve the CleanupConnection for CurrentPDU.CID.\n    if (CurrentPDU.Response = failure) {\n       CleanupConnection.State = CLEANUP_WAIT;",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "        } else {\n            CleanupConnection.State = FREE;\n        }\n    } else if (CurrentPDU.type == LoginResponse) {\n         if (this is a response to an implicit Logout) {\n            Retrieve the CleanupConnection.\n            if (successful) {\n                CleanupConnection.State = FREE;\n                Connection.State = LOGGED_IN;\n            } else {\n                 CleanupConnection.State = CLEANUP_WAIT;\n                 DestroyTransportConnection(Connection);\n            }\n         }\n    } else { /* REST UNRELATED TO CONNECTION-RECOVERY,\n              * NOT SHOWN */\n    }\n    if (CleanupConnection.State == FREE) {\n       for (each command that was active on CleanupConnection) {\n       /* Establish new connection allegiance */\n            NewConnection = Pick-A-Logged-In-Connection(Session);\n            Build-And-Send-Command(NewConnection, TCB);\n        }\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Connection-Cleanup-Handler(Connection)\n{\n    Retrieve Session from Connection.\n    if (Connection can still exchange iSCSI PDUs) {\n        NewConnection = Connection;\n    } else {\n        Start-Timer(Connection-Resource-Timeout-Handler,\n              Connection, Connection.CurrentTimeout);\n        if (there are other logged-in connections) {\n             NewConnection = Pick-A-Logged-In-Connection(Session);\n        } else {\n             NewConnection =\n                CreateTransportConnection(Session.OtherEndInfo);\n             Initiate an implicit Logout on NewConnection for\n                Connection.CID.\n             return;\n        }\n    }\n    Build-And-Send-Logout(NewConnection, Connection.CID,\n                                        RecoveryRemove);\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "Transport_Exception_Handler(Connection)\n{\n    Connection.PerformConnectionCleanup = TRUE;\n    if (the event is an unexpected transport disconnect) {\n        Connection.State = CLEANUP_WAIT;\n        Connection.CurrentTimeout = DefaultTime2Retain;\n        Start-Timer(Connection-Cleanup-Handler, Connection,\n                       DefaultTime2Wait);\n    } else {\n        Connection.State = FREE;\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "D.4.3. Target Algorithms",
      "section_title": true,
      "zh-cn": "D.4.3. Target Algorithms"
    },
    {
      "indent": 5,
      "text": "Receive-an-In-PDU(Connection, CurrentPDU)\n{\n    check-basic-validity(CurrentPDU);\n    if (Header-Digest-Bad) discard, return;\n    else if (Data-Digest-Bad) {\n              Build-And-Send-Reject(Connection, CurrentPDU,\n                                       Payload-Digest-Error);\n              discard, return;\n    }\n    Retrieve TCB and Session.\n    if (CurrentPDU.type == Logout) {\n       if (CurrentPDU.ReasonCode = RecoveryRemove) {\n           Retrieve the CleanupConnection from CurrentPDU.CID).\n           for (each command active on CleanupConnection) {\n                Quiesce-And-Prepare-for-New-Allegiance(Session,\n                   TCB);\n                TCB.CurrentlyAllegiant = FALSE;\n           }\n           Cleanup-Connection-State(CleanupConnection);\n           if ((quiescing successful) and (cleanup successful))\n{\n                Build-And-Send-Logout-Response(Connection,\n                                  CleanupConnection.CID, Success);\n           } else {\n                Build-And-Send-Logout-Response(Connection,\n                                  CleanupConnection.CID, Failure);\n           }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 13,
      "text": "}",
      "zh-cn": "}"
    },
    {
      "indent": 5,
      "text": "    } else if ((CurrentPDU.type == Login) and\n                         operational ErrorRecoveryLevel == 2) {\n            Retrieve the CleanupConnection from CurrentPDU.CID).\n            for (each command active on CleanupConnection) {\n                  Quiesce-And-Prepare-for-New-Allegiance(Session,\n                     TCB);\n                  TCB.CurrentlyAllegiant = FALSE;\n            }\n            Cleanup-Connection-State(CleanupConnection);\n            if ((quiescing successful) and (cleanup successful))\n{\n                  Continue with the rest of the login processing;\n            } else {\n                  Build-And-Send-Login-Response(Connection,\n                             CleanupConnection.CID, Target Error);\n            }\n        }\n    } else if (CurrentPDU.type == TaskManagement) {\n          if (CurrentPDU.function == \"TaskReassign\") {\n                if (Session.ErrorRecoveryLevel < 2) {\n                    Build-And-Send-TaskMgmt-Response(Connection,\n                       CurrentPDU,\n                          \"Task allegiance reassignment not\n                                              supported\");\n                } else if (task is not found) {\n                    Build-And-Send-TaskMgmt-Response(Connection,\n                       CurrentPDU, \"Task not in task set\");\n                } else if (task is currently allegiant) {\n                    Build-And-Send-TaskMgmt-Response(Connection,\n                       CurrentPDU, \"Task still allegiant\");\n                } else {\n                    Establish-New-Allegiance(TCB, Connection);\n                    TCB.CurrentlyAllegiant = TRUE;\n                    Schedule-Command-To-Continue(TCB);\n                }\n          }\n    } else { /* REST UNRELATED TO CONNECTION-RECOVERY,\n              * NOT SHOWN */\n    }",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "}",
      "zh-cn": "}"
    },
    {
      "indent": 5,
      "text": "Transport_Exception_Handler(Connection)\n{\n    Connection.PerformConnectionCleanup = TRUE;\n    if (the event is an unexpected transport disconnect) {\n        Connection.State = CLEANUP_WAIT;\n         Start-Timer(Connection-Resource-Timeout-Handler,\n            Connection, (DefaultTime2Wait+DefaultTime2Retain));\n          if (this Session has Full Feature Phase connections\n                left) {\n              DifferentConnection =\n                 Pick-A-Logged-In-Connection(Session);\n               Build-And-Send-Async(DifferentConnection,\n                     DroppedConnection, DefaultTime2Wait,\n                       DefaultTime2Retain);\n        }\n    } else {\n          Connection.State = FREE;\n    }\n}",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 0,
      "text": "Appendix E. Clearing Effects of Various Events on Targets",
      "section_title": true,
      "zh-cn": "Appendix E. Clearing Effects of Various Events on Targets"
    },
    {
      "indent": 0,
      "text": "E.1. Clearing Effects on iSCSI Objects",
      "section_title": true,
      "zh-cn": "E.1. Clearing Effects on iSCSI Objects"
    },
    {
      "indent": 3,
      "text": "The following tables describe the target behavior on receiving the events specified in the rows of the table. The second table is an extension of the first table and defines clearing actions for more objects on the same events. The legend is:",
      "zh-cn": "The following tables describe the target behavior on receiving the events specified in the rows of the table. The second table is an extension of the first table and defines clearing actions for more objects on the same events. The legend is:"
    },
    {
      "indent": 4,
      "text": "Y = Yes (cleared/discarded/reset on the event specified in the row). Unless otherwise noted, the clearing action is only applicable for the issuing initiator port.",
      "zh-cn": "Y = Yes (cleared/discarded/reset on the event specified in the row). Unless otherwise noted, the clearing action is only applicable for the issuing initiator port."
    },
    {
      "indent": 4,
      "text": "N = No (not affected on the event specified in the row, i.e., stays at previous value).",
      "zh-cn": "N = No (not affected on the event specified in the row, i.e., stays at previous value)."
    },
    {
      "indent": 3,
      "text": "NA = Not Applicable or Not Defined.",
      "zh-cn": "NA = Not Applicable or Not Defined."
    },
    {
      "indent": 5,
      "text": "                       +------+------+------+------+------+\n                       |IT (1)|IC (2)|CT (5)|ST (6)|PP (7)|\n+----------------------+------+------+------+------+------+\n|connection failure (8)|Y     |Y     |N     |N     |Y     |\n+----------------------+------+------+------+------+------+\n|connection state      |NA    |NA    |Y     |N     |NA    |\n|timeout (9)           |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|session timeout/      |Y     |Y     |Y     |Y     |Y (14)|\n|closure/reinstatement |      |      |      |      |      |\n|(10)                  |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|session continuation  |NA    |NA    |N (11)|N     |NA    |\n|(12)                  |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|successful connection |Y     |Y     |Y     |N     |Y (13)|\n|close logout          |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|session failure (18)  |Y     |Y     |N     |N     |Y     |\n+----------------------+------+------+------+------+------+\n|successful recovery   |Y     |Y     |N     |N     |Y (13)|\n|Logout                |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|failed Logout         |Y     |Y     |N     |N     |Y     |\n+----------------------+------+------+------+------+------+\n|connection Login      |NA    |NA    |NA    |Y (15)|NA    |\n|(leading)             |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|connection Login      |NA    |NA    |N (11)|N     |Y     |\n|(non-leading)         |      |      |      |      |      |\n+----------------------+------+------+------+------+------+\n|TARGET COLD RESET (16)|Y (20)|Y     |Y     |Y     |Y     |\n+----------------------+------+------+------+------+------+\n|TARGET WARM RESET (16)|Y (20)|Y     |Y     |Y     |Y     |\n+----------------------+------+------+------+------+------+\n|LU reset (19)         |Y (20)|Y     |Y     |Y     |Y     |\n+----------------------+------+------+------+------+------+\n|power cycle (16)      |Y     |Y     |Y     |Y     |Y     |\n+----------------------+------+------+------+------+------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "(1) Incomplete TTTs (IT) are Target Transfer Tags on which the target is still expecting PDUs to be received. Examples include TTTs received via R2T, NOP-In, etc.",
      "zh-cn": "(1) Incomplete TTTs (IT) are Target Transfer Tags on which the target is still expecting PDUs to be received. Examples include TTTs received via R2T, NOP-In, etc."
    },
    {
      "indent": 5,
      "text": "(2) Immediate Commands (IC) are immediate commands, but waiting for execution on a target (for example, ABORT TASK SET).",
      "zh-cn": "(2) Immediate Commands (IC) are immediate commands, but waiting for execution on a target (for example, ABORT TASK SET)."
    },
    {
      "indent": 5,
      "text": "(5) Connection Tasks (CT) are tasks that are active on the iSCSI connection in question.",
      "zh-cn": "(5) Connection Tasks (CT) are tasks that are active on the iSCSI connection in question."
    },
    {
      "indent": 5,
      "text": "(6) Session Tasks (ST) are tasks that are active on the entire iSCSI session. A union of \"connection tasks\" on all participating connections.",
      "zh-cn": "(6) Session Tasks (ST) are tasks that are active on the entire iSCSI session. A union of \"connection tasks\" on all participating connections."
    },
    {
      "indent": 5,
      "text": "(7) Partial PDUs (PP) (if any) are PDUs that are partially sent and waiting for transport window credit to complete the transmission.",
      "zh-cn": "(7) Partial PDUs (PP) (if any) are PDUs that are partially sent and waiting for transport window credit to complete the transmission."
    },
    {
      "indent": 5,
      "text": "(8) Connection failure is a connection exception condition - one of the transport connections shut down, transport connections reset, or transport connections timed out, which abruptly terminated the iSCSI Full Feature Phase connection. A connection failure always takes the connection state machine to the CLEANUP_WAIT state.",
      "zh-cn": "(8) Connection failure is a connection exception condition - one of the transport connections shut down, transport connections reset, or transport connections timed out, which abruptly terminated the iSCSI Full Feature Phase connection. A connection failure always takes the connection state machine to the CLEANUP_WAIT state."
    },
    {
      "indent": 5,
      "text": "(9) Connection state timeout happens if a connection spends more time than agreed upon during login negotiation in the CLEANUP_WAIT state, and this takes the connection to the FREE state (M1 transition in connection cleanup state diagram; see Section 8.2).",
      "zh-cn": "(9) Connection state timeout happens if a connection spends more time than agreed upon during login negotiation in the CLEANUP_WAIT state, and this takes the connection to the FREE state (M1 transition in connection cleanup state diagram; see Section 8.2)."
    },
    {
      "indent": 5,
      "text": "(10) Session timeout, closure, and reinstatement are defined in Section 6.3.5.",
      "zh-cn": "(10) Session timeout, closure, and reinstatement are defined in Section 6.3.5."
    },
    {
      "indent": 5,
      "text": "(11) This clearing effect is \"Y\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is less than 2.",
      "zh-cn": "(11) This clearing effect is \"Y\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is less than 2."
    },
    {
      "indent": 5,
      "text": "(12) Session continuation is defined in Section 6.3.6.",
      "zh-cn": "(12) Session continuation is defined in Section 6.3.6."
    },
    {
      "indent": 5,
      "text": "(13) This clearing effect is only valid if the connection is being logged out on a different connection and when the connection being logged out on the target may have some partial PDUs pending to be sent. In all other cases, the effect is \"NA\".",
      "zh-cn": "(13) This clearing effect is only valid if the connection is being logged out on a different connection and when the connection being logged out on the target may have some partial PDUs pending to be sent. In all other cases, the effect is \"NA\"."
    },
    {
      "indent": 5,
      "text": "(14) This clearing effect is only valid for a \"close the session\" logout in a multi-connection session. In all other cases, the effect is \"NA\".",
      "zh-cn": "(14) This clearing effect is only valid for a \"close the session\" logout in a multi-connection session. In all other cases, the effect is \"NA\"."
    },
    {
      "indent": 5,
      "text": "(15) Only applicable if this leading connection login is a session reinstatement. If this is not the case, it is \"NA\".",
      "zh-cn": "(15) Only applicable if this leading connection login is a session reinstatement. If this is not the case, it is \"NA\"."
    },
    {
      "indent": 5,
      "text": "(16) This operation affects all logged-in initiators.",
      "zh-cn": "(16) This operation affects all logged-in initiators."
    },
    {
      "indent": 5,
      "text": "(18) Session failure is defined in Section 6.3.6.",
      "zh-cn": "(18) Session failure is defined in Section 6.3.6."
    },
    {
      "indent": 5,
      "text": "(19) This operation affects all logged-in initiators, and the clearing effects are only applicable to the LU being reset.",
      "zh-cn": "(19) This operation affects all logged-in initiators, and the clearing effects are only applicable to the LU being reset."
    },
    {
      "indent": 5,
      "text": "(20) With standard multi-task abort semantics (Section 4.2.3.3), a TARGET WARM RESET or a TARGET COLD RESET or a LU reset would clear the active TTTs upon completion. However, the FastAbort multi-task abort semantics defined by Section 4.2.3.4 do not guarantee that the active TTTs are cleared by the end of the reset operations. In fact, the FastAbort semantics are designed to allow clearing the TTTs in a \"lazy\" fashion after the TMF Response is delivered. Thus, when TaskReporting=FastAbort (Section 13.23) is operational on a session, the clearing effects of reset operations on \"Incomplete TTTs\" is \"N\".",
      "zh-cn": "(20) With standard multi-task abort semantics (Section 4.2.3.3), a TARGET WARM RESET or a TARGET COLD RESET or a LU reset would clear the active TTTs upon completion. However, the FastAbort multi-task abort semantics defined by Section 4.2.3.4 do not guarantee that the active TTTs are cleared by the end of the reset operations. In fact, the FastAbort semantics are designed to allow clearing the TTTs in a \"lazy\" fashion after the TMF Response is delivered. Thus, when TaskReporting=FastAbort (Section 13.23) is operational on a session, the clearing effects of reset operations on \"Incomplete TTTs\" is \"N\"."
    },
    {
      "indent": 5,
      "text": "                      +------+-------+------+------+-------+\n                      |DC (1)|DD (2) |SS (3)|CS (4)|DS (5) |\n+---------------------+------+-------+------+------+-------+\n|connection failure   |N     |Y      |N     |N     |N      |\n+---------------------+------+-------+------+------+-------+\n|connection state     |Y     |NA     |Y     |N     |NA     |\n|timeout              |      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|session timeout/     |Y     |Y      |Y (7) |Y     |NA     |\n|closure/reinstatement|      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|session continuation |N (11)|NA (12)|NA    |N     |NA (13)|\n+---------------------+------+-------+------+------+-------+\n|successful connection|Y     |Y      |Y     |N     |NA     |\n|close Logout         |      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|session failure      |N     |Y      |N     |N     |N      |\n+---------------------+------+-------+------+------+-------+\n|successful recovery  |Y     |Y      |Y     |N     |N      |\n|Logout               |      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|failed Logout        |N     |Y (9)  |N     |N     |N      |\n+---------------------+------+-------+------+------+-------+\n|connection Login     |NA    |NA     |N (8) |N (8) |NA     |\n|(leading             |      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|connection Login     |N (11)|NA (12)|N (8) |N     |NA (13)|\n|(non-leading)        |      |       |      |      |       |\n+---------------------+------+-------+------+------+-------+\n|TARGET COLD RESET    |Y     |Y      |Y     |Y (10)|NA     |\n+---------------------+------+-------+------+------+-------+\n|TARGET WARM RESET    |Y     |Y      |N     |N     |NA     |\n+---------------------+------+-------+------+------+-------+\n|LU reset             |N     |Y      |N     |N     |N      |\n+---------------------+------+-------+------+------+-------+\n|power cycle          |Y     |Y      |Y     |Y (10)|NA     |\n+---------------------+------+-------+------+------+-------+",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 5,
      "text": "(1) Discontiguous Commands (DC) are commands allegiant to the connection in question and waiting to be reordered in the iSCSI layer. All \"Y\"s in this column assume that the task causing the event (if indeed the event is the result of a task) is issued as an immediate command, because the discontiguities can be ahead of the task.",
      "zh-cn": "(1) Discontiguous Commands (DC) are commands allegiant to the connection in question and waiting to be reordered in the iSCSI layer. All \"Y\"s in this column assume that the task causing the event (if indeed the event is the result of a task) is issued as an immediate command, because the discontiguities can be ahead of the task."
    },
    {
      "indent": 5,
      "text": "(2) Discontiguous Data (DD) are data PDUs received for the task in question and waiting to be reordered due to prior discontiguities in the DataSN.",
      "zh-cn": "(2) Discontiguous Data (DD) are data PDUs received for the task in question and waiting to be reordered due to prior discontiguities in the DataSN."
    },
    {
      "indent": 5,
      "text": "(3) \"SS\" refers to the StatSN.",
      "zh-cn": "(3) \"SS\" refers to the StatSN."
    },
    {
      "indent": 5,
      "text": "(4) \"CS\" refers to the CmdSN.",
      "zh-cn": "(4) \"CS\" refers to the CmdSN."
    },
    {
      "indent": 5,
      "text": "(5) \"DS\" refers to the DataSN.",
      "zh-cn": "(5) \"DS\" refers to the DataSN."
    },
    {
      "indent": 5,
      "text": "(7) This action clears the StatSN on all the connections.",
      "zh-cn": "(7) This action clears the StatSN on all the connections."
    },
    {
      "indent": 5,
      "text": "(8) This sequence number is instantiated on this event.",
      "zh-cn": "(8) This sequence number is instantiated on this event."
    },
    {
      "indent": 5,
      "text": "(9) A logout failure drives the connection state machine to the CLEANUP_WAIT state, similar to the connection failure event. Hence, it has a similar effect on this and several other protocol aspects.",
      "zh-cn": "(9) A logout failure drives the connection state machine to the CLEANUP_WAIT state, similar to the connection failure event. Hence, it has a similar effect on this and several other protocol aspects."
    },
    {
      "indent": 5,
      "text": "(10) This is cleared by virtue of the fact that all sessions with all initiators are terminated.",
      "zh-cn": "(10) This is cleared by virtue of the fact that all sessions with all initiators are terminated."
    },
    {
      "indent": 5,
      "text": "(11) This clearing effect is \"Y\" if it is a connection reinstatement.",
      "zh-cn": "(11) This clearing effect is \"Y\" if it is a connection reinstatement."
    },
    {
      "indent": 5,
      "text": "(12) This clearing effect is \"Y\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is 2.",
      "zh-cn": "(12) This clearing effect is \"Y\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is 2."
    },
    {
      "indent": 5,
      "text": "(13) This clearing effect is \"N\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is 2.",
      "zh-cn": "(13) This clearing effect is \"N\" only if it is a connection reinstatement and the operational ErrorRecoveryLevel is 2."
    },
    {
      "indent": 0,
      "text": "E.2. Clearing Effects on SCSI Objects",
      "section_title": true,
      "zh-cn": "E.2. Clearing Effects on SCSI Objects"
    },
    {
      "indent": 3,
      "text": "The only iSCSI protocol action that can effect clearing actions on SCSI objects is the \"I_T nexus loss\" notification (Section 6.3.5.1 (\"Loss of Nexus Notification\")). [SPC3] describes the clearing effects of this notification on a variety of SCSI attributes. In addition, SCSI standards documents (such as [SAM2] and [SBC2]) define additional clearing actions that may take place for several SCSI objects on SCSI events such as LU resets and power-on resets.",
      "zh-cn": "The only iSCSI protocol action that can effect clearing actions on SCSI objects is the \"I_T nexus loss\" notification (Section 6.3.5.1 (\"Loss of Nexus Notification\")). [SPC3] describes the clearing effects of this notification on a variety of SCSI attributes. In addition, SCSI standards documents (such as [SAM2] and [SBC2]) define additional clearing actions that may take place for several SCSI objects on SCSI events such as LU resets and power-on resets."
    },
    {
      "indent": 3,
      "text": "Since iSCSI defines a TARGET COLD RESET as a \"protocol-equivalent\" to a target power-cycle, the iSCSI TARGET COLD RESET must also be considered as the power-on reset event in interpreting the actions defined in the SCSI standards.",
      "zh-cn": "Since iSCSI defines a TARGET COLD RESET as a \"protocol-equivalent\" to a target power-cycle, the iSCSI TARGET COLD RESET must also be considered as the power-on reset event in interpreting the actions defined in the SCSI standards."
    },
    {
      "indent": 3,
      "text": "When the iSCSI session is reconstructed (between the same SCSI ports with the same nexus identifier) reestablishing the same I_T nexus, all SCSI objects that are defined to not clear on the \"I_T nexus loss\" notification event, such as persistent reservations, are automatically associated to this new session.",
      "zh-cn": "When the iSCSI session is reconstructed (between the same SCSI ports with the same nexus identifier) reestablishing the same I_T nexus, all SCSI objects that are defined to not clear on the \"I_T nexus loss\" notification event, such as persistent reservations, are automatically associated to this new session."
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "zh-cn": "Acknowledgments"
    },
    {
      "indent": 3,
      "text": "Several individuals on the original IPS Working Group made significant contributions to the original RFCs 3720, 3980, 4850, and 5048.",
      "zh-cn": "Several individuals on the original IPS Working Group made significant contributions to the original RFCs 3720, 3980, 4850, and 5048."
    },
    {
      "indent": 3,
      "text": "Specifically, the authors of the original RFCs -- which herein are consolidated into a single document -- were the following:",
      "zh-cn": "Specifically, the authors of the original RFCs -- which herein are consolidated into a single document -- were the following:"
    },
    {
      "indent": 6,
      "text": "RFC 3720: Julian Satran, Kalman Meth, Costa Sapuntzakis, Mallikarjun Chadalapaka, Efri Zeidner",
      "zh-cn": "RFC 3720: Julian Satran, Kalman Meth, Costa Sapuntzakis, Mallikarjun Chadalapaka, Efri Zeidner"
    },
    {
      "indent": 6,
      "text": "RFC 3980: Marjorie Krueger, Mallikarjun Chadalapaka, Rob Elliott",
      "zh-cn": "RFC 3980: Marjorie Krueger, Mallikarjun Chadalapaka, Rob Elliott"
    },
    {
      "indent": 6,
      "text": "RFC 4850: David Wysochanski",
      "zh-cn": "RFC 4850: David Wysochanski"
    },
    {
      "indent": 6,
      "text": "RFC 5048: Mallikarjun Chadalapaka",
      "zh-cn": "RFC 5048: Mallikarjun Chadalapaka"
    },
    {
      "indent": 3,
      "text": "Many thanks to Fred Knight for contributing to the UML notations and drawings in this document.",
      "zh-cn": "Many thanks to Fred Knight for contributing to the UML notations and drawings in this document."
    },
    {
      "indent": 3,
      "text": "We would in addition like to acknowledge the following individuals who contributed to this revised document: David Harrington, Paul Koning, Mark Edwards, Rob Elliott, and Martin Stiemerling.",
      "zh-cn": "We would in addition like to acknowledge the following individuals who contributed to this revised document: David Harrington, Paul Koning, Mark Edwards, Rob Elliott, and Martin Stiemerling."
    },
    {
      "indent": 3,
      "text": "Thanks to Yi Zeng and Nico Williams for suggesting and/or reviewing Kerberos-related security considerations text.",
      "zh-cn": "Thanks to Yi Zeng and Nico Williams for suggesting and/or reviewing Kerberos-related security considerations text."
    },
    {
      "indent": 3,
      "text": "The authors gratefully acknowledge the valuable feedback during the Last Call review process from a number of individuals; their feedback significantly improved this document. The individuals were Stephen Farrell, Brian Haberman, Barry Leiba, Pete Resnick, Sean Turner, Alexey Melnikov, Kathleen Moriarty, Fred Knight, Mike Christie, Qiang Wang, Shiv Rajpal, and Andy Banta.",
      "zh-cn": "The authors gratefully acknowledge the valuable feedback during the Last Call review process from a number of individuals; their feedback significantly improved this document. The individuals were Stephen Farrell, Brian Haberman, Barry Leiba, Pete Resnick, Sean Turner, Alexey Melnikov, Kathleen Moriarty, Fred Knight, Mike Christie, Qiang Wang, Shiv Rajpal, and Andy Banta."
    },
    {
      "indent": 3,
      "text": "Finally, this document also benefited from significant review contributions from the Storm Working Group at large.",
      "zh-cn": "Finally, this document also benefited from significant review contributions from the Storm Working Group at large."
    },
    {
      "indent": 3,
      "text": "Comments may be sent to Mallikarjun Chadalapaka.",
      "zh-cn": "Comments may be sent to Mallikarjun Chadalapaka."
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-cn": "Authors' Addresses"
    },
    {
      "indent": 3,
      "text": "Mallikarjun Chadalapaka Microsoft One Microsoft Way Redmond, WA 98052 USA",
      "zh-cn": "Mallikarjun Chadalapaka Microsoft One Microsoft Way Redmond, WA 98052 USA"
    },
    {
      "indent": 3,
      "text": "EMail: cbm@chadalapaka.com",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Julian Satran Infinidat Ltd.",
      "zh-cn": "Julian Satran Infinidat Ltd."
    },
    {
      "indent": 3,
      "text": "EMail: julians@infinidat.com, julian@satran.net",
      "raw": true,
      "zh-cn": ""
    },
    {
      "indent": 3,
      "text": "Kalman Meth IBM Haifa Research Lab Haifa University Campus - Mount Carmel Haifa 31905, Israel",
      "zh-cn": "Kalman Meth IBM Haifa Research Lab Haifa University Campus - Mount Carmel Haifa 31905, Israel"
    },
    {
      "indent": 3,
      "text": "Phone +972.4.829.6341 EMail: meth@il.ibm.com",
      "zh-cn": "Phone +972.4.829.6341 EMail: meth@il.ibm.com"
    },
    {
      "indent": 3,
      "text": "David L. Black EMC Corporation 176 South St. Hopkinton, MA 01748 USA",
      "zh-cn": "David L. Black EMC Corporation 176 South St. Hopkinton, MA 01748 USA"
    },
    {
      "indent": 3,
      "text": "Phone +1 (508) 293-7953 EMail: david.black@emc.com",
      "zh-cn": "Phone +1 (508) 293-7953 EMail: david.black@emc.com"
    }
  ]
}