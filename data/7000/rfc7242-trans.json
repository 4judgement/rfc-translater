{
  "title": {
    "text": "RFC 7242 - Delay-Tolerant Networking TCP Convergence-Layer Protocol",
    "ja": "RFC 7242 - 遅延耐性ネットワーキングTCPコンバージェンスレイヤープロトコル"
  },
  "number": 7242,
  "created_at": "2020-09-03 19:05:02.745820+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                            M. Demmer\nRequest for Comments: 7242                                   UC Berkeley\nCategory: Experimental                                            J. Ott\nISSN: 2070-1721                                         Aalto University\n                                                            S. Perreault",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 63,
      "text": "June 2014",
      "ja": "2014年6月"
    },
    {
      "indent": 8,
      "text": "Delay-Tolerant Networking TCP Convergence-Layer Protocol",
      "ja": "遅延耐性ネットワーキングTCPコンバージェンスレイヤープロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the protocol for the TCP-based convergence layer for Delay-Tolerant Networking (DTN). It is the product of the IRTF's DTN Research Group (DTNRG).",
      "ja": "このドキュメントでは、Delay-Tolerant Networking（DTN）のTCPベースのコンバージェンスレイヤーのプロトコルについて説明します。これはIRTFのDTN Research Group（DTNRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Delay-Tolerant Networking Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。この文書は、Internet Research Task Force（IRTF）の製品です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適さない可能性があります。このRFCは、インターネット研究タスクフォース（IRTF）の遅延耐性ネットワーキング研究グループの合意を表します。 IRSGによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補にもなりません。 RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7242.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7242で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2014 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Definitions .....................................................4\n   2.1. Definitions Specific to the TCPCL Protocol .................4\n3. General Protocol Description ....................................5\n   3.1. Bidirectional Use of TCP Connection ........................6\n   3.2. Example Message Exchange ...................................6\n4. Connection Establishment ........................................7\n   4.1. Contact Header .............................................8\n   4.2. Validation and Parameter Negotiation ......................10\n5. Established Connection Operation ...............................11\n   5.1. Message Type Codes ........................................11\n   5.2. Bundle Data Transmission (DATA_SEGMENT) ...................12\n   5.3. Bundle Acknowledgments (ACK_SEGMENT) ......................13\n   5.4. Bundle Refusal (REFUSE_BUNDLE) ............................14\n   5.5. Bundle Length (LENGTH) ....................................15\n   5.6. KEEPALIVE Feature (KEEPALIVE) .............................16\n6. Connection Termination .........................................17\n   6.1. Shutdown Message (SHUTDOWN) ...............................17\n   6.2. Idle Connection Shutdown ..................................18\n7. Security Considerations ........................................19\n8. IANA Considerations ............................................20\n   8.1. Port Number ...............................................20\n   8.2. Protocol Versions .........................................20\n   8.3. Message Types .............................................20\n   8.4. REFUSE_BUNDLE Reason Codes ................................21\n   8.5. SHUTDOWN Reason Codes .....................................21\n9. Acknowledgments ................................................21\n10. References ....................................................21\n   10.1. Normative References .....................................21\n   10.2. Informative References ...................................21",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the TCP-based convergence-layer protocol for Delay-Tolerant Networking. Delay-Tolerant Networking is an end-to-end architecture providing communications in and/or through highly stressed environments, including those with intermittent connectivity, long and/or variable delays, and high bit error rates. More detailed descriptions of the rationale and capabilities of these networks can be found in \"Delay-Tolerant Network Architecture\" [RFC4838].",
      "ja": "このドキュメントでは、遅延許容ネットワーク用のTCPベースのコンバージェンスレイヤープロトコルについて説明します。遅延耐性ネットワーキングは、断続的な接続、長い遅延や可変遅延、高いビットエラーレートなど、非常に負荷の高い環境での通信を提供するエンドツーエンドのアーキテクチャです。これらのネットワークの理論的根拠と機能の詳細については、「遅延許容ネットワークアーキテクチャ」[RFC4838]を参照してください。"
    },
    {
      "indent": 0,
      "text": " An important goal of the DTN architecture is to accommodate a wide range of networking technologies and environments. The protocol used for DTN communications is the Bundle Protocol (BP) [RFC5050], an application-layer protocol that is used to construct a store-and- forward overlay network. As described in the Bundle Protocol specification [RFC5050], it requires the services of a \"convergence-layer adapter\" (CLA) to send and receive bundles using the service of some \"native\" link, network, or Internet protocol. This document describes one such convergence-layer adapter that uses the well-known Transmission Control Protocol (TCP). This convergence layer is referred to as TCPCL.",
      "ja": "DTNアーキテクチャの重要な目標は、幅広いネットワーキングテクノロジーと環境に対応することです。 DTN通信に使用されるプロトコルは、ストアアンドフォワードオーバーレイネットワークの構築に使用されるアプリケーション層プロトコルであるバンドルプロトコル（BP）[RFC5050]です。バンドルプロトコル仕様[RFC5050]で説明されているように、「ネイティブ」リンク、ネットワーク、またはインターネットプロトコルのサービスを使用してバンドルを送受信するには、「コンバージェンスレイヤーアダプター」（CLA）のサービスが必要です。このドキュメントでは、よく知られた伝送制御プロトコル（TCP）を使用するそのようなコンバージェンスレイヤーアダプターについて説明します。この収束層はTCPCLと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The locations of the TCPCL and the BP in the Internet model protocol stack are shown in Figure 1. In particular, when BP is using TCP as its bearer with TCPCL as its convergence layer, both BP and TCPCL reside at the application layer of the Internet model.",
      "ja": "インターネットモデルプロトコルスタックにおけるTCPCLとBPの場所を図1に示します。特に、BPがTCPをベアラーとして使用し、TCPCLをコンバージェンスレイヤーとして使用している場合、BPとTCPCLの両方がインターネットのアプリケーションレイヤーに存在します。モデル。"
    },
    {
      "indent": 6,
      "text": "+-------------------------+\n|     DTN Application     | -\\\n+-------------------------|   |\n|  Bundle Protocol (BP)   |   -> Application Layer\n+-------------------------+   |\n| TCP Conv. Layer (TCPCL) | -/\n+-------------------------+\n|          TCP            | ---> Transport Layer\n+-------------------------+\n|           IP            | ---> Network Layer\n+-------------------------+\n|   Link-Layer Protocol   | ---> Link Layer\n+-------------------------+\n|    Physical Medium      | ---> Physical Layer\n+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 1: The Locations of the Bundle Protocol and the TCP Convergence-Layer Protocol in the Internet Protocol Stack",
      "ja": "図1：インターネットプロトコルスタック内のバンドルプロトコルとTCPコンバージェンスレイヤープロトコルの場所"
    },
    {
      "indent": 3,
      "text": "This document describes the format of the protocol data units passed between entities participating in TCPCL communications. This document does not address:",
      "ja": "このドキュメントでは、TCPCL通信に参加しているエンティティ間で渡されるプロトコルデータユニットの形式について説明します。このドキュメントでは、以下については扱いません。"
    },
    {
      "indent": 3,
      "text": "o The format of protocol data units of the Bundle Protocol, as those are defined elsewhere [RFC5050].",
      "ja": "o バンドルプロトコルのプロトコルデータユニットの形式。これらは他の場所で定義されています[RFC5050]。"
    },
    {
      "indent": 3,
      "text": "o Mechanisms for locating or identifying other bundle nodes within an internet.",
      "ja": "o インターネット内の他のバンドルノードを検索または識別するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "Note that this document describes version 3 of the protocol. Versions 0, 1, and 2 were never specified in an Internet-Draft, RFC, or any other public document. These prior versions of the protocol were, however, implemented in the DTN reference implementation [DTNIMPL] in prior releases; hence, the current version number reflects the existence of those prior versions.",
      "ja": "このドキュメントでは、プロトコルのバージョン3について説明しています。バージョン0、1、および2は、Internet-Draft、RFC、またはその他の公開ドキュメントでは指定されていません。ただし、これらのプロトコルの以前のバージョンは、以前のリリースのDTNリファレンス実装[DTNIMPL]に実装されていました。したがって、現在のバージョン番号は、それらの以前のバージョンの存在を反映しています。"
    },
    {
      "indent": 3,
      "text": "This is an experimental protocol produced within the IRTF's Delay-Tolerant Networking Research Group (DTNRG). It represents the consensus of all active contributors to this group. If this protocol is used on the Internet, IETF standard protocols for security and congestion control should be used.",
      "ja": "これは、IRTFのDelay-Tolerant Networking Research Group（DTNRG）内で作成された実験的なプロトコルです。これは、このグループへのすべてのアクティブな貢献者のコンセンサスを表しています。このプロトコルをインターネットで使用する場合は、セキュリティと輻輳制御のためのIETF標準プロトコルを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The terms defined in Section 3.1 of [RFC5050] are used extensively in this document.",
      "ja": "[RFC5050]のセクション3.1で定義されている用語は、このドキュメントで広く使用されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions Specific to the TCPCL Protocol",
      "section_title": true,
      "ja": "2.1. TCPCLプロトコルに固有の定義"
    },
    {
      "indent": 3,
      "text": "This section contains definitions that are interpreted to be specific to the operation of the TCPCL protocol, as described below.",
      "ja": "このセクションには、以下で説明するように、TCPCLプロトコルの操作に固有であると解釈される定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "TCP Connection -- A TCP connection refers to a transport connection using TCP as the transport protocol.",
      "ja": "TCP接続-TCP接続とは、トランスポートプロトコルとしてTCPを使用するトランスポート接続を指します。"
    },
    {
      "indent": 3,
      "text": "TCPCL Connection -- A TCPCL connection (as opposed to a TCP connection) is a TCPCL communication relationship between two bundle nodes. The lifetime of a TCPCL connection is bound to the lifetime of an underlying TCP connection. Therefore, a TCPCL connection is initiated when a bundle node initiates a TCP connection to be established for the purposes of bundle communication. A TCPCL connection is terminated when the TCP connection ends, due either to one or both nodes actively terminating the TCP connection or due to network errors causing a failure of the TCP connection. For the remainder of this document, the term \"connection\" without the prefix \"TCPCL\" shall refer to a TCPCL connection.",
      "ja": "TCPCL接続-（TCP接続ではなく）TCPCL接続は、2つのバンドルノード間のTCPCL通信関係です。 TCPCL接続の存続期間は、基礎となるTCP接続の存続期間にバインドされます。したがって、TCPCL接続は、バンドルノードがTCP接続を開始してバンドル通信の目的で確立されるときに開始されます。 TCPCL接続は、TCP接続が終了すると、1つまたは両方のノードがTCP接続をアクティブに終了したか、ネットワークエラーが原因でTCP接続に障害が発生したために終了します。このドキュメントの残りの部分では、接頭辞「TCPCL」のない「接続」という用語は、TCPCL接続を指します。"
    },
    {
      "indent": 3,
      "text": "Connection parameters -- The connection parameters are a set of values used to affect the operation of the TCPCL for a given connection. The manner in which these parameters are conveyed to the bundle node and thereby to the TCPCL is implementation dependent. However, the mechanism by which two bundle nodes exchange and negotiate the values to be used for a given session is described in Section 4.2.",
      "ja": "接続パラメーター-接続パラメーターは、特定の接続のTCPCLの操作に影響を与えるために使用される値のセットです。これらのパラメータがバンドルノードに伝達され、それによってTCPCLに伝達される方法は、実装に依存します。ただし、2つのバンドルノードが特定のセッションに使用される値を交換およびネゴシエートするメカニズムについては、セクション4.2で説明しています。"
    },
    {
      "indent": 3,
      "text": "Transmission -- Transmission refers to the procedures and mechanisms (described below) for conveyance of a bundle from one node to another.",
      "ja": "伝送-伝送とは、あるノードから別のノードにバンドルを伝送するための手順とメカニズム（以下で説明）を指します。"
    },
    {
      "indent": 0,
      "text": "3. General Protocol Description",
      "section_title": true,
      "ja": "3. 一般的なプロトコルの説明"
    },
    {
      "indent": 3,
      "text": "The service of this protocol is the transmission of DTN bundles over TCP. This document specifies the encapsulation of bundles, procedures for TCP setup and teardown, and a set of messages and node requirements. The general operation of the protocol is as follows.",
      "ja": "このプロトコルのサービスは、TCPを介したDTNバンドルの送信です。このドキュメントでは、バンドルのカプセル化、TCPのセットアップとティアダウンの手順、および一連のメッセージとノードの要件について説明します。プロトコルの一般的な操作は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "First, one node establishes a TCPCL connection to the other by initiating a TCP connection. After setup of the TCP connection is complete, an initial contact header is exchanged in both directions to set parameters of the TCPCL connection and exchange a singleton endpoint identifier for each node (not the singleton Endpoint Identifier (EID) of any application running on the node) to denote the bundle-layer identity of each DTN node. This is used to assist in routing and forwarding messages, e.g., to prevent loops.",
      "ja": "最初に、1つのノードがTCP接続を開始することにより、他のノードへのTCPCL接続を確立します。 TCP接続のセットアップが完了すると、最初の連絡先ヘッダーが両方向で交換され、TCPCL接続のパラメーターが設定され、各ノードのシングルトンエンドポイント識別子（ノードで実行されているアプリケーションのシングルトンエンドポイント識別子（EID）ではない）が交換されます）各DTNノードのバンドル層IDを示します。これは、たとえばループを防ぐために、メッセージのルーティングと転送を支援するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Once the TCPCL connection is established and configured in this way, bundles can be transmitted in either direction. Each bundle is transmitted in one or more logical segments of formatted bundle data. Each logical data segment consists of a DATA_SEGMENT message header, a Self-Delimiting Numeric Value (SDNV) as defined in [RFC5050] (see also [RFC6256]) containing the length of the segment, and finally the byte range of the bundle data. The choice of the length to use for segments is an implementation matter. The first segment for a bundle must set the 'start' flag, and the last one must set the 'end' flag in the DATA_SEGMENT message header.",
      "ja": "このようにTCPCL接続が確立および設定されると、バンドルはどちらの方向にも送信できます。各バンドルは、フォーマットされたバンドルデータの1つ以上の論理セグメントで送信されます。各論理データセグメントは、DATA_SEGMENTメッセージヘッダー、[RFC5050]（[RFC6256]も参照）で定義されているセルフデリミタリング数値（SDNV）で構成され、最後にバンドルデータのバイト範囲が含まれます。セグメントに使用する長さの選択は実装の問題です。バンドルの最初のセグメントは「開始」フラグを設定する必要があり、最後のセグメントはDATA_SEGMENTメッセージヘッダーの「終了」フラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple bundles are transmitted on a single TCPCL connection, they MUST be transmitted consecutively. Interleaving data segments from different bundles is not allowed. Bundle interleaving can be accomplished by fragmentation at the BP layer.",
      "ja": "複数のバンドルが単一のTCPCL接続で送信される場合、それらは連続して送信される必要があります。異なるバンドルのデータセグメントをインターリーブすることはできません。バンドルインターリーブは、BPレイヤーでの断片化によって実現できます。"
    },
    {
      "indent": 3,
      "text": "An optional feature of the protocol is for the receiving node to send acknowledgments as bundle data segments arrive (ACK_SEGMENT). The rationale behind these acknowledgments is to enable the sender node to determine how much of the bundle has been received, so that in case the connection is interrupted, it can perform reactive fragmentation to avoid re-sending the already transmitted part of the bundle.",
      "ja": "プロトコルのオプション機能は、バンドルデータセグメントが到着したときに受信ノードが確認応答を送信することです（ACK_SEGMENT）。これらの確認応答の背後にある理論的根拠は、送信ノードが受信したバンドルの量を判別できるようにすることです。これにより、接続が中断された場合に、すでに送信されたバンドルの部分を再送信しないようにリアクティブフラグメンテーションを実行できます。"
    },
    {
      "indent": 3,
      "text": "When acknowledgments are enabled, then for each data segment that is received, the receiving node sends an ACK_SEGMENT code followed by an SDNV containing the cumulative length of the bundle that has been received. The sending node may transmit multiple DATA_SEGMENT messages without necessarily waiting for the corresponding ACK_SEGMENT responses. This enables pipelining of messages on a channel. In addition, there is no explicit flow control on the TCPCL layer.",
      "ja": "確認応答が有効になっている場合、受信ノードは受信した各データセグメントに対してACK_SEGMENTコードを送信し、その後に受信したバンドルの累積長を含むSDNVが送信されます。送信ノードは、対応するACK_SEGMENT応答を必ずしも待機することなく、複数のDATA_SEGMENTメッセージを送信できます。これにより、チャネル上のメッセージのパイプライン化が可能になります。さらに、TCPCL層には明示的なフロー制御はありません。"
    },
    {
      "indent": 3,
      "text": "Another optional feature is that a receiver may interrupt the transmission of a bundle at any point in time by replying with a REFUSE_BUNDLE message, which causes the sender to stop transmission of the current bundle, after completing transmission of a partially sent data segment. Note: This enables a cross-layer optimization in that it allows a receiver that detects that it already has received a certain bundle to interrupt transmission as early as possible and thus save transmission capacity for other bundles.",
      "ja": "別のオプション機能は、受信者がREFUSE_BUNDLEメッセージで応答することにより、バンドルの送信をいつでも中断できることです。これにより、送信者は、部分的に送信されたデータセグメントの送信を完了した後、現在のバンドルの送信を停止します。注：これにより、特定のバンドルを既に受信したことを検出したレシーバーが送信をできるだけ早く中断して、他のバンドルの送信容量を節約できるという点で、クロスレイヤー最適化が可能になります。"
    },
    {
      "indent": 3,
      "text": "For connections that are idle, a KEEPALIVE message may optionally be sent at a negotiated interval. This is used to convey liveness information.",
      "ja": "アイドル状態の接続の場合、オプションで、ネゴシエートされた間隔でKEEPALIVEメッセージを送信できます。これは、生存情報を伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Finally, before connections close, a SHUTDOWN message is sent on the channel. After sending a SHUTDOWN message, the sender of this message may send further acknowledgments (ACK_SEGMENT or REFUSE_BUNDLE) but no further data messages (DATA_SEGMENT). A SHUTDOWN message may also be used to refuse a connection setup by a peer.",
      "ja": "最後に、接続が閉じる前に、チャネルでSHUTDOWNメッセージが送信されます。 SHUTDOWNメッセージを送信した後、このメッセージの送信者は追加の確認応答（ACK_SEGMENTまたはREFUSE_BUNDLE）を送信できますが、それ以上のデータメッセージ（DATA_SEGMENT）は送信できません。 SHUTDOWNメッセージを使用して、ピアによる接続セットアップを拒否することもできます。"
    },
    {
      "indent": 0,
      "text": "3.1. Bidirectional Use of TCP Connection",
      "section_title": true,
      "ja": "3.1. TCP接続の双方向使用"
    },
    {
      "indent": 3,
      "text": "There are specific messages for sending and receiving operations (in addition to connection setup/teardown). TCPCL is symmetric, i.e., both sides can start sending data segments in a connection, and one side's bundle transfer does not have to complete before the other side can start sending data segments on its own. Hence, the protocol allows for a bi-directional mode of communication.",
      "ja": "（接続のセットアップ/ティアダウンに加えて）送受信の操作に関する特定のメッセージがあります。 TCPCLは対称的です。つまり、両方の側が接続でデータセグメントの送信を開始できます。一方の側のバンドル転送は、もう一方の側が独自にデータセグメントの送信を開始する前に完了する必要はありません。したがって、このプロトコルは双方向通信モードを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note that in the case of concurrent bidirectional transmission, acknowledgment segments may be interleaved with data segments.",
      "ja": "同時双方向送信の場合、確認応答セグメントはデータセグメントとインターリーブされることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2. Example Message Exchange",
      "section_title": true,
      "ja": "3.2. メッセージ交換の例"
    },
    {
      "indent": 3,
      "text": "The following figure visually depicts the protocol exchange for a simple session, showing the connection establishment and the transmission of a single bundle split into three data segments (of lengths L1, L2, and L3) from Node A to Node B.",
      "ja": "次の図は、単純なセッションのプロトコル交換を視覚的に表しており、接続の確立と、ノードAからノードBへの3つのデータセグメント（長さL1、L2、およびL3）に分割された単一バンドルの送信を示しています。"
    },
    {
      "indent": 0,
      "text": " Note that the sending node may transmit multiple DATA_SEGMENT messages without necessarily waiting for the corresponding ACK_SEGMENT responses. This enables pipelining of messages on a channel. Although this example only demonstrates a single bundle transmission, it is also possible to pipeline multiple DATA_SEGMENT messages for different bundles without necessarily waiting for ACK_SEGMENT messages to be returned for each one. However, interleaving data segments from different bundles is not allowed.",
      "ja": "送信ノードは、対応するACK_SEGMENT応答を必ずしも待機することなく、複数のDATA_SEGMENTメッセージを送信する場合があることに注意してください。これにより、チャネル上のメッセージのパイプライン化が可能になります。この例では単一のバンドル送信のみを示していますが、ACK_SEGMENTメッセージが返されるのを必ずしも待たずに、異なるバンドルの複数のDATA_SEGMENTメッセージをパイプライン処理することもできます。ただし、異なるバンドルのデータセグメントをインターリーブすることはできません。"
    },
    {
      "indent": 3,
      "text": "No errors or rejections are shown in this example.",
      "ja": "この例では、エラーや拒否は示されていません。"
    },
    {
      "indent": 18,
      "text": "Node A                              Node B\n======                              ======",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "+-------------------------+         +-------------------------+\n|     Contact Header      | ->   <- |     Contact Header      |\n+-------------------------+         +-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "+-------------------------+\n|   DATA_SEGMENT (start)  | ->\n|    SDNV length [L1]     | ->\n|  Bundle Data 0..(L1-1)  | ->\n+-------------------------+\n+-------------------------+         +-------------------------+\n|     DATA_SEGMENT        | ->   <- |       ACK_SEGMENT       |\n|    SDNV length [L2]     | ->   <- |     SDNV length [L1]    |\n|Bundle Data L1..(L1+L2-1)| ->      +-------------------------+\n+-------------------------+\n+-------------------------+         +-------------------------+\n|    DATA_SEGMENT (end)   | ->   <- |       ACK_SEGMENT       |\n|     SDNV length [L3]    | ->   <- |   SDNV length [L1+L2]   |\n|Bundle Data              | ->      +-------------------------+\n|    (L1+L2)..(L1+L2+L3-1)|\n+-------------------------+\n                                    +-------------------------+\n                                 <- |       ACK_SEGMENT       |\n                                 <- |  SDNV length [L1+L2+L3] |\n                                    +-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "+-------------------------+         +-------------------------+\n|       SHUTDOWN          | ->   <- |         SHUTDOWN        |\n+-------------------------+         +-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 2: A Simple Visual Example of the Flow of Protocol Messages on a Single TCP Session between Two Nodes (A and B)",
      "ja": "図2：2つのノード（AとB）間の単一のTCPセッションでのプロトコルメッセージのフローの簡単な視覚的な例"
    },
    {
      "indent": 0,
      "text": "4. Connection Establishment",
      "section_title": true,
      "ja": "4. 接続の確立"
    },
    {
      "indent": 0,
      "text": " For bundle transmissions to occur using the TCPCL, a TCPCL connection must first be established between communicating nodes. It is up to the implementation to decide how and when connection setup is triggered. For example, some connections may be opened proactively and maintained for as long as is possible given the network conditions, while other connections may be opened only when there is a bundle that is queued for transmission and the routing algorithm selects a certain next-hop node.",
      "ja": "TCPCLを使用してバンドル送信を行うには、最初に通信ノード間でTCPCL接続を確立する必要があります。接続セットアップをトリガーする方法とタイミングを決定するのは実装です。たとえば、一部の接続は事前に開かれ、ネットワークの状態を考慮して可能な限り維持されますが、他の接続は、送信のキューに入れられているバンドルがあり、ルーティングアルゴリズムが特定のネクストホップノードを選択する場合にのみ開かれます。"
    },
    {
      "indent": 3,
      "text": "To establish a TCPCL connection, a node must first establish a TCP connection with the intended peer node, typically by using the services provided by the operating system. Port number 4556 has been assigned by IANA as the well-known port number for the TCP convergence layer. Other port numbers MAY be used per local configuration. Determining a peer's port number (if different from the well-known TCPCL port) is up to the implementation.",
      "ja": "TCPCL接続を確立するには、ノードは最初に、通常はオペレーティングシステムによって提供されるサービスを使用して、目的のピアノードとのTCP接続を確立する必要があります。ポート番号4556は、IANAによってTCPコンバージェンスレイヤーの既知のポート番号として割り当てられています。その他のポート番号は、ローカル構成ごとに使用される場合があります。ピアのポート番号の決定（既知のTCPCLポートと異なる場合）は実装次第です。"
    },
    {
      "indent": 3,
      "text": "If the node is unable to establish a TCP connection for any reason, then it is an implementation matter to determine how to handle the connection failure. A node MAY decide to re-attempt to establish the connection. If it does so, it MUST NOT overwhelm its target with repeated connection attempts. Therefore, the node MUST retry the connection setup only after some delay (a 1-second minimum is RECOMMENDED), and it SHOULD use a (binary) exponential backoff mechanism to increase this delay in case of repeated failures. In case a SHUTDOWN message specifying a reconnection delay is received, that delay is used as the initial delay. The default initial delay SHOULD be at least 1 second but SHOULD be configurable since it will be application and network type dependent.",
      "ja": "ノードが何らかの理由でTCP接続を確立できない場合、接続障害の処理方法を決定することは実装上の問題です。ノードは、接続の確立を再試行することを決定する場合があります。そうする場合、それは繰り返しの接続試行でそのターゲットを圧倒してはいけません。したがって、ノードは一定の遅延（1秒以上が推奨）の後にのみ接続セットアップを再試行する必要があり、障害が繰り返し発生した場合に、この遅延を増やすために（バイナリ）指数バックオフメカニズムを使用する必要があります（SHOULD）。再接続遅延を指定するSHUTDOWNメッセージが受信された場合、その遅延が初期遅延として使用されます。デフォルトの初期遅延は1秒以上である必要があります（SHOULD）が、アプリケーションとネットワークタイプに依存するため、構成可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "The node MAY declare failure after one or more connection attempts and MAY attempt to find an alternate route for bundle data. Such decisions are up to the higher layer (i.e., the BP).",
      "ja": "ノードは、1回以上の接続試行の後に障害を宣言する場合があり、バンドルデータの代替ルートを見つけようとする場合があります（MAY）。このような決定は、上位層（つまり、BP）に委ねられています。"
    },
    {
      "indent": 3,
      "text": "Once a TCP connection is established, each node MUST immediately transmit a contact header over the TCP connection. The format of the contact header is described in Section 4.1.",
      "ja": "TCP接続が確立されると、各ノードはTCP接続を介してコンタクトヘッダーをすぐに送信する必要があります。連絡先ヘッダーの形式については、セクション4.1で説明します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the contact header, both nodes perform the validation and negotiation procedures defined in Section 4.2",
      "ja": "コンタクトヘッダーを受信すると、両方のノードがセクション4.2で定義された検証およびネゴシエーション手順を実行します"
    },
    {
      "indent": 3,
      "text": "After receiving the contact header from the other node, either node MAY also refuse the connection by sending a SHUTDOWN message. If connection setup is refused, a reason MUST be included in the SHUTDOWN message.",
      "ja": "他のノードから連絡先ヘッダーを受信した後、いずれのノードもSHUTDOWNメッセージを送信して接続を拒否する場合があります。接続設定が拒否された場合は、理由をSHUTDOWNメッセージに含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Contact Header",
      "section_title": true,
      "ja": "4.1. 連絡先ヘッダー"
    },
    {
      "indent": 3,
      "text": "Once a TCP connection is established, both parties exchange a contact header. This section describes the format of the contact header and the meaning of its fields.",
      "ja": "TCP接続が確立されると、両者は連絡先ヘッダーを交換します。このセクションでは、連絡先ヘッダーのフォーマットとそのフィールドの意味について説明します。"
    },
    {
      "indent": 3,
      "text": "The format for the Contact Header is as follows:",
      "ja": "連絡先ヘッダーの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|                          magic='dtn!'                         |\n+---------------+---------------+---------------+---------------+\n|     version   |     flags     |      keepalive_interval       |\n+---------------+---------------+---------------+---------------+\n|                     local EID length (SDNV)                   |\n+---------------+---------------+---------------+---------------+\n|                                                               |\n+                      local EID (variable)                     +\n|                                                               |\n+---------------+---------------+---------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: Contact Header Format",
      "ja": "図3：連絡先ヘッダーの形式"
    },
    {
      "indent": 3,
      "text": "The fields of the contact header are:",
      "ja": "連絡先ヘッダーのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "magic: A four-byte field that always contains the byte sequence 0x64 0x74 0x6e 0x21, i.e., the text string \"dtn!\" in US-ASCII.",
      "ja": "マジック：常にバイトシーケンス0x64 0x74 0x6e 0x21を含む4バイトのフィールド、つまり、テキスト文字列「dtn！」 US-ASCII。"
    },
    {
      "indent": 3,
      "text": "version: A one-byte field value containing the value 3 (current version of the protocol).",
      "ja": "version：値3（プロトコルの現在のバージョン）を含む1バイトのフィールド値。"
    },
    {
      "indent": 3,
      "text": "flags: A one-byte field containing optional connection flags. The first four bits are unused and MUST be set to zero upon transmission and MUST be ignored upon reception. The last four bits are interpreted as shown in Table 1 below.",
      "ja": "flags：オプションの接続フラグを含む1バイトのフィールド。最初の4ビットは使用されず、送信時にゼロに設定する必要があり、受信時に無視する必要があります。最後の4ビットは、以下の表1に示すように解釈されます。"
    },
    {
      "indent": 3,
      "text": "keepalive_interval: A two-byte integer field containing the number of seconds between exchanges of KEEPALIVE messages on the connection (see Section 5.6). This value is in network byte order, as are all other multi-byte fields described in this protocol.",
      "ja": "keepalive_interval：接続でのKEEPALIVEメッセージの交換間の秒数を含む2バイトの整数フィールド（セクション5.6を参照）。この値は、このプロトコルで説明されている他のすべてのマルチバイトフィールドと同様に、ネットワークバイト順です。"
    },
    {
      "indent": 3,
      "text": "local EID length: A variable-length SDNV field containing the length of the endpoint identifier (EID) for some singleton endpoint in which the sending node is a member. A four-byte SDNV is depicted for clarity of the figure.",
      "ja": "ローカルEIDの長さ：送信ノードがメンバーであるいくつかのシングルトンエンドポイントのエンドポイント識別子（EID）の長さを含む可変長SDNVフィールド。図をわかりやすくするために、4バイトのSDNVが示されています。"
    },
    {
      "indent": 3,
      "text": "local EID: A byte string containing the EID of some singleton endpoint in which the sending node is a member, in the canonical format of <scheme name>:<scheme-specific part>. An eight-byte EID is shown for clarity of the figure.",
      "ja": "ローカルEID：<scheme name>：<scheme-specific part>の正規形式での、送信ノードがメンバーであるいくつかのシングルトンエンドポイントのEIDを含むバイト文字列。図をわかりやすくするために、8バイトのEIDが示されています。"
    },
    {
      "indent": 3,
      "text": "+----------+--------------------------------------------------------+\n|  Value   | Meaning                                                |\n+----------+--------------------------------------------------------+\n| 00000001 | Request acknowledgment of bundle segments.             |\n| 00000010 | Request enabling of reactive fragmentation.            |\n| 00000100 | Indicate support for bundle refusal.  This flag MUST   |\n|          | NOT be set to '1' unless support for acknowledgments   |\n|          | is also indicated.                                     |\n| 00001000 | Request sending of LENGTH messages.                    |\n+----------+--------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 1: Contact Header Flags",
      "ja": "表1：連絡先ヘッダーフラグ"
    },
    {
      "indent": 3,
      "text": "The manner in which values are configured and chosen for the various flags and parameters in the contact header is implementation dependent.",
      "ja": "連絡先ヘッダーのさまざまなフラグとパラメーターに対して値が構成および選択される方法は、実装に依存します。"
    },
    {
      "indent": 0,
      "text": "4.2. Validation and Parameter Negotiation",
      "section_title": true,
      "ja": "4.2. 検証とパラメータ交渉"
    },
    {
      "indent": 3,
      "text": "Upon reception of the contact header, each node follows the following procedures to ensure the validity of the TCPCL connection and to negotiate values for the connection parameters.",
      "ja": "コンタクトヘッダーを受信すると、各ノードは次の手順に従って、TCPCL接続の有効性を確認し、接続パラメーターの値をネゴシエートします。"
    },
    {
      "indent": 3,
      "text": "If the magic string is not present or is not valid, the connection MUST be terminated. The intent of the magic string is to provide some protection against an inadvertent TCP connection by a different protocol than the one described in this document. To prevent a flood of repeated connections from a misconfigured application, a node MAY elect to hold an invalid connection open and idle for some time before closing it.",
      "ja": "マジックストリングが存在しないか有効でない場合は、接続を終了する必要があります。マジックストリングの目的は、このドキュメントで説明されているプロトコルとは異なるプロトコルによる不注意なTCP接続からの保護を提供することです。誤って設定されたアプリケーションからの繰り返し接続のフラッドを防ぐために、ノードは無効な接続を開いたままにして、閉じる前にアイドル状態にすることを選択できます。"
    },
    {
      "indent": 3,
      "text": "If a node receives a contact header containing a version that is greater than the current version of the protocol that the node implements, then the node SHOULD interpret all fields and messages as it would normally. If a node receives a contact header with a version that is lower than the version of the protocol that the node implements, the node may either terminate the connection due to the version mismatch or may adapt its operation to conform to the older version of the protocol. This decision is an implementation matter.",
      "ja": "ノードがノードが実装するプロトコルの現在のバージョンより大きいバージョンを含む連絡先ヘッダーを受信する場合、ノードは通常どおりにすべてのフィールドとメッセージを解釈する必要があります（SHOULD）。ノードが実装するプロトコルのバージョンよりも低いバージョンの連絡先ヘッダーをノードが受信した場合、ノードはバージョンの不一致が原因で接続を終了するか、古いバージョンのプロトコルに準拠するように操作を適応させることができます。この決定は実装の問題です。"
    },
    {
      "indent": 0,
      "text": " A node calculates the parameters for a TCPCL connection by negotiating the values from its own preferences (conveyed by the contact header it sent) with the preferences of the peer node (expressed in the contact header that it received). This negotiation MUST proceed in the following manner: o The parameter for requesting acknowledgment of bundle segments is set to true iff the corresponding flag is set in both contact headers.",
      "ja": "ノードは、TCPCL接続のパラメーターを計算します（送信した連絡先ヘッダーによって伝達される）独自の設定の値を、ピアノードの設定（受信した連絡先ヘッダーで表される）とネゴシエートします。このネゴシエーションは、次の方法で進行する必要があります。oバンドルセグメントの確認応答を要求するためのパラメーターは、対応するフラグが両方の連絡先ヘッダーに設定されている場合にtrueに設定されます。"
    },
    {
      "indent": 3,
      "text": "o The parameter for enabling reactive fragmentation is set to true iff the corresponding flag is set in both contact headers.",
      "ja": "o 対応するフラグが両方のコンタクトヘッダーで設定されている場合、リアクティブフラグメンテーションを有効にするためのパラメーターはtrueに設定されます。"
    },
    {
      "indent": 3,
      "text": "o The bundle refusal capability is set to true if the corresponding flag is set in both contact headers and if segment acknowledgment has been enabled.",
      "ja": "o バンドルの拒否機能は、対応するフラグが両方の連絡先ヘッダーで設定され、セグメントの確認応答が有効になっている場合、trueに設定されます。"
    },
    {
      "indent": 3,
      "text": "o The keepalive_interval parameter is set to the minimum value from both contact headers. If one or both contact headers contains the value zero, then the keepalive feature (described in Section 5.6) is disabled.",
      "ja": "o keepalive_intervalパラメーターは、両方の連絡先ヘッダーの最小値に設定されます。 1つまたは両方の連絡先ヘッダーに値0が含まれている場合、キープアライブ機能（セクション5.6で説明）は無効になります。"
    },
    {
      "indent": 3,
      "text": "o The flag requesting sending of LENGTH messages is handled as described in Section 5.5.",
      "ja": "o LENGTHメッセージの送信を要求するフラグは、セクション5.5で説明されているように処理されます。"
    },
    {
      "indent": 3,
      "text": "Once this process of parameter negotiation is completed, the protocol defines no additional mechanism to change the parameters of an established connection; to effect such a change, the connection MUST be terminated and a new connection established.",
      "ja": "このパラメータネゴシエーションのプロセスが完了すると、プロトコルは確立された接続のパラメータを変更するための追加のメカニズムを定義しません。このような変更を行うには、接続を終了し、新しい接続を確立する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Established Connection Operation",
      "section_title": true,
      "ja": "5. 確立された接続操作"
    },
    {
      "indent": 3,
      "text": "This section describes the protocol operation for the duration of an established connection, including the mechanisms for transmitting bundles over the connection.",
      "ja": "このセクションでは、接続を介してバンドルを送信するメカニズムを含め、確立された接続の期間中のプロトコル操作について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Message Type Codes",
      "section_title": true,
      "ja": "5.1. メッセージタイプコード"
    },
    {
      "indent": 3,
      "text": "After the initial exchange of a contact header, all messages transmitted over the connection are identified by a one-byte header with the following structure:",
      "ja": "連絡先ヘッダーの最初の交換後、接続を介して送信されるすべてのメッセージは、次の構造を持つ1バイトのヘッダーによって識別されます。"
    },
    {
      "indent": 28,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| type  | flags |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 4: Format of the One-Byte Message Header",
      "ja": "図4：1バイトメッセージヘッダーのフォーマット"
    },
    {
      "indent": 3,
      "text": "type: Indicates the type of the message as per Table 2 below",
      "ja": "type：以下の表2に従ってメッセージのタイプを示します"
    },
    {
      "indent": 3,
      "text": "flags: Optional flags defined based on message type.",
      "ja": "flags：メッセージタイプに基づいて定義されたオプションのフラグ。"
    },
    {
      "indent": 3,
      "text": "The types and values for the message type code are as follows.",
      "ja": "メッセージ種別コードの種別と値は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "+----------------+---------+----------------------------------------+\n|      Type      | Code    | Description                            |\n+----------------+---------+----------------------------------------+\n|                | 0x0     | Reserved.                              |\n|                |         |                                        |\n|  DATA_SEGMENT  | 0x1     | Indicates the transmission of a        |\n|                |         | segment of bundle data, as described   |\n|                |         | in Section 5.2.                        |\n|                |         |                                        |\n|  ACK_SEGMENT   | 0x2     | Acknowledges reception of a data       |\n|                |         | segment, as described in Section 5.3   |\n|                |         |                                        |\n| REFUSE_BUNDLE  | 0x3     | Indicates that the transmission of the |\n|                |         | current bundle shall be stopped, as    |\n|                |         | described in Section 5.4.              |\n|                |         |                                        |\n|   KEEPALIVE    | 0x4     | KEEPALIVE message for the connection,  |\n|                |         | as described in Section 5.6.           |\n|                |         |                                        |\n|    SHUTDOWN    | 0x5     | Indicates that one of the nodes        |\n|                |         | participating in the connection wishes |\n|                |         | to cleanly terminate the connection,   |\n|                |         | as described in Section 6.             |\n|                |         |                                        |\n|     LENGTH     | 0x6     | Contains the length (in bytes) of the  |\n|                |         | next bundle, as described in Section   |\n|                |         | 5.5.                                   |\n|                |         |                                        |\n|                | 0x7-0xf | Unassigned.                            |\n|                |         |                                        |\n+----------------+---------+----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 2: TCPCL Message Types",
      "ja": "表2：TCPCLメッセージタイプ"
    },
    {
      "indent": 0,
      "text": "5.2. Bundle Data Transmission (DATA_SEGMENT)",
      "section_title": true,
      "ja": "5.2. バンドルデータ送信（DATA_SEGMENT）"
    },
    {
      "indent": 3,
      "text": "Each bundle is transmitted in one or more data segments. The format of a DATA_SEGMENT message follows:",
      "ja": "各バンドルは、1つ以上のデータセグメントで送信されます。 DATA_SEGMENTメッセージの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x1  |0|0|S|E|   length ...    |  contents....               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 5: Format of DATA_SEGMENT Messages",
      "ja": "図5：DATA_SEGMENTメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "The type portion of the message header contains the value 0x1.",
      "ja": "メッセージヘッダーのタイプ部分には、値0x1が含まれています。"
    },
    {
      "indent": 3,
      "text": "The flags portion of the message header byte contains two optional values in the two low-order bits, denoted 'S' and 'E' above. The 'S' bit MUST be set to one if it precedes the transmission of the first segment of a new bundle. The 'E' bit MUST be set to one when transmitting the last segment of a bundle.",
      "ja": "メッセージヘッダーバイトのフラグ部分には、上記の「S」と「E」で示される2つの下位ビットに2つのオプション値が含まれています。新しいバンドルの最初のセグメントの送信に先行する場合、「S」ビットを1に設定する必要があります。バンドルの最後のセグメントを送信するときは、「E」ビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Following the message header, the length field is an SDNV containing the number of bytes of bundle data that are transmitted in this segment. Following this length is the actual data contents.",
      "ja": "メッセージヘッダーに続く長さフィールドは、このセグメントで送信されるバンドルデータのバイト数を含むSDNVです。この長さの後に、実際のデータの内容が続きます。"
    },
    {
      "indent": 3,
      "text": "Determining the size of the segment is an implementation matter. In particular, a node may, based on local policy or configuration, only ever transmit bundle data in a single segment, in which case both the 'S' and 'E' bits MUST be set to one.",
      "ja": "セグメントのサイズを決定することは実装の問題です。特に、ノードはローカルポリシーまたは設定に基づいて、バンドルデータを単一のセグメントでのみ送信する場合があります。その場合、「S」ビットと「E」ビットの両方を1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the Bundle Protocol specification [RFC5050], a single bundle comprises a primary bundle block, a payload block, and zero or more additional bundle blocks. The relationship between the protocol blocks and the convergence-layer segments is an implementation-specific decision. In particular, a segment MAY contain more than one protocol block; alternatively, a single protocol block (such as the payload) MAY be split into multiple segments.",
      "ja": "Bundle Protocol仕様[RFC5050]では、単一のバンドルは、プライマリバンドルブロック、ペイロードブロック、および0個以上の追加のバンドルブロックで構成されています。プロトコルブロックとコンバージェンスレイヤーセグメントの関係は、実装固有の決定事項です。特に、セグメントには複数のプロトコルブロックが含まれる場合があります。あるいは、単一のプロトコルブロック（ペイロードなど）を複数のセグメントに分割してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "However, a single segment MUST NOT contain data of more than a single bundle.",
      "ja": "ただし、単一のセグメントに複数のバンドルのデータを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "Once a transmission of a bundle has commenced, the node MUST only send segments containing sequential portions of that bundle until it sends a segment with the 'E' bit set.",
      "ja": "バンドルの送信が開始されると、ノードは、「E」ビットが設定されたセグメントを送信するまで、そのバンドルの連続した部分を含むセグメントのみを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Bundle Acknowledgments (ACK_SEGMENT)",
      "section_title": true,
      "ja": "5.3. バンドル確認（ACK_SEGMENT）"
    },
    {
      "indent": 3,
      "text": "Although the TCP transport provides reliable transfer of data between transport peers, the typical BSD sockets interface provides no means to inform a sending application of when the receiving application has processed some amount of transmitted data. Thus, after transmitting some data, a Bundle Protocol agent needs an additional mechanism to determine whether the receiving agent has successfully received the segment.",
      "ja": "TCPトランスポートはトランスポートピア間で信頼性の高いデータ転送を提供しますが、典型的なBSDソケットインターフェイスは、受信アプリケーションが送信データの一部を処理したときに送信アプリケーションに通知する手段を提供しません。したがって、一部のデータを送信した後、バンドルプロトコルエージェントは、受信エージェントがセグメントを正常に受信したかどうかを判断するための追加のメカニズムを必要とします。"
    },
    {
      "indent": 3,
      "text": "To this end, the TCPCL protocol offers an optional feature whereby a receiving node transmits acknowledgments of reception of data segments. This feature is enabled if, and only if, during the exchange of contact headers, both parties set the flag to indicate that segment acknowledgments are enabled (see Section 4.1). If so, then the receiver MUST transmit a bundle acknowledgment message when it successfully receives each data segment.",
      "ja": "この目的のために、TCPCLプロトコルは、受信ノードがデータセグメントの受信の確認を送信するオプション機能を提供します。この機能は、連絡先ヘッダーの交換中に、両方の当事者がフラグを設定して、セグメントの確認応答が有効であることを示す場合にのみ有効になります（セクション4.1を参照）。そうである場合、受信者は各データセグメントを正常に受信したときに、バンドル確認メッセージを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The format of a bundle acknowledgment is as follows:",
      "ja": "バンドル確認の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x2  |0|0|0|0|   acknowledged length ...                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 6: Format of ACK_SEGMENT Messages",
      "ja": "図6：ACK_SEGMENTメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "To transmit an acknowledgment, a node first transmits a message header with the ACK_SEGMENT type code and all flags set to zero, then transmits an SDNV containing the cumulative length in bytes of the received segment(s) of the current bundle. The length MUST fall on a segment boundary. That is, only full segments can be acknowledged.",
      "ja": "確認応答を送信するには、ノードはまずACK_SEGMENTタイプのコードとすべてのフラグをゼロに設定してメッセージヘッダーを送信し、次に現在のバンドルの受信セグメントのバイト単位での累積長を含むSDNVを送信します。長さはセグメント境界に収まる必要があります。つまり、完全なセグメントのみを確認できます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the sending node transmits four segments of bundle data with lengths 100, 200, 500, and 1000, respectively. After receiving the first segment, the node sends an acknowledgment of length 100. After the second segment is received, the node sends an acknowledgment of length 300. The third and fourth acknowledgments are of length 800 and 1800, respectively.",
      "ja": "たとえば、送信ノードがそれぞれ長さ100、200、500、1000のバンドルデータの4つのセグメントを送信するとします。最初のセグメントを受信した後、ノードは長さ100の確認応答を送信します。2番目のセグメントを受信した後、ノードは長さ300の確認応答を送信します。3番目と4番目の確認応答はそれぞれ長さ800と1800です。"
    },
    {
      "indent": 0,
      "text": "5.4. Bundle Refusal (REFUSE_BUNDLE)",
      "section_title": true,
      "ja": "5.4. バンドル拒否（REFUSE_BUNDLE）"
    },
    {
      "indent": 3,
      "text": "As bundles may be large, the TCPCL supports an optional mechanisms by which a receiving node may indicate to the sender that it does not want to receive the corresponding bundle.",
      "ja": "バンドルは大きくなる可能性があるため、TCPCLはオプションのメカニズムをサポートします。これにより、受信ノードは、対応するバンドルを受信したくないことを送信者に示すことができます。"
    },
    {
      "indent": 3,
      "text": "To do so, upon receiving a DATA_SEGMENT message, the node MAY transmit a REFUSE_BUNDLE message. As data segments and acknowledgments may cross on the wire, the bundle that is being refused is implicitly identified by the sequence in which acknowledgements and refusals are received.",
      "ja": "そうするために、DATA_SEGMENTメッセージを受信すると、ノードはREFUSE_BUNDLEメッセージを送信してもよい[MAY]。データセグメントと確認応答がネットワーク上で交差する可能性があるため、拒否されているバンドルは、確認応答と拒否が受信されたシーケンスによって暗黙的に識別されます。"
    },
    {
      "indent": 3,
      "text": "The format of the REFUSE_BUNDLE message is as follows:",
      "ja": "REFUSE_BUNDLEメッセージの形式は次のとおりです。"
    },
    {
      "indent": 30,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  0x3  | RCode |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 7: Format of REFUSE_BUNDLE Messages",
      "ja": "図7：REFUSE_BUNDLEメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "The RCode field, which stands for \"reason code\", contains a value indicating why the bundle was refused. The following table contains semantics for some values. Other values may be registered with IANA, as defined in Section 8.",
      "ja": "「理由コード」を表すRCodeフィールドには、バンドルが拒否された理由を示す値が含まれています。次の表に、いくつかの値のセマンティクスを示します。セクション8で定義されているように、他の値をIANAに登録できます。"
    },
    {
      "indent": 3,
      "text": "+---------+---------------------------------------------------------+\n|  RCode  | Semantics                                               |\n+---------+---------------------------------------------------------+\n|   0x0   | Reason for refusal is unknown or not specified.         |\n|   0x1   | The receiver now has the complete bundle.  The sender   |\n|         | may now consider the bundle as completely received.     |\n|   0x2   | The receiver's resources are exhausted.  The sender     |\n|         | SHOULD apply reactive bundle fragmentation before       |\n|         | retrying.                                               |\n|   0x3   | The receiver has encountered a problem that requires    |\n|         | the bundle to be retransmitted in its entirety.         |\n| 0x4-0x7 | Unassigned.                                             |\n| 0x8-0xf | Reserved for future usage.                              |\n+---------+---------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 3: REFUSE_BUNDLE Reason Codes",
      "ja": "表3：REFUSE_BUNDLE理由コード"
    },
    {
      "indent": 3,
      "text": "The receiver MUST, for each bundle preceding the one to be refused, have either acknowledged all DATA_SEGMENTs or refused the bundle. This allows the sender to identify the bundles accepted and refused by means of a simple FIFO list of segments and acknowledgments.",
      "ja": "受信者は、拒否されるバンドルの前の各バンドルについて、すべてのDATA_SEGMENTを確認するか、バンドルを拒否する必要があります。これにより、送信者は、セグメントと確認応答の単純なFIFOリストを使用して、受け入れられ、拒否されたバンドルを識別できます。"
    },
    {
      "indent": 3,
      "text": "The bundle refusal MAY be sent before the entire data segment is received. If a sender receives a REFUSE_BUNDLE message, the sender MUST complete the transmission of any partially sent DATA_SEGMENT message (so that the receiver stays in sync). The sender MUST NOT commence transmission of any further segments of the rejected bundle subsequently. Note, however, that this requirement does not ensure that a node will not receive another DATA_SEGMENT for the same bundle after transmitting a REFUSE_BUNDLE message since messages may cross on the wire; if this happens, subsequent segments of the bundle SHOULD also be refused with a REFUSE_BUNDLE message.",
      "ja": "バンドル拒否は、データセグメント全体が受信される前に送信される場合があります。送信者がREFUSE_BUNDLEメッセージを受信した場合、送信者は部分的に送信されたDATA_SEGMENTメッセージの送信を完了しなければなりません（そのため、受信者は同期を保ちます）。送信者は、拒否されたバンドルの以降のセグメントの送信を開始してはなりません（MUST NOT）。ただし、この要件は、メッセージがネットワーク上を通過する可能性があるため、ノードがREFUSE_BUNDLEメッセージを送信した後に同じバンドルの別のDATA_SEGMENTを受信しないことを保証しないことに注意してください。これが発生した場合、バンドルの後続のセグメントもREFUSE_BUNDLEメッセージで拒否する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note: If a bundle transmission is aborted in this way, the receiver may not receive a segment with the 'E' flag set to '1' for the aborted bundle. The beginning of the next bundle is identified by the 'S' bit set to '1', indicating the start of a new bundle.",
      "ja": "注：この方法でバンドルの送信が中止されると、中止されたバンドルの「E」フラグが「1」に設定されたセグメントを受信側が受信できない場合があります。次のバンドルの開始は、「1」に設定された「S」ビットによって識別され、新しいバンドルの開始を示します。"
    },
    {
      "indent": 0,
      "text": "5.5. Bundle Length (LENGTH)",
      "section_title": true,
      "ja": "5.5. バンドルの長さ（LENGTH）"
    },
    {
      "indent": 3,
      "text": "The LENGTH message contains the total length, in bytes, of the next bundle, formatted as an SDNV. Its purpose is to allow nodes to preemptively refuse bundles that would exceed their resources. It is an optimization.",
      "ja": "LENGTHメッセージには、SDNVとしてフォーマットされた次のバンドルの全長（バイト単位）が含まれています。その目的は、ノードがリソースを超えるバンドルを先制的に拒否できるようにすることです。それは最適化です。"
    },
    {
      "indent": 3,
      "text": "The format of the LENGTH message is as follows:",
      "ja": "LENGTHメッセージの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x6  |0|0|0|0|     total bundle length ...                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 8: Format of LENGTH Messages",
      "ja": "図8：LENGTHメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "LENGTH messages MUST NOT be sent unless the corresponding flag bit is set in the contact header. If the flag bit is set, LENGTH messages MAY be sent at the sender's discretion. LENGTH messages MUST NOT be sent unless the next DATA_SEGMENT message has the 'S' bit set to \"1\" (i.e., just before the start of a new bundle).",
      "ja": "対応するフラグビットが連絡先ヘッダーで設定されていない限り、LENGTHメッセージを送信してはなりません（MUST NOT）。フラグビットが設定されている場合、LENGTHメッセージは送信者の裁量で送信される場合があります。次のDATA_SEGMENTメッセージの「S」ビットが「1」に設定されていない限り（つまり、新しいバンドルの開始直前）、LENGTHメッセージを送信してはならない（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "A receiver MAY send a BUNDLE_REFUSE message as soon as it receives a LENGTH message without waiting for the next DATA_SEGMENT message. The sender MUST be prepared for this and MUST associate the refusal with the right bundle.",
      "ja": "受信者は、次のDATA_SEGMENTメッセージを待たずに、LENGTHメッセージを受信するとすぐにBUNDLE_REFUSEメッセージを送信できます（MAY）。送信者はこれに備えなければならず（MUST）、拒否を正しいバンドルに関連付ける必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. KEEPALIVE Feature (KEEPALIVE)",
      "section_title": true,
      "ja": "5.6. KEEPALIVE機能（KEEPALIVE）"
    },
    {
      "indent": 3,
      "text": "The protocol includes a provision for transmission of KEEPALIVE messages over the TCP connection to help determine if the connection has been disrupted.",
      "ja": "プロトコルには、TCP接続を介したKEEPALIVEメッセージの送信のためのプロビジョニングが含まれており、接続が中断されたかどうかを判断するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.1, one of the parameters in the contact header is the keepalive_interval. Both sides populate this field with their requested intervals (in seconds) between KEEPALIVE messages.",
      "ja": "セクション4.1で説明したように、連絡先ヘッダーのパラメーターの1つはkeepalive_intervalです。両側で、KEEPALIVEメッセージ間の要求された間隔（秒単位）をこのフィールドに入力します。"
    },
    {
      "indent": 3,
      "text": "The format of a KEEPALIVE message is a one-byte message type code of KEEPALIVE (as described in Table 2) with no additional data. Both sides SHOULD send a KEEPALIVE message whenever the negotiated interval has elapsed with no transmission of any message (KEEPALIVE or other).",
      "ja": "KEEPALIVEメッセージのフォーマットは、KEEPALIVEの1バイトのメッセージタイプコード（表2で説明）で、追加のデータはありません。どちらの側も、メッセージ（KEEPALIVEまたはその他）を送信せずにネゴシエートされた間隔が経過するたびに、KEEPALIVEメッセージを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If no message (KEEPALIVE or other) has been received for at least twice the keepalive_interval, then either party MAY terminate the session by transmitting a one-byte SHUTDOWN message (as described in Table 2) and by closing the TCP connection.",
      "ja": "メッセージ（KEEPALIVEまたはその他）がkeepalive_intervalの2倍以上受信されなかった場合、どちらのパーティも、1バイトのSHUTDOWNメッセージ（表2で説明）を送信し、TCP接続を閉じることにより、セッションを終了できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "Note: The keepalive_interval should not be chosen too short as TCP retransmissions may occur in case of packet loss. Those will have to be triggered by a timeout (TCP retransmission timeout (RTO)), which is dependent on the measured RTT for the TCP connection so that KEEPALIVE messages may experience noticeable latency.",
      "ja": "注：パケットが失われた場合にTCP再送信が発生する可能性があるため、keepalive_intervalは短すぎないように選択してください。これらは、タイムアウト（TCP再送信タイムアウト（RTO））によってトリガーされる必要があります。これは、TCP接続の測定されたRTTに依存するため、KEEPALIVEメッセージで顕著な遅延が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "6. Connection Termination",
      "section_title": true,
      "ja": "6. 接続終了"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for ending a TCPCL connection.",
      "ja": "このセクションでは、TCPCL接続を終了する手順について説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Shutdown Message (SHUTDOWN)",
      "section_title": true,
      "ja": "6.1. シャットダウンメッセージ（SHUTDOWN）"
    },
    {
      "indent": 3,
      "text": "To cleanly shut down a connection, a SHUTDOWN message MUST be transmitted by either node at any point following complete transmission of any other message. In case acknowledgments have been negotiated, a node SHOULD acknowledge all received data segments first and then shut down the connection.",
      "ja": "接続を正常にシャットダウンするには、他のメッセージの送信が完了した後の任意の時点で、いずれかのノードがSHUTDOWNメッセージを送信する必要があります。確認応答がネゴシエートされた場合、ノードは最初にすべての受信データセグメントを確認してから、接続をシャットダウンする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The format of the SHUTDOWN message is as follows:",
      "ja": "SHUTDOWNメッセージの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x5  |0|0|R|D| reason (opt)  | reconnection delay (opt)      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 9: Format of Bundle SHUTDOWN Messages",
      "ja": "図9：バンドルSHUTDOWNメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "It is possible for a node to convey additional information regarding the reason for connection termination. To do so, the node MUST set the 'R' bit in the message header flags and transmit a one-byte reason code immediately following the message header. The specified values of the reason code are:",
      "ja": "ノードが接続終了の理由に関する追加情報を伝達することは可能です。これを行うには、ノードはメッセージヘッダーフラグに「R」ビットを設定し、メッセージヘッダーの直後に1バイトの理由コードを送信する必要があります。理由コードの指定値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-----------+------------------+------------------------------------+\n|    Code   | Meaning          | Description                        |\n+-----------+------------------+------------------------------------+\n|    0x00   | Idle timeout     | The connection is being closed due |\n|           |                  | to idleness.                       |\n|           |                  |                                    |\n|    0x01   | Version mismatch | The node cannot conform to the     |\n|           |                  | specified TCPCL protocol version.  |\n|           |                  |                                    |\n|    0x02   | Busy             | The node is too busy to handle the |\n|           |                  | current connection.                |\n|           |                  |                                    |\n| 0x03-0xff |                  | Unassigned.                        |\n+-----------+------------------+------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 4: SHUTDOWN Reason Codes",
      "ja": "表4：SHUTDOWN理由コード"
    },
    {
      "indent": 0,
      "text": " It is also possible to convey a requested reconnection delay to indicate how long the other node must wait before attempting connection re-establishment. To do so, the node sets the 'D' bit in the message header flags and then transmits an SDNV specifying the requested delay, in seconds, following the message header (and optionally, the SHUTDOWN reason code). The value 0 SHALL be interpreted as an infinite delay, i.e., that the connecting node MUST NOT re-establish the connection. In contrast, if the node does not wish to request a delay, it SHOULD omit the reconnection delay field (and set the 'D' bit to zero). Note that in the figure above, the reconnection delay SDNV is represented as a two-byte field for convenience.",
      "ja": "要求された再接続遅延を伝えて、接続の再確立を試行する前に他のノードが待機する必要がある時間を示すこともできます。そのために、ノードはメッセージヘッダーフラグに「D」ビットを設定し、メッセージヘッダー（およびオプションでSHUTDOWN理由コード）に続いて、要求された遅延を秒単位で指定するSDNVを送信します。値0は、無限の遅延として解釈されるものとします。つまり、接続ノードが接続を再確立してはいけません。対照的に、ノードが遅延を要求したくない場合は、再接続遅延フィールドを省略してください（そして「D」ビットをゼロに設定してください）。上の図では、便宜上、再接続遅延SDNVは2バイトのフィールドとして表されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A connection shutdown MAY occur immediately after TCP connection establishment or reception of a contact header (and prior to any further data exchange). This may, for example, be used to notify that the node is currently not able or willing to communicate. However, a node MUST always send the contact header to its peer before sending a SHUTDOWN message.",
      "ja": "接続のシャットダウンは、TCP接続の確立またはコンタクトヘッダーの受信の直後（およびそれ以降のデータ交換の前）に発生する場合があります。これは、たとえば、ノードが現在通信できない、または通信する意思があることを通知するために使用できます。ただし、ノードはSHUTDOWNメッセージを送信する前に、常に連絡先ヘッダーをピアに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If either node terminates a connection prematurely in this manner, it SHOULD send a SHUTDOWN message and MUST indicate a reason code unless the incoming connection did not include the magic string. If a node does not want its peer to reopen the connection immediately, it SHOULD set the 'D' bit in the flags and include a reconnection delay to indicate when the peer is allowed to attempt another connection setup.",
      "ja": "この方法でいずれかのノードが接続を途中で終了した場合、着信接続にマジックストリングが含まれていない場合を除き、SHUTDOWNメッセージを送信し、理由コードを示す必要があります。ノードがピアに接続をすぐに再開させたくない場合は、フラグに「D」ビットを設定し、ピアが別の接続セットアップをいつ試行できるかを示す再接続遅延を含める必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If a connection is to be terminated before another protocol message has completed, then the node MUST NOT transmit the SHUTDOWN message but still SHOULD close the TCP connection. In particular, if the connection is to be closed (for whatever reason) while a node is in the process of transmitting a bundle data segment, the receiving node is still expecting segment data and might erroneously interpret the SHUTDOWN message to be part of the data segment.",
      "ja": "別のプロトコルメッセージが完了する前に接続を終了する場合、ノードはSHUTDOWNメッセージを送信してはならず（MUST NOT）、それでもTCP接続を閉じる必要があります（SHOULD）。特に、ノードがバンドルデータセグメントを送信している最中に（何らかの理由で）接続が閉じられる場合、受信ノードはまだセグメントデータを予期しており、SHUTDOWNメッセージをデータの一部であると誤って解釈する可能性があります。セグメント。"
    },
    {
      "indent": 0,
      "text": "6.2. Idle Connection Shutdown",
      "section_title": true,
      "ja": "6.2. アイドル接続のシャットダウン"
    },
    {
      "indent": 3,
      "text": "The protocol includes a provision for clean shutdown of idle TCP connections. Determining the length of time to wait before closing idle connections, if they are to be closed at all, is an implementation and configuration matter.",
      "ja": "このプロトコルには、アイドル状態のTCP接続を完全にシャットダウンするための規定が含まれています。アイドル接続を閉じる前に待機する時間の長さを決定することは、接続を閉じる必要がある場合は、実装と構成の問題です。"
    },
    {
      "indent": 3,
      "text": "If there is a configured time to close idle links and if no bundle data (other than KEEPALIVE messages) has been received for at least that amount of time, then either node MAY terminate the connection by transmitting a SHUTDOWN message indicating the reason code of 'Idle timeout' (as described in Table 4). After receiving a SHUTDOWN message in response, both sides may close the TCP connection.",
      "ja": "アイドルリンクを閉じるための構成された時間があり、バンドルデータ（KEEPALIVEメッセージ以外）が少なくともその時間の間受信されなかった場合、いずれかのノードは、理由コード 'を示すSHUTDOWNメッセージを送信して接続を終了できます（MAY）。アイドルタイムアウト '（表4で説明）。応答としてSHUTDOWNメッセージを受信した後、両側でTCP接続を閉じることができます。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "One security consideration for this protocol relates to the fact that nodes present their endpoint identifier as part of the connection header exchange. It would be possible for a node to fake this value and present the identity of a singleton endpoint in which the node is not a member, essentially masquerading as another DTN node. If this identifier is used without further verification as a means to determine which bundles are transmitted over the connection, then the node that has falsified its identity may be able to obtain bundles that it should not have. Therefore, a node SHALL NOT use the endpoint identifier conveyed in the TCPCL connection message to derive a peer node's identity unless it can ascertain it via other means.",
      "ja": "このプロトコルのセキュリティに関する考慮事項の1つは、ノードが接続ヘッダー交換の一部としてエンドポイント識別子を提示するという事実に関係しています。ノードがこの値を偽造し、ノードがメンバーではないシングルトンエンドポイントのIDを提示し、本質的に別のDTNノードになりすます可能性があります。接続を介して送信されるバンドルを判別する手段として、このIDをさらに検証せずに使用すると、IDを偽造したノードが、本来持つべきでないバンドルを取得できる可能性があります。したがって、ノードは、TCPCL接続メッセージで伝達されたエンドポイント識別子を使用して、他の方法で確認できない限り、ピアノードのIDを導出しないでください。"
    },
    {
      "indent": 3,
      "text": "These concerns may be mitigated through the use of the Bundle Security Protocol [RFC6257]. In particular, the Bundle Authentication Block defines mechanism for secure exchange of bundles between DTN nodes. Thus, an implementation could delay trusting the presented endpoint identifier until the node can securely validate that its peer is in fact the only member of the given singleton endpoint.",
      "ja": "これらの懸念は、Bundle Security Protocol [RFC6257]を使用することで軽減できます。特に、バンドル認証ブロックは、DTNノード間でバンドルを安全に交換するためのメカニズムを定義します。したがって、実装は、ノードがそのピアが実際に特定のシングルトンエンドポイントの唯一のメンバーであることを安全に検証できるまで、提示されたエンドポイント識別子の信頼を遅らせる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In general, TCPCL does not provide any security services. The mechanisms defined in [RFC6257] are to be used instead.",
      "ja": "一般に、TCPCLはセキュリティサービスを提供しません。代わりに[RFC6257]で定義されたメカニズムが使用されます。"
    },
    {
      "indent": 3,
      "text": "Nothing in TCPCL prevents the use of the Transport Layer Security (TLS) protocol [RFC5246] to secure a connection.",
      "ja": "TCPCLには、接続を保護するためのトランスポート層セキュリティ（TLS）プロトコル[RFC5246]の使用を妨げるものはありません。"
    },
    {
      "indent": 3,
      "text": "Another consideration for this protocol relates to denial-of-service attacks. A node may send a large amount of data over a TCP connection, requiring the receiving node to handle the data, attempt to stop the flood of data by sending a REFUSE_BUNDLE message, or forcibly terminate the connection. This burden could cause denial of service on other, well-behaving connections. There is also nothing to prevent a malicious node from continually establishing connections and repeatedly trying to send copious amounts of bundle data. A listening node MAY take countermeasures such as ignoring TCP SYN messages, closing TCP connections as soon as they are established, waiting before sending the contact header, sending a SHUTDOWN message quickly or with a delay, etc.",
      "ja": "このプロトコルに関する別の考慮事項は、サービス拒否攻撃に関連しています。ノードは、TCP接続を介して大量のデータを送信し、受信ノードがデータを処理すること、REFUSE_BUNDLEメッセージを送信してデータのフラッドを停止すること、または接続を強制的に終了することを要求する場合があります。この負担により、他の正常な接続でサービス拒否が発生する可能性があります。また、悪意のあるノードが継続的に接続を確立し、大量のバンドルデータを繰り返し送信しようとするのを防ぐ方法はありません。リスニングノードは、TCP SYNメッセージを無視する、TCP接続が確立されるとすぐに閉じる、コンタクトヘッダーを送信する前に待機する、SHUTDOWNメッセージをすばやくまたは遅延して送信するなどの対策を講じることができます（MAY）。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In this section, registration procedures are as defined in [RFC5226].",
      "ja": "このセクションでは、登録手順は[RFC5226]で定義されています。"
    },
    {
      "indent": 0,
      "text": "8.1. Port Number",
      "section_title": true,
      "ja": "8.1. ポート番号"
    },
    {
      "indent": 3,
      "text": "Port number 4556 has been assigned as the default port for the TCP convergence layer.",
      "ja": "ポート番号4556は、TCPコンバージェンスレイヤーのデフォルトポートとして割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Service Name: dtn-bundle",
      "ja": "サービス名：dtn-bundle"
    },
    {
      "indent": 3,
      "text": "Transport Protocol(s): TCP",
      "ja": "トランスポートプロトコル：TCP"
    },
    {
      "indent": 3,
      "text": "Assignee:  Simon Perreault <simon@per.reau.lt>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Contact:  Simon Perreault <simon@per.reau.lt>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Description: DTN Bundle TCP CL Protocol",
      "ja": "説明：DTNバンドルTCP CLプロトコル"
    },
    {
      "indent": 3,
      "text": "Reference: [RFC7242]",
      "ja": "参照：[RFC7242]"
    },
    {
      "indent": 3,
      "text": "Port Number: 4556",
      "ja": "ポート番号：4556"
    },
    {
      "indent": 0,
      "text": "8.2. Protocol Versions",
      "section_title": true,
      "ja": "8.2. プロトコルバージョン"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer Version Numbers\" and initialized it with the following:",
      "ja": "IANAは、「バンドルプロトコル」レジストリの下に、「バンドルプロトコルTCPコンバージェンスレイヤーバージョン番号」というサブレジストリを作成し、次のように初期化しました。"
    },
    {
      "indent": 20,
      "text": "+-------+-------------+-----------+\n| Value | Description | Reference |\n+-------+-------------+-----------+\n|   0   | Reserved    | [RFC7242] |\n|   1   | Reserved    | [RFC7242] |\n|   2   | Reserved    | [RFC7242] |\n|   3   | TCPCL       | [RFC7242] |\n| 4-255 | Unassigned  | [RFC7242] |\n+-------+-------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The registration procedure is RFC Required.",
      "ja": "登録手順はRFC必須です。"
    },
    {
      "indent": 0,
      "text": "8.3. Message Types",
      "section_title": true,
      "ja": "8.3. メッセージの種類"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer Message Types\" and initialized it with the contents of Table 2. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドルプロトコル」レジストリの下に、「バンドルプロトコルTCPコンバージェンスレイヤメッセージタイプ」というサブレジストリを作成し、表2の内容で初期化しました。登録手順はRFC必須です。"
    },
    {
      "indent": 0,
      "text": "8.4. REFUSE_BUNDLE Reason Codes",
      "section_title": true,
      "ja": "8.4. REFUSE_BUNDLE理由コード"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer REFUSE_BUNDLE Reason Codes\" and initialized it with the contents of Table 3. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドルプロトコル」レジストリの下に、「バンドルプロトコルTCPコンバージェンスレイヤーREFUSE_BUNDLE理由コード」というサブレジストリを作成し、表3の内容で初期化しました。登録手順はRFC必須です。"
    },
    {
      "indent": 0,
      "text": "8.5. SHUTDOWN Reason Codes",
      "section_title": true,
      "ja": "8.5. SHUTDOWN理由コード"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer SHUTDOWN Reason Codes\" and initialized it with the contents of Table 4. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドルプロトコル」レジストリの下に、「バンドルプロトコルTCPコンバージェンスレイヤーシャットダウン理由コード」というサブレジストリを作成し、表4の内容で初期化しました。登録手順はRFC必須です。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following individuals who have participated in the drafting, review, and discussion of this memo: Alex McMahon, Brenton Walker, Darren Long, Dirk Kutscher, Elwyn Davies, Jean-Philippe Dionne, Joseph Ishac, Keith Scott, Kevin Fall, Lloyd Wood, Marc Blanchet, Peter Lovell, Scott Burleigh, Stephen Farrell, Vint Cerf, and William Ivancic.",
      "ja": "著者は、このメモの起草、レビュー、および議論に参加した以下の個人に感謝します：アレックスマクマホン、ブレントンウォーカー、ダレンロング、ダーククッチャー、エルウィンデイビス、ジャンフィリップディオン、ジョセフイシャック、キーススコット、ケビン・フォール、ロイド・ウッド、マーク・ブランシェ、ピーター・ロヴェル、スコット・バーレイ、スティーブン・ファレル、ヴィント・サーフ、ウィリアム・イヴァンシッチ。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5050] Scott, K. and S. Burleigh, \"Bundle Protocol Specification\", RFC 5050, November 2007.",
      "ja": "[RFC5050]スコット、KおよびS.バーレイ、「バンドルプロトコル仕様」、RFC 5050、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[DTNIMPL] DTNRG, \"Delay-Tolerant Networking Reference Implementation\", <https://sites.google.com/site/ dtnresgroup/home/code>.",
      "ja": "[DTNIMPL] DTNRG、「遅延許容ネットワーク参照実装」、<https://sites.google.com/site/ dtnresgroup / home / code>。"
    },
    {
      "indent": 3,
      "text": "[RFC4838] Cerf, V., Burleigh, S., Hooke, A., Torgerson, L., Durst, R., Scott, K., Fall, K., and H. Weiss, \"Delay-Tolerant Networking Architecture\", RFC 4838, April 2007.",
      "ja": "[RFC4838] Cerf、V.、Burleigh、S.、Hooke、A.、Torgerson、L.、Durst、R.、Scott、K.、Fall、K。、およびH. Weiss、「遅延耐性のあるネットワークアーキテクチャ」 、RFC 4838、2007年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6256] Eddy, W. and E. Davies, \"Using Self-Delimiting Numeric Values in Protocols\", RFC 6256, May 2011.",
      "ja": "[RFC6256] Eddy、W。およびE. Davies、「Using Self-Delimited Numeric Values in Protocols」、RFC 6256、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6257] Symington, S., Farrell, S., Weiss, H., and P. Lovell, \"Bundle Security Protocol Specification\", RFC 6257, May 2011.",
      "ja": "[RFC6257] Symington、S.、Farrell、S.、Weiss、H。、およびP. Lovell、「Bundle Security Protocol Specification」、RFC 6257、2011年5月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael J. Demmer University of California, Berkeley Computer Science Division 445 Soda Hall Berkeley, CA 94720-1776 US",
      "ja": "マイケル・J・デマーカリフォルニア大学バークレー校コンピュータサイエンス課445 Soda Hall Berkeley、CA 94720-1776 US"
    },
    {
      "indent": 3,
      "text": "EMail: demmer@cs.berkeley.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Joerg Ott Aalto University Department of Communications and Networking PO Box 13000 AALTO 02015 Finland",
      "ja": "Joerg Ott Aalto大学コミュニケーションおよびネットワーキング学科私書箱13000 AALTO 02015フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: jo@netlab.tkk.fi",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simon Perreault Quebec, QC Canada",
      "ja": "Simon Perreault Quebec、QC Canada"
    },
    {
      "indent": 3,
      "text": "EMail: simon@per.reau.lt",
      "raw": true,
      "ja": ""
    }
  ]
}