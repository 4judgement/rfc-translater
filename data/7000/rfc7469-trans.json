{
  "title": {
    "text": "RFC 7469 - Public Key Pinning Extension for HTTP",
    "ja": "RFC 7469 - HTTPの公開キー固定拡張機能"
  },
  "number": 7469,
  "created_at": "2020-08-15 19:37:02.887033+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          C. Evans\nRequest for Comments: 7469                                     C. Palmer\nCategory: Standards Track                                      R. Sleevi\nISSN: 2070-1721                                             Google, Inc.\n                                                              April 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Public Key Pinning Extension for HTTP",
      "ja": "HTTPの公開キー固定拡張機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines a new HTTP header that allows web host operators to instruct user agents to remember (\"pin\") the hosts' cryptographic identities over a period of time. During that time, user agents (UAs) will require that the host presents a certificate chain including at least one Subject Public Key Info structure whose fingerprint matches one of the pinned fingerprints for that host. By effectively reducing the number of trusted authorities who can authenticate the domain during the lifetime of the pin, pinning may reduce the incidence of man-in-the-middle attacks due to compromised Certification Authorities.",
      "ja": "このドキュメントは、新しいHTTPヘッダーを定義します。これにより、Webホストオペレーターは、一定期間にわたってホストの暗号IDを記憶（「ピン」）するようにユーザーエージェントに指示できます。その間、ユーザーエージェント（UA）は、そのホストのピン留めされたフィンガープリントの1つとフィンガープリントが一致する少なくとも1つのサブジェクト公開鍵情報構造を含む証明書チェーンをホストが提示することを要求します。ピンの有効期間中にドメインを認証できる信頼できる機関の数を効果的に減らすことにより、ピン留めにより、証明機関の侵害による中間者攻撃の発生を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7469.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7469で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n2.  Server and Client Behavior  . . . . . . . . . . . . . . . . .   5\n  2.1.  Response Header Field Syntax  . . . . . . . . . . . . . .   5\n    2.1.1.  The Pin Directive . . . . . . . . . . . . . . . . . .   6\n    2.1.2.  The max-age Directive . . . . . . . . . . . . . . . .   7\n    2.1.3.  The includeSubDomains Directive . . . . . . . . . . .   7\n    2.1.4.  The report-uri Directive  . . . . . . . . . . . . . .   7\n    2.1.5.  Examples  . . . . . . . . . . . . . . . . . . . . . .   8\n  2.2.  Server Processing Model . . . . . . . . . . . . . . . . .   9\n    2.2.1.  HTTP-over-Secure-Transport Request Type . . . . . . .   9\n    2.2.2.  HTTP Request Type . . . . . . . . . . . . . . . . . .   9\n  2.3.  User Agent Processing Model . . . . . . . . . . . . . . .  10\n    2.3.1.  Public-Key-Pins Response Header Field Processing  . .  10\n    2.3.2.  Interaction of Public-Key-Pins and Public-Key-Pins-\n            Report-Only . . . . . . . . . . . . . . . . . . . . .  11\n    2.3.3.  Noting a Pinned Host - Storage Model  . . . . . . . .  11\n    2.3.4.  HTTP-Equiv <Meta> Element Attribute . . . . . . . . .  13\n  2.4.  Semantics of Pins . . . . . . . . . . . . . . . . . . . .  13\n  2.5.  Noting Pins . . . . . . . . . . . . . . . . . . . . . . .  14\n  2.6.  Validating Pinned Connections . . . . . . . . . . . . . .  15\n  2.7.  Interactions with Preloaded Pin Lists . . . . . . . . . .  16\n  2.8.  Pinning Self-Signed End Entities  . . . . . . . . . . . .  16\n3.  Reporting Pin Validation Failure  . . . . . . . . . . . . . .  16\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  19\n  4.1.  Maximum max-age . . . . . . . . . . . . . . . . . . . . .  19\n  4.2.  Using includeSubDomains Safely  . . . . . . . . . . . . .  20\n  4.3.  Backup Pins . . . . . . . . . . . . . . . . . . . . . . .  21\n  4.4.  Interactions With Cookie Scoping  . . . . . . . . . . . .  21\n  4.5.  Hostile Pinning . . . . . . . . . . . . . . . . . . . . .  21\n5.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  22\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24\n7.  Usability Considerations  . . . . . . . . . . . . . . . . . .  24\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  24\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  26\nAppendix A.  Fingerprint Generation . . . . . . . . . . . . . . .  27\nAppendix B.  Deployment Guidance  . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines a new HTTP header that enables UAs to determine which Subject Public Key Info (SPKI) structures will be present in a web host's certificate chain in future Transport Layer Security (TLS) [RFC5246] connections.",
      "ja": "このドキュメントでは、UAが将来のトランスポート層セキュリティ（TLS）[RFC5246]接続でWebホストの証明書チェーンに存在するサブジェクト公開鍵情報（SPKI）構造を決定できるようにする新しいHTTPヘッダーを定義します。"
    },
    {
      "indent": 3,
      "text": "Deploying Public Key Pinning (PKP) safely will require operational and organizational maturity due to the risk that hosts may make themselves unavailable by pinning to a set of SPKIs that becomes invalid (see Section 4). With care, host operators can greatly reduce the risk of man-in-the-middle (MITM) attacks and other false-authentication problems for their users without incurring undue risk.",
      "ja": "公開鍵ピン留め（PKP）を安全に展開するには、ホストが無効になる一連のSPKIにピン留めすることでホストを利用できなくなるリスクがあるため、運用上および組織上の成熟が必要です（セクション4を参照）。ホストオペレーターは、注意を払えば、中間者（MITM）攻撃のリスクや、ユーザーに対するその他の偽の認証問題を、過度のリスクを負わずに大幅に減らすことができます。"
    },
    {
      "indent": 3,
      "text": "PKP is meant to be used together with HTTP Strict Transport Security (HSTS) [RFC6797], but it is possible to pin keys without requiring HSTS.",
      "ja": "PKPはHTTP Strict Transport Security（HSTS）[RFC6797]と一緒に使用することを目的としていますが、HSTSを必要とせずにキーを固定することが可能です。"
    },
    {
      "indent": 3,
      "text": "A Pin is a relationship between a hostname and a cryptographic identity (in this document, one or more of the public keys in a chain of X.509 certificates). Pin Validation is the process a UA performs to ensure that a host is in fact authenticated with its previously established Pin.",
      "ja": "PINは、ホスト名と暗号ID（このドキュメントでは、X.509証明書のチェーン内の1つ以上の公開鍵）の間の関係です。ピンの検証は、ホストが以前に確立されたピンで実際に認証されていることを確認するためにUAが実行するプロセスです。"
    },
    {
      "indent": 3,
      "text": "Key pinning is a trust-on-first-use (TOFU) mechanism. The first time a UA connects to a host, it lacks the information necessary to perform Pin Validation; UAs can only apply their normal cryptographic identity validation. (In this document, it is assumed that UAs apply X.509 certificate chain validation in accord with [RFC5280].)",
      "ja": "キーの固定は、最初に使用する信頼（TOFU）メカニズムです。 UAが初めてホストに接続するとき、ピンの検証を実行するために必要な情報が不足しています。 UAは通常の暗号化ID検証のみを適用できます。 （このドキュメントでは、UAが[RFC5280]に従ってX.509証明書チェーン検証を適用することを前提としています。）"
    },
    {
      "indent": 3,
      "text": "The UA will not be able to detect and thwart a MITM attacking the UA's first connection to the host. (However, the requirement that the MITM provide an X.509 certificate chain that can pass the UA's validation requirements, without error, mitigates this risk somewhat.) Worse, such a MITM can inject its own PKP header into the HTTP stream, and pin the UA to its own keys. To avoid post facto detection, the attacker would have to be in a position to intercept all future requests to the host from that UA.",
      "ja": "UAは、ホストへのUAの最初の接続を攻撃するMITMを検出して阻止することができません。 （ただし、MITMがUAの検証要件をエラーなしで渡すことができるX.509証明書チェーンを提供するという要件は、このリスクを多少軽減します。）さらに悪いことに、このようなMITMは独自のPKPヘッダーをHTTPストリームに挿入し、 UAを独自のキーに。事後検出を回避するために、攻撃者はそのUAからホストへの今後のすべてのリクエストを傍受する立場にある必要があります。"
    },
    {
      "indent": 3,
      "text": "Thus, key pinning as described in this document is not a perfect defense against MITM attackers capable of passing certificate chain validation procedures -- nothing short of pre-shared keys can be. However, it provides significant value by allowing host operators to limit the number of certification authorities that can vouch for the host's identity, and allows UAs to detect in-process MITM attacks after the initial communication.",
      "ja": "したがって、このドキュメントで説明されているキーのピン留めは、証明書チェーン検証手順を通過できるMITM攻撃者に対する完全な防御策ではありません。事前共有キー以外には何もできません。ただし、ホストオペレーターがホストのIDを保証できる証明機関の数を制限できるため、大きな価値があり、UAは最初の通信後にインプロセスMITM攻撃を検出できます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Server and Client Behavior",
      "section_title": true,
      "ja": "2. サーバーとクライアントの動作"
    },
    {
      "indent": 0,
      "text": "2.1. Response Header Field Syntax",
      "section_title": true,
      "ja": "2.1. 応答ヘッダーフィールドの構文"
    },
    {
      "indent": 3,
      "text": "The \"Public-Key-Pins\" and \"Public-Key-Pins-Report-Only\" header fields, also referred to within this specification as the PKP and PKP-RO header fields, respectively, are new response headers defined in this specification. They are used by a server to indicate that a UA should perform Pin Validation (Section 2.6) for the host emitting the response message, and to provide the necessary information for the UA to do so.",
      "ja": "「Public-Key-Pins」および「Public-Key-Pins-Report-Only」ヘッダーフィールドは、この仕様ではそれぞれPKPおよびPKP-ROヘッダーフィールドとも呼ばれ、この仕様で定義された新しい応答ヘッダーです。これらはサーバーによって使用され、UAが応答メッセージを送信するホストに対してピン検証（セクション2.6）を実行する必要があることを示し、UAがそのために必要な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Figure 1 describes the syntax (Augmented Backus-Naur Form) of the header fields, using the grammar defined in [RFC5234] and the rules defined in Section 3.2 of [RFC7230]. The field values of both header fields conform to the same rules.",
      "ja": "図1は、[RFC5234]で定義された文法と[RFC7230]のセクション3.2で定義されたルールを使用して、ヘッダーフィールドの構文（拡張バッカスナウアフォーム）を示しています。両方のヘッダーフィールドのフィールド値は、同じルールに準拠しています。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Directives = directive *( OWS \";\" OWS directive )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "directive = directive-name [ \"=\" directive-value ] directive-name = token directive-value = token / quoted-string",
      "ja": "ディレクティブ=ディレクティブ名[\"=\"ディレクティブ値]ディレクティブ名=トークンディレクティブ値=トークン/引用文字列"
    },
    {
      "indent": 23,
      "text": "Figure 1: HPKP Header Syntax",
      "ja": "図1：HPKPヘッダーの構文"
    },
    {
      "indent": 3,
      "text": "Optional white space (OWS) is used as defined in Section 3.2.3 of [RFC7230]. token and quoted-string are used as defined in Section 3.2.6 of [RFC7230].",
      "ja": "[RFC7230]のセクション3.2.3で定義されているように、オプションの空白（OWS）が使用されます。トークンとquoted-stringは、[RFC7230]のセクション3.2.6の定義に従って使用されます。"
    },
    {
      "indent": 3,
      "text": "The directives defined in this specification are described below. The overall requirements for directives are:",
      "ja": "この仕様で定義されているディレクティブを以下に示します。ディレクティブの全体的な要件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The order of appearance of directives is not significant.",
      "ja": "1. ディレクティブの出現順序は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "2. With the exception of pin-directives with the same pin-directive-name (see below), a given directive MUST NOT appear more than once in a given header field. Directives are either optional or required, as stipulated in their definitions.",
      "ja": "2. 同じpin-directive-nameを持つpin-directives（下記参照）を除いて、特定のディレクティブは特定のヘッダーフィールドに複数回出現してはなりません（MUST NOT）。ディレクティブは、その定義で規定されているように、オプションまたは必須です。"
    },
    {
      "indent": 3,
      "text": "3. Directive names are case insensitive.",
      "ja": "3. ディレクティブ名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "4. UAs MUST ignore any header fields containing directives, or other header field value data, that do not conform to the syntax defined in this specification. In particular, UAs must not attempt to fix malformed header fields.",
      "ja": "4. UAは、この仕様で定義されている構文に準拠していないディレクティブを含むヘッダーフィールドやその他のヘッダーフィールド値データを無視する必要があります。特に、UAは不正なヘッダーフィールドの修正を試みてはなりません。"
    },
    {
      "indent": 3,
      "text": "5. If a header field contains any directive(s) the UA does not recognize, the UA MUST ignore those directives.",
      "ja": "5. ヘッダーフィールドにUAが認識しないディレクティブが含まれている場合、UAはそれらのディレクティブを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "6. If the PKP or PKP-RO header field otherwise satisfies the above requirements (1 through 5), the UA MUST process the directives it recognizes.",
      "ja": "6. PKPまたはPKP-ROヘッダーフィールドが上記以外の要件（1〜5）を満たしている場合、UAは認識したディレクティブを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additional directives extending the semantic functionality of the header fields can be defined in other specifications. The first such specification will need to define a registry for such directives. Such future directives will be ignored by UAs implementing only this specification, as well as by generally non-conforming UAs.",
      "ja": "ヘッダーフィールドのセマンティック機能を拡張する追加のディレクティブは、他の仕様で定義できます。最初のそのような仕様では、そのようなディレクティブのレジストリを定義する必要があります。そのような将来のディレクティブは、この仕様のみを実装するUAだけでなく、一般に非準拠のUAによって無視されます。"
    },
    {
      "indent": 3,
      "text": "When a connection passes Pin Validation using the UA's noted Pins for the host at the time, the host becomes a Known Pinned Host.",
      "ja": "ある時点でのホストのUAの注記されたピンを使用した接続がピン検証に合格すると、ホストは既知のピン留めホストになります。"
    },
    {
      "indent": 0,
      "text": "2.1.1. The Pin Directive",
      "section_title": true,
      "ja": "2.1.1. Pinディレクティブ"
    },
    {
      "indent": 3,
      "text": "The pin directive specifies a way for web host operators to indicate a cryptographic identity that should be bound to a given web host. The syntax of a pin directive is as follows:",
      "ja": "pinディレクティブは、Webホストオペレーターが特定のWebホストにバインドする必要がある暗号化IDを示す方法を指定します。 pinディレクティブの構文は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "pin-directive = pin-directive-name \"=\" pin-directive-value",
      "ja": "pin-directive = pin-directive-name \"=\" pin-directive-value"
    },
    {
      "indent": 3,
      "text": "pin-directive-name = \"pin-\" token pin-directive-value = quoted-string",
      "ja": "pin-directive-name = \"pin-\"トークンpin-directive-value = quoted-string"
    },
    {
      "indent": 22,
      "text": "Figure 2: Pin Directive Syntax",
      "ja": "図2：ピンディレクティブの構文"
    },
    {
      "indent": 3,
      "text": "In the pin-directive, the token is the name of a cryptographic hash algorithm. The only algorithm allowed at this time is \"sha256\", i.e., the hash algorithm SHA256 [RFC6234]; additional algorithms may be allowed for use in this context in the future. The quoted-string is a sequence of base 64 digits: the base64-encoded SPKI Fingerprint [RFC4648] (see Section 2.4).",
      "ja": "pinディレクティブでは、トークンは暗号化ハッシュアルゴリズムの名前です。現時点で許可されている唯一のアルゴリズムは「sha256」、つまりハッシュアルゴリズムSHA256 [RFC6234]です。追加のアルゴリズムは、将来このコンテキストでの使用が許可される可能性があります。 quoted-stringは、base 64桁のシーケンスです：base64でエンコードされたSPKIフィンガープリント[RFC4648]（セクション2.4を参照）。"
    },
    {
      "indent": 3,
      "text": "According to the processing rules of Section 2.1, the UA MUST ignore pin-directives with tokens naming hash algorithms it does not recognize. If the set of remaining effective pin-directives is empty, and if the host is a Known Pinned Host, the UA MUST cease to consider the host as a Known Pinned Host (the UA should fail open). The UA should indicate to users that the host is no longer a Known Pinned Host.",
      "ja": "セクション2.1の処理規則によれば、UAは、認識しないハッシュアルゴリズムを命名するトークンを持つピンディレクティブを無視する必要があります。残りの有効なピンディレクティブのセットが空で、ホストが既知の固定されたホストである場合、UAはそのホストを既知の固定されたホストと見なすことを中止する必要があります（UAはオープンに失敗する必要があります）。 UAは、ホストが既知のピン留めホストではなくなったことをユーザーに示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Note, per the processing rules of Section 2.1, the pin-directive-name is case insensitive.",
      "ja": "セクション2.1の処理規則に従って、pin-directive-nameは大文字と小文字を区別しません。"
    },
    {
      "indent": 0,
      "text": "2.1.2. The max-age Directive",
      "section_title": true,
      "ja": "2.1.2. max-ageディレクティブ"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" directive specifies the number of seconds after the reception of the PKP header field during which the UA SHOULD regard the host (from whom the message was received) as a Known Pinned Host.",
      "ja": "「max-age」ディレクティブは、UAがホスト（メッセージの受信元）を既知の固定ホストと見なすべきであるPKPヘッダーフィールドの受信後の秒数を指定します。"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" directive is REQUIRED to be present within a \"Public-Key-Pins\" header field. The \"max-age\" directive is meaningless within a \"Public-Key-Pins-Report-Only\" header field, and UAs MUST ignore it and not cache the header. See Section 2.3.3.",
      "ja": "「max-age」ディレクティブは、「Public-Key-Pins」ヘッダーフィールド内に存在する必要があります。 「max-age」ディレクティブは「Public-Key-Pins-Report-Only」ヘッダーフィールド内では無意味であり、UAはそれを無視し、ヘッダーをキャッシュしない必要があります。セクション2.3.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The max-age directive is REQUIRED to have a directive value, for which the syntax (after quoted-string unescaping, if necessary) is defined as:",
      "ja": "max-ageディレクティブはディレクティブ値を持つ必要があり、その構文（必要に応じて引用符で囲まれた文字列をエスケープ解除した後）は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "max-age-value = delta-seconds delta-seconds = 1*DIGIT",
      "ja": "max-age-value =デルタ秒デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 22,
      "text": "Figure 3: max-age Value Syntax",
      "ja": "図3：max-age値の構文"
    },
    {
      "indent": 3,
      "text": "delta-seconds is used as defined in [RFC7234], Section 1.2.1.",
      "ja": "[RFC7234]のセクション1.2.1で定義されているように、デルタ秒が使用されます。"
    },
    {
      "indent": 3,
      "text": "See Section 2.3.3 for limitations on the range of values for max-age.",
      "ja": "max-ageの値の範囲の制限については、2.3.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.1.3. The includeSubDomains Directive",
      "section_title": true,
      "ja": "2.1.3. includeSubDomainsディレクティブ"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL includeSubDomains directive is a valueless directive that, if present (i.e., it is \"asserted\"), signals to the UA that the Pinning Policy applies to this Pinned Host as well as any subdomains of the host's domain name.",
      "ja": "オプションのincludeSubDomainsディレクティブは、存在しない場合（つまり、「アサートされる」）、ピン留めポリシーがこのピン留めされたホストとホストのドメイン名のサブドメインに適用されることをUAに通知する、値のないディレクティブです。"
    },
    {
      "indent": 0,
      "text": "2.1.4. The report-uri Directive",
      "section_title": true,
      "ja": "2.1.4. report-uriディレクティブ"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL report-uri directive indicates the URI to which the UA SHOULD report Pin Validation failures (Section 2.6). The UA POSTs the reports to the given URI as described in Section 3.",
      "ja": "オプションのreport-uriディレクティブは、UAがピン検証エラーを報告するURIを示します（セクション2.6）。セクション3で説明されているように、UAはレポートを指定されたURIにPOSTします。"
    },
    {
      "indent": 3,
      "text": "When used in the PKP or PKP-RO headers, the presence of a report-uri directive indicates to the UA that in the event of Pin Validation failure it SHOULD POST a report to the report-uri. If the header is Public-Key-Pins, the UA should do this in addition to terminating the connection (as described in Section 2.6).",
      "ja": "PKPヘッダーまたはPKP-ROヘッダーで使用される場合、report-uriディレクティブの存在は、ピンの検証に失敗した場合に、report-uriにレポートをPOSTする必要があることをUAに示します。ヘッダーが公開キーピンである場合、UAは接続を終了することに加えてこれを行う必要があります（セクション2.6で説明）。"
    },
    {
      "indent": 3,
      "text": "Hosts may set report-uris that use HTTP or HTTPS. If the scheme in the report-uri is one that uses TLS (e.g., HTTPS), UAs MUST perform Pinning Validation when the host in the report-uri is a Known Pinned Host; similarly, UAs MUST apply HSTS if the host in the report-uri is a Known HSTS Host.",
      "ja": "ホストは、HTTPまたはHTTPSを使用するレポートURIを設定できます。 report-uriのスキームがTLS（HTTPSなど）を使用するスキームである場合、report-uriのホストが既知の固定ホストである場合、UAは固定検証を実行する必要があります。同様に、report-uriのホストが既知のHSTSホストである場合、UAはHSTSを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the report-uri need not necessarily be in the same Internet domain or web origin as the host being reported about.",
      "ja": "レポートURIは、レポート対象のホストと同じインターネットドメインまたはWebオリジンにある必要はないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD make their best effort to report Pin Validation failures to the report-uri, but they may fail to report in exceptional conditions. For example, if connecting the report-uri itself incurs a Pinning Validation failure or other certificate validation failure, the UA MUST cancel the connection. Similarly, if Known Pinned Host A sets a report-uri referring to Known Pinned Host B, and if B sets a report-uri referring to A, and if both hosts fail Pin Validation, the UA SHOULD detect and break the loop by failing to send reports to and about those hosts.",
      "ja": "UAは、ピン検証の失敗をreport-uriに報告するために最善を尽くす必要がありますが、例外的な状況では報告に失敗する可能性があります。たとえば、report-uri自体の接続でピン留め検証エラーまたはその他の証明書検証エラーが発生した場合、UAは接続をキャンセルする必要があります。同様に、既知の固定ホストAが既知の固定ホストBを参照するレポートURIを設定し、BがAを参照するレポートURIを設定し、両方のホストがピン検証に失敗した場合、UAは、それらのホストに、およびそれらのホストに関するレポートを送信します。"
    },
    {
      "indent": 3,
      "text": "In any case of report failure, the UA MAY attempt to re-send the report later.",
      "ja": "レポートが失敗した場合は、UAは後でレポートを再送信しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD limit the rate at which they send reports. For example, it is unnecessary to send the same report to the same report-uri more than once per distinct set of declared Pins.",
      "ja": "UAは、レポートを送信する速度を制限する必要があります（SHOULD）。たとえば、宣言されたピンの異なるセットごとに、同じレポートを同じreport-uriに複数回送信する必要はありません。"
    },
    {
      "indent": 0,
      "text": "2.1.5. Examples",
      "section_title": true,
      "ja": "2.1.5. 例"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows some example PKP and PKP-RO response header fields. (Lines are folded to fit.)",
      "ja": "図4に、PKPおよびPKP-RO応答ヘッダーフィールドの例をいくつか示します。 （ラインは折りたたまれます。）"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=3000;\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    report-uri=\"http://example.com/pkp-report\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins-Report-Only: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    report-uri=\"https://other.example.net/pkp-report\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins:\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    max-age=259200",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins:\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    max-age=10000; includeSubDomains",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 4: HTTP Public Key Pinning (HPKP) Header Examples",
      "ja": "図4：HTTP公開キー固定（HPKP）ヘッダーの例"
    },
    {
      "indent": 0,
      "text": "2.2. Server Processing Model",
      "section_title": true,
      "ja": "2.2. サーバー処理モデル"
    },
    {
      "indent": 3,
      "text": "This section describes the processing model that Pinned Hosts implement. The model has 2 parts: (1) the processing rules for HTTP request messages received over a secure transport (e.g., authenticated, non-anonymous TLS); and (2) the processing rules for HTTP request messages received over non-secure transports, such as TCP.",
      "ja": "このセクションでは、固定ホストが実装する処理モデルについて説明します。モデルには2つの部分があります。（1）安全なトランスポート（認証済み、非匿名TLSなど）を介して受信されるHTTP要求メッセージの処理規則。 （2）TCPなどの非セキュアなトランスポートを介して受信されるHTTP要求メッセージの処理ルール。"
    },
    {
      "indent": 0,
      "text": "2.2.1. HTTP-over-Secure-Transport Request Type",
      "section_title": true,
      "ja": "2.2.1. HTTP-over-Secure-Transportリクエストタイプ"
    },
    {
      "indent": 3,
      "text": "When replying to an HTTP request that was conveyed over a secure transport, a Pinned Host SHOULD include in its response exactly one PKP header field, exactly one PKP-RO header field, or one of each. Each instance of either header field MUST satisfy the grammar specified in Section 2.1.",
      "ja": "安全なトランスポートを介して伝えられたHTTPリクエストに返信するとき、ピン留めホストは、その応答に1つのPKPヘッダーフィールド、1つのPKP-ROヘッダーフィールド、またはそれぞれの1つを含める必要があります。いずれかのヘッダーフィールドの各インスタンスは、セクション2.1で指定された文法を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "Establishing a given host as a Known Pinned Host, in the context of a given UA, is accomplished as follows:",
      "ja": "特定のUAのコンテキストで、特定のホストを既知の固定ホストとして確立するには、次のようにします。"
    },
    {
      "indent": 3,
      "text": "1. Over the HTTP protocol running over secure transport, by correctly returning (per this specification) at least one valid PKP header field to the UA.",
      "ja": "1. セキュアなトランスポートを介して実行されるHTTPプロトコルを介して、UAに少なくとも1つの有効なPKPヘッダーフィールドを（この仕様に従って）正しく返す。"
    },
    {
      "indent": 3,
      "text": "2. Through other mechanisms, such as a client-side preloaded Known Pinned Host List.",
      "ja": "2. クライアント側のプリロードされた既知の固定ホストリストなどの他のメカニズムを通じて。"
    },
    {
      "indent": 0,
      "text": "2.2.2. HTTP Request Type",
      "section_title": true,
      "ja": "2.2.2. HTTPリクエストタイプ"
    },
    {
      "indent": 3,
      "text": "Pinned Hosts SHOULD NOT include the PKP header field in HTTP responses conveyed over non-secure transport. UAs MUST ignore any PKP header received in an HTTP response conveyed over non-secure transport.",
      "ja": "固定ホストは、非セキュアなトランスポートを介して伝達されるHTTP応答にPKPヘッダーフィールドを含めるべきではありません（SHOULD NOT）。 UAは、非セキュアなトランスポートを介して伝達されるHTTP応答で受信されたPKPヘッダーを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. User Agent Processing Model",
      "section_title": true,
      "ja": "2.3. ユーザーエージェント処理モデル"
    },
    {
      "indent": 3,
      "text": "The UA processing model relies on parsing domain names. Note that internationalized domain names SHALL be canonicalized according to the scheme in Section 10 of [RFC6797].",
      "ja": "UA処理モデルは、ドメイン名の解析に依存しています。国際化ドメイン名は、[RFC6797]のセクション10のスキームに従って正規化する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Public-Key-Pins Response Header Field Processing",
      "section_title": true,
      "ja": "2.3.1. 公開キーピン応答ヘッダーフィールドの処理"
    },
    {
      "indent": 3,
      "text": "If the UA receives, over a secure transport, an HTTP response that includes a PKP header field conforming to the grammar specified in Section 2.1, and there are no underlying secure transport errors or warnings (see Section 2.5), the UA MUST either:",
      "ja": "UAが安全なトランスポートを介して、セクション2.1で指定された文法に準拠するPKPヘッダーフィールドを含むHTTP応答を受信し、基になる安全なトランスポートエラーまたは警告がない場合（セクション2.5を参照）、UAは次のいずれかを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Note the host as a Known Pinned Host if it is not already so noted (see Section 2.3.3),",
      "ja": "o まだ注記されていない場合は、ホストを既知の固定ホストとしてメモします（セクション2.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "or,",
      "ja": "または、"
    },
    {
      "indent": 3,
      "text": "o Update the UA's cached information for the Known Pinned Host if any of the max-age, includeSubDomains, or report-uri header field value directives convey information different from that already maintained by the UA.",
      "ja": "o max-age、includeSubDomains、またはreport-uriヘッダーフィールド値ディレクティブのいずれかが、UAによってすでに維持されているものとは異なる情報を伝える場合は、既知の固定ホストのUAのキャッシュ情報を更新します。"
    },
    {
      "indent": 3,
      "text": "The max-age value is essentially a \"time to live\" value relative to the time of the most recent observation of the PKP header field. If the max-age header field value token has a value of 0, the UA MUST remove its cached Pinning Policy information (including the includeSubDomains directive, if asserted) if the Pinned Host is Known, or, MUST NOT note this Pinned Host if it is not yet Known.",
      "ja": "max-age値は、本質的には、PKPヘッダーフィールドの最新の観測時刻に対する「存続時間」の値です。 max-ageヘッダーフィールド値トークンの値が0の場合、ピン留めホストが既知の場合、UAはキャッシュされたピン留めポリシー情報（アサートされている場合はincludeSubDomainsディレクティブを含む）を削除する必要があります。まだ知られていない。"
    },
    {
      "indent": 3,
      "text": "If a UA receives more than one PKP header field or more than one PKP-RO header field in an HTTP response message over secure transport, then the UA MUST process only the first PKP header field (if present) and only the first PKP-RO header field (if present).",
      "ja": "UAがセキュアトランスポート経由のHTTP応答メッセージで複数のPKPヘッダーフィールドまたは複数のPKP-ROヘッダーフィールドを受信する場合、UAは最初のPKPヘッダーフィールド（存在する場合）と最初のPKP-ROのみを処理する必要があります（MUST）。ヘッダーフィールド（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "If the UA receives the HTTP response over insecure transport, or if the PKP header is not a Valid Pinning Header (see Section 2.5), the UA MUST ignore any present PKP header field(s). Similarly, if the UA receives the HTTP response over insecure transport, the UA MUST ignore any present PKP-RO header field(s). The UA MUST ignore any PKP or PKP-RO header fields not conforming to the grammar specified in Section 2.1.",
      "ja": "UAが安全でないトランスポートを介してHTTP応答を受信する場合、またはPKPヘッダーが有効なピン留めヘッダーではない場合（セクション2.5を参照）、UAは現在のPKPヘッダーフィールドを無視する必要があります（MUST）。同様に、UAが安全でないトランスポートを介してHTTP応答を受信した場合、UAは現在のPKP-ROヘッダーフィールドを無視する必要があります。 UAは、セクション2.1で指定された文法に準拠していないPKPまたはPKP-ROヘッダーフィールドを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Interaction of Public-Key-Pins and Public-Key-Pins-Report-Only",
      "section_title": true,
      "ja": "2.3.2. 公開キーピンと公開キーピンレポートのみの相互作用"
    },
    {
      "indent": 3,
      "text": "A server MAY set both the \"Public-Key-Pins\" and \"Public-Key-Pins-Report-Only\" headers simultaneously. The headers do not interact with one another, but the UA MUST process the PKP header and SHOULD process both.",
      "ja": "サーバーは、「公開キーピン」と「公開キーピン-レポートのみ」の両方のヘッダーを同時に設定できます（MAY）。ヘッダーは互いに相互作用しませんが、UAはPKPヘッダーを処理する必要があり、両方を処理する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The headers are processed according to Section 2.3.1.",
      "ja": "ヘッダーはセクション2.3.1に従って処理されます。"
    },
    {
      "indent": 3,
      "text": "When the PKP-RO header is used with a report-uri, the UA SHOULD POST reports for Pin Validation failures to the indicated report-uri, although the UA MUST NOT enforce Pin Validation. That is, in the event of Pin Validation failure when the host has set the PKP-RO header, the UA performs Pin Validation to check whether or not it should POST a report, but not whether it should cause a connection failure.",
      "ja": "PKP-ROヘッダーがreport-uriとともに使用される場合、UAはピン検証を強制してはなりませんが、UAは、PIN検証の失敗について、示されたreport-uriにレポートする必要があります（SHOULD POST）。つまり、ホストがPKP-ROヘッダーを設定したときにピン検証エラーが発生した場合、UAはピン検証を実行して、レポートをPOSTする必要があるかどうかをチェックしますが、接続エラーを引き起こすかどうかはチェックしません。"
    },
    {
      "indent": 3,
      "text": "Note: There is no purpose to using the PKP-RO header without the report-uri directive. User Agents MAY discard such headers without interpreting them further.",
      "ja": "注：report-uriディレクティブなしでPKP-ROヘッダーを使用する目的はありません。ユーザーエージェントは、それらをさらに解釈することなく、そのようなヘッダーを破棄してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "When the PKP header is used with a report-uri, the UA SHOULD POST reports for Pin Validation failures to the indicated report-uri, as well as enforce Pin Validation.",
      "ja": "PKPヘッダーがreport-uriと共に使用される場合、UAは、PIN検証を強制するだけでなく、PIN検証の失敗について、示されたreport-uriにPOUレポートを送信する必要があります（SHOULD POST）。"
    },
    {
      "indent": 3,
      "text": "If a host sets the PKP-RO header, the UA SHOULD note the Pins and directives given in the PKP-RO header, ignoring any max-age directive. If the UA does note the Pins and directives in the PKP-RO header, it SHOULD evaluate the specified policy and SHOULD report any would-be Pin Validation failures that would occur if the report-only policy were enforced.",
      "ja": "ホストがPKP-ROヘッダーを設定する場合、UAは、max-ageディレクティブを無視して、PKP-ROヘッダーで指定されたピンとディレクティブに注意する必要があります。 UAがPKP-ROヘッダーのピンとディレクティブに注意する場合、指定されたポリシーを評価し、レポートのみのポリシーが適用された場合に発生する可能性のあるピン検証エラーを報告する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If a host sets both the PKP header and the PKP-RO header, the UA MUST note and enforce Pin Validation as specified by the PKP header, and SHOULD process the Pins and directives given in the PKP-RO header. If the UA does process the Pins and directives in the PKP-RO header, it SHOULD evaluate the specified policy and SHOULD report any would-be Pin Validation failures that would occur if the report-only policy were enforced.",
      "ja": "ホストがPKPヘッダーとPKP-ROヘッダーの両方を設定する場合、UAは、PKPヘッダーで指定されたピンの検証に注意して実施し、PKP-ROヘッダーで指定されたピンとディレクティブを処理する必要があります（SHOULD）。 UAがPKP-ROヘッダー内のピンとディレクティブを処理する場合、指定されたポリシーを評価し、レポートのみのポリシーが適用された場合に発生する可能性のあるピン検証エラーを報告する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Noting a Pinned Host - Storage Model",
      "section_title": true,
      "ja": "2.3.3. ピン留めされたホストへの注意-ストレージモデル"
    },
    {
      "indent": 3,
      "text": "The Effective Pin Date of a Known Pinned Host is the time that the UA observed a Valid Pinning Header for the host. The Effective Expiration Date of a Known Pinned Host is the Effective Pin Date plus the max-age. A Known Pinned Host is \"expired\" if the Effective Expiration Date refers to a date in the past. The UA MUST ignore any expired Known Pinned Hosts in its cache.",
      "ja": "既知の固定されたホストの有効な固定日は、UAがホストの有効な固定ピンヘッダーを観察した時間です。既知のピン留めされたホストの有効期限は、有効ピン日付に最大年齢を加えたものです。有効な有効期限が過去の日付を参照している場合、既知の固定ホストは「期限切れ」になります。 UAは、キャッシュ内の期限切れの既知の固定ホストを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, if a UA is beginning to perform Pin Validation for a Known Pinned Host and finds that the cached pinning information for the host indicates an Effective Expiration Date in the past, the UA MUST NOT continue with Pin Validation for the host, and MUST consider the host to no longer be a Known Pinned Host.",
      "ja": "たとえば、UAが既知の固定ホストのピン検証を実行し始め、キャッシュされたホストの固定情報が過去の有効期限を示している場合、UAはホストのピン検証を続行してはならず、ホストが既知の固定ホストではなくなったと見なします。"
    },
    {
      "indent": 3,
      "text": "Known Pinned Hosts are identified only by domain names, and never IP addresses. If the substring matching the host production from the Request-URI (of the message to which the host responded) syntactically matches the IP-literal or IPv4address productions from Section 3.2.2 of [RFC3986], then the UA MUST NOT note this host as a Known Pinned Host.",
      "ja": "既知の固定ホストは、ドメイン名によってのみ識別され、IPアドレスは識別されません。 （ホストが応答したメッセージの）Request-URIからのホストプロダクションと一致するサブストリングが構文的に[RFC3986]のセクション3.2.2からのIPリテラルまたはIPv4addressプロダクションと一致する場合、UAはこのホストを既知の固定ホスト。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the substring does not congruently match an existing Known Pinned Host's domain name, per the matching procedure specified in Section 8.2 of [RFC6797], then the UA MUST add this host to the Known Pinned Host cache. The UA caches:",
      "ja": "それ以外の場合、サブストリングが既存の既知の固定ホストのドメイン名と一致しない場合、[RFC6797]のセクション8.2で指定された一致手順に従って、UAはこのホストを既知の固定ホストキャッシュに追加する必要があります。 UAは以下をキャッシュします："
    },
    {
      "indent": 3,
      "text": "o the Pinned Host's domain name,",
      "ja": "o 固定ホストのドメイン名、"
    },
    {
      "indent": 3,
      "text": "o the Effective Expiration Date, or enough information to calculate it (the Effective Pin Date and the value of the max-age directive),",
      "ja": "o 有効期限、またはそれを計算するのに十分な情報（有効PINの日付とmax-ageディレクティブの値）、"
    },
    {
      "indent": 3,
      "text": "o whether or not the includeSubDomains directive is asserted, and",
      "ja": "o includeSubDomainsディレクティブがアサートされているかどうか"
    },
    {
      "indent": 3,
      "text": "o the value of the report-uri directive, if present.",
      "ja": "o 存在する場合、report-uriディレクティブの値"
    },
    {
      "indent": 3,
      "text": "If any other metadata from optional or future PKP header directives are present in the Valid Pinning Header, and the UA understands them, the UA MAY note them as well.",
      "ja": "オプションまたは将来のPKPヘッダーディレクティブからのその他のメタデータが有効ピンニングヘッダーに存在し、UAがそれらを理解している場合、UAはそれらにも注意を払う場合があります。"
    },
    {
      "indent": 3,
      "text": "UAs MAY set an upper limit on the value of max-age, so that UAs that have noted erroneous Pins (whether by accident or due to attack) have some chance of recovering over time. If the server sets a max-age greater than the UA's upper limit, the UA MAY behave as if the server set the max-age to the UA's upper limit. For example, if the UA caps max-age at 5,184,000 seconds (60 days), and a Pinned Host sets a max-age directive of 90 days in its Valid Pinning Header, the UA MAY behave as if the max-age were effectively 60 days. (One way to achieve this behavior is for the UA to simply store a value of 60 days instead of the 90-day value provided by the Pinned Host.) For UA implementation guidance on how to select a maximum max-age, see Section 4.1.",
      "ja": "UAはmax-ageの値に上限を設定することができるので、誤ったピンを（偶然に、または攻撃により）認識したUAは、時間の経過とともに回復する可能性があります。サーバーがUAの上限より大きいmax-ageを設定した場合、UAはサーバーがmax-ageをUAの上限に設定した場合と同様に動作する場合があります。たとえば、UAがmax-ageの上限を5,184,000秒（60日）とし、Pinned Hostが有効なPinningヘッダーに90日のmax-ageディレクティブを設定した場合、UAはmax-ageが事実上60であるかのように動作する場合があります。日々。 （この動作を実現する1つの方法は、UAがピン留めホストによって提供される90日の値ではなく60日の値を単に格納することです。）最大マックスエージを選択する方法のUA実装ガイダンスについては、セクション4.1を参照してください。 。"
    },
    {
      "indent": 3,
      "text": "The UA MUST NOT modify any pinning metadata of any superdomain matched Known Pinned Host.",
      "ja": "UAは、既知の固定ホストと一致するスーパードメインの固定メタデータを変更してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The UA MUST NOT cache information derived from a PKP-RO header. (PKP-RO headers are useful only at the time of receipt and processing.)",
      "ja": "UAは、PKP-ROヘッダーから派生した情報をキャッシュしてはなりません（MUST NOT）。 （PKP-ROヘッダーは、受信および処理時にのみ役立ちます。）"
    },
    {
      "indent": 0,
      "text": "2.3.4. HTTP-Equiv <Meta> Element Attribute",
      "section_title": true,
      "ja": "2.3.4. HTTP-Equiv <Meta>要素の属性"
    },
    {
      "indent": 3,
      "text": "UAs MUST NOT heed http-equiv=\"Public-Key-Pins\" or http-equiv=\"Public-Key-Pins-Report-Only\" attribute settings on <meta> elements [W3C.REC-html401-19991224] in received content.",
      "ja": "UAは、受信したコンテンツの<meta>要素[W3C.REC-html401-19991224]のhttp-equiv = \"Public-Key-Pins\"またはhttp-equiv = \"Public-Key-Pins-Report-Only\"属性設定に注意してはなりません（MUST NOT） 。"
    },
    {
      "indent": 0,
      "text": "2.4. Semantics of Pins",
      "section_title": true,
      "ja": "2.4. ピンの意味論"
    },
    {
      "indent": 3,
      "text": "An SPKI Fingerprint is defined as the output of a known cryptographic hash algorithm whose input is the DER-encoded ASN.1 representation of the Subject Public Key Info (SPKI) of an X.509 certificate. A Pin is defined as the combination of the known algorithm identifier and the SPKI Fingerprint computed using that algorithm.",
      "ja": "SPKIフィンガープリントは、X.509証明書のサブジェクト公開キー情報（SPKI）のDERエンコードされたASN.1表現である既知の暗号化ハッシュアルゴリズムの出力として定義されます。ピンは、既知のアルゴリズム識別子とそのアルゴリズムを使用して計算されたSPKIフィンガープリントの組み合わせとして定義されます。"
    },
    {
      "indent": 3,
      "text": "The SPKI Fingerprint is encoded in base 64 for use in an HTTP header [RFC4648].",
      "ja": "SPKIフィンガープリントは、HTTPヘッダー[RFC4648]で使用するためにbase 64でエンコードされています。"
    },
    {
      "indent": 3,
      "text": "In this version of the specification, the known cryptographic hash algorithm is SHA-256, identified as \"sha256\" [RFC6234]. (Future specifications may add new algorithms and deprecate old ones.) UAs MUST ignore Pins for which they do not recognize the algorithm identifier. UAs MUST continue to process the rest of a PKP response header field and note Pins for algorithms they do recognize.",
      "ja": "このバージョンの仕様では、既知の暗号化ハッシュアルゴリズムはSHA-256であり、「sha256」[RFC6234]として識別されます。 （将来の仕様では、新しいアルゴリズムが追加され、古いアルゴリズムが廃止される可能性があります。）UAは、アルゴリズム識別子を認識しないピンを無視する必要があります。 UAは残りのPKP応答ヘッダーフィールドを処理し続け、認識したアルゴリズムのピンを記録する必要があります。"
    },
    {
      "indent": 3,
      "text": "Figure 5 reproduces the definition of the SubjectPublicKeyInfo structure in [RFC5280].",
      "ja": "図5は、[RFC5280]のSubjectPublicKeyInfo構造の定義を再現したものです。"
    },
    {
      "indent": 3,
      "text": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n    algorithm            AlgorithmIdentifier,\n    subjectPublicKey     BIT STRING  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AlgorithmIdentifier  ::=  SEQUENCE  {\n    algorithm            OBJECT IDENTIFIER,\n    parameters           ANY DEFINED BY algorithm OPTIONAL  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 5: SPKI Definition",
      "ja": "図2：Speakyの定義"
    },
    {
      "indent": 3,
      "text": "If the certificate's Subject Public Key Info is incomplete when taken in isolation, such as when holding a DSA key without domain parameters, a public key pin cannot be formed.",
      "ja": "ドメインパラメータなしでDSA鍵を保持している場合など、証明書のサブジェクト公開鍵情報が単独で不完全な場合、公開鍵ピンを形成できません。"
    },
    {
      "indent": 3,
      "text": "We pin public keys, rather than entire certificates, to enable operators to generate new certificates containing old public keys (see [why-pin-key]).",
      "ja": "オペレーターが古い公開鍵を含む新しい証明書を生成できるように、証明書全体ではなく公開鍵を固定します（[why-pin-key]を参照）。"
    },
    {
      "indent": 3,
      "text": "See Appendix A for an example non-normative program that generates SPKI Fingerprints from certificates.",
      "ja": "証明書からSPKIフィンガープリントを生成する非規範的なプログラムの例については、付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "2.5. Noting Pins",
      "section_title": true,
      "ja": "2.5. 記ピン"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the PKP response header field, the UA notes the host as a Known Pinned Host, storing the Pins and their associated directives in non-volatile storage (for example, along with the HSTS metadata). The Pins and their associated directives are collectively known as Pinning Metadata.",
      "ja": "PKP応答ヘッダーフィールドを受信すると、UAはホストを既知の固定ホストとして認識し、ピンとそれに関連するディレクティブを（たとえば、HSTSメタデータとともに）不揮発性ストレージに保存します。ピンとそれに関連するディレクティブは、まとめてピンニングメタデータと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The UA MUST note the Pins for a Host if and only if all three of the following conditions hold:",
      "ja": "UAは、次の3つの条件がすべて満たされた場合に限り、ホストのピンに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "o It received the PKP response header field over an error-free TLS connection. If the host is a Pinned Host, this includes the validation added in Section 2.6.",
      "ja": "o エラーのないTLS接続を介してPKP応答ヘッダーフィールドを受信しました。ホストが固定ホストの場合、これにはセクション2.6で追加された検証が含まれます。"
    },
    {
      "indent": 3,
      "text": "o The TLS connection was authenticated with a certificate chain containing at least one of the SPKI structures indicated by at least one of the given SPKI Fingerprints (see Section 2.6).",
      "ja": "o TLS接続は、特定のSPKIフィンガープリントの少なくとも1つによって示されるSPKI構造の少なくとも1つを含む証明書チェーンで認証されました（セクション2.6を参照）。"
    },
    {
      "indent": 3,
      "text": "o The given set of Pins contains at least one Pin that does NOT refer to an SPKI in the certificate chain. (That is, the host must set a Backup Pin; see Section 4.3.)",
      "ja": "o 指定されたピンのセットには、証明書チェーン内のSPKIを参照しないピンが少なくとも1つ含まれています。 （つまり、ホストはバックアップピンを設定する必要があります。セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "If the PKP response header field does not meet all three of these criteria, the UA MUST NOT note the host as a Pinned Host. A PKP response header field that meets all these criteria is known as a Valid Pinning Header.",
      "ja": "PKP応答ヘッダーフィールドがこれらの3つの基準すべてを満たさない場合、UAはホストをピン留めホストとして認識してはなりません（MUST NOT）。これらすべての基準を満たすPKP応答ヘッダーフィールドは、有効ピンニングヘッダーと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Whenever a UA receives a Valid Pinning Header, it MUST set its Pinning Metadata to the exact Pins, Effective Expiration Date (computed from max-age), and (if any) report-uri given in the most recently received Valid Pinning Header.",
      "ja": "UAが有効なピン留めヘッダーを受信するときは常に、そのピン留めメタデータを正確なピン、有効期限（max-ageから計算）、および（もしあれば）最後に受信した有効なピン留めヘッダーで指定されたレポートURIに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For forward compatibility, the UA MUST ignore any unrecognized PKP and PKP-RO header directives, while still processing those directives it does recognize. Section 2.1 specifies the directives max-age, Pins, includeSubDomains, and report-uri, but future specifications and implementations might use additional directives.",
      "ja": "上位互換性のために、UAは認識されないディレクティブを処理しながら、認識されないPKPおよびPKP-ROヘッダーディレクティブを無視する必要があります。セクション2.1では、ディレクティブmax-age、Pins、includeSubDomains、およびreport-uriを指定していますが、将来の仕様および実装では、追加のディレクティブが使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a PKP-RO response header field, the UA SHOULD evaluate the policy expressed in the field, and SHOULD generate and send a report (see Section 3). However, failure to validate the Pins in the field MUST have no effect on the validity or non-validity of the policy expressed in the PKP field or in previously noted Pins for the Known Pinned Host.",
      "ja": "PKP-RO応答ヘッダーフィールドを受信すると、UAはフィールドで表現されたポリシーを評価し（SHOULD）、レポートを生成して送信する必要があります（セクション3を参照）。ただし、フィールド内のピンの検証に失敗しても、PKPフィールドまたは前述の既知の固定ホストのピンで表現されたポリシーの有効性または非有効性に影響を与えてはなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "The UA need not note any Pins or other policy expressed in the PKP-RO response header field, except for the purpose of determining that it has already sent a report for a given policy. UAs SHOULD make a best effort not to inundate report-uris with redundant reports.",
      "ja": "UAは、PKP-RO応答ヘッダーフィールドで表現されたピンまたはその他のポリシーに注意する必要はありません。ただし、所定のポリシーのレポートをすでに送信したことを確認する目的を除きます。 UAは、冗長なレポートでレポートURIが溢れないように最善の努力をする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6. Validating Pinned Connections",
      "section_title": true,
      "ja": "2.6. ピン接続の検証"
    },
    {
      "indent": 3,
      "text": "When a UA connects to a Pinned Host using a TLS connection, if the TLS connection has errors, the UA MUST terminate the connection without allowing the user to proceed anyway. (This behavior is the same as that required by [RFC6797].)",
      "ja": "UAがTLS接続を使用してピン留めホストに接続するとき、TLS接続にエラーがある場合、UAはユーザーがとにかく進むことを許可せずに接続を終了する必要があります。 （この振る舞いは[RFC6797]で要求される振る舞いと同じです。）"
    },
    {
      "indent": 3,
      "text": "If the connection has no errors, then the UA will determine whether to apply a new, additional correctness check: Pin Validation. A UA SHOULD perform Pin Validation whenever connecting to a Known Pinned Host, as soon as possible (e.g., immediately after receiving the Server Certificate message). It is acceptable to allow Pin Validation to be disabled for some Hosts according to local policy. For example, a UA may disable Pin Validation for Pinned Hosts whose validated certificate chain terminates at a user-defined trust anchor, rather than a trust anchor built-in to the UA (or underlying platform).",
      "ja": "接続にエラーがない場合、UAは新しい追加の正当性チェックであるピンの検証を適用するかどうかを決定します。 UAは、既知の固定されたホストに接続するときはいつでも（たとえば、サーバー証明書メッセージを受信した直後に）、ピンの検証を実行する必要があります（SHOULD）。ローカルポリシーに従って、一部のホストでピン検証を無効にしても問題ありません。たとえば、UAは、検証された証明書チェーンがUA（または基盤となるプラットフォーム）に組み込まれたトラストアンカーではなく、ユーザー定義のトラストアンカーで終了する固定ホストのピン検証を無効にする場合があります。"
    },
    {
      "indent": 3,
      "text": "To perform Pin Validation, the UA will compute the SPKI Fingerprints for each certificate in the Pinned Host's validated certificate chain, using each supported hash algorithm for each certificate. (As described in Section 2.4, certificates whose SPKI cannot be taken in isolation cannot be pinned.) The UA MUST ignore superfluous certificates in the chain that do not form part of the validating chain. The UA will then check that the set of these SPKI Fingerprints intersects the set of SPKI Fingerprints in that Pinned Host's Pinning Metadata. If there is set intersection, the UA continues with the connection as normal. Otherwise, the UA MUST treat this Pin Validation failure as a non-recoverable error. Any procedure that matches the results of this Pin Validation procedure is considered equivalent.",
      "ja": "ピンの検証を実行するために、UAは、証明書ごとにサポートされている各ハッシュアルゴリズムを使用して、ピン留めされたホストの検証済み証明書チェーン内の証明書ごとにSPKIフィンガープリントを計算します。 （セクション2.4で説明されているように、SPKIを分離して取得できない証明書は固定できません。）UAは、検証チェーンの一部を形成しないチェーン内の余分な証明書を無視する必要があります。次に、UAは、これらのSPKIフィンガープリントのセットが、ピン留めされたホストのピン留めメタデータのSPKIフィンガープリントのセットと交差することを確認します。交差点が設定されている場合、UAは通常どおり接続を続行します。それ以外の場合、UAはこのピン検証エラーを回復不可能なエラーとして処理する必要があります。このピン検証手順の結果と一致する手順はすべて同等と見なされます。"
    },
    {
      "indent": 3,
      "text": "A UA that has previously noted a host as a Known Pinned Host MUST perform Pin Validation when setting up the TLS session, before beginning an HTTP conversation over the TLS channel.",
      "ja": "以前に既知の固定ホストとしてホストを指摘したUAは、TLSチャネルを介したHTTP会話を開始する前に、TLSセッションを設定するときにピン検証を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "UAs send validation failure reports only when Pin Validation is actually in effect. Pin Validation might not be in effect, e.g., because the user has elected to disable it, or because a presented certificate chain chains up to a user-defined trust anchor. In such cases, UAs SHOULD NOT send reports.",
      "ja": "UAは、Pin Validationが実際に有効な場合にのみ、検証失敗レポートを送信します。ピンの検証が有効でない可能性があります。たとえば、ユーザーが無効にしたか、提示された証明書チェーンがユーザー定義のトラストアンカーにチェーンされているためです。そのような場合、UAはレポートを送信すべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.7. Interactions with Preloaded Pin Lists",
      "section_title": true,
      "ja": "2.7. プリロードされたピンリストとの相互作用"
    },
    {
      "indent": 3,
      "text": "UAs MAY choose to implement additional sources of pinning information, such as through built-in lists of pinning information. Such UAs should allow users to override such additional sources, including disabling them from consideration.",
      "ja": "UAは、固定情報の組み込みリストなどを通じて、追加の固定情報ソースを実装することを選択できます。そのようなUAは、ユーザーが考慮からそれらを無効にすることを含め、そのような追加のソースを上書きできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The effective policy for a Known Pinned Host that has both built-in Pins and Pins from previously observed PKP header response fields is implementation-defined.",
      "ja": "組み込みのピンと以前に観察されたPKPヘッダー応答フィールドからのピンの両方を持つ既知の固定ホストの有効なポリシーは、実装によって定義されます。"
    },
    {
      "indent": 0,
      "text": "2.8. Pinning Self-Signed End Entities",
      "section_title": true,
      "ja": "2.8. 自己署名エンドエンティティの固定"
    },
    {
      "indent": 3,
      "text": "If UAs accept hosts that authenticate themselves with self-signed end entity certificates, they MAY also allow hosts to pin the public keys in such certificates. The usability and security implications of this practice are outside the scope of this specification.",
      "ja": "UAが自己署名のエンドエンティティ証明書で自分自身を認証するホストを受け入れる場合、ホストがそのような証明書に公開鍵を固定することも許可する場合があります。このプラクティスの使いやすさとセキュリティへの影響は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3. Reporting Pin Validation Failure",
      "section_title": true,
      "ja": "3. ピン検証エラーの報告"
    },
    {
      "indent": 3,
      "text": "When a Known Pinned Host has set the report-uri directive, the UA SHOULD report Pin Validation failures to the indicated URI. The UA does this by POSTing a JSON [RFC7159] message to the URI; the JSON message takes this form:",
      "ja": "既知の固定されたホストがreport-uriディレクティブを設定した場合、UAは指定されたURIにピン検証エラーを報告する必要があります（SHOULD）。 UAは、JSON [RFC7159]メッセージをURIにPOSTすることでこれを行います。 JSONメッセージは次の形式を取ります。"
    },
    {
      "indent": 3,
      "text": "{\n  \"date-time\": date-time,\n  \"hostname\": hostname,\n  \"port\": port,\n  \"effective-expiration-date\": expiration-date,\n  \"include-subdomains\": include-subdomains,\n  \"noted-hostname\": noted-hostname,\n  \"served-certificate-chain\": [\n    pem1, ... pemN\n  ],\n  \"validated-certificate-chain\": [\n    pem1, ... pemN\n  ],\n  \"known-pins\": [\n    known-pin1, ... known-pinN\n  ]\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 6: JSON Report Format",
      "ja": "図6：JSONレポートの形式"
    },
    {
      "indent": 3,
      "text": "Whitespace outside of quoted strings is not significant. The key/ value pairs may appear in any order, but each MUST appear only once.",
      "ja": "引用された文字列の外側の空白は重要ではありません。キーと値のペアは任意の順序で出現できますが、それぞれが1回だけ出現する必要があります。"
    },
    {
      "indent": 3,
      "text": "The date-time indicates the time the UA observed the Pin Validation failure. It is provided as a string formatted according to Section 5.6, \"Internet Date/Time Format\", of [RFC3339].",
      "ja": "date-timeは、UAがPin Validationの失敗を検出した時間を示します。 [RFC3339]のセクション5.6「Internet Date / Time Format」に従ってフォーマットされた文字列として提供されます。"
    },
    {
      "indent": 3,
      "text": "The hostname is the hostname to which the UA made the original request that failed Pin Validation. It is provided as a string.",
      "ja": "ホスト名は、UAがPin Validationに失敗した元のリクエストを送信したホスト名です。文字列として提供されます。"
    },
    {
      "indent": 3,
      "text": "The port is the port to which the UA made the original request that failed Pin Validation. It is provided as an integer.",
      "ja": "ポートは、UAがPin Validationに失敗した元のリクエストを送信したポートです。整数として提供されます。"
    },
    {
      "indent": 3,
      "text": "The effective-expiration-date is the Effective Expiration Date for the noted Pins. It is provided as a string formatted according to Section 5.6, \"Internet Date/Time Format\", of [RFC3339].",
      "ja": "effective-expiration-dateは、指摘されたピンの有効期限です。 [RFC3339]のセクション5.6「Internet Date / Time Format」に従ってフォーマットされた文字列として提供されます。"
    },
    {
      "indent": 3,
      "text": "include-subdomains indicates whether or not the UA has noted the includeSubDomains directive for the Known Pinned Host. It is provided as one of the JSON identifiers \"true\" or \"false\".",
      "ja": "include-subdomainsは、UAが既知の固定されたホストのincludeSubDomainsディレクティブを認識しているかどうかを示します。 JSON識別子「true」または「false」のいずれかとして提供されます。"
    },
    {
      "indent": 3,
      "text": "noted-hostname indicates the hostname that the UA noted when it noted the Known Pinned Host. This field allows operators to understand why Pin Validation was performed for, e.g., foo.example.com when the noted Known Pinned Host was example.com with includeSubDomains set.",
      "ja": "notes-hostnameは、UAが既知の固定されたホストをメモしたときにUAがメモしたホスト名を示します。このフィールドにより、オペレーターは、例えば、既知のピン留めされたホストがincludeSubDomainsが設定されたexample.comである場合に、foo.example.comなどに対してピン検証が実行された理由を理解できます。"
    },
    {
      "indent": 3,
      "text": "The served-certificate-chain is the certificate chain, as served by the Known Pinned Host during TLS session setup. It is provided as an array of strings; each string pem1, ... pemN is the Privacy-Enhanced Mail (PEM) representation of each X.509 certificate as described in [RFC7468].",
      "ja": "提供される証明書チェーンは、TLSセッションのセットアップ中に既知の固定ホストによって提供される証明書チェーンです。文字列の配列として提供されます。各文字列pem1、... pemNは、[RFC7468]で説明されている各X.509証明書のプライバシー強化メール（PEM）表現です。"
    },
    {
      "indent": 3,
      "text": "The validated-certificate-chain is the certificate chain, as constructed by the UA during certificate chain verification. (This may differ from the served-certificate-chain.) It is provided as an array of strings; each string pem1, ... pemN is the PEM representation of each X.509 certificate as described in [RFC7468]. UAs that build certificate chains in more than one way during the validation process SHOULD send the last chain built. In this way, they can avoid keeping too much state during the validation process.",
      "ja": "検証済みの証明書チェーンは、証明書チェーンの検証中にUAによって構築される証明書チェーンです。 （これは、サーブされた証明書チェーンとは異なる場合があります。）文字列の配列として提供されます。各文字列pem1、... pemNは、[RFC7468]で説明されている各X.509証明書のPEM表現です。検証プロセス中に複数の方法で証明書チェーンを構築するUAは、構築された最後のチェーンを送信する必要があります（SHOULD）。このようにして、検証プロセス中に過剰な状態を維持することを回避できます。"
    },
    {
      "indent": 3,
      "text": "The known-pins are the Pins that the UA has noted for the Known Pinned Host. They are provided as an array of strings with the syntax:",
      "ja": "既知のピンとは、UAが既知の固定されたホスト用にメモしたピンです。これらは、次の構文で文字列の配列として提供されます。"
    },
    {
      "indent": 3,
      "text": "known-pin = token \"=\" quoted-string",
      "ja": "既知のピン=トークン \"=\"引用文字列"
    },
    {
      "indent": 24,
      "text": "Figure 7: Known Pin Syntax",
      "ja": "図7：既知のピン構文"
    },
    {
      "indent": 3,
      "text": "As in Section 2.4, the token refers to the algorithm name, and the quoted-string refers to the base64 encoding of the SPKI Fingerprint. When formulating the JSON POST body, the UA MUST either use single-quoted JSON strings or use double-quoted JSON strings and backslash-escape the embedded double quotes in the quoted-string part of the known-pin.",
      "ja": "セクション2.4と同様に、トークンはアルゴリズム名を指し、quoted-stringはSPKIフィンガープリントのbase64エンコーディングを指します。 JSON POST本文を作成するとき、UAは単一引用符で囲まれたJSON文字列を使用するか、二重引用符で囲まれたJSON文字列を使用し、既知のピンの引用符で囲まれた文字列部分に埋め込まれた二重引用符をバックスラッシュでエスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "Figure 8 shows an example of a Pin Validation failure report. (PEM strings are shown on multiple lines for readability.)",
      "ja": "図8は、Pin Validation failureレポートの例を示しています。 （読みやすくするために、PEM文字列は複数行に表示されています。）"
    },
    {
      "indent": 2,
      "text": "{\n  \"date-time\": \"2014-04-06T13:00:50Z\",\n  \"hostname\": \"www.example.com\",\n  \"port\": 443,\n  \"effective-expiration-date\": \"2014-05-01T12:40:50Z\"\n  \"include-subdomains\": false,\n  \"served-certificate-chain\": [\n    \"-----BEGIN CERTIFICATE-----\\n\n    MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n    ...\n    HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n    WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n    yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n    -----END CERTIFICATE-----\",\n    ...\n  ],\n  \"validated-certificate-chain\": [\n    \"-----BEGIN CERTIFICATE-----\\n\n    MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n    ...\n    HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n    WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n    yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n    -----END CERTIFICATE-----\",\n    ...\n  ],\n  \"known-pins\": [\n    'pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\"',\n    \"pin-sha256=\\\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\\\"\"\n  ]\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 8: Pin Validation Failure Report Example",
      "ja": "図8：ピン検証エラーレポートの例"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Pinning public keys helps hosts strongly assert their cryptographic identity even in the face of issuer error, malfeasance, or compromise. But, there is some risk that a host operator could lose (or lose control of) their host's private key (such as by operator error or host compromise). If the operator had pinned only the key of the host's end-entity certificate, the operator would not be able to serve their web site or application in a way that UAs would trust for the duration of their pin's max-age. (Recall that UAs MUST close the connection to a host upon Pin Failure.)",
      "ja": "公開キーを固定すると、発行者のエラー、不正行為、または侵害に直面しても、ホストが暗号化IDを強く主張するのに役立ちます。ただし、ホストオペレーターが（オペレーターのエラーやホストの侵害などにより）ホストの秘密キーを失う（または制御を失う）可能性があるというリスクがあります。オペレーターがホストのエンドエンティティ証明書のキーのみを固定した場合、オペレーターは、ピンの最大有効期間中、UAが信頼する方法でWebサイトまたはアプリケーションを提供できません。 （UAはピン障害時にホストへの接続を閉じる必要があることを思い出してください。）"
    },
    {
      "indent": 3,
      "text": "Therefore, there is a necessary trade-off between two competing goods: pin specificity and maximal reduction of the scope of issuers on the one hand; and flexibility and resilience of the host's cryptographic identity on the other hand. One way to resolve this trade-off is to compromise by pinning to the key(s) of the issuer(s) of the host's end-entity certificate(s). Often, a valid certificate chain will have at least two certificates above the end-entity certificate: the intermediate issuer and the trust anchor. Operators can pin any one or more of the public keys in this chain, and indeed MUST pin to issuers not in the chain (as, for example, a Backup Pin). Pinning to an intermediate issuer, or even to a trust anchor or root, still significantly reduces the number of issuers who can issue end-entity certificates for the Known Pinned Host, while still giving that host flexibility to change keys without a disruption of service.",
      "ja": "したがって、2つの競合する商品の間には必要なトレードオフがあります。ピンの特異性と、一方で発行者の範囲の最大の削減です。一方、ホストの暗号化IDの柔軟性と回復力。このトレードオフを解決する1つの方法は、ホストのエンドエンティティ証明書の発行者のキーにピン留めして妥協することです。多くの場合、有効な証明書チェーンには、エンドエンティティ証明書の上に、中間発行者とトラストアンカーという2つの証明書があります。オペレーターは、このチェーン内の任意の1つ以上の公開キーをピン留めすることができ、実際には、チェーン内にない発行者（たとえば、バックアップピンなど）にピン留めする必要があります。中間の発行者、またはトラストアンカーまたはルートにピン留めしても、既知のピン留めホストのエンドエンティティ証明書を発行できる発行者の数は大幅に減少しますが、サービスを中断することなくホストを柔軟に変更してキーを変更できます。"
    },
    {
      "indent": 0,
      "text": "4.1. Maximum max-age",
      "section_title": true,
      "ja": "4.1. 最大マックスエイジ"
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 2.3.3, UAs MAY cap the max-age value at some upper limit. There is a security trade-off in that low maximum values provide a narrow window of protection for users who visit the Known Pinned Host only infrequently, while high maximum values might result in a UA's inability to successfully perform Pin Validation for a Known Pinned Host if the UA's noted Pins and the host's true Pins diverge.",
      "ja": "セクション2.3.3で述べたように、UAはmax-age値に上限を設けてもよい（MAY）。最大値が小さいと、既知の固定ホストに頻繁にアクセスしないユーザーに狭い範囲の保護が提供されるというセキュリティ上のトレードオフがあります。 UAの注目ピンとホストの真のピンは分岐します。"
    },
    {
      "indent": 0,
      "text": " Such divergence could occur for several reasons, including: UA error; host operator error; network attack; or a Known Pinned Host that intentionally migrates all pinned keys, combined with a UA that has noted true Pins with a high max-age value and has not had a chance to observe the new true Pins for the host. (This last example underscores the importance for host operators to phase in new keys gradually and to set the max-age value in accordance with their planned key migration schedule.) There is probably no ideal upper limit to the max-age directive that would satisfy all use cases. However, a value on the order of 60 days (5,184,000 seconds) may be considered a balance between the two competing security concerns.",
      "ja": "このような相違は、次のようないくつかの理由で発生する可能性があります。UAエラー。ホストオペレーターエラー。ネットワーク攻撃;または、すべての固定キーを意図的に移行する既知の固定ホストと、max-age値が高い真のピンを記録し、ホストの新しい真のピンを観察する機会がなかったUAを組み合わせます。 （この最後の例は、ホストオペレーターが新しいキーを段階的に導入し、計画されたキー移行スケジュールに従ってmax-age値を設定することの重要性を強調しています。）満たすmax-ageディレクティブには、おそらく理想的な上限はありません。すべての使用例。ただし、およそ60日（5,184,000秒）の値は、2つの競合するセキュリティ上の懸念のバランスと見なすことができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Using includeSubDomains Safely",
      "section_title": true,
      "ja": "4.2. includeSubDomainsを安全に使用する"
    },
    {
      "indent": 3,
      "text": "It may happen that Pinned Hosts whose hostnames share a parent domain use different Valid Pinning Headers. If a host whose hostname is a parent domain for another host sets the includeSubDomains directive, the two hosts' Pins may conflict with each other. For example, consider two Known Pinned Hosts, example.com and subdomain.example.com. Assume example.com sets a Valid Pinning Header such as this:",
      "ja": "ホスト名が親ドメインを共有するピン留めホストが、異なる有効ピン留めヘッダーを使用する場合があります。ホスト名が別のホストの親ドメインであるホストがincludeSubDomainsディレクティブを設定すると、2つのホストのピンが互いに競合する可能性があります。たとえば、example.comとsubdomain.example.comの2つの既知の固定ホストを考えてみます。 example.comが次のような有効なピン留めヘッダーを設定するとします。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=12000; pin-sha256=\"ABC...\";\n    pin-sha256=\"DEF...\"; includeSubDomains",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 9: example.com Valid Pinning Header",
      "ja": "図9：example.comの有効なピン留めヘッダー"
    },
    {
      "indent": 3,
      "text": "Assume subdomain.example.com sets a Valid Pinning Header such as this:",
      "ja": "subdomain.example.comが次のような有効なピン留めヘッダーを設定するとします。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: pin-sha256=\"GHI...\"; pin-sha256=\"JKL...\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 10: subdomain.example.com Valid Pinning Header",
      "ja": "図10：subdomain.example.comの有効なピン留めヘッダー"
    },
    {
      "indent": 3,
      "text": "Assume a UA that has not previously noted any Pins for either of these hosts. If the UA first contacts subdomain.example.com, it will note the Pins in the Valid Pinning Header, and perform Pin Validation as normal on subsequent connections. If the UA then contacts example.com, again it will note the Pins and perform Pin Validation on future connections.",
      "ja": "これらのホストのいずれかのピンを以前に指摘していないUAを想定します。 UAが最初にsubdomain.example.comにアクセスすると、有効なピン留めヘッダーのピンが記録され、その後の接続で通常どおりピンの検証が実行されます。その後、UAがexample.comに連絡すると、ピンが記録され、今後の接続でピンの検証が実行されます。"
    },
    {
      "indent": 3,
      "text": "However, if the UA happened to visit example.com before subdomain.example.com, the UA would, due to example.com's use of the includeSubDomains directive, attempt to perform Pin Validation for subdomain.example.com using the SPKI hashes ABC... and DEF..., which are not valid for the certificate chains subdomain.example.com (which uses certificates with SPKIs GHI... and JLK...). Thus, depending on the order in which the UA observes the Valid Pinning Headers for hosts example.com and subdomain.example.com, Pin Validation might or might not fail for subdomain.example.com, even if the certificate chain the UA receives for subdomain.example.com is perfectly valid.",
      "ja": "ただし、UAがsubdomain.example.comの前にexample.comにアクセスした場合、UAはexample.comのincludeSubDomainsディレクティブの使用により、SPKIハッシュABCを使用してsubdomain.example.comのピン検証を実行しようとします。 ..およびDEF ...は、証明書チェーンsubdomain.example.com（SPKI GHI ...およびJLK ...で証明書を使用する）では無効です。したがって、UAがホストexample.comおよびsubdomain.example.comの有効なピン留めヘッダーを監視する順序に応じて、UAが受け取った証明書チェーンであっても、subdomain.example.comのピン検証は失敗する場合と失敗しない場合があります。 subdomain.example.comは完全に有効です。"
    },
    {
      "indent": 0,
      "text": " Thus, Pinned Host operators must use the includeSubDomains directive with care. For example, they may choose to use overlapping pin sets for hosts under a parent domain that uses includeSubDomains, or to not use the includeSubDomains directive in their effective-second-level domains, or to simply use the same pin set for all hosts under a given parent domain.",
      "ja": "したがって、固定ホストのオペレーターはincludeSubDomainsディレクティブを注意して使用する必要があります。たとえば、includeSubDomainsを使用する親ドメインのホストに重複するピンセットを使用するか、それらの有効な第2レベルドメインでincludeSubDomainsディレクティブを使用しないか、または単にすべてのホストに同じピンセットを使用するかを選択できます。与えられた親ドメイン。"
    },
    {
      "indent": 0,
      "text": "4.3. Backup Pins",
      "section_title": true,
      "ja": "4.3. バックアップピン"
    },
    {
      "indent": 3,
      "text": "The primary way to cope with the risk of inadvertent Pin Validation failure is to keep a Backup Pin. A Backup Pin is a fingerprint for the public key of a secondary, not-yet-deployed key pair. The operator keeps the backup key pair offline, and sets a pin for it in the PKP header. Then, in case the operator loses control of their primary private key, they can deploy the backup key pair. UAs, who have had the backup key pair pinned (when it was set in previous Valid Pinning Headers), can connect to the host without error.",
      "ja": "不注意によるピン検証エラーのリスクに対処する主な方法は、バックアップピンを保持することです。バックアップPINは、まだデプロイされていない2次キーペアの公開キーのフィンガープリントです。オペレーターはバックアップキーペアをオフラインに保ち、PKPヘッダーにそのピンを設定します。次に、オペレーターがプライマリ秘密キーの制御を失った場合に備えて、バックアップキーペアを展開できます。バックアップキーペアが固定されているUA（以前の有効な固定ヘッダーで設定されていた場合）は、エラーなしでホストに接続できます。"
    },
    {
      "indent": 3,
      "text": "Because having a backup key pair is so important to recovery, UAs MUST require that hosts set a Backup Pin (see Section 2.5). The down side of keeping a not-yet-deployed key pair is that, if an attacker gains control of the private key, she will be able to perform a MITM attack without being discovered. Operators must take care to avoid leaking the key such as keeping it offline.",
      "ja": "バックアップキーペアを持つことはリカバリにとって非常に重要であるため、UAはホストがバックアップピンを設定することを要求する必要があります（セクション2.5を参照）。まだデプロイされていないキーペアを維持することの欠点は、攻撃者が秘密キーの制御を取得した場合、発見されることなくMITM攻撃を実行できることです。オペレーターは、キーをオフラインにしておくなど、キーが漏洩しないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Interactions With Cookie Scoping",
      "section_title": true,
      "ja": "4.4. Cookieスコープとの相互作用"
    },
    {
      "indent": 3,
      "text": "HTTP cookies [RFC6265] set by a Known Pinned Host can be stolen by a network attacker who can forge web and DNS responses so as to cause a client to send the cookies to a phony subdomain of the host. To prevent this, hosts SHOULD set the \"secure\" attribute and precisely scope the \"domain\" attribute on all security-sensitive cookies, such as session cookies. These settings tell the browser that the cookie should only be sent back to the specific host(s) (and not, e.g., all subdomains of a given domain), and should only be sent over HTTPS (not HTTP).",
      "ja": "既知の固定ホストによって設定されたHTTP Cookie [RFC6265]は、クライアントがホストの偽のサブドメインにCookieを送信するようにWebおよびDNS応答を偽造できるネットワーク攻撃者に盗まれる可能性があります。これを防ぐために、ホストは「セキュア」属性を設定し、セッションCookieなどのすべてのセキュリティ依存Cookieの「ドメイン」属性を正確にスコープする必要があります（SHOULD）。これらの設定は、Cookieを特定のホストにのみ送信する必要があり（特定のドメインのすべてのサブドメインなどではなく）、HTTPS（HTTPではなく）経由でのみ送信する必要があることをブラウザーに通知します。"
    },
    {
      "indent": 0,
      "text": "4.5. Hostile Pinning",
      "section_title": true,
      "ja": "4.5. 敵対的なピン止め"
    },
    {
      "indent": 3,
      "text": "An attacker who is able to obtain a valid certificate for a domain, either through misissuance by a Certification Authority or through other means, such as being the prior owner of a given domain, may attempt to perform 'hostile' pinning. In this scenario, the attacker provides a Valid Pinning Header that pins to a set of SPKIs of the attacker's choice. If a UA has not previously noted pins for that host, it may note the attacker's pins, preventing access to the legitimate site.",
      "ja": "証明機関による誤発行、または特定のドメインの以前の所有者であるなどの他の手段のいずれかによってドメインの有効な証明書を取得できる攻撃者は、「敵対的な」ピン留めを実行しようとする可能性があります。このシナリオでは、攻撃者は、攻撃者が選択した一連のSPKIにピン留めする有効ピン留めヘッダーを提供します。 UAがそのホストのピンを以前に記録していない場合、攻撃者のピンを記録し、正当なサイトへのアクセスを妨げることがあります。"
    },
    {
      "indent": 3,
      "text": "This attack is mitigated through several means. Most prominently, the attack can only persist for the maximum max-age (see Section 4.1). Web host operators can reduce the opportunity for",
      "ja": "この攻撃は、いくつかの方法で軽減されます。最も顕著なのは、攻撃が最大max-ageまでしか持続できないことです（セクション4.1を参照）。 Webホストオペレーターは、"
    },
    {
      "indent": 3,
      "text": "attack by working to preload the host's pins within the UA. Operators may further detect such misissuance through other means, such as certificate transparency ([RFC6962]).",
      "ja": "UA内のホストのピンをプリロードするための作業による攻撃。オペレーターは、証明書の透過性（[RFC6962]）などの他の手段を通じて、このような誤発行をさらに検出できます。"
    },
    {
      "indent": 0,
      "text": "5. Privacy Considerations",
      "section_title": true,
      "ja": "5. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Hosts can use HSTS or HPKP as a \"super-cookie\", by setting distinct policies for a number of subdomains. For example, assume example.com wishes to track distinct UAs without explicitly setting a cookie, or that a previously set cookie is deleted from the UA's cookie store. Here are two attack scenarios.",
      "ja": "ホストは、HSTSまたはHPKPを「スーパーCookie」として使用できます。これには、いくつかのサブドメインに個別のポリシーを設定します。たとえば、example.comがCookieを明示的に設定せずに個別のUAを追跡したい場合や、以前に設定したCookieがUAのCookieストアから削除されたと想定します。 2つの攻撃シナリオを次に示します。"
    },
    {
      "indent": 3,
      "text": "o example.com can use report-uri and the ability to pin arbitrary identifiers to distinguish UAs.",
      "ja": "o example.comは、report-uriと任意の識別子を固定してUAを区別する機能を使用できます。"
    },
    {
      "indent": 6,
      "text": "1. example.com sets a Valid Pinning Header in its response to requests. The header asserts the includeSubDomains directive and specifies a report-uri directive as well. Pages served by the host also include references to subresource https://bad.example.com/foo.png.",
      "ja": "1. example.comは、リクエストへの応答に有効なピン留めヘッダーを設定します。ヘッダーはincludeSubDomainsディレクティブをアサートし、report-uriディレクティブも指定します。ホストによって提供されるページには、サブリソースhttps://bad.example.com/foo.pngへの参照も含まれます。"
    },
    {
      "indent": 6,
      "text": "2. The Valid Pinning Header includes a \"pin\" that is not really the hash of an SPKI but is instead an arbitrary distinguishing string sent only in response to a particular request. For each request, the host creates a new, distinct distinguishing string and sets it as if it were a pin.",
      "ja": "2. 有効なピン留めヘッダーには、実際にはSPKIのハッシュではなく、特定の要求への応答としてのみ送信される任意の識別文字列である「ピン」が含まれています。リクエストごとに、ホストは新しい区別可能な文字列を作成し、それをピンであるかのように設定します。"
    },
    {
      "indent": 6,
      "text": "3. The certificate chain served by bad.example.com does not pass Pin Validation given the pin set the host asserted in step (1). The HPKP-conforming UA attempts to report the Pin Validation failure to the specified report-uri, including the certificate chain it observed and the SPKI hashes it expected to see. Among the SPKI hashes is the distinguishing string in step (2).",
      "ja": "3. bad.example.comによって提供される証明書チェーンは、ピンがステップ（1）でアサートされたホストセットを与えられた場合、ピン検証を通過しません。 HPKPに準拠したUAは、確認された証明書チェーンとSPKIが確認するはずのハッシュを含め、指定されたレポートURIにピン検証エラーを報告しようとします。 SPKIハッシュには、ステップ（2）の識別文字列があります。"
    },
    {
      "indent": 3,
      "text": "o Different site operators/origins can optionally collaborate by setting the report-uri to be in an origin they share administrative control of. UAs MAY, therefore, refuse to send reports outside of the origin that set the PKP or PKP-RO header.",
      "ja": "o 別のサイトオペレーター/オリジンは、必要に応じて、report-uriを管理コントロールを共有するオリジンに設定することにより、コラボレーションできます。したがって、UAは、PKPまたはPKP-ROヘッダーを設定するオリジンの外部にレポートを送信することを拒否してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "o example.com can use server name indication (SNI; [RFC3546]) and subdomains to distinguish UAs.",
      "ja": "o example.comは、サーバー名表示（SNI; [RFC3546]）とサブドメインを使用してUAを区別できます。"
    },
    {
      "indent": 6,
      "text": "1. example.com sets a Valid Pinning Header in its response to requests. The header asserts the includeSubDomains directive.",
      "ja": "1. example.comは、リクエストへの応答に有効なピン留めヘッダーを設定します。ヘッダーはincludeSubDomainsディレクティブをアサートします。"
    },
    {
      "indent": 6,
      "text": "2. On a subsequent page view, the host responds with a page including the subresource https://0.fingerprint.example.com/ foo.png, and the server responds using a certificate chain that does not pass Pin Validation for the pin-set defined in the Valid Pinning Header in step (1). The HPKP-conforming UA will close the connection, never completing the request to 0.fingerprint.example.com. The host may thus note that this particular UA had noted the (good) Pins for that subdomain.",
      "ja": "2. 後続のページビューで、ホストはサブリソースhttps://0.fingerprint.example.com/ foo.pngを含むページで応答し、サーバーはピンセットのピン検証を通過しない証明書チェーンを使用して応答します手順（1）の有効なピン留めヘッダーで定義されています。 HPKP準拠のUAは接続を閉じ、0.fingerprint.example.comへの要求を完了しません。したがって、ホストは、この特定のUAがそのサブドメインの（適切な）ピンを記録したことに注意する場合があります。"
    },
    {
      "indent": 6,
      "text": "3. example.com can distinguish 2^N UAs by serving Valid Pinning Headers from an arbitrary number N distinct subdomains. For any given subdomain n.fingerprint.example.com, the host may deliver a Valid Pinning Header to one UA, but not deliver it to a different UA. The server may then change the configuration for n.fingerprint.example.com. If the UA fails to connect, it was in the set of UAs that were pinned, which can be distinguished from the UAs that were not pinned, as they will succeed in connecting. The host may repeat this for a sufficient number of subdomains necessary to distinguish individual UAs.",
      "ja": "3. example.comは、有効なピニングヘッダーを任意の数Nの異なるサブドメインから提供することにより、2 ^ N UAを区別できます。特定のサブドメインn.fingerprint.example.comの場合、ホストは有効なピン留めヘッダーを1つのUAに配信できますが、別のUAには配信できません。次に、サーバーはn.fingerprint.example.comの構成を変更します。 UAが接続に失敗した場合、それはピン接続されたUAのセット内にあり、接続に成功するため、ピン接続されなかったUAと区別できます。ホストは、個々のUAを区別するために必要な十分な数のサブドメインについてこれを繰り返すことができます。"
    },
    {
      "indent": 3,
      "text": "o Conforming implementations (as well as implementations conforming to [RFC6797]) must store state about which domains have set policies, hence which domains the UA has contacted. Because these policies cause remotely detectable behaviors, it is advisable that UAs have a way for privacy-sensitive users to clear current Pins for Pinned Hosts and that UAs allow users to query the current state of Pinned Hosts. In addition, note that because pinning a host implies a degree of persistent state, an attacker with physical access to a device may be able to recover information about hosts a user has visited, even if the user has cleared other parts of the UA's state.",
      "ja": "o 準拠する実装（および[RFC6797]に準拠する実装）は、どのドメインがポリシーを設定したか、したがってUAがアクセスしたドメインに関する状態を保存する必要があります。これらのポリシーはリモートで検出可能な動作を引き起こすため、UAにはプライバシーに敏感なユーザーがピン留めホストの現在のピンをクリアする方法があり、UAはユーザーがピン留めホストの現在の状態を照会できるようにすることをお勧めします。さらに、ホストのピン留めはある程度の永続的な状態を意味するため、デバイスに物理的にアクセスできる攻撃者は、ユーザーがUAの状態の他の部分をクリアした場合でも、ユーザーがアクセスしたホストに関する情報を回復できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Pin reports, as noted in Section 3, contains information about the certificate chain that has failed pin validation. In some cases, such as organization-wide compromise of the end-to-end security of TLS, this may include information about the interception tools and design used by the organization that the organization would otherwise prefer not be disclosed.",
      "ja": "o セクション3で説明したピンレポートには、ピンの検証に失敗した証明書チェーンに関する情報が含まれています。 TLSのエンドツーエンドのセキュリティが組織全体で侵害された場合など、場合によっては、組織が使用しない傍受ツールや設計に関する情報が含まれることがあります。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered the response headers described in this document under \"Permanent Message Header Field Names\" in the \"Message Headers\" registry [message-headers] with the following parameters:",
      "ja": "IANAは、このドキュメントで説明されているレスポンスヘッダーを、「メッセージヘッダー」レジストリ[message-headers]の「Permanent Message Header Field Names」に次のパラメーターで登録しました。"
    },
    {
      "indent": 3,
      "text": "o Header Field Names: Public-Key-Pins and Public-Key-Pins-Report-Only",
      "ja": "o ヘッダーフィールド名：Public-Key-PinsおよびPublic-Key-Pins-Report-Only"
    },
    {
      "indent": 3,
      "text": "o Protocol: http",
      "ja": "o プロトコル：http"
    },
    {
      "indent": 3,
      "text": "o Status: standard",
      "ja": "o ステータス：標準"
    },
    {
      "indent": 3,
      "text": "o Reference: RFC 7469",
      "ja": "o リファレンス：RFC 7469"
    },
    {
      "indent": 0,
      "text": "7. Usability Considerations",
      "section_title": true,
      "ja": "7. 使いやすさに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When pinning works to detect impostor Pinned Hosts, users will experience denial of service. It is advisable for UAs to explain the reason why, i.e., that it was impossible to verify the confirmed cryptographic identity of the host.",
      "ja": "固定が詐称の固定ホストを検出するために機能する場合、ユーザーはサービス拒否を経験します。 UAが、ホストの確認済みの暗号IDを検証できなかった理由を説明することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It is advisable that UAs have a way for users to clear current Pins for Pinned Hosts and that UAs allow users to query the current state of Pinned Hosts.",
      "ja": "UAには、ユーザーがピン留めホストの現在のピンをクリアする方法があり、UAによってユーザーがピン留めホストの現在の状態を照会できるようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, July 2002, <http://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339]クラインG.およびC.ニューマン、「インターネット上の日付と時刻：タイムスタンプ」、RFC 3339、2002年7月、<http://www.rfc-editor.org/info/rfc3339>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、2005年1月、<http：//www.rfc- editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月、<http://www.rfc-editor.org/info/rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、2011年5月、<http://www.rfc-editor.org/info / rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265] Barth、A。、「HTTP State Management Mechanism」、RFC 6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6797] Hodges, J., Jackson, C., and A. Barth, \"HTTP Strict Transport Security (HSTS)\", RFC 6797, November 2012, <http://www.rfc-editor.org/info/rfc6797>.",
      "ja": "[RFC6797] Hodges、J.、Jackson、C。、およびA. Barth、「HTTP Strict Transport Security（HSTS）」、RFC 6797、2012年11月、<http://www.rfc-editor.org/info/rfc6797 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T。、編、「JavaScript Object Notation（JSON）データ交換フォーマット」、RFC 7159、2014年3月、<http://www.rfc-editor.org/info/rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、2014年6月、<http://www.rfc-editor.org/info/rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234] Fielding、R。、編、Nottingham、M。、編、およびJ. Reschke、編、「Hypertext Transfer Protocol（HTTP / 1.1）：Caching」、RFC 7234、2014年6月、<http：/ /www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7468] Josefsson, S. and S. Leonard, \"Textual Encodings of PKIX, PKCS, and CMS Structures\", RFC 7468, April 2015, <http://www.rfc-editor.org/info/rfc7468>.",
      "ja": "[RFC7468] Josefsson、S。、およびS. Leonard、「PKIX、PKCS、およびCMS構造のテキストエンコーディング」、RFC 7468、2015年4月、<http://www.rfc-editor.org/info/rfc7468>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-html401-19991224] Raggett, D., Hors, A., and I. Jacobs, \"HTML 4.01 Specification\", World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, <http://www.w3.org/TR/1999/REC-html401-19991224>.",
      "ja": "[W3C.REC-html401-19991224] Raggett、D.、Hors、A。、およびI. Jacobs、「HTML 4.01 Specification」、World Wide Web Consortium Recommendation REC-html401-19991224、1999年12月、<http：// www .w3.org / TR / 1999 / REC-html401-19991224>。"
    },
    {
      "indent": 3,
      "text": "[message-headers] IANA, \"Message Headers\", <http://www.iana.org/assignments/message-headers/>.",
      "ja": "[message-headers] IANA、「メッセージヘッダー」、<http://www.iana.org/assignments/message-headers/>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3546] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 3546, June 2003, <http://www.rfc-editor.org/info/rfc3546>.",
      "ja": "[RFC3546] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J。、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 3546、2003年6月、<http：/ /www.rfc-editor.org/info/rfc3546>。"
    },
    {
      "indent": 3,
      "text": "[RFC6962] Laurie, B., Langley, A., and E. Kasper, \"Certificate Transparency\", RFC 6962, June 2013, <http://www.rfc-editor.org/info/rfc6962>.",
      "ja": "[RFC6962] Laurie、B.、Langley、A。、およびE. Kasper、「Certificate Transparency」、RFC 6962、2013年6月、<http://www.rfc-editor.org/info/rfc6962>。"
    },
    {
      "indent": 3,
      "text": "[TACK] Marlinspike, M., \"Trust Assertions for Certificate Keys\", Work in Progress, draft-perrin-tls-tack-02, January 2013.",
      "ja": "[TACK] Marlinspike、M。、「証明書キーの信頼アサーション」、作業中、draft-perrin-tls-tack-02、2013年1月。"
    },
    {
      "indent": 3,
      "text": "[why-pin-key] Langley, A., \"Public Key Pinning\", Imperial Violet: Adam Langley's Weblog, May 2011, <https://www.imperialviolet.org/2011/05/04/pinning.html>.",
      "ja": "[why-pin-key] Langley、A。、「Public Key Pinning」、Imperial Violet：Adam Langley's Weblog、2011年5月、<https://www.imperialviolet.org/2011/05/04/pinning.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Fingerprint Generation",
      "section_title": true,
      "ja": "付録A.指紋の生成"
    },
    {
      "indent": 3,
      "text": "This Portable Operating System Interface (POSIX) shell program generates SPKI Fingerprints, suitable for use in pinning, from PEM-encoded certificates. It is non-normative.",
      "ja": "このポータブルオペレーティングシステムインターフェイス（POSIX）シェルプログラムは、PEMエンコードされた証明書から、ピン留めでの使用に適したSPKIフィンガープリントを生成します。それは非規範的です。"
    },
    {
      "indent": 3,
      "text": "openssl x509 -noout -in certificate.pem -pubkey | \\\n    openssl asn1parse -noout -inform pem -out public.key\nopenssl dgst -sha256 -binary public.key | openssl enc -base64",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 11: Example SPKI Fingerprint Generation Code",
      "ja": "図11：SPKI指紋生成コードの例"
    },
    {
      "indent": 0,
      "text": "Appendix B. Deployment Guidance",
      "section_title": true,
      "ja": "付録B.展開ガイダンス"
    },
    {
      "indent": 3,
      "text": "This section is non-normative guidance that may smooth the adoption of public key pinning.",
      "ja": "このセクションは、非公開のガイダンスであり、公開鍵の固定の採用を円滑にする可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Operators should get the backup public key signed by a different (root and/or intermediary) CA than their primary certificate, and store the backup key pair safely offline. The semantics of an SPKI Fingerprint do not require the issuance of a certificate to construct a valid Pin. However, in many deployment scenarios, in order to make a Backup Pin operational, the server operator will need to have a certificate to deploy TLS on the host. Failure to obtain a certificate through prior arrangement will leave clients that recognize the site as a Known Pinned Host unable to successfully perform Pin Validation until such a time as the operator can obtain a new certificate from their desired certificate issuer.",
      "ja": "o オペレーターは、プライマリ証明書とは異なる（ルートおよび/または中間）CAによって署名されたバックアップ公開キーを取得し、バックアップキーのペアをオフラインで安全に保存する必要があります。 SPKIフィンガープリントのセマンティクスでは、有効なPINを構築するために証明書を発行する必要はありません。ただし、多くの展開シナリオでは、バックアップピンを機能させるために、サーバーオペレーターはホストにTLSを展開するための証明書を持っている必要があります。事前の取り決めで証明書を取得できない場合、オペレーターが目的の証明書発行者から新しい証明書を取得できるようになるまで、サイトを既知の固定ホストとして認識しているクライアントはピン検証を正常に実行できません。"
    },
    {
      "indent": 3,
      "text": "o It is most economical to have the backup certificate signed by a completely different signature chain than the live certificate, to maximize recoverability in the event of compromise of either the root or intermediary signer.",
      "ja": "o ルートまたは中間の署名者が侵害された場合の回復性を最大化するには、ライブ証明書とは完全に異なる署名チェーンによってバックアップ証明書に署名させるのが最も経済的です。"
    },
    {
      "indent": 3,
      "text": "o Operators should periodically exercise their Backup Pin plan -- an untested backup is no backup at all.",
      "ja": "o オペレーターは定期的にバックアップピンプランを実行する必要があります-テストされていないバックアップはまったくバックアップではありません。"
    },
    {
      "indent": 3,
      "text": "o Operators should start small. Operators should first deploy public key pinning by using the report-only mode together with a report-uri directive that points to a reliable report collection endpoint. When moving out of report-only mode, operators should start by setting a max-age of minutes or a few hours and gradually increase max-age as they gain confidence in their operational capability.",
      "ja": "o オペレーターは小さく始めるべきです。オペレーターは、信頼できるレポートコレクションエンドポイントを指すreport-uriディレクティブと共にレポート専用モードを使用して、公開キーのピン留めを最初に展開する必要があります。レポート専用モードを終了する場合、オペレーターは、まず数分または数時間のmax-ageを設定し、運用能力に自信が持てるように徐々にmax-ageを増加させる必要があります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Tobias Gondrom, Jeff Hodges, Paul Hoffman, Ivan Krstic, Adam Langley, Barry Leiba, Nicolas Lidzborski, SM, James Manger, Yoav Nir, Trevor Perrin, Eric Rescorla, Pete Resnick, Tom Ritter, and Yan Zhu for suggestions and edits that clarified the text.",
      "ja": "Tobias Gondrom、Jeff Hodges、Paul Hoffman、Ivan Krstic、Adam Langley、Barry Leiba、Nicolas Lidzborski、SM、James Manger、Yoav Nir、Trevor Perrin、Eric Rescorla、Pete Resnick、Tom Ritter、Yan Zhuの各氏の提案と編集に感謝します。それはテキストを明確にしました。"
    },
    {
      "indent": 3,
      "text": "TACK [TACK] is a fruitful source of alternative design considerations.",
      "ja": "TACK [TACK]は、代替の設計上の考慮事項の実りある情報源です。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Chris Evans Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "Chris Evans Google、Inc. 1600 Amphitheatre Pkwy Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "EMail: cevans@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chris Palmer Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "Chris Palmer Google、Inc. 1600 Amphitheatre Pkwy Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "EMail: palmer@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ryan Sleevi Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "Ryan Sleevi Google、Inc. 1600 Amphitheatre Pkwy Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "EMail: sleevi@google.com",
      "raw": true,
      "ja": ""
    }
  ]
}