{
  "title": {
    "text": "RFC 7486 - HTTP Origin-Bound Authentication (HOBA)",
    "ja": "RFC 7486 - HTTP Origin-Bound Authentication（HOBA）"
  },
  "number": 7486,
  "created_at": "2020-08-21 22:18:00.534872+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        S. Farrell\nRequest for Comments: 7486                        Trinity College Dublin\nCategory: Experimental                                        P. Hoffman\nISSN: 2070-1721                                           VPN Consortium\n                                                               M. Thomas\n                                                               Phresheez\n                                                              March 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "HTTP Origin-Bound Authentication (HOBA)",
      "ja": "HTTP Origin-Bound Authentication（HOBA）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "HTTP Origin-Bound Authentication (HOBA) is a digital-signature-based design for an HTTP authentication method. The design can also be used in JavaScript-based authentication embedded in HTML. HOBA is an alternative to HTTP authentication schemes that require passwords and therefore avoids all problems related to passwords, such as leakage of server-side password databases.",
      "ja": "HTTP Origin-Bound Authentication（HOBA）は、HTTP認証方式のデジタル署名ベースの設計です。このデザインは、HTMLに埋め込まれたJavaScriptベースの認証でも使用できます。 HOBAは、パスワードを必要とするHTTP認証スキームの代替手段であり、サーバー側のパスワードデータベースの漏洩など、パスワードに関連するすべての問題を回避します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7486.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7486で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Interfacing to Applications (Cookies) . . . . . . . . . .   4\n  1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.3.  Step-by-Step Overview of HOBA-http  . . . . . . . . . . .   6\n2.  The HOBA Authentication Scheme  . . . . . . . . . . . . . . .   6\n3.  Introduction to the HOBA-http Mechanism . . . . . . . . . . .   9\n4.  Introduction to the HOBA-js Mechanism . . . . . . . . . . . .  10\n5.  HOBA's Authentication Process . . . . . . . . . . . . . . . .  11\n  5.1.  CPK Preparation Phase . . . . . . . . . . . . . . . . . .  11\n  5.2.  Signing Phase . . . . . . . . . . . . . . . . . . . . . .  11\n  5.3.  Authentication Phase  . . . . . . . . . . . . . . . . . .  11\n6.  Other Parts of the HOBA Process . . . . . . . . . . . . . . .  12\n  6.1.  Registration  . . . . . . . . . . . . . . . . . . . . . .  13\n    6.1.1.  Hobareg Definition  . . . . . . . . . . . . . . . . .  14\n  6.2.  Associating Additional Keys to an Existing Account  . . .  16\n    6.2.1.  Moving Private Keys . . . . . . . . . . . . . . . . .  16\n    6.2.2.  Human-Memorable One-Time Password (Don't Do This One)  16\n    6.2.3.  Out-of-Band URL . . . . . . . . . . . . . . . . . . .  17\n  6.3.  Logging Out . . . . . . . . . . . . . . . . . . . . . . .  17\n  6.4.  Getting a Fresh Challenge . . . . . . . . . . . . . . . .  17\n7.  Mandatory-to-Implement Algorithms . . . . . . . . . . . . . .  18\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  18\n  8.1.  Privacy Considerations  . . . . . . . . . . . . . . . . .  18\n  8.2.  localStorage Security for JavaScript  . . . . . . . . . .  19\n  8.3.  Multiple Accounts on One User Agent . . . . . . . . . . .  20\n  8.4.  Injective Mapping for HOBA-TBS  . . . . . . . . . . . . .  20\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21\n  9.1.  HOBA Authentication Scheme  . . . . . . . . . . . . . . .  21\n  9.2.  .well-known URI . . . . . . . . . . . . . . . . . . . . .  21\n  9.3.  Algorithm Names . . . . . . . . . . . . . . . . . . . . .  21\n  9.4.  Key Identifier Types  . . . . . . . . . . . . . . . . . .  22",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  9.5.  Device Identifier Types . . . . . . . . . . . . . . . . .  22\n  9.6.  Hobareg HTTP Header Field . . . . . . . . . . . . . . . .  23\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  23\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  23\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  24\nAppendix A.  Problems with Passwords  . . . . . . . . . . . . . .  26\nAppendix B.  Example  . . . . . . . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP Origin-Bound Authentication (HOBA) is an authentication design that can be used as an HTTP authentication scheme [RFC7235] and for JavaScript-based authentication embedded in HTML. The main goal of HOBA is to offer an easy-to-implement authentication scheme that is not based on passwords but that can easily replace HTTP or HTML forms-based password authentication. Deployment of HOBA can reduce or eliminate password entries in databases, with potentially significant security benefits.",
      "ja": "HTTP Origin-Bound Authentication（HOBA）は、HTTP認証スキーム[RFC7235]として、およびHTMLに埋め込まれたJavaScriptベースの認証に使用できる認証設計です。 HOBAの主な目的は、パスワードに基づくのではなく、HTTPまたはHTMLフォームベースのパスワード認証を簡単に置き換えることができる、実装が容易な認証スキームを提供することです。 HOBAを導入すると、データベース内のパスワードエントリを削減または排除できるため、セキュリティが大幅に向上する可能性があります。"
    },
    {
      "indent": 3,
      "text": "HOBA is an HTTP authentication mechanism that complies with the framework for such schemes [RFC7235]. As a JavaScript design, HOBA demonstrates a way for clients and servers to interact using the same credentials that are used by the HTTP authentication scheme.",
      "ja": "HOBAは、そのようなスキームのフレームワーク[RFC7235]に準拠するHTTP認証メカニズムです。 JavaScriptの設計として、HOBAはクライアントとサーバーがHTTP認証スキームで使用されるのと同じ資格情報を使用して対話する方法を示します。"
    },
    {
      "indent": 3,
      "text": "Current username/password authentication methods such as HTTP Basic, HTTP Digest, and web forms have been in use for many years but are susceptible to theft of server-side password databases. Instead of passwords, HOBA uses digital signatures in a challenge-response scheme as its authentication mechanism. HOBA also adds useful features such as credential management and session logout. In HOBA, the client creates a new public-private key pair for each host (\"web origin\" [RFC6454]) to which it authenticates. These keys are used in HOBA for HTTP clients to authenticate themselves to servers in the HTTP protocol or in a JavaScript authentication program.",
      "ja": "HTTP Basic、HTTP Digest、Webフォームなどの現在のユーザー名/パスワード認証方法は長年使用されてきましたが、サーバー側のパスワードデータベースの盗難の影響を受けやすくなっています。パスワードの代わりに、HOBAは認証メカニズムとしてチャレンジ/レスポンス方式でデジタル署名を使用します。 HOBAには、資格情報管理やセッションログアウトなどの便利な機能も追加されています。 HOBAでは、クライアントは認証する各ホスト（ \"web origin\" [RFC6454]）ごとに新しい公開鍵と秘密鍵のペアを作成します。これらのキーは、HTTPクライアントがHTTPプロトコルまたはJavaScript認証プログラムでサーバーに対して自身を認証するために、HOBAで使用されます。"
    },
    {
      "indent": 3,
      "text": "HOBA session management is identical to username/password session management, with a server-side session management tool or script inserting a session cookie [RFC6265] into the output to the browser. Use of Transport Layer Security (TLS) for the HTTP session is still necessary to prevent session cookie hijacking.",
      "ja": "HOBAセッション管理はユーザー名/パスワードセッション管理と同じであり、サーバー側のセッション管理ツールまたはスクリプトがブラウザーへの出力にセッションCookie [RFC6265]を挿入します。セッションCookieのハイジャックを防ぐために、HTTPセッションにトランスポート層セキュリティ（TLS）を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": " HOBA keys are \"bare keys\", so there is no need for the semantic overhead of X.509 public key certificates, particularly with respect to naming and trust anchors. The Client Public Key (CPK) structures in HOBA do not have any publicly visible identifier for the user who possesses the corresponding private key, nor the web origin with which the client is using the CPK.",
      "ja": "HOBAキーは「ベアキー」であるため、特に名前付けアンカーとトラストアンカーに関して、X.509公開キー証明書のセマンティックオーバーヘッドは必要ありません。 HOBAのクライアント公開鍵（CPK）構造には、対応する秘密鍵を所有するユーザーの公開識別子も、クライアントがCPKを使用しているWebオリジンもありません。"
    },
    {
      "indent": 3,
      "text": "HOBA also defines some services that are needed for modern HTTP authentication:",
      "ja": "HOBAでは、最新のHTTP認証に必要ないくつかのサービスも定義しています。"
    },
    {
      "indent": 3,
      "text": "o Servers can bind a CPK with an identifier, such as an account name. Servers using HOBA define their own policies for binding CPKs with accounts during account registration.",
      "ja": "o サーバーは、CPKをアカウント名などの識別子にバインドできます。 HOBAを使用するサーバーは、アカウント登録時にCPKをアカウントにバインドするための独自のポリシーを定義します。"
    },
    {
      "indent": 3,
      "text": "o Users are likely to use more than one device or User Agent (UA) for the same HTTP-based service, so HOBA gives a way to associate more than one CPK to the same account without having to register for each separately.",
      "ja": "o ユーザーは同じHTTPベースのサービスに複数のデバイスまたはユーザーエージェント（UA）を使用する可能性が高いため、HOBAは、複数のCPKを同じアカウントに関連付ける方法を提供します。それぞれを個別に登録する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o Logout features can be useful for UAs, so HOBA defines a way to close a current HTTP \"session\".",
      "ja": "o ログアウト機能はUAに役立つため、HOBAは現在のHTTP「セッション」を閉じる方法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Digital signatures can be expensive to compute, so HOBA defines a way for HTTP servers to indicate how long a given challenge value is valid, and a way for UAs to fetch a fresh challenge at any time.",
      "ja": "o デジタル署名は計算にコストがかかる可能性があるため、HOBAは、HTTPサーバーが特定のチャレンジ値の有効期間を示す方法と、UAがいつでも新しいチャレンジをフェッチする方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Users are also likely to lose a private key, or the client's memory of which key pair is associated with which origin, such as when a user loses the computer or mobile device in which state is stored. HOBA does not define a mechanism for deleting the association between an existing CPK and an account. Such a mechanism can be implemented at the application layer.",
      "ja": "ユーザーは、秘密キー、またはユーザーが状態が保存されているコンピューターまたはモバイルデバイスを紛失した場合など、どのキーペアがどのオリジンに関連付けられているかを示すクライアントのメモリも失う可能性があります。 HOBAは、既存のCPKとアカウント間の関連付けを削除するメカニズムを定義していません。このようなメカニズムは、アプリケーション層で実装できます。"
    },
    {
      "indent": 3,
      "text": "The HOBA scheme is far from new; for example, the basic idea is pretty much identical to the first two messages from \"Mechanism R\" on page 6 of [MI93], which predates HOBA by 20 years.",
      "ja": "HOBAスキームは決して新しいものではありません。たとえば、基本的な考え方は、HOBAより20年前の[MI93]の6ページの「Mechanism R」からの最初の2つのメッセージとほとんど同じです。"
    },
    {
      "indent": 0,
      "text": "1.1. Interfacing to Applications (Cookies)",
      "section_title": true,
      "ja": "1.1. アプリケーションへのインターフェース（Cookie）"
    },
    {
      "indent": 3,
      "text": "HOBA can be used as a drop-in replacement for password-based user authentication schemes used in common web applications. The simplest way is to (re)direct the UA to a HOBA \"Login\" URL and for the response to a successful HTTP request containing a HOBA signature to set a session cookie [RFC6265]. Further interactions with the web application will then be secured via the session cookie, as is commonly done today.",
      "ja": "HOBAは、一般的なWebアプリケーションで使用されるパスワードベースのユーザー認証スキームのドロップイン代替として使用できます。最も簡単な方法は、UAをHOBAの「ログイン」URLに（再）リダイレクトし、HOBA署名を含む成功したHTTPリクエストへの応答でセッションCookieを設定することです[RFC6265]。 Webアプリケーションとのさらなる対話は、今日一般的に行われているように、セッションCookieを介して保護されます。"
    },
    {
      "indent": 3,
      "text": "While cookies are bearer tokens, and thus weaker than HOBA signatures, they are currently ubiquitously used. If non-bearer token session continuation schemes are developed in the future in the IETF or elsewhere, then those can interface to HOBA as easily as with any password-based authentication scheme.",
      "ja": "Cookieはベアラートークンであるため、HOBA署名よりも脆弱ですが、現在、ユビキタスで使用されています。非ベアラートークンセッション継続スキームがIETFまたはその他の場所で将来開発される場合、それらは、パスワードベースの認証スキームと同じように簡単にHOBAに接続できます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの \"は、RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].",
      "ja": "この仕様では、[RFC5234]の拡張バッカスナウアフォーム（ABNF）表記を使用しています。"
    },
    {
      "indent": 3,
      "text": "Account: The term \"account\" is (loosely) used to refer to whatever data structure(s) the server maintains that are associated with an identity. That will contain at least one CPK and a web origin; it will also optionally include an HTTP \"realm\" as defined in the HTTP authentication specification [RFC7235]. It might also involve many other non-standard pieces of data that the server accumulates as part of account creation processes. An account may have many CPKs that are considered equivalent in terms of being usable for authentication, but the meaning of \"equivalent\" is really up to the server and is not defined here.",
      "ja": "アカウント：「アカウント」という用語は、（大まかに）IDに関連付けられている、サーバーが維持するデータ構造を指すために使用されます。これには、少なくとも1つのCPKとWebオリジンが含まれます。また、オプションで、HTTP認証仕様[RFC7235]で定義されているHTTP「レルム」も含まれます。また、サーバーがアカウント作成プロセスの一部として蓄積する他の多くの非標準的なデータが含まれる場合もあります。アカウントには、認証に使用できるという点で同等と見なされる多くのCPKがある場合がありますが、「同等」の意味は実際にはサーバー次第であり、ここでは定義しません。"
    },
    {
      "indent": 3,
      "text": "Client public key (CPK): A CPK is the public key and associated cryptographic parameters needed for a server to validate a signature.",
      "ja": "クライアント公開鍵（CPK）：CPKは、サーバーが署名を検証するために必要な公開鍵および関連する暗号化パラメーターです。"
    },
    {
      "indent": 3,
      "text": "HOBA-http: We use this term when describing something that is specific to HOBA as an HTTP authentication mechanism.",
      "ja": "HOBA-http：HTTP認証メカニズムとしてのHOBAに固有の何かを説明する場合、この用語を使用します。"
    },
    {
      "indent": 3,
      "text": "HOBA-js: We use this term when describing something that is unrelated to HOBA-http but is relevant for HOBA as a design pattern that can be implemented in a browser in JavaScript.",
      "ja": "HOBA-js：この用語は、HOBA-httpとは無関係ですが、JavaScriptのブラウザーに実装できる設計パターンとしてHOBAに関連するものを表すときに使用します。"
    },
    {
      "indent": 3,
      "text": "User agent (UA): typically, but not always, a web browser.",
      "ja": "ユーザーエージェント（UA）：常にではありませんが、通常はWebブラウザー。"
    },
    {
      "indent": 3,
      "text": "User: a person who is running a UA. In this document, \"user\" does not mean \"user name\" or \"account name\".",
      "ja": "ユーザー：UAを実行している人。このドキュメントでは、「ユーザー」は「ユーザー名」または「アカウント名」を意味しません。"
    },
    {
      "indent": 3,
      "text": "Web client: the content and JavaScript code that run within the context of a single UA instance (such as a tab in a web browser).",
      "ja": "Webクライアント：単一のUAインスタンス（Webブラウザーのタブなど）のコンテキスト内で実行されるコンテンツとJavaScriptコード。"
    },
    {
      "indent": 0,
      "text": "1.3. Step-by-Step Overview of HOBA-http",
      "section_title": true,
      "ja": "1.3. HOBA-httpの段階的な概要"
    },
    {
      "indent": 3,
      "text": "Step-by-step, a typical HOBA-http registration and authentication flow might look like this:",
      "ja": "段階的な、典型的なHOBA-http登録および認証フローは次のようになります。"
    },
    {
      "indent": 3,
      "text": "1. The client connects to the server and makes a request, and the server's response includes a WWW-Authenticate header field that contains the \"HOBA\" auth-scheme, along with associated parameters (see Section 3).",
      "ja": "1. クライアントはサーバーに接続して要求を出し、サーバーの応答には \"HOBA\" auth-schemeとそれに関連するパラメーターを含むWWW-Authenticateヘッダーフィールドが含まれます（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "2. If the client was not already registered with the web origin and realm it is trying to access, the \"joining\" process is invoked (see Section 6.1). This creates a key pair and makes the CPK known to the server so that the server can carry out the account creation processes required.",
      "ja": "2. クライアントがまだアクセスしようとしているWebオリジンとレルムに登録されていない場合、「参加」プロセスが呼び出されます（6.1節を参照）。これにより、キーペアが作成され、CPKがサーバーに認識されるため、サーバーは必要なアカウント作成プロセスを実行できます。"
    },
    {
      "indent": 3,
      "text": "3. The client uses the challenge from the HOBA auth-scheme parameters, along with other information it knows about the web origin and realm, to create and sign a HOBA to-be-signed (HOBA-TBS) string (see Section 2).",
      "ja": "3. クライアントは、HOBA auth-schemeパラメーターからのチャレンジと、Webの起点とレルムについて知っている他の情報を使用して、署名するHOBA（HOBA-TBS）文字列を作成して署名します（セクション2を参照）。"
    },
    {
      "indent": 3,
      "text": "4. The client creates a HOBA client-result (HOBA-RES), using the signed HOBA-TBS for the \"sig\" value (see Section 2).",
      "ja": "4. クライアントは、「sig」値に署名付きのHOBA-TBSを使用して、HOBAクライアント結果（HOBA-RES）を作成します（セクション2を参照）。"
    },
    {
      "indent": 3,
      "text": "5. The client includes the Authorization header field in its next request, using the \"HOBA\" auth-scheme and putting the HOBA client-result in an auth-param named \"result\" (see Section 3).",
      "ja": "5. クライアントは、次のリクエストにAuthorizationヘッダーフィールドを含め、「HOBA」auth-schemeを使用して、HOBA client-resultを「result」という名前のauth-paramに入れます（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "6. The server authenticates the HOBA client-result (see Section 5.1).",
      "ja": "6. サーバーはHOBAクライアントの結果を認証します（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "7. Typically, the server's response includes a session cookie that allows the client to indicate its authentication state in future requests (see Section 1.1).",
      "ja": "7. 通常、サーバーの応答には、クライアントが将来のリクエストで認証状態を示すことができるようにするセッションCookieが含まれます（セクション1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "2. The HOBA Authentication Scheme",
      "section_title": true,
      "ja": "2. HOBA認証スキーム"
    },
    {
      "indent": 3,
      "text": "A UA that implements HOBA maintains a list of web origins and realms. The UA also maintains one or more client credentials for each web origin/realm combination for which it has created a CPK.",
      "ja": "HOBAを実装するUAは、Webのオリジンとレルムのリストを維持します。 UAは、CPKを作成したWebの起点とレルムの組み合わせごとに、1つ以上のクライアント資格情報も保持します。"
    },
    {
      "indent": 0,
      "text": " On receipt of a challenge (and optional realm) from a server, the client marshals a HOBA-TBS blob that includes a client generated nonce, the web origin, the realm, an identifier for the CPK, and the challenge string, and signs that blob with the private key corresponding to the CPK for that web origin. The formatting chosen for this TBS blob is chosen so as to make server-side signature verification as simple as possible for a wide range of current server tooling.",
      "ja": "サーバーからチャレンジ（およびオプションのレルム）を受信すると、クライアントは、クライアントが生成したナンス、Webオリジン、レルム、CPKの識別子、およびチャレンジ文字列を含むHOBA-TBS BLOBをマーシャリングし、それに署名します。そのWebオリジンのCPKに対応する秘密キーを持つblob。このTBS blobに選択されたフォーマットは、現在のさまざまなサーバーツールでサーバー側の署名検証をできるだけ簡単にするように選択されています。"
    },
    {
      "indent": 3,
      "text": "Figure 1 specifies the ABNF for the signature input. The term \"unreserved\" means that the field does not have a specific format defined and allows the characters specified in Section 2.3 of [RFC3986].",
      "ja": "図1は、署名入力のABNFを示しています。 「未予約」という用語は、フィールドに特定の形式が定義されておらず、[RFC3986]のセクション2.3で指定された文字を許可することを意味します。"
    },
    {
      "indent": 6,
      "text": "HOBA-TBS = len \":\" nonce\n        len \":\" alg\n        len \":\" origin\n        len \":\" [ realm  ]\n        len \":\" kid\n        len \":\" challenge\nlen = 1*DIGIT\nnonce = 1*base64urlchars\nalg = 1*2DIGIT\norigin = scheme \"://\" authority \":\" port\n; scheme, etc., are from RFC 3986\nrealm = unreserved\n; realm is to be treated as in Section 2.2 of RFC 7235\nkid = 1*base64urlchars\nchallenge = 1*base64urlchars\n; Characters for Base64URL encoding from Table 2 of RFC 4648\n; all of which are US-ASCII (see RFC 20)\nbase64urlchars = %x30-39             ; Digits\n              / %x41-5A           ; Uppercase letters\n              / %x61-7A           ; Lowercase letters\n              / \"-\" / \"_\" / \"=\"   ; Special characters",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 1: To-Be-Signed Data for HOBA",
      "ja": "図1：HOBAの署名対象データ"
    },
    {
      "indent": 3,
      "text": "The fields above contain the following:",
      "ja": "上記のフィールドには以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "o len: Each field is preceded by the number of octets of the following field, expressed as a decimal number in ASCII [RFC20]. Lengths are separated from field values by a colon character. So if a nonce with the value \"ABCD\" were used, then that would be preceeded by \"4:\" (see the example in Appendix B for details).",
      "ja": "o len：各フィールドの前には、ASCII [RFC20]で10進数として表される次のフィールドのオクテット数が続きます。長さはフィールド値からコロン文字で区切られます。したがって、値「ABCD」のノンスが使用された場合、その前に「4：」が付きます（詳細については、付録Bの例を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o nonce: a random value chosen by the UA and MUST be base64url encoded before being included in the HOBA-TBS value. (base64url encoding is defined in [RFC4648]; guidelines for randomness are given in [RFC4086].) UAs MUST be able to use at least 32 bits of randomness in generating a nonce. UAs SHOULD be able to use 64 or more bits of randomness for nonces.",
      "ja": "o nonce：UAによって選択されたランダムな値であり、HOBA-TBS値に含まれる前にbase64urlエンコードされる必要があります。 （base64urlエンコーディングは[RFC4648]で定義されています。ランダム性のガイドラインは[RFC4086]で提供されています。）UAはナンスの生成に少なくとも32ビットのランダム性を使用できなければなりません（MUST）。 UAはノンスに64ビット以上のランダム性を使用できる必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o alg: specifies the signature algorithm being used. See Section 7 for details of algorithm support requirements. The IANA-registered algorithm values (see Section 9.3) are encoded as one-or two-digit ASCII numbers. For example, RSA-SHA256 (number 0) is encoded as the ASCII character \"0\" (0x30), while a future algorithm registered as number 17 would be encoded as the ASCII characters \"17\" (0x3137).",
      "ja": "o alg：使用されている署名アルゴリズムを指定します。アルゴリズムサポート要件の詳細については、セクション7を参照してください。 IANAに登録されたアルゴリズム値（9.3項を参照）は、1桁または2桁のASCII番号としてエンコードされます。たとえば、RSA-SHA256（数値0）はASCII文字 \"0\"（0x30）としてエンコードされますが、数値17として登録された将来のアルゴリズムはASCII文字 \"17\"（0x3137）としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "o origin: the web origin expressed as the concatenation of the scheme, authority, and port from [RFC3986]. These are not base64 encoded, as they will be most readily available to the server in plain text. For example, if accessing the URL \"https://www.example.com:8080/foo\", then the bytes input to the signature process will be \"https://www.example.com:8080\". There is no default for the port number, and the port number MUST be present.",
      "ja": "o origin：[RFC3986]からのスキーム、権限、およびポートの連結として表されるWebの起源。これらはプレーンテキストでサーバーが最も簡単に利用できるため、base64エンコードされていません。たとえば、URL「https://www.example.com:8080/foo」にアクセスする場合、署名プロセスに入力されるバイトは「https://www.example.com:8080」になります。ポート番号のデフォルトはなく、ポート番号が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o realm: a string with the syntactic restrictions defined in [RFC7235]. If no realm is specified for this authentication, then this is absent but is preceeded by a length of zero (\"0:\"). Recall that both sides know when this needs to be there, independent of the encoding via a zero length.",
      "ja": "o レルム：[RFC7235]で定義された構文制限を持つ文字列。この認証にレルムが指定されていない場合、これは存在しませんが、長さゼロ（ \"0：\"）が前に付きます。長さがゼロのエンコーディングとは関係なく、これがいつ必要かを両側が知っていることを思い出してください。"
    },
    {
      "indent": 3,
      "text": "o kid: a key identifier. This MUST be a base64url-encoded value that is presented to the server in the HOBA client result (see below).",
      "ja": "o kid：キー識別子。これは、HOBAクライアントの結果でサーバーに提示されるbase64urlエンコード値である必要があります（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "o challenge: MUST be a base64url-encoded challenge value that the server chose to send to the client. The challenge MUST be chosen so that it is infeasible to guess and SHOULD be indistinguishable from (the base64url encoding of) a random string that is at least 128 bits long.",
      "ja": "o challenge：サーバーがクライアントに送信することを選択したbase64urlでエンコードされたチャレンジ値である必要があります。チャレンジは、推測することが不可能であり、少なくとも128ビット長のランダム文字列（のbase64urlエンコーディング）と区別できないように選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The HOBA-TBS string is the input to the client's signing process but is not itself sent over the network since some fields are already inherent in the HTTP exchange. The challenge, however, is sent over the network so as to reduce the amount of state that needs to be maintained by servers. (One form of stateless challenge might be a ciphertext that the server decrypts and checks, but that is an implementation detail.) The value that is sent over the network by the UA is the HOBA \"client result\", which we now define.",
      "ja": "HOBA-TBS文字列はクライアントの署名プロセスへの入力ですが、一部のフィールドはすでにHTTP交換に組み込まれているため、それ自体はネットワークを介して送信されません。ただし、サーバーが維持する必要のある状態の量を減らすために、チャレンジはネットワークを介して送信されます。 （ステートレスチャレンジの1つの形式は、サーバーが復号化してチェックする暗号文である可能性がありますが、これは実装の詳細です。）UAによってネットワーク経由で送信される値は、HOBAの「クライアント結果」であり、これを定義します。"
    },
    {
      "indent": 3,
      "text": "The HOBA \"client result\" is a dot-separated string that includes the signature and is sent in the HTTP Authorization header field value using the value syntax defined in Figure 2. The \"sig\" value is the base64url-encoded version of the binary output of the signing process. The kid, challenge, and nonce are as defined above and are also base64url encoded.",
      "ja": "HOBAの「クライアント結果」は、署名を含むドット区切りの文字列であり、図2で定義されている値の構文を使用してHTTP Authorizationヘッダーフィールド値で送信されます。「sig」値は、バイナリ出力のbase64urlエンコードバージョンです署名プロセスの。 kid、challenge、およびnonceは上記で定義したとおりであり、base64urlでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "HOBA-RES = kid \".\" challenge \".\" nonce \".\" sig sig = 1*base64urlchars",
      "ja": "HOBA-RES = kid \"。\" 「。」に挑戦ナンス \"。\" sig sig = 1 * base64urlchars"
    },
    {
      "indent": 20,
      "text": "Figure 2: HOBA Client Result Value",
      "ja": "図2：HOBAクライアントの結果値"
    },
    {
      "indent": 3,
      "text": "If a malformed message of any kind is received by a server, the server MUST fail authentication. If a malformed message of any kind is received by a client, the client MUST abandon that authentication attempt. (The client is, of course, free to start another authentication attempt if it desires.)",
      "ja": "不正な形式のメッセージをサーバーが受信した場合、サーバーは認証に失敗する必要があります。不正な形式のメッセージがクライアントによって受信された場合、クライアントはその認証の試行を中止しなければなりません（MUST）。 （もちろん、クライアントは必要に応じて別の認証試行を自由に開始できます。）"
    },
    {
      "indent": 0,
      "text": "3. Introduction to the HOBA-http Mechanism",
      "section_title": true,
      "ja": "3. HOBA-httpメカニズムの概要"
    },
    {
      "indent": 3,
      "text": "An HTTP server that supports HOBA authentication includes the \"HOBA\" auth-scheme value in a WWW-Authenticate header field when it wants the client to authenticate with HOBA. Note that the HOBA auth-scheme might not be the only one that the server includes in a WWW-Authenticate header.",
      "ja": "HOBA認証をサポートするHTTPサーバーは、クライアントにHOBAでの認証を要求するときに、WWW-Authenticateヘッダーフィールドに \"HOBA\" auth-scheme値を含めます。サーバーがWWW-Authenticateヘッダーに含めるのはHOBA auth-schemeだけではない場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The HOBA scheme has two REQUIRED attributes (challenge and max-age) and one OPTIONAL attribute (realm):",
      "ja": "HOBAスキームには、2つの必須属性（challengeおよびmax-age）と1つのOPTIONAL属性（レルム）があります。"
    },
    {
      "indent": 3,
      "text": "o The \"challenge\" attribute MUST be included. The challenge is the string made up of the base64url-encoded octets that the server wants the client to sign in its response. The challenge MUST be unique for every 401 HTTP response in order to prevent replay attacks from passive observers.",
      "ja": "o 「チャレンジ」属性を含める必要があります。チャレンジは、base64urlでエンコードされたオクテットで構成される文字列であり、サーバーはクライアントに応答へのサインインを要求します。パッシブオブザーバーからのリプレイ攻撃を防ぐために、チャレンジは401 HTTP応答ごとに一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "o A \"max-age\" attribute MUST be included. It specifies the number of seconds from the time the HTTP response is emitted for which responses to this challenge can be accepted; for example, \"max-age: 10\" would indicate ten seconds. If max-age is set to zero, then that means that only one signature will be accepted for this challenge.",
      "ja": "o 「max-age」属性を含める必要があります。これは、このチャレンジへの応答を受け入れることができるHTTP応答が発行されてからの秒数を指定します。たとえば、「max-age：10」は10秒を示します。 max-ageがゼロに設定されている場合、このチャレンジでは1つの署名のみが受け入れられます。"
    },
    {
      "indent": 3,
      "text": "o A \"realm\" attribute MAY be included to indicate the scope of protection in the manner described in HTTP/1.1, Authentication [RFC7235]. The \"realm\" attribute MUST NOT appear more than once.",
      "ja": "o HTTP / 1.1、認証[RFC7235]で説明されている方法で保護の範囲を示すために、「レルム」属性が含まれる場合があります。 「レルム」属性は2回以上指定してはなりません。"
    },
    {
      "indent": 3,
      "text": "When the \"client response\" is created, the UA encodes the HOBA client-result and returns that in the Authorization header. The client-result is a string matching the HOBA-RES production in Figure 2 as an auth-param with the name \"result\".",
      "ja": "「クライアント応答」が作成されると、UAはHOBAクライアント結果をエンコードし、Authorizationヘッダーで返します。 client-resultは、「result」という名前のauth-paramとして図2のHOBA-RESプロダクションに一致する文字列です。"
    },
    {
      "indent": 0,
      "text": " The server MUST check the cryptographic correctness of the signature based on a public key it knows for the kid in the signatures, and if the server cannot do that, or if the signature fails cryptographic checks, then validation has failed. The server can use any additional mechanisms to validate the signature. If the validation fails, or if the server chooses to reject the signature for any reason whatsoever, the server fails the request with a 401 Unauthorized HTTP response.",
      "ja": "サーバーは、署名の子供について知っている公開鍵に基づいて、署名の暗号の正しさをチェックする必要があります。サーバーがそれを行えない場合、または署名が暗号チェックに失敗した場合、検証は失敗しました。サーバーは、追加のメカニズムを使用して署名を検証できます。検証が失敗した場合、またはサーバーが何らかの理由で署名を拒否することを選択した場合、サーバーは401 Unauthorized HTTP応答で要求を失敗させます。"
    },
    {
      "indent": 3,
      "text": "The server MUST check that the same web origin is used in all of the server's TLS server certificates, the URL being accessed, and the HOBA signature. If any of those checks fail, the server treats the signature as being cryptographically incorrect.",
      "ja": "サーバーは、サーバーのすべてのTLSサーバー証明書、アクセスされるURL、およびHOBA署名で同じWebオリジンが使用されていることを確認する必要があります。これらのチェックのいずれかが失敗した場合、サーバーは署名を暗号的に正しくないものとして扱います。"
    },
    {
      "indent": 3,
      "text": "Note that a HOBA signature is good for however long a non-zero max-age parameter allows. This means that replay is possible within the time window specified by the \"max-age\" value chosen by the server. Servers can attempt to detect any such replay (via caching if they so choose) and MAY react to such replays by responding with a second (or subsequent) 401 HTTP response containing a new challenge.",
      "ja": "HOBAシグネチャは、ゼロ以外のmax-ageパラメーターが許可する限り有効です。これは、サーバーによって選択された「max-age」値によって指定された時間枠内で再生が可能であることを意味します。サーバーは、そのようなリプレイの検出を試み（選択した場合はキャッシングを介して）、新しいチャレンジを含む2番目（または後続）の401 HTTP応答で応答することにより、そのようなリプレイに反応してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "To optimize their use of challenges, UAs MAY prefetch a challenge value, for example, after (max-age)/2 seconds have elapsed, using the \".well-known/hoba/getchal\" scheme described later in this document. This also allows for precalculation of HOBA signatures, if that is required in order to produce a responsive user interface.",
      "ja": "チャレンジの使用を最適化するために、UAは、このドキュメントで後述する「.well-known / hoba / getchal」スキームを使用して、たとえば（max-age）/ 2秒が経過した後、チャレンジ値をプリフェッチできます（MAY）。これにより、応答性の高いユーザーインターフェイスを作成するために必要な場合は、HOBA署名の事前計算も可能になります。"
    },
    {
      "indent": 0,
      "text": "4. Introduction to the HOBA-js Mechanism",
      "section_title": true,
      "ja": "4. HOBA-jsメカニズムの概要"
    },
    {
      "indent": 3,
      "text": "Web sites using JavaScript can also perform origin-bound authentication without needing to involve the HTTP layer and by inference not needing HOBA-http support in browsers. HOBA-js is not an on-the-wire protocol like HOBA-http is; instead, it is a design pattern that can be realized completely in JavaScript served in normal HTML pages.",
      "ja": "JavaScriptを使用するWebサイトは、HTTPレイヤーを使用する必要がなく、ブラウザーでHOBA-httpサポートを必要としない推論によって、オリジンバインド認証を実行することもできます。 HOBA-jsは、HOBA-httpのようなネットワーク上のプロトコルではありません。代わりに、通常のHTMLページで提供されるJavaScriptで完全に実現できる設計パターンです。"
    },
    {
      "indent": 3,
      "text": "One thing that is highly desirable for HOBA-js is WebCrypto (see <http://www.w3.org/TR/WebCryptoAPI>), which is (at the time of writing) starting to see deployment. In lieu of WebCrypto, JavaScript crypto libraries can be employed with the known deficiencies of their pseudo-random number generators and the general immaturity of those libraries.",
      "ja": "HOBA-jsにとって非常に望ましいことの1つは、WebCrypto（<http://www.w3.org/TR/WebCryptoAPI>を参照）です。これは、（執筆時点で）展開を開始し始めています。 WebCryptoの代わりに、JavaScript暗号ライブラリーを、疑似乱数ジェネレーターの既知の欠陥とそれらのライブラリーの一般的な未熟さとともに使用できます。"
    },
    {
      "indent": 0,
      "text": " Without Webcrypto, one element is required for HOBA-js; localStorage (see <http://www.w3.org/TR/webstorage/>) from HTML5 can be used for persistent key storage. For example, an implementation would store a dictionary account identifier as well as public key and private key tuples in the origin's localStorage for subsequent authentication requests. How this information is actually stored in localStorage is an implementation detail. This type of key storage relies on the security properties of the same-origin policy that localStorage enforces. See the security considerations for discussion about attacks on localStorage. Note that IndexedDB (see <http://www.w3.org/TR/IndexedDB/>) is an alternative to localStorage that can also be used here and that is used by WebCrypto.",
      "ja": "Webcryptoがない場合、HOBA-jsには1つの要素が必要です。 HTML5のlocalStorage（<http://www.w3.org/TR/webstorage/>を参照）は、永続的なキーストレージに使用できます。たとえば、実装では、以降の認証リクエストのために、オリジンのlocalStorageに辞書アカウント識別子と公開鍵および秘密鍵のタプルを格納します。この情報が実際にlocalStorageに格納される方法は、実装の詳細です。このタイプのキーストレージは、localStorageが適用する同一生成元ポリシーのセキュリティプロパティに依存しています。 localStorageに対する攻撃については、セキュリティに関する考慮事項を参照してください。 IndexedDB（<http://www.w3.org/TR/IndexedDB/>を参照）はlocalStorageの代替であり、ここでも使用でき、WebCryptoで使用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Because of JavaScript's same-origin policy, scripts from subdomains do not have access to the same localStorage that scripts in their parent domains do. For larger or more complex sites, this could be an issue that requires enrollment into subdomains, which could be difficult for users. One way to get around this is to use session cookies because they can be used across subdomains. That is, with HOBA-js, the user might log in using a single well-known domain, and then session cookies are used whilst the user navigates around the site.",
      "ja": "JavaScriptの同じ生成元のポリシーにより、サブドメインのスクリプトは、親ドメインのスクリプトが行うのと同じlocalStorageにアクセスできません。大規模または複雑なサイトの場合、これはサブドメインへの登録を必要とする問題である可能性があり、ユーザーにとって難しい場合があります。これを回避する1つの方法は、サブドメイン間で使用できるため、セッションCookieを使用することです。つまり、HOBA-jsを使用すると、ユーザーは単一の既知のドメインを使用してログインし、ユーザーがサイト内を移動するときにセッションCookieが使用されます。"
    },
    {
      "indent": 0,
      "text": "5. HOBA's Authentication Process",
      "section_title": true,
      "ja": "5. HOBAの認証プロセス"
    },
    {
      "indent": 3,
      "text": "This section describes how clients and servers use HOBA for authentication. The interaction between an HTTP client and HTTP server using HOBA happens in three phases: the CPK preparation phase, the signing phase, and the authentication phase. This section also covers the actions that give HOBA features similar to today's password-based schemes.",
      "ja": "このセクションでは、クライアントとサーバーが認証にHOBAを使用する方法について説明します。 HOBAを使用したHTTPクライアントとHTTPサーバー間の対話は、CPK準備フェーズ、署名フェーズ、および認証フェーズの3つのフェーズで行われます。このセクションでは、今日のパスワードベースのスキームと同様のHOBA機能を提供するアクションについても説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. CPK Preparation Phase",
      "section_title": true,
      "ja": "5.1. CPK準備フェーズ"
    },
    {
      "indent": 3,
      "text": "In the CPK preparation phase, the client determines if it already has a CPK for the web origin with which it needs to authenticate. If the client has a CPK, the client will use it; if the client does not have a CPK, it generates one in anticipation of the server asking for one.",
      "ja": "CPK準備フェーズでは、クライアントは、認証が必要なWebオリジンのCPKがすでにあるかどうかを判断します。クライアントにCPKがある場合、クライアントはそれを使用します。クライアントにCPKがない場合は、サーバーが1つ要求することを見越して1つ生成します。"
    },
    {
      "indent": 0,
      "text": "5.2. Signing Phase",
      "section_title": true,
      "ja": "5.2. 署名フェーズ"
    },
    {
      "indent": 3,
      "text": "In the signing phase, the client connects to the server, the server asks for HOBA-based authentication, and the client authenticates by signing a blob of information as described in the previous sections.",
      "ja": "署名フェーズでは、クライアントはサーバーに接続し、サーバーはHOBAベースの認証を要求し、クライアントは前のセクションで説明したように情報のblobに署名することによって認証します。"
    },
    {
      "indent": 0,
      "text": "5.3. Authentication Phase",
      "section_title": true,
      "ja": "5.3. 認証フェーズ"
    },
    {
      "indent": 3,
      "text": "The authentication phase is completely dependent on the policies and practices of the server. That is, this phase involves no standardized protocol in HOBA-http; in HOBA-js, there is no suggested interaction template.",
      "ja": "認証フェーズは、サーバーのポリシーとプラクティスに完全に依存しています。つまり、このフェーズにはHOBA-httpの標準プロトコルは含まれません。 HOBA-jsでは、推奨される相互作用テンプレートはありません。"
    },
    {
      "indent": 3,
      "text": "In the authentication phase, the server uses the key identifier (kid) to determine the CPK from the signing phase and decides if it recognizes the CPK. If the server recognizes the CPK, the server may finish the client authentication process.",
      "ja": "認証フェーズでは、サーバーはキー識別子（kid）を使用して署名フェーズからCPKを決定し、CPKを認識するかどうかを決定します。サーバーがCPKを認識すると、サーバーはクライアント認証プロセスを終了する場合があります。"
    },
    {
      "indent": 3,
      "text": "If this stage of the process involves additional information for authentication, such as asking the user which account she wants to use (in the case where a UA is used for multiple accounts on a site), the server can prompt the user for account identifying information, or the user could choose based on HTML offered by the server before the 401 response is triggered. None of this is standardized: it all follows the server's security policy and session flow. At the end of this, the server probably assigns or updates a session cookie for the client.",
      "ja": "プロセスのこの段階で認証に追加情報が必要な場合（たとえば、サイトの複数のアカウントにUAが使用されている場合）、ユーザーにアカウントの識別情報を要求することができます。 、またはユーザーは、401応答がトリガーされる前にサーバーによって提供されるHTMLに基づいて選択できます。これはいずれも標準化されていません。すべてサーバーのセキュリティポリシーとセッションフローに従います。この最後に、サーバーはおそらくクライアントにセッションCookieを割り当てるか更新します。"
    },
    {
      "indent": 3,
      "text": "During the authentication phase, if the server cannot determine the correct CPK, it could use HTML and JavaScript to ask the user if they are really a new user or want to associate this new CPK with another CPK. The server can then use some out-of-band method (such as a confirmation email round trip, SMS, or a UA that is already enrolled) to verify that the \"new\" user is the same as the already-enrolled one. Thus, logging in on a new UA is identical to logging in with an existing account.",
      "ja": "認証フェーズ中に、サーバーが正しいCPKを判別できない場合、サーバーはHTMLおよびJavaScriptを使用して、ユーザーに本当に新しいユーザーであるか、またはこの新しいCPKを別のCPKに関連付けるかを尋ねます。次に、サーバーは帯域外の方法（確認メールの往復、SMS、または既に登録されているUAなど）を使用して、「新しい」ユーザーがすでに登録されているユーザーと同じであることを確認できます。したがって、新しいUAでのログインは、既存のアカウントでのログインと同じです。"
    },
    {
      "indent": 3,
      "text": "If the server does not recognize the CPK, the server might send the client through either a join or login-new-UA (see below) process. This process is completely up to the server and probably entails using HTML and JavaScript to ask the user some questions in order to assess whether or not the server wants to give the client an account. Completion of the joining process might require confirmation by email, SMS, CAPTCHA, and so on.",
      "ja": "サーバーがCPKを認識しない場合、サーバーはjoinまたはlogin-new-UA（下記を参照）プロセスのいずれかを介してクライアントを送信する可能性があります。このプロセスは完全にサーバー次第であり、おそらくサーバーがクライアントにアカウントを与えたいかどうかを評価するために、HTMLとJavaScriptを使用してユーザーにいくつかの質問をする必要があります。参加プロセスを完了するには、電子メール、SMS、CAPTCHAなどによる確認が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that there is no necessity for the server to initiate a joining or login process upon completion of the signing phase. Indeed, the server may desire to challenge the UA even for unprotected resources and set a session cookie for later use in a join or login process as it becomes necessary. For example, a server might only want to offer an account to someone who had been to a few pages on the web site; in such a case, the server could use the CPK from an associated session cookie as a way of building reputation for the user until the server wants the user to join.",
      "ja": "署名フェーズの完了時にサーバーが参加またはログインプロセスを開始する必要がないことに注意してください。実際、サーバーは、保護されていないリソースでもUAにチャレンジし、後で必要になったときに参加またはログインプロセスで使用するためにセッションCookieを設定することを望む場合があります。たとえば、サーバーは、Webサイトのいくつかのページにアクセスしたことがある人にのみアカウントを提供したい場合があります。このような場合、サーバーは、サーバーがユーザーの参加を希望するまで、ユーザーのレピュテーションを構築する方法として、関連付けられたセッションCookieのCPKを使用できます。"
    },
    {
      "indent": 0,
      "text": "6. Other Parts of the HOBA Process",
      "section_title": true,
      "ja": "6. HOBAプロセスの他の部分"
    },
    {
      "indent": 3,
      "text": "The authentication process is more than just the act of authentication. In password-based authentication and HOBA, there are other processes that are needed both before and after an authentication step. This section covers those processes. Where possible, it combines practices of HOBA-http and HOBA-js; where that is not possible, the differences are called out.",
      "ja": "認証プロセスは、単なる認証行為ではありません。パスワードベースの認証とHOBAでは、認証ステップの前後に必要な他のプロセスがあります。このセクションでは、これらのプロセスについて説明します。可能な場合は、HOBA-httpとHOBA-jsのプラクティスを組み合わせます。それが不可能な場合は、相違点が示されます。"
    },
    {
      "indent": 3,
      "text": "All HOBA interactions other than those defined in Section 5 MUST be performed in TLS-protected sessions [RFC5246]. If the current HTTP traffic is not running under TLS, a new session is started before any of the actions described here are performed.",
      "ja": "セクション5で定義されたもの以外のすべてのHOBA対話は、TLSで保護されたセッションで実行する必要があります[RFC5246]。現在のHTTPトラフィックがTLSで実行されていない場合、ここで説明するアクションが実行される前に新しいセッションが開始されます。"
    },
    {
      "indent": 3,
      "text": "HOBA-http uses a well-known URI [RFC5785] \"hoba\" as a base URI for performing many tasks: \"https://www.example.com/.well-known/hoba\". These URIs are based on the name of the host that the HTTP client is accessing.",
      "ja": "HOBA-httpは、よく知られているURI [RFC5785]「hoba」を、多くのタスクを実行するためのベースURIとして使用します：「https://www.example.com/.well-known/hoba」。これらのURIは、HTTPクライアントがアクセスしているホストの名前に基づいています。"
    },
    {
      "indent": 3,
      "text": "There are many use cases for these URLs to redirect to other URLs: a site that does registration through a federated site, a site that only does registration under HTTPS, and so on. Like any HTTP client, HOBA-http clients have to be able to handle redirection of these requests. However, as that would potentially cause security issues when a re-direct brings the client to a different web origin, servers implementing HOBA-http SHOULD NOT redirect to a different web origin from below \".well-known/hoba\" URLs. The above is considered sufficient to allow experimentation with HOBA, but if at some point HOBA is placed on the Standards Track, then a full analysis of off-origin redirections would need to be documented.",
      "ja": "これらのURLが他のURLにリダイレクトする多くの使用例があります。フェデレーションサイトを通じて登録を行うサイト、HTTPSでのみ登録を行うサイトなどです。他のHTTPクライアントと同様に、HOBA-httpクライアントはこれらの要求のリダイレクトを処理できる必要があります。ただし、リダイレクトによってクライアントが別のWebオリジンに移動したときにセキュリティの問題が発生する可能性があるため、HOBA-httpを実装するサーバーは、「。well-known / hoba」URLの下から別のWebオリジンにリダイレクトしないでください。上記はHOBAでの実験を可能にするのに十分であると考えられますが、ある時点でHOBAが標準化トラックに配置される場合、オフオリジンリダイレクトの完全な分析を文書化する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Registration",
      "section_title": true,
      "ja": "6.1. 登録"
    },
    {
      "indent": 3,
      "text": "Normally, a registration (also called \"joining\") is expected to happen after a UA receives a 401 response for a web origin and realm (for HOBA-http) or on demand (for HOBA-js) for which it has no associated CPK. The process of registration for a HOBA account on a server is relatively lightweight. The UA generates a new key pair and associates it with the web origin/realm in question.",
      "ja": "通常、登録（ \"参加\"とも呼ばれます）は、UAがWebオリジンとレルム（HOBA-httpの場合）またはオンデマンド（HOBA-jsの場合）の401応答を受信した後に発生し、CPKが関連付けられていない場合に発生します。 。サーバー上のHOBAアカウントの登録プロセスは比較的軽量です。 UAは新しいキーペアを生成し、それを問題のWebオリジン/レルムに関連付けます。"
    },
    {
      "indent": 3,
      "text": "Note that if the UA has a CPK associated with the web origin, but not for the realm concerned, then a new registration is REQUIRED. If the server did not wish for that outcome, then it ought to use the same or no realm.",
      "ja": "UAにWebオリジンに関連付けられたCPKがあるが、関連するレルムには関連付けられていない場合は、新規登録が必要です。サーバーがその結果を望まない場合は、同じレルムを使用するか、レルムを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The registration message for HOBA-http is sent as a POST message to the URL \".well-known/hoba/register\" with an HTML form (x-www-form-encoded, see <http://www.w3.org/TR/2014/REC-html5-20141028/ forms.html#url-encoded-form-data>), described below. The registration message for HOBA-js can be in any format specified by the server, but it could be the same as the one described here for HOBA-http. It is up to the server to decide what kind of user interaction is required before the account is finally set up. When the server's chosen registration flow is completed successfully, the server MUST add a Hobareg HTTP header (see Section 6.1.1) to the HTTP response message that completes the registration flow.",
      "ja": "HOBA-httpの登録メッセージは、POSTメッセージとしてHTMLフォーム（x-www-form-encoded、<http://www.w3.org /TR/2014/REC-html5-20141028/forms.html#url-encoded-form-data>）、以下で説明します。 HOBA-jsの登録メッセージは、サーバーで指定された任意の形式にすることができますが、HOBA-httpについてここで説明されているものと同じにすることができます。アカウントが最終的に設定される前に、どのような種類のユーザー操作が必要かを決定するのはサーバーです。サーバーの選択された登録フローが正常に完了すると、サーバーは、登録フローを完了するHTTP応答メッセージにHobareg HTTPヘッダー（セクション6.1.1を参照）を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The registration message sent to the server has one mandatory field (pub) and some optional fields that allow the UA to specify the type and value of key and device identifiers that the UA wishes to use.",
      "ja": "サーバーに送信される登録メッセージには、1つの必須フィールド（pub）と、UAが使用するキーとデバイス識別子のタイプと値をUAで指定できるようにするいくつかのオプションフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "o pub: a mandatory field containing the Privacy Enhanced Mail (PEM) formatted public key of the client. See Appendix C of [RFC6376] for an example of how to generate this key format.",
      "ja": "o pub：クライアントのプライバシー強化メール（PEM）形式の公開鍵を含む必須フィールド。この鍵形式を生成する方法の例については、[RFC6376]の付録Cを参照してください。"
    },
    {
      "indent": 3,
      "text": "o kidtype: contains the type of key identifier. This is a numeric value intended to contain one of the values from Section 9.4. If this is not present, then the mandatory-to-implement hashed public key option MUST be used.",
      "ja": "o kidtype：キー識別子のタイプを含みます。これは、9.4項のいずれかの値を含むことを目的とした数値です。これが存在しない場合は、実装が必須のハッシュ公開鍵オプションを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o kid: contains the key identifier as a base64url-encoded string that is of the type indicated in the kidtype. If the kid is a hash of a public key, then the correct (base64url-encoded) hash value MUST be provided and the server SHOULD check that and refuse the registration if an incorrect value was supplied.",
      "ja": "o kid：kidtypeで示されたタイプのbase64urlエンコード文字列としてキー識別子を含みます。子供が公開鍵のハッシュである場合、正しい（base64urlでエンコードされた）ハッシュ値を指定する必要があり、サーバーはそれを確認して、不正な値が指定された場合は登録を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "o didtype: specifies a kind of device identifier intended to contain one of the values from Section 9.5. If absent, then the \"string\" form of device identifier defined in Section 9.5 MUST be used.",
      "ja": "o didtype：セクション9.5の値の1つを含めることを目的とした一種のデバイス識別子を指定します。存在しない場合、セクション9.5で定義された「文字列」形式のデバイス識別子を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o did: a UTF-8 string that specifies the device identifier. This can be used to help a user be confident that authentication has worked, e.g., following authentication, some web content might say \"You last logged in from device 'did' at time T.\"",
      "ja": "o did：デバイス識別子を指定するUTF-8文字列。これは、認証が機能したことをユーザーが確信できるようにするために使用できます。たとえば、認証に続いて、一部のWebコンテンツに「最後にログインしたのは、時刻Tにデバイス 'did'でした」と表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that replay of registration (and other HOBA) messages is quite possible. That, however, can be counteracted if challenge freshness is ensured. See Section 2 for details. Note also that with HOBA-http, the HOBA signature does not cover the POST message body. If that is required, then HOBA-JS may be a better fit for registration and other account management actions.",
      "ja": "登録（およびその他のHOBA）メッセージの再生はかなり可能です。ただし、チャレンジの鮮度が確保されている場合は、これを打ち消すことができます。詳細については、セクション2を参照してください。 HOBA-httpでは、HOBA署名はPOSTメッセージ本文をカバーしないことにも注意してください。それが必要な場合は、HOBA-JSが登録やその他のアカウント管理アクションに適している可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Hobareg Definition",
      "section_title": true,
      "ja": "6.1.1. ホバレグの定義"
    },
    {
      "indent": 3,
      "text": "Since registration can often be a multi-step process, e.g., requiring a user to fill in contact details, the initial response to the HTTP POST message defined above may not be the end of the registration process even though the HTTP response has a 200 OK status. This creates an issue for the UA since, during the registration process (e.g., while dealing with interstitial pages), the UA doesn't yet know whether the CPK is good for that web origin or not.",
      "ja": "登録は多くの場合、ユーザーが連絡先の詳細を入力する必要があるなどの複数ステップのプロセスになる可能性があるため、上記で定義されたHTTP POSTメッセージに対する最初の応答は、HTTP応答に200 OK状態。これは、登録プロセス中（インタースティシャルページの処理中など）に、UAがCPKがそのWebオリジンに適しているかどうかをまだ認識していないため、UAに問題を引き起こします。"
    },
    {
      "indent": 0,
      "text": " For this reason, the server MUST add a header field to the response message when the registration has succeeded in order to indicate the new state. The header to be used is \"Hobareg\", and the value when registration has succeeded is to be \"regok\". When registration is in an intermediate state (e.g., on an HTTP response for an interstitial page), the server MAY add this header with a value of \"reginwork\". See Section 9.6 for the relevant IANA registration of this header field.",
      "ja": "このため、サーバーは、新しい状態を示すために、登録が成功したときにヘッダーフィールドを応答メッセージに追加する必要があります。使用するヘッダは「Hobareg」で、登録成功時の値は「regok」となります。登録が中間状態（インタースティシャルページのHTTP応答など）の場合、サーバーはこのヘッダーに「reginwork」の値を追加できます（MAY）。このヘッダーフィールドの関連するIANA登録については、セクション9.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "For interstitial pages, the client MAY include a HOBA Authorization header. This is not considered a \"MUST\", as that might needlessly complicate client implementations, but is noted here in case a server implementer assumes that all registration messages contain a HOBA Authorization header.",
      "ja": "インタースティシャルページの場合、クライアントはHOBA Authorizationヘッダーを含めることができます。クライアントの実装を不必要に複雑にする可能性があるため、これは「必須」とは見なされませんが、サーバーの実装者がすべての登録メッセージにHOBA Authorizationヘッダーが含まれていると想定している場合に備えて、ここで注記します。"
    },
    {
      "indent": 6,
      "text": "Hobareg-val = \"regok\" / \"reginwork\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 3: Hobareg Header Field Definition",
      "ja": "図3：Hobaregヘッダーフィールドの定義"
    },
    {
      "indent": 3,
      "text": "Figure 3 provides an ABNF definition for the values allowed in the Hobareg header field. Note that these (and the header field name) are case insensitive. Section 8.3.1 of [RFC7231] calls for documenting the following details for this new header field:",
      "ja": "図3は、Hobaregヘッダーフィールドで許可される値のABNF定義を示しています。これら（およびヘッダーフィールド名）は大文字と小文字を区別しないことに注意してください。 [RFC7231]のセクション8.3.1では、この新しいヘッダーフィールドに関する以下の詳細を文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Only one single value is allowed in a Hobareg header field. Should more than one (a list) be encountered, or any other ABNF-invalid value, that SHOULD be interpreted as being the same as \"reginwork\".",
      "ja": "o Hobaregヘッダーフィールドで許可される単一の値のみ。複数（リスト）に遭遇した場合、または他のABNF無効な値に遭遇した場合、「reginwork」と同じものとして解釈されるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o The Hobareg header field can only be used in HTTP responses.",
      "ja": "o Hobaregヘッダーフィールドは、HTTP応答でのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "o Since Hobareg is only meant for responses, it ought not appear in requests.",
      "ja": "o Hobaregは応答のみを目的としているため、リクエストには表示されません。"
    },
    {
      "indent": 3,
      "text": "o The HTTP response code does affect the interpretation of Hobareg. Registration is only considered to have succeeded if the regok value is seen in a 2xx response. 4xx and other errors mean that registration has failed regardless of the value of Hobareg seen. The request method has no influence on the interpretation of Hobareg.",
      "ja": "o HTTP応答コードはHobaregの解釈に影響を与えます。登録は、regok値が2xx応答で見られる場合にのみ成功したと見なされます。 4xxおよびその他のエラーは、表示されたHobaregの値に関係なく、登録が失敗したことを意味します。 requestメソッドはHobaregの解釈に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "o Intermediaries never insert, delete, or modify a Hobareg header field.",
      "ja": "o 仲介者がHobaregヘッダーフィールドを挿入、削除、または変更することはありません。"
    },
    {
      "indent": 3,
      "text": "o As a response-only header field, it is not appropriate to list a Hobareg in a Vary response header field.",
      "ja": "o 応答のみのヘッダーフィールドとして、Vary応答ヘッダーフィールドにHobaregをリストすることは適切ではありません。"
    },
    {
      "indent": 3,
      "text": "o Hobareg is allowed in trailers.",
      "ja": "o Hobaregはトレーラーで許可されています。"
    },
    {
      "indent": 3,
      "text": "o As a response-only header field, Hobareg will not be preserved across re-directs.",
      "ja": "o 応答のみのヘッダーフィールドとして、ホバレグはリダイレクト間で保持されません。"
    },
    {
      "indent": 3,
      "text": "o Hobareg itself discloses little security- or privacy-sensitive information. If an attacker can somehow detect that a Hobareg header field is being added, then that attacker would know that the UA is in the process of registration, which could be significant. However, it is likely that the set of messages between the UA and server would expose this information in many cases, regardless of whether or not TLS is used. Using TLS is still, however, a good plan.",
      "ja": "o Hobareg自体は、セキュリティやプライバシーに敏感な情報をほとんど開示していません。攻撃者がHobaregヘッダーフィールドが追加されていることを何らかの方法で検出できる場合、その攻撃者はUAが登録処理中であることを知る可能性があります。ただし、TLSが使用されているかどうかに関係なく、UAとサーバー間の一連のメッセージがこの情報を公開することがよくあります。ただし、TLSの使用は依然として適切な計画です。"
    },
    {
      "indent": 0,
      "text": "6.2. Associating Additional Keys to an Existing Account",
      "section_title": true,
      "ja": "6.2. 追加のキーを既存のアカウントに関連付ける"
    },
    {
      "indent": 3,
      "text": "From the user perspective, the UA having a CPK for a web origin will often appear to be the same as having a way to sign in to an account at that web site. Since users often have more than one UA, and since the CPKs are, in general, UA specific, that raises the question of how the user can sign in to that account from different UAs. And from the server perspective, that turns into the question of how to safely bind different CPKs to one account. In this section, we describe some ways in which this can be done, as well as one way in which this ought not be done.",
      "ja": "ユーザーの観点から見ると、WebオリジンのCPKを持つUAは、そのWebサイトのアカウントにサインインする方法を持つのと同じように見えることがよくあります。ユーザーは複数のUAを持っていることが多く、CPKは一般にUA固有であるため、ユーザーがさまざまなUAからそのアカウントにどのようにサインインできるかという疑問が生じます。そして、サーバーの観点からは、異なるCPKを1つのアカウントに安全にバインドする方法の問題に変わります。このセクションでは、これを実行できるいくつかの方法と、これを実行してはならない1つの方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Note that the context here is usually that the user has succeeded in registering with one or more UAs (for the purposes of this section, we call this \"the first UA\" below) and can use HOBA with those, and the user is now adding another UA. The newest UA might or might not have a CPK for the site in question. Since it is in fact trivial, we assume that the site is able to put in place some appropriate, quicker, easier registration for a CPK for the newest UA. The issue then becomes one of binding the CPK from the newest UA with those of other UAs bound to the account.",
      "ja": "ここでのコンテキストは通常​​、ユーザーが1つ以上のUAへの登録に成功し（このセクションでは、これを「最初のUA」と呼びます）、HOBAをそれらと一緒に使用できることに注意してください。別のUA。最新のUAには、問題のサイトのCPKがある場合とない場合があります。それは実際には取るに足らないことなので、サイトは最新のUAのCPKに対して適切で迅速かつ簡単な登録を行うことができると想定しています。次に、問題は、最新のUAからのCPKを、アカウントにバインドされている他のUAのCPKとバインドすることの1つになります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Moving Private Keys",
      "section_title": true,
      "ja": "6.2.1. 秘密鍵の移動"
    },
    {
      "indent": 3,
      "text": "It is common for a user to have multiple UAs and to want all those UAs to be able to authenticate to a single account. One method to allow a user who has an existing account to be able to authenticate on a second device is to securely transport the private and public keys and the origin information from the first device to the second. If this approach is taken, then there is no impact on the HOBA-http or HOBA-js, so this is a pure UA implementation issue and not discussed further.",
      "ja": "ユーザーが複数のUAを持ち、それらすべてのUAが単一のアカウントに対して認証できるようにすることは一般的です。既存のアカウントを持つユーザーが2番目のデバイスで認証できるようにする1つの方法は、秘密キーと公開キー、および発信元情報を最初のデバイスから2番目のデバイスに安全に転送することです。このアプローチを採用した場合、HOBA-httpまたはHOBA-jsへの影響はないため、これは純粋なUA実装の問題であり、これ以上は説明しません。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Human-Memorable One-Time Password (Don't Do This One)",
      "section_title": true,
      "ja": "6.2.2. 人間が覚えやすいワンタイムパスワード（これを行わないでください）"
    },
    {
      "indent": 0,
      "text": " It will be tempting for implementers to use a human-memorable One-Time Password (OTP) in order to \"authenticate\" binding CPKs to the same account. The workflow here would likely be something along the lines of some server administrative utility generating a human- memorable OTP such as \"1234\" and sending that to the user out of band for the user to enter at two web pages, each authenticated via the relevant CPK. While this seems obvious enough and could even be secure enough in some limited cases, we consider that this is too risky to use in the Internet, and so servers SHOULD NOT provide such a mechanism. The reason this is so dangerous is that it would be trivial for an automated client to guess such tokens and \"steal\" the binding intended for some other user. At any scale, there would always be some in-process bindings so that even with only a trickle of guesses (and hence not being detectable via message volume), an attacker would have a high probability of succeeding in registering a binding with the attacker's CPK.",
      "ja": "同じアカウントへのCPKのバインドを「認証」するために、実装者が人間が記憶できるワンタイムパスワード（OTP）を使用するのは魅力的です。ここでのワークフローは、「1234」などの記憶に残るOTPを生成し、2つのWebページにユーザーが入力できるように帯域外でユーザーに送信するサーバー管理ユーティリティのラインに沿ったものである可能性があります。 CPK。これは十分に明白であり、一部の限られたケースでは十分に安全である可能性もありますが、これはインターネットで使用するには危険すぎるため、サーバーはそのようなメカニズムを提供しないでください。これが非常に危険である理由は、自動化されたクライアントがそのようなトークンを推測し、他のユーザー向けのバインディングを「盗む」ことは簡単なことです。どんなスケールでも、常にいくつかのインプロセスバインディングが存在するため、推測の細流が1つしかなくても（したがって、メッセージの量では検出できません）、攻撃者はバインディングを攻撃者のCPKに登録することに成功する可能性が高くなります。 。"
    },
    {
      "indent": 3,
      "text": "This method of binding CPKs together is therefore NOT RECOMMENDED.",
      "ja": "したがって、CPKを一緒にバインドするこの方法はお勧めしません。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Out-of-Band URL",
      "section_title": true,
      "ja": "6.2.3. アウトオブバンドURL"
    },
    {
      "indent": 3,
      "text": "One easy binding method is to simply provide a web page where, using the first UA, the user can generate a URL (containing some \"unguessable\" cryptographically generated value) that the user then later dereferences on the newest UA. The user could email that URL to herself, for example, or the web server accessed at the first UA could automatically do that.",
      "ja": "簡単なバインディング方法の1つは、最初のUAを使用して、ユーザーがURLを生成できるWebページを提供することです（ユーザーは、「最新のUAで参照できない」暗号化された値を含みます）。たとえば、ユーザーはそのURLを自分宛てに電子メールで送信したり、最初のUAでアクセスしたWebサーバーが自動的に送信したりできます。"
    },
    {
      "indent": 3,
      "text": "Such a URL SHOULD contain at least the equivalent of 128 bits of randomness.",
      "ja": "そのようなURLには、少なくとも128ビットのランダム性と同等のものを含める必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "6.3. Logging Out",
      "section_title": true,
      "ja": "6.3. ログアウト"
    },
    {
      "indent": 3,
      "text": "The user can tell the server it wishes to log out. With HOBA-http, this is done by sending a HOBA-authenticated POST message to the URL \".well-known/hoba/logout\" on the site in question. The UA SHOULD also delete session cookies associated with the session so that the user's state is no longer \"logged in.\"",
      "ja": "ユーザーは、ログアウトするサーバーを指定できます。 HOBA-httpでは、これは、問題のサイトのURL \".well-known / hoba / logout\"にHOBA認証のPOSTメッセージを送信することで行われます。 UAは、ユーザーの状態が「ログイン」されないように、セッションに関連付けられたセッションCookieも削除する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT allow TLS session resumption for any logged out session.",
      "ja": "サーバーは、ログアウトしたセッションのTLSセッションの再開を許可してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD also revoke or delete any cookies associated with the session.",
      "ja": "サーバーはまた、セッションに関連付けられたCookieを取り消しまたは削除する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "6.4. Getting a Fresh Challenge",
      "section_title": true,
      "ja": "6.4. 新たな挑戦を受ける"
    },
    {
      "indent": 3,
      "text": "The UA can get a \"fresh\" challenge from the server. In HOBA-http, it sends a POST message to \".well-known/hoba/getchal\". If successful, the response MUST contain a fresh (base64url-encoded) HOBA challenge for this origin in the body of the response. Whitespace in the response MUST be ignored.",
      "ja": "UAはサーバーから「新しい」チャレンジを取得できます。 HOBA-httpでは、POSTメッセージを「.well-known / hoba / getchal」に送信します。成功した場合、応答の本文には、このオリジンに対する新しい（base64urlでエンコードされた）HOBAチャレンジが含まれている必要があります。応答の空白は無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Mandatory-to-Implement Algorithms",
      "section_title": true,
      "ja": "7. 必須の実装アルゴリズム"
    },
    {
      "indent": 3,
      "text": "RSA-SHA256 MUST be supported. HOBA implementations MUST use RSA-SHA256 if it is provided by the underlying cryptographic libraries. RSA-SHA1 MAY be used. RSA modulus lengths of at least 2048 bits SHOULD be used. RSA indicates the RSASSA-PKCS1-v1_5 algorithm defined in Section 8.2 of [RFC3447], and SHA-1 and SHA-256 are defined in [SHS]. Keys with moduli shorter than 2048 bits SHOULD only be used in cases where generating 2048-bit (or longer) keys is impractical, e.g., on very constrained or old devices.",
      "ja": "RSA-SHA256をサポートする必要があります。 HOBA実装は、RSA-SHA256を使用する必要があります（基盤となる暗号化ライブラリによって提供される場合）。 RSA-SHA1を使用できます。少なくとも2048ビットのRSAモジュラス長を使用する必要があります。 RSAは、[RFC3447]のセクション8.2で定義されたRSASSA-PKCS1-v1_5アルゴリズムを示し、SHA-1およびSHA-256は[SHS]で定義されています。モジュラスが2048ビットより短いキーは、非常に制約されたデバイスや古いデバイスなど、2048ビット（またはそれ以上）のキーの生成が実用的でない場合にのみ使用してください。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Binding my CPK with someone else's account would be fun and profitable so SHOULD be appropriately hard. In particular, URLs or other values generated by the server as part of any CPK binding process MUST be hard to guess, for whatever level of difficulty is chosen by the server. The server SHOULD NOT allow a random guess to reveal whether or not an account exists.",
      "ja": "私のCPKを他の誰かのアカウントにバインドすることは、楽しくて利益があるので、適切に難しいものであるべきです。特に、CPKバインディングプロセスの一部としてサーバーによって生成されたURLまたはその他の値は、サーバーがどのような難易度を選択しても、推測するのは困難です。サーバーは、アカウントが存在するかどうかをランダムな推測で明らかにすべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "If key binding was server selected, then a bad actor could bind different accounts belonging to the user from the network with possible bad consequences, especially if one of the private keys was compromised somehow.",
      "ja": "キーバインディングがサーバーで選択されている場合、特に非公開キーの1つが何らかの形で危険にさらされている場合、悪意のあるアクターはネットワークからユーザーに属するさまざまなアカウントをバインドして、悪影響をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "When the max-age parameter is not zero, then a HOBA signature has a property that is like a bearer token for the relevant number of seconds: it can be replayed for a server-selected duration. Similarly, for HOBA-js, signatures might be replayable depending on the specific implementation. The security considerations of [RFC6750] therefore apply in any case where the HOBA signature can be replayed. Server administrators can set the max-age to the minimum acceptable value in such cases, which would often be expected to be just a few seconds. There seems to be no reason to ever set the max-age more than a few minutes; the value ought also decrease over time as device capabilities improve. The administrator will most likely want to set the max-age to something that is not too short for the slowest signing device that is significant for that site.",
      "ja": "max-ageパラメーターがゼロでない場合、HOBAシグニチャーには、該当する秒数の無記名トークンのようなプロパティーがあり、サーバーが選択した期間再生できます。同様に、HOBA-jsの場合、特定の実装によってはシグニチャが再生可能になる場合があります。したがって、[RFC6750]のセキュリティに関する考慮事項は、HOBA署名を再生できるすべての場合に適用されます。サーバー管理者は、そのような場合にmax-ageを最小許容値に設定できます。これは、ほんの数秒であると予想されることがよくあります。 max-ageを数分以上設定する理由はないようです。また、デバイスの機能が向上するにつれて、時間の経過とともに価値が低下するはずです。管理者は、そのサイトにとって重要な、最も遅い署名デバイスにとって短すぎない値にmax-ageを設定する可能性が高いでしょう。"
    },
    {
      "indent": 0,
      "text": "8.1. Privacy Considerations",
      "section_title": true,
      "ja": "8.1. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "HOBA does, to some extent, impact privacy and could be considered to represent a super-cookie to the server or to any entity on the path from UA to HTTP server that can see the HOBA signature. This is because we need to send a key identifier as part of the signature and that will not vary for a given key. For this reason, and others, it is strongly RECOMMENDED to only use HOBA over server-authenticated TLS and to migrate web sites using HOBA to only use \"https\" URLs.",
      "ja": "HOBAはある程度プライバシーに影響を与え、サーバーまたはUAからHTTPサーバーへのパス上の、HOBA署名を見ることができるエンティティーへのスーパーCookieを表すと見なすことができます。これは、署名の一部としてキー識別子を送信する必要があるためであり、指定されたキーによって変化することはありません。このため、およびその他の理由から、サーバー認証されたTLSではなくHOBAのみを使用し、HOBAを使用して \"https\" URLのみを使用するようにWebサイトを移行することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD provide users a way to manage their CPKs. Ideally, there would be a way for a user to maintain their HOBA details for a site while at the same time deleting other site information such as cookies or non-HOBA HTML5 localStorage. However, as this is likely to be complex, and appropriate user interfaces counterintuitive, we expect that UAs that implement HOBA will likely treat HOBA information as just some more site data that would disappear should the user choose to \"forget\" that site.",
      "ja": "UAはユーザーにCPKを管理する方法を提供する必要があります（SHOULD）。理想的には、ユーザーがサイトのHOBA詳細を維持すると同時に、Cookieや非HOBA HTML5 localStorageなどの他のサイト情報を削除する方法が存在します。ただし、これは複雑で適切なユーザーインターフェイスが直感に反する可能性が高いため、HOBAを実装するUAはHOBA情報を、ユーザーがそのサイトを「忘れた」場合に表示されなくなるいくつかのサイトデータとして扱うと考えられます。"
    },
    {
      "indent": 3,
      "text": "Device identifiers are intended to specify classes of device in a way that can assist with registration and with presentation to the user of information about previous sessions, e.g., last login time. Device identifier types MUST NOT be privacy sensitive, with values that would allow tracking a user in unexpected ways. In particular, using a device identifier type that is analogous to the International Mobile Equipment Identifier (IMEI) would be a really bad idea and is the reason for the \"MUST NOT\" above. In that case, \"mobile phone\" could be an acceptable choice.",
      "ja": "デバイス識別子は、前回のログイン時間など、以前のセッションに関する情報をユーザーに登録および提示できるように、デバイスのクラスを指定することを目的としています。デバイス識別子のタイプはプライバシーに配慮してはならず、予期しない方法でユーザーを追跡できる値を使用する必要があります。特に、International Mobile Equipment Identifier（IMEI）に類似したデバイス識別子タイプを使用することは非常に悪い考えであり、上記の「必須ではない」理由です。その場合、「携帯電話」は許容できる選択肢です。"
    },
    {
      "indent": 3,
      "text": "If possible, implementations ought to encourage the use of device identifier values that are not personally identifying except for the user concerned; for example, \"Alice's mobile\" is likely to be chosen and is somewhat identifying, but \"Alice's phone: UUID 1234-5567- 89abc-def0\" would be a very bad choice.",
      "ja": "可能な場合、実装は、関係するユーザーを除いて個人を識別しないデバイス識別子の値の使用を奨励する必要があります。たとえば、「アリスの携帯電話」が選択される可能性が高く、ある程度は識別できますが、「アリスの電話：UUID 1234-5567-89abc-def0」は非常に悪い選択です。"
    },
    {
      "indent": 0,
      "text": "8.2. localStorage Security for JavaScript",
      "section_title": true,
      "ja": "8.2. JavaScriptのlocalStorageセキュリティ"
    },
    {
      "indent": 3,
      "text": "The use of localStorage (likely with a non-WebCrypto implementation of HOBA-js) will undoubtedly be a cause for concern. localStorage uses the same-origin model that says that the scheme, domain, and port define a localStorage instance. Beyond that, any code executing will have access to private keying material. Of particular concern are Cross-Site Scripting (XSS) attacks, which could conceivably take the keying material and use it to create UAs under the control of an attacker. XSS attacks are, in reality, devastating across the board since they can and do steal credit card information, passwords, perform illicit acts, etc. It's not evident that we are introducing unique threats from which cleartext passwords don't already suffer.",
      "ja": "localStorageの使用（HOBA-jsの非WebCrypto実装での可能性が高い）は、疑いの余地なく問題の原因になります。 localStorageは、スキーム、ドメイン、ポートがlocalStorageインスタンスを定義するという同じ起源のモデルを使用します。それを超えて、実行するコードはすべて秘密鍵の資料にアクセスできます。特に懸念されるのはクロスサイトスクリプティング（XSS）攻撃であり、これはおそらくキー情報を取得し、それを使用して攻撃者の制御下でUAを作成する可能性があります。 XSS攻撃は、実際には、クレジットカード情報やパスワードを盗んだり、不正な行為をしたりすることができるため、全面的に破壊的です。クリアテキストのパスワードがまだ影響を受けていない独自の脅威を導入していることは明らかではありません。"
    },
    {
      "indent": 0,
      "text": " Another source of concern is local access to the keys. That is, if an attacker has access to the UA itself, they could snoop on the key through a JavaScript console or find the file(s) that implement localStorage on the host computer. Again, it's not clear that we are worse in this regard because the same attacker could get at browser password files, etc., too. One possible mitigation is to encrypt the keystore with a password/PIN that the user supplies. This may sound counterintuitive, but the object here is to keep passwords off of servers to mitigate the multiplier effect of a large-scale compromise (e.g., [ThreatReport]) because of shared passwords across sites.",
      "ja": "もう1つの懸念事項は、キーへのローカルアクセスです。つまり、攻撃者がUA自体にアクセスできる場合、JavaScriptコンソールを介してキーをスヌープするか、ホストコンピューターにlocalStorageを実装するファイルを見つけることができます。繰り返しになりますが、同じ攻撃者がブラウザのパスワードファイルなどにもアクセスできる可能性があるため、この点で私たちがさらに悪いことは明らかではありません。考えられる1つの緩和策は、ユーザーが提供するパスワード/ PINを使用してキーストアを暗号化することです。これは直観に反するように思えるかもしれませんが、ここでの目的は、サイト間でパスワードを共有するため、サーバーからパスワードを離して、大規模な侵害（[ThreatReport]など）の相乗効果を軽減することです。"
    },
    {
      "indent": 3,
      "text": "It's worth noting that HOBA uses asymmetric keys and not passwords when evaluating threats. As various password database leaks have shown, the real threat of a password breach is not just to the site that was breached, it's also to all of the sites on which a user used the same password. That is, the collateral damage is severe because password reuse is common. Storing a password in localStorage would also have a similar multiplier effect for an attacker, though perhaps on a smaller scale than a server-side compromise: one successful crack gains the attacker potential access to hundreds if not thousands of sites the user visits. HOBA does not suffer from that attack multiplier since each asymmetric key pair is unique per site/UA/user.",
      "ja": "脅威を評価する場合、HOBAはパスワードではなく非対称キーを使用することに注意してください。さまざまなパスワードデータベースリークが示しているように、パスワード侵害の本当の脅威は、侵害されたサイトだけでなく、ユーザーが同じパスワードを使用したすべてのサイトにもあります。つまり、パスワードの再利用が一般的であるため、副次的な被害は深刻です。 localStorageにパスワードを保存すると、攻撃者にとっても同様の乗数効果がありますが、サーバー側の侵害よりも規模は小さいかもしれません。1つのクラックが成功すると、攻撃者はユーザーがアクセスする数千のサイトではなくても数百のサイトにアクセスする可能性があります。各非対称キーペアはサイト/ UA /ユーザーごとに一意であるため、HOBAはその攻撃乗数の影響を受けません。"
    },
    {
      "indent": 0,
      "text": "8.3. Multiple Accounts on One User Agent",
      "section_title": true,
      "ja": "8.3. 1つのユーザーエージェント上の複数のアカウント"
    },
    {
      "indent": 3,
      "text": "A shared UA with multiple accounts is possible if the account identifier is stored along with the asymmetric key pair binding them to one another. Multiple entries can be kept, one for each account, and selected by the current user. This, of course, is fraught with the possibility for abuse, since a server is potentially enrolling the device for a long period and the user may not want to have to be responsible for the credential for that long. To alleviate this problem, the user could request that the credential be erased from the browser. Similarly, during the enrollment phase, a user could request that the key pair only be kept for a certain amount of time or that it not be stored beyond the current browser session. However, all such features really ought to be part of the operating system or platform and not part of a HOBA implementation, so those are not discussed further.",
      "ja": "複数のアカウントを持つ共有UAは、アカウント識別子がそれらを互いにバインドする非対称キーペアと共に保存されている場合に可能です。アカウントごとに1つずつ、複数のエントリを保持し、現在のユーザーが選択できます。もちろん、サーバーは長期間デバイスを登録している可能性があり、ユーザーはその資格情報に長期間責任を負う必要がない場合があるため、これは不正使用の可能性に満ちています。この問題を軽減するために、ユーザーは資格情報をブラウザーから消去するように要求できます。同様に、登録フェーズ中に、ユーザーはキーペアを特定の時間だけ保持すること、または現在のブラウザセッションを超えてキーペアを保存しないことを要求できます。ただし、そのような機能はすべて、オペレーティングシステムまたはプラットフォームの一部であり、HOBA実装の一部ではないため、これ以上は説明しません。"
    },
    {
      "indent": 0,
      "text": "8.4. Injective Mapping for HOBA-TBS",
      "section_title": true,
      "ja": "8.4. HOBA-TBSの単射マッピング"
    },
    {
      "indent": 3,
      "text": "The repeated length fields in the HOBA-TBS structure are present in order to ensure that there is no possibility that the catenation of different input values can cause confusion that might lead to an attack, either against HOBA as specified here, or else an attack against some other protocol that reused this to-be-signed structure. Those fields ensure that the mapping from input fields to the HOBA-TBS string is an injective mapping.",
      "ja": "HOBA-TBS構造の繰り返しの長さフィールドは、異なる入力値の連結が混乱を引き起こし、ここで指定されたHOBAに対する攻撃、またはそれに対する攻撃につながる可能性がないことを保証するために存在します。この署名対象の構造を再利用した他のプロトコル。これらのフィールドは、入力フィールドからHOBA-TBS文字列へのマッピングが単射マッピングであることを保証します。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made registrations and created new registries as described below.",
      "ja": "IANAは、以下の説明に従って登録を行い、新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "All new registries have been placed beneath a new \"HTTP Origin-Bound Authentication (HOBA) Parameters\" category.",
      "ja": "すべての新しいレジストリは、新しい「HTTP Origin-Bound Authentication（HOBA）パラメータ」カテゴリの下に配置されています。"
    },
    {
      "indent": 0,
      "text": "9.1. HOBA Authentication Scheme",
      "section_title": true,
      "ja": "9.1. ほば あうてぇんちかちおん Ｓちぇめ"
    },
    {
      "indent": 3,
      "text": "A new scheme has been registered in the HTTP Authentication Scheme Registry as follows:",
      "ja": "新しいスキームは、次のようにHTTP認証スキームレジストリに登録されています。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name: HOBA",
      "ja": "認証スキーム名：HOBA"
    },
    {
      "indent": 3,
      "text": "Reference: Section 3 of RFC 7486",
      "ja": "参照：RFC 7486のセクション3"
    },
    {
      "indent": 3,
      "text": "Notes (optional): The HOBA scheme can be used with either HTTP servers or proxies. When used in response to a 407 Proxy Authentication Required indication, the appropriate proxy authentication header fields are used instead, as with any other HTTP authentication scheme.",
      "ja": "注（オプション）：HOBAスキームは、HTTPサーバーまたはプロキシのいずれかで使用できます。他のHTTP認証スキームと同様に、「407プロキシ認証が必要」の指示に応じて使用される場合は、代わりに適切なプロキシ認証ヘッダーフィールドが使用されます。"
    },
    {
      "indent": 0,
      "text": "9.2. .well-known URI",
      "section_title": true,
      "ja": "9.2. .well-known URI"
    },
    {
      "indent": 3,
      "text": "A new .well-known URI has been registered in the Well-Known URIs registry as described below.",
      "ja": "以下に説明するように、新しい.well-known URIがWell-Known URIレジストリに登録されました。"
    },
    {
      "indent": 3,
      "text": "URI Suffix: hoba",
      "ja": "うり すっふぃｘ： ほば"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "コントローラの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 6 of RFC 7486",
      "ja": "参照：RFC 7486のセクション6"
    },
    {
      "indent": 3,
      "text": "Related Information: N/A",
      "ja": "関連情報：なし"
    },
    {
      "indent": 0,
      "text": "9.3. Algorithm Names",
      "section_title": true,
      "ja": "9.3. アルゴリズム名"
    },
    {
      "indent": 3,
      "text": "A new HOBA signature algorithms registry has been created as follows, with Specification Required as the registration procedure. New HOBA signature algorithms SHOULD be in use with other IETF Standards Track protocols before being added to this registry.",
      "ja": "新しいHOBA署名アルゴリズムレジストリが次のように作成されました。登録手順は「仕様が必要です」です。新しいHOBA署名アルゴリズムは、このレジストリに追加する前に、他のIETF標準トラックプロトコルで使用する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "   Number       Meaning                         Reference\n   -----------  ------------------------------  ------------\n   0            RSA-SHA256                      RFC 7486\n   1            RSA-SHA1                        RFC 7486\n   RSA is defined in Section 8.2 of [RFC3447], and SHA-1 and SHA-256 are\n   defined in [SHS].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer. Following the ABNF in Figure 1, the maximum value for this is decimal 99.",
      "ja": "このレジストリの場合、数値列には小さな正の整数を含める必要があります。図1のABNFに従って、これの最大値は10進数の99です。"
    },
    {
      "indent": 0,
      "text": "9.4. Key Identifier Types",
      "section_title": true,
      "ja": "9.4. キー識別子のタイプ"
    },
    {
      "indent": 3,
      "text": "A new HOBA Key Identifier Types registry has been created as follows, with Specification Required as the registration procedure.",
      "ja": "新しいHOBA鍵識別子タイプレジストリが次のように作成され、登録手順として指定が必要です。"
    },
    {
      "indent": 3,
      "text": "Number       Meaning                         Reference\n-----------  ------------------------------  ------------\n0            a hashed public key             [RFC6698]\n1            a URI                           [RFC3986]\n2            an unformatted string, at the   RFC 7486\n             user's/UA's whim",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For the number 0, hashed public keys are as done in DNS-Based Authentication of Named Entities (DANE) [RFC6698].",
      "ja": "数値0の場合、ハッシュされた公開鍵は、名前付きエンティティのDNSベースの認証（DANE）[RFC6698]と同じです。"
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer.",
      "ja": "このレジストリの場合、数値列には小さな正の整数を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Device Identifier Types",
      "section_title": true,
      "ja": "9.5. デバイス識別子のタイプ"
    },
    {
      "indent": 3,
      "text": "A new HOBA Device Identifier Types registry has been created as follows, with Specification Required as the registration procedure.",
      "ja": "新しいHOBAデバイス識別子タイプレジストリが次のように作成され、登録手順として指定が必要です。"
    },
    {
      "indent": 3,
      "text": "The designated expert for this registry is to carefully pay attention to the notes on this field in Section 8.1, in particular, the \"MUST NOT\" stated therein.",
      "ja": "このレジストリに指定されたエキスパートは、セクション8.1のこのフィールドに関する注記、特にそこに記載されている「MUST NOT」に注意を払うことです。"
    },
    {
      "indent": 3,
      "text": "Number       Meaning                         Reference\n-----------  ------------------------------  -----------\n0            an unformatted string, at the   RFC 7486\n             user's/UA's whim",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer.",
      "ja": "このレジストリの場合、数値列には小さな正の整数を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "9.6. Hobareg HTTP Header Field",
      "section_title": true,
      "ja": "9.6. Hobareg HTTPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A new identifier has been registered in the Permanent Message Header Field Names registry as described below.",
      "ja": "以下で説明するように、新しい識別子が恒久メッセージヘッダーフィールド名レジストリに登録されました。"
    },
    {
      "indent": 3,
      "text": "Header Field Name: Hobareg",
      "ja": "ヘッダーフィールド名：Hobareg"
    },
    {
      "indent": 3,
      "text": "Protocol: http (RFC 7230)",
      "ja": "プロトコル：http（RFC 7230）"
    },
    {
      "indent": 3,
      "text": "Status: experimental",
      "ja": "ステータス：実験的"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "作成者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 6.1.1 of RFC 7486",
      "ja": "参照：RFC 7486のセクション6.1.1"
    },
    {
      "indent": 3,
      "text": "Related information: N/A",
      "ja": "関連情報：なし"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC20] Cerf, V., \"ASCII format for network interchange\", STD 80, RFC 20, October 1969, <http://www.rfc-editor.org/info/rfc20>.",
      "ja": "[RFC20] Cerf、V。、「ネットワーク交換用のASCII形式」、STD 80、RFC 20、1969年10月、<http://www.rfc-editor.org/info/rfc20>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003, <http://www.rfc-editor.org/info/rfc3447>.",
      "ja": "[RFC3447] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月、<http://www.rfc-editor.org/ info / rfc3447>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、2005年1月、<http：//www.rfc- editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月、<http://www.rfc-editor.org/info/rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, April 2010, <http://www.rfc-editor.org/info/rfc5785>.",
      "ja": "[RFC5785]ノッティンガム、M。およびE.ハマーラハブ、「Defining Well-Known Uniform Resource Identifiers（URIs）」、RFC 5785、2010年4月、<http://www.rfc-editor.org/info/rfc5785> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454] Barth、A。、「The Web Origin Concept」、RFC 6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, August 2012, <http://www.rfc-editor.org/info/rfc6698>.",
      "ja": "[RFC6698] Hoffman、P。およびJ. Schlyter、「DNSベースの名前付きエンティティ（DANE）トランスポート層セキュリティ（TLS）プロトコルの認証：TLSA」、RFC 6698、2012年8月、<http：//www.rfc- editor.org/info/rfc6698>。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, October 2012, <http://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M。およびD.ハート、「OAuth 2.0 Authorization Framework：Bearer Token Usage」、RFC 6750、2012年10月、<http://www.rfc-editor.org/info/rfc6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Authentication」、RFC 7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[SHS] NIST, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, March 2012.",
      "ja": "[SHS] NIST、「Secure Hash Standard（SHS）」、FIPS PUB 180-4、2012年3月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Bonneau] Bonneau, J., \"The Science of Guessing: Analyzing an Anonymized Corpus of 70 Million Passwords\", IEEE Symposium on Security and Privacy 538-552, 2012.",
      "ja": "[Bonneau] Bonneau、J。、「The Science of Guessing：Analyzing an Anonymized Corpus of 70 Million Passwords」、IEEE Symposium on Security and Privacy 538-552、2012。"
    },
    {
      "indent": 3,
      "text": "[MI93] Mitchell, C. and A. Thomas, \"Standardising authentication protocols based on public key techniques\", Journal of Computer Security Volume 2, 23-36, 1993.",
      "ja": "[MI93] Mitchell、C。およびA. Thomas、「公開鍵技術に基づく認証プロトコルの標準化」、Journal of Computer Security Volume 2、23-36、1993。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 \"Randomness Requirements for Security\"、BCP 106、RFC 4086、June 2005、<http://www.rfc-editor.org/info/ rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265] Barth、A。、「HTTP State Management Mechanism」、RFC 6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6376] Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed., \"DomainKeys Identified Mail (DKIM) Signatures\", STD 76, RFC 6376, September 2011, <http://www.rfc-editor.org/info/rfc6376>.",
      "ja": "[RFC6376] Crocker、D.、Ed。、Hansen、T.、Ed。、and M. Kucherawy、Ed。、 \"DomainKeys Identified Mail（DKIM）Signatures\"、STD 76、RFC 6376、September 2011、<http：/ /www.rfc-editor.org/info/rfc6376>。"
    },
    {
      "indent": 3,
      "text": "[ThreatReport] Sophos, \"Security Threat Report 2013\", January 2013, <http://www.sophos.com/en-us/medialibrary/pdfs/other/ sophossecuritythreatreport2013.pdf>.",
      "ja": "[ThreatReport]ソフォス、「セキュリティ脅威レポート2013」、2013年1月、<http://www.sophos.com/en-us/medialibrary/pdfs/other/ sophossecuritythreatreport2013.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Problems with Passwords",
      "section_title": true,
      "ja": "付録A.パスワードの問題"
    },
    {
      "indent": 3,
      "text": "By far, the most common mechanism for web authentication is passwords that can be remembered by the user, called \"human-memorable passwords\". There is plenty of good research on how users typically use human-memorable passwords (e.g., see [Bonneau]), but some of the highlights are that users typically try hard to reuse passwords on as many web sites as possible, and that web sites often use either email addresses or users' names as the identifiers that go with these passwords.",
      "ja": "はるかに、Web認証の最も一般的なメカニズムは、「人間が記憶できるパスワード」と呼ばれる、ユーザーが記憶できるパスワードです。ユーザーが通常人間が記憶できるパスワードをどのように使用するかについては多くの良い調査があります（たとえば、[Bonneau]を参照）。ハイライトのいくつかは、ユーザーが通常、できるだけ多くのWebサイトでパスワードを再利用しようと努力していること、およびそのWebサイトです。多くの場合、これらのパスワードに使用する識別子として、電子メールアドレスまたはユーザー名を使用します。"
    },
    {
      "indent": 3,
      "text": "If an attacker gets access to the database of memorizable passwords, that attacker can impersonate any of the users. Even if the breach is discovered, the attacker can still impersonate users until every password is changed. Even if all the passwords are changed or at least made unusable, the attacker now possesses a list of likely username/password pairs that might exist on other sites.",
      "ja": "攻撃者が覚えやすいパスワードのデータベースにアクセスした場合、その攻撃者は任意のユーザーになりすますことができます。違反が発見されても、攻撃者はすべてのパスワードが変更されるまでユーザーになりすますことができます。すべてのパスワードが変更された場合、または少なくとも使用不可になった場合でも、攻撃者は他のサイトに存在する可能性のあるユーザー名とパスワードのペアのリストを所有しています。"
    },
    {
      "indent": 3,
      "text": "Using memorizable passwords on unencrypted channels also poses risks to the users. If a web site uses either the HTTP Basic authentication method, or an HTML form that does no cryptographic protection of the password in transit, a passive attacker can see the password and immediately impersonate the user. If a hash-based authentication scheme such as HTTP Digest authentication is used, a passive attacker still has a high chance of being able to determine the password using a dictionary of known passwords.",
      "ja": "暗号化されていないチャネルで覚えやすいパスワードを使用することも、ユーザーにリスクをもたらします。 WebサイトがHTTP基本認証方式、または転送中のパスワードを暗号で保護しないHTMLフォームのいずれかを使用している場合、受動的な攻撃者がパスワードを確認し、すぐにユーザーになりすますことができます。 HTTPダイジェスト認証などのハッシュベースの認証スキームが使用されている場合でも、パッシブ攻撃者は既知のパスワードの辞書を使用してパスワードを特定できる可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "Note that passwords that are not human-memorable are still subject to database attack, though they are of course unlikely to be reused across many systems. Similarly, database attacks of some form or other will work against any password-based authentication scheme, regardless of the cryptographic protocol used. So for example, zero-knowledge or Password-Authenticated Key Exchange (PAKE) schemes, though making use of elegant cryptographic protocols, remain as vulnerable to what is clearly the most common exploit seen when it comes to passwords. HOBA is, however, not vulnerable to database theft.",
      "ja": "人間が記憶できないパスワードは、依然としてデータベース攻撃の対象となることに注意してください。ただし、パスワードが多くのシステムで再利用される可能性はありません。同様に、何らかの形式のデータベース攻撃は、使用されている暗号化プロトコルに関係なく、パスワードベースの認証スキームに対して機能します。したがって、たとえば、ゼロナレッジまたはパスワード認証キー交換（PAKE）スキームは、エレガントな暗号化プロトコルを利用していますが、パスワードに関して見られる最も一般的なエクスプロイトに対して明らかに脆弱です。ただし、HOBAはデータベースの盗難に対して脆弱ではありません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example",
      "section_title": true,
      "ja": "付録B.例"
    },
    {
      "indent": 3,
      "text": "The following values show an example of HOBA-http authentication to the origin \"https://example.com:443\". Carriage returns have been added and need to be removed to validate the example.",
      "ja": "次の値は、オリジン \"https://example.com:443\"に対するHOBA-http認証の例を示しています。キャリッジリターンが追加されたため、例を検証するには削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Public Key:",
      "ja": "公開鍵："
    },
    {
      "indent": 3,
      "text": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAviE8fMrGIPZN9up94M28\n6o38B99fsz5cUqYHXXJlnHIi6gGKjqLgn3P7n4snUSQswLExrkhSr0TPhRDuPH_t\nfXLKLBbh17ofB7t7shnPKxmyZ69hCLbe7pB1HvaBzTxPC2KOqskDiDBOQ6-JLHQ8\negXB14W-641RQt0CsC5nXzo92kPCdV4NZ45MW0ws3twCIUDCH0nibIG9SorrBbCl\nDPHQZS5Dk5pgS7P5hrAr634Zn4bzXhUnm7cON2x4rv83oqB3lRqjF4T9exEMyZBS\nL26m5KbK860uSOKywI0xp4ymnHMc6Led5qfEMnJC9PEI90tIMcgdHrmdHC_vpldG\nDQIDAQAB\n-----END PUBLIC KEY-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Origin: https://example.com:443",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key Identifier: vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w",
      "ja": "キー識別子：vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w"
    },
    {
      "indent": 3,
      "text": "Challenge: pUE77w0LylHypHKhBqAiQHuGC751GiOVv4/7pSlo9jc=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Signature algorithm: RSA-SHA256 (\"0\")",
      "ja": "署名アルゴリズム：RSA-SHA256（ \"0\"）"
    },
    {
      "indent": 3,
      "text": "Nonce: Pm3yUW-sW5Q",
      "ja": "ナンス：Pm3yUW-sW5Q"
    },
    {
      "indent": 3,
      "text": "Signature:",
      "ja": "署名："
    },
    {
      "indent": 3,
      "text": "VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0i 4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miUz q04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrKP tG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr9 6ZJ2i9LE6uKSUDLCD2oeEeSEvUR--4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9kI S13qQA43m4IMExkbApqrSg",
      "ja": "CEO 0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0i 4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miUz q04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrKP tG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr9 6ZJ2i9LE6uKSUDLCD2oeEeSEvUR  -  4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9kI S13qQA43m4IMExkbApqrSg"
    },
    {
      "indent": 3,
      "text": "Authorization Header:",
      "ja": "承認ヘッダー："
    },
    {
      "indent": 3,
      "text": "Authorization: HOBA result=\"vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w.pUE77w0LylHypHKhBqAiQHuGC751GiOVv4/7pSlo9jc=.Pm3yUW-sW5Q .VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0 i4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miU zq04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrK PtG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr 96ZJ2i9LE6uKSUDLCD2oeEeSEvUR--4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9k IS13qQA43m4IMExkbApqrSg\"",
      "ja": "認可：HOBA結果= \"vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w.pUE77w0LylHypHKhBqAiQHuGC751GiOVv4 / 7pSlo9jc = .Pm3yUW-sW5Q .VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0 i4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miU zq04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrK PtG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr 96ZJ2i9LE6uKSUDLCD2oeEeSEvUR  -  4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9k IS13qQA43m4IMExkbApqrSg\""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to the following for good comments received during the preparation of this specification: Richard Barnes, David Black, Alissa Cooper, Donald Eastlake, Amos Jeffries, Benjamin Kaduk, Watson Ladd, Barry Leiba, Matt Lepinski, Ilari Liusvaara, James Manger, Alexey Melnikov, Kathleen Moriarty, Yoav Nir, Mark Nottingham, Julian Reschke, Pete Resnick, Michael Richardson, Yaron Sheffer, and Michael Sweet. All errors and stupidities are of course the editors' fault.",
      "ja": "この仕様の準備中に受け取った良いコメントに対する感謝：リチャードバーンズ、デビッドブラック、アリッサクーパー、ドナルドイーストレイク、アモスジェフリーズ、ベンジャミンカドゥック、ワトソンラッド、バリーレイバ、マットレピンスキー、イラリリウスヴァーラ、ジェームズマンガー、アレクセイメルニコフ、キャスリーン・モリアーティ、ヨーブ・ニール、マーク・ノッティンガム、ジュリアン・レシュケ、ピート・レズニック、マイケル・リチャードソン、ヤロン・シェファー、マイケル・スウィート。もちろん、すべてのエラーと愚かさは編集者の責任です。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stephen Farrell Trinity College Dublin Dublin 2 Ireland",
      "ja": "スティーブンファレルトリニティカレッジダブリンダブリン2アイルランド"
    },
    {
      "indent": 3,
      "text": "Phone: +353-1-896-2354\nEMail: stephen.farrell@cs.tcd.ie",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium",
      "ja": "ポールホフマンVPNコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Thomas Phresheez",
      "ja": "ミントトーマスフレッシュ"
    },
    {
      "indent": 3,
      "text": "EMail: mike@phresheez.com",
      "raw": true,
      "ja": ""
    }
  ]
}