{
  "title": {
    "text": "RFC 7951 - JSON Encoding of Data Modeled with YANG",
    "ja": "RFC 7951 - YANGでモデル化されたデータのJSONエンコーディング"
  },
  "number": 7951,
  "created_at": "2020-08-29 10:29:44.967574+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         L. Lhotka\nRequest for Comments: 7951                                        CZ.NIC\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "JSON Encoding of Data Modeled with YANG",
      "ja": "YANGでモデル化されたデータのJSONエンコーディング"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines encoding rules for representing configuration data, state data, parameters of Remote Procedure Call (RPC) operations or actions, and notifications defined using YANG as JavaScript Object Notation (JSON) text.",
      "ja": "このドキュメントでは、構成データ、状態データ、リモートプロシージャコール（RPC）操作またはアクションのパラメーター、およびJavaScriptオブジェクト表記（JSON）テキストとしてYANGを使用して定義された通知を表すためのエンコードルールを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7951.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7951で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology and Notation  . . . . . . . . . . . . . . . . . .   3\n3.  Properties of the JSON Encoding . . . . . . . . . . . . . . .   4\n4.  Names and Namespaces  . . . . . . . . . . . . . . . . . . . .   5\n5.  Encoding of YANG Data Node Instances  . . . . . . . . . . . .   7\n  5.1.  The \"leaf\" Data Node  . . . . . . . . . . . . . . . . . .   7\n  5.2.  The \"container\" Data Node . . . . . . . . . . . . . . . .   8\n  5.3.  The \"leaf-list\" Data Node . . . . . . . . . . . . . . . .   8\n  5.4.  The \"list\" Data Node  . . . . . . . . . . . . . . . . . .   9\n  5.5.  The \"anydata\" Data Node . . . . . . . . . . . . . . . . .   9\n  5.6.  The \"anyxml\" Data Node  . . . . . . . . . . . . . . . . .  10\n  5.7.  Metadata Objects  . . . . . . . . . . . . . . . . . . . .  11\n6.  Representing YANG Data Types in JSON Values . . . . . . . . .  11\n  6.1.  Numeric Types . . . . . . . . . . . . . . . . . . . . . .  11\n  6.2.  The \"string\" Type . . . . . . . . . . . . . . . . . . . .  11\n  6.3.  The \"boolean\" Type  . . . . . . . . . . . . . . . . . . .  11\n  6.4.  The \"enumeration\" Type  . . . . . . . . . . . . . . . . .  12\n  6.5.  The \"bits\" Type . . . . . . . . . . . . . . . . . . . . .  12\n  6.6.  The \"binary\" Type . . . . . . . . . . . . . . . . . . . .  12\n  6.7.  The \"leafref\" Type  . . . . . . . . . . . . . . . . . . .  12\n  6.8.  The \"identityref\" Type  . . . . . . . . . . . . . . . . .  12\n  6.9.  The \"empty\" Type  . . . . . . . . . . . . . . . . . . . .  13\n  6.10. The \"union\" Type  . . . . . . . . . . . . . . . . . . . .  14\n  6.11. The \"instance-identifier\" Type  . . . . . . . . . . . . .  15\n7.  I-JSON Compliance . . . . . . . . . . . . . . . . . . . . . .  15\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  16\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  17\nAppendix A.  A Complete Example . . . . . . . . . . . . . . . . .  18\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  20",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Protocol (NETCONF) [RFC6241] uses XML [XML] for encoding data in its Content Layer. Other management protocols might want to use other encodings while still benefiting from using YANG [RFC7950] as the data modeling language.",
      "ja": "ネットワーク構成プロトコル（NETCONF）[RFC6241]は、XML [XML]を使用してコンテンツレイヤーのデータをエンコードします。他の管理プロトコルは、データモデリング言語としてYANG [RFC7950]を使用することのメリットを享受しながら、他のエンコーディングを使用したい場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, the RESTCONF protocol [RESTCONF] supports two encodings: XML (media type \"application/yang.data+xml\") and JavaScript Object Notation (JSON) (media type \"application/yang.data+json\").",
      "ja": "たとえば、RESTCONFプロトコル[RESTCONF]は、XML（メディアタイプ \"application / yang.data + xml\"）とJavaScript Object Notation（JSON）（メディアタイプ \"application / yang.data + json\"）の2つのエンコーディングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "The specification of the YANG 1.1 data modeling language [RFC7950] defines only XML encoding of data trees, i.e., configuration data, state data, input/output parameters of Remote Procedure Call (RPC) operations or actions, and notifications. The aim of this document is to define rules for encoding the same data as JSON text [RFC7159].",
      "ja": "YANG 1.1データモデリング言語[RFC7950]の仕様は、データツリーのXMLエンコーディングのみを定義します。つまり、構成データ、状態データ、リモートプロシージャコール（RPC）の操作またはアクションの入出力パラメーター、および通知のみです。このドキュメントの目的は、JSONテキストと同じデータをエンコードするためのルールを定義することです[RFC7159]。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Notation",
      "section_title": true,
      "ja": "2. 用語と表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC7950]:",
      "ja": "以下の用語は[RFC7950]で定義されています："
    },
    {
      "indent": 3,
      "text": "o action",
      "ja": "o アクション"
    },
    {
      "indent": 3,
      "text": "o anydata",
      "ja": "o anydata"
    },
    {
      "indent": 3,
      "text": "o anyxml",
      "ja": "o anyxml"
    },
    {
      "indent": 3,
      "text": "o augment",
      "ja": "o 増強"
    },
    {
      "indent": 3,
      "text": "o container",
      "ja": "o コンテナ"
    },
    {
      "indent": 3,
      "text": "o data node",
      "ja": "o だた ので"
    },
    {
      "indent": 3,
      "text": "o data tree",
      "ja": "o データツリー"
    },
    {
      "indent": 3,
      "text": "o identity",
      "ja": "o 身元"
    },
    {
      "indent": 3,
      "text": "o instance identifier",
      "ja": "o インスタンスを識別"
    },
    {
      "indent": 3,
      "text": "o leaf",
      "ja": "o 葉"
    },
    {
      "indent": 3,
      "text": "o leaf-list",
      "ja": "o リーフリスト"
    },
    {
      "indent": 0,
      "text": " o list o module",
      "ja": "またはリストまたはモジュール"
    },
    {
      "indent": 3,
      "text": "o RPC operation",
      "ja": "o RPC操作"
    },
    {
      "indent": 3,
      "text": "o submodule",
      "ja": "o サブモジュール"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "ja": "以下の用語は[RFC6241]で定義されています："
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "ja": "o 設定データ"
    },
    {
      "indent": 3,
      "text": "o notification",
      "ja": "o 通知"
    },
    {
      "indent": 3,
      "text": "o state data",
      "ja": "o 状態データ"
    },
    {
      "indent": 0,
      "text": "3. Properties of the JSON Encoding",
      "section_title": true,
      "ja": "3. JSONエンコーディングのプロパティ"
    },
    {
      "indent": 3,
      "text": "This document defines JSON encoding for YANG data trees and their subtrees. It is always assumed that the top-level structure in JSON-encoded data is an object.",
      "ja": "このドキュメントでは、YANGデータツリーとそのサブツリーのJSONエンコーディングを定義します。 JSONエンコードされたデータの最上位構造は常にオブジェクトであると想定されます。"
    },
    {
      "indent": 3,
      "text": "Instances of YANG data nodes (leafs, containers, leaf-lists, lists, anydata nodes, and anyxml nodes) are encoded as members of a JSON object, i.e., name/value pairs. Section 4 defines how the name part is formed, and the following sections deal with the value part. The encoding rules are identical for all types of data trees, i.e., configuration data, state data, parameters of RPC operations, actions, and notifications.",
      "ja": "YANGデータノードのインスタンス（リーフ、コンテナ、リーフリスト、リスト、anydataノード、anyxmlノード）は、JSONオブジェクトのメンバー、つまり名前と値のペアとしてエンコードされます。セクション4では、名前部分の形成方法を定義します。以降のセクションでは、値部分を扱います。エンコーディングルールは、すべてのタイプのデータツリー、つまり、構成データ、状態データ、RPC操作のパラメーター、アクション、通知で同じです。"
    },
    {
      "indent": 3,
      "text": "With the exception of \"anydata\" encoding (Section 5.5), all rules in this document are also applicable to YANG 1.0 [RFC6020].",
      "ja": "「anydata」エンコーディング（セクション5.5）を除いて、このドキュメントのすべてのルールはYANG 1.0 [RFC6020]にも適用されます。"
    },
    {
      "indent": 3,
      "text": "Unlike XML element content, JSON values carry partial type information (number, string, boolean). The JSON encoding is defined so that this information is never in conflict with the data type of the corresponding YANG leaf or leaf-list.",
      "ja": "XML要素のコンテンツとは異なり、JSON値には部分的な型情報（数値、文字列、ブール値）が含まれます。 JSONエンコードは、この情報が対応するYANGリーフまたはリーフリストのデータ型と競合しないように定義されています。"
    },
    {
      "indent": 3,
      "text": "With the exception of anyxml and schema-less anydata nodes, it is possible to map a JSON-encoded data tree to XML encoding as defined in [RFC7950], and vice versa. However, such conversions require the YANG data model to be available.",
      "ja": "anyxmlおよびスキーマレスのanydataノードを除いて、[RFC7950]で定義されているように、JSONエンコードされたデータツリーをXMLエンコーディングにマッピングできます。ただし、このような変換では、YANGデータモデルを使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to achieve maximum interoperability while allowing implementations to use a variety of existing JSON parsers, the JSON encoding rules follow, as much as possible, the constraints of the I-JSON (Internet JSON) restricted profile [RFC7493]. Section 7 discusses I-JSON conformance in more detail.",
      "ja": "実装でさまざまな既存のJSONパーサーを使用できるようにしながら最大の相互運用性を実現するために、JSONエンコーディングルールは、I-JSON（インターネットJSON）制限プロファイル[RFC7493]の制約に可能な限り従います。セクション7では、I-JSONへの準拠について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4. Names and Namespaces",
      "section_title": true,
      "ja": "4. 名前と名前空間"
    },
    {
      "indent": 3,
      "text": "A JSON object member name MUST be in one of the following forms:",
      "ja": "JSONオブジェクトのメンバー名は、次のいずれかの形式にする必要があります。"
    },
    {
      "indent": 3,
      "text": "o simple - identical to the identifier of the corresponding YANG data node.",
      "ja": "o simple-対応するYANGデータノードの識別子と同じです。"
    },
    {
      "indent": 3,
      "text": "o namespace-qualified - the data node identifier is prefixed with the name of the module in which the data node is defined, separated from the data node identifier by the colon character (\":\").",
      "ja": "o 名前空間修飾-データノード識別子には、データノードが定義されているモジュールの名前がプレフィックスとして付けられ、データノード識別子とコロン文字（ \"：\"）で区切られます。"
    },
    {
      "indent": 3,
      "text": "The name of a module determines the namespace of all data node names defined in that module. If a data node is defined in a submodule, then the namespace-qualified member name uses the name of the main module to which the submodule belongs.",
      "ja": "モジュールの名前は、そのモジュールで定義されているすべてのデータノード名の名前空間を決定します。データノードがサブモジュールで定義されている場合、名前空間で修飾されたメンバー名は、サブモジュールが属するメインモジュールの名前を使用します。"
    },
    {
      "indent": 3,
      "text": "ABNF syntax [RFC5234] of a member name is shown in Figure 1, where the production for \"identifier\" is defined in Section 14 of [RFC7950].",
      "ja": "メンバー名のABNF構文[RFC5234]を図1に示します。「識別子」の生成は[RFC7950]のセクション14で定義されています。"
    },
    {
      "indent": 11,
      "text": "member-name = [identifier \":\"] identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 1: ABNF Production for a JSON Member Name",
      "ja": "図1：JSONメンバー名のABNFプロダクション"
    },
    {
      "indent": 3,
      "text": "A namespace-qualified member name MUST be used for all members of a top-level JSON object and then also whenever the namespaces of the data node and its parent node are different. In all other cases, the simple form of the member name MUST be used.",
      "ja": "ネームスペースで修飾されたメンバー名は、最上位のJSONオブジェクトのすべてのメンバーに使用する必要があります。また、データノードとその親ノードのネームスペースが異なる場合も必ず使用する必要があります。それ以外の場合はすべて、メンバー名の単純な形式を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG module:",
      "ja": "たとえば、次のYANGモジュールを考えてみます。"
    },
    {
      "indent": 3,
      "text": "module example-foomod {",
      "ja": "モジュールexample-foomod {"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/foomod\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "prefix \"foomod\";",
      "ja": "接頭辞 \"foomod\";"
    },
    {
      "indent": 0,
      "text": "     container top {\n       leaf foo {\n         type uint8;\n       }\n     }\n   }\n   If the data model consists only of this module, then the following is\n   valid JSON-encoded configuration data:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the member of the top-level object uses the namespace-qualified name but the \"foo\" leaf doesn't because it is defined in the same module as its parent container \"top\".",
      "ja": "最上位オブジェクトのメンバーは名前空間修飾名を使用しますが、「foo」リーフは、その親コン​​テナー「top」と同じモジュールで定義されているため、使用しません。"
    },
    {
      "indent": 3,
      "text": "Now, assume that the container \"top\" is augmented from another module, \"example-barmod\":",
      "ja": "ここで、コンテナ「top」が別のモジュール「example-barmod」から拡張されていると想定します。"
    },
    {
      "indent": 3,
      "text": "module example-barmod {",
      "ja": "module example-barmod {"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/barmod\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "prefix \"barmod\";",
      "ja": "接頭辞 \"barmod\";"
    },
    {
      "indent": 5,
      "text": "import example-foomod {\n  prefix \"foomod\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  augment \"/foomod:top\" {\n    leaf bar {\n      type boolean;\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Valid JSON-encoded configuration data containing both leafs may then look like this:",
      "ja": "両方のリーフを含む有効なJSONエンコードされた構成データは、次のようになります。"
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54,\n    \"example-barmod:bar\": true\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The name of the \"bar\" leaf is prefixed with the namespace identifier because its parent is defined in a different module.",
      "ja": "「bar」リーフの名前には、その親が別のモジュールで定義されているため、名前空間識別子が前に付けられます。"
    },
    {
      "indent": 3,
      "text": "Explicit namespace identifiers are sometimes needed when encoding values of the \"identityref\" and \"instance-identifier\" types. The same form of namespace-qualified name as defined above is then used. See Sections 6.8 and 6.11 for details.",
      "ja": "「identityref」および「instance-identifier」タイプの値をエンコードするときに、明示的な名前空間識別子が必要になる場合があります。次に、上記で定義したのと同じ形式の名前空間修飾名が使用されます。詳細については、セクション6.8および6.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Encoding of YANG Data Node Instances",
      "section_title": true,
      "ja": "5. YANGデータノードインスタンスのエンコーディング"
    },
    {
      "indent": 3,
      "text": "Every data node instance is encoded as a name/value pair where the name is formed from the data node identifier using the rules of Section 4. The value depends on the category of the data node, as explained in the following subsections.",
      "ja": "すべてのデータノードインスタンスは、名前と値のペアとしてエンコードされます。ここで、名前は、セクション4のルールを使用してデータノード識別子から形成されます。値は、以下のサブセクションで説明するように、データノードのカテゴリによって異なります。"
    },
    {
      "indent": 3,
      "text": "Character encoding MUST be UTF-8.",
      "ja": "文字エンコードはUTF-8でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. The \"leaf\" Data Node",
      "section_title": true,
      "ja": "5.1. 「リーフ」データノード"
    },
    {
      "indent": 3,
      "text": "A leaf instance is encoded as a name/value pair where the value can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf (see Section 6 for the type encoding rules).",
      "ja": "リーフインスタンスは名前/値のペアとしてエンコードされます。値は、リーフのタイプに応じて、文字列、数値、リテラル「true」または「false」、または特別な配列「[null]」になります（セクションを参照）。タイプエンコーディングルールの場合は6）。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf node definition",
      "ja": "例：リーフノード定義の場合"
    },
    {
      "indent": 3,
      "text": "leaf foo {\n  type uint8;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"foo\": 123",
      "ja": "「foo」：123"
    },
    {
      "indent": 0,
      "text": "5.2. The \"container\" Data Node",
      "section_title": true,
      "ja": "5.2. 「コンテナ」データノード"
    },
    {
      "indent": 3,
      "text": "A container instance is encoded as a name/object pair. The container's child data nodes are encoded as members of the object.",
      "ja": "コンテナインスタンスは、名前/オブジェクトのペアとしてエンコードされます。コンテナの子データノードは、オブジェクトのメンバーとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Example: For the container definition",
      "ja": "例：コンテナー定義の場合"
    },
    {
      "indent": 3,
      "text": "container bar {\n  leaf foo {\n    type uint8;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": {\n  \"foo\": 123\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. The \"leaf-list\" Data Node",
      "section_title": true,
      "ja": "5.3. 「リーフリスト」データノード"
    },
    {
      "indent": 3,
      "text": "A leaf-list is encoded as a name/array pair, and the array elements are values of some scalar type, which can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf-list (see Section 6 for the type encoding rules).",
      "ja": "リーフリストは名前/配列のペアとしてエンコードされ、配列要素は文字列、数値、リテラル「true」または「false」、または特別な配列「[null]」のいずれかのスカラー型の値です、リーフリストのタイプに応じて（タイプエンコーディングルールについてはセクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing leaf-list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "ja": "配列要素の順序は、XMLエンコーディングのリーフリストエントリを表すXML要素の順序と同じ規則に従います。具体的には、「ordered-by」プロパティ（[RFC7950]のセクション7.7.7）を遵守する必要があります。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf-list definition",
      "ja": "例：リーフリスト定義の場合"
    },
    {
      "indent": 3,
      "text": "leaf-list foo {\n  type uint8;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"foo\": [123, 0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.4. The \"list\" Data Node",
      "section_title": true,
      "ja": "5.4. 「リスト」データノード"
    },
    {
      "indent": 3,
      "text": "A list instance is encoded as a name/array pair, and the array elements are JSON objects.",
      "ja": "リストインスタンスは名前/配列のペアとしてエンコードされ、配列要素はJSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "ja": "配列要素の順序は、XMLエンコーディングのリストエントリを表すXML要素の順序と同じ規則に従います。具体的には、「ordered-by」プロパティ（[RFC7950]のセクション7.7.7）を遵守する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unlike the XML encoding, where list keys are required to precede any other siblings within a list entry and appear in the order specified by the data model, the order of members in a JSON-encoded list entry is arbitrary because JSON objects are fundamentally unordered collections of members.",
      "ja": "XMLエンコーディングとは異なり、リストキーはリストエントリ内の他の兄弟の前にあり、データモデルで指定された順序で表示される必要があります。JSONオブジェクトは基本的に順序付けられていないコレクションであるため、JSONエンコードリストエントリのメンバーの順序は任意です。メンバーの。"
    },
    {
      "indent": 3,
      "text": "Example: For the list definition",
      "ja": "例：リスト定義の場合"
    },
    {
      "indent": 3,
      "text": "list bar {\n  key foo;\n  leaf foo {\n    type uint8;\n  }\n  leaf baz {\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": [\n  {\n    \"foo\": 123,\n    \"baz\": \"zig\"\n  },\n  {\n    \"baz\": \"zag\",\n    \"foo\": 0\n  }\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.5. The \"anydata\" Data Node",
      "section_title": true,
      "ja": "5.5. 「anydata」データノード"
    },
    {
      "indent": 3,
      "text": "The anydata data node serves as a container for an arbitrary set of nodes that otherwise appear as normal YANG-modeled data. A data model for anydata content may or may not be known at runtime. In the latter case, converting JSON-encoded instances to the XML encoding defined in [RFC7950] may be impossible.",
      "ja": "anydataデータノードは、通常のYANGモデルデータとして表示されるノードの任意のセットのコンテナーとして機能します。 anydataコンテンツのデータモデルは、実行時に認識される場合と認識されない場合があります。後者の場合、JSONエンコードされたインスタンスを[RFC7950]で定義されているXMLエンコーディングに変換することは不可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "An anydata instance is encoded in the same way as a container, i.e., as a name/object pair. The requirement that anydata content can be modeled by YANG implies the following rules for the JSON text inside the object:",
      "ja": "anydataインスタンスは、コンテナと同じ方法で、つまり名前とオブジェクトのペアとしてエンコードされます。すべてのデータコンテンツをYANGでモデル化できるという要件は、オブジェクト内のJSONテキストに関する次のルールを意味します。"
    },
    {
      "indent": 3,
      "text": "o It is valid I-JSON [RFC7493].",
      "ja": "o 有効なI-JSON [RFC7493]です。"
    },
    {
      "indent": 3,
      "text": "o All object member names satisfy the ABNF production in Figure 1.",
      "ja": "o すべてのオブジェクトメンバー名は、図1のABNFプロダクションを満たしています。"
    },
    {
      "indent": 3,
      "text": "o Any JSON array contains either only unique scalar values (as a leaf-list; see Section 5.3) or only objects (as a list; see Section 5.4).",
      "ja": "o JSON配列には、一意のスカラー値のみ（リーフリストとして、セクション5.3を参照）またはオブジェクトのみ（リストとして、セクション5.4を参照）のいずれかが含まれます。"
    },
    {
      "indent": 3,
      "text": "o The \"null\" value is only allowed in the single-element array \"[null]\" corresponding to the encoding of the \"empty\" type; see Section 6.9.",
      "ja": "o 「null」値は、「空」タイプのエンコーディングに対応する単一要素配列「[null]」でのみ許可されます。セクション6.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example: For the anydata definition",
      "ja": "例：anydata定義の場合"
    },
    {
      "indent": 3,
      "text": "anydata data;",
      "ja": "anydataデータ;"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"data\": {\n  \"ietf-notification:notification\": {\n    \"eventTime\": \"2014-07-29T13:43:01Z\",\n    \"example-event:event\": {\n      \"event-class\": \"fault\",\n      \"reporting-entity\": {\n        \"card\": \"Ethernet0\"\n      },\n      \"severity\": \"major\"\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.6. The \"anyxml\" Data Node",
      "section_title": true,
      "ja": "5.6. 「anyxml」データノード"
    },
    {
      "indent": 3,
      "text": "An anyxml instance is encoded as a JSON name/value pair. The value MUST satisfy I-JSON constraints.",
      "ja": "anyxmlインスタンスは、JSONの名前と値のペアとしてエンコードされます。値はI-JSON制約を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "Example: For the anyxml definition",
      "ja": "例：anyxml定義の場合"
    },
    {
      "indent": 3,
      "text": "anyxml bar;",
      "ja": "予期しない時間。"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、JSONでエンコードされた有効なインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": [true, null, true]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.7. Metadata Objects",
      "section_title": true,
      "ja": "5.7. メタデータオブジェクト"
    },
    {
      "indent": 3,
      "text": "Apart from instances of YANG data nodes, a JSON document MAY contain special object members whose name starts with the \"@\" character (COMMERCIAL AT). Such members are used for special purposes, such as encoding metadata [RFC7952]. The exact syntax and semantics of such members are outside the scope of this document.",
      "ja": "YANGデータノードのインスタンスとは別に、JSONドキュメントには、名前が「@」文字（COMMERCIAL AT）で始まる特別なオブジェクトメンバーが含まれる場合があります。そのようなメンバーは、メタデータのエンコード[RFC7952]などの特別な目的で使用されます。そのようなメンバーの正確な構文とセマンティクスは、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. Representing YANG Data Types in JSON Values",
      "section_title": true,
      "ja": "6. JSON値でのYANGデータ型の表現"
    },
    {
      "indent": 3,
      "text": "The type of the JSON value in an instance of the leaf or leaf-list data node depends on the type of that data node, as specified in the following subsections.",
      "ja": "リーフまたはリーフリストデータノードのインスタンスのJSON値のタイプは、以下のサブセクションで指定されているように、そのデータノードのタイプによって異なります。"
    },
    {
      "indent": 0,
      "text": "6.1. Numeric Types",
      "section_title": true,
      "ja": "6.1. 数値型"
    },
    {
      "indent": 3,
      "text": "A value of the \"int8\", \"int16\", \"int32\", \"uint8\", \"uint16\", or \"uint32\" type is represented as a JSON number.",
      "ja": "「int8」、「int16」、「int32」、「uint8」、「uint16」、または「uint32」タイプの値は、JSON番号として表されます。"
    },
    {
      "indent": 3,
      "text": "A value of the \"int64\", \"uint64\", or \"decimal64\" type is represented as a JSON string whose content is the lexical representation of the corresponding YANG type as specified in Sections 9.2.1 and 9.3.1 of [RFC7950].",
      "ja": "「int64」、「uint64」、または「decimal64」タイプの値は、[RFC7950]のセクション9.2.1および9.3.1で指定されている対応するYANGタイプの字句表現であるJSON文字列として表されます。"
    },
    {
      "indent": 3,
      "text": "For example, if the type of the leaf \"foo\" in Section 5.1 was \"uint64\" instead of \"uint8\", the instance would have to be encoded as",
      "ja": "たとえば、セクション5.1のリーフ「foo」のタイプが「uint8」ではなく「uint64」だった場合、インスタンスは次のようにエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "\"foo\": \"123\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The special handling of 64-bit numbers follows from the I-JSON recommendation to encode numbers exceeding the IEEE 754-2008 double-precision range [IEEE754-2008] as strings; see Section 2.2 in [RFC7493].",
      "ja": "64ビットの数値の特別な処理は、I-JSONの推奨に従い、IEEE 754-2008の倍精度範囲[IEEE754-2008]を超える数値を文字列としてエンコードします。 [RFC7493]のセクション2.2をご覧ください。"
    },
    {
      "indent": 0,
      "text": "6.2. The \"string\" Type",
      "section_title": true,
      "ja": "6.2. 「ストリング」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"string\" value is represented as a JSON string, subject to JSON string encoding rules.",
      "ja": "「文字列」値は、JSON文字列エンコーディングルールに従って、JSON文字列として表されます。"
    },
    {
      "indent": 0,
      "text": "6.3. The \"boolean\" Type",
      "section_title": true,
      "ja": "6.3. 「ブール」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"boolean\" value is represented as the corresponding JSON literal name \"true\" or \"false\".",
      "ja": "「ブール」値は、対応するJSONリテラル名「true」または「false」として表されます。"
    },
    {
      "indent": 0,
      "text": "6.4. The \"enumeration\" Type",
      "section_title": true,
      "ja": "6.4. 「列挙型」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"enumeration\" value is represented as a JSON string -- one of the names assigned by \"enum\" statements in YANG.",
      "ja": "「列挙」値は、JSON文字列として表されます。これは、YANGの「列挙」ステートメントによって割り当てられた名前の1つです。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"enumeration\" type in XML; see Section 9.6 in [RFC7950].",
      "ja": "この表現は、XMLの「列挙」タイプの字句表現と同じです。 [RFC7950]のセクション9.6をご覧ください。"
    },
    {
      "indent": 0,
      "text": "6.5. The \"bits\" Type",
      "section_title": true,
      "ja": "6.5. 「ビット」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"bits\" value is represented as a JSON string -- a space-separated sequence of names of bits that are set. The permitted bit names are assigned by \"bit\" statements in YANG.",
      "ja": "「ビット」値は、JSON文字列として設定されます。これは、スペースで区切られた、設定されたビットの名前のシーケンスです。許可されるビット名は、YANGの「ビット」ステートメントによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"bits\" type; see Section 9.7 in [RFC7950].",
      "ja": "この表現は、「ビット」タイプの字句表現と同じです。 [RFC7950]のセクション9.7をご覧ください。"
    },
    {
      "indent": 0,
      "text": "6.6. The \"binary\" Type",
      "section_title": true,
      "ja": "6.6. 「バイナリ」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"binary\" value is represented as a JSON string -- base64 encoding of arbitrary binary data.",
      "ja": "「バイナリ」値は、JSON文字列-任意のバイナリデータのbase64エンコーディングとして表されます。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"binary\" type in XML; see Section 9.8 in [RFC7950].",
      "ja": "この表現は、XMLの「バイナリ」タイプの字句表現と同じです。 [RFC7950]のセクション9.8をご覧ください。"
    },
    {
      "indent": 0,
      "text": "6.7. The \"leafref\" Type",
      "section_title": true,
      "ja": "6.7. 「leafref」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"leafref\" value is represented using the same rules as the type of the leaf to which the leafref value refers.",
      "ja": "「leafref」値は、leafref値が参照する葉のタイプと同じ規則を使用して表されます。"
    },
    {
      "indent": 0,
      "text": "6.8. The \"identityref\" Type",
      "section_title": true,
      "ja": "6.8. 「identityref」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"identityref\" value is represented as a string -- the name of an identity. If the identity is defined in a module other than the leaf node containing the identityref value, the namespace-qualified form (Section 4) MUST be used. Otherwise, both the simple and namespace-qualified forms are permitted.",
      "ja": "「identityref」値は文字列、つまりIDの名前として表されます。 IDがidentityref値を含むリーフノード以外のモジュールで定義されている場合は、名前空間修飾形式（セクション4）を使用する必要があります。それ以外の場合は、単純な形式と名前空間修飾形式の両方が許可されます。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following schematic module:",
      "ja": "たとえば、次の回路図モジュールについて考えてみます。"
    },
    {
      "indent": 3,
      "text": "module example-mod {\n  ...\n  import ietf-interfaces {\n    prefix if;\n  }\n  ...\n  leaf type {\n    type identityref {\n      base \"if:interface-type\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A valid instance of the \"type\" leaf is then encoded as follows:",
      "ja": "「タイプ」リーフの有効なインスタンスは、次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "\"type\": \"iana-if-type:ethernetCsmacd\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The namespace identifier \"iana-if-type\" must be present in this case because the \"ethernetCsmacd\" identity is not defined in the same module as the \"type\" leaf.",
      "ja": "この場合、名前空間識別子「iana-if-type」が存在している必要があります。これは、「ethernetCsmacd」IDが「type」リーフと同じモジュールで定義されていないためです。"
    },
    {
      "indent": 0,
      "text": "6.9. The \"empty\" Type",
      "section_title": true,
      "ja": "6.9. 「空の」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"empty\" value is represented as \"[null]\", i.e., an array with the \"null\" literal being its only element. For the purposes of this document, \"[null]\" is considered an atomic scalar value.",
      "ja": "「空」の値は「[null]」として表されます。つまり、「null」リテラルが唯一の要素である配列です。このドキュメントでは、「[null]」はアトミックスカラー値と見なされます。"
    },
    {
      "indent": 3,
      "text": "This encoding of the \"empty\" type was chosen instead of using simply \"null\" in order to facilitate the use of empty leafs in common programming languages where the \"null\" value of a member is treated as if the member is not present.",
      "ja": "メンバーの「null」値がメンバーが存在しないかのように扱われる一般的なプログラミング言語で空のリーフを使用しやすくするために、単に「null」を使用する代わりに、「empty」タイプのこのエンコーディングが選択されました。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf definition",
      "ja": "例：リーフ定義の場合"
    },
    {
      "indent": 3,
      "text": "leaf foo {\n  type empty;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "a valid instance is",
      "ja": "有効なインスタンスは"
    },
    {
      "indent": 3,
      "text": "\"foo\": [null]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.10. The \"union\" Type",
      "section_title": true,
      "ja": "6.10. 「ユニオン」タイプ"
    },
    {
      "indent": 3,
      "text": "A value of the \"union\" type is encoded as the value of any of the member types.",
      "ja": "「ユニオン」タイプの値は、メンバータイプのいずれかの値としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "When validating a value of the \"union\" type, the type information conveyed by the JSON encoding MUST also be taken into account. JSON syntax thus provides additional means for resolving the member type of the union that are not available in XML encoding.",
      "ja": "「ユニオン」タイプの値を検証するとき、JSONエンコーディングによって伝えられるタイプ情報も考慮に入れられなければなりません（MUST）。したがって、JSON構文は、XMLエンコーディングでは使用できないユニオンのメンバータイプを解決するための追加の手段を提供します。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG definition:",
      "ja": "たとえば、次のYANG定義を考えてみます。"
    },
    {
      "indent": 3,
      "text": "leaf bar {\n  type union {\n    type uint16;\n    type string;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In RESTCONF [RESTCONF], it is possible to set the value of \"bar\" in the following way when using the \"application/yang.data+xml\" media type:",
      "ja": "RESTCONF [RESTCONF]では、「application / yang.data + xml」メディアタイプを使用する場合、「bar」の値を次のように設定できます。"
    },
    {
      "indent": 3,
      "text": "<bar>13.5</bar>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "because the value may be interpreted as a string, i.e., the second member type of the union. When using the \"application/yang.data+json\" media type, however, this is an error:",
      "ja": "これは、値が文字列、つまり、共用体の2番目のメンバータイプとして解釈される可能性があるためです。ただし、「application / yang.data + json」メディアタイプを使用すると、これはエラーになります。"
    },
    {
      "indent": 3,
      "text": "\"bar\": 13.5",
      "ja": "「バー」：13.5"
    },
    {
      "indent": 3,
      "text": "In this case, the JSON encoding indicates that the value is supposed to be a number rather than a string, and it is not a valid \"uint16\" value.",
      "ja": "この場合、JSONエンコーディングは、値が文字列ではなく数値であることを想定しており、有効な「uint16」値ではないことを示しています。"
    },
    {
      "indent": 3,
      "text": "Conversely, the value of",
      "ja": "逆に、"
    },
    {
      "indent": 3,
      "text": "\"bar\": \"1\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is to be interpreted as a string.",
      "ja": "文字列として解釈されます。"
    },
    {
      "indent": 0,
      "text": "6.11. The \"instance-identifier\" Type",
      "section_title": true,
      "ja": "6.11. 「インスタンス識別子」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"instance-identifier\" value is encoded as a string that is analogical to the lexical representation in XML encoding; see Section 9.13.2 in [RFC7950]. However, the encoding of namespaces in instance-identifier values follows the rules stated in Section 4, namely:",
      "ja": "「インスタンス識別子」の値は、XMLエンコーディングの字句表現に類似した文字列としてエンコードされます。 [RFC7950]のセクション9.13.2を参照してください。ただし、インスタンス識別子の値の名前空間のエンコーディングは、セクション4で説明されている規則に従います。"
    },
    {
      "indent": 3,
      "text": "o The leftmost (top-level) data node name is always in the namespace-qualified form.",
      "ja": "o 左端（最上位）のデータノード名は、常に名前空間で修飾された形式です。"
    },
    {
      "indent": 3,
      "text": "o Any subsequent data node name is in the namespace-qualified form if the node is defined in a module other than its parent node, and the simple form is used otherwise. This rule also holds for node names appearing in predicates.",
      "ja": "o 後続のデータノード名は、ノードがその親ノード以外のモジュールで定義されている場合、名前空間修飾形式であり、それ以外の場合は単純形式が使用されます。このルールは、述語に現れるノード名にも適用されます。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 3,
      "text": "/ietf-interfaces:interfaces/interface[name='eth0']/ietf-ip:ipv4/ip",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is a valid instance-identifier value because the data nodes \"interfaces\", \"interface\", and \"name\" are defined in the module \"ietf-interfaces\", whereas \"ipv4\" and \"ip\" are defined in \"ietf-ip\".",
      "ja": "データノード「interfaces」、「interface」、および「name」はモジュール「ietf-interfaces」で定義されているのに対し、「ipv4」および「ip」は「ietf-ip」で定義されているため、有効なインスタンス識別子の値です。"
    },
    {
      "indent": 0,
      "text": "7. I-JSON Compliance",
      "section_title": true,
      "ja": "7. I-JSONコンプライアンス"
    },
    {
      "indent": 3,
      "text": "I-JSON [RFC7493] is a restricted profile of JSON that guarantees maximum interoperability for protocols that use JSON in their messages, no matter what JSON encoders/decoders are used in protocol implementations. The encoding defined in this document therefore observes the I-JSON requirements and recommendations as closely as possible.",
      "ja": "I-JSON [RFC7493]はJSONの制限付きプロファイルであり、プロトコル実装で使用されるJSONエンコーダー/デコーダーに関係なく、メッセージでJSONを使用するプロトコルの最大の相互運用性を保証します。したがって、このドキュメントで定義されているエンコーディングは、I-JSONの要件と推奨事項にできる限り厳密に準拠しています。"
    },
    {
      "indent": 3,
      "text": "In particular, the following properties are guaranteed:",
      "ja": "特に、次のプロパティが保証されています。"
    },
    {
      "indent": 3,
      "text": "o Character encoding is UTF-8.",
      "ja": "o 文字エンコードはUTF-8です。"
    },
    {
      "indent": 3,
      "text": "o Member names within the same JSON object are always unique.",
      "ja": "o 同じJSONオブジェクト内のメンバー名は常に一意です。"
    },
    {
      "indent": 3,
      "text": "o The order of JSON object members is never relied upon.",
      "ja": "o JSONオブジェクトメンバーの順序に依存することはありません。"
    },
    {
      "indent": 3,
      "text": "o Numbers of any type supported by YANG can be exchanged reliably. See Section 6.1 for details.",
      "ja": "o YANGがサポートするすべてのタイプの数値を確実に交換できます。詳細については、セクション6.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The JSON encoding defined in this document deviates from I-JSON only in the representation of the \"binary\" type. In order to remain compatible with XML encoding, the base64 encoding scheme is used (Section 6.6), whilst I-JSON recommends base64url instead.",
      "ja": "このドキュメントで定義されているJSONエンコーディングは、「バイナリ」タイプの表現のみがI-JSONから逸脱しています。 XMLエンコーディングとの互換性を維持するために、base64エンコーディングスキームが使用されますが（セクション6.6）、I-JSONは代わりにbase64urlを推奨しています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines an alternative encoding for data modeled in the YANG data modeling language. As such, it doesn't contribute any new security issues beyond those discussed in Section 17 of [RFC7950].",
      "ja": "このドキュメントでは、YANGデータモデリング言語でモデル化されたデータの代替エンコーディングを定義します。したがって、[RFC7950]のセクション17で説明されている問題以外の新しいセキュリティ問題は発生しません。"
    },
    {
      "indent": 3,
      "text": "This document defines no mechanisms for signing and encrypting data modeled with YANG. Under normal circumstances, data security and integrity are guaranteed by the management protocol in use, such as NETCONF [RFC6241] or RESTCONF [RESTCONF]. If this is not the case, external mechanisms, such as Public-Key Cryptography Standards (PKCS) #7 [RFC2315] or JSON Object Signing and Encryption (JOSE) [RFC7515] [RFC7516], need to be considered.",
      "ja": "このドキュメントでは、YANGでモデル化されたデータの署名と暗号化のメカニズムを定義していません。通常の状況では、データのセキュリティと整合性は、NETCONF [RFC6241]やRESTCONF [RESTCONF]などの使用中の管理プロトコルによって保証されます。そうでない場合は、公開鍵暗号化標準（PKCS）＃7 [RFC2315]またはJSONオブジェクト署名および暗号化（JOSE）[RFC7515] [RFC7516]などの外部メカニズムを検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "JSON processing is rather different from XML, and JSON parsers may thus suffer from different types of vulnerabilities than their XML counterparts. To minimize these new security risks, software on the receiving side SHOULD reject all messages that do not comply with the rules of this document and reply with an appropriate error message to the sender.",
      "ja": "JSONの処理はXMLとはかなり異なるため、JSONパーサーは、XMLのパーサーとは異なる種類の脆弱性の影響を受ける可能性があります。これらの新しいセキュリティリスクを最小限に抑えるために、受信側のソフトウェアは、このドキュメントのルールに準拠しないすべてのメッセージを拒否し、送信者に適切なエラーメッセージを返信する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241] Enns、R。、編、Bjorklund、M。、編、Schoenwaelder、J。、編、およびA. Bierman、編、「Network Configuration Protocol（NETCONF）」、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<http://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T。、編、「JavaScript Object Notation（JSON）データ交換フォーマット」、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<http://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <http://www.rfc-editor.org/info/rfc7493>.",
      "ja": "[RFC7493]ブレイ、T。、編、「The I-JSON Message Format」、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、<http://www.rfc-editor.org/info/rfc7493>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <http://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M。、編、「The YANG 1.1 Data Modeling Language」、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<http://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "ja": "[IEEE754-2008] IEEE、「IEEE Standard for Floating-Point Arithmetic」、IEEE 754-2008、DOI 10.1109 / IEEESTD.2008.4610935、2008、<http://standards.ieee.org/findstds/ standard / 754-2008。 html>。"
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "ja": "[RESTCONF] Bierman、A.、Bjorklund、M。、およびK. Watsen、「RESTCONF Protocol」、Work in Progress、draft-ietf-netconf-restconf-16、2016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2315] Kaliski, B., \"PKCS #7: Cryptographic Message Syntax Version 1.5\", RFC 2315, DOI 10.17487/RFC2315, March 1998, <http://www.rfc-editor.org/info/rfc2315>.",
      "ja": "[RFC2315] Kaliski、B。、「PKCS＃7：Cryptographic Message Syntax Version 1.5」、RFC 2315、DOI 10.17487 / RFC2315、1998年3月、<http://www.rfc-editor.org/info/rfc2315>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M。、編、「YANG-ネットワーク構成プロトコル（NETCONF）のデータモデリング言語」、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<http：//www.rfc-editor。 org / info / rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC7223] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 7223, DOI 10.17487/RFC7223, May 2014, <http://www.rfc-editor.org/info/rfc7223>.",
      "ja": "[RFC7223] Bjorklund、M。、「A YANG Data Model for Interface Management」、RFC 7223、DOI 10.17487 / RFC7223、2014年5月、<http://www.rfc-editor.org/info/rfc7223>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <http://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515]ジョーンズ、M。、ブラッドリー、J。、およびN.崎村、「JSON Web Signature（JWS）」、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、<http://www.rfc-editor.org / info / rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M。およびJ.ヒルデブランド、「JSON Web Encryption（JWE）」、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<http://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7952] Lhotka, L., \"Defining and Using Metadata with YANG\", RFC 7952, DOI 10.17487/RFC7952, August 2016, <http://www.rfc-editor.org/info/rfc7952>.",
      "ja": "[RFC7952] Lhotka、L。、「YANGを使用したメタデータの定義と使用」、RFC 7952、DOI 10.17487 / RFC7952、2016年8月、<http://www.rfc-editor.org/info/rfc7952>。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126>.",
      "ja": "[XML] Bray、T.、Paoli、J.、Sperberg-McQueen、M.、Maler、E。、およびF. Yergeau、「Extensible Markup Language（XML）1.0（Fifth Edition）」、World Wide Web Consortium Recommendation REC -xml-20081126、2008年11月、<http://www.w3.org/TR/2008/REC-xml-20081126>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. A Complete Example",
      "section_title": true,
      "ja": "付録A.完全な例"
    },
    {
      "indent": 3,
      "text": "The JSON document shown below represents the same data as the reply to the NETCONF <get> request appearing in Appendix D of [RFC7223]. The data model is a combination of two YANG modules: \"ietf-interfaces\" and \"ex-vlan\" (the latter is an example module from Appendix C of [RFC7223]). The \"if-mib\" feature defined in the \"ietf-interfaces\" module is supported.",
      "ja": "以下に示すJSONドキュメントは、[RFC7223]の付録DにあるNETCONF <get>リクエストへの応答と同じデータを表しています。データモデルは、「ietf-interfaces」と「ex-vlan」の2つのYANGモジュールの組み合わせです（後者は[RFC7223]の付録Cのモジュールの例です）。 「ietf-interfaces」モジュールで定義されている「if-mib」機能がサポートされています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ietf-interfaces:interfaces\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": false\n      },\n      {\n        \"name\": \"eth1\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": true,\n        \"ex-vlan:vlan-tagging\": true\n      },\n      {\n        \"name\": \"eth1.10\",\n        \"type\": \"iana-if-type:l2vlan\",\n        \"enabled\": true,\n        \"ex-vlan:base-interface\": \"eth1\",\n        \"ex-vlan:vlan-id\": 10\n      },\n      {\n        \"name\": \"lo1\",\n        \"type\": \"iana-if-type:softwareLoopback\",\n        \"enabled\": true\n      }\n    ]\n  },\n  \"ietf-interfaces:interfaces-state\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"admin-status\": \"down\",\n        \"oper-status\": \"down\",\n        \"if-index\": 2,\n        \"phys-address\": \"00:01:02:03:04:05\",\n        \"statistics\": {\n          \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "  }\n},\n{\n  \"name\": \"eth1\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 7,\n  \"phys-address\": \"00:01:02:03:04:06\",\n  \"higher-layer-if\": [\n    \"eth1.10\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth1.10\",\n  \"type\": \"iana-if-type:l2vlan\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 9,\n  \"lower-layer-if\": [\n    \"eth1\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth2\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"down\",\n  \"oper-status\": \"down\",\n  \"if-index\": 8,\n  \"phys-address\": \"00:01:02:03:04:07\",\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"lo1\",\n  \"type\": \"iana-if-type:softwareLoopback\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 1,\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        }\n      }\n    ]\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author wishes to thank Andy Bierman, Martin Bjorklund, Dean Bogdanovic, Balazs Lengyel, Juergen Schoenwaelder, and Phil Shafer for their helpful comments and suggestions.",
      "ja": "著者は、アンディビアマン、マーティンビョークルンド、ディーンボグダノビッチ、バラツレンゲル、ユルゲンシェーンヴェルダー、フィルシェーファーの有益なコメントと提案に感謝します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ladislav Lhotka CZ.NIC",
      "ja": "ラディスラフ・ロトカCZ.NIC"
    },
    {
      "indent": 3,
      "text": "Email: lhotka@nic.cz",
      "raw": true,
      "ja": ""
    }
  ]
}