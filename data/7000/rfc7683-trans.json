{
  "title": {
    "text": "RFC 7683 - Diameter Overload Indication Conveyance",
    "ja": "RFC 7683 - 直径過負荷表示伝達"
  },
  "number": 7683,
  "created_at": "2020-08-30 11:52:04.531147+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  J. Korhonen, Ed.\nRequest for Comments: 7683                          Broadcom Corporation\nCategory: Standards Track                                S. Donovan, Ed.\nISSN: 2070-1721                                              B. Campbell\n                                                                  Oracle\n                                                               L. Morand\n                                                             Orange Labs\n                                                            October 2015",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Diameter Overload Indication Conveyance",
      "ja": "直径過負荷表示伝達"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification defines a base solution for Diameter overload control, referred to as Diameter Overload Indication Conveyance (DOIC).",
      "ja": "この仕様は、Diameter過負荷制御（DOIC）と呼ばれるDiameter過負荷制御の基本ソリューションを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7683.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7683で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology and Abbreviations . . . . . . . . . . . . . . . .   3\n3.  Conventions Used in This Document . . . . . . . . . . . . . .   5\n4.  Solution Overview . . . . . . . . . . . . . . . . . . . . . .   5\n  4.1.  Piggybacking  . . . . . . . . . . . . . . . . . . . . . .   6\n  4.2.  DOIC Capability Announcement  . . . . . . . . . . . . . .   7\n  4.3.  DOIC Overload Condition Reporting . . . . . . . . . . . .   9\n  4.4.  DOIC Extensibility  . . . . . . . . . . . . . . . . . . .  11\n  4.5.  Simplified Example Architecture . . . . . . . . . . . . .  12\n5.  Solution Procedures . . . . . . . . . . . . . . . . . . . . .  12\n  5.1.  Capability Announcement . . . . . . . . . . . . . . . . .  12\n    5.1.1.  Reacting Node Behavior  . . . . . . . . . . . . . . .  13\n    5.1.2.  Reporting Node Behavior . . . . . . . . . . . . . . .  13\n    5.1.3.  Agent Behavior  . . . . . . . . . . . . . . . . . . .  14\n  5.2.  Overload Report Processing  . . . . . . . . . . . . . . .  15\n    5.2.1.  Overload Control State  . . . . . . . . . . . . . . .  15\n    5.2.2.  Reacting Node Behavior  . . . . . . . . . . . . . . .  19\n    5.2.3.  Reporting Node Behavior . . . . . . . . . . . . . . .  20\n  5.3.  Protocol Extensibility  . . . . . . . . . . . . . . . . .  22\n6.  Loss Algorithm  . . . . . . . . . . . . . . . . . . . . . . .  23\n  6.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  23\n  6.2.  Reporting Node Behavior . . . . . . . . . . . . . . . . .  24\n  6.3.  Reacting Node Behavior  . . . . . . . . . . . . . . . . .  24\n7.  Attribute Value Pairs . . . . . . . . . . . . . . . . . . . .  25\n  7.1.  OC-Supported-Features AVP . . . . . . . . . . . . . . . .  25\n  7.2.  OC-Feature-Vector AVP . . . . . . . . . . . . . . . . . .  25\n  7.3.  OC-OLR AVP  . . . . . . . . . . . . . . . . . . . . . . .  26\n  7.4.  OC-Sequence-Number AVP  . . . . . . . . . . . . . . . . .  26\n  7.5.  OC-Validity-Duration AVP  . . . . . . . . . . . . . . . .  26\n  7.6.  OC-Report-Type AVP  . . . . . . . . . . . . . . . . . . .  27\n  7.7.  OC-Reduction-Percentage AVP . . . . . . . . . . . . . . .  27\n  7.8.  AVP Flag Rules  . . . . . . . . . . . . . . . . . . . . .  28\n8.  Error Response Codes  . . . . . . . . . . . . . . . . . . . .  28\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  29\n  9.1.  AVP Codes . . . . . . . . . . . . . . . . . . . . . . . .  29\n  9.2.  New Registries  . . . . . . . . . . . . . . . . . . . . .  29\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  30\n  10.1.  Potential Threat Modes . . . . . . . . . . . . . . . . .  30\n  10.2.  Denial-of-Service Attacks  . . . . . . . . . . . . . . .  31\n  10.3.  Noncompliant Nodes . . . . . . . . . . . . . . . . . . .  32\n  10.4.  End-to-End Security Issues . . . . . . . . . . . . . . .  32\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  34\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  34\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  34",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix A.  Issues Left for Future Specifications  . . . . . . .  35\n  A.1.  Additional Traffic Abatement Algorithms . . . . . . . . .  35\n  A.2.  Agent Overload  . . . . . . . . . . . . . . . . . . . . .  35\n  A.3.  New Error Diagnostic AVP  . . . . . . . . . . . . . . . .  35\nAppendix B.  Deployment Considerations  . . . . . . . . . . . . .  35\nAppendix C.  Considerations for Applications Integrating the DOIC\n             Solution . . . . . . . . . . . . . . . . . . . . . .  36\n  C.1.  Application Classification  . . . . . . . . . . . . . . .  36\n  C.2.  Implications of Application Type Overload . . . . . . . .  37\n  C.3.  Request Transaction Classification  . . . . . . . . . . .  38\n  C.4.  Request Type Overload Implications  . . . . . . . . . . .  39\nContributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  41\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  42",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This specification defines a base solution for Diameter overload control, referred to as Diameter Overload Indication Conveyance (DOIC), based on the requirements identified in [RFC7068].",
      "ja": "この仕様は、[RFC7068]で特定された要件に基づいて、Diameter過負荷表示伝達（DOIC）と呼ばれるDiameter過負荷制御の基本ソリューションを定義します。"
    },
    {
      "indent": 3,
      "text": "This specification addresses Diameter overload control between Diameter nodes that support the DOIC solution. The solution, which is designed to apply to existing and future Diameter applications, requires no changes to the Diameter base protocol [RFC6733] and is deployable in environments where some Diameter nodes do not implement the Diameter overload control solution defined in this specification.",
      "ja": "この仕様は、DOICソリューションをサポートするDiameterノード間のDiameter過負荷制御を扱います。このソリューションは、既存および将来のDiameterアプリケーションに適用するように設計されており、Diameter基本プロトコル[RFC6733]に変更を加える必要がなく、一部のDiameterノードがこの仕様で定義されているDiameter過負荷制御ソリューションを実装していない環境に展開できます。"
    },
    {
      "indent": 3,
      "text": "A new application specification can incorporate the overload control mechanism specified in this document by making it mandatory to implement for the application and referencing this specification normatively. It is the responsibility of the Diameter application designers to define how overload control mechanisms work on that application.",
      "ja": "新しいアプリケーション仕様では、アプリケーションの実装を必須にしてこの仕様を規範的に参照することにより、このドキュメントで指定されている過負荷制御メカニズムを組み込むことができます。 Diameterアプリケーション設計者は、そのアプリケーションで過負荷制御メカニズムがどのように機能するかを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the overload control solution defined in this specification does not address all the requirements listed in [RFC7068]. A number of features related to overload control are left for future specifications. See Appendix A for a list of extensions that are currently being considered.",
      "ja": "この仕様で定義されている過負荷制御ソリューションは、[RFC7068]にリストされているすべての要件に対応しているわけではないことに注意してください。過負荷制御に関連する多くの機能は、将来の仕様に残されています。現在検討されている拡張機能のリストについては、付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Abbreviations",
      "section_title": true,
      "ja": "2. 用語と略語"
    },
    {
      "indent": 3,
      "text": "Abatement",
      "ja": "削減"
    },
    {
      "indent": 6,
      "text": "Reaction to receipt of an overload report resulting in a reduction in traffic sent to the reporting node. Abatement actions include diversion and throttling.",
      "ja": "レポートノードに送信されるトラフィックの削減につながる過負荷レポートの受信に対する反応。削減アクションには、宛先変更とスロットリングが含まれます。"
    },
    {
      "indent": 3,
      "text": "Abatement Algorithm",
      "ja": "削減アルゴリズム"
    },
    {
      "indent": 6,
      "text": "An extensible method requested by reporting nodes and used by reacting nodes to reduce the amount of traffic sent during an occurrence of overload control.",
      "ja": "レポートノードによって要求され、過負荷制御の発生中に送信されるトラフィックの量を減らすために反応ノードによって使用される拡張可能な方法。"
    },
    {
      "indent": 3,
      "text": "Diversion",
      "ja": "転用"
    },
    {
      "indent": 6,
      "text": "An overload abatement treatment where the reacting node selects alternate destinations or paths for requests.",
      "ja": "対応するノードが要求の代替宛先またはパスを選択する過負荷軽減処理。"
    },
    {
      "indent": 3,
      "text": "Host-Routed Requests",
      "ja": "ホストルーティングされたリクエスト"
    },
    {
      "indent": 6,
      "text": "Requests that a reacting node knows will be served by a particular host, either due to the presence of a Destination-Host Attribute Value Pair (AVP) or by some other local knowledge on the part of the reacting node.",
      "ja": "Destination-Host Attribute Value Pair（AVP）が存在するため、または反応するノードの一部に関する他のローカルな知識によって、反応するノードが知っている要求は特定のホストによって処理されます。"
    },
    {
      "indent": 3,
      "text": "Overload Control State (OCS)",
      "ja": "過負荷制御状態（OCS）"
    },
    {
      "indent": 6,
      "text": "Internal state maintained by a reporting or reacting node describing occurrences of overload control.",
      "ja": "過負荷制御の発生を説明する報告ノードまたは反応ノードによって維持される内部状態。"
    },
    {
      "indent": 3,
      "text": "Overload Report (OLR)",
      "ja": "過負荷レポート（OLR）"
    },
    {
      "indent": 6,
      "text": "Overload control information for a particular overload occurrence sent by a reporting node.",
      "ja": "レポートノードによって送信された特定の過負荷発生の過負荷制御情報。"
    },
    {
      "indent": 3,
      "text": "Reacting Node",
      "ja": "れあｃちんｇ ので"
    },
    {
      "indent": 6,
      "text": "A Diameter node that acts upon an overload report.",
      "ja": "過負荷レポートに作用するDiameterノード。"
    },
    {
      "indent": 3,
      "text": "Realm-Routed Requests",
      "ja": "レルムルーティングされたリクエスト"
    },
    {
      "indent": 6,
      "text": "Requests sent by a reacting node where the reacting node does not know to which host the request will be routed.",
      "ja": "反応ノードが要求をルーティングするホストを知らない反応ノードによって送信された要求。"
    },
    {
      "indent": 3,
      "text": "Reporting Node",
      "ja": "れぽｒちんｇ ので"
    },
    {
      "indent": 6,
      "text": "A Diameter node that generates an overload report. (This may or may not be the overloaded node.)",
      "ja": "過負荷レポートを生成するDiameterノード。 （これは過負荷のノードである場合とそうでない場合があります。）"
    },
    {
      "indent": 3,
      "text": "Throttling",
      "ja": "スロットル"
    },
    {
      "indent": 6,
      "text": "An abatement treatment that limits the number of requests sent by the reacting node. Throttling can include a Diameter Client choosing to not send requests, or a Diameter Agent or Server rejecting requests with appropriate error responses. In both cases, the result of the throttling is a permanent rejection of the transaction.",
      "ja": "対応するノードによって送信された要求の数を制限する削減処理。スロットルには、リクエストを送信しないことを選択するDiameterクライアント、または適切なエラー応答でリクエストを拒否するDiameterエージェントまたはサーバーを含めることができます。どちらの場合も、スロットリングの結果、トランザクションは永久に拒否されます。"
    },
    {
      "indent": 0,
      "text": "3. Conventions Used in This Document",
      "section_title": true,
      "ja": "3. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The interpretation from RFC 2119 [RFC2119] does not apply for the above listed words when they are not used in all caps.",
      "ja": "RFC 2119 [RFC2119]の解釈は、すべての大文字で使用されていない場合、上記の単語には適用されません。"
    },
    {
      "indent": 0,
      "text": "4. Solution Overview",
      "section_title": true,
      "ja": "4. ソリューションの概要"
    },
    {
      "indent": 3,
      "text": "The Diameter Overload Information Conveyance (DOIC) solution allows Diameter nodes to request that other Diameter nodes perform overload abatement actions, that is, actions to reduce the load offered to the overloaded node or realm.",
      "ja": "Diameter過負荷情報伝達（DOIC）ソリューションにより、Diameterノードは他のDiameterノードに過負荷軽減アクション、つまり過負荷ノードまたはレルムに提供される負荷を軽減するアクションを実行するよう要求できます。"
    },
    {
      "indent": 3,
      "text": "A Diameter node that supports DOIC is known as a \"DOIC node\". Any Diameter node can act as a DOIC node, including Diameter Clients, Diameter Servers, and Diameter Agents. DOIC nodes are further divided into \"Reporting Nodes\" and \"Reacting Nodes.\" A reporting node requests overload abatement by sending Overload Reports (OLRs).",
      "ja": "DOICをサポートするDiameterノードは、「DOICノード」と呼ばれます。 Diameterクライアント、Diameterサーバー、Diameterエージェントなど、どのDiameterノードもDOICノードとして機能できます。 DOICノードは、さらに「レポートノード」と「反応ノード」に分かれています。レポートノードは、過負荷レポート（OLR）を送信して過負荷軽減を要求します。"
    },
    {
      "indent": 3,
      "text": "A reacting node acts upon OLRs and performs whatever actions are needed to fulfill the abatement requests included in the OLRs. A reporting node may report overload on its own behalf or on behalf of other nodes. Likewise, a reacting node may perform overload abatement on its own behalf or on behalf of other nodes.",
      "ja": "反応ノードはOLRに作用し、OLRに含まれる削減要求を満たすために必要なアクションを実行します。レポートノードは、自分自身または他のノードに代わって過負荷を報告できます。同様に、反応するノードは、自分自身のために、または他のノードのために過負荷軽減を実行できます。"
    },
    {
      "indent": 3,
      "text": "A Diameter node's role as a DOIC node is independent of its Diameter role. For example, Diameter Agents may act as DOIC nodes, even though they are not endpoints in the Diameter sense. Since Diameter enables bidirectional applications, where Diameter Servers can send requests towards Diameter Clients, a given Diameter node can simultaneously act as both a reporting node and a reacting node.",
      "ja": "DOICノードとしてのDiameterノードの役割は、Diameterの役割とは無関係です。たとえば、Diameterエージェントは、Diameterの意味ではエンドポイントではありませんが、DOICノードとして機能する場合があります。 Diameterは双方向アプリケーションを有効にするため、DiameterサーバーがDiameterクライアントにリクエストを送信できるため、特定のDiameterノードは、レポートノードと反応ノードの両方として同時に機能できます。"
    },
    {
      "indent": 3,
      "text": "Likewise, a Diameter Agent may act as a reacting node from the perspective of upstream nodes, and a reporting node from the perspective of downstream nodes.",
      "ja": "同様に、Diameterエージェントは、上流ノードの観点からは反応ノードとして機能し、下流ノードの観点からはレポートノードとして機能します。"
    },
    {
      "indent": 3,
      "text": "DOIC nodes do not generate new messages to carry DOIC-related information. Rather, they \"piggyback\" DOIC information over existing Diameter messages by inserting new AVPs into existing Diameter requests and responses. Nodes indicate support for DOIC, and any needed DOIC parameters, by inserting an OC-Supported-Features AVP (Section 7.1) into existing requests and responses. Reporting nodes send OLRs by inserting OC-OLR AVPs (Section 7.3).",
      "ja": "DOICノードは、DOIC関連の情報を伝えるための新しいメッセージを生成しません。むしろ、既存のDiameter要求と応答に新しいAVPを挿入することにより、既存のDiameterメッセージにDOIC情報を「ピギーバック」します。ノードは、OC-Supported-Features AVP（セクション7.1）を既存の要求と応答に挿入することにより、DOICと必要なDOICパラメータのサポートを示します。レポートノードは、OC-OLR AVPを挿入することでOLRを送信します（7.3項）。"
    },
    {
      "indent": 3,
      "text": "A given OLR applies to the Diameter realm and application of the Diameter message that carries it. If a reporting node supports more than one realm and/or application, it reports independently for each combination of realm and application. Similarly, the OC-Supported-Features AVP applies to the realm and application of the enclosing message. This implies that a node may support DOIC for one application and/or realm, but not another, and may indicate different DOIC parameters for each application and realm for which it supports DOIC.",
      "ja": "特定のOLRは、Diameterレルムとそれを運ぶDiameterメッセージのアプリケーションに適用されます。レポートノードが複数のレルムやアプリケーションをサポートする場合、レルムとアプリケーションの組み合わせごとに独立してレポートします。同様に、OC-Supported-Features AVPは、囲んでいるメッセージの領域とアプリケーションに適用されます。これは、ノードが1つのアプリケーションまたはレルム、あるいはその両方でDOICをサポートしている可能性があり、DOICをサポートしているアプリケーションおよびレルムごとに異なるDOICパラメータを示している可能性があることを意味します。"
    },
    {
      "indent": 3,
      "text": "Reacting nodes perform overload abatement according to an agreed-upon abatement algorithm. An abatement algorithm defines the meaning of some of the parameters of an OLR and the procedures required for overload abatement. An overload abatement algorithm separates Diameter requests into two sets. The first set contains the requests that are to undergo overload abatement treatment of either throttling or diversion. The second set contains the requests that are to be given normal routing treatment. This document specifies a single \"must-support\" algorithm, namely, the \"loss\" algorithm (Section 6). Future specifications may introduce new algorithms.",
      "ja": "反応ノードは、合意された軽減アルゴリズムに従って過負荷軽減を実行します。軽減アルゴリズムは、OLRの一部のパラメーターの意味と、過負荷軽減に必要な手順を定義します。過負荷軽減アルゴリズムは、Diameterリクエストを2つのセットに分けます。最初のセットには、スロットルまたは迂回のいずれかの過負荷軽減処理を受けるリクエストが含まれています。 2番目のセットには、通常のルーティング処理が行われるリクエストが含まれています。このドキュメントでは、単一の「必須」アルゴリズム、つまり「損失」アルゴリズム（セクション6）を指定しています。将来の仕様では、新しいアルゴリズムが導入される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Overload conditions may vary in scope. For example, a single Diameter node may be overloaded, in which case, reacting nodes may attempt to send requests to other destinations. On the other hand, an entire Diameter realm may be overloaded, in which case, such attempts would do harm. DOIC OLRs have a concept of \"report type\" (Section 7.6), where the type defines such behaviors. Report types are extensible. This document defines report types for overload of a specific host and for overload of an entire realm.",
      "ja": "過負荷状態は範囲が異なる場合があります。たとえば、単一のDiameterノードが過負荷になる場合があります。その場合、反応するノードが他の宛先にリクエストを送信しようとすることがあります。一方、Diameterレルム全体が過負荷になる可能性があります。その場合、そのような試みは害を及ぼします。 DOIC OLRには「レポートタイプ」（7.6項）という概念があり、タイプによってそのような動作が定義されます。レポートタイプは拡張可能です。このドキュメントでは、特定のホストのオーバーロードおよびレルム全体のオーバーロードのレポートタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "DOIC works through non-supporting Diameter Agents that properly pass unknown AVPs unchanged.",
      "ja": "DOICは、不明なAVPを変更せずに適切に渡す、サポートされていないDiameterエージェントを通じて機能します。"
    },
    {
      "indent": 0,
      "text": "4.1. Piggybacking",
      "section_title": true,
      "ja": "4.1. ピギーバッキング"
    },
    {
      "indent": 0,
      "text": " There is no new Diameter application defined to carry overload-related AVPs. The overload control AVPs defined in this specification have been designed to be piggybacked on top of existing application messages. This is made possible by adding the optional overload control AVPs OC-OLR and OC-Supported-Features into existing commands.",
      "ja": "オーバーロード関連のAVPを伝送するために定義された新しいDiameterアプリケーションはありません。この仕様で定義されている過負荷制御AVPは、既存のアプリケーションメッセージに便乗するように設計されています。これは、オプションの過負荷制御AVPであるOC-OLRおよびOC-Supported-Featuresを既存のコマンドに追加することで可能になります。"
    },
    {
      "indent": 3,
      "text": "Reacting nodes indicate support for DOIC by including the OC-Supported-Features AVP in all request messages originated or relayed by the reacting node.",
      "ja": "反応するノードは、反応するノードによって発信または中継されるすべての要求メッセージにOC-Supported-Features AVPを含めることにより、DOICのサポートを示します。"
    },
    {
      "indent": 3,
      "text": "Reporting nodes indicate support for DOIC by including the OC-Supported-Features AVP in all answer messages that are originated or relayed by the reporting node and that are in response to a request that contained the OC-Supported-Features AVP. Reporting nodes may include overload reports using the OC-OLR AVP in answer messages.",
      "ja": "レポートノードは、OC-Supported-Features AVPを含む要求に応答する、レポートノードによって発信または中継されるすべての応答メッセージにOC-Supported-Features AVPを含めることにより、DOICのサポートを示します。レポートノードには、応答メッセージでOC-OLR AVPを使用した過負荷レポートが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that the overload control solution does not have fixed server and client roles. The DOIC node role is determined based on the message type: whether the message is a request (i.e., sent by a \"reacting node\") or an answer (i.e., sent by a \"reporting node\"). Therefore, in a typical client-server deployment, the Diameter Client may report its overload condition to the Diameter Server for any Diameter-Server-initiated message exchange. An example of such is the Diameter Server requesting a re-authentication from a Diameter Client.",
      "ja": "過負荷制御ソリューションには、固定のサーバーおよびクライアントの役割がないことに注意してください。 DOICノードの役割は、メッセージタイプに基づいて決定されます。メッセージが要求（つまり、「反応ノード」によって送信されたもの）であるか、応答（つまり、「レポートノード」によって送信されたもの）であるかです。したがって、一般的なクライアントサーバー展開では、Diameterクライアントは、Diameterサーバーが開始するメッセージ交換について、過負荷状態をDiameterサーバーに報告する場合があります。そのような例は、Diameterクライアントからの再認証を要求するDiameterサーバーです。"
    },
    {
      "indent": 0,
      "text": "4.2. DOIC Capability Announcement",
      "section_title": true,
      "ja": "4.2. DOIC機能の発表"
    },
    {
      "indent": 3,
      "text": "The DOIC solution supports the ability for Diameter nodes to determine if other nodes in the path of a request support the solution. This capability is referred to as DOIC Capability Announcement (DCA) and is separate from the Diameter Capability Exchange.",
      "ja": "DOICソリューションは、Diameterノードが要求のパス内の他のノードがソリューションをサポートしているかどうかを判別する機能をサポートします。この機能はDOIC Capability Announcement（DCA）と呼ばれ、Diameter Capability Exchangeとは別のものです。"
    },
    {
      "indent": 3,
      "text": "The DCA mechanism uses the OC-Supported-Features AVPs to indicate the Diameter overload features supported.",
      "ja": "DCAメカニズムは、OC-Supported-Features AVPを使用して、サポートされているDiameter過負荷機能を示します。"
    },
    {
      "indent": 3,
      "text": "The first node in the path of a Diameter request that supports the DOIC solution inserts the OC-Supported-Features AVP in the request message.",
      "ja": "DOICソリューションをサポートするDiameterリクエストのパスの最初のノードは、リクエストメッセージにOC-Supported-Features AVPを挿入します。"
    },
    {
      "indent": 3,
      "text": "The individual features supported by the DOIC nodes are indicated in the OC-Feature-Vector AVP. Any semantics associated with the features will be defined in extension specifications that introduce the features.",
      "ja": "DOICノードでサポートされる個々の機能は、OC-Feature-Vector AVPに示されています。機能に関連付けられているすべてのセマンティクスは、機能を紹介する拡張仕様で定義されます。"
    },
    {
      "indent": 6,
      "text": "Note: As discussed elsewhere in the document, agents in the path of the request can modify the OC-Supported-Features AVP.",
      "ja": "注：ドキュメントの他の場所で説明したように、リクエストのパスにあるエージェントは、OC-Supported-Features AVPを変更できます。"
    },
    {
      "indent": 6,
      "text": "Note: The DOIC solution must support deployments where Diameter Clients and/or Diameter Servers do not support the DOIC solution. In this scenario, Diameter Agents that support the DOIC solution may handle overload abatement for the non-supporting Diameter nodes. In this case, the DOIC agent will insert the OC-Supported-Features AVP in requests that do not already contain one, telling the reporting node that there is a DOIC node that will handle overload abatement. For transactions where there was an OC-Supporting-Features AVP in the request, the agent will insert the OC-Supported-Features AVP in answers, telling the reacting node that there is a reporting node.",
      "ja": "注：DOICソリューションは、DiameterクライアントまたはDiameterサーバー、あるいはその両方がDOICソリューションをサポートしない配置をサポートする必要があります。このシナリオでは、DOICソリューションをサポートするDiameterエージェントが、サポートされていないDiameterノードの過負荷軽減を処理する場合があります。この場合、DOICエージェントは、OC-Supported-Features AVPをまだ含んでいないリクエストに挿入し、過負荷軽減を処理するDOICノードがあることをレポートノードに通知します。リクエストにOC-Supporting-Features AVPがあったトランザクションの場合、エージェントは応答にOC-Supported-Features AVPを挿入し、レポートノードがあることを反応ノードに通知します。"
    },
    {
      "indent": 3,
      "text": "The OC-Feature-Vector AVP will always contain an indication of support for the loss overload abatement algorithm defined in this specification (see Section 6). This ensures that a reporting node always supports at least one of the advertised abatement algorithms received in a request messages.",
      "ja": "OC-Feature-Vector AVPには、この仕様で定義されている損失過負荷軽減アルゴリズムのサポートの指示が常に含まれます（セクション6を参照）。これにより、レポートノードは常に、要求メッセージで受信されたアドバタイズされた軽減アルゴリズムの少なくとも1つをサポートします。"
    },
    {
      "indent": 3,
      "text": "The reporting node inserts the OC-Supported-Features AVP in all answer messages to requests that contained the OC-Supported-Features AVP. The contents of the reporting node's OC-Supported-Features AVP indicate the set of Diameter overload features supported by the reporting node. This specification defines one exception -- the reporting node only includes an indication of support for one overload abatement algorithm, independent of the number of overload abatement algorithms actually supported by the reacting node. The overload abatement algorithm indicated is the algorithm that the reporting node intends to use should it enter an overload condition. Reacting nodes can use the indicated overload abatement algorithm to prepare for possible overload reports and must use the indicated overload abatement algorithm if traffic reduction is actually requested.",
      "ja": "レポートノードは、OC-Supported-Features AVPを含むリクエストに対するすべての応答メッセージにOC-Supported-Features AVPを挿入します。レポートノードのOC-Supported-Features AVPの内容は、レポートノードによってサポートされる一連のDiameter過負荷機能を示します。この仕様は1つの例外を定義しています-レポートノードには、反応するノードが実際にサポートする過負荷軽減アルゴリズムの数とは無関係に、1つの過負荷軽減アルゴリズムのサポートの指示のみが含まれます。示されている過負荷軽減アルゴリズムは、レポートノードが過負荷状態になった場合に使用するアルゴリズムです。反応するノードは、指定された過負荷軽減アルゴリズムを使用して可能な過負荷レポートを準備でき、実際にトラフィックの削減が要求されている場合は、指定された過負荷軽減アルゴリズムを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that the loss algorithm defined in this document is a stateless abatement algorithm. As a result, it does not require any actions by reacting nodes prior to the receipt of an overload report. Stateful abatement algorithms that base the abatement logic on a history of request messages sent might require reacting nodes to maintain state in advance of receiving an overload report to ensure that the overload reports can be properly handled.",
      "ja": "このドキュメントで定義されている損失アルゴリズムは、ステートレスな軽減アルゴリズムであることに注意してください。その結果、過負荷レポートを受信する前にノードを反応させることによるアクションは必要ありません。送信されたリクエストメッセージの履歴に基づいて削減ロジックを実行するステートフルな削減アルゴリズムでは、過負荷レポートを受信する前に、ノードが状態を維持して過負荷レポートを適切に処理できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "While it should only be done in exceptional circumstances and not during an active occurrence of overload, a reacting node that wishes to transition to a different abatement algorithm can stop advertising support for the algorithm indicated by the reporting node, as long as support for the loss algorithm is always advertised.",
      "ja": "過負荷がアクティブに発生しているときではなく、例外的な状況でのみ実行する必要がありますが、別の軽減アルゴリズムに移行することを希望する反応ノードは、損失のサポートがある限り、レポートノードが示すアルゴリズムのサポートのアドバタイズを停止できます。アルゴリズムは常にアドバタイズされます。"
    },
    {
      "indent": 3,
      "text": "The DCA mechanism must also allow the scenario where the set of features supported by the sender of a request and by agents in the path of a request differ. In this case, the agent can update the OC-Supported-Features AVP to reflect the mixture of the two sets of supported features.",
      "ja": "DCAメカニズムでは、要求の送信者と要求のパス内のエージェントによってサポートされる機能のセットが異なるシナリオも許可する必要があります。この場合、エージェントはOC-Supported-Features AVPを更新して、サポートされる機能の2つのセットの混合を反映できます。"
    },
    {
      "indent": 6,
      "text": "Note: The logic to determine if the content of the OC-Supported-Features AVP should be changed is out of scope for this document, as is the logic to determine the content of a modified OC-Supported-Features AVP. These are left to implementation decisions. Care must be taken not to introduce interoperability issues for downstream or upstream DOIC nodes. As such, the agent must act as a fully compliant reporting node to the downstream reacting node and as a fully compliant reacting node to the upstream reporting node.",
      "ja": "注：変更されたOC-Supported-Features AVPのコンテンツを決定するロジックと同様に、OC-Supported-Features AVPのコンテンツを変更する必要があるかどうかを決定するロジックは、このドキュメントの範囲外です。これらは実装の決定に任されています。ダウンストリームまたはアップストリームのDOICノードに相互運用性の問題が発生しないように注意する必要があります。そのため、エージェントは、ダウンストリーム対応ノードへの完全準拠のレポートノードとして、およびアップストリームレポートノードへの完全準拠の反応ノードとして機能する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. DOIC Overload Condition Reporting",
      "section_title": true,
      "ja": "4.3. DOIC過負荷状態レポート"
    },
    {
      "indent": 3,
      "text": "As with DOIC capability announcement, overload condition reporting uses new AVPs (Section 7.3) to indicate an overload condition.",
      "ja": "DOIC機能のアナウンスと同様に、過負荷状態のレポートでは、新しいAVP（7.3）を使用して過負荷状態を示します。"
    },
    {
      "indent": 3,
      "text": "The OC-OLR AVP is referred to as an overload report. The OC-OLR AVP includes the type of report, a sequence number, the length of time that the report is valid, and AVPs specific to the abatement algorithm.",
      "ja": "OC-OLR AVPは過負荷レポートと呼ばれます。 OC-OLR AVPには、レポートのタイプ、シーケンス番号、レポートが有効な時間の長さ、および削減アルゴリズムに固有のAVPが含まれます。"
    },
    {
      "indent": 3,
      "text": "Two types of overload reports are defined in this document: host reports and realm reports.",
      "ja": "このドキュメントでは、ホストレポートとレルムレポートの2種類の過負荷レポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "A report of type \"HOST_REPORT\" is sent to indicate the overload of a specific host, identified by the Origin-Host AVP of the message containing the OLR, for the Application-ID indicated in the transaction. When receiving an OLR of type \"HOST_REPORT\", a reacting node applies overload abatement treatment to the host-routed requests identified by the overload abatement algorithm (as defined in Section 2) sent for this application to the overloaded host.",
      "ja": "タイプ「HOST_REPORT」のレポートが送信され、トランザクションに示されているアプリケーションIDについて、OLRを含むメッセージのOrigin-Host AVPによって識別される特定のホストの過負荷を示します。タイプ「HOST_REPORT」のOLRを受信すると、反応するノードは、このアプリケーション用に過負荷ホストに送信された過負荷軽減アルゴリズム（セクション2で定義）によって識別されるホスト経路指定要求に過負荷軽減処理を適用します。"
    },
    {
      "indent": 3,
      "text": "A report of type \"REALM_REPORT\" is sent to indicate the overload of a realm for the Application-ID indicated in the transaction. The overloaded realm is identified by the Destination-Realm AVP of the message containing the OLR. When receiving an OLR of type \"REALM_REPORT\", a reacting node applies overload abatement treatment to realm-routed requests identified by the overload abatement algorithm (as defined in Section 2) sent for this application to the overloaded realm.",
      "ja": "タイプ「REALM_REPORT」のレポートが送信され、トランザクションで示されているアプリケーションIDのレルムの過負荷を示します。過負荷のレルムは、OLRを含むメッセージの宛先レルムAVPによって識別されます。タイプ「REALM_REPORT」のOLRを受信すると、対応するノードは、このアプリケーション用に過負荷レルムに送信された過負荷軽減アルゴリズム（セクション2で定義）によって識別されるレルムルーティング要求に過負荷軽減処理を適用します。"
    },
    {
      "indent": 3,
      "text": "This document assumes that there is a single source for realm reports for a given realm, or that if multiple nodes can send realm reports, that each such node has full knowledge of the overload state of the entire realm. A reacting node cannot distinguish between receiving realm reports from a single node or from multiple nodes.",
      "ja": "このドキュメントでは、特定のレルムのレルムレポートの単一のソースがあること、または複数のノードがレルムレポートを送信できる場合、そのような各ノードがレルム全体の過負荷状態を完全に認識していることを前提としています。反応するノードは、単一のノードからのレルムレポートと複数のノードからのレルムレポートの受信を区別できません。"
    },
    {
      "indent": 6,
      "text": "Note: Known issues exist if there are multiple sources for overload reports that apply to the same Diameter entity. Reacting nodes have no way of determining the source and, as such, will treat them as coming from a single source. Variance in sequence numbers between the two sources can then cause incorrect overload abatement treatment to be applied for indeterminate periods of time.",
      "ja": "注：同じDiameterエンティティに適用される過負荷レポートのソースが複数ある場合、既知の問題が存在します。反応ノードはソースを決定する方法がないため、単一のソースからのノードとして処理されます。 2つのソース間のシーケンス番号の違いにより、不正確な過負荷軽減処理が不確定な期間適用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Reporting nodes are responsible for determining the need for a reduction of traffic. The method for making this determination is implementation specific and depends on the type of overload report being generated. A host report might be generated by tracking use of resources required by the host to handle transactions for the Diameter application. A realm report generally impacts the traffic sent to multiple hosts and, as such, requires tracking the capacity of all servers able to handle realm-routed requests for the application and realm.",
      "ja": "レポートノードは、トラフィックの削減の必要性を判断する責任があります。この決定を行う方法は実装固有であり、生成される過負荷レポートのタイプによって異なります。ホストレポートは、Diameterアプリケーションのトランザクションを処理するためにホストが必要とするリソースの使用を追跡することによって生成される場合があります。レルムレポートは、通常、複数のホストに送信されるトラフィックに影響を与えるため、アプリケーションとレルムに対するレルムルーティングされた要求を処理できるすべてのサーバーの容量を追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a reporting node determines the need for a reduction in traffic, it uses the DOIC-defined AVPs to report on the condition. These AVPs are included in answer messages sent or relayed by the reporting node. The reporting node indicates the overload abatement algorithm that is to be used to handle the traffic reduction in the OC-Supported-Features AVP. The OC-OLR AVP is used to communicate information about the requested reduction.",
      "ja": "レポートノードがトラフィックの削減の必要性を判断すると、DOIC定義のAVPを使用して状態についてレポートします。これらのAVPは、レポートノードによって送信または中継される応答メッセージに含まれます。レポートノードは、OC-Supported-Features AVPのトラフィック削減を処理するために使用される過負荷軽減アルゴリズムを示します。 OC-OLR AVPは、要求された削減に関する情報を伝達するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Reacting nodes, upon receipt of an overload report, apply the overload abatement algorithm to traffic impacted by the overload report. The method used to determine the requests that are to receive overload abatement treatment is dependent on the abatement algorithm. The loss abatement algorithm is defined in this document (Section 6). Other abatement algorithms can be defined in extensions to the DOIC solution.",
      "ja": "反応ノードは、過負荷レポートを受信すると、過負荷レポートの影響を受けるトラフィックに過負荷軽減アルゴリズムを適用します。過負荷軽減処理を受けるリクエストを決定するために使用される方法は、軽減アルゴリズムに依存します。損失軽減アルゴリズムは、このドキュメントで定義されています（セクション6）。その他の軽減アルゴリズムは、DOICソリューションの拡張で定義できます。"
    },
    {
      "indent": 3,
      "text": "Two types of overload abatement treatment are defined, diversion and throttling. Reacting nodes are responsible for determining which treatment is appropriate for individual requests.",
      "ja": "2つのタイプの過負荷軽減処理が定義されています。迂回とスロットルです。反応ノードは、個々の要求に適切な処理を決定する責任があります。"
    },
    {
      "indent": 0,
      "text": " As the conditions that lead to the generation of the overload report change, the reporting node can send new overload reports requesting greater reduction if the condition gets worse or less reduction if the condition improves. The reporting node sends an overload report with a duration of zero to indicate that the overload condition has ended and abatement is no longer needed.",
      "ja": "過負荷レポートの生成につながる条件が変化すると、レポートノードは、条件が悪化した場合は大幅な削減を要求し、条件が改善した場合は削減が少ない新しい過負荷レポートを送信できます。レポートノードは、期間がゼロの過負荷レポートを送信して、過負荷状態が終了し、削減が不要になったことを示します。"
    },
    {
      "indent": 3,
      "text": "The reacting node also determines when the overload report expires based on the OC-Validity-Duration AVP in the overload report and stops applying the abatement algorithm when the report expires.",
      "ja": "反応ノードは、過負荷レポートのOC-Validity-Duration AVPに基づいて過負荷レポートの有効期限がいつになるかを判断し、レポートの有効期限が切れると削減アルゴリズムの適用を停止します。"
    },
    {
      "indent": 3,
      "text": "Note that erroneous overload reports can be used for DoS attacks. This includes the ability to indicate that a significant reduction in traffic, up to and including a request for no traffic, should be sent to a reporting node. As such, care should be taken to verify the sender of overload reports.",
      "ja": "誤った過負荷レポートがDoS攻撃に使用される可能性があることに注意してください。これには、トラフィックの大幅な削減（トラフィックなしのリクエストを含む）をレポートノードに送信する必要があることを示す機能が含まれます。そのため、過負荷レポートの送信者を確認するように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. DOIC Extensibility",
      "section_title": true,
      "ja": "4.4. DOICの拡張性"
    },
    {
      "indent": 3,
      "text": "The DOIC solution is designed to be extensible. This extensibility is based on existing Diameter-based extensibility mechanisms, along with the DOIC capability announcement mechanism.",
      "ja": "DOICソリューションは拡張可能に設計されています。この拡張性は、DOIC機能のアナウンスメントメカニズムとともに、既存のDiameterベースの拡張性メカニズムに基づいています。"
    },
    {
      "indent": 3,
      "text": "There are multiple categories of extensions that are expected. This includes the definition of new overload abatement algorithms, the definition of new report types, and the definition of new scopes of messages impacted by an overload report.",
      "ja": "予想される拡張機能には複数のカテゴリがあります。これには、新しいオーバーロード軽減アルゴリズムの定義、新しいレポートタイプの定義、およびオーバーロードレポートの影響を受けるメッセージの新しいスコープの定義が含まれます。"
    },
    {
      "indent": 3,
      "text": "A DOIC node communicates supported features by including them in the OC-Feature-Vector AVP, as a sub-AVP of OC-Supported-Features. Any non-backwards-compatible DOIC extensions define new values for the OC-Feature-Vector AVP. DOIC extensions also have the ability to add new AVPs to the OC-Supported-Features AVP, if additional information about the new feature is required.",
      "ja": "DOICノードは、OC-Feature-Vector AVPにOC-Supported-FeaturesのサブAVPとしてそれらを含めることにより、サポートされている機能を通信します。下位互換性のないDOIC拡張は、OC-Feature-Vector AVPの新しい値を定義します。 DOIC拡張には、新しい機能に関する追加情報が必要な場合に、OC-Supported-Features AVPに新しいAVPを追加する機能もあります。"
    },
    {
      "indent": 3,
      "text": "Overload reports can also be extended by adding new sub-AVPs to the OC-OLR AVP, allowing reporting nodes to communicate additional information about handling an overload condition.",
      "ja": "OC-OLR AVPに新しいサブAVPを追加して過負荷レポートを拡張することもできます。これにより、レポートノードは過負荷状態の処理に関する追加情報を伝達できます。"
    },
    {
      "indent": 3,
      "text": "If necessary, new extensions can also define new AVPs that are not part of the OC-Supported-Features and OC-OLR group AVPs. It is, however, recommended that DOIC extensions use the OC-Supported-Features AVP and OC-OLR AVP to carry all DOIC-related AVPs.",
      "ja": "必要に応じて、新しい拡張機能は、OC-Supported-FeaturesおよびOC-OLRグループAVPの一部ではない新しいAVPを定義することもできます。ただし、DOIC拡張は、OC-Supported-Features AVPおよびOC-OLR AVPを使用して、すべてのDOIC関連のAVPを伝送することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.5. Simplified Example Architecture",
      "section_title": true,
      "ja": "4.5. 簡略化されたサンプルアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates the simplified architecture for Diameter overload information conveyance.",
      "ja": "図1は、Diameter過負荷情報伝達の単純化されたアーキテクチャーを示しています。"
    },
    {
      "indent": 3,
      "text": " Realm X                                  Same or other Realms\n<--------------------------------------> <---------------------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+--------+                 : (optional) :\n|Diameter|                 :            :\n|Server A|--+     .--.     : +--------+ :     .--.\n+--------+  |   _(    `.   : |Diameter| :   _(    `.   +--------+\n            +--(        )--:-|  Agent |-:--(        )--|Diameter|\n+--------+  | ( `  .  )  ) : +--------+ : ( `  .  )  ) | Client |\n|Diameter|--+  `--(___.-'  :            :  `--(___.-'  +--------+\n|Server B|                 :            :\n+--------+                 :            :",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "             End-to-end Overload Indication\n1)  <----------------------------------------------->\n                Diameter Application Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "     Overload Indication A    Overload Indication A'\n2)  <----------------------> <---------------------->\n    Diameter Application Y   Diameter Application Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 1: Simplified Architecture Choices for Overload Indication Delivery",
      "ja": "図1：過負荷インディケーション配信のための簡素化されたアーキテクチャの選択"
    },
    {
      "indent": 3,
      "text": "In Figure 1, the Diameter overload indication can be conveyed (1) end-to-end between servers and clients or (2) between servers and the Diameter Agent inside the realm and then between the Diameter Agent and the clients.",
      "ja": "図1では、Diameter過負荷の表示は、（1）サーバーとクライアントの間、または（2）サーバーとレルム内のDiameterエージェントの間、およびDiameterエージェントとクライアントの間でエンドツーエンドで伝達できます。"
    },
    {
      "indent": 0,
      "text": "5. Solution Procedures",
      "section_title": true,
      "ja": "5. 解決手順"
    },
    {
      "indent": 3,
      "text": "This section outlines the normative behavior for the DOIC solution.",
      "ja": "このセクションでは、DOICソリューションの規範的な動作の概要を説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Capability Announcement",
      "section_title": true,
      "ja": "5.1. 能力発表"
    },
    {
      "indent": 3,
      "text": "This section defines DOIC Capability Announcement (DCA) behavior.",
      "ja": "このセクションでは、DOIC Capability Announcement（DCA）の動作を定義します。"
    },
    {
      "indent": 0,
      "text": " Note: This specification assumes that changes in DOIC node capabilities are relatively rare events that occur as a result of administrative action. Reacting nodes ought to minimize changes that force the reporting node to change the features being used, especially during active overload conditions. But even if reacting nodes avoid such changes, reporting nodes still have to be prepared for them to occur. For example, differing capabilities between multiple reacting nodes may still force a reporting node to select different features on a per-transaction basis.",
      "ja": "注：この仕様では、DOICノードの機能の変更は、管理アクションの結果として発生する比較的まれなイベントであると想定しています。反応ノードは、特にアクティブな過負荷状態の間、レポートノードが使用されている機能を強制的に変更する変更を最小限に抑える必要があります。しかし、リアクションノードがそのような変更を回避したとしても、レポートノードはそれらが発生するために準備する必要があります。たとえば、複数の反応ノード間で機能が異なる場合でも、レポートノードはトランザクションごとに異なる機能を選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Reacting Node Behavior",
      "section_title": true,
      "ja": "5.1.1. 反応ノードの動作"
    },
    {
      "indent": 3,
      "text": "A reacting node MUST include the OC-Supported-Features AVP in all requests. It MAY include the OC-Feature-Vector AVP, as a sub-AVP of OC-Supported-Features. If it does so, it MUST indicate support for the \"loss\" algorithm. If the reacting node is configured to support features (including other algorithms) in addition to the loss algorithm, it MUST indicate such support in an OC-Feature-Vector AVP.",
      "ja": "反応ノードは、すべてのリクエストにOC-Supported-Features AVPを含める必要があります。 OC-Supported-FeaturesのサブAVPとして、OC-Feature-Vector AVPを含めることができます。その場合は、「損失」アルゴリズムのサポートを示す必要があります。応答アルゴリズムが、損失アルゴリズムに加えて機能（他のアルゴリズムを含む）をサポートするように構成されている場合、OC-Feature-Vector AVPでそのようなサポートを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "An OC-Supported-Features AVP in answer messages indicates there is a reporting node for the transaction. The reacting node MAY take action, for example, creating state for some stateful abatement algorithm, based on the features indicated in the OC-Feature-Vector AVP.",
      "ja": "応答メッセージのOC-Supported-Features AVPは、トランザクションのレポートノードがあることを示します。対応するノードは、たとえば、OC-Feature-Vector AVPに示されている機能に基づいて、何らかのステートフル除算アルゴリズムの状態を作成するなどのアクションを実行できます（MAY）。"
    },
    {
      "indent": 6,
      "text": "Note: The loss abatement algorithm does not require stateful behavior when there is no active overload report.",
      "ja": "注：アクティブな過負荷レポートがない場合、損失軽減アルゴリズムはステートフルな動作を必要としません。"
    },
    {
      "indent": 3,
      "text": "Reacting nodes need to be prepared for the reporting node to change selected algorithms. This can happen at any time, including when the reporting node has sent an active overload report. The reacting node can minimize the potential for changes by modifying the advertised abatement algorithms sent to an overloaded reporting node to the currently selected algorithm and loss (or just loss if it is the currently selected algorithm). This has the effect of limiting the potential change in abatement algorithm from the currently selected algorithm to loss, avoiding changes to more complex abatement algorithms that require state to operate properly.",
      "ja": "レポートノードが選択したアルゴリズムを変更できるように、反応ノードを準備する必要があります。これは、レポートノードがアクティブな過負荷レポートを送信した場合を含め、いつでも発生する可能性があります。反応ノードは、過負荷のレポートノードに送信されるアドバタイズされた削減アルゴリズムを現在選択されているアルゴリズムと損失（または現在選択されているアルゴリズムの場合は損失）に変更することで、変更の可能性を最小限に抑えることができます。これには、現在選択されているアルゴリズムから損失への軽減アルゴリズムの潜在的な変更を制限する効果があり、適切に動作するために状態を必要とするより複雑な軽減アルゴリズムへの変更を回避します。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Reporting Node Behavior",
      "section_title": true,
      "ja": "5.1.2. ノードの動作の報告"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a request message, a reporting node determines if there is a reacting node for the transaction based on the presence of the OC-Supported-Features AVP in the request message.",
      "ja": "要求メッセージを受信すると、レポートノードは、要求メッセージ内のOC-Supported-Features AVPの存在に基づいて、トランザクションに反応するノードがあるかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "If the request message contains an OC-Supported-Features AVP, then a reporting node MUST include the OC-Supported-Features AVP in the answer message for that transaction.",
      "ja": "リクエストメッセージにOC-Supported-Features AVPが含まれている場合、レポートノードはそのトランザクションの応答メッセージにOC-Supported-Features AVPを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: Capability announcement is done on a per-transaction basis. The reporting node cannot assume that the capabilities announced by a reacting node will be the same between transactions.",
      "ja": "注：機能の発表はトランザクションごとに行われます。レポートノードは、応答ノードによってアナウンスされる機能がトランザクション間で同じであるとは想定できません。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST NOT include the OC-Supported-Features AVP, OC-OLR AVP, or any other overload control AVPs defined in extension documents in response messages for transactions where the request message does not include the OC-Supported-Features AVP. Lack of the OC-Supported-Features AVP in the request message indicates that there is no reacting node for the transaction.",
      "ja": "レポートノードは、リクエストメッセージにOC-Supported-Features AVPが含まれていないトランザクションの応答メッセージに、OC-Supported-Features AVP、OC-OLR AVP、または拡張ドキュメントで定義されているその他の過負荷制御AVPを含めてはなりません（MUST NOT）。リクエストメッセージにOC-Supported-Features AVPがない場合は、トランザクションに反応するノードがないことを示しています。"
    },
    {
      "indent": 3,
      "text": "A reporting node knows what overload control functionality is supported by the reacting node based on the content or absence of the OC-Feature-Vector AVP within the OC-Supported-Features AVP in the request message.",
      "ja": "レポートノードは、要求メッセージのOC-Supported-Features AVP内のOC-Feature-Vector AVPの内容または不在に基づいて、対応するノードによってサポートされる過負荷制御機能を認識しています。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST select a single abatement algorithm in the OC-Feature-Vector AVP. The abatement algorithm selected MUST indicate the abatement algorithm the reporting node wants the reacting node to use when the reporting node enters an overload condition.",
      "ja": "レポートノードは、OC-Feature-Vector AVPで単一の軽減アルゴリズムを選択する必要があります。選択された削減アルゴリズムは、レポートノードが過負荷状態になったときに、レポートノードが対応ノードに使用してほしい削減アルゴリズムを示している必要があります。"
    },
    {
      "indent": 3,
      "text": "The abatement algorithm selected MUST be from the set of abatement algorithms contained in the request message's OC-Feature-Vector AVP.",
      "ja": "選択された削減アルゴリズムは、リクエストメッセージのOC-Feature-Vector AVPに含まれている一連の削減アルゴリズムからのものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A reporting node that selects the loss algorithm may do so by including the OC-Feature-Vector AVP with an explicit indication of the loss algorithm, or it MAY omit the OC-Feature-Vector AVP. If it selects a different algorithm, it MUST include the OC-Feature-Vector AVP with an explicit indication of the selected algorithm.",
      "ja": "損失アルゴリズムを選択するレポートノードは、OC-Feature-Vector AVPに損失アルゴリズムの明示的な表示を含めることでそうすることができます。または、OC-Feature-Vector AVPを省略してもよいです。別のアルゴリズムを選択する場合は、選択したアルゴリズムを明示的に示すOC-Feature-Vector AVPを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The reporting node SHOULD indicate support for other DOIC features defined in extension documents that it supports and that apply to the transaction. It does so using the OC-Feature-Vector AVP.",
      "ja": "レポートノードは、サポートするトランザクションに適用される拡張ドキュメントで定義されている他のDOIC機能のサポートを示す必要があります（SHOULD）。これは、OC-Feature-Vector AVPを使用して行われます。"
    },
    {
      "indent": 6,
      "text": "Note: Not all DOIC features will apply to all Diameter applications or deployment scenarios. The features included in the OC-Feature-Vector AVP are based on local policy of the reporting node.",
      "ja": "注：すべてのDOIC機能がすべてのDiameterアプリケーションまたはデプロイメントシナリオに適用されるわけではありません。 OC-Feature-Vector AVPに含まれる機能は、レポートノードのローカルポリシーに基づいています。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Agent Behavior",
      "section_title": true,
      "ja": "5.1.3. エージェントの動作"
    },
    {
      "indent": 3,
      "text": "Diameter Agents that support DOIC can ensure that all messages relayed by the agent contain the OC-Supported-Features AVP.",
      "ja": "DOICをサポートするDiameterエージェントは、エージェントによってリレーされるすべてのメッセージにOC-Supported-Features AVPが含まれていることを確認できます。"
    },
    {
      "indent": 3,
      "text": "A Diameter Agent MAY take on reacting node behavior for Diameter endpoints that do not support the DOIC solution. A Diameter Agent detects that a Diameter endpoint does not support DOIC reacting node behavior when there is no OC-Supported-Features AVP in a request message.",
      "ja": "Diameterエージェントは、DOICソリューションをサポートしていないDiameterエンドポイントの反応ノードの動作を行う場合があります。 Diameterエージェントは、リクエストメッセージにOC-Supported-Features AVPがない場合、DiameterエンドポイントがDOIC反応ノードの動作をサポートしないことを検出します。"
    },
    {
      "indent": 3,
      "text": "For a Diameter Agent to be a reacting node for a non-supporting Diameter endpoint, the Diameter Agent MUST include the OC-Supported-Features AVP in request messages it relays that do not contain the OC-Supported-Features AVP.",
      "ja": "Diameterエージェントが、サポートされていないDiameterエンドポイントの反応ノードになるには、DiameterエージェントがOC-Supported-Features AVPを含まないリレーするリクエストメッセージにOC-Supported-Features AVPを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "A Diameter Agent MAY take on reporting node behavior for Diameter endpoints that do not support the DOIC solution. The Diameter Agent MUST have visibility to all traffic destined for the non-supporting host in order to become the reporting node for the Diameter endpoint. A Diameter Agent detects that a Diameter endpoint does not support DOIC reporting node behavior when there is no OC-Supported-Features AVP in an answer message for a transaction that contained the OC-Supported-Features AVP in the request message.",
      "ja": "Diameterエージェントは、DOICソリューションをサポートしないDiameterエンドポイントのノード動作を報告する場合があります。 Diameterエージェントは、Diameterエンドポイントのレポートノードになるために、サポートされていないホストを宛先とするすべてのトラフィックを可視化する必要があります。 Diameterエージェントは、リクエストメッセージにOC-Supported-Features AVPを含むトランザクションの応答メッセージにOC-Supported-Features AVPがない場合、DiameterエンドポイントがDOICレポートノードの動作をサポートしないことを検出します。"
    },
    {
      "indent": 3,
      "text": "If a request already has the OC-Supported-Features AVP, a Diameter Agent MAY modify it to reflect the features appropriate for the transaction. Otherwise, the agent relays the OC-Supported-Features AVP without change.",
      "ja": "リクエストにすでにOC-Supported-Features AVPが含まれている場合、Diameterエージェントは、トランザクションに適切な機能を反映するように変更する場合があります。それ以外の場合、エージェントはOC-Supported-Features AVPを変更せずにリレーします。"
    },
    {
      "indent": 6,
      "text": "Example: If the agent supports a superset of the features reported by the reacting node, then the agent might choose, based on local policy, to advertise that superset of features to the reporting node.",
      "ja": "例：エージェントが反応ノードから報告された機能のスーパーセットをサポートしている場合、エージェントはローカルポリシーに基づいて、その機能のスーパーセットをレポートノードにアドバタイズすることを選択できます。"
    },
    {
      "indent": 3,
      "text": "If the Diameter Agent changes the OC-Supported-Features AVP in a request message, then it is likely it will also need to modify the OC-Supported-Features AVP in the answer message for the transaction. A Diameter Agent MAY modify the OC-Supported-Features AVP carried in answer messages.",
      "ja": "DiameterエージェントがリクエストメッセージのOC-Supported-Features AVPを変更する場合、トランザクションの応答メッセージのOC-Supported-Features AVPも変更する必要がある可能性があります。 Diameterエージェントは、応答メッセージで運ばれるOC-Supported-Features AVPを変更する場合があります。"
    },
    {
      "indent": 3,
      "text": "When making changes to the OC-Supported-Features or OC-OLR AVPs, the Diameter Agent needs to ensure consistency in its behavior with both upstream and downstream DOIC nodes.",
      "ja": "OC-Supported-FeaturesまたはOC-OLR AVPに変更を加える場合、Diameterエージェントは、上流と下流の両方のDOICノードとの動作の一貫性を確保する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Overload Report Processing",
      "section_title": true,
      "ja": "5.2. 過負荷レポート処理"
    },
    {
      "indent": 0,
      "text": "5.2.1. Overload Control State",
      "section_title": true,
      "ja": "5.2.1. 過負荷制御状態"
    },
    {
      "indent": 3,
      "text": "Both reacting and reporting nodes maintain Overload Control State (OCS) for active overload conditions. The following sections define behavior associated with that OCS.",
      "ja": "反応ノードとレポートノードはどちらも、アクティブな過負荷状態に対して過負荷制御状態（OCS）を維持します。次のセクションでは、そのOCSに関連する動作を定義します。"
    },
    {
      "indent": 3,
      "text": "The contents of the OCS in the reporting node and in the reacting node represent logical constructs. The actual internal physical structure of the state included in the OCS is an implementation decision.",
      "ja": "レポートノードと反応ノードのOCSの内容は、論理構造を表します。 OCSに含まれる状態の実際の内部物理構造は、実装の決定です。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Overload Control State for Reacting Nodes",
      "section_title": true,
      "ja": "5.2.1.1. 反応ノードの過負荷制御状態"
    },
    {
      "indent": 3,
      "text": "A reacting node maintains the following OCS per supported Diameter application:",
      "ja": "反応ノードは、サポートされているDiameterアプリケーションごとに次のOCSを維持します。"
    },
    {
      "indent": 3,
      "text": "o a host-type OCS entry for each Destination-Host to which it sends host-type requests and",
      "ja": "o ホストタイプのリクエストを送信する宛先ホストごとのホストタイプのOCSエントリ"
    },
    {
      "indent": 3,
      "text": "o a realm-type OCS entry for each Destination-Realm to which it sends realm-type requests.",
      "ja": "o レルムタイプのリクエストを送信する宛先レルムごとのレルムタイプのOCSエントリ。"
    },
    {
      "indent": 3,
      "text": "A host-type OCS entry is identified by the pair of Application-ID and the node's DiameterIdentity.",
      "ja": "ホストタイプのOCSエントリは、Application-IDとノードのDiameterIdentityのペアで識別されます。"
    },
    {
      "indent": 3,
      "text": "A realm-type OCS entry is identified by the pair of Application-ID and realm.",
      "ja": "レルムタイプのOCSエントリは、アプリケーションIDとレルムのペアで識別されます。"
    },
    {
      "indent": 3,
      "text": "The host-type and realm-type OCS entries include the following information (the actual information stored is an implementation decision):",
      "ja": "ホストタイプおよびレルムタイプのOCSエントリには、次の情報が含まれます（格納される実際の情報は実装の決定です）。"
    },
    {
      "indent": 3,
      "text": "o Sequence number (as received in OC-OLR; see Section 7.3)",
      "ja": "o シーケンス番号（OC-OLRで受け取ったとおり。7.3を参照）"
    },
    {
      "indent": 3,
      "text": "o Time of expiry (derived from OC-Validity-Duration AVP received in the OC-OLR AVP and time of reception of the message carrying OC-OLR AVP)",
      "ja": "o 有効期限（OC-OLR AVPで受信されたOC-Validity-Duration AVPおよびOC-OLR AVPを伝送するメッセージの受信時間から派生）"
    },
    {
      "indent": 3,
      "text": "o Selected abatement algorithm (as received in the OC-Supported-Features AVP)",
      "ja": "o 選択された削減アルゴリズム（OC-Supported-Features AVPで受信）"
    },
    {
      "indent": 3,
      "text": "o Input data that is abatement algorithm specific (as received in the OC-OLR AVP -- for example, OC-Reduction-Percentage for the loss abatement algorithm)",
      "ja": "o 軽減アルゴリズムに固有の入力データ（OC-OLR AVPで受信されたもの-損失軽減アルゴリズムのOC-Reduction-Percentageなど）"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Overload Control State for Reporting Nodes",
      "section_title": true,
      "ja": "5.2.1.2. レポートノードの過負荷制御状態"
    },
    {
      "indent": 3,
      "text": "A reporting node maintains OCS entries per supported Diameter application, per supported (and eventually selected) abatement algorithm, and per report type.",
      "ja": "レポートノードは、サポートされているDiameterアプリケーションごと、サポートされている（最終的に選択された）削減アルゴリズムごと、およびレポートタイプごとにOCSエントリを維持します。"
    },
    {
      "indent": 3,
      "text": "An OCS entry is identified by the tuple of Application-ID, report type, and abatement algorithm, and it includes the following information (the actual information stored is an implementation decision):",
      "ja": "OCSエントリは、アプリケーションID、レポートタイプ、および軽減アルゴリズムのタプルによって識別され、次の情報が含まれます（格納される実際の情報は実装の決定です）。"
    },
    {
      "indent": 3,
      "text": "o Sequence number",
      "ja": "o シーケンス番号"
    },
    {
      "indent": 0,
      "text": " o Validity duration o Expiration time",
      "ja": "o有効期間o有効期限"
    },
    {
      "indent": 3,
      "text": "o Input data that is algorithm specific (for example, the reduction percentage for the loss abatement algorithm)",
      "ja": "o アルゴリズム固有の入力データ（たとえば、損失軽減アルゴリズムの削減率）"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. Reacting Node's Maintenance of Overload Control State",
      "section_title": true,
      "ja": "5.2.1.3. 反応ノードの過負荷制御状態の維持"
    },
    {
      "indent": 3,
      "text": "When a reacting node receives an OC-OLR AVP, it MUST determine if it is for an existing or new overload condition.",
      "ja": "反応するノードがOC-OLR AVPを受信すると、それが既存の過負荷状態か新しい過負荷状態かを判断しなければなりません（MUST）。"
    },
    {
      "indent": 6,
      "text": "Note: For the remainder of this section, the term \"OLR\" refers to the combination of the contents of the received OC-OLR AVP and the abatement algorithm indicated in the received OC-Supported-Features AVP.",
      "ja": "注：このセクションの残りの部分では、「OLR」という用語は、受信したOC-OLR AVPの内容と、受信したOC-Supported-Features AVPに示されている削減アルゴリズムの組み合わせを指します。"
    },
    {
      "indent": 3,
      "text": "When receiving an answer message with multiple OLRs of different supported report types, a reacting node MUST process each received OLR.",
      "ja": "サポートされている異なるレポートタイプの複数のOLRを含む応答メッセージを受信する場合、応答ノードは受信した各OLRを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "The OLR is for an existing overload condition if a reacting node has an OCS that matches the received OLR.",
      "ja": "OLRは、対応するノードに受信したOLRと一致するOCSがある場合、既存の過負荷状態用です。"
    },
    {
      "indent": 3,
      "text": "For a host report, this means it matches the Application-ID and the host's DiameterIdentity in an existing host OCS entry.",
      "ja": "ホストレポートの場合、これは、既存のホストOCSエントリのApplication-IDおよびホストのDiameterIdentityと一致することを意味します。"
    },
    {
      "indent": 3,
      "text": "For a realm report, this means it matches the Application-ID and the realm in an existing realm OCS entry.",
      "ja": "レルムレポートの場合、これは、既存のレルムOCSエントリのアプリケーションIDおよびレルムと一致することを意味します。"
    },
    {
      "indent": 3,
      "text": "If the OLR is for an existing overload condition, then a reacting node MUST determine if the OLR is a retransmission or an update to the existing OLR.",
      "ja": "OLRが既存の過負荷状態に対するものである場合、反応するノードは、OLRが既存のOLRの再送信であるか更新であるかを決定しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "If the sequence number for the received OLR is greater than the sequence number stored in the matching OCS entry, then a reacting node MUST update the matching OCS entry.",
      "ja": "受信したOLRのシーケンス番号が一致するOCSエントリに格納されているシーケンス番号より大きい場合、反応するノードは一致するOCSエントリを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the sequence number for the received OLR is less than or equal to the sequence number in the matching OCS entry, then a reacting node MUST silently ignore the received OLR. The matching OCS MUST NOT be updated in this case.",
      "ja": "受信したOLRのシーケンス番号が一致するOCSエントリのシーケンス番号以下である場合、反応するノードは受信したOLRを黙って無視しなければなりません（MUST）。この場合、一致するOCSを更新してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the reacting node determines that the sequence number has rolled over, then the reacting node MUST update the matching OCS entry. This can be determined by recognizing that the number has changed from a value within 1% of the maximum value in the OC-Sequence-Number AVP to a value within 1% of the minimum value in the OC-Sequence-Number AVP.",
      "ja": "反応ノードがシーケンス番号がロールオーバーしたと判断した場合、反応ノードは一致するOCSエントリを更新する必要があります。これは、OC-Sequence-Number AVPの最大値の1％以内の値から、OC-Sequence-Number AVPの最小値の1％以内の値に数値が変化したことを認識することで判断できます。"
    },
    {
      "indent": 3,
      "text": "If the received OLR is for a new overload condition, then a reacting node MUST generate a new OCS entry for the overload condition.",
      "ja": "受信したOLRが新しい過負荷状態用である場合、反応するノードは過負荷状態用の新しいOCSエントリを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "For a host report, this means a reacting node creates an OCS entry with the Application-ID in the received message and DiameterIdentity of the Origin-Host in the received message.",
      "ja": "ホストレポートの場合、これは、対応するノードが、受信したメッセージのApplication-IDと、受信したメッセージのOrigin-HostのDiameterIdentityを使用してOCSエントリを作成することを意味します。"
    },
    {
      "indent": 6,
      "text": "Note: This solution assumes that the Origin-Host AVP in the answer message included by the reporting node is not changed along the path to the reacting node.",
      "ja": "注：このソリューションでは、レポートノードに含まれる応答メッセージのOrigin-Host AVPが、対応するノードへのパスに沿って変更されていないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "For a realm report, this means a reacting node creates an OCS entry with the Application-ID in the received message and realm of the Origin-Realm in the received message.",
      "ja": "レルムレポートの場合、これは、対応するノードが、受信したメッセージ内のアプリケーションIDと、受信したメッセージ内の発信元レルムのレルムを持つOCSエントリを作成することを意味します。"
    },
    {
      "indent": 3,
      "text": "If the received OLR contains a validity duration of zero (\"0\"), then a reacting node MUST update the OCS entry as being expired.",
      "ja": "受信したOLRにゼロ（ \"0\"）の有効期間が含まれている場合、応答するノードはOCSエントリを期限切れとして更新する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: It is not necessarily appropriate to delete the OCS entry, as the recommended behavior is that the reacting node slowly returns to full traffic when ending an overload abatement period.",
      "ja": "注：OCSエントリを削除することは必ずしも適切ではありません。推奨される動作は、過負荷軽減期間が終了すると、反応するノードがゆっくりとフルトラフィックに戻ることです。"
    },
    {
      "indent": 3,
      "text": "The reacting node does not delete an OCS when receiving an answer message that does not contain an OC-OLR AVP (i.e., absence of OLR means \"no change\").",
      "ja": "OC-OLR AVPを含まない応答メッセージを受信して​​も、反応するノードはOCSを削除しません（つまり、OLRがないと「変更なし」を意味します）。"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. Reporting Node's Maintenance of Overload Control State",
      "section_title": true,
      "ja": "5.2.1.4. ノードの過負荷制御状態のメンテナンスの報告"
    },
    {
      "indent": 3,
      "text": "A reporting node SHOULD create a new OCS entry when entering an overload condition.",
      "ja": "レポートノードは、過負荷状態になったときに新しいOCSエントリを作成する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "Note: If a reporting node knows through absence of the OC-Supported-Features AVP in received messages that there are no reacting nodes supporting DOIC, then the reporting node can choose to not create OCS entries.",
      "ja": "注：受信メッセージにOC-Supported-Features AVPがないことを介して、レポートノードがDOICをサポートする反応ノードがないことを知っている場合、レポートノードはOCSエントリを作成しないことを選択できます。"
    },
    {
      "indent": 3,
      "text": "When generating a new OCS entry, the sequence number SHOULD be set to zero (\"0\").",
      "ja": "新しいOCSエントリを生成するときは、シーケンス番号をゼロ（ \"0\"）に設定する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "When generating sequence numbers for new overload conditions, the new sequence number MUST be greater than any sequence number in an active (unexpired) overload report for the same application and report type previously sent by the reporting node. This property MUST hold over a reboot of the reporting node.",
      "ja": "新しいオーバーロード状態のシーケンス番号を生成する場合、新しいシーケンス番号は、以前にレポートノードによって送信された同じアプリケーションおよびレポートタイプのアクティブな（期限切れでない）オーバーロードレポートのシーケンス番号よりも大きい必要があります。このプロパティは、レポートノードの再起動を保持する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: One way of addressing this over a reboot of a reporting node is to use a timestamp for the first overload condition that occurs after the report and to start using sequences beginning with zero for subsequent overload conditions.",
      "ja": "注：レポートノードの再起動時にこれに対処する1つの方法は、レポート後に発生する最初の過負荷状態にタイムスタンプを使用し、後続の過負荷状態に対してゼロで始まるシーケンスの使用を開始することです。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST update an OCS entry when it needs to adjust the validity duration of the overload condition at reacting nodes.",
      "ja": "レポートノードは、反応するノードで過負荷状態の有効期間を調整する必要がある場合、OCSエントリを更新する必要があります。"
    },
    {
      "indent": 6,
      "text": "Example: If a reporting node wishes to instruct reacting nodes to continue overload abatement for a longer period of time than originally communicated. This also applies if the reporting node wishes to shorten the period of time that overload abatement is to continue.",
      "ja": "例：レポートノードが、最初に通信された時間よりも長い時間過負荷軽減を継続するように反応ノードに指示したい場合。これは、報告ノードが過負荷軽減を継続する期間を短縮したい場合にも適用されます。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST update an OCS entry when it wishes to adjust any parameters specific to the abatement algorithm, including, for example, the reduction percentage used for the loss abatement algorithm.",
      "ja": "レポートノードは、たとえば、損失軽減アルゴリズムに使用される削減率など、軽減アルゴリズムに固有のパラメーターを調整する必要がある場合、OCSエントリを更新する必要があります。"
    },
    {
      "indent": 6,
      "text": "Example: If a reporting node wishes to change the reduction percentage either higher (if the overload condition has worsened) or lower (if the overload condition has improved), then the reporting node would update the appropriate OCS entry.",
      "ja": "例：レポートノードが削減パーセンテージをより高く（過負荷状態が悪化した場合）または低く（過負荷状態が改善した場合）変更したい場合、レポートノードは適切なOCSエントリを更新します。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST increment the sequence number associated with the OCS entry anytime the contents of the OCS entry are changed. This will result in a new sequence number being sent to reacting nodes, instructing them to process the OC-OLR AVP.",
      "ja": "レポートノードは、OCSエントリの内容が変更されるたびに、OCSエントリに関連付けられたシーケンス番号をインクリメントする必要があります。これにより、対応するノードに新しいシーケンス番号が送信され、OC-OLR AVPを処理するように指示されます。"
    },
    {
      "indent": 3,
      "text": "A reporting node SHOULD update an OCS entry with a validity duration of zero (\"0\") when the overload condition ends.",
      "ja": "レポートノードは、過負荷状態が終了すると、有効期間がゼロ（ \"0\"）のOCSエントリを更新する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "Note: If a reporting node knows that the OCS entries in the reacting nodes are near expiration, then the reporting node might decide not to send an OLR with a validity duration of zero.",
      "ja": "注：対応するノードのOCSエントリの有効期限が近づいていることをレポートノードが知っている場合、レポートノードは有効期間がゼロのOLRを送信しないことを決定する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST keep an OCS entry with a validity duration of zero (\"0\") for a period of time long enough to ensure that any unexpired reacting node's OCS entry created as a result of the overload condition in the reporting node is deleted.",
      "ja": "レポートノードは、有効期間がゼロ（ \"0\"）のOCSエントリを、レポートノードの過負荷状態の結果として作成された、期限切れでない対応ノードのOCSエントリが確実に削除されるのに十分な期間保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Reacting Node Behavior",
      "section_title": true,
      "ja": "5.2.2. 反応ノードの動作"
    },
    {
      "indent": 3,
      "text": "When a reacting node sends a request, it MUST determine if that request matches an active OCS.",
      "ja": "反応するノードがリクエストを送るとき、それはそのリクエストがアクティブなOCSと一致するかどうかを決定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the request matches an active OCS, then the reacting node MUST use the overload abatement algorithm indicated in the OCS to determine if the request is to receive overload abatement treatment.",
      "ja": "要求がアクティブなOCSと一致する場合、反応するノードはOCSに示されている過負荷軽減アルゴリズムを使用して、要求が過負荷軽減処理を受け取るかどうかを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the loss abatement algorithm defined in this specification, see Section 6 for the overload abatement algorithm logic applied.",
      "ja": "この仕様で定義されている損失軽減アルゴリズムについては、適用される過負荷軽減アルゴリズムロジックについてセクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the overload abatement algorithm selects the request for overload abatement treatment, then the reacting node MUST apply overload abatement treatment on the request. The abatement treatment applied depends on the context of the request.",
      "ja": "過負荷軽減アルゴリズムが過負荷軽減処理のリクエストを選択した場合、反応するノードはリクエストに過負荷軽減処理を適用する必要があります。適用される削減処理は、リクエストのコンテキストによって異なります。"
    },
    {
      "indent": 3,
      "text": "If diversion abatement treatment is possible (i.e., a different path for the request can be selected where the overloaded node is not part of the different path), then the reacting node SHOULD apply diversion abatement treatment to the request. The reacting node MUST apply throttling abatement treatment to requests identified for abatement treatment when diversion treatment is not possible or was not applied.",
      "ja": "迂回削減処理が可能である場合（つまり、過負荷のノードが異なるパスの一部ではない場合に、要求の異なるパスを選択できます）、反応するノードは迂回削減処理を要求に適用する必要があります（SHOULD）。反応ノードは、迂回処理が不可能な場合、または適用されなかった場合に、軽減処理のために識別された要求にスロットル軽減処理を適用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: This only addresses the case where there are two defined abatement treatments, diversion and throttling. Any extension that defines a new abatement treatment must also define its interaction with existing treatments.",
      "ja": "注：これは、迂回とスロットルの2つの定義された削減処理がある場合にのみ対応しています。新しい削減処理を定義する拡張機能は、既存の処理との相互作用も定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the overload abatement treatment results in throttling of the request and if the reacting node is an agent, then the agent MUST send an appropriate error as defined in Section 8.",
      "ja": "過負荷軽減処理によりリクエストが抑制され、反応するノードがエージェントである場合、エージェントはセクション8で定義されている適切なエラーを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Diameter endpoints that throttle requests need to do so according to the rules of the client application. Those rules will vary by application and are beyond the scope of this document.",
      "ja": "要求を調整するDiameterエンドポイントは、クライアントアプリケーションのルールに従ってそうする必要があります。これらのルールはアプリケーションによって異なり、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "In the case that the OCS entry indicated no traffic was to be sent to the overloaded entity and the validity duration expires, then overload abatement associated with the overload report MUST be ended in a controlled fashion.",
      "ja": "OCSエントリが過負荷エンティティに送信されるトラフィックがないことを示し、有効期間が満了した場合、過負荷レポートに関連付けられた過負荷軽減は制御された方法で終了しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Reporting Node Behavior",
      "section_title": true,
      "ja": "5.2.3. ノードの動作の報告"
    },
    {
      "indent": 3,
      "text": "If there is an active OCS entry, then a reporting node SHOULD include the OC-OLR AVP in all answers to requests that contain the OC-Supported-Features AVP and that match the active OCS entry.",
      "ja": "アクティブなOCSエントリがある場合、レポートノードは、OC-Supported-Features AVPを含み、アクティブなOCSエントリに一致するリクエストへのすべての回答にOC-OLR AVPを含める必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "Note: A request matches 1) if the Application-ID in the request matches the Application-ID in any active OCS entry and 2) if the report type in the OCS entry matches a report type supported by the reporting node as indicated in the OC-Supported-Features AVP.",
      "ja": "注：リクエストは、1）リクエストのApplication-IDがアクティブなOCSエントリのApplication-IDと一致する場合、および2）OCSエントリのレポートタイプが、OCに示されているレポートノードでサポートされているレポートタイプと一致する場合に一致します。 -サポートされている機能AVP。"
    },
    {
      "indent": 3,
      "text": "The contents of the OC-OLR AVP depend on the selected algorithm.",
      "ja": "OC-OLR AVPの内容は、選択したアルゴリズムによって異なります。"
    },
    {
      "indent": 3,
      "text": "A reporting node MAY choose to not resend an overload report to a reacting node if it can guarantee that this overload report is already active in the reacting node.",
      "ja": "レポートノードは、過負荷レポートが反応ノードで既にアクティブであることを保証できる場合、反応ノードに過負荷レポートを再送信しないことを選択できます（MAY）。"
    },
    {
      "indent": 6,
      "text": "Note: In some cases (e.g., when there are one or more agents in the path between reporting and reacting nodes, or when overload reports are discarded by reacting nodes), a reporting node may not be able to guarantee that the reacting node has received the report.",
      "ja": "注：場合によっては（たとえば、レポートノードと対応ノード間のパスに1つ以上のエージェントが存在する場合、または過負荷レポートが対応ノードによって破棄される場合）、レポートノードは、対応ノードが受信したことを保証できない場合があります。レポート。"
    },
    {
      "indent": 3,
      "text": "A reporting node MUST NOT send overload reports of a type that has not been advertised as supported by the reacting node.",
      "ja": "レポートノードは、対応するノードによってサポートされているとアドバタイズされていないタイプの過負荷レポートを送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "Note: A reacting node implicitly advertises support for the host and realm report types by including the OC-Supported-Features AVP in the request. Support for other report types will be explicitly indicated by new feature bits in the OC-Feature-Vector AVP.",
      "ja": "注：反応ノードは、リクエストにOC-Supported-Features AVPを含めることにより、ホストおよびレルムレポートタイプのサポートを暗黙的にアドバタイズします。他のレポートタイプのサポートは、OC-Feature-Vector AVPの新しい機能ビットによって明示的に示されます。"
    },
    {
      "indent": 3,
      "text": "A reporting node SHOULD explicitly indicate the end of an overload occurrence by sending a new OLR with OC-Validity-Duration set to a value of zero (\"0\"). The reporting node SHOULD ensure that all reacting nodes receive the updated overload report.",
      "ja": "レポートノードは、OC-Validity-Durationの値をゼロ（ \"0\"）に設定して新しいOLRを送信することにより、過負荷発生の終わりを明示的に示す必要があります（SHOULD）。レポートノードは、すべての反応ノードが更新された過負荷レポートを受信することを保証する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A reporting node MAY rely on the OC-Validity-Duration AVP values for the implicit cleanup of overload control state on the reacting node.",
      "ja": "レポートノードは、OC-Validity-Duration AVP値に依存して、対応するノードの過負荷制御状態の暗黙的なクリーンアップを行うことができます。"
    },
    {
      "indent": 6,
      "text": "Note: All OLRs sent have an expiration time calculated by adding the validity duration contained in the OLR to the time the message was sent. Transit time for the OLR can be safely ignored. The reporting node can ensure that all reacting nodes have received the OLR by continuing to send it in answer messages until the expiration time for all OLRs sent for that overload condition have expired.",
      "ja": "注：送信されるすべてのOLRには、OLRに含まれる有効期間をメッセージの送信時刻に追加することによって計算される有効期限があります。 OLRの通過時間は無視しても問題ありません。レポートノードは、その過負荷状態に対して送信されたすべてのOLRの有効期限が切れるまで応答メッセージで送信し続けることにより、すべての反応ノードがOLRを受信したことを確認できます。"
    },
    {
      "indent": 3,
      "text": "When a reporting node sends an OLR, it effectively delegates any necessary throttling to downstream nodes. If the reporting node also locally throttles the same set of messages, the overall number of throttled requests may be higher than intended. Therefore, before applying local message throttling, a reporting node needs to check if these messages match existing OCS entries, indicating that these messages have survived throttling applied by downstream nodes that have received the related OLR.",
      "ja": "レポートノードがOLRを送信すると、必要なスロットルを効果的にダウンストリームノードに委任します。レポートノードも同じメッセージのセットをローカルでスロットルする場合、スロットルされるリクエストの総数は意図した数よりも多くなる可能性があります。したがって、ローカルメッセージスロットリングを適用する前に、レポートノードはこれらのメッセージが既存のOCSエントリと一致するかどうかを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": " However, even if the set of messages match existing OCS entries, the reporting node can still apply other abatement methods such as diversion. The reporting node might also need to throttle requests for reasons other than overload. For example, an agent or server might have a configured rate limit for each client and might throttle requests that exceed that limit, even if such requests had already been candidates for throttling by downstream nodes. The reporting node also has the option to send new OLRs requesting greater reductions in traffic, reducing the need for local throttling.",
      "ja": "ただし、メッセージのセットが既存のOCSエントリと一致する場合でも、レポートノードは宛先変更などの他の削減方法を適用できます。レポートノードは、過負荷以外の理由で要求を調整する必要がある場合もあります。たとえば、エージェントまたはサーバーでは、クライアントごとに構成されたレート制限があり、その制限を超えた要求が既にダウンストリームノードによるスロットルの候補であったとしても、その制限を超える可能性があります。レポートノードには、トラフィックの大幅な削減を要求する新しいOLRを送信して、ローカルスロットリングの必要性を減らすオプションもあります。"
    },
    {
      "indent": 3,
      "text": "A reporting node SHOULD decrease requested overload abatement treatment in a controlled fashion to avoid oscillations in traffic.",
      "ja": "レポートノードは、トラフィックの変動を回避するために、制御された方法で要求された過負荷軽減処理を減らす必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "Example: A reporting node might wait some period of time after overload ends before terminating the OLR, or it might send a series of OLRs indicating progressively less overload severity.",
      "ja": "例：レポートノードは、過負荷が終了してからOLRを終了するまでしばらく待機するか、過負荷の重大度が徐々に低下することを示す一連のOLRを送信する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Protocol Extensibility",
      "section_title": true,
      "ja": "5.3. プロトコルの拡張性"
    },
    {
      "indent": 3,
      "text": "The DOIC solution can be extended. Types of potential extensions include new traffic abatement algorithms, new report types, or other new functionality.",
      "ja": "DOICソリューションは拡張できます。潜在的な拡張機能のタイプには、新しいトラフィック削減アルゴリズム、新しいレポートタイプ、またはその他の新しい機能が含まれます。"
    },
    {
      "indent": 3,
      "text": "When defining a new extension that requires new normative behavior, the specification must define a new feature for the OC-Feature-Vector AVP. This feature bit is used to communicate support for the new feature.",
      "ja": "新しい規範的な動作を必要とする新しい拡張機能を定義する場合、仕様はOC-Feature-Vector AVPの新しい機能を定義する必要があります。この機能ビットは、新機能のサポートを伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "The extension may define new AVPs for use in the DOIC Capability Announcement and for use in DOIC overload reporting. These new AVPs SHOULD be defined to be extensions to the OC-Supported-Features or OC-OLR AVPs defined in this document.",
      "ja": "拡張機能は、DOIC機能アナウンスで使用するため、およびDOIC過負荷レポートで使用するための新しいAVPを定義する場合があります。これらの新しいAVPは、このドキュメントで定義されているOC-Supported-FeaturesまたはOC-OLR AVPの拡張として定義する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The Grouped AVP extension mechanisms defined in [RFC6733] apply. This allows, for example, defining a new feature that is mandatory to be understood even when piggybacked on an existing application.",
      "ja": "[RFC6733]で定義されているグループ化されたAVP拡張メカニズムが適用されます。これにより、たとえば、既存のアプリケーションに便乗した場合でも理解する必要がある新しい機能を定義できます。"
    },
    {
      "indent": 3,
      "text": "When defining new report type values, the corresponding specification must define the semantics of the new report types and how they affect the OC-OLR AVP handling.",
      "ja": "新しいレポートタイプの値を定義する場合、対応する仕様では、新しいレポートタイプのセマンティクスと、それらがOC-OLR AVP処理にどのように影響するかを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The OC-Supported-Feature and OC-OLR AVPs can be expanded with optional sub-AVPs only if a legacy DOIC implementation can safely ignore them without breaking backward compatibility for the given OC-Report-Type AVP value. Any new sub-AVPs must not require that the M-bit be set.",
      "ja": "OC-Supported-FeatureおよびOC-OLR AVPは、レガシーDOIC実装が指定されたOC-Report-Type AVP値に対する下位互換性を損なうことなくそれらを安全に無視できる場合にのみ、オプションのサブAVPで拡張できます。新しいサブAVPでは、Mビットを設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Documents that introduce new report types must describe any limitations on their use across non-supporting agents.",
      "ja": "新しいレポートタイプを紹介するドキュメントでは、サポートしていないエージェントでの使用に関する制限について説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "As with any Diameter specification, RFC 6733 requires all new AVPs to be registered with IANA. See Section 9 for the required procedures. New features (feature bits in the OC-Feature-Vector AVP) and report types (in the OC-Report-Type AVP) MUST be registered with IANA.",
      "ja": "すべてのDiameter仕様と同様に、RFC 6733では、すべての新しいAVPをIANAに登録する必要があります。必要な手順については、セクション9を参照してください。新しい機能（OC-Feature-Vector AVPの機能ビット）およびレポートタイプ（OC-Report-Type AVP内）は、IANAに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Loss Algorithm",
      "section_title": true,
      "ja": "6. 損失アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section documents the Diameter overload loss abatement algorithm.",
      "ja": "このセクションでは、Diameter過負荷損失軽減アルゴリズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Overview",
      "section_title": true,
      "ja": "6.1. 概観"
    },
    {
      "indent": 3,
      "text": "The DOIC specification supports the ability for multiple overload abatement algorithms to be specified. The abatement algorithm used for any instance of overload is determined by the DOIC Capability Announcement process documented in Section 5.1.",
      "ja": "DOIC仕様は、複数の過負荷軽減アルゴリズムを指定する機能をサポートしています。過負荷のインスタンスに使用される削減アルゴリズムは、セクション5.1に記載されているDOIC機能発表プロセスによって決定されます。"
    },
    {
      "indent": 3,
      "text": "The loss algorithm described in this section is the default algorithm that must be supported by all Diameter nodes that support DOIC.",
      "ja": "このセクションで説明する損失アルゴリズムは、DOICをサポートするすべてのDiameterノードでサポートする必要があるデフォルトのアルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "The loss algorithm is designed to be a straightforward and stateless overload abatement algorithm. It is used by reporting nodes to request a percentage reduction in the amount of traffic sent. The traffic impacted by the requested reduction depends on the type of overload report.",
      "ja": "損失アルゴリズムは、単純でステートレスな過負荷軽減アルゴリズムになるように設計されています。これは、送信されたトラフィック量のパーセンテージ削減を要求するためにレポートノードによって使用されます。要求された削減の影響を受けるトラフィックは、過負荷レポートのタイプによって異なります。"
    },
    {
      "indent": 3,
      "text": "Reporting nodes request the stateless reduction of the number of requests by an indicated percentage. This percentage reduction is in comparison to the number of messages the node otherwise would send, regardless of how many requests the node might have sent in the past.",
      "ja": "レポートノードは、指定されたパーセンテージによるリクエスト数のステートレス削減をリクエストします。この減少率は、ノードが過去に送信した可能性のあるリクエストの数に関係なく、ノードが送信するメッセージの数と比較したものです。"
    },
    {
      "indent": 3,
      "text": "From a conceptual level, the logic at the reacting node could be outlined as follows.",
      "ja": "概念レベルから、反応ノードのロジックは次のように概説できます。"
    },
    {
      "indent": 3,
      "text": "1. An overload report is received, and the associated OCS is either saved or updated (if required) by the reacting node.",
      "ja": "1. 過負荷レポートが受信され、関連するOCSが、対応するノードによって（必要に応じて）保存または更新されます。"
    },
    {
      "indent": 3,
      "text": "2. A new Diameter request is generated by the application running on the reacting node.",
      "ja": "2. 対応するノードで実行されているアプリケーションによって、新しいDiameter要求が生成されます。"
    },
    {
      "indent": 3,
      "text": "3. The reacting node determines that an active overload report applies to the request, as indicated by the corresponding OCS entry.",
      "ja": "3. 対応するOCSエントリによって示されるように、反応するノードはアクティブな過負荷レポートが要求に適用されることを決定します。"
    },
    {
      "indent": 0,
      "text": " 4. The reacting node determines if overload abatement treatment should be applied to the request. One approach that could be taken for each request is to select a uniformly selected random number between 1 and 100. If the random number is less than or equal to the indicated reduction percentage, then the request is given abatement treatment; otherwise, the request is given normal routing treatment.",
      "ja": "4.反応ノードは、過負荷軽減処理を要求に適用する必要があるかどうかを決定します。各要求に対して採用できる1つのアプローチは、1から100の間で一様に選択された乱数を選択することです。乱数が指定された削減率以下の場合、要求は削減処理されます。それ以外の場合、リクエストには通常のルーティング処理が行われます。"
    },
    {
      "indent": 0,
      "text": "6.2. Reporting Node Behavior",
      "section_title": true,
      "ja": "6.2. ノードの動作の報告"
    },
    {
      "indent": 3,
      "text": "The method a reporting node uses to determine the amount of traffic reduction required to address an overload condition is an implementation decision.",
      "ja": "レポートノードが過負荷状態に対処するために必要なトラフィック削減量を決定するために使用する方法は、実装の決定です。"
    },
    {
      "indent": 3,
      "text": "When a reporting node that has selected the loss abatement algorithm determines the need to request a reduction in traffic, it includes an OC-OLR AVP in answer messages as described in Section 5.2.3.",
      "ja": "損失軽減アルゴリズムを選択したレポートノードがトラフィックの削減を要求する必要性を判断すると、セクション5.2.3で説明されているように、応答メッセージにOC-OLR AVPが含まれます。"
    },
    {
      "indent": 3,
      "text": "When sending the OC-OLR AVP, the reporting node MUST indicate a percentage reduction in the OC-Reduction-Percentage AVP.",
      "ja": "OC-OLR AVPを送信するとき、レポートノードはOC-Reduction-Percentage AVPの減少率を示さなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "The reporting node MAY change the reduction percentage in subsequent overload reports. When doing so, the reporting node must conform to overload report handling specified in Section 5.2.3.",
      "ja": "レポートノードは、後続の過負荷レポートの削減率を変更できます（MAY）。その場合、レポートノードは、セクション5.2.3で指定された過負荷レポート処理に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Reacting Node Behavior",
      "section_title": true,
      "ja": "6.3. 反応ノードの動作"
    },
    {
      "indent": 3,
      "text": "The method a reacting node uses to determine which request messages are given abatement treatment is an implementation decision.",
      "ja": "反応ノードがどの要求メッセージに軽減処理が与えられるかを決定するために使用する方法は、実装の決定です。"
    },
    {
      "indent": 3,
      "text": "When receiving an OC-OLR in an answer message where the algorithm indicated in the OC-Supported-Features AVP is the loss algorithm, the reacting node MUST apply abatement treatment to the requested percentage of request messages sent.",
      "ja": "OC-Supported-Features AVPに示されているアルゴリズムが損失アルゴリズムである応答メッセージでOC-OLRを受信する場合、反応するノードは、送信された要求メッセージの要求された割合に軽減処理を適用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: The loss algorithm is a stateless algorithm. As a result, the reacting node does not guarantee that there will be an absolute reduction in traffic sent. Rather, it guarantees that the requested percentage of new requests will be given abatement treatment.",
      "ja": "注：損失アルゴリズムはステートレスアルゴリズムです。その結果、反応するノードは、送信されるトラフィックが完全に減少することを保証しません。むしろ、それは新しい要求の要求されたパーセンテージが軽減処理を与えられることを保証します。"
    },
    {
      "indent": 3,
      "text": "If the reacting node comes out of the 100% traffic reduction (meaning, it has received an OLR indicating that no traffic should be sent, as a result of the overload report timing out), the reacting node sending the traffic SHOULD be conservative and, for example, first send \"probe\" messages to learn the overload condition of the overloaded node before converging to any traffic amount/rate decided by the sender. Similar concerns apply in all cases when the overload report times out, unless the previous overload report stated 0% reduction.",
      "ja": "反応ノードが100％のトラフィック削減から抜け出した場合（つまり、過負荷レポートのタイムアウトの結果として、トラフィックを送信する必要がないことを示すOLRを受信した場合）、トラフィックを送信する反応ノードは保守的である必要があり、たとえば、送信者が決定したトラフィック量/レートに収束する前に、まず「プローブ」メッセージを送信して過負荷ノードの過負荷状態を学習します。以前の過負荷レポートで0％の削減が示されていない限り、過負荷レポートがタイムアウトになった場合も、同様の問題が当てはまります。"
    },
    {
      "indent": 6,
      "text": "Note: The goal of this behavior is to reduce the probability of overload condition thrashing where an immediate transition from 100% reduction to 0% reduction results in the reporting node moving quickly back into an overload condition.",
      "ja": "注：この動作の目標は、過負荷状態のスラッシングの可能性を減らすことです。100％の削減から0％の削減に即座に移行すると、レポートノードが急速に過負荷状態に戻ります。"
    },
    {
      "indent": 0,
      "text": "7. Attribute Value Pairs",
      "section_title": true,
      "ja": "7. 属性値ペア"
    },
    {
      "indent": 3,
      "text": "This section describes the encoding and semantics of the Diameter Overload Indication Attribute Value Pairs (AVPs) defined in this document.",
      "ja": "このセクションでは、このドキュメントで定義されているDiameterオーバーロード表示属性値ペア（AVP）のエンコーディングとセマンティクスについて説明します。"
    },
    {
      "indent": 3,
      "text": "Refer to Section 4 of [RFC6733] for more information on AVPs and AVP data types.",
      "ja": "AVPとAVPデータタイプの詳細については、[RFC6733]のセクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1. OC-Supported-Features AVP",
      "section_title": true,
      "ja": "7.1. OC-Supported-Features AVP"
    },
    {
      "indent": 3,
      "text": "The OC-Supported-Features AVP (AVP Code 621) is of type Grouped and serves two purposes. First, it announces a node's support for the DOIC solution in general. Second, it contains the description of the supported DOIC features of the sending node. The OC-Supported-Features AVP MUST be included in every Diameter request message a DOIC supporting node sends.",
      "ja": "OC-Supported-Features AVP（AVPコード621）はグループ化されたタイプで、2つの目的を果たします。まず、DOICソリューションに対するノードのサポートを一般的に発表します。次に、送信ノードのサポートされているDOIC機能の説明が含まれています。 OC-Supported-Features AVPは、DOICサポートノードが送信するすべてのDiameterリクエストメッセージに含める必要があります。"
    },
    {
      "indent": 6,
      "text": "OC-Supported-Features ::= < AVP Header: 621 >\n                          [ OC-Feature-Vector ]\n                        * [ AVP ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. OC-Feature-Vector AVP",
      "section_title": true,
      "ja": "7.2. OC-Feature-Vector AVP"
    },
    {
      "indent": 3,
      "text": "The OC-Feature-Vector AVP (AVP Code 622) is of type Unsigned64 and contains a 64-bit flags field of announced capabilities of a DOIC node. The value of zero (0) is reserved.",
      "ja": "OC-Feature-Vector AVP（AVPコード622）はUnsigned64タイプで、DOICノードのアナウンスされた機能の64ビットフラグフィールドが含まれています。ゼロ（0）の値は予約されています。"
    },
    {
      "indent": 3,
      "text": "The OC-Feature-Vector sub-AVP is used to announce the DOIC features supported by the DOIC node, in the form of a flag-bits field in which each bit announces one feature or capability supported by the node. The absence of the OC-Feature-Vector AVP in request messages indicates that only the default traffic abatement algorithm described in this specification is supported. The absence of the OC-Feature-Vector AVP in answer messages indicates that the default traffic abatement algorithm described in this specification is selected (while other traffic abatement algorithms may be supported), and no features other than abatement algorithms are supported.",
      "ja": "OC-Feature-VectorサブAVPは、DOICノードでサポートされるDOIC機能をアナウンスするために使用されます。フラグビットフィールドの形式で、各ビットはノードでサポートされる1つの機能または機能をアナウンスします。要求メッセージにOC-Feature-Vector AVPがないことは、この仕様で説明されているデフォルトのトラフィック削減アルゴリズムのみがサポートされていることを示しています。応答メッセージにOC-Feature-Vector AVPがない場合、この仕様で説明されているデフォルトのトラフィック削減アルゴリズムが選択されており（他のトラフィック削減アルゴリズムはサポートされている可能性があります）、削減アルゴリズム以外の機能はサポートされていません。"
    },
    {
      "indent": 3,
      "text": "The following capability is defined in this document:",
      "ja": "このドキュメントでは、次の機能が定義されています。"
    },
    {
      "indent": 3,
      "text": "OLR_DEFAULT_ALGO (0x0000000000000001)",
      "ja": "OLR_DEFAULT_ALGO（0x0000000000000001）"
    },
    {
      "indent": 6,
      "text": "When this flag is set by the a DOIC reacting node, it means that the default traffic abatement (loss) algorithm is supported. When this flag is set by a DOIC reporting node, it means that the loss algorithm will be used for requested overload abatement.",
      "ja": "このフラグがDOIC反応ノードによって設定される場合、デフォルトのトラフィック削減（損失）アルゴリズムがサポートされていることを意味します。このフラグがDOICレポートノードによって設定されている場合、要求された過負荷軽減に損失アルゴリズムが使用されることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.3. OC-OLR AVP",
      "section_title": true,
      "ja": "7.3. OC-OLR AVP"
    },
    {
      "indent": 3,
      "text": "The OC-OLR AVP (AVP Code 623) is of type Grouped and contains the information necessary to convey an overload report on an overload condition at the reporting node. The application the OC-OLR AVP applies to is identified by the Application-ID found in the Diameter message header. The host or realm the OC-OLR AVP concerns is determined from the Origin-Host AVP and/or Origin-Realm AVP found in the encapsulating Diameter command. The OC-OLR AVP is intended to be sent only by a reporting node.",
      "ja": "OC-OLR AVP（AVPコード623）はグループ化されたタイプであり、レポートノードで過負荷状態に関する過負荷レポートを伝達するために必要な情報が含まれています。 OC-OLR AVPが適用されるアプリケーションは、DiameterメッセージヘッダーにあるApplication-IDによって識別されます。 OC-OLR AVPが関係するホストまたはレルムは、カプセル化DiameterコマンドにあるOrigin-Host AVPまたはOrigin-Realm AVPから決定されます。 OC-OLR AVPは、レポートノードのみが送信することを目的としています。"
    },
    {
      "indent": 6,
      "text": "OC-OLR ::= < AVP Header: 623 >\n           < OC-Sequence-Number >\n           < OC-Report-Type >\n           [ OC-Reduction-Percentage ]\n           [ OC-Validity-Duration ]\n         * [ AVP ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4. OC-Sequence-Number AVP",
      "section_title": true,
      "ja": "7.4. OCシーケンス番号AVP"
    },
    {
      "indent": 3,
      "text": "The OC-Sequence-Number AVP (AVP Code 624) is of type Unsigned64. Its usage in the context of overload control is described in Section 5.2.",
      "ja": "OC-Sequence-Number AVP（AVPコード624）のタイプはUnsigned64です。過負荷制御のコンテキストでの使用法については、セクション5.2で説明しています。"
    },
    {
      "indent": 3,
      "text": "From the functionality point of view, the OC-Sequence-Number AVP is used as a nonvolatile increasing counter for a sequence of overload reports between two DOIC nodes for the same overload occurrence. Sequence numbers are treated in a unidirectional manner, i.e., two sequence numbers in each direction between two DOIC nodes are not related or correlated.",
      "ja": "機能の観点から、OC-Sequence-Number AVPは、同じ過負荷発生の2つのDOICノード間の過負荷レポートのシーケンスの不揮発性増加カウンターとして使用されます。シーケンス番号は一方向で処理されます。つまり、2つのDOICノード間の各方向の2つのシーケンス番号は、関連付けられていません。"
    },
    {
      "indent": 0,
      "text": "7.5. OC-Validity-Duration AVP",
      "section_title": true,
      "ja": "7.5. OC-Validity-Duration AVP"
    },
    {
      "indent": 0,
      "text": " The OC-Validity-Duration AVP (AVP Code 625) is of type Unsigned32 and indicates in seconds the validity time of the overload report. The number of seconds is measured after reception of the first OC-OLR AVP with a given value of OC-Sequence-Number AVP. The default value for the OC-Validity-Duration AVP is 30 seconds. When the OC-Validity-Duration AVP is not present in the OC-OLR AVP, the default value applies. The maximum value for the OC-Validity-Duration AVP is 86,400 seconds (24 hours). If the value received in the OC-Validity-Duration is greater than the maximum value, then the default value applies.",
      "ja": "OC-Validity-Duration AVP（AVPコード625）のタイプはUnsigned32で、過負荷レポートの有効時間を秒単位で示します。秒数は、OC-Sequence-Number AVPの特定の値を持つ最初のOC-OLR AVPを受信して​​から測定されます。 OC-Validity-Duration AVPのデフォルト値は30秒​​です。 OC-Validity-Duration AVPがOC-OLR AVPに存在しない場合、デフォルト値が適用されます。 OC-Validity-Duration AVPの最大値は86,400秒（24時間）です。 OC-Validity-Durationで受け取った値が最大値より大きい場合、デフォルト値が適用されます。"
    },
    {
      "indent": 0,
      "text": "7.6. OC-Report-Type AVP",
      "section_title": true,
      "ja": "7.6. OCレポートタイプAVP"
    },
    {
      "indent": 3,
      "text": "The OC-Report-Type AVP (AVP Code 626) is of type Enumerated. The value of the AVP describes what the overload report concerns. The following values are initially defined:",
      "ja": "OC-Report-Type AVP（AVPコード626）は、列挙型です。 AVPの値は、過負荷レポートが関係する内容を示します。以下の値が最初に定義されています。"
    },
    {
      "indent": 3,
      "text": "HOST_REPORT 0 The overload report is for a host. Overload abatement treatment applies to host-routed requests.",
      "ja": "HOST_REPORT 0過負荷レポートはホスト用です。オーバーロード軽減処理は、ホストルーティングされたリクエストに適用されます。"
    },
    {
      "indent": 3,
      "text": "REALM_REPORT 1 The overload report is for a realm. Overload abatement treatment applies to realm-routed requests.",
      "ja": "REALM_REPORT 1過負荷レポートはレルム用です。過負荷軽減処理は、レルムルーティングされたリクエストに適用されます。"
    },
    {
      "indent": 3,
      "text": "The values 2-4294967295 are unassigned.",
      "ja": "値2-4294967295は割り当てられていません。"
    },
    {
      "indent": 0,
      "text": "7.7. OC-Reduction-Percentage AVP",
      "section_title": true,
      "ja": "7.7. OC-Reduction-Percentage AVP"
    },
    {
      "indent": 3,
      "text": "The OC-Reduction-Percentage AVP (AVP Code 627) is of type Unsigned32 and describes the percentage of the traffic that the sender is requested to reduce, compared to what it otherwise would send. The OC-Reduction-Percentage AVP applies to the default (loss) algorithm specified in this specification. However, the AVP can be reused for future abatement algorithms, if its semantics fit into the new algorithm.",
      "ja": "OC-Reduction-Percentage AVP（AVPコード627）はタイプUnsigned32であり、送信者が削減するように要求されたトラフィックのパーセンテージを、他の方法で送信するものと比較して表します。 OC-Reduction-Percentage AVPは、この仕様で指定されているデフォルト（損失）アルゴリズムに適用されます。ただし、そのセマンティクスが新しいアルゴリズムに適合する場合、AVPは将来の削減アルゴリズムに再利用できます。"
    },
    {
      "indent": 3,
      "text": "The value of the Reduction-Percentage AVP is between zero (0) and one hundred (100). Values greater than 100 are ignored. The value of 100 means that all traffic is to be throttled, i.e., the reporting node is under a severe load and ceases to process any new messages. The value of 0 means that the reporting node is in a stable state and has no need for the reacting node to apply any traffic abatement.",
      "ja": "削減率AVPの値は、ゼロ（0）から100（100）の間です。 100より大きい値は無視されます。値100は、すべてのトラフィックが抑制されることを意味します。つまり、レポートノードに大きな負荷がかかっており、新しいメッセージの処理を停止しています。値0は、レポートノードが安定した状態にあり、反応するノードがトラフィック削減を適用する必要がないことを意味します。"
    },
    {
      "indent": 0,
      "text": "7.8. AVP Flag Rules",
      "section_title": true,
      "ja": "7.8. AVPフラグルール"
    },
    {
      "indent": 6,
      "text": "                                                   +---------+\n                                                   |AVP flag |\n                                                   |rules    |\n                                                   +----+----+\n                        AVP   Section              |    |MUST|\n Attribute Name         Code  Defined  Value Type  |MUST| NOT|\n+--------------------------------------------------+----+----+\n|OC-Supported-Features  621   7.1      Grouped     |    | V  |\n+--------------------------------------------------+----+----+\n|OC-Feature-Vector      622   7.2      Unsigned64  |    | V  |\n+--------------------------------------------------+----+----+\n|OC-OLR                 623   7.3      Grouped     |    | V  |\n+--------------------------------------------------+----+----+\n|OC-Sequence-Number     624   7.4      Unsigned64  |    | V  |\n+--------------------------------------------------+----+----+\n|OC-Validity-Duration   625   7.5      Unsigned32  |    | V  |\n+--------------------------------------------------+----+----+\n|OC-Report-Type         626   7.6      Enumerated  |    | V  |\n+--------------------------------------------------+----+----+\n|OC-Reduction                                      |    |    |\n|  -Percentage          627   7.7      Unsigned32  |    | V  |\n+--------------------------------------------------+----+----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As described in the Diameter base protocol [RFC6733], the M-bit usage for a given AVP in a given command may be defined by the application.",
      "ja": "Diameter基本プロトコル[RFC6733]で説明されているように、特定のコマンドでの特定のAVPのMビットの使用は、アプリケーションで定義できます。"
    },
    {
      "indent": 0,
      "text": "8. Error Response Codes",
      "section_title": true,
      "ja": "8. エラー応答コード"
    },
    {
      "indent": 3,
      "text": "When a DOIC node rejects a Diameter request due to overload, the DOIC node MUST select an appropriate error response code. This determination is made based on the probability of the request succeeding if retried on a different path.",
      "ja": "DOICノードが過負荷のためにDiameter要求を拒否する場合、DOICノードは適切なエラー応答コードを選択する必要があります。この決定は、別のパスで再試行された場合にリクエストが成功する確率に基づいて行われます。"
    },
    {
      "indent": 6,
      "text": "Note: This only applies for DOIC nodes that are not the originator of the request.",
      "ja": "注：これは、要求の発信元ではないDOICノードにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "A reporting node rejecting a Diameter request due to an overload condition SHOULD send a DIAMETER_TOO_BUSY error response, if it can assume that the same request may succeed on a different path.",
      "ja": "過負荷状態が原因でDiameter要求を拒否するレポートノードは、同じ要求が別のパスで成功すると想定できる場合、DIAMETER_TOO_BUSYエラー応答を送信する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If a reporting node knows or assumes that the same request will not succeed on a different path, the DIAMETER_UNABLE_TO_COMPLY error response SHOULD be used. Retrying would consume valuable resources during an occurrence of overload.",
      "ja": "レポートノードが同じ要求が別のパスで成功しないことを知っている、または想定している場合、DIAMETER_UNABLE_TO_COMPLYエラー応答を使用する必要があります（SHOULD）。再試行すると、過負荷の発生時に貴重なリソースが消費されます。"
    },
    {
      "indent": 6,
      "text": "For instance, if the request arrived at the reporting node without a Destination-Host AVP, then the reporting node might determine that there is an alternative Diameter node that could successfully process the request and that retrying the transaction would not negatively impact the reporting node. DIAMETER_TOO_BUSY would be sent in this case.",
      "ja": "たとえば、要求が宛先ホストAVPなしでレポートノードに到着した場合、レポートノードは、要求を正常に処理できる代​​替のDiameterノードがあり、トランザクションを再試行してもレポートノードに悪影響を及ぼさないと判断する場合があります。この場合、DIAMETER_TOO_BUSYが送信されます。"
    },
    {
      "indent": 6,
      "text": "If the request arrived at the reporting node with a Destination-Host AVP populated with its own Diameter identity, then the reporting node can assume that retrying the request would result in it coming to the same reporting node. DIAMETER_UNABLE_TO_COMPLY would be sent in this case.",
      "ja": "独自のDiameter IDが入力されたDestination-Host AVPを使用してリクエストがレポートノードに到着した場合、レポートノードはリクエストを再試行すると同じレポートノードに到達すると見なすことができます。この場合、DIAMETER_UNABLE_TO_COMPLYが送信されます。"
    },
    {
      "indent": 6,
      "text": "A second example is when an agent that supports the DOIC solution is performing the role of a reacting node for a non-supporting client. Requests that are rejected as a result of DOIC throttling by the agent in this scenario would generally be rejected with a DIAMETER_UNABLE_TO_COMPLY response code.",
      "ja": "2番目の例は、DOICソリューションをサポートするエージェントが、サポートしていないクライアントの反応ノードの役割を果たす場合です。このシナリオでエージェントによるDOICスロットルの結果として拒否された要求は、通常、DIAMETER_UNABLE_TO_COMPLY応答コードで拒否されます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. AVP Codes",
      "section_title": true,
      "ja": "9.1. AVPコード"
    },
    {
      "indent": 3,
      "text": "New AVPs defined by this specification are listed in Section 7. All AVP codes are allocated from the \"AVP Codes\" sub-registry under the \"Authentication, Authorization, and Accounting (AAA) Parameters\" registry.",
      "ja": "この仕様で定義された新しいAVPは、セクション7にリストされています。すべてのAVPコードは、「Authentication、Authorization、and Accounting（AAA）Parameters」レジストリの下の「AVP Codes」サブレジストリから割り当てられます。"
    },
    {
      "indent": 0,
      "text": "9.2. New Registries",
      "section_title": true,
      "ja": "9.2. 新しいレジストリ"
    },
    {
      "indent": 3,
      "text": "Two new registries have been created in the \"AVP Specific Values\" sub-registry under the \"Authentication, Authorization, and Accounting (AAA) Parameters\" registry.",
      "ja": "「Authentication、Authorization、and Accounting（AAA）Parameters」レジストリの下の「AVP Specific Values」サブレジストリに2つの新しいレジストリが作成されました。"
    },
    {
      "indent": 3,
      "text": "A new \"OC-Feature-Vector AVP Values (code 622)\" registry has been created. This registry contains the following:",
      "ja": "新しい「OC-Feature-Vector AVP値（コード622）」レジストリが作成されました。このレジストリには、次のものが含まれています。"
    },
    {
      "indent": 6,
      "text": "Feature Vector Value Name",
      "ja": "特徴ベクトル値の名前"
    },
    {
      "indent": 6,
      "text": "Feature Vector Value",
      "ja": "特徴ベクトル値"
    },
    {
      "indent": 6,
      "text": "Specification defining the new value",
      "ja": "新しい値を定義する仕様"
    },
    {
      "indent": 3,
      "text": "See Section 7.2 for the initial Feature Vector Value in the registry. This specification defines the value. New values can be added to the registry using the Specification Required policy [RFC5226].",
      "ja": "レジストリの初期機能ベクトル値については、セクション7.2を参照してください。この仕様は値を定義します。新しい値は、Specification Requiredポリシー[RFC5226]を使用してレジストリに追加できます。"
    },
    {
      "indent": 3,
      "text": "A new \"OC-Report-Type AVP Values (code 626)\" registry has been created. This registry contains the following:",
      "ja": "新しい「OC-Report-Type AVP Values（code 626）」レジストリが作成されました。このレジストリには、次のものが含まれています。"
    },
    {
      "indent": 6,
      "text": "Report Type Value Name",
      "ja": "レポートタイプ値の名前"
    },
    {
      "indent": 6,
      "text": "Report Type Value",
      "ja": "レポートタイプの値"
    },
    {
      "indent": 6,
      "text": "Specification defining the new value",
      "ja": "新しい値を定義する仕様"
    },
    {
      "indent": 3,
      "text": "See Section 7.6 for the initial assignment in the registry. New types can be added using the Specification Required policy [RFC5226].",
      "ja": "レジストリでの初期割り当てについては、セクション7.6を参照してください。新しいタイプは、Specification Requiredポリシー[RFC5226]を使用して追加できます。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "DOIC gives Diameter nodes the ability to request that downstream nodes send fewer Diameter requests. Nodes do this by exchanging overload reports that directly effect this reduction. This exchange is potentially subject to multiple methods of attack and has the potential to be used as a denial-of-service (DoS) attack vector. For instance, a series of injected realm OLRs with a requested reduction percentage of 100% could be used to completely eliminate any traffic from being sent to that realm.",
      "ja": "DOICは、Diameterノードがダウンストリームノードが送信するDiameterリクエストを少なくするように要求する機能を提供します。ノードは、この削減に直接影響する過負荷レポートを交換することによってこれを行います。この交換は、複数の攻撃方法の影響を受ける可能性があり、サービス拒否（DoS）攻撃ベクトルとして使用される可能性があります。たとえば、要求された削減率が100％の一連の注入されたレルムOLRを使用して、そのレルムに送信されるトラフィックを完全に排除できます。"
    },
    {
      "indent": 3,
      "text": "Overload reports may contain information about the topology and current status of a Diameter network. This information is potentially sensitive. Network operators may wish to control disclosure of overload reports to unauthorized parties to avoid their use for competitive intelligence or to target attacks.",
      "ja": "過負荷レポートには、Diameterネットワークのトポロジと現在のステータスに関する情報が含まれる場合があります。この情報は機密である可能性があります。ネットワークオペレータは、無許可のパーティへの過負荷レポートの開示を制御して、競合するインテリジェンスの使用を回避したり、攻撃を標的としたりする場合があります。"
    },
    {
      "indent": 3,
      "text": "Diameter does not include features to provide end-to-end authentication, integrity protection, or confidentiality. This may cause complications when sending overload reports between non-adjacent nodes.",
      "ja": "Diameterには、エンドツーエンドの認証、整合性保護、または機密性を提供する機能は含まれていません。これにより、隣接していないノード間で過負荷レポートを送信するときに問題が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "10.1. Potential Threat Modes",
      "section_title": true,
      "ja": "10.1. 潜在的な脅威モード"
    },
    {
      "indent": 3,
      "text": "The Diameter protocol involves transactions in the form of requests and answers exchanged between clients and servers. These clients and servers may be peers, that is, they may share a direct transport (e.g., TCP or SCTP) connection, or the messages may traverse one or more intermediaries, known as Diameter Agents. Diameter nodes use TLS, DTLS, or IPsec to authenticate peers and to provide confidentiality and integrity protection of traffic between peers. Nodes can make authorization decisions based on the peer identities authenticated at the transport layer.",
      "ja": "Diameterプロトコルには、クライアントとサーバー間で交換される要求と応答の形式のトランザクションが含まれます。これらのクライアントとサーバーはピアである可能性があります。つまり、直接トランスポート（TCPやSCTPなど）接続を共有している可能性があります。または、メッセージは、Diameterエージェントと呼ばれる1つ以上の中間体を通過する可能性があります。 Diameterノードは、TLS、DTLS、またはIPsecを使用してピアを認証し、ピア間のトラフィックの機密性と整合性を保護します。ノードは、トランスポート層で認証されたピアIDに基づいて承認を決定できます。"
    },
    {
      "indent": 3,
      "text": "When agents are involved, this presents an effectively transitive trust model. That is, a Diameter client or server can authorize an agent for certain actions, but it must trust that agent to make appropriate authorization decisions about its peers, and so on. Since confidentiality and integrity protection occur at the transport layer, agents can read, and perhaps modify, any part of a Diameter message, including an overload report.",
      "ja": "エージェントが関与する場合、これは効果的に推移的な信頼モデルを示します。つまり、Diameterクライアントまたはサーバーは、特定のアクションについてエージェントを承認できますが、そのエージェントを信頼して、ピアに関する適切な承認決定を行う必要があります。機密性と整合性の保護はトランスポート層で発生するため、エージェントは、過負荷レポートを含むDiameterメッセージの任意の部分を読み取り、場合によっては変更できます。"
    },
    {
      "indent": 3,
      "text": "There are several ways an attacker might attempt to exploit the overload control mechanism. An unauthorized third party might inject an overload report into the network. If this third party is upstream of an agent, and that agent fails to apply proper authorization policies, downstream nodes may mistakenly trust the report. This attack is at least partially mitigated by the assumption that nodes include overload reports in Diameter answers but not in requests. This requires an attacker to have knowledge of the original request in order to construct an answer. Such an answer would also need to arrive at a Diameter node via a protected transport connection. Therefore, implementations MUST validate that an answer containing an overload report is a properly constructed response to a pending request prior to acting on the overload report, and that the answer was received via an appropriate transport connection.",
      "ja": "攻撃者が過負荷制御メカニズムを悪用しようとする方法はいくつかあります。無許可の第三者が過負荷レポートをネットワークに挿入する可能性があります。このサードパーティがエージェントの上流にあり、そのエージェントが適切な承認ポリシーを適用できない場合、下流のノードがレポートを誤って信頼する可能性があります。この攻撃は、ノードには、Diameter回答には過負荷レポートが含まれているが、リクエストには含まれていないという想定により、少なくとも部分的に軽減されています。これは、攻撃者が回答を作成するために元のリクエストの知識を持っていることを必要とします。このような回答は、保護されたトランスポート接続を介してDiameterノードに到達する必要もあります。したがって、実装は、過負荷レポートを含む応答が、過負荷レポートを処理する前の保留中の要求に対する適切に構成された応答であること、および適切なトランスポート接続を介して応答が受信されたことを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "A similar attack involves a compromised but otherwise authorized node that sends an inappropriate overload report. For example, a server for the realm \"example.com\" might send an overload report indicating that a competitor's realm \"example.net\" is overloaded. If other nodes act on the report, they may falsely believe that \"example.net\" is overloaded, effectively reducing that realm's capacity. Therefore, it's critical that nodes validate that an overload report received from a peer actually falls within that peer's responsibility before acting on the report or forwarding the report to other peers. For example, an overload report from a peer that applies to a realm not handled by that peer is suspect. This may require out-of-band, non-Diameter agreements and/or mechanisms.",
      "ja": "同様の攻撃には、不正使用されたが承認されたノードが関与し、不適切な過負荷レポートを送信します。たとえば、レルム「example.com」のサーバーは、競合他社のレルム「example.net」が過負荷であることを示す過負荷レポートを送信する場合があります。他のノードがレポートに作用する場合、「example.net」が過負荷になっていると誤って信じ、そのレルムの容量を効果的に減らします。したがって、ノードがピアから受信した過負荷レポートが実際にそのピアの責任の範囲内にあることを検証してから、レポートを操作したり、レポートを他のピアに転送したりすることが重要です。たとえば、ピアによって処理されないレルムに適用されるピアからの過負荷レポートが疑われます。これには、帯域外の非直径の合意やメカニズムが必要になる場合があります。"
    },
    {
      "indent": 6,
      "text": "This attack is partially mitigated by the fact that the application, as well as host and realm, for a given OLR is determined implicitly by respective AVPs in the enclosing answer. If a reporting node modifies any of those AVPs, the enclosing transaction will also be affected.",
      "ja": "この攻撃は、特定のOLRのアプリケーション、ホスト、およびレルムが、含まれている回答のそれぞれのAVPによって暗黙的に決定されるという事実によって部分的に軽減されます。レポートノードがこれらのAVPのいずれかを変更すると、それを含むトランザクションも影響を受けます。"
    },
    {
      "indent": 0,
      "text": "10.2. Denial-of-Service Attacks",
      "section_title": true,
      "ja": "10.2. サービス拒否攻撃"
    },
    {
      "indent": 0,
      "text": " Diameter overload reports, especially realm reports, can cause a node to cease sending some or all Diameter requests for an extended period. This makes them a tempting vector for DoS attacks. Furthermore, since Diameter is almost always used in support of other protocols, a DoS attack on Diameter is likely to impact those protocols as well. In the worst case, where the Diameter application is being used for access control into an IP network, a coordinated DoS attack could result in the blockage of all traffic into that network. Therefore, Diameter nodes MUST NOT honor or forward OLRs received from peers that are not trusted to send them.",
      "ja": "Diameter過負荷レポート、特にレルムレポートは、ノードが長期間にわたってDiameterリクエストの一部またはすべてを送信しなくなる可能性があります。これにより、DoS攻撃の誘惑となる可能性があります。さらに、Diameterはほとんど常に他のプロトコルのサポートで使用されるため、DiameterへのDoS攻撃はそれらのプロトコルにも影響を与える可能性があります。 DiameterアプリケーションがIPネットワークへのアクセス制御に使用されている最悪の場合、調整されたDoS攻撃により、そのネットワークへのすべてのトラフィックがブロックされる可能性があります。したがって、Diameterノードは、送信することが信頼されていないピアから受信したOLRを受け入れたり転送したりしてはなりません。"
    },
    {
      "indent": 3,
      "text": "An attacker might use the information in an OLR to assist in DoS attacks. For example, an attacker could use information about current overload conditions to time an attack for maximum effect, or use subsequent overload reports as a feedback mechanism to learn the results of a previous or ongoing attack. Operators need the ability to ensure that OLRs are not leaked to untrusted parties.",
      "ja": "攻撃者はOLRの情報を使用してDoS攻撃を支援する可能性があります。たとえば、攻撃者は現在の過負荷状態に関する情報を使用して攻撃のタイミングを最大にしたり、後続の過負荷レポートをフィードバックメカニズムとして使用して、以前または進行中の攻撃の結果を知ることができます。オペレーターは、OLRが信頼できない関係者に漏洩しないようにする機能が必要です。"
    },
    {
      "indent": 0,
      "text": "10.3. Noncompliant Nodes",
      "section_title": true,
      "ja": "10.3. 非準拠ノード"
    },
    {
      "indent": 3,
      "text": "In the absence of an overload control mechanism, Diameter nodes need to implement strategies to protect themselves from floods of requests, and to make sure that a disproportionate load from one source does not prevent other sources from receiving service. For example, a Diameter server might throttle a certain percentage of requests from sources that exceed certain limits. Overload control can be thought of as an optimization for such strategies, where downstream nodes never send the excess requests in the first place. However, the presence of an overload control mechanism does not remove the need for these other protection strategies.",
      "ja": "過負荷制御メカニズムがない場合、Diameterノードは、リクエストのフラッドから自分自身を保護する戦略を実装し、あるソースからの不均衡な負荷が他のソースによるサービスの受信を妨げないようにする必要があります。たとえば、Diameterサーバーは、特定の制限を超えるソースからのリクエストの特定の割合を抑制する場合があります。過負荷制御は、そのような戦略の最適化と考えることができます。その場合、ダウンストリームノードはそもそも過剰な要求を送信しません。ただし、過負荷制御メカニズムの存在は、これらの他の保護戦略の必要性を取り除きません。"
    },
    {
      "indent": 3,
      "text": "When a Diameter node sends an overload report, it cannot assume that all nodes will comply, even if they indicate support for DOIC. A noncompliant node might continue to send requests with no reduction in load. Such noncompliance could be done accidentally or maliciously to gain an unfair advantage over compliant nodes. Requirement 28 in [RFC7068] indicates that the overload control solution cannot assume that all Diameter nodes in a network are trusted. It also requires that malicious nodes not be allowed to take advantage of the overload control mechanism to get more than their fair share of service.",
      "ja": "Diameterノードが過負荷レポートを送信する場合、たとえDOICのサポートを示していても、すべてのノードが準拠するとは想定できません。非準拠ノードは、負荷を軽減せずにリクエストを送信し続ける場合があります。このような非準拠は、偶然または悪意を持って行われ、準拠ノードよりも不当な利点を得る可能性があります。 [RFC7068]の要件28は、過負荷制御ソリューションがネットワーク内のすべてのDiameterノードが信頼できると想定できないことを示しています。また、悪意のあるノードが過負荷制御メカニズムを利用して、公平なサービスシェア以上のものを取得できないようにする必要もあります。"
    },
    {
      "indent": 0,
      "text": "10.4. End-to-End Security Issues",
      "section_title": true,
      "ja": "10.4. エンドツーエンドのセキュリティ問題"
    },
    {
      "indent": 0,
      "text": " The lack of end-to-end integrity features makes it difficult to establish trust in overload reports received from non-adjacent nodes. Any agents in the message path may insert or modify overload reports. Nodes must trust that their adjacent peers perform proper checks on overload reports from their peers, and so on, creating a transitive-trust requirement extending for potentially long chains of nodes. Network operators must determine if this transitive trust requirement is acceptable for their deployments. Nodes supporting Diameter overload control MUST give operators the ability to select which peers are trusted to deliver overload reports and whether they are trusted to forward overload reports from non-adjacent nodes. DOIC nodes MUST strip DOIC AVPs from messages received from peers that are not trusted for DOIC purposes.",
      "ja": "エンドツーエンドの整合性機能がないため、隣接していないノードから受信した過負荷レポートへの信頼を確立することが困難になります。メッセージパス内のエージェントは、過負荷レポートを挿入または変更できます。ノードは、隣接するピアがピアからの過負荷レポートに対して適切なチェックを実行することなどを信頼する必要があり、ノードのチェーンが長くなる可能性のある推移的な信頼要件を作成します。ネットワークオペレーターは、この推移的な信頼要件が展開に受け入れられるかどうかを判断する必要があります。 Diameter過負荷制御をサポートするノードは、オペレーターに、過負荷レポートの配信を信頼するピアと、隣接していないノードからの過負荷レポートの転送を信頼するかどうかを選択できるようにする必要があります。 DOICノードは、DOICの目的で信頼されていないピアから受信したメッセージからDOIC AVPを取り除く必要があります。"
    },
    {
      "indent": 3,
      "text": "The lack of end-to-end confidentiality protection means that any Diameter Agent in the path of an overload report can view the contents of that report. In addition to the requirement to select which peers are trusted to send overload reports, operators MUST be able to select which peers are authorized to receive reports. A node MUST NOT send an overload report to a peer not authorized to receive it. Furthermore, an agent MUST remove any overload reports that might have been inserted by other nodes before forwarding a Diameter message to a peer that is not authorized to receive overload reports.",
      "ja": "エンドツーエンドの機密保護の欠如は、過負荷レポートのパスにあるすべてのDiameterエージェントがそのレポートの内容を表示できることを意味します。どのピアが過負荷レポートの送信を信頼されているかを選択する要件に加えて、オペレーターはレポートの受信を許可されているピアを選択できる必要があります。ノードは、過負荷レポートの受信を許可されていないピアに過負荷レポートを送信してはなりません（MUST NOT）。さらに、エージェントは、Diameterメッセージを、過負荷レポートの受信を許可されていないピアに転送する前に、他のノードによって挿入された可能性のある過負荷レポートを削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "A DOIC node cannot always automatically detect that a peer also supports DOIC. For example, a node might have a peer that is a non-supporting agent. If nodes on the other side of that agent send OC-Supported-Features AVPs, the agent is likely to forward them as unknown AVPs. Messages received across the non-supporting agent may be indistinguishable from messages received across a DOIC supporting agent, giving the false impression that the non-supporting agent actually supports DOIC. This complicates the transitive-trust nature of DOIC. Operators need to be careful to avoid situations where a non-supporting agent is mistakenly trusted to enforce DOIC-related authorization policies.",
      "ja": "DOICノードは、ピアがDOICもサポートしていることを常に自動的に検出できるわけではありません。たとえば、ノードに、サポートされていないエージェントであるピアがある場合があります。そのエージェントの反対側のノードがOC-Supported-Features AVPを送信する場合、エージェントはそれらを不明なAVPとして転送する可能性があります。非サポートエージェントを介して受信されたメッセージは、DOICサポートエージェントを介して受信されたメッセージと区別できない場合があり、非サポートエージェントが実際にDOICをサポートしているという誤った印象を与えます。これは、DOICの推移的な信頼の性質を複雑にします。オペレーターは、サポートしていないエージェントが誤って信頼されてDOIC関連の承認ポリシーを施行する状況を回避するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that work on end-to-end Diameter security might make it easier to establish trust in non-adjacent nodes for overload control purposes. Readers should be reminded, however, that the overload control mechanism allows Diameter Agents to modify AVPs in, or insert additional AVPs into, existing messages that are originated by other nodes. If end-to-end security is enabled, there is a risk that such modification could violate integrity protection. The details of using any future Diameter end-to-end security mechanism with overload control will require careful consideration, and are beyond the scope of this document.",
      "ja": "エンドツーエンドのDiameterセキュリティでの作業により、過負荷制御の目的で隣接していないノードで信頼を確立しやすくなることが期待されます。ただし、過負荷制御メカニズムにより、Diameterエージェントは他のノードから発信された既存のメッセージにAVPを変更したり、追加のAVPを挿入したりできることに注意してください。エンドツーエンドのセキュリティが有効になっている場合、そのような変更が整合性保護に違反する危険性があります。将来のDiameterエンドツーエンドセキュリティメカニズムと過負荷制御の使用の詳細は慎重に検討する必要があり、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org / info / rfc5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC6733] Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn, Ed., \"Diameter Base Protocol\", RFC 6733, DOI 10.17487/RFC6733, October 2012, <http://www.rfc-editor.org/info/rfc6733>.",
      "ja": "[RFC6733] Fajardo、V.、Ed。、Arkko、J.、Loughney、J.、and G. Zorn、Ed。、 \"Diameter Base Protocol\"、RFC 6733、DOI 10.17487 / RFC6733、October 2012、<http：/ /www.rfc-editor.org/info/rfc6733>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Cx] 3GPP, \"Cx and Dx interfaces based on the Diameter protocol; Protocol details\", 3GPP TS 29.229 12.7.0, September 2015.",
      "ja": "[Cx] 3GPP、「Diameterプロトコルに基づくCxおよびDxインターフェイス、プロトコルの詳細」、3GPP TS 29.229 12.7.0、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[PCC] 3GPP, \"Policy and charging control architecture\", 3GPP TS 23.203 12.10.0, September 2015.",
      "ja": "[PCC] 3GPP、「ポリシーと課金制御アーキテクチャ」、3GPP TS 23.203 12.10.0、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4006] Hakala, H., Mattila, L., Koskinen, J-P., Stura, M., and J. Loughney, \"Diameter Credit-Control Application\", RFC 4006, DOI 10.17487/RFC4006, August 2005, <http://www.rfc-editor.org/info/rfc4006>.",
      "ja": "[RFC4006] Hakala、H.、Mattila、L.、Koskinen、JP。、Stura、M。、およびJ. Loughney、「Diameter Credit-Control Application」、RFC 4006、DOI 10.17487 / RFC4006、2005年8月、<http： //www.rfc-editor.org/info/rfc4006>。"
    },
    {
      "indent": 3,
      "text": "[RFC7068] McMurry, E. and B. Campbell, \"Diameter Overload Control Requirements\", RFC 7068, DOI 10.17487/RFC7068, November 2013, <http://www.rfc-editor.org/info/rfc7068>.",
      "ja": "[RFC7068] McMurry、E。およびB. Campbell、「Diameter Overload Control Requirements」、RFC 7068、DOI 10.17487 / RFC7068、2013年11月、<http://www.rfc-editor.org/info/rfc7068>。"
    },
    {
      "indent": 3,
      "text": "[S13] 3GPP, \"Evolved Packet System (EPS); Mobility Management Entity (MME) and Serving GPRS Support Node (SGSN) related interfaces based on Diameter protocol\", 3GPP TS 29.272 12.8.0, September 2015.",
      "ja": "[S13] 3GPP、「Evolved Packet System（EPS）; Mobility Management Entity（MME）and Serving GPRS Support Node（SGSN）related interfaces based on Diameter protocol）」、3GPP TS 29.272 12.8.0、2015年9月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Issues Left for Future Specifications",
      "section_title": true,
      "ja": "付録A.将来の仕様に残された問題"
    },
    {
      "indent": 3,
      "text": "The base solution for overload control does not cover all possible use cases. A number of solution aspects were intentionally left for future specification and protocol work. The following subsections define some of the potential extensions to the DOIC solution.",
      "ja": "過負荷制御の基本ソリューションは、考えられるすべてのユースケースをカバーしているわけではありません。ソリューションの多くの側面は、将来の仕様とプロトコルの作業のために意図的に残されました。以下のサブセクションでは、DOICソリューションの潜在的な拡張の一部を定義します。"
    },
    {
      "indent": 0,
      "text": "A.1. Additional Traffic Abatement Algorithms",
      "section_title": true,
      "ja": "A.1. 追加のトラフィック削減アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This specification describes only means for a simple loss-based algorithm. Future algorithms can be added using the designed solution extension mechanism. The new algorithms need to be registered with IANA. See Sections 7.2 and 9 for the required IANA steps.",
      "ja": "この仕様では、単純な損失ベースのアルゴリズムの手段のみを説明しています。設計されたソリューション拡張メカニズムを使用して、将来のアルゴリズムを追加できます。新しいアルゴリズムはIANAに登録する必要があります。必要なIANAステップについては、セクション7.2および9を参照してください。"
    },
    {
      "indent": 0,
      "text": "A.2. Agent Overload",
      "section_title": true,
      "ja": "A.2. エージェントの過負荷"
    },
    {
      "indent": 3,
      "text": "This specification focuses on Diameter endpoint (server or client) overload. A separate extension will be required to outline the handling of the case of agent overload.",
      "ja": "この仕様は、Diameterエンドポイント（サーバーまたはクライアント）のオーバーロードに焦点を当てています。エージェントが過負荷の場合の処理​​の概要を説明するには、別の拡張機能が必要です。"
    },
    {
      "indent": 0,
      "text": "A.3. New Error Diagnostic AVP",
      "section_title": true,
      "ja": "A.3. 新しいエラー診断AVP"
    },
    {
      "indent": 3,
      "text": "This specification indicates the use of existing error messages when nodes reject requests due to overload. There is an expectation that additional error codes or AVPs will be defined in a separate specification to indicate that overload was the reason for the rejection of the message.",
      "ja": "この仕様は、ノードが過負荷のためにリクエストを拒否した場合の既存のエラーメッセージの使用を示しています。過負荷がメッセージの拒否の理由であったことを示すために、追加のエラーコードまたはAVPが別の仕様で定義されることが期待されています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Deployment Considerations",
      "section_title": true,
      "ja": "付録B.展開に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Non-supporting Agents",
      "ja": "非サポートエージェント"
    },
    {
      "indent": 6,
      "text": "Due to the way that realm-routed requests are handled in Diameter networks with the server selection for the request done by an agent, network operators should enable DOIC at agents that perform server selection first.",
      "ja": "レルムルーティングされたリクエストは、エージェントによるリクエストのサーバー選択でDiameterネットワークで処理される方法のため、ネットワークオペレーターは、サーバー選択を最初に実行するエージェントでDOICを有効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Topology-Hiding Interactions",
      "ja": "トポロジ非表示の相互作用"
    },
    {
      "indent": 6,
      "text": "There exist proxies that implement what is referred to as Topology Hiding. This can include cases where the agent modifies the Origin-Host in answer messages. The behavior of the DOIC solution is not well understood when this happens. As such, the DOIC solution does not address this scenario.",
      "ja": "トポロジ非表示と呼ばれるものを実装するプロキシが存在します。これには、エージェントが応答メッセージのOrigin-Hostを変更する場合が含まれます。これが発生すると、DOICソリューションの動作は十分に理解されません。そのため、DOICソリューションはこのシナリオに対応していません。"
    },
    {
      "indent": 3,
      "text": "Inter-Realm/Administrative Domain Considerations",
      "ja": "レルム間/管理ドメインの考慮事項"
    },
    {
      "indent": 6,
      "text": "There are likely to be special considerations for handling DOIC signaling across administrative boundaries. This includes considerations for whether or not information included in the DOIC signaling should be sent across those boundaries. In addition, consideration should be taken as to whether or not a reacting node in one realm can be trusted to implement the requested overload abatement handling for overload reports received from a separately administered realm.",
      "ja": "管理境界を越えてDOICシグナリングを処理するには、特別な考慮事項がある可能性があります。これには、DOICシグナリングに含まれる情報をこれらの境界を越えて送信する必要があるかどうかの考慮事項が含まれます。さらに、1つのレルムの反応ノードが、個別に管理されているレルムから受信した過負荷レポートに対して要求された過負荷軽減処理を実装するために信頼できるかどうかについても考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Considerations for Applications Integrating the DOIC Solution",
      "ja": "付録C. DOICソリューションを統合するアプリケーションに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section outlines considerations to be taken into account when integrating the DOIC solution into Diameter applications.",
      "ja": "このセクションでは、DOICソリューションをDiameterアプリケーションに統合する際に考慮すべき考慮事項について概説します。"
    },
    {
      "indent": 0,
      "text": "C.1. Application Classification",
      "section_title": true,
      "ja": "C.1. アプリケーション分類"
    },
    {
      "indent": 3,
      "text": "The following is a classification of Diameter applications and request types. This discussion is meant to document factors that play into decisions made by the Diameter entity responsible for handling overload reports.",
      "ja": "以下は、Diameterアプリケーションと要求タイプの分類です。この説明は、過負荷レポートの処理を担当するDiameterエンティティによって行われる決定に関与する要素を文書化することを目的としています。"
    },
    {
      "indent": 3,
      "text": "Section 8.1 of [RFC6733] defines two state machines that imply two types of applications, session-less and session-based applications. The primary difference between these types of applications is the lifetime of Session-Ids.",
      "ja": "[RFC6733]のセクション8.1は、セッションレスアプリケーションとセッションベースアプリケーションの2種類のアプリケーションを意味する2つのステートマシンを定義しています。これらのタイプのアプリケーションの主な違いは、Session-Idのライフタイムです。"
    },
    {
      "indent": 3,
      "text": "For session-based applications, the Session-Id is used to tie multiple requests into a single session.",
      "ja": "セッションベースのアプリケーションの場合、Session-Idを使用して、複数のリクエストを1つのセッションに結び付けます。"
    },
    {
      "indent": 3,
      "text": "The Credit-Control application defined in [RFC4006] is an example of a Diameter session-based application.",
      "ja": "[RFC4006]で定義されているCredit-Controlアプリケーションは、Diameterセッションベースのアプリケーションの例です。"
    },
    {
      "indent": 3,
      "text": "In session-less applications, the lifetime of the Session-Id is a single Diameter transaction, i.e., the session is implicitly terminated after a single Diameter transaction and a new Session-Id is generated for each Diameter request.",
      "ja": "セッションレスアプリケーションでは、Session-Idの有効期間は単一のDiameterトランザクションです。つまり、単一のDiameterトランザクションの後でセッションが暗黙的に終了し、Diameterリクエストごとに新しいSession-Idが生成されます。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this discussion, session-less applications are further divided into two types of applications:",
      "ja": "この説明では、セッションレスアプリケーションをさらに2つのタイプのアプリケーションに分けます。"
    },
    {
      "indent": 3,
      "text": "Stateless Applications:",
      "ja": "ステートレスアプリケーション："
    },
    {
      "indent": 6,
      "text": "Requests within a stateless application have no relationship to each other. The 3GPP-defined S13 application is an example of a stateless application [S13], where only a Diameter command is defined between a client and a server and no state is maintained between two consecutive transactions.",
      "ja": "ステートレスアプリケーション内のリクエストは互いに関係がありません。 3GPP定義のS13アプリケーションは、ステートレスアプリケーション[S13]の例です。ここでは、Diameterコマンドのみがクライアントとサーバー間で定義され、2つの連続するトランザクション間で状態は維持されません。"
    },
    {
      "indent": 3,
      "text": "Pseudo-Session Applications:",
      "ja": "疑似セッションアプリケーション："
    },
    {
      "indent": 6,
      "text": "Applications that do not rely on the Session-Id AVP for correlation of application messages related to the same session but use other session-related information in the Diameter requests for this purpose. The 3GPP-defined Cx application [Cx] is an example of a pseudo-session application.",
      "ja": "同じセッションに関連するアプリケーションメッセージの相関についてSession-Id AVPに依存しないが、この目的のためにDiameterリクエストで他のセッション関連情報を使用するアプリケーション。 3GPP定義のCxアプリケーション[Cx]は、疑似セッションアプリケーションの例です。"
    },
    {
      "indent": 3,
      "text": "The handling of overload reports must take the type of application into consideration, as discussed in Appendix C.2.",
      "ja": "付録C.2で説明するように、過負荷レポートの処理では、アプリケーションのタイプを考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "C.2. Implications of Application Type Overload",
      "section_title": true,
      "ja": "C.2. アプリケーションタイプのオーバーロードの影響"
    },
    {
      "indent": 3,
      "text": "This section discusses considerations for mitigating overload reported by a Diameter entity. This discussion focuses on the type of application. Appendix C.3 discusses considerations for handling various request types when the target server is known to be in an overloaded state.",
      "ja": "このセクションでは、Diameterエンティティによって報告される過負荷を軽減するための考慮事項について説明します。この説明では、アプリケーションのタイプに焦点を当てています。付録C.3では、ターゲットサーバーが過負荷状態であることがわかっている場合のさまざまな要求タイプの処理に関する考慮事項について説明します。"
    },
    {
      "indent": 3,
      "text": "These discussions assume that the strategy for mitigating the reported overload is to reduce the overall workload sent to the overloaded entity. The concept of applying overload treatment to requests targeted for an overloaded Diameter entity is inherent to this discussion. The method used to reduce offered load is not specified here, but it could include routing requests to another Diameter entity known to be able to handle them, or it could mean rejecting certain requests. For a Diameter Agent, rejecting requests will usually mean generating appropriate Diameter error responses. For a Diameter client, rejecting requests will depend upon the application. For example, it could mean giving an indication to the entity requesting the Diameter service that the network is busy and to try again later.",
      "ja": "これらの説明では、報告された過負荷を軽減するための戦略は、過負荷のエンティティに送信される全体的なワークロードを削減することであると想定しています。オーバーロードされたDiameterエンティティを対象とするリクエストにオーバーロード処理を適用するという概念は、この議論に固有のものです。提供される負荷を減らすために使用される方法はここでは指定されていませんが、それらを処理できることがわかっている別のDiameterエンティティに要求をルーティングすることや、特定の要求を拒否することを含む場合があります。 Diameterエージェントの場合、リクエストを拒否すると、通常は適切なDiameterエラー応答が生成されます。 Diameterクライアントの場合、リクエストの拒否はアプリケーションによって異なります。たとえば、Diameterサービスを要求しているエンティティに、ネットワークがビジーであることを示し、後で再試行することを意味します。"
    },
    {
      "indent": 3,
      "text": "Stateless Applications:",
      "ja": "ステートレスアプリケーション："
    },
    {
      "indent": 6,
      "text": "By definition, there is no relationship between individual requests in a stateless application. As a result, when a request is sent or relayed to an overloaded Diameter entity -- either a Diameter Server or a Diameter Agent -- the sending or relaying entity can choose to apply the overload treatment to any request targeted for the overloaded entity.",
      "ja": "定義上、ステートレスアプリケーションの個々のリクエスト間には関係がありません。その結果、要求が過負荷のDiameterエンティティ（DiameterサーバーまたはDiameterエージェント）に送信または中継されると、送信または中継エンティティは、過負荷エンティティを対象とするすべての要求に過負荷処理を適用することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Pseudo-session Applications:",
      "ja": "疑似セッションアプリケーション："
    },
    {
      "indent": 6,
      "text": "For pseudo-session applications, there is an implied ordering of requests. As a result, decisions about which requests towards an overloaded entity to reject could take the command code of the request into consideration. This generally means that transactions later in the sequence of transactions should be given more favorable treatment than messages earlier in the sequence. This is because more work has already been done by the Diameter network for those transactions that occur later in the sequence. Rejecting them could result in increasing the load on the network as the transactions earlier in the sequence might also need to be repeated.",
      "ja": "疑似セッションアプリケーションの場合、暗黙的な要求の順序があります。その結果、過負荷のエンティティへのどのリクエストを拒否するかについての決定では、リクエストのコマンドコードを考慮することができます。これは一般に、トランザクションのシーケンスの後の方のトランザクションは、シーケンスの前の方のメッセージよりも有利な扱いを与えられるべきであることを意味します。これは、シーケンスの後半で発生するトランザクションに対して、Diameterネットワークによってすでに多くの作業が行われているためです。それらを拒否すると、シーケンスの最初のトランザクションも繰り返す必要がある可能性があるため、ネットワークの負荷が増加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Session-Based Applications:",
      "ja": "セッションベースのアプリケーション："
    },
    {
      "indent": 6,
      "text": "Overload handling for session-based applications must take into consideration the work load associated with setting up and maintaining a session. As such, the entity sending requests towards an overloaded Diameter entity for a session-based application might tend to reject new session requests prior to rejecting intra-session requests. In addition, session-ending requests might be given a lower probability of being rejected, as rejecting session-ending requests could result in session status being out of sync between the Diameter clients and servers. Application designers that would decide to reject mid-session requests will need to consider whether the rejection invalidates the session and any resulting session cleanup procedures.",
      "ja": "セッションベースのアプリケーションの過負荷処理では、セッションの設定と維持に関連する作業負荷を考慮する必要があります。そのため、セッションベースのアプリケーションの過負荷のDiameterエンティティに向けてリクエストを送信するエンティティは、セッション内リクエストを拒否する前に、新しいセッションリクエストを拒否する傾向があります。さらに、セッション終了要求を拒否すると、Diameterクライアントとサーバー間でセッションステータスが同期されなくなる可能性があるため、セッション終了要求が拒否される可能性が低くなります。中間セッション要求を拒否することを決定するアプリケーション設計者は、拒否によってセッションが無効になるかどうか、および結果として生じるセッションのクリーンアップ手順を検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "C.3. Request Transaction Classification",
      "section_title": true,
      "ja": "C.3. トランザクション分類のリクエスト"
    },
    {
      "indent": 3,
      "text": "Independent Request:",
      "ja": "独立した要求："
    },
    {
      "indent": 6,
      "text": "An independent request is not correlated to any other requests, and, as such, the lifetime of the Session-Id is constrained to an individual transaction.",
      "ja": "独立した要求は他のどの要求とも関連付けられておらず、そのため、Session-Idの存続期間は個々のトランザクションに制限されています。"
    },
    {
      "indent": 3,
      "text": "Session-Initiating Request:",
      "ja": "セッション開始リクエスト："
    },
    {
      "indent": 6,
      "text": "A session-initiating request is the initial message that establishes a Diameter session. The ACR message defined in [RFC6733] is an example of a session-initiating request.",
      "ja": "セッション開始要求は、Diameterセッションを確立する最初のメッセージです。 [RFC6733]で定義されているACRメッセージは、セッション開始要求の例です。"
    },
    {
      "indent": 3,
      "text": "Correlated Session-Initiating Request:",
      "ja": "相関セッション開始リクエスト："
    },
    {
      "indent": 6,
      "text": "There are cases when multiple session-initiated requests must be correlated and managed by the same Diameter server. It is notably the case in the 3GPP Policy and Charging Control (PCC) architecture [PCC], where multiple apparently independent Diameter application sessions are actually correlated and must be handled by the same Diameter server.",
      "ja": "複数のセッションで開始された要求を同じDiameterサーバーで相互に関連付けて管理する必要がある場合があります。 3GPPポリシーおよび課金制御（PCC）アーキテクチャ[PCC]の場合は特にそうです。複数の明らかに独立したDiameterアプリケーションセッションが実際に関連付けられ、同じDiameterサーバーで処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Intra-session Request:",
      "ja": "セッション内リクエスト："
    },
    {
      "indent": 6,
      "text": "An intra-session request is a request that uses the same Session-Id as the one used in a previous request. An intra-session request generally needs to be delivered to the server that handled the session-creating request for the session. The STR message defined in [RFC6733] is an example of an intra-session request.",
      "ja": "セッション内要求は、前の要求で使用されたものと同じSession-Idを使用する要求です。通常、セッション内リクエストは、セッションのセッション作成リクエストを処理したサーバーに配信する必要があります。 [RFC6733]で定義されているSTRメッセージは、セッション内要求の例です。"
    },
    {
      "indent": 3,
      "text": "Pseudo-session Requests:",
      "ja": "疑似セッション要求："
    },
    {
      "indent": 6,
      "text": "Pseudo-session requests are independent requests and do not use the same Session-Id but are correlated by other session-related information contained in the request. There exist Diameter applications that define an expected ordering of transactions. This sequencing of independent transactions results in a pseudo-session. The AIR, MAR, and SAR requests in the 3GPP-defined Cx [Cx] application are examples of pseudo-session requests.",
      "ja": "疑似セッション要求は独立した要求であり、同じセッションIDを使用しませんが、要求に含まれる他のセッション関連情報によって相互に関連付けられます。予想されるトランザクションの順序を定義するDiameterアプリケーションが存在します。この独立したトランザクションのシーケンスにより、疑似セッションが発生します。 3GPP定義のCx [Cx]アプリケーションのAIR、MAR、およびSAR要求は、疑似セッション要求の例です。"
    },
    {
      "indent": 0,
      "text": "C.4. Request Type Overload Implications",
      "section_title": true,
      "ja": "C.4. リクエストタイプのオーバーロードの影響"
    },
    {
      "indent": 3,
      "text": "The request classes identified in Appendix C.3 have implications on decisions about which requests should be throttled first. The following list of request treatments regarding throttling is provided as guidelines for application designers when implementing the Diameter overload control mechanism described in this document. The exact behavior regarding throttling is a matter of local policy, unless specifically defined for the application.",
      "ja": "付録C.3で特定されている要求クラスは、最初にスロットルする必要がある要求に関する決定に影響を与えます。このドキュメントで説明されているDiameter過負荷制御メカニズムを実装する際のアプリケーション設計者向けのガイドラインとして、スロットルに関する次の要求処理のリストを示します。スロットリングに関する正確な動作は、アプリケーションで特に定義されていない限り、ローカルポリシーの問題です。"
    },
    {
      "indent": 3,
      "text": "Independent Requests:",
      "ja": "独立した要求："
    },
    {
      "indent": 6,
      "text": "Independent requests can generally be given equal treatment when making throttling decisions, unless otherwise indicated by application requirements or local policy.",
      "ja": "独立した要求は、アプリケーションの要件やローカルポリシーで特に指定されていない限り、スロットルの決定を行うときに一般的に同等の扱いをすることができます。"
    },
    {
      "indent": 3,
      "text": "Session-Initiating Requests:",
      "ja": "セッション開始リクエスト："
    },
    {
      "indent": 6,
      "text": "Session-initiating requests often represent more work than independent or intra-session requests. Moreover, session-initiating requests are typically followed by other session-related requests. Since the main objective of overload control is to reduce the total number of requests sent to the overloaded entity, throttling decisions might favor allowing intra-session requests over session-initiating requests. In the absence of local policies or application-specific requirements to the contrary, individual session-initiating requests can be given equal treatment when making throttling decisions.",
      "ja": "多くの場合、セッション開始要求は、独立した要求やセッション内要求よりも多くの作業を表します。さらに、セッション開始要求には通常、他のセッション関連の要求が続きます。過負荷制御の主な目的は、過負荷のエンティティに送信される要求の総数を減らすことであるため、スロットルの決定では、セッション開始要求よりもセッション内要求を許可する方が有利になる場合があります。逆にローカルポリシーまたはアプリケーション固有の要件がない場合、個々のセッション開始リクエストは、スロットルの決定を行うときに同等の扱いを受けることができます。"
    },
    {
      "indent": 3,
      "text": "Correlated Session-Initiating Requests:",
      "ja": "相関するセッション開始リクエスト："
    },
    {
      "indent": 6,
      "text": "A request that results in a new binding; where the binding is used for routing of subsequent session-initiating requests to the same server, it represents more work load than other requests. As such, these requests might be throttled more frequently than other request types.",
      "ja": "新しいバインディングが発生するリクエスト。同じサーバーへの後続のセッション開始要求のルーティングにバインディングが使用される場合、バインディングは他の要求よりも多くの作業負荷を表します。そのため、これらのリクエストは他のリクエストタイプよりも頻繁に抑制される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Pseudo-session Requests:",
      "ja": "疑似セッション要求："
    },
    {
      "indent": 6,
      "text": "Throttling decisions for pseudo-session requests can take into consideration where individual requests fit into the overall sequence of requests within the pseudo-session. Requests that are earlier in the sequence might be throttled more aggressively than requests that occur later in the sequence.",
      "ja": "疑似セッション要求のスロットリングの決定では、個々の要求が疑似セッション内の要求の全体的なシーケンスに適合する場所を考慮することができます。シーケンスの前半のリクエストは、シーケンスの後半に発生するリクエストよりも積極的に抑制される場合があります。"
    },
    {
      "indent": 3,
      "text": "Intra-session Requests:",
      "ja": "セッション内リクエスト："
    },
    {
      "indent": 6,
      "text": "There are two types of intra-sessions requests, requests that terminate a session and the remainder of intra-session requests. Implementers and operators may choose to throttle session-terminating requests less aggressively in order to gracefully terminate sessions, allow cleanup of the related resources (e.g., session state), and avoid the need for additional intra-session requests. Favoring session termination requests may reduce the session management impact on the overloaded entity. The default handling of other intra-session requests might be to treat them equally when making throttling decisions. There might also be application-level considerations whether some request types are favored over others.",
      "ja": "セッション内要求には、セッションを終了する要求と残りのセッション内要求の2種類があります。実装者とオペレーターは、セッションを適切に終了し、関連リソース（セッション状態など）をクリーンアップして、追加のセッション内リクエストの必要性を回避するために、セッション終了リクエストのアグレッシブを抑制します。セッション終了要求を優先することで、過負荷のエンティティに対するセッション管理の影響を減らすことができます。他のセッション内要求のデフォルトの処理では、スロットル決定を行うときにそれらを同等に扱う場合があります。一部のリクエストタイプが他のタイプよりも優先されるかどうかは、アプリケーションレベルの考慮事項もあります。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "The following people contributed substantial ideas, feedback, and discussion to this document:",
      "ja": "次の人々は、このドキュメントに実質的なアイデア、フィードバック、および議論を提供しました："
    },
    {
      "indent": 3,
      "text": "o Eric McMurry",
      "ja": "o エリックマクマリー"
    },
    {
      "indent": 3,
      "text": "o Hannes Tschofenig",
      "ja": "o ハネス・チョフェニグ"
    },
    {
      "indent": 3,
      "text": "o Ulrich Wiehe",
      "ja": "o ウルリッヒ・ヴィーエ"
    },
    {
      "indent": 3,
      "text": "o Jean-Jacques Trottin",
      "ja": "o ジャン=ジャック・トロタン"
    },
    {
      "indent": 3,
      "text": "o Maria Cruz Bartolome",
      "ja": "o マリア・クルス・バルトロメ"
    },
    {
      "indent": 3,
      "text": "o Martin Dolly",
      "ja": "o マーティンドリー"
    },
    {
      "indent": 3,
      "text": "o Nirav Salot",
      "ja": "o ニラヴ・サロット"
    },
    {
      "indent": 3,
      "text": "o Susan Shishufeng",
      "ja": "o すさん ししゅふぇんｇ"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jouni Korhonen (editor) Broadcom Corporation 3151 Zanker Road San Jose, CA 95134 United States",
      "ja": "Jouni Korhonen（編集者）Broadcom Corporation 3151 Zanker Road San Jose、CA 95134アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: jouni.nospam@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Steve Donovan (editor) Oracle 7460 Warren Parkway Frisco, Texas 75034 United States",
      "ja": "Steve Donovan（編集者）Oracle 7460 Warren Parkwayフリスコ、テキサス75034米国"
    },
    {
      "indent": 3,
      "text": "Email: srdonovan@usdonovans.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ben Campbell Oracle 7460 Warren Parkway Frisco, Texas 75034 United States",
      "ja": "ベンキャンベルOracle 7460 Warren Parkwayフリスコ、テキサス75034アメリカ"
    },
    {
      "indent": 3,
      "text": "Email: ben@nostrum.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lionel Morand Orange Labs 38/40 rue du General Leclerc Issy-Les-Moulineaux Cedex 9 92794 France",
      "ja": "ライオネルモランドオレンジラボ38/40 rue du General Leclerc Issy-Les-Moulineaux Cedex 9 92794 France"
    },
    {
      "indent": 3,
      "text": "Phone: +33145296257\nEmail: lionel.morand@orange.com",
      "raw": true,
      "ja": ""
    }
  ]
}