{
  "title": {
    "text": "RFC 6675 - A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP",
    "ja": "RFC 6675 - TCPの選択的確認応答（SACK）に基づく保守的な損失回復アルゴリズム"
  },
  "number": 6675,
  "created_at": "2020-09-07 19:06:49.147320+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        E. Blanton\nRequest for Comments: 6675                             Purdue University\nObsoletes: 3517                                                M. Allman\nCategory: Standards Track                                           ICSI\nISSN: 2070-1721                                                  L. Wang\n                                                        Juniper Networks\n                                                             I. Jarvinen\n                                                                 M. Kojo\n                                                  University of Helsinki\n                                                              Y. Nishida\n                                                            WIDE Project\n                                                             August 2012",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP",
      "ja": "TCPの選択的確認応答（SACK）に基づく保守的な損失回復アルゴリズム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option. The algorithm presented in this document conforms to the spirit of the current congestion control specification (RFC 5681), but allows TCP senders to recover more effectively when multiple segments are lost from a single flight of data. This document obsoletes RFC 3517 and describes changes from it.",
      "ja": "このドキュメントでは、選択的確認応答（SACK）TCPオプションの使用に基づく、TCPの控えめな損失回復アルゴリズムについて説明します。このドキュメントで紹介するアルゴリズムは、現在の輻輳制御仕様（RFC 5681）の精神に準拠していますが、データの単一のフライトから複数のセグメントが失われた場合に、TCP送信者がより効率的に回復できるようにします。このドキュメントはRFC 3517を廃止し、RFC 3517からの変更点を説明しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6675.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6675で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2012 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option. While the TCP SACK option [RFC2018] is being steadily deployed in the Internet [All00], there is evidence that hosts are not using the SACK information when making retransmission and congestion control decisions [PF01]. The goal of this document is to outline one straightforward method for TCP implementations to use SACK information to increase performance.",
      "ja": "このドキュメントでは、選択的確認応答（SACK）TCPオプションの使用に基づく、TCPの控えめな損失回復アルゴリズムについて説明します。 TCP SACKオプション[RFC2018]がインターネット[All00]に着実に展開されている間、ホストが再送信および輻輳制御の決定[PF01]を行うときにSACK情報を使用していないという証拠があります。このドキュメントの目的は、TCP実装がSACK情報を使用してパフォーマンスを向上させる簡単な方法の1つを概説することです。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] allows advanced loss recovery algorithms to be used by TCP\n[RFC793] provided that they follow the spirit of TCP's congestion\ncontrol algorithms [RFC5681] [RFC2914].  [RFC6582] outlines one such\nadvanced recovery algorithm called NewReno.  This document outlines a\nloss recovery algorithm that uses the SACK TCP option [RFC2018] to\nenhance TCP's loss recovery.  The algorithm outlined in this\ndocument, heavily based on the algorithm detailed in [FF96], is a\nconservative replacement of the fast recovery algorithm [Jac90]\n[RFC5681].  The algorithm specified in this document is a\nstraightforward SACK-based loss recovery strategy that follows the\nguidelines set in [RFC5681] and can safely be used in TCP\nimplementations.  Alternate SACK-based loss recovery methods can be\nused in TCP as implementers see fit (as long as the alternate\nalgorithms follow the guidelines provided in [RFC5681]).  Please\nnote, however, that the SACK-based decisions in this document (such\nas what segments are to be sent at what time) are largely decoupled\nfrom the congestion control algorithms, and as such can be treated as\nseparate issues if so desired.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " This document represents a revision of [RFC3517] to address several situations that are not handled explicitly in that document. A summary of the changes between this document and [RFC3517] can be found in Section 9.",
      "ja": "このドキュメントは、そのドキュメントで明示的に処理されないいくつかの状況に対処するための[RFC3517]の改訂版を表します。この文書と[RFC3517]の間の変更点の概要は、セクション9にあります。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 BCP 14、RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The reader is expected to be familiar with the definitions given in [RFC5681].",
      "ja": "読者は[RFC5681]で与えられた定義に精通していることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The reader is assumed to be familiar with selective acknowledgments as specified in [RFC2018].",
      "ja": "読者は、[RFC2018]で指定されている選択的確認応答に精通していることを前提としています。"
    },
    {
      "indent": 3,
      "text": "For the purposes of explaining the SACK-based loss recovery algorithm, we define six variables that a TCP sender stores:",
      "ja": "SACKベースの損失回復アルゴリズムを説明する目的で、TCP送信者が格納する6つの変数を定義します。"
    },
    {
      "indent": 6,
      "text": "\"HighACK\" is the sequence number of the highest byte of data that has been cumulatively ACKed at a given point.",
      "ja": "「HighACK」は、特定のポイントで累積的にACKされたデータの最上位バイトのシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"HighData\" is the highest sequence number transmitted at a given point.",
      "ja": "「HighData」は、所定のポイントで送信される最高のシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"HighRxt\" is the highest sequence number which has been retransmitted during the current loss recovery phase.",
      "ja": "「HighRxt」は、現在の損失回復フェーズ中に再送信された最高のシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"RescueRxt\" is the highest sequence number which has been optimistically retransmitted to prevent stalling of the ACK clock when there is loss at the end of the window and no new data is available for transmission.",
      "ja": "「RescueRxt」は、ウィンドウの終わりに損失があり、送信に使用できる新しいデータがない場合に、ACKクロックのストールを防ぐために楽観的に再送信された最大のシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"Pipe\" is a sender's estimate of the number of bytes outstanding in the network. This is used during recovery for limiting the sender's sending rate. The pipe variable allows TCP to use fundamentally different congestion control than the algorithm specified in [RFC5681]. The congestion control algorithm using the pipe estimate is often referred to as the \"pipe algorithm\".",
      "ja": "「パイプ」は、ネットワークで未処理のバイト数の送信者の推定です。これは、送信者の送信レートを制限するためにリカバリ中に使用されます。パイプ変数により、TCPは[RFC5681]で指定されたアルゴリズムとは根本的に異なる輻輳制御を使用できます。パイプ推定を使用する輻輳制御アルゴリズムは、「パイプアルゴリズム」と呼ばれることがあります。"
    },
    {
      "indent": 6,
      "text": "\"DupAcks\" is the number of duplicate acknowledgments received since the last cumulative acknowledgment.",
      "ja": "「DupAcks」は、最後の累積確認応答以降に受信された重複確認応答の数です。"
    },
    {
      "indent": 0,
      "text": " For the purposes of this specification, we define a \"duplicate acknowledgment\" as a segment that arrives carrying a SACK block that identifies previously unacknowledged and un-SACKed octets between HighACK and HighData. Note that an ACK which carries new SACK data is counted as a duplicate acknowledgment under this definition even if it carries new data, changes the advertised window, or moves the cumulative acknowledgment point, which is different from the definition of duplicate acknowledgment in [RFC5681].",
      "ja": "この仕様の目的のために、「重複確認応答」を、HighACKとHighDataの間で以前に未確認で未確認のオクテットを識別するSACKブロックを運ぶセグメントとして定義します。新しいSACKデータを運ぶACKは、新しいデータを運ぶ、アドバタイズされたウィンドウを変更する、または累積確認応答ポイントを移動する場合でも、この定義の下では重複確認応答としてカウントされます。これは、[RFC5681]の重複確認応答の定義とは異なります。 。"
    },
    {
      "indent": 3,
      "text": "We define a variable \"DupThresh\" that holds the number of duplicate acknowledgments required to trigger a retransmission. Per [RFC5681], this threshold is defined to be 3 duplicate acknowledgments. However, implementers should consult any updates to [RFC5681] to determine the current value for DupThresh (or method for determining its value).",
      "ja": "再送信をトリガーするために必要な重複する確認応答の数を保持する変数「DupThresh」を定義します。 [RFC5681]に従って、このしきい値は3つの重複する確認応答として定義されています。ただし、実装者は[RFC5681]の更新を参照して、DupThreshの現在の値（またはその値を決定する方法）を決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, a range of sequence numbers [A,B] is said to \"cover\" sequence number S if A <= S <= B.",
      "ja": "最後に、シーケンス番号の範囲[A、B]は、A <= S <= Bの場合、シーケンス番号Sを「カバー」すると言われています。"
    },
    {
      "indent": 0,
      "text": "3. Keeping Track of SACK Information",
      "section_title": true,
      "ja": "3. SACK情報の追跡"
    },
    {
      "indent": 3,
      "text": "For a TCP sender to implement the algorithm defined in the next section, it must keep a data structure to store incoming selective acknowledgment information on a per connection basis. Such a data structure is commonly called the \"scoreboard\". The specifics of the scoreboard data structure are out of scope for this document (as long as the implementation can perform all functions required by this specification).",
      "ja": "TCP送信側が次のセクションで定義されたアルゴリズムを実装するには、着信の選択的確認応答情報を接続ごとに格納するためのデータ構造を保持する必要があります。このようなデータ構造は一般に「スコアボード」と呼ばれます。スコアボードデータ構造の詳細は、このドキュメントの範囲外です（この仕様で必要なすべての機能を実装が実行できる限り）。"
    },
    {
      "indent": 3,
      "text": "Note that this document refers to keeping account of (marking) individual octets of data transferred across a TCP connection. A real-world implementation of the scoreboard would likely prefer to manage this data as sequence number ranges. The algorithms presented here allow this, but require the ability to mark arbitrary sequence number ranges as having been selectively acknowledged.",
      "ja": "このドキュメントは、TCP接続を介して転送されるデータの個々のオクテット（マーク）を考慮に入れることに言及していることに注意してください。スコアボードの実際の実装では、このデータをシーケンス番号の範囲として管理することを好むでしょう。ここで紹介するアルゴリズムはこれを可能にしますが、任意のシーケンス番号の範囲を選択的に確認されたものとしてマークする機能を必要とします。"
    },
    {
      "indent": 3,
      "text": "Finally, note that the algorithm in this document assumes a sender that is not keeping track of segment boundaries after transmitting a segment. It is possible that there is a more refined and precise algorithm available to a sender that keeps this extra state than the algorithm presented herein; however, we leave this as future work.",
      "ja": "最後に、このドキュメントのアルゴリズムは、セグメントの送信後にセグメント境界を追跡していない送信者を想定していることに注意してください。ここに提示されたアルゴリズムよりも、この追加の状態を保持する、より洗練された正確なアルゴリズムを送信者が利用できる可能性があります。ただし、これは将来の作業として残します。"
    },
    {
      "indent": 0,
      "text": "4. Processing and Acting Upon SACK Information",
      "section_title": true,
      "ja": "4. SACK情報の処理と処理"
    },
    {
      "indent": 3,
      "text": "This section describes a specific structure and control flow for implementing the TCP behavior described by this standard. The behavior is what is standardized, and this particular collection of functions is the strongly recommended means of implementing that behavior, though other approaches to achieving that behavior are feasible.",
      "ja": "このセクションでは、この標準で説明されているTCP動作を実装するための特定の構造と制御フローについて説明します。動作は標準化されたものであり、この特定の機能のコレクションは、その動作を実装するための強く推奨される手段ですが、その動作を実現する他のアプローチも可能です。"
    },
    {
      "indent": 3,
      "text": "The definition of Sender Maximum Segment Size (SMSS) used in this section is provided in [RFC5681].",
      "ja": "このセクションで使用される送信者最大セグメントサイズ（SMSS）の定義は、[RFC5681]で提供されています。"
    },
    {
      "indent": 3,
      "text": "For the purposes of the algorithm defined in this document, the scoreboard SHOULD implement the following functions:",
      "ja": "このドキュメントで定義されているアルゴリズムの目的のために、スコアボードは次の関数を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Update ():",
      "ja": "更新()："
    },
    {
      "indent": 6,
      "text": "Given the information provided in an ACK, each octet that is cumulatively ACKed or SACKed should be marked accordingly in the scoreboard data structure, and the total number of octets SACKed should be recorded.",
      "ja": "ACKで提供される情報を前提として、累積的にACKまたはSACKされた各オクテットは、スコアボードデータ構造でそれに応じてマークされ、SACKされたオクテットの総数が記録されます。"
    },
    {
      "indent": 6,
      "text": "Note: SACK information is advisory and therefore SACKed data MUST NOT be removed from the TCP's retransmission buffer until the data is cumulatively acknowledged [RFC2018].",
      "ja": "注：SACK情報は参考情報であるため、データが累積的に確認されるまで、SACKされたデータをTCPの再送信バッファーから削除してはなりません[RFC2018]。"
    },
    {
      "indent": 3,
      "text": "IsLost (SeqNum):",
      "ja": "IsLost（シーケンス番号）："
    },
    {
      "indent": 6,
      "text": "This routine returns whether the given sequence number is considered to be lost. The routine returns true when either DupThresh discontiguous SACKed sequences have arrived above 'SeqNum' or more than (DupThresh - 1) * SMSS bytes with sequence numbers greater than 'SeqNum' have been SACKed. Otherwise, the routine returns false.",
      "ja": "このルーチンは、指定されたシーケンス番号が失われたと見なされるかどうかを返します。 DupThreshの不連続なSACKシーケンスが「SeqNum」を超えるか、（DupThresh-1）*（SeqNum）より大きいシーケンス番号のSMSSバイトがSACKされた場合、ルーチンはtrueを返します。それ以外の場合、ルーチンはfalseを返します。"
    },
    {
      "indent": 3,
      "text": "SetPipe ():",
      "ja": "SetPipe()："
    },
    {
      "indent": 6,
      "text": "This routine traverses the sequence space from HighACK to HighData and MUST set the \"pipe\" variable to an estimate of the number of octets that are currently in transit between the TCP sender and the TCP receiver. After initializing pipe to zero, the following steps are taken for each octet 'S1' in the sequence space between HighACK and HighData that has not been SACKed:",
      "ja": "このルーチンは、シーケンス空間をHighACKからHighDataにトラバースし、「パイプ」変数を、TCP送信者とTCP受信者の間で現在送信中のオクテット数の推定値に設定する必要があります。パイプをゼロに初期化した後、SACKされていないHighACKとHighDataの間のシーケンススペース内の各オクテット「S1」に対して次の手順が実行されます。"
    },
    {
      "indent": 6,
      "text": "(a) If IsLost (S1) returns false:",
      "ja": "（a）IsLost（S1）がfalseを返す場合："
    },
    {
      "indent": 9,
      "text": "Pipe is incremented by 1 octet.",
      "ja": "パイプは1オクテットずつ増加します。"
    },
    {
      "indent": 9,
      "text": "The effect of this condition is that pipe is incremented for packets that have not been SACKed and have not been determined to have been lost (i.e., those segments that are still assumed to be in the network).",
      "ja": "この条件の影響は、SACKされておらず、失われたと判断されていないパケット（つまり、まだネットワーク内にあると想定されているセグメント）のパイプが増加することです。"
    },
    {
      "indent": 6,
      "text": "(b) If S1 <= HighRxt:",
      "ja": "（b）S1 <= HighRxtの場合："
    },
    {
      "indent": 9,
      "text": "Pipe is incremented by 1 octet.",
      "ja": "パイプは1オクテットずつ増加します。"
    },
    {
      "indent": 9,
      "text": "The effect of this condition is that pipe is incremented for the retransmission of the octet.",
      "ja": "この条件の影響は、オクテットの再送信のためにパイプが増分されることです。"
    },
    {
      "indent": 6,
      "text": "Note that octets retransmitted without being considered lost are counted twice by the above mechanism.",
      "ja": "失われたと見なされずに再送信されたオクテットは、上記のメカニズムによって2回カウントされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "NextSeg ():",
      "ja": "NextSeg()："
    },
    {
      "indent": 6,
      "text": "This routine uses the scoreboard data structure maintained by the Update() function to determine what to transmit based on the SACK information that has arrived from the data receiver (and hence been marked in the scoreboard). NextSeg () MUST return the sequence number range of the next segment that is to be transmitted, per the following rules:",
      "ja": "このルーチンは、Update()関数によって維持されるスコアボードデータ構造を使用して、データレシーバーから到着した（したがってスコアボードにマークされている）SACK情報に基づいて何を送信するかを決定します。 NextSeg()は、次のルールに従って、送信される次のセグメントのシーケンス番号の範囲を返さなければなりません（MUST）。"
    },
    {
      "indent": 6,
      "text": "(1) If there exists a smallest unSACKed sequence number 'S2' that meets the following three criteria for determining loss, the sequence range of one segment of up to SMSS octets starting with S2 MUST be returned.",
      "ja": "（1）損失を判定するための次の3つの基準を満たす最小のSACKされていないシーケンス番号「S2」が存在する場合、S2で始まるSMSSオクテットまでの1つのセグメントのシーケンス範囲を返さなければなりません（MUST）。"
    },
    {
      "indent": 10,
      "text": "(1.a) S2 is greater than HighRxt.",
      "ja": "（1.a）S2はHighRxtより大きい。"
    },
    {
      "indent": 10,
      "text": "(1.b) S2 is less than the highest octet covered by any received SACK.",
      "ja": "（1.b）S2は、受信したSACKがカバーする最高のオクテットよりも小さい。"
    },
    {
      "indent": 10,
      "text": "(1.c) IsLost (S2) returns true.",
      "ja": "（1.c）IsLost（S2）はtrueを返します。"
    },
    {
      "indent": 6,
      "text": "(2) If no sequence number 'S2' per rule (1) exists but there exists available unsent data and the receiver's advertised window allows, the sequence range of one segment of up to SMSS octets of previously unsent data starting with sequence number HighData+1 MUST be returned.",
      "ja": "（2）ルール（1）に従ってシーケンス番号「S2」が存在しないが、使用可能な未送信データが存在し、受信側のアドバタイズされたウィンドウで許可されている場合、シーケンス番号HighData +で始まる、以前に未送信のデータの最大SMSSオクテットの1セグメントのシーケンス範囲1を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "(3) If the conditions for rules (1) and (2) fail, but there exists an unSACKed sequence number 'S3' that meets the criteria for detecting loss given in steps (1.a) and (1.b) above (specifically excluding step (1.c)), then one segment of up to SMSS octets starting with S3 SHOULD be returned.",
      "ja": "（3）ルール（1）および（2）の条件が満たされていないが、上記のステップ（1.a）および（1.b）で指定された損失を検出する基準を満たす、SACKされていないシーケンス番号「S3」が存在する場合（特にステップ（1.c）を除外すると、S3で始まるSMSSオクテットまでの1つのセグメントが返される必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "(4) If the conditions for (1), (2), and (3) fail, but there exists outstanding unSACKed data, we provide the opportunity for a single \"rescue\" retransmission per entry into loss recovery. If HighACK is greater than RescueRxt (or RescueRxt is undefined), then one segment of up to SMSS octets that MUST include the highest outstanding unSACKed sequence number SHOULD be returned, and RescueRxt set to RecoveryPoint. HighRxt MUST NOT be updated.",
      "ja": "（4）（1）、（2）、および（3）の条件が満たされていないが、SACKされていない未処理のデータが存在する場合、損失回復へのエントリごとに1回の「レスキュー」再送信の機会を提供します。 HighACKがRescueRxtよりも大きい場合（またはRescueRxtが未定義の場合）は、SMSSオクテットまでの1つのセグメントが返され、未処理の最も高いシーケンス番号を含む必要があり（SHOULD）、RescueRxtがRecoveryPointに設定されます。 HighRxtを更新してはなりません。"
    },
    {
      "indent": 0,
      "text": " Note that rules (3) and (4) are a sort of retransmission \"last resort\". They allow for retransmission of sequence numbers even when the sender has less certainty a segment has been lost than as with rule (1). Retransmitting segments via rule (3) and (4) will help sustain the TCP's ACK clock and therefore can potentially help avoid retransmission timeouts. However, in sending these segments, the sender has two copies of the same data considered to be in the network (and also in the pipe estimate, in the case of (3)). When an ACK or SACK arrives covering this retransmitted segment, the sender cannot be sure exactly how much data left the network (one of the two transmissions of the packet or both transmissions of the packet). Therefore, the sender may underestimate pipe by considering both segments to have left the network when it is possible that only one of the two has.",
      "ja": "ルール（3）と（4）は一種の再送信の「最後の手段」であることに注意してください。それらは、送信者が規則（1）の場合よりもセグメントが失われた確実性が低い場合でも、シーケンス番号の再送信を可能にします。ルール（3）および（4）を介してセグメントを再送信すると、TCPのACKクロックを維持するのに役立ち、再送信のタイムアウトを回避できる可能性があります。ただし、これらのセグメントを送信する場合、送信者はネットワーク内（および（3）の場合はパイプ推定値内）にあると見なされる同じデータの2つのコピーを持っています。この再送信されたセグメントをカバーするACKまたはSACKが到着すると、送信者はネットワークから送信されたデータ量（パケットの2つの送信のうちの1つまたはパケットの両方の送信）を正確に確認できません。したがって、送信者は、2つのうちの1つだけが可能である可能性がある場合に、両方のセグメントがネットワークを離れたと見なして、パイプを過小評価する可能性があります。"
    },
    {
      "indent": 6,
      "text": "(5) If the conditions for each of (1), (2), (3), and (4) are not met, then NextSeg () MUST indicate failure, and no segment is returned.",
      "ja": "（5）（1）、（2）、（3）、および（4）の各条件が満たされない場合、NextSeg()は失敗を示し、セグメントは返されません。"
    },
    {
      "indent": 3,
      "text": "Note: The SACK-based loss recovery algorithm outlined in this document requires more computational resources than previous TCP loss recovery strategies. However, we believe the scoreboard data structure can be implemented in a reasonably efficient manner (both in terms of computation complexity and memory usage) in most TCP implementations.",
      "ja": "注：このドキュメントで概説されているSACKベースの損失回復アルゴリズムは、以前のTCP損失回復戦略よりも多くの計算リソースを必要とします。ただし、スコアボードのデータ構造は、ほとんどのTCP実装で合理的な効率的な方法で（計算の複雑さとメモリ使用量の両方に関して）実装できると考えています。"
    },
    {
      "indent": 0,
      "text": "5. Algorithm Details",
      "section_title": true,
      "ja": "5. アルゴリズムの詳細"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of any ACK containing SACK information, the scoreboard MUST be updated via the Update () routine.",
      "ja": "SACK情報を含むACKを受信すると、Update()ルーチンを介してスコアボードを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the incoming ACK is a cumulative acknowledgment, the TCP MUST reset DupAcks to zero.",
      "ja": "着信ACKが累積確認応答である場合、TCPはDupAcksをゼロにリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the incoming ACK is a duplicate acknowledgment per the definition in Section 2 (regardless of its status as a cumulative acknowledgment), and the TCP is not currently in loss recovery, the TCP MUST increase DupAcks by one and take the following steps:",
      "ja": "着信ACKがセクション2の定義に従って重複した確認応答であり（そのステータスが累積確認応答であるかどうかに関係なく）、TCPが現在損失回復状態にない場合、TCPはDupAcksを1つ増やし、次の手順を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "(1) If DupAcks >= DupThresh, go to step (4).",
      "ja": "（1）DupAcks> = DupThreshの場合、ステップ（4）に進みます。"
    },
    {
      "indent": 7,
      "text": "Note: This check covers the case when a TCP receives SACK information for multiple segments smaller than SMSS, which can potentially prevent IsLost() (next step) from declaring a segment as lost.",
      "ja": "注：このチェックは、TCPがSMSSより小さい複数のセグメントのSACK情報を受信する場合をカバーします。これにより、IsLost()（次のステップ）がセグメントが失われたと宣言するのを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "(2) If DupAcks < DupThresh but IsLost (HighACK + 1) returns true -- indicating at least three segments have arrived above the current cumulative acknowledgment point, which is taken to indicate loss -- go to step (4).",
      "ja": "（2）DupAcks <DupThreshであるがIsLost（HighACK + 1）がtrueを返す場合-少なくとも3つのセグメントが、現在の累積確認ポイント（損失を示すと見なされる）の上に到着したことを示します-ステップ（4）に進みます。"
    },
    {
      "indent": 3,
      "text": "(3) The TCP MAY transmit previously unsent data segments as per Limited Transmit [RFC5681], except that the number of octets which may be sent is governed by pipe and cwnd as follows:",
      "ja": "（3）TCPは、送信される可能性のあるオクテットの数が次のようにpipeおよびcwndによって制御されることを除いて、制限付き送信[RFC5681]に従って、以前に送信されなかったデータセグメントを送信できます（MAY）。"
    },
    {
      "indent": 7,
      "text": "(3.1) Set HighRxt to HighACK.",
      "ja": "（3.1）HighRxtをHighACKに設定します。"
    },
    {
      "indent": 7,
      "text": "(3.2) Run SetPipe ().",
      "ja": "（3.2）SetPipe()を実行します。"
    },
    {
      "indent": 7,
      "text": "(3.3) If (cwnd - pipe) >= 1 SMSS, there exists previously unsent data, and the receiver's advertised window allows, transmit up to 1 SMSS of data starting with the octet HighData+1 and update HighData to reflect this transmission, then return to (3.2).",
      "ja": "（3.3）（cwnd-pipe）> = 1 SMSSの場合、以前に未送信のデータが存在し、受信側のアドバタイズされたウィンドウで許可されます。オクテットHighData + 1で始まる最大1 SMSSのデータを送信し、この送信を反映するようにHighDataを更新します。 （3.2）に戻る。"
    },
    {
      "indent": 7,
      "text": "(3.4) Terminate processing of this ACK.",
      "ja": "（3.4）このACKの処理を終了します。"
    },
    {
      "indent": 3,
      "text": "(4) Invoke fast retransmit and enter loss recovery as follows:",
      "ja": "（4）高速再送信を呼び出して、次のように損失回復を開始します。"
    },
    {
      "indent": 7,
      "text": "(4.1) RecoveryPoint = HighData",
      "ja": "（4.1）RecoveryPoint = HighData"
    },
    {
      "indent": 13,
      "text": "When the TCP sender receives a cumulative ACK for this data octet, the loss recovery phase is terminated.",
      "ja": "TCP送信側がこのデータオクテットの累積ACKを受信すると、損失回復フェーズが終了します。"
    },
    {
      "indent": 7,
      "text": "(4.2) ssthresh = cwnd = (FlightSize / 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "The congestion window (cwnd) and slow start threshold (ssthresh) are reduced to half of FlightSize per [RFC5681]. Additionally, note that [RFC5681] requires that any segments sent as part of the Limited Transmit mechanism not be counted in FlightSize for the purpose of the above equation.",
      "ja": "混雑ウィンドウ（cwnd）とスロースタートしきい値（ssthresh）は、[RFC5681]ごとにFlightSizeの半分に削減されます。さらに、[RFC5681]では、上記の式の目的のために、制限付き送信メカニズムの一部として送信されたすべてのセグメントがFlightSizeでカウントされないようにする必要があることに注意してください。"
    },
    {
      "indent": 7,
      "text": "(4.3) Retransmit the first data segment presumed dropped -- the segment starting with sequence number HighACK + 1. To prevent repeated retransmission of the same data or a premature rescue retransmission, set both HighRxt and RescueRxt to the highest sequence number in the retransmitted segment.",
      "ja": "（4.3）ドロップされたと推定される最初のデータセグメントを再送信します-シーケンス番号HighACK + 1で始まるセグメント。同じデータの繰り返し再送信または早期のレスキュー再送信を防ぐには、HighRxtとRescueRxtの両方を再送信セグメントの最大シーケンス番号に設定します。 。"
    },
    {
      "indent": 7,
      "text": "(4.4) Run SetPipe ()",
      "ja": "（4.4）SetPipeを実行()"
    },
    {
      "indent": 13,
      "text": "Set a \"pipe\" variable to the number of outstanding octets currently \"in the pipe\"; this is the data which has been sent by the TCP sender but for which no cumulative or selective acknowledgment has been received and the data has not been determined to have been dropped in the network. It is assumed that the data is still traversing the network path.",
      "ja": "「パイプ」変数を、現在「パイプ」にある未処理のオクテットの数に設定します。これは、TCP送信側によって送信されたが、累積的または選択的な確認応答が受信されておらず、データがネットワークにドロップされたと判断されていないデータです。データがまだネットワークパスを通過していると想定されます。"
    },
    {
      "indent": 7,
      "text": "(4.5) In order to take advantage of potential additional available cwnd, proceed to step (C) below.",
      "ja": "（4.5）使用可能な追加のcwndを利用するには、以下のステップ（C）に進みます。"
    },
    {
      "indent": 3,
      "text": "Once a TCP is in the loss recovery phase, the following procedure MUST be used for each arriving ACK:",
      "ja": "TCPが損失回復フェーズに入ったら、到着するACKごとに次の手順を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "(A) An incoming cumulative ACK for a sequence number greater than RecoveryPoint signals the end of loss recovery, and the loss recovery phase MUST be terminated. Any information contained in the scoreboard for sequence numbers greater than the new value of HighACK SHOULD NOT be cleared when leaving the loss recovery phase.",
      "ja": "（A）RecoveryPointより大きいシーケンス番号の受信累積ACKは、損失回復の終了を示し、損失回復フェーズを終了する必要があります。 HighACKの新しい値より大きいシーケンス番号のスコアボードに含まれる情報は、損失回復フェーズを終了するときにクリアしてはなりません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "(B) Upon receipt of an ACK that does not cover RecoveryPoint, the following actions MUST be taken:",
      "ja": "（B）RecoveryPointをカバーしないACKを受信すると、次のアクションを実行する必要があります。"
    },
    {
      "indent": 7,
      "text": "(B.1) Use Update () to record the new SACK information conveyed by the incoming ACK.",
      "ja": "（B.1）Update()を使用して、着信ACKによって伝えられた新しいSACK情報を記録します。"
    },
    {
      "indent": 7,
      "text": "(B.2) Use SetPipe () to re-calculate the number of octets still in the network.",
      "ja": "（B.2）SetPipe()を使用して、ネットワークに残っているオクテットの数を再計算します。"
    },
    {
      "indent": 3,
      "text": "(C) If cwnd - pipe >= 1 SMSS, the sender SHOULD transmit one or more segments as follows:",
      "ja": "（C）cwnd-pipe> = 1 SMSSの場合、送信者は次のように1つ以上のセグメントを送信する必要があります（SHOULD）。"
    },
    {
      "indent": 7,
      "text": "(C.1) The scoreboard MUST be queried via NextSeg () for the sequence number range of the next segment to transmit (if any), and the given segment sent. If NextSeg () returns failure (no data to send), return without sending anything (i.e., terminate steps C.1 -- C.5).",
      "ja": "（C.1）送信する次のセグメントのシーケンス番号の範囲（存在する場合）と送信された特定のセグメントについて、スコアボードにNextSeg()を介してクエリを送信する必要があります。 NextSeg()が失敗を返す（送信するデータがない）場合は、何も送信せずに戻ります（つまり、ステップC.1からC.5を終了します）。"
    },
    {
      "indent": 7,
      "text": "(C.2) If any of the data octets sent in (C.1) are below HighData, HighRxt MUST be set to the highest sequence number of the retransmitted segment unless NextSeg () rule (4) was invoked for this retransmission.",
      "ja": "（C.2）（C.1）で送信されたデータオクテットのいずれかがHighData未満である場合、この再送信に対してNextSeg()ルール（4）が呼び出されない限り、HighRxtは再送信されたセグメントの最大シーケンス番号に設定する必要があります。"
    },
    {
      "indent": 7,
      "text": "(C.3) If any of the data octets sent in (C.1) are above HighData, HighData must be updated to reflect the transmission of previously unsent data.",
      "ja": "（C.3）（C.1）で送信されたデータオクテットのいずれかがHighDataを超えている場合、以前送信されていないデータの送信を反映するようにHighDataを更新する必要があります。"
    },
    {
      "indent": 7,
      "text": "(C.4) The estimate of the amount of data outstanding in the network must be updated by incrementing pipe by the number of octets transmitted in (C.1).",
      "ja": "（C.4）ネットワークで未処理のデータ量の推定値は、（C.1）で送信されたオクテットの数だけパイプをインクリメントして更新する必要があります。"
    },
    {
      "indent": 7,
      "text": "(C.5) If cwnd - pipe >= 1 SMSS, return to (C.1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that steps (A) and (C) can potentially send a burst of back-to-back segments into the network if the incoming cumulative acknowledgment is for more than SMSS octets of data, or if incoming SACK blocks indicate that more than SMSS octets of data have been lost in the second half of the window.",
      "ja": "ステップ（A）および（C）は、着信累積確認がSMSSオクテットを超えるデータの場合、または着信SACKブロックがSMSSオクテットを超えることを示している場合、連続して連続するセグメントのバーストをネットワークに送信する可能性があることに注意してください。ウィンドウの後半でデータの一部が失われました。"
    },
    {
      "indent": 0,
      "text": "5.1. Retransmission Timeouts",
      "section_title": true,
      "ja": "5.1. 再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "In order to avoid memory deadlocks, the TCP receiver is allowed to discard data that has already been selectively acknowledged. As a result, [RFC2018] suggests that a TCP sender SHOULD expunge the SACK information gathered from a receiver upon a retransmission timeout (RTO) \"since the timeout might indicate that the data receiver has reneged.\" Additionally, a TCP sender MUST \"ignore prior SACK information in determining which data to retransmit.\" However, since the publication of [RFC2018], this has come to be viewed by some as too strong. It has been suggested that, as long as robust tests for reneging are present, an implementation can retain and use SACK information across a timeout event [Errata1610]. While this document does not change the specification in [RFC2018], we note that implementers should consult any updates to [RFC2018] on this subject. Further, a SACK TCP sender SHOULD utilize all SACK information made available during the loss recovery following an RTO.",
      "ja": "メモリのデッドロックを回避するために、TCPレシーバーはすでに選択的に確認応答されたデータを破棄することができます。その結果、[RFC2018]は、「タイムアウトがデータレシーバーが拒否したことを示す可能性があるため」、TCP送信者は再送信タイムアウト（RTO）時にレシーバーから収集したSACK情報を消去する必要があることを示唆しています。さらに、TCP送信側は、「再送信するデータを決定する際に、以前のSACK情報を無視する」必要があります。しかし、[RFC2018]の発行以来、これは強すぎると見られるようになった。更新の堅牢なテストが存在する限り、実装はタイムアウトイベント全体でSACK情報を保持して使用できることが示唆されています[Errata1610]。このドキュメントは[RFC2018]の仕様を変更しませんが、実装者はこの主題に関する[RFC2018]の更新を参照する必要があることに注意してください。さらに、SACK TCP送信側は、RTO後の損失回復中に利用可能になったすべてのSACK情報を利用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If an RTO occurs during loss recovery as specified in this document, RecoveryPoint MUST be set to HighData. Further, the new value of RecoveryPoint MUST be preserved and the loss recovery algorithm outlined in this document MUST be terminated. In addition, a new recovery phase (as described in Section 5) MUST NOT be initiated until HighACK is greater than or equal to the new value of RecoveryPoint.",
      "ja": "このドキュメントで指定されているように損失回復中にRTOが発生した場合、RecoveryPointをHighDataに設定する必要があります。さらに、RecoveryPointの新しい値を保持する必要があり、このドキュメントで概説されている損失回復アルゴリズムを終了する必要があります。さらに、新しいリカバリフェーズ（セクション5で説明）は、HighACKがRecoveryPointの新しい値以上になるまで開始してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "As described in Sections 4 and 5, Update () SHOULD continue to be used appropriately upon receipt of ACKs. This will allow the recovery period after an RTO to benefit from all available information provided by the receiver, even if SACK information was expunged due to the RTO.",
      "ja": "セクション4と5で説明されているように、Update()は、ACKの受信時に引き続き適切に使用される必要があります。これにより、RTOが原因でSACK情報が消去された場合でも、RTO後の回復期間は、レシーバーによって提供されるすべての利用可能な情報の恩恵を受けることができます。"
    },
    {
      "indent": 3,
      "text": "If there are segments missing from the receiver's buffer following processing of the retransmitted segment, the corresponding ACK will contain SACK information. In this case, a TCP sender SHOULD use this SACK information when determining what data should be sent in each segment following an RTO. The exact algorithm for this selection is not specified in this document (specifically NextSeg () is inappropriate during loss recovery after an RTO). A relatively straightforward approach to \"filling in\" the sequence space reported as missing should be a reasonable approach.",
      "ja": "再送信されたセグメントの処理後に受信側のバッファーから欠落しているセグメントがある場合、対応するACKにはSACK情報が含まれます。この場合、TCP送信者は、RTOに続く各セグメントでどのデータを送信するかを決定するときに、このSACK情報を使用する必要があります（SHOULD）。この選択の正確なアルゴリズムは、このドキュメントでは指定されていません（具体的には、RTO後の損失回復中にNextSeg()は不適切です）。欠落として報告されたシーケンススペースを「埋める」ための比較的単純なアプローチは、合理的なアプローチです。"
    },
    {
      "indent": 0,
      "text": "6. Managing the RTO Timer",
      "section_title": true,
      "ja": "6. RTOタイマーの管理"
    },
    {
      "indent": 3,
      "text": "The standard TCP RTO estimator is defined in [RFC6298]. Due to the fact that the SACK algorithm in this document can have an impact on the behavior of the estimator, implementers may wish to consider how the timer is managed. [RFC6298] calls for the RTO timer to be re-armed each time an ACK arrives that advances the cumulative ACK point. Because the algorithm presented in this document can keep the ACK clock going through a fairly significant loss event (comparatively longer than the algorithm described in [RFC5681]), on some networks the loss event could last longer than the RTO. In this case the RTO timer would expire prematurely and a segment that need not be retransmitted would be resent.",
      "ja": "標準のTCP RTO推定量は[RFC6298]で定義されています。このドキュメントのSACKアルゴリズムは推定器の動作に影響を与える可能性があるため、実装者はタイマーの管理方法を検討する必要があります。 [RFC6298]は、累積的なACKポイントを進めるACKが到着するたびにRTOタイマーを再起動するように要求します。このドキュメントで提示されているアルゴリズムは、ACKクロックをかなり重要な損失イベント（[RFC5681]で説明されているアルゴリズムよりも比較的長い）を通過させ続けることができるため、一部のネットワークでは、損失イベントがRTOよりも長く続く場合があります。この場合、RTOタイマーが途中で期限切れになり、再送信する必要のないセグメントが再送信されます。"
    },
    {
      "indent": 3,
      "text": "Therefore, we give implementers the latitude to use the standard [RFC6298]-style RTO management or, optionally, a more careful variant that re-arms the RTO timer on each retransmission that is sent during recovery MAY be used. This provides a more conservative timer than specified in [RFC6298], and so may not always be an attractive alternative. However, in some cases it may prevent needless retransmissions, go-back-N transmission, and further reduction of the congestion window.",
      "ja": "したがって、標準の[RFC6298]スタイルのRTO管理を使用する自由度を実装者に与えるか、オプションで、リカバリ中に送信される各再送信時にRTOタイマーを再準備するより慎重なバリアントを使用できます。これは[RFC6298]で指定されているよりも保守的なタイマーを提供するため、魅力的な代替手段とは限りません。ただし、場合によっては、不必要な再送信、ゴーバックN送信、さらには輻輳ウィンドウの削減を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "7. Research",
      "section_title": true,
      "ja": "7. 研究"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in this document is analyzed in [FF96], which shows that the above algorithm is effective in reducing transfer time over standard TCP Reno [RFC5681] when multiple segments are dropped from a window of data (especially as the number of drops increases). [AHKO97] shows that the algorithm defined in this document can greatly improve throughput in connections traversing satellite channels.",
      "ja": "このドキュメントで指定されたアルゴリズムは[FF96]で分析されています。これは、上記のアルゴリズムがデータのウィンドウから複数のセグメントがドロップされた場合（特にドロップの数が増えるにつれて）、標準のTCP Reno [RFC5681]よりも転送時間を短縮するのに効果的であることを示しています。 ）。 [AHKO97]は、このドキュメントで定義されているアルゴリズムが、衛星チャネルを通過する接続のスループットを大幅に改善できることを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The algorithm presented in this paper shares security considerations with [RFC5681]. A key difference is that an algorithm based on SACKs is more robust against attackers forging duplicate ACKs to force the TCP sender to reduce cwnd. With SACKs, TCP senders have an additional check on whether or not a particular ACK is legitimate. While not fool-proof, SACK does provide some amount of protection in this area.",
      "ja": "このホワイトペーパーで紹介するアルゴリズムは、セキュリティに関する考慮事項を[RFC5681]と共有しています。主な違いは、SACKに基づくアルゴリズムは、TCP送信者にcwndを減らすように強制する重複ACKを偽造する攻撃者に対してより堅牢であることです。 SACKを使用すると、TCP送信者は特定のACKが正当であるかどうかについて追加のチェックを行います。 SACKは確実ではありませんが、この領域である程度の保護を提供します。"
    },
    {
      "indent": 0,
      "text": " Similarly, [CPNI309] sketches a variant of a blind attack [RFC5961] whereby an attacker can spoof out-of-window data to a TCP endpoint, causing it to respond to the legitimate peer with a duplicate cumulative ACK, per [RFC793]. Adding a SACK-based requirement to trigger loss recovery effectively mitigates this attack, as the duplicate ACKs caused by out-of-window segments will not contain SACK information indicating reception of previously un-SACKED in-window data.",
      "ja": "同様に、[CPNI309]はブラインドアタック[RFC5961]のバリアントをスケッチしています。これにより、攻撃者はウィンドウ外のデータをTCPエンドポイントに偽装し、[RFC793]に従って重複する累積ACKで正当なピアに応答させることができます。 SACKベースの要件を追加して損失回復をトリガーすると、この攻撃が効果的に軽減されます。これは、ウィンドウ外のセグメントによって引き起こされる重複ACKに、以前にSACKされていないウィンドウ内データの受信を示すSACK情報が含まれないためです。"
    },
    {
      "indent": 0,
      "text": "9. Changes Relative to RFC 3517",
      "section_title": true,
      "ja": "9. RFC 3517に関連する変更"
    },
    {
      "indent": 3,
      "text": "The state variable \"DupAcks\" has been added to the list of variables maintained by this algorithm, and its usage specified.",
      "ja": "状態変数「DupAcks」は、このアルゴリズムによって維持される変数のリストに追加され、その使用法が指定されています。"
    },
    {
      "indent": 3,
      "text": "The function IsLost () has been modified to require that more than (DupThresh - 1) * SMSS octets have been SACKed above a given sequence number as indication that it is lost, which is changed from the minimum requirement of (DupThresh * SMSS) described in [RFC3517]. This retains the requirement that at least three segments following the sequence number in question have been SACKed, while improving detection in the event that the sender has outstanding segments which are smaller than SMSS.",
      "ja": "IsLost()関数は、（DupThresh-1）以上であることを要求するように変更されました* SMSSオクテットは、それが失われたことを示す所定のシーケンス番号を超えてSACKされました。これは、（DupThresh * SMSS）の最小要件から変更されています。 [RFC3517]。これは、問題のシーケンス番号に続く少なくとも3つのセグメントがSACKされているという要件を保持しながら、送信者がSMSSより小さい未解決のセグメントを持っている場合の検出を改善します。"
    },
    {
      "indent": 3,
      "text": "The definition of a \"duplicate acknowledgment\" has been modified to utilize the SACK information in detecting loss. Duplicate cumulative acknowledgments can be caused by either loss or reordering in the network. To disambiguate loss and reordering, TCP's fast retransmit algorithm [RFC5681] waits until three duplicate ACKs arrive to trigger loss recovery. This notion was then the basis for the algorithm specified in [RFC3517]. However, with SACK information there is no need to rely blindly on the cumulative acknowledgment field. We can leverage the additional information present in the SACK blocks to understand that three segments lying above a gap in the sequence space have arrived at the receiver, and can use this understanding to trigger loss recovery. This notion was used in [RFC3517] during loss recovery, and the change in this document is that the notion is also used to enter a loss recovery phase.",
      "ja": "「重複確認応答」の定義は、損失の検出にSACK情報を利用するように変更されました。重複した確認応答は、ネットワーク内での損失または並べ替えによって発生する可能性があります。損失と再順序付けを明確にするために、TCPの高速再送信アルゴリズム[RFC5681]は、3つの重複するACKが到着して損失回復をトリガーするまで待機します。この概念は、[RFC3517]で指定されたアルゴリズムの基礎となりました。ただし、SACK情報を使用すると、累積的な確認応答フィールドに盲目的に依存する必要はありません。 SACKブロックにある追加情報を活用して、シーケンススペースのギャップの上にある3つのセグメントがレシーバーに到達したことを理解し、この理解を使用して損失回復をトリガーできます。この概念は、損失復旧時に[RFC3517]で使用されました。このドキュメントの変更点は、この概念が損失復旧フェーズに入るときにも使用されることです。"
    },
    {
      "indent": 3,
      "text": "The state variable \"RescueRxt\" has been added to the list of variables maintained by the algorithm, and its usage specified. This variable is used to allow for one extra retransmission per entry into loss recovery, in order to keep the ACK clock going under certain circumstances involving loss at the end of the window. This mechanism allows for no more than one segment of no larger than 1 SMSS to be optimistically retransmitted per loss recovery.",
      "ja": "状態変数「RescueRxt」が、アルゴリズムによって維持される変数のリストに追加され、その使用法が指定されました。この変数は、ウィンドウの終わりでの損失を伴う特定の状況下でACKクロックを継続させるために、損失回復へのエントリごとに1つの追加の再送信を可能にするために使用されます。このメカニズムにより、損失回復ごとに、SMSSが1つ以下のセグメントを1つだけ楽観的に再送信できます。"
    },
    {
      "indent": 3,
      "text": "Rule (3) of NextSeg() has been changed from MAY to SHOULD, to appropriately reflect the opinion of the authors and working group that it should be left in, rather than out, if an implementor does not have a compelling reason to do otherwise.",
      "ja": "NextSeg()のルール（3）が5月からSHOULDに変更され、実装者がやむを得ない理由がない限り、除外するのではなく除外する著者およびワーキンググループの意見を適切に反映します。 。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Sally Floyd for encouraging [RFC3517] and commenting on early drafts. The algorithm described in this document is loosely based on an algorithm outlined by Kevin Fall and Sally Floyd in [FF96], although the authors of this document assume responsibility for any mistakes in the above text.",
      "ja": "著者は、サリー・フロイドに[RFC3517]を奨励し、初期草案にコメントしてくれたことに感謝したいと思います。このドキュメントで説明されているアルゴリズムは、[FF96]でKevin FallとSally Floydによって概説されたアルゴリズムに大まかに基づいていますが、このドキュメントの作成者は、上記のテキストの誤りについて責任を負います。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] was co-authored by Kevin Fall, who provided crucial input to that document and hence this follow-on work.",
      "ja": "[RFC3517]はKevin Fallによって共同執筆されました。KevinFallは、そのドキュメントに重要な情報を提供し、それによりこの後続作業に取り組みました。"
    },
    {
      "indent": 3,
      "text": "Murali Bashyam, Ken Calvert, Tom Henderson, Reiner Ludwig, Jamshid Mahdavi, Matt Mathis, Shawn Ostermann, Vern Paxson, and Venkat Venkatsubra provided valuable feedback on earlier versions of this document.",
      "ja": "Murali Bashyam、Ken Calvert、Tom Henderson、Reiner Ludwig、Jamshid Mahdavi、Matt Mathis、Shawn Ostermann、Vern Paxson、Venkat Venkatsubraは、このドキュメントの以前のバージョンに関する貴重なフィードバックを提供しました。"
    },
    {
      "indent": 3,
      "text": "We thank Matt Mathis and Jamshid Mahdavi for implementing the scoreboard in ns and hence guiding our thinking in keeping track of SACK state.",
      "ja": "nsでスコアボードを実装し、SACK状態を追跡するための考え方を導いてくれたMatt MathisとJamshid Mahdaviに感謝します。"
    },
    {
      "indent": 3,
      "text": "The first author would like to thank Ohio University and the Ohio University Internetworking Research Group for supporting the bulk of his work on RFC 3517, from which this document is derived.",
      "ja": "最初の著者は、このドキュメントの派生元であるRFC 3517に関する彼の研究の大部分をサポートしてくれたオハイオ大学とオハイオ大学インターネットワーキング研究グループに感謝します。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018] Mathis、M.、Madhavi、J.、Floyd、S。、およびA. Romanow、「TCP Selective Acknowledgement Options」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[RFC5681] Allman、M.、Paxson、V。、およびE. Blanton、「TCP Congestion Control」、RFC 5681、2009年9月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AHKO97] Mark Allman, Chris Hayes, Hans Kruse, Shawn Ostermann, \"TCP Performance Over Satellite Links\", Proceedings of the Fifth International Conference on Telecommunications Systems, Nashville, TN, March, 1997.",
      "ja": "[AHKO97]マークオールマン、クリスヘイズ、ハンスクルーゼ、ショーンオスターマン、「衛星リンクを介したTCPパフォーマンス」、第5回テレコミュニケーションシステムに関する国際会議の議事録、テネシー州ナッシュビル、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[All00] Mark Allman, \"A Web Server's View of the Transport Layer\", ACM Computer Communication Review, 30(5), October 2000.",
      "ja": "[All00] Mark Allman、「トランスポート層のWebサーバーのビュー」、ACM Computer Communication Review、30（5）、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[CPNI309] Fernando Gont, \"Security Assessment of the Transmission Control Protocol (TCP)\", CPNI Technical Note 3/2009, <http://www.gont.com.ar/papers/ tn-03-09-security-assessment-TCP.pdf>, February 2009.",
      "ja": "[CPNI309] Fernando Gont、「伝送制御プロトコル（TCP）のセキュリティ評価」、CPNIテクニカルノート3/2009、<http://www.gont.com.ar/papers/tn-03-09-security-assessment -TCP.pdf>、2009年2月。"
    },
    {
      "indent": 3,
      "text": "[Errata1610] RFC Errata, Errata ID 1610, RFC 2018, <http://www.rfc-editor.org>.",
      "ja": "[Errata1610] RFC Errata、Errata ID 1610、RFC 2018、<http://www.rfc-editor.org>。"
    },
    {
      "indent": 3,
      "text": "[FF96] Kevin Fall and Sally Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996.",
      "ja": "[FF96]ケビンフォールとサリーフロイド、「タホ、リノ、SACK TCPのシミュレーションベースの比較」、Computer Communication Review、1996年7月。"
    },
    {
      "indent": 3,
      "text": "[Jac90] Van Jacobson, \"Modified TCP Congestion Avoidance Algorithm\", Technical Report, LBL, April 1990.",
      "ja": "[Jac90]ヴァンジェイコブソン、「修正されたTCP輻輳回避アルゴリズム」、テクニカルレポート、LBL、1990年4月。"
    },
    {
      "indent": 3,
      "text": "[PF01] Jitendra Padhye, Sally Floyd \"Identifying the TCP Behavior of Web Servers\", ACM SIGCOMM, August 2001.",
      "ja": "[PF01] Jitendra Padhye、Sally Floyd「Identifying the TCP Behavior of Web Servers」、ACM SIGCOMM、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6582] Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 6582, April 2012.",
      "ja": "[RFC6582] Henderson、T.、Floyd、S.、Gurtov、A。、およびY. Nishida、「The NewReno Modification to TCP's Fast Recovery Algorithm」、RFC 6582、2012年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S。、「輻輳制御原則」、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「Computing TCP's Retransmission Timer」、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517] Blanton、E.、Allman、M.、Fall、K。、およびL. Wang、「A Conservative Selective Acknowledgement（SACK）-based Loss Recovery Algorithm for TCP」、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5961] Ramaiah, A., Stewart, R., and M. Dalal, \"Improving TCP's Robustness to Blind In-Window Attacks\", RFC 5961, August 2010.",
      "ja": "[RFC5961]ラマイア、A。、スチュワート、R。、およびM.ダラル、「ウィンドウ内のブラインド攻撃に対するTCPの堅牢性の向上」、RFC 5961、2010年8月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ethan Blanton Purdue University Computer Sciences 305 N. University St. West Lafayette, IN 47907 United States EMail: elb@psg.com",
      "ja": "Ethan Blanton Purdue University Computer Sciences 305 N. University St. West Lafayette、IN 47907 United Statesメール：elb@psg.com"
    },
    {
      "indent": 3,
      "text": "Mark Allman International Computer Science Institute 1947 Center St. Suite 600 Berkeley, CA 94704 United States EMail: mallman@icir.org http://www.icir.org/mallman",
      "ja": "Mark Allman International Computer Science Institute 1947 Center St. Suite 600 Berkeley、CA 94704 United Statesメール：mallman@icir.org http://www.icir.org/mallman"
    },
    {
      "indent": 3,
      "text": "Lili Wang Juniper Networks 10 Technology Park Drive Westford, MA 01886 United States EMail: liliw@juniper.net",
      "ja": "Lili Wang Juniper Networks 10 Technology Park Drive Westford、MA 01886 United States Eメール：liliw@juniper.net"
    },
    {
      "indent": 3,
      "text": "Ilpo Jarvinen University of Helsinki P.O. Box 68 FI-00014 UNIVERSITY OF HELSINKI Finland EMail: ilpo.jarvinen@helsinki.fi",
      "ja": "ヘルシンキイルポヤルビネン大学P.O.ボックス68 FI-00014ヘルシンキ大学フィンランドメール：ilpo.jarvinen@helsinki.fi"
    },
    {
      "indent": 3,
      "text": "Markku Kojo University of Helsinki P.O. Box 68 FI-00014 UNIVERSITY OF HELSINKI Finland EMail: kojo@cs.helsinki.fi",
      "ja": "Markku Kojoヘルシンキ大学P.O.ボックス68 FI-00014ヘルシンキ大学フィンランドメール：kojo@cs.helsinki.fi"
    },
    {
      "indent": 3,
      "text": "Yoshifumi Nishida WIDE Project Endo 5322 Fujisawa, Kanagawa 252-8520 Japan EMail: nishida@wide.ad.jp",
      "ja": "よしふみ にしだ うぃで Ｐろじぇｃｔ えんど ５３２２ ふじさわ、 かながわ ２５２ー８５２０ じゃぱん えまいｌ： にしだ＠うぃで。あｄ。ｊｐ"
    }
  ]
}