{
  "title": {
    "text": "RFC 6810 - The Resource Public Key Infrastructure (RPKI) to Router Protocol",
    "ja": "RFC 6810 - ルータープロトコルへのリソース公開キー基盤（RPKI）"
  },
  "number": 6810,
  "created_at": "2020-09-05 08:43:12.987019+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Bush\nRequest for Comments: 6810                     Internet Initiative Japan\nCategory: Standards Track                                     R. Austein\nISSN: 2070-1721                                     Dragon Research Labs\n                                                            January 2013",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "The Resource Public Key Infrastructure (RPKI) to Router Protocol",
      "ja": "ルータープロトコルへのリソース公開キー基盤（RPKI）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems of BGP announcements, routers need a simple but reliable mechanism to receive Resource Public Key Infrastructure (RFC 6480) prefix origin data from a trusted cache. This document describes a protocol to deliver validated prefix origin data to routers.",
      "ja": "BGPアナウンスの発信元自律システムを検証可能に検証するには、信頼できるキャッシュからリソース公開鍵インフラストラクチャ（RFC 6480）プレフィックス発信元データを受信するためのシンプルで信頼性の高いメカニズムがルーターに必要です。このドキュメントでは、検証済みのプレフィックス起点データをルーターに配信するためのプロトコルについて説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6810.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6810で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Requirements Language  . . . . . . . . . . . . . . . . . .  3\n2.  Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . .  3\n3.  Deployment Structure . . . . . . . . . . . . . . . . . . . . .  4\n4.  Operational Overview . . . . . . . . . . . . . . . . . . . . .  4\n5.  Protocol Data Units (PDUs) . . . . . . . . . . . . . . . . . .  6\n  5.1.  Fields of a PDU  . . . . . . . . . . . . . . . . . . . . .  6\n  5.2.  Serial Notify  . . . . . . . . . . . . . . . . . . . . . .  8\n  5.3.  Serial Query . . . . . . . . . . . . . . . . . . . . . . .  8\n  5.4.  Reset Query  . . . . . . . . . . . . . . . . . . . . . . .  9\n  5.5.  Cache Response . . . . . . . . . . . . . . . . . . . . . .  9\n  5.6.  IPv4 Prefix  . . . . . . . . . . . . . . . . . . . . . . . 10\n  5.7.  IPv6 Prefix  . . . . . . . . . . . . . . . . . . . . . . . 11\n  5.8.  End of Data  . . . . . . . . . . . . . . . . . . . . . . . 12\n  5.9.  Cache Reset  . . . . . . . . . . . . . . . . . . . . . . . 12\n  5.10. Error Report . . . . . . . . . . . . . . . . . . . . . . . 12\n6.  Protocol Sequences . . . . . . . . . . . . . . . . . . . . . . 14\n  6.1.  Start or Restart . . . . . . . . . . . . . . . . . . . . . 14\n  6.2.  Typical Exchange . . . . . . . . . . . . . . . . . . . . . 15\n  6.3.  No Incremental Update Available  . . . . . . . . . . . . . 15\n  6.4.  Cache Has No Data Available  . . . . . . . . . . . . . . . 16\n7.  Transport  . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n  7.1.  SSH Transport  . . . . . . . . . . . . . . . . . . . . . . 18\n  7.2.  TLS Transport  . . . . . . . . . . . . . . . . . . . . . . 18\n  7.3.  TCP MD5 Transport  . . . . . . . . . . . . . . . . . . . . 19\n  7.4.  TCP-AO Transport . . . . . . . . . . . . . . . . . . . . . 19\n8.  Router-Cache Setup . . . . . . . . . . . . . . . . . . . . . . 20\n9.  Deployment Scenarios . . . . . . . . . . . . . . . . . . . . . 21\n10. Error Codes  . . . . . . . . . . . . . . . . . . . . . . . . . 22\n11. Security Considerations  . . . . . . . . . . . . . . . . . . . 23\n12. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 24\n13. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 25\n14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n  14.1. Normative References . . . . . . . . . . . . . . . . . . . 25\n  14.2. Informative References . . . . . . . . . . . . . . . . . . 26",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems (ASes) of BGP announcements, routers need a simple but reliable mechanism to receive Resource Public Key Infrastructure (RPKI) [RFC6480] cryptographically validated prefix origin data from a trusted cache. This document describes a protocol to deliver validated prefix origin data to routers. The design is intentionally constrained to be usable on much of the current generation of ISP router platforms.",
      "ja": "BGPアナウンスの発信元自律システム（AS）を検証可能に検証するために、ルーターは、信頼できるキャッシュから暗号化検証された接頭辞発信元データを暗号化して検証するResource Public Key Infrastructure（RPKI）[RFC6480]を受信するためのシンプルで信頼できるメカニズムを必要とします。このドキュメントでは、検証済みのプレフィックス起点データをルーターに配信するためのプロトコルについて説明します。この設計は、現在の世代のISPルータープラットフォームの多くで使用できるように意図的に制限されています。"
    },
    {
      "indent": 3,
      "text": "Section 3 describes the deployment structure, and Section 4 then presents an operational overview. The binary payloads of the protocol are formally described in Section 5, and the expected PDU sequences are described in Section 6. The transport protocol options are described in Section 7. Section 8 details how routers and caches are configured to connect and authenticate. Section 9 describes likely deployment scenarios. The traditional security and IANA considerations end the document.",
      "ja": "セクション3では配備構造について説明し、セクション4では操作の概要を示します。プロトコルのバイナリペイロードについてはセクション5で正式に説明し、予想されるPDUシーケンスについてはセクション6で説明します。トランスポートプロトコルオプションについてはセクション7で説明します。セクション8では、ルーターとキャッシュを構成して接続および認証する方法について詳しく説明します。セクション9では、考えられる展開シナリオについて説明します。従来のセキュリティとIANAの考慮事項により、ドキュメントは終了します。"
    },
    {
      "indent": 3,
      "text": "The protocol is extensible in order to support new PDUs with new semantics, if deployment experience indicates they are needed. PDUs are versioned should deployment experience call for change.",
      "ja": "展開の経験から必要とされる場合、プロトコルは新しいセマンティクスで新しいPDUをサポートするために拡張可能です。 PDUは、展開の経験から変更が必要になった場合にバージョン管理されます。"
    },
    {
      "indent": 3,
      "text": "For an implementation (not interoperability) report, see [RTR-IMPL]",
      "ja": "実装（相互運用性ではない）レポートについては、[RTR-IMPL]を参照してください"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119] only when they appear in all upper case. They may also appear in lower or mixed case as English words, without special meaning.",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。また、特別な意味を持たずに、英語の単語として小文字または大文字と小文字が混在する場合もあります。"
    },
    {
      "indent": 0,
      "text": "2. Glossary",
      "section_title": true,
      "ja": "2. 用語集"
    },
    {
      "indent": 3,
      "text": "The following terms are used with special meaning.",
      "ja": "以下の用語は特別な意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers at the IANA, Regional Internet Registries (RIRs), National Internet Registry (NIRs), and ISPs; see [RFC6481].",
      "ja": "グローバルRPKI：RPKIの信頼できるデータは、IANA、地域インターネットレジストリ（RIR）、全国インターネットレジストリ（NIR）、およびISPの分散サーバーセットで公開されます。 [RFC6481]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Cache: A coalesced copy of the RPKI, which is periodically fetched/ refreshed directly or indirectly from the Global RPKI using the [RFC5781] protocol/tools. Relying party software is used to gather and validate the distributed data of the RPKI into a cache. Trusting this cache further is a matter between the provider of the cache and a relying party.",
      "ja": "キャッシュ：[RFC5781]プロトコル/ツールを使用してグローバルRPKIから直接または間接的に定期的にフェッチ/リフレッシュされるRPKIの合体コピー。証明書利用者ソフトウェアは、RPKIの分散データを収集してキャッシュに検証するために使用されます。このキャッシュをさらに信頼することは、キャッシュのプロバイダーと依存パーティの間の問題です。"
    },
    {
      "indent": 3,
      "text": "Serial Number: A 32-bit strictly increasing unsigned integer that wraps from 2^32-1 to 0. It denotes the logical version of a cache. A cache increments the value when it successfully updates its data from a parent cache or from primary RPKI data. As a cache is receiving, new incoming data and implicit deletes are associated with the new serial but MUST NOT be sent until the fetch is complete. A Serial Number is not commensurate between caches, nor need it be maintained across resets of the cache server. See [RFC1982] on DNS Serial Number Arithmetic for too much detail on the topic.",
      "ja": "シリアル番号：2 ^ 32-1から0にラップする32ビットの厳密に増加する符号なし整数。これは、キャッシュの論理バージョンを示します。キャッシュは、親キャッシュまたはプライマリRPKIデータからデータを正常に更新すると、値をインクリメントします。キャッシュを受信すると、新しい着信データと暗黙的な削除が新しいシリアルに関連付けられますが、フェッチが完了するまで送信してはなりません。シリアル番号は、キャッシュ間で釣り合っているわけではなく、キャッシュサーバーのリセット後も維持する必要はありません。このトピックの詳細については、DNSシリアル番号演算の[RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Session ID: When a cache server is started, it generates a session identifier to uniquely identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache.",
      "ja": "セッションID：キャッシュサーバーが起動すると、キャッシュのインスタンスを一意に識別し、それをキャッシュインスタンスが生成するシリアル番号のシーケンスにバインドするためのセッション識別子が生成されます。これにより、ルーターは、使用しているシリアル番号がキャッシュのシリアル番号に対応していることを認識して、失敗したセッションを再開できます。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Structure",
      "section_title": true,
      "ja": "3. 展開構造"
    },
    {
      "indent": 3,
      "text": "Deployment of the RPKI to reach routers has a three-level structure as follows:",
      "ja": "ルーターに到達するためのRPKIの展開は、次の3つのレベルの構造になっています。"
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers, RPKI publication repositories, e.g., the IANA, RIRs, NIRs, and ISPs, see [RFC6481].",
      "ja": "グローバルRPKI：RPKIの信頼できるデータは、IANA、RIR、NIR、ISPなどのサーバー、RPKI発行リポジトリの分散セットで公開されます。[RFC6481]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Local Caches: A local set of one or more collected and verified caches. A relying party, e.g., router or other client, MUST have a trust relationship with, and a trusted transport channel to, any authoritative cache(s) it uses.",
      "ja": "ローカルキャッシュ：1つ以上の収集および検証されたキャッシュのローカルセット。依存パーティ、たとえばルーターや他のクライアントは、それが使用するすべての信頼できるキャッシュとの信頼関係と信頼されたトランスポートチャネルを持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "Routers: A router fetches data from a local cache using the protocol described in this document. It is said to be a client of the cache. There MAY be mechanisms for the router to assure itself of the authenticity of the cache and to authenticate itself to the cache.",
      "ja": "ルーター：ルーターは、このドキュメントで説明されているプロトコルを使用して、ローカルキャッシュからデータをフェッチします。キャッシュのクライアントと言われています。ルータがキャッシュ自体の信頼性を保証し、キャッシュに対して自身を認証するメカニズムが存在する場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Operational Overview",
      "section_title": true,
      "ja": "4. 運用の概要"
    },
    {
      "indent": 3,
      "text": "A router establishes and keeps open a connection to one or more caches with which it has client/server relationships. It is configured with a semi-ordered list of caches, and establishes a connection to the most preferred cache, or set of caches, which accept the connections.",
      "ja": "ルーターは、クライアント/サーバー関係を持つ1つ以上のキャッシュへの接続を確立し、開いたままにします。これは、キャッシュの半順序リストで構成され、接続を受け入れる最も好ましいキャッシュまたはキャッシュのセットへの接続を確立します。"
    },
    {
      "indent": 3,
      "text": "The router MUST choose the most preferred, by configuration, cache or set of caches so that the operator may control load on their caches and the Global RPKI.",
      "ja": "オペレーターは、キャッシュとグローバルRPKIの負荷を制御できるように、ルーターは構成、キャッシュ、またはキャッシュのセットによって最も好ましいものを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Periodically, the router sends to the cache the Serial Number of the highest numbered data it has received from that cache, i.e., the router's current Serial Number. When a router establishes a new connection to a cache, or wishes to reset a current relationship, it sends a Reset Query.",
      "ja": "ルーターは定期的に、キャッシュから受信した最も高い番号のデータのシリアル番号、つまりルーターの現在のシリアル番号をキャッシュに送信します。ルータがキャッシュへの新しい接続を確立するか、現在の関係をリセットする場合、リセットクエリを送信します。"
    },
    {
      "indent": 3,
      "text": "The Cache responds with all data records that have Serial Numbers greater than that in the router's query. This may be the null set, in which case the End of Data PDU is still sent. Note that 'greater' must take wrap-around into account, see [RFC1982].",
      "ja": "キャッシュは、ルーターのクエリのシリアル番号より大きいシリアル番号を持つすべてのデータレコードで応答します。これはヌルセットである場合があります。その場合、End of Data PDUは引き続き送信されます。 'greater'はラップアラウンドを考慮する必要があることに注意してください。[RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When the router has received all data records from the cache, it sets its current Serial Number to that of the Serial Number in the End of Data PDU.",
      "ja": "ルーターは、キャッシュからすべてのデータレコードを受信すると、現在のシリアル番号をEnd of Data PDUのシリアル番号に設定します。"
    },
    {
      "indent": 3,
      "text": "When the cache updates its database, it sends a Notify message to every currently connected router. This is a hint that now would be a good time for the router to poll for an update, but is only a hint. The protocol requires the router to poll for updates periodically in any case.",
      "ja": "キャッシュがデータベースを更新すると、現在接続されているすべてのルーターに通知メッセージが送信されます。これは、ルーターが更新をポーリングする良いタイミングですが、ヒントにすぎません。このプロトコルでは、ルーターが更新を定期的にポーリングする必要があります。"
    },
    {
      "indent": 3,
      "text": "Strictly speaking, a router could track a cache simply by asking for a complete data set every time it updates, but this would be very inefficient. The Serial Number based incremental update mechanism allows an efficient transfer of just the data records that have changed since last update. As with any update protocol based on incremental transfers, the router must be prepared to fall back to a full transfer if for any reason the cache is unable to provide the necessary incremental data. Unlike some incremental transfer protocols, this protocol requires the router to make an explicit request to start the fallback process; this is deliberate, as the cache has no way of knowing whether the router has also established sessions with other caches that may be able to provide better service.",
      "ja": "厳密に言えば、ルーターは更新するたびに完全なデータセットを要求するだけでキャッシュを追跡できますが、これは非常に非効率的です。シリアル番号ベースの増分更新メカニズムにより、最後の更新以降に変更されたデータレコードのみを効率的に転送できます。インクリメンタル転送に基づく更新プロトコルと同様に、何らかの理由でキャッシュが必要なインクリメンタルデータを提供できない場合、ルーターはフル転送にフォールバックする準備をする必要があります。一部のインクリメンタル転送プロトコルとは異なり、このプロトコルでは、ルーターがフォールバックプロセスを開始するための明示的な要求を行う必要があります。これは意図的なものです。キャッシュには、ルーターが他のキャッシュとのセッションも確立しているかどうかを知る方法がないため、より良いサービスを提供できる可能性があるからです。"
    },
    {
      "indent": 3,
      "text": "As a cache server must evaluate certificates and ROAs (Route Origin Attestations; see [RFC6480]), which are time dependent, servers' clocks MUST be correct to a tolerance of approximately an hour.",
      "ja": "キャッシュサーバーは、時間に依存する証明書とROA（Route Origin Attestations; [RFC6480]を参照）を評価する必要があるため、サーバーのクロックは約1時間の許容誤差で正確でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Protocol Data Units (PDUs)",
      "section_title": true,
      "ja": "5. プロトコルデータユニット（PDU）"
    },
    {
      "indent": 3,
      "text": "The exchanges between the cache and the router are sequences of exchanges of the following PDUs according to the rules described in Section 6.",
      "ja": "キャッシュとルーター間の交換は、セクション6で説明されているルールに従って、次のPDUの交換シーケンスです。"
    },
    {
      "indent": 3,
      "text": "Fields with unspecified content MUST be zero on transmission and MAY be ignored on receipt.",
      "ja": "未指定の内容のフィールドは、送信時にゼロでなければならず、受信時に無視してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.1. Fields of a PDU",
      "section_title": true,
      "ja": "5.1. PDUのフィールド"
    },
    {
      "indent": 3,
      "text": "PDUs contain the following data elements:",
      "ja": "PDUには、次のデータ要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "Protocol Version: An eight-bit unsigned integer, currently 0, denoting the version of this protocol.",
      "ja": "プロトコルバージョン：このプロトコルのバージョンを示す、現在0である8ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "PDU Type: An eight-bit unsigned integer, denoting the type of the PDU, e.g., IPv4 Prefix, etc.",
      "ja": "PDUタイプ：8ビットの符号なし整数。IPv4プレフィックスなど、PDUのタイプを示します。"
    },
    {
      "indent": 3,
      "text": "Serial Number: The Serial Number of the RPKI Cache when this set of PDUs was received from an upstream cache server or gathered from the Global RPKI. A cache increments its Serial Number when completing a rigorously validated update from a parent cache or the Global RPKI.",
      "ja": "シリアル番号：このPDUのセットが上流のキャッシュサーバーから受信されたとき、またはグローバルRPKIから収集されたときのRPKIキャッシュのシリアル番号。キャッシュは、親キャッシュまたはグローバルRPKIから厳密に検証された更新を完了すると、シリアル番号をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "Session ID: When a cache server is started, it generates a Session ID to identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache. If, at any time, either the router or the cache finds the value of the session identifier is not the same as the other's, they MUST completely drop the session and the router MUST flush all data learned from that cache.",
      "ja": "セッションID：キャッシュサーバーが起動すると、キャッシュのインスタンスを識別し、キャッシュインスタンスが生成するシリアル番号のシーケンスにバインドするためにセッションIDを生成します。これにより、ルーターは、使用しているシリアル番号がキャッシュのシリアル番号に対応していることを認識して、失敗したセッションを再開できます。いつでも、ルーターまたはキャッシュのいずれかがセッション識別子の値が他のものと同じでないことを発見した場合、それらはセッションを完全にドロップしなければならず、ルーターはそのキャッシュから学習したすべてのデータをフラッシュしなければなりません。"
    },
    {
      "indent": 0,
      "text": " Should a cache erroneously reuse a Session ID so that a router does not realize that the session has changed (old session ID and new session ID have same numeric value), the router may become confused as to the content of the cache. The time it takes the router to discover it is confused will depend on whether the Serial Numbers are also reused. If the Serial Numbers in the old and new sessions are different enough, the cache will respond to the router's Serial Query with a Cache Reset, which will solve the problem. If, however, the Serial Numbers are close, the cache may respond with a Cache Response, which may not be enough to bring the router into sync. In such cases, it's likely but not certain that the router will detect some discrepancy between the state that the cache expects and its own state. For example, the Cache Response may tell the router to drop a record that the router does not hold, or may tell the router to add a record that the router already has. In such cases, a router will detect the error and reset the session. The one case in which the router may stay out of sync is when nothing in the Cache Response contradicts any data currently held by the router.",
      "ja": "キャッシュが誤ってセッションIDを再利用して、ルーターがセッションの変更を認識しない場合（古いセッションIDと新しいセッションIDの数値が同じ）、ルーターはキャッシュの内容に関して混乱する可能性があります。ルーターが混乱していることをルーターが検出するのにかかる時間は、シリアル番号も再利用されるかどうかによって異なります。古いセッションと新しいセッションのシリアル番号が十分に異なる場合、キャッシュはルーターのシリアルクエリにキャッシュリセットで応答し、問題を解決します。ただし、シリアル番号が近い場合、キャッシュはキャッシュ応答で応答する可能性があり、ルーターを同期させるのに十分ではない可能性があります。このような場合、キャッシュが予期する状態とそれ自身の状態との間の何らかの不一致をルーターが検出する可能性は高いですが、確実ではありません。たとえば、キャッシュ応答は、ルーターが保持していないレコードをドロップするようにルーターに指示したり、ルーターがすでに持っているレコードを追加するようにルーターに指示したりする場合があります。このような場合、ルーターはエラーを検出してセッションをリセットします。ルーターが同期していない可能性がある1つのケースは、キャッシュ応答の何も現在ルーターが保持しているデータと矛盾しない場合です。"
    },
    {
      "indent": 6,
      "text": "Using persistent storage for the session identifier or a clock-based scheme for generating session identifiers should avoid the risk of session identifier collisions.",
      "ja": "セッション識別子に永続ストレージを使用するか、セッション識別子を生成するために時間ベースのスキームを使用すると、セッション識別子の衝突のリスクを回避できます。"
    },
    {
      "indent": 6,
      "text": "The Session ID might be a pseudo-random value, a strictly increasing value if the cache has reliable storage, etc.",
      "ja": "セッションIDは、疑似ランダム値、キャッシュに信頼できるストレージがある場合は厳密に増加する値などになります。"
    },
    {
      "indent": 3,
      "text": "Length: A 32-bit unsigned integer that has as its value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field.",
      "ja": "長さ：PDU全体のバイト数を値として持つ32ビットの符号なし整数。長さフィールドで終わるヘッダーの8バイトを含みます。"
    },
    {
      "indent": 3,
      "text": "Flags: The lowest order bit of the Flags field is 1 for an announcement and 0 for a withdrawal, whether this PDU announces a new right to announce the prefix or withdraws a previously announced right. A withdraw effectively deletes one previously announced IPvX (IPv4 or IPv6) Prefix PDU with the exact same Prefix, Length, Max-Len, and Autonomous System Number (ASN).",
      "ja": "Flags：Flagsフィールドの最下位ビットは、このPDUがプレフィックスをアナウンスする新しい権利をアナウンスするか、以前にアナウンスされた権利を撤回するかに関係なく、アナウンスの場合は1、撤回の場合は0です。撤回は、以前に発表された1つのプレフィックス、長さ、最大長、および自律システム番号（ASN）がまったく同じIPvX（IPv4またはIPv6）プレフィックスPDUを効果的に削除します。"
    },
    {
      "indent": 3,
      "text": "Prefix Length: An 8-bit unsigned integer denoting the shortest prefix allowed for the prefix.",
      "ja": "接頭辞の長さ：接頭辞に許可される最短の接頭辞を示す8ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Max Length: An 8-bit unsigned integer denoting the longest prefix allowed by the prefix. This MUST NOT be less than the Prefix Length element.",
      "ja": "最大長：プレフィックスで許可される最長のプレフィックスを示す8ビットの符号なし整数。これは、接頭辞の長さの要素より短くしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix: The IPv4 or IPv6 prefix of the ROA.",
      "ja": "プレフィックス：ROAのIPv4またはIPv6プレフィックス。"
    },
    {
      "indent": 3,
      "text": "Autonomous System Number: ASN allowed to announce this prefix, a 32-bit unsigned integer.",
      "ja": "自律システム番号：ASNは、32ビットの符号なし整数であるこのプレフィックスのアナウンスを許可されています。"
    },
    {
      "indent": 3,
      "text": "Zero: Fields shown as zero or reserved MUST be zero. The value of such a field MUST be ignored on receipt.",
      "ja": "ゼロ：ゼロまたは予約済みとして表示されるフィールドはゼロでなければなりません。このようなフィールドの値は、受信時には無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Serial Notify",
      "section_title": true,
      "ja": "5.2. シリアル通知"
    },
    {
      "indent": 3,
      "text": "The cache notifies the router that the cache has new data.",
      "ja": "キャッシュは、キャッシュに新しいデータがあることをルーターに通知します。"
    },
    {
      "indent": 3,
      "text": "The Session ID reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、シリアル番号が釣り合っていること、つまりキャッシュセッションが変更されていないことをルーターに保証します。"
    },
    {
      "indent": 3,
      "text": "Serial Notify is the only message that the cache can send that is not in response to a message from the router.",
      "ja": "シリアル通知は、ルーターからのメッセージに応答しない、キャッシュが送信できる唯一のメッセージです。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    0     |    0     |                     |\n+-------------------------------------------+\n|                                           |\n|                Length=12                  |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. Serial Query",
      "section_title": true,
      "ja": "5.3. シリアルクエリ"
    },
    {
      "indent": 3,
      "text": "Serial Query: The router sends Serial Query to ask the cache for all payload PDUs that have Serial Numbers higher than the Serial Number in the Serial Query.",
      "ja": "シリアルクエリ：ルーターはシリアルクエリを送信して、シリアルクエリのシリアル番号よりも大きいシリアル番号を持つすべてのペイロードPDUをキャッシュに要求します。"
    },
    {
      "indent": 3,
      "text": "The cache replies to this query with a Cache Response PDU (Section 5.5) if the cache has a, possibly null, record of the changes since the Serial Number specified by the router. If there have been no changes since the router last queried, the cache sends an End Of Data PDU.",
      "ja": "キャッシュには、ルーターによって指定されたシリアル番号以降の変更のレコードがnullの可能性がある場合、キャッシュ応答PDU（セクション5.5）でこのクエリに応答します。ルータが最後に照会されてから変更がない場合、キャッシュはデータの終わりPDUを送信します。"
    },
    {
      "indent": 3,
      "text": "If the cache does not have the data needed to update the router, perhaps because its records do not go back to the Serial Number in the Serial Query, then it responds with a Cache Reset PDU (Section 5.9).",
      "ja": "ルータの更新に必要なデータがキャッシュにない場合、おそらくそのクエリがシリアルクエリのシリアル番号に戻らないため、キャッシュリセットPDUで応答します（セクション5.9）。"
    },
    {
      "indent": 3,
      "text": "The Session ID tells the cache what instance the router expects to ensure that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、シリアル番号が釣り合っていることを保証するためにルーターが期待するインスタンスをキャッシュに通知します。つまり、キャッシュセッションは変更されていません。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    0     |    1     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=12                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.4. Reset Query",
      "section_title": true,
      "ja": "5.4. クエリをリセット"
    },
    {
      "indent": 3,
      "text": "Reset Query: The router tells the cache that it wants to receive the total active, current, non-withdrawn database. The cache responds with a Cache Response PDU (Section 5.5).",
      "ja": "クエリのリセット：ルーターは、アクティブで現在の非撤回データベースの合計を受信することをキャッシュに通知します。キャッシュは、キャッシュ応答PDUで応答します（セクション5.5）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |    reserved = zero  |\n|    0     |    2     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.5. Cache Response",
      "section_title": true,
      "ja": "5.5. キャッシュ応答"
    },
    {
      "indent": 3,
      "text": "Cache Response: The cache responds with zero or more payload PDUs. When replying to a Serial Query request (Section 5.3), the cache sends the set of all data records it has with Serial Numbers greater than that sent by the client router. When replying to a Reset Query, the cache sends the set of all data records it has; in this case, the withdraw/announce field in the payload PDUs MUST have the value 1 (announce).",
      "ja": "キャッシュ応答：キャッシュは、0個以上のペイロードPDUで応答します。シリアルクエリ要求（5.3節）に応答するとき、キャッシュは、クライアントルーターが送信したものよりも大きなシリアル番号を持つ、すべてのデータレコードのセットを送信します。リセットクエリに応答するとき、キャッシュは持っているすべてのデータレコードのセットを送信します。この場合、ペイロードPDUのwithdraw / announceフィールドの値は1（announce）である必要があります。"
    },
    {
      "indent": 3,
      "text": "In response to a Reset Query, the new value of the Session ID tells the router the instance of the cache session for future confirmation. In response to a Serial Query, the Session ID being the same reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not changed.",
      "ja": "リセットクエリに応答して、セッションIDの新しい値は、将来の確認のためにキャッシュセッションのインスタンスをルーターに通知します。シリアルクエリに応じて、セッションIDが同じであることにより、シリアル番号が釣り合っていること、つまりキャッシュセッションが変更されていないことをルーターに保証します。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    0     |    3     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.6. IPv4 Prefix",
      "section_title": true,
      "ja": "5.6. IPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |    reserved = zero  |\n|    0     |    4     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=20                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |   0..32  |   0..32  |          |\n+-------------------------------------------+\n|                                           |\n|                IPv4 Prefix                |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The lowest order bit of the Flags field is 1 for an announcement and 0 for a withdrawal.",
      "ja": "Flagsフィールドの最下位ビットは、アナウンスの場合は1、取り下げの場合は0です。"
    },
    {
      "indent": 3,
      "text": "In the RPKI, nothing prevents a signing certificate from issuing two identical ROAs. In this case, there would be no semantic difference between the objects, merely a process redundancy.",
      "ja": "RPKIでは、署名証明書が2つの同一のROAを発行することを妨げるものはありません。この場合、オブジェクト間に意味的な違いはなく、単にプロセスの冗長性があります。"
    },
    {
      "indent": 0,
      "text": " In the RPKI, there is also an actual need for what might appear to a router as identical IPvX PDUs. This can occur when an upstream certificate is being reissued or there is an address ownership transfer up the validation chain. The ROA would be identical in the router sense, i.e., have the same {Prefix, Len, Max-Len, ASN}, but a different validation path in the RPKI. This is important to the RPKI, but not to the router.",
      "ja": "RPKIでは、同一のIPvX PDUとしてルーターから見えるものに対する実際のニーズもあります。これは、上流の証明書が再発行されている場合、または検証チェーンの上位にアドレス所有権が転送されている場合に発生する可能性があります。 ROAはルーターの意味で同一です。つまり、{Prefix、Len、Max-Len、ASN}は同じですが、RPKIの検証パスは異なります。これはRPKIにとって重要ですが、ルーターにとっては重要ではありません。"
    },
    {
      "indent": 3,
      "text": "The cache server MUST ensure that it has told the router client to have one and only one IPvX PDU for a unique {Prefix, Len, Max-Len, ASN} at any one point in time. Should the router client receive an IPvX PDU with a {Prefix, Len, Max-Len, ASN} identical to one it already has active, it SHOULD raise a Duplicate Announcement Received error.",
      "ja": "キャッシュサーバーは、ルータークライアントに一意の{Prefix、Len、Max-Len、ASN}のIPvX PDUを1つだけ持つように指示したことを確認する必要があります。ルータクライアントが、すでにアクティブになっているものと同じ{Prefix、Len、Max-Len、ASN}を持つIPvX PDUを受信した場合、Duplicate Announcement Receivedエラーを発生させる必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7. IPv6 Prefix",
      "section_title": true,
      "ja": "5.7. IPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |    reserved = zero  |\n|    0     |    6     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=32                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |  0..128  |  0..128  |          |\n+-------------------------------------------+\n|                                           |\n+---                                     ---+\n|                                           |\n+---            IPv6 Prefix              ---+\n|                                           |\n+---                                     ---+\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Analogous to the IPv4 Prefix PDU, it has 96 more bits and no magic.",
      "ja": "IPv4プレフィックスPDUと同様に、96ビット以上あり、魔法はありません。"
    },
    {
      "indent": 0,
      "text": "5.8. End of Data",
      "section_title": true,
      "ja": "5.8. データの終わり"
    },
    {
      "indent": 3,
      "text": "End of Data: The cache tells the router it has no more data for the request.",
      "ja": "データの終わり：キャッシュは、リクエストに対してこれ以上データがないことをルーターに通知します。"
    },
    {
      "indent": 3,
      "text": "The Session ID MUST be the same as that of the corresponding Cache Response that began the, possibly null, sequence of data PDUs.",
      "ja": "セッションIDは、データPDUのシーケンス（おそらくnull）を開始した対応するキャッシュ応答のIDと同じでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    0     |    7     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=12                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.9. Cache Reset",
      "section_title": true,
      "ja": "5.9. キャッシュリセット"
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query informing the router that the cache cannot provide an incremental update starting from the Serial Number specified by the router. The router must decide whether to issue a Reset Query or switch to a different cache.",
      "ja": "キャッシュはシリアルクエリに応答し、ルーターが指定したシリアル番号から始まる増分更新をキャッシュが提供できないことをルーターに通知します。ルーターは、リセットクエリを発行するか、別のキャッシュに切り替えるかを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |    reserved = zero  |\n|    0     |    8     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.10. Error Report",
      "section_title": true,
      "ja": "5.10. エラーレポート"
    },
    {
      "indent": 3,
      "text": "This PDU is used by either party to report an error to the other.",
      "ja": "このPDUは、どちらか一方が他方にエラーを報告するために使用します。"
    },
    {
      "indent": 3,
      "text": "Error reports are only sent as responses to other PDUs.",
      "ja": "エラーレポートは、他のPDUへの応答としてのみ送信されます。"
    },
    {
      "indent": 3,
      "text": "The Error Code is described in Section 10.",
      "ja": "エラーコードについては、セクション10で説明します。"
    },
    {
      "indent": 3,
      "text": "If the error is generic (e.g., \"Internal Error\") and not associated with the PDU to which it is responding, the Erroneous PDU field MUST be empty and the Length of Encapsulated PDU field MUST be zero.",
      "ja": "エラーが一般的であり（「内部エラー」など）、それが応答しているPDUに関連付けられていない場合、エラーのあるPDUフィールドは空である必要があり、カプセル化されたPDUフィールドの長さはゼロである必要があります。"
    },
    {
      "indent": 3,
      "text": "An Error Report PDU MUST NOT be sent for an Error Report PDU. If an erroneous Error Report PDU is received, the session SHOULD be dropped.",
      "ja": "Error Report PDUに対してError Report PDUを送信してはならない（MUST NOT）。誤ったエラーレポートPDUを受信した場合、セッションをドロップする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If the error is associated with a PDU of excessive length, i.e., too long to be any legal PDU other than another Error Report, or a possibly corrupt length, the Erroneous PDU field MAY be truncated.",
      "ja": "エラーが長すぎるPDU、つまり長すぎて別のエラーレポート以外の正当なPDUにならない、または破損している可能性がある長さに関連付けられている場合、エラーPDUフィールドは切り捨てられる場合があります。"
    },
    {
      "indent": 3,
      "text": "The diagnostic text is optional; if not present, the Length of Error Text field MUST be zero. If error text is present, it MUST be a string in UTF-8 encoding (see [RFC3269]).",
      "ja": "診断テキストはオプションです。存在しない場合、Length of Error Textフィールドはゼロでなければなりません。エラーテキストが存在する場合、UTF-8エンコーディングの文字列である必要があります（[RFC3269]を参照）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Error Code      |\n|    0     |    10    |                     |\n+-------------------------------------------+\n|                                           |\n|                  Length                   |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|       Length of Encapsulated PDU          |\n|                                           |\n+-------------------------------------------+\n|                                           |\n~           Copy of Erroneous PDU           ~\n|                                           |\n+-------------------------------------------+\n|                                           |\n|           Length of Error Text            |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Arbitrary Text               |\n|                    of                     |\n~          Error Diagnostic Message         ~\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Protocol Sequences",
      "section_title": true,
      "ja": "6. プロトコルシーケンス"
    },
    {
      "indent": 3,
      "text": "The sequences of PDU transmissions fall into three conversations as follows:",
      "ja": "PDU送信のシーケンスは、次の3つの会話に分類されます。"
    },
    {
      "indent": 0,
      "text": "6.1. Start or Restart",
      "section_title": true,
      "ja": "6.1. 開始または再起動"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <----- Reset Query -------- | R requests data (or Serial Query)\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- IPvX Prefix ------> | C sends zero or more\n  | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n  | ------- IPvX Prefix ------> |   Payload PDUs\n  | ------  End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When a transport session is first established, the router MAY send a Reset Query and the cache responds with a data sequence of all data it contains.",
      "ja": "トランスポートセッションが最初に確立されたとき、ルーターはリセットクエリを送信することができ（MAY）、キャッシュはそれに含まれるすべてのデータのデータシーケンスで応答します。"
    },
    {
      "indent": 3,
      "text": "Alternatively, if the router has significant unexpired data from a broken session with the same cache, it MAY start with a Serial Query containing the Session ID from the previous session to ensure the Serial Numbers are commensurate.",
      "ja": "または、ルーターに、同じキャッシュを使用した壊れたセッションからの有効期限の切れていない重要なデータがある場合は、前のセッションのセッションIDを含むシリアルクエリから始めて、シリアル番号が釣り合っていることを確認できます。"
    },
    {
      "indent": 3,
      "text": "This Reset Query sequence is also used when the router receives a Cache Reset, chooses a new cache, or fears that it has otherwise lost its way.",
      "ja": "このリセットクエリシーケンスは、ルータがキャッシュリセットを受信したり、新しいキャッシュを選択したり、別の方法で失われたりする恐れがある場合にも使用されます。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep the data necessary to generate incremental updates, a router MUST send either a Serial Query or a Reset Query no less frequently than once an hour. This also acts as a keep-alive at the application layer.",
      "ja": "キャッシュが増分更新を生成するために必要なデータを保持しなければならない時間の長さを制限するために、ルーターはシリアルクエリまたはリセットクエリを1時間に1回以上送信する必要があります。これは、アプリケーション層でのキープアライブとしても機能します。"
    },
    {
      "indent": 3,
      "text": "As the cache MAY not keep updates for little more than one hour, the router MUST have a polling interval of no greater than once an hour.",
      "ja": "キャッシュは1時間弱更新を保持しない可能性があるため、ルーターのポーリング間隔は1時間に1回以下にする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Typical Exchange",
      "section_title": true,
      "ja": "6.2. 典型的な交換"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | -------- Notify ----------> |  (optional)\n  |                             |\n  | <----- Serial Query ------- | R requests data\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- IPvX Prefix ------> | C sends zero or more\n  | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n  | ------- IPvX Prefix ------> |   Payload PDUs\n  | ------  End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache server SHOULD send a notify PDU with its current Serial Number when the cache's serial changes, with the expectation that the router MAY then issue a Serial Query earlier than it otherwise might. This is analogous to DNS NOTIFY in [RFC1996]. The cache MUST rate limit Serial Notifies to no more frequently than one per minute.",
      "ja": "キャッシュサーバーは、キャッシュのシリアルが変更されたときに、ルーターが現在よりも早くシリアルクエリを発行できることを期待して、現在のシリアル番号を含む通知PDUを送信する必要があります（SHOULD）。これは、[RFC1996]のDNS NOTIFYに類似しています。キャッシュは、シリアル通知を1分あたり1回以下にレート制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the transport layer is up and either a timer has gone off in the router, or the cache has sent a Notify, the router queries for new data by sending a Serial Query, and the cache sends all data newer than the serial in the Serial Query.",
      "ja": "トランスポート層が起動し、ルーターでタイマーがオフになったか、キャッシュが通知を送信した場合、ルーターはシリアルクエリを送信して新しいデータを照会し、キャッシュはシリアル内のシリアルよりも新しいすべてのデータを送信しますクエリ。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep old withdraws, a router MUST send either a Serial Query or a Reset Query no less frequently than once an hour.",
      "ja": "キャッシュが古い引き出しを保持しなければならない時間の長さを制限するために、ルーターは1時間に1回以上、シリアルクエリまたはリセットクエリを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. No Incremental Update Available",
      "section_title": true,
      "ja": "6.3. 増分更新はありません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <-----  Serial Query ------ | R requests data\n  | ------- Cache Reset ------> | C cannot supply update\n  |                             |   from specified serial\n  | <------ Reset Query ------- | R requests new data\n  | ----- Cache Response -----> | C confirms request\n  | ------- IPvX Prefix ------> | C sends zero or more\n  | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n  | ------- IPvX Prefix ------> |   Payload PDUs\n  | ------  End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query with a Cache Reset, informing the router that the cache cannot supply an incremental update from the Serial Number specified by the router. This might be because the cache has lost state, or because the router has waited too long between polls and the cache has cleaned up old data that it no longer believes it needs, or because the cache has run out of storage space and had to expire some old data early. Regardless of how this state arose, the cache replies with a Cache Reset to tell the router that it cannot honor the request. When a router receives this, the router SHOULD attempt to connect to any more preferred caches in its cache list. If there are no more preferred caches, it MUST issue a Reset Query and get an entire new load from the cache.",
      "ja": "キャッシュはシリアルクエリにキャッシュリセットで応答し、ルーターが指定したシリアル番号からの増分更新をキャッシュが提供できないことをルーターに通知します。これは、キャッシュの状態が失われたか、ルーターがポーリング間で待ちすぎて、キャッシュが古いデータをクリーンアップして、必要と思わなくなったためか、キャッシュの記憶域が不足して期限切れになったことが原因である可能性がありますいくつかの古いデータが早い。この状態がどのように発生したかに関係なく、キャッシュはキャッシュリセットで応答し、要求を受け入れることができないことをルーターに通知します。ルータがこれを受信すると、ルータはそのキャッシュリスト内のより優先されるキャッシュへの接続を試みる必要があります。優先キャッシュがなくなった場合は、リセットクエリを発行して、キャッシュから新しいロード全体を取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. Cache Has No Data Available",
      "section_title": true,
      "ja": "6.4. キャッシュに使用可能なデータがありません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <-----  Serial Query ------ | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <-----  Reset Query ------- | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache may respond to either a Serial Query or a Reset Query informing the router that the cache cannot supply any update at all. The most likely cause is that the cache has lost state, perhaps due to a restart, and has not yet recovered. While it is possible that a cache might go into such a state without dropping any of its active sessions, a router is more likely to see this behavior when it initially connects and issues a Reset Query while the cache is still rebuilding its database.",
      "ja": "キャッシュは、シリアルクエリまたはリセットクエリに応答して、キャッシュが更新をまったく提供できないことをルータに通知します。最も可能性の高い原因は、おそらく再起動が原因でキャッシュの状態が失われ、まだ回復していないことです。キャッシュがアクティブなセッションを削除せずにこのような状態になる可能性はありますが、ルーターが最初に接続し、キャッシュがデータベースを再構築しているときにリセットクエリを発行すると、ルーターがこの動作をする可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "When a router receives this kind of error, the router SHOULD attempt to connect to any other caches in its cache list, in preference order. If no other caches are available, the router MUST issue periodic Reset Queries until it gets a new usable load from the cache.",
      "ja": "ルーターがこの種のエラーを受信した場合、ルーターは、キャッシュリスト内の他のキャッシュに優先順に接続する必要があります（SHOULD）。他に使用可能なキャッシュがない場合、ルーターは、キャッシュから新しい使用可能なロードを取得するまで、定期的にリセットクエリを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Transport",
      "section_title": true,
      "ja": "7. 輸送"
    },
    {
      "indent": 3,
      "text": "The transport-layer session between a router and a cache carries the binary PDUs in a persistent session.",
      "ja": "ルーターとキャッシュ間のトランスポート層セッションは、永続的なセッションでバイナリPDUを伝送します。"
    },
    {
      "indent": 3,
      "text": "To prevent cache spoofing and DoS attacks by illegitimate routers, it is highly desirable that the router and the cache be authenticated to each other. Integrity protection for payloads is also desirable to protect against monkey-in-the-middle (MITM) attacks. Unfortunately, there is no protocol to do so on all currently used platforms. Therefore, as of the writing of this document, there is no mandatory-to-implement transport that provides authentication and integrity protection.",
      "ja": "不正なルーターによるキャッシュスプーフィングやDoS攻撃を防ぐには、ルーターとキャッシュが相互に認証されることが非常に望ましいです。ペイロードの完全性保護は、中間者攻撃（MITM）攻撃から保護するためにも望ましいです。残念ながら、現在使用されているすべてのプラットフォームでこれを行うプロトコルはありません。したがって、このドキュメントの執筆時点では、認証と整合性保護を提供する必須から実装へのトランスポートはありません。"
    },
    {
      "indent": 3,
      "text": "To reduce exposure to dropped but non-terminated sessions, both caches and routers SHOULD enable keep-alives when available in the chosen transport protocol.",
      "ja": "ドロップされたが終了していないセッションへの露出を減らすために、キャッシュとルーターの両方で、選択されたトランスポートプロトコルで利用可能な場合にキープアライブを有効にする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "It is expected that, when the TCP Authentication Option (TCP-AO) [RFC5925] is available on all platforms deployed by operators, it will become the mandatory-to-implement transport.",
      "ja": "オペレーターが展開したすべてのプラットフォームでTCP認証オプション（TCP-AO）[RFC5925]が利用できる場合、それは必須から実装へのトランスポートになることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MUST implement unprotected transport over TCP using a port, rpki-rtr (323); see Section 12. Operators SHOULD use procedural means, e.g., access control lists (ACLs), to reduce the exposure to authentication issues.",
      "ja": "キャッシュとルーターは、ポートrpki-rtr（323）を使用して、TCPを介した保護されていないトランスポートを実装する必要があります。セクション12を参照してください。オペレーターは、認証問題への露出を減らすために、アクセス制御リスト（ACL）などの手続き的な手段を使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Caches and routers SHOULD use TCP-AO, SSHv2, TCP MD5, or IPsec transport.",
      "ja": "キャッシュとルーターは、TCP-AO、SSHv2、TCP MD5、またはIPsecトランスポートを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If unprotected TCP is the transport, the cache and routers MUST be on the same trusted and controlled network.",
      "ja": "保護されていないTCPがトランスポートである場合、キャッシュとルーターは同じ信頼され制御されたネットワーク上になければなりません。"
    },
    {
      "indent": 3,
      "text": "If available to the operator, caches and routers MUST use one of the following more protected protocols.",
      "ja": "オペレーターが利用できる場合、キャッシュとルーターは、次のより保護されたプロトコルのいずれかを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Caches and routers SHOULD use TCP-AO transport [RFC5925] over the rpki-rtr port.",
      "ja": "キャッシュとルーターは、rpki-rtrポートでTCP-AOトランスポート[RFC5925]を使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MAY use SSHv2 transport [RFC4252] using a the normal SSH port. For an example, see Section 7.1.",
      "ja": "キャッシュとルーターは、通常のSSHポートを使用してSSHv2トランスポート[RFC4252]を使用してもよい（MAY）。例については、7.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MAY use TCP MD5 transport [RFC2385] using the rpki-rtr port. Note that TCP MD5 has been obsoleted by TCP-AO [RFC5925].",
      "ja": "キャッシュとルーターは、rpki-rtrポートを使用してTCP MD5トランスポート[RFC2385]を使用してもよい（MAY）。 TCP MD5はTCP-AO [RFC5925]によって廃止されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MAY use IPsec transport [RFC4301] using the rpki-rtr port.",
      "ja": "キャッシュとルーターは、rpki-rtrポートを使用してIPsecトランスポート[RFC4301]を使用してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MAY use TLS transport [RFC5246] using a port, rpki-rtr-tls (324); see Section 12.",
      "ja": "キャッシュとルーターは、ポートrpki-rtr-tls（324）を使用してTLSトランスポート[RFC5246]を使用してもよい（MAY）。セクション12を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1. SSH Transport",
      "section_title": true,
      "ja": "7.1. SSHトランスポート"
    },
    {
      "indent": 3,
      "text": "To run over SSH, the client router first establishes an SSH transport connection using the SSHv2 transport protocol, and the client and server exchange keys for message integrity and encryption. The client then invokes the \"ssh-userauth\" service to authenticate the application, as described in the SSH authentication protocol [RFC4252]. Once the application has been successfully authenticated, the client invokes the \"ssh-connection\" service, also known as the SSH connection protocol.",
      "ja": "SSHを介して実行するには、クライアントルーターは最初にSSHv2トランスポートプロトコルを使用してSSHトランスポート接続を確立し、クライアントとサーバーはメッセージの整合性と暗号化のために鍵を交換します。次に、SSH認証プロトコル[RFC4252]で説明されているように、クライアントは \"ssh-userauth\"サービスを呼び出してアプリケーションを認証します。アプリケーションが正常に認証されると、クライアントは「ssh-connection」サービス（SSH接続プロトコルとも呼ばれます）を呼び出します。"
    },
    {
      "indent": 3,
      "text": "After the ssh-connection service is established, the client opens a channel of type \"session\", which results in an SSH session.",
      "ja": "ssh-connectionサービスが確立されると、クライアントは「セッション」タイプのチャネルを開き、SSHセッションが発生します。"
    },
    {
      "indent": 3,
      "text": "Once the SSH session has been established, the application invokes the application transport as an SSH subsystem called \"rpki-rtr\". Subsystem support is a feature of SSH version 2 (SSHv2) and is not included in SSHv1. Running this protocol as an SSH subsystem avoids the need for the application to recognize shell prompts or skip over extraneous information, such as a system message that is sent at shell start-up.",
      "ja": "SSHセッションが確立されると、アプリケーションは「rpki-rtr」と呼ばれるSSHサブシステムとしてアプリケーショントランスポートを呼び出します。サブシステムサポートはSSHバージョン2（SSHv2）の機能であり、SSHv1には含まれていません。このプロトコルをSSHサブシステムとして実行すると、アプリケーションがシェルプロンプトを認識したり、シェルの起動時に送信されるシステムメッセージなどの無関係な情報をスキップしたりする必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the router and cache have exchanged keys out of band by some reasonably secured means.",
      "ja": "ルーターとキャッシュは、ある程度安全な方法で帯域外の鍵を交換したと想定されています。"
    },
    {
      "indent": 3,
      "text": "Cache servers supporting SSH transport MUST accept RSA and Digital Signature Algorithm (DSA) authentication and SHOULD accept Elliptic Curve Digital Signature Algorithm (ECDSA) authentication. User authentication MUST be supported; host authentication MAY be supported. Implementations MAY support password authentication. Client routers SHOULD verify the public key of the cache to avoid monkey-in-the-middle attacks.",
      "ja": "SSHトランスポートをサポートするキャッシュサーバーは、RSAおよびデジタル署名アルゴリズム（DSA）認証を受け入れる必要があり、楕円曲線デジタル署名アルゴリズム（ECDSA）認証を受け入れる必要があります。ユーザー認証をサポートする必要があります。ホスト認証がサポートされる場合があります。実装はパスワード認証をサポートしてもよい（MAY）。クライアントルータは、中間者攻撃を回避するためにキャッシュの公開鍵を検証する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "7.2. TLS Transport",
      "section_title": true,
      "ja": "7.2. TLSトランスポート"
    },
    {
      "indent": 3,
      "text": "Client routers using TLS transport MUST present client-side certificates to authenticate themselves to the cache in order to allow the cache to manage the load by rejecting connections from unauthorized routers. In principle, any type of certificate and certificate authority (CA) may be used; however, in general, cache operators will wish to create their own small-scale CA and issue certificates to each authorized router. This simplifies credential rollover; any unrevoked, unexpired certificate from the proper CA may be used.",
      "ja": "TLSトランスポートを使用するクライアントルーターは、不正なルーターからの接続を拒否してキャッシュが負荷を管理できるようにするために、クライアント側の証明書を提示してキャッシュに対して認証する必要があります。原則として、あらゆるタイプの証明書および認証局（CA）を使用できます。ただし、一般に、キャッシュオペレーターは独自の小規模CAを作成し、承認された各ルーターに証明書を発行します。これにより、資格情報のロールオーバーが簡素化されます。適切なCAからの失効していない有効期限のない証明書を使用できます。"
    },
    {
      "indent": 3,
      "text": "Certificates used to authenticate client routers in this protocol MUST include a subjectAltName extension [RFC5280] containing one or more iPAddress identities; when authenticating the router's certificate, the cache MUST check the IP address of the TLS connection against these iPAddress identities and SHOULD reject the connection if none of the iPAddress identities match the connection.",
      "ja": "このプロトコルでクライアントルーターの認証に使用される証明書には、1つ以上のiPAddress IDを含むsubjectAltName拡張[RFC5280]が含まれている必要があります。ルーターの証明書を認証するとき、キャッシュはこれらのiPAddress IDに対してTLS接続のIPアドレスをチェックしなければならず、どのiPAddress IDも接続と一致しない場合は接続を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Routers MUST also verify the cache's TLS server certificate, using subjectAltName dNSName identities as described in [RFC6125], to avoid monkey-in-the-middle attacks. The rules and guidelines defined in [RFC6125] apply here, with the following considerations:",
      "ja": "ルーターは、[RFC6125]で説明されているように、subjectAltName dNSName IDを使用してキャッシュのTLSサーバー証明書も検証し、中間者攻撃を回避する必要があります。 [RFC6125]で定義されているルールとガイドラインは、次の点を考慮してここに適用されます。"
    },
    {
      "indent": 6,
      "text": "Support for DNS-ID identifier type (that is, the dNSName identity in the subjectAltName extension) is REQUIRED in rpki-rtr server and client implementations that use TLS. Certification authorities that issue rpki-rtr server certificates MUST support the DNS-ID identifier type, and the DNS-ID identifier type MUST be present in rpki-rtr server certificates.",
      "ja": "TLSを使用するrpki-rtrサーバーおよびクライアントの実装では、DNS-ID識別子タイプ（つまり、subjectAltName拡張のdNSName ID）のサポートが必要です。 rpki-rtrサーバー証明書を発行する認証局はDNS-ID識別子タイプをサポートする必要があり、DNS-ID識別子タイプはrpki-rtrサーバー証明書に存在する必要があります。"
    },
    {
      "indent": 6,
      "text": "DNS names in rpki-rtr server certificates SHOULD NOT contain the wildcard character \"*\".",
      "ja": "rpki-rtrサーバー証明書のDNS名には、ワイルドカード文字「*」を含めないでください。"
    },
    {
      "indent": 6,
      "text": "rpki-rtr implementations that use TLS MUST NOT use CN-ID identifiers; a CN field may be present in the server certificate's subject name, but MUST NOT be used for authentication within the rules described in [RFC6125].",
      "ja": "TLSを使用するrpki-rtr実装は、CN-ID識別子を使用してはならない（MUST NOT）。 CNフィールドはサーバー証明書のサブジェクト名に存在する可能性がありますが、[RFC6125]で説明されているルール内の認証に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "The client router MUST set its \"reference identifier\" to the DNS name of the rpki-rtr cache.",
      "ja": "クライアントルータは、その「参照識別子」をrpki-rtrキャッシュのDNS名に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. TCP MD5 Transport",
      "section_title": true,
      "ja": "7.3. TCP MD5トランスポート"
    },
    {
      "indent": 3,
      "text": "If TCP MD5 is used, implementations MUST support key lengths of at least 80 printable ASCII bytes, per Section 4.5 of [RFC2385]. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits.",
      "ja": "TCP MD5を使用する場合、実装は[RFC2385]のセクション4.5に従って、少なくとも80の印刷可能なASCIIバイトのキー長をサポートする必要があります。実装は、少なくとも32文字、つまり128ビットの16進シーケンスもサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Key rollover with TCP MD5 is problematic. Cache servers SHOULD support [RFC4808].",
      "ja": "TCP MD5でのキーロールオーバーには問題があります。キャッシュサーバーは[RFC4808]をサポートするべきです[SHOULD]。"
    },
    {
      "indent": 0,
      "text": "7.4. TCP-AO Transport",
      "section_title": true,
      "ja": "7.4. TCP-AOトランスポート"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support key lengths of at least 80 printable ASCII bytes. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits. MAC (Message Authentication Code) lengths of at least 96 bits MUST be supported, per Section 5.1 of [RFC5925].",
      "ja": "実装では、少なくとも80の印刷可能なASCIIバイトのキー長をサポートする必要があります。実装は、少なくとも32文字、つまり128ビットの16進シーケンスもサポートする必要があります。 [RFC5925]のセクション5.1に従って、少なくとも96ビットのMAC（メッセージ認証コード）の長さがサポートされている必要があります。"
    },
    {
      "indent": 3,
      "text": "The cryptographic algorithms and associated parameters described in [RFC5926] MUST be supported.",
      "ja": "[RFC5926]で説明されている暗号化アルゴリズムと関連パラメータをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Router-Cache Setup",
      "section_title": true,
      "ja": "8. ルーターキャッシュの設定"
    },
    {
      "indent": 3,
      "text": "A cache has the public authentication data for each router it is configured to support.",
      "ja": "キャッシュには、サポートするように構成されている各ルーターのパブリック認証データがあります。"
    },
    {
      "indent": 3,
      "text": "A router may be configured to peer with a selection of caches, and a cache may be configured to support a selection of routers. Each must have the name of, and authentication data for, each peer. In addition, in a router, this list has a non-unique preference value for each server. This preference merely denotes proximity, not trust, preferred belief, etc. The client router attempts to establish a session with each potential serving cache in preference order, and then starts to load data from the most preferred cache to which it can connect and authenticate. The router's list of caches has the following elements:",
      "ja": "ルーターは、選択したキャッシュとピアリングするように構成でき、キャッシュは、選択したルーターをサポートするように構成できます。各ピアには、各ピアの名前と認証データが必要です。さらに、ルーターでは、このリストには各サーバーの一意でない優先値があります。この設定は、単に信頼度ではなく近接度を表すだけです。クライアントルーターは、優先順位に従って潜在的な各サービングキャッシュとのセッションの確立を試み、接続して認証できる最も優先度の高いキャッシュからデータのロードを開始します。ルータのキャッシュリストには、次の要素があります。"
    },
    {
      "indent": 3,
      "text": "Preference: An unsigned integer denoting the router's preference to connect to that cache; the lower the value, the more preferred.",
      "ja": "設定：そのキャッシュに接続するルーターの設定を示す符号なし整数。値が小さいほど優先されます。"
    },
    {
      "indent": 3,
      "text": "Name: The IP address or fully qualified domain name of the cache.",
      "ja": "名前：キャッシュのIPアドレスまたは完全修飾ドメイン名。"
    },
    {
      "indent": 3,
      "text": "Key: Any needed public key of the cache.",
      "ja": "キー：必要なキャッシュの公開キー。"
    },
    {
      "indent": 3,
      "text": "MyKey: Any needed private key or certificate of this client.",
      "ja": "MyKey：このクライアントの必要な秘密鍵または証明書。"
    },
    {
      "indent": 3,
      "text": "Due to the distributed nature of the RPKI, caches simply cannot be rigorously synchronous. A client may hold data from multiple caches but MUST keep the data marked as to source, as later updates MUST affect the correct data.",
      "ja": "RPKIは分散されているため、キャッシュを厳密に同期させることはできません。クライアントは複数のキャッシュからのデータを保持できますが、後の更新は正しいデータに影響を与える必要があるため、データをソースとしてマークしておく必要があります。"
    },
    {
      "indent": 3,
      "text": "Just as there may be more than one covering ROA from a single cache, there may be multiple covering ROAs from multiple caches. The results are as described in [RFC6811].",
      "ja": "単一のキャッシュからカバーする複数のROAがあるように、複数のキャッシュからカバーする複数のROAがある場合があります。結果は[RFC6811]で説明されているとおりです。"
    },
    {
      "indent": 3,
      "text": "If data from multiple caches are held, implementations MUST NOT distinguish between data sources when performing validation.",
      "ja": "複数のキャッシュからのデータが保持されている場合、実装は、検証を実行するときにデータソースを区別してはなりません。"
    },
    {
      "indent": 3,
      "text": "When a more preferred cache becomes available, if resources allow, it would be prudent for the client to start fetching from that cache.",
      "ja": "より優先されるキャッシュが使用可能になったときに、リソースが許せば、クライアントがそのキャッシュからフェッチを開始するのが賢明です。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD attempt to maintain at least one set of data, regardless of whether it has chosen a different cache or established a new connection to the previous cache.",
      "ja": "クライアントは、別のキャッシュを選択したか、以前のキャッシュへの新しい接続を確立したかに関係なく、少なくとも1セットのデータを維持しようとします（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A client MAY drop the data from a particular cache when it is fully in sync with one or more other caches.",
      "ja": "クライアントは、1つ以上の他のキャッシュと完全に同期しているときに、特定のキャッシュからデータを削除する場合があります。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD delete the data from a cache when it has been unable to refresh from that cache for a configurable timer value. The default for that value is twice the polling period for that cache.",
      "ja": "クライアントは、構成可能なタイマー値のキャッシュからデータを更新できなかった場合、キャッシュからデータを削除する必要があります（SHOULD）。その値のデフォルトは、そのキャッシュのポーリング期間の2倍です。"
    },
    {
      "indent": 3,
      "text": "If a client loses connectivity to a cache it is using, or otherwise decides to switch to a new cache, it SHOULD retain the data from the previous cache until it has a full set of data from one or more other caches. Note that this may already be true at the point of connection loss if the client has connections to more than one cache.",
      "ja": "クライアントが使用しているキャッシュへの接続を失うか、または別の方法で新しいキャッシュに切り替えることを決定した場合、クライアントは、1つ以上の他のキャッシュからのデータの完全なセットを持つまで、以前のキャッシュのデータを保持する必要があります。クライアントが複数のキャッシュへの接続を持っている場合、これは接続が失われた時点ですでに当てはまる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "9. Deployment Scenarios",
      "section_title": true,
      "ja": "9. 導入シナリオ"
    },
    {
      "indent": 3,
      "text": "For illustration, we present three likely deployment scenarios.",
      "ja": "説明のために、考えられる3つの展開シナリオを示します。"
    },
    {
      "indent": 3,
      "text": "Small End Site: The small multihomed end site may wish to outsource the RPKI cache to one or more of their upstream ISPs. They would exchange authentication material with the ISP using some out-of-band mechanism, and their router(s) would connect to the cache(s) of one or more upstream ISPs. The ISPs would likely deploy caches intended for customer use separately from the caches with which their own BGP speakers peer.",
      "ja": "小規模なエンドサイト：小規模なマルチホームのエンドサイトは、RPKIキャッシュを1つまたは複数の上流ISPにアウトソーシングしたい場合があります。彼らは何らかのアウトオブバンドメカニズムを使用してISPと認証情報を交換し、ルーターは1つ以上の上流ISPのキャッシュに接続します。 ISPは、顧客の使用を意図したキャッシュを、自社のBGPスピーカーがピアリングするキャッシュとは別に展開する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Large End Site: A larger multihomed end site might run one or more caches, arranging them in a hierarchy of client caches, each fetching from a serving cache that is closer to the Global RPKI. They might configure fall-back peerings to upstream ISP caches.",
      "ja": "大規模なエンドサイト：大規模なマルチホームのエンドサイトは、1つ以上のキャッシュを実行し、それらをクライアントキャッシュの階層に配置し、それぞれがグローバルRPKIに近いサービングキャッシュからフェッチする場合があります。アップストリームISPキャッシュへのフォールバックピアリングを構成する場合があります。"
    },
    {
      "indent": 3,
      "text": "ISP Backbone: A large ISP would likely have one or more redundant caches in each major point of presence (PoP), and these caches would fetch from each other in an ISP-dependent topology so as not to place undue load on the Global RPKI.",
      "ja": "ISPバックボーン：大規模なISPは、各主要拠点（PoP）に1つ以上の冗長キャッシュを備えている可能性が高く、これらのキャッシュは、グローバルRPKIに過度の負荷をかけないように、ISP依存トポロジで互いにフェッチします。"
    },
    {
      "indent": 3,
      "text": "Experience with large DNS cache deployments has shown that complex topologies are ill-advised as it is easy to make errors in the graph, e.g., not maintain a loop-free condition.",
      "ja": "大規模なDNSキャッシュ導入の経験から、ループのない状態を維持できないなど、グラフでエラーが発生しやすいため、複雑なトポロジは不適切であることがわかっています。"
    },
    {
      "indent": 3,
      "text": "Of course, these are illustrations and there are other possible deployment strategies. It is expected that minimizing load on the Global RPKI servers will be a major consideration.",
      "ja": "もちろん、これらは例示であり、他の可能な展開戦略があります。グローバルRPKIサーバーの負荷を最小限に抑えることが重要な検討事項になると予想されます。"
    },
    {
      "indent": 3,
      "text": "To keep load on Global RPKI services from unnecessary peaks, it is recommended that primary caches that load from the distributed Global RPKI not do so all at the same times, e.g., on the hour. Choose a random time, perhaps the ISP's AS number modulo 60 and jitter the inter-fetch timing.",
      "ja": "不要なピークからグローバルRPKIサービスへの負荷を維持するために、分散グローバルRPKIからロードする一次キャッシュが同時に、たとえば1時間にそうしないことをお勧めします。ランダムな時間、おそらくISPのAS番号モジュロ60を選択し、フェッチ間タイミングにジッタを与えます。"
    },
    {
      "indent": 0,
      "text": "10. Error Codes",
      "section_title": true,
      "ja": "10. エラーコード"
    },
    {
      "indent": 3,
      "text": "This section contains a preliminary list of error codes. The authors expect additions to the list this section during development of the initial implementations. There is an IANA registry where valid error codes are listed; see Section 12. Errors that are considered fatal SHOULD cause the session to be dropped.",
      "ja": "このセクションには、エラーコードの暫定的なリストが含まれています。著者は、初期実装の開発中に、このセクションのリストへの追加を期待しています。有効なエラーコードがリストされているIANAレジストリがあります。セクション12を参照してください。致命的と見なされるエラーは、セッションをドロップする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "0: Corrupt Data (fatal): The receiver believes the received PDU to be corrupt in a manner not specified by other error codes.",
      "ja": "0：データの破損（致命的）：受信側は、受信したPDUが他のエラーコードで指定されていない方法で破損していると考えています。"
    },
    {
      "indent": 3,
      "text": "1: Internal Error (fatal): The party reporting the error experienced some kind of internal error unrelated to protocol operation (ran out of memory, a coding assertion failed, et cetera).",
      "ja": "1：内部エラー（致命的）：エラーを報告した当事者が、プロトコル操作に関係のない何らかの内部エラーを経験しました（メモリ不足、コーディングアサーションの失敗など）。"
    },
    {
      "indent": 3,
      "text": "2: No Data Available: The cache believes itself to be in good working order, but is unable to answer either a Serial Query or a Reset Query because it has no useful data available at this time. This is likely to be a temporary error, and most likely indicates that the cache has not yet completed pulling down an initial current data set from the Global RPKI system after some kind of event that invalidated whatever data it might have previously held (reboot, network partition, et cetera).",
      "ja": "2：使用可能なデータがない：キャッシュは正常に動作していると考えていますが、現時点で使用できる有用なデータがないため、シリアルクエリまたはリセットクエリのいずれにも応答できません。これは一時的なエラーである可能性が高く、以前に保持していた可能性のあるデータを無効化した何らかのイベント（再起動、ネットワーク）の後、キャッシュがグローバルRPKIシステムから初期の現在のデータセットのプルダウンをまだ完了していないことを示していますパーティションなど）。"
    },
    {
      "indent": 3,
      "text": "3: Invalid Request (fatal): The cache server believes the client's request to be invalid.",
      "ja": "3：無効なリクエスト（致命的）：キャッシュサーバーは、クライアントのリクエストが無効であると考えています。"
    },
    {
      "indent": 3,
      "text": "4: Unsupported Protocol Version (fatal): The Protocol Version is not known by the receiver of the PDU.",
      "ja": "4：サポートされていないプロトコルバージョン（致命的）：プロトコルバージョンはPDUの受信者に認識されていません。"
    },
    {
      "indent": 3,
      "text": "5: Unsupported PDU Type (fatal): The PDU Type is not known by the receiver of the PDU.",
      "ja": "5：サポートされていないPDUタイプ（致命的）：PDUタイプは、PDUの受信側に認識されていません。"
    },
    {
      "indent": 3,
      "text": "6: Withdrawal of Unknown Record (fatal): The received PDU has Flag=0 but a record for the {Prefix, Len, Max-Len, ASN} tuple does not exist in the receiver's database.",
      "ja": "6：不明なレコードの撤回（致命的）：受信したPDUにはFlag = 0がありますが、{Prefix、Len、Max-Len、ASN}タプルのレコードがレシーバーのデータベースに存在しません。"
    },
    {
      "indent": 3,
      "text": "7: Duplicate Announcement Received (fatal): The received PDU has an identical {Prefix, Len, Max-Len, ASN} tuple as a PDU that is still active in the router.",
      "ja": "7：重複したアナウンスを受信しました（致命的）：受信したPDUには、ルーターでまだアクティブなPDUと同じ{Prefix、Len、Max-Len、ASN}タプルがあります。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As this document describes a security protocol, many aspects of security interest are described in the relevant sections. This section points out issues that may not be obvious in other sections.",
      "ja": "このドキュメントではセキュリティプロトコルについて説明しているので、関連するセクションでは、セキュリティに関する多くの側面について説明します。このセクションでは、他のセクションでは明らかにならない可能性のある問題を指摘します。"
    },
    {
      "indent": 3,
      "text": "Cache Validation: In order for a collection of caches as described in Section 9 to guarantee a consistent view, they need to be given consistent trust anchors to use in their internal validation process. Distribution of a consistent trust anchor is assumed to be out of band.",
      "ja": "キャッシュの検証：セクション9で説明されているキャッシュのコレクションが一貫したビューを保証するためには、内部の検証プロセスで使用する一貫したトラストアンカーをキャッシュに与える必要があります。一貫したトラストアンカーの配布は、帯域外であると見なされます。"
    },
    {
      "indent": 3,
      "text": "Cache Peer Identification: The router initiates a transport session to a cache, which it identifies by either IP address or fully qualified domain name. Be aware that a DNS or address spoofing attack could make the correct cache unreachable. No session would be established, as the authorization keys would not match.",
      "ja": "キャッシュピアの識別：ルーターはキャッシュへのトランスポートセッションを開始します。キャッシュは、IPアドレスまたは完全修飾ドメイン名で識別されます。 DNSまたはアドレスのなりすまし攻撃により、正しいキャッシュに到達できなくなる可能性があることに注意してください。認証キーが一致しないため、セッションは確立されません。"
    },
    {
      "indent": 3,
      "text": "Transport Security: The RPKI relies on object, not server or transport, trust. That is, the IANA root trust anchor is distributed to all caches through some out-of-band means, and can then be used by each cache to validate certificates and ROAs all the way down the tree. The inter-cache relationships are based on this object security model; hence, the inter-cache transport can be lightly protected.",
      "ja": "トランスポートセキュリティ：RPKIは、サーバーやトランスポートではなくオブジェクトの信頼に依存しています。つまり、IANAルートトラストアンカーは、帯域外の手段を介してすべてのキャッシュに配布され、各キャッシュが証明書とROAをツリー全体で検証するために使用できます。キャッシュ間の関係は、このオブジェクトセキュリティモデルに基づいています。したがって、キャッシュ間トランスポートを軽く保護できます。"
    },
    {
      "indent": 6,
      "text": "But, this protocol document assumes that the routers cannot do the validation cryptography. Hence, the last link, from cache to router, is secured by server authentication and transport-level security. This is dangerous, as server authentication and transport have very different threat models than object security.",
      "ja": "ただし、このプロトコルドキュメントは、ルーターが検証暗号化を実行できないことを前提としています。したがって、キャッシュからルーターへの最後のリンクは、サーバー認証とトランスポートレベルのセキュリティによって保護されます。サーバーの認証とトランスポートにはオブジェクトのセキュリティとは非常に異なる脅威モデルがあるため、これは危険です。"
    },
    {
      "indent": 6,
      "text": "So, the strength of the trust relationship and the transport between the router(s) and the cache(s) are critical. You're betting your routing on this.",
      "ja": "したがって、信頼関係の強さとルーターとキャッシュの間のトランスポートが重要です。あなたはこれにあなたのルーティングを賭けています。"
    },
    {
      "indent": 6,
      "text": "While we cannot say the cache must be on the same LAN, if only due to the issue of an enterprise wanting to off-load the cache task to their upstream ISP(s), locality, trust, and control are very critical issues here. The cache(s) really SHOULD be as close, in the sense of controlled and protected (against DDoS, MITM) transport, to the router(s) as possible. It also SHOULD be topologically close so that a minimum of validated routing data are needed to bootstrap a router's access to a cache.",
      "ja": "キャッシュが同じLAN上にある必要があるとは言えませんが、企業がキャッシュタスクをアップストリームISPにオフロードしたいという問題のためにのみ、ここでは局所性、信頼、および制御が非常に重要な問題です。キャッシュは、（DDoS、MITMに対して）制御および保護されたトランスポートの意味で、ルーターにできる限り近い必要があります。また、トポロジー的に近い必要があるため、キャッシュからルーターへのアクセスをブートストラップするには、検証済みのルーティングデータを最小限に抑える必要があります。"
    },
    {
      "indent": 6,
      "text": "The identity of the cache server SHOULD be verified and authenticated by the router client, and vice versa, before any data are exchanged.",
      "ja": "キャッシュサーバーのIDは、データが交換される前に、ルータークライアントによって検証および認証される必要があり、その逆も同様です。"
    },
    {
      "indent": 6,
      "text": "Transports that cannot provide the necessary authentication and integrity (see Section 7) must rely on network design and operational controls to provide protection against spoofing/ corruption attacks. As pointed out in Section 7, TCP-AO is the long-term plan. Protocols that provide integrity and authenticity SHOULD be used, and if they cannot, i.e., TCP is used as the transport, the router and cache MUST be on the same trusted, controlled network.",
      "ja": "必要な認証と整合性（セクション7を参照）を提供できないトランスポートは、ネットワーク設計と運用制御に依存して、スプーフィング/破損攻撃に対する保護を提供する必要があります。セクション7で指摘したように、TCP-AOは長期計画です。整合性と信頼性を提供するプロトコルを使用する必要があります（SHOULD）。プロトコルが使用できない場合、つまり、TCPがトランスポートとして使用される場合、ルーターとキャッシュは同じ信頼され、制御されたネットワーク上にある必要があります。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned 'well-known' TCP Port Numbers to the RPKI-Router Protocol for the following, see Section 7:",
      "ja": "IANAは、「よく知られている」TCPポート番号を以下のRPKI-Routerプロトコルに割り当てています。セクション7を参照してください。"
    },
    {
      "indent": 11,
      "text": "rpki-rtr rpki-rtr-tls",
      "ja": "rpki-rtr rpki-rtr-tls"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry for tuples of Protocol Version / PDU Type, each of which may range from 0 to 255. The name of the registry is \"rpki-rtr-pdu\". The policy for adding to the registry is RFC Required per [RFC5226], either Standards Track or Experimental. The initial entries are as follows:",
      "ja": "IANAは、プロトコルバージョン/ PDUタイプのタプルのレジストリを作成しました。各タプルの範囲は0〜255です。レジストリの名前は「rpki-rtr-pdu」です。レジストリに追加するためのポリシーは、[RFC5226]のRFC必須であり、Standards TrackまたはExperimentalです。最初のエントリは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "Protocol   PDU\nVersion    Type  Description\n--------   ----  ---------------\n    0        0   Serial Notify\n    0        1   Serial Query\n    0        2   Reset Query\n    0        3   Cache Response\n    0        4   IPv4 Prefix\n    0        6   IPv6 Prefix\n    0        7   End of Data\n    0        8   Cache Reset\n    0       10   Error Report\n    0      255   Reserved",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IANA has created a registry for Error Codes 0 to 255. The name of the registry is \"rpki-rtr-error\". The policy for adding to the registry is Expert Review per [RFC5226], where the responsible IESG Area Director should appoint the Expert Reviewer. The initial entries should be as follows:",
      "ja": "IANAはエラーコード0〜255のレジストリを作成しました。レジストリの名前は「rpki-rtr-error」です。レジストリに追加するためのポリシーは、[RFC5226]によるエキスパートレビューであり、責任あるIESGエリアディレクターがエキスパートレビューアを任命する必要があります。最初のエントリは次のようになります。"
    },
    {
      "indent": 11,
      "text": "Error\nCode    Description\n-----   ----------------\n    0   Corrupt Data\n    1   Internal Error\n    2   No Data Available\n    3   Invalid Request\n    4   Unsupported Protocol Version\n    5   Unsupported PDU Type\n    6   Withdrawal of Unknown Record\n    7   Duplicate Announcement Received\n  255   Reserved",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IANA has added an SSH Connection Protocol Subsystem Name, as defined in [RFC4250], of 'rpki-rtr'.",
      "ja": "IANAは、[RFC4250]で定義されているように、「rpki-rtr」のSSH接続プロトコルサブシステム名を追加しました。"
    },
    {
      "indent": 0,
      "text": "13. Acknowledgments",
      "section_title": true,
      "ja": "13. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Steve Bellovin, Rex Fernando, Paul Hoffman, Russ Housley, Pradosh Mohapatra, Keyur Patel, Sandy Murphy, Robert Raszuk, John Scudder, Ruediger Volk, and David Ward. Particular thanks go to Hannes Gredler for showing us the dangers of unnecessary fields.",
      "ja": "著者は、Steve Bellovin、Rex Fernando、Paul Hoffman、Russ Housley、Pradosh Mohapatra、Keyur Patel、Sandy Murphy、Robert Raszuk、John Scudder、Ruediger Volk、およびDavid Wardに感謝します。不要なフィールドの危険性を示してくれたHannes Gredlerに特に感謝します。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14. 参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996.",
      "ja": "[RFC1982] Elz、R。およびR. Bush、「Serial Number Arithmetic」、RFC 1982、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2385] Heffernan, A., \"Protection of BGP Sessions via the TCP MD5 Signature Option\", RFC 2385, August 1998.",
      "ja": "[RFC2385] Heffernan、A。、「TCP MD5署名オプションによるBGPセッションの保護」、RFC 2385、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3269] Kermode, R. and L. Vicisano, \"Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents\", RFC 3269, April 2002.",
      "ja": "[RFC3269] Kermode、R。およびL. Vicisano、「Reliable Multicast Transport（RMT）Building Blocks and Protocol Instantiationドキュメントの作成者ガイドライン」、RFC 3269、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4250] Lehtinen, S. and C. Lonvick, \"The Secure Shell (SSH) Protocol Assigned Numbers\", RFC 4250, January 2006.",
      "ja": "[RFC4250] Lehtinen、S。およびC. Lonvick、「The Secure Shell（SSH）Protocol Assigned Numbers」、RFC 4250、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4252] Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH) Authentication Protocol\", RFC 4252, January 2006.",
      "ja": "[RFC4252] Ylonen、T。およびC. Lonvick、「The Secure Shell（SSH）Authentication Protocol」、RFC 4252、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301] Kent、S。およびK. Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5925] Touch, J., Mankin, A., and R. Bonica, \"The TCP Authentication Option\", RFC 5925, June 2010.",
      "ja": "[RFC5925] Touch、J.、Mankin、A。、およびR. Bonica、「The TCP Authentication Option」、RFC 5925、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5926] Lebovitz, G. and E. Rescorla, \"Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)\", RFC 5926, June 2010.",
      "ja": "[RFC5926] Lebovitz、G。およびE. Rescorla、「TCP Authentication Option（TCP-AO）の暗号化アルゴリズム」、RFC 5926、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, March 2011.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6811] Mohapatra, P., Scudder, J., Ward, D., Bush, R., and R. Austein, \"BGP Prefix Origin Validation\", RFC 6811, January 2013.",
      "ja": "[RFC6811] Mohapatra、P.、Scudder、J.、Ward、D.、Bush、R。、およびR. Austein、「BGP Prefix Origin Validation」、RFC 6811、2013年1月。"
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC1996] Vixie, P., \"A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)\", RFC 1996, August 1996.",
      "ja": "[RFC1996] Vixie、P。、「ゾーン変更の迅速な通知のためのメカニズム（DNS NOTIFY）」、RFC 1996、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4808] Bellovin, S., \"Key Change Strategies for TCP-MD5\", RFC 4808, March 2007.",
      "ja": "[RFC4808] Bellovin、S。、「TCP-MD5の主要な変更戦略」、RFC 4808、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5781] Weiler, S., Ward, D., and R. Housley, \"The rsync URI Scheme\", RFC 5781, February 2010.",
      "ja": "[RFC5781] Weiler、S.、Ward、D。、およびR. Housley、「rsync URIスキーム」、RFC 5781、2010年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6480] Lepinski, M. and S. Kent, \"An Infrastructure to Support Secure Internet Routing\", RFC 6480, February 2012.",
      "ja": "[RFC6480] Lepinski、M。およびS. Kent、「安全なインターネットルーティングをサポートするインフラストラクチャ」、RFC 6480、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6481] Huston, G., Loomans, R., and G. Michaelson, \"A Profile for Resource Certificate Repository Structure\", RFC 6481, February 2012.",
      "ja": "[RFC6481] Huston、G.、Loomans、R。、およびG. Michaelson、「リソース証明書リポジトリ構造のプロファイル」、RFC 6481、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RTR-IMPL] Bush, R., Austein, R., Patel, K., Gredler, H., and M. Waehlisch, \"RPKI Router Implementation Report\", Work in Progress, January 2012.",
      "ja": "[RTR-IMPL] Bush、R.、Austein、R.、Patel、K.、Gredler、H。、およびM. Waehlisch、「RPKI Router Implementation Report」、Work in Progress、2012年1月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randy Bush Internet Initiative Japan 5147 Crystal Springs Bainbridge Island, WA 98110 US",
      "ja": "Randy Bush Internet Initiative Japan 5147 Crystal Springs Bainbridge Island、WA 98110 US"
    },
    {
      "indent": 3,
      "text": "EMail: randy@psg.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rob Austein Dragon Research Labs",
      "ja": "ロブオースタインドラゴン研究所"
    },
    {
      "indent": 3,
      "text": "EMail: sra@hactrn.net",
      "raw": true,
      "ja": ""
    }
  ]
}