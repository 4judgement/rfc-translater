{
  "title": {
    "text": "RFC 6951 - UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication",
    "ja": "RFC 6951 - エンドホスト間通信用のストリーム制御伝送プロトコル（SCTP）パケットのUDPカプセル化"
  },
  "number": 6951,
  "created_at": "2020-09-04 16:30:21.002040+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         M. Tuexen\nRequest for Comments: 6951              Muenster Univ. of Appl. Sciences\nCategory: Standards Track                                     R. Stewart\nISSN: 2070-1721                                           Adara Networks\n                                                                May 2013",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication",
      "ja": "エンドホスト間通信用のストリーム制御伝送プロトコル（SCTP）パケットのUDPカプセル化"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a simple method of encapsulating Stream Control Transmission Protocol (SCTP) packets into UDP packets and its limitations. This allows the usage of SCTP in networks with legacy NATs that do not support SCTP. It can also be used to implement SCTP on hosts without directly accessing the IP layer, for example, implementing it as part of the application without requiring special privileges.",
      "ja": "このドキュメントでは、Stream Control Transmission Protocol（SCTP）パケットをUDPパケットにカプセル化する簡単な方法とその制限について説明します。これにより、SCTPをサポートしないレガシーNATを使用するネットワークでSCTPを使用できます。また、IP層に直接アクセスせずにホストにSCTPを実装するために使用することもできます。たとえば、特別な特権を必要とせずにアプリケーションの一部として実装することができます。"
    },
    {
      "indent": 3,
      "text": "Please note that this document only describes the functionality required within an SCTP stack to add on UDP encapsulation, providing only those mechanisms for two end-hosts to communicate with each other over UDP ports. In particular, it does not provide mechanisms to determine whether UDP encapsulation is being used by the peer, nor the mechanisms for determining which remote UDP port number can be used. These functions are out of scope for this document.",
      "ja": "このドキュメントでは、UDPカプセル化を追加するためにSCTPスタック内で必要な機能についてのみ説明し、2つのエンドホストがUDPポートを介して互いに通信するためのメカニズムのみを提供することに注意してください。特に、ピアがUDPカプセル化を使用しているかどうかを判別するメカニズムや、使用できるリモートUDPポート番号を判別するメカニズムは提供していません。これらの関数は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "This document covers only end-hosts and not tunneling (egress or ingress) endpoints.",
      "ja": "このドキュメントでは、エンドホストのみを扱い、トンネリング（出力または入力）エンドポイントは扱いません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6951.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6951で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .   3\n3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   3\n  3.1.  Portable SCTP Implementations . . . . . . . . . . . . . .   3\n  3.2.  Legacy NAT Traversal  . . . . . . . . . . . . . . . . . .   4\n4.  Unilateral Self-Address Fixing (UNSAF) Considerations . . . .   4\n5.  SCTP over UDP . . . . . . . . . . . . . . . . . . . . . . . .   4\n  5.1.  Architectural Considerations  . . . . . . . . . . . . . .   4\n  5.2.  Packet Format . . . . . . . . . . . . . . . . . . . . . .   5\n  5.3.  Encapsulation Procedure . . . . . . . . . . . . . . . . .   6\n  5.4.  Decapsulation Procedure . . . . . . . . . . . . . . . . .   7\n  5.5.  ICMP Considerations . . . . . . . . . . . . . . . . . . .   7\n  5.6.  Path MTU Considerations . . . . . . . . . . . . . . . . .   7\n  5.7.  Handling of Embedded IP Addresses . . . . . . . . . . . .   8\n  5.8.  Explicit Congestion Notification (ECN) Considerations . .   8\n6.  Socket API Considerations . . . . . . . . . . . . . . . . . .   8\n  6.1.  Get or Set the Remote UDP Encapsulation Port Number\n        (SCTP_REMOTE_UDP_ENCAPS_PORT) . . . . . . . . . . . . . .   9\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .   9\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .   9\n9.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  10\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  10\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  10\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  11",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes a simple method of encapsulating SCTP packets into UDP packets. SCTP, as defined in [RFC4960], runs directly over IPv4 or IPv6. There are two main reasons for encapsulating SCTP packets:",
      "ja": "このドキュメントでは、SCTPパケットをUDPパケットにカプセル化する簡単な方法について説明します。 [RFC4960]で定義されているSCTPは、IPv4またはIPv6で直接実行されます。 SCTPパケットをカプセル化する主な理由は2つあります。"
    },
    {
      "indent": 3,
      "text": "o To allow SCTP traffic to pass through legacy NATs, which do not provide native SCTP support as specified in [BEHAVE] and [NATSUPP].",
      "ja": "o [BEHAVE]と[NATSUPP]で指定されているネイティブSCTPサポートを提供しないレガシーNATをSCTPトラフィックが通過できるようにします。"
    },
    {
      "indent": 3,
      "text": "o To allow SCTP to be implemented on hosts that do not provide direct access to the IP layer. In particular, applications can use their own SCTP implementation if the operating system does not provide one.",
      "ja": "o IP層への直接アクセスを提供しないホストにSCTPを実装できるようにするため。特に、オペレーティングシステムが提供していない場合、アプリケーションは独自のSCTP実装を使用できます。"
    },
    {
      "indent": 3,
      "text": "SCTP provides the necessary congestion control and reliability service that UDP does not perform.",
      "ja": "SCTPは、UDPが実行しない必要な輻輳制御および信頼性サービスを提供します。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2. 規約"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Use Cases",
      "section_title": true,
      "ja": "3. ユースケース"
    },
    {
      "indent": 3,
      "text": "This section discusses two important use cases for encapsulating SCTP into UDP.",
      "ja": "このセクションでは、SCTPをUDPにカプセル化するための2つの重要な使用例について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Portable SCTP Implementations",
      "section_title": true,
      "ja": "3.1. ポータブルSCTP実装"
    },
    {
      "indent": 3,
      "text": "Some operating systems support SCTP natively. For other operating systems, implementations are available but require special privileges to install and/or use them. In some cases, a kernel implementation might not be available at all. When providing an SCTP implementation as part of a user process, most operating systems require special privileges to access the IP layer directly.",
      "ja": "一部のオペレーティングシステムはSCTPをネイティブでサポートしています。他のオペレーティングシステムでは、実装が利用可能ですが、それらをインストールまたは使用するには特別な権限が必要です。場合によっては、カーネル実装がまったく利用できないことがあります。ユーザープロセスの一部としてSCTP実装を提供する場合、ほとんどのオペレーティングシステムは、IP層に直接アクセスするための特別な特権を必要とします。"
    },
    {
      "indent": 3,
      "text": "Using UDP encapsulation makes it possible to provide an SCTP implementation as part of a user process that does not require any special privileges.",
      "ja": "UDPカプセル化を使用すると、特別な特権を必要としないユーザープロセスの一部としてSCTP実装を提供できます。"
    },
    {
      "indent": 0,
      "text": " A crucial point for implementing SCTP in user space is that the source address of outgoing packets needs to be controlled. This is not an issue if the SCTP stack can use all addresses configured at the IP layer as source addresses. However, it is an issue when also using the address management required for NAT traversal, described in Section 5.7.",
      "ja": "ユーザー空間にSCTPを実装するための重要なポイントは、発信パケットのソースアドレスを制御する必要があることです。 SCTPスタックがIP層で構成されたすべてのアドレスを送信元アドレスとして使用できる場合、これは問題ではありません。ただし、セクション5.7で説明されているように、NATトラバーサルに必要なアドレス管理も使用する場合は問題になります。"
    },
    {
      "indent": 0,
      "text": "3.2. Legacy NAT Traversal",
      "section_title": true,
      "ja": "3.2. レガシーNATトラバーサル"
    },
    {
      "indent": 3,
      "text": "Using UDP encapsulation allows SCTP communication when traversing\nlegacy NATs (i.e, those NATs not supporting SCTP as described in\n[BEHAVE] and [NATSUPP]).  For single-homed associations, IP addresses\nMUST NOT be listed in the INIT and INIT-ACK chunks.  To use multiple\naddresses, the dynamic address reconfiguration extension described in\n[RFC5061] MUST be used only with wildcard addresses in the ASCONF\nchunks (Address Configuration Change Chunks) in combination with\n[RFC4895].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For multihomed SCTP associations, the address management as described in Section 5.7 MUST be performed.",
      "ja": "マルチホームSCTPアソシエーションの場合、セクション5.7で説明されているアドレス管理を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "SCTP sends periodic HEARTBEAT chunks on all idle paths. These can keep the NAT state alive.",
      "ja": "SCTPは、すべてのアイドルパスで定期的にHEARTBEATチャンクを送信します。これらは、NAT状態を維持することができます。"
    },
    {
      "indent": 0,
      "text": "4. Unilateral Self-Address Fixing (UNSAF) Considerations",
      "section_title": true,
      "ja": "4. 片側自己アドレス修正（UNSAF）に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As [RFC3424] requires a limited scope, this document only covers SCTP endpoints dealing with legacy constraints as described in Section 3. It doesn't cover generic tunneling endpoints.",
      "ja": "[RFC3424]は限られたスコープを必要とするため、このドキュメントでは、セクション3で説明されているレガシー制約を処理するSCTPエンドポイントのみを取り上げます。一般的なトンネリングエンドポイントについては扱いません。"
    },
    {
      "indent": 3,
      "text": "Obviously, the exit strategy is to use hosts supporting SCTP natively and middleboxes supporting SCTP as specified in [BEHAVE] and [NATSUPP].",
      "ja": "明らかに、出口戦略は、SCTPをネイティブでサポートするホストと、[BEHAVE]および[NATSUPP]で指定されているSCTPをサポートするミドルボックスを使用することです。"
    },
    {
      "indent": 0,
      "text": "5. SCTP over UDP",
      "section_title": true,
      "ja": "5. UDP経由のSCTP"
    },
    {
      "indent": 0,
      "text": "5.1. Architectural Considerations",
      "section_title": true,
      "ja": "5.1. アーキテクチャに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "UDP-encapsulated SCTP is normally communicated between SCTP stacks using the IANA-assigned UDP port number 9899 (sctp-tunneling) on both ends. There are circumstances where other ports may be used on either end: As stated earlier, implementations in the application space might be required to use ports other than the registered port. Since NAT boxes might change UDP port numbers, the receiver might observe other UDP port numbers than were used by the sender. Discovery of alternate ports is outside of the scope of this document, but this section describes considerations for SCTP stack design in light of their potential use.",
      "ja": "UDPカプセル化されたSCTPは通常、両端でIANAが割り当てたUDPポート番号9899（sctp-tunneling）を使用してSCTPスタック間で通信されます。いずれかの端で他のポートが使用される状況があります。前述のように、登録済みポート以外のポートを使用するには、アプリケーション空間での実装が必要になる場合があります。 NATボックスはUDPポート番号を変更する可能性があるため、受信者は送信者が使用した以外のUDPポート番号を監視する場合があります。代替ポートの検出はこのドキュメントの範囲外ですが、このセクションでは、潜在的な使用を考慮したSCTPスタック設計の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": " Each SCTP stack uses a single local UDP encapsulation port number as the destination port for all its incoming SCTP packets. While the uniqueness of the local UDP encapsulation port number is not necessarily required for the protocol, this greatly simplifies implementation design, since different ports for each address would require a sender implementation to choose the appropriate port while doing source address selection. Using a single local UDP encapsulation port number per host is not possible if the SCTP stack is implemented as part of each application, there are multiple applications, and some of the applications want to use the same IP address.",
      "ja": "各SCTPスタックは、すべての着信SCTPパケットの宛先ポートとして、単一のローカルUDPカプセル化ポート番号を使用します。ローカルUDPカプセル化ポート番号の一意性はプロトコルに必ずしも必要ではありませんが、これにより実装設計が大幅に簡素化されます。これは、アドレスごとに異なるポートが送信元実装で送信元アドレスの選択中に適切なポートを選択する必要があるためです。 SCTPスタックが各アプリケーションの一部として実装され、複数のアプリケーションがあり、一部のアプリケーションが同じIPアドレスを使用したい場合、ホストごとに単一のローカルUDPカプセル化ポート番号を使用することはできません。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation supporting UDP encapsulation MUST maintain a remote UDP encapsulation port number per destination address for each SCTP association. Again, because the remote stack may be using ports other than the well-known port, each port may be different from each stack. However, because of remapping of ports by NATs, the remote ports associated with different remote IP addresses may not be identical, even if they are associated with the same stack.",
      "ja": "UDPカプセル化をサポートするSCTP実装は、各SCTPアソシエーションの宛先アドレスごとにリモートUDPカプセル化ポート番号を維持する必要があります。この場合も、リモートスタックはウェルノウンポート以外のポートを使用している可能性があるため、各ポートは各スタックと異なる場合があります。ただし、NATによるポートの再マッピングのため、異なるスタックに関連付けられている場合でも、異なるリモートIPアドレスに関連付けられているリモートポートは同一ではない場合があります。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Because the well-known port might not be used, implementations need to allow other port numbers to be specified as a local or remote UDP encapsulation port number through APIs.",
      "ja": "実装メモ：既知のポートが使用されない可能性があるため、実装では、APIを介して他のポート番号をローカルまたはリモートのUDPカプセル化ポート番号として指定できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Packet Format",
      "section_title": true,
      "ja": "5.2. パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "To encapsulate an SCTP packet, a UDP header as defined in [RFC0768] is inserted between the IP header as defined in [RFC0791] and the SCTP common header as defined in [RFC4960].",
      "ja": "SCTPパケットをカプセル化するには、[RFC0768]で定義されているUDPヘッダーを、[RFC0791]で定義されているIPヘッダーと[RFC4960]で定義されているSCTP共通ヘッダーの間に挿入します。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the packet format of an encapsulated SCTP packet when IPv4 is used.",
      "ja": "図1は、IPv4を使用した場合のカプセル化されたSCTPパケットのパケット形式を示しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 Header                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         UDP Header                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      SCTP Common Header                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        SCTP Chunk #1                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           ...                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        SCTP Chunk #n                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 1: An SCTP/UDP/IPv4 Packet",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The packet format for an encapsulated SCTP packet when using IPv6 as defined in [RFC2460] is shown in Figure 2. Please note that the number m of IPv6 extension headers can be 0.",
      "ja": "[RFC2460]で定義されているIPv6を使用する場合のカプセル化されたSCTPパケットのパケット形式を図2に示します。IPv6拡張ヘッダーの数mは0でもかまいません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      IPv6 Base Header                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    IPv6 Extension Header #1                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           ...                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    IPv6 Extension Header #m                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         UDP Header                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      SCTP Common Header                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        SCTP Chunk #1                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           ...                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        SCTP Chunk #n                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 2: An SCTP/UDP/IPv6 Packet",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. Encapsulation Procedure",
      "section_title": true,
      "ja": "5.3. カプセル化手順"
    },
    {
      "indent": 3,
      "text": "Within the UDP header, the source port MUST be the local UDP encapsulation port number of the SCTP stack, and the destination port MUST be the remote UDP encapsulation port number maintained for the association and the destination address to which the packet is sent (see Section 5.1).",
      "ja": "UDPヘッダー内では、送信元ポートはSCTPスタックのローカルUDPカプセル化ポート番号である必要があり、宛先ポートは、関連付けのために維持されているリモートUDPカプセル化ポート番号と、パケットの送信先の宛先アドレスである必要があります（セクションを参照）。 5.1）。"
    },
    {
      "indent": 3,
      "text": "Because the SCTP packet is the UDP payload, the length of the UDP packet MUST be the length of the SCTP packet plus the size of the UDP header.",
      "ja": "SCTPパケットはUDPペイロードであるため、UDPパケットの長さはSCTPパケットの長さとUDPヘッダーのサイズを足したものでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "The SCTP checksum MUST be computed for IPv4 and IPv6, and the UDP checksum SHOULD be computed for IPv4 and IPv6. (See [RFC0768] regarding IPv4; see [RFC2460] and [RFC6936] regarding IPv6.) Although UDP with a zero checksum over IPv6 is allowed under certain constraints [RFC6936], this document does not specify mechanisms for this mode. Deployed support may be limited; also, at the time of writing, the use of a zero UDP checksum would be counter to the goal of legacy NAT traversal.",
      "ja": "SCTPチェックサムはIPv4およびIPv6に対して計算する必要があり、UDPチェックサムはIPv4およびIPv6に対して計算する必要があります（SHOULD）。 （IPv4については[RFC0768]を参照してください。IPv6については[RFC2460]と[RFC6936]を参照してください。）特定の制約[RFC6936]の下で、IPv6でのチェックサムがゼロのUDPが許可されていますが、このドキュメントではこのモードのメカニズムを指定しません。展開されるサポートは制限される場合があります。また、これを書いている時点では、UDPチェックサムをゼロにすることは、レガシーNATトラバーサルの目標に反するものです。"
    },
    {
      "indent": 0,
      "text": "5.4. Decapsulation Procedure",
      "section_title": true,
      "ja": "5.4. カプセル開放手順"
    },
    {
      "indent": 3,
      "text": "When an encapsulated packet is received, the UDP header is removed. Then, the generic lookup is performed, as done by an SCTP stack whenever a packet is received, to find the association for the received SCTP packet. After finding the SCTP association (which includes checking the verification tag), the UDP source port MUST be stored as the encapsulation port for the destination address the SCTP packet is received from (see Section 5.1).",
      "ja": "カプセル化されたパケットを受信すると、UDPヘッダーが削除されます。次に、パケットが受信されるたびにSCTPスタックによって行われるように、受信されたSCTPパケットの関連付けを見つけるために、一般的なルックアップが実行されます。 SCTPアソシエーション（検証タグのチェックを含む）を見つけた後、UDP送信元ポートを、SCTPパケットの受信元の宛先アドレスのカプセル化ポートとして保存する必要があります（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "When a non-encapsulated SCTP packet is received by the SCTP stack, the encapsulation of outgoing packets belonging to the same association and the corresponding destination address MUST be disabled.",
      "ja": "カプセル化されていないSCTPパケットがSCTPスタックによって受信されると、同じアソシエーションと対応する宛先アドレスに属する発信パケットのカプセル化を無効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5. ICMP Considerations",
      "section_title": true,
      "ja": "5.5. ICMPに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When receiving ICMP or ICMPv6 response packets, there might not be enough bytes in the payload to identify the SCTP association that the SCTP packet triggering the ICMP or ICMPv6 packet belongs to. If a received ICMP or ICMPv6 packet cannot be related to a specific SCTP association or the verification tag cannot be verified, it MUST be discarded silently. In particular, this means that the SCTP stack MUST NOT rely on receiving ICMP or ICMPv6 messages. Implementation constraints could prevent processing received ICMP or ICMPv6 messages.",
      "ja": "ICMPまたはICMPv6応答パケットを受信するとき、ペイロードに、ICMPまたはICMPv6パケットをトリガーするSCTPパケットが属するSCTPアソシエーションを識別するのに十分なバイトがない可能性があります。受信したICMPまたはICMPv6パケットを特定のSCTPアソシエーションに関連付けることができない場合、または検証タグを検証できない場合は、黙って破棄する必要があります。特に、これはSCTPスタックがICMPまたはICMPv6メッセージの受信に依存してはならないことを意味します。実装の制約により、受信したICMPまたはICMPv6メッセージの処理が妨げられる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If received ICMP or ICMPv6 messages are processed, the following mapping SHOULD apply:",
      "ja": "受信したICMPまたはICMPv6メッセージが処理される場合、次のマッピングが適用されるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "1. ICMP messages with type 'Destination Unreachable' and code 'Port Unreachable' SHOULD be treated as ICMP messages with type 'Destination Unreachable' and code 'Protocol Unreachable'. See [RFC0792] for more details.",
      "ja": "1. タイプが「Destination Unreachable」でコードが「Port Unreachable」のICMPメッセージは、タイプが「Destination Unreachable」でコードが「Protocol Unreachable」のICMPメッセージとして扱う必要があります。詳細については、[RFC0792]を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. ICMPv6 messages with type 'Destination Unreachable' and code 'Port Unreachable' SHOULD be treated as ICMPv6 messages with type 'Parameter Problem' and code 'unrecognized Next Header type encountered'. See [RFC4443] for more details.",
      "ja": "2. タイプが「Destination Unreachable」でコードが「Port Unreachable」のICMPv6メッセージは、タイプが「Parameter Problem」でコードが「unrecognized Next Header type遭遇」のICMPv6メッセージとして扱う必要があります。詳細については、[RFC4443]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6. Path MTU Considerations",
      "section_title": true,
      "ja": "5.6. パスMTUに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "If an SCTP endpoint starts to encapsulate the packets of a path, it MUST decrease the Path MTU of that path by the size of the UDP header. If it stops encapsulating them, the Path MTU SHOULD be increased by the size of the UDP header.",
      "ja": "SCTPエンドポイントがパスのパケットのカプセル化を開始する場合、UDPヘッダーのサイズによってそのパスのパスMTUを減らす必要があります。それらのカプセル化を停止する場合、UDPヘッダーのサイズによってパスMTUを増やす必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "When performing Path MTU discovery as described in [RFC4820] and [RFC4821], it MUST be taken into account that one cannot rely on the feedback provided by ICMP or ICMPv6 due to the limitation laid out in Section 5.5.",
      "ja": "[RFC4820]と[RFC4821]で説明されているようにパスMTUディスカバリーを実行するとき、セクション5.5で説明されている制限のために、ICMPまたはICMPv6によって提供されるフィードバックに依存できないことを考慮に入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the implementation does not allow control of the Don't Fragment (DF) bit contained in the IPv4 header, then Path MTU discovery can't be used. In this case, an implementation-specific value should be used instead.",
      "ja": "実装でIPv4ヘッダーに含まれているDo n't Fragment（DF）ビットの制御が許可されていない場合、パスMTUディスカバリーは使用できません。この場合、代わりに実装固有の値を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7. Handling of Embedded IP Addresses",
      "section_title": true,
      "ja": "5.7. 埋め込みIPアドレスの処理"
    },
    {
      "indent": 3,
      "text": "When using UDP encapsulation for legacy NAT traversal, IP addresses that might require translation MUST NOT be put into any SCTP packet.",
      "ja": "レガシーNATトラバーサルにUDPカプセル化を使用する場合、変換が必要になる可能性のあるIPアドレスをSCTPパケットに入れてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "This means that a multihomed SCTP association is set up initially as a single-homed one, and the protocol extension [RFC5061] in combination with [RFC4895] is used to add the other addresses. Only wildcard addresses are put into the SCTP packet.",
      "ja": "これは、マルチホームのSCTPアソシエーションが最初にシングルホームのアソシエーションとしてセットアップされ、プロトコル拡張[RFC5061]と[RFC4895]を組み合わせて他のアドレスを追加することを意味します。ワイルドカードアドレスのみがSCTPパケットに入れられます。"
    },
    {
      "indent": 3,
      "text": "When addresses are changed during the lifetime of an association, the protocol extension [RFC5061] MUST be used with wildcard addresses only. If an SCTP endpoint receives an ABORT with the T-bit set, it MAY use this as an indication that the addresses seen by the peer might have changed.",
      "ja": "アソシエーションの存続期間中にアドレスが変更された場合、プロトコル拡張[RFC5061]はワイルドカードアドレスのみで使用する必要があります。 SCTPエンドポイントがTビットが設定されたABORTを受信した場合、ピアが認識したアドレスが変更された可能性があることを示すものとしてこれを使用できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.8. Explicit Congestion Notification (ECN) Considerations",
      "section_title": true,
      "ja": "5.8. 明示的な輻輳通知（ECN）に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "If the implementation supports the sending and receiving of the ECN bits for the IP protocols being used by an SCTP association, the ECN bits MUST NOT be changed during sending and receiving.",
      "ja": "実装がSCTPアソシエーションで使用されているIPプロトコルのECNビットの送受信をサポートする場合、送受信中にECNビットを変更してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "6. Socket API Considerations",
      "section_title": true,
      "ja": "6. ソケットAPIの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes how the socket API defined in [RFC6458] needs to be extended to provide a way for the application to control the UDP encapsulation.",
      "ja": "このセクションでは、[RFC6458]で定義されたソケットAPIを拡張して、アプリケーションがUDPカプセル化を制御する方法を提供する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Please note that this section is informational only.",
      "ja": "このセクションは情報提供のみを目的としています。"
    },
    {
      "indent": 3,
      "text": "A socket API implementation based on [RFC6458] is extended by supporting one new read/write socket option.",
      "ja": "[RFC6458]に基づくソケットAPI実装は、1つの新しい読み取り/書き込みソケットオプションをサポートすることによって拡張されます。"
    },
    {
      "indent": 0,
      "text": "6.1. Get or Set the Remote UDP Encapsulation Port Number (SCTP_REMOTE_UDP_ENCAPS_PORT)",
      "ja": "6.1. リモートUDPカプセル化ポート番号の取得または設定（SCTP_REMOTE_UDP_ENCAPS_PORT）"
    },
    {
      "indent": 3,
      "text": "This socket option can be used to set and retrieve the UDP encapsulation port number. This allows an endpoint to encapsulate initial packets.",
      "ja": "このソケットオプションを使用して、UDPカプセル化ポート番号を設定および取得できます。これにより、エンドポイントは初期パケットをカプセル化できます。"
    },
    {
      "indent": 3,
      "text": "struct sctp_udpencaps {\n  sctp_assoc_t sue_assoc_id;\n  struct sockaddr_storage sue_address;\n  uint16_t sue_port;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "sue_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, the application may fill in an association identifier or SCTP_FUTURE_ASSOC for this query. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in sue_assoc_id.",
      "ja": "sue_assoc_id：このパラメーターは、1対1スタイルのソケットでは無視されます。 1対多スタイルのソケットの場合、アプリケーションは、このクエリの関連識別子またはSCTP_FUTURE_ASSOCを入力できます。 sue_assoc_idでSCTP_ {CURRENT | ALL} _ASSOCを使用するとエラーになります。"
    },
    {
      "indent": 3,
      "text": "sue_address: This specifies which address is of interest. If a wildcard address is provided, it applies only to future paths.",
      "ja": "sue_address：関心のあるアドレスを指定します。ワイルドカードアドレスが指定されている場合、それは将来のパスにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "sue_port: The UDP port number in network byte order; used as the destination port number for UDP encapsulation. Providing a value of 0 disables UDP encapsulation.",
      "ja": "sue_port：ネットワークバイト順のUDPポート番号。 UDPカプセル化の宛先ポート番号として使用されます。値0を指定すると、UDPカプセル化が無効になります。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document refers to the already assigned UDP port 9899 (sctp-tunneling). IANA has updated this assignment to refer to this document. As per [RFC6335], the Assignee is [IESG] and the Contact is [IETF_Chair].",
      "ja": "このドキュメントは、すでに割り当てられているUDPポート9899（sctp-tunneling）を参照しています。 IANAは、このドキュメントを参照するようにこの割り当てを更新しました。 [RFC6335]に従い、担当者は[IESG]で、連絡先は[IETF_Chair]です。"
    },
    {
      "indent": 3,
      "text": "Please note that the TCP port 9899 (sctp-tunneling) assignment is not needed anymore, and IANA has removed this TCP port number assignment and marked TCP port 9899 as \"Reserved\".",
      "ja": "TCPポート9899（sctp-tunneling）の割り当ては不要になり、IANAはこのTCPポート番号の割り当てを削除し、TCPポート9899を「予約済み」としてマークしたことに注意してください。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Encapsulating SCTP into UDP does not add any additional security considerations to the ones given in [RFC4960] and [RFC5061].",
      "ja": "SCTPをUDPにカプセル化しても、[RFC4960]と[RFC5061]に記載されているセキュリティ上の考慮事項は追加されません。"
    },
    {
      "indent": 3,
      "text": "Firewalls inspecting SCTP packets must also be aware of the encapsulation and apply corresponding rules to the encapsulated packets.",
      "ja": "SCTPパケットを検査するファイアウォールは、カプセル化も認識し、カプセル化されたパケットに対応するルールを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "An attacker might send a malicious UDP packet towards an SCTP endpoint to change the encapsulation port for a single remote address of a particular SCTP association. However, as specified in",
      "ja": "攻撃者は、悪意のあるUDPパケットをSCTPエンドポイントに送信して、特定のSCTPアソシエーションの単一のリモートアドレスのカプセル化ポートを変更する可能性があります。ただし、"
    },
    {
      "indent": 3,
      "text": "Section 5.4, this requires the usage of one of the two negotiated verification tags. This protects against blind attackers the same way as described in [RFC4960] for SCTP over IPv4 or IPv6. Non-blind attackers can affect SCTP association using the UDP encapsulation described in this document in the same way as SCTP associations not using the UDP encapsulation of SCTP described here.",
      "ja": "セクション5.4では、これには2つのネゴシエートされた検証タグの1つを使用する必要があります。これは、[RFC4960]で説明されているのと同じ方法で、SCTP over IPv4またはIPv6のブラインド攻撃から保護します。非ブラインド攻撃者は、ここで説明するSCTPのUDPカプセル化を使用しないSCTPアソシエーションと同じ方法で、このドキュメントで説明するUDPカプセル化を使用してSCTPアソシエーションに影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Stewart Bryant, Dave Crocker, Gorry Fairhurst, Tero Kivinen, Barry Leiba, Pete Resnick, Martin Stiemerling, Irene Ruengeler, and Dan Wing for their invaluable comments.",
      "ja": "著者は、スチュワートブライアント、デイブクロッカー、ゴーリーフェアハースト、テロキビネン、バリーレイバ、ピートレズニック、マーティンスティーマーリング、アイリーンルエンゲラー、ダンウィングの貴重なコメントに感謝します。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768] Postel、J。、「User Datagram Protocol」、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC0791] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[RFC0792] Postel、J。、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S.E. and R.M. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]ディアリング、SEとR.M. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 4443, March 2006.",
      "ja": "[RFC4443] Conta、A.、Deering、S。、およびM. Gupta、「インターネット制御メッセージプロトコル（ICMPv6）、インターネットプロトコルバージョン6（IPv6）仕様」、RFC 4443、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4820] Tuexen, M., Stewart, R., and P. Lei, \"Padding Chunk and Parameter for the Stream Control Transmission Protocol (SCTP)\", RFC 4820, March 2007.",
      "ja": "[RFC4820] Tuexen、M.、Stewart、R。、およびP. Lei、「Stream Control Transmission Protocol（SCTP）のパディングチャンクとパラメータ」、RFC 4820、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4895] Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, \"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)\", RFC 4895, August 2007.",
      "ja": "[RFC4895] Tuexen、M.、Stewart、R.、Lei、P。、およびE. Rescorla、「Authenticated Chunks for the Stream Control Transmission Protocol（SCTP）」、RFC 4895、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960] Stewart、R。、「Stream Control Transmission Protocol」、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5061] Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M. Kozuka, \"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration\", RFC 5061, September 2007.",
      "ja": "[RFC5061] Stewart、R.、Xie、Q.、Tuexen、M.、Maruyama、S。、およびM. Kozuka、「Stream Control Transmission Protocol（SCTP）Dynamic Address Reconfiguration」、RFC 5061、2007年9月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BEHAVE] Stewart, R., Tuexen, M., and I. Ruengeler, \"Stream Control Transmission Protocol (SCTP) Network Address Translation\", Work in Progress, February 2013.",
      "ja": "[動作] Stewart、R.、Tuexen、M。、およびI. Ruengeler、「Stream Control Transmission Protocol（SCTP）Network Address Translation」、Work in Progress、2013年2月。"
    },
    {
      "indent": 3,
      "text": "[NATSUPP] Stewart, R., Tuexen, M., and I. Ruengeler, \"Stream Control Transmission Protocol (SCTP) Network Address Translation Support\", Work in Progress, February 2013.",
      "ja": "[NATSUPP] Stewart、R.、Tuexen、M.、I。Ruengeler、「Stream Control Transmission Protocol（SCTP）Network Address Translation Support」、Work in Progress、2013年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L. IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, November 2002.",
      "ja": "[RFC3424]ダイグル、L。IAB、「ネットワークアドレス変換を介したUNilateral Self-Address Fixing（UNSAF）に関するIABの考慮事項」、RFC 3424、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\", BCP 165, RFC 6335, August 2011.",
      "ja": "[RFC6335]綿、M。、エガート、L。、タッチ、J。、ウェスターランド、M。、およびS.チェシャー、「サービス名とトランスポートプロトコルのポート番号レジストリの管理のためのInternet Assigned Numbers Authority（IANA）手順\"、BCP 165、RFC 6335、2011年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, \"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)\", RFC 6458, December 2011.",
      "ja": "[RFC6458] Stewart、R.、Tuexen、M.、Poon、K.、Lei、P。、およびV. Yasevich、「Socket Control Extensions for the Stream Control Transmission Protocol（SCTP）」、RFC 6458、2011年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC6936] Fairhurst, G. and M. Westerlund, \"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums\", RFC 6936, April 2013.",
      "ja": "[RFC6936] Fairhurst、G。およびM. Westerlund、「ゼロチェックサムを使用したIPv6 UDPデータグラムの使用に関する適用性声明」、RFC 6936、2013年4月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt DE",
      "ja": "マイケルトゥセンミュンスター応用科学大学Stegerwaldstrasse 39 48565シュタインフルトDE"
    },
    {
      "indent": 3,
      "text": "EMail: tuexen@fh-muenster.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Adara Networks Chapin, SC 29036 US",
      "ja": "Randall R. Stewart Adara Networks Chapin、SC 29036 US"
    },
    {
      "indent": 3,
      "text": "EMail: randall@lakerest.net",
      "raw": true,
      "ja": ""
    }
  ]
}