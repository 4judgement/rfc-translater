{
  "title": {
    "text": "RFC 6570 - URI Template",
    "ja": "RFC 6570 - URIテンプレート"
  },
  "number": 6570,
  "created_at": "2020-08-20 19:57:51.209345+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       J. Gregorio\nRequest for Comments: 6570                                        Google\nCategory: Standards Track                                    R. Fielding\nISSN: 2070-1721                                                    Adobe\n                                                               M. Hadley\n                                                                   MITRE\n                                                           M. Nottingham\n                                                               Rackspace\n                                                              D. Orchard\n                                                          Salesforce.com\n                                                              March 2012",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 30,
      "text": "URI Template",
      "ja": "URIテンプレート"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion. This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet.",
      "ja": "URIテンプレートは、変数の展開を通じて一連のUniform Resource Identifierを記述するためのコンパクトな文字シーケンスです。この仕様では、URIテンプレートの構文と、URIテンプレートをURI参照に拡張するプロセス、およびインターネットでのURIテンプレートの使用に関するガイドラインを定義しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6570.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6570で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2012 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。"
    },
    {
      "indent": 0,
      "text": " This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Overview ...................................................3\n   1.2. Levels and Expression Types ................................5\n   1.3. Design Considerations ......................................9\n   1.4. Limitations ...............................................10\n   1.5. Notational Conventions ....................................11\n   1.6. Character Encoding and Unicode Normalization ..............12\n2. Syntax .........................................................13\n   2.1. Literals ..................................................13\n   2.2. Expressions ...............................................13\n   2.3. Variables .................................................14\n   2.4. Value Modifiers ...........................................15\n        2.4.1. Prefix Values ......................................15\n        2.4.2. Composite Values ...................................16\n3. Expansion ......................................................18\n   3.1. Literal Expansion .........................................18\n   3.2. Expression Expansion ......................................18\n        3.2.1. Variable Expansion .................................19\n        3.2.2. Simple String Expansion: {var} .....................21\n        3.2.3. Reserved Expansion: {+var} .........................22\n        3.2.4. Fragment Expansion: {#var} .........................23\n        3.2.5. Label Expansion with Dot-Prefix: {.var} ............24\n        3.2.6. Path Segment Expansion: {/var} .....................24\n        3.2.7. Path-Style Parameter Expansion: {;var} .............25\n        3.2.8. Form-Style Query Expansion: {?var} .................26\n        3.2.9. Form-Style Query Continuation: {&var} ..............27\n4. Security Considerations ........................................27\n5. Acknowledgments ................................................28\n6. References .....................................................28\n   6.1. Normative References ......................................28\n   6.2. Informative References ....................................29\nAppendix A. Implementation Hints ..................................30",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Overview",
      "section_title": true,
      "ja": "1.1. 概観"
    },
    {
      "indent": 3,
      "text": "A Uniform Resource Identifier (URI) [RFC3986] is often used to identify a specific resource within a common space of similar resources (informally, a \"URI space\"). For example, personal web spaces are often delegated using a common pattern, such as",
      "ja": "Uniform Resource Identifier（URI）[RFC3986]は、類似したリソースの共通スペース（非公式には「URIスペース」）内の特定のリソースを識別するためによく使用されます。たとえば、個人のWebスペースは、次のような一般的なパターンを使用して委任されることがよくあります。"
    },
    {
      "indent": 5,
      "text": "http://example.com/~fred/\nhttp://example.com/~mark/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or a set of dictionary entries might be grouped in a hierarchy by the first letter of the term, as in",
      "ja": "または、辞書エントリのセットは、次のように、用語の最初の文字によって階層にグループ化される場合があります。"
    },
    {
      "indent": 5,
      "text": "http://example.com/dictionary/c/cat\nhttp://example.com/dictionary/d/dog",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or a service interface might be invoked with various user input in a common pattern, as in",
      "ja": "または、次のような一般的なパターンでさまざまなユーザー入力を使用してサービスインターフェイスを呼び出すことができます。"
    },
    {
      "indent": 5,
      "text": "http://example.com/search?q=cat&lang=en\nhttp://example.com/search?q=chien&lang=fr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion.",
      "ja": "URIテンプレートは、変数の展開を通じて一連のUniform Resource Identifierを記述するためのコンパクトな文字シーケンスです。"
    },
    {
      "indent": 3,
      "text": "URI Templates provide a mechanism for abstracting a space of resource identifiers such that the variable parts can be easily identified and described. URI Templates can have many uses, including the discovery of available services, configuring resource mappings, defining computed links, specifying interfaces, and other forms of programmatic interaction with resources. For example, the above resources could be described by the following URI Templates:",
      "ja": "URIテンプレートは、可変部分を簡単に識別および記述できるように、リソース識別子のスペースを抽象化するメカニズムを提供します。 URIテンプレートは、利用可能なサービスの発見、リソースマッピングの構成、計算されたリンクの定義、インターフェースの指定、およびリソースとのプログラムによるその他の相互作用を含む、多くの用途があります。たとえば、上記のリソースは、次のURIテンプレートで説明できます。"
    },
    {
      "indent": 5,
      "text": "http://example.com/~{username}/\nhttp://example.com/dictionary/{term:1}/{term}\nhttp://example.com/search{?q,lang}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We define the following terms:",
      "ja": "以下の用語を定義します。"
    },
    {
      "indent": 3,
      "text": "expression: The text between '{' and '}', including the enclosing braces, as defined in Section 2.",
      "ja": "式：セクション2で定義されている、囲み中括弧を含む「{」と「}」の間のテキスト。"
    },
    {
      "indent": 3,
      "text": "expansion: The string result obtained from a template expression after processing it according to its expression type, list of variable names, and value modifiers, as defined in Section 3.",
      "ja": "拡張：セクション3で定義されているように、式のタイプ、変数名のリスト、および値修飾子に従ってテンプレート式を処理した後、テンプレート式から取得された文字列結果。"
    },
    {
      "indent": 3,
      "text": "template processor: A program or library that, given a URI Template and a set of variables with values, transforms the template string into a URI reference by parsing the template for expressions and substituting each one with its corresponding expansion.",
      "ja": "テンプレートプロセッサ：URIテンプレートと値のある変数のセットが与えられた場合、テンプレートを式に解析し、それぞれを対応する展開で置き換えることにより、テンプレート文字列をURI参照に変換するプログラムまたはライブラリ。"
    },
    {
      "indent": 3,
      "text": "A URI Template provides both a structural description of a URI space and, when variable values are provided, machine-readable instructions on how to construct a URI corresponding to those values. A URI Template is transformed into a URI reference by replacing each delimited expression with its value as defined by the expression type and the values of variables named within the expression. The expression types range from simple string expansion to multiple name=value lists. The expansions are based on the URI generic syntax, allowing an implementation to process any URI Template without knowing the scheme-specific requirements of every possible resulting URI.",
      "ja": "URIテンプレートは、URIスペースの構造的記述と、変数値が提供された場合に、それらの値に対応するURIを構築する方法についての機械可読な指示の両方を提供します。 URIテンプレートは、区切られた各式を、式タイプおよび式内で指定された変数の値によって定義された値で置き換えることにより、URI参照に変換されます。式のタイプは、単純な文字列展開から複数のname = valueリストまでさまざまです。拡張は、URIの一般的な構文に基づいているため、実装は、考えられるすべてのURIのスキーマ固有の要件を知らなくても、URIテンプレートを処理できます。"
    },
    {
      "indent": 3,
      "text": "For example, the following URI Template includes a form-style parameter expression, as indicated by the \"?\" operator appearing before the variable names.",
      "ja": "たとえば、次のURIテンプレートには、「？」で示されているフォームスタイルのパラメーター式が含まれています。変数名の前に現れる演算子。"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo{?query,number}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The expansion process for expressions beginning with the question-mark (\"?\") operator follows the same pattern as form-style interfaces on the World Wide Web:",
      "ja": "疑問符（ \"？\"）演算子で始まる式の展開プロセスは、World Wide Web上のフォームスタイルのインターフェイスと同じパターンに従います。"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo{?query,number}\n                          \\_____________/\n                             |\n                             |\n        For each defined variable in [ 'query', 'number' ],\n        substitute \"?\" if it is the first substitution or \"&\"\n        thereafter, followed by the variable name, '=', and the\n        variable's value.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the variables have the values",
      "ja": "変数に値がある場合"
    },
    {
      "indent": 5,
      "text": "query  := \"mycelium\"\nnumber := 100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "then the expansion of the above URI Template is",
      "ja": "次に、上記のURIテンプレートの拡張は"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo?query=mycelium&number=100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alternatively, if 'query' is undefined, then the expansion would be",
      "ja": "または、「クエリ」が未定義の場合、展開は次のようになります。"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo?number=100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or if both variables are undefined, then it would be",
      "ja": "または、両方の変数が定義されていない場合は、"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A URI Template may be provided in absolute form, as in the examples above, or in relative form. A template is expanded before the resulting reference is resolved from relative to absolute form.",
      "ja": "URIテンプレートは、上記の例のように絶対形式で、または相対形式で提供できます。結果の参照が絶対形式から相対形式に解決される前に、テンプレートが展開されます。"
    },
    {
      "indent": 3,
      "text": "Although the URI syntax is used for the result, the template string is allowed to contain the broader set of characters that can be found in Internationalized Resource Identifier (IRI) references [RFC3987]. Therefore, a URI Template is also an IRI template, and the result of template processing can be transformed to an IRI by following the process defined in Section 3.2 of [RFC3987].",
      "ja": "結果にはURI構文が使用されますが、テンプレート文字列には、Internationalized Resource Identifier（IRI）参照[RFC3987]にあるより広範な文字セットを含めることができます。したがって、URIテンプレートはIRIテンプレートでもあり、テンプレート処理の結果は、[RFC3987]のセクション3.2で定義されているプロセスに従ってIRIに変換できます。"
    },
    {
      "indent": 0,
      "text": "1.2. Levels and Expression Types",
      "section_title": true,
      "ja": "1.2. レベルと式のタイプ"
    },
    {
      "indent": 3,
      "text": "URI Templates are similar to a macro language with a fixed set of macro definitions: the expression type determines the expansion process. The default expression type is simple string expansion, wherein a single named variable is replaced by its value as a string after pct-encoding any characters not in the set of unreserved URI characters (Section 1.5).",
      "ja": "URIテンプレートは、マクロ定義の固定セットを持つマクロ言語に似ています。式のタイプによって展開プロセスが決まります。デフォルトの式のタイプは単純な文字列展開です。単一の名前付き変数は、予約されていないURI文字のセットにない文字をpctエンコードした後、その値によって文字列に置き換えられます（セクション1.5）。"
    },
    {
      "indent": 3,
      "text": "Since most template processors implemented prior to this specification have only implemented the default expression type, we refer to these as Level 1 templates.",
      "ja": "この仕様以前に実装されたほとんどのテンプレートプロセッサは、デフォルトの式タイプのみを実装しているため、これらをレベル1テンプレートと呼びます。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 1 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | Simple string expansion                       (Sec 3.2.2) |\n|     |                                                           |\n|     |    {var}                 value                            |\n|     |    {hello}               Hello%20World%21                 |\n`-----------------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Level 2 templates add the plus (\"+\") operator, for expansion of values that are allowed to include reserved URI characters (Section 1.5), and the crosshatch (\"#\") operator for expansion of fragment identifiers.",
      "ja": "レベル2テンプレートは、予約済みURI文字（セクション1.5）を含めることができる値の展開のためのプラス（ \"+\"）演算子と、フラグメント識別子の展開のためのクロスハッチ（ \"＃\"）演算子を追加します。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 2 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             path  := \"/foo/bar\"                                 |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|  +  | Reserved string expansion                     (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+var}                value                            |\n|     |    {+hello}              Hello%20World!                   |\n|     |    {+path}/here          /foo/bar/here                    |\n|     |    here?ref={+path}      here?ref=/foo/bar                |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion, crosshatch-prefixed       (Sec 3.2.4) |\n|     |                                                           |\n|     |    X{#var}               X#value                          |\n|     |    X{#hello}             X#Hello%20World!                 |\n`-----------------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Level 3 templates allow multiple variables per expression, each separated by a comma, and add more complex operators for dot-prefixed labels, slash-prefixed path segments, semicolon-prefixed path parameters, and the form-style construction of a query syntax consisting of name=value pairs that are separated by an ampersand character.",
      "ja": "レベル3のテンプレートでは、式ごとに複数の変数を使用できます。各変数はコンマで区切られ、ドットで始まるラベル、スラッシュで始まるパスセグメント、セミコロンで始まるパスパラメータ、およびフォームスタイルのクエリ構文の構成に、より複雑な演算子を追加しますアンパサンド文字で区切られた名前=値のペア。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 3 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             empty := \"\"                                         |\n|             path  := \"/foo/bar\"                                 |\n|             x     := \"1024\"                                     |\n|             y     := \"768\"                                      |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | String expansion with multiple variables      (Sec 3.2.2) |\n|     |                                                           |\n|     |    map?{x,y}             map?1024,768                     |\n|     |    {x,hello,y}           1024,Hello%20World%21,768        |\n|     |                                                           |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|-----+-----------------------------------------------------------|\n|  +  | Reserved expansion with multiple variables    (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+x,hello,y}          1024,Hello%20World!,768          |\n|     |    {+path,x}/here        /foo/bar,1024/here               |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion with multiple variables    (Sec 3.2.4) |\n|     |                                                           |\n|     |    {#x,hello,y}          #1024,Hello%20World!,768         |\n|     |    {#path,x}/here        #/foo/bar,1024/here              |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n|     |                                                           |\n|     |    X{.var}               X.value                          |\n|     |    X{.x,y}               X.1024.768                       |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n|     |                                                           |\n|     |    {/var}                /value                           |\n|     |    {/var,x}/here         /value/1024/here                 |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n|     |                                                           |\n|     |    {;x,y}                ;x=1024;y=768                    |\n|     |    {;x,y,empty}          ;x=1024;y=768;empty              |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n|     |                                                           |\n|     |    {?x,y}                ?x=1024&y=768                    |\n|     |    {?x,y,empty}          ?x=1024&y=768&empty=             |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  &  | Form-style query continuation                 (Sec 3.2.9) |\n|     |                                                           |\n|     |    ?fixed=yes{&x}        ?fixed=yes&x=1024                |\n|     |    {&x,y,empty}          &x=1024&y=768&empty=             |\n|     |                                                           |\n`-----------------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Finally, Level 4 templates add value modifiers as an optional suffix to each variable name. A prefix modifier (\":\") indicates that only a limited number of characters from the beginning of the value are used by the expansion (Section 2.4.1). An explode (\"*\") modifier",
      "ja": "最後に、レベル4テンプレートは、各変数名にオプションの接尾辞として値修飾子を追加します。接頭辞修飾子（ \"：\"）は、値の先頭から限られた数の文字のみが展開で使用されることを示します（セクション2.4.1）。分解（ \"*\"）修飾子"
    },
    {
      "indent": 3,
      "text": "indicates that the variable is to be treated as a composite value, consisting of either a list of names or an associative array of (name, value) pairs, that is expanded as if each member were a separate variable (Section 2.4.2).",
      "ja": "変数が、名前のリストまたは（名前、値）ペアの連想配列で構成される複合値として扱われ、各メンバーが個別の変数であるかのように展開されることを示します（セクション2.4.2）。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 4 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             path  := \"/foo/bar\"                                 |\n|             list  := (\"red\", \"green\", \"blue\")                   |\n|             keys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]   |\n|                                                                 |\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | String expansion with value modifiers         (Sec 3.2.2) |\n|     |                                                           |\n|     |    {var:3}               val                              |\n|     |    {var:30}              value                            |\n|     |    {list}                red,green,blue                   |\n|     |    {list*}               red,green,blue                   |\n|     |    {keys}                semi,%3B,dot,.,comma,%2C         |\n|     |    {keys*}               semi=%3B,dot=.,comma=%2C         |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  +  | Reserved expansion with value modifiers       (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+path:6}/here        /foo/b/here                      |\n|     |    {+list}               red,green,blue                   |\n|     |    {+list*}              red,green,blue                   |\n|     |    {+keys}               semi,;,dot,.,comma,,             |\n|     |    {+keys*}              semi=;,dot=.,comma=,             |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion with value modifiers       (Sec 3.2.4) |\n|     |                                                           |\n|     |    {#path:6}/here        #/foo/b/here                     |\n|     |    {#list}               #red,green,blue                  |\n|     |    {#list*}              #red,green,blue                  |\n|     |    {#keys}               #semi,;,dot,.,comma,,            |\n|     |    {#keys*}              #semi=;,dot=.,comma=,            |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n|     |                                                           |\n|     |    X{.var:3}             X.val                            |\n|     |    X{.list}              X.red,green,blue                 |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|     |    X{.list*}             X.red.green.blue                 |\n|     |    X{.keys}              X.semi,%3B,dot,.,comma,%2C       |\n|     |    X{.keys*}             X.semi=%3B.dot=..comma=%2C       |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n|     |                                                           |\n|     |    {/var:1,var}          /v/value                         |\n|     |    {/list}               /red,green,blue                  |\n|     |    {/list*}              /red/green/blue                  |\n|     |    {/list*,path:4}       /red/green/blue/%2Ffoo           |\n|     |    {/keys}               /semi,%3B,dot,.,comma,%2C        |\n|     |    {/keys*}              /semi=%3B/dot=./comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n|     |                                                           |\n|     |    {;hello:5}            ;hello=Hello                     |\n|     |    {;list}               ;list=red,green,blue             |\n|     |    {;list*}              ;list=red;list=green;list=blue   |\n|     |    {;keys}               ;keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {;keys*}              ;semi=%3B;dot=.;comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n|     |                                                           |\n|     |    {?var:3}              ?var=val                         |\n|     |    {?list}               ?list=red,green,blue             |\n|     |    {?list*}              ?list=red&list=green&list=blue   |\n|     |    {?keys}               ?keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {?keys*}              ?semi=%3B&dot=.&comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  &  | Form-style query continuation                 (Sec 3.2.9) |\n|     |                                                           |\n|     |    {&var:3}              &var=val                         |\n|     |    {&list}               &list=red,green,blue             |\n|     |    {&list*}              &list=red&list=green&list=blue   |\n|     |    {&keys}               &keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {&keys*}              &semi=%3B&dot=.&comma=%2C        |\n|     |                                                           |\n`-----------------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1.3. Design Considerations",
      "section_title": true,
      "ja": "1.3. 設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Mechanisms similar to URI Templates have been defined within several specifications, including WSDL [WSDL], WADL [WADL], and OpenSearch [OpenSearch]. This specification extends and formally defines the",
      "ja": "URIテンプレートと同様のメカニズムは、WSDL [WSDL]、WADL [WADL]、OpenSearch [OpenSearch]など、いくつかの仕様で定義されています。この仕様は、"
    },
    {
      "indent": 3,
      "text": "syntax so that URI Templates can be used consistently across multiple Internet applications and within Internet message fields, while at the same time retaining compatibility with those earlier definitions.",
      "ja": "複数のインターネットアプリケーション間およびインターネットメッセージフィールド内でURIテンプレートを一貫して使用できると同時に、以前の定義との互換性を維持できるようにする構文。"
    },
    {
      "indent": 3,
      "text": "The URI Template syntax has been designed to carefully balance the need for a powerful expansion mechanism with the need for ease of implementation. The syntax is designed to be trivial to parse while at the same time providing enough flexibility to express many common template scenarios. Implementations are able to parse the template and perform the expansions in a single pass.",
      "ja": "URIテンプレート構文は、強力な拡張メカニズムの必要性と実装の容易さの必​​要性とのバランスを慎重に保つように設計されています。構文は簡単に解析できるように設計されていると同時に、多くの一般的なテンプレートシナリオを表現するのに十分な柔軟性を備えています。実装はテンプレートを解析し、単一のパスで展開を実行できます。"
    },
    {
      "indent": 3,
      "text": "Templates are simple and readable when used with common examples because the single-character operators match the URI generic syntax delimiters. The operator's associated delimiter (\".\", \";\", \"/\", \"?\", \"&\", and \"#\") is omitted when none of the listed variables are defined. Likewise, the expansion process for \";\" (path-style parameters) will omit the \"=\" when the variable value is empty, whereas the process for \"?\" (form-style parameters) will not omit the \"=\" when the value is empty. Multiple variables and list values have their values joined with \",\" if there is no predefined joining mechanism for the operator. The \"+\" and \"#\" operators will substitute unencoded reserved characters found inside the variable values; the other operators will pct-encode reserved characters found in the variable values prior to expansion.",
      "ja": "単一文字の演算子がURIの一般的な構文区切り文字と一致するため、テンプレートは一般的な例で使用するとシンプルで読みやすくなります。演算子に関連付けられた区切り文字（ \"。\"、 \";\"、 \"/\"、 \"？\"、 \"＆\"、および \"＃\"）は、リストされた変数が定義されていない場合は省略されます。同様に、「;」の展開プロセス。 （パススタイルのパラメーター）は、変数の値が空の場合は「=」を省略しますが、「？」の処理は省略します（フォームスタイルのパラメーター）は、値が空のときに「=」を省略しません。オペレーターに事前定義された結合メカニズムがない場合は、複数の変数とリスト値の値が「、」で結合されています。 「+」および「＃」演算子は、変数値内にあるエンコードされていない予約文字を置き換えます。他の演算子は、展開前に変数値にある予約文字をpctエンコードします。"
    },
    {
      "indent": 3,
      "text": "The most common cases for URI spaces can be described with Level 1 template expressions. If we were only concerned with URI generation, then the template syntax could be limited to just simple variable expansion, since more complex forms could be generated by changing the variable values. However, URI Templates have the additional goal of describing the layout of identifiers in terms of preexisting data values. Therefore, the template syntax includes operators that reflect how resource identifiers are commonly allocated. Likewise, since prefix substrings are often used to partition large spaces of resources, modifiers on variable values provide a way to specify both the substring and the full value string with a single variable name.",
      "ja": "URIスペースの最も一般的なケースは、レベル1のテンプレート式で説明できます。変数の値を変更することでより複雑なフォームを生成できるため、URIの生成のみに関心がある場合は、テンプレートの構文を単純な変数展開に限定できます。ただし、URIテンプレートには、既存のデータ値の観点から識別子のレイアウトを記述するという追加の目標があります。したがって、テンプレート構文には、リソース識別子が一般的に割り当てられる方法を反映する演算子が含まれています。同様に、プレフィックス部分文字列はリソースの大きなスペースを分割するためによく使用されるため、変数値の修飾子は、単一の変数名で部分文字列と完全な値文字列の両方を指定する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "1.4. Limitations",
      "section_title": true,
      "ja": "1.4. 制限事項"
    },
    {
      "indent": 3,
      "text": "Since a URI Template describes a superset of the identifiers, there is no implication that every possible expansion for each delimited variable expression corresponds to a URI of an existing resource. Our expectation is that an application constructing URIs according to the template will be provided with an appropriate set of values for the variables being substituted, or at least a means of validating user data-entry for those values.",
      "ja": "URIテンプレートは識別子のスーパーセットを記述するため、区切られた変数式ごとに可能なすべての展開が既存のリソースのURIに対応するという意味はありません。テンプレートに従ってURIを構築するアプリケーションには、置換される変数の適切な値のセット、または少なくともそれらの値のユーザーデータエントリを検証する手段が提供されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "URI Templates are not URIs: they do not identify an abstract or physical resource, they are not parsed as URIs, and they should not be used in places where a URI would be expected unless the template expressions will be expanded by a template processor prior to use. Distinct field, element, or attribute names should be used to differentiate protocol elements that carry a URI Template from those that expect a URI reference.",
      "ja": "URIテンプレートはURIではありません。抽象リソースまたは物理リソースを識別せず、URIとして解析されません。また、テンプレートプロセッサによってテンプレート式が展開される前に、URIが期待される場所では使用しないでください。使用する。固有のフィールド、要素、または属性名を使用して、URIテンプレートを保持するプロトコル要素を、URI参照を期待するものと区別する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some URI Templates can be used in reverse for the purpose of variable matching: comparing the template to a fully formed URI in order to extract the variable parts from that URI and assign them to the named variables. Variable matching only works well if the template expressions are delimited by the beginning or end of the URI or by characters that cannot be part of the expansion, such as reserved characters surrounding a simple string expression. In general, regular expression languages are better suited for variable matching.",
      "ja": "一部のURIテンプレートは、変数照合の目的で逆に使用できます。テンプレートを完全に形成されたURIと比較して、そのURIから変数部分を抽出し、それらを名前付き変数に割り当てます。変数の照合は、テンプレート式がURIの最初または最後、または単純な文字列式を囲む予約文字など、展開の一部にできない文字で区切られている場合にのみ機能します。一般に、正規表現言語は変数のマッチングに適しています。"
    },
    {
      "indent": 0,
      "text": "1.5. Notational Conventions",
      "section_title": true,
      "ja": "1.5. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234]. The following ABNF rules are imported from the normative references [RFC5234], [RFC3986], and [RFC3987].",
      "ja": "この仕様では、[RFC5234]の拡張バッカスナウアフォーム（ABNF）表記を使用しています。次のABNFルールは、規範的な参照[RFC5234]、[RFC3986]、および[RFC3987]からインポートされます。"
    },
    {
      "indent": 5,
      "text": "ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\nDIGIT          =  %x30-39             ; 0-9\nHEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n                  ; case-insensitive",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "pct-encoded    =  \"%\" HEXDIG HEXDIG\nunreserved     =  ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nreserved       =  gen-delims / sub-delims\ngen-delims     =  \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\nsub-delims     =  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n               /  \"*\" / \"+\" / \",\" / \";\" / \"=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ucschar        =  %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF\n               /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD\n               /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD\n               /  %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD\n               /  %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD\n               /  %xD0000-DFFFD / %xE1000-EFFFD",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1.6. Character Encoding and Unicode Normalization",
      "section_title": true,
      "ja": "1.6. 文字エンコーディングとUnicode正規化"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"character\", \"character encoding scheme\", \"code point\", \"coded character set\", \"glyph\", \"non-ASCII\", \"normalization\", \"protocol element\", and \"regular expression\" as they are defined in [RFC6365].",
      "ja": "この仕様では、「文字」、「文字コード化スキーム」、「コードポイント」、「コード化文字セット」、「グリフ」、「非ASCII」、「正規化」、「プロトコル要素」、「正規表現」という用語を使用します。 [RFC6365]で定義されているとおり。"
    },
    {
      "indent": 3,
      "text": "The ABNF notation defines its terminal values to be non-negative integers (code points) that are a superset of the US-ASCII coded character set [ASCII]. This specification defines terminal values as code points within the Unicode coded character set [UNIV6].",
      "ja": "ABNF表記では、US-ASCIIコード化文字セット[ASCII]のスーパーセットである負でない整数（コードポイント）としてその終端値を定義します。この仕様では、端末値をUnicodeコード化文字セット[UNIV6]内のコードポイントとして定義しています。"
    },
    {
      "indent": 3,
      "text": "In spite of the syntax and template expansion process being defined in terms of Unicode code points, it should be understood that templates occur in practice as a sequence of characters in whatever form or encoding is suitable for the context in which they occur, whether that be octets embedded in a network protocol element or glyphs painted on the side of a bus. This specification does not mandate any particular character encoding scheme for mapping between URI Template characters and the octets used to store or transmit those characters. When a URI Template appears in a protocol element, the character encoding scheme is defined by that protocol; without such a definition, a URI Template is assumed to be in the same character encoding scheme as the surrounding text. It is only during the process of template expansion that a string of characters in a URI Template is REQUIRED to be processed as a sequence of Unicode code points.",
      "ja": "構文およびテンプレート拡張プロセスがUnicodeコードポイントの観点から定義されているにもかかわらず、実際には、テンプレートは、発生するコンテキストに適した形式またはエンコーディングの文字シーケンスとして発生することを理解する必要があります。ネットワークプロトコル要素に埋め込まれたオクテット、またはバスの側面に描かれたグリフ。この仕様は、URIテンプレート文字とそれらの文字の格納または送信に使用されるオクテットとの間のマッピングのための特定の文字エンコードスキームを義務付けていません。 URIテンプレートがプロトコル要素に表示される場合、文字エンコードスキームはそのプロトコルによって定義されます。そのような定義がない場合、URIテンプレートは周囲のテキストと同じ文字エンコードスキームにあると想定されます。 URIテンプレートの文字列をUnicodeコードポイントのシーケンスとして処理する必要があるのは、テンプレート拡張のプロセス中だけです。"
    },
    {
      "indent": 3,
      "text": "The Unicode Standard [UNIV6] defines various equivalences between sequences of characters for various purposes. Unicode Standard Annex #15 [UTR15] defines various Normalization Forms for these equivalences. The normalization form determines how to consistently encode equivalent strings. In theory, all URI processing implementations, including template processors, should use the same normalization form for generating a URI reference. In practice, they do not. If a value has been provided by the same server as the resource, then it can be assumed that the string is already in the form expected by that server. If a value is provided by a user, such as via a data-entry dialog, then the string SHOULD be normalized as Normalization Form C (NFC: Canonical Decomposition, followed by Canonical Composition) prior to being used in expansions by a template processor.",
      "ja": "Unicode標準[UNIV6]は、さまざまな目的で文字シーケンス間のさまざまな同等性を定義しています。ユニコード標準付属文書＃15 [UTR15]は、これらの同値のさまざまな正規化形式を定義しています。正規化形式は、同等の文字列を一貫してエンコードする方法を決定します。理論的には、テンプレートプロセッサを含むすべてのURI処理実装は、URI参照の生成に同じ正規化形式を使用する必要があります。実際には、そうではありません。値がリソースと同じサーバーによって提供されている場合、文字列はそのサーバーが予期する形式になっていると想定できます。データ入力ダイアログなどを通じてユーザーが値を提供する場合、テンプレートプロセッサによる拡張で使用する前に、文字列を正規化フォームC（NFC：Canonical Decomposition、続いてCanonical Composition）として正規化する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Likewise, when non-ASCII data that represents readable strings is pct-encoded for use in a URI reference, a template processor MUST first encode the string as UTF-8 [RFC3629] and then pct-encode any octets that are not allowed in a URI reference.",
      "ja": "同様に、読み取り可能な文字列を表す非ASCIIデータがURI参照で使用するためにpctエンコードされる場合、テンプレートプロセッサは最初に文字列をUTF-8 [RFC3629]としてエンコードし、次に許可されていないオクテットをpctエンコードする必要があります。 URI参照。"
    },
    {
      "indent": 0,
      "text": "2. Syntax",
      "section_title": true,
      "ja": "2. 構文"
    },
    {
      "indent": 3,
      "text": "A URI Template is a string of printable Unicode characters that contains zero or more embedded variable expressions, each expression being delimited by a matching pair of braces ('{', '}').",
      "ja": "URIテンプレートは、0個以上の埋め込み変数式を含む印刷可能なUnicode文字の文字列であり、各式は対応する中括弧のペア（ '{'、 '}'）で区切られます。"
    },
    {
      "indent": 5,
      "text": "URI-Template  = *( literals / expression )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Although templates (and template processor implementations) are described above in terms of four gradual levels, we define the URI-Template syntax in terms of the ABNF for Level 4. A template processor limited to lower-level templates MAY exclude the ABNF rules applicable only to higher levels. However, it is RECOMMENDED that all parsers implement the full syntax such that unsupported levels can be properly identified as such to the end user.",
      "ja": "テンプレート（およびテンプレートプロセッサの実装）は、4つの段階的なレベルに関して上記で説明されていますが、レベル4のABNFに関してURI-Template構文を定義します。下位レベルのテンプレートに限定されたテンプレートプロセッサは、適用可能なABNFルールのみを除外する場合がありますより高いレベルに。ただし、サポートされていないレベルをエンドユーザーに適切に識別できるように、すべてのパーサーが完全な構文を実装することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2.1. Literals",
      "section_title": true,
      "ja": "2.1. リテラル"
    },
    {
      "indent": 3,
      "text": "The characters outside of expressions in a URI Template string are intended to be copied literally to the URI reference if the character is allowed in a URI (reserved / unreserved / pct-encoded) or, if not allowed, copied to the URI reference as the sequence of pct-encoded triplets corresponding to that character's encoding in UTF-8 [RFC3629].",
      "ja": "URIテンプレート文字列内の式の外の文字は、文字がURIで許可されている場合（予約済み/未予約/ pct-encoded）、文字どおりにURI参照にコピーされるか、許可されていない場合は、URI参照としてUTF-8 [RFC3629]でのその文字のエンコーディングに対応するpctエンコードされたトリプレットのシーケンス。"
    },
    {
      "indent": 5,
      "text": "literals      =  %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B\n              /  %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate\n              /  pct-encoded\n                   ; any Unicode character except: CTL, SP,\n                   ;  DQUOTE, \"'\", \"%\" (aside from pct-encoded),\n                   ;  \"<\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", \"}\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2. Expressions",
      "section_title": true,
      "ja": "2.2. 式"
    },
    {
      "indent": 3,
      "text": "Template expressions are the parameterized parts of a URI Template. Each expression contains an optional operator, which defines the expression type and its corresponding expansion process, followed by a comma-separated list of variable specifiers (variable names and optional value modifiers). If no operator is provided, the expression defaults to simple variable expansion of unreserved values.",
      "ja": "テンプレート式は、URIテンプレートのパラメーター化された部分です。各式には、式のタイプとそれに対応する展開プロセスを定義するオプションの演算子が含まれ、その後に変数指定子（変数名とオプションの値修飾子）のコンマ区切りのリストが続きます。演算子を指定しない場合、式はデフォルトで予約されていない値の単純な変数展開になります。"
    },
    {
      "indent": 5,
      "text": "expression    =  \"{\" [ operator ] variable-list \"}\"\noperator      =  op-level2 / op-level3 / op-reserve\nop-level2     =  \"+\" / \"#\"\nop-level3     =  \".\" / \"/\" / \";\" / \"?\" / \"&\"\nop-reserve    =  \"=\" / \",\" / \"!\" / \"@\" / \"|\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The operator characters have been chosen to reflect each of their roles as reserved characters in the URI generic syntax. The operators defined in Section 3 of this specification include:",
      "ja": "演算子文字は、URIの一般的な構文の予約文字として、それぞれの役割を反映するように選択されています。この仕様のセクション3で定義されている演算子は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "+ Reserved character strings;",
      "ja": "+ 予約文字列。"
    },
    {
      "indent": 6,
      "text": "#   Fragment identifiers prefixed by \"#\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": ". Name labels or extensions prefixed by \".\";",
      "ja": "。接頭辞が「。」の名前ラベルまたは拡張子。"
    },
    {
      "indent": 6,
      "text": "/   Path segments prefixed by \"/\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": ";   Path parameter name or name=value pairs prefixed by \";\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "? Query component beginning with \"?\" and consisting of name=value pairs separated by \"&\"; and,",
      "ja": "？ 「？」で始まるクエリコンポーネント「＆」で区切られた名前=値のペアで構成されます。そして、"
    },
    {
      "indent": 6,
      "text": "& Continuation of query-style &name=value pairs within a literal query component.",
      "ja": "＆リテラルクエリコンポーネント内のクエリスタイル＆name = valueペアの継続。"
    },
    {
      "indent": 3,
      "text": "The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"), at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.",
      "ja": "等号（ \"=\"）、コンマ（ \"、\"）、感嘆符（ \"！\"）、アットマーク（ \"@\"）、およびパイプ（ \"|\"）は、将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The expression syntax specifically excludes use of the dollar (\"$\") and parentheses [\"(\" and \")\"] characters so that they remain available for use outside the scope of this specification. For example, a macro language might use these characters to apply macro substitution to a string prior to that string being processed as a URI Template.",
      "ja": "式の構文では、ドル（ \"$\"）および括弧[\"（\"および \"）\"]文字の使用を明確に除外しているため、この仕様の範囲外でも使用できます。たとえば、マクロ言語はこれらの文字を使用して、文字列がURIテンプレートとして処理される前に、その文字列にマクロ置換を適用できます。"
    },
    {
      "indent": 0,
      "text": "2.3. Variables",
      "section_title": true,
      "ja": "2.3. 変数"
    },
    {
      "indent": 3,
      "text": "After the operator (if any), each expression contains a list of one or more comma-separated variable specifiers (varspec). The variable names serve multiple purposes: documentation for what kinds of values are expected, identifiers for associating values within a template processor, and the literal string to use for the name in name=value expansions (aside from when exploding an associative array). Variable names are case-sensitive because the name might be expanded within a case-sensitive URI component.",
      "ja": "演算子（ある場合）の後、各式には、1つ以上のコンマ区切りの変数指定子（varspec）のリストが含まれます。変数名は、期待される値の種類に関するドキュメント、テンプレートプロセッサ内で値を関連付けるための識別子、およびname = value展開で名前に使用するリテラル文字列（連想配列の展開時を除く）の複数の目的に役立ちます。変数名は、大文字と小文字が区別されるURIコンポーネント内で展開される可能性があるため、大文字と小文字が区別されます。"
    },
    {
      "indent": 5,
      "text": "variable-list =  varspec *( \",\" varspec )\nvarspec       =  varname [ modifier-level4 ]\nvarname       =  varchar *( [\".\"] varchar )\nvarchar       =  ALPHA / DIGIT / \"_\" / pct-encoded",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A varname MAY contain one or more pct-encoded triplets. These triplets are considered an essential part of the variable name and are not decoded during processing. A varname containing pct-encoded characters is not the same variable as a varname with those same characters decoded. Applications that provide URI Templates are expected to be consistent in their use of pct-encoding within variable names.",
      "ja": "varnameには、1つ以上のpctエンコードされたトリプレットが含まれる場合があります。これらのトリプレットは変数名の重要な部分と見なされ、処理中にデコードされません。 pctエンコードされた文字を含む変数名は、同じ文字がデコードされた変数名と同じ変数ではありません。 URIテンプレートを提供するアプリケーションは、変数名内でのpct-encodingの使用に一貫性があることが期待されます。"
    },
    {
      "indent": 3,
      "text": "An expression MAY reference variables that are unknown to the template processor or whose value is set to a special \"undefined\" value, such as undef or null. Such undefined variables are given special treatment by the expansion process (Section 3.2.1).",
      "ja": "式は、テンプレートプロセッサにとって未知の変数、またはundefやnullなどの特別な「未定義」値に値が設定されている変数を参照する場合があります。そのような未定義の変数は、展開プロセス（セクション3.2.1）によって特別な扱いが与えられます。"
    },
    {
      "indent": 3,
      "text": "A variable value that is a string of length zero is not considered undefined; it has the defined value of an empty string.",
      "ja": "長さがゼロのストリングである変数値は、未定義とは見なされません。空の文字列の値が定義されています。"
    },
    {
      "indent": 3,
      "text": "In Level 4 templates, a variable may have a composite value in the form of a list of values or an associative array of (name, value) pairs. Such value types are not directly indicated by the template syntax, but they do have an impact on the expansion process (Section 3.2.1).",
      "ja": "レベル4のテンプレートでは、変数は値のリストまたは（名前、値）のペアの連想配列の形式の複合値を持つことができます。このような値タイプは、テンプレート構文では直接示されませんが、展開プロセスに影響を与えます（セクション3.2.1）。"
    },
    {
      "indent": 3,
      "text": "A variable defined as a list value is considered undefined if the list contains zero members. A variable defined as an associative array of (name, value) pairs is considered undefined if the array contains zero members or if all member names in the array are associated with undefined values.",
      "ja": "リストにメンバーが含まれていない場合、リスト値として定義された変数は未定義と見なされます。 （name、value）ペアの連想配列として定義された変数は、配列にメンバーが含まれていない場合、または配列内のすべてのメンバー名が未定義の値に関連付けられている場合、未定義と見なされます。"
    },
    {
      "indent": 0,
      "text": "2.4. Value Modifiers",
      "section_title": true,
      "ja": "2.4. 値修飾子"
    },
    {
      "indent": 3,
      "text": "Each of the variables in a Level 4 template expression can have a modifier indicating either that its expansion is limited to a prefix of the variable's value string or that its expansion is exploded as a composite value in the form of a value list or an associative array of (name, value) pairs.",
      "ja": "レベル4のテンプレート式の各変数には、その展開が変数の値文字列の接頭辞に制限されること、またはその展開が値リストまたは連想配列の形式の複合値として展開されることを示す修飾子を含めることができます（名前、値）ペアの。"
    },
    {
      "indent": 5,
      "text": "modifier-level4 =  prefix / explode",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.4.1. Prefix Values",
      "section_title": true,
      "ja": "2.4.1. プレフィックス値"
    },
    {
      "indent": 3,
      "text": "A prefix modifier indicates that the variable expansion is limited to a prefix of the variable's value string. Prefix modifiers are often used to partition an identifier space hierarchically, as is common in reference indices and hash-based storage. It also serves to limit the expanded value to a maximum number of characters. Prefix modifiers are not applicable to variables that have composite values.",
      "ja": "接頭辞修飾子は、変数の展開が変数の値文字列の接頭辞に制限されることを示します。プレフィックス修飾子は、参照インデックスとハッシュベースのストレージで一般的であるように、識別子スペースを階層的に分割するためによく使用されます。また、拡張された値を最大文字数に制限することもできます。プレフィックス修飾子は、複合値を持つ変数には適用されません。"
    },
    {
      "indent": 5,
      "text": "prefix        =  \":\" max-length\nmax-length    =  %x31-39 0*3DIGIT   ; positive integer < 10000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The max-length is a positive integer that refers to a maximum number of characters from the beginning of the variable's value as a Unicode string. Note that this numbering is in characters, not octets, in order to avoid splitting between the octets of a multi-octet-encoded character or within a pct-encoded triplet. If the max-length is greater than the length of the variable's value, then the entire value string is used.",
      "ja": "max-lengthは、変数の値の先頭からUnicode文字列としての最大文字数を参照する正の整数です。マルチオクテットエンコードされた文字のオク​​テット間またはpctエンコードされたトリプレット内での分割を避けるために、この番号付けはオクテットではなく文字であることに注意してください。 max-lengthが変数の値の長さより大きい場合、値の文字列全体が使用されます。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 5,
      "text": "Given the variable assignments",
      "ja": "変数の割り当てを考える"
    },
    {
      "indent": 7,
      "text": "var   := \"value\"\nsemi  := \";\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{var}              value\n{var:20}           value\n{var:3}            val\n{semi}             %3B\n{semi:2}           %3B",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.4.2. Composite Values",
      "section_title": true,
      "ja": "2.4.2. 複合値"
    },
    {
      "indent": 3,
      "text": "An explode (\"*\") modifier indicates that the variable is to be treated as a composite value consisting of either a list of values or an associative array of (name, value) pairs. Hence, the expansion process is applied to each member of the composite as if it were listed as a separate variable. This kind of variable specification is significantly less self-documenting than non-exploded variables, since there is less correspondence between the variable name and how the URI reference appears after expansion.",
      "ja": "分解（ \"*\"）修飾子は、変数が値のリストまたは（名前、値）ペアの連想配列のいずれかで構成される複合値として扱われることを示します。したがって、拡張プロセスは、コンポジットの各メンバーに、個別の変数としてリストされているかのように適用されます。変数名と展開後にURI参照がどのように表示されるかの間の対応が少ないため、この種の変数仕様は、展開されていない変数よりも自己文書化が大幅に少なくなります。"
    },
    {
      "indent": 5,
      "text": "explode = \"*\"",
      "ja": "分解= \"*\""
    },
    {
      "indent": 3,
      "text": "Since URI Templates do not contain an indication of type or schema, the type for an exploded variable is assumed to be determined by context. For example, the processor might be supplied values in a form that differentiates values as strings, lists, or associative arrays. Likewise, the context in which the template is used (script, mark-up language, Interface Definition Language, etc.) might define rules for associating variable names with types, structures, or schema.",
      "ja": "URIテンプレートにはタイプまたはスキーマの指示が含まれていないため、展開された変数のタイプはコンテキストによって決定されると想定されます。たとえば、プロセッサには、値を文字列、リスト、または連想配列として区別する形式で値が提供される場合があります。同様に、テンプレートが使用されるコンテキスト（スクリプト、マークアップ言語、インターフェース定義言語など）は、変数名を型、構造、またはスキーマに関連付けるためのルールを定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "Explode modifiers improve brevity in the URI Template syntax. For example, a resource that provides a geographic map for a given street address might accept a hundred permutations on fields for address input, including partial addresses (e.g., just the city or postal code). Such a resource could be described as a template with each and every address component listed in order, or with a far more simple template that makes use of an explode modifier, as in",
      "ja": "分解修飾子は、URIテンプレート構文の簡潔さを向上させます。たとえば、特定の住所に地理的地図を提供するリソースは、部分的な住所（たとえば、都市または郵便番号のみ）を含む住所入力のフィールドで100の順列を受け入れる場合があります。このようなリソースは、すべての住所コンポーネントが順番にリストされたテンプレート、または次のように分解修飾子を使用するはるかに単純なテンプレートとして説明できます。"
    },
    {
      "indent": 6,
      "text": "/mapper{?address*}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "along with some context that defines what the variable named \"address\" can include, such as by reference to some other standard for addressing (e.g., [UPU-S42]). A recipient aware of the schema can then provide appropriate expansions, such as:",
      "ja": "「address」という名前の変数が何を含むことができるかを定義するいくつかのコンテキストとともに、たとえば、アドレス指定に関する他の標準（[UPU-S42]など）を参照することによって。スキーマを認識している受信者は、次のような適切な拡張を提供できます。"
    },
    {
      "indent": 6,
      "text": "/mapper?city=Newport%20Beach&state=CA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The expansion process for exploded variables is dependent on both the operator being used and whether the composite value is to be treated as a list of values or as an associative array of (name, value) pairs. Structures are processed as if they are an associative array with names corresponding to the fields in the structure definition and \".\" separators used to indicate name hierarchy in substructures.",
      "ja": "展開された変数の展開プロセスは、使用されている演算子と、複合値が値のリストとして扱われるか、または（名前、値）ペアの連想配列として扱われるかによって異なります。構造体は、構造体定義のフィールドに対応する名前と \"。\"を持つ連想配列であるかのように処理されます。部分構造の名前階層を示すために使用されるセパレータ。"
    },
    {
      "indent": 3,
      "text": "If a variable has a composite structure and only some of the fields in that structure have defined values, then only the defined pairs are present in the expansion. This can be useful for templates that consist of a large number of potential query terms.",
      "ja": "変数が複合構造を持ち、その構造内の一部のフィールドのみに値が定義されている場合、定義されたペアのみが展開に存在します。これは、多数の潜在的なクエリ用語で構成されるテンプレートに役立ちます。"
    },
    {
      "indent": 3,
      "text": "An explode modifier applied to a list variable causes the expansion to iterate over the list's member values. For path and query parameter expansions, each member value is paired with the variable's name as a (varname, value) pair. This allows path and query parameters to be repeated for multiple values, as in",
      "ja": "リスト変数に分解修飾子を適用すると、リストのメンバー値に対して展開が繰り返されます。パスおよびクエリパラメータの展開では、各メンバー値は（varname、value）ペアとして変数名とペアになります。これにより、次のように、パスおよびクエリパラメータを複数の値に対して繰り返すことができます。"
    },
    {
      "indent": 5,
      "text": "Given the variable assignments",
      "ja": "変数の割り当てを考える"
    },
    {
      "indent": 7,
      "text": "year  := (\"1965\", \"2000\", \"2012\")\ndom   := (\"example\", \"com\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "find{?year*}       find?year=1965&year=2000&year=2012\nwww{.dom*}         www.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Expansion",
      "section_title": true,
      "ja": "3. 拡張"
    },
    {
      "indent": 3,
      "text": "The process of URI Template expansion is to scan the template string from beginning to end, copying literal characters and replacing each expression with the result of applying the expression's operator to the value of each variable named in the expression. Each variable's value MUST be formed prior to template expansion.",
      "ja": "URIテンプレート拡張のプロセスは、テンプレート文字列を最初から最後までスキャンし、リテラル文字をコピーして、各式を式で指定された各変数の値に式の演算子を適用した結果で置き換えます。各変数の値は、テンプレートを展開する前に形成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The requirements on expansion for each aspect of the URI Template grammar are defined in this section. A non-normative algorithm for the expansion process as a whole is provided in Appendix A.",
      "ja": "このセクションでは、URIテンプレート文法の各側面の拡張に関する要件を定義します。全体としての拡張プロセスの非規範的アルゴリズムは、付録Aで提供されています。"
    },
    {
      "indent": 3,
      "text": "If a template processor encounters a character sequence outside an expression that does not match the <URI-Template> grammar, then processing of the template SHOULD cease, the URI reference result SHOULD contain the expanded part of the template followed by the remainder unexpanded, and the location and type of error SHOULD be indicated to the invoking application.",
      "ja": "テンプレートプロセッサが、<URI-Template>文法と一致しない式の外側の文字シーケンスを検出した場合、テンプレートの処理は停止する必要があり（SHOULD）、URI参照結果には、テンプレートの拡張部分とその後の残りの拡張されていない部分が含まれる必要があります（SHOULD）。エラーの場所とタイプは、呼び出し元のアプリケーションに示す必要があります。"
    },
    {
      "indent": 3,
      "text": "If an error is encountered in an expression, such as an operator or value modifier that the template processor does not recognize or does not yet support, or a character is found that is not allowed by the <expression> grammar, then the unprocessed parts of the expression SHOULD be copied to the result unexpanded, processing of the remainder of the template SHOULD continue, and the location and type of error SHOULD be indicated to the invoking application.",
      "ja": "テンプレートプロセッサが認識しない、またはまだサポートしていない演算子や値修飾子などの式でエラーが発生した場合、または<expression>文法で許可されていない文字が見つかった場合は、式を展開せずに結果にコピーする必要があります（SHOULD）、テンプレートの残りの部分の処理は続行する必要があります（SHOULD）。エラーの場所とタイプは、呼び出し元のアプリケーションに示す必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If an error occurs, the result returned might not be a valid URI reference; it will be an incompletely expanded template string that is only intended for diagnostic use.",
      "ja": "エラーが発生した場合、返される結果は有効なURI参照ではない可能性があります。これは、診断での使用のみを目的とした不完全に拡張されたテンプレート文字列になります。"
    },
    {
      "indent": 0,
      "text": "3.1. Literal Expansion",
      "section_title": true,
      "ja": "3.1. 文字通りの拡張"
    },
    {
      "indent": 3,
      "text": "If the literal character is allowed anywhere in the URI syntax (unreserved / reserved / pct-encoded ), then it is copied directly to the result string. Otherwise, the pct-encoded equivalent of the literal character is copied to the result string by first encoding the character as its sequence of octets in UTF-8 and then encoding each such octet as a pct-encoded triplet.",
      "ja": "リテラル文字がURI構文の任意の場所で許可されている場合（未予約/予約済み/ pct-encoded）、結果文字列に直接コピーされます。それ以外の場合、リテラル文字に相当するpctエンコードされたものは、まず文字をUTF-8のオクテットのシーケンスとしてエンコードし、次にそのような各オクテットをpctエンコードされたトリプレットとしてエンコードすることにより、結果の文字列にコピーされます。"
    },
    {
      "indent": 0,
      "text": "3.2. Expression Expansion",
      "section_title": true,
      "ja": "3.2. 式の拡張"
    },
    {
      "indent": 3,
      "text": "Each expression is indicated by an opening brace (\"{\") character and continues until the next closing brace (\"}\"). Expressions cannot be nested.",
      "ja": "各式は左中括弧（ \"{\"）文字で示され、次の右中括弧（ \"}\"）まで続きます。式はネストできません。"
    },
    {
      "indent": 3,
      "text": "An expression is expanded by determining its expression type and then following that type's expansion process for each comma-separated varspec in the expression. Level 1 templates are limited to the default operator (simple string value expansion) and a single variable per expression. Level 2 templates are limited to a single varspec per expression.",
      "ja": "式は、式のタイプを決定し、式のコンマ区切りのvarspecごとにそのタイプの展開プロセスに従うことで拡張されます。レベル1のテンプレートは、デフォルトの演算子（単純な文字列値の展開）および式ごとに1つの変数に制限されています。レベル2のテンプレートは、式ごとに1つのvarspecに制限されています。"
    },
    {
      "indent": 3,
      "text": "The expression type is determined by looking at the first character after the opening brace. If the character is an operator, then remember the expression type associated with that operator for later expansion decisions and skip to the next character for the variable-list. If the first character is not an operator, then the expression type is simple string expansion and the first character is the beginning of the variable-list.",
      "ja": "式のタイプは、左中括弧の後の最初の文字を見て決定されます。文字が演算子である場合、その後の展開の決定のためにその演算子に関連付けられた式のタイプを覚えて、変数リストの次の文字にスキップします。最初の文字が演算子でない場合、式のタイプは単純な文字列展開であり、最初の文字は変数リストの始まりです。"
    },
    {
      "indent": 3,
      "text": "The examples in the subsections below use the following definitions for variable values:",
      "ja": "以下のサブセクションの例では、変数値に次の定義を使用しています。"
    },
    {
      "indent": 9,
      "text": "count := (\"one\", \"two\", \"three\")\ndom   := (\"example\", \"com\")\ndub   := \"me/too\"\nhello := \"Hello World!\"\nhalf  := \"50%\"\nvar   := \"value\"\nwho   := \"fred\"\nbase  := \"http://example.com/home/\"\npath  := \"/foo/bar\"\nlist  := (\"red\", \"green\", \"blue\")\nkeys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]\nv     := \"6\"\nx     := \"1024\"\ny     := \"768\"\nempty := \"\"\nempty_keys  := []\nundef := null",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.1. Variable Expansion",
      "section_title": true,
      "ja": "3.2.1. 可変拡張"
    },
    {
      "indent": 3,
      "text": "A variable that is undefined (Section 2.3) has no value and is ignored by the expansion process. If all of the variables in an expression are undefined, then the expression's expansion is the empty string.",
      "ja": "未定義の変数（セクション2.3）には値がなく、展開プロセスでは無視されます。式のすべての変数が未定義の場合、式の展開は空の文字列になります。"
    },
    {
      "indent": 0,
      "text": " Variable expansion of a defined, non-empty value results in a substring of allowed URI characters. As described in Section 1.6, the expansion process is defined in terms of Unicode code points in order to ensure that non-ASCII characters are consistently pct-encoded in the resulting URI reference. One way for a template processor to obtain a consistent expansion is to transcode the value string to UTF-8 (if it is not already in UTF-8) and then transform each octet that is not in the allowed set into the corresponding pct-encoded triplet. Another is to map directly from the value's native character encoding to the set of allowed URI characters, with any remaining disallowed characters mapping to the sequence of pct-encoded triplets that correspond to the octet(s) of that character when encoded as UTF-8 [RFC3629].",
      "ja": "空ではない定義された値の変数展開は、許可されたURI文字のサブストリングになります。セクション1.6で説明したように、非ASCII文字が結果のURI参照で一貫してpctエンコードされるようにするために、拡張プロセスはUnicodeコードポイントに関して定義されます。テンプレートプロセッサが一貫した拡張を取得する1つの方法は、値の文字列をUTF-8にトランスコードし（UTF-8になっていない場合）、許可されたセットにない各オクテットを対応するpctエンコードに変換することです。トリプレット。もう1つは、値のネイティブ文字エンコードから許可されたURI文字のセットに直接マッピングし、残りの許可されていない文字を、UTF-8としてエンコードされたときにその文字のオク​​テットに対応するpctエンコードされたトリプレットのシーケンスにマッピングすることです。 [RFC3629]。"
    },
    {
      "indent": 3,
      "text": "The allowed set for a given expansion depends on the expression type: reserved (\"+\") and fragment (\"#\") expansions allow the set of characters in the union of ( unreserved / reserved / pct-encoded ) to be passed through without pct-encoding, whereas all other expression types allow only unreserved characters to be passed through without pct-encoding. Note that the percent character (\"%\") is only allowed as part of a pct-encoded triplet and only for reserved/fragment expansion: in all other cases, a value character of \"%\" MUST be pct-encoded as \"%25\" by variable expansion.",
      "ja": "特定の拡張で許可されるセットは、式のタイプによって異なります。予約済み（ \"+\"）およびフラグメント（ \"＃\"）の拡張では、（unreserved / reserved / pct-encoded）の和集合内の文字のセットを、 pct-encoding。他のすべての式のタイプでは、予約されていない文字のみがpct-encodingなしで渡されます。パーセント文字（ \"％\"）は、pctエンコードされたトリプレットの一部としてのみ、および予約済み/フラグメント展開に対してのみ許可されていることに注意してください。それ以外の場合は、値文字 \"％\"は \"％25\"としてpctエンコードされる必要があります。 \"変数展開による。"
    },
    {
      "indent": 3,
      "text": "If a variable appears more than once in an expression or within multiple expressions of a URI Template, the value of that variable MUST remain static throughout the expansion process (i.e., the variable must have the same value for the purpose of calculating each expansion). However, if reserved characters or pct-encoded triplets occur in the value, they will be pct-encoded by some expression types and not by others.",
      "ja": "変数が1つの式またはURIテンプレートの複数の式内に複数回出現する場合、その変数の値は展開プロセス全体を通じて静的なままである必要があります（つまり、変数は各展開を計算するために同じ値でなければなりません）。ただし、予約文字またはpctエンコードのトリプレットが値に含まれる場合、それらは一部の式タイプではpctエンコードされ、他のタイプではエンコードされません。"
    },
    {
      "indent": 3,
      "text": "For a variable that is a simple string value, expansion consists of appending the encoded value to the result string. An explode modifier has no effect. A prefix modifier limits the expansion to the first max-length characters of the decoded value. If the value contains multi-octet or pct-encoded characters, care must be taken to avoid splitting the value in mid-character: count each Unicode code point as one character.",
      "ja": "単純な文字列値である変数の場合、展開はエンコードされた値を結果の文字列に追加することで構成されます。分解修飾子は効果がありません。プレフィックス修飾子は、展開をデコードされた値の最初の最大長の文字に制限します。値にマルチオクテットまたはpctエンコード文字が含まれている場合、値を文字の途中で分割しないように注意する必要があります。各Unicodeコードポイントを1文字としてカウントします。"
    },
    {
      "indent": 3,
      "text": "For a variable that is an associative array, expansion depends on both the expression type and the presence of an explode modifier. If there is no explode modifier, expansion consists of appending a comma-separated concatenation of each (name, value) pair that has a defined value. If there is an explode modifier, expansion consists of appending each pair that has a defined value as either \"name=value\" or, if the value is the empty string and the expression type does not indicate form-style parameters (i.e., not a \"?\" or \"&\" type), simply \"name\". Both name and value strings are encoded in the same way as simple string values. A separator string is appended between defined pairs according to the expression type, as defined by the following table:",
      "ja": "連想配列である変数の場合、展開は式のタイプと分解修飾子の存在の両方に依存します。展開修飾子がない場合、展開は、定義された値を持つ各（名前、値）ペアのコンマ区切りの連結の追加で構成されます。展開修飾子がある場合、展開は、 \"name = value\"として定義された値を持つ各ペアを追加するか、または値が空の文字列であり、式のタイプがフォームスタイルのパラメーターを示さない（つまり、 「？」または「＆」タイプ）、単に「名前」。名前と値の両方の文字列は、単純な文字列値と同じ方法でエンコードされます。次の表で定義されているように、式のタイプに従って、定義されたペアの間に区切り文字列が追加されます。"
    },
    {
      "indent": 6,
      "text": "Type Separator \",\" (default) + \",\" # \",\" . \".\" / \"/\" ; \";\" ? \"&\" & \"&\"",
      "ja": "タイプセパレータ \"、\"（デフォルト）+ \"、\"＃ \"、\"。 「」 / \"/\"; 「;」 ？ 「＆」と「＆」"
    },
    {
      "indent": 3,
      "text": "For a variable that is a list of values, expansion depends on both the expression type and the presence of an explode modifier. If there is no explode modifier, the expansion consists of a comma-separated concatenation of the defined member string values. If there is an explode modifier and the expression type expands named parameters (\";\", \"?\", or \"&\"), then the list is expanded as if it were an associative array in which each member value is paired with the list's varname. Otherwise, the value will be expanded as if it were a list of separate variable values, each value separated by the expression type's associated separator as defined by the table above.",
      "ja": "値のリストである変数の場合、展開は式のタイプと分解修飾子の存在の両方に依存します。展開修飾子がない場合、展開は、定義されたメンバー文字列値のコンマ区切りの連結で構成されます。展開修飾子があり、式のタイプが名前付きパラメーター（ \";\"、 \"？\"、または \"＆\"）を展開する場合、リストは、各メンバー値がリストのペアと関連付けられている連想配列であるかのように展開されます。 varname。それ以外の場合、値は個別の変数値のリストであるかのように展開されます。各値は、上記の表で定義されている式タイプの関連付けられたセパレーターで区切られます。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{count}            one,two,three\n{count*}           one,two,three\n{/count}           /one,two,three\n{/count*}          /one/two/three\n{;count}           ;count=one,two,three\n{;count*}          ;count=one;count=two;count=three\n{?count}           ?count=one,two,three\n{?count*}          ?count=one&count=two&count=three\n{&count*}          &count=one&count=two&count=three",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.2. Simple String Expansion: {var}",
      "section_title": true,
      "ja": "3.2.2. 単純な文字列展開：{var}"
    },
    {
      "indent": 3,
      "text": "Simple string expansion is the default expression type when no operator is given.",
      "ja": "演算子が指定されていない場合、単純な文字列展開がデフォルトの式タイプです。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set. If more than one variable has a defined value, append a comma (\",\") to the result string as a separator between variable expansions.",
      "ja": "変数リストに定義されている変数ごとに、セクション3.2.1で定義されているように、変数の拡張を実行します。許可されている文字は、予約されていないセットの文字です。複数の変数に値が定義されている場合は、変数展開間の区切り文字としてコンマ（ \"、\"）を結果の文字列に追加します。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{var}              value\n{hello}            Hello%20World%21\n{half}             50%25\nO{empty}X          OX\nO{undef}X          OX\n{x,y}              1024,768\n{x,hello,y}        1024,Hello%20World%21,768\n?{x,empty}         ?1024,\n?{x,undef}         ?1024\n?{undef,y}         ?768\n{var:3}            val\n{var:30}           value\n{list}             red,green,blue\n{list*}            red,green,blue\n{keys}             semi,%3B,dot,.,comma,%2C\n{keys*}            semi=%3B,dot=.,comma=%2C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.3. Reserved Expansion: {+var}",
      "section_title": true,
      "ja": "3.2.3. 予約済み拡張：{+ var}"
    },
    {
      "indent": 3,
      "text": "Reserved expansion, as indicated by the plus (\"+\") operator for Level 2 and above templates, is identical to simple string expansion except that the substituted values may also contain pct-encoded triplets and characters in the reserved set.",
      "ja": "レベル2以上のテンプレートのプラス（ \"+\"）演算子で示される予約済み拡張は、置換された値に予約済みセットのpctエンコードのトリプレットと文字が含まれる場合があることを除いて、単純な文字列拡張と同じです。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the set (unreserved / reserved / pct-encoded). If more than one variable has a defined value, append a comma (\",\") to the result string as a separator between variable expansions.",
      "ja": "変数リストの各定義済み変数について、セクション3.2.1で定義されているように、変数拡張を実行します。許可される文字は、セット内の文字です（未予約/予約済み/ pctエンコード）。複数の変数に値が定義されている場合は、変数展開間の区切り文字としてコンマ（ \"、\"）を結果の文字列に追加します。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{+var}                value\n{+hello}              Hello%20World!\n{+half}               50%25",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "{base}index           http%3A%2F%2Fexample.com%2Fhome%2Findex\n{+base}index          http://example.com/home/index\nO{+empty}X            OX\nO{+undef}X            OX",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "{+path}/here          /foo/bar/here\nhere?ref={+path}      here?ref=/foo/bar\nup{+path}{var}/here   up/foo/barvalue/here\n{+x,hello,y}          1024,Hello%20World!,768\n{+path,x}/here        /foo/bar,1024/here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "{+path:6}/here /foo/b/here {+list} red,green,blue {+list*} red,green,blue {+keys} semi,;,dot,.,comma,, {+keys*} semi=;,dot=.,comma=,",
      "ja": "{+ path：6} / here / foo / b / here {+ list} red、green、blue {+ list *} red、green、blue {+ keys} semi、;、dot、。、comma ,, {+ keys *} semi = ;, dot =。、comma =、"
    },
    {
      "indent": 0,
      "text": "3.2.4. Fragment Expansion: {#var}",
      "section_title": true,
      "ja": "3.2.4. フラグメント拡張：{#var}"
    },
    {
      "indent": 3,
      "text": "Fragment expansion, as indicated by the crosshatch (\"#\") operator for Level 2 and above templates, is identical to reserved expansion except that a crosshatch character (fragment delimiter) is appended first to the result string if any of the variables are defined.",
      "ja": "レベル2以上のテンプレートのクロスハッチ（「＃」）演算子で示されるフラグメント展開は、いずれかの変数が定義されている場合、結果の文字列の最初にクロスハッチ文字（フラグメント区切り文字）が追加されることを除いて、予約済み展開と同じです。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{#var} #value {#hello} #Hello%20World! {#half} #50%25 foo{#empty} foo# foo{#undef} foo {#x,hello,y} #1024,Hello%20World!,768 {#path,x}/here #/foo/bar,1024/here {#path:6}/here #/foo/b/here {#list} #red,green,blue {#list*} #red,green,blue {#keys} #semi,;,dot,.,comma,, {#keys*} #semi=;,dot=.,comma=,",
      "ja": "{#var} #value {#hello}＃Hello％20World！ {#half}＃50％25 foo {#empty} foo＃foo {#undef} foo {＃x、hello、y}＃1024、Hello％20World！、768 {＃path、x} / here＃/ foo / bar、1024 / here {#path：6} / here＃/ foo / b / here {#list}＃red、green、blue {＃list *}＃red、green、blue {#keys} #semi、;、ドット、。、コンマ,, {＃keys *} #semi = ;, dot =。、comma =、"
    },
    {
      "indent": 0,
      "text": "3.2.5. Label Expansion with Dot-Prefix: {.var}",
      "section_title": true,
      "ja": "3.2.5. ドットプレフィックス付きのラベル拡張：{.var}"
    },
    {
      "indent": 3,
      "text": "Label expansion, as indicated by the dot (\".\") operator for Level 3 and above templates, is useful for describing URI spaces with varying domain names or path selectors (e.g., filename extensions).",
      "ja": "レベル3以上のテンプレートのドット（ \"。\"）演算子で示されるラベル展開は、さまざまなドメイン名またはパスセレクター（ファイル名拡張子など）を使用してURIスペースを記述する場合に役立ちます。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, append \".\" to the result string and then perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "変数リストで定義された変数ごとに、「。」を追加します。セクション3.2.1で定義されているように、結果の文字列に変数を展開し、許可された文字を予約されていないセットの文字として、変数の展開を実行します。"
    },
    {
      "indent": 3,
      "text": "Since \".\" is in the unreserved set, a value that contains a \".\" has the effect of adding multiple labels.",
      "ja": "「。」以来予約されていないセット、「。」を含む値複数のラベルを追加する効果があります。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{.who}             .fred\n{.who,who}         .fred.fred\n{.half,who}        .50%25.fred\nwww{.dom*}         www.example.com\nX{.var}            X.value\nX{.empty}          X.\nX{.undef}          X\nX{.var:3}          X.val\nX{.list}           X.red,green,blue\nX{.list*}          X.red.green.blue\nX{.keys}           X.semi,%3B,dot,.,comma,%2C\nX{.keys*}          X.semi=%3B.dot=..comma=%2C\nX{.empty_keys}     X\nX{.empty_keys*}    X",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.6. Path Segment Expansion: {/var}",
      "section_title": true,
      "ja": "3.2.6. パスセグメント拡張：{/ var}"
    },
    {
      "indent": 3,
      "text": "Path segment expansion, as indicated by the slash (\"/\") operator in Level 3 and above templates, is useful for describing URI path hierarchies.",
      "ja": "レベル3以上のテンプレートでスラッシュ（ \"/\"）演算子によって示されるパスセグメント展開は、URIパス階層を記述するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, append \"/\" to the result string and then perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "変数リストで定義されている変数ごとに、結果文字列に「/」を追加し、セクション3.2.1で定義されているように、変数の展開を実行します。許可されている文字は、予約されていないセットの文字です。"
    },
    {
      "indent": 3,
      "text": "Note that the expansion process for path segment expansion is identical to that of label expansion aside from the substitution of \"/\" instead of \".\". However, unlike \".\", a \"/\" is a reserved character and will be pct-encoded if found in a value.",
      "ja": "パスセグメント展開の展開プロセスは、「。」の代わりに「/」を使用することを除けば、ラベル展開の展開プロセスと同じです。ただし、「。」とは異なり、「/」は予約文字であり、値で見つかった場合はpctエンコードされます。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{/who}             /fred\n{/who,who}         /fred/fred\n{/half,who}        /50%25/fred\n{/who,dub}         /fred/me%2Ftoo\n{/var}             /value\n{/var,empty}       /value/\n{/var,undef}       /value\n{/var,x}/here      /value/1024/here\n{/var:1,var}       /v/value\n{/list}            /red,green,blue\n{/list*}           /red/green/blue\n{/list*,path:4}    /red/green/blue/%2Ffoo\n{/keys}            /semi,%3B,dot,.,comma,%2C\n{/keys*}           /semi=%3B/dot=./comma=%2C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.7. Path-Style Parameter Expansion: {;var}",
      "section_title": true,
      "ja": "3.2.7. パススタイルのパラメーター展開：{; var}"
    },
    {
      "indent": 3,
      "text": "Path-style parameter expansion, as indicated by the semicolon (\";\") operator in Level 3 and above templates, is useful for describing URI path parameters, such as \"path;property\" or \"path;name=value\".",
      "ja": "レベル3以上のテンプレートのセミコロン（ \";\"）演算子で示されるパススタイルのパラメーター展開は、 \"path; property\"や \"path; name = value\"などのURIパスパラメーターを記述するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リストの各定義済み変数について："
    },
    {
      "indent": 3,
      "text": "o append \";\" to the result string;",
      "ja": "o 「;」を追加結果の文字列に;"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, then:",
      "ja": "o 変数に単純な文字列値がある場合、または分解修飾子が指定されていない場合は、次のようになります。"
    },
    {
      "indent": 6,
      "text": "* append the variable name (encoded as if it were a literal string) to the result string;",
      "ja": "* 変数名（リテラル文字列であるかのようにエンコード）を結果文字列に追加します。"
    },
    {
      "indent": 6,
      "text": "* if the variable's value is not empty, append \"=\" to the result string;",
      "ja": "* 変数の値が空でない場合は、結果文字列に「=」を追加します。"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "o セクション3.2.1で定義されている変数の展開を実行します。許可されている文字は予約されていないセットの文字です。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{;who}             ;who=fred\n{;half}            ;half=50%25\n{;empty}           ;empty\n{;v,empty,who}     ;v=6;empty;who=fred\n{;v,bar,who}       ;v=6;who=fred\n{;x,y}             ;x=1024;y=768\n{;x,y,empty}       ;x=1024;y=768;empty\n{;x,y,undef}       ;x=1024;y=768\n{;hello:5}         ;hello=Hello\n{;list}            ;list=red,green,blue\n{;list*}           ;list=red;list=green;list=blue\n{;keys}            ;keys=semi,%3B,dot,.,comma,%2C\n{;keys*}           ;semi=%3B;dot=.;comma=%2C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.8. Form-Style Query Expansion: {?var}",
      "section_title": true,
      "ja": "3.2.8. フォームスタイルのクエリ拡張：{？var}"
    },
    {
      "indent": 3,
      "text": "Form-style query expansion, as indicated by the question-mark (\"?\") operator in Level 3 and above templates, is useful for describing an entire optional query component.",
      "ja": "レベル3以上のテンプレートで疑問符（ \"？\"）演算子によって示されるフォームスタイルのクエリ拡張は、オプションのクエリコンポーネント全体を記述するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リストの各定義済み変数について："
    },
    {
      "indent": 3,
      "text": "o append \"?\" to the result string if this is the first defined value or append \"&\" thereafter;",
      "ja": "o 「？」を追加これが最初に定義された値である場合は結果の文字列に追加するか、その後に「＆」を追加します。"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, append the variable name (encoded as if it were a literal string) and an equals character (\"=\") to the result string; and,",
      "ja": "o 変数に単純な文字列値があるか、explode修飾子が指定されていない場合は、変数名（リテラル文字列であるかのようにエンコード）と等号（ \"=\"）を結果の文字列に追加します。そして、"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "o セクション3.2.1で定義されている変数の展開を実行します。許可されている文字は予約されていないセットの文字です。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{?who}             ?who=fred\n{?half}            ?half=50%25\n{?x,y}             ?x=1024&y=768\n{?x,y,empty}       ?x=1024&y=768&empty=\n{?x,y,undef}       ?x=1024&y=768\n{?var:3}           ?var=val\n{?list}            ?list=red,green,blue\n{?list*}           ?list=red&list=green&list=blue\n{?keys}            ?keys=semi,%3B,dot,.,comma,%2C\n{?keys*}           ?semi=%3B&dot=.&comma=%2C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.9. Form-Style Query Continuation: {&var}",
      "section_title": true,
      "ja": "3.2.9. フォームスタイルクエリの継続：{＆var}"
    },
    {
      "indent": 3,
      "text": "Form-style query continuation, as indicated by the ampersand (\"&\") operator in Level 3 and above templates, is useful for describing optional &name=value pairs in a template that already contains a literal query component with fixed parameters.",
      "ja": "レベル3以上のテンプレートのアンパサンド（ \"＆\"）演算子で示されるフォームスタイルのクエリの継続は、固定パラメーターを持つリテラルクエリコンポーネントが既に含まれているテンプレートでオプションの＆name = valueペアを記述するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リストの各定義済み変数について："
    },
    {
      "indent": 3,
      "text": "o append \"&\" to the result string;",
      "ja": "o 結果の文字列に「＆」を追加します。"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, append the variable name (encoded as if it were a literal string) and an equals character (\"=\") to the result string; and,",
      "ja": "o 変数に単純な文字列値があるか、explode修飾子が指定されていない場合は、変数名（リテラル文字列であるかのようにエンコード）と等号（ \"=\"）を結果の文字列に追加します。そして、"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "o セクション3.2.1で定義されている変数の展開を実行します。許可されている文字は予約されていないセットの文字です。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "テンプレート拡張の例"
    },
    {
      "indent": 7,
      "text": "{&who}             &who=fred\n{&half}            &half=50%25\n?fixed=yes{&x}     ?fixed=yes&x=1024\n{&x,y,empty}       &x=1024&y=768&empty=\n{&x,y,undef}       &x=1024&y=768",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "{&var:3}           &var=val\n{&list}            &list=red,green,blue\n{&list*}           &list=red&list=green&list=blue\n{&keys}            &keys=semi,%3B,dot,.,comma,%2C\n{&keys*}           &semi=%3B&dot=.&comma=%2C",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A URI Template does not contain active or executable content. However, it might be possible to craft unanticipated URIs if an attacker is given control over the template or over the variable values within an expression that allows reserved characters in the expansion. In either case, the security considerations are largely determined by who provides the template, who provides the values to use for variables within the template, in what execution context the expansion occurs (client or server), and where the resulting URIs are used.",
      "ja": "URIテンプレートにはアクティブなコンテンツや実行可能なコンテンツは含まれません。ただし、テンプレートまたは拡張内の予約文字を許可する式内の変数値に対する制御が攻撃者に与えられた場合、予期しないURIを作成できる可能性があります。どちらの場合も、セキュリティに関する考慮事項は、だれがテンプレートを提供するか、だれがテンプレート内の変数に使用する値を提供するか、拡張が発生する実行コンテキスト（クライアントまたはサーバー）、および結果のURIがどこで使用されるかによって主に決まります。"
    },
    {
      "indent": 3,
      "text": "This specification does not limit where URI Templates might be used. Current implementations exist within server-side development frameworks and within client-side javascript for computed links or forms.",
      "ja": "この仕様は、URIテンプレートが使用される場所を制限しません。現在の実装は、サーバー側の開発フレームワーク内と、計算されたリンクまたはフォームのクライアント側のJavaScript内に存在します。"
    },
    {
      "indent": 3,
      "text": "Within frameworks, templates usually act as guides for where data might occur within later (request-time) URIs in client requests. Hence, the security concerns are not in the templates themselves, but rather in how the server extracts and processes the user-provided data within a normal Web request.",
      "ja": "フレームワーク内では、テンプレートは通常、クライアントリクエストの後の（リクエスト時）URI内でデータが発生する場所のガイドとして機能します。したがって、セキュリティの問題はテンプレート自体ではなく、サーバーが通常のWebリクエスト内でユーザー提供のデータを抽出して処理する方法にあります。"
    },
    {
      "indent": 3,
      "text": "Within client-side implementations, a URI Template has many of the same properties as HTML forms, except limited to URI characters and possibly included in HTTP header field values instead of just message body content. Care ought to be taken to ensure that potentially dangerous URI reference strings, such as those beginning with \"javascript:\", do not appear in the expansion unless both the template and the values are provided by a trusted source.",
      "ja": "クライアント側の実装内で、URIテンプレートはHTMLフォームと同じプロパティの多くを持っていますが、URI文字に限定され、メッセージ本文のコンテンツだけでなくHTTPヘッダーフィールドの値に含まれる場合もあります。テンプレートと値の両方が信頼できるソースから提供されない限り、 \"javascript：\"で始まるような潜在的に危険なURI参照文字列が展開に表示されないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Other security considerations are the same as those for URIs, as described in Section 7 of [RFC3986].",
      "ja": "[RFC3986]のセクション7で説明されているように、その他のセキュリティの考慮事項はURIの場合と同じです。"
    },
    {
      "indent": 0,
      "text": "5. Acknowledgments",
      "section_title": true,
      "ja": "5. 謝辞"
    },
    {
      "indent": 3,
      "text": "The following people made contributions to this specification: Mike Burrows, Michaeljohn Clement, DeWitt Clinton, John Cowan, Stephen Farrell, Robbie Gates, Vijay K. Gurbani, Peter Johanson, Murray S. Kucherawy, James H. Manger, Tom Petch, Marc Portier, Pete Resnick, James Snell, and Jiankang Yao.",
      "ja": "次の人々がこの仕様に貢献しました：Mike Burrows、Michaeljohn Clement、DeWitt Clinton、John Cowan、Stephen Farrell、Robbie Gates、Vijay K. Gurbani、Peter Johanson、Murray S. Kucherawy、James H. Manger、Tom Petch、Marc Portier 、Pete Resnick、James Snell、Jiankang Yao。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ASCII] American National Standards Institute, \"Coded Character Set - 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "[ASCII] American National Standards Institute、「Coded Character Set-7-bit American Standard Code for Information Interchange」、ANSI X3.4、1986。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3987] Duerst, M. and M. Suignard, \"Internationalized Resource Identifiers (IRIs)\", RFC 3987, January 2005.",
      "ja": "[RFC3987] Duerst、M。およびM. Suignard、「Internationalized Resource Identifiers（IRIs）」、RFC 3987、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234] Crocker、D。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6365] Hoffman, P. and J. Klensin, \"Terminology Used in Internationalization in the IETF\", BCP 166, RFC 6365, September 2011.",
      "ja": "[RFC6365] Hoffman、P。およびJ. Klensin、「IETFの国際化で使用される用語」、BCP 166、RFC 6365、2011年9月。"
    },
    {
      "indent": 3,
      "text": "[UNIV6] The Unicode Consortium, \"The Unicode Standard, Version 6.0.0\", (Mountain View, CA: The Unicode Consortium, 2011. ISBN 978-1-936213-01-6), <http://www.unicode.org/versions/Unicode6.0.0/>.",
      "ja": "[UNIV6] Unicodeコンソーシアム、「The Unicode Standard、Version 6.0.0 \"、（Mountain View、CA：The Unicode Consortium、2011. ISBN 978-1-936213-01-6）、<http：//www.unicode .org / versions / Unicode6.0.0 />。"
    },
    {
      "indent": 3,
      "text": "[UTR15] Davis, M. and M. Duerst, \"Unicode Normalization Forms\", Unicode Standard Annex # 15, April 2003, <http://www.unicode.org/unicode/reports/tr15/ tr15-23.html>.",
      "ja": "[UTR15] Davis、M.およびM. Duerst、「Unicode Normalization Forms」、Unicode Standard Annex＃15、2003年4月、<http://www.unicode.org/unicode/reports/tr15/ tr15-23.html> 。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[OpenSearch] Clinton, D., \"OpenSearch 1.1\", Draft 5, December 2011, <http://www.opensearch.org/Specifications/OpenSearch>.",
      "ja": "[OpenSearch]クリントン、D。、「OpenSearch 1.1」、ドラフト5、2011年12月、<http://www.opensearch.org/Specifications/OpenSearch>。"
    },
    {
      "indent": 3,
      "text": "[UPU-S42] Universal Postal Union, \"International Postal Address Components and Templates\", UPU S42-1, November 2002, <http://www.upu.int/en/activities/addressing/ standards.html>.",
      "ja": "[UPU-S42] Universal Postal Union、「International Postal Address Components and Templates」、UPU S42-1、2002年11月、<http://www.upu.int/en/activities/addressing/standards.html>。"
    },
    {
      "indent": 3,
      "text": "[WADL] Hadley, M., \"Web Application Description Language\", World Wide Web Consortium Member Submission SUBM-wadl-20090831, August 2009, <http://www.w3.org/Submission/2009/ SUBM-wadl-20090831/>.",
      "ja": "[WADL] Hadley、M。、「Web Application Description Language」、World Wide Web Consortium Member Submission SUBM-wadl-20090831、2009年8月、<http://www.w3.org/Submission/2009/ SUBM-wadl-20090831 />。"
    },
    {
      "indent": 3,
      "text": "[WSDL] Weerawarana, S., Moreau, J., Ryman, A., and R. Chinnici, \"Web Services Description Language (WSDL) Version 2.0 Part 1: Core Language\", World Wide Web Consortium Recommendation REC-wsdl20-20070626, June 2007, <http://www.w3.org/TR/2007/ REC-wsdl20-20070626>.",
      "ja": "[WSDL] Weerawarana、S.、Moreau、J.、Ryman、A。、およびR. Chinnici、「Web Services Description Language（WSDL）Version 2.0 Part 1：Core Language」、World Wide Web Consortium Recommendation REC-wsdl20-20070626 、2007年6月、<http://www.w3.org/TR/2007/ REC-wsdl20-20070626>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Implementation Hints",
      "section_title": true,
      "ja": "付録A.実装のヒント"
    },
    {
      "indent": 3,
      "text": "The normative sections on expansion describe each operator with a separate expansion process for the sake of descriptive clarity. In actual implementations, we expect the expressions to be processed left-to-right using a common algorithm that has only minor variations in process per operator. This non-normative appendix describes one such algorithm.",
      "ja": "展開に関する規範的なセクションでは、説明を明確にするために、各演算子を個別の展開プロセスで説明しています。実際の実装では、式は左から右に、演算子ごとのプロセスにわずかな変動しかない共通のアルゴリズムを使用して処理されることを期待しています。この非規範的な付録では、そのようなアルゴリズムの1つについて説明します。"
    },
    {
      "indent": 3,
      "text": "Initialize an empty result string and its non-error state.",
      "ja": "空の結果文字列とその非エラー状態を初期化します。"
    },
    {
      "indent": 3,
      "text": "Scan the template and copy literals to the result string (as in Section 3.1) until an expression is indicated by a \"{\", an error is indicated by the presence of a non-literals character other than \"{\", or the template ends. When it ends, return the result string and its current error or non-error state.",
      "ja": "テンプレートをスキャンして、式が「{」で示されるまで、またはリテラルを結果文字列にコピーします（セクション3.1と同様）。エラーは、「{」以外の非リテラル文字の存在で示されるか、テンプレートが終了します。 。終了したら、結果の文字列とその現在のエラーまたは非エラー状態を返します。"
    },
    {
      "indent": 3,
      "text": "o If an expression is found, scan the template to the next \"}\" and extract the characters in between the braces.",
      "ja": "o 式が見つかった場合は、テンプレートを次の \"}\"までスキャンし、中括弧内の文字を抽出します。"
    },
    {
      "indent": 3,
      "text": "o If the template ends before a \"}\", then append the \"{\" and extracted characters to the result string and return with an error status indicating the expression is malformed.",
      "ja": "o テンプレートが「}」の前で終了する場合、「{」と抽出された文字を結果の文字列に追加し、式が不正であることを示すエラーステータスを返します。"
    },
    {
      "indent": 3,
      "text": "Examine the first character of the extracted expression for an operator.",
      "ja": "抽出された式の最初の文字を調べて、演算子を探します。"
    },
    {
      "indent": 3,
      "text": "o If the expression ended (i.e., is \"{}\"), an operator is found that is unknown or unimplemented, or the character is not in the varchar set (Section 2.3), then append \"{\", the extracted expression, and \"}\" to the result string, remember that the result is in an error state, and then go back to scan the remainder of the template.",
      "ja": "o 式が終了した場合（つまり、「{}」）、不明または実装されていない演算子が見つかった場合、または文字がvarcharセットに含まれていない場合（セクション2.3）、「{」、抽出された式、および「 } \"を結果文字列に追加し、結果がエラー状態であることを思い出してから、テンプレートの残りの部分をスキャンして戻ってください。"
    },
    {
      "indent": 3,
      "text": "o If a known and implemented operator is found, store the operator and skip to the next character to begin the varspec-list.",
      "ja": "o 既知の実装済みの演算子が見つかった場合は、演算子を保存し、次の文字にスキップしてvarspec-listを開始します。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, store the operator as NUL (simple string expansion).",
      "ja": "o それ以外の場合は、演算子をNUL（単純な文字列展開）として保存します。"
    },
    {
      "indent": 0,
      "text": " Use the following value table to determine the processing behavior by expression type operator. The entry for \"first\" is the string to append to the result first if any of the expression's variables are defined. The entry for \"sep\" is the separator to append to the result before any second (or subsequent) defined variable expansion. The entry for \"named\" is a boolean for whether or not the expansion includes the variable or key name when no explode modifier is given. The entry for \"ifemp\" is a string to append to the name if its corresponding value is empty. The entry for \"allow\" indicates what characters to allow unencoded within the value expansion: (U) means any character not in the unreserved set will be encoded; (U+R) means any character not in the union of (unreserved / reserved / pct-encoding) will be encoded; and, for both cases, each disallowed character is first encoded as its sequence of octets in UTF-8 and then each such octet is encoded as a pct-encoded triplet.",
      "ja": "次の値の表を使用して、式タイプ演算子による処理動作を決定します。 「first」のエントリは、式の変数のいずれかが定義されている場合、最初に結果に追加する文字列です。 「sep」のエントリは、2番目（またはそれ以降）の定義済み変数展開の前に結果に追加するセパレーターです。 「named」のエントリは、展開修飾子が指定されていない場合に、展開に変数またはキー名が含まれるかどうかのブール値です。 「ifemp」のエントリは、対応する値が空の場合に名前に追加する文字列です。 \"allow\"のエントリは、値の拡張内でエンコードされていない文字を許可することを示します。（U）は、予約されていないセットにない文字はエンコードされます。 （U + R）は、（unreserved / reserved / pct-encoding）の和集合にない任意の文字がエンコードされることを意味します。どちらの場合も、許可されていない各文字はまずUTF-8のオクテットのシーケンスとしてエンコードされ、次にそのような各オクテットはpctエンコードされたトリプレットとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": ".------------------------------------------------------------------.\n|          NUL     +      .       /       ;      ?      &      #   |\n|------------------------------------------------------------------|\n| first |  \"\"     \"\"     \".\"     \"/\"     \";\"    \"?\"    \"&\"    \"#\"  |\n| sep   |  \",\"    \",\"    \".\"     \"/\"     \";\"    \"&\"    \"&\"    \",\"  |\n| named | false  false  false   false   true   true   true   false |\n| ifemp |  \"\"     \"\"     \"\"      \"\"      \"\"     \"=\"    \"=\"    \"\"   |\n| allow |   U     U+R     U       U       U      U      U     U+R  |\n`------------------------------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the above table in mind, process the variable-list as follows:",
      "ja": "上記の表を念頭に置いて、次のように変数リストを処理します。"
    },
    {
      "indent": 3,
      "text": "For each varspec, extract a variable name and optional modifier from the expression by scanning the variable-list until a character not in the varname set is found or the end of the expression is reached.",
      "ja": "varspecごとに、varnameセットにない文字が見つかるか、式の終わりに達するまで変数リストをスキャンして、式から変数名とオプションの修飾子を抽出します。"
    },
    {
      "indent": 3,
      "text": "o If it is the end of the expression and the varname is empty, go back to scan the remainder of the template.",
      "ja": "o 式の終わりでvarnameが空の場合は、戻ってテンプレートの残りの部分をスキャンします。"
    },
    {
      "indent": 3,
      "text": "o If it is not the end of the expression and the last character found indicates a modifier (\"*\" or \":\"), remember that modifier. If it is an explode (\"*\"), scan the next character. If it is a prefix (\":\"), continue scanning the next one to four characters for the max-length represented as a decimal integer and then, if it is still not the end of the expression, scan the next character.",
      "ja": "o 式の終わりではなく、最後に見つかった文字が修飾子（ \"*\"または \"：\"）を示している場合は、その修飾子を覚えておいてください。分解（ \"*\"）の場合は、次の文字をスキャンします。プレフィックス（ \"：\"）の場合は、10進整数として表される最大長の次の1〜4文字のスキャンを続行し、それがまだ式の終わりでない場合は、次の文字をスキャンします。"
    },
    {
      "indent": 3,
      "text": "o If it is not the end of the expression and the last character found is not a comma (\",\"), append \"{\", the stored operator (if any), the scanned varname and modifier, the remaining expression, and \"}\" to the result string, remember that the result is in an error state, and then go back to scan the remainder of the template.",
      "ja": "o 式の最後ではなく、最後に見つかった文字がカンマ（ \"、\"）でない場合は、 \"{\"、ストアドオペレータ（存在する場合）、スキャンされた変数名と修飾子、残りの式、および \"}を追加します\"結果文字列に、結果がエラー状態であることを思い出してから、テンプレートの残りの部分をスキャンして戻ってください。"
    },
    {
      "indent": 3,
      "text": "Lookup the value for the scanned variable name, and then",
      "ja": "スキャンされた変数名の値を検索し、次に"
    },
    {
      "indent": 3,
      "text": "o If the varname is unknown or corresponds to a variable with an undefined value (Section 2.3), then skip to the next varspec.",
      "ja": "o varnameが不明であるか、値が未定義の変数に対応している場合（セクション2.3）、次のvarspecにスキップします。"
    },
    {
      "indent": 3,
      "text": "o If this is the first defined variable for this expression, append the first string for this expression type to the result string and remember that it has been done. Otherwise, append the sep string to the result string.",
      "ja": "o これがこの式の最初に定義された変数である場合は、この式タイプの最初の文字列を結果の文字列に追加し、完了したことを思い出してください。それ以外の場合は、sep文字列を結果の文字列に追加します。"
    },
    {
      "indent": 3,
      "text": "o If this variable's value is a string, then",
      "ja": "o この変数の値が文字列の場合、"
    },
    {
      "indent": 6,
      "text": "* if named is true, append the varname to the result string using the same encoding process as for literals, and",
      "ja": "* namedがtrueの場合、リテラルと同じエンコーディングプロセスを使用して、varnameを結果の文字列に追加します。"
    },
    {
      "indent": 9,
      "text": "+ if the value is empty, append the ifemp string to the result string and skip to the next varspec;",
      "ja": "+ 値が空の場合は、ifemp文字列を結果の文字列に追加し、次のvarspecにスキップします。"
    },
    {
      "indent": 9,
      "text": "+ otherwise, append \"=\" to the result string.",
      "ja": "+ それ以外の場合は、結果文字列に「=」を追加します。"
    },
    {
      "indent": 6,
      "text": "* if a prefix modifier is present and the prefix length is less than the value string length in number of Unicode characters, append that number of characters from the beginning of the value string to the result string, after pct-encoding any characters that are not in the allow set, while taking care not to split multi-octet or pct-encoded triplet characters that represent a single Unicode code point;",
      "ja": "* 接頭辞修飾子があり、接頭辞の長さがUnicode文字数で値文字列の長さよりも短い場合は、その文字数を値文字列の先頭から結果文字列に追加します。単一のUnicodeコードポイントを表すマルチオクテットまたはpctエンコードのトリプレット文字を分割しないように注意しながら、許可セット。"
    },
    {
      "indent": 6,
      "text": "* otherwise, append the value to the result string after pct-encoding any characters that are not in the allow set.",
      "ja": "* それ以外の場合は、許可セットに含まれていない文字をpctエンコードした後、結果の文字列に値を追加します。"
    },
    {
      "indent": 3,
      "text": "o else if no explode modifier is given, then",
      "ja": "o それ以外の場合、分解修飾子が指定されていなければ、"
    },
    {
      "indent": 6,
      "text": "* if named is true, append the varname to the result string using the same encoding process as for literals, and",
      "ja": "* namedがtrueの場合、リテラルと同じエンコーディングプロセスを使用して、varnameを結果の文字列に追加します。"
    },
    {
      "indent": 9,
      "text": "+ if the value is empty, append the ifemp string to the result string and skip to the next varspec;",
      "ja": "+ 値が空の場合は、ifemp文字列を結果の文字列に追加し、次のvarspecにスキップします。"
    },
    {
      "indent": 9,
      "text": "+ otherwise, append \"=\" to the result string; and",
      "ja": "+ それ以外の場合は、結果文字列に「=」を追加します。そして"
    },
    {
      "indent": 6,
      "text": "* if this variable's value is a list, append each defined list member to the result string, after pct-encoding any characters that are not in the allow set, with a comma (\",\") appended to the result between each defined list member;",
      "ja": "* この変数の値がリストの場合、定義済みの各リストメンバーを結果文字列に追加します。許可セットにない文字をpctエンコードした後、各定義済みリストメンバー間の結果にコンマ（ \"、\"）を追加します。"
    },
    {
      "indent": 6,
      "text": "* if this variable's value is an associative array or any other form of paired (name, value) structure, append each pair with a defined value to the result string as \"name,value\", after pct-encoding any characters that are not in the allow set, with a comma (\",\") appended to the result between each defined pair.",
      "ja": "* この変数の値が連想配列またはその他の形式のペア（名前、値）構造である場合、定義された値を持つ各ペアを \"name、value\"として結果文字列に追加します。定義された各ペアの間の結果にコンマ（ \"、\"）を追加して、セットを許可します。"
    },
    {
      "indent": 3,
      "text": "o else if an explode modifier is given, then",
      "ja": "o それ以外の場合、分解修飾子が指定されていると、"
    },
    {
      "indent": 6,
      "text": "* if named is true, then for each defined list member or array (name, value) pair with a defined value, do:",
      "ja": "* namedがtrueの場合、定義済みの値を持つ定義済みリストメンバーまたは配列（名前、値）のペアごとに、次のようにします。"
    },
    {
      "indent": 9,
      "text": "+ if this is not the first defined member/value, append the sep string to the result string;",
      "ja": "+ これが最初に定義されたメンバー/値でない場合は、sep文字列を結果の文字列に追加します。"
    },
    {
      "indent": 9,
      "text": "+ if this is a list, append the varname to the result string using the same encoding process as for literals;",
      "ja": "+ これがリストの場合、リテラルと同じエンコードプロセスを使用して、varnameを結果の文字列に追加します。"
    },
    {
      "indent": 9,
      "text": "+ if this is a pair, append the name to the result string using the same encoding process as for literals;",
      "ja": "+ これがペアの場合、リテラルと同じエンコードプロセスを使用して、結果の文字列に名前を追加します。"
    },
    {
      "indent": 9,
      "text": "+ if the member/value is empty, append the ifemp string to the result string; otherwise, append \"=\" and the member/value to the result string, after pct-encoding any member/value characters that are not in the allow set.",
      "ja": "+ メンバー/値が空の場合、結果文字列にifemp文字列を追加します。それ以外の場合は、許可セットに含まれていないメンバー/値の文字をpct-encodingした後、結果文字列に「=」とメンバー/値を追加します。"
    },
    {
      "indent": 6,
      "text": "* else if named is false, then",
      "ja": "* それ以外の場合、namedがfalseの場合"
    },
    {
      "indent": 9,
      "text": "+ if this is a list, append each defined list member to the result string, after pct-encoding any characters that are not in the allow set, with the sep string appended to the result between each defined list member.",
      "ja": "+ これがリストの場合、許可セットにない文字をpctエンコードした後、定義された各リストメンバーを結果文字列に追加し、定義された各リストメンバー間の結果にsep文字列を追加します。"
    },
    {
      "indent": 9,
      "text": "+ if this is an array of (name, value) pairs, append each pair with a defined value to the result string as \"name=value\", after pct-encoding any characters that are not in the allow set, with the sep string appended to the result between each defined pair.",
      "ja": "+ これが（name、value）ペアの配列である場合、定義された値を持つ各ペアを「name = value」として結果文字列に追加します。許可セットにない文字をpctエンコードした後、sep文字列を追加します。定義された各ペア間の結果に。"
    },
    {
      "indent": 3,
      "text": "When the variable-list for this expression is exhausted, go back to scan the remainder of the template.",
      "ja": "この式の変数リストがなくなったら、戻ってテンプレートの残りの部分をスキャンします。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Joe Gregorio Google",
      "ja": "じょえ Ｇれごりお ごおｇぇ"
    },
    {
      "indent": 3,
      "text": "EMail: joe@bitworking.org\nURI:   http://bitworking.org/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding Adobe Systems Incorporated",
      "ja": "ロイT.フィールディングアドビシステムズ社"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com\nURI:   http://roy.gbiv.com/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Marc Hadley The MITRE Corporation",
      "ja": "マークハドリーザマイター株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: mhadley@mitre.org\nURI:   http://mitre.org/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mark Nottingham Rackspace",
      "ja": "マークノッティンガムラックスペース"
    },
    {
      "indent": 3,
      "text": "EMail: mnot@mnot.net\nURI:   http://www.mnot.net/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Orchard Salesforce.com",
      "ja": "David Orchard Salesforce.com"
    },
    {
      "indent": 3,
      "text": "EMail: orchard@pacificspirit.com\nURI:   http://www.pacificspirit.com/",
      "raw": true,
      "ja": ""
    }
  ]
}