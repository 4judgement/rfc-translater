{
  "title": {
    "text": "RFC 6698 - The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA",
    "ja": "RFC 6698 - 名前付きエンティティのDNSベースの認証（DANE）トランスポート層セキュリティ（TLS）プロトコル：TLSA"
  },
  "number": 6698,
  "created_at": "2020-09-06 12:11:26.148713+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        P. Hoffman\nRequest for Comments: 6698                                VPN Consortium\nCategory: Standards Track                                    J. Schlyter\nISSN: 2070-1721                                                 Kirei AB\n                                                             August 2012",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA",
      "ja": "名前付きエンティティのDNSベースの認証（DANE）トランスポート層セキュリティ（TLS）プロトコル：TLSA"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Encrypted communication on the Internet often uses Transport Layer Security (TLS), which depends on third parties to certify the keys used. This document improves on that situation by enabling the administrators of domain names to specify the keys used in that domain's TLS servers. This requires matching improvements in TLS client software, but no change in TLS server software.",
      "ja": "インターネット上の暗号化された通信では、トランスポート層セキュリティ（TLS）がよく使用されます。TLSは、使用されるキーの認証をサードパーティに依存しています。このドキュメントでは、ドメイン名の管理者がそのドメインのTLSサーバーで使用されるキーを指定できるようにすることで、この状況を改善しています。これには、TLSクライアントソフトウェアの対応する改善が必要ですが、TLSサーバーソフトウェアの変更は必要ありません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6698.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6698で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2012 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Background and Motivation ..................................3\n   1.2. Securing the Association of a Domain Name with a\n        Server's Certificate .......................................4\n   1.3. Method for Securing Certificate Associations ...............5\n   1.4. Terminology ................................................6\n2. The TLSA Resource Record ........................................7\n   2.1. TLSA RDATA Wire Format .....................................7\n        2.1.1. The Certificate Usage Field .........................7\n        2.1.2. The Selector Field ..................................8\n        2.1.3. The Matching Type Field .............................9\n        2.1.4. The Certificate Association Data Field ..............9\n   2.2. TLSA RR Presentation Format ................................9\n   2.3. TLSA RR Examples ..........................................10\n3. Domain Names for TLSA Certificate Associations .................10\n4. Use of TLSA Records in TLS .....................................11\n   4.1. Usable Certificate Associations ...........................11\n5. TLSA and DANE Use Cases and Requirements .......................13\n6. Mandatory-to-Implement Features ................................15\n7. IANA Considerations ............................................15\n   7.1. TLSA RRtype ...............................................15\n   7.2. TLSA Certificate Usages ...................................15\n   7.3. TLSA Selectors ............................................16\n   7.4. TLSA Matching Types .......................................16\n8. Security Considerations ........................................16\n   8.1. Comparing DANE to Public CAs ..............................18\n        8.1.1. Risk of Key Compromise .............................19\n        8.1.2. Impact of Key Compromise ...........................20\n        8.1.3. Detection of Key Compromise ........................20\n        8.1.4. Spoofing Hostnames .................................20\n   8.2. DNS Caching ...............................................21\n   8.3. External DNSSEC Validators ................................21\n9. Acknowledgements ...............................................22\n10. References ....................................................22\n   10.1. Normative References .....................................22\n   10.2. Informative References ...................................23\nAppendix A. Operational Considerations for Deploying TLSA\n            Records ...............................................25\n  A.1. Creating TLSA Records ......................................25\n    A.1.1. Ambiguities and Corner Cases When TLS Clients\n           Build Trust Chains .....................................26\n    A.1.2. Choosing a Selector Type ...............................26\n  A.2. Provisioning TLSA Records in DNS ...........................28\n    A.2.1. Provisioning TLSA Records with Aliases .................28\n  A.3. Securing the Last Hop ......................................30\n  A.4. Handling Certificate Rollover ..............................31",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix B. Pseudocode for Using TLSA .............................32\n  B.1. Helper Functions ...........................................32\n  B.2. Main TLSA Pseudocode .......................................33\nAppendix C. Examples ..............................................35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Background and Motivation",
      "section_title": true,
      "ja": "1.1. 背景と動機"
    },
    {
      "indent": 3,
      "text": "Applications that communicate over the Internet often need to prevent eavesdropping, tampering, or forgery of their communications. The Transport Layer Security (TLS) protocol provides this kind of communications security over the Internet, using channel encryption.",
      "ja": "インターネットを介して通信するアプリケーションは、多くの場合、通信の盗聴、改ざん、または偽造を防止する必要があります。トランスポート層セキュリティ（TLS）プロトコルは、チャネル暗号化を使用して、インターネット上でこの種の通信セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "The security properties of encryption systems depend strongly on the keys that they use. If secret keys are revealed, or if public keys can be replaced by fake keys (that is, a key not corresponding to the entity identified in the certificate), these systems provide little or no security.",
      "ja": "暗号化システムのセキュリティプロパティは、それらが使用するキーに強く依存します。秘密鍵が明らかになった場合、または公開鍵を偽の鍵（つまり、証明書で識別されたエンティティに対応しない鍵）に置き換えることができる場合、これらのシステムはセキュリティをほとんどまたはまったく提供しません。"
    },
    {
      "indent": 3,
      "text": "TLS uses certificates to bind keys and names. A certificate combines a published key with other information such as the name of the service that uses the key, and this combination is digitally signed by another key. Having a key in a certificate is only helpful if one trusts the other key that signed the certificate. If that other key was itself revealed or substituted, then its signature is worthless in proving anything about the first key.",
      "ja": "TLSは証明書を使用してキーと名前をバインドします。証明書は、公開されたキーと、そのキーを使用するサービスの名前などの他の情報を組み合わせたもので、この組み合わせは別のキーによってデジタル署名されています。証明書に鍵があることは、証明書に署名した他の鍵を信頼している場合にのみ役立ちます。その別のキー自体が明らかにされたか、置き換えられた場合、その署名は最初のキーについて何かを証明する意味がありません。"
    },
    {
      "indent": 3,
      "text": "On the Internet, this problem has been solved for years by entities called \"Certification Authorities\" (CAs). CAs protect their secret key vigorously, while supplying their public key to the software vendors who build TLS clients. They then sign certificates, and supply those to TLS servers. TLS client software uses a set of these CA keys as \"trust anchors\" to validate the signatures on certificates that the client receives from TLS servers. Client software typically allows any CA to usefully sign any other certificate.",
      "ja": "インターネットでは、この問題は「認証局（CA）」と呼ばれるエンティティによって長年解決されてきました。 CAは、TLSクライアントを構築するソフトウェアベンダーに公開キーを提供しながら、秘密キーを強力に保護します。次に、証明書に署名し、それらをTLSサーバーに提供します。 TLSクライアントソフトウェアは、これらのCAキーのセットを「トラストアンカー」として使用して、クライアントがTLSサーバーから受信する証明書の署名を検証します。クライアントソフトウェアでは、通常、どのCAも他の証明書に便利に署名できます。"
    },
    {
      "indent": 3,
      "text": "The public CA model upon which TLS has depended is fundamentally vulnerable because it allows any of these CAs to issue a certificate for any domain name. A single trusted CA that betrays its trust, either voluntarily or by providing less-than-vigorous protection for its secrets and capabilities, can undermine the security offered by any certificates employed with TLS. This problem arises because a compromised CA can issue a replacement certificate that contains a fake key. Recent experiences with compromises of CAs or their trusted partners have led to very serious security problems, such as the governments of multiple countries attempting to wiretap and/or subvert major TLS-protected web sites trusted by millions of users.",
      "ja": "TLSが依存しているパブリックCAモデルは、これらのCAのいずれかが任意のドメイン名の証明書を発行できるため、根本的に脆弱です。自発的に、またはその秘密と機能に対してあまり強力ではない保護を提供することによって信頼を裏切る単一の信頼できるCAは、TLSで使用される証明書によって提供されるセキュリティを損なう可能性があります。この問題は、侵害されたCAが偽のキーを含む代替証明書を発行できるために発生します。 CAまたはその信頼できるパートナーの侵害に関する最近の経験は、非常に深刻なセキュリティ問題を引き起こしています。たとえば、複数の国の政府が、何百万ものユーザーから信頼されている主要なTLSで保護されたWebサイトを盗聴または破壊しようとしているなどです。"
    },
    {
      "indent": 3,
      "text": "The DNS Security Extensions (DNSSEC) provide a similar model that involves trusted keys signing the information for untrusted keys. However, DNSSEC provides three significant improvements. Keys are tied to names in the Domain Name System (DNS), rather than to arbitrary identifying strings; this is more convenient for Internet protocols. Signed keys for any domain are accessible online through a straightforward query using the standard DNSSEC protocol, so there is no problem distributing the signed keys. Most significantly, the keys associated with a domain name can only be signed by a key associated with the parent of that domain name; for example, the keys for \"example.com\" can only be signed by the keys for \"com\", and the keys for \"com\" can only be signed by the DNS root. This prevents an untrustworthy signer from compromising anyone's keys except those in their own subdomains. Like TLS, DNSSEC relies on public keys that come built into the DNSSEC client software, but these keys come only from a single root domain rather than from a multiplicity of CAs.",
      "ja": "DNS Security Extensions（DNSSEC）は、信頼されていないキーの情報に署名する信頼されたキーを含む同様のモデルを提供します。ただし、DNSSECには3つの重要な改善点があります。キーは、任意の識別文字列ではなく、ドメインネームシステム（DNS）内の名前に関連付けられています。これはインターネットプロトコルにとってより便利です。どのドメインの署名済みキーも、標準のDNSSECプロト​​コルを使用した簡単なクエリを通じてオンラインでアクセスできるため、署名済みキーの配布に問題はありません。最も重要なことは、ドメイン名に関連付けられたキーは、そのドメイン名の親に関連付けられたキーによってのみ署名できることです。たとえば、「example.com」のキーは「com」のキーでのみ署名でき、「com」のキーはDNSルートでのみ署名できます。これにより、信頼できない署名者が自分のサブドメインにあるもの以外の誰かの鍵を危険にさらすのを防ぎます。 TLSと同様に、DNSSECはDNSSECクライアントソフトウェアに組み込まれている公開鍵に依存していますが、これらの鍵は複数のCAではなく単一のルートドメインからのみ取得されます。"
    },
    {
      "indent": 3,
      "text": "DNS-Based Authentication of Named Entities (DANE) offers the option to use the DNSSEC infrastructure to store and sign keys and certificates that are used by TLS. DANE is envisioned as a preferable basis for binding public keys to DNS names, because the entities that vouch for the binding of public key data to DNS names are the same entities responsible for managing the DNS names in question. While the resulting system still has residual security vulnerabilities, it restricts the scope of assertions that can be made by any entity, consistent with the naming scope imposed by the DNS hierarchy. As a result, DANE embodies the security \"principle of least privilege\" that is lacking in the current public CA model.",
      "ja": "名前付きエンティティのDNSベースの認証（DANE）には、DNSSECインフラストラクチャを使用して、TLSで使用されるキーと証明書を保存および署名するオプションがあります。 DANEは、公開鍵をDNS名にバインドするための好ましい基盤として想定されています。公開鍵データのDNS名へのバインドを保証するエンティティは、問題のDNS名の管理を担当するエンティティと同じだからです。結果のシステムには依然としてセキュリティの脆弱性が残っていますが、DNS階層によって課された名前付けスコープと整合性が取れて、任意のエンティティが作成できるアサーションのスコープが制限されます。その結果、DANEは、現在のパブリックCAモデルに欠けているセキュリティ「最小特権の原則」を具現化します。"
    },
    {
      "indent": 0,
      "text": "1.2. Securing the Association of a Domain Name with a Server's Certificate",
      "ja": "1.2. サーバーの証明書によるドメイン名の関連付けの保護"
    },
    {
      "indent": 3,
      "text": "A TLS client begins a connection by exchanging messages with a TLS server. For many application protocols, it looks up the server's name using the DNS to get an Internet Protocol (IP) address associated with the name. It then begins a connection to a particular port at that address, and sends an initial message there. However, the client does not yet know whether an adversary is intercepting and/or altering its communication before it reaches the TLS server. It does not even know whether the real TLS server associated with that domain name has ever received its initial messages.",
      "ja": "TLSクライアントは、TLSサーバーとメッセージを交換することで接続を開始します。多くのアプリケーションプロトコルでは、DNSを使用してサーバーの名前を検索し、名前に関連付けられているインターネットプロトコル（IP）アドレスを取得します。次に、そのアドレスで特定のポートへの接続を開始し、そこに初期メッセージを送信します。ただし、クライアントは、攻撃者がTLSサーバーに到達する前に通信を傍受または変更しているのかどうかをまだ認識していません。そのドメイン名に関連付けられた実際のTLSサーバーが最初のメッセージを受信したことがあるかどうかさえわかりません。"
    },
    {
      "indent": 0,
      "text": " The first response from the server in TLS may contain a certificate. In order for the TLS client to authenticate that it is talking to the expected TLS server, the client must validate that this certificate is associated with the domain name used by the client to get to the server. Currently, the client must extract the domain name from the certificate and must successfully validate the certificate, including chaining to a trust anchor.",
      "ja": "TLSのサーバーからの最初の応答には、証明書が含まれる場合があります。 TLSクライアントが、予期されるTLSサーバーと通信していることを認証するために、クライアントは、この証明書がサーバーに到達するためにクライアントが使用するドメイン名に関連付けられていることを検証する必要があります。現在、クライアントは証明書からドメイン名を抽出し、トラストアンカーへのチェーンを含め、証明書を正常に検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "There is a different way to authenticate the association of the server's certificate with the intended domain name without trusting an external CA. Given that the DNS administrator for a domain name is authorized to give identifying information about the zone, it makes sense to allow that administrator to also make an authoritative binding between the domain name and a certificate that might be used by a host at that domain name. The easiest way to do this is to use the DNS, securing the binding with DNSSEC.",
      "ja": "外部CAを信頼せずに、サーバーの証明書と目的のドメイン名との関連付けを認証する別の方法があります。ドメイン名のDNS管理者がゾーンに関する識別情報を提供することを許可されている場合、その管理者がドメイン名とそのドメイン名のホストによって使用される可能性のある証明書との間に権限のあるバインディングを作成することを許可することは理にかなっています。これを行う最も簡単な方法は、DNSを使用して、DNSSECとのバインディングを保護することです。"
    },
    {
      "indent": 3,
      "text": "There are many use cases for such functionality. [RFC6394] lists the ones to which the DNS RRtype in this document apply. [RFC6394] also lists many requirements, most of which this document is believed to meet. Section 5 covers the applicability of this document to the use cases in detail. The protocol in this document can generally be referred to as the \"DANE TLSA\" protocol. (\"TLSA\" does not stand for anything; it is just the name of the RRtype.)",
      "ja": "このような機能には多くの使用例があります。 [RFC6394]は、このドキュメントのDNS RRtypeが適用されるものをリストしています。 [RFC6394]にも多くの要件がリストされており、このドキュメントのほとんどが満たされていると考えられています。セクション5では、このドキュメントのユースケースへの適用性について詳しく説明します。このドキュメントのプロトコルは、一般に「DANE TLSA」プロトコルと呼ばれます。 （「TLSA」は何の略でもありません。これはRRtypeの名前にすぎません。）"
    },
    {
      "indent": 3,
      "text": "This document applies to both TLS [RFC5246] and Datagram TLS (DTLS) [RFC6347]. In order to make the document more readable, it mostly only talks about \"TLS\", but in all cases, it means \"TLS or DTLS\". Although the references in this paragraph are to TLS and DTLS version 1.2, the DANE TLSA protocol can also be used with earlier versions of TLS and DTLS.",
      "ja": "このドキュメントは、TLS [RFC5246]とデータグラムTLS（DTLS）[RFC6347]の両方に適用されます。ドキュメントを読みやすくするために、主に「TLS」についてのみ説明していますが、すべての場合において、「TLSまたはDTLS」を意味します。この段落での参照はTLSおよびDTLSバージョン1.2に関するものですが、DANE TLSAプロトコルは、以前のバージョンのTLSおよびDTLSでも使用できます。"
    },
    {
      "indent": 3,
      "text": "This document only relates to securely associating certificates for TLS and DTLS with host names; retrieving certificates from DNS for other protocols is handled in other documents. For example, keys for IPsec are covered in [RFC4025], and keys for Secure SHell (SSH) are covered in [RFC4255].",
      "ja": "このドキュメントは、TLSおよびDTLSの証明書をホスト名に安全に関連付けることのみに関連しています。他のプロトコルのDNSからの証明書の取得は、他のドキュメントで処理されます。たとえば、IPsecのキーは[RFC4025]でカバーされており、セキュアシェル（SSH）のキーは[RFC4255]でカバーされています。"
    },
    {
      "indent": 0,
      "text": "1.3. Method for Securing Certificate Associations",
      "section_title": true,
      "ja": "1.3. 証明書の関連付けを保護する方法"
    },
    {
      "indent": 3,
      "text": "A certificate association is formed from a piece of information identifying a certificate and the domain name where the server application runs. The combination of a trust anchor and a domain name can also be a certificate association.",
      "ja": "証明書の関連付けは、サーバーアプリケーションが実行される証明書とドメイン名を識別する情報から構成されます。トラストアンカーとドメイン名の組み合わせは、証明書の関連付けにもなります。"
    },
    {
      "indent": 3,
      "text": "A DNS query can return multiple certificate associations, such as in the case of a server that is changing from one certificate to another (described in more detail in Appendix A.4).",
      "ja": "DNSクエリは、サーバーがある証明書から別の証明書に変更される場合など、複数の証明書の関連付けを返すことができます（付録A.4で詳細に説明されています）。"
    },
    {
      "indent": 3,
      "text": "This document only applies to PKIX [RFC5280] certificates, not certificates of other formats.",
      "ja": "このドキュメントは、PKIX [RFC5280]証明書にのみ適用され、他の形式の証明書には適用されません。"
    },
    {
      "indent": 3,
      "text": "This document defines a secure method to associate the certificate that is obtained from the TLS server with a domain name using DNS; the DNS information needs to be protected by DNSSEC. Because the certificate association was retrieved based on a DNS query, the domain name in the query is by definition associated with the certificate. Note that this document does not cover how to associate certificates with domain names for application protocols that depend on SRV, NAPTR, and similar DNS resource records. It is expected that future documents will cover methods for making those associations, and those documents may or may not need to update this one.",
      "ja": "このドキュメントでは、TLSサーバーから取得した証明書をDNSを使用してドメイン名に関連付ける安全な方法を定義しています。 DNS情報はDNSSECで保護する必要があります。証明書の関連付けはDNSクエリに基づいて取得されたため、クエリ内のドメイン名は、定義により証明書に関連付けられています。このドキュメントでは、SRV、NAPTR、および同様のDNSリソースレコードに依存するアプリケーションプロトコルのドメイン名に証明書を関連付ける方法については説明していません。今後のドキュメントでは、これらの関連付けを行うための方法がカバーされることが期待されており、これらのドキュメントは、この関連付けを更新する必要がある場合とない場合があります。"
    },
    {
      "indent": 3,
      "text": "DNSSEC, which is defined in [RFC4033], [RFC4034], and [RFC4035], uses cryptographic keys and digital signatures to provide authentication of DNS data. Information that is retrieved from the DNS and that is validated using DNSSEC is thereby proved to be the authoritative data. The DNSSEC signature needs to be validated on all responses that use DNSSEC in order to assure the proof of origin of the data.",
      "ja": "[RFC4033]、[RFC4034]、および[RFC4035]で定義されているDNSSECは、暗号鍵とデジタル署名を使用してDNSデータの認証を提供します。 DNSから取得され、DNSSECを使用して検証される情報は、信頼できるデータであることが証明されます。データの出所の証明を保証するには、DNSSEC署名をDNSSECを使用するすべての応答で検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "This document does not specify how DNSSEC validation occurs because there are many different proposals for how a client might get validated DNSSEC results, such as from a DNSSEC-aware resolver that is coded in the application, from a trusted DNSSEC resolver on the machine on which the application is running, or from a trusted DNSSEC resolver with which the application is communicating over an authenticated and integrity-protected channel or network. This is described in more detail in Section 7 of [RFC4033].",
      "ja": "このドキュメントでは、DNSSEC検証がどのように行われるかを指定していません。アプリケーションでコーディングされているDNSSEC対応リゾルバーから、マシンの信頼されたDNSSECリゾルバーからなど、クライアントが検証済みDNSSEC結果を取得する方法についてはさまざまな提案があるためです。アプリケーションが実行されているか、アプリケーションが認証され、整合性が保護されたチャネルまたはネットワークを介して通信している信頼できるDNSSECリゾルバーから。これについては、[RFC4033]のセクション7で詳しく説明しています。"
    },
    {
      "indent": 3,
      "text": "This document only relates to getting the DNS information for the certificate association securely using DNSSEC; other secure DNS mechanisms are out of scope.",
      "ja": "このドキュメントは、DNSSECを使用して証明書関連付けのDNS情報を安全に取得することのみに関連しています。他の安全なDNSメカニズムは範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.4. Terminology",
      "section_title": true,
      "ja": "1.4. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document also makes use of standard PKIX, DNSSEC, TLS, and DNS terminology. See [RFC5280], [RFC4033], [RFC5246], and STD 13 [RFC1034] [RFC1035], respectively, for these terms. In addition, terms related to TLS-protected application services and DNS names are taken from [RFC6125].",
      "ja": "このドキュメントでは、標準のPKIX、DNSSEC、TLS、およびDNSの用語も使用しています。これらの用語については、それぞれ[RFC5280]、[RFC4033]、[RFC5246]、およびSTD 13 [RFC1034] [RFC1035]を参照してください。さらに、TLSで保護されたアプリケーションサービスとDNS名に関連する用語は、[RFC6125]から取得されます。"
    },
    {
      "indent": 0,
      "text": "2. The TLSA Resource Record",
      "section_title": true,
      "ja": "2. TLSAリソースレコード"
    },
    {
      "indent": 3,
      "text": "The TLSA DNS resource record (RR) is used to associate a TLS server certificate or public key with the domain name where the record is found, thus forming a \"TLSA certificate association\". The semantics of how the TLSA RR is interpreted are given later in this document.",
      "ja": "TLSA DNSリソースレコード（RR）は、TLSサーバー証明書または公開鍵を、レコードが見つかったドメイン名に関連付けるために使用され、「TLSA証明書の関連付け」を形成します。 TLSA RRの解釈方法のセマンティクスは、このドキュメントの後半で説明します。"
    },
    {
      "indent": 3,
      "text": "The type value for the TLSA RR type is defined in Section 7.1.",
      "ja": "TLSA RRタイプのタイプ値はセクション7.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "The TLSA RR is class independent.",
      "ja": "TLSA RRはクラスに依存しません。"
    },
    {
      "indent": 3,
      "text": "The TLSA RR has no special Time to Live (TTL) requirements.",
      "ja": "TLSA RRには、特別なTime to Live（TTL）要件はありません。"
    },
    {
      "indent": 0,
      "text": "2.1. TLSA RDATA Wire Format",
      "section_title": true,
      "ja": "2.1. TLSA RDATAワイヤー形式"
    },
    {
      "indent": 3,
      "text": "The RDATA for a TLSA RR consists of a one-octet certificate usage field, a one-octet selector field, a one-octet matching type field, and the certificate association data field.",
      "ja": "TLSA RRのRDATAは、1オクテットの証明書使用フィールド、1オクテットのセレクタフィールド、1オクテットの一致タイプフィールド、および証明書関連付けデータフィールドで構成されます。"
    },
    {
      "indent": 3,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Cert. Usage  |   Selector    | Matching Type |               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               /\n/                                                               /\n/                 Certificate Association Data                  /\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.1. The Certificate Usage Field",
      "section_title": true,
      "ja": "2.1.1. 証明書の使用フィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"certificate usage\", specifies the provided association that will be used to match the certificate presented in the TLS handshake. This value is defined in a new IANA registry (see Section 7.2) in order to make it easier to add additional certificate usages in the future. The certificate usages defined in this document are:",
      "ja": "「証明書の使用法」と呼ばれる1オクテットの値は、TLSハンドシェイクで提示される証明書との照合に使用される、提供される関連付けを指定します。この値は、新しいIANAレジストリ（セクション7.2を参照）で定義されており、将来、証明書の使用法を簡単に追加できるようになります。このドキュメントで定義されている証明書の使用法は次のとおりです。"
    },
    {
      "indent": 0,
      "text": " 0 -- Certificate usage 0 is used to specify a CA certificate, or the public key of such a certificate, that MUST be found in any of the PKIX certification paths for the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"CA constraint\" because it limits which CA can be used to issue certificates for a given service on a host. The presented certificate MUST pass PKIX certification path validation, and a CA certificate that matches the TLSA record MUST be included as part of a valid certification path. Because this certificate usage allows both trust anchors and CA certificates, the certificate might or might not have the basicConstraints extension present.",
      "ja": "0-証明書の使用法0は、CA証明書、またはそのような証明書の公開鍵を指定するために使用されます。これは、TLSでサーバーによって提供されるエンドエンティティ証明書のPKIX証明書パスのいずれかにある必要があります。この証明書の使用は、ホスト上の特定のサービスの証明書を発行するために使用できるCAを制限するため、「CA制約」と呼ばれることがあります。提示された証明書はPKIX証明書パス検証に合格する必要があり、TLSAレコードに一致するCA証明書は有効な証明書パスの一部として含まれている必要があります。この証明書の使用では、トラストアンカーとCA証明書の両方が許可されるため、証明書にはbasicConstraints拡張が存在する場合と存在しない場合があります。"
    },
    {
      "indent": 6,
      "text": "1 -- Certificate usage 1 is used to specify an end entity certificate, or the public key of such a certificate, that MUST be matched with the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"service certificate constraint\" because it limits which end entity certificate can be used by a given service on a host. The target certificate MUST pass PKIX certification path validation and MUST match the TLSA record.",
      "ja": "1-証明書の使用法1は、エンドエンティティ証明書、またはそのような証明書の公開キーを指定するために使用されます。これは、TLSでサーバーによって提供されるエンドエンティティ証明書と一致する必要があります。この証明書の使用は、ホスト上の特定のサービスで使用できるエンドエンティティ証明書を制限するため、「サービス証明書の制約」と呼ばれることがあります。ターゲット証明書は、PKIX証明書パス検証に合格する必要があり、TLSAレコードと一致する必要があります。"
    },
    {
      "indent": 6,
      "text": "2 -- Certificate usage 2 is used to specify a certificate, or the public key of such a certificate, that MUST be used as the trust anchor when validating the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"trust anchor assertion\" and allows a domain name administrator to specify a new trust anchor -- for example, if the domain issues its own certificates under its own CA that is not expected to be in the end users' collection of trust anchors. The target certificate MUST pass PKIX certification path validation, with any certificate matching the TLSA record considered to be a trust anchor for this certification path validation.",
      "ja": "2-証明書の使用法2は、証明書、またはそのような証明書の公開鍵を指定するために使用されます。これは、TLSでサーバーから提供されたエンドエンティティ証明書を検証するときにトラストアンカーとして使用する必要があります。この証明書の使用法は、「トラストアンカーアサーション」と呼ばれることもあり、ドメイン名管理者が新しいトラストアンカーを指定できるようにします。たとえば、ドメインが独自のCAの下で独自の証明書を発行し、最終的にはそうでない場合ユーザーのトラストアンカーのコレクション。ターゲット証明書は、TLSAレコードと一致するすべての証明書がこの証明書パス検証のトラストアンカーであると見なされて、PKIX証明書パス検証に合格する必要があります。"
    },
    {
      "indent": 6,
      "text": "3 -- Certificate usage 3 is used to specify a certificate, or the public key of such a certificate, that MUST match the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"domain-issued certificate\" because it allows for a domain name administrator to issue certificates for a domain without involving a third-party CA. The target certificate MUST match the TLSA record. The difference between certificate usage 1 and certificate usage 3 is that certificate usage 1 requires that the certificate pass PKIX validation, but PKIX validation is not tested for certificate usage 3.",
      "ja": "3-証明書の使用法3は、証明書、またはそのような証明書の公開鍵を指定するために使用され、TLSでサーバーによって提供されるエンドエンティティ証明書と一致する必要があります。この証明書の使用法は、ドメイン名管理者がサードパーティのCAを介さずにドメインの証明書を発行できるため、「ドメイン発行の証明書」と呼ばれることもあります。ターゲット証明書はTLSAレコードと一致する必要があります。証明書の使用法1と証明書の使用法3の違いは、証明書の使用法1では証明書がPKIX検証に合格する必要があるが、PKIX検証は証明書の使用法3に対してテストされていないことです。"
    },
    {
      "indent": 3,
      "text": "The certificate usages defined in this document explicitly only apply to PKIX-formatted certificates in DER encoding [X.690]. If TLS allows other formats later, or if extensions to this RRtype are made that accept other formats for certificates, those certificates will need their own certificate usage values.",
      "ja": "このドキュメントで定義されている証明書の使用法は、DERエンコーディング[X.690]のPKIX形式の証明書にのみ適用されます。 TLSが後で他の形式を許可する場合、またはこのRRtypeを拡張して証明書の他の形式を受け入れる場合、それらの証明書には独自の証明書使用値が必要になります。"
    },
    {
      "indent": 0,
      "text": "2.1.2. The Selector Field",
      "section_title": true,
      "ja": "2.1.2. セレクタフィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"selector\", specifies which part of the TLS certificate presented by the server will be matched against the association data. This value is defined in a new IANA registry (see Section 7.3). The selectors defined in this document are:",
      "ja": "「セレクタ」と呼ばれる1オクテットの値は、サーバーによって提示されたTLS証明書のどの部分が関連付けデータと照合されるかを指定します。この値は、新しいIANAレジストリで定義されます（7.3項を参照）。このドキュメントで定義されているセレクタは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 -- Full certificate: the Certificate binary structure as defined in [RFC5280]",
      "ja": "0-完全な証明書：[RFC5280]で定義されている証明書のバイナリ構造"
    },
    {
      "indent": 6,
      "text": "1 -- SubjectPublicKeyInfo: DER-encoded binary structure as defined in [RFC5280]",
      "ja": "1-SubjectPublicKeyInfo：[RFC5280]で定義されているDERエンコードのバイナリ構造"
    },
    {
      "indent": 3,
      "text": "(Note that the use of \"selector\" in this document is completely unrelated to the use of \"selector\" in DomainKeys Identified Mail (DKIM) [RFC6376].)",
      "ja": "（このドキュメントでの「selector」の使用は、DomainKeys Identified Mail（DKIM）[RFC6376]での「selector」の使用とはまったく関係がないことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "2.1.3. The Matching Type Field",
      "section_title": true,
      "ja": "2.1.3. マッチングタイプフィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"matching type\", specifies how the certificate association is presented. This value is defined in a new IANA registry (see Section 7.4). The types defined in this document are:",
      "ja": "「一致タイプ」と呼ばれる1オクテットの値は、証明書の関連付けの提示方法を指定します。この値は新しいIANAレジストリで定義されます（セクション7.4を参照）。このドキュメントで定義されているタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 -- Exact match on selected content",
      "ja": "0-選択したコンテンツの完全一致"
    },
    {
      "indent": 6,
      "text": "1 -- SHA-256 hash of selected content [RFC6234]",
      "ja": "1-選択したコンテンツのSHA-256ハッシュ[RFC6234]"
    },
    {
      "indent": 6,
      "text": "2 -- SHA-512 hash of selected content [RFC6234]",
      "ja": "2-選択されたコンテンツのSHA-512ハッシュ[RFC6234]"
    },
    {
      "indent": 3,
      "text": "If the TLSA record's matching type is a hash, having the record use the same hash algorithm that was used in the signature in the certificate (if possible) will assist clients that support a small number of hash algorithms.",
      "ja": "TLSAレコードの一致タイプがハッシュの場合、証明書の署名で使用されたものと同じハッシュアルゴリズムをレコードに使用させると（可能な場合）、少数のハッシュアルゴリズムをサポートするクライアントを支援します。"
    },
    {
      "indent": 0,
      "text": "2.1.4. The Certificate Association Data Field",
      "section_title": true,
      "ja": "2.1.4. 証明書関連付けデータフィールド"
    },
    {
      "indent": 3,
      "text": "This field specifies the \"certificate association data\" to be matched. These bytes are either raw data (that is, the full certificate or its SubjectPublicKeyInfo, depending on the selector) for matching type 0, or the hash of the raw data for matching types 1 and 2. The data refers to the certificate in the association, not to the TLS ASN.1 Certificate object.",
      "ja": "このフィールドは、照合する「証明書関連付けデータ」を指定します。これらのバイトは、一致するタイプ0の生データ（つまり、セレクターに応じて完全な証明書またはそのSubjectPublicKeyInfo）、または一致するタイプ1および2の生データのハッシュのいずれかです。データは、関連付けの証明書を参照します、TLS ASN.1証明書オブジェクトではありません。"
    },
    {
      "indent": 0,
      "text": "2.2. TLSA RR Presentation Format",
      "section_title": true,
      "ja": "2.2. TLSA RRプレゼンテーション形式"
    },
    {
      "indent": 3,
      "text": "The presentation format of the RDATA portion (as defined in [RFC1035]) is as follows:",
      "ja": "RDATA部分の表示形式（[RFC1035]で定義）は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The certificate usage field MUST be represented as an 8-bit unsigned integer.",
      "ja": "o 証明書の使用法フィールドは、8ビットの符号なし整数として表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The selector field MUST be represented as an 8-bit unsigned integer.",
      "ja": "o セレクターフィールドは、8ビットの符号なし整数として表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The matching type field MUST be represented as an 8-bit unsigned integer.",
      "ja": "o 一致する型フィールドは、8ビットの符号なし整数として表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The certificate association data field MUST be represented as a string of hexadecimal characters. Whitespace is allowed within the string of hexadecimal characters, as described in [RFC1035].",
      "ja": "o 証明書関連付けデータフィールドは、16進文字の文字列として表現する必要があります。 [RFC1035]で説明されているように、16進文字の文字列内で空白を使用できます。"
    },
    {
      "indent": 0,
      "text": "2.3. TLSA RR Examples",
      "section_title": true,
      "ja": "2.3. TLSA RRの例"
    },
    {
      "indent": 3,
      "text": "In the following examples, the domain name is formed using the rules in Section 3.",
      "ja": "次の例では、ドメイン名はセクション3のルールを使用して形成されています。"
    },
    {
      "indent": 3,
      "text": "An example of a hashed (SHA-256) association of a PKIX CA certificate:",
      "ja": "PKIX CA証明書のハッシュ（SHA-256）関連付けの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 0 0 1 d2abde240d7cd3ee6b4b28c54df034b9 7983a1d16e8a410e4561cb106618e971 )",
      "ja": "_443._tcp.www.example.com。 IN TLSA（0 0 1 d2abde240d7cd3ee6b4b28c54df034b9 7983a1d16e8a410e4561cb106618e971）"
    },
    {
      "indent": 3,
      "text": "An example of a hashed (SHA-512) subject public key association of a PKIX end entity certificate:",
      "ja": "PKIXエンドエンティティ証明書のハッシュされた（SHA-512）サブジェクト公開キーの関連付けの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 1 1 2 92003ba34942dc74152e2f2c408d29ec a5a520e7f2e06bb944f4dca346baf63c 1b177615d466f6c4b71c216a50292bd5 8c9ebdd2f74e38fe51ffd48c43326cbc )",
      "ja": "_443._tcp.www.example.com。 TLSA（1 1 2 92003ba34942dc74152e2f2c408d29ec a5a520e7f2e06bb944f4dca346baf63c 1b177615d466f6c4b71c216a50292bd5 8c9ebdd2f74e38fe51ffd48c43326cbc）"
    },
    {
      "indent": 3,
      "text": "An example of a full certificate association of a PKIX end entity certificate:",
      "ja": "PKIXエンドエンティティ証明書の完全な証明書関連付けの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 3 0 0 30820307308201efa003020102020... )",
      "ja": "_443._tcp.www.example.com。 IN TLSA（3 0 0 30820307308201efa003020102020 ...）"
    },
    {
      "indent": 0,
      "text": "3. Domain Names for TLSA Certificate Associations",
      "section_title": true,
      "ja": "3. TLSA証明書関連付けのドメイン名"
    },
    {
      "indent": 3,
      "text": "Unless there is a protocol-specific specification that is different than this one, TLSA resource records are stored at a prefixed DNS domain name. The prefix is prepared in the following manner:",
      "ja": "これとは異なるプロトコル固有の仕様がない限り、TLSAリソースレコードは接頭辞付きのDNSドメイン名に格納されます。プレフィックスは次の方法で準備されます。"
    },
    {
      "indent": 3,
      "text": "1. The decimal representation of the port number on which a TLS-based service is assumed to exist is prepended with an underscore character (\"_\") to become the left-most label in the prepared domain name. This number has no leading zeros.",
      "ja": "1. TLSベースのサービスが存在すると想定されるポート番号の10進表記には、下線文字（ \"_\"）が前に付加され、準備されたドメイン名の左端のラベルになります。この数には先行ゼロはありません。"
    },
    {
      "indent": 3,
      "text": "2. The protocol name of the transport on which a TLS-based service is assumed to exist is prepended with an underscore character (\"_\") to become the second left-most label in the prepared domain name. The transport names defined for this protocol are \"tcp\", \"udp\", and \"sctp\".",
      "ja": "2. TLSベースのサービスが存在すると想定されるトランスポートのプロトコル名の前にアンダースコア文字（ \"_\"）を付加して、準備されたドメイン名の左から2番目のラベルになります。このプロトコルに定義されているトランスポート名は、「tcp」、「udp」、および「sctp」です。"
    },
    {
      "indent": 3,
      "text": "3. The base domain name is appended to the result of step 2 to complete the prepared domain name. The base domain name is the fully qualified DNS domain name [RFC1035] of the TLS server, with the additional restriction that every label MUST meet the rules of [RFC0952]. The latter restriction means that, if the query is for an internationalized domain name, it MUST use the A-label form as defined in [RFC5890].",
      "ja": "3. ステップ2の結果にベースドメイン名が追加され、準備されたドメイン名が完成します。基本ドメイン名は、TLSサーバーの完全修飾DNSドメイン名[RFC1035]であり、すべてのラベルが[RFC0952]の規則に適合しなければならないという追加の制限があります。後者の制限は、クエリが国際化ドメイン名に対するものである場合、[RFC5890]で定義されているAラベル形式を使用しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, to request a TLSA resource record for an HTTP server running TLS on port 443 at \"www.example.com\", \"_443._tcp.www.example.com\" is used in the request. To request a TLSA resource record for an SMTP server running the STARTTLS protocol on port 25 at \"mail.example.com\", \"_25._tcp.mail.example.com\" is used.",
      "ja": "たとえば、「www.example.com」のポート443でTLSを実行しているHTTPサーバーのTLSAリソースレコードをリクエストするには、リクエストで「_443._tcp.www.example.com」を使用します。 「mail.example.com」のポート25でSTARTTLSプロトコルを実行しているSMTPサーバーのTLSAリソースレコードをリクエストするには、「_ 25._tcp.mail.example.com」を使用します。"
    },
    {
      "indent": 0,
      "text": "4. Use of TLSA Records in TLS",
      "section_title": true,
      "ja": "4. TLSでのTLSAレコードの使用"
    },
    {
      "indent": 3,
      "text": "Section 2.1 of this document defines the mandatory matching rules for the data from the TLSA certificate associations and the certificates received from the TLS server.",
      "ja": "このドキュメントのセクション2.1は、TLSA証明書の関連付けからのデータとTLSサーバーから受信した証明書の必須のマッチングルールを定義しています。"
    },
    {
      "indent": 3,
      "text": "The TLS session that is to be set up MUST be for the specific port number and transport name that was given in the TLSA query.",
      "ja": "セットアップされるTLSセッションは、TLSAクエリで指定された特定のポート番号とトランスポート名に対するものである必要があります。"
    },
    {
      "indent": 3,
      "text": "Some specifications for applications that run over TLS, such as [RFC2818] for HTTP, require that the server's certificate have a domain name that matches the host name expected by the client. Some specifications, such as [RFC6125], detail how to match the identity given in a PKIX certificate with those expected by the user.",
      "ja": "HTTPの[RFC2818]など、TLSを介して実行するアプリケーションの一部の仕様では、サーバーの証明書に、クライアントが予期するホスト名と一致するドメイン名が必要です。 [RFC6125]などの一部の仕様では、PKIX証明書で指定されたIDをユーザーが期待するIDと照合する方法が詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "If a TLSA record has certificate usage 2, the corresponding TLS server SHOULD send the certificate that is referenced just like it currently sends intermediate certificates.",
      "ja": "TLSAレコードに証明書の使用法2がある場合、対応するTLSサーバーは、現在中間証明書を送信しているように、参照されている証明書を送信する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "4.1. Usable Certificate Associations",
      "section_title": true,
      "ja": "4.1. 使用可能な証明書の関連付け"
    },
    {
      "indent": 3,
      "text": "An implementation of this protocol makes a DNS query for TLSA records, validates these records using DNSSEC, and uses the resulting TLSA records and validation status to modify its responses to the TLS server.",
      "ja": "このプロトコルの実装は、TLSAレコードのDNSクエリを作成し、DNSSECを使用してこれらのレコードを検証し、結果のTLSAレコードと検証ステータスを使用して、TLSサーバーへの応答を変更します。"
    },
    {
      "indent": 3,
      "text": "Determining whether a TLSA RRSet can be used MUST be based on the DNSSEC validation state (as defined in [RFC4033]).",
      "ja": "TLSA RRSetを使用できるかどうかの判断は、DNSSEC検証状態（[RFC4033]で定義されている）に基づく必要があります。"
    },
    {
      "indent": 3,
      "text": "o A TLSA RRSet whose DNSSEC validation state is secure MUST be used as a certificate association for TLS unless a local policy would prohibit the use of the specific certificate association in the secure TLSA RRSet.",
      "ja": "o DNSSEC検証状態が安全なTLSA RRSetは、ローカルポリシーが安全なTLSA RRSetでの特定の証明書関連付けの使用を禁止しない限り、TLSの証明書関連付けとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the DNSSEC validation state on the response to the request for the TLSA RRSet is bogus, this MUST cause TLS not to be started or, if the TLS negotiation is already in progress, MUST cause the connection to be aborted.",
      "ja": "o TLSA RRSetの要求に対する応答のDNSSEC検証状態が偽である場合、これによりTLSが開始されないか、TLSネゴシエーションが既に進行中の場合、接続が中止される必要があります。"
    },
    {
      "indent": 3,
      "text": "o A TLSA RRSet whose DNSSEC validation state is indeterminate or insecure cannot be used for TLS and MUST be considered unusable.",
      "ja": "o DNSSEC検証状態が不確定または安全でないTLSA RRSetはTLSに使用できず、使用不可と見なされなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Clients that validate the DNSSEC signatures themselves MUST use standard DNSSEC validation procedures. Clients that rely on another entity to perform the DNSSEC signature validation MUST use a secure mechanism between themselves and the validator. Examples of secure transports to other hosts include TSIG [RFC2845], SIG(0) [RFC2931], and IPsec [RFC6071]. Note that it is not sufficient to use secure transport to a DNS resolver that does not do DNSSEC signature validation. See Section 8.3 for more security considerations related to external validators.",
      "ja": "DNSSEC署名自体を検証するクライアントは、標準のDNSSEC検証手順を使用する必要があります。 DNSSEC署名の検証を実行するために別のエンティティに依存しているクライアントは、クライアントとバリデータの間で安全なメカニズムを使用する必要があります。他のホストへのセキュアなトランスポートの例には、TSIG [RFC2845]、SIG（0）[RFC2931]、およびIPsec [RFC6071]が含まれます。 DNSSEC署名検証を行わないDNSリゾルバーへのセキュアなトランスポートを使用するだけでは不十分であることに注意してください。外部バリデータに関連するセキュリティの考慮事項については、セクション8.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a certificate association contains a certificate usage, selector, or matching type that is not understood by the TLS client, that certificate association MUST be considered unusable. If the comparison data for a certificate is malformed, the certificate association MUST be considered unusable.",
      "ja": "証明書の関連付けに、TLSクライアントが理解できない証明書の使用法、セレクター、または一致するタイプが含まれている場合、その証明書の関連付けは使用できないと見なす必要があります。証明書の比較データが不正な形式である場合、証明書の関連付けは使用不可と見なされます。"
    },
    {
      "indent": 3,
      "text": "If a certificate association contains a matching type or certificate association data that uses a cryptographic algorithm that is considered too weak for the TLS client's policy, the certificate association MUST be considered unusable.",
      "ja": "証明書の関連付けに、TLSクライアントのポリシーにとって弱すぎると見なされる暗号化アルゴリズムを使用する一致するタイプまたは証明書の関連付けのデータが含まれている場合、証明書の関連付けは使用できないと見なす必要があります。"
    },
    {
      "indent": 3,
      "text": "If an application receives zero usable certificate associations from a DNS request or from its cache, it processes TLS in the normal fashion without any input from the TLSA records. If an application receives one or more usable certificate associations, it attempts to match each certificate association with the TLS server's end entity certificate until a successful match is found. During the TLS handshake, if none of the certificate associations matches the certificate given by the TLS server, the TLS client MUST abort the handshake.",
      "ja": "アプリケーションがDNS要求またはそのキャッシュから使用可能な証明書の関連付けをまったく受信しない場合、アプリケーションはTLSAレコードからの入力なしで通常の方法でTLSを処理します。アプリケーションは、1つ以上の使用可能な証明書の関連付けを受信すると、一致が見つかるまで、各証明書の関連付けをTLSサーバーのエンドエンティティ証明書と照合します。 TLSハンドシェイク中に、証明書の関連付けがTLSサーバーによって提供された証明書と一致しない場合、TLSクライアントはハンドシェイクを中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "An attacker who is able to divert a user to a server under his control is also likely to be able to block DNS requests from the user or DNS responses being sent to the user. Thus, in order to achieve any security benefit from certificate usage 0 or 1, an application that sends a request for TLSA records needs to get either a valid signed response containing TLSA records or verification that the domain is insecure or indeterminate. If a request for a TLSA record does not meet one of those two criteria but the application continues with the TLS handshake anyway, the application has gotten no benefit from TLSA and SHOULD NOT make any internal or external indication that TLSA was applied. If an application has a configuration setting that has turned on TLSA use, or has any indication that TLSA is in use (regardless of whether or not this is configurable), that application either MUST NOT start a TLS connection or it MUST abort a TLS handshake if both of the two criteria above are not met.",
      "ja": "ユーザーを自分の制御下にあるサーバーに誘導できる攻撃者も、ユーザーからのDNS要求またはユーザーに送信されるDNS応答をブロックできる可能性があります。したがって、証明書の使用法0または1からセキュリティ上の利点を得るには、TLSAレコードのリクエストを送信するアプリケーションが、TLSAレコードを含む有効な署名付き応答を取得するか、ドメインが安全でないか不確定であるかを確認する必要があります。 TLSAレコードの要求がこれら2つの基準のいずれかを満たさないが、アプリケーションがTLSハンドシェイクを続行している場合、アプリケーションはTLSAからの利益を得ておらず、TLSAが適用されたことを内部または外部に示すべきではありません。アプリケーションにTLSAの使用をオンにした構成設定がある場合、またはTLSAが使用中であることを示す（これが構成可能かどうかに関係なく）場合、そのアプリケーションはTLS接続を開始してはならないか、TLSハンドシェイクを中止する必要があります上記の2つの基準の両方が満たされていない場合。"
    },
    {
      "indent": 3,
      "text": "The application can perform the TLSA lookup before initiating the TLS handshake, or do it during the TLS handshake: the choice is up to the client.",
      "ja": "アプリケーションは、TLSハンドシェイクを開始する前にTLSAルックアップを実行することも、TLSハンドシェイク中に実行することもできます。選択はクライアント次第です。"
    },
    {
      "indent": 0,
      "text": "5. TLSA and DANE Use Cases and Requirements",
      "section_title": true,
      "ja": "5. TLSAおよびDANEの使用例と要件"
    },
    {
      "indent": 3,
      "text": "The different types of certificate associations defined in TLSA are matched with various sections of [RFC6394]. The use cases from Section 3 of [RFC6394] are covered in this document as follows:",
      "ja": "TLSAで定義されているさまざまなタイプの証明書の関連付けは、[RFC6394]のさまざまなセクションと一致しています。 [RFC6394]のセクション3のユースケースは、次のようにこのドキュメントでカバーされています。"
    },
    {
      "indent": 3,
      "text": "3.1 CA Constraints -- Implemented using certificate usage 0.",
      "ja": "3.1 CA制約-証明書の使用法0を使用して実装されています。"
    },
    {
      "indent": 3,
      "text": "3.2 Certificate Constraints -- Implemented using certificate usage 1.",
      "ja": "3.2 証明書の制約-証明書の使用法を使用して実装されています1。"
    },
    {
      "indent": 3,
      "text": "3.3 Trust Anchor Assertion and Domain-Issued Certificates -- Implemented using certificate usages 2 and 3, respectively.",
      "ja": "3.3 Trust Anchor Assertion and Domain-Issued Certificates-証明書の使用法2および3を使用してそれぞれ実装されます。"
    },
    {
      "indent": 3,
      "text": "The requirements from Section 4 of [RFC6394] are covered in this document as follows:",
      "ja": "[RFC6394]のセクション4の要件は、次のようにこのドキュメントでカバーされています。"
    },
    {
      "indent": 3,
      "text": "Multiple Ports -- The TLSA records for different application services running on a single host can be distinguished through the service name and port number prefixed to the host name (see Section 3).",
      "ja": "複数のポート-単一のホストで実行されているさまざまなアプリケーションサービスのTLSAレコードは、ホスト名の前に付けられたサービス名とポート番号によって区別できます（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "No Downgrade -- Section 4 specifies the conditions under which a client can process and act upon TLSA records. Specifically, if the DNSSEC status for the TLSA resource record set is determined to be bogus, the TLS connection (if started) will fail.",
      "ja": "ダウングレードなし-セクション4は、クライアントがTLSAレコードを処理および処理できる条件を指定します。具体的には、TLSAリソースレコードセットのDNSSECステータスが偽であると判断された場合、TLS接続（開始されている場合）は失敗します。"
    },
    {
      "indent": 3,
      "text": "Encapsulation -- Encapsulation is covered in the TLSA response semantics.",
      "ja": "カプセル化-カプセル化はTLSA応答セマンティクスでカバーされています。"
    },
    {
      "indent": 3,
      "text": "Predictability -- The appendices of this specification provide operational considerations and implementation guidance in order to enable application developers to form a consistent interpretation of the recommended client behavior.",
      "ja": "予測可能性-この仕様の付録は、アプリケーション開発者が推奨されるクライアントの動作の一貫した解釈を形成できるように、運用上の考慮事項と実装のガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Opportunistic Security -- If a client conformant to this specification can reliably determine the presence of a TLSA record, it will attempt to use this information. Conversely, if a client can reliably determine the absence of any TLSA record, it will fall back to processing TLS in the normal fashion. This is discussed in Section 4.",
      "ja": "日和見セキュリティ-この仕様に準拠するクライアントがTLSAレコードの存在を確実に判断できる場合、この情報を使用しようとします。逆に、クライアントがTLSAレコードがないことを確実に判断できる場合、クライアントは通常の方法でTLSの処理にフォールバックします。これについては、セクション4で説明します。"
    },
    {
      "indent": 3,
      "text": "Combination -- Multiple TLSA records can be published for a given host name, thus enabling the client to construct multiple TLSA certificate associations that reflect different assertions. No support is provided to combine two TLSA certificate associations in a single operation.",
      "ja": "組み合わせ-特定のホスト名に対して複数のTLSAレコードを公開できるため、クライアントは、異なるアサーションを反映する複数のTLSA証明書の関連付けを構築できます。 1つの操作で2つのTLSA証明書の関連付けを組み合わせるサポートは提供されていません。"
    },
    {
      "indent": 3,
      "text": "Roll-over -- TLSA records are processed in the normal manner within the scope of the DNS protocol, including the TTL expiration of the records. This ensures that clients will not latch onto assertions made by expired TLSA records, and will be able to transition from using one public key or certificate usage to another.",
      "ja": "ロールオーバー-TLSAレコードは、レコードのTTL有効期限を含め、DNSプロトコルのスコープ内で通常の方法で処理されます。これにより、クライアントは期限切れのTLSAレコードによって作成されたアサーションにラッチすることがなくなり、ある公開鍵または証明書の使用から別の使用に移行することができます。"
    },
    {
      "indent": 3,
      "text": "Simple Key Management -- The SubjectPublicKeyInfo selector in the TLSA record provides a mode that enables a domain holder to only have to maintain a single long-lived public/private key pair without the need to manage certificates. Appendix A outlines the usefulness and the potential downsides to using this mode.",
      "ja": "シンプルなキー管理-TLSAレコードのSubjectPublicKeyInfoセレクターは、ドメイン所有者が証明書を管理する必要なく、単一の長期間有効な公開/秘密キーのペアを維持するだけでよいモードを提供します。付録Aは、このモードを使用することの有用性と潜在的な欠点の概要を示しています。"
    },
    {
      "indent": 3,
      "text": "Minimal Dependencies -- This specification relies on DNSSEC to protect the origin authenticity and integrity of the TLSA resource record set. Additionally, if DNSSEC validation is not performed on the system that wishes to use TLSA certificate bindings, this specification requires that the \"last mile\" be over a secure transport. There are no other deployment dependencies for this approach.",
      "ja": "最小限の依存関係-この仕様はDNSSECに依存して、TLSAリソースレコードセットの元の信頼性と整合性を保護します。さらに、TLSA証明書バインディングを使用するシステムでDNSSEC検証が実行されない場合、この仕様では、「ラストマイル」が安全なトランスポート上にあることが必要です。このアプローチには、他のデプロイメントの依存関係はありません。"
    },
    {
      "indent": 3,
      "text": "Minimal Options -- The operating modes map precisely to the DANE use cases and requirements. DNSSEC use is mandatory in that this specification encourages applications to use only those TLSA records that are shown to be validated.",
      "ja": "最小限のオプション-動作モードは、DANEの使用例と要件に正確に対応しています。 DNSSECの使用は必須であり、この仕様では、アプリケーションが検証済みとして示されているTLSAレコードのみを使用することを推奨しています。"
    },
    {
      "indent": 3,
      "text": "Wildcards -- Wildcards are covered in a limited manner in the TLSA request syntax; see Appendix A.",
      "ja": "ワイルドカード-ワイルドカードは、TLSA要求構文で限られた方法でカバーされます。付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Redirection -- Redirection is covered in the TLSA request syntax; see Appendix A.",
      "ja": "リダイレクション-リダイレクションはTLSAリクエスト構文でカバーされています。付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Mandatory-to-Implement Features",
      "section_title": true,
      "ja": "6. 必須の機能"
    },
    {
      "indent": 3,
      "text": "TLS clients conforming to this specification MUST be able to correctly interpret TLSA records with certificate usages 0, 1, 2, and 3. TLS clients conforming to this specification MUST be able to compare a certificate association with a certificate from the TLS handshake using selector types 0 and 1, and matching type 0 (no hash used) and matching type 1 (SHA-256), and SHOULD be able to make such comparisons with matching type 2 (SHA-512).",
      "ja": "この仕様に準拠するTLSクライアントは、証明書の使用方法が0、1、2、3のTLSAレコードを正しく解釈できる必要があります。この仕様に準拠するTLSクライアントは、セレクタータイプを使用して、証明書の関連付けをTLSハンドシェイクからの証明書と比較できる必要があります。 0と1、および一致するタイプ0（ハッシュは使用されません）および一致するタイプ1（SHA-256）。一致するタイプ2（SHA-512）とこのような比較を行うことができる必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made the assignments in this section.",
      "ja": "IANAはこのセクションで割り当てを行いました。"
    },
    {
      "indent": 3,
      "text": "In the following sections, \"RFC Required\" was chosen for TLSA certificate usages and \"Specification Required\" for selectors and matching types because of the amount of detail that is likely to be needed for implementers to correctly implement new certificate usages as compared to new selectors and matching types.",
      "ja": "次のセクションでは、TLSA証明書の使用法には「RFCが必要」、セレクターと一致するタイプには「仕様が必要」を選択しました。これは、新しいセレクターと比較して、実装者が新しい証明書の使用法を正しく実装するために必要となる可能性がある詳細のためです。および一致するタイプ。"
    },
    {
      "indent": 0,
      "text": "7.1. TLSA RRtype",
      "section_title": true,
      "ja": "7.1. TLSA RRtype"
    },
    {
      "indent": 3,
      "text": "This document uses a new DNS RR type, TLSA, whose value (52) was allocated by IANA from the Resource Record (RR) TYPEs subregistry of the Domain Name System (DNS) Parameters registry.",
      "ja": "このドキュメントでは、新しいDNS RRタイプTLSAを使用します。TLSAの値（52）は、ドメインネームシステム（DNS）パラメーターレジストリのリソースレコード（RR）TYPEsサブレジストリからIANAによって割り当てられました。"
    },
    {
      "indent": 0,
      "text": "7.2. TLSA Certificate Usages",
      "section_title": true,
      "ja": "7.2. TLSA証明書の使用"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Certificate Usages\". The registry policy is \"RFC Required\". The initial entries in the registry are:",
      "ja": "このドキュメントは、新しいレジストリ「TLSA Certificate Usages」を作成します。レジストリポリシーは「RFC必須」です。レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        CA constraint                           RFC 6698\n1        Service certificate constraint          RFC 6698\n2        Trust anchor assertion                  RFC 6698\n3        Domain-issued certificate               RFC 6698\n4-254    Unassigned\n255      Private use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへのアプリケーションは、まだ割り当てられていない特定の値を要求できます。"
    },
    {
      "indent": 0,
      "text": "7.3. TLSA Selectors",
      "section_title": true,
      "ja": "7.3. TLSAセレクター"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Selectors\". The registry policy is \"Specification Required\". The initial entries in the registry are:",
      "ja": "このドキュメントは、新しいレジストリ「TLSA Selectors」を作成します。レジストリポリシーは「指定が必要」です。レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        Full certificate                        RFC 6698\n1        SubjectPublicKeyInfo                    RFC 6698\n2-254    Unassigned\n255      Private use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへのアプリケーションは、まだ割り当てられていない特定の値を要求できます。"
    },
    {
      "indent": 0,
      "text": "7.4. TLSA Matching Types",
      "section_title": true,
      "ja": "7.4. TLSAマッチングタイプ"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Matching Types\". The registry policy is \"Specification Required\". The initial entries in the registry are:",
      "ja": "このドキュメントは、「TLSAマッチングタイプ」という新しいレジストリを作成します。レジストリポリシーは「指定が必要」です。レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        No hash used                            RFC 6698\n1        SHA-256                                 RFC 6234\n2        SHA-512                                 RFC 6234\n3-254    Unassigned\n255      Private use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへのアプリケーションは、まだ割り当てられていない特定の値を要求できます。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security of the DNS RRtype described in this document relies on the security of DNSSEC to verify that the TLSA record has not been altered.",
      "ja": "このドキュメントで説明されているDNS RRtypeのセキュリティは、TLSAレコードが変更されていないことを確認するためにDNSSECのセキュリティに依存しています。"
    },
    {
      "indent": 3,
      "text": "A rogue DNS administrator who changes the A, AAAA, and/or TLSA records for a domain name can cause the client to go to an unauthorized server that will appear authorized, unless the client performs PKIX certification path validation and rejects the certificate. That administrator could probably get a certificate issued by some CA anyway, so this is not an additional threat.",
      "ja": "ドメイン名のA、AAAA、またはTLSAレコードを変更する悪意のあるDNS管理者は、クライアントがPKIX証明書パス検証を実行して証明書を拒否しない限り、クライアントが承認されたように見える不正なサーバーに移動する可能性があります。その管理者はおそらく何らかのCAから発行された証明書を取得する可能性があるため、これは追加の脅威ではありません。"
    },
    {
      "indent": 3,
      "text": "If the authentication mechanism for adding or changing TLSA data in a zone is weaker than the authentication mechanism for changing the A and/or AAAA records, a man-in-the-middle who can redirect traffic to his site may be able to impersonate the attacked host in TLS if he can use the weaker authentication mechanism. A better design for authenticating DNS would be to have the same level of authentication used for all DNS additions and changes for a particular domain name.",
      "ja": "ゾーンのTLSAデータを追加または変更するための認証メカニズムが、Aおよび/またはAAAAレコードを変更するための認証メカニズムよりも弱い場合、サイトにトラフィックをリダイレクトできる中間者が偽装できる可能性があります。より弱い認証メカニズムを使用できる場合、TLSで攻撃されたホスト。 DNSを認証するためのより良い設計は、特定のドメイン名のすべてのDNSの追加と変更に同じレベルの認証を使用することです。"
    },
    {
      "indent": 3,
      "text": "Secure Socket Layer (SSL) proxies can sometimes act as a man-in-the-middle for TLS clients. In these scenarios, the clients add a new trust anchor whose private key is kept on the SSL proxy; the proxy intercepts TLS requests, creates a new TLS session with the intended host, and sets up a TLS session with the client using a certificate that chains to the trust anchor installed in the client by the proxy. In such environments, using TLSA records will prevent the SSL proxy from functioning as expected because the TLS client will get a certificate association from the DNS that will not match the certificate that the SSL proxy uses with the client. The client, seeing the proxy's new certificate for the supposed destination, will not set up a TLS session.",
      "ja": "Secure Socket Layer（SSL）プロキシは、TLSクライアントの中間者として機能する場合があります。これらのシナリオでは、クライアントは、プライベートキーがSSLプロキシに保持される新しいトラストアンカーを追加します。プロキシはTLS要求をインターセプトし、目的のホストとの新しいTLSセッションを作成し、プロキシによってクライアントにインストールされたトラストアンカーにチェーンする証明書を使用してクライアントとのTLSセッションをセットアップします。そのような環境では、TLSAレコードを使用すると、SSLプロキシがクライアントで使用する証明書と一致しない証明書の関連付けをDNSから取得するため、TLSプロキシが期待どおりに機能しなくなります。クライアントは、想定される宛先に対するプロキシの新しい証明書を確認しても、TLSセッションをセットアップしません。"
    },
    {
      "indent": 3,
      "text": "Client treatment of any information included in the trust anchor is a matter of local policy. This specification does not mandate that such information be inspected or validated by the server's domain name administrator.",
      "ja": "トラストアンカーに含まれる情報のクライアントの扱いは、ローカルポリシーの問題です。この仕様では、サーバーのドメイン名管理者がこのような情報を検査または検証することを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "If a server's certificate is revoked, or if an intermediate CA in a chain between the server and a trust anchor has its certificate revoked, a TLSA record with a certificate usage of 2 that matches the revoked certificate would in essence override the revocation because the client would treat that revoked certificate as a trust anchor and thus not check its revocation status. Because of this, domain administrators need to be responsible for being sure that the keys or certificates used in TLSA records with a certificate usage of 2 are in fact able to be used as reliable trust anchors.",
      "ja": "サーバーの証明書が取り消された場合、またはサーバーとトラストアンカーの間のチェーンにある中間CAの証明書が取り消された場合、取り消された証明書と一致する証明書の使用法が2のTLSAレコードは、クライアントが失効した証明書をトラストアンカーとして扱い、失効ステータスをチェックしません。このため、ドメイン管理者は、証明書の使用法が2のTLSAレコードで使用されるキーまたは証明書が、信頼できるトラストアンカーとして実際に使用できることを確認する責任があります。"
    },
    {
      "indent": 3,
      "text": "Certificates that are delivered in TLSA with certificate usage 2 fundamentally change the way the TLS server's end entity certificate is evaluated. For example, the server's certificate might chain to an existing CA through an intermediate CA that has certain policy restrictions, and the certificate would not pass those restrictions and thus normally be rejected. That intermediate CA could issue itself a new certificate without the policy restrictions and tell its customers to use that certificate with certificate usage 2. This in essence allows an intermediate CA to become a trust anchor for certificates that the end user might have expected to chain to an existing trust anchor.",
      "ja": "証明書の使用法2を使用してTLSAで配信される証明書は、TLSサーバーのエンドエンティティ証明書の評価方法を根本的に変更します。たとえば、サーバーの証明書は、特定のポリシー制限がある中間CAを介して既存のCAにチェーンし、証明書はそれらの制限を通過しないため、通常は拒否されます。その中間CAは、ポリシー制限なしで自身に新しい証明書を発行し、その証明書を使用する証明書を顧客に通知することができます。2。これにより、本質的に、中間CAは、エンドユーザーがチェーンすることを期待していた証明書の信頼アンカーになることができます。既存のトラストアンカー。"
    },
    {
      "indent": 3,
      "text": "If an administrator wishes to stop using a TLSA record, the administrator can simply remove it from the DNS. Normal clients will stop using the TLSA record after the TTL has expired. Replay attacks against the TLSA record are not possible after the expiration date on the RRsig of the TLSA record that was removed.",
      "ja": "管理者がTLSAレコードの使用を停止したい場合は、管理者がDNSから削除するだけです。通常のクライアントは、TTLの有効期限が切れると、TLSAレコードの使用を停止します。削除されたTLSAレコードのRRsigの有効期限日以降は、TLSAレコードに対するリプレイ攻撃は不可能です。"
    },
    {
      "indent": 3,
      "text": "Generators of TLSA records should be aware that the client's full trust of a certificate association retrieved from a TLSA record may be a matter of local policy. While such trust is limited to the specific domain name, protocol, and port for which the TLSA query was made, local policy may decline to accept the certificate (for reasons such as weak cryptography), as is also the case with PKIX trust anchors.",
      "ja": "TLSAレコードの生成者は、TLSAレコードから取得した証明書の関連付けに対するクライアントの完全な信頼がローカルポリシーの問題である可能性があることに注意する必要があります。このような信頼は、TLSAクエリが実行された特定のドメイン名、プロトコル、およびポートに限定されますが、PKIXトラストアンカーの場合と同様に、ローカルポリシーは（弱い暗号などの理由で）証明書の受け入れを拒否する場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Comparing DANE to Public CAs",
      "section_title": true,
      "ja": "8.1. DANEとパブリックCAの比較"
    },
    {
      "indent": 3,
      "text": "As stated above, the security of the DNS RRtype described in this document relies on the security of DNSSEC to verify that the TLSA record has not been altered. This section describes where the security of public CAs and the security of TLSA are similar and different. This section applies equally to other security-related DNS RRtypes such as keys for IPsec and SSH.",
      "ja": "上記のように、このドキュメントで説明されているDNS RRtypeのセキュリティは、TLSAレコードが変更されていないことを確認するためにDNSSECのセキュリティに依存しています。このセクションでは、パブリックCAのセキュリティとTLSAのセキュリティが似ている点と異なる点について説明します。このセクションは、IPsecやSSHのキーなど、他のセキュリティ関連のDNS RRtypeにも同様に適用されます。"
    },
    {
      "indent": 3,
      "text": "DNSSEC forms certificates (the binding of an identity to a key) by combining a DNSKEY, DS, or DLV resource record with an associated RRSIG record. These records then form a signing chain extending from the client's trust anchors to the RR of interest.",
      "ja": "DNSSECは、DNSKEY、DS、またはDLVリソースレコードを関連するRRSIGレコードと組み合わせることにより、証明書（IDとキーのバインド）を形成します。これらのレコードは、クライアントのトラストアンカーから対象のRRに至る署名チェーンを形成します。"
    },
    {
      "indent": 3,
      "text": "Although the DNSSEC protocol does not enforce it, DNSKEYs are often marked with a SEP flag indicating whether the key is a Zone Signing Key (ZSK) or a Key Signing Key (KSK). ZSKs protect records in the zone (including DS and DLV records), and KSKs protect ZSK DNSKEY records. This allows KSKs to be stored offline.",
      "ja": "DNSSECプロト​​コルはそれを強制しませんが、DNSKEYは、キーがゾーン署名キー（ZSK）であるかキー署名キー（KSK）であるかを示すSEPフラグでマークされることがよくあります。 ZSKはゾーン内のレコード（DSおよびDLVレコードを含む）を保護し、KSKはZSK DNSKEYレコードを保護します。これにより、KSKをオフラインで保存できます。"
    },
    {
      "indent": 3,
      "text": "The TLSA RRtype allows keys from the DNSSEC PKI hierarchy to authenticate keys wrapped in PKIX certificates for a particular host name, protocol, and port.",
      "ja": "TLSA RRtypeを使用すると、DNSSEC PKI階層のキーが、特定のホスト名、プロトコル、およびポートのPKIX証明書にラップされたキーを認証できます。"
    },
    {
      "indent": 3,
      "text": "With the exception of the DLV RRtype, all of these certificates constrain the keys they identify to names that are within the zone signing the certificate. In order for a domain's DLV resource records to be honored, the domain must be configured as a DLV domain, and the domain's DNSKEYs must be configured as trust anchors or be authentic [RFC5074].",
      "ja": "DLV RRtypeを除いて、これらの証明書はすべて、それらが識別する鍵を、証明書に署名するゾーン内にある名前に制約します。ドメインのDLVリソースレコードを尊重するには、ドメインをDLVドメインとして構成し、ドメインのDNSKEYをトラストアンカーとして構成するか、本物である必要があります[RFC5074]。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Risk of Key Compromise",
      "section_title": true,
      "ja": "8.1.1. 主要な侵害のリスク"
    },
    {
      "indent": 3,
      "text": "The risk that a given certificate that has a valid signing chain is fake is related to the number of keys that can contribute to the validation of the certificate, the quality of protection each private key receives, the value of each key to an attacker, and the value of falsifying the certificate.",
      "ja": "有効な署名チェーンを持つ特定の証明書が偽物であるリスクは、証明書の検証に寄与できる鍵の数、各秘密鍵が受ける保護の品質、攻撃者に対する各鍵の値、および証明書を改ざんする価値。"
    },
    {
      "indent": 3,
      "text": "DNSSEC allows any set of domains to be configured as trust anchors and/or DLVs, but most clients are likely to use the root zone as their only trust anchor. Also, because a given DNSKEY can only sign resource records for that zone, the number of private keys capable of compromising a given TLSA resource record is limited to the number of zones between the TLSA resource record and the nearest trust anchor, plus any configured DLV domains. Typically, this will be six keys, half of which will be KSKs.",
      "ja": "DNSSECでは、任意のドメインセットをトラストアンカーやDLVとして構成できますが、ほとんどのクライアントはルートゾーンを唯一のトラストアンカーとして使用する可能性があります。また、特定のDNSKEYはそのゾーンのリソースレコードにのみ署名できるため、特定のTLSAリソースレコードを危険にさらすことができる秘密鍵の数は、TLSAリソースレコードと最も近いトラストアンカーと構成されたDLVの間のゾーンの数に制限されます。ドメイン。通常、これは6つのキーで、その半分はKSKです。"
    },
    {
      "indent": 3,
      "text": "PKIX only describes how to validate a certificate based on a client-chosen set of trust anchors, but says nothing about how many trust anchors to use or how they should be constrained. As currently deployed, most PKIX clients use a large number of trust anchors provided with the client or operating system software. These trust anchors are selected carefully, but with a desire for broad interoperability. The trust anchors and CA certificates for public CAs rarely have name constraints applied.",
      "ja": "PKIXは、クライアントが選択したトラストアンカーのセットに基づいて証明書を検証する方法についてのみ説明しますが、使用するトラストアンカーの数や、それらをどのように制約するかについては何も述べていません。現在展開されているように、ほとんどのPKIXクライアントは、クライアントまたはオペレーティングシステムソフトウェアで提供される多数のトラストアンカーを使用します。これらのトラストアンカーは慎重に選択されていますが、幅広い相互運用性を望んでいます。パブリックCAのトラストアンカーとCA証明書には、名前の制約が適用されることはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "A combination of technical protections, process controls, and personnel experience contribute to the quality of security that keys receive.",
      "ja": "技術的な保護、プロセス制御、および担当者の経験の組み合わせにより、キーが受け取るセキュリティの品質が向上します。"
    },
    {
      "indent": 3,
      "text": "o The security surrounding DNSSEC DNSKEYs varies significantly. The KSK/ZSK split allows the KSK to be stored offline and protected more carefully than the ZSK, but not all domains do so. The security applied to a zone's DNSKEYs should be proportional to the value of the domain, but that is difficult to estimate. For example, the root DNSKEY has protections and controls comparable to or exceeding those of public CAs. On the other end of the spectrum, small domains might provide no more protection to their keys than they do to their other data.",
      "ja": "o DNSSEC DNSKEYを取り巻くセキュリティは大きく異なります。 KSK / ZSK分割により、KSKをオフラインで保存し、ZSKよりも慎重に保護することができますが、すべてのドメインがそうするわけではありません。ゾーンのDNSKEYに適用されるセキュリティは、ドメインの値に比例する必要がありますが、推定することは困難です。たとえば、ルートDNSKEYには、パブリックCAと同等以上の保護と制御があります。スペクトルの反対側では、小さなドメインは、他のデータに対するよりも、キーに対する保護を提供しない可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The security surrounding public CAs also varies. However, due to financial incentives and standards imposed by clients for acceptance into their trust anchor stores, CAs generally employ security experts and protect their keys carefully, though highly public compromises have occurred.",
      "ja": "o パブリックCAを取り巻くセキュリティもさまざまです。ただし、クライアントがトラストアンカーストアに受け入れるために課した金銭的インセンティブと標準により、CAは一般にセキュリティの専門家を雇用し、キーを慎重に保護しますが、非常に公的な侵害が発生しています。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Impact of Key Compromise",
      "section_title": true,
      "ja": "8.1.2. 主要な侵害の影響"
    },
    {
      "indent": 3,
      "text": "The impact of a key compromise differs significantly between the two models.",
      "ja": "重要な妥協の影響は、2つのモデル間で大きく異なります。"
    },
    {
      "indent": 3,
      "text": "o DNSKEYs are inherently limited in what they can sign, so a compromise of the DNSKEY for \"example.com\" provides no avenue of attack against \"example.org\". Even the impact of a compromise of .com's DNSKEY, while considerable, would be limited to .com domains. Only the compromise of the root DNSKEY would have the equivalent impact of an unconstrained public CA.",
      "ja": "o DNSKEYは本質的に署名できるものに制限があるため、「example.com」のDNSKEYの侵害は「example.org」に対する攻撃の手段を提供しません。 .comのDNSKEYの侵害の影響でさえ、かなりのものですが、.comドメインに限定されます。ルートDNSKEYの侵害のみが、制約のないパブリックCAと同等の影響を及ぼします。"
    },
    {
      "indent": 3,
      "text": "o Public CAs are not typically constrained in what names they can sign, and therefore a compromise of even one CA allows the attacker to generate a certificate for any name in the DNS. A domain holder can get a certificate from any willing CA, or even multiple CAs simultaneously, making it impossible for a client to determine whether the certificate it is validating is legitimate or fraudulent.",
      "ja": "o パブリックCAは通常、署名できる名前に制約がないため、1つのCAの侵害でも、攻撃者はDNS内の任意の名前の証明書を生成できます。ドメイン所有者は、任意のCAまたは複数のCAから同時に証明書を取得できるため、クライアントが検証している証明書が正当であるか不正であるかを判別することはできません。"
    },
    {
      "indent": 3,
      "text": "Because a TLSA certificate association is constrained to its associated name, protocol, and port, the PKIX certificate is similarly constrained, even if its public CAs signing the certificate (if any) are not.",
      "ja": "TLSA証明書の関連付けは、関連付けられた名前、プロトコル、およびポートに制限されているため、PKIX証明書は、証明書に署名しているパブリックCA（存在する場合）に制約がない場合でも、同様に制約されます。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Detection of Key Compromise",
      "section_title": true,
      "ja": "8.1.3. キーの侵害の検出"
    },
    {
      "indent": 3,
      "text": "If a key is compromised, rapid and reliable detection is important in order to limit the impact of the compromise. In this regard, neither model prevents an attacker from near-invisibly attacking their victim, provided that the necessary keys are compromised.",
      "ja": "キーが侵害された場合、侵害の影響を制限するために、迅速で信頼性の高い検出が重要です。この点で、必要なキーが危険にさらされている場合、どちらのモデルも攻撃者が目に見えない形で被害者を攻撃することを防ぎます。"
    },
    {
      "indent": 3,
      "text": "If a public CA is compromised, only the victim will see the fraudulent certificate, as there is typically no publicly accessible directory of all the certificates issued by a CA that can be inspected. DNS resource records are typically published publicly. However, the attacker could also allow the uncompromised records to be published to the Internet as usual but provide a compromised DNS view to the victim to achieve the same effect.",
      "ja": "公開CAが危険にさらされた場合、不正な証明書が表示されるのは被害者だけです。これは、一般に、CAが発行するすべての証明書を公開してアクセスできるディレクトリはないためです。 DNSリソースレコードは通常、公開されます。ただし、攻撃者は、通常どおり侵害されていないレコードをインターネットに公開することを許可し、被害者に侵害されたDNSビューを提供して同じ効果を得る可能性もあります。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Spoofing Hostnames",
      "section_title": true,
      "ja": "8.1.4. ホスト名のなりすまし"
    },
    {
      "indent": 3,
      "text": "Some CAs implement technical controls to ensure that certificates are not issued to domains with names similar to domains that are popular and prone to attack. Of course, an attacker can attempt to circumvent this restriction by finding a CA willing to issue the certificate anyway. However, by using DNSSEC and TLSA, the attacker can circumvent this check completely.",
      "ja": "一部のCAは、人気があり攻撃を受​​けやすいドメインに類似した名前のドメインに証明書が発行されないようにするための技術的制御を実装しています。もちろん、攻撃者はとにかく証明書を発行する意思のあるCAを見つけることにより、この制限を回避しようとする可能性があります。ただし、DNSSECおよびTLSAを使用することにより、攻撃者はこのチェックを完全に回避できます。"
    },
    {
      "indent": 0,
      "text": "8.2. DNS Caching",
      "section_title": true,
      "ja": "8.2. DNSキャッシング"
    },
    {
      "indent": 3,
      "text": "Implementations of this protocol rely heavily on the DNS, and are thus prone to security attacks based on the deliberate mis-association of TLSA records and DNS names. Implementations need to be cautious in assuming the continuing validity of an association between a TLSA record and a DNS name.",
      "ja": "このプロトコルの実装はDNSに大きく依存しているため、TLSAレコードとDNS名の意図的な誤関連付けに基づいてセキュリティ攻撃を受ける傾向があります。実装は、TLSAレコードとDNS名の間の関連付けの継続的な有効性を想定する際に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, implementations SHOULD rely on their DNS resolver for confirmation of an association between a TLSA record and a DNS name, rather than caching the result of previous domain name lookups. Many platforms already can cache domain name lookups locally when appropriate, and they SHOULD be configured to do so. It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information reported by the DNS makes it likely that the cached information will remain useful.",
      "ja": "特に、実装は、以前のドメイン名ルックアップの結果をキャッシュするのではなく、TLSAレコードとDNS名の間の関連付けの確認をDNSリゾルバーに依存する必要があります（SHOULD）。多くのプラットフォームはすでに適切な場合にドメイン名のルックアップをローカルにキャッシュすることができ、そのように構成する必要があります（SHOULD）。ただし、これらのルックアップがキャッシュされるのは適切ですが、DNSによって報告されたTTL（Time To Live）情報により、キャッシュされた情報が引き続き有用である可能性が高い場合にのみです。"
    },
    {
      "indent": 3,
      "text": "If implementations cache the results of domain name lookups in order to achieve a performance improvement, they MUST observe the TTL information reported by DNS. Implementations that fail to follow this rule could be spoofed or have access denied when a previously accessed server's TLSA record changes, such as during a certificate rollover.",
      "ja": "実装がドメイン名ルックアップの結果をキャッシュしてパフォーマンスを向上させる場合、DNSから報告されたTTL情報を監視する必要があります。このルールに従わない実装は、証明書のロールオーバー中など、以前にアクセスされたサーバーのTLSAレコードが変更されると、なりすましまたはアクセス拒否が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.3. External DNSSEC Validators",
      "section_title": true,
      "ja": "8.3. 外部DNSSECバリデーター"
    },
    {
      "indent": 3,
      "text": "Due to a lack of DNSSEC support in the most commonly deployed stub resolvers today, some ISPs have begun checking DNSSEC in the recursive resolvers they provide to their customers, setting the Authentic Data (AD) flag as appropriate. DNSSEC-aware clients could use that data, ignoring the fact that the DNSSEC data has been validated externally. Because there is typically no authentication of the recursive resolver or integrity protection of the data and AD flag between the client and the recursive resolver, this can be trivially spoofed by an attacker.",
      "ja": "現在最も一般的に展開されているスタブリゾルバーではDNSSECサポートが不足しているため、一部のISPは、顧客に提供する再帰リゾルバーでDNSSECのチェックを開始し、Authentic Data（AD）フラグを適切に設定しています。 DNSSEC対応のクライアントは、DNSSECデータが外部で検証されているという事実を無視して、そのデータを使用できます。通常、再帰リゾルバの認証や、データとADフラグの整合性保護はクライアントと再帰リゾルバの間に存在しないため、攻撃者が簡単になりすますことができます。"
    },
    {
      "indent": 3,
      "text": "However, even with secure communications between a host and the external validating resolver, there is a risk that the external validator could become compromised. Nothing prevents a compromised external DNSSEC validator from claiming that all the records it provides are secure, even if the data is falsified, unless the client checks the DNSSEC data itself (rendering the external validator unnecessary).",
      "ja": "ただし、ホストと外部の検証リゾルバーの間の通信が安全であっても、外部のバリデーターが危険にさらされる可能性があります。データが改ざんされている場合でも、クライアントがDNSSECデータ自体をチェックしない限り（外部のバリデーターをレンダリングする必要がない限り）、侵害された外部DNSSECバリデーターが提供するすべてのレコードが安全であると主張することを妨げるものはありません。"
    },
    {
      "indent": 3,
      "text": "For this reason, DNSSEC validation is best performed on-host, even when a secure path to an external validator is available.",
      "ja": "このため、外部バリデーターへの安全なパスが利用可能な場合でも、DNSSEC検証はホスト上で実行するのが最適です。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "Many of the ideas in this document have been discussed over many years. More recently, the ideas have been discussed by the authors and others in a more focused fashion. In particular, some of the ideas and words here originated with Paul Vixie, Dan Kaminsky, Jeff Hodges, Phillip Hallam-Baker, Simon Josefsson, Warren Kumari, Adam Langley, Ben Laurie, Ilari Liusvaara, Ondrej Mikle, Scott Schmit, Ondrej Sury, Richard Barnes, Jim Schaad, Stephen Farrell, Suresh Krishnaswamy, Peter Palfrader, Pieter Lexis, Wouter Wijngaards, John Gilmore, and Murray Kucherawy.",
      "ja": "このドキュメントのアイデアの多くは、長年にわたって議論されてきました。最近では、アイデアは著者や他の人々によってより焦点を絞った方法で議論されています。特に、ここでのアイデアや言葉の一部は、Paul Vixie、Dan Kaminsky、Jeff Hodges、Phillip Hallam-Baker、Simon Josefsson、Warren Kumari、Adam Langley、Ben Laurie、Ilari Liusvaara、Ondrej Mikle、Scott Schmit、Ondrej Sury、 Richard Barnes、Jim Schaad、Stephen Farrell、Suresh Krishnaswamy、Peter Palfrader、Pieter Lexis、Wouter Wijngaards、John Gilmore、Murray Kucherawy。"
    },
    {
      "indent": 3,
      "text": "This document has also been greatly helped by many active participants of the DANE Working Group.",
      "ja": "このドキュメントは、DANEワーキンググループの多くのアクティブな参加者からも大いに役立っています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名-実装と仕様」、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033] Arends、R.、Austein、R.、Larson、M.、Massey、D。、およびS. Rose、「DNSセキュリティの概要と要件」、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005.",
      "ja": "[RFC4034] Arends、R.、Austein、R.、Larson、M.、Massey、D。、およびS. Rose、「DNS Security Extensionsのリソースレコード」、RFC 4034、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4035] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Protocol Modifications for the DNS Security Extensions\", RFC 4035, March 2005.",
      "ja": "[RFC4035] Arends、R.、Austein、R.、Larson、M.、Massey、D。、およびS. Rose、「DNSセキュリティ拡張機能のプロトコル変更」、RFC 4035、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, March 2011.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, January 2012.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、2012年1月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC0952] Harrenstien, K., Stahl, M., and E. Feinler, \"DoD Internet host table specification\", RFC 952, October 1985.",
      "ja": "[RFC0952] Harrenstien、K.、Stahl、M。、およびE. Feinler、「DoD Internet host table specification」、RFC 952、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818] Rescorla、E。、「HTTP over TLS」、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2845] Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B. Wellington, \"Secret Key Transaction Authentication for DNS (TSIG)\", RFC 2845, May 2000.",
      "ja": "[RFC2845] Vixie、P.、Gudmundsson、O.、Eastlake 3rd、D。、およびB. Wellington、「DNSの秘密鍵トランザクション認証（TSIG）」、RFC 2845、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2931] Eastlake 3rd, D., \"DNS Request and Transaction Signatures ( SIG(0)s)\", RFC 2931, September 2000.",
      "ja": "[RFC2931] Eastlake 3rd、D。、「DNS Request and Transaction Signatures（SIG（0）s）」、RFC 2931、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4025] Richardson, M., \"A Method for Storing IPsec Keying Material in DNS\", RFC 4025, March 2005.",
      "ja": "[RFC4025] Richardson、M。、「A Method for Storing IPsec Keying Material in DNS」、RFC 4025、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4255] Schlyter, J. and W. Griffin, \"Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints\", RFC 4255, January 2006.",
      "ja": "[RFC4255] Schlyter、J。およびW. Griffin、「DNSを使用したセキュアシェル（SSH）キーフィンガープリントの安全な公開」、RFC 4255、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4641] Kolkman, O. and R. Gieben, \"DNSSEC Operational Practices\", RFC 4641, September 2006.",
      "ja": "[RFC4641] Kolkman、O。およびR. Gieben、「DNSSEC Operational Practices」、RFC 4641、2006年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5074] Weiler, S., \"DNSSEC Lookaside Validation (DLV)\", RFC 5074, November 2007.",
      "ja": "[RFC5074] Weiler、S。、「DNSSEC Lookaside Validation（DLV）」、RFC 5074、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, August 2010.",
      "ja": "[RFC5890] Klensin、J。、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、2010年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6071] Frankel, S. and S. Krishnan, \"IP Security (IPsec) and Internet Key Exchange (IKE) Document Roadmap\", RFC 6071, February 2011.",
      "ja": "[RFC6071]フランケルS.およびS.クリシュナン、「IP Security（IPsec）and Internet Key Exchange（IKE）Document Roadmap」、RFC 6071、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6376] Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed., \"DomainKeys Identified Mail (DKIM) Signatures\", RFC 6376, September 2011.",
      "ja": "[RFC6376] Crocker、D。、編、Hansen、T。、編、およびM. Kucherawy、編、「DomainKeys Identified Mail（DKIM）Signatures」、RFC 6376、2011年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6394] Barnes, R., \"Use Cases and Requirements for DNS-Based Authentication of Named Entities (DANE)\", RFC 6394, October 2011.",
      "ja": "[RFC6394] Barnes、R。、「名前付きエンティティのDNSベース認証（DANE）の使用例と要件」、RFC 6394、2011年10月。"
    },
    {
      "indent": 3,
      "text": "[X.690] \"Recommendation ITU-T X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", July 2002.",
      "ja": "[X.690]「推奨ITU-T X.690（2002）| ISO / IEC 8825-1：2002、情報技術-ASN.1エンコードルール：基本エンコードルール（BER）、正規エンコードルール（CER）の仕様およびDistinguished Encoding Rules（DER）」、2002年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Operational Considerations for Deploying TLSA Records",
      "section_title": true,
      "ja": "付録A. TLSAレコードの展開に関する運用上の考慮事項"
    },
    {
      "indent": 0,
      "text": "A.1. Creating TLSA Records",
      "section_title": true,
      "ja": "A.1. TLSAレコードの作成"
    },
    {
      "indent": 3,
      "text": "When creating TLSA records, care must be taken to avoid misconfigurations. Section 4 of this document states that a TLSA RRSet whose validation state is secure MUST be used. This means that the existence of such a RRSet effectively disables other forms of name and path validation. A misconfigured TLSA RRSet will effectively disable access to the TLS server for all conforming clients, and this document does not provide any means of making a gradual transition to using TLSA.",
      "ja": "TLSAレコードを作成するときは、設定ミスを回避するように注意する必要があります。このドキュメントのセクション4では、検証状態が安全なTLSA RRSetを使用する必要があると述べています。つまり、そのようなRRSetが存在すると、他の形式の名前とパスの検証が事実上無効になります。誤って構成されたTLSA RRSetは、準拠するすべてのクライアントのTLSサーバーへのアクセスを事実上無効にします。このドキュメントでは、TLSAの使用に段階的に移行する方法は提供されていません。"
    },
    {
      "indent": 3,
      "text": "When creating TLSA records with certificate usage 0 (CA certificate) or usage 2 (trust anchor), one needs to understand the implications when choosing between selector type 0 (Full certificate) and 1 (SubjectPublicKeyInfo). A careful choice is required because different methods for building trust chains are used by different TLS clients. The following outlines the cases that one ought to be aware of and discusses the implications of the choice of selector type.",
      "ja": "証明書の使用法0（CA証明書）または使用法2（トラストアンカー）でTLSAレコードを作成する場合、セレクタータイプ0（完全な証明書）と1（SubjectPublicKeyInfo）のどちらを選択するかについての理解を深める必要があります。信頼チェーンを構築するためのさまざまな方法がさまざまなTLSクライアントによって使用されるため、慎重な選択が必要です。以下に、注意すべきケースの概要を示し、セレクタータイプの選択の影響について説明します。"
    },
    {
      "indent": 3,
      "text": "Certificate usage 2 is not affected by the different types of chain building when the end entity certificate is the same as the trust anchor certificate.",
      "ja": "証明書の使用法2は、エンドエンティティ証明書がトラストアンカー証明書と同じである場合、さまざまな種類のチェーン構築の影響を受けません。"
    },
    {
      "indent": 0,
      "text": "A.1.1. Ambiguities and Corner Cases When TLS Clients Build Trust Chains",
      "section_title": true,
      "ja": "A.1.1. TLSクライアントが信頼チェーンを構築する際のあいまいさとコーナーケース"
    },
    {
      "indent": 3,
      "text": "TLS clients can implement their own chain-building code rather than rely on the chain presented by the TLS server. This means that, except for the end entity certificate, any certificate presented in the suggested chain might or might not be present in the final chain built by the client.",
      "ja": "TLSクライアントは、TLSサーバーによって提供されるチェーンに依存するのではなく、独自のチェーン構築コードを実装できます。これは、エンドエンティティ証明書を除いて、提案されたチェーンで提示される証明書は、クライアントによって構築された最終的なチェーンに存在する場合と存在しない場合があります。"
    },
    {
      "indent": 3,
      "text": "Certificates that the client can use to replace certificates from the original chain include:",
      "ja": "クライアントが元のチェーンの証明書を置き換えるために使用できる証明書には、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o Client's trust anchors",
      "ja": "o クライアントのトラストアンカー"
    },
    {
      "indent": 3,
      "text": "o Certificates cached locally",
      "ja": "o ローカルにキャッシュされた証明書"
    },
    {
      "indent": 3,
      "text": "o Certificates retrieved from a URI listed in an Authority Information Access X.509v3 extension",
      "ja": "o Authority Information Access X.509v3拡張にリストされているURIから取得した証明書"
    },
    {
      "indent": 0,
      "text": " CAs frequently reissue certificates with different validity periods, signature algorithms (such as a different hash algorithm in the signature algorithm), CA key pairs (such as for a cross-certificate), or PKIX extensions where the public key and subject remain the same. These reissued certificates are the certificates that the TLS client can use in place of an original certificate.",
      "ja": "CAは、有効期間が異なる証明書、署名アルゴリズム（署名アルゴリズム内の異なるハッシュアルゴリズムなど）、CA鍵ペア（相互証明書など）、または公開鍵とサブジェクトが同じままであるPKIX拡張を頻繁に再発行します。これらの再発行された証明書は、TLSクライアントが元の証明書の代わりに使用できる証明書です。"
    },
    {
      "indent": 3,
      "text": "Clients are known to exchange or remove certificates that could cause TLSA certificate associations that rely on the full certificate to fail. For example:",
      "ja": "クライアントは、完全な証明書に依存するTLSA証明書の関連付けが失敗する原因となる証明書を交換または削除することがわかっています。例えば："
    },
    {
      "indent": 3,
      "text": "o The client considers the signature algorithm of a certificate to no longer be sufficiently secure.",
      "ja": "o クライアントは、証明書の署名アルゴリズムが十分に安全ではなくなったと見なします。"
    },
    {
      "indent": 3,
      "text": "o The client might not have an associated root certificate in its trust store and instead uses a cross-certificate with an identical subject and public key.",
      "ja": "o クライアントのトラストストアにルート証明書が関連付けられていない可能性があり、代わりに、同一のサブジェクトと公開鍵を持つクロス証明書を使用します。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Choosing a Selector Type",
      "section_title": true,
      "ja": "A.1.2. セレクタータイプの選択"
    },
    {
      "indent": 3,
      "text": "In this section, \"false-negative failure\" means that a client will not accept the TLSA certificate association for a certificate designated by the DNS administrator. Also, \"false-positive acceptance\" means that the client accepts a TLSA association for a certificate that is not designated by the DNS administrator.",
      "ja": "このセクションでは、 \"false-negative failure\"は、クライアントがDNS管理者によって指定された証明書のTLSA証明書の関連付けを受け入れないことを意味します。また、「誤検知」とは、クライアントがDNS管理者によって指定されていない証明書のTLSAアソシエーションを受け入れることを意味します。"
    },
    {
      "indent": 0,
      "text": "A.1.2.1. Selector Type 0 (Full Certificate)",
      "section_title": true,
      "ja": "A.1.2.1. セレクタータイプ0（完全な証明書）"
    },
    {
      "indent": 3,
      "text": "The \"Full certificate\" selector provides the most precise specification of a TLSA certificate association, capturing all fields of the PKIX certificate. For a DNS administrator, the best course to avoid false-negative failures in the client when using this selector is:",
      "ja": "「完全証明書」セレクターは、TLSA証明書関連付けの最も正確な仕様を提供し、PKIX証明書のすべてのフィールドを取り込みます。 DNS管理者にとって、このセレクターを使用するときにクライアントでの偽陰性の失敗を回避する最良の方法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. If a CA issued a replacement certificate, don't associate to CA certificates that have a signature algorithm with a hash that is considered weak by local policy.",
      "ja": "1. CAが代わりの証明書を発行した場合は、ローカルポリシーによって脆弱であると見なされるハッシュを持つ署名アルゴリズムを持つCA証明書に関連付けないでください。"
    },
    {
      "indent": 3,
      "text": "2. Determine how common client applications process the TLSA certificate association using a fresh client installation -- that is, with the local certificate cache empty.",
      "ja": "2. 新しいクライアントインストールを使用して、つまりローカル証明書キャッシュを空にして、一般的なクライアントアプリケーションがTLSA証明書の関連付けを処理する方法を決定します。"
    },
    {
      "indent": 0,
      "text": "A.1.2.2. Selector Type 1 (SubjectPublicKeyInfo)",
      "section_title": true,
      "ja": "A.1.2.2. セレクタータイプ1（SubjectPublicKeyInfo）"
    },
    {
      "indent": 3,
      "text": "A SubjectPublicKeyInfo selector gives greater flexibility in avoiding some false-negative failures caused by trust-chain-building algorithms used in clients.",
      "ja": "SubjectPublicKeyInfoセレクターは、クライアントで使用される信頼チェーン構築アルゴリズムによって引き起こされるいくつかの偽陰性の失敗を回避する際の柔軟性を高めます。"
    },
    {
      "indent": 3,
      "text": "One specific use case ought to be noted: creating a TLSA certificate association to CA certificate I1 that directly signed end entity certificate S1 of the server. The case can be illustrated by the following graph:",
      "ja": "サーバーのエンドエンティティ証明書S1に直接署名したCA証明書I1へのTLSA証明書の関連付けを作成する特定の使用例に注意する必要があります。このケースは、次のグラフで説明できます。"
    },
    {
      "indent": 3,
      "text": "        +----+                      +----+\n        | I1 |                      | I2 |\n        +----+                      +----+\n           |                           |\n           v                           v\n        +----+                      +----+\n        | S1 |                      | S1 |\n        +----+                      +----+\nCertificate chain sent by    A different validation path\nserver in TLS handshake      built by the TLS client",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "I2 is a reissued version of CA certificate I1 (that is, it has a different hash in its signature algorithm).",
      "ja": "I2は、CA証明書I1の再発行されたバージョンです（つまり、署名アルゴリズムに別のハッシュが含まれています）。"
    },
    {
      "indent": 3,
      "text": "In the above scenario, both certificates I1 and I2 that sign S1 need to have identical SubjectPublicKeyInfo fields because the key used to sign S1 is fixed. An association to SubjectPublicKeyInfo (selector type 1) will always succeed in such a case, but an association with a full certificate (selector type 0) might not work due to a false-negative failure.",
      "ja": "上記のシナリオでは、S1に署名するために使用される鍵が固定されているため、S1に署名する証明書I1とI2の両方が同一のSubjectPublicKeyInfoフィールドを持つ必要があります。このような場合、SubjectPublicKeyInfo（セレクタータイプ1）への関連付けは常に成功しますが、完全な証明書（セレクタータイプ0）との関連付けは、偽陰性の失敗のために機能しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The attack surface is a bit broader compared to the \"Full certificate\" selector: the DNS administrator might unintentionally specify an association that would lead to false-positive acceptance.",
      "ja": "攻撃面は、「完全な証明書」セレクターと比較して少し広いです。DNS管理者は、誤検知の受け入れにつながる関連付けを誤って指定する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The administrator must know or trust that the CA does not engage in bad practices, such as not sharing the key of I1 for unrelated CA certificates (which would lead to trust-chain redirection). If possible, the administrator ought to review all CA certificates that have the same SubjectPublicKeyInfo field.",
      "ja": "o 管理者は、CAが関連のないCA証明書のI1のキーを共有しない（信頼チェーンのリダイレクトにつながる）などの悪い慣行に関与していないことを知っているか、信頼している必要があります。可能であれば、管理者は同じSubjectPublicKeyInfoフィールドを持つすべてのCA証明書を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The administrator ought to understand whether some PKIX extension may adversely affect security of the association. If possible, administrators ought to review all CA certificates that share the SubjectPublicKeyInfo.",
      "ja": "o 管理者は、一部のPKIX拡張が関連付けのセキュリティに悪影響を与える可能性があるかどうかを理解する必要があります。可能であれば、管理者は、SubjectPublicKeyInfoを共有するすべてのCA証明書を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The administrator ought to understand that any CA could, in the future, issue a certificate that contains the same SubjectPublicKeyInfo. Therefore, new chains can crop up in the future without any warning.",
      "ja": "o 管理者は、どのCAも将来、同じSubjectPublicKeyInfoを含む証明書を発行する可能性があることを理解する必要があります。したがって、将来、警告なしに新しいチェーンが出現する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Using the SubjectPublicKeyInfo selector for association with a certificate in a chain above I1 needs to be decided on a case-by-case basis: there are too many possibilities based on the issuing CA's practices. Unless the full implications of such an association are understood by the administrator, using selector type 0 is a better option from a security perspective.",
      "ja": "SubjectPublicKeyInfoセレクターを使用してI1の上のチェーン内の証明書と関連付けることは、ケースバイケースで決定する必要があります。発行するCAの慣習に基づいて、可能性が多すぎます。そのような関連付けの完全な影響が管理者によって理解されていない限り、セレクタータイプ0を使用することはセキュリティの観点からより良いオプションです。"
    },
    {
      "indent": 0,
      "text": "A.2. Provisioning TLSA Records in DNS",
      "section_title": true,
      "ja": "A.2. DNSでのTLSAレコードのプロビジョニング"
    },
    {
      "indent": 0,
      "text": "A.2.1. Provisioning TLSA Records with Aliases",
      "section_title": true,
      "ja": "A.2.1. エイリアスを使用したTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "The TLSA resource record is not special in the DNS; it acts exactly like any other RRtype where the queried name has one or more labels prefixed to the base name, such as the SRV RRtype [RFC2782]. This affects the way that the TLSA resource record is used when aliasing in the DNS.",
      "ja": "TLSAリソースレコードはDNSで特別なものではありません。 SRV RRtype [RFC2782]のように、クエリ名にベース名の前に1つ以上のラベルが付いた他のRRtypeとまったく同じように機能します。これは、DNSでエイリアスを作成するときにTLSAリソースレコードが使用される方法に影響します。"
    },
    {
      "indent": 3,
      "text": "Note that the IETF sometimes adds new types of aliasing in the DNS. If that happens in the future, those aliases might affect TLSA records, hopefully in a good way.",
      "ja": "IETFがDNSに新しいタイプのエイリアスを追加する場合があることに注意してください。それが将来発生する場合、これらのエイリアスがTLSAレコードに影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "A.2.1.1. Provisioning TLSA Records with CNAME Records",
      "section_title": true,
      "ja": "A.2.1.1. CNAMEレコードを使用したTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Using CNAME to alias in DNS only aliases from the exact name given, not any zones below the given name. For example, assume that a zone file has only the following:",
      "ja": "CNAMEを使用してDNSのエイリアスを作成すると、指定された名前の下のゾーンではなく、指定された正確な名前のエイリアスのみが使用されます。たとえば、ゾーンファイルに次のものだけがあるとします。"
    },
    {
      "indent": 3,
      "text": "sub1.example.com. IN CNAME sub2.example.com.",
      "ja": "sub1.example.com。 IN CNAME sub2.example.com。"
    },
    {
      "indent": 3,
      "text": "In this case, a request for the A record at \"bottom.sub1.example.com\" would not return any records because the CNAME given only aliases the name given. Assume, instead, the zone file has the following:",
      "ja": "この場合、「bottom.sub1.example.com」でのAレコードのリクエストは、指定されたCNAMEに指定された名前のエイリアスしかないため、レコードを返しません。代わりに、ゾーンファイルに次のものが含まれているとします。"
    },
    {
      "indent": 3,
      "text": "sub3.example.com. IN CNAME sub4.example.com. bottom.sub3.example.com. IN CNAME bottom.sub4.example.com.",
      "ja": "sub3.example.com。 IN CNAME sub4.example.com。 bottom.sub3.example.com。 IN CNAME bottom.sub4.example.com。"
    },
    {
      "indent": 3,
      "text": "In this case, a request for the A record at bottom.sub3.example.com would in fact return whatever value for the A record exists at bottom.sub4.example.com.",
      "ja": "この場合、bottom.sub3.example.comにあるAレコードのリクエストは、実際には、bottom.sub4.example.comにあるAレコードの値を返します。"
    },
    {
      "indent": 3,
      "text": "Application implementations and full-service resolvers request DNS records using libraries that automatically follow CNAME (and DNAME) aliasing. This allows hosts to put TLSA records in their own zones or to use CNAME to do redirection.",
      "ja": "アプリケーションの実装とフルサービスのリゾルバーは、CNAME（およびDNAME）エイリアスに自動的に従うライブラリを使用してDNSレコードを要求します。これにより、ホストは独自のゾーンにTLSAレコードを配置したり、CNAMEを使用してリダイレクトしたりできます。"
    },
    {
      "indent": 3,
      "text": "If the owner of the original domain wants a TLSA record for the same, they simply enter it under the defined prefix:",
      "ja": "元のドメインの所有者が同じのTLSAレコードを必要とする場合、定義されたプレフィックスの下に単に入力します。"
    },
    {
      "indent": 3,
      "text": "; No TLSA record in target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN TLSA 1 1 1 308202c5308201ab... sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1",
      "ja": ";ターゲットドメインにTLSAレコードがありません。 sub5.example.com。 IN CNAME sub6.example.com。 _443._tcp.sub5.example.com。 IN TLSA 1 1 1 308202c5308201ab ... sub6.example.com。 IN 192.0.2.1 sub6.example.com。 IN AAAA 2001：db8 :: 1"
    },
    {
      "indent": 3,
      "text": "If the owner of the original domain wants to have the target domain host the TLSA record, the original domain uses a CNAME record:",
      "ja": "元のドメインの所有者がターゲットドメインにTLSAレコードをホストさせたい場合、元のドメインはCNAMEレコードを使用します。"
    },
    {
      "indent": 3,
      "text": "; TLSA record for original domain has CNAME to target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN CNAME _443._tcp.sub6.example.com. sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 536a570ac49d9ba4...",
      "ja": ";元のドメインのTLSAレコードには、ターゲットドメインへのCNAMEがあります。 sub5.example.com。 IN CNAME sub6.example.com。 _443._tcp.sub5.example.com。 IN CNAME _443._tcp.sub6.example.com。 sub6.example.com。 IN 192.0.2.1 sub6.example.com。 IN AAAA 2001：db8 :: 1 _443._tcp.sub6.example.com。 TLSA IN 1 1 1 536a570ac49d9ba4 ..."
    },
    {
      "indent": 3,
      "text": "Note that it is acceptable for both the original domain and the target domain to have TLSA records, but the two records are unrelated. Consider the following:",
      "ja": "元のドメインとターゲットドメインの両方にTLSAレコードを含めることは許容されますが、2つのレコードは無関係です。以下を検討してください。"
    },
    {
      "indent": 3,
      "text": "; TLSA record in both the original and target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN TLSA 1 1 1 308202c5308201ab... sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 ac49d9ba4570ac49...",
      "ja": ";元のドメインとターゲットドメインの両方のTLSAレコード。 sub5.example.com。 IN CNAME sub6.example.com。 _443._tcp.sub5.example.com。 IN TLSA 1 1 1 308202c5308201ab ... sub6.example.com。 IN 192.0.2.1 sub6.example.com。 IN AAAA 2001：db8 :: 1 _443._tcp.sub6.example.com。 TLSAで1 1 1 ac49d9ba4570ac49 ..."
    },
    {
      "indent": 3,
      "text": "In this example, someone looking for the TLSA record for sub5.example.com would always get the record whose value starts with \"308202c5308201ab\"; the TLSA record whose value starts with \"ac49d9ba4570ac49\" would only be sought by someone who is looking for the TLSA record for sub6.example.com, and never for sub5.example.com. Note that deploying different certificates for multiple services located at a shared TLS listener often requires the use of TLS SNI (Server Name Indication) [RFC6066].",
      "ja": "この例では、sub5.example.comのTLSAレコードを探しているユーザーは常に、値が「308202c5308201ab」で始まるレコードを取得します。値が「ac49d9ba4570ac49」で始まるTLSAレコードは、sub6.example.comのTLSAレコードを探している人だけが探し、sub5.example.comは探していません。共有TLSリスナーにある複数のサービスに異なる証明書をデプロイするには、TLS SNI（サーバー名表示）[RFC6066]を使用する必要があることが多いことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that these methods use the normal method for DNS aliasing using CNAME: the DNS client requests the record type that they actually want.",
      "ja": "これらのメソッドは、CNAMEを使用したDNSエイリアスの通常のメソッドを使用することに注意してください。DNSクライアントは、実際に必要なレコードタイプを要求します。"
    },
    {
      "indent": 0,
      "text": "A.2.1.2. Provisioning TLSA Records with DNAME Records",
      "section_title": true,
      "ja": "A.2.1.2. DNAMEレコードを使用したTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Using DNAME records allows a zone owner to alias an entire subtree of names below the name that has the DNAME. This allows the wholesale aliasing of prefixed records such as those used by TLSA, SRV, and so on without aliasing the name itself. However, because DNAME can only be used for subtrees of a base name, it is rarely used to alias individual hosts that might also be running TLS.",
      "ja": "DNAMEレコードを使用すると、ゾーン所有者は、DNAMEを持つ名前の下の名前のサブツリー全体にエイリアスを設定できます。これにより、名前自体にエイリアスを付けることなく、TLSA、SRVなどで使用されるレコードのようなプレフィックス付きレコードのホールセールエイリアスが可能になります。ただし、DNAMEはベース名のサブツリーにのみ使用できるため、TLSを実行している可能性のある個々のホストのエイリアスとして使用されることはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "; TLSA record in target domain, visible in original domain via DNAME ; sub5.example.com. IN CNAME sub6.example.com. _tcp.sub5.example.com. IN DNAME _tcp.sub6.example.com. sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 536a570ac49d9ba4...",
      "ja": ";ターゲットドメインのTLSAレコード。DNAMEを介して元のドメインに表示されます。 sub5.example.com。 IN CNAME sub6.example.com。 _tcp.sub5.example.com。 IN DNAME _tcp.sub6.example.com。 sub6.example.com。 IN 192.0.2.1 sub6.example.com。 IN AAAA 2001：db8 :: 1 _443._tcp.sub6.example.com。 TLSA IN 1 1 1 536a570ac49d9ba4 ..."
    },
    {
      "indent": 0,
      "text": "A.2.1.3. Provisioning TLSA Records with Wildcards",
      "section_title": true,
      "ja": "A.2.1.3. ワイルドカードを使用したTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Wildcards are generally not terribly useful for RRtypes that require prefixing because one can only wildcard at a layer below the host name. For example, if one wants to have the same TLSA record for every TCP port for www.example.com, the result might be:",
      "ja": "ワイルドカードは、ホスト名の下のレイヤーでしかワイルドカードを使用できないため、一般に、プレフィックスが必要なRRtypeにはそれほど役立ちません。たとえば、www.example.comのすべてのTCPポートに同じTLSAレコードが必要な場合、結果は次のようになります。"
    },
    {
      "indent": 3,
      "text": "*._tcp.www.example.com. IN TLSA 1 1 1 5c1502a6549c423b...",
      "ja": "* ._ tcp.www.example.com。 TLSAで1 1 1 5c1502a6549c423b ..."
    },
    {
      "indent": 3,
      "text": "This is possibly useful in some scenarios where the same service is offered on many ports or the same certificate and/or key is used for all services on a host. Note that the domain being searched for is not necessarily related to the domain name found in the certificate, so a certificate with a wildcard in it is not searched for using a wildcard in the search request.",
      "ja": "これは、同じサービスが多くのポートで提供されている場合や、ホスト上のすべてのサービスに同じ証明書やキーが使用されている場合に役立つ可能性があります。検索されるドメインは、証明書で見つかったドメイン名に必ずしも関連しているわけではないので、ワイルドカードを含む証明書は、検索リクエストでワイルドカードを使用して検索されないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.3. Securing the Last Hop",
      "section_title": true,
      "ja": "A.3. ラストホップの確保"
    },
    {
      "indent": 3,
      "text": "As described in Section 4, an application processing TLSA records must know the DNSSEC validity of those records. There are many ways for the application to determine this securely, and this specification does not mandate any single method.",
      "ja": "セクション4で説明したように、TLSAレコードを処理するアプリケーションは、それらのレコードのDNSSEC有効性を知っている必要があります。アプリケーションがこれを安全に決定する方法はたくさんありますが、この仕様では単一のメソッドを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "Some common methods for an application to know the DNSSEC validity of TLSA records include:",
      "ja": "アプリケーションがTLSAレコードのDNSSEC有効性を知るためのいくつかの一般的な方法には、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o The application can have its own DNS resolver and DNSSEC validation stack.",
      "ja": "o アプリケーションは、独自のDNSリゾルバーとDNSSEC検証スタックを持つことができます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a trusted channel (such as requests to the operating system under which the application is running) to a local DNS resolver that does DNSSEC validation.",
      "ja": "o アプリケーションは、信頼できるチャネル（アプリケーションが実行されているオペレーティングシステムへの要求など）を介して、DNSSEC検証を行うローカルDNSリゾルバーと通信できます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a secured channel (such as requests running over TLS, IPsec, TSIG, or SIG(0)) to a non-local DNS resolver that does DNSSEC validation.",
      "ja": "o アプリケーションは、セキュリティで保護されたチャネル（TLS、IPsec、TSIG、またはSIG（0）を介して実行される要求など）を介して、DNSSEC検証を行う非ローカルDNSリゾルバーと通信できます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a secured channel (such as requests running over TLS, IPsec, TSIG, or SIG(0)) to a non-local DNS resolver that does not do DNSSEC validation, but gets responses through a secured channel from a different DNS resolver that does DNSSEC validation.",
      "ja": "o アプリケーションは、セキュリティで保護されたチャネル（TLS、IPsec、TSIG、またはSIG（0）を介して実行される要求など）を介して、DNSSEC検証を行わない非ローカルDNSリゾルバーと通信できますが、別のセキュリティで保護されたチャネルを通じて応答を取得できますDNSSEC検証を行うDNSリゾルバー。"
    },
    {
      "indent": 0,
      "text": "A.4. Handling Certificate Rollover",
      "section_title": true,
      "ja": "A.4. 証明書のロールオーバーの処理"
    },
    {
      "indent": 3,
      "text": "Certificate rollover is handled in much the same way as for rolling DNSSEC zone signing keys using the pre-publish key rollover method [RFC4641]. Suppose example.com has a single TLSA record for a TLS service on TCP port 990:",
      "ja": "証明書のロールオーバーは、事前公開キーのロールオーバー方法[RFC4641]を使用してDNSSECゾーン署名キーをロールする場合とほとんど同じ方法で処理されます。 example.comに、TCPポート990のTLSサービス用の単一のTLSAレコードがあるとします。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015...",
      "ja": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015 ..."
    },
    {
      "indent": 3,
      "text": "To start the rollover process, obtain or generate the new certificate or SubjectPublicKeyInfo to be used after the rollover and generate the new TLSA record. Add that record alongside the old one:",
      "ja": "ロールオーバープロセスを開始するには、ロールオーバー後に使用する新しい証明書またはSubjectPublicKeyInfoを取得または生成し、新しいTLSAレコードを生成します。古いレコードと一緒にそのレコードを追加します。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015... _990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30...",
      "ja": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015 ... _990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30 ..."
    },
    {
      "indent": 3,
      "text": "After the new records have propagated to the authoritative nameservers and the TTL of the old record has expired, switch to the new certificate on the TLS server. Once this has occurred, the old TLSA record can be removed:",
      "ja": "新しいレコードが信頼できるネームサーバーに伝達され、古いレコードのTTLが期限切れになった後、TLSサーバーで新しい証明書に切り替えます。これが発生すると、古いTLSAレコードを削除できます。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30...",
      "ja": "_990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30 ..."
    },
    {
      "indent": 3,
      "text": "This completes the certificate rollover.",
      "ja": "これで証明書のロールオーバーが完了しました。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Pseudocode for Using TLSA",
      "section_title": true,
      "ja": "付録B. TLSAを使用するための疑似コード"
    },
    {
      "indent": 3,
      "text": "This appendix describes, in pseudocode format, the interactions given earlier in this specification. If the steps below disagree with the text earlier in the document, the steps earlier in the document ought to be considered correct and this text incorrect.",
      "ja": "この付録では、この仕様の前半で示した相互作用について、疑似コード形式で説明します。以下の手順がドキュメントの前半のテキストと一致しない場合、ドキュメントの前半のステップは正しいと見なされ、このテキストは正しくありません。"
    },
    {
      "indent": 3,
      "text": "Note that this pseudocode is more strict than the normative text. For instance, it forces an order on the evaluation of criteria, which is not mandatory from the normative text.",
      "ja": "この疑似コードは、規範的なテキストよりも厳密であることに注意してください。たとえば、基準の評価に命令を強制しますが、これは規範的なテキストから必須ではありません。"
    },
    {
      "indent": 0,
      "text": "B.1. Helper Functions",
      "section_title": true,
      "ja": "B.1. ヘルパー関数"
    },
    {
      "indent": 3,
      "text": "// implement the function for exiting\nfunction Finish (F) = {\n  if (F == ABORT_TLS) {\n    abort the TLS handshake or prevent TLS from starting\n    exit\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (F == NO_TLSA) {\n  fall back to non-TLSA certificate validation\n  exit\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (F == ACCEPT) {\n  accept the TLS connection\n  exit\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "//到達不能}"
    },
    {
      "indent": 3,
      "text": "// implement the selector function\nfunction Select (S, X) = {\n  // Full certificate\n  if (S == 0) {\n    return X in DER encoding\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// SubjectPublicKeyInfo\nif (S == 1) {\n  return X.SubjectPublicKeyInfo in DER encoding\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "//到達不能}"
    },
    {
      "indent": 3,
      "text": "// implement the matching function\nfunction Match (M, X, Y) {\n  // Exact match on selected content\n  if (M == 0) {\n    return (X == Y)\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// SHA-256 hash of selected content\nif (M == 1) {\n  return (SHA-256(X) == Y)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// SHA-512 hash of selected content\nif (M == 2) {\n  return (SHA-512(X) == Y)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "//到達不能}"
    },
    {
      "indent": 0,
      "text": "B.2. Main TLSA Pseudocode",
      "section_title": true,
      "ja": "B.2. メインTLSA疑似コード"
    },
    {
      "indent": 3,
      "text": "TLS connect using [transport] to [name] on [port] and receiving end entity cert C for the TLS server:",
      "ja": "[ポート]の[名前]に[トランスポート]を使用してTLS接続し、TLSサーバーのエンドエンティティ証明書Cを受信します。"
    },
    {
      "indent": 3,
      "text": "(TLSArecords, ValState) = DNSSECValidatedLookup(\n  domainname=_[port]._[transport].[name], RRtype=TLSA)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// check for states that would change processing\nif (ValState == BOGUS) {\n  Finish(ABORT_TLS)\n}\nif ((ValState == INDETERMINATE) or (ValState == INSECURE)) {\n  Finish(NO_TLSA)\n}\n// if here, ValState must be SECURE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "for each R in TLSArecords {\n  // unusable records include unknown certUsage, unknown\n  // selectorType, unknown matchingType, erroneous RDATA, and\n  // prohibited by local policy\n  if (R is unusable) {\n    remove R from TLSArecords\n  }\n}\nif (length(TLSArecords) == 0) {\n  Finish(NO_TLSA)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// A TLS client might have multiple trust anchors that it might use\n//    when validating the TLS server's end entity (EE) certificate.\n//    Also, there can be multiple PKIX certification paths for the\n//    certificates given by the server in TLS.  Thus, there are\n//    possibly many chains that might need to be tested during\n//    PKIX path validation.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "for each R in TLSArecords {",
      "ja": "TLSArecordsの各Rに対して{"
    },
    {
      "indent": 5,
      "text": "// pass PKIX certificate validation and chain through a CA cert\n//    that comes from TLSA\nif (R.certUsage == 0) {\n  for each PKIX certification path H {\n    if (C passes PKIX certification path validation in H) {\n      for each D in H {\n        if ((D is a CA certificate) and\n            Match(R.matchingType, Select(R.selectorType, D),\n                  R.cert)) {\n          Finish(ACCEPT)\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// pass PKIX certificate validation and match EE cert from TLSA\nif (R.certUsage == 1) {\n  for each PKIX certification path H {\n    if ((C passes PKIX certificate validation in H) and\n            Match(R.matchingType, Select(R.selectorType, C),\n            R.cert)) {\n        Finish(ACCEPT)\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "     // pass PKIX certification validation using TLSA record as the\n     //    trust anchor\n     if (R.certUsage == 2) {\n       // the following assert() is merely a formalization of the\n       // \"trust anchor\" condition for a certificate D matching R\n       assert(Match(R.matchingType, Select(R.selectorType, D), R.cert))\n       for each PKIX certification path H that has certificate D\n           matching R as the trust anchor {\n         if (C passes PKIX validation in H) {\n           Finish(ACCEPT);\n         }\n       }\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// match the TLSA record and the TLS certificate\nif (R.certUsage == 3) {\n  if Match(R.matchingType, Select(R.selectorType, C), R.cert)\n    Finish(ACCEPT)\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "// if here, then none of the TLSA records ended in \"Finish(ACCEPT)\"\n//   so abort TLS\nFinish(ABORT_TLS)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples",
      "section_title": true,
      "ja": "付録C.例"
    },
    {
      "indent": 3,
      "text": "The following are examples of self-signed certificates that have been generated with various selectors and matching types. They were generated with one piece of software, and validated by an individual using other tools.",
      "ja": "以下は、さまざまなセレクターと一致するタイプで生成された自己署名証明書の例です。これらは1つのソフトウェアで生成され、他のツールを使用して個人が検証しました。"
    },
    {
      "indent": 3,
      "text": "S = Selector M = Matching Type",
      "ja": "S =セレクターM =マッチングタイプ"
    },
    {
      "indent": 0,
      "text": "   S M Association Data\n   0 0 30820454308202BC020900AB58D24E77AD2AF6300D06092A86\n       4886F70D0101050500306C310B3009060355040613024E4C31163014\n       0603550408130D4E6F6F72642D486F6C6C616E643112301006035504\n       071309416D7374657264616D310C300A060355040A13034F53333123\n       30210603550403131A64616E652E6B6965762E70726163746963756D\n       2E6F73332E6E6C301E170D3132303131363136353730335A170D3232\n       303131333136353730335A306C310B3009060355040613024E4C3116\n       30140603550408130D4E6F6F72642D486F6C6C616E64311230100603\n       5504071309416D7374657264616D310C300A060355040A13034F5333\n       312330210603550403131A64616E652E6B6965762E70726163746963\n       756D2E6F73332E6E6C308201A2300D06092A864886F70D0101010500\n       0382018F003082018A0282018100E62C84A5AFE59F0A2A6B250DEE68\n       7AC8C5C604F57D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B\n       6AD5DEA0C8771C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE\n       281A68230B24B9DA1A98DCBE51195B60E42FD7517C328D983E26A827\n       C877AB914EE4C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D5\n       8C389CC3D6D8C20662E19CF768F32441B7F7D14AEA8966CE7C32A172\n       2AB38623D008029A9E4702883F8B977A1A1E5292BF8AD72239D40393\n       37B86A3AC60FA001290452177BF1798609A05A130F033457A5212629\n       FBDDB8E70E2A9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D\n       4BD77DFA34035563C126AA2C3328B900E7990AC9787F01DA82F74C3D\n       4B6674CCECE1FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE775\n       6213BD3D60831175BE290442B4AFC5AE6F46B769855A067C1097E617\n       962529E166F22AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A44\n       9C8D0D31BC683C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2\n       DDFF6B4CAC050203010001300D06092A864886F70D01010505000382\n       0181002B2ABE063E9C86AC4A1F7835372091079C8276A9C2C5D1EC57\n       64DE523FDDABDEAB3FD34E6FE6CBA054580A6785A663595D90132B93\n       D473929E81FA0887D2FFF78A81C7D014B97778AB6AC9E5E690F6F5A9\n       E92BB5FBAB71B857AE69B6E18BDCCB0BA6FCD9D4B084A34F3635148C\n       495D48FE635903B888EC1DEB2610548EDD48D63F86513A4562469831\n       48C0D5DB82D73A4C350A42BB661D763430FC6C8E5F9D13EA1B76AA52\n       A4C358E5EA04000F794618303AB6CEEA4E9A8E9C74D73C1B0B7BAF16\n       DEDE7696B5E2F206F777100F5727E1684D4132F5E692F47AF6756EA8\n       B421000BE031B5D8F0220E436B51FB154FE9595333C13A2403F9DE08\n       E5DDC5A22FD6182E339593E26374450220BC14F3E40FF33F084526B0\n       9C34250702E8A352B332CCCB0F9DE2CF2B338823B92AFC61C0B6B8AB\n       DB5AF718ED8DDA97C298E46B82A01B14814868CFA4F2C36268BFFF4A\n       591F42658BF75918902D3E426DFE1D5FF0FC6A212071F6DA8BD833FE\n       2E560D87775E8EE9333C05B6FB8EB56589D910DB5EA903",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0 1 EFDDF0D915C7BDC5782C0881E1B2A95AD099FBDD06D7B1F779 82D9364338D955",
      "ja": "0 1 EFDDF0D915C7BDC5782C0881E1B2A95AD099FBDD06D7B1F779 82D9364338D955"
    },
    {
      "indent": 3,
      "text": "0 2 81EE7F6C0ECC6B09B7785A9418F54432DE630DD54DC6EE9E3C 49DE547708D236D4C413C3E97E44F969E635958AA410495844127C04 883503E5B024CF7A8F6A94",
      "ja": "0 2 81EE7F6C0ECC6B09B7785A9418F54432DE630DD54DC6EE9E3C 49DE547708D236D4C413C3E97E44F969E635958AA410495844127C04 883503BE524CF7A8F6A94"
    },
    {
      "indent": 3,
      "text": "1 0 308201A2300D06092A864886F70D01010105000382018F0030 82018A0282018100E62C84A5AFE59F0A2A6B250DEE687AC8C5C604F5 7D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B6AD5DEA0C877 1C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE281A68230B24 B9DA1A98DCBE51195B60E42FD7517C328D983E26A827C877AB914EE4 C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D58C389CC3D6D8 C20662E19CF768F32441B7F7D14AEA8966CE7C32A1722AB38623D008 029A9E4702883F8B977A1A1E5292BF8AD72239D4039337B86A3AC60F A001290452177BF1798609A05A130F033457A5212629FBDDB8E70E2A 9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D4BD77DFA3403 5563C126AA2C3328B900E7990AC9787F01DA82F74C3D4B6674CCECE1 FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE7756213BD3D6083 1175BE290442B4AFC5AE6F46B769855A067C1097E617962529E166F2 2AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A449C8D0D31BC68 3C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2DDFF6B4CAC05 0203010001",
      "ja": "1 0 308201A2300D06092A864886F70D01010105000382018F0030 82018A0282018100E62C84A5AFE59F0A2A6B250DEE687AC8C5C604F5 7D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B6AD5DEA0C877 1C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE281A68230B24 B9DA1A98DCBE51195B60E42FD7517C328D983E26A827C877AB914EE4 C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D58C389CC3D6D8 C20662E19CF768F32441B7F7D14AEA8966CE7C32A1722AB38623D008 029A9E4702883F8B977A1A1E5292BF8AD72239D4039337B86A3AC60F A001290452177BF1798609A05A130F033457A5212629FBDDB8E70E2A 9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D4BD77DFA3403 5563C126AA2C3328B900E7990AC9787F01DA82F74C3D4B6674CCECE1 FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE7756213BD3D6083 1175BE290442B4AFC5AE6F46B769855A067C1097E617962529E166F2 2AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A449C8D0D31BC68 3C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2DDFF6B4CAC05 0203010001"
    },
    {
      "indent": 3,
      "text": "1 1 8755CDAA8FE24EF16CC0F2C918063185E433FAAF1415664911 D9E30A924138C4",
      "ja": "1 1 8755CDAA8FE24EF16CC0F2C918063185E433FAAF1415664911 D9E30A924138C4"
    },
    {
      "indent": 3,
      "text": "1 2 D43165B4CDF8F8660AECCCC5344D9D9AE45FFD7E6AAB7AB9EE C169B58E11F227ED90C17330CC17B5CCEF0390066008C720CEC6AAE5 33A934B3A2D7E232C94AB4",
      "ja": "1 2 D43165B4CDF8F8660AECCCC5344D9D9AE45FFD7E6AAB7AB9EE C169B58E11F227ED90C17330CC17B5CCEF0390066008C720CEC6AAE5 33A934B3A2D7E232C94AB4"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium",
      "ja": "ポールホフマンVPNコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jakob Schlyter Kirei AB",
      "ja": "じゃこｂ Ｓｃｈｌｙてｒ きれい あＢ"
    },
    {
      "indent": 3,
      "text": "EMail: jakob@kirei.se",
      "raw": true,
      "ja": ""
    }
  ]
}