{
  "title": {
    "text": "RFC 6628 - Efficient Augmented Password-Only Authentication and Key Exchange for IKEv2",
    "ja": "RFC 6628 - IKEv2の効率的な拡張パスワードのみ認証と鍵交換"
  },
  "number": 6628,
  "created_at": "2020-09-07 18:13:43.191896+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           S. Shin\nRequest for Comments: 6628                                     K. Kobara\nCategory: Experimental                                              AIST\nISSN: 2070-1721                                                June 2012",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Efficient Augmented Password-Only Authentication and Key Exchange for IKEv2",
      "ja": "IKEv2の効率的な拡張パスワードのみ認証と鍵交換"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes an efficient augmented password-only authentication and key exchange (AugPAKE) protocol where a user remembers a low-entropy password and its verifier is registered in the intended server. In general, the user password is chosen from a small set of dictionary words that allows an attacker to perform exhaustive searches (i.e., off-line dictionary attacks). The AugPAKE protocol described here is secure against passive attacks, active attacks, and off-line dictionary attacks (on the obtained messages with passive/active attacks), and also provides resistance to server compromise (in the context of augmented PAKE security). In addition, this document describes how the AugPAKE protocol is integrated into the Internet Key Exchange Protocol version 2 (IKEv2).",
      "ja": "このドキュメントでは、ユーザーが低エントロピーパスワードを覚えていて、その検証者が目的のサーバーに登録されている、効率的な拡張パスワードのみの認証およびキー交換（AugPAKE）プロトコルについて説明します。一般に、ユーザーパスワードは、攻撃者が徹底的な検索（オフラインの辞書攻撃）を実行できるようにする小さな辞書の単語のセットから選択されます。ここで説明するAugPAKEプロトコルは、パッシブ攻撃、アクティブ攻撃、オフラインディクショナリ攻撃（パッシブ/アクティブ攻撃で取得されたメッセージに対して）に対して安全であり、（拡張PAKEセキュリティのコンテキストで）サーバーの侵害に対する耐性も提供します。さらに、このドキュメントでは、AugPAKEプロトコルがInternet Key Exchange Protocolバージョン2（IKEv2）にどのように統合されるかについて説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6628.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6628で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2012 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Keywords ...................................................4\n2. AugPAKE Specification ...........................................4\n   2.1. Underlying Group ...........................................4\n   2.2. Notation ...................................................5\n        2.2.1. Password Processing .................................6\n   2.3. Protocol ...................................................7\n        2.3.1. Initialization ......................................7\n        2.3.2. Actual Protocol Execution ...........................7\n3. Security Considerations .........................................9\n   3.1. General Assumptions ........................................9\n   3.2. Security against Passive Attacks ..........................10\n   3.3. Security against Active Attacks ...........................10\n        3.3.1. Impersonation Attacks on User U ....................10\n        3.3.2. Impersonation Attacks on Server S ..................11\n        3.3.3. Man-in-the-Middle Attacks ..........................11\n   3.4. Security against Off-line Dictionary Attacks ..............12\n   3.5. Resistance to Server Compromise ...........................12\n4. Implementation Consideration ...................................13\n5. AugPAKE for IKEv2 ..............................................13\n   5.1. Integration into IKEv2 ....................................13\n   5.2. Payload Formats ...........................................15\n        5.2.1. Notify Payload .....................................15\n        5.2.2. Generic Secure Password Method Payload .............16\n6. IANA Considerations ............................................16\n7. References .....................................................16\n   7.1. Normative References ......................................16\n   7.2. Informative References ....................................17\nAppendix A.  Evaluation by PAKE Selection Criteria.................19",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In the real world, many applications, such as Web mail and Internet banking/shopping/trading, require secure channels between participating parties. Such secure channels can be established by using an authentication and key exchange (AKE) protocol, which allows the involved parties to authenticate each other and to generate a temporary session key. The temporary session key is used to protect the subsequent communications between the parties.",
      "ja": "現実の世界では、Webメールやインターネットバンキング/ショッピング/トレーディングなどの多くのアプリケーションで、参加者間に安全なチャネルが必要です。このような安全なチャネルは、認証およびキー交換（AKE）プロトコルを使用して確立できます。これにより、関係者は相互に認証し、一時的なセッションキーを生成できます。一時的なセッションキーは、その後の当事者間の通信を保護するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Until now, password-only AKE (called PAKE) protocols have attracted much attention because password-only authentication is very convenient to the users. However, it is not trivial to design a secure PAKE protocol due to the existence of off-line dictionary attacks on passwords. These attacks are possible since passwords are chosen from a relatively-small dictionary that allows for an attacker to perform the exhaustive searches. This problem was brought forth by Bellovin and Merritt [BM92], and many subsequent works have been conducted in the literature (see some examples in [IEEEP1363.2]). A PAKE protocol is said to be secure if the best attack an active attacker can take is restricted to the on-line dictionary attacks, which allows a guessed password to be checked only by interacting with the honest party.",
      "ja": "これまで、パスワードのみの認証はユーザーにとって非常に便利であるため、パスワードのみのAKE（PAKEと呼ばれる）プロトコルが大きな注目を集めてきました。ただし、パスワードに対するオフラインの辞書攻撃が存在するため、安全なPAKEプロトコルを設計することは簡単ではありません。攻撃者が徹底的な検索を実行できる比較的小さな辞書からパスワードが選択されるため、これらの攻撃が可能です。この問題はBellovin and Merritt [BM92]によって引き起こされ、その後の多くの研究が文献で行われています（[IEEEP1363.2]のいくつかの例を参照）。アクティブな攻撃者が実行できる最善の攻撃がオンライン辞書攻撃に限定されている場合、PAKEプロトコルは安全であると言われます。これにより、推測されたパスワードは、正直な当事者との対話によってのみ確認できます。"
    },
    {
      "indent": 3,
      "text": "An augmented PAKE protocol (e.g., [BM93], [RFC2945], [ISO]) provides extra protection for server compromise in the sense that an attacker, who obtains a password verifier from a server, cannot impersonate the corresponding user without performing off-line dictionary attacks on the password verifier. This additional security is known as \"resistance to server compromise\". The AugPAKE protocol described in this document is an augmented PAKE, which also achieves measurable efficiency over some previous works (i.e., SRP [RFC2945] and AMP [ISO]). We believe the following (see [SKI10] for the formal security proof): 1) The AugPAKE protocol is secure against passive attacks, active attacks, and off-line dictionary attacks (on the obtained messages with passive/active attacks), and 2) It provides resistance to server compromise. At the same time, the AugPAKE protocol has similar computational efficiency to the plain Diffie-Hellman key exchange [DH76] that does not provide authentication by itself. Specifically, the user and the server need to compute 2 and 2.17 modular exponentiations, respectively, in the AugPAKE protocol. After excluding pre-computable costs, the user and the server are required to compute only 1 and 1.17 modular exponentiations, respectively. Compared with SRP [RFC2945] and AMP [ISO], the AugPAKE protocol is more efficient 1) than SRP in terms of the user's computational costs and 2) than AMP in terms of the server's computational costs.",
      "ja": "拡張されたPAKEプロトコル（たとえば、[BM93]、[RFC2945]、[ISO]）は、サーバーからパスワード検証を取得する攻撃者がオフに実行せずに対応するユーザーを偽装できないという意味で、サーバーの侵害に対する追加の保護を提供します。パスワードベリファイアに対する行辞書攻撃。この追加のセキュリティは、「サーバーの侵害に対する耐性」として知られています。このドキュメントで説明されているAugPAKEプロトコルは拡張されたPAKEであり、以前の一部の作業（つまり、SRP [RFC2945]およびAMP [ISO]）よりも測定可能な効率を達成しています。私たちは次のことを信じています（正式なセキュリティの証明については[SKI10]を参照してください）：1）AugPAKEプロトコルは、パッシブ攻撃、アクティブ攻撃、オフライン辞書攻撃（パッシブ/アクティブ攻撃で取得したメッセージ）に対して安全です。 ）サーバーの侵害に対する耐性を提供します。同時に、AugPAKEプロトコルは、それ自体では認証を提供しない単純なDiffie-Hellman鍵交換[DH76]と同様の計算効率を備えています。具体的には、ユーザーとサーバーは、それぞれAugPAKEプロトコルで2と2.17のべき乗を計算する必要があります。事前計算可能なコストを除外した後、ユーザーとサーバーはそれぞれ1と1.17のべき乗のみを計算する必要があります。 SRP [RFC2945]およびAMP [ISO]と比較して、AugPAKEプロトコルは、1）ユーザーの計算コストの点でSRPよりも効率的であり、2）サーバーの計算コストの点でAMPよりも効率的です。"
    },
    {
      "indent": 3,
      "text": "This document also describes how the AugPAKE protocol is integrated into IKEv2 [RFC5996].",
      "ja": "このドキュメントでは、AugPAKEプロトコルがIKEv2 [RFC5996]にどのように統合されるかも説明しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Keywords",
      "section_title": true,
      "ja": "1.1. キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. AugPAKE Specification",
      "section_title": true,
      "ja": "2. AugPAKE仕様"
    },
    {
      "indent": 0,
      "text": "2.1. Underlying Group",
      "section_title": true,
      "ja": "2.1. 基になるグループ"
    },
    {
      "indent": 3,
      "text": "The AugPAKE protocol can be implemented over the following group.",
      "ja": "AugPAKEプロトコルは、次のグループで実装できます。"
    },
    {
      "indent": 3,
      "text": "o Let p and q be sufficiently large primes such that q is a divisor of ((p - 1) / 2), and every factor of ((p - 1) / 2) are also primes comparable to q in size. This p is called a \"secure\" prime. By G, we denote a multiplicative subgroup of prime order q over the field GF(p), the integers modulo p. Let g be a generator for the subgroup G so that all the subgroup elements are generated by g. The group operation is denoted multiplicatively (in modulo p).",
      "ja": "o pとqを、qが（（p-1）/ 2）の約数になるような十分に大きな素数とし、（（p-1）/ 2）のすべての因数も、サイズがqに匹敵する素数です。このpは「安全な」素数と呼ばれます。 Gにより、pを法とする整数GF（p）上の素数階数qの乗法サブグループを表します。すべてのサブグループ要素がgによって生成されるように、gをサブグループGのジェネレーターとします。グループ演算は乗法的に（モジュロpで）示されます。"
    },
    {
      "indent": 3,
      "text": "By using a secure prime p, the AugPAKE protocol has computational efficiency gains. Specifically, it does not require the order check of elements received from the counterpart party. Note that the groups defined in Discrete Logarithm Cryptography [SP800-56A] and RFC 5114 [RFC5114] are not necessarily the above secure prime groups.",
      "ja": "安全な素数pを使用することにより、AugPAKEプロトコルは計算効率を向上させます。具体的には、相手方から受け取った要素の注文チェックを必要としない。離散対数暗号化[SP800-56A]およびRFC 5114 [RFC5114]で定義されているグループは、必ずしも上記の安全な素数グループではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Alternatively, one can implement the AugPAKE protocol over the following groups.",
      "ja": "あるいは、次のグループにAugPAKEプロトコルを実装できます。"
    },
    {
      "indent": 3,
      "text": "o Let p and q be sufficiently large primes such that p = (2 * q) + 1. This p is called a \"safe\" prime. By G, we denote a multiplicative subgroup of prime order q over the field GF(p), the integers modulo p. Let g be any element of G other than 1. For example, g = h^2 mod p where h is a primitive element. The group operation is denoted multiplicatively (in modulo p).",
      "ja": "o pとqを、p =（2 * q）+ 1となるように十分に大きな素数とします。このpは「安全な」素数と呼ばれます。 Gにより、pを法とする整数GF（p）上の素数階数qの乗法サブグループを表します。 gを1以外のGの要素とする。たとえば、g = h ^ 2 mod pで、hはプリミティブ要素です。グループ演算は乗法的に（モジュロpで）示されます。"
    },
    {
      "indent": 3,
      "text": "o Let p and q be sufficiently large primes such that q is a divisor of ((p - 1) / 2). By G, we denote a multiplicative subgroup of prime order q over the field GF(p), the integers modulo p. Let g be a generator for the subgroup G so that all the subgroup elements are generated by g. The group operation is denoted multiplicatively (in modulo p). If p is not a \"secure\" prime, the AugPAKE protocol MUST perform the order check of received elements.",
      "ja": "o pとqを、qが（（p-1）/ 2）の約数になるように十分に大きな素数とする。 Gにより、pを法とする整数GF（p）上の素数階数qの乗法サブグループを表します。すべてのサブグループ要素がgによって生成されるように、gをサブグループGのジェネレーターとします。グループ演算は乗法的に（モジュロpで）示されます。 pが「安全な」素数でない場合、AugPAKEプロトコルは受信した要素の順序チェックを実行しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "2.2. Notation",
      "section_title": true,
      "ja": "2.2. 表記"
    },
    {
      "indent": 3,
      "text": "The AugPAKE protocol is a two-party protocol where a user and a server authenticate each other and generate a session key. The following notation is used in this document:",
      "ja": "AugPAKEプロトコルは、ユーザーとサーバーが相互に認証し、セッションキーを生成する2者間のプロトコルです。このドキュメントでは、次の表記法を使用しています。"
    },
    {
      "indent": 3,
      "text": "U The user's identity (e.g., as defined in [RFC4282]). It is a string in {0,1}^* where {0,1}^* indicates a set of finite binary strings.",
      "ja": "UユーザーのID（[RFC4282]で定義されているなど）。これは{0,1} ^ *の文字列で、{0,1} ^ *は有限のバイナリ文字列のセットを示します。"
    },
    {
      "indent": 3,
      "text": "S The server's identity (e.g., as defined in [RFC4282]). It is a string in {0,1}^*.",
      "ja": "SサーバーのID（[RFC4282]で定義されているなど）。 {0,1} ^ *の文字列です。"
    },
    {
      "indent": 3,
      "text": "b = H(a) A binary string a is given as input to a secure one-way hash function H (e.g., SHA-2 family [FIPS180-3]), which produces a fixed-length output b. The hash function H maps {0,1}^* to {0,1}^k, where {0,1}^k indicates a set of binary strings of length k and k is a security parameter.",
      "ja": "b = H（a）バイナリ文字列aは、固定長の出力bを生成する安全な一方向ハッシュ関数H（SHA-2ファミリ[FIPS180-3]など）への入力として指定されます。ハッシュ関数Hは{0,1} ^ *を{0,1} ^ kにマップします。{0,1} ^ kは長さkのバイナリ文字列のセットを示し、kはセキュリティパラメータです。"
    },
    {
      "indent": 3,
      "text": "b = H'(a) A binary string a is given as input to a secure one-way hash function H', which maps the input a in {0,1}^* to the output b in Z_q^*, where Z_q^* is a set of positive integers modulo prime q.",
      "ja": "b = H '（a）バイナリ文字列aは、安全な一方向ハッシュ関数H'への入力として与えられ、{0,1} ^ *の入力aをZ_q ^ *の出力bにマッピングします。ここで、Z_q ^ *は、素数qを法とする正の整数のセットです。"
    },
    {
      "indent": 3,
      "text": "a | b It denotes a concatenation of binary strings a and b in {0,1}^*.",
      "ja": "a | bバイナリ文字列aとbを{0,1} ^ *で連結したものを示します。"
    },
    {
      "indent": 3,
      "text": "0x A hexadecimal value is shown preceded by \"0x\".",
      "ja": "0x 16進値の前に「0x」が表示されます。"
    },
    {
      "indent": 3,
      "text": "X * Y mod p It indicates a multiplication of X and Y modulo prime p.",
      "ja": "X * Y mod pプライムpを法とするXおよびYの乗算を示します。"
    },
    {
      "indent": 3,
      "text": "X = g^x mod p The g^x indicates a multiplication computation of g by x times. The resultant value modulo prime p is assigned to X. The discrete logarithm problem says that it is computationally hard to compute the discrete logarithm x from X, g, and p.",
      "ja": "X = g ^ x mod p g ^ xは、gのx倍の乗算計算を示します。結果の値を法とする素数pがXに割り当てられます。離散対数問題は、X、g、およびpから離散対数xを計算することが計算的に難しいことを示しています。"
    },
    {
      "indent": 3,
      "text": "w The password remembered by the user. This password may be used as an effective password (instead of itself) in the form of H'(0x00 | U | S | w).",
      "ja": "wユーザーが覚えているパスワード。このパスワードは、H '（0x00 | U | S | w）の形式で（それ自体ではなく）有効なパスワードとして使用できます。"
    },
    {
      "indent": 3,
      "text": "W The password verifier registered in the server. This password verifier is computed as follows: W = g^w mod p where the user's password w is used itself, or W = g^w' mod p where the effective password w' = H'(0x00 | U | S | w) is used.",
      "ja": "Wサーバーに登録されているパスワード検証。このパスワード検証は、次のように計算されます。W= g ^ w mod p（ユーザーのパスワードw自体が使用される）またはW = g ^ w 'mod p（有効なパスワードw' = H '（0x00 | U | S | w） ） 使用されている。"
    },
    {
      "indent": 3,
      "text": "bn2bin(X) It indicates a conversion of a multiple precision integer X to the corresponding binary string. If X is an element over GF(p), its binary representation MUST have the same bit length as the binary representation of prime p.",
      "ja": "bn2bin（X）倍精度整数Xから対応するバイナリ文字列への変換を示します。 XがGF（p）上の要素である場合、そのバイナリ表現は素数pのバイナリ表現と同じビット長でなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "U -> S: msg It indicates a message transmission that the user U sends a message msg to the server S.",
      "ja": "U-> S：msgこれは、ユーザーUがメッセージmsgをサーバーSに送信するメッセージ送信を示します。"
    },
    {
      "indent": 3,
      "text": "U: It indicates a local computation of user U (without any outgoing messages).",
      "ja": "U：ユーザーUのローカル計算を示します（送信メッセージなし）。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Password Processing",
      "section_title": true,
      "ja": "2.2.1. パスワード処理"
    },
    {
      "indent": 3,
      "text": "The input password MUST be processed according to the rules of the [RFC4013] profile of [RFC3454]. The password SHALL be considered a \"stored string\" per [RFC3454], and unassigned code points are therefore prohibited. The output SHALL be the binary representation of the processed UTF-8 character string. Prohibited output and unassigned code points encountered in SASLprep pre-processing SHALL cause a failure of pre-processing, and the output SHALL NOT be used with the AugPAKE protocol.",
      "ja": "入力パスワードは、[RFC3454]の[RFC4013]プロファイルのルールに従って処理される必要があります。パスワードは[RFC3454]による「格納された文字列」と見なされる必要があり、したがって、割り当てられていないコードポイントは禁止されています。出力は、処理されたUTF-8文字列のバイナリ表現である必要があります。 SASLprepの前処理で禁止された出力と未割り当てのコードポイントが発生すると、前処理が失敗し、出力はAugPAKEプロトコルでは使用されません。"
    },
    {
      "indent": 3,
      "text": "The following table shows examples of how various character data is transformed by the rules of the [RFC4013] profile.",
      "ja": "次の表は、[RFC4013]プロファイルのルールによってさまざまな文字データがどのように変換されるかの例を示しています。"
    },
    {
      "indent": 3,
      "text": "#  Input            Output     Comments\n-  -----            ------     --------\n1  I<U+00AD>X       IX         SOFT HYPHEN mapped to nothing\n2  user             user       no transformation\n3  USER             USER       case preserved, will not match #2\n4  <U+00AA>         a          output is NFKC, input in ISO 8859-1\n5  <U+2168>         IX         output is NFKC, will match #1\n6  <U+0007>                    Error - prohibited character\n7  <U+0627><U+0031>            Error - bidirectional check",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.3. Protocol",
      "section_title": true,
      "ja": "2.3. プロトコル"
    },
    {
      "indent": 3,
      "text": "The AugPAKE protocol consists of two phases: initialization and actual protocol execution. The initialization phase SHOULD be finished in a secure manner between the user and the server, and it is performed all at once. Whenever the user and the server need to establish a secure channel, they can run the actual protocol execution through an open network (i.e., the Internet) in which an active attacker exists.",
      "ja": "AugPAKEプロトコルは、初期化と実際のプロトコル実行の2つのフェーズで構成されます。初期化フェーズは、ユーザーとサーバーの間で安全な方法で終了する必要があり（SHOULD）、一度に実行されます。ユーザーとサーバーが安全なチャネルを確立する必要があるときはいつでも、アクティブな攻撃者が存在するオープンネットワーク（つまり、インターネット）を介して実際のプロトコル実行を実行できます。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Initialization",
      "section_title": true,
      "ja": "2.3.1. 初期化"
    },
    {
      "indent": 3,
      "text": "U -> S: (U, W) The user U computes W = g^w' mod p, where w' is the effective password, and transmits W to the server S. The W is registered in the server as the password verifier of user U. Of course, user U just remembers password w only.",
      "ja": "U-> S：（U、W）ユーザーUはW = g ^ w 'mod pを計算します。ここで、w'は有効なパスワードであり、WをサーバーSに送信します。Wはパスワード検証としてサーバーに登録されていますもちろん、ユーザーUはパスワードwだけを覚えています。"
    },
    {
      "indent": 3,
      "text": "If resistance to server compromise is not necessary and a node needs to act as both initiator and responder, e.g., as a gateway, then the node can store w' instead of W even when it acts as server S. In either case, server S SHOULD NOT store any plaintext passwords.",
      "ja": "サーバーの侵害への抵抗が不要であり、ノードがイニシエーターとレスポンダーの両方（ゲートウェイなど）として機能する必要がある場合、ノードはサーバーSとして機能する場合でも、Wではなくw 'を格納できます。どちらの場合でも、サーバーSプレーンテキストのパスワードは保存しないでください。"
    },
    {
      "indent": 3,
      "text": "As noted above, this phase SHOULD be performed securely and all at once.",
      "ja": "上記のように、このフェーズは安全かつ一度に実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Actual Protocol Execution",
      "section_title": true,
      "ja": "2.3.2. 実際のプロトコル実行"
    },
    {
      "indent": 3,
      "text": "The actual protocol execution of the AugPAKE protocol allows the user and the server to share an authenticated session key through an open network (see Figure 1).",
      "ja": "AugPAKEプロトコルの実際のプロトコル実行により、ユーザーとサーバーはオープンネットワークを通じて認証されたセッションキーを共有できます（図1を参照）。"
    },
    {
      "indent": 3,
      "text": "+-----------------+                              +------------------+\n|     User U      |                              |  Server S (U,W)  |\n|                 |            (U, X)            |                  |\n|                 |----------------------------->|                  |\n|                 |                              |                  |\n|                 |            (S, Y)            |                  |\n|                 |<-----------------------------|                  |\n|                 |                              |                  |\n|                 |             V_U              |                  |\n|                 |----------------------------->|                  |\n|                 |                              |                  |\n|                 |             V_S              |                  |\n|                 |<-----------------------------|                  |\n|                 |                              |                  |\n+-----------------+                              +------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 1: Actual Protocol Execution",
      "ja": "図1：実際のプロトコル実行"
    },
    {
      "indent": 3,
      "text": "U -> S: (U, X) The user U chooses a random element x from Z_q^* and computes its Diffie-Hellman public value X = g^x mod p. The user sends the first message (U, X) to the server S.",
      "ja": "U-> S：（U、X）ユーザーUはZ_q ^ *からランダムな要素xを選択し、そのDiffie-Hellman公開値X = g ^ x mod pを計算します。ユーザーは最初のメッセージ（U、X）をサーバーSに送信します。"
    },
    {
      "indent": 3,
      "text": "S -> U: (S, Y)\n   If the received X from user U is 0, 1, or -1 (mod p), server S\n   MUST terminate the protocol execution.  Otherwise, the server\n   chooses a random element y from Z_q^* and computes Y = (X *\n   (W^r))^y mod p where r = H'(0x01 | U | S | bn2bin(X)).  Note that\n   X^y * g^(w * r * y) mod p can be computed from y and (w * r * y)\n   efficiently using Shamir's trick [MOV97].  Then, server S sends\n   the second message (S, Y) to the user U.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "U -> S: V_U If the received Y from server S is 0, 1, or -1 (mod p), user U MUST terminate the protocol execution. Otherwise, the user computes K = Y^z mod p where z = 1 / (x + (w * r)) mod q and r = H'(0x01 | U | S | bn2bin(X)). Also, user U generates an authenticator V_U = H(0x02 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)). Then, the user sends the third message V_U to the server S.",
      "ja": "U-> S：V_UサーバーSから受信したYが0、1、または-1（mod p）の場合、ユーザーUはプロトコルの実行を終了しなければなりません（MUST）。それ以外の場合、ユーザーはK = Y ^ z mod pを計算します。ここで、z = 1 /（x +（w * r））mod qおよびr = H '（0x01 | U | S | bn2bin（X））です。また、ユーザーUはオーセンティケーターV_U = H（0x02 | U | S | bn2bin（X）| bn2bin（Y）| bn2bin（K））を生成します。次に、ユーザは第３のメッセージＶ＿ＵをサーバＳに送信する。"
    },
    {
      "indent": 3,
      "text": "S -> U: V_S If the received V_U from user U is not equal to H(0x02 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)) where K = g^y mod p, server S MUST terminate the protocol execution. Otherwise, the server generates an authenticator V_S = H(0x03 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)) and a session key SK = H(0x04 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)). Then, server S sends the fourth message V_S to the user U.",
      "ja": "S-> U：V_SユーザーUから受信したV_UがH（0x02 | U | S | bn2bin（X）| bn2bin（Y）| bn2bin（K））と等しくない場合、K = g ^ y mod p、サーバーSはプロトコル実行を終了しなければなりません。それ以外の場合、サーバーはオーセンティケーターV_S = H（0x03 | U | S | bn2bin（X）| bn2bin（Y）| bn2bin（K））およびセッションキーSK = H（0x04 | U | S | bn2bin（X）を生成します| bn2bin（Y）| bn2bin（K））。次に、サーバーSは4番目のメッセージV_SをユーザーUに送信します。"
    },
    {
      "indent": 3,
      "text": "U: If the received V_S from server S is not equal to H(0x03 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)), user U MUST terminate the protocol execution. Otherwise, the user generates a session key SK = H(0x04 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)).",
      "ja": "U：サーバーSから受信したV_SがH（0x03 | U | S | bn2bin（X）| bn2bin（Y）| bn2bin（K））に等しくない場合、ユーザーUはプロトコル実行を終了する必要があります。それ以外の場合、ユーザーはセッションキーSK = H（0x04 | U | S | bn2bin（X）| bn2bin（Y）| bn2bin（K））を生成します。"
    },
    {
      "indent": 3,
      "text": "In the actual protocol execution, the sequential order of message exchanges is very important to avoid any possible attacks. For example, if the server S sends the second message (S, Y) and the fourth message V_S together, any attacker can easily derive the correct password w with off-line dictionary attacks.",
      "ja": "実際のプロトコル実行では、起こり得る攻撃を回避するために、メッセージ交換の順番が非常に重要です。たとえば、サーバーSが2番目のメッセージ（S、Y）と4番目のメッセージV_Sを一緒に送信する場合、攻撃者はオフライン辞書攻撃で簡単に正しいパスワードwを導き出すことができます。"
    },
    {
      "indent": 3,
      "text": "The session key SK, shared only if the user and the server authenticate each other successfully, MAY be generated by using a key derivation function (KDF) [SP800-108]. After generating SK, the user and the server MUST delete all the internal states (e.g., Diffie-Hellman exponents x and y) from memory.",
      "ja": "ユーザーとサーバーが相互に正常に認証された場合にのみ共有されるセッションキーSKは、キー導出関数（KDF）[SP800-108]を使用して生成される場合があります。 SKを生成した後、ユーザーとサーバーはメモリからすべての内部状態（Diffie-Hellman指数xとyなど）を削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the formal proof [SKI10] of the AugPAKE protocol, we need to\nslightly change the computation of Y (in the above S -> U: (S, Y))\nand K (in the above S -> U: V_S) as follows: Y = (X * (W^r))^y' and K\n= g^y' where y' = H'(0x05 | bn2bin(y)).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section shows why the AugPAKE protocol (i.e., the actual protocol execution) is secure against passive attacks, active attacks, and off-line dictionary attacks, and also provides resistance to server compromise.",
      "ja": "このセクションでは、AugPAKEプロトコル（つまり、実際のプロトコル実行）がパッシブ攻撃、アクティブ攻撃、オフライン辞書攻撃に対して安全であり、サーバーの侵害に対する抵抗力を提供する理由を示します。"
    },
    {
      "indent": 0,
      "text": "3.1. General Assumptions",
      "section_title": true,
      "ja": "3.1. 一般的な仮定"
    },
    {
      "indent": 3,
      "text": "o An attacker is computationally bounded.",
      "ja": "o 攻撃者は計算的に制限されています。"
    },
    {
      "indent": 3,
      "text": "o Any hash functions used in the AugPAKE protocol are secure in terms of pre-image resistance (one-wayness), second pre-image resistance, and collision resistance.",
      "ja": "o AugPAKEプロトコルで使用されるハッシュ関数は、プリイメージ耐性（一方向性）、2番目のプリイメージ耐性、および衝突耐性の点で安全です。"
    },
    {
      "indent": 0,
      "text": "3.2. Security against Passive Attacks",
      "section_title": true,
      "ja": "3.2. 受動的攻撃に対するセキュリティ"
    },
    {
      "indent": 3,
      "text": "An augmented PAKE protocol is said to be secure against passive attacks in the sense that an attacker, who eavesdrops the exchanged messages, cannot compute an authenticated session key (shared between the honest parties in the protocol).",
      "ja": "拡張されたPAKEプロトコルは、交換されたメッセージを盗聴する攻撃者が認証されたセッションキー（プロトコルの正直なパーティ間で共有）を計算できないという意味で、パッシブ攻撃に対して安全であると言われています。"
    },
    {
      "indent": 3,
      "text": "In the AugPAKE protocol, an attacker can get the messages (U, X), (S,Y), V_U, V_S by eavesdropping, and then wants to compute the session key SK. That is, the attacker's goal is to derive the correct K from the obtained messages X and Y, because the hash functions are secure and the only secret in the computation of SK is K = g^y mod p. Note that",
      "ja": "AugPAKEプロトコルでは、攻撃者はメッセージ（U、X）、（S、Y）、V_U、V_Sを盗聴して取得し、セッションキーSKを計算する必要があります。つまり、ハッシュ関数は安全であり、SKの計算における唯一の秘密はK = g ^ y mod pであるため、攻撃者の目的は、取得したメッセージXおよびYから正しいKを導出することです。ご了承ください"
    },
    {
      "indent": 3,
      "text": "X = g^x mod p and",
      "ja": "X = g ^ x mod pおよび"
    },
    {
      "indent": 3,
      "text": "Y =     (X * (W^r))^y = X^y * W^(r * y) = X^y * (g^y)^t = X^y * K^t",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "hold where t = w' * r mod q. Though t is determined from possible password candidates and X, the only way for the attacker to extract K from X and Y is to compute X^y. However, the probability for the attacker to compute X^y is negligible in the security parameter for the underlying groups since both x and y are random elements chosen from Z_q^*. Therefore, the AugPAKE protocol is secure against passive attacks.",
      "ja": "ここでt = w '* r mod qを保持します。 tは可能なパスワード候補とXから決定されますが、攻撃者がXとYからKを抽出する唯一の方法はX ^ yを計算することです。ただし、xとyの両方がZ_q ^ *から選択されたランダムな要素であるため、攻撃者がX ^ yを計算する確率は、基になるグループのセキュリティパラメーターでは無視できます。したがって、AugPAKEプロトコルはパッシブ攻撃に対して安全です。"
    },
    {
      "indent": 0,
      "text": "3.3. Security against Active Attacks",
      "section_title": true,
      "ja": "3.3. アクティブな攻撃に対するセキュリティ"
    },
    {
      "indent": 3,
      "text": "An augmented PAKE protocol is said to be secure against active attacks in the sense that an attacker, who completely controls the exchanged messages, cannot compute an authenticated session key (shared with the honest party in the protocol) with the probability better than that of on-line dictionary attacks. In other words, the probability for an active attacker to compute the session key is restricted by the on-line dictionary attacks where it grows linearly to the number of interactions with the honest party.",
      "ja": "強化されたPAKEプロトコルは、交換されたメッセージを完全に制御する攻撃者が、認証されたセッションキー（プロトコルの正直なパーティと共有）をオンの確率よりも高い確率で計算できないという意味で、アクティブな攻撃に対して安全であると言われています-line辞書攻撃。言い換えると、アクティブな攻撃者がセッションキーを計算する確率は、オンラインの辞書攻撃によって制限され、正直なパーティとの相互作用の数に比例して増加します。"
    },
    {
      "indent": 3,
      "text": "In the AugPAKE protocol, the user (respectively, the server) computes the session key SK only if the received authenticator V_S (respectively, V_U) is valid. There are three cases to be considered in the active attacks.",
      "ja": "AugPAKEプロトコルでは、ユーザー（またはサーバー）は、受信した認証者V_S（それぞれV_U）が有効な場合にのみ、セッションキーSKを計算します。アクティブな攻撃で考慮すべき3つのケースがあります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Impersonation Attacks on User U",
      "section_title": true,
      "ja": "3.3.1. ユーザーUへのなりすまし攻撃"
    },
    {
      "indent": 0,
      "text": " When an attacker impersonates the user U, the attacker can compute the same SK (to be shared with the server S) only if the authenticator V_U is valid. For a valid authenticator V_U, the attacker has to compute the correct K from X and Y because the hash functions are secure. In this impersonation attack, the attacker of course knows the discrete logarithm x of X and guesses a password w'' from the password dictionary. So, the probability for the attacker to compute the correct K is bounded by the probability of w = w''. That is, this impersonation attack is restricted by the on-line dictionary attacks where the attacker can try a guessed password communicating with the honest server S. Therefore, the AugPAKE protocol is secure against impersonation attacks on user U.",
      "ja": "攻撃者がユーザーUを偽装すると、認証者V_Uが有効である場合にのみ、攻撃者は同じSK（サーバーSと共有される）を計算できます。有効な認証者V_Uの場合、ハッシュ関数は安全であるため、攻撃者はXとYから正しいKを計算する必要があります。このなりすまし攻撃では、攻撃者はもちろんXの離散対数xを知っており、パスワードディクショナリからパスワードw ''を推測します。したがって、攻撃者が正しいKを計算する確率は、w = w ''の確率によって制限されます。つまり、このなりすまし攻撃は、攻撃者が正直なサーバーSと通信する推測されたパスワードを試すことができるオンライン辞書攻撃によって制限されます。したがって、AugPAKEプロトコルは、ユーザーUへのなりすまし攻撃に対して安全です。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Impersonation Attacks on Server S",
      "section_title": true,
      "ja": "3.3.2. サーバーSへのなりすまし攻撃"
    },
    {
      "indent": 3,
      "text": "When an attacker impersonates the server S, the attacker can compute the same SK (to be shared with the user U) only if the authenticator V_S is valid. For a valid authenticator V_S, the attacker has to compute the correct K from X and Y because the hash functions are secure. In this impersonation attack, the attacker chooses a random element y and guesses a password w'' from the password dictionary so that",
      "ja": "攻撃者がサーバーSを偽装すると、認証者V_Sが有効な場合にのみ、攻撃者は同じSK（ユーザーUと共有される）を計算できます。有効なオーセンティケーターV_Sの場合、ハッシュ関数は安全であるため、攻撃者はXとYから正しいKを計算する必要があります。このなりすまし攻撃では、攻撃者はランダムな要素yを選択し、パスワードディクショナリからパスワードw ''を推測します。"
    },
    {
      "indent": 3,
      "text": "Y =     (X * (W'^r))^y = X^y * W'^(r * y) = X^y * (g^y)^t'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where t' = w'' * r mod q. The probability for the attacker to compute the correct K is bounded by the probability of w = w''. Also, the attacker knows whether the guessed password is equal to w or not by seeing the received authenticator V_U. However, when w is not equal to w'', the probability for the attacker to compute the correct K is negligible in the security parameter for the underlying groups since the attacker has to guess the discrete logarithm x (chosen by user U) as well. That is, this impersonation attack is restricted by the on-line dictionary attacks where the attacker can try a guessed password communicating with the honest user U. Therefore, the AugPAKE protocol is secure against impersonation attacks on server S.",
      "ja": "ここで、t '= w' '* r mod qです。攻撃者が正しいKを計算する確率は、w = w ''の確率によって制限されます。また、攻撃者は、受け取った認証者V_Uを見ることで、推測されたパスワードがwに等しいかどうかを知ることができます。ただし、wがw ''と等しくない場合、攻撃者が離散対数x（ユーザーUが選択）も推測する必要があるため、攻撃者が正しいKを計算する確率は、基になるグループのセキュリティパラメーターでは無視できます。 。つまり、このなりすまし攻撃は、攻撃者が正直なユーザーUと通信する推測されたパスワードを試すことができるオンライン辞書攻撃によって制限されます。したがって、サーバーSでのなりすまし攻撃に対してAugPAKEプロトコルは安全です。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Man-in-the-Middle Attacks",
      "section_title": true,
      "ja": "3.3.3. 中間者攻撃"
    },
    {
      "indent": 0,
      "text": " When an attacker performs the man-in-the-middle attack, the attacker can compute the same SK (to be shared with the user U or the server S) only if one of the authenticators V_U, V_S is valid. Note that if the attacker relays the exchanged messages honestly, it corresponds to the passive attacks. In order to generate a valid authenticator V_U or V_S, the attacker has to compute the correct K from X and Y because the hash functions are secure. So, the attacker is in the same situation as discussed above. Though the attacker can test two passwords (one with user U and the other with server S), it does not change the fact that this attack is restricted by the on-line dictionary attacks where the attacker can try a guessed password communicating with the honest party. Therefore, the AugPAKE protocol is also secure against man-in-the-middle attacks.",
      "ja": "攻撃者が中間者攻撃を実行すると、認証者V_U、V_Sのいずれかが有効な場合にのみ、攻撃者は同じSK（ユーザーUまたはサーバーSと共有される）を計算できます。攻撃者が交換されたメッセージを正直にリレーする場合、それはパッシブ攻撃に対応することに注意してください。有効なオーセンティケーターV_UまたはV_Sを生成するには、ハッシュ関数が安全であるため、攻撃者はXとYから正しいKを計算する必要があります。したがって、攻撃者は前述の状況と同じです。攻撃者は2つのパスワード（1つはユーザーUで、もう1つはサーバーSで）をテストできますが、この攻撃がオンライン辞書攻撃によって制限されているという事実は変わりません。パーティー。したがって、AugPAKEプロトコルは中間者攻撃に対しても安全です。"
    },
    {
      "indent": 0,
      "text": "3.4. Security against Off-line Dictionary Attacks",
      "section_title": true,
      "ja": "3.4. オフライン辞書攻撃に対するセキュリティ"
    },
    {
      "indent": 3,
      "text": "An augmented PAKE protocol is said to be secure against off-line dictionary attacks in the sense that an attacker, who completely controls the exchanged messages, cannot reduce the possible password candidates better than on-line dictionary attacks. Note that in the on-line dictionary attacks, an attacker can test one guessed password by running the protocol execution (i.e., communicating with the honest party).",
      "ja": "強化されたPAKEプロトコルは、交換されたメッセージを完全に制御する攻撃者が、考えられるパスワード候補をオンライン辞書攻撃よりも減らすことができないという意味で、オフライン辞書攻撃に対して安全であると言われています。オンライン辞書攻撃では、攻撃者はプロトコルの実行（つまり、正直なパーティーとの通信）を実行することで、推測された1つのパスワードをテストできます。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.2, an attacker in the passive attacks does not compute X^y (and the correct K = g^y mod p) from the obtained messages X, Y. This security analysis also indicates that, even if the attacker can guess a password, the K is derived independently from the guessed password. Next, we consider an active attacker whose main goal is to perform the off-line dictionary attacks in the AugPAKE protocol. As in Section 3.3, the attacker can 1) test one guessed password by impersonating the user U or the server S, or 2) test two guessed passwords by impersonating the server S (to the honest user U) and impersonating the user U (to the honest server S) in the man-in-the-middle attacks. Whenever the honest party receives an invalid authenticator, the party terminates the actual protocol execution without sending any message. In fact, this is important to prevent an attacker from testing more than one password in the active attacks. Since passive attacks and active attacks cannot remove the possible password candidates more efficiently than on-line dictionary attacks, the AugPAKE protocol is secure against off-line dictionary attacks.",
      "ja": "セクション3.2で説明したように、パッシブ攻撃の攻撃者は、取得したメッセージX、YからX ^ y（および正しいK = g ^ y mod p）を計算しません。このセキュリティ分析は、攻撃者がパスワードを推測すると、Kは推測されたパスワードから独立して導出されます。次に、AugPAKEプロトコルでオフライン辞書攻撃を実行することを主な目的とするアクティブな攻撃者について考えます。セクション3.3と同様に、攻撃者は1）ユーザーUまたはサーバーSになりすまして1つの推測パスワードをテストするか、2）サーバーS（正直なユーザーUに）になりすましてユーザーU（サーバー中間者攻撃における正直なサーバーS）。正直なパーティが無効なオーセンティケータを受信すると、パーティはメッセージを送信せずに実際のプロトコル実行を終了します。実際、これは攻撃者がアクティブな攻撃で複数のパスワードをテストすることを防ぐために重要です。パッシブ攻撃とアクティブ攻撃は、考えられるパスワード候補をオンライン辞書攻撃よりも効率的に削除できないため、AugPAKEプロトコルはオフライン辞書攻撃に対して安全です。"
    },
    {
      "indent": 0,
      "text": "3.5. Resistance to Server Compromise",
      "section_title": true,
      "ja": "3.5. サーバーの侵害に対する抵抗"
    },
    {
      "indent": 3,
      "text": "We consider an attacker who has obtained a (user's) password verifier from a server. In the (augmented) PAKE protocols, there are two limitations [BJKMRSW00]: 1) the attacker can find out the correct password from the password verifier with the off-line dictionary attacks because the verifier has the same entropy as the password; and 2) if the attacker impersonates the server with the password verifier, this attack is always possible because the attacker has enough information to simulate the server. An augmented PAKE protocol is said to provide resistance to server compromise in the sense that the attacker cannot impersonate the user without performing off-line dictionary attacks on the password verifier.",
      "ja": "サーバーから（ユーザーの）パスワード検証を取得した攻撃者を考慮します。 （拡張された）PAKEプロトコルでは、2つの制限があります[BJKMRSW00]。1）検証者はパスワードと同じエントロピーを持っているため、攻撃者はオフライン辞書攻撃でパスワード検証者から正しいパスワードを見つけることができます。 2）攻撃者がパスワード検証ツールを使用してサーバーを偽装する場合、攻撃者はサーバーをシミュレートするために十分な情報を持っているため、この攻撃は常に可能です。強化されたPAKEプロトコルは、攻撃者がパスワード検証でオフラインの辞書攻撃を実行せずにユーザーを偽装できないという意味で、サーバーの侵害に対する抵抗力を提供すると言われています。"
    },
    {
      "indent": 0,
      "text": " In order to show resistance to server compromise in the AugPAKE protocol, we consider an attacker who has obtained the password verifier W and then tries to impersonate the user U without off-line dictionary attacks on W. As a general attack, the attacker chooses two random elements c and d from Z_q^*, and computes",
      "ja": "AugPAKEプロトコルでサーバーの侵害に対する抵抗力を示すために、パスワード検証者Wを取得し、Wへのオフライン辞書攻撃なしにユーザーUになりすまそうとする攻撃者を考えます。一般的な攻撃として、攻撃者は2つを選択しますZ_q ^ *からのランダム要素cおよびd、および計算"
    },
    {
      "indent": 3,
      "text": "X =     (g^c) * (W^d) mod p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and sends the first message (U, X) to the server S. In order to impersonate user U successfully, the attacker has to compute the correct K = g^y mod p where y is randomly chosen by server S. After receiving Y from the server, the attacker's goal is to find out a value e satisfying Y^e = K mod p. That is,",
      "ja": "そして、最初のメッセージ（U、X）をサーバーSに送信します。ユーザーUを偽装するには、攻撃者は正しいK = g ^ y mod pを計算する必要があります。ここで、yはサーバーSによってランダムに選択されます。サーバーの場合、攻撃者の目標は、Y ^ e = K mod pを満たす値eを見つけることです。あれは、"
    },
    {
      "indent": 12,
      "text": "log_g (Y^e) = log_g K mod q",
      "ja": "log_g（Y ^ e）= log_g K mod q"
    },
    {
      "indent": 12,
      "text": "(c + (w' * d) + (w' * r)) * y * e = y mod q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "(c + w' * (d + r)) * e = 1 mod q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where log_g K indicates the logarithm of K to the base g. Since there is no off-line dictionary attacks on W, the above solution is that e = 1 / c mod q and d = -r mod q. However, the latter is not possible since r is determined by X (i.e., r = H'(0x01 | U | S | bn2bin(X))) and H' is a secure hash function. Therefore, the AugPAKE protocol provides resistance to server compromise.",
      "ja": "ここで、log_g Kは、底gに対するKの対数を示します。 Wにはオフラインの辞書攻撃がないため、上記の解決策はe = 1 / c mod qおよびd = -r mod qです。ただし、後者は不可能です。rはX（つまり、r = H '（0x01 | U | S | bn2bin（X）））によって決定され、H'は安全なハッシュ関数だからです。したがって、AugPAKEプロトコルはサーバーの侵害に対する耐性を提供します。"
    },
    {
      "indent": 0,
      "text": "4. Implementation Consideration",
      "section_title": true,
      "ja": "4. 実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3, the AugPAKE protocol is secure against passive attacks, active attacks, and off-line dictionary attacks, and provides resistance to server compromise. However, an attacker in the on-line dictionary attacks can check whether one password (guessed from the password dictionary) is correct or not by interacting with the honest party. Let N be the number of possible passwords within a dictionary. Certainly, the attacker's success probability grows with the probability of (I / N) where I is the number of interactions with the honest party. In order to provide a reasonable security margin, implementation SHOULD take a countermeasure to the on-line dictionary attacks. For example, it would take about 90 years to test 2^(25.5) passwords with a one minute lock-out for 3 failed password guesses (see Appendix A in [SP800-63]).",
      "ja": "セクション3で説明したように、AugPAKEプロトコルはパッシブ攻撃、アクティブ攻撃、オフライン辞書攻撃に対して安全であり、サーバーの侵害に対する抵抗力を提供します。ただし、オンライン辞書攻撃の攻撃者は、正直なパーティーと対話することにより、（パスワード辞書から推測された）1つのパスワードが正しいかどうかを確認できます。 Nを辞書内の可能なパスワードの数とします。確かに、攻撃者の成功確率は（I / N）の確率で増加します。ここで、Iは正直なパーティーとの対話の数です。妥当なセキュリティマージンを提供するために、実装ではオンライン辞書攻撃への対策を講じるべきです（SHOULD）。たとえば、3回の失敗したパスワード推測に対して1分のロックアウトで2 ^（25.5）パスワードをテストするには、約90年かかります（[SP800-63]の付録Aを参照）。"
    },
    {
      "indent": 0,
      "text": "5. AugPAKE for IKEv2",
      "section_title": true,
      "ja": "5. AugPAKE for IKEv2"
    },
    {
      "indent": 0,
      "text": "5.1. Integration into IKEv2",
      "section_title": true,
      "ja": "5.1. IKEv2への統合"
    },
    {
      "indent": 3,
      "text": "IKE is a primary component of IPsec in order to provide mutual authentication and establish security associations between two peers.",
      "ja": "IKEは、相互認証を提供し、2つのピア間にセキュリティアソシエーションを確立するためのIPsecの主要コンポーネントです。"
    },
    {
      "indent": 3,
      "text": "The AugPAKE protocol, described in Section 2, can be easily integrated into IKEv2 [RFC5996] as a \"weak\" pre-shared key authentication method (see Figure 2). This integrated protocol preserves the IKEv2 structure and security guarantees (e.g., identity protection). Note that the AugPAKE protocol can be used in three scenarios for IKEv2: \"Security Gateway to Security Gateway Tunnel\", \"Endpoint-to-Endpoint Transport\", and \"Endpoint to Security Gateway Tunnel\".",
      "ja": "セクション2で説明したAugPAKEプロトコルは、「弱い」事前共有キー認証方式としてIKEv2 [RFC5996]に簡単に統合できます（図2を参照）。この統合プロトコルは、IKEv2構造とセキュリティの保証（ID保護など）を保持します。 AugPAKEプロトコルは、IKEv2の3つのシナリオ、「セキュリティゲートウェイからセキュリティゲートウェイへのトンネル」、「エンドポイントからエンドポイントへのトランスポート」、および「エンドポイントからセキュリティゲートウェイへのトンネル」で使用できることに注意してください。"
    },
    {
      "indent": 3,
      "text": " Initiator                               Responder\n-----------                             -----------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IKE_SA_INIT:",
      "ja": "IKE_SA_INIT："
    },
    {
      "indent": 4,
      "text": "HDR, SAi1, KEi, Ni, N(SECURE_PASSWORD_METHODS) --> <-- HDR, SAr1, KEr, Nr, N(SECURE_PASSWORD_METHODS)",
      "ja": "HDR、SAi1、KEi、Ni、N（SECURE_PASSWORD_METHODS）-> <-HDR、SAr1、KEr、Nr、N（SECURE_PASSWORD_METHODS）"
    },
    {
      "indent": 3,
      "text": "IKE_AUTH:",
      "ja": "いけ＿あうＴＨ："
    },
    {
      "indent": 4,
      "text": "HDR, SK {IDi, GSPM(PVi), [IDr,]\n         SAi2, TSi, TSr}        -->\n                                <--  HDR, SK {IDr, GSPM(PVr)}\nHDR, SK {AUTHi}                 -->\n                                <--  HDR, SK {AUTHr, SAr2, TSi, TSr}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 2: AugPAKE into IKEv2",
      "ja": "図2：AugPAKEからIKEv2へ"
    },
    {
      "indent": 3,
      "text": "The changes from IKEv2 are summarized as follows:",
      "ja": "IKEv2からの変更点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o In addition to IKEv2, one round trip is added.",
      "ja": "o IKEv2に加えて、往復が1つ追加されます。"
    },
    {
      "indent": 3,
      "text": "o The initiator (respectively, the responder) sends an N(SECURE_PASSWORD_METHODS) notification to indicate its willingness to use AugPAKE in the IKE_SA_INIT exchange.",
      "ja": "o イニシエーター（それぞれレスポンダー）はN（SECURE_PASSWORD_METHODS）通知を送信して、IKE_SA_INIT交換でAugPAKEを使用する意思を示します。"
    },
    {
      "indent": 3,
      "text": "o The added values GSPM(PVi) and GSPM(PVr) in the IKE_AUTH exchange correspond to X and Y of the AugPAKE protocol in Section 2, respectively.",
      "ja": "o IKE_AUTH交換で追加された値GSPM（PVi）およびGSPM（PVr）は、セクション2のAugPAKEプロトコルのXおよびYにそれぞれ対応します。"
    },
    {
      "indent": 3,
      "text": "o From K (represented as an octet string) derived in Section 2, the AUTH values in the IKE_AUTH exchange are computed as",
      "ja": "o セクション2で導出されたK（オクテット文字列として表される）から、IKE_AUTH交換のAUTH値は次のように計算されます。"
    },
    {
      "indent": 0,
      "text": "         AUTHi = prf( prf(K, \"AugPAKE for IKEv2\"),\n         <InitiatorSignedOctets> | GSPM(PVi) | GSPM(PVr) | IDi | IDr)\n         AUTHr = prf( prf(K, \"AugPAKE for IKEv2\"),\n         <ResponderSignedOctets> | GSPM(PVr) | GSPM(PVi) | IDr | IDi)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2. Payload Formats",
      "section_title": true,
      "ja": "5.2. ペイロード形式"
    },
    {
      "indent": 0,
      "text": "5.2.1. Notify Payload",
      "section_title": true,
      "ja": "5.2.1. ペイロードに通知"
    },
    {
      "indent": 3,
      "text": "The Notify Payload N(SECURE_PASSWORD_METHODS) [RFC6467], indicating a willingness to use AugPAKE in the IKE_SA_INIT exchange, is defined as follows:",
      "ja": "Notify Payload N（SECURE_PASSWORD_METHODS）[RFC6467]は、IKE_SA_INIT交換でAugPAKEを使用する意思があることを示し、次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Next Payload  !C!  RESERVED   !         Payload Length        !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!  Protocol ID  !   SPI Size    !      Notify Message Type      !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!                                                               !\n~                Security Parameter Index (SPI)                 ~\n!                                                               !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!                                                               !\n~                       Notification Data                       ~\n!                                                               !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As in [RFC5996], the Protocol ID and SPI Size SHALL be set to zero and, therefore, the SPI field SHALL be empty. The Notify Message Type will be 16424 [RFC6467].",
      "ja": "[RFC5996]と同様に、プロトコルIDとSPIサイズはゼロに設定する必要があるため（SHALL）、したがって、SPIフィールドは空である必要があります（SHALL）。通知メッセージタイプは16424 [RFC6467]になります。"
    },
    {
      "indent": 3,
      "text": "The Notification Data contains the list of the 16-bit secure password method numbers:",
      "ja": "通知データには、16ビットの安全なパスワード方式番号のリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Secure Password Method #1     ! Secure Password Method #2     !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Secure Password Method #3     ! ...                           !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The response Notify Payload contains exactly one 16-bit secure password method number (i.e., for AugPAKE here) inside the Notification Data field.",
      "ja": "応答のNotify Payloadには、通知データフィールド内に16ビットの安全なパスワードメソッド番号（ここではAugPAKEの場合）が1つだけ含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Generic Secure Password Method Payload",
      "section_title": true,
      "ja": "5.2.2. 一般的な安全なパスワード方式のペイロード"
    },
    {
      "indent": 3,
      "text": "The Generic Secure Password Method (GSPM) Payload, denoted GSPM(PV) in Section 5.1, is defined as follows:",
      "ja": "セクション5.1でGSPM（PV）と示されているGeneric Secure Password Method（GSPM）ペイロードは、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Next Payload  !C!  RESERVED   !         Payload Length        !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!                                                               !\n~                                                               ~\n!          Data Specific to the Secure Password Method          !\n~                                                               ~\n!                                                               !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             The GSPM Payload Type will be 49 [RFC6467].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since the GSPM(PV) value is a group element, the encoded octet string is actually used in the \"Data Specific to the Secure Password Method\" field.",
      "ja": "GSPM（PV）値はグループ要素であるため、エンコードされたオクテット文字列は、実際には[Secure Password Methodに固有のデータ]フィールドで使用されます。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned value 2 to the method name \"AugPAKE\" from the \"IKEv2 Secure Password Methods\" registry in [IKEV2-IANA].",
      "ja": "IANAは、[IKEV2-IANA]の「IKEv2セキュアパスワードメソッド」レジストリからメソッド名「AugPAKE」に値2を割り当てました。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS180-3] Information Technology Laboratory, \"Secure Hash Standard (SHS)\", NIST FIPS Publication 180-3, October 2008, <http://csrc.nist.gov/publications/fips/ fips180-3/fips180-3_final.pdf>.",
      "ja": "[FIPS180-3]情報技術研究所、「Secure Hash Standard（SHS）」、NIST FIPS Publication 180-3、2008年10月、<http://csrc.nist.gov/publications/fips/ fips180-3 / fips180-3_final .pdf>。"
    },
    {
      "indent": 3,
      "text": "[IKEV2-IANA] IANA, \"Internet Key Exchange Version 2 (IKEv2) Parameters\", <http://www.iana.org/assignments/ikev2-parameters>.",
      "ja": "[IKEV2-IANA] IANA、「Internet Key Exchange Version 2（IKEv2）Parameters」、<http://www.iana.org/assignments/ikev2-parameters>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3454] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002.",
      "ja": "[RFC3454] Hoffman、P.およびM. Blanchet、「Preparation of Internationalized Strings（ \"stringprep\"）」、RFC 3454、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K。、「SASLprep：Stringprep Profile for User Names and Passwords」、RFC 4013、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4282] Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The Network Access Identifier\", RFC 4282, December 2005.",
      "ja": "[RFC4282] Aboba、B.、Beadles、M.、Arkko、J。、およびP. Eronen、「The Network Access Identifier」、RFC 4282、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[RFC5996] Kaufman、C.、Hoffman、P.、Nir、Y。、およびP. Eronen、「インターネットキー交換プロトコルバージョン2（IKEv2）」、RFC 5996、2010年9月。"
    },
    {
      "indent": 3,
      "text": "[SP800-108] Chen, L., \"Recommendation for Key Derivation Using Pseudorandom Functions (Revised)\", NIST Special Publication 800-108, October 2009, <http://csrc.nist.gov/publications/ nistpubs/800-108/sp800-108.pdf>.",
      "ja": "[SP800-108]チェンL.、「疑似ランダム関数を使用した鍵導出の推奨（改訂版）」、NIST Special Publication 800-108、2009年10月、<http://csrc.nist.gov/publications/nistpubs/800- 108 / sp800-108.pdf>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BJKMRSW00] Bellare, M., Jablon, D., Krawczyk, H., MacKenzie, P., Rogaway, P., Swaminathan, R., and T. Wu, \"Proposal for P1363 Study Group on Password-Based Authenticated-Key-Exchange Methods\", IEEE P1363.2: Password-Based Public-Key Cryptography, Submissions to IEEE P1363.2 , February 2000, <http://grouper.ieee.org/ groups/1363/passwdPK/contributions/p1363-pw.pdf>.",
      "ja": "[BJKMRSW00] Bellare、M.、Jablon、D.、Krawczyk、H.、MacKenzie、P.、Rogaway、P.、Swaminathan、R。、およびT. Wu、「パスワードベースの認証に関するP1363研究グループの提案-鍵交換方法」、IEEE P1363.2：パスワードベースの公開鍵暗号、IEEE P1363.2への提出、2000年2月、<http://grouper.ieee.org/ groups / 1363 / passwdPK / contributions / p1363- pw.pdf>。"
    },
    {
      "indent": 3,
      "text": "[BM92] Bellovin, S. and M. Merritt, \"Encrypted Key Exchange: Password-based Protocols Secure against Dictionary Attacks\", Proceedings of the IEEE Symposium on Security and Privacy, IEEE Computer Society, 1992.",
      "ja": "[BM92] Bellovin、S。およびM. Merritt、「暗号化鍵交換：辞書攻撃に対して安全なパスワードベースのプロトコル」、セキュリティとプライバシーに関するIEEEシンポジウムの議事録、IEEE Computer Society、1992年。"
    },
    {
      "indent": 3,
      "text": "[BM93] Bellovin, S. and M. Merritt, \"Augmented Encrypted Key Exchange: A Password-based Protocol Secure against Dictionary Attacks and Password File Compromise\", Proceedings of the 1st ACM Conference on Computer and Communication Security, ACM Press, 1993.",
      "ja": "[BM93] Bellovin、S。およびM. Merritt、「Augmented Encrypted Key Exchange：A Password-based Protocol Secure Secure for Dictionary Attacks and Password File Compromise」、Proceedings of the first ACM Conference on Computer and Communication Security、ACM Press、1993。"
    },
    {
      "indent": 3,
      "text": "[DH76] Diffie, W. and M. Hellman, \"New Directions in Cryptography\", IEEE Transactions on Information Theory Volume IT-22, Number 6, 1976.",
      "ja": "[DH76] Diffie、W.およびM. Hellman、「暗号化の新しい方向」、IEEE Transactions on Information Theory Volume IT-22、Number 6、1976。"
    },
    {
      "indent": 3,
      "text": "[H10] Harkins, D., \"Password-Based Authentication in IKEv2: Selection Criteria and Considerations\", Work in Progress, October 2010.",
      "ja": "[H10] Harkins、D。、「IKEv2でのパスワードベースの認証：選択基準と考慮事項」、進行中の作業、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[IEEEP1363.2] IEEE P1363.2, \"Password-Based Public-Key Cryptography\", Submissions to IEEE P1363.2 , <http://grouper.ieee.org/ groups/1363/passwdPK/submissions.html>.",
      "ja": "[IEEEP1363.2] IEEE P1363.2、「パスワードベースの公開キー暗号化」、IEEE P1363.2への提出、<http://grouper.ieee.org/ groups / 1363 / passwdPK / submissions.html>。"
    },
    {
      "indent": 3,
      "text": "[ISO] ISO/IEC JTC 1/SC 27 11770-4, \"Information technology -- Security techniques -- Key management -- Part 4: Mechanisms based on weak secrets\", April 2006, <http://www.iso.org/iso/iso_catalogue/catalogue_tc/ catalogue_detail.htm?csnumber=39723>.",
      "ja": "[ISO] ISO / IEC JTC 1 / SC 27 11770-4、「情報技術-セキュリティ技術-鍵管理-パート4：弱い秘密に基づくメカニズム」、2006年4月、<http：//www.iso。 org / iso / iso_catalogue / catalogue_tc / catalogue_detail.htm？csnumber = 39723>。"
    },
    {
      "indent": 3,
      "text": "[MOV97] Menezes, A., Oorschot, P., and S. Vanstone, \"Simultaneous Multiple Exponentiation\", in Handbook of Applied Cryptography, CRC Press, 1997.",
      "ja": "[MOV97] Menezes、A.、Oorschot、P。、およびS. Vanstone、「同時多重指数」、応用暗号のハンドブック、CRC Press、1997年。"
    },
    {
      "indent": 3,
      "text": "[RFC2945] Wu, T., \"The SRP Authentication and Key Exchange System\", RFC 2945, September 2000.",
      "ja": "[RFC2945] Wu、T。、「SRP認証および鍵交換システム」、RFC 2945、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5114] Lepinski, M. and S. Kent, \"Additional Diffie-Hellman Groups for Use with IETF Standards\", RFC 5114, January 2008.",
      "ja": "[RFC5114] Lepinski、M。およびS. Kent、「IETF標準で使用するための追加のDiffie-Hellmanグループ」、RFC 5114、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6467] Kivinen, T., \"Secure Password Framework for Internet Key Exchange Version 2 (IKEv2)\", RFC 6467, December 2011.",
      "ja": "[RFC6467] Kivinen、T。、「インターネットキーエクスチェンジバージョン2（IKEv2）のセキュアパスワードフレームワーク」、RFC 6467、2011年12月。"
    },
    {
      "indent": 3,
      "text": "[SKI10] Shin, S., Kobara, K., and H. Imai, \"Security Proof of AugPAKE\", Cryptology ePrint Archive: Report 2010/334, June 2010, <http://eprint.iacr.org/2010/334>.",
      "ja": "[SKI10]シン、S、コバラ、K、およびイマイ、「AugPAKEのセキュリティ証明」、Cryptology ePrint Archive：Report 2010/334、June 2010、<http://eprint.iacr.org/2010/ 334>。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Johnson, D., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007, <http://csrc.nist.gov/ publications/nistpubs/800-56A/ SP800-56A_Revision1_Mar08-2007.pdf>.",
      "ja": "[SP800-56A] Barker、E.、Johnson、D。、およびM. Smid、「離散対数暗号を使用したペアワイズキー確立スキームの推奨（改訂）」、NIST特別刊行物800-56A、2007年3月、<http ：//csrc.nist.gov/ Publications / nistpubs / 800-56A / SP800-56A_Revision1_Mar08-2007.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-63] Burr, W., Dodson, D., and W. Polk, \"Electronic Authentication Guideline\", NIST Special Publication 800-63 Version 1.0.2, April 2006, <http://csrc.nist.gov/publications/ nistpubs/800-63/SP800-63V1_0_2.pdf>.",
      "ja": "[SP800-63] Burr、W.、Dodson、D。、およびW. Polk、「電子認証ガイドライン」、NIST Special Publication 800-63バージョン1.0.2、2006年4月、<http://csrc.nist.gov / publications / nistpubs / 800-63 / SP800-63V1_0_2.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Evaluation by PAKE Selection Criteria",
      "section_title": true,
      "ja": "付録A. PAKE選択基準による評価"
    },
    {
      "indent": 3,
      "text": "Below is a self-evaluation of the AugPAKE protocol following PAKE selection criteria [H10].",
      "ja": "以下は、PAKE選択基準[H10]に従ったAugPAKEプロトコルの自己評価です。"
    },
    {
      "indent": 3,
      "text": "SEC1: AugPAKE is zero knowledge (password) proof. It is secure against passive/active/off-line dictionary attacks. It is also resistant to server-compromise impersonation attacks.",
      "ja": "SEC1：AugPAKEは知識（パスワード）をまったく証明しません。パッシブ/アクティブ/オフラインの辞書攻撃に対して安全です。また、サーバーを侵害する偽装攻撃にも耐性があります。"
    },
    {
      "indent": 3,
      "text": "SEC2: AugPAKE provides Perfect Forward Secrecy (PFS) and is secure against Denning-Sacco attack.",
      "ja": "SEC2：AugPAKEはPerfect Forward Secrecy（PFS）を提供し、Denning-Sacco攻撃に対して安全です。"
    },
    {
      "indent": 3,
      "text": "SEC3: IKEv2 identity protection is preserved.",
      "ja": "SEC3：IKEv2 ID保護は保持されます。"
    },
    {
      "indent": 3,
      "text": "SEC4: Any cryptographically secure Diffie-Hellman groups can be used.",
      "ja": "SEC4：暗号的に安全なDiffie-Hellmanグループを使用できます。"
    },
    {
      "indent": 3,
      "text": "SEC5: The formal security proof of AugPAKE can be found at [SKI10].",
      "ja": "SEC5：AugPAKEの正式なセキュリティ証明は[SKI10]にあります。"
    },
    {
      "indent": 3,
      "text": "SEC6: AugPAKE can be easily used with strong credentials.",
      "ja": "SEC6：AugPAKEは強力な資格情報で簡単に使用できます。"
    },
    {
      "indent": 3,
      "text": "SEC7: In the case of server compromise, an attacker has to perform off-line dictionary attacks while computing modular exponentiation with a password candidate.",
      "ja": "SEC7：サーバーが侵害された場合、攻撃者はオフラインの辞書攻撃を実行し、パスワード候補を使用してモジュラー指数を計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "SEC8: AugPAKE is secure regardless of the transform negotiated by IKEv2.",
      "ja": "SEC8：AugPAKEは、IKEv2によってネゴシエートされた変換に関係なく安全です。"
    },
    {
      "indent": 3,
      "text": "IPR1: AugPAKE was publicly disclosed on Oct. 2008.",
      "ja": "IPR1：AugPAKEは、2008年10月に公開されました。"
    },
    {
      "indent": 3,
      "text": "IPR2: AIST applied for a patent in Japan on July 10, 2008. AIST would provide royal-free license of AugPAKE.",
      "ja": "IPR2：産総研は2008年7月10日に日本で特許を申請しました。産総研は、AugPAKEのロイヤルティフリーライセンスを提供します。"
    },
    {
      "indent": 3,
      "text": "IPR3: IPR disclosure (see https://datatracker.ietf.org/ipr/1284/)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MISC1: AugPAKE adds one round trip to IKEv2.",
      "ja": "MISC1：AugPAKEは、IKEv2への往復を1つ追加します。"
    },
    {
      "indent": 3,
      "text": "MISC2: The initiator needs to compute only 2 modular exponentiation computations while the responder needs to compute 2.17 modular exponentiation computations. AugPAKE needs to exchange 2 group elements and 2 hash values. This is almost the same computation/communication costs as the plain Diffie-Hellman (DH) key exchange. If we use a large (e.g., 2048/3072-bits) parent group, the hash size would be relatively small.",
      "ja": "MISC2：イニシエーターは2つのモジュラ指数計算のみを計算する必要がありますが、レスポンダーは2.17モジュラー指数計算を計算する必要があります。 AugPAKEは2つのグループ要素と2つのハッシュ値を交換する必要があります。これは、単純なDiffie-Hellman（DH）鍵交換とほぼ同じ計算/通信コストです。大きな（2048/3072ビットなど）親グループを使用する場合、ハッシュサイズは比較的小さくなります。"
    },
    {
      "indent": 3,
      "text": "MISC3: AugPAKE has the same performance for any type of secret.",
      "ja": "MISC3：AugPAKEは、どのタイプのシークレットでも同じパフォーマンスを発揮します。"
    },
    {
      "indent": 3,
      "text": "MISC4: Internationalization of character-based passwords can be supported.",
      "ja": "MISC4：文字ベースのパスワードの国際化をサポートできます。"
    },
    {
      "indent": 3,
      "text": "MISC5: AugPAKE can be implemented over any ECP (Elliptic Curve Group over GF[P]), EC2N (Elliptic Curve Group over GF[2^N]), and MODP (Modular Exponentiation Group) groups.",
      "ja": "MISC5：AugPAKEは、ECP（GF [P]上の楕円曲線グループ）、EC2N（GF [2 ^ N]上の楕円曲線グループ）、およびMODP（モジュラー指数グループ）グループに実装できます。"
    },
    {
      "indent": 3,
      "text": "MISC6: AugPAKE has request/response nature of IKEv2.",
      "ja": "MISC6：AugPAKEには、IKEv2の要求/応答の性質があります。"
    },
    {
      "indent": 3,
      "text": "MISC7: No additional negotiation is needed.",
      "ja": "MISC7：追加の交渉は必要ありません。"
    },
    {
      "indent": 3,
      "text": "MISC8: No Trusted Third Party (TTP) and clock synchronization",
      "ja": "MISC8：Trusted Third Party（TTP）およびクロック同期なし"
    },
    {
      "indent": 3,
      "text": "MISC9: No additional primitive (e.g., Full Domain Hashing (FDH) and/or ideal cipher) is needed.",
      "ja": "MISC9：追加のプリミティブ（フルドメインハッシュ（FDH）や理想的な暗号など）は必要ありません。"
    },
    {
      "indent": 3,
      "text": "MISC10: As above, AugPAKE can be implemented over any ECP/EC2N groups.",
      "ja": "MISC10：上記のように、AugPAKEは任意のECP / EC2Nグループに実装できます。"
    },
    {
      "indent": 3,
      "text": "MISC11: Easy implementation. We already implemented AugPAKE and have been testing in AIST.",
      "ja": "MISC11：簡単な実装。 AugPAKEはすでに実装されており、産総研でテストされています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "SeongHan Shin AIST Central 2, 1-1-1, Umezono Tsukuba, Ibaraki 305-8568 JP",
      "ja": "せおんｇはん しん あいＳＴ せんｔらｌ ２、 １ー１ー１、 うめぞの つくば、 いばらき ３０５ー８５６８ ＪＰ"
    },
    {
      "indent": 3,
      "text": "Phone: +81 29-861-2670\nEMail: seonghan.shin@aist.go.jp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kazukuni Kobara AIST",
      "ja": "かずくに こばら あいＳＴ"
    },
    {
      "indent": 3,
      "text": "EMail: kobara_conf@m.aist.go.jp",
      "raw": true,
      "ja": ""
    }
  ]
}