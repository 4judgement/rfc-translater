{
  "title": {
    "text": "RFC 6865 - Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME",
    "ja": "RFC 6865 - FECFRAME用のシンプルなリードソロモン前方誤り訂正（FEC）スキーム"
  },
  "number": 6865,
  "created_at": "2020-09-04 20:27:25.296657+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           V. Roca\nRequest for Comments: 6865                                         INRIA\nCategory: Standards Track                                      M. Cunche\nISSN: 2070-1721                                          INSA-Lyon/INRIA\n                                                                J. Lacan\n                                                 ISAE, Univ. of Toulouse\n                                                          A. Bouabdallah\n                                                                    CDTA\n                                                            K. Matsuzono\n                                                         Keio University\n                                                           February 2013",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME",
      "ja": "FECFRAME用のシンプルなリードソロモン前方誤り訂正（FEC）スキーム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a fully-specified simple Forward Error Correction (FEC) scheme for Reed-Solomon codes over the finite field (also known as the Galois Field) GF(2^^m), with 2 <= m <= 16, that can be used to protect arbitrary media streams along the lines defined by FECFRAME. The Reed-Solomon codes considered have attractive properties, since they offer optimal protection against packet erasures and the source symbols are part of the encoding symbols, which can greatly simplify decoding. However, the price to pay is a limit on the maximum source block size, on the maximum number of encoding symbols, and a computational complexity higher than that of the Low-Density Parity Check (LDPC) codes, for instance.",
      "ja": "このドキュメントでは、2 <= m <= 16である有限フィールド（ガロア体とも呼ばれる）GF（2 ^^ m）上のリードソロモンコードの完全に指定された単純な前方誤り訂正（FEC）スキームについて説明します。 FECFRAMEで定義されたラインに沿って任意のメディアストリームを保護するために使用できます。検討されているリードソロモンコードは、パケット消去に対する最適な保護を提供し、ソースシンボルがエンコードシンボルの一部であり、デコードを大幅に簡略化できるため、魅力的な特性を備えています。ただし、支払う金額は、最大ソースブロックサイズ、エンコードシンボルの最大数、および低密度パリティチェック（LDPC）コードよりも高い計算の複雑さなどの制限です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6865.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6865で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  Definitions Notations and Abbreviations  . . . . . . . . . . .  5\n  3.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  5\n  3.2.  Notations  . . . . . . . . . . . . . . . . . . . . . . . .  7\n  3.3.  Abbreviations  . . . . . . . . . . . . . . . . . . . . . .  8\n4.  Common Procedures Related to the ADU Block and Source\n    Block Creation . . . . . . . . . . . . . . . . . . . . . . . .  9\n  4.1.  Restrictions . . . . . . . . . . . . . . . . . . . . . . .  9\n  4.2.  ADU Block Creation . . . . . . . . . . . . . . . . . . . .  9\n  4.3.  Source Block Creation  . . . . . . . . . . . . . . . . . . 10\n5.  Simple Reed-Solomon FEC Scheme over GF(2^^m) for Arbitrary\n    ADU Flows  . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n  5.1.  Formats and Codes  . . . . . . . . . . . . . . . . . . . . 12\n    5.1.1.  FEC Framework Configuration Information  . . . . . . . 12\n    5.1.2.  Explicit Source FEC Payload ID . . . . . . . . . . . . 14\n    5.1.3.  Repair FEC Payload ID  . . . . . . . . . . . . . . . . 15\n  5.2.  Procedures . . . . . . . . . . . . . . . . . . . . . . . . 17\n  5.3.  FEC Code Specification . . . . . . . . . . . . . . . . . . 17\n6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 17\n  6.1.  Attacks Against the Data Flow  . . . . . . . . . . . . . . 17\n    6.1.1.  Access to Confidential Content . . . . . . . . . . . . 17\n    6.1.2.  Content Corruption . . . . . . . . . . . . . . . . . . 18\n  6.2.  Attacks Against the FEC Parameters . . . . . . . . . . . . 18\n  6.3.  When Several Source Flows Are to Be Protected Together . . 19\n  6.4.  Baseline Secure FECFRAME Operation . . . . . . . . . . . . 19\n7.  Operations and Management Considerations . . . . . . . . . . . 19\n  7.1.  Operational Recommendations: Finite Field Size (m) . . . . 19\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 20\n9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 20\n10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n  10.1. Normative References . . . . . . . . . . . . . . . . . . . 21\n  10.2. Informative References . . . . . . . . . . . . . . . . . . 21",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The use of the Forward Error Correction (FEC) codes is a classic solution to improve the reliability of unicast, multicast, and broadcast Content Delivery Protocols (CDP) and applications. [RFC6363] describes a generic framework to use FEC schemes with media delivery applications, and for instance with real-time streaming media applications based on the Real-time Transport Protocol (RTP). Similarly, [RFC5052] describes a generic framework to use FEC schemes with object delivery applications (where the objects are files, for example) based on the Asynchronous Layered Coding (ALC) [RFC5775] and NACK-Oriented Reliable Multicast (NORM) [RFC5740] transport protocols.",
      "ja": "Forward Error Correction（FEC）コードの使用は、ユニキャスト、マルチキャスト、およびブロードキャストのコンテンツ配信プロトコル（CDP）とアプリケーションの信頼性を向上させるための古典的なソリューションです。 [RFC6363]は、メディア配信アプリケーションで、たとえばReal-time Transport Protocol（RTP）に基づくリアルタイムストリーミングメディアアプリケーションでFECスキームを使用するための一般的なフレームワークについて説明しています。同様に、[RFC5052]は、非同期レイヤードコーディング（ALC）[RFC5775]およびNACK指向の信頼できるマルチキャスト（NORM）[RFC5740に基づくオブジェクト配信アプリケーション（オブジェクトがファイルなど）でFECスキームを使用するための一般的なフレームワークについて説明]トランスポートプロトコル。"
    },
    {
      "indent": 3,
      "text": "More specifically, the [RFC5053] and [RFC5170] FEC schemes introduce erasure codes based on sparse parity-check matrices for object delivery protocols like ALC and NORM. These codes are efficient in terms of processing but not optimal in terms of erasure recovery capabilities when dealing with \"small\" objects.",
      "ja": "より具体的には、[RFC5053]および[RFC5170] FECスキームは、ALCやNORMなどのオブジェクト配信プロトコル用のスパースパリティチェックマトリックスに基づく消去コードを導入します。これらのコードは、処理の点では効率的ですが、「小さな」オブジェクトを処理する場合の消失回復機能の点では最適ではありません。"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon FEC codes described in this document belong to the class of Maximum Distance Separable (MDS) codes that are optimal in terms of erasure recovery capability. It means that a receiver can recover the k source symbols from any set of exactly k encoding symbols. These codes are also systematic codes, which means that the k source symbols are part of the encoding symbols. However, they are limited in terms of maximum source block size and number of encoding symbols. Since the real-time constraints of media delivery applications usually limit the maximum source block size, this is not considered to be a major issue in the context of FECFRAME for many (but not necessarily all) use cases. Additionally, if the encoding/ decoding complexity is higher with Reed-Solomon codes than it is with [RFC5053] or [RFC5170] codes, it remains reasonable for most use cases, even in case of a software codec.",
      "ja": "このドキュメントで説明されているリードソロモンFECコードは、消失回復能力の点で最適な最大距離分離可能（MDS）コードのクラスに属しています。これは、受信機が正確にk個のエンコーディングシンボルの任意のセットからk個のソースシンボルを復元できることを意味します。これらのコードも体系的なコードです。つまり、k個のソースシンボルがエンコードシンボルの一部です。ただし、最大ソースブロックサイズとエンコードシンボルの数に関しては制限があります。メディア配信アプリケーションのリアルタイム制約は通常、最大ソースブロックサイズを制限するため、これは多くの（必ずしもすべてではない）ユースケースのFECFRAMEのコンテキストでは主要な問題とは見なされません。さらに、[RFC5053]または[RFC5170]コードよりもリードソロモンコードの方がエンコード/デコードの複雑さが高い場合、ソフトウェアコーデックの場合でも、ほとんどのユースケースで妥当です。"
    },
    {
      "indent": 3,
      "text": "Many applications dealing with reliable content transmission or content storage already rely on packet-based Reed-Solomon erasure recovery codes. In particular, many of them use the Reed-Solomon codec of Luigi Rizzo [RS-codec] [Rizzo97]. The goal of the present document is to specify a simple Reed-Solomon scheme that is compatible with this codec.",
      "ja": "信頼性の高いコンテンツ送信またはコンテンツストレージを扱う多くのアプリケーションは、すでにパケットベースのリードソロモン消去リカバリコードに依存しています。特に、それらの多くはルイージ・リッツォのリードソロモンコーデック[RS-コーデック] [Rizzo97]を使用しています。このドキュメントの目的は、このコーデックと互換性のある単純なリードソロモン方式を指定することです。"
    },
    {
      "indent": 0,
      "text": " More specifically, [RFC5510] introduced such Reed-Solomon codes and several associated FEC schemes that are compatible with the [RFC5052] framework. The present document inherits from Section 8 of [RFC5510], \"Reed-Solomon Codes Specification for the Erasure Channel\", the specifications of the core Reed-Solomon codes based on Vandermonde matrices and specifies a simple FEC scheme that is compatible with FECFRAME [RFC6363]:",
      "ja": "より具体的には、[RFC5510]は、そのようなリードソロモンコードと、[RFC5052]フレームワークと互換性のあるいくつかの関連するFECスキームを導入しました。このドキュメントは、[RFC5510]のセクション8、「イレージャーチャネルのリードソロモンコード仕様」、Vandermondeマトリックスに基づくコアリードソロモンコードの仕様を継承し、FECFRAME [RFC6363 ]："
    },
    {
      "indent": 6,
      "text": "The Fully-Specified FEC Scheme with FEC Encoding ID 8 specifies a simple way of using of Reed-Solomon codes over GF(2^^m), with 2 <= m <= 16, in order to protect arbitrary Application Data Unit (ADU) flows.",
      "ja": "FECエンコーディングID 8の完全指定FECスキームは、任意のアプリケーションデータユニット（ADUを保護するために、2 <= m <= 16のGF（2 ^^ m）でリードソロモンコードを使用する簡単な方法を指定します） 流れ。"
    },
    {
      "indent": 3,
      "text": "Therefore, Sections 4, 5, 6, and 7 of [RFC5510] that define [RFC5052]-specific Formats and Procedures are not considered and are replaced by FECFRAME-specific Formats and Procedures.",
      "ja": "したがって、[RFC5052]固有の形式と手順を定義する[RFC5510]のセクション4、5、6、7は考慮されず、FECFRAME固有の形式と手順に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "For instance, with this scheme, a set of Application Data Units (ADUs) coming from one or several media delivery applications (e.g., a set of RTP packets), are grouped in an ADU block and FEC encoded as a whole. With Reed-Solomon codes over GF(2^^8), there is a strict limit over the number of ADUs that can be protected together, since the number of encoded symbols, n, must be inferior or equal to 255. This constraint is relaxed when using a higher finite field size (m > 8), at the price of an increased computational complexity.",
      "ja": "たとえば、このスキームでは、1つまたは複数のメディア配信アプリケーション（RTPパケットのセットなど）からのアプリケーションデータユニット（ADU）のセットがADUブロックにグループ化され、全体としてFECエンコードされます。 GF（2 ^^ 8）上のリードソロモンコードでは、エンコードされたシンボルの数nが255以下でなければならないため、一緒に保護できるADUの数には厳密な制限があります。この制約はより大きな有限フィールドサイズ（m> 8）を使用する場合は緩和されますが、計算が複雑になります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Definitions Notations and Abbreviations",
      "section_title": true,
      "ja": "3. 定義表記法と略語"
    },
    {
      "indent": 0,
      "text": "3.1. Definitions",
      "section_title": true,
      "ja": "3.1. 定義"
    },
    {
      "indent": 3,
      "text": "This document uses the following terms and definitions. Some of these terms and definitions are FEC scheme specific and are in line with [RFC5052]:",
      "ja": "このドキュメントでは、次の用語と定義を使用しています。これらの用語と定義の一部はFECスキーム固有であり、[RFC5052]に準拠しています。"
    },
    {
      "indent": 3,
      "text": "Source symbol: unit of data used during the encoding process. In this specification, there is always one source symbol per ADU.",
      "ja": "ソースシンボル：エンコードプロセス中に使用されるデータの単位。この仕様では、ADUごとに常に1つのソースシンボルがあります。"
    },
    {
      "indent": 3,
      "text": "Encoding symbol: unit of data generated by the encoding process. With systematic codes, source symbols are part of the encoding symbols.",
      "ja": "エンコーディングシンボル：エンコーディングプロセスによって生成されるデータの単位。体系的なコードでは、ソースシンボルはエンコードシンボルの一部です。"
    },
    {
      "indent": 3,
      "text": "Repair symbol: encoding symbol that is not a source symbol.",
      "ja": "シンボルの修復：ソースシンボルではないエンコードシンボル。"
    },
    {
      "indent": 3,
      "text": "Code rate: the k/n ratio, i.e., the ratio between the number of source symbols and the number of encoding symbols. By definition, the code rate is such that: 0 < code rate <= 1. A code rate close to 1 indicates that a small number of repair symbols have been produced during the encoding process.",
      "ja": "コードレート：k / n比、つまりソースシンボルの数とエンコードシンボルの数の比率。定義により、コードレートは次のようになります。0 <コードレート<=1。1に近いコードレートは、エンコードプロセス中に少数の修復シンボルが生成されたことを示します。"
    },
    {
      "indent": 3,
      "text": "Systematic code: FEC code in which the source symbols are part of the encoding symbols. The Reed-Solomon codes introduced in this document are systematic.",
      "ja": "系統的コード：ソースシンボルがエンコードシンボルの一部であるFECコード。このドキュメントで紹介されているリードソロモンコードは体系的です。"
    },
    {
      "indent": 3,
      "text": "Source Block: a block of k source symbols that are considered together for the encoding.",
      "ja": "ソースブロック：エンコーディングで一緒に考慮されるk個のソースシンボルのブロック。"
    },
    {
      "indent": 3,
      "text": "Packet erasure channel: a communication path where packets are either dropped (e.g., by a congested router, or because the number of transmission errors exceeds the correction capabilities of the physical layer codes) or received. When a packet is received, it is assumed that this packet is not corrupted.",
      "ja": "パケット消去チャネル：パケットが（たとえば、輻輳したルーターによって、または伝送エラーの数が物理層コードの訂正能力を超えているために）ドロップされるか、受信される通信パス。パケットを受信すると、このパケットは破損していないと見なされます。"
    },
    {
      "indent": 3,
      "text": "Some of these terms and definitions are FECFRAME specific and are in line with [RFC6363]:",
      "ja": "これらの用語と定義の一部はFECFRAME固有であり、[RFC6363]に準拠しています。"
    },
    {
      "indent": 3,
      "text": "Application Data Unit (ADU): The unit of source data provided as payload to the transport layer. Depending on the use case, an ADU may use an RTP encapsulation.",
      "ja": "アプリケーションデータユニット（ADU）：トランスポート層にペイロードとして提供されるソースデータの単位。使用例に応じて、ADUはRTPカプセル化を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "(Source) ADU Flow: A sequence of ADUs associated with a transport-layer flow identifier (such as the standard 5-tuple {Source IP address, source port, destination IP address, destination port, transport protocol}). Depending on the use case, several ADU flows may be protected together by FECFRAME.",
      "ja": "（ソース）ADUフロー：トランスポート層フロー識別子に関連付けられた一連のADU（標準の5タプル{ソースIPアドレス、ソースポート、宛先IPアドレス、宛先ポート、トランスポートプロトコル}など）。ユースケースによっては、いくつかのADUフローがFECFRAMEによって一緒に保護される場合があります。"
    },
    {
      "indent": 3,
      "text": "ADU Block: a set of ADUs that are considered together by the FECFRAME instance for the purpose of the FEC scheme. Along with the flow ID (F[]), length (L[]), and padding (Pad[]) fields, they form the set of source symbols over which FEC encoding will be performed.",
      "ja": "ADUブロック：FECスキームの目的でFECFRAMEインスタンスによって一緒に考慮されるADUのセット。フローID（F []）、長さ（L []）、パディング（Pad []）フィールドとともに、これらはFECエンコーディングが実行されるソースシンボルのセットを形成します。"
    },
    {
      "indent": 3,
      "text": "ADU Information (ADUI): a unit of data constituted by the ADU and the associated Flow ID, Length and Padding fields (Section 4.3). This is the unit of data that is used as source symbol.",
      "ja": "ADU情報（ADUI）：ADUおよび関連するフローID、長さ、パディングフィールド（セクション4.3）で構成されるデータの単位。これは、ソースシンボルとして使用されるデータの単位です。"
    },
    {
      "indent": 3,
      "text": "FEC Framework Configuration Information (FFCI): Information that controls the operation of FECFRAME. The FFCI enables the synchronization of the FECFRAME sender and receiver instances.",
      "ja": "FECフレームワーク構成情報（FFCI）：FECFRAMEの操作を制御する情報。 FFCIは、FECFRAME送信側および受信側インスタンスの同期を可能にします。"
    },
    {
      "indent": 3,
      "text": "FEC Source Packet: At a sender (respectively, at a receiver) a payload submitted to (respectively, received from) the transport protocol containing an ADU along with an Explicit Source FEC Payload ID (that must be present in the FEC scheme defined by the present document, see Section 5.1.2).",
      "ja": "FECソースパケット：送信側（それぞれ、受信側）で、ADUと明示的なソースFECペイロードID（によって定義されたFECスキームに存在する必要がある）を含むトランスポートプロトコルに送信された（それぞれ受信された）ペイロード現在の文書、セクション5.1.2を参照）。"
    },
    {
      "indent": 3,
      "text": "FEC Repair Packet: At a sender (respectively, at a receiver) a payload submitted to (respectively, received from) the transport protocol containing one repair symbol along with a Repair FEC Payload ID and possibly an RTP header.",
      "ja": "FEC修復パケット：送信側（それぞれ受信側）で、トランスポートプロトコルに送信された（それぞれから受信された）ペイロード。1つの修復シンボルと、修復FECペイロードID、および場合によってはRTPヘッダーが含まれています。"
    },
    {
      "indent": 3,
      "text": "The above terminology is illustrated in Figure 1 (sender's point of view):",
      "ja": "上記の用語を図1に示します（送信者の視点）。"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           |\n           | (1) Application Data Units (ADUs)\n           |\n           v\n+----------------------+                           +----------------+\n|       FECFRAME       |                           |                |\n|                      |-------------------------->|   FEC Scheme   |\n|(2) Construct source  |(3) Source Block           |                |\n|    blocks            |                           |(4) FEC Encoding|\n|(6) Construct FEC     |<--------------------------|                |\n|    source and repair |                           |                |\n|    packets           |(5) Explicit Source FEC    |                |\n+----------------------+    Payload IDs            +----------------+\n           |                Repair FEC Payload IDs\n           |                Repair symbols\n           |\n           |(7) FEC source and repair packets\n           v\n+----------------------+\n|   Transport Layer    |\n|     (e.g., UDP)      |\n+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 1: Terminology used in this document (sender).",
      "ja": "図1：このドキュメントで使用されている用語（送信者）。"
    },
    {
      "indent": 0,
      "text": "3.2. Notations",
      "section_title": true,
      "ja": "3.2. 記法"
    },
    {
      "indent": 3,
      "text": "This document uses the following notations. Some of them are FEC scheme specific.",
      "ja": "このドキュメントでは、次の表記法を使用しています。それらのいくつかはFECスキーム固有です。"
    },
    {
      "indent": 3,
      "text": "k denotes the number of source symbols in a source block.",
      "ja": "kは、ソースブロック内のソースシンボルの数を示します。"
    },
    {
      "indent": 3,
      "text": "max_k denotes the maximum number of source symbols for any source block.",
      "ja": "max_kは、任意のソースブロックのソースシンボルの最大数を示します。"
    },
    {
      "indent": 3,
      "text": "n denotes the number of encoding symbols generated for a source block.",
      "ja": "nは、ソースブロックに対して生成されたエンコードシンボルの数を示します。"
    },
    {
      "indent": 3,
      "text": "E denotes the encoding symbol length in bytes.",
      "ja": "Eは、エンコーディングシンボルの長さをバイト単位で示します。"
    },
    {
      "indent": 3,
      "text": "GF(q) denotes a finite field (also known as the Galois Field) with q elements. We assume that q = 2^^m in this document.",
      "ja": "GF（q）は、q要素の有限体（ガロア体とも呼ばれる）を表します。このドキュメントでは、q = 2 ^^ mと想定しています。"
    },
    {
      "indent": 3,
      "text": "m defines the length of the elements in the finite field, in bits. In this document, m is such that 2 <= m <= 16.",
      "ja": "mは、有限フィールドの要素の長さをビット単位で定義します。このドキュメントでは、mは2 <= m <= 16のようなものです。"
    },
    {
      "indent": 3,
      "text": "q defines the number of elements in the finite field. We have: q = 2^^m in this specification.",
      "ja": "qは、有限体の要素数を定義します。この仕様では、q = 2 ^^ mです。"
    },
    {
      "indent": 3,
      "text": "CR denotes the \"code rate\", i.e., the k/n ratio.",
      "ja": "CRは「コードレート」、つまりk / n比を示します。"
    },
    {
      "indent": 3,
      "text": "a^^b denotes a raised to the power b.",
      "ja": "a ^^ bは、bの累乗を示します。"
    },
    {
      "indent": 3,
      "text": "Some of them are FECFRAME specific:",
      "ja": "それらのいくつかはFECFRAME固有です。"
    },
    {
      "indent": 3,
      "text": "B denotes the number of ADUs per ADU block.",
      "ja": "Bは、ADUブロックあたりのADUの数を示します。"
    },
    {
      "indent": 3,
      "text": "max_B denotes the maximum number of ADUs for any ADU block.",
      "ja": "max_Bは、任意のADUブロックのADUの最大数を示します。"
    },
    {
      "indent": 0,
      "text": "3.3. Abbreviations",
      "section_title": true,
      "ja": "3.3. 略語"
    },
    {
      "indent": 3,
      "text": "This document uses the following abbreviations:",
      "ja": "このドキュメントでは、次の略語を使用しています。"
    },
    {
      "indent": 3,
      "text": "ADU stands for Application Data Unit.",
      "ja": "ADUはApplication Data Unitの略です。"
    },
    {
      "indent": 3,
      "text": "ADUI stands for Application Data Unit Information.",
      "ja": "ADUIはApplication Data Unit Informationの略です。"
    },
    {
      "indent": 3,
      "text": "ESI stands for Encoding Symbol ID.",
      "ja": "ESIは、Encoding Symbol IDの略です。"
    },
    {
      "indent": 3,
      "text": "FEC stands for Forward Error (or Erasure) Correction code.",
      "ja": "FECはForward Error（or Erasure）Correctionコードの略です。"
    },
    {
      "indent": 3,
      "text": "FFCI stands for FEC Framework Configuration Information.",
      "ja": "FFCIはFECフレームワーク構成情報の略です。"
    },
    {
      "indent": 3,
      "text": "FSSI stands for FEC Scheme-Specific Information.",
      "ja": "FSSIはFECスキーム固有の情報の略です。"
    },
    {
      "indent": 3,
      "text": "MDS stands for Maximum Distance Separable code.",
      "ja": "MDSは、最大距離分離可能コードの略です。"
    },
    {
      "indent": 3,
      "text": "SBN stands for Source Block Number.",
      "ja": "SBNは、Source Block Numberの略です。"
    },
    {
      "indent": 3,
      "text": "SDP stands for Session Description Protocol.",
      "ja": "SDPは、Session Description Protocolの略です。"
    },
    {
      "indent": 0,
      "text": "4. Common Procedures Related to the ADU Block and Source Block Creation",
      "section_title": true,
      "ja": "4. ADUブロックとソースブロックの作成に関連する一般的な手順"
    },
    {
      "indent": 3,
      "text": "This section introduces the procedures that are used during the ADU block and the related source block creation for the FEC scheme considered.",
      "ja": "このセクションでは、考慮されるFECスキームのADUブロックおよび関連するソースブロックの作成中に使用される手順を紹介します。"
    },
    {
      "indent": 0,
      "text": "4.1. Restrictions",
      "section_title": true,
      "ja": "4.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "This specification has the following restrictions:",
      "ja": "この仕様には次の制限があります。"
    },
    {
      "indent": 3,
      "text": "o there MUST be exactly one source symbol per ADUI, and therefore per ADU;",
      "ja": "o ADUIごとに、したがってADUごとに正確に1つのソースシンボルが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o there MUST be exactly one repair symbol per FEC Repair Packet;",
      "ja": "o FEC修理パケットごとに正確に1つの修理シンボルが必要です。"
    },
    {
      "indent": 3,
      "text": "o there MUST be exactly one source block per ADU block.",
      "ja": "o ADUブロックごとに正確に1つのソースブロックが必要です。"
    },
    {
      "indent": 0,
      "text": "4.2. ADU Block Creation",
      "section_title": true,
      "ja": "4.2. ADUブロックの作成"
    },
    {
      "indent": 3,
      "text": "Two kinds of limitations exist that impact the ADU block creation:",
      "ja": "ADUブロックの作成に影響を与える2種類の制限があります。"
    },
    {
      "indent": 3,
      "text": "o at the FEC Scheme level: the finite field size (m parameter) directly impacts the maximum source block size and the maximum number of encoding symbols;",
      "ja": "o FECスキームレベル：有限フィールドサイズ（mパラメーター）は、最大ソースブロックサイズとエンコードシンボルの最大数に直接影響します。"
    },
    {
      "indent": 3,
      "text": "o at the FECFRAME instance level: the target use case can have real-time constraints that can/will define a maximum ADU block size.",
      "ja": "o FECFRAMEインスタンスレベル：ターゲットユースケースには、最大ADUブロックサイズを定義できる/定義するリアルタイム制約がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that terms \"maximum source block size\" and \"maximum ADU block size\" depend on the point of view that is adopted (FEC Scheme versus FECFRAME instance). However, in this document, both refer to the same value since Section 4.1 requires there is exactly one source symbol per ADU. We now detail each of these aspects.",
      "ja": "「最大ソースブロックサイズ」および「最大ADUブロックサイズ」という用語は、採用されている観点（FECスキームとFECFRAMEインスタンス）に依存することに注意してください。ただし、このドキュメントでは、セクション4.1ではADUごとにソースシンボルが1つだけ必要であるため、両方とも同じ値を参照しています。次に、これらの各側面について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "The finite field size parameter m defines the number of non-zero elements in this field, which is equal to: q - 1 = 2^^m - 1. This q - 1 value is also the theoretical maximum number of encoding symbols that can be produced for a source block. For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols. So: k < n <= 255. Given the target FEC code rate (e.g., provided by the end-user or upper application when starting the FECFRAME instance, and taking into account the known or estimated packet loss rate), the sender calculates:",
      "ja": "有限フィールドサイズパラメーターmは、このフィールドの非ゼロ要素の数を定義します。これは、q-1 = 2 ^^ m-1に等しくなります。このq-1値は、次のことができるエンコードシンボルの理論的な最大数でもあります。ソースブロック用に生成されます。たとえば、m = 8（デフォルト）の場合、最大2 ^^ 8-1 = 255のエンコードシンボルがあります。つまり、k <n <= 255です。ターゲットFECコードレート（たとえば、FECFRAMEインスタンスを開始するときにエンドユーザーまたは上位アプリケーションによって提供され、既知または推定されたパケット損失率を考慮に入れる）が与えられると、送信者は次を計算します。"
    },
    {
      "indent": 6,
      "text": "max_k = floor((2^^m - 1) * CR)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This max_k value leaves enough room for the sender to produce the desired number of repair symbols. Since there is one source symbol per ADU, max_k is also an upper bound to the maximum number of ADUs per ADU block.",
      "ja": "このmax_k値は、送信者が必要な数の修復シンボルを生成するための十分な余地を残します。 ADUごとに1つのソースシンボルがあるため、max_kはADUブロックごとのADUの最大数の上限でもあります。"
    },
    {
      "indent": 3,
      "text": "The source ADU flows can have real-time constraints. When there are multiple flows, with different real-time constraints, let us consider the most stringent constraints (see [RFC6363], Section 10.2, item 6 for recommendations when several flows are globally protected). In that case, the maximum number of ADUs of an ADU block must not exceed a certain threshold since it directly impacts the decoding delay. The larger the ADU block size, the longer a decoder may have to wait until it has received a sufficient number of encoding symbols for decoding to succeed, and therefore the larger the decoding delay. When the target use case is known, these real-time constraints result in an upper bound to the ADU block size, max_rt.",
      "ja": "ソースADUフローには、リアルタイム制約があります。リアルタイム制約が異なる複数のフローがある場合、最も厳しい制約を検討してみましょう（複数のフローがグローバルに保護されている場合の推奨事項については、[RFC6363]、セクション10.2、アイテム6を参照してください）。その場合、ADUブロックのADUの最大数は、デコード遅延に直接影響するため、特定のしきい値を超えてはなりません。 ADUブロックサイズが大きいほど、デコードが成功するために十分な数のエンコードシンボルを受信するまでデコーダが待機する時間が長くなるため、デコード遅延が大きくなります。ターゲットのユースケースがわかっている場合、これらのリアルタイム制約により、ADUブロックサイズの上限max_rtが発生します。"
    },
    {
      "indent": 3,
      "text": "For instance, if the use case specifies a maximum decoding latency l, and if each source ADU covers a duration d of a continuous media (we assume here the simple case of a constant bit-rate ADU flow), then the ADU block size must not exceed:",
      "ja": "たとえば、ユースケースで最大デコードレイテンシlを指定し、各ソースADUが連続メディアの継続時間dをカバーする場合（ここでは、一定のビットレートのADUフローの単純なケースを想定しています）、ADUブロックサイズは超えない："
    },
    {
      "indent": 6,
      "text": "max_rt = floor(l / d)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After encoding, this block will produce a set of at most n = max_rt / CR encoding symbols. These n encoding symbols will have to be sent at a rate of n / l packets per second. For instance, with d = 10 ms, l = 1 s, max_rt = 100 ADUs.",
      "ja": "エンコード後、このブロックは最大でn = max_rt / CRエンコードシンボルのセットを生成します。これらのn個のエンコードシンボルは、毎秒n / lパケットの速度で送信する必要があります。たとえば、d = 10 ms、l = 1 s、max_rt = 100 ADU。"
    },
    {
      "indent": 3,
      "text": "If we take into account all these constraints, we find:",
      "ja": "これらすべての制約を考慮すると、次のことがわかります。"
    },
    {
      "indent": 6,
      "text": "max_B = min(max_k, max_rt)",
      "ja": "max_B = min（max_k、max_rt）"
    },
    {
      "indent": 3,
      "text": "This max_B parameter is an upper bound to the number of ADUs that can constitute an ADU block.",
      "ja": "このmax_Bパラメータは、ADUブロックを構成できるADUの数の上限です。"
    },
    {
      "indent": 0,
      "text": "4.3. Source Block Creation",
      "section_title": true,
      "ja": "4.3. ソースブロックの作成"
    },
    {
      "indent": 0,
      "text": " In their most general form, FECFRAME and the Reed-Solomon FEC scheme are meant to protect a set of independent flows. Since the flows have no relationship to one another, the ADU size of each flow can potentially vary significantly. Even in the special case of a single flow, the ADU sizes can largely vary (e.g., the various frames of a \"Group of Pictures\" (GOP) of an H.264 flow will have different sizes). This diversity must be addressed since the Reed-Solomon FEC scheme requires a constant encoding symbol size (E parameter) per source block. Since this specification requires that there is only one source symbol per ADU, E must be large enough to contain all the ADUs of an ADU block along with their prepended 3 bytes (see below).",
      "ja": "最も一般的な形式では、FECFRAMEとリードソロモンFECスキームは、一連の独立したフローを保護することを目的としています。フローには相互の関係がないため、各フローのADUサイズは大きく異なる可能性があります。単一のフローの特別な場合でも、ADUのサイズは大きく異なる可能性があります（たとえば、H.264フローの「Group of Pictures」（GOP）のさまざまなフレームのサイズは異なります）。リードソロモンFECスキームでは、ソースブロックごとに一定のエンコードシンボルサイズ（Eパラメーター）が必要であるため、この多様性に対処する必要があります。この仕様では、ADUごとに1つのソースシンボルのみが必要であるため、Eは、ADUブロックのすべてのADUとそれらの先頭に追加された3バイトを含めるのに十分な大きさでなければなりません（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "In situations where E is determined per source block (default, specified by the FFCI/FSSI with S = 0, Section 5.1.1.2), E is equal to the size of the largest ADU of this source block plus 3 (for the prepended 3 bytes; see below). In this case, upon receiving the first FEC Repair Packet for this source block, since this packet MUST contain a single repair symbol (Section 5.1.3), a receiver determines the E parameter used for this source block.",
      "ja": "Eがソースブロックごとに決定される状況（デフォルト、FFCI / FSSIでS = 0、セクション5.1.1.2で指定）では、Eはこのソースブロックの最大ADUのサイズに3を加えたもの（先頭に3バイト。下記参照）。この場合、このソースブロックの最初のFEC修復パケットを受信すると、このパケットには単一の修復シンボルが含まれている必要があるため（セクション5.1.3）、受信者はこのソースブロックに使用するEパラメータを決定します。"
    },
    {
      "indent": 3,
      "text": "In situations where E is fixed (specified by the FFCI/FSSI with S = 1, Section 5.1.1.2), then E must be greater or equal to the size of the largest ADU of this source block plus 3 (for the prepended 3 bytes; see below). If this is not the case, an error is returned. How to handle this error is use-case specific (e.g., a larger E parameter may be communicated to the receivers in an updated FFCI message using an appropriate mechanism) and is not considered by this specification.",
      "ja": "Eが固定されている状況（S = 1のFFCI / FSSIで指定、セクション5.1.1.2）では、Eは、このソースブロックの最大ADUのサイズに3を加えた値以上にする必要があります（先頭に3バイトを追加） ; 下記参照）。そうでない場合は、エラーが返されます。このエラーの処理方法はユースケース固有であり（たとえば、適切なメカニズムを使用して、更新されたFFCIメッセージでより大きいEパラメーターが受信者に通知される場合があります）、この仕様では考慮されません。"
    },
    {
      "indent": 3,
      "text": "The ADU block is always encoded as a single source block. There are a total of B <= max_B ADUs in this ADU block. For the ADU i, with 0 <= i <= B-1, 3 bytes are prepended (Figure 2):",
      "ja": "ADUブロックは常に単一のソースブロックとしてエンコードされます。このADUブロックには、合計B <= max_B ADUがあります。 ADU iの場合、0 <= i <= B-1の場合、3バイトが付加されます（図2）。"
    },
    {
      "indent": 3,
      "text": "o The first byte, F[i] (Flow ID), contains the integer identifier associated to the source ADU flow to which this ADU belongs to. It is assumed that a single byte is sufficient, or said differently, that no more than 256 flows will be protected by a single instance of FECFRAME.",
      "ja": "o 最初のバイトF [i]（フローID）には、このADUが属するソースADUフローに関連付けられた整数の識別子が含まれます。単一のバイトで十分である、または別の言い方をすると、FECFRAMEの単一のインスタンスによって保護されるフローは256以下であると想定されています。"
    },
    {
      "indent": 3,
      "text": "o The following 2 bytes, L[i] (Length), contain the length of this ADU, in network byte order (i.e., big endian). This length is for the ADU itself and does not include the F[i], L[i], or Pad[i] fields.",
      "ja": "o 次の2バイトL [i]（長さ）には、このADUの長さがネットワークバイトオーダー（ビッグエンディアン）で含まれています。この長さはADU自体の長さであり、F [i]、L [i]、またはPad [i]フィールドは含まれません。"
    },
    {
      "indent": 3,
      "text": "Then zero padding is added to ADU i (if needed), in field Pad[i], for alignment purposes up to a size of exactly E bytes. The data unit resulting from the ADU i and the F[i], L[i], and Pad[i] fields, is called ADU Information (or ADUI). Each ADUI contributes to exactly one source symbol of the source block.",
      "ja": "次に、フィールドPad [i]のADU iにゼロパディングが追加され（必要な場合）、正確にEバイトのサイズになるように調整されます。 ADU iとF [i]、L [i]、およびPad [i]フィールドから得られるデータ単位は、ADU情報（またはADUI）と呼ばれます。各ADUIは、ソースブロックのソースシンボルを1つだけ提供します。"
    },
    {
      "indent": 3,
      "text": "                     Encoding Symbol Length (E)\n< ----------------------------------------------------------------- >\n+----+--------+-----------------------+-----------------------------+\n|F[0]|  L[0]  |        ADU[0]         |            Pad[0]           |\n+----+--------+----------+------------+-----------------------------+\n|F[1]|  L[1]  | ADU[1]   |                         Pad[1]           |\n+----+--------+----------+------------------------------------------+\n|F[2]|  L[2]  |                    ADU[2]                           |\n+----+--------+------+----------------------------------------------+\n|F[3]|  L[3]  |ADU[3]|                             Pad[3]           |\n+----+--------+------+----------------------------------------------+\n\\_________________________________  ________________________________/\n                                  \\/\n                         simple FEC encoding",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|                              Repair 4                             |\n+-------------------------------------------------------------------+\n.                                                                   .\n.                                                                   .\n+-------------------------------------------------------------------+\n|                              Repair 7                             |\n+-------------------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 2: Source block creation, for code rate 1/2 (equal number of source and repair symbols; 4 in this example), and S = 0.",
      "ja": "図2：ソースブロックの作成、コードレート1/2（ソースと修復シンボルの数は同じ、この例では4）、S = 0。"
    },
    {
      "indent": 3,
      "text": "Note that neither the initial 3 bytes nor the optional padding are sent over the network. However, they are considered during FEC encoding. It means that a receiver who lost a certain FEC source packet (e.g., the UDP datagram containing this FEC source packet) will be able to recover the ADUI if FEC decoding succeeds. Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any) and identify the corresponding ADU flow.",
      "ja": "最初の3バイトもオプションのパディングもネットワーク経由で送信されないことに注意してください。ただし、それらはFECエンコード中に考慮されます。つまり、特定のFECソースパケット（このFECソースパケットを含むUDPデータグラムなど）を失った受信者は、FECデコードが成功した場合にADUIを回復できます。最初の3バイトのおかげで、このレシーバーはパディング（ある場合）を取り除き、対応するADUフローを識別します。"
    },
    {
      "indent": 0,
      "text": "5. Simple Reed-Solomon FEC Scheme over GF(2^^m) for Arbitrary ADU Flows",
      "section_title": true,
      "ja": "5. 任意のADUフローのためのGF（2 ^^ m）上の単純なリードソロモンFECスキーム"
    },
    {
      "indent": 3,
      "text": "This Fully-Specified FEC Scheme specifies the use of Reed-Solomon codes over GF(2^^m), with 2 <= m <= 16, with a simple FEC encoding for arbitrary packet flows.",
      "ja": "この完全に指定されたFECスキームは、GF（2 ^^ m）上のリードソロモンコードの使用を指定します。2<= m <= 16で、任意のパケットフローに対して単純なFECエンコーディングを使用します。"
    },
    {
      "indent": 0,
      "text": "5.1. Formats and Codes",
      "section_title": true,
      "ja": "5.1. フォーマットとコード"
    },
    {
      "indent": 0,
      "text": "5.1.1. FEC Framework Configuration Information",
      "section_title": true,
      "ja": "5.1.1. FECフレームワーク構成情報"
    },
    {
      "indent": 0,
      "text": " The FEC Framework Configuration Information (or FFCI) includes information that must be communicated between the sender and receiver(s) [RFC6363]. More specifically, it enables the synchronization of the FECFRAME sender and receiver instances. It includes both mandatory elements and scheme-specific elements, as detailed below.",
      "ja": "FECフレームワーク構成情報（またはFFCI）には、送信者と受信者の間で通信する必要がある情報が含まれています[RFC6363]。具体的には、FECFRAMEの送信側インスタンスと受信側インスタンスの同期を可能にします。以下に詳細を示すように、必須要素とスキーム固有の要素の両方が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. Mandatory Information",
      "section_title": true,
      "ja": "5.1.1.1. 表示義務のある情報"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: the value assigned to this Fully-Specified FEC scheme MUST be 8, as assigned by IANA (Section 8).",
      "ja": "o FECエンコーディングID：この完全指定FECスキームに割り当てられる値は、IANAによって割り当てられるように8でなければなりません（セクション8）。"
    },
    {
      "indent": 3,
      "text": "When SDP is used to communicate the FFCI, this FEC Encoding ID MUST be carried in the 'encoding-id' parameter of the 'fec-repair-flow' attribute specified in RFC 6364 [RFC6364].",
      "ja": "SDPを使用してFFCIを通信する場合、このFECエンコーディングIDは、RFC 6364 [RFC6364]で指定されている「fec-repair-flow」属性の「encoding-id」パラメータで伝達する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. FEC Scheme-Specific Information",
      "section_title": true,
      "ja": "5.1.1.2. FECスキーム固有の情報"
    },
    {
      "indent": 3,
      "text": "The FEC Scheme-Specific Information (FSSI) includes elements that are specific to the present FEC scheme. More precisely:",
      "ja": "FECスキーム固有情報（FSSI）には、現在のFECスキームに固有の要素が含まれています。より正確に："
    },
    {
      "indent": 3,
      "text": "o Encoding Symbol Length (E): a non-negative integer, inferior to 2^^16, that indicates either the length of each encoding symbol in bytes (\"strict\" mode, i.e., if S = 1), or the maximum length of any encoding symbol (i.e., if S = 0).",
      "ja": "o エンコーディングシンボルの長さ（E）：2 ^^ 16よりも小さい負でない整数。バイト単位の各エンコーディングシンボルの長さ（ \"strict\"モード、つまりS = 1の場合）、または最大長任意のエンコーディングシンボル（S = 0の場合）。"
    },
    {
      "indent": 3,
      "text": "o Strict (S) flag: when set to 1, this flag indicates that the E parameter is the actual encoding symbol length value for each block of the session (unless otherwise notified by an updated FFCI if this possibility is considered by the use case or CDP). When set to 0, this flag indicates that the E parameter is the maximum encoding symbol length value for each block of the session (unless otherwise notified by an updated FFCI if this possibility is considered by the use case or CDP).",
      "ja": "o 厳格（S）フラグ：1に設定されている場合、このフラグは、Eパラメーターがセッションの各ブロックの実際のエンコードシンボル長の値であることを示します（この可能性がユースケースまたはCDPで考慮されている場合、更新されたFFCIによって通知されない限り） ）。 0に設定されている場合、このフラグは、Eパラメーターがセッションの各ブロックの最大エンコードシンボル長の値であることを示します（この可能性がユースケースまたはCDPで考慮されている場合、更新されたFFCIによって通知されない限り）。"
    },
    {
      "indent": 3,
      "text": "o m parameter (m): an integer that defines the length of the elements in the finite field, in bits. We have: 2 <= m <= 16.",
      "ja": "o mパラメータ（m）：有限体の要素の長さをビット単位で定義する整数。 2 <= m <= 16。"
    },
    {
      "indent": 3,
      "text": "These elements are required both by the sender (Reed-Solomon encoder) and the receiver(s) (Reed-Solomon decoder).",
      "ja": "これらの要素は、送信者（リードソロモンエンコーダー）と受信者（リードソロモンデコーダー）の両方で必要です。"
    },
    {
      "indent": 3,
      "text": "When SDP is used to communicate the FFCI, this FEC scheme-specific information MUST be carried in the 'fssi' parameter of the 'fec-repair-flow' attribute, in textual representation as specified in RFC 6364 [RFC6364]. For instance:",
      "ja": "SDPを使用してFFCIを通信する場合、このFECスキーム固有の情報は、RFC 6364 [RFC6364]で指定されているテキスト表現で、「fec-repair-flow」属性の「fssi」パラメーターで伝達する必要があります。例えば："
    },
    {
      "indent": 3,
      "text": "a=fec-repair-flow: encoding-id=8; fssi=E:1400,S:0,m:8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " If another mechanism requires the FSSI to be carried as an opaque octet string (for instance after a Base64 encoding), the encoding format consists of the following 3 octets of Figure 3: o Encoding symbol length (E): 16-bit field.",
      "ja": "別のメカニズムでFSSIを不透明なオクテット文字列として伝送する必要がある場合（たとえば、Base64エンコーディングの後）、エンコーディング形式は図3の次の3オクテットで構成されます。oエンコーディングシンボル長（E）：16ビットフィールド。"
    },
    {
      "indent": 3,
      "text": "o Strict (S) flag: 1-bit field.",
      "ja": "o 厳格（S）フラグ：1ビットフィールド。"
    },
    {
      "indent": 3,
      "text": "o m parameter (m): 7-bit field.",
      "ja": "o mパラメータ（m）：7ビットフィールド。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Encoding Symbol Length (E)  |S|     m       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: FSSI encoding format.",
      "ja": "図3：FSSIエンコード形式。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Explicit Source FEC Payload ID",
      "section_title": true,
      "ja": "5.1.2. 明示的なソースFECペイロードID"
    },
    {
      "indent": 3,
      "text": "A FEC source packet MUST contain an Explicit Source FEC Payload ID that is appended to the end of the packet as illustrated in Figure 4.",
      "ja": "図4に示すように、FECソースパケットには、パケットの末尾に追加される明示的なソースFECペイロードIDが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+\n|           IP Header            |\n+--------------------------------+\n|        Transport Header        |\n+--------------------------------+\n|              ADU               |\n+--------------------------------+\n| Explicit Source FEC Payload ID |\n+--------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 4: Structure of a FEC Source Packet with the Explicit Source FEC Payload ID.",
      "ja": "図4：明示的なソースFECペイロードIDを含むFECソースパケットの構造。"
    },
    {
      "indent": 3,
      "text": "More precisely, the Explicit Source FEC Payload ID is composed of the Source Block Number, the Encoding Symbol ID, and the Source Block Length. The length of the first 2 fields depends on the m parameter (transmitted separately in the FFCI, Section 5.1.1.2):",
      "ja": "より正確には、Explicit Source FEC Payload IDは、Source Block Number、Encoding Symbol ID、およびSource Block Lengthで構成されています。最初の2つのフィールドの長さは、mパラメーターによって異なります（FFCI、セクション5.1.1.2で個別に送信されます）。"
    },
    {
      "indent": 3,
      "text": "o Source Block Number (SBN) ((32-m)-bit field): this field identifies the source block to which this FEC source packet belongs.",
      "ja": "o ソースブロック番号（SBN）（（32-m）ビットフィールド）：このフィールドは、このFECソースパケットが属するソースブロックを識別します。"
    },
    {
      "indent": 3,
      "text": "o Encoding Symbol ID (ESI) (m-bit field): this field identifies the source symbol contained in this FEC source packet. This value is such that 0 <= ESI <= k - 1 for source symbols.",
      "ja": "o エンコーディングシンボルID（ESI）（mビットフィールド）：このフィールドは、このFECソースパケットに含まれるソースシンボルを識別します。この値は、ソースシンボルに対して0 <= ESI <= k-1になるような値です。"
    },
    {
      "indent": 3,
      "text": "o Source Block Length (k) (16-bit field): this field provides the number of source symbols for this source block, i.e., the k parameter. If 16 bits are too much when m <= 8, it is needed when 8 < m <= 16. Therefore, we provide a single common format regardless of m.",
      "ja": "o ソースブロック長（k）（16ビットフィールド）：このフィールドは、このソースブロックのソースシンボルの数、つまりkパラメーターを提供します。 m <= 8のときに16ビットが多すぎる場合は、8 <m <= 16のときに必要です。したがって、mに関係なく単一の共通フォーマットを提供します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Source Block Number (24 bits)       | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Source Block Length (k)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 5: Source FEC Payload ID encoding format for m = 8 (default).",
      "ja": "図5：m = 8のソースFECペイロードIDエンコード形式（デフォルト）。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Source Block Length (k)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 6: Source FEC Payload ID encoding format for m = 16.",
      "ja": "図6：m = 16のソースFECペイロードIDエンコード形式"
    },
    {
      "indent": 3,
      "text": "The format of the Source FEC Payload ID for m = 8 and m = 16 are illustrated in Figures 5 and 6, respectively.",
      "ja": "m = 8およびm = 16のソースFECペイロードIDのフォーマットを、それぞれ図5および6に示します。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Repair FEC Payload ID",
      "section_title": true,
      "ja": "5.1.3. FECペイロードIDを修復する"
    },
    {
      "indent": 3,
      "text": "A FEC repair packet MUST contain a Repair FEC Payload ID that is prepended to the repair symbol(s) as illustrated in Figure 7. There MUST be a single repair symbol per FEC repair packet.",
      "ja": "FEC修復パケットには、図7に示すように修復シンボルの前に付加される修復FECペイロードIDが含まれている必要があります。FEC修復パケットごとに1つの修復シンボルが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+\n|           IP Header            |\n+--------------------------------+\n|        Transport Header        |\n+--------------------------------+\n|      Repair FEC Payload ID     |\n+--------------------------------+\n|         Repair Symbol          |\n+--------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 7: Structure of a FEC Repair Packet with the Repair FEC Payload ID.",
      "ja": "図7：修理FECペイロードIDを含むFEC修理パケットの構造。"
    },
    {
      "indent": 3,
      "text": "More precisely, the Repair FEC Payload ID is composed of the Source Block Number, the Encoding Symbol ID, and the Source Block Length. The length of the first 2 fields depends on the m parameter (transmitted separately in the FFCI, Section 5.1.1.2):",
      "ja": "より正確には、Repair FEC Payload IDは、Source Block Number、Encoding Symbol ID、およびSource Block Lengthで構成されています。最初の2つのフィールドの長さは、mパラメーターによって異なります（FFCI、セクション5.1.1.2で個別に送信されます）。"
    },
    {
      "indent": 3,
      "text": "o Source Block Number (SBN) ((32-m)-bit field): this field identifies the source block to which the FEC repair packet belongs.",
      "ja": "o ソースブロック番号（SBN）（（32-m）ビットフィールド）：このフィールドは、FEC修復パケットが属するソースブロックを識別します。"
    },
    {
      "indent": 3,
      "text": "o Encoding Symbol ID (ESI) (m-bit field): this field identifies the repair symbol contained in this FEC repair packet. This value is such that k <= ESI <= n - 1 for repair symbols.",
      "ja": "o エンコーディングシンボルID（ESI）（mビットフィールド）：このフィールドは、このFEC修復パケットに含まれる修復シンボルを識別します。この値は、修復シンボルに対してk <= ESI <= n-1になるような値です。"
    },
    {
      "indent": 3,
      "text": "o Source Block Length (k) (16-bit field): this field provides the number of source symbols for this source block, i.e., the k parameter. If 16 bits are too much when m <= 8, it is needed when 8 < m <= 16. Therefore, we provide a single common format regardless of m.",
      "ja": "o ソースブロック長（k）（16ビットフィールド）：このフィールドは、このソースブロックのソースシンボルの数、つまりkパラメーターを提供します。 m <= 8のときに16ビットが多すぎる場合は、8 <m <= 16のときに必要です。したがって、mに関係なく単一の共通フォーマットを提供します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Source Block Number (24 bits)       | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Source Block Length (k)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 8: Repair FEC Payload ID encoding format for m = 8 (default).",
      "ja": "図8：m = 8（デフォルト）のFECペイロードIDエンコード形式を修復します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Source Block Length (k)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 9: Repair FEC Payload ID encoding format for m = 16.",
      "ja": "図9：m = 16の修復FECペイロードIDエンコード形式"
    },
    {
      "indent": 3,
      "text": "The format of the Repair FEC Payload ID for m = 8 and m = 16 are illustrated in Figures 8 and 9, respectively.",
      "ja": "m = 8およびm = 16のRepair FEC Payload IDのフォーマットを、それぞれ図8および9に示します。"
    },
    {
      "indent": 0,
      "text": "5.2. Procedures",
      "section_title": true,
      "ja": "5.2. 手続き"
    },
    {
      "indent": 3,
      "text": "The following procedures apply:",
      "ja": "次の手順が適用されます。"
    },
    {
      "indent": 3,
      "text": "o The source block creation MUST follow the procedures specified in Section 4.3.",
      "ja": "o ソースブロックの作成は、セクション4.3で指定された手順に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o The SBN value MUST start with value 0 for the first block of the ADU flow and MUST be incremented by 1 for each new source block. Wrapping to zero will happen for long sessions, after value 2^^(32-m) - 1.",
      "ja": "o SBN値は、ADUフローの最初のブロックでは値0で始まり、新しいソースブロックごとに1ずつ増加する必要があります。値が2 ^^（32-m）-1になると、長いセッションではゼロへの折り返しが発生します。"
    },
    {
      "indent": 3,
      "text": "o The ESI of encoding symbols MUST start with value 0 for the first symbol and MUST be managed sequentially. The first k values (0 <= ESI <= k - 1) identify source symbols, whereas the last n-k values (k <= ESI <= n - 1) identify repair symbols.",
      "ja": "o エンコーディングシンボルのESIは、最初のシンボルの値0で始まり、連続して管理する必要があります。最初のk値（0 <= ESI <= k-1）はソースシンボルを識別し、最後のn-k値（k <= ESI <= n-1）は修復シンボルを識別します。"
    },
    {
      "indent": 3,
      "text": "o The FEC repair packet creation MUST follow the procedures specified in Section 5.1.3.",
      "ja": "o FEC修復パケットの作成は、セクション5.1.3で指定された手順に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. FEC Code Specification",
      "section_title": true,
      "ja": "5.3. FECコード仕様"
    },
    {
      "indent": 3,
      "text": "The present document inherits from Section 8 of [RFC5510], \"Reed-Solomon Codes Specification for the Erasure Channel\", the specifications of the core Reed-Solomon codes based on Vandermonde matrices.",
      "ja": "このドキュメントは、[RFC5510]のセクション8、「イレージャーチャネルのリードソロモンコード仕様」、Vandermonde行列に基づくコアリードソロモンコードの仕様を継承しています。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The FECFRAME document [RFC6363] provides a comprehensive analysis of security considerations applicable to FEC schemes. Therefore, the present section follows the security considerations section of [RFC6363] and only discusses topics that are specific to the use of Reed-Solomon codes.",
      "ja": "FECFRAMEドキュメント[RFC6363]は、FECスキームに適用可能なセキュリティの考慮事項の包括的な分析を提供します。したがって、このセクションは[RFC6363]のセキュリティに関する考慮事項セクションに続き、リードソロモンコードの使用に固有のトピックについてのみ説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Attacks Against the Data Flow",
      "section_title": true,
      "ja": "6.1. データフローに対する攻撃"
    },
    {
      "indent": 0,
      "text": "6.1.1. Access to Confidential Content",
      "section_title": true,
      "ja": "6.1.1. 機密コンテンツへのアクセス"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon FEC Scheme specified in this document does not change the recommendations of [RFC6363]. To summarize, if confidentiality is a concern, it is RECOMMENDED that one of the solutions mentioned in [RFC6363] is used with special considerations to the way this solution is applied (e.g., is encryption applied before or after FEC protection, within the end-system or in a middlebox) to the operational constraints (e.g., performing FEC decoding in a protected environment may be complicated or even impossible) and to the threat model.",
      "ja": "このドキュメントで指定されているリードソロモンFECスキームは、[RFC6363]の推奨事項を変更しません。要約すると、機密性が懸念される場合、[RFC6363]で言及されているソリューションの1つは、このソリューションが適用される方法（たとえば、FEC保護の前または後に暗号化が適用される）システムまたはミドルボックス）を運用上の制約（たとえば、保護された環境でFECデコードを実行することは複雑であるか、不可能でさえある）と脅威モデルに対して。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Content Corruption",
      "section_title": true,
      "ja": "6.1.2. コンテンツの破損"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon FEC Scheme specified in this document does not change the recommendations of [RFC6363]. To summarize, it is RECOMMENDED that one of the solutions mentioned in [RFC6363] is used on both the FEC Source and Repair Packets.",
      "ja": "このドキュメントで指定されているリードソロモンFECスキームは、[RFC6363]の推奨事項を変更しません。要約すると、[RFC6363]で言及されているソリューションの1つがFECソースと修復パケットの両方で使用されることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Attacks Against the FEC Parameters",
      "section_title": true,
      "ja": "6.2. FECパラメータに対する攻撃"
    },
    {
      "indent": 3,
      "text": "The FEC Scheme specified in this document defines parameters that can be the basis of several attacks. More specifically, the following parameters of the FFCI may be modified by an attacker (Section 5.1.1.2):",
      "ja": "このドキュメントで指定されているFECスキームは、いくつかの攻撃の基礎となるパラメータを定義しています。より具体的には、FFCIの以下のパラメーターが攻撃者によって変更される可能性があります（セクション5.1.1.2）。"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: changing this parameter leads the receiver to consider a different FEC Scheme, which enables an attacker to create a Denial of Service (DoS).",
      "ja": "o FECエンコーディングID：このパラメーターを変更すると、受信者は別のFECスキームを検討するようになり、攻撃者はサービス拒否（DoS）を作成できます。"
    },
    {
      "indent": 3,
      "text": "o Encoding symbol length (E): setting this E parameter to a value smaller than the valid one enables an attacker to create a DoS since the repair symbols and certain source symbols will be larger than E, which is an incoherency for the receiver. Setting this E parameter to a value larger than the valid one has similar impacts when S = 1 since the received repair symbol size will be smaller than expected. On the opposite, it will not lead to any incoherency when S = 0 since the actual symbol length value for the block is determined by the size of any received repair symbol, as long as this value is smaller than E. However, setting this E parameter to a larger value may have impacts on receivers that pre-allocate memory space in advance to store incoming symbols.",
      "ja": "o エンコードシンボル長（E）：このEパラメーターを有効な値よりも小さい値に設定すると、修復シンボルと特定のソースシンボルがEよりも大きくなるため、攻撃者はDoSを作成できます。このEパラメータを有効な値よりも大きい値に設定すると、S = 1の場合に同様の影響があります。これは、受信した修復シンボルのサイズが予想よりも小さくなるためです。反対に、S = 0の場合、ブロックの実際のシンボル長の値は、受信した修復シンボルのサイズによって決定されるため、この値がEより小さい限り、インコヒーレンシーにはなりません。ただし、このEパラメータをより大きな値に設定すると、受信シンボルを格納するために事前にメモリ空間を事前に割り当てるレシーバに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Strict (S) flag: flipping this S flag from 0 to 1 (i.e., E is now considered as a strict value) enables an attacker to mislead the receiver if the actual symbol size varies over different source blocks. Flipping this S flag from 1 to 0 has no major consequences unless the receiver requires to have a fixed E value (e.g., because the receiver pre-allocates memory space).",
      "ja": "o 厳格（S）フラグ：このSフラグを0から1に反転させると（つまり、Eは厳密な値と見なされます）、実際のシンボルサイズが異なるソースブロックで異なる場合、攻撃者は受信機を誤解させることができます。このSフラグを1から0に反転しても、レシーバーが固定のE値を必要としない限り、大きな影響はありません（たとえば、レシーバーがメモリ空間を事前に割り当てるため）。"
    },
    {
      "indent": 3,
      "text": "o m parameter: changing this parameter triggers a DoS since the receiver and sender will consider different codes, and the receiver will interpret the Explicit Source FEC Payload ID and Repair FEC Payload ID differently. Additionally, by increasing this m parameter to a larger value (typically m = 16 rather than 8, when both values are possible in the target use case) will create additional processing load at a receiver if decoding is attempted.",
      "ja": "o mパラメーター：受信者と送信者は異なるコードを考慮し、受信者は明示的なソースFECペイロードIDと修復FECペイロードIDを異なる方法で解釈するため、このパラメーターを変更するとDoSがトリガーされます。さらに、このmパラメーターをより大きな値（ターゲットのユースケースで両方の値が可能である場合、通常は8ではなくm = 16）に増やすことで、デコードが試行された場合にレシーバーで追加の処理負荷が生じます。"
    },
    {
      "indent": 3,
      "text": "It is therefore RECOMMENDED that security measures are taken to guarantee the FFCI integrity, as specified in [RFC6363]. How to achieve this depends on the way the FFCI is communicated from the sender to the receiver, which is not specified in this document.",
      "ja": "したがって、[RFC6363]で指定されているように、FFCIの完全性を保証するためにセキュリティ対策を講じることをお勧めします。これを実現する方法は、FFCIが送信者から受信者に通信される方法に依存しますが、これはこのドキュメントでは指定されていません。"
    },
    {
      "indent": 3,
      "text": "Similarly, attacks are possible against the Explicit Source FEC Payload ID and Repair FEC Payload ID: by modifying the Source Block Number (SBN), or the Encoding Symbol ID (ESI), or the Source Block Length (k), an attacker can easily corrupt the block identified by the SBN. Other consequences, that are use case and/or CDP dependent, may also happen. It is therefore RECOMMENDED that security measures are taken to guarantee the FEC Source and Repair Packets as stated in [RFC6363].",
      "ja": "同様に、明示的なソースFECペイロードIDおよび修復FECペイロードIDに対して攻撃が可能です。ソースブロック番号（SBN）、またはエンコードシンボルID（ESI）、またはソースブロック長（k）を変更することにより、攻撃者は簡単に行うことができます。 SBNによって識別されたブロックを破壊します。ユースケースやCDPに依存するその他の結果も発生する可能性があります。したがって、[RFC6363]で述べられているように、FEC送信元と修復パケットを保証するためにセキュリティ対策を講じることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6.3. When Several Source Flows Are to Be Protected Together",
      "section_title": true,
      "ja": "6.3. 複数のソースフローを一緒に保護する必要がある場合"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon FEC Scheme specified in this document does not change the recommendations of [RFC6363].",
      "ja": "このドキュメントで指定されているリードソロモンFECスキームは、[RFC6363]の推奨事項を変更しません。"
    },
    {
      "indent": 0,
      "text": "6.4. Baseline Secure FECFRAME Operation",
      "section_title": true,
      "ja": "6.4. ベースラインの安全なFECFRAME操作"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon FEC Scheme specified in this document does not change the recommendations of [RFC6363] concerning the use of the IPsec/ESP security protocol as a mandatory to implement (but not mandatory to use) security scheme. This is well suited to situations where the only insecure domain is the one over which FECFRAME operates.",
      "ja": "このドキュメントで指定されているリードソロモンFECスキームは、IPsec / ESPセキュリティプロトコルをセキュリティスキームの実装に必須（ただし必須ではない）として使用することに関する[RFC6363]の推奨事項を変更しません。これは、安全でないドメインがFECFRAMEが動作するドメインだけである状況に適しています。"
    },
    {
      "indent": 0,
      "text": "7. Operations and Management Considerations",
      "section_title": true,
      "ja": "7. 運用と管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The FECFRAME document [RFC6363] provides a comprehensive analysis of operations and management considerations applicable to FEC schemes. Therefore, the present section only discusses topics that are specific to the use of Reed-Solomon codes as specified in this document.",
      "ja": "FECFRAMEドキュメント[RFC6363]は、FECスキームに適用可能な運用と管理の考慮事項の包括的な分析を提供します。したがって、このセクションでは、このドキュメントで指定されているリードソロモンコードの使用に固有のトピックについてのみ説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Operational Recommendations: Finite Field Size (m)",
      "section_title": true,
      "ja": "7.1. 運用上の推奨事項：有限フィールドサイズ（m）"
    },
    {
      "indent": 3,
      "text": "The present document requires that m, the length of the elements in the finite field in bits, is such that 2 <= m <= 16. However, all possibilities are not equally interesting from a practical point of view. It is expected that m = 8, the default value, will be mostly used since it offers the possibility to have small to medium sized source blocks and/or a significant number of repair symbols (i.e., k < n <= 255). Additionally, elements in the finite field are 8 bits long, which makes read/write memory operations aligned on bytes during encoding and decoding.",
      "ja": "現在の文書では、有限フィールド内の要素の長さであるmが2 <= m <= 16である必要があります。しかし、すべての可能性が実用的な観点から等しく興味深いわけではありません。小さなサイズから中程度のサイズのソースブロックやかなりの数の修復シンボル（つまり、k <n <= 255）が存在する可能性があるため、デフォルト値であるm = 8が主に使用されます。さらに、有限フィールドの要素は8ビット長であり、これにより、エンコードおよびデコード中に読み取り/書き込みメモリ操作がバイト単位で整列されます。"
    },
    {
      "indent": 3,
      "text": "An alternative when it is known that only very small source blocks will be used is m = 4 (i.e., k < n <= 15). Elements in the finite field are 4 bits long, so if 2 elements are accessed at a time, read/ write memory operations are aligned on bytes during encoding and decoding.",
      "ja": "非常に小さなソースブロックのみが使用されることがわかっている場合の代替案は、m = 4（つまり、k <n <= 15）です。有限フィールドの要素は4ビット長であるため、一度に2つの要素にアクセスした場合、メモリの読み取り/書き込み操作は、エンコードおよびデコード中にバイトで整列されます。"
    },
    {
      "indent": 3,
      "text": "An alternative when very large source blocks are needed is m = 16 (i.e., k < n<= 65535). However, this choice has significant impact on the processing load. For instance, using pre-calculated tables to speed up operations over the finite field (as done with smaller finite fields) may require a prohibitive amount of memory to be used on embedded platforms. Alternative lightweight solutions (e.g., LDPC FEC [RFC5170]) may be preferred in situations where the processing load is an issue and the source block length is large enough [Matsuzono10].",
      "ja": "非常に大きなソースブロックが必要な場合の代替方法は、m = 16（つまり、k <n <= 65535）です。ただし、この選択は処理負荷に大きな影響を与えます。たとえば、事前に計算されたテーブルを使用して、有限フィールドでの演算を高速化する（小さい有限フィールドで行われるように）場合、組み込みプラットフォームで使用できるメモリ量が非常に多くなる可能性があります。処理負荷が問題であり、ソースブロックの長さが十分に長い[Matsuzono10]状況では、代替の軽量ソリューション（LDPC FEC [RFC5170]など）が推奨される場合があります。"
    },
    {
      "indent": 3,
      "text": "Since several values for the m parameter are possible, the use case SHOULD define which value or values need to be supported. In situations where this is not specified, the default m = 8 value MUST be used.",
      "ja": "mパラメータには複数の値が考えられるため、サポートする必要のある値をユースケースで定義する必要があります（SHOULD）。これが指定されていない状況では、デフォルトのm = 8値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In any case, any compliant implementation MUST support at least the default m = 8 value.",
      "ja": "いずれの場合も、準拠する実装は少なくともデフォルトのm = 8値をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Values of FEC Encoding IDs are subject to IANA registration. [RFC6363] defines general guidelines on IANA considerations. In particular, it defines the \"FEC Framework (FECFRAME) FEC Encoding IDs\" subregistry of the \"Reliable Multicast Transport (RMT) FEC Encoding IDs and FEC Instance IDs\" registry, whose registration procedure is IETF Review.",
      "ja": "FECエンコーディングIDの値は、IANA登録の対象です。 [RFC6363]は、IANAの考慮事項に関する一般的なガイドラインを定義しています。特に、登録手順がIETF Reviewである「Reliable Multicast Transport（RMT）FEC Encoding IDs and FEC Instance IDs」レジストリの「FEC Framework（FECFRAME）FEC Encoding IDs」サブレジストリを定義しています。"
    },
    {
      "indent": 3,
      "text": "This document registers one value in the \"FEC Framework (FECFRAME) FEC Encoding IDs\" subregistry as follows:",
      "ja": "このドキュメントでは、「FECフレームワーク（FECFRAME）FECエンコーディングID」サブレジストリに次のように1つの値を登録しています。"
    },
    {
      "indent": 6,
      "text": "8 refers to the Simple Reed-Solomon [RFC5510] FEC Scheme over GF(2^^m) for Arbitrary Packet Flows.",
      "ja": "8は、任意のパケットフローのGF（2 ^^ m）を介したシンプルリードソロモン[RFC5510] FECスキームを指します。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors want to thank Hitoshi Asaeda and Ali Begen for their valuable comments.",
      "ja": "著者は貴重なコメントをしてくれた浅田仁史とアリ・ベーゲンに感謝したい。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, August 2007.",
      "ja": "[RFC5052] Watson、M.、Luby、M。、およびL. Vicisano、「Forward Error Correction（FEC）Building Block」、RFC 5052、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5510] Lacan, J., Roca, V., Peltotalo, J., and S. Peltotalo, \"Reed-Solomon Forward Error Correction (FEC) Schemes\", RFC 5510, April 2009.",
      "ja": "[RFC5510] Lacan、J.、Roca、V.、Peltotalo、J。、およびS. Peltotalo、「Reed-Solomon Forward Error Correction（FEC）Schemes」、RFC 5510、2009年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, October 2011.",
      "ja": "[RFC6363] Watson、M.、Begen、A。、およびV. Roca、「Forward Error Correction（FEC）Framework」、RFC 6363、2011年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6364] Begen, A., \"Session Description Protocol Elements for the Forward Error Correction (FEC) Framework\", RFC 6364, October 2011.",
      "ja": "[RFC6364] Begen、A。、「Forward Error Correction（FEC）フレームワークのセッション記述プロトコル要素」、RFC 6364、2011年10月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Matsuzono10] Matsuzono, K., Detchart, J., Cunche, M., Roca, V., and H. Asaeda, \"Performance Analysis of a High-Performance Real-Time Application with Several AL-FEC Schemes\", 35th Annual IEEE Conference on Local Computer Networks (LCN 2010), October 2010.",
      "ja": "[Matsuzono10]松園健一、デッチャートJ.、クンチェM.、ロカV.、および浅江宏、「AL-FECスキームをいくつか使用した高性能リアルタイムアプリケーションのパフォーマンス分析」、35回目ローカルコンピュータネットワークに関するIEEE会議（LCN 2010）、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5053] Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, \"Raptor Forward Error Correction Scheme for Object Delivery\", RFC 5053, October 2007.",
      "ja": "[RFC5053] Luby、M.、Shokrollahi、A.、Watson、M。、およびT. Stockhammer、「Raptor Forward Error Correction Scheme for Object Delivery」、RFC 5053、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5170] Roca, V., Neumann, C., and D. Furodet, \"Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes\", RFC 5170, June 2008.",
      "ja": "[RFC5170] Roca、V.、Neumann、C。、およびD. Furodet、「低密度パリティチェック（LDPC）階段および三角形前方誤り訂正（FEC）スキーム」、RFC 5170、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5740] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"NACK-Oriented Reliable Multicast (NORM) Transport Protocol\", RFC 5740, November 2009.",
      "ja": "[RFC5740] Adamson、B.、Bormann、C.、Handley、M。、およびJ. Macker、「NACK-Oriented Reliable Multicast（NORM）Transport Protocol」、RFC 5740、2009年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5775] Luby, M., Watson, M., and L. Vicisano, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", RFC 5775, April 2010.",
      "ja": "[RFC5775] Luby、M.、Watson、M。、およびL. Vicisano、「Asynchronous Layered Coding（ALC）Protocol Instantiation」、RFC 5775、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[Rizzo97] Rizzo, L., \"Effective Erasure Codes for Reliable Computer Communication Protocols\", ACM SIGCOMM Computer Communication Review, Vol.27, No.2, pp.24-36, April 1997.",
      "ja": "[Rizzo97]リッツォL.、「信頼性の高いコンピューター通信プロトコルの効果的な消去コード」、ACM SIGCOMMコンピューター通信レビュー、Vol.27、No.2、pp.24-36、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[RS-codec] Rizzo, L., \"Reed-Solomon FEC codec (C language)\", original codec: http://info.iet.unipi.it/~luigi/vdm98/ vdm980702.tgz, improved codec: http://openfec.org/, July 1998.",
      "ja": "[RS-codec] Rizzo、L。、「Reed-Solomon FEC codec（C language）」、元のコーデック：http://info.iet.unipi.it/~luigi/vdm98/ vdm980702.tgz、改良されたコーデック：http ：//openfec.org/、1998年7月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vincent Roca INRIA 655, av. de l'Europe Inovallee; Montbonnot ST ISMIER cedex 38334 France",
      "ja": "ヴィンセントロカINRIA 655、av。イノヴァリーヨーロッパの; Montbonnot ST ISMIER cedex 38334フランス"
    },
    {
      "indent": 3,
      "text": "EMail: vincent.roca@inria.fr\nURI:   http://planete.inrialpes.fr/people/roca/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mathieu Cunche INSA-Lyon/INRIA Laboratoire CITI 6 av. des Arts Villeurbanne cedex 69621 France",
      "ja": "マシュー・クンシェINSA-リヨン/ INRIA CITIラボ6 av。 des Arts Villeurbanne cedex 69621フランス"
    },
    {
      "indent": 3,
      "text": "EMail: mathieu.cunche@inria.fr\nURI:   http://mathieu.cunche.free.fr/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jerome Lacan ISAE, Univ. of Toulouse 10 av. Edouard Belin; BP 54032 Toulouse cedex 4 31055 France",
      "ja": "ジェローム・ラカンISAE、大学トゥールーズ10のAV。エドワール・ベリン; BP 54032 Toulouse cedex 4 31055フランス"
    },
    {
      "indent": 3,
      "text": "EMail: jerome.lacan@isae.fr\nURI:   http://personnel.isae.fr/jerome-lacan/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Amine Bouabdallah CDTA Center for Development of Advanced Technologies Cite 20 aout 1956, Baba Hassen Algiers Algeria",
      "ja": "Amine Bouabdallah CDTA Center for Development for Advanced Technologies Cite 20 aout 1956、Baba Hassen Algiers Algeria"
    },
    {
      "indent": 3,
      "text": "EMail: abouabdallah@cdta.dz",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kazuhisa Matsuzono Keio University Graduate School of Media and Governance 5322 Endo Fujisawa, Kanagawa 252-8520 Japan",
      "ja": "かずひさ まつぞの けいお うにゔぇｒしｔｙ Ｇらづあて Ｓちょおｌ おｆ めぢあ あんｄ ごゔぇｒなんせ ５３２２ えんど ふじさわ、 かながわ ２５２ー８５２０ じゃぱん"
    },
    {
      "indent": 3,
      "text": "EMail: kazuhisa@sfc.wide.ad.jp",
      "raw": true,
      "ja": ""
    }
  ]
}