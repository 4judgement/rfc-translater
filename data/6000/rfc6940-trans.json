{
  "title": {
    "text": "RFC 6940 - REsource LOcation And Discovery (RELOAD) Base Protocol",
    "ja": "RFC 6940 - LOcation And Discovery（RELOAD）ベースプロトコルを再利用"
  },
  "number": 6940,
  "created_at": "2020-09-04 19:20:41.012505+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       C. Jennings\nRequest for Comments: 6940                                         Cisco\nCategory: Standards Track                               B. Lowekamp, Ed.\nISSN: 2070-1721                                                    Skype\n                                                             E. Rescorla\n                                                              RTFM, Inc.\n                                                                S. Baset\n                                                          H. Schulzrinne\n                                                     Columbia University\n                                                            January 2014",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "REsource LOcation And Discovery (RELOAD) Base Protocol",
      "ja": "LOcation And Discovery（RELOAD）ベースプロトコルを再利用"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P signaling protocol provides its clients with an abstract storage and messaging service between a set of cooperating peers that form the overlay network. RELOAD is designed to support a P2P Session Initiation Protocol (P2PSIP) network, but can be utilized by other applications with similar requirements by defining new usages that specify the Kinds of data that need to be stored for a particular application. RELOAD defines a security model based on a certificate enrollment service that provides unique identities. NAT traversal is a fundamental service of the protocol. RELOAD also allows access from \"client\" nodes that do not need to route traffic or store data for others.",
      "ja": "この仕様は、インターネットで使用するピアツーピア（P2P）シグナリングプロトコルであるREsource LOcation And Discovery（RELOAD）を定義しています。 P2Pシグナリングプロトコルは、オーバーレイネットワークを形成する一連の協調するピア間の抽象ストレージおよびメッセージングサービスをクライアントに提供します。 RELOADは、P2Pセッション開始プロトコル（P2PSIP）ネットワークをサポートするように設計されていますが、特定のアプリケーションに格納する必要があるデータの種類を指定する新しい使用法を定義することにより、同様の要件を持つ他のアプリケーションで利用できます。 RELOADは、一意のIDを提供する証明書登録サービスに基づくセキュリティモデルを定義します。 NATトラバーサルは、プロトコルの基本的なサービスです。 RELOADは、トラフィックをルーティングしたり、他の人のためにデータを保存したりする必要のない「クライアント」ノードからのアクセスも許可します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6940.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6940で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2014 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。この素材の一部で著作権を管理している人が、IETFトラストにそのような素材の変更を許可する権利を付与していない可能性がありますIETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得せずに、このドキュメントをIETF標準プロセス外で変更したり、その派生物をIETF標準プロセス外で作成したりすることはできません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7\n  1.1.  Basic Setting . . . . . . . . . . . . . . . . . . . . . .   8\n  1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .  10\n    1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . . . .  13\n    1.2.2.  Message Transport . . . . . . . . . . . . . . . . . .  13\n    1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .  14\n    1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15\n    1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16\n  1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16\n  1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17\n2.  Requirements Language . . . . . . . . . . . . . . . . . . . .  18\n3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  18\n4.  Overlay Management Overview . . . . . . . . . . . . . . . . .  21\n  4.1.  Security and Identification . . . . . . . . . . . . . . .  21\n    4.1.1.  Shared-Key Security . . . . . . . . . . . . . . . . .  23\n  4.2.  Clients . . . . . . . . . . . . . . . . . . . . . . . . .  23\n    4.2.1.  Client Routing  . . . . . . . . . . . . . . . . . . .  24\n    4.2.2.  Minimum Functionality Requirements for Clients  . . .  25\n  4.3.  Routing . . . . . . . . . . . . . . . . . . . . . . . . .  25",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  4.4.  Connectivity Management . . . . . . . . . . . . . . . . .  29\n  4.5.  Overlay Algorithm Support . . . . . . . . . . . . . . . .  30\n    4.5.1.  Support for Pluggable Overlay Algorithms  . . . . . .  30\n    4.5.2.  Joining, Leaving, and Maintenance Overview  . . . . .  30\n  4.6.  First-Time Setup  . . . . . . . . . . . . . . . . . . . .  32\n    4.6.1.  Initial Configuration . . . . . . . . . . . . . . . .  32\n    4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . . .  32\n    4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .  33\n5.  Application Support Overview  . . . . . . . . . . . . . . . .  33\n  5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33\n    5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34\n    5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35\n  5.2.  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n  5.3.  Service Discovery . . . . . . . . . . . . . . . . . . . .  36\n  5.4.  Application Connectivity  . . . . . . . . . . . . . . . .  36\n6.  Overlay Management Protocol . . . . . . . . . . . . . . . . .  37\n  6.1.  Message Receipt and Forwarding  . . . . . . . . . . . . .  37\n    6.1.1.  Responsible ID  . . . . . . . . . . . . . . . . . . .  38\n    6.1.2.  Other ID  . . . . . . . . . . . . . . . . . . . . . .  38\n    6.1.3.  Opaque ID . . . . . . . . . . . . . . . . . . . . . .  40\n  6.2.  Symmetric Recursive Routing . . . . . . . . . . . . . . .  41\n    6.2.1.  Request Origination . . . . . . . . . . . . . . . . .  41\n    6.2.2.  Response Origination  . . . . . . . . . . . . . . . .  42\n  6.3.  Message Structure . . . . . . . . . . . . . . . . . . . .  42\n    6.3.1.  Presentation Language . . . . . . . . . . . . . . . .  43\n      6.3.1.1.  Common Definitions  . . . . . . . . . . . . . . .  44\n    6.3.2.  Forwarding Header . . . . . . . . . . . . . . . . . .  46\n      6.3.2.1.  Processing Configuration Sequence Numbers . . . .  49\n      6.3.2.2.  Destination and Via Lists . . . . . . . . . . . .  50\n      6.3.2.3.  Forwarding Option . . . . . . . . . . . . . . . .  52\n    6.3.3.  Message Contents Format . . . . . . . . . . . . . . .  53\n      6.3.3.1.  Response Codes and Response Errors  . . . . . . .  54\n    6.3.4.  Security Block  . . . . . . . . . . . . . . . . . . .  57\n  6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . . . .  60\n    6.4.1.  Topology Plug-in Requirements . . . . . . . . . . . .  60\n    6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .  61\n      6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61\n      6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62\n      6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63\n      6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63\n      6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65\n  6.5.  Forwarding and Link Management Layer  . . . . . . . . . .  67\n    6.5.1.  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67\n      6.5.1.1.  Request Definition  . . . . . . . . . . . . . . .  68\n      6.5.1.2.  Response Definition . . . . . . . . . . . . . . .  70\n      6.5.1.3.  Using ICE with RELOAD . . . . . . . . . . . . . .  71\n      6.5.1.4.  Collecting STUN Servers . . . . . . . . . . . . .  71\n      6.5.1.5.  Gathering Candidates  . . . . . . . . . . . . . .  72",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "      6.5.1.6.  Prioritizing Candidates . . . . . . . . . . . . .  72\n      6.5.1.7.  Encoding the Attach Message . . . . . . . . . . .  73\n      6.5.1.8.  Verifying ICE Support . . . . . . . . . . . . . .  74\n      6.5.1.9.  Role Determination  . . . . . . . . . . . . . . .  74\n      6.5.1.10. Full ICE  . . . . . . . . . . . . . . . . . . . .  74\n      6.5.1.11. No-ICE  . . . . . . . . . . . . . . . . . . . . .  75\n      6.5.1.12. Subsequent Offers and Answers . . . . . . . . . .  75\n      6.5.1.13. Sending Media . . . . . . . . . . . . . . . . . .  75\n      6.5.1.14. Receiving Media . . . . . . . . . . . . . . . . .  75\n    6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . . . .  75\n      6.5.2.1.  Request Definition  . . . . . . . . . . . . . . .  76\n      6.5.2.2.  Response Definition . . . . . . . . . . . . . . .  77\n    6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77\n      6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77\n      6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77\n    6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78\n      6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78\n      6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79\n  6.6.  Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80\n    6.6.1.  Future Overlay Link Protocols . . . . . . . . . . . .  81\n      6.6.1.1.  HIP . . . . . . . . . . . . . . . . . . . . . . .  82\n      6.6.1.2.  ICE-TCP . . . . . . . . . . . . . . . . . . . . .  82\n      6.6.1.3.  Message-Oriented Transports . . . . . . . . . . .  82\n      6.6.1.4.  Tunneled Transports . . . . . . . . . . . . . . .  82\n    6.6.2.  Framing Header  . . . . . . . . . . . . . . . . . . .  83\n    6.6.3.  Simple Reliability  . . . . . . . . . . . . . . . . .  84\n      6.6.3.1.  Stop and Wait Sender Algorithm  . . . . . . . . .  85\n    6.6.4.  DTLS/UDP with SR  . . . . . . . . . . . . . . . . . .  86\n    6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . . . . . . . . .  86\n    6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . . . . . . . .  87\n  6.7.  Fragmentation and Reassembly  . . . . . . . . . . . . . .  87\n7.  Data Storage Protocol . . . . . . . . . . . . . . . . . . . .  88\n  7.1.  Data Signature Computation  . . . . . . . . . . . . . . .  90\n  7.2.  Data Models . . . . . . . . . . . . . . . . . . . . . . .  91\n    7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . . .  91\n    7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .  92\n    7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92\n  7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93\n    7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n    7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n    7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93\n    7.3.4.  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94\n  7.4.  Data Storage Methods  . . . . . . . . . . . . . . . . . .  94\n    7.4.1.  Store . . . . . . . . . . . . . . . . . . . . . . . .  94\n      7.4.1.1.  Request Definition  . . . . . . . . . . . . . . .  94\n      7.4.1.2.  Response Definition . . . . . . . . . . . . . . . 100\n      7.4.1.3.  Removing Values . . . . . . . . . . . . . . . . . 101",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    7.4.2.  Fetch . . . . . . . . . . . . . . . . . . . . . . . . 102\n      7.4.2.1.  Request Definition  . . . . . . . . . . . . . . . 102\n      7.4.2.2.  Response Definition . . . . . . . . . . . . . . . 104\n    7.4.3.  Stat  . . . . . . . . . . . . . . . . . . . . . . . . 105\n      7.4.3.1.  Request Definition  . . . . . . . . . . . . . . . 105\n      7.4.3.2.  Response Definition . . . . . . . . . . . . . . . 106\n    7.4.4.  Find  . . . . . . . . . . . . . . . . . . . . . . . . 107\n      7.4.4.1.  Request Definition  . . . . . . . . . . . . . . . 108\n      7.4.4.2.  Response Definition . . . . . . . . . . . . . . . 108\n    7.4.5.  Defining New Kinds  . . . . . . . . . . . . . . . . . 109\n8.  Certificate Store Usage . . . . . . . . . . . . . . . . . . . 110\n9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . . . . 110\n10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . . . 112\n  10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 113\n  10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114\n  10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114\n  10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114\n  10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115\n  10.6.  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116\n  10.7.  Updates  . . . . . . . . . . . . . . . . . . . . . . . . 117\n    10.7.1.  Handling Neighbor Failures . . . . . . . . . . . . . 118\n    10.7.2.  Handling Finger Table Entry Failure  . . . . . . . . 119\n    10.7.3.  Receiving Updates  . . . . . . . . . . . . . . . . . 119\n    10.7.4.  Stabilization  . . . . . . . . . . . . . . . . . . . 120\n      10.7.4.1.  Updating the Neighbor Table  . . . . . . . . . . 120\n      10.7.4.2.  Refreshing the Finger Table  . . . . . . . . . . 121\n      10.7.4.3.  Adjusting Finger Table Size  . . . . . . . . . . 122\n      10.7.4.4.  Detecting Partitioning . . . . . . . . . . . . . 122\n  10.8.  Route Query  . . . . . . . . . . . . . . . . . . . . . . 123\n  10.9.  Leaving  . . . . . . . . . . . . . . . . . . . . . . . . 123\n11. Enrollment and Bootstrap  . . . . . . . . . . . . . . . . . . 124\n  11.1.  Overlay Configuration  . . . . . . . . . . . . . . . . . 124\n    11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . . . . . 132\n  11.2.  Discovery through Configuration Server . . . . . . . . . 134\n  11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . . . 135\n    11.3.1.  Self-Generated Credentials . . . . . . . . . . . . . 137\n  11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138\n12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138\n13. Security Considerations . . . . . . . . . . . . . . . . . . . 144\n  13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144\n  13.2.  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145\n  13.3.  Certificate-Based Security . . . . . . . . . . . . . . . 145\n  13.4.  Shared-Secret Security . . . . . . . . . . . . . . . . . 147\n  13.5.  Storage Security . . . . . . . . . . . . . . . . . . . . 147\n    13.5.1.  Authorization  . . . . . . . . . . . . . . . . . . . 147\n    13.5.2.  Distributed Quota  . . . . . . . . . . . . . . . . . 148\n    13.5.3.  Correctness  . . . . . . . . . . . . . . . . . . . . 148\n    13.5.4.  Residual Attacks . . . . . . . . . . . . . . . . . . 149",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  13.6.  Routing Security . . . . . . . . . . . . . . . . . . . . 149\n    13.6.1.  Background . . . . . . . . . . . . . . . . . . . . . 150\n    13.6.2.  Admissions Control . . . . . . . . . . . . . . . . . 150\n    13.6.3.  Peer Identification and Authentication . . . . . . . 151\n    13.6.4.  Protecting the Signaling . . . . . . . . . . . . . . 151\n    13.6.5.  Routing Loops and DoS Attacks  . . . . . . . . . . . 152\n    13.6.6.  Residual Attacks . . . . . . . . . . . . . . . . . . 152\n14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 153\n  14.1.  Well-Known URI Registration  . . . . . . . . . . . . . . 153\n  14.2.  Port Registrations . . . . . . . . . . . . . . . . . . . 153\n  14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . . 154\n  14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154\n  14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155\n  14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155\n  14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156\n  14.8.  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156\n  14.9.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . 158\n  14.10. Overlay Link Types . . . . . . . . . . . . . . . . . . . 159\n  14.11. Overlay Link Protocols . . . . . . . . . . . . . . . . . 159\n  14.12. Forwarding Options . . . . . . . . . . . . . . . . . . . 160\n  14.13. Probe Information Types  . . . . . . . . . . . . . . . . 160\n  14.14. Message Extensions . . . . . . . . . . . . . . . . . . . 161\n  14.15. Reload URI Scheme  . . . . . . . . . . . . . . . . . . . 161\n    14.15.1.  URI Registration  . . . . . . . . . . . . . . . . . 162\n  14.16. Media Type Registration  . . . . . . . . . . . . . . . . 162\n  14.17. XML Namespace Registration . . . . . . . . . . . . . . . 163\n    14.17.1.  Config URL  . . . . . . . . . . . . . . . . . . . . 164\n    14.17.2.  Config Chord URL  . . . . . . . . . . . . . . . . . 164\n15. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164\n16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 165\n  16.1.  Normative References . . . . . . . . . . . . . . . . . . 165\n  16.2.  Informative References . . . . . . . . . . . . . . . . . 167\nAppendix A.  Routing Alternatives . . . . . . . . . . . . . . . . 171\n  A.1.  Iterative vs. Recursive . . . . . . . . . . . . . . . . . 171\n  A.2.  Symmetric vs. Forward Response  . . . . . . . . . . . . . 171\n  A.3.  Direct Response . . . . . . . . . . . . . . . . . . . . . 172\n  A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . . 173\n  A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173\nAppendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174\n  B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174\n  B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. RELOAD provides a generic, self-organizing overlay network service, allowing nodes to route messages to other nodes and to store and retrieve data in the overlay. RELOAD provides several features that are critical for a successful P2P protocol for the Internet:",
      "ja": "このドキュメントでは、インターネットで使用するピアツーピア（P2P）シグナリングプロトコルであるREsource LOcation And Discovery（RELOAD）を定義しています。 RELOADは、汎用の自己組織化オーバーレイネットワークサービスを提供します。これにより、ノードは他のノードにメッセージをルーティングし、オーバーレイにデータを保存および取得できます。 RELOADは、インターネットでP2Pプロトコルを成功させるために重要ないくつかの機能を提供します。"
    },
    {
      "indent": 3,
      "text": "Security Framework: A P2P network will often be established among a set of peers that do not trust each other. RELOAD leverages a central enrollment server to provide credentials for each peer, which can then be used to authenticate each operation. This greatly reduces the possible attack surface.",
      "ja": "セキュリティフレームワーク：P2Pネットワークは、相互に信頼しない一連のピア間に確立されることがよくあります。 RELOADは、中央の登録サーバーを利用して各ピアに資格情報を提供します。これは、各操作の認証に使用できます。これにより、攻撃を受ける可能性が大幅に減少します。"
    },
    {
      "indent": 3,
      "text": "Usage Model: RELOAD is designed to support a variety of applications, including P2P multimedia communications with the Session Initiation Protocol (SIP) [SIP-RELOAD]. RELOAD allows the definition of new application usages, each of which can define its own data types, along with the rules for their use. This allows RELOAD to be used with new applications through a simple documentation process that supplies the details for each application.",
      "ja": "使用モデル：RELOADは、Session Initiation Protocol（SIP）[SIP-RELOAD]によるP2Pマルチメディア通信を含む、さまざまなアプリケーションをサポートするように設計されています。 RELOADを使用すると、新しいアプリケーションの使用法を定義できます。それぞれのアプリケーションでは、独自のデータ型とその使用規則を定義できます。これにより、各アプリケーションの詳細を提供する簡単なドキュメントプロセスを通じて、RELOADを新しいアプリケーションで使用できます。"
    },
    {
      "indent": 3,
      "text": "NAT Traversal: RELOAD is designed to function in environments where many, if not most, of the nodes are behind NATs or firewalls. Operations for NAT traversal are part of the base design, including using Interactive Connectivity Establishment (ICE) [RFC5245] to establish new RELOAD or application protocol connections.",
      "ja": "NATトラバーサル：RELOADは、ほとんどではないにしても多くのノードがNATまたはファイアウォールの背後にある環境で機能するように設計されています。 NATトラバーサルの操作は基本設計の一部であり、インタラクティブ接続確立（ICE）[RFC5245]を使用して新しいRELOADまたはアプリケーションプロトコル接続を確立することを含みます。"
    },
    {
      "indent": 3,
      "text": "Optimized Routing: The very nature of overlay algorithms introduces a requirement that peers participating in the P2P network route requests on behalf of other peers in the network. This introduces a load on those other peers in the form of bandwidth and processing power. RELOAD has been defined with a simple, lightweight forwarding header, thus minimizing the amount of effort for intermediate peers.",
      "ja": "最適化されたルーティング：オーバーレイアルゴリズムの性質上、P2Pネットワークに参加しているピアがネットワーク内の他のピアに代わってリクエストをルーティングする必要があります。これにより、帯域幅と処理能力の形で他のピアに負荷がかかります。 RELOADは、シンプルで軽量な転送ヘッダーで定義されているため、中間ピアの労力を最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": " Pluggable Overlay Algorithms: RELOAD has been designed with an abstract interface to the overlay layer to simplify implementing a variety of structured (e.g., distributed hash tables (DHTs)) and unstructured overlay algorithms. The idea here is that RELOAD provides a generic structure that can fit most types of overlay topologies (ring, hyperspace, etc.). To instantiate an actual network, you combine RELOAD with a specific overlay algorithm, which defines how to construct the overlay topology and route messages efficiently within it. This specification also defines how RELOAD is used with the Chord-based [Chord] DHT algorithm, which is mandatory to implement. Specifying a default \"mandatory-to-implement\" overlay algorithm promotes interoperability, while extensibility allows selection of overlay algorithms optimized for a particular application.",
      "ja": "プラグ可能なオーバーレイアルゴリズム：RELOADは、さまざまな構造化（分散ハッシュテーブル（DHT）など）および非構造化オーバーレイアルゴリズムの実装を簡素化するために、オーバーレイレイヤーへの抽象的なインターフェイスで設計されています。ここでの考え方は、RELOADがほとんどのタイプのオーバーレイトポロジ（リング、ハイパースペースなど）に適合できる一般的な構造を提供するということです。実際のネットワークをインスタンス化するには、RELOADを特定のオーバーレイアルゴリズムと組み合わせます。このアルゴリズムは、オーバーレイトポロジを構築し、その中でメッセージを効率的にルーティングする方法を定義します。この仕様は、RELOADがコードベースの[Chord] DHTアルゴリズムでどのように使用されるかも定義しています。これは、実装が必須です。デフォルトの「実装に必須」のオーバーレイアルゴリズムを指定すると相互運用性が向上し、拡張性により特定のアプリケーションに最適化されたオーバーレイアルゴリズムを選択できます。"
    },
    {
      "indent": 3,
      "text": "Support for Clients: RELOAD clients differ from RELOAD peers primarily in that they do not store information on behalf of other nodes in the overlay. Rather, they use the overlay only to locate users and resources, as well as to store information and to contact other nodes.",
      "ja": "クライアントのサポート：RELOADクライアントは、主にオーバーレイ内の他のノードに代わって情報を格納しないという点で、RELOADピアとは異なります。むしろ、ユーザーとリソースを特定し、情報を保存し、他のノードに連絡するためだけにオーバーレイを使用します。"
    },
    {
      "indent": 3,
      "text": "These properties were designed specifically to meet the requirements for a P2P protocol to support SIP. This document defines the base protocol for the distributed storage and location service, as well as critical usage for NAT traversal. The SIP Usage itself is described separately in [SIP-RELOAD]. RELOAD is not limited to usage by SIP and could serve as a tool for supporting other P2P applications with similar needs.",
      "ja": "これらのプロパティは、SIPをサポートするP2Pプロトコルの要件を満たすように特別に設計されました。このドキュメントでは、分散ストレージとロケーションサービスの基本プロトコル、およびNATトラバーサルの重要な使用法を定義します。 SIPの使用法自体は、[SIP-RELOAD]で個別に説明されています。 RELOADはSIPによる使用に限定されず、同様のニーズを持つ他のP2Pアプリケーションをサポートするツールとして機能します。"
    },
    {
      "indent": 0,
      "text": "1.1. Basic Setting",
      "section_title": true,
      "ja": "1.1. 標準設定"
    },
    {
      "indent": 3,
      "text": "In this section, we provide a brief overview of the operational setting for RELOAD. A RELOAD Overlay Instance consists of a set of nodes arranged in a partly connected graph. Each node in the overlay is assigned a numeric Node-ID for the lifetime of the node, which, together with the specific overlay algorithm in use, determines its position in the graph and the set of nodes it connects to. The Node-ID is also tightly coupled to the certificate (see Section 13.3). The figure below shows a trivial example which isn't drawn from any particular overlay algorithm, but was chosen for convenience of representation.",
      "ja": "このセクションでは、RELOADの操作設定の概要を説明します。 RELOADオーバーレイインスタンスは、部分的に接続されたグラフに配置されたノードのセットで構成されます。オーバーレイの各ノードには、ノードの存続期間の数値ノードIDが割り当てられます。ノードIDは、使用中の特定のオーバーレイアルゴリズムとともに、グラフ内の位置と、ノードが接続するノードのセットを決定します。 Node-IDは、証明書と密に結合されています（セクション13.3を参照）。以下の図は、特定のオーバーレイアルゴリズムから抽出されたものではないが、表現の便宜のために選択された簡単な例を示しています。"
    },
    {
      "indent": 6,
      "text": "+--------+              +--------+              +--------+\n| Node 10|--------------| Node 20|--------------| Node 30|\n+--------+              +--------+              +--------+\n    |                       |                       |\n    |                       |                       |\n+--------+              +--------+              +--------+\n| Node 40|--------------| Node 50|--------------| Node 60|\n+--------+              +--------+              +--------+\n    |                       |                       |\n    |                       |                       |\n+--------+              +--------+              +--------+\n| Node 70|--------------| Node 80|--------------| Node 90|\n+--------+              +--------+              +--------+\n                            |\n                            |\n                        +--------+\n                        | Node 85|\n                        |(Client)|\n                        +--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because the graph is not fully connected, when a node wants to send a message to another node, it may need to route it through the network. For instance, Node 10 can talk directly to nodes 20 and 40, but not to Node 70. In order to send a message to Node 70, it would first send it to Node 40, with instructions to pass it along to Node 70. Different overlay algorithms will have different connectivity graphs, but the general idea behind all of them is to allow any node in the graph to efficiently reach every other node within a small number of hops.",
      "ja": "グラフが完全に接続されていないため、ノードが別のノードにメッセージを送信する場合、ネットワークを介してルーティングする必要がある場合があります。たとえば、ノード10はノード20および40と直接通信できますが、ノード70とは通信できません。ノード70にメッセージを送信するには、まずノード40にメッセージを送信し、ノード70にメッセージを渡すように指示します。オーバーレイアルゴリズムには異なる接続グラフがありますが、それらすべての背後にある一般的な考え方は、グラフ内の任意のノードが少数のホップ内で他のすべてのノードに効率的に到達できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The RELOAD network is not only a messaging network. It is also a storage network, albeit one designed for small-scale transient storage rather than for bulk storage of large objects. Records are stored under numeric addresses, called Resource-IDs, which occupy the same space as node identifiers. Peers are responsible for storing the data associated with some set of addresses, as determined by their Node-ID. For instance, we might say that every peer is responsible for storing any data value which has an address less than or equal to its own Node-ID, but greater than the next lowest Node-ID. Thus, Node 20 would be responsible for storing values 11-20.",
      "ja": "RELOADネットワークは、メッセージングネットワークだけではありません。大きなオブジェクトのバルクストレージではなく小規模な一時ストレージ用に設計されていますが、これもストレージネットワークです。レコードは、リソースIDと呼ばれる数値アドレスの下に格納され、ノードIDと同じスペースを占有します。ピアは、ノードIDによって決定されるように、アドレスのセットに関連付けられたデータを格納する責任があります。たとえば、すべてのピアは、自身のノードID以下で、次の最小のノードIDよりも大きいアドレスを持つデータ値を格納する責任があると言えます。したがって、ノード20は値11〜20の格納を担当します。"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports clients. These are nodes which have Node-IDs but do not participate in routing or storage. For instance, in the figure above, Node 85 is a client. It can route to the rest of the RELOAD network via Node 80, but no other node will route through it, and Node 90 is still responsible for addresses in the range [81..90]. We refer to non-client nodes as peers.",
      "ja": "RELOADはクライアントもサポートします。これらはノードIDを持っているが、ルーティングやストレージには参加していないノードです。たとえば、上の図では、ノード85がクライアントです。ノード80を介してRELOADネットワークの残りの部分にルーティングできますが、他のノードはそれを介してルーティングせず、ノード90は依然として[81..90]の範囲のアドレスを担当します。非クライアントノードをピアと呼びます。"
    },
    {
      "indent": 3,
      "text": "Other applications (for instance, SIP) can be defined on top of RELOAD and can use these two basic RELOAD services to provide their own services.",
      "ja": "他のアプリケーション（SIPなど）をRELOADの上に定義し、これら2つの基本的なRELOADサービスを使用して独自のサービスを提供できます。"
    },
    {
      "indent": 0,
      "text": "1.2. Architecture",
      "section_title": true,
      "ja": "1.2. 建築"
    },
    {
      "indent": 3,
      "text": "RELOAD is fundamentally an overlay network. The following figure shows the layered RELOAD architecture.",
      "ja": "RELOADは基本的にオーバーレイネットワークです。次の図は、階層化されたRELOADアーキテクチャを示しています。"
    },
    {
      "indent": 12,
      "text": "Application",
      "ja": "応用"
    },
    {
      "indent": 4,
      "text": "    +-------+  +-------+\n    | SIP   |  | XMPP  |  ...\n    | Usage |  | Usage |\n    +-------+  +-------+\n------------------------------------ Messaging Service Boundary\n+------------------+     +---------+\n|     Message      |<--->| Storage |\n|    Transport     |     +---------+\n+------------------+           ^\n       ^       ^               |\n       |       v               v\n       |     +-------------------+\n       |     |    Topology       |\n       |     |    Plug-in        |\n       |     +-------------------+\n       |         ^\n       v         v\n    +------------------+\n    |  Forwarding &    |\n    | Link Management  |\n    +------------------+\n------------------------------------ Overlay Link Service Boundary\n     +-------+  +-------+\n     |TLS    |  |DTLS   |  ...\n     |Overlay|  |Overlay|\n     |Link   |  |Link   |\n     +-------+  +-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The major components of RELOAD are:",
      "ja": "RELOADの主要コンポーネントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Usage Layer: Each application defines a RELOAD Usage, which is a set of data Kinds and behaviors which describe how to use the services provided by RELOAD. These usages all talk to RELOAD through a common Message Transport Service.",
      "ja": "使用法レイヤー：各アプリケーションは、RELOAD使用法を定義します。これは、RELOADによって提供されるサービスの使用方法を説明するデータの種類と動作のセットです。これらの使用法はすべて、共通のメッセージ転送サービスを介してRELOADと通信します。"
    },
    {
      "indent": 3,
      "text": "Message Transport: Handles end-to-end reliability, manages request state for the usages, and forwards Store and Fetch operations to the Storage component. It delivers message responses to the component initiating the request.",
      "ja": "メッセージトランスポート：エンドツーエンドの信頼性を処理し、使用状況の要求状態を管理し、ストアおよびフェッチ操作をストレージコンポーネントに転送します。リクエストを開始するコンポーネントにメッセージ応答を配信します。"
    },
    {
      "indent": 3,
      "text": "Storage: The Storage component is responsible for processing messages relating to the storage and retrieval of data. It talks directly to the Topology Plug-in to manage data replication and migration, and it talks to the Message Transport component to send and receive messages.",
      "ja": "ストレージ：ストレージコンポーネントは、データの保存と取得に関するメッセージを処理します。トポロジプラグインと直接通信してデータの複製と移行を管理し、メッセージトランスポートコンポーネントと通信してメッセージを送受信します。"
    },
    {
      "indent": 3,
      "text": "Topology Plug-in: The Topology Plug-in is responsible for implementing the specific overlay algorithm being used. It uses the Message Transport component to send and receive overlay management messages, the Storage component to manage data replication, and the Forwarding Layer to control hop-by-hop message forwarding. This component superficially parallels conventional routing algorithms, but is more tightly coupled to the Forwarding Layer, because there is no single \"Routing Table\" equivalent used by all overlay algorithms. The Topology Plug-in has two functions: constructing the local forwarding instructions and selecting the operational topology (i.e., creating links by sending overlay management messages).",
      "ja": "トポロジプラグイン：トポロジプラグインは、使用されている特定のオーバーレイアルゴリズムの実装を担当します。メッセージトランスポートコンポーネントを使用してオーバーレイ管理メッセージを送受信し、ストレージコンポーネントを使用してデータ複製を管理し、転送レイヤーを使用してホップバイホップメッセージ転送を制御します。このコンポーネントは、表面的には従来のルーティングアルゴリズムに似ていますが、すべてのオーバーレイアルゴリズムで使用される「ルーティングテーブル」に相当するものがないため、フォワーディングレイヤーにより密接に結合されています。トポロジプラグインには2つの機能があります。ローカル転送命令の作成と運用トポロジの選択（つまり、オーバーレイ管理メッセージを送信してリンクを作成する）です。"
    },
    {
      "indent": 3,
      "text": "Forwarding and Link Management Layer: Stores and implements the Routing Table by providing packet forwarding services between nodes. It also handles establishing new links between nodes, including setting up connections for overlay links across NATs using ICE.",
      "ja": "転送およびリンク管理レイヤー：ノード間のパケット転送サービスを提供することにより、ルーティングテーブルを格納および実装します。また、ICEを使用してNAT全体のオーバーレイリンクの接続を設定するなど、ノード間の新しいリンクの確立も処理します。"
    },
    {
      "indent": 3,
      "text": "Overlay Link Layer: Responsible for actually transporting traffic directly between nodes. Transport Layer Security (TLS) [RFC5246] and Datagram Transport Layer Security (DTLS) [RFC6347] are the currently defined \"overlay link layer\" protocols used by RELOAD for hop-by-hop communication. Each such protocol includes the appropriate provisions for per-hop framing and hop-by-hop ACKs needed by unreliable underlying transports. New protocols can be defined, as described in Sections 6.6.1 and 11.1. As this document defines only TLS and DTLS, we use those terms throughout the remainder of the document with the understanding that some future specification may add new overlay link layers.",
      "ja": "オーバーレイリンクレイヤー：実際にノード間でトラフィックを直接転送します。トランスポート層セキュリティ（TLS）[RFC5246]およびデータグラムトランスポート層セキュリティ（DTLS）[RFC6347]は、ホップバイホップ通信のためにRELOADによって使用される、現在定義されている「オーバーレイリンク層」プロトコルです。このような各プロトコルには、信頼性のない基礎となるトランスポートが必要とするホップ単位のフレーミングとホップバイホップのACKに対する適切な規定が含まれています。セクション6.6.1および11.1で説明されているように、新しいプロトコルを定義できます。このドキュメントではTLSとDTLSのみを定義しているため、今後の仕様で新しいオーバーレイリンクレイヤーが追加される可能性があることを理解した上で、ドキュメントの残りの部分でこれらの用語を使用します。"
    },
    {
      "indent": 3,
      "text": "To further clarify the roles of the various layers, the following figure parallels the architecture with each layer's role from an overlay perspective and implementation layer in the Internet:",
      "ja": "さまざまなレイヤーの役割をさらに明確にするために、次の図は、アーキテクチャを、オーバーレイの観点およびインターネットの実装レイヤーから見た各レイヤーの役割に対応させています。"
    },
    {
      "indent": 3,
      "text": " Internet    | Internet Model  |\n Model       |   Equivalent    |          Reload\n             |   in Overlay    |       Architecture\n-------------+-----------------+------------------------------------\n             |                 |    +-------+  +-------+\n             |  Application    |    | SIP   |  | XMPP  |  ...\n             |                 |    | Usage |  | Usage |\n             |                 |    +-------+  +-------+\n             |                 |  ----------------------------------\n             |                 |+------------------+     +---------+\n             |   Transport     ||     Message      |<--->| Storage |\n             |                 ||    Transport     |     +---------+\n             |                 |+------------------+           ^\n             |                 |       ^       ^               |\n             |                 |       |       v               v\nApplication  |                 |       |     +-------------------+\n             |   (Routing)     |       |     |     Topology      |\n             |                 |       |     |     Plug-in       |\n             |                 |       |     +-------------------+\n             |                 |       |         ^\n             |                 |       v         v\n             |    Network      |    +------------------+\n             |                 |    |  Forwarding &    |\n             |                 |    | Link Management  |\n             |                 |    +------------------+\n             |                 |  ----------------------------------\nTransport    |      Link       |     +-------+  +------+\n             |                 |     |TLS    |  |DTLS  |  ...\n             |                 |     +-------+  +------+\n-------------+-----------------+------------------------------------\n  Network    |\n             |\n    Link     |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to the above components, nodes may communicate with a central provisioning infrastructure (not shown) to get configuration information, authentication credentials, and the initial set of nodes to communicate with to join the overlay.",
      "ja": "上記のコンポーネントに加えて、ノードは中央プロビジョニングインフラストラクチャ（図示せず）と通信して、構成情報、認証資格情報、およびオーバーレイに参加するために通信する最初のノードセットを取得します。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Usage Layer",
      "section_title": true,
      "ja": "1.2.1. 使用レイヤー"
    },
    {
      "indent": 3,
      "text": "The top layer, called the Usage Layer, has application usages, such as the SIP Registration Usage [SIP-RELOAD], that use the abstract Message Transport Service provided by RELOAD. The goal of this layer is to implement application-specific usages of the generic overlay services provided by RELOAD. The Usage defines how a specific application maps its data into something that can be stored in the overlay, where to store the data, how to secure the data, and finally how applications can retrieve and use the data.",
      "ja": "使用層と呼ばれる最上層には、SIP登録使用法[SIP-RELOAD]など、RELOADによって提供される抽象メッセージ転送サービスを使用するアプリケーション使用法があります。この層の目標は、RELOADによって提供される汎用オーバーレイサービスのアプリケーション固有の使用法を実装することです。 Usageは、特定のアプリケーションがオーバーレイに格納できるデータにデータをマッピングする方法、データを格納する場所、データを保護する方法、最後にアプリケーションがデータを取得して使用する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "The architecture diagram shows both a SIP Usage and an XMPP Usage. A single application may require multiple usages; for example, a voicemail feature in a softphone application that stores links to the messages in the overlay would require a different usage than the type of rendezvous service of XMPP or SIP. A usage may define multiple Kinds of data that are stored in the overlay and may also rely on Kinds originally defined by other usages.",
      "ja": "アーキテクチャ図は、SIPの使用とXMPPの使用の両方を示しています。 1つのアプリケーションで複数の使用法が必要になる場合があります。たとえば、メッセージへのリンクをオーバーレイに保存するソフトフォンアプリケーションのボイスメール機能では、XMPPまたはSIPのランデブーサービスのタイプとは異なる使用法が必要になります。使用法は、オーバーレイに格納されている複数の種類のデータを定義する場合があり、他の使用法によって最初に定義された種類に依存する場合もあります。"
    },
    {
      "indent": 3,
      "text": "Because the security and storage policies for each Kind are dictated by the usage defining the Kind, the usages may be coupled with the Storage component to provide security policy enforcement and to implement appropriate storage strategies according to the needs of the usage. The exact implementation of such an interface is outside the scope of this specification.",
      "ja": "各種類のセキュリティポリシーとストレージポリシーは、種類を定義する使用法によって決定されるため、使用法をストレージコンポーネントと組み合わせて、セキュリティポリシーを適用し、使用法のニーズに応じて適切なストレージ戦略を実装できます。そのようなインターフェースの正確な実装は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Message Transport",
      "section_title": true,
      "ja": "1.2.2. メッセージ転送"
    },
    {
      "indent": 3,
      "text": "The Message Transport component provides a generic message routing service for the overlay. The Message Transport layer is responsible for end-to-end message transactions. Each peer is identified by its location in the overlay, as determined by its Node-ID. A component that is a client of the Message Transport can perform two basic functions:",
      "ja": "メッセージ転送コンポーネントは、オーバーレイの一般的なメッセージルーティングサービスを提供します。メッセージトランスポート層は、エンドツーエンドのメッセージトランザクションを担当します。各ピアは、ノードIDによって決定される、オーバーレイ内の位置によって識別されます。メッセージ転送のクライアントであるコンポーネントは、2つの基本的な機能を実行できます。"
    },
    {
      "indent": 3,
      "text": "o Send a message to a given peer specified by Node-ID or to the peer responsible for a particular Resource-ID.",
      "ja": "o Node-IDで指定された特定のピアまたは特定のResource-IDを担当するピアにメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "o Receive messages that other peers sent to a Node-ID or Resource-ID for which the receiving peer is responsible.",
      "ja": "o 他のピアが受信側ピアが担当するノードIDまたはリソースIDに送信したメッセージを受信します。"
    },
    {
      "indent": 3,
      "text": "All usages rely on the Message Transport component to send and receive messages from peers. For instance, when a usage wants to store data, it does so by sending Store requests. Note that the Storage component and the Topology Plug-in are themselves clients of the Message Transport, because they need to send and receive messages from other peers.",
      "ja": "すべての使用法は、ピアからのメッセージの送受信をメッセージトランスポートコンポーネントに依存しています。たとえば、使用状況がデータを保存したい場合は、Storeリクエストを送信して行います。ストレージコンポーネントとトポロジプラグインは、他のピアとメッセージを送受信する必要があるため、それ自体がメッセージトランスポートのクライアントであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Message Transport Service is responsible for end-to-end reliability, which is accomplished by timer-based retransmissions. Unlike the Internet transport layer, however, this layer does not provide congestion control. RELOAD is a request-response protocol, with no more than two pairs of request-response messages used in typical transactions between pairs of nodes; therefore, there are no opportunities to observe and react to end-to-end congestion. As with all Internet applications, implementers are strongly discouraged from writing applications that react to loss by immediately retrying the transaction.",
      "ja": "メッセージトランスポートサービスは、タイマーベースの再送信によって実現されるエンドツーエンドの信頼性を担います。ただし、インターネットトランスポート層とは異なり、この層は輻輳制御を提供しません。 RELOADは要求/応答プロトコルであり、ノードのペア間の一般的なトランザクションで使用される要求/応答メッセージのペアは2つまでです。したがって、エンドツーエンドの輻輳を観察して対応する機会はありません。すべてのインターネットアプリケーションと同様に、実装者は、トランザクションをすぐに再試行することで損失に対応するアプリケーションを作成することを強くお勧めしません。"
    },
    {
      "indent": 3,
      "text": "The Message Transport Service is similar to those described as providing \"key-based routing\" (KBR) [wikiKBR], although as RELOAD supports different overlay algorithms (including non-DHT overlay algorithms) that calculate keys (storage indices, not encryption keys) in different ways, the actual interface needs to accept Resource Names rather than actual keys.",
      "ja": "メッセージトランスポートサービスは、「キーベースルーティング」（KBR）[wikiKBR]を提供するものとして説明されているものと似ていますが、RELOADはキー（暗号化キーではなくストレージインデックス）を計算するさまざまなオーバーレイアルゴリズム（非DHTオーバーレイアルゴリズムを含む）をサポートしますさまざまな方法で、実際のインターフェースは、実際のキーではなくリソース名を受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management layers are responsible for maintaining the overlay in the face of changes in the available nodes and underlying network supporting the overlay (the Internet). They also handle congestion control between overlay neighbors, and exchange routing updates and data replicas in addition to forwarding end-to-end messages.",
      "ja": "転送レイヤーとリンク管理レイヤーは、オーバーレイ（インターネット）をサポートする利用可能なノードと基盤となるネットワークの変更に直面しても、オーバーレイを維持する責任があります。また、オーバーレイネイバー間の輻輳制御を処理し、ルーティング更新とデータレプリカを交換して、エンドツーエンドメッセージを転送します。"
    },
    {
      "indent": 3,
      "text": "Real-world experience has shown that a fixed timeout for the end-to-end retransmission timer is sufficient for practical overlay networks. This timer is adjustable via the overlay configuration. As the overlay configuration can be rapidly updated, this value could be dynamically adjusted at coarse time scales, although algorithms for determining how to accomplish this are beyond the scope of this specification. In many cases, however, other means of improving network performance, such as having the Topology Plug-in remove lossy links from use in overlay routing or reducing the overall hop count of end-to-end paths, will be more effective than simply increasing the retransmission timer.",
      "ja": "実際の経験では、エンドツーエンドの再送信タイマーの固定タイムアウトは、実際のオーバーレイネットワークには十分であることが示されています。このタイマーは、オーバーレイ構成を介して調整できます。オーバーレイ構成は迅速に更新できるため、この値は粗い時間スケールで動的に調整できますが、これを行う方法を決定するアルゴリズムはこの仕様の範囲を超えています。ただし、多くの場合、トポロジプラグインでオーバーレイルーティングの使用から損失の多いリンクを削除したり、エンドツーエンドパスの全体のホップカウントを削減したりするなど、ネットワークパフォーマンスを向上させる他の方法は、単に再送信タイマー。"
    },
    {
      "indent": 0,
      "text": "1.2.3. Storage",
      "section_title": true,
      "ja": "1.2.3. ストレージ"
    },
    {
      "indent": 0,
      "text": " One of the major functions of RELOAD is storage of data, that is, allowing nodes to store data in the overlay and to retrieve data stored by other nodes or by themselves. The Storage component is responsible for processing data storage and retrieval messages. For instance, the Storage component might receive a Store request for a given resource from the Message Transport. It would then query the appropriate usage before storing the data value(s) in its local data store and sending a response to the Message Transport for delivery to the requesting node. Typically, these messages will come from other nodes, but depending on the overlay topology, a node might be responsible for storing data for itself as well, especially if the overlay is small.",
      "ja": "RELOADの主要な機能の1つはデータの格納です。つまり、ノードがオーバーレイにデータを格納したり、他のノードまたは自身が格納したデータを取得したりできます。ストレージコンポーネントは、データストレージと取得メッセージの処理を担当します。たとえば、ストレージコンポーネントは、メッセージトランスポートから特定のリソースのストアリクエストを受信する場合があります。次に、データ値をローカルデータストアに格納し、要求ノードへの配信のためにメッセージトランスポートに応答を送信する前に、適切な使用法を照会します。通常、これらのメッセージは他のノードから送信されますが、オーバーレイトポロジによっては、特にオーバーレイが小さい場合、ノードがそれ自体のデータを格納することもあります。"
    },
    {
      "indent": 3,
      "text": "A peer's Node-ID determines the set of resources that it will be responsible for storing. However, the exact mapping between these is determined by the overlay algorithm in use. The Storage component will only receive a Store request from the Message Transport if this peer is responsible for that Resource-ID. The Storage component is notified by the Topology Plug-in when the Resource-IDs for which it is responsible change, and the Storage component is then responsible for migrating resources to other peers.",
      "ja": "ピアのノードIDは、ピアが格納するリソースのセットを決定します。ただし、これらの間の正確なマッピングは、使用中のオーバーレイアルゴリズムによって決まります。ストレージコンポーネントは、このピアがそのResource-IDを担当している場合にのみ、メッセージトランスポートからストア要求を受け取ります。ストレージコンポーネントは、担当するリソースIDが変更されるとトポロジプラグインから通知され、ストレージコンポーネントは他のピアへのリソースの移行を担当します。"
    },
    {
      "indent": 0,
      "text": "1.2.4. Topology Plug-in",
      "section_title": true,
      "ja": "1.2.4. トポロジプラグイン"
    },
    {
      "indent": 3,
      "text": "RELOAD is explicitly designed to work with a variety of overlay algorithms. In order to facilitate this, the overlay algorithm implementation is provided by a Topology Plug-in so that each overlay can select an appropriate overlay algorithm that relies on the common RELOAD core protocols and code.",
      "ja": "RELOADは、さまざまなオーバーレイアルゴリズムで機能するように明示的に設計されています。これを容易にするために、トポロジプラグインによってオーバーレイアルゴリズムの実装が提供されるため、各オーバーレイは、共通のRELOADコアプロトコルとコードに依存する適切なオーバーレイアルゴリズムを選択できます。"
    },
    {
      "indent": 3,
      "text": "The Topology Plug-in is responsible for maintaining the overlay algorithm Routing Table, which is consulted by the Forwarding and Link Management Layer before routing a message. When connections are made or broken, the Forwarding and Link Management Layer notifies the Topology Plug-in, which adjusts the Routing Table as appropriate. The Topology Plug-in will also instruct the Forwarding and Link Management Layer to form new connections as dictated by the requirements of the overlay algorithm Topology. The Topology Plug-in issues periodic update requests through Message Transport to maintain and update its Routing Table.",
      "ja": "トポロジプラグインは、メッセージをルーティングする前に転送およびリンク管理レイヤーによって参照されるオーバーレイアルゴリズムのルーティングテーブルを維持する役割を果たします。接続が確立または切断されると、転送およびリンク管理レイヤーはトポロジプラグインに通知し、トポロジプラグインはルーティングテーブルを適切に調整します。トポロジプラグインは、オーバーレイアルゴリズムトポロジの要件に応じて、新しい接続を形成するように転送およびリンク管理レイヤーにも指示します。トポロジプラグインは、ルーティングテーブルを維持および更新するために、メッセージトランスポートを介して定期的な更新要求を発行します。"
    },
    {
      "indent": 3,
      "text": "As peers enter and leave, resources may be stored on different peers, so the Topology Plug-in also keeps track of which peers are responsible for which resources. As peers join and leave, the Topology Plug-in instructs the Storage component to issue resource migration requests as appropriate, in order to ensure that other peers have whatever resources they are now responsible for. The Topology Plug-in is also responsible for providing for redundant data storage to protect against loss of information in the event of a peer failure and to protect against compromised or subversive peers.",
      "ja": "ピアが出入りするとき、リソースは異なるピアに格納される可能性があるため、トポロジプラグインは、どのピアがどのリソースを担当しているかを追跡します。ピアが参加および脱退すると、トポロジプラグインはストレージコンポーネントに、適切にリソース移行リクエストを発行して、他のピアが現在担当しているリソースを確保するように指示します。トポロジープラグインは、ピアの障害発生時の情報の損失から保護し、侵害されたまたは破壊的なピアから保護するために冗長データストレージを提供する役割も果たします。"
    },
    {
      "indent": 0,
      "text": "1.2.5. Forwarding and Link Management Layer",
      "section_title": true,
      "ja": "1.2.5. 転送およびリンク管理レイヤー"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management Layer is responsible for getting a message to the next peer, as determined by the Topology Plug-in. This layer establishes and maintains the network connections as needed by the Topology Plug-in. This layer is also responsible for setting up connections to other peers through NATs and firewalls using ICE, and it can elect to forward traffic using relays for NAT and firewall traversal.",
      "ja": "転送およびリンク管理レイヤーは、トポロジプラグインによって決定された次のピアへのメッセージの取得を担当します。この層は、トポロジプラグインが必要とするネットワーク接続を確立および維持します。この層は、ICEを使用したNATおよびファイアウォールを介した他のピアへの接続のセットアップも担当し、NATおよびファイアウォールトラバーサルのリレーを使用してトラフィックを転送することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Congestion control is implemented at this layer to protect the Internet paths used to form the link in the overlay. Additionally, retransmission is performed to improve the reliability of end-to-end transactions. The relation of this layer to the Message Transport Layer can be likened to the relation of the link-level congestion control and retransmission in modern wireless networks ` to Internet transport protocols.",
      "ja": "輻輳制御はこのレイヤーで実装され、オーバーレイでリンクを形成するために使用されるインターネットパスを保護します。さらに、エンドツーエンドトランザクションの信頼性を向上させるために再送信が実行されます。このレイヤーとメッセージトランスポートレイヤーの関係は、リンクレベルの輻輳制御と最新のワイヤレスネットワークでの再送信のインターネットトランスポートプロトコルへの関係に例えることができます。"
    },
    {
      "indent": 3,
      "text": "This layer provides a generic interface that allows the Topology Plug-in to control the overlay and resource operations and messages. Because each overlay algorithm is defined and functions differently, we generically refer to the table of other peers that the overlay algorithm maintains and uses to route requests as a Routing Table. The Topology Plug-in actually owns the Routing Table, and forwarding decisions are made by querying the Topology Plug-in for the next hop for a particular Node-ID or Resource-ID. If this node is the destination of the message, the message is delivered to the Message Transport.",
      "ja": "この層は、トポロジプラグインがオーバーレイとリソース操作およびメッセージを制御できるようにする汎用インターフェイスを提供します。各オーバーレイアルゴリズムの定義と機能は異なるため、オーバーレイアルゴリズムが維持し、リクエストをルーティングテーブルとしてルーティングするために使用する他のピアのテーブルを総称的に参照します。トポロジプラグインは実際にルーティングテーブルを所有し、転送の決定は、特定のノードIDまたはリソースIDのネクストホップについてトポロジプラグインにクエリを実行することによって行われます。このノードがメッセージの宛先である場合、メッセージはメッセージトランスポートに配信されます。"
    },
    {
      "indent": 3,
      "text": "This layer also utilizes a framing header to encapsulate messages as they are forwarded along each hop. This header aids reliability congestion control, flow control, etc. It has meaning only in the context of that individual link.",
      "ja": "この層は、フレーミングヘッダーを利用して、メッセージが各ホップに沿って転送されるときにメッセージをカプセル化します。このヘッダーは、信頼性の輻輳制御、フロー制御などに役立ちます。これは、その個々のリンクのコンテキストでのみ意味があります。"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management Layer sits on top of the Overlay Link Layer protocols that carry the actual traffic. This specification defines how to use DTLS and TLS protocols to carry RELOAD messages.",
      "ja": "Forwarding and Link Management Layerは、実際のトラフィックを伝送するOverlay Link Layerプロトコルの上にあります。この仕様は、DTLSおよびTLSプロトコルを使用してRELOADメッセージを伝送する方法を定義しています。"
    },
    {
      "indent": 0,
      "text": "1.3. Security",
      "section_title": true,
      "ja": "1.3. 安全保障"
    },
    {
      "indent": 0,
      "text": " RELOAD's security model is based on each node having one or more public key certificates. In general, these certificates will be assigned by a central server, which also assigns Node-IDs, although self-signed certificates can be used in closed networks. These credentials can be leveraged to provide communications security for RELOAD messages. RELOAD provides communications security at three levels: Connection level: Connections between nodes are secured with TLS, DTLS, or potentially some to-be-defined future protocol.",
      "ja": "RELOADのセキュリティモデルは、1つ以上の公開鍵証明書を持つ各ノードに基づいています。一般に、これらの証明書は中央サーバーによって割り当てられます。中央サーバーはノードIDも割り当てますが、自己署名証明書は閉じたネットワークで使用できます。これらの資格情報を利用して、RELOADメッセージの通信セキュリティを提供できます。 RELOADは、3つのレベルで通信セキュリティを提供します。接続レベル：ノード間の接続は、TLS、DTLS、または将来的に定義される将来のプロトコルで保護されます。"
    },
    {
      "indent": 3,
      "text": "Message level: Each RELOAD message is signed.",
      "ja": "メッセージレベル：各RELOADメッセージは署名されます。"
    },
    {
      "indent": 3,
      "text": "Object Level: Stored objects are signed by the creating node.",
      "ja": "オブジェクトレベル：保存されたオブジェクトは作成ノードによって署名されます。"
    },
    {
      "indent": 3,
      "text": "These three levels of security work together to allow nodes to verify the origin and correctness of data they receive from other nodes, even in the face of malicious activity by other nodes in the overlay. RELOAD also provides access control built on top of these communications security features. Because the peer responsible for storing a piece of data can validate the signature on the data being stored, it can determine whether or not a given operation is permitted.",
      "ja": "これらの3つのレベルのセキュリティは連携して機能し、オーバーレイ内の他のノードによる悪意のあるアクティビティに直面した場合でも、ノードは他のノードから受信したデータの出所と正確性を検証できます。 RELOADは、これらの通信セキュリティ機能の上に構築されたアクセス制御も提供します。データの格納を担当するピアは、格納されるデータの署名を検証できるため、特定の操作が許可されているかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "RELOAD also provides an optional shared-secret-based admission control feature using shared secrets and TLS pre-shared keys (PSK) or TLS Secure Remote Password (SRP). In order to form a TLS connection to any node in the overlay, a new node needs to know the shared overlay key, thus restricting access to authorized users only. This feature is used together with certificate-based access control, not as a replacement for it. It is typically used when self-signed certificates are being used but would generally not be used when the certificates were all signed by an enrollment server.",
      "ja": "RELOADは、共有シークレットとTLS事前共有キー（PSK）またはTLSセキュアリモートパスワード（SRP）を使用するオプションの共有シークレットベースのアドミッションコントロール機能も提供します。オーバーレイ内の任意のノードへのTLS接続を形成するには、新しいノードが共有オーバーレイキーを知っている必要があるため、許可されたユーザーのみにアクセスを制限します。この機能は、証明書ベースのアクセス制御と一緒に使用され、その代わりとしては使用されません。これは通常、自己署名証明書が使用されている場合に使用されますが、証明書がすべて登録サーバーによって署名されている場合は通常使用されません。"
    },
    {
      "indent": 0,
      "text": "1.4. Structure of This Document",
      "section_title": true,
      "ja": "1.4. このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The remainder of this document is structured as follows.",
      "ja": "このドキュメントの残りの部分は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o Section 3 provides definitions of terms used in this document.",
      "ja": "o セクション3では、このドキュメントで使用されている用語の定義を示します。"
    },
    {
      "indent": 3,
      "text": "o Section 4 provides an overview of the mechanisms used to establish and maintain the overlay.",
      "ja": "o セクション4では、オーバーレイの確立と維持に使用されるメカニズムの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "o Section 5 provides an overview of the mechanism RELOAD provides to support other applications.",
      "ja": "o セクション5では、RELOADが他のアプリケーションをサポートするために提供するメカニズムの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "o Section 6 defines the protocol messages that RELOAD uses to establish and maintain the overlay.",
      "ja": "o セクション6では、RELOADがオーバーレイの確立と維持に使用するプロトコルメッセージを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 7 defines the protocol messages that are used to store and retrieve data using RELOAD.",
      "ja": "o セクション7では、RELOADを使用してデータを格納および取得するために使用されるプロトコルメッセージを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 8 defines the Certificate Store Usages.",
      "ja": "o セクション8では、証明書ストアの使用法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 9 defines the TURN Server Usage needed to locate TURN (Traversal Using Relays around NAT) servers for NAT traversal.",
      "ja": "o セクション9は、NATトラバーサル用のTURN（NATの周りにリレーを使用するトラバーサル）サーバーを見つけるために必要なTURN Serverの使用法を定義しています。"
    },
    {
      "indent": 3,
      "text": "o Section 10 defines a specific Topology Plug-in using a Chord-based algorithm.",
      "ja": "o セクション10では、コードベースのアルゴリズムを使用して特定のトポロジプラグインを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 11 defines the mechanisms that new RELOAD nodes use to join the overlay for the first time.",
      "ja": "o セクション11は、新しいRELOADノードが初めてオーバーレイに参加するために使用するメカニズムを定義しています。"
    },
    {
      "indent": 3,
      "text": "o Section 12 provides an extended example.",
      "ja": "o セクション12は、拡張された例を提供します。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "Terms in this document are defined in-line when used and are also defined below for reference. The definitions in this section use terminology and concepts that are not explained until later in the specification.",
      "ja": "このドキュメントの用語は、使用時にインラインで定義され、参照用に以下でも定義されています。このセクションの定義では、仕様の後半まで説明されていない用語と概念を使用しています。"
    },
    {
      "indent": 3,
      "text": "Admitting Peer (AP): A peer in the overlay which helps the Joining Node join the Overlay.",
      "ja": "Admitting Peer（AP）：参加ノードがオーバーレイに参加するのを助けるオーバーレイのピア。"
    },
    {
      "indent": 3,
      "text": "Bootstrap Node: A network node used by Joining Nodes to help locate the Admitting Peer.",
      "ja": "ブートストラップノード：参加ピアがアドミティングピアを見つけるのに役立つネットワークノード。"
    },
    {
      "indent": 3,
      "text": "Client: A host that is able to store data in and retrieve data from the overlay, but does not participate in routing or data storage for the overlay.",
      "ja": "クライアント：オーバーレイにデータを格納したり、オーバーレイからデータを取得したりできるが、オーバーレイのルーティングやデータストレージには参加しないホスト。"
    },
    {
      "indent": 3,
      "text": "Configuration Document: An XML document containing all the Overlay Parameters for one overlay instance.",
      "ja": "構成ドキュメント：1つのオーバーレイインスタンスのすべてのオーバーレイパラメータを含むXMLドキュメント。"
    },
    {
      "indent": 3,
      "text": "Connection Table: Contains connection information for the set of nodes to which a node is directly connected, which include nodes that are not yet available for routing.",
      "ja": "接続テーブル：ノードが直接接続されている一連のノードの接続情報が含まれます。これには、ルーティングにまだ使用できないノードが含まれます。"
    },
    {
      "indent": 3,
      "text": "Destination List: A list of Node-IDs, Resource-IDs, and Opaque IDs through which a message is to be routed, in strict order. A single Node-ID, Resource-ID, or Opaque ID is a trivial form of Destination List. When multiple Node-IDs are specified, a Destination List is a loose source route. The list is reduced hop by hop, and does not include the source but does include the destination.",
      "ja": "宛先リスト：メッセージがルーティングされるノードID、リソースID、および不透明IDのリスト。単一のノードID、リソースID、または不透明IDは、宛先リストの簡単な形式です。複数のノードIDが指定されている場合、宛先リストは緩やかなソースルートです。リストはホップごとに削減され、送信元は含まれませんが、宛先は含まれます。"
    },
    {
      "indent": 3,
      "text": "DHT: A distributed hash table. A DHT is an abstract storage service realized by storing the contents of the hash table across a set of peers.",
      "ja": "DHT：分散ハッシュテーブル。 DHTは、ピアのセット全体にハッシュテーブルのコンテンツを格納することによって実現される抽象的なストレージサービスです。"
    },
    {
      "indent": 3,
      "text": "ID: A generic term for any kind of identifiers in an Overlay. This document specifies an ID as being an Application-ID, a Kind-ID, a Node-ID, a transaction ID, a component ID, a response ID, a Resource-ID, or an Opaque ID.",
      "ja": "ID：オーバーレイのあらゆる種類の識別子の総称。このドキュメントでは、IDをアプリケーションID、種類ID、ノードID、トランザクションID、コンポーネントID、応答ID、リソースID、または不透明IDとして指定しています。"
    },
    {
      "indent": 3,
      "text": "Joining Node (JN): A node that is attempting to become a peer in a particular Overlay.",
      "ja": "参加ノード（IN）：特定のオーバーレイのピアになることを試みているノード。"
    },
    {
      "indent": 3,
      "text": "Kind: A Kind defines a particular type of data that can be stored in the overlay. Applications define new Kinds to store the data they use. Each Kind is identified with a unique integer called a Kind-ID.",
      "ja": "種類：種類は、オーバーレイに保存できる特定のタイプのデータを定義します。アプリケーションは、使用するデータを格納する新しい種類を定義します。各種類は、種類IDと呼ばれる一意の整数で識別されます。"
    },
    {
      "indent": 3,
      "text": "Kind-ID: A unique 32-bit value identifying a Kind. Kind-IDs are either private or allocated by IANA (see Section 14.6).",
      "ja": "Kind-ID：種類を識別する一意の32ビット値。種類IDはプライベートであるか、IANAによって割り当てられます（セクション14.6を参照）。"
    },
    {
      "indent": 3,
      "text": "Maximum Request Lifetime: The maximum time a request will wait for a response. This value is equal to the value of the overlay reliability value (defined in Section 11.1) multiplied by the number of transmissions (defined in Section 6.2.1), and so defaults to 15 seconds.",
      "ja": "最大要求存続時間：要求が応答を待つ最大時間。この値は、オーバーレイの信頼性値（セクション11.1で定義）に送信回数（セクション6.2.1で定義）を掛けた値に等しいため、デフォルトは15秒です。"
    },
    {
      "indent": 3,
      "text": "Node: The term \"node\" refers to a host that may be either a peer or a client. Because RELOAD uses the same protocol for both clients and peers, much of the text applies equally to both. Therefore, we use \"node\" when the text applies to both clients and peers, and we use the more specific term (i.e., \"client\" or \"peer\") when the text applies only to clients or only to peers.",
      "ja": "ノード：「ノード」という用語は、ピアまたはクライアントのいずれかである可能性があるホストを指します。 RELOADはクライアントとピアの両方に同じプロトコルを使用するため、テキストの多くは両方に等しく適用されます。したがって、テキストがクライアントとピアの両方に適用される場合は「ノード」を使用し、テキストがクライアントのみまたはピアのみに適用される場合はより具体的な用語（つまり、「クライアント」または「ピア」）を使用します。"
    },
    {
      "indent": 3,
      "text": "Node-ID: A value of fixed but configurable length that uniquely identifies a node. Node-IDs of all 0s and all 1s are reserved. A value of 0 is not used in the wire protocol, but can be used to indicate an invalid node in implementations and APIs. The Node-ID of all 1s is used on the wire protocol as a wildcard.",
      "ja": "ノードID：ノードを一意に識別する、固定されているが構成可能な長さの値。すべて0とすべて1のノードIDは予約されています。値0はワイヤプロトコルでは使用されませんが、実装とAPIで無効なノードを示すために使用できます。すべて1のノードIDは、ワイヤプロトコルでワイルドカードとして使用されます。"
    },
    {
      "indent": 3,
      "text": "Overlay Algorithm: An overlay algorithm defines the rules for determining which peers in an overlay store a particular piece of data and for determining a topology of interconnections amongst peers in order to find a piece of data.",
      "ja": "オーバーレイアルゴリズム：オーバーレイアルゴリズムは、オーバーレイ内のどのピアが特定のデータを格納するかを決定するためのルールと、データの一部を見つけるためにピア間の相互接続のトポロジを決定するためのルールを定義します。"
    },
    {
      "indent": 3,
      "text": "Overlay Instance: A specific overlay algorithm and the collection of peers that are collaborating to provide read and write access to it. Any number of overlay instances can be running in an IP network at a time, and each operates in isolation of the others.",
      "ja": "オーバーレイインスタンス：特定のオーバーレイアルゴリズムと、読み取りと書き込みのアクセスを提供するために協力しているピアのコレクション。任意の数のオーバーレイインスタンスを一度にIPネットワークで実行でき、それぞれが他のインスタンスと分離して動作します。"
    },
    {
      "indent": 3,
      "text": "Overlay Parameters: A set of values that are shared among all nodes in an overlay. The overlay parameters are distributed in an XML document called the Configuration Document.",
      "ja": "オーバーレイパラメータ：オーバーレイのすべてのノード間で共有される値のセット。オーバーレイパラメータは、構成ドキュメントと呼ばれるXMLドキュメントで配布されます。"
    },
    {
      "indent": 3,
      "text": "Peer: A host that is participating in the overlay. Peers are responsible for holding some portion of the data that has been stored in the overlay, and they are responsible for routing messages on behalf of other hosts as needed by the Overlay Algorithm.",
      "ja": "ピア：オーバーレイに参加しているホスト。ピアは、オーバーレイに格納されているデータの一部を保持する責任があり、オーバーレイアルゴリズムで必要に応じて、他のホストに代わってメッセージをルーティングする責任があります。"
    },
    {
      "indent": 3,
      "text": "Peer Admission: The act of admitting a node (the Joining Node) into an Overlay. After the admission process is over, the Joining Node is a fully functional peer of the overlay. During the admission process, the Joining Node may need to present credentials to prove that it has sufficient authority to join the overlay.",
      "ja": "ピアアドミッション：ノード（参加ノード）をオーバーレイに許可する行為。アドミッションプロセスが終了すると、Joining Nodeはオーバーレイの完全に機能するピアになります。承認プロセス中、参加ノードは、オーバーレイに参加するための十分な権限があることを証明するために、資格情報を提示する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Resource: An object or group of objects stored in a P2P network.",
      "ja": "リソース：P2Pネットワークに格納されているオブジェクトまたはオブジェクトのグループ。"
    },
    {
      "indent": 3,
      "text": "Resource-ID: A value that identifies some resources and which is used as a key for storing and retrieving the resource. Often this is not human friendly/readable. One way to generate a Resource-ID is by applying a mapping function to some other unique name (e.g., user name or service name) for the resource. The Resource-ID is used by the distributed database algorithm to determine the peer or peers that are responsible for storing the data for the overlay. In structured P2P networks, Resource-IDs are generally fixed length and are formed by hashing the Resource Name. In unstructured networks, Resource Names may be used directly as Resource-IDs and may be of variable length.",
      "ja": "Resource-ID：一部のリソースを識別する値で、リソースを格納および取得するためのキーとして使用されます。多くの場合、これは人間にとって使いやすいものではありません。 Resource-IDを生成する1つの方法は、リソースの他の一意の名前（ユーザー名やサービス名など）にマッピング関数を適用することです。 Resource-IDは、オーバーレイのデータの保存を担当するピアを決定するために、分散データベースアルゴリズムによって使用されます。構造化P2Pネットワークでは、リソースIDは通常固定長であり、リソース名をハッシュすることによって形成されます。非構造化ネットワークでは、リソース名を直接リソースIDとして使用でき、長さが可変になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Resource Name: The name by which a resource is identified. In unstructured P2P networks, the Resource Name is sometimes used directly as a Resource-ID. In structured P2P networks, the Resource Name is typically mapped into a Resource-ID by using the string as the input to hash function. Structured and unstructured P2P networks are described in [RFC5694]. A SIP resource, for example, is often identified by its AOR (address-of-record), which is an example of a Resource Name.",
      "ja": "リソース名：リソースを識別するための名前。非構造化P2Pネットワークでは、リソース名がリソースIDとして直接使用されることがあります。構造化P2Pネットワークでは、リソース名は通常、文字列をハッシュ関数への入力として使用することにより、リソースIDにマップされます。構造化および非構造化P2Pネットワークについては、[RFC5694]で説明されています。たとえば、SIPリソースは多くの場合、リソース名の例であるAOR（レコードのアドレス）によって識別されます。"
    },
    {
      "indent": 3,
      "text": "Responsible Peer: The peer that is responsible for a specific resource, as defined by the Topology Plug-in algorithm.",
      "ja": "Responsible Peer：Topology Plug-inアルゴリズムで定義されている、特定のリソースを担当するピア。"
    },
    {
      "indent": 0,
      "text": " Routing Table: The set of directly connected peers which a node can use to forward overlay messages. In normal operation, these peers will all be in the Connection Table, but not vice versa, because some peers may not yet be available for routing. Peers may send messages directly to peers that are in their Connection Tables, but may forward messages to peers that are not in their Connection Table only through peers that are in the Routing Table.",
      "ja": "ルーティングテーブル：ノードがオーバーレイメッセージの転送に使用できる、直接接続されたピアのセット。通常の操作では、これらのピアはすべて接続テーブルに含まれますが、その逆はできません。一部のピアはまだルーティングに使用できない場合があるためです。ピアは、接続テーブルにあるピアにメッセージを直接送信できますが、ルーティングテーブルにあるピアを介してのみ、接続テーブルにないピアにメッセージを転送できます。"
    },
    {
      "indent": 3,
      "text": "Successor Replacement Hold-Down Time: The amount of time to wait before starting replication when a new successor is found; it defaults to 30 seconds.",
      "ja": "サクセサ交換のホールドダウン時間：新しいサクセサが見つかったときに、レプリケーションを開始する前に待機する時間。デフォルトは30秒です。"
    },
    {
      "indent": 3,
      "text": "Transaction ID: A randomly chosen identifier selected by the originator of a request that is used to correlate requests and responses.",
      "ja": "トランザクションID：要求の発信者がランダムに選択した識別子で、要求と応答を関連付けるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Usage: The definition of a set of data structures (data Kinds) that an application wants to store in the overlay. A usage may also define a set of network protocols (Application IDs) that can be tunneled over TLS or DTLS direct connections between nodes. For example, the SIP Usage defines a SIP registration data Kind, which contains information on how to reach a SIP endpoint, and two Application IDs corresponding to the SIP and SIPS protocols.",
      "ja": "使用法：アプリケーションがオーバーレイに保存するデータ構造（データの種類）のセットの定義。使用法では、ノード間のTLSまたはDTLS直接接続でトンネリングできる一連のネットワークプロトコル（アプリケーションID）を定義することもできます。たとえば、SIP Usageは、SIPエンドポイントに到達する方法に関する情報を含むSIP登録データの種類と、SIPおよびSIPSプロトコルに対応する2つのアプリケーションIDを定義します。"
    },
    {
      "indent": 3,
      "text": "User: A physical person identified by the certificates assigned to them.",
      "ja": "ユーザー：割り当てられた証明書によって識別される身体の人。"
    },
    {
      "indent": 3,
      "text": "User Name: A name identifying a user of the overlay, typically used as a Resource Name or as a label on a resource that identifies the user owning the resource.",
      "ja": "ユーザー名：オーバーレイのユーザーを識別する名前。通常は、リソース名として、またはリソースを所有するユーザーを識別するリソース上のラベルとして使用されます。"
    },
    {
      "indent": 0,
      "text": "4. Overlay Management Overview",
      "section_title": true,
      "ja": "4. オーバーレイ管理の概要"
    },
    {
      "indent": 3,
      "text": "The most basic function of RELOAD is as a generic overlay network. Nodes need to be able to join the overlay, form connections to other nodes, and route messages through the overlay to nodes to which they are not directly connected. This section provides an overview of the mechanisms that perform these functions.",
      "ja": "RELOADの最も基本的な機能は、一般的なオーバーレイネットワークです。ノードは、オーバーレイに参加し、他のノードへの接続を形成し、オーバーレイを介して、直接接続されていないノードにメッセージをルーティングできる必要があります。このセクションでは、これらの機能を実行するメカニズムの概要を説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Security and Identification",
      "section_title": true,
      "ja": "4.1. セキュリティと識別"
    },
    {
      "indent": 3,
      "text": "The overlay parameters are specified in a Configuration Document. Because the parameters include security-critical information, such as the certificate signing trust anchors, the Configuration Document needs to be retrieved securely. The initial Configuration Document is either initially fetched over HTTPS or manually provisioned. Subsequent Configuration Document updates are received either as a result of being refreshed periodically by the configuration server, or, more commonly, by being flood-filled through the overlay, which allows for fast propagation once an update is pushed. In the latter case, updates are via digital signatures that trace back to the initial Configuration Document.",
      "ja": "オーバーレイパラメータは、構成ドキュメントで指定されます。パラメータには、証明書署名トラストアンカーなどのセキュリティ上重要な情報が含まれているため、構成ドキュメントを安全に取得する必要があります。最初の構成ドキュメントは、最初にHTTPS経由でフェッチされるか、手動でプロビジョニングされます。後続の構成ドキュメントの更新は、構成サーバーによって定期的に更新された結果として受信されるか、またはより一般的には、オーバーレイを介してフラッドフィルされ、更新がプッシュされると迅速な伝播が可能になります。後者の場合、更新はデジタル署名を介して行われ、最初の構成ドキュメントまでさかのぼります。"
    },
    {
      "indent": 3,
      "text": "Every node in the RELOAD overlay is identified by a Node-ID. The Node-ID is used for three major purposes:",
      "ja": "RELOADオーバーレイのすべてのノードはノードIDで識別されます。ノードIDは、主に3つの目的で使用されます。"
    },
    {
      "indent": 3,
      "text": "o To address the node itself.",
      "ja": "o ノード自体をアドレス指定する。"
    },
    {
      "indent": 3,
      "text": "o To determine the node's position in the overlay topology (if the overlay is structured; overlays do not need to be structured).",
      "ja": "o オーバーレイトポロジ内のノードの位置を決定するため（オーバーレイが構造化されている場合、オーバーレイを構造化する必要はありません）。"
    },
    {
      "indent": 3,
      "text": "o To determine the set of resources for which the node is responsible.",
      "ja": "o ノードが担当するリソースのセットを決定するため。"
    },
    {
      "indent": 3,
      "text": "Each node has a certificate [RFC5280] containing its Node-ID in a subjectAltName extension, which is unique within an overlay instance.",
      "ja": "各ノードには、オーバーレイインスタンス内で一意のsubjectAltName拡張にノードIDを含む証明書[RFC5280]があります。"
    },
    {
      "indent": 3,
      "text": "The certificate serves multiple purposes:",
      "ja": "証明書には複数の目的があります。"
    },
    {
      "indent": 3,
      "text": "o It entitles the user to store data at specific locations in the Overlay Instance. Each data Kind defines the specific rules for determining which certificates can access each Resource-ID/Kind-ID pair. For instance, some Kinds might allow anyone to write at a given location, whereas others might restrict writes to the owner of a single certificate.",
      "ja": "o これにより、ユーザーはオーバーレイインスタンスの特定の場所にデータを保存できます。各データの種類は、どの証明書が各Resource-ID / Kind-IDペアにアクセスできるかを決定するための特定のルールを定義します。たとえば、特定の場所で誰にでも書き込みを許可するKindsもあれば、単一の証明書の所有者への書き込みを制限するKindsもあります。"
    },
    {
      "indent": 3,
      "text": "o It entitles the user to operate a node that has a Node-ID found in the certificate. When the node forms a connection to another peer, it uses this certificate so that a node connecting to it knows it is connected to the correct node. (Technically, a TLS or DTLS association with client authentication is formed.) In addition, the node can sign messages, thus providing integrity and authentication for messages which are sent from the node.",
      "ja": "o 証明書にノードIDが含まれているノードを操作する資格をユーザーに付与します。ノードが別のピアへの接続を形成すると、この証明書を使用して、接続しているノードが正しいノードに接続されていることを認識します。 （技術的には、クライアント認証とのTLSまたはDTLS関連付けが形成されます。）さらに、ノードはメッセージに署名できるため、ノードから送信されるメッセージの整合性と認証を提供できます。"
    },
    {
      "indent": 3,
      "text": "o It entitles the user to use the user name found in the certificate.",
      "ja": "o 証明書にあるユーザー名を使用する資格をユーザーに付与します。"
    },
    {
      "indent": 3,
      "text": "If a user has more than one device, typically they would get one certificate for each device. This allows each device to act as a separate peer.",
      "ja": "ユーザーが複数のデバイスを持っている場合、通常、ユーザーはデバイスごとに1つの証明書を取得します。これにより、各デバイスを個別のピアとして機能させることができます。"
    },
    {
      "indent": 3,
      "text": "RELOAD supports multiple certificate issuance models. The first is based on a central enrollment process, which allocates a unique name and Node-ID and puts them in a certificate for the user. All peers in a particular Overlay Instance have the enrollment server as a trust anchor and so can verify any other peer's certificate.",
      "ja": "RELOADは、複数の証明書発行モデルをサポートしています。 1つ目は、一意の名前とノードIDを割り当て、それらをユーザーの証明書に入れる中央登録プロセスに基づいています。特定のオーバーレイインスタンス内のすべてのピアは、登録サーバーをトラストアンカーとして持っているため、他のピアの証明書を検証できます。"
    },
    {
      "indent": 0,
      "text": " The second model is useful in settings, when a group of users want to set up an overlay network but are not concerned about attack by other users in the network. For instance, users on a LAN might want to set up a short-term ad hoc network without going to the trouble of setting up an enrollment server. RELOAD supports the use of self-generated, self-signed certificates. When self-signed certificates are used, the node also generates its own Node-ID and user name. The Node-ID is computed as a digest of the public key, to prevent Node-ID theft. Note that the relevant cryptographic property for the digest is partial preimage resistance. Collision resistance is not needed, because an attacker who can create two nodes with the same Node-ID but a different public key obtains no advantage. This model is still subject to a number of known attacks (most notably, Sybil attacks [Sybil]) and can be safely used only in closed networks where users are mutually trusting. Another drawback of this approach is that the user's data is then tied to their key, so if a key is changed, any data stored under their Node-ID needs to be re-stored. This is not an issue for centrally issued Node-IDs provided that the Certification Authority (CA) reissues the same Node-ID when a new certificate is generated.",
      "ja": "2番目のモデルは、ユーザーグループがオーバーレイネットワークをセットアップしたいが、ネットワーク内の他のユーザーによる攻撃を心配しない場合に便利です。たとえば、LAN上のユーザーは、登録サーバーをセットアップする手間をかけずに、短期的なアドホックネットワークをセットアップしたい場合があります。 RELOADは、自己生成された自己署名証明書の使用をサポートしています。自己署名証明書が使用される場合、ノードは独自のノードIDとユーザー名も生成します。ノードIDは、ノードIDの盗難を防ぐために、公開鍵のダイジェストとして計算されます。ダイジェストに関連する暗号プロパティは、部分的なプリイメージ耐性です。同じノードIDを持つが公開鍵が異なる2つのノードを作成できる攻撃者には利点がないため、衝突抵抗は必要ありません。このモデルは依然として多くの既知の攻撃（特にSybil攻撃[Sybil]）の影響を受けており、ユーザーが相互に信頼している閉じたネットワークでのみ安全に使用できます。このアプローチのもう1つの欠点は、ユーザーのデータがキーに関連付けられるため、キーが変更された場合、ノードIDに保存されているデータを再保存する必要があることです。新しい証明書が生成されたときに証明機関（CA）が同じノードIDを再発行する場合、これは中央で発行されたノードIDの問題ではありません。"
    },
    {
      "indent": 3,
      "text": "The general principle here is that the security mechanisms (TLS or DTLS at the data link layer and message signatures at the message transport layer) are always used, even if the certificates are self-signed. This allows for a single set of code paths in the systems, with the only difference being whether certificate verification is used to chain to a single root of trust.",
      "ja": "ここでの一般的な原則は、証明書が自己署名されている場合でも、セキュリティメカニズム（データリンク層でのTLSまたはDTLSおよびメッセージトランスポート層でのメッセージ署名）が常に使用されることです。これにより、システム内のコードパスの単一セットが可能になります。唯一の違いは、証明書の検証を使用して単一の信頼のルートにチェーンするかどうかです。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Shared-Key Security",
      "section_title": true,
      "ja": "4.1.1. 共有キーセキュリティ"
    },
    {
      "indent": 3,
      "text": "RELOAD also provides an admission control system based on shared keys. In this model, the peers all share a single key which is used to authenticate the peer-to-peer connections via TLS-PSK [RFC4279] or TLS-SRP [RFC5054].",
      "ja": "RELOADは、共有キーに基づくアドミッションコントロールシステムも提供します。このモデルでは、ピアはすべて、TLS-PSK [RFC4279]またはTLS-SRP [RFC5054]を介したピアツーピア接続の認証に使用される単一の鍵を共有します。"
    },
    {
      "indent": 0,
      "text": "4.2. Clients",
      "section_title": true,
      "ja": "4.2. クライアント"
    },
    {
      "indent": 3,
      "text": "RELOAD defines a single protocol that is used both as the peer protocol and as the client protocol for the overlay. Having a single protocol simplifies implementation, particularly for devices that may act in either role, and allows clients to inject messages directly into the overlay.",
      "ja": "RELOADは、オーバーレイのピアプロトコルとクライアントプロトコルの両方として使用される単一のプロトコルを定義します。単一のプロトコルを使用すると、特にどちらかの役割で動作するデバイスの実装が簡単になり、クライアントがメッセージをオーバーレイに直接挿入できるようになります。"
    },
    {
      "indent": 3,
      "text": "We use the term \"peer\" to identify a node in the overlay that routes messages for nodes other than those to which it is directly connected. Peers also have storage responsibilities. We use the term \"client\" to refer to nodes that do not have routing or storage responsibilities. When text applies to both peers and clients, we will simply refer to such devices as \"nodes\".",
      "ja": "「ピア」という用語は、直接接続されているノード以外のノードにメッセージをルーティングするオーバーレイ内のノードを識別するために使用します。ピアにはストレージの責任もあります。 「クライアント」という用語は、ルーティングまたはストレージの責任を持たないノードを指すために使用します。テキストがピアとクライアントの両方に適用される場合、そのようなデバイスを単に「ノード」と呼びます。"
    },
    {
      "indent": 3,
      "text": "RELOAD's client support allows nodes that are not participating in the overlay as peers to utilize the same implementation and to benefit from the same security mechanisms as the peers. Clients possess and use certificates that authorize the user to store data at certain locations in the overlay. The Node-ID in the certificate is used to identify the particular client as a member of the overlay and to authenticate its messages.",
      "ja": "RELOADのクライアントサポートにより、オーバーレイとしてピアに参加していないノードがピアとして同じ実装を利用し、ピアと同じセキュリティメカニズムの恩恵を受けることができます。クライアントは、ユーザーがオーバーレイの特定の場所にデータを保存することを許可する証明書を所有し、使用します。証明書のノードIDは、特定のクライアントをオーバーレイのメンバーとして識別し、そのメッセージを認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In RELOAD, unlike some other designs, clients are not first-class entities. From the perspective of a peer, a client is a node that has connected to the overlay, but that has not yet taken steps to insert itself into the overlay topology. It might never do so (if it's a client), or it might eventually do so (if it's just a node that is taking a long time to join). The routing and storage rules for RELOAD provide for correct behavior by peers regardless of whether other nodes attached to them are clients or peers. Of course, a client implementation needs to know that it intends to be a client, but this localizes complexity only to that node.",
      "ja": "RELOADでは、他の一部のデザインとは異なり、クライアントはファーストクラスのエンティティではありません。ピアの観点から見ると、クライアントはオーバーレイに接続されているノードですが、オーバーレイトポロジに自分自身を挿入するための手順はまだ行っていません。 （クライアントの場合は）それが行われない場合や、最終的には（参加するのに時間がかかるノードの場合のみ）行われる場合があります。 RELOADのルーティングおよびストレージルールは、接続されている他のノードがクライアントであるかピアであるかに関係なく、ピアによる正しい動作を提供します。もちろん、クライアントの実装は、それがクライアントになるつもりであることを知る必要がありますが、これは複雑さをそのノードだけに限定します。"
    },
    {
      "indent": 3,
      "text": "For more discussion about the motivation for RELOAD's client support, see Appendix B.",
      "ja": "RELOADのクライアントサポートの動機についての詳細は、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Client Routing",
      "section_title": true,
      "ja": "4.2.1. クライアントのルーティング"
    },
    {
      "indent": 3,
      "text": "Clients may insert themselves in the overlay in two ways:",
      "ja": "クライアントは、次の2つの方法でオーバーレイに自分自身を挿入できます。"
    },
    {
      "indent": 3,
      "text": "o Establish a connection to the peer responsible for the client's Node-ID in the overlay. Then, requests may be sent from/to the client using its Node-ID in the same manner as if it were a peer, because the responsible peer in the overlay will handle the final step of routing to the client. This may require a TURN [RFC5766] relay in cases where NATs or firewalls prevent a client from forming a direct connection with its responsible peer. Note that clients that choose this option need to process Update messages from the peer (Section 6.4.2.3). These updates can indicate that the peer is no longer responsible for the client's Node-ID. The client would then need to form a connection to the appropriate peer. Failure to do so will result in the client no longer receiving messages.",
      "ja": "o オーバーレイでクライアントのノードIDを担当するピアへの接続を確立します。次に、オーバーレイ内の責任のあるピアがクライアントへのルーティングの最終ステップを処理するため、ピアと同じようにノードIDを使用して、クライアントとの間で要求を送信できます。これは、NATまたはファイアウォールがクライアントがその責任のあるピアとの直接接続を形成できないようにする場合に、TURN [RFC5766]リレーを必要とする場合があります。このオプションを選択するクライアントは、ピアからの更新メッセージを処理する必要があることに注意してください（セクション6.4.2.3）。これらの更新は、ピアがクライアントのノードIDに対してもはや責任がないことを示している可能性があります。次に、クライアントは適切なピアへの接続を形成する必要があります。そうしないと、クライアントはメッセージを受信できなくなります。"
    },
    {
      "indent": 0,
      "text": " o Establish a connection with an arbitrary peer in the overlay (perhaps based on network proximity or an inability to establish a direct connection with the responsible peer). In this case, the client will rely on RELOAD's Destination List feature (Section 6.3.2.2) to ensure reachability. The client can initiate requests, and any node in the overlay that knows the Destination List to its current location can reach it, but the client is not directly reachable using only its Node-ID. If the client is to receive incoming requests from other members of the overlay, the Destination List needed to reach the client needs to be learnable via other mechanisms, such as being stored in the overlay by a usage. A client connected this way using a certificate with only a single Node-ID can proceed to use the connection without performing an Attach (Section 6.5.1). A client wishing to connect using this mechanism with a certificate with multiple Node-IDs can use a Ping (Section 6.5.3) to probe the Node-ID of the node to which it is connected before performing the Attach.",
      "ja": "oオーバーレイ内の任意のピアとの接続を確立します（おそらく、ネットワークの近接性または責任のあるピアとの直接接続を確立できないことに基づいています）。この場合、クライアントはRELOADの宛先リスト機能（セクション6.3.2.2）を利用して到達可能性を確保します。クライアントはリクエストを開始でき、現在の場所への宛先リストを知っているオーバーレイのノードはそれに到達できますが、クライアントはノードIDだけを使用して直接到達できません。クライアントがオーバーレイの他のメンバーから着信要求を受信する場合、クライアントに到達するために必要な宛先リストは、使用法によってオーバーレイに格納されるなど、他のメカニズムを介して学習可能である必要があります。ノードIDが1つだけの証明書を使用してこの方法で接続したクライアントは、接続を実行せずに接続の使用を続行できます（6.5.1項）。このメカニズムを使用して複数のノードIDを持つ証明書を使用して接続するクライアントは、Ping（6.5.3節）を使用して、接続を実行する前に、接続先のノードのノードIDをプローブできます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Minimum Functionality Requirements for Clients",
      "section_title": true,
      "ja": "4.2.2. クライアントの最小機能要件"
    },
    {
      "indent": 3,
      "text": "A node may act as a client simply because it does not have the capacity or need to act as a peer in the overlay, or because it does not even have an implementation of the Topology Plug-in defined in Section 6.4.1, needed to act as a peer in the overlay. In order to exchange RELOAD messages with a peer, a client needs to meet a minimum level of functionality. Such a client will:",
      "ja": "ノードは、容量がないか、オーバーレイでピアとして機能する必要がないため、またはセクション6.4.1で定義されているトポロジプラグインの実装さえもないため、クライアントとして機能する可能性があります。オーバーレイのピアとして機能します。ピアとRELOADメッセージを交換するには、クライアントは最小レベルの機能を満たす必要があります。そのようなクライアントは："
    },
    {
      "indent": 3,
      "text": "o Implement RELOAD's connection-management operations that are used to establish the connection with the peer.",
      "ja": "o ピアとの接続を確立するために使用されるRELOADの接続管理操作を実装します。"
    },
    {
      "indent": 3,
      "text": "o Implement RELOAD's data retrieval methods (with client functionality).",
      "ja": "o RELOADのデータ取得メソッドを実装します（クライアント機能を使用）。"
    },
    {
      "indent": 3,
      "text": "o Be able to calculate Resource-IDs used by the overlay.",
      "ja": "o オーバーレイで使用されるリソースIDを計算できるようにします。"
    },
    {
      "indent": 3,
      "text": "o Possess security credentials needed by the overlay that it is implementing.",
      "ja": "o 実装しているオーバーレイに必要なセキュリティ認証情報を持っている。"
    },
    {
      "indent": 3,
      "text": "A client speaks the same protocol as the peers, knows how to calculate Resource-IDs, and signs its requests in the same manner as peers. While a client does not necessarily require a full implementation of the overlay algorithm, calculating the Resource-ID requires an implementation of an appropriate algorithm for the overlay.",
      "ja": "クライアントはピアと同じプロトコルを話し、リソースIDの計算方法を知っており、ピアと同じ方法でリクエストに署名します。クライアントがオーバーレイアルゴリズムの完全な実装を必ずしも必要とするわけではありませんが、Resource-IDの計算には、オーバーレイに適切なアルゴリズムの実装が必要です。"
    },
    {
      "indent": 0,
      "text": "4.3. Routing",
      "section_title": true,
      "ja": "4.3. ルーティング"
    },
    {
      "indent": 3,
      "text": "This section discusses the capabilities of RELOAD's routing layer and the protocol features used to implement the capabilities, and provides a brief overview of how they are used. Appendix A discusses some alternative designs and the trade-offs that would be necessary to support them.",
      "ja": "このセクションでは、RELOADのルーティング層の機能と、機能の実装に使用されるプロトコル機能について説明し、それらの使用方法の概要を示します。付録Aでは、いくつかの代替設計とそれらをサポートするために必要なトレードオフについて説明します。"
    },
    {
      "indent": 3,
      "text": "RELOAD's routing provides the following capabilities:",
      "ja": "RELOADのルーティングは、次の機能を提供します。"
    },
    {
      "indent": 3,
      "text": "Resource-based Routing: RELOAD supports routing messages based solely on the name of the resource. Such messages are delivered to a node that is responsible for that resource. Both structured and unstructured overlays are supported, so the route may not be deterministic for all Topology Plug-ins.",
      "ja": "リソースベースのルーティング：RELOADは、リソースの名前のみに基づいたメッセージのルーティングをサポートします。このようなメッセージは、そのリソースを担当するノードに配信されます。構造化オーバーレイと非構造化オーバーレイの両方がサポートされているため、すべてのトポロジプラグインでルートが確定的ではない場合があります。"
    },
    {
      "indent": 3,
      "text": "Node-based Routing: RELOAD supports routing messages to a specific node in the overlay.",
      "ja": "ノードベースのルーティング：RELOADは、オーバーレイ内の特定のノードへのメッセージのルーティングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "Clients: RELOAD supports requests from and to clients that do not participate in overlay routing. The clients are located via either of the mechanisms described above.",
      "ja": "クライアント：RELOADは、オーバーレイルーティングに参加していないクライアントとの間の要求をサポートします。クライアントは、上記のメカニズムのいずれかを介して配置されます。"
    },
    {
      "indent": 3,
      "text": "NAT Traversal: RELOAD supports establishing and using connections between nodes separated by one or more NATs, including locating peers behind NATs for those overlays allowing/requiring it.",
      "ja": "NATトラバーサル：RELOADは、1つ以上のNATで分離されたノード間の接続の確立と使用をサポートします。これには、NATの背後にあるピアを見つけてオーバーレイを許可/要求することも含まれます。"
    },
    {
      "indent": 3,
      "text": "Low State: RELOAD's routing algorithms do not require significant state (i.e., state linear or greater in the number of outstanding messages that have passed through it) to be stored on intermediate peers.",
      "ja": "低状態：RELOADのルーティングアルゴリズムでは、中間ピアに格納するために重要な状態（つまり、通過した未処理のメッセージ数が線形以上）を必要としません。"
    },
    {
      "indent": 3,
      "text": "Routability in Unstable Topologies: Overlay topology changes constantly in an overlay of moderate size due to the failure of individual nodes and links in the system. RELOAD's routing allows peers to reroute messages when a failure is detected, and replies can be returned to the requesting node as long as the peers that originally forwarded the successful request do not fail before the response is returned.",
      "ja": "不安定なトポロジーでのルーティング可能性：オーバーレイトポロジーは、システム内の個々のノードとリンクの障害により、中程度のサイズのオーバーレイで絶えず変化します。 RELOADのルーティングにより、障害が検出されたときにピアがメッセージを再ルーティングできます。成功した要求を最初に転送したピアが応答を返す前に失敗しない限り、応答は要求ノードに返されます。"
    },
    {
      "indent": 3,
      "text": "RELOAD's routing utilizes three basic mechanisms:",
      "ja": "RELOADのルーティングは、3つの基本的なメカニズムを利用します。"
    },
    {
      "indent": 3,
      "text": "Destination Lists: While, in principle, it is possible to just inject a message into the overlay with a single Node-ID as the destination, RELOAD provides a source-routing capability in the form of \"Destination Lists\". A Destination List provides a list of the nodes through which a message flows in order (i.e., it is loose source routed). The minimal Destination List contains just a single value.",
      "ja": "宛先リスト：原則として、単一のノードIDを宛先としてメッセージをオーバーレイに挿入することは可能ですが、RELOADは「宛先リスト」の形式でソースルーティング機能を提供します。宛先リストは、メッセージが順番に流れるノードのリストを提供します（つまり、ルーズソースルーティングです）。最小限の宛先リストには、単一の値のみが含まれています。"
    },
    {
      "indent": 3,
      "text": "Via Lists: In order to allow responses to follow the same path as requests, each message also contains a \"Via List\", which is appended to by each node a message traverses. This Via List can then be inverted and used as a Destination List for the response.",
      "ja": "リスト経由：応答が要求と同じパスをたどることを可能にするために、各メッセージには、メッセージが通過する各ノードによって追加される「Viaリスト」も含まれます。次に、このViaリストを反転して、応答の宛先リストとして使用できます。"
    },
    {
      "indent": 3,
      "text": "RouteQuery: The RouteQuery method allows a node to query a peer for the next hop it will use to route a message. This method is useful for diagnostics and for iterative routing (see Section 6.4.2.4).",
      "ja": "RouteQuery：RouteQueryメソッドを使用すると、ノードはメッセージのルーティングに使用する次のホップについてピアにクエリを実行できます。この方法は、診断および反復ルーティングに役立ちます（6.4.2.4項を参照）。"
    },
    {
      "indent": 3,
      "text": "The basic routing mechanism that RELOAD uses is symmetric recursive. We will first describe symmetric recursive routing and then discuss its advantages in terms of the requirements discussed above.",
      "ja": "RELOADが使用する基本的なルーティングメカニズムは、対称的な再帰的です。最初に対称再帰ルーティングについて説明し、次に上記で説明した要件の観点からその利点について説明します。"
    },
    {
      "indent": 3,
      "text": "Symmetric recursive routing requires that a request message follow a path through the overlay to the destination: each peer forwards the message closer to its destination. The return path of the response goes through the same nodes as the request (though it may also go through some new intermediate nodes due to topology changes). Note that a failure on the reverse path caused by a topology change after the request was sent will be handled by the end-to-end retransmission of the response as described in Section 6.2.1. For example, the following figure shows a message following a route from A to Z through B and X:",
      "ja": "対称再帰ルーティングでは、要求メッセージがオーバーレイを経由して宛先までのパスをたどる必要があります。各ピアは、メッセージを宛先の近くに転送します。応答の戻りパスは、要求と同じノードを通過します（トポロジの変更により、いくつかの新しい中間ノードを通過する場合もあります）。リクエストが送信された後のトポロジ変更によって引き起こされたリバースパスの障害は、セクション6.2.1で説明されているように、応答のエンドツーエンドの再送信によって処理されることに注意してください。たとえば、次の図は、AからZ、BおよびXを経由するルートへのメッセージを示しています。"
    },
    {
      "indent": 3,
      "text": "A         B         X         Z\n-------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---------->\nDest=Z\n         ---------->\n         Via=A\n         Dest=Z\n                   ---------->\n                   Via=A,B\n                   Dest=Z",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                   <----------\n                    Dest=X,B,A\n         <----------\n            Dest=B,A\n<----------\n     Dest=A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this figure does not indicate whether A is a client or peer. A forwards its request to B, and the response is returned to A in the same manner regardless of A's role in the overlay.",
      "ja": "この図は、Aがクライアントであるかピアであるかを示していないことに注意してください。 Aはその要求をBに転送し、オーバーレイでのAの役割に関係なく、同じ方法で応答がAに返されます。"
    },
    {
      "indent": 0,
      "text": " This figure shows use of full Via Lists by intermediate peers B and X. However, if B and/or X are willing to store state, then they may elect to truncate the lists and save the truncated information internally using the transaction ID as a key to allow it to be retrieved later. Later, when the response message arrives, the transaction ID would be used to recover the truncated information and return the response message along the path from which the request arrived. This option requires a greater amount of state to be stored on intermediate peers, but saves a small amount of bandwidth and reduces the need for modifying the message en route. Selection of this mode of operation is a choice for the individual peer; the techniques are interoperable even on a single message. The figure below shows B using full Via Lists, but X truncating them to X1 and saving the state internally.",
      "ja": "この図は、中間ピアBおよびXによる完全なViaリストの使用を示しています。ただし、Bおよび/またはXが状態を保存する用意がある場合、リストを切り捨て、切り捨てられた情報をトランザクションIDをキーとして内部的に保存することを選択できます。後で取得できるようにします。その後、応答メッセージが到着すると、トランザクションIDを使用して、切り捨てられた情報を回復し、要求が到着したパスに沿って応答メッセージを返します。このオプションでは、中間ピアに保存する状態の量を増やす必要がありますが、少量の帯域幅を節約し、途中でメッセージを変更する必要性を減らします。この動作モードの選択は、個々のピアの選択です。この手法は、単一のメッセージでも相互運用できます。下の図は、完全なViaリストを使用しているBを示していますが、XはそれらをX1に切り捨て、状態を内部的に保存しています。"
    },
    {
      "indent": 3,
      "text": "A         B         X         Z\n-------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---------->\nDest=Z\n         ---------->\n         Via=A\n         Dest=Z\n                   ---------->\n                   Via=X1\n                   Dest=Z",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                   <----------\n                     Dest=X,X1\n           <----------\n              Dest=B,A\n<----------\n     Dest=A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As before, when B receives the message, B creates a Via List consisting of [A]. However, instead of sending [A, B], X creates an opaque ID X1 which maps internally to [A, B] (perhaps by being an encryption of [A, B]) and then forwards to Z with only X1 as the Via List. When the response arrives at X, it maps X1 back to [A, B], then inverts it to produce the new Destination List [B, A], and finally routes it to B.",
      "ja": "以前と同様に、Bがメッセージを受信すると、Bは[A]からなるViaリストを作成します。ただし、Xは[A、B]を送信する代わりに、内部的に[A、B]にマップする（おそらく[A、B]の暗号化によって）不透明なID X1を作成し、V1としてX1のみを使用してZに転送します。リスト。応答がXに到着すると、X1を[A、B]にマッピングし、それを反転して新しい宛先リスト[B、A]を作成し、最後にそれをBにルーティングします。"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports a basic iterative \"routing\" mode, in which the intermediate peers merely return a response indicating the next hop, but do not actually forward the message to that next hop themselves. Iterative routing is implemented using the RouteQuery method (see Section 6.4.2.4), which requests this behavior. Note that iterative routing is selected only by the initiating node.",
      "ja": "RELOADは、基本的な反復「ルーティング」モードもサポートします。このモードでは、中間ピアはネクストホップを示す応答を返すだけで、実際にはそのネクストホップ自体にメッセージを転送しません。反復ルーティングは、この動作を要求するRouteQueryメソッド（セクション6.4.2.4を参照）を使用して実装されます。反復ルーティングは開始ノードによってのみ選択されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4. Connectivity Management",
      "section_title": true,
      "ja": "4.4. 接続管理"
    },
    {
      "indent": 3,
      "text": "In order to provide efficient routing, a peer needs to maintain a set of direct connections to other peers in the Overlay Instance. Due to the presence of NATs, these connections often cannot be formed directly. Instead, we use the Attach request to establish a connection. Attach uses Interactive Connectivity Establishment (ICE) [RFC5245] to establish the connection. It is assumed that the reader is familiar with ICE.",
      "ja": "効率的なルーティングを提供するために、ピアはオーバーレイインスタンス内の他のピアへの一連の直接接続を維持する必要があります。 NATが存在するため、これらの接続を直接形成できないことがよくあります。代わりに、接続リクエストを使用して接続を確立します。接続は、インタラクティブ接続確立（ICE）[RFC5245]を使用して接続を確立します。読者はICEに精通していることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Say that peer A wishes to form a direct connection to peer B, either to join the overlay or to add more connections in its Routing Table. It gathers ICE candidates and packages them up in an Attach request, which it sends to B through usual overlay routing procedures. B does its own candidate gathering and sends back a response with its candidates. A and B then do ICE connectivity checks on the candidate pairs. The result is a connection between A and B. At this point, A and B MAY send messages directly between themselves without going through other overlay peers. In other words, A and B are in each other's Connection Tables. They MAY then execute an Update process, resulting in additions to each other's Routing Tables, and may then become able to route messages through each other to other overlay nodes.",
      "ja": "ピアAが、オーバーレイに参加するか、ルーティングテーブルに接続を追加するために、ピアBへの直接接続を形成したいとします。 ICE候補を収集し、それらをAttach要求にパッケージ化して、通常のオーバーレイルーティング手順を介してBに送信します。 Bは独自の候補者収集を行い、候補者に応答を返します。次に、AとBが候補ペアのICE接続チェックを実行します。結果は、AとBの間の接続です。この時点で、AとBは、他のオーバーレイピアを経由せずに、それらの間で直接メッセージを送信できます（MAY）。つまり、AとBは互いの接続テーブルにあります。次に、更新プロセスを実行して、互いのルーティングテーブルに追加し、メッセージを相互に他のオーバーレイノードにルーティングできるようにする場合があります。"
    },
    {
      "indent": 3,
      "text": "There are two cases where Attach is not used. The first is when a peer is joining the overlay and is not connected to any peers. In order to support this case, a small number of bootstrap nodes typically need to be publicly accessible so that new peers can directly connect to them. Section 11 contains more detail on this. The second case is when a client connects to a peer at an arbitrary IP address, rather than to its responsible peer, as described in the second bullet point of Section 4.2.1.",
      "ja": "アタッチが使用されない2つのケースがあります。 1つ目は、ピアがオーバーレイに参加していて、どのピアにも接続されていない場合です。このケースをサポートするために、新しいピアが直接接続できるように、少数のブートストラップノードは一般にパブリックにアクセス可能である必要があります。セクション11では、これについて詳しく説明します。 2番目のケースは、セクション4.2.1の2番目の箇条書きで説明されているように、クライアントが責任のあるピアではなく、任意のIPアドレスのピアに接続する場合です。"
    },
    {
      "indent": 3,
      "text": "In general, a peer needs to maintain connections to all of the peers near it in the Overlay Instance and to enough other peers to have efficient routing (the details on what \"enough\" and \"near\" mean depend on the specific overlay). If a peer cannot form a connection to some other peer, this is not necessarily a disaster; overlays can route correctly even without fully connected links. However, a peer needs to try to maintain the specified Routing Table defined by the Topology Plug-in algorithm and needs to form new connections if it detects that it has fewer direct connections than specified by the algorithm. This also implies that peers, in accordance with the Topology Plug-in algorithm, need to periodically verify that the connected peers are still alive and, if not, need to try to re-form the connections or form alternate ones. See Section 10.7.4.3 for an example on how a specific overlay algorithm implements these constraints.",
      "ja": "一般に、ピアは、オーバーレイインスタンス内のピアの近くのすべてのピアへの接続と、効率的なルーティングを行うのに十分な他のピアへの接続を維持する必要があります（「十分」と「近く」の意味の詳細は、特定のオーバーレイによって異なります）。ピアが他のピアへの接続を形成できない場合、これは必ずしも災害ではありません。オーバーレイは、完全に接続されたリンクがなくても正しくルーティングできます。ただし、ピアは、トポロジプラグインアルゴリズムによって定義された指定されたルーティングテーブルを維持しようとする必要があり、アルゴリズムによって指定された数よりも直接接続が少ないことを検出した場合、新しい接続を形成する必要があります。これは、トポロジプラグインアルゴリズムに従って、ピアが接続されたピアがまだ生きていることを定期的に確認する必要があり、生きていない場合は、接続の再形成または代替の形成を試みる必要があることも意味します。特定のオーバーレイアルゴリズムがこれらの制約を実装する方法の例については、セクション10.7.4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5. Overlay Algorithm Support",
      "section_title": true,
      "ja": "4.5. オーバーレイアルゴリズムのサポート"
    },
    {
      "indent": 3,
      "text": "The Topology Plug-in allows RELOAD to support a variety of overlay algorithms. This specification defines a DHT based on Chord, which is mandatory to implement, but the base RELOAD protocol is designed to support a variety of overlay algorithms. The information needed to implement this DHT is fully contained in this specification, but it is easier to understand if you are familiar with Chord-based [Chord] DHTs. A nice tutorial can be found at [wikiChord].",
      "ja": "トポロジプラグインにより、RELOADはさまざまなオーバーレイアルゴリズムをサポートできます。この仕様は、実装に必須のコードに基づくDHTを定義していますが、基本のRELOADプロトコルは、さまざまなオーバーレイアルゴリズムをサポートするように設計されています。このDHTを実装するために必要な情報はこの仕様に完全に含まれていますが、Chordベースの[Chord] DHTに精通していると理解しやすくなります。素敵なチュートリアルが[wikiChord]にあります。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Support for Pluggable Overlay Algorithms",
      "section_title": true,
      "ja": "4.5.1. プラガブルオーバーレイアルゴリズムのサポート"
    },
    {
      "indent": 3,
      "text": "RELOAD defines three methods for overlay maintenance: Join, Update, and Leave. However, the contents of these messages, when they are sent, and their precise semantics are specified by the actual overlay algorithm, which is specified by configuration for all nodes in the overlay and thus is known to nodes before they attempt to join the overlay. RELOAD merely provides a framework of commonly needed methods that provide uniformity of notation (and ease of debugging) for a variety of overlay algorithms.",
      "ja": "RELOADは、オーバーレイメンテナンスの3つの方法、Join、Update、Leaveを定義しています。ただし、これらのメッセージの内容と送信時の正確なセマンティクスは、実際のオーバーレイアルゴリズムによって指定されます。実際のオーバーレイアルゴリズムは、オーバーレイのすべてのノードの構成によって指定されるため、オーバーレイに参加する前にノードに認識されます。 RELOADは、さまざまなオーバーレイアルゴリズムに表記の均一性（およびデバッグの容易さ）を提供する、一般的に必要なメソッドのフレームワークを提供するだけです。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Joining, Leaving, and Maintenance Overview",
      "section_title": true,
      "ja": "4.5.2. 加入、脱退、保守の概要"
    },
    {
      "indent": 3,
      "text": "When a new peer wishes to join the Overlay Instance, it will need a Node-ID that it is allowed to use and a set of credentials which match that Node-ID. When an enrollment server is used, the Node-ID used is the one found in the certificate received from the enrollment server. The details of the joining procedure are defined by the overlay algorithm, but the general steps for joining an Overlay Instance are:",
      "ja": "新しいピアがオーバーレイインスタンスに参加する場合は、使用が許可されているノードIDと、そのノードIDと一致する資格情報のセットが必要です。登録サーバーが使用される場合、使用されるノードIDは、登録サーバーから受信した証明書で見つかったものです。結合手順の詳細はオーバーレイアルゴリズムによって定義されますが、オーバーレイインスタンスを結合するための一般的な手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Form connections to some other peers.",
      "ja": "o 他のいくつかのピアへの接続を形成します。"
    },
    {
      "indent": 3,
      "text": "o Acquire the data values this peer is responsible for storing.",
      "ja": "o このピアが格納を担当するデータ値を取得します。"
    },
    {
      "indent": 3,
      "text": "o Inform the other peers which were previously responsible for that data that this peer has taken over responsibility.",
      "ja": "o そのデータが以前に担当していた他のピアに、このピアが担当したことを通知します。"
    },
    {
      "indent": 0,
      "text": " The first thing the peer needs to do is to form a connection to some bootstrap node. Because this is the first connection the peer makes, these nodes will need public IP addresses so that they can be connected to directly. Once a peer has connected to one or more bootstrap nodes, it can form connections in the usual way, by routing Attach messages through the overlay to other nodes. After a peer has connected to the overlay for the first time, it can cache the set of past adjacencies which have public IP addresses and can attempt to use them as future bootstrap nodes. Note that this requires some notion of which addresses are likely to be public as discussed in Section 9.",
      "ja": "ピアが最初に行う必要があるのは、いくつかのブートストラップノードへの接続を形成することです。これはピアが行う最初の接続であるため、これらのノードは、直接接続できるようにパブリックIPアドレスを必要とします。ピアが1つ以上のブートストラップノードに接続すると、オーバーレイを介して他のノードに接続メッセージをルーティングすることにより、通常の方法で接続を形成できます。ピアが初めてオーバーレイに接続した後、パブリックIPアドレスを持つ過去の隣接のセットをキャッシュし、それらを将来のブートストラップノードとして使用することができます。これには、セクション9で説明されているように、どのアドレスが公開される可能性が高いかについての何らかの概念が必要です。"
    },
    {
      "indent": 3,
      "text": "After a peer has connected to a bootstrap node, it then needs to take up its appropriate place in the overlay. This requires two major operations:",
      "ja": "ピアがブートストラップノードに接続した後、ピアはオーバーレイの適切な場所を占める必要があります。これには2つの主要な操作が必要です。"
    },
    {
      "indent": 3,
      "text": "o Form connections to other peers in the overlay to populate its Routing Table.",
      "ja": "o オーバーレイ内の他のピアへの接続を形成して、ルーティングテーブルに入力します。"
    },
    {
      "indent": 3,
      "text": "o Get a copy of the data it is now responsible for storing, and assume responsibility for that data.",
      "ja": "o 保存する責任があるデータのコピーを取得し、そのデータの責任を引き受けます。"
    },
    {
      "indent": 3,
      "text": "The second operation is performed by contacting the Admitting Peer (AP), the node which is currently responsible for the relevant section of the overlay.",
      "ja": "2番目の操作は、オーバーレイの関連セクションを現在担当しているノードであるAdmitting Peer（AP）に接続することによって実行されます。"
    },
    {
      "indent": 3,
      "text": "The details of this operation depend mostly on the overlay algorithm involved, but a typical case would be:",
      "ja": "この操作の詳細は、主に含まれるオーバーレイアルゴリズムによって異なりますが、一般的なケースは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. JN sends a Join request to AP announcing its intention to join.",
      "ja": "1. JNは参加要求をAPに送信し、参加する意思を通知します。"
    },
    {
      "indent": 3,
      "text": "2. AP sends a Join response.",
      "ja": "2. APが参加応答を送信します。"
    },
    {
      "indent": 3,
      "text": "3. AP does a sequence of Stores to JN to give it the data it will need.",
      "ja": "3. APは一連のStoresをJNに送信して、必要なデータを提供します。"
    },
    {
      "indent": 3,
      "text": "4. AP does Updates to JN and to other peers to tell them about its own Routing Table. At this point, both JN and AP consider JN responsible for some section of the Overlay Instance.",
      "ja": "4. APは、JNおよび他のピアを更新して、独自のルーティングテーブルについて通知します。この時点で、JNとAPの両方が、オーバーレイインスタンスの一部のセクションをJNが担当すると見なします。"
    },
    {
      "indent": 3,
      "text": "5. JN makes its own connections to the appropriate peers in the Overlay Instance.",
      "ja": "5. JNは、オーバーレイインスタンスの適切なピアに独自の接続を確立します。"
    },
    {
      "indent": 3,
      "text": "After this process completes, JN is a full member of the Overlay Instance and can process Store/Fetch requests.",
      "ja": "このプロセスが完了すると、JNはオーバーレイインスタンスの完全なメンバーになり、ストア/フェッチリクエストを処理できるようになります。"
    },
    {
      "indent": 3,
      "text": "Note that the first node is a special case. When ordinary nodes cannot form connections to the bootstrap nodes, then they are not part of the overlay. However, the first node in the overlay can obviously not connect to other nodes. In order to support this case, potential first nodes (which can also initially serve as bootstrap nodes) need to somehow be instructed that they are the entire overlay, rather than part of an existing overlay (e.g., by comparing their IP address to the bootstrap IP addresses in the configuration file).",
      "ja": "最初のノードは特殊なケースであることに注意してください。通常のノードがブートストラップノードへの接続を形成できない場合、それらはオーバーレイの一部ではありません。ただし、オーバーレイの最初のノードは明らかに他のノードに接続できません。このケースをサポートするために、潜在的な最初のノード（最初はブートストラップノードとしても機能します）は、既存のオーバーレイの一部ではなく、オーバーレイ全体であることを何らかの方法で（たとえば、IPアドレスをブートストラップと比較することによって）指示する必要があります構成ファイルのIPアドレス）。"
    },
    {
      "indent": 3,
      "text": "Note that clients do not perform either of these operations.",
      "ja": "クライアントはこれらの操作を実行しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.6. First-Time Setup",
      "section_title": true,
      "ja": "4.6. 初回セットアップ"
    },
    {
      "indent": 3,
      "text": "Previous sections addressed how RELOAD works after a node has connected. This section provides an overview of how users get connected to the overlay for the first time. RELOAD is designed so that users can start with the name of the overlay they wish to join and perhaps an account name and password, and can leverage these into having a working peer with minimal user intervention. This helps avoid the problems that have been experienced with conventional SIP clients in which users need to manually configure a large number of settings.",
      "ja": "前のセクションでは、ノードが接続した後のRELOADの動作について説明しました。このセクションでは、ユーザーが初めてオーバーレイに接続する方法の概要を説明します。 RELOADは、ユーザーが参加したいオーバーレイの名前と、おそらくアカウント名とパスワードで開始できるように設計されており、これらを活用して、ユーザーの介入を最小限に抑えてピアを機能させることができます。これにより、ユーザーが多数の設定を手動で構成する必要がある従来のSIPクライアントで発生していた問題を回避できます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Initial Configuration",
      "section_title": true,
      "ja": "4.6.1. 初期構成"
    },
    {
      "indent": 3,
      "text": "In the first phase of the setup process, the user starts with the name of the overlay and uses it to download an initial set of overlay configuration parameters. The node does a DNS SRV [RFC2782] lookup on the overlay name to get the address of a configuration server. It can then connect to this server with HTTPS [RFC2818] to download a Configuration Document which contains the basic overlay configuration parameters as well as a set of bootstrap nodes which can be used to join the overlay. The details of the relationships between names in the HTTPS certificates and the overlay names are described in Section 11.2.",
      "ja": "セットアッププロセスの最初のフェーズでは、ユーザーはオーバーレイの名前から始め、それを使用してオーバーレイ構成パラメーターの初期セットをダウンロードします。ノードは、オーバーレイ名に対してDNS SRV [RFC2782]ルックアップを実行して、構成サーバーのアドレスを取得します。次に、HTTPS [RFC2818]を使用してこのサーバーに接続し、基本的なオーバーレイ構成パラメーターと、オーバーレイの結合に使用できるブートストラップノードのセットを含む構成ドキュメントをダウンロードできます。 HTTPS証明書の名前とオーバーレイ名の関係の詳細については、セクション11.2で説明します。"
    },
    {
      "indent": 3,
      "text": "If a node already has the valid Configuration Document that it received by an out-of-band method, this step can be skipped. Note that this out-of-band method needs to provide authentication and integrity, because the Configuration Document contains the trust anchors used by the overlay.",
      "ja": "ノードがアウトオブバンド方式で受信した有効な構成ドキュメントをすでに持っている場合、この手順はスキップできます。構成ドキュメントにはオーバーレイで使用されるトラストアンカーが含まれているため、この帯域外の方法では認証と整合性を提供する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Enrollment",
      "section_title": true,
      "ja": "4.6.2. 入学"
    },
    {
      "indent": 3,
      "text": "If the overlay is using centralized enrollment, then a user needs to acquire a certificate before joining the overlay. The certificate attests both to the user's name within the overlay and to the Node-IDs which they are permitted to operate. In this case, the Configuration Document will contain the address of an enrollment server which can be used to obtain such a certificate and will also contain the trust anchor, so this document must be retrieved securely (see Section 11.2). The enrollment server may (and probably will) require some sort of account name for the user and a password before issuing the certificate. The enrollment server's ability to ensure attackers cannot get a large number of certificates for the overlay is one of the cornerstones of RELOAD's security.",
      "ja": "オーバーレイが集中登録を使用している場合、ユーザーはオーバーレイに参加する前に証明書を取得する必要があります。証明書は、オーバーレイ内のユーザーの名前と、ユーザーが操作を許可されているノードIDの両方を証明します。この場合、構成ドキュメントには、このような証明書の取得に使用できる登録サーバーのアドレスが含まれ、トラストアンカーも含まれるため、このドキュメントは安全に取得する必要があります（セクション11.2を参照）。登録サーバーは、証明書を発行する前に、ユーザーのある種のアカウント名とパスワードを要求する場合があります（おそらく要求するでしょう）。登録サーバーが攻撃者がオーバーレイの多数の証明書を取得できないようにする機能は、RELOADのセキュリティの基礎の1つです。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Diagnostics",
      "section_title": true,
      "ja": "4.6.3. 診断"
    },
    {
      "indent": 3,
      "text": "Significant advice around managing a RELOAD overlay and extensions for diagnostics are described in [P2P-DIAGNOSTICS].",
      "ja": "診断のRELOADオーバーレイと拡張機能の管理に関する重要なアドバイスは、[P2P-DIAGNOSTICS]で説明されています。"
    },
    {
      "indent": 0,
      "text": "5. Application Support Overview",
      "section_title": true,
      "ja": "5. アプリケーションサポートの概要"
    },
    {
      "indent": 3,
      "text": "RELOAD is not intended to be used alone, but rather as a substrate for other applications. These applications can use RELOAD for a variety of purposes:",
      "ja": "RELOADは、単独で使用することを意図したものではなく、他のアプリケーションの基盤として使用することを目的としています。これらのアプリケーションは、さまざまな目的でRELOADを使用できます。"
    },
    {
      "indent": 3,
      "text": "o To store data in the overlay and to retrieve data stored by other nodes.",
      "ja": "o オーバーレイにデータを保存し、他のノードによって保存されたデータを取得します。"
    },
    {
      "indent": 3,
      "text": "o As a discovery mechanism for services such as TURN.",
      "ja": "o TURNなどのサービスの検出メカニズムとして。"
    },
    {
      "indent": 3,
      "text": "o To form direct connections which can be used to transmit application-level messages without using the overlay.",
      "ja": "o オーバーレイを使用せずにアプリケーションレベルのメッセージを送信するために使用できる直接接続を形成します。"
    },
    {
      "indent": 3,
      "text": "This section provides an overview of these services.",
      "ja": "このセクションでは、これらのサービスの概要について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Data Storage",
      "section_title": true,
      "ja": "5.1. データストレージ"
    },
    {
      "indent": 3,
      "text": "RELOAD provides operations to Store and Fetch data. Each location in the Overlay Instance is referenced by a Resource-ID. However, each location may contain data elements corresponding to multiple Kinds (e.g., certificate and SIP registration). Similarly, there may be multiple elements of a given Kind, as shown below:",
      "ja": "RELOADは、データを保存およびフェッチする操作を提供します。オーバーレイインスタンスの各場所は、リソースIDによって参照されます。ただし、各場所には、複数の種類（証明書やSIP登録など）に対応するデータ要素が含まれている場合があります。同様に、以下に示すように、特定の種類の要素が複数存在する場合があります。"
    },
    {
      "indent": 22,
      "text": "+--------------------------------+\n|            Resource-ID         |\n|                                |\n| +------------+  +------------+ |\n| |   Kind 1   |  |   Kind 2   | |\n| |            |  |            | |\n| | +--------+ |  | +--------+ | |\n| | | Value  | |  | | Value  | | |\n| | +--------+ |  | +--------+ | |\n| |            |  |            | |\n| | +--------+ |  | +--------+ | |\n| | | Value  | |  | | Value  | | |\n| | +--------+ |  | +--------+ | |\n| |            |  +------------+ |\n| | +--------+ |                 |\n| | | Value  | |                 |\n| | +--------+ |                 |\n| +------------+                 |\n+--------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Kind is identified by a Kind-ID, which is a code point either assigned by IANA or allocated out of a private range. As part of the Kind definition, protocol designers may define constraints (such as limits on size) on the values which may be stored. For many Kinds, the set may be restricted to a single value, while some sets may be allowed to contain multiple identical items, and others may have only unique items. Note that a Kind may be employed by multiple usages, and new usages are encouraged to use previously defined Kinds where possible. We define the following data models in this document, although other usages can define their own structures:",
      "ja": "各種類は、IANAによって割り当てられた、またはプライベート範囲外に割り当てられたコードポイントである種類IDによって識別されます。種類の定義の一部として、プロトコル設計者は、格納できる値に制約（サイズの制限など）を定義できます。多くの種類では、セットは単一の値に制限される場合がありますが、一部のセットは複数の同一アイテムを含むことが許可されている場合もあれば、一意のアイテムのみを持つ場合もあります。 Kindは複数の使用法で使用される場合があり、新しい使用法では、可能な場合は以前に定義されたKindを使用することをお勧めします。このドキュメントでは、次のデータモデルを定義していますが、他の使用法でも独自の構造を定義できます。"
    },
    {
      "indent": 3,
      "text": "single value: There can be at most one item in the set, and any value overwrites the previous item.",
      "ja": "単一の値：セットには最大で1つのアイテムを含めることができ、任意の値が前のアイテムを上書きします。"
    },
    {
      "indent": 3,
      "text": "array: Many values can be stored and addressed by a numeric index.",
      "ja": "配列：多くの値を格納し、数値インデックスでアドレス指定できます。"
    },
    {
      "indent": 3,
      "text": "dictionary: The values stored are indexed by a key. Often, this key is one of the values from the certificate of the peer sending the Store request.",
      "ja": "辞書：格納された値には、キーによってインデックスが付けられます。多くの場合、このキーは、ストア要求を送信するピアの証明書の値の1つです。"
    },
    {
      "indent": 3,
      "text": "In order to protect stored data from tampering by other nodes, each stored value is individually digitally signed by the node which created it. When a value is retrieved, the digital signature can be verified to detect tampering. If the certificate used to verify the stored value signature expires, the value can no longer be retrieved (although it may not be immediately garbage collected by the storing node), and the creating node will need to store the value again if it desires that the stored value continue to be available.",
      "ja": "保存されたデータを他のノードによる改ざんから保護するために、保存された各値は、それを作成したノードによって個別にデジタル署名されます。値が取得されると、デジタル署名を検証して改ざんを検出できます。ストアドバリューの署名の検証に使用される証明書の有効期限が切れると、値を取得できなくなります（ただし、格納ノードによってガベージコレクションがすぐに行われるわけではありません）。作成ノードは、値が必要な場合、値を再度格納する必要があります。保存された値は引き続き使用できます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Storage Permissions",
      "section_title": true,
      "ja": "5.1.1. ストレージのアクセス許可"
    },
    {
      "indent": 3,
      "text": "A major issue in peer-to-peer storage networks is minimizing the burden of becoming a peer and, in particular, minimizing the amount of data which any peer needs to store for other nodes. RELOAD addresses this issue by allowing any given node to store data only at a small number of locations in the overlay, with those locations being determined by the node's certificate. When a peer uses a Store request to place data at a location authorized by its certificate, it signs that data with the private key that corresponds to its certificate. Then the peer responsible for storing the data is able to verify that the peer issuing the request is authorized to make that request. Each data Kind defines the exact rules for determining what certificate is appropriate.",
      "ja": "ピアツーピアストレージネットワークの主要な問題は、ピアになる負担を最小限に抑えること、特に、他のノードのためにピアが格納する必要があるデータの量を最小限に抑えることです。 RELOADは、特定のノードがオーバーレイの少数の場所にのみデータを保存できるようにすることでこの問題に対処します。これらの場所はノードの証明書によって決定されます。ピアがStore要求を使用して、証明書によって承認された場所にデータを配置する場合、ピアは、その証明書に対応する秘密キーでデータに署名します。次に、データの保存を担当するピアは、要求を発行するピアがその要求を行う権限を持っていることを確認できます。各データの種類は、適切な証明書を決定するための正確なルールを定義します。"
    },
    {
      "indent": 0,
      "text": " The most natural rule is that a certificate authorizes a user to store data keyed with their user name X. Thus, only a user with a certificate for \"alice@example.org\" could write to that location in the overlay (see Section 11.3). However, other usages can define any rules they choose, including publicly writable values.",
      "ja": "最も自然な規則は、証明書がユーザーにユーザー名Xでキー設定されたデータを格納することを許可することです。したがって、「alice@example.org」の証明書を持つユーザーのみがオーバーレイのその場所に書き込むことができます（セクション11.3を参照） 。ただし、他の使用法では、パブリックに書き込み可能な値を含め、選択したルールを定義できます。"
    },
    {
      "indent": 3,
      "text": "The digital signature over the data serves two purposes. First, it allows the peer responsible for storing the data to verify that this Store is authorized. Second, it provides integrity for the data. The signature is saved along with the data value (or values) so that any reader can verify the integrity of the data. Of course, the responsible peer can \"lose\" the value, but it cannot undetectably modify it.",
      "ja": "データのデジタル署名には2つの目的があります。まず、データの保存を担当するピアが、このストアが承認されていることを確認できます。次に、データの整合性を提供します。署名はデータ値（1つまたは複数）と共に保存されるため、どのリーダーもデータの整合性を検証できます。もちろん、責任のあるピアは値を「失う」ことができますが、それを検出不能に変更することはできません。"
    },
    {
      "indent": 3,
      "text": "The size requirements of the data being stored in the overlay are variable. For instance, a SIP AOR and voicemail differ widely in the storage size. RELOAD leaves it to the usage and overlay configuration to limit size imbalances of various Kinds.",
      "ja": "オーバーレイに格納されるデータのサイズ要件は可変です。たとえば、SIP AORとボイスメールのストレージサイズは大きく異なります。 RELOADは、さまざまな種類のサイズの不均衡を制限するために、それを使用法およびオーバーレイ構成に任せます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Replication",
      "section_title": true,
      "ja": "5.1.2. レプリケーション"
    },
    {
      "indent": 3,
      "text": "Replication in P2P overlays can be used to provide:",
      "ja": "P2Pオーバーレイでのレプリケーションは、以下を提供するために使用できます。"
    },
    {
      "indent": 3,
      "text": "persistence: if the responsible peer crashes and/or if the storing peer leaves the overlay",
      "ja": "永続性：責任のあるピアがクラッシュした場合、および/または格納しているピアがオーバーレイを離れた場合"
    },
    {
      "indent": 3,
      "text": "security: to guard against DoS attacks by the responsible peer or routing attacks to that responsible peer",
      "ja": "セキュリティ：責任のあるピアによるDoS攻撃またはその責任のあるピアへのルーティング攻撃から保護する"
    },
    {
      "indent": 3,
      "text": "load balancing: to balance the load of queries for popular resources",
      "ja": "負荷分散：人気のあるリソースに対するクエリの負荷を分散する"
    },
    {
      "indent": 3,
      "text": "A variety of schemes are used in P2P overlays to achieve some of these goals. Common techniques include replicating on neighbors of the responsible peer, randomly locating replicas around the overlay, and replicating along the path to the responsible peer.",
      "ja": "P2Pオーバーレイでは、これらの目標のいくつかを達成するためにさまざまなスキームが使用されます。一般的な手法には、責任のあるピアのネイバーでの複製、オーバーレイ周辺のランダムなレプリカの配置、責任のあるピアへのパスに沿った複製が含まれます。"
    },
    {
      "indent": 3,
      "text": "The core RELOAD specification does not specify a particular replication strategy. Instead, the first level of replication strategies is determined by the overlay algorithm, which can base the replication strategy on its particular topology. For example, Chord places replicas on successor peers, which will take over responsibility if the responsible peer fails [Chord].",
      "ja": "コアRELOAD仕様は、特定のレプリケーション戦略を指定していません。代わりに、複製戦略の最初のレベルは、特定のトポロジに基づいて複製戦略を作成できるオーバーレイアルゴリズムによって決定されます。たとえば、Chordは後続のピアにレプリカを配置し、責任のあるピアに障害が発生した場合に責任を引き継ぎます[Chord]。"
    },
    {
      "indent": 3,
      "text": "If additional replication is needed, for example, if data persistence is particularly important for a particular usage, then that usage may specify additional replication, such as implementing random replications by inserting a different well-known constant into the Resource Name used to store each replicated copy of the resource. Such replication strategies can be added independently of the underlying algorithm, and their usage can be determined based on the needs of the particular usage.",
      "ja": "追加のレプリケーションが必要な場合、たとえば、特定の使用法でデータの永続性が特に重要である場合、その使用法は、各複製の保存に使用されるリソース名に異なる既知の定数を挿入することによりランダムレプリケーションを実装するなど、追加の複製を指定できます。リソースのコピー。このような複製戦略は、基盤となるアルゴリズムとは無関係に追加でき、その使用法は、特定の使用法のニーズに基づいて決定できます。"
    },
    {
      "indent": 0,
      "text": "5.2. Usages",
      "section_title": true,
      "ja": "5.2. 用途"
    },
    {
      "indent": 3,
      "text": "By itself, the distributed storage layer provides only the infrastructure on which applications are built. In order to do anything useful, a usage needs to be defined. Each usage needs to specify several things:",
      "ja": "分散ストレージレイヤー自体は、アプリケーションが構築されるインフラストラクチャのみを提供します。有用なことを行うには、使用法を定義する必要があります。使用法ごとに、いくつかのことを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Register Kind-ID code points for any Kinds that the usage defines (Section 14.6).",
      "ja": "o 使用法で定義されている種類の種類IDコードポイントを登録します（セクション14.6）。"
    },
    {
      "indent": 3,
      "text": "o Define the data structure for each of the Kinds (the value member in Section 7.2). If the data structure contains character strings, conversion rules between characters and the binary storage need to be specified.",
      "ja": "o 各種類のデータ構造を定義します（セクション7.2の値メンバー）。データ構造に文字列が含まれている場合、文字とバイナリストレージ間の変換規則を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Define access control rules for each of the Kinds (Section 7.3).",
      "ja": "o 各種類のアクセス制御ルールを定義します（第7.3項）。"
    },
    {
      "indent": 3,
      "text": "o Define how the Resource Name is used to form the Resource-ID where each Kind is stored.",
      "ja": "o リソース名を使用して、各種類が格納されるリソースIDを形成する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Describe how values will be merged when a network partition is being healed.",
      "ja": "o ネットワークパーティションが修復されているときに値がマージされる方法を説明します。"
    },
    {
      "indent": 3,
      "text": "The Kinds defined by a usage may also be applied to other usages. However, a need for different parameters, such as a different access control model, would imply the need to create a new Kind.",
      "ja": "用途によって定義された種類は、他の用途にも適用できます。ただし、別のアクセス制御モデルなどの別のパラメーターが必要な場合は、新しい種類を作成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Service Discovery",
      "section_title": true,
      "ja": "5.3. サービスの発見"
    },
    {
      "indent": 3,
      "text": "RELOAD does not currently define a generic service discovery algorithm as part of the base protocol, although a simplistic TURN-specific discovery mechanism is provided. A variety of service discovery algorithms can be implemented as extensions to the base protocol, such as the service discovery algorithm ReDIR [opendht-sigcomm05] and [REDIR-RELOAD].",
      "ja": "単純なTURN固有の検出メカニズムが提供されていますが、RELOADは現在、基本プロトコルの一部として一般的なサービス検出アルゴリズムを定義していません。サービス検出アルゴリズムReDIR [opendht-sigcomm05]や[REDIR-RELOAD]など、さまざまなサービス検出アルゴリズムを基本プロトコルの拡張機能として実装できます。"
    },
    {
      "indent": 0,
      "text": "5.4. Application Connectivity",
      "section_title": true,
      "ja": "5.4. アプリケーション接続"
    },
    {
      "indent": 3,
      "text": "There is no requirement that a RELOAD Usage needs to use RELOAD's primitives for establishing its own communication if it already possesses its own means of establishing connections. For example, one could design a RELOAD-based resource discovery protocol which used HTTP to retrieve the actual data.",
      "ja": "RELOAD Usageが接続を確立する独自の手段をすでに持っている場合、RELOADが独自の通信を確立するためにRELOADのプリミティブを使用する必要があるという要件はありません。たとえば、実際のデータを取得するためにHTTPを使用するRELOADベースのリソース検出プロトコルを設計できます。"
    },
    {
      "indent": 0,
      "text": " For more common situations, however, it is the overlay itself -- rather than an external authority such as DNS -- which is used to establish a connection. RELOAD provides connectivity to applications using the AppAttach method. For example, if a P2PSIP node wishes to establish a SIP dialog with another P2PSIP node, it will use AppAttach to establish a direct connection with the other node. This new connection is separate from the peer protocol connection. It is a dedicated DTLS or TLS flow used only for the SIP dialog.",
      "ja": "ただし、より一般的な状況では、接続の確立に使用されるのは、DNSなどの外部機関ではなく、オーバーレイ自体です。 RELOADは、AppAttachメソッドを使用してアプリケーションへの接続を提供します。たとえば、P2PSIPノードが別のP2PSIPノードとのSIPダイアログを確立したい場合は、AppAttachを使用して他のノードとの直接接続を確立します。この新しい接続は、ピアプロトコル接続とは別のものです。これは、SIPダイアログにのみ使用される専用のDTLSまたはTLSフローです。"
    },
    {
      "indent": 0,
      "text": "6. Overlay Management Protocol",
      "section_title": true,
      "ja": "6. オーバーレイ管理プロトコル"
    },
    {
      "indent": 3,
      "text": "This section defines the basic protocols used to create, maintain, and use the RELOAD overlay network. We start by defining the basic concept of how message destinations are interpreted when routing messages. We then describe the symmetric recursive routing model, which is RELOAD's default routing algorithm. Finally, we define the message structure and the messages used to join and maintain the overlay.",
      "ja": "このセクションでは、RELOADオーバーレイネットワークの作成、維持、使用に使用される基本的なプロトコルを定義します。まず、メッセージのルーティング時にメッセージの宛先がどのように解釈されるかについての基本的な概念を定義します。次に、RELOADのデフォルトのルーティングアルゴリズムである対称再帰ルーティングモデルについて説明します。最後に、メッセージ構造と、オーバーレイの結合と維持に使用されるメッセージを定義します。"
    },
    {
      "indent": 0,
      "text": "6.1. Message Receipt and Forwarding",
      "section_title": true,
      "ja": "6.1. メッセージの受信と転送"
    },
    {
      "indent": 3,
      "text": "When a node receives a message, it first examines the overlay, version, and other header fields to determine whether the message is one it can process. If any of these are incorrect, as defined in Section 6.3.2, it is an error and the message MUST be discarded. The peer SHOULD generate an appropriate error, but local policy can override this and cause the message to be silently dropped.",
      "ja": "ノードはメッセージを受信すると、まず、オーバーレイ、バージョン、およびその他のヘッダーフィールドを調べて、メッセージが処理可能なメッセージかどうかを判断します。セクション6.3.2で定義されているように、これらのいずれかが正しくない場合はエラーであり、メッセージを破棄する必要があります。ピアは適切なエラーを生成する必要があります（SHOULD）が、ローカルポリシーがこれを上書きして、メッセージが通知なしでドロップされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Once the peer has determined that the message is correctly formatted (note that this does not include signature-checking on intermediate nodes as the message may be fragmented), it examines the first entry on the Destination List. There are three possible cases here:",
      "ja": "ピアは、メッセージが正しくフォーマットされていると判断すると（メッセージが断片化されている可能性があるため、中間ノードでの署名チェックは含まれないことに注意してください）、宛先リストの最初のエントリを調べます。ここでは3つのケースが考えられます。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an ID for which the peer is responsible. A peer is always responsible for the wildcard Node-ID. Handling of this case is described in Section 6.1.1.",
      "ja": "o 宛先リストの最初のエントリは、ピアが担当するIDです。ピアは常にワイルドカードノードIDを担当します。このケースの処理については、セクション6.1.1で説明します。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an ID for which another peer is responsible. Handling of this case is described in Section 6.1.2.",
      "ja": "o 宛先リストの最初のエントリは、別のピアが担当するIDです。このケースの処理については、セクション6.1.2で説明します。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an opaque ID that is being used for Destination List compression. Handling of this case is described in Section 6.1.3. Note that opaque IDs can be distinguished from Node-IDs and Resource-IDs on the wire as described in Section 6.3.2.2.",
      "ja": "o 宛先リストの最初のエントリは、宛先リストの圧縮に使用されている不透明なIDです。このケースの処理については、セクション6.1.3で説明します。 6.3.2.2項で説明するように、不透明なIDは回線上のノードIDおよびリソースIDと区別できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "These cases are handled as discussed below.",
      "ja": "これらのケースは、以下で説明するように処理されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Responsible ID",
      "section_title": true,
      "ja": "6.1.1. 責任者ID"
    },
    {
      "indent": 3,
      "text": "If the first entry on the Destination List is an ID for which the peer is responsible, there are several (mutually exclusive) subcases to consider.",
      "ja": "宛先リストの最初のエントリがピアが担当するIDである場合、考慮すべきいくつかの（相互に排他的な）サブケースがあります。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Resource-ID, then it MUST be the only entry on the Destination List. If there are other entries, the message MUST be silently dropped. Otherwise, the message is destined for this node, so the node MUST verify the signature as described in Section 7.1 and MUST pass it to the upper layers. \"Upper layers\" is used here to mean the components above the \"Overlay Link Service Boundary\" line in the figure in Section 1.2.",
      "ja": "o エントリがResource-IDの場合、それは宛先リストの唯一のエントリでなければなりません。他のエントリがある場合は、メッセージを通知なしでドロップする必要があります。それ以外の場合、メッセージの宛先はこのノードであるため、ノードはセクション7.1で説明されているように署名を検証し、それを上位層に渡す必要があります。ここで「上位層」は、セクション1.2の図の「オーバーレイリンクサービス境界」線より上のコンポーネントを意味するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Node-ID which equals this node's Node-ID, then the message is destined for this node. If it is the only entry on the Destination List, the message is destined for this node and so the node passes it to the upper layers. Otherwise, the node removes the entry from the Destination List and repeats the routing process with the next entry on the Destination List. If the message is a response and list compression was used, then the node first modifies the Destination List to reinsert the saved state, e.g., by unpacking any opaque IDs.",
      "ja": "o エントリがこのノードのノードIDと等しいノードIDである場合、メッセージの宛先はこのノードです。それが宛先リストの唯一のエントリである場合、メッセージはこのノードを宛先としているため、ノードはそれを上位層に渡します。それ以外の場合、ノードは宛先リストからエントリを削除し、宛先リストの次のエントリでルーティングプロセスを繰り返します。メッセージが応答であり、リスト圧縮が使用された場合、ノードは最初に宛先リストを変更して、たとえば、不透明なIDをアンパックするなどして、保存された状態を再挿入します。"
    },
    {
      "indent": 3,
      "text": "o If the entry is the wildcard Node-ID (all \"1\"s), the message is destined for this node, and the node passes the message to the upper layers. A message with a wildcard Node-ID as its first entry is never forwarded; it is consumed locally.",
      "ja": "o エントリがワイルドカードノードID（すべて \"1\"）の場合、メッセージの宛先はこのノードであり、ノードはメッセージを上位層に渡します。最初のエントリがワイルドカードのノードIDのメッセージは転送されません。ローカルで消費されます。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Node-ID which is not equal to this node, then the node MUST drop the message silently unless the Node-ID corresponds to a node which is directly connected to this node (i.e., a client). In the latter case, the node MUST attempt to forward the message to the destination node as described in the next section (though this may fail for connectivity reasons, because the TTL has expired, or because of some other error.)",
      "ja": "o エントリがこのノードに等しくないNode-IDである場合、Node-IDがこのノードに直接接続されているノード（つまり、クライアント）に対応しない限り、ノードはメッセージをサイレントにドロップする必要があります。後者の場合、ノードは次のセクションで説明するように、メッセージを宛先ノードに転送しようとする必要があります（ただし、接続上の理由、TTLの期限切れ、またはその他のエラーが原因で失敗する場合があります）。"
    },
    {
      "indent": 3,
      "text": "Note that this process implies that in order to address a message to \"the peer that controls region X\", a sender sends to Resource-ID X, not Node-ID X.",
      "ja": "このプロセスは、メッセージを「リージョンXを制御するピア」にアドレス指定するために、送信者がノードID Xではなく、リソースID Xに送信することを意味することに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Other ID",
      "section_title": true,
      "ja": "6.1.2. その他のID"
    },
    {
      "indent": 0,
      "text": " If the first entry on the Destination List is neither an opaque ID nor an ID the peer is responsible for, then the peer MUST forward the message towards that entry. This means that it MUST select one of the peers to which it is connected and which is most likely to be responsible (according to the Topology Plug-in) for the first entry on the Destination List. For the CHORD-RELOAD topology, the routing to the most likely responsible node is explained in Section 10.3. If the first entry on the Destination List is in the peer's Connection Table, the peer MUST forward the message to that peer directly. Otherwise, the peer consults the Routing Table to forward the message.",
      "ja": "宛先リストの最初のエントリが不透明なIDでもピアが担当するIDでもない場合、ピアはそのエントリに向けてメッセージを転送する必要があります。これは、接続先のピアの1つを選択する必要があり、宛先トポロジの最初のエントリに対して（トポロジプラグインに従って）責任がある可能性が最も高いことを意味します。 CHORD-RELOADトポロジの場合、最も可能性の高いノードへのルーティングについては、10.3項で説明しています。宛先リストの最初のエントリがピアの接続テーブルにある場合、ピアはメッセージをそのピアに直接転送する必要があります。それ以外の場合、ピアはルーティングテーブルを参照してメッセージを転送します。"
    },
    {
      "indent": 3,
      "text": "Any intermediate peer which forwards a RELOAD request MUST ensure that if it receives a response to that message, the response can be routed back through the set of nodes through which the request passed. The peer selects one of these approaches:",
      "ja": "RELOAD要求を転送する中間ピアは、そのメッセージへの応答を受信した場合、要求が通過したノードのセットを介して応答をルーティングできるようにする必要があります。ピアは次のいずれかの方法を選択します。"
    },
    {
      "indent": 3,
      "text": "o The peer can add an entry to the Via List in the forwarding header that will enable it to determine the correct node. This is done by appending to the Via List the Node-ID of the node from which the request was received.",
      "ja": "o ピアは、転送ヘッダーのViaリストにエントリを追加して、正しいノードを判別できるようにすることができます。これは、要求を受信したノードのノードIDをViaリストに追加することによって行われます。"
    },
    {
      "indent": 3,
      "text": "o The peer can keep per-transaction state which will allow it to determine the correct node.",
      "ja": "o ピアはトランザクションごとの状態を維持できるため、正しいノードを判別できます。"
    },
    {
      "indent": 3,
      "text": "As an example of the first strategy, consider an example with nodes A, B, C, D, and E. If node D receives a message from node C with Via List [A, B], then D would forward to the next node E with Via List [A, B, C]. Now, if E wants to respond to the message, it reverses the Via List to produce the Destination List, resulting in [D, C, B, A]. When D forwards the response to C, the Destination List will contain [C, B, A].",
      "ja": "最初の戦略の例として、ノードA、B、C、D、Eの例を考えます。ノードDがノードCからVia List [A、B]でメッセージを受信すると、Dは次のノードに転送します。ビアリスト付きのE [A、B、C]。ここで、Eがメッセージに応答する場合は、Viaリストを逆にして宛先リストを作成し、[D、C、B、A]を生成します。 Dが応答をCに転送すると、宛先リストには[C、B、A]が含まれます。"
    },
    {
      "indent": 3,
      "text": "As an example of the second strategy, if node D receives a message from node C with transaction ID X (as assigned by A) and Via List [A, B], it could store [X, C] in its state database and forward the message with the Via List unchanged. When D receives the response, it consults its state database for transaction ID X, determines that the request came from C, and forwards the response to C.",
      "ja": "2番目の戦略の例として、ノードDがトランザクションID X（Aによって割り当てられたもの）およびVia List [A、B]を含むメッセージをノードCから受信した場合、[X、C]をその状態データベースに保存して転送できます。 Viaリストが変更されていないメッセージ。 Dは応答を受信すると、トランザクションID Xについてその状態データベースを調べ、要求がCからのものであると判断し、応答をCに転送します。"
    },
    {
      "indent": 3,
      "text": "Intermediate peers which modify the Via List are not required to simply add entries. The only requirement is that the peer MUST be able to reconstruct the correct Destination List on the return route. RELOAD provides explicit support for this functionality in the form of opaque IDs, which can replace any number of Via List entries.",
      "ja": "Viaリストを変更する中間ピアは、単にエントリを追加する必要はありません。唯一の要件は、ピアが戻りルートで正しい宛先リストを再構築できる必要があることです。 RELOADは、不透明IDの形式でこの機能を明示的にサポートします。これにより、任意の数のViaリストエントリを置き換えることができます。"
    },
    {
      "indent": 0,
      "text": " For instance, in the above example, Node D might send E a Via List containing only the opaque ID I. E would then use the Destination List [D, I] to send its return message. When D processes this Destination List, it would detect that I is an opaque ID, recover the Via List [A, B, C], and reverse that to produce the correct Destination List [C, B, A] before sending it to C. This feature is called \"list compression\". Possibilities for an opaque ID include a compressed and/or encrypted version of the original Via List and an index into a state database containing the original Via List, but the details are a local matter.",
      "ja": "たとえば、上記の例では、ノードDは不透明なID Iのみを含むViaリストをEに送信します。次に、Eは宛先リスト[D、I]を使用してその返信メッセージを送信します。 Dがこの宛先リストを処理するとき、Cに送信する前に、Iが不透明なIDであることを検出し、経由リスト[A、B、C]を回復し、それを逆にして正しい宛先リスト[C、B、A]を生成します。この機能は「リスト圧縮」と呼ばれます。不透明なIDの可能性には、元のViaリストの圧縮および/または暗号化バージョン、および元のViaリストを含む状態データベースへのインデックスが含まれますが、詳細はローカルの問題です。"
    },
    {
      "indent": 3,
      "text": "No matter what mechanism for storing Via List state is used, if an intermediate peer exits the overlay, then on the return trip the message cannot be forwarded and will be dropped. The ordinary timeout and retransmission mechanisms provide stability over this type of failure.",
      "ja": "Via List状態を格納するためのメカニズムが使用されているかどうかに関係なく、中間ピアがオーバーレイを終了すると、メッセージは転送されずにドロップされます。通常のタイムアウトおよび再送信メカニズムは、このタイプの障害に対する安定性を提供します。"
    },
    {
      "indent": 3,
      "text": "Note that if an intermediate peer retains per-transaction state instead of modifying the Via List, it needs some mechanism for timing out that state; otherwise, its state database will grow without bound. Whatever algorithm is used, unless a FORWARD_CRITICAL forwarding option (Section 6.3.2.3) or an overlay configuration option explicitly indicates this state is not needed, the state MUST be maintained for at least the value of the overlay-reliability-timer configuration parameter and MAY be kept longer. Future extensions, such as [P2PSIP-RELAY], may define mechanisms for determining when this state does not need to be retained.",
      "ja": "中間ピアがViaリストを変更する代わりにトランザクションごとの状態を保持する場合、その状態をタイムアウトするための何らかのメカニズムが必要であることに注意してください。それ以外の場合は、その状態データベースは無限に大きくなります。使用されるアルゴリズムが何であれ、FORWARD_CRITICAL転送オプション（セクション6.3.2.3）またはオーバーレイ構成オプションがこの状態が不要であることを明示的に示さない限り、少なくともoverlay-reliability-timer構成パラメータの値に対して状態を維持する必要があります。より長く維持されます。 [P2PSIP-RELAY]などの将来の拡張では、この状態を保持する必要がない場合を決定するメカニズムを定義する可能性があります。"
    },
    {
      "indent": 3,
      "text": "There is no requirement to ensure that a request issued after the receipt of a response follows the same path as the response. As a consequence, there is no requirement to use either of the mechanisms described above (Via List or state retention) when processing a response message.",
      "ja": "応答の受信後に発行された要求が応答と同じパスに従うことを保証する必要はありません。結果として、応答メッセージを処理するときに、上記のメカニズム（リスト経由または状態保持）のいずれかを使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "A node receiving a request from another node MUST ensure that any response to that request exits that node with a Destination List equal to the concatenation of the Node-ID of the node from which the request was received with the Via List in the original request. The intermediate node normally learns the Node-ID that the other node is using via an Attach, but a node using a certificate with a single Node-ID MAY elect not to send an Attach (see Section 4.2.1, bullet 2). If a node with a certificate with multiple Node-IDs attempts to route a message other than a Ping or Attach through a node without performing an Attach, the receiving node MUST reject the request with an Error_Forbidden error. The node MUST implement support for returning responses to a Ping or Attach request made by a Joining Node Attaching to its responsible peer.",
      "ja": "別のノードから要求を受信するノードは、その要求へのすべての応答が、元の要求のViaリストを使用して要求を受信したノードのノードIDの連結と等しい宛先リストでそのノードを出るようにする必要があります。中間ノードは通常、他のノードがアタッチを介して使用しているノードIDを学習しますが、単一のノードIDを持つ証明書を使用するノードは、アタッチを送信しないことを選択できます（セクション4.2.1、箇条書き2を参照）。複数のノードIDを持つ証明書を持つノードが、接続を実行せずにノードを介してPingまたは接続以外のメッセージをルーティングしようとする場合、受信ノードは、Error_Forbiddenエラーで要求を拒否する必要があります。ノードは、責任のあるピアへの参加ノード接続によって行われたPingまたは接続要求への応答を返すためのサポートを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Opaque ID",
      "section_title": true,
      "ja": "6.1.3. 不透明ID"
    },
    {
      "indent": 3,
      "text": "If the first entry on the Destination List is an opaque ID (e.g., a compressed Via List), the peer MUST replace the entry with the original Via List that it replaced and then re-examine the Destination List to determine which of the three cases in Section 6.1 now applies.",
      "ja": "宛先リストの最初のエントリが不透明なID（たとえば、圧縮されたViaリスト）である場合、ピアはエントリを元のViaリストに置き換え、置き換えた後、宛先リストを再検査して3つのケースのいずれかを決定する必要があります。セクション6.1が適用されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Symmetric Recursive Routing",
      "section_title": true,
      "ja": "6.2. 対称再帰ルーティング"
    },
    {
      "indent": 3,
      "text": "This section defines RELOAD's Symmetric Recursive Routing algorithm, which is the default algorithm used by nodes to route messages through the overlay. All implementations MUST implement this routing algorithm. An overlay MAY be configured to use alternative routing algorithms, and alternative routing algorithms MAY be selected on a per-message basis. That is, a node in an overlay which supports Symmetric Recursive Routing and some other routing algorithm called XXX might use Symmetric Recursive Routing some of the time and XXX at other times.",
      "ja": "このセクションでは、RELOADの対称再帰ルーティングアルゴリズムを定義します。これは、オーバーレイを介してメッセージをルーティングするためにノードが使用するデフォルトのアルゴリズムです。すべての実装は、このルーティングアルゴリズムを実装する必要があります。オーバーレイは、代替ルーティングアルゴリズムを使用するように構成できます。また、代替ルーティングアルゴリズムをメッセージごとに選択できます（MAY）。つまり、対称再帰ルーティングとXXXと呼ばれるその他のルーティングアルゴリズムをサポートするオーバーレイのノードは、対称再帰ルーティングを使用する場合とXXXを使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Request Origination",
      "section_title": true,
      "ja": "6.2.1. オリジネーションのリクエスト"
    },
    {
      "indent": 3,
      "text": "In order to originate a message to a given Node-ID or Resource-ID, a node MUST construct an appropriate Destination List. The simplest such Destination List is a single entry containing the Node-ID or Resource-ID. The resulting message MUST be forwarded to its destination via the normal overlay routing mechanisms. The node MAY also construct a more complicated Destination List for source routing.",
      "ja": "特定のノードIDまたはリソースIDにメッセージを発信するために、ノードは適切な宛先リストを作成する必要があります。そのような最も単純な宛先リストは、ノードIDまたはリソースIDを含む単一のエントリです。結果のメッセージは、通常のオーバーレイルーティングメカニズムを介して宛先に転送される必要があります。ノードはまた、ソースルーティングのためのより複雑な宛先リストを構築してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Once the message is constructed, the node sends the message to an adjacent peer. If the first entry on the Destination List is directly connected, then the message MUST be routed down that connection. Otherwise, the Topology Plug-in MUST be consulted to determine the appropriate next hop.",
      "ja": "メッセージが作成されると、ノードはメッセージを隣接ピアに送信します。宛先リストの最初のエントリが直接接続されている場合、メッセージはその接続を経由してルーティングされる必要があります。それ以外の場合は、トポロジプラグインを調べて、適切なネクストホップを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parallel requests for a resource are a common solution to improve reliability in the face of churn or subversive peers. Parallel searches for usage-specified replicas are managed by the usage layer, for instance, by having the usage store data at multiple Resource-IDs, with the requesting node sending requests to each of those Resource-IDs. However, a single request MAY also be routed through multiple adjacent peers, even when they are known to be suboptimal, to improve reliability [vulnerabilities-acsac04]. Such parallel searches MAY be specified by the Topology Plug-in, in which case it would return multiple next hops and the request would be routed to all of them.",
      "ja": "リソースの並列要求は、チャーンまたは破壊的なピアに直面した場合の信頼性を向上させる一般的なソリューションです。使用法で指定されたレプリカの並列検索は、たとえば、複数のリソースIDに使用法ストアデータを置き、要求ノードがそれらの各リソースIDに要求を送信することにより、使用法レイヤーによって管理されます。ただし、信頼性を向上させるために、1つのリクエストが複数の隣接ピアを経由してルーティングされる場合があります（隣接ピアが最適でないことがわかっている場合でも）[vulnerabilities-acsac04]。このような並列検索は、トポロジプラグインによって指定される場合があります。その場合、複数のネクストホップが返され、要求はそれらすべてにルーティングされます。"
    },
    {
      "indent": 3,
      "text": "Because messages can be lost in transit through the overlay, RELOAD incorporates an end-to-end reliability mechanism. When an originating node transmits a request, it MUST set a timer to the current overlay-reliability-timer. If a response has not been received when the timer fires, the request MUST be retransmitted with the same transaction identifier. The request MAY be retransmitted up to 4 times, for a total of 5 messages. After the timer for the fifth transmission fires, the message MUST be considered to have failed.",
      "ja": "メッセージはオーバーレイを通過する際に失われる可能性があるため、RELOADにはエンドツーエンドの信頼性メカニズムが組み込まれています。発信ノードがリクエストを送信するとき、それはタイマーを現在のoverlay-reliability-timerに設定しなければなりません（MUST）。タイマーが作動したときに応答が受信されなかった場合、同じトランザクション識別子で要求を再送信する必要があります。リクエストは最大4回、合計5つのメッセージで再送信できます。 5番目の送信のタイマーが作動した後、メッセージは失敗したと見なされなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Although the originating node will be doing both end-to-end and hop-by-hop retransmissions, the end-by-end retransmission procedure is not followed by intermediate nodes. They follow the hop-by-hop reliability procedure described in Section 6.6.3.",
      "ja": "発信ノードはエンドツーエンドとホップバイホップの両方の再送信を行いますが、エンドバイエンドの再送信手順の後に中間ノードは続きません。これらは、セクション6.6.3で説明されているホップバイホップの信頼性手順に従います。"
    },
    {
      "indent": 3,
      "text": "The above algorithm can result in multiple requests being delivered to a node. Receiving nodes MUST generate semantically equivalent responses to retransmissions of the same request (this can be determined by the transaction ID) if the request is received within the maximum request lifetime (15 seconds). For some requests (e.g., Fetch), this can be accomplished merely by processing the request again. For other requests (e.g., Store), it may be necessary to maintain state for the duration of the request lifetime.",
      "ja": "上記のアルゴリズムでは、複数のリクエストがノードに配信される可能性があります。受信ノードは、要求が最大要求存続期間（15秒）内に受信された場合、同じ要求の再送信（これはトランザクションIDによって判別できます）に対して意味的に同等の応答を生成する必要があります。一部のリクエスト（Fetchなど）では、これはリクエストを再度処理するだけで実行できます。他のリクエスト（ストアなど）の場合、リクエストの存続期間中、状態を維持する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Response Origination",
      "section_title": true,
      "ja": "6.2.2. 応答の発生"
    },
    {
      "indent": 3,
      "text": "When a peer sends a response to a request using this routing algorithm, it MUST construct the Destination List by reversing the order of the entries on the Via List. This has the result that the response traverses the same peers as the request traversed, except in reverse order (symmetric routing) and possibly with extra nodes (loose routing).",
      "ja": "ピアがこのルーティングアルゴリズムを使用して要求への応答を送信する場合、ビアリストのエントリの順序を逆にすることで宛先リストを作成する必要があります。これにより、逆の順序（対称ルーティング）と余分なノード（ルーズルーティング）を除いて、応答が通過した要求と同じピアを通過するという結果になります。"
    },
    {
      "indent": 0,
      "text": "6.3. Message Structure",
      "section_title": true,
      "ja": "6.3. メッセージの構造"
    },
    {
      "indent": 3,
      "text": "RELOAD is a message-oriented request/response protocol. The messages are encoded using binary fields. All integers are represented in network byte order. The general philosophy behind the design was to use Type, Length, Value (TLV) fields to allow for extensibility. However, for the parts of a structure that were required in all messages, we just define these in a fixed position, as adding a type and length for them is unnecessary and would only increase bandwidth and introduce new potential interoperability issues.",
      "ja": "RELOADは、メッセージ指向の要求/応答プロトコルです。メッセージはバイナリフィールドを使用してエンコードされます。すべての整数は、ネットワークバイトオーダーで表されます。設計の背後にある一般的な哲学は、タイプ、長さ、値（TLV）フィールドを使用して拡張性を可能にすることでした。ただし、すべてのメッセージで必要な構造の部分については、タイプと長さを追加する必要がなく、帯域幅が増加し、新たな潜在的な相互運用性の問題が生じるため、これらを固定位置に定義するだけです。"
    },
    {
      "indent": 3,
      "text": "Each message has three parts, which are concatenated, as shown below:",
      "ja": "各メッセージには3つの部分があり、次に示すように連結されています。"
    },
    {
      "indent": 5,
      "text": "+-------------------------+\n|    Forwarding Header    |\n+-------------------------+\n|    Message Contents     |\n+-------------------------+\n|     Security Block      |\n+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of these parts are as follows:",
      "ja": "これらのパーツの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Forwarding Header: Each message has a generic header which is used to forward the message between peers and to its final destination. This header is the only information that an intermediate peer (i.e., one that is not the target of a message) needs to examine. Section 6.3.2 describes the format of this part.",
      "ja": "転送ヘッダー：各メッセージには、ピア間でメッセージを転送し、最終的な宛先に転送するために使用される汎用ヘッダーがあります。このヘッダーは、中間ピア（つまり、メッセージのターゲットではないもの）が検査する必要がある唯一の情報です。セクション6.3.2では、この部分の形式について説明します。"
    },
    {
      "indent": 3,
      "text": "Message Contents: The message being delivered between the peers. From the perspective of the forwarding layer, the contents are opaque; however, they are interpreted by the higher layers. Section 6.3.3 describes the format of this part.",
      "ja": "メッセージの内容：ピア間で配信されるメッセージ。転送層の観点から見ると、コンテンツは不透明です。ただし、それらは上位層によって解釈されます。 6.3.3項では、この部分の形式について説明します。"
    },
    {
      "indent": 3,
      "text": "Security Block: A security block containing certificates and a digital signature over the \"Message Contents\" section. Note that this signature can be computed without parsing the message contents. All messages MUST be signed by their originator. Section 6.3.4 describes the format of this part.",
      "ja": "セキュリティブロック：「メッセージの内容」セクションの証明書とデジタル署名を含むセキュリティブロック。この署名は、メッセージの内容を解析せずに計算できることに注意してください。すべてのメッセージは発信者によって署名されなければなりません。セクション6.3.4では、この部分の形式について説明します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Presentation Language",
      "section_title": true,
      "ja": "6.3.1. プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "The structures defined in this document are defined using a C-like syntax based on the presentation language used to define TLS [RFC5246]. Advantages of this style include:",
      "ja": "このドキュメントで定義されている構造は、TLS [RFC5246]を定義するために使用されるプレゼンテーション言語に基づくCのような構文を使用して定義されています。このスタイルの利点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o It is familiar enough that most readers can grasp it quickly.",
      "ja": "o ほとんどの読者がすぐに理解できるほど十分に精通しています。"
    },
    {
      "indent": 3,
      "text": "o The ability to define nested structures allows a separation between high-level and low-level message structures.",
      "ja": "o ネストされた構造を定義する機能により、高レベルのメッセージ構造と低レベルのメッセージ構造を分離できます。"
    },
    {
      "indent": 3,
      "text": "o It has a straightforward wire encoding that allows quick implementation, but the structures can be comprehended without knowing the encoding.",
      "ja": "o それは素早い実装を可能にする簡単なワイヤーエンコーディングを持っていますが、構造はエンコーディングを知らなくても理解できます。"
    },
    {
      "indent": 3,
      "text": "o It is possible to mechanically compile encoders and decoders.",
      "ja": "o エンコーダとデコーダを機械的にコンパイルすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Several idiosyncrasies of this language are worth noting:",
      "ja": "この言語のいくつかの特異性は注目に値します："
    },
    {
      "indent": 3,
      "text": "o All lengths are denoted in bytes, not objects.",
      "ja": "o すべての長さは、オブジェクトではなくバイトで示されます。"
    },
    {
      "indent": 3,
      "text": "o Variable-length values are denoted like arrays, with angle brackets.",
      "ja": "o 可変長の値は、山括弧を使用して配列のように表されます。"
    },
    {
      "indent": 3,
      "text": "o \"select\" is used to indicate variant structures.",
      "ja": "o 「select」は、バリアント構造を示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "For instance, \"uint16 array<0..2^8-2>;\" represents up to 254 bytes, which corresponds to up to 127 values of two bytes (16 bits) each.",
      "ja": "たとえば、「uint16 array <0..2 ^ 8-2>;」のようになります。最大254バイトを表します。これは、それぞれ2バイト（16ビット）の最大127の値に対応します。"
    },
    {
      "indent": 3,
      "text": "A repetitive structure member shares a common notation with a member containing a variable-length block of data. The latter always starts with \"opaque\", whereas the former does not. For instance, the following denotes a variable block of data:",
      "ja": "反復構造メンバーは、可変長のデータブロックを含むメンバーと共通の表記法を共有します。後者は常に「不透明」で始まりますが、前者はそうではありません。たとえば、以下はデータの可変ブロックを示しています。"
    },
    {
      "indent": 21,
      "text": "opaque data<0..2^32-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "whereas the following denotes a list of 0, 1, or more instances of the Name element:",
      "ja": "一方、以下はName要素の0、1、またはそれ以上のインスタンスのリストを示しています。"
    },
    {
      "indent": 21,
      "text": "Name names<0..2^32-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Common Definitions",
      "section_title": true,
      "ja": "6.3.1.1. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "This section provides an introduction to the presentation language used throughout RELOAD.",
      "ja": "このセクションでは、RELOAD全体で使用されるプレゼンテーション言語の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "An enum represents an enumerated type. The values associated with each possibility are represented in parentheses, and the maximum value is represented as a nameless value, for purposes of describing the width of the containing integral type. For instance, Boolean represents a true or false:",
      "ja": "列挙型は列挙型を表します。含まれる整数型の幅を説明するために、各可能性に関連付けられた値は括弧内に表され、最大値は名前のない値として表されます。たとえば、ブール値はtrueまたはfalseを表します。"
    },
    {
      "indent": 9,
      "text": "enum { false(0), true(1), (255) } Boolean;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A boolean value is either a 1 or a 0. The max value of 255 indicates that this is represented as a single byte on the wire.",
      "ja": "ブール値は1または0のいずれかです。最大値255は、これが回線上の単一バイトとして表されることを示します。"
    },
    {
      "indent": 3,
      "text": "The NodeId, shown below, represents a single Node-ID.",
      "ja": "以下に示すNodeIdは、単一のノードIDを表します。"
    },
    {
      "indent": 13,
      "text": "typedef opaque NodeId[NodeIdLength];",
      "ja": "typedef不透明なNodeId [NodeIdLength];"
    },
    {
      "indent": 3,
      "text": "A NodeId is a fixed-length structure represented as a series of bytes, with the most significant byte first. The length is set on a per-overlay basis within the range of 16-20 bytes (128 to 160 bits). (See Section 11.1 for how NodeIdLength is set.) Note that the use of \"typedef\" here is an extension to the TLS language, but its meaning should be relatively obvious. Also note that the [ size ] syntax defines a fixed-length element that does not include the length of the element in the on-the-wire encoding.",
      "ja": "NodeIdは、一連のバイトとして表される固定長の構造で、最上位バイトが最初です。長さは、オーバーレイごとに16〜20バイト（128〜160ビット）の範囲で設定されます。 （NodeIdLengthの設定方法については、セクション11.1を参照してください。）ここでの「typedef」の使用はTLS言語の拡張ですが、その意味は比較的明白であるはずです。また、[size]構文は固定長の要素を定義することに注意してください。この要素には、送信中の要素の長さが含まれていません。"
    },
    {
      "indent": 3,
      "text": "A ResourceId, shown below, represents a single Resource-ID.",
      "ja": "以下に示すResourceIdは、単一のResource-IDを表します。"
    },
    {
      "indent": 13,
      "text": "typedef opaque       ResourceId<0..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " Like a NodeId, a ResourceId is an opaque string of bytes, but unlike NodeIds, ResourceIds are variable length, up to 254 bytes (2040 bits) in length. On the wire, each ResourceId is preceded by a single length byte (allowing lengths up to 255 bytes). Thus, the 3-byte value \"FOO\" would be encoded as: 03 46 4f 4f. Note the < range > syntax defines a variable length element that includes the length of the element in the on-the-wire encoding. The number of bytes to encode the length on the wire is derived by range; i.e., it is the minimum number of bytes which can encode the largest range value.",
      "ja": "NodeIdと同様に、ResourceIdは不透明なバイト文字列ですが、NodeIdとは異なり、ResourceIdは可変長で、長さは最大254バイト（2040ビット）です。ネットワーク上では、各ResourceIdの前に単一の長さバイトが付きます（最大長は255バイトです）。したがって、3バイトの値「FOO」は03 46 4f 4fとしてエンコードされます。 <range>構文は、オンザワイヤエンコーディングの要素の長さを含む可変長要素を定義することに注意してください。ワイヤ上で長さをエンコードするバイト数は、範囲によって導出されます。つまり、最大範囲値をエンコードできる最小バイト数です。"
    },
    {
      "indent": 3,
      "text": "A more complicated example is IpAddressPort, which represents a network address and can be used to carry either an IPv6 or IPv4 address:",
      "ja": "より複雑な例はIpAddressPortです。これはネットワークアドレスを表し、IPv6またはIPv4アドレスを運ぶために使用できます。"
    },
    {
      "indent": 8,
      "text": "enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),\n     (255) } AddressType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  addr;\n  uint16                  port;\n} IPv4AddrPort;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  uint128                 addr;\n  uint16                  port;\n} IPv6AddrPort;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  AddressType             type;\n  uint8                   length;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "select (type) {\n  case ipv4_address:\n     IPv4AddrPort       v4addr_port;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case ipv6_address: IPv6AddrPort v6addr_port;",
      "ja": "case ipv6_address：IPv6AddrPort v6addr_port;"
    },
    {
      "indent": 8,
      "text": "    /* This structure can be extended */\n  };\n} IpAddressPort;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first two fields in the structure are the same no matter what kind of address is being represented:",
      "ja": "構造体の最初の2つのフィールドは、どのような種類の住所が表現されていても同じです。"
    },
    {
      "indent": 3,
      "text": "type: The type of address (IPv4 or IPv6).",
      "ja": "type：アドレスのタイプ（IPv4またはIPv6）。"
    },
    {
      "indent": 3,
      "text": "length: The length of the rest of the structure.",
      "ja": "length：構造の残りの長さ。"
    },
    {
      "indent": 3,
      "text": "By having the type and the length appear at the beginning of the structure regardless of the kind of address being represented, an implementation which does not understand new address type X can still parse the IpAddressPort field and then discard it if it is not needed.",
      "ja": "表現されるアドレスの種類に関係なく、タイプと長さを構造体の先頭に表示することにより、新しいアドレスタイプXを理解しない実装でも、IpAddressPortフィールドを解析し、不要な場合はそれを破棄できます。"
    },
    {
      "indent": 3,
      "text": "The rest of the IpAddressPort structure is either an IPv4AddrPort or an IPv6AddrPort. Both of these simply consist of an address represented as an integer and a 16-bit port. As an example, here is the wire representation of the IPv4 address \"192.0.2.1\" with port \"6084\".",
      "ja": "IpAddressPort構造の残りの部分は、IPv4AddrPortまたはIPv6AddrPortのいずれかです。これらは両方とも、整数として表されるアドレスと16ビットのポートで構成されます。例として、ポート「6084」を使用したIPv4アドレス「192.0.2.1」のワイヤー表現を次に示します。"
    },
    {
      "indent": 13,
      "text": "01           ; type    = IPv4\n06           ; length  = 6\nc0 00 02 01  ; address = 192.0.2.1\n17 c4        ; port    = 6084",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unless a given structure that uses a select explicitly allows for unknown types in the select, any unknown type SHOULD be treated as a parsing error, and the whole message SHOULD be discarded with no response.",
      "ja": "selectを使用する特定の構造がselectで不明なタイプを明示的に許可しない限り、不明なタイプは解析エラーとして扱われる必要があり（SHOULD）、メッセージ全体が応答なしで破棄される必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Forwarding Header",
      "section_title": true,
      "ja": "6.3.2. 転送ヘッダー"
    },
    {
      "indent": 3,
      "text": "The forwarding header is defined as a ForwardingHeader structure, as shown below.",
      "ja": "次に示すように、転送ヘッダーはForwardingHeader構造として定義されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32             relo_token;\n  uint32             overlay;\n  uint16             configuration_sequence;\n  uint8              version;\n  uint8              ttl;\n  uint32             fragment;\n  uint32             length;\n  uint64             transaction_id;\n  uint32             max_response_length;\n  uint16             via_list_length;\n  uint16             destination_list_length;\n  uint16             options_length;\n  Destination        via_list[via_list_length];\n  Destination        destination_list\n                       [destination_list_length];\n  ForwardingOption   options[options_length];\n} ForwardingHeader;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of the structure are:",
      "ja": "構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "relo_token: The first four bytes identify this message as a RELOAD message. This field MUST contain the value 0xd2454c4f (the string \"RELO\" with the high bit of the first byte set).",
      "ja": "relo_token：最初の4バイトは、このメッセージをRELOADメッセージとして識別します。このフィールドには、値0xd2454c4f（最初のバイトセットの上位ビットを含む文字列 \"RELO\"）を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "overlay: The 32-bit checksum/hash of the overlay being used. This MUST be formed by taking the lower 32 bits of the SHA-1 [RFC3174] hash of the overlay name. The purpose of this field is to allow nodes to participate in multiple overlays and to detect accidental misconfiguration. This is not a security-critical function. The overlay name MUST consist of a sequence of characters that would be allowable as a DNS name. Specifically, as it is used in a DNS lookup, it will need to be compliant with the grammar for the domain as specified in Section 2.3.1 of [RFC1035].",
      "ja": "overlay：使用されているオーバーレイの32ビットチェックサム/ハッシュ。これは、オーバーレイ名のSHA-1 [RFC3174]ハッシュの下位32ビットを使用して形成する必要があります。このフィールドの目的は、ノードが複数のオーバーレイに参加できるようにし、偶発的な設定ミスを検出することです。これはセキュリティ上重要な機能ではありません。オーバーレイ名は、DNS名として許可される一連の文字で構成する必要があります。具体的には、DNSルックアップで使用されるため、[RFC1035]のセクション2.3.1で指定されているドメインの文法に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "configuration_sequence: The sequence number of the configuration file. See Section 6.3.2.1 for details.",
      "ja": "configuration_sequence：構成ファイルのシーケンス番号。詳細については、6.3.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "version: The version of the RELOAD protocol being used times 10. RELOAD version numbers are fixed-point decimal numbers between fixed-point integer between 0.1 and 25.4. This document describes version 1.0, with a value of 0x0a. (Note that versions used prior to the publication of this RFC used version number 0.1.) Nodes MUST reject messages with other versions.",
      "ja": "version：使用されているRELOADプロトコルのバージョン。10回。RELOADバージョン番号は、0.1から25.4までの固定小数点整数の間の固定小数点10進数です。このドキュメントでは、値が0x0aのバージョン1.0について説明します。 （このRFCの公開前に使用されていたバージョンはバージョン番号0.1を使用したことに注意してください。）ノードは他のバージョンのメッセージを拒否しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "ttl: An 8-bit field indicating the number of iterations, or hops, a message can experience before it is discarded. The TTL (time-to-live) value MUST be decremented by one at every hop along the route the message traverses just before transmission. If a received message has a TTL of 0 and the message is not destined for the receiving node, then the message MUST NOT be propagated further, and an Error_TTL_Exceeded error should be generated. The initial value of the TTL SHOULD be 100 and MUST NOT exceed 100 unless defined otherwise by the overlay configuration. Implementations which receive messages with a TTL greater than the current value of initial-ttl (or the default of 100) MUST discard the message and send an Error_TTL_Exceeded error.",
      "ja": "ttl：メッセージが破棄される前に発生する可能性のある反復またはホップの数を示す8ビットのフィールド。 TTL（存続時間）値は、メッセージが送信の直前に通過するルートに沿ったホップごとに1ずつ減らされなければなりません（MUST）。受信したメッセージのTTLが0であり、メッセージの宛先が受信ノードではない場合は、メッセージをさらに伝播してはならず、Error_TTL_Exceededエラーが生成されます。 TTLの初期値は100である必要があり（SHOULD）、オーバーレイ構成で特に定義されていない限り、100を超えてはなりません。 initial-ttlの現在の値（またはデフォルトの100）より大きいTTLを持つメッセージを受信する実装は、メッセージを破棄し、Error_TTL_Exceededエラーを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "fragment: This field is used to handle fragmentation. The high bit (0x80000000) MUST be set for historical reasons. If the next bit (0x40000000) is set to 1, it indicates that this is the last (or only) fragment. The next six bits (0x20000000 through 0x01000000) are reserved and SHOULD be set to zero. The remainder of the field is used to indicate the fragment offset; see Section 6.7 for details.",
      "ja": "fragment：このフィールドは、断片化を処理するために使用されます。歴史的な理由により、上位ビット（0x80000000）を設定する必要があります。次のビット（0x40000000）が1に設定されている場合は、これが最後の（または唯一の）フラグメントであることを示しています。次の6ビット（0x20000000〜0x01000000）は予約されており、ゼロに設定する必要があります（SHOULD）。フィールドの残りの部分は、フラグメントのオフセットを示すために使用されます。詳細については、セクション6.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "length: The count in bytes of the size of the message, including the header, after the eventual fragmentation.",
      "ja": "length：最終的な断片化後の、ヘッダーを含むメッセージのサイズのバイト数。"
    },
    {
      "indent": 3,
      "text": "transaction_id: A unique 64-bit number that identifies this transaction and also allows receivers to disambiguate transactions which are otherwise identical. In order to provide a high probability that transaction IDs are unique, they MUST be randomly generated. Responses use the same transaction ID as the request to which they correspond. Transaction IDs are also used for fragment reassembly. See Section 6.7 for details.",
      "ja": "transaction_id：このトランザクションを識別する一意の64ビット番号。受信者が他の点では同一のトランザクションを明確化することもできます。トランザクションIDが一意である可能性を高くするには、ランダムに生成する必要があります。応答は、対応する要求と同じトランザクションIDを使用します。トランザクションIDはフラグメントの再構成にも使用されます。詳細については、セクション6.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "max_response_length: The maximum size in bytes of a response. This is used by requesting nodes to avoid receiving (unexpected) very large responses. If this value is non-zero, responding peers MUST check that any response would not exceed it and if so generate an Error_Incompatible_with_Overlay value. This value SHOULD be set to zero for responses.",
      "ja": "max_response_length：応答の最大サイズ（バイト単位）。これは、（予期しない）非常に大きな応答の受信を回避するためにノードを要求するときに使用されます。この値がゼロ以外の場合、応答するピアは、応答がそれを超えないことを確認する必要があり、超えた場合はError_Incompatible_with_Overlay値を生成する必要があります。この値は、応答に対してゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "via_list_length: The length of the Via List in bytes. Note that in this field and the following two length fields, we depart from the usual variable-length convention of having the length immediately precede the value, in order to make it easier for hardware decoding engines to quickly determine the length of the header.",
      "ja": "via_list_length：Viaリストの長さ（バイト単位）。このフィールドと次の2つの長さフィールドでは、ハードウェアデコードエンジンがヘッダーの長さをすばやく判別しやすくするために、値を直前に置くという通常の可変長規則から逸脱していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "destination_list_length: The length of the Destination List in bytes.",
      "ja": "destination_list_length：宛先リストの長さ（バイト単位）。"
    },
    {
      "indent": 3,
      "text": "options_length: The length of the header options in bytes.",
      "ja": "options_length：バイト単位のヘッダーオプションの長さ。"
    },
    {
      "indent": 3,
      "text": "via_list: The via_list contains the sequence of destinations through which the message has passed. The via_list starts out empty and grows as the message traverses each peer. In stateless cases, the previous hop that the message is from is appended to the Via List as specified in Section 6.1.2.",
      "ja": "via_list：via_listには、メッセージが通過した一連の宛先が含まれています。 via_listは空から始まり、メッセージが各ピアを通過するにつれて大きくなります。ステートレスの場合、セクション6.1.2で指定されているように、メッセージの元の前のホップがViaリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "destination_list: The destination_list contains a sequence of destinations through which the message should pass. The Destination List is constructed by the message originator. The first element on the Destination List is where the message goes next. Generally, the list shrinks as the message traverses each listed peer, though if list compression is used, this may not be true.",
      "ja": "destination_list：destination_listには、メッセージが通過する一連の宛先が含まれます。宛先リストは、メッセージの発信者が作成します。宛先リストの最初の要素は、メッセージが次に送られる場所です。通常、メッセージはリストされた各ピアを通過するときにリストが縮小しますが、リスト圧縮が使用されている場合、これは当てはまらない場合があります。"
    },
    {
      "indent": 3,
      "text": "options: Contains a series of ForwardingOption entries. See Section 6.3.2.3.",
      "ja": "options：一連のForwardingOptionエントリが含まれます。セクション6.3.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. Processing Configuration Sequence Numbers",
      "section_title": true,
      "ja": "6.3.2.1. 構成シーケンス番号の処理"
    },
    {
      "indent": 3,
      "text": "In order to be part of the overlay, a node MUST have a copy of the overlay Configuration Document. In order to allow for configuration document changes, each version of the Configuration Document MUST contain a sequence number which MUST be monotonically increasing mod 65535. Because the sequence number may, in principle, wrap, greater than or less than are interpreted by modulo arithmetic as in TCP.",
      "ja": "オーバーレイの一部となるためには、ノードはオーバーレイ構成ドキュメントのコピーを持っている必要があります。構成文書の変更を可能にするために、構成文書の各バージョンには、mod 65535を単調増加させる必要があるシーケンス番号が含まれている必要があります。 TCPで。"
    },
    {
      "indent": 3,
      "text": "When a destination node receives a request, it MUST check that the configuration_sequence field is equal to its own configuration sequence number. If they do not match, the node MUST generate an error, either Error_Config_Too_Old or Error_Config_Too_New. In addition, if the configuration file in the request is too old, the node MUST generate a ConfigUpdate message to update the requesting node. This allows new Configuration Documents to propagate quickly throughout the system. The one exception to this rule is that if the configuration_sequence field is equal to 65535 and the message type is ConfigUpdate, then the message MUST be accepted regardless of the receiving node's configuration sequence number. Since 65535 is a special value, peers sending a new configuration when the configuration sequence is currently 65534 MUST set the configuration sequence number to 0 when they send a new configuration.",
      "ja": "宛先ノードがリクエストを受信すると、configuration_sequenceフィールドが自身の設定シーケンス番号と等しいことを確認する必要があります。それらが一致しない場合、ノードはError_Config_Too_OldまたはError_Config_Too_Newのいずれかのエラーを生成する必要があります。さらに、リクエスト内の設定ファイルが古すぎる場合、ノードはConfigUpdateメッセージを生成してリクエストノードを更新する必要があります。これにより、新しい構成文書をシステム全体に迅速に伝達できます。このルールの1つの例外は、configuration_sequenceフィールドが65535で、メッセージタイプがConfigUpdateの場合、受信ノードの構成シーケンス番号に関係なく、メッセージを受け入れる必要があることです。 65535は特別な値なので、構成シーケンスが現在65534であるときに新しい構成を送信するピアは、新しい構成を送信するときに構成シーケンス番号を0に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.2.2. Destination and Via Lists",
      "section_title": true,
      "ja": "6.3.2.2. 宛先および経由リスト"
    },
    {
      "indent": 3,
      "text": "The Destination List and Via List are sequences of Destination values:",
      "ja": "宛先リストと経由リストは、宛先値のシーケンスです。"
    },
    {
      "indent": 5,
      "text": "enum { invalidDestinationType(0), node(1), resource(2),\n       opaque_id_type(3), /* 128-255 not allowed */ (255) }\n     DestinationType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "select (destination_type) {\n case node:\n        NodeId               node_id;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "case resource: ResourceId resource_id;",
      "ja": "ケースリソース：ResourceId resource_id;"
    },
    {
      "indent": 6,
      "text": "case opaque_id_type:\n       opaque               opaque_id<0..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "     /* This structure may be extended with new types */\n} DestinationData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "struct {\n   DestinationType         type;\n   uint8                   length;\n   DestinationData         destination_data;\n} Destination;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "struct {\n   uint16               opaque_id; /* Top bit MUST be 1 */\n} Destination;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the destination structure is a 16-bit integer, then the first bit MUST be set to 1, and it MUST be treated as if it were a full structure with a DestinationType of opaque_id_type and an opaque_id that was 2 bytes long with the value of the 16-bit integer. If the destination structure starts with DestinationType, then the first bit MUST be set to 0, and the destination structure must use a TLV structure with the following contents:",
      "ja": "宛先構造が16ビット整数の場合、最初のビットを1に設定する必要があり、DestinationTypeがopaque_id_typeで、長さが2バイトのopaque_idの完全な構造であるかのように処理する必要があります。 16ビット整数。宛先構造がDestinationTypeで始まる場合、最初のビットは0に設定する必要があり、宛先構造は次の内容のTLV構造を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "type The type of the DestinationData Payload Data Unit (PDU). It may be one of \"node\", \"resource\", or \"opaque_id_type\".",
      "ja": "type DestinationData Payload Data Unit（PDU）のタイプ。 「node」、「resource」、または「opaque_id_type」のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "length The length of the destination_data.",
      "ja": "length destination_dataの長さ。"
    },
    {
      "indent": 3,
      "text": "destination_data The destination value itself, which is an encoded DestinationData structure that depends on the value of \"type\".",
      "ja": "destination_data「type」の値に依存するエンコードされたDestinationData構造である宛先値自体。"
    },
    {
      "indent": 3,
      "text": "Note that the destination structure encodes a Type, Length, Value. The Length field specifies the length of the DestinationData values, which allows the addition of new DestinationTypes. It also allows an implementation which does not understand a given DestinationType to skip over it.",
      "ja": "宛先構造は、タイプ、長さ、値をエンコードすることに注意してください。 Lengthフィールドは、DestinationData値の長さを指定します。これにより、新しいDestinationTypesを追加できます。また、特定のDestinationTypeを理解しない実装でスキップすることもできます。"
    },
    {
      "indent": 3,
      "text": "A DestinationData can be one of three types:",
      "ja": "DestinationDataは、次の3つのタイプのいずれかになります。"
    },
    {
      "indent": 3,
      "text": "node A Node-ID.",
      "ja": "ので あ のでーいＤ。"
    },
    {
      "indent": 3,
      "text": "opaque A compressed list of Node-IDs and an eventual Resource-ID. Because this value has been compressed by one of the peers, it is meaningful only to that peer and cannot be decoded by other peers. Thus, it is represented as an opaque string.",
      "ja": "opaqueノードIDと最終的なリソースIDの圧縮リスト。この値はピアの1つによって圧縮されているため、そのピアに対してのみ意味があり、他のピアによってデコードすることはできません。したがって、それは不透明な文字列として表されます。"
    },
    {
      "indent": 3,
      "text": "resource The Resource-ID of the resource which is desired. This type MUST appear only in the final location of a Destination List and MUST NOT appear in a Via List. It is meaningless to try to route through a resource.",
      "ja": "resource必要なリソースのResource-ID。このタイプは、宛先リストの最終的な場所にのみ出現する必要があり、経由リストに出現してはなりません。リソースを介してルーティングしようとしても意味がありません。"
    },
    {
      "indent": 3,
      "text": "One possible encoding of the 16-bit integer version as an opaque identifier is to encode an index into a Connection Table. To avoid misrouting responses in the event a response is delayed and the Connection Table entry has changed, the identifier SHOULD be split between an index and a generation counter for that index. When a Node first joins the overlay, the generation counters SHOULD be initialized to random values. An implementation MAY use 12 bits for the Connection Table index and 3 bits for the generation counter. (Note that this does not suggest a 4096-entry Connection Table for every peer, only the ability to encode for a larger Connection Table.) When a Connection Table slot is used for a new connection, the generation counter is incremented (with wrapping). Connection Table slots are used on a rotating basis to maximize the time interval between uses of the same slot for different connections. When routing a message to an entry in the Destination List encoding a Connection Table entry, the peer MUST confirm that the generation counter matches the current generation counter of that index before forwarding the message. If it does not match, the message MUST be silently dropped.",
      "ja": "不透明な識別子としての16ビット整数バージョンの可能なエンコードの1つは、インデックスを接続テーブルにエンコードすることです。応答が遅延し、接続テーブルのエントリが変更された場合に応答を誤ってルーティングしないようにするには、識別子をインデックスとそのインデックスの生成カウンタの間で分割する必要があります（SHOULD）。ノードが最初にオーバーレイに参加するとき、生成カウンターはランダムな値に初期化されるべきです（SHOULD）。実装は、接続テーブルインデックスに12ビットを使用し、生成カウンターに3ビットを使用する場合があります。 （これは、すべてのピアに対して4096エントリの接続テーブルを提案するのではなく、より大きな接続テーブルをエンコードする機能のみを示唆していることに注意してください。）接続テーブルスロットが新しい接続に使用されると、生成カウンターが増分されます（ラップあり）。 。接続テーブルスロットは、異なる接続で同じスロットを使用する時間間隔を最大化するために、循環的に使用されます。接続テーブルエントリをエンコードする宛先リストのエントリにメッセージをルーティングする場合、ピアは、メッセージを転送する前に、生成カウンターがそのインデックスの現在の生成カウンターと一致することを確認する必要があります。それが一致しない場合、メッセージは静かに落とされなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.2.3. Forwarding Option",
      "section_title": true,
      "ja": "6.3.2.3. 転送オプション"
    },
    {
      "indent": 3,
      "text": "The Forwarding header can be extended with forwarding header options, which are a series of ForwardingOption structures:",
      "ja": "Forwardingヘッダーは、一連のForwardingOption構造であるForwardingヘッダーオプションで拡張できます。"
    },
    {
      "indent": 4,
      "text": "enum { invalidForwardingOptionType(0), (255) }\n  ForwardingOptionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "struct {\n  ForwardingOptionType      type;\n  uint8                     flags;\n  uint16                    length;\n  select (type) {\n        /* This type may be extended */\n  };\n} ForwardingOption;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each ForwardingOption consists of the following values:",
      "ja": "各ForwardingOptionは、次の値で構成されています。"
    },
    {
      "indent": 3,
      "text": "type The type of the option. This structure allows for unknown options types.",
      "ja": "typeオプションのタイプ。この構造では、不明なオプションタイプを使用できます。"
    },
    {
      "indent": 3,
      "text": "flags Three flags are defined: FORWARD_CRITICAL(0x01), DESTINATION_CRITICAL(0x02), and RESPONSE_COPY(0x04). These flags MUST NOT be set in a response. If the FORWARD_CRITICAL flag is set, any peer that would forward the message but does not understand this option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the DESTINATION_CRITICAL flag is set, any node that generates a response to the message but does not understand the forwarding option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the RESPONSE_COPY flag is set, any node generating a response MUST copy the option from the request to the response except that the RESPONSE_COPY, FORWARD_CRITICAL, and DESTINATION_CRITICAL flags MUST be cleared.",
      "ja": "flags 3つのフラグが定義されています：FORWARD_CRITICAL（0x01）、DESTINATION_CRITICAL（0x02）、およびRESPONSE_COPY（0x04）。これらのフラグは、応答で設定してはいけません。 FORWARD_CRITICALフラグが設定されている場合、メッセージを転送するがこのオプションを理解していないピアは、Error_Unsupported_Forwarding_Optionエラー応答で要求を拒否する必要があります。 DESTINATION_CRITICALフラグが設定されている場合、メッセージへの応答を生成するが転送オプションを理解していないノードは、Error_Unsupported_Forwarding_Optionエラー応答で要求を拒否する必要があります。 RESPONSE_COPYフラグが設定されている場合、RESPONSE_COPY、FORWARD_CRITICAL、およびDESTINATION_CRITICALフラグをクリアする必要があることを除いて、応答を生成するノードはオプションを要求から応答にコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "length The length of the rest of the structure. Note that a 0 length may be reasonable if the mere presence of the option is meaningful and no value is required.",
      "ja": "length構造の残りの長さ。オプションが存在するだけで意味があり、値が不要な場合は、長さ0が妥当な場合があります。"
    },
    {
      "indent": 3,
      "text": "option The option value.",
      "ja": "optionオプションの値。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Message Contents Format",
      "section_title": true,
      "ja": "6.3.3. メッセージ内容フォーマット"
    },
    {
      "indent": 3,
      "text": "The second major part of a RELOAD message is the contents part, which is defined by MessageContents:",
      "ja": "RELOADメッセージの2番目の主要部分はコンテンツ部分であり、MessageContentsによって定義されます。"
    },
    {
      "indent": 3,
      "text": "enum { invalidMessageExtensionType(0),\n       (2^16-1) } MessageExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n  MessageExtensionType  type;\n  Boolean               critical;\n  opaque                extension_contents<0..2^32-1>;\n} MessageExtension;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n  uint16                 message_code;\n  opaque                 message_body<0..2^32-1>;\n  MessageExtension       extensions<0..2^32-1>;\n} MessageContents;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "message_code This indicates the message that is being sent. The code space is broken up as follows:",
      "ja": "message_codeこれは、送信されているメッセージを示します。コードスペースは次のように分割されます。"
    },
    {
      "indent": 6,
      "text": "0x0 Invalid Message Code. This code will never be assigned.",
      "ja": "0x0無効なメッセージコード。このコードは割り当てられません。"
    },
    {
      "indent": 6,
      "text": "0x1 .. 0x7FFF Requests and responses. These code points are always paired, with requests being an odd value and the corresponding response being the request code plus 1. Thus, \"probe_request\" (the Probe request) has the value 1 and \"probe_answer\" (the Probe response) has the value 2",
      "ja": "0x1 .. 0x7FFF要求と応答。これらのコードポイントは常にペアになっており、要求は奇数の値であり、対応する応答は要求コードに1を加えたものです。したがって、「probe_request」（プローブ要求）の値は1で、「probe_answer」（プローブ応答）の値は2"
    },
    {
      "indent": 6,
      "text": "0x8000 .. 0xFFFE Reserved",
      "ja": "0x8000 .. 0xFFFE予約済み"
    },
    {
      "indent": 6,
      "text": "0xFFFF Error",
      "ja": "0xFFFFエラー"
    },
    {
      "indent": 6,
      "text": "The message codes are defined in Section 14.8.",
      "ja": "メッセージコードはセクション14.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "message_body The message body itself, represented as a variable-length string of bytes. The bytes themselves are dependent on the code value. See the sections describing the various RELOAD methods (Join, Update, Attach, Store, Fetch, etc.) for the definitions of the payload contents.",
      "ja": "message_body可変長のバイト文字列として表されるメッセージ本文自体。バイト自体はコード値に依存します。ペイロードの内容の定義については、さまざまなRELOADメソッド（結合、更新、接続、保存、フェッチなど）を説明するセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "extensions Extensions to the message. Currently no extensions are defined, but new extensions can be defined by the process described in Section 14.14.",
      "ja": "メッセージの拡張子。現在、拡張機能は定義されていませんが、セクション14.14で説明されているプロセスで新しい拡張機能を定義できます。"
    },
    {
      "indent": 3,
      "text": "All extensions have the following form:",
      "ja": "すべての拡張機能の形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "type The extension type.",
      "ja": "type拡張タイプ。"
    },
    {
      "indent": 3,
      "text": "critical Whether this extension needs to be understood in order to process the message. If critical = True and the recipient does not understand the message, it MUST generate an Error_Unknown_Extension error. If critical = False, the recipient MAY choose to process the message even if it does not understand the extension.",
      "ja": "重要メッセージを処理するために、この拡張機能を理解する必要があるかどうか。 critical = Trueであり、受信者がメッセージを理解できない場合は、Error_Unknown_Extensionエラーを生成する必要があります。 critical = Falseの場合、受信者は、拡張子を理解していなくても、メッセージを処理することを選択できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "extension_contents The contents of the extension (which are extension dependent).",
      "ja": "extension_contents拡張機能のコンテンツ（拡張機能に依存）。"
    },
    {
      "indent": 3,
      "text": "The subsections 6.4.2, 6.5, and 7 describe structures that are inserted inside the message_body member, depending on the value of the message_code value. For example, a message_code value of join_req means that the structure named JoinReq is inserted inside message_body. This document does not contain a mapping between message_code values and structure names, as the conversion between the two is obvious.",
      "ja": "サブセクション6.4.2、6.5、および7では、message_code値の値に応じて、message_bodyメンバー内に挿入される構造について説明します。たとえば、join_reqのmessage_code値は、JoinReqという名前の構造がmessage_body内に挿入されることを意味します。このドキュメントには、2つの間の変換が明らかであるため、message_code値と構造体名の間のマッピングは含まれていません。"
    },
    {
      "indent": 3,
      "text": "Similarly, this document uses the name of the structure without the \"Req\" or \"Ans\" suffix to mean the execution of a transaction consisting of the matching request and answer. For example, when the text says \"perform an Attach\", it must be understood as performing a transaction composed of an AttachReq and an AttachAns.",
      "ja": "同様に、このドキュメントでは、 \"Req\"または \"Ans\"サフィックスのない構造の名前を使用して、一致する要求と応答で構成されるトランザクションの実行を意味します。たとえば、「アタッチを実行してください」というテキストは、AttachReqとAttachAnsで構成されるトランザクションを実行するものとして理解する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.3.1. Response Codes and Response Errors",
      "section_title": true,
      "ja": "6.3.3.1. 応答コードと応答エラー"
    },
    {
      "indent": 3,
      "text": "A node processing a request MUST return its status in the message_code field. If the request was a success, then the message code MUST be set to the response code that matches the request (i.e., the next code up). The response payload is then as defined in the request/response descriptions.",
      "ja": "リクエストを処理するノードは、そのステータスをmessage_codeフィールドに返さなければなりません（MUST）。リクエストが成功した場合、メッセージコードはリクエストに一致するレスポンスコードに設定する必要があります（つまり、次のコード）。応答ペイロードは、要求/応答の説明で定義されているとおりになります。"
    },
    {
      "indent": 3,
      "text": "If the request has failed, then the message code MUST be set to 0xffff (error) and the payload MUST be an error_response message, as shown below.",
      "ja": "要求が失敗した場合、メッセージコードは0xffff（エラー）に設定する必要があり、ペイロードは以下に示すようにerror_responseメッセージである必要があります。"
    },
    {
      "indent": 3,
      "text": "When the message code is 0xFFFF, the payload MUST be an ErrorResponse:",
      "ja": "メッセージコードが0xFFFFの場合、ペイロードはErrorResponseである必要があります。"
    },
    {
      "indent": 9,
      "text": "public struct {\n  uint16             error_code;\n  opaque             error_info<0..2^16-1>;\n} ErrorResponse;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "error_code A numeric error code indicating the error that occurred.",
      "ja": "error_code発生したエラーを示す数値エラーコード。"
    },
    {
      "indent": 3,
      "text": "error_info An optional arbitrary byte string. Unless otherwise specified, this will be a UTF-8 text string that provides further information about what went wrong. Developers are encouraged to include enough diagnostic information to be useful in error_info. The specific text to be used and any relevant language or encoding thereof is left to the implementation.",
      "ja": "error_infoオプションの任意のバイト文字列。特に明記されていない限り、これはUTF-8テキスト文字列であり、何が問題だったかに関する詳細情報を提供します。開発者は、error_infoで役立つのに十分な診断情報を含めることをお勧めします。使用する特定のテキストと関連する言語またはそのエンコーディングは、実装に任されています。"
    },
    {
      "indent": 3,
      "text": "The following error code values are defined. The numeric values for these are defined in Section 14.9.",
      "ja": "以下のエラーコード値が定義されています。これらの数値はセクション14.9で定義されています。"
    },
    {
      "indent": 3,
      "text": "Error_Forbidden The requesting node does not have permission to make this request.",
      "ja": "Error_Forbidden要求元ノードには、この要求を行う権限がありません。"
    },
    {
      "indent": 3,
      "text": "Error_Not_Found The resource or node cannot be found or does not exist.",
      "ja": "Error_Not_Foundリソースまたはノードが見つからないか、存在しません。"
    },
    {
      "indent": 3,
      "text": "Error_Request_Timeout A response to the request has not been received in a suitable amount of time. The requesting node MAY resend the request at a later time.",
      "ja": "Error_Request_Timeoutリクエストへの応答が適切な時間内に受信されませんでした。要求側ノードは、後で要求を再送信してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Error_Data_Too_Old A store cannot be completed because the storage_time precedes the existing value.",
      "ja": "Error_Data_Too_Old storage_timeが既存の値の前にあるため、ストアを完了できません。"
    },
    {
      "indent": 3,
      "text": "Error_Data_Too_Large A store cannot be completed because the requested object exceeds the size limits for that Kind.",
      "ja": "Error_Data_Too_Large要求されたオブジェクトがその種類のサイズ制限を超えているため、ストアを完了できません。"
    },
    {
      "indent": 3,
      "text": "Error_Generation_Counter_Too_Low A store cannot be completed because the generation counter precedes the existing value.",
      "ja": "Error_Generation_Counter_Too_Low生成カウンターが既存の値の前にあるため、ストアを完了できません。"
    },
    {
      "indent": 3,
      "text": "Error_Incompatible_with_Overlay A peer receiving the request is using a different overlay, overlay algorithm, or hash algorithm, or some other parameter that is inconsistent with the overlay configuration.",
      "ja": "Error_Incompatible_with_Overlay要求を受信するピアが、異なるオーバーレイ、オーバーレイアルゴリズム、ハッシュアルゴリズム、またはオーバーレイ構成と矛盾するその他のパラメーターを使用しています。"
    },
    {
      "indent": 3,
      "text": "Error_Unsupported_Forwarding_Option A node received the request with a forwarding options flagged as critical, but the node does not support this option. See Section 6.3.2.3.",
      "ja": "Error_Unsupported_Forwarding_Optionノードは、クリティカルのフラグが設定された転送オプションを含む要求を受信しましたが、ノードはこのオプションをサポートしていません。セクション6.3.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_TTL_Exceeded A peer received the request in which the TTL was decremented to zero. See Section 6.3.2.",
      "ja": "Error_TTL_Exceededピアが、TTLがゼロにデクリメントされた要求を受信しました。セクション6.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Message_Too_Large A peer received a request that was too large. See Section 6.6.",
      "ja": "Error_Message_Too_Largeピアが大きすぎるリクエストを受信しました。セクション6.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Response_Too_Large A node would have generated a response that is too large per the max_response_length field.",
      "ja": "Error_Response_Too_Largeノードがmax_response_lengthフィールドごとに大きすぎる応答を生成した可能性があります。"
    },
    {
      "indent": 3,
      "text": "Error_Config_Too_Old A destination node received a request with a configuration sequence that is too old. See Section 6.3.2.1.",
      "ja": "Error_Config_Too_Old宛先ノードが、構成シーケンスが古すぎる要求を受け取りました。セクション6.3.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Config_Too_New A destination node received a request with a configuration sequence that is too new. See Section 6.3.2.1.",
      "ja": "Error_Config_Too_New宛先ノードが、あまりにも新しい構成シーケンスの要求を受け取りました。セクション6.3.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Unknown_Kind A destination peer received a request with an unknown Kind-ID. See Section 7.4.1.2.",
      "ja": "Error_Unknown_Kind宛先ピアが不明な種類IDの要求を受信しました。セクション7.4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_In_Progress An Attach to this peer is already in progress. See Section 6.5.1.2.",
      "ja": "Error_In_Progressこのピアへの接続はすでに進行中です。セクション6.5.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Unknown_Extension A destination node received a request with an unknown extension.",
      "ja": "Error_Unknown_Extension宛先ノードが不明な拡張子を持つ要求を受け取りました。"
    },
    {
      "indent": 3,
      "text": "Error_Invalid_Message Something about this message is invalid, but it does not fit the other error codes. When this message is sent, implementations SHOULD provide some meaningful description in error_info to aid in debugging.",
      "ja": "Error_Invalid_Messageこのメッセージに関する何かが無効ですが、他のエラーコードに適合しません。このメッセージが送信されると、実装はデバッグを支援するためにerror_infoに意味のある説明を提供する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Error_Exp_A For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.",
      "ja": "Error_Exp_A実験を目的としています。これは、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Error_Exp_B For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.",
      "ja": "Error_Exp_B実験を目的としています。これは、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Security Block",
      "section_title": true,
      "ja": "6.3.4. セキュリティブロック"
    },
    {
      "indent": 3,
      "text": "The third part of a RELOAD message is the security block. The security block is represented by a SecurityBlock structure:",
      "ja": "RELOADメッセージの3番目の部分はセキュリティブロックです。セキュリティブロックはSecurityBlock構造で表されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n   CertificateType     type;   // From RFC 6091\n   opaque              certificate<0..2^16-1>;\n} GenericCertificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n   GenericCertificate certificates<0..2^16-1>;\n   Signature          signature;\n} SecurityBlock;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "certificates A bucket of certificates.",
      "ja": "証明書証明書のバケット。"
    },
    {
      "indent": 3,
      "text": "signature A signature.",
      "ja": "署名署名。"
    },
    {
      "indent": 3,
      "text": "The certificates bucket SHOULD contain all the certificates necessary to verify every signature in both the message and the internal message objects, except for those certificates in a root-cert element of the current configuration file. This is the only location in the message which contains certificates, thus allowing only a single copy of each certificate to be sent. In systems that have an alternative certificate distribution mechanism, some certificates MAY be omitted. However, unless an alternative mechanism for immediately generating certificates, such as shared secret security (Section 13.4) is used, implementers MUST include all referenced certificates.",
      "ja": "証明書バケットには、現在の構成ファイルのroot-cert要素にある証明書を除き、メッセージオブジェクトと内部メッセージオブジェクトの両方のすべての署名を検証するために必要なすべての証明書を含める必要があります（SHOULD）。これは、証明書を含むメッセージ内の唯一の場所であるため、各証明書のコピーを1つだけ送信できます。代替の証明書配布メカニズムを持つシステムでは、一部の証明書が省略される場合があります。ただし、共有シークレットセキュリティ（セクション13.4）など、証明書を即座に生成するための代替メカニズムを使用しない限り、実装者はすべての参照証明書を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE TO IMPLEMENTERS: This requirement implies that a peer storing data is obligated to retain certificates for the data that it holds.",
      "ja": "実装者への注記：この要件は、データを格納するピアが、保持するデータの証明書を保持する義務があることを意味します。"
    },
    {
      "indent": 3,
      "text": "Each certificate is represented by a GenericCertificate structure, which has the following contents:",
      "ja": "各証明書はGenericCertificate構造で表され、次の内容があります。"
    },
    {
      "indent": 3,
      "text": "type The type of the certificate, as defined in [RFC6091]. Only the use of X.509 certificates is defined in this document.",
      "ja": "type [RFC6091]で定義されている証明書のタイプ。このドキュメントでは、X.509証明書の使用のみが定義されています。"
    },
    {
      "indent": 3,
      "text": "certificate The encoded version of the certificate. For X.509 certificates, it is the Distinguished Encoding Rules (DER) form.",
      "ja": "証明書のエンコードされたバージョン。 X.509証明書の場合、これはDistinguished Encoding Rules（DER）フォームです。"
    },
    {
      "indent": 3,
      "text": "The signature is computed over the payload and parts of the forwarding header. In case of a Store, the payload MUST contain an additional signature computed as described in Section 7.1. All signatures MUST be formatted using the Signature element. This element is also used in other contexts where signatures are needed. The input structure to the signature computation MAY vary depending on the data element being signed.",
      "ja": "署名は、ペイロードと転送ヘッダーの一部に対して計算されます。ストアの場合、ペイロードにはセクション7.1で説明されているように計算された追加の署名が含まれている必要があります。すべての署名は、Signature要素を使用してフォーマットする必要があります。この要素は、署名が必要な他のコンテキストでも使用されます。署名計算への入力構造は、署名されるデータ要素によって異なる場合があります。"
    },
    {
      "indent": 5,
      "text": "enum { invalidSignerIdentityType(0),\n       cert_hash(1), cert_hash_node_id(2),\n       none(3)\n       (255) } SignerIdentityType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "struct {\n  select (identity_type) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "case cert_hash;\n  HashAlgorithm      hash_alg;              // From TLS\n  opaque             certificate_hash<0..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "case cert_hash_node_id:\n  HashAlgorithm      hash_alg;              // From TLS\n  opaque             certificate_node_id_hash<0..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    case none:\n      /* empty */\n    /* This structure may be extended with new types if necessary*/\n  };\n} SignerIdentityValue;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "struct {\n  SignerIdentityType     identity_type;\n  uint16                 length;\n  SignerIdentityValue    identity[SignerIdentity.length];\n} SignerIdentity;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "struct {\n   SignatureAndHashAlgorithm     algorithm;   // From TLS\n   SignerIdentity                identity;\n   opaque                        signature_value<0..2^16-1>;\n} Signature;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Signature construct contains the following values:",
      "ja": "Signature構成には、次の値が含まれます。"
    },
    {
      "indent": 3,
      "text": "algorithm The signature algorithm in use. The algorithm definitions are found in the IANA TLS SignatureAlgorithm and HashAlgorithm registries. All implementations MUST support RSASSA-PKCS1-v1_5 [RFC3447] signatures with SHA-256 hashes [RFC6234].",
      "ja": "algorithm使用中の署名アルゴリズム。アルゴリズムの定義は、IANA TLS SignatureAlgorithmおよびHashAlgorithmレジストリにあります。すべての実装は、SHA-256ハッシュを使用したRSASSA-PKCS1-v1_5 [RFC3447]署名をサポートする必要があります[RFC6234]。"
    },
    {
      "indent": 3,
      "text": "identity The identity, as defined in the two paragraphs following this list, used to form the signature.",
      "ja": "identityこのリストに続く2つの段落で定義されている、署名の形成に使用されるID。"
    },
    {
      "indent": 3,
      "text": "signature_value The value of the signature.",
      "ja": "signature_value署名の値。"
    },
    {
      "indent": 6,
      "text": "Note that storage operations allow for special values of algorithm and identity. See the Store Request definition (Section 7.4.1.1) and the Fetch Response definition (Section 7.4.2.2).",
      "ja": "ストレージ操作では、アルゴリズムとIDの特別な値が許可されることに注意してください。 Store Request定義（セクション7.4.1.1）およびFetch Response定義（セクション7.4.2.2）を参照してください。"
    },
    {
      "indent": 3,
      "text": "There are two permitted identity formats, one for a certificate with only one Node-ID and one for a certificate with multiple Node-IDs. In the first case, the cert_hash type MUST be used. The hash_alg field is used to indicate the algorithm used to produce the hash. The certificate_hash contains the hash of the certificate object (i.e., the DER-encoded certificate).",
      "ja": "許可されるID形式は2つあります。1つはノードIDが1つだけの証明書用で、もう1つは複数のノードIDを持つ証明書用です。最初のケースでは、cert_hashタイプを使用する必要があります。 hash_algフィールドは、ハッシュの生成に使用されるアルゴリズムを示すために使用されます。 certificate_hashには、証明書オブジェクト（つまり、DERでエンコードされた証明書）のハッシュが含まれています。"
    },
    {
      "indent": 3,
      "text": "In the second case, the cert_hash_node_id type MUST be used. The hash_alg is as in cert_hash, but the cert_hash_node_id is computed over the NodeId used to sign concatenated with the certificate; i.e., H(NodeId || certificate). The NodeId is represented without any framing or length fields, as simple raw bytes. This is safe because NodeIds are a fixed length for a given overlay.",
      "ja": "2番目のケースでは、cert_hash_node_idタイプを使用する必要があります。 hash_algはcert_hashと同様ですが、cert_hash_node_idは、証明書と連結された署名に使用されるNodeIdに対して計算されます。つまり、H（NodeId || certificate）です。 NodeIdは、フレーミングまたは長さフィールドなしで、単純な未加工バイトとして表されます。 NodeIdは特定のオーバーレイの固定長であるため、これは安全です。"
    },
    {
      "indent": 3,
      "text": "For signatures over messages, the input to the signature is computed over:",
      "ja": "メッセージの署名の場合、署名への入力は次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "overlay || transaction_id || MessageContents || SignerIdentity",
      "ja": "オーバーレイ|| transaction_id || MessageContents || SignerIdentity"
    },
    {
      "indent": 3,
      "text": "where overlay and transaction_id come from the forwarding header and || indicates concatenation.",
      "ja": "ここで、overlayとtransaction_idは転送ヘッダーと||から取得されます。連結を示します。"
    },
    {
      "indent": 3,
      "text": "The input to signatures over data values is different and is described in Section 7.1.",
      "ja": "データ値に対する署名への入力は異なり、セクション7.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "All RELOAD messages MUST be signed. Intermediate nodes do not verify signatures. Upon receipt (and fragment reassembly, if needed), the destination node MUST verify the signature and the authorizing certificate. If the signature fails, the implementation SHOULD simply drop the message and MUST NOT process it. This check provides a minimal level of assurance that the sending node is a valid part of the overlay, and it provides cryptographic authentication of the sending node. In addition, responses MUST be checked as follows by the requesting node:",
      "ja": "すべてのRELOADメッセージは署名する必要があります。中間ノードは署名を検証しません。受信後（必要に応じてフラグメントの再構成）、宛先ノードは署名と認証証明書を検証する必要があります。署名が失敗した場合、実装は単にメッセージをドロップし、それを処理してはならない（MUST NOT）。このチェックは、送信ノードがオーバーレイの有効な部分であることを最小限のレベルで保証し、送信ノードの暗号認証を提供します。さらに、応答は要求ノードによって次のようにチェックされる必要があります："
    },
    {
      "indent": 3,
      "text": "1. The response to a message sent to a Node-ID MUST have been sent by that Node-ID unless the response has been sent to the wildcard Node-ID.",
      "ja": "1. ノードIDに送信されたメッセージへの応答は、ワイルドカードノードIDに応答が送信されていない限り、そのノードIDによって送信されている必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The response to a message sent to a Resource-ID MUST have been sent by a Node-ID which is at least as close to the target Resource-ID as any node in the requesting node's Neighbor Table.",
      "ja": "2. Resource-IDに送信されるメッセージへの応答は、要求元ノードの近隣テーブル内のノードと少なくともターゲットResource-IDに近いNode-IDによって送信されている必要があります。"
    },
    {
      "indent": 3,
      "text": "The second condition serves as a primitive check for responses from wildly wrong nodes but is not a complete check. Note that in periods of churn, it is possible for the requesting node to obtain a closer neighbor while the request is outstanding. This will cause the response to be rejected and the request to be retransmitted.",
      "ja": "2番目の条件は、非常に間違ったノードからの応答の基本的なチェックとして機能しますが、完全なチェックではありません。チャーンの期間では、要求が未解決の間に要求側ノードがより近いネイバーを取得する可能性があることに注意してください。これにより、応答が拒否され、要求が再送信されます。"
    },
    {
      "indent": 3,
      "text": "In addition, some methods (especially Store) have additional authentication requirements, which are described in the sections covering those methods.",
      "ja": "さらに、一部のメソッド（特にストア）には追加の認証要件があります。これらのメソッドをカバーするセクションで説明しています。"
    },
    {
      "indent": 0,
      "text": "6.4. Overlay Topology",
      "section_title": true,
      "ja": "6.4. オーバーレイトポロジ"
    },
    {
      "indent": 3,
      "text": "As discussed in previous sections, RELOAD defines a default overlay topology (CHORD-RELOAD) but allows for other topologies through the use of Topology Plug-ins. This section describes the requirements for new Topology Plug-ins and the methods that RELOAD provides for overlay topology maintenance.",
      "ja": "前のセクションで説明したように、RELOADはデフォルトのオーバーレイトポロジ（CHORD-RELOAD）を定義しますが、トポロジプラグインを使用して他のトポロジを可能にします。このセクションでは、新しいトポロジプラグインの要件と、RELOADがオーバーレイトポロジのメンテナンスのために提供する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Topology Plug-in Requirements",
      "section_title": true,
      "ja": "6.4.1. トポロジプラグインの要件"
    },
    {
      "indent": 3,
      "text": "When specifying a new overlay algorithm, at least the following MUST be described:",
      "ja": "新しいオーバーレイアルゴリズムを指定するときは、少なくとも次の項目を説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Joining procedures, including the contents of the Join message.",
      "ja": "o Joinメッセージの内容を含む、参加手順。"
    },
    {
      "indent": 3,
      "text": "o Stabilization procedures, including the contents of the Update message, the frequency of topology probes and keepalives, and the mechanism used to detect when peers have disconnected.",
      "ja": "o 更新メッセージの内容、トポロジープローブとキープアライブの頻度、ピアが切断されたことを検出するために使用されるメカニズムなどの安定化手順。"
    },
    {
      "indent": 3,
      "text": "o Exit procedures, including the contents of the Leave message.",
      "ja": "o Leaveメッセージの内容を含む終了手順。"
    },
    {
      "indent": 3,
      "text": "o The length of the Resource-IDs and for DHTs the hash algorithm to compute the hash of an identifier.",
      "ja": "o Resource-IDの長さ、およびDHTの場合、識別子のハッシュを計算するためのハッシュアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "o The procedures that peers use to route messages.",
      "ja": "o ピアがメッセージをルーティングするために使用する手順。"
    },
    {
      "indent": 3,
      "text": "o The replication strategy used to ensure data redundancy.",
      "ja": "o データの冗長性を確保するために使用される複製戦略。"
    },
    {
      "indent": 3,
      "text": "All overlay algorithms MUST specify maintenance procedures that send Updates to clients and peers that have established connections to the peer responsible for a particular ID when the responsibility for that ID changes. Because tracking this information is difficult, overlay algorithms MAY simply specify that an Update is sent to all members of the Connection Table whenever the range of IDs for which the peer is responsible changes.",
      "ja": "すべてのオーバーレイアルゴリズムは、特定のIDの責任が変更されたときに、そのIDを担当するピアへの接続を確立したクライアントおよびピアに更新を送信するメンテナンス手順を指定する必要があります。この情報の追跡は難しいため、オーバーレイアルゴリズムは、ピアが担当するIDの範囲が変更されるたびに、更新が接続テーブルのすべてのメンバーに送信されることを単に指定する場合があります。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Methods and Types for Use by Topology Plug-ins",
      "section_title": true,
      "ja": "6.4.2. トポロジプラグインで使用するメソッドとタイプ"
    },
    {
      "indent": 3,
      "text": "This section describes the methods that Topology Plug-ins use to join, leave, and maintain the overlay.",
      "ja": "このセクションでは、トポロジプラグインがオーバーレイの結合、離脱、維持に使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.1. Join",
      "section_title": true,
      "ja": "6.4.2.1. 参加する"
    },
    {
      "indent": 3,
      "text": "A new peer (which already has credentials) uses the JoinReq message to join the overlay. The JoinReq is sent to the responsible peer depending on the routing mechanism described in the Topology Plug-in. This message notifies the responsible peer that the new peer is taking over some of the overlay and that it needs to synchronize its state.",
      "ja": "新しいピア（すでに資格情報を持っている）は、JoinReqメッセージを使用してオーバーレイに参加します。 JoinReqは、トポロジプラグインで説明されているルーティングメカニズムに応じて、責任のあるピアに送信されます。このメッセージは、新しいピアがオーバーレイの一部を引き継いでいること、およびその状態を同期する必要があることを担当ピアに通知します。"
    },
    {
      "indent": 9,
      "text": "struct {\n   NodeId                joining_peer_id;\n   opaque                overlay_specific_data<0..2^16-1>;\n} JoinReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The minimal JoinReq contains only the Node-ID which the sending peer wishes to assume. Overlay algorithms MAY specify other data to appear in this request. Receivers of the JoinReq MUST verify that the joining_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.",
      "ja": "最小のJoinReqには、送信ピアが想定したいNode-IDのみが含まれています。オーバーレイアルゴリズムは、このリクエストに表示される他のデータを指定する場合があります。 JoinReqの受信者は、joining_peer_idフィールドがメッセージの署名に使用されたNode-IDと一致することを確認する必要があります。一致しない場合、メッセージはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "Because joins may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any JoinReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the Joining Node. Implementations MUST use DTLS anti-replay mechanisms, thus preventing replay attacks.",
      "ja": "結合は直接隣接するノード間でのみ実行できるため、受信ピアは、受信するすべてのJoinReqが、結合ノードによって想定されるノードIDにバインドされているトランスポートチャネルから到着することを確認する必要があります。実装では、DTLSアンチリプレイメカニズムを使用する必要があるため、リプレイ攻撃を防止します。"
    },
    {
      "indent": 3,
      "text": "If the request succeeds, the responding peer responds with a JoinAns message, as defined below:",
      "ja": "要求が成功すると、応答するピアは、以下に定義されているように、JoinAnsメッセージで応答します。"
    },
    {
      "indent": 9,
      "text": "struct {\n   opaque                overlay_specific_data<0..2^16-1>;\n} JoinAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the request succeeds, the responding peer MUST follow up by executing the right sequence of Stores and Updates to transfer the appropriate section of the overlay space to the Joining Node. In addition, overlay algorithms MAY define data to appear in the response payload that provides additional information.",
      "ja": "要求が成功した場合、応答するピアは、ストアと更新の正しいシーケンスを実行して、オーバーレイスペースの適切なセクションを参加ノードに転送することでフォローアップする必要があります。さらに、オーバーレイアルゴリズムは、追加情報を提供する応答ペイロードに表示されるデータを定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "Joining Nodes MUST verify that the signature on the JoinAns message matches the expected target (i.e., the adjacency over which they are joining). If not, they MUST discard the message.",
      "ja": "参加ノードは、JoinAnsメッセージの署名が予期されるターゲット（つまり、ノードが参加する隣接関係）と一致することを確認する必要があります。そうでない場合は、メッセージを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "In general, nodes which cannot form connections SHOULD report an error to the user. However, implementations MUST provide some mechanism whereby nodes can determine that they are potentially the first node and can take responsibility for the overlay. (The idea is to avoid having ordinary nodes try to become responsible for the entire overlay during a partition.) This specification does not mandate any particular mechanism, but a configuration flag or setting seems appropriate.",
      "ja": "一般に、接続を形成できないノードは、ユーザーにエラーを報告する必要があります（SHOULD）。ただし、実装は、ノードが潜在的に最初のノードであると判断し、オーバーレイの責任を負うことができるメカニズムを提供する必要があります。 （アイデアは、通常のノードがパーティション中にオーバーレイ全体の責任を負うことを回避することです。）この仕様は特定のメカニズムを強制するものではありませんが、構成フラグまたは設定が適切と思われます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.2. Leave",
      "section_title": true,
      "ja": "6.4.2.2. 去る"
    },
    {
      "indent": 3,
      "text": "The LeaveReq message is used to indicate that a node is exiting the overlay. A node SHOULD send this message to each peer with which it is directly connected prior to exiting the overlay.",
      "ja": "LeaveReqメッセージは、ノードがオーバーレイを終了していることを示すために使用されます。ノードは、オーバーレイを終了する前に、直接接続されている各ピアにこのメッセージを送信する必要があります（SHOULD）。"
    },
    {
      "indent": 9,
      "text": "struct {\n   NodeId                leaving_peer_id;\n   opaque                overlay_specific_data<0..2^16-1>;\n} LeaveReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LeaveReq contains only the Node-ID of the leaving peer. Overlay algorithms MAY specify other data to appear in this request. Receivers of the LeaveReq MUST verify that the leaving_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.",
      "ja": "LeaveReqには、離脱するピアのノードIDのみが含まれます。オーバーレイアルゴリズムは、このリクエストに表示される他のデータを指定する場合があります。 LeaveReqの受信者は、leaveing_peer_idフィールドがメッセージの署名に使用されたNode-IDと一致することを確認する必要があります。一致しない場合、メッセージはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "Because leaves may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any LeaveReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the leaving peer. This also prevents replay attacks, provided that DTLS anti-replay is used.",
      "ja": "リーフは直接隣接するノード間でのみ実行される可能性があるため、受信ピアは、受信ピアが想定するノードIDにバインドされているトランスポートチャネルから受信するLeaveReqが到着することを確認する必要があります。これにより、DTLSアンチリプレイが使用されている場合は、リプレイ攻撃も防止されます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a Leave request, a peer MUST update its own Routing Table and send the appropriate Store/Update sequences to re-stabilize the overlay.",
      "ja": "Leaveリクエストを受信すると、ピアは自身のルーティングテーブルを更新し、適切なストア/更新シーケンスを送信してオーバーレイを再安定化する必要があります。"
    },
    {
      "indent": 3,
      "text": "LeaveAns is an empty message.",
      "ja": "LeaveAnsは空のメッセージです。"
    },
    {
      "indent": 0,
      "text": "6.4.2.3. Update",
      "section_title": true,
      "ja": "6.4.2.3. 更新"
    },
    {
      "indent": 3,
      "text": "Update is the primary overlay-specific maintenance message. It is used by the sender to notify the recipient of the sender's view of the current state of the overlay (that is, its routing state), and it is up to the recipient to take whatever actions are appropriate to deal with the state change. In general, peers send Update messages to all their adjacencies whenever they detect a topology shift.",
      "ja": "更新は、オーバーレイ固有の主要なメンテナンスメッセージです。これは、オーバーレイの現在の状態（つまり、ルーティング状態）の送信者のビューを受信者に通知するために送信者によって使用され、状態の変化に対処するために適切なアクションをとるのは受信者次第です。一般に、ピアはトポロジシフトを検出するたびに、すべての隣接に更新メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "When a peer receives an Attach request with the send_update flag set to True (Section 6.4.2.4.1), it MUST send an Update message back to the sender of the Attach request after completion of the corresponding ICE check and TLS connection. Note that the sender of such an Attach request may not have joined the overlay yet.",
      "ja": "ピアがsend_updateフラグをTrueに設定してアタッチ要求を受信すると（セクション6.4.2.4.1）、対応するICEチェックとTLS接続が完了した後、アタッチ要求の送信者に更新メッセージを送信する必要があります。このようなAttachリクエストの送信者は、まだオーバーレイに参加していない可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "When a peer detects through an Update that it is no longer responsible for any data value it is storing, it MUST attempt to Store a copy to the correct node unless it knows the newly responsible node already has a copy of the data. This prevents data loss during large-scale topology shifts, such as the merging of partitioned overlays.",
      "ja": "ピアがUpdateを介して、格納しているデータ値に対してもはや責任がないことを検出した場合、新しく責任のあるノードがすでにデータのコピーを持っていることを認識していない限り、ピアはコピーを正しいノードに格納しようとする必要があります。これにより、パーティション化されたオーバーレイのマージなど、大規模なトポロジーのシフト中にデータが失われるのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "The contents of the UpdateReq message are completely overlay specific. The UpdateAns response is expected to be either success or an error.",
      "ja": "UpdateReqメッセージの内容は完全にオーバーレイ固有です。 UpdateAns応答は、成功またはエラーのいずれかであると予想されます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4. RouteQuery",
      "section_title": true,
      "ja": "6.4.2.4. RouteQuery"
    },
    {
      "indent": 3,
      "text": "The RouteQuery request allows the sender to ask a peer where they would route a message directed to a given destination. In other words, a RouteQuery for a destination X requests the Node-ID for the node that the receiving peer would next route to in order to get to X. A RouteQuery can also request that the receiving peer initiate an Update request to transfer the receiving peer's Routing Table.",
      "ja": "RouteQueryリクエストにより、送信者はピアに、指定された宛先に向けられたメッセージをルーティングする場所を尋ねることができます。つまり、宛先XのRouteQueryは、Xに到達するために受信ピアが次にルーティングするノードのノードIDを要求します。RouteQueryは、受信ピアが更新要求を開始して受信ピアを転送するように要求することもできます。ピアのルーティングテーブル。"
    },
    {
      "indent": 3,
      "text": "One important use of the RouteQuery request is to support iterative routing. The sender selects one of the peers in its Routing Table and sends it a RouteQuery message with the destination field set to the Node-ID or Resource-ID to which it wishes to route. The receiving peer responds with information about the peers to which the request would be routed. The sending peer MAY then use the Attach method to attach to that peer(s) and repeat the RouteQuery. Eventually, the sender gets a response from a peer that is closest to the identifier in the destination field as determined by the Topology Plug-in. At that point, the sender can send messages directly to that peer.",
      "ja": "RouteQueryリクエストの重要な用途の1つは、反復ルーティングをサポートすることです。送信者はルーティングテーブルでピアの1つを選択し、ルーティング先のノードIDまたはリソースIDに設定された宛先フィールドを持つRouteQueryメッセージを送信します。受信ピアは、要求がルーティングされるピアに関する情報で応答します。次に、送信側ピアは、Attachメソッドを使用してそのピアに接続し、RouteQueryを繰り返すことができます（MAY）。最終的に、送信者は、トポロジプラグインによって決定された宛先フィールドの識別子に最も近いピアから応答を受け取ります。その時点で、送信者はそのピアにメッセージを直接送信できます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4.1. Request Definition",
      "section_title": true,
      "ja": "6.4.2.4.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "A RouteQueryReq message indicates the peer or resource that the requesting node is interested in. It also contains a \"send_update\" option that allows the requesting node to request a full copy of the other peer's Routing Table.",
      "ja": "RouteQueryReqメッセージは、要求ノードが関心を持っているピアまたはリソースを示します。また、要求ノードが他のピ​​アのルーティングテーブルの完全なコピーを要求できるようにする「send_update」オプションも含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  Boolean                send_update;\n  Destination            destination;\n  opaque                 overlay_specific_data<0..2^16-1>;\n} RouteQueryReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of the RouteQueryReq message are as follows:",
      "ja": "RouteQueryReqメッセージの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "send_update A single byte. This may be set to True to indicate that the requester wishes the responder to initiate an Update request immediately. Otherwise, this value MUST be set to False.",
      "ja": "send_updateシングルバイト。これはTrueに設定して、リクエスタがレスポンダにすぐに更新リクエストを開始することを希望することを示すことができます。それ以外の場合、この値はFalseに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "destination The destination which the requester is interested in. This may be any valid destination object, including a Node-ID, opaque ID, or Resource-ID. Note: If implementations are using opaque IDs for privacy purposes, answering RouteQueryReqs for opaque IDs will allow the requester to translate an opaque ID. Implementations MAY wish to consider limiting the use of RouteQuery for opaque IDs in such cases.",
      "ja": "destinationリクエスタが関心を持っている宛先。これは、Node-ID、不透明ID、またはResource-IDを含む、任意の有効な宛先オブジェクトである可能性があります。注：実装がプライバシーの目的で不透明なIDを使用している場合、不透明なIDに対してRouteQueryReqsに応答すると、リクエスターは不透明なIDを変換できます。実装は、そのような場合に不透明なIDのRouteQueryの使用を制限することを検討したいと思うかもしれません。"
    },
    {
      "indent": 3,
      "text": "overlay_specific_data Other data as appropriate for the overlay.",
      "ja": "overlay_specific_dataオーバーレイに適切なその他のデータ。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4.2. Response Definition",
      "section_title": true,
      "ja": "6.4.2.4.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "A response to a successful RouteQueryReq request is a RouteQueryAns message. This message is completely overlay specific.",
      "ja": "成功したRouteQueryReqリクエストへの応答は、RouteQueryAnsメッセージです。このメッセージは完全にオーバーレイ固有のものです。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5. Probe",
      "section_title": true,
      "ja": "6.4.2.5. 調査"
    },
    {
      "indent": 3,
      "text": "Probe provides primitive \"exploration\" services: it allows a node to determine which resources another node is responsible for. A probe can be addressed to a specific Node-ID or to the peer controlling a given location (by using a Resource-ID). In either case, the target node responds with a simple response containing some status information.",
      "ja": "プローブは、基本的な「探索」サービスを提供します。これにより、ノードは別のノードが担当するリソースを決定できます。プローブは、特定のノードIDまたは特定の場所を制御するピア（リソースIDを使用して）にアドレス指定できます。どちらの場合も、ターゲットノードは、いくつかのステータス情報を含む単純な応答で応答します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5.1. Request Definition",
      "section_title": true,
      "ja": "6.4.2.5.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "The ProbeReq message contains a list (potentially empty) of the pieces of status information that the requester would like the responder to provide.",
      "ja": "ProbeReqメッセージには、リクエスターがレスポンダーに提供してほしいステータス情報のリスト（空の可能性があります）が含まれています。"
    },
    {
      "indent": 8,
      "text": "enum { invalidProbeInformationType(0), responsible_set(1),\n       num_resources(2), uptime(3), (255) }\n     ProbeInformationType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  ProbeInformationType     requested_info<0..2^8-1>;\n} ProbeReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The currently defined values for ProbeInformationType are:",
      "ja": "ProbeInformationTypeに現在定義されている値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "responsible_set Indicates that the peer should Respond with the fraction of the overlay for which the responding peer is responsible.",
      "ja": "Responsible_setピアが応答するピアが担当するオーバーレイの一部で応答する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "num_resources Indicates that the peer should Respond with the number of resources currently being stored by the peer. Note that multiple values under the same Resource-ID are counted only once.",
      "ja": "num_resourcesピアが現在ピアに格納されているリソースの数で応答する必要があることを示します。同じResource-IDの下の複数の値は1回だけカウントされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "uptime Indicates that the peer should Respond with how long the peer has been up, in seconds.",
      "ja": "uptimeピアが応答した時間を秒単位でピアが応答する必要があることを示します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5.2. Response Definition",
      "section_title": true,
      "ja": "6.4.2.5.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "A successful ProbeAns response contains the information elements requested by the peer.",
      "ja": "成功したProbeAns応答には、ピアによって要求された情報要素が含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  select (type) {\n    case responsible_set:\n      uint32             responsible_ppb;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "case num_resources: uint32 num_resources;",
      "ja": "ケースnum_resources：uint32 num_resources;"
    },
    {
      "indent": 13,
      "text": "case uptime: uint32 uptime;",
      "ja": "ケース稼働時間：uint32稼働時間。"
    },
    {
      "indent": 9,
      "text": "    /* This type may be extended */\n  };\n} ProbeInformationData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n  ProbeInformationType    type;\n  uint8                   length;\n  ProbeInformationData    value;\n} ProbeInformation;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n  ProbeInformation        probe_info<0..2^16-1>;\n} ProbeAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A ProbeAns message contains a sequence of ProbeInformation structures. Each has a \"length\" indicating the length of the following value field. This structure allows for unknown option types.",
      "ja": "ProbeAnsメッセージには、ProbeInformation構造のシーケンスが含まれています。それぞれに、次の値フィールドの長さを示す「長さ」があります。この構造では、不明なオプションタイプを使用できます。"
    },
    {
      "indent": 3,
      "text": "Each of the current possible Probe information types is a 32-bit unsigned integer. For type \"responsible_ppb\", it is the fraction of the overlay for which the peer is responsible, in parts per billion. For type \"num_resources\", it is the number of resources the peer is storing. For the type \"uptime\", it is the number of seconds the peer has been up.",
      "ja": "現在可能なプローブ情報タイプのそれぞれは、32ビットの符号なし整数です。タイプ「responsible_ppb」の場合、10億分の1で、ピアが担当するオーバーレイの割合です。タイプ「num_resources」の場合、ピアが格納しているリソースの数です。 「uptime」タイプの場合、ピアが稼働していた秒数です。"
    },
    {
      "indent": 3,
      "text": "The responding peer SHOULD include any values that the requesting node requested and that it recognizes. They SHOULD be returned in the requested order. Any other values MUST NOT be returned.",
      "ja": "応答するピアには、要求元ノードが要求し、認識したすべての値を含める必要があります（SHOULD）。それらは要求された順序で返されるべきです。他の値は返してはいけません。"
    },
    {
      "indent": 0,
      "text": "6.5. Forwarding and Link Management Layer",
      "section_title": true,
      "ja": "6.5. 転送およびリンク管理レイヤー"
    },
    {
      "indent": 3,
      "text": "Each node maintains connections to a set of other nodes defined by the Topology Plug-in. This section defines the methods RELOAD uses to form and maintain connections between nodes in the overlay. Three methods are defined:",
      "ja": "各ノードは、トポロジプラグインによって定義された他のノードのセットへの接続を維持します。このセクションでは、RELOADがオーバーレイのノード間の接続を形成および維持するために使用するメソッドを定義します。 3つのメソッドが定義されています。"
    },
    {
      "indent": 3,
      "text": "Attach Used to form RELOAD connections between nodes using ICE for NAT traversal. When node A wants to connect to node B, it sends an Attach message to node B through the overlay. The Attach contains A's ICE parameters. B responds with its ICE parameters, and the two nodes perform ICE to form connection. Attach also allows two nodes to connect via No-ICE instead of full ICE.",
      "ja": "アタッチNATトラバーサルにICEを使用してノード間のRELOAD接続を形成するために使用されます。ノードAがノードBに接続する場合、ノードAはオーバーレイを介してノードBに接続メッセージを送信します。アタッチには、AのICEパラメータが含まれています。 BはICEパラメータで応答し、2つのノードがICEを実行して接続を形成します。アタッチでは、2つのノードが完全なICEではなくNo-ICEを介して接続することもできます。"
    },
    {
      "indent": 3,
      "text": "AppAttach Used to form application-layer connections between nodes.",
      "ja": "AppAttachノード間のアプリケーション層接続を形成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Ping A simple request/response which is used to verify connectivity of the target peer.",
      "ja": "Pingターゲットピアの接続を確認するために使用される単純な要求/応答。"
    },
    {
      "indent": 0,
      "text": "6.5.1. Attach",
      "section_title": true,
      "ja": "6.5.1. 添付"
    },
    {
      "indent": 3,
      "text": "A node sends an Attach request when it wishes to establish a direct Overlay Link connection to another node for the purpose of sending RELOAD messages. A client that can establish a connection directly need not send an Attach, as described in the second bullet of Section 4.2.1.",
      "ja": "ノードは、RELOADメッセージを送信する目的で別のノードへの直接オーバーレイリンク接続を確立する場合に、アタッチ要求を送信します。セクション4.2.1の2番目の箇条書きで説明されているように、接続を直接確立できるクライアントは、アタッチを送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "As described in Section 6.1, an Attach may be routed to either a Node-ID or a Resource-ID. An Attach routed to a specific Node-ID will fail if that node is not reached. An Attach routed to a Resource-ID will establish a connection with the peer currently responsible for that Resource-ID, which may be useful in establishing a direct connection to the responsible peer for use with frequent or large resource updates.",
      "ja": "セクション6.1で説明したように、アタッチはノードIDまたはリソースIDのいずれかにルーティングできます。特定のノードIDにルーティングされた接続は、そのノードに到達しないと失敗します。 Resource-IDにルーティングされたAttachは、そのResource-IDを現在担当しているピアとの接続を確立します。これは、頻繁または大規模なリソース更新で使用する責任のあるピアへの直接接続を確立するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "An Attach, in and of itself, does not result in updating the Routing Table of either node. That function is performed by Updates. If node A has Attached to node B, but has not received any Updates from B, it MAY route messages which are directly addressed to B through that channel, but it MUST NOT route messages through B to other peers via that channel. The process of Attaching is separate from the process of becoming a peer (using Join and Update), to prevent half-open states where a node has started to form connections but is not really ready to act as a peer. Thus, clients (unlike peers) can simply Attach without sending Join or Update.",
      "ja": "アタッチ自体は、どちらのノードのルーティングテーブルも更新しません。その機能はアップデートによって実行されます。ノードAがノードBに接続されているが、Bから更新を受信して​​いない場合、ノードAはそのチャネルを介してBに直接アドレス指定されているメッセージをルーティングできますが、そのチャネルを介してBを介して他のピアにメッセージをルーティングしてはなりません。アタッチのプロセスは、ノードが接続を形成し始めたが実際にはピアとして機能する準備ができていないハーフオープン状態を防ぐために、（結合と更新を使用して）ピアになるプロセスとは別です。したがって、（ピアとは異なり）クライアントは、JoinやUpdateを送信せずに単純に接続できます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.1. Request Definition",
      "section_title": true,
      "ja": "6.5.1.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "An Attach request message contains the requesting node ICE connection parameters formatted into a binary structure.",
      "ja": "アタッチ要求メッセージには、バイナリ構造にフォーマットされた要求ノードのICE接続パラメータが含まれています。"
    },
    {
      "indent": 8,
      "text": "enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),\n       DTLS-UDP-SR-NO-ICE(3), TLS-TCP-FH-NO-ICE(4),\n       (255) } OverlayLinkType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "enum { invalidCandType(0),\n       host(1), srflx(2), /* RESERVED(3), */ relay(4),\n       (255) } CandType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                name<0..2^16-1>;\n  opaque                value<0..2^16-1>;\n} IceExtension;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  IpAddressPort         addr_port;\n  OverlayLinkType       overlay_link;\n  opaque                foundation<0..255>;\n  uint32                priority;\n  CandType              type;\n  select (type) {\n    case host:\n      ;          /* Empty */\n    case srflx:\n    case relay:\n      IpAddressPort     rel_addr_port;\n  };\n  IceExtension          extensions<0..2^16-1>;\n} IceCandidate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                ufrag<0..2^8-1>;\n  opaque                password<0..2^8-1>;\n  opaque                role<0..2^8-1>;\n  IceCandidate          candidates<0..2^16-1>;\n  Boolean               send_update;\n} AttachReqAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The values contained in AttachReqAns are:",
      "ja": "AttachReqAnsに含まれる値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ufrag The username fragment (from ICE).",
      "ja": "ufrag（ICEからの）ユーザー名フラグメント。"
    },
    {
      "indent": 3,
      "text": "password The ICE password.",
      "ja": "password ICEパスワード。"
    },
    {
      "indent": 3,
      "text": "role An active/passive/actpass attribute from RFC 4145 [RFC4145]. This value MUST be \"passive\" for the offerer (the peer sending the Attach request) and \"active\" for the answerer (the peer sending the Attach response).",
      "ja": "role RFC 4145 [RFC4145]のactive / passive / actpass属性。この値は、提供者（接続要求を送信するピア）に対して「パッシブ」であり、応答者（接続応答を送信するピア）に対して「アクティブ」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "candidates One or more ICE candidate values, as described below.",
      "ja": "候補以下で説明するように、1つ以上のICE候補値。"
    },
    {
      "indent": 3,
      "text": "send_update Has the same meaning as the send_update field in RouteQueryReq.",
      "ja": "send_update RouteQueryReqのsend_updateフィールドと同じ意味です。"
    },
    {
      "indent": 3,
      "text": "Each ICE candidate is represented as an IceCandidate structure, which is a direct translation of the information from the ICE string structures, with the exception of the component ID. Since there is only one component, it is always 1, and thus left out of the structure. The remaining values are specified as follows:",
      "ja": "各ICE候補はIceCandidate構造として表されます。これは、コンポーネントIDを除いて、ICE文字列構造からの情報を直接変換したものです。コンポーネントは1つしかないため、常に1であり、構造から除外されます。残りの値は次のように指定されます。"
    },
    {
      "indent": 3,
      "text": "addr_port Corresponds to the ICE connection-address and port productions.",
      "ja": "addr_port ICEの接続アドレスとポートの生成に対応します。"
    },
    {
      "indent": 3,
      "text": "overlay_link Corresponds to the ICE transport production. Overlay Link protocols used with No-ICE MUST specify \"No-ICE\" in their description. Future overlay link values can be added by defining new OverlayLinkType values in the IANA registry as described in Section 14.10. Future extensions to the encapsulation or framing that provide for backward compatibility with the previously specified encapsulation or framing values MUST use the same OverlayLinkType value that was previously defined. OverlayLinkType protocols are defined in Section 6.6",
      "ja": "overlay_link ICEトランスポートプロダクションに対応します。 No-ICEで使用されるオーバーレイリンクプロトコルは、その説明で「No-ICE」を指定する必要があります。セクション10.10で説明されているように、IANAレジストリで新しいOverlayLinkType値を定義することにより、将来のオーバーレイリンク値を追加できます。以前に指定されたカプセル化またはフレーミング値との下位互換性を提供するカプセル化またはフレーミングに対する将来の拡張では、以前に定義されたものと同じOverlayLinkType値を使用する必要があります。 OverlayLinkTypeプロトコルはセクション6.6で定義されています"
    },
    {
      "indent": 6,
      "text": "A single AttachReqAns MUST NOT include both candidates whose OverlayLinkType protocols use ICE (the default) and candidates that specify \"No-ICE\".",
      "ja": "単一のAttachReqAnsには、OverlayLinkTypeプロトコルがICE（デフォルト）を使用する候補と、「No-ICE」を指定する候補の両方を含めてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "foundation Corresponds to the ICE foundation production.",
      "ja": "ICE財団の制作に対応しています。"
    },
    {
      "indent": 3,
      "text": "priority Corresponds to the ICE priority production.",
      "ja": "priority ICE優先生産に対応します。"
    },
    {
      "indent": 3,
      "text": "type Corresponds to the ICE cand-type production.",
      "ja": "type ICEキャンドタイプ生産に対応。"
    },
    {
      "indent": 3,
      "text": "rel_addr_port Corresponds to the ICE rel-addr and rel-port productions. It is present only for types \"relay\", \"prfix\", and \"srflx\".",
      "ja": "rel_addr_port ICE rel-addrおよびrel-portプロダクションに対応します。タイプ「relay」、「prfix」、および「srflx」の場合のみ存在します。"
    },
    {
      "indent": 3,
      "text": "extensions ICE extensions. The name and value fields correspond to binary translations of the equivalent fields in the ICE extensions.",
      "ja": "拡張ICE拡張。名前フィールドと値フィールドは、ICE拡張機能の同等のフィールドのバイナリ変換に対応しています。"
    },
    {
      "indent": 3,
      "text": "These values should be generated using the procedures described in Section 6.5.1.3.",
      "ja": "これらの値は、6.5.1.3項で説明する手順を使用して生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.2. Response Definition",
      "section_title": true,
      "ja": "6.5.1.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "If a peer receives an Attach request, it MUST determine how to process the request as follows:",
      "ja": "ピアがAttachリクエストを受信した場合、次のようにリクエストの処理方法を決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the peer has not initiated an Attach request to the originating peer of this Attach request, it MUST process this request and SHOULD generate its own response with an AttachReqAns. It should then begin ICE checks.",
      "ja": "o ピアがこのAttach要求の発信元ピアへのAttach要求を開始していない場合、ピアはこの要求を処理する必要があり、AttachReqAnsを使用して独自の応答を生成する必要があります（SHOULD）。その後、ICEチェックが開始されます。"
    },
    {
      "indent": 3,
      "text": "o If the peer has already sent an Attach request to and received the response from the originating peer of this Attach request and, as a result, an ICE check and TLS connection are in progress, then it SHOULD generate an Error_In_Progress error instead of an AttachReqAns.",
      "ja": "o ピアがすでにアタッチ要求を送信し、このアタッチ要求の発信元ピアからの応答を受信して​​おり、その結果、ICEチェックとTLS接続が進行中の場合は、AttachReqAnsではなくError_In_Progressエラーを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the peer has already sent an Attach request to but not yet received the response from the originating peer of this Attach request, it SHOULD apply the following tie-breaker heuristic to determine how to handle this Attach request and the incomplete Attach request it has sent out:",
      "ja": "o ピアがアタッチ要求をすでに送信しているが、このアタッチ要求の発信ピアからの応答をまだ受信していない場合、次のタイブレーカーヒューリスティックを適用して、このアタッチ要求と送信した不完全なアタッチ要求の処理方法を決定する必要があります（SHOULD）。でる："
    },
    {
      "indent": 6,
      "text": "* If the peer's own Node-ID is smaller when compared as big-endian unsigned integers, it MUST cancel retransmission of its own incomplete Attach request. It MUST then process this Attach request, generate an AttachReqAns response, and proceed with the corresponding ICE check.",
      "ja": "* ピアの独自のNode-IDがビッグエンディアンの符号なし整数と比較して小さい場合、ピア自体の不完全なAttach要求の再送信をキャンセルする必要があります。次に、このAttach要求を処理し、AttachReqAns応答を生成して、対応するICEチェックを続行する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the peer's own Node-ID is larger when compared as big-endian unsigned integers, it MUST generate an Error_In_Progress error to this Attach request, and then proceed to wait for and complete the Attach and the corresponding ICE check it has originated.",
      "ja": "* ピアの独自のノードIDがビッグエンディアンの符号なし整数と比較して大きい場合、ピアはこのAttachリクエストに対してError_In_Progressエラーを生成し、アタッチとそれに対応するICEチェックを待機して完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the peer is overloaded or detects some other kind of error, it MAY generate an error instead of an AttachReqAns.",
      "ja": "o ピアが過負荷になっている場合、または他の種類のエラーを検出した場合は、AttachReqAnsの代わりにエラーが生成される場合があります。"
    },
    {
      "indent": 3,
      "text": "When a peer receives an Attach response, it SHOULD parse the response and begin its own ICE checks.",
      "ja": "ピアがAttach応答を受信すると、その応答を解析し、独自のICEチェックを開始する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "6.5.1.3. Using ICE with RELOAD",
      "section_title": true,
      "ja": "6.5.1.3. RELOADでのICEの使用"
    },
    {
      "indent": 3,
      "text": "This section describes the profile of ICE that is used with RELOAD. RELOAD implementations MUST implement full ICE.",
      "ja": "このセクションでは、RELOADで使用されるICEのプロファイルについて説明します。 RELOAD実装は完全なICEを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "In ICE, as defined by [RFC5245], the Session Description Protocol (SDP) is used to carry the ICE parameters. In RELOAD, this function is performed by a binary encoding in the Attach method. This encoding is more restricted than the SDP encoding because the RELOAD environment is simpler:",
      "ja": "ICEでは、[RFC5245]で定義されているように、セッション記述プロトコル（SDP）を使用してICEパラメータを伝送します。 RELOADでは、この機能はAttachメソッドのバイナリエンコーディングによって実行されます。 RELOAD環境がよりシンプルであるため、このエンコーディングはSDPエンコーディングよりも制限されています。"
    },
    {
      "indent": 3,
      "text": "o Only a single media stream is supported.",
      "ja": "o 単一のメディアストリームのみがサポートされます。"
    },
    {
      "indent": 3,
      "text": "o In this case, the \"stream\" refers not to RTP or other types of media, but rather to a connection for RELOAD itself or other application-layer protocols, such as SIP.",
      "ja": "o この場合、「ストリーム」は、RTPまたは他のタイプのメディアを指すのではなく、RELOAD自体またはSIPなどの他のアプリケーション層プロトコルの接続を指します。"
    },
    {
      "indent": 3,
      "text": "o RELOAD allows only for a single offer/answer exchange. Unlike the usage of ICE within SIP, there is never a need to send a subsequent offer to update the default candidates to match the ones selected by ICE.",
      "ja": "o RELOADは、単一のオファー/アンサー交換のみを許可します。 SIP内でのICEの使用とは異なり、ICEによって選択された候補と一致するようにデフォルトの候補を更新するために後続のオファーを送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "An agent follows the ICE specification as described in [RFC5245] with the changes and additional procedures described in the subsections below.",
      "ja": "エージェントは、[RFC5245]で説明されているICE仕様に従い、以下のサブセクションで説明されている変更と追加の手順に従います。"
    },
    {
      "indent": 0,
      "text": "6.5.1.4. Collecting STUN Servers",
      "section_title": true,
      "ja": "6.5.1.4. STUNサーバーの収集"
    },
    {
      "indent": 3,
      "text": "ICE relies on the node having one or more Session Traversal Utilities for NAT (STUN) servers to use. In conventional ICE, it is assumed that nodes are configured with one or more STUN servers through some out-of-band mechanism. This is still possible in RELOAD, but RELOAD also learns STUN servers as it connects to other peers.",
      "ja": "ICEは、NAT（STUN）サーバーが使用する1つ以上のセッショントラバーサルユーティリティを持つノードに依存しています。従来のICEでは、ノードは、帯域外メカニズムを介して1つ以上のSTUNサーバーで構成されていると想定されています。これはRELOADでも可能ですが、RELOADは他のピアに接続するときにSTUNサーバーも学習します。"
    },
    {
      "indent": 3,
      "text": "A peer on a well-provisioned wide-area overlay will be configured with one or more bootstrap nodes. These nodes make an initial list of STUN servers. However, as the peer forms connections with additional peers, it builds more peers that it can use like STUN servers.",
      "ja": "適切にプロビジョニングされた広域オーバーレイ上のピアは、1つ以上のブートストラップノードで構成されます。これらのノードは、STUNサーバーの初期リストを作成します。ただし、ピアは追加のピアとの接続を形成するため、STUNサーバーのように使用できるピアがさらに構築されます。"
    },
    {
      "indent": 0,
      "text": " Because complicated NAT topologies are possible, a peer may need more than one STUN server. Specifically, a peer that is behind a single NAT will typically observe only two IP addresses in its STUN checks: its local address and its server reflexive address from a STUN server outside its NAT. However, if more NATs are involved, a peer may learn additional server reflexive addresses (which vary based on where in the topology the STUN server is). To maximize the chance of achieving a direct connection, a peer SHOULD group other peers by the peer-reflexive addresses it discovers through them. It SHOULD then select one peer from each group to use as a STUN server for future connections.",
      "ja": "複雑なNATトポロジーが可能であるため、ピアは複数のSTUNサーバーを必要とする場合があります。具体的には、単一のNATの背後にあるピアは、通常、STUNチェックで2つのIPアドレスのみを監視します。ローカルアドレスと、NAT外のSTUNサーバーからのサーバー再帰アドレスです。ただし、より多くのNATが関係する場合、ピアは追加のサーバー再帰アドレスを学習する可能性があります（これは、STUNサーバーのトポロジ内の場所によって異なります）。直接接続を実現する可能性を最大化するために、ピアは、ピアを介して検出したピア再帰アドレスによって他のピアをグループ化する必要があります（SHOULD）。その後、各グループから1つのピアを選択して、将来の接続でSTUNサーバーとして使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Only peers to which the peer currently has connections may be used. If the connection to that host is lost, it MUST be removed from the list of STUN servers, and a new server from the same group MUST be selected unless there are no others servers in the group, in which case some other peer MAY be used.",
      "ja": "ピアが現在接続しているピアのみを使用できます。そのホストへの接続が失われた場合は、STUNサーバーのリストから削除する必要があり、グループに他のサーバーがない場合を除いて、同じグループの新しいサーバーを選択する必要があります。その場合、他のピアを使用できます。 。"
    },
    {
      "indent": 0,
      "text": "6.5.1.5. Gathering Candidates",
      "section_title": true,
      "ja": "6.5.1.5. 候補者の収集"
    },
    {
      "indent": 3,
      "text": "When a node wishes to establish a connection for the purposes of RELOAD signaling or application signaling, it follows the process of gathering candidates as described in Section 4 of ICE [RFC5245]. RELOAD utilizes a single component. Consequently, gathering for these \"streams\" requires a single component. In the case where a node has not yet found a TURN server, the agent would not include a relayed candidate.",
      "ja": "ノードがRELOADシグナリングまたはアプリケーションシグナリングの目的で接続を確立したい場合、ICE [RFC5245]のセクション4で説明されているように、候補を収集するプロセスに従います。 RELOADは単一のコンポーネントを利用します。したがって、これらの「ストリーム」を収集するには、単一のコンポーネントが必要です。ノードがまだTURNサーバーを見つけていない場合、エージェントにはリレーされた候補は含まれません。"
    },
    {
      "indent": 3,
      "text": "The ICE specification assumes that an ICE agent is configured with, or somehow knows of, TURN and STUN servers. RELOAD provides a way for an agent to learn these by querying the overlay, as described in Sections 6.5.1.4 and 9.",
      "ja": "ICE仕様では、ICEエージェントがTURNサーバーとSTUNサーバーで構成されているか、何らかの形でそれがわかっていることを前提としています。セクション6.5.1.4と9で説明されているように、RELOADはエージェントがオーバーレイをクエリすることでこれらを学習する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The default candidate selection described in Section 4.1.4 of ICE is ignored; defaults are not signaled or utilized by RELOAD.",
      "ja": "ICEのセクション4.1.4で説明されているデフォルトの候補選択は無視されます。デフォルトはRELOADによって通知または利用されません。"
    },
    {
      "indent": 3,
      "text": "An alternative to using the full ICE supported by the Attach request is to use the No-ICE mechanism by providing candidates with \"No-ICE\" Overlay Link protocols. Configuration for the overlay indicates whether or not these Overlay Link protocols can be used. An overlay MUST be either all ICE or all No-ICE.",
      "ja": "接続要求でサポートされる完全なICEを使用する代わりに、候補者に「No-ICE」オーバーレイリンクプロトコルを提供することにより、No-ICEメカニズムを使用することができます。オーバーレイの構成は、これらのオーバーレイリンクプロトコルを使用できるかどうかを示します。オーバーレイは、すべてICEまたはすべてNo-ICEでなければなりません。"
    },
    {
      "indent": 3,
      "text": "No-ICE will not work in all the scenarios where ICE would work, but in some cases, particularly those with no NATs or firewalls, it will work.",
      "ja": "No-ICEは、ICEが機能するすべてのシナリオで機能するわけではありませんが、場合によっては、特にNATやファイアウォールがないシナリオで機能することがあります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.6. Prioritizing Candidates",
      "section_title": true,
      "ja": "6.5.1.6. 候補の優先順位付け"
    },
    {
      "indent": 3,
      "text": "Standardization of additional protocols for use with ICE is expected, including TCP [RFC6544] and protocols such as the Stream Control Transmission Protocol (SCTP) [RFC4960] and Datagram Congestion Control Protocol (DCCP) [RFC4340]. UDP encapsulations for SCTP and DCCP would expand the Overlay Link protocols available for RELOAD.",
      "ja": "TCP [RFC6544]や、Stream Control Transmission Protocol（SCTP）[RFC4960]やDatagram Congestion Control Protocol（DCCP）[RFC4340]などのプロトコルを含む、ICEで使用する追加のプロトコルの標準化が期待されています。 SCTPおよびDCCPのUDPカプセル化により、RELOADで使用可能なオーバーレイリンクプロトコルが拡張されます。"
    },
    {
      "indent": 3,
      "text": "When additional protocols are available, the following prioritization is RECOMMENDED:",
      "ja": "追加のプロトコルが利用可能な場合、次の優先順位付けが推奨されます。"
    },
    {
      "indent": 3,
      "text": "o Highest priority is assigned to protocols that offer well-understood congestion and flow control without head-of-line blocking, for example, SCTP without message ordering, DCCP, and those protocols encapsulated using UDP.",
      "ja": "o 最も高い優先度は、ヘッドオブラインブロッキングなしでよく理解されている輻輳とフロー制御を提供するプロトコルに割り当てられます。たとえば、メッセージ順序付けのないSCTP、DCCP、およびUDPを使用してカプセル化されたプロトコルです。"
    },
    {
      "indent": 3,
      "text": "o Second highest priority is assigned to protocols that offer well-understood congestion and flow control, but that have head-of-line blocking, such as TCP.",
      "ja": "o 2番目に高い優先順位は、よく理解されている輻輳とフロー制御を提供するが、TCPなどの行頭ブロッキングを備えているプロトコルに割り当てられます。"
    },
    {
      "indent": 3,
      "text": "o Lowest priority is assigned to protocols encapsulated over UDP that do not implement well-established congestion control algorithms. The DTLS/UDP with Simple Reliability (SR) overlay link protocol is an example of such a protocol.",
      "ja": "o 最低の優先順位は、確立された輻輳制御アルゴリズムを実装しない、UDPを介してカプセル化されたプロトコルに割り当てられます。シンプル信頼性（SR）オーバーレイリンクプロトコルを使用するDTLS / UDPは、このようなプロトコルの例です。"
    },
    {
      "indent": 3,
      "text": "Head-of-line blocking is undesirable in an Overlay Link protocol, because the messages carried on a RELOAD link are independent, rather than stream-oriented. Therefore, if message N on a link is lost, delaying message N+1 on that same link until N is successfully retransmitted does nothing other than increase the latency for the transaction of message N+1, as they are unrelated to each other. Therefore, while the high quality, performance, and availability of modern TCP implementations makes them very attractive, their performance as Overlay Link protocols is not optimal.",
      "ja": "RELOADリンクで伝送されるメッセージはストリーム指向ではなく独立しているため、オーバーレイリンクプロトコルではヘッドオブラインブロッキングは望ましくありません。したがって、リンク上のメッセージNが失われた場合、Nが正常に再送信されるまで同じリンク上でメッセージN + 1を遅らせても、メッセージN + 1のトランザクションのレイテンシが増加するだけです。したがって、最新のTCP実装の高品質、パフォーマンス、および可用性は非常に魅力的ですが、オーバーレイリンクプロトコルとしてのパフォーマンスは最適ではありません。"
    },
    {
      "indent": 3,
      "text": "Note that none of the protocols defined in this document meets these conditions, but it is expected that new Overlay Link protocols defined in the future will fill this gap.",
      "ja": "このドキュメントで定義されているプロトコルはどれもこれらの条件を満たしていませんが、将来定義される新しいオーバーレイリンクプロトコルがこのギャップを埋めると予想されます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.7. Encoding the Attach Message",
      "section_title": true,
      "ja": "6.5.1.7. 添付メッセージのエンコード"
    },
    {
      "indent": 3,
      "text": "Section 4.3 of ICE describes procedures for encoding the SDP for conveying RELOAD candidates. Instead of actually encoding an SDP message, the candidate information (IP address and port and transport protocol, priority, foundation, type, and related address) is carried within the attributes of the Attach request or its response. Similarly, the username fragment and password are carried in the Attach message or its response. Section 6.5.1 describes the detailed attribute encoding for Attach. The Attach request and its response do not contain any default candidates or the ice-lite attribute, as these features of ICE are not used by RELOAD.",
      "ja": "ICEのセクション4.3では、RELOAD候補を伝達するためにSDPをエンコードする手順について説明します。 SDPメッセージを実際にエンコードする代わりに、候補情報（IPアドレスとポートおよびトランスポートプロトコル、優先度、ファンデーション、タイプ、および関連アドレス）が、アタッチ要求またはその応答の属性内で伝達されます。同様に、ユーザー名フラグメントとパスワードは、Attachメッセージまたはその応答で伝達されます。セクション6.5.1では、アタッチの詳細な属性エンコーディングについて説明します。アタッチ要求とその応答には、ICEのこれらの機能はRELOADで使用されないため、デフォルトの候補やice-lite属性は含まれていません。"
    },
    {
      "indent": 0,
      "text": " Since the Attach request contains the candidate information and short term credentials, it is considered as an offer for a single media stream that happens to be encoded in a format different than SDP, but is otherwise considered a valid offer for the purposes of following the ICE specification. Similarly, the Attach response is considered a valid answer for the purposes of following the ICE specification.",
      "ja": "Attachリクエストには候補情報と短期的な認証情報が含まれているため、たまたまSDPとは異なるフォーマットでエンコードされている単一のメディアストリームのオファーと見なされますが、それ以外の場合はICEに従うための有効なオファーと見なされます仕様。同様に、アタッチ応答は、ICE仕様に従うための有効な回答と見なされます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.8. Verifying ICE Support",
      "section_title": true,
      "ja": "6.5.1.8. ICEサポートの確認"
    },
    {
      "indent": 3,
      "text": "An agent MUST skip the verification procedures in Sections 5.1 and 6.1 of ICE. Since RELOAD requires full ICE from all agents, this check is not required.",
      "ja": "エージェントは、ICEのセクション5.1および6.1の検証手順をスキップする必要があります。 RELOADはすべてのエージェントからの完全なICEを必要とするため、このチェックは必要ありません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.9. Role Determination",
      "section_title": true,
      "ja": "6.5.1.9. 役割の決定"
    },
    {
      "indent": 3,
      "text": "The roles of controlling and controlled, as described in Section 5.2 of ICE, are still utilized with RELOAD. However, the offerer (the entity sending the Attach request) will always be controlling, and the answerer (the entity sending the Attach response) will always be controlled. The connectivity checks MUST still contain the ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though the role reversal capability for which they are defined will never be needed with RELOAD. This is to allow for a common codebase between ICE for RELOAD and ICE for SDP.",
      "ja": "ICEのセクション5.2で説明されているように、制御と制御の役割は、RELOADでも使用されます。ただし、提供者（Attach要求を送信するエンティティ）は常に制御し、応答者（Attach応答を送信するエンティティ）は常に制御します。接続性チェックには、ICE-CONTROLLEDおよびICE-CONTROLLING属性が含まれている必要があります。ただし、RELOADでは、それらが定義されているロールの反転機能は必要ありません。これは、ICE for RELOADとICE for SDPの間で共通のコードベースを可能にするためです。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10. Full ICE",
      "section_title": true,
      "ja": "6.5.1.10. フルICE"
    },
    {
      "indent": 3,
      "text": "When the overlay uses ICE, connectivity checks and nominations are used as in regular ICE.",
      "ja": "オーバーレイがICEを使用する場合、通常のICEと同様に、接続性のチェックとノミネートが使用されます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.1. Connectivity Checks",
      "section_title": true,
      "ja": "6.5.1.10.1. 接続チェック"
    },
    {
      "indent": 3,
      "text": "The processes of forming check lists in Section 5.7 of ICE, scheduling checks in Section 5.8, and checking connectivity checks in Section 7 are used with RELOAD without change.",
      "ja": "ICEのセクション5.7でチェックリストを形成するプロセス、セクション5.8でスケジュールチェック、セクション7で接続性チェックをチェックするプロセスは、RELOADでそのまま使用されます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.2. Concluding ICE",
      "section_title": true,
      "ja": "6.5.1.10.2. ICEのまとめ"
    },
    {
      "indent": 3,
      "text": "The procedures in Section 8 of ICE are followed to conclude ICE, with the following exceptions:",
      "ja": "ICEのセクション8の手順に従って、ICEを終了します。ただし、次の例外があります。"
    },
    {
      "indent": 3,
      "text": "o The controlling agent MUST NOT attempt to send an updated offer once the state of its single media stream reaches Completed.",
      "ja": "o 制御エージェントは、その単一のメディアストリームの状態がCompletedに達したら、更新されたオファーの送信を試みてはなりません。"
    },
    {
      "indent": 3,
      "text": "o Once the state of ICE reaches Completed, the agent can immediately free all unused candidates. This is because RELOAD does not have the concept of forking, and thus the three-second delay in Section 8.3 of ICE does not apply.",
      "ja": "o ICEの状態が完了に達すると、エージェントは未使用のすべての候補をすぐに解放できます。これは、RELOADにフォークの概念がないため、ICEのセクション8.3の3秒の遅延が適用されないためです。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.3. Media Keepalives",
      "section_title": true,
      "ja": "6.5.1.10.3. メディアキープアライブ"
    },
    {
      "indent": 3,
      "text": "STUN MUST be utilized for the keepalives described in Section 10 of ICE.",
      "ja": "STUNは、ICEのセクション10で説明されているキープアライブに使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.11. No-ICE",
      "section_title": true,
      "ja": "6.5.1.11. No-ICE"
    },
    {
      "indent": 3,
      "text": "No-ICE is selected when either side has provided \"no ICE\" Overlay Link candidates. STUN is not used for connectivity checks when doing No-ICE; instead, the DTLS or TLS handshake (or similar security layer of future overlay link protocols) forms the connectivity check. The certificate exchanged during the TLS or DTLS handshake MUST match the node which sent the AttachReqAns, and if it does not, the connection MUST be closed.",
      "ja": "どちらの側も「ICEなし」のオーバーレイリンク候補を提供した場合、ICEなしが選択されます。 STUNは、No-ICEを実行するときの接続チェックには使用されません。代わりに、DTLSまたはTLSハンドシェイク（または将来のオーバーレイリンクプロトコルの同様のセキュリティレイヤー）が接続チェックを形成します。 TLSまたはDTLSハンドシェイク中に交換される証明書は、AttachReqAnsを送信したノードと一致する必要があり、一致しない場合は、接続を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.12. Subsequent Offers and Answers",
      "section_title": true,
      "ja": "6.5.1.12. 後続のオファーと回答"
    },
    {
      "indent": 3,
      "text": "An agent MUST NOT send a subsequent offer or answer. Thus, the procedures in Section 9 of ICE MUST be ignored.",
      "ja": "エージェントは後続のオファーまたは応答を送信してはなりません。したがって、ICEのセクション9の手順は無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.13. Sending Media",
      "section_title": true,
      "ja": "6.5.1.13. メディアの送信"
    },
    {
      "indent": 3,
      "text": "The procedures of Section 11 of ICE apply to RELOAD as well. However, in this case, the \"media\" takes the form of application-layer protocols (e.g., RELOAD) over TLS or DTLS. Consequently, once ICE processing completes, the agent will begin TLS or DTLS procedures to establish a secure connection. The node that sent the Attach request MUST be the TLS server. The other node MUST be the TLS client. The server MUST request TLS client authentication. The nodes MUST verify that the certificate presented in the handshake matches the identity of the other peer as found in the Attach message. Once the TLS or DTLS signaling is complete, the application protocol is free to use the connection.",
      "ja": "ICEのセクション11の手順はRELOADにも適用されます。ただし、この場合、「メディア」はTLSまたはDTLSを介したアプリケーション層プロトコル（RELOADなど）の形式を取ります。したがって、ICE処理が完了すると、エージェントはTLSまたはDTLS手順を開始して、安全な接続を確立します。接続要求を送信したノードは、TLSサーバーでなければなりません。他のノードはTLSクライアントでなければなりません。サーバーはTLSクライアント認証を要求する必要があります。ノードは、ハンドシェイクで提示された証明書が、アタッチメッセージにある他のピアのIDと一致することを確認する必要があります。 TLSまたはDTLSシグナリングが完了すると、アプリケーションプロトコルは接続を自由に使用できます。"
    },
    {
      "indent": 3,
      "text": "The concept of a previous selected pair for a component does not apply to RELOAD, since ICE restarts are not possible with RELOAD.",
      "ja": "コンポーネントに対して以前に選択されたペアの概念は、RELOADには適用されません。これは、ICEの再起動がRELOADでは不可能であるためです。"
    },
    {
      "indent": 0,
      "text": "6.5.1.14. Receiving Media",
      "section_title": true,
      "ja": "6.5.1.14. メディアを受け取る"
    },
    {
      "indent": 3,
      "text": "An agent MUST be prepared to receive packets for the application protocol (TLS or DTLS carrying RELOAD) at any time. The jitter and RTP considerations in Section 11 of ICE do not apply to RELOAD.",
      "ja": "エージェントは、いつでもアプリケーションプロトコル（RELOADを伝送するTLSまたはDTLS）のパケットを受信できるように準備する必要があります。 ICEのセクション11にあるジッタとRTPの考慮事項は、RELOADには適用されません。"
    },
    {
      "indent": 0,
      "text": "6.5.2. AppAttach",
      "section_title": true,
      "ja": "6.5.2. AppAttach"
    },
    {
      "indent": 0,
      "text": " A node sends an AppAttach request when it wishes to establish a direct connection to another node for the purposes of sending application-layer messages. AppAttach is nearly identical to Attach, except for the purpose of the connection: it is used to transport non-RELOAD \"media\". A separate request is used to avoid implementer confusion between the two methods (this was found to be a real problem with initial implementations). The AppAttach request and its response contain an application attribute, which indicates what protocol is to be run over the connection.",
      "ja": "アプリケーション層メッセージを送信する目的で別のノードへの直接接続を確立したい場合、ノードはAppAttach要求を送信します。 AppAttachは、接続の目的を除いて、Attachとほぼ同じです。これは、非RELOAD「メディア」の転送に使用されます。 2つのメソッド間の実装者の混乱を回避するために、個別のリクエストが使用されます（これは、初期実装での実際の問題であることが判明しました）。 AppAttach要求とその応答には、接続で実行するプロトコルを示すアプリケーション属性が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.5.2.1. Request Definition",
      "section_title": true,
      "ja": "6.5.2.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "An AppAttachReq message contains the requesting node's ICE connection parameters formatted into a binary structure.",
      "ja": "AppAttachReqメッセージには、バイナリ構造にフォーマットされた要求ノードのICE接続パラメーターが含まれています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                  ufrag<0..2^8-1>;\n  opaque                  password<0..2^8-1>;\n  uint16                  application;\n  opaque                  role<0..2^8-1>;\n  IceCandidate            candidates<0..2^16-1>;\n} AppAttachReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The values contained in AppAttachReq and AppAttachAns are:",
      "ja": "AppAttachReqおよびAppAttachAnsに含まれる値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ufrag The username fragment (from ICE).",
      "ja": "ufrag（ICEからの）ユーザー名フラグメント。"
    },
    {
      "indent": 3,
      "text": "password The ICE password.",
      "ja": "password ICEパスワード。"
    },
    {
      "indent": 3,
      "text": "application A 16-bit Application-ID, as defined in the Section 14.5. This number represents the IANA-registered application that is going to send data on this connection.",
      "ja": "applicationセクション14.5で定義されている16ビットのアプリケーションID。この番号は、この接続でデータを送信するIANA登録アプリケーションを表します。"
    },
    {
      "indent": 3,
      "text": "role An active/passive/actpass attribute from RFC 4145 [RFC4145].",
      "ja": "role RFC 4145 [RFC4145]のactive / passive / actpass属性。"
    },
    {
      "indent": 3,
      "text": "candidates One or more ICE candidate values.",
      "ja": "候補1つ以上のICE候補値。"
    },
    {
      "indent": 3,
      "text": "The application using the connection that is set up with this request is responsible for providing traffic of sufficient frequency to keep the NAT and Firewall binding alive. Applications will often send traffic every 25 seconds to ensure this.",
      "ja": "このリクエストで設定された接続を使用するアプリケーションは、NATとファイアウォールのバインディングを維持するのに十分な頻度のトラフィックを提供する責任があります。これを確実にするために、アプリケーションは多くの場合、25秒ごとにトラフィックを送信します。"
    },
    {
      "indent": 0,
      "text": "6.5.2.2. Response Definition",
      "section_title": true,
      "ja": "6.5.2.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "If a peer receives an AppAttach request, it SHOULD process the request and generate its own response with a AppAttachAns. It should then begin ICE checks. When a peer receives an AppAttach response, it SHOULD parse the response and begin its own ICE checks. If the Application ID is not supported, the peer MUST reply with an Error_Not_Found error.",
      "ja": "ピアがAppAttachリクエストを受信した場合、ピアはリクエストを処理し、AppAttachAnsで独自の応答を生成する必要があります（SHOULD）。その後、ICEチェックが開始されます。ピアがAppAttach応答を受信すると、その応答を解析して独自のICEチェックを開始する必要があります（SHOULD）。アプリケーションIDがサポートされていない場合、ピアはError_Not_Foundエラーで応答する必要があります。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                  ufrag<0..2^8-1>;\n  opaque                  password<0..2^8-1>;\n  uint16                  application;\n  opaque                  role<0..2^8-1>;\n  IceCandidate            candidates<0..2^16-1>;\n} AppAttachAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The meaning of the fields is the same as in the AppAttachReq.",
      "ja": "フィールドの意味は、AppAttachReqの場合と同じです。"
    },
    {
      "indent": 0,
      "text": "6.5.3. Ping",
      "section_title": true,
      "ja": "6.5.3. ping"
    },
    {
      "indent": 3,
      "text": "Ping is used to test connectivity along a path. A ping can be addressed to a specific Node-ID, to the peer controlling a given location (by using a Resource-ID), or to the wildcard Node-ID.",
      "ja": "Pingは、パスに沿った接続をテストするために使用されます。 pingは、特定のノードID、指定された場所を制御するピア（リソースIDを使用）、またはワイルドカードノードIDにアドレス指定できます。"
    },
    {
      "indent": 0,
      "text": "6.5.3.1. Request Definition",
      "section_title": true,
      "ja": "6.5.3.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "The PingReq structure is used to make a Ping request.",
      "ja": "PingReq構造体は、Ping要求を行うために使用されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque<0..2^16-1> padding;\n} PingReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Ping request is empty of meaningful contents. However, it may contain up to 65535 bytes of padding to facilitate the discovery of overlay maximum packet sizes.",
      "ja": "Pingリクエストには意味のあるコンテンツがありません。ただし、オーバーレイの最大パケットサイズの検出を容易にするために、最大65535バイトのパディングが含まれる場合があります。"
    },
    {
      "indent": 0,
      "text": "6.5.3.2. Response Definition",
      "section_title": true,
      "ja": "6.5.3.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "A successful PingAns response contains the information elements requested by the peer.",
      "ja": "成功したPingAns応答には、ピアから要求された情報要素が含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  uint64                 response_id;\n  uint64                 time;\n} PingAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A PingAns message contains the following elements:",
      "ja": "PingAnsメッセージには、次の要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "response_id A randomly generated 64-bit response ID. This is used to distinguish Ping responses.",
      "ja": "response_idランダムに生成された64ビットの応答ID。これは、Ping応答を区別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "time The time when the Ping response was created, represented in the same way as storage_time, defined in Section 7.",
      "ja": "time Ping応答が作成された時刻。セクション7で定義されたstorage_timeと同じ方法で表されます。"
    },
    {
      "indent": 0,
      "text": "6.5.4. ConfigUpdate",
      "section_title": true,
      "ja": "6.5.4. ConfigUpdate"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdate method is used to push updated configuration data across the overlay. Whenever a node detects that another node has old configuration data, it MUST generate a ConfigUpdate request. The ConfigUpdate request allows updating of two kinds of data: the configuration data (Section 6.3.2.1) and the Kind information (Section 7.4.1.1).",
      "ja": "ConfigUpdateメソッドは、更新された構成データをオーバーレイ全体にプッシュするために使用されます。ノードが別のノードに古い設定データがあることを検出するときはいつでも、それはConfigUpdateリクエストを生成しなければなりません（MUST）。 ConfigUpdateリクエストでは、構成データ（セクション6.3.2.1）と種類情報（セクション7.4.1.1）の2種類のデータを更新できます。"
    },
    {
      "indent": 0,
      "text": "6.5.4.1. Request Definition",
      "section_title": true,
      "ja": "6.5.4.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateReq structure is used to provide updated configuration information.",
      "ja": "ConfigUpdateReq構造体は、更新された構成情報を提供するために使用されます。"
    },
    {
      "indent": 8,
      "text": "enum { invalidConfigUpdateType(0), config(1), kind(2), (255) }\n     ConfigUpdateType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "typedef uint32           KindId;\ntypedef opaque           KindDescription<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  ConfigUpdateType       type;\n  uint32                 length;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "select (type) {\n  case config:\n              opaque             config_data<0..2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case kind:\n            KindDescription    kinds<0..2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended with new types */\n  };\n} ConfigUpdateReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateReq message contains the following elements:",
      "ja": "ConfigUpdateReqメッセージには、次の要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "type The type of the contents of the message. This structure allows for unknown content types.",
      "ja": "typeメッセージの内容のタイプ。この構造により、不明なコンテンツタイプが許可されます。"
    },
    {
      "indent": 3,
      "text": "length The length of the remainder of the message. This is included to preserve backward compatibility and is 32 bits instead of 24 to facilitate easy conversion between network and host byte order.",
      "ja": "lengthメッセージの残りの長さ。これは、下位互換性を維持するために含まれており、ネットワークとホストのバイトオーダー間の変換を容易にするために、24ではなく32ビットです。"
    },
    {
      "indent": 3,
      "text": "config_data (type==config) The contents of the Configuration Document.",
      "ja": "config_data（type == config）構成ドキュメントの内容。"
    },
    {
      "indent": 3,
      "text": "kinds (type==kind) One or more XML kind-block productions (see Section 11.1). These MUST be encoded with UTF-8 and assume a default namespace of \"urn:ietf:params:xml:ns:p2p:config-base\".",
      "ja": "kind（type == kind）1つ以上のXML kind-block生成（セクション11.1を参照）。これらはUTF-8でエンコードされ、デフォルトの名前空間が「urn：ietf：params：xml：ns：p2p：config-base」であると想定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.4.2. Response Definition",
      "section_title": true,
      "ja": "6.5.4.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateAns structure is used to respond to a ConfigUpdateReq request.",
      "ja": "ConfigUpdateAns構造体は、ConfigUpdateReqリクエストに応答するために使用されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n} ConfigUpdateAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the ConfigUpdateReq is of type \"config\", it MUST be processed only if all the following are true:",
      "ja": "ConfigUpdateReqのタイプが「config」の場合、次のすべてに該当する場合にのみ処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The sequence number in the document is greater than the current configuration sequence number.",
      "ja": "o ドキュメント内のシーケンス番号が、現在の構成シーケンス番号より大きいです。"
    },
    {
      "indent": 3,
      "text": "o The Configuration Document is correctly digitally signed (see Section 11 for details on signatures).",
      "ja": "o 構成ドキュメントは正しくデジタル署名されています（署名の詳細については、セクション11を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Otherwise, appropriate errors MUST be generated.",
      "ja": "それ以外の場合は、適切なエラーを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the ConfigUpdateReq is of type \"kind\", it MUST be processed only if it is correctly digitally signed by an acceptable Kind signer (i.e., one listed in the current configuration file). Details on the kind-signer field in the configuration file are described in Section 11.1. In addition, if the Kind update conflicts with an existing known Kind (i.e., it is signed by a different signer), then it should be rejected with an Error_Forbidden error. This should not happen in correctly functioning overlays.",
      "ja": "ConfigUpdateReqのタイプが「kind」の場合は、受け入れ可能なKind署名者（つまり、現在の構成ファイルにリストされているもの）によって正しくデジタル署名されている場合にのみ処理する必要があります。構成ファイルの種類署名者フィールドの詳細は、11.1項で説明しています。さらに、Kindの更新が既存の既知のKindと競合する（つまり、別の署名者によって署名されている）場合、Error_Forbiddenエラーで拒否されます。これは、正しく機能するオーバーレイでは発生しません。"
    },
    {
      "indent": 3,
      "text": "If the update is acceptable, then the node MUST reconfigure itself to match the new information. This may include adding permissions for new Kinds, deleting old Kinds, or even, in extreme circumstances, exiting and re-entering the overlay, if, for instance, the DHT algorithm has changed.",
      "ja": "更新が受け入れられる場合、ノードは新しい情報と一致するようにノード自体を再構成する必要があります。これには、新しい種類のアクセス許可の追加、古い種類の削除、さらに極端な状況では、たとえばDHTアルゴリズムが変更された場合にオーバーレイを終了して再入力することが含まれます。"
    },
    {
      "indent": 3,
      "text": "If an implementation misses enough ConfigUpdates that include key changes, it is possible that it will no longer be able to verify new valid ConfigUpdates. In this case, the only available recovery mechanism is to attempt to retrieve a new Configuration Document, typically by the mechanisms used for initial bootstrapping. It is up to implementers whether or how to decide to employ this sort of recovery mechanism.",
      "ja": "重要な変更を含む十分なConfigUpdateが実装で不足している場合、新しい有効なConfigUpdateを検証できなくなる可能性があります。この場合、利用可能な唯一の回復メカニズムは、通常は初期ブートストラップに使用されるメカニズムによって、新しい構成ドキュメントを取得することです。この種の回復メカニズムを採用するかどうか、またはどのように決定するかは、実装者次第です。"
    },
    {
      "indent": 3,
      "text": "The response for ConfigUpdate is empty.",
      "ja": "ConfigUpdateの応答が空です。"
    },
    {
      "indent": 0,
      "text": "6.6. Overlay Link Layer",
      "section_title": true,
      "ja": "6.6. オーバーレイリンクレイヤー"
    },
    {
      "indent": 3,
      "text": "RELOAD can use multiple Overlay Link protocols to send its messages. Because ICE is used to establish connections (see Section 6.5.1.3), RELOAD nodes are able to detect which Overlay Link protocols are offered by other nodes and establish connections between them. Any link protocol needs to be able to establish a secure, authenticated connection and to provide data origin authentication and message integrity for individual data elements. RELOAD currently supports three Overlay Link protocols:",
      "ja": "RELOADは、複数のオーバーレイリンクプロトコルを使用してメッセージを送信できます。 ICEは接続を確立するために使用されるため（セクション6.5.1.3を参照）、RELOADノードは、他のノードによって提供されているオーバーレイリンクプロトコルを検出し、それらの間の接続を確立できます。リンクプロトコルは、安全で認証された接続を確立し、個々のデータ要素にデータ発信元認証とメッセージ整合性を提供できる必要があります。 RELOADは現在、3つのオーバーレイリンクプロトコルをサポートしています。"
    },
    {
      "indent": 3,
      "text": "o DTLS [RFC6347] over UDP with Simple Reliability (SR) (OverlayLinkType=DTLS-UDP-SR)",
      "ja": "o 単純な信頼性（SR）を使用したUDP経由のDTLS [RFC6347]（OverlayLinkType = DTLS-UDP-SR）"
    },
    {
      "indent": 3,
      "text": "o TLS [RFC5246] over TCP with Framing Header, No-ICE (OverlayLinkType=TLS-TCP-FH-NO-ICE)",
      "ja": "o TLS [RFC5246] over TCP with Framing Header、No-ICE（OverlayLinkType = TLS-TCP-FH-NO-ICE）"
    },
    {
      "indent": 3,
      "text": "o DTLS [RFC6347] over UDP with SR, No-ICE (OverlayLinkType=DTLS-UDP-SR-NO-ICE)",
      "ja": "o DTLS [RFC6347] over UDP with SR、No-ICE（OverlayLinkType = DTLS-UDP-SR-NO-ICE）"
    },
    {
      "indent": 3,
      "text": "Note that although UDP does not properly have \"connections\", both TLS and DTLS have a handshake that establishes a similar, stateful association. We refer to these as \"connections\" for the purposes of this document.",
      "ja": "UDPには「接続」が適切に設定されていませんが、TLSとDTLSの両方に、同様のステートフルな関連付けを確立するハンドシェイクがあることに注意してください。このドキュメントでは、これらを「接続」と呼びます。"
    },
    {
      "indent": 0,
      "text": " If a peer receives a message that is larger than the value of max-message-size defined in the overlay configuration, the peer SHOULD send an Error_Message_Too_Large error and then close the TLS or DTLS session from which the message was received. Note that this error can be sent and the session closed before the peer receives the complete message. If the forwarding header is larger than the max- message-size, the receiver SHOULD close the TLS or DTLS session without sending an error.",
      "ja": "ピアがオーバーレイ構成で定義されたmax-message-sizeの値より大きいメッセージを受信した場合、ピアはError_Message_Too_Largeエラーを送信してから、メッセージの送信元のTLSまたはDTLSセッションを閉じる必要があります（SHOULD）。ピアが完全なメッセージを受信する前に、このエラーを送信してセッションを閉じることができることに注意してください。転送ヘッダーがmax-message-sizeより大きい場合、受信者はエラーを送信せずにTLSまたはDTLSセッションを閉じる必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The RELOAD mechanism requires that failed links be quickly removed from the Routing Table so end-to-end retransmission can handle lost messages. Overlay Link protocols MUST be designed with a mechanism that quickly signals a likely failure, and implementations SHOULD quickly act to remove a failed link from the Routing Table when receiving this signal. The entry can be restored if it proves to resume functioning, or it can be replaced at some point in the future if necessary. Section 10.7.2 contains more details specific to the CHORD-RELOAD Topology Plug-in.",
      "ja": "RELOADメカニズムでは、失敗したリンクをルーティングテーブルからすばやく削除して、エンドツーエンドの再送信で失われたメッセージを処理できるようにする必要があります。オーバーレイリンクプロトコルは、可能性のある障害を迅速に通知するメカニズムを使用して設計する必要があり、実装は、この信号を受信したときにルーティングテーブルから失敗したリンクを削除するように迅速に動作する必要があります。エントリは、機能を再開したことが判明した場合に復元できます。または、必要に応じて、将来のある時点で置き換えることができます。セクション10.7.2には、CHORD-RELOADトポロジプラグインに固有の詳細が含まれています。"
    },
    {
      "indent": 3,
      "text": "The Framing Header (FH) is used to frame messages and provide timing when used on a reliable stream-based transport protocol. Simple Reliability (SR) uses the FH to provide congestion control and partial reliability when using unreliable message-oriented transport protocols. We will first define each of these algorithms in Sections 6.6.2 and 6.6.3, and then define Overlay Link protocols that use them in Sections 6.6.4, 6.6.5, and 6.6.6.",
      "ja": "フレーミングヘッダー（FH）は、メッセージをフレーム化し、信頼性の高いストリームベースのトランスポートプロトコルで使用されるときにタイミングを提供するために使用されます。シンプル信頼性（SR）はFHを使用して、信頼性の低いメッセージ指向のトランスポートプロトコルを使用する場合に、輻輳制御と部分的な信頼性を提供します。まず、セクション6.6.2および6.6.3でこれらの各アルゴリズムを定義し、次にセクション6.6.4、6.6.5、および6.6.6でそれらを使用するオーバーレイリンクプロトコルを定義します。"
    },
    {
      "indent": 3,
      "text": "Note: We expect future Overlay Link protocols to define replacements for all components of these protocols, including the Framing Header. The three protocols that we will discuss have been chosen for simplicity of implementation and reasonable performance.",
      "ja": "注：将来のオーバーレイリンクプロトコルでは、フレーミングヘッダーを含むこれらのプロトコルのすべてのコンポーネントの代替を定義する予定です。これから説明する3つのプロトコルは、実装の簡素化と妥当なパフォーマンスのために選択されています。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Future Overlay Link Protocols",
      "section_title": true,
      "ja": "6.6.1. 将来のオーバーレイリンクプロトコル"
    },
    {
      "indent": 3,
      "text": "It is possible to define new link-layer protocols and apply them to a new overlay using the \"overlay-link-protocol\" configuration directive (see Section 11.1.). However, any new protocols MUST meet the following requirements:",
      "ja": "「overlay-link-protocol」設定ディレクティブを使用して、新しいリンク層プロトコルを定義し、それらを新しいオーバーレイに適用することができます（セクション11.1を参照）。ただし、新しいプロトコルは次の要件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "Endpoint authentication: When a node forms an association with another endpoint, it MUST be possible to cryptographically verify that the endpoint has a given Node-ID.",
      "ja": "エンドポイント認証：ノードが別のエンドポイントとの関連付けを形成する場合、エンドポイントが特定のノードIDを持っていることを暗号で検証できる必要があります。"
    },
    {
      "indent": 3,
      "text": "Traffic origin authentication and integrity: When a node receives traffic from another endpoint, it MUST be possible to cryptographically verify that the traffic came from a given association and that it has not been modified in transit from the other endpoint in the association. The overlay link protocol MUST also provide replay prevention/detection.",
      "ja": "トラフィックの起点認証と整合性：ノードが別のエンドポイントからトラフィックを受信するとき、トラフィックが特定のアソシエーションからのものであり、アソシエーションの他のエンドポイントからの転送中に変更されていないことを暗号で検証できる必要があります。オーバーレイリンクプロトコルは、リプレイ防止/検出も提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Traffic confidentiality: When a node sends traffic to another endpoint, it MUST NOT be possible for a third party that is not involved in the association to determine the contents of that traffic.",
      "ja": "トラフィックの機密性：ノードがトラフィックを別のエンドポイントに送信する場合、関連付けに関与していないサードパーティがそのトラフィックの内容を判別することは不可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "Any new overlay protocol MUST be defined via Standards Action [RFC5226]. See Section 14.11.",
      "ja": "新しいオーバーレイプロトコルは、標準アクション[RFC5226]を介して定義する必要があります。セクション14.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.6.1.1. HIP",
      "section_title": true,
      "ja": "6.6.1.1. ヒップ"
    },
    {
      "indent": 3,
      "text": "In a Host Identity Protocol Based Overlay Networking Environment (HIP BONE) [RFC6079], HIP [RFC5201] provides connection management (e.g., NAT traversal and mobility) and security for the overlay network. The P2PSIP Working Group has expressed interest in supporting a HIP-based link protocol. Such support would require specifying such details as:",
      "ja": "ホストアイデンティティプロトコルベースのオーバーレイネットワーキング環境（HIPボーン）[RFC6079]では、HIP [RFC5201]は、オーバーレイネットワークに接続管理（NATトラバーサルやモビリティなど）とセキュリティを提供します。 P2PSIPワーキンググループは、HIPベースのリンクプロトコルのサポートに関心を示しています。このようなサポートでは、次のような詳細を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o How to issue certificates which provide identities meaningful to the HIP base exchange. We anticipate that this would require a mapping between Overlay Routable Cryptographic Hash Identifiers (ORCHIDs) and NodeIds.",
      "ja": "o HIPベース交換に意味のあるIDを提供する証明書を発行する方法。これには、オーバーレイルーティング可能な暗号化ハッシュ識別子（ORCHID）とNodeIdの間のマッピングが必要になると予想しています。"
    },
    {
      "indent": 3,
      "text": "o How to carry the HIP I1 and I2 messages.",
      "ja": "o HIP I1およびI2メッセージの伝送方法。"
    },
    {
      "indent": 3,
      "text": "o How to carry RELOAD messages over HIP.",
      "ja": "o HIPを介してRELOADメッセージを伝送する方法。"
    },
    {
      "indent": 3,
      "text": "[HIP-RELOAD] documents work in progress on using RELOAD with the HIP BONE.",
      "ja": "[HIP-RELOAD]ドキュメントは、HIP BONEでRELOADを使用する際に進行中です。"
    },
    {
      "indent": 0,
      "text": "6.6.1.2. ICE-TCP",
      "section_title": true,
      "ja": "6.6.1.2. ICE-TCP"
    },
    {
      "indent": 3,
      "text": "The ICE-TCP RFC [RFC6544] allows TCP to be supported as an Overlay Link protocol that can be added using ICE.",
      "ja": "ICE-TCP RFC [RFC6544]では、ICEを使用して追加できるオーバーレイリンクプロトコルとしてTCPをサポートできます。"
    },
    {
      "indent": 0,
      "text": "6.6.1.3. Message-Oriented Transports",
      "section_title": true,
      "ja": "6.6.1.3. メッセージ指向のトランスポート"
    },
    {
      "indent": 3,
      "text": "Modern message-oriented transports offer high performance and good congestion control, and they avoid head-of-line blocking in case of lost data. These characteristics make them preferable as underlying transport protocols for RELOAD links. SCTP without message ordering and DCCP are two examples of such protocols. However, currently they are not well-supported by commonly available NATs, and specifications for ICE session establishment are not available.",
      "ja": "最新のメッセージ指向のトランスポートは、高いパフォーマンスと優れた輻輳制御を提供し、データが失われた場合にヘッドオブラインブロッキングを回避します。これらの特性により、RELOADリンクの基礎となるトランスポートプロトコルとして好ましいものになっています。メッセージの順序付けのないSCTPとDCCPは、そのようなプロトコルの2つの例です。ただし、現在それらは一般的に利用可能なNATでは十分にサポートされておらず、ICEセッション確立の仕様は利用できません。"
    },
    {
      "indent": 0,
      "text": "6.6.1.4. Tunneled Transports",
      "section_title": true,
      "ja": "6.6.1.4. トンネルトランスポート"
    },
    {
      "indent": 0,
      "text": " As of the time of this writing, there is significant interest in the IETF community in tunneling other transports over UDP, which is motivated by the situation that UDP is well-supported by modern NAT hardware and by the fact that performance similar to a native implementation can be achieved. Currently, SCTP, DCCP, and a generic tunneling extension are being proposed for message-oriented protocols. Once ICE traversal has been specified for these tunneled protocols, they should be straightforward to support as overlay link protocols.",
      "ja": "この記事の執筆時点では、UDPを介して他のトランスポートをトンネリングすることに関してIETFコミュニティに大きな関心が寄せられています。これは、UDPが最新のNATハードウェアによって十分にサポートされているという状況と、ネイティブ実装と同様のパフォーマンスという事実が動機です達成することができます。現在、SCTP、DCCP、および一般的なトンネリング拡張機能が、メッセージ指向プロトコル用に提案されています。これらのトンネルプロトコルに対してICEトラバーサルを指定すると、オーバーレイリンクプロトコルとしてサポートするのが簡単になります。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Framing Header",
      "section_title": true,
      "ja": "6.6.2. フレーミングヘッダー"
    },
    {
      "indent": 3,
      "text": "In order to support unreliable links and to allow for quick detection of link failures when using reliable end-to-end transports, each message is wrapped in a very simple framing layer (FramedMessage), which is used only for each hop. This layer contains a sequence number which can then be used for ACKs. The same header is used for both reliable and unreliable transports for simplicity of implementation.",
      "ja": "信頼性の低いリンクをサポートし、信頼性の高いエンドツーエンドのトランスポートを使用するときにリンク障害をすばやく検出できるようにするために、各メッセージは非常に単純なフレーミングレイヤー（FramedMessage）でラップされ、ホップごとにのみ使用されます。この層には、ACKに使用できるシーケンス番号が含まれています。実装を簡単にするために、信頼できるトランスポートと信頼できないトランスポートの両方に同じヘッダーが使用されます。"
    },
    {
      "indent": 3,
      "text": "The definition of FramedMessage is:",
      "ja": "FramedMessageの定義は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "enum { data(128), ack(129), (255) } FramedMessageType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  FramedMessageType       type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "select (type) {\n  case data:\n    uint32              sequence;\n    opaque              message<0..2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "    case ack:\n      uint32              ack_sequence;\n      uint32              received;\n  };\n} FramedMessage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The type field of the PDU is set to indicate whether the message is data or an acknowledgement.",
      "ja": "PDUのタイプフィールドは、メッセージがデータか確認応答かを示すために設定されます。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"data\", then the remainder of the PDU is as follows:",
      "ja": "メッセージのタイプが「データ」の場合、PDUの残りは次のようになります。"
    },
    {
      "indent": 3,
      "text": "sequence The sequence number. This increments by one for each framed message sent over this transport session.",
      "ja": "sequenceシーケンス番号。これは、このトランスポートセッションで送信されたフレームメッセージごとに1ずつ増加します。"
    },
    {
      "indent": 3,
      "text": "message The message that is being transmitted.",
      "ja": "message送信されているメッセージ。"
    },
    {
      "indent": 3,
      "text": "Each connection has it own sequence number space. Initially, the value is zero, and it increments by exactly one for each message sent over that connection.",
      "ja": "各接続には、独自のシーケンス番号スペースがあります。最初、値はゼロであり、その接続を介して送信されるメッセージごとに正確に1ずつ増加します。"
    },
    {
      "indent": 3,
      "text": "When the receiver receives a message, it SHOULD immediately send an ACK message. The receiver MUST keep track of the 32 most recent sequence numbers received on this association in order to generate the appropriate ACK.",
      "ja": "受信者がメッセージを受信すると、すぐにACKメッセージを送信する必要があります（SHOULD）。受信者は、適切なACKを生成するために、この関連付けで受信した最新の32のシーケンス番号を追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the PDU is of type \"ack\", the contents are as follows:",
      "ja": "PDUのタイプが「ack」の場合、内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ack_sequence The sequence number of the message being acknowledged.",
      "ja": "ack_sequence確認されるメッセージのシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "received A bitmask indicating if each of the previous 32 sequence numbers before this packet has been among the 32 packets most recently received on this connection. When a packet is received with a sequence number N, the receiver looks at the sequence number of the 32 previously received packets on this connection. We call the previously received packet number M. For each of the previous 32 packets, if the sequence number M is less than N but greater than N-32, the N-M bit of the received bitmask is set to one; otherwise, it is set to zero. Note that a bit being set to one indicates positively that a particular packet was received, but a bit being set to zero means only that it is unknown whether or not the packet has been received, because it might have been received before the 32 most recently received packets.",
      "ja": "受信このパケットの前の直前の32シーケンス番号のそれぞれが、この接続で最後に受信された32パケットの中にあるかどうかを示すビットマスク。シーケンス番号Nのパケットが受信されると、レシーバーはこの接続で以前に受信した32個のパケットのシーケンス番号を調べます。以前に受信したパケット番号をMと呼びます。以前の32パケットのそれぞれについて、シーケンス番号MがN未満でN-32より大きい場合、受信したビットマスクのN-Mビットは1に設定されます。それ以外の場合は、ゼロに設定されます。ビットが1に設定されていると、特定のパケットが受信されたことが明確に示されますが、ビットが0に設定されていると、パケットが受信されたかどうか不明であることに注意してください。受信したパケット。"
    },
    {
      "indent": 3,
      "text": "The received field bits in the ACK provide a high degree of redundancy so that the sender can figure out which packets the receiver has received and can then estimate packet loss rates. If the sender also keeps track of the time at which recent sequence numbers have been sent, the RTT (round-trip time) can be estimated.",
      "ja": "ACKの受信フィールドビットは高度な冗長性を提供するため、送信者は受信者が受信したパケットを把握し、パケット損失率を推定できます。送信者が最近のシーケンス番号が送信された時刻も追跡している場合は、RTT（往復時間）を推定できます。"
    },
    {
      "indent": 3,
      "text": "Note that because retransmissions receive new sequence numbers, multiple ACKs may be received for the same message. This approach provides more information than traditional TCP sequence numbers, but care must be taken when applying algorithms designed based on TCP's stream-oriented sequence number.",
      "ja": "再送信は新しいシーケンス番号を受信するため、同じメッセージに対して複数のACKが受信される可能性があることに注意してください。このアプローチは、従来のTCPシーケンス番号よりも多くの情報を提供しますが、TCPのストリーム指向のシーケンス番号に基づいて設計されたアルゴリズムを適用するときは注意が必要です。"
    },
    {
      "indent": 0,
      "text": "6.6.3. Simple Reliability",
      "section_title": true,
      "ja": "6.6.3. シンプルな信頼性"
    },
    {
      "indent": 3,
      "text": "When RELOAD is carried over DTLS or another unreliable link protocol, it needs to be used with a reliability and congestion control mechanism, which is provided on a hop-by-hop basis. The basic principle is that each message, regardless of whether or not it carries a request or response, will get an ACK and be reliably retransmitted. The receiver's job is very simple, and is limited to just sending ACKs. All the complexity is at the sender side. This allows the sending implementation to trade off performance versus implementation complexity without affecting the wire protocol.",
      "ja": "RELOADがDTLSまたはその他の信頼性の低いリンクプロトコルで実行される場合、ホップバイホップベースで提供される信頼性と輻輳制御メカニズムと共に使用する必要があります。基本的な原則は、各メッセージは、要求または応答を運ぶかどうかに関係なく、ACKを取得し、確実に再送信されることです。受信者の仕事は非常に単純で、ACKの送信だけに制限されています。すべての複雑さは送信側にあります。これにより、送信側の実装は、ワイヤプロトコルに影響を与えることなく、パフォーマンスと実装の複雑さをトレードオフできます。"
    },
    {
      "indent": 3,
      "text": "Because the receiver's role is limited to providing packet acknowledgements, a wide variety of congestion control algorithms can be implemented on the sender side while using the same basic wire protocol. The sender algorithm used MUST meet the requirements of [RFC5405].",
      "ja": "受信側の役割はパケット確認応答の提供に限定されているため、同じ基本的なワイヤープロトコルを使用しながら、さまざまな輻輳制御アルゴリズムを送信側に実装できます。使用される送信者アルゴリズムは[RFC5405]の要件を満たさなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.3.1. Stop and Wait Sender Algorithm",
      "section_title": true,
      "ja": "6.6.3.1. 送信者アルゴリズムの停止と待機"
    },
    {
      "indent": 3,
      "text": "This section describes one possible implementation of a sender algorithm for Simple Reliability. It is adequate for overlays running on underlying networks with low latency and loss (LANs) or low-traffic overlays on the Internet.",
      "ja": "このセクションでは、シンプル信頼性の送信アルゴリズムの可能な実装の1つについて説明します。低レイテンシとロス（LAN）の基盤となるネットワークで実行されているオーバーレイや、インターネット上のトラフィックの少ないオーバーレイに適しています。"
    },
    {
      "indent": 3,
      "text": "A node MUST NOT have more than one unacknowledged message on the DTLS connection at a time. Note that because retransmissions of the same message are given new sequence numbers, there may be multiple unacknowledged sequence numbers in use.",
      "ja": "ノードは、一度に複数の未確認メッセージをDTLS接続上に持つことはできません。同じメッセージの再送信には新しいシーケンス番号が与えられるため、複数の未確認のシーケンス番号が使用されている可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The RTO (Retransmission TimeOut) is based on an estimate of the RTT. The value for RTO is calculated separately for each DTLS session. Implementations can use a static value for RTO or a dynamic estimate, which will result in better performance. For implementations that use a static value, the default value for RTO is 500 ms. Nodes MAY use smaller values of RTO if it is known that all nodes are within the local network. The default RTO MAY be set to a larger value, which is RECOMMENDED if it is known in advance (such as on high-latency access links) that the RTT is larger.",
      "ja": "RTO（再送信タイムアウト）は、RTTの推定に基づいています。 RTOの値は、DTLSセッションごとに個別に計算されます。実装では、RTOの静的な値または動的な見積もりを使用できます。これにより、パフォーマンスが向上します。静的な値を使用する実装の場合、RTOのデフォルト値は500ミリ秒です。すべてのノードがローカルネットワーク内にあることがわかっている場合、ノードはより小さな値のRTOを使用できます。デフォルトのRTOはより大きな値に設定される場合があり（MAY）、事前に（高遅延アクセスリンクなどで）RTTが大きいことがわかっている場合に推奨されます。"
    },
    {
      "indent": 3,
      "text": "Implementations that use a dynamic estimate to compute the RTO MUST use the algorithm described in RFC 6298 [RFC6298], with the exception that the value of RTO SHOULD NOT be rounded up to the nearest second, but instead rounded up to the nearest millisecond. The RTT of a successful STUN transaction from the ICE stage is used as the initial measurement for formula 2.2 of RFC 6298. The sender keeps track of the time each message was sent for all recently sent messages. Any time an ACK is received, the sender can compute the RTT for that message by looking at the time the ACK was received and the time when the message was sent. This is used as a subsequent RTT measurement for formula 2.3 of RFC 6298 to update the RTO estimate. (Note that because retransmissions receive new sequence numbers, all received ACKs are used.)",
      "ja": "動的推定を使用してRTOを計算する実装は、RFC 6298 [RFC6298]で説明されているアルゴリズムを使用する必要があります。ただし、RTOの値は最も近い秒に切り上げられるべきではなく、最も近いミリ秒に切り上げられる必要があります。 ICEステージからの成功したSTUNトランザクションのRTTは、RFC 6298の式2.2の初期測定値として使用されます。送信者は、最近送信されたすべてのメッセージに対して各メッセージが送信された時間を追跡します。 ACKが受信されると、送信者はACKが受信された時刻とメッセージが送信された時刻を確認することで、そのメッセージのRTTを計算できます。これは、RTO見積もりを更新するために、RFC 6298の式2.3の後続のRTT測定として使用されます。 （再送信は新しいシーケンス番号を受信するため、受信したすべてのACKが使用されることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "An initiating node SHOULD retransmit a message if it has not received an ACK after an interval of RTO (transit nodes do not retransmit at this layer). The node MUST double the time to wait after each retransmission. For each retransmission, the sequence number MUST be incremented.",
      "ja": "開始ノードは、RTOの間隔後にACKを受信しなかった場合、メッセージを再送信する必要があります（中継ノードはこの層で再送信しません）。ノードは、各再送信後に待機する時間を2倍にする必要があります。再送信ごとに、シーケンス番号をインクリメントする必要があります。"
    },
    {
      "indent": 3,
      "text": "Retransmissions continue until a response is received, until a total of 5 requests have been sent, until there has been a hard ICMP error [RFC1122], or until a TLS alert indicating the end of the connection has been sent or received. The sender knows a response was received when it receives an ACK with a sequence number that indicates it is a response to one of the transmissions of this message. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, and 7500 ms. If all retransmissions for a message fail, then the sending node SHOULD close the connection routing the message.",
      "ja": "再送信は、応答が受信されるまで、合計5つの要求が送信されるまで、ハードICMPエラー[RFC1122]が発生するまで、または接続の終了を示すTLSアラートが送信または受信されるまで続きます。送信者は、このメッセージの送信の1つに対する応答であることを示すシーケンス番号を含むACKを受信すると、応答が受信されたことを認識します。たとえば、RTOが500ミリ秒の場合、リクエストは0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒の時間に送信されます。メッセージのすべての再送信が失敗した場合、送信ノードはメッセージをルーティングする接続を閉じる必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "To determine when a link might be failing without waiting for the final timeout, observe when no ACKs have been received for an entire RTO interval, and then wait for three retransmissions to occur beyond that point. If no ACKs have been received by the time the third retransmission occurs, it is RECOMMENDED that the link be removed from the Routing Table. The link MAY be restored to the Routing Table if ACKs resume before the connection is closed, as described above.",
      "ja": "最終タイムアウトを待たずにリンクに障害が発生している可能性があるかどうかを判断するには、RTOインターバル全体にわたってACKが受信されなかった場合を観察し、そのポイントを超えて3回の再送信が発生するまで待ちます。 3回目の再送信が行われるまでにACKが受信されない場合は、リンクをルーティングテーブルから削除することをお勧めします。上記のように、接続が閉じられる前にACKが再開した場合、リンクはルーティングテーブルに復元される場合があります。"
    },
    {
      "indent": 3,
      "text": "A sender MUST wait 10 ms between receipt of an ACK and transmission of the next message.",
      "ja": "送信者は、ACKの受信と次のメッセージの送信との間に10ミリ秒待機する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.4. DTLS/UDP with SR",
      "section_title": true,
      "ja": "6.6.4. SRを使用したDTLS / UDP"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of DTLS over UDP while implementing the SR protocol. STUN connectivity checks and keepalives are used. Any compliant sender algorithm may be used.",
      "ja": "このオーバーレイリンクプロトコルは、SRプロトコルを実装しながら、DTLS over UDPで構成されています。 STUN接続チェックとキープアライブが使用されます。準拠する送信者アルゴリズムを使用できます。"
    },
    {
      "indent": 0,
      "text": "6.6.5. TLS/TCP with FH, No-ICE",
      "section_title": true,
      "ja": "6.6.5. FH付きTLS / TCP、No-ICE"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of TLS over TCP with the framing header. Because ICE is not used, STUN connectivity checks are not used upon establishing the TCP connection, nor are they used for keepalives.",
      "ja": "このオーバーレイリンクプロトコルは、フレーミングヘッダーを備えたTLS over TCPで構成されています。 ICEは使用されないため、TCP接続の確立時にSTUN接続チェックは使用されず、キープアライブにも使用されません。"
    },
    {
      "indent": 3,
      "text": "Because the TCP layer's application-level timeout is too slow to be useful for overlay routing, the Overlay Link implementation MUST use the framing header to measure the RTT of the connection and calculate an RTO as specified in Section 2 of [RFC6298]. The resulting RTO is not used for retransmissions, but rather as a timeout to indicate when the link SHOULD be removed from the Routing Table. It is RECOMMENDED that such a connection be retained for 30 seconds to determine if the failure was transient before concluding the link has failed permanently.",
      "ja": "TCPレイヤのアプリケーションレベルのタイムアウトは遅すぎてオーバーレイルーティングに役立たないため、オーバーレイリンクの実装では、フレーミングヘッダーを使用して接続のRTTを測定し、[RFC6298]のセクション2で指定されているRTOを計算する必要があります。結果のRTOは再送信に使用されませんが、リンクがルーティングテーブルから削除されるべきであるときに示すタイムアウトとして使用されます。そのような接続を30秒間保持して、リンクが永続的に失敗したと結論付ける前に、一時的な障害かどうかを判断することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When sending candidates for TLS/TCP with FH, No-ICE, a passive candidate MUST be provided.",
      "ja": "FH、No-ICEを使用してTLS / TCPの候補を送信する場合、パッシブ候補を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.6. DTLS/UDP with SR, No-ICE",
      "section_title": true,
      "ja": "6.6.6. SR付きDTLS / UDP、No-ICE"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of DTLS over UDP while implementing the Simple Reliability protocol. Because ICE is not used, no STUN connectivity checks or keepalives are used.",
      "ja": "このオーバーレイリンクプロトコルは、シンプル信頼性プロトコルを実装しながら、DTLS over UDPで構成されています。 ICEは使用されないため、STUN接続チェックまたはキープアライブは使用されません。"
    },
    {
      "indent": 0,
      "text": "6.7. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.7. 断片化と再構成"
    },
    {
      "indent": 3,
      "text": "In order to allow transmission over datagram protocols such as DTLS, RELOAD messages may be fragmented.",
      "ja": "DTLSなどのデータグラムプロトコルを介した送信を可能にするために、RELOADメッセージはフラグメント化される場合があります。"
    },
    {
      "indent": 3,
      "text": "Any node along the path can fragment the message, but only the final destination reassembles the fragments. When a node takes a packet and fragments it, each fragment has a full copy of the forwarding header, but the data after the forwarding header is broken up into appropriately sized chunks. The size of the payload chunks needs to take into account space to allow the Via and Destination Lists to grow. Each fragment MUST contain a full copy of the Via List, Destination List, and ForwardingOptions and MUST contain at least 256 bytes of the message body. If these elements cannot fit within the MTU of the underlying datagram protocol, RELOAD fragmentation is not performed, and IP-layer fragmentation is allowed to occur. The length field MUST contain the size of the message after fragmentation. When a message MUST be fragmented, it SHOULD be split into equal-sized fragments that are no larger than the Path MTU (PMTU) of the next overlay link minus 32 bytes. This is to allow the Via List to grow before further fragmentation is required.",
      "ja": "パス上のどのノードでもメッセージをフラグメント化できますが、最終的な宛先のみがフラグメントを再構成します。ノードがパケットを受け取ってフラグメント化すると、各フラグメントには転送ヘッダーの完全なコピーが含まれますが、転送ヘッダーの後のデータは適切なサイズのチャンクに分割されます。ペイロードチャンクのサイズは、ViaリストとDestinationリストを拡張できるようにスペースを考慮する必要があります。各フラグメントには、Viaリスト、宛先リスト、およびForwardingOptionsの完全なコピーが含まれている必要があり、少なくとも256バイトのメッセージ本文が含まれている必要があります。これらの要素が基になるデータグラムプロトコルのMTUに収まらない場合、RELOADフラグメンテーションは実行されず、IPレイヤーフラグメンテーションが発生することが許可されます。長さフィールドには、断片化後のメッセージのサイズが含まれている必要があります。メッセージをフラグメント化する必要がある場合は、次のオーバーレイリンクのパスMTU（PMTU）から32バイトを引いた値以下の等しいサイズのフラグメントに分割する必要があります（SHOULD）。これは、さらにフラグメンテーションが必要になる前にViaリストを拡大できるようにするためです。"
    },
    {
      "indent": 3,
      "text": "Note that this fragmentation is not optimal for the end-to-end path -- a message may be refragmented multiple times as it traverses the overlay, but it is assembled only at the final destination. This option has been chosen as it is far easier to implement than end-to-end (e2e) PMTU discovery across an ever-changing overlay and it effectively addresses the reliability issues of relying on IP-layer fragmentation. However, Ping can be used to allow e2e PMTU discovery to be implemented if desired.",
      "ja": "この断片化はエンドツーエンドパスに最適ではないことに注意してください。メッセージはオーバーレイを通過するときに複数回再断片化される可能性がありますが、最終的な宛先でのみ組み立てられます。このオプションが選択されたのは、絶え間なく変化するオーバーレイ全体でエンドツーエンド（e2e）PMTUディスカバリーを実装するよりもはるかに簡単であり、IPレイヤーのフラグメント化に依存するという信頼性の問題に効果的に対処するためです。ただし、Pingを使用すると、必要に応じてe2e PMTU検出を実装できます。"
    },
    {
      "indent": 0,
      "text": " Upon receipt of a fragmented message by the intended peer, the peer holds the fragments in a holding buffer until the entire message has been received. The message is then reassembled into a single message and processed. In order to mitigate denial-of-service (DoS) attacks, receivers SHOULD time out incomplete fragments after the maximum request lifetime (15 seconds). This time was derived from looking at the end-to-end retransmission time and saving fragments long enough for the full end-to-end retransmissions to take place. Ideally, the receiver would have enough buffer space to deal with as many fragments as can arrive in the maximum request lifetime. However, if the receiver runs out of buffer space to reassemble a message, it MUST drop the message.",
      "ja": "目的のピアがフラグメント化されたメッセージを受信すると、メッセージ全体が受信されるまで、ピアはフラグメントを保持バッファーに保持します。その後、メッセージは単一のメッセージに再構成され、処理されます。サービス拒否（DoS）攻撃を緩和するために、受信者は、リクエストの最大存続期間（15秒）後に不完全なフラグメントをタイムアウトする必要があります（SHOULD）。この時間は、エンドツーエンドの再送信時間を確認し、完全なエンドツーエンドの再送信が行われるのに十分な時間フラグメントを保存することから導き出されました。理想的には、レシーバーは、最大のリクエストライフタイムで到着できる限り多くのフラグメントを処理するのに十分なバッファースペースを持つことになります。ただし、メッセージを再構成するためにバッファースペースが不足した場合、メッセージをドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "The fragment field of the forwarding header is used to encode fragmentation information. The offset is the number of bytes between the end of the forwarding header and the start of the data. The first fragment therefore has an offset of 0. The last fragment indicator MUST be appropriately set. If the message is not fragmented, it is simply treated as if it is the only fragment: the last fragment bit is set and the offset is 0, resulting in a fragment value of 0xC0000000.",
      "ja": "転送ヘッダーのフラグメントフィールドは、フラグメンテーション情報をエンコードするために使用されます。オフセットは、転送ヘッダーの終わりとデータの始まりの間のバイト数です。したがって、最初のフラグメントのオフセットは0です。最後のフラグメントインジケーターを適切に設定する必要があります。メッセージが断片化されていない場合、それは単にそれが唯一の断片であるかのように扱われます。最後の断片ビットが設定され、オフセットは0なので、断片値は0xC0000000になります。"
    },
    {
      "indent": 3,
      "text": "Note: The reason for this definition of the fragment field is that originally, the high bit was defined in part of the specification as \"is fragmented\", so there was some specification ambiguity about how to encode messages with only one fragment. This ambiguity was resolved in favor of always encoding as the \"last\" fragment with offset 0, thus simplifying the receiver code path, but resulting in the high bit being redundant. Because messages MUST be set with the high bit set to 1, implementations SHOULD discard any message with it set to 0. Implementations (presumably legacy ones) which choose to accept such messages MUST either ignore the remaining bits or ensure that they are 0. They MUST NOT try to interpret as fragmented messages with the high bit set low.",
      "ja": "注：フラグメントフィールドをこのように定義したのは、元々、仕様の一部でハイビットが「フラグメント化されている」と定義されていたため、フラグメントが1つだけのメッセージをエンコードする方法について、仕様のあいまいさがありました。このあいまいさは常に解決され、オフセット0の「最後の」フラグメントとしてエンコードされるため、レシーバーのコードパスが簡略化されますが、高ビットが冗長になります。メッセージは高ビットを1に設定して設定する必要があるため（MUST）、実装はそれを0に設定してメッセージを破棄する必要があります。そのようなメッセージを受け入れることを選択した実装（おそらくレガシーなもの）は、残りのビットを無視するか、それらが0であることを確認する必要があります。高ビットが低に設定された断片化されたメッセージとして解釈してはいけません。"
    },
    {
      "indent": 0,
      "text": "7. Data Storage Protocol",
      "section_title": true,
      "ja": "7. データストレージプロトコル"
    },
    {
      "indent": 3,
      "text": "RELOAD provides a set of generic mechanisms for storing and retrieving data in the Overlay Instance. These mechanisms can be used for new applications simply by defining new code points and a small set of rules. No new protocol mechanisms are required.",
      "ja": "RELOADは、オーバーレイインスタンスでデータを保存および取得するための一連の一般的なメカニズムを提供します。これらのメカニズムは、新しいコードポイントと小さなルールセットを定義するだけで、新しいアプリケーションに使用できます。新しいプロトコルメカニズムは必要ありません。"
    },
    {
      "indent": 3,
      "text": "The basic unit of stored data is a single StoredData structure:",
      "ja": "保存データの基本単位は、単一のStoredData構造です。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  length;\n  uint64                  storage_time;\n  uint32                  lifetime;\n  StoredDataValue         value;\n  Signature               signature;\n} StoredData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "length The size of the StoredData structure, in bytes, excluding the size of length itself.",
      "ja": "length StoredData構造のサイズ（バイト単位、長さ自体のサイズを除く）。"
    },
    {
      "indent": 3,
      "text": "storage_time The time when the data was stored, represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC, not counting leap seconds. This will have the same values for seconds as standard UNIX or POSIX time. More information can be found at [UnixTime]. Any attempt to store a data value with a storage time before that of a value already stored at this location MUST generate an Error_Data_Too_Old error. This prevents rollback attacks. The node SHOULD make a best-effort attempt to use a correct clock to determine this number. However, the protocol does not require synchronized clocks: the receiving peer uses the storage time in the previous store, not its own clock. Clock values are used so that when clocks are generally synchronized, data may be stored in a single transaction, rather than querying for the value of a counter before the actual store.",
      "ja": "storage_timeデータが保存された時刻。1970年1月1日午前0時からのミリ秒数で表され、うるう秒はカウントされません。これは、標準のUNIXまたはPOSIX時間と同じ秒の値になります。詳細については、[UnixTime]を参照してください。この場所にすでに格納されている値よりも前の格納時間でデータ値を格納しようとすると、Error_Data_Too_Oldエラーが生成される必要があります。これにより、ロールバック攻撃が防止されます。ノードは、この数を決定するために正しいクロックを使用するように最善の努力をする必要があります。ただし、プロトコルは同期クロックを必要としません。受信ピアは、自身のクロックではなく、前のストアのストレージ時間を使用します。クロック値は、クロックが一般的に同期されている場合、実際のストアの前にカウンターの値を照会するのではなく、単一のトランザクションでデータを格納できるようにするために使用されます。"
    },
    {
      "indent": 6,
      "text": "If a node attempting to store new data in response to a user request (rather than as an overlay maintenance operation such as occurs when healing the overlay from a partition) is rejected with an Error_Data_Too_Old error, the node MAY elect to perform its store using a storage_time that increments the value used with the previous store (this may be obtained by doing a Fetch). This situation may occur when the clocks of nodes storing to this location are not properly synchronized.",
      "ja": "（パーティションからオーバーレイを修復するときに発生するようなオーバーレイメンテナンス操作としてではなく）ユーザー要求に応じて新しいデータを保存しようとするノードがError_Data_Too_Oldエラーで拒否された場合、ノードは、前のストアで使用された値をインクリメントするstorage_time（これはFetchを実行することで取得できます）。この状況は、この場所に格納されているノードのクロックが適切に同期されていない場合に発生することがあります。"
    },
    {
      "indent": 3,
      "text": "lifetime The validity period for the data, in seconds, starting from the time the peer receives the StoreReq.",
      "ja": "ピアがStoreReqを受信したときから始まる、データの有効期間（秒単位）。"
    },
    {
      "indent": 3,
      "text": "value The data value itself, as described in Section 7.2.",
      "ja": "value 7.2で説明されているデータ値自体。"
    },
    {
      "indent": 3,
      "text": "signature A signature, as defined in Section 7.1.",
      "ja": "署名セクション7.1で定義されている署名。"
    },
    {
      "indent": 3,
      "text": "Each Resource-ID specifies a single location in the Overlay Instance. However, each location may contain multiple StoredData values, distinguished by Kind-ID. The definition of a Kind describes both the data values which may be stored and the data model of the data. Some data models allow multiple values to be stored under the same Kind-ID. Section 7.2 describes the available data models. Thus, for instance, a given Resource-ID might contain a single-value element stored under Kind-ID X and an array containing multiple values stored under Kind-ID Y.",
      "ja": "各Resource-IDは、オーバーレイインスタンスの単一の場所を指定します。ただし、各場所には、Kind-IDで区別された複数のStoredData値が含まれる場合があります。種類の定義は、格納できるデータ値とデータのデータモデルの両方を記述します。一部のデータモデルでは、複数の値を同じKind-IDで保存できます。セクション7.2では、使用可能なデータモデルについて説明します。したがって、たとえば、特定のResource-IDには、Kind-ID Xに格納された単一値要素と、Kind-ID Yに格納された複数の値を含む配列が含まれる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1. Data Signature Computation",
      "section_title": true,
      "ja": "7.1. データ署名の計算"
    },
    {
      "indent": 3,
      "text": "Each StoredData element is individually signed. However, the signature also must be self-contained and must cover the Kind-ID and Resource-ID, even though they are not present in the StoredData structure. The input to the signature algorithm is:",
      "ja": "各StoredData要素は個別に署名されます。ただし、StoredData構造に存在しない場合でも、署名は自己完結型である必要があり、Kind-IDとResource-IDをカバーする必要があります。署名アルゴリズムへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "resource_id || kind || storage_time || StoredDataValue || SignerIdentity",
      "ja": "resource_id ||種類|| storage_time || StoredDataValue || SignerIdentity"
    },
    {
      "indent": 3,
      "text": "where || indicates concatenation and where these values are:",
      "ja": "どこ||連結とこれらの値の場所を示します。"
    },
    {
      "indent": 3,
      "text": "resource_id The Resource-ID where this data is stored.",
      "ja": "resource_idこのデータが保存されているリソースID。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID for this data.",
      "ja": "kindこのデータの種類ID。"
    },
    {
      "indent": 3,
      "text": "storage_time The contents of the storage_time data value.",
      "ja": "storage_time storage_timeデータ値の内容。"
    },
    {
      "indent": 3,
      "text": "StoredDataValue The contents of the stored data value, as described in the previous sections.",
      "ja": "StoredDataValue前のセクションで説明したように、保存されたデータ値の内容。"
    },
    {
      "indent": 3,
      "text": "SignerIdentity The signer identity, as defined in Section 6.3.4.",
      "ja": "SignerIdentity 6.3.4項で定義されている署名者ID。"
    },
    {
      "indent": 3,
      "text": "Once the signature has been computed, the signature is represented using a signature element, as described in Section 6.3.4.",
      "ja": "署名が計算されると、6.3.4で説明されているように、署名は署名要素を使用して表されます。"
    },
    {
      "indent": 3,
      "text": "Note that there is no necessary relationship between the validity window of a certificate and the expiry of the data it is authenticating. When signatures are verified, the current time MUST be compared to the certificate validity period. Stored data MAY be set to expire after the signing certificate's validity period. Such signatures are not considered valid after the signing certificate expires. Implementations may \"garbage collect\" such data at their convenience, either by purging it automatically (perhaps by setting the upper bound on data storage to the lifetime of the signing certificate) or by simply leaving it in place until it expires naturally and relying on users of that data to notice the expired signing certificate.",
      "ja": "証明書の有効期間と認証するデータの有効期限の間には、必要な関係がないことに注意してください。署名が検証されたら、現在の時刻を証明書の有効期間と比較する必要があります。保存されたデータは、署名証明書の有効期間が過ぎると期限が切れるように設定できます。このような署名は、署名証明書の有効期限が切れると有効とは見なされません。実装は、自動的に（おそらく、データストレージの上限を署名証明書の有効期間に設定することによって）または自然に期限が切れてユーザーに依存するまでそのままにしておくことにより、そのようなデータを都合のよいときに「ガベージコレクション」することができます。期限切れの署名証明書に気づくためのそのデータの。"
    },
    {
      "indent": 0,
      "text": "7.2. Data Models",
      "section_title": true,
      "ja": "7.2. データモデル"
    },
    {
      "indent": 3,
      "text": "The protocol currently defines the following data models:",
      "ja": "プロトコルは現在、次のデータモデルを定義しています。"
    },
    {
      "indent": 3,
      "text": "o single value",
      "ja": "o 単一の値"
    },
    {
      "indent": 3,
      "text": "o array",
      "ja": "o アレイ"
    },
    {
      "indent": 3,
      "text": "o dictionary",
      "ja": "o 辞書"
    },
    {
      "indent": 3,
      "text": "These are represented with the StoredDataValue structure. The actual data model is known from the Kind being stored.",
      "ja": "これらはStoredDataValue構造で表されます。実際のデータモデルは、保存されている種類からわかります。"
    },
    {
      "indent": 8,
      "text": "struct {\n  Boolean                exists;\n  opaque                 value<0..2^32-1>;\n} DataValue;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  select (DataModel) {\n    case single_value:\n      DataValue             single_value_entry;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case array: ArrayEntry array_entry;",
      "ja": "ケース配列：ArrayEntry array_entry;"
    },
    {
      "indent": 12,
      "text": "case dictionary: DictionaryEntry dictionary_entry;",
      "ja": "ケース辞書：DictionaryEntry dictionary_entry;"
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended */\n  };\n} StoredDataValue;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following sections discuss the properties of each data model.",
      "ja": "次のセクションでは、各データモデルのプロパティについて説明します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Single Value",
      "section_title": true,
      "ja": "7.2.1. 単一の値"
    },
    {
      "indent": 3,
      "text": "A single-value element is a simple sequence of bytes. There may be only one single-value element for each Resource-ID, Kind-ID pair.",
      "ja": "単一値要素は、単純なバイトのシーケンスです。 Resource-IDとKind-IDのペアごとに1つの単一値要素のみが存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "A single value element is represented as a DataValue, which contains the following two elements:",
      "ja": "単一の値要素は、次の2つの要素を含むDataValueとして表されます。"
    },
    {
      "indent": 3,
      "text": "exists This value indicates whether the value exists at all. If it is set to False, it means that no value is present. If it is True, this means that a value is present. This gives the protocol a mechanism for indicating nonexistence as opposed to emptiness.",
      "ja": "existsこの値は、値が存在するかどうかを示します。 Falseに設定されている場合、値が存在しないことを意味します。 Trueの場合、これは値が存在することを意味します。これは、空ではなく存在しないことを示すメカニズムをプロトコルに与えます。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "value保存されているデータ。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Array",
      "section_title": true,
      "ja": "7.2.2. アレイ"
    },
    {
      "indent": 3,
      "text": "An array is a set of opaque values addressed by an integer index. Arrays are zero based. Note that arrays can be sparse. For instance, a Store of \"X\" at index 2 in an empty array produces an array with the values [ NA, NA, \"X\"]. Future attempts to fetch elements at index 0 or 1 will return values with \"exists\" set to False.",
      "ja": "配列は、整数のインデックスによってアドレス指定された不透明な値のセットです。配列はゼロベースです。配列はスパースになる可能性があることに注意してください。たとえば、空の配列のインデックス2の「X」のStoreは、値[NA、NA、 \"X\"]の配列を生成します。インデックス0または1で要素をフェッチしようとすると、 \"exists\"がFalseに設定された値が返されます。"
    },
    {
      "indent": 3,
      "text": "An array element is represented as an ArrayEntry:",
      "ja": "配列要素はArrayEntryとして表されます。"
    },
    {
      "indent": 9,
      "text": "struct {\n  uint32                  index;\n  DataValue               value;\n} ArrayEntry;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "index The index of the data element in the array.",
      "ja": "index配列内のデータ要素のインデックス。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "value保存されているデータ。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Dictionary",
      "section_title": true,
      "ja": "7.2.3. 辞書"
    },
    {
      "indent": 3,
      "text": "A dictionary is a set of opaque values indexed by an opaque key, with one value for each key. A single dictionary entry is represented as a DictionaryEntry:",
      "ja": "辞書は、不透明なキーによってインデックスが付けられた一連の不透明な値であり、キーごとに1つの値があります。単一の辞書エントリは、DictionaryEntryとして表されます。"
    },
    {
      "indent": 9,
      "text": "typedef opaque           DictionaryKey<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n  DictionaryKey          key;\n  DataValue              value;\n} DictionaryEntry;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "key The dictionary key for this value.",
      "ja": "keyこの値の辞書キー。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "value保存されているデータ。"
    },
    {
      "indent": 0,
      "text": "7.3. Access Control Policies",
      "section_title": true,
      "ja": "7.3. アクセス制御ポリシー"
    },
    {
      "indent": 3,
      "text": "Every Kind which is storable in an overlay MUST be associated with an access control policy. This policy defines whether a request from a given node to operate on a given value should succeed or fail. It is anticipated that only a small number of generic access control policies are required. To that end, this section describes a small set of such policies, and Section 14.4 establishes a registry for new policies, if required. Each policy has a short string identifier which is used to reference it in the Configuration Document.",
      "ja": "オーバーレイに格納できるすべての種類は、アクセス制御ポリシーに関連付けられている必要があります。このポリシーは、特定のノードから特定の値を操作する要求が成功するか失敗するかを定義します。少数の一般的なアクセス制御ポリシーのみが必要であると予想されます。そのため、このセクションではそのようなポリシーの小さなセットについて説明し、必要に応じてセクション14.4で新しいポリシーのレジストリを確立します。各ポリシーには、構成ドキュメントでそれを参照するために使用される短い文字列識別子があります。"
    },
    {
      "indent": 3,
      "text": "In the following policies, the term \"signer\" refers to the signer of the StoredValue object and, in the case of non-replica stores, to the signer of the StoreReq message. That is, in a non-replica store, both the signer of the StoredValue and the signer of the StoreReq MUST conform to the policy. In the case of a replica store, the signer of the StoredValue MUST conform to the policy, and the StoreReq itself MUST be checked as described in Section 7.4.1.1.",
      "ja": "以下のポリシーでは、「署名者」という用語はStoredValueオブジェクトの署名者を指し、非レプリカストアの場合はStoreReqメッセージの署名者を指します。つまり、非レプリカストアでは、StoredValueの署名者とStoreReqの署名者の両方がポリシーに準拠する必要があります。レプリカストアの場合、StoredValueの署名者はポリシーに準拠する必要があり、7.4.1.1で説明されているようにStoreReq自体をチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.1. USER-MATCH",
      "section_title": true,
      "ja": "7.3.1. ユーザーマッチ"
    },
    {
      "indent": 3,
      "text": "In the USER-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. Recall that the certificate may, depending on the overlay configuration, be self-signed.",
      "ja": "USER-MATCHポリシーでは、署名者の証明書がリソースのResource-IDに（オーバーレイのハッシュ関数を使用して）ハッシュするユーザー名を持っている場合にのみ、特定の値を書き込む（または上書きする）必要があります。証明書は、オーバーレイ構成によっては自己署名される場合があることを思い出してください。"
    },
    {
      "indent": 0,
      "text": "7.3.2. NODE-MATCH",
      "section_title": true,
      "ja": "7.3.2. のでーまＴＣＨ"
    },
    {
      "indent": 3,
      "text": "In the NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a specified Node-ID which hashes (using the hash function for the overlay) to the Resource-ID for the resource and that Node-ID is the one indicated in the SignerIdentity value cert_hash.",
      "ja": "NODE-MATCHポリシーでは、署名者の証明書に、リソースのResource-IDに（オーバーレイのハッシュ関数を使用して）ハッシュする指定されたNode-IDがある場合にのみ、特定の値を書き込む（または上書きする）必要があります。そのノードIDは、SignerIdentity値cert_hashで示されているものです。"
    },
    {
      "indent": 0,
      "text": "7.3.3. USER-NODE-MATCH",
      "section_title": true,
      "ja": "7.3.3. ユーザーノードマッチ"
    },
    {
      "indent": 3,
      "text": "The USER-NODE-MATCH policy may be used only with dictionary types. In the USER-NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. In addition, the dictionary key MUST be equal to the Node-ID in the certificate, and that Node-ID MUST be the one indicated in the SignerIdentity value cert_hash.",
      "ja": "USER-NODE-MATCHポリシーは、辞書タイプでのみ使用できます。 USER-NODE-MATCHポリシーでは、署名者の証明書に（オーバーレイのハッシュ関数を使用して）リソースのResource-IDにハッシュするユーザー名がある場合にのみ、特定の値を書き込む（または上書きする）必要があります。さらに、ディクショナリキーは証明書のノードIDと同じである必要があり、そのノードIDはSignerIdentity値cert_hashで示されているものである必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.4. NODE-MULTIPLE",
      "section_title": true,
      "ja": "7.3.4. のでーむＬちＰぇ"
    },
    {
      "indent": 3,
      "text": "In the NODE-MULTIPLE policy, a given value MUST be written (or overwritten) if and only if the signer's certificate contains a Node-ID such that H(Node-ID || i) is equal to the Resource-ID for some small integer value of i and that Node-ID is the one indicated in the SignerIdentity value cert_hash. When this policy is in use, the maximum value of i MUST be specified in the Kind definition.",
      "ja": "NODE-MULTIPLEポリシーでは、H（Node-ID || i）が小さなリソースIDに等しいようなノードIDが署名者の証明書に含まれている場合にのみ、特定の値を書き込む（または上書きする）必要がありますiの整数値とそのノードIDは、SignerIdentity値cert_hashに示されているものです。このポリシーが使用されている場合、iの最大値を種類の定義で指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that because i is not carried on the wire, the verifier MUST iterate through potential i values, up to the maximum value, to determine whether a store is acceptable.",
      "ja": "iはネットワーク上で運ばれないため、検証者は、ストアが受け入れ可能かどうかを判断するために、最大値までの潜在的なi値を反復しなければならない（MUST）。"
    },
    {
      "indent": 0,
      "text": "7.4. Data Storage Methods",
      "section_title": true,
      "ja": "7.4. データ保存方法"
    },
    {
      "indent": 3,
      "text": "RELOAD provides several methods for storing and retrieving data:",
      "ja": "RELOADは、データを格納および取得するためのいくつかの方法を提供します。"
    },
    {
      "indent": 3,
      "text": "o Store values in the overlay.",
      "ja": "o オーバーレイに値を格納します。"
    },
    {
      "indent": 3,
      "text": "o Fetch values from the overlay.",
      "ja": "o オーバーレイから値をフェッチします。"
    },
    {
      "indent": 3,
      "text": "o Stat: Get metadata about values in the overlay.",
      "ja": "o 統計：オーバーレイの値に関するメタデータを取得します。"
    },
    {
      "indent": 3,
      "text": "o Find the values stored at an individual peer.",
      "ja": "o 個々のピアに保存されている値を見つけます。"
    },
    {
      "indent": 3,
      "text": "These methods are described in the following sections.",
      "ja": "これらの方法については、次のセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Store",
      "section_title": true,
      "ja": "7.4.1. お店"
    },
    {
      "indent": 3,
      "text": "The Store method is used to store data in the overlay. The format of the Store request depends on the data model, which is determined by the Kind.",
      "ja": "Storeメソッドは、オーバーレイにデータを格納するために使用されます。 Storeリクエストのフォーマットは、Kindによって決定されるデータモデルによって異なります。"
    },
    {
      "indent": 0,
      "text": "7.4.1.1. Request Definition",
      "section_title": true,
      "ja": "7.4.1.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "A StoreReq message is a sequence of StoreKindData values, each of which represents a sequence of stored values for a given Kind. The same Kind-ID MUST NOT be used twice in a given store request. Each value is then processed in turn. These operations MUST be atomic. If any operation fails, the state MUST be rolled back to what it was before the request was received.",
      "ja": "StoreReqメッセージは、一連のStoreKindData値であり、それぞれが特定の種類の格納された値のシーケンスを表します。特定のストアリクエストで同じKind-IDを2回使用することはできません。次に、各値が順番に処理されます。これらの操作はアトミックである必要があります。いずれかの操作が失敗した場合、状態はリクエストを受信する前の状態にロールバックする必要があります。"
    },
    {
      "indent": 3,
      "text": "The store request is defined by the StoreReq structure:",
      "ja": "ストア要求は、StoreReq構造によって定義されます。"
    },
    {
      "indent": 7,
      "text": "struct {\n    KindId                 kind;\n    uint64                 generation_counter;\n    StoredData             values<0..2^32-1>;\n} StoreKindData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    ResourceId             resource;\n    uint8                  replica_number;\n    StoreKindData          kind_data<0..2^32-1>;\n} StoreReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A single Store request stores data of a number of Kinds to a single resource location. The contents of the structure are:",
      "ja": "単一のStoreリクエストは、複数の種類のデータを単一のリソースの場所に保存します。構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "resource The resource at which to store.",
      "ja": "resource保存するリソース。"
    },
    {
      "indent": 3,
      "text": "replica_number The number of this replica. When a storing peer saves replicas to other peers, each peer is assigned a replica number, starting from 1, that is sent in the Store message. This field is set to 0 when a node is storing its own data. This allows peers to distinguish replica writes from original writes. Different topologies may choose to allocate or interpret the replica number differently (see Section 10.4).",
      "ja": "replica_numberこのレプリカの数。保存するピアがレプリカを他のピアに保存するとき、各ピアには、1から始まるレプリカ番号が割り当てられ、ストアメッセージで送信されます。ノードが独自のデータを格納している場合、このフィールドは0に設定されます。これにより、ピアはレプリカの書き込みと元の書き込みを区別できます。トポロジーによって、レプリカ番号の割り当てや解釈が異なる場合があります（セクション10.4を参照）。"
    },
    {
      "indent": 3,
      "text": "kind_data A series of elements, one for each Kind of data to be stored.",
      "ja": "kind_data格納されるデータの種類ごとに1つずつ、一連​​の要素。"
    },
    {
      "indent": 3,
      "text": "The peer MUST check that it is responsible for the resource if the replica number is zero; if it is not, the peer must reject the request. The peer MUST check that it expects to be a replica for the resource and that the request sender is consistent with being the responsible node (i.e., that the receiving peer does not know of a better node) if the replica number is nonzero; if the request sender is not consistent, it should reject the request.",
      "ja": "レプリカ番号がゼロの場合、ピアはリソースに責任があることを確認する必要があります。そうでない場合、ピアは要求を拒否する必要があります。レプリカ番号がゼロ以外の場合、ピアは、リソースのレプリカであると予想し、リクエストの送信者が責任ノードであることを確認する必要があります（つまり、受信ピアがより良いノードを知らないこと）。リクエストの送信者に一貫性がない場合は、リクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each StoreKindData element represents the data to be stored for a single Kind-ID. The contents of the element are:",
      "ja": "各StoreKindData要素は、単一のKind-IDに格納されるデータを表します。要素の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID. Implementations MUST reject requests corresponding to unknown Kinds.",
      "ja": "種類種類ID。実装は、不明な種類に対応するリクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "generation_counter The expected current state of the generation counter (approximately the number of times that this object has been written; see below for details).",
      "ja": "generation_counter生成カウンターの予想される現在の状態（このオブジェクトが書き込まれたおおよその回数。詳細については、以下を参照してください）。"
    },
    {
      "indent": 3,
      "text": "values The value or values to be stored. This may contain one or more stored_data values, depending on the data model associated with each Kind.",
      "ja": "values格納される1つまたは複数の値。これには、各種類に関連付けられたデータモデルに応じて、1つ以上のstored_data値が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The peer MUST perform the following checks:",
      "ja": "ピアは次のチェックを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The Kind-ID is known and supported.",
      "ja": "o Kind-IDは既知であり、サポートされています。"
    },
    {
      "indent": 3,
      "text": "o The signatures over each individual data element, if any, are valid. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "o 個々のデータ要素に対する署名があれば、それは有効です。このチェックが失敗した場合、リクエストはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "o Each element is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "o 各要素は、このリソースIDでこの種類を書き込むことが許可されている資格情報によって署名されています。このチェックが失敗した場合、リクエストはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "o For original (non-replica) stores, the StoreReq is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "o 元の（レプリカではない）ストアの場合、StoreReqは、このリソースIDでこの種類を書き込むことを許可されている資格情報によって署名されています。このチェックが失敗した場合、リクエストはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "o For replica stores, the StoreReq is signed by a Node-ID which is a plausible node to either have originally stored the value or have been in the replica set. What this means is overlay specific, but in the case of the Chord-based DHT defined in this specification, replica StoreReqs MUST come from nodes which are either in the known replica set for a given resource or which are closer than some node in the replica set. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "o レプリカストアの場合、StoreReqはノードIDによって署名されます。ノードIDは、値を最初に格納したか、レプリカセットに含まれているかのいずれかである可能性があります。これが意味することはオーバーレイ固有ですが、この仕様で定義されているコードベースのDHTの場合、レプリカStoreReqは、特定のリソースの既知のレプリカセットにあるノード、またはレプリカの一部のノードよりも近いノードから来る必要がありますセットする。このチェックが失敗した場合、リクエストはError_Forbiddenエラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "o For original (non-replica) stores, the peer MUST check that if the generation counter is nonzero, it equals the current value of the generation counter for this Kind. This feature allows the generation counter to be used in a way similar to the HTTP ETag feature.",
      "ja": "o 元の（非レプリカ）ストアの場合、ピアは、生成カウンターがゼロでない場合、この種類の生成カウンターの現在の値と等しいことを確認する必要があります。この機能により、生成カウンターをHTTP ETag機能と同様の方法で使用できます。"
    },
    {
      "indent": 3,
      "text": "o For replica Stores, the peer MUST set the generation counter to match the generation counter in the message and MUST NOT check the generation counter against the current value. Replica Stores MUST NOT use a generation counter of 0.",
      "ja": "o レプリカストアの場合、ピアはメッセージ内の生成カウンターと一致するように生成カウンターを設定する必要があり、現在の値に対して生成カウンターをチェックしてはなりません（MUST NOT）。レプリカストアは、0の生成カウンターを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "o The storage time values are greater than that of any values which would be replaced by this Store.",
      "ja": "o 保管時間の値は、このストアによって置き換えられるすべての値よりも大きくなっています。"
    },
    {
      "indent": 3,
      "text": "o The size and number of the stored values are consistent with the limits specified in the overlay configuration.",
      "ja": "o 保存される値のサイズと数は、オーバーレイ構成で指定された制限と一致しています。"
    },
    {
      "indent": 3,
      "text": "o If the data is signed with identity_type set to \"none\" and/or SignatureAndHashAlgorithm values set to {0, 0} (\"anonymous\" and \"none\"), the StoreReq MUST be rejected with an Error_forbidden error. Only synthesized data returned by the storage can use these values (see Section 7.4.2.2)",
      "ja": "o データにidentity_typeが「none」に設定されているか、SignatureAndHashAlgorithmの値が{0、0}（「anonymous」および「none」）に設定されている場合、StoreReqはError_forbiddenエラーで拒否される必要があります。ストレージから返された合成データのみがこれらの値を使用できます（セクション7.4.2.2を参照）"
    },
    {
      "indent": 3,
      "text": "If all these checks succeed, the peer MUST attempt to store the data values. For non-replica stores, if the store succeeds and the data is changed, then the peer MUST increase the generation counter by at least 1. If there are multiple stored values in a single StoreKindData, it is permissible for the peer to increase the generation counter by only 1 for the entire Kind-ID or by 1 or more than 1 for each value. Accordingly, all stored data values MUST have a generation counter of 1 or greater. 0 is used in the Store request to indicate that the generation counter should be ignored for processing this request. However, the responsible peer should increase the stored generation counter and should return the correct generation counter in the response.",
      "ja": "これらすべてのチェックが成功した場合、ピアはデータ値の格納を試行する必要があります。非レプリカストアの場合、ストアが成功してデータが変更された場合、ピアは生成カウンターを少なくとも1増加する必要があります。単一のStoreKindDataに複数の格納された値がある場合、ピアが生成を増加することは許容されます。 Kind-ID全体に対して1だけ、または各値に対して1以上1ずつカウンターします。したがって、保存されているすべてのデータ値には、1以上の生成カウンターが必要です。 Store要求で0を使用して、この要求を処理するために生成カウンターを無視する必要があることを示します。ただし、責任のあるピアは、格納されている生成カウンターを増やし、応答で正しい生成カウンターを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "When a peer stores data previously stored by another node (e.g., for replicas or topology shifts), it MUST adjust the lifetime value downward to reflect the amount of time the value was stored at the peer. The adjustment SHOULD be implemented by an algorithm equivalent to the following: at the time the peer initially receives the StoreReq, it notes the local time T. When it then attempts to do a StoreReq to another node, it should decrement the lifetime value by the difference between the current local time and T.",
      "ja": "ピアが別のノードによって以前に保存されたデータを保存するとき（たとえば、レプリカまたはトポロジーのシフトの場合）、ピアで値が保存された時間を反映するために、ライフタイム値を下方に調整する必要があります。調整は、以下と同等のアルゴリズムで実装する必要があります（SHOULD）。ピアが最初にStoreReqを受信したときに、ローカル時間Tを記録します。次に、別のノードに対してStoreReqを実行しようとすると、ライフタイム値を現在の現地時間とTの差。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified by the usage, if a peer attempts to store data previously stored by another node (e.g., for replicas or topology shifts) and that store fails with either an Error_Generation_Counter_Too_Low or an Error_Data_Too_Old error, the peer MUST fetch the newer data from the peer generating the error and use that to replace its own copy. This rule allows resynchronization after partitions heal.",
      "ja": "使用方法で特に指定されていない限り、ピアが別のノードによって以前に保存されたデータを保存しようとした場合（たとえば、レプリカまたはトポロジーのシフト）、その保存がError_Generation_Counter_Too_LowまたはError_Data_Too_Oldエラーで失敗した場合、ピアは新しいデータをピアがエラーを生成し、それを使用して自身のコピーを置き換えます。このルールは、パーティションが回復した後の再同期を許可します。"
    },
    {
      "indent": 0,
      "text": " When a network partition is being healed and unless otherwise specified, the default merging rule is to act as if all the values that need to be merged were stored and as if the order they were stored in corresponds to the stored time values associated with (and carried in) their values. Because the stored time values are those associated with the peer which did the writing, clock skew is generally not an issue. If two nodes are on different partitions, write to the same location, and have clock skew, this can create merge conflicts. However, because RELOAD deliberately segregates storage so that data from different users and peers is stored in different locations, and a single peer will typically only be in a single network partition, this case will generally not arise.",
      "ja": "ネットワークパーティションが修復されている場合、特に指定のない限り、デフォルトのマージルールは、マージする必要のあるすべての値が格納されているかどうか、およびそれらが格納されている順序が、持ち込まれた）それらの値。格納された時間値は、書き込みを行ったピアに関連するものであるため、通常、クロックスキューは問題になりません。 2つのノードが異なるパーティションにあり、同じ場所に書き込み、クロックスキューがある場合、マージの競合が発生する可能性があります。ただし、RELOADは意図的にストレージを分離して、さまざまなユーザーやピアからのデータをさまざまな場所に格納し、通常は1つのピアが1つのネットワークパーティションにのみ存在するため、このケースは通常発生しません。"
    },
    {
      "indent": 3,
      "text": "The properties of stores for each data model are as follows:",
      "ja": "各データモデルのストアのプロパティは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "single-value: A store of a new single-value element creates the element if it does not exist and overwrites any existing value with the new value.",
      "ja": "単一値：新しい単一値要素のストアは、存在しない場合に要素を作成し、既存の値を新しい値で上書きします。"
    },
    {
      "indent": 3,
      "text": "array: A store of an array entry replaces (or inserts) the given value at the location specified by the index. Because arrays are sparse, a store past the end of the array extends it with nonexistent values (exists = False) as required. A store at index 0xffffffff places the new value at the end of the array, regardless of the length of the array. The resulting StoredData has the correct index value when it is subsequently fetched.",
      "ja": "array：配列エントリのストアは、インデックスで指定された場所にある指定された値を置き換えます（または挿入します）。配列はスパースであるため、配列の末尾を超えるストアは、必要に応じて、存在しない値（exists = False）で拡張します。インデックス0xffffffffのストアは、配列の長さに関係なく、新しい値を配列の最後に配置します。結果のStoredDataは、後でフェッチされるときに正しいインデックス値を持ちます。"
    },
    {
      "indent": 3,
      "text": "dictionary: A store of a dictionary entry replaces (or inserts) the given value at the location specified by the dictionary key.",
      "ja": "辞書：辞書エントリのストアは、辞書キーで指定された場所にある特定の値を置き換えます（または挿入します）。"
    },
    {
      "indent": 3,
      "text": "The following figure shows the relationship between these structures for an example store which stores the following values at resource \"1234\":",
      "ja": "次の図は、リソース \"1234\"に次の値を格納するストアの例におけるこれらの構造間の関係を示しています。"
    },
    {
      "indent": 3,
      "text": "o The value \"abc\" is in the single-value location for Kind X.",
      "ja": "o 値「abc」は、種類Xの単一値の場所にあります。"
    },
    {
      "indent": 3,
      "text": "o The value \"foo\" at index 0 is in the array for Kind Y.",
      "ja": "o インデックス0の値「foo」は、種類Yの配列にあります。"
    },
    {
      "indent": 3,
      "text": "o The value \"bar\" at index 1 is in the array for Kind Y.",
      "ja": "o インデックス1の値「bar」は、種類Yの配列にあります。"
    },
    {
      "indent": 13,
      "text": "                        Store\n                   resource=1234\n                 replica_number = 0\n                      /      \\\n                     /        \\\n         StoreKindData        StoreKindData\n     kind=X (Single-Value)    kind=Y (Array)\n   generation_counter = 99    generation_counter = 107\n              |                    /\\\n              |                   /  \\\n          StoredData             /    \\\nstorage_time = xxxxxxx          /      \\\n      lifetime = 86400         /        \\\n      signature = XXXX        /          \\\n              |               |           |\n              |        StoredData       StoredData\n              |    storage_time =       storage_time =\n              |          yyyyyyyy       zzzzzzz\n              |  lifetime = 86400       lifetime = 33200\n              |  signature = YYYY       signature = ZZZZ\n              |               |           |\n       StoredDataValue        |           |\n        value=\"abc\"           |           |\n                              |           |\n                     StoredDataValue  StoredDataValue\n                           index=0      index=1\n                        value=\"foo\"    value=\"bar\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.1.2. Response Definition",
      "section_title": true,
      "ja": "7.4.1.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "In response to a successful Store request, the peer MUST return a StoreAns message containing a series of StoreKindResponse elements, which contains the current value of the generation counter for each Kind-ID, as well as a list of the peers where the data will be replicated by the node processing the request.",
      "ja": "成功したStoreリクエストに応答して、ピアは一連のStoreKindResponse要素を含むStoreAnsメッセージを返す必要があります。これには、各Kind-IDの生成カウンターの現在の値と、データが存在するピアのリストが含まれますリクエストを処理するノードによって複製されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                  kind;\n  uint64                  generation_counter;\n  NodeId                  replicas<0..2^16-1>;\n} StoreKindResponse;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  StoreKindResponse       kind_responses<0..2^16-1>;\n} StoreAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of each StoreKindResponse are:",
      "ja": "各StoreKindResponseの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID being represented.",
      "ja": "kind表現されているKind-ID。"
    },
    {
      "indent": 3,
      "text": "generation_counter The current value of the generation counter for that Kind-ID.",
      "ja": "generation_counterそのKind-IDの生成カウンターの現在の値。"
    },
    {
      "indent": 3,
      "text": "replicas The list of other peers at which the data was/will be replicated. In overlays and applications where the responsible peer is intended to store redundant copies, this allows the storing node to independently verify that the replicas have in fact been stored. It does this verification by using the Stat method (see Section 7.4.3). Note that the storing node is not required to perform this verification.",
      "ja": "レプリカデータが複製された、または複製される他のピアのリスト。責任のあるピアが冗長コピーを保存することを目的とするオーバーレイおよびアプリケーションでは、これにより、保存ノードはレプリカが実際に保存されていることを個別に確認できます。この検証は、Statメソッドを使用して行われます（セクション7.4.3を参照）。この検証を実行するためにストレージノードは必要ないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The response itself is just StoreKindResponse values packed end to end.",
      "ja": "応答自体は、エンドツーエンドでパックされたStoreKindResponse値です。"
    },
    {
      "indent": 3,
      "text": "If any of the generation counters in the request precede the corresponding stored generation counter, then the peer MUST fail the entire request and respond with an Error_Generation_Counter_Too_Low error. The error_info in the ErrorResponse MUST be a StoreAns response containing the correct generation counter for each Kind and the replica list, which will be empty. For original (non-replica) stores, a node which receives such an error SHOULD attempt to fetch the data and, if the storage_time value is newer, replace its own data with that newer data. This rule improves data consistency in the case of partitions and merges.",
      "ja": "要求内のいずれかの生成カウンターが対応する格納された生成カウンターの前にある場合、ピアは要求全体を失敗させ、Error_Generation_Counter_Too_Lowエラーで応答する必要があります。 ErrorResponseのerror_infoは、各Kindの正しい生成カウンターと空のレプリカリストを含むStoreAns応答である必要があります。元の（非レプリカ）ストアの場合、このようなエラーを受け取ったノードはデータのフェッチを試みて（SHOULD）、storage_time値が新しい場合は、自身のデータをその新しいデータで置き換えます。このルールにより、パーティションおよびマージの場合のデータの一貫性が向上します。"
    },
    {
      "indent": 3,
      "text": "If the data being stored is too large for the allowed limit by the given usage, then the peer MUST fail the request and generate an Error_Data_Too_Large error.",
      "ja": "保存されているデータが指定された使用法で許可されている制限に対して大きすぎる場合、ピアは要求を失敗させ、Error_Data_Too_Largeエラーを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "If any type of request tries to access a data Kind that the peer does not know about, the peer MUST fail the request and generate an Error_Unknown_Kind error. The error_info in the Error_Response is:",
      "ja": "いずれかのタイプのリクエストが、ピアが認識していないデータの種類にアクセスしようとした場合、ピアはリクエストを失敗させ、Error_Unknown_Kindエラーを生成する必要があります。 Error_Responseのerror_infoは次のとおりです。"
    },
    {
      "indent": 14,
      "text": "KindId        unknown_kinds<0..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "which lists all the Kinds that were unrecognized. A node which receives this error MUST generate a ConfigUpdate message which contains the appropriate Kind definition (assuming which, in fact, a Kind which was defined in the configuration document was used).",
      "ja": "認識されなかったすべての種類がリストされます。このエラーを受信するノードは、適切なKind定義を含むConfigUpdateメッセージを生成する必要があります（実際には、構成ドキュメントで定義されたKindが使用されたと想定しています）。"
    },
    {
      "indent": 0,
      "text": "7.4.1.3. Removing Values",
      "section_title": true,
      "ja": "7.4.1.3. 値の削除"
    },
    {
      "indent": 3,
      "text": "RELOAD does not have an explicit Remove operation. Rather, values are Removed by storing \"nonexistent\" values in their place. Each DataValue contains a boolean value called \"exists\" which indicates whether a value is present at that location. In order to effectively remove a value, the owner stores a new DataValue with \"exists\" set to False:",
      "ja": "RELOADには明示的な削除操作はありません。代わりに、「存在しない」値をその場所に格納することにより、値が削除されます。各DataValueには、値がその場所に存在するかどうかを示す「exists」と呼ばれるブール値が含まれています。値を効果的に削除するために、所有者は \"exists\"がFalseに設定された新しいDataValueを保存します。"
    },
    {
      "indent": 6,
      "text": "exists = False",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "value = {} (0 length)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The owner SHOULD use a lifetime for the nonexistent value that is at least as long as the remainder of the lifetime of the value it is replacing. Otherwise, it is possible for the original value to be accidentally or maliciously re-stored after the storing node has expired it. Note that a window of vulnerability for replay attack still exists after the original lifetime has expired (as with any store). This attack can be mitigated by doing a nonexistent store with a very long lifetime.",
      "ja": "所有者は、存在しない値に対して、少なくともそれが置き換える値の残りの存続期間と同じ長さの存続期間を使用する必要があります（SHOULD）。そうしないと、保存ノードが期限切れになった後で、元の値が誤ってまたは悪意を持って再保存される可能性があります。 （他のストアと同様に）最初の存続期間が満了した後も、リプレイ攻撃の脆弱性のウィンドウが存在することに注意してください。この攻撃は、存続期間が非常に長い存在しないストアを実行することで軽減できます。"
    },
    {
      "indent": 3,
      "text": "Storing nodes MUST treat these nonexistent values the same way they treat any other stored value, including overwriting the existing value, replicating them, and aging them out as necessary when the lifetime expires. When a stored nonexistent value's lifetime expires, it is simply removed from the storing node, as happens when any other stored value expires.",
      "ja": "ノードの格納では、これらの存在しない値を、他の格納された値と同じ方法で処理する必要があります（既存の値の上書き、それらの複製、有効期限が切れたときに必要に応じてそれらをエージングアウトするなど）。格納されている存在しない値の有効期限が切れると、他の格納されている値の有効期限が切れたときのように、その値は格納ノードから削除されます。"
    },
    {
      "indent": 3,
      "text": "Note that in the case of arrays and dictionaries, expiration may create an implicit, unsigned \"nonexistent\" value to represent a gap in the data structure, as might happen when any value is aged out.",
      "ja": "配列およびディクショナリの場合、期限が切れると、暗黙の符号なし「存在しない」値が作成され、値が期限切れになったときに発生する可能性があるように、データ構造のギャップが表される場合があります。"
    },
    {
      "indent": 3,
      "text": "However, this value isn't persistent, nor is it replicated. It is simply synthesized by the storing node.",
      "ja": "ただし、この値は永続的ではなく、複製されません。これは、ストレージノードによって単純に合成されます。"
    },
    {
      "indent": 0,
      "text": "7.4.2. Fetch",
      "section_title": true,
      "ja": "7.4.2. フェッチ"
    },
    {
      "indent": 3,
      "text": "The Fetch request retrieves one or more data elements stored at a given Resource-ID. A single Fetch request can retrieve multiple different Kinds.",
      "ja": "Fetchリクエストは、特定のResource-IDに保存されている1つ以上のデータ要素を取得します。 1つのFetchリクエストで、複数の異なる種類を取得できます。"
    },
    {
      "indent": 0,
      "text": "7.4.2.1. Request Definition",
      "section_title": true,
      "ja": "7.4.2.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "Fetch requests are defined by the FetchReq structure:",
      "ja": "フェッチ要求は、FetchReq構造によって定義されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  int32            first;\n  int32            last;\n} ArrayRange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                  kind;\n  uint64                  generation;\n  uint16                  length;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "select (DataModel) {\n  case single_value: ;    /* Empty */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case array:\n     ArrayRange       indices<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case dictionary:\n     DictionaryKey    keys<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "/* This structure may be extended */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "  } model_specifier;\n} StoredDataSpecifier;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  ResourceId              resource;\n  StoredDataSpecifier     specifiers<0..2^16-1>;\n} FetchReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of the Fetch requests are as follows:",
      "ja": "Fetchリクエストの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "resource The Resource-ID to fetch from.",
      "ja": "resource取得するResource-ID。"
    },
    {
      "indent": 3,
      "text": "specifiers A sequence of StoredDataSpecifier values, each specifying some of the data values to retrieve.",
      "ja": "specifiers取得するデータ値の一部をそれぞれ指定するStoredDataSpecifier値のシーケンス。"
    },
    {
      "indent": 3,
      "text": "Each StoredDataSpecifier specifies a single Kind of data to retrieve and, if appropriate, the subset of values that are to be retrieved. The contents of the StoredDataSpecifier structure are as follows:",
      "ja": "各StoredDataSpecifierは、取得する単一の種類のデータと、必要に応じて、取得する値のサブセットを指定します。 StoredDataSpecifier構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID of the data being fetched. Implementations SHOULD reject requests corresponding to unknown Kinds unless specifically configured otherwise.",
      "ja": "kindフェッチされるデータのKind-ID。特に設定されていない限り、実装は不明な種類に対応するリクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "DataModel The data model of the data. This is not transmitted on the wire, but comes from the definition of the Kind.",
      "ja": "DataModelデータのデータモデル。これはネットワーク上で送信されませんが、種類の定義に由来します。"
    },
    {
      "indent": 3,
      "text": "generation The last generation counter that the requesting node saw. This may be used to avoid unnecessary fetches, or it may be set to zero.",
      "ja": "要求ノードが確認した最後の世代のカウンター。これは、不要なフェッチを回避するために使用される場合と、ゼロに設定される場合があります。"
    },
    {
      "indent": 3,
      "text": "length The length of the rest of the structure, thus allowing extensibility.",
      "ja": "length構造の残りの部分の長さで、拡張性を可能にします。"
    },
    {
      "indent": 3,
      "text": "model_specifier A reference to the data value being requested within the data model specified for the Kind. For instance, if the data model is \"array\", it might specify some subset of the values.",
      "ja": "model_specifier Kindに指定されたデータモデル内で要求されているデータ値への参照。たとえば、データモデルが「配列」の場合、値のサブセットを指定することがあります。"
    },
    {
      "indent": 3,
      "text": "The model_specifier is as follows:",
      "ja": "model_specifierは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the data model is single value, the specifier is empty.",
      "ja": "o データモデルが単一値の場合、指定子は空です。"
    },
    {
      "indent": 3,
      "text": "o If the data model is array, the specifier contains a list of ArrayRange elements, each of which contains two integers. The first integer is the beginning of the range, and the second is the end of the range. 0 is used to indicate the first element, and 0xffffffff is used to indicate the final element. The first integer MUST be less than or equal to the second. While multiple ranges MAY be specified, they MUST NOT overlap.",
      "ja": "o データモデルが配列の場合、指定子にはArrayRange要素のリストが含まれ、各要素には2つの整数が含まれます。最初の整数は範囲の始まりで、2番目の整数は範囲の終わりです。 0は最初の要素を示すために使用され、0xffffffffは最後の要素を示すために使用されます。最初の整数は2番目の整数以下でなければなりません。複数の範囲を指定してもかまいませんが、重複してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If the data model is dictionary, then the specifier contains a list of the dictionary keys being requested. If no keys are specified, then this is a wildcard fetch and all key-value pairs are returned.",
      "ja": "o データモデルがディクショナリの場合、指定子には、要求されているディクショナリキーのリストが含まれます。キーが指定されていない場合、これはワイルドカードフェッチであり、すべてのキーと値のペアが返されます。"
    },
    {
      "indent": 3,
      "text": "The generation counter is used to indicate the requester's expected state of the storing peer. If the generation counter in the request matches the stored counter, then the storing peer returns a response with no StoredData values.",
      "ja": "生成カウンターは、リクエスターの格納ピアの予想される状態を示すために使用されます。リクエスト内の生成カウンターが保存されたカウンターと一致する場合、保存ピアはStoredData値のない応答を返します。"
    },
    {
      "indent": 0,
      "text": "7.4.2.2. Response Definition",
      "section_title": true,
      "ja": "7.4.2.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "The response to a successful Fetch request is a FetchAns message containing the data requested by the requester.",
      "ja": "成功したFetchリクエストへの応答は、リクエスタによってリクエストされたデータを含むFetchAnsメッセージです。"
    },
    {
      "indent": 9,
      "text": "struct {\n  KindId                 kind;\n  uint64                 generation;\n  StoredData             values<0..2^32-1>;\n} FetchKindResponse;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n  FetchKindResponse      kind_responses<0..2^32-1>;\n} FetchAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The FetchAns structure contains a series of FetchKindResponse structures. There MUST be one FetchKindResponse element for each Kind-ID in the request.",
      "ja": "FetchAns構造には、一連のFetchKindResponse構造が含まれています。リクエストのKind-IDごとに1つのFetchKindResponse要素が必要です。"
    },
    {
      "indent": 3,
      "text": "The contents of the FetchKindResponse structure are as follows:",
      "ja": "FetchKindResponse構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind that this structure is for.",
      "ja": "kindこの構造の対象となる種類。"
    },
    {
      "indent": 3,
      "text": "generation The generation counter for this Kind.",
      "ja": "generationこの種類の生成カウンター。"
    },
    {
      "indent": 3,
      "text": "values The relevant values. If the generation counter in the request matches the generation counter in the stored data, then no StoredData values are returned. Otherwise, all relevant data values MUST be returned. A nonexistent value (i.e., one which the node has no knowledge of) is represented by a synthetic value with \"exists\" set to False and has an empty signature. Specifically, the identity_type is set to \"none\", the SignatureAndHashAlgorithm values are set to {0, 0} (\"anonymous\" and \"none\", respectively), and the signature value is of zero length. This removes the need for the responding node to do signatures for values which do not exist. These signatures are unnecessary, as the entire response is signed by that node. Note that entries which have been removed by the procedure given in Section 7.4.1.3 and which have not yet expired also have exists = False, but have valid signatures from the node which did the store.",
      "ja": "values関連する値。要求内の生成カウンターが、格納されたデータ内の生成カウンターと一致する場合、StoredData値は返されません。それ以外の場合は、関連するすべてのデータ値を返す必要があります。存在しない値（つまり、ノードが認識していない値）は、「存在する」がFalseに設定された合成値によって表され、空の署名があります。具体的には、identity_typeを \"none\"に設定し、SignatureAndHashAlgorithm値を{0、0}（それぞれ \"anonymous\"および \"none\"）に設定し、署名値の長さをゼロにします。これにより、応答ノードが存在しない値の署名を行う必要がなくなります。応答全体がそのノードによって署名されるため、これらの署名は不要です。セクション7.4.1.3の手順で削除され、まだ期限が切れていないエントリも存在する= Falseですが、ストアを行ったノードからの有効な署名があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a FetchAns message, nodes MUST verify the signatures on all the received values. Any values with invalid signatures (including expired certificates) MUST be discarded. Note that this implies that implementations which wish to store data for long periods of time must have certificates with appropriate expiration dates or must re-store periodically. Implementations MAY return the subset of values with valid signatures, but in that case, they SHOULD somehow signal to the application that a partial response was received.",
      "ja": "FetchAnsメッセージを受信すると、ノードは受信したすべての値の署名を検証する必要があります。無効な署名（期限切れの証明書を含む）のある値は破棄する必要があります。これは、長期間データを保存したい実装が適切な有効期限の証明書を持っているか、定期的に再保存する必要があることを意味することに注意してください。実装は、有効な署名を持つ値のサブセットを返す場合がありますが、その場合、部分的な応答が受信されたことをアプリケーションに何らかの方法で通知する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "There is one subtle point about signature computation on arrays. If the storing node uses the append feature (where the index=0xffffffff), then the index in the StoredData that is returned will not match that used by the storing node, which would break the signature. In order to avoid this issue, the index value in the array is set to zero before the signature is computed. This implies that malicious storing nodes can reorder array entries without being detected.",
      "ja": "配列のシグネチャ計算については、1つの微妙な点があります。格納ノードが追加機能（index = 0xffffffff）を使用する場合、返されるStoredDataのインデックスは、格納ノードで使用されるインデックスと一致しないため、署名が破損します。この問題を回避するために、配列のインデックス値は署名が計算される前にゼロに設定されます。これは、悪意のある格納ノードが検出されずに配列エントリを並べ替えることができることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.4.3. Stat",
      "section_title": true,
      "ja": "7.4.3. 状態"
    },
    {
      "indent": 3,
      "text": "The Stat request is used to get metadata (length, generation counter, digest, etc.) for a stored element without retrieving the element itself. The name is from the UNIX stat(2) system call, which performs a similar function for files in a file system. It also allows the requesting node to get a list of matching elements without requesting the entire element.",
      "ja": "Statリクエストは、要素自体を取得せずに、格納された要素のメタデータ（長さ、生成カウンター、ダイジェストなど）を取得するために使用されます。この名前はUNIX stat（2）システムコールからのもので、ファイルシステム内のファイルに対して同様の機能を実行します。また、要素全体を要求することなく、要求ノードが一致する要素のリストを取得できるようにします。"
    },
    {
      "indent": 0,
      "text": "7.4.3.1. Request Definition",
      "section_title": true,
      "ja": "7.4.3.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "The Stat request is identical to the Fetch request. It simply specifies the elements to get metadata about.",
      "ja": "StatリクエストはFetchリクエストと同じです。メタデータを取得する要素を指定するだけです。"
    },
    {
      "indent": 8,
      "text": "struct {\n  ResourceId              resource;\n  StoredDataSpecifier     specifiers<0..2^16-1>;\n} StatReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.3.2. Response Definition",
      "section_title": true,
      "ja": "7.4.3.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "The Stat response contains the same sort of entries that a Fetch response would contain. However, instead of containing the element data, it contains metadata.",
      "ja": "Stat応答には、Fetch応答に含まれるのと同じ種類のエントリが含まれます。ただし、要素データではなく、メタデータが含まれています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  Boolean                exists;\n  uint32                 value_length;\n  HashAlgorithm          hash_algorithm;\n  opaque                 hash_value<0..255>;\n} MetaData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                 index;\n  MetaData               value;\n} ArrayEntryMeta;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  DictionaryKey          key;\n  MetaData               value;\n} DictionaryEntryMeta;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  select (DataModel) {\n    case single_value:\n      MetaData              single_value_entry;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case array: ArrayEntryMeta array_entry;",
      "ja": "ケース配列：ArrayEntryMeta array_entry;"
    },
    {
      "indent": 12,
      "text": "case dictionary: DictionaryEntryMeta dictionary_entry;",
      "ja": "ケース辞書：DictionaryEntryMeta dictionary_entry;"
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended */\n  };\n} MetaDataValue;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  value_length;\n  uint64                  storage_time;\n  uint32                  lifetime;\n  MetaDataValue           metadata;\n} StoredMetaData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                 kind;\n  uint64                 generation;\n  StoredMetaData         values<0..2^32-1>;\n} StatKindResponse;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n  StatKindResponse      kind_responses<0..2^32-1>;\n} StatAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The structures used in StatAns parallel those used in FetchAns: a response consists of multiple StatKindResponse values, one for each Kind that was in the request. The contents of the StatKindResponse are the same as those in the FetchKindResponse, except that the values list contains StoredMetaData entries instead of StoredData entries.",
      "ja": "StatAnsで使用されている構造は、FetchAnsで使用されている構造と類似しています。応答は、要求に含まれていた種類ごとに1つずつ、複数のStatKindResponse値で構成されています。値リストにStoredDataエントリの代わりにStoredMetaDataエントリが含まれていることを除いて、StatKindResponseの内容はFetchKindResponseの内容と同じです。"
    },
    {
      "indent": 3,
      "text": "The contents of the StoredMetaData structure are the same as the corresponding fields in StoredData, except that there is no signature field and the value is a MetaDataValue rather than a StoredDataValue.",
      "ja": "StoredMetaData構造の内容は、署名フィールドがなく、値がStoredDataValueではなくMetaDataValueであることを除いて、StoredDataの対応するフィールドと同じです。"
    },
    {
      "indent": 3,
      "text": "A MetaDataValue is a variant structure, like a StoredDataValue, except for the types of each arm, which replace DataValue with MetaData.",
      "ja": "MetaDataValueは、DatadをMetaDataに置き換える各アームのタイプを除いて、StoredDataValueのようなバリアント構造です。"
    },
    {
      "indent": 3,
      "text": "The only new structure is MetaData, which has the following contents:",
      "ja": "唯一の新しい構造はMetaDataで、次の内容があります。"
    },
    {
      "indent": 3,
      "text": "exists Same as in DataValue.",
      "ja": "データ値と同じです。"
    },
    {
      "indent": 3,
      "text": "value_length The length of the stored value.",
      "ja": "value_length保管された値の長さ。"
    },
    {
      "indent": 3,
      "text": "hash_algorithm The hash algorithm used to perform the digest of the value.",
      "ja": "hash_algorithm値のダイジェストを実行するために使用されるハッシュアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "hash_value A digest using hash_algorithm on the value field of the DataValue, including its 4 leading length bytes.",
      "ja": "hash_value DataValueの値フィールドでhash_algorithmを使用するダイジェスト（先頭の4バイトを含む）。"
    },
    {
      "indent": 0,
      "text": "7.4.4. Find",
      "section_title": true,
      "ja": "7.4.4. 探す"
    },
    {
      "indent": 3,
      "text": "The Find request can be used to explore the Overlay Instance. A Find request for a Resource-ID R and a Kind-ID T retrieves the Resource-ID, if any, of the resource of Kind T known to the target peer which is closest to R. This method can be used to walk the Overlay Instance by iteratively fetching R_n+1=nearest(1 + R_n).",
      "ja": "Findリクエストを使用して、オーバーレイインスタンスを探索できます。 Resource-ID RとKind-ID TのFindリクエストは、Rに最も近いターゲットピアに既知のKind TのリソースのResource-IDを取得します。このメソッドは、オーバーレイのウォークに使用できます。 R_n + 1 = nearest（1 + R_n）を繰り返しフェッチしてインスタンス化します。"
    },
    {
      "indent": 0,
      "text": "7.4.4.1. Request Definition",
      "section_title": true,
      "ja": "7.4.4.1. リクエスト定義"
    },
    {
      "indent": 3,
      "text": "The FindReq message contains a Resource-ID and a series of Kind-IDs identifying the resource the peer is interested in.",
      "ja": "FindReqメッセージには、Resource-IDと、ピアが関心を持っているリソースを識別する一連のKind-IDが含まれています。"
    },
    {
      "indent": 5,
      "text": "struct {\n  ResourceId                 resource;\n  KindId                     kinds<0..2^8-1>;\n} FindReq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The request contains a list of Kind-IDs which the Find is for, as indicated below:",
      "ja": "リクエストには、以下に示すように、Findの対象となるKind-IDのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "resource The desired Resource-ID.",
      "ja": "resource目的のResource-ID。"
    },
    {
      "indent": 3,
      "text": "kinds The desired Kind-IDs. Each value MUST appear only once. Otherwise, the request MUST be rejected with an error.",
      "ja": "kind必要なKind-ID。各値は1回だけ出現する必要があります。それ以外の場合、リクエストはエラーで拒否される必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.4.2. Response Definition",
      "section_title": true,
      "ja": "7.4.4.2. 応答の定義"
    },
    {
      "indent": 3,
      "text": "A response to a successful Find request is a FindAns message containing the closest Resource-ID on the peer for each Kind specified in the request.",
      "ja": "成功したFind要求への応答は、要求で指定された各Kindのピア上の最も近いResource-IDを含むFindAnsメッセージです。"
    },
    {
      "indent": 4,
      "text": "struct {\n  KindId                      kind;\n  ResourceId                  closest;\n} FindKindData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "struct {\n  FindKindData                results<0..2^16-1>;\n} FindAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the processing peer is not responsible for the specified Resource-ID, it SHOULD return an Error_Not_Found error code.",
      "ja": "処理中のピアが指定されたResource-IDを担当しない場合は、Error_Not_Foundエラーコードを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "For each Kind-ID in the request, the response MUST contain a FindKindData indicating the closest Resource-ID for that Kind-ID, unless the Kind is not allowed to be used with Find, in which case a FindKindData for that Kind-ID MUST NOT be included in the response. If a Kind-ID is not known, then the corresponding Resource-ID MUST be 0. Note that different Kind-IDs may have different closest Resource-IDs.",
      "ja": "リクエストのKind-IDごとに、KindをFindで使用することが許可されていない限り、応答にはそのKind-IDに最も近いResource-IDを示すFindKindDataが含まれている必要があります。その場合、そのKind-IDのFindKindDataは応答には含まれません。 Kind-IDが不明の場合、対応するResource-IDは0である必要があります。Kind-IDが異なると、最も近いResource-IDが異なる場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The response is simply a series of FindKindData elements, one per Kind, concatenated end to end. The contents of each element are:",
      "ja": "応答は、一連のFindKindData要素であり、Kindごとに1つ、エンドツーエンドで連結されています。各要素の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID.",
      "ja": "種類種類ID。"
    },
    {
      "indent": 3,
      "text": "closest The closest Resource-ID to the specified Resource-ID. It is 0 if no Resource-ID is known.",
      "ja": "最も近い指定されたResource-IDに最も近いResource-ID。 Resource-IDが不明の場合は0です。"
    },
    {
      "indent": 3,
      "text": "Note that the response does not contain the contents of the data stored at these Resource-IDs. If the requester wants this, it must retrieve it using Fetch.",
      "ja": "応答には、これらのResource-IDに格納されているデータの内容が含まれていないことに注意してください。リクエスタがこれを必要とする場合は、Fetchを使用して取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.5. Defining New Kinds",
      "section_title": true,
      "ja": "7.4.5. 新しい種類の定義"
    },
    {
      "indent": 3,
      "text": "There are two ways to define a new Kind. The first is by writing a document and registering the Kind-ID with IANA. This is the preferred method for Kinds which may be widely used and reused. The second method is to simply define the Kind and its parameters in the Configuration Document using the section of Kind-ID space set aside for private use. This method MAY be used to define ad hoc Kinds in new overlays.",
      "ja": "新しい種類を定義するには2つの方法があります。 1つ目は、ドキュメントを作成してKind-IDをIANAに登録することです。これは、広く使用および再利用できるKindsに推奨される方法です。 2番目の方法は、プライベート用に取っておいたKind-IDスペースのセクションを使用して、構成ドキュメントでKindとそのパラメーターを定義するだけです。このメソッドは、新しいオーバーレイでアドホックの種類を定義するために使用できます。"
    },
    {
      "indent": 3,
      "text": "However a Kind is defined, the definition MUST include:",
      "ja": "種類が定義されている場合でも、定義には以下を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o The meaning of the data to be stored (in some textual form).",
      "ja": "o 保存するデータの意味（テキスト形式）。"
    },
    {
      "indent": 3,
      "text": "o The Kind-ID.",
      "ja": "o 種類ID。"
    },
    {
      "indent": 3,
      "text": "o The data model (single value, array, dictionary, etc.).",
      "ja": "o データモデル（単一値、配列、辞書など）。"
    },
    {
      "indent": 3,
      "text": "o The access control model.",
      "ja": "o アクセス制御モデル。"
    },
    {
      "indent": 3,
      "text": "In addition, when Kinds are registered with IANA, each Kind is assigned a short string name which is used to refer to it in Configuration Documents.",
      "ja": "さらに、KindがIANAに登録されると、各Kindには短い文字列名が割り当てられ、構成ドキュメントでそれを参照するために使用されます。"
    },
    {
      "indent": 3,
      "text": "While each Kind needs to define what data model is used for its data, this does not mean that it must define new data models. Where practical, Kinds should use the existing data models. The intention is that the basic data model set be sufficient for most applications/ usages.",
      "ja": "各種類は、そのデータに使用されるデータモデルを定義する必要がありますが、新しいデータモデルを定義する必要があるという意味ではありません。実際には、Kindsは既存のデータモデルを使用する必要があります。その意図は、基本的なデータモデルセットでほとんどのアプリケーション/用途に十分であるということです。"
    },
    {
      "indent": 0,
      "text": "8. Certificate Store Usage",
      "section_title": true,
      "ja": "8. 証明書ストアの使用"
    },
    {
      "indent": 3,
      "text": "The Certificate Store Usage allows a node to store its certificate in the overlay.",
      "ja": "証明書ストアの使用により、ノードは証明書をオーバーレイに保存できます。"
    },
    {
      "indent": 3,
      "text": "A user/node MUST store its certificate at Resource-IDs derived from two Resource Names:",
      "ja": "ユーザー/ノードは、2つのリソース名から派生したリソースIDに証明書を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The user name in the certificate.",
      "ja": "o 証明書のユーザー名。"
    },
    {
      "indent": 3,
      "text": "o The Node-ID in the certificate.",
      "ja": "o 証明書のノードID。"
    },
    {
      "indent": 3,
      "text": "Note that in the second case, the certificate for a peer is not stored at its Node-ID but rather at a hash of its Node-ID. The intention here (as is common throughout RELOAD) is to avoid making a peer responsible for its own data.",
      "ja": "2番目のケースでは、ピアの証明書はそのノードIDではなく、ノードIDのハッシュに保存されることに注意してください。ここでの意図は（RELOAD全体で共通）、ピアが自身のデータを担当することを回避することです。"
    },
    {
      "indent": 3,
      "text": "New certificates are stored at the end of the list. This structure allows users to store an old and a new certificate that both have the same Node-ID, which allows for migration of certificates when they are renewed.",
      "ja": "新しい証明書はリストの最後に保存されます。この構造により、ユーザーは両方とも同じノードIDを持つ古い証明書と新しい証明書を保存でき、更新時に証明書を移行できます。"
    },
    {
      "indent": 3,
      "text": "This usage defines the following Kinds:",
      "ja": "この使用法は、次の種類を定義します。"
    },
    {
      "indent": 3,
      "text": "Name: CERTIFICATE_BY_NODE",
      "ja": "名前：CERTIFICATE_BY_NODE"
    },
    {
      "indent": 3,
      "text": "Data Model: The data model for CERTIFICATE_BY_NODE data is array.",
      "ja": "データモデル：CERTIFICATE_BY_NODEデータのデータモデルは配列です。"
    },
    {
      "indent": 3,
      "text": "Access Control: NODE-MATCH",
      "ja": "アクセス制御：NODE-MATCH"
    },
    {
      "indent": 3,
      "text": "Name: CERTIFICATE_BY_USER",
      "ja": "名前：CERTIFICATE_BY_USER"
    },
    {
      "indent": 3,
      "text": "Data Model: The data model for CERTIFICATE_BY_USER data is array.",
      "ja": "データモデル：CERTIFICATE_BY_USERデータのデータモデルは配列です。"
    },
    {
      "indent": 3,
      "text": "Access Control: USER-MATCH",
      "ja": "アクセス制御：USER-MATCH"
    },
    {
      "indent": 0,
      "text": "9. TURN Server Usage",
      "section_title": true,
      "ja": "9. TURN Serverの使用"
    },
    {
      "indent": 0,
      "text": " The TURN Server Usage allows a RELOAD peer to advertise that it is prepared to be a TURN server, as defined in [RFC5766]. When a node starts up, it joins the overlay network and forms several connections in the process. If the ICE stage in any of these connections returns a reflexive address that is not the same as the peer's perceived address, then the peer is behind a NAT and SHOULD NOT be a candidate for a TURN server. Additionally, if the peer's IP address is in the private address space range as defined by [RFC1918], then it is also SHOULD NOT be a candidate for a TURN server. Otherwise, the peer SHOULD assume that it is a potential TURN server and follow the procedures below.",
      "ja": "[RFC5766]で定義されているように、TURN Serverを使用すると、RELOADピアはTURN Serverになる準備ができていることを通知できます。ノードが起動すると、オーバーレイネットワークに参加し、その過程でいくつかの接続を形成します。これらの接続のいずれかのICEステージが、ピアの認識したアドレスと同じではない再帰アドレスを返す場合、ピアはNATの背後にあり、TURNサーバーの候補であってはなりません（SHOULD NOT）。さらに、ピアのIPアドレスが[RFC1918]で定義されているプラ​​イベートアドレス空間の範囲内にある場合は、TURNサーバーの候補にもならないはずです。それ以外の場合、ピアは、それが潜在的なTURNサーバーであると想定し、以下の手順に従ってください。"
    },
    {
      "indent": 3,
      "text": "If the node is a candidate for a TURN server, it will insert some pointers in the overlay so that other peers can find it. The overlay configuration file specifies a turn-density parameter that indicates how many times each TURN server SHOULD record itself in the overlay. Typically, this should be set to the reciprocal of the estimate of what percentage of peers will act as TURN servers. If the turn-density is not set to zero, for each value, called d, between 1 and turn-density, the peer forms a Resource Name by concatenating its Node-ID and the value d. This Resource Name is hashed to form a Resource-ID. The address of the peer is stored at that Resource-ID using type TURN-SERVICE and the TurnServer object:",
      "ja": "ノードがTURNサーバーの候補である場合、他のピアが見つけられるように、オーバーレイにポインターを挿入します。オーバーレイ構成ファイルは、各TURNサーバーが自分自身をオーバーレイに記録する必要がある回数を示すターン密度パラメーターを指定します。通常、これは、ピアの何パーセントがTURNサーバーとして機能するかの見積もりの​​逆数に設定する必要があります。ターン密度がゼロに設定されていない場合、dと呼ばれる1からターン密度までの各値について、ピアはそのノードIDと値dを連結してリソース名を形成します。このリソース名はハッシュされてリソースIDを形成します。ピアのアドレスは、タイプTURN-SERVICEとTurnServerオブジェクトを使用して、そのResource-IDに格納されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint8                   iteration;\n  IpAddressPort           server_address;\n} TurnServer;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "iteration The d value.",
      "ja": "反復d値。"
    },
    {
      "indent": 3,
      "text": "server_address The address at which the TURN server can be contacted.",
      "ja": "server_address TURNサーバーに接続できるアドレス。"
    },
    {
      "indent": 3,
      "text": "Note: Correct functioning of this algorithm depends on having turn-density be a reasonable estimate of the reciprocal of the proportion of nodes in the overlay that can act as TURN servers. If the turn-density value in the configuration file is too low, the process of finding TURN servers becomes more expensive, as multiple candidate Resource-IDs must be probed to find a TURN server.",
      "ja": "注：このアルゴリズムが正しく機能するかどうかは、ターン密度がTURNサーバーとして機能できるオーバーレイ内のノードの比率の逆数の妥当な見積もりになるかどうかに依存します。構成ファイルのターン密度値が低すぎる場合、複数の候補リソースIDを調べてTURNサーバーを見つける必要があるため、TURNサーバーを見つけるプロセスはよりコストがかかります。"
    },
    {
      "indent": 3,
      "text": "Peers that provide this service need to support the TURN extensions to STUN for media relay, as defined in [RFC5766].",
      "ja": "このサービスを提供するピアは、[RFC5766]で定義されているように、メディアリレー用にSTUNのTURN拡張をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "This usage defines the following Kind to indicate that a peer is willing to act as a TURN server:",
      "ja": "この使用法は、ピアがTURNサーバーとして機能する用意があることを示すために、次の種類を定義します。"
    },
    {
      "indent": 3,
      "text": "Name: TURN-SERVICE",
      "ja": "名前：TURN-SERVICE"
    },
    {
      "indent": 3,
      "text": "Data Model: The TURN-SERVICE Kind stores a single value for each Resource-ID.",
      "ja": "データモデル：TURN-SERVICE Kindは、Resource-IDごとに1つの値を格納します。"
    },
    {
      "indent": 3,
      "text": "Access Control: NODE-MULTIPLE, with a maximum iteration of counter 20.",
      "ja": "アクセス制御：NODE-MULTIPLE、カウンター20の最大反復。"
    },
    {
      "indent": 3,
      "text": "Peers MAY find other servers by selecting a random Resource-ID and then doing a Find request for the appropriate Kind-ID with that Resource-ID. The Find request gets routed to a random peer based on the Resource-ID. If that peer knows of any servers, they will be returned. The returned response may be empty if the peer does not know of any servers, in which case the process gets repeated with some other random Resource-ID. As long as the ratio of servers relative to peers is not too low, this approach will result in finding a server relatively quickly.",
      "ja": "ピアは、ランダムなリソースIDを選択し、そのリソースIDを使用して適切な種類IDの検索要求を行うことで、他のサーバーを見つけることができます（MAY）。検索要求は、リソースIDに基づいてランダムなピアにルーティングされます。そのピアがサーバーを知っている場合は、それらが返されます。ピアがサーバーを認識していない場合、返される応答は空になる場合があります。その場合、他のランダムなリソースIDでプロセスが繰り返されます。ピアに対するサーバーの比率が低くなりすぎない限り、このアプローチはサーバーを比較的迅速に見つけることになります。"
    },
    {
      "indent": 3,
      "text": "Note to implementers: The certificates used by TurnServer entries need to be retained, as described in Section 6.3.4.",
      "ja": "実装者への注意：セクション6.3.4で説明されているように、TurnServerエントリで使用される証明書は保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Chord Algorithm",
      "section_title": true,
      "ja": "10. コードアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This algorithm is assigned the name CHORD-RELOAD to indicate that it is an adaptation of the basic Chord-based DHT algorithm.",
      "ja": "このアルゴリズムには、CHORD-RELOADという名前が割り当てられており、基本的なコードベースのDHTアルゴリズムの適応であることを示しています。"
    },
    {
      "indent": 3,
      "text": "This algorithm differs from the Chord algorithm that was originally presented in [Chord]. It has been updated based on more recent research results and implementation experiences, and to adapt it to the RELOAD protocol. Here is a short list of differences:",
      "ja": "このアルゴリズムは、[Chord]で最初に提示されたChordアルゴリズムとは異なります。これは、より最近の研究結果と実装経験に基づいて更新され、RELOADプロトコルに適合させるためのものです。違いの短いリストを次に示します。"
    },
    {
      "indent": 3,
      "text": "o The original Chord algorithm specified that a single predecessor and a successor list be stored. The CHORD-RELOAD algorithm attempts to have more than one predecessor and successor. The predecessor sets help other neighbors learn their successor list.",
      "ja": "o 元のコードアルゴリズムでは、単一の先行リストと後続リストを格納するように指定されていました。 CHORD-RELOADアルゴリズムは、複数の先行および後続を保持しようとします。先行セットは、他のネイバーが後続リストを学習するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "o The original Chord specification and analysis called for iterative routing. RELOAD specifies recursive routing. In addition to the performance implications, the cost of NAT traversal dictates recursive routing.",
      "ja": "o オリジナルのコード仕様と分析では、反復ルーティングが必要でした。 RELOADは再帰ルーティングを指定します。パフォーマンスへの影響に加えて、NATトラバーサルのコストにより、再帰ルーティングが決まります。"
    },
    {
      "indent": 3,
      "text": "o Finger Table entries are indexed in the opposite order. Original Chord specifies finger[0] as the immediate successor of the peer. CHORD-RELOAD specifies finger[0] as the peer 180 degrees around the ring from the peer. This change was made to simplify discussion and implementation of variable-sized Finger Tables. However, with either approach, no more than O(log N) entries should typically be stored in a Finger Table.",
      "ja": "o フィンガーテーブルエントリには、逆の順序でインデックスが付けられます。 Original Chordは、finger [0]をピアの直接の後継として指定します。 CHORD-RELOADは、finger [0]をピアからリングの周りに180度のピアとして指定します。この変更は、可変サイズのフィンガーテーブルの説明と実装を簡素化するために行われました。ただし、どちらの方法でも、通常、O（log N）エントリのみがFinger Tableに保存されます。"
    },
    {
      "indent": 0,
      "text": " o The stabilize() and fix_fingers() algorithms in the original Chord algorithm are merged into a single periodic process. Stabilization is implemented slightly differently because of the larger neighborhood, and fix_fingers is not as aggressive to reduce load, nor does it search for optimal matches of the Finger Table entries.",
      "ja": "oオリジナルのChordアルゴリズムのstabilize()およびfix_fingers()アルゴリズムは、単一の周期的プロセスにマージされます。近傍が大きいため、安定化の実装は少し異なります。また、fix_fingersは、負荷を減らすために積極的ではなく、Finger Tableエントリの最適な一致を検索しません。"
    },
    {
      "indent": 3,
      "text": "o RELOAD allows for a 128-bit hash instead of a 160-bit hash, as RELOAD is not designed to be used in networks with close to or more than 2^128 nodes or objects (and it is hard to see how one would assemble such a network).",
      "ja": "o RELOADは、160ビットのハッシュの代わりに128ビットのハッシュを許可します。これは、RELOADが2 ^ 128近くまたはそれ以上のノードまたはオブジェクトを持つネットワークで使用されるように設計されていないためです（そして、そのような方法を組み立てる方法を理解するのは困難ですネットワーク）。"
    },
    {
      "indent": 3,
      "text": "o RELOAD uses randomized finger entries, as described in Section 10.7.4.2.",
      "ja": "o セクション10.7.4.2で説明するように、RELOADはランダム化されたfingerエントリを使用します。"
    },
    {
      "indent": 3,
      "text": "o The CHORD-RELOAD algorithm allows the use of either reactive or periodic recovery. The original Chord paper used periodic recovery. Reactive recovery provides better performance in small overlays, but is believed to be unstable in large overlays (greater than 1000) with high levels of churn [handling-churn-usenix04]. The overlay configuration file specifies a \"chord-reactive\" element that indicates whether reactive recovery should be used.",
      "ja": "o CHORD-RELOADアルゴリズムでは、リアクティブまたは定期的なリカバリのいずれかを使用できます。オリジナルのコード紙は定期的な回復を使用していました。反応性回復は小さなオーバーレイでより良いパフォーマンスを提供しますが、高レベルのチャーン[handling-churn-usenix04]を伴う大きなオーバーレイ（1000を超える）では不安定になると考えられています。オーバーレイ構成ファイルは、リアクティブリカバリを使用する必要があるかどうかを示す「chord-reactive」要素を指定します。"
    },
    {
      "indent": 0,
      "text": "10.1. Overview",
      "section_title": true,
      "ja": "10.1. 概観"
    },
    {
      "indent": 3,
      "text": "The algorithm described here, CHORD-RELOAD, is a modified version of the Chord algorithm. In Chord (and in the algorithm described here), nodes are arranged in a ring, with node n being adjacent to nodes n-1 and n+1 and with all arithmetic being done modulo 2^{k}, where k is the length of the Node-ID in bits, so that node 2^{k} - 1 is directly before node 0.",
      "ja": "ここで説明するアルゴリズム、CHORD-RELOADは、Chordアルゴリズムの修正バージョンです。 Chord（およびここで説明するアルゴリズム）では、ノードはリングに配置され、ノードnはノードn-1およびn + 1に隣接し、すべての計算は2 ^ {k}を法として行われます（kは長さ）ノードIDをビットで表すため、ノード2 ^ {k}-1はノード0の直前になります。"
    },
    {
      "indent": 3,
      "text": "Each peer keeps track of a Finger Table and a Neighbor Table. The Neighbor Table contains at least the three peers before and after this peer in the DHT ring. There may not be three entries in all cases, such as small rings or while the ring topology is changing. The first entry in the Finger Table contains the peer halfway around the ring from this peer, the second entry contains the peer that is 1/4th of the way around, the third entry contains the peer that is 1/8th of the way around, and so on. Fundamentally, the Chord DHT can be thought of as a doubly linked list formed by knowing the successors and predecessor peers in the Neighbor Table, sorted by the Node-ID. As long as the successor peers are correct, the DHT will return the correct result. The pointers to the prior peers are kept to enable the insertion of new peers into the list structure. Keeping multiple predecessor and successor pointers makes it possible to maintain the integrity of the data structure even when consecutive peers simultaneously fail. The Finger Table forms a skip list [wikiSkiplist] so that entries in the linked list can be found in O(log(N)) time instead of the typical O(N) time that a linked list would provide, where N represents the number of nodes in the DHT.",
      "ja": "各ピアは、フィンガーテーブルとネイバーテーブルを追跡します。ネイバーテーブルには、DHTリングのこのピアの前後に少なくとも3つのピアが含まれています。小さなリングやリングトポロジの変更中など、すべてのケースで3つのエントリがあるとは限りません。フィンガーテーブルの最初のエントリには、このピアからリングの中間にあるピアが含まれ、2番目のエントリには、経路の1/4のピアが含まれ、3番目のエントリには、経路の1/8のピアが含まれます。等々。基本的に、Chord DHTは、ノードIDでソートされたネイバーテーブルの後続ピアと先行ピアを知ることによって形成される二重にリンクされたリストと考えることができます。後続ピアが正しい限り、DHTは正しい結果を返します。以前のピアへのポインタは、新しいピアをリスト構造に挿入できるようにするために保持されます。複数の先行ポインターと後続ポインターを保持することで、連続したピアが同時に失敗した場合でも、データ構造の整合性を維持することができます。フィンガーテーブルはスキップリスト[wikiSkiplist]を形成するため、リンクリストのエントリは、リンクリストが提供する通常のO（N）時間ではなくO（log（N））時間で見つけることができます（Nは数字を表します）。 DHTのノードの。"
    },
    {
      "indent": 3,
      "text": "The Neighbor Table and Finger Table entries contain logical Node-IDs as values, but the actual mapping of an IP level addressing information to reach that Node-ID is kept in the Connection Table.",
      "ja": "ネイバーテーブルとフィンガーテーブルのエントリには、値として論理ノードIDが含まれますが、そのノードIDに到達するためのIPレベルのアドレス指定情報の実際のマッピングは、接続テーブルに保持されます。"
    },
    {
      "indent": 3,
      "text": "A peer, x, is responsible for a particular Resource-ID, k, if k is less than or equal to x and k is greater than p, where p is the Node-ID of the previous peer in the Neighbor Table. Care must be taken when computing to note that all math is modulo 2^128.",
      "ja": "ピアxは、kがx以下でkがpより大きい場合、特定のリソースID kを担当します。ここで、pは、ネイバーテーブル内の前のピアのノードIDです。計算時にはすべての数学が2 ^ 128を法とすることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2. Hash Function",
      "section_title": true,
      "ja": "10.2. ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "For this Chord-based Topology Plug-in, the size of the Resource-ID is 128 bits. The hash of a Resource-ID MUST be computed using SHA-1 [RFC3174], and then the SHA-1 result MUST be truncated to the most significant 128 bits.",
      "ja": "このコードベースのトポロジプラグインの場合、Resource-IDのサイズは128ビットです。 Resource-IDのハッシュは、SHA-1 [RFC3174]を使用して計算しなければならず（MUST）、SHA-1の結果は最上位の128ビットに切り捨てられる必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3. Routing",
      "section_title": true,
      "ja": "10.3. ルーティング"
    },
    {
      "indent": 3,
      "text": "The Routing Table is conceptually the union of the Neighbor Table and the Finger Table.",
      "ja": "ルーティングテーブルは、概念的にはネイバーテーブルとフィンガーテーブルの和集合です。"
    },
    {
      "indent": 3,
      "text": "If a peer is not responsible for a Resource-ID k, but is directly connected to a node with Node-ID k, then it MUST route the message to that node. Otherwise, it MUST route the request to the peer in the Routing Table that has the largest Node-ID that is in the interval between the peer and k. If no such node is found, the peer finds the smallest Node-ID that is greater than k and MUST route the message to that node.",
      "ja": "ピアがResource-ID kを担当しないが、Node-ID kのノードに直接接続されている場合、ピアはメッセージをそのノードにルーティングする必要があります。それ以外の場合は、ピアとkの間の間隔にある最大のノードIDを持つルーティングテーブルのピアに要求をルーティングする必要があります。そのようなノードが見つからない場合、ピアはkより大きい最小のノードIDを見つけ、そのノードにメッセージをルーティングする必要があります。"
    },
    {
      "indent": 0,
      "text": "10.4. Redundancy",
      "section_title": true,
      "ja": "10.4. 冗長性"
    },
    {
      "indent": 3,
      "text": "When a peer receives a Store request for Resource-ID k and it is responsible for Resource-ID k, it MUST store the data and return a success response. It MUST then send a Store request to its successor in the Neighbor Table and to that peer's successor, incrementing the replica number for each successor. Note that these Store requests are addressed to those specific peers, even though the Resource-ID they are being asked to store is outside the range that they are responsible for. The peers receiving these SHOULD check that they came from an appropriate predecessor in their Neighbor Table and that they are in a range that this predecessor is responsible for. Then, they MUST store the data. They do not themselves perform further Stores, because they can determine that they are not responsible for the Resource-ID.",
      "ja": "ピアがResource-ID kのStoreリクエストを受信し、それがResource-ID kを担当している場合、ピアはデータを保存し、成功応答を返さなければなりません（MUST）。次に、近隣テーブルの後続ノードとそのピアの後続ノードにストア要求を送信し、各後続ノードのレプリカ番号を増分する必要があります。これらのStore要求は、それらが格納するように要求されているResource-IDがそれらが担当する範囲外であっても、それらの特定のピアにアドレス指定されることに注意してください。これらを受信するピアは、それらがネイバーテーブルの適切な前任者からのものであること、およびこの前任者が担当する範囲内にあることを確認する必要があります。次に、データを保存する必要があります。彼らはResource-IDに責任がないと判断できるため、それ自体はそれ以上ストアを実行しません。"
    },
    {
      "indent": 3,
      "text": "Note that this Topology Plug-in does not use the replica number for purposes other than knowing the difference between a replica and a non-replica.",
      "ja": "このトポロジプラグインは、レプリカと非レプリカの違いを知る以外の目的でレプリカ番号を使用しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Managing replicas as the overlay changes is described in Section 10.7.3.",
      "ja": "オーバーレイの変更に伴うレプリカの管理については、セクション10.7.3で説明します。"
    },
    {
      "indent": 3,
      "text": "The sequential replicas used in this overlay algorithm protect against peer failure but not against malicious peers. Additional replication from the Usage is required to protect resources from such attacks, as discussed in Section 13.5.4.",
      "ja": "このオーバーレイアルゴリズムで使用される順次レプリカは、ピアの障害から保護しますが、悪意のあるピアからは保護しません。セクション13.5.4で説明するように、このような攻撃からリソースを保護するには、Usageからの追加のレプリケーションが必要です。"
    },
    {
      "indent": 0,
      "text": "10.5. Joining",
      "section_title": true,
      "ja": "10.5. 接合"
    },
    {
      "indent": 3,
      "text": "The join process for a Joining Node (JN) with Node-ID n is as follows:",
      "ja": "ノードID nの結合ノード（JN）の結合プロセスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. JN MUST connect to its chosen bootstrap node, as specified in Section 11.4.",
      "ja": "1. JNは、セクション11.4で指定されているように、選択したブートストラップノードに接続する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. JN SHOULD send an Attach request to the Admitting Peer (AP) for Resource-ID n+1. The \"send_update\" flag can be used to acquire the Routing Table of AP.",
      "ja": "2. JNは、リソースID n + 1の接続ピア（AP）に接続要求を送信する必要があります（SHOULD）。 「send_update」フラグを使用して、APのルーティングテーブルを取得できます。"
    },
    {
      "indent": 3,
      "text": "3. JN SHOULD send Attach requests to initiate connections to each of the peers in the Neighbor Table as well as to the desired peers in the Finger Table. Note that this does not populate their Routing Tables, but only their Connection Tables, so JN will not get messages that it is expected to route to other nodes.",
      "ja": "3. JN SHOULDは、Neighbor Tableの各ピアと、Finger Tableの目的のピアへの接続を開始するために、アタッチ要求を送信する必要があります。これは、ルーティングテーブルではなく接続テーブルにのみデータを入力するため、JNは他のノードにルーティングすることが期待されるメッセージを取得しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "4. JN MUST enter into its Routing Table all the peers that it has successfully contacted.",
      "ja": "4. JNは、正常に接続したすべてのピアをルーティングテーブルに入力する必要があります。"
    },
    {
      "indent": 3,
      "text": "5. JN MUST send a Join to AP. The AP MUST send the response to the Join.",
      "ja": "5. JNはAPに参加を送信する必要があります。 APは参加への応答を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "6. AP MUST do a series of Store requests to JN to store the data that JN will be responsible for.",
      "ja": "6. APは、JNが担当するデータを保存するために、JNに対して一連のStoreリクエストを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "7. AP MUST send JN an Update explicitly labeling JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP MAY now forget any data which is assigned to JN and not AP. AP SHOULD NOT forget any data where AP is the replica set for the data.",
      "ja": "7. APは、JNをその前任者として明示的にラベル付けした更新をJNに送信する必要があります。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは、APではなくJNに割り当てられているデータをすべて忘れる場合があります。 APは、APがデータのレプリカセットであるデータを忘れないでください。"
    },
    {
      "indent": 3,
      "text": "8. The AP MUST send an Update to all of its neighbors (including JN) with the new values of its neighbor set (including JN).",
      "ja": "8. APは、ネイバーセット（JNを含む）の新しい値を使用して、そのネイバー（JNを含む）のすべてにアップデートを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "9. JN MUST send Updates to all of the peers in its Neighbor Table.",
      "ja": "9. JNは、ネイバーテーブル内のすべてのピアに更新を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If JN sends an Attach to AP with send_update, it immediately knows most of its expected neighbors from AP's Routing Table update and MAY directly connect to them. This is the RECOMMENDED procedure.",
      "ja": "JNがAttachをsend_updateを使用してAPに送信する場合、JNはAPのルーティングテーブルの更新から予想されるネイバーのほとんどを即座に認識し、それらに直接接続できます（MAY）。これはRECOMMENDEDプロシージャです。"
    },
    {
      "indent": 3,
      "text": "If for some reason JN does not get AP's Routing Table, it MAY still populate its Neighbor Table incrementally. It SHOULD send a Ping directed at Resource-ID n+1 (directly after its own Resource-ID). This allows JN to discover its own successor. Call that node p0. JN then SHOULD send a Ping to p0+1 to discover its successor (p1). This process MAY be repeated to discover as many successors as desired. The values for the two peers before p will be found at a later stage, when n receives an Update. An alternate procedure is to send Attaches to those nodes rather than Pings, which form the connections immediately, but may be slower if the nodes need to collect ICE candidates.",
      "ja": "何らかの理由でJNがAPのルーティングテーブルを取得しない場合でも、JNは引き続きネイバーテーブルにデータを追加していきます。リソースID n + 1に向けられたPingを送信する必要があります（自身のリソースIDの直後）。これにより、JNは自身の後続を検出できます。そのノードをp0と呼びます。その後、JNはP0をp0 + 1に送信して、後続（p1）を検出する必要があります（SHOULD）。このプロセスは、必要なだけ後継者を発見するために繰り返される場合があります。 pの前の2つのピアの値は、nが更新を受け取った後の段階で見つかります。別の手順として、PingではなくAttachesをこれらのノードに送信します。Pingはすぐに接続を形成しますが、ノードがICE候補を収集する必要がある場合は遅くなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In order to set up its i'th Finger Table entry, JN MUST send an Attach to peer n+2^(128-i). This will be routed to a peer in approximately the right location around the ring. (Note that the first entry in the Finger Table has i=1 and not i=0 in this formulation.)",
      "ja": "i番目のフィンガーテーブルエントリを設定するために、JNはアタッチをピアに送信する必要がありますn + 2 ^（128-i）。これは、リングのほぼ適切な場所にあるピアにルーティングされます。 （この定式化では、Finger Tableの最初のエントリにはi = 1があり、i = 0はないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The Joining Node MUST NOT send any Update message placing itself in the overlay until it has successfully completed an Attach with each peer that should be in its Neighbor Table.",
      "ja": "参加ノードは、ネイバーテーブルにある各ピアとの接続が正常に完了するまで、自身をオーバーレイに配置する更新メッセージを送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "10.6. Routing Attaches",
      "section_title": true,
      "ja": "10.6. ルーティングアタッチ"
    },
    {
      "indent": 3,
      "text": "When a peer needs to Attach to a new peer in its Neighbor Table, it MUST source-route the Attach request through the peer from which it learned the new peer's Node-ID. Source-routing these requests allows the overlay to recover from instability.",
      "ja": "ピアがネイバーテーブルの新しいピアに接続する必要がある場合、ピアは、新しいピアのノードIDを学習したピアを介して接続要求をソースルーティングする必要があります。これらのリクエストをソースルーティングすると、オーバーレイを不安定から回復できます。"
    },
    {
      "indent": 3,
      "text": "All other Attach requests, such as those for new Finger Table entries, are routed conventionally through the overlay.",
      "ja": "新しいFinger Tableエントリのリクエストなど、他のすべてのAttachリクエストは、通常、オーバーレイを介してルーティングされます。"
    },
    {
      "indent": 0,
      "text": "10.7. Updates",
      "section_title": true,
      "ja": "10.7. アップデート"
    },
    {
      "indent": 3,
      "text": "An Update for this DHT is defined as:",
      "ja": "このDHTのアップデートは次のように定義されています。"
    },
    {
      "indent": 8,
      "text": "enum { invalidChordUpdateType(0),\n       peer_ready(1), neighbors(2), full(3), (255) }\n     ChordUpdateType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "struct {\n   uint32                 uptime;\n   ChordUpdateType        type;\n   select (type){\n    case peer_ready:                   /* Empty */\n      ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case neighbors:\n  NodeId              predecessors<0..2^16-1>;\n  NodeId              successors<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "    case full:\n      NodeId              predecessors<0..2^16-1>;\n      NodeId              successors<0..2^16-1>;\n      NodeId              fingers<0..2^16-1>;\n  };\n} ChordUpdate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"uptime\" field contains the time this peer has been up in seconds.",
      "ja": "「uptime」フィールドには、このピアがアップしていた時間が秒単位で含まれます。"
    },
    {
      "indent": 3,
      "text": "The \"type\" field contains the type of the update, which depends on the reason the update was sent.",
      "ja": "「タイプ」フィールドには、更新のタイプが含まれます。これは、更新が送信された理由によって異なります。"
    },
    {
      "indent": 3,
      "text": "peer_ready This peer is ready to receive messages. This message is used to indicate that a node which has Attached is a peer and can be routed through. It is also used as a connectivity check to non-neighbor peers.",
      "ja": "peer_readyこのピアはメッセージを受信する準備ができています。このメッセージは、接続されているノードがピアであり、ルーティングできることを示すために使用されます。また、非隣接ピアへの接続チェックとしても使用されます。"
    },
    {
      "indent": 3,
      "text": "neighbors This version is sent to members of the Chord Neighbor Table.",
      "ja": "近隣このバージョンは、コード近隣テーブルのメンバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "full This version is sent to peers which request an Update with a RouteQueryReq.",
      "ja": "fullこのバージョンは、RouteQueryReqで更新を要求するピアに送信されます。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"neighbors\", then the contents of the message will be:",
      "ja": "メッセージのタイプが「ネイバー」の場合、メッセージの内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The predecessor set of the Updating peer.",
      "ja": "predecessors更新ピアの先行セット。"
    },
    {
      "indent": 3,
      "text": "successors The successor set of the Updating peer.",
      "ja": "後継者更新ピアの後継者セット。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"full\", then the contents of the message will be:",
      "ja": "メッセージのタイプが「完全」の場合、メッセージの内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The predecessor set of the Updating peer.",
      "ja": "predecessors更新ピアの先行セット。"
    },
    {
      "indent": 3,
      "text": "successors The successor set of the Updating peer.",
      "ja": "後継者更新ピアの後継者セット。"
    },
    {
      "indent": 3,
      "text": "fingers The Finger Table of the Updating peer, in numerically ascending order.",
      "ja": "fingers数値の昇順の更新ピアのFinger Table。"
    },
    {
      "indent": 3,
      "text": "A peer MUST maintain an association (via Attach) to every member of its neighbor set. A peer MUST attempt to maintain at least three predecessors and three successors, even though this will not be possible if the ring is very small. It is RECOMMENDED that O(log(N)) predecessors and successors be maintained in the neighbor set. There are many ways to estimate N, some of which are discussed in [DHT-RELOAD].",
      "ja": "ピアは、隣接セットのすべてのメンバーへの関連付けを（アタッチを介して）維持する必要があります。ピアが少なくとも3つの先行ノードと3つの後続ノードを維持しようと試みなければならない（ただし、リングが非常に小さい場合は不可能です）。 O（log（N））の先行ノードと後続ノードをネイバーセットで維持することをお勧めします。 Nを推定するには多くの方法があり、そのうちのいくつかは[DHT-RELOAD]で説明されています。"
    },
    {
      "indent": 0,
      "text": "10.7.1. Handling Neighbor Failures",
      "section_title": true,
      "ja": "10.7.1. ネイバー障害の処理"
    },
    {
      "indent": 3,
      "text": "Every time a connection to a peer in the Neighbor Table is lost (as determined by connectivity pings or the failure of some request), the peer MUST remove the entry from its Neighbor Table and replace it with the best match it has from the other peers in its Routing Table. If using reactive recovery, the peer MUST send an immediate Update to all nodes in its Neighbor Table. The update will contain all the Node-IDs of the current entries of the table (after the failed one has been removed). Note that when replacing a successor, the peer SHOULD delay the creation of new replicas for the successor replacement hold-down time (30 seconds) after removing the failed entry from its Neighbor Table in order to allow a triggered update to inform it of a better match for its Neighbor Table.",
      "ja": "隣接テーブル内のピアへの接続が失われるたびに（接続pingまたは何らかの要求の失敗によって決定される）、ピアはその隣接テーブルからエントリを削除し、それを他のピアからの最も一致するものと置き換える必要がありますルーティングテーブル内。リアクティブリカバリを使用する場合、ピアはネイバーテーブル内のすべてのノードに即時更新を送信する必要があります。更新には、テーブルの現在のエントリのすべてのノードIDが含まれます（失敗したノードが削除された後）。後継者を交換する場合、トリガーされた更新がより良いことを通知できるように、ピアは近隣テーブルから失敗したエントリを削除した後、後継者の交換ホールドダウン時間（30秒）の間、新しいレプリカの作成を遅らせる必要があります（SHOULD）ネイバーテーブルと一致します。"
    },
    {
      "indent": 3,
      "text": "If the neighbor failure affects the peer's range of responsible IDs, then the Update MUST be sent to all nodes in its Connection Table.",
      "ja": "ネイバーの障害がピアの責任IDの範囲に影響を与える場合は、接続テーブル内のすべてのノードに更新を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A peer MAY attempt to reestablish connectivity with a lost neighbor either by waiting additional time to see if connectivity returns or by actively routing a new Attach to the lost peer. Details for these procedures are beyond the scope of this document. In the case of an attempt to reestablish connectivity with a lost neighbor, the peer MUST be removed from the Neighbor Table. Such a peer is returned to the Neighbor Table once connectivity is reestablished.",
      "ja": "ピアは、接続が戻るかどうかを確認するために追加の時間待機するか、新しい接続を失われたピアにアクティブにルーティングすることにより、失われたネイバーとの接続を再確立しようとする場合があります。これらの手順の詳細は、このドキュメントの範囲外です。失われたネイバーとの接続を再確立する試みの場合、ピアはネイバーテーブルから削除する必要があります。接続が再確立されると、このようなピアはネイバーテーブルに返されます。"
    },
    {
      "indent": 3,
      "text": "If connectivity is lost to all successor peers in the Neighbor Table, then this peer SHOULD behave as if it is joining the network and MUST use Pings to find a peer and send it a Join. If connectivity is lost to all the peers in the Finger Table, this peer SHOULD assume that it has been disconnected from the rest of the network, and it SHOULD periodically try to join the DHT.",
      "ja": "ネイバーテーブル内のすべての後続ピアへの接続が失われた場合、このピアはネットワークに参加しているように動作する必要があり（SHOULD）、Pingを使用してピアを見つけ、Joinを送信する必要があります。 Finger Tableのすべてのピアへの接続が失われた場合、このピアは、ネットワークの残りの部分から切断されていると想定し、定期的にDHTへの参加を試行する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "10.7.2. Handling Finger Table Entry Failure",
      "section_title": true,
      "ja": "10.7.2. フィンガーテーブルエントリの失敗の処理"
    },
    {
      "indent": 3,
      "text": "If a Finger Table entry is found to have failed (as determined by connectivity pings or the failure of some request), all references to the failed peer MUST be removed from the Finger Table and replaced with the closest preceding peer from the Finger Table or Neighbor Table.",
      "ja": "フィンガーテーブルエントリが失敗したことが判明した場合（接続pingまたはいくつかの要求の失敗によって判断）、失敗したピアへのすべての参照をフィンガーテーブルから削除し、フィンガーテーブルまたはネイバーから最も近い先行ピアと置き換える必要があります。テーブル。"
    },
    {
      "indent": 3,
      "text": "If using reactive recovery, the peer MUST initiate a search for a new Finger Table entry, as described below.",
      "ja": "リアクティブリカバリを使用している場合、ピアは、以下で説明するように、新しいFinger Tableエントリの検索を開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.7.3. Receiving Updates",
      "section_title": true,
      "ja": "10.7.3. 更新の受信"
    },
    {
      "indent": 3,
      "text": "When a peer x receives an Update request, it examines the Node-IDs in the UpdateReq and at its Neighbor Table and decides if this UpdateReq would change its Neighbor Table. This is done by taking the set of peers currently in the Neighbor Table and comparing them to the peers in the Update request. There are two major cases:",
      "ja": "ピアxが更新要求を受信すると、UpdateReqとその近隣テーブルのノードIDを調べ、このUpdateReqが近隣テーブルを変更するかどうかを決定します。これは、現在ネイバーテーブルにあるピアのセットを取得し、それらをUpdateリクエストのピアと比較することで行われます。主なケースは2つあります。"
    },
    {
      "indent": 3,
      "text": "o The UpdateReq contains peers that match x's Neighbor Table, so no change is needed to the neighbor set.",
      "ja": "o UpdateReqには、xのネイバーテーブルと一致するピアが含まれているため、ネイバーセットを変更する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o The UpdateReq contains peers that x does not know about that should be in x's Neighbor Table; i.e., they are closer than entries in the Neighbor Table.",
      "ja": "o UpdateReqには、xのネイバーテーブルに存在する必要があることをxが認識していないピアが含まれています。つまり、それらはネイバーテーブルのエントリよりも近くにあります。"
    },
    {
      "indent": 3,
      "text": "In the first case, no change is needed.",
      "ja": "最初のケースでは、変更は必要ありません。"
    },
    {
      "indent": 3,
      "text": "In the second case, x MUST attempt to Attach to the new peers, and if it is successful, it MUST adjust its neighbor set accordingly. Note that x can maintain the now inferior peers as neighbors, but it MUST remember the closer ones.",
      "ja": "2番目のケースでは、xは新しいピアへの接続を試みなければならず、成功した場合、それに応じてネイバーセットを調整する必要があります。 xは、現在劣っているピアをネイバーとして維持できますが、より近いものを記憶する必要があります。"
    },
    {
      "indent": 3,
      "text": "After any Pings and Attaches are done, if the Neighbor Table changes and the peer is using reactive recovery, the peer MUST send an Update request to each member of its Connection Table. These Update requests are what end up filling in the predecessor/successor tables of peers that this peer is a neighbor to. A peer MUST NOT enter itself in its successor or predecessor table and instead should leave the entries empty.",
      "ja": "PingとAttachが行われた後、ネイバーテーブルが変更され、ピアがリアクティブリカバリを使用している場合、ピアは接続テーブルの各メンバーに更新リクエストを送信する必要があります。これらの更新要求は、このピアがネイバーであるピアの先行/後続テーブルを埋めることになります。ピアは、後続または先行テーブルに自分自身を入力してはならず（MUST NOT）、代わりにエントリを空のままにする必要があります。"
    },
    {
      "indent": 3,
      "text": "If peer x is responsible for a Resource-ID R and x discovers that the replica set for R (the next two nodes in its successor set) has changed, it MUST send a Store for any data associated with R to any new node in the replica set. It SHOULD NOT delete data from peers which have left the replica set.",
      "ja": "ピアxがResource-ID Rを担当し、xがRのレプリカセット（その後続セットの次の2つのノード）が変更されたことを検出した場合、Rに関連付けられたすべてのデータのストアを、レプリカセット。レプリカセットを離れたピアからデータを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "When peer x detects that it is no longer in the replica set for a resource R (i.e., there are three predecessors between x and R), it SHOULD delete all data associated with R from its local store.",
      "ja": "ピアxがそれがリソースRのレプリカセットに存在しないことを検出すると（つまり、xとRの間に3つの先行操作がある）、Rに関連付けられたすべてのデータをローカルストアから削除する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "When a peer discovers that its range of responsible IDs has changed, it MUST send an Update to all entries in its Connection Table.",
      "ja": "ピアが責任IDの範囲が変更されたことを検出した場合、ピアは接続テーブルのすべてのエントリに更新を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.7.4. Stabilization",
      "section_title": true,
      "ja": "10.7.4. 安定"
    },
    {
      "indent": 3,
      "text": "There are four components to stabilization:",
      "ja": "安定化には4つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "1. Exchange Updates with all peers in its Neighbor Table to exchange state.",
      "ja": "1. ネイバーテーブル内のすべてのピアと更新を交換して、状態を交換します。"
    },
    {
      "indent": 3,
      "text": "2. Search for better peers to place in its Finger Table.",
      "ja": "2. フィンガーテーブルに配置するより良いピアを検索します。"
    },
    {
      "indent": 3,
      "text": "3. Search to determine if the current Finger Table size is sufficiently large.",
      "ja": "3. 検索して、現在のフィンガーテーブルのサイズが十分に大きいかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "4. Search to determine if the overlay has partitioned and needs to recover.",
      "ja": "4. オーバーレイが分割され、回復する必要があるかどうかを確認するために検索します。"
    },
    {
      "indent": 0,
      "text": "10.7.4.1. Updating the Neighbor Table",
      "section_title": true,
      "ja": "10.7.4.1. ネイバーテーブルの更新"
    },
    {
      "indent": 3,
      "text": "A peer MUST periodically send an Update request to every peer in its Neighbor Table. The purpose of this is to keep the predecessor and successor lists up to date and to detect failed peers. The default time is about every ten minutes, but the configuration server SHOULD set this in the Configuration Document using the \"chord-update-interval\" element (denominated in seconds). A peer SHOULD randomly offset these Update requests so they do not occur all at once.",
      "ja": "ピアは、隣接テーブル内のすべてのピアに定期的に更新リクエストを送信する必要があります。これの目的は、先行リストと後続リストを最新の状態に保ち、失敗したピアを検出することです。デフォルトの時間は約10分ごとですが、構成サーバーは「chord-update-interval」要素（秒単位）を使用して構成文書でこれを設定する必要があります（SHOULD）。ピアは、これらの更新リクエストをランダムにオフセットして、一度に発生しないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "10.7.4.2. Refreshing the Finger Table",
      "section_title": true,
      "ja": "10.7.4.2. 指テーブルをリフレッシュする"
    },
    {
      "indent": 3,
      "text": "A peer MUST periodically search for new peers to replace invalid entries in the Finger Table. For peer x, the i'th Finger Table entry is valid if it is in the range [ x+2^( 128-i ), x+2^( 128-(i-1) )-1 ]. Invalid entries occur in the Finger Table when a previous Finger Table entry has failed or when no peer has been found in that range.",
      "ja": "ピアは定期的に新しいピアを検索して、フィンガーテーブルの無効なエントリを置き換える必要があります。ピアxの場合、[x + 2 ^（128-i）、x + 2 ^（128-（i-1））-1]の範囲にあるi番目のフィンガーテーブルエントリは有効です。前のFinger Tableエントリが失敗した場合、またはその範囲でピアが見つからなかった場合、Finger Tableで無効なエントリが発生します。"
    },
    {
      "indent": 3,
      "text": "Two possible methods for searching for new peers for the Finger Table entries are presented:",
      "ja": "Finger Tableエントリの新しいピアを検索する2つの可能な方法が提示されます。"
    },
    {
      "indent": 3,
      "text": "Alternative 1: A peer selects one entry in the Finger Table from among the invalid entries. It pings for a new peer for that Finger Table entry. The selection SHOULD be exponentially weighted to attempt to replace earlier (lower i) entries in the Finger Table. A simple way to implement this selection is to search through the Finger Table entries from i=1, and each time an invalid entry is encountered, send a Ping to replace that entry with probability 0.5.",
      "ja": "代替策1：ピアは、無効なエントリの中からFinger Tableのエントリを1つ選択します。そのフィンガーテーブルエントリの新しいピアにpingを送信します。選択は、フィンガーテーブルの以前の（低いi）エントリを置き換えるように指数的に重み付けする必要があります（SHOULD）。この選択を実装する簡単な方法は、i = 1からFinger Tableエントリを検索し、無効なエントリが検出されるたびにPingを送信して、そのエントリを確率0.5で置き換えることです。"
    },
    {
      "indent": 3,
      "text": "Alternative 2: A peer monitors the Update messages received from its connections to observe when an Update indicates a peer that would be used to replace an invalid Finger Table entry, i, and flags that entry in the Finger Table. Every \"chord-ping-interval\" seconds, the peer selects from among those flagged candidates using an exponentially weighted probability, as above.",
      "ja": "代替策2：ピアは、接続から受信した更新メッセージを監視して、更新が無効なフィンガーテーブルエントリiを置き換えるために使用されるピアを示し、フィンガーテーブル内のそのエントリにフラグを立てるタイミングを監視します。 「chord-ping-interval」秒ごとに、ピアは、上記のように指数的に重み付けされた確率を使用して、フラグが付けられた候補の中から選択します。"
    },
    {
      "indent": 3,
      "text": "When searching for a better entry, the peer SHOULD send the Ping to a Node-ID selected randomly from that range. Random selection is preferred over a search for strictly spaced entries to minimize the effect of churn on overlay routing [minimizing-churn-sigcomm06]. An implementation or subsequent specification MAY choose a method for selecting Finger Table entries other than choosing randomly within the range. Any such alternate methods SHOULD be employed only on Finger Table stabilization and not for the selection of initial Finger Table entries unless the alternative method is faster and imposes less overhead on the overlay.",
      "ja": "より適切なエントリを検索する場合、ピアはその範囲からランダムに選択されたノードIDにPingを送信する必要があります（SHOULD）。オーバーレイルーティングに対するチャーンの影響を最小限に抑えるために、厳密に間隔を空けたエントリの検索よりもランダム選択が推奨されます[最小化チャーンsigcomm06]。実装または後続の仕様は、範囲内でランダムに選択する以外に、Finger Tableエントリを選択する方法を選択する場合があります。このような代替方法は、高速でオーバーレイのオーバーヘッドが少ない限り、フィンガーテーブルの安定化でのみ使用し、初期のフィンガーテーブルエントリの選択では使用しないでください。"
    },
    {
      "indent": 3,
      "text": "A peer SHOULD NOT send Ping requests looking for new finger table entries more often than the configuration element \"chord-ping-interval\", which defaults to 3600 seconds (one per hour).",
      "ja": "ピアは、構成要素「chord-ping-interval」（デフォルトは3600秒（1時間に1つ））よりも頻繁に新しいfingerテーブルエントリを探すPingリクエストを送信しないでください。"
    },
    {
      "indent": 3,
      "text": "A peer MAY choose to keep connections to multiple peers that can act for a given Finger Table entry.",
      "ja": "ピアは、特定のフィンガーテーブルエントリに対して機能できる複数のピアへの接続を維持することを選択できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "10.7.4.3. Adjusting Finger Table Size",
      "section_title": true,
      "ja": "10.7.4.3. フィンガーテーブルサイズの調整"
    },
    {
      "indent": 3,
      "text": "If the Finger Table has fewer than 16 entries, the node SHOULD attempt to discover more fingers to grow the size of the table to 16. The value 16 was chosen to ensure high odds of a node maintaining connectivity to the overlay even with strange network partitions.",
      "ja": "フィンガーテーブルのエントリが16未満の場合、ノードは、テーブルのサイズを16に拡大するために、より多くのフィンガーを検出しようとする必要があります（SHOULD）。 。"
    },
    {
      "indent": 3,
      "text": "For many overlays, 16 Finger Table entries will be enough, but as an overlay grows very large, more than 16 entries may be required in the Finger Table for efficient routing. An implementation SHOULD be capable of increasing the number of entries in the Finger Table to 128 entries.",
      "ja": "多くのオーバーレイでは、16のフィンガーテーブルエントリで十分ですが、オーバーレイが非常に大きくなると、効率的なルーティングのために、フィンガーテーブルで16を超えるエントリが必要になる場合があります。実装は、フィンガーテーブルのエントリ数を128エントリに増やすことができる必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Although log(N) entries are all that are required for optimal performance, careful implementation of stabilization will result in no additional traffic being generated when maintaining a Finger Table larger than log(N) entries. Implementers are encouraged to make use of RouteQuery and algorithms for determining where new Finger Table entries may be found. Complete details of possible implementations are outside the scope of this specification.",
      "ja": "最適なパフォーマンスに必要なのはlog（N）エントリだけですが、安定化を注意深く実装すると、log（N）エントリより大きいFinger Tableを維持するときに追加のトラフィックが生成されなくなります。実装者は、RouteQueryとアルゴリズムを利用して、新しいFinger Tableエントリがどこにあるかを判断することをお勧めします。可能な実装の完全な詳細は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "A simple approach to sizing the Finger Table is to ensure that the Finger Table is large enough to contain at least the final successor in the peer's Neighbor Table.",
      "ja": "Finger Tableのサイズを設定する簡単な方法は、Finger Tableが少なくともピアのネイバーテーブルの最後のサクセサを含むのに十分な大きさであることを確認することです。"
    },
    {
      "indent": 0,
      "text": "10.7.4.4. Detecting Partitioning",
      "section_title": true,
      "ja": "10.7.4.4. パーティション分割の検出"
    },
    {
      "indent": 3,
      "text": "To detect that a partitioning has occurred and to heal the overlay, a peer P MUST periodically repeat the discovery process used in the initial join for the overlay to locate an appropriate bootstrap node, B. P SHOULD then send a Ping for its own Node-ID routed through B. If a response is received from peer S', which is not P's successor, then the overlay is partitioned and P SHOULD send an Attach to S' routed through B, followed by an Update sent to S'. (Note that S' may not be in P's Neighbor Table once the overlay is healed, but the connection will allow S' to discover appropriate neighbor entries for itself via its own stabilization.)",
      "ja": "パーティショニングが発生したことを検出し、オーバーレイを修復するために、ピアPは、オーバーレイの初期結合で使用された検出プロセスを定期的に繰り返して、適切なブートストラップノードBを特定する必要があります。次に、Pは独自のノードのPingを送信する必要があります- Bを介してルーティングされるID。ピアのS 'から応答が受信された場合（Pの後継ではありません）、オーバーレイは分割され、PはBを介してルーティングされるS'にAttachを送信し、その後S 'に送信される更新を送信します。 （オーバーレイが修復されると、S 'はPのネイバーテーブルに存在しない可能性がありますが、接続により、S'は独自の安定化を介してS 'が自身の適切なネイバーエントリを検出できるようになります。）"
    },
    {
      "indent": 3,
      "text": "Future specifications may describe alternative mechanisms for determining when to repeat the discovery process.",
      "ja": "将来の仕様では、発見プロセスを繰り返すタイミングを決定するための代替メカニズムについて説明する可能性があります。"
    },
    {
      "indent": 0,
      "text": "10.8. Route Query f.in 3",
      "section_title": true,
      "ja": "10.8. ルートクエリf.in 3"
    },
    {
      "indent": 7,
      "text": "For CHORD-RELOAD, the RouteQueryReq contains no additional information. The RouteQueryAns contains the single Node-ID of the next peer to which the responding peer would have routed the request message in recursive routing:",
      "ja": "CHORD-RELOADの場合、RouteQueryReqには追加情報は含まれません。 RouteQueryAnsには、応答ピアが要求メッセージを再帰ルーティングでルーティングした次のピアの単一のノードIDが含まれています。"
    },
    {
      "indent": 6,
      "text": "struct {\n   NodeId                  next_peer;\n} ChordRouteQueryAns;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "この構造の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "next_peer The peer to which the responding peer would route the message in order to deliver it to the destination listed in the request.",
      "ja": "next_peer要求にリストされている宛先にメッセージを配信するために、応答するピアがメッセージをルーティングするピア。"
    },
    {
      "indent": 3,
      "text": "If the requester has set the send_update flag, the responder SHOULD initiate an Update immediately after sending the RouteQueryAns.",
      "ja": "リクエスターがsend_updateフラグを設定した場合、レスポンダーはRouteQueryAnsを送信した直後に更新を開始する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "10.9. Leaving",
      "section_title": true,
      "ja": "10.9. 去る"
    },
    {
      "indent": 3,
      "text": "To support extensions, such as [DHT-RELOAD], peers SHOULD send a Leave request to all members of their Neighbor Table before exiting the Overlay Instance. The overlay_specific_data field MUST contain the ChordLeaveData structure, defined below:",
      "ja": "[DHT-RELOAD]などの拡張をサポートするために、ピアは、オーバーレイインスタンスを終了する前に、ネイバーテーブルのすべてのメンバーに脱退要求を送信する必要があります（SHOULD）。 overlay_specific_dataフィールドには、以下で定義するChordLeaveData構造を含める必要があります。"
    },
    {
      "indent": 14,
      "text": "enum { invalidChordLeaveType(0),\n        from_succ(1), from_pred(2), (255) }\n      ChordLeaveType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "struct {\n  ChordLeaveType         type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "select (type) {\n  case from_succ:\n    NodeId            successors<0..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "     case from_pred:\n       NodeId           predecessors<0..2^16-1>;\n   };\n} ChordLeaveData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"type\" field indicates whether the Leave request was sent by a predecessor or a successor of the recipient:",
      "ja": "「タイプ」フィールドは、脱退要求が受信者の先行者または後続者によって送信されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "from_succ The Leave request was sent by a successor.",
      "ja": "from_succ脱退リクエストは後継者から送信されました。"
    },
    {
      "indent": 3,
      "text": "from_pred The Leave request was sent by a predecessor.",
      "ja": "from_pred脱退リクエストは、前任者によって送信されました。"
    },
    {
      "indent": 3,
      "text": "If the type of the request is \"from_succ\", the contents will be:",
      "ja": "リクエストのタイプが「from_succ」の場合、コンテンツは次のようになります。"
    },
    {
      "indent": 3,
      "text": "successors The sender's successor list.",
      "ja": "後継者送信者の後継者リスト。"
    },
    {
      "indent": 3,
      "text": "If the type of the request is \"from_pred\", the contents will be:",
      "ja": "リクエストのタイプが「from_pred」の場合、コンテンツは次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The sender's predecessor list.",
      "ja": "predecessors送信者の先行リスト。"
    },
    {
      "indent": 3,
      "text": "Any peer which receives a Leave for a peer n in its neighbor set MUST follow procedures as if it had detected a peer failure as described in Section 10.7.1.",
      "ja": "隣接セットでピアnのLeaveを受信するピアは、セクション10.7.1で説明されているように、ピア障害を検出したかのように手順に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "11. Enrollment and Bootstrap",
      "section_title": true,
      "ja": "11. 登録とブートストラップ"
    },
    {
      "indent": 3,
      "text": "The section defines the format of the configuration data as well the process to join a new overlay.",
      "ja": "このセクションでは、構成データのフォーマットと、新しいオーバーレイを結合するプロセスを定義します。"
    },
    {
      "indent": 0,
      "text": "11.1. Overlay Configuration",
      "section_title": true,
      "ja": "11.1. オーバーレイ構成"
    },
    {
      "indent": 3,
      "text": "This specification defines a new content type \"application/p2p-overlay+xml\" for a MIME entity that contains overlay information. An example document is shown below:",
      "ja": "この仕様では、オーバーレイ情報を含むMIMEエンティティの新しいコンテンツタイプ「application / p2p-overlay + xml」を定義しています。ドキュメントの例を以下に示します。"
    },
    {
      "indent": 0,
      "text": "   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <overlay xmlns=\"urn:ietf:params:xml:ns:p2p:config-base\"\n      xmlns:ext=\"urn:ietf:params:xml:ns:p2p:config-ext1\"\n      xmlns:chord=\"urn:ietf:params:xml:ns:p2p:config-chord\">\n      <configuration instance-name=\"overlay.example.org\" sequence=\"22\"\n          expiration=\"2002-10-10T07:00:00Z\" ext:ext-example=\"stuff\" >\n          <topology-plugin> CHORD-RELOAD </topology-plugin>\n          <node-id-length>16</node-id-length>\n          <root-cert>\n   MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET\n   MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT\n   BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0\n   eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT\n   MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE\n   ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y\n   aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud\n   +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4\n   N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5\n   Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU\n   bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0\n   pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT\n   CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD\n   ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B\n   AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O\n   qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ\n   QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg==\n          </root-cert>\n          <root-cert> YmFkIGNlcnQK </root-cert>\n          <enrollment-server>https://example.org</enrollment-server>\n          <enrollment-server>https://example.net</enrollment-server>\n          <self-signed-permitted\n                    digest=\"sha1\">false</self-signed-permitted>\n          <bootstrap-node address=\"192.0.0.1\" port=\"6084\" />\n          <bootstrap-node address=\"192.0.2.2\" port=\"6084\" />\n          <bootstrap-node address=\"2001:DB8::1\" port=\"6084\" />\n          <turn-density> 20 </turn-density>\n          <clients-permitted> false </clients-permitted>\n          <no-ice> false </no-ice>\n          <chord:chord-update-interval>\n              400</chord:chord-update-interval>\n          <chord:chord-ping-interval>30</chord:chord-ping-interval>\n          <chord:chord-reactive> true </chord:chord-reactive>\n          <shared-secret> password </shared-secret>\n          <max-message-size>4000</max-message-size>\n          <initial-ttl> 30 </initial-ttl>\n          <overlay-reliability-timer> 3000 </overlay-reliability-timer>\n          <overlay-link-protocol>TLS</overlay-link-protocol>\n          <configuration-signer>47112162e84c69ba</configuration-signer>\n          <kind-signer> 47112162e84c69ba </kind-signer>\n          <kind-signer> 6eba45d31a900c06 </kind-signer>\n          <bad-node> 6ebc45d31a900c06 </bad-node>\n          <bad-node> 6ebc45d31a900ca6 </bad-node>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "<ext:example-extension> foo </ext:example-extension>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "<mandatory-extension>\n    urn:ietf:params:xml:ns:p2p:config-ext1\n</mandatory-extension>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "<required-kinds>\n  <kind-block>\n    <kind name=\"SIP-REGISTRATION\">",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "            <data-model>SINGLE</data-model>\n            <access-control>USER-MATCH</access-control>\n            <max-count>1</max-count>\n            <max-size>100</max-size>\n        </kind>\n        <kind-signature>\n             VGhpcyBpcyBub3QgcmlnaHQhCg==\n        </kind-signature>\n      </kind-block>\n      <kind-block>\n        <kind id=\"2000\">\n            <data-model>ARRAY</data-model>\n            <access-control>NODE-MULTIPLE</access-control>\n            <max-node-multiple>3</max-node-multiple>\n            <max-count>22</max-count>\n            <max-size>4</max-size>\n            <ext:example-kind-extension> 1\n                    </ext:example-kind-extension>\n        </kind>\n        <kind-signature>\n           VGhpcyBpcyBub3QgcmlnaHQhCg==\n        </kind-signature>\n      </kind-block>\n    </required-kinds>\n</configuration>\n<signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<configuration instance-name=\"other.example.net\">\n</configuration>\n<signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "</overlay>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The file MUST be a well-formed XML document, and it SHOULD contain an encoding declaration in the XML declaration. The file MUST use the UTF-8 character encoding. The namespaces for the elements defined in this specification are urn:ietf:params:xml:ns:p2p:config-base and urn:ietf:params:xml:ns:p2p:config-chord.",
      "ja": "ファイルは整形式のXMLドキュメントでなければならず、XML宣言にはエンコーディング宣言が含まれている必要があります。ファイルはUTF-8文字エンコーディングを使用する必要があります。この仕様で定義されている要素の名前空間は、urn：ietf：params：xml：ns：p2p：config-baseおよびurn：ietf：params：xml：ns：p2p：config-chordです。"
    },
    {
      "indent": 3,
      "text": "Note that elements or attributes that are defined as type xsd:boolean in the RELAX NG schema (Section 11.1.1) have two lexical representations, \"1\" or \"true\" for the concept true, and \"0\" or \"false\" for the concept false. Whitespace and case processing follows the rules of [OASIS.relax_ng] and XML Schema Datatypes [W3C.REC-xmlschema-2-20041028].",
      "ja": "RELAX NGスキーマ（セクション11.1.1）でタイプxsd：booleanとして定義されている要素または属性には、2つの字句表現があります。「true」は「1」または「true」、trueは「0」または「false」です。概念は偽です。空白と大文字と小文字の処理は、[OASIS.relax_ng]およびXMLスキーマデータ型[W3C.REC-xmlschema-2-20041028]のルールに従います。"
    },
    {
      "indent": 3,
      "text": "The file MAY contain multiple \"configuration\" elements, where each one contains the configuration information for a different overlay. Each configuration element MAY be followed by signature elements that provide a signature over the preceding configuration element. Each configuration element has the following attributes:",
      "ja": "ファイルには複数の「設定」要素が含まれている場合があり、各要素には異なるオーバーレイの設定情報が含まれています。各構成要素の後には、前の構成要素に対する署名を提供する署名要素が続く場合があります。各構成要素には次の属性があります。"
    },
    {
      "indent": 3,
      "text": "instance-name The name of the overlay (referred to as \"overlay name\" in this specification)",
      "ja": "instance-nameオーバーレイの名前（この仕様では「オーバーレイ名」と呼ばれます）"
    },
    {
      "indent": 3,
      "text": "expiration Time in the future at which this overlay configuration is no longer valid. The node SHOULD retrieve a new copy of the configuration at a randomly selected time that is before the expiration time. Note that if the certificates expire before a new configuration is retried, the node will not be able to validate the configuration file. All times MUST conform to the Internet date/time format defined in [RFC3339] and be specified using UTC.",
      "ja": "有効期限このオーバーレイ構成が無効になる将来の時刻。ノードは、有効期限より前のランダムに選択された時間に構成の新しいコピーを取得する必要があります（SHOULD）。新しい構成が再試行される前に証明書の有効期限が切れると、ノードは構成ファイルを検証できなくなります。すべての時間は、[RFC3339]で定義されているインターネットの日付/時刻形式に準拠し、UTCを使用して指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "sequence A monotonically increasing sequence number between 0 and 2^16-2.",
      "ja": "シーケンス0と2 ^ 16-2の間の単調に増加するシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "Inside each overlay element, the following elements can occur:",
      "ja": "各オーバーレイ要素の内部では、次の要素が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "topology-plug-in This element defines the overlay algorithm being used. If missing, the default is \"CHORD-RELOAD\".",
      "ja": "topology-plug-inこの要素は、使用されるオーバーレイアルゴリズムを定義します。欠落している場合、デフォルトは「CHORD-RELOAD」です。"
    },
    {
      "indent": 3,
      "text": "node-id-length This element contains the length of a NodeId (NodeIdLength), in bytes. This value MUST be between 16 (128 bits) and 20 (160 bits). If this element is not present, the default of 16 is used.",
      "ja": "node-id-lengthこのエレメントには、NodeId（NodeIdLength）の長さがバイト単位で含まれています。この値は16（128ビット）から20（160ビット）の間でなければなりません。この要素が存在しない場合、デフォルトの16が使用されます。"
    },
    {
      "indent": 3,
      "text": "root-cert This element contains a base-64-encoded X.509v3 certificate that is a root trust anchor used to sign all certificates in this overlay. There can be more than one root-cert element.",
      "ja": "root-certこの要素には、base64でエンコードされたX.509v3証明書が含まれます。この証明書は、このオーバーレイのすべての証明書に署名するために使用されるルートトラストアンカーです。 root-cert要素は複数存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "enrollment-server This element contains the URL at which the enrollment server can be reached in a \"url\" element. This URL MUST be of type \"https:\". More than one enrollment-server element MAY be present. Note that there is no necessary relationship between the overlay name/ configuration server name and the enrollment server name.",
      "ja": "enrollment-serverこの要素には、 \"url\"要素に、登録サーバーに到達できるURLが含まれています。このURLは「https：」タイプである必要があります。複数のenrollment-server要素が存在する場合があります。オーバーレイ名/構成サーバー名と登録サーバー名の間に必要な関係がないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "self-signed-permitted This element indicates whether self-signed certificates are permitted. If it is set to \"true\", then self-signed certificates are allowed, in which case the enrollment-server and root-cert elements MAY be absent. Otherwise, it SHOULD be absent, but MAY be set to \"false\". This element also contains an attribute \"digest\", which indicates the digest to be used to compute the Node-ID. Valid values for this parameter are \"sha1\" and \"sha256\", representing SHA-1 [RFC3174] and SHA-256 [RFC6234], respectively. Implementations MUST support both of these algorithms.",
      "ja": "self-signed-permittedこの要素は、自己署名証明書が許可されるかどうかを示します。これが「true」に設定されている場合、自己署名証明書が許可されます。この場合、enrollment-serverおよびroot-certエレメントは存在しない場合があります。それ以外の場合は存在しない必要がありますが、 \"false\"に設定できます（MAY）。この要素には、ノードIDの計算に使用されるダイジェストを示す属性「digest」も含まれています。このパラメーターの有効な値は「sha1」と「sha256」で、それぞれSHA-1 [RFC3174]とSHA-256 [RFC6234]を表します。実装は、これらのアルゴリズムの両方をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "bootstrap-node This element represents the address of one of the bootstrap nodes. It has an attribute called \"address\" that represents the IP address (either IPv4 or IPv6, since they can be distinguished) and an optional attribute called \"port\" that represents the port and defaults to 6084. The IPv6 address is in typical hexadecimal form using standard period and colon separators as specified in [RFC5952]. More than one bootstrap-node element MAY be present.",
      "ja": "bootstrap-nodeこの要素は、ブートストラップノードの1つのアドレスを表します。これには、IPアドレス（区別できるため、IPv4またはIPv6のいずれか）を表す「address」という属性と、ポートを表す「port」というオプションの属性があり、デフォルトは6084です。IPv6アドレスは通常の16進数形式です。 [RFC5952]で指定されている標準のピリオドとコロンの区切り文字を使用します。複数のbootstrap-node要素が存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "turn-density This element is a positive integer that represents the approximate reciprocal of density of nodes that can act as TURN servers. For example, if 5% of the nodes can act as TURN servers, this element would be set to 20. If it is not present, the default value is 1. If there are no TURN servers in the overlay, it is set to zero.",
      "ja": "turn-densityこの要素は、TURNサーバーとして機能できるノードの密度のおよその逆数を表す正の整数です。たとえば、ノードの5％がTURNサーバーとして機能できる場合、この要素は20に設定されます。それが存在しない場合、デフォルト値は1です。オーバーレイにTURNサーバーがない場合、ゼロに設定されます。 。"
    },
    {
      "indent": 3,
      "text": "clients-permitted This element represents whether clients are permitted or whether all nodes must be peers. If clients are permitted, the element MUST be set to \"true\" or be absent. If the nodes are not allowed to remain clients after the initial join, the element MUST be set to \"false\". There is currently no way for the overlay to enforce this.",
      "ja": "clients-permittedこの要素は、クライアントを許可するかどうか、またはすべてのノードをピアにする必要があるかどうかを表します。クライアントが許可されている場合、要素は「true」に設定するか、存在しない必要があります。最初の参加後、ノードがクライアントのままでいることが許可されない場合は、要素を「false」に設定する必要があります。現在、オーバーレイがこれを強制する方法はありません。"
    },
    {
      "indent": 3,
      "text": "no-ice This element represents whether nodes are REQUIRED to use the \"No-ICE\" Overlay Link protocols in this overlay. If it is absent, it is treated as if it were set to \"false\".",
      "ja": "no-iceこの要素は、ノードがこのオーバーレイで「No-ICE」オーバーレイリンクプロトコルを使用する必要があるかどうかを表します。存在しない場合は、「false」に設定されているものとして扱われます。"
    },
    {
      "indent": 3,
      "text": "chord-update-interval The update frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).",
      "ja": "chord-update-interval CHORD-RELOADトポロジプラグインの更新頻度（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "chord-ping-interval The Ping frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).",
      "ja": "chord-ping-interval CHORD-RELOADトポロジプラグインのPing頻度（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "chord-reactive Whether reactive recovery SHOULD be used for this overlay. It is set to \"true\" or \"false\". If missing, the default is \"true\" (see Section 10).",
      "ja": "chord-reactiveこのオーバーレイにリアクティブリカバリを使用する必要があるかどうか（SHOULD）。 「true」または「false」に設定されます。欠落している場合、デフォルトは「true」です（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "shared-secret If shared secret mode is used, this element contains the shared secret. The security guarantee here is that any agent which is able to access the Configuration Document (presumably protected by some sort of HTTP access control or network topology) is able to recover the shared secret and hence join the overlay.",
      "ja": "shared-secret共有秘密モードが使用されている場合、この要素には共有秘密が含まれます。ここでのセキュリティ保証は、構成ドキュメントにアクセスできる（おそらく何らかのHTTPアクセス制御またはネットワークトポロジーによって保護されている）エージェントが共有シークレットを回復して、オーバーレイに参加できることです。"
    },
    {
      "indent": 3,
      "text": "max-message-size Maximum size, in bytes, of any message in the overlay. If this value is not present, the default is 5000.",
      "ja": "max-message-sizeオーバーレイ内のメッセージの最大サイズ（バイト単位）。この値が存在しない場合、デフォルトは5000です。"
    },
    {
      "indent": 3,
      "text": "initial-ttl Initial default TTL for messages (see Section 6.3.2). If this value is not present, the default is 100.",
      "ja": "initial-ttlメッセージの初期デフォルトTTL（セクション6.3.2を参照）。この値が存在しない場合、デフォルトは100です。"
    },
    {
      "indent": 3,
      "text": "overlay-reliability-timer Default value for the end-to-end retransmission timer for messages, in milliseconds. If not present, the default value is 3000. The value MUST be at least 200 milliseconds, which means the minimum time delay before dropping a link is 1000 milliseconds.",
      "ja": "overlay-reliability-timerメッセージのエンドツーエンドの再送信タイマーのデフォルト値（ミリ秒単位）。存在しない場合、デフォルト値は3000です。値は少なくとも200ミリ秒である必要があります。つまり、リンクをドロップするまでの最小遅延は1000ミリ秒です。"
    },
    {
      "indent": 3,
      "text": "overlay-link-protocol Indicates a permissible overlay link protocol (see Section 6.6.1 for requirements for such protocols). An arbitrary number of these elements may appear. If none appear, then this implies the default value, \"TLS\", which refers to the use of TLS and DTLS. If one or more elements appear, then no default value applies.",
      "ja": "overlay-link-protocol許容されるオーバーレイリンクプロトコルを示します（そのようなプロトコルの要件については、セクション6.6.1を参照してください）。これらの要素の任意の数が表示される場合があります。何も表示されない場合、これはデフォルト値「TLS」を意味し、TLSとDTLSの使用を示します。 1つ以上の要素が表示される場合、デフォルト値は適用されません。"
    },
    {
      "indent": 3,
      "text": "kind-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign Kinds. Identifying kind-signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.",
      "ja": "kind-signerこれには、16進数の単一のノードIDが含まれ、このノードIDを持つ証明書が種類に署名できることを示します。証明書ではなくノードIDで種類の署名者を識別すると、更新された構成ファイルを常に提供する必要がなく、有効期間が短い証明書を使用できます。"
    },
    {
      "indent": 3,
      "text": "configuration-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign configurations for this instance-name. Identifying the signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.",
      "ja": "configuration-signerこれは、16進数の単一のノードIDを含み、このノードIDを持つ証明書がこのインスタンス名の構成に署名できることを示します。証明書ではなくノードIDで署名者を識別することにより、更新された構成ファイルを常に提供する必要がなく、有効期間が短い証明書を使用できます。"
    },
    {
      "indent": 3,
      "text": "bad-node This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID MUST NOT be considered valid. This allows certificate revocation. An arbitrary number of these elements can be provided. Note that because certificates may expire, bad-node entries need be present only for the lifetime of the certificate. Technically speaking, bad Node-IDs may be reused after their certificates have expired. The requirement for Node-IDs to be pseudorandomly generated gives this event a vanishing probability.",
      "ja": "bad-nodeこれには、16進数の単一のノードIDが含まれており、このノードIDを持つ証明書が有効であると見なしてはならないことを示します。これにより、証明書の失効が可能になります。任意の数のこれらの要素を提供できます。証明書が期限切れになる可能性があるため、不良ノードエントリは、証明書の有効期間中のみ存在する必要があることに注意してください。技術的には、不正なノードIDは、証明書の有効期限が切れた後に再利用される可能性があります。ノードIDを擬似ランダムに生成する必要があるため、このイベントは消失する可能性があります。"
    },
    {
      "indent": 3,
      "text": "mandatory-extension This element contains the name of an XML namespace that a node joining the overlay MUST support. The presence of a mandatory-extension element does not require the extension to be used in the current configuration file, but can indicate that it may be used in the future. Note that the namespace is case-sensitive, as specified in Section 2.3 of [w3c-xml-namespaces]. More than one mandatory-extension element MAY be present.",
      "ja": "required-extensionこの要素には、オーバーレイに参加するノードがサポートする必要があるXML名前空間の名前が含まれます。 required-extension要素が存在しても、現在の構成ファイルで使用する必要はありませんが、将来使用される可能性があることを示すことができます。 [w3c-xml-namespaces]のセクション2.3で指定されているように、名前空間では大文字と小文字が区別されることに注意してください。必須の拡張要素が複数存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "Inside each configuration element, the required-kinds element MAY also occur. This element indicates the Kinds that members MUST support and contains multiple kind-block elements that each define a single Kind that MUST be supported by nodes in the overlay. Each kind-block consists of a single kind element and a kind-signature. The kind element defines the Kind. The kind-signature is the signature computed over the kind element.",
      "ja": "各構成要素内では、必須の種類の要素も発生する場合があります。この要素は、メンバーがサポートする必要があるKindを示し、オーバーレイのノードによってサポートされる必要がある単一のKindをそれぞれ定義する複数のkind-block要素を含みます。各kind-blockは、単一のkind要素とkind-signatureで構成されています。 kind要素は種類を定義します。 kind-signatureは、kind要素に対して計算された署名です。"
    },
    {
      "indent": 3,
      "text": "Each kind element has either an id attribute or a name attribute. The name attribute is a string representing the Kind (the name registered to IANA), while the id is an integer Kind-ID allocated out of private space.",
      "ja": "各kind要素には、id属性またはname属性があります。 name属性はKind（IANAに登録された名前）を表す文字列で、idはプライベートスペースから割り当てられた整数のKind-IDです。"
    },
    {
      "indent": 3,
      "text": "In addition, the kind element MUST contain the following elements:",
      "ja": "さらに、kind要素には次の要素を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "max-count The maximum number of values which members of the overlay must support.",
      "ja": "max-countオーバーレイのメンバーがサポートする必要がある値の最大数。"
    },
    {
      "indent": 3,
      "text": "data-model The data model to be used.",
      "ja": "data-model使用するデータモデル。"
    },
    {
      "indent": 3,
      "text": "max-size The maximum size of individual values.",
      "ja": "max-size個々の値の最大サイズ。"
    },
    {
      "indent": 3,
      "text": "access-control The access control model to be used.",
      "ja": "access-control使用するアクセス制御モデル。"
    },
    {
      "indent": 3,
      "text": "The kind element MAY also contain the following element:",
      "ja": "kind要素には、次の要素も含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "max-node-multiple If the access control is NODE-MULTIPLE, this element MUST be included. This indicates the maximum value for the i counter. It MUST be an integer greater than 0.",
      "ja": "max-node-multipleアクセス制御がNODE-MULTIPLEの場合、この要素を含める必要があります。これは、iカウンターの最大値を示します。 0より大きい整数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "All of the non-optional values MUST be provided. If the Kind is registered with IANA, the data-model and access-control elements MUST match those in the Kind registration, and clients MUST ignore them in favor of the IANA versions. Multiple kind-block elements MAY be present.",
      "ja": "オプション以外のすべての値を指定する必要があります。 KindがIANAに登録されている場合、data-model要素とaccess-control要素はKind登録の要素と一致する必要があり、クライアントはIANAバージョンを優先してそれらを無視する必要があります。複数の種類ブロック要素が存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "The kind-block element also MUST contain a \"kind-signature\" element. This signature is computed across the kind element from the beginning of the first < of the kind element to the end of the last > of the kind element in the same way as the signature element described later in this section. kind-block elements MUST be signed by a node listed in the kind-signers block of the current configuration. Receivers MUST verify the signature prior to accepting a kind-block.",
      "ja": "kind-block要素には、「kind-signature」要素も含まれている必要があります。このシグニチャーは、このセクションで後述するシグニチャー・エレメントと同じ方法で、kindエレメントの最初の<の最初からkindエレメントの最後まで>のエレメント全体で計算されます。 kind-block要素は、現在の構成のkind-signersブロックにリストされているノードによって署名されている必要があります。受信者は、kind-blockを受け入れる前に署名を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The configuration element MUST be treated as a binary blob that cannot be changed -- including any whitespace changes -- or the signature will break. The signature MUST be computed by taking each configuration element and starting from, and including, the first < at the start of <configuration> up to and including the > in </ configuration> and treating this as a binary blob that MUST be signed using the standard SecurityBlock defined in Section 6.3.4. The SecurityBlock MUST be base-64 encoded using the base64 alphabet from [RFC4648] and MUST be put in the signature element following the configuration object in the configuration file. Any configuration file MUST be signed by one of the configuration-signer elements from the previous extant configuration. Recipients MUST verify the signature prior to accepting the configuration file.",
      "ja": "構成要素は、変更できないバイナリblobとして扱う必要があります（空白の変更を含む）。そうしないと、署名が壊れます。シグネチャは、各構成要素を取得し、<configuration>の最初の<から<を含めて> </ configuration>まで含めて計算し、これを使用して署名する必要があるバイナリblobとして扱う必要があります。セクション6.3.4で定義された標準のSecurityBlock SecurityBlockは、[RFC4648]のbase64アルファベットを使用してbase-64でエンコードする必要があり、構成ファイルの構成オブジェクトに続く署名要素に配置する必要があります。すべての構成ファイルは、以前の現存する構成からのconfiguration-signer要素の1つで署名する必要があります。受信者は、構成ファイルを受け入れる前に署名を検証する必要があります。"
    },
    {
      "indent": 0,
      "text": " When a node receives a new configuration file, it MUST change its configuration to meet the new requirements. This may require the node to exit the DHT and rejoin. If a node is not capable of supporting the new requirements, it MUST exit the overlay. If some information about a particular Kind changes from what the node previously knew about the Kind (for example, the max size), the new information in the configuration files overrides any previously learned information. If any Kind data was signed by a node that is no longer allowed to sign Kinds, that Kind MUST be discarded along with any stored information of that Kind. Note that forcing an avalanche restart of the overlay with a configuration change that requires rejoining the overlay may result in serious performance problems, including total collapse of the network if configuration parameters are not properly considered. Such an event may be necessary in case of a compromised CA or similar problem, but for large overlays, it should be avoided in almost all circumstances.",
      "ja": "ノードが新しい構成ファイルを受信すると、新しい要件を満たすように構成を変更する必要があります。これには、ノードがDHTを終了して再参加する必要がある場合があります。ノードが新しい要件をサポートできない場合は、オーバーレイを終了する必要があります。特定の種類に関するいくつかの情報が、ノードが以前に種類について知っていたもの（たとえば、最大サイズ）から変更された場合、構成ファイルの新しい情報は、以前に学習した情報を上書きします。 Kindへの署名が許可されなくなったノードによってKindデータが署名された場合、そのKindは、そのKindの格納されている情報とともに破棄される必要があります。オーバーレイの再結合を必要とする構成変更を伴うオーバーレイの雪崩再起動を強制すると、構成パラメーターが適切に考慮されていない場合、ネットワークの完全な崩壊など、重大なパフォーマンスの問題が発生する可能性があります。このようなイベントは、CAのセキュリティが侵害された場合や同様の問題が発生した場合に必要になることがありますが、大きなオーバーレイの場合は、ほとんどすべての状況で回避する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.1.1. RELAX NG Grammar",
      "section_title": true,
      "ja": "11.1.1. 文法のリラックス"
    },
    {
      "indent": 3,
      "text": "The grammar for the configuration data is:",
      "ja": "構成データの文法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "namespace chord = \"urn:ietf:params:xml:ns:p2p:config-chord\"\nnamespace local = \"\"\ndefault namespace p2pcf = \"urn:ietf:params:xml:ns:p2p:config-base\"\nnamespace rng = \"http://relaxng.org/ns/structure/1.0\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "anything =\n    (element * { anything }\n     | attribute * { text }\n     | text)*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "foreign-elements = element * - (p2pcf:* | local:* | chord:*)\n                   { anything }*\nforeign-attributes = attribute * - (p2pcf:*|local:*|chord:*)\n                     { text }*\nforeign-nodes = (foreign-attributes | foreign-elements)*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "start =  element p2pcf:overlay {\n      overlay-element\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "overlay-element &=  element configuration {\n            attribute instance-name { xsd:string },\n            attribute expiration { xsd:dateTime }?,\n            attribute sequence { xsd:long }?,\n            foreign-attributes*,\n            parameter\n        }+\noverlay-element &= element signature {\n            attribute algorithm { signature-algorithm-type }?,\n            xsd:base64Binary\n        }*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "signature-algorithm-type |= \"rsa-sha1\"\nsignature-algorithm-type |=  xsd:string # signature alg extensions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   parameter &= element topology-plugin { topology-plugin-type }?\n   topology-plugin-type |= xsd:string # topo plugin extensions\n   parameter &= element max-message-size { xsd:unsignedInt }?\n   parameter &= element initial-ttl { xsd:int }?\n   parameter &= element root-cert { xsd:base64Binary }*\n   parameter &= element required-kinds { kind-block* }?\n   parameter &= element enrollment-server { xsd:anyURI }*\n   parameter &= element kind-signer {  xsd:string }*\n   parameter &= element configuration-signer {  xsd:string }*\n   parameter &= element bad-node {  xsd:string }*\n   parameter &= element no-ice { xsd:boolean }?\n   parameter &= element shared-secret { xsd:string }?\n   parameter &= element overlay-link-protocol { xsd:string }*\n   parameter &= element clients-permitted { xsd:boolean }?\n   parameter &= element turn-density { xsd:unsignedByte }?\n   parameter &= element node-id-length { xsd:int }?\n   parameter &= element mandatory-extension { xsd:string }*\n   parameter &= foreign-elements*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "parameter &=\n    element self-signed-permitted {\n        attribute digest { self-signed-digest-type },\n        xsd:boolean\n    }?\nself-signed-digest-type |= \"sha1\"\nself-signed-digest-type |=  xsd:string # signature digest extensions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "parameter &= element bootstrap-node {\n                attribute address { xsd:string },\n                attribute port { xsd:int }?\n             }*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kind-block = element kind-block {\n    element kind {\n        (  attribute name { kind-names }\n           | attribute id { xsd:unsignedInt } ),\n        kind-parameter\n    } &\n    element kind-signature  {\n        attribute algorithm { signature-algorithm-type }?,\n        xsd:base64Binary\n    }?\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kind-parameter &= element max-count { xsd:int }\nkind-parameter &= element max-size { xsd:int }\nkind-parameter &= element max-node-multiple { xsd:int }?",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   kind-parameter &= element data-model { data-model-type }\n   data-model-type |= \"SINGLE\"\n   data-model-type |= \"ARRAY\"\n   data-model-type |= \"DICTIONARY\"\n   data-model-type |=  xsd:string # data model extensions\n   kind-parameter &= element access-control { access-control-type }\n   access-control-type |= \"USER-MATCH\"\n   access-control-type |= \"NODE-MATCH\"\n   access-control-type |= \"USER-NODE-MATCH\"\n   access-control-type |= \"NODE-MULTIPLE\"\n   access-control-type |= xsd:string # access control extensions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kind-parameter &= foreign-elements*",
      "ja": "種類パラメーター＆= foreign-elements *"
    },
    {
      "indent": 3,
      "text": "kind-names |= \"TURN-SERVICE\"\nkind-names |= \"CERTIFICATE_BY_NODE\"\nkind-names |= \"CERTIFICATE_BY_USER\"\nkind-names |= xsd:string # kind extensions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "# Chord specific parameters\ntopology-plugin-type |= \"CHORD-RELOAD\"\nparameter &= element chord:chord-ping-interval { xsd:int }?\nparameter &= element chord:chord-update-interval { xsd:int }?\nparameter &= element chord:chord-reactive { xsd:boolean }?",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2. Discovery through Configuration Server",
      "section_title": true,
      "ja": "11.2. 構成サーバーによる検出"
    },
    {
      "indent": 3,
      "text": "When a node first enrolls in a new overlay, it starts with a discovery process to find a configuration server.",
      "ja": "ノードが新しいオーバーレイに最初に登録されると、構成サーバーを見つけるための検出プロセスから始まります。"
    },
    {
      "indent": 3,
      "text": "The node MAY start by determining the overlay name. This value MUST be provided by the user or some other out-of-band provisioning mechanism. The out-of-band mechanism MAY also provide an optional URL for the configuration server. If a URL for the configuration server is not provided, the node MUST do a DNS SRV query using a Service name of \"reload-config\" and a protocol of TCP to find a configuration server and form the URL by appending a path of \"/.well-known/reload-config\" to the overlay name. This uses the \"well-known URI\" framework defined in [RFC5785]. For example, if the overlay name was example.com, the URL would be \"https://example.com/.well-known/reload-config\".",
      "ja": "ノードは、オーバーレイ名を決定することから開始してもよい（MAY）。この値は、ユーザーまたはその他の帯域外プロビジョニングメカニズムによって提供される必要があります。帯域外メカニズムは、構成サーバーにオプションのURLを提供する場合もあります。構成サーバーのURLが指定されていない場合、ノードは「reload-config」のサービス名とTCPのプロトコルを使用してDNS SRVクエリを実行し、構成サーバーを検索して、「/」のパスを追加してURLを形成する必要があります。 .well-known / reload-config」をオーバーレイ名に追加します。これは[RFC5785]で定義された「よく知られているURI」フレームワークを使用します。たとえば、オーバーレイ名がexample.comの場合、URLは「https://example.com/.well-known/reload-config」になります。"
    },
    {
      "indent": 0,
      "text": " Once an address and URL for the configuration server are determined, the peer MUST form an HTTPS connection to that IP address. If an optional URL for the configuration server was provided, the certificate MUST match the domain name from the URL as described in [RFC2818]; otherwise, the certificate MUST match the overlay name as described in [RFC2818]. If the HTTPS certificates pass the name matching, the node MUST fetch a new copy of the configuration file. To do this, the peer performs a GET to the URL. The result of the HTTP GET is an XML configuration file described above. If the XML is not valid or the instance-name attribute of the overlay-element in the XML does not match the overlay name, this configurations file SHOULD be discarded. Otherwise, the new configuration MUST replace any previously learned configuration file for this overlay.",
      "ja": "構成サーバーのアドレスとURLが決定したら、ピアはそのIPアドレスへのHTTPS接続を形成する必要があります。構成サーバーのオプションのURLが提供された場合、証明書は[RFC2818]で説明されているように、URLからのドメイン名と一致する必要があります。それ以外の場合、[RFC2818]で説明されているように、証明書はオーバーレイ名と一致する必要があります。 HTTPS証明書が一致する名前を渡す場合、ノードは構成ファイルの新しいコピーをフェッチする必要があります。これを行うには、ピアがURLへのGETを実行します。 HTTP GETの結果は、上記のXML構成ファイルです。 XMLが無効であるか、XMLのoverlay-elementのinstance-name属性がオーバーレイ名と一致しない場合、この構成ファイルは破棄されるべきです（SHOULD）。それ以外の場合、新しい構成は、このオーバーレイの以前に学習した構成ファイルを置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "For overlays that do not use a configuration server, nodes MUST obtain the configuration information needed to join the overlay through some out-of-band approach, such as an XML configuration file sent over email.",
      "ja": "構成サーバーを使用しないオーバーレイの場合、ノードは、電子メールで送信されるXML構成ファイルなど、帯域外の方法でオーバーレイに参加するために必要な構成情報を取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.3. Credentials",
      "section_title": true,
      "ja": "11.3. 資格情報"
    },
    {
      "indent": 3,
      "text": "If the Configuration Document contains an enrollment-server element, credentials are REQUIRED to join the Overlay Instance. A peer which does not yet have credentials MUST contact the enrollment server to acquire them.",
      "ja": "構成ドキュメントにenrollment-server要素が含まれている場合、オーバーレイインスタンスに参加するには資格情報が必要です。まだ資格情報を持っていないピアは、登録サーバーに連絡してそれらを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "RELOAD defines its own trivial certificate request protocol. We would have liked to have used an existing protocol, but were concerned about the implementation burden of even the simplest of those protocols, such as [RFC5272] and [RFC5273]. The objective was to have a protocol which could be easily implemented in a Web server which the operator did not control (e.g., in a hosted service) and which was compatible with the existing certificate-handling tooling as used with the Web certificate infrastructure. This means accepting bare PKCS#10 requests and returning a single bare X.509 certificate. Although the MIME types for these objects are defined, none of the existing protocols support exactly this model.",
      "ja": "RELOADは、独自の簡単な証明書要求プロトコルを定義します。既存のプロトコルを使用したかったのですが、[RFC5272]や[RFC5273]など、これらのプロトコルの最も単純なものでさえ、実装の負担を心配していました。目的は、オペレーターが制御しないWebサーバー（ホストされたサービスなど）に簡単に実装でき、Web証明書インフラストラクチャで使用される既存の証明書処理ツールと互換性のあるプロトコルを用意することでした。つまり、ベアPKCS＃10リクエストを受け入れ、単一のベアX.509証明書を返します。これらのオブジェクトのMIMEタイプは定義されていますが、既存のプロトコルはどれもこのモデルを正確にサポートしていません。"
    },
    {
      "indent": 3,
      "text": "The certificate request protocol MUST be performed over HTTPS. The server certificate MUST match the overlay name as described in [RFC2818]. The request MUST be an HTTP POST with the parameters encoded as described in [RFC2388] and with the following properties:",
      "ja": "証明書要求プロトコルはHTTPSを介して実行する必要があります。 [RFC2818]で説明されているように、サーバー証明書はオーバーレイ名と一致する必要があります。リクエストは、[RFC2388]で説明されているようにエンコードされたパラメータと、次のプロパティを持つHTTP POSTでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "o If authentication is required, there MUST be form parameters of \"password\" and \"username\" containing the user's account name and password in the clear (hence the need for HTTPS). The username and password strings MUST be UTF-8 strings compared as binary objects. Applications using RELOAD SHOULD define any needed string preparation as per [RFC4013] or its successor documents.",
      "ja": "o 認証が必要な場合、ユーザーのアカウント名とパスワードを平文で含む「パスワード」と「ユーザー名」のフォームパラメータが存在する必要があります（そのためHTTPSが必要です）。ユーザー名とパスワードの文字列は、バイナリオブジェクトと比較してUTF-8文字列である必要があります。 RELOAD SHOULDを使用するアプリケーションは、[RFC4013]またはその後継ドキュメントに従って、必要な文字列の準備を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If more than one Node-ID is required, there MUST be a form parameter of \"nodeids\" containing the number of Node-IDs required.",
      "ja": "o 複数のノードIDが必要な場合は、必要なノードIDの数を含む「nodeids」のフォームパラメータが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o There MUST be a form parameter of \"csr\" with a content type of \"application/pkcs10\", as defined in [RFC2311], that contains the certificate signing request (CSR).",
      "ja": "o [RFC2311]で定義されているように、証明書署名要求（CSR）を含む「application / pkcs10」のコンテンツタイプを持つ「csr」のフォームパラメータが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The Accept header MUST contain the type \"application/pkix-cert\", indicating the type that is expected in the response.",
      "ja": "o Acceptヘッダーには、タイプ \"application / pkix-cert\"が含まれている必要があります。これは、応答で予期されるタイプを示します。"
    },
    {
      "indent": 3,
      "text": "The enrollment server MUST authenticate the request using the provided account name and password. The reason for using the RFC 2388 \"multipart/form-data\" encoding is so that the password parameter will not be encoded in the URL, to reduce the chance of accidental leakage of the password. If the authentication succeeds and the requested user name in the CSR is acceptable, the server MUST generate and return a certificate for the CSR in the \"csr\" parameter of the request. The SubjectAltName field in the certificate MUST contain the following values:",
      "ja": "登録サーバーは、提供されたアカウント名とパスワードを使用してリクエストを認証する必要があります。 RFC 2388の「multipart / form-data」エンコーディングを使用する理由は、パスワードパラメータがURLでエンコードされないようにするためです。これにより、パスワードが誤って漏洩する可能性を減らします。認証が成功し、CSRで要求されたユーザー名が受け入れられる場合、サーバーは要求の「csr」パラメーターでCSRの証明書を生成して返す必要があります。証明書のSubjectAltNameフィールドには、次の値を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o One or more Node-IDs which MUST be cryptographically random [RFC4086]. Each MUST be chosen by the enrollment server in such a way that it is unpredictable to the requesting user. For example, the user MUST NOT be informed of potential (random) Node-IDs prior to authenticating. Each is placed in the subjectAltName using the uniformResourceIdentifier type, each MUST contain RELOAD URI, as described in Section 14.15, and each MUST contain a Destination List with a single entry of type \"node_id\". The enrollment server SHOULD maintain a mapping of users to Node-IDs and if the same user returns (e.g., to have their certificate re-issued), the enrollment server should return the same Node-IDs, thus avoiding the need for implementations to re-store all their data when their certificates expire.",
      "ja": "o 暗号的にランダムでなければならない1つ以上のノードID [RFC4086]。それぞれは、要求しているユーザーが予測できないような方法で、登録サーバーによって選択されなければなりません（MUST）。たとえば、ユーザーは認証の前に潜在的な（ランダムな）ノードIDを通知してはなりません（MUST NOT）。それぞれは、uniformResourceIdentifierタイプを使用してsubjectAltNameに配置され、セクション14.15で説明されているように、それぞれがRELOAD URIを含む必要があり、タイプ「node_id」の単一のエントリを持つ宛先リストを含む必要があります。登録サーバーはユーザーのノードIDへのマッピングを維持する必要があり（SHOULD）、同じユーザーが戻った場合（たとえば、証明書を再発行するため）、登録サーバーは同じノードIDを返す必要があるため、実装の再実行の必要性を回避します。 -証​​明書の有効期限が切れたときにすべてのデータを保存します。"
    },
    {
      "indent": 3,
      "text": "o A single name (the \"user name\") that this user is allowed to use in the overlay, using type rfc822Name. Enrollment servers SHOULD take care to allow only legal characters in the name (e.g., no embedded NULs), rather than simply accepting any name provided by",
      "ja": "o タイプrfc822Nameを使用して、このユーザーがオーバーレイで使用できる単一の名前（「ユーザー名」）。登録サーバーは、提供されている名前を単に受け入れるのではなく、名前に有効な文字のみを許可するように注意する必要があります（たとえば、埋め込まれたNULは不可）。"
    },
    {
      "indent": 6,
      "text": "the user. In some usages, the right side of the user name will match the overlay name, but there is no requirement for this match in this specification. Applications using this specification MAY define such a requirement or MAY otherwise limit the allowed range of allowed user names.",
      "ja": "ユーザー。一部の使用法では、ユーザー名の右側がオーバーレイ名と一致しますが、この仕様ではこの一致の要件はありません。この仕様を使用するアプリケーションは、そのような要件を定義してもよいし、そうでなければ、許可されたユーザー名の許容範囲を制限してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "The SubjectAltName field in the certificate MUST NOT contain any identities other than those listed above. The subject distinguished name in the certificate MUST be empty.",
      "ja": "証明書のSubjectAltNameフィールドには、上記以外のIDを含めてはなりません。証明書のサブジェクト識別名は空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The certificate MUST be returned as type \"application/pkix-cert\", as defined in [RFC2585], with an HTTP status code of 200 OK.",
      "ja": "[RFC2585]で定義されているように、証明書はタイプ「application / pkix-cert」として、HTTPステータスコード200 OKで返される必要があります。"
    },
    {
      "indent": 3,
      "text": "Certificate processing errors SHOULD result in an HTTP return code of 403 Forbidden, along with a body of type \"text/plain\" and body that consists of one of the tokens defined in the following list:",
      "ja": "証明書処理エラーは、「text / plain」タイプの本文と、次のリストで定義されているトークンの1つで構成される本文とともに、HTTP戻りコード403 Forbiddenになるはずです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "failed_authentication The account name and password combination used in the HTTPS request was not valid.",
      "ja": "failed_authentication HTTPS要求で使用されたアカウント名とパスワードの組み合わせが無効でした。"
    },
    {
      "indent": 3,
      "text": "username_not_available The requested user name in the CSR was not acceptable.",
      "ja": "username_not_available CSRで要求されたユーザー名は受け入れられませんでした。"
    },
    {
      "indent": 3,
      "text": "Node-IDs_not_available The number of Node-IDs requested was not acceptable.",
      "ja": "Node-IDs_not_available要求されたノードIDの数が許容範囲を超えていました。"
    },
    {
      "indent": 3,
      "text": "bad_CSR There was some other problem with the CSR.",
      "ja": "bad_CSR CSRに他の問題がありました。"
    },
    {
      "indent": 3,
      "text": "If the client receives an unknown token in the body, it SHOULD treat it as a failure for an unknown reason.",
      "ja": "クライアントが本文で不明なトークンを受信した場合、不明な理由で失敗として扱う必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The client MUST check that the returned certificate chains back to one of the certificates received in the \"root-cert\" list of the overlay configuration data (including PKIX BasicConstraints checks). The node then reads the certificate to find the Node-ID it can use.",
      "ja": "クライアントは、返された証明書がオーバーレイ構成データの「ルート証明書」リストで受け取った証明書の1つにチェーンされていることを確認する必要があります（PKIX BasicConstraintsチェックを含む）。次に、ノードは証明書を読み取り、使用できるノードIDを見つけます。"
    },
    {
      "indent": 0,
      "text": "11.3.1. Self-Generated Credentials",
      "section_title": true,
      "ja": "11.3.1. 自己生成された資格情報"
    },
    {
      "indent": 3,
      "text": "If the \"self-signed-permitted\" element is present in the configuration and is set to \"true\", then a node MUST generate its own self-signed certificate to join the overlay. The self-signed certificate MAY contain any user name of the user's choice.",
      "ja": "「self-signed-permitted」要素が構成に存在し、「true」に設定されている場合、ノードはオーバーレイに参加するために独自の自己署名証明書を生成する必要があります。自己署名証明書には、ユーザーが選択したユーザー名を含めることができます。"
    },
    {
      "indent": 3,
      "text": "For self-signed certificates containing only one Node-ID, the Node-ID MUST be computed by applying the digest specified in the self-signed-permitted element to the DER representation of the user's public key (more specifically, the subjectPublicKeyInfo) and taking the high-order bits. For self-signed certificates containing multiple Node-IDs, the index of the Node-ID (from 1 to the number of Node-IDs needed) must be prepended as a 4-byte big-endian integer to the DER representation of the user's public key and taking the high-order bits. When accepting a self-signed certificate, nodes MUST check that the Node-ID and public keys match. This prevents Node-ID theft.",
      "ja": "Node-IDが1つだけの自己署名証明書の場合、Node-IDは、self-signed-permitted要素で指定されたダイジェストをユーザーの公開鍵（より具体的には、subjectPublicKeyInfo）のDER表現に適用し、上位ビット。複数のノードIDを含む自己署名証明書の場合、ノードIDのインデックス（1から必要なノードIDの数まで）を、ユーザーのパブリックのDER表現の4バイトのビッグエンディアン整数として付加する必要があります。キーと上位ビットを取る。自己署名証明書を受け入れる場合、ノードはノードIDと公開鍵が一致することを確認する必要があります。これにより、ノードIDの盗難が防止されます。"
    },
    {
      "indent": 0,
      "text": " Once the node has constructed a self-signed certificate, it MAY join the overlay. It MUST store its certificate in the overlay (Section 8), but SHOULD look to see if the user name is already taken and, if so, choose another user name. Note that this provides protection only against accidental name collisions. Name theft is still possible. If protection against name theft is desired, then the enrollment service MUST be used.",
      "ja": "ノードが自己署名証明書を構築すると、オーバーレイに参加する場合があります。証明書をオーバーレイに保存する必要があります（セクション8）。ただし、ユーザー名が既に使用されているかどうかを確認し、使用されている場合は別のユーザー名を選択する必要があります。これは、偶発的な名前の衝突に対してのみ保護を提供することに注意してください。名前の盗難はまだ可能です。名前の盗難からの保護が必要な場合は、登録サービスを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.4. Contacting a Bootstrap Node",
      "section_title": true,
      "ja": "11.4. ブートストラップノードへの接続"
    },
    {
      "indent": 3,
      "text": "In order to join the overlay, the Joining Node MUST contact a node in the overlay. Typically this means contacting the bootstrap nodes, since they are reachable by the local peer or have public IP addresses. If the Joining Node has cached a list of peers that it has previously been connected with in this overlay, as an optimization it MAY attempt to use one or more of them as bootstrap nodes before falling back to the bootstrap nodes listed in the configuration file.",
      "ja": "オーバーレイに参加するには、参加ノードがオーバーレイのノードに接続する必要があります。ローカルピアから到達可能であるか、パブリックIPアドレスを持っているため、通常、これはブートストラップノードに接続することを意味します。参加ノードが以前にこのオーバーレイで接続されたピアのリストをキャッシュしている場合、最適化として、構成ファイルにリストされているブートストラップノードにフォールバックする前に、それらの1つ以上をブートストラップノードとして使用することができます。"
    },
    {
      "indent": 3,
      "text": "When contacting a bootstrap node, the Joining Node MUST first form the DTLS or TLS connection to the bootstrap node and then send an Attach request over this connection with the destination Resource-ID set to the Joining Node's Node-ID plus 1.",
      "ja": "ブートストラップノードに接続する場合、参加ノードは最初にブートストラップノードへのDTLSまたはTLS接続を形成してから、この接続を介して、接続リソースのIDを結合ノードのノードID + 1に設定して、接続要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the requester node finally does receive a response from some responding node, it MUST use the Node-ID in the response to start sending requests to join the Overlay Instance as described in Section 6.4.",
      "ja": "リクエスタノードが最終的に応答ノードから応答を受信した場合、セクション6.4で説明されているように、オーバーレイインスタンスに参加する要求の送信を開始するために、応答でノードIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "After a node has successfully joined the overlay network, it will have direct connections to several peers. Some MAY be added to the cached bootstrap nodes list and used in future boots. Peers that are not directly connected MUST NOT be cached. The suggested number of peers to cache is 10. Algorithms for determining which peers to cache are beyond the scope of this specification.",
      "ja": "ノードがオーバーレイネットワークに正常に参加すると、ノードは複数のピアに直接接続されます。一部は、キャッシュされたブートストラップノードリストに追加され、今後のブートで使用される場合があります。直接接続されていないピアはキャッシュしてはいけません。キャッシュするピアの推奨数は10です。キャッシュするピアを決定するアルゴリズムは、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "12. Message Flow Example",
      "section_title": true,
      "ja": "12. メッセージフローの例"
    },
    {
      "indent": 3,
      "text": "The following abbreviations are used in the message flow diagrams: JN = Joining Node, AP = Admitting Peer, NP = next peer after the AP, NNP = next next peer which is the peer after NP, PP = previous peer before the AP, PPP = previous previous peer which is the peer before the PP, BP = bootstrap node.",
      "ja": "メッセージフロー図では、次の略語が使用されています。JN=参加ノード、AP =ピアの承認、NP = APの次のピア、NNP = NPの次のピアである次のピア、PP = APの前のピア、PPP = PPの前のピアである以前の以前のピア、BP =ブートストラップノード。"
    },
    {
      "indent": 3,
      "text": "In the following example, we assume that JN has formed a connection to one of the bootstrap nodes. JN then sends an Attach through that peer to a Resource-ID of itself plus 1 (JN+1). It gets routed to the AP, because JN is not yet part of the overlay. When AP responds, JN and the AP use ICE to set up a connection and then set up DTLS. Once AP has connected to JN, AP sends to JN an Update to populate its Routing Table. The following example shows the Update happening after the DTLS connection is formed, but it could also happen before, in which case the Update would often be routed through other nodes.",
      "ja": "次の例では、JNがブートストラップノードの1つへの接続を形成していると想定しています。次に、JNはそのピアを介して、自分自身のリソースID + 1（JN + 1）に接続を送信します。 JNはまだオーバーレイの一部ではないため、APにルーティングされます。 APが応答すると、JNとAPはICEを使用して接続をセットアップしてから、DTLSをセットアップします。 APがJNに接続すると、APは更新をJNに送信して、ルーティングテーブルに入力します。次の例は、DTLS接続が形成された後に更新が行われることを示していますが、前に行われる場合もあります。その場合、更新は他のノードを通じてルーティングされることがよくあります。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq Dest=JN+1|         |         |         |         |\n |---------------------------------------------------------->|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachReq Dest=JN+1|         |\n |         |         |         |<----------------------------|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachAns          |         |\n |         |         |         |---------------------------->|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns          |         |         |         |         |\n |<----------------------------------------------------------|\n |         |         |         |         |         |         |\n |ICE      |         |         |         |         |         |\n |<===========================>|         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |<...........................>|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The JN then forms connections to the appropriate neighbors, such as NP, by sending an Attach which gets routed via other nodes. When NP responds, JN and NP use ICE and DTLS to set up a connection.",
      "ja": "次に、JNは、他のノードを介してルーティングされるアタッチを送信することにより、NPなどの適切なネイバーへの接続を形成します。 NPが応答すると、JNとNPはICEとDTLSを使用して接続をセットアップします。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq NP       |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachReq NP       |         |\n |         |         |         |-------->|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachAns|         |         |\n |         |         |         |<--------|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |ICE      |         |         |         |         |         |\n |<=====================================>|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |<.....................................>|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "The JN also needs to populate its Finger Table (for the Chord-based DHT). It issues an Attach to a variety of locations around the overlay. The diagram below shows JN sending an Attach halfway around the Chord ring to the JN + 2^127.",
      "ja": "JNはそのフィンガーテーブルにデータを入力する必要もあります（コードベースのDHTの場合）。オーバーレイの周りのさまざまな場所にAttachを発行します。以下の図は、JNがコードリングの途中でJN + 2 ^ 127にアタッチを送信することを示しています。"
    },
    {
      "indent": 7,
      "text": "JN        NP        XX        TP\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |AttachReq JN+2<<126|         |\n |-------->|         |         |\n |         |         |         |\n |         |         |         |\n |         |AttachReq JN+2<<126|\n |         |-------->|         |\n |         |         |         |\n |         |         |         |\n |         |         |AttachReq JN+2<<126\n |         |         |-------->|\n |         |         |         |\n |         |         |         |\n |         |         |AttachAns|\n |         |         |<--------|\n |         |         |         |\n |         |         |         |\n |         |AttachAns|         |\n |         |<--------|         |\n |         |         |         |\n |         |         |         |\n |AttachAns|         |         |\n |<--------|         |         |\n |         |         |         |\n |ICE      |         |         |\n |<===========================>|\n |         |         |         |\n |TLS      |         |         |\n |<...........................>|\n |         |         |         |\n |         |         |         |",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "Once JN has a reasonable set of connections, it is ready to take its place in the DHT. It does this by sending a Join to AP. AP sends a series of Store requests to JN to store the data that JN will be responsible for. AP then sends JN an Update that explicitly labels JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP can now forget any data which is assigned to JN and not to AP.",
      "ja": "JNに適切な接続のセットが用意されると、DHTでJNを使用する準備が整います。これは、APに参加を送信することによって行われます。 APは一連のStoreリクエストをJNに送信して、JNが担当するデータを保存します。 APは次に、JNをその前任者として明示的にラベル付けする更新をJNに送信します。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは、APではなくJNに割り当てられているデータをすべて忘れることができるようになりました。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |JoinReq  |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |JoinAns  |         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreReq Data A    |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreAns |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreReq Data B    |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreAns |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "In Chord, JN's Neighbor Table needs to contain its own predecessors. It couldn't connect to them previously, because it did not yet know their addresses. However, now that it has received an Update from AP, as in the previous diagram, it has AP's predecessors, which are also its own, so it sends Attaches to them. Below, it is shown connecting only to AP's closest predecessor, PP.",
      "ja": "コードでは、JNのネイバーテーブルに独自の先行テーブルを含める必要があります。それはまだ彼らのアドレスを知らなかったので、以前はそれらに接続できませんでした。ただし、前の図のようにAPからアップデートを受け取ったので、APの前身であるAPの前任者もいるので、それらにアタッチメントを送信します。以下では、APの最も近い前任者であるPPにのみ接続することが示されています。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq Dest=PP  |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |AttachReq Dest=PP  |         |         |\n |         |         |<--------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |AttachAns|         |         |         |\n |         |         |-------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |...................|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |------------------>|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |<------------------|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "|-------------------------------------->|         |         |\n|         |         |         |         |         |         |\n|         |         |         |         |         |         |\n|UpdateAns|         |         |         |         |         |\n|<--------------------------------------|         |         |\n|         |         |         |         |         |         |\n|         |         |         |         |         |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "Finally, now that JN has a copy of all the data and is ready to route messages and receive requests, it sends Updates to everyone in its Routing Table to tell them it is ready to go. Below, it is shown sending such an update to TP.",
      "ja": "最後に、JNはすべてのデータのコピーを取得し、メッセージをルーティングしてリクエストを受信する準備ができたので、ルーティングテーブルの全員に更新を送信して、準備ができていることを伝えます。以下に、そのような更新をTPに送信することが示されています。"
    },
    {
      "indent": 11,
      "text": "JN        NP        XX        TP\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |UpdateReq|         |         |\n |---------------------------->|\n |         |         |         |\n |         |         |         |\n |UpdateAns|         |         |\n |<----------------------------|\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |         |         |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "13.1. Overview",
      "section_title": true,
      "ja": "13.1. 概観"
    },
    {
      "indent": 3,
      "text": "RELOAD provides a generic storage service, albeit one designed to be useful for P2PSIP. In this section, we discuss security issues that are likely to be relevant to any usage of RELOAD. More background information can be found in [RFC5765].",
      "ja": "RELOADは汎用ストレージサービスを提供しますが、P2PSIPに役立つように設計されています。このセクションでは、RELOADの使用に関連すると思われるセキュリティの問題について説明します。より多くの背景情報は[RFC5765]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": " In any Overlay Instance, any given user depends on a number of peers with which they have no well-defined relationship except that they are fellow members of the Overlay Instance. In practice, these other nodes may be friendly, lazy, curious, or outright malicious. No security system can provide complete protection in an environment where most nodes are malicious. The goal of security in RELOAD is to provide strong security guarantees of some properties even in the face of a large number of malicious nodes and to allow the overlay to function correctly in the face of a modest number of malicious nodes.",
      "ja": "オーバーレイインスタンスでは、特定のユーザーは、オーバーレイインスタンスのメンバーである場合を除いて、明確に定義された関係を持っていないピアの数に依存します。実際には、これらの他のノードは、友好的、怠惰、好奇心が強い、または完全に悪意がある可能性があります。ほとんどのノードが悪意のある環境で完全な保護を提供できるセキュリティシステムはありません。 RELOADのセキュリティの目的は、多数の悪意のあるノードが存在する場合でも、一部のプロパティの強力なセキュリティ保証を提供し、適度な数の悪意のあるノードが存在する場合でもオーバーレイが正しく機能できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "P2PSIP deployments require the ability to authenticate both peers and resources (users) without the active presence of a trusted entity in the system. We describe two mechanisms. The first mechanism is based on public key certificates and is suitable for general deployments. The second is an admission control mechanism based on an overlay-wide shared symmetric key.",
      "ja": "P2PSIPの展開には、システムに信頼されたエンティティがアクティブに存在することなく、ピアとリソース（ユーザー）の両方を認証する機能が必要です。 2つのメカニズムについて説明します。最初のメカニズムは公開鍵証明書に基づいており、一般的な展開に適しています。 2つ目は、オーバーレイ全体の共有対称鍵に基づくアドミッションコントロールメカニズムです。"
    },
    {
      "indent": 0,
      "text": "13.2. Attacks on P2P Overlays",
      "section_title": true,
      "ja": "13.2. P2Pオーバーレイへの攻撃"
    },
    {
      "indent": 3,
      "text": "The two basic functions provided by overlay nodes are storage and routing: some peer is responsible for storing a node's data and for allowing a third node to fetch this stored data, while other peers are responsible for routing messages to and from the storing nodes. Each of these issues is covered in the following sections.",
      "ja": "オーバーレイノードが提供する2つの基本的な機能はストレージとルーティングです。一部のピアはノードのデータを保存し、3番目のノードがこの保存されたデータをフェッチできるようにします。他のピアは、ストレージノードとの間でメッセージをルーティングします。これらの各問題について、次のセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "P2P overlays are subject to attacks by subversive nodes that may attempt to disrupt routing, corrupt or remove user registrations, or eavesdrop on signaling. The certificate-based security algorithms we describe in this specification are intended to protect overlay routing and user registration information in RELOAD messages.",
      "ja": "P2Pオーバーレイは、ルーティングを妨害したり、ユーザー登録を破損または削除したり、シグナリングを盗聴したりする可能性のある破壊的なノードによる攻撃の影響を受けます。この仕様で説明する証明書ベースのセキュリティアルゴリズムは、RELOADメッセージのオーバーレイルーティングとユーザー登録情報を保護することを目的としています。"
    },
    {
      "indent": 3,
      "text": "To protect the signaling from attackers pretending to be valid nodes (or nodes other than themselves), the first requirement is to ensure that all messages are received from authorized members of the overlay. For this reason, RELOAD MUST transport all messages over a secure channel (TLS and DTLS are defined in this document) which provides message integrity and authentication of the directly communicating peer. In addition, messages and data MUST be digitally signed with the sender's private key, providing end-to-end security for communications.",
      "ja": "有効なノード（またはそれ以外のノード）を装う攻撃者からシグナリングを保護するために、最初の要件は、すべてのメッセージがオーバーレイの承認されたメンバーから受信されることを保証することです。このため、RELOADは、メッセージの整合性と直接通信するピアの認証を提供する安全なチャネル（TLSおよびDTLSはこのドキュメントで定義されています）を介してすべてのメッセージを転送する必要があります。さらに、メッセージとデータは送信者の秘密鍵でデジタル署名されなければならず、通信にエンドツーエンドのセキュリティを提供します。"
    },
    {
      "indent": 0,
      "text": "13.3. Certificate-Based Security",
      "section_title": true,
      "ja": "13.3. 証明書ベースのセキュリティ"
    },
    {
      "indent": 3,
      "text": "This specification stores users' registrations and possibly other data in an overlay network. This requires a solution both to securing this data and to securing, as well as possible, the routing in the overlay. Both types of security are based on requiring that every entity in the system (whether user or peer) authenticate cryptographically using an asymmetric key pair tied to a certificate.",
      "ja": "この仕様は、ユーザーの登録と、場合によっては他のデータをオーバーレイネットワークに格納します。これには、このデータを保護するためのソリューションと、オーバーレイのルーティングを可能な限り保護するためのソリューションが必要です。どちらの種類のセキュリティも、システム内のすべてのエンティティ（ユーザーまたはピア）が、証明書に関連付けられた非対称キーペアを使用して暗号化して認証することを要求することに基づいています。"
    },
    {
      "indent": 0,
      "text": " When a user enrolls in the Overlay Instance, they request or are assigned a unique name, such as \"alice@dht.example.net\". These names MUST be unique and are meant to be chosen and used by humans much like a SIP address-of-record (AOR) or an email address. The user MUST also be assigned one or more Node-IDs by the central enrollment authority. Both the name and the Node-IDs are placed in the certificate, along with the user's public key.",
      "ja": "ユーザーがオーバーレイインスタンスに登録すると、「alice@dht.example.net」などの一意の名前をリクエストするか、割り当てられます。これらの名前は一意である必要があり、SIPのレコードアドレス（AOR）または電子メールアドレスと同様に、人間が選択して使用することを目的としています。ユーザーには、中央登録機関によって1つ以上のノードIDも割り当てられている必要があります。名前とノードIDの両方が、ユーザーの公開鍵とともに証明書に配置されます。"
    },
    {
      "indent": 3,
      "text": "Each certificate enables an entity to act in two sorts of roles:",
      "ja": "各証明書により、エンティティは次の2種類の役割を果たします。"
    },
    {
      "indent": 3,
      "text": "o As a user, storing data at specific Resource-IDs in the Overlay Instance corresponding to the user name.",
      "ja": "o ユーザーとして、ユーザー名に対応するオーバーレイインスタンスの特定のリソースIDにデータを保存します。"
    },
    {
      "indent": 3,
      "text": "o As a overlay peer with the Node-IDs listed in the certificate.",
      "ja": "o 証明書にリストされているノードIDを持つオーバーレイピアとして。"
    },
    {
      "indent": 3,
      "text": "Note that since only users of this Overlay Instance need to validate a certificate, this usage does not require a global Public Key Infrastructure (PKI). Instead, certificates MUST be signed by a central enrollment authority which acts as the certificate authority for the Overlay Instance. This authority signs each node's certificate. Because each node possesses the CA's certificate (which they receive upon enrollment), they can verify the certificates of the other entities in the overlay without further communication. Because the certificates contain the user's/node's public key, communications from the user/node can, in turn, be verified.",
      "ja": "このオーバーレイインスタンスのユーザーのみが証明書を検証する必要があるため、この使用法ではグローバルな公開キー基盤（PKI）は必要ありません。代わりに、証明書は、オーバーレイインスタンスの認証局として機能する中央の登録機関によって署名されている必要があります。この機関は、各ノードの証明書に署名します。各ノードはCAの証明書（登録時に受け取る）を所有しているため、さらに通信することなく、オーバーレイ内の他のエンティティの証明書を検証できます。証明書にはユーザー/ノードの公開鍵が含まれているため、ユーザー/ノードからの通信を検証できます。"
    },
    {
      "indent": 3,
      "text": "If self-signed certificates are used, then the security provided is significantly decreased, since attackers can mount Sybil attacks. In addition, attackers cannot trust the user names in certificates (although they can trust the Node-IDs, because they are cryptographically verifiable). This scheme may be appropriate for some small deployments, such as a small office or an ad hoc overlay set up among participants in a meeting where all hosts on the network are trusted. Some additional security can be provided by using the shared secret admission control scheme as well.",
      "ja": "自己署名証明書を使用すると、攻撃者がシビル攻撃を仕掛けることができるため、セキュリティが大幅に低下します。さらに、攻撃者は証明書内のユーザー名を信頼することはできません（暗号で検証できるため、ノードIDは信頼できます）。このスキームは、小規模オフィスや、ネットワーク上のすべてのホストが信頼されている会議の参加者間に設定されたアドホックオーバーレイなどの小規模な展開に適している場合があります。共有シークレットアドミッションコントロールスキームを使用することで、追加のセキュリティを提供することもできます。"
    },
    {
      "indent": 3,
      "text": "Because all stored data is signed by the owner of the data, the storing node can verify that the storer is authorized to perform a store at that Resource-ID and also can allow any consumer of the data to verify the provenance and integrity of the data when it retrieves it.",
      "ja": "保存されているすべてのデータはデータの所有者によって署名されているため、保存ノードは、保存者がそのResource-IDで保存を実行することを承認されていることを確認でき、データの消費者がデータの来歴と整合性を確認できるようにすることもできます。それを取得するとき。"
    },
    {
      "indent": 3,
      "text": "Note that RELOAD does not itself provide a revocation/status mechanism (although certificates may, of course, include Online Certificate Status Protocol [OCSP] responder information). Thus, certificate lifetimes SHOULD be chosen to balance the compromise window versus the cost of certificate renewal. Because RELOAD is already designed to operate in the face of some fraction of malicious nodes, this form of compromise is not fatal.",
      "ja": "RELOAD自体は失効/ステータスメカニズムを提供しないことに注意してください（もちろん、証明書にはオンライン証明書ステータスプロトコル[OCSP]レスポンダ情報が含まれる場合があります）。したがって、証明書のライフタイムは、妥協ウィンドウと証明書の更新のコストのバランスを取るために選択する必要があります（SHOULD）。 RELOADは悪意のあるノードの一部に直面しても動作するようにすでに設計されているため、この形式の侵害は致命的ではありません。"
    },
    {
      "indent": 3,
      "text": "All implementations MUST implement certificate-based security.",
      "ja": "すべての実装は、証明書ベースのセキュリティを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.4. Shared-Secret Security",
      "section_title": true,
      "ja": "13.4. 共有秘密セキュリティ"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports a shared secret admission control scheme that relies on a single key that is shared among all members of the overlay. It is appropriate for small groups that wish to form a private network without complexity. In shared secret mode, all the peers MUST share a single symmetric key which is used to key TLS-PSK or TLS-SRP mode. A peer which does not know the key cannot form TLS connections with any other peer and therefore cannot join the overlay.",
      "ja": "RELOADは、オーバーレイのすべてのメンバー間で共有される単一のキーに依存する共有シークレットアドミッションコントロールスキームもサポートします。複雑さを伴わずにプライベートネットワークを形成したい小規模なグループに適しています。共有シークレットモードでは、すべてのピアが、TLS-PSKまたはTLS-SRPモードのキーに使用される単一の対称キーを共有する必要があります。キーを知らないピアは、他のピアとのTLS接続を形成できないため、オーバーレイに参加できません。"
    },
    {
      "indent": 3,
      "text": "One natural approach to a shared-secret scheme is to use a user-entered password as the key. The difficulty with this is that in TLS-PSK mode, such keys are very susceptible to dictionary attacks. If passwords are used as the source of shared keys, then TLS-SRP is a superior choice, because it is not subject to dictionary attacks.",
      "ja": "共有秘密スキームへの自然なアプローチの1つは、ユーザーが入力したパスワードをキーとして使用することです。これの難しさは、TLS-PSKモードでは、そのようなキーが辞書攻撃の影響を非常に受けやすいことです。パスワードを共有キーのソースとして使用する場合、辞書攻撃を受けないため、TLS-SRPが優れた選択肢です。"
    },
    {
      "indent": 0,
      "text": "13.5. Storage Security",
      "section_title": true,
      "ja": "13.5. ストレージのセキュリティ"
    },
    {
      "indent": 3,
      "text": "When certificate-based security is used in RELOAD, any given Resource-ID/Kind-ID pair is bound to some small set of certificates. In order to write data, the writer must prove possession of the private key for one of those certificates. Moreover, all data is stored, signed with the same private key that was used to authorize the storage. This set of rules makes questions of authorization and data integrity, which have historically been thorny for overlays, relatively simple.",
      "ja": "RELOADで証明書ベースのセキュリティが使用されている場合、特定のResource-ID / Kind-IDペアはいくつかの小さな証明書セットにバインドされます。データを書き込むために、ライターはそれらの証明書の1つの秘密鍵の所有を証明する必要があります。さらに、すべてのデータは保存され、ストレージの承認に使用されたのと同じ秘密鍵で署名されます。この一連のルールにより、承認とデータの整合性に関する問題が比較的簡単に作成されます。"
    },
    {
      "indent": 0,
      "text": "13.5.1. Authorization",
      "section_title": true,
      "ja": "13.5.1. 認可"
    },
    {
      "indent": 3,
      "text": "When a node wants to store some value, it MUST first digitally sign the value with its own private key. It then sends a Store request that contains both the value and the signature towards the storing peer (which is defined by the Resource Name construction algorithm for that particular Kind of value).",
      "ja": "ノードが何らかの値を保存したい場合、最初に独自の秘密鍵で値にデジタル署名する必要があります。次に、値とシグネチャの両方を含むStoreリクエストを、（特定の種類の値のリソース名構築アルゴリズムによって定義されている）保存ピアに送信します。"
    },
    {
      "indent": 3,
      "text": "When the storing peer receives the request, it MUST determine whether the storing node is authorized to store at this Resource-ID/Kind-ID pair. Determining this requires comparing the user's identity to the requirements of the access control model (see Section 7.3). If it satisfies those requirements, the user is authorized to write, pending quota checks, as described in the next section.",
      "ja": "格納ピアが要求を受信すると、格納ノードがこのResource-ID / Kind-IDペアでの格納を許可されているかどうかを判断する必要があります。これを決定するには、ユーザーのIDをアクセス制御モデルの要件と比較する必要があります（セクション7.3を参照）。これらの要件を満たしている場合、ユーザーは、次のセクションで説明するように、書き込み、保留中の割り当てチェックを行うことができます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a certificate with the following properties:",
      "ja": "たとえば、次のプロパティを持つ証明書について考えます。"
    },
    {
      "indent": 10,
      "text": "User name: alice@dht.example.com Node-ID: 013456789abcdef Serial: 1234",
      "ja": "ユーザー名：alice@dht.example.comノードID：013456789abcdefシリアル：1234"
    },
    {
      "indent": 3,
      "text": "If Alice wishes to Store a value of the \"SIP Location\" Kind, the Resource Name will be the SIP AOR \"sip:alice@dht.example.com\". The Resource-ID will be determined by hashing the Resource Name. Because SIP Location uses the USER-NODE-MATCH policy, it first verifies that the user name in the certificate hashes to the requested Resource-ID. It then verifies that the Node-ID in the certificate matches the dictionary key being used for the store. If both of these checks succeed, the Store is authorized. Note that because the access control model is different for different Kinds, the exact set of checks will vary.",
      "ja": "アリスが「SIPの場所」の種類の値を保存する場合、リソース名はSIP AORの「sip：alice@dht.example.com」になります。リソースIDは、リソース名をハッシュすることによって決定されます。 SIPロケーションはUSER-NODE-MATCHポリシーを使用するため、証明書内のユーザー名が要求されたリソースIDにハッシュすることを最初に確認します。次に、証明書のノードIDがストアで使用されている辞書キーと一致することを確認します。これらのチェックの両方が成功した場合、ストアは承認されます。アクセス制御モデルは種類によって異なるため、チェックの正確なセットは異なることに注意してください。"
    },
    {
      "indent": 0,
      "text": "13.5.2. Distributed Quota",
      "section_title": true,
      "ja": "13.5.2. 分散クォータ"
    },
    {
      "indent": 3,
      "text": "Being a peer in an Overlay Instance carries with it the responsibility to store data for a given region of the Overlay Instance. However, allowing nodes to store unlimited amounts of data would create unacceptable burdens on peers and would also enable trivial denial-of-service (DoS) attacks. RELOAD addresses this issue by requiring configurations to define maximum sizes for each Kind of stored data. Attempts to store values exceeding this size MUST be rejected. (If peers are inconsistent about this, then strange artifacts will happen when the zone of responsibility shifts and a different peer becomes responsible for overlarge data.) Because each Resource-ID/Kind-ID pair is bound to a small set of certificates, these size restrictions also create a distributed quota mechanism, with the quotas administered by the central configuration server.",
      "ja": "オーバーレイインスタンスのピアであることには、オーバーレイインスタンスの特定の領域のデータを格納する責任があります。ただし、ノードに無制限の量のデータを保存できるようにすると、ピアに許容できない負荷がかかり、ささいなサービス拒否（DoS）攻撃も可能になります。 RELOADは、保存されているデータの種類ごとに最大サイズを定義する構成を要求することで、この問題に対処しています。このサイズを超える値を保存する試みは拒否されなければなりません（MUST）。 （ピアがこれについて一貫性がない場合、責任の範囲がシフトし、別のピアが過大なデータを担当するようになると、奇妙なアーティファクトが発生します。）各Resource-ID / Kind-IDペアは証明書の小さなセットにバインドされるため、これらはサイズの制限により、分散型の割り当てメカニズムも作成され、割り当ては中央構成サーバーによって管理されます。"
    },
    {
      "indent": 3,
      "text": "Allowing different Kinds of data to have different size restrictions allows new usages the flexibility to define limits that fit their needs without requiring all usages to have expansive limits.",
      "ja": "さまざまな種類のデータにさまざまなサイズ制限を許可することで、すべての使用法に拡張的な制限を設けることなく、新しい使用法にニーズに合った制限を柔軟に定義できます。"
    },
    {
      "indent": 0,
      "text": "13.5.3. Correctness",
      "section_title": true,
      "ja": "13.5.3. 正しさ"
    },
    {
      "indent": 3,
      "text": "Because each stored value is signed, it is trivial for any retrieving node to verify the integrity of the stored value. More care needs to be taken to prevent version rollback attacks. Rollback attacks on storage are prevented by the use of store times and lifetime values in each store. A lifetime represents the latest time at which the data is valid and thus limits (although does not completely prevent) the ability of the storing node to perform a rollback attack on retrievers. In order to prevent a rollback attack at the time of the Store request, it is REQUIRED that storage times be monotonically increasing. Storing peers MUST reject Store requests with storage times smaller than or equal to those that they are currently storing. In addition, a fetching node which receives a data value with a storage time older than the result of the previous fetch knows that a rollback has occurred.",
      "ja": "保存された各値は署名されているため、取得ノードが保存された値の整合性を検証するのは簡単です。バージョンロールバック攻撃を防ぐために、さらに注意が必要です。ストレージに対するロールバック攻撃は、各ストアのストア時間とライフタイム値を使用することで防止されます。存続期間は、データが有効である最新の時刻を表し、したがって、リトリーバーに対してロールバック攻撃を実行するストレージノードの機能を制限します（完全には防ぎません）。ストア要求時のロールバック攻撃を防ぐために、ストレージ時間が単調に増加することが必要です。ピアを保存することは、現在保存しているものと同じかそれ以下の保存時間で保存リクエストを拒否しなければなりません。さらに、前のフェッチの結果よりも古いストレージ時間のデータ値を受信するフェッチングノードは、ロールバックが発生したことを認識しています。"
    },
    {
      "indent": 0,
      "text": "13.5.4. Residual Attacks",
      "section_title": true,
      "ja": "13.5.4. 残留攻撃"
    },
    {
      "indent": 3,
      "text": "The mechanisms described here provide a high degree of security, but some attacks remain possible. Most simply, it is possible for storing peers to refuse to store a value (i.e., they reject any request). In addition, a storing peer can deny knowledge of values which it has previously accepted. To some extent, these attacks can be ameliorated by attempting to store to and retrieve from replicas, but a retrieving node does not know whether or not it should try this, as there is a cost to doing so.",
      "ja": "ここで説明するメカニズムは高度なセキュリティを提供しますが、一部の攻撃は依然として可能です。最も簡単に言えば、ピアを格納することで値の格納を拒否することができます（つまり、ピアは要求を拒否します）。さらに、格納ピアは、以前に受け入れた値の知識を拒否できます。これらの攻撃は、レプリカへの格納とレプリカの取得を試みることである程度改善できますが、取得ノードには、コストがかかるため、これを試行する必要があるかどうかがわかりません。"
    },
    {
      "indent": 3,
      "text": "The certificate-based authentication scheme prevents a single peer from being able to forge data owned by other peers. Furthermore, although a subversive peer can refuse to return data resources for which it is responsible, it cannot return forged data, because it cannot provide authentication for such registrations. Therefore, parallel searches for redundant registrations can mitigate most of the effects of a compromised peer. The ultimate reliability of such an overlay is a statistical question based on the replication factor and the percentage of compromised peers.",
      "ja": "証明書ベースの認証スキームにより、単一のピアが他のピアが所有するデータを偽造することができなくなります。さらに、破壊的ピアは、それが責任を負うデータリソースを返すことを拒否できますが、そのような登録に認証を提供できないため、偽造データを返すことはできません。したがって、冗長な登録を並行して検索することで、侵害されたピアの影響のほとんどを軽減できます。そのようなオーバーレイの究極の信頼性は、レプリケーション係数と侵害されたピアの割合に基づく統計的な質問です。"
    },
    {
      "indent": 3,
      "text": "In addition, when a Kind is multivalued (e.g., an array data model), the storing peer can return only some subset of the values, thus biasing its responses. This can be countered by using single values rather than sets, but that makes coordination between multiple storing agents much more difficult. This is a trade-off that must be made when designing any usage.",
      "ja": "さらに、Kindが複数値（配列データモデルなど）の場合、格納ピアは値の一部のサブセットのみを返すことができるため、応答にバイアスがかかります。これは、セットではなく単一の値を使用することで対処できますが、複数のストレージエージェント間の調整がはるかに困難になります。これは、使用法を設計するときに行う必要があるトレードオフです。"
    },
    {
      "indent": 0,
      "text": "13.6. Routing Security",
      "section_title": true,
      "ja": "13.6. ルーティングセキュリティ"
    },
    {
      "indent": 3,
      "text": "Because the storage security system guarantees (within limits) the integrity of the stored data, routing security focuses on stopping the attacker from performing a DoS attack that misroutes requests in the overlay. There are a few obvious observations to make about this. First, it is easy to ensure that an attacker is at least a valid node in the Overlay Instance. Second, this is a DoS attack only. Third, if a large percentage of the nodes on the Overlay Instance are controlled by the attacker, it is probably impossible to perfectly secure against this.",
      "ja": "ストレージセキュリティシステムは、格納されたデータの整合性を（制限内で）保証するため、ルーティングセキュリティは、オーバーレイで要求を誤ってルーティングするDoS攻撃を攻撃者が実行することを阻止することに重点を置いています。これについては、いくつかの明らかな観察があります。まず、攻撃者が少なくともオーバーレイインスタンスの有効なノードであることを簡単に確認できます。次に、これはDoS攻撃のみです。第3に、オーバーレイインスタンスのノードの大部分が攻撃者によって制御されている場合、これに対して完全に保護することはおそらく不可能です。"
    },
    {
      "indent": 0,
      "text": "13.6.1. Background",
      "section_title": true,
      "ja": "13.6.1. バックグラウンド"
    },
    {
      "indent": 3,
      "text": "In general, attacks on DHT routing are mounted by the attacker arranging to route traffic through one or two nodes that it controls. In the Eclipse attack [Eclipse], the attacker tampers with messages to and from nodes for which it is on-path with respect to a given victim node. This allows it to pretend to be all the nodes that are reachable through it. In the Sybil attack [Sybil], the attacker registers a large number of nodes and is therefore able to capture a large amount of the traffic through the DHT.",
      "ja": "一般に、DHTルーティングへの攻撃は、攻撃者が制御する1つまたは2つのノードを介してトラフィックをルーティングするように仕組んでいます。 Eclipse攻撃[Eclipse]では、攻撃者は、特定の犠牲ノードに関して、経路上にあるノードとの間のメッセージを改ざんします。これにより、アクセス可能なすべてのノードを装うことができます。シビル攻撃[シビル]では、攻撃者は多数のノードを登録するため、DHTを介して大量のトラフィックをキャプチャできます。"
    },
    {
      "indent": 3,
      "text": "Both the Eclipse and Sybil attacks require the attacker to be able to exercise control over her Node-IDs. The Sybil attack requires the creation of a large number of peers. The Eclipse attack requires that the attacker be able to impersonate specific peers. In both cases, RELOAD attempts to mitigate these attacks by the use of centralized, certificate-based admission control.",
      "ja": "Eclipse攻撃とSybil攻撃の両方で、攻撃者は自分のノードIDを制御できる必要があります。シビル攻撃では、多数のピアを作成する必要があります。 Eclipse攻撃では、攻撃者が特定のピアになりすますことができる必要があります。どちらの場合も、RELOADは、集中型の証明書ベースのアドミッションコントロールを使用して、これらの攻撃を緩和しようとします。"
    },
    {
      "indent": 0,
      "text": "13.6.2. Admissions Control",
      "section_title": true,
      "ja": "13.6.2. 入学管理"
    },
    {
      "indent": 3,
      "text": "Admission to a RELOAD Overlay Instance is controlled by requiring that each peer have a certificate containing its Node-ID. The requirement to have a certificate is enforced by using certificate-based mutual authentication on each connection. (Note: the following applies only when self-signed certificates are not used.) Whenever a peer connects to another peer, each side automatically checks that the other has a suitable certificate. These Node-IDs MUST be randomly assigned by the central enrollment server. This has two benefits:",
      "ja": "RELOADオーバーレイインスタンスへのアドミッションは、各ピアにそのノードIDを含む証明書を要求することによって制御されます。各接続で証明書ベースの相互認証を使用することにより、証明書が必要になります。 （注：以下は、自己署名証明書が使用されていない場合にのみ適用されます。）ピアが別のピアに接続するたびに、両側が自動的に、相手が適切な証明書を持っていることを確認します。これらのノードIDは、中央登録サーバーによってランダムに割り当てられる必要があります。これには2つの利点があります。"
    },
    {
      "indent": 3,
      "text": "o It allows the enrollment server to limit the number of Node-IDs issued to any individual user.",
      "ja": "o これにより、登録サーバーは、個々のユーザーに発行されるノードIDの数を制限できます。"
    },
    {
      "indent": 3,
      "text": "o It prevents the attacker from choosing specific Node-IDs.",
      "ja": "o 攻撃者が特定のノードIDを選択するのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "The first property allows protection against Sybil attacks (provided that the enrollment server uses strict rate-limiting policies). The second property deters but does not completely prevent Eclipse attacks. Because an Eclipse attacker must impersonate peers on the other side of the attacker, the attacker must have a certificate for suitable Node-IDs, which requires him to repeatedly query the enrollment server for new certificates, which will match only by chance. From the attacker's perspective, the difficulty is that if the attacker has only a small number of certificates, the region of the Overlay Instance he is impersonating appears to be very sparsely populated by comparison to the victim's local region.",
      "ja": "最初のプロパティは、Sybil攻撃に対する保護を可能にします（登録サーバーが厳密なレート制限ポリシーを使用している場合）。 2番目のプロパティは、Eclipse攻撃を阻止しますが、完全には阻止しません。 Eclipse攻撃者は、攻撃者の反対側のピアを偽装する必要があるため、攻撃者は適切なノードIDの証明書を持っている必要があります。そのため、偶然にのみ一致する新しい証明書を登録サーバーに繰り返し照会する必要があります。攻撃者の観点から見ると、困難は、攻撃者が証明書の数が少ない場合、なりすましているオーバーレイインスタンスの領域が、被害者のローカル領域と比較して非常にまばらに表示されることです。"
    },
    {
      "indent": 0,
      "text": "13.6.3. Peer Identification and Authentication",
      "section_title": true,
      "ja": "13.6.3. ピアの識別と認証"
    },
    {
      "indent": 3,
      "text": "In general, whenever a peer engages in overlay activity that might affect the Routing Table, it must establish its identity. This happens in two ways. First, whenever a peer establishes a direct connection to another peer, it authenticates via certificate-based mutual authentication. All messages between peers are sent over this protected channel, and therefore the peers can verify the data origin of the last-hop peer for requests and responses without further cryptography.",
      "ja": "一般に、ピアがルーティングテーブルに影響を与える可能性のあるオーバーレイアクティビティを実行するときは常に、IDを確立する必要があります。これは2つの方法で発生します。まず、ピアが別のピアへの直接接続を確立するときは常に、証明書ベースの相互認証を介して認証されます。ピア間のすべてのメッセージはこの保護されたチャネルを介して送信されるため、ピアはラストホップピアのデータ発信元を確認し、さらに暗号化することなく要求と応答を確認できます。"
    },
    {
      "indent": 3,
      "text": "In some situations, however, it is desirable to be able to establish the identity of a peer with whom one is not directly connected. The most natural case is when a peer Updates its state. At this point, other peers may need to update their view of the overlay structure, but they need to verify that the Update message came from the actual peer rather than from an attacker. To prevent having a peer accept Update messages from an attacker, all overlay routing messages are signed by the peer that generated them.",
      "ja": "ただし、状況によっては、直接接続されていないピアのIDを確立できることが望ましい場合があります。最も自然なケースは、ピアがその状態を更新する場合です。この時点で、他のピアはオーバーレイ構造のビューを更新する必要があるかもしれませんが、更新メッセージが攻撃者からではなく実際のピアからのものであることを確認する必要があります。ピアが攻撃者からの更新メッセージを受け入れるのを防ぐために、すべてのオーバーレイルーティングメッセージは、それらを生成したピアによって署名されます。"
    },
    {
      "indent": 3,
      "text": "For messages that impact the topology of the overlay, replay is typically prevented by having the information come directly from, or be verified by, the nodes that claimed to have generated the update. Data storage replay detection is done by signing the time of the node that generated the signature on the Store request, thus providing a time-based replay protection, but the time synchronization is needed only between peers that can write to the same location.",
      "ja": "オーバーレイのトポロジに影響を与えるメッセージの場合、通常は、更新を生成したと主張するノードから直接情報を取得するか、情報を検証することによって、再生が防止されます。データストレージのリプレイ検出は、ストアリクエストで署名を生成したノードの時刻に署名することで行われ、時間ベースのリプレイ保護を提供しますが、時刻の同期が必要なのは、同じ場所に書き込むことができるピア間でのみです。"
    },
    {
      "indent": 0,
      "text": "13.6.4. Protecting the Signaling",
      "section_title": true,
      "ja": "13.6.4. シグナリングの保護"
    },
    {
      "indent": 3,
      "text": "The goal here is to stop an attacker from knowing who is signaling what to whom. An attacker is unlikely to be able to observe the activities of a specific individual, given the randomization of IDs and routing based on the present peers discussed above. Furthermore, because messages can be routed using only the header information, the actual body of the RELOAD message can be encrypted during transmission.",
      "ja": "ここでの目標は、攻撃者がだれに何を誰にシグナリングしているかを知ることを阻止することです。上記の現在のピアに基づいてIDとルーティングがランダム化されている場合、攻撃者が特定の個人のアクティビティを観察できる可能性は低いです。さらに、メッセージはヘッダー情報のみを使用してルーティングできるため、RELOADメッセージの実際の本文は送信中に暗号化できます。"
    },
    {
      "indent": 3,
      "text": "There are two lines of defense here. The first is the use of TLS or DTLS for each communications link between peers. This provides protection against attackers who are not members of the overlay. The second line of defense is to digitally sign each message. This prevents adversarial peers from modifying messages in flight, even if they are on the routing path.",
      "ja": "ここには2つの防御線があります。 1つは、ピア間の各通信リンクにTLSまたはDTLSを使用することです。これにより、オーバーレイのメンバーではない攻撃者に対する保護が提供されます。 2番目の防御策は、各メッセージにデジタル署名することです。これにより、たとえそれらがルーティングパス上にあっても、敵対的なピアが処理中のメッセージを変更することを防ぎます。"
    },
    {
      "indent": 0,
      "text": "13.6.5. Routing Loops and DoS Attacks",
      "section_title": true,
      "ja": "13.6.5. ルーティングループとDoS攻撃"
    },
    {
      "indent": 3,
      "text": "Source-routing mechanisms are known to create the possibility for DoS amplification, especially by the induction of routing loops [RFC5095]. In order to limit amplification, the initial-ttl value in the configuration file SHOULD be set to a value slightly larger than the longest expected path through the network. For Chord, experience has shown that log(2) of the number of nodes in the network + 5 is a safe bound. Because nodes are required to enforce the initial-ttl as the maximum value, an attacker cannot achieve an amplification factor greater than initial-ttl, thus limiting the additional capabilities provided by source routing.",
      "ja": "ソースルーティングメカニズムは、特にルーティングループの誘導によって、DoS増幅の可能性を生み出すことが知られています[RFC5095]。増幅を制限するために、構成ファイルのinitial-ttl値は、ネットワークを介して予想される最長のパスよりわずかに大きい値に設定する必要があります（SHOULD）。 Chordの場合、経験上、ネットワーク内のノード数のlog（2）+ 5が安全な範囲であることが示されています。ノードは初期値を最大値として強制する必要があるため、攻撃者は初期値より大きな増幅率を達成できず、ソースルーティングによって提供される追加機能が制限されます。"
    },
    {
      "indent": 3,
      "text": "In order to prevent the use of loops for targeted implementation attacks, implementations SHOULD check the Destination List for duplicate entries and discard such records with an \"Error_Invalid_Message\" error. This does not completely prevent loops, but it does require that at least one attacker node be part of the loop.",
      "ja": "ターゲット実装攻撃でループが使用されるのを防ぐために、実装では宛先リストで重複するエントリを確認し、そのようなレコードを「Error_Invalid_Message」エラーで破棄する必要があります。これはループを完全に防ぐわけではありませんが、少なくとも1つの攻撃者ノードがループの一部である必要があります。"
    },
    {
      "indent": 0,
      "text": "13.6.6. Residual Attacks",
      "section_title": true,
      "ja": "13.6.6. 残留攻撃"
    },
    {
      "indent": 3,
      "text": "The routing security mechanisms in RELOAD are designed to contain rather than eliminate attacks on routing. It is still possible for an attacker to mount a variety of attacks. In particular, if an attacker is able to take up a position on the overlay routing between A and B, it can make it appear as if B does not exist or is disconnected. It can also advertise false network metrics in an attempt to reroute traffic. However, these are primarily DoS attacks.",
      "ja": "RELOADのルーティングセキュリティメカニズムは、ルーティングに対する攻撃を排除するのではなく、封じ込めるように設計されています。攻撃者がさまざまな攻撃を仕掛けることは依然として可能です。特に、攻撃者がAとBの間のオーバーレイルーティングの位置を取得できる場合、Bが存在しないか切断されているように見せかけることができます。また、トラフィックを再ルーティングしようとして、誤ったネットワークメトリックをアドバタイズすることもできます。ただし、これらは主にDoS攻撃です。"
    },
    {
      "indent": 3,
      "text": "The certificate-based security scheme secures the namespace, but if an individual peer is compromised or if an attacker obtains a certificate from the CA, then a number of subversive peers can still appear in the overlay. While these peers cannot falsify responses to resource queries, they can respond with error messages, effecting a DoS attack on the resource registration. They can also subvert routing to other compromised peers. To defend against such attacks, a resource search must still consist of parallel searches for replicated registrations.",
      "ja": "証明書ベースのセキュリティスキームは名前空間を保護しますが、個々のピアが侵害された場合、または攻撃者がCAから証明書を取得した場合でも、いくつかの破壊的なピアがオーバーレイに表示される可能性があります。これらのピアはリソースクエリへの応答を改ざんすることはできませんが、エラーメッセージで応答して、リソース登録に対するDoS攻撃を引き起こす可能性があります。また、他の侵害されたピアへのルーティングを妨害することもできます。このような攻撃を防ぐために、リソース検索は、複製された登録の並列検索で構成されている必要があります。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section contains the new code points registered by this document.",
      "ja": "このセクションには、このドキュメントによって登録された新しいコードポイントが含まれています。"
    },
    {
      "indent": 0,
      "text": "14.1. Well-Known URI Registration",
      "section_title": true,
      "ja": "14.1. 既知のURI登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered a \"well-known URI\" as described in [RFC5785]:",
      "ja": "[RFC5785]で説明されているように、IANAは「既知のURI」を登録しています。"
    },
    {
      "indent": 11,
      "text": "+----------------------------+----------------------+\n| URI suffix:                | reload-config        |\n| Change controller:         | IETF <iesg@ietf.org> |\n| Specification document(s): | RFC 6940             |\n| Related information:       | None                 |\n+----------------------------+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.2. Port Registrations",
      "section_title": true,
      "ja": "14.2. ポート登録"
    },
    {
      "indent": 3,
      "text": "IANA has already allocated a TCP port for the main peer-to-peer protocol. This port had the name p2psip-enroll and the port number of 6084. Per this document, IANA has updated this registration to change the service name to reload-config.",
      "ja": "IANAは、メインのピアツーピアプロトコル用のTCPポートをすでに割り当てています。このポートの名前はp2psip-enrollで、ポート番号は6084でした。このドキュメントに従って、IANAはこの登録を更新して、サービス名をreload-configに変更しました。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following port registration:",
      "ja": "IANAは次のポート登録を行いました："
    },
    {
      "indent": 3,
      "text": "+-----------------------------+-------------------------------------+\n| Registration Technical      | IETF Chair <chair@ietf.org>         |\n| Contact                     |                                     |\n| Registration Owner          | IETF <iesg@ietf.org>                |\n| Transport Protocol          | TCP                                 |\n| Port Number                 | 6084                                |\n| Service Name                | reload-config                       |\n| Description                 | Peer-to-Peer Infrastructure         |\n|                             | Configuration                       |\n+-----------------------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.3. Overlay Algorithm Types",
      "section_title": true,
      "ja": "14.3. オーバーレイアルゴリズムタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Algorithm Types\" Registry. Entries in this registry are strings denoting the names of overlay algorithms, as described in Section 11.1 of [RFC6940]. The registration policy for this registry is \"IETF Review\" [RFC522]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Overlay Algorithm Types」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション11.1で説明されているように、オーバーレイアルゴリズムの名前を示す文字列です。このレジストリの登録ポリシーは「IETFレビュー」[RFC522]です。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+----------------+-----------+\n| Algorithm Name | Reference |\n+----------------+-----------+\n| CHORD-RELOAD   |  RFC 6940 |\n| EXP-OVERLAY    |  RFC 6940 |\n+----------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value EXP-OVERLAY has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "EXP-OVERLAYという値は、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.4. Access Control Policies",
      "section_title": true,
      "ja": "14.4. アクセス制御ポリシー"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Access Control Policies\" Registry. Entries in this registry are strings denoting access control policies, as described in Section 7.3 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Access Control Policies」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション7.3で説明されているように、アクセス制御ポリシーを示す文字列です。このレジストリの新しいエントリは、標準アクション[RFC5226]を介して登録する必要があります。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+-----------------+-----------+\n| Access Policy   | Reference |\n+-----------------+-----------+\n| USER-MATCH      |  RFC 6940 |\n| NODE-MATCH      |  RFC 6940 |\n| USER-NODE-MATCH |  RFC 6940 |\n| NODE-MULTIPLE   |  RFC 6940 |\n| EXP-MATCH       |  RFC 6940 |\n+-----------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value EXP-MATCH has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "EXP-MATCHの値は、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.5. Application-ID",
      "section_title": true,
      "ja": "14.5. アプリケーションID"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Application-ID\" Registry. Entries in this registry are 16-bit integers denoting Application-IDs, as described in Section 6.5.2 of [RFC6940]. Code points in the range 1 to 32767 SHALL be registered via Standards Action [RFC5226]. Code points in the range 32768 to 61440 SHALL be registered via Expert Review [RFC5226]. Code points in the range 61441 to 65534 are reserved for private use. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Application-ID」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション6.5.2で説明されているように、アプリケーションIDを示す16ビット整数です。 1から32767の範囲のコードポイントは、標準アクション[RFC5226]を介して登録する必要があります。 32768から61440の範囲のコードポイントは、エキスパートレビュー[RFC5226]を介して登録する必要があります。 61441から65534の範囲のコードポイントは、個人使用のために予約されています。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+-------------+----------------+-------------------------------+\n| Application | Application-ID |                 Specification |\n+-------------+----------------+-------------------------------+\n| INVALID     |              0 |                      RFC 6940 |\n| SIP         |           5060 | Reserved for use by SIP Usage |\n| SIP         |           5061 | Reserved for use by SIP Usage |\n| Reserved    |          65535 |                      RFC 6940 |\n+-------------+----------------+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.6. Data Kind-ID",
      "section_title": true,
      "ja": "14.6. データの種類ID"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Data Kind-ID\" registry. Entries in this registry are 32-bit integers denoting data Kinds, as described in Section 5.2 of [RFC6940]. Code points in the range 0x00000001 to 0x7FFFFFFF SHALL be registered via Standards Action [RFC5226]. Code points in the range 0x8000000 to 0xF0000000 SHALL be registered via Expert Review [RFC5226]. Code points in the range 0xF0000001 to 0xFFFFFFFE are reserved for private use via the Kind description mechanism described in Section 11 of [RFC6940]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Data Kind-ID」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション5.2で説明されているように、データの種類を示す32ビットの整数です。 0x00000001から0x7FFFFFFFの範囲のコードポイントは、標準アクション[RFC5226]を介して登録する必要があります。 0x8000000から0xF0000000の範囲のコードポイントは、エキスパートレビュー[RFC5226]を介して登録する必要があります。 0xF0000001から0xFFFFFFFEの範囲のコードポイントは、[RFC6940]のセクション11で説明されている種類の説明メカニズムを介して、私的使用のために予約されています。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 13,
      "text": "+---------------------+------------+-----------+\n| Kind                |    Kind-ID | Reference |\n+---------------------+------------+-----------+\n| INVALID             |        0x0 |  RFC 6940 |\n| TURN-SERVICE        |        0x2 |  RFC 6940 |\n| CERTIFICATE_BY_NODE |        0x3 |  RFC 6940 |\n| CERTIFICATE_BY_USER |       0x10 |  RFC 6940 |\n| Reserved            | 0x7fffffff |  RFC 6940 |\n| Reserved            | 0xfffffffe |  RFC 6940 |\n+---------------------+------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.7. Data Model",
      "section_title": true,
      "ja": "14.7. データ・モデル"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Data Model\" registry. Entries in this registry are strings denoting data models, as described in Section 7.2 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Data Model」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション7.2で説明されているように、データモデルを示す文字列です。このレジストリの新しいエントリは、標準アクション[RFC5226]を介して登録する必要があります。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 24,
      "text": "+------------+-----------+\n| Data Model | Reference |\n+------------+-----------+\n| INVALID    |  RFC 6940 |\n| SINGLE     |  RFC 6940 |\n| ARRAY      |  RFC 6940 |\n| DICTIONARY |  RFC 6940 |\n| EXP-DATA   |  RFC 6940 |\n| RESERVED   |  RFC 6940 |\n+------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value EXP-DATA has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "EXP-DATAという値は、実験の目的で利用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.8. Message Codes",
      "section_title": true,
      "ja": "14.8. メッセージコード"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Message Codes\" registry. Entries in this registry are 16-bit integers denoting method codes, as described in Section 6.3.3 of [RFC6940]. These codes SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Message Codes」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.3で説明されているように、メソッドコードを示す16ビット整数です。これらのコードは、標準アクション[RFC5226]を通じて登録する必要があります。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 0,
      "text": "   +-------------------------------------+----------------+-----------+\n   | Message Code Name                   |     Code Value | Reference |\n   +-------------------------------------+----------------+-----------+\n   | invalidMessageCode                  |            0x0 |  RFC 6940 |\n   | probe_req                           |            0x1 |  RFC 6940 |\n   | probe_ans                           |            0x2 |  RFC 6940 |\n   | attach_req                          |            0x3 |  RFC 6940 |\n   | attach_ans                          |            0x4 |  RFC 6940 |\n   | Unassigned                          |            0x5 |           |\n   | Unassigned                          |            0x6 |           |\n   | store_req                           |            0x7 |  RFC 6940 |\n   | store_ans                           |            0x8 |  RFC 6940 |\n   | fetch_req                           |            0x9 |  RFC 6940 |\n   | fetch_ans                           |            0xA |  RFC 6940 |\n   | Unassigned (was remove_req)         |            0xB |  RFC 6940 |\n   | Unassigned (was remove_ans)         |            0xC |  RFC 6940 |\n   | find_req                            |            0xD |  RFC 6940 |\n   | find_ans                            |            0xE |  RFC 6940 |\n   | join_req                            |            0xF |  RFC 6940 |\n   | join_ans                            |           0x10 |  RFC 6940 |\n   | leave_req                           |           0x11 |  RFC 6940 |\n   | leave_ans                           |           0x12 |  RFC 6940 |\n   | update_req                          |           0x13 |  RFC 6940 |\n   | update_ans                          |           0x14 |  RFC 6940 |\n   | route_query_req                     |           0x15 |  RFC 6940 |\n   | route_query_ans                     |           0x16 |  RFC 6940 |\n   | ping_req                            |           0x17 |  RFC 6940 |\n   | ping_ans                            |           0x18 |  RFC 6940 |\n   | stat_req                            |           0x19 |  RFC 6940 |\n   | stat_ans                            |           0x1A |  RFC 6940 |\n   | Unassigned (was attachlite_req)     |           0x1B |  RFC 6940 |\n   | Unassigned (was attachlite_ans)     |           0x1C |  RFC 6940 |\n   | app_attach_req                      |           0x1D |  RFC 6940 |\n   | app_attach_ans                      |           0x1E |  RFC 6940 |\n   | Unassigned (was app_attachlite_req) |           0x1F |  RFC 6940 |\n   | Unassigned (was app_attachlite_ans) |           0x20 |  RFC 6940 |\n   | config_update_req                   |           0x21 |  RFC 6940 |\n   | config_update_ans                   |           0x22 |  RFC 6940 |\n   | exp_a_req                           |           0x23 |  RFC 6940 |\n   | exp_a_ans                           |           0x24 |  RFC 6940 |\n   | exp_b_req                           |           0x25 |  RFC 6940 |\n   | exp_b_ans                           |           0x26 |  RFC 6940 |\n   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |\n   | error                               |         0xFFFF |  RFC 6940 |\n   +-------------------------------------+----------------+-----------+\n   The values exp_a_req, exp_a_ans, exp_b_req, and exp_b_ans have been\n   made available for the purposes of experimentation.  These values are\n   not meant for vendor-specific use of any sort, and they MUST NOT be\n   used for operational deployments.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.9. Error Codes",
      "section_title": true,
      "ja": "14.9. エラーコード"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Error Code\" registry. Entries in this registry are 16-bit integers denoting error codes, as described in Section 6.3.3.1 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは「RELOAD Error Code」レジストリを作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.3.1で説明されているように、エラーコードを示す16ビット整数です。新しいエントリは、標準アクション[RFC5226]を介して定義する必要があります。このレジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------+----------------+-----------+\n| Error Code Name                     |     Code Value | Reference |\n+-------------------------------------+----------------+-----------+\n| invalidErrorCode                    |            0x0 |  RFC 6940 |\n| Unassigned                          |            0x1 |           |\n| Error_Forbidden                     |            0x2 |  RFC 6940 |\n| Error_Not_Found                     |            0x3 |  RFC 6940 |\n| Error_Request_Timeout               |            0x4 |  RFC 6940 |\n| Error_Generation_Counter_Too_Low    |            0x5 |  RFC 6940 |\n| Error_Incompatible_with_Overlay     |            0x6 |  RFC 6940 |\n| Error_Unsupported_Forwarding_Option |            0x7 |  RFC 6940 |\n| Error_Data_Too_Large                |            0x8 |  RFC 6940 |\n| Error_Data_Too_Old                  |            0x9 |  RFC 6940 |\n| Error_TTL_Exceeded                  |            0xA |  RFC 6940 |\n| Error_Message_Too_Large             |            0xB |  RFC 6940 |\n| Error_Unknown_Kind                  |            0xC |  RFC 6940 |\n| Error_Unknown_Extension             |            0xD |  RFC 6940 |\n| Error_Response_Too_Large            |            0xE |  RFC 6940 |\n| Error_Config_Too_Old                |            0xF |  RFC 6940 |\n| Error_Config_Too_New                |           0x10 |  RFC 6940 |\n| Error_In_Progress                   |           0x11 |  RFC 6940 |\n| Error_Exp_A                         |           0x12 |  RFC 6940 |\n| Error_Exp_B                         |           0x13 |  RFC 6940 |\n| Error_Invalid_Message               |           0x14 |  RFC 6940 |\n| Reserved                            | 0x8000..0xFFFE |  RFC 6940 |\n+-------------------------------------+----------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The values Error_Exp_A and Error_Exp_B have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.",
      "ja": "実験のために、Error_Exp_AとError_Exp_Bの値が用意されています。これらの値は、ベンダー固有の使用を目的としたものではなく、運用展開に使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "14.10. Overlay Link Types",
      "section_title": true,
      "ja": "14.10. オーバーレイリンクタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Link Registry\". Entries in this registry are 8-bit integers, as described in Section 6.5.1.1 of [RFC6940]. For more information on the link types defined here, see Section 6.6 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは「RELOAD Overlay Link Registry」を作成しました。 [RFC6940]のセクション6.5.1.1で説明されているように、このレジストリのエントリは8ビット整数です。ここで定義されているリンクタイプの詳細については、[RFC6940]のセクション6.6をご覧ください。新しいエントリは、標準アクション[RFC5226]を介して定義する必要があります。このレジストリには、最初に次の値が入力されています。"
    },
    {
      "indent": 17,
      "text": "+--------------------+------+-----------+\n| Protocol           | Code | Reference |\n+--------------------+------+-----------+\n| INVALID-PROTOCOL   |    0 |  RFC 6940 |\n| DTLS-UDP-SR        |    1 |  RFC 6940 |\n| DTLS-UDP-SR-NO-ICE |    3 |  RFC 6940 |\n| TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940 |\n| EXP-LINK           |    5 |  RFC 6940 |\n| Reserved           |  255 |  RFC 6940 |\n+--------------------+------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value EXP-LINK has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "EXP-LINKという値は、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.11. Overlay Link Protocols",
      "section_title": true,
      "ja": "14.11. オーバーレイリンクプロトコル"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Link Protocol Registry\". Entries in this registry are strings denoting protocols as described in Section 11.1 of this document and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは「RELOAD Overlay Link Protocol Registry」を作成しました。このレジストリのエントリは、このドキュメントのセクション11.1で説明されているプロトコルを示す文字列であり、標準アクション[RFC5226]を介して定義する必要があります。このレジストリには、最初に次の値が入力されています。"
    },
    {
      "indent": 23,
      "text": "+---------------+-----------+\n| Link Protocol | Reference |\n+---------------+-----------+\n| TLS           |  RFC 6940 |\n| EXP-PROTOCOL  |  RFC 6940 |\n+---------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value EXP-PROTOCOL has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "EXP-PROTOCOLという値は、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.12. Forwarding Options",
      "section_title": true,
      "ja": "14.12. 転送オプション"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Forwarding Option Registry\". Entries in this registry are 8-bit integers denoting options, as described in Section 6.3.2.3 of [RFC6940]. Values between 1 and 127 SHALL be defined via Standards Action [RFC5226]. Entries in this registry between 128 and 254 SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは「RELOAD Forwarding Option Registry」を作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.2.3で説明されているように、オプションを示す8ビット整数です。 1から127までの値は、標準アクション[RFC5226]を介して定義する必要があります。 128と254の間のこのレジストリのエントリは、Specification Required [RFC5226]を介して定義する必要があります。このレジストリには、最初に次の値が入力されています。"
    },
    {
      "indent": 14,
      "text": "+-------------------------+------+-----------+\n| Forwarding Option       | Code | Reference |\n+-------------------------+------+-----------+\n| invalidForwardingOption |    0 |  RFC 6940 |\n| exp-forward             |    1 |  RFC 6940 |\n| Reserved                |  255 |  RFC 6940 |\n+-------------------------+------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value exp-forward has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "exp-forwardという値は、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.13. Probe Information Types",
      "section_title": true,
      "ja": "14.13. プローブ情報タイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Probe Information Type Registry\". Entries are 8-bit integers denoting types as described in Section 6.4.2.5.1 of [RFC6940] and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは「RELOADプローブ情報タイプレジストリ」を作成しました。エントリは、[RFC6940]のセクション6.4.2.5.1で説明されているタイプを示す8ビット整数であり、標準アクション[RFC5226]を介して定義する必要があります。このレジストリには、最初に次の値が入力されています。"
    },
    {
      "indent": 17,
      "text": "+--------------------+------+-----------+\n| Probe Option       | Code | Reference |\n+--------------------+------+-----------+\n| invalidProbeOption |    0 |  RFC 6940 |\n| responsible_set    |    1 |  RFC 6940 |\n| num_resources      |    2 |  RFC 6940 |\n| uptime             |    3 |  RFC 6940 |\n| exp-probe          |    4 |  RFC 6940 |\n| Reserved           |  255 |  RFC 6940 |\n+--------------------+------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value exp-probe has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値exp-probeは、実験の目的で使用できるようになっています。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.14. Message Extensions",
      "section_title": true,
      "ja": "14.14. メッセージ拡張"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Extensions Registry\". Entries in this registry are 8-bit integers denoting extensions as described in Section 6.3.3 of [RFC6940] and SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは「RELOAD Extensions Registry」を作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.3で説明されている拡張を示す8ビット整数であり、必要な仕様[RFC5226]を介して定義する必要があります。このレジストリには、最初に次の値が入力されています。"
    },
    {
      "indent": 11,
      "text": "+-----------------------------+--------+-----------+\n| Extensions Name             |   Code | Reference |\n+-----------------------------+--------+-----------+\n| invalidMessageExtensionType |    0x0 |  RFC 6940 |\n| exp-ext                     |    0x1 |  RFC 6940 |\n| Reserved                    | 0xFFFF |  RFC 6940 |\n+-----------------------------+--------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value exp-ext has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "実験のために、値exp-extが利用可能になりました。この値は、ベンダー固有のあらゆる種類の使用を意図したものではなく、運用展開に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "14.15. Reload URI Scheme",
      "section_title": true,
      "ja": "14.15. URIスキームの再読み込み"
    },
    {
      "indent": 3,
      "text": "This section describes the scheme for a reload URI, which can be used to refer to either:",
      "ja": "このセクションでは、次のいずれかを参照するために使用できるリロードURIのスキームについて説明します。"
    },
    {
      "indent": 3,
      "text": "o A peer, e.g., as used in a certificate (see Section 11.3 of [RFC6940]).",
      "ja": "o 証明書で使用されているようなピア（[RFC6940]のセクション11.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o A resource inside a peer.",
      "ja": "o ピア内のリソース。"
    },
    {
      "indent": 3,
      "text": "The reload URI is defined using a subset of the URI schema specified in Appendix A of RFC 3986 [RFC3986] and the associated URI Guidelines [RFC4395] per the following ABNF syntax:",
      "ja": "リロードURIは、次のABNF構文に従って、RFC 3986 [RFC3986]の付録Aで指定されているURIスキーマのサブセットと、関連するURIガイドライン[RFC4395]を使用して定義されます。"
    },
    {
      "indent": 6,
      "text": "RELOAD-URI = \"reload://\" destination \"@\" overlay \"/\"\n         [specifier]\ndestination = 1*HEXDIG\noverlay = reg-name\nspecifier = 1*HEXDIG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The definitions of these productions are as follows:",
      "ja": "これらのプロダクションの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "destination A hexadecimal-encoded Destination List object (i.e., multiple concatenated Destination objects with no length prefix prior to the object as a whole).",
      "ja": "宛先16進数でエンコードされた宛先リストオブジェクト（つまり、オブジェクト全体の前に長さの接頭辞がない複数の連結された宛先オブジェクト）。"
    },
    {
      "indent": 3,
      "text": "overlay The name of the overlay.",
      "ja": "overlayオーバーレイの名前。"
    },
    {
      "indent": 3,
      "text": "specifier A hexadecimal-encoded StoredDataSpecifier indicating the data element.",
      "ja": "specifierデータ要素を示す16進数でエンコードされたStoredDataSpecifier。"
    },
    {
      "indent": 3,
      "text": "If no specifier is present, this URI addresses the peer which can be reached via the indicated Destination List at the indicated overlay name. If a specifier is present, the URI addresses the data value.",
      "ja": "指定子が存在しない場合、このURIは、指定されたオーバーレイ名で指定された宛先リストを介して到達できるピアをアドレス指定します。指定子が存在する場合、URIはデータ値をアドレス指定します。"
    },
    {
      "indent": 0,
      "text": "14.15.1. URI Registration",
      "section_title": true,
      "ja": "14.15.1. うり れぎｓｔらちおん"
    },
    {
      "indent": 3,
      "text": "The following summarizes the information necessary to register the reload URI.",
      "ja": "以下は、リロードURIの登録に必要な情報をまとめたものです。"
    },
    {
      "indent": 3,
      "text": "URI Scheme Name: reload",
      "ja": "URIスキーム名：reload"
    },
    {
      "indent": 3,
      "text": "Status: permanent",
      "ja": "ステータス：永続的"
    },
    {
      "indent": 3,
      "text": "URI Scheme Syntax: see Section 14.15 of RFC 6940",
      "ja": "URIスキームの構文：RFC 6940のセクション14.15を参照"
    },
    {
      "indent": 3,
      "text": "URI Scheme Semantics: The reload URI is intended to be used as a reference to a RELOAD peer or resource.",
      "ja": "URIスキームセマンティクス：リロードURIは、RELOADピアまたはリソースへの参照として使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: The reload URI is not intended to be human-readable text, so it is encoded entirely in US-ASCII.",
      "ja": "エンコーディングに関する考慮事項：リロードURIは人間が読み取れるテキストを意図したものではないため、完全にUS-ASCIIでエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that Use this URI Scheme: The RELOAD protocol described in RFC 6940.",
      "ja": "このURIスキームを使用するアプリケーション/プロトコル：RFC 6940で説明されているRELOADプロトコル。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: See RFC 6940.",
      "ja": "相互運用性に関する考慮事項：RFC 6940を参照してください。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: See RFC 6940",
      "ja": "セキュリティに関する考慮事項：RFC 6940を参照"
    },
    {
      "indent": 3,
      "text": "Contact:  Cullen Jennings <fluffy@cisco.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Author/Change Controller: IESG",
      "ja": "著者/変更コントローラ：IESG"
    },
    {
      "indent": 3,
      "text": "References: RFC 6940",
      "ja": "参照：RFC 6940"
    },
    {
      "indent": 0,
      "text": "14.16. Media Type Registration",
      "section_title": true,
      "ja": "14.16. メディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "Type Name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype Name: p2p-overlay+xml",
      "ja": "サブタイプ名：p2p-overlay + xml"
    },
    {
      "indent": 0,
      "text": " Required Parameters: none Optional Parameters: none",
      "ja": "必須パラメーター：なしオプションパラメーター：なし"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: Must be binary encoded.",
      "ja": "エンコードに関する考慮事項：バイナリエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: This media type is typically not used to transport information that needs to be kept confidential. However, there are cases where it is integrity of the information is important. For these cases, using a digital signature is RECOMMENDED. One way of doing this is specified in RFC 6940. In the case when the media includes a shared-secret element, the contents of the file MUST be kept confidential or else anyone who can see the shared secret can affect the RELOAD overlay network.",
      "ja": "セキュリティに関する考慮事項：このメディアタイプは、通常、機密を保持する必要がある情報の転送には使用されません。ただし、情報の整合性が重要となる場合があります。このような場合は、デジタル署名を使用することをお勧めします。これを行う1つの方法は、RFC 6940で指定されています。メディアに共有シークレット要素が含まれている場合、ファイルの内容は秘密にしておく必要があります。そうしないと、共有シークレットを見ることができる誰もがRELOADオーバーレイネットワークに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: No known interoperability consideration beyond those identified for application/xml in [RFC3023].",
      "ja": "相互運用性に関する考慮事項：[RFC3023]のapplication / xmlで識別されたものを超える相互運用性に関する考慮事項はありません。"
    },
    {
      "indent": 3,
      "text": "Published Specification: RFC 6940",
      "ja": "公開された仕様：RFC 6940"
    },
    {
      "indent": 3,
      "text": "Applications that Use this Media Type: The type is used to configure the peer-to-peer overlay networks defined in RFC 6940.",
      "ja": "このメディアタイプを使用するアプリケーション：このタイプは、RFC 6940で定義されているピアツーピアオーバーレイネットワークを構成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Additional Information: The syntax for this media type is specified in Section 11.1 of [RFC6940]. The contents MUST be valid XML that is compliant with the RELAX NG grammar specified in RFC 6940 and that use the UTF-8[RFC3629] character encoding.",
      "ja": "追加情報：このメディアタイプの構文は、[RFC6940]のセクション11.1で指定されています。コンテンツは、RFC 6940で指定されたRELAX NG文法に準拠し、UTF-8 [RFC3629]文字エンコーディングを使用する有効なXMLである必要があります。"
    },
    {
      "indent": 6,
      "text": "Magic Number(s): none",
      "ja": "マジックナンバー：なし"
    },
    {
      "indent": 6,
      "text": "File Extension(s): relo",
      "ja": "ファイル拡張子：relo"
    },
    {
      "indent": 6,
      "text": "Macintosh File Type Code(s): none",
      "ja": "Macintoshファイルタイプコード：なし"
    },
    {
      "indent": 3,
      "text": "Person & Email Address to Contact for Further Information: Cullen\nJennings <fluffy@cisco.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Intended Usage: COMMON",
      "ja": "使用目的：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on Usage: None",
      "ja": "使用上の制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: Cullen Jennings <fluffy@cisco.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Change Controller: IESG",
      "ja": "コントローラーの変更：IESG"
    },
    {
      "indent": 0,
      "text": "14.17. XML Namespace Registration",
      "section_title": true,
      "ja": "14.17. XML名前空間の登録"
    },
    {
      "indent": 3,
      "text": "This document registers two URIs for the config and config-chord XML namespaces in the IETF XML registry defined in [RFC3688].",
      "ja": "このドキュメントは、[RFC3688]で定義されているIETF XMLレジストリにconfigおよびconfig-chord XML名前空間の2つのURIを登録します。"
    },
    {
      "indent": 0,
      "text": "14.17.1. Config URL",
      "section_title": true,
      "ja": "14.17.1. 設定URL"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:p2p:config-base",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IESG.",
      "ja": "登録者の連絡先：IESG。"
    },
    {
      "indent": 3,
      "text": "XML: N/A, the requested URIs are XML namespaces",
      "ja": "XML：N / A、リクエストされたURIはXML名前空間です"
    },
    {
      "indent": 0,
      "text": "14.17.2. Config Chord URL",
      "section_title": true,
      "ja": "14.17.2. 設定コードURL"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:p2p:config-chord",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Registrant Contact: The IESG.",
      "ja": "登録者の連絡先：IESG。"
    },
    {
      "indent": 3,
      "text": "XML: N/A, the requested URIs are XML namespaces",
      "ja": "XML：N / A、リクエストされたURIはXML名前空間です"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "This specification is a merge of the \"REsource LOcation And Discovery (RELOAD)\" document by David A. Bryan, Marcia Zangrilli, and Bruce B. Lowekamp; the \"Address Settlement by Peer to Peer\" document by Cullen Jennings, Jonathan Rosenberg, and Eric Rescorla; the \"Security Extensions for RELOAD\" document by Bruce B. Lowekamp and James Deverick; the \"A Chord-based DHT for Resource Lookup in P2PSIP\" by Marcia Zangrilli and David A. Bryan; and the Peer-to-Peer Protocol (P2PP) document by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski. Thanks to the authors of [RFC5389] for text included from that document. Vidya Narayanan provided many comments and improvements.",
      "ja": "この仕様は、David A. Bryan、Marcia Zangrilli、およびBruce B. Lowekampによる「REsource LOcation And Discovery（RELOAD）」ドキュメントのマージです。 Cullen Jennings、Jonathan Rosenberg、Eric Rescorlaによる「ピアツーピアによる住所解決」文書。 Bruce B. LowekampとJames Deverickによる「RELOADのセキュリティ拡張」ドキュメント。 Marcia ZangrilliとDavid A. Bryanによる「P2PSIPでのリソースルックアップ用のコードベースのDHT」。 Salman A. Baset、Henning Schulzrinne、Marcin MatuszewskiによるPeer-to-Peer Protocol（P2PP）ドキュメント。 [RFC5389]の作者に感謝します。 Vidya Narayananは多くのコメントと改善を提供しました。"
    },
    {
      "indent": 3,
      "text": "The ideas and text for the Chord-specific extension data to the Leave mechanisms were provided by Jouni Maenpaa, Gonzalo Camarillo, and Jani Hautakorpi.",
      "ja": "休暇メカニズムへのコード固有の拡張データのアイデアとテキストは、Jouni Maenpaa、Gonzalo Camarillo、Jani Hautakorpiから提供されました。"
    },
    {
      "indent": 3,
      "text": "Thanks to the many people who contributed, including Ted Hardie, Michael Chen, Dan York, Das Saumitra, Lyndsay Campbell, Brian Rosen, David Bryan, Dave Craig, and Julian Cain. Extensive last call comments were provided by Jouni Maenpaa, Roni Even, Gonzalo Camarillo, Ari Keranen, John Buford, Michael Chen, Frederic-Philippe Met, Mary Barnes, Roland Bless, David Bryan, and Polina Goltsman. Special thanks to Marc Petit-Huguenin, who provided an amazing amount of detailed review.",
      "ja": "テッド・ハーディ、マイケル・チェン、ダン・ヨーク、ダス・サウミトラ、リンゼイ・キャンベル、ブライアン・ローゼン、デビッド・ブライアン、デイブ・クレイグ、ジュリアン・ケインなど、多くの貢献者に感謝します。ラストコールに関する広範なコメントは、Jouni Maenpaa、Roni Even、Gonzalo Camarillo、Ari Keranen、John Buford、Michael Chen、Frederic-Philippe Met、Mary Barnes、Roland Bless、David Bryan、およびPolina Goltsmanから提供されました。 Marc Petit-Huguenin氏に特に感謝します。"
    },
    {
      "indent": 3,
      "text": "Dean Willis and Marc Petit-Huguenin helped resolve and provided text to fix many comments received during the IESG review.",
      "ja": "ディーンウィリスとマークプティフーゲニンは、IESGレビュー中に受け取った多くのコメントを修正するためにテキストの解決と提供を支援しました。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[OASIS.relax_ng] Bray, T. and M. Murata, \"RELAX NG Specification\", December 2001.",
      "ja": "[OASIS.relax_ng] Bray、T。およびM.村田、「RELAX NG仕様」、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[RFC1918] Rekhter、Y.、Moskowitz、R.、Karrenberg、D.、Groot、G。、およびE. Lear、「プライベートインターネットのアドレス割り当て」、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2388] Masinter, L., \"Returning Values from Forms: multipart/ form-data\", RFC 2388, August 1998.",
      "ja": "[RFC2388] Masinter、L。、「Returning Values from Forms：multipart / form-data」、RFC 2388、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2585] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[RFC2585] Housley、R。およびP. Hoffman、「Internet X.509 Public Key Infrastructure Operational Protocols：FTP and HTTP」、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818] Rescorla、E。、「HTTP over TLS」、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, \"XML Media Types\", RFC 3023, January 2001.",
      "ja": "[RFC3023] Murata、M.、St。Laurent、S。、およびD. Kohn、「XML Media Types」、RFC 3023、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[RFC3174] Eastlake、D。およびP. Jones、「US Secure Hash Algorithm 1（SHA1）」、RFC 3174、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G., Ed. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, July 2002.",
      "ja": "[RFC3339]クライン、G、エド。 C.ニューマン、「インターネット上の日付と時刻：タイムスタンプ」、RFC 3339、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4279] Eronen, P. and H. Tschofenig, \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, December 2005.",
      "ja": "[RFC4279] Eronen、P。およびH. Tschofenig、「トランスポート層セキュリティ（TLS）の事前共有鍵暗号スイート」、RFC 4279、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4395] Hansen, T., Hardie, T., and L. Masinter, \"Guidelines and Registration Procedures for New URI Schemes\", BCP 35, RFC 4395, February 2006.",
      "ja": "[RFC4395] Hansen、T.、Hardie、T。、およびL. Masinter、「新しいURIスキームのガイドラインと登録手順」、BCP 35、RFC 4395、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, April 2010.",
      "ja": "[RFC5245] Rosenberg、J。、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5272] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC)\", RFC 5272, June 2008.",
      "ja": "[RFC5272] Schaad、J。およびM. Myers、「CMS（CMC）を介した証明書管理」、RFC 5272、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5273] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC): Transport Protocols\", RFC 5273, June 2008.",
      "ja": "[RFC5273] Schaad、J。およびM. Myers、「CMS（CMC）を介した証明書管理：トランスポートプロトコル」、RFC 5273、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「Session Traversal Utilities for NAT（STUN）」、RFC 5389、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5405] Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines for Application Designers\", BCP 145, RFC 5405, November 2008.",
      "ja": "[RFC5405] Eggert、L。およびG. Fairhurst、「アプリケーション設計者のためのユニキャストUDP使用ガイドライン」、BCP 145、RFC 5405、2008年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", RFC 5766, April 2010.",
      "ja": "[RFC5766] Mahy、R.、Matthews、P.、J。Rosenberg、「NAT周辺のリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）」、RFC 5766、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, August 2010.",
      "ja": "[RFC5952] Kawamura、S. and M. Kawashima、 \"A Recommendation for IPv6 Address Text Representation\"、RFC 5952、August 2010。"
    },
    {
      "indent": 3,
      "text": "[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication\", RFC 6091, February 2011.",
      "ja": "[RFC6091] Mavrogiannopoulos、N。およびD. Gillmor、「Using OpenPGP Keys for Transport Layer Security（TLS）Authentication」、RFC 6091、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.",
      "ja": "[RFC6234] Eastlake、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「Computing TCP's Retransmission Timer」、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, January 2012.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、2012年1月。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xmlschema-2-20041028] Malhotra, A. and P. Biron, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "ja": "[W3C.REC-xmlschema-2-20041028] Malhotra、A。およびP. Biron、「XML Schema Part 2：Datatypes Second Edition」、World Wide Web Consortium Recommendation REC-xmlschema-2-20041028、2004年10月、<http： //www.w3.org/TR/2004/REC-xmlschema-2-20041028>。"
    },
    {
      "indent": 3,
      "text": "[w3c-xml-namespaces] Bray, T., Hollander, D., Layman, A., Tobin, R., and University of Edinburgh and W3C, \"Namespaces in XML 1.0 (Third Edition)\", December 2008.",
      "ja": "[w3c-xml-namespaces] Bray、T.、Hollander、D.、Layman、A.、Tobin、R.、University of EdinburghおよびW3C、「Namespaces in XML 1.0（Third Edition）」、2008年12月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Chord] Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, \"Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications\", IEEE/ACM Transactions on Networking Volume 11, Issue 1, 17-32, Feb 2003, 2001.",
      "ja": "[コード] Stoica、I.、Morris、R.、Liben-Nowell、D.、Karger、D.、Kaashoek、M.、Dabek、F。、およびH. Balakrishnan、「コード：スケーラブルなピアツーピアインターネットアプリケーション用のルックアッププロトコル」、IEEE / ACM Transactions on Networking Volume 11、Issue 1、17-32、Feb 2003、2001。"
    },
    {
      "indent": 3,
      "text": "[DHT-RELOAD] Maenpaa, J. and G. Camarillo, \"A Self-tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD)\", Work in Progress, August 2013.",
      "ja": "[DHT-RELOAD] Maenpaa、J。、およびG. Camarillo、「リソース再配置および検出（RELOAD）のための自己調整分散ハッシュテーブル（DHT）」、2013年8月、作業中。"
    },
    {
      "indent": 3,
      "text": "[Eclipse] Singh, A., Ngan, T., Druschel, T., and D. Wallach, \"Eclipse Attacks on Overlay Networks: Threats and Defenses\", INFOCOM 2006, April 2006.",
      "ja": "[Eclipse] Singh、A.、Ngan、T.、Druschel、T.、and D. Wallach、 \"Eclipse Attacks on Overlay Networks：Threats and Defenses\"、INFOCOM 2006、April 2006。"
    },
    {
      "indent": 3,
      "text": "[P2P-DIAGNOSTICS] Song, H., Jiang, X., Even, R., and D. Bryan, \"P2P Overlay Diagnostics\", Work in Progress, August 2013.",
      "ja": "[P2P-DIAGNOSTICS] Song、H.、Jiang、X.、Even、R.、D。Bryan、「P2P Overlay Diagnostics」、Work in Progress、2013年8月。"
    },
    {
      "indent": 3,
      "text": "[P2PSIP-RELAY] Zong, N., Jiang, X., Even, R., and Y. Zhang, \"An extension to RELOAD to support Relay Peer Routing\", Work in Progress, October 2013.",
      "ja": "[P2PSIP-RELAY] Zong、N.、Jiang、X.、Even、R。、およびY. Zhang、「リレーピアルーティングをサポートするためのRELOADの拡張」、2013年10月、作業中。"
    },
    {
      "indent": 3,
      "text": "[REDIR-RELOAD] Maenpaa, J. and G. Camarillo, \"Service Discovery Usage for REsource LOcation And Discovery (RELOAD)\", Work in Progress, August 2013.",
      "ja": "[REDIR-RELOAD] Maenpaa、J.、G。Camarillo、「REsource LOcation And Discovery（RELOAD）のService Discoveryの使用法」、作業中、2013年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名-実装と仕様」、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R。、「インターネットホストの要件-通信層」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2311] Dusse, S., Hoffman, P., Ramsdell, B., Lundblade, L., and L. Repka, \"S/MIME Version 2 Message Specification\", RFC 2311, March 1998.",
      "ja": "[RFC2311] Dusse、S.、Hoffman、P.、Ramsdell、B.、Lundblade、L。、およびL. Repka、「S / MIME Version 2 Message Specification」、RFC 2311、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004.",
      "ja": "[RFC3688] Mealling M。、「The IETF XML Registry」、BCP 81、RFC 3688、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K。、「SASLprep：Stringprep Profile for User Names and Passwords」、RFC 4013、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4145] Yon, D. and G. Camarillo, \"TCP-Based Media Transport in the Session Description Protocol (SDP)\", RFC 4145, September 2005.",
      "ja": "[RFC4145] Yon、D。、およびG. Camarillo、「セッション記述プロトコル（SDP）におけるTCPベースのメディア転送」、RFC 4145、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340] Kohler、E.、Handley、M。、およびS. Floyd、「Datagram Congestion Control Protocol（DCCP）」、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787]オーデットF.およびC.ジェニングス、「ユニキャストUDPのネットワークアドレス変換（NAT）動作要件」、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960] Stewart、R。、「Stream Control Transmission Protocol」、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5054] Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, \"Using the Secure Remote Password (SRP) Protocol for TLS Authentication\", RFC 5054, November 2007.",
      "ja": "[RFC5054] Taylor、D.、Wu、T.、Mavrogiannopoulos、N。、およびT. Perrin、「Using the Secure Remote Password（SRP）Protocol for TLS Authentication」、RFC 5054、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5095] Abley, J., Savola, P., and G. Neville-Neil, \"Deprecation of Type 0 Routing Headers in IPv6\", RFC 5095, December 2007.",
      "ja": "[RFC5095] Abley、J.、Savola、P。、およびG. Neville-Neil、「Deprecation of Type 0 Routing Headers in IPv6」、RFC 5095、2007年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, \"Host Identity Protocol\", RFC 5201, April 2008.",
      "ja": "[RFC5201] Moskowitz、R.、Nikander、P.、Jokela、P。、およびT. Henderson、「Host Identity Protocol」、RFC 5201、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5694] Camarillo, G., Ed., and IAB, \"Peer-to-Peer (P2P) Architecture: Definition, Taxonomies, Examples, and Applicability\", RFC 5694, November 2009.",
      "ja": "[RFC5694] Camarillo、G.、Ed。、およびIAB、「ピアツーピア（P2P）アーキテクチャ：定義、分類、例、および適用性」、RFC 5694、2009年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5765] Schulzrinne, H., Marocco, E., and E. Ivov, \"Security Issues and Solutions in Peer-to-Peer Systems for Realtime Communications\", RFC 5765, February 2010.",
      "ja": "[RFC5765] Schulzrinne、H.、Marocco、E。、およびE. Ivov、「リアルタイム通信のためのピアツーピアシステムのセキュリティの問題とソリューション」、RFC 5765、2010年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, April 2010.",
      "ja": "[RFC5785]ノッティンガム、M。およびE.ハマーラハブ、「Defining Well-Known Uniform Resource Identifiers（URIs）」、RFC 5785、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6079] Camarillo, G., Nikander, P., Hautakorpi, J., Keranen, A., and A. Johnston, \"HIP BONE: Host Identity Protocol (HIP) Based Overlay Networking Environment (BONE)\", RFC 6079, January 2011.",
      "ja": "[RFC6079]カマリロ、G。、ニカンダー、P。、ハウタコルピ、J。、ケラネン、A。、およびA.ジョンストン、「HIP BONE：Host Identity Protocol（HIP）Based Overlay Networking Environment（BONE）」、RFC 6079、 2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, \"TCP Candidates with Interactive Connectivity Establishment (ICE)\", RFC 6544, March 2012.",
      "ja": "[RFC6544] Rosenberg、J.、Kerenen、A.、Lowekamp、B。、およびA. Roach、「インタラクティブ接続確立（ICE）を使用するTCP候補」、RFC 6544、2012年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC7086] Keranen, A., Camarillo, G., and J. Maenpaa, \"Host Identity Protocol-Based Overlay Networking Environment (HIP BONE) Instance Specification for REsource LOcation And Discovery (RELOAD)\", RFC 7086, January 2014.",
      "ja": "[RFC7086] Keranen、A.、Camarillo、G。、およびJ. Maenpaa、「Host Identity Protocol-Based Overlay Networking Environment（HIP BONE）Instance Specification for REsource LOcation And Discovery（RELOAD）」、RFC 7086、2014年1月。"
    },
    {
      "indent": 3,
      "text": "[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, \"A SIP Usage for RELOAD\", Work in Progress, July 2013.",
      "ja": "[SIP-RELOAD] Jennings、C.、Lowekamp、B.、Rescorla、E.、Baset、S.、Schulzrinne、H。、およびT. Schmidt、「A SIP Usage for RELOAD」、Work in Progress、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[Sybil] Douceur, J., \"The Sybil Attack\", IPTPS 02, March 2002.",
      "ja": "[シビル] Douceur、J。、「シビル攻撃」、IPTPS 02、2002年3月。"
    },
    {
      "indent": 3,
      "text": "[UnixTime] Wikipedia, \"Unix Time\", 2013, <http://en.wikipedia.org/w/ index.php?title=Unix_time&oldid=551527446>.",
      "ja": "[UnixTime] Wikipedia、「Unix Time」、2013、<http://en.wikipedia.org/w/ index.php？title = Unix_time＆oldid = 551527446>。"
    },
    {
      "indent": 3,
      "text": "[bryan-design-hotp2p08] Bryan, D., Lowekamp, B., and M. Zangrilli, \"The Design of a Versatile, Secure P2PSIP Communications Architecture for the Public Internet\", Hot-P2P'08, 2008.",
      "ja": "[bryan-design-hotp2p08] Bryan、D.、Lowekamp、B。、およびM. Zangrilli、「The Public Design for a Versatile、Secure P2PSIP Communications Architecture for the Public Internet」、Hot-P2P'08、2008。"
    },
    {
      "indent": 3,
      "text": "[handling-churn-usenix04] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, \"Handling Churn in a DHT\", In Proc. of the USENIX Annual Technical Conference June 2004 USENIX 2004, 2004.",
      "ja": "[handling-churn-usenix04] Rhea、S.、Geels、D.、Roscoe、T.、and J. Kubiatowicz、 \"Handling Churn in a DHT\"、In Proc。 USENIX Annual Technical Conference 2004年6月USENIX 2004、2004"
    },
    {
      "indent": 3,
      "text": "[lookups-churn-p2p06] Wu, D., Tian, Y., and K. Ng, \"Analytical Study on Improving DHT Lookup Performance under Churn\", IEEE P2P'06, 2006.",
      "ja": "[lookups-churn-p2p06] Wu、D.、Tian、Y。、およびK. Ng、「チャーン下でのDHTルックアップパフォーマンスの改善に関する分析的研究」、IEEE P2P'06、2006。"
    },
    {
      "indent": 3,
      "text": "[minimizing-churn-sigcomm06] Godfrey, P., Shenker, S., and I. Stoica, \"Minimizing Churn in Distributed Systems\", SIGCOMM 2006, 2006.",
      "ja": "[minimizing-churn-sigcomm06] Godfrey、P.、Shenker、S。、およびI. Stoica、「Minimizing Churn in Distributed Systems」、SIGCOMM 2006、2006。"
    },
    {
      "indent": 3,
      "text": "[non-transitive-dhts-worlds05] Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, \"Non-Transitive Connectivity and DHTs\", WORLDS'05, 2005.",
      "ja": "[non-transitive-dhts-worlds05] Freedman、M.、Lakshminarayanan、K.、Rhea、S。、およびI. Stoica、「Non-Transitive Connectivity and DHTs」、WORLDS'05、2005。"
    },
    {
      "indent": 3,
      "text": "[opendht-sigcomm05] Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, \"OpenDHT: A Public DHT and its Uses\", SIGCOMM'05, 2005.",
      "ja": "[opendht-sigcomm05] Rhea、S.、Godfrey、B.、Karp、B.、Kubiatowicz、J.、Ratnasamy、S.、Shenker、S.、Stoica、I.、and H. Yu、 \"OpenDHT：A Public DHTおよびその使用」、SIGCOMM'05、2005。"
    },
    {
      "indent": 3,
      "text": "[vulnerabilities-acsac04] Srivatsa, M. and L. Liu, \"Vulnerabilities and Security Threats in Structured Peer-to-Peer Systems: A Quantitative Analysis\", ACSAC 2004, 2004.",
      "ja": "[vulnerabilities-acsac04] Srivatsa、M。およびL. Liu、「構造化ピアツーピアシステムの脆弱性とセキュリティの脅威：定量分析」、ACSAC 2004、2004。"
    },
    {
      "indent": 3,
      "text": "[wikiChord] Wikipedia, \"Chord (peer-to-peer)\", 2013, <http://en.wikipedia.org/w/ index.php?title=Chord_%28peer-to-peer%29&oldid=549516287>.",
      "ja": "[wikiChord] Wikipedia、「Chord（peer-to-peer）」、2013、<http://en.wikipedia.org/w/ index.php？title = Chord_％28peer-to-peer％29＆oldid = 549516287>。"
    },
    {
      "indent": 3,
      "text": "[wikiKBR] Wikipedia, \"Key-based routing\", 2013, <en.wikipedia.org/w/ index.php?title=Key-based_routing&oldid=543850833>.",
      "ja": "[wikiKBR] Wikipedia、「Key-based routing」、2013、<en.wikipedia.org/w/ index.php？title = Key-based_routing＆oldid = 543850833>。"
    },
    {
      "indent": 3,
      "text": "[wikiSkiplist] Wikipedia, \"Skip list\", 2013, <http://en.wikipedia.org/w/ index.php?title=Skip_list&oldid=551304213>.",
      "ja": "[wikiSkiplist] Wikipedia、「Skip list」、2013、<http://en.wikipedia.org/w/ index.php？title = Skip_list＆oldid = 551304213>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Routing Alternatives",
      "section_title": true,
      "ja": "付録A.代替ルーティング"
    },
    {
      "indent": 3,
      "text": "Significant discussion has been focused on the selection of a routing algorithm for P2PSIP. This section discusses the motivations for selecting symmetric recursive routing for RELOAD and describes the extensions that would be required to support additional routing algorithms.",
      "ja": "P2PSIPのルーティングアルゴリズムの選択に重点が置かれています。このセクションでは、RELOADの対称再帰ルーティングを選択する動機と、追加のルーティングアルゴリズムをサポートするために必要な拡張機能について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Iterative vs. Recursive",
      "section_title": true,
      "ja": "A.1. 反復対再帰"
    },
    {
      "indent": 3,
      "text": "Iterative routing has a number of advantages. It is easier to debug, consumes fewer resources on intermediate peers, and allows the querying peer to identify and route around misbehaving peers [non-transitive-dhts-worlds05]. However, in the presence of NATs, iterative routing is intolerably expensive, because a new connection must be established for each hop (using ICE) [bryan-design-hotp2p08].",
      "ja": "反復ルーティングには多くの利点があります。デバッグが容易で、中間ピアでのリソース消費が少なく、クエリを実行しているピアが、不正なピア[non-transitive-dhts-worlds05]を識別して迂回できるようにします。ただし、NATが存在する場合、（ICEを使用して）ホップごとに新しい接続を確立する必要があるため、反復ルーティングは耐えられないほど高価です[bryan-design-hotp2p08]。"
    },
    {
      "indent": 3,
      "text": "Iterative routing is supported through the RouteQuery mechanism and is primarily intended for debugging. It also allows the querying peer to evaluate the routing decisions made by the peers at each hop, consider alternatives, and perhaps detect at what point the forwarding path fails.",
      "ja": "反復ルーティングはRouteQueryメカニズムを通じてサポートされ、主にデバッグを目的としています。また、クエリを実行するピアが、各ホップでピアによって行われたルーティングの決定を評価し、代替案を検討し、おそらく転送パスが失敗するポイントを検出できます。"
    },
    {
      "indent": 0,
      "text": "A.2. Symmetric vs. Forward Response",
      "section_title": true,
      "ja": "A.2. 対称応答と転送応答"
    },
    {
      "indent": 3,
      "text": "An alternative to the symmetric recursive routing method used by RELOAD is forward-only routing, where the response is routed to the requester as if it were a new message initiated by the responder. (In the previous example, Z sends the response to A as if it were sending a request.) Forward-only routing requires no state in either the message or intermediate peers.",
      "ja": "RELOADが使用する対称再帰ルーティング方式の代替手段は、転送のみのルーティングです。この場合、応答は、応答側によって開始された新しいメッセージであるかのように要求側にルーティングされます。 （前の例では、Zは要求を送信しているかのようにAに応答を送信します。）転送のみのルーティングでは、メッセージピアまたは中間ピアで状態を必要としません。"
    },
    {
      "indent": 3,
      "text": "The drawback of forward-only routing is that it does not work when the overlay is unstable. For example, if A is in the process of joining the overlay and is sending a Join request to Z, it is not yet reachable via forward-only routing. Even if it is established in the overlay, if network failures produce temporary instability, A may not be reachable (and may be trying to stabilize its network connectivity via Attach messages).",
      "ja": "転送のみのルーティングの欠点は、オーバーレイが不安定な場合は機能しないことです。たとえば、Aがオーバーレイに参加している途中で、Join要求をZに送信している場合、順方向専用ルーティングではまだ到達できません。オーバーレイで確立されている場合でも、ネットワーク障害により一時的に不安定になると、Aに到達できない場合があります（接続メッセージを介してネットワーク接続を安定させようとしている可能性があります）。"
    },
    {
      "indent": 3,
      "text": "Furthermore, forward-only responses are less likely to reach the querying peer than symmetric recursive ones are, because the forward path is more likely to have a failed peer than is the request path (which was just tested to route the request) [non-transitive-dhts-worlds05].",
      "ja": "さらに、フォワードパスはリクエストパス（リクエストをルーティングするためにテストされたもの）よりもピアに障害が発生する可能性が高いため、フォワードのみのレスポンスは対称再帰よりもクエリピアに到達する可能性が低くなります。推移的dhts-worlds05]。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports forward-only routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use forward-only routing and when to fallback to symmetric routing, we have chosen not to include it as an option at this point.",
      "ja": "順方向専用ルーティングをサポートするがフォールバックとして対称応答に依存するRELOADの拡張は可能ですが、順方向専用ルーティングを使用するタイミングと対称ルーティングにフォールバックするタイミングを決定するのは複雑であるため、含めないことを選択しましたこの時点でオプションとして。"
    },
    {
      "indent": 0,
      "text": "A.3. Direct Response",
      "section_title": true,
      "ja": "A.3. ダイレクトレスポンス"
    },
    {
      "indent": 3,
      "text": "Another routing option is direct response routing, in which the response is returned directly to the querying node. In the previous example, if A encodes its IP address in the request, then Z can simply deliver the response directly to A. In the absence of NATs or other connectivity issues, this is the optimal routing technique.",
      "ja": "別のルーティングオプションは、ダイレクトレスポンスルーティングです。このルーティングでは、応答がクエリを実行しているノードに直接返されます。前の例では、Aが要求でIPアドレスをエンコードする場合、Zは単にAに直接応答を配信できます。NATまたはその他の接続の問題がない場合、これが最適なルーティング手法です。"
    },
    {
      "indent": 3,
      "text": "The challenge of implementing direct response routing is the presence of NATs. There are a number of complexities that must be addressed. In this discussion, we will continue our assumption that A issued the request and Z is generating the response.",
      "ja": "ダイレクトレスポンスルーティングの実装における課題は、NATの存在です。対処しなければならない複雑さがいくつかあります。この説明では、Aが要求を発行し、Zが応答を生成しているという仮定を続けます。"
    },
    {
      "indent": 3,
      "text": "o The IP address listed by A may be unreachable, either due to NAT or firewall rules. Therefore, a direct response technique must fallback to symmetric response [non-transitive-dhts-worlds05]. The hop-by-hop ACKs used by RELOAD allow Z to determine when A has received the message (and the TLS negotiation will provide earlier confirmation that A is reachable), but this fallback requires a timeout that will increase the response latency whenever A is not reachable from Z.",
      "ja": "o AでリストされたIPアドレスは、NATまたはファイアウォールルールにより、到達できない可能性があります。したがって、直接応答手法は対称応答[non-transitive-dhts-worlds05]にフォールバックする必要があります。 RELOADで使用されるホップバイホップACKにより、ZはAがメッセージを受信したことを確認できます（TLSネゴシエーションにより、Aが到達可能であることをより早く確認できます）。 Zから到達できません。"
    },
    {
      "indent": 3,
      "text": "o Whenever A is behind a NAT it, will have multiple candidate IP addresses, each of which must be advertised to ensure connectivity. Therefore, Z will need to attempt multiple connections to deliver the response.",
      "ja": "o AがNATの背後にある場合は常に、複数の候補IPアドレスがあり、接続を確実にするためにそれぞれをアドバタイズする必要があります。したがって、Zは応答を配信するために複数の接続を試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o One (or all) of A's candidate addresses may route from Z to a different device on the Internet. In the worst case, these nodes may actually be running RELOAD on the same port. Therefore, it is absolutely necessary to establish a secure connection to authenticate A before delivering the response. This step diminishes the efficiency of direct response routing, because multiple round-trips are required before the message can be delivered.",
      "ja": "o Aの候補アドレスの1つ（またはすべて）は、Zからインターネット上の別のデバイスにルーティングできます。最悪の場合、これらのノードは実際には同じポートでRELOADを実行している可能性があります。したがって、応答を配信する前に、Aを認証するための安全な接続を確立することが絶対に必要です。この手順では、メッセージを配信する前に複数のラウンドトリップが必要になるため、ダイレクトレスポンスルーティングの効率が低下します。"
    },
    {
      "indent": 0,
      "text": " o If A is behind a NAT and does not have a connection already established with Z, there are only two ways the direct response will work. The first is that A and Z must both be behind the same NAT, in which case the NAT is not involved. In the more common case, when Z is outside A's NAT, the response will be received only if A's NAT implements endpoint-independent filtering. As the choice of filtering mode conflates application transparency with security [RFC4787] and no clear recommendation is available, the prevalence of this feature in future devices remains unclear.",
      "ja": "o AがNATの背後にあり、Zとの接続がまだ確立されていない場合、直接応答が機能する方法は2つしかありません。 1つ目は、AとZの両方が同じNATの背後にある必要があることです。この場合、NATは関与しません。より一般的なケースでは、ZがAのNATの外部にある場合、応答は、AのNATがエンドポイントに依存しないフィルタリングを実装している場合にのみ受信されます。フィルタリングモードを選択すると、アプリケーションの透過性がセキュリティ[RFC4787]で満たされ、明確な推奨事項がないため、将来のデバイスでのこの機能の普及率は不明のままです。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports direct response routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use direct response routing and when to fallback to symmetric routing, and the reduced performance for responses to peers behind restrictive NATs, we have chosen not to include it as an option at this point.",
      "ja": "ダイレクトレスポンスルーティングをサポートするがフォールバックとして対称レスポンスに依存するRELOADの拡張は可能ですが、ダイレクトレスポンスルーティングを使用するタイミングと対称ルーティングにフォールバックするタイミングを決定する複雑さ、およびピアへのレスポンスのパフォーマンス低下が原因です。制限付きNATの背後にあるため、現時点ではそれをオプションとして含めないことを選択しました。"
    },
    {
      "indent": 0,
      "text": "A.4. Relay Peers",
      "section_title": true,
      "ja": "A.4. リレーピア"
    },
    {
      "indent": 3,
      "text": "[P2PSIP-RELAY] has proposed implementing a form of direct response by having A identify a peer, Q, that will be directly reachable by any other peer. A uses Attach to establish a connection with Q and advertises Q's IP address in the request sent to Z. Z sends the response to Q, which relays it to A. This then reduces the latency to two hops, and Z is negotiating a secure connection to Q.",
      "ja": "[P2PSIP-RELAY]は、Aが他のピアから直接到達可能なピアQを特定することにより、直接応答の形式を実装することを提案しています。 AはAttachを使用してQとの接続を確立し、Zに送信された要求でQのIPアドレスをアドバタイズします。Zは応答をQに送信し、Aに中継します。これにより、レイテンシが2ホップに短縮され、Zは安全な接続をネゴシエートしますQ."
    },
    {
      "indent": 3,
      "text": "This technique relies on the relative population of nodes such as A that require relay peers and peers such as Q that are capable of serving as a relay peer. It also requires nodes to be able to identify which category they are in. This identification problem has turned out to be hard to solve and is still an open area of exploration.",
      "ja": "この手法は、リレーピアを必要とするAなどのノードと、リレーピアとして機能するQなどのピアの相対的な数に依存しています。また、ノードがどのカテゴリに属しているかを特定できる必要もあります。この特定の問題は解決が困難であることが判明し、未だ調査の余地があります。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports relay peers is possible, but due to the complexities of implementing such an alternative, we have not added such a feature to RELOAD at this point.",
      "ja": "リレーピアをサポートするRELOADへの拡張は可能ですが、そのような代替手段の実装は複雑であるため、現時点ではRELOADにそのような機能を追加していません。"
    },
    {
      "indent": 3,
      "text": "A concept similar to relay peers, essentially choosing a relay peer at random, has previously been suggested to solve problems of pair-wise non-transitivity [non-transitive-dhts-worlds05], but deterministic filtering provided by NATs makes random relay peers no more likely to work than the responding peer.",
      "ja": "リレーピアと同様の概念、本質的にリレーピアをランダムに選択することは、ペアワイズ非推移性[non-transitive-dhts-worlds05]の問題を解決するために以前に提案されていますが、NATによって提供される決定論的フィルタリングはランダムリレーピアを応答するピアよりも動作する可能性が高くなります。"
    },
    {
      "indent": 0,
      "text": "A.5. Symmetric Route Stability",
      "section_title": true,
      "ja": "A.5. 対称ルートの安定性"
    },
    {
      "indent": 3,
      "text": "A common concern about symmetric recursive routing has been that one or more peers along the request path may fail before the response is received. The significance of this problem essentially depends on the response latency of the overlay. An overlay that produces slow responses will be vulnerable to churn, whereas responses that are delivered very quickly are vulnerable only to failures that occur over that small interval.",
      "ja": "対称再帰ルーティングに関する一般的な懸念は、要求パスに沿った1つ以上のピアが、応答を受信する前に失敗する可能性があることです。この問題の重要性は、基本的にオーバーレイの応答待ち時間に依存します。遅い応答を生成するオーバーレイはチャーンに対して脆弱ですが、非常に迅速に配信される応答は、その短い間隔で発生する障害に対してのみ脆弱です。"
    },
    {
      "indent": 3,
      "text": "The other aspect of this issue is whether the request itself can be successfully delivered. Assuming typical connection maintenance intervals, the time period between the last maintenance and the request being sent will be orders of magnitude greater than the delay between the request being forwarded and the response being received. Therefore, if the path was stable enough to be available to route the request, it is almost certainly going to remain available to route the response.",
      "ja": "この問題のもう1つの側面は、リクエスト自体を正常に配信できるかどうかです。通常の接続保守間隔を想定すると、最後の保守と送信される要求との間の期間は、転送される要求と受信される応答との間の遅延よりも桁違いに大きくなります。したがって、パスがリクエストのルーティングに利用できるほど安定していれば、ほぼ確実にレスポンスのルーティングに利用できます。"
    },
    {
      "indent": 3,
      "text": "An overlay that is unstable enough to suffer this type of failure frequently is unlikely to be able to support reliable functionality regardless of the routing mechanism. However, regardless of the stability of the return path, studies show that in the event of high churn, iterative routing is a better solution to ensure request completion [lookups-churn-p2p06] [non-transitive-dhts-worlds05]",
      "ja": "このタイプの障害が頻繁に発生するほど不安定なオーバーレイは、ルーティングメカニズムに関係なく、信頼性の高い機能をサポートできない可能性があります。ただし、リターンパスの安定性に関係なく、調査により、チャーンが多い場合は、反復ルーティングがリクエストの完了を確実にするための優れたソリューションであることが示されています[lookups-churn-p2p06] [non-transitive-dhts-worlds05]"
    },
    {
      "indent": 3,
      "text": "Finally, because RELOAD retries the end-to-end request, that retry will address the issues of churn that remain.",
      "ja": "Finally, because RELOAD retries the end-to-end request, that retry will address the issues of churn that remain."
    },
    {
      "indent": 0,
      "text": "Appendix B. Why Clients?",
      "ja": "付録B.なぜクライアントなのか？"
    },
    {
      "indent": 3,
      "text": "There are a wide variety of reasons a node may act as a client rather than as a peer. This section outlines some of those scenarios and how the client's behavior changes based on its capabilities.",
      "ja": "ノードがピアとしてではなくクライアントとして機能する理由はさまざまです。このセクションでは、これらのシナリオのいくつかと、クライアントの動作がその機能に基づいてどのように変化するかについて概説します。"
    },
    {
      "indent": 0,
      "text": "B.1. Why Not Only Peers?",
      "section_title": true,
      "ja": "B.1. なぜピアだけではないのですか？"
    },
    {
      "indent": 3,
      "text": "For a number of reasons, a particular node may be forced to act as a client even though it is willing to act as a peer. These include:",
      "ja": "いくつかの理由により、特定のノードがピアとして動作することをいとわない場合でも、クライアントとして動作するように強制される場合があります。これらは以下を含みます："
    },
    {
      "indent": 3,
      "text": "o The node does not have appropriate network connectivity, typically because it has a low-bandwidth network connection.",
      "ja": "o ノードには適切なネットワーク接続がありません。これは通常、帯域幅が狭いネットワーク接続があるためです。"
    },
    {
      "indent": 3,
      "text": "o The node may not have sufficient resources, such as computing power, storage space, or battery power.",
      "ja": "o ノードには、コンピューティング能力、ストレージスペース、バッテリ電力などの十分なリソースがない可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The overlay algorithm may dictate specific requirements for peer selection. These may include participating in the overlay to determine trustworthiness, controlling the number of peers in the overlay to reduce overly long routing paths, and ensuring minimum application uptime before a node can join as a peer.",
      "ja": "o オーバーレイアルゴリズムによって、ピアの選択に関する特定の要件が決まる場合があります。これらには、信頼性を決定するためのオーバーレイへの参加、過度に長いルーティングパスを削減するためのオーバーレイ内のピアの数の制御、ノードがピアとして参加する前のアプリケーションの稼働時間の最小化などがあります。"
    },
    {
      "indent": 0,
      "text": " The ultimate criteria for a node to become a peer are determined by the overlay algorithm and specific deployment. A node acting as a client that has a full implementation of RELOAD and the appropriate overlay algorithm is capable of locating its responsible peer in the overlay and using Attach to establish a direct connection to that peer. In that way, it may elect to be reachable under either of the routing approaches listed above. Particularly for overlay algorithms that elect nodes to serve as peers based on trustworthiness or population, the overlay algorithm may require such a client to locate itself at a particular place in the overlay.",
      "ja": "ノードがピアになるための最終的な基準は、オーバーレイアルゴリズムと特定の展開によって決定されます。 RELOADの完全な実装と適切なオーバーレイアルゴリズムを持つクライアントとして機能するノードは、オーバーレイで責任のあるピアを特定し、アタッチを使用してそのピアへの直接接続を確立できます。このようにして、上記のルーティングアプローチのいずれかで到達可能にすることができます。特に、信頼性または母集団に基づいてピアとして機能するノードを選択するオーバーレイアルゴリズムの場合、オーバーレイアルゴリズムでは、そのようなクライアントがオーバーレイ内の特定の場所にいることを要求する場合があります。"
    },
    {
      "indent": 0,
      "text": "B.2. Clients as Application-Level Agents",
      "section_title": true,
      "ja": "B.2. アプリケーションレベルのエージェントとしてのクライアント"
    },
    {
      "indent": 3,
      "text": "SIP defines an extensive protocol for registration and security between a client and its registrar/proxy server(s). Any SIP device can act as a client of a RELOAD-based P2PSIP overlay if it contacts a peer that implements the server-side functionality required by the SIP protocol. In this case, the peer would be acting as if it were the user's peer and would need the appropriate credentials for that user.",
      "ja": "SIPは、クライアントとそのレジストラ/プロキシサーバー間の登録とセキュリティのための広範なプロトコルを定義します。 SIPプロトコルが必要とするサーバー側の機能を実装するピアと通信するSIPデバイスは、RELOADベースのP2PSIPオーバーレイのクライアントとして機能できます。この場合、ピアはユーザーのピアであるかのように動作し、そのユーザーに適切な資格情報が必要になります。"
    },
    {
      "indent": 3,
      "text": "Application-level support for clients is defined by a usage. A usage offering support for application-level clients should specify how the security of the system is maintained when the data is moved between the application and RELOAD layers.",
      "ja": "クライアントに対するアプリケーションレベルのサポートは、使用法によって定義されます。アプリケーションレベルのクライアントのサポートを提供する使用法では、アプリケーション層とRELOAD層の間でデータを移動するときに、システムのセキュリティを維持する方法を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Cullen Jennings Cisco 400 3rd Avenue SW, Suite 350 Calgary Canada",
      "ja": "カレンジェニングスCisco 400 3rd Avenue SW、Suite 350 Calgary Canada"
    },
    {
      "indent": 3,
      "text": "EMail: fluffy@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bruce B. Lowekamp (editor) Skype Palo Alto, CA USA",
      "ja": "Bruce B. Lowekamp（editor）Skype Palo Alto、CA USA"
    },
    {
      "indent": 3,
      "text": "EMail: bbl@lowekamp.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA",
      "ja": "Eric Rescorla RTFM、Inc. 2064 Edgewood Drive Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 678 2350\nEMail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Salman A. Baset Columbia University 1214 Amsterdam Avenue New York, NY USA",
      "ja": "サルマンA.バセットコロンビア大学1214アムステルダムアベニューニューヨーク、ニューヨークアメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "EMail: salman@cs.columbia.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY USA",
      "ja": "Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY USA"
    },
    {
      "indent": 3,
      "text": "EMail: hgs@cs.columbia.edu",
      "raw": true,
      "ja": ""
    }
  ]
}