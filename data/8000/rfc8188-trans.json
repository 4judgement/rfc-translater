{
  "title": {
    "text": "RFC 8188 - Encrypted Content-Encoding for HTTP",
    "ja": "RFC 8188 - HTTPの暗号化されたコンテンツエンコーディング"
  },
  "number": 8188,
  "created_at": "2020-08-28 15:38:53.007760+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        M. Thomson\nRequest for Comments: 8188                                       Mozilla\nCategory: Standards Track                                      June 2017\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Encrypted Content-Encoding for HTTP",
      "ja": "HTTPの暗号化されたコンテンツエンコーディング"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This memo introduces a content coding for HTTP that allows message payloads to be encrypted.",
      "ja": "このメモは、メッセージペイロードの暗号化を可能にするHTTPのコンテンツコーディングを紹介しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8188.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8188で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3\n2.  The \"aes128gcm\" HTTP Content Coding . . . . . . . . . . . . .   3\n  2.1.  Encryption Content-Coding Header  . . . . . . . . . . . .   5\n  2.2.  Content-Encryption Key Derivation . . . . . . . . . . . .   6\n  2.3.  Nonce Derivation  . . . . . . . . . . . . . . . . . . . .   6\n3.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.1.  Encryption of a Response  . . . . . . . . . . . . . . . .   7\n  3.2.  Encryption with Multiple Records  . . . . . . . . . . . .   8\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .   8\n  4.1.  Automatic Decryption  . . . . . . . . . . . . . . . . . .   9\n  4.2.  Message Truncation  . . . . . . . . . . . . . . . . . . .   9\n  4.3.  Key and Nonce Reuse . . . . . . . . . . . . . . . . . . .   9\n  4.4.  Data Encryption Limits  . . . . . . . . . . . . . . . . .  10\n  4.5.  Content Integrity . . . . . . . . . . . . . . . . . . . .  10\n  4.6.  Leaking Information in Header Fields  . . . . . . . . . .  10\n  4.7.  Poisoning Storage . . . . . . . . . . . . . . . . . . . .  11\n  4.8.  Sizing and Timing Attacks . . . . . . . . . . . . . . . .  11\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12\n  5.1.  The \"aes128gcm\" HTTP Content Coding . . . . . . . . . . .  12\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  12\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  13\nAppendix A.  JWE Mapping  . . . . . . . . . . . . . . . . . . . .  15\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  16\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "It is sometimes desirable to encrypt the contents of an HTTP message (request or response) so that when the payload is stored (e.g., with an HTTP PUT), only someone with the appropriate key can read it.",
      "ja": "ペイロードが格納されると（たとえば、HTTP PUTを使用して）、適切なキーを持つ人だけがそれを読み取ることができるように、HTTPメッセージ（要求または応答）の内容を暗号化することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, it might be necessary to store a file on a server without exposing its contents to that server. Furthermore, that same file could be replicated to other servers (to make it more resistant to server or network failure), downloaded by clients (to make it available offline), etc., without exposing its contents.",
      "ja": "たとえば、コンテンツをサーバーに公開せずにサーバーにファイルを保存する必要がある場合があります。さらに、コンテンツを公開せずに、同じファイルを他のサーバーに複製したり（サーバーやネットワークの障害に対する耐性を高めたり）、クライアントがダウンロードしたり（オフラインで利用できるようにするなど）したりできます。"
    },
    {
      "indent": 3,
      "text": "These uses are not met by the use of Transport Layer Security (TLS) [RFC5246], since it only encrypts the channel between the client and server.",
      "ja": "クライアントとサーバー間のチャネルを暗号化するだけなので、これらの使用はトランスポート層セキュリティ（TLS）[RFC5246]の使用では満たされません。"
    },
    {
      "indent": 3,
      "text": "This document specifies a content coding (see Section 3.1.2 of [RFC7231]) for HTTP to serve these and other use cases.",
      "ja": "このドキュメントでは、これらの使用例やその他の使用例に対応するHTTPのコンテンツコーディング（[RFC7231]のセクション3.1.2を参照）を指定しています。"
    },
    {
      "indent": 3,
      "text": "This content coding is not a direct adaptation of message-based encryption formats -- such as those that are described by [RFC4880], [RFC5652], [RFC7516], and [XMLENC]. Those formats are not suited to stream processing, which is necessary for HTTP. The format described here follows more closely to the lower-level constructs described in [RFC5116].",
      "ja": "このコンテンツコーディングは、[RFC4880]、[RFC5652]、[RFC7516]、および[XMLENC]で記述されているようなメッセージベースの暗号化形式を直接適応したものではありません。これらの形式は、HTTPに必要なストリーム処理には適していません。ここで説明する形式は、[RFC5116]で説明されている下位レベルの構成に、より厳密に従っています。"
    },
    {
      "indent": 3,
      "text": "To the extent that message-based encryption formats use the same primitives, the format can be considered to be a sequence of encrypted messages with a particular profile. For instance, Appendix A explains how the format is congruent with a sequence of JSON Web Encryption [RFC7516] values with a fixed header.",
      "ja": "メッセージベースの暗号化フォーマットが同じプリミティブを使用する限り、このフォーマットは、特定のプロファイルを持つ暗号化されたメッセージのシーケンスと見なすことができます。たとえば、付録Aでは、フォーマットが、固定ヘッダーを持つ一連のJSON Web Encryption [RFC7516]値とどのように一致するかを説明しています。"
    },
    {
      "indent": 3,
      "text": "This mechanism is likely only a small part of a larger design that uses content encryption. How clients and servers acquire and identify keys will depend on the use case. In particular, a key management system is not described.",
      "ja": "このメカニズムは、おそらくコンテンツの暗号化を使用する大規模な設計のほんの一部にすぎません。クライアントとサーバーがキーを取得して識別する方法は、ユースケースによって異なります。特に、鍵管理システムは記述されていない。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The \"aes128gcm\" HTTP Content Coding",
      "section_title": true,
      "ja": "2. 「aes128gcm」HTTPコンテンツコーディング"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" HTTP content coding indicates that a payload has been encrypted using Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM) as identified as AEAD_AES_128_GCM in [RFC5116], Section 5.1. The AEAD_AES_128_GCM algorithm uses a 128-bit content-encryption key.",
      "ja": "「aes128gcm」HTTPコンテンツコーディングは、ペイロードがGalois / Counter Mode（GCM）のAdvanced Encryption Standard（AES）を使用して暗号化され、[RFC5116]のセクション5.1でAEAD_AES_128_GCMとして識別されていることを示します。 AEAD_AES_128_GCMアルゴリズムは、128ビットのコンテンツ暗号化キーを使用します。"
    },
    {
      "indent": 3,
      "text": "Using this content coding requires knowledge of a key. How this key is acquired is not defined in this document.",
      "ja": "このコンテンツコーディングを使用するには、キーの知識が必要です。このドキュメントでは、このキーの取得方法は定義されていません。"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding uses a single fixed set of encryption primitives. Cipher agility is achieved by defining a new content-coding scheme. This ensures that only the HTTP Accept-Encoding header field is necessary to negotiate the use of encryption.",
      "ja": "「aes128gcm」コンテンツコーディングは、暗号化プリミティブの単一の固定セットを使用します。暗号の俊敏性は、新しいコンテンツコーディングスキームを定義することによって実現されます。これにより、暗号化の使用をネゴシエートするために必要なのは、HTTP Accept-Encodingヘッダーフィールドのみです。"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding uses a fixed record size. The final encoding consists of a header (see Section 2.1) and zero or more fixed-size encrypted records; the final record can be smaller than the record size.",
      "ja": "「aes128gcm」コンテンツコーディングは、固定レコードサイズを使用します。最終的なエンコードは、ヘッダー（セクション2.1を参照）と0個以上の固定サイズの暗号化レコードで構成されます。最終レコードは、レコードサイズよりも小さい場合があります。"
    },
    {
      "indent": 3,
      "text": "The record size determines the length of each portion of plaintext that is enciphered. The record size (\"rs\") is included in the content-coding header (see Section 2.1).",
      "ja": "レコードサイズによって、暗号化されるプレーンテキストの各部分の長さが決まります。レコードサイズ（ \"rs\"）はcontent-codingヘッダーに含まれています（セクション2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "+-----------+             content\n|   data    |             any length up to rs-17 octets\n+-----------+\n     |\n     v\n+-----------+-----+       add a delimiter octet (0x01 or 0x02)\n|   data    | pad |       then 0x00-valued octets to rs-16\n+-----------+-----+       (or less on the last record)\n         |\n         v\n+--------------------+    encrypt with AEAD_AES_128_GCM;\n|    ciphertext      |    final size is rs;\n+--------------------+    the last record can be smaller",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AEAD_AES_128_GCM produces ciphertext 16 octets longer than its input plaintext. Therefore, the unencrypted content of each record is shorter than the record size by 16 octets. Valid records always contain at least a padding delimiter octet and a 16-octet authentication tag.",
      "ja": "AEAD_AES_128_GCMは、入力平文よりも16オクテット長い暗号文を生成します。したがって、各レコードの暗号化されていないコンテンツは、レコードサイズよりも16オクテット短いです。有効なレコードには、常に少なくともパディング区切りオクテットと16オクテット認証タグが含まれています。"
    },
    {
      "indent": 3,
      "text": "Each record contains a single padding delimiter octet followed by any number of zero octets. The last record uses a padding delimiter octet set to the value 2, all other records have a padding delimiter octet value of 1.",
      "ja": "各レコードには、1つのパディング区切りオクテットとそれに続く任意の数のゼロオクテットが含まれます。最後のレコードは、値2に設定されたパディング区切りオクテットを使用します。他のすべてのレコードは、パディング区切りオクテット値1を持っています。"
    },
    {
      "indent": 3,
      "text": "On decryption, the padding delimiter is the last non-zero-valued octet of the record. A decrypter MUST fail if the record contains no non-zero octet. A decrypter MUST fail if the last record contains a padding delimiter with a value other than 2 or if any record other than the last contains a padding delimiter with a value other than 1.",
      "ja": "復号化では、パディング区切り文字は、レコードの最後の非ゼロ値オクテットです。レコードにゼロ以外のオクテットが含まれていない場合、復号化は失敗する必要があります。最後のレコードに2以外の値のパディング区切り文字が含まれている場合、または最後のレコード以外のレコードに1以外の値のパディング区切り文字が含まれている場合、復号化プログラムは失敗する必要があります。"
    },
    {
      "indent": 3,
      "text": "The nonce for each record is a 96-bit value constructed from the record sequence number and the input-keying material. Nonce derivation is covered in Section 2.3.",
      "ja": "各レコードのナンスは、レコードシーケンス番号と入力キーマテリアルから構成される96ビット値です。ノンス導出については、セクション2.3で説明しています。"
    },
    {
      "indent": 3,
      "text": "The additional data passed to each invocation of AEAD_AES_128_GCM is a zero-length octet sequence.",
      "ja": "AEAD_AES_128_GCMの各呼び出しに渡される追加データは、長さがゼロのオクテットシーケンスです。"
    },
    {
      "indent": 0,
      "text": " A consequence of this record structure is that range requests [RFC7233] and random access to encrypted payload bodies are possible at the granularity of the record size. Partial records at the ends of a range cannot be decrypted. Thus, it is best if range requests start and end on record boundaries. However, note that random access to specific parts of encrypted data could be confounded by the presence of padding.",
      "ja": "このレコード構造の結果は、範囲要求[RFC7233]と暗号化されたペイロード本体へのランダムアクセスがレコードサイズの粒度で可能になることです。範囲の末尾にある部分的なレコードは復号化できません。したがって、範囲リクエストはレコード境界で開始および終了するのが最適です。ただし、暗号化されたデータの特定の部分へのランダムアクセスは、パディングの存在によって混乱する可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Selecting the record size most appropriate for a given situation requires a trade-off. A smaller record size allows decrypted octets to be released more rapidly, which can be appropriate for applications that depend on responsiveness. Smaller records also reduce the additional data required if random access into the ciphertext is needed.",
      "ja": "特定の状況に最も適したレコードサイズを選択するには、トレードオフが必要です。レコードサイズが小さいほど、復号化されたオクテットがより速く解放されます。これは、応答性に依存するアプリケーションに適しています。レコードが小さいほど、暗号文へのランダムアクセスが必要な場合に必要な追加データも削減されます。"
    },
    {
      "indent": 3,
      "text": "Applications that don't depend on streaming, random access, or arbitrary padding can use larger records, or even a single record. A larger record size reduces processing and data overheads.",
      "ja": "ストリーミング、ランダムアクセス、または任意のパディングに依存しないアプリケーションは、より大きなレコードを使用することも、単一のレコードを使用することもできます。レコードサイズが大きいほど、処理とデータのオーバーヘッドが減少します。"
    },
    {
      "indent": 0,
      "text": "2.1. Encryption Content-Coding Header",
      "section_title": true,
      "ja": "2.1. 暗号化コンテンツコーディングヘッダー"
    },
    {
      "indent": 3,
      "text": "The content coding uses a header block that includes all parameters needed to decrypt the content (other than the key). The header block is placed in the body of a message ahead of the sequence of records.",
      "ja": "コンテンツコーディングでは、コンテンツの復号化に必要なすべてのパラメーター（キー以外）を含むヘッダーブロックを使用します。ヘッダーブロックは、一連のレコードの前のメッセージの本文に配置されます。"
    },
    {
      "indent": 3,
      "text": "+-----------+--------+-----------+---------------+\n| salt (16) | rs (4) | idlen (1) | keyid (idlen) |\n+-----------+--------+-----------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "salt: The \"salt\" parameter comprises the first 16 octets of the \"aes128gcm\" content-coding header. The same \"salt\" parameter value MUST NOT be reused for two different payload bodies that have the same input-keying material; generating a random salt for every application of the content coding ensures that content-encryption key reuse is highly unlikely.",
      "ja": "salt：「salt」パラメータは、「aes128gcm」コンテンツコーディングヘッダーの最初の16オクテットで構成されます。同じ「salt」パラメータ値は、同じ入力キーイングマテリアルを持つ2つの異なるペイロード本体に再利用してはなりません（MUST NOT）。コンテンツコーディングのアプリケーションごとにランダムなソルトを生成することで、コンテンツ暗号化キーの再利用が非常に起こりにくくなります。"
    },
    {
      "indent": 3,
      "text": "rs: The \"rs\" or record size parameter contains an unsigned 32-bit integer in network byte order that describes the record size in octets. Note that it is, therefore, impossible to exceed the 2^36-31 limit on plaintext input to AEAD_AES_128_GCM. Values smaller than 18 are invalid.",
      "ja": "rs：「rs」またはレコードサイズパラメーターには、レコードサイズをオクテットで表すネットワークバイトオーダーの符号なし32ビット整数が含まれます。したがって、AEAD_AES_128_GCMへのプレーンテキスト入力の2 ^ 36-31制限を超えることは不可能であることに注意してください。 18より小さい値は無効です。"
    },
    {
      "indent": 3,
      "text": "idlen: The \"idlen\" parameter is an unsigned 8-bit integer that defines the length of the \"keyid\" parameter.",
      "ja": "idlen：「idlen」パラメーターは、「keyid」パラメーターの長さを定義する符号なし8ビット整数です。"
    },
    {
      "indent": 3,
      "text": "keyid: The \"keyid\" parameter can be used to identify the keying material that is used. This field is the length determined by the \"idlen\" parameter. Recipients that receive a message are expected to know how to retrieve keys; the \"keyid\" parameter might be input to that process. A \"keyid\" parameter SHOULD be a UTF-8-encoded [RFC3629] string, particularly where the identifier might need to be rendered in a textual form.",
      "ja": "keyid：「keyid」パラメーターを使用して、使用される鍵情報を識別できます。このフィールドは、「idlen」パラメーターによって決定される長さです。メッセージを受信する受信者は、キーを取得する方法を知っている必要があります。 「keyid」パラメータがそのプロセスに入力される可能性があります。 「keyid」パラメータは、特に識別子をテキスト形式でレンダリングする必要がある場合は、UTF-8エンコード[RFC3629]文字列にする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.2. Content-Encryption Key Derivation",
      "section_title": true,
      "ja": "2.2. コンテンツ暗号化キーの導出"
    },
    {
      "indent": 3,
      "text": "In order to allow the reuse of keying material for multiple different HTTP messages, a content-encryption key is derived for each message. The content-encryption key is derived from the \"salt\" parameter using the HMAC-based key derivation function (HKDF) described in [RFC5869] using the SHA-256 hash algorithm [FIPS180-4].",
      "ja": "複数の異なるHTTPメッセージでキー情報を再利用できるようにするために、メッセージごとにコンテンツ暗号化キーが生成されます。コンテンツ暗号化キーは、SHA-256ハッシュアルゴリズム[FIPS180-4]を使用して[RFC5869]で説明されているHMACベースのキー導出関数（HKDF）を使用して、「塩」パラメーターから導出されます。"
    },
    {
      "indent": 3,
      "text": "The value of the \"salt\" parameter is the salt input to the HKDF. The keying material identified by the \"keyid\" parameter is the input-keying material (IKM) to HKDF. Input-keying material is expected to be provided to recipients separately. The extract phase of HKDF, therefore, produces a pseudorandom key (PRK) as follows:",
      "ja": "「salt」パラメーターの値は、HKDFへのソルト入力です。 「keyid」パラメーターで識別される鍵素材は、HKDFへの入力鍵素材（IKM）です。入力キーの資料は、受信者に個別に提供されることが期待されています。したがって、HKDFの抽出フェーズでは、次のように擬似ランダムキー（PRK）が生成されます。"
    },
    {
      "indent": 6,
      "text": "PRK = HMAC-SHA-256 (salt, IKM)",
      "ja": "PRK = HMAC-SHA-256（塩、IKM）"
    },
    {
      "indent": 3,
      "text": "The info parameter to HKDF is set to the ASCII-encoded string \"Content-Encoding: aes128gcm\" and a single zero octet:",
      "ja": "HKDFへのinfoパラメータは、ASCIIエンコードされた文字列 \"Content-Encoding：aes128gcm\"と1つのゼロオクテットに設定されます。"
    },
    {
      "indent": 6,
      "text": "cek_info = \"Content-Encoding: aes128gcm\" || 0x00",
      "ja": "cek_info = \"Content-Encoding：aes128gcm\" || 0x00"
    },
    {
      "indent": 3,
      "text": "Note(1): Concatenation of octet sequences is represented by the \"||\" operator.",
      "ja": "注（1）：オクテットシーケンスの連結は「||」で表されますオペレーター。"
    },
    {
      "indent": 3,
      "text": "Note(2): The strings used here and in Section 2.3 do not include a terminating 0x00 octet, as is used in some programming languages.",
      "ja": "注（2）：ここおよびセクション2.3で使用されている文字列には、一部のプログラミング言語で使用されているような、終了0x00オクテットは含まれていません。"
    },
    {
      "indent": 3,
      "text": "AEAD_AES_128_GCM requires a 16-octet (128-bit) content-encryption key (CEK), so the length (L) parameter to HKDF is 16. The second step of HKDF can, therefore, be simplified to the first 16 octets of a single HMAC:",
      "ja": "AEAD_AES_128_GCMには16オクテット（128ビット）のコンテンツ暗号化キー（CEK）が必要なので、HKDFへの長さ（L）パラメーターは16です。したがって、HKDFの2番目のステップは、単一の最初の16オクテットに簡略化できます。 HMAC："
    },
    {
      "indent": 6,
      "text": "CEK = HMAC-SHA-256(PRK, cek_info || 0x01)",
      "ja": "CEK = HMAC-SHA-256（PRK、check_info || 0x01）"
    },
    {
      "indent": 0,
      "text": "2.3. Nonce Derivation",
      "section_title": true,
      "ja": "2.3. ノンス派生"
    },
    {
      "indent": 3,
      "text": "The nonce input to AEAD_AES_128_GCM is constructed for each record. The nonce for each record is a 12-octet (96-bit) value that is derived from the record sequence number, input-keying material, and \"salt\" parameter.",
      "ja": "AEAD_AES_128_GCMへのノンス入力は、レコードごとに作成されます。各レコードのナンスは、レコードシーケンス番号、入力キーマテリアル、および「ソルト」パラメーターから派生した12オクテット（96ビット）の値です。"
    },
    {
      "indent": 3,
      "text": "The input-keying material and \"salt\" parameter are input to HKDF with different info and length (L) parameters.",
      "ja": "入力キーマテリアルと「塩」パラメータは、異なる情報と長さ（L）パラメータを使用してHKDFに入力されます。"
    },
    {
      "indent": 3,
      "text": "The length (L) parameter is 12 octets. The info parameter for the nonce is the ASCII-encoded string \"Content-Encoding: nonce\", terminated by a single zero octet:",
      "ja": "長さ（L）パラメータは12オクテットです。 nonceのinfoパラメーターは、1つのゼロオクテットで終了する、ASCIIエンコードされた文字列 \"Content-Encoding：nonce\"です。"
    },
    {
      "indent": 6,
      "text": "nonce_info = \"Content-Encoding: nonce\" || 0x00",
      "ja": "nonce_info = \"Content-Encoding：nonce\" || 0x00"
    },
    {
      "indent": 3,
      "text": "The result is combined with the record sequence number -- using exclusive or -- to produce the nonce. The record sequence number (SEQ) is a 96-bit unsigned integer in network byte order that starts at zero.",
      "ja": "結果はレコードのシーケンス番号と組み合わせられます-排他的論理和を使用して-ナンスを生成します。レコードシーケンス番号（SEQ）は、ゼロから始まるネットワークバイトオーダーの96ビット符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "Thus, the final nonce for each record is a 12-octet value:",
      "ja": "したがって、各レコードの最後のノンスは12オクテットの値です。"
    },
    {
      "indent": 6,
      "text": "NONCE = HMAC-SHA-256(PRK, nonce_info || 0x01) XOR SEQ",
      "ja": "NONCE = HMAC-SHA-256（PRK、nonce_info || 0x01）XOR SEQ"
    },
    {
      "indent": 3,
      "text": "This nonce construction prevents removal or reordering of records.",
      "ja": "このノンス構造は、レコードの削除または並べ替えを防ぎます。"
    },
    {
      "indent": 0,
      "text": "3. Examples",
      "section_title": true,
      "ja": "3. 例"
    },
    {
      "indent": 3,
      "text": "This section shows a few examples of the encrypted-content coding.",
      "ja": "このセクションでは、暗号化されたコンテンツのコーディングの例をいくつか示します。"
    },
    {
      "indent": 3,
      "text": "Note: All binary values in the examples in this section use base64 encoding with URL and filename safe alphabet [RFC4648]. This includes the bodies of requests. Whitespace and line wrapping is added to fit formatting constraints.",
      "ja": "注：このセクションの例のすべてのバイナリ値は、URLとファイル名セーフアルファベット[RFC4648]を使用したbase64エンコーディングを使用しています。これにはリクエストの本文が含まれます。書式の制約に合わせて、空白と行の折り返しが追加されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Encryption of a Response",
      "section_title": true,
      "ja": "3.1. 応答の暗号化"
    },
    {
      "indent": 3,
      "text": "Here, a successful HTTP GET response has been encrypted. This uses a record size of 4096 octets and no padding (just the single-octet padding delimiter), so only a partial record is present. The input-keying material is identified by an empty string (that is, the \"keyid\" field in the header is zero octets in length).",
      "ja": "ここでは、成功したHTTP GET応答が暗号化されています。これは、4096オクテットのレコードサイズとパディングなし（単一オクテットのパディング区切り文字のみ）を使用するため、部分的なレコードのみが存在します。入力キー情報は空の文字列で識別されます（つまり、ヘッダーの「keyid」フィールドは長さが0オクテットです）。"
    },
    {
      "indent": 3,
      "text": "The encrypted data in this example is the UTF-8-encoded string \"I am the walrus\". The input-keying material is the value \"yqdlZ-tYemfogSmv7Ws5PQ\" (in base64url). The 54-octet content body contains a single record and is shown here using 71 base64url characters for presentation reasons.",
      "ja": "この例の暗号化されたデータは、UTF-8でエンコードされた文字列「I am the walrus」です。入力キーの素材は、「yqdlZ-tYemfogSmv7Ws5PQ」という値です（base64url内）。 54オクテットのコンテンツ本文には単一のレコードが含まれており、ここでは表示上の理由から71のbase64url文字を使用して示されています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Content-Type: application/octet-stream Content-Length: 54 Content-Encoding: aes128gcm",
      "ja": "HTTP / 1.1 200 OK Content-Type：application / octet-stream Content-Length：54 Content-Encoding：aes128gcm"
    },
    {
      "indent": 0,
      "text": " I1BsxtFttlv3u_Oo94xnmwAAEAAA-NAVub2qFgBEuQKRapoZu-IxkIva3MEB1PD-ly8Thjg Note that the media type has been changed to \"application/octet-stream\" to avoid exposing information about the content. Alternatively (and equivalently), the Content-Type header field can be omitted.",
      "ja": "I1BsxtFttlv3u_Oo94xnmwAAEAAA-NAVub2qFgBEuQKRapoZu-IxkIva3MEB1PD-ly8Thjgメディアタイプが「application / octet-stream」に変更され、コンテンツに関する情報が公開されないようになっていることに注意してください。代わりに（そして同等に）、Content-Typeヘッダーフィールドを省略できます。"
    },
    {
      "indent": 3,
      "text": "Intermediate values for this example (all shown using base64url):",
      "ja": "この例の中間値（すべてbase64urlを使用して示されています）："
    },
    {
      "indent": 3,
      "text": "salt (from header) = I1BsxtFttlv3u_Oo94xnmw PRK = zyeH5phsIsgUyd4oiSEIy35x-gIi4aM7y0hCF8mwn9g CEK = _wniytB-ofscZDh4tbSjHw NONCE = Bcs8gkIRKLI8GeI8 unencrypted data = SSBhbSB0aGUgd2FscnVzAg",
      "ja": "ヘッダー（ヘッダーから）= I1BsxtFttlv3u_Oo94xnmw PRK = zyeH5phsIsgUyd4oiSEIy35x-gIi4aM7y0hCF8mwn9g CEK = _wniytB-ofscZDh4tbSjHw NONCE = Bcs8gkbgbsggbsggbbgbggbsbgbgbggbsbggbsbggbsbggbsbgbgbgbgbggbsbggbsbggbsbggbsbggbsbggbb"
    },
    {
      "indent": 0,
      "text": "3.2. Encryption with Multiple Records",
      "section_title": true,
      "ja": "3.2. 複数のレコードによる暗号化"
    },
    {
      "indent": 3,
      "text": "This example shows the same message with input-keying material of \"BO3ZVPxUlnLORbVGMpbT1Q\". In this example, the plaintext is split into records of 25 octets each (that is, the \"rs\" field in the header is 25). The first record includes one 0x00 padding octet. This means that there are 7 octets of message in the first record and 8 in the second. A key identifier of the UTF-8-encoded string \"a1\" is also included in the header.",
      "ja": "この例は、「BO3ZVPxUlnLORbVGMpbT1Q」の入力キー情報を持つ同じメッセージを示しています。この例では、平文はそれぞれ25オクテットのレコードに分割されます（つまり、ヘッダーの「rs」フィールドは25です）。最初のレコードには、1つの0x00パディングオクテットが含まれています。つまり、最初のレコードには7オクテット、2番目のレコードには8オクテットあります。ヘッダーには、UTF-8でエンコードされた文字列「a1」のキー識別子も含まれています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Content-Length: 73 Content-Encoding: aes128gcm",
      "ja": "HTTP / 1.1 200 OK Content-Length：73 Content-Encoding：aes128gcm"
    },
    {
      "indent": 3,
      "text": "uNCkWiNYzKTnBN9ji3-qWAAAABkCYTHOG8chz_gnvgOqdGYovxyjuqRyJFjEDyoF 1Fvkj6hQPdPHI51OEUKEpgz3SsLWIqS_uA",
      "ja": "uNCkWiNYzKTnBN9ji3-qWAAAABkCYTHOG8chz_gnvgOqdGYovxyjuqRyJFjEDyoF 1Fvkj6hQPdPHI51OEUKEpgz3SsLWIqS_uA"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This mechanism assumes the presence of a key management framework that is used to manage the distribution of keys between valid senders and receivers. Defining key management is part of composing this mechanism into a larger application, protocol, or framework.",
      "ja": "このメカニズムは、有効な送信者と受信者間のキーの配布を管理するために使用されるキー管理フレームワークの存在を前提としています。キー管理の定義は、このメカニズムをより大きなアプリケーション、プロトコル、またはフレームワークに構成することの一部です。"
    },
    {
      "indent": 3,
      "text": "Implementation of cryptography -- and key management in particular -- can be difficult. For instance, implementations need to account for the potential for exposing keying material on side channels, such as might be exposed by the time it takes to perform a given operation. The requirements for a good implementation of cryptographic algorithms can change over time.",
      "ja": "暗号化の実装、特にキー管理は難しい場合があります。たとえば、実装は、特定の操作を実行するのにかかる時間によって公開される可能性があるような、サイドチャネルでキーイング情報を公開する可能性を考慮する必要があります。暗号化アルゴリズムを適切に実装するための要件は、時間とともに変化する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Automatic Decryption",
      "section_title": true,
      "ja": "4.1. 自動解読"
    },
    {
      "indent": 3,
      "text": "As a content coding, a \"aes128gcm\" content coding might be automatically removed by a receiver in a way that is not obvious to the ultimate consumer of a message. Recipients that depend on content-origin authentication using this mechanism MUST reject messages that don't include the \"aes128gcm\" content coding.",
      "ja": "コンテンツコーディングとして、「aes128gcm」コンテンツコーディングは、メッセージの最終的なコンシューマーには明らかではない方法で、受信者によって自動的に削除される場合があります。このメカニズムを使用するコンテンツオリジン認証に依存する受信者は、「aes128gcm」コンテンツコーディングを含まないメッセージを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Truncation",
      "section_title": true,
      "ja": "4.2. メッセージの切り捨て"
    },
    {
      "indent": 3,
      "text": "This content encoding is designed to permit the incremental processing of large messages. It also permits random access to plaintext in a limited fashion. The content encoding permits a receiver to detect when a message is truncated.",
      "ja": "このコンテンツエンコーディングは、大きなメッセージを段階的に処理できるように設計されています。また、限定された方法でプレーンテキストへのランダムアクセスを許可します。コンテンツのエンコードにより、受信者はメッセージが切り捨てられたことを検出できます。"
    },
    {
      "indent": 3,
      "text": "A partially delivered message MUST NOT be processed as though the entire message was successfully delivered. For instance, a partially delivered message cannot be cached as though it were complete.",
      "ja": "部分的に配信されたメッセージは、メッセージ全体が正常に配信されたかのように処理してはなりません（MUST NOT）。たとえば、部分的に配信されたメッセージは、完全であるかのようにキャッシュすることはできません。"
    },
    {
      "indent": 3,
      "text": "An attacker might exploit willingness to process partial messages to cause a receiver to remain in a specific intermediate state. Implementations performing processing on partial messages need to ensure that any intermediate processing states don't advantage an attacker.",
      "ja": "攻撃者は、部分的なメッセージを処理する意欲を悪用して、受信者を特定の中間状態のままにさせる可能性があります。部分的なメッセージに対して処理を実行する実装では、中間の処理状態が攻撃者に有利にならないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Key and Nonce Reuse",
      "section_title": true,
      "ja": "4.3. キーとノンスの再利用"
    },
    {
      "indent": 3,
      "text": "Encrypting different plaintext with the same content-encryption key and nonce in AES-GCM is not safe [RFC5116]. The scheme defined here uses a fixed progression of nonce values. Thus, a new content-encryption key is needed for every application of the content coding. Since input-keying material can be reused, a unique \"salt\" parameter is needed to ensure that a content-encryption key is not reused.",
      "ja": "AES-GCMで同じコンテンツ暗号化キーとノンスを使用して異なる平文を暗号化することは安全ではありません[RFC5116]。ここで定義されているスキームは、ナンス値の固定された進行を使用します。したがって、コンテンツコーディングのすべてのアプリケーションに新しいコンテンツ暗号化キーが必要です。入力鍵の素材は再利用できるため、コンテンツ暗号化鍵が再利用されないようにするために、一意の「塩」パラメータが必要です。"
    },
    {
      "indent": 3,
      "text": "If a content-encryption key is reused -- that is, if input-keying material and \"salt\" parameter are reused -- this could expose the plaintext and the authentication key, nullifying the protection offered by encryption. Thus, if the same input-keying material is reused, then the \"salt\" parameter MUST be unique each time. This ensures that the content-encryption key is not reused. An implementation SHOULD generate a random \"salt\" parameter for every message.",
      "ja": "コンテンツ暗号化キーが再利用される場合、つまり、入力キーマテリアルと「ソルト」パラメータが再利用される場合、これはプレーンテキストと認証キーを公開し、暗号化によって提供される保護を無効にする可能性があります。したがって、同じ入力キー情報が再利用される場合、「塩」パラメータは毎回一意でなければなりません。これにより、コンテンツ暗号化キーが再利用されなくなります。実装は、すべてのメッセージに対してランダムな「塩」パラメーターを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "4.4. Data Encryption Limits",
      "section_title": true,
      "ja": "4.4. データ暗号化の制限"
    },
    {
      "indent": 3,
      "text": "There are limits to the data that AEAD_AES_128_GCM can encipher. The maximum value for the record size is limited by the size of the \"rs\" field in the header (see Section 2.1), which ensures that the 2^36-31 limit for a single application of AEAD_AES_128_GCM is not reached [RFC5116]. In order to preserve a 2^-40 probability of indistinguishability under chosen plaintext attack (IND-CPA), the total amount of plaintext that can be enciphered with the key derived from the same input-keying material and salt MUST be less than 2^44.5 blocks of 16 octets [AEBounds].",
      "ja": "AEAD_AES_128_GCMが暗号化できるデータには制限があります。レコードサイズの最大値は、ヘッダーの「rs」フィールドのサイズによって制限されます（セクション2.1を参照）。これにより、AEAD_AES_128_GCMの単一アプリケーションの2 ^ 36-31制限に確実に達しません[RFC5116]。選択された平文攻撃（IND-CPA）で2 ^ -40の区別がつかない確率を維持するために、同じ入力鍵素材とソルトから派生した鍵で暗号化できる平文の総量は2 ^未満でなければなりません16オクテットの44.5ブロック[AEBounds]。"
    },
    {
      "indent": 3,
      "text": "If the record size is a multiple of 16 octets, this means that 398 terabytes can be encrypted safely, including padding and overhead. However, if the record size is not a multiple of 16 octets, the total amount of data that can be safely encrypted is reduced because partial AES blocks are encrypted. The worst case is a record size of 18 octets, for which at most 74 terabytes of plaintext can be encrypted, of which at least half is padding.",
      "ja": "レコードサイズが16オクテットの倍数である場合、これは、パディングやオーバーヘッドを含め、398テラバイトを安全に暗号化できることを意味します。ただし、レコードサイズが16オクテットの倍数でない場合、部分的なAESブロックが暗号化されるため、安全に暗号化できるデータの総量が減少します。最悪のケースは18オクテットのレコードサイズであり、最大74テラバイトのプレーンテキストを暗号化でき、そのうち少なくとも半分はパディングです。"
    },
    {
      "indent": 0,
      "text": "4.5. Content Integrity",
      "section_title": true,
      "ja": "4.5. コンテンツの整合性"
    },
    {
      "indent": 3,
      "text": "This mechanism only provides content-origin authentication. The authentication tag only ensures that an entity with access to the content-encryption key produced the encrypted data.",
      "ja": "このメカニズムは、コンテンツオリジン認証のみを提供します。認証タグは、コンテンツ暗号化キーへのアクセス権を持つエンティティが暗号化されたデータを生成することのみを保証します。"
    },
    {
      "indent": 3,
      "text": "Any entity with the content-encryption key can, therefore, produce content that will be accepted as valid. This includes all recipients of the same HTTP message.",
      "ja": "したがって、コンテンツ暗号化キーを持つエンティティは、有効であると認められるコンテンツを生成できます。これには、同じHTTPメッセージのすべての受信者が含まれます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, any entity that is able to modify both the Content-Encoding header field and the HTTP message body can replace the contents. Without the content-encryption key or the input-keying material, modifications to, or replacement of, parts of a payload body are not possible.",
      "ja": "さらに、Content-EncodingヘッダーフィールドとHTTPメッセージ本文の両方を変更できるエンティティは、コンテンツを置き換えることができます。コンテンツ暗号化キーまたは入力キーイングマテリアルがないと、ペイロード本体の一部を変更または交換することはできません。"
    },
    {
      "indent": 0,
      "text": "4.6. Leaking Information in Header Fields",
      "section_title": true,
      "ja": "4.6. ヘッダーフィールドの情報の漏洩"
    },
    {
      "indent": 3,
      "text": "Because only the payload body is encrypted, information exposed in header fields is visible to anyone who can read the HTTP message. This could expose side-channel information.",
      "ja": "ペイロード本体のみが暗号化されているため、ヘッダーフィールドに公開された情報は、HTTPメッセージを読み取ることができるすべてのユーザーに表示されます。これにより、サイドチャネル情報が公開される可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, the Content-Type header field can leak information about the payload body.",
      "ja": "たとえば、Content-Typeヘッダーフィールドは、ペイロード本体に関する情報をリークする可能性があります。"
    },
    {
      "indent": 3,
      "text": "There are a number of strategies available to mitigate this threat, depending upon the application's threat model and the users' tolerance for leaked information:",
      "ja": "アプリケーションの脅威モデルと漏洩した情報に対するユーザーの許容度に応じて、この脅威を軽減するために利用可能ないくつかの戦略があります。"
    },
    {
      "indent": 3,
      "text": "1. Determine that it is not an issue. For example, if it is expected that all content stored will be \"application/json\", or another very common media type, exposing the Content-Type header field could be an acceptable risk.",
      "ja": "1. それが問題ではないことを確認します。たとえば、格納されるすべてのコンテンツが「application / json」、または別の非常に一般的なメディアタイプであることが予想される場合、Content-Typeヘッダーフィールドを公開することは許容できるリスクである可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. If it is considered sensitive information and it is possible to determine it through other means (e.g., out of band, using hints in other representations, etc.), omit the relevant headers, and/ or normalize them. In the case of Content-Type, this could be accomplished by always sending Content-Type: application/octet-stream (the most generic media type), or no Content-Type at all.",
      "ja": "2. 機密情報と見なされ、他の手段（帯域外、他の表現でのヒントの使用など）を通じてそれを特定できる場合は、関連するヘッダーを省略するか、ヘッダーを正規化します。 Content-Typeの場合、これは常にContent-Type：application / octet-stream（最も一般的なメディアタイプ）を送信するか、Content-Typeをまったく送信しないことで実現できます。"
    },
    {
      "indent": 3,
      "text": "3. If it is considered sensitive information and it is not possible to convey it elsewhere, encapsulate the HTTP message using the application/http media type (see Section 8.3.2 of [RFC7230]), encrypting that as the payload of the \"outer\" message.",
      "ja": "3. 機密情報と見なされ、他の場所に伝えることができない場合は、application / httpメディアタイプを使用してHTTPメッセージをカプセル化し（[RFC7230]のセクション8.3.2を参照）、それを「外部」メッセージのペイロードとして暗号化します。 。"
    },
    {
      "indent": 0,
      "text": "4.7. Poisoning Storage",
      "section_title": true,
      "ja": "4.7. 中毒ストレージ"
    },
    {
      "indent": 3,
      "text": "This mechanism only offers data-origin authentication; it does not perform authentication or authorization of the message creator, which could still need to be performed (e.g., by HTTP authentication [RFC7235]).",
      "ja": "このメカニズムはデータ起源の認証のみを提供します。メッセージの作成者の認証や承認は実行されません。これは、（たとえば、HTTP認証[RFC7235]によって）実行する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "This is especially relevant when an HTTP PUT request is accepted by a server without decrypting the payload; if the request is unauthenticated, it becomes possible for a third party to deny service and/or poison the store.",
      "ja": "これは、ペイロードを復号化せずにサーバーがHTTP PUTリクエストを受け入れる場合に特に関係があります。リクエストが認証されていない場合、サードパーティがサービスを拒否したり、ストアを汚染したりする可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.8. Sizing and Timing Attacks",
      "section_title": true,
      "ja": "4.8. サイジングとタイミング攻撃"
    },
    {
      "indent": 3,
      "text": "Applications using this mechanism need to be aware that the size of encrypted messages, as well as their timing, HTTP methods, URIs and so on, may leak sensitive information. See, for example, [NETFLIX] or [CLINIC].",
      "ja": "このメカニズムを使用するアプリケーションは、暗号化されたメッセージのサイズ、タイミング、HTTPメソッド、URIなどが機密情報を漏洩する可能性があることに注意する必要があります。たとえば、[NETFLIX]または[CLINIC]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This risk can be mitigated through the use of the padding that this mechanism provides. Alternatively, splitting up content into segments and storing them separately might reduce exposure. HTTP/2 [RFC7540] combined with TLS [RFC5246] might be used to hide the size of individual messages.",
      "ja": "このリスクは、このメカニズムが提供するパディングを使用することで軽減できます。または、コンテンツをセグメントに分割して個別に保存すると、露出を減らすことができます。 HTTP / 2 [RFC7540]とTLS [RFC5246]を組み合わせて使用​​すると、個々のメッセージのサイズを隠すことができます。"
    },
    {
      "indent": 3,
      "text": "Developing a padding strategy is difficult. A good padding strategy can depend on context. Common strategies include padding to a small set of fixed lengths, padding to multiples of a value, or padding to powers of 2. Even a good strategy can still cause size information to leak if processing activity of a recipient can be observed. This is especially true if the trailing records of a message contain only padding. Distributing non-padding data across records is recommended to avoid leaking size information.",
      "ja": "パディング戦略の開発は困難です。適切なパディング戦略は、コンテキストに依存します。一般的な戦略には、固定長の小さなセットへのパディング、値の倍数へのパディング、または2の累乗へのパディングが含まれます。受信者の処理アクティビティが観察できる場合、優れた戦略でもサイズ情報がリークする可能性があります。これは、メッセージの末尾のレコードにパディングのみが含まれている場合に特に当てはまります。サイズ情報の漏えいを防ぐために、非パディングデータをレコード間で分散することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. The \"aes128gcm\" HTTP Content Coding",
      "section_title": true,
      "ja": "5.1. 「aes128gcm」HTTPコンテンツコーディング"
    },
    {
      "indent": 3,
      "text": "This memo registers the \"aes128gcm\" HTTP content coding in the \"HTTP Content Coding Registry\", as detailed in Section 2.",
      "ja": "このメモは、「aes128gcm」HTTPコンテンツコーディングを「HTTPコンテンツコーディングレジストリ」に登録します。詳細については、セクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Name: aes128gcm",
      "ja": "o 名前：aes128gcm"
    },
    {
      "indent": 3,
      "text": "o Description: AES-GCM encryption with a 128-bit content-encryption key",
      "ja": "o 説明：128ビットのコンテンツ暗号化キーを使用したAES-GCM暗号化"
    },
    {
      "indent": 3,
      "text": "o Reference: this specification",
      "ja": "o 参照：この仕様"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS180-4] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS180-4, August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[FIPS180-4]米国国立標準技術研究所、「Secure Hash Standard（SHS）」、FIPS PUB 180-4、DOI 10.6028 / NIST.FIPS180-4、2015年8月、<http://nvlpubs.nist.gov/ nistpubs / FIPS / NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <http://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<http://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <http://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー導出関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<http：//www.rfc-editor .org / info / rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「あいまいな大文字と小文字のRFC 2119キーワード」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AEBounds] Luykx, A. and K. Paterson, \"Limits on Authenticated Encryption Use in TLS\", March 2016, <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.",
      "ja": "[AEBounds] Luykx、A。およびK. Paterson、「TLSでの認証された暗号化の使用に関する制限」、2016年3月、<http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>。"
    },
    {
      "indent": 3,
      "text": "[CLINIC] Miller, B., Huang, L., Joseph, A., and J. Tygar, \"I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis\", DOI 10.1007/978-3-319-08506-7_8, March 2014, <https://arxiv.org/abs/1403.0297>.",
      "ja": "[クリニック] Miller、B.、Huang、L.、Joseph、A.、J。Tygar、「クリニックに行った理由を知っています：HTTPSトラフィック分析のリスクと実現」、DOI 10.1007 / 978-3-319 -08506-7_8、2014年3月、<https://arxiv.org/abs/1403.0297>。"
    },
    {
      "indent": 3,
      "text": "[NETFLIX] Reed, A. and M. Kranch, \"Identifying HTTPS-Protected Netflix Videos in Real-Time\", Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy CODASPY '17, DOI 10.1145/3029806.3029821, 2017.",
      "ja": "[NETFLIX] Reed、A。およびM. Kranch、「Identifying HTTPS-Protected Netflix Videos in Real-Time」、Proceedings on the Seventh ACM on Conference on Data and Application Security and Privacy CODASPY '17、DOI 10.1145 / 3029806.3029821、2017。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, DOI 10.17487/RFC4880, November 2007, <http://www.rfc-editor.org/info/rfc4880>.",
      "ja": "[RFC4880] Callas、J.、Donnerhacke、L.、Finney、H.、Shaw、D。、およびR. Thayer、「OpenPGP Message Format」、RFC 4880、DOI 10.17487 / RFC4880、2007年11月、<http：// www.rfc-editor.org/info/rfc4880>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, <http://www.rfc-editor.org/info/rfc5652>.",
      "ja": "[RFC5652] Housley、R。、「Cryptographic Message Syntax（CMS）」、STD 70、RFC 5652、DOI 10.17487 / RFC5652、2009年9月、<http://www.rfc-editor.org/info/rfc5652>。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233] Fielding、R.、Ed。、Lafon、Y.、Ed。、and J. Reschke、Ed。、 \"Hypertext Transfer Protocol（HTTP / 1.1）：Range Requests\"、RFC 7233、DOI 10.17487 / RFC7233、June 2014、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Authentication」、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M。およびJ.ヒルデブランド、「JSON Web Encryption（JWE）」、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<http://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7540] Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext Transfer Protocol Version 2 (HTTP/2)\", RFC 7540, DOI 10.17487/RFC7540, May 2015, <http://www.rfc-editor.org/info/rfc7540>.",
      "ja": "[RFC7540] Belshe、M.、Peon、R。、およびM. Thomson、編、「Hypertext Transfer Protocol Version 2（HTTP / 2）」、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、<http：// www.rfc-editor.org/info/rfc7540>。"
    },
    {
      "indent": 3,
      "text": "[XMLENC] Eastlake, D., Reagle, J., Hirsch, F., and T. Roessler, \"XML Encryption Syntax and Processing Version 1.1\", World Wide Web Consortium Recommendation REC-xmlenc-core1-20130411, April 2013, <http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411>.",
      "ja": "[XMLENC] Eastlake、D.、Reagle、J.、Hirsch、F。、およびT. Roessler、「XML Encryption Syntax and Processing Version 1.1」、World Wide Web Consortium Recommendation REC-xmlenc-core1-20130411、2013年4月、< http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. JWE Mapping",
      "section_title": true,
      "ja": "付録A. PLAYマッピング"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding can be considered as a sequence of JSON Web Encryption (JWE) [RFC7516] objects, each corresponding to a single fixed-size record that includes trailing padding. The following transformations are applied to a JWE object that might be expressed using the JWE Compact Serialization:",
      "ja": "「aes128gcm」コンテンツコーディングは、一連のJSON Web Encryption（JWE）[RFC7516]オブジェクトと見なすことができ、それぞれが末尾のパディングを含む単一の固定サイズのレコードに対応しています。以下の変換は、JWE Compact Serializationを使用して表現される可能性のあるJWEオブジェクトに適用されます。"
    },
    {
      "indent": 3,
      "text": "o The JWE Protected Header is fixed to the value { \"alg\": \"dir\", \"enc\": \"A128GCM\" }, describing direct encryption using AES-GCM with a 128-bit content-encryption key. This header is not transmitted, it is instead implied by the value of the Content-Encoding header field.",
      "ja": "o JWE保護ヘッダーは、値{\"alg\"： \"dir\"、 \"enc\"： \"A128GCM\"}に固定されており、128ビットのコンテンツ暗号化キーでAES-GCMを使用する直接暗号化を記述します。このヘッダーは送信されず、代わりにContent-Encodingヘッダーフィールドの値によって暗示されます。"
    },
    {
      "indent": 3,
      "text": "o The JWE Encrypted Key is empty, as stipulated by the direct encryption algorithm.",
      "ja": "o 直接暗号化アルゴリズムで規定されているように、JWE暗号化キーは空です。"
    },
    {
      "indent": 3,
      "text": "o The JWE Initialization Vector (\"iv\") for each record is set to the exclusive-or of the 96-bit record sequence number, starting at zero, and a value derived from the input-keying material (see Section 2.3). This value is also not transmitted.",
      "ja": "o 各レコードのJWE初期化ベクトル（ \"iv\"）は、ゼロから始まる96ビットのレコードシーケンス番号の排他的論理和、および入力キーマテリアルから派生した値に設定されます（セクション2.3を参照）。この値も送信されません。"
    },
    {
      "indent": 3,
      "text": "o The final value is the concatenated header, JWE Ciphertext, and JWE Authentication Tag, all expressed without base64url encoding. The \".\" separator is omitted, since the length of these fields is known.",
      "ja": "o 最後の値は、連結ヘッダー、JWE Ciphertext、およびJWE Authentication Tagであり、すべてbase64urlエンコードなしで表現されます。 「。」これらのフィールドの長さがわかっているため、セパレーターは省略されます。"
    },
    {
      "indent": 3,
      "text": "Thus, the example in Section 3.1 can be rendered using the JWE Compact Serialization as:",
      "ja": "したがって、セクション3.1の例は、JWE Compact Serializationを使用して次のようにレンダリングできます。"
    },
    {
      "indent": 3,
      "text": "eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..Bcs8gkIRKLI8GeI8. -NAVub2qFgBEuQKRapoZuw.4jGQi9rcwQHU8P6XLxOGOA",
      "ja": "eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..Bcs8gkIRKLI8GeI8。 -NAVub2qFgBEuQKRapoZuw.4jGQi9rcwQHU8P6XLxOGOA"
    },
    {
      "indent": 3,
      "text": "Where the first line represents the fixed JWE Protected Header, an empty JWE Encrypted Key, and the algorithmically determined JWE Initialization Vector. The second line contains the encoded body, split into JWE Ciphertext and JWE Authentication Tag.",
      "ja": "最初の行は、固定されたJWE保護ヘッダー、空のJWE暗号化キー、およびアルゴリズムによって決定されたJWE初期化ベクトルを表します。 2行目には、エンコードされた本文が含まれ、JWE暗号文とJWE認証タグに分割されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Mark Nottingham was an original author of this document.",
      "ja": "マークノッティンガムは、このドキュメントの原作者です。"
    },
    {
      "indent": 3,
      "text": "The following people provided valuable input: Richard Barnes, David Benjamin, Peter Beverloo, JR Conlin, Mike Jones, Stephen Farrell, Adam Langley, James Manger, John Mattsson, Julian Reschke, Eric Rescorla, Jim Schaad, and Magnus Westerlund.",
      "ja": "リチャードバーンズ、デビッドベンジャミン、ピーターベバールー、JRコンリン、マイクジョーンズ、スティーブンファレル、アダムラングレー、ジェームズマンガー、ジョンマットソン、ジュリアンレシュケ、エリックレスコーラ、ジムシャード、マグナスウェスタールンドが貴重な情報を提供してくれました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Thomson Mozilla",
      "ja": "マーティン・トムソン・モジラ"
    },
    {
      "indent": 3,
      "text": "Email: martin.thomson@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}