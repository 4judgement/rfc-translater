{
  "title": {
    "text": "RFC 8154 - Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout",
    "ja": "RFC 8154 - Parallel NFS（pNFS）Small Computer System Interface（SCSI）レイアウト"
  },
  "number": 8154,
  "created_at": "2020-08-28 14:34:57.049699+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        C. Hellwig\nRequest for Comments: 8154                                      May 2017\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout",
      "ja": "Parallel NFS（pNFS）Small Computer System Interface（SCSI）レイアウト"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Parallel Network File System (pNFS) allows a separation between the metadata (onto a metadata server) and data (onto a storage device) for a file. The Small Computer System Interface (SCSI) layout type is defined in this document as an extension to pNFS to allow the use of SCSI-based block storage devices.",
      "ja": "Parallel Network File System（pNFS）では、ファイルのメタデータ（メタデータサーバー上）とデータ（ストレージデバイス上）を分離できます。このドキュメントでは、SCSI（Small Computer System Interface）レイアウトタイプをpNFSの拡張機能として定義し、SCSIベースのブロックストレージデバイスを使用できるようにしています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8154.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8154で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n  1.2.  General Definitions . . . . . . . . . . . . . . . . . . .   4\n  1.3.  Code Components Licensing Notice  . . . . . . . . . . . .   5\n  1.4.  XDR Description . . . . . . . . . . . . . . . . . . . . .   5\n2.  SCSI Layout Description . . . . . . . . . . . . . . . . . . .   7\n  2.1.  Background and Architecture . . . . . . . . . . . . . . .   7\n  2.2.  layouttype4 . . . . . . . . . . . . . . . . . . . . . . .   8\n  2.3.  GETDEVICEINFO . . . . . . . . . . . . . . . . . . . . . .   8\n    2.3.1.  Volume Identification . . . . . . . . . . . . . . . .   8\n    2.3.2.  Volume Topology . . . . . . . . . . . . . . . . . . .  10\n  2.4.  Data Structures: Extents and Extent Lists . . . . . . . .  12\n    2.4.1.  Layout Requests and Extent Lists  . . . . . . . . . .  15\n    2.4.2.  Layout Commits  . . . . . . . . . . . . . . . . . . .  16\n    2.4.3.  Layout Returns  . . . . . . . . . . . . . . . . . . .  17\n    2.4.4.  Layout Revocation . . . . . . . . . . . . . . . . . .  17\n    2.4.5.  Client Copy-on-Write Processing . . . . . . . . . . .  17\n    2.4.6.  Extents Are Permissions . . . . . . . . . . . . . . .  18\n    2.4.7.  Partial-Block Updates . . . . . . . . . . . . . . . .  19\n    2.4.8.  End-of-File Processing  . . . . . . . . . . . . . . .  20\n    2.4.9.  Layout Hints  . . . . . . . . . . . . . . . . . . . .  20\n    2.4.10. Client Fencing  . . . . . . . . . . . . . . . . . . .  21\n  2.5.  Crash Recovery Issues . . . . . . . . . . . . . . . . . .  22\n  2.6.  Recalling Resources: CB_RECALL_ANY  . . . . . . . . . . .  23\n  2.7.  Transient and Permanent Errors  . . . . . . . . . . . . .  23\n  2.8.  Volatile Write Caches . . . . . . . . . . . . . . . . . .  24\n3.  Enforcing NFSv4 Semantics . . . . . . . . . . . . . . . . . .  24\n  3.1.  Use of Open Stateids  . . . . . . . . . . . . . . . . . .  25\n  3.2.  Enforcing Security Restrictions . . . . . . . . . . . . .  26\n  3.3.  Enforcing Locking Restrictions  . . . . . . . . . . . . .  26\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  27\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28\n6.  Normative References  . . . . . . . . . . . . . . . . . . . .  28\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  29\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  30",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the overall architecture of a Parallel NFS (pNFS) system:",
      "ja": "図1は、Parallel NFS（pNFS）システムの全体的なアーキテクチャを示しています。"
    },
    {
      "indent": 8,
      "text": "+-----------+\n|+-----------+                                 +-----------+\n||+-----------+                                |           |\n|||           |       NFSv4.1 + pNFS           |           |\n+||  Clients  |<------------------------------>|   Server  |\n +|           |                                |           |\n  +-----------+                                |           |\n       |||                                     +-----------+\n       |||                                           |\n       |||                                           |\n       ||| Storage        +-----------+              |\n       ||| Protocol       |+-----------+             |\n       ||+----------------||+-----------+  Control   |\n       |+-----------------|||           |    Protocol|\n       +------------------+||  Storage  |------------+\n                           +|  Systems  |\n                            +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The overall approach is that pNFS-enhanced clients obtain sufficient information from the server to enable them to access the underlying storage (on the storage systems) directly. See Section 12 of [RFC5661] for more details. This document is concerned with access from pNFS clients to storage devices over block storage protocols based on the SCSI Architecture Model [SAM-5], e.g., the Fibre Channel Protocol (FCP), Internet SCSI (iSCSI), or Serial Attached SCSI (SAS). pNFS SCSI layout requires block-based SCSI command sets, for example, SCSI Block Commands [SBC3]. While SCSI command sets for non-block-based access exist, these are not supported by the SCSI layout type, and all future references to SCSI storage devices will imply a block-based SCSI command set.",
      "ja": "全体的なアプローチは、pNFS拡張クライアントがサーバーから十分な情報を取得して、（ストレージシステム上の）基盤となるストレージに直接アクセスできるようにすることです。詳細については、[RFC5661]のセクション12を参照してください。このドキュメントは、SCNアーキテクチャモデル[SAM-5]に基づくブロックストレージプロトコル（ファイバーチャネルプロトコル（FCP）、インターネットSCSI（iSCSI）、シリアルアタッチドSCSI（SAS）など）を介したpNFSクライアントからストレージデバイスへのアクセスに関するものです。 ）。 pNFS SCSIレイアウトには、ブロックベースのSCSIコマンドセット（SCSIブロックコマンド[SBC3]など）が必要です。非ブロックベースのアクセス用のSCSIコマンドセットは存在しますが、これらはSCSIレイアウトタイプではサポートされておらず、今後のSCSIストレージデバイスへの参照はすべてブロックベースのSCSIコマンドセットを意味します。"
    },
    {
      "indent": 3,
      "text": "The Server to Storage System protocol, called the \"Control Protocol\", is not of concern for interoperability, although it will typically be the same SCSI-based storage protocol.",
      "ja": "「制御プロトコル」と呼ばれるサーバーからストレージシステムへのプロトコルは、通常は同じSCSIベースのストレージプロトコルですが、相互運用性には関係ありません。"
    },
    {
      "indent": 0,
      "text": " This document is based on [RFC5663] and makes changes to the block layout type to provide a better pNFS layout protocol for SCSI-based storage devices. Despite these changes, [RFC5663] remains the defining document for the existing block layout type. pNFS Block Disk Protection [RFC6688] is unnecessary in the context of the SCSI layout type because the new layout type provides mandatory disk access protection as part of the layout type definition. In contrast to [RFC5663], this document uses SCSI protocol features to provide reliable fencing by using SCSI persistent reservations, and it can provide reliable and efficient device discovery by using SCSI device identifiers instead of having to rely on probing all devices potentially attached to a client. This new layout type also optimizes the Input/Output (I/O) path by reducing the size of the LAYOUTCOMMIT payload.",
      "ja": "このドキュメントは[RFC5663]に基づいており、ブロックレイアウトタイプを変更して、SCSIベースのストレージデバイスにより適切なpNFSレイアウトプロトコルを提供します。これらの変更にもかかわらず、[RFC5663]は既存のブロックレイアウトタイプの定義ドキュメントのままです。新しいレイアウトタイプは、レイアウトタイプ定義の一部として必須のディスクアクセス保護を提供するため、SCSIレイアウトタイプのコンテキストでは、pNFSブロックディスク保護[RFC6688]は不要です。 [RFC5663]とは対照的に、このドキュメントはSCSIプロトコル機能を使用して、SCSI永続予約を使用することで信頼できるフェンシングを提供し、SCSIデバイス識別子を使用することにより、クライアント。この新しいレイアウトタイプは、LAYOUTCOMMITペイロードのサイズを削減することにより、入出力（I / O）パスも最適化します。"
    },
    {
      "indent": 3,
      "text": "The above two paragraphs summarize the major functional differences from [RFC5663]. There are other minor differences, e.g., the \"base\" volume type in this specification is used instead of the \"simple\" volume type in [RFC5663], but there are no significant differences in the data structures that describe the volume topology above this level (Section 2.3.2) or in the data structures that describe extents (Section 2.4).",
      "ja": "上記の2つの段落は、[RFC5663]との主要な機能の違いを要約しています。他のマイナーな違いがあります。たとえば、[RFC5663]の「単純な」ボリュームタイプの代わりにこの仕様の「ベース」ボリュームタイプが使用されますが、このレベルより上のボリュームトポロジを記述するデータ構造に大きな違いはありません（セクション2.3.2）またはエクステントを記述するデータ構造（セクション2.4）。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. General Definitions",
      "section_title": true,
      "ja": "1.2. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "The following definitions are provided for the purpose of providing an appropriate context for the reader.",
      "ja": "以下の定義は、読者に適切なコンテキストを提供する目的で提供されています。"
    },
    {
      "indent": 3,
      "text": "Byte: an octet, i.e., a datum exactly 8 bits in length.",
      "ja": "バイト：オクテット、つまり、正確に8ビットの長さのデータ。"
    },
    {
      "indent": 3,
      "text": "Client: the entity that accesses the NFS server's resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.",
      "ja": "クライアント：NFSサーバーのリソースにアクセスするエンティティ。クライアントは、NFSサーバーに直接アクセスするためのロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーションにリモートファイルシステムサービスを提供する従来のオペレーティングシステムクライアントでもかまいません。"
    },
    {
      "indent": 3,
      "text": "Server: the entity responsible for coordinating client access to a set of file systems and is identified by a server owner.",
      "ja": "サーバー：ファイルシステムのセットへのクライアントアクセスの調整を担当するエンティティで、サーバーの所有者によって識別されます。"
    },
    {
      "indent": 3,
      "text": "Metadata Server (MDS): a pNFS server that provides metadata information for a file system object. It also is responsible for generating layouts for file system objects. Note that the MDS is also responsible for directory-based operations.",
      "ja": "メタデータサーバー（MDS）：ファイルシステムオブジェクトのメタデータ情報を提供するpNFSサーバー。また、ファイルシステムオブジェクトのレイアウトを生成します。 MDSはディレクトリベースの操作も担当することに注意してください。"
    },
    {
      "indent": 0,
      "text": "1.3. Code Components Licensing Notice",
      "section_title": true,
      "ja": "1.3. コードコンポーネントライセンス通知"
    },
    {
      "indent": 3,
      "text": "The external data representation (XDR) description and scripts for extracting the XDR description are Code Components as described in Section 4 of \"Legal Provisions Relating to IETF Documents\" [LEGAL]. These Code Components are licensed according to the terms of Section 4 of \"Legal Provisions Relating to IETF Documents\".",
      "ja": "外部データ表現（XDR）記述とXDR記述を抽出するためのスクリプトは、「IETFドキュメントに関連する法的規定」[法的事項]のセクション4で説明されているコードコンポーネントです。これらのコードコンポーネントは、「IETFドキュメントに関連する法的規定」のセクション4の条件に従ってライセンスされます。"
    },
    {
      "indent": 0,
      "text": "1.4. XDR Description",
      "section_title": true,
      "ja": "1.4. XDRの説明"
    },
    {
      "indent": 3,
      "text": "This document contains the XDR [RFC4506] description of the NFSv4.1 SCSI layout protocol. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine-readable XDR description of the NFSv4.1 SCSI layout:",
      "ja": "このドキュメントには、NFSv4.1 SCSIレイアウトプロトコルのXDR [RFC4506]の説明が含まれています。 XDRの説明は、読者がコンパイル可能なフォームに簡単に抽出できるように、このドキュメントに埋め込まれています。読者はこのドキュメントを次のシェルスクリプトにフィードして、NFSv4.1 SCSIレイアウトの機械可読なXDR記述を生成できます。"
    },
    {
      "indent": 4,
      "text": "#!/bin/sh\ngrep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "That is, if the above script is stored in a file called \"extract.sh\", and this document is in a file called \"spec.txt\", then the reader can do:",
      "ja": "つまり、上記のスクリプトが「extract.sh」というファイルに保存されていて、このドキュメントが「spec.txt」というファイルにある場合、リーダーは次のことを実行できます。"
    },
    {
      "indent": 4,
      "text": "sh extract.sh < spec.txt > scsi_prot.x",
      "ja": "sh extract.sh <spec.txt> scsi_prot.x"
    },
    {
      "indent": 3,
      "text": "The effect of the script is to remove leading white space from each line, plus a sentinel sequence of \"///\".",
      "ja": "スクリプトの効果は、各行から先頭の空白と、 \"///\"のセンチネルシーケンスを削除することです。"
    },
    {
      "indent": 3,
      "text": "The embedded XDR file header follows. Subsequent XDR descriptions with the sentinel sequence are embedded throughout the document.",
      "ja": "埋め込まれたXDRファイルのヘッダーは次のとおりです。センチネルシーケンスを含む後続のXDR説明は、ドキュメント全体に埋め込まれています。"
    },
    {
      "indent": 3,
      "text": "Note that the XDR code contained in this document depends on types from the NFSv4.1 nfs4_prot.x file [RFC5662]. This includes both NFS types that end with a 4, such as offset4, length4, etc., as well as more generic types such as uint32_t and uint64_t.",
      "ja": "このドキュメントに含まれるXDRコードは、NFSv4.1 nfs4_prot.xファイル[RFC5662]のタイプに依存することに注意してください。これには、offset4、length4など、4で終わるNFSタイプと、uint32_tやuint64_tなどのより一般的なタイプの両方が含まれます。"
    },
    {
      "indent": 7,
      "text": "/// /*\n///  * This code was derived from RFC 8154.\n///  * Please reproduce this note if possible.\n///  */\n/// /*\n///  * Copyright (c) 2017 IETF Trust and the persons\n///  * identified as authors of the code.  All rights reserved.\n///  *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "///  * Redistribution and use in source and binary forms, with\n///  * or without modification, are permitted provided that the\n///  * following conditions are met:\n///  *\n///  * - Redistributions of source code must retain the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer.\n///  *\n///  * - Redistributions in binary form must reproduce the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer in the documentation and/or other\n///  *   materials provided with the distribution.\n///  *\n///  * - Neither the name of Internet Society, IETF or IETF\n///  *   Trust, nor the names of specific contributors, may be\n///  *   used to endorse or promote products derived from this\n///  *   software without specific prior written permission.\n///  *\n///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///  *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///  */\n///\n/// /*\n///  *      nfs4_scsi_layout_prot.x\n///  */\n///\n/// %#include \"nfsv41.h\"\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2. SCSI Layout Description",
      "section_title": true,
      "ja": "2. SCSIレイアウトの説明"
    },
    {
      "indent": 0,
      "text": "2.1. Background and Architecture",
      "section_title": true,
      "ja": "2.1. 背景とアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The fundamental storage model supported by SCSI storage devices is a logical unit (LU) consisting of a sequential series of fixed-size blocks. Logical units used as devices for NFS SCSI layouts, and the SCSI initiators used for the pNFS metadata server and clients, MUST support SCSI persistent reservations as defined in [SPC4].",
      "ja": "SCSIストレージデバイスでサポートされている基本的なストレージモデルは、一連の固定サイズのブロックで構成される論理ユニット（LU）です。 NFS SCSIレイアウトのデバイスとして使用される論理ユニット、およびpNFSメタデータサーバーとクライアントに使用されるSCSIイニシエーターは、[SPC4]で定義されているSCSI永続予約をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "A pNFS layout for this SCSI class of storage is responsible for mapping from an NFS file (or portion of a file) to the blocks of storage volumes that contain the file. The blocks are expressed as extents with 64-bit offsets and lengths using the existing NFSv4 offset4 and length4 types. Clients MUST be able to perform I/O to the block extents without affecting additional areas of storage (especially important for writes); therefore, extents MUST be aligned to logical block size boundaries of the underlying logical units (typically 512 or 4096 bytes). For complex volume topologies, the server MUST ensure extents are aligned to the logical block size boundaries of the largest logical block size in the volume topology.",
      "ja": "このSCSIストレージクラスのpNFSレイアウトは、NFSファイル（またはファイルの一部）から、ファイルを含むストレージボリュームのブロックへのマッピングを担当します。ブロックは、既存のNFSv4 offset4およびlength4タイプを使用して、64ビットのオフセットと長さを持つエクステントとして表現されます。クライアントは、ストレージの追加領域に影響を与えることなく（特に書き込みにとって重要）、ブロックエクステントへのI / Oを実行できなければなりません（MUST）。したがって、エクステントは、基礎となる論理ユニットの論理ブロックサイズ境界（通常は512または4096バイト）に揃える必要があります。複雑なボリュームトポロジの場合、サーバーは、エクステントがボリュームトポロジの最大論理ブロックサイズの論理ブロックサイズ境界に揃えられていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The pNFS operation for requesting a layout (LAYOUTGET) includes the \"layoutiomode4 loga_iomode\" argument, which indicates whether the requested layout is for read-only use or read-write use. A read-only layout may contain holes that are read as zero, whereas a read-write layout will contain allocated but uninitialized storage in those holes (read as zero, can be written by client). This document also supports client participation in copy-on-write (e.g., for file systems with snapshots) by providing both read-only and uninitialized storage for the same range in a layout. Reads are initially performed on the read-only storage, with writes going to the uninitialized storage. After the first write that initializes the uninitialized storage, all reads are performed to that now-initialized writable storage, and the corresponding read-only storage is no longer used.",
      "ja": "レイアウトを要求するためのpNFS操作（LAYOUTGET）には、「layoutiomode4 loga_iomode」引数が含まれています。これは、要求されたレイアウトが読み取り専用であるか、読み取りと書き込みで使用されるかを示します。読み取り専用レイアウトには、ゼロとして読み取られるホールが含まれる場合がありますが、読み取り/書き込みレイアウトには、割り当てられたが初期化されていないストレージがこれらのホールに含まれます（ゼロとして読み取られ、クライアントが書き込むことができます）。このドキュメントは、レイアウト内の同じ範囲に読み取り専用ストレージと初期化されていないストレージの両方を提供することにより、コピーオンライト（たとえば、スナップショットを持つファイルシステム）へのクライアントの参加もサポートします。読み取りは最初は読み取り専用ストレージで実行され、書き込みは初期化されていないストレージに行われます。初期化されていないストレージを初期化する最初の書き込み後、すべての読み取りは現在初期化されている書き込み可能なストレージに対して実行され、対応する読み取り専用ストレージは使用されなくなります。"
    },
    {
      "indent": 3,
      "text": "The SCSI layout solution expands the security responsibilities of the pNFS clients, and there are a number of environments where the mandatory-to-implement security properties for NFS cannot be satisfied. The additional security responsibilities of the client follow, and a full discussion is present in Section 4 (\"Security Considerations\").",
      "ja": "SCSIレイアウトソリューションは、pNFSクライアントのセキュリティの責任を拡大します。また、NFSの実装に必須のセキュリティプロパティを満たせない環境が多数あります。クライアントの追加のセキュリティ責任が続き、セクション4（「セキュリティの考慮事項」）で完全な議論が行われます。"
    },
    {
      "indent": 3,
      "text": "o Typically, SCSI storage devices provide access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), which operate at the granularity of individual hosts, not individual blocks. For this reason, block-based protection must be provided by the client software.",
      "ja": "o 通常、SCSIストレージデバイスは、個別のブロックではなく、個別のホストの粒度で動作するアクセス制御メカニズム（論理ユニット番号（LUN）マッピングやマスキングなど）を提供します。このため、ブロックベースの保護をクライアントソフトウェアで提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Similarly, SCSI storage devices typically are not able to validate NFS locks that apply to file regions. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests and not to allow writes to the existing parts of the file.",
      "ja": "o 同様に、SCSIストレージデバイスは通常、ファイル領域に適用されるNFSロックを検証できません。たとえば、ファイルが必須の読み取り専用ロックでカバーされている場合、サーバーは、ファイルの読み取り可能なレイアウトのみがpNFSクライアントに許可されるようにすることができます。ただし、読み取り可能なレイアウトが読み取り要求を処理するためにのみ使用され、ファイルの既存の部分への書き込みを許可しないことを保証するのは、各pNFSクライアントの責任です。"
    },
    {
      "indent": 3,
      "text": "Since SCSI storage devices are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS SCSI layouts MUST NOT be used.",
      "ja": "SCSIストレージデバイスは通常、このようなファイルベースのセキュリティを適用することができないため、pNFSクライアントがそのようなポリシーの実施を信頼できない環境では、pNFS SCSIレイアウトを使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "2.2. layouttype4",
      "section_title": true,
      "ja": "2.2. layouttype4"
    },
    {
      "indent": 3,
      "text": "The layout4 type defined in [RFC5662] is extended with a new value as follows:",
      "ja": "[RFC5662]で定義されているlayout4タイプは、次のように新しい値で拡張されています。"
    },
    {
      "indent": 8,
      "text": "enum layouttype4 {\n    LAYOUT4_NFSV4_1_FILES   = 1,\n    LAYOUT4_OSD2_OBJECTS    = 2,\n    LAYOUT4_BLOCK_VOLUME    = 3,\n    LAYOUT4_SCSI            = 5\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This document defines the structure associated with the layouttype4 value LAYOUT4_SCSI. [RFC5661] specifies the loc_body structure as an XDR type \"opaque\". The opaque layout is uninterpreted by the generic pNFS client layers but obviously must be interpreted by the layout type implementation.",
      "ja": "このドキュメントは、layouttype4値LAYOUT4_SCSIに関連付けられた構造を定義します。 [RFC5661]は、loc_body構造をXDRタイプ「不透明」として指定します。不透明なレイアウトは、一般的なpNFSクライアントレイヤーでは解釈されませんが、レイアウトタイプの実装で解釈する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. GETDEVICEINFO",
      "section_title": true,
      "ja": "2.3. GETDEVICEINFO"
    },
    {
      "indent": 0,
      "text": "2.3.1. Volume Identification",
      "section_title": true,
      "ja": "2.3.1. ボリューム識別"
    },
    {
      "indent": 0,
      "text": " SCSI targets implementing [SPC4] export unique LU names for each LU through the Device Identification Vital Product Data (VPD) page (page code 0x83), which can be obtained using the INQUIRY command with the Enable VPD (EVPD) bit set to one. This document uses a subset of this information to identify LUs backing pNFS SCSI layouts. The Device Identification VPD page descriptors used to identify LUs for use with pNFS SCSI layouts must adhere to the following restrictions:",
      "ja": "[SPC4]を実装するSCSIターゲットは、デバイス識別重要製品データ（VPD）ページ（ページコード0x83）を介して各LUの一意のLU名をエクスポートします。これは、VPDの有効化（EVPD）ビットを1に設定したINQUIRYコマンドを使用して取得できます。このドキュメントでは、この情報のサブセットを使用して、pNFS SCSIレイアウトを支えるLUを​​識別します。 pNFS SCSIレイアウトで使用するLUを識別するために使用されるデバイス識別VPDページ記述子は、次の制限に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "1. The \"ASSOCIATION\" MUST be set to 0 (The \"DESIGNATOR\" field is associated with the addressed logical unit).",
      "ja": "1. 「ASSOCIATION」は0に設定する必要があります（「DESIGNATOR」フィールドはアドレス指定された論理ユニットに関連付けられています）。"
    },
    {
      "indent": 3,
      "text": "2. The \"DESIGNATOR TYPE\" MUST be set to one of four values that are required for the mandatory logical unit name in Section 7.7.3 of [SPC4], as explicitly listed in the \"pnfs_scsi_designator_type\" enumeration:",
      "ja": "2. \"pnfs_scsi_designator_type\"列挙に明示的にリストされているように、[DESIGNATOR TYPE]は、[SPC4]のセクション7.7.3の必須の論理ユニット名に必要な4つの値のいずれかに設定する必要があります。"
    },
    {
      "indent": 10,
      "text": "PS_DESIGNATOR_T10 - based on T10 vendor ID",
      "ja": "PS_DESIGNATOR_T10-T10ベンダーIDに基づく"
    },
    {
      "indent": 10,
      "text": "PS_DESIGNATOR_EUI64 - based on EUI-64",
      "ja": "PS_DESIGNATOR_EUI64-EUI-64に基づく"
    },
    {
      "indent": 10,
      "text": "PS_DESIGNATOR_NAA - Network Address Authority (NAA)",
      "ja": "Purse_Designor_No-ネットワークアドレス機関（NO）"
    },
    {
      "indent": 10,
      "text": "PS_DESIGNATOR_NAME - SCSI name string",
      "ja": "PS_DESIGNATOR_NAME-SCSI名の文字列"
    },
    {
      "indent": 3,
      "text": "3. Any other association or designator type MUST NOT be used. Use of T10 vendor IDs is discouraged when one of the other types can be used.",
      "ja": "3. 他のアソシエーションまたは指定子タイプは使用してはなりません。他のタイプのいずれかを使用できる場合は、T10ベンダーIDを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The \"CODE SET\" VPD page field is stored in the \"sbv_code_set\" field of the \"pnfs_scsi_base_volume_info4\" data structure, the \"DESIGNATOR TYPE\" is stored in \"sbv_designator_type\", and the DESIGNATOR is stored in \"sbv_designator\". Due to the use of an XDR array, the \"DESIGNATOR LENGTH\" field does not need to be set separately. Only certain combinations of \"sbv_code_set\" and \"sbv_designator_type\" are valid; please refer to [SPC4] for details, and note that ASCII MAY be used as the code set for UTF-8 text that contains only printable ASCII characters. Note that a Device Identification VPD page MAY contain multiple descriptors with the same association, code set, and designator type. Thus, NFS clients MUST check all the descriptors for a possible match to \"sbv_code_set\", \"sbv_designator_type\", and \"sbv_designator\".",
      "ja": "「CODE SET」VPDページフィールドは「pnfs_scsi_base_volume_info4」データ構造の「sbv_code_set」フィールドに格納され、「DESIGNATOR TYPE」は「sbv_designator_type」に格納され、DESIGNATORは「sbv_designator」に格納されます。 XDR配列を使用しているため、「DESIGNATOR LENGTH」フィールドを個別に設定する必要はありません。 「sbv_code_set」と「sbv_designator_type」の特定の組み合わせのみが有効です。詳細については、[SPC4]を参照してください。また、印刷可能なASCII文字のみを含むUTF-8テキストのコードセットとしてASCIIを使用できます。デバイス識別VPDページには、同じ関連付け、コードセット、および指定子タイプを持つ複数の記述子が含まれる場合があります。したがって、NFSクライアントは、「sbv_code_set」、「sbv_designator_type」、および「sbv_designator」に一致する可能性があるかどうか、すべての記述子をチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "Storage devices such as storage arrays can have multiple physical network interfaces that need not be connected to a common network, resulting in a pNFS client having simultaneous multipath access to the same storage volumes via different ports on different networks. Selection of one or multiple ports to access the storage device is left up to the client.",
      "ja": "ストレージアレイなどのストレージデバイスは、共通のネットワークに接続する必要のない複数の物理ネットワークインターフェイスを持つことができるため、pNFSクライアントは、異なるネットワーク上の異なるポートを介して同じストレージボリュームに同時にマルチパスアクセスできます。ストレージデバイスにアクセスするための1つまたは複数のポートの選択は、クライアントに任されています。"
    },
    {
      "indent": 3,
      "text": "Additionally, the server returns a persistent reservation key in the \"sbv_pr_key\" field. See Section 2.4.10 for more details on the use of persistent reservations.",
      "ja": "さらに、サーバーは「sbv_pr_key」フィールドに永続予約キーを返します。永続的予約の使用の詳細については、2.4.10項を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Volume Topology",
      "section_title": true,
      "ja": "2.3.2. ボリュームトポロジ"
    },
    {
      "indent": 3,
      "text": "The pNFS SCSI layout volume topology is expressed in terms of the volume types described below. The individual components of the topology are contained in an array, and components MAY refer to other components by using array indices.",
      "ja": "pNFS SCSIレイアウトボリュームトポロジは、以下で説明するボリュームタイプで表されます。トポロジの個々のコンポーネントは配列に含まれており、コンポーネントは配列インデックスを使用して他のコンポーネントを参照する場合があります。"
    },
    {
      "indent": 3,
      "text": "/// enum pnfs_scsi_volume_type4 {\n///     PNFS_SCSI_VOLUME_SLICE  = 1,  /* volume is a slice of\n///                                      another volume */\n///     PNFS_SCSI_VOLUME_CONCAT = 2,  /* volume is a\n///                                      concatenation of\n///                                      multiple volumes */\n///     PNFS_SCSI_VOLUME_STRIPE = 3   /* volume is striped across\n///                                      multiple volumes */\n///     PNFS_SCSI_VOLUME_BASE   = 4,  /* volume maps to a single\n///                                      LU */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Code sets from SPC-4.\n///  */\n/// enum pnfs_scsi_code_set {\n///     PS_CODE_SET_BINARY     = 1,\n///     PS_CODE_SET_ASCII      = 2,\n///     PS_CODE_SET_UTF8       = 3\n/// };\n///\n/// /*\n///  * Designator types taken from SPC-4.\n///  *\n///  * Other values are allocated in SPC-4 but are not mandatory to\n///  * implement or aren't logical unit names.\n///  */\n/// enum pnfs_scsi_designator_type {\n///     PS_DESIGNATOR_T10      = 1,\n///     PS_DESIGNATOR_EUI64    = 2,\n///     PS_DESIGNATOR_NAA      = 3,\n///     PS_DESIGNATOR_NAME     = 8\n/// };\n///\n/// /*\n///  * Logical unit name + reservation key.\n///  */\n/// struct pnfs_scsi_base_volume_info4 {\n///     pnfs_scsi_code_set             sbv_code_set;\n///     pnfs_scsi_designator_type      sbv_designator_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///     opaque                         sbv_designator<>;\n///     uint64_t                       sbv_pr_key;\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/// struct pnfs_scsi_slice_volume_info4 {\n///     offset4  ssv_start;            /* offset of the start of\n///                                       the slice in bytes */\n///     length4  ssv_length;           /* length of slice in\n///                                       bytes */\n///     uint32_t ssv_volume;           /* array index of sliced\n///                                       volume */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///\n/// struct pnfs_scsi_concat_volume_info4 {\n///     uint32_t  scv_volumes<>;       /* array indices of volumes\n///                                       that are concatenated */\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///\n/// struct pnfs_scsi_stripe_volume_info4 {\n///     length4  ssv_stripe_unit;      /* size of stripe in bytes */\n///     uint32_t ssv_volumes<>;        /* array indices of\n///                                       volumes that are striped\n///                                       across -- MUST be same\n///                                       size */\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///\n/// union pnfs_scsi_volume4 switch (pnfs_scsi_volume_type4 type) {\n///     case PNFS_SCSI_VOLUME_BASE:\n///         pnfs_scsi_base_volume_info4 sv_simple_info;\n///     case PNFS_SCSI_VOLUME_SLICE:\n///         pnfs_scsi_slice_volume_info4 sv_slice_info;\n///     case PNFS_SCSI_VOLUME_CONCAT:\n///         pnfs_scsi_concat_volume_info4 sv_concat_info;\n///     case PNFS_SCSI_VOLUME_STRIPE:\n///         pnfs_scsi_stripe_volume_info4 sv_stripe_info;\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/// /* SCSI layout-specific type for da_addr_body */\n/// struct pnfs_scsi_deviceaddr4 {\n///     pnfs_scsi_volume4 sda_volumes<>; /* array of volumes */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"pnfs_scsi_deviceaddr4\" data structure is a structure that allows arbitrarily complex nested volume structures to be encoded. The types of aggregations that are allowed are stripes, concatenations, and slices. Note that the volume topology expressed in the \"pnfs_scsi_deviceaddr4\" data structure will always resolve to a set of \"pnfs_scsi_volume_type4\" PNFS_SCSI_VOLUME_BASE. The array of volumes is ordered such that the root of the volume hierarchy is the last element of the array. Concat, slice, and stripe volumes MUST refer to volumes defined by lower indexed elements of the array.",
      "ja": "「pnfs_scsi_deviceaddr4」データ構造は、任意に複雑なネストされたボリューム構造をエンコードできるようにする構造です。許可される集約のタイプは、ストライプ、連結、およびスライスです。 「pnfs_scsi_deviceaddr4」データ構造で表されるボリュームトポロジは、常に「pnfs_scsi_volume_type4」のセットに解決されることに注意してください。PNFS_SCSI_VOLUME_BASE。ボリュームの配列は、ボリューム階層のルートが配列の最後の要素になるように順序付けられます。連結、スライス、およびストライプボリュームは、配列の下位のインデックス付き要素によって定義されたボリュームを参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"pnfs_scsi_deviceaddr4\" data structure is returned by the server as the storage-protocol-specific opaque field \"da_addr_body\" in the \"device_addr4\" data structure by a successful GETDEVICEINFO operation [RFC5661].",
      "ja": "「pnfs_scsi_deviceaddr4」データ構造は、正常なGETDEVICEINFO操作[RFC5661]によって、「device_addr4」データ構造のストレージプロトコル固有の不透明フィールド「da_addr_body」としてサーバーから返されます。"
    },
    {
      "indent": 3,
      "text": "As noted above, all \"device_addr4\" data structures eventually resolve to a set of volumes of type PNFS_SCSI_VOLUME_BASE. Complicated volume hierarchies may be composed of dozens of volumes, each with several components; thus, the device address may require several kilobytes. The client SHOULD be prepared to allocate a large buffer to contain the result. In the case of the server returning NFS4ERR_TOOSMALL, the client SHOULD allocate a buffer of at least gdir_mincount_bytes to contain the expected result and retry the GETDEVICEINFO request.",
      "ja": "上記のように、すべての「device_addr4」データ構造は、最終的にPNFS_SCSI_VOLUME_BASEタイプのボリュームのセットに解決されます。複雑なボリューム階層は、それぞれがいくつかのコンポーネントを持つ数十のボリュームで構成される場合があります。したがって、デバイスアドレスは数キロバイトを必要とする場合があります。クライアントは、結果を格納するために大きなバッファを割り当てる準備をする必要があります。サーバーがNFS4ERR_TOOSMALLを返す場合、クライアントは、少なくともgdir_mincount_bytesのバッファーを割り当てて、予期される結果を含め、GETDEVICEINFO要求を再試行する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.4. Data Structures: Extents and Extent Lists",
      "section_title": true,
      "ja": "2.4. データ構造：エクステントとエクステントリスト"
    },
    {
      "indent": 3,
      "text": "A pNFS SCSI layout is a list of extents within a flat array of data blocks in a volume. The details of the volume topology can be determined by using the GETDEVICEINFO operation. The SCSI layout describes the individual block extents on the volume that make up the file. The offsets and length contained in an extent are specified in units of bytes.",
      "ja": "pNFS SCSIレイアウトは、ボリューム内のデータブロックのフラットアレイ内のエクステントのリストです。ボリュームトポロジの詳細は、GETDEVICEINFO操作を使用して確認できます。 SCSIレイアウトは、ファイルを構成するボリューム上の個々のブロックエクステントを記述します。エクステントに含まれるオフセットと長さは、バイト単位で指定されます。"
    },
    {
      "indent": 3,
      "text": "/// enum pnfs_scsi_extent_state4 {\n///     PNFS_SCSI_READ_WRITE_DATA = 0, /* the data located by\n///                                       this extent is valid\n///                                       for reading and\n///                                       writing. */\n///     PNFS_SCSI_READ_DATA      = 1,  /* the data located by this\n///                                       extent is valid for\n///                                       reading only; it may not\n///                                       be written. */\n///     PNFS_SCSI_INVALID_DATA   = 2,  /* the location is valid; the\n///                                       data is invalid.  It is a\n///                                       newly (pre-)allocated\n///                                       extent.  The client MUST\n///                                       not read from this\n///                                       space. */\n///     PNFS_SCSI_NONE_DATA      = 3   /* the location is invalid.\n///                                       It is a hole in the file.\n///                                       The client MUST NOT read\n///                                       from or write to this\n///                                       space. */\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///\n/// struct pnfs_scsi_extent4 {\n///     deviceid4    se_vol_id;         /* id of the volume on\n///                                        which extent of file is\n///                                        stored */\n///     offset4      se_file_offset;    /* starting byte offset\n///                                        in the file */\n///     length4      se_length;         /* size in bytes of the\n///                                        extent */\n///     offset4      se_storage_offset; /* starting byte offset\n///                                        in the volume */\n///     pnfs_scsi_extent_state4 se_state;\n///                                     /* state of this extent */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   /// /* SCSI layout-specific type for loc_body */\n   /// struct pnfs_scsi_layout4 {\n   ///     pnfs_scsi_extent4 sl_extents<>;\n   ///                                    /* extents that make up this\n   ///                                       layout */\n   /// };\n   ///\n   The SCSI layout consists of a list of extents that map the regions of\n   the file to locations on a volume.  The \"se_storage_offset\" field\n   within each extent identifies a location on the volume specified by\n   the \"se_vol_id\" field in the extent.  The \"se_vol_id\" itself is\n   shorthand for the whole topology of the volume on which the file is\n   stored.  The client is responsible for translating this volume-\n   relative offset into an offset on the appropriate underlying SCSI LU.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each extent maps a region of the file onto a portion of the specified LU. The \"se_file_offset\", \"se_length\", and \"se_state\" fields for an extent returned from the server are valid for all extents. In contrast, the interpretation of the \"se_storage_offset\" field depends on the value of \"se_state\" as follows (in increasing order):",
      "ja": "各エクステントは、ファイルの領域を指定されたLUの一部にマップします。サーバーから返されたエクステントの「se_file_offset」、「se_length」、および「se_state」フィールドは、すべてのエクステントに対して有効です。対照的に、「se_storage_offset」フィールドの解釈は、次のように「昇順」で「se_state」の値に依存します。"
    },
    {
      "indent": 3,
      "text": "PNFS_SCSI_READ_WRITE_DATA \"se_storage_offset\" is valid and points to valid/initialized data that can be read and written.",
      "ja": "PNFS_SCSI_READ_WRITE_DATA \"se_storage_offset\"は有効であり、読み書き可能な有効/初期化されたデータを指します。"
    },
    {
      "indent": 3,
      "text": "PNFS_SCSI_READ_DATA \"se_storage_offset\" is valid and points to valid/initialized data that can only be read. Write operations are prohibited.",
      "ja": "PNFS_SCSI_READ_DATA \"se_storage_offset\"は有効であり、読み取りのみが可能な有効な/初期化されたデータを指します。書き込み操作は禁止されています。"
    },
    {
      "indent": 3,
      "text": "PNFS_SCSI_INVALID_DATA \"se_storage_offset\" is valid but points to invalid, uninitialized data. This data MUST not be read from the disk until it has been initialized. A read request for a PNFS_SCSI_INVALID_DATA extent MUST fill the user buffer with zeros, unless the extent is covered by a PNFS_SCSI_READ_DATA extent of a copy-on-write file system. Write requests MUST write whole server-sized blocks to the disk; bytes not initialized by the user MUST be set to zero. Any write to storage in a PNFS_SCSI_INVALID_DATA extent changes the written portion of the extent to PNFS_SCSI_READ_WRITE_DATA; the pNFS client is responsible for reporting this change via LAYOUTCOMMIT.",
      "ja": "PNFS_SCSI_INVALID_DATA \"se_storage_offset\"は有効ですが、初期化されていない無効なデータを指しています。このデータは、初期化されるまでディスクから読み取ってはなりません。 PNFS_SCSI_INVALID_DATAエクステントの読み取り要求は、エクステントがコピーオンライトファイルシステムのPNFS_SCSI_READ_DATAエクステントでカバーされていない限り、ユーザーバッファーをゼロで埋める必要があります。書き込み要求は、サーバーサイズのブロック全体をディスクに書き込む必要があります。ユーザーが初期化していないバイトはゼロに設定する必要があります。 PNFS_SCSI_INVALID_DATAエクステント内のストレージへの書き込みは、エクステントの書き込まれた部分をPNFS_SCSI_READ_WRITE_DATAに変更します。 pNFSクライアントは、LAYOUTCOMMITを介してこの変更を報告する責任があります。"
    },
    {
      "indent": 3,
      "text": "PNFS_SCSI_NONE_DATA \"se_storage_offset\" is not valid, and this extent MAY not be used to satisfy write requests. Read requests MAY be satisfied by zero-filling as for PNFS_SCSI_INVALID_DATA. PNFS_SCSI_NONE_DATA extents MAY be returned by requests for readable extents; they are never returned if the request was for a writable extent.",
      "ja": "PNFS_SCSI_NONE_DATA \"se_storage_offset\"は無効であり、このエクステントを使用して書き込み要求を満たすことはできません。読み取り要求は、PNFS_SCSI_INVALID_DATAのようにゼロで埋めることで満たされる場合があります。 PNFS_SCSI_NONE_DATAエクステントは、読み取り可能なエクステントの要求によって返される場合があります。リクエストが書き込み可能なエクステントに対するものであった場合、それらは決して返されません。"
    },
    {
      "indent": 3,
      "text": "An extent list contains all relevant extents in increasing order of the se_file_offset of each extent; any ties are broken by increasing order of the extent state (se_state).",
      "ja": "エクステントリストには、関連するすべてのエクステントが、各エクステントのse_file_offsetの昇順で含まれています。エクステント状態（se_state）の昇順により、すべての関連付けが解除されます。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Layout Requests and Extent Lists",
      "section_title": true,
      "ja": "2.4.1. レイアウトリクエストとエクステントリスト"
    },
    {
      "indent": 3,
      "text": "Each request for a layout specifies at least three parameters: file offset, desired size, and minimum size. If the status of a request indicates success, the extent list returned MUST meet the following criteria:",
      "ja": "レイアウトの各要求は、少なくとも3つのパラメーターを指定します：ファイルオフセット、目的のサイズ、最小サイズ。リクエストのステータスが成功を示す場合、返されるエクステントリストは次の基準を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o A request for a readable (but not writable) layout MUST return either PNFS_SCSI_READ_DATA or PNFS_SCSI_NONE_DATA extents. It SHALL NOT return PNFS_SCSI_INVALID_DATA or PNFS_SCSI_READ_WRITE_DATA extents.",
      "ja": "o 読み取り可能（ただし書き込み不可）レイアウトの要求は、PNFS_SCSI_READ_DATAまたはPNFS_SCSI_NONE_DATAエクステントのいずれかを返す必要があります。 PNFS_SCSI_INVALID_DATAまたはPNFS_SCSI_READ_WRITE_DATAエクステントを返しません。"
    },
    {
      "indent": 3,
      "text": "o A request for a writable layout MUST return PNFS_SCSI_READ_WRITE_DATA or PNFS_SCSI_INVALID_DATA extents, and it MAY return additional PNFS_SCSI_READ_DATA extents for ranges covered by PNFS_SCSI_INVALID_DATA extents to allow client-side copy-on-write operations. A request for a writable layout SHALL NOT return PNFS_SCSI_NONE_DATA extents.",
      "ja": "o 書き込み可能なレイアウトのリクエストは、PNFS_SCSI_READ_WRITE_DATAまたはPNFS_SCSI_INVALID_DATAエクステントを返す必要があり、クライアント側のコピーオンライト操作を可能にするために、PNFS_SCSI_INVALID_DATAエクステントによってカバーされる範囲の追加のPNFS_SCSI_READ_DATAエクステントを返す場合があります。書き込み可能なレイアウトの要求は、PNFS_SCSI_NONE_DATAエクステントを返さないものとします（SHALL NOT）。"
    },
    {
      "indent": 3,
      "text": "o The first extent in the list MUST contain the requested starting offset.",
      "ja": "o リストの最初のエクステントには、要求された開始オフセットが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The total size of extents within the requested range MUST cover at least the minimum size. One exception is allowed: the total size MAY be smaller if only readable extents were requested and EOF is encountered.",
      "ja": "o 要求された範囲内のエクステントの合計サイズは、少なくとも最小サイズをカバーする必要があります。 1つの例外が許可されます。読み取り可能なエクステントのみが要求され、EOFが検出された場合、合計サイズは小さくなる場合があります。"
    },
    {
      "indent": 3,
      "text": "o Extents in the extent list MUST be logically contiguous for a read-only layout. For a read-write layout, the set of writable extents (i.e., excluding PNFS_SCSI_READ_DATA extents) MUST be logically contiguous. Every PNFS_SCSI_READ_DATA extent in a read-write layout MUST be covered by one or more PNFS_SCSI_INVALID_DATA extents. This overlap of PNFS_SCSI_READ_DATA and PNFS_SCSI_INVALID_DATA extents is the only permitted extent overlap.",
      "ja": "o エクステントリストのエクステントは、読み取り専用レイアウトでは論理的に隣接している必要があります。読み書きレイアウトの場合、書き込み可能なエクステントのセット（つまり、PNFS_SCSI_READ_DATAエクステントを除く）は、論理的に隣接している必要があります。読み取り/書き込みレイアウトのすべてのPNFS_SCSI_READ_DATAエクステントは、1つ以上のPNFS_SCSI_INVALID_DATAエクステントでカバーされている必要があります。 PNFS_SCSI_READ_DATAとPNFS_SCSI_INVALID_DATAのエクステントのこのオーバーラップは、許可される唯一のエクステントのオーバーラップです。"
    },
    {
      "indent": 3,
      "text": "o Extents MUST be ordered in the list by starting offset, with PNFS_SCSI_READ_DATA extents preceding PNFS_SCSI_INVALID_DATA extents in the case of equal se_file_offsets.",
      "ja": "o 等しいse_file_offsetsの場合、PNFS_SCSI_READ_DATAエクステントがPNFS_SCSI_INVALID_DATAエクステントに先行するように、エクステントは開始オフセットによってリストで順序付けられなければなりません。"
    },
    {
      "indent": 0,
      "text": " According to [RFC5661], if the minimum requested size, loga_minlength, is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has \"readily available\". Given the lack of a clear definition of this phrase, in the context of the SCSI layout type, when loga_minlength is zero, the metadata server SHOULD do the following:",
      "ja": "[RFC5661]によると、最小要求サイズloga_minlengthがゼロの場合、これは、クライアントがオフセットloga_offset以下のレイアウトを希望し、メタデータサーバーが「すぐに利用できる」ことをメタデータサーバーに示していることを示しています。このフレーズの明確な定義がないため、SCSIレイアウトタイプのコンテキストでは、loga_minlengthがゼロの場合、メタデータサーバーは次のことを行う必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o when processing requests for readable layouts, return all such layouts, even if some extents are in the PNFS_SCSI_NONE_DATA state.",
      "ja": "o 読み取り可能なレイアウトのリクエストを処理する場合、一部のエクステントがPNFS_SCSI_NONE_DATA状態であっても、そのようなレイアウトをすべて返します。"
    },
    {
      "indent": 3,
      "text": "o when processing requests for writable layouts, return extents that can be returned in the PNFS_SCSI_READ_WRITE_DATA state.",
      "ja": "o 書き込み可能なレイアウトのリクエストを処理するときに、PNFS_SCSI_READ_WRITE_DATA状態で返される可能性があるエクステントを返します。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Layout Commits",
      "section_title": true,
      "ja": "2.4.2. レイアウトコミット"
    },
    {
      "indent": 5,
      "text": "///\n/// /* SCSI layout-specific type for lou_body */\n///\n/// struct pnfs_scsi_range4 {\n///     offset4      sr_file_offset;   /* starting byte offset\n///                                       in the file */\n///     length4      sr_length;        /* size in bytes */\n/// };\n///\n/// struct pnfs_scsi_layoutupdate4 {\n///     pnfs_scsi_range4 slu_commit_list<>;\n///                                    /* list of extents that\n///                                     * now contain valid data.\n///                                     */\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"pnfs_scsi_layoutupdate4\" data structure is used by the client as the SCSI layout-specific argument in a LAYOUTCOMMIT operation. The \"slu_commit_list\" field is a list covering regions of the file layout that were previously in the PNFS_SCSI_INVALID_DATA state but have been written by the client and SHOULD now be considered in the PNFS_SCSI_READ_WRITE_DATA state. The extents in the commit list MUST be disjoint and MUST be sorted by sr_file_offset. Implementors should be aware that a server MAY be unable to commit regions at a granularity smaller than a file system block (typically 4 KB or 8 KB). As noted above, the block size that the server uses is available as an NFSv4 attribute, and any extents included in the \"slu_commit_list\" MUST be aligned to this granularity and have a size that is a multiple of this granularity. Since the block in question is in state PNFS_SCSI_INVALID_DATA, byte ranges not written SHOULD be filled with zeros. This applies even if it appears that the area being written is beyond what the client believes to be the end of file.",
      "ja": "「pnfs_scsi_layoutupdate4」データ構造は、LAYOUTCOMMIT操作のSCSIレイアウト固有の引数としてクライアントによって使用されます。 「slu_commit_list」フィールドは、以前はPNFS_SCSI_INVALID_DATA状態でしたが、クライアントによって書き込まれたファイルレイアウトの領域をカバーするリストであり、PNFS_SCSI_READ_WRITE_DATA状態で考慮される必要があります（SHOULD）。コミットリストのエクステントはばらばらである必要があり、sr_file_offsetでソートする必要があります。実装者は、サーバーがファイルシステムブロック（通常は4 KBまたは8 KB）よりも細かい単位で領域をコミットできない場合があることに注意してください。上記のように、サーバーが使用するブロックサイズはNFSv4属性として使用可能であり、「slu_commit_list」に含まれるエクステントはこの粒度に合わせて調整し、この粒度の倍数のサイズにする必要があります。問題のブロックの状態はPNFS_SCSI_INVALID_DATAであるため、書き込まれていないバイト範囲はゼロで埋める必要があります。これは、書き込まれている領域が、クライアントがファイルの終わりであると信じている領域を超えているように見えても当てはまります。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Layout Returns",
      "section_title": true,
      "ja": "2.4.3. レイアウトの返品"
    },
    {
      "indent": 3,
      "text": "A LAYOUTRETURN operation represents an explicit release of resources by the client. This MAY be done in response to a CB_LAYOUTRECALL or before any recall, in order to avoid a future CB_LAYOUTRECALL. When the LAYOUTRETURN operation specifies a LAYOUTRETURN4_FILE return type, then the \"layoutreturn_file4\" data structure specifies the region of the file layout that is no longer needed by the client.",
      "ja": "LAYOUTRETURN操作は、クライアントによるリソースの明示的な解放を表します。これは、将来のCB_LAYOUTRECALLを回避するために、CB_LAYOUTRECALLに応答して、または再呼び出しの前に実行される場合があります。 LAYOUTRETURNオペレーションがLAYOUTRETURN4_FILE戻り値の型を指定する場合、「layoutreturn_file4」データ構造は、クライアントが必要としなくなったファイルレイアウトの領域を指定します。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTRETURN operation is done without any data specific to the SCSI layout. The opaque \"lrf_body\" field of the \"layoutreturn_file4\" data structure MUST have length zero.",
      "ja": "LAYOUTRETURN操作は、SCSIレイアウトに固有のデータなしで実行されます。 「layoutreturn_file4」データ構造の不透明な「lrf_body」フィールドは、長さがゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4.4. Layout Revocation",
      "section_title": true,
      "ja": "2.4.4. レイアウトの取り消し"
    },
    {
      "indent": 3,
      "text": "Layouts MAY be unilaterally revoked by the server due to the client's lease time expiring or the client failing to return a layout that has been recalled in a timely manner. For the SCSI layout type, this is accomplished by fencing off the client from access to storage as described in Section 2.4.10. When this is done, it is necessary that all I/Os issued by the fenced-off client be rejected by the storage. This includes any in-flight I/Os that the client issued before the layout was revoked.",
      "ja": "クライアントのリース時間が満了するか、クライアントが適時にリコールされたレイアウトを返せなかったため、レイアウトはサーバーによって一方的に取り消される場合があります。 SCSIレイアウトタイプの場合、これは、セクション2.4.10で説明されているように、ストレージへのアクセスからクライアントを隔離することで実現されます。これが行われると、フェンシングされたクライアントによって発行されたすべてのI / Oがストレージによって拒否される必要があります。これには、レイアウトが取り消される前にクライアントが発行した実行中のI / Oが含まれます。"
    },
    {
      "indent": 3,
      "text": "Note that the granularity of this operation can only be at the host/ LU level. Thus, if one of a client's layouts is unilaterally revoked by the server, it will effectively render useless *all* of the client's layouts for files located on the storage units comprising the volume. This may render useless the client's layouts for files in other file systems. See Section 2.4.10.5 for a discussion of recovery from fencing.",
      "ja": "この操作の細分性は、ホスト/ LUレベルでのみ可能であることに注意してください。したがって、クライアントのレイアウトの1つがサーバーによって一方的に取り消された場合、ボリュームを構成するストレージユニットにあるファイルのクライアントのレイアウトの無用*すべて*を効果的にレンダリングします。これにより、他のファイルシステムにあるファイルのクライアントのレイアウトが役に立たなくなる可能性があります。フェンシングからの回復については、セクション2.4.10.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.5. Client Copy-on-Write Processing",
      "section_title": true,
      "ja": "2.4.5. クライアントのコピーオンライト処理"
    },
    {
      "indent": 3,
      "text": "Copy-on-write is a mechanism used to support file and/or file system snapshots. When writing to unaligned regions, or to regions smaller than a file system block, the writer MUST copy the portions of the original file data to a new location on disk. This behavior can be implemented either on the client or the server. The paragraphs below describe how a pNFS SCSI layout client implements access to a file that requires copy-on-write semantics.",
      "ja": "コピーオンライトは、ファイルやファイルシステムのスナップショットをサポートするために使用されるメカニズムです。位置合わせされていない領域、またはファイルシステムブロックより小さい領域に書き込む場合、ライターは元のファイルデータの一部をディスク上の新しい場所にコピーする必要があります。この動作は、クライアントまたはサーバーのいずれかに実装できます。以下の段落では、pNFS SCSIレイアウトクライアントが、コピーオンライトセマンティクスを必要とするファイルへのアクセスを実装する方法について説明します。"
    },
    {
      "indent": 0,
      "text": " Distinguishing the PNFS_SCSI_READ_WRITE_DATA and PNFS_SCSI_READ_DATA extent types in combination with the allowed overlap of PNFS_SCSI_READ_DATA extents with PNFS_SCSI_INVALID_DATA extents allows copy-on-write processing to be done by pNFS clients. In classic NFS, this operation would be done by the server. Since pNFS enables clients to do direct block access, it is useful for clients to participate in copy-on-write operations. All SCSI pNFS clients MUST support this copy-on-write processing.",
      "ja": "PNFS_SCSI_READ_WRITE_DATAおよびPNFS_SCSI_READ_DATAエクステントタイプとPNFS_SCSI_READ_DATAエクステントとPNFS_SCSI_INVALID_DATAエクステントの許可されたオーバーラップを組み合わせることで、pNFSクライアントによるコピーオンライト処理が可能になります。従来のNFSでは、この操作はサーバーによって行われます。 pNFSにより、クライアントは直接ブロックアクセスを行うことができるため、クライアントがコピーオンライト操作に参加すると便利です。すべてのSCSI pNFSクライアントは、このコピーオンライト処理をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to write data covered by a PNFS_SCSI_READ_DATA extent, it MUST have requested a writable layout from the server; that layout will contain PNFS_SCSI_INVALID_DATA extents to cover all the data ranges of that layout's PNFS_SCSI_READ_DATA extents. More precisely, for any se_file_offset range covered by one or more PNFS_SCSI_READ_DATA extents in a writable layout, the server MUST include one or more PNFS_SCSI_INVALID_DATA extents in the layout that cover the same se_file_offset range. When performing a write to such an area of a layout, the client MUST effectively copy the data from the PNFS_SCSI_READ_DATA extent for any partial blocks of se_file_offset and range, merge in the changes to be written, and write the result to the PNFS_SCSI_INVALID_DATA extent for the blocks for that se_file_offset and range. That is, if entire blocks of data are to be overwritten by an operation, the corresponding PNFS_SCSI_READ_DATA blocks need not be fetched, but any partial-block writes MUST be merged with data fetched via PNFS_SCSI_READ_DATA extents before storing the result via PNFS_SCSI_INVALID_DATA extents. For the purposes of this discussion, \"entire blocks\" and \"partial blocks\" refer to the block size of the server's file system. Storing of data in a PNFS_SCSI_INVALID_DATA extent converts the written portion of the PNFS_SCSI_INVALID_DATA extent to a PNFS_SCSI_READ_WRITE_DATA extent; all subsequent reads MUST be performed from this extent; the corresponding portion of the PNFS_SCSI_READ_DATA extent MUST NOT be used after storing data in a PNFS_SCSI_INVALID_DATA extent. If a client writes only a portion of an extent, the extent MAY be split at block-aligned boundaries.",
      "ja": "クライアントがPNFS_SCSI_READ_DATAエクステントの対象となるデータを書き込みたい場合は、サーバーから書き込み可能なレイアウトを要求している必要があります。そのレイアウトには、そのレイアウトのPNFS_SCSI_READ_DATAエクステントのすべてのデータ範囲をカバーするPNFS_SCSI_INVALID_DATAエクステントが含まれます。より正確には、書き込み可能なレイアウトの1つ以上のPNFS_SCSI_READ_DATAエクステントでカバーされる任意のse_file_offset範囲について、サーバーは同じse_file_offset範囲をカバーするレイアウトに1つ以上のPNFS_SCSI_INVALID_DATAエクステントを含める必要があります。レイアウトのそのような領域への書き込みを実行するとき、クライアントは、se_file_offsetおよびrangeの部分ブロックのPNFS_SCSI_READ_DATAエクステントからデータを効果的にコピーし、書き込まれる変更をマージして、結果をPNFS_SCSI_INVALID_DATAエクステントに書き込む必要があります。そのse_file_offsetと範囲のブロック。つまり、データブロック全体が操作によって上書きされる場合、対応するPNFS_SCSI_READ_DATAブロックをフェッチする必要はありませんが、PNFS_SCSI_INVALID_DATAエクステントを介して結果を保存する前に、部分ブロック書き込みをPNFS_SCSI_READ_DATAエクステントを介してフェッチしたデータとマージする必要があります。この説明では、「ブロック全体」と「部分ブロック」はサーバーのファイルシステムのブロックサイズを指します。 PNFS_SCSI_INVALID_DATAエクステントにデータを格納すると、書き込まれたPNFS_SCSI_INVALID_DATAエクステントの部分がPNFS_SCSI_READ_WRITE_DATAエクステントに変換されます。以降の読み取りはすべてこのエクステントから実行する必要があります。 PNFS_SCSI_INVALID_DATAエクステントにデータを格納した後、PNFS_SCSI_READ_DATAエクステントの対応する部分を使用してはなりません（MUST NOT）。クライアントがエクステントの一部のみを書き込む場合、エクステントはブロック境界で区切られます。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to write data to a PNFS_SCSI_INVALID_DATA extent that is not covered by a PNFS_SCSI_READ_DATA extent, it MUST treat this write identically to a write to a file not involved with copy-on-write semantics. Thus, data MUST be written in at least block-sized increments and aligned to multiples of block-sized offsets, and unwritten portions of blocks MUST be zero filled.",
      "ja": "クライアントが、PNFS_SCSI_READ_DATAエクステントでカバーされていないPNFS_SCSI_INVALID_DATAエクステントにデータを書き込みたい場合、この書き込みを、コピーオンライトセマンティクスに関係しないファイルへの書き込みと同じように扱う必要があります。したがって、データは少なくともブロックサイズの増分で書き込まれ、ブロックサイズのオフセットの倍数に揃えられなければならず、ブロックの書き込まれていない部分はゼロで埋められなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "2.4.6. Extents Are Permissions",
      "section_title": true,
      "ja": "2.4.6. エクステントは権限です"
    },
    {
      "indent": 0,
      "text": " Layout extents returned to pNFS clients grant permission to read or write; PNFS_SCSI_READ_DATA and PNFS_SCSI_NONE_DATA are read-only (PNFS_SCSI_NONE_DATA reads as zeros), and PNFS_SCSI_READ_WRITE_DATA and PNFS_SCSI_INVALID_DATA are read-write (PNFS_SCSI_INVALID_DATA reads as zeros; any write converts it to PNFS_SCSI_READ_WRITE_DATA). This is the only means a client has of obtaining permission to perform direct I/O to storage devices; a pNFS client MUST NOT perform direct I/O operations that are not permitted by an extent held by the client. Client adherence to this rule places the pNFS server in control of potentially conflicting storage device operations, enabling the server to determine what does conflict and how to avoid conflicts by granting and recalling extents to/from clients.",
      "ja": "pNFSクライアントに返されるレイアウト範囲は、読み取りまたは書き込みの許可を与えます。 PNFS_SCSI_READ_DATAおよびPNFS_SCSI_NONE_DATAは読み取り専用（PNFS_SCSI_NONE_DATAはゼロとして読み取られます）、およびPNFS_SCSI_READ_WRITE_DATAおよびPNFS_SCSI_INVALID_DATAは読み取り/書き込み（PNFS_SCSI_INVALID_DATAはゼロとして読み取られます）。これは、クライアントがストレージデバイスへの直接I / Oを実行する許可を取得する唯一の手段です。 pNFSクライアントは、クライアントが保持するエクステントによって許可されていない直接I / O操作を実行してはなりません（MUST NOT）。クライアントがこのルールを順守すると、pNFSサーバーが競合する可能性のあるストレージデバイス操作を制御できるようになり、サーバーは、クライアントとの間でエクステントを許可および再呼び出しすることで、競合する内容と競合を回避する方法を決定できます。"
    },
    {
      "indent": 3,
      "text": "If a client makes a layout request that conflicts with an existing layout delegation, the request will be rejected with the error NFS4ERR_LAYOUTTRYLATER. This client is then expected to retry the request after a short interval. During this interval, the server SHOULD recall the conflicting portion of the layout delegation from the client that currently holds it. This reject-and-retry approach does not prevent client starvation when there is contention for the layout of a particular file. For this reason, a pNFS server SHOULD implement a mechanism to prevent starvation. One possibility is that the server can maintain a queue of rejected layout requests. Each new layout request can be checked to see if it conflicts with a previous rejected request, and if so, the newer request can be rejected. Once the original requesting client retries its request, its entry in the rejected request queue can be cleared, or the entry in the rejected request queue can be removed when it reaches a certain age.",
      "ja": "クライアントが既存のレイアウト委任と競合するレイアウト要求を行うと、その要求はエラーNFS4ERR_LAYOUTTRYLATERで拒否されます。このクライアントは、短い間隔の後で要求を再試行することが期待されています。この間隔の間、サーバーは、現在それを保持しているクライアントからのレイアウト委譲の競合する部分を再呼び出しする必要があります（SHOULD）。この拒否と再試行のアプローチは、特定のファイルのレイアウトに競合がある場合のクライアントの枯渇を防ぎません。このため、pNFSサーバーは、枯渇を防ぐメカニズムを実装する必要があります（SHOULD）。 1つの可能性は、サーバーが拒否されたレイアウト要求のキューを維持できることです。それぞれの新しいレイアウトリクエストをチェックして、以前の拒否されたリクエストと競合していないかどうかを確認できます。競合している場合は、新しいリクエストを拒否できます。元の要求側クライアントが要求を再試行すると、拒否された要求キュー内のエントリをクリアするか、一定の期間に達したときに拒否された要求キュー内のエントリを削除できます。"
    },
    {
      "indent": 3,
      "text": "NFSv4 supports mandatory locks and share reservations. These are mechanisms that clients can use to restrict the set of I/O operations that are permissible to other clients. Since all I/O operations ultimately arrive at the NFSv4 server for processing, the server is in a position to enforce these restrictions. However, with pNFS layouts, I/Os will be issued from the clients that hold the layouts directly to the storage devices that host the data. These devices have no knowledge of files, mandatory locks, or share reservations, and they are not in a position to enforce such restrictions. For this reason, the NFSv4 server MUST NOT grant layouts that conflict with mandatory locks or share reservations. Further, if a conflicting mandatory lock request or a conflicting OPEN request arrives at the server, the server MUST recall the part of the layout in conflict with the request before granting the request.",
      "ja": "NFSv4は、強制ロックと共有予約をサポートしています。これらは、クライアントが他のクライアントに許可されるI / O操作のセットを制限するために使用できるメカニズムです。すべてのI / O操作は最終的に処理のためにNFSv4サーバーに到着するので、サーバーはこれらの制限を実施する立場にあります。ただし、pNFSレイアウトでは、レイアウトを直接保持するクライアントから、データをホストするストレージデバイスにI / Oが発行されます。これらのデバイスは、ファイル、強制ロック、または共有予約についての知識がなく、そのような制限を強制する立場にはありません。このため、NFSv4サーバーは、強制ロックまたは共有予約と競合するレイアウトを許可してはなりません。さらに、競合する強制ロック要求または競合するOPEN要求がサーバーに到着した場合、サーバーは、要求を許可する前に、要求と競合するレイアウトの部分をリコールする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.7. Partial-Block Updates",
      "section_title": true,
      "ja": "2.4.7. 部分ブロック更新"
    },
    {
      "indent": 0,
      "text": " SCSI storage devices do not provide byte granularity access and can only perform read and write operations atomically on a block granularity. Writes to SCSI storage devices thus require read-modify-write cycles to write data that is smaller than the block size or that is otherwise not block aligned. Write operations from multiple clients to the same block can thus lead to data corruption even if the byte range written by the applications does not overlap. When there are multiple clients who wish to access the same block, a pNFS server MUST avoid these conflicts by implementing a concurrency control policy of single writer XOR multiple readers for a given data block.",
      "ja": "SCSIストレージデバイスは、バイト単位のアクセスを提供せず、読み取りおよび書き込み操作をブロック単位でアトミックにのみ実行できます。したがって、SCSIストレージデバイスへの書き込みでは、ブロックサイズよりも小さいデータ、またはブロックアラインされていないデータを書き込むために、読み取り-変更-書き込みサイクルが必要です。したがって、複数のクライアントから同じブロックへの書き込み操作は、アプリケーションによって書き込まれたバイト範囲がオーバーラップしていなくても、データの破損を引き起こす可能性があります。同じブロックにアクセスするクライアントが複数ある場合、pNFSサーバーは、特定のデータブロックに対して単一のライターXOR複数のリーダーの同時実行制御ポリシーを実装することにより、これらの競合を回避する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.8. End-of-File Processing",
      "section_title": true,
      "ja": "2.4.8. ファイルの終わり処理"
    },
    {
      "indent": 3,
      "text": "The end-of-file location can be changed in two ways: implicitly as the result of a WRITE or LAYOUTCOMMIT beyond the current end of file or explicitly as the result of a SETATTR request. Typically, when a file is truncated by an NFSv4 client via the SETATTR call, the server frees any disk blocks belonging to the file that are beyond the new end-of-file byte and MUST write zeros to the portion of the new end-of-file block beyond the new end-of-file byte. These actions render semantically invalid any pNFS layouts that refer to the blocks that are freed or written. Therefore, the server MUST recall from clients the portions of any pNFS layouts that refer to blocks that will be freed or written by the server before effecting the file truncation. These recalls may take time to complete; as explained in [RFC5661], if the server cannot respond to the client SETATTR request in a reasonable amount of time, it SHOULD reply to the client with the error NFS4ERR_DELAY.",
      "ja": "ファイルの終わりの場所は、2つの方法で変更できます。現在のファイルの終わりを超えるWRITEまたはLAYOUTCOMMITの結果として暗黙的に、またはSETATTR要求の結果として明示的に変更できます。通常、ファイルがSETATTR呼び出しを介してNFSv4クライアントによって切り捨てられると、サーバーはファイルに属するディスクブロックを解放し、新しいファイルの終わりバイトを超えて、新しい終わりの部分にゼロを書き込む必要があります。 -新しいファイル終了バイトを超えるファイルブロック。これらのアクションは、解放または書き込まれたブロックを参照するすべてのpNFSレイアウトを意味的に無効にします。したがって、サーバーは、ファイルの切り捨てを行う前にサーバーによって解放または書き込まれるブロックを参照するpNFSレイアウトの部分をクライアントからリコールする必要があります。これらのリコールは完了するのに時間がかかる場合があります。 [RFC5661]で説明されているように、サーバーが妥当な時間内にクライアントのSETATTR要求に応答できない場合は、NFS4ERR_DELAYエラーでクライアントに応答する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Blocks in the PNFS_SCSI_INVALID_DATA state that lie beyond the new end-of-file block present a special case. The server has reserved these blocks for use by a pNFS client with a writable layout for the file, but the client has yet to commit the blocks, and they are not yet a part of the file mapping on disk. The server MAY free these blocks while processing the SETATTR request. If so, the server MUST recall any layouts from pNFS clients that refer to the blocks before processing the truncate. If the server does not free the PNFS_SCSI_INVALID_DATA blocks while processing the SETATTR request, it need not recall layouts that refer only to the PNFS_SCSI_INVALID_DATA blocks.",
      "ja": "PNFS_SCSI_INVALID_DATA状態のブロックで、新しいファイルの終わりブロックを超えている場合は、特殊なケースになります。サーバーはこれらのブロックを、ファイルの書き込み可能なレイアウトでpNFSクライアントが使用するために予約していますが、クライアントはまだブロックをコミットしておらず、まだディスク上のファイルマッピングの一部ではありません。サーバーは、SETATTR要求の処理中にこれらのブロックを解放する場合があります。その場合、サーバーは、切り捨てを処理する前に、ブロックを参照するpNFSクライアントからのレイアウトをリコールする必要があります。サーバーがSETATTR要求の処理中にPNFS_SCSI_INVALID_DATAブロックを解放しない場合、PNFS_SCSI_INVALID_DATAブロックのみを参照するレイアウトを再呼び出しする必要はありません。"
    },
    {
      "indent": 3,
      "text": "When a file is extended implicitly by a WRITE or LAYOUTCOMMIT beyond the current end of file, or extended explicitly by a SETATTR request, the server need not recall any portions of any pNFS layouts.",
      "ja": "ファイルが現在のファイルの終わりを超えてWRITEまたはLAYOUTCOMMITによって暗黙的に拡張された場合、またはSETATTR要求によって明示的に拡張された場合、サーバーはpNFSレイアウトの一部を呼び出す必要はありません。"
    },
    {
      "indent": 0,
      "text": "2.4.9. Layout Hints",
      "section_title": true,
      "ja": "2.4.9. レイアウトのヒント"
    },
    {
      "indent": 3,
      "text": "The layout hint attribute specified in [RFC5661] is not supported by the SCSI layout, and the pNFS server MUST reject setting a layout hint attribute with a loh_type value of LAYOUT4_SCSI_VOLUME during OPEN or SETATTR operations. On a file system only supporting the SCSI layout, a server MUST NOT report the layout_hint attribute in the supported_attrs attribute.",
      "ja": "[RFC5661]で指定されたレイアウトヒント属性はSCSIレイアウトでサポートされていません。pNFSサーバーは、OPENまたはSETATTR操作中にloh_type値がLAYOUT4_SCSI_VOLUMEのレイアウトヒント属性の設定を拒否する必要があります。 SCSIレイアウトのみをサポートするファイルシステムでは、サーバーは、supported_attrs属性のlayout_hint属性を報告してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "2.4.10. Client Fencing",
      "section_title": true,
      "ja": "2.4.10. クライアントフェンシング"
    },
    {
      "indent": 3,
      "text": "The pNFS SCSI protocol must handle situations in which a system failure, typically a network connectivity issue, requires the server to unilaterally revoke extents from a client after the client fails to respond to a CB_LAYOUTRECALL request. This is implemented by fencing off a non-responding client from access to the storage device.",
      "ja": "pNFS SCSIプロトコルは、クライアントがCB_LAYOUTRECALL要求への応答に失敗した後、サーバーがクライアントからエクステントを一方的に取り消す必要があるシステム障害（通常はネットワーク接続の問題）を処理する必要があります。これは、応答しないクライアントがストレージデバイスにアクセスできないようにすることで実装されます。"
    },
    {
      "indent": 3,
      "text": "The pNFS SCSI protocol implements fencing using persistent reservations (PRs), similar to the fencing method used by existing shared disk file systems. By placing a PR of type \"Exclusive Access - Registrants Only\" on each SCSI LU exported to pNFS clients, the MDS prevents access from any client that does not have an outstanding device ID that gives the client a reservation key to access the LU and allows the MDS to revoke access to the logical unit at any time.",
      "ja": "pNFS SCSIプロトコルは、既存の共有ディスクファイルシステムで使用されているフェンシング方式と同様に、永続的予約（PR）を使用してフェンシングを実装します。 pNFSクライアントにエクスポートされた各SCSI LUにタイプ「Exclusive Access-Registrants Only」のPRを配置することにより、MDSは、クライアントにLUにアクセスするための予約キーを与え、許可する未解決のデバイスIDを持たないクライアントからのアクセスを防止しますいつでも論理ユニットへのアクセスを取り消すためのMDS。"
    },
    {
      "indent": 0,
      "text": "2.4.10.1. PRs -- Key Generation",
      "section_title": true,
      "ja": "2.4.10.1. PR-鍵の生成"
    },
    {
      "indent": 3,
      "text": "To allow fencing individual systems, each system MUST use a unique persistent reservation key. [SPC4] does not specify a way to generate keys. This document assigns the burden to generate unique keys to the MDS, which MUST generate a key for itself before exporting a volume and a key for each client that accesses SCSI layout volumes. Individuals keys for each volume that a client can access are permitted but not required.",
      "ja": "個別のシステムをフェンシングできるようにするには、各システムで一意の永続予約キーを使用する必要があります。 [SPC4]は、キーを生成する方法を指定していません。このドキュメントは、MDSに一意のキーを生成する負担を割り当てます。MDSは、ボリュームをエクスポートする前にそれ自体のキーと、SCSIレイアウトボリュームにアクセスする各クライアントのキーを生成する必要があります。クライアントがアクセスできる各ボリュームの個別キーは許可されますが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "2.4.10.2. PRs -- MDS Registration and Reservation",
      "section_title": true,
      "ja": "2.4.10.2. PR-MDSの登録と予約"
    },
    {
      "indent": 3,
      "text": "Before returning a PNFS_SCSI_VOLUME_BASE volume to the client, the MDS needs to prepare the volume for fencing using PRs. This is done by registering the reservation generated for the MDS with the device using the \"PERSISTENT RESERVE OUT\" command with a service action of \"REGISTER\", followed by a \"PERSISTENT RESERVE OUT\" command with a service action of \"RESERVE\" and the \"TYPE\" field set to 8h (Exclusive Access - Registrants Only). To make sure all I_T nexuses (see Section 3.1.45 of [SAM-5]) are registered, the MDS SHOULD set the \"All Target Ports\" (ALL_TG_PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.",
      "ja": "PNFS_SCSI_VOLUME_BASEボリュームをクライアントに返す前に、MDSはPRを使用してフェンシング用のボリュームを準備する必要があります。これは、「REGISTER」のサービスアクションを指定した「PERSISTENT RESERVE OUT」コマンドを使用し、その後に「RESERVE」のサービスアクションを指定した「PERSISTENT RESERVE OUT」コマンドを使用して、MDS用に生成された予約をデバイスに登録することで行われます。 「タイプ」フィールドは8hに設定されます（排他的アクセス-登録者のみ）。すべてのI_Tネクサス（[SAM-5]のセクション3.1.45を参照）が登録されていることを確認するために、MDSはキーの登録時に「すべてのターゲットポート」（ALL_TG_PT）ビットを設定するか、そうでなければ各ターゲットに対して登録が実行されるようにしますポート、および各イニシエーターポートの登録を実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.10.3. PRs -- Client Registration",
      "section_title": true,
      "ja": "2.4.10.3. PR-クライアント登録"
    },
    {
      "indent": 0,
      "text": " Before performing the first I/O to a device returned from a GETDEVICEINFO operation, the client will register the registration key returned in sbv_pr_key with the storage device by issuing a \"PERSISTENT RESERVE OUT\" command with a service action of REGISTER with the \"SERVICE ACTION RESERVATION KEY\" set to the reservation key returned in sbv_pr_key. To make sure all I_T nexuses are registered, the client SHOULD set the \"All Target Ports\" (ALL_TG_PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.",
      "ja": "GETDEVICEINFO操作から返されたデバイスに対して最初のI / Oを実行する前に、クライアントはsbv_pr_keyに返された登録キーをストレージデバイスに登録します予約キー」は、sbv_pr_keyで返される予約キーに設定されています。すべてのI_Tネクサスが登録されていることを確認するために、クライアントはキーを登録するときに「すべてのターゲットポート」（ALL_TG_PT）ビットを設定する必要があります。そうでない場合、各ターゲットポートに対して登録が実行され、各イニシエーターポートに対して登録を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client stops using a device earlier returned by GETDEVICEINFO, it MUST unregister the earlier registered key by issuing a \"PERSISTENT RESERVE OUT\" command with a service action of \"REGISTER\" with the \"RESERVATION KEY\" set to the earlier registered reservation key.",
      "ja": "クライアントが以前にGETDEVICEINFOから返されたデバイスの使用を停止した場合、「予約キー」が以前に登録された予約キーに設定された「登録」のサービスアクションを指定して「永続的予約アウト」コマンドを発行して、以前に登録されたキーの登録を解除する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.10.4. PRs -- Fencing Action",
      "section_title": true,
      "ja": "2.4.10.4. PR-フェンシングアクション"
    },
    {
      "indent": 3,
      "text": "In case of a non-responding client, the MDS fences the client by issuing a \"PERSISTENT RESERVE OUT\" command with the service action set to \"PREEMPT\" or \"PREEMPT AND ABORT\", the \"RESERVATION KEY\" field set to the server's reservation key, the service action \"RESERVATION KEY\" field set to the reservation key associated with the non-responding client, and the \"TYPE\" field set to 8h (Exclusive Access - Registrants Only).",
      "ja": "クライアントが応答しない場合、MDSは、サービスアクションが「PREEMPT」または「PREEMPT AND ABORT」に設定された「PERSISTENT RESERVE OUT」コマンドを発行することにより、クライアントをフェンスします。「RESERVATION KEY」フィールドはサーバーの予約に設定されますキー、応答しないクライアントに関連付けられた予約キーに設定されたサービスアクションの[予約キー]フィールド、および8hに設定された[タイプ]フィールド（排他的アクセス-登録者のみ）。"
    },
    {
      "indent": 3,
      "text": "After the MDS preempts a client, all client I/O to the LU fails. The client SHOULD at this point return any layout that refers to the device ID that points to the LU. Note that the client can distinguish I/O errors due to fencing from other errors based on the \"RESERVATION CONFLICT\" SCSI status. Refer to [SPC4] for details.",
      "ja": "MDSがクライアントをプリエンプトした後、LUへのすべてのクライアントI / Oが失敗します。この時点でクライアントは、LUを指すデバイスIDを参照するレイアウトを返す必要があります（SHOULD）。クライアントは、フェンシングが原因のI / Oエラーを、「RESERVATION CONFLICT」SCSIステータスに基づいて他のエラーと区別できることに注意してください。詳細については、[SPC4]を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.10.5. Client Recovery after a Fence Action",
      "section_title": true,
      "ja": "2.4.10.5. フェンスアクション後のクライアントの回復"
    },
    {
      "indent": 3,
      "text": "A client that detects a \"RESERVATION CONFLICT\" SCSI status (I/O error) on the storage devices MUST commit all layouts that use the storage device through the MDS, return all outstanding layouts for the device, forget the device ID, and unregister the reservation key. Future GETDEVICEINFO calls MAY refer to the storage device again, in which case the client will perform a new registration based on the key provided (via sbv_pr_key) at that time.",
      "ja": "ストレージデバイスで「RESERVATION CONFLICT」SCSIステータス（I / Oエラー）を検出するクライアントは、MDSを介してストレージデバイスを使用するすべてのレイアウトをコミットし、デバイスのすべての未解決のレイアウトを返し、デバイスIDを忘れて、登録を解除する必要があります予約キー。今後のGETDEVICEINFO呼び出しは、ストレージデバイスを再び参照する可能性があります。その場合、クライアントは、その時点で（sbv_pr_keyを介して）提供されたキーに基づいて新しい登録を実行します。"
    },
    {
      "indent": 0,
      "text": "2.5. Crash Recovery Issues",
      "section_title": true,
      "ja": "2.5. クラッシュリカバリの問題"
    },
    {
      "indent": 3,
      "text": "A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. These requirements and a full discussion of crash recovery issues are covered in Section 8.4 (\"Crash Recovery\") of the NFSv4.1 specification [RFC5661]. This document contains additional crash recovery material specific only to the SCSI layout.",
      "ja": "クラッシュリカバリの重要な要件は、クライアントとサーバーの両方が、どちらが失敗したかを知ることです。さらに、サーバーの再起動後もクライアントはデータの一貫したビューを見る必要があります。これらの要件とクラッシュリカバリの問題の詳細については、NFSv4.1仕様[RFC5661]のセクション8.4（「クラッシュリカバリ」）で説明されています。このドキュメントには、SCSIレイアウトのみに固有の追加のクラッシュ回復資料が含まれています。"
    },
    {
      "indent": 3,
      "text": "When the server crashes while the client holds a writable layout, the client has written data to blocks covered by the layout, and the blocks are still in the PNFS_SCSI_INVALID_DATA state, the client has two options for recovery. If the data that has been written to these blocks is still cached by the client, the client can simply re-write the data via NFSv4 once the server has come back online. However, if the data is no longer in the client's cache, the client MUST NOT attempt to source the data from the data servers. Instead, it SHOULD attempt to commit the blocks in question to the server during the server's recovery grace period by sending a LAYOUTCOMMIT with the \"loca_reclaim\" flag set to true. This process is described in detail in Section 18.42.4 of [RFC5661].",
      "ja": "クライアントが書き込み可能なレイアウトを保持しているときにサーバーがクラッシュすると、クライアントはレイアウトによってカバーされるブロックにデータを書き込み、ブロックはまだPNFS_SCSI_INVALID_DATA状態にあり、クライアントには2つのリカバリオプションがあります。これらのブロックに書き込まれたデータがまだクライアントによってキャッシュされている場合、サーバーがオンラインに戻ったら、クライアントはNFSv4を介してデータを再書き込みすることができます。ただし、データがクライアントのキャッシュに存在しない場合、クライアントはデータサーバーからデータを取得しようとしてはなりません（MUST NOT）。代わりに、 \"loca_reclaim\"フラグをtrueに設定してLAYOUTCOMMITを送信することにより、サーバーの回復猶予期間中に問題のブロックをサーバーにコミットしようとする必要があります（SHOULD）。このプロセスは、[RFC5661]のセクション18.42.4で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "2.6. Recalling Resources: CB_RECALL_ANY",
      "section_title": true,
      "ja": "2.6. リソースの呼び出し：CB_RECALL_ANY"
    },
    {
      "indent": 3,
      "text": "The server MAY decide that it cannot hold all of the state for layouts without running out of resources. In such a case, it is free to recall individual layouts using CB_LAYOUTRECALL to reduce the load, or it MAY choose to request that the client return any layout.",
      "ja": "サーバーは、リソースを使い果たすことなくレイアウトのすべての状態を保持することはできないと判断する場合があります。このような場合、負荷を軽減するためにCB_LAYOUTRECALLを使用して個々のレイアウトを自由に呼び出すことができます。または、クライアントが任意のレイアウトを返すように要求することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 specification [RFC5661] defines the following types:",
      "ja": "NFSv4.1仕様[RFC5661]では、次のタイプが定義されています。"
    },
    {
      "indent": 7,
      "text": "const RCA4_TYPE_MASK_BLK_LAYOUT = 4;",
      "ja": "const RCA4_TYPE_MASK_BLK_LAYOUT = 4;"
    },
    {
      "indent": 7,
      "text": "struct CB_RECALL_ANY4args {\n       uint32_t      craa_objects_to_keep;\n       bitmap4       craa_type_mask;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the server sends a CB_RECALL_ANY request to a client specifying the RCA4_TYPE_MASK_BLK_LAYOUT bit in craa_type_mask, the client SHOULD immediately respond with NFS4_OK and then asynchronously return complete file layouts until the number of files with layouts cached on the client is less than craa_object_to_keep.",
      "ja": "サーバーがcraa_type_maskのRCA4_TYPE_MASK_BLK_LAYOUTビットを指定してクライアントにCB_RECALL_ANY要求を送信すると、クライアントはすぐにNFS4_OKで応答し、その後、クライアントにキャッシュされたレイアウトを持つファイルの数がcraa_object_to_keep未満になるまで完全なファイルレイアウトを非同期的に返します。"
    },
    {
      "indent": 0,
      "text": "2.7. Transient and Permanent Errors",
      "section_title": true,
      "ja": "2.7. 一時的および永続的なエラー"
    },
    {
      "indent": 3,
      "text": "The server may respond to LAYOUTGET with a variety of error statuses. These errors can convey transient conditions or more permanent conditions that are unlikely to be resolved soon.",
      "ja": "サーバーは、さまざまなエラーステータスでLAYOUTGETに応答する場合があります。これらのエラーは、一時的な状態、またはすぐには解決されそうにないより永続的な状態を伝える可能性があります。"
    },
    {
      "indent": 3,
      "text": "The error NFS4ERR_RECALLCONFLICT indicates that the server has recently issued a CB_LAYOUTRECALL to the requesting client, making it necessary for the client to respond to the recall before processing the layout request. A client can wait for that recall to be received and processed, or it can retry as NFS4ERR_TRYLATER, as described below.",
      "ja": "エラーNFS4ERR_RECALLCONFLICTは、サーバーが要求側のクライアントに最近CB_LAYOUTRECALLを発行したことを示し、クライアントはレイアウト要求を処理する前に再呼び出しに応答する必要があります。クライアントは、そのリコールが受信されて処理されるのを待つか、以下に説明するようにNFS4ERR_TRYLATERとして再試行できます。"
    },
    {
      "indent": 3,
      "text": "The error NFS4ERR_TRYLATER is used to indicate that the server cannot immediately grant the layout to the client. This may be due to constraints on writable sharing of blocks by multiple clients or to a conflict with a recallable lock (e.g., a delegation). In either case, a reasonable approach for the client is to wait several milliseconds and retry the request. The client SHOULD track the number of retries, and if forward progress is not made, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the server.",
      "ja": "エラーNFS4ERR_TRYLATERは、サーバーがレイアウトをクライアントにすぐに付与できないことを示すために使用されます。これは、複数のクライアントによるブロックの書き込み可能な共有に対する制約、またはリコール可能なロック（委任など）との競合が原因である可能性があります。どちらの場合も、クライアントの合理的なアプローチは、数ミリ秒待ってから要求を再試行することです。クライアントは再試行の回数を追跡する必要があり（SHOULD）、フォワードプログレスが行われない場合、クライアントはレイアウトを取得してサーバーに送信することによりREADおよびWRITE操作を実行する試みを中止する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The error NFS4ERR_LAYOUTUNAVAILABLE MAY be returned by the server if layouts are not supported for the requested file or its containing file system. The server MAY also return this error code if the server is in the process of migrating the file from secondary storage, there is a conflicting lock that would prevent the layout from being granted, or any other reason causes the server to be unable to supply the layout. As a result of receiving NFS4ERR_LAYOUTUNAVAILABLE, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the MDS. It is expected that a client will not cache the file's layoutunavailable state forever. In particular, when the file is closed or opened by the client, issuing a new LAYOUTGET is appropriate.",
      "ja": "要求されたファイルまたはそれを含むファイルシステムでレイアウトがサポートされていない場合、サーバーからエラーNFS4ERR_LAYOUTUNAVAILABLEが返されることがあります。サーバーがセカンダリストレージからファイルを移行しているとき、レイアウトの許可を妨げる競合するロックがある場合、またはその他の理由によりサーバーがサーバーに供給できない場合、サーバーはこのエラーコードを返す場合があります。レイアウト。 NFS4ERR_LAYOUTUNAVAILABLEを受信した結果として、クライアントは、レイアウトを取得し、それらをMDSに送信することによってREADおよびWRITE操作を実行する試みを中止する必要があります（SHOULD）。クライアントがファイルのレイアウトが使用できない状態を永久にキャッシュしないことが予想されます。特に、ファイルがクライアントによってクローズまたはオープンされた場合、新しいLAYOUTGETを発行することが適切です。"
    },
    {
      "indent": 0,
      "text": "2.8. Volatile Write Caches",
      "section_title": true,
      "ja": "2.8. 揮発性書き込みキャッシュ"
    },
    {
      "indent": 3,
      "text": "Many storage devices implement volatile write caches that require an explicit flush to persist the data from write operations to stable storage. Storage devices implementing [SBC3] should indicate a volatile write cache by setting the Write Cache Enable (WCE) bit to 1 in the Caching mode page. When a volatile write cache is used, the pNFS server MUST ensure the volatile write cache has been committed to stable storage before the LAYOUTCOMMIT operation returns by using one of the SYNCHRONIZE CACHE commands.",
      "ja": "多くのストレージデバイスは、書き込み操作から安定したストレージへのデータを永続化するために明示的なフラッシュを必要とする揮発性書き込みキャッシュを実装しています。 [SBC3]を実装するストレージデバイスは、キャッシングモードページで書き込みキャッシュイネーブル（WCE）ビットを1に設定して、揮発性書き込みキャッシュを示す必要があります。揮発性書き込みキャッシュを使用する場合、pNFSサーバーは、SYNCHRONIZE CACHEコマンドの1つを使用してLAYOUTCOMMIT操作が戻る前に、揮発性書き込みキャッシュが安定したストレージにコミットされていることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Enforcing NFSv4 Semantics",
      "section_title": true,
      "ja": "3. NFSv4セマンティクスの実施"
    },
    {
      "indent": 3,
      "text": "The functionality provided by SCSI persistent reservations makes it possible for the MDS to control access by individual client machines to specific LUs. Individual client machines may be allowed to or prevented from reading or writing to certain block devices. Finer-grained access control methods are not generally available.",
      "ja": "SCSI永続予約によって提供される機能により、MDSは個々のクライアントマシンから特定のLUへのアクセスを制御できます。個々のクライアントマシンは、特定のブロックデバイスに対する読み取りまたは書き込みを許可または禁止できます。よりきめの細かいアクセス制御方法は一般に利用できません。"
    },
    {
      "indent": 0,
      "text": " For this reason, certain responsibilities for enforcing NFSv4 semantics, including security and locking, are delegated to pNFS clients when SCSI layouts are being used. The metadata server's role is to only grant layouts appropriately, and the pNFS clients have to be trusted to only perform accesses allowed by the layout extents they currently hold (e.g., not access storage for files on which a layout extent is not held). In general, the server will not be able to prevent a client that holds a layout for a file from accessing parts of the physical disk not covered by the layout. Similarly, the server will not be able to prevent a client from accessing blocks covered by a layout that it has already returned. The pNFS client must respect the layout model for this mapping type to appropriately respect NFSv4 semantics.",
      "ja": "このため、SCSIレイアウトが使用されている場合、セキュリティやロックなど、NFSv4セマンティクスを適用するための特定の責任はpNFSクライアントに委任されます。メタデータサーバーの役割は、レイアウトを適切に付与することだけです。pNFSクライアントは、現在保持しているレイアウト範囲によって許可されているアクセスのみを実行することを信頼されている必要があります（たとえば、レイアウト範囲が保持されていないファイルのストレージにアクセスしない）。一般に、サーバーは、ファイルのレイアウトを保持するクライアントが、レイアウトでカバーされていない物理ディスクの部分にアクセスすることを防ぐことができません。同様に、サーバーは、クライアントが既に返したレイアウトでカバーされているブロックにクライアントがアクセスするのを防ぐことができません。 pNFSクライアントは、NFSv4セマンティクスを適切に尊重するために、このマッピングタイプのレイアウトモデルを尊重する必要があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, there is no way for the storage to determine the specific NFSv4 entity (principal, openowner, lockowner) on whose behalf the I/O operation is being done. This fact may limit the functionality to be supported and require the pNFS client to implement server policies other than those describable by layouts. In cases in which layouts previously granted become invalid, the server has the option of recalling them. In situations in which communication difficulties prevent this from happening, layouts may be revoked by the server. This revocation is accompanied by changes in persistent reservation that have the effect of preventing SCSI access to the LUs in question by the client.",
      "ja": "さらに、I / O操作が実行されている特定のNFSv4エンティティ（プリンシパル、openowner、lockowner）をストレージが判断する方法はありません。この事実により、サポートされる機能が制限され、pNFSクライアントがレイアウトで記述できるもの以外のサーバーポリシーを実装する必要があります。以前に許可されたレイアウトが無効になった場合、サーバーはそれらを再呼び出しすることができます。通信の問題が原因でこれが発生しない場合、レイアウトがサーバーによって取り消されることがあります。この取り消しには、クライアントによる問題のLUへのSCSIアクセスを防止する効果がある永続的な予約の変更が伴います。"
    },
    {
      "indent": 0,
      "text": "3.1. Use of Open Stateids",
      "section_title": true,
      "ja": "3.1. オープンステートIDの使用"
    },
    {
      "indent": 3,
      "text": "The effective implementation of these NFSv4 semantic constraints is complicated by the different granularities of the actors for the different types of the functionality to be enforced:",
      "ja": "これらのNFSv4セマンティック制約の効果的な実装は、実行されるさまざまなタイプの機能のアクターのさまざまな細分性によって複雑になります。"
    },
    {
      "indent": 3,
      "text": "o To enforce security constraints for particular principals.",
      "ja": "o 特定のプリンシパルにセキュリティ制約を適用します。"
    },
    {
      "indent": 3,
      "text": "o To enforce locking constraints for particular owners (openowners and lockowners).",
      "ja": "o 特定の所有者（openownersおよびlockowners）にロック制約を適用します。"
    },
    {
      "indent": 3,
      "text": "Fundamental to enforcing both of these sorts of constraints is the principle that a pNFS client must not issue a SCSI I/O operation unless it possesses both:",
      "ja": "これらの両方の種類の制約を強制するための基本は、pNFSクライアントが両方を所有しない限り、SCSI I / O操作を発行してはならないという原則です。"
    },
    {
      "indent": 3,
      "text": "o A valid open stateid for the file in question, performing the I/O that allows I/O of the type in question, which is associated with the openowner and principal on whose behalf the I/O is to be done.",
      "ja": "o 問題のファイルの有効なオープン状態ID。問題のタイプのI / Oを許可するI / Oを実行します。これは、I / Oが行われることになっているopenownerとプリンシパルに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "o A valid layout stateid for the file in question that covers the byte range on which the I/O is to be done and that allows I/O of that type to be done.",
      "ja": "o I / Oが実行されるバイト範囲をカバーし、そのタイプのI / Oを実行できるようにする、問題のファイルの有効なレイアウト状態ID。"
    },
    {
      "indent": 3,
      "text": "As a result, if the equivalent of I/O with an anonymous or write-bypass stateid is to be done, it MUST NOT by done using the pNFS SCSI layout type. The client MAY attempt such I/O using READs and WRITEs that do not use pNFS and are directed to the MDS.",
      "ja": "その結果、匿名または書き込みバイパスの状態IDと同等のI / Oを行う場合は、pNFS SCSIレイアウトタイプを使用して行わないでください。クライアントは、pNFSを使用せず、MDSに送信されるREADおよびWRITEを使用して、このようなI / Oを試行できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "When open stateids are revoked, due to lease expiration or any form of administrative revocation, the server MUST recall all layouts that allow I/O to be done on any of the files for which open revocation happens. When there is a failure to successfully return those layouts, the client MUST be fenced.",
      "ja": "リースの有効期限または何らかの形での管理上の取り消しにより、オープン状態のIDが取り消されると、サーバーは、オープン取り消しが発生するファイルのいずれかでI / Oを実行できるようにするすべてのレイアウトを再呼び出しする必要があります。それらのレイアウトを正常に返すことに失敗した場合、クライアントはフェンスされなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.2. Enforcing Security Restrictions",
      "section_title": true,
      "ja": "3.2. セキュリティ制限の実施"
    },
    {
      "indent": 3,
      "text": "The restriction noted above provides adequate enforcement of appropriate security restriction when the principal issuing the I/O is the same as that opening the file. The server is responsible for checking that the I/O mode requested by the OPEN is allowed for the principal doing the OPEN. If the correct sort of I/O is done on behalf of the same principal, then the security restriction is thereby enforced.",
      "ja": "上記の制限により、I / Oを発行するプリンシパルがファイルを開いているプリンシパルと同じである場合、適切なセキュリティ制限が適切に適用されます。サーバーは、OPENによって要求されたI / Oモードが、OPENを実行するプリンシパルに許可されていることを確認する責任があります。同じプリンシパルに代わって正しい種類のI / Oが実行されると、セキュリティ制限が適用されます。"
    },
    {
      "indent": 3,
      "text": "If I/O is done by a principal different from the one that opened the file, the client SHOULD send the I/O to be performed by the metadata server rather than doing it directly to the storage device.",
      "ja": "I / Oがファイルを開いたプリンシパルとは異なるプリンシパルによって行われる場合、クライアントは、ストレージデバイスに対して直接行うのではなく、メタデータサーバーによって実行されるI / Oを送信する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "3.3. Enforcing Locking Restrictions",
      "section_title": true,
      "ja": "3.3. ロック制限の実施"
    },
    {
      "indent": 3,
      "text": "Mandatory enforcement of whole-file locking by means of share reservations is provided when the pNFS client obeys the requirement set forth in Section 3.1. Since performing I/O requires a valid open stateid, an I/O that violates an existing share reservation would only be possible when the server allows conflicting open stateids to exist.",
      "ja": "共有予約によるファイル全体のロックの強制的な実施は、pNFSクライアントがセクション3.1に記載されている要件に従う場合に提供されます。 I / Oの実行には有効なオープン状態IDが必要なので、既存の共有予約に違反するI / Oは、サーバーが競合するオープン状態IDの存在を許可している場合にのみ可能です。"
    },
    {
      "indent": 0,
      "text": " The nature of the SCSI layout type is that such implementation/ enforcement of mandatory byte-range locks is very difficult. Given that layouts are granted to clients rather than owners, the pNFS client is in no position to successfully arbitrate among multiple lockowners on the same client. Suppose lockowner A is doing a write and, while the I/O is pending, lockowner B requests a mandatory byte-range lock for a byte range potentially overlapping the pending I/O. In such a situation, the lock request cannot be granted while the I/O is pending. In a non-pNFS environment, the server would have to wait for pending I/O before granting the mandatory byte-range lock. In the pNFS environment, the server does not issue the I/O and is thus in no position to wait for its completion. The server may recall such layouts, but in doing so, it has no way of distinguishing those being used by lockowners A and B, making it difficult to allow B to perform I/O while forbidding A from doing so. Given this fact, the MDS need to successfully recall all layouts that overlap the range being locked before returning a successful response to the LOCK request. While the lock is in effect, the server SHOULD respond to requests for layouts that overlap a currently locked area with NFS4ERR_LAYOUTUNAVAILABLE. To simplify the required logic, a server MAY do this for all layout requests on the file in question as long as there are any byte-range locks in effect.",
      "ja": "SCSIレイアウトタイプの性質は、必須のバイト範囲ロックのこのような実装/実施が非常に難しいことです。レイアウトが所有者ではなくクライアントに許可されているとすると、pNFSクライアントは、同じクライアント上の複数のロック所有者の間で調停を成功させることができません。ロック所有者Aが書き込みを行っており、I / Oが保留中に、ロック所有者Bが、保留中のI / Oと重複する可能性のあるバイト範囲の必須のバイト範囲ロックを要求したとします。このような状況では、I / Oが保留されている間はロック要求を許可できません。非pNFS環境では、サーバーは、必須のバイト範囲ロックを許可する前に、保留中のI / Oを待機する必要があります。 pNFS環境では、サーバーはI / Oを発行しないため、その完了を待つことができません。サーバーはそのようなレイアウトをリコールする可能性がありますが、そうすることで、ロック所有者AとBが使用しているものを区別する方法がなくなり、Aがそうすることを禁止しながら、BがI / Oを実行することを困難にします。この事実を踏まえると、MDSは、LOCKリクエストに対して正常な応答を返す前に、ロックされている範囲と重複するすべてのレイアウトを正常に呼び出す必要があります。ロックが有効である間、サーバーは、現在ロックされている領域とNFS4ERR_LAYOUTUNAVAILABLEで重複するレイアウトの要求に応答する必要があります（SHOULD）。必要なロジックを簡略化するために、サーバーは、有効なバイト範囲ロックがある限り、問題のファイルに対するすべてのレイアウト要求に対してこれを実行できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "Given these difficulties, it may be difficult for servers supporting mandatory byte-range locks to also support SCSI layouts. Servers can support advisory byte-range locks instead. The NFSv4 protocol currently has no way of determining whether byte-range lock support on a particular file system will be mandatory or advisory, except by trying operation, which would conflict if mandatory locking is in effect. Therefore, to avoid confusion, servers SHOULD NOT switch between mandatory and advisory byte-range locking based on whether any SCSI layouts have been obtained or whether a client that has obtained a SCSI layout has requested a byte-range lock.",
      "ja": "これらの困難を考えると、必須のバイト範囲ロックをサポートするサーバーがSCSIレイアウトもサポートすることは難しいかもしれません。サーバーは、代わりに勧告的なバイト範囲ロックをサポートできます。現在、NFSv4プロトコルは、特定のファイルシステムでのバイト範囲ロックのサポートが必須であるか、または勧告であるかを判断する方法がありません。したがって、混乱を避けるために、サーバーは、SCSIレイアウトを取得したかどうか、またはSCSIレイアウトを取得したクライアントがバイト範囲ロックを要求したかどうかに基づいて、必須および推奨のバイト範囲ロックを切り替えないでください。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Access to SCSI storage devices is logically at a lower layer of the I/O stack than NFSv4; hence, NFSv4 security is not directly applicable to protocols that access such storage directly. Depending on the protocol, some of the security mechanisms provided by NFSv4 (e.g., encryption and cryptographic integrity) may not be available or may be provided via different means. At one extreme, pNFS with SCSI layouts can be used with storage access protocols (e.g., Serial Attached SCSI [SAS3]) that provide essentially no security functionality. At the other extreme, pNFS may be used with storage protocols such as iSCSI [RFC7143] that can provide significant security functionality. It is the responsibility of those administering and deploying pNFS with a SCSI storage access protocol to ensure that appropriate protection is provided to that protocol (physical security is a common means for protocols not based on IP). In environments where the security requirements for the storage protocol cannot be met, pNFS SCSI layouts SHOULD NOT be used.",
      "ja": "SCSIストレージデバイスへのアクセスは、論理的にはNFSv4よりもI / Oスタックの下位層にあります。したがって、NFSv4セキュリティは、そのようなストレージに直接アクセスするプロトコルには直接適用できません。プロトコルによっては、NFSv4によって提供されるセキュリティメカニズムの一部（暗号化や暗号化の整合性など）が利用できない場合や、別の方法で提供される場合があります。極端な例として、SCSIレイアウトを備えたpNFSは、本質的にセキュリティ機能を提供しないストレージアクセスプロトコル（シリアルアタッチドSCSI [SAS3]など）で使用できます。反対に、pNFSは、iSCSI [RFC7143]などの重要なセキュリティ機能を提供できるストレージプロトコルで使用される場合があります。 SCSIストレージアクセスプロトコルを使用してpNFSを管理および展開する担当者は、そのプロトコルに適切な保護が確実に提供されるようにする責任があります（物理的なセキュリティは、IPベースではないプロトコルの一般的な手段です）。ストレージプロトコルのセキュリティ要件を満たせない環境では、pNFS SCSIレイアウトを使用すべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "When using IP-based storage protocols such as iSCSI, IPsec should be used as outlined in [RFC3723] and updated in [RFC7146].",
      "ja": "iSCSIなどのIPベースのストレージプロトコルを使用する場合は、[RFC3723]で概説され、[RFC7146]で更新されているIPsecを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When security is available for a storage protocol, it is generally at a different granularity and with a different notion of identity than NFSv4 (e.g., NFSv4 controls user access to files, and iSCSI controls initiator access to volumes). The responsibility for enforcing appropriate correspondences between these security layers is placed upon the pNFS client. As with the issues in the first paragraph of this section, in environments where the security requirements are such that client-side protection from access to storage outside of the layout is not sufficient, pNFS SCSI layouts SHOULD NOT be used.",
      "ja": "ストレージプロトコルでセキュリティを利用できる場合、セキュリティは通常、NFSv4とは異なる粒度で、IDの概念が異なります（たとえば、NFSv4はファイルへのユーザーアクセスを制御し、iSCSIはボリュームへのイニシエーターアクセスを制御します）。これらのセキュリティ層の間で適切な対応を実施する責任は、pNFSクライアントにあります。このセクションの最初の段落の問題と同様に、レイアウト外のストレージへのアクセスからのクライアント側の保護が十分でないようなセキュリティ要件がある環境では、pNFS SCSIレイアウトを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned a new pNFS layout type in the \"pNFS Layout Types Registry\" as follows:",
      "ja": "IANAは、次のように「pNFSレイアウトタイプレジストリ」で新しいpNFSレイアウトタイプを割り当てました。"
    },
    {
      "indent": 4,
      "text": "Layout Type Name: LAYOUT4_SCSI Value: 0x00000005 RFC: RFC 8154 How: L Minor Versions: 1",
      "ja": "レイアウトタイプ名：LAYOUT4_SCSI値：0x00000005 RFC：RFC 8154方法：Lマイナーバージョン：1"
    },
    {
      "indent": 0,
      "text": "6. Normative References",
      "section_title": true,
      "ja": "6. 引用文献"
    },
    {
      "indent": 3,
      "text": "[LEGAL] IETF Trust, \"Legal Provisions Relating to IETF Documents\", March 2015, <http://trustee.ietf.org/docs/ IETF-Trust-License-Policy.pdf>.",
      "ja": "[法的] IETFトラスト、「IETF文書に関する法的規定」、2015年3月、<http://trustee.ietf.org/docs/ IETF-Trust-License-Policy.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3723] Aboba, B., Tseng, J., Walker, J., Rangan, V., and F. Travostino, \"Securing Block Storage Protocols over IP\", RFC 3723, DOI 10.17487/RFC3723, April 2004, <http://www.rfc-editor.org/info/rfc3723>.",
      "ja": "[RFC3723] Aboba、B.、Tseng、J.、Walker、J.、Rangan、V。、およびF. Travostino、「IPを介したブロックストレージプロトコルの保護」、RFC 3723、DOI 10.17487 / RFC3723、2004年4月、<http ：//www.rfc-editor.org/info/rfc3723>。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <http://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<http://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <http://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 \"Network File System（NFS）Version 4 Minor Version 1 Protocol\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<http://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description\", RFC 5662, DOI 10.17487/RFC5662, January 2010, <http://www.rfc-editor.org/info/rfc5662>.",
      "ja": "[RFC5662] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 \"Network File System（NFS）Version 4 Minor Version 1 External Data Representation Standard（XDR）Description\"、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、<http://www.rfc-editor.org/info/rfc5662>。"
    },
    {
      "indent": 3,
      "text": "[RFC5663] Black, D., Fridella, S., and J. Glasgow, \"Parallel NFS (pNFS) Block/Volume Layout\", RFC 5663, DOI 10.17487/RFC5663, January 2010, <http://www.rfc-editor.org/info/rfc5663>.",
      "ja": "[RFC5663] Black、D.、Fridella、S。、およびJ. Glasgow、「Parallel NFS（pNFS）Block / Volume Layout」、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、<http：//www.rfc- editor.org/info/rfc5663>。"
    },
    {
      "indent": 3,
      "text": "[RFC6688] Black, D., Ed., Glasgow, J., and S. Faibish, \"Parallel NFS (pNFS) Block Disk Protection\", RFC 6688, DOI 10.17487/RFC6688, July 2012, <http://www.rfc-editor.org/info/rfc6688>.",
      "ja": "[RFC6688] Black、D.、Ed。、Glasgow、J。、およびS. Faibish、「Parallel NFS（pNFS）Block Disk Protection」、RFC 6688、DOI 10.17487 / RFC6688、2012年7月、<http：// www。 rfc-editor.org/info/rfc6688>。"
    },
    {
      "indent": 3,
      "text": "[RFC7143] Chadalapaka, M., Satran, J., Meth, K., and D. Black, \"Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)\", RFC 7143, DOI 10.17487/RFC7143, April 2014, <http://www.rfc-editor.org/info/rfc7143>.",
      "ja": "[RFC7143] Chadalapaka、M.、Satran、J.、Meth、K。、およびD. Black、「インターネットスモールコンピュータシステムインターフェイス（iSCSI）プロトコル（統合）」、RFC 7143、DOI 10.17487 / RFC7143、2014年4月、< http://www.rfc-editor.org/info/rfc7143>。"
    },
    {
      "indent": 3,
      "text": "[RFC7146] Black, D. and P. Koning, \"Securing Block Storage Protocols over IP: RFC 3723 Requirements Update for IPsec v3\", RFC 7146, DOI 10.17487/RFC7146, April 2014, <http://www.rfc-editor.org/info/rfc7146>.",
      "ja": "[RFC7146] Black、D。、およびP. Koning、「IPを介したブロックストレージプロトコルの保護：IPsec v3のRFC 3723要件の更新」、RFC 7146、DOI 10.17487 / RFC7146、2014年4月、<http：//www.rfc-editor .org / info / rfc7146>。"
    },
    {
      "indent": 3,
      "text": "[SAM-5] INCITS Technical Committee T10, \"Information Technology - SCSI Architecture Model - 5 (SAM-5)\", ANSI INCITS 515-2016, 2016.",
      "ja": "[SAM-5] INCITS技術委員会T10、「情報技術-SCSIアーキテクチャモデル-5（SAM-5）」、ANSI INCITS 515-2016、2016。"
    },
    {
      "indent": 3,
      "text": "[SAS3] INCITS Technical Committee T10, \"Information technology - Serial Attached SCSI-3 (SAS-3)\", ANSI INCITS 519-2014, ISO/IEC 14776-154, 2014.",
      "ja": "[SAS3] INCITS技術委員会T10、「情報技術-シリアルアタッチドSCSI-3（SAS-3）」、ANSI INCITS 519-2014、ISO / IEC 14776-154、2014。"
    },
    {
      "indent": 3,
      "text": "[SBC3] INCITS Technical Committee T10, \"Information Technology - SCSI Block Commands - 3 (SBC-3)\", ANSI INCITS 514-2014, ISO/IEC 14776-323, 2014.",
      "ja": "[SBC3] INCITS技術委員会T10、「情報技術-SCSIブロックコマンド-3（SBC-3）」、ANSI INCITS 514-2014、ISO / IEC 14776-323、2014。"
    },
    {
      "indent": 3,
      "text": "[SPC4] INCITS Technical Committee T10, \"Information Technology - SCSI Primary Commands - 4 (SPC-4)\", ANSI INCITS 513-2015, 2015.",
      "ja": "[SPC4] INCITS技術委員会T10、「情報技術-SCSIプライマリコマンド-4（SPC-4）」、ANSI INCITS 513-2015、2015。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Large parts of this document were copied verbatim from [RFC5663], and some parts were inspired by it. Thank to David Black, Stephen Fridella, and Jason Glasgow for their work on the pNFS block/volume layout protocol.",
      "ja": "このドキュメントの大部分は[RFC5663]から逐語的にコピーされたものであり、一部はそれに触発されたものです。 pNFSブロック/ボリュームレイアウトプロトコルに関する作業を行ったDavid Black、Stephen Fridella、およびJason Glasgowに感謝します。"
    },
    {
      "indent": 3,
      "text": "David Black, Robert Elliott, and Tom Haynes provided a thorough review of drafts of this document, and their input led to the current form of the document.",
      "ja": "デビッドブラック、ロバートエリオット、トムヘインズは、このドキュメントのドラフトを徹底的にレビューし、彼らの意見がこのドキュメントの現在の形につながりました。"
    },
    {
      "indent": 3,
      "text": "David Noveck provided ample feedback to various drafts of this document, wrote the section on enforcing NFSv4 semantics, and rewrote various sections to better catch the intent.",
      "ja": "David Noveckは、このドキュメントのさまざまなドラフトに十分なフィードバックを提供し、NFSv4セマンティクスの適用に関するセクションを書き、意図をよりよく理解するためにさまざまなセクションを書き直しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Christoph Hellwig",
      "ja": "クリストフ・ヘルウィッグ"
    },
    {
      "indent": 3,
      "text": "Email: hch@lst.de",
      "raw": true,
      "ja": ""
    }
  ]
}