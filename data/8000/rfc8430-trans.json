{
  "title": {
    "text": "RFC 8430 - RIB Information Model",
    "ja": "RFC 8430 - RIB情報モデル"
  },
  "number": 8430,
  "created_at": "2020-08-23 12:07:57.348791+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   N. Bahadur, Ed.\nRequest for Comments: 8430                                          Uber\nCategory: Informational                                     S. Kini, Ed.\nISSN: 2070-1721\n                                                               J. Medved\n                                                                   Cisco\n                                                          September 2018",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "RIB Information Model",
      "ja": "RIB情報モデル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Routing and routing functions in enterprise and carrier networks are typically performed by network devices (routers and switches) using a Routing Information Base (RIB). Protocols and configurations push data into the RIB, and the RIB manager installs state into the hardware for packet forwarding. This document specifies an information model for the RIB to enable defining a standardized data model. The IETF's I2RS WG used this document to design the I2RS RIB data model. This document is being published to record the higher-level information model decisions for RIBs so that other developers of RIBs may benefit from the design concepts.",
      "ja": "エンタープライズネットワークおよびキャリアネットワークのルーティングおよびルーティング機能は、通常、ルーティング情報ベース（RIB）を使用してネットワークデバイス（ルーターおよびスイッチ）によって実行されます。プロトコルと構成はデータをRIBにプッシュし、RIBマネージャーはパケット転送のために状態をハードウェアにインストールします。このドキュメントでは、RIBの情報モデルを指定して、標準化されたデータモデルを定義できるようにします。 IETFのI2RS WGは、このドキュメントを使用してI2RS RIBデータモデルを設計しました。このドキュメントは、RIBの他の開発者が設計概念の恩恵を受けることができるように、RIBのより高いレベルの情報モデル決定を記録するために発行されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補であるとは限りません。 RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8430.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8430で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Conventions Used in This Document . . . . . . . . . . . .   6\n2.  RIB Data  . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  RIB Definition  . . . . . . . . . . . . . . . . . . . . .   7\n  2.2.  Routing Instance  . . . . . . . . . . . . . . . . . . . .   7\n  2.3.  Route . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n  2.4.  Nexthop . . . . . . . . . . . . . . . . . . . . . . . . .  10\n    2.4.1.  Base Nexthops . . . . . . . . . . . . . . . . . . . .  12\n    2.4.2.  Derived Nexthops  . . . . . . . . . . . . . . . . . .  14\n    2.4.3.  Nexthop Indirection . . . . . . . . . . . . . . . . .  15\n3.  Reading from the RIB  . . . . . . . . . . . . . . . . . . . .  16\n4.  Writing to the RIB  . . . . . . . . . . . . . . . . . . . . .  16\n5.  Notifications . . . . . . . . . . . . . . . . . . . . . . . .  17\n6.  RIB Grammar . . . . . . . . . . . . . . . . . . . . . . . . .  17\n  6.1.  Nexthop Grammar Explained . . . . . . . . . . . . . . . .  20\n7.  Using the RIB Grammar . . . . . . . . . . . . . . . . . . . .  20\n  7.1.  Using Route Preference  . . . . . . . . . . . . . . . . .  20\n  7.2.  Using Different Nexthop Types . . . . . . . . . . . . . .  20\n    7.2.1.  Tunnel Nexthops . . . . . . . . . . . . . . . . . . .  21\n    7.2.2.  Replication Lists . . . . . . . . . . . . . . . . . .  21\n    7.2.3.  Weighted Lists  . . . . . . . . . . . . . . . . . . .  21\n    7.2.4.  Protection  . . . . . . . . . . . . . . . . . . . . .  22\n    7.2.5.  Nexthop Chains  . . . . . . . . . . . . . . . . . . .  22\n    7.2.6.  Lists of Lists  . . . . . . . . . . . . . . . . . . .  23\n  7.3.  Performing Multicast  . . . . . . . . . . . . . . . . . .  24\n8.  RIB Operations at Scale . . . . . . . . . . . . . . . . . . .  25\n  8.1.  RIB Reads . . . . . . . . . . . . . . . . . . . . . . . .  25\n  8.2.  RIB Writes  . . . . . . . . . . . . . . . . . . . . . . .  25\n  8.3.  RIB Events and Notifications  . . . . . . . . . . . . . .  25\n9.  Security Considerations . . . . . . . . . . . . . . . . . . .  25\n10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  26\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  26\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  26\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Routing and routing functions in enterprise and carrier networks are traditionally performed in network devices. Customarily, routers run routing protocols, and the routing protocols (along with static configuration information) populate the Routing Information Base (RIB) of the router. The RIB is managed by the RIB manager, and the RIB manager provides a northbound interface to its clients (i.e., the routing protocols) to insert routes into the RIB. The RIB manager consults the RIB and decides how to program the Forwarding Information Base (FIB) of the hardware by interfacing with the FIB manager. The relationship between these entities is shown in Figure 1.",
      "ja": "エンタープライズおよびキャリアネットワークのルーティングおよびルーティング機能は、従来ネットワークデバイスで実行されていました。通常、ルーターはルーティングプロトコルを実行し、ルーティングプロトコルは（静的構成情報と共に）ルーターのルーティング情報ベース（RIB）に入力されます。 RIBはRIBマネージャーによって管理され、RIBマネージャーはクライアントにノースバウンドインターフェイス（つまり、ルーティングプロトコル）を提供して、RIBにルートを挿入します。 RIBマネージャーはRIBを参照し、FIBマネージャーとのインターフェースによってハードウェアの転送情報ベース（FIB）をプログラムする方法を決定します。これらのエンティティ間の関係を図1に示します。"
    },
    {
      "indent": 3,
      "text": "      +-------------+        +-------------+\n      |RIB Client 1 | ...... |RIB Client N |\n      +-------------+        +-------------+\n             ^                      ^\n             |                      |\n             +----------------------+\n                        |\n                        V\n             +---------------------+\n             |    RIB Manager      |\n             |                     |\n             |     +--------+      |\n             |     | RIB(s) |      |\n             |     +--------+      |\n             +---------------------+\n                        ^\n                        |\n       +---------------------------------+\n       |                                 |\n       V                                 V\n+----------------+               +----------------+\n| FIB Manager 1  |               | FIB Manager M  |\n|   +--------+   |  ..........   |   +--------+   |\n|   | FIB(s) |   |               |   | FIB(s) |   |\n|   +--------+   |               |   +--------+   |\n+----------------+               +----------------+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 1: RIB Manager, RIB Clients, and FIB Managers",
      "ja": "図1：RIBマネージャー、RIBクライアント、およびFIBマネージャー"
    },
    {
      "indent": 0,
      "text": " Routing protocols are inherently distributed in nature, and each router makes an independent decision based on the routing data received from its peers. With the advent of newer deployment paradigms and the need for specialized applications, there is an emerging need to guide the router's routing function [RFC7920]. The traditional network-device RIB population that is protocol based suffices for most use cases where distributed network control is used. However, there are use cases that the network operators currently address by configuring static routes, policies, and RIB import/export rules on the routers. There is also a growing list of use cases in which a network operator might want to program the RIB based on data unrelated to just routing (within that network's domain). Programming the RIB could be based on other information (such as routing data in the adjacent domain or the load on storage and compute) in the given domain. Or, it could simply be a programmatic way of creating on-demand dynamic overlays (e.g., GRE tunnels) between compute hosts (without requiring the hosts to run traditional routing protocols). If there was a standardized, publicly documented programmatic interface to a RIB, it would enable further networking applications that address a variety of use cases [RFC7920].",
      "ja": "ルーティングプロトコルは本質的に本質的に分散されており、各ルーターは、ピアから受信したルーティングデータに基づいて独立した決定を行います。新しい展開パラダイムの出現と特殊なアプリケーションの必要性に伴い、ルーターのルーティング機能を導く必要性が出現しています[RFC7920]。プロトコルベースの従来のネットワークデバイスRIBポピュレーションは、分散ネットワーク制御が使用されるほとんどのユースケースで十分です。ただし、ネットワークオペレーターがルーターに静的ルート、ポリシー、およびRIBインポート/エクスポートルールを構成することで現在対処しているユースケースがあります。また、ネットワークオペレータが（そのネットワークのドメイン内の）ルーティングだけに関係のないデータに基づいてRIBをプログラムすることを望むユースケースのリストも増えています。 RIBのプログラミングは、特定のドメイン内の他の情報（隣接ドメイン内のルーティングデータやストレージとコンピューティングの負荷など）に基づいて行うことができます。または、（ホストが従来のルーティングプロトコルを実行する必要なく）計算ホスト間でオンデマンドの動的オーバーレイ（GREトンネルなど）を作成するプログラムによる方法でもかまいません。 RIBへの標準化され、公に文書化されたプログラマティックインターフェイスがある場合、それはさまざまなユースケース[RFC7920]に対処するさらなるネットワーキングアプリケーションを可能にします。"
    },
    {
      "indent": 3,
      "text": "A programmatic interface to the RIB involves two types of operations: reading from the RIB and writing (adding/modifying/deleting) to the RIB.",
      "ja": "RIBへのプログラムインターフェイスには、RIBからの読み取りとRIBへの書き込み（追加/変更/削除）の2種類の操作が含まれます。"
    },
    {
      "indent": 3,
      "text": "In order to understand what is in a router's RIB, methods like per-protocol SNMP MIBs and screen scraping are used. These methods are not scalable since they are client pull mechanisms and not proactive push (from the router) mechanisms. Screen scraping is error prone (since the output format can change) and is vendor dependent. Building a RIB from per-protocol MIBs is error prone since the MIB data represents protocol data and not the exact information that went into the RIB. Thus, just getting read-only RIB information from a router is a hard task.",
      "ja": "ルータのRIBの内容を理解するために、プロトコルごとのSNMP MIBやスクリーンスクレイピングなどの方法が使用されます。これらのメソッドは、クライアントのプルメカニズムであり、（ルーターからの）プロアクティブなプッシュメカニズムではないため、スケーラブルではありません。画面のスクレイピングはエラーが発生しやすく（出力形式が変更される可能性があるため）、ベンダーによって異なります。 MIBデータはプロトコルデータを表し、RIBに入力された正確な情報ではないため、プロトコルごとのMIBからRIBを構築するとエラーが発生しやすくなります。したがって、ルータから読み取り専用のRIB情報を取得することは困難な作業です。"
    },
    {
      "indent": 3,
      "text": "Adding content to the RIB from a RIB client can be done today using static configuration mechanisms provided by router vendors. However, the mix of what can be modified in the RIB varies from vendor to vendor, and the method of configuring it is also vendor dependent. This makes it hard for a RIB client to program a multi-vendor network in a consistent and vendor-independent way.",
      "ja": "RIBクライアントからRIBにコンテンツを追加するには、ルーターベンダーが提供する静的構成メカニズムを使用します。ただし、RIBで変更できるものの組み合わせはベンダーごとに異なり、その構成方法もベンダーによって異なります。これにより、RIBクライアントが一貫してベンダーに依存しない方法でマルチベンダーネットワークをプログラムすることが難しくなります。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to specify an information model for the RIB. Using the information model, one can build a detailed data model for the RIB. That data model could then be used by a RIB client to program a network device. One data model that has been based on this document is the I2RS RIB data model [RFC8431].",
      "ja": "このドキュメントの目的は、RIBの情報モデルを指定することです。情報モデルを使用して、RIBの詳細なデータモデルを構築できます。そのデータモデルは、RIBクライアントがネットワークデバイスをプログラムするために使用できます。このドキュメントに基づいている1つのデータモデルは、I2RS RIBデータモデル[RFC8431]です。"
    },
    {
      "indent": 3,
      "text": "The rest of this document is organized as follows. Section 2 goes into the details of what constitutes and can be programmed in a RIB. Guidelines for reading and writing the RIB are provided in Sections 3 and 4, respectively. Section 5 provides a high-level view of the",
      "ja": "このドキュメントの残りの部分は、次のように構成されています。セクション2では、RIBを構成し、RIBでプログラムできる詳細について説明します。 RIBの読み取りと書き込みのガイドラインは、セクション3とセクション4にそれぞれ記載されています。セクション5では、"
    },
    {
      "indent": 3,
      "text": "events and notifications going from a network device to a RIB client to update the RIB client on asynchronous events. The RIB grammar is specified in Section 6. Examples of using the RIB grammar are shown in Section 7. Section 8 covers considerations for performing RIB operations at scale.",
      "ja": "非同期イベントでRIBクライアントを更新するためにネットワークデバイスからRIBクライアントに送信されるイベントと通知。 RIB文法はセクション6で指定されています。RIB文法の使用例はセクション7に示されています。セクション8では、大規模なRIB操作を実行するための考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. RIB Data",
      "section_title": true,
      "ja": "2. RIBデータ"
    },
    {
      "indent": 3,
      "text": "This section describes the details of a RIB. It makes forward references to objects in the RIB grammar (see Section 6). A high-level description of the RIB contents is as shown in Figure 2. Please note that for ease of representation in ASCII art, this drawing shows a single routing instance, a single RIB, and a single route. Subsections of this section describe the logical data nodes that should be contained within a RIB. Sections 3 and 4 describe the high-level read and write operations.",
      "ja": "このセクションでは、RIBの詳細について説明します。 RIB文法内のオブジェクトを前方参照します（セクション6を参照）。 RIBの内容の概要を図2に示します。ASCIIアートでの表現を簡単にするために、この図は単一のルーティングインスタンス、単一のRIB、および単一のルートを示していることに注意してください。このセクションのサブセクションでは、RIBに含める必要がある論理データノードについて説明します。セクション3および4では、高レベルの読み取りおよび書き込み操作について説明します。"
    },
    {
      "indent": 20,
      "text": "      network-device\n            |\n            | 0..N\n            |\n     routing instance(s)\n      |             |\n      |             |\n0..N  |             | 0..N\n      |             |\n interface(s)     RIB(s)\n                    |\n                    |\n                    | 0..N\n                    |\n                  route(s)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 2: RIB Information Model",
      "ja": "図2：RIB情報モデル"
    },
    {
      "indent": 0,
      "text": "2.1. RIB Definition",
      "section_title": true,
      "ja": "2.1. RIBの定義"
    },
    {
      "indent": 3,
      "text": "A RIB, in the context of the RIB information model, is an entity that contains routes. It is identified by its name and is contained within a routing instance (see Section 2.2). A network device MAY contain routing instances, and each routing instance MAY contain RIBs. The name MUST be unique within a routing instance. All routes in a given RIB MUST be of the same address family (e.g., IPv4). Each RIB MUST belong to a routing instance.",
      "ja": "RIBは、RIB情報モデルのコンテキストでは、ルートを含むエンティティです。これは名前で識別され、ルーティングインスタンス内に含まれています（セクション2.2を参照）。ネットワークデバイスにはルーティングインスタンスが含まれる場合があり、各ルーティングインスタンスにはRIBが含まれる場合があります。名前はルーティングインスタンス内で一意である必要があります。指定されたRIB内のすべてのルートは、同じアドレスファミリ（IPv4など）である必要があります。各RIBはルーティングインスタンスに属している必要があります。"
    },
    {
      "indent": 3,
      "text": "A routing instance may contain two or more RIBs of the same address family (e.g., IPv6). A typical case where this can be used is for multi-topology routing [RFC4915] [RFC5120].",
      "ja": "ルーティングインスタンスには、同じアドレスファミリ（IPv6など）の2つ以上のRIBが含まれる場合があります。これを使用できる典型的なケースは、マルチトポロジルーティング[RFC4915] [RFC5120]です。"
    },
    {
      "indent": 3,
      "text": "Each RIB MAY be associated with an ENABLE_IP_RPF_CHECK attribute that enables Reverse Path Forwarding (RPF) checks on all IP routes in that RIB. The RPF check is used to prevent spoofing and limit malicious traffic. For IP packets, the IP source address is looked up and the RPF interface(s) associated with the route for that IP source address is found. If the incoming IP packet's interface matches one of the RPF interfaces, then the IP packet is forwarded based on its IP destination address; otherwise, the IP packet is discarded.",
      "ja": "各RIBは、そのRIB内のすべてのIPルートでリバースパス転送（RPF）チェックを有効にするENABLE_IP_RPF_CHECK属性に関連付けることができます（MAY）。 RPFチェックは、スプーフィングを防止し、悪意のあるトラフィックを制限するために使用されます。 IPパケットの場合、IP送信元アドレスが検索され、そのIP送信元アドレスのルートに関連付けられたRPFインターフェイスが見つかります。着信IPパケットのインターフェイスがRPFインターフェイスの1つと一致する場合、IPパケットはIP宛先アドレスに基づいて転送されます。それ以外の場合、IPパケットは破棄されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Routing Instance",
      "section_title": true,
      "ja": "2.2. ルーティングインスタンス"
    },
    {
      "indent": 3,
      "text": "A routing instance, in the context of the RIB information model, is a collection of RIBs, interfaces, and routing parameters. A routing instance creates a logical slice of the router. It allows different logical slices across a set of routers to communicate with each other. Layer 3 VPNs, Layer 2 VPNs (L2VPNs), and Virtual Private LAN Service (VPLS) can be modeled as routing instances. Note that modeling an L2VPN using a routing instance only models the Layer 3 (RIB) aspect and does not model any Layer 2 information (like ARP) that might be associated with the L2VPN.",
      "ja": "ルーティングインスタンスは、RIB情報モデルのコンテキストでは、RIB、インターフェイス、およびルーティングパラメータのコレクションです。ルーティングインスタンスは、ルーターの論理スライスを作成します。これにより、一連のルーター間で異なる論理スライスが相互に通信できます。レイヤー3 VPN、レイヤー2 VPN（L2VPN）、および仮想プライベートLANサービス（VPLS）は、ルーティングインスタンスとしてモデル化できます。ルーティングインスタンスを使用してL2VPNをモデル化すると、レイヤー3（RIB）アスペクトのみがモデル化され、L2VPNに関連付けられている可能性のあるレイヤー2情報（ARPなど）はモデル化されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The set of interfaces indicates which interfaces are associated with this routing instance. The RIBs specify how incoming traffic is to be forwarded, and the routing parameters control the information in the RIBs. The intersection set of interfaces of two routing instances MUST be the null set. In other words, an interface MUST NOT be present in two routing instances. Thus, a routing instance describes the routing information and parameters across a set of interfaces.",
      "ja": "インターフェイスのセットは、このルーティングインスタンスに関連付けられているインターフェイスを示します。 RIBは着信トラフィックの転送方法を指定し、ルーティングパラメータはRIB内の情報を制御します。 2つのルーティングインスタンスのインターフェイスの共通部分セットはnullセットである必要があります。言い換えると、インターフェースは2つのルーティングインスタンスに存在してはなりません（MUST NOT）。したがって、ルーティングインスタンスは、一連のインターフェイスにわたるルーティング情報とパラメータを記述します。"
    },
    {
      "indent": 3,
      "text": "A routing instance MUST contain the following mandatory fields:",
      "ja": "ルーティングインスタンスには、次の必須フィールドが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o INSTANCE_NAME: A routing instance is identified by its name, INSTANCE_NAME. This MUST be unique across all routing instances in a given network device.",
      "ja": "o INSTANCE_NAME：ルーティングインスタンスは、その名前INSTANCE_NAMEで識別されます。これは、特定のネットワークデバイスのすべてのルーティングインスタンスで一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "o rib-list: This is the list of RIBs associated with this routing instance. Each routing instance can have multiple RIBs to represent routes of different types. For example, one would put IPv4 routes in one RIB and MPLS routes in another RIB. The list of RIBs can be an empty list.",
      "ja": "o rib-list：これは、このルーティングインスタンスに関連付けられたRIBのリストです。各ルーティングインスタンスは、さまざまなタイプのルートを表すために複数のRIBを持つことができます。たとえば、IPv4ルートを1つのRIBに配置し、MPLSルートを別のRIBに配置します。 RIBのリストは空のリストにすることができます。"
    },
    {
      "indent": 3,
      "text": "A routing instance MAY contain the following fields:",
      "ja": "ルーティングインスタンスには次のフィールドが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "o interface-list: This represents the list of interfaces associated with this routing instance. The interface list helps constrain the boundaries of packet forwarding. Packets coming in on these interfaces are directly associated with the given routing instance. The interface list contains a list of identifiers, with each identifier uniquely identifying an interface.",
      "ja": "o interface-list：これは、このルーティングインスタンスに関連付けられたインターフェースのリストを表します。インターフェイスリストは、パケット転送の境界を制限するのに役立ちます。これらのインターフェイスに着信するパケットは、指定されたルーティングインスタンスに直接関連付けられます。インターフェイスリストには識別子のリストが含まれ、各識別子はインターフェイスを一意に識別します。"
    },
    {
      "indent": 3,
      "text": "o ROUTER_ID: This field identifies the network device in control plane interactions with other network devices. This field is to be used if one wants to virtualize a physical router into multiple virtual routers. Each virtual router MUST have a unique ROUTER_ID. A ROUTER_ID MUST be unique across all network devices in a given domain.",
      "ja": "o ROUTER_ID：このフィールドは、他のネットワークデバイスとのコントロールプレーンの相互作用でネットワークデバイスを識別します。このフィールドは、物理ルーターを複数の仮想ルーターに仮想化する場合に使用します。各仮想ルーターには一意のROUTER_IDが必要です。 ROUTER_IDは、特定のドメイン内のすべてのネットワークデバイスで一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "A routing instance may be created purely for the purposes of packet processing and may not have any interfaces associated with it. For example, an incoming packet in routing instance A might have a nexthop of routing instance B, and after packet processing in B, the nexthop might be routing instance C. Thus, routing instance B is not associated with any interface. And, given that this routing instance does not do any control-plane interaction with other network devices, a ROUTER_ID is also not needed.",
      "ja": "ルーティングインスタンスは、純粋にパケット処理の目的で作成され、インターフェイスが関連付けられていない場合があります。たとえば、ルーティングインスタンスAの着信パケットにはルーティングインスタンスBのネクストホップがあり、Bでのパケット処理後のネクストホップはルーティングインスタンスCになる可能性があります。したがって、ルーティングインスタンスBはどのインターフェイスにも関連付けられていません。また、このルーティングインスタンスは他のネットワークデバイスとコントロールプレーンの相互作用を行わないため、ROUTER_IDも必要ありません。"
    },
    {
      "indent": 0,
      "text": "2.3. Route",
      "section_title": true,
      "ja": "2.3. ルート"
    },
    {
      "indent": 3,
      "text": "A route is essentially a match condition and an action following the match. The match condition specifies the kind of route (IPv4, MPLS, etc.) and the set of fields to match on. Figure 3 represents the overall contents of a route. Please note that for ease of depiction in ASCII art, only a single instance of the route-attribute, match flags, and nexthop is depicted.",
      "ja": "ルートは基本的に一致条件であり、一致に続くアクションです。一致条件は、ルートの種類（IPv4、MPLSなど）と一致するフィールドのセットを指定します。図3は、ルートの全体的な内容を表しています。 ASCIIアートでの描写を容易にするために、ルート属性、一致フラグ、およびネクストホップの単一のインスタンスのみが描写されていることに注意してください。"
    },
    {
      "indent": 18,
      "text": "               route\n               | | |\n     +---------+ | +----------+\n     |           |            |\n0..N |           |            |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "route-attribute         match         nexthop\n                          |\n                          |\n          +-------+-------+-------+--------+\n          |       |       |       |        |\n          |       |       |       |        |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "IPv4 IPv6 MPLS MAC Interface",
      "ja": "IPv4 IPv6 MPLS MACインターフェイス"
    },
    {
      "indent": 27,
      "text": "Figure 3: Route Model",
      "ja": "図3：ルートモデル"
    },
    {
      "indent": 3,
      "text": "This document specifies the following match types:",
      "ja": "このドキュメントでは、次のマッチタイプを指定しています。"
    },
    {
      "indent": 3,
      "text": "o IPv4: Match on destination and/or source IP address in the IPv4 header",
      "ja": "o IPv4：IPv4ヘッダーの宛先および/または送信元IPアドレスで一致"
    },
    {
      "indent": 3,
      "text": "o IPv6: Match on destination and/or source IP address in the IPv6 header",
      "ja": "o IPv6：IPv6ヘッダーの宛先および/または送信元IPアドレスで一致"
    },
    {
      "indent": 3,
      "text": "o MPLS: Match on an MPLS label at the top of the MPLS label stack",
      "ja": "o MPLS：MPLSラベルスタックの最上位にあるMPLSラベルに一致"
    },
    {
      "indent": 3,
      "text": "o MAC: Match on Media Access Control (MAC) destination addresses in the Ethernet header",
      "ja": "o MAC：イーサネットヘッダーのMedia Access Control（MAC）宛先アドレスに一致"
    },
    {
      "indent": 3,
      "text": "o Interface: Match on the incoming interface of the packet",
      "ja": "o インターフェース：パケットの着信インターフェースで一致"
    },
    {
      "indent": 3,
      "text": "A route MAY be matched on one or more of these match types by policy as either an \"AND\" (to restrict the number of routes) or an \"OR\" (to combine two filters).",
      "ja": "ルートは、ポリシーによって「AND」（ルートの数を制限するため）または「OR」（2つのフィルターを組み合わせるため）のいずれかとして、これらの一致タイプの1つ以上に一致する場合があります。"
    },
    {
      "indent": 3,
      "text": "Each route MUST have the following mandatory route-attributes associated with it:",
      "ja": "各ルートには、次の必須のルート属性が関連付けられている必要があります。"
    },
    {
      "indent": 0,
      "text": " o ROUTE_PREFERENCE: This is a numerical value that allows for comparing routes from different protocols. Static configuration is also considered a protocol for the purpose of this field. It is also known as \"administrative distance\". The lower the value, the higher the preference. For example, there can be an OSPF route for 192.0.2.1/32 (or IPv6 2001:DB8::1/128) with a preference of 5. If a controller programs a route for 192.0.2.1/32 (or IPv6 2001:DB8::1/128) with a preference of 2, then the controller's route will be preferred by the RIB manager. Preference should be used to dictate behavior. For more examples of preference, see Section 7.1.",
      "ja": "o ROUTE_PREFERENCE：これは、異なるプロトコルからのルートを比較できる数値です。静的構成も、このフィールドの目的ではプロトコルと見なされます。 「アドミニストレーティブディスタンス」とも呼ばれます。値が低いほど、優先度が高くなります。たとえば、192.0.2.1 / 32（またはIPv6 2001：DB8 :: 1/128）の優先順位が5のOSPFルートが存在する可能性があります。コントローラが192.0.2.1/32（またはIPv6 2001： DB8 :: 1/1/128）、優先度が2の場合、コントローラーのルートがRIBマネージャーによって優先されます。動作を指示するには、設定を使用する必要があります。設定のその他の例については、7.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Each route can have one or more optional route-attributes associated with it.",
      "ja": "各ルートには、1つ以上のオプションのルート属性を関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "o route-vendor-attributes: Vendors can specify vendor-specific attributes using this. The details of this attribute are outside the scope of this document.",
      "ja": "o route-vendor-attributes：ベンダーはこれを使用してベンダー固有の属性を指定できます。この属性の詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Each route has a nexthop associated with it. Nexthops are described in Section 2.4.",
      "ja": "各ルートにはネクストホップが関連付けられています。ネクストホップについては、セクション2.4で説明します。"
    },
    {
      "indent": 3,
      "text": "Additional features to match multicast packets were considered (e.g., TTL of the packet to limit the range of a multicast group), but these were not added to this information model. Future RIB information models should investigate these multicast features.",
      "ja": "マルチキャストパケットを照合するための追加機能（たとえば、マルチキャストグループの範囲を制限するためのパケットのTTL）が検討されましたが、これらはこの情報モデルに追加されませんでした。将来のRIB情報モデルでは、これらのマルチキャスト機能を調査する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Nexthop",
      "section_title": true,
      "ja": "2.4. ネクストホップ"
    },
    {
      "indent": 3,
      "text": "A nexthop represents an object resulting from a route lookup. For example, if a route lookup results in sending the packet out of a given interface, then the nexthop represents that interface.",
      "ja": "ネクストホップは、ルートルックアップの結果のオブジェクトを表します。たとえば、ルートルックアップによって特定のインターフェイスからパケットが送信される場合、ネクストホップはそのインターフェイスを表します。"
    },
    {
      "indent": 3,
      "text": "Nexthops can be either fully resolved or unresolved. A resolved nexthop has adequate information to send the outgoing packet to the destination by forwarding it on an interface to a directly connected neighbor. For example, a nexthop to a point-to-point interface or a nexthop to an IP address on an Ethernet interface has the nexthop resolved. An unresolved nexthop is something that requires the RIB manager to determine the final resolved nexthop. For example, a nexthop could be an IP address. The RIB manager would resolve how to reach that IP address; for example, is the IP address reachable by regular IP forwarding, by an MPLS tunnel, or by both? If the RIB manager cannot resolve the nexthop, then the nexthop remains in an unresolved state and is NOT a candidate for installation in the FIB. Future RIB events can cause an unresolved nexthop to get resolved (e.g., an IP address being advertised by an IGP neighbor). Conversely, resolved nexthops can also become unresolved (e.g., in the case of a tunnel going down); hence, they would no longer be candidates to be installed in the FIB.",
      "ja": "ネクストホップは完全に解決することも、解決しないこともできます。解決されたネクストホップには、直接接続されたネイバーへのインターフェイスでパケットを転送することにより、発信パケットを宛先に送信するための適切な情報があります。たとえば、ポイントツーポイントインターフェイスへのネクストホップ、またはイーサネットインターフェイスのIPアドレスへのネクストホップでは、ネクストホップが解決されます。未解決のネクストホップは、RIBマネージャが最終的に解決されたネクストホップを決定する必要があるものです。たとえば、ネクストホップはIPアドレスです。 RIBマネージャーは、そのIPアドレスに到達する方法を解決します。たとえば、通常のIP転送、MPLSトンネル、またはその両方によってIPアドレスに到達できますか？ RIBマネージャがネクストホップを解決できない場合、ネクストホップは未解決の状態のままであり、FIBへのインストールの候補ではありません。将来のRIBイベントにより、未解決のネクストホップが解決される可能性があります（たとえば、IPアドレスがIGPネイバーによってアドバタイズされている）。逆に、解決されたネクストホップも解決されないことがあります（たとえば、トンネルがダウンした場合）。したがって、それらはFIBにインストールされる候補ではなくなります。"
    },
    {
      "indent": 0,
      "text": " When at least one of a route's nexthops is resolved, then the route can be used to forward packets. Such a route is considered eligible to be installed in the FIB and is henceforth referred to as a FIB-eligible route. Conversely, when all the nexthops of a route are unresolved, that route can no longer be used to forward packets. Such a route is considered ineligible to be installed in the FIB and is henceforth referred to as a FIB-ineligible route. The RIB information model allows a RIB client to program routes whose nexthops may be unresolved initially. Whenever an unresolved nexthop gets resolved, the RIB manager will send a notification of the same (see Section 5).",
      "ja": "ルートのネクストホップの少なくとも1つが解決されると、そのルートを使用してパケットを転送できます。このようなルートは、FIBにインストールするのに適格と見なされ、以降、FIB適格ルートと呼ばれます。逆に、ルートのすべてのネクストホップが解決されない場合、そのルートはパケットの転送に使用できなくなります。そのようなルートは、FIBにインストールするのに不適格であると見なされ、以降、FIB不適格ルートと呼ばれます。 RIB情報モデルを使用すると、RIBクライアントは、ネクストホップが最初に解決されない可能性があるルートをプログラムできます。未解決のネクストホップが解決されるたびに、RIBマネージャーはその通知を送信します（セクション5を参照）。"
    },
    {
      "indent": 3,
      "text": "The overall structure and usage of a nexthop is as shown in the figure below. For ease of description using ASCII art, only a single instance of any component of the nexthop is shown in Figure 4.",
      "ja": "ネクストホップの全体的な構造と使用法は、次の図に示すとおりです。 ASCIIアートを使用して説明を簡単にするために、ネクストホップのコンポーネントの単一インスタンスのみを図4に示します。"
    },
    {
      "indent": 1,
      "text": "                              route\n                                |\n                                | 0..N\n                                |\n                              nexthop <-------------------------------+\n                                |                                     |\n         +-------+----------------------------+-------------+         |\n         |       |              |             |             |         |\n         |       |              |             |             |         |\n      base   load-balance   protection      replicate     chain       |\n         |       |              |             |             |         |\n         |       |2..N          |2..N         |2..N         |1..N     |\n         |       |              |             |             |         |\n         |       |              V             |             |         |\n         |       +------------->+<------------+-------------+         |\n         |                      |                                     |\n         |                      +-------------------------------------+\n         |\n         +-------------------+\n                             |\n                             |\n                             |\n                             |\n    +---------------+--------+--------+--------------+----------+\n    |               |                 |              |          |\n    |               |                 |              |          |\n nexthop-id  egress-interface  ip-address     logical-tunnel    |\n                                                                |\n                                                                |\n                         +--------------------------------------+\n                         |\n      +----------------------+------------------+-------------+\n      |                      |                  |             |\n      |                      |                  |             |\ntunnel-encapsulation   tunnel-decapsulation  rib-name   special-nexthop",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 4: Nexthop Model",
      "ja": "図4：Nexthopモデル"
    },
    {
      "indent": 3,
      "text": "This document specifies a very generic, extensible, and recursive grammar for nexthops. A nexthop can be a base nexthop or a derived nexthop. Section 2.4.1 details base nexthops, and Section 2.4.2 explains various kinds of derived nexthops. There are certain special nexthops, and those are described in Section 2.4.1.1. Lastly, Section 2.4.3 delves into nexthop indirection and its use. Examples of when and how to use tunnel nexthops and derived nexthops are shown in Section 7.2.",
      "ja": "このドキュメントでは、ネクストホップの非常に一般的で拡張可能な再帰的な文法を指定しています。ネクストホップは、ベースネクストホップまたは派生ネクストホップにすることができます。セクション2.4.1でベースネクストホップの詳細を説明し、セクション2.4.2でさまざまな種類の派生ネクストホップについて説明します。特定のネクストホップがあり、それらはセクション2.4.1.1で説明されています。最後に、セクション2.4.3では、ネクストホップの間接化とその使用について詳しく説明します。トンネルネクストホップと派生ネクストホップをいつどのように使用するかの例をセクション7.2に示します。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Base Nexthops",
      "section_title": true,
      "ja": "2.4.1. ベースネクストホップ"
    },
    {
      "indent": 3,
      "text": "At the lowest level, a nexthop can be one of the following:",
      "ja": "最下位レベルでは、ネクストホップは次のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "o Identifier: This is an identifier returned by the network device representing a nexthop. This can be used as a way of reusing a nexthop when programming derived nexthops.",
      "ja": "o 識別子：これは、ネクストホップを表すネットワークデバイスによって返される識別子です。これは、派生ネクストホップをプログラミングするときにネクストホップを再利用する方法として使用できます。"
    },
    {
      "indent": 3,
      "text": "o Interface nexthops: These are nexthops that are pointing to an interface. Various attributes associated with these nexthops are:",
      "ja": "o インターフェイスのネクストホップ：これらは、インターフェイスを指しているネクストホップです。これらのネクストホップに関連するさまざまな属性は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface: This represents a physical, logical, or virtual interface on the network device. Address resolution must not be required on this interface. This interface may belong to any routing instance.",
      "ja": "* 出力インターフェイス：これは、ネットワークデバイス上の物理、論理、または仮想インターフェイスを表します。このインターフェイスでは、アドレス解決は必要ありません。このインターフェイスは、任意のルーティングインスタンスに属することができます。"
    },
    {
      "indent": 6,
      "text": "* IP address: A route lookup on this IP address is done to determine the egress-interface. Address resolution may be required depending on the interface.",
      "ja": "* IPアドレス：このIPアドレスのルートルックアップは、出力インターフェイスを決定するために行われます。インターフェースによってはアドレス解決が必要な場合があります。"
    },
    {
      "indent": 9,
      "text": "+ An optional rib-name can also be specified to indicate the RIB in which the IP address is to be looked up. One can use the rib-name field to direct the packet from one domain into another domain. By default the RIB will be the same as the one that route belongs to.",
      "ja": "+ オプションのrib-nameを指定して、IPアドレスを検索するRIBを指定することもできます。 rib-nameフィールドを使用して、あるドメインから別のドメインにパケットを転送できます。デフォルトでは、RIBはルートが属するものと同じになります。"
    },
    {
      "indent": 6,
      "text": "These attributes can be used in combination as follows:",
      "ja": "これらの属性は、次のように組み合わせて使用​​できます。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface and IP address: This can be used in cases where, e.g., the IP address is a link-local address.",
      "ja": "* 出力インターフェースとIPアドレス：これは、たとえばIPアドレスがリンクローカルアドレスである場合に使用できます。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface and MAC address: The egress-interface must be an Ethernet interface. Address resolution is not required for this nexthop.",
      "ja": "* 出力インターフェイスとMACアドレス：出力インターフェイスはイーサネットインターフェイスである必要があります。このネクストホップにはアドレス解決は必要ありません。"
    },
    {
      "indent": 3,
      "text": "o Tunnel nexthops: These are nexthops that are pointing to a tunnel. The types of tunnel nexthops are:",
      "ja": "o トンネルのネクストホップ：トンネルを指すネクストホップです。トンネルネクストホップのタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* tunnel-encapsulation: This can be an encapsulation representing an IP tunnel, MPLS tunnel, or others as defined in this document. An optional egress-interface can be chained to the tunnel-encapsulation to indicate which interface to send the packet out on. The egress-interface is useful when the network device contains Ethernet interfaces and one needs to perform address resolution for the IP packet.",
      "ja": "* トンネルカプセル化：これは、IPトンネル、MPLSトンネル、またはこのドキュメントで定義されているその他を表すカプセル化です。オプションの出力インターフェイスをトンネルカプセル化にチェーンして、パケットを送信するインターフェイスを指定できます。出力インターフェイスは、ネットワークデバイスにイーサネットインターフェイスが含まれていて、IPパケットのアドレス解決を実行する必要がある場合に役立ちます。"
    },
    {
      "indent": 6,
      "text": "* tunnel-decapsulation: This is to specify decapsulating a tunnel header. After decapsulation, further lookup on the packet can be done via chaining it with another nexthop. The packet can also be sent out via an egress-interface directly.",
      "ja": "* トンネルカプセル化解除：トンネルヘッダーのカプセル化解除を指定します。カプセル化を解除した後、別のネクストホップとチェーンすることで、パケットをさらに検索できます。パケットは、出力インターフェイスを介して直接送信することもできます。"
    },
    {
      "indent": 6,
      "text": "* logical-tunnel: This can be an MPLS Label Switched Path (LSP) or a GRE tunnel (or others as defined in this document) that is represented by a unique identifier (e.g., name).",
      "ja": "* 論理トンネル：これは、一意の識別子（例：名前）で表されるMPLSラベルスイッチドパス（LSP）またはGREトンネル（またはこのドキュメントで定義されている他のトンネル）にすることができます。"
    },
    {
      "indent": 3,
      "text": "o rib-name: A nexthop pointing to a RIB. This indicates that the route lookup needs to continue in the specified RIB. This is a way to perform chained lookups.",
      "ja": "o rib-name：RIBを指すネクストホップ。これは、指定されたRIBでルートルックアップを続行する必要があることを示しています。これは、連鎖検索を実行する方法です。"
    },
    {
      "indent": 3,
      "text": "Tunnel nexthops allow a RIB client to program static tunnel headers. There can be cases where the remote tunnel endpoint does not support dynamic signaling (e.g., no LDP support on a host); in those cases, the RIB client might want to program the tunnel header on both ends of the tunnel. The tunnel nexthop is kept generic with specifications provided for some commonly used tunnels. It is expected that the data model will model these tunnel types with complete accuracy.",
      "ja": "トンネルネクストホップにより、RIBクライアントは静的トンネルヘッダーをプログラムできます。リモートトンネルエンドポイントが動的シグナリングをサポートしていない場合があります（たとえば、ホストでLDPがサポートされていない）。このような場合、RIBクライアントはトンネルの両端でトンネルヘッダーをプログラムする必要があります。トンネルのネクストホップは、一般的に使用されるいくつかのトンネルに提供される仕様を使用して、汎用的に保たれます。データモデルは、これらのトンネルタイプを完全な精度でモデル化することが期待されています。"
    },
    {
      "indent": 0,
      "text": "2.4.1.1. Special Nexthops",
      "section_title": true,
      "ja": "2.4.1.1. 特別なネクストホップ"
    },
    {
      "indent": 3,
      "text": "Special nexthops are for performing specific well-defined functions (e.g., DISCARD). The purpose of each of them is explained below:",
      "ja": "特別なネクストホップは、明確に定義された特定の機能（DISCARDなど）を実行するためのものです。それぞれの目的を以下に説明します。"
    },
    {
      "indent": 3,
      "text": "o DISCARD: This indicates that the network device should drop the packet and increment a drop counter.",
      "ja": "o DISCARD：これは、ネットワークデバイスがパケットをドロップし、ドロップカウンターをインクリメントする必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "o DISCARD_WITH_ERROR: This indicates that the network device should drop the packet, increment a drop counter, and send back an appropriate error message (like ICMP error).",
      "ja": "o DISCARD_WITH_ERROR：これは、ネットワークデバイスがパケットをドロップし、ドロップカウンターをインクリメントし、適切なエラーメッセージ（ICMPエラーなど）を返送する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "o RECEIVE: This indicates that the traffic is destined for the network device, for example, protocol packets or Operations, Administration, and Maintenance (OAM) packets. All locally destined traffic SHOULD be throttled to avoid a denial-of-service attack on the router's control plane. An optional rate limiter can be specified to indicate how to throttle traffic destined for the control plane. The description of the rate limiter is outside the scope of this document.",
      "ja": "o RECEIVE：これは、トラフィックがネットワークデバイス（たとえば、プロトコルパケットまたはOperations、Administration、and Maintenance（OAM）パケット）宛てであることを示します。ローカルに宛てられたすべてのトラフィックは、ルーターのコントロールプレーンへのサービス拒否攻撃を回避するために抑制されるべきです（SHOULD）。オプションのレートリミッターを指定して、コントロールプレーン宛てのトラフィックを抑制する方法を指定できます。レートリミッタの説明は、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Derived Nexthops",
      "section_title": true,
      "ja": "2.4.2. 派生ネクストホップ"
    },
    {
      "indent": 3,
      "text": "Derived nexthops can be:",
      "ja": "派生ネクストホップは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o weighted lists, which are used for load-balancing;",
      "ja": "o 負荷分散に使用される加重リスト。"
    },
    {
      "indent": 3,
      "text": "o preference lists, which are used for protection using primary and backup;",
      "ja": "o 優先リストは、プライマリとバックアップを使用した保護に使用されます。"
    },
    {
      "indent": 3,
      "text": "o replication lists, which are lists of nexthops to which to replicate a packet;",
      "ja": "o パケットを複製するネクストホップのリストである複製リスト。"
    },
    {
      "indent": 3,
      "text": "o nexthop chains, which are for chaining multiple operations or attaching multiple headers; or",
      "ja": "o ネクストホップチェーン。複数の操作をチェーンしたり、複数のヘッダーを添付したりするためのものです。または"
    },
    {
      "indent": 3,
      "text": "o lists of lists, which are a recursive application of the above.",
      "ja": "o 上記の再帰的な適用であるリストのリスト。"
    },
    {
      "indent": 3,
      "text": "Nexthop chains (see Section 7.2.5 for usage) are a way to perform multiple operations on a packet by logically combining them. For example, one can chain together \"decapsulate MPLS header\" and \"send it out a specific egress-interface\". Chains can be used to specify multiple headers over a packet before a packet is forwarded. One simple example is that of MPLS over GRE, wherein the packet has an inner MPLS header followed by a GRE header followed by an IP header. The outermost IP header is decided by the network device, whereas the MPLS header or GRE header is specified by the controller. Not every network device will be able to support all kinds of nexthop chains and an arbitrary number of headers chained together. The RIB data model SHOULD provide a way to expose a nexthop chaining capability supported by a given network device.",
      "ja": "ネクストホップチェーン（使用方法については、セクション7.2.5を参照）は、論理的に結合することにより、パケットに対して複数の操作を実行する方法です。たとえば、「MPLSヘッダーのカプセル化解除」と「特定の出力インターフェイスに送信」することができます。チェーンを使用すると、パケットが転送される前に、パケットに複数のヘッダーを指定できます。簡単な例の1つは、MPLS over GREの例です。パケットには、内部MPLSヘッダーの後にGREヘッダーの後にIPヘッダーが続きます。最も外側のIPヘッダーはネットワークデバイスによって決定されますが、MPLSヘッダーまたはGREヘッダーはコントローラーによって指定されます。すべてのネットワークデバイスがすべての種類のネクストホップチェーンと任意の数のヘッダーをチェーン化できるわけではありません。 RIBデータモデルは、特定のネットワークデバイスでサポートされるネクストホップチェーン機能を公開する方法を提供する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "It is expected that all network devices will have a limit on how many levels of lookup can be performed, and not all hardware will be able to support all kinds of nexthops. RIB capability negotiation becomes very important for this reason, and a RIB data model MUST specify a way for a RIB client to learn about the network device's capabilities.",
      "ja": "すべてのネットワークデバイスには、実行できるルックアップのレベル数に制限があり、すべてのハードウェアがあらゆる種類のネクストホップをサポートできるわけではありません。このため、RIB機能のネゴシエーションは非常に重要になります。RIBデータモデルでは、RIBクライアントがネットワークデバイスの機能を学習する方法を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.2.1. Nexthop List Attributes",
      "section_title": true,
      "ja": "2.4.2.1. Nexthopリストの属性"
    },
    {
      "indent": 3,
      "text": "For nexthops that are of the form of a list(s), attributes can be associated with each member of the list to indicate the role of an individual member of the list. Two attributes are specified:",
      "ja": "リストの形式のネクストホップの場合、属性をリストの各メンバーに関連付けて、リストの個々のメンバーの役割を示すことができます。 2つの属性が指定されています。"
    },
    {
      "indent": 3,
      "text": "o NEXTHOP_PREFERENCE: This is used for protection schemes. It is an integer value between 1 and 99. A lower value indicates higher preference. To download a primary/standby pair to the FIB, the nexthops that are resolved and have the two highest preferences are selected. Each <NEXTHOP_PREFERENCE> should have a unique value within a <nexthop-protection> (see Section 6).",
      "ja": "o NEXTHOP_PREFERENCE：これは保護スキームに使用されます。 1〜99の整数値です。値が小さいほど、優先度が高くなります。プライマリ/スタンバイペアをFIBにダウンロードするために、解決され、優先度が最も高い2つのネクストホップが選択されます。各<NEXTHOP_PREFERENCE>は、<nexthop-protection>内で一意の値を持つ必要があります（セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "o NEXTHOP_LB_WEIGHT: This is used for load-balancing. Each list member MUST be assigned a weight between 1 and 99. The weight determines the proportion of traffic to be sent over a nexthop used for forwarding as a ratio of the weight of this nexthop divided by the weights of all the nexthops of this route that are used for forwarding. To perform equal load-balancing, one MAY specify a weight of \"0\" for all the member nexthops. The value \"0\" is reserved for equal load-balancing and, if applied, MUST be applied to all member nexthops. Note that a weight of 0 is special because of historical reasons.",
      "ja": "o NEXTHOP_LB_WEIGHT：これは負荷分散に使用されます。各リストメンバーには1〜99の重みを割り当てる必要があります。重みは、転送に使用されるネクストホップを介して送信されるトラフィックの割合を、このルートのすべてのネクストホップの重みで割ったこのネクストホップの重みの比率として決定します。転送に使用されます。均等なロードバランシングを実行するには、すべてのメンバーのネクストホップに「0」の重みを指定できます。値「0」は、均等なロードバランシング用に予約されており、適用する場合は、すべてのメンバーのネクストホップに適用する必要があります。歴史的な理由により、重み0は特別であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Nexthop Indirection",
      "section_title": true,
      "ja": "2.4.3. ネクストホップインダイレクション"
    },
    {
      "indent": 3,
      "text": "Nexthops can be identified by an identifier to create a level of indirection. The identifier is set by the RIB manager and returned to the RIB client on request.",
      "ja": "ネクストホップは、間接参照のレベルを作成するための識別子によって識別できます。 IDはRIBマネージャーによって設定され、要求に応じてRIBクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "One example of usage of indirection is a nexthop that points to another network device (e.g., a BGP peer). The returned nexthop identifier can then be used for programming routes to point to the this nexthop. Given that the RIB manager has created an indirection using the nexthop identifier, if the transport path to the network device (BGP peer) changes, that change in path will be seamless to the RIB client and all routes that point to that network device will automatically start going over the new transport path. Nexthop indirection using identifiers could be applied to not only unicast nexthops but also nexthops that contain chains and nested nexthops. See Section 2.4.2 for examples.",
      "ja": "インダイレクションの使用例の1つは、別のネットワークデバイス（BGPピアなど）を指すネクストホップです。返されたネクストホップ識別子は、このネクストホップを指すようにルートをプログラミングするために使用できます。 RIBマネージャーがネクストホップ識別子を使用してインダイレクションを作成した場合、ネットワークデバイス（BGPピア）へのトランスポートパスが変更されると、パスのその変更はRIBクライアントに対してシームレスになり、そのネットワークデバイスを指すすべてのルートが自動的に行われます。新しいトランスポートパスを通過し始めます。識別子を使用したネクストホップの間接化は、ユニキャストネクストホップだけでなく、チェーンとネストされたネクストホップを含むネクストホップにも適用できます。例については、セクション2.4.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Reading from the RIB",
      "section_title": true,
      "ja": "3. RIBからの読み取り"
    },
    {
      "indent": 3,
      "text": "A RIB data model MUST allow a RIB client to read entries for RIBs created by that entity. The network device administrator MAY allow reading of other RIBs by a RIB client through access lists on the network device. The details of access lists are outside the scope of this document.",
      "ja": "RIBデータモデルでは、RIBクライアントがそのエンティティによって作成されたRIBのエントリを読み取ることができるようにする必要があります。ネットワークデバイス管理者は、ネットワークデバイス上のアクセスリストを介して、RIBクライアントによる他のRIBの読み取りを許可する場合があります。アクセスリストの詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "The data model MUST support a full read of the RIB and subsequent incremental reads of changes to the RIB. When sending data to a RIB client, the RIB manager SHOULD try to send all dependencies of an object prior to sending that object.",
      "ja": "データモデルは、RIBの完全な読み取りと、RIBへの変更の後続の増分読み取りをサポートする必要があります。 RIBクライアントにデータを送信する場合、RIBマネージャーは、オブジェクトを送信する前に、そのオブジェクトのすべての依存関係を送信する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "4. Writing to the RIB",
      "section_title": true,
      "ja": "4. RIBへの書き込み"
    },
    {
      "indent": 3,
      "text": "A RIB data model MUST allow a RIB client to write entries for RIBs created by that entity. The network device administrator MAY allow writes to other RIBs by a RIB client through access lists on the network device. The details of access lists are outside the scope of this document.",
      "ja": "RIBデータモデルは、RIBクライアントがそのエンティティによって作成されたRIBのエントリを書き込むことを許可する必要があります。ネットワークデバイス管理者は、ネットワークデバイスのアクセスリストを介して、RIBクライアントによる他のRIBへの書き込みを許可してもよい（MAY）。アクセスリストの詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "When writing an object to a RIB, the RIB client SHOULD try to write all dependencies of the object prior to sending that object. The data model SHOULD support requesting identifiers for nexthops and collecting the identifiers back in the response.",
      "ja": "オブジェクトをRIBに書き込む場合、RIBクライアントは、そのオブジェクトを送信する前に、そのオブジェクトのすべての依存関係の書き込みを試行する必要があります（SHOULD）。データモデルは、ネクストホップの識別子の要求と、応答での識別子の収集をサポートする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Route programming in the RIB MUST result in a return code that contains the following attributes:",
      "ja": "RIBでのルートプログラミングは、次の属性を含む戻りコードを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Installed: Yes/No (indicates whether the route got installed in the FIB)",
      "ja": "o インストール済み：はい/いいえ（ルートがFIBにインストールされたかどうかを示します）"
    },
    {
      "indent": 3,
      "text": "o Active: Yes/No (indicates whether a route is fully resolved and is a candidate for selection)",
      "ja": "o アクティブ：はい/いいえ（ルートが完全に解決され、選択の候補であるかどうかを示します）"
    },
    {
      "indent": 3,
      "text": "o Reason: E.g., \"Not authorized\"",
      "ja": "o 理由：例：「未承認」"
    },
    {
      "indent": 3,
      "text": "The data model MUST specify which objects can be modified. An object that can be modified is one whose contents can be changed without having to change objects that depend on it and without affecting any data forwarding. To change a non-modifiable object, one will need to create a new object and delete the old one. For example, routes that use a nexthop that is identified by a nexthop identifier should be unaffected when the contents of that nexthop changes.",
      "ja": "データモデルは、変更できるオブジェクトを指定する必要があります。変更可能なオブジェクトとは、それに依存するオブジェクトを変更する必要がなく、データ転送に影響を与えることなく、内容を変更できるオブジェクトです。変更不可能なオブジェクトを変更するには、新しいオブジェクトを作成し、古いオブジェクトを削除する必要があります。たとえば、ネクストホップ識別子で識別されるネクストホップを使用するルートは、そのネクストホップの内容が変更されても影響を受けません。"
    },
    {
      "indent": 0,
      "text": "5. Notifications",
      "section_title": true,
      "ja": "5. お知らせ"
    },
    {
      "indent": 3,
      "text": "Asynchronous notifications are sent by the network device's RIB manager to a RIB client when some event occurs on the network device. A RIB data model MUST support sending asynchronous notifications. A brief list of suggested notifications is as below:",
      "ja": "非同期通知は、ネットワークデバイスで何らかのイベントが発生したときに、ネットワークデバイスのRIBマネージャーによってRIBクライアントに送信されます。 RIBデータモデルは、非同期通知の送信をサポートする必要があります。推奨される通知の簡単なリストは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Route change notification (with a return code as specified in Section 4)",
      "ja": "o ルート変更通知（セクション4で指定された戻りコード付き）"
    },
    {
      "indent": 3,
      "text": "o Nexthop resolution status (resolved/unresolved) notification",
      "ja": "o ネクストホップ解決ステータス（解決済み/未解決）通知"
    },
    {
      "indent": 0,
      "text": "6. RIB Grammar",
      "section_title": true,
      "ja": "6. RIB文法"
    },
    {
      "indent": 3,
      "text": "This section specifies the RIB information model in Routing Backus-Naur Form (rBNF) [RFC5511]. This grammar is intended to help the reader better understand Section 2 in order to derive a data model.",
      "ja": "このセクションでは、Routing Backus-Naur Form（rBNF）[RFC5511]のRIB情報モデルを指定します。この文法は、データモデルを導出するために、読者がセクション2をよりよく理解できるようにすることを目的としています。"
    },
    {
      "indent": 1,
      "text": "<routing-instance> ::= <INSTANCE_NAME>\n                       [<interface-list>] <rib-list>\n                       [<ROUTER_ID>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<interface-list> ::= (<INTERFACE_IDENTIFIER> ...)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<rib-list> ::= (<rib> ...)\n<rib> ::= <rib-name> <address-family>\n                    [<route> ... ]\n                    [ENABLE_IP_RPF_CHECK]\n<address-family> ::= <IPV4_ADDRESS_FAMILY> | <IPV6_ADDRESS_FAMILY> |\n                     <MPLS_ADDRESS_FAMILY> | <IEEE_MAC_ADDRESS_FAMILY>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<route> ::= <match> <nexthop>\n            [<route-attributes>]\n            [<route-vendor-attributes>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<match> ::= <IPV4> <ipv4-route> | <IPV6> <ipv6-route> |\n            <MPLS> <MPLS_LABEL> | <IEEE_MAC> <MAC_ADDRESS> |\n            <INTERFACE> <INTERFACE_IDENTIFIER>\n<route-type> ::= <IPV4> | <IPV6> | <MPLS> | <IEEE_MAC> | <INTERFACE>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<ipv4-route> ::= <ip-route-type>\n                 (<destination-ipv4-address> | <source-ipv4-address> |\n                  (<destination-ipv4-address> <source-ipv4-address>))\n<destination-ipv4-address> ::= <ipv4-prefix>\n<source-ipv4-address> ::= <ipv4-prefix>\n<ipv4-prefix> ::= <IPV4_ADDRESS> <IPV4_PREFIX_LENGTH>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<ipv6-route> ::= <ip-route-type>\n                 (<destination-ipv6-address> | <source-ipv6-address> |\n                  (<destination-ipv6-address> <source-ipv6-address>))\n<destination-ipv6-address> ::= <ipv6-prefix>\n<source-ipv6-address> ::= <ipv6-prefix>\n<ipv6-prefix> ::= <IPV6_ADDRESS> <IPV6_PREFIX_LENGTH>\n<ip-route-type> ::= <SRC> | <DEST> | <DEST_SRC>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<route-attributes> ::= <ROUTE_PREFERENCE> [<LOCAL_ONLY>]\n                       [<address-family-route-attributes>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<address-family-route-attributes> ::= <ip-route-attributes> |\n                                      <mpls-route-attributes> |\n                                      <ethernet-route-attributes>\n<ip-route-attributes> ::= <>\n<mpls-route-attributes> ::= <>\n<ethernet-route-attributes> ::= <>\n<route-vendor-attributes> ::= <>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop> ::= <nexthop-base> |\n              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>) |\n              (<NEXTHOP_PROTECTION> <nexthop-protection>) |\n              (<NEXTHOP_REPLICATE> <nexthop-replicate>) |\n              <nexthop-chain>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-base> ::= <NEXTHOP_ID> |\n                   <nexthop-special> |\n                   <egress-interface> |\n                   <ipv4-address> | <ipv6-address> |\n                   (<egress-interface>\n                       (<ipv4-address> | <ipv6-address>)) |\n                   (<egress-interface> <IEEE_MAC_ADDRESS>) |\n                   <tunnel-encapsulation> | <tunnel-decapsulation> |\n                   <logical-tunnel> |\n                   <rib-name>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<egress-interface> ::= <INTERFACE_IDENTIFIER>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-special> ::= <DISCARD> | <DISCARD_WITH_ERROR> |\n                      (<RECEIVE> [<COS_VALUE>])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-lb> ::= <NEXTHOP_LB_WEIGHT> <nexthop>\n                 (<NEXTHOP_LB_WEIGHT> <nexthop) ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-protection> = <NEXTHOP_PREFERENCE> <nexthop>\n                      (<NEXTHOP_PREFERENCE> <nexthop>)...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-replicate> ::= <nexthop> <nexthop> ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<nexthop-chain> ::= <nexthop> ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<logical-tunnel> ::= <tunnel-type> <TUNNEL_NAME>\n<tunnel-type> ::= <IPV4> | <IPV6> | <MPLS> | <GRE> | <VxLAN> | <NVGRE>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<tunnel-encapsulation> ::= (<IPV4> <ipv4-header>) |\n                           (<IPV6> <ipv6-header>) |\n                           (<MPLS> <mpls-header>) |\n                           (<GRE> <gre-header>) |\n                           (<VXLAN> <vxlan-header>) |\n                           (<NVGRE> <nvgre-header>)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<ipv4-header> ::= <SOURCE_IPv4_ADDRESS> <DESTINATION_IPv4_ADDRESS>\n                  <PROTOCOL> [<TTL>] [<DSCP>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<ipv6-header> ::= <SOURCE_IPV6_ADDRESS> <DESTINATION_IPV6_ADDRESS>\n                  <NEXT_HEADER> [<TRAFFIC_CLASS>]\n                  [<FLOW_LABEL>] [<HOP_LIMIT>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<mpls-header> ::= (<mpls-label-operation> ...)\n<mpls-label-operation> ::= (<MPLS_PUSH> <MPLS_LABEL> [<S_BIT>]\n                                        [<TOS_VALUE>] [<TTL_VALUE>]) |\n                           (<MPLS_SWAP> <IN_LABEL> <OUT_LABEL>\n                                       [<TTL_ACTION>])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<gre-header> ::= <GRE_IP_DESTINATION> <GRE_PROTOCOL_TYPE> [<GRE_KEY>]\n<vxlan-header> ::= (<ipv4-header> | <ipv6-header>)\n                   [<VXLAN_IDENTIFIER>]\n<nvgre-header> ::= (<ipv4-header> | <ipv6-header>)\n                   <VIRTUAL_SUBNET_ID>\n                   [<FLOW_ID>]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "<tunnel-decapsulation> ::= ((<IPV4> <IPV4_DECAP> [<TTL_ACTION>]) |\n                           (<IPV6> <IPV6_DECAP> [<HOP_LIMIT_ACTION>]) |\n                           (<MPLS> <MPLS_POP> [<TTL_ACTION>]))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 5: RIB rBNF Grammar",
      "ja": "図5：RIB rBNF文法"
    },
    {
      "indent": 0,
      "text": "6.1. Nexthop Grammar Explained",
      "section_title": true,
      "ja": "6.1. Nexthop文法の説明"
    },
    {
      "indent": 3,
      "text": "A nexthop is used to specify the next network element to forward the traffic to. It is also used to specify how the traffic should be load-balanced, protected using preference, or multicast using replication. This is explicitly specified in the grammar. The nexthop has recursion built in to address complex use cases like the one defined in Section 7.2.6.",
      "ja": "ネクストホップは、トラフィックを転送する次のネットワーク要素を指定するために使用されます。また、トラフィックの負荷分散、プリファレンスを使用した保護、またはレプリケーションを使用したマルチキャストの方法を指定するためにも使用されます。これは文法で明示的に指定されています。ネクストホップには、セクション7.2.6で定義されているような複雑なユースケースに対処するための再帰が組み込まれています。"
    },
    {
      "indent": 0,
      "text": "7. Using the RIB Grammar",
      "section_title": true,
      "ja": "7. RIB文法の使用"
    },
    {
      "indent": 3,
      "text": "The RIB grammar is very generic and covers a variety of features. This section provides examples on using objects in the RIB grammar and examples to program certain use cases.",
      "ja": "RIB文法は非常に一般的で、さまざまな機能をカバーしています。このセクションでは、RIB文法でオブジェクトを使用する例と、特定のユースケースをプログラムする例を示します。"
    },
    {
      "indent": 0,
      "text": "7.1. Using Route Preference",
      "section_title": true,
      "ja": "7.1. ルート設定の使用"
    },
    {
      "indent": 3,
      "text": "Using route preference, a client can preinstall alternate paths in the network. For example, if OSPF has a route preference of 10, then another client can install a route with a route preference of 20 to the same destination. The OSPF route will get precedence and will get installed in the FIB. When the OSPF route is withdrawn, the alternate path will get installed in the FIB.",
      "ja": "ルートプリファレンスを使用して、クライアントはネットワークに代替パスをプレインストールできます。たとえば、OSPFのルートプリファレンスが10の場合、別のクライアントはルートプリファレンスが20のルートを同じ宛先にインストールできます。 OSPFルートが優先され、FIBにインストールされます。 OSPFルートが撤回されると、代替パスがFIBにインストールされます。"
    },
    {
      "indent": 3,
      "text": "Route preference can also be used to prevent denial-of-service attacks by installing routes with the best preference, which either drops the offending traffic or routes it to some monitoring/analysis station. Since the routes are installed with the best preference, they will supersede any route installed by any other protocol.",
      "ja": "ルートプリファレンスは、問題のあるトラフィックをドロップするか、監視/分析ステーションにルーティングするベストプリファレンスのルートをインストールすることにより、サービス拒否攻撃を防ぐためにも使用できます。ルートは最適な設定でインストールされるため、他のプロトコルでインストールされたルートよりも優先されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Using Different Nexthop Types",
      "section_title": true,
      "ja": "7.2. 異なるネクストホップタイプの使用"
    },
    {
      "indent": 3,
      "text": "The RIB grammar allows one to create a variety of nexthops. This section describes uses for certain types of nexthops.",
      "ja": "RIB文法により、さまざまなネクストホップを作成できます。このセクションでは、特定のタイプのネクストホップの使用法について説明します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Tunnel Nexthops",
      "section_title": true,
      "ja": "7.2.1. トンネルネクストホップ"
    },
    {
      "indent": 3,
      "text": "A tunnel nexthop points to a tunnel of some kind. Traffic that goes over the tunnel gets encapsulated with the tunnel-encapsulation. Tunnel nexthops are useful for abstracting out details of the network by having the traffic seamlessly route between network edges. At the end of a tunnel, the tunnel will get decapsulated. Thus, the grammar supports two kinds of operations: one for encapsulation and another for decapsulation.",
      "ja": "トンネルのネクストホップは、何らかのトンネルを指します。トンネルを通過するトラフィックは、トンネルカプセル化によってカプセル化されます。トンネルネクストホップは、ネットワークエッジ間でトラフィックをシームレスにルーティングすることにより、ネットワークの詳細を抽象化するのに役立ちます。トンネルの終わりに、トンネルはカプセル化を解除されます。したがって、文法は2種類の操作をサポートしています。1つはカプセル化、もう1つはカプセル化解除です。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Replication Lists",
      "section_title": true,
      "ja": "7.2.2. レプリケーションリスト"
    },
    {
      "indent": 3,
      "text": "One can create a replication list for replicating traffic to multiple destinations. The destinations, in turn, could be derived nexthops in themselves (at a level supported by the network device); point to multipoint and broadcast are examples that involve replication.",
      "ja": "トラフィックを複数の宛先に複製するための複製リストを作成できます。次に、宛先はそれ自体から派生したネクストホップ（ネットワークデバイスでサポートされているレベル）になります。ポイントツーマルチポイントおよびブロードキャストは、レプリケーションを含む例です。"
    },
    {
      "indent": 3,
      "text": "A replication list (at the simplest level) can be represented as:",
      "ja": "複製リスト（最も単純なレベル）は次のように表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> [ <nexthop> ... ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "上記は、次のように文法から導出できます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <nexthop-replicate>\n<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> <nexthop> ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.3. Weighted Lists",
      "section_title": true,
      "ja": "7.2.3. 加重リスト"
    },
    {
      "indent": 3,
      "text": "A weighted list is used to load-balance traffic among a set of nexthops. From a modeling perspective, a weighted list is very similar to a replication list, with the difference that each member nexthop MUST have a NEXTHOP_LB_WEIGHT associated with it.",
      "ja": "重み付きリストは、ネクストホップのセット間でトラフィックを負荷分散するために使用されます。モデリングの観点から、加重リストはレプリケーションリストに非常に似ていますが、各メンバーのネクストホップにはNEXTHOP_LB_WEIGHTが関連付けられている必要があるという違いがあります。"
    },
    {
      "indent": 3,
      "text": "A weighted list (at the simplest level) can be represented as:",
      "ja": "加重リスト（最も単純なレベル）は次のように表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<nexthop> <NEXTHOP_LB_WEIGHT>)\n                   [(<nexthop> <NEXTHOP_LB_WEIGHT>)... ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "上記は、次のように文法から導出できます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <nexthop-lb>\n<nexthop> ::= <NEXTHOP_LOAD_BALANCE>\n                <NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...\n<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<NEXTHOP_LB_WEIGHT> <nexthop>)\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.4. Protection",
      "section_title": true,
      "ja": "7.2.4. 保護"
    },
    {
      "indent": 3,
      "text": "A primary/backup protection can be represented as:",
      "ja": "プライマリ/バックアップ保護は次のように表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> <1> <interface-primary>\n                                   <2> <interface-backup>)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "上記は、次のように文法から導出できます。"
    },
    {
      "indent": 0,
      "text": "<nexthop> ::= <nexthop-protection>\n<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n                      (<NEXTHOP_PREFERENCE> <nexthop>)...)\n<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n                      (<NEXTHOP_PREFERENCE> <nexthop>))\n<nexthop> ::= <NEXTHOP_PROTECTION> ((<NEXTHOP_PREFERENCE> <nexthop-base>\n                      (<NEXTHOP_PREFERENCE> <nexthop-base>))\n<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <interface-primary>\n                      (<2> <interface-backup>))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Traffic can be load-balanced among multiple primary nexthops and a single backup. In such a case, the nexthop will look like:",
      "ja": "トラフィックは、複数のプライマリネクストホップと単一のバックアップ間で負荷分散できます。このような場合、ネクストホップは次のようになります。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> (<1>\n              (<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop-base>\n               (<NEXTHOP_LB_WEIGHT> <nexthop-base>) ...))\n                <2> <nexthop-base>)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A backup can also have another backup. In such a case, the list will look like:",
      "ja": "バックアップは別のバックアップを持つこともできます。このような場合、リストは次のようになります。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <nexthop>\n              <2> <NEXTHOP_PROTECTION>(<1> <nexthop> <2> <nexthop>))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.5. Nexthop Chains",
      "section_title": true,
      "ja": "7.2.5. Nexthopチェーン"
    },
    {
      "indent": 3,
      "text": "A nexthop chain is a way to perform multiple operations on a packet by logically combining them. For example, when a VPN packet comes on the WAN interface and has to be forwarded to the correct VPN interface, one needs to pop the VPN label before sending the packet out. Using a nexthop chain, one can chain together \"pop MPLS header\" and \"send it out a specific egress-interface\".",
      "ja": "ネクストホップチェーンは、パケットを論理的に組み合わせて複数の操作を実行する方法です。たとえば、VPNパケットがWANインターフェイスに到達し、正しいVPNインターフェイスに転送する必要がある場合、パケットを送信する前にVPNラベルをポップする必要があります。ネクストホップチェーンを使用すると、「ポップMPLSヘッダー」を連鎖させ、「特定の出力インターフェイスに送信する」ことができます。"
    },
    {
      "indent": 3,
      "text": "The above example can be derived from the grammar as follows:",
      "ja": "上記の例は、次のように文法から導出できます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= <nexthop> <nexthop>\n<nexthop-chain> ::= <nexthop-base> <nexthop-base>\n<nexthop-chain> ::= <tunnel-decapsulation> <egress-interface>\n<nexthop-chain> ::= (<MPLS> <MPLS_POP>) <interface-outgoing>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Elements in a nexthop chain are evaluated left to right.",
      "ja": "ネクストホップチェーンの要素は、左から右に評価されます。"
    },
    {
      "indent": 3,
      "text": "A nexthop chain can also be used to put one or more headers on an outgoing packet. One example is a pseudowire, which is MPLS over some transport (MPLS or GRE, for instance). Another example is Virtual eXtensible Local Area Network (VXLAN) over IP. A nexthop chain thus allows a RIB client to break up the programming of the nexthop into independent pieces (one per encapsulation).",
      "ja": "ネクストホップチェーンを使用して、発信パケットに1つ以上のヘッダーを付けることもできます。 1つの例は、いくつかのトランスポート（たとえば、MPLSまたはGRE）上のMPLSである疑似配線です。別の例は、IP上の仮想拡張可能ローカルエリアネットワーク（VXLAN）です。したがって、ネクストホップチェーンにより、RIBクライアントはネクストホップのプログラミングを独立した部分（カプセル化ごとに1つ）に分割できます。"
    },
    {
      "indent": 3,
      "text": "A simple example of MPLS over GRE can be represented as follows:",
      "ja": "MPLS over GREの簡単な例は、次のように表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)\n                    <interface-outgoing>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "上記は、次のように文法から導出できます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= <nexthop> <nexthop> <nexthop>\n<nexthop-chain> ::= <nexthop-base> <nexthop-base> <nexthop-base>\n<nexthop-chain> ::= <tunnel-encapsulation> <tunnel-encapsulation>\n                    <egress-interface>\n<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)\n                    <interface-outgoing>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.6. Lists of Lists",
      "section_title": true,
      "ja": "7.2.6. リストのリスト"
    },
    {
      "indent": 3,
      "text": "Lists of lists is a derived construct. One example of usage of such a construct is to replicate traffic to multiple destinations with load-balancing. In other words, for each branch of the replication tree, there are multiple interfaces on which traffic needs to be load-balanced. So, the outer list is a replication list for multicast and the inner lists are weighted lists for load-balancing. Let's take an example of a network element that has to replicate traffic to two other network elements. Traffic to the first network element should be load-balanced equally over two interfaces: outgoing-1-1 and outgoing-1-2. Traffic to the second network element should be load-balanced over three interfaces: outgoing-2-1, outgoing-2-2, and outgoing-2-3 (in the ratio 20:20:60).",
      "ja": "リストのリストは派生構造です。このような構成の使用例の1つは、ロードバランシングを使用してトラフィックを複数の宛先に複製することです。つまり、レプリケーションツリーのブランチごとに、トラフィックの負荷分散が必要なインターフェイスが複数あります。したがって、外部リストはマルチキャストのレプリケーションリストであり、内部リストはロードバランシング用の重み付きリストです。他の2つのネットワーク要素にトラフィックを複製する必要があるネットワーク要素の例を見てみましょう。最初のネットワーク要素へのトラフィックは、2つのインターフェイス（outgoing-1-1とoutgoing-1-2）で均等に負荷分散する必要があります。 2番目のネットワーク要素へのトラフィックは、outgoing-2-1、outgoing-2-2、outgoing-2-3の3つのインターフェイス（20:20:60の比率）で負荷分散する必要があります。"
    },
    {
      "indent": 3,
      "text": "This can be derived from the grammar as follows:",
      "ja": "これは、次のように文法から導出できます。"
    },
    {
      "indent": 0,
      "text": "<nexthop> ::= <nexthop-replicate>\n<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>...)\n<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>)\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE> <nexthop-lb>)\n              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n               ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n                ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>)\n                (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n               ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n<nexthop> ::= <NEXTHOP_REPLICATE>\n               ((<NEXTHOP_LOAD_BALANCE>\n                 (50 <outgoing-1-1>)\n                 (50 <outgoing-1-2>)))\n                ((<NEXTHOP_LOAD_BALANCE>\n                  (20 <outgoing-2-1>)\n                  (20 <outgoing-2-2>)\n                  (60 <outgoing-2-3>)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3. Performing Multicast",
      "section_title": true,
      "ja": "7.3. マルチキャストを実行する"
    },
    {
      "indent": 3,
      "text": "IP multicast involves matching a packet on (S,G) or (*,G), where both S (Source) and G (Group) are IP prefixes. Following the match, the packet is replicated to one or more recipients. How the recipients subscribe to the multicast group is outside the scope of this document.",
      "ja": "IPマルチキャストでは、（S、G）または（*、G）でパケットを照合します。S（ソース）とG（グループ）の両方がIPプレフィックスです。一致後、パケットは1人以上の受信者に複製されます。受信者がマルチキャストグループにサブスクライブする方法は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "In PIM-based multicast, the packets are IP forwarded on an IP multicast tree. The downstream nodes on each point in the multicast tree are one or more IP addresses. These can be represented as a replication list (see Section 7.2.2).",
      "ja": "PIMベースのマルチキャストでは、パケットはIPマルチキャストツリーでIP転送されます。マルチキャストツリーの各ポイントのダウンストリームノードは、1つ以上のIPアドレスです。これらは複製リストとして表すことができます（セクション7.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "In MPLS-based multicast, the packets are forwarded on a Point-to-Multipoint (P2MP) LSP. The nexthop for a P2MP LSP can be represented in the nexthop grammar as a <logical-tunnel> (P2MP LSP identifier) or a replication list (see Section 7.2.2) of <tunnel-encapsulation>, with each tunnel-encapsulation representing a single MPLS downstream nexthop.",
      "ja": "MPLSベースのマルチキャストでは、パケットはポイントツーマルチポイント（P2MP）LSPで転送されます。 P2MP LSPのネクストホップは、ネクストホップの文法で<logical-tunnel>（P2MP LSP識別子）または<tunnel-encapsulation>のレプリケーションリスト（セクション7.2.2を参照）として表すことができます。各トンネルカプセル化は、単一のMPLSダウンストリームネクストホップ。"
    },
    {
      "indent": 0,
      "text": "8. RIB Operations at Scale",
      "section_title": true,
      "ja": "8. 大規模なRIB運用"
    },
    {
      "indent": 3,
      "text": "This section discusses the scale requirements for a RIB data model. The RIB data model should be able to handle a large scale of operations to enable deployment of RIB applications in large networks.",
      "ja": "このセクションでは、RIBデータモデルのスケール要件について説明します。 RIBデータモデルは、大規模なネットワークでのRIBアプリケーションの展開を可能にするために、大規模な操作を処理できる必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1. RIB Reads",
      "section_title": true,
      "ja": "8.1. RIB読み取り"
    },
    {
      "indent": 3,
      "text": "Bulking (grouping of multiple objects in a single message) MUST be supported when a network device sends RIB data to a RIB client. Similarly, the data model MUST enable a RIB client to request data in bulk from a network device.",
      "ja": "ネットワークデバイスがRIBデータをRIBクライアントに送信する場合、バルキング（複数のオブジェクトを1つのメッセージにグループ化）をサポートする必要があります。同様に、データモデルでは、RIBクライアントがネットワークデバイスからデータをまとめて要求できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. RIB Writes",
      "section_title": true,
      "ja": "8.2. RIB書き込み"
    },
    {
      "indent": 3,
      "text": "Bulking (grouping of multiple write operations in a single message) MUST be supported when a RIB client wants to write to the RIB. The response from the network device MUST include a return-code for each write operation in the bulk message.",
      "ja": "RIBクライアントがRIBへの書き込みを希望する場合、バルキング（複数の書き込み操作を1つのメッセージにグループ化）をサポートする必要があります。ネットワークデバイスからの応答には、バルクメッセージ内の各書き込み操作の戻りコードが含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3. RIB Events and Notifications",
      "section_title": true,
      "ja": "8.3. RIBイベントと通知"
    },
    {
      "indent": 3,
      "text": "There can be cases where a single network event results in multiple events and/or notifications from the network device to a RIB client. On the other hand, due to timing of multiple things happening at the same time, a network device might have to send multiple events and/or notifications to a RIB client. The network-device-originated event/ notification message MUST support the bulking of multiple events and notifications in a single message.",
      "ja": "単一のネットワークイベントにより、ネットワークデバイスからRIBクライアントへの複数のイベントや通知が発生する場合があります。一方、複数のイベントが同時に発生するタイミングのため、ネットワークデバイスは複数のイベントや通知をRIBクライアントに送信する必要がある場合があります。 network-device-originated event / notification messageは、単一のメッセージでの複数のイベントと通知のバルクをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The information model specified in this document defines a schema for data models that are designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040]. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) [RFC6242]. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS [RFC8446].",
      "ja": "このドキュメントで指定されている情報モデルは、NETCONF [RFC6241]やRESTCONF [RFC8040]などのネットワーク管理プロトコルを介してアクセスするように設計されたデータモデルのスキーマを定義します。最下位のNETCONFレイヤーはセキュアなトランスポートレイヤーであり、実装に必須のセキュアなトランスポートはセキュアシェル（SSH）です[RFC6242]。最下位のRESTCONFレイヤーはHTTPSであり、実装に必須のセキュアなトランスポートはTLS [RFC8446]です。"
    },
    {
      "indent": 3,
      "text": "The NETCONF access control model [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.",
      "ja": "NETCONFアクセス制御モデル[RFC8341]は、特定のNETCONFまたはRESTCONFユーザーのアクセスを、利用可能なすべてのNETCONFまたはRESTCONFプロトコル操作およびコンテンツの事前構成されたサブセットに制限する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "The RIB information model specifies read and write operations to network devices. These network devices might be considered sensitive or vulnerable in some network environments. Write operations to these network devices without proper protection can have a negative effect on network operations. Due to this factor, it is recommended that data models also consider the following in their design:",
      "ja": "RIB情報モデルは、ネットワークデバイスへの読み取りおよび書き込み操作を指定します。これらのネットワークデバイスは、一部のネットワーク環境では機密または脆弱であると見なされる場合があります。適切に保護されていないこれらのネットワークデバイスへの書き込み操作は、ネットワーク操作に悪影響を及ぼす可能性があります。このため、データモデルでは、設計において次のことも考慮することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Require utilization of the authentication and authorization features of the NETCONF or RESTCONF suite of protocols.",
      "ja": "o NETCONFまたはRESTCONFプロトコルスイートの認証および許可機能の利用を要求します。"
    },
    {
      "indent": 3,
      "text": "o Augment the limits on how much data can be written or updated by a remote entity built to include enough protection for a RIB data model.",
      "ja": "o RIBデータモデルに十分な保護を組み込むために構築されたリモートエンティティが書き込みまたは更新できるデータ量の制限を強化します。"
    },
    {
      "indent": 3,
      "text": "o Expose the specific RIB data model implemented via NETCONF/ RESTCONF data models.",
      "ja": "o NETCONF / RESTCONFデータモデルを介して実装された特定のRIBデータモデルを公開します。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <https://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241] Enns、R。、編、Bjorklund、M。、編、Schoenwaelder、J。、編、およびA. Bierman、編、「Network Configuration Protocol（NETCONF）」、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<https://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC6242] Wasserman, M., \"Using the NETCONF Protocol over Secure Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011, <https://www.rfc-editor.org/info/rfc6242>.",
      "ja": "[RFC6242] Wasserman、M。、「Using the NETCONF Protocol over Secure Shell（SSH）」、RFC 6242、DOI 10.17487 / RFC6242、2011年6月、<https://www.rfc-editor.org/info/rfc6242>。"
    },
    {
      "indent": 3,
      "text": "[RFC8040] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017, <https://www.rfc-editor.org/info/rfc8040>.",
      "ja": "[RFC8040] Bierman、A.、Bjorklund、M。、およびK. Watsen、「RESTCONFプロトコル」、RFC 8040、DOI 10.17487 / RFC8040、2017年1月、<https://www.rfc-editor.org/info/rfc8040 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8341] Bierman, A. and M. Bjorklund, \"Network Configuration Access Control Model\", STD 91, RFC 8341, DOI 10.17487/RFC8341, March 2018, <https://www.rfc-editor.org/info/rfc8341>.",
      "ja": "[RFC8341] Bierman、A。およびM. Bjorklund、「Network Configuration Access Control Model」、STD 91、RFC 8341、DOI 10.17487 / RFC8341、2018年3月、<https://www.rfc-editor.org/info/rfc8341 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC4915] Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, \"Multi-Topology (MT) Routing in OSPF\", RFC 4915, DOI 10.17487/RFC4915, June 2007, <https://www.rfc-editor.org/info/rfc4915>.",
      "ja": "[RFC4915] Psenak、P.、Mirtorabi、S.、Roy、A.、Nguyen、L。、およびP. Pillay-Esnault、「OSPFでのマルチトポロジ（MT）ルーティング」、RFC 4915、DOI 10.17487 / RFC4915、 2007年6月、<https://www.rfc-editor.org/info/rfc4915>。"
    },
    {
      "indent": 3,
      "text": "[RFC5120] Przygienda, T., Shen, N., and N. Sheth, \"M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs)\", RFC 5120, DOI 10.17487/RFC5120, February 2008, <https://www.rfc-editor.org/info/rfc5120>.",
      "ja": "[RFC5120] Przygienda、T.、Shen、N。、およびN. Sheth、「M-ISIS：Multi Topology（MT）Routing in Intermediate System to Intermediate Systems（IS-ISs）」、RFC 5120、DOI 10.17487 / RFC5120、 2008年2月、<https://www.rfc-editor.org/info/rfc5120>。"
    },
    {
      "indent": 3,
      "text": "[RFC5511] Farrel, A., \"Routing Backus-Naur Form (RBNF): A Syntax Used to Form Encoding Rules in Various Routing Protocol Specifications\", RFC 5511, DOI 10.17487/RFC5511, April 2009, <https://www.rfc-editor.org/info/rfc5511>.",
      "ja": "[RFC5511] Farrel、A。、「Routing Backus-Naur Form（RBNF）：A Syntax Using Forming Encoding Rules in Various Routing Protocol Specifications」、RFC 5511、DOI 10.17487 / RFC5511、2009年4月、<https：// www。 rfc-editor.org/info/rfc5511>。"
    },
    {
      "indent": 3,
      "text": "[RFC7920] Atlas, A., Ed., Nadeau, T., Ed., and D. Ward, \"Problem Statement for the Interface to the Routing System\", RFC 7920, DOI 10.17487/RFC7920, June 2016, <https://www.rfc-editor.org/info/rfc7920>.",
      "ja": "[RFC7920] Atlas、A.、Ed。、Nadeau、T.、Ed。、and D. Ward、 \"Problem Statement for the Interface for the Routing System\"、RFC 7920、DOI 10.17487 / RFC7920、June 2016、<https： //www.rfc-editor.org/info/rfc7920>。"
    },
    {
      "indent": 3,
      "text": "[RFC8431] Wang, L., Chen, M., Dass, A., Ananthakrishnan, H., Kini, S., and N. Bahadur, \"A YANG Data Model for the Routing Information Base (RIB)\", RFC 8431, DOI 10.17487/RFC8431, September 2018, <http://www.rfc-editor.org/info/rfc8431>.",
      "ja": "[RFC8431] Wang、L.、Chen、M.、Dass、A.、Ananthakrishnan、H.、Kini、S。、およびN. Bahadur、「ルーティング情報ベース（RIB）のYANGデータモデル」、RFC 8431 、DOI 10.17487 / RFC8431、2018年9月、<http://www.rfc-editor.org/info/rfc8431>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Ron Folkes, Jeffrey Zhang, the WG co-Chairs, and reviewers for their comments and suggestions on this document. The following people contributed to the design of the RIB information model as part of the I2RS Interim meeting in April 2013:",
      "ja": "このドキュメントに対するコメントと提案を提供してくれたRon Folkes、Jeffrey Zhang、WGの共同議長、およびレビュー担当者に感謝します。 2013年4月のI2RS中間会議の一環として、以下の人々がRIB情報モデルの設計に貢献しました。"
    },
    {
      "indent": 3,
      "text": "Wes George, Chris Liljenstolpe, Jeff Tantsura, Susan Hares, and Fabian Schneider.",
      "ja": "ウェス・ジョージ、クリス・リジェンストルプ、ジェフ・タンチュラ、スーザン・ヘアズ、ファビアン・シュナイダー。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Nitin Bahadur (editor) Uber 900 Arastradero Rd Palo Alto, CA 94304 United States of America",
      "ja": "Nitin Bahadur（編集者）Uber 900 Arastradero Rd Palo Alto、CA 94304アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: nitin_bahadur@yahoo.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sriganesh Kini (editor)",
      "ja": "Sriganesh Kini（編集）"
    },
    {
      "indent": 3,
      "text": "Email: sriganeshkini@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jan Medved Cisco",
      "ja": "Jan Medved Cisco"
    },
    {
      "indent": 3,
      "text": "Email: jmedved@cisco.com",
      "raw": true,
      "ja": ""
    }
  ]
}