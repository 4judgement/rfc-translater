{
  "title": {
    "text": "RFC 8229 - TCP Encapsulation of IKE and IPsec Packets",
    "ja": "RFC 8229 - IKEおよびIPsecパケットのTCPカプセル化"
  },
  "number": 8229,
  "created_at": "2020-08-28 12:07:15.046371+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          T. Pauly\nRequest for Comments: 8229                                    Apple Inc.\nCategory: Standards Track                                      S. Touati\nISSN: 2070-1721                                                 Ericsson\n                                                               R. Mantha\n                                                           Cisco Systems\n                                                             August 2017",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "TCP Encapsulation of IKE and IPsec Packets",
      "ja": "IKEおよびIPsecパケットのTCPカプセル化"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a method to transport Internet Key Exchange Protocol (IKE) and IPsec packets over a TCP connection for traversing network middleboxes that may block IKE negotiation over UDP. This method, referred to as \"TCP encapsulation\", involves sending both IKE packets for Security Association establishment and Encapsulating Security Payload (ESP) packets over a TCP connection. This method is intended to be used as a fallback option when IKE cannot be negotiated over UDP.",
      "ja": "このドキュメントでは、UDPを介したIKEネゴシエーションをブロックする可能性のあるネットワークミドルボックスを通過するために、TCP接続を介してインターネットキー交換プロトコル（IKE）およびIPsecパケットを転送する方法について説明します。この方法は「TCPカプセル化」と呼ばれ、TCP接続を介してセキュリティアソシエーションの確立用のIKEパケットとカプセル化セキュリティペイロード（ESP）パケットの両方を送信します。この方法は、UDPを介してIKEをネゴシエートできない場合のフォールバックオプションとして使用することを目的としています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8229.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8229で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Prior Work and Motivation ..................................4\n   1.2. Terminology and Notation ...................................5\n2. Configuration ...................................................5\n3. TCP-Encapsulated Header Formats .................................6\n   3.1. TCP-Encapsulated IKE Header Format .........................6\n   3.2. TCP-Encapsulated ESP Header Format .........................7\n4. TCP-Encapsulated Stream Prefix ..................................7\n5. Applicability ...................................................8\n   5.1. Recommended Fallback from UDP ..............................8\n6. Connection Establishment and Teardown ...........................9\n7. Interaction with NAT Detection Payloads ........................11\n8. Using MOBIKE with TCP Encapsulation ............................11\n9. Using IKE Message Fragmentation with TCP Encapsulation .........12\n10. Considerations for Keep-Alives and Dead Peer Detection ........12\n11. Middlebox Considerations ......................................12\n12. Performance Considerations ....................................13\n   12.1. TCP-in-TCP ...............................................13\n   12.2. Added Reliability for Unreliable Protocols ...............14\n   12.3. Quality-of-Service Markings ..............................14\n   12.4. Maximum Segment Size .....................................14\n   12.5. Tunneling ECN in TCP .....................................14\n13. Security Considerations .......................................15\n14. IANA Considerations ...........................................16\n15. References ....................................................16\n   15.1. Normative References .....................................16\n   15.2. Informative References ...................................17",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix A. Using TCP Encapsulation with TLS ......................18\nAppendix B. Example Exchanges of TCP Encapsulation with TLS .......19\n  B.1. Establishing an IKE Session ................................19\n  B.2. Deleting an IKE Session ....................................21\n  B.3. Re-establishing an IKE Session .............................22\n  B.4. Using MOBIKE between UDP and TCP Encapsulation .............23\nAcknowledgments ...................................................25\nAuthors' Addresses ................................................25",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Internet Key Exchange Protocol version 2 (IKEv2) [RFC7296] is a protocol for establishing IPsec Security Associations (SAs), using IKE messages over UDP for control traffic, and using Encapsulating Security Payload (ESP) [RFC4303] messages for encrypted data traffic. Many network middleboxes that filter traffic on public hotspots block all UDP traffic, including IKE and IPsec, but allow TCP connections through because they appear to be web traffic. Devices on these networks that need to use IPsec (to access private enterprise networks, to route Voice over IP calls to carrier networks, or because of security policies) are unable to establish IPsec SAs. This document defines a method for encapsulating IKE control messages as well as IPsec data messages within a TCP connection.",
      "ja": "インターネットキーエクスチェンジプロトコルバージョン2（IKEv2）[RFC7296]は、IPsecセキュリティアソシエーション（SA）を確立し、UDPを介して制御トラフィックにIKEメッセージを使用し、暗号化データトラフィックにカプセル化セキュリティペイロード（ESP）[RFC4303]メッセージを使用するためのプロトコルです。 。パブリックホットスポットでトラフィックをフィルタリングする多くのネットワークミドルボックスは、IKEやIPsecを含むすべてのUDPトラフィックをブロックしますが、TCP接続はWebトラフィックのように見えるため許可します。 IPsecを使用する必要があるこれらのネットワーク上のデバイス（プライベートエンタープライズネットワークにアクセスする、Voice over IP通話をキャリアネットワークにルーティングする、またはセキュリティポリシーのため）は、IPsec SAを確立できません。このドキュメントでは、TCP接続内でIKE制御メッセージとIPsecデータメッセージをカプセル化する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Using TCP as a transport for IPsec packets adds a third option to the list of traditional IPsec transports:",
      "ja": "IPsecパケットのトランスポートとしてTCPを使用すると、従来のIPsecトランスポートのリストに3番目のオプションが追加されます。"
    },
    {
      "indent": 3,
      "text": "1. Direct. Currently, IKE negotiations begin over UDP port 500. If no Network Address Translation (NAT) device is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 500, and IPsec data packets are sent using ESP.",
      "ja": "1. 直接。現在、IKEネゴシエーションはUDPポート500で開始されます。イニシエーターとレスポンダーの間でネットワークアドレス変換（NAT）デバイスが検出されない場合、後続のIKEパケットはUDPポート500で送信され、IPsecデータパケットはESPを使用して送信されます。"
    },
    {
      "indent": 3,
      "text": "2. UDP Encapsulation [RFC3948]. If a NAT is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 4500 with four bytes of zero at the start of the UDP payload, and ESP packets are sent out over UDP port 4500. Some peers default to using UDP encapsulation even when no NAT is detected on the path, as some middleboxes do not support IP protocols other than TCP and UDP.",
      "ja": "2. UDPカプセル化[RFC3948]。イニシエーターとレスポンダーの間でNATが検出された場合、後続のIKEパケットはUDPペイロードの先頭に4バイトのゼロが付いたUDPポート4500を介して送信され、ESPパケットはUDPポート4500を介して送信されます。一部のミドルボックスはTCPおよびUDP以外のIPプロトコルをサポートしていないため、パスでNATが検出されない場合でもUDPカプセル化を使用します。"
    },
    {
      "indent": 3,
      "text": "3. TCP Encapsulation. If the other two methods are not available or appropriate, IKE negotiation packets as well as ESP packets can be sent over a single TCP connection to the peer.",
      "ja": "3. TCPカプセル化。他の2つの方法が利用できないか適切でない場合、IKEネゴシエーションパケットとESPパケットを単一のTCP接続を介してピアに送信できます。"
    },
    {
      "indent": 3,
      "text": "Direct use of ESP or UDP encapsulation should be preferred by IKE implementations due to performance concerns when using TCP encapsulation (Section 12). Most implementations should use TCP encapsulation only on networks where negotiation over UDP has been attempted without receiving responses from the peer or if a network is known to not support UDP.",
      "ja": "ESPまたはUDPカプセル化を直接使用することは、TCPカプセル化を使用するときのパフォーマンスの問題のために（セクション12）、IKE実装で推奨されます。ほとんどの実装では、ピアからの応答を受信せずにUDPを介したネゴシエーションが試行されたネットワーク、またはネットワークがUDPをサポートしていないことがわかっている場合にのみ、TCPカプセル化を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Prior Work and Motivation",
      "section_title": true,
      "ja": "1.1. 以前の仕事と動機"
    },
    {
      "indent": 3,
      "text": "Encapsulating IKE connections within TCP streams is a common approach to solve the problem of UDP packets being blocked by network middleboxes. The specific goals of this document are as follows:",
      "ja": "TCPストリーム内にIKE接続をカプセル化することは、ネットワークミドルボックスによってブロックされるUDPパケットの問題を解決するための一般的なアプローチです。このドキュメントの具体的な目標は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o To promote interoperability by defining a standard method of framing IKE and ESP messages within TCP streams.",
      "ja": "o TCPストリーム内でIKEおよびESPメッセージをフレーミングする標準的な方法を定義することにより、相互運用性を促進します。"
    },
    {
      "indent": 3,
      "text": "o To be compatible with the current IKEv2 standard without requiring modifications or extensions.",
      "ja": "o 変更や拡張を必要とせずに、現在のIKEv2標準と互換性がある。"
    },
    {
      "indent": 3,
      "text": "o To use IKE over UDP by default to avoid the overhead of other alternatives that always rely on TCP or Transport Layer Security (TLS) [RFC5246].",
      "ja": "o IKE over UDPをデフォルトで使用して、常にTCPまたはトランスポート層セキュリティ（TLS）[RFC5246]に依存する他の選択肢のオーバーヘッドを回避する。"
    },
    {
      "indent": 3,
      "text": "Some previous alternatives include:",
      "ja": "以前の代替案には次のものがあります。"
    },
    {
      "indent": 3,
      "text": "Cellular Network Access Interworking Wireless LAN (IWLAN) uses IKEv2 to create secure connections to cellular carrier networks for making voice calls and accessing other network services over Wi-Fi networks. 3GPP has recommended that IKEv2 and ESP packets be sent within a TLS connection to be able to establish connections on restrictive networks.",
      "ja": "セルラーネットワークアクセスインターワーキングワイヤレスLAN（IWLAN）は、IKEv2を使用してセルラーキャリアネットワークへの安全な接続を作成し、音声通話を行ったり、Wi-Fiネットワーク経由で他のネットワークサービスにアクセスしたりします。 3GPPは、IKEv2およびESPパケットをTLS接続内で送信して、制限的なネットワークで接続を確立できるようにすることを推奨しています。"
    },
    {
      "indent": 3,
      "text": "ISAKMP over TCP Various non-standard extensions to the Internet Security Association and Key Management Protocol (ISAKMP) have been deployed that send IPsec traffic over TCP or TCP-like packets.",
      "ja": "ISAKMP over TCPインターネットセキュリティアソシエーションおよびキー管理プロトコル（ISAKMP）に対するさまざまな非標準の拡張機能が展開され、TCPまたはTCPのようなパケットを介してIPsecトラフィックを送信します。"
    },
    {
      "indent": 3,
      "text": "Secure Sockets Layer (SSL) VPNs Many proprietary VPN solutions use a combination of TLS and IPsec in order to provide reliability. These often run on TCP port 443.",
      "ja": "Secure Sockets Layer（SSL）VPN多くの独自仕様のVPNソリューションは、信頼性を提供するためにTLSとIPsecの組み合わせを使用しています。これらは多くの場合、TCPポート443で実行されます。"
    },
    {
      "indent": 3,
      "text": "IKEv2 over TCP IKEv2 over TCP as described in [IKE-over-TCP] is used to avoid UDP fragmentation.",
      "ja": "[IKE-over-TCP]で説明されているIKEv2 over TCP IKEv2 over TCPは、UDPフラグメンテーションを回避するために使用されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology and Notation",
      "section_title": true,
      "ja": "1.2. 用語と表記"
    },
    {
      "indent": 3,
      "text": "This document distinguishes between the IKE peer that initiates TCP connections to be used for TCP encapsulation and the roles of Initiator and Responder for particular IKE messages. During the course of IKE exchanges, the role of IKE Initiator and Responder may swap for a given SA (as with IKE SA rekeys), while the Initiator of the TCP connection is still responsible for tearing down the TCP connection and re-establishing it if necessary. For this reason, this document will use the term \"TCP Originator\" to indicate the IKE peer that initiates TCP connections. The peer that receives TCP connections will be referred to as the \"TCP Responder\". If an IKE SA is rekeyed one or more times, the TCP Originator MUST remain the peer that originally initiated the first IKE SA.",
      "ja": "このドキュメントでは、TCPカプセル化に使用されるTCP接続を開始するIKEピアと、特定のIKEメッセージに対するイニシエーターおよびレスポンダーの役割を区別しています。 IKE交換の過程で、IKEイニシエーターとレスポンダーの役割が特定のSAにスワップする場合があります（IKE SAキー再生成の場合と同様）。一方、TCP接続のイニシエーターは、TCP接続を切断して再確立する責任があります。必要。このため、このドキュメントでは「TCP発信元」という用語を使用して、TCP接続を開始するIKEピアを示します。 TCP接続を受信するピアは、「TCPレスポンダ」と呼ばれます。 IKE SAが1回以上キーが再生成される場合、TCP発信者は最初のIKE SAを最初に開始したピアのままである必要があります。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Configuration",
      "section_title": true,
      "ja": "2. 構成"
    },
    {
      "indent": 3,
      "text": "One of the main reasons to use TCP encapsulation is that UDP traffic may be entirely blocked on a network. Because of this, support for TCP encapsulation is not specifically negotiated in the IKE exchange. Instead, support for TCP encapsulation must be pre-configured on both the TCP Originator and the TCP Responder.",
      "ja": "TCPカプセル化を使用する主な理由の1つは、ネットワーク上でUDPトラフィックが完全にブロックされる可能性があることです。このため、TCPカプセル化のサポートは、IKE交換では特にネゴシエートされません。代わりに、TCPカプセル化のサポートは、TCP発信者とTCPレスポンダの両方で事前設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support TCP encapsulation on TCP port 4500, which is reserved for IPsec NAT traversal.",
      "ja": "実装では、IPsec NATトラバーサル用に予約されているTCPポート4500でのTCPカプセル化をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Beyond a flag indicating support for TCP encapsulation, the configuration for each peer can include the following optional parameters:",
      "ja": "TCPカプセル化のサポートを示すフラグの他に、各ピアの設定には、次のオプションパラメータを含めることができます。"
    },
    {
      "indent": 3,
      "text": "o Alternate TCP ports on which the specific TCP Responder listens for incoming connections. Note that the TCP Originator may initiate TCP connections to the TCP Responder from any local port.",
      "ja": "o 特定のTCPレスポンダが着信接続をリッスンする代替TCPポート。 TCP Originatorは、任意のローカルポートからTCP ResponderへのTCP接続を開始する場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o An extra framing protocol to use on top of TCP to further encapsulate the stream of IKE and IPsec packets. See Appendix A for a detailed discussion.",
      "ja": "o TCPの上で使用する追加のフレーミングプロトコル。IKEおよびIPsecパケットのストリームをさらにカプセル化します。詳細については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Since TCP encapsulation of IKE and IPsec packets adds overhead and has potential performance trade-offs compared to direct or UDP-encapsulated SAs (as described in Section 12), implementations SHOULD prefer ESP direct or UDP-encapsulated SAs over TCP-encapsulated SAs when possible.",
      "ja": "IKEおよびIPsecパケットのTCPカプセル化はオーバーヘッドを追加し、直接またはUDPカプセル化SA（セクション12で説明）と比較して潜在的なパフォーマンストレードオフがあるため、実装は、可能な場合、TCPカプセル化SAよりもESP直接またはUDPカプセル化SAを優先する必要があります。 。"
    },
    {
      "indent": 0,
      "text": "3. TCP-Encapsulated Header Formats",
      "section_title": true,
      "ja": "3. TCPカプセル化ヘッダー形式"
    },
    {
      "indent": 3,
      "text": "Like UDP encapsulation, TCP encapsulation uses the first four bytes of a message to differentiate IKE and ESP messages. TCP encapsulation also adds a Length field to define the boundaries of messages within a stream. The message length is sent in a 16-bit field that precedes every message. If the first 32 bits of the message are zeros (a non-ESP marker), then the contents comprise an IKE message. Otherwise, the contents comprise an ESP message. Authentication Header (AH) messages are not supported for TCP encapsulation.",
      "ja": "UDPカプセル化と同様に、TCPカプセル化もメッセージの最初の4バイトを使用して、IKEメッセージとESPメッセージを区別します。 TCPカプセル化では、ストリーム内のメッセージの境界を定義するためのLengthフィールドも追加されます。メッセージの長さは、すべてのメッセージの前にある16ビットのフィールドで送信されます。メッセージの最初の32ビットがゼロ（非ESPマーカー）の場合、内容はIKEメッセージを構成します。それ以外の場合、コンテンツにはESPメッセージが含まれます。認証ヘッダー（AH）メッセージは、TCPカプセル化ではサポートされていません。"
    },
    {
      "indent": 3,
      "text": "Although a TCP stream may be able to send very long messages, implementations SHOULD limit message lengths to typical UDP datagram ESP payload lengths. The maximum message length is used as the effective MTU for connections that are being encrypted using ESP, so the maximum message length will influence characteristics of inner connections, such as the TCP Maximum Segment Size (MSS).",
      "ja": "TCPストリームは非常に長いメッセージを送信できる可能性がありますが、実装では、メッセージの長さを一般的なUDPデータグラムのESPペイロードの長さに制限する必要があります（SHOULD）。最大メッセージ長は、ESPを使用して暗号化されている接続の有効なMTUとして使用されるため、最大メッセージ長は、TCP最大セグメントサイズ（MSS）などの内部接続の特性に影響します。"
    },
    {
      "indent": 3,
      "text": "Note that this method of encapsulation will also work for placing IKE and ESP messages within any protocol that presents a stream abstraction, beyond TCP.",
      "ja": "このカプセル化方式は、TCPを超えてストリームの抽象化を提供する任意のプロトコル内にIKEおよびESPメッセージを配置する場合にも機能することに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. TCP-Encapsulated IKE Header Format",
      "section_title": true,
      "ja": "3.1. TCPカプセル化IKEヘッダー形式"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Non-ESP Marker                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                      IKE header [RFC7296]                     ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The IKE header is preceded by a 16-bit Length field in network byte order that specifies the length of the IKE message (including the non-ESP marker) within the TCP stream. As with IKE over UDP port 4500, a zeroed 32-bit non-ESP marker is inserted before the start of the IKE header in order to differentiate the traffic from ESP traffic between the same addresses and ports.",
      "ja": "IKEヘッダーの前には、TCPバイトストリーム内のIKEメッセージ（非ESPマーカーを含む）の長さを指定するネットワークバイトオーダーの16ビットの長さフィールドがあります。 IKE over UDPポート4500と同様に、トラフィックを同じアドレスとポートの間のESPトラフィックと区別するために、IKEヘッダーの開始前にゼロ化された32ビットの非ESPマーカーが挿入されます。"
    },
    {
      "indent": 3,
      "text": "o Length (2 octets, unsigned integer) - Length of the IKE packet, including the Length field and non-ESP marker.",
      "ja": "o 長さ（2オクテット、符号なし整数）-長さフィールドと非ESPマーカーを含む、IKEパケットの長さ。"
    },
    {
      "indent": 0,
      "text": "3.2. TCP-Encapsulated ESP Header Format",
      "section_title": true,
      "ja": "3.2. TCPカプセル化ESPヘッダー形式"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                     ESP header [RFC4303]                      ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "The ESP header is preceded by a 16-bit Length field in network byte order that specifies the length of the ESP packet within the TCP stream.",
      "ja": "ESPヘッダーの前には、TCPバイトストリーム内のESPパケットの長さを指定するネットワークバイトオーダーの16ビットの長さフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "The Security Parameter Index (SPI) field [RFC7296] in the ESP header MUST NOT be a zero value.",
      "ja": "ESPヘッダーのセキュリティパラメータインデックス（SPI）フィールド[RFC7296]はゼロ値であってはなりません。"
    },
    {
      "indent": 3,
      "text": "o Length (2 octets, unsigned integer) - Length of the ESP packet, including the Length field.",
      "ja": "o 長さ（2オクテット、符号なし整数）-長さフィールドを含む、ESPパケットの長さ。"
    },
    {
      "indent": 0,
      "text": "4. TCP-Encapsulated Stream Prefix",
      "section_title": true,
      "ja": "4. TCPカプセル化ストリームプレフィックス"
    },
    {
      "indent": 3,
      "text": "Each stream of bytes used for IKE and IPsec encapsulation MUST begin with a fixed sequence of six bytes as a magic value, containing the characters \"IKETCP\" as ASCII values. This value is intended to identify and validate that the TCP connection is being used for TCP encapsulation as defined in this document, to avoid conflicts with the prevalence of previous non-standard protocols that used TCP port 4500. This value is only sent once, by the TCP Originator only, at the beginning of any stream of IKE and ESP messages.",
      "ja": "IKEおよびIPsecカプセル化に使用される各バイトストリームは、マジック値として6バイトの固定シーケンスで始まり、ASCII値として「IKETCP」という文字が含まれている必要があります。この値は、このドキュメントで定義されているように、TCP接続がTCPカプセル化に使用されていることを識別および検証して、TCPポート4500を使用していた以前の非標準プロトコルの普及との競合を回避することを目的としています。この値は、 TCP発信者のみ、IKEおよびESPメッセージのストリームの最初。"
    },
    {
      "indent": 0,
      "text": " If other framing protocols are used within TCP to further encapsulate or encrypt the stream of IKE and ESP messages, the stream prefix must be at the start of the TCP Originator's IKE and ESP message stream within the added protocol layer (Appendix A). Although some framing protocols do support negotiating inner protocols, the stream prefix should always be used in order for implementations to be as generic as possible and not rely on other framing protocols on top of TCP.",
      "ja": "TCP内で他のフレーミングプロトコルを使用してIKEおよびESPメッセージのストリームをさらにカプセル化または暗号化する場合、ストリームプレフィックスは、追加されたプロトコルレイヤー内のTCP発信者のIKEおよびESPメッセージストリームの先頭にある必要があります（付録A）。一部のフレーミングプロトコルは内部プロトコルのネゴシエーションをサポートしていますが、実装を可能な限り汎用的にし、TCP上の他のフレーミングプロトコルに依存しないように、ストリームプレフィックスを常に使用する必要があります。"
    },
    {
      "indent": 15,
      "text": " 0      1      2      3      4      5\n+------+------+------+------+------+------+\n| 0x49 | 0x4b | 0x45 | 0x54 | 0x43 | 0x50 |\n+------+------+------+------+------+------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 0,
      "text": "5. Applicability",
      "section_title": true,
      "ja": "5. 適用性"
    },
    {
      "indent": 3,
      "text": "TCP encapsulation is applicable only when it has been configured to be used with specific IKE peers. If a Responder is configured to use TCP encapsulation, it MUST listen on the configured port(s) in case any peers will initiate new IKE sessions. Initiators MAY use TCP encapsulation for any IKE session to a peer that is configured to support TCP encapsulation, although it is recommended that Initiators should only use TCP encapsulation when traffic over UDP is blocked.",
      "ja": "TCPカプセル化は、特定のIKEピアで使用するように構成されている場合にのみ適用できます。レスポンダがTCPカプセル化を使用するように構成されている場合、ピアが新しいIKEセッションを開始する場合に備えて、構成されたポートでリッスンする必要があります。イニシエーターは、TCPカプセル化をサポートするように構成されたピアへのすべてのIKEセッションにTCPカプセル化を使用できます（ただし、UDP上のトラフィックがブロックされている場合にのみイニシエーターがTCPカプセル化を使用することをお勧めします）。"
    },
    {
      "indent": 3,
      "text": "Since the support of TCP encapsulation is a configured property, not a negotiated one, it is recommended that if there are multiple IKE endpoints representing a single peer (such as multiple machines with different IP addresses when connecting by Fully Qualified Domain Name, or endpoints used with IKE redirection), all of the endpoints equally support TCP encapsulation.",
      "ja": "TCPカプセル化のサポートは構成されたプロパティであり、ネゴシエートされたプロパティではないため、単一のピアを表す複数のIKEエンドポイント（完全修飾ドメイン名で接続するときに異なるIPアドレスを持つ複数のマシン、または使用されるエンドポイントなど）がある場合に推奨されますIKEリダイレクションの場合）、すべてのエンドポイントがTCPカプセル化を等しくサポートします。"
    },
    {
      "indent": 3,
      "text": "If TCP encapsulation is being used for a specific IKE SA, all messages for that IKE SA and its Child SAs MUST be sent over a TCP connection until the SA is deleted or IKEv2 Mobility and Multihoming (MOBIKE) is used to change the SA endpoints and/or the encapsulation protocol. See Section 8 for more details on using MOBIKE to transition between encapsulation modes.",
      "ja": "TCPカプセル化が特定のIKE SAに使用されている場合、SAが削除されるか、IKEv2モビリティとマルチホーミング（MOBIKE）を使用してSAエンドポイントを変更するまで、そのIKE SAとその子SAのすべてのメッセージをTCP接続経由で送信する必要があります。 /またはカプセル化プロトコル。 MOBIKEを使用してカプセル化モードを切り替える詳細については、セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1. Recommended Fallback from UDP",
      "section_title": true,
      "ja": "5.1. UDPからの推奨フォールバック"
    },
    {
      "indent": 0,
      "text": " Since UDP is the preferred method of transport for IKE messages, implementations that use TCP encapsulation should have an algorithm for deciding when to use TCP after determining that UDP is unusable. If an Initiator implementation has no prior knowledge about the network it is on and the status of UDP on that network, it SHOULD always attempt to negotiate IKE over UDP first. IKEv2 defines how to use retransmission timers with IKE messages and, specifically, IKE_SA_INIT messages [RFC7296]. Generally, this means that the implementation will define a frequency of retransmission and the maximum number of retransmissions allowed before marking the IKE SA as failed. An implementation can attempt negotiation over TCP once it has hit the maximum retransmissions over UDP, or slightly before to reduce connection setup delays. It is recommended that the initial message over UDP be retransmitted at least once before falling back to TCP, unless the Initiator knows beforehand that the network is likely to block UDP.",
      "ja": "UDPはIKEメッセージのトランスポートの優先メソッドであるため、TCPカプセル化を使用する実装には、UDPが使用不可であると判断した後でTCPをいつ使用するかを決定するアルゴリズムが必要です。イニシエーター実装が、それがオンになっているネットワークとそのネットワーク上のUDPのステータスについて事前の知識がない場合、常に最初にUDPを介してIKEのネゴシエーションを試みる必要があります。 IKEv2は、IKEメッセージ、特にIKE_SA_INITメッセージ[RFC7296]で再送信タイマーを使用する方法を定義します。一般に、これは、実装がIKE SAを失敗としてマークする前に許可される再送信の頻度と再送信の最大数を定義することを意味します。実装は、UDPを介した最大再送信に達した後、または少し前にTCPを介したネゴシエーションを試行して、接続セットアップの遅延を減らすことができます。イニシエーターがネットワークがUDPをブロックする可能性が高いことを事前に認識していない限り、TCPにフォールバックする前に、UDPを介した初期メッセージを少なくとも1回再送信することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6. Connection Establishment and Teardown",
      "section_title": true,
      "ja": "6. 接続の確立とティアダウン"
    },
    {
      "indent": 3,
      "text": "When the IKE Initiator uses TCP encapsulation, it will initiate a TCP connection to the Responder using the configured TCP port. The first bytes sent on the stream MUST be the stream prefix value (Section 4). After this prefix, encapsulated IKE messages will negotiate the IKE SA and initial Child SA [RFC7296]. After this point, both encapsulated IKE (Figure 1) and ESP (Figure 2) messages will be sent over the TCP connection. The TCP Responder MUST wait for the entire stream prefix to be received on the stream before trying to parse out any IKE or ESP messages. The stream prefix is sent only once, and only by the TCP Originator.",
      "ja": "IKEイニシエーターがTCPカプセル化を使用する場合、構成されたTCPポートを使用してレスポンダへのTCP接続を開始します。ストリームで送信される最初のバイトは、ストリームプレフィックス値でなければなりません（セクション4）。このプレフィックスの後、カプセル化されたIKEメッセージは、IKE SAと最初の子SA [RFC7296]をネゴシエートします。この後、カプセル化されたIKE（図1）とESP（図2）の両方のメッセージがTCP接続を介して送信されます。 TCPレスポンダは、IKEまたはESPメッセージの解析を試みる前に、ストリームプレフィックス全体がストリームで受信されるのを待機する必要があります。ストリームプレフィックスは1回だけ送信され、TCP発信者によってのみ送信されます。"
    },
    {
      "indent": 3,
      "text": "In order to close an IKE session, either the Initiator or Responder SHOULD gracefully tear down IKE SAs with DELETE payloads. Once the SA has been deleted, the TCP Originator SHOULD close the TCP connection if it does not intend to use the connection for another IKE session to the TCP Responder. If the connection is left idle and the TCP Responder needs to clean up resources, the TCP Responder MAY close the TCP connection.",
      "ja": "IKEセッションを閉じるには、イニシエーターまたはレスポンダーのいずれかが、DELETEペイロードを使用してIKE SAを適切に破棄する必要があります（SHOULD）。 SAが削除されると、TCP発信者は、TCPレスポンダへの別のIKEセッションに接続を使用する予定がない場合、TCP接続を閉じる必要があります（SHOULD）。接続がアイドル状態のままで、TCPレスポンダがリソースをクリーンアップする必要がある場合、TCPレスポンダはTCP接続を閉じてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "An unexpected FIN or a TCP Reset on the TCP connection may indicate a loss of connectivity, an attack, or some other error. If a DELETE payload has not been sent, both sides SHOULD maintain the state for their SAs for the standard lifetime or timeout period. The TCP Originator is responsible for re-establishing the TCP connection if it is torn down for any unexpected reason. Since new TCP connections may use different ports due to NAT mappings or local port allocations changing, the TCP Responder MUST allow packets for existing SAs to be received from new source ports.",
      "ja": "TCP接続での予期しないFINまたはTCPリセットは、接続の喪失、攻撃、またはその他のエラーを示している可能性があります。 DELETEペイロードが送信されていない場合、両側は、標準のライフタイムまたはタイムアウト期間の間、SAの状態を維持する必要があります（SHOULD）。 TCPオリジネーターは、予期しない理由で切断された場合に、TCP接続を再確立する責任があります。 NATマッピングまたはローカルポート割り当ての変更により、新しいTCP接続は異なるポートを使用する可能性があるため、TCPレスポンダは、既存のSAのパケットを新しいソースポートから受信できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "A peer MUST discard a partially received message due to a broken connection.",
      "ja": "接続が切断されたため、ピアは部分的に受信したメッセージを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Whenever the TCP Originator opens a new TCP connection to be used for an existing IKE SA, it MUST send the stream prefix first, before any IKE or ESP messages. This follows the same behavior as the initial TCP connection.",
      "ja": "TCP Originatorが既存のIKE SAに使用される新しいTCP接続を開くときは常に、IKEまたはESPメッセージの前に、まずストリームプレフィックスを送信する必要があります。これは、最初のTCP接続と同じ動作に従います。"
    },
    {
      "indent": 3,
      "text": "If a TCP connection is being used to resume a previous IKE session, the TCP Responder can recognize the session using either the IKE SPI from an encapsulated IKE message or the ESP SPI from an encapsulated ESP message. If the session had been fully established previously, it is suggested that the TCP Originator send an UPDATE_SA_ADDRESSES message if MOBIKE is supported, or an informational message (a keep-alive) otherwise.",
      "ja": "TCP接続を使用して以前のIKEセッションを再開している場合、TCPレスポンダは、カプセル化されたIKEメッセージのIKE SPIまたはカプセル化されたESPメッセージのESP SPIを使用してセッションを認識できます。以前にセッションが完全に確立されている場合、MOBIKEがサポートされている場合はTCP OriginatorがUPDATE_SA_ADDRESSESメッセージを送信するか、そうでない場合は情報メッセージ（キープアライブ）を送信することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The TCP Responder MUST NOT accept any messages for the existing IKE session on a new incoming connection, unless that connection begins with the stream prefix. If either the TCP Originator or TCP Responder detects corruption on a connection that was started with a valid stream prefix, it SHOULD close the TCP connection. The connection can be determined to be corrupted if there are too many subsequent messages that cannot be parsed as valid IKE messages or ESP messages with known SPIs, or if the authentication check for an ESP message with a known SPI fails. Implementations SHOULD NOT tear down a connection if only a single ESP message has an unknown SPI, since the SPI databases may be momentarily out of sync. If there is instead a syntax issue within an IKE message, an implementation MUST send the INVALID_SYNTAX notify payload and tear down the IKE SA as usual, rather than tearing down the TCP connection directly.",
      "ja": "TCPレスポンダは、その接続がストリームプレフィックスで始まる場合を除き、新しい着信接続で既存のIKEセッションのメッセージを受け入れてはなりません（MUST NOT）。 TCP OriginatorまたはTCP Responderのいずれかが、有効なストリームプレフィックスで開始された接続の破損を検出した場合、TCP接続を閉じる必要があります（SHOULD）。有効なIKEメッセージまたは既知のSPIを持つESPメッセージとして解析できない後続のメッセージが多すぎる場合、または既知のSPIを持つESPメッセージの認証チェックが失敗した場合、接続が破損していると判断できます。 SPIデータベースが一時的に同期していない可能性があるため、単一のESPメッセージのみに不明なSPIがある場合、実装は接続を切断しないでください。代わりにIKEメッセージ内に構文の問題がある場合、実装は、TCP接続を直接切断するのではなく、通常どおりにINVALID_SYNTAX通知ペイロードを送信してIKE SAを切断する必要があります。"
    },
    {
      "indent": 3,
      "text": "A TCP Originator SHOULD only open one TCP connection per IKE SA, over which it sends all of the corresponding IKE and ESP messages. This helps ensure that any firewall or NAT mappings allocated for the TCP connection apply to all of the traffic associated with the IKE SA equally.",
      "ja": "TCPオリジネーターは、IKE SAごとに1つのTCP接続のみを開く必要があり（SHOULD）、対応するすべてのIKEおよびESPメッセージを送信します。これにより、TCP接続に割り当てられたファイアウォールまたはNATマッピングが、IKE SAに関連付けられたすべてのトラフィックに等しく適用されるようになります。"
    },
    {
      "indent": 3,
      "text": "Similarly, a TCP Responder SHOULD at any given time send packets for an IKE SA and its Child SAs over only one TCP connection. It SHOULD choose the TCP connection on which it last received a valid and decryptable IKE or ESP message. In order to be considered valid for choosing a TCP connection, an IKE message must be successfully decrypted and authenticated, not be a retransmission of a previously received message, and be within the expected window for IKE message IDs. Similarly, an ESP message must pass authentication checks and be decrypted, and must not be a replay of a previous message.",
      "ja": "同様に、TCPレスポンダは、常に1つのTCP接続を介してIKE SAとその子SAのパケットを送信する必要があります（SHOULD）。それはそれが有効で解読可能なIKEまたはESPメッセージを最後に受信したTCP接続を選択するべきです（SHOULD）。 TCP接続の選択に有効と見なされるには、IKEメッセージが正常に復号化および認証され、以前に受信したメッセージの再送信ではなく、IKEメッセージIDの予想されるウィンドウ内にある必要があります。同様に、ESPメッセージは認証チェックを通過して復号化される必要があり、前のメッセージの再生であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Since a connection may be broken and a new connection re-established by the TCP Originator without the TCP Responder being aware, a TCP Responder SHOULD accept receiving IKE and ESP messages on both old and new connections until the old connection is closed by the TCP Originator. A TCP Responder MAY close a TCP connection that it perceives as idle and extraneous (one previously used for IKE and ESP messages that has been replaced by a new connection).",
      "ja": "TCP Responderが認識せずに接続が切断され、新しい接続がTCP Originatorによって再確立される可能性があるため、TCP Responderは、古い接続がTCP Originatorによって閉じられるまで、古い接続と新しい接続の両方でIKEおよびESPメッセージの受信を受け入れる必要があります（SHOULD）。 。 TCPレスポンダは、それがアイドルで無関係であると認識しているTCP接続を閉じる可能性があります（以前は、新しい接続で置き換えられたIKEおよびESPメッセージに使用されていました）。"
    },
    {
      "indent": 3,
      "text": "Multiple IKE SAs MUST NOT share a single TCP connection, unless one is a rekey of an existing IKE SA, in which case there will temporarily be two IKE SAs on the same TCP connection.",
      "ja": "既存のIKE SAのキー再生成でない限り、複数のIKE SAが単一のTCP接続を共有してはなりません。その場合、同じTCP接続に一時的に2つのIKE SAが存在します。"
    },
    {
      "indent": 0,
      "text": "7. Interaction with NAT Detection Payloads",
      "section_title": true,
      "ja": "7. NAT検出ペイロードとの相互作用"
    },
    {
      "indent": 3,
      "text": "When negotiating over UDP port 500, IKE_SA_INIT packets include NAT_DETECTION_SOURCE_IP and NAT_DETECTION_DESTINATION_IP payloads to determine if UDP encapsulation of IPsec packets should be used. These payloads contain SHA-1 digests of the SPIs, IP addresses, and ports as defined in [RFC7296]. IKE_SA_INIT packets sent on a TCP connection SHOULD include these payloads with the same content as when sending over UDP and SHOULD use the applicable TCP ports when creating and checking the SHA-1 digests.",
      "ja": "UDPポート500を介してネゴシエートする場合、IKE_SA_INITパケットにはNAT_DETECTION_SOURCE_IPおよびNAT_DETECTION_DESTINATION_IPペイロードが含まれており、IPsecパケットのUDPカプセル化を使用する必要があるかどうかを判断します。これらのペイロードには、[RFC7296]で定義されているSPI、IPアドレス、およびポートのSHA-1ダイジェストが含まれています。 TCP接続で送信されるIKE_SA_INITパケットには、UDP経由で送信する場合と同じ内容のこれらのペイロードが含まれている必要があり（SHOULD）、SHA-1ダイジェストを作成および確認するときに適切なTCPポートを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If a NAT is detected due to the SHA-1 digests not matching the expected values, no change should be made for encapsulation of subsequent IKE or ESP packets, since TCP encapsulation inherently supports NAT traversal. Implementations MAY use the information that a NAT is present to influence keep-alive timer values.",
      "ja": "SHA-1ダイジェストが期待値と一致しないためにNATが検出された場合、TCPカプセル化は本質的にNATトラバーサルをサポートしているため、後続のIKEまたはESPパケットのカプセル化を変更する必要はありません。実装は、NATが存在するという情報を使用して、キープアライブタイマー値に影響を与えることができます。"
    },
    {
      "indent": 3,
      "text": "If a NAT is detected, implementations need to handle transport mode TCP and UDP packet checksum fixup as defined for UDP encapsulation in [RFC3948].",
      "ja": "NATが検出された場合、[RFC3948]でUDPカプセル化用に定義されているように、実装はトランスポートモードのTCPおよびUDPパケットチェックサム修正を処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Using MOBIKE with TCP Encapsulation",
      "section_title": true,
      "ja": "8. TCPカプセル化でのMOBIKEの使用"
    },
    {
      "indent": 3,
      "text": "When an IKE session that has negotiated MOBIKE [RFC4555] is transitioning between networks, the Initiator of the transition may switch between using TCP encapsulation, UDP encapsulation, or no encapsulation. Implementations that implement both MOBIKE and TCP encapsulation MUST support dynamically enabling and disabling TCP encapsulation as interfaces change.",
      "ja": "MOBIKE [RFC4555]をネゴシエートしたIKEセッションがネットワーク間で移行している場合、移行のイニシエーターは、TCPカプセル化、UDPカプセル化、または非カプセル化を使用して切り替えます。 MOBIKEとTCPの両方のカプセル化を実装する実装は、インターフェイスの変更に応じて、TCPカプセル化を動的に有効および無効にすることをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a MOBIKE-enabled Initiator changes networks, the UPDATE_SA_ADDRESSES notification SHOULD be sent out first over UDP before attempting over TCP. If there is a response to the UPDATE_SA_ADDRESSES notification sent over UDP, then the ESP packets should be sent directly over IP or over UDP port 4500 (depending on if a NAT was detected), regardless of if a connection on a previous network was using TCP encapsulation. Similarly, if the Responder only responds to the UPDATE_SA_ADDRESSES notification over TCP, then the ESP packets should be sent over the TCP connection, regardless of if a connection on a previous network did not use TCP encapsulation.",
      "ja": "MOBIKE対応のイニシエーターがネットワークを変更するとき、UPDATE_SA_ADDRESSES通知は、TCP経由で試行する前に、まずUDP経由で送信する必要があります（SHOULD）。 UDP経由で送信されたUPDATE_SA_ADDRESSES通知への応答がある場合、前のネットワーク上の接続がTCPを使用していたかどうかに関係なく、ESPパケットはIPまたはUDPポート4500（NATが検出されたかどうかに応じて）経由で直接送信されます。カプセル化。同様に、ResponderがTCP経由でUPDATE_SA_ADDRESSES通知にのみ応答する場合、前のネットワーク上の接続がTCPカプセル化を使用していないかどうかに関係なく、ESPパケットはTCP接続経由で送信されます。"
    },
    {
      "indent": 0,
      "text": "9. Using IKE Message Fragmentation with TCP Encapsulation",
      "section_title": true,
      "ja": "9. TCPカプセル化でのIKEメッセージフラグメンテーションの使用"
    },
    {
      "indent": 3,
      "text": "IKE message fragmentation [RFC7383] is not required when using TCP encapsulation, since a TCP stream already handles the fragmentation of its contents across packets. Since fragmentation is redundant in this case, implementations might choose to not negotiate IKE fragmentation. Even if fragmentation is negotiated, an implementation SHOULD NOT send fragments when going over a TCP connection, although it MUST support receiving fragments.",
      "ja": "TCPストリームはすでにパケット全体のコンテンツの断片化を処理しているため、TCPカプセル化を使用する場合、IKEメッセージの断片化[RFC7383]は不要です。この場合、フラグメンテーションは冗長であるため、実装はIKEフラグメンテーションをネゴシエートしないことを選択する場合があります。断片化がネゴシエートされた場合でも、TCP接続を経由するときに、実装はフラグメントを送信してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "If an implementation supports both MOBIKE and IKE fragmentation, it SHOULD negotiate IKE fragmentation over a TCP-encapsulated session in case the session switches to UDP encapsulation on another network.",
      "ja": "実装がMOBIKEとIKEの両方の断片化をサポートする場合、セッションが別のネットワークでUDPカプセル化に切り替わる場合に備えて、TCPカプセル化セッションを介してIKE断片化をネゴシエートする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "10. Considerations for Keep-Alives and Dead Peer Detection",
      "section_title": true,
      "ja": "10. キープアライブとデッドピア検出に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Encapsulating IKE and IPsec inside of a TCP connection can impact the strategy that implementations use to detect peer liveness and to maintain middlebox port mappings. Peer liveness should be checked using IKE informational packets [RFC7296].",
      "ja": "TCP接続内でIKEおよびIPsecをカプセル化すると、実装がピアの活性を検出し、ミドルボックスポートマッピングを維持するために使用する戦略に影響を与える可能性があります。ピアの活性は、IKE情報パケット[RFC7296]を使用してチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "In general, TCP port mappings are maintained by NATs longer than UDP port mappings, so IPsec ESP NAT keep-alives [RFC3948] SHOULD NOT be sent when using TCP encapsulation. Any implementation using TCP encapsulation MUST silently drop incoming NAT keep-alive packets and not treat them as errors. NAT keep-alive packets over a TCP-encapsulated IPsec connection will be sent as an ESP message with a one-octet-long payload with the value 0xFF.",
      "ja": "一般に、TCPポートマッピングはUDPポートマッピングよりも長いNATによって維持されるため、TCPカプセル化を使用する場合は、IPsec ESP NATキープアライブ[RFC3948]を送信しないでください。 TCPカプセル化を使用する実装はすべて、着信NATキープアライブパケットを警告なしにドロップし、それらをエラーとして扱わないようにする必要があります。 TCPカプセル化IPsec接続上のNATキープアライブパケットは、値が0xFFの1オクテット長のペイロードを持つESPメッセージとして送信されます。"
    },
    {
      "indent": 3,
      "text": "Note that, depending on the configuration of TCP and TLS on the connection, TCP keep-alives [RFC1122] and TLS keep-alives [RFC6520] may be used. These MUST NOT be used as indications of IKE peer liveness.",
      "ja": "接続のTCPとTLSの構成によっては、TCPキープアライブ[RFC1122]とTLSキープアライブ[RFC6520]が使用される場合があることに注意してください。これらは、IKEピアの活性の指標として使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "11. Middlebox Considerations",
      "section_title": true,
      "ja": "11. ミドルボックスの考慮事項"
    },
    {
      "indent": 3,
      "text": "Many security networking devices, such as firewalls or intrusion prevention systems, network optimization/acceleration devices, and NAT devices, keep the state of sessions that traverse through them.",
      "ja": "ファイアウォールや侵入防止システム、ネットワーク最適化/高速化デバイス、NATデバイスなどの多くのセキュリティネットワーキングデバイスは、それらを通過するセッションの状態を保持します。"
    },
    {
      "indent": 3,
      "text": "These devices commonly track the transport-layer and/or application-layer data to drop traffic that is anomalous or malicious in nature. While many of these devices will be more likely to pass TCP-encapsulated traffic as opposed to UDP-encapsulated traffic, some may still block or interfere with TCP-encapsulated IKE and IPsec traffic.",
      "ja": "これらのデバイスは通常、トランスポート層またはアプリケーション層のデータを追跡して、異常または悪意のあるトラフィックをドロップします。これらのデバイスの多くは、UDPカプセル化トラフィックとは対照的に、TCPカプセル化トラフィックを渡す可能性が高くなりますが、TCPカプセル化IKEおよびIPsecトラフィックをブロックまたは妨害するものもあります。"
    },
    {
      "indent": 3,
      "text": "A network device that monitors the transport layer will track the state of TCP sessions, such as TCP sequence numbers. TCP encapsulation of IKE should therefore use standard TCP behaviors to avoid being dropped by middleboxes.",
      "ja": "トランスポート層を監視するネットワークデバイスは、TCPシーケンス番号などのTCPセッションの状態を追跡します。したがって、IKEのTCPカプセル化では、標準のTCP動作を使用して、ミドルボックスによるドロップを回避する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Performance Considerations",
      "section_title": true,
      "ja": "12. パフォーマンスに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Several aspects of TCP encapsulation for IKE and IPsec packets may negatively impact the performance of connections within a tunnel-mode IPsec SA. Implementations should be aware of these performance impacts and take these into consideration when determining when to use TCP encapsulation. Implementations SHOULD favor using direct ESP or UDP encapsulation over TCP encapsulation whenever possible.",
      "ja": "IKEおよびIPsecパケットのTCPカプセル化のいくつかの側面は、トンネルモードのIPsec SA内の接続のパフォーマンスに悪影響を及ぼす可能性があります。実装では、これらのパフォーマンスへの影響を認識し、TCPカプセル化をいつ使用するかを決定する際にこれらを考慮する必要があります。実装では、可能な場合は常に、TCPカプセル化よりも直接ESPまたはUDPカプセル化を使用することを推奨します。"
    },
    {
      "indent": 0,
      "text": "12.1. TCP-in-TCP",
      "section_title": true,
      "ja": "12.1. TCP-in-TCP"
    },
    {
      "indent": 3,
      "text": "If the outer connection between IKE peers is over TCP, inner TCP connections may suffer negative effects from using TCP within TCP. Running TCP within TCP is discouraged, since the TCP algorithms generally assume that they are running over an unreliable datagram layer.",
      "ja": "IKEピア間の外部接続がTCPを介している場合、内部TCP接続はTCP内でTCPを使用することによる悪影響を受ける可能性があります。 TCPアルゴリズムは通常、信頼性の低いデータグラム層で実行されていると想定しているため、TCP内でTCPを実行することはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "If the outer (tunnel) TCP connection experiences packet loss, this loss will be hidden from any inner TCP connections, since the outer connection will retransmit to account for the losses. Since the outer TCP connection will deliver the inner messages in order, any messages after a lost packet may have to wait until the loss is recovered. This means that loss on the outer connection will be interpreted only as delay by inner connections. The burstiness of inner traffic can increase, since a large number of inner packets may be delivered across the tunnel at once. The inner TCP connection may interpret a long period of delay as a transmission problem, triggering a retransmission timeout, which will cause spurious retransmissions. The sending rate of the inner connection may be unnecessarily reduced if the retransmissions are not detected as spurious in time.",
      "ja": "外部（トンネル）TCP接続でパケット損失が発生した場合、外部接続が損失を考慮して再送信するため、この損失は内部TCP接続から隠されます。外部TCP接続は内部メッセージを順番に配信するため、パケットが失われた後のメッセージは、損失が回復するまで待機する必要があります。つまり、外部接続での損失は、内部接続による遅延としてのみ解釈されます。大量の内部パケットがトンネルを介して一度に配信される可能性があるため、内部トラフィックのバースト性が増加する可能性があります。内部TCP接続は、長い遅延を送信の問題として解釈し、再送信タイムアウトを引き起こし、偽の再送信を引き起こす可能性があります。内部接続の送信速度は、再送信が誤って時間的に検出されない場合、不必要に低下する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The inner TCP connection's round-trip-time estimation will be affected by the burstiness of the outer TCP connection if there are long delays when packets are retransmitted by the outer TCP connection. This will make the congestion control loop of the inner TCP traffic less reactive, potentially permanently leading to a lower sending rate than the outer TCP would allow for.",
      "ja": "パケットが外部TCP接続によって再送信されるときに長い遅延がある場合、内部TCP接続の往復時間の見積もりは、外部TCP接続のバースト性の影響を受けます。これにより、内部TCPトラフィックの輻輳制御ループの反応が鈍くなり、外部TCPが許容するよりも永続的に送信レートが低下する可能性があります。"
    },
    {
      "indent": 3,
      "text": "TCP-in-TCP can also lead to increased buffering, or bufferbloat. This can occur when the window size of the outer TCP connection is reduced and becomes smaller than the window sizes of the inner TCP connections. This can lead to packets backing up in the outer TCP connection's send buffers. In order to limit this effect, the outer TCP connection should have limits on its send buffer size and on the rate at which it reduces its window size.",
      "ja": "TCP-in-TCPは、バッファリングまたはbufferbloatの増加にもつながる可能性があります。これは、外部TCP接続のウィンドウサイズが縮小され、内部TCP接続のウィンドウサイズよりも小さくなると発生する可能性があります。これにより、外部TCP接続の送信バッファでパケットがバックアップされる可能性があります。この影響を制限するには、外部TCP接続の送信バッファーサイズと、ウィンドウサイズを縮小するレートに制限を設ける必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that any negative effects will be shared between all flows going through the outer TCP connection. This is of particular concern for any latency-sensitive or real-time applications using the tunnel. If such traffic is using a TCP-encapsulated IPsec connection, it is recommended that the number of inner connections sharing the tunnel be limited as much as possible.",
      "ja": "負の影響はすべて、外部TCP接続を通過するすべてのフロー間で共有されることに注意してください。これは、トンネルを使用するレイテンシの影響を受けやすいアプリケーションやリアルタイムアプリケーションで特に懸念されます。そのようなトラフィックがTCPカプセル化IPsec接続を使用している場合は、トンネルを共有する内部接続の数をできるだけ制限することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "12.2. Added Reliability for Unreliable Protocols",
      "section_title": true,
      "ja": "12.2. 信頼性の低いプロトコルの信頼性を向上"
    },
    {
      "indent": 3,
      "text": "Since ESP is an unreliable protocol, transmitting ESP packets over a TCP connection will change the fundamental behavior of the packets. Some application-level protocols that prefer packet loss to delay (such as Voice over IP or other real-time protocols) may be negatively impacted if their packets are retransmitted by the TCP connection due to packet loss.",
      "ja": "ESPは信頼性の低いプロトコルであるため、TCP接続を介してESPパケットを送信すると、パケットの基本的な動作が変わります。遅延よりもパケット損失を優先する一部のアプリケーションレベルのプロトコル（Voice over IPまたは他のリアルタイムプロトコルなど）は、パケット損失のためにTCP接続によってパケットが再送信されると、悪影響を受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "12.3. Quality-of-Service Markings",
      "section_title": true,
      "ja": "12.3. サービス品質のマーキング"
    },
    {
      "indent": 3,
      "text": "Quality-of-Service (QoS) markings, such as the Differentiated Services Code Point (DSCP) and Traffic Class, should be used with care on TCP connections used for encapsulation. Individual packets SHOULD NOT use different markings than the rest of the connection, since packets with different priorities may be routed differently and cause unnecessary delays in the connection.",
      "ja": "カプセル化に使用されるTCP接続では、Differentiated Services Code Point（DSCP）やトラフィッククラスなどのサービス品質（QoS）マーキングを注意して使用する必要があります。個々のパケットは、他の接続とは異なるマーキングを使用するべきではありません。異なる優先度のパケットは異なる方法でルーティングされ、接続に不必要な遅延を引き起こす可能性があるためです。"
    },
    {
      "indent": 0,
      "text": "12.4. Maximum Segment Size",
      "section_title": true,
      "ja": "12.4. 最大セグメントサイズ"
    },
    {
      "indent": 3,
      "text": "A TCP connection used for IKE encapsulation SHOULD negotiate its MSS in order to avoid unnecessary fragmentation of packets.",
      "ja": "IKEカプセル化に使用されるTCP接続は、不必要なパケットの断片化を回避するために、MSSをネゴシエートする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "12.5. Tunneling ECN in TCP",
      "section_title": true,
      "ja": "12.5. TCPでのECNのトンネリング"
    },
    {
      "indent": 3,
      "text": "Since there is not a one-to-one relationship between outer IP packets and inner ESP/IP messages when using TCP encapsulation, the markings for Explicit Congestion Notification (ECN) [RFC3168] cannot be simply mapped. However, any ECN Congestion Experienced (CE) marking on inner headers should be preserved through the tunnel.",
      "ja": "TCPカプセル化を使用する場合、外部IPパケットと内部ESP / IPメッセージの間に1対1の関係がないため、明示的輻輳通知（ECN）[RFC3168]のマーキングを単純にマッピングすることはできません。ただし、内部ヘッダーのECN Congestion Experienced（CE）マーキングは、トンネルを通じて保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD follow the ECN compatibility mode for tunnel ingress as described in [RFC6040]. In compatibility mode, the outer tunnel TCP connection marks its packet headers as not ECN-capable. If upon egress, the arriving outer header is marked with CE, the implementation will drop the inner packet, since there is not a distinct inner packet header onto which to translate the ECN markings.",
      "ja": "[RFC6040]で説明されているように、実装はトンネル進入のECN互換モードに従う必要があります（SHOULD）。互換モードでは、外部トンネルTCP接続は、そのパケットヘッダーをECN対応ではないものとしてマークします。出力時に、到着する外部ヘッダーがCEでマークされている場合、ECNマーキングを変換する明確な内部パケットヘッダーがないため、実装は内部パケットをドロップします。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IKE Responders that support TCP encapsulation may become vulnerable to new Denial-of-Service (DoS) attacks that are specific to TCP, such as SYN-flooding attacks. TCP Responders should be aware of this additional attack surface.",
      "ja": "TCPカプセル化をサポートするIKEレスポンダは、SYNフラッディング攻撃など、TCP固有の新しいサービス拒否（DoS）攻撃に対して脆弱になる可能性があります。 TCPレスポンダは、この追加の攻撃面に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "TCP Responders should be careful to ensure that (1) the stream prefix \"IKETCP\" uniquely identifies incoming streams as streams that use the TCP encapsulation protocol and (2) they are not running any other protocols on the same listening port (to avoid potential conflicts).",
      "ja": "TCPレスポンダは、（1）ストリームプレフィックス \"IKETCP\"が着信ストリームをTCPカプセル化プロトコルを使用するストリームとして一意に識別し、（2）同じリスニングポートで他のプロトコルを実行していないことを確認するように注意する必要があります（潜在的な競合を回避するため） ）。"
    },
    {
      "indent": 3,
      "text": "Attackers may be able to disrupt the TCP connection by sending spurious TCP Reset packets. Therefore, implementations SHOULD make sure that IKE session state persists even if the underlying TCP connection is torn down.",
      "ja": "攻撃者は、偽のTCPリセットパケットを送信することにより、TCP接続を妨害する可能性があります。したがって、実装では、基になるTCP接続が切断された場合でも、IKEセッション状態が持続するようにする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If MOBIKE is being used, all of the security considerations outlined for MOBIKE apply [RFC4555].",
      "ja": "MOBIKEが使用されている場合、MOBIKEについて概説されているすべてのセキュリティの考慮事項が適用されます[RFC4555]。"
    },
    {
      "indent": 3,
      "text": "Similarly to MOBIKE, TCP encapsulation requires a TCP Responder to handle changes to source address and port due to network or connection disruption. The successful delivery of valid IKE or ESP messages over a new TCP connection is used by the TCP Responder to determine where to send subsequent responses. If an attacker is able to send packets on a new TCP connection that pass the validation checks of the TCP Responder, it can influence which path future packets will take. For this reason, the validation of messages on the TCP Responder must include decryption, authentication, and replay checks.",
      "ja": "MOBIKEと同様に、TCPカプセル化では、ネットワークまたは接続の中断による送信元アドレスとポートの変更を処理するためにTCPレスポンダが必要です。新しいTCP接続を介した有効なIKEまたはESPメッセージの配信の成功は、後続の応答の送信先を決定するためにTCPレスポンダによって使用されます。攻撃者がTCPレスポンダの検証チェックに合格した新しいTCP接続でパケットを送信できる場合、将来のパケットが通過する経路に影響を与える可能性があります。このため、TCPレスポンダでのメッセージの検証には、復号化、認証、および再生チェックを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Since TCP provides reliable, in-order delivery of ESP messages, the ESP anti-replay window size SHOULD be set to 1. See [RFC4303] for a complete description of the ESP anti-replay window. This increases the protection of implementations against replay attacks.",
      "ja": "TCPはESPメッセージの信頼できる順序どおりの配信を提供するため、ESPアンチリプレイウィンドウサイズは1に設定する必要があります（SHOULD）。ESPアンチリプレイウィンドウの詳細については、[RFC4303]を参照してください。これにより、リプレイ攻撃に対する実装の保護が強化されます。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "TCP port 4500 is already allocated to IPsec for NAT traversal. This port SHOULD be used for TCP-encapsulated IKE and ESP as described in this document.",
      "ja": "TCPポート4500は、NATトラバーサル用のIPsecにすでに割り当てられています。このドキュメントで説明されているように、このポートは、TCPカプセル化IKEおよびESPに使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "This document updates the reference for TCP port 4500:",
      "ja": "このドキュメントでは、TCPポート4500のリファレンスを更新しています。"
    },
    {
      "indent": 9,
      "text": "Keyword       Decimal    Description           Reference\n-----------   --------   -------------------   ---------\nipsec-nat-t   4500/tcp   IPsec NAT-Traversal   RFC 8229",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3948] Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, \"UDP Encapsulation of IPsec ESP Packets\", RFC 3948, DOI 10.17487/RFC3948, January 2005, <http://www.rfc-editor.org/info/rfc3948>.",
      "ja": "[RFC3948] Huttunen、A.、Swander、B.、Volpe、V.、DiBurro、L。、およびM. Stenberg、「IPsec ESPパケットのUDPカプセル化」、RFC 3948、DOI 10.17487 / RFC3948、2005年1月、<http ：//www.rfc-editor.org/info/rfc3948>。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, DOI 10.17487/RFC4303, December 2005, <http://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[RFC4303]ケント、S。、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、<http://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[RFC6040] Briscoe, B., \"Tunnelling of Explicit Congestion Notification\", RFC 6040, DOI 10.17487/RFC6040, November 2010, <http://www.rfc-editor.org/info/rfc6040>.",
      "ja": "[RFC6040] Briscoe、B。、「Tunnelling of Explicit Congestion Notification」、RFC 6040、DOI 10.17487 / RFC6040、2010年11月、<http://www.rfc-editor.org/info/rfc6040>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296] Kaufman、C.、Hoffman、P.、Nir、Y.、Eronen、P。、およびT. Kivinen、「Internet Key Exchange Protocol Version 2（IKEv2）」、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、<http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「あいまいな大文字と小文字のRFC 2119キーワード」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[IKE-over-TCP] Nir, Y., \"A TCP transport for the Internet Key Exchange\", Work in Progress, draft-ietf-ipsecme-ike-tcp-01, December 2012.",
      "ja": "[IKE-over-TCP] Nir、Y。、「インターネットキー交換用のTCPトランスポート」、作業中、draft-ietf-ipsecme-ike-tcp-01、2012年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <http://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122] Braden、R。、編、「インターネットホストの要件-通信層」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<http://www.rfc-editor.org/info/ rfc1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC2817] Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\", RFC 2817, DOI 10.17487/RFC2817, May 2000, <http://www.rfc-editor.org/info/rfc2817>.",
      "ja": "[RFC2817] Khare、R。およびS. Lawrence、「HTTP / 1.1内のTLSへのアップグレード」、RFC 2817、DOI 10.17487 / RFC2817、2000年5月、<http://www.rfc-editor.org/info/rfc2817> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <http://www.rfc-editor.org/info/rfc3168>.",
      "ja": "[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<http：// www。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC4555] Eronen, P., \"IKEv2 Mobility and Multihoming Protocol (MOBIKE)\", RFC 4555, DOI 10.17487/RFC4555, June 2006, <http://www.rfc-editor.org/info/rfc4555>.",
      "ja": "[RFC4555] Eronen、P。、「IKEv2 Mobility and Multihoming Protocol（MOBIKE）」、RFC 4555、DOI 10.17487 / RFC4555、2006年6月、<http://www.rfc-editor.org/info/rfc4555>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, \"Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension\", RFC 6520, DOI 10.17487/RFC6520, February 2012, <http://www.rfc-editor.org/info/rfc6520>.",
      "ja": "[RFC6520] Seggelmann、R.、Tuexen、M。、およびM. Williams、「Transport Layer Security（TLS）and Datagram Transport Layer Security（DTLS）Heartbeat Extension」、RFC 6520、DOI 10.17487 / RFC6520、2012年2月、<http ：//www.rfc-editor.org/info/rfc6520>。"
    },
    {
      "indent": 3,
      "text": "[RFC7383] Smyslov, V., \"Internet Key Exchange Protocol Version 2 (IKEv2) Message Fragmentation\", RFC 7383, DOI 10.17487/RFC7383, November 2014, <http://www.rfc-editor.org/info/rfc7383>.",
      "ja": "[RFC7383] Smyslov、V。、「インターネットキーエクスチェンジプロトコルバージョン2（IKEv2）メッセージの断片化」、RFC 7383、DOI 10.17487 / RFC7383、2014年11月、<http://www.rfc-editor.org/info/rfc7383> 。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Using TCP Encapsulation with TLS",
      "section_title": true,
      "ja": "付録A.TLSでのTCPカプセル化の使用"
    },
    {
      "indent": 3,
      "text": "This section provides recommendations on how to use TLS in addition to TCP encapsulation.",
      "ja": "このセクションでは、TCPカプセル化に加えてTLSの使用方法に関する推奨事項を提供します。"
    },
    {
      "indent": 3,
      "text": "When using TCP encapsulation, implementations may choose to use TLS [RFC5246] on the TCP connection to be able to traverse middleboxes, which may otherwise block the traffic.",
      "ja": "TCPカプセル化を使用する場合、実装はミドルボックスを通過できるようにTCP接続でTLS [RFC5246]を使用することを選択できます。そうしないと、トラフィックがブロックされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a web proxy is applied to the ports used for the TCP connection and TLS is being used, the TCP Originator can send an HTTP CONNECT message to establish an SA through the proxy [RFC2817].",
      "ja": "TCP接続に使用されるポートにWebプロキシが適用され、TLSが使用されている場合、TCP発信者はHTTP CONNECTメッセージを送信して、プロキシを介してSAを確立できます[RFC2817]。"
    },
    {
      "indent": 3,
      "text": "The use of TLS should be configurable on the peers, and may be used as the default when using TCP encapsulation or may be used as a fallback when basic TCP encapsulation fails. The TCP Responder may expect to read encapsulated IKE and ESP packets directly from the TCP connection, or it may expect to read them from a stream of TLS data packets. The TCP Originator should be pre-configured to use TLS or not when communicating with a given port on the TCP Responder.",
      "ja": "TLSの使用はピアで設定可能である必要があり、TCPカプセル化を使用する場合はデフォルトとして使用でき、基本的なTCPカプセル化が失敗した場合のフォールバックとして使用できます。 TCPレスポンダは、カプセル化されたIKEおよびESPパケットをTCP接続から直接読み取ることを期待するか、TLSデータパケットのストリームからそれらを読み取ることを期待する場合があります。 TCP発信者は、TCPレスポンダの特定のポートと通信するときにTLSを使用するかどうかを事前に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When new TCP connections are re-established due to a broken connection, TLS must be renegotiated. TLS session resumption is recommended to improve efficiency in this case.",
      "ja": "接続が切断されたために新しいTCP接続が再確立された場合、TLSを再ネゴシエートする必要があります。この場合、効率を向上させるために、TLSセッションの再開をお勧めします。"
    },
    {
      "indent": 3,
      "text": "The security of the IKE session is entirely derived from the IKE negotiation and key establishment and not from the TLS session (which in this context is only used for encapsulation purposes); therefore, when TLS is used on the TCP connection, both the TCP Originator and the TCP Responder SHOULD allow the NULL cipher to be selected for performance reasons.",
      "ja": "IKEセッションのセキュリティは完全にIKEネゴシエーションとキーの確立から派生し、TLSセッションからは派生しません（このコンテキストではカプセル化の目的でのみ使用されます）。したがって、TCP接続でTLSが使用されている場合、TCP発信者とTCPレスポンダーの両方で、パフォーマンス上の理由からNULL暗号を選択できるようにする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Implementations should be aware that the use of TLS introduces another layer of overhead requiring more bytes to transmit a given IKE and IPsec packet. For this reason, direct ESP, UDP encapsulation, or TCP encapsulation without TLS should be preferred in situations in which TLS is not required in order to traverse middleboxes.",
      "ja": "実装では、TLSを使用すると、所定のIKEおよびIPsecパケットを送信するためにより多くのバイト数を必要とする別のオーバーヘッド層が導入されることに注意する必要があります。このため、ミドルボックスを通過するためにTLSが不要な状況では、TLSを使用しない直接ESP、UDPカプセル化、またはTCPカプセル化をお勧めします。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example Exchanges of TCP Encapsulation with TLS",
      "section_title": true,
      "ja": "付録B.TLSを使用したTCPカプセル化の交換例"
    },
    {
      "indent": 0,
      "text": "B.1. Establishing an IKE Session",
      "section_title": true,
      "ja": "B.1. IKEセッションの確立"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  --------------------  TCP Connection  -------------------\n    (IP_I:Port_I  -> IP_R:Port_R)\n    TcpSyn                    ---------->\n                              <----------          TcpSyn,Ack\n    TcpAck                    ---------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "2)  ---------------------  TLS Session  ---------------------\n    ClientHello               ---------->\n                                                  ServerHello\n                                                 Certificate*\n                                           ServerKeyExchange*\n                              <----------     ServerHelloDone\n    ClientKeyExchange\n    CertificateVerify*\n    [ChangeCipherSpec]\n    Finished                  ---------->\n                                           [ChangeCipherSpec]\n                              <----------            Finished",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "3)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->\n4)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker   ---------->\n    IKE_SA_INIT\n    HDR, SAi1, KEi, Ni,\n    [N(NAT_DETECTION_*_IP)]\n                              <------ Length + Non-ESP Marker\n                                                  IKE_SA_INIT\n                                          HDR, SAr1, KEr, Nr,\n                                      [N(NAT_DETECTION_*_IP)]\n    Length + Non-ESP Marker   ---------->\n    first IKE_AUTH\n    HDR, SK {IDi, [CERTREQ]\n    CP(CFG_REQUEST), IDr,\n    SAi2, TSi, TSr, ...}\n                              <------ Length + Non-ESP Marker\n                                               first IKE_AUTH\n                                  HDR, SK {IDr, [CERT], AUTH,\n                                         EAP, SAr2, TSi, TSr}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Length + Non-ESP Marker   ---------->\nIKE_AUTH + EAP\nrepeat 1..N times\n                          <------ Length + Non-ESP Marker\n                                           IKE_AUTH + EAP\nLength + Non-ESP Marker   ---------->\nfinal IKE_AUTH\nHDR, SK {AUTH}\n                          <------ Length + Non-ESP Marker\n                                           final IKE_AUTH\n                            HDR, SK {AUTH, CP(CFG_REPLY),\n                                       SA, TSi, TSr, ...}\n-------------- IKE and IPsec SAs Established ------------\nLength + ESP Frame        ---------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "1. The client establishes a TCP connection with the server on port 4500 or on an alternate pre-configured port that the server is listening on.",
      "ja": "1. クライアントは、ポート4500またはサーバーがリッスンしている代替の構成済みポートでサーバーとのTCP接続を確立します。"
    },
    {
      "indent": 3,
      "text": "2. If configured to use TLS, the client initiates a TLS handshake. During the TLS handshake, the server SHOULD NOT request the client's certificate, since authentication is handled as part of IKE negotiation.",
      "ja": "2. TLSを使用するように構成されている場合、クライアントはTLSハンドシェイクを開始します。 TLSハンドシェイクの間、認証はIKEネゴシエーションの一部として処理されるため、サーバーはクライアントの証明書を要求しないでください。"
    },
    {
      "indent": 3,
      "text": "3. The client sends the stream prefix for TCP-encapsulated IKE (Section 4) traffic to signal the beginning of IKE negotiation.",
      "ja": "3. クライアントは、TCPカプセル化IKE（セクション4）トラフィックのストリームプレフィックスを送信して、IKEネゴシエーションの開始を知らせます。"
    },
    {
      "indent": 3,
      "text": "4. The client and server establish an IKE connection. This example shows EAP-based authentication, although any authentication type may be used.",
      "ja": "4. クライアントとサーバーはIKE接続を確立します。この例はEAPベースの認証を示していますが、任意の認証タイプを使用できます。"
    },
    {
      "indent": 0,
      "text": "B.2. Deleting an IKE Session",
      "section_title": true,
      "ja": "B.2. IKEセッションの削除"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker   ---------->\n    INFORMATIONAL\n    HDR, SK {[N,] [D,]\n           [CP,] ...}\n                              <------ Length + Non-ESP Marker\n                                                INFORMATIONAL\n                                           HDR, SK {[N,] [D,]\n                                                   [CP], ...}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "2)  ---------------------  TLS Session  ---------------------\n    close_notify              ---------->\n                              <----------        close_notify\n3)  --------------------  TCP Connection  -------------------\n    TcpFin                    ---------->\n                              <----------                 Ack\n                              <----------              TcpFin\n    Ack                       ---------->\n    --------------------  IKE SA Deleted  -------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 3,
      "text": "1. The client and server exchange informational messages to notify IKE SA deletion.",
      "ja": "1. クライアントとサーバーは情報メッセージを交換して、IKE SAの削除を通知します。"
    },
    {
      "indent": 3,
      "text": "2. The client and server negotiate TLS session deletion using TLS CLOSE_NOTIFY.",
      "ja": "2. クライアントとサーバーは、TLS CLOSE_NOTIFYを使用してTLSセッションの削除をネゴシエートします。"
    },
    {
      "indent": 3,
      "text": "3. The TCP connection is torn down.",
      "ja": "3. TCP接続が切断されます。"
    },
    {
      "indent": 3,
      "text": "The deletion of the IKE SA should lead to the disposal of the underlying TLS and TCP state.",
      "ja": "IKE SAを削除すると、基になるTLSおよびTCP状態が破棄されます。"
    },
    {
      "indent": 0,
      "text": "B.3. Re-establishing an IKE Session",
      "section_title": true,
      "ja": "B.3. IKEセッションの再確立"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  --------------------  TCP Connection  -------------------\n    (IP_I:Port_I  -> IP_R:Port_R)\n    TcpSyn                    ---------->\n                              <----------          TcpSyn,Ack\n    TcpAck                    ---------->\n2)  ---------------------  TLS Session  ---------------------\n    ClientHello               ---------->\n                              <----------         ServerHello\n                                           [ChangeCipherSpec]\n                                                     Finished\n    [ChangeCipherSpec]        ---------->\n    Finished\n3)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->\n4)  <---------------------> IKE/ESP Flow <------------------>\n    Length + ESP Frame        ---------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 7",
      "ja": "図7"
    },
    {
      "indent": 3,
      "text": "1. If a previous TCP connection was broken (for example, due to a TCP Reset), the client is responsible for re-initiating the TCP connection. The TCP Originator's address and port (IP_I and Port_I) may be different from the previous connection's address and port.",
      "ja": "1. 以前のTCP接続が切断された場合（たとえば、TCPリセットが原因で）、クライアントはTCP接続を再開始する必要があります。 TCP発信元のアドレスとポート（IP_IおよびPort_I）は、以前の接続のアドレスとポートと異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "2. In the ClientHello TLS message, the client SHOULD send the session ID it received in the previous TLS handshake if available. It is up to the server to perform either an abbreviated handshake or a full handshake based on the session ID match.",
      "ja": "2. ClientHello TLSメッセージでは、クライアントは、可能であれば、前のTLSハンドシェイクで受信したセッションIDを送信する必要があります（SHOULD）。セッションIDの一致に基づいて省略されたハンドシェイクまたは完全なハンドシェイクを実行するかどうかは、サーバーに依存します。"
    },
    {
      "indent": 3,
      "text": "3. After TCP and TLS are complete, the client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).",
      "ja": "3. TCPとTLSが完了すると、クライアントはTCPカプセル化IKEトラフィックのストリームプレフィックスを送信します（セクション4）。"
    },
    {
      "indent": 3,
      "text": "4. The IKE and ESP packet flow can resume. If MOBIKE is being used, the Initiator SHOULD send an UPDATE_SA_ADDRESSES message.",
      "ja": "4. IKEおよびESPパケットフローを再開できます。 MOBIKEが使用されている場合、イニシエーターはUPDATE_SA_ADDRESSESメッセージを送信する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "B.4. Using MOBIKE between UDP and TCP Encapsulation",
      "section_title": true,
      "ja": "B.4. UDPとTCPカプセル化の間のMOBIKEの使用"
    },
    {
      "indent": 5,
      "text": "                Client                              Server\n              ----------                          ----------\n    (IP_I1:UDP500 -> IP_R:UDP500)\n1)  ----------------- IKE_SA_INIT Exchange -----------------\n    (IP_I1:UDP4500 -> IP_R:UDP4500)\n    Non-ESP Marker           ----------->\n    Initial IKE_AUTH\n    HDR, SK { IDi, CERT, AUTH,\n    CP(CFG_REQUEST),\n    SAi2, TSi, TSr,\n    N(MOBIKE_SUPPORTED) }\n                             <-----------      Non-ESP Marker\n                                             Initial IKE_AUTH\n                                   HDR, SK { IDr, CERT, AUTH,\n                                         EAP, SAr2, TSi, TSr,\n                                        N(MOBIKE_SUPPORTED) }\n    <------------------ IKE SA Establishment --------------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "2)  ------------ MOBIKE Attempt on New Network --------------\n    (IP_I2:UDP4500 -> IP_R:UDP4500)\n    Non-ESP Marker           ----------->\n    INFORMATIONAL\n    HDR, SK { N(UPDATE_SA_ADDRESSES),\n    N(NAT_DETECTION_SOURCE_IP),\n    N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "3)  --------------------  TCP Connection  -------------------\n    (IP_I2:Port_I -> IP_R:Port_R)\n    TcpSyn                   ----------->\n                             <-----------          TcpSyn,Ack\n    TcpAck                   ----------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "4)  ---------------------  TLS Session  ---------------------\n    ClientHello              ----------->\n                                                  ServerHello\n                                                 Certificate*\n                                           ServerKeyExchange*\n                             <-----------     ServerHelloDone\n    ClientKeyExchange\n    CertificateVerify*\n    [ChangeCipherSpec]\n    Finished                 ----------->\n                                           [ChangeCipherSpec]\n                             <-----------            Finished",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "5)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "6)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker  ----------->\n    INFORMATIONAL (Same as step 2)\n    HDR, SK { N(UPDATE_SA_ADDRESSES),\n    N(NAT_DETECTION_SOURCE_IP),\n    N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "                             <------- Length + Non-ESP Marker\n                        HDR, SK { N(NAT_DETECTION_SOURCE_IP),\n                            N(NAT_DETECTION_DESTINATION_IP) }\n7)  <----------------- IKE/ESP Data Flow ------------------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 8",
      "ja": "図8"
    },
    {
      "indent": 3,
      "text": "1. During the IKE_SA_INIT exchange, the client and server exchange MOBIKE_SUPPORTED notify payloads to indicate support for MOBIKE.",
      "ja": "1. IKE_SA_INIT交換中に、クライアントとサーバーはMOBIKE_SUPPORTED通知ペイロードを交換して、MOBIKEのサポートを示します。"
    },
    {
      "indent": 3,
      "text": "2. The client changes its point of attachment to the network and receives a new IP address. The client attempts to re-establish the IKE session using the UPDATE_SA_ADDRESSES notify payload, but the server does not respond because the network blocks UDP traffic.",
      "ja": "2. クライアントは、ネットワークへの接続ポイントを変更し、新しいIPアドレスを受け取ります。クライアントはUPDATE_SA_ADDRESSES通知ペイロードを使用してIKEセッションを再確立しようとしますが、ネットワークがUDPトラフィックをブロックしているため、サーバーは応答しません。"
    },
    {
      "indent": 3,
      "text": "3. The client brings up a TCP connection to the server in order to use TCP encapsulation.",
      "ja": "3. クライアントは、TCPカプセル化を使用するために、サーバーへのTCP接続を開始します。"
    },
    {
      "indent": 3,
      "text": "4. The client initiates a TLS handshake with the server.",
      "ja": "4. クライアントはサーバーとのTLSハンドシェイクを開始します。"
    },
    {
      "indent": 3,
      "text": "5. The client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).",
      "ja": "5. クライアントは、TCPカプセル化IKEトラフィックのストリームプレフィックスを送信します（セクション4）。"
    },
    {
      "indent": 3,
      "text": "6. The client sends the UPDATE_SA_ADDRESSES notify payload on the TCP-encapsulated connection. Note that this IKE message is the same as the one sent over UDP in step 2; it should have the same message ID and contents.",
      "ja": "6. クライアントは、TCPカプセル化接続でUPDATE_SA_ADDRESSES通知ペイロードを送信します。このIKEメッセージは、手順2でUDPを介して送信されたものと同じであることに注意してください。メッセージIDと内容は同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "7. The IKE and ESP packet flow can resume.",
      "ja": "7. IKEおよびESPパケットフローを再開できます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge the input and advice of Stuart Cheshire, Delziel Fernandes, Yoav Nir, Christoph Paasch, Yaron Sheffer, David Schinazi, Graham Bartlett, Byju Pularikkal, March Wu, Kingwel Xie, Valery Smyslov, Jun Hu, and Tero Kivinen. Special thanks to Eric Kinnear for his implementation work.",
      "ja": "著者は、スチュアートチェシャー、デルジエルフェルナンデス、ヨアフニル、クリストフパーシュ、ヤロンシェファー、デビッドシナジ、グラハムバートレット、ビジュプラリカル、マーチウー、キングウェルシェ、ヴァレリースミスロフ、ジュンヒュー、およびテロキビネンの入力とアドバイスを認めたい。 Eric Kinnear氏の実装作業に特に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tommy Pauly Apple Inc. 1 Infinite Loop Cupertino, California 95014 United States of America",
      "ja": "トミーポーリーアップル社1無限ループクパチーノ、カリフォルニア95014アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: tpauly@apple.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Samy Touati Ericsson 2755 Augustine Santa Clara, California 95054 United States of America",
      "ja": "Samy Touati Ericsson 2755オーガスティンサンタクララ、カリフォルニア95054アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: samy.touati@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ravi Mantha Cisco Systems SEZ, Embassy Tech Village Panathur, Bangalore 560 037 India",
      "ja": "Ravi Mantha Cisco Systems SEZ、Embassy Tech Village Panathur、Bangalore 560 037 India"
    },
    {
      "indent": 3,
      "text": "Email: ramantha@cisco.com",
      "raw": true,
      "ja": ""
    }
  ]
}