{
  "title": {
    "text": "RFC 8829 - JavaScript Session Establishment Protocol (JSEP)",
    "ja": "RFC 8829 - JavaScriptセッション確立プロトコル（JSEP）"
  },
  "number": 8829,
  "created_at": "2021-03-01 12:59:06.520366+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         J. Uberti\nRequest for Comments: 8829                                        Google\nCategory: Standards Track                                    C. Jennings\nISSN: 2070-1721                                                    Cisco\n                                                        E. Rescorla, Ed.\n                                                                 Mozilla\n                                                            January 2021",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "JavaScript Session Establishment Protocol (JSEP)",
      "ja": "JavaScriptセッション確立プロトコル（JSEP）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the mechanisms for allowing a JavaScript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API and discusses how this relates to existing signaling protocols.",
      "ja": "このドキュメントでは、JavaScriptアプリケーションがW3C RTCPeerConnection APIで指定されたインターフェイスを介してマルチメディアセッションのシグナリングプレーンを制御できるようにするメカニズムについて説明し、これが既存のシグナリングプロトコルとどのように関連するかについて説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です。これは、IETFコミュニティのコンセンサスを表しています。パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました。インターネット標準の詳細については、RFC7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8829.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8829で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2021 IETFTrustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  General Design of JSEP\n  1.2.  Other Approaches Considered\n  1.3.  Contradiction regarding bundle-only \"m=\" sections\n2.  Terminology\n3.  Semantics and Syntax\n  3.1.  Signaling Model\n  3.2.  Session Descriptions and State Machine\n  3.3.  Session Description Format\n  3.4.  Session Description Control\n    3.4.1.  RtpTransceivers\n    3.4.2.  RtpSenders\n    3.4.3.  RtpReceivers\n  3.5.  ICE\n    3.5.1.  ICE Gathering Overview\n    3.5.2.  ICE Candidate Trickling\n      3.5.2.1.  ICE Candidate Format\n    3.5.3.  ICE Candidate Policy\n    3.5.4.  ICE Candidate Pool\n    3.5.5.  ICE Versions\n  3.6.  Video Size Negotiation\n    3.6.1.  Creating an imageattr Attribute\n    3.6.2.  Interpreting imageattr Attributes\n  3.7.  Simulcast\n  3.8.  Interactions with Forking\n    3.8.1.  Sequential Forking\n    3.8.2.  Parallel Forking\n4.  Interface\n  4.1.  PeerConnection\n    4.1.1.  Constructor\n    4.1.2.  addTrack\n    4.1.3.  removeTrack\n    4.1.4.  addTransceiver\n    4.1.5.  onaddtrack Event\n    4.1.6.  createDataChannel\n    4.1.7.  ondatachannel Event\n    4.1.8.  createOffer\n    4.1.9.  createAnswer\n    4.1.10. SessionDescriptionType\n      4.1.10.1.  Use of Provisional Answers\n      4.1.10.2.  Rollback\n    4.1.11. setLocalDescription\n    4.1.12. setRemoteDescription\n    4.1.13. currentLocalDescription\n    4.1.14. pendingLocalDescription\n    4.1.15. currentRemoteDescription\n    4.1.16. pendingRemoteDescription\n    4.1.17. canTrickleIceCandidates\n    4.1.18. setConfiguration\n    4.1.19. addIceCandidate\n    4.1.20. onicecandidate Event\n  4.2.  RtpTransceiver\n    4.2.1.  stop\n    4.2.2.  stopped\n    4.2.3.  setDirection\n    4.2.4.  direction\n    4.2.5.  currentDirection\n    4.2.6.  setCodecPreferences\n5.  SDP Interaction Procedures\n  5.1.  Requirements Overview\n    5.1.1.  Usage Requirements\n    5.1.2.  Profile Names and Interoperability\n  5.2.  Constructing an Offer\n    5.2.1.  Initial Offers\n    5.2.2.  Subsequent Offers\n    5.2.3.  Options Handling\n      5.2.3.1.  IceRestart\n      5.2.3.2.  VoiceActivityDetection\n  5.3.  Generating an Answer\n    5.3.1.  Initial Answers\n    5.3.2.  Subsequent Answers\n    5.3.3.  Options Handling\n      5.3.3.1.  VoiceActivityDetection\n  5.4.  Modifying an Offer or Answer\n  5.5.  Processing a Local Description\n  5.6.  Processing a Remote Description\n  5.7.  Processing a Rollback\n  5.8.  Parsing a Session Description\n    5.8.1.  Session-Level Parsing\n    5.8.2.  Media Section Parsing\n    5.8.3.  Semantics Verification\n  5.9.  Applying a Local Description\n  5.10. Applying a Remote Description\n  5.11. Applying an Answer\n6.  Processing RTP/RTCP\n7.  Examples\n  7.1.  Simple Example\n  7.2.  Detailed Example\n  7.3.  Early Transport Warmup Example\n8.  Security Considerations\n9.  IANA Considerations\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  SDP ABNF Syntax\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes how the W3C Web Real-Time Communication (WebRTC) RTCPeerConnection interface [W3C.webrtc] is used to control the setup, management, and teardown of a multimedia session.",
      "ja": "このドキュメントでは、W3C Webリアルタイム通信（WebRTC）RTCPeerConnectionインターフェイス[W3C.webrtc]を使用して、マルチメディアセッションのセットアップ、管理、およびティアダウンを制御する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. General Design of JSEP",
      "section_title": true,
      "ja": "1.1. JSEPの一般的な設計"
    },
    {
      "indent": 3,
      "text": "WebRTC call setup has been designed to focus on controlling the media plane, leaving signaling-plane behavior up to the application as much as possible. The rationale is that different applications may prefer to use different protocols, such as the existing SIP call signaling protocol, or something custom to the particular application, perhaps for a novel use case. In this approach, the key information that needs to be exchanged is the multimedia session description, which specifies the transport and media configuration information necessary to establish the media plane.",
      "ja": "WebRTC呼び出しのセットアップは、メディアプレーンの制御に重点を置いて設計されており、シグナリングプレーンの動作は可能な限りアプリケーションに任せています。理論的根拠は、異なるアプリケーションが、既存のSIPコールシグナリングプロトコルなどの異なるプロトコル、またはおそらく新しいユースケースのために特定のアプリケーションにカスタムなものを使用することを好む可能性があるということです。このアプローチでは、交換する必要のある重要な情報はマルチメディアセッションの説明です。これは、メディアプレーンを確立するために必要なトランスポートおよびメディア構成情報を指定します。"
    },
    {
      "indent": 3,
      "text": "With these considerations in mind, this document describes the JavaScript Session Establishment Protocol (JSEP), which allows for full control of the signaling state machine from JavaScript. As described above, JSEP assumes a model in which a JavaScript application executes inside a runtime containing WebRTC APIs (the \"JSEP implementation\"). The JSEP implementation is almost entirely divorced from the core signaling flow, which is instead handled by the JavaScript making use of two interfaces: (1) passing in local and remote session descriptions and (2) interacting with the Interactive Connectivity Establishment (ICE) state machine [RFC8445]. The combination of the JSEP implementation and the JavaScript application is referred to throughout this document as a \"JSEP endpoint\".",
      "ja": "これらの考慮事項を念頭に置いて、このドキュメントでは、JavaScriptからシグナリングステートマシンを完全に制御できるJavaScriptセッション確立プロトコル（JSEP）について説明します。上記のように、JSEPは、JavaScriptアプリケーションがWebRTC APIを含むランタイム内で実行されるモデル（「JSEP実装」）を想定しています。JSEPの実装は、コアシグナリングフローからほぼ完全に切り離されています。コアシグナリングフローは、代わりに2つのインターフェイスを使用するJavaScriptによって処理されます。（1）ローカルおよびリモートセッションの説明を渡すことと、（2）Interactive Connectivity Establishment（ICE）状態と対話することです。マシン[RFC8445]。JSEP実装とJavaScriptアプリケーションの組み合わせは、このドキュメント全体で「JSEPエンドポイント」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "In this document, the use of JSEP is described as if it always occurs between two JSEP endpoints. Note, though, that in many cases it will actually be between a JSEP endpoint and some kind of server, such as a gateway or Multipoint Control Unit (MCU). This distinction is invisible to the JSEP endpoint; it just follows the instructions it is given via the API.",
      "ja": "このドキュメントでは、JSEPの使用は、2つのJSEPエンドポイント間で常に発生するかのように説明されています。ただし、多くの場合、実際にはJSEPエンドポイントと、ゲートウェイやマルチポイントコントロールユニット（MCU）などのある種のサーバーの間にあることに注意してください。この違いは、JSEPエンドポイントには表示されません。APIを介して与えられた指示に従うだけです。"
    },
    {
      "indent": 3,
      "text": "JSEP's handling of session descriptions is simple and straightforward. Whenever an offer/answer exchange is needed, the initiating side creates an offer by calling a createOffer API. The application then uses that offer to set up its local configuration via the setLocalDescription API. The offer is finally sent off to the remote side over its preferred signaling mechanism (e.g., WebSockets); upon receipt of that offer, the remote party installs it using the setRemoteDescription API.",
      "ja": "JSEPのセッション記述の処理は単純で簡単です。オファー/アンサー交換が必要な場合は常に、開始側がcreateOfferAPIを呼び出してオファーを作成します。次に、アプリケーションはそのオファーを使用して、setLocalDescriptionAPIを介してローカル構成をセットアップします。オファーは最終的に、優先されるシグナリングメカニズム（WebSocketなど）を介してリモート側に送信されます。そのオファーを受信すると、リモートパーティはsetRemoteDescriptionAPIを使用してオファーをインストールします。"
    },
    {
      "indent": 3,
      "text": "To complete the offer/answer exchange, the remote party uses the createAnswer API to generate an appropriate answer, applies it using the setLocalDescription API, and sends the answer back to the initiator over the signaling channel. When the initiator gets that answer, it installs it using the setRemoteDescription API, and initial setup is complete. This process can be repeated for additional offer/answer exchanges.",
      "ja": "オファー/アンサー交換を完了するために、リモートパーティはcreateAnswer APIを使用して適切なアンサーを生成し、setLocalDescription APIを使用してそれを適用し、シグナリングチャネルを介してイニシエーターにアンサーを送り返します。イニシエーターがその回答を取得すると、setRemoteDescription APIを使用してインストールし、初期セットアップが完了します。このプロセスは、追加のオファー/アンサー交換のために繰り返すことができます。"
    },
    {
      "indent": 3,
      "text": "Regarding ICE [RFC8445], JSEP decouples the ICE state machine from the overall signaling state machine. The ICE state machine must remain in the JSEP implementation because only the implementation has the necessary knowledge of candidates and other transport information. Performing this separation provides additional flexibility in protocols that decouple session descriptions from transport. For instance, in traditional SIP, each offer or answer is self-contained, including both the session descriptions and the transport information. However, [RFC8840] allows SIP to be used with Trickle ICE [RFC8838], in which the session description can be sent immediately and the transport information can be sent when available. Sending transport information separately can allow for faster ICE and DTLS startup, since ICE checks can start as soon as any transport information is available rather than waiting for all of it. JSEP's decoupling of the ICE and signaling state machines allows it to accommodate either model.",
      "ja": "ICE [RFC8445]に関して、JSEPはICEステートマシンをシグナリングステートマシン全体から切り離します。 ICEステートマシンはJSEP実装にとどまる必要があります。これは、実装だけが候補やその他のトランスポート情報について必要な知識を持っているためです。この分離を実行すると、セッションの説明をトランスポートから分離するプロトコルに柔軟性が追加されます。たとえば、従来のSIPでは、各オファーまたはアンサーは、セッションの説明とトランスポート情報の両方を含め、自己完結型です。ただし、[RFC8840]では、SIPをTrickle ICE [RFC8838]で使用できます。この場合、セッションの説明をすぐに送信でき、使用可能な場合はトランスポート情報を送信できます。トランスポート情報を個別に送信すると、ICEとDTLSの起動を高速化できます。これは、ICEチェックは、トランスポート情報がすべて利用可能になるとすぐに開始できるためです。 JSEPのICEとシグナリングステートマシンの分離により、JSEPはどちらのモデルにも対応できます。"
    },
    {
      "indent": 3,
      "text": "Although it abstracts signaling, the JSEP approach requires that the application be aware of the signaling process. While the application does not need to understand the contents of session descriptions to set up a call, the application must call the right APIs at the right times, convert the session descriptions and ICE information into the defined messages of its chosen signaling protocol, and perform the reverse conversion on the messages it receives from the other side.",
      "ja": "シグナリングを抽象化しますが、JSEPアプローチでは、アプリケーションがシグナリングプロセスを認識している必要があります。アプリケーションは、呼び出しを設定するためにセッションの説明の内容を理解する必要はありませんが、アプリケーションは適切なAPIを適切なタイミングで呼び出し、セッションの説明とICE情報を選択したシグナリングプロトコルの定義済みメッセージに変換して、実行する必要があります。反対側から受信したメッセージの逆変換。"
    },
    {
      "indent": 3,
      "text": "One way to make life easier for the application is to provide a JavaScript library that hides this complexity from the developer; said library would implement a given signaling protocol along with its state machine and serialization code, presenting a higher-level call-oriented interface to the application developer. For example, libraries exist to provide implementations of the SIP [RFC3261] and Extensible Messaging and Presence Protocol (XMPP) [RFC6120] signaling protocols atop the JSEP API. Thus, JSEP provides greater control for the experienced developer without forcing any additional complexity on the novice developer.",
      "ja": "アプリケーションの作業を楽にする1つの方法は、この複雑さを開発者から隠すJavaScriptライブラリを提供することです。このライブラリは、ステートマシンとシリアル化コードとともに特定のシグナリングプロトコルを実装し、アプリケーション開発者に高レベルの呼び出し指向のインターフェイスを提供します。たとえば、ライブラリは、JSEPAPI上にSIP [RFC3261]およびExtensibleMessaging and Presence Protocol（XMPP）[RFC6120]シグナリングプロトコルの実装を提供するために存在します。したがって、JSEPは、初心者の開発者に追加の複雑さを強いることなく、経験豊富な開発者により優れた制御を提供します。"
    },
    {
      "indent": 0,
      "text": "1.2. Other Approaches Considered",
      "section_title": true,
      "ja": "1.2. 考慮される他のアプローチ"
    },
    {
      "indent": 3,
      "text": "One approach that was considered instead of JSEP was to include a lightweight signaling protocol. Instead of providing session descriptions to the API, the API would produce and consume messages from this protocol. While providing a more high-level API, this put more control of signaling within the JSEP implementation, forcing it to have to understand and handle concepts like signaling glare (see [RFC3264], Section 4).",
      "ja": "JSEPの代わりに検討された1つのアプローチは、軽量のシグナリングプロトコルを含めることでした。APIにセッションの説明を提供する代わりに、APIはこのプロトコルからメッセージを生成および消費します。より高レベルのAPIを提供する一方で、これによりJSEP実装内のシグナリングの制御が強化され、シグナリンググレアなどの概念を理解して処理する必要があります（[RFC3264]、セクション4を参照）。"
    },
    {
      "indent": 3,
      "text": "A second approach that was considered but not chosen was to decouple the management of the media control objects from session descriptions, instead offering APIs that would control each component directly. This was rejected based on the argument that requiring exposure of this level of complexity to the application programmer would not be beneficial; it would (1) result in an API where even a simple example would require a significant amount of code to orchestrate all the needed interactions and (2) create a large API surface that would need to be agreed upon and documented. In addition, these API points could be called in any order, resulting in a more complex set of interactions with the media subsystem than the JSEP approach, which specifies how session descriptions are to be evaluated and applied.",
      "ja": "検討されたが選択されなかった2番目のアプローチは、メディア制御オブジェクトの管理をセッション記述から切り離し、代わりに各コンポーネントを直接制御するAPIを提供することでした。これは、このレベルの複雑さをアプリケーションプログラマーに公開することは有益ではないという議論に基づいて却下されました。その結果、（1）単純な例でも必要なすべての対話を調整するために大量のコードが必要になるAPIが生成され、（2）合意して文書化する必要がある大きなAPIサーフェスが作成されます。さらに、これらのAPIポイントは任意の順序で呼び出すことができるため、セッションの説明を評価および適用する方法を指定するJSEPアプローチよりも、メディアサブシステムとの対話のセットが複雑になります。"
    },
    {
      "indent": 3,
      "text": "One variation on JSEP that was considered was to keep the basic session-description-oriented API but to move the mechanism for generating offers and answers out of the JSEP implementation. Instead of providing createOffer/createAnswer methods within the implementation, this approach would instead expose a getCapabilities API, which would provide the application with the information it needed in order to generate its own session descriptions. This increases the amount of work that the application needs to do; it needs to know how to generate session descriptions from capabilities, and especially how to generate the correct answer from an arbitrary offer and the supported capabilities. While this could certainly be addressed by using a library like the one mentioned above, it basically forces the use of said library even for a simple example. Providing createOffer/createAnswer avoids this problem.",
      "ja": "検討されたJSEPの1つのバリエーションは、基本的なセッション記述指向のAPIを維持することでしたが、オファーとアンサーを生成するためのメカニズムをJSEP実装から移動することでした。このアプローチでは、実装内でcreateOffer / createAnswerメソッドを提供する代わりに、getCapabilities APIを公開します。これにより、独自のセッション記述を生成するために必要な情報がアプリケーションに提供されます。これにより、アプリケーションが実行する必要のある作業量が増加します。機能からセッションの説明を生成する方法、特に任意のオファーとサポートされている機能から正しい答えを生成する方法を知る必要があります。これは、上記のようなライブラリを使用することで確実に対処できますが、基本的には、単純な例であっても、前述のライブラリの使用を強制します。createOffer / createAnswerを提供すると、この問題を回避できます。"
    },
    {
      "indent": 0,
      "text": "1.3. Contradiction regarding bundle-only \"m=\" sections",
      "section_title": true,
      "ja": "1.3. バンドルのみの「m =」セクションに関する矛盾"
    },
    {
      "indent": 3,
      "text": "Since the approval of the WebRTC specification documents, the IETF has become aware of an inconsistency between the document specifying JSEP and the document specifying BUNDLE (this RFC and [RFC8843], respectively). Rather than delaying publication further to come to a resolution, the documents are being published as they were originally approved. The IETF intends to restart work on these technologies, and revised versions of these documents will be published as soon as a resolution becomes available.",
      "ja": "WebRTC仕様文書の承認以来、IETFは、JSEPを指定する文書とBUNDLEを指定する文書（それぞれこのRFCと[RFC8843]）の間の不整合に気づきました。公開をさらに遅らせて解決するのではなく、ドキュメントは最初に承認されたとおりに公開されています。IETFはこれらのテクノロジの作業を再開する予定であり、これらのドキュメントの改訂版は、解決策が利用可能になり次第公開されます。"
    },
    {
      "indent": 3,
      "text": "The specific issue involves the handling of \"m=\" sections that are designated as bundle-only, as discussed in Section 4.1.1 of this RFC. Currently, there is divergence between JSEP and BUNDLE, as well as between these specifications and existing browser implementations:",
      "ja": "特定の問題には、このRFCのセクション4.1.1で説明されているように、バンドルのみとして指定されている「m =」セクションの処理が含まれます。現在、JSEPとBUNDLEの間、およびこれらの仕様と既存のブラウザー実装の間には相違があります。"
    },
    {
      "indent": 3,
      "text": "* JSEP prescribes that said \"m=\" sections should use port zero and add an \"a=bundle-only\" attribute in initial offers, but not in answers or subsequent offers.",
      "ja": "* JSEPは、「m = \"セクションはポート0を使用し、最初のオファーでは「a = bundle-only」属性を追加する必要がありますが、回答や後続のオファーでは追加しないようにする必要がある」と規定しています。"
    },
    {
      "indent": 3,
      "text": "* BUNDLE prescribes that these \"m=\" sections should be marked as described in the previous point, but in all offers and answers.",
      "ja": "* BUNDLEは、これらの「m =」セクションは前のポイントで説明したようにマークする必要があると規定していますが、すべてのオファーと回答でマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "* Most current browsers do not mark any \"m=\" sections with port zero and instead use the same port for all bundled \"m=\" sections; some others follow the JSEP behavior.",
      "ja": "* 現在のほとんどのブラウザは、「m =」セクションにポート0のマークを付けず、代わりに、バンドルされているすべての「m =」セクションに同じポートを使用します。他のいくつかはJSEPの振る舞いに従います。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すように、すべて大文字で表示される場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Semantics and Syntax",
      "section_title": true,
      "ja": "3. セマンティクスと構文"
    },
    {
      "indent": 0,
      "text": "3.1. Signaling Model",
      "section_title": true,
      "ja": "3.1. シグナリングモデル"
    },
    {
      "indent": 3,
      "text": "JSEP does not specify a particular signaling model or state machine, other than the generic need to exchange session descriptions in the fashion described by [RFC3264] (offer/answer) in order for both sides of the session to know how to conduct the session. JSEP provides mechanisms to create offers and answers, as well as to apply them to a session. However, the JSEP implementation is totally decoupled from the actual mechanism by which these offers and answers are communicated to the remote side, including addressing, retransmission, forking, and glare handling. These issues are left entirely up to the application; the application has complete control over which offers and answers get handed to the implementation, and when.",
      "ja": "JSEPは、セッションの両側がセッションの実行方法を知るために、[RFC3264]（オファー/アンサー）で説明されている方法でセッションの説明を交換する一般的な必要性を除いて、特定のシグナリングモデルまたはステートマシンを指定しません。JSEPは、オファーとアンサーを作成し、それらをセッションに適用するためのメカニズムを提供します。ただし、JSEPの実装は、アドレス指定、再送信、フォーク、グレア処理など、これらのオファーとアンサーがリモート側に伝達される実際のメカニズムから完全に切り離されています。これらの問題は完全にアプリケーションに任されています。アプリケーションは、どのオファーとアンサーがいつ実装に渡されるかを完全に制御できます。"
    },
    {
      "indent": 9,
      "text": "+-----------+                               +-----------+\n|  Web App  |<--- App-Specific Signaling -->|  Web App  |\n+-----------+                               +-----------+\n      ^                                            ^\n      |  SDP                                       |  SDP\n      V                                            V\n+-----------+                                +-----------+\n|   JSEP    |<----------- Media ------------>|   JSEP    |\n|   Impl.   |                                |   Impl.   |\n+-----------+                                +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 1: JSEP Signaling Model",
      "ja": "図1：JSEPシグナリングモデル"
    },
    {
      "indent": 0,
      "text": "3.2. Session Descriptions and State Machine",
      "section_title": true,
      "ja": "3.2. セッションの説明とステートマシン"
    },
    {
      "indent": 3,
      "text": "In order to establish the media plane, the JSEP implementation needs specific parameters to indicate what to transmit to the remote side, as well as how to handle the media that is received. These parameters are determined by the exchange of session descriptions in offers and answers, and there are certain details to this process that must be handled in the JSEP APIs.",
      "ja": "メディアプレーンを確立するために、JSEP実装には、リモート側に何を送信するか、および受信したメディアを処理する方法を示す特定のパラメーターが必要です。これらのパラメーターは、オファーとアンサーのセッション記述の交換によって決定されます。このプロセスには、JSEPAPIで処理する必要のある特定の詳細があります。"
    },
    {
      "indent": 3,
      "text": "Whether a session description applies to the local side or the remote side affects the meaning of that description. For example, the list of codecs sent to a remote party indicates what the local side is willing to receive, which, when intersected with the set of codecs the remote side supports, specifies what the remote side should send. However, not all parameters follow this rule; some parameters are declarative, and the remote side must either accept them or reject them altogether. An example of such a parameter is the TLS fingerprints [RFC8122] as used in the context of DTLS [RFC6347]; these fingerprints are calculated based on the local certificate(s) offered and are not subject to negotiation.",
      "ja": "セッションの説明がローカル側に適用されるかリモート側に適用されるかは、その説明の意味に影響します。たとえば、リモートパーティに送信されるコーデックのリストは、ローカル側が受信する意思があるものを示し、リモート側がサポートするコーデックのセットと交差する場合、リモート側が送信する必要があるものを指定します。ただし、すべてのパラメーターがこの規則に従うわけではありません。一部のパラメーターは宣言型であり、リモート側はそれらを受け入れるか、完全に拒否する必要があります。このようなパラメータの例は、DTLS [RFC6347]のコンテキストで使用されるTLSフィンガープリント[RFC8122]です。これらのフィンガープリントは、提供されたローカル証明書に基づいて計算され、ネゴシエーションの対象にはなりません。"
    },
    {
      "indent": 3,
      "text": "In addition, various RFCs put different conditions on the format of offers versus answers. For example, an offer may propose an arbitrary number of \"m=\" sections (i.e., media descriptions as described in [RFC4566], Section 5.14), but an answer must contain the exact same number as the offer.",
      "ja": "さらに、さまざまなRFCは、オファーとアンサーの形式に異なる条件を設定します。たとえば、オファーは任意の数の「m =」セクション（つまり、[RFC4566]のセクション5.14で説明されているメディアの説明）を提案できますが、回答にはオファーとまったく同じ数が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "Lastly, while the exact media parameters are known only after an offer and an answer have been exchanged, the offerer may receive ICE checks, and possibly media (e.g., in the case of a re-offer after a connection has been established) before it receives an answer. To properly process incoming media in this case, the offerer's media handler must be aware of the details of the offer before the answer arrives.",
      "ja": "最後に、正確なメディアパラメータは、オファーと回答が交換された後にのみわかりますが、オファー側はICEチェックを受け取り、場合によってはメディア（接続が確立された後の再オファーの場合）を受け取る可能性があります。答えを受け取ります。この場合、着信メディアを適切に処理するには、回答が到着する前に、オファー側のメディアハンドラーがオファーの詳細を認識している必要があります。"
    },
    {
      "indent": 3,
      "text": "Therefore, in order to handle session descriptions properly, the JSEP implementation needs:",
      "ja": "したがって、セッション記述を適切に処理するために、JSEP実装には以下が必要です。"
    },
    {
      "indent": 3,
      "text": "1. To know if a session description pertains to the local or remote side.",
      "ja": "1. セッションの説明がローカル側に関係するのかリモート側に関係するのかを知るため。"
    },
    {
      "indent": 3,
      "text": "2. To know if a session description is an offer or an answer.",
      "ja": "2. セッションの説明がオファーなのかアンサーなのかを知るため。"
    },
    {
      "indent": 3,
      "text": "3. To allow the offer to be specified independently of the answer.",
      "ja": "3. 回答とは別にオファーを指定できるようにするため。"
    },
    {
      "indent": 3,
      "text": "JSEP addresses this by adding both setLocalDescription and setRemoteDescription methods and having session description objects contain a type field indicating the type of session description being supplied. This satisfies the requirements listed above for both the offerer, who first calls setLocalDescription(sdp [offer]) and then later setRemoteDescription(sdp [answer]), and the answerer, who first calls setRemoteDescription(sdp [offer]) and then later setLocalDescription(sdp [answer]).",
      "ja": "JSEPは、setLocalDescriptionメソッドとsetRemoteDescriptionメソッドの両方を追加し、セッション記述オブジェクトに、提供されているセッション記述のタイプを示すタイプフィールドを含めることで、これに対処します。これは、最初にsetLocalDescription（sdp [offer]）を呼び出してから後でsetRemoteDescription（sdp [answer]）を呼び出す提供者と、最初にsetRemoteDescription（sdp [offer]）を呼び出して後でsetLocalDescriptionを呼び出す回答者の両方について上記の要件を満たします。（sdp [回答]）。"
    },
    {
      "indent": 3,
      "text": "During the offer/answer exchange, the outstanding offer is considered to be \"pending\" at the offerer and the answerer, as it may be either accepted or rejected. If this is a re-offer, each side will also have \"current\" local and remote descriptions, which reflect the result of the last offer/answer exchange. Sections 4.1.14, 4.1.16, 4.1.13, and 4.1.15 provide more detail on pending and current descriptions.",
      "ja": "オファー/アンサー交換中、未処理のオファーは、受け入れられるか拒否される可能性があるため、オファー側とアンサー側で「保留中」と見なされます。これが再オファーである場合、各サイドには、最後のオファー/アンサー交換の結果を反映する「現在の」ローカルおよびリモートの説明もあります。セクション4.1.14、4.1.16、4.1.13、および4.1.15は、保留中および現在の説明の詳細を提供します。"
    },
    {
      "indent": 3,
      "text": "JSEP also allows for an answer to be treated as provisional by the application. Provisional answers provide a way for an answerer to communicate initial session parameters back to the offerer, in order to allow the session to begin, while allowing a final answer to be specified later. This concept of a final answer is important to the offer/answer model; when such an answer is received, any extra resources allocated by the caller can be released, now that the exact session configuration is known. These \"resources\" can include things like extra ICE components, Traversal Using Relays around NAT (TURN) candidates, or video decoders. Provisional answers, on the other hand, do no such deallocation; as a result, multiple dissimilar provisional answers, with their own codec choices, transport parameters, etc., can be received and applied during call setup. Note that the final answer itself may be different than any received provisional answers.",
      "ja": "JSEPでは、回答をアプリケーションによって暫定的なものとして扱うこともできます。暫定回答は、セッションを開始できるようにすると同時に、最終回答を後で指定できるようにするために、回答者が最初のセッションパラメータを提供者に通知する方法を提供します。最終回答のこの概念は、オファー/回答モデルにとって重要です。このような応答を受信すると、正確なセッション構成がわかったので、呼び出し元によって割り当てられた追加のリソースを解放できます。これらの「リソース」には、追加のICEコンポーネント、NAT（TURN）候補の周りのリレーを使用したトラバーサル、またはビデオデコーダーなどが含まれます。一方、暫定的な回答では、そのような割り当て解除は行われません。その結果、独自のコーデックの選択、トランスポートパラメータなどを備えた、複数の異なる暫定回答を受信して、コールセットアップ中に適用できます。最終的な回答自体は、受け取った暫定的な回答とは異なる場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "In [RFC3264], the constraint at the signaling level is that only one offer can be outstanding for a given session, but at the JSEP level, a new offer can be generated at any point. For example, when using SIP for signaling, if one offer is sent and is then canceled using a SIP CANCEL, another offer can be generated even though no answer was received for the first offer. To support this, the JSEP media layer can provide an offer via the createOffer method whenever the JavaScript application needs one for the signaling. The answerer can send back zero or more provisional answers and then finally end the offer/answer exchange by sending a final answer. The state machine for this is as follows:",
      "ja": "[RFC3264]では、シグナリングレベルでの制約は、特定のセッションで未処理のオファーは1つだけですが、JSEPレベルでは、いつでも新しいオファーを生成できます。たとえば、シグナリングにSIPを使用している場合、1つのオファーが送信され、SIP CANCELを使用してキャンセルされると、最初のオファーに対する応答が受信されなくても、別のオファーが生成される可能性があります。これをサポートするために、JSEPメディアレイヤーは、JavaScriptアプリケーションがシグナリング用にオファーを必要とするときはいつでもcreateOfferメソッドを介してオファーを提供できます。回答者は、0個以上の暫定的な回答を送り返し、最終的な回答を送信することで、最終的にオファー/回答の交換を終了できます。このためのステートマシンは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "                    setRemote(OFFER)               setLocal(PRANSWER)\n                        /-----\\                               /-----\\\n                        |     |                               |     |\n                        v     |                               v     |\n         +---------------+    |                +---------------+    |\n         |               |----/                |               |----/\n         |  have-        | setLocal(PRANSWER)  | have-         |\n         |  remote-offer |------------------- >| local-pranswer|\n         |               |                     |               |\n         |               |                     |               |\n         +---------------+                     +---------------+\n              ^   |                                   |\n              |   | setLocal(ANSWER)                  |\nsetRemote(OFFER)  |                                   |\n              |   V                  setLocal(ANSWER) |\n         +---------------+                            |\n         |               |                            |\n         |               |<---------------------------+\n         |    stable     |\n         |               |<---------------------------+\n         |               |                            |\n         +---------------+          setRemote(ANSWER) |\n              ^   |                                   |\n              |   | setLocal(OFFER)                   |\nsetRemote(ANSWER) |                                   |\n              |   V                                   |\n         +---------------+                     +---------------+\n         |               |                     |               |\n         |  have-        | setRemote(PRANSWER) |have-          |\n         |  local-offer  |------------------- >|remote-pranswer|\n         |               |                     |               |\n         |               |----\\                |               |----\\\n         +---------------+    |                +---------------+    |\n                        ^     |                               ^     |\n                        |     |                               |     |\n                        \\-----/                               \\-----/\n                    setLocal(OFFER)               setRemote(PRANSWER)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 2: JSEP State Machine",
      "ja": "図2：JSEPステートマシン"
    },
    {
      "indent": 3,
      "text": "Aside from these state transitions, there is no other difference between the handling of provisional (\"pranswer\") and final (\"answer\") answers.",
      "ja": "これらの状態遷移を除けば、暫定（ \"pranswer\"）回答と最終（ \"answer\"）回答の処理に違いはありません。"
    },
    {
      "indent": 0,
      "text": "3.3. Session Description Format",
      "section_title": true,
      "ja": "3.3. セッションの説明形式"
    },
    {
      "indent": 3,
      "text": "JSEP's session descriptions use Session Description Protocol (SDP) syntax for their internal representation. While this format is not optimal for manipulation from JavaScript, it is widely accepted and is frequently updated with new features; any alternate encoding of session descriptions would have to keep pace with the changes to SDP, at least until the time that this new encoding eclipsed SDP in popularity.",
      "ja": "JSEPのセッション記述は、内部表現にSession Description Protocol（SDP）構文を使用します。この形式はJavaScriptからの操作には最適ではありませんが、広く受け入れられており、新しい機能で頻繁に更新されます。セッション記述の代替エンコーディングは、少なくともこの新しいエンコーディングがSDPの人気を上回ったときまで、SDPの変更に対応する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, to provide for future flexibility, the SDP syntax is encapsulated within a SessionDescription object, which can be constructed from SDP and be serialized out to SDP. If future specifications agree on a JSON format for session descriptions, we could easily enable this object to generate and consume that JSON.",
      "ja": "ただし、将来の柔軟性を提供するために、SDP構文はSessionDescriptionオブジェクト内にカプセル化されます。このオブジェクトは、SDPから構築し、SDPにシリアル化できます。将来の仕様でセッション記述のJSON形式が合意された場合、このオブジェクトがそのJSONを生成して使用できるようにすることが簡単にできます。"
    },
    {
      "indent": 3,
      "text": "As detailed below, most applications should be able to treat the SessionDescriptions produced and consumed by these various API calls as opaque blobs; that is, the application will not need to read or change them.",
      "ja": "以下で詳しく説明するように、ほとんどのアプリケーションは、これらのさまざまなAPI呼び出しによって生成および消費されるSessionDescriptionsを不透明なblobとして扱うことができるはずです。つまり、アプリケーションはそれらを読み取ったり変更したりする必要はありません。"
    },
    {
      "indent": 0,
      "text": "3.4. Session Description Control",
      "section_title": true,
      "ja": "3.4. セッション記述制御"
    },
    {
      "indent": 3,
      "text": "In order to give the application control over various common session parameters, JSEP provides control surfaces that tell the JSEP implementation how to generate session descriptions. This avoids the need for JavaScript to modify session descriptions in most cases.",
      "ja": "さまざまな一般的なセッションパラメータをアプリケーションが制御できるようにするために、JSEPは、セッション記述の生成方法をJSEP実装に指示するコントロールサーフェスを提供します。これにより、ほとんどの場合、JavaScriptがセッションの説明を変更する必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "Changes to these objects result in changes to the session descriptions generated by subsequent createOffer/createAnswer calls.",
      "ja": "これらのオブジェクトを変更すると、後続のcreateOffer / createAnswer呼び出しによって生成されるセッションの説明が変更されます。"
    },
    {
      "indent": 0,
      "text": "3.4.1. RtpTransceivers",
      "section_title": true,
      "ja": "3.4.1. RtpTransceivers"
    },
    {
      "indent": 3,
      "text": "RtpTransceivers allow the application to control the RTP media associated with one \"m=\" section. Each RtpTransceiver has an RtpSender and an RtpReceiver, which an application can use to control the sending and receiving of RTP media. The application may also modify the RtpTransceiver directly, for instance, by stopping it.",
      "ja": "RtpTransceiversを使用すると、アプリケーションは1つの「m =」セクションに関連付けられたRTPメディアを制御できます。各RtpTransceiverにはRtpSenderとRtpReceiverがあり、アプリケーションはこれらを使用してRTPメディアの送受信を制御できます。アプリケーションは、RtpTransceiverを停止するなどして、直接変更することもできます。"
    },
    {
      "indent": 3,
      "text": "RtpTransceivers generally have a 1:1 mapping with \"m=\" sections, although there may be more RtpTransceivers than \"m=\" sections when RtpTransceivers are created but not yet associated with an \"m=\" section, or if RtpTransceivers have been stopped and disassociated from \"m=\" sections. An RtpTransceiver is said to be associated with an \"m=\" section if its media identification (mid) property is non-null; otherwise, it is said to be disassociated. The associated \"m=\" section is determined using a mapping between transceivers and \"m=\" section indices, formed when creating an offer or applying a remote offer.",
      "ja": "RtpTransceiversは通常、「m =」セクションと1：1のマッピングを持ちますが、RtpTransceiversが作成されたが、まだ「m =」セクションに関連付けられていない場合、またはRtpTransceiversが停止されていて、「m =」セクションから関連付けを解除しました。RtpTransceiverは、メディアID（mid）プロパティがnullでない場合、「m =」セクションに関連付けられていると言われます。それ以外の場合は、関連付けが解除されていると言われます。関連する「m =」セクションは、トランシーバーと「m =」セクションインデックス間のマッピングを使用して決定され、オファーの作成時またはリモートオファーの適用時に形成されます。"
    },
    {
      "indent": 3,
      "text": "An RtpTransceiver is never associated with more than one \"m=\" section, and once a session description is applied, an \"m=\" section is always associated with exactly one RtpTransceiver. However, in certain cases where an \"m=\" section has been rejected, as discussed in Section 5.2.2 below, that \"m=\" section will be \"recycled\" and associated with a new RtpTransceiver with a new MID value.",
      "ja": "RtpTransceiverが複数の「m =」セクションに関連付けられることはありません。セッションの説明が適用されると、「m =」セクションは常に1つのRtpTransceiverにのみ関連付けられます。ただし、以下のセクション5.2.2で説明するように、「m =」セクションが拒否された特定のケースでは、その「m =」セクションは「リサイクル」され、新しいMID値を持つ新しいRtpTransceiverに関連付けられます。"
    },
    {
      "indent": 3,
      "text": "RtpTransceivers can be created explicitly by the application or implicitly by calling setRemoteDescription with an offer that adds new \"m=\" sections.",
      "ja": "RtpTransceiversは、アプリケーションによって明示的に作成することも、新しい「m =」セクションを追加するオファーでsetRemoteDescriptionを呼び出すことによって暗黙的に作成することもできます。"
    },
    {
      "indent": 0,
      "text": "3.4.2. RtpSenders",
      "section_title": true,
      "ja": "3.4.2. RtpSenders"
    },
    {
      "indent": 3,
      "text": "RtpSenders allow the application to control how RTP media is sent. An RtpSender is conceptually responsible for the outgoing RTP stream(s) described by an \"m=\" section. This includes encoding the attached MediaStreamTrack, sending RTP media packets, and generating/ processing the RTP Control Protocol (RTCP) for the outgoing RTP streams(s).",
      "ja": "RtpSendersを使用すると、アプリケーションはRTPメディアの送信方法を制御できます。RtpSenderは、「m =」セクションで記述された発信RTPストリームに対して概念的に責任があります。これには、接続されたMediaStreamTrackのエンコード、RTPメディアパケットの送信、および発信RTPストリームのRTP制御プロトコル（RTCP）の生成/処理が含まれます。"
    },
    {
      "indent": 0,
      "text": "3.4.3. RtpReceivers",
      "section_title": true,
      "ja": "3.4.3. RtpReceivers"
    },
    {
      "indent": 3,
      "text": "RtpReceivers allow the application to inspect how RTP media is received. An RtpReceiver is conceptually responsible for the incoming RTP stream(s) described by an \"m=\" section. This includes processing received RTP media packets, decoding the incoming stream(s) to produce a remote MediaStreamTrack, and generating/ processing RTCP for the incoming RTP stream(s).",
      "ja": "RtpReceiversを使用すると、アプリケーションはRTPメディアの受信方法を検査できます。RtpReceiverは、「m =」セクションで記述された着信RTPストリームに対して概念的に責任があります。これには、受信したRTPメディアパケットの処理、着信ストリームをデコードしてリモートMediaStreamTrackを生成すること、および着信RTPストリームのRTCPを生成/処理することが含まれます。"
    },
    {
      "indent": 0,
      "text": "3.5. ICE",
      "section_title": true,
      "ja": "3.5. 氷"
    },
    {
      "indent": 0,
      "text": "3.5.1. ICE Gathering Overview",
      "section_title": true,
      "ja": "3.5.1. ICE収集の概要"
    },
    {
      "indent": 3,
      "text": "JSEP gathers ICE candidates as needed by the application. Collection of ICE candidates is referred to as a gathering phase, and this is triggered either by the addition of a new or recycled \"m=\" section to the local session description or by new ICE credentials in the description, indicating an ICE restart. Use of new ICE credentials can be triggered explicitly by the application or implicitly by the JSEP implementation in response to changes in the ICE configuration.",
      "ja": "JSEPは、アプリケーションの必要に応じてICE候補を収集します。ICE候補の収集は収集フェーズと呼ばれ、これは、ローカルセッションの説明に新しいまたはリサイクルされた「m =」セクションが追加されるか、説明に新しいICE資格情報が追加され、ICEの再起動を示すことによってトリガーされます。新しいICE資格情報の使用は、アプリケーションによって明示的にトリガーすることも、ICE構成の変更に応じてJSEP実装によって暗黙的にトリガーすることもできます。"
    },
    {
      "indent": 3,
      "text": "When the ICE configuration changes in a way that requires a new gathering phase, a 'needs-ice-restart' bit is set. When this bit is set, calls to the createOffer API will generate new ICE credentials. This bit is cleared by a call to the setLocalDescription API with new ICE credentials from either an offer or an answer, i.e., from either a locally or remotely initiated ICE restart.",
      "ja": "新しい収集フェーズを必要とする方法でICE構成が変更されると、「needs-ice-restart」ビットが設定されます。このビットが設定されている場合、createOfferAPIを呼び出すと新しいICE資格情報が生成されます。このビットは、オファーまたはアンサーのいずれかから、つまりローカルまたはリモートで開始されたICE再起動からの新しいICE資格情報を使用したsetLocalDescriptionAPIの呼び出しによってクリアされます。"
    },
    {
      "indent": 3,
      "text": "When a new gathering phase starts, the ICE agent will notify the application that gathering is occurring through a state change event. Then, when each new ICE candidate becomes available, the ICE agent will supply it to the application via an onicecandidate event; these candidates will also automatically be added to the current and/or pending local session description. Finally, when all candidates have been gathered, a final onicecandidate event will be dispatched to signal that the gathering process is complete.",
      "ja": "新しい収集フェーズが開始されると、ICEエージェントは、状態変更イベントを通じて収集が行われていることをアプリケーションに通知します。次に、新しいICE候補がそれぞれ利用可能になると、ICEエージェントはonicecandidateイベントを介してそれをアプリケーションに提供します。これらの候補は、現在および/または保留中のローカルセッションの説明にも自動的に追加されます。最後に、すべての候補者が収集されると、最終的な候補者イベントがディスパッチされ、収集プロセスが完了したことを通知します。"
    },
    {
      "indent": 3,
      "text": "Note that gathering phases only gather the candidates needed by new/recycled/restarting \"m=\" sections; other \"m=\" sections continue to use their existing candidates. Also, if an \"m=\" section is bundled (either by a successful bundle negotiation or by being marked as bundle-only), then candidates will be gathered and exchanged for that \"m=\" section if and only if its MID item is a BUNDLE-tag, as described in [RFC8843].",
      "ja": "収集フェーズでは、「m =」セクションの新規/リサイクル/再開に必要な候補のみが収集されることに注意してください。他の「m =」セクションは、引き続き既存の候補を使用します。また、「m =」セクションがバンドルされている場合（バンドルネゴシエーションの成功またはバンドルのみとしてマークされている場合）、MIDアイテムが次の場合に限り、候補が収集され、その「m =」セクションと交換されます。[RFC8843]で説明されているBUNDLEタグ。"
    },
    {
      "indent": 0,
      "text": "3.5.2. ICE Candidate Trickling",
      "section_title": true,
      "ja": "3.5.2. ICE候補のトリックリング"
    },
    {
      "indent": 3,
      "text": "Candidate trickling is a technique through which a caller may incrementally provide candidates to the callee after the initial offer has been dispatched; the semantics of \"Trickle ICE\" are defined in [RFC8838]. This process allows the callee to begin acting upon the call and setting up the ICE (and perhaps DTLS) connections immediately, without having to wait for the caller to gather all possible candidates. This results in faster media setup in cases where gathering is not performed prior to initiating the call.",
      "ja": "候補者の細流化は、最初のオファーがディスパッチされた後、発信者が着信者に候補者を段階的に提供するための手法です。「TrickleICE」のセマンティクスは[RFC8838]で定義されています。このプロセスにより、呼び出し元がすべての可能な候補を収集するのを待たずに、呼び出し先が呼び出しに対応し、ICE（およびおそらくDTLS）接続をすぐにセットアップできるようになります。これにより、通話を開始する前に収集が実行されない場合に、メディアのセットアップが高速になります。"
    },
    {
      "indent": 3,
      "text": "JSEP supports optional candidate trickling by providing APIs, as described above, that provide control and feedback on the ICE candidate gathering process. Applications that support candidate trickling can send the initial offer immediately and send individual candidates when they get notified of a new candidate; applications that do not support this feature can simply wait for the indication that gathering is complete, and then create and send their offer, with all the candidates, at that time.",
      "ja": "JSEPは、上記のように、ICE候補収集プロセスの制御とフィードバックを提供するAPIを提供することにより、オプションの候補トリクルをサポートします。候補者の細流化をサポートするアプリケーションは、最初のオファーをすぐに送信し、新しい候補者の通知を受け取ったときに個々の候補者を送信できます。この機能をサポートしていないアプリケーションは、収集が完了したという表示を待つだけで、その時点ですべての候補者とともにオファーを作成して送信できます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of trickled candidates, the receiving application will supply them to its ICE agent. This triggers the ICE agent to start using the new remote candidates for connectivity checks.",
      "ja": "騙された候補者を受け取ると、受け取ったアプリケーションはそれらをICEエージェントに提供します。これにより、ICEエージェントは接続チェックに新しいリモート候補の使用を開始します。"
    },
    {
      "indent": 0,
      "text": "3.5.2.1. ICE Candidate Format",
      "section_title": true,
      "ja": "3.5.2.1. ICE候補フォーマット"
    },
    {
      "indent": 3,
      "text": "In JSEP, ICE candidates are abstracted by an IceCandidate object, and as with session descriptions, SDP syntax is used for the internal representation.",
      "ja": "JSEPでは、ICE候補はIceCandidateオブジェクトによって抽象化され、セッションの説明と同様に、SDP構文が内部表現に使用されます。"
    },
    {
      "indent": 3,
      "text": "The candidate details are specified in an IceCandidate field, using the same SDP syntax as the \"candidate-attribute\" field defined in [RFC8839], Section 5.1. Note that this field does not contain an \"a=\" prefix, as indicated in the following example:",
      "ja": "候補の詳細は、[RFC8839]のセクション5.1で定義されている「candidate-attribute」フィールドと同じSDP構文を使用して、IceCandidateフィールドで指定されます。次の例に示すように、このフィールドには「a =」プレフィックスが含まれていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host",
      "ja": "候補：1 1 UDP 1694498815 192.0.2.33 10000typホスト"
    },
    {
      "indent": 3,
      "text": "The IceCandidate object contains a field to indicate which ICE username fragment (ufrag) it is associated with, as defined in [RFC8839], Section 5.4. This value is used to determine which session description (and thereby which gathering phase) this IceCandidate belongs to, which helps resolve ambiguities during ICE restarts. If this field is absent in a received IceCandidate (perhaps when communicating with a non-JSEP endpoint), the most recently received session description is assumed.",
      "ja": "IceCandidateオブジェクトには、[RFC8839]のセクション5.4で定義されているように、関連付けられているICEユーザー名フラグメント（ufrag）を示すフィールドが含まれています。この値は、このIceCandidateが属するセッションの説明（およびそれによってどの収集フェーズ）を決定するために使用され、ICEの再起動中のあいまいさを解決するのに役立ちます。受信したIceCandidateにこのフィールドがない場合（おそらく、JSEP以外のエンドポイントと通信している場合）、最後に受信したセッションの説明が想定されます。"
    },
    {
      "indent": 3,
      "text": "The IceCandidate object also contains fields to indicate which \"m=\" section it is associated with, which can be identified in one of two ways: either by an \"m=\" section index or by a MID. The \"m=\" section index is a zero-based index, with index N referring to the N+1th \"m=\" section in the session description referenced by this IceCandidate. The MID is a \"media stream identification\" value, as defined in [RFC5888], Section 4, which provides a more robust way to identify the \"m=\" section in the session description, using the MID of the associated RtpTransceiver object (which may have been locally generated by the answerer when interacting with a non-JSEP endpoint that does not support the MID attribute, as discussed in Section 5.10 below). If the MID field is present in a received IceCandidate, it MUST be used for identification; otherwise, the \"m=\" section index is used instead.",
      "ja": "IceCandidateオブジェクトには、関連付けられている「m =」セクションを示すフィールドも含まれています。これは、「m =」セクションインデックスまたはMIDのいずれかで識別できます。「m =」セクションインデックスはゼロベースのインデックスであり、インデックスNは、このIceCandidateによって参照されるセッション記述のN番目の「m =」セクションを参照します。MIDは、[RFC5888]のセクション4で定義されている「メディアストリーム識別」値であり、関連付けられたRtpTransceiverオブジェクトのMIDを使用して、セッションの説明で「m =」セクションを識別するためのより堅牢な方法を提供します。以下のセクション5.10で説明するように、MID属性をサポートしない非JSEPエンドポイントと対話するときに、アンサーによってローカルに生成された可能性があります。受信したIceCandidateにMIDフィールドが存在する場合は、識別に使用する必要があります。それ以外の場合は、代わりに「m =」セクションインデックスが使用されます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST be prepared to receive objects with some fields missing, as mentioned above.",
      "ja": "上記のように、実装は、いくつかのフィールドが欠落しているオブジェクトを受け取るように準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.3. ICE Candidate Policy",
      "section_title": true,
      "ja": "3.5.3. ICE候補ポリシー"
    },
    {
      "indent": 3,
      "text": "Typically, when gathering ICE candidates, the JSEP implementation will gather all possible forms of initial candidates -- host, server-reflexive, and relay. However, in certain cases, applications may want to have more specific control over the gathering process, due to privacy or related concerns. For example, one may want to only use relay candidates, to leak as little location information as possible (keeping in mind that this choice comes with corresponding operational costs). To accomplish this, JSEP allows the application to restrict which ICE candidates are used in a session. Note that this filtering is applied on top of any restrictions the implementation chooses to enforce regarding which IP addresses are permitted for the application, as discussed in [RFC8828].",
      "ja": "通常、ICE候補を収集する場合、JSEP実装は、ホスト、サーバー再帰、およびリレーなど、考えられるすべての形式の初期候補を収集します。ただし、場合によっては、プライバシーまたは関連する懸念事項のために、アプリケーションが収集プロセスをより具体的に制御したい場合があります。たとえば、リレー候補のみを使用して、位置情報の漏洩をできるだけ少なくしたい場合があります（この選択には対応する運用コストが伴うことに注意してください）。これを実現するために、JSEPを使用すると、アプリケーションはセッションで使用されるICE候補を制限できます。[RFC8828]で説明されているように、このフィルタリングは、アプリケーションで許可されるIPアドレスに関して実装が適用することを選択した制限に加えて適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "There may also be cases where the application wants to change which types of candidates are used while the session is active. A prime example is where a callee may initially want to use only relay candidates, to avoid leaking location information to an arbitrary caller, but then change to use all candidates (for lower operational cost) once the user has indicated that they want to take the call. For this scenario, the JSEP implementation MUST allow the candidate policy to be changed in mid-session, subject to the aforementioned interactions with local policy.",
      "ja": "また、セッションがアクティブなときに、アプリケーションが使用する候補のタイプを変更したい場合もあります。代表的な例は、発信者が任意の発信者に位置情報を漏らさないように、最初は中継候補のみを使用したいが、ユーザーが取得したいことを示したら、すべての候補を使用するように変更する場合です（運用コストを削減するため）。コール。このシナリオでは、JSEP実装は、前述のローカルポリシーとの相互作用を条件として、セッションの途中で候補ポリシーを変更できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "To administer the ICE candidate policy, the JSEP implementation will determine the current setting at the start of each gathering phase. Then, during the gathering phase, the implementation MUST NOT expose candidates disallowed by the current policy to the application, use them as the source of connectivity checks, or indirectly expose them via other fields, such as the raddr/rport attributes for other ICE candidates. Later, if a different policy is specified by the application, the application can apply it by kicking off a new gathering phase via an ICE restart.",
      "ja": "ICE候補ポリシーを管理するために、JSEP実装は、各収集フェーズの開始時に現在の設定を決定します。次に、収集フェーズ中に、実装は、現在のポリシーで許可されていない候補をアプリケーションに公開したり、接続チェックのソースとして使用したり、他のICE候補のraddr / rport属性などの他のフィールドを介して間接的に公開したりしてはなりません。。後で、アプリケーションによって別のポリシーが指定された場合、アプリケーションは、ICEの再起動を介して新しい収集フェーズを開始することによってそれを適用できます。"
    },
    {
      "indent": 0,
      "text": "3.5.4. ICE Candidate Pool",
      "section_title": true,
      "ja": "3.5.4. ICE候補プール"
    },
    {
      "indent": 3,
      "text": "JSEP applications typically inform the JSEP implementation to begin ICE gathering via the information supplied to setLocalDescription, as the local description indicates the number of ICE components that will be needed and for which candidates must be gathered. However, to accelerate cases where the application knows the number of ICE components to use ahead of time, it may ask the implementation to gather a pool of potential ICE candidates to help ensure rapid media setup.",
      "ja": "JSEPアプリケーションは通常、setLocalDescriptionに提供された情報を介してICE収集を開始するようにJSEP実装に通知します。これは、ローカル記述が必要で候補を収集する必要があるICEコンポーネントの数を示しているためです。ただし、アプリケーションが事前に使用するICEコンポーネントの数を知っている場合を加速するために、迅速なメディアセットアップを確実にするために、潜在的なICE候補のプールを収集するように実装に要求する場合があります。"
    },
    {
      "indent": 3,
      "text": "When setLocalDescription is eventually called and the JSEP implementation prepares to gather the needed ICE candidates, it SHOULD start by checking if any candidates are available in the pool. If there are candidates in the pool, they SHOULD be handed to the application immediately via the ICE candidate event. If the pool becomes depleted, either because a larger-than-expected number of ICE components are used or because the pool has not had enough time to gather candidates, the remaining candidates are gathered as usual. This only occurs for the first offer/answer exchange, after which the candidate pool is emptied and no longer used.",
      "ja": "setLocalDescriptionが最終的に呼び出され、JSEP実装が必要なICE候補を収集する準備をするとき、プールで利用可能な候補があるかどうかを確認することから開始する必要があります。プールに候補者がいる場合は、ICE候補者イベントを介してすぐにアプリケーションに渡す必要があります。予想よりも多くのICEコンポーネントが使用されているか、プールに候補を収集するのに十分な時間がないためにプールが使い果たされた場合、残りの候補は通常どおり収集されます。これは、最初のオファー/アンサー交換でのみ発生し、その後、候補プールは空になり、使用されなくなります。"
    },
    {
      "indent": 3,
      "text": "One example of where this concept is useful is an application that expects an incoming call at some point in the future, and wants to minimize the time it takes to establish connectivity, to avoid clipping of initial media. By pre-gathering candidates into the pool, it can exchange and start sending connectivity checks from these candidates almost immediately upon receipt of a call. Note, though, that by holding on to these pre-gathered candidates, which will be kept alive as long as they may be needed, the application will consume resources on the STUN/TURN servers it is using. (\"STUN\" stands for \"Session Traversal Utilities for NAT\".)",
      "ja": "この概念が役立つ一例は、将来のある時点で着信コールを予期し、接続の確立にかかる時間を最小限に抑えて、初期メディアのクリッピングを回避したいアプリケーションです。候補を事前にプールに収集することにより、コールを受信するとすぐに、これらの候補からの接続チェックを交換して送信を開始できます。ただし、これらの事前に収集された候補を保持することにより、必要な限り存続するため、アプリケーションは使用しているSTUN / TURNサーバー上のリソースを消費することに注意してください。（「STUN」は「NATのセッショントラバーサルユーティリティ」の略です。）"
    },
    {
      "indent": 0,
      "text": "3.5.5. ICE Versions",
      "section_title": true,
      "ja": "3.5.5. ICEバージョン"
    },
    {
      "indent": 3,
      "text": "While this specification formally relies on [RFC8445], at the time of its publication, the majority of WebRTC implementations support the version of ICE described in [RFC5245]. The \"ice2\" attribute defined in [RFC8445] can be used to detect the version in use by a remote endpoint and to provide a smooth transition from the older specification to the newer one. Implementations MUST be able to accept remote descriptions that do not have the \"ice2\" attribute.",
      "ja": "この仕様は正式には[RFC8445]に依存していますが、公開時点では、WebRTC実装の大部分は[RFC5245]で説明されているバージョンのICEをサポートしています。[RFC8445]で定義されている「ice2」属性を使用して、リモートエンドポイントで使用されているバージョンを検出し、古い仕様から新しい仕様へのスムーズな移行を提供できます。実装は、「ice2」属性を持たないリモート記述を受け入れることができなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Video Size Negotiation",
      "section_title": true,
      "ja": "3.6. ビデオサイズの交渉"
    },
    {
      "indent": 3,
      "text": "Video size negotiation is the process through which a receiver can use the \"a=imageattr\" SDP attribute [RFC6236] to indicate what video frame sizes it is capable of receiving. A receiver may have hard limits on what its video decoder can process, or it may have some maximum set by policy. By specifying these limits in an \"a=imageattr\" attribute, JSEP endpoints can attempt to ensure that the remote sender transmits video at an acceptable resolution. However, when communicating with a non-JSEP endpoint that does not understand this attribute, any signaled limits may be exceeded, and the JSEP implementation MUST handle this gracefully, e.g., by discarding the video.",
      "ja": "ビデオサイズネゴシエーションは、受信者が「a = imageattr」SDP属性[RFC6236]を使用して、受信可能なビデオフレームサイズを示すことができるプロセスです。受信機には、ビデオデコーダーが処理できるものに厳しい制限がある場合や、ポリシーによって設定された最大値がある場合があります。これらの制限を「a = imageattr」属性で指定することにより、JSEPエンドポイントは、リモート送信者が許容可能な解像度でビデオを送信することを保証しようと試みることができます。ただし、この属性を理解しない非JSEPエンドポイントと通信する場合、シグナル制限を超える可能性があり、JSEP実装は、たとえばビデオを破棄することによって、これを適切に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that certain codecs support transmission of samples with aspect ratios other than 1.0 (i.e., non-square pixels). JSEP implementations will not transmit non-square pixels but SHOULD receive and render such video with the correct aspect ratio. However, sample aspect ratio has no impact on the size negotiation described below; all dimensions are measured in pixels, whether square or not.",
      "ja": "特定のコーデックは、1.0以外のアスペクト比（つまり、非正方形ピクセル）のサンプルの送信をサポートしていることに注意してください。JSEP実装は非正方形ピクセルを送信しませんが、正しいアスペクト比でそのようなビデオを受信してレンダリングする必要があります。ただし、サンプルのアスペクト比は、以下で説明するサイズネゴシエーションには影響しません。正方形かどうかに関係なく、すべての寸法はピクセル単位で測定されます。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Creating an imageattr Attribute",
      "section_title": true,
      "ja": "3.6.1. imageattr属性の作成"
    },
    {
      "indent": 3,
      "text": "The receiver will first combine any known local limits (e.g., hardware decoder capabilities or local policy) to determine the absolute minimum and maximum sizes it can receive. If there are no known local limits, the \"a=imageattr\" attribute SHOULD be omitted. If these local limits preclude receiving any video, i.e., the degenerate case of no permitted resolutions, the \"a=imageattr\" attribute MUST be omitted, and the \"m=\" section MUST be marked as sendonly/inactive, as appropriate.",
      "ja": "受信者は、最初に既知のローカル制限（ハードウェアデコーダー機能やローカルポリシーなど）を組み合わせて、受信できる絶対最小サイズと最大サイズを決定します。既知のローカル制限がない場合は、「a = imageattr」属性を省略する必要があります。これらのローカル制限によりビデオの受信が不可能な場合、つまり、解像度が許可されていない退化した場合は、「a = imageattr」属性を省略し、「m =」セクションを必要に応じてsendonly / inactiveとしてマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, an \"a=imageattr\" attribute is created with a \"recv\" direction, and the resulting resolution space formed from the aforementioned intersection is used to specify its minimum and maximum \"x=\" and \"y=\" values.",
      "ja": "それ以外の場合は、「a = imageattr」属性が「recv」方向で作成され、前述の交点から形成された結果の解像度空間を使用して、最小および最大の「x =」および「y =」値を指定します。"
    },
    {
      "indent": 3,
      "text": "The rules here express a single set of preferences, and therefore, the \"a=imageattr\" \"q=\" value is not important. It SHOULD be set to \"1.0\".",
      "ja": "ここでのルールは単一の設定セットを表すため、「a = imageattr」「q =」の値は重要ではありません。「1.0」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"a=imageattr\" field is payload type specific. When all video codecs supported have the same capabilities, use of a single attribute, with the wildcard payload type (*), is RECOMMENDED. However, when the supported video codecs have different limitations, specific \"a=imageattr\" attributes MUST be inserted for each payload type.",
      "ja": "「a = imageattr」フィールドはペイロードタイプ固有です。サポートされているすべてのビデオコーデックが同じ機能を備えている場合は、ワイルドカードペイロードタイプ（*）を使用した単一の属性の使用をお勧めします。ただし、サポートされているビデオコーデックに異なる制限がある場合は、ペイロードタイプごとに特定の「a = imageattr」属性を挿入する必要があります。"
    },
    {
      "indent": 3,
      "text": "As an example, consider a system with a multiformat video decoder, which is capable of decoding any resolution from 48x48 to 720p. In this case, the implementation would generate this attribute:",
      "ja": "例として、48x48から720pまでの任意の解像度をデコードできるマルチフォーマットビデオデコーダーを備えたシステムを考えてみましょう。この場合、実装は次の属性を生成します。"
    },
    {
      "indent": 13,
      "text": "a=imageattr:* recv [x=[48:1280],y=[48:720],q=1.0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This declaration indicates that the receiver is capable of decoding any image resolution from 48x48 up to 1280x720 pixels.",
      "ja": "この宣言は、受信機が48x48から1280x720ピクセルまでの任意の画像解像度をデコードできることを示しています。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Interpreting imageattr Attributes",
      "section_title": true,
      "ja": "3.6.2. imageattr属性の解釈"
    },
    {
      "indent": 3,
      "text": "[RFC6236] defines \"a=imageattr\" to be an advisory field. This means that it does not absolutely constrain the video formats that the sender can use but gives an indication of the preferred values.",
      "ja": "[RFC6236]は、「a = imageattr」をアドバイザリフィールドとして定義しています。これは、送信者が使用できるビデオ形式を完全に制限するのではなく、優先値を示すことを意味します。"
    },
    {
      "indent": 3,
      "text": "This specification prescribes behavior that is more specific. When a MediaStreamTrack, which is producing video of a certain resolution (the \"track resolution\"), is attached to an RtpSender, which is encoding the track video at the same or lower resolution(s) (the \"encoder resolutions\"), and a remote description is applied that references the sender and contains valid \"a=imageattr recv\" attributes, it MUST follow the rules below to ensure that the sender does not transmit a resolution that would exceed the size criteria specified in the attributes. These rules MUST be followed as long as the attributes remain present in the remote description, including cases in which the track changes its resolution or is replaced with a different track.",
      "ja": "この仕様は、より具体的な動作を規定しています。特定の解像度（「トラック解像度」）のビデオを生成しているMediaStreamTrackが、同じまたはより低い解像度（「エンコーダー解像度」）でトラックビデオをエンコードしているRtpSenderに接続されている場合。送信者を参照し、有効な「a = imageattr recv」属性を含むリモート記述が適用されます。送信者が属性で指定されたサイズ基準を超える解像度を送信しないように、以下のルールに従う必要があります。トラックの解像度が変更されたり、別のトラックに置き換えられたりする場合を含め、属性がリモートディスクリプションに存在する限り、これらのルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "Depending on how the RtpSender is configured, it may be producing a single encoding at a certain resolution or, if simulcast (Section 3.7) has been negotiated, multiple encodings, each at their own specific resolution. In addition, depending on the configuration, each encoding may have the flexibility to reduce resolution when needed or may be locked to a specific output resolution.",
      "ja": "RtpSenderの構成方法に応じて、特定の解像度で単一のエンコーディングを生成する場合もあれば、サイマルキャスト（セクション3.7）がネゴシエートされている場合は、それぞれが固有の解像度で複数のエンコーディングを生成する場合もあります。さらに、構成に応じて、各エンコーディングには、必要に応じて解像度を下げる柔軟性がある場合や、特定の出力解像度にロックされる場合があります。"
    },
    {
      "indent": 3,
      "text": "For each encoding being produced by the RtpSender, the set of \"a=imageattr recv\" attributes in the corresponding \"m=\" section of the remote description is processed to determine what should be transmitted. Only attributes that reference the media format selected for the encoding are considered; each such attribute is evaluated individually, starting with the attribute with the highest \"q=\" value. If multiple attributes have the same \"q=\" value, they are evaluated in the order they appear in their containing \"m=\" section. Note that while JSEP endpoints will include at most one \"a=imageattr recv\" attribute per media format, JSEP endpoints may receive session descriptions from non-JSEP endpoints with \"m=\" sections that contain multiple such attributes.",
      "ja": "RtpSenderによって生成されるエンコーディングごとに、リモート記述の対応する「m =」セクションの「a = imageattr recv」属性のセットが処理され、何を送信するかが決定されます。エンコーディング用に選択されたメディアフォーマットを参照する属性のみが考慮されます。このような各属性は、「q =」の値が最も高い属性から始めて個別に評価されます。複数の属性が同じ「q =」値を持っている場合、それらは含まれている「m =」セクションに表示される順序で評価されます。JSEPエンドポイントには、メディア形式ごとに最大1つの「a = imageattrrecv」属性が含まれますが、JSEPエンドポイントは、複数のそのような属性を含む「m =」セクションを持つ非JSEPエンドポイントからセッションの説明を受け取る場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For each \"a=imageattr recv\" attribute, the following rules are applied. If this processing is successful, the encoding is transmitted accordingly, and no further attributes are considered for that encoding. Otherwise, the next attribute is evaluated, in the aforementioned order. If none of the supplied attributes can be processed successfully, the encoding MUST NOT be transmitted, and an error SHOULD be raised to the application.",
      "ja": "「a = imageattrrecv」属性ごとに、次のルールが適用されます。この処理が成功すると、それに応じてエンコーディングが送信され、そのエンコーディングについてそれ以上の属性は考慮されません。それ以外の場合は、次の属性が前述の順序で評価されます。指定された属性のいずれも正常に処理できない場合は、エンコーディングを送信してはならず、アプリケーションにエラーを発生させる必要があります。"
    },
    {
      "indent": 3,
      "text": "* The limits from the attribute are compared to the encoder resolution. Only the specific limits mentioned below are considered; any other values, such as picture aspect ratio, MUST be ignored. When considering a MediaStreamTrack that is producing rotated video, the unrotated resolution MUST be used for the checks. This is required regardless of whether the receiver supports performing receive-side rotation (e.g., through Coordination of Video Orientation (CVO) [TS26.114]), as it significantly simplifies the matching logic.",
      "ja": "* 属性からの制限は、エンコーダの解像度と比較されます。以下に記載されている特定の制限のみが考慮されます。画像のアスペクト比など、その他の値はすべて無視する必要があります。回転したビデオを生成しているMediaStreamTrackを検討する場合、チェックには回転していない解像度を使用する必要があります。これは、受信側が受信側の回転の実行をサポートしているかどうかに関係なく（たとえば、ビデオ方向の調整（CVO）[TS26.114]を介して）、マッチングロジックを大幅に簡素化するために必要です。"
    },
    {
      "indent": 3,
      "text": "* If the attribute includes a \"sar=\" (sample aspect ratio) value set to something other than \"1.0\", indicating that the receiver wants to receive non-square pixels, this cannot be satisfied and the attribute MUST NOT be used.",
      "ja": "* 属性に「1.0」以外に設定された「sar =」（サンプルアスペクト比）値が含まれている場合、受信者が非正方形ピクセルを受信することを示している場合、これを満たすことはできず、属性を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "* If the encoder resolution exceeds the maximum size permitted by the attribute and the encoder is allowed to adjust its resolution, the encoder SHOULD apply downscaling in order to satisfy the limits. Downscaling MUST NOT change the picture aspect ratio of the encoding, ignoring any trivial differences due to rounding. For example, if the encoder resolution is 1280x720 and the attribute specified a maximum of 640x480, the expected output resolution would be 640x360. If downscaling cannot be applied, the attribute MUST NOT be used.",
      "ja": "* エンコーダーの解像度が属性で許可されている最大サイズを超え、エンコーダーがその解像度を調整できる場合、エンコーダーは制限を満たすためにダウンスケーリングを適用する必要があります。ダウンスケーリングは、丸めによる些細な違いを無視して、エンコーディングの画像のアスペクト比を変更してはなりません（MUSTNOT）。たとえば、エンコーダの解像度が1280x720で、属性が最大640x480を指定している場合、期待される出力解像度は640x360になります。ダウンスケーリングを適用できない場合は、属性を使用しないでください。"
    },
    {
      "indent": 3,
      "text": "* If the encoder resolution is less than the minimum size permitted by the attribute, the attribute MUST NOT be used; the encoder MUST NOT apply upscaling. JSEP implementations SHOULD avoid this situation by allowing receipt of arbitrarily small resolutions, perhaps via fallback to a software decoder.",
      "ja": "* エンコーダの解像度が属性で許可されている最小サイズよりも小さい場合、属性を使用してはなりません。エンコーダーはアップスケーリングを適用してはなりません（MUSTNOT）。JSEP実装は、おそらくソフトウェアデコーダーへのフォールバックを介して、任意の小さな解像度の受信を許可することにより、この状況を回避する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the encoder resolution is within the maximum and minimum sizes, no action is needed.",
      "ja": "* エンコーダの解像度が最大サイズと最小サイズの範囲内にある場合、アクションは不要です。"
    },
    {
      "indent": 0,
      "text": "3.7. Simulcast",
      "section_title": true,
      "ja": "3.7. サイマルキャスト"
    },
    {
      "indent": 3,
      "text": "JSEP supports simulcast transmission of a MediaStreamTrack, where multiple encodings of the source media can be transmitted within the context of a single \"m=\" section. The current JSEP API is designed to allow applications to send simulcasted media but only to receive a single encoding. This allows for multi-user scenarios where each sending client sends multiple encodings to a server, which then, for each receiving client, chooses the appropriate encoding to forward.",
      "ja": "JSEPは、MediaStreamTrackの同時送信をサポートします。この場合、ソースメディアの複数のエンコーディングを単一の「m =」セクションのコンテキスト内で送信できます。現在のJSEPAPIは、アプリケーションが同時放送されたメディアを送信できるように設計されていますが、単一のエンコーディングのみを受信できます。これにより、各送信クライアントが複数のエンコーディングをサーバーに送信し、サーバーが受信クライアントごとに適切なエンコーディングを選択して転送するマルチユーザーシナリオが可能になります。"
    },
    {
      "indent": 3,
      "text": "Applications request support for simulcast by configuring multiple encodings on an RtpSender. Upon generation of an offer or answer, these encodings are indicated via SDP markings on the corresponding \"m=\" section, as described below. Receivers that understand simulcast and are willing to receive it will also include SDP markings to indicate their support, and JSEP endpoints will use these markings to determine whether simulcast is permitted for a given RtpSender. If simulcast support is not negotiated, the RtpSender will only use the first configured encoding.",
      "ja": "アプリケーションは、RtpSenderで複数のエンコーディングを構成することにより、サイマルキャストのサポートを要求します。オファーまたはアンサーが生成されると、これらのエンコーディングは、以下で説明するように、対応する「m =」セクションのSDPマーキングを介して示されます。サイマルキャストを理解し、それを受信する意思のある受信者には、サポートを示すSDPマーキングも含まれ、JSEPエンドポイントはこれらのマーキングを使用して、特定のRtpSenderでサイマルキャストが許可されているかどうかを判断します。サイマルキャストのサポートがネゴシエートされていない場合、RtpSenderは最初に構成されたエンコーディングのみを使用します。"
    },
    {
      "indent": 3,
      "text": "Note that the exact simulcast parameters are up to the sending application. While the aforementioned SDP markings are provided to ensure that the remote side can receive and demux multiple simulcast encodings, the specific resolutions and bitrates to be used for each encoding are purely a send-side decision in JSEP.",
      "ja": "正確なサイマルキャストパラメータは送信アプリケーション次第であることに注意してください。前述のSDPマーキングは、リモート側が複数のサイマルキャストエンコーディングを受信およびデマックスできるようにするために提供されていますが、各エンコーディングに使用される特定の解像度とビットレートは、JSEPでは純粋に送信側の決定です。"
    },
    {
      "indent": 3,
      "text": "JSEP currently does not provide a mechanism to configure receipt of simulcast. This means that if simulcast is offered by the remote endpoint, the answer generated by a JSEP endpoint will not indicate support for receipt of simulcast, and as such the remote endpoint will only send a single encoding per \"m=\" section.",
      "ja": "JSEPは現在、サイマルキャストの受信を構成するメカニズムを提供していません。つまり、リモートエンドポイントによってサイマルキャストが提供されている場合、JSEPエンドポイントによって生成された応答は、サイマルキャストの受信のサポートを示さないため、リモートエンドポイントは「m =」セクションごとに1つのエンコーディングのみを送信します。"
    },
    {
      "indent": 3,
      "text": "In addition, JSEP does not provide a mechanism to handle an incoming offer requesting simulcast from the JSEP endpoint. This means that setting up simulcast in the case where the JSEP endpoint receives the initial offer requires out-of-band signaling or SDP inspection. However, in the case where the JSEP endpoint sets up simulcast in its initial offer, any established simulcast streams will continue to work upon receipt of an incoming re-offer. Future versions of this specification may add additional APIs to handle the incoming initial offer scenario.",
      "ja": "さらに、JSEPは、JSEPエンドポイントからの同時キャストを要求する着信オファーを処理するメカニズムを提供していません。これは、JSEPエンドポイントが最初のオファーを受信した場合にサイマルキャストを設定するには、帯域外信号方式またはSDP検査が必要であることを意味します。ただし、JSEPエンドポイントが最初のオファーでサイマルキャストを設定した場合、確立されたサイマルキャストストリームは、着信再オファーを受信しても引き続き機能します。この仕様の将来のバージョンでは、着信初期オファーシナリオを処理するためのAPIが追加される可能性があります。"
    },
    {
      "indent": 3,
      "text": "When using JSEP to transmit multiple encodings from an RtpSender, the techniques from [RFC8853] and [RFC8851] are used. Specifically, when multiple encodings have been configured for an RtpSender, the \"m=\" section for the RtpSender will include an \"a=simulcast\" attribute, as defined in [RFC8853], Section 5.1, with a \"send\" simulcast stream description that lists each desired encoding, and no \"recv\" simulcast stream description. The \"m=\" section will also include an \"a=rid\" attribute for each encoding, as specified in [RFC8851], Section 4; the use of Restriction Identifiers (RIDs, also called rid-ids or RtpStreamIds) allows the individual encodings to be disambiguated even though they are all part of the same \"m=\" section.",
      "ja": "JSEPを使用してRtpSenderから複数のエンコーディングを送信する場合、[RFC8853]および[RFC8851]の手法が使用されます。具体的には、RtpSenderに複数のエンコーディングが構成されている場合、RtpSenderの「m =」セクションには、[RFC8853]のセクション5.1で定義されているように、「送信」サイマルキャストストリームの説明とともに「a = simulcast」属性が含まれます。必要な各エンコーディングをリストし、「recv」サイマルキャストストリームの説明はリストしません。「m =」セクションには、[RFC8851]のセクション4で指定されているように、各エンコーディングの「a = rid」属性も含まれます。制限識別子（RID、rid-idsまたはRtpStreamIdsとも呼ばれます）を使用すると、すべて同じ「m =」セクションの一部であっても、個々のエンコーディングを明確にすることができます。"
    },
    {
      "indent": 0,
      "text": "3.8. Interactions with Forking",
      "section_title": true,
      "ja": "3.8. フォークとの相互作用"
    },
    {
      "indent": 3,
      "text": "Some call signaling systems allow various types of forking where an SDP Offer may be provided to more than one device. For example, SIP [RFC3261] defines both a \"parallel search\" and \"sequential search\". Although these are primarily signaling-level issues that are outside the scope of JSEP, they do have some impact on the configuration of the media plane that is relevant. When forking happens at the signaling layer, the JavaScript application responsible for the signaling needs to make the decisions about what media should be sent or received at any point in time, as well as which remote endpoint it should communicate with; JSEP is used to make sure the media engine can make the RTP and media perform as required by the application. The basic operations that the applications can have the media engine do are as follows:",
      "ja": "一部のコールシグナリングシステムでは、SDPオファーが複数のデバイスに提供される可能性があるさまざまなタイプの分岐が可能です。たとえば、SIP [RFC3261]は、「並列検索」と「順次検索」の両方を定義します。これらは主にJSEPの範囲外のシグナリングレベルの問題ですが、関連するメディアプレーンの構成にある程度の影響を及ぼします。シグナリングレイヤーでフォークが発生した場合、シグナリングを担当するJavaScriptアプリケーションは、任意の時点で送信または受信するメディアと、通信するリモートエンドポイントを決定する必要があります。JSEPは、メディアエンジンがアプリケーションの要求に応じてRTPとメディアを実行できるようにするために使用されます。アプリケーションがメディアエンジンに実行できる基本的な操作は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Start exchanging media with a given remote peer, but keep all the resources reserved in the offer.",
      "ja": "* 特定のリモートピアとのメディア交換を開始しますが、すべてのリソースをオファーで予約したままにします。"
    },
    {
      "indent": 3,
      "text": "* Start exchanging media with a given remote peer, and free any resources in the offer that are not being used.",
      "ja": "* 特定のリモートピアとのメディア交換を開始し、使用されていないオファー内のリソースを解放します。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Sequential Forking",
      "section_title": true,
      "ja": "3.8.1. シーケンシャルフォーク"
    },
    {
      "indent": 3,
      "text": "Sequential forking involves a call being dispatched to multiple remote callees, where each callee can accept the call, but only one active session ever exists at a time; no mixing of received media is performed.",
      "ja": "シーケンシャルフォークでは、複数のリモート呼び出し先にコールがディスパッチされます。各呼び出し先はコールを受け入れることができますが、アクティブなセッションは一度に1つしか存在しません。受信したメディアのミキシングは実行されません。"
    },
    {
      "indent": 3,
      "text": "JSEP handles sequential forking well, allowing the application to easily control the policy for selecting the desired remote endpoint. When an answer arrives from one of the callees, the application can choose to apply it as either (1) a provisional answer, leaving open the possibility of using a different answer in the future or (2) a final answer, ending the setup flow.",
      "ja": "JSEPはシーケンシャルフォークを適切に処理するため、アプリケーションは目的のリモートエンドポイントを選択するためのポリシーを簡単に制御できます。呼び出し先の1人から回答が到着すると、アプリケーションはそれを（1）暫定的な回答として適用し、将来別の回答を使用する可能性を残しておくか、（2）最終的な回答としてセットアップフローを終了するかを選択できます。。"
    },
    {
      "indent": 3,
      "text": "In a \"first-one-wins\" situation, the first answer will be applied as a final answer, and the application will reject any subsequent answers. In SIP parlance, this would be ACK + BYE.",
      "ja": "「first-one-wins」の状況では、最初の回答が最終回答として適用され、アプリケーションはそれ以降の回答を拒否します。SIP用語では、これはACKBYEになります。"
    },
    {
      "indent": 3,
      "text": "In a \"last-one-wins\" situation, all answers would be applied as provisional answers, and any previous call leg will be terminated. At some point, the application will end the setup process, perhaps with a timer; at this point, the application could reapply the pending remote description as a final answer.",
      "ja": "「ラストワンウィン」の状況では、すべての回答が暫定回答として適用され、以前のコールレッグはすべて終了します。ある時点で、アプリケーションはおそらくタイマーを使用してセットアッププロセスを終了します。この時点で、アプリケーションは保留中のリモート記述を最終的な回答として再適用できます。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Parallel Forking",
      "section_title": true,
      "ja": "3.8.2. パラレルフォーク"
    },
    {
      "indent": 3,
      "text": "Parallel forking involves a call being dispatched to multiple remote callees, where each callee can accept the call and multiple simultaneous active signaling sessions can be established as a result. If multiple callees send media at the same time, the possibilities for handling this are described in [RFC3960], Section 3.1. Most SIP devices today only support exchanging media with a single device at a time and do not try to mix multiple early media audio sources, as that could result in a confusing situation. For example, consider having a European ringback tone mixed together with the North American ringback tone -- the resulting sound would not be like either tone and would confuse the user. If the signaling application wishes to only exchange media with one of the remote endpoints at a time, then from a media engine point of view, this is exactly like the sequential forking case.",
      "ja": "並列フォークでは、複数のリモート呼び出し先にコールがディスパッチされ、各呼び出し先がコールを受け入れることができ、その結果、複数のアクティブなシグナリングセッションを同時に確立できます。複数の呼び出し先が同時にメディアを送信する場合、これを処理する可能性については、[RFC3960]のセクション3.1で説明されています。今日のほとんどのSIPデバイスは、一度に1つのデバイスとのメディア交換のみをサポートし、混乱を招く可能性があるため、複数の初期メディアオーディオソースをミキシングしようとはしません。たとえば、ヨーロッパのリングバックトーンを北米のリングバックトーンと混合することを検討してください。結果として得られるサウンドはどちらのトーンにも似ておらず、ユーザーを混乱させます。シグナリングアプリケーションが一度に1つのリモートエンドポイントとのみメディアを交換したい場合、メディアエンジンの観点からは、これはシーケンシャルフォークの場合とまったく同じです。"
    },
    {
      "indent": 3,
      "text": "In the parallel forking case where the JavaScript application wishes to simultaneously exchange media with multiple peers, the flow is slightly more complex, but the JavaScript application can follow the strategy that [RFC3960] describes, using UPDATE. The UPDATE approach allows the signaling to set up a separate media flow for each peer that it wishes to exchange media with. In JSEP, this offer used in the UPDATE would be formed by simply creating a new PeerConnection (see Section 4.1) and making sure that the same local media streams have been added into this new PeerConnection. Then the new PeerConnection object would produce an SDP offer that could be used by the signaling to perform the UPDATE strategy discussed in [RFC3960].",
      "ja": "JavaScriptアプリケーションが複数のピアと同時にメディアを交換したい並列フォークの場合、フローは少し複雑ですが、JavaScriptアプリケーションはUPDATEを使用して[RFC3960]が説明する戦略に従うことができます。UPDATEアプローチにより、シグナリングは、メディアを交換するピアごとに個別のメディアフローを設定できます。JSEPでは、UPDATEで使用されるこのオファーは、新しいPeerConnectionを作成し（セクション4.1を参照）、同じローカルメディアストリームがこの新しいPeerConnectionに追加されていることを確認するだけで形成されます。次に、新しいPeerConnectionオブジェクトは、[RFC3960]で説明されているUPDATE戦略を実行するためにシグナリングで使用できるSDPオファーを生成します。"
    },
    {
      "indent": 3,
      "text": "As a result of sharing the media streams, the application will end up with N parallel PeerConnection sessions, each with a local and remote description and their own local and remote addresses. The media flow from these sessions can be managed using setDirection (see Section 4.2.3), or the application can choose to play out the media from all sessions mixed together. Of course, if the application wants to only keep a single session, it can simply terminate the sessions that it no longer needs.",
      "ja": "メディアストリームを共有した結果、アプリケーションはN個の並列PeerConnectionセッションになり、それぞれにローカルとリモートの説明、および独自のローカルアドレスとリモートアドレスが含まれます。これらのセッションからのメディアフローは、setDirection（セクション4.2.3を参照）を使用して管理できます。または、アプリケーションは、一緒に混合されたすべてのセッションからメディアを再生することを選択できます。もちろん、アプリケーションが単一のセッションのみを保持したい場合は、不要になったセッションを単に終了することができます。"
    },
    {
      "indent": 0,
      "text": "4. Interface",
      "section_title": true,
      "ja": "4. インターフェース"
    },
    {
      "indent": 3,
      "text": "This section details the basic operations that must be present to implement JSEP functionality. The actual API exposed in the W3C API may have somewhat different syntax but should map easily to these concepts.",
      "ja": "このセクションでは、JSEP機能を実装するために存在しなければならない基本的な操作について詳しく説明します。W3C APIで公開されている実際のAPIの構文は多少異なる場合がありますが、これらの概念に簡単にマッピングできるはずです。"
    },
    {
      "indent": 0,
      "text": "4.1. PeerConnection",
      "section_title": true,
      "ja": "4.1. PeerConnection"
    },
    {
      "indent": 0,
      "text": "4.1.1. Constructor",
      "section_title": true,
      "ja": "4.1.1. コンストラクタ"
    },
    {
      "indent": 3,
      "text": "The PeerConnection constructor allows the application to specify global parameters for the media session, such as the STUN/TURN servers and credentials to use when gathering candidates, as well as the initial ICE candidate policy and pool size, and also the bundle policy to use.",
      "ja": "PeerConnectionコンストラクターを使用すると、アプリケーションは、候補を収集するときに使用するSTUN / TURNサーバーと資格情報、初期ICE候補ポリシーとプールサイズ、使用するバンドルポリシーなど、メディアセッションのグローバルパラメーターを指定できます。"
    },
    {
      "indent": 3,
      "text": "If an ICE candidate policy is specified, it functions as described in Section 3.5.3, causing the JSEP implementation to only surface the permitted candidates (including any implementation-internal filtering) to the application and only use those candidates for connectivity checks. The set of available policies is as follows:",
      "ja": "ICE候補ポリシーが指定されている場合、セクション3.5.3で説明されているように機能し、JSEP実装は、許可された候補（実装内部フィルタリングを含む）のみをアプリケーションに表示し、それらの候補のみを接続チェックに使用します。使用可能なポリシーのセットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "all: All candidates permitted by implementation policy will be gathered and used.",
      "ja": "all：実装ポリシーで許可されているすべての候補者が収集されて使用されます。"
    },
    {
      "indent": 3,
      "text": "relay: All candidates except relay candidates will be filtered out. This obfuscates the location information that might be ascertained by the remote peer from the received candidates. Depending on how the application deploys and chooses relay servers, this could obfuscate location to a metro or possibly even global level.",
      "ja": "リレー：リレー候補を除くすべての候補が除外されます。これにより、受信した候補からリモートピアによって確認される可能性のある位置情報がわかりにくくなります。アプリケーションがリレーサーバーを展開および選択する方法によっては、これにより場所がメトロレベルまたは場合によってはグローバルレベルにまでわかりにくくなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The default ICE candidate policy MUST be set to \"all\", as this is generally the desired policy and also typically reduces the use of application TURN server resources significantly.",
      "ja": "デフォルトのICE候補ポリシーは「all」に設定する必要があります。これは一般的に望ましいポリシーであり、通常、アプリケーションのTURNサーバーリソースの使用を大幅に削減するためです。"
    },
    {
      "indent": 3,
      "text": "If a size is specified for the ICE candidate pool, this indicates the number of ICE components to pre-gather candidates for. Because pre-gathering results in utilizing STUN/TURN server resources for potentially long periods of time, this MUST only occur upon application request, and therefore the default candidate pool size MUST be zero.",
      "ja": "ICE候補プールにサイズが指定されている場合、これは候補を事前に収集するICEコンポーネントの数を示します。事前収集の結果、STUN / TURNサーバーリソースが長期間使用される可能性があるため、これはアプリケーション要求時にのみ発生する必要があります。したがって、デフォルトの候補プールサイズはゼロである必要があります。"
    },
    {
      "indent": 3,
      "text": "The application can specify its preferred policy regarding use of bundle, the multiplexing mechanism defined in [RFC8843]. Regardless of policy, the application will always try to negotiate bundle onto a single transport and will offer a single bundle group across all \"m=\" sections; use of this single transport is contingent upon the answerer accepting bundle. However, by specifying a policy from the list below, the application can control exactly how aggressively it will try to bundle media streams together, which affects how it will interoperate with a non-bundle-aware endpoint. When negotiating with a non-bundle-aware endpoint, only the streams not marked as bundle-only streams will be established.",
      "ja": "アプリケーションは、[RFC8843]で定義されている多重化メカニズムであるバンドルの使用に関する優先ポリシーを指定できます。ポリシーに関係なく、アプリケーションは常にバンドルを単一のトランスポートにネゴシエートしようとし、すべての「m =」セクションに単一のバンドルグループを提供します。この単一のトランスポートの使用は、アンサーがバンドルを受け入れることを条件とします。ただし、以下のリストからポリシーを指定することにより、アプリケーションはメディアストリームをバンドルしようとする積極的な方法を正確に制御できます。これは、バンドルに対応していないエンドポイントとの相互運用方法に影響します。バンドルに対応していないエンドポイントとネゴシエートする場合、バンドルのみのストリームとしてマークされていないストリームのみが確立されます。"
    },
    {
      "indent": 3,
      "text": "The set of available policies is as follows:",
      "ja": "使用可能なポリシーのセットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "balanced: The first \"m=\" section of each type (audio, video, or application) will contain transport parameters, which will allow an answerer to unbundle that section. The second and any subsequent \"m=\" sections of each type will be marked bundle-only. The result is that if there are N distinct media types, then candidates will be gathered for N media streams. This policy balances desire to multiplex with the need to ensure that basic audio and video can still be negotiated in legacy cases. When acting as answerer, if there is no bundle group in the offer, the implementation will reject all but the first \"m=\" section of each type.",
      "ja": "バランス：各タイプ（オーディオ、ビデオ、またはアプリケーション）の最初の「m =」セクションにはトランスポートパラメーターが含まれ、回答者がそのセクションをバンドル解除できるようにします。各タイプの2番目以降の「m =」セクションは、バンドルのみとしてマークされます。その結果、N個の異なるメディアタイプがある場合、N個のメディアストリームの候補が収集されます。このポリシーは、マルチプレックスへの要望と、従来のケースでも基本的なオーディオとビデオをネゴシエートできるようにする必要性とのバランスを取ります。回答者として機能するときに、オファーにバンドルグループがない場合、実装は各タイプの最初の「m =」セクションを除くすべてを拒否します。"
    },
    {
      "indent": 3,
      "text": "max-compat: All \"m=\" sections will contain transport parameters; none will be marked as bundle-only. This policy will allow all streams to be received by non-bundle-aware endpoints but will require separate candidates to be gathered for each media stream.",
      "ja": "max-compat：すべての「m =」セクションにはトランスポートパラメータが含まれます。バンドルのみとしてマークされるものはありません。このポリシーでは、バンドルを認識しないエンドポイントがすべてのストリームを受信できるようにしますが、メディアストリームごとに個別の候補を収集する必要があります。"
    },
    {
      "indent": 3,
      "text": "max-bundle: Only the first \"m=\" section will contain transport parameters; all streams other than the first will be marked as bundle-only. This policy aims to minimize candidate gathering and maximize multiplexing, at the cost of less compatibility with legacy endpoints. When acting as answerer, the implementation will reject any \"m=\" sections other than the first \"m=\" section, unless they are in the same bundle group as that \"m=\" section.",
      "ja": "max-bundle：最初の「m =」セクションのみにトランスポートパラメータが含まれます。最初のストリーム以外のすべてのストリームは、バンドルのみとしてマークされます。このポリシーは、レガシーエンドポイントとの互換性を低下させながら、候補の収集を最小限に抑え、多重化を最大化することを目的としています。回答者として機能する場合、実装は、最初の「m =」セクション以外の「m =」セクションが「m =」セクションと同じバンドルグループにない限り、それらを拒否します。"
    },
    {
      "indent": 3,
      "text": "As it provides the best trade-off between performance and compatibility with legacy endpoints, the default bundle policy MUST be set to \"balanced\".",
      "ja": "パフォーマンスとレガシーエンドポイントとの互換性の間で最良のトレードオフを提供するため、デフォルトのバンドルポリシーを「バランス」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The application can specify its preferred policy regarding use of RTP/RTCP multiplexing [RFC5761] using one of the following policies:",
      "ja": "アプリケーションは、次のいずれかのポリシーを使用して、RTP / RTCP多重化[RFC5761]の使用に関する優先ポリシーを指定できます。"
    },
    {
      "indent": 3,
      "text": "negotiate: The JSEP implementation will gather both RTP and RTCP candidates but also will offer \"a=rtcp-mux\", thus allowing for compatibility with either multiplexing or non-multiplexing endpoints.",
      "ja": "ネゴシエート：JSEP実装は、RTPとRTCPの両方の候補を収集しますが、「a = rtcp-mux」も提供するため、多重化または非多重化エンドポイントとの互換性が可能になります。"
    },
    {
      "indent": 3,
      "text": "require: The JSEP implementation will only gather RTP candidates and will insert an \"a=rtcp-mux-only\" indication into any new \"m=\" sections in offers it generates. This halves the number of candidates that the offerer needs to gather. Applying a description with an \"m=\" section that does not contain an \"a=rtcp-mux\" attribute will cause an error to be returned.",
      "ja": "require：JSEP実装はRTP候補のみを収集し、生成するオファーの新しい「m =」セクションに「a = rtcp-mux-only」指示を挿入します。これにより、提供者が収集する必要のある候補者の数が半分になります。「a = rtcp-mux」属性を含まない「m =」セクションを含む説明を適用すると、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "The default multiplexing policy MUST be set to \"require\". Implementations MAY choose to reject attempts by the application to set the multiplexing policy to \"negotiate\".",
      "ja": "デフォルトの多重化ポリシーは「require」に設定する必要があります。実装は、多重化ポリシーを「ネゴシエート」に設定するアプリケーションによる試行を拒否することを選択できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "4.1.2. addTrack",
      "section_title": true,
      "ja": "4.1.2. addTrack"
    },
    {
      "indent": 3,
      "text": "The addTrack method adds a MediaStreamTrack to the PeerConnection, using the MediaStream argument to associate the track with other tracks in the same MediaStream, so that they can be added to the same \"LS\" (Lip Synchronization) group when creating an offer or answer. Adding tracks to the same \"LS\" group indicates that the playback of these tracks should be synchronized for proper lip sync, as described in [RFC5888], Section 7. addTrack attempts to minimize the number of transceivers as follows: if the PeerConnection is in the \"have-remote-offer\" state, the track will be attached to the first compatible transceiver that was created by the most recent call to setRemoteDescription and does not have a local track. Otherwise, a new transceiver will be created, as described in Section 4.1.4.",
      "ja": "addTrackメソッドはMediaStreamTrackをPeerConnectionに追加し、MediaStream引数を使用してトラックを同じMediaStream内の他のトラックに関連付け、オファーまたはアンサーを作成するときに同じ「LS」（リップシンク）グループに追加できるようにします。同じ「LS」グループにトラックを追加すると、[RFC5888]のセクション7で説明されているように、これらのトラックの再生を同期して適切なリップシンクを行う必要があることを示します。addTrackは、次のようにトランシーバーの数を最小限に抑えようとします。「have-remote-offer」状態の場合、トラックは、setRemoteDescriptionへの最新の呼び出しによって作成され、ローカルトラックを持たない最初の互換性のあるトランシーバーに接続されます。それ以外の場合は、セクション4.1.4で説明されているように、新しいトランシーバーが作成されます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. removeTrack",
      "section_title": true,
      "ja": "4.1.3. removeTrack"
    },
    {
      "indent": 3,
      "text": "The removeTrack method removes a MediaStreamTrack from the PeerConnection, using the RtpSender argument to indicate which sender should have its track removed. The sender's track is cleared, and the sender stops sending. Future calls to createOffer will mark the \"m=\" section associated with the sender as recvonly (if transceiver.direction is sendrecv) or as inactive (if transceiver.direction is sendonly).",
      "ja": "removeTrackメソッドは、RtpSender引数を使用してPeerConnectionからMediaStreamTrackを削除し、トラックを削除する必要がある送信者を示します。送信者のトラックがクリアされ、送信者は送信を停止します。createOfferを今後呼び出すと、送信者に関連付けられた「m =」セクションがrecvonly（transceiver.directionがsendrecvの場合）または非アクティブ（transceiver.directionがsendonlyの場合）としてマークされます。"
    },
    {
      "indent": 0,
      "text": "4.1.4. addTransceiver",
      "section_title": true,
      "ja": "4.1.4. addTransceiver"
    },
    {
      "indent": 3,
      "text": "The addTransceiver method adds a new RtpTransceiver to the PeerConnection. If a MediaStreamTrack argument is provided, then the transceiver will be configured with that media type and the track will be attached to the transceiver. Otherwise, the application MUST explicitly specify the type; this mode is useful for creating recvonly transceivers as well as for creating transceivers to which a track can be attached at some later point.",
      "ja": "addTransceiverメソッドは、新しいRtpTransceiverをPeerConnectionに追加します。MediaStreamTrack引数が指定されている場合、トランシーバーはそのメディアタイプで構成され、トラックはトランシーバーに接続されます。それ以外の場合、アプリケーションはタイプを明示的に指定する必要があります。このモードは、recvonlyトランシーバーを作成する場合や、後でトラックを接続できるトランシーバーを作成する場合に役立ちます。"
    },
    {
      "indent": 3,
      "text": "At the time of creation, the application can also specify a transceiver direction attribute, a set of MediaStreams that the transceiver is associated with (allowing \"LS\" group assignments), and a set of encodings for the media (used for simulcast as described in Section 3.7).",
      "ja": "作成時に、アプリケーションは、トランシーバーの方向属性、トランシーバーが関連付けられているMediaStreamのセット（「LS」グループの割り当てを許可）、およびメディアのエンコーディングのセット（で説明されているようにサイマルキャストに使用）を指定することもできます。セクション3.7）。"
    },
    {
      "indent": 0,
      "text": "4.1.5. onaddtrack Event",
      "section_title": true,
      "ja": "4.1.5. onaddtrackイベント"
    },
    {
      "indent": 3,
      "text": "The onaddtrack event is dispatched to the application when a new remote track has been signaled as a result of a setRemoteDescription call. The new track is supplied as a MediaStreamTrack object in the event, along with the MediaStream(s) the track is part of.",
      "ja": "onaddtrackイベントは、setRemoteDescription呼び出しの結果として新しいリモートトラックが通知されたときにアプリケーションにディスパッチされます。新しいトラックは、トラックが含まれているMediaStreamとともに、イベントのMediaStreamTrackオブジェクトとして提供されます。"
    },
    {
      "indent": 0,
      "text": "4.1.6. createDataChannel",
      "section_title": true,
      "ja": "4.1.6. createDataChannel"
    },
    {
      "indent": 3,
      "text": "The createDataChannel method creates a new data channel and attaches it to the PeerConnection. If no data channel currently exists for this PeerConnection, then a new offer/answer exchange is required. All data channels on a given PeerConnection share the same SCTP/DTLS association (\"SCTP\" stands for \"Stream Control Transmission Protocol\") and therefore the same \"m=\" section, so subsequent creation of data channels does not have any impact on the JSEP state.",
      "ja": "createDataChannelメソッドは、新しいデータチャネルを作成し、それをPeerConnectionに接続します。このPeerConnectionのデータチャネルが現在存在しない場合は、新しいオファー/アンサー交換が必要です。特定のPeerConnection上のすべてのデータチャネルは同じSCTP / DTLSアソシエーション（「SCTP」は「StreamControl Transmission Protocol」の略）を共有するため、同じ「m =」セクションを共有するため、その後のデータチャネルの作成はJSEP状態。"
    },
    {
      "indent": 3,
      "text": "The createDataChannel method also includes a number of arguments that are used by the PeerConnection (e.g., maxPacketLifetime) but are not reflected in the SDP and do not affect the JSEP state.",
      "ja": "createDataChannelメソッドには、PeerConnectionで使用される引数（maxPacketLifetimeなど）もいくつか含まれていますが、SDPには反映されず、JSEPの状態には影響しません。"
    },
    {
      "indent": 0,
      "text": "4.1.7. ondatachannel Event",
      "section_title": true,
      "ja": "4.1.7. ondatachannelイベント"
    },
    {
      "indent": 3,
      "text": "The ondatachannel event is dispatched to the application when a new data channel has been negotiated by the remote side, which can occur at any time after the underlying SCTP/DTLS association has been established. The new data channel object is supplied in the event.",
      "ja": "ondatachannelイベントは、新しいデータチャネルがリモート側によってネゴシエートされたときにアプリケーションにディスパッチされます。これは、基になるSCTP / DTLSアソシエーションが確立された後いつでも発生する可能性があります。新しいデータチャネルオブジェクトがイベントで提供されます。"
    },
    {
      "indent": 0,
      "text": "4.1.8. createOffer",
      "section_title": true,
      "ja": "4.1.8. createOffer"
    },
    {
      "indent": 3,
      "text": "The createOffer method generates a blob of SDP that contains an offer per [RFC3264] with the supported configurations for the session, including descriptions of the media added to this PeerConnection, the codec, RTP, and RTCP options supported by this implementation, and any candidates that have been gathered by the ICE agent. An options parameter may be supplied to provide additional control over the generated offer. This options parameter allows an application to trigger an ICE restart, for the purpose of reestablishing connectivity.",
      "ja": "createOfferメソッドは、[RFC3264]ごとに、このPeerConnectionに追加されたメディアの説明、この実装でサポートされているコーデック、RTP、RTCPオプション、および候補を含む、セッションでサポートされている構成を含むオファーを含むSDPのblobを生成します。ICEエージェントによって収集されたもの。生成されたオファーをさらに制御するために、オプションパラメータを指定できます。このオプションパラメータを使用すると、接続を再確立する目的で、アプリケーションがICEの再起動をトリガーできます。"
    },
    {
      "indent": 3,
      "text": "In the initial offer, the generated SDP will contain all desired functionality for the session (functionality that is supported but not desired by default may be omitted); for each SDP line, the generation of the SDP will follow the process defined for generating an initial offer from the specification that defines the given SDP line. The exact handling of initial offer generation is detailed in Section 5.2.1 below.",
      "ja": "最初のオファーでは、生成されたSDPには、セッションに必要なすべての機能が含まれます（サポートされているが、デフォルトでは不要な機能は省略できます）。SDPラインごとに、SDPの生成は、指定されたSDPラインを定義する仕様から初期オファーを生成するために定義されたプロセスに従います。最初のオファー生成の正確な処理については、以下のセクション5.2.1で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "In the event createOffer is called after the session is established, createOffer will generate an offer to modify the current session based on any changes that have been made to the session, e.g., adding or stopping RtpTransceivers, or requesting an ICE restart. For each existing stream, the generation of each SDP line MUST follow the process defined for generating an updated offer from the RFC that specifies the given SDP line. For each new stream, the generation of the SDP MUST follow the process of generating an initial offer, as mentioned above. If no changes have been made, or for SDP lines that are unaffected by the requested changes, the offer will only contain the parameters negotiated by the last offer/answer exchange. The exact handling of subsequent offer generation is detailed in Section 5.2.2 below.",
      "ja": "セッションの確立後にcreateOfferが呼び出された場合、createOfferは、RtpTransceiversの追加や停止、ICEの再起動の要求など、セッションに加えられた変更に基づいて現在のセッションを変更するオファーを生成します。既存のストリームごとに、各SDPラインの生成は、指定されたSDPラインを指定するRFCから更新されたオファーを生成するために定義されたプロセスに従う必要があります。SDPの生成は、前述のように、新しいストリームごとに、最初のオファーを生成するプロセスに従う必要があります。変更が行われていない場合、または要求された変更の影響を受けないSDP回線の場合、オファーには、最後のオファー/アンサー交換によってネゴシエートされたパラメーターのみが含まれます。その後のオファー生成の正確な処理については、以下のセクション5.2.2で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Session descriptions generated by createOffer MUST be immediately usable by setLocalDescription; if a system has limited resources (e.g., a finite number of decoders), createOffer SHOULD return an offer that reflects the current state of the system, so that setLocalDescription will succeed when it attempts to acquire those resources.",
      "ja": "createOfferによって生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります。システムのリソースが限られている場合（たとえば、デコーダーの数が限られている場合）、createOfferはシステムの現在の状態を反映するオファーを返す必要があります。これにより、setLocalDescriptionはそれらのリソースを取得しようとしたときに成功します。"
    },
    {
      "indent": 3,
      "text": "Calling this method may do things such as generating new ICE credentials, but it does not change the PeerConnection state, trigger candidate gathering, or cause media to start or stop flowing. Specifically, the offer is not applied, and does not become the pending local description, until setLocalDescription is called.",
      "ja": "このメソッドを呼び出すと、新しいICE資格情報の生成などが行われる場合がありますが、PeerConnectionの状態が変更されたり、候補の収集がトリガーされたり、メディアのフローが開始または停止したりすることはありません。具体的には、setLocalDescriptionが呼び出されるまで、オファーは適用されず、保留中のローカル記述にはなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.9. createAnswer",
      "section_title": true,
      "ja": "4.1.9. createAnswer"
    },
    {
      "indent": 3,
      "text": "The createAnswer method generates a blob of SDP that contains an SDP answer per [RFC3264] with the supported configuration for the session that is compatible with the parameters supplied in the most recent call to setRemoteDescription; setRemoteDescription MUST have been called prior to calling createAnswer. Like createOffer, the returned blob contains descriptions of the media added to this PeerConnection, the codec/RTP/RTCP options negotiated for this session, and any candidates that have been gathered by the ICE agent. An options parameter may be supplied to provide additional control over the generated answer.",
      "ja": "createAnswerメソッドは、setRemoteDescriptionへの最新の呼び出しで提供されたパラメーターと互換性のあるセッションでサポートされている構成で[RFC3264]ごとのSDP回答を含むSDPのblobを生成します。createAnswerを呼び出す前に、setRemoteDescriptionを呼び出す必要があります。createOfferと同様に、返されるblobには、このPeerConnectionに追加されたメディアの説明、このセッションでネゴシエートされたコーデック/ RTP / RTCPオプション、およびICEエージェントによって収集された候補が含まれます。生成された回答をさらに制御するために、オプションパラメータを指定できます。"
    },
    {
      "indent": 3,
      "text": "As an answer, the generated SDP will contain a specific configuration that specifies how the media plane should be established; for each SDP line, the generation of the SDP MUST follow the process defined for generating an answer from the specification that defines the given SDP line. The exact handling of answer generation is detailed in Section 5.3 below.",
      "ja": "答えとして、生成されたSDPには、メディアプレーンを確立する方法を指定する特定の構成が含まれます。SDPラインごとに、SDPの生成は、指定されたSDPラインを定義する仕様から回答を生成するために定義されたプロセスに従う必要があります。回答生成の正確な処理については、以下のセクション5.3で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Session descriptions generated by createAnswer MUST be immediately usable by setLocalDescription; like createOffer, the returned description SHOULD reflect the current state of the system.",
      "ja": "createAnswerによって生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります。createOfferと同様に、返される説明はシステムの現在の状態を反映する必要があります。"
    },
    {
      "indent": 3,
      "text": "Calling this method may do things such as generating new ICE credentials, but it does not change the PeerConnection state, trigger candidate gathering, or cause a media state change. Specifically, the answer is not applied, and does not become the current local description, until setLocalDescription is called.",
      "ja": "このメソッドを呼び出すと、新しいICE資格情報の生成などが行われる場合がありますが、PeerConnectionの状態が変更されたり、候補の収集がトリガーされたり、メディアの状態が変更されたりすることはありません。具体的には、setLocalDescriptionが呼び出されるまで、回答は適用されず、現在のローカルの説明にはなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.10. SessionDescriptionType",
      "section_title": true,
      "ja": "4.1.10. SessionDescriptionType"
    },
    {
      "indent": 3,
      "text": "Session description objects (RTCSessionDescription) may be of type \"offer\", \"pranswer\", \"answer\", or \"rollback\". These types provide information as to how the description parameter should be parsed and how the media state should be changed.",
      "ja": "セッション記述オブジェクト（RTCSessionDescription）は、「offer」、「pranswer」、「answer」、または「rollback」タイプの場合があります。これらのタイプは、descriptionパラメーターを解析する方法とメディアの状態を変更する方法に関する情報を提供します。"
    },
    {
      "indent": 3,
      "text": "\"offer\" indicates that a description MUST be parsed as an offer; said description may include many possible media configurations. A description used as an \"offer\" may be applied any time the PeerConnection is in a \"stable\" state or applied as an update to a previously supplied but unanswered \"offer\".",
      "ja": "「オファー」は、説明をオファーとして解析する必要があることを示します。上記の説明は、多くの可能なメディア構成を含み得る。「オファー」として使用される説明は、PeerConnectionが「安定」状態にあるときはいつでも適用できます。または、以前に提供されたが未回答の「オファー」の更新として適用できます。"
    },
    {
      "indent": 3,
      "text": "\"pranswer\" indicates that a description MUST be parsed as an answer, but not a final answer, and so MUST NOT result in the freeing of allocated resources. It may result in the start of media transmission, if the answer does not specify an inactive media direction. A description used as a \"pranswer\" may be applied as a response to an \"offer\" or as an update to a previously sent \"pranswer\".",
      "ja": "「pranswer」は、説明を回答として解析する必要があるが、最終的な回答として解析する必要がないことを示します。したがって、割り当てられたリソースが解放されてはなりません。回答で非アクティブなメディアの方向が指定されていない場合、メディア送信が開始される可能性があります。「pranswer」として使用される説明は、「offer」への応答として、または以前に送信された「pranswer」への更新として適用できます。"
    },
    {
      "indent": 3,
      "text": "\"answer\" indicates that a description MUST be parsed as an answer, the offer/answer exchange MUST be considered complete, and any resources (decoders, candidates) that are no longer needed SHOULD be released. A description used as an \"answer\" may be applied as a response to an \"offer\" or as an update to a previously sent \"pranswer\".",
      "ja": "「回答」は、説明を回答として解析する必要があり、オファー/回答の交換が完了したと見なす必要があり、不要になったリソース（デコーダー、候補）を解放する必要があることを示します。「回答」として使用される説明は、「オファー」への応答として、または以前に送信された「pranswer」への更新として適用される場合があります。"
    },
    {
      "indent": 3,
      "text": "The only difference between a provisional and final answer is that the final answer results in the freeing of any unused resources that were allocated as a result of the offer. As such, the application can use some discretion on whether an answer should be applied as provisional or final and can change the type of the session description as needed. For example, in a serial forking scenario, an application may receive multiple \"final\" answers, one from each remote endpoint. The application could choose to accept the initial answers as provisional answers and only apply an answer as final when it receives one that meets its criteria (e.g., a live user instead of voicemail).",
      "ja": "暫定回答と最終回答の唯一の違いは、最終回答により、オファーの結果として割り当てられた未使用のリソースが解放されることです。そのため、アプリケーションは、回答を暫定として適用するか最終として適用するかについてある程度の裁量を使用し、必要に応じてセッションの説明のタイプを変更できます。たとえば、シリアルフォークのシナリオでは、アプリケーションは、各リモートエンドポイントから1つずつ、複数の「最終的な」回答を受け取る場合があります。アプリケーションは、最初の回答を暫定的な回答として受け入れ、基準を満たす回答を受け取った場合にのみ最終的な回答として適用することを選択できます（たとえば、ボイスメールではなくライブユーザー）。"
    },
    {
      "indent": 3,
      "text": "\"rollback\" is a special session description type indicating that the state machine MUST be rolled back to the previous \"stable\" state, as described in Section 4.1.10.2. The contents MUST be empty.",
      "ja": "「ロールバック」は、セクション4.1.10.2で説明されているように、ステートマシンを以前の「安定した」状態にロールバックする必要があることを示す特別なセッション記述タイプです。内容は空でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.10.1. Use of Provisional Answers",
      "section_title": true,
      "ja": "4.1.10.1. 暫定回答の使用"
    },
    {
      "indent": 3,
      "text": "Most applications will not need to create answers using the \"pranswer\" type. While it is good practice to send an immediate response to an offer, in order to warm up the session transport and prevent media clipping, the preferred handling for a JSEP application is to create and send a \"sendonly\" final answer with a null MediaStreamTrack immediately after receiving the offer, which will prevent media from being sent by the caller and allow media to be sent immediately upon answer by the callee. Later, when the callee actually accepts the call, the application can plug in the real MediaStreamTrack and create a new \"sendrecv\" offer to update the previous offer/answer pair and start bidirectional media flow. While this could also be done with a \"sendonly\" pranswer followed by a \"sendrecv\" answer, the initial pranswer leaves the offer/answer exchange open, which means that the caller cannot send an updated offer during this time.",
      "ja": "ほとんどのアプリケーションは、「pranswer」タイプを使用して回答を作成する必要はありません。オファーへの即時応答を送信することは良い習慣ですが、セッショントランスポートをウォームアップし、メディアクリッピングを防ぐために、JSEPアプリケーションの推奨される処理は、nullMediaStreamTrackを使用して「送信専用」の最終応答を作成して送信することです。オファーを受信した後。これにより、発信者がメディアを送信できなくなり、着信者が応答するとすぐにメディアを送信できるようになります。後で、呼び出し先が実際に呼び出しを受け入れると、アプリケーションは実際のMediaStreamTrackをプラグインし、新しい「sendrecv」オファーを作成して、前のオファーと応答のペアを更新し、双方向のメディアフローを開始できます。これは、「sendonly」pranswerの後に「sendrecv」回答を続けることでも実行できますが、最初のpranswerはオファー/アンサー交換を開いたままにします。つまり、この間、発信者は更新されたオファーを送信できません。"
    },
    {
      "indent": 3,
      "text": "As an example, consider a typical JSEP application that wants to set up audio and video as quickly as possible. When the callee receives an offer with audio and video MediaStreamTracks, it will send an immediate answer accepting these tracks as sendonly (meaning that the caller will not send the callee any media yet, and because the callee has not yet added its own MediaStreamTracks, the callee will not send any media either). It will then ask the user to accept the call and acquire the needed local tracks. Upon acceptance by the user, the application will plug in the tracks it has acquired, which, because ICE handshaking and DTLS handshaking have likely completed by this point, can start transmitting immediately. The application will also send a new offer to the remote side indicating call acceptance and moving the audio and video to be two-way media. A detailed example flow along these lines is shown in Section 7.3.",
      "ja": "例として、オーディオとビデオをできるだけ早くセットアップしたい典型的なJSEPアプリケーションを考えてみましょう。呼び出し先がオーディオとビデオのMediaStreamTracksでオファーを受信すると、これらのトラックをsendonlyとして受け入れる即時応答を送信します（つまり、呼び出し元はまだ呼び出し先にメディアを送信せず、呼び出し先はまだ独自のMediaStreamTracksを追加していないため、呼び出し先もメディアを送信しません）。次に、ユーザーに通話を受け入れて必要なローカルトラックを取得するように求めます。ユーザーが受け入れると、アプリケーションは取得したトラックをプラグインします。これは、ICEハンドシェイクとDTLSハンドシェイクがこの時点で完了している可能性が高いため、すぐに送信を開始できます。アプリケーションはまた、通話の受け入れを示し、オーディオとビデオを双方向メディアに移動することを示す新しいオファーをリモート側に送信します。これらの線に沿ったフローの詳細な例は、セクション7.3に示されています。"
    },
    {
      "indent": 3,
      "text": "Of course, some applications may not be able to perform this double offer/answer exchange, particularly ones that are attempting to gateway to legacy signaling protocols. In these cases, pranswer can still provide the application with a mechanism to warm up the transport.",
      "ja": "もちろん、一部のアプリケーション、特にレガシーシグナリングプロトコルへのゲートウェイを試みているアプリケーションでは、この二重のオファー/アンサー交換を実行できない場合があります。このような場合でも、pranswerは、トランスポートをウォームアップするメカニズムをアプリケーションに提供できます。"
    },
    {
      "indent": 0,
      "text": "4.1.10.2. Rollback",
      "section_title": true,
      "ja": "4.1.10.2. ロールバック"
    },
    {
      "indent": 3,
      "text": "In certain situations, it may be desirable to \"undo\" a change made to setLocalDescription or setRemoteDescription. Consider a case where a call is ongoing and one side wants to change some of the session parameters; that side generates an updated offer and then calls setLocalDescription. However, the remote side, either before or after setRemoteDescription, decides it does not want to accept the new parameters and sends a reject message back to the offerer. Now, the offerer, and possibly the answerer as well, needs to return to a \"stable\" state and the previous local/remote description. To support this, we introduce the concept of \"rollback\", which discards any proposed changes to the session, returning the state machine to the \"stable\" state. A rollback is performed by supplying a session description of type \"rollback\" with empty contents to either setLocalDescription or setRemoteDescription.",
      "ja": "特定の状況では、setLocalDescriptionまたはsetRemoteDescriptionに加えられた変更を「元に戻す」ことが望ましい場合があります。通話が進行中で、一方がセッションパラメータの一部を変更したい場合を考えてみます。その側は更新されたオファーを生成してから、setLocalDescriptionを呼び出します。ただし、リモート側は、setRemoteDescriptionの前または後のいずれかで、新しいパラメーターを受け入れたくないと判断し、拒否メッセージを提供者に送り返します。ここで、提供者、場合によっては回答者も、「安定した」状態と以前のローカル/リモートの説明に戻る必要があります。これをサポートするために、セッションに対して提案された変更を破棄し、ステートマシンを「安定した」状態に戻す「ロールバック」の概念を導入します。ロールバックは、setLocalDescriptionまたはsetRemoteDescriptionのいずれかに、内容が空の「rollback」タイプのセッション記述を提供することによって実行されます。"
    },
    {
      "indent": 0,
      "text": "4.1.11. setLocalDescription",
      "section_title": true,
      "ja": "4.1.11. setLocalDescription"
    },
    {
      "indent": 3,
      "text": "The setLocalDescription method instructs the PeerConnection to apply the supplied session description as its local configuration. The type field indicates whether the description should be processed as an offer, provisional answer, final answer, or rollback; offers and answers are checked differently, using the various rules that exist for each SDP line.",
      "ja": "setLocalDescriptionメソッドは、指定されたセッションの説明をローカル構成として適用するようにPeerConnectionに指示します。タイプフィールドは、説明をオファー、暫定回答、最終回答、またはロールバックとして処理する必要があるかどうかを示します。各SDPラインに存在するさまざまなルールを使用して、オファーとアンサーのチェック方法が異なります。"
    },
    {
      "indent": 3,
      "text": "This API changes the local media state; among other things, it sets up local resources for receiving and decoding media. In order to successfully handle scenarios where the application wants to offer to change from one media format to a different, incompatible format, the PeerConnection MUST be able to simultaneously support use of both the current and pending local descriptions (e.g., support the codecs that exist in either description). This dual processing begins when the PeerConnection enters the \"have-local-offer\" state, and it continues until setRemoteDescription is called with either (1) a final answer, at which point the PeerConnection can fully adopt the pending local description or (2) a rollback, which results in a revert to the current local description.",
      "ja": "このAPIは、ローカルメディアの状態を変更します。特に、メディアを受信およびデコードするためのローカルリソースを設定します。アプリケーションが1つのメディア形式から別の互換性のない形式への変更を提案するシナリオを正常に処理するには、PeerConnectionは、現在のローカル記述と保留中のローカル記述の両方の使用を同時にサポートできる必要があります（たとえば、存在するコーデックをサポートする）。どちらの説明でも）。この二重処理は、PeerConnectionが「have-local-offer」状態に入ると開始され、setRemoteDescriptionが（1）最終応答で呼び出されるまで続きます。最終応答で、PeerConnectionは保留中のローカル記述を完全に採用できます。ロールバック。これにより、現在のローカル記述に戻ります。"
    },
    {
      "indent": 3,
      "text": "This API indirectly controls the candidate gathering process. When a local description is supplied and the number of transports currently in use does not match the number of transports needed by the local description, the PeerConnection will create transports as needed and begin gathering candidates for each transport, using ones from the candidate pool if available.",
      "ja": "このAPIは、候補者の収集プロセスを間接的に制御します。ローカル記述が提供され、現在使用されているトランスポートの数がローカル記述に必要なトランスポートの数と一致しない場合、PeerConnectionは必要に応じてトランスポートを作成し、可能な場合は候補プールからの候補を使用して、各トランスポートの候補の収集を開始します。。"
    },
    {
      "indent": 3,
      "text": "If (1) setRemoteDescription was previously called with an offer, (2) setLocalDescription is called with an answer (provisional or final), (3) the media directions are compatible, and (4) media is available to send, this will result in the starting of media transmission.",
      "ja": "（1）setRemoteDescriptionが以前にオファーで呼び出された場合、（2）setLocalDescriptionが応答（暫定または最終）で呼び出された場合、（3）メディアの方向性に互換性があり、（4）メディアを送信できる場合、次のようになります。メディア送信の開始。"
    },
    {
      "indent": 0,
      "text": "4.1.12. setRemoteDescription",
      "section_title": true,
      "ja": "4.1.12. setRemoteDescription"
    },
    {
      "indent": 3,
      "text": "The setRemoteDescription method instructs the PeerConnection to apply the supplied session description as the desired remote configuration. As in setLocalDescription, the type field of the description indicates how it should be processed.",
      "ja": "setRemoteDescriptionメソッドは、指定されたセッションの説明を目的のリモート構成として適用するようにPeerConnectionに指示します。setLocalDescriptionと同様に、説明のタイプフィールドは、その処理方法を示します。"
    },
    {
      "indent": 3,
      "text": "This API changes the local media state; among other things, it sets up local resources for sending and encoding media.",
      "ja": "このAPIは、ローカルメディアの状態を変更します。特に、メディアを送信およびエンコードするためのローカルリソースを設定します。"
    },
    {
      "indent": 3,
      "text": "If (1) setLocalDescription was previously called with an offer, (2) setRemoteDescription is called with an answer (provisional or final), (3) the media directions are compatible, and (4) media is available to send, this will result in the starting of media transmission.",
      "ja": "（1）setLocalDescriptionが以前にオファーで呼び出された場合、（2）setRemoteDescriptionが応答（暫定または最終）で呼び出された場合、（3）メディアの方向に互換性があり、（4）メディアを送信できる場合、次のようになります。メディア送信の開始。"
    },
    {
      "indent": 0,
      "text": "4.1.13. currentLocalDescription",
      "section_title": true,
      "ja": "4.1.13. currentLocalDescription"
    },
    {
      "indent": 3,
      "text": "The currentLocalDescription method returns the current negotiated local description -- i.e., the local description from the last successful offer/answer exchange -- in addition to any local candidates that have been generated by the ICE agent since the local description was set.",
      "ja": "currentLocalDescriptionメソッドは、ローカル記述が設定されてからICEエージェントによって生成されたローカル候補に加えて、現在ネゴシエートされたローカル記述（つまり、最後に成功したオファー/アンサー交換からのローカル記述）を返します。"
    },
    {
      "indent": 3,
      "text": "A null object will be returned if an offer/answer exchange has not yet been completed.",
      "ja": "オファー/アンサー交換がまだ完了していない場合は、nullオブジェクトが返されます。"
    },
    {
      "indent": 0,
      "text": "4.1.14. pendingLocalDescription",
      "section_title": true,
      "ja": "4.1.14. 保留中のローカル説明"
    },
    {
      "indent": 3,
      "text": "The pendingLocalDescription method returns a copy of the local description currently in negotiation -- i.e., a local offer set without any corresponding remote answer -- in addition to any local candidates that have been generated by the ICE agent since the local description was set.",
      "ja": "保留中のLocalDescriptionメソッドは、ローカル記述が設定されてからICEエージェントによって生成されたローカル候補に加えて、現在ネゴシエーション中のローカル記述のコピー（つまり、対応するリモート応答のないローカルオファーセット）を返します。"
    },
    {
      "indent": 3,
      "text": "A null object will be returned if the state of the PeerConnection is \"stable\" or \"have-remote-offer\".",
      "ja": "PeerConnectionの状態が「stable」または「have-remote-offer」の場合、nullオブジェクトが返されます。"
    },
    {
      "indent": 0,
      "text": "4.1.15. currentRemoteDescription",
      "section_title": true,
      "ja": "4.1.15. currentRemoteDescription"
    },
    {
      "indent": 3,
      "text": "The currentRemoteDescription method returns a copy of the current negotiated remote description -- i.e., the remote description from the last successful offer/answer exchange -- in addition to any remote candidates that have been supplied via processIceMessage since the remote description was set.",
      "ja": "currentRemoteDescriptionメソッドは、リモートの説明が設定されてからprocessIceMessageを介して提供されたリモートの候補に加えて、現在ネゴシエートされたリモートの説明のコピー（つまり、最後に成功したオファー/アンサー交換からのリモートの説明）を返します。"
    },
    {
      "indent": 3,
      "text": "A null object will be returned if an offer/answer exchange has not yet been completed.",
      "ja": "オファー/アンサー交換がまだ完了していない場合は、nullオブジェクトが返されます。"
    },
    {
      "indent": 0,
      "text": "4.1.16. pendingRemoteDescription",
      "section_title": true,
      "ja": "4.1.16. 保留中のRemoteDescription"
    },
    {
      "indent": 3,
      "text": "The pendingRemoteDescription method returns a copy of the remote description currently in negotiation -- i.e., a remote offer set without any corresponding local answer -- in addition to any remote candidates that have been supplied via processIceMessage since the remote description was set.",
      "ja": "保留中のRemoteDescriptionメソッドは、リモート記述が設定されてからprocessIceMessageを介して提供されたリモート候補に加えて、現在ネゴシエーション中のリモート記述のコピー（つまり、対応するローカル応答のないリモートオファーセット）を返します。"
    },
    {
      "indent": 3,
      "text": "A null object will be returned if the state of the PeerConnection is \"stable\" or \"have-local-offer\".",
      "ja": "PeerConnectionの状態が「stable」または「have-local-offer」の場合、nullオブジェクトが返されます。"
    },
    {
      "indent": 0,
      "text": "4.1.17. canTrickleIceCandidates",
      "section_title": true,
      "ja": "4.1.17. canTrickleIceCandidates"
    },
    {
      "indent": 3,
      "text": "The canTrickleIceCandidates property indicates whether the remote side supports receiving trickled candidates. There are three potential values:",
      "ja": "canTrickleIceCandidatesプロパティは、リモート側がトリクル候補の受信をサポートするかどうかを示します。3つの潜在的な値があります。"
    },
    {
      "indent": 3,
      "text": "null: No SDP has been received from the other side, so it is not known if it can handle trickle. This is the initial value before setRemoteDescription is called.",
      "ja": "null：反対側からSDPを受信していないため、トリクルを処理できるかどうかは不明です。これは、setRemoteDescriptionが呼び出される前の初期値です。"
    },
    {
      "indent": 3,
      "text": "true: SDP has been received from the other side indicating that it can support trickle.",
      "ja": "true：SDPが反対側から受信され、トリクルをサポートできることを示しています。"
    },
    {
      "indent": 3,
      "text": "false: SDP has been received from the other side indicating that it cannot support trickle.",
      "ja": "false：SDPが反対側から受信され、トリクルをサポートできないことを示しています。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3.5.2, JSEP implementations always provide candidates to the application individually, consistent with what is needed for Trickle ICE. However, applications can use the canTrickleIceCandidates property to determine whether their peer can actually do Trickle ICE, i.e., whether it is safe to send an initial offer or answer followed later by candidates as they are gathered. As \"true\" is the only value that definitively indicates remote Trickle ICE support, an application that compares canTrickleIceCandidates against \"true\" will by default attempt Half Trickle on initial offers and Full Trickle on subsequent interactions with a Trickle ICE-compatible agent.",
      "ja": "セクション3.5.2で説明されているように、JSEP実装は常に、Trickle ICEに必要なものと一致して、アプリケーションに個別に候補を提供します。ただし、アプリケーションはcanTrickleIceCandidatesプロパティを使用して、ピアが実際にTrickle ICEを実行できるかどうか、つまり、最初のオファーまたは回答を送信し、後で候補者が収集された後に安全かどうかを判断できます。「true」はリモートTrickleICEサポートを明確に示す唯一の値であるため、canTrickleIceCandidatesを「true」と比較するアプリケーションは、デフォルトで、最初のオファーでHalf Trickleを試行し、その後のTrickleICE互換エージェントとの対話でFullTrickleを試行します。"
    },
    {
      "indent": 0,
      "text": "4.1.18. setConfiguration",
      "section_title": true,
      "ja": "4.1.18. setConfiguration"
    },
    {
      "indent": 3,
      "text": "The setConfiguration method allows the global configuration of the PeerConnection, which was initially set by constructor parameters, to be changed during the session. The effects of calling this method depend on when it is invoked, and they will differ, depending on which specific parameters are changed:",
      "ja": "setConfigurationメソッドを使用すると、コンストラクターパラメーターによって最初に設定されたPeerConnectionのグローバル構成を、セッション中に変更できます。このメソッドを呼び出すことの効果は、呼び出されるタイミングによって異なり、変更される特定のパラメーターによって異なります。"
    },
    {
      "indent": 3,
      "text": "* Any changes to the STUN/TURN servers to use affect the next gathering phase. If an ICE gathering phase has already started or completed, the 'needs-ice-restart' bit mentioned in Section 3.5.1 will be set. This will cause the next call to createOffer to generate new ICE credentials, for the purpose of forcing an ICE restart and kicking off a new gathering phase, in which the new servers will be used. If the ICE candidate pool has a nonzero size and a local description has not yet been applied, any existing candidates will be discarded, and new candidates will be gathered from the new servers.",
      "ja": "* 使用するSTUN / TURNサーバーへの変更は、次の収集フェーズに影響します。ICE収集フェーズがすでに開始または完了している場合は、セクション3.5.1に記載されている「needs-ice-restart」ビットが設定されます。これにより、次のcreateOfferの呼び出しで、ICEの再起動を強制し、新しいサーバーが使用される新しい収集フェーズを開始する目的で、新しいICE資格情報が生成されます。ICE候補プールのサイズがゼロ以外で、ローカル記述がまだ適用されていない場合、既存の候補はすべて破棄され、新しい候補が新しいサーバーから収集されます。"
    },
    {
      "indent": 3,
      "text": "* Any change to the ICE candidate policy affects the next gathering phase. If an ICE gathering phase has already started or completed, the 'needs-ice-restart' bit will be set. Either way, changes to the policy have no effect on the candidate pool, because pooled candidates are not made available to the application until a gathering phase occurs, and so any necessary filtering can still be done on any pooled candidates.",
      "ja": "* ICE候補ポリシーへの変更は、次の収集フェーズに影響します。ICE収集フェーズがすでに開始または完了している場合は、「needs-ice-restart」ビットが設定されます。いずれにせよ、ポリシーの変更は候補プールに影響を与えません。これは、プールされた候補は収集フェーズが発生するまでアプリケーションで使用できないため、プールされた候補に対して必要なフィルタリングを実行できるためです。"
    },
    {
      "indent": 3,
      "text": "* The ICE candidate pool size MUST NOT be changed after applying a local description. If a local description has not yet been applied, any changes to the ICE candidate pool size take effect immediately; if increased, additional candidates are pre-gathered; if decreased, the now-superfluous candidates are discarded.",
      "ja": "* ローカル記述を適用した後、ICE候補プールサイズを変更してはなりません（MUSTNOT）。ローカル記述がまだ適用されていない場合、ICE候補プールサイズへの変更はすぐに有効になります。増加した場合、追加の候補者が事前に収集されます。減少した場合、現在は不要な候補は破棄されます。"
    },
    {
      "indent": 3,
      "text": "* The bundle and RTCP-multiplexing policies MUST NOT be changed after the construction of the PeerConnection.",
      "ja": "* バンドルおよびRTCP多重化ポリシーは、PeerConnectionの構築後に変更してはなりません（MUSTNOT）。"
    },
    {
      "indent": 3,
      "text": "Calling this method may result in a change to the state of the ICE agent.",
      "ja": "このメソッドを呼び出すと、ICEエージェントの状態が変わる可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.1.19. addIceCandidate",
      "section_title": true,
      "ja": "4.1.19. addIceCandidate"
    },
    {
      "indent": 3,
      "text": "The addIceCandidate method provides an update to the ICE agent via an IceCandidate object (Section 3.5.2.1). If the IceCandidate's candidate field is non-null, the IceCandidate is treated as a new remote ICE candidate, which will be added to the current and/or pending remote description according to the rules defined for Trickle ICE. Otherwise, the IceCandidate is treated as an end-of-candidates indication, as defined in [RFC8838], Section 14.",
      "ja": "addIceCandidateメソッドは、IceCandidateオブジェクトを介してICEエージェントに更新を提供します（セクション3.5.2.1）。IceCandidateの候補フィールドがnullでない場合、IceCandidateは新しいリモートICE候補として扱われ、Trickle ICEに定義されたルールに従って、現在および/または保留中のリモート記述に追加されます。それ以外の場合、IceCandidateは、[RFC8838]のセクション14で定義されているように、候補の終了を示すものとして扱われます。"
    },
    {
      "indent": 3,
      "text": "In either case, the \"m=\" section index, MID, and ufrag fields from the supplied IceCandidate are used to determine which \"m=\" section and ICE candidate generation the IceCandidate belongs to, as described in Section 3.5.2.1 above. In the case of an end-of-candidates indication, null values for the \"m=\" section index and MID fields are interpreted to mean that the indication applies to all \"m=\" sections in the specified ICE candidate generation. However, if both fields are null for a new remote candidate, this MUST be treated as an invalid condition, as specified below.",
      "ja": "いずれの場合も、上記のセクション3.5.2.1で説明したように、提供されたIceCandidateの \"m =\"セクションインデックス、MID、およびufragフィールドを使用して、IceCandidateが属する \"m =\"セクションおよびICE候補世代を決定します。候補の終わりの表示の場合、「m =」セクションインデックスおよびMIDフィールドのnull値は、指定されたICE候補世代のすべての「m =」セクションに表示が適用されることを意味すると解釈されます。ただし、新しいリモート候補に対して両方のフィールドがnullの場合、以下に指定するように、これは無効な条件として扱われる必要があります。"
    },
    {
      "indent": 3,
      "text": "If any IceCandidate fields contain invalid values or an error occurs during the processing of the IceCandidate object, the supplied IceCandidate MUST be ignored and an error MUST be returned.",
      "ja": "IceCandidateフィールドに無効な値が含まれている場合、またはIceCandidateオブジェクトの処理中にエラーが発生した場合は、指定されたIceCandidateを無視し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the new remote candidate or end-of-candidates indication is supplied to the ICE agent. In the case of a new remote candidate, connectivity checks will be sent to the new candidate, assuming setLocalDescription has already been called to initialize the ICE gathering process.",
      "ja": "それ以外の場合は、新しいリモート候補または候補の終了の表示がICEエージェントに提供されます。新しいリモート候補の場合、ICE収集プロセスを初期化するためにsetLocalDescriptionがすでに呼び出されていると想定して、接続チェックが新しい候補に送信されます。"
    },
    {
      "indent": 0,
      "text": "4.1.20. onicecandidate Event",
      "section_title": true,
      "ja": "4.1.20. onicecandidateイベント"
    },
    {
      "indent": 3,
      "text": "The onicecandidate event is dispatched to the application in two situations: (1) when the ICE agent has discovered a new allowed local ICE candidate during ICE gathering, as outlined in Section 3.5.1 and subject to the restrictions discussed in Section 3.5.3, or (2) when an ICE gathering phase completes. The event contains a single IceCandidate object, as defined in Section 3.5.2.1.",
      "ja": "onicecandidateイベントは、次の2つの状況でアプリケーションにディスパッチされます。（1）セクション3.5.1で概説され、セクション3.5.3で説明されている制限に従って、ICEエージェントがICE収集中に新しい許可されたローカルICE候補を検出した場合。または（2）ICE収集フェーズが完了したとき。セクション3.5.2.1で定義されているように、イベントには単一のIceCandidateオブジェクトが含まれています。"
    },
    {
      "indent": 3,
      "text": "In the first case, the newly discovered candidate is reflected in the IceCandidate object, and all of its fields MUST be non-null. This candidate will also be added to the current and/or pending local description according to the rules defined for Trickle ICE.",
      "ja": "最初のケースでは、新しく検出された候補がIceCandidateオブジェクトに反映され、そのすべてのフィールドがnull以外である必要があります。この候補は、Trickle ICEに定義されたルールに従って、現在および/または保留中のローカルの説明にも追加されます。"
    },
    {
      "indent": 3,
      "text": "In the second case, the event's IceCandidate object MUST have its candidate field set to null to indicate that the current gathering phase is complete, i.e., there will be no further onicecandidate events in this phase. However, the IceCandidate's ufrag field MUST be specified to indicate which ICE candidate generation is ending. The IceCandidate's \"m=\" section index and MID fields MAY be specified to indicate that the event applies to a specific \"m=\" section, or set to null to indicate it applies to all \"m=\" sections in the current ICE candidate generation. This event can be used by the application to generate an end-of-candidates indication, as defined in [RFC8838], Section 13.",
      "ja": "2番目のケースでは、イベントのIceCandidateオブジェクトの候補フィールドをnullに設定して、現在の収集フェーズが完了したことを示す必要があります。つまり、このフェーズではこれ以上onicecandidateイベントが発生しません。ただし、IceCandidateのufragフィールドは、どのICE候補生成が終了するかを示すために指定する必要があります。IceCandidateの「m =」セクションインデックスおよびMIDフィールドは、イベントが特定の「m =」セクションに適用されることを示すために指定するか、nullに設定して現在のICE候補世代のすべての「m =」セクションに適用することを示すことができます。。このイベントは、[RFC8838]のセクション13で定義されているように、アプリケーションが候補の終了を示すために使用できます。"
    },
    {
      "indent": 0,
      "text": "4.2. RtpTransceiver",
      "section_title": true,
      "ja": "4.2. RtpTransceiver"
    },
    {
      "indent": 0,
      "text": "4.2.1. stop",
      "section_title": true,
      "ja": "4.2.1. やめる"
    },
    {
      "indent": 3,
      "text": "The stop method stops an RtpTransceiver. This will cause future calls to createOffer to generate a zero port for the associated \"m=\" section. See below for more details.",
      "ja": "stopメソッドはRtpTransceiverを停止します。これにより、createOfferを今後呼び出すと、関連する「m =」セクションのゼロポートが生成されます。詳細については、以下を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.2. stopped",
      "section_title": true,
      "ja": "4.2.2. 停止"
    },
    {
      "indent": 3,
      "text": "The stopped property indicates whether the transceiver has been stopped, either by a call to stop or by applying an answer that rejects the associated \"m=\" section. In either of these cases, it is set to \"true\" and otherwise will be set to \"false\".",
      "ja": "停止プロパティは、stopの呼び出しによって、または関連する「m =」セクションを拒否する応答を適用することによって、トランシーバーが停止したかどうかを示します。いずれの場合も「true」に設定され、それ以外の場合は「false」に設定されます。"
    },
    {
      "indent": 3,
      "text": "A stopped RtpTransceiver does not send any outgoing RTP or RTCP or process any incoming RTP or RTCP. It cannot be restarted.",
      "ja": "停止したRtpTransceiverは、発信RTPまたはRTCPを送信したり、着信RTPまたはRTCPを処理したりしません。再起動できません。"
    },
    {
      "indent": 0,
      "text": "4.2.3. setDirection",
      "section_title": true,
      "ja": "4.2.3. setDirection"
    },
    {
      "indent": 3,
      "text": "The setDirection method sets the direction of a transceiver, which affects the direction property of the associated \"m=\" section on future calls to createOffer and createAnswer. The permitted values for direction are \"recvonly\", \"sendrecv\", \"sendonly\", and \"inactive\", mirroring the identically named direction attributes defined in [RFC4566], Section 6.",
      "ja": "setDirectionメソッドは、トランシーバーの方向を設定します。これは、createOfferおよびcreateAnswerへの今後の呼び出しで関連する「m =」セクションの方向プロパティに影響します。方向に許可される値は、「recvonly」、「sendrecv」、「sendonly」、および「inactive」であり、[RFC4566]のセクション6で定義されている同じ名前の方向属性を反映しています。"
    },
    {
      "indent": 3,
      "text": "When creating offers, the transceiver direction is directly reflected in the output, even for re-offers. When creating answers, the transceiver direction is intersected with the offered direction, as explained in Section 5.3 below.",
      "ja": "オファーを作成するとき、トランシーバーの方向は、再オファーの場合でも、出力に直接反映されます。回答を作成するとき、以下のセクション5.3で説明するように、トランシーバーの方向は提供された方向と交差します。"
    },
    {
      "indent": 3,
      "text": "Note that while setDirection sets the direction property of the transceiver immediately (Section 4.2.4), this property does not immediately affect whether the transceiver's RtpSender will send or its RtpReceiver will receive. The direction in effect is represented by the currentDirection property, which is only updated when an answer is applied.",
      "ja": "setDirectionはトランシーバーの方向プロパティをすぐに設定しますが（セクション4.2.4）、このプロパティはトランシーバーのRtpSenderが送信するか受信するかにはすぐには影響しません。有効な方向はcurrentDirectionプロパティで表され、回答が適用されたときにのみ更新されます。"
    },
    {
      "indent": 0,
      "text": "4.2.4. direction",
      "section_title": true,
      "ja": "4.2.4. 方向"
    },
    {
      "indent": 3,
      "text": "The direction property indicates the last value passed into setDirection. If setDirection has never been called, it is set to the direction the transceiver was initialized with.",
      "ja": "方向プロパティは、setDirectionに渡された最後の値を示します。setDirectionが呼び出されたことがない場合は、トランシーバーが初期化された方向に設定されます。"
    },
    {
      "indent": 0,
      "text": "4.2.5. currentDirection",
      "section_title": true,
      "ja": "4.2.5. currentDirection"
    },
    {
      "indent": 3,
      "text": "The currentDirection property indicates the last negotiated direction for the transceiver's associated \"m=\" section. More specifically, it indicates the direction attribute [RFC3264] of the associated \"m=\" section in the last applied answer (including provisional answers), with \"send\" and \"recv\" directions reversed if it was a remote answer. For example, if the direction attribute for the associated \"m=\" section in a remote answer is \"recvonly\", currentDirection is set to \"sendonly\".",
      "ja": "currentDirectionプロパティは、トランシーバーに関連付けられた「m =」セクションの最後にネゴシエートされた方向を示します。具体的には、最後に適用された回答（暫定回答を含む）の関連する「m =」セクションの方向属性[RFC3264]を示し、リモート回答の場合は「送信」と「受信」の方向が逆になります。たとえば、リモート回答の関連する「m =」セクションの方向属性が「recvonly」の場合、currentDirectionは「sendonly」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If an answer that references this transceiver has not yet been applied or if the transceiver is stopped, currentDirection is set to \"null\".",
      "ja": "このトランシーバーを参照する回答がまだ適用されていない場合、またはトランシーバーが停止している場合、currentDirectionは「null」に設定されます。"
    },
    {
      "indent": 0,
      "text": "4.2.6. setCodecPreferences",
      "section_title": true,
      "ja": "4.2.6. setCodecPreferences"
    },
    {
      "indent": 3,
      "text": "The setCodecPreferences method sets the codec preferences of a transceiver, which in turn affect the presence and order of codecs of the associated \"m=\" section on future calls to createOffer and createAnswer. Note that setCodecPreferences does not directly affect which codec the implementation decides to send. It only affects which codecs the implementation indicates that it prefers to receive, via the offer or answer. Even when a codec is excluded by setCodecPreferences, it still may be used to send until the next offer/answer exchange discards it.",
      "ja": "setCodecPreferencesメソッドは、トランシーバーのコーデックプリファレンスを設定します。これは、createOfferおよびcreateAnswerへの今後の呼び出しで関連する「m =」セクションのコーデックの存在と順序に影響します。setCodecPreferencesは、実装が送信することを決定したコーデックに直接影響しないことに注意してください。これは、実装がオファーまたはアンサーを介して受信することを好むことを示すコーデックにのみ影響します。コーデックがsetCodecPreferencesによって除外されている場合でも、次のオファー/アンサー交換でコーデックが破棄されるまで、コーデックを使用して送信できます。"
    },
    {
      "indent": 3,
      "text": "The codec preferences of an RtpTransceiver can cause codecs to be excluded by subsequent calls to createOffer and createAnswer, in which case the corresponding media formats in the associated \"m=\" section will be excluded. The codec preferences cannot add media formats that would otherwise not be present.",
      "ja": "RtpTransceiverのコーデック設定により、createOfferおよびcreateAnswerの後続の呼び出しによってコーデックが除外される可能性があります。その場合、関連する「m =」セクションの対応するメディア形式が除外されます。コーデック設定では、他の方法では存在しないメディア形式を追加できません。"
    },
    {
      "indent": 3,
      "text": "The codec preferences of an RtpTransceiver can also determine the order of codecs in subsequent calls to createOffer and createAnswer, in which case the order of the media formats in the associated \"m=\" section will follow the specified preferences.",
      "ja": "RtpTransceiverのコーデック設定では、createOfferおよびcreateAnswerの後続の呼び出しでコーデックの順序を決定することもできます。この場合、関連する「m =」セクションのメディア形式の順序は指定された設定に従います。"
    },
    {
      "indent": 0,
      "text": "5. SDP Interaction Procedures",
      "section_title": true,
      "ja": "5. SDP相互作用手順"
    },
    {
      "indent": 3,
      "text": "This section describes the specific procedures to be followed when creating and parsing SDP objects.",
      "ja": "このセクションでは、SDPオブジェクトを作成および解析するときに従うべき特定の手順について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Requirements Overview",
      "section_title": true,
      "ja": "5.1. 要件の概要"
    },
    {
      "indent": 3,
      "text": "JSEP implementations MUST comply with the specifications listed below that govern the creation and processing of offers and answers.",
      "ja": "JSEPの実装は、オファーとアンサーの作成と処理を管理する以下の仕様に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Usage Requirements",
      "section_title": true,
      "ja": "5.1.1. 使用要件"
    },
    {
      "indent": 3,
      "text": "All session descriptions handled by JSEP implementations, both local and remote, MUST indicate support for the following specifications. If any of these are absent, this omission MUST be treated as an error.",
      "ja": "ローカルとリモートの両方のJSEP実装によって処理されるすべてのセッション記述は、以下の仕様のサポートを示さなければなりません。これらのいずれかが存在しない場合、この省略はエラーとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "* ICE, as specified in [RFC8445], MUST be used. Note that the remote endpoint may use a lite implementation; implementations MUST properly handle remote endpoints that use ICE-lite. The remote endpoint may also use an older version of ICE; implementations MUST properly handle remote endpoints that use ICE as specified in [RFC5245].",
      "ja": "* [RFC8445]で指定されているICEを使用する必要があります。リモートエンドポイントはライト実装を使用する場合があることに注意してください。実装は、ICE-liteを使用するリモートエンドポイントを適切に処理する必要があります。リモートエンドポイントは、古いバージョンのICEを使用する場合もあります。実装は、[RFC5245]で指定されているようにICEを使用するリモートエンドポイントを適切に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "* DTLS [RFC6347] or DTLS-SRTP [RFC5763] MUST be used, as appropriate for the media type, as specified in [RFC8827].",
      "ja": "* [RFC8827]で指定されているように、メディアタイプに応じて、DTLS [RFC6347]またはDTLS-SRTP [RFC5763]を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The SDP security descriptions mechanism for SRTP keying [RFC4568] MUST NOT be used, as discussed in [RFC8827].",
      "ja": "[RFC8827]で説明されているように、SRTPキーイング[RFC4568]のSDPセキュリティ記述メカニズムを使用してはなりません（MUSTNOT）。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Profile Names and Interoperability",
      "section_title": true,
      "ja": "5.1.2. プロファイル名と相互運用性"
    },
    {
      "indent": 3,
      "text": "For media \"m=\" sections, JSEP implementations MUST support the \"UDP/TLS/RTP/SAVPF\" profile specified in [RFC5764] as well as the \"TCP/DTLS/RTP/SAVPF\" profile specified in [RFC7850] and MUST indicate one of these profiles for each media \"m=\" line they produce in an offer. For data \"m=\" sections, implementations MUST support the \"UDP/DTLS/SCTP\" profile as well as the \"TCP/DTLS/SCTP\" profile and MUST indicate one of these profiles for each data \"m=\" line they produce in an offer. The exact profile to use is determined by the protocol associated with the current default or selected ICE candidate, as described in [RFC8839], Section 4.2.1.2.",
      "ja": "メディア「m =」セクションの場合、JSEP実装は、[RFC5764]で指定された「UDP / TLS / RTP / SAVPF」プロファイルと[RFC7850]で指定された「TCP / DTLS / RTP / SAVPF」プロファイルをサポートする必要があります。オファーで作成する各メディア「m =」行のこれらのプロファイルの1つ。データ「m =」セクションの場合、実装は「UDP / DTLS / SCTP」プロファイルと「TCP / DTLS / SCTP」プロファイルをサポートする必要があり、データ「m =」行ごとにこれらのプロファイルの1つを示す必要があります。提案。使用する正確なプロファイルは、[RFC8839]のセクション4.2.1.2で説明されているように、現在のデフォルトまたは選択されたICE候補に関連付けられたプロトコルによって決定されます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, in an attempt at compatibility, some endpoints generate other profile strings even when they mean to support one of these profiles. For instance, an endpoint might generate \"RTP/AVP\" but supply \"a=fingerprint\" and \"a=rtcp-fb\" attributes, indicating its willingness to support \"UDP/TLS/RTP/SAVPF\" or \"TCP/DTLS/RTP/SAVPF\". In order to simplify compatibility with such endpoints, JSEP implementations MUST follow the following rules when processing the media \"m=\" sections in a received offer:",
      "ja": "残念ながら、互換性を確保するために、一部のエンドポイントは、これらのプロファイルの1つをサポートすることを意図している場合でも、他のプロファイル文字列を生成します。たとえば、エンドポイントは「RTP / AVP」を生成しますが、「a = fingerprint」および「a = rtcp-fb」属性を提供し、「UDP / TLS / RTP / SAVPF」または「TCP / DTLS / RTP」をサポートする意思があることを示します。/ SAVPF」。このようなエンドポイントとの互換性を簡素化するために、JSEP実装は、受信したオファーのメディア「m =」セクションを処理するときに次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any profile in the offer matching one of the following MUST be accepted:",
      "ja": "* 次のいずれかに一致するオファー内のプロファイルはすべて受け入れる必要があります。"
    },
    {
      "indent": 6,
      "text": "- \"RTP/AVP\" (defined in [RFC4566], Section 8.2.2)",
      "ja": "- 「RTP / AVP」（[RFC4566]、セクション8.2.2で定義）"
    },
    {
      "indent": 6,
      "text": "- \"RTP/AVPF\" (defined in [RFC4585], Section 9)",
      "ja": "- 「RTP / AVPF」（[RFC4585]、セクション9で定義）"
    },
    {
      "indent": 6,
      "text": "- \"RTP/SAVP\" (defined in [RFC3711], Section 12)",
      "ja": "- 「RTP / SAVP」（[RFC3711]、セクション12で定義）"
    },
    {
      "indent": 6,
      "text": "- \"RTP/SAVPF\" (defined in [RFC5124], Section 6)",
      "ja": "- 「RTP / SAVPF」（[RFC5124]、セクション6で定義）"
    },
    {
      "indent": 6,
      "text": "-  \"TCP/DTLS/RTP/SAVP\" (defined in [RFC7850], Section 3.4)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "-  \"TCP/DTLS/RTP/SAVPF\" (defined in [RFC7850], Section 3.5)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "-  \"UDP/TLS/RTP/SAVP\" (defined in [RFC5764], Section 9)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "-  \"UDP/TLS/RTP/SAVPF\" (defined in [RFC5764], Section 9)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* The profile in any \"m=\" line in any generated answer MUST exactly match the profile provided in the offer.",
      "ja": "* 生成された回答の「m =」行のプロファイルは、オファーで提供されたプロファイルと正確に一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Because DTLS-SRTP is REQUIRED, the choice of SAVP or AVP has no effect; support for DTLS-SRTP is determined by the presence of one or more \"a=fingerprint\" attributes. Note that lack of an \"a=fingerprint\" attribute will lead to negotiation failure.",
      "ja": "* DTLS-SRTPが必要なため、SAVPまたはAVPを選択しても効果はありません。DTLS-SRTPのサポートは、1つ以上の「a = fingerprint」属性の存在によって決定されます。「a = fingerprint」属性がないと、ネゴシエーションが失敗することに注意してください。"
    },
    {
      "indent": 3,
      "text": "* The use of AVPF or AVP simply controls the timing rules used for RTCP feedback. If AVPF is provided or an \"a=rtcp-fb\" attribute is present, assume AVPF timing, i.e., a default value of \"trr-int=0\". Otherwise, assume that AVPF is being used in an AVP-compatible mode and use a value of \"trr-int=4000\".",
      "ja": "* AVPFまたはAVPを使用すると、RTCPフィードバックに使用されるタイミングルールを制御するだけです。AVPFが提供されている場合、または「a = rtcp-fb」属性が存在する場合は、AVPFタイミング、つまりデフォルト値の「trr-int = 0」を想定します。それ以外の場合は、AVPFがAVP互換モードで使用されていると想定し、「trr-int = 4000」の値を使用します。"
    },
    {
      "indent": 3,
      "text": "* For data \"m=\" sections, implementations MUST support receiving the \"UDP/DTLS/SCTP\", \"TCP/DTLS/SCTP\", or \"DTLS/SCTP\" (for backwards compatibility) profiles.",
      "ja": "* データ「m =」セクションの場合、実装は「UDP / DTLS / SCTP」、「TCP / DTLS / SCTP」、または「DTLS / SCTP」（下位互換性のため）プロファイルの受信をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that re-offers by JSEP implementations MUST use the correct profile strings even if the initial offer/answer exchange used an (incorrect) older profile string. This simplifies JSEP behavior, with minimal downside, as any remote endpoint that fails to handle such a re-offer will also fail to handle a JSEP endpoint's initial offer.",
      "ja": "JSEP実装による再オファーでは、最初のオファー/アンサー交換で（誤った）古いプロファイル文字列が使用されていたとしても、正しいプロファイル文字列を使用する必要があることに注意してください。これにより、JSEPの動作が簡素化され、欠点は最小限に抑えられます。このような再オファーの処理に失敗したリモートエンドポイントは、JSEPエンドポイントの最初のオファーの処理にも失敗するためです。"
    },
    {
      "indent": 0,
      "text": "5.2. Constructing an Offer",
      "section_title": true,
      "ja": "5.2. オファーの作成"
    },
    {
      "indent": 3,
      "text": "When createOffer is called, a new SDP description MUST be created that includes the functionality specified in [RFC8834]. The exact details of this process are explained below.",
      "ja": "createOfferが呼び出されると、[RFC8834]で指定された機能を含む新しいSDP記述を作成する必要があります。このプロセスの正確な詳細を以下に説明します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Initial Offers",
      "section_title": true,
      "ja": "5.2.1. 最初のオファー"
    },
    {
      "indent": 3,
      "text": "When createOffer is called for the first time, the result is known as the initial offer.",
      "ja": "createOfferが初めて呼び出されたとき、その結果は最初のオファーと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The first step in generating an initial offer is to generate session-level attributes, as specified in [RFC4566], Section 5. Specifically:",
      "ja": "最初のオファーを生成する最初のステップは、[RFC4566]のセクション5で指定されているように、セッションレベルの属性を生成することです。具体的には次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* The first SDP line MUST be \"v=0\" as defined in [RFC4566], Section 5.1.",
      "ja": "* [RFC4566]のセクション5.1で定義されているように、最初のSDP行は「v = 0」である必要があります。"
    },
    {
      "indent": 3,
      "text": "* The second SDP line MUST be an \"o=\" line as defined in [RFC4566], Section 5.2. The value of the <username> field SHOULD be \"-\". The <sess-id> MUST be representable by a 64-bit signed integer, and the value MUST be less than 2^(63)-1. It is RECOMMENDED that the <sess-id> be constructed by generating a 64-bit quantity with the highest bit set to zero and the remaining 63 bits being cryptographically random. The value of the <nettype> <addrtype> <unicast-address> tuple SHOULD be set to a non-meaningful address, such as IN IP4 0.0.0.0, to prevent leaking a local IP address in this field; this problem is discussed in [RFC8828]. As mentioned in [RFC4566], the entire \"o=\" line needs to be unique, but selecting a random number for <sess-id> is sufficient to accomplish this.",
      "ja": "* 2番目のSDP行は、[RFC4566]のセクション5.2で定義されている「o =」行である必要があります。<username>フィールドの値は「-」である必要があります。<sess-id>は、64ビットの符号付き整数で表現できる必要があり、値は2 ^（63）-1未満である必要があります。<sess-id>は、最高ビットがゼロに設定され、残りの63ビットが暗号的にランダムである64ビット量を生成することによって構築されることをお勧めします。<nettype> <addrtype> <unicast-address>タプルの値は、このフィールドのローカルIPアドレスのリークを防ぐために、IN IP40.0.0.0などの意味のないアドレスに設定する必要があります。この問題は[RFC8828]で説明されています。[RFC4566]で説明されているように、「o =」行全体が一意である必要がありますが、これを実現するには、<sess-id>に乱数を選択するだけで十分です。"
    },
    {
      "indent": 3,
      "text": "* The third SDP line MUST be a \"s=\" line as defined in [RFC4566], Section 5.3; to match the \"o=\" line, a single dash SHOULD be used as the session name, e.g., \"s=-\". Note that this differs from the advice in [RFC4566], which proposes a single space, but as both \"o=\" and \"s=\" are meaningless in JSEP, having the same meaningless value seems clearer.",
      "ja": "* 3番目のSDP行は、[RFC4566]のセクション5.3で定義されている「s =」行である必要があります。「o =」行と一致させるには、セッション名として1つのダッシュを使用する必要があります（例：「s =-」）。これは、単一のスペースを提案する[RFC4566]のアドバイスとは異なりますが、JSEPでは「o =」と「s =」の両方が無意味であるため、同じ無意味な値を持つ方が明確に見えることに注意してください。"
    },
    {
      "indent": 3,
      "text": "* Session Information (\"i=\"), URI (\"u=\"), Email Address (\"e=\"), Phone Number (\"p=\"), Repeat Times (\"r=\"), and Time Zones (\"z=\") lines are not useful in this context and SHOULD NOT be included.",
      "ja": "* セッション情報（ \"i =\"）、URI（ \"u =\"）、電子メールアドレス（ \"e =\"）、電話番号（ \"p =\"）、繰り返し時間（ \"r =\"）、およびタイムゾーン（ \"z= \"）行はこのコンテキストでは役に立たないため、含めないでください。"
    },
    {
      "indent": 3,
      "text": "* Encryption Keys (\"k=\") lines do not provide sufficient security and MUST NOT be included.",
      "ja": "* 暗号化キー（ \"k =\"）行は十分なセキュリティを提供しないため、含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "* A \"t=\" line MUST be added, as specified in [RFC4566], Section 5.9; both <start-time> and <stop-time> SHOULD be set to zero, e.g., \"t=0 0\".",
      "ja": "* [RFC4566]のセクション5.9で指定されているように、「t =」行を追加する必要があります。<start-time>と<stop-time>の両方をゼロに設定する必要があります（例： \"t = 0 0\"）。"
    },
    {
      "indent": 3,
      "text": "* An \"a=ice-options\" line with the \"trickle\" and \"ice2\" options MUST be added, as specified in [RFC8840], Section 4.1.1 and [RFC8445], Section 10.",
      "ja": "* [RFC8840]のセクション4.1.1および[RFC8445]のセクション10で指定されているように、「trickle」および「ice2」オプションを含む「a = ice-options」行を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If WebRTC identity is being used, an \"a=identity\" line MUST be added, as described in [RFC8827], Section 5.",
      "ja": "* WebRTC IDを使用している場合は、[RFC8827]のセクション5で説明されているように、「a = identity」行を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The next step is to generate \"m=\" sections, as specified in [RFC4566], Section 5.14. An \"m=\" section is generated for each RtpTransceiver that has been added to the PeerConnection, excluding any stopped RtpTransceivers; this is done in the order the RtpTransceivers were added to the PeerConnection. If there are no such RtpTransceivers, no \"m=\" sections are generated; more can be added later, as discussed in [RFC3264], Section 5.",
      "ja": "次のステップは、[RFC4566]のセクション5.14で指定されているように、「m =」セクションを生成することです。「m =」セクションは、停止したRtpTransceiversを除き、PeerConnectionに追加されたRtpTransceiverごとに生成されます。これは、RtpTransceiversがPeerConnectionに追加された順序で実行されます。そのようなRtpTransceiversがない場合、「m =」セクションは生成されません。[RFC3264]のセクション5で説明されているように、後でさらに追加できます。"
    },
    {
      "indent": 3,
      "text": "For each \"m=\" section generated for an RtpTransceiver, establish a mapping between the transceiver and the index of the generated \"m=\" section.",
      "ja": "RtpTransceiver用に生成された「m =」セクションごとに、トランシーバーと生成された「m =」セクションのインデックスとの間のマッピングを確立します。"
    },
    {
      "indent": 3,
      "text": "Each \"m=\" section, provided it is not marked as bundle-only, MUST contain a unique set of ICE credentials and a unique set of ICE candidates. Bundle-only \"m=\" sections MUST NOT contain any ICE credentials and MUST NOT gather any candidates.",
      "ja": "各「m =」セクションには、バンドルのみとしてマークされていない場合、一意のICE資格情報のセットと一意のICE候補のセットが含まれている必要があります。バンドルのみの「m =」セクションには、ICE資格情報を含めたり、候補を収集したりしてはなりません。"
    },
    {
      "indent": 3,
      "text": "For DTLS, all \"m=\" sections MUST use any and all certificates that have been specified for the PeerConnection; as a result, they MUST all have the same fingerprint value or values [RFC8122], or these values MUST be session-level attributes.",
      "ja": "DTLSの場合、すべての「m =」セクションは、PeerConnectionに指定されているすべての証明書を使用する必要があります。結果として、それらはすべて同じフィンガープリント値を持っている必要があります[RFC8122]、またはこれらの値はセッションレベルの属性でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each \"m=\" section MUST be generated as specified in [RFC4566], Section 5.14. For the \"m=\" line itself, the following rules MUST be followed:",
      "ja": "各「m =」セクションは、[RFC4566]のセクション5.14で指定されているように生成する必要があります。「m =」行自体については、次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section is marked as bundle-only, then the <port> value MUST be set to zero. Otherwise, the <port> value is set to the port of the default ICE candidate for this \"m=\" section, but given that no candidates are available yet, the default port value of 9 (Discard) MUST be used, as indicated in [RFC8840], Section 4.1.1.",
      "ja": "* 「m =」セクションがバンドルのみとしてマークされている場合、<port>値はゼロに設定する必要があります。それ以外の場合、<port>値はこの \"m =\"セクションのデフォルトICE候補のポートに設定されますが、候補がまだ利用できない場合は、に示すように、デフォルトのポート値9（破棄）を使用する必要があります。[RFC8840]、セクション4.1.1。"
    },
    {
      "indent": 3,
      "text": "* To properly indicate use of DTLS, the <proto> field MUST be set to \"UDP/TLS/RTP/SAVPF\", as specified in [RFC5764], Section 8.",
      "ja": "* DTLSの使用を適切に示すには、[RFC5764]のセクション8で指定されているように、<proto>フィールドを「UDP / TLS / RTP / SAVPF」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If codec preferences have been set for the associated transceiver, media formats MUST be generated in the corresponding order and MUST exclude any codecs not present in the codec preferences.",
      "ja": "* 関連するトランシーバーにコーデックプリファレンスが設定されている場合、メディアフォーマットは対応する順序で生成する必要があり、コーデックプリファレンスに存在しないコーデックを除外する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Unless excluded by the above restrictions, the media formats MUST include the mandatory audio/video codecs as specified in [RFC7874], Section 3 and [RFC7742], Section 5.",
      "ja": "* 上記の制限によって除外されない限り、メディア形式には、[RFC7874]のセクション3および[RFC7742]のセクション5で指定されている必須のオーディオ/ビデオコーデックを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"m=\" line MUST be followed immediately by a \"c=\" line, as specified in [RFC4566], Section 5.7. Again, as no candidates are available yet, the \"c=\" line MUST contain the default value \"IN IP4 0.0.0.0\", as defined in [RFC8840], Section 4.1.1.",
      "ja": "[RFC4566]のセクション5.7で指定されているように、「m =」行の直後に「c =」行を続ける必要があります。繰り返しになりますが、まだ候補がないため、[RFC8840]のセクション4.1.1で定義されているように、「c =」行にはデフォルト値「INIP40.0.0.0」が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC8859] groups SDP attributes into different categories. To avoid unnecessary duplication when bundling, attributes of category IDENTICAL or TRANSPORT MUST NOT be repeated in bundled \"m=\" sections, repeating the guidance from [RFC8843], Section 7.1.3. This includes \"m=\" sections for which bundling has been negotiated and is still desired, as well as \"m=\" sections marked as bundle-only.",
      "ja": "[RFC8859]は、SDP属性をさまざまなカテゴリにグループ化します。バンドル時に不要な重複を避けるために、カテゴリIDENTICALまたはTRANSPORTの属性は、[RFC8843]のセクション7.1.3のガイダンスを繰り返して、バンドルされた「m =」セクションで繰り返さないでください。これには、バンドルがネゴシエートされてまだ必要な「m =」セクションと、バンドルのみとしてマークされた「m =」セクションが含まれます。"
    },
    {
      "indent": 3,
      "text": "The following attributes, which are of a category other than IDENTICAL or TRANSPORT, MUST be included in each \"m=\" section:",
      "ja": "IDENTICALまたはTRANSPORT以外のカテゴリの次の属性は、各「m =」セクションに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* An \"a=mid\" line, as specified in [RFC5888], Section 4. All MID values MUST be generated in a fashion that does not leak user information, e.g., randomly or using a per-PeerConnection counter, and SHOULD be 3 bytes or less, to allow them to efficiently fit into the RTP header extension defined in [RFC8843], Section 15.2. Note that this does not set the RtpTransceiver mid property, as that only occurs when the description is applied. The generated MID value can be considered a \"proposed\" MID at this point.",
      "ja": "* [RFC5888]のセクション4で指定されている「a = mid」行。すべてのMID値は、ユーザー情報を漏らさない方法で生成する必要があります。たとえば、ランダムに、またはPeerConnectionカウンターごとに使用し、3バイトにする必要があります。[RFC8843]のセクション15.2で定義されているRTPヘッダー拡張に効率的に適合できるようにするため。説明が適用された場合にのみ発生するため、これはRtpTransceivermidプロパティを設定しないことに注意してください。生成されたMID値は、この時点で「提案された」MIDと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "* A direction attribute that is the same as that of the associated transceiver.",
      "ja": "* 関連するトランシーバーの方向属性と同じ方向属性。"
    },
    {
      "indent": 3,
      "text": "* For each media format on the \"m=\" line, \"a=rtpmap\" and \"a=fmtp\" lines, as specified in [RFC4566], Section 6 and [RFC3264], Section 5.1.",
      "ja": "* [RFC4566]のセクション6および[RFC3264]のセクション5.1で指定されているように、「m =」行、「a = rtpmap」および「a = fmtp」行の各メディア形式について。"
    },
    {
      "indent": 3,
      "text": "* For each primary codec where RTP retransmission should be used, a corresponding \"a=rtpmap\" line indicating \"rtx\" with the clock rate of the primary codec and an \"a=fmtp\" line that references the payload type of the primary codec, as specified in [RFC4588], Section 8.1.",
      "ja": "* RTP再送信を使用する必要がある各プライマリコーデックについて、プライマリコーデックのクロックレートで「rtx」を示す対応する「a = rtpmap」行と、プライマリコーデックのペイロードタイプを参照する「a = fmtp」行を次のように示します。[RFC4588]のセクション8.1で指定されています。"
    },
    {
      "indent": 3,
      "text": "* For each supported Forward Error Correction (FEC) mechanism, \"a=rtpmap\" and \"a=fmtp\" lines, as specified in [RFC4566], Section 6. The FEC mechanisms that MUST be supported are specified in [RFC8854], Section 7, and specific usage for each media type is outlined in Sections 4 and 5.",
      "ja": "* サポートされているフォワードエラー訂正（FEC）メカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行。サポートされなければならないFECメカニズムは[RFC8854]のセクション7で指定されています。、および各メディアタイプの具体的な使用法については、セクション4および5で概説しています。"
    },
    {
      "indent": 3,
      "text": "* If this \"m=\" section is for media with configurable durations of media per packet, e.g., audio, an \"a=maxptime\" line, indicating the maximum amount of media, specified in milliseconds, that can be encapsulated in each packet, as specified in [RFC4566], Section 6. This value is set to the smallest of the maximum duration values across all the codecs included in the \"m=\" section.",
      "ja": "* この「m =」セクションがパケットあたりのメディアの期間を構成可能なメディア用である場合（オーディオなど）、「a = maxptime」行は、ミリ秒単位で指定され、各パケットにカプセル化できるメディアの最大量を示します。[RFC4566]のセクション6で指定されています。この値は、「m =」セクションに含まれるすべてのコーデックの最大継続時間値の最小値に設定されます。"
    },
    {
      "indent": 3,
      "text": "* If this \"m=\" section is for video media and there are known limitations on the size of images that can be decoded, an \"a=imageattr\" line, as specified in Section 3.6.",
      "ja": "* この「m =」セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合は、セクション3.6で指定されている「a = imageattr」行。"
    },
    {
      "indent": 3,
      "text": "* For each supported RTP header extension, an \"a=extmap\" line, as specified in [RFC5285], Section 5. The list of header extensions that SHOULD/MUST be supported is specified in [RFC8834], Section 5.2. Any header extensions that require encryption MUST be specified as indicated in [RFC6904], Section 4.",
      "ja": "* サポートされているRTPヘッダー拡張ごとに、[RFC5285]のセクション5で指定されている「a = extmap」行。サポートされるべき/サポートされなければならないヘッダー拡張のリストは、[RFC8834]のセクション5.2で指定されています。暗号化が必要なヘッダー拡張は、[RFC6904]のセクション4に示されているように指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* For each supported RTCP feedback mechanism, an \"a=rtcp-fb\" line, as specified in [RFC4585], Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in [RFC8834], Section 5.1.",
      "ja": "* サポートされているRTCPフィードバックメカニズムごとに、[RFC4585]のセクション4.2で指定されている「a = rtcp-fb」行。サポートする必要がある/サポートする必要があるRTCPフィードバックメカニズムのリストは、[RFC8834]のセクション5.1で指定されています。"
    },
    {
      "indent": 3,
      "text": "* If the RtpTransceiver has a sendrecv or sendonly direction:",
      "ja": "* RtpTransceiverにsendrecvまたはsendonly方向がある場合："
    },
    {
      "indent": 6,
      "text": "- For each MediaStream that was associated with the transceiver when it was created via addTrack or addTransceiver, an \"a=msid\" line, as specified in [RFC8830], Section 2, but omitting the \"appdata\" field.",
      "ja": "- addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられたMediaStreamごとに、[RFC8830]のセクション2で指定されているように、「appdata」フィールドを省略した「a = msid」行。"
    },
    {
      "indent": 3,
      "text": "* If the RtpTransceiver has a sendrecv or sendonly direction, and the application has specified a rid-id for an encoding, or has specified more than one encoding in the RtpSenders's parameters, an \"a=rid\" line for each encoding specified. The \"a=rid\" line is specified in [RFC8851], and its direction MUST be \"send\". If the application has chosen a rid-id, it MUST be used; otherwise, a rid-id MUST be generated by the implementation. rid-ids MUST be generated in a fashion that does not leak user information, e.g., randomly or using a per-PeerConnection counter (see guidance at the end of [RFC8852], Section 3.3), and SHOULD be 3 bytes or less, to allow them to efficiently fit into the RTP header extensions defined in [RFC8852], Section 3.3. If no encodings have been specified, or only one encoding is specified but without a rid-id, then no \"a=rid\" lines are generated.",
      "ja": "* RtpTransceiverにsendrecvまたはsendonly方向があり、アプリケーションがエンコーディングにrid-idを指定した場合、またはRtpSendersのパラメータに複数のエンコーディングを指定した場合、指定されたエンコーディングごとに「a = rid」行。「a = rid」行は[RFC8851]で指定されており、その方向は「送信」でなければなりません。アプリケーションがrid-idを選択した場合は、それを使用する必要があります。それ以外の場合は、実装によってrid-idを生成する必要があります。rid-idは、ユーザー情報を漏らさない方法で生成する必要があります。たとえば、ランダムに、またはPeerConnectionごとのカウンターを使用して（[RFC8852]の最後のセクション3.3を参照）、3バイト以下にする必要があります。[RFC8852]のセクション3.3で定義されているRTPヘッダー拡張に効率的に適合できるようにします。エンコーディングが指定されていない場合、または1つのエンコーディングのみが指定されているがrid-idがない場合、「a = rid」行は生成されません。"
    },
    {
      "indent": 3,
      "text": "* If the RtpTransceiver has a sendrecv or sendonly direction and more than one \"a=rid\" line has been generated, an \"a=simulcast\" line, with direction \"send\", as defined in [RFC8853], Section 5.1. The associated set of rid-ids MUST include all of the rid-ids used in the \"a=rid\" lines for this \"m=\" section.",
      "ja": "* RtpTransceiverにsendrecvまたはsendonly方向があり、複数の「a = rid」行が生成されている場合、[RFC8853]のセクション5.1で定義されているように、方向が「send」の「a = simulcast」行。関連するrid-idのセットには、この「m =」セクションの「a = rid」行で使用されるすべてのrid-idを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If (1) the bundle policy for this PeerConnection is set to \"max-bundle\" and this is not the first \"m=\" section or (2) the bundle policy is set to \"balanced\" and this is not the first \"m=\" section for this media type, an \"a=bundle-only\" line.",
      "ja": "* （1）このPeerConnectionのバンドルポリシーが「max-bundle」に設定されており、これが最初の「m =」セクションではない場合、または（2）バンドルポリシーが「balanced」に設定されており、これが最初の「m」ではない場合=このメディアタイプのセクション、「a = bundle-only」行。"
    },
    {
      "indent": 3,
      "text": "The following attributes, which are of category IDENTICAL or TRANSPORT, MUST appear only in \"m=\" sections that either have a unique address or are associated with the BUNDLE-tag. (In initial offers, this means those \"m=\" sections that do not contain an \"a=bundle-only\" attribute.)",
      "ja": "カテゴリIDENTICALまたはTRANSPORTの次の属性は、一意のアドレスを持つか、BUNDLEタグに関連付けられている「m =」セクションにのみ表示する必要があります。（最初のオファーでは、これは「a = bundle-only」属性を含まない「m =」セクションを意味します。）"
    },
    {
      "indent": 3,
      "text": "* \"a=ice-ufrag\" and \"a=ice-pwd\" lines, as specified in [RFC8839], Section 5.4.",
      "ja": "* [RFC8839]のセクション5.4で指定されている、「a = ice-ufrag」および「a = ice-pwd」の行。"
    },
    {
      "indent": 3,
      "text": "* For each desired digest algorithm, one or more \"a=fingerprint\" lines for each of the endpoint's certificates, as specified in [RFC8122], Section 5.",
      "ja": "* [RFC8122]のセクション5で指定されているように、必要なダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行。"
    },
    {
      "indent": 3,
      "text": "* An \"a=setup\" line, as specified in [RFC4145], Section 4 and clarified for use in DTLS-SRTP scenarios in [RFC5763], Section 5. The role value in the offer MUST be \"actpass\".",
      "ja": "* [RFC4145]のセクション4で指定され、[RFC5763]のセクション5でDTLS-SRTPシナリオで使用するために明確化された、「a = setup」行。オファーのロール値は「actpass」である必要があります。"
    },
    {
      "indent": 3,
      "text": "* An \"a=tls-id\" line, as specified in [RFC8842], Section 5.2.",
      "ja": "* [RFC8842]のセクション5.2で指定されている「a = tls-id」行。"
    },
    {
      "indent": 3,
      "text": "* An \"a=rtcp\" line, as specified in [RFC3605], Section 2.1, containing the default value \"9 IN IP4 0.0.0.0\", because no candidates have yet been gathered.",
      "ja": "* [RFC3605]のセクション2.1で指定されている「a = rtcp」行。候補がまだ収集されていないため、デフォルト値「9 INIP40.0.0.0」が含まれています。"
    },
    {
      "indent": 3,
      "text": "* An \"a=rtcp-mux\" line, as specified in [RFC5761], Section 5.1.3.",
      "ja": "* [RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行。"
    },
    {
      "indent": 3,
      "text": "* If the RTP/RTCP multiplexing policy is \"require\", an \"a=rtcp-mux-only\" line, as specified in [RFC8858], Section 4.",
      "ja": "* RTP / RTCP多重化ポリシーが「require」の場合、[RFC8858]のセクション4で指定されているように、「a = rtcp-mux-only」行。"
    },
    {
      "indent": 3,
      "text": "* An \"a=rtcp-rsize\" line, as specified in [RFC5506], Section 5.",
      "ja": "* [RFC5506]のセクション5で指定されている「a = rtcp-rsize」行。"
    },
    {
      "indent": 3,
      "text": "Lastly, if a data channel has been created, an \"m=\" section MUST be generated for data. The <media> field MUST be set to \"application\", and the <proto> field MUST be set to \"UDP/DTLS/SCTP\" [RFC8841]. The <fmt> value MUST be set to \"webrtc-datachannel\" as specified in [RFC8841], Section 4.2.2.",
      "ja": "最後に、データチャネルが作成されている場合は、データ用に「m =」セクションを生成する必要があります。<media>フィールドは「application」に設定する必要があり、<proto>フィールドは「UDP / DTLS / SCTP」に設定する必要があります[RFC8841]。<fmt>値は、[RFC8841]のセクション4.2.2で指定されているように、「webrtc-datachannel」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Within the data \"m=\" section, an \"a=mid\" line MUST be generated and included as described above, along with an \"a=sctp-port\" line referencing the SCTP port number, as defined in [RFC8841], Section 5.1; and, if appropriate, an \"a=max-message-size\" line, as defined in [RFC8841], Section 6.1.",
      "ja": "データ「m =」セクション内で、「a = mid」行を生成し、上記のように含める必要があります。また、[RFC8841]のセクションで定義されているように、SCTPポート番号を参照する「a = sctp-port」行も含める必要があります。5.1;また、必要に応じて、[RFC8841]のセクション6.1で定義されている「a = max-message-size」行。"
    },
    {
      "indent": 3,
      "text": "As discussed above, the following attributes of category IDENTICAL or TRANSPORT are included only if the data \"m=\" section either has a unique address or is associated with the BUNDLE-tag (e.g., if it is the only \"m=\" section):",
      "ja": "上記のように、カテゴリIDENTICALまたはTRANSPORTの次の属性は、データ「m =」セクションに一意のアドレスがあるか、BUNDLEタグに関連付けられている場合にのみ含まれます（たとえば、それが唯一の「m =」セクションである場合）。："
    },
    {
      "indent": 3,
      "text": "* \"a=ice-ufrag\"",
      "ja": "* 「a = ice-ufrag」"
    },
    {
      "indent": 3,
      "text": "* \"a=ice-pwd\"",
      "ja": "* 「a = ice-pwd」"
    },
    {
      "indent": 3,
      "text": "* \"a=fingerprint\"",
      "ja": "* 「a =指紋」"
    },
    {
      "indent": 3,
      "text": "* \"a=setup\"",
      "ja": "* 「a = setup」"
    },
    {
      "indent": 3,
      "text": "* \"a=tls-id\"",
      "ja": "* \"a = tls-id\""
    },
    {
      "indent": 3,
      "text": "Once all \"m=\" sections have been generated, a session-level \"a=group\" attribute MUST be added as specified in [RFC5888]. This attribute MUST have semantics \"BUNDLE\" and MUST include the mid identifiers of each \"m=\" section. The effect of this is that the JSEP implementation offers all \"m=\" sections as one bundle group. However, whether the \"m=\" sections are bundle-only or not depends on the bundle policy.",
      "ja": "すべての「m =」セクションが生成されたら、[RFC5888]で指定されているようにセッションレベルの「a = group」属性を追加する必要があります。この属性にはセマンティクス「BUNDLE」が必要であり、各「m =」セクションの中間識別子が含まれている必要があります。この効果は、JSEP実装がすべての「m =」セクションを1つのバンドルグループとして提供することです。ただし、「m =」セクションがバンドルのみであるかどうかは、バンドルポリシーによって異なります。"
    },
    {
      "indent": 3,
      "text": "The next step is to generate session-level lip sync groups as defined in [RFC5888], Section 7. For each MediaStream referenced by more than one RtpTransceiver (by passing those MediaStreams as arguments to the addTrack and addTransceiver methods), a group of type \"LS\" MUST be added that contains the MID values for each RtpTransceiver.",
      "ja": "次のステップは、[RFC5888]のセクション7で定義されているセッションレベルのリップシンクグループを生成することです。複数のRtpTransceiverによって参照されるMediaStreamごとに（これらのMediaStreamを引数としてaddTrackメソッドとaddTransceiverメソッドに渡すことにより）、タイプのグループ各RtpTransceiverのMID値を含む「LS」を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "Attributes that SDP permits to be at either the session level or the media level SHOULD generally be at the media level even if they are identical. This assists development and debugging by making it easier to understand individual media sections, especially if one of a set of initially identical attributes is subsequently changed. However, implementations MAY choose to aggregate attributes at the session level, and JSEP implementations MUST be prepared to receive attributes in either location.",
      "ja": "SDPがセッションレベルまたはメディアレベルのいずれかで許可する属性は、それらが同一であっても、通常はメディアレベルである必要があります。これは、特に最初は同一の属性のセットの1つが後で変更された場合に、個々のメディアセクションを理解しやすくすることで、開発とデバッグを支援します。ただし、実装はセッションレベルで属性を集約することを選択でき、JSEP実装はいずれかの場所で属性を受け取るように準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Attributes other than the ones specified above MAY be included, except for the following attributes, which are specifically incompatible with the requirements of [RFC8834] and MUST NOT be included:",
      "ja": "[RFC8834]の要件と特に互換性がなく、含めてはならない次の属性を除いて、上記で指定されたもの以外の属性を含めることができます。"
    },
    {
      "indent": 3,
      "text": "* \"a=crypto\"",
      "ja": "* 「a = crypto」"
    },
    {
      "indent": 3,
      "text": "* \"a=key-mgmt\"",
      "ja": "* \"a = key-mgmt\""
    },
    {
      "indent": 3,
      "text": "* \"a=ice-lite\"",
      "ja": "* 「a = ice-lite」"
    },
    {
      "indent": 3,
      "text": "Note that when bundle is used, any additional attributes that are added MUST follow the advice in [RFC8859] on how those attributes interact with bundle.",
      "ja": "バンドルを使用する場合、追加される追加の属性は、それらの属性がバンドルとどのように相互作用するかに関する[RFC8859]のアドバイスに従わなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that these requirements are in some cases stricter than those of SDP. Implementations MUST be prepared to accept compliant SDP even if it would not conform to the requirements for generating SDP in this specification.",
      "ja": "これらの要件は、SDPの要件よりも厳しい場合があることに注意してください。実装は、この仕様でSDPを生成するための要件に準拠しない場合でも、準拠するSDPを受け入れるように準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Subsequent Offers",
      "section_title": true,
      "ja": "5.2.2. 後続のオファー"
    },
    {
      "indent": 3,
      "text": "When createOffer is called a second (or later) time or is called after a local description has already been installed, the processing is somewhat different than for an initial offer.",
      "ja": "createOfferが2回目（またはそれ以降）に呼び出された場合、またはローカル記述がすでにインストールされた後に呼び出された場合、処理は最初のオファーの場合とは多少異なります。"
    },
    {
      "indent": 3,
      "text": "If the previous offer was not applied using setLocalDescription, meaning the PeerConnection is still in the \"stable\" state, the steps for generating an initial offer MUST be followed, subject to the following restriction:",
      "ja": "以前のオファーがsetLocalDescriptionを使用して適用されなかった場合、つまりPeerConnectionがまだ「安定」状態である場合は、次の制限に従って、最初のオファーを生成する手順に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* The fields of the \"o=\" line MUST stay the same except for the <session-version> field, which MUST increment by one on each call to createOffer if the offer might differ from the output of the previous call to createOffer; implementations MAY opt to increment <session-version> on every call. The value of the generated <session-version> is independent of the <session-version> of the current local description; in particular, in the case where the current version is N, an offer is created and applied with version N+1, and then that offer is rolled back so that the current version is again N, the next generated offer will still have version N+2.",
      "ja": "* 「o =」行のフィールドは、<session-version>フィールドを除いて同じままである必要があります。<session-version>フィールドは、オファーがcreateOfferの前の呼び出しの出力と異なる可能性がある場合、createOfferの呼び出しごとに1ずつインクリメントする必要があります。実装は、呼び出しごとに<session-version>をインクリメントすることを選択できます（MAY）。生成された<session-version>の値は、現在のローカル記述の<session-version>とは無関係です。特に、現在のバージョンがNの場合、オファーはバージョンN 1で作成および適用され、そのオファーはロールバックされて現在のバージョンが再びNになり、次に生成されるオファーにはバージョンN2が残ります。。"
    },
    {
      "indent": 3,
      "text": "Note that if the application creates an offer by reading currentLocalDescription instead of calling createOffer, the returned SDP may be different than when setLocalDescription was originally called, due to the addition of gathered ICE candidates, but the <session-version> will not have changed. There are no known scenarios in which this causes problems, but if this is a concern, the solution is simply to use createOffer to ensure a unique <session-version>.",
      "ja": "アプリケーションがcreateOfferを呼び出す代わりにcurrentLocalDescriptionを読み取ってオファーを作成する場合、収集されたICE候補が追加されるため、返されるSDPはsetLocalDescriptionが最初に呼び出されたときとは異なる場合がありますが、<session-version>は変更されません。これが問題を引き起こす既知のシナリオはありませんが、これが懸念される場合の解決策は、createOfferを使用して一意の<session-version>を確保することです。"
    },
    {
      "indent": 3,
      "text": "If the previous offer was applied using setLocalDescription, but a corresponding answer from the remote side has not yet been applied, meaning the PeerConnection is still in the \"have-local-offer\" state, an offer is generated by following the steps in the \"stable\" state above, along with these exceptions:",
      "ja": "以前のオファーがsetLocalDescriptionを使用して適用されたが、リモート側からの対応する回答がまだ適用されていない場合、つまりPeerConnectionがまだ「ローカルオファーを持っている」状態である場合、オファーは「」の手順に従って生成されます。これらの例外とともに、上記の「安定した」状態："
    },
    {
      "indent": 3,
      "text": "* The \"s=\" and \"t=\" lines MUST stay the same.",
      "ja": "* 「s =」と「t =」の行は同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If any RtpTransceiver has been added and there exists an \"m=\" section with a zero port in the current local description or the current remote description, that \"m=\" section MUST be recycled by generating an \"m=\" section for the added RtpTransceiver as if the \"m=\" section were being added to the session description (including a new MID value) and placing it at the same index as the \"m=\" section with a zero port.",
      "ja": "* RtpTransceiverが追加されていて、現在のローカルの説明または現在のリモートの説明にゼロポートの「m =」セクションが存在する場合、その「m =」セクションは、追加された「m =」セクションを生成してリサイクルする必要があります。RtpTransceiverは、「m =」セクションがセッションの説明（新しいMID値を含む）に追加され、ポートがゼロの「m =」セクションと同じインデックスに配置されているかのように表示されます。"
    },
    {
      "indent": 3,
      "text": "* If an RtpTransceiver is stopped and is not associated with an \"m=\" section, an \"m=\" section MUST NOT be generated for it. This prevents adding back RtpTransceivers whose \"m=\" sections were recycled and used for a new RtpTransceiver in a previous offer/ answer exchange, as described above.",
      "ja": "* RtpTransceiverが停止していて、「m =」セクションに関連付けられていない場合、「m =」セクションを生成してはなりません（MUSTNOT）。これにより、上記のように、「m =」セクションがリサイクルされ、以前のオファー/アンサー交換で新しいRtpTransceiverに使用されたRtpTransceiverが追加されなくなります。"
    },
    {
      "indent": 3,
      "text": "* If an RtpTransceiver has been stopped and is associated with an \"m=\" section, and the \"m=\" section is not being recycled as described above, an \"m=\" section MUST be generated for it with the port set to zero and all \"a=msid\" lines removed.",
      "ja": "* RtpTransceiverが停止され、「m =」セクションに関連付けられていて、「m =」セクションが上記のようにリサイクルされていない場合、ポートをゼロに設定して「m =」セクションを生成する必要があります。すべての「a = msid」行が削除されました。"
    },
    {
      "indent": 3,
      "text": "* For RtpTransceivers that are not stopped, the \"a=msid\" line or lines MUST stay the same if they are present in the current description, regardless of changes to the transceiver's direction or track. If no \"a=msid\" line is present in the current description, \"a=msid\" line(s) MUST be generated according to the same rules as for an initial offer.",
      "ja": "* 停止していないRtpTransceiversの場合、「a = msid」ラインは、トランシーバーの方向またはトラックの変更に関係なく、現在の説明に存在する場合は同じままである必要があります。現在の説明に「a = msid」行が存在しない場合、「a = msid」行は、最初のオファーと同じルールに従って生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Each \"m=\" and \"c=\" line MUST be filled in with the port, relevant RTP profile, and address of the default candidate for the \"m=\" section, as described in [RFC8839], Section 4.2.1.2 and clarified in Section 5.1.2. If no RTP candidates have yet been gathered, default values MUST still be used, as described above.",
      "ja": "* [RFC8839]のセクション4.2.1.2で説明され、明確にされているように、各「m =」および「c =」行には、ポート、関連するRTPプロファイル、および「m =」セクションのデフォルト候補のアドレスを入力する必要があります。セクション5.1.2。RTP候補がまだ収集されていない場合でも、上記のようにデフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Each \"a=mid\" line MUST stay the same.",
      "ja": "* 各「a = mid」行は同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Each \"a=ice-ufrag\" and \"a=ice-pwd\" line MUST stay the same, unless the ICE configuration has changed (e.g., changes to either the supported STUN/TURN servers or the ICE candidate policy) or the IceRestart option (Section 5.2.3.1) was specified. If the \"m=\" section is bundled into another \"m=\" section, it still MUST NOT contain any ICE credentials.",
      "ja": "* 「a = ice-ufrag」と「a = ice-pwd」の各行は、ICE構成が変更されていない限り（たとえば、サポートされているSTUN / TURNサーバーまたはICE候補ポリシーのいずれかへの変更）、またはIceRestartオプションがない限り、同じままである必要があります。（セクション5.2.3.1）が指定されました。「m =」セクションが別の「m =」セクションにバンドルされている場合でも、ICE資格情報を含めてはなりません（MUSTNOT）。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section is not bundled into another \"m=\" section, its \"a=rtcp\" attribute line MUST be filled in with the port and address of the default RTCP candidate, as indicated in [RFC5761], Section 5.1.3. If no RTCP candidates have yet been gathered, default values MUST be used, as described in Section 5.2.1 above.",
      "ja": "* 「m =」セクションが別の「m =」セクションにバンドルされていない場合、[RFC5761]のセクション5.1に示されているように、その「a = rtcp」属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります。.3。RTCP候補がまだ収集されていない場合は、上記のセクション5.2.1で説明されているように、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section is not bundled into another \"m=\" section, for each candidate that has been gathered during the most recent gathering phase (see Section 3.5.1), an \"a=candidate\" line MUST be added, as defined in [RFC8839], Section 5.1. If candidate gathering for the section has completed, an \"a=end-of-candidates\" attribute MUST be added, as described in [RFC8840], Section 8.2. If the \"m=\" section is bundled into another \"m=\" section, both \"a=candidate\" and \"a=end-of-candidates\" MUST be omitted.",
      "ja": "* 「m =」セクションが別の「m =」セクションにバンドルされていない場合、最新の収集フェーズで収集された候補ごとに（セクション3.5.1を参照）、「a = candidate」行を追加する必要があります。[RFC8839]のセクション5.1で定義されているとおり。セクションの候補者の収集が完了した場合は、[RFC8840]のセクション8.2で説明されているように、「a = end-of-candidates」属性を追加する必要があります。「m =」セクションが別の「m =」セクションにバンドルされている場合は、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "* For RtpTransceivers that are still present, the \"a=rid\" lines MUST stay the same.",
      "ja": "* まだ存在しているRtpTransceiversの場合、「a = rid」行は同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* For RtpTransceivers that are still present, any \"a=simulcast\" line MUST stay the same.",
      "ja": "* まだ存在しているRtpTransceiversの場合、「a = simulcast」行は同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the previous offer was applied using setLocalDescription, and a corresponding answer from the remote side has been applied using setRemoteDescription, meaning the PeerConnection is in the \"have-remote-pranswer\" state or the \"stable\" state, an offer is generated based on the negotiated session descriptions by following the steps mentioned for the \"have-local-offer\" state above.",
      "ja": "以前のオファーがsetLocalDescriptionを使用して適用され、リモート側からの対応する回答がsetRemoteDescriptionを使用して適用された場合、つまりPeerConnectionが「have-remote-pranswer」状態または「stable」状態にある場合、オファーはに基づいて生成されます。上記の「have-local-offer」状態について説明した手順に従って、ネゴシエートされたセッションの説明。"
    },
    {
      "indent": 3,
      "text": "In addition, for each existing, non-recycled, non-rejected \"m=\" section in the new offer, the following adjustments are made based on the contents of the corresponding \"m=\" section in the current local or remote description, as appropriate:",
      "ja": "さらに、新しいオファーの既存の、リサイクルされていない、拒否されていない「m =」セクションごとに、現在のローカルまたはリモートの説明の対応する「m =」セクションの内容に基づいて、次の調整が行われます。適切な："
    },
    {
      "indent": 3,
      "text": "* The \"m=\" line and corresponding \"a=rtpmap\" and \"a=fmtp\" lines MUST only include media formats that have not been excluded by the codec preferences of the associated transceiver and also MUST include all currently available formats. Media formats that were previously offered but are no longer available (e.g., a shared hardware codec) MAY be excluded.",
      "ja": "* 「m =」行と対応する「a = rtpmap」および「a = fmtp」行には、関連するトランシーバーのコーデック設定によって除外されていないメディア形式のみを含める必要があり、現在使用可能なすべての形式も含める必要があります。以前に提供されていたが現在は使用できないメディア形式（共有ハードウェアコーデックなど）は除外される場合があります。"
    },
    {
      "indent": 3,
      "text": "* Unless codec preferences have been set for the associated transceiver, the media formats on the \"m=\" line MUST be generated in the same order as in the most recent answer. Any media formats that were not present in the most recent answer MUST be added after all existing formats.",
      "ja": "* 関連するトランシーバーにコーデック設定が設定されていない限り、「m =」行のメディア形式は、最新の回答と同じ順序で生成する必要があります。最新の回答に存在しなかったメディアフォーマットは、既存のすべてのフォーマットの後に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The RTP header extensions MUST only include those that are present in the most recent answer.",
      "ja": "* RTPヘッダー拡張には、最新の回答に存在するもののみを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* The RTCP feedback mechanisms MUST only include those that are present in the most recent answer, except for the case of format-specific mechanisms that are referencing a newly added media format.",
      "ja": "* RTCPフィードバックメカニズムには、新しく追加されたメディアフォーマットを参照するフォーマット固有のメカニズムの場合を除いて、最新の回答に存在するもののみを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"a=rtcp\" line MUST NOT be added if the most recent answer included an \"a=rtcp-mux\" line.",
      "ja": "* 最新の回答に「a = rtcp-mux」行が含まれている場合は、「a = rtcp」行を追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "* The \"a=rtcp-mux\" line MUST be the same as that in the most recent answer.",
      "ja": "* 「a = rtcp-mux」行は、最新の回答の行と同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"a=rtcp-mux-only\" line MUST NOT be added.",
      "ja": "* 「a = rtcp-mux-only」行を追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "* The \"a=rtcp-rsize\" line MUST NOT be added unless present in the most recent answer.",
      "ja": "* 「a = rtcp-rsize」行は、最新の回答に存在しない限り追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "* An \"a=bundle-only\" line, as defined in [RFC8843], Section 6, MUST NOT be added. Instead, JSEP implementations MUST simply omit parameters in the IDENTICAL and TRANSPORT categories for bundled \"m=\" sections, as described in [RFC8843], Section 7.1.3.",
      "ja": "* [RFC8843]のセクション6で定義されている「a = bundle-only」行を追加してはなりません。代わりに、JSEP実装は、[RFC8843]のセクション7.1.3で説明されているように、バンドルされた「m =」セクションのIDENTICALおよびTRANSPORTカテゴリのパラメータを単に省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Note that if media \"m=\" sections are bundled into a data \"m=\" section, then certain TRANSPORT and IDENTICAL attributes may appear in the data \"m=\" section even if they would otherwise only be appropriate for a media \"m=\" section (e.g., \"a=rtcp-mux\"). This cannot happen in initial offers because in the initial offer JSEP implementations always list media \"m=\" sections (if any) before the data \"m=\" section (if any), and at least one of those media \"m=\" sections will not have the \"a=bundle-only\" attribute. Therefore, in initial offers, any \"a=bundle-only\" \"m=\" sections will be bundled into a preceding non-bundle-only media \"m=\" section.",
      "ja": "* メディア \"m =\"セクションがデータ \"m =\"セクションにバンドルされている場合、特定のTRANSPORTおよびIDENTICAL属性は、メディア \"m =にのみ適切である場合でも、データ\" m = \"セクションに表示される場合があることに注意してください。\"セクション（例：\" a = rtcp-mux \"）。最初のオファーでは、JSEP実装は常に、データ \"m =\"セクション（存在する場合）の前にメディア \"m =\"セクション（存在する場合）をリストし、それらのメディア \"m =\"セクションの少なくとも1つをリストするため、これは初期オファーでは発生しません。「a = bundle-only」属性はありません。したがって、最初のオファーでは、「a = bundle-only」「m =」セクションは、先行する非バンドルのみのメディア「m =」セクションにバンドルされます。"
    },
    {
      "indent": 3,
      "text": "The \"a=group:BUNDLE\" attribute MUST include the MID identifiers specified in the bundle group in the most recent answer, minus any \"m=\" sections that have been marked as rejected, plus any newly added or re-enabled \"m=\" sections. In other words, the bundle attribute MUST contain all \"m=\" sections that were previously bundled, as long as they are still alive, as well as any new \"m=\" sections.",
      "ja": "「a = group：BUNDLE」属性には、最新の回答のバンドルグループで指定されたMID識別子から、拒否としてマークされた「m =」セクションと、新しく追加または再度有効化された「m =」を除いたものを含める必要があります。\"セクション。つまり、bundle属性には、以前にバンドルされたすべての「m =」セクションと、新しい「m =」セクションが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "\"a=group:LS\" attributes are generated in the same way as for initial offers, with the additional stipulation that any lip sync groups that were present in the most recent answer MUST continue to exist and MUST contain any previously existing MID identifiers, as long as the identified \"m=\" sections still exist and are not rejected, and the group still contains at least two MID identifiers. This ensures that any synchronized \"recvonly\" \"m=\" sections continue to be synchronized in the new offer.",
      "ja": "「a = group：LS」属性は、最初のオファーと同じ方法で生成されますが、最新の回答に存在したリップシンクグループは引き続き存在し、既存のMID識別子を含む必要があるという追加の規定があります。識別された「m =」セクションがまだ存在し、拒否されず、グループに少なくとも2つのMID識別子が含まれている限り。これにより、同期された「recvonly」「m =」セクションは、新しいオファーで引き続き同期されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Options Handling",
      "section_title": true,
      "ja": "5.2.3. オプションの取り扱い"
    },
    {
      "indent": 3,
      "text": "The createOffer method takes as a parameter an RTCOfferOptions object. Special processing is performed when generating an SDP description if the following options are present.",
      "ja": "createOfferメソッドは、RTCOfferOptionsオブジェクトをパラメーターとして受け取ります。次のオプションが存在する場合、SDP記述を生成するときに特別な処理が実行されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1. IceRestart",
      "section_title": true,
      "ja": "5.2.3.1. IceRestart"
    },
    {
      "indent": 3,
      "text": "If the IceRestart option is specified, with a value of \"true\", the offer MUST indicate an ICE restart by generating new ICE ufrag and pwd attributes, as specified in [RFC8839], Section 4.4.3.1.1. If this option is specified on an initial offer, it has no effect (since a new ICE ufrag and pwd are already generated). Similarly, if the ICE configuration has changed, this option has no effect, since new ufrag and pwd attributes will be generated automatically. This option is primarily useful for reestablishing connectivity in cases where failures are detected by the application.",
      "ja": "IceRestartオプションが指定され、値が「true」の場合、オファーは、[RFC8839]のセクション4.4.3.1.1で指定されているように、新しいICEufragおよびpwd属性を生成することによってICEの再起動を示さなければなりません。このオプションが最初のオファーで指定されている場合、効果はありません（新しいICE ufragとpwdがすでに生成されているため）。同様に、ICE構成が変更された場合、新しいufrag属性とpwd属性が自動的に生成されるため、このオプションは効果がありません。このオプションは主に、アプリケーションによって障害が検出された場合に接続を再確立するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2. VoiceActivityDetection",
      "section_title": true,
      "ja": "5.2.3.2. VoiceActivityDetection"
    },
    {
      "indent": 3,
      "text": "Silence suppression, also known as discontinuous transmission (\"DTX\"), can reduce the bandwidth used for audio by switching to a special encoding when voice activity is not detected, at the cost of some fidelity.",
      "ja": "不連続送信（「DTX」）とも呼ばれる無音抑制は、音声アクティビティが検出されないときに特別なエンコーディングに切り替えることにより、オーディオに使用される帯域幅を減らすことができますが、ある程度の忠実度が犠牲になります。"
    },
    {
      "indent": 3,
      "text": "If the \"VoiceActivityDetection\" option is specified, with a value of \"true\", the offer MUST indicate support for silence suppression in the audio it receives by including comfort noise (\"CN\") codecs for each offered audio codec, as specified in [RFC3389], Section 5.1, except for codecs that have their own internal silence suppression support. For codecs that have their own internal silence suppression support, the appropriate fmtp parameters for that codec MUST be specified to indicate that silence suppression for received audio is desired. For example, when using the Opus codec [RFC6716], the \"usedtx=1\" parameter, specified in [RFC7587], would be used in the offer.",
      "ja": "「VoiceActivityDetection」オプションが指定され、値が「true」の場合、オファーは、[で指定されているように、提供されるオーディオコーデックごとにコンフォートノイズ（「CN」）コーデックを含めることにより、受信するオーディオの無音抑制のサポートを示さなければなりません。RFC3389]、セクション5.1。ただし、独自の内部無音抑制サポートがあるコーデックは除きます。独自の内部無音抑制をサポートするコーデックの場合、受信したオーディオの無音抑制が必要であることを示すために、そのコーデックに適切なfmtpパラメータを指定する必要があります。たとえば、Opusコーデック[RFC6716]を使用する場合、[RFC7587]で指定された「usedtx = 1」パラメーターがオファーで使用されます。"
    },
    {
      "indent": 3,
      "text": "If the \"VoiceActivityDetection\" option is specified, with a value of \"false\", the JSEP implementation MUST NOT emit \"CN\" codecs. For codecs that have their own internal silence suppression support, the appropriate fmtp parameters for that codec MUST be specified to indicate that silence suppression for received audio is not desired. For example, when using the Opus codec, the \"usedtx=0\" parameter would be specified in the offer. In addition, the implementation MUST NOT use silence suppression for media it generates, regardless of whether the \"CN\" codecs or related fmtp parameters appear in the peer's description. The impact of these rules is that silence suppression in JSEP depends on mutual agreement of both sides, which ensures consistent handling regardless of which codec is used.",
      "ja": "「VoiceActivityDetection」オプションが指定され、値が「false」の場合、JSEP実装は「CN」コーデックを発行してはなりません（MUSTNOT）。独自の内部無音抑制をサポートするコーデックの場合、受信したオーディオの無音抑制が望ましくないことを示すために、そのコーデックに適切なfmtpパラメータを指定する必要があります。たとえば、Opusコーデックを使用する場合、「usedtx = 0」パラメーターがオファーで指定されます。さらに、実装は、「CN」コーデックまたは関連するfmtpパラメータがピアの説明に表示されているかどうかに関係なく、生成するメディアに無音抑制を使用してはなりません（MUSTNOT）。これらのルールの影響は、JSEPでの無音の抑制が双方の相互合意に依存していることです。これにより、使用されているコーデックに関係なく、一貫した処理が保証されます。"
    },
    {
      "indent": 3,
      "text": "The \"VoiceActivityDetection\" option does not have any impact on the setting of the \"vad\" value in the signaling of the client-to-mixer audio level header extension described in [RFC6464], Section 4.",
      "ja": "「VoiceActivityDetection」オプションは、[RFC6464]のセクション4で説明されているクライアントからミキサーへのオーディオレベルヘッダー拡張のシグナリングの「vad」値の設定には影響しません。"
    },
    {
      "indent": 0,
      "text": "5.3. Generating an Answer",
      "section_title": true,
      "ja": "5.3. 回答の生成"
    },
    {
      "indent": 3,
      "text": "When createAnswer is called, a new SDP description MUST be created that is compatible with the supplied remote description as well as the requirements specified in [RFC8834]. The exact details of this process are explained below.",
      "ja": "createAnswerが呼び出されると、提供されたリモート記述および[RFC8834]で指定された要件と互換性のある新しいSDP記述を作成する必要があります。このプロセスの正確な詳細を以下に説明します。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Initial Answers",
      "section_title": true,
      "ja": "5.3.1. 最初の回答"
    },
    {
      "indent": 3,
      "text": "When createAnswer is called for the first time after a remote description has been provided, the result is known as the initial answer. If no remote description has been installed, an answer cannot be generated, and an error MUST be returned.",
      "ja": "リモート記述が提供された後にcreateAnswerが初めて呼び出されたとき、その結果は初期応答と呼ばれます。リモート記述がインストールされていない場合、回答を生成することはできず、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the remote description SDP may not have been created by a JSEP endpoint and may not conform to all the requirements listed in Section 5.2. For many cases, this is not a problem. However, if any mandatory SDP attributes are missing or functionality listed as mandatory-to-use above is not present, this MUST be treated as an error and MUST cause the affected \"m=\" sections to be marked as rejected.",
      "ja": "リモート記述SDPはJSEPエンドポイントによって作成されていない可能性があり、セクション5.2にリストされているすべての要件に準拠していない可能性があることに注意してください。多くの場合、これは問題ではありません。ただし、必須のSDP属性が欠落している場合、または上記で必須としてリストされている機能が存在しない場合、これはエラーとして扱われ、影響を受ける「m =」セクションが拒否としてマークされる必要があります。"
    },
    {
      "indent": 3,
      "text": "The first step in generating an initial answer is to generate session-level attributes. The process here is identical to that indicated in Section 5.2.1 above, except that the \"a=ice-options\" line, with the \"trickle\" option as specified in [RFC8840], Section 4.1.3 and the \"ice2\" option as specified in [RFC8445], Section 10, is only included if such an option was present in the offer.",
      "ja": "最初の回答を生成する最初のステップは、セッションレベルの属性を生成することです。ここでのプロセスは、[RFC8840]のセクション4.1.3で指定されている「trickle」オプションと「ice2」オプションを使用した「a = ice-options」行を除いて、上記のセクション5.2.1で示したプロセスと同じです。[RFC8445]のセクション10で指定されているように、そのようなオプションがオファーに存在する場合にのみ含まれます。"
    },
    {
      "indent": 3,
      "text": "The next step is to generate session-level lip sync groups, as defined in [RFC5888], Section 7. For each group of type \"LS\" present in the offer, select the local RtpTransceivers that are referenced by the MID values in the specified group, and determine which of them either reference a common local MediaStream (specified in the calls to addTrack/addTransceiver used to create them) or have no MediaStream to reference because they were not created by addTrack/ addTransceiver. If at least two such RtpTransceivers exist, a group of type \"LS\" with the MID values of these RtpTransceivers MUST be added. Otherwise, the offered \"LS\" group MUST be ignored and no corresponding group generated in the answer.",
      "ja": "次のステップは、[RFC5888]のセクション7で定義されているように、セッションレベルのリップシンクグループを生成することです。オファーに存在するタイプ「LS」のグループごとに、指定されたMID値によって参照されるローカルRtpTransceiversを選択します。グループ化し、共通のローカルMediaStream（それらの作成に使用されたaddTrack / addTransceiverの呼び出しで指定）を参照するか、addTrack / addTransceiverによって作成されなかったために参照するMediaStreamがないかを判別します。そのようなRtpTransceiversが少なくとも2つ存在する場合は、これらのRtpTransceiversのMID値を持つタイプ「LS」のグループを追加する必要があります。それ以外の場合、提供された「LS」グループは無視されなければならず、対応するグループは回答で生成されません。"
    },
    {
      "indent": 3,
      "text": "As a simple example, consider the following offer of a single audio and single video track contained in the same MediaStream. SDP lines not relevant to this example have been removed for clarity. As explained in Section 5.2, a group of type \"LS\" has been added that references each track's RtpTransceiver.",
      "ja": "簡単な例として、同じMediaStreamに含まれる単一のオーディオトラックと単一のビデオトラックの次のオファーについて考えてみます。この例に関係のないSDP行は、わかりやすくするために削除されています。セクション5.2で説明したように、各トラックのRtpTransceiverを参照するタイプ「LS」のグループが追加されました。"
    },
    {
      "indent": 13,
      "text": "a=group:LS a1 v1\nm=audio 10000 UDP/TLS/RTP/SAVPF 0\na=mid:a1\na=msid:ms1\nm=video 10001 UDP/TLS/RTP/SAVPF 96\na=mid:v1\na=msid:ms1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the answerer uses a single MediaStream when it adds its tracks, both of its transceivers will reference this stream, and so the subsequent answer will contain a \"LS\" group identical to that in the offer, as shown below:",
      "ja": "回答者がトラックを追加するときに単一のMediaStreamを使用する場合、そのトランシーバーの両方がこのストリームを参照するため、次の回答には、以下に示すように、オファーと同じ「LS」グループが含まれます。"
    },
    {
      "indent": 13,
      "text": "a=group:LS a1 v1\nm=audio 20000 UDP/TLS/RTP/SAVPF 0\na=mid:a1\na=msid:ms2\nm=video 20001 UDP/TLS/RTP/SAVPF 96\na=mid:v1\na=msid:ms2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "However, if the answerer groups its tracks into separate MediaStreams, its transceivers will reference different streams, and so the subsequent answer will not contain a \"LS\" group.",
      "ja": "ただし、回答者がトラックを個別のMediaStreamにグループ化すると、トランシーバーは異なるストリームを参照するため、後続の回答には「LS」グループは含まれません。"
    },
    {
      "indent": 13,
      "text": "m=audio 20000 UDP/TLS/RTP/SAVPF 0\na=mid:a1\na=msid:ms2a\nm=video 20001 UDP/TLS/RTP/SAVPF 96\na=mid:v1\na=msid:ms2b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Finally, if the answerer does not add any tracks, its transceivers will not reference any MediaStreams, causing the preferences of the offerer to be maintained, and so the subsequent answer will contain an identical \"LS\" group.",
      "ja": "最後に、回答者がトラックを追加しない場合、そのトランシーバーはMediaStreamを参照しないため、提供者の設定が維持されるため、後続の回答には同一の「LS」グループが含まれます。"
    },
    {
      "indent": 13,
      "text": "a=group:LS a1 v1\nm=audio 20000 UDP/TLS/RTP/SAVPF 0\na=mid:a1\na=recvonly\nm=video 20001 UDP/TLS/RTP/SAVPF 96\na=mid:v1\na=recvonly",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The example in Section 7.2 shows a more involved case of \"LS\" group generation.",
      "ja": "セクション7.2の例は、「LS」グループ生成のより複雑なケースを示しています。"
    },
    {
      "indent": 3,
      "text": "The next step is to generate an \"m=\" section for each \"m=\" section that is present in the remote offer, as specified in [RFC3264], Section 6. For the purposes of this discussion, any session-level attributes in the offer that are also valid as media-level attributes are considered to be present in each \"m=\" section. Each offered \"m=\" section will have an associated RtpTransceiver, as described in Section 5.10. If there are more RtpTransceivers than there are \"m=\" sections, the unmatched RtpTransceivers will need to be associated in a subsequent offer.",
      "ja": "次のステップは、[RFC3264]のセクション6で指定されているように、リモートオファーに存在する「m =」セクションごとに「m =」セクションを生成することです。この説明の目的上、セッションレベルの属性はメディアレベルの属性としても有効なオファーは、各「m =」セクションに存在すると見なされます。セクション5.10で説明されているように、提供される各「m =」セクションには、関連付けられたRtpTransceiverがあります。「m =」セクションよりも多くのRtpTransceiversがある場合、一致しないRtpTransceiversを後続のオファーに関連付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "For each offered \"m=\" section, if any of the following conditions are true, the corresponding \"m=\" section in the answer MUST be marked as rejected by setting the <port> in the \"m=\" line to zero, as indicated in [RFC3264], Section 6, and further processing for this \"m=\" section can be skipped:",
      "ja": "提供された「m =」セクションごとに、次の条件のいずれかが当てはまる場合、「m =」行の<port>をゼロに設定して、回答の対応する「m =」セクションを拒否としてマークする必要があります。[RFC3264]のセクション6に示されているように、この「m =」セクションの以降の処理はスキップできます。"
    },
    {
      "indent": 3,
      "text": "* The associated RtpTransceiver has been stopped.",
      "ja": "* 関連するRtpTransceiverが停止しました。"
    },
    {
      "indent": 3,
      "text": "* There is no offered media format that is both supported and, if applicable, allowed by codec preferences.",
      "ja": "* サポートされており、該当する場合はコーデック設定で許可されているメディア形式は提供されていません。"
    },
    {
      "indent": 3,
      "text": "* The bundle policy is \"max-bundle\", and this is not the first \"m=\" section or in the same bundle group as the first \"m=\" section.",
      "ja": "* バンドルポリシーは「max-bundle」であり、これは最初の「m =」セクションでも、最初の「m =」セクションと同じバンドルグループ内でもありません。"
    },
    {
      "indent": 3,
      "text": "* The bundle policy is \"balanced\", and this is not the first \"m=\" section for this media type or in the same bundle group as the first \"m=\" section for this media type.",
      "ja": "* バンドルポリシーは「バランス」されており、これはこのメディアタイプの最初の「m =」セクションではなく、このメディアタイプの最初の「m =」セクションと同じバンドルグループ内でもありません。"
    },
    {
      "indent": 3,
      "text": "* This \"m=\" section is in a bundle group, and the group's offerer tagged \"m=\" section is being rejected due to one of the above reasons. This requires all \"m=\" sections in the bundle group to be rejected, as specified in [RFC8843], Section 7.3.3.",
      "ja": "* この「m =」セクションはバンドルグループに含まれており、「m =」セクションとタグ付けされたグループの提供者は、上記のいずれかの理由により拒否されています。これには、[RFC8843]のセクション7.3.3で指定されているように、バンドルグループ内のすべての「m =」セクションを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, each \"m=\" section in the answer MUST then be generated as specified in [RFC3264], Section 6.1. For the \"m=\" line itself, the following rules MUST be followed:",
      "ja": "それ以外の場合、回答の各「m =」セクションは、[RFC3264]のセクション6.1で指定されているように生成する必要があります。「m =」行自体については、次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* The <port> value would normally be set to the port of the default ICE candidate for this \"m=\" section, but given that no candidates are available yet, the default <port> value of 9 (Discard) MUST be used, as indicated in [RFC8840], Section 4.1.1.",
      "ja": "* <port>値は通常、この「m =」セクションのデフォルトのICE候補のポートに設定されますが、候補がまだ利用できない場合は、デフォルトの<port>値9（破棄）を使用する必要があります。[RFC8840]のセクション4.1.1に示されています。"
    },
    {
      "indent": 3,
      "text": "* The <proto> field MUST be set to exactly match the <proto> field for the corresponding \"m=\" line in the offer.",
      "ja": "* <proto>フィールドは、オファー内の対応する「m =」行の<proto>フィールドと完全に一致するように設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If codec preferences have been set for the associated transceiver, media formats MUST be generated in the corresponding order, regardless of what was offered, and MUST exclude any codecs not present in the codec preferences.",
      "ja": "* 関連するトランシーバーにコーデックプリファレンスが設定されている場合、メディアフォーマットは、提供されたものに関係なく、対応する順序で生成する必要があり、コーデックプリファレンスに存在しないコーデックを除外する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the media formats on the \"m=\" line MUST be generated in the same order as those offered in the current remote description, excluding any currently unsupported formats. Any currently available media formats that are not present in the current remote description MUST be added after all existing formats.",
      "ja": "* それ以外の場合、「m =」行のメディア形式は、現在サポートされていない形式を除いて、現在のリモート記述で提供されているものと同じ順序で生成する必要があります。現在のリモートディスクリプションに存在しない現在利用可能なメディアフォーマットは、既存のすべてのフォーマットの後に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "* In either case, the media formats in the answer MUST include at least one format that is present in the offer but MAY include formats that are locally supported but not present in the offer, as mentioned in [RFC3264], Section 6.1. If no common format exists, the \"m=\" section is rejected as described above.",
      "ja": "* いずれの場合も、回答のメディア形式には、オファーに存在するフォーマットを少なくとも1つ含める必要がありますが、[RFC3264]のセクション6.1に記載されているように、ローカルでサポートされているがオファーには存在しないフォーマットを含めることができます。一般的な形式が存在しない場合、「m =」セクションは上記のように拒否されます。"
    },
    {
      "indent": 3,
      "text": "The \"m=\" line MUST be followed immediately by a \"c=\" line, as specified in [RFC4566], Section 5.7. Again, as no candidates are available yet, the \"c=\" line MUST contain the default value \"IN IP4 0.0.0.0\", as defined in [RFC8840], Section 4.1.3.",
      "ja": "[RFC4566]のセクション5.7で指定されているように、「m =」行の直後に「c =」行を続ける必要があります。繰り返しになりますが、まだ候補がないため、[RFC8840]のセクション4.1.3で定義されているように、「c =」行にはデフォルト値「INIP40.0.0.0」が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "If the offer supports bundle, all \"m=\" sections to be bundled MUST use the same ICE credentials and candidates; all \"m=\" sections not being bundled MUST use unique ICE credentials and candidates. Each \"m=\" section MUST contain the following attributes (which are of attribute types other than IDENTICAL or TRANSPORT):",
      "ja": "オファーがバンドルをサポートしている場合、バンドルされるすべての「m =」セクションは、同じICE資格情報と候補を使用する必要があります。バンドルされていないすべての「m =」セクションは、一意のICE資格情報と候補を使用する必要があります。各「m =」セクションには、次の属性（IDENTICALまたはTRANSPORT以外の属性タイプ）が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "* If and only if present in the offer, an \"a=mid\" line, as specified in [RFC5888], Section 9.1. The MID value MUST match that specified in the offer.",
      "ja": "* オファーに存在する場合に限り、[RFC5888]のセクション9.1で指定されている「a = mid」行。MID値は、オファーで指定された値と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* A direction attribute, determined by applying the rules regarding the offered direction specified in [RFC3264], Section 6.1, and then intersecting with the direction of the associated RtpTransceiver. For example, in the case where an \"m=\" section is offered as \"sendonly\" and the local transceiver is set to \"sendrecv\", the result in the answer is a \"recvonly\" direction.",
      "ja": "* [RFC3264]のセクション6.1で指定された提供された方向に関するルールを適用し、関連するRtpTransceiverの方向と交差することによって決定される方向属性。たとえば、「m =」セクションが「sendonly」として提供され、ローカルトランシーバーが「sendrecv」に設定されている場合、回答の結果は「recvonly」方向になります。"
    },
    {
      "indent": 3,
      "text": "* For each media format on the \"m=\" line, \"a=rtpmap\" and \"a=fmtp\" lines, as specified in [RFC4566], Section 6 and [RFC3264], Section 6.1.",
      "ja": "* [RFC4566]のセクション6および[RFC3264]のセクション6.1で指定されているように、「m =」行、「a = rtpmap」および「a = fmtp」行の各メディア形式について。"
    },
    {
      "indent": 3,
      "text": "* If \"rtx\" is present in the offer, for each primary codec where RTP retransmission should be used, a corresponding \"a=rtpmap\" line indicating \"rtx\" with the clock rate of the primary codec and an \"a=fmtp\" line that references the payload type of the primary codec, as specified in [RFC4588], Section 8.1.",
      "ja": "* オファーに「rtx」が存在する場合、RTP再送信を使用する必要があるプライマリコーデックごとに、プライマリコーデックのクロックレートで「rtx」を示す対応する「a = rtpmap」行と、次の「a = fmtp」行[RFC4588]のセクション8.1で指定されているように、プライマリコーデックのペイロードタイプを参照します。"
    },
    {
      "indent": 3,
      "text": "* For each supported FEC mechanism, \"a=rtpmap\" and \"a=fmtp\" lines, as specified in [RFC4566], Section 6. The FEC mechanisms that MUST be supported are specified in [RFC8854], Section 7, and specific usage for each media type is outlined in Sections 4 and 5.",
      "ja": "* サポートされているFECメカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行。サポートされなければならないFECメカニズムは、[RFC8854]のセクション7で指定されています。各メディアタイプの概要はセクション4と5にあります。"
    },
    {
      "indent": 3,
      "text": "* If this \"m=\" section is for media with configurable durations of media per packet, e.g., audio, an \"a=maxptime\" line, as described in Section 5.2.",
      "ja": "* この「m =」セクションが、パケットあたりのメディアの期間を構成可能なメディア用である場合（オーディオなど）、セクション5.2で説明されているように、「a = maxptime」行。"
    },
    {
      "indent": 3,
      "text": "* If this \"m=\" section is for video media and there are known limitations on the size of images that can be decoded, an \"a=imageattr\" line, as specified in Section 3.6.",
      "ja": "* この「m =」セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合は、セクション3.6で指定されている「a = imageattr」行。"
    },
    {
      "indent": 3,
      "text": "* For each supported RTP header extension that is present in the offer, an \"a=extmap\" line, as specified in [RFC5285], Section 5. The list of header extensions that SHOULD/MUST be supported is specified in [RFC8834], Section 5.2. Any header extensions that require encryption MUST be specified as indicated in [RFC6904], Section 4.",
      "ja": "* オファーに存在するサポートされているRTPヘッダー拡張ごとに、[RFC5285]のセクション5で指定されている「a = extmap」行。サポートされるべき/サポートされなければならないヘッダー拡張のリストは、[RFC8834]のセクションで指定されています。5.2。暗号化が必要なヘッダー拡張は、[RFC6904]のセクション4に示されているように指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* For each supported RTCP feedback mechanism that is present in the offer, an \"a=rtcp-fb\" line, as specified in [RFC4585], Section 4.2. The list of RTCP feedback mechanisms that SHOULD/ MUST be supported is specified in [RFC8834], Section 5.1.",
      "ja": "* オファーに存在するサポートされているRTCPフィードバックメカニズムごとに、[RFC4585]のセクション4.2で指定されている「a = rtcp-fb」行。サポートする必要がある/サポートする必要があるRTCPフィードバックメカニズムのリストは、[RFC8834]のセクション5.1で指定されています。"
    },
    {
      "indent": 3,
      "text": "* If the RtpTransceiver has a sendrecv or sendonly direction:",
      "ja": "* RtpTransceiverにsendrecvまたはsendonly方向がある場合："
    },
    {
      "indent": 6,
      "text": "- For each MediaStream that was associated with the transceiver when it was created via addTrack or addTransceiver, an \"a=msid\" line, as specified in [RFC8830], Section 2, but omitting the \"appdata\" field.",
      "ja": "- addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられたMediaStreamごとに、[RFC8830]のセクション2で指定されているように、「appdata」フィールドを省略した「a = msid」行。"
    },
    {
      "indent": 3,
      "text": "Each \"m=\" section that is not bundled into another \"m=\" section MUST contain the following attributes (which are of category IDENTICAL or TRANSPORT):",
      "ja": "別の「m =」セクションにバンドルされていない各「m =」セクションには、次の属性が含まれている必要があります（カテゴリIDENTICALまたはTRANSPORT）。"
    },
    {
      "indent": 3,
      "text": "* \"a=ice-ufrag\" and \"a=ice-pwd\" lines, as specified in [RFC8839], Section 5.4.",
      "ja": "* [RFC8839]のセクション5.4で指定されている、「a = ice-ufrag」および「a = ice-pwd」の行。"
    },
    {
      "indent": 3,
      "text": "* For each desired digest algorithm, one or more \"a=fingerprint\" lines for each of the endpoint's certificates, as specified in [RFC8122], Section 5.",
      "ja": "* [RFC8122]のセクション5で指定されているように、必要なダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行。"
    },
    {
      "indent": 3,
      "text": "* An \"a=setup\" line, as specified in [RFC4145], Section 4 and clarified for use in DTLS-SRTP scenarios in [RFC5763], Section 5. The role value in the answer MUST be \"active\" or \"passive\". When the offer contains the \"actpass\" value, as will always be the case with JSEP endpoints, the answerer SHOULD use the \"active\" role. Offers from non-JSEP endpoints MAY send other values for \"a=setup\", in which case the answer MUST use a value consistent with the value in the offer.",
      "ja": "* [RFC4145]のセクション4で指定され、[RFC5763]のセクション5でDTLS-SRTPシナリオで使用するために明確化された、「a = setup」行。回答の役割値は「アクティブ」または「パッシブ」である必要があります。JSEPエンドポイントの場合に常にそうであるように、オファーに「actpass」値が含まれている場合、回答者は「アクティブ」ロールを使用する必要があります。非JSEPエンドポイントからのオファーは、「a = setup」に他の値を送信する場合があります。その場合、回答はオファーの値と一致する値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* An \"a=tls-id\" line, as specified in [RFC8842], Section 5.3.",
      "ja": "* [RFC8842]のセクション5.3で指定されている「a = tls-id」行。"
    },
    {
      "indent": 3,
      "text": "* If present in the offer, an \"a=rtcp-mux\" line, as specified in [RFC5761], Section 5.1.3. Otherwise, an \"a=rtcp\" line, as specified in [RFC3605], Section 2.1, containing the default value \"9 IN IP4 0.0.0.0\" (because no candidates have yet been gathered).",
      "ja": "* オファーに存在する場合は、[RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行。それ以外の場合は、[RFC3605]のセクション2.1で指定されているように、デフォルト値「9 IN IP40.0.0.0」を含む「a = rtcp」行（候補がまだ収集されていないため）。"
    },
    {
      "indent": 3,
      "text": "* If present in the offer, an \"a=rtcp-rsize\" line, as specified in [RFC5506], Section 5.",
      "ja": "* オファーに存在する場合は、[RFC5506]のセクション5で指定されている「a = rtcp-rsize」行。"
    },
    {
      "indent": 3,
      "text": "If a data channel \"m=\" section has been offered, an \"m=\" section MUST also be generated for data. The <media> field MUST be set to \"application\", and the <proto> and <fmt> fields MUST be set to exactly match the fields in the offer.",
      "ja": "データチャネル「m =」セクションが提供されている場合、「m =」セクションもデータ用に生成する必要があります。<media>フィールドは「application」に設定する必要があり、<proto>フィールドと<fmt>フィールドはオファーのフィールドと完全に一致するように設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Within the data \"m=\" section, an \"a=mid\" line MUST be generated and included as described above, along with an \"a=sctp-port\" line referencing the SCTP port number, as defined in [RFC8841], Section 5.1; and, if appropriate, an \"a=max-message-size\" line, as defined in [RFC8841], Section 6.1.",
      "ja": "データ「m =」セクション内で、「a = mid」行を生成し、上記のように含める必要があります。また、[RFC8841]のセクションで定義されているように、SCTPポート番号を参照する「a = sctp-port」行も含める必要があります。5.1;また、必要に応じて、[RFC8841]のセクション6.1で定義されている「a = max-message-size」行。"
    },
    {
      "indent": 3,
      "text": "As discussed above, the following attributes of category IDENTICAL or TRANSPORT are included only if the data \"m=\" section is not bundled into another \"m=\" section:",
      "ja": "上で説明したように、カテゴリIDENTICALまたはTRANSPORTの次の属性は、データ「m =」セクションが別の「m =」セクションにバンドルされていない場合にのみ含まれます。"
    },
    {
      "indent": 3,
      "text": "* \"a=ice-ufrag\"",
      "ja": "* 「a = ice-ufrag」"
    },
    {
      "indent": 3,
      "text": "* \"a=ice-pwd\"",
      "ja": "* 「a = ice-pwd」"
    },
    {
      "indent": 3,
      "text": "* \"a=fingerprint\"",
      "ja": "* 「a =指紋」"
    },
    {
      "indent": 3,
      "text": "* \"a=setup\"",
      "ja": "* 「a = setup」"
    },
    {
      "indent": 3,
      "text": "* \"a=tls-id\"",
      "ja": "* \"a = tls-id\""
    },
    {
      "indent": 3,
      "text": "Note that if media \"m=\" sections are bundled into a data \"m=\" section, then certain TRANSPORT and IDENTICAL attributes may also appear in the data \"m=\" section even if they would otherwise only be appropriate for a media \"m=\" section (e.g., \"a=rtcp-mux\").",
      "ja": "メディア「m =」セクションがデータ「m =」セクションにバンドルされている場合、特定のTRANSPORTおよびIDENTICAL属性は、メディア「m」にのみ適切である場合でも、データ「m =」セクションに表示される場合があることに注意してください。= \"セクション（例：\" a = rtcp-mux \"）。"
    },
    {
      "indent": 3,
      "text": "If \"a=group\" attributes with semantics of \"BUNDLE\" are offered, corresponding session-level \"a=group\" attributes MUST be added as specified in [RFC5888]. These attributes MUST have semantics \"BUNDLE\" and MUST include all mid identifiers from the offered bundle groups that have not been rejected. Note that regardless of the presence of \"a=bundle-only\" in the offer, all \"m=\" sections in the answer MUST NOT have an \"a=bundle-only\" line.",
      "ja": "「BUNDLE」のセマンティクスを持つ「a = group」属性が提供される場合、[RFC5888]で指定されているように、対応するセッションレベルの「a = group」属性を追加する必要があります。これらの属性は、セマンティクス「BUNDLE」を持たなければならず、拒否されていない提供されたバンドルグループからのすべての中間識別子を含まなければなりません。オファーに「a = bundle-only」が含まれているかどうかに関係なく、回答のすべての「m =」セクションに「a = bundle-only」行を含めてはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Attributes that are common between all \"m=\" sections MAY be moved to the session level if explicitly defined to be valid at the session level.",
      "ja": "すべての「m =」セクションに共通の属性は、セッションレベルで有効であると明示的に定義されている場合、セッションレベルに移動できます。"
    },
    {
      "indent": 3,
      "text": "The attributes prohibited in the creation of offers are also prohibited in the creation of answers.",
      "ja": "オファーの作成で禁止されている属性は、回答の作成でも禁止されています。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Subsequent Answers",
      "section_title": true,
      "ja": "5.3.2. 後続の回答"
    },
    {
      "indent": 3,
      "text": "When createAnswer is called a second (or later) time or is called after a local description has already been installed, the processing is somewhat different than for an initial answer.",
      "ja": "createAnswerが2回目（またはそれ以降）に呼び出された場合、またはローカル記述がすでにインストールされた後に呼び出された場合、処理は最初の応答の場合とは多少異なります。"
    },
    {
      "indent": 3,
      "text": "If the previous answer was not applied using setLocalDescription, meaning the PeerConnection is still in the \"have-remote-offer\" state, the steps for generating an initial answer MUST be followed, subject to the following restriction:",
      "ja": "以前の回答がsetLocalDescriptionを使用して適用されなかった場合、つまりPeerConnectionがまだ「have-remote-offer」状態にある場合、次の制限に従って、最初の回答を生成する手順に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* The fields of the \"o=\" line MUST stay the same except for the <session-version> field, which MUST increment if the session description changes in any way from the previously generated answer.",
      "ja": "* 「o =」行のフィールドは、<session-version>フィールドを除いて同じままである必要があります。ただし、セッションの説明が以前に生成された回答から何らかの方法で変更された場合はインクリメントする必要があります。"
    },
    {
      "indent": 3,
      "text": "If any session description was previously supplied to setLocalDescription, an answer is generated by following the steps in the \"have-remote-offer\" state above, along with these exceptions:",
      "ja": "以前にsetLocalDescriptionにセッションの説明が指定されていた場合は、上記の「have-remote-offer」状態の手順に従って、次の例外とともに回答が生成されます。"
    },
    {
      "indent": 3,
      "text": "* The \"s=\" and \"t=\" lines MUST stay the same.",
      "ja": "* 「s =」と「t =」の行は同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Each \"m=\" and \"c=\" line MUST be filled in with the port and address of the default candidate for the \"m=\" section, as described in [RFC8839], Section 4.2.1.2. Note that in certain cases, the \"m=\" line protocol may not match that of the default candidate, because the \"m=\" line protocol value MUST match what was supplied in the offer, as described above.",
      "ja": "* [RFC8839]のセクション4.2.1.2で説明されているように、「m =」と「c =」の各行には、「m =」セクションのデフォルト候補のポートとアドレスを入力する必要があります。上記のように、「m =」ラインプロトコル値はオファーで提供されたものと一致する必要があるため、「m =」ラインプロトコルがデフォルト候補の値と一致しない場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "* Each \"a=ice-ufrag\" and \"a=ice-pwd\" line MUST stay the same, unless the \"m=\" section is restarting, in which case new ICE credentials MUST be created as specified in [RFC8839], Section 4.4.1.1.1. If the \"m=\" section is bundled into another \"m=\" section, it still MUST NOT contain any ICE credentials.",
      "ja": "* 「m =」セクションが再起動しない限り、「a = ice-ufrag」と「a = ice-pwd」の各行は同じままである必要があります。再起動する場合は、[RFC8839]のセクション4.4で指定されているように新しいICE資格情報を作成する必要があります。.1.1.1。「m =」セクションが別の「m =」セクションにバンドルされている場合でも、ICE資格情報を含めてはなりません（MUSTNOT）。"
    },
    {
      "indent": 3,
      "text": "* Each \"a=tls-id\" line MUST stay the same, unless the offerer's \"a=tls-id\" line changed, in which case a new tls-id value MUST be created, as described in [RFC8842], Section 5.2.",
      "ja": "* [RFC8842]のセクション5.2で説明されているように、提供者の「a = tls-id」行が変更された場合を除き、各「a = tls-id」行は同じままである必要があります。変更された場合は、新しいtls-id値を作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Each \"a=setup\" line MUST use an \"active\" or \"passive\" role value consistent with the existing DTLS association, if the association is being continued by the offerer.",
      "ja": "* アソシエーションが提供者によって継続されている場合、各「a = setup」行は、既存のDTLSアソシエーションと一致する「アクティブ」または「パッシブ」ロール値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* RTCP multiplexing MUST be used, and an \"a=rtcp-mux\" line inserted if and only if the \"m=\" section previously used RTCP multiplexing.",
      "ja": "* 「m =」セクションが以前にRTCP多重化を使用した場合に限り、RTCP多重化を使用する必要があり、「a = rtcp-mux」行を挿入します。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section is not bundled into another \"m=\" section and RTCP multiplexing is not active, an \"a=rtcp\" attribute line MUST be filled in with the port and address of the default RTCP candidate. If no RTCP candidates have yet been gathered, default values MUST be used, as described in Section 5.3.1 above.",
      "ja": "* 「m =」セクションが別の「m =」セクションにバンドルされておらず、RTCP多重化がアクティブでない場合、「a = rtcp」属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります。RTCP候補がまだ収集されていない場合は、上記のセクション5.3.1で説明されているように、デフォルト値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section is not bundled into another \"m=\" section, for each candidate that has been gathered during the most recent gathering phase (see Section 3.5.1), an \"a=candidate\" line MUST be added, as defined in [RFC8839], Section 5.1. If candidate gathering for the section has completed, an \"a=end-of-candidates\" attribute MUST be added, as described in [RFC8840], Section 8.2. If the \"m=\" section is bundled into another \"m=\" section, both \"a=candidate\" and \"a=end-of-candidates\" MUST be omitted.",
      "ja": "* 「m =」セクションが別の「m =」セクションにバンドルされていない場合、最新の収集フェーズで収集された候補ごとに（セクション3.5.1を参照）、「a = candidate」行を追加する必要があります。[RFC8839]のセクション5.1で定義されているとおり。セクションの候補者の収集が完了した場合は、[RFC8840]のセクション8.2で説明されているように、「a = end-of-candidates」属性を追加する必要があります。「m =」セクションが別の「m =」セクションにバンドルされている場合は、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "* For RtpTransceivers that are not stopped, the \"a=msid\" line(s) MUST stay the same, regardless of changes to the transceiver's direction or track. If no \"a=msid\" line is present in the current description, \"a=msid\" line(s) MUST be generated according to the same rules as for an initial answer.",
      "ja": "* 停止していないRtpTransceiversの場合、トランシーバーの方向またはトラックの変更に関係なく、「a = msid」ラインは同じままである必要があります。現在の説明に「a = msid」行が存在しない場合、「a = msid」行は、最初の回答と同じルールに従って生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Options Handling",
      "section_title": true,
      "ja": "5.3.3. オプションの取り扱い"
    },
    {
      "indent": 3,
      "text": "The createAnswer method takes as a parameter an RTCAnswerOptions object. The set of parameters for RTCAnswerOptions is different than those supported in RTCOfferOptions; the IceRestart option is unnecessary, as ICE credentials will automatically be changed for all \"m=\" sections where the offerer chose to perform ICE restart.",
      "ja": "createAnswerメソッドは、パラメーターとしてRTCAnswerOptionsオブジェクトを取ります。RTCAnswerOptionsのパラメーターのセットは、RTCOfferOptionsでサポートされているものとは異なります。提供者がICEの再起動を実行することを選択したすべての「m =」セクションのICE資格情報が自動的に変更されるため、IceRestartオプションは不要です。"
    },
    {
      "indent": 3,
      "text": "The following options are supported in RTCAnswerOptions.",
      "ja": "次のオプションはRTCAnswerOptionsでサポートされています。"
    },
    {
      "indent": 0,
      "text": "5.3.3.1. VoiceActivityDetection",
      "section_title": true,
      "ja": "5.3.3.1. VoiceActivityDetection"
    },
    {
      "indent": 3,
      "text": "Silence suppression in the answer is handled as described in Section 5.2.3.2, with one exception: if support for silence suppression was not indicated in the offer, the VoiceActivityDetection parameter has no effect, and the answer MUST be generated as if VoiceActivityDetection was set to \"false\". This is done on a per-codec basis (e.g., if the offerer somehow offered support for CN but set \"usedtx=0\" for Opus, setting VoiceActivityDetection to \"true\" would result in an answer with CN codecs and \"usedtx=0\"). The impact of this rule is that an answerer will not try to use silence suppression with any endpoint that does not offer it, making silence suppression support bilateral even with non-JSEP endpoints.",
      "ja": "回答の無音抑制は、セクション5.2.3.2で説明されているように処理されますが、1つの例外があります。オファーで無音抑制のサポートが示されていない場合、VoiceActivityDetectionパラメーターは効果がなく、VoiceActivityDetectionがに設定されているかのように回答を生成する必要があります。「false」。これはコーデックごとに行われます（たとえば、提供者が何らかの理由でCNのサポートを提供したが、Opusに「usedtx = 0」を設定した場合、VoiceActivityDetectionを「true」に設定すると、CNコーデックと「usedtx = 0」で応答が返されます。）。このルールの影響は、回答者がそれを提供しないエンドポイントで無音抑制を使用しようとしないことであり、JSEP以外のエンドポイントでも無音抑制を二国間でサポートします。"
    },
    {
      "indent": 0,
      "text": "5.4. Modifying an Offer or Answer",
      "section_title": true,
      "ja": "5.4. オファーまたはアンサーの変更"
    },
    {
      "indent": 3,
      "text": "The SDP returned from createOffer or createAnswer MUST NOT be changed before passing it to setLocalDescription. If precise control over the SDP is needed, the aforementioned createOffer/createAnswer options or RtpTransceiver APIs MUST be used.",
      "ja": "createOfferまたはcreateAnswerから返されたSDPは、setLocalDescriptionに渡す前に変更してはなりません（MUSTNOT）。SDPを正確に制御する必要がある場合は、前述のcreateOffer / createAnswerオプションまたはRtpTransceiverAPIを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "After calling setLocalDescription with an offer or answer, the application MAY modify the SDP to reduce its capabilities before sending it to the far side, as long as it follows the rules above that define a valid JSEP offer or answer. Likewise, an application that has received an offer or answer from a peer MAY modify the received SDP, subject to the same constraints, before calling setRemoteDescription.",
      "ja": "オファーまたはアンサーを使用してsetLocalDescriptionを呼び出した後、アプリケーションは、有効なJSEPオファーまたはアンサーを定義する上記のルールに従っている限り、SDPを変更して機能を減らしてからファーサイドに送信できます。同様に、ピアからオファーまたはアンサーを受信したアプリケーションは、setRemoteDescriptionを呼び出す前に、同じ制約に従って、受信したSDPを変更できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "As always, the application is solely responsible for what it sends to the other party, and all incoming SDP will be processed by the JSEP implementation to the extent of its capabilities. It is an error to assume that all SDP is well formed; however, one should be able to assume that any implementation of this specification will be able to process, as a remote offer or answer, unmodified SDP coming from any other implementation of this specification.",
      "ja": "いつものように、アプリケーションは相手に送信するものに対して単独で責任があり、すべての着信SDPは、その機能の範囲内でJSEP実装によって処理されます。すべてのSDPが適切に形成されていると仮定するのは誤りです。ただし、この仕様の実装は、この仕様の他の実装からの変更されていないSDPをリモートオファーまたはアンサーとして処理できると想定できるはずです。"
    },
    {
      "indent": 0,
      "text": "5.5. Processing a Local Description",
      "section_title": true,
      "ja": "5.5. ローカル記述の処理"
    },
    {
      "indent": 3,
      "text": "When a SessionDescription is supplied to setLocalDescription, the following steps MUST be performed:",
      "ja": "SessionDescriptionがsetLocalDescriptionに提供される場合、以下のステップを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the description is of type \"rollback\", follow the processing defined in Section 5.7 and skip the processing described in the rest of this section.",
      "ja": "* 説明のタイプが「ロールバック」の場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the type of the SessionDescription is checked against the current state of the PeerConnection:",
      "ja": "* それ以外の場合、SessionDescriptionのタイプはPeerConnectionの現在の状態と照合されます。"
    },
    {
      "indent": 6,
      "text": "- If the type is \"offer\", the PeerConnection state MUST be either \"stable\" or \"have-local-offer\".",
      "ja": "- タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-local-offer」のいずれかでなければなりません。"
    },
    {
      "indent": 6,
      "text": "- If the type is \"pranswer\" or \"answer\", the PeerConnection state MUST be either \"have-remote-offer\" or \"have-local-pranswer\".",
      "ja": "- タイプが「pranswer」または「answer」の場合、PeerConnectionの状態は「have-remote-offer」または「have-local-pranswer」のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the type is not correct for the current state, processing MUST stop and an error MUST be returned.",
      "ja": "* タイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* The SessionDescription is then checked to ensure that its contents are identical to those generated in the last call to createOffer/ createAnswer, and thus have not been altered, as discussed in Section 5.4; otherwise, processing MUST stop and an error MUST be returned.",
      "ja": "* 次に、SessionDescriptionをチェックして、その内容がcreateOffer / createAnswerの最後の呼び出しで生成されたものと同じであり、セクション5.4で説明したように変更されていないことを確認します。それ以外の場合は、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* Next, the SessionDescription is parsed into a data structure, as described in Section 5.8 below.",
      "ja": "* 次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます。"
    },
    {
      "indent": 3,
      "text": "* Finally, the parsed SessionDescription is applied as described in Section 5.9 below.",
      "ja": "* 最後に、以下のセクション5.9で説明するように、解析されたSessionDescriptionが適用されます。"
    },
    {
      "indent": 0,
      "text": "5.6. Processing a Remote Description",
      "section_title": true,
      "ja": "5.6. リモート記述の処理"
    },
    {
      "indent": 3,
      "text": "When a SessionDescription is supplied to setRemoteDescription, the following steps MUST be performed:",
      "ja": "SessionDescriptionがsetRemoteDescriptionに提供される場合、以下のステップを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the description is of type \"rollback\", follow the processing defined in Section 5.7 and skip the processing described in the rest of this section.",
      "ja": "* 説明のタイプが「ロールバック」の場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the type of the SessionDescription is checked against the current state of the PeerConnection:",
      "ja": "* それ以外の場合、SessionDescriptionのタイプはPeerConnectionの現在の状態と照合されます。"
    },
    {
      "indent": 6,
      "text": "- If the type is \"offer\", the PeerConnection state MUST be either \"stable\" or \"have-remote-offer\".",
      "ja": "- タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-remote-offer」のいずれかである必要があります。"
    },
    {
      "indent": 6,
      "text": "- If the type is \"pranswer\" or \"answer\", the PeerConnection state MUST be either \"have-local-offer\" or \"have-remote-pranswer\".",
      "ja": "- タイプが「pranswer」または「answer」の場合、PeerConnectionの状態は「have-local-offer」または「have-remote-pranswer」のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the type is not correct for the current state, processing MUST stop and an error MUST be returned.",
      "ja": "* タイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* Next, the SessionDescription is parsed into a data structure, as described in Section 5.8 below. If parsing fails for any reason, processing MUST stop and an error MUST be returned.",
      "ja": "* 次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます。何らかの理由で解析が失敗した場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* Finally, the parsed SessionDescription is applied as described in Section 5.10 below.",
      "ja": "* 最後に、以下のセクション5.10で説明するように、解析されたSessionDescriptionが適用されます。"
    },
    {
      "indent": 0,
      "text": "5.7. Processing a Rollback",
      "section_title": true,
      "ja": "5.7. ロールバックの処理"
    },
    {
      "indent": 3,
      "text": "A rollback may be performed if the PeerConnection is in any state except for \"stable\". This means that both offers and provisional answers can be rolled back. Rollback can only be used to cancel proposed changes; there is no support for rolling back from a \"stable\" state to a previous \"stable\" state. If a rollback is attempted in the \"stable\" state, processing MUST stop and an error MUST be returned. Note that this implies that once the answerer has performed setLocalDescription with its answer, this cannot be rolled back.",
      "ja": "PeerConnectionが「安定」以外の状態にある場合、ロールバックが実行される可能性があります。これは、オファーと暫定回答の両方をロールバックできることを意味します。ロールバックは、提案された変更をキャンセルするためにのみ使用できます。「安定」状態から以前の「安定」状態へのロールバックはサポートされていません。「安定した」状態でロールバックが試行された場合、処理を停止し、エラーを返す必要があります。これは、回答者が回答に対してsetLocalDescriptionを実行すると、これをロールバックできないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "The effect of rollback MUST be the same regardless of whether setLocalDescription or setRemoteDescription is called.",
      "ja": "setLocalDescriptionまたはsetRemoteDescriptionのどちらが呼び出されたかに関係なく、ロールバックの効果は同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to process rollback, a JSEP implementation abandons the current offer/answer transaction, sets the signaling state to \"stable\", and sets the pending local and/or remote description (see Sections 4.1.14 and 4.1.16) to \"null\". Any resources or candidates that were allocated by the abandoned local description are discarded; any media that is received is processed according to the previous local and remote descriptions.",
      "ja": "ロールバックを処理するために、JSEP実装は現在のオファー/アンサートランザクションを破棄し、シグナリング状態を「安定」に設定し、保留中のローカルおよび/またはリモートの説明（セクション4.1.14および4.1.16を参照）を「null」に設定します。\"。放棄されたローカル記述によって割り当てられたリソースまたは候補はすべて破棄されます。受信したメディアはすべて、以前のローカルおよびリモートの説明に従って処理されます。"
    },
    {
      "indent": 3,
      "text": "A rollback disassociates any RtpTransceivers that were associated with \"m=\" sections by the application of the rolled-back session description (see Sections 5.10 and 5.9). This means that some RtpTransceivers that were previously associated will no longer be associated with any \"m=\" section; in such cases, the value of the RtpTransceiver's mid property MUST be set to \"null\", and the mapping between the transceiver and its \"m=\" section index MUST be discarded. RtpTransceivers that were created by applying a remote offer that was subsequently rolled back MUST be stopped and removed from the PeerConnection. However, an RtpTransceiver MUST NOT be removed if a track was attached to the RtpTransceiver via the addTrack method. This is so that an application may call addTrack, then call setRemoteDescription with an offer, then roll back that offer, then call createOffer and have an \"m=\" section for the added track appear in the generated offer.",
      "ja": "ロールバックは、ロールバックされたセッションの説明を適用することにより、「m =」セクションに関連付けられていたRtpTransceiversの関連付けを解除します（セクション5.10および5.9を参照）。これは、以前に関連付けられていた一部のRtpTransceiverが「m =」セクションに関連付けられなくなることを意味します。このような場合、RtpTransceiverのmidプロパティの値を「null」に設定する必要があり、トランシーバーとその「m =」セクションインデックス間のマッピングを破棄する必要があります。その後ロールバックされたリモートオファーを適用することによって作成されたRtpTransceiversは、停止してPeerConnectionから削除する必要があります。ただし、トラックがaddTrackメソッドを介してRtpTransceiverに接続されている場合は、RtpTransceiverを削除してはなりません（MUSTNOT）。これは、アプリケーションがaddTrackを呼び出し、オファーでsetRemoteDescriptionを呼び出し、そのオファーをロールバックし、createOfferを呼び出して、生成されたオファーに追加されたトラックの「m =」セクションを表示できるようにするためです。"
    },
    {
      "indent": 0,
      "text": "5.8. Parsing a Session Description",
      "section_title": true,
      "ja": "5.8. セッションの説明の解析"
    },
    {
      "indent": 3,
      "text": "The SDP contained in the session description object consists of a sequence of text lines, each containing a key-value expression, as described in [RFC4566], Section 5. The SDP is read, line by line, and converted to a data structure that contains the deserialized information. However, SDP allows many types of lines, not all of which are relevant to JSEP applications. For each line, the implementation will first ensure that it is syntactically correct according to its defining ABNF, check that it conforms to the semantics used in [RFC4566] and [RFC3264], and then either parse and store or discard the provided value, as described below.",
      "ja": "セッション記述オブジェクトに含まれるSDPは、[RFC4566]のセクション5で説明されているように、それぞれがKey-Value式を含む一連のテキスト行で構成されます。SDPは1行ずつ読み取られ、次のようなデータ構造に変換されます。デシリアライズされた情報が含まれています。ただし、SDPでは多くの種類の回線が許可されており、そのすべてがJSEPアプリケーションに関連しているわけではありません。各行について、実装は最初に、定義するABNFに従って構文的に正しいことを確認し、[RFC4566]および[RFC3264]で使用されるセマンティクスに準拠していることを確認してから、提供された値を解析して保存または破棄します。以下で説明します。"
    },
    {
      "indent": 3,
      "text": "If any line is not well formed or cannot be parsed as described, the parser MUST stop with an error and reject the session description, even if the value is to be discarded. This ensures that implementations do not accidentally misinterpret ambiguous SDP.",
      "ja": "いずれかの行が整形式でないか、説明どおりに解析できない場合、値が破棄される場合でも、パーサーはエラーで停止し、セッションの説明を拒否する必要があります。これにより、実装があいまいなSDPを誤って誤解することがなくなります。"
    },
    {
      "indent": 0,
      "text": "5.8.1. Session-Level Parsing",
      "section_title": true,
      "ja": "5.8.1. セッションレベルの解析"
    },
    {
      "indent": 3,
      "text": "First, the session-level lines are checked and parsed. These lines MUST occur in a specific order, and with a specific syntax, as defined in [RFC4566], Section 5. Note that while the specific line types (e.g., \"v=\", \"c=\") MUST occur in the defined order, lines of the same type (typically \"a=\") can occur in any order.",
      "ja": "まず、セッションレベルの行がチェックされ、解析されます。これらの行は、[RFC4566]のセクション5で定義されているように、特定の順序で特定の構文で出現する必要があります。ただし、特定の線種（ \"v =\"、 \"c =\"など）は定義済みで出現する必要があります。順序、同じタイプの行（通常は「a =」）は任意の順序で発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following non-attribute lines are not meaningful in the JSEP context and MAY be discarded once they have been checked.",
      "ja": "次の非属性行は、JSEPコンテキストでは意味がなく、チェックされると破棄される場合があります。"
    },
    {
      "indent": 3,
      "text": "* The \"c=\" line MUST be checked for syntax, but its value is only used for ICE mismatch detection, as defined in [RFC8445], Section 5.4. Note that JSEP implementations should never encounter this condition because ICE is required for WebRTC.",
      "ja": "* 「c =」行の構文をチェックする必要がありますが、その値は、[RFC8445]のセクション5.4で定義されているように、ICEの不一致の検出にのみ使用されます。WebRTCにはICEが必要であるため、JSEP実装でこの状態が発生することはないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "* The \"i=\", \"u=\", \"e=\", \"p=\", \"t=\", \"r=\", \"z=\", and \"k=\" lines MUST be checked for syntax, but their values are not otherwise used.",
      "ja": "* \"i =\"、 \"u =\"、 \"e =\"、 \"p =\"、 \"t =\"、 \"r =\"、 \"z =\"、および \"k =\"行の構文をチェックする必要がありますが、それ以外の場合、値は使用されません。"
    },
    {
      "indent": 3,
      "text": "The remaining non-attribute lines are processed as follows:",
      "ja": "残りの非属性行は次のように処理されます。"
    },
    {
      "indent": 3,
      "text": "* The \"v=\" line MUST have a version of 0, as specified in [RFC4566], Section 5.1.",
      "ja": "* [RFC4566]のセクション5.1で指定されているように、「v =」行のバージョンは0である必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"o=\" line MUST be parsed as specified in [RFC4566], Section 5.2.",
      "ja": "* 「o =」行は、[RFC4566]のセクション5.2で指定されているように解析する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"b=\" line, if present, MUST be parsed as specified in [RFC4566], Section 5.8, and the bwtype and bandwidth values stored.",
      "ja": "* 「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているように解析し、bwtypeと帯域幅の値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, the attribute lines are processed. Specific processing MUST be applied for the following session-level attribute (\"a=\") lines:",
      "ja": "最後に、属性行が処理されます。次のセッションレベルの属性（ \"a =\"）行には、特定の処理を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=group\" lines are parsed as specified in [RFC5888], Section 5, and the group's semantics and mids are stored.",
      "ja": "* 「a = group」行は[RFC5888]のセクション5で指定されているように解析され、グループのセマンティクスとミッドが保存されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-lite\" line is parsed as specified in [RFC8839], Section 5.3, and a value indicating the presence of ice-lite is stored.",
      "ja": "* 存在する場合、[RFC8839]のセクション5.3で指定されているように、単一の「a = ice-lite」行が解析され、ice-liteの存在を示す値が格納されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-ufrag\" line is parsed as specified in [RFC8839], Section 5.4, and the ufrag value is stored.",
      "ja": "* 存在する場合、単一の「a = ice-ufrag」行が[RFC8839]のセクション5.4で指定されているように解析され、ufrag値が格納されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-pwd\" line is parsed as specified in [RFC8839], Section 5.4, and the password value is stored.",
      "ja": "* 存在する場合、[RFC8839]のセクション5.4で指定されているように、単一の「a = ice-pwd」行が解析され、パスワード値が保存されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-options\" line is parsed as specified in [RFC8839], Section 5.6, and the set of specified options is stored.",
      "ja": "* 存在する場合、単一の「a = ice-options」行が[RFC8839]のセクション5.6で指定されているように解析され、指定されたオプションのセットが保存されます。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=fingerprint\" lines are parsed as specified in [RFC8122], Section 5, and the set of fingerprint and algorithm values is stored.",
      "ja": "* 「a = fingerprint」行は、[RFC8122]のセクション5で指定されているように解析され、フィンガープリントとアルゴリズムの値のセットが保存されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=setup\" line is parsed as specified in [RFC4145], Section 4, and the setup value is stored.",
      "ja": "* 存在する場合、[RFC4145]のセクション4で指定されているように、単一の「a = setup」行が解析され、セットアップ値が保存されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=tls-id\" line is parsed as specified in [RFC8842], Section 5, and the attribute value is stored.",
      "ja": "* 存在する場合、[RFC8842]のセクション5で指定されているように、単一の「a = tls-id」行が解析され、属性値が保存されます。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=identity\" lines are parsed and the identity values stored for subsequent verification, as specified in [RFC8827], Section 5.",
      "ja": "* [RFC8827]のセクション5で指定されているように、「a = identity」行はすべて解析され、ID値は後続の検証のために保存されます。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=extmap\" lines are parsed as specified in [RFC5285], Section 5, and their values are stored.",
      "ja": "* 「a = extmap」行はすべて、[RFC5285]のセクション5で指定されているように解析され、それらの値が保存されます。"
    },
    {
      "indent": 3,
      "text": "Other attributes that are not relevant to JSEP may also be present, and implementations SHOULD process any that they recognize. As required by [RFC4566], Section 5.13, unknown attribute lines MUST be ignored.",
      "ja": "JSEPに関係のない他の属性も存在する可能性があり、実装は認識したものを処理する必要があります。[RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once all the session-level lines have been parsed, processing continues with the lines in \"m=\" sections.",
      "ja": "すべてのセッションレベルの行が解析されると、処理は「m =」セクションの行から続行されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Media Section Parsing",
      "section_title": true,
      "ja": "5.8.2. メディアセクションの解析"
    },
    {
      "indent": 3,
      "text": "Like the session-level lines, the media section lines MUST occur in the specific order and with the specific syntax defined in [RFC4566], Section 5.",
      "ja": "セッションレベルの行と同様に、メディアセクションの行は、[RFC4566]のセクション5で定義されている特定の順序で特定の構文で出現する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"m=\" line itself MUST be parsed as described in [RFC4566], Section 5.14, and the <media>, <port>, <proto>, and <fmt> values stored.",
      "ja": "「m =」行自体は、[RFC4566]のセクション5.14で説明されているように解析され、<media>、<port>、<proto>、および<fmt>の値が格納されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Following the \"m=\" line, specific processing MUST be applied for the following non-attribute lines:",
      "ja": "「m =」行に続いて、次の非属性行に特定の処理を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* As with the \"c=\" line at the session level, the \"c=\" line MUST be parsed according to [RFC4566], Section 5.7, but its value is not used.",
      "ja": "* セッションレベルの「c =」行と同様に、「c =」行は[RFC4566]のセクション5.7に従って解析する必要がありますが、その値は使用されません。"
    },
    {
      "indent": 3,
      "text": "* The \"b=\" line, if present, MUST be parsed as specified in [RFC4566], Section 5.8, and the bwtype and bandwidth values stored.",
      "ja": "* 「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているように解析し、bwtypeと帯域幅の値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Specific processing MUST also be applied for the following attribute lines:",
      "ja": "次の属性行にも特定の処理を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-ufrag\" line is parsed as specified in [RFC8839], Section 5.4, and the ufrag value is stored.",
      "ja": "* 存在する場合、単一の「a = ice-ufrag」行が[RFC8839]のセクション5.4で指定されているように解析され、ufrag値が格納されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-pwd\" line is parsed as specified in [RFC8839], Section 5.4, and the password value is stored.",
      "ja": "* 存在する場合、[RFC8839]のセクション5.4で指定されているように、単一の「a = ice-pwd」行が解析され、パスワード値が保存されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ice-options\" line is parsed as specified in [RFC8839], Section 5.6, and the set of specified options is stored.",
      "ja": "* 存在する場合、単一の「a = ice-options」行が[RFC8839]のセクション5.6で指定されているように解析され、指定されたオプションのセットが保存されます。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=candidate\" attributes MUST be parsed as specified in [RFC8839], Section 5.1, and their values stored.",
      "ja": "* 「a = candidate」属性は、[RFC8839]のセクション5.1で指定されているように解析し、それらの値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=remote-candidates\" attributes MUST be parsed as specified in [RFC8839], Section 5.2, but their values are ignored.",
      "ja": "* 「a = remote-candidates」属性は、[RFC8839]のセクション5.2で指定されているように解析する必要がありますが、それらの値は無視されます。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=end-of-candidates\" attribute MUST be parsed as specified in [RFC8840], Section 8.1, and its presence or absence flagged and stored.",
      "ja": "* 存在する場合、単一の「a = end-of-candidates」属性は、[RFC8840]のセクション8.1で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=fingerprint\" lines are parsed as specified in [RFC8122], Section 5, and the set of fingerprint and algorithm values is stored.",
      "ja": "* 「a = fingerprint」行は、[RFC8122]のセクション5で指定されているように解析され、フィンガープリントとアルゴリズムの値のセットが保存されます。"
    },
    {
      "indent": 3,
      "text": "If the \"m=\" <proto> value indicates use of RTP, as described in Section 5.1.2 above, the following attribute lines MUST be processed:",
      "ja": "上記のセクション5.1.2で説明したように、「m = \"<proto>値がRTPの使用を示している場合は、次の属性行を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"m=\" <fmt> value MUST be parsed as specified in [RFC4566], Section 5.14, and the individual values stored.",
      "ja": "* \"m =\" <fmt>値は、[RFC4566]のセクション5.14で指定されているように解析され、個々の値が格納されている必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=rtpmap\" or \"a=fmtp\" lines MUST be parsed as specified in [RFC4566], Section 6, and their values stored.",
      "ja": "* 「a = rtpmap」または「a = fmtp」の行は、[RFC4566]のセクション6で指定されているように解析し、それらの値を格納する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=ptime\" line MUST be parsed as described in [RFC4566], Section 6, and its value stored.",
      "ja": "* 存在する場合は、[RFC4566]のセクション6で説明されているように、単一の「a = ptime」行を解析し、その値を格納する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=maxptime\" line MUST be parsed as described in [RFC4566], Section 6, and its value stored.",
      "ja": "* 存在する場合は、[RFC4566]のセクション6で説明されているように、単一の「a = maxptime」行を解析し、その値を格納する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single direction attribute line (e.g., \"a=sendrecv\") MUST be parsed as described in [RFC4566], Section 6, and its value stored.",
      "ja": "* 存在する場合、[RFC4566]のセクション6で説明されているように、単一方向の属性行（ \"a = sendrecv\"など）を解析し、その値を格納する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=ssrc\" attributes MUST be parsed as specified in [RFC5576], Section 4.1, and their values stored.",
      "ja": "* 「a = ssrc」属性は、[RFC5576]のセクション4.1で指定されているように解析し、それらの値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=extmap\" attributes MUST be parsed as specified in [RFC5285], Section 5, and their values stored.",
      "ja": "* 「a = extmap」属性は、[RFC5285]のセクション5で指定されているように解析し、それらの値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=rtcp-fb\" attributes MUST be parsed as specified in [RFC4585], Section 4.2, and their values stored.",
      "ja": "* 「a = rtcp-fb」属性は、[RFC4585]のセクション4.2で指定されているように解析し、それらの値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=rtcp-mux\" attribute MUST be parsed as specified in [RFC5761], Section 5.1.3, and its presence or absence flagged and stored.",
      "ja": "* 存在する場合、単一の「a = rtcp-mux」属性は、[RFC5761]のセクション5.1.3で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=rtcp-mux-only\" attribute MUST be parsed as specified in [RFC8858], Section 3, and its presence or absence flagged and stored.",
      "ja": "* 存在する場合、単一の「a = rtcp-mux-only」属性は、[RFC8858]のセクション3で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=rtcp-rsize\" attribute MUST be parsed as specified in [RFC5506], Section 5, and its presence or absence flagged and stored.",
      "ja": "* 存在する場合、単一の「a = rtcp-rsize」属性は、[RFC5506]のセクション5で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=rtcp\" attribute MUST be parsed as specified in [RFC3605], Section 2.1, but its value is ignored, as this information is superfluous when using ICE.",
      "ja": "* 存在する場合、単一の「a = rtcp」属性は[RFC3605]のセクション2.1で指定されているように解析する必要がありますが、ICEを使用する場合、この情報は不要であるため、その値は無視されます。"
    },
    {
      "indent": 3,
      "text": "* If present, \"a=msid\" attributes MUST be parsed as specified in [RFC8830], Section 3.2, and their values stored, ignoring any \"appdata\" field. If no \"a=msid\" attributes are present, a random msid-id value is generated for a \"default\" MediaStream for the session, if not already present, and this value is stored.",
      "ja": "* 存在する場合、「a = msid」属性は、[RFC8830]のセクション3.2で指定されているように解析され、それらの値は「appdata」フィールドを無視して保存される必要があります。「a = msid」属性が存在しない場合、セッションの「デフォルト」MediaStreamに対してランダムなmsid-id値が生成され、まだ存在しない場合は、この値が保存されます。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=imageattr\" attributes MUST be parsed as specified in [RFC6236], Section 3, and their values stored.",
      "ja": "* 「a = imageattr」属性は、[RFC6236]のセクション3で指定されているように解析し、それらの値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any \"a=rid\" lines MUST be parsed as specified in [RFC8851], Section 10, and their values stored.",
      "ja": "* 「a = rid」行は、[RFC8851]のセクション10で指定されているように解析し、その値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=simulcast\" line MUST be parsed as specified in [RFC8853], and its values stored.",
      "ja": "* 存在する場合、単一の「a = simulcast」行は、[RFC8853]で指定されているように解析され、その値が格納される必要があります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the \"m=\" <proto> value indicates use of SCTP, the following attribute lines MUST be processed:",
      "ja": "それ以外の場合、「m = \"<proto>値がSCTPの使用を示している場合は、次の属性行を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The \"m=\" <fmt> value MUST be parsed as specified in [RFC8841], Section 4.3, and the application protocol value stored.",
      "ja": "* 「m =」<fmt>値は、[RFC8841]のセクション4.3で指定されているように解析され、アプリケーションプロトコル値が保存されている必要があります。"
    },
    {
      "indent": 3,
      "text": "* An \"a=sctp-port\" attribute MUST be present, and it MUST be parsed as specified in [RFC8841], Section 5.2, and the value stored.",
      "ja": "* 「a = sctp-port」属性が存在する必要があり、[RFC8841]のセクション5.2で指定されているように解析され、値が格納されている必要があります。"
    },
    {
      "indent": 3,
      "text": "* If present, a single \"a=max-message-size\" attribute MUST be parsed as specified in [RFC8841], Section 6, and the value stored. Otherwise, use the specified default.",
      "ja": "* 存在する場合、単一の「a = max-message-size」属性は、[RFC8841]のセクション6で指定されているように解析され、値が格納されている必要があります。それ以外の場合は、指定されたデフォルトを使用します。"
    },
    {
      "indent": 3,
      "text": "Other attributes that are not relevant to JSEP may also be present, and implementations SHOULD process any that they recognize. As required by [RFC4566], Section 5.13, unknown attribute lines MUST be ignored.",
      "ja": "JSEPに関係のない他の属性も存在する可能性があり、実装は認識したものを処理する必要があります。[RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.8.3. Semantics Verification",
      "section_title": true,
      "ja": "5.8.3. セマンティクス検証"
    },
    {
      "indent": 3,
      "text": "Assuming that parsing completes successfully, the parsed description is then evaluated to ensure internal consistency as well as proper support for mandatory features. Specifically, the following checks are performed:",
      "ja": "解析が正常に完了したと仮定すると、解析された記述が評価され、内部の一貫性と必須機能の適切なサポートが保証されます。具体的には、次のチェックが実行されます。"
    },
    {
      "indent": 3,
      "text": "* For each \"m=\" section, valid values for each of the mandatory-to-use features enumerated in Section 5.1.1 MUST be present. These values MAY be either present at the media level or inherited from the session level.",
      "ja": "* 各「m =」セクションには、セクション5.1.1に列挙されている必須機能のそれぞれに有効な値が存在する必要があります。これらの値は、メディアレベルに存在するか、セッションレベルから継承される場合があります。"
    },
    {
      "indent": 6,
      "text": "- ICE ufrag and password values, which MUST comply with the size limits specified in [RFC8839], Section 5.4.",
      "ja": "- ICEのufragとパスワードの値。[RFC8839]のセクション5.4で指定されているサイズ制限に準拠する必要があります。"
    },
    {
      "indent": 6,
      "text": "- A tls-id value, which MUST be set according to [RFC8842], Section 5. If this is a re-offer or a response to a re-offer and the tls-id value is different from that presently in use, the DTLS connection is not being continued and the remote description MUST be part of an ICE restart, together with new ufrag and password values.",
      "ja": "- tls-id値。[RFC8842]のセクション5に従って設定する必要があります。これが再オファーまたは再オファーへの応答であり、tls-id値が現在使用されている値と異なる場合、DTLS接続は継続されておらず、リモート記述は、新しいufragおよびパスワード値とともにICE再起動の一部である必要があります。"
    },
    {
      "indent": 6,
      "text": "- A DTLS setup value, which MUST be set according to the rules specified in [RFC5763], Section 5 and MUST be consistent with the selected role of the current DTLS connection, if one exists and is being continued.",
      "ja": "- DTLSセットアップ値。これは、[RFC5763]のセクション5で指定されたルールに従って設定する必要があり、現在のDTLS接続の選択された役割と一致している必要があります（存在し、継続されている場合）。"
    },
    {
      "indent": 6,
      "text": "- DTLS fingerprint values, where at least one fingerprint MUST be present.",
      "ja": "- DTLSフィンガープリント値。少なくとも1つのフィンガープリントが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "* All rid-ids referenced in an \"a=simulcast\" line MUST exist as \"a=rid\" lines.",
      "ja": "* 「a = simulcast」行で参照されるすべてのrid-idは「a = rid」行として存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Each \"m=\" section is also checked to ensure that prohibited features are not used.",
      "ja": "* 各「m =」セクションもチェックされ、禁止されている機能が使用されていないことを確認します。"
    },
    {
      "indent": 3,
      "text": "* If the RTP/RTCP multiplexing policy is \"require\", each \"m=\" section MUST contain an \"a=rtcp-mux\" attribute. If an \"m=\" section contains an \"a=rtcp-mux-only\" attribute, that section MUST also contain an \"a=rtcp-mux\" attribute.",
      "ja": "* RTP / RTCP多重化ポリシーが「require」の場合、各「m =」セクションには「a = rtcp-mux」属性が含まれている必要があります。「m =」セクションに「a = rtcp-mux-only」属性が含まれている場合、そのセクションには「a = rtcp-mux」属性も含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "* If an \"m=\" section was present in the previous answer, the state of RTP/RTCP multiplexing MUST match what was previously negotiated.",
      "ja": "* 前の回答に「m =」セクションが存在した場合、RTP / RTCP多重化の状態は、以前にネゴシエートされた状態と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "If this session description is of type \"pranswer\" or \"answer\", the following additional checks are applied:",
      "ja": "このセッションの説明のタイプが「pranswer」または「answer」の場合、次の追加のチェックが適用されます。"
    },
    {
      "indent": 3,
      "text": "* The session description MUST follow the rules defined in [RFC3264], Section 6, including the requirement that the number of \"m=\" sections MUST exactly match the number of \"m=\" sections in the associated offer.",
      "ja": "* セッションの説明は、[RFC3264]のセクション6で定義されているルールに従う必要があります。これには、「m =」セクションの数が関連するオファーの「m =」セクションの数と正確に一致する必要があるという要件が含まれます。"
    },
    {
      "indent": 3,
      "text": "* For each \"m=\" section, the media type and protocol values MUST exactly match the media type and protocol values in the corresponding \"m=\" section in the associated offer.",
      "ja": "* 各「m =」セクションについて、メディアタイプとプロトコル値は、関連するオファーの対応する「m =」セクションのメディアタイプとプロトコル値と正確に一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "If any of the preceding checks failed, processing MUST stop and an error MUST be returned.",
      "ja": "上記のチェックのいずれかが失敗した場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "5.9. Applying a Local Description",
      "section_title": true,
      "ja": "5.9. ローカル記述の適用"
    },
    {
      "indent": 3,
      "text": "The following steps are performed at the media engine level to apply a local description. If an error is returned, the session MUST be restored to the state it was in before performing these steps.",
      "ja": "次の手順は、ローカル記述を適用するためにメディアエンジンレベルで実行されます。エラーが返された場合は、これらの手順を実行する前に、セッションを元の状態に復元する必要があります。"
    },
    {
      "indent": 3,
      "text": "First, \"m=\" sections are processed. For each \"m=\" section, the following steps MUST be performed; if any parameters are out of bounds or cannot be applied, processing MUST stop and an error MUST be returned.",
      "ja": "まず、「m =」セクションが処理されます。「m =」セクションごとに、次の手順を実行する必要があります。パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If this \"m=\" section is new, begin gathering candidates for it, as defined in [RFC8445], Section 5.1.1, unless it is definitively being bundled (either (1) this is an offer and the \"m=\" section is marked bundle-only or (2) it is an answer and the \"m=\" section is bundled into another \"m=\" section).",
      "ja": "* この「m =」セクションが新しい場合は、[RFC8445]のセクション5.1.1で定義されているように、候補の収集を開始します。ただし、確実にバンドルされている場合を除きます（（1）これはオファーであり、「m =」セクションははバンドルのみとマークされているか、（2）回答であり、「m =」セクションは別の「m =」セクションにバンドルされています。"
    },
    {
      "indent": 3,
      "text": "* Or, if the ICE ufrag and password values have changed, trigger the ICE agent to start an ICE restart as described in [RFC8445], Section 9, and begin gathering new candidates for the \"m=\" section. If this description is an answer, also start checks on that media section.",
      "ja": "* または、ICE ufragとpasswordの値が変更された場合は、[RFC8445]のセクション9で説明されているように、ICEエージェントをトリガーしてICEの再起動を開始し、「m =」セクションの新しい候補の収集を開始します。この説明が答えである場合は、そのメディアセクションのチェックも開始します。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section <proto> value indicates use of RTP:",
      "ja": "* 「m =」セクションの<proto>値がRTPの使用を示している場合："
    },
    {
      "indent": 6,
      "text": "- If there is no RtpTransceiver associated with this \"m=\" section, find one and associate it with this \"m=\" section according to the following steps. Note that this situation will only occur when applying an offer.",
      "ja": "- この「m =」セクションに関連付けられているRtpTransceiverがない場合は、RtpTransceiverを見つけて、次の手順に従ってこの「m =」セクションに関連付けます。この状況は、オファーを適用する場合にのみ発生することに注意してください。"
    },
    {
      "indent": 9,
      "text": "o Find the RtpTransceiver that corresponds to this \"m=\" section, using the mapping between transceivers and \"m=\" section indices established when creating the offer.",
      "ja": "o オファーの作成時に確立されたトランシーバーと「m =」セクションインデックス間のマッピングを使用して、この「m =」セクションに対応するRtpTransceiverを見つけます。"
    },
    {
      "indent": 9,
      "text": "o Set the value of this RtpTransceiver's mid property to the MID of the \"m=\" section.",
      "ja": "o このRtpTransceiverのmidプロパティの値を「m =」セクションのMIDに設定します。"
    },
    {
      "indent": 6,
      "text": "- If RTCP mux is indicated, prepare to demux RTP and RTCP from the RTP ICE component, as specified in [RFC5761], Section 5.1.3.",
      "ja": "- RTCPマルチプレクサが示されている場合は、[RFC5761]のセクション5.1.3で指定されているように、RTPICEコンポーネントからRTPとRTCPをデマルチプレクサする準備をします。"
    },
    {
      "indent": 6,
      "text": "- For each specified RTP header extension, establish a mapping between the extension ID and URI, as described in [RFC5285], Section 6.",
      "ja": "- 指定されたRTPヘッダー拡張ごとに、[RFC5285]のセクション6で説明されているように、拡張IDとURIの間のマッピングを確立します。"
    },
    {
      "indent": 6,
      "text": "- If the MID header extension is supported, prepare to demux RTP streams intended for this \"m=\" section based on the MID header extension, as described in [RFC8843], Section 15.",
      "ja": "- MIDヘッダー拡張がサポートされている場合は、[RFC8843]のセクション15で説明されているように、MIDヘッダー拡張に基づいてこの「m =」セクション向けのRTPストリームをデマックスする準備をします。"
    },
    {
      "indent": 6,
      "text": "- For each specified media format, establish a mapping between the payload type and the actual media format, as described in [RFC3264], Section 6.1. In addition, prepare to demux RTP streams intended for this \"m=\" section based on the media formats supported by this \"m=\" section, as described in [RFC8843], Section 9.2.",
      "ja": "- [RFC3264]のセクション6.1で説明されているように、指定されたメディア形式ごとに、ペイロードタイプと実際のメディア形式の間のマッピングを確立します。さらに、[RFC8843]のセクション9.2で説明されているように、この「m =」セクションでサポートされているメディア形式に基づいて、この「m =」セクション向けのRTPストリームをデマックスする準備をします。"
    },
    {
      "indent": 6,
      "text": "- For each specified \"rtx\" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in Sections 8.6 and 8.7 of [RFC4588].",
      "ja": "- [RFC4588]のセクション8.6および8.7で説明されているように、指定された「rtx」メディア形式ごとに、RTXペイロードタイプとそれに関連するプライマリペイロードタイプの間のマッピングを確立します。"
    },
    {
      "indent": 6,
      "text": "- If the direction attribute is of type \"sendrecv\" or \"recvonly\", enable receipt and decoding of media.",
      "ja": "- 方向属性のタイプが「sendrecv」または「recvonly」の場合、メディアの受信とデコードを有効にします。"
    },
    {
      "indent": 3,
      "text": "Finally, if this description is of type \"pranswer\" or \"answer\", follow the processing defined in Section 5.11 below.",
      "ja": "最後に、この説明のタイプが「pranswer」または「answer」の場合は、以下のセクション5.11で定義されている処理に従います。"
    },
    {
      "indent": 0,
      "text": "5.10. Applying a Remote Description",
      "section_title": true,
      "ja": "5.10. リモート記述の適用"
    },
    {
      "indent": 3,
      "text": "The following steps are performed to apply a remote description. If an error is returned, the session MUST be restored to the state it was in before performing these steps.",
      "ja": "リモート記述を適用するには、次の手順を実行します。エラーが返された場合は、これらの手順を実行する前に、セッションを元の状態に復元する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the answer contains any \"a=ice-options\" attributes where \"trickle\" is listed as an attribute, update the PeerConnection canTrickleIceCandidates property to be \"true\". Otherwise, set this property to \"false\".",
      "ja": "回答に「trickle」が属性としてリストされている「a = ice-options」属性が含まれている場合は、PeerConnectioncanTrickleIceCandidatesプロパティを「true」に更新します。それ以外の場合は、このプロパティを「false」に設定します。"
    },
    {
      "indent": 3,
      "text": "The following steps MUST be performed for attributes at the session level; if any parameters are out of bounds or cannot be applied, processing MUST stop and an error MUST be returned.",
      "ja": "次の手順は、セッションレベルで属性に対して実行する必要があります。パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* For any specified \"CT\" bandwidth value, set this value as the limit for the maximum total bitrate for all \"m=\" sections, as specified in [RFC4566], Section 5.8. Within this overall limit, the implementation can dynamically decide how to best allocate the available bandwidth between \"m=\" sections, respecting any specific limits that have been specified for individual \"m=\" sections.",
      "ja": "* 指定された「CT」帯域幅値について、[RFC4566]のセクション5.8で指定されているように、この値をすべての「m =」セクションの最大合計ビットレートの制限として設定します。この全体的な制限内で、実装は、個々の「m =」セクションに指定された特定の制限を尊重して、「m =」セクション間で使用可能な帯域幅を最適に割り当てる方法を動的に決定できます。"
    },
    {
      "indent": 3,
      "text": "* For any specified \"RR\" or \"RS\" bandwidth values, handle as specified in [RFC3556], Section 2.",
      "ja": "* 指定された「RR」または「RS」帯域幅の値については、[RFC3556]のセクション2で指定されているように処理してください。"
    },
    {
      "indent": 3,
      "text": "* Any \"AS\" bandwidth value ([RFC4566], Section 5.8) MUST be ignored, as the meaning of this construct at the session level is not well defined.",
      "ja": "* セッションレベルでのこの構成の意味が明確に定義されていないため、「AS」帯域幅の値（[RFC4566]、セクション5.8）は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "For each \"m=\" section, the following steps MUST be performed; if any parameters are out of bounds or cannot be applied, processing MUST stop and an error MUST be returned.",
      "ja": "「m =」セクションごとに、次の手順を実行する必要があります。パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the ICE ufrag or password changed from the previous remote description:",
      "ja": "* ICE ufragまたはパスワードが前のリモート記述から変更された場合："
    },
    {
      "indent": 6,
      "text": "- If the description is of type \"offer\", the implementation MUST note that an ICE restart is needed, as described in [RFC8839], Section 4.4.1.1.1.",
      "ja": "- 説明のタイプが「offer」の場合、[RFC8839]のセクション4.4.1.1.1で説明されているように、実装はICEの再起動が必要であることに注意する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If the description is of type \"answer\" or \"pranswer\", then check to see if the current local description is an ICE restart, and if not, generate an error. If the PeerConnection state is \"have-remote-pranswer\" and the ICE ufrag or password changed from the previous provisional answer, then signal the ICE agent to discard any previous ICE checklist state for the \"m=\" section. Finally, signal the ICE agent to begin checks.",
      "ja": "- 説明のタイプが「answer」または「pranswer」の場合は、現在のローカル説明がICE再起動であるかどうかを確認し、そうでない場合はエラーを生成します。PeerConnectionの状態が「have-remote-pranswer」であり、ICE ufragまたはパスワードが以前の暫定回答から変更された場合は、「m =」セクションの以前のICEチェックリスト状態を破棄するようにICEエージェントに通知します。最後に、ICEエージェントにチェックを開始するように通知します。"
    },
    {
      "indent": 3,
      "text": "* If the current local description indicates an ICE restart but neither the ICE ufrag nor the password has changed from the previous remote description (as prescribed by [RFC8445], Section 9), generate an error.",
      "ja": "* 現在のローカルの説明がICEの再起動を示しているが、ICE ufragもパスワードも以前のリモートの説明（[RFC8445]のセクション9で規定）から変更されていない場合、エラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "* Configure the ICE components associated with this media section to use the supplied ICE remote ufrag and password for their connectivity checks.",
      "ja": "* このメディアセクションに関連付けられているICEコンポーネントを構成して、接続チェックに付属のICEリモートufragとパスワードを使用します。"
    },
    {
      "indent": 3,
      "text": "* Pair any supplied ICE candidates with any gathered local candidates, as described in [RFC8445], Section 6.1.2, and start connectivity checks with the appropriate credentials.",
      "ja": "* [RFC8445]のセクション6.1.2で説明されているように、提供されたICE候補を収集されたローカル候補とペアリングし、適切な認証情報を使用して接続チェックを開始します。"
    },
    {
      "indent": 3,
      "text": "* If an \"a=end-of-candidates\" attribute is present, process the end-of-candidates indication as described in [RFC8838], Section 14.",
      "ja": "* 「a = end-of-candidates」属性が存在する場合は、[RFC8838]のセクション14の説明に従って、end-of-candidates表示を処理します。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section <proto> value indicates use of RTP:",
      "ja": "* 「m =」セクションの<proto>値がRTPの使用を示している場合："
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section is being recycled (see Section 5.2.2), disassociate the currently associated RtpTransceiver by setting its mid property to \"null\", and discard the mapping between the transceiver and its \"m=\" section index.",
      "ja": "- 「m =」セクションがリサイクルされている場合（セクション5.2.2を参照）、現在関連付けられているRtpTransceiverのmidプロパティを「null」に設定して関連付けを解除し、トランシーバーと「m =」セクションインデックス間のマッピングを破棄します。"
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section is not associated with any RtpTransceiver (possibly because it was disassociated in the previous step), either find an RtpTransceiver or create one according to the following steps:",
      "ja": "- 「m =」セクションがどのRtpTransceiverにも関連付けられていない場合（おそらく前の手順で関連付けが解除されたため）、RtpTransceiverを見つけるか、次の手順に従って作成します。"
    },
    {
      "indent": 9,
      "text": "o If the \"m=\" section is sendrecv or recvonly, and there are RtpTransceivers of the same type that were added to the PeerConnection by addTrack and are not associated with any \"m=\" section and are not stopped, find the first (according to the canonical order described in Section 5.2.1) such RtpTransceiver.",
      "ja": "o 「m =」セクションがsendrecvまたはrecvonlyであり、addTrackによってPeerConnectionに追加され、「m =」セクションに関連付けられておらず、停止されていない同じタイプのRtpTransceiversがある場合は、最初のものを見つけます（セクション5.2.1で説明されている正規の順序）そのようなRtpTransceiver。"
    },
    {
      "indent": 9,
      "text": "o If no RtpTransceiver was found in the previous step, create one with a recvonly direction.",
      "ja": "o 前の手順でRtpTransceiverが見つからなかった場合は、recvonly方向でRtpTransceiverを作成します。"
    },
    {
      "indent": 9,
      "text": "o Associate the found or created RtpTransceiver with the \"m=\" section by setting the value of the RtpTransceiver's mid property to the MID of the \"m=\" section, and establish a mapping between the transceiver and the index of the \"m=\" section. If the \"m=\" section does not include a MID (i.e., the remote endpoint does not support the MID extension), generate a value for the RtpTransceiver mid property, following the guidance for \"a=mid\" mentioned in Section 5.2.1.",
      "ja": "o RtpTransceiverのmidプロパティの値を「m =」セクションのMIDに設定することにより、検出または作成されたRtpTransceiverを「m =」セクションに関連付け、トランシーバーと「m =」セクションのインデックスの間のマッピングを確立します。。「m =」セクションにMIDが含まれていない場合（つまり、リモートエンドポイントがMID拡張機能をサポートしていない場合）、セクション5.2.1で説明した「a = mid」のガイダンスに従って、RtpTransceivermidプロパティの値を生成します。。"
    },
    {
      "indent": 6,
      "text": "- For each specified media format that is also supported by the local implementation, establish a mapping between the specified payload type and the media format, as described in [RFC3264], Section 6.1. Specifically, this means that the implementation records the payload type to be used in outgoing RTP packets when sending each specified media format, as well as the relative preference for each format that is indicated in their ordering. If any indicated media format is not supported by the local implementation, it MUST be ignored.",
      "ja": "- ローカル実装でもサポートされている指定されたメディア形式ごとに、[RFC3264]のセクション6.1で説明されているように、指定されたペイロードタイプとメディア形式の間のマッピングを確立します。具体的には、これは、実装が、指定された各メディア形式を送信するときに発信RTPパケットで使用されるペイロードタイプと、順序で示される各形式の相対的な優先順位を記録することを意味します。示されたメディア形式がローカル実装でサポートされていない場合は、無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "- For each specified \"rtx\" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in [RFC4588], Section 4. If any referenced primary payload types are not present, this MUST result in an error. Note that RTX payload types may refer to primary payload types that are not supported by the local media implementation, in which case the RTX payload type MUST also be ignored.",
      "ja": "- 指定された「rtx」メディア形式ごとに、[RFC4588]のセクション4で説明されているように、RTXペイロードタイプとそれに関連するプライマリペイロードタイプの間のマッピングを確立します。参照されるプライマリペイロードタイプが存在しない場合、エラーが発生する必要があります。。RTXペイロードタイプは、ローカルメディア実装でサポートされていないプライマリペイロードタイプを参照する場合があることに注意してください。その場合、RTXペイロードタイプも無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "- For each specified fmtp parameter that is supported by the local implementation, enable them on the associated media formats.",
      "ja": "- ローカル実装でサポートされている指定されたfmtpパラメーターごとに、関連するメディア形式でそれらを有効にします。"
    },
    {
      "indent": 6,
      "text": "- For each specified Synchronization Source (SSRC) that is signaled in the \"m=\" section, prepare to demux RTP streams intended for this \"m=\" section using that SSRC, as described in [RFC8843], Section 9.2.",
      "ja": "- [RFC8843]のセクション9.2で説明されているように、「m =」セクションで通知される指定された同期ソース（SSRC）ごとに、そのSSRCを使用してこの「m =」セクション向けのRTPストリームをデマックスする準備をします。"
    },
    {
      "indent": 6,
      "text": "- For each specified RTP header extension that is also supported by the local implementation, establish a mapping between the extension ID and URI, as described in [RFC5285], Section 5. Specifically, this means that the implementation records the extension ID to be used in outgoing RTP packets when sending each specified header extension. If any indicated RTP header extension is not supported by the local implementation, it MUST be ignored.",
      "ja": "- ローカル実装でもサポートされている指定されたRTPヘッダー拡張ごとに、[RFC5285]のセクション5で説明されているように、拡張IDとURIの間のマッピングを確立します。具体的には、これは、実装がで使用される拡張IDを記録することを意味します。指定された各ヘッダー拡張子を送信するときの発信RTPパケット。示されたRTPヘッダー拡張子がローカル実装でサポートされていない場合は、無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "- For each specified RTCP feedback mechanism that is supported by the local implementation, enable them on the associated media formats.",
      "ja": "- ローカル実装でサポートされている指定されたRTCPフィードバックメカニズムごとに、関連するメディア形式でそれらを有効にします。"
    },
    {
      "indent": 6,
      "text": "- For any specified \"TIAS\" (\"Transport Independent Application Specific Maximum\") bandwidth value, set this value as a constraint on the maximum RTP bitrate to be used when sending media, as specified in [RFC3890]. If a \"TIAS\" value is not present but an \"AS\" value is specified, generate a \"TIAS\" value using this formula:",
      "ja": "- 指定された「TIAS」（「トランスポートに依存しないアプリケーション固有の最大値」）帯域幅値について、[RFC3890]で指定されているように、この値をメディアの送信時に使用される最大RTPビットレートの制約として設定します。「TIAS」値が存在しないが「AS」値が指定されている場合は、次の式を使用して「TIAS」値を生成します。"
    },
    {
      "indent": 12,
      "text": "TIAS = AS * 1000 * 0.95 - (50 * 40 * 8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The 1000 changes the unit from kbps to bps (as required by TIAS), and the 0.95 is to allocate 5% to RTCP. An estimate of header overhead is then subtracted out, in which the 50 is based on 50 packets per second, the 40 is based on typical header size (in bytes), and the 8 converts bytes to bits. Note that \"TIAS\" is preferred over \"AS\" because it provides more accurate control of bandwidth.",
      "ja": ""
    },
    {
      "indent": 6,
      "text": "- For any \"RR\" or \"RS\" bandwidth values, handle as specified in [RFC3556], Section 2.",
      "ja": "- 「RR」または「RS」帯域幅の値については、[RFC3556]のセクション2で指定されているように処理してください。"
    },
    {
      "indent": 6,
      "text": "- Any specified \"CT\" bandwidth value MUST be ignored, as the meaning of this construct at the media level is not well defined.",
      "ja": "- メディアレベルでのこの構成の意味は十分に定義されていないため、指定された「CT」帯域幅の値はすべて無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section is of type \"audio\":",
      "ja": "- 「m =」セクションのタイプが「audio」の場合："
    },
    {
      "indent": 9,
      "text": "o For each specified \"CN\" media format, configure silence suppression for all supported media formats with the same clock rate, as described in [RFC3389], Section 5, except for formats that have their own internal silence suppression mechanisms. Silence suppression for such formats (e.g., Opus) is controlled via fmtp parameters, as discussed in Section 5.2.3.2.",
      "ja": "o 指定された「CN」メディア形式ごとに、[RFC3389]のセクション5で説明されているように、サポートされているすべてのメディア形式に対して、独自の内部無音抑制メカニズムを持つ形式を除いて、無音抑制を構成します。このような形式（Opusなど）の無音抑制は、セクション5.2.3.2で説明されているように、fmtpパラメーターを介して制御されます。"
    },
    {
      "indent": 9,
      "text": "o For each specified \"telephone-event\" media format, enable dual-tone multifrequency (DTMF) transmission for all supported media formats with the same clock rate, as described in [RFC4733], Section 2.5.1.2. If there are any supported media formats that do not have a corresponding telephone-event format, disable DTMF transmission for those formats.",
      "ja": "o 指定された「電話イベント」メディア形式ごとに、[RFC4733]のセクション2.5.1.2で説明されているように、サポートされているすべてのメディア形式で同じクロックレートでデュアルトーン多重周波数（DTMF）送信を有効にします。対応する電話イベント形式を持たないサポートされているメディア形式がある場合は、それらの形式のDTMF送信を無効にします。"
    },
    {
      "indent": 9,
      "text": "o For any specified \"ptime\" value, configure the available media formats to use the specified packet size when sending. If the specified size is not supported for a media format, use the next closest value instead.",
      "ja": "o 指定された「ptime」値について、送信時に指定されたパケットサイズを使用するように使用可能なメディア形式を構成します。指定されたサイズがメディア形式でサポートされていない場合は、代わりに次に近い値を使用してください。"
    },
    {
      "indent": 3,
      "text": "Finally, if this description is of type \"pranswer\" or \"answer\", follow the processing defined in Section 5.11 below.",
      "ja": "最後に、この説明のタイプが「pranswer」または「answer」の場合は、以下のセクション5.11で定義されている処理に従います。"
    },
    {
      "indent": 0,
      "text": "5.11. Applying an Answer",
      "section_title": true,
      "ja": "5.11. 回答を適用する"
    },
    {
      "indent": 3,
      "text": "In addition to the steps mentioned above for processing a local or remote description, the following steps are performed when processing a description of type \"pranswer\" or \"answer\".",
      "ja": "ローカルまたはリモートの説明を処理するための上記のステップに加えて、タイプ「pranswer」または「answer」の説明を処理するときに、以下のステップが実行されます。"
    },
    {
      "indent": 3,
      "text": "For each \"m=\" section, the following steps MUST be performed:",
      "ja": "「m =」セクションごとに、次の手順を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section has been rejected (i.e., the <port> value is set to zero in the answer), stop any reception or transmission of media for this section, and, unless a non-rejected \"m=\" section is bundled with this \"m=\" section, discard any associated ICE components, as described in [RFC8839], Section 4.4.3.1.",
      "ja": "* 「m =」セクションが拒否された場合（つまり、回答で<port>値がゼロに設定されている場合）、このセクションのメディアの受信または送信を停止し、拒否されていない「m =」セクションを除きます。はこの「m =」セクションにバンドルされており、[RFC8839]のセクション4.4.3.1で説明されているように、関連するICEコンポーネントをすべて破棄します。"
    },
    {
      "indent": 3,
      "text": "* If the remote DTLS fingerprint has been changed or the value of the \"a=tls-id\" attribute has changed, tear down the DTLS connection. This includes the case when the PeerConnection state is \"have-remote-pranswer\". If a DTLS connection needs to be torn down but the answer does not indicate an ICE restart or, in the case of \"have-remote-pranswer\", new ICE credentials, an error MUST be generated. If an ICE restart is performed without a change in the tls-id value or fingerprint, then the same DTLS connection is continued over the new ICE channel. Note that although JSEP requires that answerers change the tls-id value if and only if the offerer does, non-JSEP answerers are permitted to change the tls-id value as long as the offer contained an ICE restart. Thus, JSEP implementations that process DTLS data prior to receiving an answer MUST be prepared to receive either a ClientHello or data from the previous DTLS connection.",
      "ja": "* リモートDTLSフィンガープリントが変更された場合、または「a = tls-id」属性の値が変更された場合は、DTLS接続を切断します。これには、PeerConnectionの状態が「have-remote-pranswer」の場合も含まれます。DTLS接続を切断する必要があるが、回答がICEの再起動を示さない場合、または「have-remote-pranswer」の場合は新しいICE資格情報の場合、エラーを生成する必要があります。tls-id値またはフィンガープリントを変更せずにICEの再起動が実行された場合、同じDTLS接続が新しいICEチャネルを介して継続されます。JSEPでは、オファー側がtls-id値を変更する必要があるのは、オファー側が変更した場合のみですが、JSEP以外のアンサーは、オファーにICE再起動が含まれている限りtls-id値を変更できます。したがって、回答を受信する前にDTLSデータを処理するJSEP実装は、ClientHelloまたは以前のDTLS接続からのデータを受信するように準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If no valid DTLS connection exists, prepare to start a DTLS connection, using the specified roles and fingerprints, on any underlying ICE components, once they are active.",
      "ja": "* 有効なDTLS接続が存在しない場合は、基になるICEコンポーネントがアクティブになったら、指定されたロールとフィンガープリントを使用してDTLS接続を開始する準備をします。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section <proto> value indicates use of RTP:",
      "ja": "* 「m =」セクションの<proto>値がRTPの使用を示している場合："
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section references RTCP feedback mechanisms that were not present in the corresponding \"m=\" section in the offer, this indicates a negotiation problem and MUST result in an error. However, new media formats and new RTP header extension values are permitted in the answer, as described in [RFC3264], Section 7 and [RFC5285], Section 6.",
      "ja": "- 「m =」セクションがオファーの対応する「m =」セクションに存在しなかったRTCPフィードバックメカニズムを参照している場合、これはネゴシエーションの問題を示しており、エラーが発生する必要があります。ただし、[RFC3264]のセクション7および[RFC5285]のセクション6で説明されているように、新しいメディア形式と新しいRTPヘッダー拡張値が回答で許可されています。"
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section has RTCP mux enabled, discard the RTCP ICE component, if one exists, and begin or continue muxing RTCP over the RTP ICE component, as specified in [RFC5761], Section 5.1.3. Otherwise, prepare to transmit RTCP over the RTCP ICE component; if no RTCP ICE component exists because RTCP mux was previously enabled, this MUST result in an error.",
      "ja": "- 「m =」セクションでRTCPmuxが有効になっている場合は、RTCP ICEコンポーネントが存在する場合はそれを破棄し、[RFC5761]のセクション5.1.3で指定されているように、RTPICEコンポーネントを介してRTCPの多重化を開始または続行します。それ以外の場合は、RTCPICEコンポーネントを介してRTCPを送信する準備をします。RTCPマルチプレクサが以前に有効にされていたためにRTCPICEコンポーネントが存在しない場合、これはエラーにならなければならない[MUST]。"
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section has Reduced-Size RTCP enabled, configure the RTCP transmission for this \"m=\" section to use Reduced-Size RTCP, as specified in [RFC5506].",
      "ja": "- 「m =」セクションで縮小サイズRTCPが有効になっている場合は、[RFC5506]で指定されているように、この「m =」セクションのRTCP送信を縮小サイズRTCPを使用するように構成します。"
    },
    {
      "indent": 6,
      "text": "- If the direction attribute in the answer indicates that the JSEP implementation should be sending media (\"sendonly\" for local answers, \"recvonly\" for remote answers, or \"sendrecv\" for either type of answer), choose the media format to send as the most preferred media format from the remote description that is also locally supported, as discussed in Sections 6.1 and 7 of [RFC3264], and start transmitting RTP media using that format once the underlying transport layers have been established. If an SSRC has not already been chosen for this outgoing RTP stream, choose a unique random one. If media is already being transmitted, the same SSRC SHOULD be used unless the clock rate of the new codec is different, in which case a new SSRC MUST be chosen, as specified in [RFC7160], Section 4.1.",
      "ja": "- 回答のdirection属性が、JSEP実装がメディアを送信する必要があることを示している場合（ローカル回答の場合は「sendonly」、リモート回答の場合は「recvonly」、いずれかのタイプの回答の場合は「sendrecv」）、送信するメディア形式を選択します。[RFC3264]のセクション6.1および7で説明されているように、ローカルでもサポートされているリモート記述からの最も好ましいメディア形式。基盤となるトランスポート層が確立されたら、その形式を使用してRTPメディアの送信を開始します。この発信RTPストリームに対してSSRCがまだ選択されていない場合は、一意のランダムなものを選択してください。メディアがすでに送信されている場合は、新しいコーデックのクロックレートが異なる場合を除いて、同じSSRCを使用する必要があります。異なる場合は、[RFC7160]のセクション4.1で指定されているように、新しいSSRCを選択する必要があります。"
    },
    {
      "indent": 6,
      "text": "- The payload type mapping from the remote description is used to determine payload types for the outgoing RTP streams, including the payload type for the send media format chosen above. Any RTP header extensions that were negotiated should be included in the outgoing RTP streams, using the extension mapping from the remote description. If the MID header extension has been negotiated, include it in the outgoing RTP streams, as indicated in [RFC8843], Section 15. If the RtpStreamId or RepairedRtpStreamId header extensions have been negotiated and rid-ids have been established, include these header extensions in the outgoing RTP streams, as indicated in [RFC8851], Section 4.",
      "ja": "- リモート記述からのペイロードタイプマッピングは、上記で選択した送信メディア形式のペイロードタイプを含む、発信RTPストリームのペイロードタイプを決定するために使用されます。ネゴシエートされたRTPヘッダー拡張は、リモート記述からの拡張マッピングを使用して、発信RTPストリームに含める必要があります。MIDヘッダー拡張がネゴシエートされている場合は、[RFC8843]のセクション15に示されているように、発信RTPストリームに含めます。RtpStreamIdまたはRepairedRtpStreamIdヘッダー拡張がネゴシエートされ、rid-idが確立されている場合は、これらのヘッダー拡張を[RFC8851]のセクション4に示されているように、発信RTPストリーム。"
    },
    {
      "indent": 6,
      "text": "- If the \"m=\" section is of type \"audio\", and silence suppression was (1) configured for the send media format as a result of processing the remote description and (2) also enabled for that format in the local description, use silence suppression for outgoing media, in accordance with the guidance in Section 5.2.3.2. If these conditions are not met, silence suppression MUST NOT be used for outgoing media.",
      "ja": "- 「m =」セクションのタイプが「audio」であり、（1）リモート記述の処理の結果として送信メディア形式に対して無音抑制が構成され、（2）ローカル記述でその形式に対しても有効になっている場合は、次を使用します。セクション5.2.3.2のガイダンスに従った、発信メディアの無音抑制。これらの条件が満たされない場合、発信メディアに無音抑制を使用してはなりません（MUSTNOT）。"
    },
    {
      "indent": 6,
      "text": "- If simulcast has been negotiated, send the appropriate number of Source RTP Streams as specified in [RFC8853], Section 5.3.3.",
      "ja": "- サイマルキャストがネゴシエートされている場合は、[RFC8853]のセクション5.3.3で指定されている適切な数のソースRTPストリームを送信します。"
    },
    {
      "indent": 6,
      "text": "- If the send media format chosen above has a corresponding \"rtx\" media format or a FEC mechanism has been negotiated, establish a redundancy RTP stream with a unique random SSRC for each Source RTP Stream, and start or continue transmitting RTX/FEC packets as needed.",
      "ja": "- 上記で選択した送信メディア形式に対応する「rtx」メディア形式がある場合、またはFECメカニズムがネゴシエートされている場合は、ソースRTPストリームごとに一意のランダムSSRCを使用して冗長RTPストリームを確立し、必要に応じてRTX / FECパケットの送信を開始または続行します。。"
    },
    {
      "indent": 6,
      "text": "- If the send media format chosen above has a corresponding \"red\" media format of the same clock rate, allow redundant encoding using the specified format for resiliency purposes, as discussed in [RFC8854], Section 3.2. Note that unlike RTX or FEC media formats, the \"red\" format is transmitted on the Source RTP Stream, not the redundancy RTP stream.",
      "ja": "- 上記で選択した送信メディア形式に、同じクロックレートの対応する「赤」メディア形式がある場合は、[RFC8854]のセクション3.2で説明されているように、復元力の目的で指定された形式を使用した冗長エンコードを許可します。RTXまたはFECメディア形式とは異なり、「赤」形式は、冗長RTPストリームではなく、ソースRTPストリームで送信されることに注意してください。"
    },
    {
      "indent": 6,
      "text": "- Enable the RTCP feedback mechanisms referenced in the media section for all Source RTP Streams using the specified media formats. Specifically, begin or continue sending the requested feedback types and reacting to received feedback, as specified in [RFC4585], Section 4.2. When sending RTCP feedback, follow the rules and recommendations from [RFC8108], Section 5.4.1 to select which SSRC to use.",
      "ja": "- 指定されたメディア形式を使用して、すべてのソースRTPストリームのメディアセクションで参照されているRTCPフィードバックメカニズムを有効にします。具体的には、[RFC4585]のセクション4.2で指定されているように、要求されたフィードバックタイプの送信を開始または継続し、受信したフィードバックに対応します。RTCPフィードバックを送信するときは、[RFC8108]のセクション5.4.1のルールと推奨事項に従って、使用するSSRCを選択してください。"
    },
    {
      "indent": 6,
      "text": "- If the direction attribute in the answer indicates that the JSEP implementation should not be sending media (\"recvonly\" for local answers, \"sendonly\" for remote answers, or \"inactive\" for either type of answer), stop transmitting all RTP media, but continue sending RTCP, as described in [RFC3264], Section 5.1.",
      "ja": "- 回答のdirection属性が、JSEP実装がメディアを送信してはならないことを示している場合（ローカル回答の場合は「recvonly」、リモート回答の場合は「sendonly」、いずれかのタイプの回答の場合は「inactive」）、すべてのRTPメディアの送信を停止します。[RFC3264]のセクション5.1で説明されているように、RTCPの送信を続行します。"
    },
    {
      "indent": 3,
      "text": "* If the \"m=\" section <proto> value indicates use of SCTP:",
      "ja": "* 「m =」セクションの<proto>値がSCTPの使用を示している場合："
    },
    {
      "indent": 6,
      "text": "- If an SCTP association exists and the remote SCTP port has changed, discard the existing SCTP association. This includes the case when the PeerConnection state is \"have-remote-pranswer\".",
      "ja": "- SCTPアソシエーションが存在し、リモートSCTPポートが変更された場合は、既存のSCTPアソシエーションを破棄します。これには、PeerConnectionの状態が「have-remote-pranswer」の場合も含まれます。"
    },
    {
      "indent": 6,
      "text": "- If no valid SCTP association exists, prepare to initiate an SCTP association over the associated ICE component and DTLS connection, using the local SCTP port value from the local description and the remote SCTP port value from the remote description, as described in [RFC8841], Section 10.2.",
      "ja": "- 有効なSCTPアソシエーションが存在しない場合は、[RFC8841]で説明されているように、ローカル記述のローカルSCTPポート値とリモート記述のリモートSCTPポート値を使用して、関連付けられたICEコンポーネントとDTLS接続を介してSCTPアソシエーションを開始する準備をします。セクション10.2。"
    },
    {
      "indent": 3,
      "text": "If the answer contains valid bundle groups, discard any ICE components for the \"m=\" sections that will be bundled onto the primary ICE components in each bundle, and begin muxing these \"m=\" sections accordingly, as described in [RFC8843], Section 7.4.",
      "ja": "回答に有効なバンドルグループが含まれている場合は、[RFC8843]で説明されているように、各バンドルのプライマリICEコンポーネントにバンドルされる「m =」セクションのICEコンポーネントを破棄し、それに応じてこれらの「m =」セクションの多重化を開始します。セクション7.4。"
    },
    {
      "indent": 3,
      "text": "If the description is of type \"answer\" and there are still remaining candidates in the ICE candidate pool, discard them.",
      "ja": "説明のタイプが「answer」であり、ICE候補プールにまだ候補が残っている場合は、それらを破棄します。"
    },
    {
      "indent": 0,
      "text": "6. Processing RTP/RTCP",
      "section_title": true,
      "ja": "6. RTP / RTCPの処理"
    },
    {
      "indent": 3,
      "text": "When bundling, associating incoming RTP/RTCP with the proper \"m=\" section is defined in [RFC8843], Section 9.2. When not bundling, the proper \"m=\" section is clear from the ICE component over which the RTP/RTCP is received.",
      "ja": "バンドルする場合、着信RTP / RTCPを適切な「m =」セクションに関連付けることは[RFC8843]のセクション9.2で定義されています。バンドルしていない場合、適切な「m =」セクションは、RTP / RTCPを受信するICEコンポーネントからクリアされます。"
    },
    {
      "indent": 3,
      "text": "Once the proper \"m=\" section or sections are known, RTP/RTCP is delivered to the RtpTransceiver(s) associated with the \"m=\" section(s) and further processing of the RTP/RTCP is done at the RtpTransceiver level. This includes using the RID mechanism [RFC8851] and its associated RtpStreamId and RepairedRtpStreamId identifiers to distinguish between multiple encoded streams and determine which Source RTP stream should be repaired by a given redundancy RTP stream.",
      "ja": "適切な「m =」セクションがわかると、RTP / RTCPが「m =」セクションに関連付けられたRtpTransceiverに配信され、RTP / RTCPのさらなる処理がRtpTransceiverレベルで実行されます。これには、RIDメカニズム[RFC8851]とそれに関連するRtpStreamIdおよびRepairedRtpStreamId識別子を使用して、複数のエンコードされたストリームを区別し、特定の冗長RTPストリームによって修復する必要があるソースRTPストリームを決定することが含まれます。"
    },
    {
      "indent": 0,
      "text": "7. Examples",
      "section_title": true,
      "ja": "7. 例"
    },
    {
      "indent": 3,
      "text": "Note that this example section shows several SDP fragments. To accommodate RFC line-length restrictions, some of the SDP lines have been split into multiple lines, where leading whitespace indicates that a line is a continuation of the previous line. In addition, some blank lines have been added to improve readability but are not valid in SDP.",
      "ja": "このサンプルセクションは、いくつかのSDPフラグメントを示していることに注意してください。RFCの行の長さの制限に対応するために、一部のSDP行は複数の行に分割されています。先頭の空白は、行が前の行の続きであることを示しています。さらに、読みやすさを向上させるためにいくつかの空白行が追加されましたが、SDPでは無効です。"
    },
    {
      "indent": 3,
      "text": "More examples of SDP for WebRTC call flows, including examples with IPv6 addresses, can be found in [SDP4WebRTC].",
      "ja": "IPv6アドレスの例を含むWebRTCコールフローのSDPのその他の例は、[SDP4WebRTC]にあります。"
    },
    {
      "indent": 0,
      "text": "7.1. Simple Example",
      "section_title": true,
      "ja": "7.1. 簡単な例"
    },
    {
      "indent": 3,
      "text": "This section shows a very simple example that sets up a minimal audio/video call between two JSEP endpoints without using Trickle ICE. The example in the following section provides a more detailed example of what could happen in a JSEP session.",
      "ja": "このセクションでは、TrickleICEを使用せずに2つのJSEPエンドポイント間で最小限のオーディオ/ビデオ通話を設定する非常に簡単な例を示します。次のセクションの例は、JSEPセッションで発生する可能性のあるより詳細な例を示しています。"
    },
    {
      "indent": 3,
      "text": "The code flow below shows Alice's endpoint initiating the session to Bob's endpoint. The messages from the JavaScript application in Alice's browser to the JavaScript in Bob's browser, abbreviated as \"AliceJS\" and \"BobJS\", respectively, are assumed to flow over some signaling protocol via a web server. The JavaScript on both Alice's side and Bob's side waits for all candidates before sending the offer or answer, so the offers and answers are complete; Trickle ICE is not used. The user agents (JSEP implementations) in Alice's and Bob's browsers, abbreviated as \"AliceUA\" and \"BobUA\", respectively, are both using the default bundle policy of \"balanced\" and the default RTCP mux policy of \"require\".",
      "ja": "以下のコードフローは、アリスのエンドポイントがボブのエンドポイントへのセッションを開始することを示しています。アリスのブラウザのJavaScriptアプリケーションからボブのブラウザのJavaScriptへのメッセージは、それぞれ「AliceJS」および「BobJS」と省略され、Webサーバーを介して何らかのシグナリングプロトコルを介して流れると想定されています。アリス側とボブ側の両方のJavaScriptは、オファーまたは回答を送信する前にすべての候補者を待機するため、オファーと回答は完了です。TrickleICEは使用されていません。アリスとボブのブラウザのユーザーエージェント（JSEP実装）は、それぞれ「AliceUA」と「BobUA」と省略され、両方とも「balanced」のデフォルトバンドルポリシーと「require」のデフォルトRTCPマルチプレクサポリシーを使用しています。"
    },
    {
      "indent": 3,
      "text": "//                  set up local media state\nAliceJS->AliceUA:   create new PeerConnection\nAliceJS->AliceUA:   addTrack with two tracks: audio and video\nAliceJS->AliceUA:   createOffer to get offer\nAliceJS->AliceUA:   setLocalDescription with offer\nAliceUA->AliceJS:   multiple onicecandidate events with candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  wait for ICE gathering to complete\nAliceUA->AliceJS:   onicecandidate event with null candidate\nAliceJS->AliceUA:   get |offer-A1| from pendingLocalDescription",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-A1| is sent over signaling protocol to Bob\nAliceJS->WebServer: signaling with |offer-A1|\nWebServer->BobJS:   signaling with |offer-A1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-A1| arrives at Bob\nBobJS->BobUA:       create a PeerConnection\nBobJS->BobUA:       setRemoteDescription with |offer-A1|\nBobUA->BobJS:       ontrack events for audio and video tracks",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  Bob accepts call\nBobJS->BobUA:       addTrack with local tracks\nBobJS->BobUA:       createAnswer\nBobJS->BobUA:       setLocalDescription with answer\nBobUA->BobJS:       multiple onicecandidate events with candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  wait for ICE gathering to complete\nBobUA->BobJS:       onicecandidate event with null candidate\nBobJS->BobUA:       get |answer-A1| from currentLocalDescription",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-A1| is sent over signaling protocol\n//                  to Alice\nBobJS->WebServer:   signaling with |answer-A1|\nWebServer->AliceJS: signaling with |answer-A1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-A1| arrives at Alice\nAliceJS->AliceUA:   setRemoteDescription with |answer-A1|\nAliceUA->AliceJS:   ontrack events for audio and video tracks",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  media flows\nBobUA->AliceUA:     media sent from Bob to Alice\nAliceUA->BobUA:     media sent from Alice to Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |offer-A1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 4962303333179871722 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 10100 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 203.0.113.100\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:47017fee-b6c1-4162-929c-a25110252400\na=ice-ufrag:ETEn\na=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl\na=fingerprint:sha-256\n              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:\n              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2\na=setup:actpass\na=tls-id:91bbf309c0990a6bec11e38ba2933cee\na=rtcp:10101 IN IP4 203.0.113.100\na=rtcp-mux\na=rtcp-rsize\na=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host\na=candidate:1 2 udp 2113929470 203.0.113.100 10101 typ host\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 10102 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 203.0.113.100\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:47017fee-b6c1-4162-929c-a25110252400\na=ice-ufrag:BGKk\na=ice-pwd:mqyWsAjvtKwTGnvhPztQ9mIf\na=fingerprint:sha-256\n              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:\n              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2\na=setup:actpass\na=tls-id:91bbf309c0990a6bec11e38ba2933cee\na=rtcp:10103 IN IP4 203.0.113.100\na=rtcp-mux\na=rtcp-rsize\na=candidate:1 1 udp 2113929471 203.0.113.100 10102 typ host\na=candidate:1 2 udp 2113929470 203.0.113.100 10103 typ host\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |answer-A1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 6729291447651054566 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 10200 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 203.0.113.200\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:61317484-2ed4-49d7-9eb7-1414322a7aae\na=ice-ufrag:6sFv\na=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2\na=fingerprint:sha-256\n              6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:\n              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08\na=setup:active\na=tls-id:eec3392ab83e11ceb6a0990c903fbb19\na=rtcp-mux\na=rtcp-rsize\na=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 10200 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 203.0.113.200\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:61317484-2ed4-49d7-9eb7-1414322a7aae",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. Detailed Example",
      "section_title": true,
      "ja": "7.2. 詳細な例"
    },
    {
      "indent": 3,
      "text": "This section shows a more involved example of a session between two JSEP endpoints. Trickle ICE is used in full trickle mode, with a bundle policy of \"max-bundle\", an RTCP mux policy of \"require\", and a single TURN server. Initially, both Alice and Bob establish an audio channel and a data channel. Later, Bob adds two video flows -- one for his video feed and one for screen sharing, both supporting FEC -- with the video feed configured for simulcast. Alice accepts these video flows but does not add video flows of her own, so they are handled as recvonly. Alice also specifies a maximum video decoder resolution.",
      "ja": "このセクションでは、2つのJSEPエンドポイント間のセッションのより複雑な例を示します。Trickle ICEは、「max-bundle」のバンドルポリシー、「require」のRTCPマルチプレクサポリシー、および単一のTURNサーバーを使用して、フルトリクルモードで使用されます。最初に、アリスとボブの両方がオーディオチャネルとデータチャネルを確立します。その後、ボブは2つのビデオフローを追加します。1つはビデオフィード用、もう1つは画面共有用で、どちらもFECをサポートし、ビデオフィードは同時放送用に構成されています。アリスはこれらのビデオフローを受け入れますが、独自のビデオフローを追加しないため、recvonlyとして処理されます。アリスは、ビデオデコーダーの最大解像度も指定します。"
    },
    {
      "indent": 3,
      "text": "//                  set up local media state\nAliceJS->AliceUA:   create new PeerConnection\nAliceJS->AliceUA:   addTrack with an audio track\nAliceJS->AliceUA:   createDataChannel to get data channel\nAliceJS->AliceUA:   createOffer to get |offer-B1|\nAliceJS->AliceUA:   setLocalDescription with |offer-B1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-B1| is sent over signaling protocol to Bob\nAliceJS->WebServer: signaling with |offer-B1|\nWebServer->BobJS:   signaling with |offer-B1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-B1| arrives at Bob\nBobJS->BobUA:       create a PeerConnection\nBobJS->BobUA:       setRemoteDescription with |offer-B1|\nBobUA->BobJS:       ontrack event with audio track from Alice",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  candidates are sent to Bob\nAliceUA->AliceJS:   onicecandidate (host) |offer-B1-candidate-1|\nAliceJS->WebServer: signaling with |offer-B1-candidate-1|\nAliceUA->AliceJS:   onicecandidate (srflx) |offer-B1-candidate-2|\nAliceJS->WebServer: signaling with |offer-B1-candidate-2|\nAliceUA->AliceJS:   onicecandidate (relay) |offer-B1-candidate-3|\nAliceJS->WebServer: signaling with |offer-B1-candidate-3|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WebServer->BobJS:   signaling with |offer-B1-candidate-1|\nBobJS->BobUA:       addIceCandidate with |offer-B1-candidate-1|\nWebServer->BobJS:   signaling with |offer-B1-candidate-2|\nBobJS->BobUA:       addIceCandidate with |offer-B1-candidate-2|\nWebServer->BobJS:   signaling with |offer-B1-candidate-3|\nBobJS->BobUA:       addIceCandidate with |offer-B1-candidate-3|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  Bob accepts call\nBobJS->BobUA:       addTrack with local audio\nBobJS->BobUA:       createDataChannel to get data channel\nBobJS->BobUA:       createAnswer to get |answer-B1|\nBobJS->BobUA:       setLocalDescription with |answer-B1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-B1| is sent to Alice\nBobJS->WebServer:   signaling with |answer-B1|\nWebServer->AliceJS: signaling with |answer-B1|\nAliceJS->AliceUA:   setRemoteDescription with |answer-B1|\nAliceUA->AliceJS:   ontrack event with audio track from Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  candidates are sent to Alice\nBobUA->BobJS:       onicecandidate (host) |answer-B1-candidate-1|\nBobJS->WebServer:   signaling with |answer-B1-candidate-1|\nBobUA->BobJS:       onicecandidate (srflx) |answer-B1-candidate-2|\nBobJS->WebServer:   signaling with |answer-B1-candidate-2|\nBobUA->BobJS:       onicecandidate (relay) |answer-B1-candidate-3|\nBobJS->WebServer:   signaling with |answer-B1-candidate-3|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WebServer->AliceJS: signaling with |answer-B1-candidate-1|\nAliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-1|\nWebServer->AliceJS: signaling with |answer-B1-candidate-2|\nAliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-2|\nWebServer->AliceJS: signaling with |answer-B1-candidate-3|\nAliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-3|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  data channel opens\nBobUA->BobJS:       ondatachannel event\nAliceUA->AliceJS:   ondatachannel event\nBobUA->BobJS:       onopen\nAliceUA->AliceJS:   onopen",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  media is flowing between endpoints\nBobUA->AliceUA:     audio+data sent from Bob to Alice\nAliceUA->BobUA:     audio+data sent from Alice to Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  some time later, Bob adds two video streams\n//                  note: no candidates exchanged, because of bundle\nBobJS->BobUA:       addTrack with first video stream\nBobJS->BobUA:       addTrack with second video stream\nBobJS->BobUA:       createOffer to get |offer-B2|\nBobJS->BobUA:       setLocalDescription with |offer-B2|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-B2| is sent to Alice\nBobJS->WebServer:   signaling with |offer-B2|\nWebServer->AliceJS: signaling with |offer-B2|\nAliceJS->AliceUA:   setRemoteDescription with |offer-B2|\nAliceUA->AliceJS:   ontrack event with first video track\nAliceUA->AliceJS:   ontrack event with second video track\nAliceJS->AliceUA:   createAnswer to get |answer-B2|\nAliceJS->AliceUA:   setLocalDescription with |answer-B2|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-B2| is sent over signaling protocol\n//                  to Bob\nAliceJS->WebServer: signaling with |answer-B2|\nWebServer->BobJS:   signaling with |answer-B2|\nBobJS->BobUA:       setRemoteDescription with |answer-B2|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  media is flowing between endpoints\nBobUA->AliceUA:     audio+video+data sent from Bob to Alice\nAliceUA->BobUA:     audio+video+data sent from Alice to Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |offer-B1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 4962303333179871723 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 d1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 0.0.0.0\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:57017fee-b6c1-4162-929c-a25110252400\na=ice-ufrag:ATEn\na=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl\na=fingerprint:sha-256\n              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:\n              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2\na=setup:actpass\na=tls-id:17f0f4ba8a5f1213faca591b58ba52a7\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=application 0 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 0.0.0.0\na=mid:d1\na=sctp-port:5000\na=max-message-size:65536\na=bundle-only",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|offer-B1-candidate-1| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag ATEn index 0 mid a1 attr candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host",
      "ja": "ufragATEnインデックス0mid a1 attr候補：1 1 udp 2113929471 203.0.113.100 10100typホスト"
    },
    {
      "indent": 3,
      "text": "|offer-B1-candidate-2| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag ATEn index 0 mid a1 attr candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx raddr 203.0.113.100 rport 10100",
      "ja": "ufrag ATEn index 0 mid a1 attr Candidate：1 1 udp 1845494015 198.51.100.100 11100 typ srflx raddr 203.0.113.100 rport 10100"
    },
    {
      "indent": 3,
      "text": "|offer-B1-candidate-3| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag ATEn index 0 mid a1 attr candidate:1 1 udp 255 192.0.2.100 12100 typ relay raddr 198.51.100.100 rport 11100",
      "ja": "ufragATEnインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.100 12100typリレーraddr198.51.100.100 rport 11100"
    },
    {
      "indent": 3,
      "text": "The SDP for |answer-B1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 7729291447651054566 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 d1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 0.0.0.0\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:71317484-2ed4-49d7-9eb7-1414322a7aae\na=ice-ufrag:7sFv\na=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2\na=fingerprint:sha-256\n              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:\n              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08\na=setup:active\na=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 0.0.0.0\na=mid:d1\na=sctp-port:5000\na=max-message-size:65536",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|answer-B1-candidate-1| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag 7sFv index 0 mid a1 attr candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host",
      "ja": "ufrag 7sFv index 0 mid a1 attr Candidate：1 1 udp 2113929471 203.0.113.200 10200 typ host"
    },
    {
      "indent": 3,
      "text": "|answer-B1-candidate-2| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag 7sFv index 0 mid a1 attr candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx raddr 203.0.113.200 rport 10200",
      "ja": "ufrag 7sFv index 0 mid a1 attr Candidate：1 1 udp 1845494015 198.51.100.200 11200 typ srflx raddr 203.0.113.200 rport 10200"
    },
    {
      "indent": 3,
      "text": "|answer-B1-candidate-3| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag 7sFv index 0 mid a1 attr candidate:1 1 udp 255 192.0.2.200 12200 typ relay raddr 198.51.100.200 rport 11200",
      "ja": "ufrag7sFvインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.200 12200typリレーraddr198.51.100.200 rport 11200"
    },
    {
      "indent": 3,
      "text": "The SDP for |offer-B2| is shown below. In addition to the new \"m=\" sections for video, both of which are offering FEC and one of which is offering simulcast, note the increment of the version number in the \"o=\" line; changes to the \"c=\" line, indicating the local candidate that was selected; and the inclusion of gathered candidates as a=candidate lines.",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 7729291447651054566 2 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 d1 v1 v2\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 192.0.2.200\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:71317484-2ed4-49d7-9eb7-1414322a7aae\na=ice-ufrag:7sFv\na=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2\na=fingerprint:sha-256\n              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:\n              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08\na=setup:actpass\na=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize\na=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host\na=candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx\n            raddr 203.0.113.200 rport 10200\na=candidate:1 1 udp 255 192.0.2.200 12200 typ relay\n            raddr 198.51.100.200 rport 11200\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=application 12200 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 192.0.2.200\na=mid:d1\na=sctp-port:5000\na=max-message-size:65536",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104\nc=IN IP4 192.0.2.200\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=rtpmap:104 flexfec/90000\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:71317484-2ed4-49d7-9eb7-1414322a7aae\na=rid:1 send\na=rid:2 send\na=rid:3 send\na=simulcast:send 1;2;3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104\nc=IN IP4 192.0.2.200\na=mid:v2\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=rtpmap:104 flexfec/90000\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:81317484-2ed4-49d7-9eb7-1414322a7aae",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |answer-B2| is shown below. In addition to the acceptance of the video \"m=\" sections, the use of a=recvonly to indicate one-way video, and the use of a=imageattr to limit the received resolution, note the use of setup:passive to maintain the existing DTLS roles.",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 4962303333179871723 2 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 d1 v1 v2\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 192.0.2.100\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:57017fee-b6c1-4162-929c-a25110252400\na=ice-ufrag:ATEn\na=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl\na=fingerprint:sha-256\n              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:\n              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2\na=setup:passive\na=tls-id:17f0f4ba8a5f1213faca591b58ba52a7\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize\na=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host\na=candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx\n            raddr 203.0.113.100 rport 10100\na=candidate:1 1 udp 255 192.0.2.100 12100 typ relay\n            raddr 198.51.100.100 rport 11100\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=application 12100 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 192.0.2.100\na=mid:d1\na=sctp-port:5000\na=max-message-size:65536",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 192.0.2.100\na=mid:v1\na=recvonly\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 192.0.2.100\na=mid:v2\na=recvonly\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3. Early Transport Warmup Example",
      "section_title": true,
      "ja": "7.3. 早期輸送ウォームアップの例"
    },
    {
      "indent": 3,
      "text": "This example demonstrates the early-warmup technique described in Section 4.1.10.1. Here, Alice's endpoint sends an offer to Bob's endpoint to start an audio/video call. Bob immediately responds with an answer that accepts the audio/video \"m=\" sections but marks them as sendonly (from his perspective), meaning that Alice will not yet send media. This allows the JSEP implementation to start negotiating ICE and DTLS immediately. Bob's endpoint then prompts him to answer the call, and when he does, his endpoint sends a second offer, which enables the audio and video \"m=\" sections, and thereby bidirectional media transmission. The advantage of such a flow is that as soon as the first answer is received, the implementation can proceed with ICE and DTLS negotiation and establish the session transport. If the transport setup completes before the second offer is sent, then media can be transmitted by the callee immediately upon answering the call, minimizing perceived post-dial delay. The second offer/answer exchange can also change the preferred codecs or other session parameters.",
      "ja": "この例は、セクション4.1.10.1で説明されている早期ウォームアップ手法を示しています。ここで、アリスのエンドポイントはボブのエンドポイントに音声/ビデオ通話を開始するためのオファーを送信します。ボブはすぐに、オーディオ/ビデオの「m =」セクションを受け入れるが、（彼の観点から）それらを送信専用としてマークする回答で応答します。これは、アリスがまだメディアを送信しないことを意味します。これにより、JSEP実装はICEとDTLSのネゴシエーションをすぐに開始できます。次に、ボブのエンドポイントは電話に応答するように促し、応答すると、エンドポイントは2番目のオファーを送信します。これにより、オーディオとビデオの「m =」セクションが有効になり、双方向のメディア送信が可能になります。このようなフローの利点は、最初の回答を受信するとすぐに、実装がICEおよびDTLSネゴシエーションを続行し、セッショントランスポートを確立できることです。 2番目のオファーが送信される前にトランスポートのセットアップが完了すると、通話に応答するとすぐに受信者がメディアを送信できるため、ダイヤル後の遅延が最小限に抑えられます。 2番目のオファー/アンサー交換でも、優先コーデックまたはその他のセッションパラメータを変更できます。"
    },
    {
      "indent": 3,
      "text": "This example also makes use of the \"relay\" ICE candidate policy described in Section 3.5.3 to minimize the ICE gathering and checking needed.",
      "ja": "この例では、セクション3.5.3で説明されている「リレー」ICE候補ポリシーを利用して、必要なICEの収集とチェックを最小限に抑えています。"
    },
    {
      "indent": 3,
      "text": "//                  set up local media state\nAliceJS->AliceUA:   create new PeerConnection with \"relay\" ICE policy\nAliceJS->AliceUA:   addTrack with two tracks: audio and video\nAliceJS->AliceUA:   createOffer to get |offer-C1|\nAliceJS->AliceUA:   setLocalDescription with |offer-C1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-C1| is sent over signaling protocol to Bob\nAliceJS->WebServer: signaling with |offer-C1|\nWebServer->BobJS:   signaling with |offer-C1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-C1| arrives at Bob\nBobJS->BobUA:       create new PeerConnection with \"relay\" ICE policy\nBobJS->BobUA:       setRemoteDescription with |offer-C1|\nBobUA->BobJS:       ontrack events for audio and video",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  a relay candidate is sent to Bob\nAliceUA->AliceJS:   onicecandidate (relay) |offer-C1-candidate-1|\nAliceJS->WebServer: signaling with |offer-C1-candidate-1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WebServer->BobJS:   signaling with |offer-C1-candidate-1|\nBobJS->BobUA:       addIceCandidate with |offer-C1-candidate-1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  Bob prepares an early answer to warm up the\n//                  transport\nBobJS->BobUA:       addTransceiver with null audio and video tracks\nBobJS->BobUA:       transceiver.setDirection(sendonly) for both\nBobJS->BobUA:       createAnswer\nBobJS->BobUA:       setLocalDescription with answer",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-C1| is sent over signaling protocol\n//                  to Alice\nBobJS->WebServer:   signaling with |answer-C1|\nWebServer->AliceJS: signaling with |answer-C1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-C1| (sendonly) arrives at Alice\nAliceJS->AliceUA:   setRemoteDescription with |answer-C1|\nAliceUA->AliceJS:   ontrack events for audio and video",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  a relay candidate is sent to Alice\nBobUA->BobJS:       onicecandidate (relay) |answer-B1-candidate-1|\nBobJS->WebServer:   signaling with |answer-B1-candidate-1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WebServer->AliceJS: signaling with |answer-B1-candidate-1|\nAliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-1|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// ICE and DTLS establish while call is ringing",
      "ja": "// ICEとDTLSは、通話が鳴っている間に確立します"
    },
    {
      "indent": 3,
      "text": "//                  Bob accepts call, starts media, and sends\n//                  new offer\nBobJS->BobUA:       transceiver.setTrack with audio and video tracks\nBobUA->AliceUA:     media sent from Bob to Alice\nBobJS->BobUA:       transceiver.setDirection(sendrecv) for both\n                    transceivers\nBobJS->BobUA:       createOffer\nBobJS->BobUA:       setLocalDescription with offer",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-C2| is sent over signaling protocol\n//                  to Alice\nBobJS->WebServer:   signaling with |offer-C2|\nWebServer->AliceJS: signaling with |offer-C2|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |offer-C2| (sendrecv) arrives at Alice\nAliceJS->AliceUA:   setRemoteDescription with |offer-C2|\nAliceJS->AliceUA:   createAnswer\nAliceJS->AliceUA:   setLocalDescription with |answer-C2|\nAliceUA->BobUA:     media sent from Alice to Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "//                  |answer-C2| is sent over signaling protocol\n//                  to Bob\nAliceJS->WebServer: signaling with |answer-C2|\nWebServer->BobJS:   signaling with |answer-C2|\nBobJS->BobUA:       setRemoteDescription with |answer-C2|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |offer-C1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 1070771854436052752 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 0.0.0.0\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce\na=ice-ufrag:4ZcD\na=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD\na=fingerprint:sha-256\n              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:\n              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF\na=setup:actpass\na=tls-id:9e5b948ade9c3d41de6617b68f769e55\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 0 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 0.0.0.0\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce\na=bundle-only",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|offer-C1-candidate-1| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag 4ZcD index 0 mid a1 attr candidate:1 1 udp 255 192.0.2.100 12100 typ relay raddr 0.0.0.0 rport 0",
      "ja": "ufrag4ZcDインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.100 12100typリレーraddr0.0.0.0 rport 0"
    },
    {
      "indent": 3,
      "text": "The SDP for |answer-C1| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 6386516489780559513 1 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 0.0.0.0\na=mid:a1\na=sendonly\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:751f239e-4ae0-c549-aa3d-890de772998b\na=ice-ufrag:TpaA\na=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/\na=fingerprint:sha-256\n              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:\n              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D\na=setup:active\na=tls-id:55e967f86b7166ed14d3c9eda849b5e9\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 9 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 0.0.0.0\na=mid:v1\na=sendonly\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:751f239e-4ae0-c549-aa3d-890de772998b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|answer-C1-candidate-1| looks like:",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ufrag TpaA index 0 mid a1 attr candidate:1 1 udp 255 192.0.2.200 12200 typ relay raddr 0.0.0.0 rport 0",
      "ja": "ufragTpaAインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.200 12200typリレーraddr0.0.0.0 rport 0"
    },
    {
      "indent": 3,
      "text": "The SDP for |offer-C2| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 6386516489780559513 2 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 192.0.2.200\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:751f239e-4ae0-c549-aa3d-890de772998b\na=ice-ufrag:TpaA\na=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/\na=fingerprint:sha-256\n              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:\n              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D\na=setup:actpass\na=tls-id:55e967f86b7166ed14d3c9eda849b5e9\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize\na=candidate:1 1 udp 255 192.0.2.200 12200 typ relay\n            raddr 0.0.0.0 rport 0\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 192.0.2.200\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:751f239e-4ae0-c549-aa3d-890de772998b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SDP for |answer-C2| looks like:",
      "ja": "のSDP"
    },
    {
      "indent": 3,
      "text": "v=0\no=- 1070771854436052752 2 IN IP4 0.0.0.0\ns=-\nt=0 0\na=ice-options:trickle ice2\na=group:BUNDLE a1 v1\na=group:LS a1 v1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98\nc=IN IP4 192.0.2.100\na=mid:a1\na=sendrecv\na=rtpmap:96 opus/48000/2\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 telephone-event/8000\na=rtpmap:98 telephone-event/48000\na=fmtp:97 0-15\na=fmtp:98 0-15\na=maxptime:120\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce\na=ice-ufrag:4ZcD\na=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD\na=fingerprint:sha-256\n              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:\n              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF\na=setup:passive\na=tls-id:9e5b948ade9c3d41de6617b68f769e55\na=rtcp-mux\na=rtcp-mux-only\na=rtcp-rsize\na=candidate:1 1 udp 255 192.0.2.100 12100 typ relay\n            raddr 0.0.0.0 rport 0\na=end-of-candidates",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103\nc=IN IP4 192.0.2.100\na=mid:v1\na=sendrecv\na=rtpmap:100 VP8/90000\na=rtpmap:101 H264/90000\na=fmtp:101 packetization-mode=1;profile-level-id=42e01f\na=rtpmap:102 rtx/90000\na=fmtp:102 apt=100\na=rtpmap:103 rtx/90000\na=fmtp:103 apt=101\na=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtcp-fb:100 ccm fir\na=rtcp-fb:100 nack\na=rtcp-fb:100 nack pli\na=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The IETF has published separate documents [RFC8827] [RFC8826] describing the security architecture for WebRTC as a whole. The remainder of this section describes security considerations for this document.",
      "ja": "IETFは、WebRTC全体のセキュリティアーキテクチャを説明する個別のドキュメント[RFC8827] [RFC8826]を公開しています。このセクションの残りの部分では、このドキュメントのセキュリティに関する考慮事項について説明します。"
    },
    {
      "indent": 3,
      "text": "While formally the JSEP interface is an API, it is better to think of it as an Internet protocol, with the application JavaScript being untrustworthy from the perspective of the JSEP implementation. Thus, the threat model of [RFC3552] applies. In particular, JavaScript can call the API in any order and with any inputs, including malicious ones. This is particularly relevant when we consider the SDP that is passed to setLocalDescription. While correct API usage requires that the application pass in SDP that was derived from createOffer or createAnswer, there is no guarantee that applications do so. The JSEP implementation MUST be prepared for the JavaScript to pass in bogus data instead.",
      "ja": "正式にはJSEPインターフェースはAPIですが、JSEP実装の観点からは、アプリケーションJavaScriptは信頼できないため、インターネットプロトコルと考えることをお勧めします。したがって、[RFC3552]の脅威モデルが適用されます。特に、JavaScriptは、悪意のあるものを含め、任意の順序で任意の入力を使用してAPIを呼び出すことができます。これは、setLocalDescriptionに渡されるSDPを検討する場合に特に関係があります。APIを正しく使用するには、createOfferまたはcreateAnswerから派生したSDPをアプリケーションが渡す必要がありますが、アプリケーションがそうするという保証はありません。JSEP実装は、JavaScriptが代わりに偽のデータを渡すように準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Conversely, the application programmer needs to be aware that the JavaScript does not have complete control of endpoint behavior. One case that bears particular mention is that editing ICE candidates out of the SDP or suppressing trickled candidates does not have the expected behavior: implementations will still perform checks from those candidates even if they are not sent to the other side. Thus, for instance, it is not possible to prevent the remote peer from learning your public IP address by removing server-reflexive candidates. Applications that wish to conceal their public IP address MUST instead configure the ICE agent to use only relay candidates.",
      "ja": "逆に、アプリケーションプログラマーは、JavaScriptがエンドポイントの動作を完全に制御できないことに注意する必要があります。特に言及する1つのケースは、SDPからICE候補を編集したり、細流の候補を抑制したりしても、期待される動作がないことです。実装は、反対側に送信されなくても、それらの候補からのチェックを実行します。したがって、たとえば、サーバー再帰候補を削除することによって、リモートピアがパブリックIPアドレスを学習するのを防ぐことはできません。パブリックIPアドレスを隠したいアプリケーションは、代わりにリレー候補のみを使用するようにICEエージェントを構成する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SessionInitiationProtocol」、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, DOI 10.17487/RFC3264, June 2002, <https://www.rfc-editor.org/info/rfc3264>.",
      "ja": "[RFC3264] Rosenberg、J。およびH. Schulzrinne、「Session Description Protocol（SDP）を使用したオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org/ info / rfc3264>。"
    },
    {
      "indent": 3,
      "text": "[RFC3552] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.",
      "ja": "[RFC3552] Rescorla、E。およびB. Korver、「セキュリティの考慮事項に関するRFCテキストを作成するためのガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/info / rfc3552>。"
    },
    {
      "indent": 3,
      "text": "[RFC3605] Huitema, C., \"Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)\", RFC 3605, DOI 10.17487/RFC3605, October 2003, <https://www.rfc-editor.org/info/rfc3605>.",
      "ja": "[RFC3605] Huitema、C。、「Session Description Protocol（SDP）のReal Time Control Protocol（RTCP）属性」、RFC 3605、DOI 10.17487 / RFC3605、2003年10月、<https://www.rfc-editor.org/info / rfc3605>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月2004年、<https://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC3890] Westerlund, M., \"A Transport Independent Bandwidth Modifier for the Session Description Protocol (SDP)\", RFC 3890, DOI 10.17487/RFC3890, September 2004, <https://www.rfc-editor.org/info/rfc3890>.",
      "ja": "[RFC3890] Westerlund、M。、「A Transport Independent Bandwidth Modifier for the Session Description Protocol（SDP）」、RFC 3890、DOI 10.17487 / RFC3890、2004年9月、<https://www.rfc-editor.org/info/rfc3890>。"
    },
    {
      "indent": 3,
      "text": "[RFC4145] Yon, D. and G. Camarillo, \"TCP-Based Media Transport in the Session Description Protocol (SDP)\", RFC 4145, DOI 10.17487/RFC4145, September 2005, <https://www.rfc-editor.org/info/rfc4145>.",
      "ja": "[RFC4145] Yon、D。およびG. Camarillo、「Session Description Protocol（SDP）におけるTCPベースのメディアトランスポート」、RFC 4145、DOI 10.17487 / RFC4145、2005年9月、<https：//www.rfc-editor。org / info / rfc4145>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <https://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566] Handley、M.、Jacobson、V。、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/info / rfc4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <https://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C。、およびJ. Rey、「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / AVPF）の拡張RTPプロファイル\"、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<https://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC5124] Ott, J. and E. Carrara, \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\", RFC 5124, DOI 10.17487/RFC5124, February 2008, <https://www.rfc-editor.org/info/rfc5124>.",
      "ja": "[RFC5124] Ott、J。およびE. Carrara、「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）用の拡張セキュアRTPプロファイル」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<https：//www.rfc-editor.org/info/rfc5124>。"
    },
    {
      "indent": 3,
      "text": "[RFC5285] Singer, D. and H. Desineni, \"A General Mechanism for RTP Header Extensions\", RFC 5285, DOI 10.17487/RFC5285, July 2008, <https://www.rfc-editor.org/info/rfc5285>.",
      "ja": "[RFC5285] Singer、D。and H. Desineni、 \"A General Mechanism for RTP Header Extensions\"、RFC 5285、DOI 10.17487 / RFC5285、July 2008、<https://www.rfc-editor.org/info/rfc5285>。"
    },
    {
      "indent": 3,
      "text": "[RFC5761] Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and Control Packets on a Single Port\", RFC 5761, DOI 10.17487/RFC5761, April 2010, <https://www.rfc-editor.org/info/rfc5761>.",
      "ja": "[RFC5761] Perkins、C。およびM. Westerlund、「単一ポートでのRTPデータと制御パケットの多重化」、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<https://www.rfc-editor.org/info/ rfc5761>。"
    },
    {
      "indent": 3,
      "text": "[RFC5888] Camarillo, G. and H. Schulzrinne, \"The Session Description Protocol (SDP) Grouping Framework\", RFC 5888, DOI 10.17487/RFC5888, June 2010, <https://www.rfc-editor.org/info/rfc5888>.",
      "ja": "[RFC5888] Camarillo、G。およびH. Schulzrinne、「The Session Description Protocol（SDP）Grouping Framework」、RFC 5888、DOI 10.17487 / RFC5888、2010年6月、<https://www.rfc-editor.org/info/rfc5888>。"
    },
    {
      "indent": 3,
      "text": "[RFC6236] Johansson, I. and K. Jung, \"Negotiation of Generic Image Attributes in the Session Description Protocol (SDP)\", RFC 6236, DOI 10.17487/RFC6236, May 2011, <https://www.rfc-editor.org/info/rfc6236>.",
      "ja": "[RFC6236] Johansson、I。およびK. Jung、「Session Description Protocol（SDP）における汎用画像属性のネゴシエーション」、RFC 6236、DOI 10.17487 / RFC6236、2011年5月、<https：//www.rfc-editor。org / info / rfc6236>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6716] Valin, JM., Vos, K., and T. Terriberry, \"Definition of the Opus Audio Codec\", RFC 6716, DOI 10.17487/RFC6716, September 2012, <https://www.rfc-editor.org/info/rfc6716>.",
      "ja": "[RFC6716] Valin、JM。、Vos、K。、およびT. Terriberry、「Definition of the Opus Audio Codec」、RFC 6716、DOI 10.17487 / RFC6716、2012年9月、<https://www.rfc-editor.org/ info / rfc6716>。"
    },
    {
      "indent": 3,
      "text": "[RFC6904] Lennox, J., \"Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP)\", RFC 6904, DOI 10.17487/RFC6904, April 2013, <https://www.rfc-editor.org/info/rfc6904>.",
      "ja": "[RFC6904] Lennox、J。、「Secure Real-time Transport Protocol（SRTP）におけるヘッダー拡張の暗号化」、RFC 6904、DOI 10.17487 / RFC6904、2013年4月、<https://www.rfc-editor.org/info / rfc6904>。"
    },
    {
      "indent": 3,
      "text": "[RFC7160] Petit-Huguenin, M. and G. Zorn, Ed., \"Support for Multiple Clock Rates in an RTP Session\", RFC 7160, DOI 10.17487/RFC7160, April 2014, <https://www.rfc-editor.org/info/rfc7160>.",
      "ja": "[RFC7160] Petit-Huguenin、M。and G. Zorn、Ed。、 \"Support for Multiple Clock Rate in a RTP Session\"、RFC 7160、DOI 10.17487 / RFC7160、April 2014、<https：//www.rfc-editor.org / info / rfc7160>。"
    },
    {
      "indent": 3,
      "text": "[RFC7587] Spittka, J., Vos, K., and JM. Valin, \"RTP Payload Format for the Opus Speech and Audio Codec\", RFC 7587, DOI 10.17487/RFC7587, June 2015, <https://www.rfc-editor.org/info/rfc7587>.",
      "ja": "[RFC7587] Spittka、J.、Vos、K。、およびJM。Valin、「Opus Speech and Audio CodecのRTPペイロード形式」、RFC 7587、DOI 10.17487 / RFC7587、2015年6月、<https://www.rfc-editor.org/info/rfc7587>。"
    },
    {
      "indent": 3,
      "text": "[RFC7742] Roach, A.B., \"WebRTC Video Processing and Codec Requirements\", RFC 7742, DOI 10.17487/RFC7742, March 2016, <https://www.rfc-editor.org/info/rfc7742>.",
      "ja": "[RFC7742] Roach、A.B。、「WebRTC Video Processing and Codec Requirements」、RFC 7742、DOI 10.17487 / RFC7742、2016年3月、<https://www.rfc-editor.org/info/rfc7742>。"
    },
    {
      "indent": 3,
      "text": "[RFC7850] Nandakumar, S., \"Registering Values of the SDP 'proto' Field for Transporting RTP Media over TCP under Various RTP Profiles\", RFC 7850, DOI 10.17487/RFC7850, April 2016, <https://www.rfc-editor.org/info/rfc7850>.",
      "ja": "[RFC7850] Nandakumar、S。、「さまざまなRTPプロファイルでTCPを介してRTPメディアを転送するためのSDP「proto」フィールドの値の登録」、RFC 7850、DOI 10.17487 / RFC7850、2016年4月、<https：//www.rfc-editor.org/info/rfc7850>。"
    },
    {
      "indent": 3,
      "text": "[RFC7874] Valin, JM. and C. Bran, \"WebRTC Audio Codec and Processing Requirements\", RFC 7874, DOI 10.17487/RFC7874, May 2016, <https://www.rfc-editor.org/info/rfc7874>.",
      "ja": "[RFC7874]ヴァリン、JM。およびC.Bran、「WebRTCオーディオコーデックおよび処理要件」、RFC 7874、DOI 10.17487 / RFC7874、2016年5月、<https://www.rfc-editor.org/info/rfc7874>。"
    },
    {
      "indent": 3,
      "text": "[RFC8108] Lennox, J., Westerlund, M., Wu, Q., and C. Perkins, \"Sending Multiple RTP Streams in a Single RTP Session\", RFC 8108, DOI 10.17487/RFC8108, March 2017, <https://www.rfc-editor.org/info/rfc8108>.",
      "ja": "[RFC8108] Lennox、J.、Westerlund、M.、Wu、Q。、およびC. Perkins、「単一のRTPセッションで複数のRTPストリームを送信する」、RFC 8108、DOI 10.17487 / RFC8108、2017年3月、<https：//www.rfc-editor.org/info/rfc8108>。"
    },
    {
      "indent": 3,
      "text": "[RFC8122] Lennox, J. and C. Holmberg, \"Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)\", RFC 8122, DOI 10.17487/RFC8122, March 2017, <https://www.rfc-editor.org/info/rfc8122>.",
      "ja": "[RFC8122] Lennox、J。and C. Holmberg、 \"Connection-Oriented Media Transport over the Transport Layer Security（TLS）Protocol in the Session Description Protocol（SDP）\"、RFC 8122、DOI 10.17487 / RFC8122、March 2017、<https：//www.rfc-editor.org/info/rfc8122>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードにおける大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal\", RFC 8445, DOI 10.17487/RFC8445, July 2018, <https://www.rfc-editor.org/info/rfc8445>.",
      "ja": "[RFC8445] Keranen、A.、Holmberg、C。、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、<https://www.rfc-editor.org/info/rfc8445>。"
    },
    {
      "indent": 3,
      "text": "[RFC8826] Rescorla, E., \"Security Considerations for WebRTC\", RFC 8826, DOI 10.17487/RFC8826, January 2021, <https://www.rfc-editor.org/info/rfc8826>.",
      "ja": "[RFC8826] Rescorla、E。、「WebRTCのセキュリティに関する考慮事項」、RFC 8826、DOI 10.17487 / RFC8826、2021年1月、<https://www.rfc-editor.org/info/rfc8826>。"
    },
    {
      "indent": 3,
      "text": "[RFC8827] Rescorla, E., \"WebRTC Security Architecture\", RFC 8827, DOI 10.17487/RFC8827, January 2021, <https://www.rfc-editor.org/info/rfc8827>.",
      "ja": "[RFC8827] Rescorla、E。、「WebRTC Security Architecture」、RFC 8827、DOI 10.17487 / RFC8827、2021年1月、<https://www.rfc-editor.org/info/rfc8827>。"
    },
    {
      "indent": 3,
      "text": "[RFC8830] Alvestrand, H., \"WebRTC MediaStream Identification in the Session Description Protocol\", RFC 8830, DOI 10.17487/RFC8830, January 2021, <https://www.rfc-editor.org/info/rfc8830>.",
      "ja": "[RFC8830] Alvestrand、H。、「Session DescriptionProtocolでのWebRTCMediaStream Identification」、RFC 8830、DOI 10.17487 / RFC8830、2021年1月、<https://www.rfc-editor.org/info/rfc8830>。"
    },
    {
      "indent": 3,
      "text": "[RFC8834] Perkins, C., Westerlund, M., and J. Ott, \"Media Transport and Use of RTP in WebRTC\", RFC 8834, DOI 10.17487/RFC8834, January 2021, <https://www.rfc-editor.org/info/rfc8834>.",
      "ja": "[RFC8834] Perkins、C.、Westerlund、M。、およびJ. Ott、「Media Transport and Use of RTP in WebRTC」、RFC 8834、DOI 10.17487 / RFC8834、2021年1月、<https：//www.rfc-editor.org / info / rfc8834>。"
    },
    {
      "indent": 3,
      "text": "[RFC8838] Ivov, E., Uberti, J., and P. Saint-Andre, \"Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol\", RFC 8838, DOI 10.17487/RFC8838, January 2021, <https://www.rfc-editor.org/info/rfc8838>.",
      "ja": "[RFC8838] Ivov、E.、Uberti、J。、およびP. Saint-Andre、「Trickle ICE：Interactive Connectivity Establishment（ICE）プロトコルの候補のインクリメンタルプロビジョニング」、RFC 8838、DOI 10.17487 / RFC8838、2021年1月<https://www.rfc-editor.org/info/rfc8838>。"
    },
    {
      "indent": 3,
      "text": "[RFC8839] Petit-Huguenin, M., Nandakumar, S., Holmberg, C., Keränen, A., and R. Shpount, \"Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE)\", RFC 8839, DOI 10.17487/RFC8839, January 2021, <https://www.rfc-editor.org/info/rfc8839>.",
      "ja": "[RFC8839] Petit-Huguenin、M.、Nandakumar、S.、Holmberg、C.、Keränen、A。、およびR. Shpount、「Interactive Connectivity Establishment（ICE）のセッション記述プロトコル（SDP）オファー/アンサー手順」、RFC 8839、DOI 10.17487 / RFC8839、2021年1月、<https://www.rfc-editor.org/info/rfc8839>。"
    },
    {
      "indent": 3,
      "text": "[RFC8840] Ivov, E., Stach, T., Marocco, E., and C. Holmberg, \"A Session Initiation Protocol (SIP) Usage for Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (Trickle ICE)\", RFC 8840, DOI 10.17487/RFC8840, January 2021, <https://www.rfc-editor.org/info/rfc8840>.",
      "ja": "[RFC8840] Ivov、E.、Stach、T.、Marocco、E。、およびC. Holmberg、「Interactive Connectivity Establishment（Trickle ICE）の候補のインクリメンタルプロビジョニングのためのセッション開始プロトコル（SIP）の使用法」、RFC 8840、DOI 10.17487 / RFC8840、2021年1月、<https://www.rfc-editor.org/info/rfc8840>。"
    },
    {
      "indent": 3,
      "text": "[RFC8841] Holmberg, C., Shpount, R., Loreto, S., and G. Camarillo, \"Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport\", RFC 8841, DOI 10.17487/RFC8841, January 2021, <https://www.rfc-editor.org/info/rfc8841>.",
      "ja": "[RFC8841] Holmberg、C.、Shpount、R.、Loreto、S。、およびG. Camarillo、「Datagram Transport Layer Security（DTLS）を介したStream Control Transmission Protocol（SCTP）のセッション記述プロトコル（SDP）オファー/アンサー手順トランスポート」、RFC 8841、DOI 10.17487 / RFC8841、2021年1月、<https://www.rfc-editor.org/info/rfc8841>。"
    },
    {
      "indent": 3,
      "text": "[RFC8842] Holmberg, C. and R. Shpount, \"Session Description Protocol (SDP) Offer/Answer Considerations for Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)\", RFC 8842, DOI 10.17487/RFC8842, January 2021, <https://www.rfc-editor.org/info/rfc8842>.",
      "ja": "[RFC8842] Holmberg、C。およびR. Shpount、「Datagram Transport Layer Security（DTLS）およびTransport Layer Security（TLS）に関するSession Description Protocol（SDP）オファー/アンサーの考慮事項」、RFC 8842、DOI 10.17487 / RFC8842、2021年1月、<https://www.rfc-editor.org/info/rfc8842>。"
    },
    {
      "indent": 3,
      "text": "[RFC8843] Holmberg, C., Alvestrand, H., and C. Jennings, \"Negotiating Media Multiplexing Using the Session Description Protocol (SDP)\", RFC 8843, DOI 10.17487/RFC8843, January 2021, <https://www.rfc-editor.org/info/rfc8843>.",
      "ja": "[RFC8843] Holmberg、C.、Alvestrand、H。、およびC. Jennings、「Session Description Protocol（SDP）を使用したメディア多重化のネゴシエーション」、RFC 8843、DOI 10.17487 / RFC8843、2021年1月<https：// www。rfc-editor.org/info/rfc8843>。"
    },
    {
      "indent": 3,
      "text": "[RFC8851] Roach, A.B., Ed., \"RTP Payload Format Restrictions\", RFC 8851, DOI 10.17487/RFC8851, January 2021, <https://www.rfc-editor.org/info/rfc8851>.",
      "ja": "[RFC8851] Roach、A.B.、Ed。、 \"RTP Payload Format Limitations\"、RFC 8851、DOI 10.17487 / RFC8851、January 2021、<https://www.rfc-editor.org/info/rfc8851>。"
    },
    {
      "indent": 3,
      "text": "[RFC8852] Roach, A.B., Nandakumar, S., and P. Thatcher, \"RTP Stream Identifier Source Description (SDES)\", RFC 8852, DOI 10.17487/RFC8852, January 2021, <https://www.rfc-editor.org/info/rfc8852>.",
      "ja": "[RFC8852] Roach、AB、Nandakumar、S。、およびP. Thatcher、「RTP Stream Identifier Source Description（SDES）」、RFC 8852、DOI 10.17487 / RFC8852、2021年1月、<https：//www.rfc-editor。org / info / rfc8852>。"
    },
    {
      "indent": 3,
      "text": "[RFC8853] Burman, B., Westerlund, M., Nandakumar, S., and M. Zanaty, \"Using Simulcast in Session Description Protocol (SDP) and RTP Sessions\", RFC 8853, DOI 10.17487/RFC8853, January 2021, <https://www.rfc-editor.org/info/rfc8853>.",
      "ja": "[RFC8853] Burman、B.、Westerlund、M.、Nandakumar、S。、およびM. Zanaty、「Session Description Protocol（SDP）およびRTPセッションでのSimulcastの使用」、RFC 8853、DOI 10.17487 / RFC8853、2021年1月<https://www.rfc-editor.org/info/rfc8853>。"
    },
    {
      "indent": 3,
      "text": "[RFC8854] Uberti, J., \"WebRTC Forward Error Correction Requirements\", RFC 8854, DOI 10.17487/RFC8854, January 2021, <https://www.rfc-editor.org/info/rfc8854>.",
      "ja": "[RFC8854] Uberti、J。、「WebRTC前方誤り訂正要件」、RFC 8854、DOI 10.17487 / RFC8854、2021年1月、<https://www.rfc-editor.org/info/rfc8854>。"
    },
    {
      "indent": 3,
      "text": "[RFC8858] Holmberg, C., \"Indicating Exclusive Support of RTP and RTP Control Protocol (RTCP) Multiplexing Using the Session Description Protocol (SDP)\", RFC 8858, DOI 10.17487/RFC8858, January 2021, <https://www.rfc-editor.org/info/rfc8858>.",
      "ja": "[RFC8858] Holmberg、C。、 \"Indicating Exclusive Support of RTP and RTP Control Protocol（RTCP）Multiplexing Using the Session Description Protocol（SDP）\"、RFC 8858、DOI 10.17487 / RFC8858、January 2021、<https：// www。rfc-editor.org/info/rfc8858>。"
    },
    {
      "indent": 3,
      "text": "[RFC8859] Nandakumar, S., \"A Framework for Session Description Protocol (SDP) Attributes When Multiplexing\", RFC 8859, DOI 10.17487/RFC8859, January 2021, <https://www.rfc-editor.org/info/rfc8859>.",
      "ja": "[RFC8859] Nandakumar、S。、「多重化時のセッション記述プロトコル（SDP）属性のフレームワーク」、RFC 8859、DOI 10.17487 / RFC8859、2021年1月、<https://www.rfc-editor.org/info/rfc8859>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3389] Zopf, R., \"Real-time Transport Protocol (RTP) Payload for Comfort Noise (CN)\", RFC 3389, DOI 10.17487/RFC3389, September 2002, <https://www.rfc-editor.org/info/rfc3389>.",
      "ja": "[RFC3389] Zopf、R。、「コンフォートノイズ（CN）のリアルタイムトランスポートプロトコル（RTP）ペイロード」、RFC 3389、DOI 10.17487 / RFC3389、2002年9月、<https://www.rfc-editor.org/info / rfc3389>。"
    },
    {
      "indent": 3,
      "text": "[RFC3556] Casner, S., \"Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth\", RFC 3556, DOI 10.17487/RFC3556, July 2003, <https://www.rfc-editor.org/info/rfc3556>.",
      "ja": "[RFC3556] Casner、S。、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」、RFC 3556、DOI 10.17487 / RFC3556、2003年7月、<https://www.rfc-editor.org/ info / rfc3556>。"
    },
    {
      "indent": 3,
      "text": "[RFC3960] Camarillo, G. and H. Schulzrinne, \"Early Media and Ringing Tone Generation in the Session Initiation Protocol (SIP)\", RFC 3960, DOI 10.17487/RFC3960, December 2004, <https://www.rfc-editor.org/info/rfc3960>.",
      "ja": "[RFC3960] Camarillo、G。and H. Schulzrinne、 \"Early Media and Ringing Tone Generation in the Session Initiation Protocol（SIP）\"、RFC 3960、DOI 10.17487 / RFC3960、December 2004、<https：//www.rfc-editor.org / info / rfc3960>。"
    },
    {
      "indent": 3,
      "text": "[RFC4568] Andreasen, F., Baugher, M., and D. Wing, \"Session Description Protocol (SDP) Security Descriptions for Media Streams\", RFC 4568, DOI 10.17487/RFC4568, July 2006, <https://www.rfc-editor.org/info/rfc4568>.",
      "ja": "[RFC4568] Andreasen、F.、Baugher、M。、およびD. Wing、「Media Streamsのセッション記述プロトコル（SDP）セキュリティ記述」、RFC 4568、DOI 10.17487 / RFC4568、2006年7月、<https：// www。rfc-editor.org/info/rfc4568>。"
    },
    {
      "indent": 3,
      "text": "[RFC4588] Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, \"RTP Retransmission Payload Format\", RFC 4588, DOI 10.17487/RFC4588, July 2006, <https://www.rfc-editor.org/info/rfc4588>.",
      "ja": "[RFC4588] Rey、J.、Leon、D.、Miyazaki、A.、Varsa、V。、およびR. Hakenberg、「RTP Retransmission Payload Format」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<https：//www.rfc-editor.org/info/rfc4588>。"
    },
    {
      "indent": 3,
      "text": "[RFC4733] Schulzrinne, H. and T. Taylor, \"RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals\", RFC 4733, DOI 10.17487/RFC4733, December 2006, <https://www.rfc-editor.org/info/rfc4733>.",
      "ja": "[RFC4733] Schulzrinne、H。and T. Taylor、 \"RTP Payload for DTMF Digits、Telephony Tones、and Telephony Signals\"、RFC 4733、DOI 10.17487 / RFC4733、December 2006、<https://www.rfc-editor.org/ info / rfc4733>。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, DOI 10.17487/RFC5245, April 2010, <https://www.rfc-editor.org/info/rfc5245>.",
      "ja": "[RFC5245] Rosenberg、J。、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<https：// www.rfc-editor.org / info / rfc5245>。"
    },
    {
      "indent": 3,
      "text": "[RFC5506] Johansson, I. and M. Westerlund, \"Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences\", RFC 5506, DOI 10.17487/RFC5506, April 2009, <https://www.rfc-editor.org/info/rfc5506>.",
      "ja": "[RFC5506] Johansson、I。およびM. Westerlund、「Reduced-Size Real-Time Transport Control Protocol（RTCP）：Opportunities and Consequences」、RFC 5506、DOI 10.17487 / RFC5506、2009年4月、<https：// www.rfc-editor.org / info / rfc5506>。"
    },
    {
      "indent": 3,
      "text": "[RFC5576] Lennox, J., Ott, J., and T. Schierl, \"Source-Specific Media Attributes in the Session Description Protocol (SDP)\", RFC 5576, DOI 10.17487/RFC5576, June 2009, <https://www.rfc-editor.org/info/rfc5576>.",
      "ja": "[RFC5576] Lennox、J.、Ott、J。、およびT. Schierl、「Session Description Protocol（SDP）のソース固有のメディア属性」、RFC 5576、DOI 10.17487 / RFC5576、2009年6月、<https：//www.rfc-editor.org/info/rfc5576>。"
    },
    {
      "indent": 3,
      "text": "[RFC5763] Fischl, J., Tschofenig, H., and E. Rescorla, \"Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)\", RFC 5763, DOI 10.17487/RFC5763, May 2010, <https://www.rfc-editor.org/info/rfc5763>.",
      "ja": "[RFC5763] Fischl、J.、Tschofenig、H。、およびE. Rescorla、「Datagram Transport Layer Security（DTLS）を使用してセキュアなReal-time Transport Protocol（SRTP）セキュリティコンテキストを確立するためのフレームワーク」、RFC 5763、DOI 10.17487 /RFC5763、2010年5月、<https://www.rfc-editor.org/info/rfc5763>。"
    },
    {
      "indent": 3,
      "text": "[RFC5764] McGrew, D. and E. Rescorla, \"Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)\", RFC 5764, DOI 10.17487/RFC5764, May 2010, <https://www.rfc-editor.org/info/rfc5764>.",
      "ja": "[RFC5764] McGrew、D。およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのDatagram Transport Layer Security（DTLS）Extension」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<https：//www.rfc-editor.org/info/rfc5764>。"
    },
    {
      "indent": 3,
      "text": "[RFC6120] Saint-Andre, P., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 6120, DOI 10.17487/RFC6120, March 2011, <https://www.rfc-editor.org/info/rfc6120>.",
      "ja": "[RFC6120] Saint-Andre、P。、「Extensible Messaging and Presence Protocol（XMPP）：Core」、RFC 6120、DOI 10.17487 / RFC6120、2011年3月、<https://www.rfc-editor.org/info/rfc6120>。"
    },
    {
      "indent": 3,
      "text": "[RFC6464] Lennox, J., Ed., Ivov, E., and E. Marocco, \"A Real-time Transport Protocol (RTP) Header Extension for Client-to-Mixer Audio Level Indication\", RFC 6464, DOI 10.17487/RFC6464, December 2011, <https://www.rfc-editor.org/info/rfc6464>.",
      "ja": "[RFC6464] Lennox、J.、Ed。、Ivov、E.、and E. Marocco、 \"A Real-time Transport Protocol（RTP）Header Extension for Client-to-Mixer Audio Level Indication\"、RFC 6464、DOI 10.17487 /RFC6464、2011年12月、<https://www.rfc-editor.org/info/rfc6464>。"
    },
    {
      "indent": 3,
      "text": "[RFC8828] Uberti, J. and G. Shieh, \"WebRTC IP Address Handling Requirements\", RFC 8828, DOI 10.17487/RFC8828, January 2021, <https://www.rfc-editor.org/info/rfc8828>.",
      "ja": "[RFC8828] Uberti、J。およびG. Shieh、「WebRTC IPアドレス処理要件」、RFC 8828、DOI 10.17487 / RFC8828、2021年1月、<https://www.rfc-editor.org/info/rfc8828>。"
    },
    {
      "indent": 3,
      "text": "[SDP4WebRTC] Nandakumar, S. and C. Jennings, \"Annotated Example SDP for WebRTC\", Work in Progress, Internet-Draft, draft-ietf-rtcweb-sdp-14, 17 December 2020, <https://tools.ietf.org/html/draft-ietf-rtcweb-sdp-14>.",
      "ja": "[SDP4WebRTC] Nandakumar、S。and C. Jennings、 \"Annotated Example SDP for WebRTC\"、Work in Progress、Internet-Draft、draft-ietf-rtcweb-sdp-14、17 December 2020、<https：//tools.ietf.org / html / draft-ietf-rtcweb-sdp-14>。"
    },
    {
      "indent": 3,
      "text": "[TS26.114] 3GPP, \"3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; IP Multimedia Subsystem (IMS); Multimedia Telephony; Media handling and interaction (Release 16)\", 3GPP TS 26.114 V16.3.0, September 2019, <https://www.3gpp.org/DynaReport/26114.htm>.",
      "ja": "[TS26.114] 3GPP、「第3世代パートナーシッププロジェクト、技術仕様グループのサービスとシステムの側面、IPマルチメディアサブシステム（IMS）、マルチメディアテレフォニー、メディアの処理と相互作用（リリース16）」、3GPP TS 26.114 V16.3.0、2019年9月、<https://www.3gpp.org/DynaReport/26114.htm>。"
    },
    {
      "indent": 3,
      "text": "[W3C.webrtc] Jennings, C., Ed., Boström, H., Ed., and J. Bruaroey, Ed., \"WebRTC 1.0: Real-time Communication Between Browsers\", World Wide Web Consortium PR PR-webrtc-20201215, December 2020, <https://www.w3.org/TR/2020/PR-webrtc-20201215/>.",
      "ja": "[W3C.webrtc] Jennings、C.、Ed。、Boström、H。、Ed。、and J. Bruaroey、Ed。、 \"WebRTC 1.0：Real-time Communication Between Browsers\"、World Wide Web Consortium PR PR-webrtc-20201215、2020年12月、<https://www.w3.org/TR/2020/PR-webrtc-20201215/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. SDP ABNF Syntax",
      "section_title": true,
      "ja": "付録A.SDPABNF構文"
    },
    {
      "indent": 3,
      "text": "For the syntax validation performed in Section 5.8, the following list of ABNF definitions is used:",
      "ja": "セクション5.8で実行される構文検証では、次のABNF定義のリストが使用されます。"
    },
    {
      "indent": 10,
      "text": "+=========================+==========================+\n| Attribute               | Reference                |\n+=========================+==========================+\n| ptime                   | Section 6 of [RFC4566]   |\n+-------------------------+--------------------------+\n| maxptime                | Section 6 of [RFC4566]   |\n+-------------------------+--------------------------+\n| rtpmap                  | Section 6 of [RFC4566]   |\n+-------------------------+--------------------------+\n| recvonly                | Section 9 of [RFC4566]   |\n+-------------------------+--------------------------+\n| sendrecv                | Section 9 of [RFC4566]   |\n+-------------------------+--------------------------+\n| sendonly                | Section 9 of [RFC4566]   |\n+-------------------------+--------------------------+\n| inactive                | Section 9 of [RFC4566]   |\n+-------------------------+--------------------------+\n| fmtp                    | Section 9 of [RFC4566]   |\n+-------------------------+--------------------------+\n| rtcp                    | Section 2.1 of [RFC3605] |\n+-------------------------+--------------------------+\n| setup                   | Section 4 of [RFC4145]   |\n+-------------------------+--------------------------+\n| fingerprint             | Section 5 of [RFC8122]   |\n+-------------------------+--------------------------+\n| rtcp-fb                 | Section 4.2 of [RFC4585] |\n+-------------------------+--------------------------+\n| extmap                  | Section 7 of [RFC5285]   |\n+-------------------------+--------------------------+\n| mid                     | Section 4 of [RFC5888]   |\n+-------------------------+--------------------------+\n| group                   | Section 5 of [RFC5888]   |\n+-------------------------+--------------------------+\n| imageattr               | Section 3.1 of [RFC6236] |\n+-------------------------+--------------------------+\n| extmap (encrypt option) | Section 4 of [RFC6904]   |\n+-------------------------+--------------------------+\n| candidate               | Section 5.1 of [RFC8839] |\n+-------------------------+--------------------------+\n| remote-candidates       | Section 5.2 of [RFC8839] |\n+-------------------------+--------------------------+\n| ice-lite                | Section 5.3 of [RFC8839] |\n+-------------------------+--------------------------+\n| ice-ufrag               | Section 5.4 of [RFC8839] |\n+-------------------------+--------------------------+\n| ice-pwd                 | Section 5.4 of [RFC8839] |\n+-------------------------+--------------------------+\n| ice-options             | Section 5.6 of [RFC8839] |\n+-------------------------+--------------------------+\n| msid                    | Section 3 of [RFC8830]   |\n+-------------------------+--------------------------+\n| rid                     | Section 10 of [RFC8851]  |\n+-------------------------+--------------------------+\n| simulcast               | Section 5.1 of [RFC8853] |\n+-------------------------+--------------------------+\n| tls-id                  | Section 4 of [RFC8842]   |\n+-------------------------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 1: SDP ABNF References",
      "ja": "表1：SDPABNFリファレンス"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Harald Alvestrand, Taylor Brandstetter, Suhas Nandakumar, and Peter Thatcher provided significant text for this document. Bernard Aboba, Adam Bergkvist, Jan-Ivar Bruaroey, Dan Burnett, Ben Campbell, Alissa Cooper, Richard Ejzak, Stefan Håkansson, Ted Hardie, Christer Holmberg, Andrew Hutton, Randell Jesup, Matthew Kaufman, Anant Narayanan, Adam Roach, Robert Sparks, Neil Stratford, Martin Thomson, Sean Turner, and Magnus Westerlund all provided valuable feedback on this document.",
      "ja": "Harald Alvestrand、Taylor Brandstetter、Suhas Nandakumar、およびPeter Thatcherが、このドキュメントに重要なテキストを提供しました。Bernard Aboba、Adam Bergkvist、Jan-Ivar Bruaroey、Dan Burnett、Ben Campbell、Alissa Cooper、Richard Ejzak、StefanHåkansson、Ted Hardie、Christer Holmberg、Andrew Hutton、Randell Jesup、Matthew Kaufman、Anant Narayanan、Adam Roach、Robert Sparks、Neil Stratford、Martin Thomson、Sean Turner、およびMagnus Westerlundはすべて、このドキュメントに関する貴重なフィードバックを提供しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Justin Uberti Google 747 6th Street South Kirkland, WA 98033 United States of America",
      "ja": "Justin Uberti Google 747 6th Street South Kirkland、WA98033アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: justin@uberti.name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cullen Jennings Cisco 400 3rd Avenue SW Calgary AB T2P 4H2 Canada",
      "ja": "カレンジェニングスCisco400 3rd AvenueSWカルガリーABT2P4H2カナダ"
    },
    {
      "indent": 3,
      "text": "Email: fluffy@iii.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eric Rescorla (editor) Mozilla",
      "ja": "Eric Rescorla（編集者）Mozilla"
    },
    {
      "indent": 3,
      "text": "Email: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    }
  ]
}