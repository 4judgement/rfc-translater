{
  "title": {
    "text": "RFC 8705 - OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens",
    "ja": "RFC 8705 - OAuth 2.0相互TLSクライアント認証および証明書バインドアクセストークン"
  },
  "number": 8705,
  "created_at": "2020-08-15 21:23:46.255477+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       B. Campbell\nRequest for Comments: 8705                                 Ping Identity\nCategory: Standards Track                                     J. Bradley\nISSN: 2070-1721                                                   Yubico\n                                                             N. Sakimura\n                                               Nomura Research Institute\n                                                          T. Lodderstedt\n                                                              YES.com AG\n                                                           February 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens",
      "ja": "OAuth 2.0相互TLSクライアント認証および証明書バインドアクセストークン"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes OAuth client authentication and certificate-bound access and refresh tokens using mutual Transport Layer Security (TLS) authentication with X.509 certificates. OAuth clients are provided a mechanism for authentication to the authorization server using mutual TLS, based on either self-signed certificates or public key infrastructure (PKI). OAuth authorization servers are provided a mechanism for binding access tokens to a client's mutual-TLS certificate, and OAuth protected resources are provided a method for ensuring that such an access token presented to it was issued to the client presenting the token.",
      "ja": "このドキュメントでは、X.509証明書を使用した相互トランスポート層セキュリティ（TLS）認証を使用したOAuthクライアント認証と証明書バインドアクセスおよび更新トークンについて説明します。 OAuthクライアントには、自己署名証明書または公開鍵基盤（PKI）に基づいて、相互TLSを使用して承認サーバーへの認証メカニズムが提供されます。 OAuth承認サーバーは、アクセストークンをクライアントの相互TLS証明書にバインドするメカニズムを提供し、OAuthで保護されたリソースは、提示されたそのようなアクセストークンがトークンを提示するクライアントに発行されたことを確認する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8705.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8705で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETFトラストおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Notation and Conventions\n  1.2.  Terminology\n2.  Mutual TLS for OAuth Client Authentication\n  2.1.  PKI Mutual-TLS Method\n    2.1.1.  PKI Method Metadata Value\n    2.1.2.  Client Registration Metadata\n  2.2.  Self-Signed Certificate Mutual-TLS Method\n    2.2.1.  Self-Signed Method Metadata Value\n    2.2.2.  Client Registration Metadata\n3.  Mutual-TLS Client Certificate-Bound Access Tokens\n  3.1.  JWT Certificate Thumbprint Confirmation Method\n  3.2.  Confirmation Method for Token Introspection\n  3.3.  Authorization Server Metadata\n  3.4.  Client Registration Metadata\n4.  Public Clients and Certificate-Bound Tokens\n5.  Metadata for Mutual-TLS Endpoint Aliases\n6.  Implementation Considerations\n  6.1.  Authorization Server\n  6.2.  Resource Server\n  6.3.  Certificate Expiration and Bound Access Tokens\n  6.4.  Implicit Grant Unsupported\n  6.5.  TLS Termination\n7.  Security Considerations\n  7.1.  Certificate-Bound Refresh Tokens\n  7.2.  Certificate Thumbprint Binding\n  7.3.  TLS Versions and Best Practices\n  7.4.  X.509 Certificate Spoofing\n  7.5.  X.509 Certificate Parsing and Validation Complexity\n8.  Privacy Considerations\n9.  IANA Considerations\n  9.1.  JWT Confirmation Methods Registration\n  9.2.  Authorization Server Metadata Registration\n  9.3.  Token Endpoint Authentication Method Registration\n  9.4.  Token Introspection Response Registration\n  9.5.  Dynamic Client Registration Metadata Registration\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  Example \"cnf\" Claim, Certificate, and JWK\nAppendix B.  Relationship to Token Binding\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 Authorization Framework [RFC6749] enables third-party client applications to obtain delegated access to protected resources. In the prototypical abstract OAuth flow, illustrated in Figure 1, the client obtains an access token from an entity known as an authorization server and then uses that token when accessing protected resources, such as HTTPS APIs.",
      "ja": "OAuth 2.0 Authorization Framework [RFC6749]により、サードパーティのクライアントアプリケーションは保護されたリソースへの委任アクセスを取得できます。図1に示すプロトタイプの抽象OAuthフローでは、クライアントは認証サーバーと呼ばれるエンティティからアクセストークンを取得し、HTTPS APIなどの保護されたリソースにアクセスするときにそのトークンを使用します。"
    },
    {
      "indent": 5,
      "text": "+--------+                                 +---------------+\n|        |                                 |               |\n|        |<--(A)-- Get an access token --->| Authorization |\n|        |                                 |     Server    |\n|        |                                 |               |\n|        |                                 +---------------+\n|        |                                         ^\n|        |                                         |\n|        |\n|        |                               (C)       |\n| Client |                           Validate the\n|        |                           access token  |\n|        |\n|        |                                         |\n|        |                                         v\n|        |                                 +---------------+\n|        |                                 |      (C)      |\n|        |                                 |               |\n|        |<--(B)-- Use the access token -->|   Protected   |\n|        |                                 |    Resource   |\n|        |                                 |               |\n+--------+                                 +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 1: Abstract OAuth 2.0 Protocol Flow",
      "ja": "図1：抽象OAuth 2.0プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "The flow illustrated in Figure 1 includes the following steps:",
      "ja": "図1に示されているフローには、以下のステップが含まれています。"
    },
    {
      "indent": 3,
      "text": "(A) The client makes an HTTPS \"POST\" request to the authorization server and presents a credential representing the authorization grant. For certain types of clients (those that have been issued or otherwise established a set of client credentials) the request must be authenticated. In the response, the authorization server issues an access token to the client.",
      "ja": "（A）クライアントはHTTPSの「POST」要求を許可サーバーに送信し、許可付与を表す資格情報を提示します。特定のタイプのクライアント（発行されたか、クライアントの資格情報のセットを確立したクライアント）の場合、要求は認証される必要があります。応答では、承認サーバーがクライアントにアクセストークンを発行します。"
    },
    {
      "indent": 3,
      "text": "(B) The client includes the access token when making a request to access a protected resource.",
      "ja": "（B）クライアントは、保護されたリソースへのアクセスを要求するときに、アクセストークンを含めます。"
    },
    {
      "indent": 3,
      "text": "(C) The protected resource validates the access token in order to authorize the request. In some cases, such as when the token is self-contained and cryptographically secured, the validation can be done locally by the protected resource. Other cases require that the protected resource call out to the authorization server to determine the state of the token and obtain metainformation about it.",
      "ja": "（C）保護されたリソースは、リクエストを承認するためにアクセストークンを検証します。トークンが自己完結型で暗号で保護されている場合など、場合によっては、保護されたリソースによってローカルで検証を実行できます。他のケースでは、保護されたリソースが許可サーバーを呼び出してトークンの状態を判別し、トークンに関するメタ情報を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Layering on the abstract flow above, this document standardizes enhanced security options for OAuth 2.0 utilizing client-certificate-based mutual TLS. Section 2 provides options for authenticating the request in Step (A). Step (C) is supported with semantics to express the binding of the token to the client certificate for both local and remote processing in Sections 3.1 and 3.2, respectively. This ensures that, as described in Section 3, protected resource access in Step (B) is only possible by the legitimate client using a certificate-bound token and holding the private key corresponding to the certificate.",
      "ja": "上記の抽象フローを階層化して、このドキュメントは、クライアント証明書ベースの相互TLSを利用するOAuth 2.0の拡張セキュリティオプションを標準化します。セクション2では、ステップ（A）でリクエストを認証するためのオプションを示します。ステップ（C）は、それぞれセクション3.1および3.2のローカル処理とリモート処理の両方で、クライアント証明書へのトークンのバインディングを表すセマンティクスでサポートされています。これにより、セクション3で説明したように、手順（B）での保護されたリソースアクセスは、正当なクライアントが証明書にバインドされたトークンを使用し、証明書に対応する秘密キーを保持することによってのみ可能になります。"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 defines a shared-secret method of client authentication but also allows for defining and using additional client authentication mechanisms when interacting directly with the authorization server. This document describes an additional mechanism of client authentication utilizing mutual-TLS certificate-based authentication that provides better security characteristics than shared secrets. While [RFC6749] documents client authentication for requests to the token endpoint, extensions to OAuth 2.0 (such as Introspection [RFC7662], Revocation [RFC7009], and the Backchannel Authentication Endpoint in [OpenID.CIBA]) define endpoints that also utilize client authentication, and the mutual-TLS methods defined herein are applicable to those endpoints as well.",
      "ja": "OAuth 2.0は、クライアント認証の共有秘密方式を定義しますが、許可サーバーと直接対話するときに、追加のクライアント認証メカニズムを定義して使用することもできます。このドキュメントでは、共有シークレットよりも優れたセキュリティ特性を提供する相互TLS証明書ベースの認証を利用したクライアント認証の追加メカニズムについて説明します。 [RFC6749]はトークンエンドポイントへのリクエストのクライアント認証を文書化していますが、OAuth 2.0の拡張機能（イントロスペクション[RFC7662]、失効[RFC7009]、[OpenID.CIBA]のバックチャネル認証エンドポイントなど）は、クライアント認証も利用するエンドポイントを定義しています、およびここで定義されている相互TLSメソッドは、これらのエンドポイントにも適用できます。"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS certificate-bound access tokens ensure that only the party in possession of the private key corresponding to the certificate can utilize the token to access the associated resources. Such a constraint is sometimes referred to as key confirmation, proof-of-possession, or holder-of-key and is unlike the case of the bearer token described in [RFC6750], where any party in possession of the access token can use it to access the associated resources. Binding an access token to the client's certificate prevents the use of stolen access tokens or replay of access tokens by unauthorized parties.",
      "ja": "相互TLS証明書にバインドされたアクセストークンにより、証明書に対応する秘密鍵を所持する当事者のみが、トークンを使用して関連するリソースにアクセスできるようになります。このような制約は、鍵の確認、所有の証明、または鍵の所有者と呼ばれることもあり、[RFC6750]で説明されているベアラートークンの場合とは異なります。関連するリソースにアクセスします。アクセストークンをクライアントの証明書にバインドすることで、盗まれたアクセストークンの使用や、権限のない当事者によるアクセストークンの再生を防止できます。"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS certificate-bound access tokens and mutual-TLS client authentication are distinct mechanisms that are complementary but don't necessarily need to be deployed or used together.",
      "ja": "相互TLS証明書にバインドされたアクセストークンと相互TLSクライアント認証は別個のメカニズムであり、補完的ですが、必ずしも一緒に展開または使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Additional client metadata parameters are introduced by this document in support of certificate-bound access tokens and mutual-TLS client authentication. The authorization server can obtain client metadata via the Dynamic Client Registration Protocol [RFC7591], which defines mechanisms for dynamically registering OAuth 2.0 client metadata with authorization servers. Also the metadata defined by [RFC7591], and registered extensions to it, imply a general data model for clients that is useful for authorization server implementations, even when the Dynamic Client Registration Protocol isn't in play. Such implementations will typically have some sort of user interface available for managing client configuration.",
      "ja": "このドキュメントでは、証明書にバインドされたアクセストークンと相互TLSクライアント認証をサポートするために、追加のクライアントメタデータパラメーターが導入されています。承認サーバーは、動的クライアント登録プロトコル[RFC7591]を介してクライアントメタデータを取得できます。これは、OAuth 2.0クライアントメタデータを承認サーバーに動的に登録するためのメカニズムを定義します。また、[RFC7591]によって定義されたメタデータとそれに登録されている拡張機能は、動的クライアント登録プロトコルが機能していない場合でも、承認サーバーの実装に役立つクライアントの一般的なデータモデルを意味します。このような実装では、通常、クライアント構成を管理するために使用できるある種のユーザーインターフェイスがあります。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation and Conventions",
      "section_title": true,
      "ja": "1.1. 要件の表記と規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "Throughout this document the term \"mutual TLS\" refers to the process whereby, in addition to the normal TLS server authentication with a certificate, a client presents its X.509 certificate and proves possession of the corresponding private key to a server when negotiating a TLS session. In contemporary versions of TLS [RFC5246] [RFC8446], this requires that the client send the Certificate and CertificateVerify messages during the handshake and for the server to verify the CertificateVerify and Finished messages.",
      "ja": "このドキュメント全体で、「相互TLS」という用語は、証明書による通常のTLSサーバー認証に加えて、クライアントがX.509証明書を提示し、TLSのネゴシエーション時に対応する秘密鍵の所有をサーバーに証明するプロセスを指しますセッション。 TLS [RFC5246] [RFC8446]の最新バージョンでは、ハンドシェイク中にクライアントがCertificateおよびCertificateVerifyメッセージを送信し、サーバーがCertificateVerifyおよびFinishedメッセージを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Mutual TLS for OAuth Client Authentication",
      "section_title": true,
      "ja": "2. OAuthクライアント認証用の相互TLS"
    },
    {
      "indent": 3,
      "text": "This section defines, as an extension of Section 2.3 of OAuth 2.0 [RFC6749], two distinct methods of using mutual-TLS X.509 client certificates as client credentials. The requirement of mutual TLS for client authentication is determined by the authorization server, based on policy or configuration for the given client (regardless of whether the client was dynamically registered, statically configured, or otherwise established).",
      "ja": "このセクションでは、OAuth 2.0 [RFC6749]のセクション2.3の拡張として、相互TLS X.509クライアント証明書をクライアント資格情報として使用する2つの異なる方法を定義します。クライアント認証のための相互TLSの要件は、（クライアントが動的に登録されたか、静的に構成されたか、その他の方法で確立されたかに関係なく）特定のクライアントのポリシーまたは構成に基づいて、承認サーバーによって決定されます。"
    },
    {
      "indent": 3,
      "text": "In order to utilize TLS for OAuth client authentication, the TLS connection between the client and the authorization server MUST have been established or re-established with mutual-TLS X.509 certificate authentication (i.e., the client Certificate and CertificateVerify messages are sent during the TLS handshake).",
      "ja": "OAuthクライアント認証にTLSを利用するには、クライアントと承認サーバー間のTLS接続が相互TLS X.509証明書認証で確立または再確立されている必要があります（つまり、クライアントの証明書とCertificateVerifyメッセージは、 TLSハンドシェイク）。"
    },
    {
      "indent": 3,
      "text": "For all requests to the authorization server utilizing mutual-TLS client authentication, the client MUST include the \"client_id\" parameter described in Section 2.2 of OAuth 2.0 [RFC6749]. The presence of the \"client_id\" parameter enables the authorization server to easily identify the client independently from the content of the certificate. The authorization server can locate the client configuration using the client identifier and check the certificate presented in the TLS handshake against the expected credentials for that client. The authorization server MUST enforce the binding between client and certificate, as described in either Section 2.1 or 2.2 below. If no certificate is presented, or that which is presented doesn't match that which is expected for the given \"client_id\", the authorization server returns a normal OAuth 2.0 error response per Section 5.2 of [RFC6749] with the \"invalid_client\" error code to indicate failed client authentication.",
      "ja": "相互TLSクライアント認証を利用する許可サーバーへのすべての要求について、クライアントはOAuth 2.0 [RFC6749]のセクション2.2で説明されている「client_id」パラメーターを含める必要があります。 「client_id」パラメーターの存在により、許可サーバーは、証明書の内容とは無関係にクライアントを簡単に識別できます。許可サーバーは、クライアントIDを使用してクライアント構成を見つけ、TLSハンドシェイクで提示された証明書を、そのクライアントの予想される資格情報と照合します。承認サーバーは、以下のセクション2.1または2.2で説明されているように、クライアントと証明書間のバインディングを実施する必要があります。証明書が提示されない場合、または提示された証明書が「client_id」に期待されるものと一致しない場合、認証サーバーは[RFC6749]のセクション5.2に従って通常のOAuth 2.0エラー応答を返し、「invalid_client」エラーコードを返します。失敗したクライアント認証を示します。"
    },
    {
      "indent": 0,
      "text": "2.1. PKI Mutual-TLS Method",
      "section_title": true,
      "ja": "2.1. PKI相互TLS方式"
    },
    {
      "indent": 3,
      "text": "The PKI (public key infrastructure) method of mutual-TLS OAuth client authentication adheres to the way in which X.509 certificates are traditionally used for authentication. It relies on a validated certificate chain [RFC5280] and a single subject distinguished name (DN) or a single subject alternative name (SAN) to authenticate the client. Only one subject name value of any type is used for each client. The TLS handshake is utilized to validate the client's possession of the private key corresponding to the public key in the certificate and to validate the corresponding certificate chain. The client is successfully authenticated if the subject information in the certificate matches the single expected subject configured or registered for that particular client (note that a predictable treatment of DN values, such as the distinguishedNameMatch rule from [RFC4517], is needed in comparing the certificate's subject DN to the client's registered DN). Revocation checking is possible with the PKI method but if and how to check a certificate's revocation status is a deployment decision at the discretion of the authorization server. Clients can rotate their X.509 certificates without the need to modify the respective authentication data at the authorization server by obtaining a new certificate with the same subject from a trusted certificate authority (CA).",
      "ja": "相互TLS OAuthクライアント認証のPKI（公開鍵インフラストラクチャ）方式は、X.509証明書が認証に従来使用されている方法に準拠しています。検証済みの証明書チェーン[RFC5280]と単一のサブジェクト識別名（DN）または単一のサブジェクト代替名（SAN）に依存して、クライアントを認証します。クライアントごとに、任意のタイプのサブジェクト名の値が1つだけ使用されます。 TLSハンドシェイクは、証明書内の公開鍵に対応する秘密鍵のクライアントの所有を検証し、対応する証明書チェーンを検証するために利用されます。証明書のサブジェクト情報がその特定のクライアントに対して構成または登録された単一の予期されるサブジェクトと一致する場合、クライアントは正常に認証されます（証明書の比較には、[RFC4517]のdistinguishedNameMatchルールなどのDN値の予測可能な処理が必要です。サブジェクトDNをクライアントの登録済みDNに）。失効確認はPKI方式で可能ですが、証明書の失効ステータスを確認するかどうか、および確認方法は、承認サーバーの裁量による展開の決定です。クライアントは、信頼できる認証局（CA）から同じサブジェクトを持つ新しい証明書を取得することにより、承認サーバーでそれぞれの認証データを変更する必要なく、X.509証明書をローテーションできます。"
    },
    {
      "indent": 0,
      "text": "2.1.1. PKI Method Metadata Value",
      "section_title": true,
      "ja": "2.1.1. PKIメソッドのメタデータ値"
    },
    {
      "indent": 3,
      "text": "For the PKI method of mutual-TLS client authentication, this specification defines and registers the following authentication method metadata value into the \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters].",
      "ja": "相互TLSクライアント認証のPKI方式の場合、この仕様では、次の認証方式メタデータ値を定義し、「OAuthトークンエンドポイント認証方式」レジストリ[IANA.OAuth.Parameters]に登録します。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth Indicates that client authentication to the authorization server will occur with mutual TLS utilizing the PKI method of associating a certificate to a client.",
      "ja": "tls_client_auth承認サーバーへのクライアント認証が、証明書をクライアントに関連付けるPKI方式を利用する相互TLSで発生することを示します。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Client Registration Metadata",
      "section_title": true,
      "ja": "2.1.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "In order to convey the expected subject of the certificate, the following metadata parameters are introduced for the OAuth 2.0 Dynamic Client Registration Protocol [RFC7591] in support of the PKI method of mutual-TLS client authentication. A client using the \"tls_client_auth\" authentication method MUST use exactly one of the below metadata parameters to indicate the certificate subject value that the authorization server is to expect when authenticating the respective client.",
      "ja": "証明書の予想されるサブジェクトを伝えるために、相互TLSクライアント認証のPKIメソッドをサポートするOAuth 2.0動的クライアント登録プロトコル[RFC7591]に次のメタデータパラメーターが導入されています。 「tls_client_auth」認証方式を使用するクライアントは、以下のメタデータパラメータの1つを使用して、認証サーバーがそれぞれのクライアントを認証するときに予期する証明書のサブジェクト値を示す必要があります。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_subject_dn A string representation -- as defined in [RFC4514] -- of the expected subject distinguished name of the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_subject_dn [RFC4514]で定義されている、OAuthクライアントが相互TLS認証で使用する証明書のサブジェクト識別名の文字列表現。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_dns A string containing the value of an expected dNSName SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_dns OAuthクライアントが相互TLS認証で使用する証明書で予期されるdNSName SANエントリの値を含む文字列。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_uri A string containing the value of an expected uniformResourceIdentifier SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_uri OAuthクライアントが相互TLS認証で使用する証明書で予期されるUniformResourceIdentifier SANエントリの値を含む文字列。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_ip A string representation of an IP address in either dotted decimal notation (for IPv4) or colon-delimited hexadecimal (for IPv6, as defined in [RFC5952]) that is expected to be present as an iPAddress SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication. Per Section 8 of [RFC5952], the IP address comparison of the value in this parameter and the SAN entry in the certificate is to be done in binary format.",
      "ja": "tls_client_auth_san_ip OAuthが発行する証明書のiPAddress SANエントリとして存在すると予想される、ドット付き10進表記（IPv4の場合）またはコロン区切りの16進数（[RFC5952]で定義されているIPv6の場合）のIPアドレスの文字列表現クライアントは相互TLS認証で使用します。 [RFC5952]のセクション8に従って、このパラメータの値と証明書のSANエントリのIPアドレス比較はバイナリ形式で行われます。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_email A string containing the value of an expected rfc822Name SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_email OAuthクライアントが相互TLS認証で使用する証明書で予期されるrfc822Name SANエントリの値を含む文字列。"
    },
    {
      "indent": 0,
      "text": "2.2. Self-Signed Certificate Mutual-TLS Method",
      "section_title": true,
      "ja": "2.2. 自己署名証明書の相互TLS方式"
    },
    {
      "indent": 3,
      "text": "This method of mutual-TLS OAuth client authentication is intended to support client authentication using self-signed certificates. As a prerequisite, the client registers its X.509 certificates (using \"jwks\" defined in [RFC7591]) or a reference to a trusted source for its X.509 certificates (using \"jwks_uri\" from [RFC7591]) with the authorization server. During authentication, TLS is utilized to validate the client's possession of the private key corresponding to the public key presented within the certificate in the respective TLS handshake. In contrast to the PKI method, the client's certificate chain is not validated by the server in this case. The client is successfully authenticated if the certificate that it presented during the handshake matches one of the certificates configured or registered for that particular client. The Self-Signed Certificate method allows the use of mutual TLS to authenticate clients without the need to maintain a PKI. When used in conjunction with a \"jwks_uri\" for the client, it also allows the client to rotate its X.509 certificates without the need to change its respective authentication data directly with the authorization server.",
      "ja": "この相互TLS OAuthクライアント認証方式は、自己署名証明書を使用したクライアント認証をサポートすることを目的としています。前提条件として、クライアントはX.509証明書（[RFC7591]で定義されている \"jwks\"を使用）またはX.509証明書の信頼できるソースへの参照（[RFC7591]の \"jwks_uri\"を使用）を承認サーバーに登録します。 。認証中にTLSを使用して、それぞれのTLSハンドシェイクの証明書内に提示された公開鍵に対応する秘密鍵のクライアントの所有を検証します。この場合、PKI方式とは対照的に、クライアントの証明書チェーンはサーバーによって検証されません。ハンドシェイク中に提示された証明書が、特定のクライアント用に構成または登録された証明書の1つと一致する場合、クライアントは正常に認証されます。自己署名証明書方式では、相互TLSを使用して、PKIを維持する必要なくクライアントを認証できます。クライアントの「jwks_uri」と組み合わせて使用​​すると、クライアントは、認証サーバーで直接それぞれの認証データを変更する必要なく、X.509証明書をローテーションできます。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Self-Signed Method Metadata Value",
      "section_title": true,
      "ja": "2.2.1. 自己署名メソッドのメタデータ値"
    },
    {
      "indent": 3,
      "text": "For the Self-Signed Certificate method of mutual-TLS client authentication, this specification defines and registers the following authentication method metadata value into the \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters].",
      "ja": "相互TLSクライアント認証の自己署名証明書方式の場合、この仕様では、次の認証方式メタデータ値を定義し、「OAuthトークンエンドポイント認証方式」レジストリ[IANA.OAuth.Parameters]に登録します。"
    },
    {
      "indent": 3,
      "text": "self_signed_tls_client_auth Indicates that client authentication to the authorization server will occur using mutual TLS with the client utilizing a self-signed certificate.",
      "ja": "self_signed_tls_client_auth自己署名証明書を利用するクライアントとの相互TLSを使用して、許可サーバーへのクライアント認証が行われることを示します。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Client Registration Metadata",
      "section_title": true,
      "ja": "2.2.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "For the Self-Signed Certificate method of binding a certificate with a client using mutual-TLS client authentication, the existing \"jwks_uri\" or \"jwks\" metadata parameters from [RFC7591] are used to convey the client's certificates via JSON Web Key (JWK) in a JWK Set [RFC7517]. The \"jwks\" metadata parameter is a JWK Set containing the client's public keys as an array of JWKs, while the \"jwks_uri\" parameter is a URL that references a client's JWK Set. A certificate is represented with the \"x5c\" parameter of an individual JWK within the set. Note that the members of the JWK representing the public key (e.g., \"n\" and \"e\" for RSA, \"x\" and \"y\" for Elliptic Curve (EC)) are required parameters per [RFC7518] so will be present even though they are not utilized in this context. Also note that Section 4.7 of [RFC7517] requires that the key in the first certificate of the \"x5c\" parameter match the public key represented by those other members of the JWK.",
      "ja": "相互TLSクライアント認証を使用して証明書をクライアントにバインドする自己署名証明書方式の場合、[RFC7591]の既存の「jwks_uri」または「jwks」メタデータパラメータを使用して、JSON Webキー（JWK）経由でクライアントの証明書を伝達しますJWKセット[RFC7517]。 「jwks」メタデータパラメータは、JWKの配列としてクライアントの公開鍵を含むJWKセットであり、「jwks_uri」パラメータは、クライアントのJWKセットを参照するURLです。証明書は、セット内の個々のJWKの「x5c」パラメーターで表されます。公開鍵を表すJWKのメンバー（RSAの場合は「n」と「e」、楕円曲線（EC）の場合は「x」と「y」）は[RFC7518]の必須パラメーターであるため、ただし、このコンテキストでは使用されません。 [RFC7517]のセクション4.7では、「x5c」パラメータの最初の証明書の鍵が、JWKの他のメンバーが表す公開鍵と一致する必要があることにも注意してください。"
    },
    {
      "indent": 0,
      "text": "3. Mutual-TLS Client Certificate-Bound Access Tokens",
      "section_title": true,
      "ja": "3. 相互TLSクライアント証明書にバインドされたアクセストークン"
    },
    {
      "indent": 3,
      "text": "When mutual TLS is used by the client on the connection to the token endpoint, the authorization server is able to bind the issued access token to the client certificate. Such a binding is accomplished by associating the certificate with the token in a way that can be accessed by the protected resource, such as embedding the certificate hash in the issued access token directly, using the syntax described in Section 3.1, or through token introspection as described in Section 3.2. Binding the access token to the client certificate in that fashion has the benefit of decoupling that binding from the client's authentication with the authorization server, which enables mutual TLS during protected resource access to serve purely as a proof-of-possession mechanism. Other methods of associating a certificate with an access token are possible, per agreement by the authorization server and the protected resource, but are beyond the scope of this specification.",
      "ja": "トークンエンドポイントへの接続でクライアントが相互TLSを使用すると、許可サーバーは発行されたアクセストークンをクライアント証明書にバインドできます。このようなバインディングは、セクション3.1で説明されている構文を使用して、またはトークンイントロスペクションを通じて、発行されたアクセストークンに証明書ハッシュを直接埋め込むなど、保護されたリソースからアクセスできる方法で証明書をトークンに関連付けることによって実現されます。セクション3.2で説明します。この方法でアクセストークンをクライアント証明書にバインドすることには、クライアントの認証から承認サーバーへのバインドを切り離すという利点があります。これにより、保護されたリソースアクセス中に相互TLSが純粋に所有証明メカニズムとして機能します。承認サーバーと保護されたリソースによる合意に従って、証明書をアクセストークンに関連付ける他の方法も可能ですが、この仕様の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "In order for a resource server to use certificate-bound access tokens, it must have advance knowledge that mutual TLS is to be used for some or all resource accesses. In particular, the access token itself cannot be used as input to the decision of whether or not to request mutual TLS because (from the TLS perspective) it is \"Application Data\", only exchanged after the TLS handshake has been completed, and the initial CertificateRequest occurs during the handshake, before the Application Data is available. Although subsequent opportunities for a TLS client to present a certificate may be available, e.g., via TLS 1.2 renegotiation [RFC5246] or TLS 1.3 post-handshake authentication [RFC8446], this document makes no provision for their usage. It is expected to be common that a mutual-TLS-using resource server will require mutual TLS for all resources hosted thereupon or will serve mutual-TLS-protected and regular resources on separate hostname and port combinations, though other workflows are possible. How resource server policy is synchronized with the authorization server (AS) is out of scope for this document.",
      "ja": "リソースサーバーが証明書にバインドされたアクセストークンを使用するためには、相互TLSが一部またはすべてのリソースアクセスに使用されるという事前の知識が必要です。特に、アクセストークン自体は、相互TLSを要求するかどうかの決定への入力として使用できません。これは、（TLSの観点から）「アプリケーションデータ」であり、TLSハンドシェイクが完了した後にのみ交換されるためです。 CertificateRequestは、アプリケーションデータが利用可能になる前のハンドシェイク中に発生します。 TLSクライアントが証明書を提示する後続の機会は、たとえばTLS 1.2再ネゴシエーション[RFC5246]またはTLS 1.3ハンドシェイク認証[RFC8446]を介して利用できる場合がありますが、このドキュメントではそれらの使用法については規定していません。相互TLSを使用するリソースサーバーは、ホストされているすべてのリソースに相互TLSを必要とするか、別のホスト名とポートの組み合わせで相互TLS保護された通常のリソースを提供することが一般的であると予想されますが、他のワークフローも可能です。リソースサーバーポリシーを承認サーバー（AS）と同期する方法は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Within the scope of a mutual-TLS-protected resource-access flow, the client makes protected resource requests, as described in [RFC6750], however, those requests MUST be made over a mutually authenticated TLS connection using the same certificate that was used for mutual TLS at the token endpoint.",
      "ja": "相互TLSで保護されたリソースアクセスフローの範囲内で、[RFC6750]で説明されているように、クライアントは保護されたリソース要求を行いますが、これらの要求は、トークンエンドポイントでの相互TLS。"
    },
    {
      "indent": 3,
      "text": "The protected resource MUST obtain, from its TLS implementation layer, the client certificate used for mutual TLS and MUST verify that the certificate matches the certificate associated with the access token. If they do not match, the resource access attempt MUST be rejected with an error, per [RFC6750], using an HTTP 401 status code and the \"invalid_token\" error code.",
      "ja": "保護されたリソースは、そのTLS実装層から、相互TLSに使用されるクライアント証明書を取得する必要があり、証明書がアクセストークンに関連付けられている証明書と一致することを確認する必要があります。それらが一致しない場合、[RFC6750]に従い、HTTP 401ステータスコードと「invalid_token」エラーコードを使用して、リソースアクセスの試行をエラーで拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Metadata to convey server and client capabilities for mutual-TLS client certificate-bound access tokens is defined in Sections 3.3 and 3.4, respectively.",
      "ja": "相互TLSクライアント証明書にバインドされたアクセストークンのサーバーおよびクライアント機能を伝達するメタデータは、それぞれセクション3.3および3.4​​で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.1. JWT Certificate Thumbprint Confirmation Method",
      "section_title": true,
      "ja": "3.1. JWT証明書の拇印確認方法"
    },
    {
      "indent": 3,
      "text": "When access tokens are represented as JSON Web Tokens (JWT) [RFC7519], the certificate hash information SHOULD be represented using the \"x5t#S256\" confirmation method member defined herein.",
      "ja": "アクセストークンがJSON Web Token（JWT）[RFC7519]として表される場合、証明書のハッシュ情報は、ここで定義されている「x5t＃S256」確認メソッドメンバーを使用して表されるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "To represent the hash of a certificate in a JWT, this specification defines the new JWT Confirmation Method [RFC7800] member \"x5t#S256\" for the X.509 Certificate SHA-256 Thumbprint. The value of the \"x5t#S256\" member is a base64url-encoded [RFC4648] SHA-256 [SHS] hash (a.k.a., thumbprint, fingerprint, or digest) of the DER encoding [X690] of the X.509 certificate [RFC5280]. The base64url-encoded value MUST omit all trailing pad '=' characters and MUST NOT include any line breaks, whitespace, or other additional characters.",
      "ja": "JWTで証明書のハッシュを表すために、この仕様では、X.509証明書SHA-256サムプリント用の新しいJWT確認メソッド[RFC7800]メンバー \"x5t＃S256\"を定義しています。 「x5t＃S256」メンバーの値は、X.509証明書[RFC5280]のDERエンコード[X690]のbase64urlエンコード[RFC4648] SHA-256 [SHS]ハッシュ（別名、拇印、指紋、またはダイジェスト）です。 ]。 base64urlでエンコードされた値では、末尾の「=」文字をすべて省略し、改行、空白、その他の追加文字を含めてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The following is an example of a JWT payload containing an \"x5t#S256\" certificate thumbprint confirmation method. The new JWT content introduced by this specification is the \"cnf\" confirmation method claim at the bottom of the example that has the \"x5t#S256\" confirmation method member containing the value that is the hash of the client certificate to which the access token is bound.",
      "ja": "以下は、「x5t＃S256」証明書の拇印確認メソッドを含むJWTペイロードの例です。この仕様で導入された新しいJWTコンテンツは、「x5t＃S256」確認メソッドメンバーがアクセストークンが適用されるクライアント証明書のハッシュである値を含む「x5t＃S256」確認メソッドメンバーを持つ例の下部にある「cnf」確認メソッドクレームです。バウンド。"
    },
    {
      "indent": 5,
      "text": "{\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 2: Example JWT Claims Set with an X.509 Certificate Thumbprint Confirmation Method",
      "ja": "図2：X.509証明書の拇印確認メソッドを使用したJWTクレームセットの例"
    },
    {
      "indent": 0,
      "text": "3.2. Confirmation Method for Token Introspection",
      "section_title": true,
      "ja": "3.2. トークンイントロスペクションの確認方法"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 Token Introspection [RFC7662] defines a method for a protected resource to query an authorization server about the active state of an access token as well as to determine metainformation about the token.",
      "ja": "OAuth 2.0トークンイントロスペクション[RFC7662]は、保護されたリソースがアクセストークンのアクティブな状態について承認サーバーにクエリを実行し、トークンに関するメタ情報を決定するためのメソッドを定義しています。"
    },
    {
      "indent": 3,
      "text": "For a mutual-TLS client certificate-bound access token, the hash of the certificate to which the token is bound is conveyed to the protected resource as metainformation in a token introspection response. The hash is conveyed using the same \"cnf\" with \"x5t#S256\" member structure as the certificate SHA-256 thumbprint confirmation method, described in Section 3.1, as a top-level member of the introspection response JSON. The protected resource compares that certificate hash to a hash of the client certificate used for mutual-TLS authentication and rejects the request if they do not match.",
      "ja": "相互TLSクライアント証明書にバインドされたアクセストークンの場合、トークンがバインドされている証明書のハッシュは、トークンイントロスペクションレスポンスのメタ情報として保護されたリソースに伝達されます。ハッシュは、「x5t＃S256」メンバー構造と同じ「cnf」を使用して、セクション3.1で説明した証明書SHA-256サムプリント確認メソッドと同様に、イントロスペクション応答JSONのトップレベルメンバーとして伝達されます。保護されたリソースは、その証明書ハッシュを相互TLS認証に使用されるクライアント証明書のハッシュと比較し、一致しない場合は要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "The following is an example of an introspection response for an active token with an \"x5t#S256\" certificate thumbprint confirmation method. The new introspection response content introduced by this specification is the \"cnf\" confirmation method at the bottom of the example that has the \"x5t#S256\" confirmation method member containing the value that is the hash of the client certificate to which the access token is bound.",
      "ja": "以下は、「x5t＃S256」証明書サムプリント確認メソッドを使用したアクティブなトークンのイントロスペクション応答の例です。この仕様で導入された新しいイントロスペクション応答コンテンツは、アクセストークンが適用されるクライアント証明書のハッシュである値を含む「x5t＃S256」確認メソッドメンバーを含む、例の下部にある「cnf」確認メソッドです。バウンド。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "{\n  \"active\": true,\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 3: Example Introspection Response for a Certificate-Bound Access Token",
      "ja": "図3：証明書にバインドされたアクセストークンのイントロスペクション応答の例"
    },
    {
      "indent": 0,
      "text": "3.3. Authorization Server Metadata",
      "section_title": true,
      "ja": "3.3. 承認サーバーのメタデータ"
    },
    {
      "indent": 3,
      "text": "This document introduces the following new authorization server metadata [RFC8414] parameter to signal the server's capability to issue certificate-bound access tokens:",
      "ja": "このドキュメントでは、次の新しい認証サーバーメタデータ[RFC8414]パラメーターを導入して、サーバーに証明書バインドアクセストークンを発行する機能を通知します。"
    },
    {
      "indent": 3,
      "text": "tls_client_certificate_bound_access_tokens OPTIONAL. Boolean value indicating server support for mutual-TLS client certificate-bound access tokens. If omitted, the default value is \"false\".",
      "ja": "tls_client_certificate_bound_access_tokensオプション。相互TLSクライアント証明書にバインドされたアクセストークンに対するサーバーのサポートを示すブール値。省略した場合、デフォルト値は「false」です。"
    },
    {
      "indent": 0,
      "text": "3.4. Client Registration Metadata",
      "section_title": true,
      "ja": "3.4. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "The following new client metadata parameter is introduced to convey the client's intention to use certificate-bound access tokens:",
      "ja": "証明書にバインドされたアクセストークンを使用するクライアントの意図を伝えるために、次の新しいクライアントメタデータパラメーターが導入されました。"
    },
    {
      "indent": 3,
      "text": "tls_client_certificate_bound_access_tokens OPTIONAL. Boolean value used to indicate the client's intention to use mutual-TLS client certificate-bound access tokens. If omitted, the default value is \"false\".",
      "ja": "tls_client_certificate_bound_access_tokensオプション。相互TLSクライアント証明書にバインドされたアクセストークンを使用するクライアントの意図を示すために使用されるブール値。省略した場合、デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "Note that if a client that has indicated the intention to use mutual-TLS client certificate-bound tokens makes a request to the token endpoint over a non-mutual-TLS connection, it is at the authorization server's discretion as to whether to return an error or issue an unbound token.",
      "ja": "相互TLSクライアント証明書にバインドされたトークンを使用する意図を示したクライアントが非相互TLS接続を介してトークンエンドポイントにリクエストを行う場合、エラーを返すかどうかは、許可サーバーの裁量にあることに注意してください。または、バインドされていないトークンを発行します。"
    },
    {
      "indent": 0,
      "text": "4. Public Clients and Certificate-Bound Tokens",
      "section_title": true,
      "ja": "4. パブリッククライアントと証明書バインドトークン"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS OAuth client authentication and certificate-bound access tokens can be used independently of each other. Use of certificate-bound access tokens without mutual-TLS OAuth client authentication, for example, is possible in support of binding access tokens to a TLS client certificate for public clients (those without authentication credentials associated with the \"client_id\"). The authorization server would configure the TLS stack in the same manner as for the Self-Signed Certificate method such that it does not verify that the certificate presented by the client during the handshake is signed by a trusted CA. Individual instances of a client would create a self-signed certificate for mutual TLS with both the authorization server and resource server. The authorization server would not use the mutual-TLS certificate to authenticate the client at the OAuth layer but would bind the issued access token to the certificate for which the client has proven possession of the corresponding private key. The access token is then bound to the certificate and can only be used by the client possessing the certificate and corresponding private key and utilizing them to negotiate mutual TLS on connections to the resource server. When the authorization server issues a refresh token to such a client, it SHOULD also bind the refresh token to the respective certificate and check the binding when the refresh token is presented to get new access tokens. The implementation details of the binding of the refresh token are at the discretion of the authorization server.",
      "ja": "相互TLS OAuthクライアント認証と証明書にバインドされたアクセストークンは、互いに独立して使用できます。たとえば、相互TLS OAuthクライアント認証なしで証明書にバインドされたアクセストークンを使用すると、パブリッククライアントのTLSクライアント証明書にアクセストークンをバインドできます（「client_id」に関連付けられた認証資格情報がないもの）。承認サーバーは、ハンドシェイク中にクライアントによって提示された証明書が信頼できるCAによって署名されていることを検証しないように、自己署名証明書の方法と同じ方法でTLSスタックを構成します。クライアントの個々のインスタンスは、承認サーバーとリソースサーバーの両方との相互TLS用の自己署名証明書を作成します。承認サーバーは、相互TLS証明書を使用してOAuthレイヤーでクライアントを認証しませんが、発行されたアクセストークンを、クライアントが対応する秘密キーを所有していることを証明した証明書にバインドします。アクセストークンは証明書にバインドされ、証明書と対応する秘密キーを所有し、それらを利用してリソースサーバーへの接続で相互TLSをネゴシエートするクライアントのみが使用できます。承認サーバーがそのようなクライアントに更新トークンを発行するとき、更新トークンをそれぞれの証明書にバインドし、更新トークンが提示されたときにバインドをチェックして新しいアクセストークンを取得する必要があります（SHOULD）。更新トークンのバインディングの実装の詳細は、許可サーバーの裁量にあります。"
    },
    {
      "indent": 0,
      "text": "5. Metadata for Mutual-TLS Endpoint Aliases",
      "section_title": true,
      "ja": "5. 相互TLSエンドポイントエイリアスのメタデータ"
    },
    {
      "indent": 3,
      "text": "The process of negotiating client certificate-based mutual TLS involves a TLS server requesting a certificate from the TLS client (the client does not provide one unsolicited). Although a server can be configured such that client certificates are optional, meaning that the connection is allowed to continue when the client does not provide a certificate, the act of a server requesting a certificate can result in undesirable behavior from some clients. This is particularly true of web browsers as TLS clients, which will typically present the end user with an intrusive certificate selection interface when the server requests a certificate.",
      "ja": "クライアント証明書ベースの相互TLSをネゴシエートするプロセスには、TLSサーバーがTLSクライアントからの証明書を要求することが含まれます（クライアントは非送信請求を提供しません）。サーバーは、クライアント証明書がオプションであるように構成できます。つまり、クライアントが証明書を提供しなくても接続を継続できますが、サーバーが証明書を要求すると、一部のクライアントから望ましくない動作が発生する可能性があります。これは、TLSクライアントとしてのWebブラウザーに特に当てはまります。サーバーは証明書を要求すると、通常、エンドユーザーに侵入証明書選択インターフェイスを提示します。"
    },
    {
      "indent": 3,
      "text": "Authorization servers supporting both clients using mutual TLS and conventional clients MAY chose to isolate the server side mutual-TLS behavior to only clients intending to do mutual TLS, thus avoiding any undesirable effects it might have on conventional clients. The following authorization server metadata parameter is introduced to facilitate such separation:",
      "ja": "相互TLSを使用するクライアントと従来のクライアントの両方をサポートする承認サーバーは、サーバー側の相互TLS動作を相互TLSを実行する予定のクライアントのみに分離することを選択できます。このような分離を容易にするために、次の許可サーバーメタデータパラメーターが導入されています。"
    },
    {
      "indent": 3,
      "text": "mtls_endpoint_aliases OPTIONAL. A JSON object containing alternative authorization server endpoints that, when present, an OAuth client intending to do mutual TLS uses in preference to the conventional endpoints. The parameter value itself consists of one or more endpoint parameters, such as \"token_endpoint\", \"revocation_endpoint\", \"introspection_endpoint\", etc., conventionally defined for the top level of authorization server metadata. An OAuth client intending to do mutual TLS (for OAuth client authentication and/or to acquire or use certificate-bound tokens) when making a request directly to the authorization server MUST use the alias URL of the endpoint within the \"mtls_endpoint_aliases\", when present, in preference to the endpoint URL of the same name at the top level of metadata. When an endpoint is not present in \"mtls_endpoint_aliases\", then the client uses the conventional endpoint URL defined at the top level of the authorization server metadata. Metadata parameters within \"mtls_endpoint_aliases\" that do not define endpoints to which an OAuth client makes a direct request have no meaning and SHOULD be ignored.",
      "ja": "mtls_endpoint_aliasesオプション。存在する場合、相互TLSを実行することを意図しているOAuthクライアントが従来のエンドポイントに優先して使用する代替の認証サーバーエンドポイントを含むJSONオブジェクト。パラメータ値自体は、「token_endpoint」、「revocation_endpoint」、「introspection_endpoint」など、1つ以上のエンドポイントパラメータで構成されます。これらは、通常、最上位の認証サーバーメタデータ用に定義されています。承認サーバーに直接リクエストを行うときに相互TLS（OAuthクライアント認証および/または証明書にバインドされたトークンを取得または使用する）を意図しているOAuthクライアントは、存在する場合は「mtls_endpoint_aliases」内のエンドポイントのエイリアスURLを使用する必要があります、メタデータの最上位にある同じ名前のエンドポイントURLに優先して。エンドポイントが「mtls_endpoint_aliases」に存在しない場合、クライアントは、承認サーバーメタデータの最上位に定義されている従来のエンドポイントURLを使用します。 OAuthクライアントが直接リクエストするエンドポイントを定義しない「mtls_endpoint_aliases」内のメタデータパラメータは意味を持たないため、無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Below is an example of an authorization server metadata document with the \"mtls_endpoint_aliases\" parameter, which indicates aliases for the token, revocation, and introspection endpoints that an OAuth client intending to do mutual TLS would use in preference to the conventional token, revocation, and introspection endpoints. Note that the endpoints in \"mtls_endpoint_aliases\" use a different host than their conventional counterparts, which allows the authorization server (via TLS \"server_name\" extension [RFC6066] or actual distinct hosts) to differentiate its TLS behavior as appropriate.",
      "ja": "以下は、「mtls_endpoint_aliases」パラメーターが指定された承認サーバーメタデータドキュメントの例です。これは、相互TLSを実行しようとしているOAuthクライアントが従来のトークン、失効、および優先順位に優先して使用するトークン、失効、およびイントロスペクションエンドポイントのエイリアスを示します。イントロスペクションのエンドポイント。 \"mtls_endpoint_aliases\"のエンドポイントは、従来の対応するものとは異なるホストを使用することに注意してください。これにより、許可サーバー（TLS \"server_name\"拡張[RFC6066]または実際の個別のホストを介して）が適切にTLS動作を区別できるようになります。"
    },
    {
      "indent": 3,
      "text": "{\n  \"issuer\": \"https://server.example.com\",\n  \"authorization_endpoint\": \"https://server.example.com/authz\",\n  \"token_endpoint\": \"https://server.example.com/token\",\n  \"introspection_endpoint\": \"https://server.example.com/introspect\",\n  \"revocation_endpoint\": \"https://server.example.com/revo\",\n  \"jwks_uri\": \"https://server.example.com/jwks\",\n  \"response_types_supported\": [\"code\"],\n  \"response_modes_supported\": [\"fragment\",\"query\",\"form_post\"],\n  \"grant_types_supported\": [\"authorization_code\", \"refresh_token\"],\n  \"token_endpoint_auth_methods_supported\":\n                  [\"tls_client_auth\",\"client_secret_basic\",\"none\"],\n  \"tls_client_certificate_bound_access_tokens\": true,\n  \"mtls_endpoint_aliases\": {\n    \"token_endpoint\": \"https://mtls.example.com/token\",\n    \"revocation_endpoint\": \"https://mtls.example.com/revo\",\n    \"introspection_endpoint\": \"https://mtls.example.com/introspect\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 4: Example Authorization Server Metadata with Mutual-TLS Endpoint Aliases",
      "ja": "図4：相互TLSエンドポイントエイリアスを持つ承認サーバーメタデータの例"
    },
    {
      "indent": 0,
      "text": "6. Implementation Considerations",
      "section_title": true,
      "ja": "6. 実装に関する考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Authorization Server",
      "section_title": true,
      "ja": "6.1. 認可サーバー"
    },
    {
      "indent": 3,
      "text": "The authorization server needs to set up its TLS configuration appropriately for the OAuth client authentication methods it supports.",
      "ja": "許可サーバーは、サポートするOAuthクライアント認証方式に合わせてTLS構成を適切にセットアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "An authorization server that supports mutual-TLS client authentication and other client authentication methods or public clients in parallel would make mutual TLS optional (i.e., allowing a handshake to continue after the server requests a client certificate but the client does not send one).",
      "ja": "相互TLSクライアント認証と他のクライアント認証方法、またはパブリッククライアントを並行してサポートする承認サーバーは、相互TLSをオプションにします（つまり、サーバーがクライアント証明書を要求した後、クライアントが証明書を送信しない場合でも、ハンドシェイクを続行できます）。"
    },
    {
      "indent": 3,
      "text": "In order to support the Self-Signed Certificate method alone, the authorization server would configure the TLS stack in such a way that it does not verify whether the certificate presented by the client during the handshake is signed by a trusted CA certificate.",
      "ja": "自己署名証明書方式のみをサポートするために、承認サーバーは、ハンドシェイク中にクライアントによって提示された証明書が信頼できるCA証明書によって署名されているかどうかを検証しないようにTLSスタックを構成します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, the authorization server binds the issued access token to the TLS client certificate, which means that it will only issue certificate-bound tokens for a certificate that the client has proven possession of the corresponding private key.",
      "ja": "セクション3で説明したように、認証サーバーは発行されたアクセストークンをTLSクライアント証明書にバインドします。つまり、クライアントが対応する秘密鍵を所有していることが証明された証明書に対してのみ、証明書にバインドされたトークンを発行します。"
    },
    {
      "indent": 3,
      "text": "The authorization server may also consider hosting the token endpoint and other endpoints requiring client authentication on a separate host name or port in order to prevent unintended impact on the TLS behavior of its other endpoints, e.g., the authorization endpoint. As described in Section 5, it may further isolate any potential impact of the server requesting client certificates by offering a distinct set of endpoints on a separate host or port, which are aliases for the originals that a client intending to do mutual TLS will use in preference to the conventional endpoints.",
      "ja": "承認サーバーは、他のエンドポイント（承認エンドポイントなど）のTLS動作への意図しない影響を防ぐために、別のホスト名またはポートでクライアント認証を必要とするトークンエンドポイントおよび他のエンドポイントをホストすることも検討します。セクション5で説明されているように、個別のホストまたはポートにエンドポイントの異なるセットを提供することにより、サーバーがクライアント証明書を要求する潜在的な影響をさらに分離できます。従来のエンドポイントよりも優先されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Resource Server",
      "section_title": true,
      "ja": "6.2. リソースサーバー"
    },
    {
      "indent": 3,
      "text": "OAuth divides the roles and responsibilities such that the resource server relies on the authorization server to perform client authentication and obtain resource-owner (end-user) authorization. The resource server makes authorization decisions based on the access token presented by the client but does not directly authenticate the client per se. The manner in which an access token is bound to the client certificate and how a protected resource verifies the proof-of-possession decouples that from the specific method that the client used to authenticate with the authorization server. Mutual TLS during protected resource access can, therefore, serve purely as a proof-of-possession mechanism. As such, it is not necessary for the resource server to validate the trust chain of the client's certificate in any of the methods defined in this document. The resource server would, therefore, configure the TLS stack in a way that it does not verify whether the certificate presented by the client during the handshake is signed by a trusted CA certificate.",
      "ja": "OAuthは役割と責任を分割するため、リソースサーバーは承認サーバーに依存してクライアント認証を実行し、リソース所有者（エンドユーザー）の承認を取得します。リソースサーバーは、クライアントから提示されたアクセストークンに基づいて承認を決定しますが、クライアント自体を直接認証しません。アクセストークンがクライアント証明書にバインドされる方法、および保護されたリソースが所有証明を検証する方法は、クライアントが許可サーバーでの認証に使用した特定の方法からそれを切り離します。したがって、保護されたリソースアクセス中の相互TLSは、純粋に所有証明メカニズムとして機能します。そのため、このドキュメントで定義されている方法のいずれかで、リソースサーバーがクライアントの証明書の信頼チェーンを検証する必要はありません。したがって、リソースサーバーは、ハンドシェイク中にクライアントによって提示された証明書が信頼できるCA証明書によって署名されているかどうかを検証しないようにTLSスタックを構成します。"
    },
    {
      "indent": 0,
      "text": "6.3. Certificate Expiration and Bound Access Tokens",
      "section_title": true,
      "ja": "6.3. 証明書の有効期限とバインドされたアクセストークン"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, an access token is bound to a specific client certificate, which means that the same certificate must be used for mutual TLS on protected resource access. It also implies that access tokens are invalidated when a client updates the certificate, which can be handled similarly to expired access tokens where the client requests a new access token (typically with a refresh token) and retries the protected resource request.",
      "ja": "セクション3で説明したように、アクセストークンは特定のクライアント証明書にバインドされます。つまり、保護されたリソースアクセスで相互TLSに同じ証明書を使用する必要があります。また、クライアントが証明書を更新するとアクセストークンが無効になることを意味します。これは、クライアントが新しいアクセストークンを要求し（通常は更新トークンを使用）、保護されたリソース要求を再試行する期限切れのアクセストークンと同様に処理できます。"
    },
    {
      "indent": 0,
      "text": "6.4. Implicit Grant Unsupported",
      "section_title": true,
      "ja": "6.4. 暗黙的な付与はサポートされていません"
    },
    {
      "indent": 3,
      "text": "This document describes binding an access token to the client certificate presented on the TLS connection from the client to the authorization server's token endpoint, however, such binding of access tokens issued directly from the authorization endpoint via the implicit grant flow is explicitly out of scope. End users interact directly with the authorization endpoint using a web browser, and the use of client certificates in user's browsers bring operational and usability issues that make it undesirable to support certificate-bound access tokens issued in the implicit grant flow. Implementations wanting to employ certificate-bound access tokens should utilize grant types that involve the client making an access token request directly to the token endpoint (e.g., the authorization code and refresh token grant types).",
      "ja": "このドキュメントでは、クライアントから許可サーバーのトークンエンドポイントへのTLS接続で提示されるクライアント証明書へのアクセストークンのバインドについて説明しますが、暗黙的な許可フローを介して許可エンドポイントから直接発行されたアクセストークンのバインドは、明示的に範囲外です。エンドユーザーは、Webブラウザーを使用して認証エンドポイントと直接対話します。ユーザーのブラウザーでクライアント証明書を使用すると、暗黙的な許可フローで発行された証明書にバインドされたアクセストークンをサポートすることが望ましくない運用上および使用上の問題が発生します。証明書にバインドされたアクセストークンを使用する実装では、クライアントがトークンエンドポイントに直接アクセストークンリクエストを発行することを許可するタイプ（認証コードや更新トークンの許可タイプなど）を利用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. TLS Termination",
      "section_title": true,
      "ja": "6.5. TLS終了"
    },
    {
      "indent": 3,
      "text": "An authorization server or resource server MAY choose to terminate TLS connections at a load balancer, reverse proxy, or other network intermediary. How the client certificate metadata is securely communicated between the intermediary and the application server, in this case, is out of scope of this specification.",
      "ja": "承認サーバーまたはリソースサーバーは、ロードバランサー、リバースプロキシ、またはその他のネットワーク仲介でTLS接続を終了することを選択できます。この場合、クライアント証明書メタデータが中間サーバーとアプリケーションサーバーの間で安全に通信される方法は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Certificate-Bound Refresh Tokens",
      "section_title": true,
      "ja": "7.1. 証明書にバインドされた更新トークン"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 Authorization Framework [RFC6749] requires that an authorization server (AS) bind refresh tokens to the client to which they were issued and that confidential clients (those having established authentication credentials with the AS) authenticate to the AS when presenting a refresh token. As a result, refresh tokens are indirectly certificate-bound by way of the client ID and the associated requirement for (certificate-based) authentication to the AS when issued to clients utilizing the \"tls_client_auth\" or \"self_signed_tls_client_auth\" methods of client authentication. Section 4 describes certificate-bound refresh tokens issued to public clients (those without authentication credentials associated with the \"client_id\").",
      "ja": "OAuth 2.0承認フレームワーク[RFC6749]では、承認サーバー（AS）が発行されたクライアントに更新トークンをバインドし、機密クライアント（ASで認証資格情報を確立しているクライアント）が更新トークンを提示するときにASを認証する必要があります。 。その結果、更新トークンは、クライアント認証の「tls_client_auth」または「self_signed_tls_client_auth」メソッドを使用してクライアントに発行されると、クライアントIDとASに対する（証明書ベースの）認証の関連要件によって間接的に証明書にバインドされます。セクション4では、パブリッククライアントに発行された証明書バインドリフレッシュトークンについて説明します（「client_id」に関連付けられた認証資格情報がないトークン）。"
    },
    {
      "indent": 0,
      "text": "7.2. Certificate Thumbprint Binding",
      "section_title": true,
      "ja": "7.2. 証明書の拇印のバインド"
    },
    {
      "indent": 3,
      "text": "The binding between the certificate and access token specified in Section 3.1 uses a cryptographic hash of the certificate. It relies on the hash function having sufficient second-preimage resistance so as to make it computationally infeasible to find or create another certificate that produces to the same hash output value. The SHA-256 hash function was used because it meets the aforementioned requirement while being widely available. If, in the future, certificate thumbprints need to be computed using hash function(s) other than SHA-256, it is suggested that, for additional related JWT confirmation methods, members be defined for that purpose and registered in the IANA \"JWT Confirmation Methods\" registry [IANA.JWT.Claims] for JWT \"cnf\" member values.",
      "ja": "証明書とセクション3.1で指定されたアクセストークン間のバインディングでは、証明書の暗号化ハッシュが使用されます。同じハッシュ出力値を生成する別の証明書を検索または作成することを計算上実行不可能にするために、十分な第2プリイメージ耐性を持つハッシュ関数に依存しています。 SHA-256ハッシュ関数は、広く利用可能でありながら前述の要件を満たしているため使用されました。将来、SHA-256以外のハッシュ関数を使用して証明書の拇印を計算する必要がある場合は、関連する追加のJWT確認方法について、その目的のためにメンバーを定義し、IANAの「JWT確認」に登録することをお勧めします。メソッド」レジストリ[IANA.JWT.Claims]のJWT「cnf」メンバー値。"
    },
    {
      "indent": 3,
      "text": "Community knowledge about the strength of various algorithms and feasible attacks can change suddenly, and experience shows that a document about security is a point-in-time statement. Readers are advised to seek out any errata or updates that apply to this document.",
      "ja": "さまざまなアルゴリズムの強さや実行可能な攻撃に関するコミュニティの知識は突然変化する可能性があり、セキュリティに関するドキュメントは特定の時点のステートメントであることが経験からわかります。読者は、このドキュメントに適用される正誤表または更新を探すことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.3. TLS Versions and Best Practices",
      "section_title": true,
      "ja": "7.3. TLSバージョンとベストプラクティス"
    },
    {
      "indent": 3,
      "text": "This document is applicable with any TLS version supporting certificate-based client authentication. Both TLS 1.3 [RFC8446] and TLS 1.2 [RFC5246] are cited herein, because, at the time of writing, 1.3 is the newest version, while 1.2 is the most widely deployed. General implementation and security considerations for TLS, including version recommendations, can be found in [BCP195].",
      "ja": "このドキュメントは、証明書ベースのクライアント認証をサポートするすべてのTLSバージョンに適用できます。執筆時点では1.3が最新バージョンであり、1.2が最も広く展開されているため、TLS 1.3 [RFC8446]とTLS 1.2 [RFC5246]の両方がここで引用されています。バージョンの推奨事項を含む、TLSの一般的な実装とセキュリティの考慮事項は、[BCP195]にあります。"
    },
    {
      "indent": 3,
      "text": "TLS certificate validation (for both client and server certificates) requires a local database of trusted certificate authorities (CAs). Decisions about what CAs to trust and how to make such a determination of trust are out of scope for this document.",
      "ja": "TLS証明書の検証（クライアント証明書とサーバー証明書の両方）には、信頼できる認証局（CA）のローカルデータベースが必要です。どのCAを信頼するべきか、どのように信頼を決定するかについての決定は、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "7.4. X.509 Certificate Spoofing",
      "section_title": true,
      "ja": "7.4. X.509証明書のなりすまし"
    },
    {
      "indent": 3,
      "text": "If the PKI method of client authentication is used, an attacker could try to impersonate a client using a certificate with the same subject (DN or SAN) but issued by a different CA that the authorization server trusts. To cope with that threat, the authorization server SHOULD only accept, as trust anchors, a limited number of CAs whose certificate issuance policy meets its security requirements. There is an assumption then that the client and server agree out of band on the set of trust anchors that the server uses to create and validate the certificate chain. Without this assumption the use of a subject to identify the client certificate would open the server up to certificate spoofing attacks.",
      "ja": "クライアント認証のPKI方式が使用されている場合、攻撃者は、同じサブジェクト（DNまたはSAN）を持つが、承認サーバーが信頼する別のCAによって発行された証明書を使用してクライアントを偽装しようとする可能性があります。その脅威に対処するために、承認サーバーは、証明書発行ポリシーがそのセキュリティ要件を満たしている限られた数のCAのみをトラストアンカーとして受け入れる必要があります（SHOULD）。次に、クライアントとサーバーが、サーバーが証明書チェーンの作成と検証に使用するトラストアンカーのセットについて帯域外で合意するという仮定があります。この仮定がない場合、サブジェクトを使用してクライアント証明書を識別すると、サーバーが証明書のなりすまし攻撃を受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.5. X.509 Certificate Parsing and Validation Complexity",
      "section_title": true,
      "ja": "7.5. X.509証明書の解析と検証の複雑さ"
    },
    {
      "indent": 3,
      "text": "Parsing and validation of X.509 certificates and certificate chains is complex, and implementation mistakes have previously exposed security vulnerabilities. Complexities of validation include (but are not limited to) [CX5P] [DCW] [RFC5280]:",
      "ja": "X.509証明書と証明書チェーンの解析と検証は複雑であり、実装の誤りにより、以前にセキュリティの脆弱性が露呈しています。検証の複雑さは次のとおりです（これらに限定されません）[CX5P] [DCW] [RFC5280]："
    },
    {
      "indent": 3,
      "text": "* checking of basic constraints, basic and extended key usage constraints, validity periods, and critical extensions;",
      "ja": "* 基本制約、基本および拡張キー使用制約、有効期間、および重要な拡張のチェック。"
    },
    {
      "indent": 3,
      "text": "* handling of embedded NUL bytes in ASN.1 counted-length strings and non-canonical or non-normalized string representations in subject names;",
      "ja": "* ASN.1のカウントされた長さの文字列に埋め込まれたNULバイトと、サブジェクト名の非正規または非正規化文字列表現の処理。"
    },
    {
      "indent": 3,
      "text": "* handling of wildcard patterns in subject names;",
      "ja": "* 件名でのワイルドカードパターンの処理。"
    },
    {
      "indent": 3,
      "text": "* recursive verification of certificate chains and checking certificate revocation.",
      "ja": "* 証明書チェーンの再帰的な検証と証明書の取り消しの確認。"
    },
    {
      "indent": 3,
      "text": "For these reasons, implementors SHOULD use an established and well-tested X.509 library (such as one used by an established TLS library) for validation of X.509 certificate chains and SHOULD NOT attempt to write their own X.509 certificate validation procedures.",
      "ja": "これらの理由により、実装者は、確立され、十分にテストされたX.509ライブラリ（確立されたTLSライブラリで使用されるライブラリなど）をX.509証明書チェーンの検証に使用する必要があり（SHOULD）、独自のX.509証明書検証手順を記述しないでください（SHOULD NOT） 。"
    },
    {
      "indent": 0,
      "text": "8. Privacy Considerations",
      "section_title": true,
      "ja": "8. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In TLS versions prior to 1.3, the client's certificate is sent unencrypted in the initial handshake and can potentially be used by third parties to monitor, track, and correlate client activity. This is likely of little concern for clients that act on behalf of a significant number of end users because individual user activity will not be discernible amidst the client activity as a whole. However, clients that act on behalf of a single end user, such as a native application on a mobile device, should use TLS version 1.3 whenever possible or consider the potential privacy implications of using mutual TLS on earlier versions.",
      "ja": "1.3より前のTLSバージョンでは、クライアントの証明書は最初のハンドシェイクで暗号化されずに送信され、サードパーティがクライアントのアクティビティを監視、追跡、および関連付けるために潜在的に使用できます。個々のユーザーアクティビティは、クライアントアクティビティ全体では識別できないため、これは、かなりの数のエンドユーザーに代わって動作するクライアントにはほとんど関係ありません。ただし、モバイルデバイスのネイティブアプリケーションなど、単一のエンドユーザーに代わって動作するクライアントは、可能な限りTLSバージョン1.3を使用するか、以前のバージョンで相互TLSを使用することによるプライバシーへの影響を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. JWT Confirmation Methods Registration",
      "section_title": true,
      "ja": "9.1. JWT確認メソッドの登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following value has been registered in the IANA \"JWT Confirmation Methods\" registry [IANA.JWT.Claims] for JWT \"cnf\" member values established by [RFC7800].",
      "ja": "この仕様に従って、[RFC7800]によって確立されたJWT \"cnf\"メンバー値のIANA \"JWT確認メソッド\"レジストリ[IANA.JWT.Claims]に次の値が登録されています。"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Value: \"x5t#S256\" Confirmation Method Description: X.509 Certificate SHA-256 Thumbprint Change Controller: IESG Specification Document(s): Section 3.1 of RFC 8705",
      "ja": "確認方法の値：「x5t＃S256」確認方法の説明：X.509証明書のSHA-256拇印変更コントローラー：IESG仕様ドキュメント：RFC 8705のセクション3.1"
    },
    {
      "indent": 0,
      "text": "9.2. Authorization Server Metadata Registration",
      "section_title": true,
      "ja": "9.2. 承認サーバーのメタデータ登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following values have been registered in the IANA \"OAuth Authorization Server Metadata\" registry [IANA.OAuth.Parameters] established by [RFC8414].",
      "ja": "この仕様に従って、[RFC8414]によって確立されたIANA \"OAuth Authorization Server Metadata\"レジストリ[IANA.OAuth.Parameters]に次の値が登録されています。"
    },
    {
      "indent": 3,
      "text": "Metadata Name: \"tls_client_certificate_bound_access_tokens\" Metadata Description: Indicates authorization server support for mutual-TLS client certificate-bound access tokens. Change Controller: IESG Specification Document(s): Section 3.3 of RFC 8705",
      "ja": "メタデータ名： \"tls_client_certificate_bound_access_tokens\"メタデータの説明：相互TLSクライアント証明書にバインドされたアクセストークンに対する承認サーバーのサポートを示します。変更管理者：IESG仕様書：RFC 8705のセクション3.3"
    },
    {
      "indent": 3,
      "text": "Metadata Name: \"mtls_endpoint_aliases\" Metadata Description: JSON object containing alternative authorization server endpoints, which a client intending to do mutual TLS will use in preference to the conventional endpoints. Change Controller: IESG Specification Document(s): Section 5 of RFC 8705",
      "ja": "メタデータ名： \"mtls_endpoint_aliases\"メタデータの説明：相互TLSを実行する予定のクライアントが従来のエンドポイントよりも優先して使用する代替の承認サーバーエンドポイントを含むJSONオブジェクト。変更管理者：IESG仕様書：RFC 8705のセクション5"
    },
    {
      "indent": 0,
      "text": "9.3. Token Endpoint Authentication Method Registration",
      "section_title": true,
      "ja": "9.3. トークンエンドポイント認証方法の登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following values have been registered in the IANA \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters] established by [RFC7591].",
      "ja": "この仕様により、[RFC7591]によって確立されたIANA \"OAuth Token Endpoint Authentication Methods\"レジストリ[IANA.OAuth.Parameters]に次の値が登録されています。"
    },
    {
      "indent": 3,
      "text": "Token Endpoint Authentication Method Name: \"tls_client_auth\" Change Controller: IESG Specification Document(s): Section 2.1.1 of RFC 8705",
      "ja": "トークンエンドポイント認証方式名： \"tls_client_auth\"変更コントローラ：IESG仕様ドキュメント：RFC 8705のセクション2.1.1"
    },
    {
      "indent": 3,
      "text": "Token Endpoint Authentication Method Name: \"self_signed_tls_client_ auth\" Change Controller: IESG Specification Document(s): Section 2.2.1 of RFC 8705",
      "ja": "トークンエンドポイントの認証方法名：「self_signed_tls_client_ auth」変更コントローラ：IESG仕様ドキュメント：RFC 8705のセクション2.2.1"
    },
    {
      "indent": 0,
      "text": "9.4. Token Introspection Response Registration",
      "section_title": true,
      "ja": "9.4. トークンイントロスペクションレスポンスの登録"
    },
    {
      "indent": 3,
      "text": "\"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\" [RFC7800] defined the \"cnf\" (confirmation) claim that enables confirmation key information to be carried in a JWT. However, the same proof-of-possession semantics are also useful for introspected access tokens whereby the protected resource obtains the confirmation key data as metainformation of a token introspection response and uses that information in verifying proof-of-possession. Therefore, this specification defines and registers proof-of-possession semantics for OAuth 2.0 Token Introspection [RFC7662] using the \"cnf\" structure. When included as a top-level member of an OAuth token introspection response, \"cnf\" has the same semantics and format as the claim of the same name defined in [RFC7800]. While this specification only explicitly uses the \"x5t#S256\" confirmation method member (see Section 3.2), it needs to define and register the higher-level \"cnf\" structure as an introspection response member in order to define and use the more specific certificate thumbprint confirmation method.",
      "ja": "「JSON Web Token（JWT）の所有証明キーの意味論」[RFC7800]は、確認キー情報をJWTで伝送できるようにする「cnf」（確認）クレームを定義しました。ただし、同じ所有証明のセマンティクスは、イントロスペクトされたアクセストークンにも役立ちます。保護されたリソースは、確認キーデータをトークンのイントロスペクション応答のメタ情報として取得し、その情報を使用して所有証明を確認します。したがって、この仕様では、「cnf」構造を使用してOAuth 2.0トークンイントロスペクション[RFC7662]の所有証明を定義し、登録します。 OAuthトークンイントロスペクションレスポンスのトップレベルメンバーとして含まれる場合、「cnf」は[RFC7800]で定義された同じ名前のクレームと同じセマンティクスと形式を持ちます。この仕様は明示的に「x5t＃S256」確認メソッドメンバー（セクション3.2を参照）のみを使用しますが、より具体的な証明書を定義して使用するには、イントロスペクション応答メンバーとして上位レベルの「cnf」構造を定義および登録する必要があります拇印確認方法。"
    },
    {
      "indent": 3,
      "text": "As such, the following values have been registered in the IANA \"OAuth Token Introspection Response\" registry [IANA.OAuth.Parameters] established by [RFC7662].",
      "ja": "そのため、[RFC7662]によって確立されたIANA \"OAuth Token Introspection Response\"レジストリ[IANA.OAuth.Parameters]に次の値が登録されています。"
    },
    {
      "indent": 3,
      "text": "Claim Name: \"cnf\" Claim Description: Confirmation Change Controller: IESG Specification Document(s): [RFC7800] and RFC 8705",
      "ja": "クレーム名： \"cnf\"クレームの説明：確認変更コントローラー：IESG仕様ドキュメント：[RFC7800]およびRFC 8705"
    },
    {
      "indent": 0,
      "text": "9.5. Dynamic Client Registration Metadata Registration",
      "section_title": true,
      "ja": "9.5. 動的クライアント登録メタデータ登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following client metadata definitions have been registered in the IANA \"OAuth Dynamic Client Registration Metadata\" registry [IANA.OAuth.Parameters] established by [RFC7591]:",
      "ja": "この仕様に従って、次のクライアントメタデータ定義が、[RFC7591]によって確立されたIANA \"OAuth Dynamic Client Registration Metadata\"レジストリ[IANA.OAuth.Parameters]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_certificate_bound_access_tokens\" Client Metadata Description: Indicates the client's intention to use mutual-TLS client certificate-bound access tokens. Change Controller: IESG Specification Document(s): Section 3.4 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_certificate_bound_access_tokens\"クライアントメタデータの説明：相互TLSクライアント証明書にバインドされたアクセストークンを使用するクライアントの意図を示します。変更管理者：IESG仕様書：RFC 8705のセクション3.4"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_subject_dn\" Client Metadata Description: String value specifying the expected subject DN of the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_subject_dn\"クライアントメタデータの説明：クライアント証明書の予期されるサブジェクトDNを指定する文字列値。変更管理者：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_dns\" Client Metadata Description: String value specifying the expected dNSName SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名：「tls_client_auth_san_dns」クライアントメタデータの説明：クライアント証明書で予期されるdNSName SANエントリを指定する文字列値。変更管理者：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_uri\" Client Metadata Description: String value specifying the expected uniformResourceIdentifier SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名：「tls_client_auth_san_uri」クライアントメタデータの説明：クライアント証明書で予期されるUniformResourceIdentifier SANエントリを指定する文字列値。変更管理者：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_ip\" Client Metadata Description: String value specifying the expected iPAddress SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_san_ip\"クライアントメタデータの説明：クライアント証明書で予期されるiPAddress SANエントリを指定する文字列値。変更管理者：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_email\" Client Metadata Description: String value specifying the expected rfc822Name SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名：「tls_client_auth_san_email」クライアントメタデータの説明：クライアント証明書で予期されるrfc822Name SANエントリを指定する文字列値。変更管理者：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, May 2015, <https://www.rfc-editor.org/info/bcp195>.",
      "ja": "[BCP195] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、2015年5月、<https://www.rfc-editor.org/info/bcp195>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4514] Zeilenga, K., Ed., \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\", RFC 4514, DOI 10.17487/RFC4514, June 2006, <https://www.rfc-editor.org/info/rfc4514>.",
      "ja": "[RFC4514] Zeilenga、K。、編、「ライトウェイトディレクトリアクセスプロトコル（LDAP）：識別名の文字列表現」、RFC 4514、DOI 10.17487 / RFC4514、2006年6月、<https://www.rfc-editor.org / info / rfc4514>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D。、編、「The OAuth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, DOI 10.17487/RFC6750, October 2012, <https://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M。およびD.ハート、「OAuth 2.0 Authorization Framework：Bearer Token Usage」、RFC 6750、DOI 10.17487 / RFC6750、2012年10月、<https://www.rfc-editor.org/info/ rfc6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <https://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M。、「JSON Web Key（JWK）」、RFC 7517、DOI 10.17487 / RFC7517、2015年5月、<https://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <https://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519]ジョーンズ、M。、ブラッドリー、J.、N。崎村、「JSON Web Token（JWT）」、RFC 7519、DOI 10.17487 / RFC7519、2015年5月、<https://www.rfc-editor.org / info / rfc7519>。"
    },
    {
      "indent": 3,
      "text": "[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\", RFC 7591, DOI 10.17487/RFC7591, July 2015, <https://www.rfc-editor.org/info/rfc7591>.",
      "ja": "[RFC7591] Richer、J.、Ed。、Jones、M.、Bradley、J.、Machulak、M。、およびP. Hunt、「OAuth 2.0 Dynamic Client Registration Protocol」、RFC 7591、DOI 10.17487 / RFC7591、2015年7月、<https://www.rfc-editor.org/info/rfc7591>。"
    },
    {
      "indent": 3,
      "text": "[RFC7662] Richer, J., Ed., \"OAuth 2.0 Token Introspection\", RFC 7662, DOI 10.17487/RFC7662, October 2015, <https://www.rfc-editor.org/info/rfc7662>.",
      "ja": "[RFC7662] Richer、J。、編、「OAuth 2.0トークンイントロスペクション」、RFC 7662、DOI 10.17487 / RFC7662、2015年10月、<https://www.rfc-editor.org/info/rfc7662>。"
    },
    {
      "indent": 3,
      "text": "[RFC7800] Jones, M., Bradley, J., and H. Tschofenig, \"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\", RFC 7800, DOI 10.17487/RFC7800, April 2016, <https://www.rfc-editor.org/info/rfc7800>.",
      "ja": "[RFC7800] Jones、M.、Bradley、J。、およびH. Tschofenig、「Proof-of-Possession Key Semantics for JSON Web Tokens（JWTs）」、RFC 7800、DOI 10.17487 / RFC7800、2016年4月、<https：/ /www.rfc-editor.org/info/rfc7800>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8414] Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0 Authorization Server Metadata\", RFC 8414, DOI 10.17487/RFC8414, June 2018, <https://www.rfc-editor.org/info/rfc8414>.",
      "ja": "[RFC8414] Jones、M.、Sakimura、N.、J。Bradley、「OAuth 2.0 Authorization Server Metadata」、RFC 8414、DOI 10.17487 / RFC8414、2018年6月、<https://www.rfc-editor.org/ info / rfc8414>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[SHS] National Institute of Standards and Technology (NIST), \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, August 2015, <https://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[SHS]米国国立標準技術研究所（NIST）、「Secure Hash Standard（SHS）」、FIPS PUB 180-4、DOI 10.6028 / NIST.FIPS.180-4、2015年8月、<https：//nvlpubs.nist .gov / nistpubs / FIPS / NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[X690] ITU-T, \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, August 2015.",
      "ja": "[X690] ITU-T、「Information Technology-ASN.1 encoding rules：Specification of Basic Encoding Rules（BER）、Canonical Encoding Rules（CER）and Distinguished Encoding Rules（DER）」、ITU-T Recommendation X.690、August 2015。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CX5P] Wong, D., \"Common x509 certificate validation/creation pitfalls\", September 2016, <https://www.cryptologie.net/article/374/common-x509- certificate-validationcreation-pitfalls>.",
      "ja": "[CX5P] Wong、D。、「一般的なx509証明書の検証/作成の落とし穴」、2016年9月、<https://www.cryptologie.net/article/374/common-x509- certificate-validationcreation-pitfalls>。"
    },
    {
      "indent": 3,
      "text": "[DCW] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, \"The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software\", DOI 10.1145/2382196.2382204, October 2012, <http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>.",
      "ja": "[DCW] Georgiev、M.、Iyengar、S.、Jana、S.、Anubhai、R.、Boneh、D。、およびV. Shmatikov、「世界で最も危険なコード：非ブラウザソフトウェアでのSSL証明書の検証\"、DOI 10.1145 / 2382196.2382204、2012年10月、<http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IANA.JWT.Claims] IANA, \"JSON Web Token Claims\", <https://www.iana.org/assignments/jwt>.",
      "ja": "[IANA.JWT.Claims] IANA、「JSON Web Token Claims」、<https://www.iana.org/assignments/jwt>。"
    },
    {
      "indent": 3,
      "text": "[IANA.OAuth.Parameters] IANA, \"OAuth Parameters\", <https://www.iana.org/assignments/oauth-parameters>.",
      "ja": "[IANA.OAuth.Parameters] IANA、「OAuthパラメータ」、<https://www.iana.org/assignments/oauth-parameters>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.CIBA] Fernandez, G., Walter, F., Nennker, A., Tonge, D., and B. Campbell, \"OpenID Connect Client Initiated Backchannel Authentication Flow - Core 1.0\", 16 January 2019, <https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>.",
      "ja": "[OpenID.CIBA] Fernandez、G.、Walter、F.、Nennnker、A.、Tonge、D。、およびB. Campbell、「OpenID Connect Client Initiated Backchannel Authentication Flow-Core 1.0」、2019年1月16日、<https： //openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC4517] Legg, S., Ed., \"Lightweight Directory Access Protocol (LDAP): Syntaxes and Matching Rules\", RFC 4517, DOI 10.17487/RFC4517, June 2006, <https://www.rfc-editor.org/info/rfc4517>.",
      "ja": "[RFC4517] Legg、S。、編、「Lightweight Directory Access Protocol（LDAP）：Syntaxes and Matching Rules」、RFC 4517、DOI 10.17487 / RFC4517、2006年6月、<https://www.rfc-editor.org/ info / rfc4517>。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, DOI 10.17487/RFC5952, August 2010, <https://www.rfc-editor.org/info/rfc5952>.",
      "ja": "[RFC5952] Kawamura、S. and M. Kawashima、 \"A Recommendation for IPv6 Address Text Representation\"、RFC 5952、DOI 10.17487 / RFC5952、August 2010、<https://www.rfc-editor.org/info/rfc5952> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <https://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<https://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7009] Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"OAuth 2.0 Token Revocation\", RFC 7009, DOI 10.17487/RFC7009, August 2013, <https://www.rfc-editor.org/info/rfc7009>.",
      "ja": "[RFC7009] Lodderstedt、T.、Ed。、Dronia、S。、およびM. Scurtescu、「OAuth 2.0トークンの取り消し」、RFC 7009、DOI 10.17487 / RFC7009、2013年8月、<https：//www.rfc-editor。 org / info / rfc7009>。"
    },
    {
      "indent": 3,
      "text": "[RFC7518] Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518, DOI 10.17487/RFC7518, May 2015, <https://www.rfc-editor.org/info/rfc7518>.",
      "ja": "[RFC7518]ジョーンズ、M。、「JSON Web Algorithms（JWA）」、RFC 7518、DOI 10.17487 / RFC7518、2015年5月、<https://www.rfc-editor.org/info/rfc7518>。"
    },
    {
      "indent": 3,
      "text": "[TOKEN] Jones, M., Campbell, B., Bradley, J., and W. Denniss, \"OAuth 2.0 Token Binding\", Work in Progress, Internet-Draft, draft-ietf-oauth-token-binding-08, 19 October 2018, <https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>.",
      "ja": "[トークン]ジョーンズ、M。、キャンベル、B。、ブラッドリー、J。、およびW.デニス、「OAuth 2.0トークンバインディング」、Work in Progress、Internet-Draft、draft-ietf-oauth-token-binding-08、 2018年10月19日、<https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example \"cnf\" Claim, Certificate, and JWK",
      "ja": "付録A.「cnf」クレーム、証明書、およびJWKの例"
    },
    {
      "indent": 3,
      "text": "For reference, an \"x5t#S256\" value and the X.509 certificate from which it was calculated are provided in the following examples, Figures 5 and 6, respectively. A JWK representation of the certificate's public key along with the \"x5c\" member is also provided in Figure 7.",
      "ja": "参考のために、「x5t＃S256」の値と、それを計算したX.509証明書を、以下の例である図5と6にそれぞれ示します。証明書の公開鍵のJWK表現と「x5c」メンバーも図7に示されています。"
    },
    {
      "indent": 3,
      "text": "\"cnf\":{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 5: x5t#S256 Confirmation Claim",
      "ja": "図5：x5t＃S256確認要求"
    },
    {
      "indent": 3,
      "text": "-----BEGIN CERTIFICATE-----\nMIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTAx\nODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGByqG\nSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZjjJ\n/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0EAwID\nSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2eXZOV\nbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\n-----END CERTIFICATE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 6: PEM Encoded Self-Signed Certificate",
      "ja": "図6：PEMエンコードされた自己署名証明書"
    },
    {
      "indent": 3,
      "text": "{\n \"kty\":\"EC\",\n \"x\":\"1yfLHCpXqFjxCeHHHMVDTcLscpb07KUxudBmOMn8C7Q\",\n \"y\":\"8_coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8\",\n \"crv\":\"P-256\",\n \"x5c\":[\n  \"MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTA\n   xODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGBy\n   qGSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZ\n   jjJ/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0E\n   AwIDSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2\n   eXZOVbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\"\n   ]\n }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 7: JSON Web Key",
      "ja": "図7：JSON Web Key"
    },
    {
      "indent": 0,
      "text": "Appendix B. Relationship to Token Binding",
      "section_title": true,
      "ja": "付録B.トークンバインディングとの関係"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 Token Binding [TOKEN] enables the application of Token Binding to the various artifacts and tokens employed throughout OAuth. That includes binding of an access token to a Token Binding key, which bears some similarities in motivation and design to the mutual-TLS client certificate-bound access tokens defined in this document. Both documents define what is often called a proof-of-possession security mechanism for access tokens, whereby a client must demonstrate possession of cryptographic keying material when accessing a protected resource. The details differ somewhat between the two documents but both have the authorization server bind the access token that it issues to an asymmetric key pair held by the client. The client then proves possession of the private key from that pair with respect to the TLS connection over which the protected resource is accessed.",
      "ja": "OAuth 2.0トークンバインディング[トークン]は、OAuth全体で使用されるさまざまなアーティファクトおよびトークンへのトークンバインディングの適用を可能にします。これには、アクセストークンのトークンバインディングキーへのバインディングが含まれます。これには、このドキュメントで定義されている相互TLSクライアント証明書にバインドされたアクセストークンに対する動機と設計にいくつかの類似点があります。どちらのドキュメントでも、アクセストークンの所持証明セキュリティメカニズムと呼ばれるものが定義されています。これにより、クライアントは、保護されたリソースにアクセスするときに暗号化キー情報の所持を示す必要があります。詳細は2つのドキュメント間で多少異なりますが、どちらも、認証サーバーが発行するアクセストークンを、クライアントが保持する非対称キーペアにバインドします。次に、クライアントは、保護されたリソースへのアクセスに使用されるTLS接続に関して、そのペアからの秘密鍵の所有を証明します。"
    },
    {
      "indent": 3,
      "text": "Token Binding uses bare keys that are generated on the client, which avoids many of the difficulties of creating, distributing, and managing certificates used in this specification. However, at the time of writing, Token Binding is fairly new, and there is relatively little support for it in available application development platforms and tooling. Until better support for the underlying core Token Binding specifications exists, practical implementations of OAuth 2.0 Token Binding are infeasible. Mutual TLS, on the other hand, has been around for some time and enjoys widespread support in web servers and development platforms. As a consequence, OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens can be built and deployed now using existing platforms and tools. In the future, the two specifications are likely to be deployed in parallel for solving similar problems in different environments. Authorization servers may even support both specifications simultaneously using different proof-of-possession mechanisms for tokens issued to different clients.",
      "ja": "トークンバインディングは、クライアントで生成されるベアキーを使用するため、この仕様で使用される証明書の作成、配布、および管理の多くの困難を回避できます。ただし、執筆時点では、トークンバインディングはかなり新しいものであり、利用可能なアプリケーション開発プラットフォームとツールでは、トークンバインディングのサポートはほとんどありません。基になるコアトークンバインディング仕様のサポートが改善されるまで、OAuth 2.0トークンバインディングの実用的な実装は不可能です。一方、相互TLSは以前から存在し、Webサーバーや開発プラットフォームで広くサポートされています。その結果、OAuth 2.0相互TLSクライアント認証と証明書バインドアクセストークンを構築し、既存のプラットフォームとツールを使用してデプロイできるようになりました。将来、2つの仕様は、異なる環境で同様の問題を解決するために並行して展開される可能性があります。承認サーバーは、異なるクライアントに発行されたトークンに対して異なる所有証明メカニズムを使用して、両方の仕様を同時にサポートすることもできます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Scott \"not Tomlinson\" Tomilson and Matt Peterson were involved in design and development work on a mutual-TLS OAuth client authentication implementation that predates this document. Experience and learning from that work informed some of the content of this document.",
      "ja": "スコット「トムリンソンではない」トミルソンとマットピーターソンは、このドキュメントより前の相互TLS OAuthクライアント認証実装の設計と開発に携わっていました。その作業からの経験と学習により、このドキュメントの内容の一部がわかりました。"
    },
    {
      "indent": 3,
      "text": "This specification was developed within the OAuth Working Group under the chairmanship of Hannes Tschofenig and Rifaat Shekh-Yusef with Eric Rescorla, Benjamin Kaduk, and Roman Danyliw serving as Security Area Directors. Additionally, the following individuals contributed ideas, feedback, and wording that helped shape this specification: Vittorio Bertocci, Sergey Beryozkin, Ralph Bragg, Sophie Bremer, Roman Danyliw, Vladimir Dzhuvinov, Samuel Erdtman, Evan Gilman, Leif Johansson, Michael Jones, Phil Hunt, Benjamin Kaduk, Takahiko Kawasaki, Sean Leonard, Kepeng Li, Neil Madden, James Manger, Jim Manico, Nov Matake, Sascha Preibisch, Eric Rescorla, Justin Richer, Vincent Roca, Filip Skokan, Dave Tonge, and Hannes Tschofenig.",
      "ja": "この仕様は、Hanes TschofenigとRifaat Shekh-Yusefの議長の下、OAuthワーキンググループ内で開発されました。EricRescorla、Benjamin Kaduk、Roman Danyliwがセキュリティエリアディレクターを務めています。さらに、次の個人がこの仕様を形作るのに役立つアイデア、フィードバック、文言を提供しました：ヴィットリオベルトッチ、セルゲイベリオズキン、ラルフブラッグ、ソフィーブレマー、ローマンダニーリュー、ウラジミールズビノフ、サミュエルエルトマン、エヴァンギルマン、レイフヨハンソン、マイケルジョーンズ、フィルハント、ベンジャミン・カドゥック、川崎貴彦、ショーン・レナ​​ード、ケペン・リー、ニール・マッデン、ジェームズ・マンガー、ジム・マニコ、ノヴ・マタケ、サシャ・プレビッシュ、エリック・レスコーラ、ジャスティン・リチャー、ヴィンセント・ロカ、フィリップ・スコカン、デイブ・トンゲ、そしてハンネス・ショフェニグ。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Campbell Ping Identity",
      "ja": "ブライアンキャンベルピンアイデンティティ"
    },
    {
      "indent": 3,
      "text": "Email: brian.d.campbell@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Bradley Yubico",
      "ja": "ジョンブラッドリーユビコ"
    },
    {
      "indent": 3,
      "text": "Email: ve7jtb@ve7jtb.com\nURI:   http://www.thread-safe.com/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nat Sakimura Nomura Research Institute",
      "ja": "崎村ナット野村総合研究所"
    },
    {
      "indent": 3,
      "text": "Email: n-sakimura@nri.co.jp\nURI:   https://nat.sakimura.org/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt YES.com AG",
      "ja": "Torsten Lodderstedt YES.com AG"
    },
    {
      "indent": 3,
      "text": "Email: torsten@lodderstedt.net",
      "raw": true,
      "ja": ""
    }
  ]
}