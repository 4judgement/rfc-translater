{
  "title": {
    "text": "RFC 8881 - Network File System (NFS) Version 4 Minor Version 1 Protocol",
    "ja": "RFC 8881 - ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1プロトコル"
  },
  "number": 8881,
  "created_at": "2021-03-24 00:59:07.377130+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    D. Noveck, Ed.\nRequest for Comments: 8881                                        NetApp\nObsoletes: 5661                                                 C. Lever\nCategory: Standards Track                                         ORACLE\nISSN: 2070-1721                                              August 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Network File System (NFS) Version 4 Minor Version 1 Protocol",
      "ja": "ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1プロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Network File System (NFS) version 4 minor version 1, including features retained from the base protocol (NFS version 4 minor version 0, which is specified in RFC 7530) and protocol extensions made subsequently. The later minor version has no dependencies on NFS version 4 minor version 0, and is considered a separate protocol.",
      "ja": "このドキュメントでは、基本プロトコル（RFC 7530で指定されているNFSバージョン4マイナーバージョン0）から保持されている機能を含む、ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1と、その後に作成されたプロトコル拡張機能について説明します。後のマイナーバージョンは、NFSバージョン4マイナーバージョン0に依存しません。また、別のプロトコルと見なされます。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 5661. It substantially revises the treatment of features relating to multi-server namespace, superseding the description of those features appearing in RFC 5661.",
      "ja": "この文書はRFC 5661を廃止します.RFC 5661に表示される機能の説明に置き換えられているマルチサーバーネームスペースに関連する機能の扱いを実質的に修正します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット規格のトラック文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8881.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/frfc8881で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（C）2020 IETFの信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、この文書の公開日に有効なIETF文書（https://truste.ietf.org/License-info）に関するBCP 78とIETF信頼の法的規定を受けています。この文書に関してあなたの権利と制限を説明するので、これらの文書を慎重に見直してください。この文書から抽出されたコードコンポーネントには、信頼法の法的規定のセクション4。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この文書には、2008年11月10日以前に公開されたIETF文書または公開されたIETFの貢献からの資料を含めることができます。この材料のいくつかの著作権を制御する人は、そのような材料の修正を許可する権利を信頼する権利を与えられなかった人物IETF標準の外部プロセス。そのような材料の著作権を制御する人から適切なライセンスを取得せずに、この文書はIETF規格プロセスの外で修正されていない可能性があり、それをフォーマットすること以外はIETF標準プロセスの外ではデリバティブ作品が作成されない可能性があります。RFCとしての出版物、または英語以外の言語に翻訳する。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Introduction to This Update\n  1.2.  The NFS Version 4 Minor Version 1 Protocol\n  1.3.  Requirements Language\n  1.4.  Scope of This Document\n  1.5.  NFSv4 Goals\n  1.6.  NFSv4.1 Goals\n  1.7.  General Definitions\n  1.8.  Overview of NFSv4.1 Features\n  1.9.  Differences from NFSv4.0\n2.  Core Infrastructure\n  2.1.  Introduction\n  2.2.  RPC and XDR\n  2.3.  COMPOUND and CB_COMPOUND\n  2.4.  Client Identifiers and Client Owners\n  2.5.  Server Owners\n  2.6.  Security Service Negotiation\n  2.7.  Minor Versioning\n  2.8.  Non-RPC-Based Security Services\n  2.9.  Transport Layers\n  2.10. Session\n3.  Protocol Constants and Data Types\n  3.1.  Basic Constants\n  3.2.  Basic Data Types\n  3.3.  Structured Data Types\n4.  Filehandles\n  4.1.  Obtaining the First Filehandle\n  4.2.  Filehandle Types\n  4.3.  One Method of Constructing a Volatile Filehandle\n  4.4.  Client Recovery from Filehandle Expiration\n5.  File Attributes\n  5.1.  REQUIRED Attributes\n  5.2.  RECOMMENDED Attributes\n  5.3.  Named Attributes\n  5.4.  Classification of Attributes\n  5.5.  Set-Only and Get-Only Attributes\n  5.6.  REQUIRED Attributes - List and Definition References\n  5.7.  RECOMMENDED Attributes - List and Definition References\n  5.8.  Attribute Definitions\n  5.9.  Interpreting owner and owner_group\n  5.10. Character Case Attributes\n  5.11. Directory Notification Attributes\n  5.12. pNFS Attribute Definitions\n  5.13. Retention Attributes\n6.  Access Control Attributes\n  6.1.  Goals\n  6.2.  File Attributes Discussion\n  6.3.  Common Methods\n  6.4.  Requirements\n7.  Single-Server Namespace\n  7.1.  Server Exports\n  7.2.  Browsing Exports\n  7.3.  Server Pseudo File System\n  7.4.  Multiple Roots\n  7.5.  Filehandle Volatility\n  7.6.  Exported Root\n  7.7.  Mount Point Crossing\n  7.8.  Security Policy and Namespace Presentation\n8.  State Management\n  8.1.  Client and Session ID\n  8.2.  Stateid Definition\n  8.3.  Lease Renewal\n  8.4.  Crash Recovery\n  8.5.  Server Revocation of Locks\n  8.6.  Short and Long Leases\n  8.7.  Clocks, Propagation Delay, and Calculating Lease Expiration\n  8.8.  Obsolete Locking Infrastructure from NFSv4.0\n9.  File Locking and Share Reservations\n  9.1.  Opens and Byte-Range Locks\n  9.2.  Lock Ranges\n  9.3.  Upgrading and Downgrading Locks\n  9.4.  Stateid Seqid Values and Byte-Range Locks\n  9.5.  Issues with Multiple Open-Owners\n  9.6.  Blocking Locks\n  9.7.  Share Reservations\n  9.8.  OPEN/CLOSE Operations\n  9.9.  Open Upgrade and Downgrade\n  9.10. Parallel OPENs\n  9.11. Reclaim of Open and Byte-Range Locks\n10. Client-Side Caching\n  10.1.  Performance Challenges for Client-Side Caching\n  10.2.  Delegation and Callbacks\n  10.3.  Data Caching\n  10.4.  Open Delegation\n  10.5.  Data Caching and Revocation\n  10.6.  Attribute Caching\n  10.7.  Data and Metadata Caching and Memory Mapped Files\n  10.8.  Name and Directory Caching without Directory Delegations\n  10.9.  Directory Delegations\n11. Multi-Server Namespace\n  11.1.  Terminology\n  11.2.  File System Location Attributes\n  11.3.  File System Presence or Absence\n  11.4.  Getting Attributes for an Absent File System\n  11.5.  Uses of File System Location Information\n  11.6.  Trunking without File System Location Information\n  11.7.  Users and Groups in a Multi-Server Namespace\n  11.8.  Additional Client-Side Considerations\n  11.9.  Overview of File Access Transitions\n  11.10. Effecting Network Endpoint Transitions\n  11.11. Effecting File System Transitions\n  11.12. Transferring State upon Migration\n  11.13. Client Responsibilities When Access Is Transitioned\n  11.14. Server Responsibilities Upon Migration\n  11.15. Effecting File System Referrals\n  11.16. The Attribute fs_locations\n  11.17. The Attribute fs_locations_info\n  11.18. The Attribute fs_status\n12. Parallel NFS (pNFS)\n  12.1.  Introduction\n  12.2.  pNFS Definitions\n  12.3.  pNFS Operations\n  12.4.  pNFS Attributes\n  12.5.  Layout Semantics\n  12.6.  pNFS Mechanics\n  12.7.  Recovery\n  12.8.  Metadata and Storage Device Roles\n  12.9.  Security Considerations for pNFS\n13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type\n  13.1.  Client ID and Session Considerations\n  13.2.  File Layout Definitions\n  13.3.  File Layout Data Types\n  13.4.  Interpreting the File Layout\n  13.5.  Data Server Multipathing\n  13.6.  Operations Sent to NFSv4.1 Data Servers\n  13.7.  COMMIT through Metadata Server\n  13.8.  The Layout Iomode\n  13.9.  Metadata and Data Server State Coordination\n  13.10. Data Server Component File Size\n  13.11. Layout Revocation and Fencing\n  13.12. Security Considerations for the File Layout Type\n14. Internationalization\n  14.1.  Stringprep Profile for the utf8str_cs Type\n  14.2.  Stringprep Profile for the utf8str_cis Type\n  14.3.  Stringprep Profile for the utf8str_mixed Type\n  14.4.  UTF-8 Capabilities\n  14.5.  UTF-8 Related Errors\n15. Error Values\n  15.1.  Error Definitions\n  15.2.  Operations and Their Valid Errors\n  15.3.  Callback Operations and Their Valid Errors\n  15.4.  Errors and the Operations That Use Them\n16. NFSv4.1 Procedures\n  16.1.  Procedure 0: NULL - No Operation\n  16.2.  Procedure 1: COMPOUND - Compound Operations\n17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL\n18. NFSv4.1 Operations\n  18.1.  Operation 3: ACCESS - Check Access Rights\n  18.2.  Operation 4: CLOSE - Close File\n  18.3.  Operation 5: COMMIT - Commit Cached Data\n  18.4.  Operation 6: CREATE - Create a Non-Regular File Object\n  18.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting\n          Recovery\n  18.6.  Operation 8: DELEGRETURN - Return Delegation\n  18.7.  Operation 9: GETATTR - Get Attributes\n  18.8.  Operation 10: GETFH - Get Current Filehandle\n  18.9.  Operation 11: LINK - Create Link to a File\n  18.10. Operation 12: LOCK - Create Lock\n  18.11. Operation 13: LOCKT - Test for Lock\n  18.12. Operation 14: LOCKU - Unlock File\n  18.13. Operation 15: LOOKUP - Lookup Filename\n  18.14. Operation 16: LOOKUPP - Lookup Parent Directory\n  18.15. Operation 17: NVERIFY - Verify Difference in Attributes\n  18.16. Operation 18: OPEN - Open a Regular File\n  18.17. Operation 19: OPENATTR - Open Named Attribute Directory\n  18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access\n  18.19. Operation 22: PUTFH - Set Current Filehandle\n  18.20. Operation 23: PUTPUBFH - Set Public Filehandle\n  18.21. Operation 24: PUTROOTFH - Set Root Filehandle\n  18.22. Operation 25: READ - Read from File\n  18.23. Operation 26: READDIR - Read Directory\n  18.24. Operation 27: READLINK - Read Symbolic Link\n  18.25. Operation 28: REMOVE - Remove File System Object\n  18.26. Operation 29: RENAME - Rename Directory Entry\n  18.27. Operation 31: RESTOREFH - Restore Saved Filehandle\n  18.28. Operation 32: SAVEFH - Save Current Filehandle\n  18.29. Operation 33: SECINFO - Obtain Available Security\n  18.30. Operation 34: SETATTR - Set Attributes\n  18.31. Operation 37: VERIFY - Verify Same Attributes\n  18.32. Operation 38: WRITE - Write to File\n  18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control\n  18.34. Operation 41: BIND_CONN_TO_SESSION - Associate Connection\n          with Session\n  18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID\n  18.36. Operation 43: CREATE_SESSION - Create New Session and\n          Confirm Client ID\n  18.37. Operation 44: DESTROY_SESSION - Destroy a Session\n  18.38. Operation 45: FREE_STATEID - Free Stateid with No Locks\n  18.39. Operation 46: GET_DIR_DELEGATION - Get a Directory\n          Delegation\n  18.40. Operation 47: GETDEVICEINFO - Get Device Information\n  18.41. Operation 48: GETDEVICELIST - Get All Device Mappings for\n          a File System\n  18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a\n          Layout\n  18.43. Operation 50: LAYOUTGET - Get Layout Information\n  18.44. Operation 51: LAYOUTRETURN - Release Layout Information\n  18.45. Operation 52: SECINFO_NO_NAME - Get Security on Unnamed\n          Object\n  18.46. Operation 53: SEQUENCE - Supply Per-Procedure Sequencing\n          and Control\n  18.47. Operation 54: SET_SSV - Update SSV for a Client ID\n  18.48. Operation 55: TEST_STATEID - Test Stateids for Validity\n  18.49. Operation 56: WANT_DELEGATION - Request Delegation\n  18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID\n  18.51. Operation 58: RECLAIM_COMPLETE - Indicates Reclaims\n          Finished\n  18.52. Operation 10044: ILLEGAL - Illegal Operation\n19. NFSv4.1 Callback Procedures\n  19.1.  Procedure 0: CB_NULL - No Operation\n  19.2.  Procedure 1: CB_COMPOUND - Compound Operations\n20. NFSv4.1 Callback Operations\n  20.1.  Operation 3: CB_GETATTR - Get Attributes\n  20.2.  Operation 4: CB_RECALL - Recall a Delegation\n  20.3.  Operation 5: CB_LAYOUTRECALL - Recall Layout from Client\n  20.4.  Operation 6: CB_NOTIFY - Notify Client of Directory\n          Changes\n  20.5.  Operation 7: CB_PUSH_DELEG - Offer Previously Requested\n          Delegation to Client\n  20.6.  Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects\n  20.7.  Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal Resources\n          for Recallable Objects\n  20.8.  Operation 10: CB_RECALL_SLOT - Change Flow Control Limits\n  20.9.  Operation 11: CB_SEQUENCE - Supply Backchannel Sequencing\n          and Control\n  20.10. Operation 12: CB_WANTS_CANCELLED - Cancel Pending\n          Delegation Wants\n  20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of Possible\n          Lock Availability\n  20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify Client of Device\n          ID Changes\n  20.13. Operation 10044: CB_ILLEGAL - Illegal Callback Operation\n21. Security Considerations\n22. IANA Considerations\n  22.1.  IANA Actions\n  22.2.  Named Attribute Definitions\n  22.3.  Device ID Notifications\n  22.4.  Object Recall Types\n  22.5.  Layout Types\n  22.6.  Path Variable Definitions\n23. References\n  23.1.  Normative References\n  23.2.  Informative References\nAppendix A.  The Need for This Update\nAppendix B.  Changes in This Update\n  B.1.  Revisions Made to Section 11 of RFC 5661\n  B.2.  Revisions Made to Operations in RFC 5661\n  B.3.  Revisions Made to Error Definitions in RFC 5661\n  B.4.  Other Revisions Made to RFC 5661\nAppendix C.  Security Issues That Need to Be Addressed\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Introduction to This Update",
      "section_title": true,
      "ja": "1.1. このアップデートの紹介"
    },
    {
      "indent": 3,
      "text": "Two important features previously defined in minor version 0 but never fully addressed in minor version 1 are trunking, which is the simultaneous use of multiple connections between a client and server, potentially to different network addresses, and Transparent State Migration, which allows a file system to be transferred between servers in a way that provides to the client the ability to maintain its existing locking state across the transfer.",
      "ja": "マイナーバージョン0で以前に定義されていた2つの重要な機能は、マイナーバージョン1で完全に扱われていません。これは、クライアントとサーバー間の複数の接続を同時に使用しています。クライアントに提供する方法でサーバー間で転送されます。"
    },
    {
      "indent": 3,
      "text": "The revised description of the NFS version 4 minor version 1 (NFSv4.1) protocol presented in this update is necessary to enable full use of these features together with other multi-server namespace features. This document is in the form of an updated description of the NFSv4.1 protocol previously defined in RFC 5661 [66]. RFC 5661 is obsoleted by this document. However, the update has a limited scope and is focused on enabling full use of trunking and Transparent State Migration. The need for these changes is discussed in Appendix A. Appendix B describes the specific changes made to arrive at the current text.",
      "ja": "このアップデートで提示されているNFSバージョン4マイナーバージョン1（NFSV4.1）プロトコルの改訂された説明は、これらの機能を他のマルチサーバーネームスペース機能と一緒に完全に使用できるようにする必要があります。このドキュメントは、RFC 5661 [66]で以前に定義されているNFSV4.1プロトコルの更新された説明の形式です。RFC 5661はこの文書によって廃止されています。ただし、このアップデートには限られた範囲があり、トランキングと透過状態の移行を最大限に活用することができます。これらの変更の必要性は付録Aで説明されています。付録Bは、現在のテキストに到着するように行われた特定の変更を示しています。"
    },
    {
      "indent": 3,
      "text": "This limited-scope update replaces the current NFSv4.1 RFC with the intention of providing an authoritative and complete specification, the motivation for which is discussed in [36], addressing the issues within the scope of the update. However, it will not address issues that are known but outside of this limited scope as could be expected by a full update of the protocol. Below are some areas that are known to need addressing in a future update of the protocol:",
      "ja": "この限られたスコープの更新は、現在のNFSV4.1 RFCを、正式で完全な仕様を提供することを意図して、[36]で説明されているモチベーションを更新の範囲内の問題に対処することを目的としています。ただし、プロトコルの完全な更新によって予想されるように、既知の問題に対処することはありません。以下は、将来のプロトコルの更新でアドレス指定が必要ないくつかの分野です。"
    },
    {
      "indent": 3,
      "text": "* Work needs to be done with regard to RFC 8178 [67], which establishes NFSv4-wide versioning rules. As RFC 5661 is currently inconsistent with that document, changes are needed in order to arrive at a situation in which there would be no need for RFC 8178 to update the NFSv4.1 specification.",
      "ja": "* NFSV4全体のバージョン管理規則を確立するRFC 8178 [67]に関して作業を行う必要があります。RFC 5661が現在その文書と矛盾しているので、RFC 8178がNFSV4.1の仕様を更新する必要がない状況に到着するために変更が必要です。"
    },
    {
      "indent": 3,
      "text": "* Work needs to be done with regard to RFC 8434 [70], which establishes the requirements for parallel NFS (pNFS) layout types, which are not clearly defined in RFC 5661. When that work is done and the resulting documents approved, the new NFSv4.1 specification document will provide a clear set of requirements for layout types and a description of the file layout type that conforms to those requirements. Other layout types will have their own specification documents that conform to those requirements as well.",
      "ja": "* RFC 8434 [70]に関しては、RFC 5661では明確に定義されていない並列NFS（PNFS）レイアウトタイプの要件が確立されるRFC 8434 [70]に関して行う必要があります。その作業が行われ、結果として得られる文書が新しいNFSV4.1仕様書は、レイアウトタイプのための明確な要件とそれらの要件に準拠したファイルレイアウト型の説明を提供します。他のレイアウトタイプには、それらの要件にも適合する独自の仕様書があります。"
    },
    {
      "indent": 3,
      "text": "* Work needs to be done to address many errata reports relevant to RFC 5661, other than errata report 2006 [64], which is addressed in this document. Addressing that report was not deferrable because of the interaction of the changes suggested there and the newly described handling of state and session migration.",
      "ja": "* このドキュメントで対処されているErrata Report 2006 [64]以外のRFC 5661に関連する多くのエラータレポートに対処するために、作業を行う必要があります。その変更の相互作用が推奨されていないことに対処し、そこに示唆された変更と、新しく説明された状態の移行とセッションの移行の取り扱いが延期されました。"
    },
    {
      "indent": 6,
      "text": "The errata reports that have been deferred and that will need to be addressed in a later document include reports currently assigned a range of statuses in the errata reporting system, including reports marked Accepted and those marked Hold For Document Update because the change was too minor to address immediately.",
      "ja": "後の文書で延期されているエラータレポートには、現在のものとマークされたレポートとドキュメントの更新のためのマークされたレポートなど、Erorataレポーティングシステムのステータスの範囲が割り当てられているレポートが含まれています。すぐにアドレス。"
    },
    {
      "indent": 6,
      "text": "In addition, there is a set of other reports, including at least one in state Rejected, that will need to be addressed in a later document. This will involve making changes to consensus decisions reflected in RFC 5661, in situations in which the working group has decided that the treatment in RFC 5661 is incorrect and needs to be revised to reflect the working group's new consensus and to ensure compatibility with existing implementations that do not follow the handling described in RFC 5661.",
      "ja": "さらに、少なくとも1つの状態を含む他のレポートのセットがあります。これにより、後の文書でアドレス指定する必要があります。これは、RFC 5661に反映されているコンセンサス決定を変更することを含み、ワーキンググループがRFC 5661の治療が正しくないと判断し、ワーキンググループの新しいコンセンサスを反映し、既存の実装との互換性を確保する必要がある状況では、RFC 5661に変更を加えることが含まれます。RFC 5661に記載されている取り扱いに従わないでください。"
    },
    {
      "indent": 6,
      "text": "Note that it is expected that all such errata reports will remain relevant to implementors and the authors of an eventual rfc5661bis, despite the fact that this document obsoletes RFC 5661 [66].",
      "ja": "この文書がRFC 5661を廃止されているという事実にもかかわらず、そのようなエラータレポートはすべて実装者および最終的なRFC5661BISの著者に関連したままになると予想されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "* There is a need for a new approach to the description of internationalization since the current internationalization section (Section 14) has never been implemented and does not meet the needs of the NFSv4 protocol. Possible solutions are to create a new internationalization section modeled on that in [68] or to create a new document describing internationalization for all NFSv4 minor versions and reference that document in the RFCs defining both NFSv4.0 and NFSv4.1.",
      "ja": "* 現在の国際化セクション（セクション14）が実装されたことがなく、NFSV4プロトコルのニーズを満たしていないため、国際化の説明への新しいアプローチが必要とされています。考えられる解決策は、[68]でモデル化された新しい国際化セクションを作成したり、すべてのNFSV4マイナーバージョンの国際化を説明し、NFSV4.0とNFSV4.1の両方を定義するRFCSの文書を参照してください。"
    },
    {
      "indent": 3,
      "text": "* There is a need for a revised treatment of security in NFSv4.1. The issues with the existing treatment are discussed in Appendix C.",
      "ja": "* NFSV4.1のセキュリティの修正治療が必要です。既存の治療の問題は付録Cで議論されています。"
    },
    {
      "indent": 3,
      "text": "Until the above work is done, there will not be a consistent set of documents that provides a description of the NFSv4.1 protocol, and any full description would involve documents updating other documents within the specification. The updates applied by RFC 8434 [70] and RFC 8178 [67] to RFC 5661 also apply to this specification, and will apply to any subsequent v4.1 specification until that work is done.",
      "ja": "上記の作業が行われるまで、NFSV4.1プロトコルの説明を提供する一貫した文書のセットはありません。また、詳細な説明は、仕様内の他の文書を更新する文書を含みます。RFC 8434 [70]とRFC 8178 [67]からRFC 5661に適用された更新プログラムは、この仕様にも適用され、その作業が行われるまでの任意の後続のV4.1仕様に適用されます。"
    },
    {
      "indent": 0,
      "text": "1.2. The NFS Version 4 Minor Version 1 Protocol",
      "section_title": true,
      "ja": "1.2. NFSバージョン4マイナーバージョン1プロトコル"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 minor version 1 (NFSv4.1) protocol is the second minor version of the NFS version 4 (NFSv4) protocol. The first minor version, NFSv4.0, is now described in RFC 7530 [68]. It generally follows the guidelines for minor versioning that are listed in Section 10 of RFC 3530 [37]. However, it diverges from guidelines 11 (\"a client and server that support minor version X must support minor versions 0 through X-1\") and 12 (\"no new features may be introduced as mandatory in a minor version\"). These divergences are due to the introduction of the sessions model for managing non-idempotent operations and the RECLAIM_COMPLETE operation. These two new features are infrastructural in nature and simplify implementation of existing and other new features. Making them anything but REQUIRED would add undue complexity to protocol definition and implementation. NFSv4.1 accordingly updates the minor versioning guidelines (Section 2.7).",
      "ja": "NFSバージョン4マイナーバージョン1（NFSV4.1）プロトコルは、NFSバージョン4（NFSV4）プロトコルの2番目のマイナーバージョンです。最初のマイナーバージョンNFSV4.0は、RFC 7530 [68]で説明されています。それは一般的にRFC 3530のセクション10にリストされているマイナーバージョン管理のガイドラインに従います。ただし、ガイドライン11（「マイナーバージョンXをサポートするクライアントとサーバーは、マイナーバージョン0からX-1」をサポートしている必要があります）と12（マイナーバージョンでは必須の新しい機能は導入されない可能性があります）から分岐します。これらの分岐は、非イデボータ操作操作およびRECLAIM_COMPLETE操作を管理するためのセッションモデルの導入によるものです。これら2つの新機能は、本質的にインフラストラクチャーであり、既存およびその他の新機能の実装を簡素化しています。必要があるが必要とされるが、プロトコルの定義および実装に過度の複雑さを追加するであろう。NFSV4.1により、マイナーバージョン管理ガイドラインを更新します（セクション2.7）。"
    },
    {
      "indent": 3,
      "text": "As a minor version, NFSv4.1 is consistent with the overall goals for NFSv4, but extends the protocol so as to better meet those goals, based on experiences with NFSv4.0. In addition, NFSv4.1 has adopted some additional goals, which motivate some of the major extensions in NFSv4.1.",
      "ja": "マイナーバージョンとして、NFSV4.1はNFSV4の全体的な目標と一致していますが、NFSv4.0の経験に基づいてこれらの目標をよりよく満たすようにプロトコルを拡張します。さらに、NFSV4.1はいくつかの追加の目標を採用しており、これはNFSV4.1の主要な拡張機能をいくつか動かす。"
    },
    {
      "indent": 0,
      "text": "1.3. Requirements Language",
      "section_title": true,
      "ja": "1.3. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "「必須」、「必須」、「必要ではない」、「しない」、「推奨する」、「推奨する」、「5月」、および「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、RFC 2119 [1]に記載されているように解釈されること。"
    },
    {
      "indent": 0,
      "text": "1.4. Scope of This Document",
      "section_title": true,
      "ja": "1.4. この文書の範囲"
    },
    {
      "indent": 3,
      "text": "This document describes the NFSv4.1 protocol. With respect to NFSv4.0, this document does not:",
      "ja": "このドキュメントでは、NFSV4.1プロトコルについて説明します。NFSV4.0に関しては、この文書は次のことはありません。"
    },
    {
      "indent": 3,
      "text": "* describe the NFSv4.0 protocol, except where needed to contrast with NFSv4.1.",
      "ja": "* NFSV4.1とは対照的に必要な場合を除き、NFSV4.0プロトコルを説明します。"
    },
    {
      "indent": 3,
      "text": "* modify the specification of the NFSv4.0 protocol.",
      "ja": "* NFSv4.0プロトコルの指定を変更します。"
    },
    {
      "indent": 3,
      "text": "* clarify the NFSv4.0 protocol.",
      "ja": "* NFSV4.0プロトコルを明確にします。"
    },
    {
      "indent": 0,
      "text": "1.5. NFSv4 Goals",
      "section_title": true,
      "ja": "1.5. NFSV4目標"
    },
    {
      "indent": 3,
      "text": "The NFSv4 protocol is a further revision of the NFS protocol defined already by NFSv3 [38]. It retains the essential characteristics of previous versions: easy recovery; independence of transport protocols, operating systems, and file systems; simplicity; and good performance. NFSv4 has the following goals:",
      "ja": "NFSV4プロトコルは、NFSV3 [38]で既に定義されているNFSプロトコルのさらなるリビジョンです。それは以前のバージョンの本質的な特徴を保持します：簡単な回復。トランスポートプロトコル、オペレーティングシステム、およびファイルシステムの独立性。シンプルさ。そして良いパフォーマンス。NFSV4には次の目標があります。"
    },
    {
      "indent": 3,
      "text": "* Improved access and good performance on the Internet",
      "ja": "* インターネット上のアクセスと良好なパフォーマンスが向上しました"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.",
      "ja": "プロトコルはファイアウォールを簡単にトランジットするように設計されており、待ち時間が高く、帯域幅が低く、サーバーごとに非常に多数のクライアントにスケールを実行します。"
    },
    {
      "indent": 3,
      "text": "* Strong security with negotiation built into the protocol",
      "ja": "* 議定書に組み込まれた交渉による強力なセキュリティ"
    },
    {
      "indent": 6,
      "text": "The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFSv4.1 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.",
      "ja": "プロトコルは、RPCSEC_GSSプロトコルをサポートする際のONCRPCワーキンググループの作業に構築されています。さらに、NFSV4.1プロトコルは、クライアントとサーバーをセキュリティにネゴシエートする機能を許可し、クライアントやサーバーがセキュリティスキームのセットをサポートする能力を要求するメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "* Good cross-platform interoperability",
      "ja": "* 良いクロスプラットフォームの相互運用性"
    },
    {
      "indent": 6,
      "text": "The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.",
      "ja": "プロトコルは、別のファイルシステムまたはオペレーティングシステムを過度に有利にしない、有用な共通の機能を提供するファイルシステムモデルを備えています。"
    },
    {
      "indent": 3,
      "text": "* Designed for protocol extensions",
      "ja": "* プロトコル拡張用に設計されています"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to accept standard extensions within a framework that enables and encourages backward compatibility.",
      "ja": "このプロトコルは、下位互換性を可能にし、促進するフレームワーク内の標準的な拡張機能を受け入れるように設計されています。"
    },
    {
      "indent": 0,
      "text": "1.6. NFSv4.1 Goals",
      "section_title": true,
      "ja": "1.6. NFSV4.1目標"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 has the following goals, within the framework established by the overall NFSv4 goals.",
      "ja": "NFSV4.1は、NFSV4全体の目標によって確立されたフレームワーク内で、次の目標を持ちます。"
    },
    {
      "indent": 3,
      "text": "* To correct significant structural weaknesses and oversights discovered in the base protocol.",
      "ja": "* 基本プロトコルで発見されたかなりの構造的弱点と監視を修正するため。"
    },
    {
      "indent": 3,
      "text": "* To add clarity and specificity to areas left unaddressed or not addressed in sufficient detail in the base protocol. However, as stated in Section 1.4, it is not a goal to clarify the NFSv4.0 protocol in the NFSv4.1 specification.",
      "ja": "* ベースプロトコルでは十分な詳細で埋め込まれていないか、または対処されていない領域に明確さと特異性を追加する。ただし、セクション1.4に記載されているように、NFSV4.1仕様でNFSV4.0プロトコルを明確にすることは目標ではありません。"
    },
    {
      "indent": 3,
      "text": "* To add specific features based on experience with the existing protocol and recent industry developments.",
      "ja": "* 既存のプロトコルと最近の業界の開発の経験に基づいて特定の機能を追加する。"
    },
    {
      "indent": 3,
      "text": "* To provide protocol support to take advantage of clustered server deployments including the ability to provide scalable parallel access to files distributed among multiple servers.",
      "ja": "* プロトコルサポートを提供するには、複数のサーバー間で分散されたファイルへのスケーラブルな並列アクセスを提供する機能を含む、クラスタ化されたサーバーの展開を提供すること。"
    },
    {
      "indent": 0,
      "text": "1.7. General Definitions",
      "section_title": true,
      "ja": "1.7. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "The following definitions provide an appropriate context for the reader.",
      "ja": "次の定義は、リーダーの適切なコンテキストを提供します。"
    },
    {
      "indent": 3,
      "text": "Byte: In this document, a byte is an octet, i.e., a datum exactly 8 bits in length.",
      "ja": "バイト：この文書では、バイトはオクテット、すなわち長さが正確に8ビットのデータです。"
    },
    {
      "indent": 3,
      "text": "Client: The client is the entity that accesses the NFS server's resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.",
      "ja": "クライアント：クライアントは、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバに直接アクセスするためのロジックを含むアプリケーションであり得る。クライアントは、一連のアプリケーション用のリモートファイルシステムサービスを提供する従来のオペレーティングシステムクライアントでもあり得る。"
    },
    {
      "indent": 6,
      "text": "A client is uniquely identified by a client owner.",
      "ja": "クライアントはクライアントの所有者によって一意に識別されます。"
    },
    {
      "indent": 6,
      "text": "With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.",
      "ja": "バイトレンジロックを参照して、クライアントは1つ以上のアプリケーションに代わって一連のロックを維持するエンティティです。このクライアントは、それが管理するロックのクラッシュまたは障害回復を担当します。"
    },
    {
      "indent": 6,
      "text": "Note that multiple clients may share the same transport and connection and multiple clients may exist on the same network node.",
      "ja": "複数のクライアントが同じトランスポートを共有し、接続が同じネットワークノード上に複数のクライアントが存在する可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Client ID: The client ID is a 64-bit quantity used as a unique, short-hand reference to a client-supplied verifier and client owner. The server is responsible for supplying the client ID.",
      "ja": "クライアントID：クライアントIDは、クライアント提供の検証者およびクライアントの所有者への一意のショリュンド参照として使用される64ビット数量です。サーバーはクライアントIDを提供する責任があります。"
    },
    {
      "indent": 3,
      "text": "Client Owner: The client owner is a unique string, opaque to the server, that identifies a client. Multiple network connections and source network addresses originating from those connections may share a client owner. The server is expected to treat requests from connections with the same client owner as coming from the same client.",
      "ja": "クライアント所有者：クライアントの所有者は、クライアントを識別する、サーバーへの不透明な一意の文字列です。これらの接続から発生した複数のネットワーク接続とソースネットワークアドレスは、クライアントの所有者を共有することがあります。サーバーは、同じクライアントからの同じクライアント所有者との接続からの要求を扱うことが期待されています。"
    },
    {
      "indent": 3,
      "text": "File System: The file system is the collection of objects on a server (as identified by the major identifier of a server owner, which is defined later in this section) that share the same fsid attribute (see Section 5.8.1.9).",
      "ja": "ファイルシステム：ファイルシステムは、同じFSID属性を共有するサーバー上のオブジェクトのコレクションです（サーバー所有者の主要な識別子によって識別されます。）"
    },
    {
      "indent": 3,
      "text": "Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted locks. At the end of a lease period, locks may be revoked if the lease has not been extended. A lock must be revoked if a conflicting lock has been granted after the lease interval.",
      "ja": "リース：リースは、クライアントが取り消されたロックが付与されているサーバーによって定義された時間の間隔です。リース期間の終わりに、リースが拡張されていない場合はロックが取り消される可能性があります。リース間隔の後に競合するロックが付与されている場合は、ロックを取り消す必要があります。"
    },
    {
      "indent": 6,
      "text": "A server grants a client a single lease for all state.",
      "ja": "サーバーはクライアントをすべての状態に1回のリースに付与します。"
    },
    {
      "indent": 3,
      "text": "Lock: The term \"lock\" is used to refer to byte-range (in UNIX environments, also known as record) locks, share reservations, delegations, or layouts unless specifically stated otherwise.",
      "ja": "ロック：「ロック」という用語はバイト範囲（UNIX環境でもレコードとしても呼ばれる）ロック、特に述べられていない限り、予約、委任、またはレイアウトを共有するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Secret State Verifier (SSV): The SSV is a unique secret key shared between a client and server. The SSV serves as the secret key for an internal (that is, internal to NFSv4.1) Generic Security Services (GSS) mechanism (the SSV GSS mechanism; see Section 2.10.9). The SSV GSS mechanism uses the SSV to compute message integrity code (MIC) and Wrap tokens. See Section 2.10.8.3 for more details on how NFSv4.1 uses the SSV and the SSV GSS mechanism.",
      "ja": "Secret State Verifier（SSV）：SSVはクライアントとサーバー間で共有されている一意の秘密鍵です。SSVは、内部（つまり、NFSV4.1の内部にある）Generic Security Services（GSS）メカニズム（SSV GSSメカニズム）の秘密鍵として機能します（SSV GSSメカニズム; 2.10.9を参照）。SSV GSSメカニズムはSSVを使用してメッセージ整合性コード（MIC）とラップトークンを計算します。NFSv4.1のSSVとSSV GSSメカニズムの使用方法の詳細については、2.10.8.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Server: The Server is the entity responsible for coordinating client access to a set of file systems and is identified by a server owner. A server can span multiple network addresses.",
      "ja": "サーバー：サーバーは、一連のファイルシステムへのクライアントアクセスを調整する責任があるエンティティであり、サーバーの所有者によって識別されます。サーバーは複数のネットワークアドレスにまたがることができます。"
    },
    {
      "indent": 3,
      "text": "Server Owner: The server owner identifies the server to the client. The server owner consists of a major identifier and a minor identifier. When the client has two connections each to a peer with the same major identifier, the client assumes that both peers are the same server (the server namespace is the same via each connection) and that lock state is shareable across both connections. When each peer has both the same major and minor identifiers, the client assumes that each connection might be associable with the same session.",
      "ja": "サーバー所有者：サーバーの所有者はサーバーをクライアントに識別します。サーバーの所有者は、メジャー識別子とマイナー識別子で構成されています。クライアントが同じメジャー識別子を持つピアに2つの接続を持つ場合、クライアントは両方のピアが同じサーバーであると仮定します（サーバーネームスペースは各接続を介して同じです）、両方の接続で共有可能です。各ピアに同じメジャー識別子とマイナー識別子の両方がある場合、クライアントは各接続が同じセッションと関連性があると見なします。"
    },
    {
      "indent": 3,
      "text": "Stable Storage: Stable storage is storage from which data stored by an NFSv4.1 server can be recovered without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and/or hardware failure of components other than the storage medium itself (such as disk, nonvolatile RAM, flash memory, etc.).",
      "ja": "安定したストレージ：安定したストレージは、複数の電源障害（カスケード能力の障害、すなわち迅速な累進のいくつかの電力障害を含む）、オペレーティングシステムの障害、および/ /記憶媒体自体（ディスク、不揮発性RAM、フラッシュメモリなど）以外のコンポーネントのハードウェア障害。"
    },
    {
      "indent": 6,
      "text": "Some examples of stable storage that are allowable for an NFS server include:",
      "ja": "NFSサーバーに許容される安定したストレージの例としては、次のものがあります。"
    },
    {
      "indent": 6,
      "text": "1. Media commit of data; that is, the modified data has been successfully written to the disk media, for example, the disk platter.",
      "ja": "1. データのメディアコミット。すなわち、修正されたデータは、ディスク媒体、例えばディスクプラッタに正常に書き込まれてきた。"
    },
    {
      "indent": 6,
      "text": "2. An immediate reply disk drive with battery-backed, on-drive intermediate storage or uninterruptible power system (UPS).",
      "ja": "2. バッテリバックドドライブ中間ストレージまたは無停電電力システム（UPS）を備えた即時返信ディスクドライブ。"
    },
    {
      "indent": 6,
      "text": "3. Server commit of data with battery-backed intermediate storage and recovery software.",
      "ja": "3. バッテリバックアップ中間記憶域および回復ソフトウェアを持つデータのサーバー。"
    },
    {
      "indent": 6,
      "text": "4. Cache commit with uninterruptible power system (UPS) and recovery software.",
      "ja": "4. 無停電電源システム（UPS）および回復ソフトウェアを使用してキャッシュをコミットします。"
    },
    {
      "indent": 3,
      "text": "Stateid: A stateid is a 128-bit quantity returned by a server that uniquely defines the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.",
      "ja": "StateID：StateIDは、特定のファイルとロックの種類の特定のファイルとロック所有者/オープンオーナーのペアに対して、サーバーによって提供されたオープン状態とロック状態を一意に定義するサーバーによって返される128ビット数です。"
    },
    {
      "indent": 3,
      "text": "Verifier: A verifier is a 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.",
      "ja": "検証者：検証者は、クライアントが使用できるクライアントによって生成された64ビット数量で、クライアントが再起動し、以前のすべてのロック状態を失ったかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "1.8. Overview of NFSv4.1 Features",
      "section_title": true,
      "ja": "1.8. NFSV4.1機能の概要"
    },
    {
      "indent": 3,
      "text": "The major features of the NFSv4.1 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader who is new to the NFS protocols. For the reader new to the NFS protocols, there is still a set of fundamental knowledge that is expected. The reader should be familiar with the External Data Representation (XDR) and Remote Procedure Call (RPC) protocols as described in [2] and [3]. A basic knowledge of file systems and distributed file systems is expected as well.",
      "ja": "NFSV4.1プロトコルの主な機能は簡単に検討されます。これは、以前のバージョンのNFSプロトコルとNFSプロトコルに新しいリーダーに精通しているリーダーの両方に適切なコンテキストを提供するために行われます。NFSプロトコルの新機能のために、予想される基本的な知識のセットがまだあります。[2]と[3]に記載されているように、リーダーは外部データ表現（XDR）およびリモートプロシージャコール（RPC）プロトコルに精通している必要があります。ファイルシステムと分散ファイルシステムの基本的な知識も期待されています。"
    },
    {
      "indent": 3,
      "text": "In general, this specification of NFSv4.1 will not distinguish those features added in minor version 1 from those present in the base protocol but will treat NFSv4.1 as a unified whole. See Section 1.9 for a summary of the differences between NFSv4.0 and NFSv4.1.",
      "ja": "一般に、NFSV4.1のこの仕様は、マイナーバージョン1で追加されたものをベースプロトコルにあるものから区別することはできませんが、NFSV4.1を統一された全体として扱います。NFSV4.0とNFSV4.1の違いの概要については、セクション1.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.8.1. RPC and Security",
      "section_title": true,
      "ja": "1.8.1. RPCとセキュリティ"
    },
    {
      "indent": 3,
      "text": "As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFSv4.1 protocol are those defined in [2] and [3]. To meet end-to-end security requirements, the RPCSEC_GSS framework [4] is used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFSv4 protocol. Kerberos V5 is used as described in [5] to provide one security framework. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4.1 security.",
      "ja": "以前のバージョンのNFSと同様に、NFSv4.1プロトコルに使用される外部データ表現（XDR）およびリモートプロシージャコール（RPC）メカニズムは、[2]と[3]で定義されているものです。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク[4]は基本的なRPCセキュリティを拡張するために使用されます。RPCSEC_GSSを使用すると、NFSV4プロトコルに対する認証、整合性、およびプライバシーを提供するためにさまざまなメカニズムを提供できます。Kerberos V5は[5]で説明されているように使用して、1つのセキュリティフレームワークを提供します。RPCSEC_GSSを使用すると、他のメカニズムも指定し、NFSV4.1セキュリティに使用することができます。"
    },
    {
      "indent": 3,
      "text": "To enable in-band security negotiation, the NFSv4.1 protocol has operations that provide the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server's file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.",
      "ja": "インバンドセキュリティネゴシエーションを有効にするために、NFSV4.1プロトコルは、クライアントにサーバーのファイルシステムリソースへのアクセスにどのセキュリティメカニズムを使用する必要があるかに関するポリシーについてサーバーに照会する方法を提供する操作があります。これにより、クライアントはクライアントとサーバの両方で指定されたポリシーを満たすセキュリティメカニズムを安全に一致させることができる。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces parallel access (see Section 1.8.2.2), which is called pNFS. The security framework described in this section is significantly modified by the introduction of pNFS (see Section 12.9), because data access is sometimes not over RPC. The level of significance varies with the storage protocol (see Section 12.2.5) and can be as low as zero impact (see Section 13.12).",
      "ja": "NFSV4.1では、PNFSと呼ばれる並列アクセス（1.8.2.2項を参照）を紹介します。このセクションで説明されているセキュリティフレームワークは、データアクセスがRPCを越えない場合があるため、PNFSの導入によって大幅に変更されています（セクション12.9を参照）。有意水準はストレージプロトコルによって異なります（セクション12.2.5を参照）、ゼロの影響が遅くなる可能性があります（セクション13.12を参照）。"
    },
    {
      "indent": 0,
      "text": "1.8.2. Protocol Structure",
      "section_title": true,
      "ja": "1.8.2. プロトコル構造"
    },
    {
      "indent": 0,
      "text": "1.8.2.1. Core Protocol",
      "section_title": true,
      "ja": "1.8.2.1. コアプロトコル"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, which used a series of ancillary protocols (e.g., NLM, NSM (Network Status Monitor), MOUNT), within all minor versions of NFSv4 a single RPC protocol is used to make requests to the server. Facilities that had been separate protocols, such as locking, are now integrated within a single unified protocol.",
      "ja": "NFSv3の一連の補助プロトコル（例えば、NLM、NSM（ネットワークステータスモニタ）、マウント）を使用したNFSV3とは異なり、NFSV4のすべてのマイナーバージョン内で、サーバーへの要求を行うために使用されます。ロックなどの別々のプロトコルであった機能は、単一の統合プロトコル内に統合されています。"
    },
    {
      "indent": 0,
      "text": "1.8.2.2. Parallel Access",
      "section_title": true,
      "ja": "1.8.2.2. 並行アクセス"
    },
    {
      "indent": 3,
      "text": "Minor version 1 supports high-performance data access to a clustered server implementation by enabling a separation of metadata access and data access, with the latter done to multiple servers in parallel.",
      "ja": "マイナーバージョン1は、後者が複数のサーバーに並列に行われた状態で、メタデータアクセスとデータアクセスの分離を有効にすることによって、クラスタ化されたサーバー実装への高性能データアクセスをサポートします。"
    },
    {
      "indent": 3,
      "text": "Such parallel data access is controlled by recallable objects known as \"layouts\", which are integrated into the protocol locking model. Clients direct requests for data access to a set of data servers specified by the layout via a data storage protocol which may be NFSv4.1 or may be another protocol.",
      "ja": "そのような並列データアクセスは、プロトコルロックモデルに統合されている「レイアウト」として知られるリコール可能なオブジェクトによって制御される。クライアントは、NFSV4.1であり得るデータストレージプロトコルを介してレイアウトによって指定された一連のデータサーバへのデータアクセスに対する要求を直接要求する。"
    },
    {
      "indent": 3,
      "text": "Because the protocols used for parallel data access are not necessarily RPC-based, the RPC-based security model (Section 1.8.1) is obviously impacted (see Section 12.9). The degree of impact varies with the storage protocol (see Section 12.2.5) used for data access, and can be as low as zero (see Section 13.12).",
      "ja": "並列データアクセスに使用されるプロトコルは必ずしもRPCベースではないため、RPCベースのセキュリティモデル（セクション1.8.1）は明らかに影響を受けます（セクション12.9を参照）。影響の程度は、データアクセスに使用されるストレージプロトコル（セクション12.2.5を参照）によって異なり、ゼロの低くなることがあります（セクション13.12を参照）。"
    },
    {
      "indent": 0,
      "text": "1.8.3. File System Model",
      "section_title": true,
      "ja": "1.8.3. ファイルシステムモデル"
    },
    {
      "indent": 3,
      "text": "The general file system model used for the NFSv4.1 protocol is the same as previous versions. The server file system is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.",
      "ja": "NFSV4.1プロトコルに使用される一般ファイルシステムモデルは以前のバージョンと同じです。サーバーファイルシステムは、不透明バイトストリームとして扱われている通常のファイルと階層的です。わずかな出発時に、ファイル名とディレクトリ名は、国際化の基本に対処するためにUTF-8でエンコードされています。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. All file systems exported by a server are presented as a tree so that all file systems are reachable from a special per-server global root filehandle. This allows LOOKUP operations to be used to perform functions previously provided by the MOUNT protocol. The server provides any necessary pseudo file systems to bridge any gaps that arise due to unexported gaps between exported file systems.",
      "ja": "NFSV4.1プロトコルは、パス名とFileHandleの間の初期マッピングを提供するための別のプロトコルを必要としません。サーバーによってエクスポートされたすべてのファイルシステムはすべてのファイルシステムが特別なサーバーごとのグローバルルートファイルハンドルから到達可能になるようにツリーとして表示されます。これにより、ルックアップ操作を使用して、マウントプロトコルによって以前に提供された機能を実行できます。サーバーは、エクスポートされたファイルシステム間のエクスポートされていないギャップが原因で発生するギャップを埋めるために必要な疑似ファイルシステムを提供します。"
    },
    {
      "indent": 0,
      "text": "1.8.3.1. Filehandles",
      "section_title": true,
      "ja": "1.8.3.1. ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "As in previous versions of the NFS protocol, opaque filehandles are used to identify individual files and directories. Lookup-type and create operations translate file and directory names to filehandles, which are then used to identify objects in subsequent operations.",
      "ja": "以前のバージョンのNFSプロトコルのように、不透明なファイルハンドルは個々のファイルとディレクトリを識別するために使用されます。Lookup型と作成操作ファイルとディレクトリ名をfileHandlesに変換します。これは、後続の操作でオブジェクトを識別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides support for persistent filehandles, guaranteed to be valid for the lifetime of the file system object designated. In addition, it provides support to servers to provide filehandles with more limited validity guarantees, called volatile filehandles.",
      "ja": "NFSV4.1プロトコルは、永続的なファイルハンドルをサポートし、指定されたファイルシステムオブジェクトの有効期間に有効であることが保証されています。さらに、揮発性のファイルハンドルと呼ばれる、より限定された有効性保証付きのファイルハンドルを提供するためのサーバーへのサポートを提供します。"
    },
    {
      "indent": 0,
      "text": "1.8.3.2. File Attributes",
      "section_title": true,
      "ja": "1.8.3.2. ファイル属性"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol has a rich and extensible file object attribute structure, which is divided into REQUIRED, RECOMMENDED, and named attributes (see Section 5).",
      "ja": "NFSV4.1プロトコルには、必須、推奨、および名前付き属性に分割されている豊富で拡張可能なファイルオブジェクト属性構造があります（セクション5を参照）。"
    },
    {
      "indent": 3,
      "text": "Several (but not all) of the REQUIRED attributes are derived from the attributes of NFSv3 (see the definition of the fattr3 data type in [38]). An example of a REQUIRED attribute is the file object's type (Section 5.8.1.2) so that regular files can be distinguished from directories (also known as folders in some operating environments) and other types of objects. REQUIRED attributes are discussed in Section 5.1.",
      "ja": "必要な属性のいくつか（まだ全体ではない）は、NFSV3の属性から派生しています（[38]のFATTR 3データ型の定義を参照）。必要な属性の例は、ファイルオブジェクトのタイプ（セクション5.8.1.2）で、通常のファイルはディレクトリ（一部のオペレーティング環境でもフォルダとも呼ばれる）やその他の種類のオブジェクトとは区別できます。必須属性についてはセクション5.1で説明します。"
    },
    {
      "indent": 3,
      "text": "An example of three RECOMMENDED attributes are acl, sacl, and dacl. These attributes define an Access Control List (ACL) on a file object (Section 6). An ACL provides directory and file access control beyond the model used in NFSv3. The ACL definition allows for specification of specific sets of permissions for individual users and groups. In addition, ACL inheritance allows propagation of access permissions and restrictions down a directory tree as file system objects are created. RECOMMENDED attributes are discussed in Section 5.2.",
      "ja": "3つの推奨される属性の例は、ACL、SACL、およびDACLです。これらの属性は、ファイルオブジェクトのアクセス制御リスト（ACL）を定義します（セクション6）。ACLは、NFSV3で使用されているモデルを超えてディレクトリとファイルアクセス制御を提供します。ACL定義では、個々のユーザーとグループに対する特定の権限のセットを指定できます。さらに、ACL継承は、ファイルシステムオブジェクトとしてのディレクトリツリーを作成するアクセス権の伝播とディレクトリツリーを停止することを可能にします。推奨される属性については、セクション5.2で説明します。"
    },
    {
      "indent": 3,
      "text": "A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application-specific data with a regular file or directory. NFSv4.1 modifies named attributes relative to NFSv4.0 by tightening the allowed operations in order to prevent the development of non-interoperable implementations. Named attributes are discussed in Section 5.3.",
      "ja": "名前付き属性は、ディレクトリまたはファイルに関連付けられ、文字列名によって参照される不透明バイトストリームです。名前付き属性は、アプリケーション固有のデータを通常のファイルまたはディレクトリと関連付ける方法として、クライアントアプリケーションによって使用されることを目的としています。NFSV4.1は、非相互運用可能な実装の開発を防ぐために、許可された操作を締め付けることによって、NFSV4.0に対する名前付き属性を変更します。名前付き属性はセクション5.3で説明されています。"
    },
    {
      "indent": 0,
      "text": "1.8.3.3. Multi-Server Namespace",
      "section_title": true,
      "ja": "1.8.3.3. マルチサーバーネームスペース"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 contains a number of features to allow implementation of namespaces that cross server boundaries and that allow and facilitate a nondisruptive transfer of support for individual file systems between servers. They are all based upon attributes that allow one file system to specify alternate, additional, and new location information that specifies how the client may access that file system.",
      "ja": "NFSV4.1には、サーバーの境界をクロスし、サーバー間の個々のファイルシステムに対するサポートの非途中のサポートが許可されていない名前空間の実装を可能にするためのいくつかの機能が含まれています。それらはすべて、1つのファイルシステムがクライアントがそのファイルシステムにアクセスする方法を指定する代替、追加、および新しい位置情報を指定できる属性に基づいています。"
    },
    {
      "indent": 3,
      "text": "These attributes can be used to provide for individual active file systems:",
      "ja": "これらの属性は、個々のアクティブファイルシステムを提供するために使用できます。"
    },
    {
      "indent": 3,
      "text": "* Alternate network addresses to access the current file system instance.",
      "ja": "* 現在のファイルシステムインスタンスにアクセスするための代替ネットワークアドレス。"
    },
    {
      "indent": 3,
      "text": "* The locations of alternate file system instances or replicas to be used in the event that the current file system instance becomes unavailable.",
      "ja": "* 現在のファイルシステムインスタンスが利用できなくなった場合に使用される代替ファイルシステムインスタンスまたはレプリカの場所。"
    },
    {
      "indent": 3,
      "text": "These file system location attributes may be used together with the concept of absent file systems, in which a position in the server namespace is associated with locations on other servers without there being any corresponding file system instance on the current server. For example,",
      "ja": "これらのファイルシステムの場所属性は、存在しないファイルシステムの概念と共に使用されてもよく、ここではサーバネームスペース内の位置は、現在のサーバ上の対応するファイルシステムインスタンスがあっても他のサーバ上の位置に関連付けられている。例えば、"
    },
    {
      "indent": 3,
      "text": "* These attributes may be used with absent file systems to implement referrals whereby one server may direct the client to a file system provided by another server. This allows extensive multi-server namespaces to be constructed.",
      "ja": "* これらの属性は、1つのサーバが他のサーバによって提供されたファイルシステムに指示することができる参照を実装するために、存在しないファイルシステムと共に使用され得る。これにより、広範なマルチサーバーネームスペースを構築できます。"
    },
    {
      "indent": 3,
      "text": "* These attributes may be provided when a previously present file system becomes absent. This allows nondisruptive migration of file systems to alternate servers.",
      "ja": "* これらの属性は、以前に現在のファイルシステムが存在しない場合に提供されてもよい。これにより、ファイルシステムの交互のサーバーへの中断の中断が可能になります。"
    },
    {
      "indent": 0,
      "text": "1.8.4. Locking Facilities",
      "section_title": true,
      "ja": "1.8.4. ロック設備"
    },
    {
      "indent": 3,
      "text": "As mentioned previously, NFSv4.1 is a single protocol that includes locking facilities. These locking facilities include support for many types of locks including a number of sorts of recallable locks. Recallable locks such as delegations allow the client to be assured that certain events will not occur so long as that lock is held. When circumstances change, the lock is recalled via a callback request. The assurances provided by delegations allow more extensive caching to be done safely when circumstances allow it.",
      "ja": "前述のように、NFSV4.1はロック機能を含む単一のプロトコルです。これらのロック機能には、回復可能なロックの種類を含む多くの種類のロックのサポートが含まれています。代表団などのリコール可能なロックにより、そのロックが保持されている限り、特定のイベントが発生しないことをクライアントに保証できます。状況が変わると、ロックはコールバック要求によって呼び出されます。代表団によって提供される保証は、状況がそれを許すときに安全に広範囲のキャッシングを可能にする。"
    },
    {
      "indent": 3,
      "text": "The types of locks are:",
      "ja": "ロックの種類は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Share reservations as established by OPEN operations.",
      "ja": "* オープン操作によって確立されたように予約を共有する。"
    },
    {
      "indent": 3,
      "text": "* Byte-range locks.",
      "ja": "* バイトレンジロック"
    },
    {
      "indent": 3,
      "text": "* File delegations, which are recallable locks that assure the holder that inconsistent opens and file changes cannot occur so long as the delegation is held.",
      "ja": "* 委任が保持されている限り、矛盾するホルダーを保証するリコール可能なロックであるリソタリングロックです。"
    },
    {
      "indent": 3,
      "text": "* Directory delegations, which are recallable locks that assure the holder that inconsistent directory modifications cannot occur so long as the delegation is held.",
      "ja": "* ディレクトリの委任は、委任が保持されている限り、矛盾するディレクトリ変更が発生することができないホルダーを保証するリソタリングロックです。"
    },
    {
      "indent": 3,
      "text": "* Layouts, which are recallable objects that assure the holder that direct access to the file data may be performed directly by the client and that no change to the data's location that is inconsistent with that access may be made so long as the layout is held.",
      "ja": "* ファイルデータへのアクセスを確実にするホルダを保証するレイアウトは、クライアントによって直接実行され、そのアクセスと矛盾しないデータの位置に変更されないことが、レイアウトが保持されている限り、データの位置に変更されない可能性がある。"
    },
    {
      "indent": 3,
      "text": "All locks for a given client are tied together under a single client-wide lease. All requests made on sessions associated with the client renew that lease. When the client's lease is not promptly renewed, the client's locks are subject to revocation. In the event of server restart, clients have the opportunity to safely reclaim their locks within a special grace period.",
      "ja": "特定のクライアントのすべてのロックは、単一のクライアント全体のリースの下でまとめられています。クライアントに関連付けられているセッションで行われたすべての要求はそのリースを更新します。クライアントのリースが速やかに更新されない場合、クライアントのロックは失効の対象となります。サーバーの再起動が発生した場合、クライアントは特別な猶予期間内に自分のロックを安全に再利用する機会があります。"
    },
    {
      "indent": 0,
      "text": "1.9. Differences from NFSv4.0",
      "section_title": true,
      "ja": "1.9. NFSv4.0との違い"
    },
    {
      "indent": 3,
      "text": "The following summarizes the major differences between minor version 1 and the base protocol:",
      "ja": "以下は、マイナーバージョン1と基本プロトコルの主な違いを要約しています。"
    },
    {
      "indent": 3,
      "text": "* Implementation of the sessions model (Section 2.10).",
      "ja": "* セッションモデルの実装（セクション2.10）"
    },
    {
      "indent": 3,
      "text": "* Parallel access to data (Section 12).",
      "ja": "* データへの並列アクセス（セクション12）。"
    },
    {
      "indent": 3,
      "text": "* Addition of the RECLAIM_COMPLETE operation to better structure the lock reclamation process (Section 18.51).",
      "ja": "* ロック再生プロセスをよりよく構成するためのRECLAIM_COMPLETE操作の追加（セクション18.51）。"
    },
    {
      "indent": 3,
      "text": "* Enhanced delegation support as follows.",
      "ja": "* 以下のような強化された委任サポート。"
    },
    {
      "indent": 6,
      "text": "- Delegations on directories and other file types in addition to regular files (Section 18.39, Section 18.49).",
      "ja": "- 通常のファイルに加えて、ディレクトリやその他のファイルタイプに関する代理人（18.39項18.49節）。"
    },
    {
      "indent": 6,
      "text": "- Operations to optimize acquisition of recalled or denied delegations (Section 18.49, Section 20.5, Section 20.7).",
      "ja": "- リコールまたは拒否された委任の取得を最適化するための操作（第18.49節、セクション20.5、セクション20.7）。"
    },
    {
      "indent": 6,
      "text": "- Notifications of changes to files and directories (Section 18.39, Section 20.4).",
      "ja": "- ファイルとディレクトリへの変更の通知（セクション18.39,20.4）。"
    },
    {
      "indent": 6,
      "text": "- A method to allow a server to indicate that it is recalling one or more delegations for resource management reasons, and thus a method to allow the client to pick which delegations to return (Section 20.6).",
      "ja": "- サーバーが、リソース管理上の理由から1つ以上の委任を呼び出すことを示す方法、したがって、クライアントがどの委任を返すかをユーザーに返す方法を許可する方法です（セクション20.6）。"
    },
    {
      "indent": 3,
      "text": "* Attributes can be set atomically during exclusive file create via the OPEN operation (see the new EXCLUSIVE4_1 creation method in Section 18.16).",
      "ja": "* 属性は、オープン操作を介して排他ファイル作成中にアトミックに設定できます（セクション18.16の新しいexclusive4_1の作成方法を参照）。"
    },
    {
      "indent": 3,
      "text": "* Open files can be preserved if removed and the hard link count (\"hard link\" is defined in an Open Group [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\"\">6] standard) goes to zero, thus obviating the need for clients to rename deleted files to partially hidden names -- colloquially called \"silly rename\" (see the new OPEN4_RESULT_PRESERVE_UNLINKED reply flag in Section 18.16).",
      "ja": "* 削除された場合はオープンファイルを保存でき、ハードリンク数（「ハードリンク」をオープングループのセクション3のセクション3のセクション3.191号のセクション3.191号：IEEE STD 1003.1,2004版、HTML版）\"6]標準）はゼロになり、削除されたファイルの名前を部分的に隠された名前に名前を変更する必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "* Improved compatibility with Microsoft Windows for Access Control Lists (Section 6.2.3, Section 6.2.2, Section 6.4.3.2).",
      "ja": "* アクセス制御リストのMicrosoft Windowsとの互換性の向上（6.2.3項6.2.2項6.4.3.2項）。"
    },
    {
      "indent": 3,
      "text": "* Data retention (Section 5.13).",
      "ja": "* データ保持（セクション5.13）。"
    },
    {
      "indent": 3,
      "text": "* Identification of the implementation of the NFS client and server (Section 18.35).",
      "ja": "* NFSクライアントとサーバーの実装の識別（セクション18.35）。"
    },
    {
      "indent": 3,
      "text": "* Support for notification of the availability of byte-range locks (see the new OPEN4_RESULT_MAY_NOTIFY_LOCK reply flag in Section 18.16 and see Section 20.11).",
      "ja": "* バイトレンジロックの可用性の通知をサポートします（セクション18.16の新しいOpen4_Result_May_Notify_lockの返信フラグを参照）。"
    },
    {
      "indent": 3,
      "text": "* In NFSv4.1, LIPKEY and SPKM-3 are not required security mechanisms [39].",
      "ja": "* NFSV4.1では、リッキーとSPKM-3は必須のセキュリティメカニズムではありません[39]。"
    },
    {
      "indent": 0,
      "text": "2. Core Infrastructure",
      "section_title": true,
      "ja": "2. コアインフラストラクチャー"
    },
    {
      "indent": 0,
      "text": "2.1. Introduction",
      "section_title": true,
      "ja": "2.1. はじめに"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 relies on core infrastructure common to nearly every operation. This core infrastructure is described in the remainder of this section.",
      "ja": "NFSV4.1は、ほぼすべての操作に共通のコアインフラストラクチャに依存しています。このコアインフラストラクチャは、このセクションの残りの部分で説明されています。"
    },
    {
      "indent": 0,
      "text": "2.2. RPC and XDR",
      "section_title": true,
      "ja": "2.2. RPCとXDR"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [3] and [2].",
      "ja": "NFSV4.1プロトコルは、[3]と[2]で定義されているRPCバージョン2と対応する外部データ表現（XDR）を使用するリモートプロシージャコール（RPC）アプリケーションです。"
    },
    {
      "indent": 0,
      "text": "2.2.1. RPC-Based Security",
      "section_title": true,
      "ja": "2.2.1. RPCベースのセキュリティ"
    },
    {
      "indent": 3,
      "text": "Previous NFS versions have been thought of as having a host-based authentication model, where the NFS server authenticates the NFS client, and trusts the client to authenticate all users. Actually, NFS has always depended on RPC for authentication. One of the first forms of RPC authentication, AUTH_SYS, had no strong authentication and required a host-based authentication approach. NFSv4.1 also depends on RPC for basic security services and mandates RPC support for a user-based authentication model. The user-based authentication model has user principals authenticated by a server, and in turn the server authenticated by user principals. RPC provides some basic security services that are used by NFSv4.1.",
      "ja": "以前のNFSバージョンは、NFSサーバーがNFSクライアントを認証し、すべてのユーザーを認証するようにクライアントに信頼するというホストベースの認証モデルを持つと考えられています。実際には、NFSは常に認証のためにRPCに依存しています。RPC認証auth_sysの最初の形式の1つは、強力な認証を有し、ホストベースの認証アプローチを必要としました。NFSV4.1は、基本的なセキュリティサービスのためのRPCにも依存し、ユーザーベースの認証モデルのRPCサポートを義務付けます。ユーザーベースの認証モデルには、サーバーによって認証されているユーザープリンシパルがあり、ユーザーのプリンシパルによって認証されたサーバーがあります。RPCは、NFSv4.1によって使用される基本的なセキュリティサービスをいくつか提供します。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1. RPC Security Flavors",
      "section_title": true,
      "ja": "2.2.1.1. RPCセキュリティフレーバー"
    },
    {
      "indent": 3,
      "text": "As described in \"Authentication\", Section 7 of [3], RPC security is encapsulated in the RPC header, via a security or authentication flavor, and information specific to the specified security flavor. Every RPC header conveys information used to identify and authenticate a client and server. As discussed in Section 2.2.1.1.1, some security flavors provide additional security services.",
      "ja": "[3]の「認証」の「認証」で説明されているように、RPCセキュリティは、セキュリティまたは認証フレーバー、および指定されたセキュリティフレーバーに固有の情報を介してRPCヘッダーにカプセル化されています。すべてのRPCヘッダーは、クライアントとサーバーの識別と認証に使用される情報を伝えます。セクション2.2.1.1.1で説明したように、いくつかのセキュリティフレーバーは追加のセキュリティサービスを提供します。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 clients and servers MUST implement RPCSEC_GSS. (This requirement to implement is not a requirement to use.) Other flavors, such as AUTH_NONE and AUTH_SYS, MAY be implemented as well.",
      "ja": "NFSV4.1クライアントとサーバーはRPCSEC_GSSを実装する必要があります。（実装するこの要件は使用の要件ではありません。）auth_noneやauth_sysなどの他のフレーバーも同様に実装されてもよい。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1. RPCSEC_GSS and Security Services",
      "section_title": true,
      "ja": "2.2.1.1.1. RPCSEC_GSSおよびセキュリティサービス"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS [4] uses the functionality of GSS-API [7]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors.",
      "ja": "RPCSEC_GSS [4]はGSS-API [7]の機能を使用します。これにより、RPCセキュリティフレーバーを追加するための追加の実装のオーバーヘッドなしに、RPCレイヤによって様々なセキュリティメカニズムを使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.1. Identification, Authentication, Integrity, Privacy",
      "section_title": true,
      "ja": "2.2.1.1.1.1. 識別、認証、整合性、プライバシー"
    },
    {
      "indent": 3,
      "text": "Via the GSS-API, RPCSEC_GSS can be used to identify and authenticate users on clients to servers, and servers to users. It can also perform integrity checking on the entire RPC message, including the RPC header, and on the arguments or results. Finally, privacy, usually via encryption, is a service available with RPCSEC_GSS. Privacy is performed on the arguments and results. Note that if privacy is selected, integrity, authentication, and identification are enabled. If privacy is not selected, but integrity is selected, authentication and identification are enabled. If integrity and privacy are not selected, but authentication is enabled, identification is enabled. RPCSEC_GSS does not provide identification as a separate service.",
      "ja": "GSS-APIを介して、RPCSEC_GSSを使用して、クライアント上のユーザー、およびユーザーへのサーバーを識別して認証することができます。RPCヘッダーを含むRPCメッセージ全体、および引数または結果について整合性チェックを実行することもできます。最後に、通常は暗号化によるプライバシーは、RPCSEC_GSSで利用可能なサービスです。引数と結果に対してプライバシーが実行されます。プライバシーが選択されている場合は、整合性、認証、および識別が有効になっていることに注意してください。プライバシーが選択されていないが、完全性が選択されている場合は、認証と識別が有効になります。整合性とプライバシーが選択されていない場合、認証が有効になっている場合は、識別が有効になります。RPCSEC_GSSは別のサービスとして識別を提供しません。"
    },
    {
      "indent": 3,
      "text": "Although GSS-API has an authentication service distinct from its privacy and integrity services, GSS-API's authentication service is not used for RPCSEC_GSS's authentication service. Instead, each RPC request and response header is integrity protected with the GSS-API integrity service, and this allows RPCSEC_GSS to offer per-RPC authentication and identity. See [4] for more information.",
      "ja": "GSS-APIにはプライバシーサービスとIntegrity Servicesとは異なる認証サービスがありますが、GSS-APIの認証サービスはRPCSEC_GSSの認証サービスには使用されません。代わりに、各RPC要求および応答ヘッダーはGSS-API Integrityサービスで保護されている整合性であり、これによりRPCSEC_GSSはRPCごとの認証とIDを提供できます。詳細については[4]を参照してください。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 client and servers MUST support RPCSEC_GSS's integrity and authentication service. NFSv4.1 servers MUST support RPCSEC_GSS's privacy service. NFSv4.1 clients SHOULD support RPCSEC_GSS's privacy service.",
      "ja": "NFSV4.1クライアントとサーバーは、RPCSEC_GSSの整合性と認証サービスをサポートしている必要があります。NFSV4.1サーバーはRPCSEC_GSSのプライバシーサービスをサポートしている必要があります。NFSV4.1クライアントはRPCSEC_GSSのプライバシーサービスをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2. Security Mechanisms for NFSv4.1",
      "section_title": true,
      "ja": "2.2.1.1.1.2. NFSV4.1のセキュリティメカニズム"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS, via GSS-API, normalizes access to mechanisms that provide security services. Therefore, NFSv4.1 clients and servers MUST support the Kerberos V5 security mechanism.",
      "ja": "RPCSEC_GSSは、GSS-APIを介して、セキュリティサービスを提供するメカニズムへのアクセスを正規化します。したがって、NFSV4.1クライアントとサーバーはKerberos V5セキュリティメカニズムをサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "The use of RPCSEC_GSS requires selection of mechanism, quality of protection (QOP), and service (authentication, integrity, privacy). For the mandated security mechanisms, NFSv4.1 specifies that a QOP of zero is used, leaving it up to the mechanism or the mechanism's configuration to map QOP zero to an appropriate level of protection. Each mandated mechanism specifies a minimum set of cryptographic algorithms for implementing integrity and privacy. NFSv4.1 clients and servers MUST be implemented on operating environments that comply with the REQUIRED cryptographic algorithms of each REQUIRED mechanism.",
      "ja": "RPCSEC_GSSの使用には、メカニズム、保護品質（QOP）、およびサービス（認証、整合性、プライバシー）の選択が必要です。必須のセキュリティメカニズムの場合、NFSV4.1は、ゼロのQoPが使用され、メカニズムまたはメカニズムの構成に、QOPゼロを適切なレベルの保護にマッピングすることを指定します。各命令メカニズムは、整合性とプライバシーを実装するための最小の暗号化アルゴリズムのセットを指定します。NFSV4.1クライアントとサーバーは、必要な各メカニズムの必要な暗号化アルゴリズムに準拠したオペレーティング環境で実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2.1. Kerberos V5",
      "section_title": true,
      "ja": "2.2.1.1.1.2.1. Kerberos V5"
    },
    {
      "indent": 3,
      "text": "The Kerberos V5 GSS-API mechanism as described in [5] MUST be implemented with the RPCSEC_GSS services as specified in the following table:",
      "ja": "[5]に記載されているKerberos V5 GSS-APIメカニズムは、次の表にあるRPCSEC_GSSサービスを使用して実装する必要があります。"
    },
    {
      "indent": 6,
      "text": "column descriptions:\n1 == number of pseudo flavor\n2 == name of pseudo flavor\n3 == mechanism's OID\n4 == RPCSEC_GSS service\n5 == NFSv4.1 clients MUST support\n6 == NFSv4.1 servers MUST support",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "1      2        3                    4                     5   6\n------------------------------------------------------------------\n390003 krb5     1.2.840.113554.1.2.2 rpc_gss_svc_none      yes yes\n390004 krb5i    1.2.840.113554.1.2.2 rpc_gss_svc_integrity yes yes\n390005 krb5p    1.2.840.113554.1.2.2 rpc_gss_svc_privacy    no yes",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the number and name of the pseudo flavor are presented here as a mapping aid to the implementor. Because the NFSv4.1 protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for the NFSv3 since the security negotiation is done via the MOUNT protocol as described in [40].",
      "ja": "疑似風味の数と名前は、ここでは実装者へのマッピング補助として示されていることに注意してください。NFSV4.1プロトコルはセキュリティを交渉するためのメソッドを含み、GSS-APIメカニズムを理解するための方法を含み、疑似フレーバーは必要ありません。セキュリティネゴシエーションは[40]に記載されているようにマウントプロトコルを介して行われるため、疑似フレーバーがNFSV3に必要です。"
    },
    {
      "indent": 3,
      "text": "At the time NFSv4.1 was specified, the Advanced Encryption Standard (AES) with HMAC-SHA1 was a REQUIRED algorithm set for Kerberos V5. In contrast, when NFSv4.0 was specified, weaker algorithm sets were REQUIRED for Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because the Kerberos V5 specification at the time did not specify stronger algorithms. The NFSv4.1 specification does not specify REQUIRED algorithms for Kerberos V5, and instead, the implementor is expected to track the evolution of the Kerberos V5 standard if and when stronger algorithms are specified.",
      "ja": "NFSV4.1が指定された時点で、HMAC-SHA1を持つ高度な暗号化規格（AES）はKerberos V5に設定された要求アルゴリズムでした。対照的に、NFSV4.0が指定されている場合、Kerberos V5に弱いアルゴリズムセットが必要であり、NFSV4.0仕様では必要とされていました。なぜなら、Kerberos V5仕様はより強いアルゴリズムを指定しなかったためです。NFSV4.1仕様はKerberos V5に必要なアルゴリズムを指定しておらず、代わりに、実装者は、より強いアルゴリズムが指定されている場合、Kerberos V5規格の進化を追跡することが予想されます。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2.1.1. Security Considerations for Cryptographic Algorithms in Kerberos V5",
      "ja": "2.2.1.1.1.2.1.1. Kerberos v5における暗号化アルゴリズムに関するセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "When deploying NFSv4.1, the strength of the security achieved depends on the existing Kerberos V5 infrastructure. The algorithms of Kerberos V5 are not directly exposed to or selectable by the client or server, so there is some due diligence required by the user of NFSv4.1 to ensure that security is acceptable where needed.",
      "ja": "NFSV4.1を展開するとき、達成されたセキュリティの強さは既存のKerberos v5インフラストラクチャによって異なります。Kerberos v5のアルゴリズムは、クライアントまたはサーバーによって直接公開されていないため、必要に応じてセキュリティが許容できるようにするためにNFSV4.1のユーザーが必要とするデューデリジェンスがいくつかあります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.3. GSS Server Principal",
      "section_title": true,
      "ja": "2.2.1.1.1.3. GSSサーバープリンシパル"
    },
    {
      "indent": 3,
      "text": "Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:",
      "ja": "RPCSEC_GSSの下のセキュリティメカニズムが使用されているのかにかかわらず、NFSサーバーはGSS_C_NT_HOSTBASED_SERVICE NAMEタイプを介してGSS-APIで自分自身を識別する必要があります。GSS_C_NT_HOSTBASED_SERVICE名は次の形式です。"
    },
    {
      "indent": 8,
      "text": "service@hostname",
      "ja": "サービス@ホスト名"
    },
    {
      "indent": 3,
      "text": "For NFS, the \"service\" element is",
      "ja": "NFSの場合、「サービス」要素はです"
    },
    {
      "indent": 8,
      "text": "nfs",
      "ja": "NFS"
    },
    {
      "indent": 3,
      "text": "Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5, the following form is RECOMMENDED:",
      "ja": "セキュリティメカニズムの実装は、NFS @ hostnameをさまざまな形式に変換します。Kerberos V5の場合、次のフォームをお勧めします。"
    },
    {
      "indent": 8,
      "text": "nfs/hostname",
      "ja": "NFS /ホスト名"
    },
    {
      "indent": 0,
      "text": "2.3. COMPOUND and CB_COMPOUND",
      "section_title": true,
      "ja": "2.3. 化合物とcb_compound."
    },
    {
      "indent": 3,
      "text": "A significant departure from the versions of the NFS protocol before NFSv4 is the introduction of the COMPOUND procedure. For the NFSv4 protocol, in all minor versions, there are exactly two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined as a series of individual operations and these operations perform the sorts of functions performed by traditional NFS procedures.",
      "ja": "NFSV4以前のNFSプロトコルのバージョンからの大きな逸脱は、複合手順の導入です。NFSV4プロトコルのすべてのマイナーバージョンでは、NULLと化合物とは正確に2つのRPC手順があります。複合手順は一連の個々の操作として定義され、これらの操作は従来のNFS手順によって実行される種類の機能を実行します。"
    },
    {
      "indent": 3,
      "text": "The operations combined within a COMPOUND request are evaluated in order by the server, without any atomicity guarantees. A limited set of facilities exist to pass results from one operation to another. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.",
      "ja": "複合要求内で組み合わされた操作は、原子力を保証することなくサーバーによって順番に評価されます。ある操作から別の操作への結果を渡すために、限られた施設のセットが存在します。操作が失敗した結果を返すと、評価は終了し、すべて評価された操作の結果がクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, multi-component look up requests can be constructed by combining multiple LOOKUP operations. Those can be further combined with operations such as GETATTR, READDIR, or OPEN plus READ to do more complicated sets of operation without incurring additional latency.",
      "ja": "複合手順を使用すると、クライアントは単純または複雑な要求を作成することができます。これらの複合要求により、論理ファイルシステムの操作に必要なRPCの数を減らすことができます。たとえば、複数のルックアップ操作を組み合わせることで、マルチコンポーネントルックアップ要求を構築できます。追加の待ち時間を招くことなく、getAttr、ReadDir、またはOpen Plusの読み取りなどの操作とさらに組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 also contains a considerable set of callback operations in which the server makes an RPC directed at the client. Callback RPCs have a similar structure to that of the normal server requests. In all minor versions of the NFSv4 protocol, there are two callback RPC procedures: CB_NULL and CB_COMPOUND. The CB_COMPOUND procedure is defined in an analogous fashion to that of COMPOUND with its own set of callback operations.",
      "ja": "NFSV4.1には、サーバーがクライアントにRPCを向けたかのかなりのコールバック操作のセットも含まれています。コールバックRPCは、通常のサーバ要求と同様の構造を持ちます。NFSV4プロトコルのすべてのマイナーバージョンでは、CB_NULLとCB_COMPOUND 2つのコールバックRPCプロシージャがあります。CB_COMPOUND手順は、独自のコールバック操作を持つ化合物のそれと同様の方法で定義されています。"
    },
    {
      "indent": 3,
      "text": "The addition of new server and callback operations within the COMPOUND and CB_COMPOUND request framework provides a means of extending the protocol in subsequent minor versions.",
      "ja": "複合およびCB_Compound Request Framework内の新しいサーバーおよびコールバック操作の追加は、その後のマイナーバージョンでプロトコルを拡張する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "Except for a small number of operations needed for session creation, server requests and callback requests are performed within the context of a session. Sessions provide a client context for every request and support robust replay protection for non-idempotent requests.",
      "ja": "セッション作成に必要な少数の操作を除いて、サーバー要求およびコールバック要求はセッションのコンテキスト内で実行されます。セッションはすべての要求に対してクライアントコンテキストを提供し、IDEMPOTENT以外の要求に対する堅牢な再生保護をサポートします。"
    },
    {
      "indent": 0,
      "text": "2.4. Client Identifiers and Client Owners",
      "section_title": true,
      "ja": "2.4. クライアント識別子とクライアントの所有者"
    },
    {
      "indent": 3,
      "text": "For each operation that obtains or depends on locking state, the specific client needs to be identifiable by the server.",
      "ja": "ロック状態に応じてまたは依存する各操作について、特定のクライアントはサーバーによって識別可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "Each distinct client instance is represented by a client ID. A client ID is a 64-bit identifier representing a specific client at a given time. The client ID is changed whenever the client re-initializes, and may change when the server re-initializes. Client IDs are used to support lock identification and crash recovery.",
      "ja": "各個別のクライアントインスタンスはクライアントIDによって表されます。クライアントIDは、特定のクライアントを表す64ビット識別子です。クライアントIDは、クライアントが再初期化するたびに変更され、サーバーが再初期化されたときに変更される可能性があります。クライアントIDは、ロックの識別とクラッシュの回復をサポートするために使用されます。"
    },
    {
      "indent": 3,
      "text": "During steady state operation, the client ID associated with each operation is derived from the session (see Section 2.10) on which the operation is sent. A session is associated with a client ID when the session is created.",
      "ja": "定常運転中、各操作に関連するクライアントIDは、操作が送信されるセッション（2.10を参照）から派生します。セッションが作成されたときにセッションがクライアントIDに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv4.0, the only NFSv4.1 operations possible before a client ID is established are those needed to establish the client ID.",
      "ja": "NFSv4.0とは異なり、クライアントIDが確立される前に可能な限り唯一のNFSv4.1操作は、クライアントIDを確立するために必要なものです。"
    },
    {
      "indent": 3,
      "text": "A sequence of an EXCHANGE_ID operation followed by a CREATE_SESSION operation using that client ID (eir_clientid as returned from EXCHANGE_ID) is required to establish and confirm the client ID on the server. Establishment of identification by a new incarnation of the client also has the effect of immediately releasing any locking state that a previous incarnation of that same client might have had on the server. Such released state would include all byte-range lock, share reservation, layout state, and -- where the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_CUR_FH claim types -- all delegation state associated with the same client with the same identity. For discussion of delegation state recovery, see Section 10.2.1. For discussion of layout state recovery, see Section 12.7.1.",
      "ja": "Exchange_ID操作のシーケンスとそれに続くそのクライアントIDを使用したCREATE_SESSION操作（Exchange_IDから返されたEIR_ClientID）を使用して、サーバー上のクライアントIDを確立して確認するために必要です。クライアントの新しい化身による識別の確立も、以前のクライアントの以前の化身がサーバー上であった可能性があるようなロック状態を直ちに解放するという効果もあります。このようなリリース状態には、すべてのバイトレンジロック、共有予約、レイアウト状態、および - サーバがクレームのいずれかをサポートしていない場合、サーバがクレームのいずれかをサポートしていません。委任状況回復については、10.2.1項を参照してください。レイアウト状態の回復については、12.7.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Releasing such state requires that the server be able to determine that one client instance is the successor of another. Where this cannot be done, for any of a number of reasons, the locking state will remain for a time subject to lease expiration (see Section 8.3) and the new client will need to wait for such state to be removed, if it makes conflicting lock requests.",
      "ja": "このような状態を解放するには、サーバーが1つのクライアントインスタンスが別のクライアントインスタンスの後継者であることを判断できるようにする必要があります。これを行うことができない場合は、いくつかの理由のいずれかについて、ロック状態はリースの有効期限の対象となる時間の間残ります（セクション8.3を参照）、新しいクライアントは競合する場合はそのような状態を削除するのを待つ必要があります。要求をロックします。"
    },
    {
      "indent": 3,
      "text": "Client identification is encapsulated in the following client owner data type:",
      "ja": "クライアント識別情報は、次のクライアント所有者データ型でカプセル化されています。"
    },
    {
      "indent": 3,
      "text": "struct client_owner4 {\n        verifier4       co_verifier;\n        opaque          co_ownerid<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first field, co_verifier, is a client incarnation verifier, allowing the server to distinguish successive incarnations (e.g., reboots) of the same client. The server will start the process of canceling the client's leased state if co_verifier is different than what the server has previously recorded for the identified client (as specified in the co_ownerid field).",
      "ja": "最初のフィールドCO_VERIFIERは、クライアントのインカレーション検証子で、サーバーは同じクライアントの連続した化身（たとえば再起動）を区別できるようになります。CO_VERIFIERがサーバーが以前に識別されたクライアントに対して以前に記録されているものとは異なる場合（co_owneridフィールドで指定されているように）CO_VERIFIERが異なる場合、サーバーはクライアントのリース状態をキャンセルするプロセスを開始します。"
    },
    {
      "indent": 3,
      "text": "The second field, co_ownerid, is a variable length string that uniquely defines the client so that subsequent instances of the same client bear the same co_ownerid with a different verifier.",
      "ja": "2番目のフィールドco_ownerIdは、同じクライアントの後続のインスタンスが異なる検証者を持つ同じCO_OWNERIDを持つようにクライアントを一意に定義する可変長文字列です。"
    },
    {
      "indent": 3,
      "text": "There are several considerations for how the client generates the co_ownerid string:",
      "ja": "クライアントがCO_OWNERID文字列を生成する方法については、いくつかの考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "* The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly cancelled.",
      "ja": "* 複数のクライアントが同じ文字列を存在しないように、文字列は一意であるべきです。1つのクライアントから同じ文字列範囲を表示する2つのクライアントの結果は、そのリース状態を突然、予期せずにキャンセルされた1つのクライアントにエラーを取得します。"
    },
    {
      "indent": 3,
      "text": "* The string should be selected so that subsequent incarnations (e.g., restarts) of the same client cause the client to present the same string. The implementor is cautioned from an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4.1 server.",
      "ja": "* 同じクライアントのその後のinnarations（たとえば、再起動）がクライアントに同じ文字列を表示させるように文字列を選択する必要があります。この実装者は、ローカルファイルに記録されるように文字列を記録するためのアプローチから、ローカルディスクがない環境での実装の使用を排除し、すべてのファイルアクセスがNFSV4.1サーバーからのものであるためです。"
    },
    {
      "indent": 3,
      "text": "* The string should be the same for each server network address that the client accesses. This way, if a server has multiple interfaces, the client can trunk traffic over multiple network paths as described in Section 2.10.5. (Note: the precise opposite was advised in the NFSv4.0 specification [37].)",
      "ja": "* クライアントがアクセスするサーバーネットワークアドレスごとに文字列は同じである必要があります。このようにして、サーバに複数のインタフェースがある場合、クライアントはセクション2.10.5で説明されているように複数のネットワークパスを介したトラフィックをトランス化できます。（注：NFSV4.0仕様では、正確な反対は推奨されています[37]）"
    },
    {
      "indent": 3,
      "text": "* The algorithm for generating the string should not assume that the client's network address will not change, unless the client implementation knows it is using statically assigned network addresses. This includes changes between client incarnations and even changes while the client is still running in its current incarnation. Thus, with dynamic address assignment, if the client includes just the client's network address in the co_ownerid string, there is a real risk that after the client gives up the network address, another client, using a similar algorithm for generating the co_ownerid string, would generate a conflicting co_ownerid string.",
      "ja": "* クライアントの実装が静的に割り当てられたネットワークアドレスを使用していることを知っていない限り、文字列を生成するためのアルゴリズムは、クライアントのネットワークアドレスが変更されないと仮定しないでください。これには、クライアントのインカネルと変更さえ、クライアントが現在のインカレーションで実行されている間に変更されています。したがって、動的アドレス割り当てを使用して、クライアントがCO_OWNERID文字列内のクライアントのネットワークアドレスだけを含む場合、クライアントがCo_OwnerID文字列を生成するための同様のアルゴリズムを使用して、クライアントがネットワークアドレスをあきらめた後に実際のリスクがあります。競合するCO_OWNERID文字列を生成します。"
    },
    {
      "indent": 3,
      "text": "Given the above considerations, an example of a well-generated co_ownerid string is one that includes:",
      "ja": "上記の考慮事項を考慮すると、よく生成されたCO_OWNERID文字列の例は以下のものを含むものである。"
    },
    {
      "indent": 3,
      "text": "* If applicable, the client's statically assigned network address.",
      "ja": "* 該当する場合、クライアントの静的に割り当てられたネットワークアドレス。"
    },
    {
      "indent": 3,
      "text": "* Additional information that tends to be unique, such as one or more of:",
      "ja": "* 1つ以上のものなど、ユニークになる傾向がある追加情報"
    },
    {
      "indent": 6,
      "text": "- The client machine's serial number (for privacy reasons, it is best to perform some one-way function on the serial number).",
      "ja": "- クライアントマシンのシリアル番号（プライバシー上の理由から、シリアル番号に一方向機能を実行するのが最善です）。"
    },
    {
      "indent": 6,
      "text": "- A Media Access Control (MAC) address (again, a one-way function should be performed).",
      "ja": "- メディアアクセス制御（MAC）アドレス（やはり、一方向機能を実行する必要があります）。"
    },
    {
      "indent": 6,
      "text": "- The timestamp of when the NFSv4.1 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4.1).",
      "ja": "- NFSV4.1ソフトウェアが最初にクライアントにインストールされたときのタイムスタンプのタイムスタンプは（これはファイルに格納されている情報の使用について前述した注意の対象となりますが、ファイルはNFSV4.1よりもアクセスできない可能性があります）。"
    },
    {
      "indent": 6,
      "text": "- A true random number. However, since this number ought to be the same between client incarnations, this shares the same problem as that of using the timestamp of the software installation.",
      "ja": "- 真の乱数。ただし、この数はクライアントのインカネル間で同じであるべきであるため、ソフトウェアのインストールのタイムスタンプの使用方法と同じ問題を共有しています。"
    },
    {
      "indent": 3,
      "text": "* For a user-level NFSv4.1 client, it should contain additional information to distinguish the client from other user-level clients running on the same host, such as a process identifier or other unique sequence.",
      "ja": "* ユーザーレベルのNFSV4.1クライアントの場合、プロセス識別子やその他の固有のシーケンスなど、同じホスト上で実行されている他のユーザーレベルクライアントからクライアントを区別するための追加情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The client ID is assigned by the server (the eir_clientid result from EXCHANGE_ID) and should be chosen so that it will not conflict with a client ID previously assigned by the server. This applies across server restarts.",
      "ja": "クライアントIDは、サーバー（Exchange_IDのEIR_CLIENTIDの結果）によって割り当てられ、サーバーによって以前に割り当てられたクライアントIDと競合しないように選択されるべきです。これはサーバーの再起動に適用されます。"
    },
    {
      "indent": 3,
      "text": "In the event of a server restart, a client may find out that its current client ID is no longer valid when it receives an NFS4ERR_STALE_CLIENTID error. The precise circumstances depend on the characteristics of the sessions involved, specifically whether the session is persistent (see Section 2.10.6.5), but in each case the client will receive this error when it attempts to establish a new session with the existing client ID and receives the error NFS4ERR_STALE_CLIENTID, indicating that a new client ID needs to be obtained via EXCHANGE_ID and the new session established with that client ID.",
      "ja": "サーバーの再起動が発生した場合、クライアントは、NFS4ERR_STALE_CLIENTIDエラーを受信したときに現在のクライアントIDが無効になっていないことがわかります。正確な状況は、関与するセッションの特性、特にセッションが永続的かどうか（セクション2.10.6.5を参照）に依存しますが、それぞれの場合では、クライアントは既存のクライアントIDと新しいセッションを確立しようとするとクライアントがこのエラーを受け取ります。エラーNFS4ERR_STALE_CLIENTIDを受信し、Exchange_IDを介して新しいクライアントIDとそのクライアントIDで確立された新しいセッションを取得する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "When a session is not persistent, the client will find out that it needs to create a new session as a result of getting an NFS4ERR_BADSESSION, since the session in question was lost as part of a server restart. When the existing client ID is presented to a server as part of creating a session and that client ID is not recognized, as would happen after a server restart, the server will reject the request with the error NFS4ERR_STALE_CLIENTID.",
      "ja": "セッションが永続的ではない場合、クライアントは、問題のセッションがサーバーの再起動の一部として失われたため、NFS4ERR_BADSessionを取得した結果として新しいセッションを作成する必要があることを確認します。サーバーの再起動後に起こるように、既存のクライアントIDがサーバーに提示され、クライアントIDが認識されない場合、サーバーはエラーNFS4ERR_STALE_CLIENTIDを使用して要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "In the case of the session being persistent, the client will re-establish communication using the existing session after the restart. This session will be associated with the existing client ID but may only be used to retransmit operations that the client previously transmitted and did not see replies to. Replies to operations that the server previously performed will come from the reply cache; otherwise, NFS4ERR_DEADSESSION will be returned. Hence, such a session is referred to as \"dead\". In this situation, in order to perform new operations, the client needs to establish a new session. If an attempt is made to establish this new session with the existing client ID, the server will reject the request with NFS4ERR_STALE_CLIENTID.",
      "ja": "セッションが永続的である場合、クライアントは再起動後に既存のセッションを使用して通信を再確立します。このセッションは既存のクライアントIDに関連付けられますが、クライアントが以前に送信され、返信が表示されなかった操作を再送信するためにのみ使用できます。以前に実行されたサーバーが返信キャッシュから来る操作に応答します。それ以外の場合は、NFS4ERR_DeadSessionが返されます。したがって、そのようなセッションは「死んだ」と呼ばれる。この状況では、新しい操作を実行するために、クライアントは新しいセッションを確立する必要があります。既存のクライアントIDとこの新しいセッションを確立しようとすると、サーバーはNFS4ERR_STALE_CLIENTIDを使用して要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "When NFS4ERR_STALE_CLIENTID is received in either of these situations, the client needs to obtain a new client ID by use of the EXCHANGE_ID operation, then use that client ID as the basis of a new session, and then proceed to any other necessary recovery for the server restart case (see Section 8.4.2).",
      "ja": "NFS4ERR_STALE_CLIENTIDがこれらの状況で受信されると、クライアントはExchange_ID操作を使用して新しいクライアントIDを入手してから、新しいセッションの基礎としてそのクライアントIDを使用してから、サーバーの他の必要な回復に進む必要があります。ケースを再起動します（8.4.2項を参照）。"
    },
    {
      "indent": 3,
      "text": "See the descriptions of EXCHANGE_ID (Section 18.35) and CREATE_SESSION (Section 18.36) for a complete specification of these operations.",
      "ja": "これらの操作を完全に指定するために、Exchange_ID（18.35節）とCREATE_SESSION（セクション18.36）の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Upgrade from NFSv4.0 to NFSv4.1",
      "section_title": true,
      "ja": "2.4.1. NFSV4.0からNFSV4.1へのアップグレード"
    },
    {
      "indent": 3,
      "text": "To facilitate upgrade from NFSv4.0 to NFSv4.1, a server may compare a value of data type client_owner4 in an EXCHANGE_ID with a value of data type nfs_client_id4 that was established using the SETCLIENTID operation of NFSv4.0. A server that does so will allow an upgraded client to avoid waiting until the lease (i.e., the lease established by the NFSv4.0 instance client) expires. This requires that the value of data type client_owner4 be constructed the same way as the value of data type nfs_client_id4. If the latter's contents included the server's network address (per the recommendations of the NFSv4.0 specification [37]), and the NFSv4.1 client does not wish to use a client ID that prevents trunking, it should send two EXCHANGE_ID operations. The first EXCHANGE_ID will have a client_owner4 equal to the nfs_client_id4. This will clear the state created by the NFSv4.0 client. The second EXCHANGE_ID will not have the server's network address. The state created for the second EXCHANGE_ID will not have to wait for lease expiration, because there will be no state to expire.",
      "ja": "NFSV4.0からNFSV4.1へのアップグレードを容易にするために、サーバは、NFSV4.0のSetClientID操作を使用して確立されたデータ型NFS_CLIENT_ID4の値を有する、Exchange_ID内のデータ型CLIENT_OWNER4の値を比較することができる。そのため、アップグレードされたクライアントがリースまで待機しないようにする（すなわち、NFSV4.0インスタンスクライアントによって確立されたリース）が期限切れになることを可能にする。これには、データ型CLIENT_OWNER4の値がデータ型NFS_CLIENT_ID4の値と同じ方法で構成されている必要があります。後者の内容にサーバーのネットワークアドレスが含まれていた場合（NFSV4.0仕様[37]の推奨事項ごとに）、およびNFSV4.1クライアントがトランキングを防ぐクライアントIDを使用したくない場合は、2つのExchange_ID操作を送信する必要があります。最初のExchange_idは、nfs_client_id4に等しいclient_owner4を持ちます。これにより、NFSV4.0クライアントによって作成された状態がクリアされます。 2番目のExchange_IDにはサーバーのネットワークアドレスがありません。 2番目のExchange_IDのために作成された状態は、期限切れにされない状態がないため、リースの有効期限を待つ必要はありません。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Server Release of Client ID",
      "section_title": true,
      "ja": "2.4.2. クライアントIDのサーバーリリース"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces a new operation called DESTROY_CLIENTID (Section 18.50), which the client SHOULD use to destroy a client ID it no longer needs. This permits graceful, bilateral release of a client ID. The operation cannot be used if there are sessions associated with the client ID, or state with an unexpired lease.",
      "ja": "NFSV4.1では、DEASTER_CLIENTID（セクション18.50）という新しい操作が導入され、クライアントはニーズがなくなったクライアントIDを破棄するために使用する必要があります。これにより、クライアントIDの優雅で二国間リリースが可能になります。クライアントIDに関連付けられているセッション、または期限切れのリースを持つ状態がある場合は、動作を使用できません。"
    },
    {
      "indent": 3,
      "text": "If the server determines that the client holds no associated state for its client ID (associated state includes unrevoked sessions, opens, locks, delegations, layouts, and wants), the server MAY choose to unilaterally release the client ID in order to conserve resources. If the client contacts the server after this release, the server MUST ensure that the client receives the appropriate error so that it will use the EXCHANGE_ID/CREATE_SESSION sequence to establish a new client ID. The server ought to be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes. As long as there are sessions, opens, locks, delegations, layouts, or wants, the server MUST NOT release the client ID. See Section 2.10.13.1.4 for discussion on releasing inactive sessions.",
      "ja": "クライアントがクライアントIDの関連状態を保持していないとサーバーが決定された場合（関連状態には取り消されていないセッション、オープン、ロック、委任、レイアウト、および欲しい）、サーバーはリソースを節約するためにクライアントIDを一方的に解放することを選択できます。このリリースの後にクライアントがサーバーに連絡している場合、サーバーはクライアントがExchange_ID / Create_Sessionシーケンスを使用して新しいクライアントIDを確立するようにする必要があることを確認する必要があります。このようなイベントから回復するクライアント上の結果として生じる作業は、サーバーが失敗して再起動した場合と同じ負担になるため、サーバーはクライアントIDを解放することが非常に躊躇します。通常、サーバーは、そのクライアントから何分間のアクティビティもない限りクライアントIDを解放しません。セッションがある限り、オープン、ロック、代表団、レイアウト、または希望は、サーバーはクライアントIDを解放してはいけません。非アクティブセッションの解放に関する議論については、セクション2.10.13.1.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Resolving Client Owner Conflicts",
      "section_title": true,
      "ja": "2.4.3. クライアント所有者の競合の解決"
    },
    {
      "indent": 3,
      "text": "When the server gets an EXCHANGE_ID for a client owner that currently has no state, or that has state but the lease has expired, the server MUST allow the EXCHANGE_ID and confirm the new client ID if followed by the appropriate CREATE_SESSION.",
      "ja": "サーバーが現在状態がない、またはその状態があるがリースが期限切れになっているクライアント所有者のExchange_IDを取得すると、サーバーはExchange_IDを許可し、適切なCreate_Sessionが続く場合は新しいクライアントIDを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server gets an EXCHANGE_ID for a new incarnation of a client owner that currently has an old incarnation with state and an unexpired lease, the server is allowed to dispose of the state of the previous incarnation of the client owner if one of the following is true:",
      "ja": "現在の状態と期限切れのリースを持つ古いincarnationを持つクライアント所有者の新しい化身のためにサーバーがExchange_idを取得すると、サーバーは次のいずれかの場合はクライアント所有者の以前の化身の状態を廃棄できます。真実："
    },
    {
      "indent": 3,
      "text": "* The principal that created the client ID for the client owner is the same as the principal that is sending the EXCHANGE_ID operation. Note that if the client ID was created with SP4_MACH_CRED state protection (Section 18.35), the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.",
      "ja": "* クライアント所有者のクライアントIDを作成した主体は、Exchange_ID操作を送信しているプリンシパルと同じです。クライアントIDがSP4_MACH_CRED状態保護（セクション18.35）で作成された場合、プリンシパルはRPCSEC_GSS認証に基づいている必要がありますが、使用されるRPCSEC_GSSサービスは整合性またはプライバシーでなければならず、同じGSSメカニズムとプリンシパルを使用する必要があります。クライアントIDが作成されました。"
    },
    {
      "indent": 3,
      "text": "* The client ID was established with SP4_SSV protection (Section 18.35, Section 2.10.8.3) and the client sends the EXCHANGE_ID with the security flavor set to RPCSEC_GSS using the GSS SSV mechanism (Section 2.10.9).",
      "ja": "* クライアントIDはSP4_SSV保護（セクション2.35,2.10.8.3）で確立され、クライアントはGSS SSVメカニズムを使用してRPCSEC_GSSにセキュリティフレーバーセットにEXCHANGE_IDを送信します（セクション2.10.9）。"
    },
    {
      "indent": 3,
      "text": "* The client ID was established with SP4_SSV protection, and under the conditions described herein, the EXCHANGE_ID was sent with SP4_MACH_CRED state protection. Because the SSV might not persist across client and server restart, and because the first time a client sends EXCHANGE_ID to a server it does not have an SSV, the client MAY send the subsequent EXCHANGE_ID without an SSV RPCSEC_GSS handle. Instead, as with SP4_MACH_CRED protection, the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.",
      "ja": "* クライアントIDはSP4_SSV保護を使用して確立され、本明細書に記載されている条件下で、Exchange_IDはSP4_MACH_CRED状態保護を使用して送信されました。SSVはクライアントとサーバーの再起動を継続しない可能性があるため、クライアントが初めてExchange_IDをサーバーに送信しているため、SSVがありません。クライアントはSSV RPCSEC_GSSハンドルなしで後続のExchange_idを送信できます。代わりに、SP4_MACH_CRED保護と同様に、プリンシパルはRPCSEC_GSS認証に基づいている必要があります。使用されているRPCSEC_GSSサービスは、整合性またはプライバシーでなければならず、クライアントIDが作成されたときに同じGSSメカニズムとプリンシパルを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If none of the above situations apply, the server MUST return NFS4ERR_CLID_INUSE.",
      "ja": "上記の状況のどれもが適用されない場合、サーバーはNFS4ERR_CLID_INUSEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server accepts the principal and co_ownerid as matching that which created the client ID, and the co_verifier in the EXCHANGE_ID differs from the co_verifier used when the client ID was created, then after the server receives a CREATE_SESSION that confirms the client ID, the server deletes state. If the co_verifier values are the same (e.g., the client either is updating properties of the client ID (Section 18.35) or is attempting trunking (Section 2.10.5), the server MUST NOT delete state.",
      "ja": "サーバーがクライアントIDを作成したマッチングとしてプリンシパルとCO_OWNERIDを受け入れ、Exchange_IDのCO_VERIFIERはクライアントIDが作成されたときに使用されたCO_VERVERIFIERとは異なります。状態を削除します。CO_VERIFIER値が同じ（例えば、クライアントがクライアントIDのプロパティを更新している（セクション18.35）、またはトランキングを試みている場合（セクション2.10.5）、サーバーは状態を削除しないでください。"
    },
    {
      "indent": 0,
      "text": "2.5. Server Owners",
      "section_title": true,
      "ja": "2.5. サーバーの所有者"
    },
    {
      "indent": 3,
      "text": "The server owner is similar to a client owner (Section 2.4), but unlike the client owner, there is no shorthand server ID. The server owner is defined in the following data type:",
      "ja": "サーバーの所有者はクライアントの所有者と似ています（セクション2.4）、クライアントの所有者とは異なり、短縮サーバーIDはありません。サーバーの所有者は、次のデータ型で定義されています。"
    },
    {
      "indent": 3,
      "text": "struct server_owner4 {\n uint64_t       so_minor_id;\n opaque         so_major_id<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The server owner is returned from EXCHANGE_ID. When the so_major_id fields are the same in two EXCHANGE_ID results, the connections that each EXCHANGE_ID were sent over can be assumed to address the same server (as defined in Section 1.7). If the so_minor_id fields are also the same, then not only do both connections connect to the same server, but the session can be shared across both connections. The reader is cautioned that multiple servers may deliberately or accidentally claim to have the same so_major_id or so_major_id/ so_minor_id; the reader should examine Sections 2.10.5 and 18.35 in order to avoid acting on falsely matching server owner values.",
      "ja": "サーバーの所有者はExchange_IDから返されます。SO_MAJOR_IDフィールドが2つのExchange_IDの結果で同じである場合、各Exchange_IDが送信した接続は同じサーバーに対処すると仮定することができます（セクション1.7で定義されているように）。SO_MINOR_IDフィールドも同じである場合は、同じサーバーに接続するだけでなく、両方の接続でセッションを共有できます。リーダーには、複数のサーバーが意図的にまたは誤って同じSO_MAJOR_IDまたはSO_MAJOR_ID / SO_MINOR_IDを持つことを主張することができることに注意してください。リーダーは、誤ってサーバーの所有者の値を誤ってマッチングすることを回避するために、セクション2.10.5および18.35を調べる必要があります。"
    },
    {
      "indent": 3,
      "text": "The considerations for generating an so_major_id are similar to that for generating a co_ownerid string (see Section 2.4). The consequences of two servers generating conflicting so_major_id values are less dire than they are for co_ownerid conflicts because the client can use RPCSEC_GSS to compare the authenticity of each server (see Section 2.10.5).",
      "ja": "SO_MAJOR_IDを生成するための考慮事項は、CO_OWNERID文字列を生成するためのものと似ています（セクション2.4を参照）。競合するSO_MAJOR_ID値を生成する2つのサーバーの結果は、CO_OWNERIDの競合のためのものよりも難しく、クライアントは各サーバーの信頼性を比較できるためです（セクション2.10.5を参照）。"
    },
    {
      "indent": 0,
      "text": "2.6. Security Service Negotiation",
      "section_title": true,
      "ja": "2.6. セキュリティサービスの交渉"
    },
    {
      "indent": 3,
      "text": "With the NFSv4.1 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its file system namespace that are available for use by NFS clients. These points can be considered security policy boundaries, and, in some NFS implementations, are tied to NFS export points. In turn, the NFS server may be configured such that each of these security policy boundaries may have different or multiple security mechanisms in use.",
      "ja": "NFSV4.1サーバーが複数のセキュリティメカニズムを提供する可能性があるため、どのメカニズムをサーバーとの通信に使用するかを決定またはネゴシエートする方法が必要です。NFSサーバーは、NFSクライアントが使用できるファイルシステムの名前空間内に複数のポイントを持つことができます。これらの点はセキュリティポリシーの境界と見なすことができ、いくつかのNFSの実装ではNFSエクスポートポイントに関連付けられています。次に、NFSサーバは、これらのセキュリティポリシー境界のそれぞれが使用中に異なるセキュリティメカニズムを有することがあるように構成され得る。"
    },
    {
      "indent": 3,
      "text": "The security negotiation between client and server SHOULD be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See Section 21 for further discussion.",
      "ja": "クライアントとサーバー間のセキュリティネゴシエーションは、安全なチャネルを使用して、第三者がネゴシエーションシーケンスを傍受し、クライアントとサーバーを強制する可能性を排除し、必要以上に必要なものよりも低いレベルのセキュリティを選択する可能性を排除する必要があります。さらなる議論については21節を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.6.1. NFSv4.1 Security Tuples",
      "section_title": true,
      "ja": "2.6.1. NFSV4.1セキュリティタプル"
    },
    {
      "indent": 3,
      "text": "An NFS server can assign one or more \"security tuples\" to each security policy boundary in its namespace. Each security tuple consists of a security flavor (see Section 2.2.1.1) and, if the flavor is RPCSEC_GSS, a GSS-API mechanism Object Identifier (OID), a GSS-API quality of protection, and an RPCSEC_GSS service.",
      "ja": "NFSサーバーは、名前空間内の各セキュリティポリシー境界に1つ以上の「セキュリティタプル」を割り当てることができます。各セキュリティタプルは、セキュリティフレーバー（セクション2.2.1.1を参照）で構成されており、フレーバーがRPCSEC_GSSの場合は、GSS-APIメカニズムオブジェクト識別子（OID）、PROS-APIの保護品質、およびRPCSEC_GSSサービスです。"
    },
    {
      "indent": 0,
      "text": "2.6.2. SECINFO and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.2. secinfoとsecinfo_no_name."
    },
    {
      "indent": 3,
      "text": "The SECINFO and SECINFO_NO_NAME operations allow the client to determine, on a per-filehandle basis, what security tuple is to be used for server access. In general, the client will not have to use either operation except during initial communication with the server or when the client crosses security policy boundaries at the server. However, the server's policies may also change at any time and force the client to negotiate a new security tuple.",
      "ja": "secinfoとsecinfo_no_name操作により、クライアントはファイルハンドルごとに、サーバーアクセスにどのセキュリティタプルを使用するかを決定できます。一般に、クライアントは、サーバーとの最初の通信中、またはクライアントがサーバーのセキュリティポリシーの境界を横切るときを除いて、どちらの操作を使用する必要はありません。ただし、サーバーのポリシーはいつでも変更し、クライアントに新しいセキュリティタプルを交渉するように強制することもできます。"
    },
    {
      "indent": 3,
      "text": "Where the use of different security tuples would affect the type of access that would be allowed if a request was sent over the same connection used for the SECINFO or SECINFO_NO_NAME operation (e.g., read-only vs. read-write) access, security tuples that allow greater access should be presented first. Where the general level of access is the same and different security flavors limit the range of principals whose privileges are recognized (e.g., allowing or disallowing root access), flavors supporting the greatest range of principals should be listed first.",
      "ja": "さまざまなセキュリティタプルの使用が、SECINFOまたはSECINFO_NO_NAME操作（例えば、読み取り専用VS / Read-Write）アクセス、セキュリティタプルに使用されるのと同じ接続で要求が送信された場合に許可されるアクセスの種類に影響を与えるでしょう。最初に大きなアクセスを許可する必要があります。一般的なアクセスが同じであり、異なるセキュリティフレーバーが、特権が認識されているプリンシパルの範囲を制限します（例えば、rootアクセスを許可または禁止）、最大の範囲のプリンシパルをサポートするフレーバーを最初にリストする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6.3. Security Error",
      "section_title": true,
      "ja": "2.6.3. セキュリティエラー"
    },
    {
      "indent": 3,
      "text": "Based on the assumption that each NFSv4.1 client and server MUST support a minimum set of security (i.e., Kerberos V5 under RPCSEC_GSS), the NFS client will initiate file access to the server with one of the minimal security tuples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security tuple currently being used contravenes the server's security policy. The client is then responsible for determining (see Section 2.6.3.1) what security tuples are available at the server and choosing one that is appropriate for the client.",
      "ja": "各NFSV4.1クライアントとサーバーが最小セキュリティセット（すなわちRPCSEC_GSSの下のKerberos V5）をサポートしなければならないという仮定に基づいて、NFSクライアントは最小限のセキュリティタプルのうちの1つを持つサーバーへのファイルアクセスを開始します。サーバーとの通信中、クライアントはNFS4ERR_WRONGSECのNFSエラーを受信することがあります。このエラーにより、サーバーは、現在使用されているセキュリティタプルがサーバーのセキュリティポリシーを照らしていることをクライアントに通知できます。その場合、クライアントは決定を担当します（2.6.3.1項を参照）サーバーで利用可能なセキュリティタプルが利用可能であり、クライアントに適したものを選択するのかを選択します。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1. Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1. NFS4ERR_WRONGSEC、SECINFO、およびSECINFO_NO_NAMEを使用する"
    },
    {
      "indent": 3,
      "text": "This section explains the mechanics of NFSv4.1 security negotiation.",
      "ja": "このセクションでは、NFSV4.1セキュリティ交渉の力学について説明します。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1. Put Filehandle Operations",
      "section_title": true,
      "ja": "2.6.3.1.1. FileHandle Operationsを入れる"
    },
    {
      "indent": 3,
      "text": "The term \"put filehandle operation\" refers to PUTROOTFH, PUTPUBFH, PUTFH, and RESTOREFH. Each of the subsections herein describes how the server handles a subseries of operations that starts with a put filehandle operation.",
      "ja": "「FileHandle操作を入れる」という用語は、Putrootfh、Putpubfh、Putfh、およびRestoreFHを指します。本明細書の各サブセクションは、プットファイルハンドル操作で始まる操作のサマリーを処理する方法を説明する。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.1. Put Filehandle Operation + SAVEFH",
      "section_title": true,
      "ja": "2.6.3.1.1.1. FileHandleオペレーションSavefhを入れる"
    },
    {
      "indent": 3,
      "text": "The client is saving a filehandle for a future RESTOREFH, LINK, or RENAME. SAVEFH MUST NOT return NFS4ERR_WRONGSEC. To determine whether or not the put filehandle operation returns NFS4ERR_WRONGSEC, the server implementation pretends SAVEFH is not in the series of operations and examines which of the situations described in the other subsections of Section 2.6.3.1.1 apply.",
      "ja": "クライアントは、将来のRestoreFH、Link、またはRenameのためにファイルハンドルを保存しています。SavefhはNFS4ERR_WRONGSECを返さないでください。PUTファイルハンドル操作がNFS4ERR_WRONGSECを返すかどうかを判断するために、サーバー実装はSAVEFHが一連の操作ではなく、セクション2.6.3.1.1の他のサブセクションで説明されている状況のどれが適用されているかを調べます。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.2. Two or More Put Filehandle Operations",
      "section_title": true,
      "ja": "2.6.3.1.1.2. 2つ以上のファイルハンドル操作"
    },
    {
      "indent": 3,
      "text": "For a series of N put filehandle operations, the server MUST NOT return NFS4ERR_WRONGSEC to the first N-1 put filehandle operations. The Nth put filehandle operation is handled as if it is the first in a subseries of operations. For example, if the server received a COMPOUND request with this series of operations -- PUTFH, PUTROOTFH, LOOKUP -- then the PUTFH operation is ignored for NFS4ERR_WRONGSEC purposes, and the PUTROOTFH, LOOKUP subseries is processed as according to Section 2.6.3.1.1.3.",
      "ja": "一連のn個のファイルハンドル操作の場合、サーバはNFS4ERR_WRONGSECを最初のN-1に返却してはいけませんFileHandle操作に必要です。NTH PUT FILEHANDLE操作は、あたかもその操作のサマリーの最初のものであるかのように処理されます。たとえば、サーバーがこの一連の操作で複合要求を受信した場合は、PUTFH、PUTROOTFH、LOOKUP  - その後、PUTFH操作はNFS4ERR_WRONGSECの目的で無視され、PUTROOTFH、ルックアップサブシリーズはセクション2.6.3.1に従って処理されます。1.3。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.3. Put Filehandle Operation + LOOKUP (or OPEN of an Existing Name)",
      "ja": "2.6.3.1.1.3. FileHandleの操作検索（または既存の名前の開き）を入れる"
    },
    {
      "indent": 3,
      "text": "This situation also applies to a put filehandle operation followed by a LOOKUP or an OPEN operation that specifies an existing component name.",
      "ja": "このような状況は、PUT FileHandleの操作に続くルックアップまたは既存のコンポーネント名を指定するオープン操作にも適用されます。"
    },
    {
      "indent": 3,
      "text": "In this situation, the client is potentially crossing a security policy boundary, and the set of security tuples the parent directory supports may differ from those of the child. The server implementation may decide whether to impose any restrictions on security policy administration. There are at least three approaches (sec_policy_child is the tuple set of the child export, sec_policy_parent is that of the parent).",
      "ja": "この状況では、クライアントはセキュリティポリシーの境界を犠牲にしており、セキュリティタプルのセットは親ディレクトリサポートが子のそれと異なる可能性があります。サーバー実装は、セキュリティポリシー管理に制限を課すかどうかを決定することができます。少なくとも3つのアプローチがあります（SEC_POLICY_CHILDは、子エクスポートのタプルセットです.SEC_POLICY_PARENTは親の）。"
    },
    {
      "indent": 3,
      "text": "(a) sec_policy_child <= sec_policy_parent (<= for subset). This means that the set of security tuples specified on the security policy of a child directory is always a subset of its parent directory.",
      "ja": "（a）sec_policy_child <= sec_policy_parent（<=サブセットの場合）。つまり、子ディレクトリのセキュリティポリシーで指定されたセキュリティタプルのセットは、常にその親ディレクトリのサブセットです。"
    },
    {
      "indent": 3,
      "text": "(b)  sec_policy_child ^ sec_policy_parent != {} (^ for intersection,\n     {} for the empty set).  This means that the set of security\n     tuples specified on the security policy of a child directory\n     always has a non-empty intersection with that of the parent.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(c)  sec_policy_child ^ sec_policy_parent == {}.  This means that the\n     set of security tuples specified on the security policy of a\n     child directory may not intersect with that of the parent.  In\n     other words, there are no restrictions on how the system\n     administrator may set up these tuples.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In order for a server to support approaches (b) (for the case when a client chooses a flavor that is not a member of sec_policy_parent) and (c), the put filehandle operation cannot return NFS4ERR_WRONGSEC when there is a security tuple mismatch. Instead, it should be returned from the LOOKUP (or OPEN by existing component name) that follows.",
      "ja": "サーバーがアプローチ（B）をサポートするために（クライアントがSEC_POLICY_PARENTのメンバーではないフレーバーを選択した場合の場合）、セキュリティタプルの不一致がある場合は、PUTファイルハンドル操作はNFS4ERR_WRONGSECを返すことはできません。代わりに、次のようなルックアップ（または既存のコンポーネント名で開く）から返されるべきです。"
    },
    {
      "indent": 3,
      "text": "Since the above guideline does not contradict approach (a), it should be followed in general. Even if approach (a) is implemented, it is possible for the security tuple used to be acceptable for the target of LOOKUP but not for the filehandles used in the put filehandle operation. The put filehandle operation could be a PUTROOTFH or PUTPUBFH, where the client cannot know the security tuples for the root or public filehandle. Or the security policy for the filehandle used by the put filehandle operation could have changed since the time the filehandle was obtained.",
      "ja": "上記のガイドラインはアプローチ（A）と矛盾しないので、それは一般的に従うべきです。アプローチ（a）が実装されていても、セキュリティタプルがルックアップのターゲットに対して許容されるが、PUTファイルハンドル操作で使用されるファイルハンドルに対しては受け入れられないことが可能である。PUT FileHandle操作はPUTROOTFHまたはPUTPUBFHで、クライアントはルートまたはパブリックファイルハンドルのセキュリティタプルを知ることができません。またはPUT FileHandle操作で使用されているFileHandleのセキュリティポリシーは、ファイルハンドルが取得された時刻から変更された可能性があります。"
    },
    {
      "indent": 3,
      "text": "Therefore, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to the put filehandle operation if the operation is immediately followed by a LOOKUP or an OPEN by component name.",
      "ja": "したがって、操作に直ちにルックアップまたはコンポーネント名が開くと、PUTファイルハンドル操作に応答してNFSV4.1サーバーを返さないでください。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.4. Put Filehandle Operation + LOOKUPP",
      "section_title": true,
      "ja": "2.6.3.1.1.4. FileHandle操作ルックアップを入れる"
    },
    {
      "indent": 3,
      "text": "Since SECINFO only works its way down, there is no way LOOKUPP can return NFS4ERR_WRONGSEC without SECINFO_NO_NAME. SECINFO_NO_NAME solves this issue via style SECINFO_STYLE4_PARENT, which works in the opposite direction as SECINFO. As with Section 2.6.3.1.1.3, a put filehandle operation that is followed by a LOOKUPP MUST NOT return NFS4ERR_WRONGSEC. If the server does not support SECINFO_NO_NAME, the client's only recourse is to send the put filehandle operation, LOOKUPP, GETFH sequence of operations with every security tuple it supports.",
      "ja": "SecInfoはその途中でのみ機能するため、Lookuppがsecinfo_no_nameなしでNFS4ERR_WRONGSECを返す方法はありません。secInfo_no_nameはスタイルSecInfo_Style4_Parentを介してこの問題を解決します。これはSecInfoとして反対方向に機能します。セクション2.6.3.1.1.3と同様に、Lookuppが続くPUTファイルハンドル操作はNFS4ERR_WRONGSECを返してはいけません。サーバーがSECINFO_NO_NAMEをサポートしていない場合、クライアントの専用契約は、PUT FileHandle操作、Lookupp、GetFHのgetfhの順序をサポートするすべてのセキュリティタプルを使用して送信します。"
    },
    {
      "indent": 3,
      "text": "Regardless of whether SECINFO_NO_NAME is supported, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to a put filehandle operation if the operation is immediately followed by a LOOKUPP.",
      "ja": "SECINFO_NO_NAMEがサポートされているかどうかにかかわらず、操作が直ちにLookUppが続く場合に、PUTファイルハンドル操作に応答してNFSV4.1サーバーを返さないでください。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.5. Put Filehandle Operation + SECINFO/SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1.1.5. fileHandleオペレーションSecInfo / secInfo_no_nameを入れる"
    },
    {
      "indent": 3,
      "text": "A security-sensitive client is allowed to choose a strong security tuple when querying a server to determine a file object's permitted security tuples. The security tuple chosen by the client does not have to be included in the tuple list of the security policy of either the parent directory indicated in the put filehandle operation or the child file object indicated in SECINFO (or any parent directory indicated in SECINFO_NO_NAME). Of course, the server has to be configured for whatever security tuple the client selects; otherwise, the request will fail at the RPC layer with an appropriate authentication error.",
      "ja": "セキュリティに敏感なクライアントは、ファイルオブジェクトの許可されたセキュリティタプルを判断するためにサーバーに照会するときに強力なセキュリティタプルを選択できます。クライアントによって選択されたセキュリティタプルは、PUTファイルハンドル操作に示されている親ディレクトリまたはsecinfoに示されている子ファイルオブジェクト（またはsecinfo_no_nameで示されている親ディレクトリ）のセキュリティポリシーのタプルリストに含める必要はありません。もちろん、クライアントが選択するセキュリティタプルでは、サーバーを設定する必要があります。それ以外の場合、要求は適切な認証エラーでRPCレイヤで失敗します。"
    },
    {
      "indent": 3,
      "text": "In theory, there is no connection between the security flavor used by SECINFO or SECINFO_NO_NAME and those supported by the security policy. But in practice, the client may start looking for strong flavors from those supported by the security policy, followed by those in the REQUIRED set.",
      "ja": "理論的には、secinfoまたはsecinfo_no_nameによって使用されるセキュリティフレーバーとセキュリティポリシーによってサポートされているものとの間には接続はありません。しかし実際には、クライアントは、セキュリティポリシーによってサポートされているものから強い風味を探すことができ、続いて必要なセットのものが続くことがあります。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to a put filehandle operation that is immediately followed by SECINFO or SECINFO_NO_NAME. The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC from SECINFO or SECINFO_NO_NAME.",
      "ja": "NFSV4.1サーバーは、SecInfoまたはSecInfo_no_nameが続くPUT FileHandle操作にNFS4ERR_WRONGSECを返さないでください。NFSV4.1サーバーはSECINFOまたはSECINFO_NO_NAMEからNFS4ERR_WRONGSECを返さないでください。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.6. Put Filehandle Operation + Nothing",
      "section_title": true,
      "ja": "2.6.3.1.1.6. FileHandle操作を入れて"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC.",
      "ja": "NFSV4.1サーバーはNFS4ERR_WRONGSECを返さないでください。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.7. Put Filehandle Operation + Anything Else",
      "section_title": true,
      "ja": "2.6.3.1.1.7. FileHandle操作を他のものにしてください"
    },
    {
      "indent": 3,
      "text": "\"Anything Else\" includes OPEN by filehandle.",
      "ja": "「他の何でも」はFileHandleによって開かれています。"
    },
    {
      "indent": 3,
      "text": "The security policy enforcement applies to the filehandle specified in the put filehandle operation. Therefore, the put filehandle operation MUST return NFS4ERR_WRONGSEC when there is a security tuple mismatch. This avoids the complexity of adding NFS4ERR_WRONGSEC as an allowable error to every other operation.",
      "ja": "セキュリティポリシーの強制は、PUT FileHandle操作で指定されたファイルハンドルに適用されます。そのため、セキュリティタプルの不一致がある場合は、PUTファイルハンドル操作がNFS4ERR_WRONGSECを返す必要があります。これにより、NFS4ERR_WRONGSECを他のすべての操作に許容エラーとして追加することが複雑になります。"
    },
    {
      "indent": 3,
      "text": "A COMPOUND containing the series put filehandle operation + SECINFO_NO_NAME (style SECINFO_STYLE4_CURRENT_FH) is an efficient way for the client to recover from NFS4ERR_WRONGSEC.",
      "ja": "シリーズPUT FILE Handle Operation SECINFO_NO_NAME（STYLE SECINFO_STYLE4_CURRENT_FH）を含むコンパウンドは、クライアントがNFS4ERR_WRONGSECから回復するための効率的な方法です。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to any operation other than a put filehandle operation, LOOKUP, LOOKUPP, and OPEN (by component name).",
      "ja": "NFSV4.1サーバーは、PUT FILEHANDLE操作、ルックアップ、LookUpp、Open（コンポーネント名）以外の操作にNFS4ERR_WRONGSECを返さないでください。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.8. Operations after SECINFO and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1.1.8. secinfoとsecinfo_no_nameの後の操作"
    },
    {
      "indent": 3,
      "text": "Suppose a client sends a COMPOUND procedure containing the series SEQUENCE, PUTFH, SECINFO_NONAME, READ, and suppose the security tuple used does not match that required for the target file. By rule (see Section 2.6.3.1.1.5), neither PUTFH nor SECINFO_NO_NAME can return NFS4ERR_WRONGSEC. By rule (see Section 2.6.3.1.1.7), READ cannot return NFS4ERR_WRONGSEC. The issue is resolved by the fact that SECINFO and SECINFO_NO_NAME consume the current filehandle (note that this is a change from NFSv4.0). This leaves no current filehandle for READ to use, and READ returns NFS4ERR_NOFILEHANDLE.",
      "ja": "クライアントがシリーズシーケンス、putfh、secinfo_noname、読み取り、使用されているセキュリティタプルがターゲットファイルに必要なものと一致しないとします。ルール（2.6.3.1.1.5項参照）では、putfhもsecinfo_no_nameもNFS4ERR_WRONGSECを返すことはできません。規則別（2.6.3.1.1.7項を参照）、読み取りはNFS4ERR_WRONGSECを返すことができません。この問題は、secinfoとsecinfo_no_nameが現在のファイルハンドルを消費するという事実によって解決されます（これはNFSv4.0からの変更です）。これにより、読み取りやすく読み取りのための現在のファイルハンドルは残りません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.2. LINK and RENAME",
      "section_title": true,
      "ja": "2.6.3.1.2. リンクと名前の変更"
    },
    {
      "indent": 3,
      "text": "The LINK and RENAME operations use both the current and saved filehandles. Technically, the server MAY return NFS4ERR_WRONGSEC from LINK or RENAME if the security policy of the saved filehandle rejects the security flavor used in the COMPOUND request's credentials. If the server does so, then if there is no intersection between the security policies of saved and current filehandles, this means that it will be impossible for the client to perform the intended LINK or RENAME operation.",
      "ja": "リンクと名前変更操作は、現在のファイルハンドルと保存されたファイルハンドルの両方を使用します。技術的には、保存されたファイルハンドルのセキュリティポリシーが複合要求の認証情報で使用されているセキュリティフレーバを拒否した場合、サーバーはリンクからNFS4ERR_WRONGSECを返します。サーバーがそうすると、保存されたファイルハンドルのセキュリティポリシーの間に交差点がない場合、これはクライアントが意図されたリンクまたは名前の変更操作を実行することが不可能になることを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the client sends this COMPOUND request: SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME \"c\" \"d\", where filehandles bFH and aFH refer to different directories. Suppose no common security tuple exists between the security policies of aFH and bFH. If the client sends the request using credentials acceptable to bFH's security policy but not aFH's policy, then the PUTFH aFH operation will fail with NFS4ERR_WRONGSEC. After a SECINFO_NO_NAME request, the client sends SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME \"c\" \"d\", using credentials acceptable to aFH's security policy but not bFH's policy. The server returns NFS4ERR_WRONGSEC on the RENAME operation.",
      "ja": "たとえば、クライアントがこの複合要求を送信します。シーケンス、PUTFH BFH、SAVEFH、PUTFH AFH、ファイルハンドルBFHとAFHの名前を変更します。ここで、FileHandles BFHとAFHは別のディレクトリを参照します。AFHとBFHのセキュリティポリシーの間に共通のセキュリティタプルが存在しないとします。クライアントがBFHのセキュリティポリシーに受け入れられるがAFHのポリシーを使用して要求を送信した場合、PUTFHAFH操作はNFS4ERR_WRONGSECで失敗します。secInfo_no_name要求の後、クライアントは、AFHのセキュリティポリシーに受け入れられるがBFHのポリシーに受け入れられる認証情報を使用して、クライアントはシーケンス、PUTFH BFH、SAVEFH、PUTFH AFHを送信します。サーバーは名前変更操作でNFS4ERR_WRONGSECを返します。"
    },
    {
      "indent": 3,
      "text": "To prevent a client from an endless sequence of a request containing LINK or RENAME, followed by a request containing SECINFO_NO_NAME or SECINFO, the server MUST detect when the security policies of the current and saved filehandles have no mutually acceptable security tuple, and MUST NOT return NFS4ERR_WRONGSEC from LINK or RENAME in that situation. Instead the server MUST do one of two things:",
      "ja": "リンクまたは名前を変更したリクエストの無限のシーケンスからのクライアントが続いて、その後にsecinfo_no_nameまたはsecinfoを含むリクエストが続かないようにするには、現在のファイルハンドルと保存されたファイルハンドルのセキュリティポリシーには相互に許容されるセキュリティタプルがない場合にサーバーが検出する必要があります。リンクからNFS4ERR_WRONGSECその状況のリンクまたは名前の変更。代わりに、サーバーは2つのことのうちの1つを実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The server can return NFS4ERR_XDEV.",
      "ja": "* サーバーはNFS4ERR_XDEVを返すことができます。"
    },
    {
      "indent": 3,
      "text": "* The server can allow the security policy of the current filehandle to override that of the saved filehandle, and so return NFS4_OK.",
      "ja": "* サーバーは、現在のファイルハンドルのセキュリティポリシーを保存したファイルハンドルのそれをオーバーライドすることを許可することができますので、NFS4_OKを返します。"
    },
    {
      "indent": 0,
      "text": "2.7. Minor Versioning",
      "section_title": true,
      "ja": "2.7. マイナーバージョン管理"
    },
    {
      "indent": 3,
      "text": "To address the requirement of an NFS protocol that can evolve as the need arises, the NFSv4.1 protocol contains the rules and framework to allow for future minor changes or versioning.",
      "ja": "必要に応じて進化する可能性があるNFSプロトコルの要件に対処するために、NFSV4.1プロトコルには、将来のマイナーな変更やバージョン管理を可能にするための規則とフレームワークが含まれています。"
    },
    {
      "indent": 3,
      "text": "The base assumption with respect to minor versioning is that any future accepted minor version will be documented in one or more Standards Track RFCs. Minor version 0 of the NFSv4 protocol is represented by [37], and minor version 1 is represented by this RFC. The COMPOUND and CB_COMPOUND procedures support the encoding of the minor version being requested by the client.",
      "ja": "マイナーなバージョン管理に関する基本的な仮定は、将来の受け入れられたマイナーバージョンが1つ以上の標準トラックRFCに文書化されることです。NFSV4プロトコルのマイナーバージョン0は[37]で表され、マイナーバージョン1はこのRFCによって表されます。複合およびCB_COMPOUND手順は、クライアントによって要求されているマイナーバージョンのエンコードをサポートします。"
    },
    {
      "indent": 3,
      "text": "The following items represent the basic rules for the development of minor versions. Note that a future minor version may modify or add to the following rules as part of the minor version definition.",
      "ja": "以下の項目は、マイナーバージョンの開発の基本的な規則を表しています。将来のマイナーバージョンは、マイナーバージョン定義の一部として次の規則を変更または追加することがあります。"
    },
    {
      "indent": 3,
      "text": "1. Procedures are not added or deleted.",
      "ja": "1. 手順は追加または削除されません。"
    },
    {
      "indent": 8,
      "text": "To maintain the general RPC model, NFSv4 minor versions will not add to or delete procedures from the NFS program.",
      "ja": "一般的なRPCモデルを維持するために、NFSv4マイナーバージョンはNFSプログラムの手順に追加または削除されません。"
    },
    {
      "indent": 3,
      "text": "2. Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.",
      "ja": "2. マイナーバージョンは、複合およびCB_COMPOUND手順に操作を追加することができます。"
    },
    {
      "indent": 8,
      "text": "The addition of operations to the COMPOUND and CB_COMPOUND procedures does not affect the RPC model.",
      "ja": "複合およびCB_COMPOUND手順への操作の追加は、RPCモデルに影響を与えません。"
    },
    {
      "indent": 8,
      "text": "* Minor versions may append attributes to the bitmap4 that represents sets of attributes and to the fattr4 that represents sets of attribute values.",
      "ja": "* マイナーバージョンは、属性のセットと属性値のセットを表すFATTR4に属性を追加することがあります。"
    },
    {
      "indent": 11,
      "text": "This allows for the expansion of the attribute model to allow for future growth or adaptation.",
      "ja": "これにより、将来の成長や適応を可能にするための属性モデルの拡張が可能になります。"
    },
    {
      "indent": 8,
      "text": "* Minor version X must append any new attributes after the last documented attribute.",
      "ja": "* マイナーバージョンXは、最後の文書化された属性の後に新しい属性を追加する必要があります。"
    },
    {
      "indent": 11,
      "text": "Since attribute results are specified as an opaque array of per-attribute, XDR-encoded results, the complexity of adding new attributes in the midst of the current definitions would be too burdensome.",
      "ja": "属性の結果は属性ごとのXDR符号化された結果の不透明な配列として指定されているため、現在の定義の中で新しい属性を追加する複雑さは非常に大きすぎるでしょう。"
    },
    {
      "indent": 3,
      "text": "3. Minor versions must not modify the structure of an existing operation's arguments or results.",
      "ja": "3. マイナーバージョンは、既存の操作の引数または結果の構造を変更してはなりません。"
    },
    {
      "indent": 8,
      "text": "Again, the complexity of handling multiple structure definitions for a single operation is too burdensome. New operations should be added instead of modifying existing structures for a minor version.",
      "ja": "やはり、単一の操作のための複数の構造定義を処理する複雑さはあまりにも面倒なことです。マイナーバージョンの既存の構造体を変更する代わりに、新しい操作を追加する必要があります。"
    },
    {
      "indent": 8,
      "text": "This rule does not preclude the following adaptations in a minor version:",
      "ja": "この規則は、マイナーバージョンで次の適応を排除しません。"
    },
    {
      "indent": 8,
      "text": "* adding bits to flag fields, such as new attributes to GETATTR's bitmap4 data type, and providing corresponding variants of opaque arrays, such as a notify4 used together with such bitmaps",
      "ja": "* GetAttrのBitmap4データ型への新しい属性などのFlagフィールドにビットを追加し、そのようなビットマップと一緒に使用されるNotify4のような不透明配列の亜種を提供します。"
    },
    {
      "indent": 8,
      "text": "* adding bits to existing attributes like ACLs that have flag words",
      "ja": "* フラグ単語を持つACLのような既存の属性にビットを追加する"
    },
    {
      "indent": 8,
      "text": "* extending enumerated types (including NFS4ERR_*) with new values",
      "ja": "* 新しい値で列挙型（NFS4ERR_ *を含む）の拡張"
    },
    {
      "indent": 8,
      "text": "* adding cases to a switched union",
      "ja": "* 交換ユニオンにケースを追加する"
    },
    {
      "indent": 3,
      "text": "4. Minor versions must not modify the structure of existing attributes.",
      "ja": "4. マイナーバージョンは、既存の属性の構造を変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "5. Minor versions must not delete operations.",
      "ja": "5. マイナーバージョンは操作を削除しないでください。"
    },
    {
      "indent": 8,
      "text": "This prevents the potential reuse of a particular operation \"slot\" in a future minor version.",
      "ja": "これにより、将来のマイナーバージョンの特定の操作「スロット」の潜在的な再利用が防止されます。"
    },
    {
      "indent": 3,
      "text": "6. Minor versions must not delete attributes.",
      "ja": "6. マイナーバージョンは属性を削除しないでください。"
    },
    {
      "indent": 3,
      "text": "7. Minor versions must not delete flag bits or enumeration values.",
      "ja": "7. マイナーバージョンは、フラグビットまたは列挙値を削除しないでください。"
    },
    {
      "indent": 3,
      "text": "8. Minor versions may declare an operation MUST NOT be implemented.",
      "ja": "8. マイナーバージョンは、操作を宣言してはいけません。"
    },
    {
      "indent": 8,
      "text": "Specifying that an operation MUST NOT be implemented is equivalent to obsoleting an operation. For the client, it means that the operation MUST NOT be sent to the server. For the server, an NFS error can be returned as opposed to \"dropping\" the request as an XDR decode error. This approach allows for the obsolescence of an operation while maintaining its structure so that a future minor version can reintroduce the operation.",
      "ja": "操作を実装していなければならないことを指定することは、操作を廃止するのと同じです。クライアントの場合、それは操作がサーバーに送信されてはならないことを意味します。サーバーの場合、要求をXDRデコードエラーとしての「ドロップ」とは対照的に、NFSエラーを返すことができます。このアプローチにより、将来のマイナーバージョンが操作を再導入することができるようにその構造を維持しながら動作の陳腐化を可能にする。"
    },
    {
      "indent": 8,
      "text": "1. Minor versions may declare that an attribute MUST NOT be implemented.",
      "ja": "1. マイナーバージョンは、属性が実装されてはならないことを宣言することができます。"
    },
    {
      "indent": 8,
      "text": "2. Minor versions may declare that a flag bit or enumeration value MUST NOT be implemented.",
      "ja": "2. マイナーバージョンは、フラグビットまたは列挙値を実装してはならないことを宣言することができます。"
    },
    {
      "indent": 3,
      "text": "9. Minor versions may downgrade features from REQUIRED to RECOMMENDED, or RECOMMENDED to OPTIONAL.",
      "ja": "9. マイナーバージョンは、必須から推奨されているのをダウングレードすること、またはオプションに推奨されることがあります。"
    },
    {
      "indent": 3,
      "text": "10. Minor versions may upgrade features from OPTIONAL to RECOMMENDED, or RECOMMENDED to REQUIRED.",
      "ja": "10. マイナーバージョンは、推奨されている、または必要とされることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "11. A client and server that support minor version X SHOULD support minor versions zero through X-1 as well.",
      "ja": "11. マイナーバージョンXをサポートするクライアントとサーバーは、マイナーバージョンゼロからX-1をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "12. Except for infrastructural changes, a minor version must not introduce REQUIRED new features.",
      "ja": "12. インフラストラクチャの変更を除いて、マイナーバージョンは必要な新機能を導入してはいけません。"
    },
    {
      "indent": 8,
      "text": "This rule allows for the introduction of new functionality and forces the use of implementation experience before designating a feature as REQUIRED. On the other hand, some classes of features are infrastructural and have broad effects. Allowing infrastructural features to be RECOMMENDED or OPTIONAL complicates implementation of the minor version.",
      "ja": "この規則は、必要に応じて機能を指定する前に、新しい機能の導入を可能にし、実装経験の使用を強制します。一方、いくつかのクラスの機能はインフラストラクチャーであり、広範な効果があります。インフラストラクチャー機能を推奨またはオプションの可能性を推奨することは、マイナーバージョンの実装を複雑にします。"
    },
    {
      "indent": 3,
      "text": "13. A client MUST NOT attempt to use a stateid, filehandle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.",
      "ja": "13. マイナーバージョンyを持つ別の複合手順で、マイナーバージョンXを使用して、マイナーバージョンXを使用して、StateID、FileHandle、または類似の返品オブジェクトを、マイナーバージョンXで使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.8. Non-RPC-Based Security Services",
      "section_title": true,
      "ja": "2.8. 非RPCベースのセキュリティサービス"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.2.1.1.1.1, NFSv4.1 relies on RPC for identification, authentication, integrity, and privacy. NFSv4.1 itself provides or enables additional security services as described in the next several subsections.",
      "ja": "セクション2.2.1.1.1.1で説明されているように、NFSv4.1は識別、認証、整合性、およびプライバシーのためのRPCに依存しています。NFSV4.1自体は、次のいくつかのサブセクションで説明されているように、追加のセキュリティサービスを提供または有効にします。"
    },
    {
      "indent": 0,
      "text": "2.8.1. Authorization",
      "section_title": true,
      "ja": "2.8.1. 承認"
    },
    {
      "indent": 3,
      "text": "Authorization to access a file object via an NFSv4.1 operation is ultimately determined by the NFSv4.1 server. A client can predetermine its access to a file object via the OPEN (Section 18.16) and the ACCESS (Section 18.1) operations.",
      "ja": "NFSV4.1操作を介してファイルオブジェクトにアクセスするための許可は、最終的にNFSV4.1サーバーによって決定されます。クライアントは、オープン（18.16節）とアクセス（セクション18.1）操作を介してファイルオブジェクトへのアクセスを事前に決定できます。"
    },
    {
      "indent": 3,
      "text": "Principals with appropriate access rights can modify the authorization on a file object via the SETATTR (Section 18.30) operation. Attributes that affect access rights include mode, owner, owner_group, acl, dacl, and sacl. See Section 5.",
      "ja": "適切なアクセス権を持つプリンシパルは、SETATTR（セクション18.30）操作を介してファイルオブジェクトの許可を変更できます。アクセス権に影響を与える属性には、モード、所有者、owner_group、ACL、DACL、およびSACLが含まれます。5セクション5を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.8.2. Auditing",
      "section_title": true,
      "ja": "2.8.2. 監査"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides auditing on a per-file object basis, via the acl and sacl attributes as described in Section 6. It is outside the scope of this specification to specify audit log formats or management policies.",
      "ja": "NFSV4.1は、セクション6で説明されているACLおよびSACLの属性を介して、ファイルごとのオブジェクトごとの監査を提供します。この仕様の範囲外です。監査ログのフォーマットまたは管理ポリシーを指定するには、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.8.3. Intrusion Detection",
      "section_title": true,
      "ja": "2.8.3. 侵入検知"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides alarm control on a per-file object basis, via the acl and sacl attributes as described in Section 6. Alarms may serve as the basis for intrusion detection. It is outside the scope of this specification to specify heuristics for detecting intrusion via alarms.",
      "ja": "NFSV4.1は、セクション6で説明されているACLおよびSACL属性を介して、ファイルごとのオブジェクトごとにアラーム制御を提供します。アラームは侵入検知の基礎として機能することがあります。アラームによる侵入を検出するためのヒューリスティックを指定するのは、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.9. Transport Layers",
      "section_title": true,
      "ja": "2.9. 輸送層"
    },
    {
      "indent": 0,
      "text": "2.9.1. REQUIRED and RECOMMENDED Properties of Transports",
      "section_title": true,
      "ja": "2.9.1. トランスポートの必須で推奨されるプロパティ"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 works over Remote Direct Memory Access (RDMA) and non-RDMA-based transports with the following attributes:",
      "ja": "NFSV4.1は、次の属性を持つリモートダイレクトメモリアクセス（RDMA）と非RDMAベースのトランスポートを介して動作します。"
    },
    {
      "indent": 3,
      "text": "* The transport supports reliable delivery of data, which NFSv4.1 requires but neither NFSv4.1 nor RPC has facilities for ensuring [41].",
      "ja": "* トランスポートは信頼できるデータの配信をサポートしています。これらのNFSV4.1は必要ですが、NFSV4.1もRPCも確実にするための機能を持っていません。"
    },
    {
      "indent": 3,
      "text": "* The transport delivers data in the order it was sent. Ordered delivery simplifies detection of transmit errors, and simplifies the sending of arbitrary sized requests and responses via the record marking protocol [3].",
      "ja": "* トランスポートは送信された順序でデータを配信します。順序付けられた配信は送信エラーの検出を簡素化し、レコードマーキングプロトコルを介して任意のサイズの要求と応答の送信を簡素化します[3]。"
    },
    {
      "indent": 3,
      "text": "Where an NFSv4.1 implementation supports operation over the IP network protocol, any transport used between NFS and IP MUST be among the IETF-approved congestion control transport protocols. At the time this document was written, the only two transports that had the above attributes were TCP and the Stream Control Transmission Protocol (SCTP). To enhance the possibilities for interoperability, an NFSv4.1 implementation MUST support operation over the TCP transport protocol.",
      "ja": "NFSv4.1の実装がIPネットワークプロトコルを介した操作をサポートしている場合、NFSとIPの間で使用されるトランスポートは、IETF承認の輻輳制御トランスポートプロトコルの中にある必要があります。この文書が書かれた時点では、上記の属性を持つ唯一の輸送はTCPとストリーム制御伝送プロトコル（SCTP）でした。相互運用性の可能性を高めるために、NFSV4.1の実装はTCPトランスポートプロトコルに対する操作をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Even if NFSv4.1 is used over a non-IP network protocol, it is RECOMMENDED that the transport support congestion control.",
      "ja": "NFSV4.1が非IPネットワークプロトコルで使用されていても、トランスポートが輻輳制御をサポートすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It is permissible for a connectionless transport to be used under NFSv4.1; however, reliable and in-order delivery of data combined with congestion control by the connectionless transport is REQUIRED. As a consequence, UDP by itself MUST NOT be used as an NFSv4.1 transport. NFSv4.1 assumes that a client transport address and server transport address used to send data over a transport together constitute a connection, even if the underlying transport eschews the concept of a connection.",
      "ja": "コネクションレストランスポートをNFSV4.1の下で使用することは許可されています。しかしながら、コネクションレストランスポートによる輻輳制御と組み合わされたデータの信頼性および順序の配信が必要です。結果として、UDPそれ自体はNFSV4.1トランスポートとして使用してはいけません。NFSV4.1は、基礎となるトランスポートが接続の概念を急上昇させても、トランスポートに介してデータを送信するために使用されるクライアントトランスポートアドレスとサーバーのトランスポートアドレスが接続を構成していると想定しています。"
    },
    {
      "indent": 0,
      "text": "2.9.2. Client and Server Transport Behavior",
      "section_title": true,
      "ja": "2.9.2. クライアントとサーバーのトランスポート動作"
    },
    {
      "indent": 3,
      "text": "If a connection-oriented transport (e.g., TCP) is used, the client and server SHOULD use long-lived connections for at least three reasons:",
      "ja": "接続指向輸送（例えば、TCP）が使用されている場合、クライアントとサーバーは少なくとも3つの理由で長寿命の接続を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. This will prevent the weakening of the transport's congestion control mechanisms via short-lived connections.",
      "ja": "1. これにより、短命の接続による輸送の輻輳制御メカニズムの弱化が防止されます。"
    },
    {
      "indent": 3,
      "text": "2. This will improve performance for the WAN environment by eliminating the need for connection setup handshakes.",
      "ja": "2. これにより、接続設定ハンドシェイクの必要性を排除することで、WAN環境のパフォーマンスが向上します。"
    },
    {
      "indent": 3,
      "text": "3. The NFSv4.1 callback model differs from NFSv4.0, and requires the client and server to maintain a client-created backchannel (see Section 2.10.3.1) for the server to use.",
      "ja": "3. NFSV4.1コールバックモデルはNFSV4.0とは異なり、サーバーが使用するためのクライアント作成のバックチャネル（セクション2.10.3.1を参照）を維持するようにクライアントとサーバーが必要です。"
    },
    {
      "indent": 3,
      "text": "In order to reduce congestion, if a connection-oriented transport is used, and the request is not the NULL procedure:",
      "ja": "輻輳を減らすために、接続指向のトランスポートが使用されている場合、要求はNULLプロシージャではありません。"
    },
    {
      "indent": 3,
      "text": "* A requester MUST NOT retry a request unless the connection the request was sent over was lost before the reply was received.",
      "ja": "* 返信が受信される前に、要求が送信された接続が拒否されていない限り、リクエスタはリクエストを再試行してはいけません。"
    },
    {
      "indent": 3,
      "text": "* A replier MUST NOT silently drop a request, even if the request is a retry. (The silent drop behavior of RPCSEC_GSS [4] does not apply because this behavior happens at the RPCSEC_GSS layer, a lower layer in the request processing.) Instead, the replier SHOULD return an appropriate error (see Section 2.10.6.1), or it MAY disconnect the connection.",
      "ja": "* リクエストが再試行しても、リプライアはリクエストを黙ってはいけません。（RPCSEC_GSSのサイレントドロップ動作は、RPCSEC_GSSレイヤであるRPCSEC_GSSレイヤ、リクエスト処理内の下位レイヤーで発生するため、適用されません。）代わりに、レプリタは適切なエラーを返す（セクション2.10.6.1を参照）、またはそれを参照）接続を切断する可能性があります。"
    },
    {
      "indent": 3,
      "text": "When sending a reply, the replier MUST send the reply to the same full network address (e.g., if using an IP-based transport, the source port of the requester is part of the full network address) from which the requester sent the request. If using a connection-oriented transport, replies MUST be sent on the same connection from which the request was received.",
      "ja": "返信を送信するとき、レプリタは同じフルネットワークアドレスに返信を送信しなければなりません（例えば、IPベースのトランスポートを使用する場合、リクエスタの送信元ポートはリクエスタネットワークアドレスの一部である場合）、そこからリクエスタが要求を送信しました。接続指向のトランスポートを使用する場合、要求が受信されたのと同じ接続で返信を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a connection is dropped after the replier receives the request but before the replier sends the reply, the replier might have a pending reply. If a connection is established with the same source and destination full network address as the dropped connection, then the replier MUST NOT send the reply until the requester retries the request. The reason for this prohibition is that the requester MAY retry a request over a different connection (provided that connection is associated with the original request's session).",
      "ja": "リプライアがリクエストを受信した後に接続がドロップされたが、レプリアが返信を送信する前に、レプリアは保留中の応答を持つ可能性があります。ドロップされた接続として同じ送信元ネットワークアドレスと宛先フルネットワークアドレスを使用して接続が確立された場合、リクエスタが要求を再試行するまでレプリアは返信を送信してはなりません。この禁止の理由は、要求者が異なる接続を介してリクエストを再試行することができることです（接続が元の要求のセッションに関連付けられている場合）。"
    },
    {
      "indent": 3,
      "text": "When using RDMA transports, there are other reasons for not tolerating retries over the same connection:",
      "ja": "RDMAトランスポートを使用する場合、同じ接続で再試行を許容しない理由があります。"
    },
    {
      "indent": 3,
      "text": "* RDMA transports use \"credits\" to enforce flow control, where a credit is a right to a peer to transmit a message. If one peer were to retransmit a request (or reply), it would consume an additional credit. If the replier retransmitted a reply, it would certainly result in an RDMA connection loss, since the requester would typically only post a single receive buffer for each request. If the requester retransmitted a request, the additional credit consumed on the server might lead to RDMA connection failure unless the client accounted for it and decreased its available credit, leading to wasted resources.",
      "ja": "* RDMAトランスポートは、クレジットがメッセージを送信するピアの権利であるフロー制御を強制するために「クレジット」を使用します。1つのピアがリクエスト（または返信）を再送信することになった場合は、追加のクレジットを消費します。リクエスタが各要求に対して単一の受信バッファを投稿するだけなので、レプリタが応答を再送信した場合、それは確かにRDMA接続損失を引き起こすでしょう。リクエスタが要求を再送信した場合、クライアントがITを説明し、利用可能なクレジットが低下しない限り、サーバー上で消費された追加のクレジットがRDMA接続の失敗につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "* RDMA credits present a new issue to the reply cache in NFSv4.1. The reply cache may be used when a connection within a session is lost, such as after the client reconnects. Credit information is a dynamic property of the RDMA connection, and stale values must not be replayed from the cache. This implies that the reply cache contents must not be blindly used when replies are sent from it, and credit information appropriate to the channel must be refreshed by the RPC layer.",
      "ja": "* RDMAクレジットは、NFSV4.1の返信キャッシュに新しい問題を提示します。クライアントが再接続した後など、セッション内の接続が失われたときに返信キャッシュを使用できます。クレジット情報はRDMA接続の動的プロパティであり、古い値をキャッシュから再生しないでください。これは、返信が送信されたときに返信キャッシュの内容を盲目的に使用されてはならず、チャネルに適したクレジット情報はRPCレイヤによってリフレッシュされなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "In addition, as described in Section 2.10.6.2, while a session is active, the NFSv4.1 requester MUST NOT stop waiting for a reply.",
      "ja": "さらに、セクション2.10.6.2で説明されているように、セッションがアクティブな間に、NFSv4.1要求者は返信を待つのをやめてはいけません。"
    },
    {
      "indent": 0,
      "text": "2.9.3. Ports",
      "section_title": true,
      "ja": "2.9.3. 港"
    },
    {
      "indent": 3,
      "text": "Historically, NFSv3 servers have listened over TCP port 2049. The registered port 2049 [42] for the NFS protocol should be the default configuration. NFSv4.1 clients SHOULD NOT use the RPC binding protocols as described in [43].",
      "ja": "歴史的に、NFSV3サーバーはTCPポート2049を介してリッスンされています.NFSプロトコルの登録ポート2049 [42]は、デフォルトの構成になります。NFSV4.1クライアントは[43]に記載されているようにRPCバインディングプロトコルを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "2.10. Session",
      "section_title": true,
      "ja": "2.10. セッション"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 clients and servers MUST support and MUST use the session feature as described in this section.",
      "ja": "NFSV4.1クライアントとサーバーは、このセクションの説明に従ってセッション機能をサポートして使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.1. Motivation and Overview",
      "section_title": true,
      "ja": "2.10.1. 動機と概要"
    },
    {
      "indent": 3,
      "text": "Previous versions and minor versions of NFS have suffered from the following:",
      "ja": "以前のバージョンとマイナーバージョンのNFSは次のものを患っています。"
    },
    {
      "indent": 3,
      "text": "* Lack of support for Exactly Once Semantics (EOS). This includes lack of support for EOS through server failure and recovery.",
      "ja": "* 正確に一度だけサポートされていない（EOS）。これには、サーバーの障害と回復によるEOSのサポートの欠如が含まれています。"
    },
    {
      "indent": 3,
      "text": "* Limited callback support, including no support for sending callbacks through firewalls, and races between replies to normal requests and callbacks.",
      "ja": "* ファイアウォールを介してコールバックを送信するためのサポートを含まず、正規の要求とコールバックに対するレーセレスを含む、リマンスコールバックサポート。"
    },
    {
      "indent": 3,
      "text": "* Limited trunking over multiple network paths.",
      "ja": "* 複数のネットワーク経路上の限られたトランキング。"
    },
    {
      "indent": 3,
      "text": "* Requiring machine credentials for fully secure operation.",
      "ja": "* 完全に安全な操作のための機械認証情報を必要とします。"
    },
    {
      "indent": 3,
      "text": "Through the introduction of a session, NFSv4.1 addresses the above shortfalls with practical solutions:",
      "ja": "セッションの導入を通じて、NFSV4.1は実用的な解決策を持つ上記の不足に対処します。"
    },
    {
      "indent": 3,
      "text": "* EOS is enabled by a reply cache with a bounded size, making it feasible to keep the cache in persistent storage and enable EOS through server failure and recovery. One reason that previous revisions of NFS did not support EOS was because some EOS approaches often limited parallelism. As will be explained in Section 2.10.6, NFSv4.1 supports both EOS and unlimited parallelism.",
      "ja": "* EOSは有効なサイズの応答キャッシュによって有効になり、キャッシュを永続的なストレージに保持し、サーバーの障害と回復を通じてEOSを有効にします。NFSの以前の改訂がEOSをサポートしていなかった1つの理由は、EOSアプローチが頻繁に限られた並列処理によってあったためです。セクション2.10.6で説明されるように、NFSV4.1はEOSと無制限の並列処理の両方をサポートしています。"
    },
    {
      "indent": 3,
      "text": "* The NFSv4.1 client (defined in Section 1.7) creates transport connections and provides them to the server to use for sending callback requests, thus solving the firewall issue (Section 18.34). Races between responses from client requests and callbacks caused by the requests are detected via the session's sequencing properties that are a consequence of EOS (Section 2.10.6.3).",
      "ja": "* NFSV4.1クライアント（セクション1.7で定義）はトランスポート接続を作成し、それらをコールバック要求の送信に使用するサーバーに提供し、ファイアウォールの問題を解決します（セクション18.34）。クライアント要求からの応答とリクエストによって引き起こされるコールバックの間のレースは、EOSの結果であるセッションのシーケンスプロパティによって検出されます（2.10.6.3項）。"
    },
    {
      "indent": 3,
      "text": "* The NFSv4.1 client can associate an arbitrary number of connections with the session, and thus provide trunking (Section 2.10.5).",
      "ja": "* NFSV4.1クライアントは、任意の数の接続をセッションと関連付けることができ、したがってトランキングを提供する（2.10.5項）。"
    },
    {
      "indent": 3,
      "text": "* The NFSv4.1 client and server produce a session key independent of client and server machine credentials which can be used to compute a digest for protecting critical session management operations (Section 2.10.8.3).",
      "ja": "* NFSV4.1クライアントとサーバーは、重要なセッション管理操作を保護するためのダイジェストを計算するために使用できるクライアントとサーバーのマシンの認証情報とは無関係にセッションキーを作成します（セクション2.10.8.3）。"
    },
    {
      "indent": 3,
      "text": "* The NFSv4.1 client can also create secure RPCSEC_GSS contexts for use by the session's backchannel that do not require the server to authenticate to a client machine principal (Section 2.10.8.2).",
      "ja": "* NFSV4.1クライアントは、サーバーがクライアントマシンプリンシパルの認証を要求しないセッションのBackChannelが使用するための安全なRPCSEC_GSSコンテキストを作成することもできます（セクション2.10.8.2）。"
    },
    {
      "indent": 3,
      "text": "A session is a dynamically created, long-lived server object created by a client and used over time from one or more transport connections. Its function is to maintain the server's state relative to the connection(s) belonging to a client instance. This state is entirely independent of the connection itself, and indeed the state exists whether or not the connection exists. A client may have one or more sessions associated with it so that client-associated state may be accessed using any of the sessions associated with that client's client ID, when connections are associated with those sessions. When no connections are associated with any of a client ID's sessions for an extended time, such objects as locks, opens, delegations, layouts, etc. are subject to expiration. The session serves as an object representing a means of access by a client to the associated client state on the server, independent of the physical means of access to that state.",
      "ja": "セッションは、クライアントによって作成され、1つ以上のトランスポート接続から時間が経つにつれて、動的に作成された長寿命のサーバーオブジェクトです。その機能は、クライアントインスタンスに属する接続に対するサーバーの状態を維持することです。この状態は接続自体から完全に独立しており、実際には接続が存在するかどうかが存在します。クライアントは、接続がそれらのセッションに関連付けられているときに、クライアント関連状態がそのクライアントのクライアントIDに関連付けられたセッションを使用してアクセスされることができるように、それに関連する1つまたは複数のセッションを有することができる。接続が一定されたクライアントIDのセッションのいずれかに関連付けられていない場合、ロック、オープン、代理、レイアウトなどのオブジェクトは有効期限があります。セッションは、その状態へのアクセスの物理的手段とは無関係に、サーバ上のクライアントによるアクセス手段を表すオブジェクトとして機能する。"
    },
    {
      "indent": 3,
      "text": "A single client may create multiple sessions. A single session MUST NOT serve multiple clients.",
      "ja": "単一のクライアントが複数のセッションを作成する可能性があります。単一のセッションは複数のクライアントにサービスを提供してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.10.2. NFSv4 Integration",
      "section_title": true,
      "ja": "2.10.2. NFSV4統合"
    },
    {
      "indent": 3,
      "text": "Sessions are part of NFSv4.1 and not NFSv4.0. Normally, a major infrastructure change such as sessions would require a new major version number to an Open Network Computing (ONC) RPC program like NFS. However, because NFSv4 encapsulates its functionality in a single procedure, COMPOUND, and because COMPOUND can support an arbitrary number of operations, sessions have been added to NFSv4.1 with little difficulty. COMPOUND includes a minor version number field, and for NFSv4.1 this minor version is set to 1. When the NFSv4 server processes a COMPOUND with the minor version set to 1, it expects a different set of operations than it does for NFSv4.0. NFSv4.1 defines the SEQUENCE operation, which is required for every COMPOUND that operates over an established session, with the exception of some session administration operations, such as DESTROY_SESSION (Section 18.37).",
      "ja": "セッションはNFSv4.1ではなくNFSv4.0の一部です。通常、セッションなどの主要なインフラストラクチャの変更は、NFSのようなオープンネットワークコンピューティング（ONC）RPCプログラムへの新しいメジャーバージョン番号を必要とするでしょう。しかしながら、NFSV4は単一の手順でその機能をカプセル化するので、化合物は任意の数の演算をサポートできるため、セッションがほとんど困難でNFSV4.1に追加されました。化合物には、マイナーバージョン番号フィールドが含まれており、NFSV4.1の場合はこのマイナーバージョンは1に設定されています.NFSV4サーバーがマイナーバージョンを1に設定してコンパウンドを処理すると、NFSv4.0の場合は異なる操作セットが表示されます。。NFSV4.1は、Destroy_Sessionなどのセッション管理操作を除いて、確立されたセッションを介して動作するすべての化合物に必要なシーケンス操作を定義します（セクション18.37）。"
    },
    {
      "indent": 0,
      "text": "2.10.2.1. SEQUENCE and CB_SEQUENCE",
      "section_title": true,
      "ja": "2.10.2.1. シーケンスとCB_Sequence"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, when the SEQUENCE operation is present, it MUST be the first operation in the COMPOUND procedure. The primary purpose of SEQUENCE is to carry the session identifier. The session identifier associates all other operations in the COMPOUND procedure with a particular session. SEQUENCE also contains required information for maintaining EOS (see Section 2.10.6). Session-enabled NFSv4.1 COMPOUND requests thus have the form:",
      "ja": "NFSV4.1では、シーケンス操作が存在する場合は、複合手順の最初の操作でなければなりません。シーケンスの主な目的はセッション識別子を搬送することです。セッション識別子は、複合手順の他のすべての操作を特定のセッションと関連付けます。シーケンスには、EOSを維持するための必須情報も含まれています（2.10.6項を参照）。セッション対応のNFSV4.1複合要求に従って、次の形式があります。"
    },
    {
      "indent": 7,
      "text": "+-----+--------------+-----------+------------+-----------+----\n| tag | minorversion | numops    |SEQUENCE op | op + args | ...\n|     |   (== 1)     | (limited) |  + args    |           |\n+-----+--------------+-----------+------------+-----------+----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the replies have the form:",
      "ja": "そして返信には次の形式があります。"
    },
    {
      "indent": 7,
      "text": "+------------+-----+--------+-------------------------------+--//\n|last status | tag | numres |status + SEQUENCE op + results |  //\n+------------+-----+--------+-------------------------------+--//\n        //-----------------------+----\n        // status + op + results | ...\n        //-----------------------+----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A CB_COMPOUND procedure request and reply has a similar form to COMPOUND, but instead of a SEQUENCE operation, there is a CB_SEQUENCE operation. CB_COMPOUND also has an additional field called \"callback_ident\", which is superfluous in NFSv4.1 and MUST be ignored by the client. CB_SEQUENCE has the same information as SEQUENCE, and also includes other information needed to resolve callback races (Section 2.10.6.3).",
      "ja": "CB_COMPOUND手続き要求と応答は、複合と同様の形式を持ちますが、シーケンス操作の代わりにCB_SEQUENCE動作があります。CB_COMPOUNDには、NFSV4.1では不要であり、クライアントによって無視される必要があります。CB_Sequenceはシーケンスと同じ情報を持ち、コールバックレースを解決するために必要な他の情報も含まれています（セクション2.10.6.3）。"
    },
    {
      "indent": 0,
      "text": "2.10.2.2. Client ID and Session Association",
      "section_title": true,
      "ja": "2.10.2.2. クライアントIDとセッションの関連付け"
    },
    {
      "indent": 3,
      "text": "Each client ID (Section 2.4) can have zero or more active sessions. A client ID and associated session are required to perform file access in NFSv4.1. Each time a session is used (whether by a client sending a request to the server or the client replying to a callback request from the server), the state leased to its associated client ID is automatically renewed.",
      "ja": "各クライアントID（セクション2.4）は、0個以上のアクティブセッションを持つことができます。NFSV4.1でファイルアクセスを実行するには、クライアントIDと関連付けられているセッションが必要です。セッションが使用されるたびに（クライアントがサーバーに要求を送信するか、サーバーからのコールバック要求に返信するクライアントが）を使用するかどうか（サーバーからコールバック要求に返信されているかどうか）、関連するクライアントIDにリースされている状態が自動的に更新されます。"
    },
    {
      "indent": 3,
      "text": "State (which can consist of share reservations, locks, delegations, and layouts (Section 1.8.4)) is tied to the client ID. Client state is not tied to any individual session. Successive state changing operations from a given state owner MAY go over different sessions, provided the session is associated with the same client ID. A callback MAY arrive over a different session than that of the request that originally acquired the state pertaining to the callback. For example, if session A is used to acquire a delegation, a request to recall the delegation MAY arrive over session B if both sessions are associated with the same client ID. Sections 2.10.8.1 and 2.10.8.2 discuss the security considerations around callbacks.",
      "ja": "State（これは、共有予約、ロック、委任、およびレイアウト（セクション1.8.4））をクライアントIDに関連付けられています。クライアントの状態は個々のセッションに関連付けられていません。セッションが同じクライアントIDに関連付けられている場合、特定の状態の所有者からの連続状態の変更操作は異なるセッションを介して行くことができます。コールバックは、コールバックに関する状態を最初に取得した要求のそれとは異なるセッションにわたって到着することができる。例えば、セッションAが委任を取得するために使用される場合、両方のセッションが同じクライアントIDに関連付けられている場合、委任を思い出す要求はセッションBを介して到着する可能性がある。セクション2.10.8.1および2.10.8.2コールバックに関するセキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.3. Channels",
      "section_title": true,
      "ja": "2.10.3. チャンネル"
    },
    {
      "indent": 3,
      "text": "A channel is not a connection. A channel represents the direction ONC RPC requests are sent.",
      "ja": "チャネルは接続ではありません。チャネルはONC RPC要求を送信する方向を表します。"
    },
    {
      "indent": 3,
      "text": "Each session has one or two channels: the fore channel and the backchannel. Because there are at most two channels per session, and because each channel has a distinct purpose, channels are not assigned identifiers.",
      "ja": "各セッションには1つまたは2つのチャンネルがあります。前面チャンネルとバックチャネルです。セッションごとに最大2つのチャンネルがあるため、各チャンネルには異なる目的があるため、チャネルは識別子に割り当てられていません。"
    },
    {
      "indent": 3,
      "text": "The fore channel is used for ordinary requests from the client to the server, and carries COMPOUND requests and responses. A session always has a fore channel.",
      "ja": "前回のチャネルは、クライアントからサーバーへの通常の要求に使用され、複合要求と応答を担います。セッションには常に前回のチャネルがあります。"
    },
    {
      "indent": 3,
      "text": "The backchannel is used for callback requests from server to client, and carries CB_COMPOUND requests and responses. Whether or not there is a backchannel is decided by the client; however, many features of NFSv4.1 require a backchannel. NFSv4.1 servers MUST support backchannels.",
      "ja": "バックチャネルは、サーバーからクライアントへのコールバック要求に使用され、CB_COMPOUND要求と応答を伝送します。バックチャネルがあるかどうかはクライアントによって決まります。ただし、NFSV4.1の多くの機能はバックチャネルを必要とします。NFSV4.1サーバーはバックチャンネルをサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "Each session has resources for each channel, including separate reply caches (see Section 2.10.6.1). Note that even the backchannel requires a reply cache (or, at least, a slot table in order to detect retries) because some callback operations are non-idempotent.",
      "ja": "各セッションには、個別の返信キャッシュを含む、各チャネルのリソースがあります（セクション2.10.6.1を参照）。バックチャネルでさえ、いくつかのコールバック操作はIDEmpotentであるため、返信キャッシュ（または少なくとも再試行を検出するためにスロットテーブル）を必要とすることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.10.3.1. Association of Connections, Channels, and Sessions",
      "section_title": true,
      "ja": "2.10.3.1. 接続、チャンネル、セッションの関連付け"
    },
    {
      "indent": 3,
      "text": "Each channel is associated with zero or more transport connections (whether of the same transport protocol or different transport protocols). A connection can be associated with one channel or both channels of a session; the client and server negotiate whether a connection will carry traffic for one channel or both channels via the CREATE_SESSION (Section 18.36) and the BIND_CONN_TO_SESSION (Section 18.34) operations. When a session is created via CREATE_SESSION, the connection that transported the CREATE_SESSION request is automatically associated with the fore channel, and optionally the backchannel. If the client specifies no state protection (Section 18.35) when the session is created, then when SEQUENCE is transmitted on a different connection, the connection is automatically associated with the fore channel of the session specified in the SEQUENCE operation.",
      "ja": "各チャネルは、0個以上のトランスポート接続と関連付けられています（同じトランスポートプロトコルまたは異なるトランスポートプロトコルであろう）。接続は、セッションの1つのチャネルまたは両方のチャネルに関連付けることができます。クライアントとサーバーは、CREATE_SESSION（セクション18.36）とBIND_CONN_TO_SESSION（セクション18.34）の操作を介して、接続が1つのチャネルまたは両方のチャンネルのトラフィックを搬送するかどうかをネゴシエートします。CREATE_SESSIONを介してセッションが作成されると、CREATE_SESSION要求を転送した接続は自動的に前のチャネル、およびオプションでバックチャネルに関連付けられます。クライアントがState Protectionを指定していない場合（セクション18.35）セッションが作成されたときに、シーケンスが異なる接続で送信されると、接続はシーケンス操作で指定されたセッションの前のチャネルに自動的に関連付けられます。"
    },
    {
      "indent": 3,
      "text": "A connection's association with a session is not exclusive. A connection associated with the channel(s) of one session may be simultaneously associated with the channel(s) of other sessions including sessions associated with other client IDs.",
      "ja": "セッションとの接続の関連付けは排他的ではありません。1つのセッションのチャネルに関連付けられた接続は、他のクライアントIDに関連付けられたセッションを含む他のセッションのチャネルと同時に関連付けられてもよい。"
    },
    {
      "indent": 3,
      "text": "It is permissible for connections of multiple transport types to be associated with the same channel. For example, both TCP and RDMA connections can be associated with the fore channel. In the event an RDMA and non-RDMA connection are associated with the same channel, the maximum number of slots SHOULD be at least one more than the total number of RDMA credits (Section 2.10.6.1). This way, if all RDMA credits are used, the non-RDMA connection can have at least one outstanding request. If a server supports multiple transport types, it MUST allow a client to associate connections from each transport to a channel.",
      "ja": "複数のトランスポートタイプの接続を同じチャンネルに関連付けることが許可されています。たとえば、TCP接続とRDMA接続の両方をフォアチャネルに関連付けることができます。イベントでは、RDMAと非RDMA接続が同じチャンネルに関連付けられている場合、最大スロット数はRDMAクレジットの総数を超えています（セクション2.10.6.1）。このようにして、すべてのRDMAクレジットが使用されている場合、RDMA以外の接続には少なくとも1つの未解決の要求を持つことができます。サーバーが複数のトランスポートタイプをサポートしている場合は、クライアントが各トランスポートからチャンネルへの接続を関連付けることを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is permissible for a connection of one type of transport to be associated with the fore channel, and a connection of a different type to be associated with the backchannel.",
      "ja": "1つのタイプのトランスポートを、前チャネルと関連付けるように、バックチャネルと関連付ける異なるタイプの接続を接続することが許可されています。"
    },
    {
      "indent": 0,
      "text": "2.10.4. Server Scope",
      "section_title": true,
      "ja": "2.10.4. サーバースコープ"
    },
    {
      "indent": 3,
      "text": "Servers each specify a server scope value in the form of an opaque string eir_server_scope returned as part of the results of an EXCHANGE_ID operation. The purpose of the server scope is to allow a group of servers to indicate to clients that a set of servers sharing the same server scope value has arranged to use distinct values of opaque identifiers so that the two servers never assign the same value to two distinct objects. Thus, the identifiers generated by two servers within that set can be assumed compatible so that, in certain important cases, identifiers generated by one server in that set may be presented to another server of the same scope.",
      "ja": "サーバーはそれぞれ、Exchange_ID操作の結果の一部として返された不透明文字列EIR_SERVER_SCOPEの形式のサーバースコープ値を指定します。サーバーの範囲の目的は、同じサーバースコープ値を共有するサーバーのセットが不透明な識別子の異なる値を使用するように構成されているサーバーのグループが、2つのサーバーが同じ値を2つの異なるものに割り当てることができないようにすることをクライアントに示すことです。オブジェクトしたがって、そのセット内の2つのサーバによって生成された識別子は、特定の重要な場合において、そのセット内の1つのサーバによって生成された識別子が同じスコープの別のサーバに提示され得るように互換性があると仮定することができる。"
    },
    {
      "indent": 3,
      "text": "The use of such compatible values does not imply that a value generated by one server will always be accepted by another. In most cases, it will not. However, a server will not inadvertently accept a value generated by another server. When it does accept it, it will be because it is recognized as valid and carrying the same meaning as on another server of the same scope.",
      "ja": "そのような互換性のある値を使用すると、1つのサーバーによって生成された値が常に別のサーバーによって受け入れられることを意味しません。ほとんどの場合、そうではありません。ただし、サーバーは誤って別のサーバーによって生成された値を受け入れません。それを受け入れると、それが有効であると認識され、同じスコープの別のサーバーと同じ意味を持ち運ぶからです。"
    },
    {
      "indent": 3,
      "text": "When servers are of the same server scope, this compatibility of values applies to the following identifiers:",
      "ja": "サーバーが同じサーバースコープのものである場合、この値の互換性は次の識別子に適用されます。"
    },
    {
      "indent": 3,
      "text": "* Filehandle values. A filehandle value accepted by two servers of the same server scope denotes the same object. A WRITE operation sent to one server is reflected immediately in a READ sent to the other.",
      "ja": "* ファイルハンドル値同じサーバースコープの2つのサーバーによって受け入れられたファイルハンドル値は同じオブジェクトを表します。1つのサーバに送信された書き込み操作は、もう一方のサーバに送信された読み取りに反映されます。"
    },
    {
      "indent": 3,
      "text": "* Server owner values. When the server scope values are the same, server owner value may be validly compared. In cases where the server scope values are different, server owner values are treated as different even if they contain identical strings of bytes.",
      "ja": "* サーバーの所有者の値。サーバースコープ値が同じ場合は、サーバーの所有者の値が有効に比較される可能性があります。サーバースコープ値が異なる場合、サーバーの所有者の値は、同一のバイト文字列を含む場合でも、異なるものとして扱われます。"
    },
    {
      "indent": 3,
      "text": "The coordination among servers required to provide such compatibility can be quite minimal, and limited to a simple partition of the ID space. The recognition of common values requires additional implementation, but this can be tailored to the specific situations in which that recognition is desired.",
      "ja": "そのような互換性を提供するために必要とされるサーバー間の調整は、非常に最小限であり、ID空間の単純なパーティションに制限され得る。共通値の認識は追加の実装を必要とするが、これはその認識が望まれる特定の状況に合わせて調整することができる。"
    },
    {
      "indent": 3,
      "text": "Clients will have occasion to compare the server scope values of multiple servers under a number of circumstances, each of which will be discussed under the appropriate functional section:",
      "ja": "クライアントは、複数のサーバーのサーバースコープ値をいくつかの状況下で比較することができます。各状況は、適切な機能セクションで説明されます。"
    },
    {
      "indent": 3,
      "text": "* When server owner values received in response to EXCHANGE_ID operations sent to multiple network addresses are compared for the purpose of determining the validity of various forms of trunking, as described in Section 11.5.2.",
      "ja": "* 複数のネットワークアドレスに送信されたExchange_ID操作に応答して受信されたサーバ所有者の値が、セクション11.5.2で説明されているように、さまざまな形式のトランキングの妥当性を判断する目的で比較される。"
    },
    {
      "indent": 3,
      "text": "* When network or server reconfiguration causes the same network address to possibly be directed to different servers, with the necessity for the client to determine when lock reclaim should be attempted, as described in Section 8.4.2.1.",
      "ja": "* ネットワークまたはサーバーの再構成が異なるサーバーに同じネットワークアドレスを引き起こす場合、クライアントがロック再生がいつ試行されるかをクライアントに決定する必要がある場合は、セクション8.4.2.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "When two replies from EXCHANGE_ID, each from two different server network addresses, have the same server scope, there are a number of ways a client can validate that the common server scope is due to two servers cooperating in a group.",
      "ja": "Exchange_IDからの2つの応答が、2つの異なるサーバーネットワークアドレスから同じサーバースコープを持ち、クライアントがCommon Serverスコープがグループ内に協力している2つのサーバーがあることを検証できる方法がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "* If both EXCHANGE_ID requests were sent with RPCSEC_GSS ([4], [9], [27]) authentication and the server principal is the same for both targets, the equality of server scope is validated. It is RECOMMENDED that two servers intending to share the same server scope and server_owner major_id also share the same principal name. In some cases, this simplifies the client's task of validating server scope.",
      "ja": "* 両方のExchange_id要求がRPCSEC_GSS（[4]、[9]、[27]）で送信され、サーバープリンシパルが両方のターゲットで同じである場合、サーバースコープの平等は検証されます。同じサーバースコープとserver_owner mapear_idを共有するつもりの2つのサーバーも同じプリンシパル名を共有することをお勧めします。場合によっては、これにより、クライアントのサーバースコープを検証するタスクが簡単になります。"
    },
    {
      "indent": 3,
      "text": "* The client may accept the appearance of the second server in the fs_locations or fs_locations_info attribute for a relevant file system. For example, if there is a migration event for a particular file system or there are locks to be reclaimed on a particular file system, the attributes for that particular file system may be used. The client sends the GETATTR request to the first server for the fs_locations or fs_locations_info attribute with RPCSEC_GSS authentication. It may need to do this in advance of the need to verify the common server scope. If the client successfully authenticates the reply to GETATTR, and the GETATTR request and reply containing the fs_locations or fs_locations_info attribute refers to the second server, then the equality of server scope is supported. A client may choose to limit the use of this form of support to information relevant to the specific file system involved (e.g. a file system being migrated).",
      "ja": "* クライアントは、関連するファイルシステムのFS_LOCATIONATIONATIONSまたはFS_LOCATIONS_INFO属性内の2番目のサーバーの外観を受け入れることができます。たとえば、特定のファイルシステムのマイグレーションイベントがあるか、特定のファイルシステムで再生されるロックがある場合、その特定のファイルシステムの属性を使用できます。クライアントは、RPCSEC_GSS認証を使用してFS_LOCATIONSまたはFS_LOCATIONS_INFO属性の最初のサーバーにGetAttr要求を送信します。一般的なサーバーの範囲を確認する必要がないようにする必要があるかもしれません。クライアントがGetAttrへの返信を正常に認証し、fs_locationsまたはfs_locations_info属性を含むgetAttr要求と応答が2番目のサーバーを参照してから、サーバースコープの平等がサポートされています。クライアントは、この形式のサポートの使用を関連する特定のファイルシステムに関連する情報（例えば、移行されているファイルシステム）に制限することを選択することができる。"
    },
    {
      "indent": 0,
      "text": "2.10.5. Trunking",
      "section_title": true,
      "ja": "2.10.5. 切り捨て"
    },
    {
      "indent": 3,
      "text": "Trunking is the use of multiple connections between a client and server in order to increase the speed of data transfer. NFSv4.1 supports two types of trunking: session trunking and client ID trunking.",
      "ja": "トランキングは、データ転送の速度を上げるためにクライアントとサーバー間の複数の接続を使用することです。NFSV4.1は、セッショントランキングとクライアントIDのトランキングの2種類のトランキングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "In the context of a single server network address, it can be assumed that all connections are accessing the same server, and NFSv4.1 servers MUST support both forms of trunking. When multiple connections use a set of network addresses to access the same server, the server MUST support both forms of trunking. NFSv4.1 servers in a clustered configuration MAY allow network addresses for different servers to use client ID trunking.",
      "ja": "単一のサーバーネットワークアドレスのコンテキストでは、すべての接続が同じサーバーにアクセスしていると想定することができ、NFSV4.1サーバーは両方のトランキングをサポートしている必要があります。複数の接続が同じサーバーにアクセスするために一連のネットワークアドレスを使用する場合、サーバーは両方の形式のトランキングをサポートしている必要があります。NFSV4.1クラスタ構成内のサーバーは、さまざまなサーバーのネットワークアドレスをクライアントIDのトランキングを使用できます。"
    },
    {
      "indent": 3,
      "text": "Clients may use either form of trunking as long as they do not, when trunking between different server network addresses, violate the servers' mandates as to the kinds of trunking to be allowed (see below). With regard to callback channels, the client MUST allow the server to choose among all callback channels valid for a given client ID and MUST support trunking when the connections supporting the backchannel allow session or client ID trunking to be used for callbacks.",
      "ja": "クライアントは、さまざまなサーバーネットワークアドレス間のトランキングが許可されるべきトランキングの種類に関してサーバーの義務を違反している限り、クライアントのいずれかのトランキングを使用できます。コールバックチャネルに関しては、クライアントは、特定のクライアントIDに対して有効なすべてのコールバックチャネルの中からサーバーがすべて選択され、バックチャネルをサポートする接続がセッションまたはクライアントIDのトランキングをコールバックに使用できるようにするときにトランキングをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Session trunking is essentially the association of multiple connections, each with potentially different target and/or source network addresses, to the same session. When the target network addresses (server addresses) of the two connections are the same, the server MUST support such session trunking. When the target network addresses are different, the server MAY indicate such support using the data returned by the EXCHANGE_ID operation (see below).",
      "ja": "セッショントランキングは、基本的には、それぞれが異なるターゲットネットワークアドレスおよび/またはソースネットワークアドレスを持つ複数の接続と同じセッションに、複数の接続の関連付けです。2つの接続のターゲットネットワークアドレス（サーバアドレス）が同じである場合、サーバーはそのようなセッショントランキングをサポートしている必要があります。ターゲットネットワークアドレスが異なる場合、サーバは、Exchange_ID操作によって返されたデータを使用してそのようなサポートを示してもよい（下記参照）。"
    },
    {
      "indent": 3,
      "text": "Client ID trunking is the association of multiple sessions to the same client ID. Servers MUST support client ID trunking for two target network addresses whenever they allow session trunking for those same two network addresses. In addition, a server MAY, by presenting the same major server owner ID (Section 2.5) and server scope (Section 2.10.4), allow an additional case of client ID trunking. When two servers return the same major server owner and server scope, it means that the two servers are cooperating on locking state management, which is a prerequisite for client ID trunking.",
      "ja": "クライアントIDのトランキングは、同じクライアントIDへの複数のセッションの関連付けです。サーバーは、同じ2つのネットワークアドレスのセッショントランキングを許可するときはいつでも、2つのターゲットネットワークアドレスのクライアントIDトランキングをサポートしている必要があります。さらに、サーバーは、同じ主要なサーバー所有者ID（セクション2.5）とサーバーの範囲（セクション2.10.4）を提示することによって、クライアントIDのトランキングの追加のケースを許可することがあります。2つのサーバーが同じメジャーサーバーの所有者とサーバーの範囲を返すと、2つのサーバーがロック状態管理に協力していることを意味します。これはクライアントIDのトランキングの前提条件です。"
    },
    {
      "indent": 3,
      "text": "Distinguishing when the client is allowed to use session and client ID trunking requires understanding how the results of the EXCHANGE_ID (Section 18.35) operation identify a server. Suppose a client sends EXCHANGE_IDs over two different connections, each with a possibly different target network address, but each EXCHANGE_ID operation has the same value in the eia_clientowner field. If the same NFSv4.1 server is listening over each connection, then each EXCHANGE_ID result MUST return the same values of eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. The client can then treat each connection as referring to the same server (subject to verification; see Section 2.10.5.1 below), and it can use each connection to trunk requests and replies. The client's choice is whether session trunking or client ID trunking applies.",
      "ja": "クライアントがセッションとクライアントIDのトランキングの使用を許可されている場合に区別するには、Exchange_IDの結果がサーバーを識別する方法を理解する必要があります。クライアントが2つの異なる接続を介してExchange_idsを送信し、それぞれ異なるターゲットネットワークアドレスを持つが、各Exchange_ID操作はEIA_ClientOwnerフィールドに同じ値を持ちます。同じNFSV4.1サーバーが各接続を介してリスンされている場合、各Exchange_ID結果はEIR_CLIENTID、EIR_SERVER_OWNER.SO_MAJOR_ID、およびEIR_SERVER_SCOPEの同じ値を返す必要があります。クライアントは、各接続を同じサーバー（検証対象）を参照して扱うことができます（下記のセクション2.10.5.1を参照）、トランク要求と応答に各接続を使用できます。クライアントの選択は、セッショントランキングまたはクライアントIDのトランキングが適用されるかどうかです。"
    },
    {
      "indent": 3,
      "text": "Session Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, eir_server_owner.so_minor_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform session trunking. If the client has no session mapping to the tuple of eir_clientid, eir_server_owner.so_major_id, eir_server_scope, and eir_server_owner.so_minor_id, then it creates the session via a CREATE_SESSION operation over one of the connections, which associates the connection to the session. If there is a session for the tuple, the client can send BIND_CONN_TO_SESSION to associate the connection to the session.",
      "ja": "セッショントランキングEIA_CLINTEROWNER引数が2つの異なるExchange_ID要求で同じで、EIR_CLIENTID、EIR_SERVER_OWNER.SO_MINOR_ID、EIR_SERVER_OWNER_SO_MINOR_ID、およびEIR_SERVER_SCOPEの結果が一致した場合、クライアントはセッショントランキングを実行できます。クライアントにEIR_CLIENTIDのタプルへのセッションマッピングがない場合、EIR_SERVER_OWNER.SO_MAJOR_ID、EIR_SERVER_SCOPE、およびEIR_SERVER_OWNER.SO_MINOR_IDのセッションは、セッションに接続を関連付ける接続の1つを介してCREATE_SESSION操作を介してセッションを作成します。タプルのセッションがある場合、クライアントは接続をセッションに関連付けるためにbind_conn_to_sessionを送信できます。"
    },
    {
      "indent": 6,
      "text": "Of course, if the client does not desire to use session trunking, it is not required to do so. It can invoke CREATE_SESSION on the connection. This will result in client ID trunking as described below. It can also decide to drop the connection if it does not choose to use trunking.",
      "ja": "もちろん、クライアントがセッションのトランキングを使用していない場合は、そうする必要はありません。接続にcreate_sessionを呼び出すことができます。これにより、以下に説明するようにクライアントIDのトランキングが発生します。トランキングを使用することを選択しない場合は、接続をドロップすることもできます。"
    },
    {
      "indent": 3,
      "text": "Client ID Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform client ID trunking (regardless of whether the eir_server_owner.so_minor_id results match). The client can associate each connection with different sessions, where each session is associated with the same server.",
      "ja": "クライアントIDのトランキングEXECH_IDの両方の結果でEIA_CLINTEROWNER引数とEIR_CLIENTID、EIR_SERVER_OWNER.SO_MAJOR_ID、およびEIR_SERVER_SCOPEの結果が一致している場合、クライアントはクライアントIDのトランキングを実行できます（EIR_SERVER_OWNER.SO_MINOR_IDが一致するかどうかにかかわらず）。）。クライアントは各接続を異なるセッションと関連付けることができ、各セッションは同じサーバーに関連付けられています。"
    },
    {
      "indent": 6,
      "text": "The client completes the act of client ID trunking by invoking CREATE_SESSION on each connection, using the same client ID that was returned in eir_clientid. These invocations create two sessions and also associate each connection with its respective session. The client is free to decline to use client ID trunking by simply dropping the connection at this point.",
      "ja": "クライアントは、EIR_ClientIDで返された同じクライアントIDを使用して、各接続でCREATE_SESSIONを呼び出すことで、クライアントIDトランキングの動作を完了します。これらの呼び出しは2つのセッションを作成し、それぞれの接続をそれぞれのセッションに関連付けます。この時点で接続をドロップするだけで、クライアントはクライアントIDのトランキングを使用することを自由に辞退することができます。"
    },
    {
      "indent": 6,
      "text": "When doing client ID trunking, locking state is shared across sessions associated with that same client ID. This requires the server to coordinate state across sessions and the client to be able to associate the same locking state with multiple sessions.",
      "ja": "クライアントIDのトランキングを実行すると、その同じクライアントIDに関連付けられているセッション間でロック状態が共有されます。これにより、サーバーがセッション間で状態を調整し、クライアントは同じロック状態を複数のセッションと関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "It is always possible that, as a result of various sorts of reconfiguration events, eir_server_scope and eir_server_owner values may be different on subsequent EXCHANGE_ID requests made to the same network address.",
      "ja": "さまざまな種類の再構成イベントの結果として、EIR_SERVER_SCOPEおよびEIR_SERVER_OWNER値が同じネットワークアドレスに対して行われた後続のExchange_ID要求では異なる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In most cases, such reconfiguration events will be disruptive and indicate that an IP address formerly connected to one server is now connected to an entirely different one.",
      "ja": "ほとんどの場合、そのような再構成イベントは破壊的になり、以前は1つのサーバーに接続されていたIPアドレスが完全に異なるものに接続されていることを示します。"
    },
    {
      "indent": 3,
      "text": "Some guidelines on client handling of such situations follow:",
      "ja": "そのような状況のクライアント処理に関するいくつかのガイドラインは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* When eir_server_scope changes, the client has no assurance that any IDs that it obtained previously (e.g., filehandles) can be validly used on the new server, and, even if the new server accepts them, there is no assurance that this is not due to accident. Thus, it is best to treat all such state as lost or stale, although a client may assume that the probability of inadvertent acceptance is low and treat this situation as within the next case.",
      "ja": "* EIR_SERVER_SCOPEが変更された場合、クライアントには、以前に取得したID（ファイルハンドルなど）が新しいサーバーで有効に使用できること、および新しいサーバーがそれらを受け入れても、これが原因ではないという保証はありません。事故。したがって、クライアントは、不注意による受理の確率が低いと仮定され、次の場合と同じようにこの状況を扱うことができるが、紛失または古い状態のまったく扱うことが最善である。"
    },
    {
      "indent": 3,
      "text": "* When eir_server_scope remains the same and eir_server_owner.so_major_id changes, the client can use the filehandles it has, consider its locking state lost, and attempt to reclaim or otherwise re-obtain its locks. It might find that its filehandle is now stale. However, if NFS4ERR_STALE is not returned, it can proceed to reclaim or otherwise re-obtain its open locking state.",
      "ja": "* EIR_SERVER_SCOPEが同じでEIR_SERVER_OWNER.SO_MAJOR_IDのままである場合、クライアントはそれが持つファイルハンドルを使用し、そのロック状態が失われたとみなし、そのロックを再利用するか、またはその他の方法で再取得しようとします。そのファイルハンドルが現在古くなっていることがわかります。ただし、NFS4ERR_STALEが返されない場合は、そのオープンロック状態の再利用またはその他の方法で再取得できます。"
    },
    {
      "indent": 3,
      "text": "* When eir_server_scope and eir_server_owner.so_major_id remain the same, the client has to use the now-current values of eir_server_owner.so_minor_id in deciding on appropriate forms of trunking. This may result in connections being dropped or new sessions being created.",
      "ja": "* EIR_SERVER_SCOPEおよびEIR_SERVER_OWNER.SO_MAJOR_IDが同じままである場合、クライアントは適切な形式のトランキングを決定する際にEIR_SERVER_OWNER.SO_MINOR_IDの現在の電流値を使用する必要があります。これにより、接続が削除されたり、新しいセッションが作成されたりする可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.10.5.1. Verifying Claims of Matching Server Identity",
      "section_title": true,
      "ja": "2.10.5.1. マッチングサーバーIDのクレームを確認します"
    },
    {
      "indent": 3,
      "text": "When the server responds using two different connections that claim matching or partially matching eir_server_owner, eir_server_scope, and eir_clientid values, the client does not have to trust the servers' claims. The client may verify these claims before trunking traffic in the following ways:",
      "ja": "サーバーが、EIR_SERVER_OWNER、EIR_SERVER_SCOPE、およびEIR_CLIENTIDの値と一致または部分的に一致する2つの異なる接続を使用して応答すると、クライアントはサーバーの主張を信頼する必要はありません。クライアントは、次の方法でトラフィックをトレーキングする前にこれらのクレームを検証することができます。"
    },
    {
      "indent": 3,
      "text": "* For session trunking, clients SHOULD reliably verify if connections between different network paths are in fact associated with the same NFSv4.1 server and usable on the same session, and servers MUST allow clients to perform reliable verification. When a client ID is created, the client SHOULD specify that BIND_CONN_TO_SESSION is to be verified according to the SP4_SSV or SP4_MACH_CRED (Section 18.35) state protection options. For SP4_SSV, reliable verification depends on a shared secret (the SSV) that is established via the SET_SSV (see Section 18.47) operation.",
      "ja": "* セッショントランキングの場合、クライアントは、異なるネットワークパス間の接続が同じNFSV4.1サーバーに関連付けられ、同じセッションで使用可能であるかどうかを確実に検証する必要があり、サーバーはクライアントが信頼できる検証を実行できるようにします。クライアントIDが作成されると、クライアントはSP4_SSVまたはSP4_MACH_CRED（セクション18.35）の状態保護オプションに従ってBIND_CONN_TO_SESSIONを検証するように指定する必要があります。SP4_SSVの場合、信頼性の高い検証はSET_SSVを介して確立された共有秘密（SSV）によって異なります（セクション18.47）。"
    },
    {
      "indent": 6,
      "text": "When a new connection is associated with the session (via the BIND_CONN_TO_SESSION operation, see Section 18.34), if the client specified SP4_SSV state protection for the BIND_CONN_TO_SESSION operation, the client MUST send the BIND_CONN_TO_SESSION with RPCSEC_GSS protection, using integrity or privacy, and an RPCSEC_GSS handle created with the GSS SSV mechanism (see Section 2.10.9).",
      "ja": "新しい接続がセッションに関連付けられている場合（BIND_CONN_TO_SESSION操作を介して、18.34項を参照）、クライアントがbind_conn_to_session操作のSP4_SSV状態保護を指定した場合、クライアントは、整合性またはプライバシーを使用して、rpcsec_gss保護を使用してbind_conn_to_sessionを送信する必要があります。GSS SSVメカニズムで作成されたハンドル（2.10.9項を参照）。"
    },
    {
      "indent": 6,
      "text": "If the client mistakenly tries to associate a connection to a session of a wrong server, the server will either reject the attempt because it is not aware of the session identifier of the BIND_CONN_TO_SESSION arguments, or it will reject the attempt because the RPCSEC_GSS authentication fails. Even if the server mistakenly or maliciously accepts the connection association attempt, the RPCSEC_GSS verifier it computes in the response will not be verified by the client, so the client will know it cannot use the connection for trunking the specified session.",
      "ja": "誤って誤ったサーバーのセッションへの接続を関連付けると、クライアントがBIND_CONN_TO_SESSION引数のセッションIDを認識していないため、サーバーはその試行を拒否します。サーバーが誤ってまたは悪意がある場合でも接続アソシエーションの試行を受け付けても、応答を計算するRPCSEC_GSS Verifierはクライアントによって検証されません。そのため、クライアントは指定されたセッションのトランキングに接続を使用できないことがわかります。"
    },
    {
      "indent": 6,
      "text": "If the client specified SP4_MACH_CRED state protection, the BIND_CONN_TO_SESSION operation will use RPCSEC_GSS integrity or privacy, using the same credential that was used when the client ID was created. Mutual authentication via RPCSEC_GSS assures the client that the connection is associated with the correct session of the correct server.",
      "ja": "クライアントがSP4_MACH_CRED状態保護を指定した場合、bind_conn_to_session操作は、クライアントIDが作成されたときに使用されたものと同じ信任状を使用して、RPCSEC_GSSの整合性またはプライバシーを使用します。RPCSEC_GSSを介した相互認証は、接続が正しいサーバーの正しいセッションに関連付けられているクライアントを保証します。"
    },
    {
      "indent": 3,
      "text": "* For client ID trunking, the client has at least two options for verifying that the same client ID obtained from two different EXCHANGE_ID operations came from the same server. The first option is to use RPCSEC_GSS authentication when sending each EXCHANGE_ID operation. Each time an EXCHANGE_ID is sent with RPCSEC_GSS authentication, the client notes the principal name of the GSS target. If the EXCHANGE_ID results indicate that client ID trunking is possible, and the GSS targets' principal names are the same, the servers are the same and client ID trunking is allowed.",
      "ja": "* クライアントIDのトランキングの場合、クライアントには、2つの異なるExchange_ID操作から取得した同じクライアントIDが同じサーバーから取得されたことを確認するための少なくとも2つのオプションがあります。最初のオプションは、各Exchange_ID操作を送信するときにRPCSEC_GSS認証を使用することです。Exchange_IDがRPCSEC_GSS認証で送信されるたびに、クライアントはGSSターゲットのプリンシパル名を注います。Exchange_IDの結果がクライアントIDのトランキングが可能で、GSSターゲットの「プリンシパル名は同じである場合は、サーバーは同じでクライアントIDのトランキングが許可されています。"
    },
    {
      "indent": 6,
      "text": "The second option for verification is to use SP4_SSV protection. When the client sends EXCHANGE_ID, it specifies SP4_SSV protection. The first EXCHANGE_ID the client sends always has to be confirmed by a CREATE_SESSION call. The client then sends SET_SSV. Later, the client sends EXCHANGE_ID to a second destination network address different from the one the first EXCHANGE_ID was sent to. The client checks that each EXCHANGE_ID reply has the same eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. If so, the client verifies the claim by sending a CREATE_SESSION operation to the second destination address, protected with RPCSEC_GSS integrity using an RPCSEC_GSS handle returned by the second EXCHANGE_ID. If the server accepts the CREATE_SESSION request, and if the client verifies the RPCSEC_GSS verifier and integrity codes, then the client has proof the second server knows the SSV, and thus the two servers are cooperating for the purposes of specifying server scope and client ID trunking.",
      "ja": "検証のための2番目のオプションはSP4_SSV保護を使用することです。クライアントがExchange_IDを送信すると、SP4_SSV保護を指定します。最初のExchange_idクライアントの送信は常にCreate_Session呼び出しによって確認されなければなりません。その後、クライアントはset_ssvを送信します。後で、クライアントは、最初のExchange_IDが送信されたものとは異なる2番目の宛先ネットワークアドレスにExchange_idを送信します。クライアントは、各Exchange_ID応答に同じEIR_CLIENTID、EIR_SERVER_OWNER.SO_MAJOR_ID、EIR_SERVER_SCOPEがあることを確認します。もしそうであれば、クライアントは、2番目のExchange_IDによって返されるRPCSEC_GSSハンドルを使用して、RPCSEC_GSSの整合性を使用して保護された、CREATE_SESSION操作を2番目の宛先アドレスに送信することによってクレームを検証します。サーバーがcreate_session要求を受け入れ、クライアントがRPCSEC_GSS VerifierとIntegrityコードを検証した場合、クライアントは2番目のサーバーがSSVを認識しているため、サーバースコープとクライアントIDのトランキングを指定する目的で2つのサーバーが協力しています。 。"
    },
    {
      "indent": 0,
      "text": "2.10.6. Exactly Once Semantics",
      "section_title": true,
      "ja": "2.10.6. 一度だけ意味："
    },
    {
      "indent": 3,
      "text": "Via the session, NFSv4.1 offers exactly once semantics (EOS) for requests sent over a channel. EOS is supported on both the fore channel and backchannel.",
      "ja": "セッションを介して、NFSv4.1は、チャネルを介して送信された要求のためのセマンティクス（EOS）を正確に提供します。EOSは、前チャンネルとバックチャネルの両方でサポートされています。"
    },
    {
      "indent": 3,
      "text": "Each COMPOUND or CB_COMPOUND request that is sent with a leading SEQUENCE or CB_SEQUENCE operation MUST be executed by the receiver exactly once. This requirement holds regardless of whether the request is sent with reply caching specified (see Section 2.10.6.1.3). The requirement holds even if the requester is sending the request over a session created between a pNFS data client and pNFS data server. To understand the rationale for this requirement, divide the requests into three classifications:",
      "ja": "先頭のシーケンスまたはCB_Sequence操作で送信される各化合物またはCB_COMPOUND要求は、正確に1回受信機によって実行されなければなりません。この要件は、要求が指定された応答キャッシュで送信されたかどうかにかかわらず、（2.10.6.1.3項を参照）。要求者が、PNFSデータクライアントとPNFSデータサーバー間で作成されたセッションを介して要求を送信している場合でも、要件は保持されます。この要件の根拠を理解するには、要求を3つの分類に分割します。"
    },
    {
      "indent": 3,
      "text": "* Non-idempotent requests.",
      "ja": "* 非IDEMPOTENT要求"
    },
    {
      "indent": 3,
      "text": "* Idempotent modifying requests.",
      "ja": "* IDEmpotentの変更要求"
    },
    {
      "indent": 3,
      "text": "* Idempotent non-modifying requests.",
      "ja": "* IDEmpotent非修正要求"
    },
    {
      "indent": 3,
      "text": "An example of a non-idempotent request is RENAME. Obviously, if a replier executes the same RENAME request twice, and the first execution succeeds, the re-execution will fail. If the replier returns the result from the re-execution, this result is incorrect. Therefore, EOS is required for non-idempotent requests.",
      "ja": "非IDEmpotent要求の例は名前変更です。明らかに、レプリアが同じ名前の変更要求を2回実行し、最初の実行が成功した場合、再実行は失敗します。REPLIERが再実行から結果を返す場合、この結果は正しくありません。したがって、IDEMOTENTENT要求にEOSが必要です。"
    },
    {
      "indent": 3,
      "text": "An example of an idempotent modifying request is a COMPOUND request containing a WRITE operation. Repeated execution of the same WRITE has the same effect as execution of that WRITE a single time. Nevertheless, enforcing EOS for WRITEs and other idempotent modifying requests is necessary to avoid data corruption.",
      "ja": "IDEmPotorment修正要求の一例は、書き込み動作を含む複合要求である。同じ書き込みの繰り返し実行は、その実行の実行と同じ効果があります。それにもかかわらず、データの破損を回避するためには、書き込み用のEOSやその他のIDEmpotentの変更要求を強制する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose a client sends WRITE A to a noncompliant server that does not enforce EOS, and receives no response, perhaps due to a network partition. The client reconnects to the server and re-sends WRITE A. Now, the server has outstanding two instances of A. The server can be in a situation in which it executes and replies to the retry of A, while the first A is still waiting in the server's internal I/O system for some resource. Upon receiving the reply to the second attempt of WRITE A, the client believes its WRITE is done so it is free to send WRITE B, which overlaps the byte-range of A. When the original A is dispatched from the server's I/O system and executed (thus the second time A will have been written), then what has been written by B can be overwritten and thus corrupted.",
      "ja": "クライアントがEOSを強制しない非コンポーネントのサーバーにWRITE Aを送信し、おそらくネットワークパーティションのために応答を受信しないとします。クライアントはサーバーに再接続し、Write Aを再送信します。これでサーバーの2つのインスタンスがあります。サーバーは、最初のAがまだ待っていますが、サーバーはAの再試行に応答して返信することができます。リソースのサーバーの内部I / Oシステムで。WRITE Aの2回目の試行への返信を受信すると、クライアントはその書き込みが行われるため、Aのバイト範囲を重複するのは自由に送信することができます。元のAがサーバーのI / Oシステムから送出されるときそして実行された（したがって、2番目の時間Aは書き込まれた）、Bによって書き込まれたものは上書きされ、したがって破損することができる。"
    },
    {
      "indent": 3,
      "text": "An example of an idempotent non-modifying request is a COMPOUND containing SEQUENCE, PUTFH, READLINK, and nothing else. The re-execution of such a request will not cause data corruption or produce an incorrect result. Nonetheless, to keep the implementation simple, the replier MUST enforce EOS for all requests, whether or not idempotent and non-modifying.",
      "ja": "IDEmpotent非修正要求の例は、シーケンス、PUTFH、ReadLink、および他に何もない複合である。そのような要求の再実行はデータの破損を引き起こすことも、誤った結果を生み出すことはありません。それにもかかわらず、実装を簡単にするためには、replierは、idempotentと非修正が必要であるかどうかにかかわらず、すべての要求に対してEOSを強制する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that true and complete EOS is not possible unless the server persists the reply cache in stable storage, and unless the server is somehow implemented to never require a restart (indeed, if such a server exists, the distinction between a reply cache kept in stable storage versus one that is not is one without meaning). See Section 2.10.6.5 for a discussion of persistence in the reply cache. Regardless, even if the server does not persist the reply cache, EOS improves robustness and correctness over previous versions of NFS because the legacy duplicate request/reply caches were based on the ONC RPC transaction identifier (XID). Section 2.10.6.1 explains the shortcomings of the XID as a basis for a reply cache and describes how NFSv4.1 sessions improve upon the XID.",
      "ja": "サーバーが安定したストレージ内の応答キャッシュを持続しない限り、TRUEと完全なEOSは不可能で、サーバーが再起動を必要としないように実行されていない限り（実際にはそのようなサーバーが存在する場合は、返信キャッシュの間の区別が安定して保持します。保存対1つは意味なしのものではありません）。返信キャッシュの永続性についての議論については、2.10.6.5項を参照してください。とにかく、サーバが返信キャッシュを永続化しなくても、EOSは以前のバージョンのNFSに対する堅牢性と正確性を改善し、従来の重複リクエスト/返信キャッシュはONC RPCトランザクション識別子（XID）に基づいていました。セクション2.10.6.1は、返信キャッシュの基礎としてのXIDの欠点を説明し、NFSV4.1セッションがXIDを改善する方法を説明しています。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1. Slot Identifiers and Reply Cache",
      "section_title": true,
      "ja": "2.10.6.1. スロット識別子と返信キャッシュ"
    },
    {
      "indent": 3,
      "text": "The RPC layer provides a transaction ID (XID), which, while required to be unique, is not convenient for tracking requests for two reasons. First, the XID is only meaningful to the requester; it cannot be interpreted by the replier except to test for equality with previously sent requests. When consulting an RPC-based duplicate request cache, the opaqueness of the XID requires a computationally expensive look up (often via a hash that includes XID and source address). NFSv4.1 requests use a non-opaque slot ID, which is an index into a slot table, which is far more efficient. Second, because RPC requests can be executed by the replier in any order, there is no bound on the number of requests that may be outstanding at any time. To achieve perfect EOS, using ONC RPC would require storing all replies in the reply cache. XIDs are 32 bits; storing over four billion (2^(32)) replies in the reply cache is not practical. In practice, previous versions of NFS have chosen to store a fixed number of replies in the cache, and to use a least recently used (LRU) approach to replacing cache entries with new entries when the cache is full. In NFSv4.1, the number of outstanding requests is bounded by the size of the slot table, and a sequence ID per slot is used to tell the replier when it is safe to delete a cached reply.",
      "ja": "RPCレイヤーはトランザクションID（XID）を提供します。これは、一意であることが要求されている間に、2つの理由で要求を追跡するのに便利ではありません。まず、XIDは要求者にとってのみ意味があります。以前に送信された要求との平等のテストを除いて、絞り目によって解釈されることはできません。 RPCベースの重複リクエストキャッシュをコンサルティングするとき、XIDの不透明度は計算上高価なルックアップを必要とします（多くの場合、XIDと送信元アドレスを含むハッシュを介して）。 NFSV4.1要求は、スロットテーブルへのインデックスである非不透明スロットIDを使用します。これははるかに効率的です。第二に、RPC要求は任意の順序でレプリアによって実行されることができるので、いつでも未解決の要求の数にバインドされていない。完璧なEOSを達成するには、ONC RPCを使用すると、返信キャッシュ内のすべての応答を格納する必要があります。 XIDは32ビットです。返信キャッシュ内で4億を超える記憶（2 ^（32））応答は実用的ではありません。実際には、以前のバージョンのNFSは、キャッシュ内に固定数の応答を保存し、キャッシュがいっぱいのときにキャッシュエントリを新しいエントリと置き換えるために最近使用されている（LRU）アプローチを使用することを選択しました。 NFSV4.1では、未処理の要求の数はスロットテーブルのサイズによって制限され、スロットごとのシーケンスIDを使用してキャッシュされた応答を削除しても安全な場合はレプリアを伝えます。"
    },
    {
      "indent": 3,
      "text": "In the NFSv4.1 reply cache, when the requester sends a new request, it selects a slot ID in the range 0..N, where N is the replier's current maximum slot ID granted to the requester on the session over which the request is to be sent. The value of N starts out as equal to ca_maxrequests - 1 (Section 18.36), but can be adjusted by the response to SEQUENCE or CB_SEQUENCE as described later in this section. The slot ID must be unused by any of the requests that the requester has already active on the session. \"Unused\" here means the requester has no outstanding request for that slot ID.",
      "ja": "NFSV4.1応答キャッシュでは、リクエスタが新しい要求を送信すると、0.nの範囲内のスロットIDを選択します。ここで、Nは、リクエストが要求されているセッションのリクエスタの現在の最大スロットIDです。送られる。nの値はCA_MAXRequests  -  1と等しく始まります（セクション18.36）は、このセクションの後述のシーケンスまたはCB_Sequenceへの応答によって調整できます。スロットIDは、リクエスタがセッションですでにアクティブになっている要求のいずれかによって未使用でなければなりません。ここで「未使用」とは、要求者にそのスロットIDに対する未処理の要求がないことを意味します。"
    },
    {
      "indent": 3,
      "text": "A slot contains a sequence ID and the cached reply corresponding to the request sent with that sequence ID. The sequence ID is a 32-bit unsigned value, and is therefore in the range 0..0xFFFFFFFF (2^(32) - 1). The first time a slot is used, the requester MUST specify a sequence ID of one (Section 18.36). Each time a slot is reused, the request MUST specify a sequence ID that is one greater than that of the previous request on the slot. If the previous sequence ID was 0xFFFFFFFF, then the next request for the slot MUST have the sequence ID set to zero (i.e., (2^(32) - 1) + 1 mod 2^(32)).",
      "ja": "スロットはシーケンスIDとそのシーケンスIDで送信された要求に対応するキャッシュされた応答を含みます。シーケンスIDは32ビットの符号なし値であり、したがって0.0xFFFFFFFF（2 ^（32） -  1）の範囲内である。スロットが初めて使用されるとき、要求者は1のシーケンスIDを指定する必要があります（セクション18.36）。スロットが再利用されるたびに、リクエストはスロット上の前の要求の1つ以上のシーケンスIDを指定する必要があります。前のシーケンスIDが0xFFFFFFFFの場合、スロットに対する次の要求はゼロに設定されている（すなわち、（2 ^（32））1 MOD 2 ^（32））に設定されなければならない。"
    },
    {
      "indent": 3,
      "text": "The sequence ID accompanies the slot ID in each request. It is for the critical check at the replier: it used to efficiently determine whether a request using a certain slot ID is a retransmit or a new, never-before-seen request. It is not feasible for the requester to assert that it is retransmitting to implement this, because for any given request the requester cannot know whether the replier has seen it unless the replier actually replies. Of course, if the requester has seen the reply, the requester would not retransmit.",
      "ja": "シーケンスIDは各要求のスロットIDを伴う。それは専門的なチェックのためのものです。特定のスロットIDを使用している要求が再送信であるか新しい、未承認の要求であるかどうかを効率的に決定するために使用されます。要求者が実際に応答しない限り、リクエスターがレプリアがそれを見たことがわかりません。もちろん、リクエスターが返信を見た場合、リクエスタは再送信されません。"
    },
    {
      "indent": 3,
      "text": "The replier compares each received request's sequence ID with the last one previously received for that slot ID, to see if the new request is:",
      "ja": "Replierは、新しい要求が次のようになっているかどうかを確認するために、そのスロットIDに対して以前に受信した各受信した要求のシーケンスIDを比較します。"
    },
    {
      "indent": 3,
      "text": "* A new request, in which the sequence ID is one greater than that previously seen in the slot (accounting for sequence wraparound). The replier proceeds to execute the new request, and the replier MUST increase the slot's sequence ID by one.",
      "ja": "* シーケンスIDがスロットで前回見たものより1つ多い新しい要求（シーケンスラップアラウンドの会計）。REPLIERは新しい要求の実行に進み、レプリアはスロットのシーケンスIDを1つずつ増やす必要があります。"
    },
    {
      "indent": 3,
      "text": "* A retransmitted request, in which the sequence ID is equal to that currently recorded in the slot. If the original request has executed to completion, the replier returns the cached reply. See Section 2.10.6.2 for direction on how the replier deals with retries of requests that are still in progress.",
      "ja": "* シーケンスIDが現在スロットに記録されているものと等しい再送信要求。元の要求が完了した場合、Replierはキャッシュされた応答を返します。2.10.6.2セクションを参照してください。レプリアがまだ進行中の要求の再試行を扱う方法についての方向については、「2.10.6.2」を参照してください。"
    },
    {
      "indent": 3,
      "text": "* A misordered retry, in which the sequence ID is less than (accounting for sequence wraparound) that previously seen in the slot. The replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "* シーケンスIDが以前にスロット内で前に見られた（シーケンスラップアラウンドの会計処理）より小さい誤った再試行。REPLIERはNFS4ERR_SEQ_MISORDERED（結果として（シーケンスまたはCB_SEQUENCE）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* A misordered new request, in which the sequence ID is two or more than (accounting for sequence wraparound) that previously seen in the slot. Note that because the sequence ID MUST wrap around to zero once it reaches 0xFFFFFFFF, a misordered new request and a misordered retry cannot be distinguished. Thus, the replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "* シーケンスIDが、スロット内で以前に見られた（シーケンスラップアラウンドの会計処理）2以上の誤った新しい要求。シーケンスIDは、0xFFFFFFFFに達すると、誤って命令された新しい要求と誤ったリトライを区別することはできません。したがって、レプリタはNFS4ERR_SEQ_MISORDERED（結果として（シーケンスまたはCB_SEQUENCE）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Unlike the XID, the slot ID is always within a specific range; this has two implications. The first implication is that for a given session, the replier need only cache the results of a limited number of COMPOUND requests. The second implication derives from the first, which is that unlike XID-indexed reply caches (also known as duplicate request caches - DRCs), the slot ID-based reply cache cannot be overflowed. Through use of the sequence ID to identify retransmitted requests, the replier does not need to actually cache the request itself, reducing the storage requirements of the reply cache further. These facilities make it practical to maintain all the required entries for an effective reply cache.",
      "ja": "XIDとは異なり、スロットIDは常に特定の範囲内です。これには2つの意味があります。第1の意味は、特定のセッションの場合、レプリアは限られた数の複合要求の結果をキャッシュするだけであることである。2番目の含意は最初から派生します。これは、XIDインデックス付きの返信キャッシュとは異なり（重複する要求キャッシュ -  DRCとも呼ばれます）、スロットIDベースの応答キャッシュをオーバーフローすることはできません。再送信要求を識別するためにシーケンスIDを使用することで、レプリタは要求自体を実際にキャッシュする必要はなく、返信キャッシュのストレージ要件をさらに短縮する必要はありません。これらの施設は、効果的な返信キャッシュのすべての必要なエントリを維持することを実用的にします。"
    },
    {
      "indent": 3,
      "text": "The slot ID, sequence ID, and session ID therefore take over the traditional role of the XID and source network address in the replier's reply cache implementation. This approach is considerably more portable and completely robust -- it is not subject to the reassignment of ports as clients reconnect over IP networks. In addition, the RPC XID is not used in the reply cache, enhancing robustness of the cache in the face of any rapid reuse of XIDs by the requester. While the replier does not care about the XID for the purposes of reply cache management (but the replier MUST return the same XID that was in the request), nonetheless there are considerations for the XID in NFSv4.1 that are the same as all other previous versions of NFS. The RPC XID remains in each message and needs to be formulated in NFSv4.1 requests as in any other ONC RPC request. The reasons include:",
      "ja": "したがって、スロットID、シーケンスID、およびセッションIDは、レプリタの応答キャッシュ実装内のXIDおよびソースネットワークアドレスの従来の役割を引き継ぎます。このアプローチはかなりポータブルで完全に堅牢です。クライアントがIPネットワークを介して再接続されているため、ポートの再割り当てが受けられません。さらに、RPC XIDは応答キャッシュでは使用されず、リクエスターによるXIDの迅速な再利用の範囲内のキャッシュの堅牢性を高めます。Replier Cache Managementの目的のためにXIDを気にしない間（ただし、リクエストが要求されていた同じXIDを返す必要があります）。それにもかかわらず、他のすべてと同じであるNFSv4.1のXIDに関する考慮事項があります。以前のバージョンのNFS。RPC XIDは各メッセージに残り、他のONC RPC要求のようにNFSv4.1要求に定式化する必要があります。その理由は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* The RPC layer retains its existing semantics and implementation.",
      "ja": "* RPC層は既存の意味と実装を保持しています。"
    },
    {
      "indent": 3,
      "text": "* The requester and replier must be able to interoperate at the RPC layer, prior to the NFSv4.1 decoding of the SEQUENCE or CB_SEQUENCE operation.",
      "ja": "* リクエスターとレプリタは、シーケンスまたはCB_SEQUENCE動作のNFSV4.1の復号化の前に、RPCレイヤーで相互運用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "* If an operation is being used that does not start with SEQUENCE or CB_SEQUENCE (e.g., BIND_CONN_TO_SESSION), then the RPC XID is needed for correct operation to match the reply to the request.",
      "ja": "* シーケンスまたはCB_SEQUENCE（例えば、bind_conn_to_session）で始まらない操作が使用されている場合、RPC XIDは要求への応答と一致するように正しい操作のために必要です。"
    },
    {
      "indent": 3,
      "text": "* The SEQUENCE or CB_SEQUENCE operation may generate an error. If so, the embedded slot ID, sequence ID, and session ID (if present) in the request will not be in the reply, and the requester has only the XID to match the reply to the request.",
      "ja": "* シーケンスまたはCB_Sequenceの動作はエラーを生成する可能性があります。もしそうであれば、リクエスト内の埋め込みスロットID、シーケンスID、およびセッションID（存在する場合）は返信に含まれず、要求に応答に合わせるためのXIDのみがあります。"
    },
    {
      "indent": 3,
      "text": "Given that well-formulated XIDs continue to be required, this raises the question: why do SEQUENCE and CB_SEQUENCE replies have a session ID, slot ID, and sequence ID? Having the session ID in the reply means that the requester does not have to use the XID to look up the session ID, which would be necessary if the connection were associated with multiple sessions. Having the slot ID and sequence ID in the reply means that the requester does not have to use the XID to look up the slot ID and sequence ID. Furthermore, since the XID is only 32 bits, it is too small to guarantee the re-association of a reply with its request [44]; having session ID, slot ID, and sequence ID in the reply allows the client to validate that the reply in fact belongs to the matched request.",
      "ja": "適切な策定されているXIDが継続され続けることを考えると、これは質問を上げます：なぜSequenceとCB_Sequenceの応答にセッションID、スロットID、およびシーケンスIDがあるのですか？応答にセッションIDを持つことは、リクエスタがセッションIDを検索するためにXIDを使用する必要がないことを意味します。これは、接続が複数のセッションに関連付けられている場合に必要です。REPLYにスロットIDとシーケンスIDを持つことは、リクエスタがスロットIDとシーケンスIDを調べるためにXIDを使用する必要がないことを意味します。また、XIDは32ビットであるため、リクエストとのリクエストの再関連付けを保証するのに小さすぎる[44]。応答内のセッションID、スロットID、およびシーケンスIDを持つことで、クライアントは、実際の応答が一致した要求に属していることを検証できます。"
    },
    {
      "indent": 3,
      "text": "The SEQUENCE (and CB_SEQUENCE) operation also carries a \"highest_slotid\" value, which carries additional requester slot usage information. The requester MUST always indicate the slot ID representing the outstanding request with the highest-numbered slot value. The requester should in all cases provide the most conservative value possible, although it can be increased somewhat above the actual instantaneous usage to maintain some minimum or optimal level. This provides a way for the requester to yield unused request slots back to the replier, which in turn can use the information to reallocate resources.",
      "ja": "シーケンス（およびCB_Sequence）操作は、追加のリクエスタスロット使用情報を搭載している「最高_SLOTID」値を搬送します。リクエスターは常に最上位のスロット値を持つ未解決の要求を表すスロットIDを示す必要があります。すべての場合には、すべての場合に最も控えめな価値を提供する必要がありますが、最小レベルまたは最適なレベルを維持するための実際の瞬時使用法よりも幾分上回ることができます。これにより、要求者が未使用の要求スロットをレプリアに返す方法を提供します。これにより、情報を使用してリソースが再割り当てされます。"
    },
    {
      "indent": 3,
      "text": "The replier responds with both a new target highest_slotid and an enforced highest_slotid, described as follows:",
      "ja": "replierは、次のように説明されている新しいターゲットのimpslotidとentoced hisspslotidの両方で応答します。"
    },
    {
      "indent": 3,
      "text": "* The target highest_slotid is an indication to the requester of the highest_slotid the replier wishes the requester to be using. This permits the replier to withdraw (or add) resources from a requester that has been found to not be using them, in order to more fairly share resources among a varying level of demand from other requesters. The requester must always comply with the replier's value updates, since they indicate newly established hard limits on the requester's access to session resources. However, because of request pipelining, the requester may have active requests in flight reflecting prior values; therefore, the replier must not immediately require the requester to comply.",
      "ja": "* ターゲットhiste_slotidは、replicierが要求者に使用する希望者が求められているrequest_lotidの要求者への指示です。これにより、他のリクエスタからさまざまなレベルの需要の間でリソースをより公正に共有するために、それらを使用していないことが判明したリクエスターからリソースを撤回する（または追加）リソースを引き出す（または追加）リソースを引き出すことができます。リクエスタのセッションリソースへのアクセス権に対して新しく確立されたハードリミットを示すので、リクエスターは常にレプリアの値の更新に準拠している必要があります。しかしながら、リクエストパイプライン化のために、要求者は事前の値を反映して有効な要求を有することができる。したがって、レプリタはすぐに要求者に準拠する必要がありません。"
    },
    {
      "indent": 3,
      "text": "* The enforced highest_slotid indicates the highest slot ID the requester is permitted to use on a subsequent SEQUENCE or CB_SEQUENCE operation. The replier's enforced highest_slotid SHOULD be no less than the highest_slotid the requester indicated in the SEQUENCE or CB_SEQUENCE arguments.",
      "ja": "* 施行されたhist_slotidは、最上位のスロットIDを示しています。要求者は、後続のシーケンスまたはCB_Sequence操作で使用できます。replierの強制されたhiss_slotidは、sequenceまたはcb_sequence引数に示されている要求者がhists_slotidを下回る必要があります。"
    },
    {
      "indent": 6,
      "text": "A requester can be intransigent with respect to lowering its highest_slotid argument to a Sequence operation, i.e. the requester continues to ignore the target highest_slotid in the response to a Sequence operation, and continues to set its highest_slotid argument to be higher than the target highest_slotid. This can be considered particularly egregious behavior when the replier knows there are no outstanding requests with slot IDs higher than its target highest_slotid. When faced with such intransigence, the replier is free to take more forceful action, and MAY reply with a new enforced highest_slotid that is less than its previous enforced highest_slotid. Thereafter, if the requester continues to send requests with a highest_slotid that is greater than the replier's new enforced highest_slotid, the server MAY return NFS4ERR_BAD_HIGH_SLOT, unless the slot ID in the request is greater than the new enforced highest_slotid and the request is a retry.",
      "ja": "リクエスターは、そのhisto_slotid引数をシーケンス操作に低下させることに関して、すなわち、requesterがシーケンス操作に対する応答でターゲットの高いものを無視し続け、そのinters_slotid引数をターゲットの高いものよりも高く設定し続ける。これは、スロットIDがターゲットIDより高い標準IDより高い要求がないことを認識している場合、これは特に大きな動作と見なすことができます。そのようなインターンジェンスに直面したとき、専用家はより強力な行動を自由に受け取り、それ以前の施行された最高司令官よりも少ない新しい強制暫定_SLOTIDで返信することができます。その後、リクエスタがReplierの新しい強制されたISLOTIDより大きいISTION_SLOTIDで要求を送信し続けると、リクエスト内のスロットIDが新しい強制されたISLOTIDより大きい場合は、サーバーはNFS4R_BAD_HIGH_SLOTを返し、リクエストが再試行している場合があります。"
    },
    {
      "indent": 6,
      "text": "The replier SHOULD retain the slots it wants to retire until the requester sends a request with a highest_slotid less than or equal to the replier's new enforced highest_slotid.",
      "ja": "RequesterがRequesterがReplierの新しい強制されたISSLOTID以上で要求を送信するまで、再起動したいスロットを保持する必要があります。"
    },
    {
      "indent": 6,
      "text": "The requester can also be intransigent with respect to sending non-retry requests that have a slot ID that exceeds the replier's highest_slotid. Once the replier has forcibly lowered the enforced highest_slotid, the requester is only allowed to send retries on slots that exceed the replier's highest_slotid. If a request is received with a slot ID that is higher than the new enforced highest_slotid, and the sequence ID is one higher than what is in the slot's reply cache, then the server can both retire the slot and return NFS4ERR_BADSLOT (however, the server MUST NOT do one and not the other). The reason it is safe to retire the slot is because by using the next sequence ID, the requester is indicating it has received the previous reply for the slot.",
      "ja": "リクエスト担当者は、レプリアのhisswotidを超えるスロットIDを持つ、再試行されていない要求を送信することに関して、無信度にすることもできます。Replierが強制されているISTION_SLOTIDを強制的に低下させると、リクエスタはレプリアのhisslotidを超えるスロットの再試行のみを送信できます。新しい強制ISLOTIDよりも高いスロットIDで要求が受信され、シーケンスIDがスロットの応答キャッシュ内にあるものより高い場合は、サーバーは両方ともスロットを再退縮させてNFS4ERR_BADSLOTを返すことができます（ただし、サーバーもう一方をしてはいけません）。スロットを退行させても安全な理由は、次のシーケンスIDを使用することによって、リクエスタはスロットに対して前の応答を受信したことを示すからです。"
    },
    {
      "indent": 3,
      "text": "* The requester SHOULD use the lowest available slot when sending a new request. This way, the replier may be able to retire slot entries faster. However, where the replier is actively adjusting its granted highest_slotid, it will not be able to use only the receipt of the slot ID and highest_slotid in the request. Neither the slot ID nor the highest_slotid used in a request may reflect the replier's current idea of the requester's session limit, because the request may have been sent from the requester before the update was received. Therefore, in the downward adjustment case, the replier may have to retain a number of reply cache entries at least as large as the old value of maximum requests outstanding, until it can infer that the requester has seen a reply containing the new granted highest_slotid. The replier can infer that the requester has seen such a reply when it receives a new request with the same slot ID as the request replied to and the next higher sequence ID.",
      "ja": "* リクエスタは、新しい要求を送信するときに最も低いスロットを使用する必要があります。このようにして、レプリアはスロットエントリをより速く遅らせることができるかもしれません。ただし、レプリアが積極的に付与されているISTIS_SLOTIDを積極的に調整している場合は、リクエスト内のスロットIDとSLOTIDの受信のみを使用できません。リクエストで使用されているスロットIDもSLOT_SLOTIDも、更新が受信される前にリクエスタから送信された可能性があるため、リクエスタのセッション制限のリクエストの現在のアイデアを反映しています。したがって、下向き調整ケースでは、リクエスタが未処理の最大要求の古い値と同じくらい大きなリクエストの古い値と同じくらい大きな応答キャッシュエントリを、依存していると推測されるまで、要求者が新しいArgited_SLOTIDを含む返信を見たことができる。リプライアは、リクエストがリクエストと同じスロットIDを持つ新しい要求を受信したとき、および次の高いシーケンスIDを持つ新しい要求を受信したときに、要求者がそのような応答を見たことを推測できます。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.1. Caching of SEQUENCE and CB_SEQUENCE Replies",
      "section_title": true,
      "ja": "2.10.6.1.1. シーケンスとCB_Sequenceのキャッシング"
    },
    {
      "indent": 3,
      "text": "When a SEQUENCE or CB_SEQUENCE operation is successfully executed, its reply MUST always be cached. Specifically, session ID, sequence ID, and slot ID MUST be cached in the reply cache. The reply from SEQUENCE also includes the highest slot ID, target highest slot ID, and status flags. Instead of caching these values, the server MAY re-compute the values from the current state of the fore channel, session, and/or client ID as appropriate. Similarly, the reply from CB_SEQUENCE includes a highest slot ID and target highest slot ID. The client MAY re-compute the values from the current state of the session as appropriate.",
      "ja": "シーケンスまたはCB_SEQUENCE動作が正常に実行されると、その応答は常にキャッシュされなければなりません。具体的には、返信キャッシュにセッションID、シーケンスID、およびスロットIDをキャッシュする必要があります。シーケンスからの返信には、最も高いスロットID、目標最高スロットID、およびステータスフラグが含まれます。これらの値をキャッシュする代わりに、サーバーは、必要に応じて、前チャネル、セッション、および/またはクライアントIDの現在の状態から値を再計算できます。同様に、CB_Sequenceからの応答には、最も高いスロットIDとターゲット最高スロットIDが含まれています。クライアントは、必要に応じてセッションの現在の状態から値を再計算できます。"
    },
    {
      "indent": 3,
      "text": "Regardless of whether or not a replier is re-computing highest slot ID, target slot ID, and status on replies to retries, the requester MUST NOT assume that the values are being re-computed whenever it receives a reply after a retry is sent, since it has no way of knowing whether the reply it has received was sent by the replier in response to the retry or is a delayed response to the original request. Therefore, it may be the case that highest slot ID, target slot ID, or status bits may reflect the state of affairs when the request was first executed. Although acting based on such delayed information is valid, it may cause the receiver of the reply to do unneeded work. Requesters MAY choose to send additional requests to get the current state of affairs or use the state of affairs reported by subsequent requests, in preference to acting immediately on data that might be out of date.",
      "ja": "Replierが最も高いスロットID、ターゲットスロットID、およびレプリブのステータスを再計算しているかどうかにかかわらず、リクエスタは再試行が送信された後に返信を受け取るたびに値が再計算されていると想定してはなりません。再試行に応答して受信した返信が再試行者によって送信されたかどうかを知らないので、元の要求に対する遅延応答である。したがって、要求が最初に実行されたときに、最も高いスロットID、対象スロットID、またはステータスビットが事態を反映している場合がある。そのような遅延情報に基づく作用は有効であるが、返信の受信者が不要な作業をする可能性がある。リクエスタは、現在の状況を取得するため、または後続の要求によって報告された状況を使用して、最新の要求によって報告されている状況を使用することを選択します。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.2. Errors from SEQUENCE and CB_SEQUENCE",
      "section_title": true,
      "ja": "2.10.6.1.2. シーケンスとCB_Sequenceからのエラー"
    },
    {
      "indent": 3,
      "text": "Any time SEQUENCE or CB_SEQUENCE returns an error, the sequence ID of the slot MUST NOT change. The replier MUST NOT modify the reply cache entry for the slot whenever an error is returned from SEQUENCE or CB_SEQUENCE.",
      "ja": "任意の時系列またはCB_Sequenceはエラーを返し、スロットのシーケンスIDは変更してはなりません。replierは、エラーがシーケンスまたはCB_Sequenceから返されるたびに、スロットの応答キャッシュエントリを変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.3. Optional Reply Caching",
      "section_title": true,
      "ja": "2.10.6.1.3. オプションの返信キャッシング"
    },
    {
      "indent": 3,
      "text": "On a per-request basis, the requester can choose to direct the replier to cache the reply to all operations after the first operation (SEQUENCE or CB_SEQUENCE) via the sa_cachethis or csa_cachethis fields of the arguments to SEQUENCE or CB_SEQUENCE. The reason it would not direct the replier to cache the entire reply is that the request is composed of all idempotent operations [41]. Caching the reply may offer little benefit. If the reply is too large (see Section 2.10.6.4), it may not be cacheable anyway. Even if the reply to idempotent request is small enough to cache, unnecessarily caching the reply slows down the server and increases RPC latency.",
      "ja": "要求ごとに、リクエスタは、順序またはcb_sequenceの引数のSA_CACHETHISまたはCSA_CACHETISフィールドを介して、最初の操作（シーケンスまたはCB_SEQUENCE）の後にすべての操作に応答をキャッシュするようにreplierを指示することを選択できます。Replier全体をキャッシュに指示しない理由は、要求がすべてのIDEmPotent操作で構成されていることです[41]。返信をキャッシュすると、利益がほとんどありません。返信が大きすぎる場合（2.10.6.4項を参照）、とにかくキャッシュ可能ではないかもしれません。iDempotent要求への返信がキャッシュするのに十分小さい場合でも、返信を不必要にキャッシュしてサーバーを遅くし、RPCレイテンシを増やします。"
    },
    {
      "indent": 3,
      "text": "Whether or not the requester requests the reply to be cached has no effect on the slot processing. If the result of SEQUENCE or CB_SEQUENCE is NFS4_OK, then the slot's sequence ID MUST be incremented by one. If a requester does not direct the replier to cache the reply, the replier MUST do one of following:",
      "ja": "リクエスターがキャッシュされるような応答を要求するかどうかはスロット処理には影響しません。シーケンスまたはCB_Sequenceの結果がNFS4_OKの場合、スロットのシーケンスIDは1つインクリメントされなければなりません。リクエスタがリプライアに返信をキャッシュするように指示しない場合、レプリアは次のいずれかを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The replier can cache the entire original reply. Even though sa_cachethis or csa_cachethis is FALSE, the replier is always free to cache. It may choose this approach in order to simplify implementation.",
      "ja": "* replierは元の返信全体をキャッシュできます。SA_CACHETHISまたはCSA_CACHETHISがfalseであっても、replierは常にキャッシュを自由にしています。実装を簡単にするためにこのアプローチを選択することができます。"
    },
    {
      "indent": 3,
      "text": "* The replier enters into its reply cache a reply consisting of the original results to the SEQUENCE or CB_SEQUENCE operation, and with the next operation in COMPOUND or CB_COMPOUND having the error NFS4ERR_RETRY_UNCACHED_REP. Thus, if the requester later retries the request, it will get NFS4ERR_RETRY_UNCACHED_REP. If a replier receives a retried Sequence operation where the reply to the COMPOUND or CB_COMPOUND was not cached, then the replier,",
      "ja": "* レプリアは、その応答キャッシュに、元の結果からシーケンスまたはCB_Sequence操作、およびエラーNFS4ERR_RETRY_UNCACHED_REPを有する化合物またはCB_COMPOUNDでの次の操作で返信キャッシュをキャッシュに入ります。したがって、要求者が後で要求を再試行すると、NFS4ERR_RETRY_UNCACHED_REPが得られます。リプライアが複製シーケンス操作を受信した場合、複合またはcb_compoundへの応答がキャッシュされていない場合は、"
    },
    {
      "indent": 6,
      "text": "- MAY return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is not the first operation (granted, a requester that does so is in violation of the NFSv4.1 protocol).",
      "ja": "- シーケンス操作が最初の操作ではない場合は、シーケンス操作に応答してNFS4ERR_RETRY_UNCACHED_REPを返します（許可されている要求者は、NFSV4.1プロトコルに違反しているリクエスター）。"
    },
    {
      "indent": 6,
      "text": "- MUST NOT return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is the first operation.",
      "ja": "- シーケンス操作が最初の操作である場合、シーケンス操作に応答してNFS4ERR_RETRY_UNCACHED_REPを返してはなりません。"
    },
    {
      "indent": 3,
      "text": "* If the second operation is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MUST NOT ever return NFS4ERR_RETRY_UNCACHED_REP. Instead the replier MUST return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate.",
      "ja": "* 2番目の操作が不正な操作である場合、または以前のマイナーバージョンのNFSV4で正当な操作で、現在のマイナーバージョン（例えばSetClientID）でサポートされていなければならない場合は、ReplierがNFS4ERR_RETRY_UNCACHED_REPを返さないようにしてください。代わりに、必要に応じて、replierはNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the second operation can result in another error status, the replier MAY return a status other than NFS4ERR_RETRY_UNCACHED_REP, provided the operation is not executed in such a way that the state of the replier is changed. Examples of such an error status include: NFS4ERR_NOTSUPP returned for an operation that is legal but not REQUIRED in the current minor versions, and thus not supported by the replier; NFS4ERR_SEQUENCE_POS; and NFS4ERR_REQ_TOO_BIG.",
      "ja": "* 第2の操作が別のエラー状態になる可能性がある場合、レプリアの状態が変更されるように操作が実行されない場合には、ReplierがNFS4ERR_RETRY_UNCACHED_REPを返すことができる。このようなエラーステータスの例は次のとおりです.nfs4err_notsuppは、正当な操作に対して返され、現在のマイナーバージョンでは必須ではなく、したがってレプリアによってサポートされていません。NFS4ERR_SEQUENCE_POS;NFS4ERR_REQ_TOO_BIG。"
    },
    {
      "indent": 3,
      "text": "The discussion above assumes that the retried request matches the original one. Section 2.10.6.1.3.1 discusses what the replier might do, and MUST do when original and retried requests do not match. Since the replier may only cache a small amount of the information that would be required to determine whether this is a case of a false retry, the replier may send to the client any of the following responses:",
      "ja": "上記の説明は、再試行要求が元のものと一致すると仮定しています。セクション2.10.6.1.3.1既製ができることを説明し、オリジナルおよびリトライ要求が一致しない場合に実行する必要があります。絞り込みは、これが誤った再試行の場合であるかどうかを判断するために必要とされる少量の情報をキャッシュすることができるので、次の応答のいずれかの任意の応答のいずれかをクライアントに送信することができます。"
    },
    {
      "indent": 3,
      "text": "* The cached reply to the original request (if the replier has cached it in its entirety and the users of the original request and retry match).",
      "ja": "* 元のリクエストへのキャッシュされた返信（レプリアが全体としてキャッシュした場合、元の要求と再試行のユーザにキャッシュした場合）。"
    },
    {
      "indent": 3,
      "text": "* A reply that consists only of the Sequence operation with the error NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "* エラーNFS4ERR_SEQ_FALSE_RETRYを使用してシーケンス操作のみで構成されている応答。"
    },
    {
      "indent": 3,
      "text": "* A reply consisting of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the retried request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.",
      "ja": "* NFS4ERR_RETRY_UNCACHED_REPまたはその他のエラーのエラーを誤りに登録されているときに、ステータスNFS4_OKとの応答からの応答と、上述のようにして実行された応答からなる。"
    },
    {
      "indent": 3,
      "text": "* A reply that consists of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the original request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.",
      "ja": "* NFS4ERR_RETRY_UNCACHED_REPまたはその他のエラーのエラーを持つ、NFS4ERR_RETRY_UNCACHED_REPまたはその他のエラーのエラーを持つ最初の要求に登場したときの、ステータスNFS4_OKとの応答からの応答で構成されています。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.3.1. False Retry",
      "section_title": true,
      "ja": "2.10.6.1.3.1. 誤った再試行"
    },
    {
      "indent": 3,
      "text": "If a requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache but the replier detected that the retried request is not the same as the original request, including a retry that has different operations or different arguments in the operations from the original and a retry that uses a different principal in the RPC request's credential field that translates to a different user, then this is a false retry. When the replier detects a false retry, it is permitted (but not always obligated) to return NFS4ERR_SEQ_FALSE_RETRY in response to the Sequence operation when it detects a false retry.",
      "ja": "リクエスタが応答キャッシュ内にあるスロットIDとシーケンスIDを使用して依頼者がシーケンス操作を送信した場合、再試行要求が元の要求と同じではないことを検出した場合は、操作に異なる操作または異なる引数を持つリトライを含む。元のユーザーに変換されたRPC要求フィールドで異なるプリンシパルを使用する元のリトライから、これは誤った再試行です。REPLIERが誤った再試行を検出すると、誤った再試行を検出したときにシーケンス操作に応答してNFS4ERR_SEQ_FALSE_RETRYを返すことが許可されます（ただし必ず義務付けられていません）。"
    },
    {
      "indent": 3,
      "text": "Translations of particularly privileged user values to other users due to the lack of appropriately secure credentials, as configured on the replier, should be applied before determining whether the users are the same or different. If the replier determines the users are different between the original request and a retry, then the replier MUST return NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "絞り目に設定されているように、適切に安全な認証情報がないため、特に特権ユーザーの値の翻訳は、ユーザーが同じか異なるかどうかを判断する前に適用する必要があります。Replierが元の要求と再試行の間でユーザーが異なると判断した場合、レプリタはNFS4ERR_SEQ_FALSE_RETRYを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If an operation of the retry is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MAY return NFS4ERR_SEQ_FALSE_RETRY (and MUST do so if the users of the original request and retry differ). Otherwise, the replier MAY return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate. Note that the handling is in contrast for how the replier deals with retries requests with no cached reply. The difference is due to NFS4ERR_SEQ_FALSE_RETRY being a valid error for only Sequence operations, whereas NFS4ERR_RETRY_UNCACHED_REP is a valid error for all operations except illegal operations and operations that MUST NOT be supported in the current minor version of NFSv4.",
      "ja": "再試行の操作が不正な操作、または以前のマイナーバージョンのNFSV4で正当な操作で、現在のマイナーバージョン（SetClientID）ではサポートされてはならない操作であれば、ReplierはNFS4ERR_SEQ_FALSE_RETRYを返すことができます（そしてそうしなければならない元の要求のユーザーが異なる場合）それ以外の場合、レプリタは必要に応じてNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを返すことがあります。リプライアがリトライを取得する方法は、キャッシュされた返信のない要求にどのように取引されるかについては、処理が対照的です。この違いは、NFS4ERR_SEQ_FALSE_RETRYのみがシーケンス操作のみの有効なエラーであるため、NFS4ERR_RETRY_UNCACHED_REPは、NFSV4の現在のマイナーバージョンでサポートされていなければならない違法な操作と操作を除くすべての操作の有効なエラーです。"
    },
    {
      "indent": 0,
      "text": "2.10.6.2. Retry and Replay of Reply",
      "section_title": true,
      "ja": "2.10.6.2. 返信を再試行して再生します"
    },
    {
      "indent": 3,
      "text": "A requester MUST NOT retry a request, unless the connection it used to send the request disconnects. The requester can then reconnect and re-send the request, or it can re-send the request over a different connection that is associated with the same session.",
      "ja": "リクエストが切断された接続を送信するために使用されていない限り、リクエスタは要求を再試行してはいけません。その後、リクエスタはリクエストを再接続して再送信することも、同じセッションに関連付けられている異なる接続を介して要求を再送信することもできます。"
    },
    {
      "indent": 3,
      "text": "If the requester is a server wanting to re-send a callback operation over the backchannel of a session, the requester of course cannot reconnect because only the client can associate connections with the backchannel. The server can re-send the request over another connection that is bound to the same session's backchannel. If there is no such connection, the server MUST indicate that the session has no backchannel by setting the SEQ4_STATUS_CB_PATH_DOWN_SESSION flag bit in the response to the next SEQUENCE operation from the client. The client MUST then associate a connection with the session (or destroy the session).",
      "ja": "リクエスターがセッションのバックチャンネルを介してコールバック操作を再送信したいサーバーである場合、コースは、クライアントのみがBackChannelとの接続を関連付けることができるために再接続できません。サーバーは、同じセッションのBackChannelにバインドされている別の接続を介して要求を再送信できます。そのような接続がない場合、サーバーは、クライアントからの次のシーケンス操作に応答してSEQ4_STATUS_CB_PATH_DOWN_SESSIONフラグビットを設定して、セッションにバックチャネルがないことを示している必要があります。その後、クライアントはセッションとの接続を関連付ける（またはセッションを破壊する）。"
    },
    {
      "indent": 3,
      "text": "Note that it is not fatal for a requester to retry without a disconnect between the request and retry. However, the retry does consume resources, especially with RDMA, where each request, retry or not, consumes a credit. Retries for no reason, especially retries sent shortly after the previous attempt, are a poor use of network bandwidth and defeat the purpose of a transport's inherent congestion control system.",
      "ja": "要求者がリクエストとリトライ間の切断なしで再試行することが致命的ではないことに注意してください。ただし、Retryは、特にRDMAを使用してリソースを消費します。ここで、各要求、再試行、またはNOTはクレジットを消費します。理由がない、特に前回の試みの後すぐに送付された再試行は、ネットワーク帯域幅の使用不良であり、トランスポートの固有の輻輳制御システムの目的を軽減します。"
    },
    {
      "indent": 3,
      "text": "A requester MUST wait for a reply to a request before using the slot for another request. If it does not wait for a reply, then the requester does not know what sequence ID to use for the slot on its next request. For example, suppose a requester sends a request with sequence ID 1, and does not wait for the response. The next time it uses the slot, it sends the new request with sequence ID 2. If the replier has not seen the request with sequence ID 1, then the replier is not expecting sequence ID 2, and rejects the requester's new request with NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "要求者は、スロットを別の要求に使用する前に要求への返信を待つ必要があります。返信を待っていない場合、リクエスターは次の要求のスロットに使用するシーケンスIDを知りません。たとえば、リクエスターがシーケンスID 1で要求を送信し、応答を待っていないとします。次回スロットを使用するときは、シーケンスID 2で新しい要求を送信します。レプリアがシーケンスID 1の要求を見ていない場合は、レプリアはシーケンスID 2を期待していないため、NFS4ER_SEQ_MISORDERDED（シーケンスまたはCB_Sequenceの結果として。"
    },
    {
      "indent": 3,
      "text": "RDMA fabrics do not guarantee that the memory handles (Steering Tags) within each RPC/RDMA \"chunk\" [32] are valid on a scope outside that of a single connection. Therefore, handles used by the direct operations become invalid after connection loss. The server must ensure that any RDMA operations that must be replayed from the reply cache use the newly provided handle(s) from the most recent request.",
      "ja": "RDMAファブリックは、各RPC / RDMA \"チャンク\" [32]内のメモリハンドル（ステアリングタグ）が単一の接続の外側の範囲で有効であることを保証しません。したがって、接続損失後に直接操作で使用されるハンドルが無効になります。サーバーは、返信キャッシュから再生する必要があるRDMA操作が、最新の要求から新しく提供されたハンドルを使用していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "A retry might be sent while the original request is still in progress on the replier. The replier SHOULD deal with the issue by returning NFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE operation, but implementations MAY return NFS4ERR_MISORDERED. Since errors from SEQUENCE and CB_SEQUENCE are never recorded in the reply cache, this approach allows the results of the execution of the original request to be properly recorded in the reply cache (assuming that the requester specified the reply to be cached).",
      "ja": "元の要求が依然として再スポードで進行中の間に再試行が送信されることがあります。replierは、SequenceまたはCB_Sequence操作への返信としてNFS4ERR_DELAYを返すことによって問題に対処する必要がありますが、実装はNFS4ERR_MISORDEREDを返すことがあります。シーケンスとCB_Sequenceからのエラーが返信キャッシュに記録されないため、元の要求の実行結果を返信キャッシュに適切に記録することができます（リクエスタがキャッシュされる応答を指定したと仮定する）。"
    },
    {
      "indent": 0,
      "text": "2.10.6.3. Resolving Server Callback Races",
      "section_title": true,
      "ja": "2.10.6.3. サーバーコールバックレースの解決"
    },
    {
      "indent": 3,
      "text": "It is possible for server callbacks to arrive at the client before the reply from related fore channel operations. For example, a client may have been granted a delegation to a file it has opened, but the reply to the OPEN (informing the client of the granting of the delegation) may be delayed in the network. If a conflicting operation arrives at the server, it will recall the delegation using the backchannel, which may be on a different transport connection, perhaps even a different network, or even a different session associated with the same client ID.",
      "ja": "関連するフォアチャネル操作からの応答の前に、サーバーコールバックがクライアントに到着することが可能です。例えば、クライアントは、開かれたファイルへの委任が許可されているかもしれないが、開くこと（代表団の付与のクライアントを知らせる）はネットワーク内で遅延されてもよい。競合する操作がサーバーに到着すると、バックチャネルを使用して委任が呼び出されます。これは、異なるトランスポート接続、おそらく異なるネットワークでさえ、または同じクライアントIDに関連付けられた異なるセッションでさえも呼び出されます。"
    },
    {
      "indent": 3,
      "text": "The presence of a session between the client and server alleviates this issue. When a session is in place, each client request is uniquely identified by its { session ID, slot ID, sequence ID } triple. By the rules under which slot entries (reply cache entries) are retired, the server has knowledge whether the client has \"seen\" each of the server's replies. The server can therefore provide sufficient information to the client to allow it to disambiguate between an erroneous or conflicting callback race condition.",
      "ja": "クライアントとサーバー間のセッションの存在はこの問題を軽減します。セッションが所定の位置にあるとき、各クライアント要求はその{セッションID、スロットID、シーケンスID}トリプルによって一意に識別されます。スロットエントリ（応答キャッシュエントリ）が引退したルールによって、サーバーはクライアントが各サーバーの返信を「見た」かどうかの知識を持っています。したがって、サーバは、誤ったコールバック競合状態と矛盾するコールバック競合状態との間で曖昧さを解消することを可能にするためにクライアントに十分な情報を提供することができる。"
    },
    {
      "indent": 3,
      "text": "For each client operation that might result in some sort of server callback, the server SHOULD \"remember\" the { session ID, slot ID, sequence ID } triple of the client request until the slot ID retirement rules allow the server to determine that the client has, in fact, seen the server's reply. Until the time the { session ID, slot ID, sequence ID } request triple can be retired, any recalls of the associated object MUST carry an array of these referring identifiers (in the CB_SEQUENCE operation's arguments), for the benefit of the client. After this time, it is not necessary for the server to provide this information in related callbacks, since it is certain that a race condition can no longer occur.",
      "ja": "ある種のサーバーコールバックをもたらす可能性がある各クライアント操作に対して、Slot IDの退除規則がサーバーがクライアントが決定できるようになるまで、クライアント要求の{セッションID、スロットID、シーケンスID}トリプルを「覚えておく」必要があります。実際には、サーバーの返信を見ました。{セッションID、スロットID、シーケンスID}リクエストトリプルを引退することができるまでに、関連付けられているオブジェクトのリコールは、クライアントの利点について、これらの参照識別子の配列を（CB_Sequence操作の引数）の配列を持たなければなりません。この時間の後、サーバーはレースの状態が発生しなくなることが確実であることが確実であるため、この情報を関連するコールバックに提供する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The CB_SEQUENCE operation that begins each server callback carries a list of \"referring\" { session ID, slot ID, sequence ID } triples. If the client finds the request corresponding to the referring session ID, slot ID, and sequence ID to be currently outstanding (i.e., the server's reply has not been seen by the client), it can determine that the callback has raced the reply, and act accordingly. If the client does not find the request corresponding to the referring triple to be outstanding (including the case of a session ID referring to a destroyed session), then there is no race with respect to this triple. The server SHOULD limit the referring triples to requests that refer to just those that apply to the objects referred to in the CB_COMPOUND procedure.",
      "ja": "各サーバーコールバックを開始するCB_Sequenceオペレーションは、「参照」{セッションID、スロットID、シーケンスID}トリプルのリストを搬送します。クライアントが現在未解決の参照のセッションID、スロットID、およびシーケンスIDに対応する要求を見つけた場合（すなわち、サーバの応答はクライアントによって見られていません）、コールバックが返信を怠ったと判断できます。それに応じて行動します。クライアントが抜群に対応する要求が未解決に対応する要求が見つからない場合（破棄されたセッションを参照してセッションIDの場合を含む）、このトリプルに関してレースはありません。サーバーは、CB_COMPOUNDプロシージャで参照されるオブジェクトに適用されるものだけを参照する要求を参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client must not simply wait forever for the expected server reply to arrive before responding to the CB_COMPOUND that won the race, because it is possible that it will be delayed indefinitely. The client should assume the likely case that the reply will arrive within the average round-trip time for COMPOUND requests to the server, and wait that period of time. If that period of time expires, it can respond to the CB_COMPOUND with NFS4ERR_DELAY. There are other scenarios under which callbacks may race replies. Among them are pNFS layout recalls as described in Section 12.5.5.2.",
      "ja": "クライアントは、レースを獲得したCB_COMPOUNDに応答する前に、予想されるサーバーの応答が永遠に到着してはいけません。クライアントは、応答がサーバーへの複合要求の平均往復時間内に到着し、その期間を待つという可能性が高いと仮定する必要があります。その期間が期限切れになると、NFS4ERR_DELAYを使用してCB_COMPOUNDに応答できます。コールバックが答えを競技することがある他のシナリオもあります。その中には、PNFSレイアウトがセクション12.5.5.2で説明されているようにリコールされています。"
    },
    {
      "indent": 0,
      "text": "2.10.6.4. COMPOUND and CB_COMPOUND Construction Issues",
      "section_title": true,
      "ja": "2.10.6.4. 化合物とCB_COMPOUND構造の問題"
    },
    {
      "indent": 3,
      "text": "Very large requests and replies may pose both buffer management issues (especially with RDMA) and reply cache issues. When the session is created (Section 18.36), for each channel (fore and back), the client and server negotiate the maximum-sized request they will send or process (ca_maxrequestsize), the maximum-sized reply they will return or process (ca_maxresponsesize), and the maximum-sized reply they will store in the reply cache (ca_maxresponsesize_cached).",
      "ja": "非常に大きな要求と返信は、バッファ管理の問題（特にRDMAとの間で）と応答キャッシュの問題の両方をもたらす可能性があります。セッションが作成されたら（セクション18.36）、各チャンネル（前後）に対して、クライアントとサーバーは、送信または処理（CA_MAXRequestSize）（CA_MAXREQUESTSIZE）、返却または処理が行われる（CA_MAXResponsize）。）、および最大サイズの返信は、応答キャッシュ（CA_MAXResponseSize_Cached）に格納します。"
    },
    {
      "indent": 3,
      "text": "If a request exceeds ca_maxrequestsize, the reply will have the status NFS4ERR_REQ_TOO_BIG. A replier MAY return NFS4ERR_REQ_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request (which means that no operations in the request executed and that the state of the slot in the reply cache is unchanged), or it MAY opt to return it on a subsequent operation in the same COMPOUND or CB_COMPOUND request (which means that at least one operation did execute and that the state of the slot in the reply cache does change). The replier SHOULD set NFS4ERR_REQ_TOO_BIG on the operation that exceeds ca_maxrequestsize.",
      "ja": "要求がCA_MAXRequestSizeを超える場合、応答はステータスNFS4ERR_REQ_TOO_BIGを持ちます。リセプタは、要求内の最初の操作（シーケンスまたはCB_Sequence）のステータスとしてNFS4ERR_REQ_TOO_BIGを返すことができます（これは、要求に実行されず、返信キャッシュ内のスロットの状態が変わらないことを意味します）、またはオプトしてもよい。同じ化合物またはCB_COMPOUND要求で後続の操作でそれを返します（これは、少なくとも1つの操作が実行されたこと、および返信キャッシュ内のスロットの状態が変更されたことを意味します）。Replierは、CA_MAXRequestSizeを超える操作にNFS4ERR_REQ_TOO_BIGを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a reply exceeds ca_maxresponsesize, the reply will have the status NFS4ERR_REP_TOO_BIG. A replier MAY return NFS4ERR_REP_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request, or it MAY opt to return it on a subsequent operation (in the same COMPOUND or CB_COMPOUND reply). A replier MAY return NFS4ERR_REP_TOO_BIG in the reply to SEQUENCE or CB_SEQUENCE, even if the response would still exceed ca_maxresponsesize.",
      "ja": "返信がCA_MAXResponseSizeを超えると、応答はステータスNFS4ERR_REP_TOO_BIGを持ちます。Replierは、要求内の最初の操作（シーケンスまたはCB_Sequence）のステータスとしてNFS4ERR_REP_TOO_BIGを返すか、またはそれを後続の操作（同じ化合物またはCB_COMPOUND REPLANDで）返すことを選択できます。応答が依然としてCA_MAXResponseSizeを超えていても、Replierが応答内のnfs4err_rep_too_bigをsequenceまたはcb_sequenceに返すことができます。"
    },
    {
      "indent": 3,
      "text": "If sa_cachethis or csa_cachethis is TRUE, then the replier MUST cache a reply except if an error is returned by the SEQUENCE or CB_SEQUENCE operation (see Section 2.10.6.1.2). If the reply exceeds ca_maxresponsesize_cached (and sa_cachethis or csa_cachethis is TRUE), then the server MUST return NFS4ERR_REP_TOO_BIG_TO_CACHE. Even if NFS4ERR_REP_TOO_BIG_TO_CACHE (or any other error for that matter) is returned on an operation other than the first operation (SEQUENCE or CB_SEQUENCE), then the reply MUST be cached if sa_cachethis or csa_cachethis is TRUE. For example, if a COMPOUND has eleven operations, including SEQUENCE, the fifth operation is a RENAME, and the tenth operation is a READ for one million bytes, the server may return NFS4ERR_REP_TOO_BIG_TO_CACHE on the tenth operation. Since the server executed several operations, especially the non-idempotent RENAME, the client's request to cache the reply needs to be honored in order for the correct operation of exactly once semantics. If the client retries the request, the server will have cached a reply that contains results for ten of the eleven requested operations, with the tenth operation having a status of NFS4ERR_REP_TOO_BIG_TO_CACHE.",
      "ja": "SA_CACHETHISまたはCSA_CACHETHISがtrueの場合、レプリアはシーケンスまたはCB_Sequence操作によってエラーが返される場合を除き、応答をキャッシュする必要があります（セクション2.10.6.1.2を参照）。返信がCA_MAXResponseSize_cached（およびSA_CachethisまたはCSA_Cachethisがtrue）を超えると、サーバーはNFS4ERR_REP_TOO_BIG_TO_TO_CACHEを返す必要があります。 NFS4ERR_REP_TOO_BIG_TO_CACHE（またはその重要なエラー）が最初の操作（シーケンスまたはCB_Sequence）以外の操作で返された場合でも、SA_CACHETHISまたはCSA_CACHETHISがTRUEの場合、返信をキャッシュする必要があります。たとえば、シーケンスを含めて、化合物が11の操作を持つ場合、5番目の操作は名前の変更であり、10回目の操作は100万バイトの読み取りです。サーバーは、サーバーは10回目の動作でNFS4R_REP_TOO_BIG_TO_CACHEを返すことがあります。サーバーはいくつかの操作、特にIDEMPOTENT NONAMEを実行したため、クライアントの返信をキャッシュする要求は、一度正確に正確に操作するために称わられる必要があります。クライアントが要求を再試行した場合、サーバーは11の要求された操作のうちの10の結果を含む応答をキャッシュしており、10番目の操作はNFS4ERR_REP_TOO_BIG_TO_TO_CACHEのステータスを持ちます。"
    },
    {
      "indent": 3,
      "text": "A client needs to take care that, when sending operations that change the current filehandle (except for PUTFH, PUTPUBFH, PUTROOTFH, and RESTOREFH), it does not exceed the maximum reply buffer before the GETFH operation. Otherwise, the client will have to retry the operation that changed the current filehandle, in order to obtain the desired filehandle. For the OPEN operation (see Section 18.16), retry is not always available as an option. The following guidelines for the handling of filehandle-changing operations are advised:",
      "ja": "クライアントは、現在のファイルハンドルを変更する操作を送信するとき（PUTFH、PUTPUBF、PUTROOTFH、およびRESTOREFHを除く）、GETFH操作の前に最大応答バッファを超えません。それ以外の場合、クライアントは、目的のファイルハンドルを取得するために、現在のファイルハンドルを変更した操作を再試行する必要があります。オープン操作の場合（18.16節を参照）、再試行は必ずしもオプションとして使用できません。ファイルハンドル変更操作の処理に関する次のガイドラインを参照してください。"
    },
    {
      "indent": 3,
      "text": "* Within the same COMPOUND procedure, a client SHOULD send GETFH immediately after a current filehandle-changing operation. A client MUST send GETFH after a current filehandle-changing operation that is also non-idempotent (e.g., the OPEN operation), unless the operation is RESTOREFH. RESTOREFH is an exception, because even though it is non-idempotent, the filehandle RESTOREFH produced originated from an operation that is either idempotent (e.g., PUTFH, LOOKUP), or non-idempotent (e.g., OPEN, CREATE). If the origin is non-idempotent, then because the client MUST send GETFH after the origin operation, the client can recover if RESTOREFH returns an error.",
      "ja": "* 同じ複合手順で、クライアントは現在のファイルハンドル変更操作の直後にGETFHを送信する必要があります。操作が復元されない限り、現在のファイルハンドル変更操作の後に、クライアントはGETFHを送信する必要があります（例えば、オープン操作）。RestoreFhは例外です。原点がIDEMPOTENTである場合、クライアントはOrigin操作の後にGETFHを送信する必要があるため、RESTOREFHがエラーを返す場合、クライアントは回復できます。"
    },
    {
      "indent": 3,
      "text": "* A server MAY return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing operation if the reply would be too large on the next operation.",
      "ja": "* 次の操作でリ応答が大きすぎる場合、サーバーはNFS4ERR_REP_TOO_BIGまたはNFS4ERR_REP_TOO_BIG_TO_TO_CACHE（SA_CACHETHISがTRUEの場合）を返します（SA_CACHETHISがTRUEの場合）。"
    },
    {
      "indent": 3,
      "text": "* A server SHOULD return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing, non-idempotent operation if the reply would be too large on the next operation, especially if the operation is OPEN.",
      "ja": "* サーバーは、FileHandle-Changitedの場合、特に操作が開いている場合は、次の操作でリ応答が大きすぎる場合は、ファイルハンドル変更では、IDEMPOTENTのない操作で、サーバーがNFS4ERR_REP_TOO_BIGまたはNFS4ERR_REP_TOO_BIG_TO_CACHE（SA_CACHETHISがTRUE）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* A server MAY return NFS4ERR_UNSAFE_COMPOUND to a non-idempotent current filehandle-changing operation, if it looks at the next operation (in the same COMPOUND procedure) and finds it is not GETFH. The server SHOULD do this if it is unable to determine in advance whether the total response size would exceed ca_maxresponsesize_cached or ca_maxresponsesize.",
      "ja": "* サーバーは、次の操作（同じ複合手順で）調べてGETFHではないと検索されている場合、NFS4ERR_UNSAFE_COMPOUNDを非IDEmPOTENT現在のファイルハンドル変更操作に戻すことができます。合計応答サイズがCA_MAXResponseSize_CachedまたはCA_MAXResponseSizeを超えるかどうかを事前に決定できない場合、サーバーはこれを行うべきです。"
    },
    {
      "indent": 0,
      "text": "2.10.6.5. Persistence",
      "section_title": true,
      "ja": "2.10.6.5. 永続的な"
    },
    {
      "indent": 3,
      "text": "Since the reply cache is bounded, it is practical for the reply cache to persist across server restarts. The replier MUST persist the following information if it agreed to persist the session (when the session was created; see Section 18.36):",
      "ja": "応答キャッシュは境界が付けられているので、応答キャッシュがサーバーの再起動を継続して持続するのが実用的です。セッションを永続化することに合意した場合（セッションが作成されたときに; 18.36を参照）。"
    },
    {
      "indent": 3,
      "text": "* The session ID.",
      "ja": "* セッションID。"
    },
    {
      "indent": 3,
      "text": "* The slot table including the sequence ID and cached reply for each slot.",
      "ja": "* 各スロットのシーケンスIDとキャッシュされた応答を含むスロットテーブル。"
    },
    {
      "indent": 3,
      "text": "The above are sufficient for a replier to provide EOS semantics for any requests that were sent and executed before the server restarted. If the replier is a client, then there is no need for it to persist any more information, unless the client will be persisting all other state across client restart, in which case, the server will never see any NFSv4.1-level protocol manifestation of a client restart. If the replier is a server, with just the slot table and session ID persisting, any requests the client retries after the server restart will return the results that are cached in the reply cache, and any new requests (i.e., the sequence ID is one greater than the slot's sequence ID) MUST be rejected with NFS4ERR_DEADSESSION (returned by SEQUENCE). Such a session is considered dead. A server MAY re-animate a session after a server restart so that the session will accept new requests as well as retries. To re-animate a session, the server needs to persist additional information through server restart:",
      "ja": "上記では、サーバーが再起動される前に送信および実行された要求に対して、ReplierがEOSセマンティクスを提供するのに十分です。レプリアがクライアントである場合は、クライアントがクライアントの再起動にわたって他のすべての状態を永続化しない限り、その他の情報を永続化する必要はありません。その場合、サーバーはNFSV4.1レベルのプロトコル表示を表示しません。クライアントの再起動スロットテーブルとセッションIDだけを持つサーバーがサーバーである場合、サーバーの再起動後にクライアントが再試行してもクライアントが再試行し、新しい要求（つまり、シーケンスIDは1つです）を返します。スロットのシーケンスIDより大きい場合は、NFS4ERR_DEADSession（シーケンス別に返されます）で拒否する必要があります。そのようなセッションは死んだと見なされます。サーバーが再起動した後にサーバーがセッションを再アニメート化することで、セッションは再試行だけでなく新しい要求を受け入れます。セッションを再アニメートするためには、サーバーはサーバーの再起動を通じて追加情報を永続化する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The client ID. This is a prerequisite to let the client create more sessions associated with the same client ID as the re-animated session.",
      "ja": "* クライアントID。これは、クライアントに再アニメーションセッションと同じクライアントIDに関連付けられているより多くのセッションを作成させるための前提条件です。"
    },
    {
      "indent": 3,
      "text": "* The client ID's sequence ID that is used for creating sessions (see Sections 18.35 and 18.36). This is a prerequisite to let the client create more sessions.",
      "ja": "* セッションの作成に使用されるクライアントIDのシーケンスID（セクション18.35および18.36を参照）。これは、クライアントにより多くのセッションを作成させるための前提条件です。"
    },
    {
      "indent": 3,
      "text": "* The principal that created the client ID. This allows the server to authenticate the client when it sends EXCHANGE_ID.",
      "ja": "* クライアントIDを作成した主体。これにより、Exchange_IDを送信するとサーバーはクライアントを認証できます。"
    },
    {
      "indent": 3,
      "text": "* The SSV, if SP4_SSV state protection was specified when the client ID was created (see Section 18.35). This lets the client create new sessions, and associate connections with the new and existing sessions.",
      "ja": "* SP4_SSV状態保護がクライアントIDが作成されたときに指定されている場合は、SSV（セクション18.35を参照）。これにより、クライアントは新しいセッションを作成し、新しいセッションと既存のセッションとの接続を関連付けます。"
    },
    {
      "indent": 3,
      "text": "* The properties of the client ID as defined in Section 18.35.",
      "ja": "* セクション18.35で定義されているクライアントIDのプロパティ。"
    },
    {
      "indent": 3,
      "text": "A persistent reply cache places certain demands on the server. The execution of the sequence of operations (starting with SEQUENCE) and placement of its results in the persistent cache MUST be atomic. If a client retries a sequence of operations that was previously executed on the server, the only acceptable outcomes are either the original cached reply or an indication that the client ID or session has been lost (indicating a catastrophic loss of the reply cache or a session that has been deleted because the client failed to use the session for an extended period of time).",
      "ja": "永続的な返信キャッシュは、サーバーに特定の要求を配置します。永続的なキャッシュ内の一連の動作の実行とその結果の配置はアトミックでなければなりません。クライアントが以前にサーバー上で実行された一連の操作を再試行した場合、唯一の許容可能な結果は、元のキャッシュされた返信またはクライアントIDまたはセッションが失われたことを示しています（返信キャッシュまたはセッションの致命的な損失を示す）。クライアントが長期間にわたってセッションを使用できなかったために削除されました。"
    },
    {
      "indent": 3,
      "text": "A server could fail and restart in the middle of a COMPOUND procedure that contains one or more non-idempotent or idempotent-but-modifying operations. This creates an even higher challenge for atomic execution and placement of results in the reply cache. One way to view the problem is as a single transaction consisting of each operation in the COMPOUND followed by storing the result in persistent storage, then finally a transaction commit. If there is a failure before the transaction is committed, then the server rolls back the transaction. If the server itself fails, then when it restarts, its recovery logic could roll back the transaction before starting the NFSv4.1 server.",
      "ja": "サーバーは、1つ以上のIDEMPOTENTまたはIDEMPOTENT-BUT修正操作を含む複合プロシージャの途中で失敗して再起動することができます。これにより、アトミック実行と応答キャッシュ内の結果の配置にさらに高いチャレンジが発生します。問題を表示する1つの方法は、コンパウンド内の各操作からなる単一のトランザクションとそれに続く結果を永続的なストレージに格納し、最後にトランザクションのコミットを実行します。トランザクションがコミットされる前に障害がある場合、サーバーはトランザクションをロールバックします。サーバー自体が失敗した場合、再起動時には、NFSV4.1サーバーを起動する前にその回復ロジックはトランザクションをロールバックする可能性があります。"
    },
    {
      "indent": 3,
      "text": "While the description of the implementation for atomic execution of the request and caching of the reply is beyond the scope of this document, an example implementation for NFSv2 [45] is described in [46].",
      "ja": "要求の原子的実行のための実装と応答のキャッシングの実装の説明はこの文書の範囲を超えていますが、NFSV2 [45]の実装例を[46]に説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.7. RDMA Considerations",
      "section_title": true,
      "ja": "2.10.7. RDMAの考慮事項"
    },
    {
      "indent": 3,
      "text": "A complete discussion of the operation of RPC-based protocols over RDMA transports is in [32]. A discussion of the operation of NFSv4, including NFSv4.1, over RDMA is in [33]. Where RDMA is considered, this specification assumes the use of such a layering; it addresses only the upper-layer issues relevant to making best use of RPC/RDMA.",
      "ja": "RDMAトランスポートを介したRPCベースのプロトコルの動作についての完全な説明は[32]にあります。NFSV4.1を含むNFSV4の操作についての議論は[33]にあります。RDMAが考慮される場合、この仕様はそのような階層化の使用を想定しています。RPC / RDMAを最大限に活用するには関連する上位層の問題だけです。"
    },
    {
      "indent": 0,
      "text": "2.10.7.1. RDMA Connection Resources",
      "section_title": true,
      "ja": "2.10.7.1. RDMA接続リソース"
    },
    {
      "indent": 3,
      "text": "RDMA requires its consumers to register memory and post buffers of a specific size and number for receive operations.",
      "ja": "RDMAは、その消費者に、受信操作のために特定のサイズと数のメモリとポストバッファを登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "Registration of memory can be a relatively high-overhead operation, since it requires pinning of buffers, assignment of attributes (e.g., readable/writable), and initialization of hardware translation. Preregistration is desirable to reduce overhead. These registrations are specific to hardware interfaces and even to RDMA connection endpoints; therefore, negotiation of their limits is desirable to manage resources effectively.",
      "ja": "メモリの登録は、バッファの固定、属性の割り当て（例えば、読み取り可能/書き込み可能）、およびハードウェア変換の初期化を必要とするので、比較的高いオーバーヘッド操作であり得る。前登録はオーバーヘッドを減らすために望ましいです。これらの登録は、ハードウェアインターフェイス、さらにはRDMA接続エンドポイントに固有のものです。したがって、それらの限界の交渉は、資源を効果的に管理することが望ましい。"
    },
    {
      "indent": 3,
      "text": "Following basic registration, these buffers must be posted by the RPC layer to handle receives. These buffers remain in use by the RPC/ NFSv4.1 implementation; the size and number of them must be known to the remote peer in order to avoid RDMA errors that would cause a fatal error on the RDMA connection.",
      "ja": "基本登録後、これらのバッファは受信を処理するためにRPCレイヤによって転記されなければなりません。これらのバッファは、RPC / NFSV4.1実装によって使用されています。RDMA接続で致命的なエラーを引き起こす可能性があるRDMAエラーを回避するために、それらのサイズと数はリモートピアに知られている必要があります。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 manages slots as resources on a per-session basis (see Section 2.10), while RDMA connections manage credits on a per-connection basis. This means that in order for a peer to send data over RDMA to a remote buffer, it has to have both an NFSv4.1 slot and an RDMA credit. If multiple RDMA connections are associated with a session, then if the total number of credits across all RDMA connections associated with the session is X, and the number of slots in the session is Y, then the maximum number of outstanding requests is the lesser of X and Y.",
      "ja": "NFSV4.1は、セッションごとにリソースとしてスロットを管理します（セクション2.10を参照）、RDMA接続は接続ごとにクレジットを管理します。つまり、ピアがRDMAを介してリモートバッファにデータを送信するためには、NFSV4.1スロットとRDMAクレジットの両方を持つ必要があります。複数のRDMA接続がセッションに関連付けられている場合、セッションに関連付けられているすべてのRDMA接続にわたるクレジットの総数がXの場合、セッション内のスロット数がYの場合は、最低限の要求の数が少なくなります。xとy。"
    },
    {
      "indent": 0,
      "text": "2.10.7.2. Flow Control",
      "section_title": true,
      "ja": "2.10.7.2. フロー制御"
    },
    {
      "indent": 3,
      "text": "Previous versions of NFS do not provide flow control; instead, they rely on the windowing provided by transports like TCP to throttle requests. This does not work with RDMA, which provides no operation flow control and will terminate a connection in error when limits are exceeded. Limits such as maximum number of requests outstanding are therefore negotiated when a session is created (see the ca_maxrequests field in Section 18.36). These limits then provide the maxima within which each connection associated with the session's channel(s) must remain. RDMA connections are managed within these limits as described in Section 3.3 of [32]; if there are multiple RDMA connections, then the maximum number of requests for a channel will be divided among the RDMA connections. Put a different way, the onus is on the replier to ensure that the total number of RDMA credits across all connections associated with the replier's channel does exceed the channel's maximum number of outstanding requests.",
      "ja": "以前のバージョンのNFSはフロー制御を提供していません。代わりに、彼らはTCPのような輸送によって提供されたウィンドウをスロットル要求に依存しています。これはRDMAでは動作しません。これは、操作フロー制御を提供し、制限が超過したときにエラー内の接続を終了します。したがって、未解決の要求の最大要求数などの制限は、セッションが作成されたときにネゴシエートされます（セクション18.36のCA_MAXRequestsフィールドを参照）。これらの制限は、セッションのチャネルに関連付けられている各接続が残る必要がある最大値を提供します。[32]のセクション3.3で説明されているように、RDMA接続はこれらの制限内で管理されています。複数のRDMA接続がある場合、チャネルの最大要求数はRDMA接続に分割されます。別の方法を置くと、onusはレプリアのチャネルに関連付けられているすべての接続にわたるRDMAクレジットの総数がチャネルの最大数の要求数を超えていることを確認するために、replier上にあります。"
    },
    {
      "indent": 3,
      "text": "The limits may also be modified dynamically at the replier's choosing by manipulating certain parameters present in each NFSv4.1 reply. In addition, the CB_RECALL_SLOT callback operation (see Section 20.8) can be sent by a server to a client to return RDMA credits to the server, thereby lowering the maximum number of requests a client can have outstanding to the server.",
      "ja": "各NFSV4.1応答に存在する特定のパラメータを操作することによって、リプライアの選択では、限界を動的に変更することもできます。さらに、CB_RECALL_SLOTコールバック操作（セクション20.8を参照）をサーバーに送信して、RDMAクレジットをサーバーに戻すためにクライアントに送信でき、それによってクライアントがサーバーに優れている要求の最大要求数を下げることができます。"
    },
    {
      "indent": 0,
      "text": "2.10.7.3. Padding",
      "section_title": true,
      "ja": "2.10.7.3. パディング"
    },
    {
      "indent": 3,
      "text": "Header padding is requested by each peer at session initiation (see the ca_headerpadsize argument to CREATE_SESSION in Section 18.36), and subsequently used by the RPC RDMA layer, as described in [32]. Zero padding is permitted.",
      "ja": "ヘッダーパディングは、セッション開始時に各ピアによって要求されます（セクション18.36のCATE_SESSERT_SESSIONの引数を参照）、[32]の説明に従って、RPC RDMAレイヤによって使用されます。ゼロパディングが許可されています。"
    },
    {
      "indent": 3,
      "text": "Padding leverages the useful property that RDMA preserve alignment of data, even when they are placed into anonymous (untagged) buffers. If requested, client inline writes will insert appropriate pad bytes within the request header to align the data payload on the specified boundary. The client is encouraged to add sufficient padding (up to the negotiated size) so that the \"data\" field of the WRITE operation is aligned. Most servers can make good use of such padding, which allows them to chain receive buffers in such a way that any data carried by client requests will be placed into appropriate buffers at the server, ready for file system processing. The receiver's RPC layer encounters no overhead from skipping over pad bytes, and the RDMA layer's high performance makes the insertion and transmission of padding on the sender a significant optimization. In this way, the need for servers to perform RDMA Read to satisfy all but the largest client writes is obviated. An added benefit is the reduction of message round trips on the network -- a potentially good trade, where latency is present.",
      "ja": "パディングは、RDMAがデータのアライメントを保存する有用なプロパティを活用します。要求された場合、クライアントのインライン書き込みは要求ヘッダー内に適切なパッドバイトを挿入して、指定された境界上のデータペイロードを揃えます。クライアントは、書き込み操作の「データ」フィールドが整列されるように十分なパディング（ネゴシエートされたサイズまで）を追加することが奨励されます。ほとんどのサーバーはそのようなパディングをよく使用できます。受信機のRPCレイヤーはパッドバイトをスキップすることからオーバーヘッドを遭遇しないため、RDMAレイヤーの高性能は、送信者にとってパディングの挿入と伝送を大切に最適化します。このようにして、サーバが最大のクライアント書き込みを満たすためにRDMAを読み取る必要性が排除される。追加された利点は、ネットワーク上のメッセージ往復の削減です - 待ち時間が存在する潜在的に良い貿易。"
    },
    {
      "indent": 3,
      "text": "The value to choose for padding is subject to a number of criteria. A primary source of variable-length data in the RPC header is the authentication information, the form of which is client-determined, possibly in response to server specification. The contents of COMPOUNDs, sizes of strings such as those passed to RENAME, etc. all go into the determination of a maximal NFSv4.1 request size and therefore minimal buffer size. The client must select its offered value carefully, so as to avoid overburdening the server, and vice versa. The benefit of an appropriate padding value is higher performance.",
      "ja": "パディングに選択する値は、いくつかの基準の対象となります。RPCヘッダ内の可変長データの主なソースは認証情報であり、その形式は、おそらくサーバー仕様に応答してクライアントが決定されます。化合物の内容、名前変更されたものなどの文字列のサイズなどはすべて、最大NFSV4.1要求サイズ、したがって最小限のバッファサイズの決定に入ります。クライアントは、サーバーの過負荷を避けるために、提供された値を慎重に選択する必要があります。適切なパディング値の利点は高性能です。"
    },
    {
      "indent": 8,
      "text": "            Sender gather:\n|RPC Request|Pad  bytes|Length| -> |User data...|\n\\------+----------------------/      \\\n        \\                             \\\n         \\    Receiver scatter:        \\-----------+- ...\n    /-----+----------------\\            \\           \\\n    |RPC Request|Pad|Length|   ->  |FS buffer|->|FS buffer|->...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the above case, the server may recycle unused buffers to the next posted receive if unused by the actual received request, or may pass the now-complete buffers by reference for normal write processing. For a server that can make use of it, this removes any need for data copies of incoming data, without resorting to complicated end-to-end buffer advertisement and management. This includes most kernel-based and integrated server designs, among many others. The client may perform similar optimizations, if desired.",
      "ja": "上記の場合、サーバは、実際の受信要求によって未使用で未使用のバッファを次の投稿受信にリサイクルすることも、通常の書き込み処理のために参照により現在完全なバッファを渡すことができる。それを利用できるサーバーの場合、複雑なエンドツーエンドバッファー広告と管理に頼ることなく、着信データのデータコピーの必要性を削除します。これには、ほとんどのカーネルベースの設計と統合されたサーバーの設計が含まれています。必要に応じて、クライアントは同様の最適化を実行することができる。"
    },
    {
      "indent": 0,
      "text": "2.10.7.4. Dual RDMA and Non-RDMA Transports",
      "section_title": true,
      "ja": "2.10.7.4. デュアルRDMAと非RDMAトランスポート"
    },
    {
      "indent": 3,
      "text": "Some RDMA transports (e.g., RFC 5040 [8]) permit a \"streaming\" (non-RDMA) phase, where ordinary traffic might flow before \"stepping up\" to RDMA mode, commencing RDMA traffic. Some RDMA transports start connections always in RDMA mode. NFSv4.1 allows, but does not assume, a streaming phase before RDMA mode. When a connection is associated with a session, the client and server negotiate whether the connection is used in RDMA or non-RDMA mode (see Sections 18.36 and 18.34).",
      "ja": "いくつかのRDMAトランスポート（例えば、RFC 5040 [8]）は、RDMAトラフィックを開始する「ストリーミング」（RDMA）フェーズを「ストリーミング」（非RDMA）フェーズを許可します。一部のRDMAは常にRDMAモードで接続を開始します。NFSV4.1はRDMAモードの前のストリーミングフェーズを使用することを許可します。接続がセッションに関連付けられている場合、クライアントとサーバーは、接続がRDMAまたは非RDMAモードで使用されているかどうかをネゴシエートします（セクション18.36と18.34を参照）。"
    },
    {
      "indent": 0,
      "text": "2.10.8. Session Security",
      "section_title": true,
      "ja": "2.10.8. セッションセキュリティ"
    },
    {
      "indent": 0,
      "text": "2.10.8.1. Session Callback Security",
      "section_title": true,
      "ja": "2.10.8.1. セッションコールバックセキュリティ"
    },
    {
      "indent": 3,
      "text": "Via session/connection association, NFSv4.1 improves security over that provided by NFSv4.0 for the backchannel. The connection is client-initiated (see Section 18.34) and subject to the same firewall and routing checks as the fore channel. At the client's option (see Section 18.35), connection association is fully authenticated before being activated (see Section 18.34). Traffic from the server over the backchannel is authenticated exactly as the client specifies (see Section 2.10.8.2).",
      "ja": "Session / Connection Associationを介して、NFSV4.1はBackChannelに対してNFSv4.0が提供するセキュリティを向上させます。接続はクライアントが開始され（セクション18.34を参照）、前のチャネルとして同じファイアウォールとルーティングチェックを受けます。クライアントのオプション（セクション18.35を参照）で、接続アソシエーションはアクティブになる前に完全に認証されています（18.34節を参照）。BackChannelを介したサーバーからのトラフィックは、クライアントが指定されているとおりに認証されます（セクション2.10.8.2を参照）。"
    },
    {
      "indent": 0,
      "text": "2.10.8.2. Backchannel RPC Security",
      "section_title": true,
      "ja": "2.10.8.2. BackChannel RPCセキュリティ"
    },
    {
      "indent": 3,
      "text": "When the NFSv4.1 client establishes the backchannel, it informs the server of the security flavors and principals to use when sending requests. If the security flavor is RPCSEC_GSS, the client expresses the principal in the form of an established RPCSEC_GSS context. The server is free to use any of the flavor/principal combinations the client offers, but it MUST NOT use unoffered combinations. This way, the client need not provide a target GSS principal for the backchannel as it did with NFSv4.0, nor does the server have to implement an RPCSEC_GSS initiator as it did with NFSv4.0 [37].",
      "ja": "NFSV4.1クライアントがBackChannelを確立すると、リクエストの送信時に使用するセキュリティフレーバーとプリンシパルのサーバーに通知します。セキュリティフレーバーがRPCSEC_GSSの場合、クライアントは確立されたRPCSEC_GSSコンテキストの形式でプリンシパルを表します。サーバーはクライアントのオファーのいずれかのフレーバー/プリンシパルの組み合わせを自由に使用できますが、未払いの組み合わせを使用しないでください。このようにして、クライアントはNFSv4.0と同じようにBackChannelのターゲットGSSプリンシパルを提供する必要もなく、NFSv4.0 [37]と同じようにサーバはRPCSEC_GSSイニシエータを実装する必要もありません[37]。"
    },
    {
      "indent": 3,
      "text": "The CREATE_SESSION (Section 18.36) and BACKCHANNEL_CTL (Section 18.33) operations allow the client to specify flavor/ principal combinations.",
      "ja": "create_session（セクション18.36）およびbackchannel_ctl（セクション18.33）操作により、クライアントはフレーバー/プリンシパルの組み合わせを指定できます。"
    },
    {
      "indent": 3,
      "text": "Also note that the SP4_SSV state protection mode (see Sections 18.35 and 2.10.8.3) has the side benefit of providing SSV-derived RPCSEC_GSS contexts (Section 2.10.9).",
      "ja": "また、SP4_SSV状態保護モード（セクション18.35および2.10.8.3を参照）は、SSV派生RPCSEC_GSSコンテキストを提供することのサイドの利点を有する（2.10.9項）。"
    },
    {
      "indent": 0,
      "text": "2.10.8.3. Protection from Unauthorized State Changes",
      "section_title": true,
      "ja": "2.10.8.3. 不正状態の変更からの保護"
    },
    {
      "indent": 3,
      "text": "As described to this point in the specification, the state model of NFSv4.1 is vulnerable to an attacker that sends a SEQUENCE operation with a forged session ID and with a slot ID that it expects the legitimate client to use next. When the legitimate client uses the slot ID with the same sequence number, the server returns the attacker's result from the reply cache, which disrupts the legitimate client and thus denies service to it. Similarly, an attacker could send a CREATE_SESSION with a forged client ID to create a new session associated with the client ID. The attacker could send requests using the new session that change locking state, such as LOCKU operations to release locks the legitimate client has acquired. Setting a security policy on the file that requires RPCSEC_GSS credentials when manipulating the file's state is one potential work around, but has the disadvantage of preventing a legitimate client from releasing state when RPCSEC_GSS is required to do so, but a GSS context cannot be obtained (possibly because the user has logged off the client).",
      "ja": "本明細書のこの点について説明したように、NFSV4.1の状態モデルは、鍛造セッションIDと、Regitimeimeクライアントが次に使用することを期待するスロットIDを持つシーケンス操作を送信する攻撃者に対して脆弱です。合法的なクライアントが同じシーケンス番号を持つスロットIDを使用すると、サーバーは応答キャッシュからの攻撃者の結果を返します。これにより正当なクライアントが混乱し、したがってサービスを拒否します。同様に、攻撃者は、クライアントIDに関連付けられている新しいセッションを作成するために、攻撃者が偽造クライアントIDを登録することができます。攻撃者は、Resku Operations Locks Locks Locks Resking Locksを取得した場合の新しいセッションを使用してリクエストを送信できます。ファイルの状態を操作するときにRPCSEC_GSS認証情報を必要とするファイルのセキュリティポリシーを設定することは、RPCSEC_GSSが必要なときに正当なクライアントの解放を防ぐという欠点がありますが、GSSコンテキストは取得できません（ユーザーがクライアントからログオフしたからです。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides three options to a client for state protection, which are specified when a client creates a client ID via EXCHANGE_ID (Section 18.35).",
      "ja": "NFSV4.1は、クライアントがExchange_IDを介してクライアントIDを作成したときに指定されている状態保護のためのクライアントに3つのオプションを提供します（セクション18.35）。"
    },
    {
      "indent": 3,
      "text": "The first (SP4_NONE) is to simply waive state protection.",
      "ja": "最初の（SP4_NONE）は、単に状態保護を放棄することです。"
    },
    {
      "indent": 3,
      "text": "The other two options (SP4_MACH_CRED and SP4_SSV) share several traits:",
      "ja": "他の2つのオプション（SP4_MACH_CREDおよびSP4_SSV）はいくつかの特性を共有しています。"
    },
    {
      "indent": 3,
      "text": "* An RPCSEC_GSS-based credential is used to authenticate client ID and session maintenance operations, including creating and destroying a session, associating a connection with the session, and destroying the client ID.",
      "ja": "* rpcsec_gssベースの信任状は、セッションの作成と破棄、セッションとの接続を関連付け、クライアントIDを破棄するなど、クライアントIDとセッションのメンテナンス操作を認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "* Because RPCSEC_GSS is used to authenticate client ID and session maintenance, the attacker cannot associate a rogue connection with a legitimate session, or associate a rogue session with a legitimate client ID in order to maliciously alter the client ID's lock state via CLOSE, LOCKU, DELEGRETURN, LAYOUTRETURN, etc.",
      "ja": "* RPCSEC_GSSはクライアントIDとセッションのメンテナンスを認証するために使用されているため、攻撃者は正当なセッションとの不正なセッションを関連付けることも、クライアントIDのロック状態を閉鎖、Locku、DelegReturnで故意に変更するために正当なクライアントIDとの不正なセッションを関連付けることもできません。、LayoutReturnなど"
    },
    {
      "indent": 3,
      "text": "* In cases where the server's security policies on a portion of its namespace require RPCSEC_GSS authentication, a client may have to use an RPCSEC_GSS credential to remove per-file state (e.g., LOCKU, CLOSE, etc.). The server may require that the principal that removes the state match certain criteria (e.g., the principal might have to be the same as the one that acquired the state). However, the client might not have an RPCSEC_GSS context for such a principal, and might not be able to create such a context (perhaps because the user has logged off). When the client establishes SP4_MACH_CRED or SP4_SSV protection, it can specify a list of operations that the server MUST allow using the machine credential (if SP4_MACH_CRED is used) or the SSV credential (if SP4_SSV is used).",
      "ja": "* ネームスペースの一部でサーバーのセキュリティポリシーがRPCSEC_GSS認証を必要とする場合、クライアントはファイルごとの状態（例えば、ロック、クローズなど）を削除するためにRPCSEC_GSSクレデンシャルを使用する必要があります。サーバは、状態を削除する主体が特定の基準と一致する（例えば、主体を取得したものと同じでなければならないかもしれない）。ただし、クライアントはそのようなプリンシパルのためのRPCSEC_GSSコンテキストを持っていない可能性があり、そのようなコンテキストを作成できない可能性があります（ユーザーがログオフしたためにおそらく）。クライアントがSP4_MACH_CREDまたはSP4_SSV保護を確立すると、サーバーがマシンの信任状（SP4_MACH_CREDが使用されている場合）またはSSV認証情報（SP4_SSVが使用されている場合）を使用する必要がある操作のリストを指定できます。"
    },
    {
      "indent": 3,
      "text": "The SP4_MACH_CRED state protection option uses a machine credential where the principal that creates the client ID MUST also be the principal that performs client ID and session maintenance operations. The security of the machine credential state protection approach depends entirely on safeguarding the per-machine credential. Assuming a proper safeguard using the per-machine credential for operations like CREATE_SESSION, BIND_CONN_TO_SESSION, DESTROY_SESSION, and DESTROY_CLIENTID will prevent an attacker from associating a rogue connection with a session, or associating a rogue session with a client ID.",
      "ja": "SP4_MACH_CRED状態保護オプションは、クライアントIDを作成するプリンシパルもクライアントIDとセッションのメンテナンス操作を実行するプリンシパルである必要があります。マシン信用証明書状態保護アプローチのセキュリティは、マシンごとの信任状を保護する上で完全に依存します。create_session、bind_conn_to_session、destroy_scrientidなどの操作のマシンの信任状を使用して適切な保護措置を使用すると、攻撃者がセッションとの不正な接続とセッションとの関連付け、またはクライアントIDとの関連付けを防ぎます。"
    },
    {
      "indent": 3,
      "text": "There are at least three scenarios for the SP4_MACH_CRED option:",
      "ja": "SP4_MACH_CREDオプションには少なくとも3つのシナリオがあります。"
    },
    {
      "indent": 3,
      "text": "1. The system administrator configures a unique, permanent per-machine credential for one of the mandated GSS mechanisms (e.g., if Kerberos V5 is used, a \"keytab\" containing a principal derived from a client host name could be used).",
      "ja": "1. システム管理者は、必須のGSSメカニズムの1つに対して一意の永続的なマシンの信任状を設定します（例えば、Kerberos V5が使用されている場合は、クライアントホスト名から派生したプリンシパルを含む「KeyTab」を使用できる）。"
    },
    {
      "indent": 3,
      "text": "2. The client is used by a single user, and so the client ID and its sessions are used by just that user. If the user's credential expires, then session and client ID maintenance cannot occur, but since the client has a single user, only that user is inconvenienced.",
      "ja": "2. クライアントは単一のユーザーによって使用されているので、クライアントIDとそのセッションはそのユーザーだけで使用されます。ユーザーの資格情報が期限切れになると、セッションとクライアントIDのメンテナンスが発生することはできませんが、クライアントには単一のユーザーがあるため、そのユーザーのみが不便です。"
    },
    {
      "indent": 3,
      "text": "3. The physical client has multiple users, but the client implementation has a unique client ID for each user. This is effectively the same as the second scenario, but a disadvantage is that each user needs to be allocated at least one session each, so the approach suffers from lack of economy.",
      "ja": "3. 物理クライアントに複数のユーザーがありますが、クライアント実装には各ユーザーに固有のクライアントIDがあります。これは2番目のシナリオと同じですが、それぞれのユーザーをそれぞれ少なくとも1つのセッションを割り当てる必要があることがあります。"
    },
    {
      "indent": 3,
      "text": "The SP4_SSV protection option uses the SSV (Section 1.7), via RPCSEC_GSS and the SSV GSS mechanism (Section 2.10.9), to protect state from attack. The SP4_SSV protection option is intended for the situation comprised of a client that has multiple active users and a system administrator who wants to avoid the burden of installing a permanent machine credential on each client. The SSV is established and updated on the server via SET_SSV (see Section 18.47). To prevent eavesdropping, a client SHOULD send SET_SSV via RPCSEC_GSS with the privacy service. Several aspects of the SSV make it intractable for an attacker to guess the SSV, and thus associate rogue connections with a session, and rogue sessions with a client ID:",
      "ja": "SP4_SSV保護オプションは、攻撃から状態を保護するために、RPCSEC_GSSおよびSSV GSSメカニズム（セクション2.10.9）を介してSSV（1.7）を使用します。SP4_SSV保護オプションは、複数のアクティブなユーザーを持つクライアントと、各クライアントに永続的なマシンの資格情報をインストールするという負担を避けたいシステム管理者とからなる状況を目的としています。SSVはset_ssvを介してサーバー上で確立され更新されます（18.47節を参照）。盗聴を防ぐために、クライアントはPrivacy Serviceを使用してRPCSEC_GSSを介してset_ssvを送信する必要があります。SSVのいくつかの側面は、攻撃者がSSVを推測するために扱いやすく、したがって不正な接続をセッションと関連付け、クライアントIDとの不正なセッションを関連付けます。"
    },
    {
      "indent": 3,
      "text": "* The arguments to and results of SET_SSV include digests of the old and new SSV, respectively.",
      "ja": "* set_ssvの引数と結果には、それぞれ古いSSVと新しいSSVのダイジェストが含まれます。"
    },
    {
      "indent": 3,
      "text": "* Because the initial value of the SSV is zero, therefore known, the client that opts for SP4_SSV protection and opts to apply SP4_SSV protection to BIND_CONN_TO_SESSION and CREATE_SESSION MUST send at least one SET_SSV operation before the first BIND_CONN_TO_SESSION operation or before the second CREATE_SESSION operation on a client ID. If it does not, the SSV mechanism will not generate tokens (Section 2.10.9). A client SHOULD send SET_SSV as soon as a session is created.",
      "ja": "* したがって、SSVの初期値はゼロであるため、既知であるため、SP4_SSV保護をオプションし、SP4_SSV保護をBIND_CONN_TO_SESSIONに適用し、CREATE_SESSESTをOPTにする必要があります。クライアントID。そうでない場合、SSVメカニズムはトークンを生成しません（セクション2.10.9）。セッションが作成されるとすぐにクライアントがset_ssvを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "* A SET_SSV request does not replace the SSV with the argument to SET_SSV. Instead, the current SSV on the server is logically exclusive ORed (XORed) with the argument to SET_SSV. Each time a new principal uses a client ID for the first time, the client SHOULD send a SET_SSV with that principal's RPCSEC_GSS credentials, with RPCSEC_GSS service set to RPC_GSS_SVC_PRIVACY.",
      "ja": "* set_ssv要求は、SSVを引数に置き換えない。代わりに、サーバー上の現在のSSVは論理的に排他的または引数を指定してset_ssvへの引数です。新しいプリンシパルが初めてクライアントIDを使用するたびに、クライアントはそのプリンシパルのRPCSEC_GSSクレデンシャルを使用してset_ssvを送信し、RPCSEC_GSSサービスはRPC_GSS_SVC_PRIVACYに設定されています。"
    },
    {
      "indent": 3,
      "text": "Here are the types of attacks that can be attempted by an attacker named Eve on a victim named Bob, and how SP4_SSV protection foils each attack:",
      "ja": "これは、ボブという名前の犠牲者に命名された攻撃者が試みることができる攻撃の種類、およびSP4_SSV保護が各攻撃を守る方法です。"
    },
    {
      "indent": 3,
      "text": "* Suppose Eve is the first user to log into a legitimate client. Eve's use of an NFSv4.1 file system will cause the legitimate client to create a client ID with SP4_SSV protection, specifying that the BIND_CONN_TO_SESSION operation MUST use the SSV credential. Eve's use of the file system also causes an SSV to be created. The SET_SSV operation that creates the SSV will be protected by the RPCSEC_GSS context created by the legitimate client, which uses Eve's GSS principal and credentials. Eve can eavesdrop on the network while her RPCSEC_GSS context is created and the SET_SSV using her context is sent. Even if the legitimate client sends the SET_SSV with RPC_GSS_SVC_PRIVACY, because Eve knows her own credentials, she can decrypt the SSV. Eve can compute an RPCSEC_GSS credential that BIND_CONN_TO_SESSION will accept, and so associate a new connection with the legitimate session. Eve can change the slot ID and sequence state of a legitimate session, and/or the SSV state, in such a way that when Bob accesses the server via the same legitimate client, the legitimate client will be unable to use the session.",
      "ja": "* EVEが正当なクライアントにログインする最初のユーザーであるとします。 EveのNFSV4.1ファイルシステムの使用により、RegitimeクライアントがSP4_SSV保護を使用してクライアントIDを作成し、BIND_CONN_TO_SESSION操作がSSV認証情報を使用する必要があることを指定します。ファイルシステムのEVEの使用により、SSVが作成されます。 SSVを作成するSET_SSV操作は、Regitimate Clientによって作成されたRPCSEC_GSSコンテキストによって保護され、これはEveのGSSプリンシパルと資格情報を使用します。彼女のrpcsec_gssコンテキストが作成され、彼女のコンテキストを使用してset_ssvが送信されている間、Eveはネットワーク上で盗聴することができます。正当なクライアントがRPC_GSS_SVC_PRIVACYを使用してSET_SSVを送信しても、EVEは自分の資格情報を知っているため、SSVを復号化できます。 EVEは、bind_conn_to_sessionが受け入れるRPCSEC_GSSクレデンシャルを計算でき、新しい接続を正当なセッションに関連付けます。 EVEは、BOBが同じRegitimateクライアントを介してサーバーにアクセスすると、正当なクライアントがセッションを使用できなくなるように、EVEは正当なセッションとSEQUENT状態のスロットIDとシーケンス状態を変更できます。"
    },
    {
      "indent": 6,
      "text": "The client's only recourse is to create a new client ID for Bob to use, and establish a new SSV for the client ID. The client will be unable to delete the old client ID, and will let the lease on the old client ID expire.",
      "ja": "クライアントの専用の推奨事項は、使用するBOBの新しいクライアントIDを作成し、クライアントIDの新しいSSVを確立することです。クライアントは古いクライアントIDを削除することができなくなり、古いクライアントIDのリースが期限切れにされます。"
    },
    {
      "indent": 6,
      "text": "Once the legitimate client establishes an SSV over the new session using Bob's RPCSEC_GSS context, Eve can use the new session via the legitimate client, but she cannot disrupt Bob. Moreover, because the client SHOULD have modified the SSV due to Eve using the new session, Bob cannot get revenge on Eve by associating a rogue connection with the session.",
      "ja": "正当なクライアントがBobのRPCSEC_GSSコンテキストを使用して新しいセッションを介してSSVを確立すると、EVEは正当なクライアントを介して新しいセッションを使用できますが、BOBを中断することはできません。さらに、クライアントは新しいセッションを使用してEVEのためにSSVを修正したはずであるため、ローグ接続とセッションとの関連付けを関連付けることで、復讐を復讐することはできません。"
    },
    {
      "indent": 6,
      "text": "The question is how did the legitimate client detect that Eve has hijacked the old session? When the client detects that a new principal, Bob, wants to use the session, it SHOULD have sent a SET_SSV, which leads to the following sub-scenarios:",
      "ja": "問題は、正当なクライアントがそのEveが古いセッションをハイジャックしたことをどのように検出したのでしょうか。クライアントが新しいプリンシパルBOBがセッションを使用したいことを検出すると、SET_SSVが送信されたはずです。これにより、次のサブシナリオが発生します。"
    },
    {
      "indent": 6,
      "text": "- Let us suppose that from the rogue connection, Eve sent a SET_SSV with the same slot ID and sequence ID that the legitimate client later uses. The server will assume the SET_SSV sent with Bob's credentials is a retry, and return to the legitimate client the reply it sent Eve. However, unless Eve can correctly guess the SSV the legitimate client will use, the digest verification checks in the SET_SSV response will fail. That is an indication to the client that the session has apparently been hijacked.",
      "ja": "- Rogue接続からEVEがSET_SSVをSET_SSVに送信させて、正当なクライアントが後で使用するのと同じスロットIDとシーケンスIDを送信しました。サーバーは、BOBの認証情報が再試行で送信されたSET_SSSVが想定され、Reptimate Clientに戻ってEveを送信します。ただし、EVEが正当なクライアントが使用するSSVを正しく推測できる限り、SET_SSV応答のダイジェスト検証チェックは失敗します。これは、セッションが明らかにハイジャックされたことをクライアントに指示しています。"
    },
    {
      "indent": 6,
      "text": "- Alternatively, Eve sent a SET_SSV with a different slot ID than the legitimate client uses for its SET_SSV. Then the digest verification of the SET_SSV sent with Bob's credentials fails on the server, and the error returned to the client makes it apparent that the session has been hijacked.",
      "ja": "- あるいは、EVEはそのset_ssvのために正当なクライアントが使用するのとは異なるスロットIDを持つset_ssvを送信しました。その後、BOBの資格情報を送信したSET_SSVのダイジェスト検証はサーバー上で失敗し、クライアントに返されたエラーは、セッションがハイジャックされたことを明らかにします。"
    },
    {
      "indent": 6,
      "text": "- Alternatively, Eve sent an operation other than SET_SSV, but with the same slot ID and sequence that the legitimate client uses for its SET_SSV. The server returns to the legitimate client the response it sent Eve. The client sees that the response is not at all what it expects. The client assumes either session hijacking or a server bug, and either way destroys the old session.",
      "ja": "- あるいは、EVEはset_ssv以外の操作を送信しましたが、正当なクライアントがそのset_ssvに使用するのと同じスロットIDとシーケンスを使用します。サーバーは、Eveを送信した応答を正当なクライアントに戻ります。クライアントは、対応がそれが期待するものだけではないことを見ています。クライアントはセッションハイジャックまたはサーバーのバグのいずれかを想定しており、どちらの方法で古いセッションを破棄します。"
    },
    {
      "indent": 3,
      "text": "* Eve associates a rogue connection with the session as above, and then destroys the session. Again, Bob goes to use the server from the legitimate client, which sends a SET_SSV using Bob's credentials. The client receives an error that indicates that the session does not exist. When the client tries to create a new session, this will fail because the SSV it has does not match that which the server has, and now the client knows the session was hijacked. The legitimate client establishes a new client ID.",
      "ja": "* EVEは上記のように不正な接続をセッションに関連付けてからセッションを破棄します。繰り返しますが、Bobは正当なクライアントからサーバーを使用します。これは、BOBの資格情報を使用してset_ssvを送信します。クライアントは、セッションが存在しないことを示すエラーを受け取ります。クライアントが新しいセッションを作成しようとすると、SSVがサーバーが持っているものと一致しないため、これは失敗し、クライアントはセッションをハイジャックされたことを認識しました。合法的なクライアントは新しいクライアントIDを確立します。"
    },
    {
      "indent": 3,
      "text": "* If Eve creates a connection before the legitimate client establishes an SSV, because the initial value of the SSV is zero and therefore known, Eve can send a SET_SSV that will pass the digest verification check. However, because the new connection has not been associated with the session, the SET_SSV is rejected for that reason.",
      "ja": "* RegitimateクライアントがSSVを確立する前にEVEが接続を作成する場合、SSVの初期値はゼロ、したがって既知であるため、EVEはダイジェスト検証チェックを渡すSET_SSVを送信できます。ただし、新しい接続がセッションに関連付けられていないため、set_ssvはその理由で拒否されます。"
    },
    {
      "indent": 3,
      "text": "In summary, an attacker's disruption of state when SP4_SSV protection is in use is limited to the formative period of a client ID, its first session, and the establishment of the SSV. Once a non-malicious user uses the client ID, the client quickly detects any hijack and rectifies the situation. Once a non-malicious user successfully modifies the SSV, the attacker cannot use NFSv4.1 operations to disrupt the non-malicious user.",
      "ja": "要約すると、SP4_SSV保護が使用されているときの攻撃者の州の中断は、クライアントID、その最初のセッション、およびSSVの確立に制限されています。悪意のあるユーザーがクライアントIDを使用すると、クライアントは迅速にハイジャックを検出し、状況を整理します。悪意のあるユーザーがSSVを正常に変更すると、攻撃者はNFSv4.1操作を使用して非悪質なユーザーを中断することはできません。"
    },
    {
      "indent": 3,
      "text": "Note that neither the SP4_MACH_CRED nor SP4_SSV protection approaches prevent hijacking of a transport connection that has previously been associated with a session. If the goal of a counter-threat strategy is to prevent connection hijacking, the use of IPsec is RECOMMENDED.",
      "ja": "SP4_MACH_CREDもSP4_SSV保護アプローチも、以前にセッションに関連付けられているトランスポート接続のハイジャックを防止しないことに注意してください。カウンター脅威の戦略の目的が接続ハイジャックを防止することである場合は、IPSecの使用をお勧めします。"
    },
    {
      "indent": 3,
      "text": "If a connection hijack occurs, the hijacker could in theory change locking state and negatively impact the service to legitimate clients. However, if the server is configured to require the use of RPCSEC_GSS with integrity or privacy on the affected file objects, and if EXCHGID4_FLAG_BIND_PRINC_STATEID capability (Section 18.35) is in force, this will thwart unauthorized attempts to change locking state.",
      "ja": "接続ハイジャックが発生した場合、Hijackerは理論的なロック状態を変更し、正当なクライアントにサービスに悪影響を与える可能性があります。ただし、影響を受けるファイルオブジェクトに対して整合性またはプライバシーを持つRPCSEC_GSSを使用するように設定されている場合、およびEXCHGID4_FLAG_BIND_PRINC_STATEID機能（セクション18.35）が施行されている場合は、wartが不正な状態を変更しようとします。"
    },
    {
      "indent": 0,
      "text": "2.10.9. The Secret State Verifier (SSV) GSS Mechanism",
      "section_title": true,
      "ja": "2.10.9. 秘密状態検証者（SSV）GSS機構"
    },
    {
      "indent": 3,
      "text": "The SSV provides the secret key for a GSS mechanism internal to NFSv4.1 that NFSv4.1 uses for state protection. Contexts for this mechanism are not established via the RPCSEC_GSS protocol. Instead, the contexts are automatically created when EXCHANGE_ID specifies SP4_SSV protection. The only tokens defined are the PerMsgToken (emitted by GSS_GetMIC) and the SealedMessage token (emitted by GSS_Wrap).",
      "ja": "SSVは、NFSv4.1の内部GSSメカニズムの秘密鍵をNFSV4.1に提供します。このメカニズムのコンテキストは、RPCSEC_GSSプロトコルを介して確立されていません。代わりに、Exchange_idがSP4_SSV保護を指定している場合、コンテキストは自動的に作成されます。定義されている唯一のトークンはPermSgToken（GSS_GetMicによって発行された）とSealedMessageトークン（GSS_WRAPによって放出されます）です。"
    },
    {
      "indent": 3,
      "text": "The mechanism OID for the SSV mechanism is iso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv_mech (1.3.6.1.4.1.28882.1.1). While the SSV mechanism does not define any initial context tokens, the OID can be used to let servers indicate that the SSV mechanism is acceptable whenever the client sends a SECINFO or SECINFO_NO_NAME operation (see Section 2.6).",
      "ja": "SSVメカニズムのためのメカニズムOIDはiso.org.dod.internet.private.enterprise.michael Eisler.nfs.sv_mech（1.3.6.1.4.1.28882.1.1）です。SSVメカニズムは初期コンテキストトークンを定義していない間、OIDを使用して、サーバーを使用して、クライアントがSECINFOまたはSECINFO_NO_NAME操作を送信するたびにSSVメカニズムが許容できることを示します（セクション2.6を参照）。"
    },
    {
      "indent": 3,
      "text": "The SSV mechanism defines four subkeys derived from the SSV value. Each time SET_SSV is invoked, the subkeys are recalculated by the client and server. The calculation of each of the four subkeys depends on each of the four respective ssv_subkey4 enumerated values. The calculation uses the HMAC [52] algorithm, using the current SSV as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by the XDR encoded enumeration value for that subkey of data type ssv_subkey4. If the length of the output of the HMAC algorithm exceeds the length of key of the encryption algorithm (which is also negotiated by EXCHANGE_ID), then the subkey MUST be truncated from the HMAC output, i.e., if the subkey is of N bytes long, then the first N bytes of the HMAC output MUST be used for the subkey. The specification of EXCHANGE_ID states that the length of the output of the HMAC algorithm MUST NOT be less than the length of subkey needed for the encryption algorithm (see Section 18.35).",
      "ja": "SSVメカニズムは、SSV値から派生した4つのサブキーを定義します。 set_ssvが呼び出されるたびに、サブキーはクライアントとサーバーによって再計算されます。 4つのサブキーのそれぞれの計算は、それぞれのそれぞれのSSV_SUBKEY4列挙値のそれぞれによって異なります。この計算は、現在のSSVをキーとしてのHMAC [52]アルゴリズム、Exchange_IDによってネゴシエートされた一方向ハッシュアルゴリズム、およびデータ型SSV_SUBKEY4のそのサブキーのXDRエンコードされた列挙値によって表される入力テキストを使用します。 HMACアルゴリズムの出力の長さが暗号化アルゴリズムのキーの長さを超えている場合（これはExchange_IDによってもネゴシエートされます）、サブキーはHMAC出力から切り捨てられなければならず、すなわちサブキーがnバイトの長さである場合、その後、HMAC出力の最初のNバイトをサブキーに使用する必要があります。 Exchange_idの指定は、HMACアルゴリズムの出力の長さが暗号化アルゴリズムに必要なサブキーの長さよりも小さくなければならないことを示しています（セクション18.35を参照）。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing subkeys */\nenum ssv_subkey4 {\n        SSV4_SUBKEY_MIC_I2T     = 1,\n        SSV4_SUBKEY_MIC_T2I     = 2,\n        SSV4_SUBKEY_SEAL_I2T    = 3,\n        SSV4_SUBKEY_SEAL_T2I    = 4\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The subkey derived from SSV4_SUBKEY_MIC_I2T is used for calculating message integrity codes (MICs) that originate from the NFSv4.1 client, whether as part of a request over the fore channel or a response over the backchannel. The subkey derived from SSV4_SUBKEY_MIC_T2I is used for MICs originating from the NFSv4.1 server. The subkey derived from SSV4_SUBKEY_SEAL_I2T is used for encryption text originating from the NFSv4.1 client, and the subkey derived from SSV4_SUBKEY_SEAL_T2I is used for encryption text originating from the NFSv4.1 server.",
      "ja": "SSV4_SUBKEY_MIC_I2Tから派生したサブキーは、NFSV4.1クライアントから発生するメッセージインテグリティコード（MIC）を計算するために、前面チャネルを介した要求の一部またはバックチャネルを介したレスポンスであるかどうかを計算するために使用されます。SSV4_SUBKEY_MIC_T2Iから派生したサブキーは、NFSV4.1サーバーから発信されたMICに使用されます。SSV4_SUBKEY_SEAL_I2Tから派生したサブキーは、NFSV4.1クライアントから発信された暗号化テキストに使用され、SSV4_SUBKEY_SEAL_T2Iから派生したサブキーはNFSV4.1サーバーから発信された暗号化テキストに使用されます。"
    },
    {
      "indent": 3,
      "text": "The PerMsgToken description is based on an XDR definition:",
      "ja": "permsgtokenの説明はXDR定義に基づいています。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing smt_hmac */\nstruct ssv_mic_plain_tkn4 {\n  uint32_t        smpt_ssv_seq;\n  opaque          smpt_orig_plain<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* SSV GSS PerMsgToken token */\nstruct ssv_mic_tkn4 {\n  uint32_t        smt_ssv_seq;\n  opaque          smt_hmac<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The field smt_hmac is an HMAC calculated by using the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by data of type ssv_mic_plain_tkn4. The field smpt_ssv_seq is the same as smt_ssv_seq. The field smpt_orig_plain is the \"message\" input passed to GSS_GetMIC() (see Section 2.3.1 of [7]). The caller of GSS_GetMIC() provides a pointer to a buffer containing the plain text. The SSV mechanism's entry point for GSS_GetMIC() encodes this into an opaque array, and the encoding will include an initial four-byte length, plus any necessary padding. Prepended to this will be the XDR encoded value of smpt_ssv_seq, thus making up an XDR encoding of a value of data type ssv_mic_plain_tkn4, which in turn is the input into the HMAC.",
      "ja": "フィールドSMT_HMACは、SSV4_SUBKEY_MIC_I2TまたはSSV4_SUBKEY_MIC_T2IまたはSSV4_SUBKEY_MIC_T2IまたはSSV4_SUBKEY_MIC_T2Iから派生したサブキーを、Exchange_IDによってネゴシエートされた一方向ハッシュアルゴリズム、およびSSV_MIC_PLAIN_TKN4のデータによって表される入力テキストを使用して計算されます。フィールドSMPT_SSV_SEQはSMT_SSV_SEQと同じです。フィールドSMPT_ORIG_PLAINは、GSS_GETMIC（）に渡された「メッセージ」入力です（[7]のセクション2.3.1を参照）。GSS_GetMic（）の呼び出し側は、プレーンテキストを含むバッファへのポインタを提供します。gss_getmic（）のSSVメカニズムのエントリポイントはこれを不透明な配列にエンコードし、エンコーディングには初期4バイトの長さと必要なパディングが含まれます。これに先に記述されたSMPT_SSV_SEQのXDRエンコードされた値になり、データ型SSV_MIC_PLAIN_TKN4のXDRエンコーディングが行われ、これは次にHMACへの入力です。"
    },
    {
      "indent": 3,
      "text": "The token emitted by GSS_GetMIC() is XDR encoded and of XDR data type ssv_mic_tkn4. The field smt_ssv_seq comes from the SSV sequence number, which is equal to one after SET_SSV (Section 18.47) is called the first time on a client ID. Thereafter, the SSV sequence number is incremented on each SET_SSV. Thus, smt_ssv_seq represents the version of the SSV at the time GSS_GetMIC() was called. As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. This allows the SSV to be changed without serializing all RPC calls that use the SSV mechanism with SET_SSV operations. Once the HMAC is calculated, it is XDR encoded into smt_hmac, which will include an initial four-byte length, and any necessary padding. Prepended to this will be the XDR encoded value of smt_ssv_seq.",
      "ja": "GSS_GETMIC（）によって放出されたトークンはXDRエンコードされ、XDRデータ型SSV_MIC_TKN4です。フィールドSMT_SSV_SEQはSSVシーケンス番号から来ており、これはSet_ssv（セクション18.47）がクライアントID上の初めて呼び出された後に1つに等しい。その後、SSVシーケンス番号は各SET_SSVでインクリメントされます。したがって、SMT_SSV_SEQは、GSS_GETMIC（）が呼び出された時点でのSSVのバージョンを表します。18.35項で述べたように、クライアントとサーバーはSSVの複数の同時バージョンを維持できます。これにより、SSVメカニズムをSET_SSV操作で使用するすべてのRPCコールをシリアル化することなくSSVを変更できます。HMACが計算されると、それはSMT_HMACにエンコードされ、最初の4バイトの長さ、および必要なパディングが含まれます。これに先に記述されたSMT_SSV_SEQのXDRエンコードされた値になります。"
    },
    {
      "indent": 3,
      "text": "The SealedMessage description is based on an XDR definition:",
      "ja": "SealedMessageの説明はXDR定義に基づいています。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing ssct_encr_data and ssct_hmac */\nstruct ssv_seal_plain_tkn4 {\n  opaque          sspt_confounder<>;\n  uint32_t        sspt_ssv_seq;\n  opaque          sspt_orig_plain<>;\n  opaque          sspt_pad<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* SSV GSS SealedMessage token */\nstruct ssv_seal_cipher_tkn4 {\n  uint32_t      ssct_ssv_seq;\n  opaque        ssct_iv<>;\n  opaque        ssct_encr_data<>;\n  opaque        ssct_hmac<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The token emitted by GSS_Wrap() is XDR encoded and of XDR data type ssv_seal_cipher_tkn4.",
      "ja": "GSS_WRAP（）によって発せられたトークンはXDRエンコードされ、XDRデータ型SSV_SEAL_CIPHER_TKN4です。"
    },
    {
      "indent": 3,
      "text": "The ssct_ssv_seq field has the same meaning as smt_ssv_seq.",
      "ja": "ssct_ssv_seqフィールドはSMT_SSV_SEQと同じ意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "The ssct_encr_data field is the result of encrypting a value of the XDR encoded data type ssv_seal_plain_tkn4. The encryption key is the subkey derived from SSV4_SUBKEY_SEAL_I2T or SSV4_SUBKEY_SEAL_T2I, and the encryption algorithm is that negotiated by EXCHANGE_ID.",
      "ja": "ssct_encr_dataフィールドは、XDRエンコードデータ型SSV_SEAL_PLAIN_TKN4の値を暗号化した結果です。暗号化キーは、SSV4_SUBKEY_SEAL_I2TまたはSSV4_SUBKEY_SEAL_T2Iから派生したサブキーであり、暗号化アルゴリズムはExchange_IDによってネゴシエートされます。"
    },
    {
      "indent": 3,
      "text": "The ssct_iv field is the initialization vector (IV) for the encryption algorithm (if applicable) and is sent in clear text. The content and size of the IV MUST comply with the specification of the encryption algorithm. For example, the id-aes256-CBC algorithm MUST use a 16-byte initialization vector (IV), which MUST be unpredictable for each instance of a value of data type ssv_seal_plain_tkn4 that is encrypted with a particular SSV key.",
      "ja": "ssct_ivフィールドは、暗号化アルゴリズムの初期化ベクトル（IV）であり、明確なテキストで送信されます。IVの内容とサイズは、暗号化アルゴリズムの仕様に準拠している必要があります。たとえば、ID-AES256-CBCアルゴリズムは、特定のSSVキーで暗号化されているデータ型SSV_SEAL_PLAIN_TKN4の値の各インスタンスに対して予測できない16バイトの初期化ベクトル（IV）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ssct_hmac field is the result of computing an HMAC using the value of the XDR encoded data type ssv_seal_plain_tkn4 as the input text. The key is the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I, and the one-way hash algorithm is that negotiated by EXCHANGE_ID.",
      "ja": "SSCT_HMACフィールドは、入力テキストとしてXDRエンコードされたデータ型SSV_SEAL_PLAIN_TKN4の値を使用してHMACを計算した結果です。キーは、SSV4_SUBKEY_MIC_I2TまたはSSV4_SUBKEY_MIC_T2Iから派生したサブキーであり、一方向ハッシュアルゴリズムはExchange_IDによってネゴシエートされます。"
    },
    {
      "indent": 3,
      "text": "The sspt_confounder field is a random value.",
      "ja": "SSPT_CONOFOUNDERフィールドはランダムな値です。"
    },
    {
      "indent": 3,
      "text": "The sspt_ssv_seq field is the same as ssvt_ssv_seq.",
      "ja": "sspt_ssv_seqフィールドはssvt_ssv_seqと同じです。"
    },
    {
      "indent": 3,
      "text": "The field sspt_orig_plain field is the original plaintext and is the \"input_message\" input passed to GSS_Wrap() (see Section 2.3.3 of [7]). As with the handling of the plaintext by the SSV mechanism's GSS_GetMIC() entry point, the entry point for GSS_Wrap() expects a pointer to the plaintext, and will XDR encode an opaque array into sspt_orig_plain representing the plain text, along with the other fields of an instance of data type ssv_seal_plain_tkn4.",
      "ja": "フィールドSSPT_ORIG_PLAINフィールドは元の平文で、GSS_WRAP（）に渡された \"input_message\"入力です（[7]のセクション2.3.3を参照）。SSVメカニズムのGSS_GETMIC（）エントリポイントによる平文の処理と同様に、GSS_WRAP（）のエントリポイントは平文へのポインタを想定し、XDRはプレーンテキストを表すSSPT_ORIG_PLAINにXDRをエンコードします。データ型SSV_SEAL_PLAIN_TKN4の例。"
    },
    {
      "indent": 3,
      "text": "The sspt_pad field is present to support encryption algorithms that require inputs to be in fixed-sized blocks. The content of sspt_pad is zero filled except for the length. Beware that the XDR encoding of ssv_seal_plain_tkn4 contains three variable-length arrays, and so each array consumes four bytes for an array length, and each array that follows the length is always padded to a multiple of four bytes per the XDR standard.",
      "ja": "SSPT_PADフィールドは、入力を固定サイズのブロックにする必要がある暗号化アルゴリズムをサポートするために存在します。SSPT_PADの内容は、長さを除いてゼロにいっぱいです。SSV_SEAL_PLAIN_TKN4のXDRエンコーディングには3つの可変長配列が含まれているので、各配列はアレイ長に対して4バイトを消費し、長さに続く各配列は常にXDR規格ごとに4バイトの倍数に埋め込まれます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the encryption algorithm uses 16-byte blocks, and the sspt_confounder is three bytes long, and the sspt_orig_plain field is 15 bytes long. The XDR encoding of sspt_confounder uses eight bytes (4 + 3 + 1-byte pad), the XDR encoding of sspt_ssv_seq uses four bytes, the XDR encoding of sspt_orig_plain uses 20 bytes (4 + 15 + 1-byte pad), and the smallest XDR encoding of the sspt_pad field is four bytes. This totals 36 bytes. The next multiple of 16 is 48; thus, the length field of sspt_pad needs to be set to 12 bytes, or a total encoding of 16 bytes. The total number of XDR encoded bytes is thus 8 + 4 + 20 + 16 = 48.",
      "ja": "たとえば、暗号化アルゴリズムが16バイトのブロックを使用し、SSPT_CONOFOUNDERは3バイトの長さで、SSPT_ORIG_PLAINフィールドは15バイト長です。SSPT_CONFOUNDORのXDRエンコーディングは8バイト（4 3 1バイトPAD）を使用しているため、SSPT_SSV_SEQのXDRエンコーディングは4バイトを使用しています.SSPT_ORIG_PLAINのXDRエンコーディングは、20バイト（4 15 1バイトPAD）を使用し、最小のXDRエンコーディングを使用します。SSPT_PADフィールドは4バイトです。この合計36バイト16の次の倍数は48です。したがって、SSPT_PADの長さフィールドは12バイト、または16バイトの総エンコードを設定する必要があります。したがって、XDR符号化バイトの総数は8 4 20 16 = 48である。"
    },
    {
      "indent": 3,
      "text": "GSS_Wrap() emits a token that is an XDR encoding of a value of data type ssv_seal_cipher_tkn4. Note that regardless of whether or not the caller of GSS_Wrap() requests confidentiality, the token always has confidentiality. This is because the SSV mechanism is for RPCSEC_GSS, and RPCSEC_GSS never produces GSS_wrap() tokens without confidentiality.",
      "ja": "gss_wrap（）は、データ型SSV_SEAL_CIPHER_TKN4の値のXDRエンコードであるトークンをエクステイします。GSS_WRAP（）の発信者が機密性を要求しているかどうかにかかわらず、トークンには常に機密性があります。これは、SSVメカニズムがRPCSEC_GSSの場合、RPCSEC_GSSは機密性なしにGSS_WRAP（）トークンを生成することはありません。"
    },
    {
      "indent": 3,
      "text": "There is one SSV per client ID. There is a single GSS context for a client ID / SSV pair. All SSV mechanism RPCSEC_GSS handles of a client ID / SSV pair share the same GSS context. SSV GSS contexts do not expire except when the SSV is destroyed (causes would include the client ID being destroyed or a server restart). Since one purpose of context expiration is to replace keys that have been in use for \"too long\", hence vulnerable to compromise by brute force or accident, the client can replace the SSV key by sending periodic SET_SSV operations, which is done by cycling through different users' RPCSEC_GSS credentials. This way, the SSV is replaced without destroying the SSV's GSS contexts.",
      "ja": "クライアントIDごとにSSVが1つあります。クライアントID / SSVペアのための単一のGSSコンテキストがあります。すべてのSSVメカニズムRPCSEC_GSSクライアントID / SSVペアのハンドルは、同じGSSコンテキストを共有します。SSVがSSVが破棄されたときを除いて、SSV GSSコンテキストは期限切れになりません（原因には破棄されているクライアントIDまたはサーバーの再起動が含まれます）。コンテキストの有効期限の目的は、「長すぎる」に使用されているキーを置き換えることです。さまざまなユーザーのRPCSEC_GSS認証情報。このようにして、SSVのGSSコンテキストを破棄することなくSSVが置き換えられます。"
    },
    {
      "indent": 3,
      "text": "SSV RPCSEC_GSS handles can be expired or deleted by the server at any time, and the EXCHANGE_ID operation can be used to create more SSV RPCSEC_GSS handles. Expiration of SSV RPCSEC_GSS handles does not imply that the SSV or its GSS context has expired.",
      "ja": "SSV RPCSEC_GSSハンドルはいつでもサーバーによって期限切れまたは削除することができ、Exchange_ID操作を使用してより多くのSSV RPCSEC_GSSハンドルを作成できます。SSV RPCSEC_GSSハンドルの有効期限は、SSVまたはそのGSSコンテキストが期限切れになったことを意味しません。"
    },
    {
      "indent": 3,
      "text": "The client MUST establish an SSV via SET_SSV before the SSV GSS context can be used to emit tokens from GSS_Wrap() and GSS_GetMIC(). If SET_SSV has not been successfully called, attempts to emit tokens MUST fail.",
      "ja": "クライアントは、SSV GSSコンテキストを使用してGSS_WRAP（）およびGSS_GETMIC（）からトークンをエミッでエミッタリングできる前にSET_SSVを介してSSVを確立する必要があります。set_ssvが正常に呼び出されていない場合、トークンをエミッタエミッタを発行しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "The SSV mechanism does not support replay detection and sequencing in its tokens because RPCSEC_GSS does not use those features (see \"Context Creation Requests\", Section 5.2.2 of [4]). However, Section 2.10.10 discusses special considerations for the SSV mechanism when used with RPCSEC_GSS.",
      "ja": "RPCSEC_GSSがそれらの機能を使用しないため、SSVメカニズムはトークン内の再生検出とシーケンスをサポートしません（[4]の「コンテキスト作成要求」、セクション5.2.2）。ただし、セクション2.10.10では、RPCSEC_GSSで使用されている場合のSSVメカニズムに関する特別な考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.10. Security Considerations for RPCSEC_GSS When Using the SSV Mechanism",
      "ja": "2.10.10. SSVメカニズムを使用するときのRPCSEC_GSSのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "When a client ID is created with SP4_SSV state protection (see Section 18.35), the client is permitted to associate multiple RPCSEC_GSS handles with the single SSV GSS context (see Section 2.10.9). Because of the way RPCSEC_GSS (both version 1 and version 2, see [4] and [9]) calculate the verifier of the reply, special care must be taken by the implementation of the NFSv4.1 client to prevent attacks by a man-in-the-middle. The verifier of an RPCSEC_GSS reply is the output of GSS_GetMIC() applied to the input value of the seq_num field of the RPCSEC_GSS credential (data type rpc_gss_cred_ver_1_t) (see Section 5.3.3.2 of [4]). If multiple RPCSEC_GSS handles share the same GSS context, then if one handle is used to send a request with the same seq_num value as another handle, an attacker could block the reply, and replace it with the verifier used for the other handle.",
      "ja": "クライアントIDがSP4_SSV状態保護（セクション18.35を参照）で作成されると、クライアントは複数のRPCSEC_GSSハンドルを単一のSSV GSSコンテキストに関連付けることができます（セクション2.10.9を参照）。rpcsec_gss（バージョン1とバージョン2の両方、[4]、[9]）の計算は、返信の検証を計算する必要があります。マンによる攻撃を防ぐためのNFSV4.1クライアントの実装によって考慮する必要があります。途中で。RPCSEC_GSS応答の検証者は、RPCSEC_GSSクレデンシャル（データ型RPC_GSS_CRED_VER__1_T）のSEQ_NUMフィールドの入力値に適用されるGSS_GETMIC（）の出力です（[4]のセクション5.3.3.2を参照）。複数のRPCSEC_GSSが同じGSSコンテキストを共有する場合、1つのハンドルを使用して同じSEQNUM値を別のハンドルとして要求を送信する場合、攻撃者は返信をブロックし、もう一方のハンドルに使用される検証者に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways to prevent the attack on the SSV RPCSEC_GSS verifier in the reply. The simplest is believed to be as follows.",
      "ja": "返信でSSV RPCSEC_GSS検証者に対する攻撃を防ぐ方法は複数あります。最も単純なものは以下の通りであると考えられています。"
    },
    {
      "indent": 3,
      "text": "* Each time one or more new SSV RPCSEC_GSS handles are created via EXCHANGE_ID, the client SHOULD send a SET_SSV operation to modify the SSV. By changing the SSV, the new handles will not result in the re-use of an SSV RPCSEC_GSS verifier in a reply.",
      "ja": "* 1つ以上の新しいSSV RPCSEC_GSSハンドルがExchange_IDを介して作成されるたびに、クライアントはSSVを変更するためのset_ssv操作を送信する必要があります。SSVを変更することで、新しいハンドルは応答のSSV RPCSEC_GSS検証者の再利用をもたらされません。"
    },
    {
      "indent": 3,
      "text": "* When a requester decides to use N SSV RPCSEC_GSS handles, it SHOULD assign a unique and non-overlapping range of seq_nums to each SSV RPCSEC_GSS handle. The size of each range SHOULD be equal to MAXSEQ / N (see Section 5 of [4] for the definition of MAXSEQ). When an SSV RPCSEC_GSS handle reaches its maximum, it SHOULD force the replier to destroy the handle by sending a NULL RPC request with seq_num set to MAXSEQ + 1 (see Section 5.3.3.3 of [4]).",
      "ja": "* リクエスターがNSV RPCSEC_GSSハンドルを使用することを決定すると、各SSV RPCSEC_GSSハンドルにSEQNUMSの一意の範囲と重複しない範囲を割り当てる必要があります。各範囲のサイズはmaxseq / nに等しくなければなりません（MaxSeqの定義については[4]のセクション5を参照）。SSV RPCSEC_GSSハンドルが最大に達すると、SEQNUMをMAXSQ 1に設定してNULL RPC要求を送信することで、リプライアにハンドルを破棄するように強制する必要があります（[4]のセクション5.3.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "* When the requester wants to increase or decrease N, it SHOULD force the replier to destroy all N handles by sending a NULL RPC request on each handle with seq_num set to MAXSEQ + 1. If the requester is the client, it SHOULD send a SET_SSV operation before using new handles. If the requester is the server, then the client SHOULD send a SET_SSV operation when it detects that the server has forced it to destroy a backchannel's SSV RPCSEC_GSS handle. By sending a SET_SSV operation, the SSV will change, and so the attacker will be unavailable to successfully replay a previous verifier in a reply to the requester.",
      "ja": "* リクエスタがNを増減したい場合はNを増減したい場合は、SEQ_NUMをMAXSEQに設定して各ハンドルでNULL RPC要求を送信することで、すべてのNハンドルを破壊する必要があります.1がクライアントである場合は、前にset_ssv操作を送信する必要があります。新しいハンドルを使うリクエスタがサーバーの場合、サーバーがBackChannelのSSV RPCSEC_GSSハンドルを破棄するように強制したことを検出すると、クライアントはset_ssv操作を送信する必要があります。set_ssv操作を送信することによって、SSVは変更され、攻撃者は要求者への返信で前の検証者を正常に再生することができません。"
    },
    {
      "indent": 3,
      "text": "Note that if the replier carefully creates the SSV RPCSEC_GSS handles, the related risk of a man-in-the-middle splicing a forged SSV RPCSEC_GSS credential with a verifier for another handle does not exist. This is because the verifier in an RPCSEC_GSS request is computed from input that includes both the RPCSEC_GSS handle and seq_num (see Section 5.3.1 of [4]). Provided the replier takes care to avoid re-using the value of an RPCSEC_GSS handle that it creates, such as by including a generation number in the handle, the man-in-the-middle will not be able to successfully replay a previous verifier in the request to a replier.",
      "ja": "ReplierがSSV RPCSEC_GSSハンドルを慎重に作成した場合、中間のSSV RPCSEC_GSSクレデンシャルが別のハンドルの検証者に登録されているMAN-IN-MIDDE SSV RPCSEC_GSSクレデンシャルの関連リスクが存在しません。これは、RPCSEC_GSS要求の検証者がRPCSEC_GSSハンドルとSEQ_NUMの両方を含む入力から計算されるためです（[4]のセクション5.3.1を参照）。Replierが、ハンドル内の世代番号を含めるなど、作成したRPCSEC_GSSハンドルの値を再利用しないように注意してください。中央のMAN-IN-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-THE-MODINDが、以前の検証者を再生できなくなります。専用の要求"
    },
    {
      "indent": 0,
      "text": "2.10.11. Session Mechanics - Steady State",
      "section_title": true,
      "ja": "2.10.11. セッションメカニズム - 定常状態"
    },
    {
      "indent": 0,
      "text": "2.10.11.1. Obligations of the Server",
      "section_title": true,
      "ja": "2.10.11.1. サーバーの義務"
    },
    {
      "indent": 3,
      "text": "The server has the primary obligation to monitor the state of backchannel resources that the client has created for the server (RPCSEC_GSS contexts and backchannel connections). If these resources vanish, the server takes action as specified in Section 2.10.13.2.",
      "ja": "サーバーには、クライアントがサーバー用に作成したバックチャネルリソースの状態を監視する主な義務があります（RPCSEC_GSSコンテキストとバックチャネル接続）。これらのリソースが消えた場合、サーバーはセクション2.10.13.2で指定されているようにアクションを実行します。"
    },
    {
      "indent": 0,
      "text": "2.10.11.2. Obligations of the Client",
      "section_title": true,
      "ja": "2.10.11.2. クライアントの義務"
    },
    {
      "indent": 3,
      "text": "The client SHOULD honor the following obligations in order to utilize the session:",
      "ja": "クライアントは、セッションを利用するために以下の義務を尊重する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Keep a necessary session from going idle on the server. A client that requires a session but nonetheless is not sending operations risks having the session be destroyed by the server. This is because sessions consume resources, and resource limitations may force the server to cull an inactive session. A server MAY consider a session to be inactive if the client has not used the session before the session inactivity timer (Section 2.10.12) has expired.",
      "ja": "* サーバー上のアイドル状態から必要なセッションを保持してください。セッションを必要とするが、それにもかかわらず、セッションを送信するリスクを送信していないクライアントは、サーバによって破棄されない。これは、セッションがリソースを消費するため、リソースの制限により、サーバーが非アクティブセッションを強制的に解凍する可能性があります。クライアントがセッション非アクティブタイマー（セクション2.10.12）が期限切れになった前に、クライアントがセッションを使用していない場合、サーバーが非アクティブになることを検討することがあります。"
    },
    {
      "indent": 3,
      "text": "* Destroy the session when not needed. If a client has multiple sessions, one of which has no requests waiting for replies, and has been idle for some period of time, it SHOULD destroy the session.",
      "ja": "* 必要ないときにセッションを破壊する。クライアントに複数のセッションがある場合、そのうちの1つは返信を待っていて、何らかの期間アイドル状態になっているため、セッションを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Maintain GSS contexts and RPCSEC_GSS handles for the backchannel. If the client requires the server to use the RPCSEC_GSS security flavor for callbacks, then it needs to be sure the RPCSEC_GSS handles and/or their GSS contexts that are handed to the server via BACKCHANNEL_CTL or CREATE_SESSION are unexpired.",
      "ja": "* BackChannelのGSSコンテキストとRPCSEC_GSSハンドルを維持します。クライアントにコールバックのRPCSEC_GSSセキュリティフレーバーを使用するようにする必要がある場合は、rpcsec_gssがbackchannel_ctlまたはcreate_sessionを経過してサーバーに渡されるRPCSEC_GSSがハンドルおよび/またはそれらのGSSコンテキストがないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Preserve a connection for a backchannel. The server requires a backchannel in order to gracefully recall recallable state or notify the client of certain events. Note that if the connection is not being used for the fore channel, there is no way for the client to tell if the connection is still alive (e.g., the server restarted without sending a disconnect). The onus is on the server, not the client, to determine if the backchannel's connection is alive, and to indicate in the response to a SEQUENCE operation when the last connection associated with a session's backchannel has disconnected.",
      "ja": "* バックチャネルの接続を保持します。サーバーには、リコール可能な状態を正しくリコールしたり、特定のイベントのクライアントに通知するためにバックチャネルが必要です。接続が前のチャネルに使用されていない場合、クライアントが接続がまだ生存しているかどうか（例えば、切断を送信せずにサーバーが再起動された場合）に指示する方法はありません。ONUSは、バックチャネルの接続が生きているかどうかを判断し、セッションのBackChannelに関連付けられている最後の接続が切断されたときに、シーケンス操作への応答を示すために、クライアントではなくサーバー上にあります。"
    },
    {
      "indent": 0,
      "text": "2.10.11.3. Steps the Client Takes to Establish a Session",
      "section_title": true,
      "ja": "2.10.11.3. ステップクライアントがセッションを確立するのにかかるステップ"
    },
    {
      "indent": 3,
      "text": "If the client does not have a client ID, the client sends EXCHANGE_ID to establish a client ID. If it opts for SP4_MACH_CRED or SP4_SSV protection, in the spo_must_enforce list of operations, it SHOULD at minimum specify CREATE_SESSION, DESTROY_SESSION, BIND_CONN_TO_SESSION, BACKCHANNEL_CTL, and DESTROY_CLIENTID. If it opts for SP4_SSV protection, the client needs to ask for SSV-based RPCSEC_GSS handles.",
      "ja": "クライアントにクライアントIDがない場合、クライアントはExchange_IDを送信してクライアントIDを確立します。SPO_MAST_ENFORCEの操作リストでは、SP4_MACH_CREDまたはSP4_SSV保護をオプトしている場合は、CREATE_SESSION、DEASTER_SESSION、BIND_CONNN_TO_SESSION、BACKCHANNEL_CTL、およびDOSTERY_CLIENTIDを指定する必要があります。SP4_SSV保護を選択した場合、クライアントはSSVベースのRPCSEC_GSSハンドルを要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client uses the client ID to send a CREATE_SESSION on a connection to the server. The results of CREATE_SESSION indicate whether or not the server will persist the session reply cache through a server that has restarted, and the client notes this for future reference.",
      "ja": "クライアントはクライアントIDを使用してサーバーへの接続にcreate_sessionを送信します。CREATE_SESSIONの結果は、再起動したサーバーを介してサーバーがセッション応答キャッシュを永続的に保持し、クライアントは将来の参照のためにこれを上げているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If the client specified SP4_SSV state protection when the client ID was created, then it SHOULD send SET_SSV in the first COMPOUND after the session is created. Each time a new principal goes to use the client ID, it SHOULD send a SET_SSV again.",
      "ja": "クライアントIDが作成されたときにクライアントがSP4_SSV状態保護を保護した場合は、セッションが作成された後に最初の化合物にset_ssvを送信する必要があります。新しいプリンシパルがクライアントIDを使用するたびに、もう一度SET_SSVを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client wants to use delegations, layouts, directory notifications, or any other state that requires a backchannel, then it needs to add a connection to the backchannel if CREATE_SESSION did not already do so. The client creates a connection, and calls BIND_CONN_TO_SESSION to associate the connection with the session and the session's backchannel. If CREATE_SESSION did not already do so, the client MUST tell the server what security is required in order for the client to accept callbacks. The client does this via BACKCHANNEL_CTL. If the client selected SP4_MACH_CRED or SP4_SSV protection when it called EXCHANGE_ID, then the client SHOULD specify that the backchannel use RPCSEC_GSS contexts for security.",
      "ja": "クライアントが代表団、レイアウト、ディレクトリ通知、またはバックチャネルを必要とするその他の状態を使用したい場合は、CREATE_SESSIONがまだそうしていない場合は、BackChannelへの接続を追加する必要があります。クライアントは接続を作成し、その接続をセッションとセッションのバックチャネルと関連付けるためにbind_conn_to_sessionを呼び出します。CREATE_SESSIONがまだ行っていない場合、クライアントがコールバックを受け入れるためにクライアントはサーバーにどのセキュリティが必要なのかを指示する必要があります。クライアントはbackchannel_ctlを介してこれを行います。クライアントがExchange_IDと呼ばれたときにSP4_MACH_CREDまたはSP4_SSV保護を選択した場合、クライアントはバックチャネルがセキュリティのためにRPCSEC_GSSコンテキストを使用するように指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client wants to use additional connections for the backchannel, then it needs to call BIND_CONN_TO_SESSION on each connection it wants to use with the session. If the client wants to use additional connections for the fore channel, then it needs to call BIND_CONN_TO_SESSION if it specified SP4_SSV or SP4_MACH_CRED state protection when the client ID was created.",
      "ja": "クライアントがBackChannelに追加の接続を使用したい場合は、セッションで使用する必要がある接続ごとにBIND_CONN_TO_SESSIONを呼び出す必要があります。クライアントがFore Channelに追加の接続を使用したい場合は、クライアントIDが作成されたときにSP4_SSVまたはSP4_MACH_CRED状態保護を指定した場合、BIND_CONN_TO_SESSISTを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "At this point, the session has reached steady state.",
      "ja": "この時点で、セッションは定常状態に達しました。"
    },
    {
      "indent": 0,
      "text": "2.10.12. Session Inactivity Timer",
      "section_title": true,
      "ja": "2.10.12. セッション非アクティブタイマー"
    },
    {
      "indent": 3,
      "text": "The server MAY maintain a session inactivity timer for each session. If the session inactivity timer expires, then the server MAY destroy the session. To avoid losing a session due to inactivity, the client MUST renew the session inactivity timer. The length of session inactivity timer MUST NOT be less than the lease_time attribute (Section 5.8.1.11). As with lease renewal (Section 8.3), when the server receives a SEQUENCE operation, it resets the session inactivity timer, and MUST NOT allow the timer to expire while the rest of the operations in the COMPOUND procedure's request are still executing. Once the last operation has finished, the server MUST set the session inactivity timer to expire no sooner than the sum of the current time and the value of the lease_time attribute.",
      "ja": "サーバーは、セッションごとにセッション非アクティモタイマーを維持できます。セッション非アクティブタイマーが期限切れになると、サーバーはセッションを破壊する可能性があります。非アクティブのためにセッションを失うことを避けるために、クライアントはセッション非アクティブタイマーを更新する必要があります。セッション非アクティブタイマーの長さは、LEASE_TIME属性よりも小さくなければならない（セクション5.8.1.11）。リース更新と同様に、サーバーがシーケンス操作を受信すると、セッションの非アクティブタイマーをリセットし、複合プロシージャの要求の残りの操作が実行されている間にタイマーが期限切れになることを許可してはなりません。最後の操作が終了したら、サーバーは現在時刻の合計とlease_time属性の値の合計よりも早く期限切れになるようにセッション非アクティブタイマーを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13. Session Mechanics - Recovery",
      "section_title": true,
      "ja": "2.10.13. セッションの力学 - 回復"
    },
    {
      "indent": 0,
      "text": "2.10.13.1. Events Requiring Client Action",
      "section_title": true,
      "ja": "2.10.13.1. クライアントアクションを必要とするイベント"
    },
    {
      "indent": 3,
      "text": "The following events require client action to recover.",
      "ja": "次のイベントには、クライアントアクションが回復する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.1. RPCSEC_GSS Context Loss by Callback Path",
      "section_title": true,
      "ja": "2.10.13.1.1. コールバックパスによるRPCSEC_GSSコンテキスト損失"
    },
    {
      "indent": 3,
      "text": "If all RPCSEC_GSS handles granted by the client to the server for callback use have expired, the client MUST establish a new handle via BACKCHANNEL_CTL. The sr_status_flags field of the SEQUENCE results indicates when callback handles are nearly expired, or fully expired (see Section 18.46.3).",
      "ja": "コールバック使用のためにクライアントによって許可されたすべてのRPCSEC_GSSハンドルが期限切れになっている場合、クライアントはbackchannel_ctlを介して新しいハンドルを確立する必要があります。シーケンスの結果のsr_status_flagsフィールドは、コールバックハンドルがほぼ期限切れになっているか完全に期限切れになっているかを示します（セクション18.46.3を参照）。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.2. Connection Loss",
      "section_title": true,
      "ja": "2.10.13.1.2. 接続損失"
    },
    {
      "indent": 3,
      "text": "If the client loses the last connection of the session and wants to retain the session, then it needs to create a new connection, and if, when the client ID was created, BIND_CONN_TO_SESSION was specified in the spo_must_enforce list, the client MUST use BIND_CONN_TO_SESSION to associate the connection with the session.",
      "ja": "クライアントがセッションの最後の接続を失い、セッションを保持したい場合は、新しい接続を作成する必要があります。また、クライアントIDが作成されたときに、bind_conn_to_sessionがspo_must_enforceリストで指定されている場合、クライアントはBIND_CONN_TO_SESSISTを使用する必要があります。セッションとの接続を関連付けます。"
    },
    {
      "indent": 3,
      "text": "If there was a request outstanding at the time of connection loss, then if the client wants to continue to use the session, it MUST retry the request, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the server will recognize the request as a retry if it executed the request prior to disconnect.",
      "ja": "接続損失時に未解決の要求があった場合、クライアントがセッションを使用し続ける場合は、セクション2.10.6.2の説明に従ってリクエストを再試行する必要があります。ロスト接続と同じソースネットワークアドレスまたは同じ宛先ネットワークアドレスとの接続を介してリクエストを再試行する必要はないことに注意してください。再試行中のセッションID、スロットID、およびシーケンスIDが元の要求のリクエストと一致する限り、サーバは切断前に要求を実行した場合、リトライとして要求を認識します。"
    },
    {
      "indent": 3,
      "text": "If the connection that was lost was the last one associated with the backchannel, and the client wants to retain the backchannel and/or prevent revocation of recallable state, the client needs to reconnect, and if it does, it MUST associate the connection to the session and backchannel via BIND_CONN_TO_SESSION. The server SHOULD indicate when it has no callback connection via the sr_status_flags result from SEQUENCE.",
      "ja": "失われた接続がBackChannelに関連付けられていて、クライアントがバックチャネルを保持し、リコール可能な状態の失効を防ぐことを望んでいる場合、クライアントは再接続する必要があります。そうすれば、その接続を関連付ける必要があります。bind_conn_to_sessionを介したセッションとバックチャネル。サーバーは、SR_STATUS_FLAGSを介したコールバック接続がシーケンスから発生しない場合に指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.3. Backchannel GSS Context Loss",
      "section_title": true,
      "ja": "2.10.13.1.3. BackChannel GSSのコンテキストの損失"
    },
    {
      "indent": 3,
      "text": "Via the sr_status_flags result of the SEQUENCE operation or other means, the client will learn if some or all of the RPCSEC_GSS contexts it assigned to the backchannel have been lost. If the client wants to retain the backchannel and/or not put recallable state subject to revocation, the client needs to use BACKCHANNEL_CTL to assign new contexts.",
      "ja": "シーケンス操作または他の手段のSR_STATUS_FLAGSの結果を介して、クライアントはバックチャネルに割り当てられたRPCSEC_GSSコンテキストの一部または全部が失われた場合に学習されます。クライアントがバックチャネルを保持したり、リコール可能な状態を失効したりしない場合、クライアントはBackChannel_CTLを使用して新しいコンテキストを割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.4. Loss of Session",
      "section_title": true,
      "ja": "2.10.13.1.4. セッションの損失"
    },
    {
      "indent": 3,
      "text": "The replier might lose a record of the session. Causes include:",
      "ja": "絞り目はセッションの記録を失う可能性があります。原因は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Replier failure and restart.",
      "ja": "* リプライアの障害と再起動"
    },
    {
      "indent": 3,
      "text": "* A catastrophe that causes the reply cache to be corrupted or lost on the media on which it was stored. This applies even if the replier indicated in the CREATE_SESSION results that it would persist the cache.",
      "ja": "* それが保存されたメディアで応答キャッシュを破損または失われるようにする大惨事。これは、CREATE_SESSIONに示されているレプリアがキャッシュを永続化した場合にも適用されます。"
    },
    {
      "indent": 3,
      "text": "* The server purges the session of a client that has been inactive for a very extended period of time.",
      "ja": "* サーバーは、非常に長い期間非アクティブであるクライアントのセッションを消去します。"
    },
    {
      "indent": 3,
      "text": "* As a result of configuration changes among a set of clustered servers, a network address previously connected to one server becomes connected to a different server that has no knowledge of the session in question. Such a configuration change will generally only happen when the original server ceases to function for a time.",
      "ja": "* 一組のクラスタサーバ間の構成変更の結果として、1つのサーバに以前に接続されているネットワークアドレスが、問題のセッションに関する知識を持たない異なるサーバに接続される。そのような構成変更は、一般に、元のサーバが一度に機能しなくなるとしか起こりません。"
    },
    {
      "indent": 3,
      "text": "Loss of reply cache is equivalent to loss of session. The replier indicates loss of session to the requester by returning NFS4ERR_BADSESSION on the next operation that uses the session ID that refers to the lost session.",
      "ja": "返信キャッシュの損失はセッションの損失に相当します。replierは、失われたセッションを参照するセッションIDを使用する次の操作でNFS4ERR_BAdessionを返すことによって、リクエスターへのセッションの損失を示します。"
    },
    {
      "indent": 3,
      "text": "After an event like a server restart, the client may have lost its connections. The client assumes for the moment that the session has not been lost. It reconnects, and if it specified connection association enforcement when the session was created, it invokes BIND_CONN_TO_SESSION using the session ID. Otherwise, it invokes SEQUENCE. If BIND_CONN_TO_SESSION or SEQUENCE returns NFS4ERR_BADSESSION, the client knows the session is not available to it when communicating with that network address. If the connection survives session loss, then the next SEQUENCE operation the client sends over the connection will get back NFS4ERR_BADSESSION. The client again knows the session was lost.",
      "ja": "サーバーの再起動のようなイベントの後、クライアントはその接続を失った可能性があります。クライアントは、セッションが失われていない瞬間を想定しています。セッションが作成されたときに接続アソシエーションの強制を再接続し、それはセッションIDを使用してbind_conn_to_sessionを呼び出します。それ以外の場合は、シーケンスを呼び出します。bind_conn_to_sessionまたはsequenceがNFS4ERR_BADSESSIONを返す場合、クライアントはそのネットワークアドレスと通信するときにセッションが使用できないことを知っています。接続がセッション損失を生き残った場合、クライアントが接続を送信する次のシーケンス操作は、NFS4ERR_BADSessionを返します。クライアントは、セッションが失われたことをもう一度知っています。"
    },
    {
      "indent": 3,
      "text": "Here is one suggested algorithm for the client when it gets NFS4ERR_BADSESSION. It is not obligatory in that, if a client does not want to take advantage of such features as trunking, it may omit parts of it. However, it is a useful example that draws attention to various possible recovery issues:",
      "ja": "これがNFS4ERR_BADSESSIONになるとクライアントの1つの推奨アルゴリズムです。クライアントがトランキングとしてそのような機能を利用したくない場合は、必須ではありませんが、その一部を省略することがあります。ただし、さまざまな回復の問題に注意を引くのに便利な例です。"
    },
    {
      "indent": 3,
      "text": "1. If the client has other connections to other server network addresses associated with the same session, attempt a COMPOUND with a single operation, SEQUENCE, on each of the other connections.",
      "ja": "1. クライアントが同じセッションに関連付けられている他のサーバーネットワークアドレスへの他の接続を持っている場合は、他の各接続で単一の操作、シーケンスを持つ複合を試みます。"
    },
    {
      "indent": 3,
      "text": "2. If the attempts succeed, the session is still alive, and this is a strong indicator that the server's network address has moved. The client might send an EXCHANGE_ID on the connection that returned NFS4ERR_BADSESSION to see if there are opportunities for client ID trunking (i.e., the same client ID and so_major_id value are returned). The client might use DNS to see if the moved network address was replaced with another, so that the performance and availability benefits of session trunking can continue.",
      "ja": "2. 試行が成功した場合、セッションはまだ生きていますが、これはサーバーのネットワークアドレスが移動した強力なインジケータです。クライアントは、クライアントIDのトランキングの機会があるかどうかを確認するためにNFS4ERR_BADSessionを返す接続にExchange_idを送信することができます（すなわち、同じクライアントIDとSO_MAJOR_ID値が返される）。クライアントはDNSを使用して、移動したネットワークアドレスが別のネットワークアドレスに置き換えられたかどうかを確認することができ、セッションのトランキングのパフォーマンスと可用性の利点が続くことができます。"
    },
    {
      "indent": 3,
      "text": "3. If the SEQUENCE requests fail with NFS4ERR_BADSESSION, then the session no longer exists on any of the server network addresses for which the client has connections associated with that session ID. It is possible the session is still alive and available on other network addresses. The client sends an EXCHANGE_ID on all the connections to see if the server owner is still listening on those network addresses. If the same server owner is returned but a new client ID is returned, this is a strong indicator of a server restart. If both the same server owner and same client ID are returned, then this is a strong indication that the server did delete the session, and the client will need to send a CREATE_SESSION if it has no other sessions for that client ID. If a different server owner is returned, the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a \"mount\" paradigm, unmounting the server is advised.",
      "ja": "3. シーケンス要求がNFS4ERR_BADSessionで失敗した場合、そのセッションIDに関連付けられている接続が関連付けられているサーバーネットワークアドレスのいずれかにセッションが存在しなくなりました。セッションがまだ生きていて他のネットワークアドレスで利用可能である可能性があります。クライアントは、サーバーの所有者がそれらのネットワークアドレスを依然として待機しているかどうかを確認するために、すべての接続でExchange_idを送信します。同じサーバーの所有者が返されたが新しいクライアントIDが返された場合、これはサーバーの再起動の強力なインジケータです。同じサーバーの所有者と同じクライアントIDの両方が返された場合、これはサーバーがセッションを削除したという強力な表示であり、クライアントはそのクライアントIDのセッションが他にある場合はcreate_sessionを送信する必要があります。別のサーバーの所有者が返された場合、クライアントはDNSを使用して他のネットワークアドレスを見つけることができます。そうでない場合、またはDNSがサーバーの他のアドレスが見つからない場合、クライアントはNFSV4.1サービスを提供できなくなり、致命的なエラーはサーバーを使用していたプロセスに返されるべきです。クライアントが「マウント」パラダイムを使用している場合は、サーバーをマウント解除します。"
    },
    {
      "indent": 3,
      "text": "4. If the client knows of no other connections associated with the session ID and server network addresses that are, or have been, associated with the session ID, then the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a \"mount\" paradigm, unmounting the server is advised.",
      "ja": "4. クライアントがセッションIDとサーバーネットワークアドレスと関連付けられている、またはセッションIDに関連付けられている他の接続を知っていない場合、クライアントはDNSを使用して他のネットワークアドレスを見つけることができます。そうでない場合、またはDNSがサーバーの他のアドレスが見つからない場合、クライアントはNFSV4.1サービスを提供できなくなり、致命的なエラーはサーバーを使用していたプロセスに返されるべきです。クライアントが「マウント」パラダイムを使用している場合は、サーバーをマウント解除します。"
    },
    {
      "indent": 3,
      "text": "If there is a reconfiguration event that results in the same network address being assigned to servers where the eir_server_scope value is different, it cannot be guaranteed that a session ID generated by the first will be recognized as invalid by the first. Therefore, in managing server reconfigurations among servers with different server scope values, it is necessary to make sure that all clients have disconnected from the first server before effecting the reconfiguration. Nonetheless, clients should not assume that servers will always adhere to this requirement; clients MUST be prepared to deal with unexpected effects of server reconfigurations. Even where a session ID is inappropriately recognized as valid, it is likely either that the connection will not be recognized as valid or that a sequence value for a slot will not be correct. Therefore, when a client receives results indicating such unexpected errors, the use of EXCHANGE_ID to determine the current server configuration is RECOMMENDED.",
      "ja": "EIR_SERVER_SCOPE値が異なるサーバに同じネットワークアドレスが割り当てられている再構成イベントがある場合は、最初に生成されたセッションIDが最初に無効として認識されることを保証することはできません。したがって、サーバースコープ値が異なるサーバー間のサーバーの再構成を管理する場合は、再構成を実行する前に、すべてのクライアントが最初のサーバーから切断されていることを確認する必要があります。それにもかかわらず、クライアントはサーバーが常にこの要件を遵守すると仮定しないでください。クライアントは、サーバーの再構成の予期しない影響を及ぼす準備ができている必要があります。セッションIDが有効に不適切に認識されている場合でも、接続が有効であると認識されないこと、またはスロットのシーケンス値が正しくないことのいずれかである。したがって、クライアントがそのような予期せぬエラーを示す結果を受け取ると、現在のサーバ構成を決定するためのExchange_IDの使用をお勧めします。"
    },
    {
      "indent": 3,
      "text": "A variation on the above is that after a server's network address moves, there is no NFSv4.1 server listening, e.g., no listener on port 2049. In this example, one of the following occur: the NFSv4 server returns NFS4ERR_MINOR_VERS_MISMATCH, the NFS server returns a PROG_MISMATCH error, the RPC listener on 2049 returns PROG_UNVAIL, or attempts to reconnect to the network address timeout. These SHOULD be treated as equivalent to SEQUENCE returning NFS4ERR_BADSESSION for these purposes.",
      "ja": "上記の変形例は、サーバのネットワークアドレスが移動した後、NFSV4.1サーバがリスニングされず、例えば、ポート2049にリスナーなしでリスナーが表示されないことがわかります。この例では、次のいずれかが発生します.NFSv4サーバは、NFS4ER_MINOR_VERS_MISMATCH、NFSサーバを返します。prog_mismatchエラーを返し、2049のRPCリスナーはPROG_UNVAILを返し、ネットワークアドレスタイムアウトへの再接続を試みます。これらは、これらの目的のためにNFS4ERR_BAdessionを返す配列と同等のものとして扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "When the client detects session loss, it needs to call CREATE_SESSION to recover. Any non-idempotent operations that were in progress might have been performed on the server at the time of session loss. The client has no general way to recover from this.",
      "ja": "クライアントがセッション損失を検出すると、CREATE_SESSIONを回復する必要があります。セッションの損失時に、進行中の非冪等操作がサーバー上で実行された可能性があります。クライアントはこれから回復する一般的な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Note that loss of session does not imply loss of byte-range lock, open, delegation, or layout state because locks, opens, delegations, and layouts are tied to the client ID and depend on the client ID, not the session. Nor does loss of byte-range lock, open, delegation, or layout state imply loss of session state, because the session depends on the client ID; loss of client ID however does imply loss of session, byte-range lock, open, delegation, and layout state. See Section 8.4.2. A session can survive a server restart, but lock recovery may still be needed.",
      "ja": "ロック、オープン、代表団、およびレイアウトがクライアントIDに関連付けられており、セッションではなくクライアントIDに依存しているため、セッションの損失はバイトレンジロック、オープン、委任、またはレイアウト状態の損失を意味しません。セッションはクライアントIDによって異なるため、バイトレンジロック、オープン、委任、またはレイアウト状態の損失も、セッション状態の損失を意味します。ただし、クライアントIDの損失は、セッション、バイトレンジロック、オープン、委任、およびレイアウト状態の損失を意味します。8.4.2節を参照してください。セッションはサーバーの再起動を生き残ることができますが、ロックリカバリが必要になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "It is possible that CREATE_SESSION will fail with NFS4ERR_STALE_CLIENTID (e.g., the server restarts and does not preserve client ID state). If so, the client needs to call EXCHANGE_ID, followed by CREATE_SESSION.",
      "ja": "CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗する可能性があります（たとえば、サーバーはクライアントID状態を再起動し、保存しません）。もしそうなら、クライアントはExchange_idを呼び出してcreate_sessionを呼び出します。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2. Events Requiring Server Action",
      "section_title": true,
      "ja": "2.10.13.2. サーバーアクションを必要とするイベント"
    },
    {
      "indent": 3,
      "text": "The following events require server action to recover.",
      "ja": "次のイベントには、サーバーアクションが回復する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.1. Client Crash and Restart",
      "section_title": true,
      "ja": "2.10.13.2.1. クライアントがクラッシュして再起動します"
    },
    {
      "indent": 3,
      "text": "As described in Section 18.35, a restarted client sends EXCHANGE_ID in such a way that it causes the server to delete any sessions it had.",
      "ja": "セクション18.35で説明されているように、再起動したクライアントは、サーバーに持っていたセッションを削除するようにExchange_IDを送信します。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.2. Client Crash with No Restart",
      "section_title": true,
      "ja": "2.10.13.2.2. 再起動なしのクライアントクラッシュ"
    },
    {
      "indent": 3,
      "text": "If a client crashes and never comes back, it will never send EXCHANGE_ID with its old client owner. Thus, the server has session state that will never be used again. After an extended period of time, and if the server has resource constraints, it MAY destroy the old session as well as locking state.",
      "ja": "クライアントがクラッシュして戻ってきたことがない場合、それは古いクライアント所有者とExchange_idを送信することはありません。したがって、サーバーはセッション状態になります。長期間にわたって、サーバーがリソース制約を持っている場合、ロック状態だけでなく古いセッションも破棄される可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.3. Extended Network Partition",
      "section_title": true,
      "ja": "2.10.13.2.3. 拡張ネットワークパーティション"
    },
    {
      "indent": 3,
      "text": "To the server, the extended network partition may be no different from a client crash with no restart (see Section 2.10.13.2.2). Unless the server can discern that there is a network partition, it is free to treat the situation as if the client has crashed permanently.",
      "ja": "サーバーに、拡張ネットワークパーティションは再起動なしでクライアントクラッシュと変わらない可能性があります（セクション2.10.13.2.2を参照）。サーバーがネットワークパーティションがあることを見分けることができない限り、クライアントが永久にクラッシュしたかのように状況を自由に扱うことは自由です。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.4. Backchannel Connection Loss",
      "section_title": true,
      "ja": "2.10.13.2.4. バックチャンネル接続損失"
    },
    {
      "indent": 3,
      "text": "If there were callback requests outstanding at the time of a connection loss, then the server MUST retry the requests, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the callback target will recognize the request as a retry even if it did see the request prior to disconnect.",
      "ja": "接続損失時にカーリングバック要求が発生した場合、セクション2.10.6.2で説明されているように、サーバーは要求を再試行する必要があります。ロスト接続と同じソースネットワークアドレスまたは同じ宛先ネットワークアドレスとの接続を介してリクエストを再試行する必要はないことに注意してください。セッションID、スロットID、および再試行のスロットID、およびシーケンスIDが元の要求の要求と一致すると、コールバックターゲットは、切断前の要求が表示されていてもリトークとして要求を認識します。"
    },
    {
      "indent": 3,
      "text": "If the connection lost is the last one associated with the backchannel, then the server MUST indicate that in the sr_status_flags field of every SEQUENCE reply until the backchannel is re-established. There are two situations, each of which uses different status flags: no connectivity for the session's backchannel and no connectivity for any session backchannel of the client. See Section 18.46 for a description of the appropriate flags in sr_status_flags.",
      "ja": "接続がBackChannelに関連付けられている最後のものが失われた場合、サーバーはバックチャネルが再確立されるまですべてのシーケンス応答のSR_STATUS_FLAGSフィールドにそれを示す必要があります。それぞれが異なるステータスフラグを使用している2つの状況があります。セッションのBackChannelの接続はありません。クライアントのセッションバックチャンネルの接続はありません。SR_STATUS_FLAGSの適切なフラグの説明については、セクション18.46を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.5. GSS Context Loss",
      "section_title": true,
      "ja": "2.10.13.2.5. GSSのコンテキスト損失"
    },
    {
      "indent": 3,
      "text": "The server SHOULD monitor when the number of RPCSEC_GSS handles assigned to the backchannel reaches one, and when that one handle is near expiry (i.e., between one and two periods of lease time), and indicate so in the sr_status_flags field of all SEQUENCE replies. The server MUST indicate when all of the backchannel's assigned RPCSEC_GSS handles have expired via the sr_status_flags field of all SEQUENCE replies.",
      "ja": "バックチャネルに割り当てられているRPCSEC_GSSハンドルの数が1つに到達し、その1つのハンドルが有効期限に近い場合（すなわち、リース時間の1~2周期の間の）rpcsec_gssハンドルの数が監視され、すべてのシーケンスのsr_status_flagsフィールドにSOを示す必要があります。サーバーは、すべてのシーケンス応答のSR_STATUS_FLAGSフィールドを介して、バックチャネルの割り当てられたRPCSEC_GSSハンドルがすべて期限切れになっていることを示す必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.14. Parallel NFS and Sessions",
      "section_title": true,
      "ja": "2.10.14. 並列NFSとセッション"
    },
    {
      "indent": 3,
      "text": "A client and server can potentially be a non-pNFS implementation, a metadata server implementation, a data server implementation, or two or three types of implementations. The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS flags (not mutually exclusive) are passed in the EXCHANGE_ID arguments and results to allow the client to indicate how it wants to use sessions created under the client ID, and to allow the server to indicate how it will allow the sessions to be used. See Section 13.1 for pNFS sessions considerations.",
      "ja": "クライアントとサーバーは、非PNFS実装、メタデータサーバーの実装、データサーバーの実装、または2つまたは3種類の実装である可能性があります。EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DSフラグ（相互に排他的ではない）は、Exchange_IDの引数に渡され、結果はクライアントIDの下に作成されたセッションを使用したいか、およびサーバーが許可する方法を示すことを可能にします。使用されるセッション。PNFSセッションに関する考慮事項については、セクション13.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Constants and Data Types",
      "section_title": true,
      "ja": "3. プロトコル定数とデータ型"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics to describe the data types of the NFSv4.1 protocol are defined in the XDR (RFC 4506 [2]) and RPC (RFC 5531 [3]) documents. The next sections build upon the XDR data types to define constants, types, and structures specific to this protocol. The full list of XDR data types is in [10].",
      "ja": "NFSV4.1プロトコルのデータ型を記述するための構文とセマンティクスは、XDR（RFC 4506 [2]）とRPC（RFC 5531 [3]）の文書で定義されています。次のセクションは、このプロトコルに固有の定数、型、および構造を定義するためにXDRデータ型の上に構築されます。XDRデータ型の全リストは[10]にあります。"
    },
    {
      "indent": 0,
      "text": "3.1. Basic Constants",
      "section_title": true,
      "ja": "3.1. 基本定数"
    },
    {
      "indent": 3,
      "text": "const NFS4_FHSIZE               = 128;\nconst NFS4_VERIFIER_SIZE        = 8;\nconst NFS4_OPAQUE_LIMIT         = 1024;\nconst NFS4_SESSIONID_SIZE       = 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const NFS4_INT64_MAX            = 0x7fffffffffffffff;\nconst NFS4_UINT64_MAX           = 0xffffffffffffffff;\nconst NFS4_INT32_MAX            = 0x7fffffff;\nconst NFS4_UINT32_MAX           = 0xffffffff;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const NFS4_MAXFILELEN           = 0xffffffffffffffff;\nconst NFS4_MAXFILEOFF           = 0xfffffffffffffffe;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Except where noted, all these constants are defined in bytes.",
      "ja": "注目されている場合を除き、これらすべての定数はバイト単位で定義されています。"
    },
    {
      "indent": 3,
      "text": "* NFS4_FHSIZE is the maximum size of a filehandle.",
      "ja": "* NFS4_FHSIZEはファイルハンドルの最大サイズです。"
    },
    {
      "indent": 3,
      "text": "* NFS4_VERIFIER_SIZE is the fixed size of a verifier.",
      "ja": "* NFS4_VERIFIER_SIZEは、検証者の固定サイズです。"
    },
    {
      "indent": 3,
      "text": "* NFS4_OPAQUE_LIMIT is the maximum size of certain opaque information.",
      "ja": "* NFS4_OPAQUE_LIMITは、特定の不透明情報の最大サイズです。"
    },
    {
      "indent": 3,
      "text": "* NFS4_SESSIONID_SIZE is the fixed size of a session identifier.",
      "ja": "* NFS4_SESSIONID_SIZEはセッション識別子の固定サイズです。"
    },
    {
      "indent": 3,
      "text": "* NFS4_INT64_MAX is the maximum value of a signed 64-bit integer.",
      "ja": "* NFS4_INT64_MAXは符号付き64ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "* NFS4_UINT64_MAX is the maximum value of an unsigned 64-bit integer.",
      "ja": "* NFS4_UINT64_MAXは、符号なし64ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "* NFS4_INT32_MAX is the maximum value of a signed 32-bit integer.",
      "ja": "* NFS4_INT32_MAXは符号付き32ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "* NFS4_UINT32_MAX is the maximum value of an unsigned 32-bit integer.",
      "ja": "* NFS4_UINT32_MAXは、符号なし32ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "* NFS4_MAXFILELEN is the maximum length of a regular file.",
      "ja": "* NFS4_MAXFILELENは、通常のファイルの最大長です。"
    },
    {
      "indent": 3,
      "text": "* NFS4_MAXFILEOFF is the maximum offset into a regular file.",
      "ja": "* NFS4_MAXFILEOFFは、通常のファイルへの最大オフセットです。"
    },
    {
      "indent": 0,
      "text": "3.2. Basic Data Types",
      "section_title": true,
      "ja": "3.2. 基本データ型"
    },
    {
      "indent": 3,
      "text": "These are the base NFSv4.1 data types.",
      "ja": "これらは基本NFSV4.1データ型です。"
    },
    {
      "indent": 5,
      "text": "+===============+==============================================+\n| Data Type     | Definition                                   |\n+===============+==============================================+\n| int32_t       | typedef int int32_t;                         |\n+---------------+----------------------------------------------+\n| uint32_t      | typedef unsigned int uint32_t;               |\n+---------------+----------------------------------------------+\n| int64_t       | typedef hyper int64_t;                       |\n+---------------+----------------------------------------------+\n| uint64_t      | typedef unsigned hyper uint64_t;             |\n+---------------+----------------------------------------------+\n| attrlist4     | typedef opaque attrlist4<>;                  |\n|               |                                              |\n|               | Used for file/directory attributes.          |\n+---------------+----------------------------------------------+\n| bitmap4       | typedef uint32_t bitmap4<>;                  |\n|               |                                              |\n|               | Used in attribute array encoding.            |\n+---------------+----------------------------------------------+\n| changeid4     | typedef uint64_t changeid4;                  |\n|               |                                              |\n|               | Used in the definition of change_info4.      |\n+---------------+----------------------------------------------+\n| clientid4     | typedef uint64_t clientid4;                  |\n|               |                                              |\n|               | Shorthand reference to client                |\n|               | identification.                              |\n+---------------+----------------------------------------------+\n| count4        | typedef uint32_t count4;                     |\n|               |                                              |\n|               | Various count parameters (READ, WRITE,       |\n|               | COMMIT).                                     |\n+---------------+----------------------------------------------+\n| length4       | typedef uint64_t length4;                    |\n|               |                                              |\n|               | The length of a byte-range within a file.    |\n+---------------+----------------------------------------------+\n| mode4         | typedef uint32_t mode4;                      |\n|               |                                              |\n|               | Mode attribute data type.                    |\n+---------------+----------------------------------------------+\n| nfs_cookie4   | typedef uint64_t nfs_cookie4;                |\n|               |                                              |\n|               | Opaque cookie value for READDIR.             |\n+---------------+----------------------------------------------+\n| nfs_fh4       | typedef opaque nfs_fh4<NFS4_FHSIZE>;         |\n|               |                                              |\n|               | Filehandle definition.                       |\n+---------------+----------------------------------------------+\n| nfs_ftype4    | enum nfs_ftype4;                             |\n|               |                                              |\n|               | Various defined file types.                  |\n+---------------+----------------------------------------------+\n| nfsstat4      | enum nfsstat4;                               |\n|               |                                              |\n|               | Return value for operations.                 |\n+---------------+----------------------------------------------+\n| offset4       | typedef uint64_t offset4;                    |\n|               |                                              |\n|               | Various offset designations (READ, WRITE,    |\n|               | LOCK, COMMIT).                               |\n+---------------+----------------------------------------------+\n| qop4          | typedef uint32_t qop4;                       |\n|               |                                              |\n|               | Quality of protection designation in         |\n|               | SECINFO.                                     |\n+---------------+----------------------------------------------+\n| sec_oid4      | typedef opaque sec_oid4<>;                   |\n|               |                                              |\n|               | Security Object Identifier.  The sec_oid4    |\n|               | data type is not really opaque.  Instead, it |\n|               | contains an ASN.1 OBJECT IDENTIFIER as used  |\n|               | by GSS-API in the mech_type argument to      |\n|               | GSS_Init_sec_context.  See [7] for details.  |\n+---------------+----------------------------------------------+\n| sequenceid4   | typedef uint32_t sequenceid4;                |\n|               |                                              |\n|               | Sequence number used for various session     |\n|               | operations (EXCHANGE_ID, CREATE_SESSION,     |\n|               | SEQUENCE, CB_SEQUENCE).                      |\n+---------------+----------------------------------------------+\n| seqid4        | typedef uint32_t seqid4;                     |\n|               |                                              |\n|               | Sequence identifier used for locking.        |\n+---------------+----------------------------------------------+\n| sessionid4    | typedef opaque                               |\n|               | sessionid4[NFS4_SESSIONID_SIZE];             |\n|               |                                              |\n|               | Session identifier.                          |\n+---------------+----------------------------------------------+\n| slotid4       | typedef uint32_t slotid4;                    |\n|               |                                              |\n|               | Sequencing artifact for various session      |\n|               | operations (SEQUENCE, CB_SEQUENCE).          |\n+---------------+----------------------------------------------+\n| utf8string    | typedef opaque utf8string<>;                 |\n|               |                                              |\n|               | UTF-8 encoding for strings.                  |\n+---------------+----------------------------------------------+\n| utf8str_cis   | typedef utf8string utf8str_cis;              |\n|               |                                              |\n|               | Case-insensitive UTF-8 string.               |\n+---------------+----------------------------------------------+\n| utf8str_cs    | typedef utf8string utf8str_cs;               |\n|               |                                              |\n|               | Case-sensitive UTF-8 string.                 |\n+---------------+----------------------------------------------+\n| utf8str_mixed | typedef utf8string utf8str_mixed;            |\n|               |                                              |\n|               | UTF-8 strings with a case-sensitive prefix   |\n|               | and a case-insensitive suffix.               |\n+---------------+----------------------------------------------+\n| component4    | typedef utf8str_cs component4;               |\n|               |                                              |\n|               | Represents pathname components.              |\n+---------------+----------------------------------------------+\n| linktext4     | typedef utf8str_cs linktext4;                |\n|               |                                              |\n|               | Symbolic link contents (\"symbolic link\" is   |\n|               | defined in an Open Group [Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\"\">11] standard).     |\n+---------------+----------------------------------------------+\n| pathname4     | typedef component4 pathname4<>;              |\n|               |                                              |\n|               | Represents pathname for fs_locations.        |\n+---------------+----------------------------------------------+\n| verifier4     | typedef opaque                               |\n|               | verifier4[NFS4_VERIFIER_SIZE];               |\n|               |                                              |\n|               | Verifier used for various operations         |\n|               | (COMMIT, CREATE, EXCHANGE_ID, OPEN, READDIR, |\n|               | WRITE) NFS4_VERIFIER_SIZE is defined as 8.   |\n+---------------+----------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "End of Base Data Types",
      "ja": "基本データ型の終わり"
    },
    {
      "indent": 0,
      "text": "3.3. Structured Data Types",
      "section_title": true,
      "ja": "3.3. 構造化データ型"
    },
    {
      "indent": 0,
      "text": "3.3.1. nfstime4",
      "section_title": true,
      "ja": "3.3.1. nfstime4"
    },
    {
      "indent": 3,
      "text": "struct nfstime4 {\n        int64_t         seconds;\n        uint32_t        nseconds;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The nfstime4 data type gives the number of seconds and nanoseconds since midnight or zero hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the zero hour January 1, 1970. Values less than zero for the seconds field denote dates before the zero hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before zero hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds field would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are invalid.",
      "ja": "NFSTIME4データ・タイプは、1970年1月1日、1970年1月1日に協定されたユニバーサル・タイム（UTC）で秒数とナノ秒数を与えます。秒フィールドのゼロよりも大きい値は、1970年1月1日ゼロ時間以降の日付を示します。秒フィールドのゼロよりも小さい値は、1970年1月1日ゼロの前の日付を示します。両方の場合では、NSECONDSフィールドを追加します。最終時間表現の秒フィールド。たとえば、1970年1月1日ゼロ時間の前に表す時間が1/2秒である場合、秒フィールドは負の値（-1）の値を持ち、NSecondsフィールドには半秒の値があります（500000000）。nsecondsの999,999,999より大きい値は無効です。"
    },
    {
      "indent": 3,
      "text": "This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is RECOMMENDED to reduce client and server time skew.",
      "ja": "このデータ型は、時間と日付情報を渡すために使用されます。サーバーは、時間の値を処理するときのそのローカル表現との間で、できるだけ多くの精度を保持します。ファイルシステムオブジェクトに格納されているタイムスタンプの精度が定義されていない場合は、精度の損失が発生する可能性があります。クライアントとサーバーの時間のスキューを減らすには、ADJUNCT TIMEメンテナンスプロトコルを推奨します。"
    },
    {
      "indent": 0,
      "text": "3.3.2. time_how4",
      "section_title": true,
      "ja": "3.3.2. time_how4."
    },
    {
      "indent": 3,
      "text": "enum time_how4 {\n        SET_TO_SERVER_TIME4 = 0,\n        SET_TO_CLIENT_TIME4 = 1\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.3. settime4",
      "section_title": true,
      "ja": "3.3.3. settime4"
    },
    {
      "indent": 3,
      "text": "union settime4 switch (time_how4 set_it) {\n case SET_TO_CLIENT_TIME4:\n         nfstime4       time;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The time_how4 and settime4 data types are used for setting timestamps in file object attributes. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.",
      "ja": "time_how4およびsetTime4データ型は、ファイルオブジェクト属性のタイムスタンプを設定するために使用されます。set_itがset_to_server_time4の場合、サーバーはそのローカルの時間の時間の時間表現を使用します。"
    },
    {
      "indent": 0,
      "text": "3.3.4. specdata4",
      "section_title": true,
      "ja": "3.3.4. SpecData4"
    },
    {
      "indent": 3,
      "text": "struct specdata4 {\n uint32_t specdata1; /* major device number */\n uint32_t specdata2; /* minor device number */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type represents the device numbers for the device file types NF4CHR and NF4BLK.",
      "ja": "このデータ型は、デバイスファイルタイプNF4CHRとNF4BLKのデバイス番号を表します。"
    },
    {
      "indent": 0,
      "text": "3.3.5. fsid4",
      "section_title": true,
      "ja": "3.3.5. FSID4"
    },
    {
      "indent": 3,
      "text": "struct fsid4 {\n        uint64_t        major;\n        uint64_t        minor;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.6. change_policy4",
      "section_title": true,
      "ja": "3.3.6. change_policy4"
    },
    {
      "indent": 3,
      "text": "struct change_policy4 {\n        uint64_t        cp_major;\n        uint64_t        cp_minor;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The change_policy4 data type is used for the change_policy RECOMMENDED attribute. It provides change sequencing indication analogous to the change attribute. To enable the server to present a value valid across server re-initialization without requiring persistent storage, two 64-bit quantities are used, allowing one to be a server instance ID and the second to be incremented non-persistently, within a given server instance.",
      "ja": "change_policy4データ型は、change_policy推奨属性に使用されます。変更属性に類似した変更シーケンス表示を提供します。サーバーが永続的な記憶域を必要とせずにサーバーの再初期化にわたって有効な値を有効にするために、2つの64ビット数量が使用され、特定のサーバーインスタンス内でサーバーインスタンスIDと2番目のインクリメントされることができます。。"
    },
    {
      "indent": 0,
      "text": "3.3.7. fattr4",
      "section_title": true,
      "ja": "3.3.7. Fattr4"
    },
    {
      "indent": 3,
      "text": "struct fattr4 {\n        bitmap4         attrmask;\n        attrlist4       attr_vals;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fattr4 data type is used to represent file and directory attributes.",
      "ja": "FATTR4データ型は、ファイルとディレクトリの属性を表すために使用されます。"
    },
    {
      "indent": 3,
      "text": "The bitmap is a counted array of 32-bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32), and its bit within that integer is (n mod 32).",
      "ja": "ビットマップは、ビット値を含むために使用される32ビット整数のカウントされた配列です。ビットNを含むアレイ内の整数の位置は、式（N / 32）から計算することができ、その整数内のそのビットは（n mod 32）である。"
    },
    {
      "indent": 3,
      "text": "                  0            1\n+-----------+-----------+-----------+--\n|  count    | 31  ..  0 | 63  .. 32 |\n+-----------+-----------+-----------+--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.8. change_info4",
      "section_title": true,
      "ja": "3.3.8. change_info4."
    },
    {
      "indent": 3,
      "text": "struct change_info4 {\n        bool            atomic;\n        changeid4       before;\n        changeid4       after;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type is used with the CREATE, LINK, OPEN, REMOVE, and RENAME operations to let the client know the value of the change attribute for the directory in which the target file system object resides.",
      "ja": "このデータ型は、クライアントにターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値をクライアントに知らせるために、Create、Link、Open、Remove、およびRename Operationsと共に使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.9. netaddr4",
      "section_title": true,
      "ja": "3.3.9. NetAddr4."
    },
    {
      "indent": 3,
      "text": "struct netaddr4 {\n        /* see struct rpcb in RFC 1833 */\n        string na_r_netid<>; /* network id */\n        string na_r_addr<>;  /* universal address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The netaddr4 data type is used to identify network transport endpoints. The na_r_netid and na_r_addr fields respectively contain a netid and uaddr. The netid and uaddr concepts are defined in [12]. The netid and uaddr formats for TCP over IPv4 and TCP over IPv6 are defined in [12], specifically Tables 2 and 3 and in Sections 5.2.3.3 and 5.2.3.4.",
      "ja": "NetAddr4データ型は、ネットワークトランスポートエンドポイントを識別するために使用されます。NA_R_NETIDおよびNA_R_ADDRフィールドはそれぞれNETIDとUADDRを含みます。NETIDおよびUADDRの概念は[12]で定義されています。IPv4 over over IPv6 over over ipv6 over over tcpのNETIDおよびUADDRフォーマットは、[12]、具体的な表2および3およびセクション5.2.3.3および5.2.3.4で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3.10. state_owner4",
      "section_title": true,
      "ja": "3.3.10. State_Owner4"
    },
    {
      "indent": 3,
      "text": "struct state_owner4 {\n        clientid4       clientid;\n        opaque          owner<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef state_owner4 open_owner4;\ntypedef state_owner4 lock_owner4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The state_owner4 data type is the base type for the open_owner4 (Section 3.3.10.1) and lock_owner4 (Section 3.3.10.2).",
      "ja": "STATE_OWNER4データ型は、OPEN_OWNER4（セクション3.3.10.1）およびLOCK_OWNER4（セクション3.3.10.2）の基本タイプです。"
    },
    {
      "indent": 0,
      "text": "3.3.10.1. open_owner4",
      "section_title": true,
      "ja": "3.3.10.1. open_owner4."
    },
    {
      "indent": 3,
      "text": "This data type is used to identify the owner of OPEN state.",
      "ja": "このデータ型は、オープン状態の所有者を識別するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.2. lock_owner4",
      "section_title": true,
      "ja": "3.3.10.2. lock_owner4"
    },
    {
      "indent": 3,
      "text": "This structure is used to identify the owner of byte-range locking state.",
      "ja": "この構造は、バイトレンジロック状態の所有者を識別するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.11. open_to_lock_owner4",
      "section_title": true,
      "ja": "3.3.11. Open_To_Lock_Owner4."
    },
    {
      "indent": 3,
      "text": "struct open_to_lock_owner4 {\n        seqid4          open_seqid;\n        stateid4        open_stateid;\n        seqid4          lock_seqid;\n        lock_owner4     lock_owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner, such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.",
      "ja": "このデータ型は、Open_owner4に対して行われた最初のロック操作に使用されます。遷移が有効なopen_stateIDシーケンスから新しいlock_stateIDシーケンスの遷移を行うように、open_stateIdとlock_ownerの両方を提供します。このメカニズムを使用すると、OPEN_STATEID / OPEN_SEQIDの形式で確立された状態に接続されているため、lock_owner / lock_seqidペアの確認を回避します。"
    },
    {
      "indent": 0,
      "text": "3.3.12. stateid4",
      "section_title": true,
      "ja": "3.3.12. StateID4"
    },
    {
      "indent": 3,
      "text": "struct stateid4 {\n        uint32_t        seqid;\n        opaque          other[12];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type is used for the various state sharing mechanisms between the client and server. The client never modifies a value of data type stateid. The starting value of the \"seqid\" field is undefined. The server is required to increment the \"seqid\" field by one at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.",
      "ja": "このデータ型は、クライアントとサーバー間のさまざまな状態共有メカニズムに使用されます。クライアントはデータ型StateIDの値を変更しません。「seqid」フィールドの開始値は未定義です。サーバーは、StareIDの各遷移時に「SEQID」フィールドを1つずつ増やす必要があります。クライアントがOpen StateIDのSEQIDを検査してサーバーによって行われたオープン処理の順序を判断するため、これは重要です。"
    },
    {
      "indent": 0,
      "text": "3.3.13. layouttype4",
      "section_title": true,
      "ja": "3.3.13. LayoutType4"
    },
    {
      "indent": 3,
      "text": "enum layouttype4 {\n        LAYOUT4_NFSV4_1_FILES   = 0x1,\n        LAYOUT4_OSD2_OBJECTS    = 0x2,\n        LAYOUT4_BLOCK_VOLUME    = 0x3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type indicates what type of layout is being used. The file server advertises the layout types it supports through the fs_layout_type file system attribute (Section 5.12.1). A client asks for layouts of a particular type in LAYOUTGET, and processes those layouts in its layout-type-specific logic.",
      "ja": "このデータ型は、どのタイプのレイアウトが使用されているかを示します。ファイルサーバーは、FS_LAYOUT_TYPEファイルシステム属性をサポートするレイアウトタイプをアドバタイズします（セクション5.12.1）。クライアントは、レイアウトの特定の型のレイアウトを要求し、それらのレイアウトをレイアウト型固有のロジックに処理します。"
    },
    {
      "indent": 3,
      "text": "The layouttype4 data type is 32 bits in length. The range represented by the layout type is split into three parts. Type 0x0 is reserved. Types within the range 0x00000001-0x7FFFFFFF are globally unique and are assigned according to the description in Section 22.5; they are maintained by IANA. Types within the range 0x80000000-0xFFFFFFFF are site specific and for private use only.",
      "ja": "LayoutType4データ型の長さは32ビットです。レイアウトタイプで表される範囲は3つの部分に分割されています。タイプ0x0は予約されています。範囲内のタイプ0x00000001-0X7FFFFFFはグローバルに一意であり、セクション22.5の説明に従って割り当てられています。彼らはIANAによって維持されています。0x80000000-0xFFFFFFFFの範囲内のタイプは、サイト固有で、プライベート使用のみです。"
    },
    {
      "indent": 3,
      "text": "The LAYOUT4_NFSV4_1_FILES enumeration specifies that the NFSv4.1 file layout type, as defined in Section 13, is to be used. The LAYOUT4_OSD2_OBJECTS enumeration specifies that the object layout, as defined in [47], is to be used. Similarly, the LAYOUT4_BLOCK_VOLUME enumeration specifies that the block/volume layout, as defined in [48], is to be used.",
      "ja": "LAYOUT4_NFSV4_1_FILES列挙体は、セクション13で定義されているように、NFSv4.1ファイルレイアウトタイプを使用することを指定します。LAYOUT4_OSD2_OBJECTS列挙体は、[47]で定義されているオブジェクトレイアウトが使用されることを指定します。同様に、LAYOUT4_BLOCK_VOLUME列挙体は、[48]で定義されているブロック/ボリュームレイアウトを使用することを指定します。"
    },
    {
      "indent": 0,
      "text": "3.3.14. deviceid4",
      "section_title": true,
      "ja": "3.3.14. DeviceID4"
    },
    {
      "indent": 3,
      "text": "const NFS4_DEVICEID4_SIZE = 16;",
      "ja": "const nfs4_deviceId4_size = 16;"
    },
    {
      "indent": 3,
      "text": "typedef opaque deviceid4[NFS4_DEVICEID4_SIZE];",
      "ja": "typedef opaque deviceId4 [NFS4_DeviceID4_SIZE];"
    },
    {
      "indent": 3,
      "text": "Layout information includes device IDs that specify a storage device through a compact handle. Addressing and type information is obtained with the GETDEVICEINFO operation. Device IDs are not guaranteed to be valid across metadata server restarts. A device ID is unique per client ID and layout type. See Section 12.2.10 for more details.",
      "ja": "レイアウト情報には、コンパクトなハンドルを介してストレージデバイスを指定するデバイスIDが含まれています。getDeviceInfo操作でアドレス指定とタイプ情報が取得されます。デバイスIDは、メタデータサーバの再起動間で有効であることが保証されていません。デバイスIDは、クライアントIDおよびレイアウトタイプごとに固有のものです。詳細については、12.2.10項を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.15. device_addr4",
      "section_title": true,
      "ja": "3.3.15. device_addr4"
    },
    {
      "indent": 3,
      "text": "struct device_addr4 {\n        layouttype4             da_layout_type;\n        opaque                  da_addr_body<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The device address is used to set up a communication channel with the storage device. Different layout types will require different data types to define how they communicate with storage devices. The opaque da_addr_body field is interpreted based on the specified da_layout_type field.",
      "ja": "機器アドレスは、記憶装置と通信チャネルを設定するために使用される。さまざまなレイアウト型には、データ型がストレージデバイスとの通信方法を定義する必要があります。opaque da_addr_bodyフィールドは、指定されたda_layout_typeフィールドに基づいて解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document defines the device address for the NFSv4.1 file layout (see Section 13.3), which identifies a storage device by network IP address and port number. This is sufficient for the clients to communicate with the NFSv4.1 storage devices, and may be sufficient for other layout types as well. Device types for object-based storage devices and block storage devices (e.g., Small Computer System Interface (SCSI) volume labels) are defined by their respective layout specifications.",
      "ja": "このドキュメントでは、NFSV4.1ファイルレイアウトのデバイスアドレス（セクション13.3を参照）を定義します。これは、ネットワークIPアドレスとポート番号でストレージデバイスを識別します。これは、クライアントがNFSV4.1ストレージデバイスと通信するのに十分であり、他のレイアウトタイプにも十分であり得る。オブジェクトベースのストレージデバイスとブロック記憶装置（例えば、小型コンピュータシステムインタフェース（SCSI）ボリュームラベル）のデバイスタイプは、それぞれのレイアウト仕様によって定義されます。"
    },
    {
      "indent": 0,
      "text": "3.3.16. layout_content4",
      "section_title": true,
      "ja": "3.3.16. Layout_Content4"
    },
    {
      "indent": 3,
      "text": "struct layout_content4 {\n        layouttype4 loc_type;\n        opaque      loc_body<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The loc_body field is interpreted based on the layout type (loc_type). This document defines the loc_body for the NFSv4.1 file layout type; see Section 13.3 for its definition.",
      "ja": "loc_bodyフィールドは、レイアウトタイプ（loc_type）に基づいて解釈されます。このドキュメントは、NFSv4.1ファイルレイアウト型のloc_bodyを定義します。その定義については13.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.17. layout4",
      "section_title": true,
      "ja": "3.3.17. レイアウト4"
    },
    {
      "indent": 3,
      "text": "struct layout4 {\n        offset4                 lo_offset;\n        length4                 lo_length;\n        layoutiomode4           lo_iomode;\n        layout_content4         lo_content;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The layout4 data type defines a layout for a file. The layout type specific data is opaque within lo_content. Since layouts are sub-dividable, the offset and length together with the file's filehandle, the client ID, iomode, and layout type identify the layout.",
      "ja": "LAYOUT4データ型は、ファイルのレイアウトを定義します。レイアウトタイプ固有のデータは、LO_Content内の不透明です。レイアウトは、ファイルのファイルハンドルとともにオフセットと長さ、クライアントID、IOMODE、およびレイアウトタイプがレイアウトを識別します。"
    },
    {
      "indent": 0,
      "text": "3.3.18. layoutupdate4",
      "section_title": true,
      "ja": "3.3.18. LayoutUpdate4"
    },
    {
      "indent": 3,
      "text": "struct layoutupdate4 {\n        layouttype4             lou_type;\n        opaque                  lou_body<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The layoutupdate4 data type is used by the client to return updated layout information to the metadata server via the LAYOUTCOMMIT (Section 18.42) operation. This data type provides a channel to pass layout type specific information (in field lou_body) back to the metadata server. For example, for the block/volume layout type, this could include the list of reserved blocks that were written. The contents of the opaque lou_body argument are determined by the layout type. The NFSv4.1 file-based layout does not use this data type; if lou_type is LAYOUT4_NFSV4_1_FILES, the lou_body field MUST have a zero length.",
      "ja": "LayoutUpdate4データ型は、レイアウトコミット（セクション18.42）操作を介して更新されたレイアウト情報をメタデータサーバーに返すようにクライアントによって使用されます。このデータ型は、（フィールドLou_Body）レイアウト型固有情報をメタデータサーバに返すチャネルを提供します。たとえば、ブロック/ボリュームレイアウトタイプの場合、これには書き込まれた予約ブロックのリストを含めることができます。不透明lou_body引数の内容は、レイアウトタイプによって決まります。NFSV4.1ファイルベースのレイアウトはこのデータ型を使用しません。lou_typeがlayout4_nfsv4_1_1_filesの場合、Lou_bodyフィールドは長さがゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.19. layouthint4",
      "section_title": true,
      "ja": "3.3.19. layoushint4."
    },
    {
      "indent": 3,
      "text": "struct layouthint4 {\n        layouttype4             loh_type;\n        opaque                  loh_body<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The layouthint4 data type is used by the client to pass in a hint about the type of layout it would like created for a particular file. It is the data type specified by the layout_hint attribute described in Section 5.12.4. The metadata server may ignore the hint or may selectively ignore fields within the hint. This hint should be provided at create time as part of the initial attributes within OPEN. The loh_body field is specific to the type of layout (loh_type). The NFSv4.1 file-based layout uses the nfsv4_1_file_layouthint4 data type as defined in Section 13.3.",
      "ja": "LayouseInt4データ型は、特定のファイルに対して作成したいレイアウトの種類についてヒントを渡すためにクライアントによって使用されます。それは、5.12.4項で説明されているlayout_hint属性によって指定されたデータ型です。メタデータサーバーはヒントを無視することも、ヒント内のフィールドを選択的に無視することができます。このヒントは、Open内の初期属性の一部としてCREATE TIMEで提供されるべきです。LOH_BODYフィールドはレイアウトのタイプ（LOH_TYPE）に固有のものです。NFSV4.1ファイルベースのレイアウトは、セクション13.3で定義されているようにNFSV4_1_FILE_LAYOUTHINT4データ型を使用します。"
    },
    {
      "indent": 0,
      "text": "3.3.20. layoutiomode4",
      "section_title": true,
      "ja": "3.3.20. LayoutiOmode4"
    },
    {
      "indent": 3,
      "text": "enum layoutiomode4 {\n        LAYOUTIOMODE4_READ      = 1,\n        LAYOUTIOMODE4_RW        = 2,\n        LAYOUTIOMODE4_ANY       = 3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The iomode specifies whether the client intends to just read or both read and write the data represented by the layout. While the LAYOUTIOMODE4_ANY iomode MUST NOT be used in the arguments to the LAYOUTGET operation, it MAY be used in the arguments to the LAYOUTRETURN and CB_LAYOUTRECALL operations. The LAYOUTIOMODE4_ANY iomode specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively. The metadata server's use of the iomode may depend on the layout type being used. The storage devices MAY validate I/O accesses against the iomode and reject invalid accesses.",
      "ja": "IOMODEは、クライアントがレイアウトによって表されるデータを読み書きするだけで読み書きすることを意図しているかどうかを指定します。LayoutIomode4_any iomodeをLayoutget操作の引数で使用してはいけませんが、LayoutReturnおよびCB_LayoutRecall操作の引数で使用できます。LAYOUTIOMODE4_ANY IOMODEは、それぞれlayoutioMode4_readおよびlayoutioMode4_rw iomodeの両方に関連するレイアウトが返されるかリコールされていることを指定します。メタデータサーバのIOMODEの使用は、使用されているレイアウト型によって異なります。ストレージデバイスは、IOMODEに対してI / Oアクセスを検証し、無効なアクセスを拒否することができます。"
    },
    {
      "indent": 0,
      "text": "3.3.21. nfs_impl_id4",
      "section_title": true,
      "ja": "3.3.21. NFS_IMPL_ID4"
    },
    {
      "indent": 3,
      "text": "struct nfs_impl_id4 {\n        utf8str_cis   nii_domain;\n        utf8str_cs    nii_name;\n        nfstime4      nii_date;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type is used to identify client and server implementation details. The nii_domain field is the DNS domain name with which the implementor is associated. The nii_name field is the product name of the implementation and is completely free form. It is RECOMMENDED that the nii_name be used to distinguish machine architecture, machine platforms, revisions, versions, and patch levels. The nii_date field is the timestamp of when the software instance was published or built.",
      "ja": "このデータ型は、クライアントとサーバーの実装の詳細を識別するために使用されます。NII_DOMAINフィールドは、実装者が関連付けられているDNSドメイン名です。NII_NAMEフィールドは実装の製品名であり、完全に自由形式です。NII_NAMEは、マシンアーキテクチャ、マシンプラットフォーム、リビジョン、バージョン、およびパッチレベルを区別するために使用することをお勧めします。NII_DATEフィールドは、ソフトウェアインスタンスが公開または構築されたときのタイムスタンプです。"
    },
    {
      "indent": 0,
      "text": "3.3.22. threshold_item4",
      "section_title": true,
      "ja": "3.3.22. threshold_item4."
    },
    {
      "indent": 3,
      "text": "struct threshold_item4 {\n        layouttype4     thi_layout_type;\n        bitmap4         thi_hintset;\n        opaque          thi_hintlist<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type contains a list of hints specific to a layout type for helping the client determine when it should send I/O directly through the metadata server versus the storage devices. The data type consists of the layout type (thi_layout_type), a bitmap (thi_hintset) describing the set of hints supported by the server (they may differ based on the layout type), and a list of hints (thi_hintlist) whose content is determined by the hintset bitmap. See the mdsthreshold attribute for more details.",
      "ja": "このデータ型は、クライアントがメタデータサーバとストレージデバイスを介して直接I / Oを送信する必要があるときにクライアントが判別するためのレイアウト型に固有のヒントのリストを含みます。データ型は、サーバーでサポートされているヒントのセットを記述するレイアウトタイプ（THI_LAYOUT_TYPE）で構成されています（レイアウトタイプに基づいて異なる場合があります）、コンテンツが決定されたヒント（THI_HINTLIST）のリスト（THI_HINTLIST）のリストからなります。ヒントセットビットマップ。詳細については、mdsthreshold属性を参照してください。"
    },
    {
      "indent": 3,
      "text": "The thi_hintset field is a bitmap of the following values:",
      "ja": "THI_HINTSETフィールドは、次の値のビットマップです。"
    },
    {
      "indent": 3,
      "text": "+=========================+===+=========+===========================+\n| name                    | # | Data    | Description               |\n|                         |   | Type    |                           |\n+=========================+===+=========+===========================+\n| threshold4_read_size    | 0 | length4 | If a file's length is     |\n|                         |   |         | less than the value of    |\n|                         |   |         | threshold4_read_size,     |\n|                         |   |         | then it is RECOMMENDED    |\n|                         |   |         | that the client read      |\n|                         |   |         | from the file via the     |\n|                         |   |         | MDS and not a storage     |\n|                         |   |         | device.                   |\n+-------------------------+---+---------+---------------------------+\n| threshold4_write_size   | 1 | length4 | If a file's length is     |\n|                         |   |         | less than the value of    |\n|                         |   |         | threshold4_write_size,    |\n|                         |   |         | then it is RECOMMENDED    |\n|                         |   |         | that the client write     |\n|                         |   |         | to the file via the       |\n|                         |   |         | MDS and not a storage     |\n|                         |   |         | device.                   |\n+-------------------------+---+---------+---------------------------+\n| threshold4_read_iosize  | 2 | length4 | For read I/O sizes        |\n|                         |   |         | below this threshold,     |\n|                         |   |         | it is RECOMMENDED to      |\n|                         |   |         | read data through the     |\n|                         |   |         | MDS.                      |\n+-------------------------+---+---------+---------------------------+\n| threshold4_write_iosize | 3 | length4 | For write I/O sizes       |\n|                         |   |         | below this threshold,     |\n|                         |   |         | it is RECOMMENDED to      |\n|                         |   |         | write data through the    |\n|                         |   |         | MDS.                      |\n+-------------------------+---+---------+---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2."
    },
    {
      "indent": 0,
      "text": "3.3.23. mdsthreshold4",
      "section_title": true,
      "ja": "3.3.23. mdsthreshold4."
    },
    {
      "indent": 3,
      "text": "struct mdsthreshold4 {\n        threshold_item4 mth_hints<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data type holds an array of elements of data type threshold_item4, each of which is valid for a particular layout type. An array is necessary because a server can support multiple layout types for a single file.",
      "ja": "このデータ型は、データ型Threshmorit_Item4の要素の配列を保持しており、各データ型は特定のレイアウトタイプに対して有効です。サーバーが単一のファイルの複数のレイアウトタイプをサポートできるため、アレイが必要です。"
    },
    {
      "indent": 0,
      "text": "4. Filehandles",
      "section_title": true,
      "ja": "4. ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The filehandle in the NFS protocol is a per-server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object.",
      "ja": "NFSプロトコルのファイルハンドルは、ファイルシステムオブジェクトのサーバーごとの一意の識別子です。ファイルハンドルの内容はクライアントに不透明です。したがって、サーバーはファイルハンドルをファイルシステムオブジェクトの内部表現に変換する責任があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Obtaining the First Filehandle",
      "section_title": true,
      "ja": "4.1. 最初のファイルハンドルを入手する"
    },
    {
      "indent": 3,
      "text": "The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFSv3 protocol (RFC 1813 [38]), there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string-based file system pathname to a filehandle, which can then be used by the NFS protocols.",
      "ja": "NFSプロトコルの動作は、1つ以上のファイルハンドルに関して定義されています。したがって、クライアントはサーバーとの通信を開始するためのファイルハンドルが必要です。NFSV3プロトコル（RFC 1813 [38]）では、この最初のファイルハンドルを取得するための補助プロトコルがあります。マウントプロトコルRPCプログラム番号100005は、文字列ベースのファイルシステムパス名をファイルハンドルに変換するメカニズムを提供します。これはNFSプロトコルによって使用できます。"
    },
    {
      "indent": 3,
      "text": "The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in RFC 2054 [49] and RFC 2055 [50]. With the use of the public filehandle in combination with the LOOKUP operation in the NFSv3 protocol, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.",
      "ja": "マウントプロトコルには、セキュリティの分野内の欠陥があり、ファイアウォールを介して使用します。これは、Public FileHandleの使用がRFC 2054 [49]とRFC 2055で導入された理由の1つです[50]。NFSV3プロトコルのルックアップ操作と組み合わせてパブリックファイルハンドルを使用すると、NFSクライアントとサーバ間の実行可能な対話にはマウントプロトコルが不要であることが実証されている。"
    },
    {
      "indent": 3,
      "text": "Therefore, the NFSv4.1 protocol will not use an ancillary protocol for translation from string-based pathnames to a filehandle. Two special filehandles will be used as starting points for the NFS client.",
      "ja": "したがって、NFSV4.1プロトコルは、文字列ベースのパス名からFileHandleへの変換のための補助プロトコルを使用しません。NFSクライアントの開始点としては、2つの特別なファイルハンドルが使用されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Root Filehandle",
      "section_title": true,
      "ja": "4.1.1. ルートファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the \"conceptual\" root of the file system namespace at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the \"current\" filehandle to the ROOT of the server's file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server's file tree with the LOOKUP operation. A complete discussion of the server namespace is in Section 7.",
      "ja": "特別なファイルハンドルの最初のファイルハンドルはルートファイルハンドルです。ルートファイルハンドルは、NFSサーバーのファイルシステム名前空間の「概念的な」ルートです。クライアントは、PUTROOTFH操作を使用してルートファイルハンドルで使用または開始します。PUTROOTFH操作は、サーバーのファイルツリーのルートに \"current\"ファイルハンドルを設定するようにサーバーに指示します。このPUTROOTFH操作が使用されると、クライアントはルックアップ操作でサーバーのファイルツリーの全体を通過できます。サーバーネームスペースの完全な説明はセクション7にあります。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Public Filehandle",
      "section_title": true,
      "ja": "4.1.2. パブリックファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server file system object. The client may not make any assumptions about this binding. The client uses the PUBLIC filehandle via the PUTPUBFH operation.",
      "ja": "2番目の特別なファイルハンドルはパブリックファイルハンドルです。ルートファイルハンドルとは異なり、パブリックファイルハンドルはバインドされているか、サーバーで任意のファイルシステムオブジェクトを表します。サーバーはこのバインディングを担当します。パブリックファイルハンドルとルートファイルハンドルが同じファイルシステムオブジェクトを参照している可能性があります。ただし、パブリックファイルハンドルとサーバーファイルシステムオブジェクトのバインディングを定義するには、サーバーで管理ソフトウェアとサーバー管理者のポリシーの推奨です。クライアントはこのバインディングに関する仮定を任意にしない可能性があります。クライアントはPUTPUBFH操作を介してパブリックファイルハンドルを使用します。"
    },
    {
      "indent": 0,
      "text": "4.2. Filehandle Types",
      "section_title": true,
      "ja": "4.2. ファイルハンドルの種類"
    },
    {
      "indent": 3,
      "text": "In the NFSv3 protocol, there was one type of filehandle with a single set of semantics. This type of filehandle is termed \"persistent\" in NFSv4.1. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFSv4.1 is the \"volatile\" filehandle, which attempts to accommodate certain server environments.",
      "ja": "NFSV3プロトコルでは、単一セットのセマンティクスを持つファイルハンドルのタイプのファイルハンドルがありました。このタイプのファイルハンドルは、NFSv4.1では \"persistent\"と呼ばれます。永続ファイルハンドルのセマンティクスは以前と同じままです。NFSV4.1で導入された新しいタイプのファイルハンドルは、特定のサーバー環境に対応しようとしている「揮発性」ファイルハンドルです。"
    },
    {
      "indent": 3,
      "text": "The volatile filehandle type was introduced to address server functionality or implementation issues that make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file-system-level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant or the server's file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.",
      "ja": "永続的なファイルハンドルの正しい実装を実行できないサーバーの機能や実装の問題に対処するために、揮発性のファイルハンドルタイプが導入されました。一部のサーバー環境では、永続的なファイルハンドルを構築するために使用できるファイルシステムレベルの不変権がありません。基礎となるサーバーファイルシステムは、不変権またはサーバーのファイルシステムのプログラミングインターフェイスを提供しない場合があります。揮発性のファイルハンドルは、階層ストレージ管理またはファイルシステムの再編成や移行などのサーバー機能の実装を容易にする可能性があります。ただし、揮発性ファイルハンドルはクライアントの実装負担を増やします。"
    },
    {
      "indent": 3,
      "text": "Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined that may be used by the client to determine the filehandle types being returned by the server.",
      "ja": "クライアントは永続性と揮発性のファイルハンドルを異なる方法で処理する必要があるため、サーバーによって返されるFileHandleの種類を判断するためにクライアントによって使用される可能性があるファイル属性が定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1. General Properties of a Filehandle",
      "section_title": true,
      "ja": "4.2.1. ファイルハンドルの一般的なプロパティ"
    },
    {
      "indent": 3,
      "text": "The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files, but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions that might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in Section 10.3.4.",
      "ja": "FileHandleには、サーバーが個々のファイルを区別する必要があるすべての情報が含まれています。クライアントに、ファイルハンドルは不透明です。クライアントは後の要求で使用するためのファイルハンドルを格納し、バイトごとの比較を行うことで同じサーバーから2つのファイルハンドルを比較できます。ただし、クライアントは特にファイルハンドルの内容を解釈してはいけません。同じサーバーから2つのファイルハンドルが等しい場合は、同じファイルを参照する必要があります。サーバーはファイルハンドルとファイル間の一対一の対応を維持しようとするはずですが、これは必須ではありません。クライアントは、正しい動作ではなく、パフォーマンスを向上させるためにのみFileHandle比較を使用する必要があります。 2つのファイルハンドルが同じオブジェクトを示すかどうか、そのような場合には誤った動作を引き起こす可能性があるという無効な仮定を避けることができない場合に、すべてのクライアントを準備する必要があります。データキャッシングのコンテキストにおけるFileHandleと属性比較の詳細については、10.3.4項に示されています。"
    },
    {
      "indent": 3,
      "text": "As an example, in the case that two different pathnames when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link (see [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\"\">6]) is used to create two file names that refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both pathnames' traversals.",
      "ja": "例として、サーバーが同じファイルシステムオブジェクトで終了したときに2つの異なるパス名がある場合、サーバーは各パスに対して同じファイルハンドルを返す必要があります。これは、ハードリンクの場合に発生する可能性があります（[オープングループベース仕様の開始6 IEEE STD 1003.1,2004エディション、HTMLバージョン \"\"> 6]の基本定義の第3章のセクション3.191）は、参照する2つのファイル名を作成するために使用されます。同じ基礎となるファイルオブジェクトと関連データに。たとえば、PATHS / A / B / Cおよび/ A / D / Cが同じファイルを参照している場合、サーバーは両方のパス名のトラバースに同じファイルハンドルを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Persistent Filehandle",
      "section_title": true,
      "ja": "4.2.2. 永続的なファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts, the NFS server MUST honor the same filehandle value as it did in the server's previous instantiation. Similarly, if the file system is migrated, the new NFS server MUST honor the same filehandle as the old NFS server.",
      "ja": "永続的なファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間に固定値を持つと定義されています。サーバーがファイルシステムオブジェクトのファイルハンドルを作成すると、サーバーはオブジェクトの有効期間にわたってオブジェクトの同じファイルハンドルを受け入れる必要があります。サーバーが再起動すると、NFSサーバーはサーバーの前のインスタンス化で同じファイルハンドル値を尊重する必要があります。同様に、ファイルシステムが移行された場合、新しいNFSサーバーは古いNFSサーバーと同じファイルハンドルを尊重する必要があります。"
    },
    {
      "indent": 3,
      "text": "The persistent filehandle will be become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the file system in whole has been destroyed or the file system has simply been removed from the server's namespace (i.e., unmounted in a UNIX environment).",
      "ja": "ファイルシステムオブジェクトが削除されたときに、永続的なファイルハンドルが古くなったり無効になります。サーバーに削除されたオブジェクトを参照する永続的なファイルハンドルが表示されている場合は、NFS4ERR_STALEのエラーを返す必要があります。オブジェクトを含むファイルシステムが使用できなくなったときに、ファイルハンドルが古くなる可能性があります。リムーバブルメディア上に存在する場合はファイルシステムが使用できなくなり、メディアはサーバーまたは全体のファイルシステムが破棄されたか、ファイルシステムがサーバーのネームスペースから単に削除された（すなわち、UNIXでマウント解除されています）。環境）。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Volatile Filehandle",
      "section_title": true,
      "ja": "4.2.3. 揮発性のファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.",
      "ja": "揮発性のファイルハンドルは、永続的なファイルハンドルの同じ寿命の特性を共有しません。サーバーは、揮発性のファイルハンドルがさまざまな時点ではもはや有効ではないと判断できます。サーバーが揮発性のファイルハンドルが削除されたオブジェクトを参照すると、サーバーがクライアントにNFS4ERR_STALEを返す必要があると判断した場合（永続ファイルハンドルの場合と同様に）。サーバーが揮発性のファイルハンドルを使用できなくなるとサーバーが決定した他のすべての場合では、NFS4ERR_FHEXPIREDのエラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED attribute \"fh_expire_type\" is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values:",
      "ja": "必要な属性 \"fh_expire_type\"は、サーバーが特定のファイルシステムを提供しているファイルハンドルの種類を決定するためにクライアントによって使用されます。この属性は、次の値を持つビットマスクです。"
    },
    {
      "indent": 3,
      "text": "FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.",
      "ja": "FH4_PERSINTENT FH4_PerSistentの値は、オブジェクトがファイルシステムから削除されるまで有効な永続的なファイルハンドルを示すために使用されます。このファイルハンドルのNFS4ERR_FHEXPIEDを返しません。FH4_Persistentは、以下に指定されたビットが設定されていない値として定義されています。"
    },
    {
      "indent": 3,
      "text": "FH4_VOLATILE_ANY The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).",
      "ja": "FH4_VOLATILE_ANY FILEHANDLEは、特に除外された場合（すなわち、FH4_NO_EXPIRE_WITH_OPEN）を除いて、いつでも期限切れになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "FH4_NOEXPIRE_WITH_OPEN May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.",
      "ja": "FH4_VOLATILE_ANYが設定されている場合にのみ設定できます。このビットが設定されている場合、FH4_VOLATILE_ANの意味は、開いているときにFileHandleの有効期限を除外する資格があります。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_MIGRATION The filehandle will expire as a result of a file system transition (migration or replication), in those cases in which the continuity of filehandle use is not specified by handle class information within the fs_locations_info attribute. When this bit is set, clients without access to fs_locations_info information should assume that filehandles will expire on file system transitions.",
      "ja": "FH4_VOL_MIGRATION FILE Handleの継続性がFS_LOCATIONS_INFO属性内のハンドルクラス情報で指定されていない場合、ファイルハンドルはファイルシステムの遷移（移行または複製）の結果として期限切れになります。このビットが設定されている場合、FS_LOCATIONS_INFO情報へのアクセスなしのクライアントは、ファイルハンドルがファイルシステムの遷移時に期限切れになると想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_RENAME The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOL_ANY is set, FH4_VOL_RENAME is redundant.",
      "ja": "FH4_VOL_RENAMEファイルハンドルは名前変更中に期限切れになります。これには、要求側クライアントまたは他のクライアントによる名前の変更を含みます。FH4_VOL_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。"
    },
    {
      "indent": 3,
      "text": "Servers that provide volatile filehandles that can expire while open require special care as regards handling of RENAMEs and REMOVEs. This situation can arise if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set, if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not set, or if a non-read-only file system has a transition target in a different handle class. In these cases, the server should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace period, in order to make sure that reclaims of files where filehandles may have expired do not do a reclaim for the wrong file.",
      "ja": "オープン中に期限切れになる可能性があるサーバーは、名前の変更と削除に関して特別な注意を必要とします。FH4_VOLATILE_ANYが設定され、FH4_VOLATILE_ANYが設定されていない場合、または非読み取り専用ファイルシステムが異なるハンドル・クラスに遷移ターゲットがある場合、この状況は発生する可能性があります。このような場合、サーバーは名前の変更または削除を拒否する必要があり、オープンファイルにつながるコンポーネントのいずれかのオープンファイルに影響を与えるはずです。さらに、ファイルハンドルが有効期限が切れている可能性があるファイルの再利用が誤ったファイルの再利用をしないようにするために、サーバーは猶予期間中にすべてのリクエストまたは削除要求を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Volatile filehandles are especially suitable for implementation of the pseudo file systems used to bridge exports. See Section 7.5 for a discussion of this.",
      "ja": "揮発性のファイルハンドルは、エクスポートをブリッジするために使用される疑似ファイルシステムの実装に特に適しています。これについての議論については7.5項を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. One Method of Constructing a Volatile Filehandle",
      "section_title": true,
      "ja": "4.3. 揮発性ファイルハンドルを構築する1つの方法"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle, while opaque to the client, could contain:",
      "ja": "クライアントに不透明ながら、揮発性のファイルハンドルが含まれている可能性があります。"
    },
    {
      "indent": 3,
      "text": "[volatile bit = 1 | server boot time | slot | generation number]",
      "ja": "[揮発性ビット= 1"
    },
    {
      "indent": 3,
      "text": "* slot is an index in the server volatile filehandle table",
      "ja": "* スロットはサーバー揮発性ファイルハンドルテーブルのインデックスです。"
    },
    {
      "indent": 3,
      "text": "* generation number is the generation number for the table entry/ slot",
      "ja": "* 世代番号はテーブルエントリ/スロットの世代番号です"
    },
    {
      "indent": 3,
      "text": "When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.",
      "ja": "クライアントが揮発性のファイルハンドルを表示すると、サーバーは次のチェックを行い、揮発性ビットのチェックが経過したと仮定します。サーバーの起動時刻が現在のサーバーの起動時刻より小さい場合は、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHExpiredを返します。"
    },
    {
      "indent": 3,
      "text": "When the server restarts, the table is gone (it is volatile).",
      "ja": "サーバーが再起動すると、テーブルがなくなります（揮発性）。"
    },
    {
      "indent": 3,
      "text": "If the volatile bit is 0, then it is a persistent filehandle with a different structure following it.",
      "ja": "揮発性ビットが0の場合、それはそれに続く異なる構造を持つ永続的なファイルハンドルです。"
    },
    {
      "indent": 0,
      "text": "4.4. Client Recovery from Filehandle Expiration",
      "section_title": true,
      "ja": "4.4. FileHandleの有効期限からのクライアントの回復"
    },
    {
      "indent": 3,
      "text": "If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.",
      "ja": "可能であれば、クライアントはNFS4ERR_FHExpiredエラーの受信から回復する必要があります。クライアントは、揮発性のファイルハンドルの有効期限から回復するように自分自身を準備することができるように追加の責任を負う必要があります。サーバーが永続的なファイルハンドルを返す場合、クライアントはこれらの追加のステップを必要としません。"
    },
    {
      "indent": 3,
      "text": "For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the namespace that is still available or by starting at the root of the server's file system namespace.",
      "ja": "揮発性のファイルハンドルの場合、最も一般的には、クライアントは、問題のファイルシステムオブジェクトまで、およびそれを含むコンポーネント名を保存する必要があります。これらの名前を付けて、クライアントは、まだ利用可能な名前空間内のファイルハンドルを見つけることによって、またはサーバーのファイルシステムの名前空間のルートから始めて復元できるはずです。"
    },
    {
      "indent": 3,
      "text": "If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.",
      "ja": "期限切れのファイルハンドルがファイルシステムから削除されたオブジェクトを参照している場合は、明らかにクライアントが期限切れのファイルハンドルから回復できません。"
    },
    {
      "indent": 3,
      "text": "It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new pathname based on the processing of the rename request. The client can then regenerate the new filehandle based on the new pathname. The client could also use the COMPOUND procedure to construct a series of operations like:",
      "ja": "期限切れのファイルハンドルが名前が変更されたファイルを参照することも可能です。ファイルが別のクライアントによって名前変更された場合、再度元のクライアントが回復できない可能性があります。ただし、クライアント自体がファイルの名前を変更してファイルが開いている場合は、クライアントが回復できる可能性があります。クライアントは、名前変更要求の処理に基づいて新しいパス名を決定できます。その後、クライアントは新しいパス名に基づいて新しいファイルハンドルを再生成できます。クライアントは、以下のような一連の操作を構築するために複合手順を使用することもできます。"
    },
    {
      "indent": 13,
      "text": "RENAME A B LOOKUP B GETFH",
      "ja": "ルックアップB GETFHを変更します"
    },
    {
      "indent": 3,
      "text": "Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.",
      "ja": "なお、化合物手順は原子性を提供しない。この例では、期限切れのファイルハンドルからの回復のオーバーヘッドを縮小します。"
    },
    {
      "indent": 0,
      "text": "5. File Attributes",
      "section_title": true,
      "ja": "5. ファイル属性"
    },
    {
      "indent": 3,
      "text": "To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes need to be handled in a flexible manner. The NFSv3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure cannot be extended as new needs arise and it provides no way to indicate non-support. With the NFSv4.1 protocol, the client is able to query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).",
      "ja": "非UNIXプラットフォームとの伸張性の要件を満たすために、属性は柔軟な方法で処理される必要があります。NFSV3 FATTR3構造には、すべてのクライアントとサーバーがサポートまたはケアが可能ではない属性の固定リストが含まれています。FATTR3構造は新しいニーズが発生するにつれて拡張することはできず、非サポートを示す方法はありません。NFSV4.1プロトコルを使用すると、クライアントはサーバーがサポートされている属性（またはそのサブセット）のみで要求をサポートおよび構築する属性を照会することができます。"
    },
    {
      "indent": 3,
      "text": "To this end, attributes are divided into three groups: REQUIRED, RECOMMENDED, and named. Both REQUIRED and RECOMMENDED attributes are supported in the NFSv4.1 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New REQUIRED or RECOMMENDED attributes may be added to the NFSv4 protocol as part of a new minor version by publishing a Standards Track RFC that allocates a new attribute number value and defines the encoding for the attribute. See Section 2.7 for further discussion.",
      "ja": "この目的のために、属性は3つのグループに分けられます。必須、推奨、および名前付き。必要とされた属性と推奨される属性の両方が、特定の明確なエンコーディングによってNFSV4.1プロトコルでサポートされており、番号によって識別されます。GetAttrリクエストで送信されたビットベクトル内のビットを設定することによって要求されます。サーバーの応答には、応答にどの属性が返されたかをリストするためのビットベクトルが含まれています。新しい属性番号値を割り当て、属性のエンコーディングを定義する標準トラックRFCを公開することで、新しいマイナーバージョンの一部としてNFSV4プロトコルに追加されても、NFSV4プロトコルに追加されることがあります。さらなる議論についてはセクション2.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:",
      "ja": "名前付き属性は、新しいOpenATTR操作によってアクセスされます。これは、ファイルシステムオブジェクトに関連付けられている属性の隠しディレクトリにアクセスします。OpenATTRはオブジェクトのファイルハンドルを取り、属性階層のファイルハンドルを返します。名前付き属性のファイルハンドルは、検索またはReadDirによってアクセス可能なディレクトリオブジェクトであり、名前が指定された属性を表し、そのデータバイトが属性の値であるファイルを含みます。例えば："
    },
    {
      "indent": 8,
      "text": "+----------+-----------+---------------------------------+\n| LOOKUP   | \"foo\"     | ; look up file                  |\n+----------+-----------+---------------------------------+\n| GETATTR  | attrbits  |                                 |\n+----------+-----------+---------------------------------+\n| OPENATTR |           | ; access foo's named attributes |\n+----------+-----------+---------------------------------+\n| LOOKUP   | \"x11icon\" | ; look up specific attribute    |\n+----------+-----------+---------------------------------+\n| READ     | 0,4096    | ; read stream of bytes          |\n+----------+-----------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 3",
      "ja": "表3."
    },
    {
      "indent": 3,
      "text": "Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as RECOMMENDED attributes by bringing them to the IETF Standards Track process.",
      "ja": "名前付き属性は、NFSクライアント実装ではなくアプリケーションに必要なデータを対象としています。NFS実装者は、それらをIETF規格追跡プロセスにすることによって、新しい属性を推奨属性として定義することを強く奨励されています。"
    },
    {
      "indent": 3,
      "text": "The set of attributes that are classified as REQUIRED is deliberately small since servers need to do whatever it takes to support them. A server should support as many of the RECOMMENDED attributes as possible but, by their definition, the server is not required to support all of them. Attributes are deemed REQUIRED if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.",
      "ja": "必要に応じて分類されている属性のセットは、サーバーがそれらをサポートするのに必要なものは何でもする必要があるため、意図的に小さくなります。サーバーはできるだけ多くの推奨される属性をサポートする必要がありますが、その定義によってサーバーはそれらのすべてをサポートするために必要ではありません。データが両方とも多数のクライアントによって必要とされており、そうでなければサポートが提供されていないときには、データが必要とされない場合は属性が必要とされます。"
    },
    {
      "indent": 3,
      "text": "Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server's implementation of named attributes and whether or not the underlying file system at the server has a named attribute directory. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.",
      "ja": "OpenATTRによって返された隠しディレクトリは、プロトコル処理の利便性です。クライアントは、サーバーの名前付き属性の実装に関する仮定を任意の仮定し、サーバーの基礎となるファイルシステムに名前付きの属性ディレクトリがあるかどうかを確認しないでください。したがって、名前付き属性ディレクトリ上のsetAttrやgetAttrなどの操作は未定義です。"
    },
    {
      "indent": 0,
      "text": "5.1. REQUIRED Attributes",
      "section_title": true,
      "ja": "5.1. 必須属性"
    },
    {
      "indent": 3,
      "text": "These MUST be supported by every NFSv4.1 client and server in order to ensure a minimum level of interoperability. The server MUST store and return these attributes, and the client MUST be able to function with an attribute set limited to these attributes. With just the REQUIRED attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request, and the server MUST return their value.",
      "ja": "これらは、最小レベルの相互運用性を確保するために、すべてのNFSV4.1クライアントおよびサーバーによってサポートされている必要があります。サーバーはこれらの属性を保存して返却する必要があり、クライアントはこれらの属性に限定された属性セットで機能することができなければなりません。必要な属性だけで、一部のクライアント機能は何らかの方法で損なわれているか、制限される可能性があります。クライアントは、GetAttr要求のビットを設定することによって、これらの属性のいずれかを返すことを要求し、サーバーはそれらの値を返す必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. RECOMMENDED Attributes",
      "section_title": true,
      "ja": "5.2. 推奨される属性"
    },
    {
      "indent": 3,
      "text": "These attributes are understood well enough to warrant support in the NFSv4.1 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client MAY ask for the set of attributes the server supports and SHOULD NOT request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes that are difficult to support in their operating environments. A server should provide attributes whenever they don't have to \"tell lies\" to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. At times this will be difficult for clients, but a client is better positioned to decide whether and how to fabricate or construct an attribute or whether to do without the attribute.",
      "ja": "これらの属性は、NFSV4.1プロトコルでサポートを保証するのに十分なほど理解されています。ただし、それらはすべてのクライアントやサーバーでサポートされていない可能性があります。クライアントは、GetAttrリクエストのビットを設定することによって、これらの属性のいずれかを返すことを要求することができますが、サーバーがそれらを返さない場合を処理する必要があります。クライアントは、サーバーがサポートしている属性のセットを要求することがあり、サーバーがサポートしていない属性を要求しないでください。サーバーは、サポートされていない属性の要求を許容し、要求を要求するのではなく単にそれらを返さないようにしてください。サーバーが快適に使用できるすべての属性をサポートすることが予想され、それらのオペレーティング環境ではサポートが困難な属性をサポートすることができません。サーバーは、クライアントに「嘘をつく」必要がない場合はいつでも属性を提供する必要があります。たとえば、ファイル修正時刻は正確な時間であるか、サーバーによってサポートされるべきではありません。時々これはクライアントにとって難しいでしょうが、クライアントは属性の作成または作成方法や属性なしで行う方法を決定するために優れています。"
    },
    {
      "indent": 0,
      "text": "5.3. Named Attributes",
      "section_title": true,
      "ja": "5.3. 名前付き属性"
    },
    {
      "indent": 3,
      "text": "These attributes are not supported by direct encoding in the NFSv4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes that are stored with the file system object. The namespace for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual \"named attribute directory\", and further perusal and modification of the namespace may be done using operations that work on more typical directories. In particular, READDIR may be used to get a list of such named attributes, and LOOKUP and OPEN may select a particular attribute. Creation of a new named attribute may be the result of an OPEN specifying file creation.",
      "ja": "これらの属性は、NFSV4プロトコルで直接エンコードによってサポートされていませんが、数字ではなく文字列名でアクセスされ、ファイルシステムオブジェクトに格納されている未解釈のバイトのストリームに対応します。これらの属性のネームスペースには、OpenATTR操作を使用してアクセスできます。OpenATTRの操作は仮想「名前付き属性ディレクトリ」のファイルハンドルを返し、さらに典型的なディレクトリに取り組む操作を使用して、さらに閲覧と変更を行うことができます。特に、READDIRを使用してそのような名前付き属性のリストを取得し、検索および開くことができる。新しい名前付き属性の作成は、ファイル作成を指定するオープン指定の結果です。"
    },
    {
      "indent": 3,
      "text": "Once an OPEN is done, named attributes may be examined and changed by normal READ and WRITE operations using the filehandles and stateids returned by OPEN.",
      "ja": "Openが完了すると、名前付き属性は、Openによって返されるFileHandlesとStateIDを使用して、通常の読み取りおよび書き込み操作によって調べられ、変更されます。"
    },
    {
      "indent": 3,
      "text": "Named attributes and the named attribute directory may have their own (non-named) attributes. Each of these objects MUST have all of the REQUIRED attributes and may have additional RECOMMENDED attributes. However, the set of attributes for named attributes and the named attribute directory need not be, and typically will not be, as large as that for other objects in that file system.",
      "ja": "名前付き属性と名前付き属性ディレクトリには、独自の（名前が付けられていない）属性があります。これらの各オブジェクトには、必要なすべての属性があり、追加の推奨属性がある場合があります。ただし、名前付き属性の属性のセットと名前付き属性ディレクトリは必要ありません。通常、そのファイルシステム内の他のオブジェクトの大きさと同じくらい大きくはありません。"
    },
    {
      "indent": 3,
      "text": "Named attributes and the named attribute directory might be the target of delegations (in the case of the named attribute directory, these will be directory delegations). However, since granting of delegations is at the server's discretion, a server need not support delegations on named attributes or the named attribute directory.",
      "ja": "名前付き属性と名前付き属性ディレクトリは、委任のターゲットである可能性があります（名前付き属性ディレクトリの場合、これらはディレクトリ委任になります）。ただし、代表団の付与はサーバーの裁量にあるため、サーバーは名前付き属性または名前付き属性ディレクトリ上の委任をサポートする必要はありません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server's file system. If a server does support named attributes, a client that is also able to handle them should be able to copy a file's data and metadata with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.",
      "ja": "サーバーは任意の名前付き属性をサポートすることをお勧めします。クライアントは、サーバーのファイルシステム内の名前付き属性を保存する機能に依存しないでください。サーバーが名前付き属性をサポートしている場合、それらを処理することもできるクライアントはファイルのデータとメタデータを1つの場所から別の場所への完全な透明度でコピーすることができます。これにより、通常のディレクトリエントリに許可されている名前は名前付き属性名も有効であることを意味します。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, the structure of named attribute directories is restricted in a number of ways, in order to prevent the development of non-interoperable implementations in which some servers support a fully general hierarchical directory structure for named attributes while others support a limited but adequate structure for named attributes. In such an environment, clients or applications might come to depend on non-portable extensions. The restrictions are:",
      "ja": "NFSv4.1では、名前付き属性ディレクトリの構造は、名前付き属性に対して完全に一般的な階層ディレクトリ構造をサポートしている非相互運用可能な実装の開発を防ぐために、いくつかの方法で制限されますが、他のものは限られたものですが名前付き属性のための適切な構造そのような環境では、クライアントやアプリケーションがポータブル以外の拡張に依存するようになる可能性があります。制限は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* CREATE is not allowed in a named attribute directory. Thus, such objects as symbolic links and special files are not allowed to be named attributes. Further, directories may not be created in a named attribute directory, so no hierarchical structure of named attributes for a single object is allowed.",
      "ja": "* 名前付き属性ディレクトリには作成は許可されていません。したがって、シンボリックリンクと特殊ファイルとのようなオブジェクトは、属性の名前を付けられていません。さらに、ディレクトリは名前付き属性ディレクトリに作成されないため、単一のオブジェクトの名前付き属性の階層構造は許可されません。"
    },
    {
      "indent": 3,
      "text": "* If OPENATTR is done on a named attribute directory or on a named attribute, the server MUST return NFS4ERR_WRONG_TYPE.",
      "ja": "* openattrが名前付き属性ディレクトリまたは名前付き属性で行われている場合、サーバーはNFS4ERR_WRONG_TYPEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* Doing a RENAME of a named attribute to a different named attribute directory or to an ordinary (i.e., non-named-attribute) directory is not allowed.",
      "ja": "* 名前付き属性の名前付き属性の名前付き属性ディレクトリまたは通常（すなわち、non-non-属性）ディレクトリに変更することはできません。"
    },
    {
      "indent": 3,
      "text": "* Creating hard links between named attribute directories or between named attribute directories and ordinary directories is not allowed.",
      "ja": "* 名前付き属性ディレクトリ間または名前付き属性ディレクトリと通常のディレクトリ間のハードリンクを作成することは許可されていません。"
    },
    {
      "indent": 3,
      "text": "Names of attributes will not be controlled by this document or other IETF Standards Track documents. See Section 22.2 for further discussion.",
      "ja": "属性の名前は、この文書または他のIETF標準のトラック文書によって制御されません。さらなる議論については22.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Classification of Attributes",
      "section_title": true,
      "ja": "5.4. 属性の分類"
    },
    {
      "indent": 3,
      "text": "Each of the REQUIRED and RECOMMENDED attributes can be classified in one of three categories: per server (i.e., the value of the attribute will be the same for all file objects that share the same server owner; see Section 2.5 for a definition of server owner), per file system (i.e., the value of the attribute will be the same for some or all file objects that share the same fsid attribute (Section 5.8.1.9) and server owner), or per file system object. Note that it is possible that some per file system attributes may vary within the file system, depending on the value of the \"homogeneous\" (Section 5.8.2.16) attribute. Note that the attributes time_access_set and time_modify_set are not listed in this section because they are write-only attributes corresponding to time_access and time_modify, and are used in a special instance of SETATTR.",
      "ja": "必要な属性と推奨属性のそれぞれは、サーバーごとに3つのカテゴリのいずれかに分類できます（つまり、属性の値は、同じサーバーの所有者を共有するすべてのファイルオブジェクトで同じになります。サーバーオーナーの定義については、セクション2.5を参照してください。）、ファイルシステムごとに（すなわち、属性の値は、同じFSID属性（セクション5.8.1.9）およびサーバーの所有者）、またはファイルシステムオブジェクトごとにファイルオブジェクトを共有するファイルオブジェクトまたはすべてのファイルオブジェクトで同じになります。「均質」（セクション5.8.2.16）属性の値に応じて、ファイルシステムごとの属性ごとにファイルシステム内で異なる可能性があることに注意してください。属性time_access_setとtime_modify_setは、time_accessとtime_modifyに対応する書き込み専用属性であり、SetAttrの特別なインスタンスで使用されているため、このセクションにはリストされていません。"
    },
    {
      "indent": 3,
      "text": "* The per-server attribute is:",
      "ja": "* サーバーごとの属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "lease_time",
      "ja": "リース時間"
    },
    {
      "indent": 3,
      "text": "* The per-file system attributes are:",
      "ja": "* ファイルごとのシステム属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "supported_attrs, suppattr_exclcreat, fh_expire_type, link_support, symlink_support, unique_handles, aclsupport, cansettime, case_insensitive, case_preserving, chown_restricted, files_avail, files_free, files_total, fs_locations, homogeneous, maxfilesize, maxname, maxread, maxwrite, no_trunc, space_avail, space_free, space_total, time_delta, change_policy, fs_status, fs_layout_type, fs_locations_info, fs_charset_cap",
      "ja": "support_Attrs、Suppatr_Exclreat、FH_EXPIRE_TYPE、LINK_SUPPORT、CANSTIME、CASE_INSENSITIVE、CASE_PRESERVING、CHOWN_RESSERITED、FS_LOCATION、CHOWN_RESTRICTED、FS_LOCATION、MAXWRITES、NO_TRUNC、SPACE_AVAIL、SPACE_FREE、SPACE_DELTA、TIME_DELTA、change_policy、fs_status、fs_layout_type、fs_locations_info、fs_charset_cap."
    },
    {
      "indent": 3,
      "text": "* The per-file system object attributes are:",
      "ja": "* ファイルごとのシステムオブジェクト属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "type, change, size, named_attr, fsid, rdattr_error, filehandle, acl, archive, fileid, hidden, maxlink, mimetype, mode, numlinks, owner, owner_group, rawdev, space_used, system, time_access, time_backup, time_create, time_metadata, time_modify, mounted_on_fileid, dir_notif_delay, dirent_notif_delay, dacl, sacl, layout_type, layout_hint, layout_blksize, layout_alignment, mdsthreshold, retention_get, retention_set, retentevt_get, retentevt_set, retention_hold, mode_set_masked",
      "ja": "タイプ、変更、サイズ、named_attr、fsid、rdattr_error、fileHandle、ACL、アーカイブ、fileID、隠し、maxlink、mimeType、mode、numlinks、所有者、owner_group、RawDev、Space_Used、System、Time_MetaData、Time_Modify、MACKING_ON_FILEID、DIR_NOTIF_DELAY、DIRENT_NOTIF_DELAY、DACL、SACL、LAYOUT_TYPE、LAYOUT_HINT、LAYOUT_BLKSIZE、LAYEOUT_GET、MDSTHRESHOLD、RETENTION_GET、RETENTION_SET、RETENTEVT_GET、RETENTEVT_SET、RETENSER_HOLD、MODE_SET_MASKED"
    },
    {
      "indent": 3,
      "text": "For quota_avail_hard, quota_avail_soft, and quota_used, see their definitions below for the appropriate classification.",
      "ja": "quota_avail_hard、quota_avail_soft、およびquota_usedの場合は、適切な分類については、以下の定義を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5. Set-Only and Get-Only Attributes",
      "section_title": true,
      "ja": "5.5. セット専用およびGET専用の属性"
    },
    {
      "indent": 3,
      "text": "Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they can be set via SETATTR but not retrieved via GETATTR. Similarly, some REQUIRED and RECOMMENDED attributes are get-only; i.e., they can be retrieved via GETATTR but not set via SETATTR. If a client attempts to set a get-only attribute or get a set-only attributes, the server MUST return NFS4ERR_INVAL.",
      "ja": "必要な属性と推奨される属性はいくつか設定されます。すなわち、それらはSetAttrを介して設定することができますが、GetAttrを介して取得されません。同様に、必要な属性と推奨される属性の中にはGet-Onlyです。すなわち、それらはgetAttrを介して取得することができますがSetAttrによって設定されていません。クライアントがGet-Only属性を設定しようとした場合、またはセット専用属性を取得しようとすると、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. REQUIRED Attributes - List and Definition References",
      "section_title": true,
      "ja": "5.6. 必須属性 - リストと定義参照"
    },
    {
      "indent": 3,
      "text": "The list of REQUIRED attributes appears in Table 4. The meaning of the columns of the table are:",
      "ja": "必要な属性のリストが表4に表示されます。表の列の意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: The name of the attribute.",
      "ja": "名前：属性の名前。"
    },
    {
      "indent": 3,
      "text": "Id: The number assigned to the attribute. In the event of conflicts between the assigned number and [10], the latter is likely authoritative, but should be resolved with Errata to this document and/or [10]. See [51] for the Errata process.",
      "ja": "ID：属性に割り当てられている番号。割り当てられた番号と[10]の間に競合が発生した場合、後者は能力的である可能性がありますが、この文書の正誤表や[10]で解決する必要があります。エラータプロセスの[51]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Data Type: The XDR data type of the attribute.",
      "ja": "データ型：属性のXDRデータ型。"
    },
    {
      "indent": 3,
      "text": "Acc: Access allowed to the attribute. R means read-only (GETATTR may retrieve, SETATTR may not set). W means write-only (SETATTR may set, GETATTR may not retrieve). R W means read/write (GETATTR may retrieve, SETATTR may set).",
      "ja": "ACC：属性に許可されています。Rは読み取り専用を意味します（GetAttrが取得し、setAttrは設定されていない場合があります）。w書き込み専用（SetAttrが設定されている、getAttrが取得できない場合があります）。R wは読み取り/書き込みを意味します（GetAttrが取得して、SetAttrは設定されています）。"
    },
    {
      "indent": 3,
      "text": "Defined in: The section of this specification that describes the attribute.",
      "ja": "属性を説明するこの仕様のセクションで定義されています。"
    },
    {
      "indent": 5,
      "text": "+====================+====+============+=====+==================+\n| Name               | Id | Data Type  | Acc | Defined in:      |\n+====================+====+============+=====+==================+\n| supported_attrs    | 0  | bitmap4    | R   | Section 5.8.1.1  |\n+--------------------+----+------------+-----+------------------+\n| type               | 1  | nfs_ftype4 | R   | Section 5.8.1.2  |\n+--------------------+----+------------+-----+------------------+\n| fh_expire_type     | 2  | uint32_t   | R   | Section 5.8.1.3  |\n+--------------------+----+------------+-----+------------------+\n| change             | 3  | uint64_t   | R   | Section 5.8.1.4  |\n+--------------------+----+------------+-----+------------------+\n| size               | 4  | uint64_t   | R W | Section 5.8.1.5  |\n+--------------------+----+------------+-----+------------------+\n| link_support       | 5  | bool       | R   | Section 5.8.1.6  |\n+--------------------+----+------------+-----+------------------+\n| symlink_support    | 6  | bool       | R   | Section 5.8.1.7  |\n+--------------------+----+------------+-----+------------------+\n| named_attr         | 7  | bool       | R   | Section 5.8.1.8  |\n+--------------------+----+------------+-----+------------------+\n| fsid               | 8  | fsid4      | R   | Section 5.8.1.9  |\n+--------------------+----+------------+-----+------------------+\n| unique_handles     | 9  | bool       | R   | Section 5.8.1.10 |\n+--------------------+----+------------+-----+------------------+\n| lease_time         | 10 | nfs_lease4 | R   | Section 5.8.1.11 |\n+--------------------+----+------------+-----+------------------+\n| rdattr_error       | 11 | enum       | R   | Section 5.8.1.12 |\n+--------------------+----+------------+-----+------------------+\n| filehandle         | 19 | nfs_fh4    | R   | Section 5.8.1.13 |\n+--------------------+----+------------+-----+------------------+\n| suppattr_exclcreat | 75 | bitmap4    | R   | Section 5.8.1.14 |\n+--------------------+----+------------+-----+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4."
    },
    {
      "indent": 0,
      "text": "5.7. RECOMMENDED Attributes - List and Definition References",
      "section_title": true,
      "ja": "5.7. 推奨される属性 - リストと定義の参照"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED attributes are defined in Table 5. The meanings of the column headers are the same as Table 4; see Section 5.6 for the meanings.",
      "ja": "推奨される属性は表5に定義されています。列ヘッダーの意味は表4と同じです。意味については5.6項を参照してください。"
    },
    {
      "indent": 3,
      "text": "+====================+====+====================+=====+=============+\n| Name               | Id | Data Type          | Acc | Defined in: |\n+====================+====+====================+=====+=============+\n| acl                | 12 | nfsace4<>          | R W | Section     |\n|                    |    |                    |     | 6.2.1       |\n+--------------------+----+--------------------+-----+-------------+\n| aclsupport         | 13 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 6.2.1.2     |\n+--------------------+----+--------------------+-----+-------------+\n| archive            | 14 | bool               | R W | Section     |\n|                    |    |                    |     | 5.8.2.1     |\n+--------------------+----+--------------------+-----+-------------+\n| cansettime         | 15 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.2     |\n+--------------------+----+--------------------+-----+-------------+\n| case_insensitive   | 16 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.3     |\n+--------------------+----+--------------------+-----+-------------+\n| case_preserving    | 17 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.4     |\n+--------------------+----+--------------------+-----+-------------+\n| change_policy      | 60 | chg_policy4        | R   | Section     |\n|                    |    |                    |     | 5.8.2.5     |\n+--------------------+----+--------------------+-----+-------------+\n| chown_restricted   | 18 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.6     |\n+--------------------+----+--------------------+-----+-------------+\n| dacl               | 58 | nfsacl41           | R W | Section     |\n|                    |    |                    |     | 6.2.2       |\n+--------------------+----+--------------------+-----+-------------+\n| dir_notif_delay    | 56 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.11.1      |\n+--------------------+----+--------------------+-----+-------------+\n| dirent_notif_delay | 57 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.11.2      |\n+--------------------+----+--------------------+-----+-------------+\n| fileid             | 20 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.7     |\n+--------------------+----+--------------------+-----+-------------+\n| files_avail        | 21 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.8     |\n+--------------------+----+--------------------+-----+-------------+\n| files_free         | 22 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.9     |\n+--------------------+----+--------------------+-----+-------------+\n| files_total        | 23 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.10    |\n+--------------------+----+--------------------+-----+-------------+\n| fs_charset_cap     | 76 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.11    |\n+--------------------+----+--------------------+-----+-------------+\n| fs_layout_type     | 62 | layouttype4<>      | R   | Section     |\n|                    |    |                    |     | 5.12.1      |\n+--------------------+----+--------------------+-----+-------------+\n| fs_locations       | 24 | fs_locations       | R   | Section     |\n|                    |    |                    |     | 5.8.2.12    |\n+--------------------+----+--------------------+-----+-------------+\n| fs_locations_info  | 67 | fs_locations_info4 | R   | Section     |\n|                    |    |                    |     | 5.8.2.13    |\n+--------------------+----+--------------------+-----+-------------+\n| fs_status          | 61 | fs4_status         | R   | Section     |\n|                    |    |                    |     | 5.8.2.14    |\n+--------------------+----+--------------------+-----+-------------+\n| hidden             | 25 | bool               | R W | Section     |\n|                    |    |                    |     | 5.8.2.15    |\n+--------------------+----+--------------------+-----+-------------+\n| homogeneous        | 26 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.16    |\n+--------------------+----+--------------------+-----+-------------+\n| layout_alignment   | 66 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.12.2      |\n+--------------------+----+--------------------+-----+-------------+\n| layout_blksize     | 65 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.12.3      |\n+--------------------+----+--------------------+-----+-------------+\n| layout_hint        | 63 | layouthint4        |   W | Section     |\n|                    |    |                    |     | 5.12.4      |\n+--------------------+----+--------------------+-----+-------------+\n| layout_type        | 64 | layouttype4<>      | R   | Section     |\n|                    |    |                    |     | 5.12.5      |\n+--------------------+----+--------------------+-----+-------------+\n| maxfilesize        | 27 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.17    |\n+--------------------+----+--------------------+-----+-------------+\n| maxlink            | 28 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.18    |\n+--------------------+----+--------------------+-----+-------------+\n| maxname            | 29 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.19    |\n+--------------------+----+--------------------+-----+-------------+\n| maxread            | 30 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.20    |\n+--------------------+----+--------------------+-----+-------------+\n| maxwrite           | 31 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.21    |\n+--------------------+----+--------------------+-----+-------------+\n| mdsthreshold       | 68 | mdsthreshold4      | R   | Section     |\n|                    |    |                    |     | 5.12.6      |\n+--------------------+----+--------------------+-----+-------------+\n| mimetype           | 32 | utf8str_cs         | R W | Section     |\n|                    |    |                    |     | 5.8.2.22    |\n+--------------------+----+--------------------+-----+-------------+\n| mode               | 33 | mode4              | R W | Section     |\n|                    |    |                    |     | 6.2.4       |\n+--------------------+----+--------------------+-----+-------------+\n| mode_set_masked    | 74 | mode_masked4       |   W | Section     |\n|                    |    |                    |     | 6.2.5       |\n+--------------------+----+--------------------+-----+-------------+\n| mounted_on_fileid  | 55 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.23    |\n+--------------------+----+--------------------+-----+-------------+\n| no_trunc           | 34 | bool               | R   | Section     |\n|                    |    |                    |     | 5.8.2.24    |\n+--------------------+----+--------------------+-----+-------------+\n| numlinks           | 35 | uint32_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.25    |\n+--------------------+----+--------------------+-----+-------------+\n| owner              | 36 | utf8str_mixed      | R W | Section     |\n|                    |    |                    |     | 5.8.2.26    |\n+--------------------+----+--------------------+-----+-------------+\n| owner_group        | 37 | utf8str_mixed      | R W | Section     |\n|                    |    |                    |     | 5.8.2.27    |\n+--------------------+----+--------------------+-----+-------------+\n| quota_avail_hard   | 38 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.28    |\n+--------------------+----+--------------------+-----+-------------+\n| quota_avail_soft   | 39 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.29    |\n+--------------------+----+--------------------+-----+-------------+\n| quota_used         | 40 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.30    |\n+--------------------+----+--------------------+-----+-------------+\n| rawdev             | 41 | specdata4          | R   | Section     |\n|                    |    |                    |     | 5.8.2.31    |\n+--------------------+----+--------------------+-----+-------------+\n| retentevt_get      | 71 | retention_get4     | R   | Section     |\n|                    |    |                    |     | 5.13.3      |\n+--------------------+----+--------------------+-----+-------------+\n| retentevt_set      | 72 | retention_set4     |   W | Section     |\n|                    |    |                    |     | 5.13.4      |\n+--------------------+----+--------------------+-----+-------------+\n| retention_get      | 69 | retention_get4     | R   | Section     |\n|                    |    |                    |     | 5.13.1      |\n+--------------------+----+--------------------+-----+-------------+\n| retention_hold     | 73 | uint64_t           | R W | Section     |\n|                    |    |                    |     | 5.13.5      |\n+--------------------+----+--------------------+-----+-------------+\n| retention_set      | 70 | retention_set4     |   W | Section     |\n|                    |    |                    |     | 5.13.2      |\n+--------------------+----+--------------------+-----+-------------+\n| sacl               | 59 | nfsacl41           | R W | Section     |\n|                    |    |                    |     | 6.2.3       |\n+--------------------+----+--------------------+-----+-------------+\n| space_avail        | 42 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.32    |\n+--------------------+----+--------------------+-----+-------------+\n| space_free         | 43 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.33    |\n+--------------------+----+--------------------+-----+-------------+\n| space_total        | 44 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.34    |\n+--------------------+----+--------------------+-----+-------------+\n| space_used         | 45 | uint64_t           | R   | Section     |\n|                    |    |                    |     | 5.8.2.35    |\n+--------------------+----+--------------------+-----+-------------+\n| system             | 46 | bool               | R W | Section     |\n|                    |    |                    |     | 5.8.2.36    |\n+--------------------+----+--------------------+-----+-------------+\n| time_access        | 47 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.8.2.37    |\n+--------------------+----+--------------------+-----+-------------+\n| time_access_set    | 48 | settime4           |   W | Section     |\n|                    |    |                    |     | 5.8.2.38    |\n+--------------------+----+--------------------+-----+-------------+\n| time_backup        | 49 | nfstime4           | R W | Section     |\n|                    |    |                    |     | 5.8.2.39    |\n+--------------------+----+--------------------+-----+-------------+\n| time_create        | 50 | nfstime4           | R W | Section     |\n|                    |    |                    |     | 5.8.2.40    |\n+--------------------+----+--------------------+-----+-------------+\n| time_delta         | 51 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.8.2.41    |\n+--------------------+----+--------------------+-----+-------------+\n| time_metadata      | 52 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.8.2.42    |\n+--------------------+----+--------------------+-----+-------------+\n| time_modify        | 53 | nfstime4           | R   | Section     |\n|                    |    |                    |     | 5.8.2.43    |\n+--------------------+----+--------------------+-----+-------------+\n| time_modify_set    | 54 | settime4           |   W | Section     |\n|                    |    |                    |     | 5.8.2.44    |\n+--------------------+----+--------------------+-----+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 5",
      "ja": "表5."
    },
    {
      "indent": 0,
      "text": "5.8. Attribute Definitions",
      "section_title": true,
      "ja": "5.8. 属性定義"
    },
    {
      "indent": 0,
      "text": "5.8.1. Definitions of REQUIRED Attributes",
      "section_title": true,
      "ja": "5.8.1. 必要な属性の定義"
    },
    {
      "indent": 0,
      "text": "5.8.1.1. Attribute 0: supported_attrs",
      "section_title": true,
      "ja": "5.8.1.1. 属性0：supported_attrs."
    },
    {
      "indent": 3,
      "text": "The bit vector that would retrieve all REQUIRED and RECOMMENDED attributes that are supported for this object. The scope of this attribute applies to all objects with a matching fsid.",
      "ja": "このオブジェクトでサポートされているすべての必須属性と推奨される属性を取得するビットベクトル。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.8.1.2. Attribute 1: type",
      "section_title": true,
      "ja": "5.8.1.2. 属性1：タイプ"
    },
    {
      "indent": 3,
      "text": "Designates the type of an object in terms of one of a number of special constants:",
      "ja": "特別な定数の数の1つに関してオブジェクトの種類を指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4REG designates a regular file.",
      "ja": "* NF4REGは通常のファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4DIR designates a directory.",
      "ja": "* NF4DIRはディレクトリを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4BLK designates a block device special file.",
      "ja": "* NF4BLKはブロックデバイス特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4CHR designates a character device special file.",
      "ja": "* NF4CHRは文字装置特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4LNK designates a symbolic link.",
      "ja": "* NF4LNKはシンボリックリンクを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4SOCK designates a named socket special file.",
      "ja": "* NF4SOCK名前付きソケット特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4FIFO designates a fifo special file.",
      "ja": "* NF4FIFOはFIFO特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4ATTRDIR designates a named attribute directory.",
      "ja": "* NF4AttrDir名前付き属性ディレクトリを指定します。"
    },
    {
      "indent": 3,
      "text": "* NF4NAMEDATTR designates a named attribute.",
      "ja": "* NF4NamedAttrは名前付き属性を指定します。"
    },
    {
      "indent": 3,
      "text": "Within the explanatory text and operation descriptions, the following phrases will be used with the meanings given below:",
      "ja": "説明文と操作の説明内で、以下のフレーズが以下の意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "* The phrase \"is a directory\" means that the object's type attribute is NF4DIR or NF4ATTRDIR.",
      "ja": "* \"directory\"というフレーズは、オブジェクトのtype属性がNF4DIRまたはNF4ATTRDIRであることを意味します。"
    },
    {
      "indent": 3,
      "text": "* The phrase \"is a special file\" means that the object's type attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO.",
      "ja": "* 「は特別なファイル」というフレーズは、オブジェクトのtype属性がNF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOであることを意味します。"
    },
    {
      "indent": 3,
      "text": "* The phrases \"is an ordinary file\" and \"is a regular file\" mean that the object's type attribute is NF4REG or NF4NAMEDATTR.",
      "ja": "* 「通常のファイル」と「通常のファイル」は、オブジェクトのtype属性がNF4REGまたはNF4NADEDATTRであることを意味します。"
    },
    {
      "indent": 0,
      "text": "5.8.1.3. Attribute 2: fh_expire_type",
      "section_title": true,
      "ja": "5.8.1.3. 属性2：FH_EXPIRE_TYPE"
    },
    {
      "indent": 3,
      "text": "Server uses this to specify filehandle expiration behavior to the client. See Section 4 for additional description.",
      "ja": "サーバーはこれを使用して、クライアントにFileHandleの有効期限の動作を指定します。追加の説明についてはセクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.1.4. Attribute 3: change",
      "section_title": true,
      "ja": "5.8.1.4. 属性3：変更"
    },
    {
      "indent": 3,
      "text": "A value created by the server that the client can use to determine if file data, directory contents, or attributes of the object have been modified. The server may return the object's time_metadata attribute for this attribute's value, but only if the file system object cannot be updated more frequently than the resolution of time_metadata.",
      "ja": "オブジェクトのファイルデータ、ディレクトリ内容、またはオブジェクトの属性が変更されたかどうかを判断するためにクライアントが使用できるサーバーによって作成された値。サーバーは、この属性の値のオブジェクトのtime_metadata属性を返すことができますが、ファイルシステムオブジェクトをtime_metadataの解像度よりも頻繁に更新できない場合に限ります。"
    },
    {
      "indent": 0,
      "text": "5.8.1.5. Attribute 4: size",
      "section_title": true,
      "ja": "5.8.1.5. 属性4：サイズ"
    },
    {
      "indent": 3,
      "text": "The size of the object in bytes.",
      "ja": "オブジェクトのサイズがバイト単位で。"
    },
    {
      "indent": 0,
      "text": "5.8.1.6. Attribute 5: link_support",
      "section_title": true,
      "ja": "5.8.1.6. 属性5：link_support."
    },
    {
      "indent": 3,
      "text": "TRUE, if the object's file system supports hard links.",
      "ja": "オブジェクトのファイルシステムがハードリンクをサポートしている場合はtrueです。"
    },
    {
      "indent": 0,
      "text": "5.8.1.7. Attribute 6: symlink_support",
      "section_title": true,
      "ja": "5.8.1.7. 属性6：symlink_support."
    },
    {
      "indent": 3,
      "text": "TRUE, if the object's file system supports symbolic links.",
      "ja": "オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合はtrueです。"
    },
    {
      "indent": 0,
      "text": "5.8.1.8. Attribute 7: named_attr",
      "section_title": true,
      "ja": "5.8.1.8. 属性7：named_attr."
    },
    {
      "indent": 3,
      "text": "TRUE, if this object has named attributes. In other words, object has a non-empty named attribute directory.",
      "ja": "このオブジェクトに名前が付けられた場合はtrueです。言い換えれば、オブジェクトは空でない名前付き属性ディレクトリを持ちます。"
    },
    {
      "indent": 0,
      "text": "5.8.1.9. Attribute 8: fsid",
      "section_title": true,
      "ja": "5.8.1.9. 属性8：FSID"
    },
    {
      "indent": 3,
      "text": "Unique file system identifier for the file system holding this object. The fsid attribute has major and minor components, each of which are of data type uint64_t.",
      "ja": "このオブジェクトを保持しているファイルシステムの固有ファイルシステム識別子。fsid属性にはメジャーコンポーネントとマイナーコンポーネントがあり、その各々はデータ型uint64_tです。"
    },
    {
      "indent": 0,
      "text": "5.8.1.10. Attribute 9: unique_handles",
      "section_title": true,
      "ja": "5.8.1.10. 属性9：Unique_Handles"
    },
    {
      "indent": 3,
      "text": "TRUE, if two distinct filehandles are guaranteed to refer to two different file system objects.",
      "ja": "2つの異なるファイルハンドルが2つの異なるファイルシステムオブジェクトを参照することが保証されている場合はtrue。"
    },
    {
      "indent": 0,
      "text": "5.8.1.11. Attribute 10: lease_time",
      "section_title": true,
      "ja": "5.8.1.11. 属性10：lease_time"
    },
    {
      "indent": 3,
      "text": "Duration of the lease at server in seconds.",
      "ja": "サーバーのリースの期間秒単位で。"
    },
    {
      "indent": 0,
      "text": "5.8.1.12. Attribute 11: rdattr_error",
      "section_title": true,
      "ja": "5.8.1.12. 属性11：RDATTR_ERROR"
    },
    {
      "indent": 3,
      "text": "Error returned from an attempt to retrieve attributes during a READDIR operation.",
      "ja": "READDIR操作中に属性を取得しようとしたときにエラーが返されました。"
    },
    {
      "indent": 0,
      "text": "5.8.1.13. Attribute 19: filehandle",
      "section_title": true,
      "ja": "5.8.1.13. 属性19：FileHandle."
    },
    {
      "indent": 3,
      "text": "The filehandle of this object (primarily for READDIR requests).",
      "ja": "このオブジェクトのファイルハンドル（主にREADDIR要求の場合）。"
    },
    {
      "indent": 0,
      "text": "5.8.1.14. Attribute 75: suppattr_exclcreat",
      "section_title": true,
      "ja": "5.8.1.14. 属性75：suppattr_exclaceat"
    },
    {
      "indent": 3,
      "text": "The bit vector that would set all REQUIRED and RECOMMENDED attributes that are supported by the EXCLUSIVE4_1 method of file creation via the OPEN operation. The scope of this attribute applies to all objects with a matching fsid.",
      "ja": "オープン操作を介してファイル作成のexclusive4_1メソッドでサポートされているすべての必須属性と推奨属性を設定するビットベクトル。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Definitions of Uncategorized RECOMMENDED Attributes",
      "section_title": true,
      "ja": "5.8.2. 未分類推奨属性の定義"
    },
    {
      "indent": 3,
      "text": "The definitions of most of the RECOMMENDED attributes follow. Collections that share a common category are defined in other sections.",
      "ja": "推奨される属性の大部分の定義は次のとおりです。共通のカテゴリを共有するコレクションは、他のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "5.8.2.1. Attribute 14: archive",
      "section_title": true,
      "ja": "5.8.2.1. 属性14：アーカイブ"
    },
    {
      "indent": 3,
      "text": "TRUE, if this file has been archived since the time of last modification (deprecated in favor of time_backup).",
      "ja": "このファイルが最後の変更時からアーカイブされている場合（time_backupを支持して廃止予定）。"
    },
    {
      "indent": 0,
      "text": "5.8.2.2. Attribute 15: cansettime",
      "section_title": true,
      "ja": "5.8.2.2. 属性15：CanSettime"
    },
    {
      "indent": 3,
      "text": "TRUE, if the server is able to change the times for a file system object as specified in a SETATTR operation.",
      "ja": "SETATTR操作で指定されているファイルシステムオブジェクトの時間をサーバーに変更できる場合は、TRUE。"
    },
    {
      "indent": 0,
      "text": "5.8.2.3. Attribute 16: case_insensitive",
      "section_title": true,
      "ja": "5.8.2.3. 属性16：case_insensitive."
    },
    {
      "indent": 3,
      "text": "TRUE, if file name comparisons on this file system are case insensitive.",
      "ja": "このファイルシステムのファイル名の比較が大文字と小文字を区別しない場合はtrueです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.4. Attribute 17: case_preserving",
      "section_title": true,
      "ja": "5.8.2.4. 属性17：CASE_PRESERVING"
    },
    {
      "indent": 3,
      "text": "TRUE, if file name case on this file system is preserved.",
      "ja": "このファイルシステムのファイル名の場合が保存されている場合は、trueです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.5. Attribute 60: change_policy",
      "section_title": true,
      "ja": "5.8.2.5. 属性60：change_policy."
    },
    {
      "indent": 3,
      "text": "A value created by the server that the client can use to determine if some server policy related to the current file system has been subject to change. If the value remains the same, then the client can be sure that the values of the attributes related to fs location and the fss_type field of the fs_status attribute have not changed. On the other hand, a change in this value does necessarily imply a change in policy. It is up to the client to interrogate the server to determine if some policy relevant to it has changed. See Section 3.3.6 for details.",
      "ja": "現在のファイルシステムに関連するサーバポリシーが変更されたかどうかを判断するためにクライアントが使用できるサーバによって作成された値。値が同じままである場合、クライアントは、FSの場所に関連する属性の値とfs_status属性のfss_typeフィールドが変更されていないことを確認できます。一方、この値の変更は必ずしもポリシーの変更を意味します。それに関連するいくつかのポリシーが変更されたかどうかを判断するためにサーバーを問い合わせるのはクライアント次第です。詳細については3.3.6項を参照してください。"
    },
    {
      "indent": 3,
      "text": "This attribute MUST change when the value returned by the fs_locations or fs_locations_info attribute changes, when a file system goes from read-only to writable or vice versa, or when the allowable set of security flavors for the file system or any part thereof is changed.",
      "ja": "この属性は、ファイルシステムが読み取り専用から書き込み可能な、またはその逆の場合、またはファイルシステムまたはその一部のセキュリティフレーバーの許容範囲が変更されたときに、FS_LOCATIONATIONS_INFO属性によって返される値が変更されたときに変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.6. Attribute 18: chown_restricted",
      "section_title": true,
      "ja": "5.8.2.6. 属性18：chown_restrictited"
    },
    {
      "indent": 3,
      "text": "If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, \"root\" in UNIX operating environments or, in Windows 2000, the \"Take Ownership\" privilege).",
      "ja": "trueの場合、サーバーは、呼び出し元が特権ユーザーではない場合、またはファイルに関連付けられている所有者またはグループに関連付けられているグループ（UNIXオペレーティング環境の「ルート」など、またはWindows 2000では、「所有権を取得する」という要求を拒否します。\"特権）。"
    },
    {
      "indent": 0,
      "text": "5.8.2.7. Attribute 20: fileid",
      "section_title": true,
      "ja": "5.8.2.7. 属性20：fileID"
    },
    {
      "indent": 3,
      "text": "A number uniquely identifying the file within the file system.",
      "ja": "ファイルシステム内のファイルを一意に識別する番号。"
    },
    {
      "indent": 0,
      "text": "5.8.2.8. Attribute 21: files_avail",
      "section_title": true,
      "ja": "5.8.2.8. 属性21：files_avail."
    },
    {
      "indent": 3,
      "text": "File slots available to this user on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上でこのユーザーが利用できるファイルスロット - これは関連する限界であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.9. Attribute 22: files_free",
      "section_title": true,
      "ja": "5.8.2.9. 属性22：files_free."
    },
    {
      "indent": 3,
      "text": "Free file slots on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上の空きファイルスロット - これは最小の関連制限であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.10. Attribute 23: files_total",
      "section_title": true,
      "ja": "5.8.2.10. 属性23：files_total"
    },
    {
      "indent": 3,
      "text": "Total file slots on the file system containing this object.",
      "ja": "このオブジェクトを含むファイルシステム上の合計ファイルスロット。"
    },
    {
      "indent": 0,
      "text": "5.8.2.11. Attribute 76: fs_charset_cap",
      "section_title": true,
      "ja": "5.8.2.11. 属性76：fs_charset_cap."
    },
    {
      "indent": 3,
      "text": "Character set capabilities for this file system. See Section 14.4.",
      "ja": "このファイルシステムの文字セット機能。14.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.12. Attribute 24: fs_locations",
      "section_title": true,
      "ja": "5.8.2.12. 属性24：fs_locations."
    },
    {
      "indent": 3,
      "text": "Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported. See Section 11.16 for more details.",
      "ja": "このファイルシステムが見つかる可能性がある場所。サーバーがエラーとしてNFS4ERR_MOUDを返す場合、この属性はサポートされている必要があります。詳細については11.16項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.13. Attribute 67: fs_locations_info",
      "section_title": true,
      "ja": "5.8.2.13. 属性67：FS_LOCATIONS_INFO"
    },
    {
      "indent": 3,
      "text": "Full function file system location. See Section 11.17.2 for more details.",
      "ja": "フル機能ファイルの場所。詳細については11.17.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.14. Attribute 61: fs_status",
      "section_title": true,
      "ja": "5.8.2.14. 属性61：fs_status."
    },
    {
      "indent": 3,
      "text": "Generic file system type information. See Section 11.18 for more details.",
      "ja": "一般ファイルシステムタイプ情報詳細については11.18項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.15. Attribute 25: hidden",
      "section_title": true,
      "ja": "5.8.2.15. 属性25：hidden."
    },
    {
      "indent": 3,
      "text": "TRUE, if the file is considered hidden with respect to the Windows API.",
      "ja": "true、ファイルがWindows APIに関して非表示に見える場合。"
    },
    {
      "indent": 0,
      "text": "5.8.2.16. Attribute 26: homogeneous",
      "section_title": true,
      "ja": "5.8.2.16. 属性26：均質"
    },
    {
      "indent": 3,
      "text": "TRUE, if this object's file system is homogeneous; i.e., all objects in the file system (all objects on the server with the same fsid) have common values for all per-file-system attributes.",
      "ja": "このオブジェクトのファイルシステムが均質である場合はtrue。すなわち、ファイルシステム内のすべてのオブジェクト（同じFSIDを持つサーバー上のすべてのオブジェクト）には、ファイルごとの属性ごとに共通の値があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.17. Attribute 27: maxfilesize",
      "section_title": true,
      "ja": "5.8.2.17. 属性27：MaxFileSize"
    },
    {
      "indent": 3,
      "text": "Maximum supported file size for the file system of this object.",
      "ja": "このオブジェクトのファイルシステムのサポートされている最大ファイルサイズ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.18. Attribute 28: maxlink",
      "section_title": true,
      "ja": "5.8.2.18. 属性28：MaxLink."
    },
    {
      "indent": 3,
      "text": "Maximum number of links for this object.",
      "ja": "このオブジェクトの最大リンク数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.19. Attribute 29: maxname",
      "section_title": true,
      "ja": "5.8.2.19. 属性29：MaxName."
    },
    {
      "indent": 3,
      "text": "Maximum file name size supported for this object.",
      "ja": "このオブジェクトでサポートされている最大ファイル名サイズ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.20. Attribute 30: maxread",
      "section_title": true,
      "ja": "5.8.2.20. 属性30：MaxRead."
    },
    {
      "indent": 3,
      "text": "Maximum amount of data the READ operation will return for this object.",
      "ja": "最大データ読み取り操作はこのオブジェクトに戻ります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.21. Attribute 31: maxwrite",
      "section_title": true,
      "ja": "5.8.2.21. 属性31：MaxWrite."
    },
    {
      "indent": 3,
      "text": "Maximum amount of data the WRITE operation will accept for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.",
      "ja": "最大データ書き込み操作はこのオブジェクトに対して受け入れます。この属性は、ファイルが書き込み可能な場合にサポートされます。この属性の欠如は、クライアントが帯域幅を無駄にするか、最良のパフォーマンスを受信していない可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.22. Attribute 32: mimetype",
      "section_title": true,
      "ja": "5.8.2.22. 属性32：MimeType."
    },
    {
      "indent": 3,
      "text": "MIME body type/subtype of this object.",
      "ja": "このオブジェクトのMIMEボディタイプ/サブタイプ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.23. Attribute 55: mounted_on_fileid",
      "section_title": true,
      "ja": "5.8.2.23. 属性55：MACKIT_ON_FILEID"
    },
    {
      "indent": 3,
      "text": "Like fileid, but if the target filehandle is the root of a file system, this attribute represents the fileid of the underlying directory.",
      "ja": "fileIDと同じですが、ターゲットファイルハンドルがファイルシステムのルートである場合、この属性は基礎となるディレクトリのfileIDを表します。"
    },
    {
      "indent": 3,
      "text": "UNIX-based operating environments connect a file system into the namespace by connecting (mounting) the file system onto the existing file object (the mount point, usually a directory) of an existing file system. When the mount point's parent directory is read via an API like readdir(), the return results are directory entries, each with a component name and a fileid. The fileid of the mount point's directory entry will be different from the fileid that the stat() system call returns. The stat() system call is returning the fileid of the root of the mounted file system, whereas readdir() is returning the fileid that stat() would have returned before any file systems were mounted on the mount point.",
      "ja": "UNIXベースのオペレーティング環境ファイルシステムを既存のファイルシステムの既存のファイルオブジェクト（マウントポイント、通常はディレクトリ）に接続する（マウント）することで、ファイルシステムをネームスペースに接続します。マウントポイントの親ディレクトリがREADDIR（）のようなAPIを介して読み込まれると、戻り結果はディレクトリエントリであり、それぞれコンポーネント名とfileIDを持つ。マウントポイントのディレクトリエントリのfileIDは、stat（）システムコールが返されるFileIDとは異なります。stat（）システムコールはマウントされたファイルシステムのルートのファイルIDを返しますが、READDIR（）は任意のファイルシステムがマウントポイントにマウントされていた前にstat（）が返されたことをfileIDに戻します。"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, NFSv4.1 allows a client's LOOKUP request to cross other file systems. The client detects the file system crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a \"mount point crossing\". UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point's parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned as described previously.",
      "ja": "NFSV3とは異なり、NFSV4.1では、クライアントのルックアップ要求を他のファイルシステムと交雑させることができます。LookupのfileHandle引数にルックアップによって返されたFileHandleのファイルハンドルとは異なるFSID属性がある場合は、クライアントはファイルシステム交差を検出します。UNIXベースのクライアントは、これが「マウントポイント交差点」と検討します。UNIXは、プロセスが現在の作業ディレクトリを決定できるようにするための従来のスキームを持っています。これは、前述のようにファイルIDを返すマウントポイントのマウントポイントの親とstat（）のREADDIR（）に依存しています。mounted_on_fileid属性は、readdir（）が前述のように返されたことをfileIdに対応しています。"
    },
    {
      "indent": 3,
      "text": "While the NFSv4.1 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the file system. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.",
      "ja": "NFSV4.1クライアントは、PAPTING_ON_FILEIDが提供する内容に対応するFileIDを単純に作成できるが（およびサーバがマウントされていない場合、クライアントは選択肢がない場合）、クライアントが1つと競合するFileIDを生成するリスクがあります。ファイルシステム内の別のオブジェクトにすでに割り当てられています。代わりに、サーバーがMACKIT_ON_FILEIDを提供できる場合、この領域のクライアントの運用上の問題の可能性がなくなります。"
    },
    {
      "indent": 3,
      "text": "If the server detects that there is no mounted point at the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.",
      "ja": "サーバーがターゲットファイルオブジェクトにマウントポイントがないことを検出した場合は、返すMAPINTED_ON_FILEIDの値はfileID属性の値と同じです。"
    },
    {
      "indent": 3,
      "text": "The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object's entry in the object's parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more file systems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.",
      "ja": "mounted_on_fileid属性をお勧めしますので、サーバーは可能であれば、そしてUNIXベースのサーバーの場合、これは簡単です。通常、AllidDir操作中に搭載されています。これは、READDIR（）によって返されるディレクトリエントリのfileIDと等しいため、（少なくともUNIXベースのサーバーの場合）では些細な（少なくともUNIXベースのサーバーの場合）。MACKIT_ON_FILEIDがGETATTRオペレーションで要求されている場合、サーバーは、オブジェクトの親ディレクトリ内のファイルオブジェクトのエントリ、すなわちREADDIR（）が返された値に等しい値を返す不変権に従います。いくつかの動作環境では、一連の2つ以上のファイルシステムを単一のマウントポイントにマウントすることができます。この場合、サーバーが前述の不変に従うためには、中間マウントポイントではなく、ベースマウントポイントを見つける必要があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.24. Attribute 34: no_trunc",
      "section_title": true,
      "ja": "5.8.2.24. 属性34：NO_TRUNC"
    },
    {
      "indent": 3,
      "text": "If this attribute is TRUE, then if the client uses a file name longer than name_max, an error will be returned instead of the name being truncated.",
      "ja": "この属性がtrueの場合、クライアントがname_maxより長いファイル名を使用している場合は、切り捨てられている名前の代わりにエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.25. Attribute 35: numlinks",
      "section_title": true,
      "ja": "5.8.2.25. 属性35：numlinks."
    },
    {
      "indent": 3,
      "text": "Number of hard links to this object.",
      "ja": "このオブジェクトへのハードリンクの数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.26. Attribute 36: owner",
      "section_title": true,
      "ja": "5.8.2.26. 属性36：所有者"
    },
    {
      "indent": 3,
      "text": "The string name of the owner of this object.",
      "ja": "このオブジェクトの所有者の文字列名。"
    },
    {
      "indent": 0,
      "text": "5.8.2.27. Attribute 37: owner_group",
      "section_title": true,
      "ja": "5.8.2.27. 属性37：owner_group."
    },
    {
      "indent": 3,
      "text": "The string name of the group ownership of this object.",
      "ja": "このオブジェクトのグループ所有権の文字列名。"
    },
    {
      "indent": 0,
      "text": "5.8.2.28. Attribute 38: quota_avail_hard",
      "section_title": true,
      "ja": "5.8.2.28. 属性38：quota_avail_hard."
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.",
      "ja": "追加の割り当てを超えた追加のディスク容量を超える追加のディスク容量を表す値は、このファイルまたはディレクトリに割り当てることができます。その他の割り当てが拒否されます。このスペースは他のファイルまたはディレクトリへの割り当てによって消費される可能性があることが理解されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.29. Attribute 39: quota_avail_soft",
      "section_title": true,
      "ja": "5.8.2.29. 属性39：quota_avail_soft."
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.",
      "ja": "ユーザーが合理的に警告する前にこのファイルまたはディレクトリに割り当てることができる追加のディスク容量の量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリに関して規則があるが、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることが理解される。"
    },
    {
      "indent": 0,
      "text": "5.8.2.30. Attribute 40: quota_used",
      "section_title": true,
      "ja": "5.8.2.30. 属性40：quota_used."
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of disk space used by this file or directory and possibly a number of other similar files or directories, where the set of \"similar\" meets at least the criterion that allocating space to any file or directory in the set will reduce the \"quota_avail_hard\" of every other file or directory in the set.",
      "ja": "このファイルまたはディレクトリによって使用されるディスク容量、およびおそらく他の類似のファイルやディレクトリの数を表す値の値は、少なくとも「類似」のセットが少なくとも任意のファイルまたはディレクトリに割り当てる基準を満たしています。セットは、セット内の他のすべてのファイルまたはディレクトリの \"quota_avail_hard\"を減らします。"
    },
    {
      "indent": 3,
      "text": "Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained, e.g., \"all files with a given owner\", \"all files with a given group owner\", etc. The server is at liberty to choose any of those sets when providing the content of the quota_used attribute, but should do so in a repeatable way. The rule may be configured per file system or may be \"choose the set with the smallest quota\".",
      "ja": "Quota_USED値が維持されている、例えば「特定の所有者を持つすべてのファイル」、「特定のグループ所有者を持つすべてのファイル」などが維持されている、たくさんの異なるが重複するファイルまたはディレクトリが多数あることがあります。Quota_used属性の内容を提供するときは、これらのセットのいずれかを選択するためにLibertyで、繰り返し可能な方法でそうする必要があります。ルールはファイルシステムごとに設定されているか、「最小のクォータのセットを選択する」です。"
    },
    {
      "indent": 0,
      "text": "5.8.2.31. Attribute 41: rawdev",
      "section_title": true,
      "ja": "5.8.2.31. 属性41：RawDev."
    },
    {
      "indent": 3,
      "text": "Raw device number of file of type NF4BLK or NF4CHR. The device number is split into major and minor numbers. If the file's type attribute is not NF4BLK or NF4CHR, the value returned SHOULD NOT be considered useful.",
      "ja": "RAWデバイスNF4BLKまたはNF4CHR型のファイル数。デバイス番号はメジャー番号とマイナー番号に分割されています。ファイルの種類属性がNF4BLKまたはNF4CHRではない場合、返される値は有用であると見なされるべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.8.2.32. Attribute 42: space_avail",
      "section_title": true,
      "ja": "5.8.2.32. 属性42：space_avail."
    },
    {
      "indent": 3,
      "text": "Disk space in bytes available to this user on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上でこのユーザーが利用できるバイト単位のディスク容量 - これは最小の関連制限であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.33. Attribute 43: space_free",
      "section_title": true,
      "ja": "5.8.2.33. 属性43：space_free."
    },
    {
      "indent": 3,
      "text": "Free disk space in bytes on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上のバイト単位の空きディスク容量 - これは最小の関連制限であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.34. Attribute 44: space_total",
      "section_title": true,
      "ja": "5.8.2.34. 属性44：space_total"
    },
    {
      "indent": 3,
      "text": "Total disk space in bytes on the file system containing this object.",
      "ja": "このオブジェクトを含むファイルシステム上のバイト単位の全ディスク容量。"
    },
    {
      "indent": 0,
      "text": "5.8.2.35. Attribute 45: space_used",
      "section_title": true,
      "ja": "5.8.2.35. 属性45：space_used."
    },
    {
      "indent": 3,
      "text": "Number of file system bytes allocated to this object.",
      "ja": "このオブジェクトに割り当てられているファイルシステムのバイト数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.36. Attribute 46: system",
      "section_title": true,
      "ja": "5.8.2.36. 属性46：システム"
    },
    {
      "indent": 3,
      "text": "This attribute is TRUE if this file is a \"system\" file with respect to the Windows operating environment.",
      "ja": "この属性は、このファイルがWindowsオペレーティング環境に関する「システム」ファイルである場合にも当てはまります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.37. Attribute 47: time_access",
      "section_title": true,
      "ja": "5.8.2.37. 属性47：time_access."
    },
    {
      "indent": 3,
      "text": "The time_access attribute represents the time of last access to the object by a READ operation sent to the server. The notion of what is an \"access\" depends on the server's operating environment and/or the server's file system semantics. For example, for servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only by the READ and READDIR operations and not any of the operations that modify the content of the object [13], [14], [15]. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.",
      "ja": "time_access属性は、サーバーに送信された読み取り操作によってオブジェクトへの最後のアクセス時刻を表します。「アクセス」となるのは、サーバーのオペレーティング環境やサーバーのファイルシステムセマンティクスによって異なります。たとえば、ポータブルオペレーティングシステムインタフェース（POSIX）セマンティクスのセマンティクスのセマンティクスの場合、Time_accessは、オブジェクトの内容を変更する操作のいずれか[13]、[14]、[15]、[15]、[15]、[15]の間ではTime_accessが更新されます。。もちろん、対応するtime_access_set属性を設定すると、time_access属性を変更するもう1つの方法があります。"
    },
    {
      "indent": 3,
      "text": "Whenever the file object resides on a writable file system, the server should make its best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object's content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.",
      "ja": "ファイルオブジェクトが書き込み可能なファイルシステム上にあるときはいつでも、サーバーはTime_Accessを安定したストレージに記録するための最良の努力をしてください。ただし、SOのパフォーマンス効果を軽減するために、サーバーがそのキャッシュからオブジェクトのコンテンツの読み取りを満たしているときはいつでも、サーバーはアクセス時間の更新をキャッシュし、それらを安定したストレージに書き込むことができます。TIME_ACCESSの更新を無効にするオプションをサーバーの管理者に提供することもできます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.38. Attribute 48: time_access_set",
      "section_title": true,
      "ja": "5.8.2.38. 属性48：time_access_set"
    },
    {
      "indent": 3,
      "text": "Sets the time of last access to the object. SETATTR use only.",
      "ja": "オブジェクトへの最後のアクセス時間を設定します。SetAttrのみ使用してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.39. Attribute 49: time_backup",
      "section_title": true,
      "ja": "5.8.2.39. 属性49：time_backup"
    },
    {
      "indent": 3,
      "text": "The time of last backup of the object.",
      "ja": "オブジェクトの最後のバックアップの時間。"
    },
    {
      "indent": 0,
      "text": "5.8.2.40. Attribute 50: time_create",
      "section_title": true,
      "ja": "5.8.2.40. 属性50：time_create"
    },
    {
      "indent": 3,
      "text": "The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute \"ctime\" or \"change time\".",
      "ja": "オブジェクトの作成時。この属性には、従来のUNIXファイル属性「CTIME」または「変更時刻」との関係はありません。"
    },
    {
      "indent": 0,
      "text": "5.8.2.41. Attribute 51: time_delta",
      "section_title": true,
      "ja": "5.8.2.41. 属性51：time_delta"
    },
    {
      "indent": 3,
      "text": "Smallest useful server time granularity.",
      "ja": "最小の有用なサーバー時間の粒度。"
    },
    {
      "indent": 0,
      "text": "5.8.2.42. Attribute 52: time_metadata",
      "section_title": true,
      "ja": "5.8.2.42. 属性52：time_metadata"
    },
    {
      "indent": 3,
      "text": "The time of last metadata modification of the object.",
      "ja": "オブジェクトの最後のメタデータの変更の時間。"
    },
    {
      "indent": 0,
      "text": "5.8.2.43. Attribute 53: time_modify",
      "section_title": true,
      "ja": "5.8.2.43. 属性53：time_modify"
    },
    {
      "indent": 3,
      "text": "The time of last modification to the object.",
      "ja": "オブジェクトへの最後の変更の時間。"
    },
    {
      "indent": 0,
      "text": "5.8.2.44. Attribute 54: time_modify_set",
      "section_title": true,
      "ja": "5.8.2.44. 属性54：time_modify_set."
    },
    {
      "indent": 3,
      "text": "Sets the time of last modification to the object. SETATTR use only.",
      "ja": "最後の変更の時間をオブジェクトに設定します。SetAttrのみ使用してください。"
    },
    {
      "indent": 0,
      "text": "5.9. Interpreting owner and owner_group",
      "section_title": true,
      "ja": "5.9. 所有者とowner_groupの解釈"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED attributes \"owner\" and \"owner_group\" (and also users and groups within the \"acl\" attribute) are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that Section 6.1 of RFC 2624 [53] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server, the local representation is translated to a syntax of the form \"user@dns_domain\". This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.",
      "ja": "推奨される属性 \"owner\"と \"owner_group\"（そして \"acl\"属性内のユーザーとグループ）は、UTF-8文字列の観点から表されます。クライアントまたはサーバーで特定の基礎となる実装に関連する表現を回避するために、UTF-8文字列の使用が選択されました。RFC 2624 [53]のセクション6.1は追加の根拠を提供することに留意されたい。クライアントとサーバーには、ローカルストレージやエンドユーザーへのプレゼンテーションに使用される所有者およびowner_groupの独自のローカル表現があります。したがって、これらの属性がクライアントとサーバー間で転送されると、ローカル表現は \"user @ dns_domain\"の形式の構文に変換されることが予想されます。これにより、同じローカル表現を使用しないクライアントとサーバーは、両方で解釈できる一般的な構文に変換する機能を使用することができます。"
    },
    {
      "indent": 3,
      "text": "Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals, they identify, in a common format, the users associated with each corresponding set of security principals.",
      "ja": "同様に、セキュリティプリンシパルは、さまざまなセキュリティメカニズムによってさまざまな方法で表すことができます。サーバは通常、これらの表現を一般的にローカルストレージで使用されている共通のフォーマットに変換し、これらのセキュリティプリンシパルに対応するユーザーを識別する手段として機能します。これらのローカル識別子がそのようなプリンシパルによって作成されたファイルに関連付けられている所有者属性の形式に変換されると、それらは、対応する各セキュリティプリンシパルに関連付けられているユーザを共通の形式で識別する。"
    },
    {
      "indent": 3,
      "text": "The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps a numeric identifier to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.",
      "ja": "所有者とグループ文字列を解釈するために使用される翻訳は、プロトコルの一部として指定されていません。これにより、様々な解決策を採用することができる。例えば、ローカル変換テーブルは、数値識別子をユーザ@ DNS_DOMAIN構文にマッピングするように調べることができる。翻訳を実行するためにネームサービスを使用することもできます。サーバは、翻訳なしで所有者および所有者および所有者の属性を格納することによって、所有者および所有者の属性を格納することによって、所有者および所有者の属性を格納することによって、限られた可能な文字列のセットを変換するだけであろう）によって制限されない一般的なサービスを提供することがある。翻訳が利用可能である場合のローカル表現の使用中に翻訳がない属性の文字列全体。"
    },
    {
      "indent": 3,
      "text": "Servers that do not provide support for all possible values of the owner and owner_group attributes SHOULD return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner, owner_group, or acl attributes. When a server does accept an owner or owner_group value as valid on a SETATTR (and similarly for the owner and group strings in an acl), it is promising to return that same string when a corresponding GETATTR is done. Configuration changes (including changes from the mapping of the string to the local representation) and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to ownership has occurred.",
      "ja": "所有者およびowner_group属性のすべての可能な値をサポートしていないサーバーは、翻訳が表示されていないときにエラー（NFS4ERR_BADOWNER）が返されるはずです。オーナー、owner_group、またはACLのsetAttrに設定される値として、属性サーバーがSETATTR（ACL内の所有者およびグループの文字列についても同様に）の所有者またはowner_group値を受け入れると、対応するGetAttrが行われたときに同じ文字列を返すことが有望です。構成変更（文字列のマッピングからローカル表現への変更を含む）とILL構築された名前の翻訳（エイリアシングを含むもの）と、その約束を尊重することは不可能になる可能性があります。サーバーは、所有権に実際の変更が発生しなかった場合にこれらの属性がそれらの値を変更した状況を避けるために適切な努力を払うべきです。"
    },
    {
      "indent": 3,
      "text": "The \"dns_domain\" portion of the owner string is meant to be a DNS domain name, for example, user@example.org. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.",
      "ja": "OWNER文字列の \"dns_domain\"部分は、dnsドメイン名、たとえばuser@example.orgであることを意味します。サーバーは、少なくとも1つのドメインに対して有効なユーザーのセットとして受け入れる必要があります。サーバーは他のドメインを有効な翻訳なしのものとして扱うことがあります。サーバーが複数のドメインのユーザーを受け入れることができますが、セキュリティ制約の対象となるすべてのドメインの場合は、より一般的なサービスが提供されます。"
    },
    {
      "indent": 3,
      "text": "In the case where there is no translation available to the client or server, the attribute value will be constructed without the \"@\". Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value cannot be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.",
      "ja": "クライアントまたはサーバーに翻訳が利用できない場合は、属性値が \"@\"なしで構築されます。したがって、所有者またはowner_group属性から@がないことは、送信者に翻訳が利用可能であり、属性の受信者がその文字列を翻訳の基礎として自らの内部形式に使用しないことを意味します。属性値を翻訳できないとしても、まだ役に立つ可能性があります。クライアントの場合、属性文字列は所有権のローカルディスプレイに使用できます。"
    },
    {
      "indent": 3,
      "text": "To provide a greater degree of compatibility with NFSv3, which identified users and groups by 32-bit unsigned user identifiers and group identifiers, owner and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value. A server is not obligated to accept such a string, but may return an NFS4ERR_BADOWNER instead. To avoid this mechanism being used to subvert user and group translation, so that a client might pass all of the owners and groups in numeric form, a server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate name@domain string and not the special form for compatibility.",
      "ja": "32ビット符号なしユーザ識別子とグループ識別子とグループ識別子、主要な数値で構成されているユーザとグループとの互換性を高めるために、クライアントやサーバによる特別な解釈を与えることができるNFSV3との互換性を高くすることができる。それはそのようなサポートを提供することを選びます。受信機は、そのようなユーザまたはグループ文字列を、対応する数値を有するNFSv3 UIDまたはGIDによって表されるものと同じユーザを表すものとして扱うことができる。サーバーはそのような文字列を受け入れる義務はありませんが、代わりにNFS4ERR_BADOWNERを返すことがあります。このメカニズムを使用しないようにするために、ユーザーがすべての所有者とグループのすべての所有者とグループを数値形式で渡すことを避けるために、ユーザーまたはこれで指定された所有者の有効な翻訳がある場合は、サーバーがNFS4ERR_BADOWNERエラーを返す必要があります。仕方。その場合、クライアントは適切な名前の@ Domain文字列を使用する必要があります。互換性のための特別な形式ではありません。"
    },
    {
      "indent": 3,
      "text": "The owner string \"nobody\" may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute. Users and implementations of NFSv4.1 SHOULD NOT use \"nobody\" to designate a real user whose access is not anonymous.",
      "ja": "所有者文字列「NOBODY」を使用して、匿名ユーザを指定することができ、これは、通常の手段を介して所有者属性にマッピングできないセキュリティプリンシパルによって作成されたファイルに関連付けられる。NFSV4.1のユーザーと実装は、そのアクセスが匿名ではない実際のユーザーを指定するために「誰も」を使用するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.10. Character Case Attributes",
      "section_title": true,
      "ja": "5.10. 文字ケース属性"
    },
    {
      "indent": 3,
      "text": "With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) can be mapped according to Appendix B.2 of RFC 3454 [16]. For general character handling and internationalization issues, see Section 14.",
      "ja": "Case_insensive属性とcase_preving属性に関して、各UCS-4文字（UTF-8エンコード）はRFC 3454 [16]の付録B.2に従ってマッピングできます。一般的な文字処理と国際化の問題については、14節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.11. Directory Notification Attributes",
      "section_title": true,
      "ja": "5.11. ディレクトリ通知属性"
    },
    {
      "indent": 3,
      "text": "As described in Section 18.39, the client can request a minimum delay for notifications of changes to attributes, but the server is free to ignore what the client requests. The client can determine in advance what notification delays the server will accept by sending a GETATTR operation for either or both of two directory notification attributes. When the client calls the GET_DIR_DELEGATION operation and asks for attribute change notifications, it should request notification delays that are no less than the values in the server-provided attributes.",
      "ja": "セクション18.39で説明されているように、クライアントは属性の変更の通知の最小遅延を要求することができますが、サーバーはクライアント要求を無視することができます。クライアントは、2つのディレクトリ通知属性のいずれかまたは両方に対してGetAttrオペレーションを送信することで、サーバーがgetattrオペレーションを送信することで、サーバーが受け入れることで、事前に決定できます。クライアントがGET_DIR_DELEGATION操作を呼び出して属性変更通知を要求すると、サーバー提供の属性内の値以上の通知遅延を要求する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.11.1. Attribute 56: dir_notif_delay",
      "section_title": true,
      "ja": "5.11.1. 属性56：dir_notif_delay."
    },
    {
      "indent": 3,
      "text": "The dir_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to the directory's attributes.",
      "ja": "dir_notif_delay属性は、クライアントにディレクトリの属性に通知する前に、サーバーが遅延する最小秒数です。"
    },
    {
      "indent": 0,
      "text": "5.11.2. Attribute 57: dirent_notif_delay",
      "section_title": true,
      "ja": "5.11.2. 属性57：dirent_notif_delay"
    },
    {
      "indent": 3,
      "text": "The dirent_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to a file object that has an entry in the directory.",
      "ja": "dirent_notif_delay属性は、ディレクトリ内のエントリを持つファイルオブジェクトにクライアントに通知する前に、サーバーが遅延する最小秒数です。"
    },
    {
      "indent": 0,
      "text": "5.12. pNFS Attribute Definitions",
      "section_title": true,
      "ja": "5.12. PNFS属性定義"
    },
    {
      "indent": 0,
      "text": "5.12.1. Attribute 62: fs_layout_type",
      "section_title": true,
      "ja": "5.12.1. 属性62：FS_LAYOUT_TYPE"
    },
    {
      "indent": 3,
      "text": "The fs_layout_type attribute (see Section 3.3.13) applies to a file system and indicates what layout types are supported by the file system. When the client encounters a new fsid, the client SHOULD obtain the value for the fs_layout_type attribute associated with the new file system. This attribute is used by the client to determine if the layout types supported by the server match any of the client's supported layout types.",
      "ja": "FS_LAYOUT_TYPE属性（セクション3.3.13を参照）はファイルシステムに適用され、ファイルシステムによってどのレイアウトタイプがサポートされているかを示します。クライアントが新しいFSIDに遭遇すると、クライアントは新しいファイルシステムに関連付けられているFS_LAYOUT_TYPE属性の値を取得する必要があります。この属性は、サーバーによってサポートされているレイアウト型がクライアントのサポートされているレイアウト型と一致するかどうかを判断するためにクライアントによって使用されます。"
    },
    {
      "indent": 0,
      "text": "5.12.2. Attribute 66: layout_alignment",
      "section_title": true,
      "ja": "5.12.2. 属性66：layout_alignment."
    },
    {
      "indent": 3,
      "text": "When a client holds layouts on files of a file system, the layout_alignment attribute indicates the preferred alignment for I/O to files on that file system. Where possible, the client should send READ and WRITE operations with offsets that are whole multiples of the layout_alignment attribute.",
      "ja": "クライアントがファイルシステムのファイルに対してレイアウトを保持すると、LAYOUT_ALIGNIGNT属性はそのファイルシステム上のI / Oのための優先アライメントを示します。可能であれば、クライアントは、Layout_alignment属性の倍数の倍数であるオフセットで読み書き操作を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.12.3. Attribute 65: layout_blksize",
      "section_title": true,
      "ja": "5.12.3. 属性65：layout_blksize"
    },
    {
      "indent": 3,
      "text": "When a client holds layouts on files of a file system, the layout_blksize attribute indicates the preferred block size for I/O to files on that file system. Where possible, the client should send READ operations with a count argument that is a whole multiple of layout_blksize, and WRITE operations with a data argument of size that is a whole multiple of layout_blksize.",
      "ja": "クライアントがファイルシステムのファイルのレイアウトを保持すると、LAYOUT_BLKSIZE属性はそのファイルシステム上のファイルへのI / Oの優先ブロックサイズを示します。可能であれば、クライアントは、LAYOUT_BLKSIZEの倍数の倍数であるCount引数を使用して読み取り操作を送信し、Layout_BLKSIZEの倍数の倍数のデータ引数を使用して操作を書きます。"
    },
    {
      "indent": 0,
      "text": "5.12.4. Attribute 63: layout_hint",
      "section_title": true,
      "ja": "5.12.4. 属性63：layout_hint"
    },
    {
      "indent": 3,
      "text": "The layout_hint attribute (see Section 3.3.19) may be set on newly created files to influence the metadata server's choice for the file's layout. If possible, this attribute is one of those set in the initial attributes within the OPEN operation. The metadata server may choose to ignore this attribute. The layout_hint attribute is a subset of the layout structure returned by LAYOUTGET. For example, instead of specifying particular devices, this would be used to suggest the stripe width of a file. The server implementation determines which fields within the layout will be used.",
      "ja": "ファイルのレイアウトのためのメタデータサーバの選択に影響を与えるために、新しく作成されたファイルにlayout_hint属性（セクション3.3.19を参照）を設定することができます。可能であれば、この属性はオープン操作内の初期属性に設定されているものの1つです。メタデータサーバーはこの属性を無視することを選択できます。layout_hint属性は、Layoutgetによって返されるレイアウト構造のサブセットです。たとえば、特定のデバイスを指定する代わりに、ファイルのストライプ幅を提案するためにこれが使用されます。サーバー実装は、レイアウト内のどのフィールドを使用するかを決定します。"
    },
    {
      "indent": 0,
      "text": "5.12.5. Attribute 64: layout_type",
      "section_title": true,
      "ja": "5.12.5. 属性64：LAYOUT_TYPE"
    },
    {
      "indent": 3,
      "text": "This attribute lists the layout type(s) available for a file. The value returned by the server is for informational purposes only. The client will use the LAYOUTGET operation to obtain the information needed in order to perform I/O, for example, the specific device information for the file and its layout.",
      "ja": "この属性は、ファイルに使用可能なレイアウトタイプを一覧表示します。サーバーによって返される値は情報提供のみを目的としています。クライアントは、ファイルの特定のデバイス情報とそのレイアウトなど、I / Oを実行するために必要な情報を取得するためにレイアウト操作を使用します。"
    },
    {
      "indent": 0,
      "text": "5.12.6. Attribute 68: mdsthreshold",
      "section_title": true,
      "ja": "5.12.6. 属性68：MDSTHRESHOLD"
    },
    {
      "indent": 3,
      "text": "This attribute is a server-provided hint used to communicate to the client when it is more efficient to send READ and WRITE operations to the metadata server or the data server. The two types of thresholds described are file size thresholds and I/O size thresholds. If a file's size is smaller than the file size threshold, data accesses SHOULD be sent to the metadata server. If an I/O request has a length that is below the I/O size threshold, the I/O SHOULD be sent to the metadata server. Each threshold type is specified separately for read and write.",
      "ja": "この属性は、メタデータサーバーまたはデータサーバーに読み書き操作を送信するのが効率的である場合に、クライアントと通信するために使用されるサーバー提供のヒントです。記載されている2種類のしきい値は、ファイルサイズのしきい値とI / Oサイズのしきい値です。ファイルのサイズがファイルサイズしきい値より小さい場合、データアクセスはメタデータサーバーに送信されます。I / O要求にI / Oサイズしきい値を下回る長さがある場合は、I / Oをメタデータサーバーに送信する必要があります。各しきい値タイプは、読み書きのために別々に指定されます。"
    },
    {
      "indent": 3,
      "text": "The server MAY provide both types of thresholds for a file. If both file size and I/O size are provided, the client SHOULD reach or exceed both thresholds before sending its read or write requests to the data server. Alternatively, if only one of the specified thresholds is reached or exceeded, the I/O requests are sent to the metadata server.",
      "ja": "サーバーは、ファイルの両方のタイプのしきい値を提供できます。ファイルサイズとI / Oサイズの両方が提供されている場合、クライアントは両方のしきい値に達するか、データサーバへの読み取りまたは書き込み要求を送信する必要があります。あるいは、指定されたしきい値のうちの1つだけを超えている場合は、I / O要求がメタデータサーバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "For each threshold type, a value of zero indicates no READ or WRITE should be sent to the metadata server, while a value of all ones indicates that all READs or WRITEs should be sent to the metadata server.",
      "ja": "各しきい値タイプの場合、ゼロの値はメタデータサーバーに読み書きを送信しないことを示しますが、すべてのものの値はすべての読み書きをメタデータサーバーに送信する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "The attribute is available on a per-filehandle basis. If the current filehandle refers to a non-pNFS file or directory, the metadata server should return an attribute that is representative of the filehandle's file system. It is suggested that this attribute is queried as part of the OPEN operation. Due to dynamic system changes, the client should not assume that the attribute will remain constant for any specific time period; thus, it should be periodically refreshed.",
      "ja": "属性はファイルハンドルごとに利用可能です。現在のファイルハンドルがPNF以外のファイルまたはディレクトリを参照している場合、メタデータサーバーはFileHandleのファイルシステムを表す属性を返すべきです。この属性はオープン操作の一部として照会されることが示唆されています。動的システムの変更により、クライアントは特定の期間に対して属性が一定のままであると仮定しないでください。したがって、それは定期的にリフレッシュされるべきです。"
    },
    {
      "indent": 0,
      "text": "5.13. Retention Attributes",
      "section_title": true,
      "ja": "5.13. 保持属性"
    },
    {
      "indent": 3,
      "text": "Retention is a concept whereby a file object can be placed in an immutable, undeletable, unrenamable state for a fixed or infinite duration of time. Once in this \"retained\" state, the file cannot be moved out of the state until the duration of retention has been reached.",
      "ja": "保存は、ファイルオブジェクトが、固定または無限の期間のために不変、未使用の、未知の状態に配置することができるという概念です。この「保持された」状態では、保持期間に達するまでファイルを状態から移動することはできません。"
    },
    {
      "indent": 3,
      "text": "When retention is enabled, retention MUST extend to the data of the file, and the name of file. The server MAY extend retention to any other property of the file, including any subset of REQUIRED, RECOMMENDED, and named attributes, with the exceptions noted in this section.",
      "ja": "保存が有効になっていると、保存はファイルのデータ、およびファイルの名前まで拡張する必要があります。サーバーは、このセクションに記載されている例外を備えた、必須、推奨、および名前付き属性のサブセットを含め、ファイルの他の任意のプロパティに保存を拡張することがあります。"
    },
    {
      "indent": 3,
      "text": "Servers MAY support or not support retention on any file object type.",
      "ja": "サーバーは、任意のファイルオブジェクトタイプでの保存をサポートまたはサポートできません。"
    },
    {
      "indent": 3,
      "text": "The five retention attributes are explained in the next subsections.",
      "ja": "5つの保持属性は次のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "5.13.1. Attribute 69: retention_get",
      "section_title": true,
      "ja": "5.13.1. 属性69：retention_get."
    },
    {
      "indent": 3,
      "text": "If retention is enabled for the associated file, this attribute's value represents the retention begin time of the file object. This attribute's value is only readable with the GETATTR operation and MUST NOT be modified by the SETATTR operation (Section 5.5). The value of the attribute consists of:",
      "ja": "関連付けられているファイルに対して保存が有効になっている場合、この属性の値はファイルオブジェクトの保存開始時間を表します。この属性の値はGetAttrの動作でのみ読み取り可能で、setAttrの操作によって変更されないでください（セクション5.5）。属性の値は次のもので構成されています。"
    },
    {
      "indent": 3,
      "text": "const RET4_DURATION_INFINITE    = 0xffffffffffffffff;\nstruct retention_get4 {\n        uint64_t        rg_duration;\n        nfstime4        rg_begin_time<1>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The field rg_duration is the duration in seconds indicating how long the file will be retained once retention is enabled. The field rg_begin_time is an array of up to one absolute time value. If the array is zero length, no beginning retention time has been established, and retention is not enabled. If rg_duration is equal to RET4_DURATION_INFINITE, the file, once retention is enabled, will be retained for an infinite duration.",
      "ja": "フィールドRG_DURATIONは、保持が有効になったかどうかがファイルを保持する時間を示す秒単位の期間です。フィールドRG_BEGIN_TIMEは、最大1つの絶対時間値の配列です。配列が長さゼロの場合、開始の保存期間が確立されておらず、保持は有効になっていません。RG_DURATIONがRET4_DURATION_INFINETと等しい場合、ファイルは一度保持が有効になっていると、無限の期間の間保持されます。"
    },
    {
      "indent": 3,
      "text": "If (as soon as) rg_duration is zero, then rg_begin_time will be of zero length, and again, retention is not (no longer) enabled.",
      "ja": "（遅すぐに）RG_DURITIONがゼロの場合、RG_BEGIN_TIMEは長さがゼロになり、再度保持が有効になっていません。"
    },
    {
      "indent": 0,
      "text": "5.13.2. Attribute 70: retention_set",
      "section_title": true,
      "ja": "5.13.2. 属性70：retention_set."
    },
    {
      "indent": 3,
      "text": "This attribute is used to set the retention duration and optionally enable retention for the associated file object. This attribute is only modifiable via the SETATTR operation and MUST NOT be retrieved by the GETATTR operation (Section 5.5). This attribute corresponds to retention_get. The value of the attribute consists of:",
      "ja": "この属性は、保存期間を設定し、オプションで関連するファイルオブジェクトの保存を有効にするために使用されます。この属性はSETATTRの動作を介してのみ変更可能で、GetAttr操作によって取得しないでください（5.5項）。この属性はretention_getに対応しています。属性の値は次のもので構成されています。"
    },
    {
      "indent": 3,
      "text": "struct retention_set4 {\n        bool            rs_enable;\n        uint64_t        rs_duration<1>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the client sets rs_enable to TRUE, then it is enabling retention on the file object with the begin time of retention starting from the server's current time and date. The duration of the retention can also be provided if the rs_duration array is of length one. The duration is the time in seconds from the begin time of retention, and if set to RET4_DURATION_INFINITE, the file is to be retained forever. If retention is enabled, with no duration specified in either this SETATTR or a previous SETATTR, the duration defaults to zero seconds. The server MAY restrict the enabling of retention or the duration of retention on the basis of the ACE4_WRITE_RETENTION ACL permission. The enabling of retention MUST NOT prevent the enabling of event-based retention or the modification of the retention_hold attribute.",
      "ja": "クライアントがRS_ENABLEをtrueに設定した場合、サーバーの現在の時刻と日付から開始する保持時間の開始時刻を持つファイルオブジェクトでの保存を有効にしています。RS_DURATION配列が長さ1の場合、保持期間も提供できます。デュレーションは、保持時間の開始時からの時間（秒）、ret4_duration_infiniteに設定されている場合、ファイルは永久に保持されます。このSESATTRまたは以前のSETATTRのいずれかで期間が指定されていない場合は、デフォルトはゼロ秒に割り当てられます。サーバは、ACE4_WRITE_RETこの権限に基づいて、保持の有効化または保持期間を制限することができる。保存の有効化は、イベントベースの保存の有効化またはretention_hold属性の変更を妨げてはいけません。"
    },
    {
      "indent": 3,
      "text": "The following rules apply to both the retention_set and retentevt_set attributes.",
      "ja": "次の規則は、retention_set属性とretentevt_set属性の両方に適用されます。"
    },
    {
      "indent": 3,
      "text": "* As long as retention is not enabled, the client is permitted to decrease the duration.",
      "ja": "* 保持が有効になっていない限り、クライアントは期間を短縮することができます。"
    },
    {
      "indent": 3,
      "text": "* The duration can always be set to an equal or higher value, even if retention is enabled. Note that once retention is enabled, the actual duration (as returned by the retention_get or retentevt_get attributes; see Section 5.13.1 or Section 5.13.3) is constantly counting down to zero (one unit per second), unless the duration was set to RET4_DURATION_INFINITE. Thus, it will not be possible for the client to precisely extend the duration on a file that has retention enabled.",
      "ja": "* 保持が有効になっていても、期間は常に等しい値に設定できます。一度保持が有効になっていると、実際の期間（retention_getまたはretentevt_get属性によって返されるように。セクション5.13.1またはセクション5.13.3を参照）が、期間が設定されていない限り、常にゼロにカウントダウンされています（1秒あたり1秒間）、ret4_duration_infinite。したがって、クライアントが保持が有効になっているファイル上の期間を正確に拡張することは不可能であろう。"
    },
    {
      "indent": 3,
      "text": "* While retention is enabled, attempts to disable retention or decrease the retention's duration MUST fail with the error NFS4ERR_INVAL.",
      "ja": "* 保存が有効になっている間は、保存期間を無効にしたり、保存期間を削減しようとしました。"
    },
    {
      "indent": 3,
      "text": "* If the principal attempting to change retention_set or retentevt_set does not have ACE4_WRITE_RETENTION permissions, the attempt MUST fail with NFS4ERR_ACCESS.",
      "ja": "* retention_setまたはretentevt_setを変更しようとしたプリンシパルがACE4_WRITE_RETENTION権限を持っていない場合、その試行はNFS4ERR_ACCESSで失敗する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.13.3. Attribute 71: retentevt_get",
      "section_title": true,
      "ja": "5.13.3. 属性71：retentevt_get"
    },
    {
      "indent": 3,
      "text": "Gets the event-based retention duration, and if enabled, the event-based retention begin time of the file object. This attribute is like retention_get, but refers to event-based retention. The event that triggers event-based retention is not defined by the NFSv4.1 specification.",
      "ja": "イベントベースの保存期間を取得し、有効になっている場合、イベントベースの保存期間はファイルオブジェクトの時刻を開始します。この属性はretention_getのようなものですが、イベントベースの保持を参照します。イベントベースの保存をトリガーするイベントは、NFSV4.1仕様によって定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.13.4. Attribute 72: retentevt_set",
      "section_title": true,
      "ja": "5.13.4. 属性72：retentevt_set."
    },
    {
      "indent": 3,
      "text": "Sets the event-based retention duration, and optionally enables event-based retention on the file object. This attribute corresponds to retentevt_get and is like retention_set, but refers to event-based retention. When event-based retention is set, the file MUST be retained even if non-event-based retention has been set, and the duration of non-event-based retention has been reached. Conversely, when non-event-based retention has been set, the file MUST be retained even if event-based retention has been set, and the duration of event-based retention has been reached. The server MAY restrict the enabling of event-based retention or the duration of event-based retention on the basis of the ACE4_WRITE_RETENTION ACL permission. The enabling of event-based retention MUST NOT prevent the enabling of non-event-based retention or the modification of the retention_hold attribute.",
      "ja": "イベントベースの保存期間を設定し、オプションでファイルオブジェクトでイベントベースの保存を有効にします。この属性はretentevt_getに対応しており、retention_setのようなものですが、イベントベースの保持を参照します。イベントベースの保持が設定されている場合は、イベントベースの保存期間が設定されていてもファイルを保持する必要があります。イベント以外の保存期間に達しました。逆に、非イベントベースの保存が設定されている場合、イベントベースの保存が設定されていてもファイルを保持する必要があります。イベントベースの保存期間に達しました。サーバーは、ACE4_WRITE_RETこのACL権限に基づいて、イベントベースの保持の有効化またはイベントベースの保存期間を制限することができます。イベントベースの保存の有効化は、イベントベースの保存期間の有効化またはretention_hold属性の変更を妨げてはいけません。"
    },
    {
      "indent": 0,
      "text": "5.13.5. Attribute 73: retention_hold",
      "section_title": true,
      "ja": "5.13.5. 属性73：retention_hold."
    },
    {
      "indent": 3,
      "text": "Gets or sets administrative retention holds, one hold per bit position.",
      "ja": "管理保持保持を取得または設定し、ビット位置ごとに1つの保持します。"
    },
    {
      "indent": 3,
      "text": "This attribute allows one to 64 administrative holds, one hold per bit on the attribute. If retention_hold is not zero, then the file MUST NOT be deleted, renamed, or modified, even if the duration on enabled event or non-event-based retention has been reached. The server MAY restrict the modification of retention_hold on the basis of the ACE4_WRITE_RETENTION_HOLD ACL permission. The enabling of administration retention holds does not prevent the enabling of event-based or non-event-based retention.",
      "ja": "この属性により、1対64の管理者が属性に1つずつ保持されます。retension_holdがゼロではない場合、有効なイベントまたは非イベントベースの保存期間に到達した期間に達しても、ファイルは削除、名前変更、または変更されてはいけません。サーバは、ACE4_WRITE_RETENTION_HOLE ACL権限に基づいて、retention_holdの変更を制限することができる。管理保持の有効化は、イベントベースまたは非イベントベースの保持の有効化を妨げません。"
    },
    {
      "indent": 3,
      "text": "If the principal attempting to change retention_hold does not have ACE4_WRITE_RETENTION_HOLD permissions, the attempt MUST fail with NFS4ERR_ACCESS.",
      "ja": "retention_holdを変更しようとしたプリンシパルにACE4_WRITE_RETENTION_HELS_HELS権限がない場合は、NFS4ERR_ACCESSでは試行が失敗する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Access Control Attributes",
      "section_title": true,
      "ja": "6. アクセス制御属性"
    },
    {
      "indent": 3,
      "text": "Access Control Lists (ACLs) are file attributes that specify fine-grained access control. This section covers the \"acl\", \"dacl\", \"sacl\", \"aclsupport\", \"mode\", and \"mode_set_masked\" file attributes and their interactions. Note that file attributes may apply to any file system object.",
      "ja": "アクセス制御リスト（ACL）は、きめ細かいアクセス制御を指定するファイル属性です。このセクションでは、「ACL」、「DACL」、「SACL」、「ACLSUPPORT」、「MODE」、「MODE_SET_MASKED」のファイル属性とその対話について説明します。ファイル属性はファイルシステムオブジェクトに適用される場合があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Goals",
      "section_title": true,
      "ja": "6.1. 目標"
    },
    {
      "indent": 3,
      "text": "ACLs and modes represent two well-established models for specifying permissions. This section specifies requirements that attempt to meet the following goals:",
      "ja": "ACLとモードは、権限を指定するための2つの確立されたモデルを表します。このセクションでは、次の目標を達成しようとする要件を指定します。"
    },
    {
      "indent": 3,
      "text": "* If a server supports the mode attribute, it should provide reasonable semantics to clients that only set and retrieve the mode attribute.",
      "ja": "* サーバーがMODE属性をサポートしている場合は、MODE属性を設定および取得するクライアントに合理的なセマンティクスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If a server supports ACL attributes, it should provide reasonable semantics to clients that only set and retrieve those attributes.",
      "ja": "* サーバーがACL属性をサポートしている場合は、それらの属性を設定および取得するクライアントに合理的なセマンティクスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "* On servers that support the mode attribute, if ACL attributes have never been set on an object, via inheritance or explicitly, the behavior should be traditional UNIX-like behavior.",
      "ja": "* MODE属性をサポートするサーバー上で、ACL属性は、継承または明示的にオブジェクトに設定されていない場合、動作は従来のUNIXのような動作になります。"
    },
    {
      "indent": 3,
      "text": "* On servers that support the mode attribute, if the ACL attributes have been previously set on an object, either explicitly or via inheritance:",
      "ja": "* MODE属性をサポートするサーバー上で、ACL属性が以前にオブジェクトに設定されている場合は、明示的にまたは継承を介して次のように設定されています。"
    },
    {
      "indent": 6,
      "text": "- Setting only the mode attribute should effectively control the traditional UNIX-like permissions of read, write, and execute on owner, owner_group, and other.",
      "ja": "- MODE属性のみを設定すると、OWNER、OWNER_GROUPなどのREAD、WRITE、EXECUTEの従来のUNIX様の権限を効果的に制御する必要があります。"
    },
    {
      "indent": 6,
      "text": "- Setting only the mode attribute should provide reasonable security. For example, setting a mode of 000 should be enough to ensure that future OPEN operations for OPEN4_SHARE_ACCESS_READ or OPEN4_SHARE_ACCESS_WRITE by any principal fail, regardless of a previously existing or inherited ACL.",
      "ja": "- モード属性のみを設定すると、合理的なセキュリティを提供する必要があります。たとえば、000モードを設定するには、以前に存在しているか継承されたACLに関係なく、任意のプリンシパルによるOpen4_Share_access_ReadまたはOpen4_Share_access_Writeの将来のオープン操作が確実に失敗するのに十分なはずです。"
    },
    {
      "indent": 3,
      "text": "* NFSv4.1 may introduce different semantics relating to the mode and ACL attributes, but it does not render invalid any previously existing implementations. Additionally, this section provides clarifications based on previous implementations and discussions around them.",
      "ja": "* NFSV4.1は、モードおよびACL属性に関する異なるセマンティクスを導入することができますが、以前に既存の実装を無効にしません。さらに、このセクションでは、以前の実装とそれらの周囲の議論に基づく明確化を説明します。"
    },
    {
      "indent": 3,
      "text": "* On servers that support both the mode and the acl or dacl attributes, the server must keep the two consistent with each other. The value of the mode attribute (with the exception of the three high-order bits described in Section 6.2.4) must be determined entirely by the value of the ACL, so that use of the mode is never required for anything other than setting the three high-order bits. See Section 6.4.1 for exact requirements.",
      "ja": "* モードとACLまたはDACL属性の両方をサポートするサーバー上で、サーバーは2つを互いに一貫して保持しなければなりません。MODE属性の値（セクション6.2.4で説明されている3つの上位ビットを除く）はACLの値によって完全に決定されなければならず、そのためモードの使用は設定以外のものには必要ありません。3つの高次ビット正確な要件については6.4.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* When a mode attribute is set on an object, the ACL attributes may need to be modified in order to not conflict with the new mode. In such cases, it is desirable that the ACL keep as much information as possible. This includes information about inheritance, AUDIT and ALARM ACEs, and permissions granted and denied that do not conflict with the new mode.",
      "ja": "* モード属性がオブジェクトに設定されている場合は、新しいモードと競合しないようにACL属性を変更する必要があります。そのような場合、ACLができるだけ多くの情報を保持することが望ましい。これには、継承、監査、およびアラームACEの情報、および新しいモードと競合しない権限と拒否された権限に関する情報が含まれます。"
    },
    {
      "indent": 0,
      "text": "6.2. File Attributes Discussion",
      "section_title": true,
      "ja": "6.2. ファイル属性ディスカッション"
    },
    {
      "indent": 0,
      "text": "6.2.1. Attribute 12: acl",
      "section_title": true,
      "ja": "6.2.1. 属性12：ACL."
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 ACL attribute contains an array of Access Control Entries (ACEs) that are associated with the file system object. Although the client can set and get the acl attribute, the server is responsible for using the ACL to perform access control. The client can use the OPEN or ACCESS operations to check access without modifying or reading data or metadata.",
      "ja": "NFSV4.1 ACL属性には、ファイルシステムオブジェクトに関連付けられているアクセス制御エントリの配列（ACE）が含まれています。クライアントはACL属性を設定および取得することができますが、サーバーはACLを使用してアクセス制御を実行します。クライアントは、データやメタデータを変更または読み取ることなくアクセスを確認するためにオープンまたはアクセス操作を使用できます。"
    },
    {
      "indent": 3,
      "text": "The NFS ACE structure is defined as follows:",
      "ja": "NFS ACE構造体は次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t acetype4;",
      "ja": "typedef uint32_t ateratype4。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t aceflag4;",
      "ja": "typedef uint32_t acflag4;"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t acemask4;",
      "ja": "typedef uint32_t a atemask4;"
    },
    {
      "indent": 3,
      "text": "struct nfsace4 {\n        acetype4        type;\n        aceflag4        flag;\n        acemask4        access_mask;\n        utf8str_mixed   who;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To determine if a request succeeds, the server processes each nfsace4 entry in order. Only ACEs that have a \"who\" that matches the requester are considered. Each ACE is processed until all of the bits of the requester's access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester's access still has unALLOWED bits in common with the \"access_mask\" of the ACE, the request is denied. When the ACL is fully processed, if there are bits in the requester's mask that have not been ALLOWED or DENIED, access is denied.",
      "ja": "要求が成功したかどうかを判断するために、サーバーは各NFSACE4エントリを順番に処理します。要求者に一致する「誰」を持つACESのみが考慮されます。各ACEは、リクエスタのアクセスのすべてのビットが許可されるまで処理されます。ビット（下記参照）がACCESS_ALLOWED_ACEによって許可されたら、後のACEの処理では考慮されなくなりました。要求者のアクセスがまだACEの「access_mask」と共通のビットがまだ未許可されていない場合にaccess_denied_aceが見つかった場合、要求は拒否されます。ACLが完全に処理されると、許可または拒否されていないリクエスタのマスクにビットがある場合は、アクセスが拒否されます。"
    },
    {
      "indent": 3,
      "text": "Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do not affect a requester's access, and instead are for triggering events as a result of a requester's access attempt. Therefore, AUDIT and ALARM ACEs are processed only after processing ALLOW and DENY ACEs.",
      "ja": "ALLY ACEタイプとは異なり、アラームと監査ACEタイプはリクエスタのアクセスには影響しません。代わりに、リクエスタのアクセス試行の結果としてイベントをトリガするためのものです。したがって、監査およびアラームACEは、処理が許可され、ACEを拒否した後にのみ処理されます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 ACL model is quite rich. Some server platforms may provide access-control functionality that goes beyond the UNIX-style mode attribute, but that is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may support the acl attributes by mapping between its ACL model and the NFSv4.1 ACL model. Servers must ensure that the ACL they actually store or enforce is at least as strict as the NFSv4 ACL that was set. It is tempting to accomplish this by rejecting any ACL that falls outside the small set that can be represented accurately. However, such an approach can render ACLs unusable without special client-side knowledge of the server's mapping, which defeats the purpose of having a common NFSv4 ACL protocol. Therefore, servers should accept every ACL that they can without compromising security. To help accomplish this, servers may make a special exception, in the case of unsupported permission bits, to the rule that bits not ALLOWED or DENIED by an ACL must be denied. For example, a UNIX-style server might choose to silently allow read attribute permissions even though an ACL does not explicitly allow those permissions. (An ACL that explicitly denies permission to read attributes should still be rejected.)",
      "ja": "NFSV4.1 ACLモデルはかなり豊富です。一部のサーバープラットフォームは、UNIXスタイルモード属性を超えてアクセス制御機能を提供できますが、NFS ACLモデルと同じくらい豊富ではありません。ユーザーがこのより限られた機能を利用できるように、サーバーはACLモデルとNFSV4.1 ACLモデルの間のマッピングによってACL属性をサポートできます。サーバーは、実際に保存または適用しているACLが設定されたNFSv4 ACLと少なくとも厳密であることを確認する必要があります。正確に表すことができる小型セットの外側にあるACLを拒絶することによってこれを達成することを魅力的です。しかしながら、そのようなアプローチは、サーバのマッピングに関する特別なクライアント側の知識なしにACLを使用できなくなる可能性があり、これは一般的なNFSV4 ACLプロトコルを有することの目的を軽減する。したがって、サーバーはセキュリティを犠牲にすることなくできるすべてのACLを受け入れる必要があります。これを達成するのを助けるために、サーバーは、サポートされていない権限ビットの場合、ビットが許可されていないか、またはACLによって拒否されたルールに特別な例外を作成することができます。たとえば、UNIXスタイルのサーバーは、ACLがそれらの権限を明示的に許可しない場合でも、読み取り属性のアクセス許可を静的に許可することを選択できます。 （明示的に属性を読み取る許可を拒否するACLは依然として拒否されるべきです。）"
    },
    {
      "indent": 3,
      "text": "The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFSv4.1 access may be different from, but not weaker than, the enforcement for local access, and both may be different from the enforcement for access through other protocols such as SMB (Server Message Block). So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.",
      "ja": "状況は、サーバーがACLを強制する複数のモジュールを持つことができるという事実によって複雑です。たとえば、NFSV4.1アクセスの執行は、ローカルアクセスの執行、両方とは異なる場合があります。また、SMB（サーバーメッセージブロック）などの他のプロトコルを介したアクセスのための執行とは異なります。したがって、すべてのモジュールがそれをサポートできるわけではなく、サーバーがACLを受け入れるのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The guiding principle with regard to NFSv4 access is that the server must not accept ACLs that appear to make access to the file more restrictive than it really is.",
      "ja": "NFSV4アクセスに関するガイド原則は、サーバーが本当に制限的なものよりも制限的なファイルにアクセスするように見えるACLを受け入れてはいけません。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. ACE Type",
      "section_title": true,
      "ja": "6.2.1.1. エースタイプ"
    },
    {
      "indent": 3,
      "text": "The constants used for the type field (acetype4) are as follows:",
      "ja": "TYPEフィールド（ATERATYPE4）に使用される定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\nconst ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\nconst ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\nconst ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Only the ALLOWED and DENIED bits may be used in the dacl attribute, and only the AUDIT and ALARM bits may be used in the sacl attribute. All four are permitted in the acl attribute.",
      "ja": "DACL属性で使用できるのは許可され拒否されたビットのみが使用され、監査ビットとアラームビットのみがSACL属性で使用できます。4つすべてがACL属性で許可されています。"
    },
    {
      "indent": 3,
      "text": "+==============================+==============+=====================+\n| Value                        | Abbreviation | Description         |\n+==============================+==============+=====================+\n| ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |\n|                              |              | the access          |\n|                              |              | defined in          |\n|                              |              | acemask4 to the     |\n|                              |              | file or             |\n|                              |              | directory.          |\n+------------------------------+--------------+---------------------+\n| ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |\n|                              |              | the access          |\n|                              |              | defined in          |\n|                              |              | acemask4 to the     |\n|                              |              | file or             |\n|                              |              | directory.          |\n+------------------------------+--------------+---------------------+\n| ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | Log (in a system-   |\n|                              |              | dependent way)      |\n|                              |              | any access          |\n|                              |              | attempt to a file   |\n|                              |              | or directory that   |\n|                              |              | uses any of the     |\n|                              |              | access methods      |\n|                              |              | specified in        |\n|                              |              | acemask4.           |\n+------------------------------+--------------+---------------------+\n| ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate an alarm   |\n|                              |              | (in a system-       |\n|                              |              | dependent way)      |\n|                              |              | when any access     |\n|                              |              | attempt is made     |\n|                              |              | to a file or        |\n|                              |              | directory for the   |\n|                              |              | access methods      |\n|                              |              | specified in        |\n|                              |              | acemask4.           |\n+------------------------------+--------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 6",
      "ja": "表6."
    },
    {
      "indent": 3,
      "text": "The \"Abbreviation\" column denotes how the types will be referred to throughout the rest of this section.",
      "ja": "「略語」列は、このセクションの残りの部分を通してタイプの種類をどのように参照するかを示します。"
    },
    {
      "indent": 0,
      "text": "6.2.1.2. Attribute 13: aclsupport",
      "section_title": true,
      "ja": "6.2.1.2. 属性13：ACLSupport."
    },
    {
      "indent": 3,
      "text": "A server need not support all of the above ACE types. This attribute indicates which ACE types are supported for the current file system. The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:",
      "ja": "サーバーは上記のすべてのACEタイプをサポートする必要はありません。この属性は、現在のファイルシステムでどのACEタイプがサポートされているかを示します。aclsupport属性内の上記の定義を表すために使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\nconst ACL4_SUPPORT_DENY_ACL     = 0x00000002;\nconst ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\nconst ACL4_SUPPORT_ALARM_ACL    = 0x00000008;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers that support either the ALLOW or DENY ACE type SHOULD support both ALLOW and DENY ACE types.",
      "ja": "許可または拒否ACEタイプをサポートするサーバーは、ALLY ACEタイプと拒否の両方をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバーがそのACEタイプのサポートを受けていない限り、クライアントはACEを設定しようとしないでください。保存できないACEを設定する要求を受信した場合は、NFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーが保存できるが適切でできないACEを設定する要求を受け取ると、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Support for any of the ACL attributes is optional (albeit RECOMMENDED). However, a server that supports either of the new ACL attributes (dacl or sacl) MUST allow use of the new ACL attributes to access all of the ACE types that it supports. In other words, if such a server supports ALLOW or DENY ACEs, then it MUST support the dacl attribute, and if it supports AUDIT or ALARM ACEs, then it MUST support the sacl attribute.",
      "ja": "いずれかのACL属性のサポートはオプションです（推奨されています）。ただし、新しいACL属性（DACLまたはSACL）のいずれかをサポートするサーバーは、新しいACL属性を使用してサポートしているすべてのACEタイプにアクセスする必要があります。言い換えれば、そのようなサーバーがACEを許可または拒否している場合は、DACL属性をサポートしており、監査またはアラームACESをサポートしている場合はSACL属性をサポートしている必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3. ACE Access Mask",
      "section_title": true,
      "ja": "6.2.1.3. ACEアクセスマスク"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the access mask field are as follows:",
      "ja": "アクセスマスクフィールドに使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_READ_DATA            = 0x00000001;\nconst ACE4_LIST_DIRECTORY       = 0x00000001;\nconst ACE4_WRITE_DATA           = 0x00000002;\nconst ACE4_ADD_FILE             = 0x00000002;\nconst ACE4_APPEND_DATA          = 0x00000004;\nconst ACE4_ADD_SUBDIRECTORY     = 0x00000004;\nconst ACE4_READ_NAMED_ATTRS     = 0x00000008;\nconst ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\nconst ACE4_EXECUTE              = 0x00000020;\nconst ACE4_DELETE_CHILD         = 0x00000040;\nconst ACE4_READ_ATTRIBUTES      = 0x00000080;\nconst ACE4_WRITE_ATTRIBUTES     = 0x00000100;\nconst ACE4_WRITE_RETENTION      = 0x00000200;\nconst ACE4_WRITE_RETENTION_HOLD = 0x00000400;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_DELETE               = 0x00010000;\nconst ACE4_READ_ACL             = 0x00020000;\nconst ACE4_WRITE_ACL            = 0x00040000;\nconst ACE4_WRITE_OWNER          = 0x00080000;\nconst ACE4_SYNCHRONIZE          = 0x00100000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that some masks have coincident values, for example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY. The mask entries ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are intended to be used with directory objects, while ACE4_READ_DATA, ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with non-directory objects.",
      "ja": "いくつかのマスクは、例えば、ACE4_READ_DATAおよびace4_list_directoryなどの一致値を持ちます。マスクエントリACE4_LIST_DIRECTORY、ACE4_ADD_FILE、およびACE4_ADD_SUBDIRECTORYはディレクトリオブジェクトと共に使用されることを意図していますが、ACE4_READ_DATA、ACE4_WRITE_DATA、およびACE4_APPEND_DATAは、ディレクトリ以外のオブジェクトで使用されることを目的としています。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3.1. Discussion of Mask Attributes",
      "section_title": true,
      "ja": "6.2.1.3.1. マスク属性の説明"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_DATA",
      "ja": "ACE4_READ_DATA"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: READ",
      "ja": "操作の影響を受ける：読み取り"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to read the data of the file.",
      "ja": "ディスカッション：ファイルのデータを読み取る権限。"
    },
    {
      "indent": 9,
      "text": "Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed.",
      "ja": "サーバーは、ACE4_EXECUTE ACCESS MASKビットのみが許可されている場合にファイルのデータを読み取る機能をユーザーに許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_LIST_DIRECTORY",
      "ja": "ACE4_LIST_DIRECTORY"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: READDIR",
      "ja": "操作の影響を受けた操作：ReadDir"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to list the contents of a directory.",
      "ja": "ディスカッション：ディレクトリの内容を一覧表示する権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_DATA",
      "ja": "ACE4_WRITE_DATA"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: WRITE",
      "ja": "操作の影響を受ける：write."
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "SETATTR of size",
      "ja": "サイズのsetAttr"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to modify a file's data.",
      "ja": "ディスカッション：ファイルのデータを変更する権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_ADD_FILE",
      "ja": "ACE4_ADD_FILE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: CREATE",
      "ja": "操作の影響を受ける：創造"
    },
    {
      "indent": 9,
      "text": "LINK",
      "ja": "リンク"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "ren ren"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to add a new file in a directory. The CREATE operation is affected when nfs_ftype4 is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. (NF4DIR is not listed because it is covered by ACE4_ADD_SUBDIRECTORY.) OPEN is affected when used to create a regular file. LINK and RENAME are always affected.",
      "ja": "ディスカッション：ディレクトリに新しいファイルを追加する権限。NFS_FTYPE4がNF4LNK、NF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOの場合、作成操作は影響を受けます。（NF4DIRはACE4_ADD_SUBDIRECTORYでカバーされているため、リストされていません。）通常のファイルを作成するために使用されると、開くことは影響を受けます。リンクと名前の変更は常に影響を受けます。"
    },
    {
      "indent": 3,
      "text": "ACE4_APPEND_DATA",
      "ja": "ale4_append_data"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: WRITE",
      "ja": "操作の影響を受ける：write."
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "SETATTR of size",
      "ja": "サイズのsetAttr"
    },
    {
      "indent": 6,
      "text": "Discussion: The ability to modify a file's data, but only starting at EOF. This allows for the notion of append-only files, by allowing ACE4_APPEND_DATA and denying ACE4_WRITE_DATA to the same user or group. If a file has an ACL such as the one described above and a WRITE request is made for somewhere other than EOF, the server SHOULD return NFS4ERR_ACCESS.",
      "ja": "ディスカッション：ファイルのデータを変更する機能は、EOFからだけ開始されます。これにより、ACE4_APPEND_DATAを許可し、同じユーザーまたはグループにACE4_WRITE_DATAを拒否することで、Append-Onlyファイルの概念を可能にします。ファイルが上記のようなACLを持ち、EOF以外の方法で書き込み要求が行われた場合、サーバーはNFS4ERR_ACCESSを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_ADD_SUBDIRECTORY",
      "ja": "ACE4_ADD_SUBDIRECTORY"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: CREATE",
      "ja": "操作の影響を受ける：創造"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "ren ren"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to create a subdirectory in a directory. The CREATE operation is affected when nfs_ftype4 is NF4DIR. The RENAME operation is always affected.",
      "ja": "ディスカッション：ディレクトリにサブディレクトリを作成する権限。NFS_FTYPE4がNF4DIRの場合、作成操作は影響を受けます。名前の変更操作は常に影響を受けます。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_NAMED_ATTRS",
      "ja": "ACE4_READ_NADED_ATTRS."
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: OPENATTR",
      "ja": "操作の影響を受ける：Openattr."
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to read the named attributes of a file or to look up the named attribute directory. OPENATTR is affected when it is not used to create a named attribute directory. This is when 1) createdir is TRUE, but a named attribute directory already exists, or 2) createdir is FALSE.",
      "ja": "ディスカッション：ファイルの名前付き属性を読み取る権限または名前付き属性ディレクトリを検索する権限。openattrは、名前付き属性ディレクトリを作成するために使用されない場合に影響を受けます。これは1）CreatectIRがtrueですが、名前付き属性ディレクトリは既に存在する、または2）Createctirがfalseです。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_NAMED_ATTRS",
      "ja": "ACE4_WRITE_NADED_ATTRS."
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: OPENATTR",
      "ja": "操作の影響を受ける：Openattr."
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to write the named attributes of a file or to create a named attribute directory. OPENATTR is affected when it is used to create a named attribute directory. This is when createdir is TRUE and no named attribute directory exists. The ability to check whether or not a named attribute directory exists depends on the ability to look it up; therefore, users also need the ACE4_READ_NAMED_ATTRS permission in order to create a named attribute directory.",
      "ja": "ディスカッション：ファイルの名前付き属性を書き込む権限または名前付き属性ディレクトリを作成する権限。openattrは、名前付き属性ディレクトリを作成するために使用されるときに影響を受けます。これはCreatectirがTrueで、名前付き属性ディレクトリが存在しない場合です。名前付き属性ディレクトリが存在するかどうかを確認する機能は、それを検索する機能によって異なります。したがって、名前付き属性ディレクトリを作成するために、ユーザーはACE4_READ_NADED_ATTRS権限を必要とします。"
    },
    {
      "indent": 3,
      "text": "ACE4_EXECUTE",
      "ja": "ACE4_EXECUTE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: READ",
      "ja": "操作の影響を受ける：読み取り"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "REMOVE",
      "ja": "削除する"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "ren ren"
    },
    {
      "indent": 9,
      "text": "LINK",
      "ja": "リンク"
    },
    {
      "indent": 9,
      "text": "CREATE",
      "ja": "創造する"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to execute a file.",
      "ja": "ディスカッション：ファイルを実行する権限。"
    },
    {
      "indent": 9,
      "text": "Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed. This is because there is no way to execute a file without reading the contents. Though a server may treat ACE4_EXECUTE and ACE4_READ_DATA bits identically when deciding to permit a READ operation, it SHOULD still allow the two bits to be set independently in ACLs, and MUST distinguish between them when replying to ACCESS operations. In particular, servers SHOULD NOT silently turn on one of the two bits when the other is set, as that would make it impossible for the client to correctly enforce the distinction between read and execute permissions.",
      "ja": "サーバーは、ACE4_EXECUTE ACCESS MASKビットのみが許可されている場合にファイルのデータを読み取る機能をユーザーに許可する必要があります。内容を読むことなくファイルを実行する方法がないためです。読み取り操作を許可するように決定するときは、サーバーはICE4_EXECUTEおよびACE4_READ_DATAビットを同じように扱うことができますが、2ビットをACLで独立して設定することもできます。アクセス操作に返信するときにそれらを区別する必要があります。特に、サーバーは、他方が設定されているときに2ビットのうちの1つを静かにしてはいけません。これにより、クライアントが読み取りアクセス許可と実行許可の間の区別を正しく適用できなくなります。"
    },
    {
      "indent": 9,
      "text": "As an example, following a SETATTR of the following ACL:",
      "ja": "例として、次のACLのSETATTRに従って："
    },
    {
      "indent": 12,
      "text": "nfsuser:ACE4_EXECUTE:ALLOW",
      "ja": "NFSUSER：ACE4_EXECUTE：allow."
    },
    {
      "indent": 9,
      "text": "A subsequent GETATTR of ACL for that file SHOULD return:",
      "ja": "そのファイルのACLの後続のgetAttrは次のように返されます。"
    },
    {
      "indent": 12,
      "text": "nfsuser:ACE4_EXECUTE:ALLOW",
      "ja": "NFSUSER：ACE4_EXECUTE：allow."
    },
    {
      "indent": 9,
      "text": "Rather than:",
      "ja": "のではなく："
    },
    {
      "indent": 12,
      "text": "nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ACE4_EXECUTE",
      "ja": "ACE4_EXECUTE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: LOOKUP",
      "ja": "操作の影響を受けた：ルックアップ"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to traverse/search a directory.",
      "ja": "ディスカッション：ディレクトリをトラバース/検索する権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_DELETE_CHILD",
      "ja": "ACE4_DELETE_CHILD"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: REMOVE",
      "ja": "操作の影響を受ける：削除します"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "ren ren"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to delete a file or directory within a directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.",
      "ja": "ディスカッション：ディレクトリ内のファイルまたはディレクトリを削除する権限。ACE4_DELETEおよびACE4_DELETE_CHILD INTORACTについては、6.2.1.3.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_ATTRIBUTES",
      "ja": "ACE4_READ_ATTRIBUTES"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: GETATTR of file system object attributes",
      "ja": "操作の影響を受ける：ファイルシステムオブジェクト属性のgetAttr"
    },
    {
      "indent": 9,
      "text": "VERIFY",
      "ja": "確認"
    },
    {
      "indent": 9,
      "text": "NVERIFY",
      "ja": "n n"
    },
    {
      "indent": 9,
      "text": "READDIR",
      "ja": "readdir."
    },
    {
      "indent": 6,
      "text": "Discussion: The ability to read basic attributes (non-ACLs) of a file. On a UNIX system, basic attributes can be thought of as the stat-level attributes. Allowing this access mask bit would mean that the entity can execute \"ls -l\" and stat. If a READDIR operation requests attributes, this mask must be allowed for the READDIR to succeed.",
      "ja": "ディスカッション：ファイルの基本属性（ACL以外）を読み取る機能。UNIXシステムでは、基本属性をSTATレベル属性として考えることができます。このアクセスマスクビットを許可すると、エンティティは \"LS -L\"とstatを実行できることを意味します。READDIRオペレーションが属性を要求した場合、READDIRが成功するためにこのマスクを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_ATTRIBUTES",
      "ja": "ACE4_WRITE_ATTRIBUTES"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: SETATTR of time_access_set, time_backup,",
      "ja": "操作の影響を受ける：setAttrのtime_access_set、time_backup、"
    },
    {
      "indent": 9,
      "text": "time_create, time_modify_set, mimetype, hidden, system",
      "ja": "time_create、time_modify_set、mimeType、非表示、システム"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to change the times associated with a file or directory to an arbitrary value. Also permission to change the mimetype, hidden, and system attributes. A user having ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed to set the times associated with a file to the current server time.",
      "ja": "ディスカッション：ファイルまたはディレクトリに関連付けられている時間を任意の値に変更する権限。MimeType、非表示、およびシステム属性を変更する権限もあります。ACE4_WRITE_DATAまたはACE4_WRITE_ATTRIBUTESを持つユーザーは、ファイルに関連付けられている時間を現在のサーバー時間に設定することを許可されます。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_RETENTION",
      "ja": "ACE4_WRITE_RETENTER."
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: SETATTR of retention_set, retentevt_set.",
      "ja": "操作の影響を受ける：retention_setのsetAttr、retentevt_set。"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to modify the durations of event and non-event-based retention. Also permission to enable event and non-event-based retention. A server MAY behave such that setting ACE4_WRITE_ATTRIBUTES allows ACE4_WRITE_RETENTION.",
      "ja": "議論：イベントおよび非イベントベースの保持の期間を変更する権限。イベントおよび非イベントベースの保存を有効にする権限。ACE4_WRITE_ATTRIBUTESの設定がACE4_WRITE_RETENTIONを許可するようにサーバーが動作します。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_RETENTION_HOLD",
      "ja": "ale4_write_retention_hold."
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: SETATTR of retention_hold.",
      "ja": "操作の影響を受けた：retention_holdのsetAttr。"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to modify the administration retention holds. A server MAY map ACE4_WRITE_ATTRIBUTES to ACE_WRITE_RETENTION_HOLD.",
      "ja": "議論：管理維持管理を変更する権限。サーバーはACE4_WRITE_ATTRIBUTESをACE_WRITE_RETENTIONS_HOLD_HOLSをマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "ACE4_DELETE",
      "ja": "ACE4_DELETE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: REMOVE",
      "ja": "操作の影響を受ける：削除します"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to delete the file or directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.",
      "ja": "ディスカッション：ファイルまたはディレクトリを削除する権限。ACE4_DELETEおよびACE4_DELETE_CHILD INTORACTについては、6.2.1.3.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_ACL",
      "ja": "ACE4_READ_ACL"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: GETATTR of acl, dacl, or sacl",
      "ja": "影響を受ける操作：ACL、DACL、またはSACLのGETATTR"
    },
    {
      "indent": 9,
      "text": "NVERIFY",
      "ja": "n n"
    },
    {
      "indent": 9,
      "text": "VERIFY",
      "ja": "確認"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to read the ACL.",
      "ja": "議論：ACLを読む許可。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_ACL",
      "ja": "ACE4_WRITE_ACL"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: SETATTR of acl and mode",
      "ja": "操作の影響を受ける：ACLとモードのSETATTR"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to write the acl and mode attributes.",
      "ja": "ディスカッション：ACL属性とモード属性を書き込む権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_OWNER",
      "ja": "ACE4_WRITE_OWNER"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: SETATTR of owner and owner_group",
      "ja": "操作の影響を受ける：所有者とowner_groupのsetAttr"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to write the owner and owner_group attributes. On UNIX systems, this is the ability to execute chown() and chgrp().",
      "ja": "ディスカッション：所有者およびowner_group属性を書く権限。UNIXシステムでは、これがchown（）とchgrp（）を実行する機能です。"
    },
    {
      "indent": 3,
      "text": "ACE4_SYNCHRONIZE",
      "ja": "ACE4_SYNCHONIZE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected: NONE",
      "ja": "操作の影響を受ける：なし"
    },
    {
      "indent": 6,
      "text": "Discussion: Permission to use the file object as a synchronization primitive for interprocess communication. This permission is not enforced or interpreted by the NFSv4.1 server on behalf of the client.",
      "ja": "ディスカッション：ファイルオブジェクトをプロセス間通信用の同期プリミティブとして使用する権限。この権限は、クライアントに代わってNFSV4.1サーバーによって適用または解釈されません。"
    },
    {
      "indent": 9,
      "text": "Typically, the ACE4_SYNCHRONIZE permission is only meaningful on local file systems, i.e., file systems not accessed via NFSv4.1. The reason that the permission bit exists is that some operating environments, such as Windows, use ACE4_SYNCHRONIZE.",
      "ja": "通常、ACE4_SYNCHONIZE権限は、ローカルファイルシステム、すなわちNFSv4.1を介してアクセスされていないファイルシステムでのみ意味があります。許可ビットが存在する理由は、Windowsなどのいくつかのオペレーティング環境がACE4_SYNCRONIZEを使用することです。"
    },
    {
      "indent": 9,
      "text": "For example, if a client copies a file that has ACE4_SYNCHRONIZE set from a local file system to an NFSv4.1 server, and then later copies the file from the NFSv4.1 server to a local file system, it is likely that if ACE4_SYNCHRONIZE was set in the original file, the client will want it set in the second copy. The first copy will not have the permission set unless the NFSv4.1 server has the means to set the ACE4_SYNCHRONIZE bit. The second copy will not have the permission set unless the NFSv4.1 server has the means to retrieve the ACE4_SYNCHRONIZE bit.",
      "ja": "たとえば、クライアントがローカルファイルシステムからNFSV4.1サーバーに設定されているファイルをコピーし、後でファイルをNFSV4.1サーバーからローカルファイルシステムにコピーします.ACE4_Synchronizeがあった場合元のファイルに設定されている場合、クライアントは2番目のコピーに設定されます。NFSV4.1サーバーにACE4_SYNCHONSINIZEビットを設定する手段がない限り、最初のコピーには許可セットはありません。NFSV4.1サーバーにACE4_SYNCHONSINIZEビットを取得するための手段がない限り、2番目のコピーには許可セットはありません。"
    },
    {
      "indent": 3,
      "text": "Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish ACE4_APPEND_DATA (the ability to append to a file) from ACE4_WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single \"write\" permission [17]. When such a server returns attributes to the client, it would show both ACE4_APPEND_DATA and ACE4_WRITE_DATA if and only if the write permission is enabled.",
      "ja": "サーバーの実装は、このマスクのリストによって暗示されている制御の粒度を提供する必要はありません。たとえば、POSIXベースのシステムは、ACE4_APPEND_DATA（ファイルに追加する機能）をACE4_WRITE_DATA（既存のコンテンツを変更する機能）を区別することはできません。どちらのマスクも単一の「書き込み」許可に結び付けられます[17]。そのようなサーバがクライアントに属性を返すと、書き込み権限が有効になっている場合に限り、ACE4_APPEND_DATAとACE4_WRITE_DATAの両方が表示されます。"
    },
    {
      "indent": 3,
      "text": "If a server receives a SETATTR request that it cannot accurately implement, it should err in the direction of more restricted access, except in the previously discussed cases of execute and read. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ALLOW ACE where ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or vice versa), the server should either turn off ACE4_APPEND_DATA or reject the request with NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバーが正確に実装できないSETATTR要求を受信した場合は、以前に説明されているEXECUTEおよびREADの場合を除いて、より制限されたアクセスの方向にERRを実行してください。たとえば、前の段落で説明されているように、サーバーが新しいデータを追加するのを区別できないとします。ACE4_APPEND_DATAが設定されていますが、ACE4_WRITE_DATAが設定されていないACE ACEを送信する場合（またはその逆）、サーバーはACE4_APPEND_DATAをオフにするか、またはNFS4ERR_ATTRNOTSUPPで要求を拒否します。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3.2. ACE4_DELETE vs. ACE4_DELETE_CHILD",
      "section_title": true,
      "ja": "6.2.1.3.2. ACE4_DELETE対ACE4_DELETE_CHILD"
    },
    {
      "indent": 3,
      "text": "Two access mask bits govern the ability to delete a directory entry: ACE4_DELETE on the object itself (the \"target\") and ACE4_DELETE_CHILD on the containing directory (the \"parent\").",
      "ja": "2つのアクセスマスクBITSは、オブジェクト自体のACE4_DELETE（ \"ターゲット\"）およびinconsedディレクトリのACE4_DELETE_CHILD（「親」）を統括します。"
    },
    {
      "indent": 3,
      "text": "Many systems also take the \"sticky bit\" (MODE4_SVTX) on a directory to allow unlink only to a user that owns either the target or the parent; on some such systems the decision also depends on whether the target is writable.",
      "ja": "多くのシステムはまた、ディレクトリ上の「スティッキビット」（MODE4_SVTX）を取り出して、ターゲットまたは親のいずれかを所有するユーザにのみリンクします。いくつかのそのようなシステムでは、決定はターゲットが書き込み可能かどうかによっても依存します。"
    },
    {
      "indent": 3,
      "text": "Servers SHOULD allow unlink if either ACE4_DELETE is permitted on the target, or ACE4_DELETE_CHILD is permitted on the parent. (Note that this is true even if the parent or target explicitly denies one of these permissions.)",
      "ja": "ace4_deleteがターゲットで許可されている場合、サーバーはリンクリンクを許可する必要があります。（親またはターゲットがこれらの権限の1つを明示的に拒否してもこれは当てはまります。）"
    },
    {
      "indent": 3,
      "text": "If the ACLs in question neither explicitly ALLOW nor DENY either of the above, and if MODE4_SVTX is not set on the parent, then the server SHOULD allow the removal if and only if ACE4_ADD_FILE is permitted. In the case where MODE4_SVTX is set, the server may also require the remover to own either the parent or the target, or may require the target to be writable.",
      "ja": "問題のACLが明示的に上記のいずれかを明示的に許可または拒否しない場合、およびMODE4_SVTXが親に設定されていない場合、サーバーはACE4_ADD_FILEが許可されている場合に限り、サーバーは削除を許可する必要があります。MODE4_SVTXが設定されている場合、サーバーは、除去者が親またはターゲットのいずれかを所有するように要求することもできます。"
    },
    {
      "indent": 3,
      "text": "This allows servers to support something close to traditional UNIX-like semantics, with ACE4_ADD_FILE taking the place of the write bit.",
      "ja": "これにより、サーバーは伝統的なUnix様のセマンティクスに近いものをサポートし、ACE4_ADD_FILEが書き込みビットの場所を取得します。"
    },
    {
      "indent": 0,
      "text": "6.2.1.4. ACE flag",
      "section_title": true,
      "ja": "6.2.1.4. エースの国旗"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the flag field are as follows:",
      "ja": "Flagフィールドに使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_FILE_INHERIT_ACE             = 0x00000001;\nconst ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\nconst ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\nconst ACE4_INHERIT_ONLY_ACE             = 0x00000008;\nconst ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\nconst ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\nconst ACE4_IDENTIFIER_GROUP             = 0x00000040;\nconst ACE4_INHERITED_ACE                = 0x00000080;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags.",
      "ja": "サーバーはこれらのフラグをサポートする必要はありません。サーバーがこれらのフラグと正確に同じではないフラグをサポートしている場合、実装はプロトコル定義フラグと実装定義フラグとの間のマッピングを定義することができます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single \"inherit ACE\" flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.",
      "ja": "たとえば、クライアントがACE4_FILE_INHERIT_ACEセットを使用してACEを設定しようとするが、ACE4_DIRECTORY_INHERIT_ACEを設定しようとしているとします。サーバーがACL継承の形式をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーがファイルとディレクトリの両方に適用される単一の「継承ACE」フラグをサポートしている場合、サーバーは要求を拒否します（すなわち、クライアントにファイルとディレクトリの両方の継承フラグを設定する必要がある）。サーバーはまた要求を受け入れ、ace4_directory_inherit_aceフラグを静止している可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1.4.1. Discussion of Flag Bits",
      "section_title": true,
      "ja": "6.2.1.4.1. 旗ビットの議論"
    },
    {
      "indent": 3,
      "text": "ACE4_FILE_INHERIT_ACE Any non-directory file in any sub-directory will get this ACE inherited.",
      "ja": "ACE4_FILE_INHERIT_ACE任意のサブディレクトリ内のディレクトリー以外のファイルが継承されます。"
    },
    {
      "indent": 3,
      "text": "ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created.",
      "ja": "ACE4_DIRECTORY_INHERIT_ACEはディレクトリに配置でき、このACEを作成した各ディレクトリに追加する必要があることを示します。"
    },
    {
      "indent": 6,
      "text": "If this flag is set in an ACE in an ACL attribute to be set on a non-directory file system object, the operation attempting to set the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.",
      "ja": "このフラグが、ディレクトリ以外のファイルシステムオブジェクトに設定されるACL属性のACEに設定されている場合、ACLを設定しようとした操作はNFS4ERR_ATTRNOWPPで失敗する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. This flag tells the server that inheritance of this ACE should stop at newly created child directories.",
      "ja": "ACE4_NO_PROPAGAT_INHERIT_ACEはディレクトリに配置できます。このフラグは、このACEの継承が新しく作成された子ディレクトリで停止する必要があることをサーバーに指示します。"
    },
    {
      "indent": 3,
      "text": "ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory; ALLOW and DENY ACEs with this bit set do not affect access to the directory, and AUDIT and ALARM ACEs with this bit set do not trigger log or alarm events. Such ACEs only take effect once they are applied (with this bit cleared) to newly created files and directories as specified by the ACE4_FILE_INHERIT_ACE and ACE4_DIRECTORY_INHERIT_ACE flags.",
      "ja": "ACE4_INHERIT_ONLY_ACEはディレクトリに配置できますが、ディレクトリには適用されません。このビットセットを使用してACEを許可および拒否するディレクトリへのアクセスには影響しません。このビットセットを使用した監査とアラームACEはログまたはアラームイベントをトリガしません。そのようなACEは、ACE4_FILE_INHERIT_ACEおよびACE4_DIRECTORY_INHERIT_ACEフラグによって指定されたように、それらが（このビットクリアされた）ファイルおよびディレクトリーに適用されると（このビットがクリアされた）ことだけを有効にします。"
    },
    {
      "indent": 6,
      "text": "If this flag is present on an ACE, but neither ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE is present, then an operation attempting to set such an attribute SHOULD fail with NFS4ERR_ATTRNOTSUPP.",
      "ja": "このフラグがACEに存在するが、ale4_directory_inherit_aceもace4_file_inherit_aceも存在しない場合、そのような属性を設定しようとする操作はNFS4ERR_ATTRNOWPPで失敗する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_SUCCESSFUL_ACCESS_ACE_FLAG and ACE4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits may be set only on ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If during the processing of the file's ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact, and the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, it then notes if the operation succeeded or failed. If the operation succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. If the operation failed, and if the FAILED flag was set for the matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. Either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.",
      "ja": "ACE4_SUCCESSFUR_ACCESS_ACE_FLAGとACE4_FAILED_ACCESS_ACE_FLAG ACE4_SUCCESSFUL_ACCESS_ACES_FLAG（成功）とACE4_FAILED_ACCESS_ACE_FLAG（故障）フラグビットは、ACE4_SYSTEM_AUDIT_ACE_AACE_TYPE（監査）およびACE4_SYSTEM_ALARM_ACE_TYPE（ALARM）ACEタイプでのみ設定できます。ファイルのACLの処理中に、サーバーは、オープンを試みるプリンシパルと一致する監査またはアラームACEに遭遇し、その事実、および監査またはアラームで発生した成功と失敗のフラグの有無を示します。エース。サーバーがACL処理を完了すると、操作が成功または失敗した場合は注意してください。操作が成功した場合、一致する監査またはアラームACEに成功フラグが設定されている場合は、適切な監査またはアラームイベントが発生します。操作に失敗した場合、および障害のあるフラグが一致する監査またはアラームACEに設定された場合、適切な監査またはアラームイベントが発生します。成功または失敗のどちらかまたは両方を設定することができますが、どちらに設定されていない場合、監査またはアラームACEは役に立ちません。"
    },
    {
      "indent": 6,
      "text": "The previously described processing applies to ACCESS operations even when they return NFS4_OK. For the purposes of AUDIT and ALARM, we consider an ACCESS operation to be a \"failure\" if it fails to return a bit that was requested and supported.",
      "ja": "前述の処理は、NFS4_OKを返す場合でもアクセス動作に適用されます。監査とアラームの目的のために、要求されサポートされたビットを返すことができない場合は、アクセス動作を「失敗」になると見なします。"
    },
    {
      "indent": 3,
      "text": "ACE4_IDENTIFIER_GROUP Indicates that the \"who\" refers to a GROUP as defined under UNIX or a GROUP ACCOUNT as defined under Windows. Clients and servers MUST ignore the ACE4_IDENTIFIER_GROUP flag on ACEs with a who value equal to one of the special identifiers outlined in Section 6.2.1.5.",
      "ja": "ACE4_IDENTIFIER_GROUP Windowsで定義されているUNIXまたはグループアカウントで定義されているグループを「Who」と参照することを示します。クライアントとサーバーは、ACEのACE4_IDENTIFIER_GROUPフラグを6.2.1.5項で概説されている特殊識別子の1つに等しい値を指定して、ACES上のACE4_IDENTIFIER_GROUPフラグを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_INHERITED_ACE Indicates that this ACE is inherited from a parent directory. A server that supports automatic inheritance will place this flag on any ACEs inherited from the parent directory when creating a new object. Client applications will use this to perform automatic inheritance. Clients and servers MUST clear this bit in the acl attribute; it may only be used in the dacl and sacl attributes.",
      "ja": "ACE4_INHERTITED_ACEこのACEが親ディレクトリから継承されていることを示します。自動継承をサポートするサーバーは、新しいオブジェクトを作成するときに、親ディレクトリから継承されたACEにこのフラグを配置します。クライアントアプリケーションはこれを使用して自動継承を実行します。クライアントとサーバーはACL属性でこのビットをクリアする必要があります。DACL属性とSACLの属性でのみ使用できます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.5. ACE Who",
      "section_title": true,
      "ja": "6.2.1.5. エースだ"
    },
    {
      "indent": 3,
      "text": "The \"who\" field of an ACE is an identifier that specifies the principal or principals to whom the ACE applies. It may refer to a user or a group, with the flag bit ACE4_IDENTIFIER_GROUP specifying which.",
      "ja": "ACEの「WHO」フィールドは、ACEが適用されるプリンシパルまたはプリンシパルを指定する識別子です。これは、ユーザーまたはグループを参照することがあります。これを指定するフラグビットACE4_IDENTIFIER_GROUP。"
    },
    {
      "indent": 3,
      "text": "There are several special identifiers that need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understands the identifiers.",
      "ja": "特定のDNSドメインのコンテキストではなく、普遍的に理解される必要があるいくつかの特別な識別子がある。NFSクライアントがサーバーにアクセスしたが、ローカルプロセスがファイルにアクセスしたときに意味を持つ場合には、これらの識別子の一部を理解できません。サーバー上のアクセスメソッドが識別子を理解していなくても、これらの権限を表示および変更する機能はNFSを介して許可されます。"
    },
    {
      "indent": 3,
      "text": "+===============+==================================================+\n| Who           | Description                                      |\n+===============+==================================================+\n| OWNER         | The owner of the file.                           |\n+---------------+--------------------------------------------------+\n| GROUP         | The group associated with the file.              |\n+---------------+--------------------------------------------------+\n| EVERYONE      | The world, including the owner and owning group. |\n+---------------+--------------------------------------------------+\n| INTERACTIVE   | Accessed from an interactive terminal.           |\n+---------------+--------------------------------------------------+\n| NETWORK       | Accessed via the network.                        |\n+---------------+--------------------------------------------------+\n| DIALUP        | Accessed as a dialup user to the server.         |\n+---------------+--------------------------------------------------+\n| BATCH         | Accessed from a batch job.                       |\n+---------------+--------------------------------------------------+\n| ANONYMOUS     | Accessed without any authentication.             |\n+---------------+--------------------------------------------------+\n| AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).  |\n+---------------+--------------------------------------------------+\n| SERVICE       | Access from a system service.                    |\n+---------------+--------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 7",
      "ja": "表7."
    },
    {
      "indent": 3,
      "text": "To avoid conflict, these special identifiers are distinguished by an appended \"@\" and should appear in the form \"xxxx@\" (with no domain name after the \"@\"), for example, ANONYMOUS@.",
      "ja": "競合を回避するために、これらの特別な識別子は追加された \"@\"によって区別され、 \"xxxx @\"の形式（ \"@\"の後にドメイン名がない）に表示されるべきです（例えば、anonymous @）。"
    },
    {
      "indent": 3,
      "text": "The ACE4_IDENTIFIER_GROUP flag MUST be ignored on entries with these special identifiers. When encoding entries with these special identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.",
      "ja": "ACE4_IDENTIFIER_GROUPフラグは、これらの特別な識別子を持つエントリでは無視されなければなりません。これらの特別な識別子を使用してエントリを符号化するときは、ace4_identifier_groupフラグをゼロに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1.5.1. Discussion of EVERYONE@",
      "section_title": true,
      "ja": "6.2.1.5.1. 皆の議論@"
    },
    {
      "indent": 3,
      "text": "It is important to note that \"EVERYONE@\" is not equivalent to the UNIX \"other\" entity. This is because, by definition, UNIX \"other\" does not include the owner or owning group of a file. \"EVERYONE@\" means literally everyone, including the owner or owning group.",
      "ja": "「皆@」がUNIXの「その他」エンティティと同等ではないことに注意することが重要です。これは、定義によって、UNIXの「その他」にファイルの所有者または所有グループが含まれていないためです。「皆さん@」は、所有者または所有グループを含むすべての人が文字通り全員を意味します。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Attribute 58: dacl",
      "section_title": true,
      "ja": "6.2.2. 属性58：DACL."
    },
    {
      "indent": 3,
      "text": "The dacl attribute is like the acl attribute, but dacl allows just ALLOW and DENY ACEs. The dacl attribute supports automatic inheritance (see Section 6.4.3.2).",
      "ja": "DACL属性はACL属性のようなものですが、DACLはACEを許可して拒否するだけです。DACL属性は自動継承をサポートしています（6.4.3.2項を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Attribute 59: sacl",
      "section_title": true,
      "ja": "6.2.3. 属性59：SACL."
    },
    {
      "indent": 3,
      "text": "The sacl attribute is like the acl attribute, but sacl allows just AUDIT and ALARM ACEs. The sacl attribute supports automatic inheritance (see Section 6.4.3.2).",
      "ja": "SACL属性はACL属性のようなものですが、SACLでは監査とアラームACEを使用できます。SACL属性は自動継承をサポートしています（6.4.3.2項を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Attribute 33: mode",
      "section_title": true,
      "ja": "6.2.4. 属性33：モード"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 mode attribute is based on the UNIX mode bits. The following bits are defined:",
      "ja": "NFSV4.1モード属性は、UNIXモードビットに基づいています。以下のビットが定義されています。"
    },
    {
      "indent": 3,
      "text": "const MODE4_SUID = 0x800;  /* set user id on execution */\nconst MODE4_SGID = 0x400;  /* set group id on execution */\nconst MODE4_SVTX = 0x200;  /* save text even after use */\nconst MODE4_RUSR = 0x100;  /* read permission: owner */\nconst MODE4_WUSR = 0x080;  /* write permission: owner */\nconst MODE4_XUSR = 0x040;  /* execute permission: owner */\nconst MODE4_RGRP = 0x020;  /* read permission: group */\nconst MODE4_WGRP = 0x010;  /* write permission: group */\nconst MODE4_XGRP = 0x008;  /* execute permission: group */\nconst MODE4_ROTH = 0x004;  /* read permission: other */\nconst MODE4_WOTH = 0x002;  /* write permission: other */\nconst MODE4_XOTH = 0x001;  /* execute permission: other */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP apply to principals identified in the owner_group attribute but who are not identified in the owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply to any principal that does not match that in the owner attribute and does not have a group matching that of the owner_group attribute.",
      "ja": "BITS MODE4_RUSR、MODE4_WUSR、およびMODE4_XUSRは、所有者属性で識別されているプリンシパルに適用されます。BITS MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRPは、owner_group属性で識別されたプリンシパルに適用されますが、所有者属性では識別されません。BITS MODE4_ROTH、MODE4_WOTH、およびMODE4_XOTSは、所有者属性のそれと一致しないプリンシパルに適用され、owner_group属性のグループが一致するグループがありません。"
    },
    {
      "indent": 3,
      "text": "Bits within a mode other than those specified above are not defined by this protocol. A server MUST NOT return bits other than those defined above in a GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL if bits other than those defined above are set in a SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.",
      "ja": "上記以外のモード内のビットは、このプロトコルによって定義されていません。サーバーは、getAttrまたはReadDir操作で上で定義したもの以外のビットを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.5. Attribute 74: mode_set_masked",
      "section_title": true,
      "ja": "6.2.5. 属性74：mode_set_masked"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute is a write-only attribute that allows individual bits in the mode attribute to be set or reset, without changing others. It allows, for example, the bits MODE4_SUID, MODE4_SGID, and MODE4_SVTX to be modified while leaving unmodified any of the nine low-order mode bits devoted to permissions.",
      "ja": "mode_set_masked属性は、他のビットを変更することなく、モード属性の個々のビットを設定またはリセットできるようにするライトオンリー属性です。それは、例えば、許可に費やされる9つの下位モードビットのいずれかを変更しながら、変更されるべきビットMODE4_SUID、MODE4_SGID、およびMODE4_SVTXを変更することを可能にする。"
    },
    {
      "indent": 3,
      "text": "In such instances that the nine low-order bits are left unmodified, then neither the acl nor the dacl attribute should be automatically modified as discussed in Section 6.4.1.",
      "ja": "そのような場合には、9つの下位ビットが変更されずに変更されていないため、6.4.1項で説明したようにACL属性もDACL属性も自動変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute consists of two words, each in the form of a mode4. The first consists of the value to be applied to the current mode value and the second is a mask. Only bits set to one in the mask word are changed (set or reset) in the file's mode. All other bits in the mode remain unchanged. Bits in the first word that correspond to bits that are zero in the mask are ignored, except that undefined bits are checked for validity and can result in NFS4ERR_INVAL as described below.",
      "ja": "mode_set_masked属性は、それぞれMODE4の形で2つの単語で構成されています。最初に現在のモード値に適用される値と2番目のものはマスクで構成されています。マスクワード内の1つに設定されているビットだけがファイルのモードで変更（設定またはリセット）されます。モードの他のすべてのビットは変更されません。マスク内でゼロのビットに対応する最初の単語のビットは無視され、未定義のビットが有効性がチェックされ、以下に説明するようにNFS4ERR_INVALになる可能性がある。"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute is only valid in a SETATTR operation. If it is used in a CREATE or OPEN operation, the server MUST return NFS4ERR_INVAL.",
      "ja": "mode_set_masked属性はSETATTR操作でのみ有効です。作成またはオープン操作で使用されている場合、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Bits not defined as valid in the mode attribute are not valid in either word of the mode_set_masked attribute. The server MUST return NFS4ERR_INVAL if any such bits are set to one in a SETATTR. If the mode and mode_set_masked attributes are both specified in the same SETATTR, the server MUST also return NFS4ERR_INVAL.",
      "ja": "モード属性で有効で定義されていないビットは、mode_set_masked属性のどちらのワードでも無効です。SETATTRのそのようなビットが1つに設定されている場合、サーバーはNFS4ERR_INVALを返す必要があります。モードとMODE_SET_MASKED属性が両方とも同じSETATTRで指定されている場合、サーバーもNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Common Methods",
      "section_title": true,
      "ja": "6.3. 一般的な方法"
    },
    {
      "indent": 3,
      "text": "The requirements in this section will be referred to in future sections, especially Section 6.4.",
      "ja": "このセクションの要件は、将来のセクション、特にセクション6.4で参照されます。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Interpreting an ACL",
      "section_title": true,
      "ja": "6.3.1. ACLの解釈"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Server Considerations",
      "section_title": true,
      "ja": "6.3.1.1. サーバーの考慮事項"
    },
    {
      "indent": 3,
      "text": "The server uses the algorithm described in Section 6.2.1 to determine whether an ACL allows access to an object. However, the ACL might not be the sole determiner of access. For example:",
      "ja": "サーバーは、6.2.1項に記載されているアルゴリズムを使用して、ACLがオブジェクトへのアクセスを許可するかどうかを判断します。ただし、ACLはアクセスの唯一の決定ビルではない可能性があります。例えば："
    },
    {
      "indent": 3,
      "text": "* In the case of a file system exported as read-only, the server may deny write access even though an object's ACL grants it.",
      "ja": "* 読み取り専用としてエクスポートされたファイルシステムの場合、オブジェクトのACLがそれを許可していてもサーバは書き込みアクセスを拒否することがあります。"
    },
    {
      "indent": 3,
      "text": "* Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL permissions to prevent a situation from arising in which there is no valid way to ever modify the ACL.",
      "ja": "* サーバー実装は、ACLを変更するための有効な方法がないという状況が発生しないことを防ぐために、ACE4_WRITE_ACLおよびACE4_READ_ACL権限を付与することができます。"
    },
    {
      "indent": 3,
      "text": "* All servers will allow a user the ability to read the data of the file when only the execute permission is granted (i.e., if the ACL denies the user the ACE4_READ_DATA access and allows the user ACE4_EXECUTE, the server will allow the user to read the data of the file).",
      "ja": "* すべてのサーバーは、実行権限のみが許可されたときに（つまり、ACLがACLがユーザーを拒否し、ユーザーACE4_EXECUTEを許可する場合、ユーザーがユーザーがユーザーがユーザーがユーザーが読み取ることを許可することをユーザーに読み取ることができます。ファイルの）"
    },
    {
      "indent": 3,
      "text": "* Many servers have the notion of owner-override in which the owner of the object is allowed to override accesses that are denied by the ACL. This may be helpful, for example, to allow users continued access to open files on which the permissions have changed.",
      "ja": "* 多くのサーバーは、オブジェクトの所有者がACLによって拒否されたアクセスをオーバーライドすることを許可されている所有者のオーバーライドの概念を持っています。たとえば、ユーザーがアクセス許可が変更されたオープンファイルへのアクセスを継続できるようにするために役立ちます。"
    },
    {
      "indent": 3,
      "text": "* Many servers have the notion of a \"superuser\" that has privileges beyond an ordinary user. The superuser may be able to read or write data or metadata in ways that would not be permitted by the ACL.",
      "ja": "* 多くのサーバーは、通常のユーザーを超えた特権を持つ「スーパーユーザー」の概念を持っています。スーパーユーザーは、ACLによって許可されない方法でデータまたはメタデータを読み書きすることができます。"
    },
    {
      "indent": 3,
      "text": "* A retention attribute might also block access otherwise allowed by ACLs (see Section 5.13).",
      "ja": "* 保持属性は、ACLによってそうでなければ許可されているアクセスをブロックすることもあります（セクション5.13を参照）。"
    },
    {
      "indent": 0,
      "text": "6.3.1.2. Client Considerations",
      "section_title": true,
      "ja": "6.3.1.2. クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT do their own access checks based on their interpretation of the ACL, but rather use the OPEN and ACCESS operations to do access checks. This allows the client to act on the results of having the server determine whether or not access should be granted based on its interpretation of the ACL.",
      "ja": "クライアントはACLの解釈に基づいて独自のアクセスチェックを行ってはいけませんが、むしろアクセスチェックを行うためにオープン操作とアクセス操作を使用してください。これにより、クライアントは、ACLの解釈に基づいてアクセスが許可されているかどうかをサーバーに決定した結果に行動することができます。"
    },
    {
      "indent": 3,
      "text": "Clients must be aware of situations in which an object's ACL will define a certain access even though the server will not enforce it. In general, but especially in these situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client MAY send the appropriate ACCESS operation prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server doesn't enforce, see Section 6.3.1.1.",
      "ja": "クライアントは、サーバーがそれを執行しないにもかかわらず、オブジェクトのACLが特定のアクセスを定義する状況に注意する必要があります。一般に、特にこれらの状況では、クライアントはACLによって定義されたアクセスの執行においてその部分をする必要があります。これを行うために、クライアントは、ユーザまたはアプリケーションがアクセス要求されたアクセスを許可されるべきかどうかを判断するために、ユーザまたはアプリケーションの要求を処理する前に適切なアクセス動作を送信することができる。ACLがサーバーが執行していないアクセスを定義できる例については、6.3.1.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Computing a Mode Attribute from an ACL",
      "section_title": true,
      "ja": "6.3.2. ACLからMODE属性を計算します"
    },
    {
      "indent": 3,
      "text": "The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.",
      "ja": "次の方法を使用して、ACLに基づいてMODE4_R *、MODE4_W *、およびMODE属性のMODE4_X *ビットを計算することができます。"
    },
    {
      "indent": 3,
      "text": "First, for each of the special identifiers OWNER@, GROUP@, and EVERYONE@, evaluate the ACL in order, considering only ALLOW and DENY ACEs for the identifier EVERYONE@ and for the identifier under consideration. The result of the evaluation will be an NFSv4 ACL mask showing exactly which bits are permitted to that identifier.",
      "ja": "まず、特別な識別子の所有者@、Group @、およびhveryn @のそれぞれについて、ACLを順番に評価し、識別子@および検討中の識別子の識別子のACEを許可および拒否します。評価結果は、どのビットがその識別子に許可されているかを正確に示すNFSV4 ACLマスクになります。"
    },
    {
      "indent": 3,
      "text": "Then translate the calculated mask for OWNER@, GROUP@, and EVERYONE@ into mode bits for, respectively, the user, group, and other, as follows:",
      "ja": "次に、計算されたマスクを所有者@、Group @、およびhomeing @に、それぞれユーザー、グループ、その他のモードビットに変換します。"
    },
    {
      "indent": 3,
      "text": "1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.",
      "ja": "1. ace4_read_dataが対応するマスクに設定されている場合に限り、読み取りビット（MODE4_RUSR、MODE4_RGRP、またはMODE4_ROTH）を設定します。"
    },
    {
      "indent": 3,
      "text": "2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.",
      "ja": "2. ACE4_WRITE_DATAとACE4_APPEND_DATAが両方とも対応するマスクに設定されている場合に限り、書き込みビット（MODE4_WUSR、MODE4_WGRP、またはMODE4_WOTH）を設定します。"
    },
    {
      "indent": 3,
      "text": "3. Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if and only if ACE4_EXECUTE is set in the corresponding mask.",
      "ja": "3. 対応するマスクにace4_executeが設定されている場合に限り、EXECUTEビット（MODE4_XUSR、MODE4_XGRP、またはMODE4_XOTH）を設定します。"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. Discussion",
      "section_title": true,
      "ja": "6.3.2.1. 考察"
    },
    {
      "indent": 3,
      "text": "Some server implementations also add bits permitted to named users and groups to the group bits (MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP).",
      "ja": "一部のサーバー実装は、名前付きユーザーとグループとグループビット（MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRP）に許可されているビットも追加します。"
    },
    {
      "indent": 3,
      "text": "Implementations are discouraged from doing this, because it has been found to cause confusion for users who see members of a file's group denied access that the mode bits appear to allow. (The presence of DENY ACEs may also lead to such behavior, but DENY ACEs are expected to be more rarely used.)",
      "ja": "ファイルのグループのメンバーが許可されているように見えるように見えたファイルのグループのメンバーが拒否されたユーザーを混乱させることがわかっているため、実装はこれを行うことができませんでした。（拒否ACEの存在はそのような行動をもたらすかもしれませんが、ACEの拒否はよりめったに使用されると予想されます。）"
    },
    {
      "indent": 3,
      "text": "The same user confusion seen when fetching the mode also results if setting the mode does not effectively control permissions for the owner, group, and other users; this motivates some of the requirements that follow.",
      "ja": "モードをフェッチするときに見られるのと同じユーザーの混乱も、モードの設定が所有者、グループ、およびその他のユーザーに対する権限を効果的に制御しない場合に発生します。これは以下の要件のいくつかをやる気にしています。"
    },
    {
      "indent": 0,
      "text": "6.4. Requirements",
      "section_title": true,
      "ja": "6.4. 要件"
    },
    {
      "indent": 3,
      "text": "The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs that have respective who fields of \"OWNER@\", \"GROUP@\", and \"EVERYONE@\". This way, the client can see if semantically equivalent access permissions exist whether the client asks for the owner, owner_group, and mode attributes or for just the ACL.",
      "ja": "モードとACLの両方をサポートするサーバーは、MODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTSビットを「所有者@」、「GROUP @」、および「皆さん@」の項目を持つACESと認識する必要があります。\"。このようにして、クライアントは、クライアントが所有者、owner_group、およびモードの属性を要求するか、またはACLだけであるかどうかを意味的に同等のアクセス許可が存在するかどうかを確認できます。"
    },
    {
      "indent": 3,
      "text": "In this section, much is made of the methods in Section 6.3.2. Many requirements refer to this section. But note that the methods have behaviors specified with \"SHOULD\". This is intentional, to avoid invalidating existing implementations that compute the mode according to the withdrawn POSIX ACL draft (1003.1e draft 17), rather than by actual permissions on owner, group, and other.",
      "ja": "このセクションでは、6.3.2項のメソッドで多くのものがあります。多くの要件はこのセクションを参照しています。ただし、メソッドには「SOUP」で指定された動作があることに注意してください。これは意図的なものです。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Setting the Mode and/or ACL Attributes",
      "section_title": true,
      "ja": "6.4.1. モードおよび/またはACL属性を設定する"
    },
    {
      "indent": 3,
      "text": "In the case where a server supports the sacl or dacl attribute, in addition to the acl attribute, the server MUST fail a request to set the acl attribute simultaneously with a dacl or sacl attribute. The error to be given is NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバーがSACLまたはDACL属性をサポートしている場合は、ACL属性に加えて、サーバーはDACLまたはSACL属性と同時にACL属性を設定する要求に失敗する必要があります。与えられるエラーはNFS4ERR_ATTRNOTSUPPです。"
    },
    {
      "indent": 0,
      "text": "6.4.1.1. Setting Mode and not ACL",
      "section_title": true,
      "ja": "6.4.1.1. 設定モードとACLではなく"
    },
    {
      "indent": 3,
      "text": "When any of the nine low-order mode bits are subject to change, either because the mode attribute was set or because the mode_set_masked attribute was set and the mask included one or more bits from the nine low-order mode bits, and no ACL attribute is explicitly set, the acl and dacl attributes must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.",
      "ja": "モード属性が設定されているため、またはMODE_SET_MASKED属性が設定されているため、またはMODE_SET_MASKED属性が設定されているため、9つの下位モードビットのいずれかが変更され、MASKが9つの下位モードビットから1つ以上のビットを含め、ACL属性が含まれているためです。明示的に設定され、ACL属性とDACL属性はそれらのビットの更新された値に従って変更されなければなりません。前後のビットの値が以前と同じように設定された後も同じであっても、これが起こらなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that any AUDIT or ALARM ACEs (hence any ACEs in the sacl attribute) are unaffected by changes to the mode.",
      "ja": "モードへの変更による監査またはアラームACE（したがって、任意のACE）は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "In cases in which the permissions bits are subject to change, the acl and dacl attributes MUST be modified such that the mode computed via the method in Section 6.3.2 yields the low-order nine bits (MODE4_R*, MODE4_W*, MODE4_X*) of the mode attribute as modified by the attribute change. The ACL attributes SHOULD also be modified such that:",
      "ja": "アクセス許可ビットが変更される場合は、6.3.2項のメソッドを介して計算されたモードが下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）をもたらすようにACLおよびDACL属性を変更する必要があります。属性変更によって変更されたモード属性の。ACL属性も変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.",
      "ja": "1. MODE4_RGRPが設定されていない場合は、所有者@とholider @以外のACLに明示的にリストされているエンティティは、ACE4_READ_DATAを付与しないでください。"
    },
    {
      "indent": 3,
      "text": "2. If MODE4_WGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_WRITE_DATA or ACE4_APPEND_DATA.",
      "ja": "2. MODE4_WGRPが設定されていない場合は、所有者@およびhomeone @以外のACLに明示的にリストされているエンティティは、ACE4_WRITE_DATAまたはACE4_APPEND_DATAを付与しないでください。"
    },
    {
      "indent": 3,
      "text": "3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.",
      "ja": "3. MODE4_XGRPが設定されていない場合は、所有者@およびhervery @以外のACLに明示的にリストされているエンティティがACE4_EXECUTEを付与しないでください。"
    },
    {
      "indent": 3,
      "text": "Access mask bits other than those listed above, appearing in ALLOW ACEs, MAY also be disabled.",
      "ja": "上記のもの以外のアクセスマスクビットは、ACEを許可することもできます。"
    },
    {
      "indent": 3,
      "text": "Note that ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect the permissions of the ACL itself, nor do ACEs of the type AUDIT and ALARM. As such, it is desirable to leave these ACEs unmodified when modifying the ACL attributes.",
      "ja": "フラグACE4_INHERIT_ONLY_ACE SETを持つACEは、ACL自体のアクセス許可には影響しません。また、タイプ監査とアラームのACEを実行しません。そのため、ACL属性を変更するときにこれらのACEを変更しなくなることが望ましいです。"
    },
    {
      "indent": 3,
      "text": "Also note that the requirement may be met by discarding the acl and dacl, in favor of an ACL that represents the mode and only the mode. This is permitted, but it is preferable for a server to preserve as much of the ACL as possible without violating the above requirements. Discarding the ACL makes it effectively impossible for a file created with a mode attribute to inherit an ACL (see Section 6.4.3).",
      "ja": "また、モードとモードのみを表すACLを支持して、ACLとDACLを廃棄することで、要件を満たすことができることにも注意してください。これは許可されていますが、サーバーが上記の要件に違反することなくできるだけ多くのACLを保存することが好ましいです。ACLを破棄すると、MODE属性を使用して作成されたファイルがACLを継承するのに効果的に不可能です（セクション6.4.3を参照）。"
    },
    {
      "indent": 0,
      "text": "6.4.1.2. Setting ACL and Not Mode",
      "section_title": true,
      "ja": "6.4.1.2. ACLを設定してモードではありません"
    },
    {
      "indent": 3,
      "text": "When setting the acl or dacl and not setting the mode or mode_set_masked attributes, the permission bits of the mode need to be derived from the ACL. In this case, the ACL attribute SHOULD be set as given. The nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) MUST be modified to match the result of the method in Section 6.3.2. The three high-order bits of the mode (MODE4_SUID, MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.",
      "ja": "ACLまたはDACLを設定し、モードまたはMODE_SET_MASKED属性を設定しない場合、モードの許可ビットはACLから派生する必要があります。この場合、ACL属性は指定されているとおりに設定する必要があります。MODE属性の9つの下位ビット（MODE4_R *、MODE4_W *、MODE4_X *）は、6.3.2のメソッドの結果と一致するように変更する必要があります。モードの3つの上位ビット（MODE4_SUID、MODE4_SGID、MODE4_SVTX）は変更されていないはずです。"
    },
    {
      "indent": 0,
      "text": "6.4.1.3. Setting Both ACL and Mode",
      "section_title": true,
      "ja": "6.4.1.3. ACLとモードの両方を設定します"
    },
    {
      "indent": 3,
      "text": "When setting both the mode (includes use of either the mode attribute or the mode_set_masked attribute) and the acl or dacl attributes in the same operation, the attributes MUST be applied in this order: mode (or mode_set_masked), then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.",
      "ja": "どちらのモード（MODE属性またはmode_set_masked属性のいずれかを使用する場合）と同じ操作でACLまたはDACL属性の両方を設定する場合、属性をこの順序で適用する必要があります。モード（またはmode_set_masked）、次にACL。MODE関連属性は指定されているとおりに設定されてから、ACL属性が指定されているとおりに設定され、6.4.1.2項で説明したように、最終モードを変更します。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Retrieving the Mode and/or ACL Attributes",
      "section_title": true,
      "ja": "6.4.2. モードおよび/またはACL属性を取得する"
    },
    {
      "indent": 3,
      "text": "This section applies only to servers that support both the mode and ACL attributes.",
      "ja": "このセクションは、モード属性とACL属性の両方をサポートするサーバーにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "Some server implementations may have a concept of \"objects without ACLs\", meaning that all permissions are granted and denied according to the mode attribute and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.",
      "ja": "一部のサーバー実装では、「ACLのないオブジェクト」の概念がある場合があります。つまり、モード属性に従ってすべての権限が付与され、そのオブジェクトにACL属性が保存されていないことを意味します。そのようなサーバーにACL属性が要求された場合、サーバーはモードと競合しないACLを返す必要があります。つまり、返されるACLは、6.3.2項で説明されているように、モード属性の9つの下位ビット（MODE4_R *、MODE4_W *、MODE4_X *）を表す必要があります。"
    },
    {
      "indent": 3,
      "text": "For other server implementations, the ACL attribute is always present for every object. Such servers SHOULD store at least the three high-order bits of the mode attribute (MODE4_SUID, MODE4_SGID, MODE4_SVTX). The server SHOULD return a mode attribute if one is requested, and the low-order nine bits of the mode (MODE4_R*, MODE4_W*, MODE4_X*) MUST match the result of applying the method in Section 6.3.2 to the ACL attribute.",
      "ja": "他のサーバー実装では、ACL属性はすべてのオブジェクトに対して常に存在します。そのようなサーバーは、モード属性の少なくとも3次ビット（MODE4_SUID、MODE4_SGID、MODE4_SVTX）を保存する必要があります。サーバーが要求された場合はモード属性を返し、モードの下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）が、6.3.2項のメソッドをACL属性に適用した結果と一致する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4.3. Creating New Objects",
      "section_title": true,
      "ja": "6.4.3. 新しいオブジェクトを作成する"
    },
    {
      "indent": 3,
      "text": "If a server supports any ACL attributes, it may use the ACL attributes on the parent directory to compute an initial ACL attribute for a newly created object. This will be referred to as the inherited ACL within this section. The act of adding one or more ACEs to the inherited ACL that are based upon ACEs in the parent directory's ACL will be referred to as inheriting an ACE within this section.",
      "ja": "サーバーがACL属性をサポートしている場合は、親ディレクトリ上のACL属性を使用して、新しく作成されたオブジェクトの最初のACL属性を計算できます。これはこのセクション内の継承ACLと呼ばれます。親ディレクトリのACLのACEに基づく継承ACLに1つ以上のACEを追加する行為は、このセクション内のACEを継承すると呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Implementors should standardize what the behavior of CREATE and OPEN must be depending on the presence or absence of the mode and ACL attributes.",
      "ja": "実装者は、MODE属性とACL属性の有無に応じて、CREATE AND OPENの動作が何であるかを標準化する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If just the mode is given in the call:",
      "ja": "1. モードだけが呼び出しで指定されている場合"
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD take place, but the mode MUST be applied to the inherited ACL as described in Section 6.4.1.1, thereby modifying the ACL.",
      "ja": "この場合、継承は行われるべきであるが、6.4.1.1項で説明されているように継承されたACLにモードを適用する必要があり、それによってACLを修正する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If just the ACL is given in the call:",
      "ja": "2. ACLが呼び出しに与えられたら："
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD NOT take place, and the ACL as defined in the CREATE or OPEN will be set without modification, and the mode modified as in Section 6.4.1.2.",
      "ja": "この場合、継承は行われてはいけません、そして作成または開いているACLは変更なしで設定され、6.4.1.2項のようにモードが変更されます。"
    },
    {
      "indent": 3,
      "text": "3. If both mode and ACL are given in the call:",
      "ja": "3. コールにモードとACLの両方が指定されている場合"
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD NOT take place, and both attributes will be set as described in Section 6.4.1.3.",
      "ja": "この場合、継承は行われてはいけません、そして両方の属性は6.4.1.3項で説明されているように設定されます。"
    },
    {
      "indent": 3,
      "text": "4. If neither mode nor ACL is given in the call:",
      "ja": "4. どちらのモードもACLも呼び出しで指定されていない場合"
    },
    {
      "indent": 7,
      "text": "In the case where an object is being created without any initial attributes at all, e.g., an OPEN operation with an opentype4 of OPEN4_CREATE and a createmode4 of EXCLUSIVE4, inheritance SHOULD NOT take place (note that EXCLUSIVE4_1 is a better choice of createmode4, since it does permit initial attributes). Instead, the server SHOULD set permissions to deny all access to the newly created object. It is expected that the appropriate client will set the desired attributes in a subsequent SETATTR operation, and the server SHOULD allow that operation to succeed, regardless of what permissions the object is created with. For example, an empty ACL denies all permissions, but the server should allow the owner's SETATTR to succeed even though WRITE_ACL is implicitly denied.",
      "ja": "初期属性なしでオブジェクトが作成されている場合、例えば、Open4_CreateのOpenType4とexclusive4のCreateMode4を使用したオープン操作では、継承は行われるべきではありません（exclusive4_1はそれがCreateMode4のより良い選択であることに注意してください）。初期属性を許可します）。代わりに、サーバーは、新しく作成されたオブジェクトへのすべてのアクセスを拒否するための権限を設定する必要があります。適切なクライアントは後続のSESATTR操作で目的の属性を設定し、その操作を許可しても、オブジェクトが作成された権限に関係なく、サーバーはその操作を成功させることができます。たとえば、空のACLはすべての権限を拒否しますが、WRITE_ACLが暗黙的に拒否されていても、サーバーは所有者のsetAttrが成功することを許可する必要があります。"
    },
    {
      "indent": 7,
      "text": "In other cases, inheritance SHOULD take place, and no modifications to the ACL will happen. The mode attribute, if supported, MUST be as computed in Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX bits clear. If no inheritable ACEs exist on the parent directory, the rules for creating acl, dacl, or sacl attributes are implementation defined. If either the dacl or sacl attribute is supported, then the ACL4_DEFAULTED flag SHOULD be set on the newly created attributes.",
      "ja": "それ以外の場合は、継承が行われるべきであり、ACLへの変更は起こらないであろう。MODE属性は、サポートされている場合は、MODE4_SUID、MODE4_SGID、およびMODE4_SVTXビットがクリアされた状態で、セクション6.3.2で計算されている必要があります。親ディレクトリに継承可能なACEが存在しない場合は、ACL、DACL、またはSACL属性を作成するための規則が定義されています。DACLまたはSACL属性がサポートされている場合は、新しく作成された属性にACL4_Defaultedフラグを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4.3.1. The Inherited ACL",
      "section_title": true,
      "ja": "6.4.3.1. 継承されたACL"
    },
    {
      "indent": 3,
      "text": "If the object being created is not a directory, the inherited ACL SHOULD NOT inherit ACEs from the parent directory ACL unless the ACE4_FILE_INHERIT_FLAG is set.",
      "ja": "作成されているオブジェクトがディレクトリではない場合、ACE4_FILE_INHERIT_FLAGが設定されていない限り、継承されたACLは親ディレクトリACLからACEを継承しないでください。"
    },
    {
      "indent": 3,
      "text": "If the object being created is a directory, the inherited ACL should inherit all inheritable ACEs from the parent directory, that is, those that have the ACE4_FILE_INHERIT_ACE or ACE4_DIRECTORY_INHERIT_ACE flag set. If the inheritable ACE has ACE4_FILE_INHERIT_ACE set but ACE4_DIRECTORY_INHERIT_ACE is clear, the inherited ACE on the newly created directory MUST have the ACE4_INHERIT_ONLY_ACE flag set to prevent the directory from being affected by ACEs meant for non-directories.",
      "ja": "作成されているオブジェクトがディレクトリである場合、継承されたACLは親ディレクトリ、つまりACE4_FILE_INHERIT_ACEまたはACE4_DIRECTORY_INHERIT_ACEフラグを設定するものすべての継承可能なACEを継承する必要があります。継承可能なACEにACE4_FILE_INHERIT_ACEセットが設定されていますが、ACE4_DIRECTORY_INHERIT_ACEがクリアされている場合、新しく作成されたディレクトリ上の継承されたACEは、ディレクトリが非ディレクトリを意味するACEの影響を受けるのを防ぐために、ACE4_INHERIT_ONLY_ACEフラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a new directory is created, the server MAY split any inherited ACE that is both inheritable and effective (in other words, that has neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE set), into two ACEs, one with no inheritance flags and one with ACE4_INHERIT_ONLY_ACE set. (In the case of a dacl or sacl attribute, both of those ACEs SHOULD also have the ACE4_INHERITED_ACE flag set.) This makes it simpler to modify the effective permissions on the directory without modifying the ACE that is to be inherited to the new directory's children.",
      "ja": "新しいディレクトリが作成されると、サーバーは、継承可能かつ効果的な継承されたACE（つまり、ACE4_INHERIT_ONLY_ACEもACE4_NO_PROPAGAT_INHERIT_ACEセットも持ちません）、継承フラグを持たない2つのACE、およびACE4_INHERIT_ONLY_ACEセットを持つものではない。（DACLまたはSACL属性の場合、これらのACEの両方にACE4_INHERTITED_ACEフラグが設定されている必要があります。）これにより、新しいディレクトリの子供に継承されるACEを変更せずにディレクトリに対する効果的な権限を変更することができます。。"
    },
    {
      "indent": 0,
      "text": "6.4.3.2. Automatic Inheritance",
      "section_title": true,
      "ja": "6.4.3.2. 自動継承"
    },
    {
      "indent": 3,
      "text": "The acl attribute consists only of an array of ACEs, but the sacl (Section 6.2.3) and dacl (Section 6.2.2) attributes also include an additional flag field.",
      "ja": "ACL属性はACEの配列のみで構成されていますが、SACL（セクション6.2.3）とDACL（6.2.2節）属性には追加のFlagフィールドも含まれます。"
    },
    {
      "indent": 3,
      "text": "struct nfsacl41 {\n        aclflag4        na41_flag;\n        nfsace4         na41_aces<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The flag field applies to the entire sacl or dacl; three flag values are defined:",
      "ja": "flagフィールドはSACLまたはDACL全体に適用されます。3つのフラグ値が定義されています。"
    },
    {
      "indent": 3,
      "text": "const ACL4_AUTO_INHERIT         = 0x00000001;\nconst ACL4_PROTECTED            = 0x00000002;\nconst ACL4_DEFAULTED            = 0x00000004;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and all other bits must be cleared. The ACE4_INHERITED_ACE flag may be set in the ACEs of the sacl or dacl (whereas it must always be cleared in the acl).",
      "ja": "そして他のすべてのビットはクリアされなければなりません。ACE4_INHERTITED_ACEフラグは、SACLまたはDACLのACESに設定されてもよい（一方、ACLでは常にクリアされている必要があります）。"
    },
    {
      "indent": 3,
      "text": "Together these features allow a server to support automatic inheritance, which we now explain in more detail.",
      "ja": "これらの機能をまとめることで、サーバーは自動継承をサポートできます。これは、今詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Inheritable ACEs are normally inherited by child objects only at the time that the child objects are created; later modifications to inheritable ACEs do not result in modifications to inherited ACEs on descendants.",
      "ja": "継承可能なACEは通常、子オブジェクトが作成された時点でのみ子オブジェクトによって継承されます。継承可能なACEの後の変更は、子孫に継承されたACEを修正しません。"
    },
    {
      "indent": 3,
      "text": "However, the dacl and sacl provide an OPTIONAL mechanism that allows a client application to propagate changes to inheritable ACEs to an entire directory hierarchy.",
      "ja": "ただし、DACLとSACLはクライアントアプリケーションが継承可能なACEへの変更をディレクトリ階層全体に伝播させることを可能にするオプションのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "A server that supports this performs inheritance at object creation time in the normal way, and SHOULD set the ACE4_INHERITED_ACE flag on any inherited ACEs as they are added to the new object.",
      "ja": "これをサポートするサーバーは、通常の方法でオブジェクト作成時に継承を実行し、それらが新しいオブジェクトに追加されるとおりにACE4_INHERITED_ACEフラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client application such as an ACL editor may then propagate changes to inheritable ACEs on a directory by recursively traversing that directory's descendants and modifying each ACL encountered to remove any ACEs with the ACE4_INHERITED_ACE flag and to replace them by the new inheritable ACEs (also with the ACE4_INHERITED_ACE flag set). It uses the existing ACE inheritance flags in the obvious way to decide which ACEs to propagate. (Note that it may encounter further inheritable ACEs when descending the directory hierarchy and that those will also need to be taken into account when propagating inheritable ACEs to further descendants.)",
      "ja": "その後、ACLエディタなどのクライアントアプリケーションは、そのディレクトリの子孫を再帰的に通過し、ACE4_inherited_aceフラグを使用してACEを削除し、それらを新しい継承可能なACEで置き換えるように遭遇した各ACLを変更することによって、ディレクトリ上の継承可能なACEへの変更を伝播させることができます。ACE4_INHERITED_ACEフラグセット）。それは明らかな方法で既存のACE継承フラグを使用してどのACEを伝播するかを決定します。（ディレクトリ階層の降順にさらに継承可能なACEに遭遇する可能性があるため、継承可能なACEをその他の子孫に伝播するときに考慮に入れる必要があります。）"
    },
    {
      "indent": 3,
      "text": "The reach of this propagation may be limited in two ways: first, automatic inheritance is not performed from any directory ACL that has the ACL4_AUTO_INHERIT flag cleared; and second, automatic inheritance stops wherever an ACL with the ACL4_PROTECTED flag is set, preventing modification of that ACL and also (if the ACL is set on a directory) of the ACL on any of the object's descendants.",
      "ja": "この伝播の範囲は2つの方法で制限されるかもしれません：最初に、ACL4_AUTO_INHERITフラグがクリアされている任意のディレクトリACLから自動継承は実行されません。そして第2に、ACL4_PROTECTEDフラグを持つACLが設定され、そのACLの変更を防ぎ、そのACLの変更を防ぎ、そのACLの任意のオブジェクトの任意のオブジェクトの任意のACLの変更を防ぎます。"
    },
    {
      "indent": 3,
      "text": "This propagation is performed independently for the sacl and the dacl attributes; thus, the ACL4_AUTO_INHERIT and ACL4_PROTECTED flags may be independently set for the sacl and the dacl, and propagation of one type of acl may continue down a hierarchy even where propagation of the other acl has stopped.",
      "ja": "この伝播は、SACLおよびDACL属性に対して独立して実行されます。したがって、ACL4_AUTO_INHERITフラグおよびACL4_PROTECTEDフラグは、SACLおよびDACLに対して独立して設定され、他のACLの伝播が停止している場合でも1つのタイプのACLの伝播は階層を下ります。"
    },
    {
      "indent": 3,
      "text": "New objects should be created with a dacl and a sacl that both have the ACL4_PROTECTED flag cleared and the ACL4_AUTO_INHERIT flag set to the same value as that on, respectively, the sacl or dacl of the parent object.",
      "ja": "新しいオブジェクトは、ACL4_PROTECTEDフラグがクリアされ、ACL4_AUTO_INHERITフラグがそれぞれ、親オブジェクトのSACLまたはDACLと同じ値に設定されているDACLとSACLを使用して作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Both the dacl and sacl attributes are RECOMMENDED, and a server may support one without supporting the other.",
      "ja": "DACL属性とSACLの属性の両方が推奨され、サーバーはもう一方をサポートせずに1つをサポートできます。"
    },
    {
      "indent": 3,
      "text": "A server that supports both the old acl attribute and one or both of the new dacl or sacl attributes must do so in such a way as to keep all three attributes consistent with each other. Thus, the ACEs reported in the acl attribute should be the union of the ACEs reported in the dacl and sacl attributes, except that the ACE4_INHERITED_ACE flag must be cleared from the ACEs in the acl. And of course a client that queries only the acl will be unable to determine the values of the sacl or dacl flag fields.",
      "ja": "3つの属性すべてを互いに一貫して保持するように、古いACL属性と1つまたは複数の新しいDACL属性の両方をサポートするサーバーはそうする必要があります。したがって、ACL属性に報告されたACEは、ACL内のACEからクリアされなければならないことを除いて、DACL属性とSACL属性に報告されているACEの共用体である必要があります。そしてもちろん、ACLのみをクエリするクライアントは、SACLフラグフィールドまたはDACLフラグフィールドの値を特定できません。"
    },
    {
      "indent": 3,
      "text": "When a client performs a SETATTR for the acl attribute, the server SHOULD set the ACL4_PROTECTED flag to true on both the sacl and the dacl. By using the acl attribute, as opposed to the dacl or sacl attributes, the client signals that it may not understand automatic inheritance, and thus cannot be trusted to set an ACL for which automatic inheritance would make sense.",
      "ja": "クライアントがACL属性に対してsetAttrを実行すると、サーバーはSACLとDACLの両方でACL4_PROTECTEDフラグをTRUEに設定する必要があります。DACLまたはSACLの属性とは対照的に、ACL属性を使用することによって、クライアントは自動継承を理解できない可能性があるため、自動継承が理にかなっているACLを設定することは信頼できません。"
    },
    {
      "indent": 3,
      "text": "When a client application queries an ACL, modifies it, and sets it again, it should leave any ACEs marked with ACE4_INHERITED_ACE unchanged, in their original order, at the end of the ACL. If the application is unable to do this, it should set the ACL4_PROTECTED flag. This behavior is not enforced by servers, but violations of this rule may lead to unexpected results when applications perform automatic inheritance.",
      "ja": "クライアントアプリケーションがACLを問い合わせたとき、それを変更してそれを再度設定し、ACLの最後に、ACE4_INHERTIPED_ACEを変更しない、ACE4_INHERTIPED_ACEを変更しないでください。アプリケーションがこれを実行できない場合は、ACL4_PROTECTEDフラグを設定する必要があります。この動作はサーバーによって強制されませんが、アプリケーションが自動継承を実行すると、この規則の違反が予期しない結果につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a server also supports the mode attribute, it SHOULD set the mode in such a way that leaves inherited ACEs unchanged, in their original order, at the end of the ACL. If it is unable to do so, it SHOULD set the ACL4_PROTECTED flag on the file's dacl.",
      "ja": "サーバーがMODE属性もサポートしている場合は、ACLの最後に、ACEが元の注文で継承されているようなACEが変更されていないような方法でモードを設定する必要があります。それができない場合は、ファイルのDACLにACL4_PROTECTEDフラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, in the case where the request that creates a new file or directory does not also set permissions for that file or directory, and there are also no ACEs to inherit from the parent's directory, then the server's choice of ACL for the new object is implementation-dependent. In this case, the server SHOULD set the ACL4_DEFAULTED flag on the ACL it chooses for the new object. An application performing automatic inheritance takes the ACL4_DEFAULTED flag as a sign that the ACL should be completely replaced by one generated using the automatic inheritance rules.",
      "ja": "最後に、新しいファイルまたはディレクトリを作成する要求もそのファイルまたはディレクトリの権限を設定しない場合、親のディレクトリから継承するACEもありません。その場合、新しいオブジェクトのサーバーのACLの選択は実装依存この場合、サーバーは新しいオブジェクトに対して選択されたACLにACL4_Defaultedフラグを設定する必要があります。自動継承を実行するアプリケーションは、ACLが自動継承規則を使用して生成されたものに完全に置き換えられるような符号としてACL4_Defaultedフラグを取ります。"
    },
    {
      "indent": 0,
      "text": "7. Single-Server Namespace",
      "section_title": true,
      "ja": "7. シングルサーバーネームスペース"
    },
    {
      "indent": 3,
      "text": "This section describes the NFSv4 single-server namespace. Single-server namespaces may be presented directly to clients, or they may be used as a basis to form larger multi-server namespaces (e.g., site-wide or organization-wide) to be presented to clients, as described in Section 11.",
      "ja": "このセクションでは、NFSV4 Single-Serverネームスペースについて説明します。シングルサーバーネームスペースは、クライアントに直接表示されることも、セクション11で説明されているように、より大きなマルチサーバーネームスペース（例えば、サイト全体または組織全体）を形成するための基礎として使用されてもよい。"
    },
    {
      "indent": 0,
      "text": "7.1. Server Exports",
      "section_title": true,
      "ja": "7.1. サーバーエクスポート"
    },
    {
      "indent": 3,
      "text": "On a UNIX server, the namespace describes all the files reachable by pathnames under the root directory or \"/\". On a Windows server, the namespace constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server's file system namespace available to NFS clients. More often, portions of the namespace are made available via an \"export\" feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sent a string that identified the export name within the namespace and the server returned the root filehandle for that export. The MOUNT protocol also provided an EXPORTS procedure that enumerated the server's exports.",
      "ja": "UNIXサーバーでは、ネームスペースは、ルートディレクトリまたは \"/\"の下のパス名によって到達可能なすべてのファイルを記述します。Windows Serverでは、ネームスペースはマッピングされたディスク文字で指定されたディスク上のすべてのファイルを構成します。NFS Server管理者は、サーバーのファイルシステムの名前空間全体をNFSクライアントに使用できるようにしてください。より頻繁には、名前空間の一部は「エクスポート」機能を介して利用可能にされています。以前のバージョンのNFSプロトコルでは、各エクスポートのルートファイルハンドルがマウントプロトコルを介して取得されます。クライアントはネームスペース内でエクスポート名を識別した文字列を送信し、サーバーはそのエクスポートのルートファイルハンドルを返しました。マウントプロトコルは、サーバーのエクスポートを列挙したエクスポート手順も提供されていました。"
    },
    {
      "indent": 0,
      "text": "7.2. Browsing Exports",
      "section_title": true,
      "ja": "7.2. 排出を閲覧する"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides a root filehandle that clients can use to obtain filehandles for the exports of a particular server, via a series of LOOKUP operations within a COMPOUND, to traverse a path. A common user experience is to use a graphical user interface (perhaps a file \"Open\" dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.",
      "ja": "NFSV4.1プロトコルは、コンパウンド内の一連のルックアップ操作を介して、パスをトラバースするために、クライアントが特定のサーバーのエクスポートのファイルハンドルを取得するために使用できるルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、ディレクトリツリーを介したプログレッシブブラウジングを介してファイルを見つけるために、グラフィカルユーザーインターフェイス（おそらくファイル「オープン」ダイアログウィンドウ）を使用することです。クライアントは、1コンポーネント、プログレッシブルックアップ操作を介して1つのエクスポートから別のエクスポートに移動できなければなりません。"
    },
    {
      "indent": 3,
      "text": "This style of browsing is not well supported by the NFSv3 protocol. In NFSv3, the client expects all LOOKUP operations to remain within a single server file system. For example, the device attribute will not change. This prevents a client from taking namespace paths that span exports.",
      "ja": "この閲覧のスタイルは、NFSv3プロトコルによってサポートされていません。NFSv3では、クライアントはすべてのルックアップ操作を単一のサーバーファイルシステム内に保留することを期待しています。たとえば、デバイス属性は変わりません。これにより、クライアントがエクスポートにまたがるネームスペースパスを実行するのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "In the case of NFSv3, an automounter on the client can obtain a snapshot of the server's namespace using the EXPORTS procedure of the MOUNT protocol. If it understands the server's pathname syntax, it can create an image of the server's namespace on the client. The parts of the namespace that are not exported by the server are filled in with directories that might be constructed similarly to an NFSv4.1 \"pseudo file system\" (see Section 7.3) that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server's namespace on the client: it is static. If the server administrator adds a new export, the client will be unaware of it.",
      "ja": "NFSV3の場合、クライアント上のオートマウンタは、マウントプロトコルのエクスポート手順を使用してサーバーのネームスペースのスナップショットを取得できます。サーバーのパス名の構文を理解している場合は、クライアント上のサーバーの名前空間のイメージを作成できます。サーバーによってエクスポートされていない名前空間の部分は、ユーザーが別のマウントされたファイルシステムから別のファイルシステムを閲覧することを可能にする、NFSV4.1「疑似ファイルシステム」と同様に構築される可能性があるディレクトリで入力されています。。クライアント上のサーバーの名前空間のこの表現には欠点があります。静的です。サーバー管理者が新しいエクスポートを追加した場合、クライアントはそれに認められません。"
    },
    {
      "indent": 0,
      "text": "7.3. Server Pseudo File System",
      "section_title": true,
      "ja": "7.3. サーバー疑似ファイルシステム"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 servers avoid this namespace inconsistency by presenting all the exports for a given server within the framework of a single namespace for that server. An NFSv4.1 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another.",
      "ja": "NFSV4.1サーバーは、そのサーバーの単一のネームスペースのフレームワーク内で特定のサーバーのすべてのエクスポートを表示することで、この名前空間の不一致を回避します。NFSV4.1クライアントは、ルックアップおよびREADDIRの操作を使用して、あるエクスポートから別のエクスポートへのシームレスに閲覧します。"
    },
    {
      "indent": 3,
      "text": "Where there are portions of the server namespace that are not exported, clients require some way of traversing those portions to reach actual exported file systems. A technique that servers may use to provide for this is to bridge the unexported portion of the namespace via a \"pseudo file system\" that provides a view of exported directories only. A pseudo file system has a unique fsid and behaves like a normal, read-only file system.",
      "ja": "エクスポートされていないサーバーネームスペースの部分がある場合、クライアントは、それらの部分を実行して実際のエクスポートされたファイルシステムに到達する方法を必要とします。これを提供するためにサーバーが使用することができる技術は、エクスポートされたディレクトリのみのビューを提供する「疑似ファイルシステム」を介して名前空間の非区切り部分を埋めることです。疑似ファイルシステムは、一意のFSIDを持ち、通常の読み取り専用ファイルシステムのように動作します。"
    },
    {
      "indent": 3,
      "text": "Based on the construction of the server's namespace, it is possible that multiple pseudo file systems may exist. For example,",
      "ja": "サーバーの名前空間の構成に基づいて、複数の疑似ファイルシステムが存在する可能性があります。例えば、"
    },
    {
      "indent": 11,
      "text": "/a              pseudo file system\n/a/b            real file system\n/a/b/c          pseudo file system\n/a/b/c/d        real file system",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each of the pseudo file systems is considered a separate entity and therefore MUST have its own fsid, unique among all the fsids for that server.",
      "ja": "疑似ファイルシステムの各々は別のエンティティと見なされ、したがって、そのサーバーのすべてのFSIDの間で独自のFSIDを持つ必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4. Multiple Roots",
      "section_title": true,
      "ja": "7.4. 複数の根"
    },
    {
      "indent": 3,
      "text": "Certain operating environments are sometimes described as having \"multiple roots\". In such environments, individual file systems are commonly represented by disk or volume names. NFSv4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.",
      "ja": "特定の動作環境は、「複数の根」を持つものとして説明されることがあります。そのような環境では、個々のファイルシステムは一般にディスクまたはボリューム名によって表されます。これらのプラットフォーム用のNFSV4サーバーは、これらのルート名の上にある疑似ファイルシステムを構築することができ、ディスク文字またはボリューム名は疑似ルート内の単なるディレクトリ名です。"
    },
    {
      "indent": 0,
      "text": "7.5. Filehandle Volatility",
      "section_title": true,
      "ja": "7.5. FileHandleのボラティリティ"
    },
    {
      "indent": 3,
      "text": "The nature of the server's pseudo file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo file system may not have an on-disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo file system, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated \"fh_expire_type\" attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a series of LOOKUP operations) when receiving an error of NFS4ERR_FHEXPIRED.",
      "ja": "サーバーの疑似ファイルシステムの性質は、サーバーから入手可能なファイルシステムの論理表現であることです。したがって、サーバーが最初にインスタンス化されると、疑似ファイルシステムは最も可能性が高いです。疑似ファイルシステムは、永続的なファイルハンドルを構築することができるディスク上の対応物を持っていない可能性があります。サーバーが疑似ファイルシステムに永続的なファイルハンドルを提供することが好ましいが、NFSクライアントは疑似ファイルシステムファイルハンドルが揮発性であることを期待する必要があります。これは、問題のファイルハンドルに関連付けられている \"fh_expire_type\"属性を確認することによって確認できます。ファイルハンドルが揮発性の場合、NFS4ER_FHExpiredのエラーを受信すると、NFSクライアントをファイルハンドル値（例えば、一連の検索操作で）を回復するように準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because it is quite likely that servers will implement pseudo file systems using volatile filehandles, clients need to be prepared for them, rather than assuming that all filehandles will be persistent.",
      "ja": "サーバーが揮発性のファイルハンドルを使用して疑似ファイルシステムを実装する可能性が非常に高いため、すべてのファイルハンドルが永続的になるのではなく、それらのためにクライアントを準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Exported Root",
      "section_title": true,
      "ja": "7.6. 輸出されたルート"
    },
    {
      "indent": 3,
      "text": "If the server's root file system is exported, one might conclude that a pseudo file system is unneeded. This is not necessarily so. Assume the following file systems on a server:",
      "ja": "サーバーのルートファイルシステムがエクスポートされた場合、疑似ファイルシステムが不要になると結論付けることがあります。これは必ずしもそうではありません。サーバー上の次のファイルシステムを仮定します。"
    },
    {
      "indent": 11,
      "text": "/       fs1  (exported)\n/a      fs2  (not exported)\n/a/b    fs3  (exported)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because fs2 is not exported, fs3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo file system.",
      "ja": "FS2はエクスポートされていないため、簡単なルックアップではFS3にアクセスできません。サーバーは疑似ファイルシステムでギャップを埋める必要があります。"
    },
    {
      "indent": 0,
      "text": "7.7. Mount Point Crossing",
      "section_title": true,
      "ja": "7.7. マウントポイント交差点"
    },
    {
      "indent": 3,
      "text": "The server file system environment may be constructed in such a way that one file system contains a directory that is 'covered' or mounted upon by a second file system. For example:",
      "ja": "サーバファイルシステム環境は、1つのファイルシステムが「対象」または第2のファイルシステムによってマウントされたディレクトリを含むように構成されてもよい。例えば："
    },
    {
      "indent": 11,
      "text": "/a/b            (file system 1)\n/a/b/c/d        (file system 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The pseudo file system for this server may be constructed to look like:",
      "ja": "このサーバーの疑似ファイルシステムは、次のようになるように構成されている可能性があります。"
    },
    {
      "indent": 11,
      "text": "/               (place holder/not exported)\n/a/b            (file system 1)\n/a/b/c/d        (file system 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is the server's responsibility to present the pseudo file system that is complete to the client. If the client sends a LOOKUP request for the path /a/b/c/d, the server's response is the filehandle of the root of the file system /a/b/c/d. In previous versions of the NFS protocol, the server would respond with the filehandle of directory /a/b/c/d within the file system /a/b.",
      "ja": "クライアントに完全な疑似ファイルシステムを提示するためのサーバーの責任です。クライアントがパス/ A / B / C / Dのルックアップ要求を送信すると、サーバーの応答はファイルシステム/ A / B / C / Dのルートのファイルハンドルです。以前のバージョンのNFSプロトコルでは、サーバーはファイルシステム/ A / B内のディレクトリ/ A / B / C / Dのファイルハンドルで応答します。"
    },
    {
      "indent": 3,
      "text": "The NFS client will be able to determine if it crosses a server mount point by a change in the value of the \"fsid\" attribute.",
      "ja": "NFSクライアントは、 \"fsid\"属性の値の変更によってサーバーマウントポイントを交差するかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "7.8. Security Policy and Namespace Presentation",
      "section_title": true,
      "ja": "7.8. セキュリティポリシーとネームスペースの発表"
    },
    {
      "indent": 3,
      "text": "Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO and SECINFO_NONAME, the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.",
      "ja": "NFSV4クライアントは、使用されるセキュリティメカニズムを変更する機能を保持しているため、SECINFOとSECINFO_NONAMEを使用してサーバーはクライアントによって使用されているセキュリティメカニズムに基づいて名前空間のさまざまなビューを表示しないでください。代わりに、不適切なセキュリティメカニズムを持つデータにアクセスするための試みが行われている場合は、一貫したビューを表示してNFS4ERR_WRONGSECを返します。"
    },
    {
      "indent": 3,
      "text": "If security considerations make it necessary to hide the existence of a particular file system, as opposed to all of the data within it, the server can apply the security policy of a shared resource in the server's namespace to components of the resource's ancestors. For example:",
      "ja": "セキュリティに関する考慮事項が、その内のすべてのデータとは対照的に、特定のファイルシステムの存在を隠す必要がある場合、サーバーはサーバーの名前空間内の共有リソースのセキュリティポリシーをリソースの先祖のコンポーネントに適用できます。例えば："
    },
    {
      "indent": 11,
      "text": "/                           (place holder/not exported)\n/a/b                        (file system 1)\n/a/b/MySecretProject        (file system 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.",
      "ja": "/ a / b / mysecretprojectディレクトリは実際のファイルシステムであり、共有リソースです。/ a / b / mysecretprojectのセキュリティポリシーが整合性を持つKerberosであり、このファイルシステムの存在に関する知識を制限することが望ましいとします。この場合、サーバーは同じセキュリティポリシーを/ a / bに適用する必要があります。これにより、望ましい場合には、ファイルシステムの存在に関する知識が確保されることが可能になる。"
    },
    {
      "indent": 3,
      "text": "For the case of the use of multiple, disjoint security mechanisms in the server's resources, applying that sort of policy would result in the higher-level file system not being accessible using any security flavor. Therefore, that sort of configuration is not compatible with hiding the existence (as opposed to the contents) from clients using multiple disjoint sets of security flavors.",
      "ja": "サーバーのリソース内の複数の派生セキュリティメカニズムを使用する場合は、その種のポリシーを適用して、セキュリティフレーバーを使用して上位レベルのファイルシステムがアクセスできません。したがって、セキュリティフレーバーの複数の異なるセットを使用して、クライアントからの存在（内容とは対照的に）存在を隠蔽することと互換性がありません。"
    },
    {
      "indent": 3,
      "text": "In other circumstances, a desirable policy is for the security of a particular object in the server's namespace to include the union of all security mechanisms of all direct descendants. A common and convenient practice, unless strong security requirements dictate otherwise, is to make the entire the pseudo file system accessible by all of the valid security mechanisms.",
      "ja": "他の状況では、望ましい方針は、サーバのネームスペース内の特定のオブジェクトのセキュリティがすべての直接の子孫のすべてのセキュリティメカニズムの組合を含むことである。強力なセキュリティ要件がそれ以外の場合を判断しない限り、一般的で便利な実践は、すべての有効なセキュリティメカニズムによって疑似ファイルシステム全体をアクセスできるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Where there is concern about the security of data on the network, clients should use strong security mechanisms to access the pseudo file system in order to prevent man-in-the-middle attacks.",
      "ja": "ネットワーク上のデータのセキュリティに関する懸念がある場合、クライアントは、中間攻撃を防ぐために、強力なセキュリティメカニズムを使用して疑似ファイルシステムにアクセスする必要があります。"
    },
    {
      "indent": 0,
      "text": "8. State Management",
      "section_title": true,
      "ja": "8. 州管理"
    },
    {
      "indent": 3,
      "text": "Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of such features as share reservations, file and directory delegations, recallable layouts, and support for mandatory byte-range locking, the protocol becomes substantially more dependent on proper management of state than the traditional combination of NFS and NLM (Network Lock Manager) [54]. These features include expanded locking facilities, which provide some measure of inter-client exclusion, but the state also offers features not readily providable using a stateless model. There are three components to making this state manageable:",
      "ja": "NFSプロトコルへのロックを統合すると、必然的にそれがステートフルになります。そのような機能を共有予約、ファイルおよびディレクトリの代表団、リコール可能なレイアウト、および必須バイトレンジロックのサポートとして、プロトコルは、NFSとNLMの伝統的な組み合わせよりも状態の適切な管理にかなり依存するようになります（Network Lock Manager））[54]。これらの機能には、クライアント間排除の尺度を提供する拡張ロック機能が含まれていますが、ステートレスモデルを使用して容易に販売できない機能も提供しています。この状態を管理しやすくするための3つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "* clear division between client and server",
      "ja": "* クライアントとサーバー間のクリア分割"
    },
    {
      "indent": 3,
      "text": "* ability to reliably detect inconsistency in state between client and server",
      "ja": "* クライアントとサーバー間の状態の矛盾を確実に検出する機能"
    },
    {
      "indent": 3,
      "text": "* simple and robust recovery mechanisms",
      "ja": "* シンプルで堅牢な回復メカニズム"
    },
    {
      "indent": 3,
      "text": "In this model, the server owns the state information. The client requests changes in locks and the server responds with the changes made. Non-client-initiated changes in locking state are infrequent. The client receives prompt notification of such changes and can adjust its view of the locking state to reflect the server's changes.",
      "ja": "このモデルでは、サーバーは状態情報を所有しています。クライアントはロックの変更を要求し、サーバーが変更された変更で応答します。ロック状態の非クライアント開始変更はまれです。クライアントはそのような変更の迅速な通知を受け取り、サーバーの変更を反映するようにロック状態のビューを調整することができます。"
    },
    {
      "indent": 3,
      "text": "Individual pieces of state created by the server and passed to the client at its request are represented by 128-bit stateids. These stateids may represent a particular open file, a set of byte-range locks held by a particular owner, or a recallable delegation of privileges to access a file in particular ways or at a particular location.",
      "ja": "サーバーによって作成され、その要求でクライアントに渡された個々の状態は128ビットのStateIDによって表されます。これらの状態は、特定の開いたファイル、特定の所有者によって保持されているバイトレンジのセット、または特定の方法でファイルにアクセスするためのリコール可能な特権の委任を表すことができます。"
    },
    {
      "indent": 3,
      "text": "In all cases, there is a transition from the most general information that represents a client as a whole to the eventual lightweight stateid used for most client and server locking interactions. The details of this transition will vary with the type of object but it always starts with a client ID.",
      "ja": "すべての場合において、ほとんどのクライアントおよびサーバーのロックインタラクションに使用される最終的なLightweight StateID全体としてクライアントを表す最も一般的な情報からの遷移があります。この遷移の詳細は、オブジェクトの種類によって異なりますが、常にクライアントIDから始まります。"
    },
    {
      "indent": 0,
      "text": "8.1. Client and Session ID",
      "section_title": true,
      "ja": "8.1. クライアントとセッションID"
    },
    {
      "indent": 3,
      "text": "A client must establish a client ID (see Section 2.4) and then one or more sessionids (see Section 2.10) before performing any operations to open, byte-range lock, delegate, or obtain a layout for a file object. Each session ID is associated with a specific client ID, and thus serves as a shorthand reference to an NFSv4.1 client.",
      "ja": "クライアントは、ファイルオブジェクトの開き、バイトレンジロック、デリゲート、またはファイルオブジェクトのレイアウトを取得するための操作を実行する前に、クライアントID（セクション2.4）（2.10項を参照）を設定する必要があります（2.10項を参照）。各セッションIDは特定のクライアントIDに関連付けられており、したがってNFSV4.1クライアントへの短縮基準として機能します。"
    },
    {
      "indent": 3,
      "text": "For some types of locking interactions, the client will represent some number of internal locking entities called \"owners\", which normally correspond to processes internal to the client. For other types of locking-related objects, such as delegations and layouts, no such intermediate entities are provided for, and the locking-related objects are considered to be transferred directly between the server and a unitary client.",
      "ja": "一部のタイプのロックインタラクションについては、クライアントは「所有者」と呼ばれるいくつかの数の内部ロックエンティティを表します。これは通常クライアントの内部プロセスに対応しています。代表団やレイアウトなどの他の種類のロック関連のオブジェクトの場合、そのような中間エンティティは提供されず、ロック関連のオブジェクトはサーバーとユニタリクライアントの間で直接転送されると見なされます。"
    },
    {
      "indent": 0,
      "text": "8.2. Stateid Definition",
      "section_title": true,
      "ja": "8.2. StateIDの定義"
    },
    {
      "indent": 3,
      "text": "When the server grants a lock of any type (including opens, byte-range locks, delegations, and layouts), it responds with a unique stateid that represents a set of locks (often a single lock) for the same file, of the same type, and sharing the same ownership characteristics. Thus, opens of the same file by different open-owners each have an identifying stateid. Similarly, each set of byte-range locks on a file owned by a specific lock-owner has its own identifying stateid. Delegations and layouts also have associated stateids by which they may be referenced. The stateid is used as a shorthand reference to a lock or set of locks, and given a stateid, the server can determine the associated state-owner or state-owners (in the case of an open-owner/lock-owner pair) and the associated filehandle. When stateids are used, the current filehandle must be the one associated with that stateid.",
      "ja": "サーバーが任意のタイプのロックを許可すると（オープン、バイトレンジロック、委任、およびレイアウトを含む）、それは同じファイルの一連のロック（しばしば単一のロック）を表す一意のStateIDと応答します。同じ所有権特性を入力し、共有します。したがって、異なるオープンオーナーによって同じファイルを開くと、それぞれ識別ステーションIDがあります。同様に、特定のロックオーナーが所有するファイル上の各バイトレンジロックは、独自の識別ステーションIDを持ちます。代表団とレイアウトには、それらが参照される可能性がある州の関連性があります。StateIDは、ロックまたはロックのセットへの短縮基準として使用され、StareIDを指定して、サーバーは関連する状態所有者または状態所有者（開放者/ロック所有者のペアの場合）を決定できます。関連するファイルハンドル。StateIDSが使用されている場合、現在のファイルハンドルはそのStareIDに関連付けられているものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "All stateids associated with a given client ID are associated with a common lease that represents the claim of those stateids and the objects they represent to be maintained by the server. See Section 8.3 for a discussion of the lease.",
      "ja": "特定のクライアントIDに関連付けられているすべてのStateIDは、それらのStateIDとサーバーによって管理されるべきオブジェクトの主張を表す一般的なリースに関連付けられています。リースの議論については、セクション8.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The server may assign stateids independently for different clients. A stateid with the same bit pattern for one client may designate an entirely different set of locks for a different client. The stateid is always interpreted with respect to the client ID associated with the current session. Stateids apply to all sessions associated with the given client ID, and the client may use a stateid obtained from one session on another session associated with the same client ID.",
      "ja": "サーバーは、さまざまなクライアントに対して独立してStateIDを割り当てることができます。1つのクライアントに対して同じビットパターンを持つStateIDは、異なるクライアントのための完全に異なるロックのセットを指定することができます。StateIDは、現在のセッションに関連付けられているクライアントIDに関して常に解釈されます。StateIDは、特定のクライアントIDに関連付けられているすべてのセッションに適用され、クライアントは同じクライアントIDに関連付けられている別のセッションで1つのセッションから取得したStareIDを使用できます。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Stateid Types",
      "section_title": true,
      "ja": "8.2.1. StateID型"
    },
    {
      "indent": 3,
      "text": "With the exception of special stateids (see Section 8.2.3), each stateid represents locking objects of one of a set of types defined by the NFSv4.1 protocol. Note that in all these cases, where we speak of guarantee, it is understood there are situations such as a client restart, or lock revocation, that allow the guarantee to be voided.",
      "ja": "特別なStateIDを除いて（セクション8.2.3を参照）、各StateIDは、NFSV4.1プロトコルによって定義された一連のタイプのうちの1つのロックオブジェクトを表します。保証について話すすべての場合において、クライアントの再起動、またはロック失効などの状況があることが理解されます。これにより、保証を無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "* Stateids may represent opens of files.",
      "ja": "* StateIDは、そのオープンファイルを表すことができます。"
    },
    {
      "indent": 6,
      "text": "Each stateid in this case represents the OPEN state for a given client ID/open-owner/filehandle triple. Such stateids are subject to change (with consequent incrementing of the stateid's seqid) in response to OPENs that result in upgrade and OPEN_DOWNGRADE operations.",
      "ja": "この場合の各stateIDは、特定のクライアントID / Open-Owner / FileHandleトリプルの開状態を表します。そのような州、アップグレードおよびOpen_Downgrade操作をもたらすオープンに応答して、変更される（その結果、StateIDのSEQIDの増分を伴う）変更があります。"
    },
    {
      "indent": 3,
      "text": "* Stateids may represent sets of byte-range locks.",
      "ja": "* StateIDはバイトレンジロックのセットを表すことができます。"
    },
    {
      "indent": 6,
      "text": "All locks held on a particular file by a particular owner and gotten under the aegis of a particular open file are associated with a single stateid with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.",
      "ja": "特定の所有者によって特定のファイル上に保持され、特定のオープンファイルのAEGISの下にあるすべてのロックは、ロック操作とLockuの操作がロックのセットに影響を与える場合は、SEQIDがインクリメントされている単一のStareIDと関連付けられています。"
    },
    {
      "indent": 3,
      "text": "* Stateids may represent file delegations, which are recallable guarantees by the server to the client that other clients will not reference or modify a particular file, until the delegation is returned. In NFSv4.1, file delegations may be obtained on both regular and non-regular files.",
      "ja": "* StateIDは、委任が返されるまで、他のクライアントが特定のファイルを参照または変更しないクライアントへのサーバーによるリコール可能な保証であるファイルの委任を表します。NFSV4.1では、ファイルの委任は、通常のファイルと非正規ファイルの両方で取得できます。"
    },
    {
      "indent": 6,
      "text": "A stateid represents a single delegation held by a client for a particular filehandle.",
      "ja": "StateIDは、特定のファイルハンドルのクライアントによって保持されている単一の委任を表します。"
    },
    {
      "indent": 3,
      "text": "* Stateids may represent directory delegations, which are recallable guarantees by the server to the client that other clients will not modify the directory, until the delegation is returned.",
      "ja": "* StateIDは、委任が返されるまで、他のクライアントがディレクトリを変更しないクライアントへのサーバーによるリコール可能な保証であるディレクトリの委任を表します。"
    },
    {
      "indent": 6,
      "text": "A stateid represents a single delegation held by a client for a particular directory filehandle.",
      "ja": "StateIDは、特定のディレクトリファイルハンドルのクライアントによって保持されている単一の委任を表します。"
    },
    {
      "indent": 3,
      "text": "* Stateids may represent layouts, which are recallable guarantees by the server to the client that particular files may be accessed via an alternate data access protocol at specific locations. Such access is limited to particular sets of byte-ranges and may proceed until those byte-ranges are reduced or the layout is returned.",
      "ja": "* StateIDSはレイアウトを表します。これは、特定の場所で特定のファイルが代替データアクセスプロトコルを介してアクセスできるように、クライアントへのサーバーによるリコール可能な保証です。そのようなアクセスは、特定のバイト範囲のセットに制限され、それらのバイト範囲が減少するかレイアウトが返されるまで進むことがあります。"
    },
    {
      "indent": 6,
      "text": "A stateid represents the set of all layouts held by a particular client for a particular filehandle with a given layout type. The seqid is updated as the layouts of that set of byte-ranges change, via layout stateid changing operations such as LAYOUTGET and LAYOUTRETURN.",
      "ja": "StateIDは、特定のファイルハンドルが特定のファイルハンドルに対して特定のクライアントで保持されているすべてのレイアウトのセットを表します。SEQIDは、LayoutgetやLayOutReturnなどのレイアウトStareIDの変更操作を介して、その一連のバイト範囲のレイアウトとして更新されます。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Stateid Structure",
      "section_title": true,
      "ja": "8.2.2. 州の構造"
    },
    {
      "indent": 3,
      "text": "Stateids are divided into two fields, a 96-bit \"other\" field identifying the specific set of locks and a 32-bit \"seqid\" sequence value. Except in the case of special stateids (see Section 8.2.3), a particular value of the \"other\" field denotes a set of locks of the same type (for example, byte-range locks, opens, delegations, or layouts), for a specific file or directory, and sharing the same ownership characteristics. The seqid designates a specific instance of such a set of locks, and is incremented to indicate changes in such a set of locks, either by the addition or deletion of locks from the set, a change in the byte-range they apply to, or an upgrade or downgrade in the type of one or more locks.",
      "ja": "StateIDは、特定のロックセットと32ビットの \"SEQID\"シーケンス値を識別する96ビット \"その他\"フィールドの2つのフィールドに分けられます。特別なStateID（セクション8.2.3を参照）の場合を除いて、「その他」フィールドの特定の値は、同じタイプのロックのセット（たとえば、バイトレンジロック、オープン、委任、またはレイアウト）を示します。特定のファイルまたはディレクトリの場合、同じ所有権特性を共有します。SEQIDはそのようなロックのセットの特定のインスタンスを指定し、セットからのロックの追加または削除、またはそれらが適用されるバイト範囲の変更によって、そのような一連のロックの変更を示すためにインクリメントされる。1つ以上のロックの種類のアップグレードまたはダウングレード。"
    },
    {
      "indent": 3,
      "text": "When such a set of locks is first created, the server returns a stateid with seqid value of one. On subsequent operations that modify the set of locks, the server is required to increment the \"seqid\" field by one whenever it returns a stateid for the same state-owner/file/type combination and there is some change in the set of locks actually designated. In this case, the server will return a stateid with an \"other\" field the same as previously used for that state-owner/file/type combination, with an incremented \"seqid\" field. This pattern continues until the seqid is incremented past NFS4_UINT32_MAX, and one (not zero) is the next seqid value.",
      "ja": "このようなロックセットが最初に作成されると、サーバーはSEQID値を持つStareIDを返します。ロックのセットを変更する後続の操作では、サーバーは同じ状態所有者/ファイル/タイプの組み合わせのStareIDを返すたびに「SEQID」フィールドを1つずつインクリメントする必要があり、実際にロックのセットに変更があります。専用。この場合、サーバーは、その状態-owner / file / typeの組み合わせと同じ「他の」フィールドを持つStateIDを返します。このパターンは、SEQIDがNFS4_UINT32_MAXを越えてインクリメントされるまで続き、1つ（ゼロではない）が次のseqid値です。"
    },
    {
      "indent": 3,
      "text": "The purpose of the incrementing of the seqid is to allow the server to communicate to the client the order in which operations that modified locking state associated with a stateid have been processed and to make it possible for the client to send requests that are conditional on the set of locks not having changed since the stateid in question was returned.",
      "ja": "SEQIDの増分の目的は、StateIDに関連付けられたロック状態を変更した操作が処理され、クライアントが条件付き要求を送信できるようにする順序で、サーバーがクライアントに通信できるようにすることです。問題のStateIDが返されてから変更されていないロックのセット。"
    },
    {
      "indent": 3,
      "text": "Except for layout stateids (Section 12.5.3), when a client sends a stateid to the server, it has two choices with regard to the seqid sent. It may set the seqid to zero to indicate to the server that it wishes the most up-to-date seqid for that stateid's \"other\" field to be used. This would be the common choice in the case of a stateid sent with a READ or WRITE operation. It also may set a non-zero value, in which case the server checks if that seqid is the correct one. In that case, the server is required to return NFS4ERR_OLD_STATEID if the seqid is lower than the most current value and NFS4ERR_BAD_STATEID if the seqid is greater than the most current value. This would be the common choice in the case of stateids sent with a CLOSE or OPEN_DOWNGRADE. Because OPENs may be sent in parallel for the same owner, a client might close a file without knowing that an OPEN upgrade had been done by the server, changing the lock in question. If CLOSE were sent with a zero seqid, the OPEN upgrade would be cancelled before the client even received an indication that an upgrade had happened.",
      "ja": "レイアウトステーション（セクション12.5.3）を除いて、クライアントがStateIDをサーバーに送信すると、送信されたSEQIDに関して2つの選択肢があります。 SEQIDをゼロに設定して、そのStareIDの「その他」フィールドの最新のSEQIDを希望するサーバーに設定します。これは、読み取りまたは書き込み操作で送信されたStateIDの場合、一般的な選択です。それはまたゼロ以外の値を設定するかもしれず、その場合、サーバーはseqidが正しいものであるかどうかをチェックします。その場合、SEQIDが最新の値より大きい場合、SEQIDが最新値およびNFS4ERR_BAD_STATATIDより低い場合、サーバーはNFS4ERR_OLD_STATEIDを返す必要があります。これは、閉鎖またはopen_downgradeで送信されたStateIDSの場合、一般的な選択です。 OpenSは同じ所有者に対して並行して送信される可能性があるため、クライアントはサーバーによってオープンアップグレードが行われていたことを知らずにファイルを閉じることができ、問題のロックを変更します。 SEQUIDがゼロのSEQIDで送信された場合、クライアントがアップグレードが発生したという表示を受け取る前に、オープンアップグレードがキャンセルされます。"
    },
    {
      "indent": 3,
      "text": "When a stateid is sent by the server to the client as part of a callback operation, it is not subject to checking for a current seqid and returning NFS4ERR_OLD_STATEID. This is because the client is not in a position to know the most up-to-date seqid and thus cannot verify it. Unless specially noted, the seqid value for a stateid sent by the server to the client as part of a callback is required to be zero with NFS4ERR_BAD_STATEID returned if it is not.",
      "ja": "StateIDがコールバック操作の一部としてサーバーからクライアントに送信されると、現在のSEQIDのチェックとNFS4ERR_OLD_STATEIDを返すことはできません。これは、クライアントが最新のSEQIDを知る位置にないため、検証できないためです。特別に注目されていない限り、コールバックの一部としてサーバーによって送信されたStareIDのseqid値は、NFS4ERR_BAD_STATEIDが返されない場合はゼロになる必要があります。"
    },
    {
      "indent": 3,
      "text": "In making comparisons between seqids, both by the client in determining the order of operations and by the server in determining whether the NFS4ERR_OLD_STATEID is to be returned, the possibility of the seqid being swapped around past the NFS4_UINT32_MAX value needs to be taken into account. When two seqid values are being compared, the total count of slots for all sessions associated with the current client is used to do this. When one seqid value is less than this total slot count and another seqid value is greater than NFS4_UINT32_MAX minus the total slot count, the former is to be treated as lower than the latter, despite the fact that it is numerically greater.",
      "ja": "SEQID間の比較を、クライアントの両方を操作順を決定する際に、およびNFS4ERR_OLD_STATEIDが返されるかどうかを判断する際に、SEQIDの可能性は、NFS4_UINT32_MAX値を通過する可能性が考慮される必要があります。2つのSEQID値が比較されている場合、現在のクライアントに関連するすべてのセッションのスロットの総数はこれを行うために使用されます。1つのSEQID値がこの全スロット数より小さく、別のSEQID値がNFS4_UINT32_MAXからNFS4_UINT32_MAXをマイナスしている場合、その結果は数値的に大きいという事実にもかかわらず、前者は後者より低いものとして扱われるべきである。"
    },
    {
      "indent": 0,
      "text": "8.2.3. Special Stateids",
      "section_title": true,
      "ja": "8.2.3. 特別な州"
    },
    {
      "indent": 3,
      "text": "Stateid values whose \"other\" field is either all zeros or all ones are reserved. They may not be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the \"other\" field is all zeros or all ones and the specific value of the \"seqid\" field.",
      "ja": "\"Other\"フィールドがすべてのゼロまたはすべてのもののいずれかのstateID値が予約されています。それらはサーバーによって割り当てられていないが、プロトコルによって定義された特別な意味を有することがある。特定の意味は、 \"other\"フィールドがすべてゼロまたはすべてのものか、および \"seqid\"フィールドの特定の値に依存します。"
    },
    {
      "indent": 3,
      "text": "The following combinations of \"other\" and \"seqid\" are defined in NFSv4.1:",
      "ja": "以下の「その他」と「SEQID」の組み合わせは、NFSV4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "* When \"other\" and \"seqid\" are both zero, the stateid is treated as a special anonymous stateid, which can be used in READ, WRITE, and SETATTR requests to indicate the absence of any OPEN state associated with the request. When an anonymous stateid value is used and an existing open denies the form of access requested, then access will be denied to the request. This stateid MUST NOT be used on operations to data servers (Section 13.6).",
      "ja": "* 「その他」および「seqid」がゼロの場合、StateIDは特別な匿名StareIDとして扱われます。これは、リクエストに関連付けられているオープン状態がないことを示すために、読み取り、書き込み、およびsetAttr要求で使用できます。匿名の状態ID値が使用され、既存のOpenが要求されたアクセス形式を拒否した場合、アクセスは要求に拒否されます。このStateIDは、データサーバーへの操作で使用してはいけません（セクション13.6）。"
    },
    {
      "indent": 3,
      "text": "* When \"other\" and \"seqid\" are both all ones, the stateid is a special READ bypass stateid. When this value is used in WRITE or SETATTR, it is treated like the anonymous value. When used in READ, the server MAY grant access, even if access would normally be denied to READ operations. This stateid MUST NOT be used on operations to data servers.",
      "ja": "* \"Other\"と \"Seqid\"がどちらもすべてのものである場合、StateIDは特別な読み取りバイパス州スタディです。この値がWRITEまたはSETATTRで使用されている場合は、匿名の値のように扱われます。読み取り中に使用されると、アクセスが正常に読み取り操作に拒否される場合でも、サーバーはアクセスを許可することがあります。このStateIDはデータサーバへの操作に使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "* When \"other\" is zero and \"seqid\" is one, the stateid represents the current stateid, which is whatever value is the last stateid returned by an operation within the COMPOUND. In the case of an OPEN, the stateid returned for the open file and not the delegation is used. The stateid passed to the operation in place of the special value has its \"seqid\" value set to zero, except when the current stateid is used by the operation CLOSE or OPEN_DOWNGRADE. If there is no operation in the COMPOUND that has returned a stateid value, the server MUST return the error NFS4ERR_BAD_STATEID. As illustrated in Figure 6, if the value of a current stateid is a special stateid and the stateid of an operation's arguments has \"other\" set to zero and \"seqid\" set to one, then the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "* \"Other\"がゼロで \"seqid\"の場合、StateIDは現在のStateIDを表します。これは、コンパウンド内の操作によって返された最後のStateIDです。開いている場合は、開いているファイルに対して返され、委任が使用されていないSTATEIDが使用されます。特殊値の代わりに操作に渡されたStateIDは、現在のStateIDが操作閉鎖またはOpen_DownGradeによって使用される場合を除き、その「SEQID」値をゼロに設定しています。stateID値を返した化合物に操作がない場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。図6に示すように、現在のStateIDの値が特別なSTATEIDで、操作の引数のStateIDが「Other」をゼロに設定し、「seqid」が1に設定されている場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* When \"other\" is zero and \"seqid\" is NFS4_UINT32_MAX, the stateid represents a reserved stateid value defined to be invalid. When this stateid is used, the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "* \"Other\"がゼロで \"seqid\"がNFS4_UINT32_MAXの場合、StateIDは無効になるように定義されている予約済みStateID値を表します。このStateIDが使用されると、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If a stateid value is used that has all zeros or all ones in the \"other\" field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "すべてのゼロまたはすべてのゼロを持つStateID値が使用されている場合は、上記のいずれかのケースの1つと一致しない場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles. In the case of a special stateid designating the current stateid, the current stateid value substituted for the special stateid is associated with a particular client ID and filehandle, and so, if it is used where the current filehandle does not match that associated with the current stateid, the operation to which the stateid is passed will return NFS4ERR_BAD_STATEID.",
      "ja": "特別なStateIDは、他のStateIDとは異なり、個々のクライアントIDまたはFileHandlesには関連付けられておらず、有効なすべてのクライアントIDとFileHandlesで使用できます。現在のStateIDを指定する特別なSTATEIDの場合、特別なStareIDに代わる現在のステートID値は特定のクライアントIDとファイルハンドルに関連付けられているため、現在のファイルハンドルが現在のファイルハンドルが一致しない場合に使用されている場合StateID、StateIDが渡される操作はNFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 0,
      "text": "8.2.4. Stateid Lifetime and Validation",
      "section_title": true,
      "ja": "8.2.4. StateIDの有効期間と検証"
    },
    {
      "indent": 3,
      "text": "Stateids must remain valid until either a client restart or a server restart or until the client returns all of the locks associated with the stateid by means of an operation such as CLOSE or DELEGRETURN. If the locks are lost due to revocation, as long as the client ID is valid, the stateid remains a valid designation of that revoked state until the client frees it by using FREE_STATEID. Stateids associated with byte-range locks are an exception. They remain valid even if a LOCKU frees all remaining locks, so long as the open file with which they are associated remains open, unless the client frees the stateids via the FREE_STATEID operation.",
      "ja": "StateIDSは、クライアントの再起動またはサーバーが再起動するまで、またはクライアントがStareIDに関連付けられているすべてのロックを閉じるなどの操作で返されるまで有効でなければなりません。クライアントIDが有効である限り、失効のためロックが失われると、StateIDはFree_StateIDを使用してクライアントが解放されるまでその失効状態の有効な指定です。バイトレンジロックに関連付けられているStateIDは例外です。Lockuがすべての残りのロックを解放しても、Free_StateID操作を介してクライアントが開いたままになっている場合でも、それらは有効なままです。"
    },
    {
      "indent": 3,
      "text": "It should be noted that there are situations in which the client's locks become invalid, without the client requesting they be returned. These include lease expiration and a number of forms of lock revocation within the lease period. It is important to note that in these situations, the stateid remains valid and the client can use it to determine the disposition of the associated lost locks.",
      "ja": "クライアントが要求されることなく、クライアントのロックが無効になる状況があることに注意してください。これらには、リース期間内のリース期限とロック失効の数が含まれます。このような状況では、StateIDは有効なままであり、クライアントはそれを使用して関連するロックロックの配置を決定することができることに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "An \"other\" value must never be reused for a different purpose (i.e., different filehandle, owner, or type of locks) within the context of a single client ID. A server may retain the \"other\" value for the same purpose beyond the point where it may otherwise be freed, but if it does so, it must maintain \"seqid\" continuity with previous values.",
      "ja": "単一のクライアントIDのコンテキスト内の「他の」値は、異なる目的（すなわち、さまざまなファイルハンドル、所有者、またはロックの種類）のために再利用されたことはありません。そうでなければ解放される可能性があるポイントを超えて同じ目的の「他の」値を保持することができますが、それがそうであれば、以前の値で「SEQID」の連続性を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "One mechanism that may be used to satisfy the requirement that the server recognize invalid and out-of-date stateids is for the server to divide the \"other\" field of the stateid into two fields.",
      "ja": "サーバーが無効および最新のステーションを認識する要件を満たすために使用され得る1つのメカニズムは、StateIDの \"other\"フィールドを2つのフィールドに分割するためのサーバーがサーバーにとって必要です。"
    },
    {
      "indent": 3,
      "text": "* an index into a table of locking-state structures.",
      "ja": "* ロック状態構造のテーブルへのインデックス。"
    },
    {
      "indent": 3,
      "text": "* a generation number that is incremented on each allocation of a table entry for a particular use.",
      "ja": "* 特定の使用のためのテーブルエントリの各割り当てに増分される世代番号。"
    },
    {
      "indent": 3,
      "text": "And then store in each table entry,",
      "ja": "そして各テーブルエントリに保存する、"
    },
    {
      "indent": 3,
      "text": "* the client ID with which the stateid is associated.",
      "ja": "* StateIDが関連付けられているクライアントID。"
    },
    {
      "indent": 3,
      "text": "* the current generation number for the (at most one) valid stateid sharing this index value.",
      "ja": "* このインデックス値を共有する有効な（最大1つ）有効なStateIDの現在の世代番号。"
    },
    {
      "indent": 3,
      "text": "* the filehandle of the file on which the locks are taken.",
      "ja": "* ロックが取られるファイルのファイルハンドル。"
    },
    {
      "indent": 3,
      "text": "* an indication of the type of stateid (open, byte-range lock, file delegation, directory delegation, layout).",
      "ja": "* StateIDのタイプの表示（オープン、バイトレンジロック、ファイル委任、ディレクトリ委任、レイアウト）。"
    },
    {
      "indent": 3,
      "text": "* the last \"seqid\" value returned corresponding to the current \"other\" value.",
      "ja": "* 最後の \"seqid\"値は、現在の \"other\"値に対応して返されます。"
    },
    {
      "indent": 3,
      "text": "* an indication of the current status of the locks associated with this stateid, in particular, whether these have been revoked and if so, for what reason.",
      "ja": "* 特に、このStateIDに関連するロックの現在のステータスの表示、特にこれらが失効されたかどうかは、どのような理由で。"
    },
    {
      "indent": 3,
      "text": "With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 8.2.3 for a discussion of special stateids.)",
      "ja": "この情報を使用すると、着信StareIDを検証でき、必要に応じて適切なエラーが返されます。特別な州、特別な州は別々に処理されます。（特別な州の議論については、セクション8.2.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "Note that stateids are implicitly qualified by the current client ID, as derived from the client ID associated with the current session. Note, however, that the semantics of the session will prevent stateids associated with a previous client or server instance from being analyzed by this procedure.",
      "ja": "現在のセッションに関連したクライアントIDから派生したように、StateIDSは現在のクライアントIDによって暗黙的に修飾されています。ただし、セッションのセマンティクスは、この手順によって以前のクライアントまたはサーバーインスタンスに関連付けられているStateIDが分析されるのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "If server restart has resulted in an invalid client ID or a session ID that is invalid, SEQUENCE will return an error and the operation that takes a stateid as an argument will never be processed.",
      "ja": "サーバーの再起動が無効なクライアントIDまたは無効なセッションIDをもたらした場合、シーケンスはエラーを返し、議論としてStareIDを取り込む操作は決して処理されません。"
    },
    {
      "indent": 3,
      "text": "If there has been a server restart where there is a persistent session and all leased state has been lost, then the session in question will, although valid, be marked as dead, and any operation not satisfied by means of the reply cache will receive the error NFS4ERR_DEADSESSION, and thus not be processed as indicated below.",
      "ja": "永続的なセッションがあるサーバーの再起動があった場合、すべてのリース状態が失われた場合、有効なセッションは、有効ですが、有効であるとマークされ、返信キャッシュによって満たされていない操作が受信されます。エラーNFS4ERR_DeadSession、したがって以下に示すように処理されません。"
    },
    {
      "indent": 3,
      "text": "When a stateid is being tested and the \"other\" field is all zeros or all ones, a check that the \"other\" and \"seqid\" fields match a defined combination for a special stateid is done and the results determined as follows:",
      "ja": "StateIDがテストされていて「その他」フィールドがすべてゼロまたはすべてのものである場合は、特別なStareIDに対して定義された組み合わせと一致することを確認し、結果は次のように決定されます。"
    },
    {
      "indent": 3,
      "text": "* If the \"other\" and \"seqid\" fields do not match a defined combination associated with a special stateid, the error NFS4ERR_BAD_STATEID is returned.",
      "ja": "* 「その他」および「seqid」フィールドが特別なStareIDに関連付けられている定義された組み合わせと一致しない場合、エラーNFS4ERR_BAD_STATEIDが返されます。"
    },
    {
      "indent": 3,
      "text": "* If the special stateid is one designating the current stateid and there is a current stateid, then the current stateid is substituted for the special stateid and the checks appropriate to non-special stateids are performed.",
      "ja": "* 特別なstateIDが現在のStateIDを指定して現在のStateIDを指定している場合、現在のStateIDが特別なStareIDの代わりになり、特別なステートに適したチェックが実行されます。"
    },
    {
      "indent": 3,
      "text": "* If the combination is valid in general but is not appropriate to the context in which the stateid is used (e.g., an all-zero stateid is used when an OPEN stateid is required in a LOCK operation), the error NFS4ERR_BAD_STATEID is also returned.",
      "ja": "* 組み合わせが一般的に有効である場合は、StateIDが使用されているコンテキストに適していない場合（たとえば、オープンステートIDがロック操作で必要な場合はオープンステートIDが必要な場合に使用されます）、エラーNFS4ERR_BAD_STATEIDも返されます。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the check is completed and the special stateid is accepted as valid.",
      "ja": "* それ以外の場合は、チェックが完了し、特別なStateIDは有効なものとして受け入れられます。"
    },
    {
      "indent": 3,
      "text": "When a stateid is being tested, and the \"other\" field is neither all zeros nor all ones, the following procedure could be used to validate an incoming stateid and return an appropriate error, when necessary, assuming that the \"other\" field would be divided into a table index and an entry generation.",
      "ja": "StateIDがテストされているとき、「その他」フィールドはすべてのゼロでもすべてのゼロでもない場合、次の手順を使用して着信StareIDを検証し、必要に応じて適切なエラーを返すことができます。テーブルインデックスとエントリ生成に分かれています。"
    },
    {
      "indent": 3,
      "text": "* If the table index field is outside the range of the associated table, return NFS4ERR_BAD_STATEID.",
      "ja": "* [テーブルインデックス]フィールドが関連テーブルの範囲外の場合は、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the selected table entry is of a different generation than that specified in the incoming stateid, return NFS4ERR_BAD_STATEID.",
      "ja": "* 選択したテーブルエントリが着信StareIDで指定されたものとは異なる世代のものである場合は、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the selected table entry does not match the current filehandle, return NFS4ERR_BAD_STATEID.",
      "ja": "* 選択したテーブルエントリが現在のファイルハンドルと一致しない場合は、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the client ID in the table entry does not match the client ID associated with the current session, return NFS4ERR_BAD_STATEID.",
      "ja": "* テーブルエントリのクライアントIDが現在のセッションに関連付けられているクライアントIDと一致しない場合は、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the stateid represents revoked state, then return NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED, as appropriate.",
      "ja": "* stateIDが失効状態を表した場合は、必要に応じてNFS4ERR_EXPIED、NFS4ERR_ADMIN_REVOKED、またはNFS4ERR_DELEG_REVOKEDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general, as would be reported by the TEST_STATEID operation, but be invalid for a particular operation, as, for example, when a stateid that doesn't represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.",
      "ja": "* stateID型が表示されているコンテキストに有効でない場合は、NFS4ERR_BAD_STATEIDを返します。TEST_STATEID操作によって報告されるように、StateDIDは一般的に有効であるかもしれないが、例えばバイトレンジロックを表していないStareIDが非以外に渡されたときのように、特定の操作に対して無効であるかもしれないことに留意されたい。from_openロックまたはロックの場合、またはオープンを表していないStateIDが閉じるかOpen_Downgradeに渡されます。そのような場合、サーバーはNFS4ERR_BAD_STATEIDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"seqid\" field is not zero and it is greater than the current sequence value corresponding to the current \"other\" field, return NFS4ERR_BAD_STATEID.",
      "ja": "* 「seqid」フィールドがゼロではなく、現在の \"other\"フィールドに対応する現在のシーケンス値よりも大きい場合は、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "* If the \"seqid\" field is not zero and it is less than the current sequence value corresponding to the current \"other\" field, return NFS4ERR_OLD_STATEID.",
      "ja": "* 「seqid」フィールドがゼロではなく、現在の \"other\"フィールドに対応する現在のシーケンス値よりも小さい場合は、nfs4err_old_stateIdを返します。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the stateid is valid and the table entry should contain any additional information about the type of stateid and information associated with that particular type of stateid, such as the associated set of locks, e.g., open-owner and lock-owner information, as well as information on the specific locks, e.g., open modes and byte-ranges.",
      "ja": "* それ以外の場合、StateIDは有効であり、テーブルエントリには、ステートIDの種類に関する追加の情報とその特定のタイプのStareID、例えばオープンオーナーおよびロックオーナー情報など、その特定の種類のStareIDに関連付けられている情報を含める必要があります。特定のロックに関する情報、例えばオープンモードとバイト範囲。"
    },
    {
      "indent": 0,
      "text": "8.2.5. Stateid Use for I/O Operations",
      "section_title": true,
      "ja": "8.2.5. StateID I / O操作の使用"
    },
    {
      "indent": 3,
      "text": "Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. SETATTR operations that change the file size are treated like I/O operations in this regard.",
      "ja": "I / O操作を実行するクライアントは、クライアントによって保持されているロック（オープンおよび代理を含む）に基づいて適切なStateIDを選択する必要があります。およびI / Oリクエストを送信するさまざまな種類の状態所有者が入荷しています。この点に関して、ファイルサイズを変更するSETATTRの操作はI / O操作のように扱われます。"
    },
    {
      "indent": 3,
      "text": "The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid. In following these rules, the client will only consider locks of which it has actually received notification by an appropriate operation response or callback. Note that the rules are slightly different in the case of I/O to data servers when file layouts are being used (see Section 13.9.1).",
      "ja": "優先順位の低下順に適用される次の規則は、適切なStateIDの選択を管理します。これらの規則に従って、クライアントは、適切な操作応答またはコールバックによって実際に通知を受けているロックのみを考慮します。ファイルレイアウトが使用されているときにI / Oへのデータサーバの場合、ルールはわずかに異なることに注意してください（セクション13.9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "* If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.",
      "ja": "* クライアントが問題のファイルの委任を保持している場合、委任ステートIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, if the entity corresponding to the lock-owner (e.g., a process) sending the I/O has a byte-range lock stateid for the associated open file, then the byte-range lock stateid for that lock-owner and open file SHOULD be used.",
      "ja": "* そうではなく、I / Oを送信するロック所有者（例えばプロセス）に対応するエンティティが、関連するオープンファイルに対してバイトレンジロックステートIDを有する場合、そのロック所有者および開いたファイルのバイトレンジロックステートIDを有する。使用すべきです。"
    },
    {
      "indent": 3,
      "text": "* If there is no byte-range lock stateid, then the OPEN stateid for the open file in question SHOULD be used.",
      "ja": "* バイトレンジロックステーションIDがない場合、問題のオープンファイルのオープンステートIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Finally, if none of the above apply, then a special stateid SHOULD be used.",
      "ja": "* 最後に、上記のどれも適用されていない場合は、特別なStateIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Ignoring these rules may result in situations in which the server does not have information necessary to properly process the request. For example, when mandatory byte-range locks are in effect, if the stateid does not indicate the proper lock-owner, via a lock stateid, a request might be avoidably rejected.",
      "ja": "これらの規則を無視すると、サーバーが要求を適切に処理するために必要な情報を持っていない状況につながる可能性があります。たとえば、必須バイトレンジロックが有効な場合、StateIDがロックステーションIDを介して、要求が回避できない可能性がある場合があります。"
    },
    {
      "indent": 3,
      "text": "The server however should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.",
      "ja": "ただし、サーバーはこれらの注文規則を強制することを試みるべきではなく、I / O要求を正しく処理するために利用できる情報を使用する必要があります。特に、クライアントが特定のファイルに対して委任を持つ場合、それが特別なStareIDとともに送信された場合でも、要求を処理する際にこの事実に注意してください。"
    },
    {
      "indent": 0,
      "text": "8.2.6. Stateid Use for SETATTR Operations",
      "section_title": true,
      "ja": "8.2.6. SetAttrオペレーションのためのStateID使用"
    },
    {
      "indent": 3,
      "text": "Because each operation is associated with a session ID and from that the clientid can be determined, operations do not need to include a stateid for the server to be able to determine whether they should cause a delegation to be recalled or are to be treated as done within the scope of the delegation.",
      "ja": "各操作はセッションIDと関連付けられているため、ClientIDを判断できるため、操作は、委任を回収させるか、または完了したように扱われるべきかどうかを判断できるようにするためのStareIDを含める必要はありません。代表団の範囲内で。"
    },
    {
      "indent": 3,
      "text": "In the case of SETATTR operations, a stateid is present. In cases other than those that set the file size, the client may send either a special stateid or, when a delegation is held for the file in question, a delegation stateid. While the server SHOULD validate the stateid and may use the stateid to optimize the determination as to whether a delegation is held, it SHOULD note the presence of a delegation even when a special stateid is sent, and MUST accept a valid delegation stateid when sent.",
      "ja": "SetAttrの操作の場合、StateIDが存在します。ファイルサイズを設定したもの以外の場合、クライアントは特別なStateIDを送信したり、問題のファイルに対して委任が保持されている場合は、委任ステートIDです。サーバーがStateIDを検証し、委任が保持されているかどうかの判断を最適化するためにStateIDを使用しても、特別なStareIDが送信されても委任の存在に注意してください。送信されたときに有効な委任ステートIDを受け入れる必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3. Lease Renewal",
      "section_title": true,
      "ja": "8.3. リースリニューアル"
    },
    {
      "indent": 3,
      "text": "Each client/server pair, as represented by a client ID, has a single lease. The purpose of the lease is to allow the client to indicate to the server, in a low-overhead way, that it is active, and thus that the server is to retain the client's locks. This arrangement allows the server to remove stale locking-related objects that are held by a client that has crashed or is otherwise unreachable, once the relevant lease expires. This in turn allows other clients to obtain conflicting locks without being delayed indefinitely by inactive or unreachable clients. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.",
      "ja": "クライアントIDによって表されるように、各クライアント/サーバーペアは1つのリースを持っています。リースの目的は、クライアントがローオーバーヘッドの方法で、アクティブであること、したがってクライアントのロックを保持することをクライアントに提供できるようにすることです。この配置により、関連するリースが期限切れになると、クラッシュしたクライアントによって保持されているクライアントによって保持されている古いロック関連のオブジェクトを削除できます。これにより、他のクライアントが無効または到達不能なクライアントによって無期限に遅れることなく、競合するロックを取得できます。リース期間が期限切れにならない場合は、キャッシュの一貫性のためのメカニズムではなく、リースの更新は拒否されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "Since each session is associated with a specific client (identified by the client's client ID), any operation sent on that session is an indication that the associated client is reachable. When a request is sent for a given session, successful execution of a SEQUENCE operation (or successful retrieval of the result of SEQUENCE from the reply cache) on an unexpired lease will result in the lease being implicitly renewed, for the standard renewal period (equal to the lease_time attribute).",
      "ja": "各セッションは特定のクライアント（クライアントのクライアントIDによって識別されている）に関連付けられているので、そのセッションで送信された操作は、関連するクライアントが到達可能であることを示しています。所与のセッションに対して要求が送信されると、期限切れのリースでのシーケンス操作の実行（または返信キャッシュからのシーケンスの結果の成功した検索）が、標準の更新期間（等しい）のためにリースが暗黙的に更新されることになる。LEASE_TIME属性に。"
    },
    {
      "indent": 3,
      "text": "If the client ID's lease has not expired when the server receives a SEQUENCE operation, then the server MUST renew the lease. If the client ID's lease has expired when the server receives a SEQUENCE operation, the server MAY renew the lease; this depends on whether any state was revoked as a result of the client's failure to renew the lease before expiration.",
      "ja": "サーバーがシーケンス操作を受信したときにクライアントIDのリースが期限切れになっていない場合、サーバーはリースを更新しなければなりません。サーバーがシーケンス操作を受信したときにクライアントIDのリースが期限切れになった場合、サーバーはリースを更新することがあります。これは、クライアントが有効期限が切れた前にリースを更新しなかった結果として、いかなる状態が失敗したかどうかによって異なります。"
    },
    {
      "indent": 3,
      "text": "Absent other activity that would renew the lease, a COMPOUND consisting of a single SEQUENCE operation will suffice. The client should also take communication-related delays into account and take steps to ensure that the renewal messages actually reach the server in good time. For example:",
      "ja": "リースを更新するであろう他の活動を欠席しないと、単一の配列操作からなる化合物で十分であろう。クライアントは、コミュニケーション関連の遅延も考慮に入れるべきであり、更新メッセージが実際にサーバーに到達するように手順を実行する必要があります。例えば："
    },
    {
      "indent": 3,
      "text": "* When trunking is in effect, the client should consider sending multiple requests on different connections, in order to ensure that renewal occurs, even in the event of blockage in the path used for one of those connections.",
      "ja": "* トランキングが有効な場合、クライアントは、それらの接続のうちの1つに使用されるパス内の閉塞が発生した場合でも、更新が行われるようにするために、さまざまな接続に対して複数の要求を送信することを検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Transport retransmission delays might become so large as to approach or exceed the length of the lease period. This may be particularly likely when the server is unresponsive due to a restart; see Section 8.4.2.1. If the client implementation is not careful, transport retransmission delays can result in the client failing to detect a server restart before the grace period ends. The scenario is that the client is using a transport with exponential backoff, such that the maximum retransmission timeout exceeds both the grace period and the lease_time attribute. A network partition causes the client's connection's retransmission interval to back off, and even after the partition heals, the next transport-level retransmission is sent after the server has restarted and its grace period ends.",
      "ja": "* 輸送再送遅延は、リース期間の長さを近づくか超えるように大きくなる可能性があります。再起動のためにサーバーが反応しない場合に特に可能性が高い場合があります。8.4.2.1項を参照してください。クライアントの実装が注意していない場合、トランスポートの再送信遅延は、クライアントが猶予期間が終了する前にサーバーの再起動を検出できなかった可能性があります。シナリオは、クライアントが指数バックオフでトランスポートを使用しているため、最大再送信タイムアウトが猶予期間とLEASE_TIME属性の両方を超えています。ネットワークパーティションでは、クライアントの接続の再送信間隔がバックオフされ、パーティションが隠れても、サーバーが再起動した後に次のトランスポートレベルの再送信が送信され、その猶予期間が終了します。"
    },
    {
      "indent": 6,
      "text": "The client MUST either recover from the ensuing NFS4ERR_NO_GRACE errors or it MUST ensure that, despite transport-level retransmission intervals that exceed the lease_time, a SEQUENCE operation is sent that renews the lease before expiration. The client can achieve this by associating a new connection with the session, and sending a SEQUENCE operation on it. However, if the attempt to establish a new connection is delayed for some reason (e.g., exponential backoff of the connection establishment packets), the client will have to abort the connection establishment attempt before the lease expires, and attempt to reconnect.",
      "ja": "クライアントは、続くNFS4ERR_NO_GRACEエラーから回復する必要があります。または、リース数を超えるトランスポートレベルの再送信間隔にもかかわらず、有効期限が切れる前にリースを更新するシーケンス操作が送信されることを確認する必要があります。クライアントは、新しい接続をセッションと関連付けることによってこれを達成でき、それにシーケンス操作を送信することができます。ただし、新しい接続を確立しようとすると、何らかの理由で（例えば、接続確立パケットの指数バックオフ）が遅れると、リースが期限切れになる前に接続確立の試みを中止し、再接続を試みる必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server renews the lease upon receiving a SEQUENCE operation, the server MUST NOT allow the lease to expire while the rest of the operations in the COMPOUND procedure's request are still executing. Once the last operation has finished, and the response to COMPOUND has been sent, the server MUST set the lease to expire no sooner than the sum of current time and the value of the lease_time attribute.",
      "ja": "シーケンス操作を受信すると、サーバがリースを更新すると、複合プロシージャの要求における残りの操作が依然として実行されている間、サーバはリースが期限切れにされてはならない。最後の操作が終了し、複合に対する応答が送信されると、サーバーは現在の時間の合計とLease_time属性の値よりも早く期限切れになるようにリースを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client ID's lease can expire when it has been at least the lease interval (lease_time) since the last lease-renewing SEQUENCE operation was sent on any of the client ID's sessions and there are no active COMPOUND operations on any such sessions.",
      "ja": "クライアントIDのリースは、最後のリース更新シーケンス操作がクライアントIDのセッションのいずれかで送信され、そのようなセッションに対してアクティブな複合操作はありませんので、少なくともリース間隔（LEASE_TIME）が経過する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Because the SEQUENCE operation is the basic mechanism to renew a lease, and because it must be done at least once for each lease period, it is the natural mechanism whereby the server will inform the client of changes in the lease status that the client needs to be informed of. The client should inspect the status flags (sr_status_flags) returned by sequence and take the appropriate action (see Section 18.46.3 for details).",
      "ja": "シーケンス操作はリースを更新するための基本的なメカニズムであり、少なくともリース期間ごとに1回は実行されなければならないため、サーバーがクライアントが必要なリース状況の変更のクライアントに通知する自然なメカニズムです。知らされます。クライアントはシーケンスによって返されたステータスフラグ（SR_STATUS_FLAGS）を検査し、適切な処置をとるべきです（詳細はセクション18.46.3を参照）。"
    },
    {
      "indent": 3,
      "text": "* The status bits SEQ4_STATUS_CB_PATH_DOWN and SEQ4_STATUS_CB_PATH_DOWN_SESSION indicate problems with the backchannel that the client may need to address in order to receive callback requests.",
      "ja": "* ステータスBITS SEQ4_STATUS_CB_PATH_DOWNおよびSEQ4_STATUS_CB_PATH_DOWN_SESSESSEは、コールバック要求を受信するためにクライアントがアドレス指定できるバックチャネルに関する問題を示します。"
    },
    {
      "indent": 3,
      "text": "* The status bits SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING and SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED indicate problems with GSS contexts or RPCSEC_GSS handles for the backchannel that the client might have to address in order to allow callback requests to be sent.",
      "ja": "* ステータスビットSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRINGおよびSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDは、コールバック要求を送信できるようにするために、クライアントがアドレス指定する必要があるバックチャネルのGSSコンテキストまたはRPCSEC_GSSハンドルに関する問題を示します。"
    },
    {
      "indent": 3,
      "text": "* The status bits SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, SEQ4_STATUS_ADMIN_STATE_REVOKED, and SEQ4_STATUS_RECALLABLE_STATE_REVOKED notify the client of lock revocation events. When these bits are set, the client should use TEST_STATEID to find what stateids have been revoked and use FREE_STATEID to acknowledge loss of the associated state.",
      "ja": "* ステータスビットseq4_status_expired_all_state_revoked、seq4_status_expired_some_state_revoked、seq4_status_admin_state_revoked、およびseq4_status_recallable_state_revokedロック失効イベントのクライアントに通知します。これらのビットが設定されると、クライアントはTest_StateIDを使用して、どのようなStateIDが取り消されていて、refe_stateIDを使用して関連状態の損失を確認します。"
    },
    {
      "indent": 3,
      "text": "* The status bit SEQ4_STATUS_LEASE_MOVE indicates that responsibility for lease renewal has been transferred to one or more new servers.",
      "ja": "* ステータスビットSEQ4_STATUS_LEASE_MOVEは、リース更新の責任が1つ以上の新しいサーバーに転送されたことを示します。"
    },
    {
      "indent": 3,
      "text": "* The status bit SEQ4_STATUS_RESTART_RECLAIM_NEEDED indicates that due to server restart the client must reclaim locking state.",
      "ja": "* ステータスビットSEQ4_STATUS_RESTART_RECLAIM_NEEDEDは、サーバーの再起動がロック状態を再利用する必要があることを示しています。"
    },
    {
      "indent": 3,
      "text": "* The status bit SEQ4_STATUS_BACKCHANNEL_FAULT indicates that the server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of a sequence ID for a slot in the backchannel).",
      "ja": "* ステータスビットSEQ4_STATUS_BACKCHANNEL_FAULTは、サーバがバックチャネルを用いて回復不可能な障害が発生したことを示している（例えば、バックチャネル内のスロットのシーケンスIDのトラックを失った）。"
    },
    {
      "indent": 0,
      "text": "8.4. Crash Recovery",
      "section_title": true,
      "ja": "8.4. クラッシュリカバリー"
    },
    {
      "indent": 3,
      "text": "A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations. Any that reach the server before the server can safely determine that the client has recovered enough locking state to be sure that such operations can be safely processed must be rejected. This will happen because either:",
      "ja": "クラッシュリカバリの重要な要件は、他方が失敗したときにクライアントとサーバーの両方が知ることです。さらに、クライアントがサーバーの再起動にわたるデータの一貫したビューを見ていることが必要です。クライアントまたはネットワークバッファ内でキューに入れられた可能性があるすべての読み書き操作は、クライアントが読み取り操作と書き込み操作を保護するロックを正常に回復するまで待機する必要があります。そのような操作を安全に処理できるようにするためにクライアントが十分なロック状態を回復したことをサーバーに到達できるようになる前に、サーバーに到達できるようにすることは、拒否されなければなりません。これは次のようになります。"
    },
    {
      "indent": 3,
      "text": "* The state presented is no longer valid since it is associated with a now invalid client ID. In this case, the client will receive either an NFS4ERR_BADSESSION or NFS4ERR_DEADSESSION error, and any attempt to attach a new session to that invalid client ID will result in an NFS4ERR_STALE_CLIENTID error.",
      "ja": "* 現在表示されている状態は、無効なクライアントIDに関連付けられているため無効になりました。この場合、クライアントはNFS4ERR_BADSESSIONまたはNFS4ERR_DEADSESSIONエラーを受信し、その無効なクライアントIDに新しいセッションを添付しようとすると、NFS4ERR_STALE_CLIENTIDエラーが発生します。"
    },
    {
      "indent": 3,
      "text": "* Subsequent recovery of locks may make execution of the operation inappropriate (NFS4ERR_GRACE).",
      "ja": "* その後のロックの回復は、動作不適切（NFS4ERR_GRACE）の実行を実行する可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.4.1. Client Failure and Recovery",
      "section_title": true,
      "ja": "8.4.1. クライアントの障害と回復"
    },
    {
      "indent": 3,
      "text": "In the event that a client fails, the server may release the client's locks when the associated lease has expired. Conflicting locks from another client may only be granted after this lease expiration. As discussed in Section 8.3, when a client has not failed and re-establishes its lease before expiration occurs, requests for conflicting locks will not be granted.",
      "ja": "クライアントが失敗した場合、関連するリースが期限切れになったときにサーバーはクライアントのロックを解除することがあります。別のクライアントからの競合するロックは、このリースの有効期限の後にのみ付与されます。8.3項で説明したように、クライアントが失敗していない場合には、有効期限が発生する前にそのリースを再確立していない場合、競合するロックに対する要求は許可されません。"
    },
    {
      "indent": 3,
      "text": "To minimize client delay upon restart, lock requests are associated with an instance of the client by a client-supplied verifier. This verifier is part of the client_owner4 sent in the initial EXCHANGE_ID call made by the client. The server returns a client ID as a result of the EXCHANGE_ID operation. The client then confirms the use of the client ID by establishing a session associated with that client ID (see Section 18.36.3 for a description of how this is done). All locks, including opens, byte-range locks, delegations, and layouts obtained by sessions using that client ID, are associated with that client ID.",
      "ja": "再起動時にクライアントの遅延を最小限に抑えるために、ロック要求はクライアント提供の検証者によってクライアントのインスタンスに関連付けられています。この検証者は、クライアントによって行われた最初のExchange_ID呼び出しで送信されたClient_Owner4の一部です。Exchange_ID操作の結果として、サーバーはクライアントIDを返します。その後、クライアントはそのクライアントIDに関連付けられているセッションを確立することによってクライアントIDの使用を確認します（これが行われる方法については、セクション18.36.3を参照）。そのクライアントIDを使用してセッションによって取得されたセッションによって取得されたオープン、バイトレンジロック、代理店、およびレイアウトを含むすべてのロックは、そのクライアントIDに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client's new instantiation and subsequent loss (upon confirmation of the new client ID) of locking state. As a result, the server is free to release all locks held that are associated with the old client ID that was derived from the old verifier. At this point, conflicting locks from other clients, kept waiting while the lease had not yet expired, can be granted. In addition, all stateids associated with the old client ID can also be freed, as they are no longer reference-able.",
      "ja": "検証者は各初期化時にクライアントによって変更されるので、サーバーは現在保持されているロックに関連した新しい検証者を検証者に比較し、それらが一致しないと判断できます。これは、ロック状態の新しいクライアントのインスタンス化とその後の損失（新しいクライアントIDの確認時に）を意味します。その結果、サーバーは古い検証者から派生した古いクライアントIDに関連付けられているすべてのロックを解放することができます。この時点で、他のクライアントからの競合するロックは、リースがまだ期限切れになっていない間待っていましたが、許可されます。さらに、古いクライアントIDに関連付けられているすべてのStateIDも参照できなくなったため、解放できます。"
    },
    {
      "indent": 3,
      "text": "Note that the verifier must have the same uniqueness properties as the verifier for the COMMIT operation.",
      "ja": "検証者は、コミット操作の検証者と同じ一意性プロパティを持つ必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Server Failure and Recovery",
      "section_title": true,
      "ja": "8.4.2. サーバーの障害と回復"
    },
    {
      "indent": 3,
      "text": "If the server loses locking state (usually as a result of a restart), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is a possibility that clients have not yet re-established their locking state for a file and that such locking state might make it invalid to perform READ or WRITE operations. For example, if mandatory locks are a possibility, the server must disallow READ and WRITE operations for that file.",
      "ja": "サーバーがロック状態を失う（通常は再起動の結果として）、クライアントがこの事実を検出し、失われたロック状態を再確立させることを許可する必要があります。サーバーに別のクライアントへのアクセスを許可したため、クライアントは、サーバーが有効な要求を拒否せずにロック状態を再確立できなければなりません。同様に、クライアントがファイルに対してロック状態を再確立していない可能性がある場合、およびそのようなロック状態が読み取りまたは書き込み操作を実行することが無効になる可能性がある場合があります。たとえば、必須ロックが可能性がある場合、サーバーはそのファイルの読み取りと書き込み操作を許可しない必要があります。"
    },
    {
      "indent": 3,
      "text": "A client can determine that loss of locking state has occurred via several methods.",
      "ja": "クライアントは、いくつかの方法によってロック状態の損失が発生したと判断できます。"
    },
    {
      "indent": 3,
      "text": "1. When a SEQUENCE (most common) or other operation returns NFS4ERR_BADSESSION, this may mean that the session has been destroyed but the client ID is still valid. The client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state with the new client ID, after the CREATE_SESSION operation succeeds (see Section 8.4.2.1).",
      "ja": "1. シーケンス（最も一般的な）または他の操作がNFS4ERR_BADSESSIONを返す場合、これはセッションが破棄されたがクライアントIDはまだ有効であることを意味します。クライアントはクライアントIDを使用してCreate_Session要求を送信してセッションを再確立します。CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントは新しいクライアントIDを確立し（セクション8.1を参照）、CREATE_SESSION操作が成功した後に新しいクライアントIDを使用してそのロック状態を再確立する必要があります（セクション8.4.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "2. When a SEQUENCE (most common) or other operation on a persistent session returns NFS4ERR_DEADSESSION, this indicates that a session is no longer usable for new, i.e., not satisfied from the reply cache, operations. Once all pending operations are determined to be either performed before the retry or not performed, the client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state after the CREATE_SESSION, with the new client ID, succeeds (Section 8.4.2.1).",
      "ja": "2. 永続セッションでのシーケンス（最も一般的な）またはその他の操作がNFS4ERR_DEADSESSIONを返す場合、これはセッションが新しい、すなわち、返信キャッシュから満足していないことを示していることを示しています。すべての保留中の操作が再試行または実行されなかった前に実行されると決定されると、クライアントはクライアントIDを使用してCREATE_SESSION要求を送信してセッションを再確立します。CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントは新しいクライアントIDを確立し（セクション8.1を参照）、新しいクライアントIDを使用して、CREATE_SESSIONの後にそのロック状態を再確立する必要があります（セクション8.4.2.1）。"
    },
    {
      "indent": 3,
      "text": "3. When an operation, neither SEQUENCE nor preceded by SEQUENCE (for example, CREATE_SESSION, DESTROY_SESSION), returns NFS4ERR_STALE_CLIENTID, the client MUST establish a new client ID (Section 8.1) and re-establish its lock state (Section 8.4.2.1).",
      "ja": "3. 操作がシーケンスまたはシーケンスでも先行していない場合（たとえば、create_session、destroy_session）、NFS4ERR_STALE_CLIENTIDを返し、クライアントは新しいクライアントID（セクション8.1）を確立し、そのロック状態を再確立する必要があります（8.4.2.1項）。"
    },
    {
      "indent": 0,
      "text": "8.4.2.1. State Reclaim",
      "section_title": true,
      "ja": "8.4.2.1. 議論の撤回"
    },
    {
      "indent": 3,
      "text": "When state information and the associated locks are lost as a result of a server restart, the protocol must provide a way to cause that state to be re-established. The approach used is to define, for most types of locking state (layouts are an exception), a request whose function is to allow the client to re-establish on the server a lock first obtained from a previous instance. Generally, these requests are variants of the requests normally used to create locks of that type and are referred to as \"reclaim-type\" requests, and the process of re-establishing such locks is referred to as \"reclaiming\" them.",
      "ja": "サーバーの再起動の結果として状態情報と関連するロックが失われると、プロトコルはその状態を再確立させる方法を提供する必要があります。使用されるアプローチは、ほとんどのタイプのロック状態（レイアウトが例外である）を定義することです（レイアウトが例外です）、その関数がクライアントが前のインスタンスから最初に取得されたロックをサーバー上で再確立できるようにする要求です。一般に、これらの要求は、通常、そのタイプのロックを作成するために通常使用され、「再生型」要求と呼ばれ、そのようなロックを再確立するプロセスは「再生」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Because each client must have an opportunity to reclaim all of the locks that it has without the possibility that some other client will be granted a conflicting lock, a \"grace period\" is devoted to the reclaim process. During this period, requests creating client IDs and sessions are handled normally, but locking requests are subject to special restrictions. Only reclaim-type locking requests are allowed, unless the server can reliably determine (through state persistently maintained across restart instances) that granting any such lock cannot possibly conflict with a subsequent reclaim. When a request is made to obtain a new lock (i.e., not a reclaim-type request) during the grace period and such a determination cannot be made, the server must return the error NFS4ERR_GRACE.",
      "ja": "各クライアントは、他のクライアントが競合するロックを付与される可能性がないというすべてのロックを再利用する機会がなければならないので、「猶予期間」は再利用プロセスに専念しています。この間、クライアントIDとセッションの作成要求は正常に処理されますが、ロック要求は特別な制限の対象となります。サーバーが確実に確実に判断できない限り、そのようなロックを付与することが、そのようなロックを許可することが、その後の再利用と競合することができないことを確実に決定できない限り、再生型のロック要求のみが許可されます。猶予期間中に新しいロック（すなわち再生型要求ではない）を取得するための要求が行われ、そのような決定が行われない場合、サーバはエラーNFS4ERR_GRACEを返す必要がある。"
    },
    {
      "indent": 3,
      "text": "Once a session is established using the new client ID, the client will use reclaim-type locking requests (e.g., LOCK operations with reclaim set to TRUE and OPEN operations with a claim type of CLAIM_PREVIOUS; see Section 9.11) to re-establish its locking state. Once this is done, or if there is no such locking state to reclaim, the client sends a global RECLAIM_COMPLETE operation, i.e., one with the rca_one_fs argument set to FALSE, to indicate that it has reclaimed all of the locking state that it will reclaim. Once a client sends such a RECLAIM_COMPLETE operation, it may attempt non-reclaim locking operations, although it might get an NFS4ERR_GRACE status result from each such operation until the period of special handling is over. See Section 11.11.9 for a discussion of the analogous handling lock reclamation in the case of file systems transitioning from server to server.",
      "ja": "新しいクライアントIDを使用してセッションが確立されると、クライアントはReclaim型ロック要求を使用します（例：クレーム・オペレーション・クレーム・オペレーション・クレーム・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オブ・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション・オペレーション）。状態。これが行われると、または再利用するためのそのようなロック状態がない場合、クライアントはグローバルreclaim_complete操作、つまりRCA_ONE_FS引数をrca_one_fs引数に設定し、それが再生されるすべてのロック状態を再生したことを示します。。クライアントがそのようなRECLAIM_COMPLETE操作を送信すると、特別な処理の期間が終了するまで、それぞれのそのような操作からNFS4ERR_GRACEのステータスが発生する可能性がありますが、再生以外のロック操作を試みることがあります。サーバーからサーバーへの移行の場合のファイルシステムの場合の類似の処理ロック再生の説明については、11.11.9項を参照してください。"
    },
    {
      "indent": 3,
      "text": "During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE, unless it can guarantee that these may be done safely, as described below.",
      "ja": "猶予期間中、サーバは、以下に説明するように、NFS4ERR_GRACEのエラーで読み書き操作および再生されていないロック要求（すなわち、他のロックおよびオープン操作）を拒否しなければならない。"
    },
    {
      "indent": 3,
      "text": "The grace period may last until all clients that are known to possibly have had locks have done a global RECLAIM_COMPLETE operation, indicating that they have finished reclaiming the locks they held before the server restart. This means that a client that has done a RECLAIM_COMPLETE must be prepared to receive an NFS4ERR_GRACE when attempting to acquire new locks. In order for the server to know that all clients with possible prior lock state have done a RECLAIM_COMPLETE, the server must maintain in stable storage a list clients that may have such locks. The server may also terminate the grace period before all clients have done a global RECLAIM_COMPLETE. The server SHOULD NOT terminate the grace period before a time equal to the lease period in order to give clients an opportunity to find out about the server restart, as a result of sending requests on associated sessions with a frequency governed by the lease time. Note that when a client does not send such requests (or they are sent by the client but not received by the server), it is possible for the grace period to expire before the client finds out that the server restart has occurred.",
      "ja": "猶予期間は、おそらくロックが発生した可能性があるすべてのクライアントがグローバルRECLAIM_COMPLETE操作を行うまで、サーバーの再起動前に保持しているロックを再生したことを示しています。つまり、RECLAIM_COMPLETEを作成したクライアントは、新しいロックを取得しようとするとNFS4ERR_GRACEを受信するように準備する必要があります。以前のロック状態が可能なすべてのクライアントがRECLAIM_COMPLETEを実行したことをサーバが知るためには、サーバはそのようなロックを持つ可能性があるリストクライアントを安定した記憶域で維持する必要があります。サーバーは、すべてのクライアントがグローバルreclaim_completeを実行する前に猶予期間を終了することもできます。リース期間によって関連する頻度で関連するセッションで要求を送信した結果として、サーバーはリース期間に等しい時間の前に猶予期間を終了しないでください。クライアントがそのような要求を送信しない場合（またはそれらのクライアントによってサーバーによって送信されていないがサーバーによって受信されていない）場合、クライアントがサーバーの再起動が行われたことを判断する前に猶予期間が期限切れになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some additional time in order to allow a client to establish a new client ID and session and to effect lock reclaims may be added to the lease time. Note that analogous rules apply to file system-specific grace periods discussed in Section 11.11.9.",
      "ja": "クライアントが新しいクライアントIDとセッションを確立し、ロック再利用を実行できるようにするためのいくつかの追加の時間をリース時間に追加することができます。類似の規則は、セクション11.11.9で説明したファイルシステム固有の猶予期間に適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned even within the grace period, although NFS4ERR_GRACE must always be returned to clients attempting a non-reclaim lock request before doing their own global RECLAIM_COMPLETE. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between a potential reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.",
      "ja": "サーバが他のクライアントによるロックの再生と競合しないことをサーバが確実に判断できる場合は、NFS4ERR_GRACEは常に非以外のクライアントに返されなければならないが、NFS4ERR_GRACEエラーが返されない。 - 自分のグローバルRECLAIM_COMPLETEを実行する前にロック要求を解除してください。サーバーが猶予期間中に読み書き操作を処理できるようにするには、潜在的な再利用ロック要求と読み取りまたは書き込み操作の間で発生する可能性のない競合が発生しないことを保証することができます。サーバーがその保証を提供できない場合は、NFS4ERR_GRACEエラーをクライアントに返す必要があります。"
    },
    {
      "indent": 3,
      "text": "For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a locking, READ or WRITE operation can be safely processed.",
      "ja": "サーバーが猶予期間中に単純で有効な処理を提供するために、最も簡単な方法は、NFS4ERR_GRACEエラーを返すことによって、再利用されていないロック要求と読み書き操作を単に拒否することです。ただし、サーバーは付与されたロックに関する情報を安定したストレージに保持することがあります。この情報を使用すると、サーバーは、ロック、読み取りまたは書き込み操作を安全に処理できるかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "For example, if the server maintained on stable storage summary information on whether mandatory locks exist, either mandatory byte-range locks, or share reservations specifying deny modes, many requests could be allowed during the grace period. If it is known that no such share reservations exist, OPEN request that do not specify deny modes may be safely granted. If, in addition, it is known that no mandatory byte-range locks exist, either through information stored on stable storage or simply because the server does not support such locks, READ and WRITE operations may be safely processed during the grace period. Another important case is where it is known that no mandatory byte-range locks exist, either because the server does not provide support for them or because their absence is known from persistently recorded data. In this case, READ and WRITE operations specifying stateids derived from reclaim-type operations may be validly processed during the grace period because of the fact that the valid reclaim ensures that no lock subsequently granted can prevent the I/O.",
      "ja": "たとえば、必須ロックが存在するかどうか、必須のロックが存在するかどうか、または拒否モードを指定する共有予約のいずれかについて、サーバーがSTARY STORAGE SUMMORY情報で保持されている場合、猶予期間中に多くの要求を許可できます。そのような共有予約が存在しないことが知られている場合は、拒否モードを指定しないオープン要求を安全に付与することができます。さらに、安定した記憶装置に格納されている情報を介して、または単にサーバがそのようなロックをサポートしていないため、読み書き操作が猶予期間中に安全に処理されてもよい。これは、必須のバイトレンジロックが存在しないことが知られている。もう1つの重要なケースは、サーバーがそれらのサポートを提供していないため、またはそれらの欠如が永続的に記録されたデータから知られているため、必須のバイトレンジロックが存在しないことが知られている場合です。この場合、Reclaim型操作から導出されたStateIDを指定する読み書き操作は、有効な再利用がその後付与されていないロックがI / Oを妨げることができることを保証するという事実のために、猶予期間中に有効に処理され得る。"
    },
    {
      "indent": 3,
      "text": "To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.",
      "ja": "reliterateを繰り返すには、猶予期間中に非RECLAIMロックとI / O要求を処理することを可能にするサーバーの場合、その後再利用されるロックが拒否されず、その後RESLAIMEDがI / O操作を防止していないと判断する必要があります。猶予期間中に処理されます。"
    },
    {
      "indent": 3,
      "text": "Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case, the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [55]. The client must account for the server that can perform I/O and non-reclaim locking requests within the grace period as well as those that cannot do so.",
      "ja": "Reclaim LockおよびI / O要求のNFS4ERR_GRACEエラーの復帰には、クライアントを作成する必要があります。この場合、クライアントは要求のために再試行メカニズムを採用する必要があります。再試行間の遅延（数秒のオーダー）は、サーバを圧倒的に避けるために使用されるべきです。一般的な問題についてのさらなる議論は[55]に含まれる。クライアントは、猶予期間内のI / Oと回収されていないロック要求を実行できるサーバーと、そうすることができないリクエストを説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "A reclaim-type locking request outside the server's grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since restart.",
      "ja": "サーバーの猶予期間外の再利用タイプのロック要求は、サーバーが競合するロックまたはI / O要求が再起動してから付与されていないことを保証できる場合にのみ成功することができます。"
    },
    {
      "indent": 3,
      "text": "A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new client ID is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.",
      "ja": "サーバーが再起動時に、リース期間の新しい値を確立することがあります。したがって、クライアントは、新しいクライアントIDが確立されると、Lease_time属性を参照して、そのサーバーに関連付けられているリースのリース更新の基礎として使用する必要があります。ただし、このRestartイベントは、少なくとも前のサーバーのインスタンス化のリース期間限定の長期間の猶予期間を確立する必要があります。これにより、以前のサーバーインスタンス中に取得されたクライアント状態を確実に再確立できます。"
    },
    {
      "indent": 3,
      "text": "The possibility exists that, because of server configuration events, the client will be communicating with a server different than the one on which the locks were obtained, as shown by the combination of eir_server_scope and eir_server_owner. This leads to the issue of if and when the client should attempt to reclaim locks previously obtained on what is being reported as a different server. The rules to resolve this question are as follows:",
      "ja": "その可能性は、サーバ構成イベントのために、クライアントは、EIR_SERVER_SCOPEとEIR_SERVER_OWNERの組み合わせによって示されるように、クライアントがロックが得られたものとは異なるサーバと通信することになる。これは、クライアントが別のサーバーとして報告されているもので以前に取得されたロックを再利用しようとする場合の問題につながります。この質問を解決するための規則は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* If the server scope is different, the client should not attempt to reclaim locks. In this situation, no lock reclaim is possible. Any attempt to re-obtain the locks with non-reclaim operations is problematic since there is no guarantee that the existing filehandles will be recognized by the new server, or that if recognized, they denote the same objects. It is best to treat the locks as having been revoked by the reconfiguration event.",
      "ja": "* サーバースコープが異なる場合、クライアントはロックを再利用しようとしないでください。この状況では、ロック再利用は可能ではありません。既存のファイルハンドルが新しいサーバーによって認識されること、または認識されている場合、それらは同じオブジェクトによって認識されるという保証がないため、非再生操作でロックを再取得しようとすると問題があります。ロックを再構成イベントによって取り消されたときに扱うのが最善です。"
    },
    {
      "indent": 3,
      "text": "* If the server scope is the same, the client should attempt to reclaim locks, even if the eir_server_owner value is different. In this situation, it is the responsibility of the server to return NFS4ERR_NO_GRACE if it cannot provide correct support for lock reclaim operations, including the prevention of edge conditions.",
      "ja": "* サーバーの範囲が同じ場合、EIR_SERVER_OWNER値が異なる場合でも、クライアントはロックを再利用しようとします。この状況では、エッジ条件の防止を含め、ロック再生演算の正しいサポートを提供できない場合は、NFS4ERR_NO_GRACEを返すサーバーの責任です。"
    },
    {
      "indent": 3,
      "text": "The eir_server_owner field is not used in making this determination. Its function is to specify trunking possibilities for the client (see Section 2.10.5) and not to control lock reclaim.",
      "ja": "EIR_SERVER_OWNERフィールドはこの判断の中では使用されません。その関数は、クライアントのトランキングの可能性を指定することです（2.10.5項を参照）、RESCLAIM RESLAIMを制御しないようにします。"
    },
    {
      "indent": 0,
      "text": "8.4.2.1.1. Security Considerations for State Reclaim",
      "section_title": true,
      "ja": "8.4.2.1.1. 州の取り戻されたセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "During the grace period, a client can reclaim state that it believes or asserts it had before the server restarted. Unless the server maintained a complete record of all the state the client had, the server has little choice but to trust the client. (Of course, if the server maintained a complete record, then it would not have to force the client to reclaim state after server restart.) While the server has to trust the client to tell the truth, the negative consequences for security are limited to enabling denial-of-service attacks in situations in which AUTH_SYS is supported. The fundamental rule for the server when processing reclaim requests is that it MUST NOT grant the reclaim if an equivalent non-reclaim request would not be granted during steady state due to access control or access conflict issues. For example, an OPEN request during a reclaim will be refused with NFS4ERR_ACCESS if the principal making the request does not have access to open the file according to the discretionary ACL (Section 6.2.2) on the file.",
      "ja": "猶予期間中、クライアントは、サーバーが再起動する前にそれが持っていたと考慮またはアサートする状態を再利用することができます。サーバーがクライアントが持っていたすべての状態の完全な記録を維持していない限り、サーバーはほとんど選択されませんが、クライアントを信頼します。 （もちろん、サーバーが完全なレコードを維持している場合、サーバーの再起動後にクライアントが状態を再起動するように強制する必要はありません。 AUTH_SYSがサポートされている状況でサービス拒否攻撃を可能にします。 Reclaim要求を処理するときのサーバーの基本的な規則は、アクセス制御またはアクセス競合の問題のために定常状態の間に同等の非再生要求が許可されない場合にReBlaimを付与してはいけません。たとえば、リクエストを実行するプリンシパルがファイルの任意ACL（セクション6.2.2）に従ってファイルを開くのにアクセス権がない場合、Reclaimのオープン要求はNFS4ERR_ACCESSで拒否されます。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, it is possible that a client operating in error or maliciously could, during reclaim, prevent another client from reclaiming access to state. For example, an attacker could send an OPEN reclaim operation with a deny mode that prevents another client from reclaiming the OPEN state it had before the server restarted. The attacker could perform the same denial of service during steady state prior to server restart, as long as the attacker had permissions. Given that the attack vectors are equivalent, the grace period does not offer any additional opportunity for denial of service, and any concerns about this attack vector, whether during grace or steady state, are addressed the same way: use RPCSEC_GSS for authentication and limit access to the file only to principals that the owner of the file trusts.",
      "ja": "それにもかかわらず、relaimの間にエラーまたは故意で動作するクライアントが、別のクライアントが状態へのアクセスを再利用するのを防ぐことができる可能性があります。たとえば、攻撃者は、サーバーが再起動する前に他のクライアントが開いていたオープン状態を再利用するのを防ぐことを拒否モードでオープンリクローアップ操作を送信できます。攻撃者がアクセス許可を持っていれば、攻撃者は、サーバーの再起動前に定常状態の間同じサービス拒否を実行できます。攻撃ベクトルが同等であることを考えると、猶予期間はサービス拒否のための追加の機会を提供し、猶予または定常状態にあるかどうかにかかわらず、この攻撃ベクトルについての懸念は同じように対処されます。認証とリミットアクセスのためのRPCSEC_GSSを使用するファイルの所有者が信頼するプリンシパルにのみファイルに。"
    },
    {
      "indent": 3,
      "text": "Note that if prior to restart the server had client IDs with the EXCHGID4_FLAG_BIND_PRINC_STATEID (Section 18.35) capability set, then the server SHOULD record in stable storage the client owner and the principal that established the client ID via EXCHANGE_ID. If the server does not, then there is a risk a client will be unable to reclaim state if it does not have a credential for a principal that was originally authorized to establish the state.",
      "ja": "サーバーを再起動する前にEXCHGID4_FLAG_BIND_PRINC_STATEID（セクション18.35）機能セットを使用したクライアントIDがある場合、サーバーはクライアント所有者とExchange_IDを介してクライアントIDを確立したプリンシパルを安定したストレージに記録する必要があります。サーバーがそうでない場合は、元々の状態を確立することを許可されていたプリンシパルの資格情報がない場合、クライアントが状態を再利用できないリスクがあります。"
    },
    {
      "indent": 0,
      "text": "8.4.3. Network Partitions and Recovery",
      "section_title": true,
      "ja": "8.4.3. ネットワークパーティションとリカバリ"
    },
    {
      "indent": 3,
      "text": "If the duration of a network partition is greater than the lease period provided by the server, the server will not have received a lease renewal from the client. If this occurs, the server may free all locks held for the client or it may allow the lock state to remain for a considerable period, subject to the constraint that if a request for a conflicting lock is made, locks associated with an expired lease do not prevent such a conflicting lock from being granted but MUST be revoked as necessary so as to avoid interfering with such conflicting requests.",
      "ja": "ネットワークパーティションの持続時間がサーバーによって提供されるリース期間よりも大きい場合、サーバーはクライアントからリース更新を受信していません。これが起こると、サーバーはクライアントに保持されているすべてのロックを解放することも、競合するロックの要求が行われた場合、期限切れのリースに関連するロックの拘束の対象となる、かなりの期間ロック状態のままにすることができます。そのような矛盾するロックが付与されないようにするのを防ぐのではなく、そのような矛盾する要求の妨害を避けるために必要に応じて失効する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server chooses to delay freeing of lock state until there is a conflict, it may either free all of the client's locks once there is a conflict or it may only revoke the minimum set of locks necessary to allow conflicting requests. When it adopts the finer-grained approach, it must revoke all locks associated with a given stateid, even if the conflict is with only a subset of locks.",
      "ja": "サーバーが競合があるまでロック状態の解放を遅らせることを選択した場合、競合があるか、競合する要求を許可するのに必要な最小ロックセットのみを取り消すことができる場合は、クライアントのすべてのロックを解放する可能性があります。それがより細かいアプローチを採用するとき、それは競合がロックのサブセットだけであっても、特定のStateIDに関連するすべてのロックを取り消す必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server chooses to free all of a client's lock state, either immediately upon lease expiration or as a result of the first attempt to obtain a conflicting a lock, the server may report the loss of lock state in a number of ways.",
      "ja": "サーバーがリースの有効期限の直後または最初のロックを取得しようとした結果として、クライアントのすべてのロック状態のすべてを解放することを選択した場合、サーバーはロック状態の損失をいくつかの方法で報告することがあります。"
    },
    {
      "indent": 3,
      "text": "The server may choose to invalidate the session and the associated client ID. In this case, once the client can communicate with the server, it will receive an NFS4ERR_BADSESSION error. Upon attempting to create a new session, it would get an NFS4ERR_STALE_CLIENTID. Upon creating the new client ID and new session, the client will attempt to reclaim locks. Normally, the server will not allow the client to reclaim locks, because the server will not be in its recovery grace period.",
      "ja": "サーバーは、セッションと関連するクライアントIDを無効にすることを選択できます。この場合、クライアントがサーバーと通信できると、NFS4ERR_BAdessionエラーが表示されます。新しいセッションを作成しようとすると、NFS4ERR_STALE_CLIENTIDが表示されます。新しいクライアントIDと新しいセッションを作成すると、クライアントはロックを再利用しようとします。通常、サーバーはリカバリ猶予期間内にないため、サーバーはロックを再利用できません。"
    },
    {
      "indent": 3,
      "text": "Another possibility is for the server to maintain the session and client ID but for all stateids held by the client to become invalid or stale. Once the client can reach the server after such a network partition, the status returned by the SEQUENCE operation will indicate a loss of locking state; i.e., the flag SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED will be set in sr_status_flags. In addition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will suitably notify the applications that held the invalidated locks. The client should then take action to free invalidated stateids, either by establishing a new client ID using a new verifier or by doing a FREE_STATEID operation to release each of the invalidated stateids.",
      "ja": "もう1つの可能性は、サーバーがセッションとクライアントIDを維持しますが、クライアントが保持しているすべてのステートに無効または古くなるようになります。そのようなネットワークパーティションの後にクライアントがサーバーに到達すると、シーケンス操作によって返されたステータスはロック状態の損失を示します。すなわち、フラグSEQ4_STATUS_EXPIED_ALL_STATE_REVOKEDはSR_STATUS_FLAGSに設定される。さらに、クライアントから送信されたすべてのI / Oが、NFS4ERR_Expiredを返しているサーバーでは、サーバーで失敗します。クライアントがロック状態の損失を学習すると、無効化されたロックを保持しているアプリケーションに適切に通知します。その後、クライアントは、新しい検証者を使用して新しいクライアントIDを確立することによって、またはFree_StateID操作を実行して各無効化されたStateIDを解放することによって、無効化されたステートIDを使用してアクションを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server adopts a finer-grained approach to revocation of locks when a client's lease has expired, only a subset of stateids will normally become invalid during a network partition. When the client can communicate with the server after such a network partition heals, the status returned by the SEQUENCE operation will indicate a partial loss of locking state (SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED). In addition, operations, including I/O submitted by the client, with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will use the TEST_STATEID operation on all of its stateids to determine which locks have been lost and then suitably notify the applications that held the invalidated locks. The client can then release the invalidated locking state and acknowledge the revocation of the associated locks by doing a FREE_STATEID operation on each of the invalidated stateids.",
      "ja": "クライアントのリースが期限切れになったときにサーバーがロックの失効に細かいアプローチを採用した場合、ネットワークパーティションの間、StateIDSのサブセットのみが正常に無効になります。そのようなネットワークパーティションのヘールの後にクライアントがサーバと通信できる場合、シーケンス操作によって返されるステータスはロック状態の部分的な損失（SEQ4_STATUS_EXPIED_SOME_STATE_REVOKED）を示す。さらに、クライアントから送信されたI / Oを含む操作は、サーバーがエラーNFS4ERR_Expiredを返すことで失敗します。クライアントがロック状態の喪失を学習すると、そのすべてのStateIDでTEST_STATEID操作を使用して、どのロックが失われてから無効化されたロックを保持しているアプリケーションに適切に通知します。その後、クライアントは無効化されたロック状態を解放し、無効化された各StateIDのFree_StateID操作を実行することによって、関連するロックの失効を確認できます。"
    },
    {
      "indent": 3,
      "text": "When a network partition is combined with a server restart, there are edge conditions that place requirements on the server in order to avoid silent data corruption following the server restart. Two of these edge conditions are known, and are discussed below.",
      "ja": "ネットワークパーティションがサーバーの再起動と組み合わされると、サーバーの再起動後にサイレントデータの破損を回避するためにサーバーに要件を配置するエッジ条件があります。これらのエッジ条件のうちの2つは知られており、以下で論じる。"
    },
    {
      "indent": 3,
      "text": "The first edge condition arises as a result of the scenarios such as the following:",
      "ja": "次のようなシナリオの結果として、最初のエッジ状態が発生します。"
    },
    {
      "indent": 3,
      "text": "1. Client A acquires a lock.",
      "ja": "1. クライアントAはロックを取得します。"
    },
    {
      "indent": 3,
      "text": "2. Client A and server experience mutual network partition, such that client A is unable to renew its lease.",
      "ja": "2. クライアントAとサーバーは、クライアントAがリースを更新できないように、相互ネットワークパーティションを体験します。"
    },
    {
      "indent": 3,
      "text": "3. Client A's lease expires, and the server releases the lock.",
      "ja": "3. クライアントAのリースが期限切れになり、サーバーはロックを解放します。"
    },
    {
      "indent": 3,
      "text": "4. Client B acquires a lock that would have conflicted with that of client A.",
      "ja": "4. クライアントBはクライアントAのそれと矛盾しているようなロックを取得します。"
    },
    {
      "indent": 3,
      "text": "5. Client B releases its lock.",
      "ja": "5. クライアントBはそのロックを解放します。"
    },
    {
      "indent": 3,
      "text": "6. Server restarts.",
      "ja": "6. サーバーの再起動"
    },
    {
      "indent": 3,
      "text": "7. Network partition between client A and server heals.",
      "ja": "7. クライアントAとサーバーの治癒の間のネットワークパーティション。"
    },
    {
      "indent": 3,
      "text": "8. Client A connects to a new server instance and finds out about server restart.",
      "ja": "8. クライアントAは新しいサーバーインスタンスに接続し、サーバーの再起動について検索します。"
    },
    {
      "indent": 3,
      "text": "9. Client A reclaims its lock within the server's grace period.",
      "ja": "9. クライアントAは、サーバーの猶予期間内にロックを再利用します。"
    },
    {
      "indent": 3,
      "text": "Thus, at the final step, the server has erroneously granted client A's lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.",
      "ja": "したがって、最後のステップで、サーバーは誤ってクライアントAのロック再利用を許可しました。クライアントBがオブジェクトを変更した場合、ロックが保護されていた場合、クライアントAはオブジェクトの破損を経験します。"
    },
    {
      "indent": 3,
      "text": "The second known edge condition arises in situations such as the following:",
      "ja": "第2の既知のエッジ条件は、次のような状況で発生する。"
    },
    {
      "indent": 3,
      "text": "1. Client A acquires one or more locks.",
      "ja": "1. クライアントAは1つ以上のロックを取得します。"
    },
    {
      "indent": 3,
      "text": "2. Server restarts.",
      "ja": "2. サーバーの再起動"
    },
    {
      "indent": 3,
      "text": "3. Client A and server experience mutual network partition, such that client A is unable to reclaim all of its locks within the grace period.",
      "ja": "3. クライアントAとサーバーは、クライアントAが猶予期間内のすべてのロックを再利用できないように、相互ネットワークパーティションを体験します。"
    },
    {
      "indent": 3,
      "text": "4. Server's reclaim grace period ends. Client A has either no locks or an incomplete set of locks known to the server.",
      "ja": "4. サーバーの再利用猶予期間が終了します。クライアントAには、ロックまたはサーバーに認識されている不完全なロックのセットがあります。"
    },
    {
      "indent": 3,
      "text": "5. Client B acquires a lock that would have conflicted with a lock of client A that was not reclaimed.",
      "ja": "5. クライアントBは、クライアントAのロックと矛盾していたロックを取得しました。"
    },
    {
      "indent": 3,
      "text": "6. Client B releases the lock.",
      "ja": "6. クライアントBロックを解除します。"
    },
    {
      "indent": 3,
      "text": "7. Server restarts a second time.",
      "ja": "7. サーバーは2回目に再起動します。"
    },
    {
      "indent": 3,
      "text": "8. Network partition between client A and server heals.",
      "ja": "8. クライアントAとサーバーの治癒の間のネットワークパーティション。"
    },
    {
      "indent": 3,
      "text": "9. Client A connects to new server instance and finds out about server restart.",
      "ja": "9. クライアントAは新しいサーバーインスタンスに接続し、サーバーの再起動について検索します。"
    },
    {
      "indent": 3,
      "text": "10. Client A reclaims its lock within the server's grace period.",
      "ja": "10. クライアントAは、サーバーの猶予期間内にロックを再利用します。"
    },
    {
      "indent": 3,
      "text": "As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A's lock reclaim.",
      "ja": "第1のエッジ状態と同様に、第2のエッジ状態のシナリオの最後のステップは、サーバが誤ってクライアントAのロック再利用を許可することを有する。"
    },
    {
      "indent": 3,
      "text": "Solving the first and second edge conditions requires either that the server always assumes after it restarts that some edge condition occurs, and thus returns NFS4ERR_NO_GRACE for all reclaim attempts, or that the server record some information in stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server intends to be whenever edge conditions arise. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is released. For the two edge conditions discussed above, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:",
      "ja": "第1および第2のエッジ条件を解決するには、一部のエッジ条件が発生したことを再起動した後にサーバが常に仮定し、したがってNFS4ERR_NO_GRACEを返し、したがって、サーバが一部の情報を安定したストレージに記録することを要求する。サーバーレコードが安定したストレージ内の情報のレコードは、エッジ条件が発生するたびにサーバーがどのようになる予定のものに比例しています。すべてのエッジ条件を完全に耐えるサーバーは、取得されたすべてのロックごとに安定したストレージで記録され、ロックが解除されたときにのみ安定したストレージからロックレコードを削除します。上述した2つのエッジ条件では、サーバーを厳密にすることができ、それでも再利用の猶予期間をサポートすることができ、サーバーレコードが安定した記憶域では最小限の情報が必要です。たとえば、サーバーの実装は、各クライアントに対して、安定したストレージに保存され、次のようなレコードを保存できます。"
    },
    {
      "indent": 3,
      "text": "* the co_ownerid field from the client_owner4 presented in the EXCHANGE_ID operation.",
      "ja": "* Exchange_ID操作で提示されたCLIENT_OWNER4のCO_OWNERIDフィールド。"
    },
    {
      "indent": 3,
      "text": "* a boolean that indicates if the client's lease expired or if there was administrative intervention (see Section 8.5) to revoke a byte-range lock, share reservation, or delegation and there has been no acknowledgment, via FREE_STATEID, of such revocation.",
      "ja": "* バイトレンジロック、共有予約、または委任を取り消すには、クライアントのリースが期限切れになったか、または管理介入（セクション8.5を参照）が発生した場合は、このような失効のfree_stateIDを介して確認応答はありませんでした。"
    },
    {
      "indent": 3,
      "text": "* a boolean that indicates whether the client may have locks that it believes to be reclaimable in situations in which the grace period was terminated, making the server's view of lock reclaimability suspect. The server will set this for any client record in stable storage where the client has not done a suitable RECLAIM_COMPLETE (global or file system-specific depending on the target of the lock request) before it grants any new (i.e., not reclaimed) lock to any client.",
      "ja": "* クライアントが猶予期間が終了した状況で再生可能であると考えているロックがあるかどうかを示すブール値は、サーバーのロック再生可能性の表示が容疑されています。サーバーは、新しい（すなわち、再生されていない）ロックを付与する前に、クライアントが適切なRECLAIM_COMPLETE（ロック要求のターゲットに応じてグローバルまたはファイルシステム固有）を行っていない安定したストレージ内のクライアントレコードに対してこれを設定します。任意のクライアント。"
    },
    {
      "indent": 3,
      "text": "Assuming the above record keeping, for the first edge condition, after the server restarts, the record that client A's lease expired means that another client could have acquired a conflicting byte-range lock, share reservation, or delegation. Hence, the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.",
      "ja": "上記のレコードを最初のエッジ状態を保持すると仮定すると、サーバーが再起動した後に、クライアントAのリースが期限切れになったレコードは、別のクライアントが競合するバイトレンジロック、共有予約、または委任を取得できることを意味します。したがって、サーバーはエラーNFS4ERR_NO_GRACEを使用してクライアントAから再利用を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the second edge condition, after the server restarts for a second time, the indication that the client had not completed its reclaims at the time at which the grace period ended means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.",
      "ja": "2番目のエッジ条件では、サーバーが2回目に再起動した後、クライアントが猶予期間が終了した時点でクライアントが再利用を完了していないという指示は、サーバーがエラーNFS4ERR_NO_GRACEでクライアントAから再利用を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "When either edge condition occurs, the client's attempt to reclaim locks will result in the error NFS4ERR_NO_GRACE. When this is received, or after the client restarts with no lock state, the client will send a global RECLAIM_COMPLETE. When the RECLAIM_COMPLETE is received, the server and client are again in agreement regarding reclaimable locks and both booleans in persistent storage can be reset, to be set again only when there is a subsequent event that causes lock reclaim operations to be questionable.",
      "ja": "どちらのエッジ条件が発生した場合、クライアントのロックを再利用しようとすると、エラーNFS4ERR_NO_GRACEが発生します。これが受信されたとき、またはクライアントがロック状態なしで再起動した後に、クライアントはグローバルreclaim_completeを送信します。RECLAIM_COMPLETEが受信されると、サーバーとクライアントは再度再生可能なロックに関して再び契約し、永続ストレージ内のブール値の両方をリセットすることができます。ロック再生操作を疑問にかけるようになった後続のイベントがある場合にのみ設定できます。"
    },
    {
      "indent": 3,
      "text": "Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, byte-range locks, and delegations):",
      "ja": "録音するためのレベルとアプローチに関係なく、サーバーは次のいずれかの戦略を実行する必要があります（これは、共有予約、バイトレンジロック、および代表団の再利用に適用されます）。"
    },
    {
      "indent": 3,
      "text": "1. Reject all reclaims with NFS4ERR_NO_GRACE. This is extremely unforgiving, but necessary if the server does not record lock state in stable storage.",
      "ja": "1. NFS4ERR_NO_GRACEですべての再利用を拒否します。これは非常に許されていませんが、サーバーが安定したストレージでロック状態を記録しない場合に必要です。"
    },
    {
      "indent": 3,
      "text": "2. Record sufficient state in stable storage such that all known edge conditions involving server restart, including the two noted in this section, are detected. It is acceptable to erroneously recognize an edge condition and not allow a reclaim, when, with sufficient knowledge, it would be allowed. The error the server would return in this case is NFS4ERR_NO_GRACE. Note that it is not known if there are other edge conditions.",
      "ja": "2. このセクションに記載されている2つの2つを含むサーバーの再起動を含むすべての既知のエッジ条件が検出されるように、安定したストレージで十分な状態を記録します。誤ってエッジ状態を認識し、再利用を許可しないと、十分な知識で許可されることが許容されます。この場合、サーバーが返すエラーはNFS4ERR_NO_GRACEです。他のエッジ条件があるかどうかはわかりません。"
    },
    {
      "indent": 7,
      "text": "In the event that, after a server restart, the server determines there is unrecoverable damage or corruption to the information in stable storage, then for all clients and/or locks that may be affected, the server MUST return NFS4ERR_NO_GRACE.",
      "ja": "サーバーの再起動後、サーバーは安定したストレージ内の情報の回復不可能な損傷または破損があると判断した場合、その影響を受ける可能性のあるすべてのクライアントやロックに対して、サーバーはNFS4ERR_NO_GRACEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "A mandate for the client's handling of the NFS4ERR_NO_GRACE error is outside the scope of this specification, since the strategies for such handling are very dependent on the client's operating environment. However, one potential approach is described below.",
      "ja": "そのような処理のための戦略はクライアントのオペレーティング環境に非常に依存しているため、クライアントのNFS4ERR_NO_GRACEエラーの取り扱いの任務は、この仕様の範囲外です。しかしながら、1つの潜在的なアプローチについて説明する。"
    },
    {
      "indent": 3,
      "text": "When the client receives NFS4ERR_NO_GRACE, it could examine the change attribute of the objects for which the client is trying to reclaim state, and use that to determine whether to re-establish the state via normal OPEN or LOCK operations. This is acceptable provided that the client's operating environment allows it. In other words, the client implementor is advised to document for his users the behavior. The client could also inform the application that its byte-range lock or share reservations (whether or not they were delegated) have been lost, such as via a UNIX signal, a Graphical User Interface (GUI) pop-up window, etc. See Section 10.5 for a discussion of what the client should do for dealing with unreclaimed delegations on client state.",
      "ja": "クライアントがNFS4ERR_NO_GRACEを受信すると、クライアントが状態を再実行しようとしているオブジェクトの変更属性を調べ、それを使用して、通常のオープンまたはロック操作を介して状態を再確立するかどうかを判断できます。これは、クライアントの動作環境がそれを許可するという条件でもあります。言い換えれば、クライアント実装者は彼のユーザーの行動を文書化することをお勧めします。クライアントは、UNIX信号、グラフィカルユーザインタフェース（GUI）ポップアップウィンドウなどのように、そのバイトレンジロックまたは共有予約（それらが委任されたかどうか）が失われたことをアプリケーションに通知することができます。クライアントの州で未分類の委任を扱うためにクライアントができることについての議論については、10.5項。"
    },
    {
      "indent": 3,
      "text": "For further discussion of revocation of locks, see Section 8.5.",
      "ja": "ロックの取り消しについてのさらなる議論については、8.5節を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.5. Server Revocation of Locks",
      "section_title": true,
      "ja": "8.5. ロックのサーバーの失効"
    },
    {
      "indent": 3,
      "text": "At any point, the server can revoke locks held by a client, and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.",
      "ja": "任意の時点で、サーバーはクライアントによって保持されているロックを取り消すことができ、このイベントにクライアントを作成する必要があります。クライアントがそのロックが取り消されたことを検出した場合、クライアントはそれ自体とサーバー間の状態情報を検証する責任があります。クライアントのロック状態の検証は、現在保持されている各ロックの状態を検証または再生する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "The first occasion of lock revocation is upon server restart. Note that this includes situations in which sessions are persistent and locking state is lost. In this class of instances, the client will receive an error (NFS4ERR_STALE_CLIENTID) on an operation that takes client ID, usually as part of recovery in response to a problem with the current session), and the client will proceed with normal crash recovery as described in the Section 8.4.2.1.",
      "ja": "ロック失効の最初の機会はサーバーの再起動時にあります。これには、セッションが永続的で、ロック状態が失われる状況が含まれます。このクラスのインスタンスでは、クライアントは、通常、現在のセッションの問題に応答してリカバリの一部としてクライアントIDを取得し、クライアントが説明されているように通常のクラッシュリカバリを続行する操作でエラー（NFS4ERR_STALE_CLIENTID）を受け取ります。8.4.2.1項で。"
    },
    {
      "indent": 3,
      "text": "The second occasion of lock revocation is the inability to renew the lease before expiration, as discussed in Section 8.4.3. While this is considered a rare or unusual event, the client must be prepared to recover. The server is responsible for determining the precise consequences of the lease expiration, informing the client of the scope of the lock revocation decided upon. The client then uses the status information provided by the server in the SEQUENCE results (field sr_status_flags, see Section 18.46.3) to synchronize its locking state with that of the server, in order to recover.",
      "ja": "第8,8節で説明したように、ロック失効の2番目の機会は、有効期限の前にリースを更新できないことです。これは稀なまたは珍しいイベントと見なされますが、クライアントは回復する準備をしなければなりません。サーバーはリース期限切れの正確な結果を決定する責任があり、ロック失効の範囲の範囲をクライアントに知らせる責任があります。その後、クライアントは、サーバーによって提供されたステータス情報（フィールドSR_STATUS_FLAGS、セクション18.46.3）を使用して、回復するためにサーバーのロック状態と同期します。"
    },
    {
      "indent": 3,
      "text": "The third occasion of lock revocation can occur as a result of revocation of locks within the lease period, either because of administrative intervention or because a recallable lock (a delegation or layout) was not returned within the lease period after having been recalled. While these are considered rare events, they are possible, and the client must be prepared to deal with them. When either of these events occurs, the client finds out about the situation through the status returned by the SEQUENCE operation. Any use of stateids associated with locks revoked during the lease period will receive the error NFS4ERR_ADMIN_REVOKED or NFS4ERR_DELEG_REVOKED, as appropriate.",
      "ja": "ロック失効の第3の機会は、管理介入のため、またはリコール可能なロック（委任またはレイアウト）が呼び出された後にリース期間内に戻されなかったため、リース期間内のロックの失効の結果として発生する可能性があります。これらはまれなイベントと見なされますが、可能であり、クライアントはそれらに対処する準備をしなければなりません。これらのイベントのどちらかが発生すると、クライアントはシーケンス操作によって返されたステータスを通して状況について見つけられます。リース期間中に取り消されたロックに関連するStequeIDの使用は、必要に応じて、エラーNFS4ERR_ADMIN_REVOKEDまたはNFS4ERR_DELEG_REVOKEDを受け取ります。"
    },
    {
      "indent": 3,
      "text": "In all situations in which a subset of locking state may have been revoked, which include all cases in which locking state is revoked within the lease period, it is up to the client to determine which locks have been revoked and which have not. It does this by using the TEST_STATEID operation on the appropriate set of stateids. Once the set of revoked locks has been determined, the applications can be notified, and the invalidated stateids can be freed and lock revocation acknowledged by using FREE_STATEID.",
      "ja": "ロック状態のサブセットが取り消された可能性がある状況では、ロック状態がリース期間内に取り消されるすべてのケースを含むすべての状況では、どのロックが取り消されていないかを判断するためにクライアント次第です。これは、適切なStateIDSのセットに対してtest_stateID操作を使用することによって行われます。一連の無効なロックが決定されたら、アプリケーションに通知することができ、無効化されたステートIDは解放され、Free_StateIDを使用して確認された失効を確認することができます。"
    },
    {
      "indent": 0,
      "text": "8.6. Short and Long Leases",
      "section_title": true,
      "ja": "8.6. 短くて長いリース"
    },
    {
      "indent": 3,
      "text": "When determining the time period for the server lease, the usual lease trade-offs apply. A short lease is good for fast server recovery at a cost of increased operations to effect lease renewal (when there are no other operations during the period to effect lease renewal as a side effect). A long lease is certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of extra requests to effect lock renewal drops in inverse proportion to the lease time. The disadvantages of a long lease include the possibility of slower recovery after certain failures. After server failure, a longer grace period may be required when some clients do not promptly reclaim their locks and do a global RECLAIM_COMPLETE. In the event of client failure, the longer period for a lease to expire will force conflicting requests to wait longer.",
      "ja": "サーバーリースの期間を決定するときは、通常のリーストレードオフが適用されます。短いリースは、リース更新を行うための業務のコストでの高速サーバーの回復に適しています（リースの更新を副作用として有効にする期間中に他の操作がない場合）。長いリースは確かに幼稚園と非常に多数のクライアントを処理しようとしているサーバーへの緊密なものです。ロック更新を行うための追加要求の数は、リース時間に反比例します。長いリースの不利な点には、特定の失敗後の回復が遅い可能性があります。サーバー障害後、一部のクライアントが自分のロックを再利用してグローバルRECLAIM_COMPLETEを実行しない場合は、長い猶予期間が長くなることがあります。クライアントの障害が発生した場合、リースのリースの期間の長期間は、競合する要求に長く待つことができます。"
    },
    {
      "indent": 3,
      "text": "A long lease is practical if the server can store lease state in stable storage. Upon recovery, the server can reconstruct the lease state from its stable storage and continue operation with its clients.",
      "ja": "サーバーが安定したストレージにリース状態を保存できる場合は、長いリースが実用的です。回復すると、サーバーはその安定したストレージからリース状態を再構築し、そのクライアントで操作を続けることができます。"
    },
    {
      "indent": 0,
      "text": "8.7. Clocks, Propagation Delay, and Calculating Lease Expiration",
      "section_title": true,
      "ja": "8.7. クロック、伝播遅延、およびリースの推定の計算"
    },
    {
      "indent": 3,
      "text": "To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lease. There is also the issue of propagation delay across the network, which could easily be several hundred milliseconds, as well as the possibility that requests will be lost and need to be retransmitted.",
      "ja": "同期クロックの必要性を回避するために、リースタイムはサーバーによって時間デルタとして許可されます。ただし、クライアントのクロックとサーバーのクロックがリース期間にわたって過度にドリフトしないという要件があります。ネットワーク全体での伝播遅延もあり、これは数百ミリ秒、ならびに要求が失われ、再送信される可能性がある可能性がある。"
    },
    {
      "indent": 3,
      "text": "To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 milliseconds, then it can assume that the lease is already 200 milliseconds old when it gets it). In addition, it will take another 200 milliseconds to get a response back to the server. So the client must send a lease renewal or write data back to the server at least 400 milliseconds before the lease would expire. If the propagation delay varies over the life of the lease (e.g., the client is on a mobile host), the client will need to continuously subtract the increase in propagation delay from the lease times.",
      "ja": "伝播遅延を考慮に入れるためには、クライアントはリース時間からそれを減算するべきである（例えば、クライアントが200ミリ秒と推定されている場合、リースがすでに200ミリ秒後に古いと仮定することができる）。さらに、さらに200ミリ秒かかり、サーバーに返答します。そのため、リースが期限切れになる前に、クライアントはリース更新またはデータをサーバーに返送する必要があります。伝播遅延がリースの寿命を介して変化する（例えば、クライアントがモバイルホスト上にある）場合、クライアントはリース時間から伝播遅延の増加を継続的に減算する必要がある。"
    },
    {
      "indent": 3,
      "text": "The server's lease period configuration should take into account the network distance of the clients that will be accessing the server's resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server's administrator may have to tune the lease period.",
      "ja": "サーバーのリース期間構成は、サーバーのリソースにアクセスするクライアントのネットワーク距離を考慮に入れる必要があります。リース期間は、ネットワーク伝播遅延やクライアントの人口の他のネットワーク遅延係数を考慮に入れることが予想されます。プロトコルは自動的な方法が適切なリース期間を決定することを許可しないので、サーバーの管理者はリース期間を調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.8. Obsolete Locking Infrastructure from NFSv4.0",
      "section_title": true,
      "ja": "8.8. NFSV4.0からの廃止されたロッキングインフラストラクチャ"
    },
    {
      "indent": 3,
      "text": "There are a number of operations and fields within existing operations that no longer have a function in NFSv4.1. In one way or another, these changes are all due to the implementation of sessions that provide client context and exactly once semantics as a base feature of the protocol, separate from locking itself.",
      "ja": "NFSv4.1に関数がなくなった既存の操作内には、さまざまな操作やフィールドがいくつかあります。ある意味では、これらの変更はすべて、クライアントコンテキストを提供するセッションの実装と、プロトコルの基本機能として一度だけセマンティクスの実装があります。"
    },
    {
      "indent": 3,
      "text": "The following NFSv4.0 operations MUST NOT be implemented in NFSv4.1. The server MUST return NFS4ERR_NOTSUPP if these operations are found in an NFSv4.1 COMPOUND.",
      "ja": "次のNFSV4.0操作はNFSV4.1で実装してはいけません。これらの操作がNFSV4.1コンパウンドに見つかった場合、サーバーはNFS4ERR_NOTSUPPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* SETCLIENTID since its function has been replaced by EXCHANGE_ID.",
      "ja": "* SetClientIDその関数はExchange_IDに置き換えられています。"
    },
    {
      "indent": 3,
      "text": "* SETCLIENTID_CONFIRM since client ID confirmation now happens by means of CREATE_SESSION.",
      "ja": "* create_sessionを使用してクライアントIDの確認が発生するようになったため、setclientid_confirm。"
    },
    {
      "indent": 3,
      "text": "* OPEN_CONFIRM because state-owner-based seqids have been replaced by the sequence ID in the SEQUENCE operation.",
      "ja": "* open_confird State-Owner-Based SeqIDがシーケンス操作のシーケンスIDに置き換えられているためです。"
    },
    {
      "indent": 3,
      "text": "* RELEASE_LOCKOWNER because lock-owners with no associated locks do not have any sequence-related state and so can be deleted by the server at will.",
      "ja": "* Release_LockOwnerに関連付けられているロックを持たないロック所有者にはシーケンス関連の状態がありませんので、サーバーによって削除される可能性があります。"
    },
    {
      "indent": 3,
      "text": "* RENEW because every SEQUENCE operation for a session causes lease renewal, making a separate operation superfluous.",
      "ja": "* セッションのすべてのシーケンス操作がリース更新を引き起こし、別々の操作を余分にします。"
    },
    {
      "indent": 3,
      "text": "Also, there are a number of fields, present in existing operations, related to locking that have no use in minor version 1. They were used in minor version 0 to perform functions now provided in a different fashion.",
      "ja": "また、マイナーバージョン1では使用されていないロックに関連する既存の操作に存在する数のフィールドがいくつかあります。"
    },
    {
      "indent": 3,
      "text": "* Sequence ids used to sequence requests for a given state-owner and to provide retry protection, now provided via sessions.",
      "ja": "* 特定の状態 - 所有者の要求を配列し、再試行保護を提供するために使用されるシーケンスIDは、現在セッションを介して提供されます。"
    },
    {
      "indent": 3,
      "text": "* Client IDs used to identify the client associated with a given request. Client identification is now available using the client ID associated with the current session, without needing an explicit client ID field.",
      "ja": "* クライアントIDは、特定の要求に関連付けられているクライアントを識別するために使用されます。明示的なクライアントIDフィールドを必要とせずに、現在のセッションに関連付けられているクライアントIDを使用して、クライアント識別情報が利用可能になりました。"
    },
    {
      "indent": 3,
      "text": "Such vestigial fields in existing operations have no function in NFSv4.1 and are ignored by the server. Note that client IDs in operations new to NFSv4.1 (such as CREATE_SESSION and DESTROY_CLIENTID) are not ignored.",
      "ja": "既存の操作のそのような逸脱フィールドは、NFSV4.1には機能はありません。サーバーによって無視されます。NFSv4.1（create_sessionやdestroy_clientidなど）に新しい操作のクライアントIDは無視されません。"
    },
    {
      "indent": 0,
      "text": "9. File Locking and Share Reservations",
      "section_title": true,
      "ja": "9. ファイルロックと共有予約"
    },
    {
      "indent": 3,
      "text": "To support Win32 share reservations, it is necessary to provide operations that atomically open or create files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFSv4.1 protocol defines an OPEN operation that is capable of atomically looking up, creating, and locking a file on the server.",
      "ja": "Win32共有予約をサポートするには、アトミックにオープンまたはファイルを作成する操作を提供する必要があります。別のShare / Unshare操作を持つと、Win32 OpenFile APIの正しい実装を許可しません。Share Semanticsを正しく実装するために、ファイルが開いたり作成されたり作成されたりしたときに使用される前のNFSプロトコルメカニズム（ルックアップ、作成、アクセス）を置き換える必要があります。NFSV4.1プロトコルは、サーバー上のファイルを起動、作成、およびロックすることができるオープン操作を定義します。"
    },
    {
      "indent": 0,
      "text": "9.1. Opens and Byte-Range Locks",
      "section_title": true,
      "ja": "9.1. オープンとバイトレンジロック"
    },
    {
      "indent": 3,
      "text": "It is assumed that manipulating a byte-range lock is rare when compared to READ and WRITE operations. It is also assumed that server restarts and network partitions are relatively rare. Therefore, it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A LOCK operation contains the heavyweight information required to establish a byte-range lock and uniquely define the owner of the lock.",
      "ja": "読み書き操作と比較して、バイトレンジロックを操作することはまれであると仮定されます。サーバーの再起動とネットワークパーティションが比較的まれであるとも想定されています。したがって、読み取り操作には、保持されたロックを持つかどうかを示すための軽量のメカニズムがあることが重要です。ロック操作には、バイトレンジロックを確立し、ロックの所有者を一意に定義するために必要なヘビー級情報が含まれています。"
    },
    {
      "indent": 0,
      "text": "9.1.1. State-Owner Definition",
      "section_title": true,
      "ja": "9.1.1. 州所有者の定義"
    },
    {
      "indent": 3,
      "text": "When opening a file or requesting a byte-range lock, the client must specify an identifier that represents the owner of the requested lock. This identifier is in the form of a state-owner, represented in the protocol by a state_owner4, a variable-length opaque array that, when concatenated with the current client ID, uniquely defines the owner of a lock managed by the client. This may be a thread ID, process ID, or other unique value.",
      "ja": "ファイルを開くときやバイトレンジロックを要求するとき、クライアントは要求されたロックの所有者を表す識別子を指定する必要があります。この識別子は、現在のクライアントIDと連結されたときに、クライアントによって管理されているロックの所有者を一意に定義する、State_OWNER4、可変長の不透明な配列によってプロトコルで表されている状態 - 所有者の形式です。これは、スレッドID、プロセスID、またはその他の固有の値であり得る。"
    },
    {
      "indent": 3,
      "text": "Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).",
      "ja": "バイトレンジロックのオープンと所有者の所有者は別々のエンティティであり、同じ不透明アレイがそれぞれの所有者を指定するために使用されていても別々に残っています。プロトコルは、オープンオーナー（Open_OWNER4構造によって表される）とロック所有者（Lock_OWNER4構造で表される）を区別します。"
    },
    {
      "indent": 3,
      "text": "Each open is associated with a specific open-owner while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done. Delegations and layouts, on the other hand, are not associated with a specific owner but are associated with the client as a whole (identified by a client ID).",
      "ja": "各オープンは特定の開い主に関連付けられていますが、各バイトレンジロックはロックオーナーとオープンオーナーに関連付けられている間、後者はロック操作が行われたオープンファイルに関連付けられているオープンオーナーです。一方、代表団とレイアウトは特定の所有者に関連付けられていませんが、クライアント全体として関連付けられています（クライアントIDによって識別されます）。"
    },
    {
      "indent": 0,
      "text": "9.1.2. Use of the Stateid and Locking",
      "section_title": true,
      "ja": "9.1.2. StateIDとロックの使用"
    },
    {
      "indent": 3,
      "text": "All READ, WRITE, and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations that change the size attribute of a file are treated as if they are writing the area between the old and new sizes (i.e., the byte-range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text. The stateid passed to one of these operations must be one that represents an open, a set of byte-range locks, or a delegation, or it may be a special stateid representing anonymous access or the special bypass stateid.",
      "ja": "読み取り、書き込み、およびsetAttrのすべての操作にはStateIDが含まれています。このセクションの目的のために、ファイルのサイズ属性を変更するSETATTRの操作は、それらが古いサイズと新しいサイズの間の領域を書き込んでいるかのように扱われます（つまり、SETATTRによってファイルに切り捨てられるバイトレンジまたは追加）SetAttrがテキストに明示的に言及されていない場合でも。これらの操作の1つに渡されたStateIDは、オープン、バイトレンジロックのセット、または委任を表すものである必要があります。または、匿名アクセスまたは特別なバイパスStareIDを表す特別なStateIDである場合があります。"
    },
    {
      "indent": 3,
      "text": "If the state-owner performs a READ or WRITE operation in a situation in which it has established a byte-range lock or share reservation on the server (any OPEN constitutes a share reservation), the stateid (previously returned by the server) must be used to indicate what locks, including both byte-range locks and share reservations, are held by the state-owner. If no state is established by the client, either a byte-range lock or a share reservation, a special stateid for anonymous state (zero as the value for \"other\" and \"seqid\") is used. (See Section 8.2.3 for a description of 'special' stateids in general.) Regardless of whether a stateid for anonymous state or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory byte-range lock held on the file, the server MUST refuse to service the READ or WRITE operation.",
      "ja": "State-Ownerがサーバー上のバイトレンジロックまたは共有予約を確立した状況で読み取りまたは書き込み操作を実行した場合（任意のオープンを構成する）、StateID（以前はサーバーから返された）は必須です。バイトレンジロックと共有予約を含むロックを示すために使用され、州所有者によって保持されています。クライアントによって、バイトレンジロックまたは共有予約のいずれかによって、クライアントによって確立されていない場合は、匿名状態の特別なStateID（「その他」、「SEQID」の値としてゼロ）が使用されます。（一般的なセクション8.2.3を参照してください。一般的な特別な 'StateIDSの説明については、「一般的な」の説明については、サーバーから返されるStateIDが使用されているかどうかにかかわらず、矛盾する共有予約または必須のバイトレンジロックがある場合に関係なくファイル上で、サーバーは読み取りまたは書き込み操作を処理することを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Byte-range locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a \"mandatory lock bit\" on the mode attribute such that if set, byte-range locks are required on the file before I/O is possible). When byte-range locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory byte-range locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file for which it knows it has the proper share reservation, it will need to send a LOCK operation on the byte-range of the file that includes the byte-range the I/O was to be performed on, with an appropriate locktype field of the LOCK operation's arguments (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).",
      "ja": "共有予約はオープン操作によって確立され、それらの性質によって確立され、オープンが読み取りまたは書き込み操作を拒否した場合、その拒否はエラーNFS4ERR_LOCKEDで拒否されます。バイトレンジロックは、必須または勧告のいずれかとしてサーバーによって実装されてもよく、またはアクセスされているファイルに基づいてサーバーによって決定されてもよく、必須またはアドバイザリーの動作の選択は（たとえば、一部のUNIXベースのサーバーをサポートする \" MODE属性の必須ロックビット「MODE属性」では、I / Oの前にファイルに設定されている場合はバイトレンジロックが必要です。バイトレンジロックがアドバイザリーの場合、それらは競合するロック要求の付与を防ぎ、読み取りまたは書き込みに影響を与えないだけです。ただし、必須のバイトレンジロックは、競合するI / O操作を防ぎます。試行されると、それらはNFS4ERR_LOCKEDで拒否されます。クライアントが適切な共有予約を知っているファイルに対してNFS4ERR_LOCKEDを取得すると、I / Oが実行されるバイト範囲を含むファイルのバイト範囲にロック操作を送信する必要があります。 、ロック操作の引数の適切なLOCKTYPEフィールド（すなわち、読み出し動作のための読み込み* _LT、書き込み操作のために* _LTを書き込みます）。"
    },
    {
      "indent": 3,
      "text": "Note that for UNIX environments that support mandatory byte-range locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same as far as the APIs and requirements on implementation. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (READ_LT) or exclusive (WRITE_LT) byte-range lock on the byte-range it wishes to READ from or WRITE to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner, and if successful, release the lock after the READ or WRITE operation is done), and if there is, the server returns NFS4ERR_LOCKED.",
      "ja": "必須のバイトレンジロックをサポートするUNIX環境では、アドバイザリと必須のロックの区別は微妙です。実際、アドバイザリと必須のバイトレンジロックは、APIと実装の要件だけではまったく同じです。必須ロック属性がファイルに設定されている場合、サーバーは、ロックー所有者が適切な共有（READ_LT）または排他式（RORTE_LT）バイトレンジロックがあるかどうかを確認します。。適切なロックがない場合、サーバーは競合するロックがあるかどうかを確認します（ロック所有者に代わって競合するロックを取得しようとし、成功した場合はロックを解除することによって実行できます。行った場合、サーバーはNFS4ERR_LOCKEDを返します。"
    },
    {
      "indent": 3,
      "text": "For Windows environments, byte-range locks are always mandatory, so the server always checks for byte-range locks during I/O requests.",
      "ja": "Windows環境の場合、バイトレンジロックは常に必須です。そのため、サーバーは常にI / O要求中にバイトレンジロックをチェックします。"
    },
    {
      "indent": 3,
      "text": "Thus, the LOCK operation does not need to distinguish between advisory and mandatory byte-range locks. It is the server's processing of the READ and WRITE operations that introduces the distinction.",
      "ja": "したがって、ロック操作は、アドバイザリと必須のバイトレンジロックを区別する必要はありません。これは区別を導入した読み書き操作のサーバーの処理です。"
    },
    {
      "indent": 3,
      "text": "Every stateid that is validly passed to READ, WRITE, or SETATTR, with the exception of special stateid values, defines an access mode for the file (i.e., OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH).",
      "ja": "Special StareID値を除いて、読み取り、書き込み、またはsetAttrに有効に渡されるすべてのStareIDは、ファイルのアクセスモード（すなわちOpen4_Share_Access_Read、Open4_Share_access_both、Open4_Share_Both）を定義します。"
    },
    {
      "indent": 3,
      "text": "* For stateids associated with opens, this is the mode defined by the original OPEN that caused the allocation of the OPEN stateid and as modified by subsequent OPENs and OPEN_DOWNGRADEs for the same open-owner/file pair.",
      "ja": "* OpenSに関連付けられているStateIDの場合、これはオープンステートIDの割り当てを引き起こし、その後の開いているOpenSとOPEN_DOWNGRADESによって変更されたオープンオーナー/ファイルペアで変更されたモードです。"
    },
    {
      "indent": 3,
      "text": "* For stateids returned by byte-range LOCK operations, the appropriate mode is the access mode for the OPEN stateid associated with the lock set represented by the stateid.",
      "ja": "* バイトレンジロック操作によって返されるStateIDの場合、適切なモードは、StareIDによって表されるロックセットに関連付けられているOpen StareIDのアクセスモードです。"
    },
    {
      "indent": 3,
      "text": "* For delegation stateids, the access mode is based on the type of delegation.",
      "ja": "* 委任ステートIDの場合、アクセスモードは委任の種類に基づいています。"
    },
    {
      "indent": 3,
      "text": "When a READ, WRITE, or SETATTR (that specifies the size attribute) operation is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the stateid with which the operation is associated.",
      "ja": "読み取り、書き込み、またはsetAttrが（サイズ属性を指定する）操作が行われると、操作は、操作が関連付けられているStateIDを考慮して、アクセスモードからチェックモードをチェックすることができます。"
    },
    {
      "indent": 3,
      "text": "In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that set size), the server MUST verify that the access mode allows writing and MUST return an NFS4ERR_OPENMODE error if it does not. In the case of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on OPENs for OPEN4_SHARE_ACCESS_WRITE, to accommodate clients whose WRITE implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another OPEN specified OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH). Note that a server that does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for OPEN4_SHARE_ACCESS_READ guarantees that no conflicting share reservation can exist.",
      "ja": "書き込み型の動作（すなわち、サイズを設定する書き込みおよびSETATTR）の場合、サーバはアクセスモードが書き込みを許可し、NFS4ERR_OPENMODEエラーを返すことを確認する必要がある。読み取りの場合、サーバはアクセスモードで対応するチェックを実行することができ、あるいはOpen4_Share_Access_Write用の読み出しON開度を許可することを選択して、書き込み実装が不可避的に読み取りを行うことができる（例えば、バッファキャッシュ制約のために）。ただし、これらの状況で読み取りが許可されていても、サーバーは読み取りと競合するロック（たとえば、別のオープン4_share_deny_both）と競合するロックを確認する必要があります。open4_share_access_readの存在が存在しないことを保証することができるので、アクセスモードチェックオンの読み取りを実行するサーバは、競合する共有予約を明示的にチェックする必要はないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The READ bypass special stateid (all bits of \"other\" and \"seqid\" set to one) indicates a desire to bypass locking checks. The server MAY allow READ operations to bypass locking checks at the server, when this special stateid is used. However, WRITE operations with this special stateid value MUST NOT bypass locking checks and are treated exactly the same as if a special stateid for anonymous state were used.",
      "ja": "読み取りバイパス特殊ステートID（ \"OTHER\"および \"SEQID\"が1に設定されているすべてのビット）は、ロックチェックをバイパスしたいという願望を示しています。この特別なStareIDが使用されるとき、サーバーはサーバーでロックチェックをバイパスするための読み取り操作を許可することがあります。ただし、この特別なStareID値を使用した書き込み操作はロックチェックをバイパスしてはならず、匿名状態の特別なStareIDが使用されている場合とまったく同じです。"
    },
    {
      "indent": 3,
      "text": "A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the scope of the lock to be granted would conflict with the READ or WRITE operation. This can occur when:",
      "ja": "特別な州の1つを使用した読み取りまたは書き込み操作が実行されており、付与されるロックの範囲が読み取りまたは書き込み操作と競合することになる間、ロックが許可されない場合があります。次の場合に発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* A mandatory byte-range lock is requested with a byte-range that conflicts with the byte-range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed.",
      "ja": "* 必須バイトレンジロックは、読み取りまたは書き込み操作のバイト範囲と競合するバイト範囲で要求されます。この段落の目的のために、共有ロックが要求されて書き込み動作が実行されているとき、または排他的ロックが要求され、読み取りまたは書き込み動作が実行されている場合に競合が発生します。"
    },
    {
      "indent": 3,
      "text": "* A share reservation is requested that denies reading and/or writing and the corresponding operation is being performed.",
      "ja": "* 読み取りおよび/または書き込みを拒否し、対応する動作が実行されている株式予約が要求される。"
    },
    {
      "indent": 3,
      "text": "* A delegation is to be granted and the delegation type would prevent the I/O operation, i.e., READ and WRITE conflict with an OPEN_DELEGATE_WRITE delegation and WRITE conflicts with an OPEN_DELEGATE_READ delegation.",
      "ja": "* 委任が許可され、委任タイプはI / O操作、すなわちopen_delegate_writeの委任と読み取りおよび書き込み競合を妨げ、Open_Delegate_read委任との競合を書き込むことを妨げます。"
    },
    {
      "indent": 3,
      "text": "When a client holds a delegation, it needs to ensure that the stateid sent conveys the association of operation with the delegation, to avoid the delegation from being avoidably recalled. When the delegation stateid, a stateid open associated with that delegation, or a stateid representing byte-range locks derived from such an open is used, the server knows that the READ, WRITE, or SETATTR does not conflict with the delegation but is sent under the aegis of the delegation. Even though it is possible for the server to determine from the client ID (via the session ID) that the client does in fact have a delegation, the server is not obliged to check this, so using a special stateid can result in avoidable recall of the delegation.",
      "ja": "クライアントが委任を保持すると、委任が回避できないことを回避するために、StateIDが操作の関連付けを委任とすることを確実にする必要があります。委任StateID、その委任に関連付けられているStateIDオープン、またはそのようなオープンから派生したバイトレンジロックを表すStateIDが使用されている場合、サーバーは読み取り、書き込み、またはSETATTRが委任と競合しないが下に送信されます。代表団のAEGIS。サーバーが実際に委任を行うクライアントID（セッションIDを介して）を決定することは可能ですが、サーバーはこれをチェックする義務がありません。代表団"
    },
    {
      "indent": 0,
      "text": "9.2. Lock Ranges",
      "section_title": true,
      "ja": "9.2. ロック範囲"
    },
    {
      "indent": 3,
      "text": "The protocol allows a lock-owner to request a lock with a byte-range and then either upgrade, downgrade, or unlock a sub-range of the initial lock, or a byte-range that overlaps -- fully or partially -- either with that initial lock or a combination of a set of existing locks for the same lock-owner. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.",
      "ja": "このプロトコルでは、ロック所有者がバイト範囲でロックを要求し、次にアップグレード、ダウングレード、または初期ロックのサブレンジ、または重複するバイト範囲、または部分的に、または部分的に - を使用するバイト範囲を使用することができます。その初期ロックまたは同じロックオーナーの既存のロックのセットの組み合わせ。これは珍しいタイプの要求になると予想されます。いずれにせよ、サーバーまたはサーバーファイルシステムはサブレンジロックセマンティクスをサポートできない可能性があります。ロック所有者の現在のロック状態のサブ範囲を表すロック要求をサーバーに受信した場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことができ、サブレンジロック操作をサポートしていないことを示します。したがって、クライアントはこのエラーを受け取る準備をしており、必要に応じて、要求元アプリケーションにエラーを報告します。"
    },
    {
      "indent": 3,
      "text": "The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests for reasons related to the recovery of byte-range locking state in the event of server failure. As discussed in Section 8.4.2, the server may employ certain optimizations during recovery that work effectively only when the client's behavior during lock recovery is similar to the client's locking behavior prior to server failure.",
      "ja": "サーバーは、サーバー障害が発生した場合のバイトレンジロック状態の回復に関連する理由でサブレンジ要求をサポートしていない可能性があるため、クライアントは、サーバーがバイトレンジロック状態の回復に関連するサブレンジ要求をサポートしていない可能性があるため、クライアントは単一の要求に隣接していることをお勧めします。8.4.2節で説明したように、サーバーは、ロック回復中のクライアントの動作がサーバーの障害の前にクライアントのロック動作と似ている場合にのみ、リカバリ中に特定の最適化を採用することができます。"
    },
    {
      "indent": 0,
      "text": "9.3. Upgrading and Downgrading Locks",
      "section_title": true,
      "ja": "9.3. ロックのアップグレードとダウングレード"
    },
    {
      "indent": 3,
      "text": "If a client has a WRITE_LT lock on a byte-range, it can request an atomic downgrade of the lock to a READ_LT lock via the LOCK operation, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.",
      "ja": "クライアントがバイト範囲でWRITE_LTロックを持つ場合、そのタイプをREAD_LTに設定することによって、ロック操作を介してREAD_LTロックにロックのアトミックダウングレードを要求できます。サーバーがアトミックダウングレードをサポートしている場合、要求は成功します。そうでない場合は、NFS4ERR_LOCK_NOTSUPPを返します。クライアントはこのエラーを受け取る準備をしており、必要に応じて、要求元アプリケーションにエラーを報告してください。"
    },
    {
      "indent": 3,
      "text": "If a client has a READ_LT lock on a byte-range, it can request an atomic upgrade of the lock to a WRITE_LT lock via the LOCK operation by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client sent the LOCK operation with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and, if appropriate, report the error to the requesting application.",
      "ja": "クライアントがバイト範囲でREAD_LTロックを持つ場合は、TypeをWRITE_LTまたはWRITEW_LTに設定して、ロック操作を介してLOCKの原子力をLORT_LTロックに要求できます。サーバーがアトミックアップグレードをサポートしていない場合は、NFS4ERR_LOCK_NOTSUPPを返します。アップグレードが既存の矛盾なく達成できる場合は、要求は成功します。それ以外の場合、サーバーはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKを返します。エラーNFS4ERR_DeadLockは、クライアントがWriteW_LTに設定された型でロック操作を送信し、サーバーがデッドロックを検出した場合に返されます。クライアントはそのようなエラーを受信する準備をしており、必要に応じて要求側アプリケーションにエラーを報告してください。"
    },
    {
      "indent": 0,
      "text": "9.4. Stateid Seqid Values and Byte-Range Locks",
      "section_title": true,
      "ja": "9.4. StateID SEQID値とバイトレンジロック"
    },
    {
      "indent": 3,
      "text": "When a LOCK or LOCKU operation is performed, the stateid returned has the same \"other\" value as the argument's stateid, and a \"seqid\" value that is incremented (relative to the argument's stateid) to reflect the occurrence of the LOCK or LOCKU operation. The server MUST increment the value of the \"seqid\" field whenever there is any change to the locking status of any byte offset as described by any of the locks covered by the stateid. A change in locking status includes a change from locked to unlocked or the reverse or a change from being locked for READ_LT to being locked for WRITE_LT or the reverse.",
      "ja": "ロックまたはロック操作が実行されると、返されるStateIDは引数のSTATEIDとして同じ「その他」の値を持ち、ロックまたはロック操作の発生を反映するための（引数のStateIDから）増分される「seqid」値です。。StareIDでカバーされているいずれかのロックによって説明されているように、バイトオフセットのロック状態に変更がある場合は、サーバーは「seqid」フィールドの値を増やす必要があります。ロックステータスの変更には、ロックされたロック解除からロック解除または逆の変更、またはREAD_LTのためのロックされているのがrawing_ltまたは逆のためにロックされています。"
    },
    {
      "indent": 3,
      "text": "When there is no such change, as, for example, when a range already locked for WRITE_LT is locked again for WRITE_LT, the server MAY increment the \"seqid\" value.",
      "ja": "そのような変更がない場合、例えばWRITE_LTに対して既にロックされている範囲がWRITE_LTに対して再度ロックされているときに、サーバは「seqid」値を増加させることができる。"
    },
    {
      "indent": 0,
      "text": "9.5. Issues with Multiple Open-Owners",
      "section_title": true,
      "ja": "9.5. 複数のオープンオーナーに関する問題"
    },
    {
      "indent": 3,
      "text": "When the same file is opened by multiple open-owners, a client will have multiple OPEN stateids for that file, each associated with a different open-owner. In that case, there can be multiple LOCK and LOCKU requests for the same lock-owner sent using the different OPEN stateids, and so a situation may arise in which there are multiple stateids, each representing byte-range locks on the same file and held by the same lock-owner but each associated with a different open-owner.",
      "ja": "同じファイルが複数のオープンオーナーによって開かれると、クライアントにはそのファイルに複数のオープンステートIDがあり、それぞれ異なるオープンオーナーに関連付けられます。その場合、異なるオープンのステートIDを使用して送信された同じロックー所有者に対する複数のロックおよびロック要求があります。同じロック所有者によって、それぞれ異なるオープンオーナーに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "In such a situation, the locking status of each byte (i.e., whether it is locked, the READ_LT or WRITE_LT type of the lock, and the lock-owner holding the lock) MUST reflect the last LOCK or LOCKU operation done for the lock-owner in question, independent of the stateid through which the request was sent.",
      "ja": "そのような状況では、各バイトのロックステータス（すなわち、ロックされているかどうか、ロックのREAD_LTまたはWRIED_LTタイプ、ロックを保持しているロック所有者がロックを保持する）は、ロックに対して行われた最後のロックまたはロック操作を反映しなければなりません。問題の所有者は、要求が送信されたStateIDとは無関係です。"
    },
    {
      "indent": 3,
      "text": "When a byte is locked by the lock-owner in question, the open-owner to which that byte-range lock is assigned SHOULD be that of the open-owner associated with the stateid through which the last LOCK of that byte was done. When there is a change in the open-owner associated with locks for the stateid through which a LOCK or LOCKU was done, the \"seqid\" field of the stateid MUST be incremented, even if the locking, in terms of lock-owners has not changed. When there is a change to the set of locked bytes associated with a different stateid for the same lock-owner, i.e., associated with a different open-owner, the \"seqid\" value for that stateid MUST NOT be incremented.",
      "ja": "バイトが問題のロック所有者によってロックされると、そのバイトレンジロックが割り当てられているオープンオーナーは、そのバイトの最後のロックが行われたStateIDに関連付けられているOpen Ownerのそれである必要があります。ロックまたはロックが行われたStateIDのロックに関連付けられているオープンオーナーに変更がある場合は、ロック所有者の観点から、StateIDの「seqid」フィールドをインクリメントする必要があります。かわった。同じロック所有者に対して異なるStateIDに関連付けられたロックされたバイトのセットに変更がある場合、すなわち、異なるオープンオーナーに関連付けられているので、そのStareIDの「seqid」値はインクリメントされてはならない。"
    },
    {
      "indent": 0,
      "text": "9.6. Blocking Locks",
      "section_title": true,
      "ja": "9.6. ブロッキングロック"
    },
    {
      "indent": 3,
      "text": "Some clients require the support of blocking locks. While NFSv4.1 provides a callback when a previously unavailable lock becomes available, this is an OPTIONAL feature and clients cannot depend on its presence. Clients need to be prepared to continually poll for the lock. This presents a fairness problem. Two of the lock types, READW_LT and WRITEW_LT, are used to indicate to the server that the client is requesting a blocking lock. When the callback is not used, the server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait for the period of time equal to lease_time for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.",
      "ja": "一部のクライアントにはブロックロックのサポートが必要です。 NFSV4.1は、以前に利用できないロックが利用可能になったときにコールバックを提供しますが、これはオプションの機能であり、クライアントはその存在に依存できません。クライアントはロックを継続的にポーリングするように準備する必要があります。これは公平性の問題を提示します。 2つのロックタイプ、readw_ltおよびwritew_ltは、クライアントがブロッキングロックを要求しているサーバーに示すために使用されます。コールバックが使用されていない場合、サーバーは保留中のブロックロックの注文リストを維持する必要があります。競合するロックが解除されると、サーバーは最初の待機クライアントがロックを再要求するためのLEASE_TIMEに等しい期間を待つことができます。リース期間が切れると、次の待機クライアント要求がロックを許可されます。クライアントは、それがタイムリーにロックを取得する可能性が高いという十分に小さい間隔でポーリングする必要があります。サーバーは、公平性を高め、正しい操作を高めるために使用される保留中のブロックロックのリストを維持する必要はありません。クラッシュ回復の順序付けされていない性質のために、ブロッキングロックの順序付けされた付与を保証するために、ロック状態を安定した記憶装置に保存することが必要になるでしょう。"
    },
    {
      "indent": 3,
      "text": "Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needless frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.",
      "ja": "サーバーはまた、競合するロックを解放するための余分な時間を許可するための要求の拒否を返すロックの種類と遅延にも注意して、返された戻りを可能にすることができます。このようにして、クライアントはロックをブロックするための不要な頻繁なポーリングの負担を回避することができます。クライアントが要求を再送信する場合、サーバーは遅延の長さに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a server receives a blocking LOCK operation, denies it, and then later receives a nonblocking request for the same lock, which is also denied, then it should remove the lock in question from its list of pending blocking locks. Clients should use such a nonblocking request to indicate to the server that this is the last time they intend to poll for the lock, as may happen when the process requesting the lock is interrupted. This is a courtesy to the server, to prevent it from unnecessarily waiting a lease period before granting other LOCK operations. However, clients are not required to perform this courtesy, and servers must not depend on them doing so. Also, clients must be prepared for the possibility that this final locking request will be accepted.",
      "ja": "サーバーがブロッキングロック操作を受信した場合は、それを拒否し、後で同じロックに対してノンブロッキング要求を受信します。これも拒否され、その後、問題のロックを保留中のブロックロックのリストから削除する必要があります。ロックを要求するプロセスが中断されたときに起こる可能性があるように、クライアントはこのような非ブロック要求をサーバーに指定してロックをポーリングする予定のサーバーに表示する必要があります。他のロック操作を許可する前に不必要にリース期間を待つのを防ぐために、これはサーバーへの礼儀です。ただし、クライアントはこの礼儀を実行する必要はありません。サーバーはそうすることに依存してはいけません。また、この最終ロック要求が受け入れられる可能性のために、クライアントを準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a server indicates, via the flag OPEN4_RESULT_MAY_NOTIFY_LOCK, that CB_NOTIFY_LOCK callbacks might be done for the current open file, the client should take notice of this, but, since this is a hint, cannot rely on a CB_NOTIFY_LOCK always being done. A client may reasonably reduce the frequency with which it polls for a denied lock, since the greater latency that might occur is likely to be eliminated given a prompt callback, but it still needs to poll. When it receives a CB_NOTIFY_LOCK, it should promptly try to obtain the lock, but it should be aware that other clients may be polling and that the server is under no obligation to reserve the lock for that particular client.",
      "ja": "サーバーがフラグOPEN4_RESULT_MAY_NOTIFY_LOCKを介して、CB_NOTIFY_LOCKコールバックが現在のオープンファイルに対して実行される可能性がある場合、クライアントはこれを通知する必要がありますが、これはヒントであるため、常に行われているCB_NOTIFY_LOCKに頼ることはできません。プロンプトコールバックが与えられる可能性があるより大きな待ち時間が排除される可能性が高いため、クライアントは拒否されたロックのためにポーリングされる頻度を合理的に減らすことができますが、まだポーリングする必要があります。CB_NOTIFY_LOCKを受信すると、迅速にロックを取得しようとしますが、他のクライアントがポーリングされている可能性があり、その特定のクライアントのロックを予約する義務を負うことはできません。"
    },
    {
      "indent": 0,
      "text": "9.7. Share Reservations",
      "section_title": true,
      "ja": "9.7. 予約を共有します"
    },
    {
      "indent": 3,
      "text": "A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from byte-range locking. When a client opens a file, it sends an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH). If the OPEN fails, the client will fail the application's open request.",
      "ja": "共有予約は、ファイルへのアクセスを制御するためのメカニズムです。バイトレンジロックから独立した独立したメカニズムです。クライアントがファイルを開くと、必要なアクセスの種類（読み取り、書き込み、またはその両方）とその他の拒否の種類（Open4_Share_Deny_NONE、OPEN4_SHARE_DENY_BOTH、OPEN4_SHARE_DENY_BOTH、OPEN4_SHARE_DENY_BOTH）を指定するサーバにオープン操作を送信します。開くと失敗した場合、クライアントはアプリケーションのオープン要求に失敗します。"
    },
    {
      "indent": 3,
      "text": "Pseudo-code definition of the semantics:",
      "ja": "セマンティクスの疑似コード定義："
    },
    {
      "indent": 11,
      "text": "if (request.access == 0) {\n  return (NFS4ERR_INVAL)\n} else {\n  if ((request.access & file_state.deny)) ||\n     (request.deny & file_state.access)) {\n    return (NFS4ERR_SHARE_DENIED)\n}\nreturn (NFS4ERR_OK);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When doing this checking of share reservations on OPEN, the current file_state used in the algorithm includes bits that reflect all current opens, including those for the open-owner making the new OPEN request.",
      "ja": "この共有予約の確認を開くと、アルゴリズムで使用されている現在のFile_Stateには、Open-Ownerが新しいオープン要求を実行するためのすべての現在のオープンを反映するビットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:",
      "ja": "アクセスフィールドと拒否フィールドのOpenおよびOpen_Downgrade操作に使用される定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.8. OPEN/CLOSE Operations",
      "section_title": true,
      "ja": "9.8. オープン/クローズ操作"
    },
    {
      "indent": 3,
      "text": "To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what access, if any, to deny. Even if the client intends to use a special stateid for anonymous state or READ bypass, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. Clients that do not have a deny mode built into their programming interfaces for opening a file should request a deny mode of OPEN4_SHARE_DENY_NONE.",
      "ja": "正しい株式セマンティクスを提供するためには、クライアントは最初のファイルハンドルを取得し、目的のアクセスと任意のアクセスを拒否するために、開いている操作を使用する必要があります。クライアントが匿名状態または読み取りバイパスのために特別なstateIDを使用している場合でも、オープン操作で通常のファイルのファイルハンドルを取得する必要があるため、適切なシェアセマンティクスを適用することができます。ファイルを開くためのプログラミングインタフェースに組み込まれている拒否モードを持たないクライアントは、Open4_Share_deny_noneの拒否モードを要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation with the CREATE flag also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.",
      "ja": "CREATE FLAGを使用したオープン操作は、以前のバージョンのNFSプロトコルで使用されているように、通常のファイルの作成操作も節約します。これにより、共有を作成することができます。"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation removes all share reservations held by the open-owner on that file. If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE operation. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.",
      "ja": "CLOSE OPERATIONは、そのファイルのOpen-Ownerによって保持されているすべての共有予約を削除します。バイトレンジロックが保持されている場合、クライアントはクローズ操作を送信する前にすべてのロックを解放する必要があります。サーバーは閉じるすべての未解決のロックを解放することができますが、一部のサーバーはまだバイトレンジロックが保持されているファイルのクローズをサポートしていない可能性があります。CLOSEの後にロックが存在する場合は、サーバーが失敗を返し、NFS4ERR_LOCKS_HELDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume that the client has the least access. For example, if one client opened a file with OPEN4_SHARE_DENY_BOTH and another client accesses the file via a filehandle obtained through LOOKUP, the second client could only read the file using the special read bypass stateid. The second client could not WRITE the file at all because it would not have a valid stateid from OPEN and the special anonymous stateid would not be allowed access.",
      "ja": "ルックアップ操作はサーバー上のロック状態を確立せずにファイルハンドルを返します。有効なStateIDがないと、サーバーはクライアントに最小のアクセスがあります。たとえば、1つのクライアントがopen4_share_deny_bothを持つファイルを開くと、検索で取得したファイルハンドルを介してファイルにアクセスした場合、2番目のクライアントは特別なRead Bypass StareIDを使用してファイルを読み取ることができます。2番目のクライアントは、オープンから有効なStateIDを持たず、特別な匿名StareIDがアクセスできないため、ファイルをすべて作成できませんでした。"
    },
    {
      "indent": 0,
      "text": "9.9. Open Upgrade and Downgrade",
      "section_title": true,
      "ja": "9.9. アップグレードとダウングレードを開く"
    },
    {
      "indent": 3,
      "text": "When an OPEN is done for a file and the open-owner for which the OPEN is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. The OPEN is represented by a single stateid whose \"other\" value matches that of the original open, and whose \"seqid\" value is incremented to reflect the occurrence of the upgrade. The increment is required in cases in which the \"upgrade\" results in no change to the open mode (e.g., an OPEN is done for read when the existing open file is opened for OPEN4_SHARE_ACCESS_BOTH). Only a single CLOSE will be done to reset the effects of both OPENs. The client may use the stateid returned by the OPEN effecting the upgrade or with a stateid sharing the same \"other\" field and a seqid of zero, although care needs to be taken as far as upgrades that happen while the CLOSE is pending. Note that the client, when sending the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.",
      "ja": "オープンがオープンを行い、オープンが行われているオープンオーナーがすでにファイルを開いている場合、その結果はサーバー上で保持されているオープンファイルのステータスを新しいビットと拒否ビットを含めることです。既存のオープンのためのものと同様に開く。その結果、プロトコルが関係している限り、開いているファイルが1つあるため、完了したすべてのオープン要求のためのアクセスの連合と拒否ビットが含まれます。オープンは、「その他」の値が元のオープンのそれと一致する単一のStareIDで表され、アップグレードの発生を反映するように「seqid」値が増加します。 「アップグレード」がオープンモードに変更されない場合（例えば、既存のオープンファイルがOpen4_Share_access_both用に開かれたときに開かれた場合は開放された場合）。両方の開口の影響をリセットするために、単一のクローズだけが行われます。クライアントは、アップグレードにアップグレードするOpenに返されたStateIDを使用することができ、または同じ「その他の」フィールドとSEQIDをゼロのSEQIDを共有している状態で使用することができます。オープンを送信するときに、クライアントは、実際に開かれていることがわからないことに注意してください。同じファイルハンドルによって指定されたオブジェクトが開かれているオブジェクトが開かれると、上記のみが適用されます。"
    },
    {
      "indent": 3,
      "text": "When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT \"OR\" together the access and deny bits and coalesce the two open files. Instead, the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.",
      "ja": "サーバーが同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートし、同じファイルオブジェクトの2つの異なるオープンで異なるファイルハンドルを返すことを選択した場合、サーバーはアクセスと拒否ビットをまとめて、2つのオープンファイルを合体してはいけません。代わりに、サーバーは別々の州の状態で別々に開いている必要があり、それらを解放するために別々に閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "When multiple open files on the client are merged into a single OPEN file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly. The stateid returned has the same \"other\" field as that passed to the server. The \"seqid\" value in the returned stateid MUST be incremented, even in situations in which there is no change to the access and deny bits for the file.",
      "ja": "クライアント上の複数の開いているファイルがサーバー上の単一の開いているファイルオブジェクトにマージされている場合、（クライアント上の）開いているファイルの1つの閉じるには、アクセスの変更と、サーバー上の開いているファイルのステータスが拒否されます。これは、残りの開口用のアクセスと拒否ビットの連合が、以前よりも小さい（すなわち、適切なサブセット）からであるからである。Open_Downgrade操作は、必要な変更を加えるために使用され、クライアントはサーバーを更新して他のクライアントによる共有予約要求が正しく処理されるようにする必要があります。返されるStateIDは、サーバーに渡されたものと同じ「その他」フィールドを持ちます。返されたStateIDの「seqid」値は、アクセスに変更がない場合でも、ファイルのビットのビットが拒否されていてもインクリメントされなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.10. Parallel OPENs",
      "section_title": true,
      "ja": "9.10. 並列オープン"
    },
    {
      "indent": 3,
      "text": "Unlike the case of NFSv4.0, in which OPEN operations for the same open-owner are inherently serialized because of the owner-based seqid, multiple OPENs for the same open-owner may be done in parallel. When clients do this, they may encounter situations in which, because of the existence of hard links, two OPEN operations may turn out to open the same file, with a later OPEN performed being an upgrade of the first, with this fact only visible to the client once the operations complete.",
      "ja": "オーナーベースのSEQIDのために同じオープンオーナーのオープン操作は本質的にシリアル化されているNFSv4.0の場合とは異なり、同じオープンオーナー用の複数のオープンを並行して行うことができます。クライアントがこれを行うとき、それらはハードリンクの存在のために、2つのオープン操作が同じファイルを開くことができ、後で開放されたオープンで最初のオープンが実行され、この事実は目に見えるだけで、操作が完了したら、クライアント。"
    },
    {
      "indent": 3,
      "text": "In this situation, clients may determine the order in which the OPENs were performed by examining the stateids returned by the OPENs. Stateids that share a common value of the \"other\" field can be recognized as having opened the same file, with the order of the operations determinable from the order of the \"seqid\" fields, mod any possible wraparound of the 32-bit field.",
      "ja": "この状況では、クライアントは開くことによって開かれた状態を調べることによって開く順序を決定することができます。「その他」フィールドの共通値を共有するStateIDは、同じファイルを開くと認識され、操作の順序は「seqid」フィールドの順序から決定可能で、32ビットフィールドの任意のラップアラウンドを実行します。"
    },
    {
      "indent": 3,
      "text": "When the possibility exists that the client will send multiple OPENs for the same open-owner in parallel, it may be the case that an open upgrade may happen without the client knowing beforehand that this could happen. Because of this possibility, CLOSEs and OPEN_DOWNGRADEs should generally be sent with a non-zero seqid in the stateid, to avoid the possibility that the status change associated with an open upgrade is not inadvertently lost.",
      "ja": "クライアントが同じオープンオーナーに対して並行して複数のオープンを送信する可能性が存在する場合、これが発生する可能性があるクライアントが認識されていなくてもオープンアップグレードが発生する可能性があります。この可能性のために、オープンアップグレードに関連するステータス変更が誤って失われない可能性を避けるために、この可能性とOpen_Downgradesは一般的にゼロ以外のseqidを使用して送信されるべきです。"
    },
    {
      "indent": 0,
      "text": "9.11. Reclaim of Open and Byte-Range Locks",
      "section_title": true,
      "ja": "9.11. オープンレンジロックとバイトレンジロックの再利用"
    },
    {
      "indent": 3,
      "text": "Special forms of the LOCK and OPEN operations are provided when it is necessary to re-establish byte-range locks or opens after a server failure.",
      "ja": "バイトレンジロックを再確立する必要がある場合、またはサーバー障害後に開く必要がある場合は、特別な形式があります。"
    },
    {
      "indent": 3,
      "text": "* To reclaim existing opens, an OPEN operation is performed using a CLAIM_PREVIOUS. Because the client, in this type of situation, will have already opened the file and have the filehandle of the target file, this operation requires that the current filehandle be the target file, rather than a directory, and no file name is specified.",
      "ja": "* 既存のオープンを再利用するために、オープン操作はクレームを使用して実行されます。このタイプの状況では、クライアントはすでにファイルを開いてターゲットファイルのファイルハンドルを開いているため、この操作では、現在のファイルハンドルがディレクトリではなくターゲットファイルになる必要があり、ファイル名は指定されていません。"
    },
    {
      "indent": 3,
      "text": "* To reclaim byte-range locks, a LOCK operation with the reclaim parameter set to true is used.",
      "ja": "* バイトレンジロックを再生するために、Reclaimパラメータをtrueに設定したロック操作が使用されます。"
    },
    {
      "indent": 3,
      "text": "Reclaims of opens associated with delegations are discussed in Section 10.2.1.",
      "ja": "代表団に関連する開いたオープンの再利用については、10.2.1項で議論されています。"
    },
    {
      "indent": 0,
      "text": "10. Client-Side Caching",
      "section_title": true,
      "ja": "10. クライアントサイドキャッシング"
    },
    {
      "indent": 3,
      "text": "Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem, and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications, and it is often unclear what is valid or invalid client behavior.",
      "ja": "ファイル属性のクライアントサイドキャッシュ、およびファイル名のファイル名は、NFSプロトコルで良いパフォーマンスを提供するために不可欠です。分散キャッシュコヒーレンスを提供することは困難な問題であり、以前のバージョンのNFSプロトコルはそれを試みなかった。代わりに、いくつかのNFSクライアント実装技術が、コヒーレンスが不足しているという問題をユーザーに短縮するために使用されています。これらの技術は、以前のプロトコル仕様によって明確に定義されていません。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFSv4.1 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client-side caching.",
      "ja": "NFSV4.1プロトコルは、以前のプロトコルバージョンで使用されているものと同様の多くのテクニックを使用します。NFSV4.1プロトコルは分散キャッシュコヒーレンスを提供しません。ただし、クライアントサイドキャッシングからの破壊的な干渉をかけずに使用できるようにするための、より限られたキャッシュ保証のセットを定義します。"
    },
    {
      "indent": 3,
      "text": "In addition, the NFSv4.1 protocol introduces a delegation mechanism, which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.",
      "ja": "さらに、NFSV4.1プロトコルは委任メカニズムを導入し、これにより、サーバーによって通常クライアントがローカルに作成されることができます。このメカニズムは、共有がまれである場合、または共有が読み取り専用の場合の一般的なケースを効率的にサポートしています。"
    },
    {
      "indent": 0,
      "text": "10.1. Performance Challenges for Client-Side Caching",
      "section_title": true,
      "ja": "10.1. クライアントサイドキャッシングのパフォーマンスの課題"
    },
    {
      "indent": 3,
      "text": "Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.",
      "ja": "以前のバージョンのNFSプロトコルで使用されているキャッシングテクニックは、優れた性能を提供することに成功しています。しかしながら、それらの技術が非常に多数のクライアントと共に使用されるときに、いくつかのスケーラビリティの課題が発生する可能性がある。これは、クライアントが地理的に分散されている場合に特に当てはまります。"
    },
    {
      "indent": 3,
      "text": "The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.",
      "ja": "以前のバージョンのNFSプロトコルは、ファイルが開かれた時点でファイルデータキャッシュ検証要求を繰り返します。この現象は深刻なパフォーマンスの欠点を持つことができます。一般的なケースは、ファイルが単一のクライアントによってのみアクセスされるものです。したがって、共有はまれです。"
    },
    {
      "indent": 3,
      "text": "In this case, repeated references to the server to find that no conflicts exist are expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.",
      "ja": "この場合、競合が存在しないことを検索するためのサーバーへの参照を繰り返しています。パフォーマンスに関してより良いオプションは、サーバーを参照せずにファイルを繰り返し開くクライアントを実行できるようにすることです。これは、別のクライアントからの競合する操作が実際に発生するまで行われます。"
    },
    {
      "indent": 3,
      "text": "A similar situation arises in connection with byte-range locking. Sending LOCK and LOCKU operations as well as the READ and WRITE operations necessary to make data caching consistent with the locking semantics (see Section 10.3.2) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of byte-range locking by applications.",
      "ja": "バイトレンジロックに関連しても同様の状況が発生します。ロックとロックの操作とロック操作とロックセマンティクスと一貫したデータキャッシングをするために必要な読み書き操作（セクション10.3.2を参照）は、パフォーマンスを厳しく制限できます。頻度のない紛争に対して保護を提供するためにロックが使用されるとき、大きなペナルティが発生します。このペナルティは、アプリケーションによるバイトレンジロックの使用を妨げる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides more aggressive caching strategies with the following design goals:",
      "ja": "NFSV4.1プロトコルは、次の設計目標を持つより積極的なキャッシュ戦略を提供します。"
    },
    {
      "indent": 3,
      "text": "* Compatibility with a large range of server semantics.",
      "ja": "* 広範囲のサーバーセマンティクスとの互換性。"
    },
    {
      "indent": 3,
      "text": "* Providing the same caching benefits as previous versions of the NFS protocol when unable to support the more aggressive model.",
      "ja": "* より積極的なモデルをサポートできない場合、以前のバージョンのNFSプロトコルと同じキャッシングメリットを提供します。"
    },
    {
      "indent": 3,
      "text": "* Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.",
      "ja": "* 積極的なキャッシングの要件は、すべての要件が満たされるわけではない場合でも、利益の大部分が得られるように構成されています。"
    },
    {
      "indent": 3,
      "text": "The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered (see Section 10.4).",
      "ja": "サーバーの適切な要件については、特定の形式のキャッシングがカバーされているセクションで説明します（10.4項を参照）。"
    },
    {
      "indent": 0,
      "text": "10.2. Delegation and Callbacks",
      "section_title": true,
      "ja": "10.2. 委任とコールバック"
    },
    {
      "indent": 3,
      "text": "Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a \"callback\" RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.",
      "ja": "クライアントへのファイルに対するサーバー責任のリコール可能な委任は、クライアント間の競合がない場合にサーバーへの繰り返し要求を回避することによってパフォーマンスを向上させます。サーバーからクライアントからクライアントへの「コールバック」RPCを使用すると、他のクライアントが委任ファイルの共有に関与する際に委任された責任を思い出します。"
    },
    {
      "indent": 3,
      "text": "A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations, but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a client ID and may be used on behalf of all the open-owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.",
      "ja": "委任のオブジェクトと委任の種類を指定して、委任がサーバーからクライアントに渡されます。委任の種類が異なりますが、各タイプには、委任に依存する操作を実行するときに委任を表すために使用されるStateIDが含まれています。このStateIDは、ロックおよび共有予約に関連するものと似ていますが、委任のStateIDはクライアントIDに関連付けられており、特定のクライアントのすべてのオープンオーナーの代わりに使用できます。委任は全体としてクライアントに行われ、その内部での制御のスレッドにはそうではありません。"
    },
    {
      "indent": 3,
      "text": "The backchannel is established by CREATE_SESSION and BIND_CONN_TO_SESSION, and the client is required to maintain it. Because the backchannel may be down, even temporarily, correct protocol operation does not depend on them. Preliminary testing of backchannel functionality by means of a CB_COMPOUND procedure with a single operation, CB_SEQUENCE, can be used to check the continuity of the backchannel. A server avoids delegating responsibilities until it has determined that the backchannel exists. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients MUST NOT assume that a delegation will be granted and they MUST always be prepared for OPENs, WANT_DELEGATIONs, and GET_DIR_DELEGATIONs to be processed without any delegations being granted.",
      "ja": "BackChannelはcreate_sessionとbind_conn_to_sessionによって確立され、クライアントはそれを維持するために必要です。バックチャネルがダウンしている可能性があるため、一時的に正しいプロトコル操作はそれらに依存しません。バックチャネル機能の予備テスト単一の操作を持つCB_COMPOUND手順によるCB_COMPOUND手順を使用して、バックチャネルの連続性をチェックするために使用できます。サーバーは、バックチャネルが存在すると判断されるまで責任を委任します。代表団の付与は常に矛盾するアクセスがないと条件付きであるため、委任が付与されていて、常にopens、want_delegations、およびget_dir_delegationsがrependedに登録されていると常に準備されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback. For individual operations, we will describe, under IMPLEMENTATION, when such operations are required to effect a recall. A number of points should be noted, however.",
      "ja": "ロックとは異なり、委任されたファイルへの2番目のクライアントによる操作によって、サーバーがコールバックを介して委任を思い出します。個々の操作では、そのような操作がリコールに影響を与える必要があるときに、実装の下で説明します。しかしながら、いくつかの点が注目すべきである。"
    },
    {
      "indent": 3,
      "text": "* The server is free to recall a delegation whenever it feels it is desirable and may do so even if no operations requiring recall are being done.",
      "ja": "* サーバーは、それが望ましいと感じるときはいつでも委任を自由に思い出すことができ、リコールを必要とする操作が行われていなくてもそうすることができます。"
    },
    {
      "indent": 3,
      "text": "* Operations done outside the NFSv4.1 protocol, due to, for example, access by other protocols, or by local access, also need to result in delegation recall when they make analogous changes to file system data. What is crucial is if the change would invalidate the guarantees provided by the delegation. When this is possible, the delegation needs to be recalled and MUST be returned or revoked before allowing the operation to proceed.",
      "ja": "* 例えば、他のプロトコルによるアクセス、またはローカルアクセスによるNFSV4.1プロトコルの外で行われた操作は、ファイルシステムデータに類似した変更を加えると、委任を思い出す必要があります。重要なのは、変更が委任によって提供される保証を無効にするかどうかです。これが可能な場合は、委任を呼び出す必要があり、操作を続行できるようにする前に返却または取り消される必要があります。"
    },
    {
      "indent": 3,
      "text": "* The semantics of the file system are crucial in defining when delegation recall is required. If a particular change within a specific implementation causes change to a file attribute, then delegation recall is required, whether that operation has been specifically listed as requiring delegation recall. Again, what is critical is whether the guarantees provided by the delegation are being invalidated.",
      "ja": "* ファイルシステムのセマンティクスは、委任リコールが必要な場合に定義することにおいて不可欠です。特定の実装内の特定の変更がファイル属性に変更されると、委任リコールが必要かどうか、その操作が要求されていることを要求する必要があるかどうかを要求します。繰り返しになりますが、重要なのは、委任によって提供される保証が無効になっているかどうかです。"
    },
    {
      "indent": 3,
      "text": "Despite those caveats, the implementation sections for a number of operations describe situations in which delegation recall would be required under some common circumstances:",
      "ja": "これらの警告にもかかわらず、いくつかの操作のための実施セクションは、いくつかの一般的な状況下で代表団の想起が必要とされる状況を説明しています。"
    },
    {
      "indent": 3,
      "text": "* For GETATTR, see Section 18.7.4.",
      "ja": "* GetAttrの場合は、18.7.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For OPEN, see Section 18.16.4.",
      "ja": "* Openの場合は、18.16.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For READ, see Section 18.22.4.",
      "ja": "* 読み取りのために、18.22.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For REMOVE, see Section 18.25.4.",
      "ja": "* 削除の場合は、セクション18.25.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For RENAME, see Section 18.26.4.",
      "ja": "* 名前の変更については、18.26.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For SETATTR, see Section 18.30.4.",
      "ja": "* SetAttrについては、18.30.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For WRITE, see Section 18.32.4.",
      "ja": "* 書き込みの場合は、18.32.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "On recall, the client holding the delegation needs to flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not be acted on until the recall is complete. The recall is considered complete when the client returns the delegation or the server times its wait for the delegation to be returned and revokes the delegation as a result of the timeout. In the interim, the server will either delay responding to conflicting requests or respond to them with NFS4ERR_DELAY. Following the resolution of the recall, the server has the information necessary to grant or deny the second client's request.",
      "ja": "リコールでは、委任を保持しているクライアントは、修正された状態（変更データなど）をサーバーにフラッシュして委任を返す必要があります。リコールが完了するまで矛盾する要求は行動されません。recallは、クライアントが委任を返すのを待つサーバーの時間を返し、タイムアウトの結果として委任を返します。中間体では、サーバーは競合する要求への応答を遅らせるか、NFS4ERR_DELAYでそれらに対応します。リコールの解像度に続いて、サーバーは2番目のクライアントの要求を付与または拒否するために必要な情報を持っています。"
    },
    {
      "indent": 3,
      "text": "At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.",
      "ja": "クライアントが委任リコールを受信すると、サーバーにフラッシュする必要がある実質的な状態がある可能性があります。したがって、サーバーには、サーバーへの多数のRPCが含まれる可能性があるため、サーバーは委任が返されるのに十分な時間を許可する必要があります。リコールの結果としてクライアントがサーバにシリアルがシリアルにフラッシュされていると判断できる場合、サーバは呼び出しに許可されている通常の時間を延長することができる。ただし、リコール完了に許可されている時間を無制限にしないでください。"
    },
    {
      "indent": 3,
      "text": "An example of this is when responsibility to mediate opens on a given file is delegated to a client (see Section 10.4). The server will not know what opens are in effect on the client. Without this knowledge, the server will be unable to determine if the access and deny states for the file allow any particular open until the delegation for the file has been returned.",
      "ja": "この例は、特定のファイルで仲介する責任がある場合の責任は、特定のファイルに委任されます（セクション10.4を参照）。サーバーは、OpenSがクライアントに有効なのかわかりません。この知識がなければ、サーバーはファイルの委任が返されるまで、ファイルのアクセスと拒否の状態が特定のオープンを許可するかどうかを判断できません。"
    },
    {
      "indent": 3,
      "text": "A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation, which in turn will render useless any modified state still on the client.",
      "ja": "クライアント障害またはネットワークパーティションは、リコールコールバックに応答できない可能性があります。この場合、サーバーは委任を取り消します。これは、順番にクライアント上にまだ修正された状態をレンダリングします。"
    },
    {
      "indent": 0,
      "text": "10.2.1. Delegation Recovery",
      "section_title": true,
      "ja": "10.2.1. 委任の回復"
    },
    {
      "indent": 3,
      "text": "There are three situations that delegation recovery needs to deal with:",
      "ja": "代表団の回復に対処する必要があるという3つの状況があります。"
    },
    {
      "indent": 3,
      "text": "* client restart",
      "ja": "* クライアントの再起動"
    },
    {
      "indent": 3,
      "text": "* server restart",
      "ja": "* サーバーの再起動"
    },
    {
      "indent": 3,
      "text": "* network partition (full or backchannel-only)",
      "ja": "* ネットワークパーティション（フルまたはバックチャネルのみ）"
    },
    {
      "indent": 3,
      "text": "In the event the client restarts, the failure to renew the lease will result in the revocation of byte-range locks and share reservations. Delegations, however, may be treated a bit differently.",
      "ja": "クライアントが再起動した場合、リースの更新の失敗はバイトレンジロックの失効と予約を共有します。しかしながら、代理人はビットを異なる方法で扱うことができる。"
    },
    {
      "indent": 3,
      "text": "There will be situations in which delegations will need to be re-established after a client restarts. The reason for this is that the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to re-establish the appropriate file state on the server.",
      "ja": "クライアントが再起動した後に代表団を再確立する必要がある状況があるでしょう。その理由は、クライアントがローカルに保存されたファイルデータを持つことができ、このデータは以前に開催された代理人に関連付けられている可能性があります。クライアントは、サーバー上の適切なファイル状態を再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "To allow for this type of client recovery, the server MAY extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to restart and consult stable storage so that the delegations can be reclaimed. For OPEN delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV or CLAIM_DELEG_PREV_FH (see Sections 10.5 and 18.16 for discussion of OPEN delegation and the details of OPEN, respectively).",
      "ja": "この種のクライアントリカバリを許可するために、サーバーは典型的なリース期間を超えて委任リカバリの期間を拡張することができる。これは、これらの代表団と競合する他のクライアントからの要求が待つ必要があることを意味します。通常のリコールプロセスでは、クライアントが変更された状態をサーバーにフラッシュするためにかなりの時間が必要になる場合があるため、相反する委任のために発生する遅延のために他のクライアントを作成する必要があります。この長い間隔は、顧客が再起動し、安定したストレージを再起動し、代理を再生できるようにするためのウィンドウが増えます。オープン委任のために、そのような代表団はクレームタイプのクレームタイプのクレームタイプを使用して再生され、それぞれオープン委任の議論とオープンの詳細については、10.5と18.16節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A server MAY support claim types of CLAIM_DELEGATE_PREV and CLAIM_DELEG_PREV_FH, and if it does, it MUST NOT remove delegations upon a CREATE_SESSION that confirm a client ID created by EXCHANGE_ID. Instead, the server MUST, for a period of time no less than that of the value of the lease_time attribute, maintain the client's delegations to allow time for the client to send CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH requests. The server that supports CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH MUST support the DELEGPURGE operation.",
      "ja": "サーバーはクレームタイプのクレームタイプをサポートしていて、クレームタイプのクレームタイプをサポートしている可能性があります。代わりに、サーバーは、lease_time属性の値よりも少なく、一定期間、クライアントの委任を維持して、クライアントがクレーム_delegate_prevおよび/またはclason_deleg_prev_fh要求を送信できるようにします。クレームをサポートするサーバーは、DELEGPURGE操作をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to byte-range locks and share reservations. However, there is a slight semantic difference. In the normal case, if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFSv4.1 protocol:",
      "ja": "サーバーが再起動すると、委任が同様にバイトレンジロックと共有予約と同様の方法で委任が回復されます（特許請求の範囲でオープン操作を使用）。しかし、わずかな意味的な違いがあります。通常の場合、委任が許可されていないと、サーバが決定されないと判断した場合は、委任を許可することなく要求されたアクション（Open）を実行します。再利用の場合、サーバーは委任を付与しますが、クライアントが付与されたがサーバーによって呼び出されたとして委任を扱うように特別な指定が適用されます。このため、クライアントにはすべての変更された状態をサーバーに書き込む義務があり、その後委任を返します。代表団の取扱いプロセスは、NFSV4.1プロトコルの3つの原則を調整します。"
    },
    {
      "indent": 3,
      "text": "* Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.",
      "ja": "* 再利用すると、以前のサーバーインスタンスによってそれに割り当てられているクライアントレポートリソースにそれらのリソースが付与されなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.",
      "ja": "* サーバーは、委任が許可されるかどうかを判断し、かつて付与されるかどうかを判断する権限があります。"
    },
    {
      "indent": 3,
      "text": "* The use of callbacks should not be depended upon until the client has proven its ability to receive them.",
      "ja": "* コールバックの使用は、クライアントがそれらを受信する能力を証明するまでに依存しないでください。"
    },
    {
      "indent": 3,
      "text": "When a client needs to reclaim a delegation and there is no associated open, the client may use the CLAIM_PREVIOUS variant of the WANT_DELEGATION operation. However, since the server is not required to support this operation, an alternative is to reclaim via a dummy OPEN together with the delegation using an OPEN of type CLAIM_PREVIOUS. The dummy open file can be released using a CLOSE to re-establish the original state to be reclaimed, a delegation without an associated open.",
      "ja": "クライアントが委任を回復する必要があり、関連付けられている開いていない場合、クライアントはwant_delegation操作のクレームを使用することができます。しかしながら、サーバはこの操作をサポートするために必要とされないので、代替案は、タイプクレームを開くことを使用して委任と一緒に開いたダミーを介して再利用することである。ダミーオープンファイルは、既に再生される元の状態を再確立するために近い状態で解放することができ、関連するオープンなしの委任。"
    },
    {
      "indent": 3,
      "text": "When a client has more than a single open associated with a delegation, state for those additional opens can be established using OPEN operations of type CLAIM_DELEGATE_CUR. When these are used to establish opens associated with reclaimed delegations, the server MUST allow them when made within the grace period.",
      "ja": "クライアントが委任に関連した単一のオープンを持っている場合、Typeクレームのオープン操作を使用して追加開始された状態の状態を確立できます。これらが再生された代理人に関連付けられている開いている開設に使用されるとき、サーバーは猶予期間内で行われたときにそれらを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the backchannel (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.",
      "ja": "ネットワークパーティションが発生すると、リース更新期間が期限切れになると、代表団がサーバーによって解放されることがあります。これはロックと共有予約の動作と似ています。しかしながら、代表団の場合、サーバは矛盾する要求がオフにされる期間を拡張することができる。最終的には、別のクライアントからの矛盾する要求が発生すると、委任の失効が発生します。バックチャネルの損失（例えば、後のネットワーク構成変更による）は同じ効果をもたらすであろう。リコールリクエストが失敗し、委任が失効します。"
    },
    {
      "indent": 3,
      "text": "A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives one of the errors NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED. It also may find out about delegation revocation after a client restart when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked OPEN_DELEGATE_WRITE delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See Section 10.5.1 for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in Section 8.4.3). This is done to deal with the case in which a server restarts after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.",
      "ja": "クライアントは通常、委任に関連付けられているStateIDを使用したときに委任の失効について説明し、エラーNFS4ERR_EXPIED、NFS4ERR_ADMIN_REVOKED、またはNFS4ERR_DELEG_REVOKEDのいずれかを受け取ります。また、委任を再開しようとし、その同じエラーを受信したときにクライアントの再起動後に委任の失効についても調べることができます。取り消しされたOpen_Delegate_Writeの委任の場合、その委任が取り消され、別々に他のクライアントによって別々にデータが変更されている可能性があるため、問題があります。そのような問題についての議論については、10.5.1項を参照してください。また、委任が取り消されると、取り消された委任に関する情報はサーバーによって安定したストレージに書き込まれます（8.4.3項で説明されているように）。これは、委任を回復した後でサーバーが再起動しますが、失効した委任を保持しているクライアントが失効について通知される場合に対処します。"
    },
    {
      "indent": 0,
      "text": "10.3. Data Caching",
      "section_title": true,
      "ja": "10.3. データキャッシング"
    },
    {
      "indent": 3,
      "text": "When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.",
      "ja": "アプリケーションが一連のファイルへのアクセスを共有するとき、それらは別のアプリケーションによるアクセスに競合する可能性を考慮に入れるように実装される必要があります。これは、問題のアプリケーションがさまざまなクライアントで実行されているか、同じクライアント上にあるかどうかにかかわらず当てはまります。"
    },
    {
      "indent": 3,
      "text": "Share reservations and byte-range locks are the facilities the NFSv4.1 protocol provides to allow applications to coordinate access by using mutual exclusion facilities. The NFSv4.1 protocol's data caching must be implemented such that it does not invalidate the assumptions on which those using these facilities depend.",
      "ja": "共有予約とバイトレンジのロックは、NFSV4.1プロトコルが相互除外機能を使用してアクセスを調整できるようにする機能です。NFSV4.1プロトコルのデータキャッシュは、これらの機能を使用しているものを使用している仮定を無効にしないように実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.1. Data Caching and OPENs",
      "section_title": true,
      "ja": "10.3.1. データキャッシュとオープン"
    },
    {
      "indent": 3,
      "text": "In order to avoid invalidating the sharing assumptions on which applications rely, NFSv4.1 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.",
      "ja": "アプリケーションが依存している共有の仮定を無効にするために、NFSV4.1クライアントはキャッシュされたデータをアプリケーションに提供したり、読み書きで同じデータを取得または変更するのに有効でない場合はアプリケーションに変更したり、アプリケーションに代わって変更する必要はありません。操作。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in the absence of an OPEN delegation (see Section 10.4), two additional rules apply. Note that these rules are obeyed in practice by many NFSv3 clients.",
      "ja": "さらに、オープンな委任がない場合（10.4節を参照）、2つの追加規則が適用されます。これらの規則は実際には多くのNFSV3クライアントによって従うことに注意してください。"
    },
    {
      "indent": 3,
      "text": "* First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client's cache. This validation must be done at least when the client's OPEN operation includes a deny of OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying a deny mode of OPEN4_SHARE_DENY_NONE) to parallel the NFSv3 protocol's practice for the benefit of users assuming this degree of cache revalidation.",
      "ja": "* まず、クライアントに存在するキャッシュされたデータを開いた後に再検証する必要があります。再検証は、クライアントがサーバーから変更属性を取得し、それをキャッシュされた変更属性と比較し、異なる場合はキャッシュされたデータ（およびキャッシュされた属性）を無効として宣言します。これは、開かれたファイルのデータがまだクライアントのキャッシュに正しく反映されていることを確認するためです。この検証は、少なくともクライアントのオープン操作にOpen4_Share_deny_WriteまたはOpen4_Share_deny_bothが含まれている場合に実行する必要があります。したがって、他のクライアントがOpen4_Share_Access_Write / Open4_Share_access_bothアクセスを使用してファイルを開く機会がある可能性がある期間を終了します。クライアントは、この程度のキャッシュの再検証を想定しているユーザーの利益のために、NFSV3プロトコルの慣例を並行して、Revenationsをより頻繁に実行することを選択することができます（すなわち、Open4_Share_deny_NONEの拒否モードを指定するOpenS）。"
    },
    {
      "indent": 6,
      "text": "Since the change attribute is updated for data and metadata modifications, some client implementors may be tempted to use the time_modify attribute and not the change attribute to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementor is cautioned in this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client's data cache validation logic of time_modify and not change runs the risk of the client incorrectly marking stale data as valid. Thus, any cache validation approach by the client MUST include the use of the change attribute.",
      "ja": "変更属性はデータおよびメタデータの変更に対して更新されるので、一部のクライアント実装者は、CHACHEDデータを検証するための変更属性ではなくTIME_MODIFY属性を使用することが誘惑されているため、メタデータの変更は誤ってクリーンなデータを無効にしません。このアプローチでは、実装者に警告があります。変更属性はファイルへの更新ごとに変更が保証されていますが、time_modifyはtime_delta属性の粒度でのみ変更が保証されています。クライアントのデータキャッシュ検証ロジックのTIME_MODIFYのデータキャッシュ検証ロジックを使用すると、クライアントが古いデータを有効に誤ってマークするリスクを実行します。したがって、クライアントによるキャッシュ検証アプローチは、変更属性の使用を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* Second, modified data must be flushed to the server before closing a file OPENed for OPEN4_SHARE_ACCESS_WRITE. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after the client OPENs a file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file, hence, this requirement.",
      "ja": "* 次に、open4_share_access_write用に開いたファイルを閉じる前に、修正されたデータをサーバーにフラッシュする必要があります。これは最初の規則に相補的です。データが閉じるとフラッシュされていない場合、クライアントがファイルを開くと、その目的を達成することはできません。近くのデータをフラッシュするための他の態様は、クライアントによってクライアントによって要求される前に、データが安定したストレージにコミットされなければならないことです。サーバーの再起動とクローズドファイルの場合、ファイルに書き込まれるデータを再送信することはできません。したがって、この要件。"
    },
    {
      "indent": 0,
      "text": "10.3.2. Data Caching and File Locking",
      "section_title": true,
      "ja": "10.3.2. データキャッシュとファイルロック"
    },
    {
      "indent": 3,
      "text": "For those applications that choose to use byte-range locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client-side data caching. These rules are effective only if the byte-range locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to byte-range locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte ranges and protecting access to the two byte-ranges by byte-range locks on bytes zero and one. A WRITE_LT lock on byte zero of the file would represent the right to perform READ and WRITE operations on the first byte-range. A WRITE_LT lock on byte one of the file would represent the right to perform READ and WRITE operations on the second byte-range. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFSv4.1 protocol unless clients refrain from data caching.",
      "ja": "共有予約の代わりにバイトレンジロックを使用することを選択するアプリケーションの場合、矛盾するファイルアクセスを除外するために、クライアント側のデータキャッシュに適用される類似の制約セットがあります。これらの規則は、実行された実際の読み取り操作と書き込み操作が実行された同等の方法で一致するような方法でバイトレンジロックが使用される場合にのみ有効です。これは、純粋な条約に基づくバイトレンジロックとは対照的です。たとえば、ファイルを2つの1メガバイトの範囲に分割し、バイトゼロのバイトレンジロックで2バイト範囲へのアクセスを保護することで、2メガバイトファイルを操作することができます。ファイルのバイトゼロのWRITE_LTロックは、最初のバイト範囲で読み書き操作を実行する権利を表します。ファイルの1つのファイルの1つのWRITE_LTロックは、2回目のバイト範囲で読み取り操作と書き込み操作を実行する権利を表します。ファイルを操作するすべてのアプリケーションがこの規約に従う限り、それらはローカルファイルシステムで機能します。ただし、クライアントがデータキャッシングを控えると、NFSV4.1プロトコルでは機能しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The rules for data caching in the byte-range locking environment are:",
      "ja": "バイトレンジロック環境でのデータキャッシュの規則は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* First, when a client obtains a byte-range lock for a particular byte-range, the data cache corresponding to that byte-range (if any cache data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked byte-range. A client might choose to invalidate all of the non-modified cached data that it has for the file, but the only requirement for correct operation is to invalidate all of the data in the newly locked byte-range.",
      "ja": "* まず、クライアントが特定のバイト範囲のバイトレンジロックを取得すると、そのバイト範囲に対応するデータキャッシュ（キャッシュデータが存在する場合）は再検証されなければなりません。キャッシュされたデータが取得されてからファイルが更新された可能性があることを変更属性が表示されている場合、クライアントは新しくロックされたバイト範囲のキャッシュデータをフラッシュまたは無効にする必要があります。クライアントは、ファイルに含まれているすべての変更されていないキャッシュデータを無効にすることを選択できますが、正しい操作の唯一の要件は、新しくロックされたバイト範囲内のすべてのデータを無効にすることです。"
    },
    {
      "indent": 3,
      "text": "* Second, before releasing a WRITE_LT lock for a byte-range, all modified data for that byte-range must be flushed to the server. The modified data must also be written to stable storage.",
      "ja": "* 第二に、1バイト範囲のWRITE_LTロックを解除する前に、そのバイトレンジのすべての変更データをサーバーにフラッシュする必要があります。修正されたデータは安定したストレージにも書き込まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that flushing data to the server and the invalidation of cached data must reflect the actual byte-ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the byte-range outside the unlocked area. This, in turn, may be part of a byte-range locked by another client. Clients can avoid this situation by synchronously performing portions of WRITE operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area that is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data that the client possesses may not be valid.",
      "ja": "データをサーバーにフラッシュし、キャッシュされたデータの無効化は、ロックまたはロック解除された実際のバイトレンジを反映している必要があります。クライアントキャッシュブロックの境界を反映するためにこれらを上下に丸めると、慎重に行われない場合は問題が発生します。たとえば、そのブロックの半分のみがロック解除されている領域内にあるときに修正されたブロックを書き込むと、ロック解除された領域の外側のバイト範囲に対して無効な変更が発生する可能性があります。これは、次に、他のクライアントによってロックされたバイト範囲の一部であり得る。クライアントは、フルブロックではないその部分（初期または最後）と重なる書き込み操作の一部を同期的に実行することによってこの状況を回避できます。同様に、積分数のフルバッファブロックではないロック領域を無効にすることで、クライアントが所有するデータが有効ではない可能性があることを示す場合、クライアントはサーバーから1つまたは2つの部分ブロックを読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "The data that is written to the server as a prerequisite to the unlocking of a byte-range must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server restart might conflict with a lock held by another client.",
      "ja": "バイト範囲のロック解除の前提条件としてサーバーに書き込まれるデータをサーバーで、安定したストレージに書き込む必要があります。クライアントは、これを同期書き込みで、またはコミット操作で非同期書き込みを行うことによって実行することができます。これは、サーバーの再起動後の変更データの再送信が他のクライアントによって保持されているロックと競合する可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "A client implementation may choose to accommodate applications that use byte-range locking in non-standard ways (e.g., using a byte-range lock as a global semaphore) by flushing to the server more data upon a LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of byte-range locks that the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated LOCKU operation. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate byte-range lock and those for which there are modifications not covered by a byte-range lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.",
      "ja": "クライアント実装は、ロックされている範囲でカバーされているものよりもロック上のより多くのデータをより多くのデータにフラッシュすることによって、非標準的な方法でバイトレンジロックを使用するアプリケーションに対応することを選択することができます。 。これには、ロック解除が行われているもの以外のファイル内の変更データを含めることができます。そのような場合、クライアントは、アプリケーションが保持しているバイトレンジロックの範囲内でのみ、読み書きが行われているアプリケーションを妨害してはなりません。たとえば、アプリケーションはファイルの1バイトをロックしてそのシングルバイトの書き込みを進めます。変更されたすべてのデータをサーバにフラッシュすることによってロックを処理することを選択したクライアントは、無関係のロック操作に応答してその単一のバイトを有効に書き込むことができます。ただし、ロックされていない領域が含まれており、別のクライアントによってロックされる可能性があるため、単一の書き込みバイトが見つかったブロック全体を書き込むことは有効ではありません。クライアント実装は、修正されたデータとのファイルを適切なバイトレンジロックでカバーされている領域にすべての変更が行われるものと、バイトレンジロックによってカバーされていないものに変更されたデータを除算することで、この問題を回避できます。以前のクラスのファイルに対して行われた書き込みは、ロックされていない領域を含めてはならず、したがってクライアント上で変更されていない。"
    },
    {
      "indent": 0,
      "text": "10.3.3. Data Caching and Mandatory File Locking",
      "section_title": true,
      "ja": "10.3.3. データキャッシングと必須のファイルロック"
    },
    {
      "indent": 3,
      "text": "Client-side data caching needs to respect mandatory byte-range locking when it is in effect. The presence of mandatory byte-range locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE operation on a file for which it has an appropriate share reservation. When mandatory locking is in effect for a file, the client must check for an appropriate byte-range lock for data being read or written. If a byte-range lock exists for the range being read or written, the client may satisfy the request using the client's validated cache. If an appropriate byte-range lock is not held for the range of the read or write, the read or write request must not be satisfied by the client's cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked byte-range, the request should be subdivided into multiple pieces with each byte-range (locked or not) treated appropriately.",
      "ja": "クライアントサイドのデータキャッシングは、有効なときに必須のバイトレンジロックを尊重する必要があります。特定のファイルの必須バイトレンジロックの存在は、クライアントが適切な共有予約があるファイルに対して読み取りまたは書き込み操作からNFS4ERR_LOCKEDを取り戻すときに示されます。必須のロックがファイルに有効になっている場合、クライアントは読み書きまたは書き込まれているデータの適切なバイトレンジロックを確認する必要があります。読み書き中の範囲に対してバイトレンジロックが存在する場合、クライアントはクライアントの検証されたキャッシュを使用して要求を満たすことができます。読み取りまたは書き込みの範囲に対して適切なバイトレンジロックが保持されていない場合、読み取り要求または書き込み要求はクライアントのキャッシュによって満たされてはならず、要求は処理のためにサーバーに送信されなければなりません。読み取り要求または書き込み要求が部分的にロックされたバイト範囲と重なっている場合、要求は適切に処理された各バイトレンジ（ロックまたはそうでない）で複数のピースに細分されるべきです。"
    },
    {
      "indent": 0,
      "text": "10.3.4. Data Caching and File Identity",
      "section_title": true,
      "ja": "10.3.4. データキャッシュとファイルID"
    },
    {
      "indent": 3,
      "text": "When clients cache data, the file data needs to be organized according to the file system object to which the data belongs. For NFSv3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.",
      "ja": "クライアントがデータをキャッシュすると、ファイルデータは、データが属するファイルシステムオブジェクトに従って編成される必要があります。NFSV3クライアントの場合、典型的な練習は、その異なるファイルハンドルが異なるファイルシステムオブジェクトを表すことをキャッシュする目的で想定されていました。その後、クライアントはこの基準でデータキャッシュを整理して維持することを選択しています。"
    },
    {
      "indent": 3,
      "text": "In the NFSv4.1 protocol, there is now the possibility to have significant deviations from a \"one filehandle per object\" model because a filehandle may be constructed on the basis of the object's pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client-side objects that mapped to the same server-side object.",
      "ja": "NFSV4.1プロトコルでは、オブジェクトのパス名に基づいてファイルハンドルを構築することができるため、「オブジェクトごとの1つのファイルハンドル」モデルから大きな偏差を持つ可能性があります。したがって、クライアントは、2つのファイルハンドルが同じファイルシステムオブジェクトを指定するかどうかを判断するための信頼できる方法が必要です。クライアントが単にすべての異なるファイルハンドルが異なるオブジェクトを示すと仮定し、このベースでデータキャッシングを実行するようになると、同じサーバー側のオブジェクトにマッピングされた異なるクライアントサイドオブジェクトの間で矛盾するキャッシングが発生します。"
    },
    {
      "indent": 3,
      "text": "By providing a method to differentiate filehandles, the NFSv4.1 protocol alleviates a potential functional regression in comparison with the NFSv3 protocol. Without this method, caching inconsistencies within the same client could occur, and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients, but that is not the issue being addressed here.",
      "ja": "ファイルハンドルを区別する方法を提供することによって、NFSV4.1プロトコルは、NFSV3プロトコルと比較して潜在的な機能回帰を軽減します。この方法がなければ、同じクライアント内のキャッシング矛盾が発生する可能性があり、これは以前のバージョンのNFSプロトコルには存在しませんでした。複数のクライアントで実行されているアプリケーションとのこのような不一致を持つことは可能ですが、それはここでは問題に対処されていません。"
    },
    {
      "indent": 3,
      "text": "For the purposes of data caching, the following steps allow an NFSv4.1 client to determine whether two distinct filehandles denote the same server-side object:",
      "ja": "データキャッシングの目的のために、次の手順では、NFSV4.1クライアントが2つの異なるファイルハンドルが同じサーバーサイドオブジェクトを示すかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "* If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.",
      "ja": "* 2つのFileHandlesに向けられたgetATTRがFSID属性の異なる値を返す場合、ファイルハンドルは異なるオブジェクトを表します。"
    },
    {
      "indent": 3,
      "text": "* If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.",
      "ja": "* 既知の2つのファイルハンドルのFSIDと一致するFSIDを持つ任意のファイルのgetAttrの場合、値がtrueのunique_handles属性を返し、2つのオブジェクトは異なります。"
    },
    {
      "indent": 3,
      "text": "* If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations that depend on that knowledge (e.g., client-side data caching) cannot be done reliably. Note that if GETATTR does not return the fileid attribute for both filehandles, it will return it for neither of the filehandles, since the fsid for both filehandles is the same.",
      "ja": "* 2つのファイルハンドルに向けられたGetAttrが両方のハンドルのfileID属性を返さない場合は、2つのオブジェクトが同じかどうかを判断することはできません。したがって、その知識（例えば、クライアント側データキャッシング）に依存する操作は確実に行われない。getAttrが両方のファイルハンドルのfileID属性を返さない場合、両方のファイルハンドルのFSIDは同じであるため、ファイルハンドルではそれを返しません。"
    },
    {
      "indent": 3,
      "text": "* If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.",
      "ja": "* 2つのファイルハンドルに向けられたgetATTRがfileID属性に異なる値を返す場合、それらは異なるオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, they are the same object.",
      "ja": "* そうでなければ、それらは同じオブジェクトです。"
    },
    {
      "indent": 0,
      "text": "10.4. Open Delegation",
      "section_title": true,
      "ja": "10.4. オープン委任"
    },
    {
      "indent": 3,
      "text": "When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable since the circumstances that allowed for the delegation are subject to change. In particular, if the server receives a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server, and clients should not assume that any particular OPEN either will or will not result in an OPEN delegation. The following is a typical set of conditions that servers might use in deciding whether an OPEN should be delegated:",
      "ja": "ファイルが開かれているとき、サーバーはオープンのさらなる処理を委任することができ、そのファイルをOpeningクライアントに閉じます。委任を許可する状況は変更されることがあるため、そのような委任はリコール可能です。特に、サーバが他のクライアントから競合するオープンを受信した場合、サーバは他のクライアントからの開いているかどうかを判断する前に委任を思い出す必要があります。委任をサーバーにすることはサーバーになり、クライアントは、特定の開いているいずれかの開いているか、またはオープンな委任を引き起こしないと仮定しないでください。以下は、オープンを委任する必要があるかどうかを決定する際にサーバーが使用することができるという典型的な条件のセットです。"
    },
    {
      "indent": 3,
      "text": "* The client must be able to respond to the server's callback requests. If a backchannel has been established, the server will send a CB_COMPOUND request, containing a single operation, CB_SEQUENCE, for a test of backchannel availability.",
      "ja": "* クライアントはサーバーのコールバック要求に応答できなければなりません。バックチャネルが確立されている場合、サーバーは、バックチャネルの可用性のテストのために、単一の操作CB_Sequenceを含むCB_COMPOUND要求を送信します。"
    },
    {
      "indent": 3,
      "text": "* The client must have responded properly to previous recalls.",
      "ja": "* クライアントは以前のリコールに正しく応答していなければなりません。"
    },
    {
      "indent": 3,
      "text": "* There must be no current OPEN conflicting with the requested delegation.",
      "ja": "* 要求された委任と矛盾する現在のオープンなオープンは必要ありません。"
    },
    {
      "indent": 3,
      "text": "* There should be no current delegation that conflicts with the delegation being requested.",
      "ja": "* 要求されている委任と競合する現在の委任はありません。"
    },
    {
      "indent": 3,
      "text": "* The probability of future conflicting open requests should be low based on the recent history of the file.",
      "ja": "* 将来の矛盾するオープン要求の確率は、最近のファイルの履歴に基づいて低くなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).",
      "ja": "* 委任されたクライアントが適用される処方された処理とは、必要な処理を規定の取り扱いと互換性がなくなります（下記参照）。"
    },
    {
      "indent": 3,
      "text": "There are two types of OPEN delegations: OPEN_DELEGATE_READ and OPEN_DELEGATE_WRITE. An OPEN_DELEGATE_READ delegation allows a client to handle, on its own, requests to open a file for reading that do not deny OPEN4_SHARE_ACCESS_READ access to others. Multiple OPEN_DELEGATE_READ delegations may be outstanding simultaneously and do not conflict. An OPEN_DELEGATE_WRITE delegation allows the client to handle, on its own, all opens. Only one OPEN_DELEGATE_WRITE delegation may exist for a given file at a given time, and it is inconsistent with any OPEN_DELEGATE_READ delegations.",
      "ja": "オープン委任には、Open_Delegate_ReadとOpen_Delegate_Writeには2つのタイプがあります。open_delegate_readの委任により、クライアントはそれ自身で、Open4_share_access_readアクセスを他のものに拒否しないようにファイルを開くためのファイルを開く要求を求めることができます。複数のopen_delegate_readの代表団が同時に優れていて、競合しない可能性があります。open_delegate_writeの委任を許可すると、クライアントはそれ自身で、すべてが開くことを可能にします。特定のファイルに対して特定のファイルに対して存在する場合は1つのOpen_Delegate_Writeの委任は1つだけであり、open_delegate_readの委任と矛盾しています。"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN_DELEGATE_READ delegation, it is assured that neither the contents, the attributes (with the exception of time_access), nor the names of any links to the file will change without its knowledge, so long as the delegation is held. When a client has an OPEN_DELEGATE_WRITE delegation, it may modify the file data locally since no other client will be accessing the file's data. The client holding an OPEN_DELEGATE_WRITE delegation may only locally affect file attributes that are intimately connected with the file data: size, change, time_access, time_metadata, and time_modify. All other attributes must be reflected on the server.",
      "ja": "クライアントがOpen_Delegate_readの委任を持つ場合、委任が保持されている限り、内容、属性（time_accessを除く）もそのファイルへのリンクの名前もその知識なしに変更されないように保証されます。クライアントがOPEN_DELEGATE_WRITE委任を持つと、他のクライアントがファイルのデータにアクセスしているため、ファイルデータをローカルに変更することがあります。open_delegate_write委任を保持しているクライアントは、ファイルデータと密接に接続されているファイル属性にのみローカルにしか影響します。サイズ、変更、time_access、time_metadata、およびtime_modify。他のすべての属性はサーバーに反映されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN delegation, it does not need to send OPENs or CLOSEs to the server. Instead, the client may update the appropriate status internally. For an OPEN_DELEGATE_READ delegation, opens that cannot be handled locally (opens that are for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH or that deny OPEN4_SHARE_ACCESS_READ access) must be sent to the server.",
      "ja": "クライアントにオープンな委任がある場合は、サーバーを開くか閉じる必要はありません。代わりに、クライアントは適切なステータスを内部的に更新することができます。Open_Delegate_readの委任の場合は、ローカルに処理できない（Open4_Share_Access_Write / Open4_Share_access_bothの場合は開く、またはそのopen4_share_access_readアクセス）をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an OPEN delegation is made, the reply to the OPEN contains an OPEN delegation structure that specifies the following:",
      "ja": "オープン委任が行われると、Openへの返信には、次のものを指定するオープン委任構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "* the type of delegation (OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE).",
      "ja": "* 委任の種類（OPEN_DELEGATE_READまたはOPEN_DELEGATE_WRITE）。"
    },
    {
      "indent": 3,
      "text": "* space limitation information to control flushing of data on close (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)",
      "ja": "* スペース制限情報閉じるデータのフラッシュを制御する（Open_Delegate_Write Delegationのみ; 10.4.1項を参照）。"
    },
    {
      "indent": 3,
      "text": "* an nfsace4 specifying read and write permissions",
      "ja": "* 読み書き権限を指定するNFSACE4"
    },
    {
      "indent": 3,
      "text": "* a stateid to represent the delegation",
      "ja": "* 代表団を表すStiodid"
    },
    {
      "indent": 3,
      "text": "The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular lock-owner and will continue to be valid after the delegation is recalled and the file remains open.",
      "ja": "委任ステートIDは、Open適切な状態のStateIDとは別に別々に異なります。標準のStateIDは、委任StareIDとは異なり、特定のロックオーナーに関連付けられており、委任が呼び出された後に有効であり、ファイルは開いているままになります。"
    },
    {
      "indent": 3,
      "text": "When a request internal to the client is made to open a file and an OPEN delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in the OPEN delegation being denied so that the checks can be made by the server itself.",
      "ja": "クライアント内部の要求がファイルを開いてオープン委任が有効になると、以下の条件に基づいて承認または拒否されます。代理人によって行われるべき他のチェックに対する要求は、オープン委任が拒否され、そのため、チェックがサーバー自体によって行われる可能性があります。"
    },
    {
      "indent": 3,
      "text": "* The access and deny bits for the request and the file as described in Section 9.7.",
      "ja": "* セクション9.7で説明されているように、要求とファイルのアクセスと拒否ビット。"
    },
    {
      "indent": 3,
      "text": "* The read and write permissions as determined below.",
      "ja": "* 以下に決定された読み取りおよび書き込み権限。"
    },
    {
      "indent": 3,
      "text": "The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:",
      "ja": "委任で渡されたNFSACE4を使用して、頻繁なアクセスコールを避けることができます。許可検査は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.",
      "ja": "* NFSACE4が開くことができることを示している場合は、サーバーを参照せずに許可されます。"
    },
    {
      "indent": 3,
      "text": "* If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.",
      "ja": "* NFSACE4が開くことができない可能性があることを示す場合は、確定的な答えを取得するためにアクセス要求をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user \"root\" to the user \"nobody\" (see Section 5.9) may make it incorrect to return the actual ACL of the file in the delegation response.",
      "ja": "サーバーは、ファイルの実際のACLよりも制限的なNFSACE4を返すことがあります。これには、すべてのアクセスの拒否を指定するNFSACE4が含まれています。従来のユーザー \"root\"をユーザー \"NOBODY\"（セクション5.9を参照）にマッピングするなどの一般的な方法は、委任応答でファイルの実際のACLを返すように誤っている可能性があります。"
    },
    {
      "indent": 3,
      "text": "The use of a delegation together with various other forms of caching creates the possibility that no server authentication and authorization will ever be performed for a given user since all of the user's requests might be satisfied locally. Where the client is depending on the server for authentication and authorization, the client should be sure authentication and authorization occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every OPEN delegation.",
      "ja": "委任を他のさまざまな形式のキャッシュと一緒に使用することは、すべてのユーザーの要求がローカルに満たされる可能性があるため、特定のユーザーに対してサーバー認証と許可が実行されない可能性を作成します。クライアントが認証と許可のためにサーバーによってある場合、クライアントはアクセス操作を使用して各ユーザーに対して認証と許可が発生することを確認してください。それ以外の場合はアクセス操作が必要ない場合でもこれは事実であるはずです。前述のように、サーバーは、すべてのオープン委任によるすべてのアクセスを拒否するNFSACE4を返すことによって、頻繁な認証を強制することができます。"
    },
    {
      "indent": 0,
      "text": "10.4.1. Open Delegation and Data Caching",
      "section_title": true,
      "ja": "10.4.1. オープン委任とデータキャッシング"
    },
    {
      "indent": 3,
      "text": "An OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an OPEN delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the \"OPEN_DELEGATE_READ delegation\" provides a guarantee that no OPEN for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH, and thus no write, has occurred. Similarly, when closing a file opened for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH and if an OPEN_DELEGATE_WRITE delegation is in effect, the data written does not have to be written to the server until the OPEN delegation is recalled. The continued endurance of the OPEN delegation provides a guarantee that no open, and thus no READ or WRITE, has been done by another client.",
      "ja": "オープン委任により、オープニングファイルと閉じるファイルに関連するメッセージオーバーヘッドの大部分が排除されます。オープン委任が有効になっているときに開かれても、検証メッセージをサーバーに送信する必要はありません。\"Open_Delegate_read委任\"の継続的な耐久性は、Open4_Share_access_Write / Open4_Share_access_bothの開放なしではないことを保証します。同様に、Open4_Share_access_Write / Open4_Share_access_bothで開かれたファイルを閉じると、Open_Delegate_Writeの委任が有効な場合は、書き込まれたデータをサーバーに書き込む必要はありません。オープン委任の継続的な耐久性は、オープンなし、したがって読み書きがないという保証を提供します。"
    },
    {
      "indent": 3,
      "text": "For the purposes of OPEN delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. Although a client SHOULD NOT use special stateids when an open exists, delegation handling on the server can use the client ID associated with the current session to determine if the operation has been done by the holder of the delegation (in which case, no recall is necessary) or by another client (in which case, the delegation must be recalled and I/O not proceed until the delegation is returned or revoked).",
      "ja": "オープン委任の目的のために、オープンなしで行われた読み書きは、対応するタイプのオープンの機能的な均等物として扱われます。オープンが存在する場合、クライアントは特別な状態にはなりませんが、サーバー上の委任処理は現在のセッションに関連付けられているクライアントIDを使用して、委任の保有者によって操作が行われたかどうかを判断できます（その場合は、リコールはありません。必要）または別のクライアントによって（その場合、委任は呼び出す必要があり、委任が返されたか失効されるまで入出力は進みません）。"
    },
    {
      "indent": 3,
      "text": "With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server and, through normal accounting, the server is able to determine if the available file system space for the data has been exceeded (i.e., the server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that an alternative method be in place for the same type of communication to occur between client and server.",
      "ja": "代理人では、クライアントはファイルの閉会が処理されたときにサーバーへのデータの書き込みを回避することができます。ファイルクローズシステムコールは、アプリケーションによって生成された変更されたファイルデータの安定したストレージの欠如をクライアントに通知される通常のポイントです。閉じると、ファイルデータがサーバーに書き込まれ、通常のアカウンティングを通じて、データの使用可能なファイルシステムスペースが超えているかどうかを判断できます（すなわち、サーバーはNFS4ER_NOSPCまたはNFS4ERR_DQUOTを返します）。このアカウンティングにはクォータが含まれます。代表団の導入には、クライアントとサーバー間で同じ種類の通信が行われるための代替方法が適切な方法が必要です。"
    },
    {
      "indent": 3,
      "text": "In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to write modified data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data, taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server's state space limits for delegations. If the client exceeds the stated limits for the delegation, the server's behavior is undefined.",
      "ja": "委任応答では、サーバーはファイルのサイズの制限または変更されたブロック数と関連ブロックサイズの数のいずれかを提供します。サーバーは、クライアントが元の委任で提供されているものと同じサイズのサーバーに修正されたデータを記述できるようにする必要があります。サーバーはすべての未払いの委任に対してこの保証を行わなければなりません。したがって、利用可能なファイルシステムスペースと該当するクォータを考慮して、サーバーは、新規または変更されたデータのために利用可能なスペースの管理に注意してください。利用可能なファイルシステムスペースを管理した結果として、サーバーは委任を思い出すことができます。クライアントは、代表団のためのサーバーの状態空間の制限によって従うべきです。クライアントが委任の記載された制限を超えると、サーバーの動作は未定義です。"
    },
    {
      "indent": 3,
      "text": "Based on server conditions, quotas, or available file system space, the server may grant OPEN_DELEGATE_WRITE delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.",
      "ja": "サーバーの状態、クォータ、または使用可能なファイルシステムスペースに基づいて、サーバーは非常に制限的なスペースの制限を持つOpen_Delegate_Writeの委任を付与することがあります。制限は、常に修正されたデータを閉じるように強制的に強制的に強制的に強制的に定義することができます。"
    },
    {
      "indent": 3,
      "text": "With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client, and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.",
      "ja": "認証に関して、クローズが発生した後に修正されたデータをサーバにフラッシュすることは問題があるかもしれない。たとえば、アプリケーションのユーザーはクライアントをログオフした可能性があり、期限切れの認証資格情報が存在しない可能性があります。この場合、クライアントは、局所期限切れの信任状が実際に利用可能になることを確認するために特別な注意を払う必要があるかもしれません。これは、資格情報の有効期限を追跡し、それらの有効期限の前に、または必要に応じて可用性を保証するための資格情報のプライベートコピーをすることによって、データをよくフラッシュすることによって達成することができる。"
    },
    {
      "indent": 0,
      "text": "10.4.2. Open Delegation and File Locks",
      "section_title": true,
      "ja": "10.4.2. オープン委任とファイルロック"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, lock operations are performed locally. This includes those required for mandatory byte-range locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.",
      "ja": "クライアントがOPEN_DELEGATE_WRITE委任を保持すると、ロック操作がローカルに実行されます。これには、必須バイトレンジロックに必要なものが含まれます。これは、委任が競合するロックがないことを意味するため、これを行うことができます。同様に、通常はロックの取得と関連付けられているすべての再検証と、ロックの解放に関連するデータのフラッシングは行われる必要はありません。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_READ delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.",
      "ja": "クライアントがOpen_Delegate_readの委任を保持すると、ロック操作はローカルに実行されません。非排他的ロックを要求するものを含むすべてのロック操作は、解像度のためにサーバーに送信されます。"
    },
    {
      "indent": 0,
      "text": "10.4.3. Handling of CB_GETATTR",
      "section_title": true,
      "ja": "10.4.3. CB_GetAttrの処理"
    },
    {
      "indent": 3,
      "text": "The server needs to employ special handling for a GETATTR where the target is a file that has an OPEN_DELEGATE_WRITE delegation in effect. The reason for this is that the client holding the OPEN_DELEGATE_WRITE delegation may have modified the data, and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the OPEN_DELEGATE_WRITE delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.",
      "ja": "サーバーは、ターゲットがOpen_Delegate_Writeの委任を有効にしたファイルであるGETATTRのための特別な処理を採用する必要があります。この理由は、Open_Delegate_Write委任を保持しているクライアントがデータを変更した可能性があり、サーバーはGetAttrを送信した2番目のクライアントに変更する必要があります。したがって、Open_Delegate_Write委任を保持するクライアントを調べる必要があります。サーバーはCB_GetATTRの動作を使用します。サーバーがCB_GetAttrを介して確実に照会できる唯一の属性は、サイズと変更です。"
    },
    {
      "indent": 3,
      "text": "Since CB_GETATTR is being used to satisfy another client's GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client's copy of the delegated file is not modified (data or size), the server can satisfy the second client's GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client's GETATTR as if the file had been modified locally at the server.",
      "ja": "CB_GETATTRは別のクライアントのGetAttr要求を満たすために使用されているので、委任を保持しているクライアントにファイルの変更されたバージョンがあるかどうかを知る必要があります。委任されたファイルのクライアントのコピーが変更されていない場合（データまたはサイズ）、サーバーはサーバーでローカルに保存されている属性からの2番目のクライアントのGetAttr要求を満たすことができます。ファイルが変更されている場合、サーバーはこの変更された状態についてのみ知る必要があります。サーバーがファイルが現在変更されていると判断した場合、ファイルがサーバーでローカルに変更されたかのように、2番目のクライアントのGetAttrに応答します。"
    },
    {
      "indent": 3,
      "text": "Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size. For the change attribute, the handling is more involved.",
      "ja": "変更属性の形式はサーバによって決定され、クライアントに不透明なので、クライアントとサーバはファイルの修正された状態を通信する方法について同意する必要がある。size属性の場合、クライアントはファイルサイズの現在のビューを報告します。変更属性の場合、処理はより多くの関与しています。"
    },
    {
      "indent": 3,
      "text": "For the client, the following steps will be taken when receiving an OPEN_DELEGATE_WRITE delegation:",
      "ja": "クライアントの場合、open_delegate_write委任を受信すると、次の手順が実行されます。"
    },
    {
      "indent": 3,
      "text": "* The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.",
      "ja": "* 変更属性の値はサーバーから取得され、キャッシュされます。この値をCで表す。"
    },
    {
      "indent": 3,
      "text": "* The client will create a value greater than c that will be used for communicating that modified data is held at the client. Let this value be represented by d.",
      "ja": "* クライアントは、変更されたデータがクライアントに保持されている通信に使用されるCよりも大きい値を作成します。この値をdで表す。"
    },
    {
      "indent": 3,
      "text": "* When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.",
      "ja": "* CHANGE属性のCB_GETATTRを介してクライアントが照会されると、変更されたデータが保持されているかどうかを確認します。ファイルが変更されている場合は、変更属性値の値Dが返されます。このファイルが現在変更されていない場合、クライアントは変更属性の値Cを返します。"
    },
    {
      "indent": 3,
      "text": "For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies the file's data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.",
      "ja": "実装を簡単にするために、クライアントは各CB_GetAttrに対して同じ値dを返すことができる。連続するCB_GetATTR操作の間に、クライアントが再びキャッシュ内のファイルのデータまたはメタデータを変更しても、これは当てはまります。クライアントがクライアントが変更されたデータを保持しているサーバーにクライアントが指定できることであるため、クライアントは同じ値を返すことができます。したがって、Dの値は常にC 1になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client's changes to that integer. Therefore, the server MUST encode the change attribute in network order when sending it to the client. The client MUST decode it from network order to its native order when receiving it, and the client MUST encode it in network order when sending it to the server. For this reason, change is defined as an unsigned integer rather than an opaque array of bytes.",
      "ja": "変更属性は、サーバーが変更されているのはどの単位の単位が変更されているという意味でクライアントに不透明になりますが、サーバーが変更されている場合は不透明ではありません。サーバーは、クライアントのその整数への変更の結果を確認できなければなりません。したがって、サーバーは、クライアントに送信するときにネットワーク順に変更属性をエンコードする必要があります。クライアントは、それを受信するとネットワークの順序からそのネイティブ注文に復号する必要があり、クライアントはサーバーに送信するときにネットワーク順にエンコードする必要があります。このため、変更は不透明なバイト配列ではなく、符号なし整数として定義されます。"
    },
    {
      "indent": 3,
      "text": "For the server, the following steps will be taken when providing an OPEN_DELEGATE_WRITE delegation:",
      "ja": "サーバーの場合、Open_Delegate_Writeの委任を提供するときに次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "* Upon providing an OPEN_DELEGATE_WRITE delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.",
      "ja": "* Open_Delegate_Writeの委任を提供すると、サーバーは委任を記録するために使用するデータ構造内の変更属性のコピーをキャッシュします。この値をSCで表す。"
    },
    {
      "indent": 3,
      "text": "* When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.",
      "ja": "* 2番目のクライアントが同じファイルに対してサーバーにGetAttrオペレーションを送信すると、サーバーは最初のクライアントから変更属性を取得します。この値をCCにする。"
    },
    {
      "indent": 3,
      "text": "* If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.",
      "ja": "* 値CCがSCに等しい場合、ファイルは変更されず、サーバーは変更の現在の値、time_metadata、およびtime_modify（たとえば）を2番目のクライアントに返します。"
    },
    {
      "indent": 3,
      "text": "* If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc >= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file's metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.",
      "ja": "* 値CCがSCと等しくない場合、ファイルは最初のクライアントで変更されており、将来の時間にサーバーで変更される可能性が最も高いです。その後、サーバーはその現在時刻を使用してtime_metadataとtime_modifyの属性値を構築します。NSCを呼び出すSCの新しい値は、NSC> = SC 1.サーバによって計算され、サーバは構成されたtime_metadata、time_modify、およびnsc値を要求者に返す。サーバーは、委任レコードのSCをNSCに置き換えます。time_modify、time_metadata、time_metadataの可能性を防ぐために（委任を保持しているクライアントが委任が失効または返される前に変更されたデータをサーバーに書き込まれなかった場合に発生する可能性があります）、サーバーはファイルを更新する必要があります。構築された属性値を持つメタデータレコード。合理的なパフォーマンスの理由から、構築された属性値を安定したストレージにコミットすることはオプションです。"
    },
    {
      "indent": 3,
      "text": "As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client's cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again, and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation's delegation record would satisfy this mandate by including a boolean field (let us call it \"modified\") that is set to FALSE when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to TRUE the first time cc != sc, and would stay TRUE until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo code:",
      "ja": "このセクションで前述したように、クライアントは、ファイルがクライアントのキャッシュでまだ連続するCB_GetAttr呼び出しの間で再度クライアントのキャッシュで変更された場合でも、その後のCB_GetATTR呼び出しで同じCC値を返すことができます。したがって、サーバーはファイルが再度変更されていると仮定する必要があり、新しいNSCが構築して返す新しいNSCが返された以前のNSCより大きいことを確認する必要があります。実装の委任レコードの例では、委任が許可されたときにFALSEに設定されているブールフィールド（「変更された」と呼びます）、および変更属性値の付与時に設定されたSC値を含めることで、この義務を満たします。修正されたフィールドは、最初の時刻CC！= SCで真に設定され、委任が返されたか取り消されるまで継続します。nsc、time_modify、およびtime_metadataを構築するための処理は、この疑似コードを使用します。"
    },
    {
      "indent": 7,
      "text": "if (!modified) {\n    do CB_GETATTR for change and size;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (cc != sc)\n        modified = TRUE;\n} else {\n    do CB_GETATTR for size;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (modified) {\n    sc = sc + 1;\n    time_modify = time_metadata = current_time;\n    update sc, time_modify, time_metadata into file's metadata;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This would return to the client (that sent GETATTR) the attributes it requested, but make sure size comes from what CB_GETATTR returned. The server would not update the file's metadata with the client's modified size.",
      "ja": "これは、要求された属性をクライアントに戻ります（getAttrを送信されました）。サーバーは、クライアントの変更されたサイズでファイルのメタデータを更新しません。"
    },
    {
      "indent": 3,
      "text": "In the case that the file attribute size is different than the server's current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.",
      "ja": "ファイル属性サイズがサーバーの現在の値と異なる場合、サーバーはCB_GETATTRを介して取得された変更属性の値に関係なく、変更としてこれを変更し、最後のステップのように2番目のクライアントに応答します。"
    },
    {
      "indent": 3,
      "text": "This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR break down.",
      "ja": "この方法論は、クライアントとサーバーとの間のクロックの違いやCB_GetATTRの使用が分解された他のシナリオの問題を解決します。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the server is under no obligation to use CB_GETATTR, and therefore the server MAY simply recall the delegation to avoid its use.",
      "ja": "サーバーはCB_GetATTRを使用する義務を負いません。したがって、サーバーはその使用を回避するために委任をリコールすることがあります。"
    },
    {
      "indent": 0,
      "text": "10.4.4. Recall of Open Delegation",
      "section_title": true,
      "ja": "10.4.4. オープン委任の思い出"
    },
    {
      "indent": 3,
      "text": "The following events necessitate recall of an OPEN delegation:",
      "ja": "次のイベントは、オープン委任を思い出す必要があります。"
    },
    {
      "indent": 3,
      "text": "* potentially conflicting OPEN request (or a READ or WRITE operation done with a special stateid)",
      "ja": "* 潜在的に矛盾するオープンリクエスト（または特別な州のIDで行われた読み取りまたは書き込み操作）"
    },
    {
      "indent": 3,
      "text": "* SETATTR sent by another client",
      "ja": "* 他のクライアントによって送信されたsetAttr"
    },
    {
      "indent": 3,
      "text": "* REMOVE request for the file",
      "ja": "* ファイルの要求を削除します"
    },
    {
      "indent": 3,
      "text": "* RENAME request for the file as either the source or target of the RENAME",
      "ja": "* 名前変更のソースまたはターゲットとしてのファイルの要求の名前変更"
    },
    {
      "indent": 3,
      "text": "Whether a RENAME of a directory in the path leading to the file results in recall of an OPEN delegation depends on the semantics of the server's file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.",
      "ja": "ファイルにつながるパス内のディレクトリの名前変更が、オープン委任をリコールしているかどうかは、サーバーのファイルシステムのセマンティクスによって異なります。ファイルシステムが開いているときにそのファイルシステムがそのような名前の変更を拒否した場合は、問題のファイルが開いているかどうかを判断するためにリコールを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to the situations above, the server may choose to recall OPEN delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.",
      "ja": "上記の状況に加えて、サーバーは、リソースの制約がそれがそれを推奨されるようにすると、いつでもオープンな委任を思い出すことを選択できます。顧客は常にリコールの可能性のために準備されるべきです。"
    },
    {
      "indent": 3,
      "text": "When a client receives a recall for an OPEN delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:",
      "ja": "クライアントがオープン委任のリコールを受信すると、委任を返す前にサーバー上の状態を更新する必要があります。これらの同じアップデートは、クライアントが委任を自発的に返すことを選択したときはいつでも実行する必要があります。以下の州の項目を扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.",
      "ja": "* 委任に関連付けられているファイルが開いていなくても、以前のクローズ操作がサーバーに送信されていない場合は、Close操作をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will no longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (See Section 18.16, which describes the OPEN operation, for details.)",
      "ja": "* ファイルにクライアントで他のオープン参照がある場合は、オープン操作をサーバーに送信する必要があります。委任ステートIDは有効ではなくなるため、クライアントによるその後の使用のために適切なStateIDがサーバーによって提供されます。これらのオープンリクエストは、クレームのクレームタイプのクレームタイプを使用して行われます。これにより、クライアントがオープンを実行するための適切な権限を確立できるように、委任ステートIDの表示を可能にします。（詳細は、開き操作を説明したセクション18.16を参照してください。）"
    },
    {
      "indent": 3,
      "text": "* If there are granted byte-range locks, the corresponding LOCK operations need to be performed. This applies to the OPEN_DELEGATE_WRITE delegation case only.",
      "ja": "* 付与されたバイトレンジロックが付与されている場合、対応するロック操作を実行する必要があります。これはOpen_Delegate_Writeの委任の場合のみに適用されます。"
    },
    {
      "indent": 3,
      "text": "* For an OPEN_DELEGATE_WRITE delegation, if at the time of recall the file is not open for OPEN4_SHARE_ACCESS_WRITE/ OPEN4_SHARE_ACCESS_BOTH, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.",
      "ja": "* Open_Delegate_Writeの委任の場合、ファイルの呼び出し時にOpen4_Share_access_Write / Open4_Share_access_bothに対して開いていない場合は、ファイルの変更されたすべてのデータをサーバーにフラッシュする必要があります。委任が存在しなかった場合、クライアントはクローズ操作の前にこのデータをフラッシュしていました。"
    },
    {
      "indent": 3,
      "text": "* For an OPEN_DELEGATE_WRITE delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.",
      "ja": "* open_delegate_writeの委任の場合、リコール時にファイルがまだ開いているときに、ファイルの変更されたデータをサーバーにフラッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "* With the OPEN_DELEGATE_WRITE delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.",
      "ja": "* open_delegate_writeの委任を整うと、委任期間中にファイルが切り捨てられた可能性があります。たとえば、サイズ属性値がゼロでオープンされていないオープンの結果として切り捨てが発生する可能性があります。したがって、ファイルの切り捨てが発生していてこの操作がサーバーに伝播されていない場合、変更されたデータがサーバーに書き込まれる前に切り捨てが必要です。"
    },
    {
      "indent": 3,
      "text": "In the case of OPEN_DELEGATE_WRITE delegation, byte-range locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any byte-range for which a WRITE_LT lock was released while the OPEN_DELEGATE_WRITE delegation was in effect. However, because the OPEN_DELEGATE_WRITE delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any WRITE_LT lock has been released while the OPEN_DELEGATE_WRITE delegation was in effect.",
      "ja": "Open_Delegate_Writeの委任の場合、バイトレンジロックはいくつかの追加の要件を課します。関連する不変権を正確に維持するためには、open_delegate_write委任が有効な間にWRITE_LTロックが解除された任意のバイト範囲内で修正されたデータをフラッシュする必要があります。ただし、Open_Delegate_Writeの委任は他のクライアントによる他のロックを意味していないため、open_delegate_write委任が有効になっている間にwrite_ltロックが解除された場合に（すぐ上に記載されているように）ファイルのすべての変更されたデータをフラッシュすることは簡単です。"
    },
    {
      "indent": 3,
      "text": "An implementation need not wait until delegation recall (or the decision to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual OPEN state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. An exception is when the client has no more internal opens of the file. In this case, sending a CLOSE is useful because it reduces resource utilization on the client and server. Regardless of the client's choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the OPEN that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.",
      "ja": "実装は、実装の考慮事項（例えばリソース可用性制約）が望ましい場合には、上記の動作のいずれかを実行するために委任リコール（または委任を委任を返すという決定）が待機する必要はありません。しかしながら、一般的に、ファイルの実際の開いた状態が変化し続けることができるという事実は、代表団の復帰の一部として、開くことについて情報を送信することは価値がなくなり、サーバに閉じることを除く。例外は、クライアントがファイルの内部オープンをもう一度開いていない場合です。この場合、クライアントとサーバー上のリソース使用率を低下させるため、クローズを送信することが便利です。これらのアクションのスケジューリングに関するクライアントの選択肢に関係なく、委任が返される前にすべての委任が返される前に実行されなければなりません。これらのアクションは、以前のリクエストまたは以前の操作で同じ複合要求で実行できます。"
    },
    {
      "indent": 0,
      "text": "10.4.5. Clients That Fail to Honor Delegation Recalls",
      "section_title": true,
      "ja": "10.4.5. 委任を尊重することに失敗するクライアント"
    },
    {
      "indent": 3,
      "text": "A client may fail to respond to a recall for various reasons, such as a failure of the backchannel from server to the client. The client may be unaware of a failure in the backchannel. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held an OPEN_DELEGATE_WRITE delegation.",
      "ja": "クライアントは、サーバーからクライアントへのバックチャネルの障害など、さまざまな理由でリコールに応答できません。クライアントは、バックチャネル内の障害を認識していない可能性があります。この意識の欠如は、その委任が失敗した後にクライアントが見つかる可能性があり、別のクライアントはクライアントが委任を受けたデータを変更しました。これは、open_delegate_write委任を保持しているクライアントにとって特に問題です。"
    },
    {
      "indent": 3,
      "text": "Status bits returned by SEQUENCE operations help to provide an alternate way of informing the client of issues regarding the status of the backchannel and of recalled delegations. When the backchannel is not available, the server returns the status bit SEQ4_STATUS_CB_PATH_DOWN on SEQUENCE operations. The client can react by attempting to re-establish the backchannel and by returning recallable objects if a backchannel cannot be successfully re-established.",
      "ja": "シーケンス操作によって返されるステータスビットは、バックチャネルのステータスとリコールされた委任に関する問題のクライアントに通知する代替方法を提供するのに役立ちます。バックチャネルが使用できない場合、サーバーはシーケンス操作でステータスビットSEQ4_STATUS_CB_PATH_DOWNを返します。バックチャネルを再確立し、バックチャネルを正常に再確立できない場合は、クライアントがバックチャネルを再確立し、リコール可能なオブジェクトを返すことによって反応できます。"
    },
    {
      "indent": 3,
      "text": "Whether the backchannel is functioning or not, it may be that the recalled delegation is not returned. Note that the client's lease might still be renewed, even though the recalled delegation is not returned. In this situation, servers SHOULD revoke delegations that are not returned in a period of time equal to the lease period. This period of time should allow the client time to note the backchannel-down status and re-establish the backchannel.",
      "ja": "バックチャネルが機能しているかどうかは、リコールされた委任が返されない可能性があります。リコールされた委任が返されない場合でも、クライアントのリースが更新される可能性があります。この状況では、サーバーはリース期間に等しい期間に返されない委任を取り消す必要があります。この期間には、クライアントの時刻にバックチャネルダウンステータスに注意してバックチャネルを再確立することができます。"
    },
    {
      "indent": 3,
      "text": "When delegations are revoked, the server will return with the SEQ4_STATUS_RECALLABLE_STATE_REVOKED status bit set on subsequent SEQUENCE operations. The client should note this and then use TEST_STATEID to find which delegations have been revoked.",
      "ja": "代表団が取り消されると、サーバーは後続のシーケンス操作でSEQ4_STATUS_RECALLABLE_STATE_REVOKED STATUSビットを返します。クライアントはこれに注意してからtest_stateIDを使用してどの代表団が取り消されたのかを見つけます。"
    },
    {
      "indent": 0,
      "text": "10.4.6. Delegation Revocation",
      "section_title": true,
      "ja": "10.4.6. 委任失効"
    },
    {
      "indent": 3,
      "text": "At the point a delegation is revoked, if there are associated opens on the client, these opens may or may not be revoked. If no byte-range lock or open is granted that is inconsistent with the existing open, the stateid for the open may remain valid and be disconnected from the revoked delegation, just as would be the case if the delegation were returned.",
      "ja": "代表団が取り消される時点で、クライアントに関連付けられている場合は、これらが開き、または取り消されない場合があります。既存のオープンと矛盾するバイトレンジロックまたはオープンが付与されていない場合、オープンのStateIDは有効なままであり、委任が返された場合と同様に、失効した委任から切断されます。"
    },
    {
      "indent": 3,
      "text": "For example, if an OPEN for OPEN4_SHARE_ACCESS_BOTH with a deny of OPEN4_SHARE_DENY_NONE is associated with the delegation, granting of another such OPEN to a different client will revoke the delegation but need not revoke the OPEN, since the two OPENs are consistent with each other. On the other hand, if an OPEN denying write access is granted, then the existing OPEN must be revoked.",
      "ja": "たとえば、Open4_Share_deny_noneの拒否を持つOpen4_Share_access_bothのオープンが委任に関連付けられている場合、別のクライアントへのオープンの許可は委任を取り消しますが、2つの開いているのは互いに一致しているため、開く必要はありません。一方、オープン拒否書き込みアクセスが許可されている場合は、既存のオープンを取り消す必要があります。"
    },
    {
      "indent": 3,
      "text": "When opens and/or locks are revoked, the applications holding these opens or locks need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.",
      "ja": "開くとロックが取り消されると、これらを開いたアプリケーションまたはロックを通知する必要があります。この通知は通常、読み取り/書き込み操作のエラーを返すことによって、または開いているファイルに対してクローズが試行されたときに発生します。"
    },
    {
      "indent": 3,
      "text": "If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See Section 10.5.1 for additional details.",
      "ja": "委任が取り消された時点でファイルに開いていない場合は、失効の通知は不要です。ただし、ファイルのクライアントに存在する変更データがある場合は、アプリケーションのユーザーに通知される必要があります。残念ながら、アクティブなアプリケーションがクライアントに存在しないため、ユーザーに通知することは不可能かもしれません。詳細については10.5.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.4.7. Delegations via WANT_DELEGATION",
      "section_title": true,
      "ja": "10.4.7. want_delegationを介した代表団"
    },
    {
      "indent": 3,
      "text": "In addition to providing delegations as part of the reply to OPEN operations, servers MAY provide delegations separate from open, via the OPTIONAL WANT_DELEGATION operation. This allows delegations to be obtained in advance of an OPEN that might benefit from them, for objects that are not a valid target of OPEN, or to deal with cases in which a delegation has been recalled and the client wants to make an attempt to re-establish it if the absence of use by other clients allows that.",
      "ja": "オープン操作への返信の一部として代理委員会を提供することに加えて、サーバーはオプションのwant_delegation操作を介してオープンとは別の代表団を提供することができます。これにより、オープンの有効なターゲットではないオブジェクトの場合、または委任がリコールされ、クライアントが再登録されている場合に対処することができるオープンを事前に取得することができます。 - 他のクライアントが使用不在がある場合は、それを実現してください。"
    },
    {
      "indent": 3,
      "text": "The WANT_DELEGATION operation may be performed on any type of file object other than a directory.",
      "ja": "want_delegation操作は、ディレクトリ以外の任意の種類のファイルオブジェクトに対して実行できます。"
    },
    {
      "indent": 3,
      "text": "When a delegation is obtained using WANT_DELEGATION, any open files for the same filehandle held by that client are to be treated as subordinate to the delegation, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. They are otherwise unchanged as to seqid, access and deny modes, and the relationship with byte-range locks. Similarly, because existing byte-range locks are subordinate to an open, those byte-range locks also become indirectly subordinate to that new delegation.",
      "ja": "want_delegationを使用して委任が取得されると、そのクライアントによって保持されているのと同じファイルハンドルのためのオープンファイルは、委任されたかのように、委任が委任されたものとして扱われます。そうではなく、seqid、アクセスおよび拒否モード、およびバイトレンジロックとの関係に関しては変更されません。同様に、既存のバイトレンジロックが開いているため、これらのバイトレンジロックもその新しい委任に間接的に従属するようになります。"
    },
    {
      "indent": 3,
      "text": "The WANT_DELEGATION operation provides for delivery of delegations via callbacks, when the delegations are not immediately available. When a requested delegation is available, it is delivered to the client via a CB_PUSH_DELEG operation. When this happens, open files for the same filehandle become subordinate to the new delegation at the point at which the delegation is delivered, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. Similarly, this occurs for existing byte-range locks subordinate to an open.",
      "ja": "want_delegation操作は、委任がすぐに利用できない場合、コールバックを介した代表団の配信を提供します。要求された委任が利用可能な場合は、CB_PUSH_DELEG操作を介してクライアントに配信されます。これが起こると、同じファイルハンドルのファイルを開くと、委任が配信されている時点で、委任が配信される時点で、委任が配信されるポイントに従属しています。同様に、これはオープンに従属する既存のバイトレンジロックに対して発生します。"
    },
    {
      "indent": 0,
      "text": "10.5. Data Caching and Revocation",
      "section_title": true,
      "ja": "10.5. データキャッシュと失効"
    },
    {
      "indent": 3,
      "text": "When locks and delegations are revoked, the assumptions upon which successful caching depends are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding state-owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation that has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client's cache, that data must be removed from the client without being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting byte-range lock after the revocation of the byte-range lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.",
      "ja": "ロックと委任が取り消されると、キャッシングが成功したことの前提条件は保証されなくなりました。取り消されたロックまたは共有予約については、対応する状態所有者に通知する必要があります。この通知には、取り消された対応する委任を持つファイルを開くアプリケーションが含まれています。失効に関連したキャッシュデータはクライアントから削除する必要があります。クライアントのキャッシュに存在する修正データの場合、そのデータはサーバーに書き込まれずにクライアントから削除されなければなりません。前述のように、クライアントによって行われた仮定は、ロックまたは委任が失効された時点ではもはや有効ではありません。たとえば、最初のクライアントでのバイトレンジロックの失効後に別のクライアントが競合するバイトレンジロックが付与されている可能性があります。したがって、ロック範囲内のデータは他のクライアントによって変更されている可能性があります。明らかに、最初のクライアントは失効の場合にファイルに発生したものをアプリケーションに保証することができません。"
    },
    {
      "indent": 3,
      "text": "Notification to a state-owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification here is that an invariant on which an application depends may be violated. Depending on how errors are typically treated for the client-operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.",
      "ja": "多くの場合、状態の所有者への通知は、単に次の読み取り/書き込みのすべての読み取り/書き込みまたはクローズでエラーを返すだけで構成されます。特定の操作のエラーが返されない可能性があるため、クライアントがそのような通知を不可能にする場合、信号やプロセス終了などのより劇的な動作が適切である可能性があるため、そのような通知を不可能にする場合。ここでの正当化は、アプリケーションが依存する不変権に違反している可能性があります。エラーが通常クライアントオペレーティング環境のためにどのように扱われるかに応じて、ロギング、コンソールメッセージ、およびGUIのポップアップを含むさらなるレベルの通知が適切であり得る。"
    },
    {
      "indent": 0,
      "text": "10.5.1. Revocation Recovery for Write Open Delegation",
      "section_title": true,
      "ja": "10.5.1. 書き込みオープン委任の失効回復"
    },
    {
      "indent": 3,
      "text": "Revocation recovery for an OPEN_DELEGATE_WRITE delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client that does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.",
      "ja": "open_delegate_write委任の失効回復は、ファイルが開いていない間にクライアントキャッシュ内の変更されたデータの特別な問題を提起します。このような状況では、各クローズで変更されたデータをサーバーにフラッシュしないクライアントは、失効の結果としてユーザーが失敗の適切な通知を受け取ることを確認する必要があります。そのような状況は、問題を修正するために人間の処置を必要とし得るので、適切なユーザまたは管理者が通知される通知スキームが必要であり得る。ロギングメッセージとコンソールのメッセージは典型的な例です。"
    },
    {
      "indent": 3,
      "text": "If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system namespace to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of the file in question, such a saved copy of the client's view of the file may be of particular value for recovery. In another case, recovery using a copy of the file based partially on the client's cached data and partially on the server's copy as modified by other clients will be anything but straightforward, so clients may avoid saving file contents in these situations or specially mark the results to warn users of possible problems.",
      "ja": "クライアントにデータが変更されている場合は、サーバーに通常フラッシュしてはいけません。クライアントは、リカバリを容易にするために、ファイルシステムの名前空間の異なる名前で委任中に変更されたファイルデータのコピーを提供しようとすることがあります。クライアントが他のクライアントによってファイルが変更されていないことを判断した場合、またはクライアントが問題のファイルの完全なキャッシュされたコピーが完全になっている場合、そのファイルのクライアントのビューの保存されたコピーは特定の値である可能性があることに注意してください。回復のために。別の場合では、クライアントのキャッシュデータに部分的にベースに基づくファイルのコピーを使用したリカバリ、および他のクライアントによって変更されたサーバーのコピーに部分的には、まっすぐになりますので、クライアントはこれらの状況でファイルの内容を保存したり、結果を特別にマークしたりすることがある考えられる問題をユーザーに警告する。"
    },
    {
      "indent": 3,
      "text": "Saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target file system. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.",
      "ja": "委任失効状況におけるそのような修正されたデータの保存は、特定のサイズのファイルに制限されてもよく、またはターゲットファイルシステム内で十分なディスク容量が利用可能な場合にのみ使用されてもよい。このような保存は、クライアントがキャッシュされたコピーをターゲットファイルシステムに適切に保存されるまで利用できる十分なバッファリソースを持っている場合にも、状況に限定されます。"
    },
    {
      "indent": 0,
      "text": "10.6. Attribute Caching",
      "section_title": true,
      "ja": "10.6. 属性キャッシング"
    },
    {
      "indent": 3,
      "text": "This section pertains to the caching of a file's attributes on a client when that client does not hold a delegation on the file.",
      "ja": "このセクションは、クライアントがファイルに委任を保持していない場合のクライアント上のファイルの属性のキャッシュに関する。"
    },
    {
      "indent": 3,
      "text": "The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files, and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory (as well as the directory's contents) are to be cached on the same basis as any other pathnames.",
      "ja": "このセクションで説明されている属性には、名前付き属性は含まれていません。個々の名前付き属性はファイルに類似しており、データキャッシュが通常のファイル用の場合と同じように処理される必要がある必要があるデータのキャッシュ。同様に、OpenATTRディレクトリ（ディレクトリの内容）からのルックアップ結果は、他のパス名と同じベースでキャッシュされます。"
    },
    {
      "indent": 3,
      "text": "Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and should not be cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally, such changes are not propagated directly to the server, but when the modified data is flushed to the server, analogous attribute changes are made on the server. When OPEN delegation is in effect, the modified attributes may be returned to the server in reaction to a CB_RECALL call.",
      "ja": "クライアントは、サーバーから取得したファイル属性をキャッシュし、それらを使用して後続のGetAttr要求を回避することができます。そのようなキャッシュは、ファイル属性への変更が常にサーバへの要求によって行われ、ローカルに行われず、キャッシュされるべきではないという点で書き込みます。これに対する例外は、データキャッシュと密接に接続されている属性に対する変更です。したがって、ローカルデータキャッシュにデータを書き込むことによってファイルを拡張することは、この変更なしにクライアントにすぐにサーバーに反映されているようにすぐに反映されます。通常、このような変更はサーバーに直接伝達されませんが、変更されたデータがサーバーにフラッシュされている場合、サーバー上で類似の属性の変更が行われます。オープン委任が有効な場合、変更された属性はCB_Recall呼び出しと反応してサーバーに返される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on another client.",
      "ja": "属性のローカルキャッシングの結果は、個々のクライアントで維持されている属性キャッシュがコヒーレントではないことです。サーバー上の1つの順序で行われた変更は、1つのクライアント上で異なる順序で、別のクライアント上の3次で見ることができます。"
    },
    {
      "indent": 3,
      "text": "The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherencies mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.",
      "ja": "典型的なファイルシステムアプリケーションプログラミングインタフェースは、複数のファイルの属性を同時にアトミックに変更または尋問するための手段を提供しません。以下の規則は、上述した潜在的なインコヒーレンスを合理的に管理できる環境を提供する。これらの規則は、以前のNFSプロトコルの実践から導き出されます。"
    },
    {
      "indent": 3,
      "text": "* All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.",
      "ja": "* 特定のファイルのすべての属性（FSID属性ごとの属性）は、単一のファイルのコンテキスト内で発生しないように、クライアントの単位としてキャッシュされます。"
    },
    {
      "indent": 3,
      "text": "* An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.",
      "ja": "* 上位の境界は、サーバーから更新されずにクライアントキャッシュエントリをどのくらい保持できるかに維持されます。"
    },
    {
      "indent": 3,
      "text": "* When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client's cached attributes.",
      "ja": "* サーバーの属性を変更する操作が実行されると、更新された属性セットはChinuse RPCの一部として要求されます。これには、間接的に属性を更新するディレクトリ操作が含まれます。これは、GetAttrの動作を使用して変更操作を行ってからGetAttrの結果を使用してクライアントのキャッシュされた属性を更新することによって実現されます。"
    },
    {
      "indent": 3,
      "text": "Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.",
      "ja": "キャッシュされるべき属性のフルセットがREADDIRによって要求された場合、結果はgetAttrを介して取得された属性と同じベースでクライアントによってキャッシュされることができます。"
    },
    {
      "indent": 3,
      "text": "A client may validate its cached version of attributes for a file by fetching both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The reason why time_access is also fetched is because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call [15]. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.",
      "ja": "クライアントは、変更属性とtime_access属性の両方を取得し、属性がキャッシュされたときに変更されたのと同じ値を持つと、TIME_ACCESS以外の属性は変更されていないと仮定して、クライアントがファイルのキャッシュされたバージョンの属性を検証することができます。time_accessもフェッチされるのは、変更を更新する操作がtime_accessを更新しない環境で多くのサーバーが動作するためです。たとえば、POSIXファイルセマンティクスは、書き込みシステムコール[15]でファイルが変更されたときのアクセス時間を更新しません。したがって、現在のtime_access値を求めるクライアントは、属性キャッシュ検証処理中に変更を取得し、そのキャッシュされたtime_accessを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.",
      "ja": "クライアントは、修正された通常ファイルのデータと密接に接続された属性の修正された属性のキャッシュを維持することができる（サイズ、time_modify、および変更）。これら3つの属性以外に、クライアントは修正された属性のキャッシュを維持してはいけません。代わりに、属性の変更は直ちにサーバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed, and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since the client either would eventually have to write the access time to the server with bad performance effects or never update the server's time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a read that was satisfied by the server. This way clients will tend to see only time_access changes that go forward in time.",
      "ja": "一部のオペレーティング環境では、time_accessと同等のものは、ファイルオブジェクトのコンテンツの読み取りごとに暗黙的に更新されることが予想されます。 NFSクライアントがファイルオブジェクトのコンテンツをキャッシュしている場合は、通常のファイル、ディレクトリ、またはシンボリックリンクであろうと、クライアントは、それぞれのサーバー上のtime_access属性（SetAttrまたはReadDir要求を介して）更新しないでください。キャッシュから満足している読み取り。その理由は、特に明示的なsetAttrがサーバー上の変更属性を変更する可能性があるため、これはキャッシングコンテンツのパフォーマンス上の利点を倒す可能性があるためです。変更属性が変更された場合、コンテンツをキャッシュしているクライアントは、コンテンツが変更されたと思われ、サーバーから変更されていないデータを再読み出します。クライアントは、クライアントは、クライアントがパフォーマンス効果が悪いサーバーへのアクセス時間をサーバーに書き込むか、サーバーのTIME_ACCESSを更新することはできませんので、クライアントはそのキャッシュ内で修正されたバージョンを維持することをお勧めします。同じファイルの閉鎖と開放の間のアクセス時間をキャッシュすると、過去と現在の間のアクセス時間が発振します。 time_access属性は常にサーバーによって満たされた読み取りによってファイルへの最後のアクセスの時間を意味します。このようにクライアントは時間内に進むtime_accessの変更のみを見る傾向があります。"
    },
    {
      "indent": 0,
      "text": "10.7. Data and Metadata Caching and Memory Mapped Files",
      "section_title": true,
      "ja": "10.7. データとメタデータキャッシングとメモリマップファイル"
    },
    {
      "indent": 3,
      "text": "Some operating environments include the capability for an application to map a file's content into the application's address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application's address space).",
      "ja": "一部のオペレーティング環境には、アプリケーションのコンテンツをアプリケーションのアドレス空間にマッピングする機能が含まれます。アプリケーションがアドレス空間にロードされていないブロックに対応するメモリ位置にアクセスするたびに、ページ障害が発生し、ファイルが読み取られ（またはそのブロックがファイルに存在しない場合はそのブロックが割り当てられ、次にブロックが割り当てられている場合）アプリケーションのアドレス空間でインスタンス化されています）。"
    },
    {
      "indent": 3,
      "text": "As long as each memory-mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required, these attributes will not be updated on reads or updates to the file via memory access (regardless of whether the file is local or is accessed remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory-mapped I/O. This has several implications:",
      "ja": "ファイルへの各メモリマッピングアクセスがページ障害を必要とする限り、アクセスと変更を検出するために使用されるファイルの関連属性（time_access、time_metadata、time_modify、および変更）が更新されます。ただし、多くのオペレーティング環境では、ページフォルトが不要な場合、これらの属性はメモリアクセスを介してファイルの読み取りまたは更新で更新されません（ファイルがローカルかどうかにかかわらず、またはリモートでアクセスされます）。クライアントまたはサーバーは、メモリマップされたI / Oを介してアクセスされているファイルの属性を更新できません。これにはいくつかの意味があります。"
    },
    {
      "indent": 3,
      "text": "* If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether or not its cache is stale. A server that knows that the file is memory-mapped could always pessimistically return updated values for change so as to force the application to always get the most up-to-date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.",
      "ja": "* クライアントがアクセスしているファイルをメモリマッピングしているサーバーにアプリケーションがある場合、クライアントはCHANGE属性の一貫した値を取得してそのキャッシュが古くかどうかを判断できません。ファイルがマッピングされていることを知っているサーバーでは、アプリケーションにファイルの最新のデータとメタデータが常に最新のデータとメタデータを取得できるように、常に変更のために更新された値を返すことができます。しかしながら、これを否定的な性能の意味のために、そのような動作はオプションである。"
    },
    {
      "indent": 3,
      "text": "* If the memory-mapped file is not being modified on the server, and instead is just being read by an application via the memory-mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus, NFS clients are at no disadvantage with respect to local processes.",
      "ja": "* メモリマップファイルがサーバ上で変更されておらず、代わりにメモリマップインターフェイスを介してアプリケーションによって読み取られているだけで、クライアントは更新されたtime_access属性を表示しません。ただし、多くのオペレーティング環境では、サーバー上で実行されているプロセスもありません。したがって、NFSクライアントは局所プロセスに関して不利でない。"
    },
    {
      "indent": 3,
      "text": "* If there is another client that is memory mapping the file, and if that client is holding an OPEN_DELEGATE_WRITE delegation, the same set of issues as discussed in the previous two bullet points apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the reply from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client's obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client's memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory-mapped.",
      "ja": "* ファイルをマッピングする別のクライアントがある場合、およびそのクライアントがOpen_Delegate_Writeの委任を保持している場合は、前の2つの箇条書きポイントで説明したのと同じ一連の問題が適用されます。そのため、サーバーがCB_GETATTRをキャッシュで変更したファイルにCB_GETATTRを実行すると、CB_GETATTRからの応答は必ずしも正確ではありません。前述したように、クライアントの義務は、委任が付与されてから、連続するCB_GetATTR呼び出しの間で再度変更されたかどうかではなく、サーバーがキャッシュでクライアントが変更されたファイルがあれば、委任が許可されているため、ファイルが変更されたことを報告することです。連続するCB_GetATTR呼び出しの間に再度変更されました。クライアントのメモリ管理システムの性質に応じて、この弱い義務は不可能かもしれません。クライアントは、ファイルがメモリマップされているときはいつでもCB_GetAttrで古い情報を返すことがあります。"
    },
    {
      "indent": 3,
      "text": "* The mixture of memory mapping and byte-range locking on the same file is problematic. Consider the following scenario, where a page size on each client is 8192 bytes.",
      "ja": "* 同じファイル上のメモリマッピングとバイトレンジロックの混在は問題があります。次のシナリオを検討してください。各クライアントのページサイズは8192バイトです。"
    },
    {
      "indent": 6,
      "text": "- Client A memory maps the first page (8192 bytes) of file X.",
      "ja": "- クライアントメモリは、ファイルXの最初のページ（8192バイト）をマッピングします。"
    },
    {
      "indent": 6,
      "text": "- Client B memory maps the first page (8192 bytes) of file X.",
      "ja": "- クライアントBメモリファイルの最初のページ（8192バイト）をマップします。"
    },
    {
      "indent": 6,
      "text": "- Client A WRITE_LT locks the first 4096 bytes.",
      "ja": "- クライアントWrite_LTは最初の4096バイトをロックします。"
    },
    {
      "indent": 6,
      "text": "- Client B WRITE_LT locks the second 4096 bytes.",
      "ja": "- クライアントB WRITE_LTは、2番目の4096バイトをロックします。"
    },
    {
      "indent": 6,
      "text": "- Client A, via a STORE instruction, modifies part of its locked byte-range.",
      "ja": "- クライアントAは、ストア命令を介して、そのロックされたバイト範囲の一部を変更します。"
    },
    {
      "indent": 6,
      "text": "- Simultaneous to client A, client B executes a STORE on part of its locked byte-range.",
      "ja": "- クライアントAと同時に、クライアントBはそのロックされたバイト範囲の一部にストアを実行する。"
    },
    {
      "indent": 3,
      "text": "Here the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock byte-ranges has been modified. So it is not possible for each client to do the right thing, which is to write to the server only that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A's data is lost.",
      "ja": "ここでは、課題は、最初のページの正しいビューを取得するために再同期する各クライアントのための課題です。多くの動作環境では、各クライアント上の仮想メモリ管理システムは、それぞれのロックバイト範囲に対応するページのサブセットが変更されていないため、ページが変更されていることを知っている。したがって、各クライアントが正しいことを実行することは不可能です。これは、ロックされているページのその部分のみをサーバーに書き込むことです。たとえば、クライアントAが単純にページを書き出して、クライアントBはページを書き出し、クライアントAのデータが失われます。"
    },
    {
      "indent": 3,
      "text": "Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B execute the STORE instructions, the resulting page faults require a byte-range lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock. Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.",
      "ja": "さらに、ファイル上で必須のロックが有効になっている場合は、問題が異なります。クライアントAとBがストア命令を実行すると、結果のページ障害にはページ全体のバイトレンジロックが必要です。各クライアントは、ロックされた範囲をページ全体に拡張しようとします。これによりデッドロックが発生します。NFS4ERR_DEADLOCKエラーをストア命令に通信することは困難です。"
    },
    {
      "indent": 3,
      "text": "If a client is locking the entire memory-mapped file, there is no problem with advisory or mandatory byte-range locking, at least until the client unlocks a byte-range in the middle of the file.",
      "ja": "クライアントがメモリマップファイル全体をロックしている場合は、少なくともクライアントがファイルの途中でバイト範囲をロック解除するまで、アドバイザリまたは必須のバイトレンジロックに問題はありません。"
    },
    {
      "indent": 3,
      "text": "Given the above issues, the following are permitted:",
      "ja": "上記の問題を考えると、以下は許可されています。"
    },
    {
      "indent": 3,
      "text": "* Clients and servers MAY deny memory mapping a file for which they know there are byte-range locks.",
      "ja": "* クライアントとサーバーは、バイトレンジロックがあることを知っているファイルをマッピングするメモリを拒否できます。"
    },
    {
      "indent": 3,
      "text": "* Clients and servers MAY deny a byte-range lock on a file they know is memory-mapped.",
      "ja": "* クライアントとサーバーは、メモリマッピングされているファイルのバイトレンジロックを拒否できます。"
    },
    {
      "indent": 3,
      "text": "* A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.",
      "ja": "* クライアントは、I / Oのための必須ロックが必要なファイルをマッピングするメモリを拒否することができます。ファイルが開いてマップされた後に必須のロックが有効になっている場合、クライアントはアプリケーションがそのマップされたファイルにさらにアクセスすることを拒否できます。"
    },
    {
      "indent": 0,
      "text": "10.8. Name and Directory Caching without Directory Delegations",
      "section_title": true,
      "ja": "10.8. ディレクトリ名称なしの名前とディレクトリキャッシュ"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 directory delegation facility (described in Section 10.9 below) is OPTIONAL for servers to implement. Even where it is implemented, it may not always be functional because of resource availability issues or other constraints. Thus, it is important to understand how name and directory caching are done in the absence of directory delegations. These topics are discussed in the next two subsections.",
      "ja": "NFSv4.1ディレクトリ委任機能（以下のセクション10.9で説明されている）は、サーバーが実装するためのオプションです。実装されている場合でも、リソースの可用性の問題やその他の制約のために、必ずしも機能的ではないかもしれません。したがって、ディレクトリの委任がない場合にどのように名前とディレクトリのキャッシングが行われるかを理解することが重要です。これらのトピックについては、次の2つのサブセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "10.8.1. Name Caching",
      "section_title": true,
      "ja": "10.8.1. ネームキャッシング"
    },
    {
      "indent": 3,
      "text": "The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, an upper time boundary is maintained for how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.",
      "ja": "ルックアップおよびREADDIRの動作の結果は、後続のルックアップ操作のコストを回避するためにキャッシュされます。属性キャッシングの場合と同様に、さまざまなクライアントキャッシュの間で矛盾が発生する可能性があります。これらの矛盾の影響を軽減し、典型的なファイルシステムAPIのコンテキストを考えると、実行されたディレクトリ変更操作によってエントリが無効にされていないことを確認せずにクライアント名キャッシュエントリをどのくらい保持できるかについて上位の時間境界が維持されます。他のクライアントによって。"
    },
    {
      "indent": 3,
      "text": "When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.",
      "ja": "クライアントが存在しているディレクトリに存在するディレクトリを変更していない場合、クライアントはそのディレクトリの属性を定期的に取得して、変更されていないことを確認する必要があります。変更が発生していないと判断した後、関連する名前キャッシュエントリの有効期限は、現在の時間に名前キャッシュのStaliness Bundence Bunderを更新することができます。"
    },
    {
      "indent": 3,
      "text": "When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client has a basis for determining, given proper care, whether other clients are modifying the directory in question.",
      "ja": "クライアントが特定のディレクトリに変更を加えているときは、他のクライアントによってディレクトリに変更されたかどうかを判断する必要があります。これは、操作に返された関連Change_Info4値のディレクトリ操作の前後に報告された変更属性を使用することです。サーバは、change_info4データがディレクトリ操作に対してアトミックに提供されているかどうかをクライアントに通信することができます。変更値がアトミックに提供されている場合、クライアントは、他のクライアントが問題のディレクトリを変更しているかどうかにかかわらず、適切な注意を決定するための基礎を持ちます。"
    },
    {
      "indent": 3,
      "text": "The simplest way to enable the client to make this determination is for the client to serialize all changes made to a specific directory. When this is done, and the server provides before and after values of the change attribute atomically, the client can simply compare the after value of the change attribute from one operation on a directory with the before value on the subsequent operation modifying that directory. When these are equal, the client is assured that no other client is modifying the directory in question.",
      "ja": "クライアントがこの判断を実行できる最も簡単な方法は、クライアントが特定のディレクトリに加えられたすべての変更をシリアル化することです。これが行われ、サーバーが変更属性の値をアトミックにする前後にサーバーが提供すると、そのディレクトリを変更した後続の操作で、変更属性のAFTER値をディレクトリ上の1つの操作と比較して、そのディレクトリを変更します。これらが等しい場合、クライアントは他のクライアントが問題のディレクトリを変更していないことが保証されています。"
    },
    {
      "indent": 3,
      "text": "When such serialization is not used, and there may be multiple simultaneous outstanding operations modifying a single directory sent from a single client, making this sort of determination can be more complicated. If two such operations complete in a different order than they were actually performed, that might give an appearance consistent with modification being made by another client. Where this appears to happen, the client needs to await the completion of all such modifications that were started previously, to see if the outstanding before and after change numbers can be sorted into a chain such that the before value of one change number matches the after value of a previous one, in a chain consistent with this client being the only one modifying the directory.",
      "ja": "このような直列化が使用されておらず、単一のクライアントから送信された単一のディレクトリを修正する複数の同時優れた操作があり、この種の判断をより複雑にすることができる。2つのそのような操作が実際に実行されたとは異なる順序で完了した場合、それは別のクライアントによって変更されている変更と一致する外観を与える可能性があります。これが起こるように見える場合、クライアントは以前に開始されたすべての変更を待つ必要があります。このクライアントと一致するチェーン内の前の値の値は、ディレクトリを変更する唯一の1つです。"
    },
    {
      "indent": 3,
      "text": "In either of these cases, the client is able to determine whether the directory is being modified by another client. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout can be extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.",
      "ja": "どちらの場合も、クライアントはディレクトリが別のクライアントによって変更されているかどうかを判断できます。比較が別のクライアントによってディレクトリが更新されたことを示す場合、変更されたディレクトリに関連付けられている名前キャッシュはクライアントから消去されます。比較が変更されていないことを示していれば、ディレクトリ操作を反映するようにクライアント上で名前キャッシュを更新することができ、関連するタイムアウトを拡張することができます。運転後の変更値は、将来のChange_Info4の比較の基礎として保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "上記のシナリオによって実証されたように、名前キャッシュは、名前キャッシュ項目がキャッシュされた時点でディレクトリの変更属性を検査することによって、クライアントが名前キャッシュデータを再検証する必要がある。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがCHANGE_INFO4情報を適切かつ正しく使用するために、サーバーは前後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前後の値を原子的に報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないと仮定しないでください。"
    },
    {
      "indent": 0,
      "text": "10.8.2. Directory Caching",
      "section_title": true,
      "ja": "10.8.2. ディレクトリキャッシング"
    },
    {
      "indent": 3,
      "text": "The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:",
      "ja": "READDIR動作の結果は、後続のREADDIR動作を回避するために使用されてもよい。属性とネームキャッシングの場合と同様に、矛盾がさまざまなクライアントキャッシュの間で矛盾が生じる可能性があります。これらの矛盾の影響を軽減するために、典型的なファイルシステムAPIのコンテキストを考えると、次の規則に従うべきです。"
    },
    {
      "indent": 3,
      "text": "* Cached READDIR information for a directory that is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last READDIR that contributes to the cache.",
      "ja": "* 単一のReadDir操作で取得されていないディレクトリのキャッシュされたREADDIR情報は、常にディレクトリ内容の一貫したスナップショットである必要があります。これは、最初のREADDIRの前にgetattrを使用し、キャッシュに寄与する最後のREADDIRの後に決定されます。"
    },
    {
      "indent": 3,
      "text": "* An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.",
      "ja": "* 上限時間境界は、クライアントがキャッシュされた情報を再検証する前に、ディレクトリキャッシュエントリが有効であると見なされる時間の長さを示すために維持されます。"
    },
    {
      "indent": 3,
      "text": "The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.",
      "ja": "Revalidation Techniqueは、ネームキャッシングの場合に説明したところです。クライアントが問題のディレクトリを変更していない場合は、getAttrを使用してディレクトリの変更属性を確認してください。キャッシュエントリの有効期間は、これらのチェックポイントで拡張できます。クライアントがディレクトリを変更しているとき、クライアントは、ディレクトリを変更する他のクライアントがあるかどうかを判断するためにchange_info4データを使用する必要があります。他のクライアント変更が発生していないと判断された場合、クライアントは独自の変更を反映するようにそのディレクトリキャッシュを更新することができます。"
    },
    {
      "indent": 3,
      "text": "As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "前述のように、ディレクトリキャッシュは、ディレクトリがキャッシュされた時点でディレクトリの変更属性を検査することによって、クライアントがディレクトリキャッシュデータを再検証する必要がある。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがCHANGE_INFO4情報を適切かつ正しく使用するために、サーバーは前後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前後の値を原子的に報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないと仮定しないでください。"
    },
    {
      "indent": 0,
      "text": "10.9. Directory Delegations",
      "section_title": true,
      "ja": "10.9. ディレクトリ代表"
    },
    {
      "indent": 0,
      "text": "10.9.1. Introduction to Directory Delegations",
      "section_title": true,
      "ja": "10.9.1. ディレクトリ代理人の紹介"
    },
    {
      "indent": 3,
      "text": "Directory caching for the NFSv4.1 protocol, as previously described, is similar to file caching in previous versions. Clients typically cache directory information for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the directory has been updated. By caching attributes, clients reduce the number of GETATTR calls made to the server to validate attributes. Furthermore, frequently accessed files and directories, such as the current working directory, have their attributes cached on the client so that some NFS operations can be performed without having to make an RPC call. By caching name and inode information about most recently looked up entries in a Directory Name Lookup Cache (DNLC), clients do not need to send LOOKUP calls to the server every time these files are accessed.",
      "ja": "前述のように、NFSv4.1プロトコルのディレクトリキャッシングは、以前のバージョンのファイルキャッシュと似ています。クライアントは通常、クライアントによって決定された期間のディレクトリ情報をキャッシュします。定義済みのタイムアウトの最後に、クライアントはサーバーに照会して、ディレクトリが更新されたかどうかがわかります。属性をキャッシュすることで、クライアントはサーバーに加えられたGetAttr呼び出しの数を減らすために属性を検証します。さらに、現在の作業ディレクトリなどの頻繁にアクセスされるファイルやディレクトリには、RPC呼び出しを行わないことなく、いくつかのNFS操作を実行できるようにクライアントにキャッシュされます。ディレクトリ名検索キャッシュ（DNLC）内の最近検索されたエントリに関する名前とiノードの情報をキャッシュすることで、クライアントはこれらのファイルにアクセスするたびにサーバーに検索コールを送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "This caching approach works reasonably well at reducing network traffic in many environments. However, it does not address environments where there are numerous queries for files that do not exist. In these cases of \"misses\", the client sends requests to the server in order to provide reasonable application semantics and promptly detect the creation of new directory entries. Examples of high miss activity are compilation in software development environments. The current behavior of NFS limits its potential scalability and wide-area sharing effectiveness in these types of environments. Other distributed stateful file system architectures such as AFS and DFS have proven that adding state around directory contents can greatly reduce network traffic in high-miss environments.",
      "ja": "このキャッシングアプローチは、多くの環境でネットワークトラフィックを削減するのに適しています。ただし、存在しないファイルに多数のクエリがある環境には対処しません。「ミス」のこれらの場合、クライアントは合理的なアプリケーションセマンティクスを提供するためにサーバーに要求を送信し、新しいディレクトリエントリの作成を速やかに検出します。高いミス活動の例は、ソフトウェア開発環境におけるコンパイルです。NFSの現在の動作は、その潜在的なスケーラビリティとこれらのタイプの環境における広域共有有効性を制限します。AFSやDFSなどの他の分散ステートフルファイルシステムアーキテクチャは、ディレクトリ内容の周囲の状態を追加することが証明されています。"
    },
    {
      "indent": 3,
      "text": "Delegation of directory contents is an OPTIONAL feature of NFSv4.1. Directory delegations provide similar traffic reduction benefits as with file delegations. By allowing clients to cache directory contents (in a read-only fashion) while being notified of changes, the client can avoid making frequent requests to interrogate the contents of slowly-changing directories, reducing network traffic and improving client performance. It can also simplify the task of determining whether other clients are making changes to the directory when the client itself is making many changes to the directory and changes are not serialized.",
      "ja": "ディレクトリ内容の委任は、NFSV4.1のオプション機能です。ディレクトリの代表団は、ファイル委任と同様のトラフィック削減利益を提供します。変更が変更されている間にクライアントがディレクトリ内容を（読み取り専用の方法で）キャッシュできるようにすることで、クライアントはゆっくりと変更されたディレクトリの内容を尋問し、ネットワークトラフィックの削減とクライアントパフォーマンスの向上を頻繁に要求することができます。クライアント自体がディレクトリに多くの変更を加えて変更がシリアル化されていない場合、他のクライアントがディレクトリに変更を加えているかどうかを判断するタスクを簡素化することもできます。"
    },
    {
      "indent": 3,
      "text": "Directory delegations allow improved namespace cache consistency to be achieved through delegations and synchronous recalls, in the absence of notifications. In addition, if time-based consistency is sufficient, asynchronous notifications can provide performance benefits for the client, and possibly the server, under some common operating conditions such as slowly-changing and/or very large directories.",
      "ja": "ディレクトリ委任により、通知がない場合に、委任と同期リコールを通じて、名前空間キャッシュの一貫性が改善されることができます。さらに、時間ベースの一貫性が十分である場合、非同期通知は、ゆっくりと変化するディレクトリや非常に大きなディレクトリなどの一般的な動作条件下で、クライアント、および場合によってはサーバーにパフォーマンス上の利点を提供できます。"
    },
    {
      "indent": 0,
      "text": "10.9.2. Directory Delegation Design",
      "section_title": true,
      "ja": "10.9.2. ディレクトリ委任デザイン"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces the GET_DIR_DELEGATION (Section 18.39) operation to allow the client to ask for a directory delegation. The delegation covers directory attributes and all entries in the directory. If either of these change, the delegation will be recalled synchronously. The operation causing the recall will have to wait before the recall is complete. Any changes to directory entry attributes will not cause the delegation to be recalled.",
      "ja": "NFSV4.1では、クライアントがディレクトリ委任を要求できるようにするためのget_dir_delegation（セクション18.39）の操作を紹介します。委任はディレクトリ属性とディレクトリ内のすべてのエントリをカバーしています。これらの変更のどちらかが、委任が同期的に呼び出されます。リコールの原因となる操作は、リコールが完了する前に待機する必要があります。ディレクトリエントリ属性の変更は任意の委任を引き起こすことはありません。"
    },
    {
      "indent": 3,
      "text": "In addition to asking for delegations, a client can also ask for notifications for certain events. These events include changes to the directory's attributes and/or its contents. If a client asks for notification for a certain event, the server will notify the client when that event occurs. This will not result in the delegation being recalled for that client. The notifications are asynchronous and provide a way of avoiding recalls in situations where a directory is changing enough that the pure recall model may not be effective while trying to allow the client to get substantial benefit. In the absence of notifications, once the delegation is recalled the client has to refresh its directory cache; this might not be very efficient for very large directories.",
      "ja": "代議員を尋ねることに加えて、クライアントは特定のイベントの通知を求めることもできます。これらのイベントには、ディレクトリの属性および/またはその内容への変更が含まれます。クライアントが特定のイベントの通知を要求すると、そのイベントが発生したときにサーバーはクライアントに通知されます。これにより、委任がそのクライアントの呼び出されることはありません。通知は非同期であり、ディレクトリが十分に変化している状況では、クライアントが実質的な利益を得ることができるように効果的ではない可能性がある状況でのリコールを回避する方法を提供します。通知がない場合は、委任が呼び出されると、クライアントはそのディレクトリキャッシュを更新する必要があります。これは非常に大きなディレクトリに対してはあまり効率的ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The delegation is read-only and the client may not make changes to the directory other than by performing NFSv4.1 operations that modify the directory or the associated file attributes so that the server has knowledge of these changes. In order to keep the client's namespace synchronized with that of the server, the server will notify the delegation-holding client (assuming it has requested notifications) of the changes made as a result of that client's directory-modifying operations. This is to avoid any need for that client to send subsequent GETATTR or READDIR operations to the server. If a single client is holding the delegation and that client makes any changes to the directory (i.e., the changes are made via operations sent on a session associated with the client ID holding the delegation), the delegation will not be recalled. Multiple clients may hold a delegation on the same directory, but if any such client modifies the directory, the server MUST recall the delegation from the other clients, unless those clients have made provisions to be notified of that sort of modification.",
      "ja": "委任は読み取り専用であり、クライアントは、ディレクトリまたは関連するファイル属性を変更するNFSV4.1操作を実行すること以外のディレクトリを変更しない場合があります。サーバーがこれらの変更についての知識を持っているようにします。クライアントの名前空間をサーバーと同期させるために、サーバーは、そのクライアントのディレクトリ変更操作の結果として行われた変更の変更の委任保持クライアントに通知されます。これは、そのクライアントがその後のGetAttrまたはReadDir操作をサーバーに送信する必要がないようにすることです。単一のクライアントが委任を保持しており、そのクライアントがディレクトリに変更を加えている場合（すなわち、委任を保持しているクライアントIDに関連付けられたセッションで送信された操作で変更が行われます）、委任は呼び出されません。複数のクライアントが同じディレクトリ上の委任を保持することができますが、そのようなクライアントがディレクトリを変更した場合、サーバーはその種の変更の種類の通知を規定されていない限り、サーバーは他のクライアントからの委任を呼び出しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Delegations can be recalled by the server at any time. Normally, the server will recall the delegation when the directory changes in a way that is not covered by the notification, or when the directory changes and notifications have not been requested. If another client removes the directory for which a delegation has been granted, the server will recall the delegation.",
      "ja": "代表団はいつでもサーバーによって呼び出すことができます。通常、ディレクトリが通知によってカバーされていない方法で変更されたとき、またはディレクトリの変更と通知が要求されていないときに、サーバーは委任を呼び出します。別のクライアントが委任が許可されているディレクトリを削除した場合、サーバーは委任を思い出します。"
    },
    {
      "indent": 0,
      "text": "10.9.3. Attributes in Support of Directory Notifications",
      "section_title": true,
      "ja": "10.9.3. ディレクトリ通知をサポートする属性"
    },
    {
      "indent": 3,
      "text": "See Section 5.11 for a description of the attributes associated with directory notifications.",
      "ja": "ディレクトリ通知に関連した属性の説明については、セクション5.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.9.4. Directory Delegation Recall",
      "section_title": true,
      "ja": "10.9.4. ディレクトリの委任を思い出す"
    },
    {
      "indent": 3,
      "text": "The server will recall the directory delegation by sending a callback to the client. It will use the same callback procedure as used for recalling file delegations. The server will recall the delegation when the directory changes in a way that is not covered by the notification. However, the server need not recall the delegation if attributes of an entry within the directory change.",
      "ja": "サーバーはクライアントにコールバックを送信することによってディレクトリ委任を呼び出します。ファイルの委任を呼び出すために使用されるのと同じコールバック手順を使用します。ディレクトリが通知によってカバーされていない方法で変更されたときに、サーバーは委任を呼び出します。ただし、ディレクトリの変更内のエントリの属性が変更された場合、サーバーは委任を呼び出す必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the server notices that handing out a delegation for a directory is causing too many notifications to be sent out, it may decide to not hand out delegations for that directory and/or recall those already granted. If a client tries to remove the directory for which a delegation has been granted, the server will recall all associated delegations.",
      "ja": "サーバーがディレクトリの委任を引き出すことを通知している場合、通知が多すぎるために送信されることが多すぎると、そのディレクトリの代表団を配信することや/またはすでに付与されているものを思い出すことを決定することができます。委任が許可されているディレクトリを削除しようとすると、サーバーはすべての関連する委任を思い出されます。"
    },
    {
      "indent": 3,
      "text": "The implementation sections for a number of operations describe situations in which notification or delegation recall would be required under some common circumstances. In this regard, a similar set of caveats to those listed in Section 10.2 apply.",
      "ja": "多くの操作のための実装セクションは、いくつかの一般的な状況下で通知または委任リコールが必要とされる状況を説明しています。これに関して、セクション10.2に列挙されたものへの類似の警告セットが適用されます。"
    },
    {
      "indent": 3,
      "text": "* For CREATE, see Section 18.4.4.",
      "ja": "* 作成のために、18.4.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For LINK, see Section 18.9.4.",
      "ja": "* リンクの場合は、18.9.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For OPEN, see Section 18.16.4.",
      "ja": "* Openの場合は、18.16.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For REMOVE, see Section 18.25.4.",
      "ja": "* 削除の場合は、セクション18.25.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For RENAME, see Section 18.26.4.",
      "ja": "* 名前の変更については、18.26.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* For SETATTR, see Section 18.30.4.",
      "ja": "* SetAttrについては、18.30.4項を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.9.5. Directory Delegation Recovery",
      "section_title": true,
      "ja": "10.9.5. ディレクトリ委任の回復"
    },
    {
      "indent": 3,
      "text": "Recovery from client or server restart for state on regular files has two main goals: avoiding the necessity of breaking application guarantees with respect to locked files and delivery of updates cached at the client. Neither of these goals applies to directories protected by OPEN_DELEGATE_READ delegations and notifications. Thus, no provision is made for reclaiming directory delegations in the event of client or server restart. The client can simply establish a directory delegation in the same fashion as was done initially.",
      "ja": "クライアントまたはサーバーのリカバリ通常ファイルでの状態には2つの主な目標があります。ロックされたファイルに関して、クライアントにキャッシュされたアップデートの配信を拒否するアプリケーション保証の必要性を回避します。これらの目標は、Open_Delegate_Readの委任と通知によって保護されているディレクトリに適用されません。したがって、クライアントまたはサーバーの再起動時にディレクトリ委任を再生するための規定はありません。クライアントは、最初は行われたのと同じ方法で単純にディレクトリ委任を確立することができます。"
    },
    {
      "indent": 0,
      "text": "11. Multi-Server Namespace",
      "section_title": true,
      "ja": "11. マルチサーバーネームスペース"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 supports attributes that allow a namespace to extend beyond the boundaries of a single server. It is desirable that clients and servers support construction of such multi-server namespaces. Use of such multi-server namespaces is OPTIONAL; however, and for many purposes, single-server namespaces are perfectly acceptable. The use of multi-server namespaces can provide many advantages by separating a file system's logical position in a namespace from the (possibly changing) logistical and administrative considerations that cause a particular file system to be located on a particular server via a single network access path that has to be known in advance or determined using DNS.",
      "ja": "NFSV4.1は、名前空間が単一のサーバーの境界を超えて拡張できるようにする属性をサポートしています。クライアントとサーバーがそのようなマルチサーバーネームスペースの構築をサポートすることが望ましいです。そのようなマルチサーバーネームスペースの使用はオプションです。ただし、そして多くの目的のために、シングルサーバーの名前空間は完全に許容されています。マルチサーバーネームスペースの使用は、特定のファイルシステムを単一のネットワークアクセスパスを介して特定のサーバー上に特定のサーバーに配置される（おそらく変更された）ロジスティックおよび管理上の考慮事項の名前空間内のファイルシステムの論理位置を分離することで、多くの利点を提供できます。それは事前に知られていなければならないか、またはDNSを使用して決定されなければならない。"
    },
    {
      "indent": 0,
      "text": "11.1. Terminology",
      "section_title": true,
      "ja": "11.1. 用語"
    },
    {
      "indent": 3,
      "text": "In this section as a whole (i.e., within all of Section 11), the phrase \"client ID\" always refers to the 64-bit shorthand identifier assigned by the server (a clientid4) and never to the structure that the client uses to identify itself to the server (called an nfs_client_id4 or client_owner in NFSv4.0 and NFSv4.1, respectively). The opaque identifier within those structures is referred to as a \"client id string\".",
      "ja": "このセクション全体として（すなわち、セクション11の全部内）では、「クライアントID」というフレーズは、常にサーバによって割り当てられた64ビットの短縮識別子（クライアントID4）を参照し、クライアントが識別するために使用する構造を決して使用することはありません。それぞれサーバーに（それぞれNFSV4.0およびNFSv4.1ではそれぞれNFS_CLIENT_ID4またはCLIENT_OWNERと呼びます）。これらの構造内の不透明識別子は、「クライアントID文字列」と呼ばれる。"
    },
    {
      "indent": 0,
      "text": "11.1.1. Terminology Related to Trunking",
      "section_title": true,
      "ja": "11.1.1. トランキングに関連する用語"
    },
    {
      "indent": 3,
      "text": "It is particularly important to clarify the distinction between trunking detection and trunking discovery. The definitions we present are applicable to all minor versions of NFSv4, but we will focus on how these terms apply to NFS version 4.1.",
      "ja": "トランキング検出とトランキングの発見の間の区別を明確にすることが特に重要です。私たちが提示する定義は、NFSV4のすべてのマイナーバージョンに適用されますが、これらの用語がNFSバージョン4.1にどのように適用されているかに焦点を当てます。"
    },
    {
      "indent": 3,
      "text": "* Trunking detection refers to ways of deciding whether two specific network addresses are connected to the same NFSv4 server. The means available to make this determination depends on the protocol version, and, in some cases, on the client implementation.",
      "ja": "* トランキング検出とは、2つの特定のネットワークアドレスが同じNFSV4サーバに接続されているかどうかを決定する方法を指します。この決定を行うために利用可能な手段は、プロトコルのバージョン、および場合によってはクライアントの実装に依存します。"
    },
    {
      "indent": 6,
      "text": "In the case of NFS version 4.1 and later minor versions, the means of trunking detection are as described in this document and are available to every client. Two network addresses connected to the same server can always be used together to access a particular server but cannot necessarily be used together to access a single session. See below for definitions of the terms \"server-trunkable\" and \"session-trunkable\".",
      "ja": "NFSバージョン4.1以降のマイナーバージョンの場合、トランキング検出の手段はこの文書に記載されており、すべてのクライアントが利用可能です。同じサーバーに接続されている2つのネットワークアドレスを常に一緒に使用して特定のサーバーにアクセスできますが、必ずしも使用することはできません。「Server-Trunkable」と「Session-Trunkable」という用語の定義については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Trunking discovery is a process by which a client using one network address can obtain other addresses that are connected to the same server. Typically, it builds on a trunking detection facility by providing one or more methods by which candidate addresses are made available to the client, who can then use trunking detection to appropriately filter them.",
      "ja": "* Trunking Discoveryは、1つのネットワークアドレスを使用するクライアントが同じサーバーに接続されている他のアドレスを取得できるプロセスです。典型的には、候補アドレスがクライアントに利用可能にされる1つまたは複数の方法を提供することによって、トランキング検出を適切にフィルタリングすることができる1つまたは複数の方法を提供することによってトランキング検出機能を構築する。"
    },
    {
      "indent": 6,
      "text": "Despite the support for trunking detection, there was no description of trunking discovery provided in RFC 5661 [66], making it necessary to provide those means in this document.",
      "ja": "トランキング検出の支援にもかかわらず、RFC 5661で提供されているトランキング発見の説明はありませんでした。"
    },
    {
      "indent": 3,
      "text": "The combination of a server network address and a particular connection type to be used by a connection is referred to as a \"server endpoint\". Although using different connection types may result in different ports being used, the use of different ports by multiple connections to the same network address in such cases is not the essence of the distinction between the two endpoints used. This is in contrast to the case of port-specific endpoints, in which the explicit specification of port numbers within network addresses is used to allow a single server node to support multiple NFS servers.",
      "ja": "接続によって使用されるサーバネットワークアドレスと特定の接続タイプとの組み合わせは、「サーバエンドポイント」と呼ばれる。異なる接続タイプを使用すると、さまざまなポートが使用される可能性がありますが、そのような場合に同じネットワークアドレスへの複数の接続によるさまざまなポートの使用は、使用される2つのエンドポイント間の区別の本質ではありません。これは、ネットワークアドレス内のポート番号の明示的な指定が複数のNFSサーバーをサポートできるようにするために使用されるポート固有のエンドポイントの場合とは対照的です。"
    },
    {
      "indent": 3,
      "text": "Two network addresses connected to the same server are said to be server-trunkable. Two such addresses support the use of client ID trunking, as described in Section 2.10.5.",
      "ja": "同じサーバーに接続されている2つのネットワークアドレスがサーバートランクタブルと言われています。2つのそのようなアドレスは、セクション2.10.5で説明されているように、クライアントIDトランキングの使用をサポートしています。"
    },
    {
      "indent": 3,
      "text": "Two network addresses connected to the same server such that those addresses can be used to support a single common session are referred to as session-trunkable. Note that two addresses may be server-trunkable without being session-trunkable, and that, when two connections of different connection types are made to the same network address and are based on a single file system location entry, they are always session-trunkable, independent of the connection type, as specified by Section 2.10.5, since their derivation from the same file system location entry, together with the identity of their network addresses, assures that both connections are to the same server and will return server-owner information, allowing session trunking to be used.",
      "ja": "これらのアドレスを使用して単一の共通セッションをサポートできるように、同じサーバーに接続されている2つのネットワークアドレスをSession-Trunkableと呼びます。2つのアドレスがセッショントランクタブルになっていなくてもサーバートランク不能になる可能性があり、異なる接続タイプの2つの接続が同じネットワークアドレスに行われ、単一のファイルシステムの場所エントリに基づいている場合、それらは常にSession-Trunkableであることに注意してください。セクション2.10.5で指定されている接続タイプとは無関係に、同じファイルシステムの場所エントリからの派生がネットワークアドレスの識別と一緒に、両方の接続が同じサーバーへのものであり、サーバー所有者情報を返すことを保証します。セッションのトランキングを使用できるようにする。"
    },
    {
      "indent": 0,
      "text": "11.1.2. Terminology Related to File System Location",
      "section_title": true,
      "ja": "11.1.2. ファイルシステムの場所に関連する用語"
    },
    {
      "indent": 3,
      "text": "Regarding the terminology that relates to the construction of multi-server namespaces out of a set of local per-server namespaces:",
      "ja": "サーバーごとのセットごとの名前空間のセットからマルチサーバーネームスペースの構築に関連する用語については、次のようにします。"
    },
    {
      "indent": 3,
      "text": "* Each server has a set of exported file systems that may be accessed by NFSv4 clients. Typically, this is done by assigning each file system a name within the pseudo-fs associated with the server, although the pseudo-fs may be dispensed with if there is only a single exported file system. Each such file system is part of the server's local namespace, and can be considered as a file system instance within a larger multi-server namespace.",
      "ja": "* 各サーバーには、NFSV4クライアントがアクセスできるエクスポートされたファイルシステムのセットがあります。通常、これはサーバーに関連付けられている疑似FS内の各ファイルシステムを各ファイルシステムに割り当てることによって行われます。そのような各ファイルシステムはサーバーのローカルネームスペースの一部であり、より大きなマルチサーバーネームスペース内のファイルシステムインスタンスとして考慮することができます。"
    },
    {
      "indent": 3,
      "text": "* The set of all exported file systems for a given server constitutes that server's local namespace.",
      "ja": "* 特定のサーバーのすべてのエクスポートされたファイルシステムのセットは、そのサーバーのローカルネームスペースを構成します。"
    },
    {
      "indent": 3,
      "text": "* In some cases, a server will have a namespace more extensive than its local namespace by using features associated with attributes that provide file system location information. These features, which allow construction of a multi-server namespace, are all described in individual sections below and include referrals (Section 11.5.6), migration (Section 11.5.5), and replication (Section 11.5.4).",
      "ja": "* 場合によっては、サーバーは、ファイルシステムの場所情報を提供する属性に関連付けられている機能を使用して、そのローカルネームスペースよりも広範囲にわたる名前空間を持ちます。マルチサーバーネームスペースの構築を可能にするこれらの機能はすべて、以下の個々のセクションで説明されており、参照（11.5.6項）、移行（セクション11.5.5）、およびレプリケーションを含めます（セクション11.5.4）。"
    },
    {
      "indent": 3,
      "text": "* A file system present in a server's pseudo-fs may have multiple file system instances on different servers associated with it. All such instances are considered replicas of one another. Whether such replicas can be used simultaneously is discussed in Section 11.11.1, while the level of coordination between them (important when switching between them) is discussed in Sections 11.11.2 through 11.11.8 below.",
      "ja": "* サーバーの疑似FSに存在するファイルシステムは、それに関連する異なるサーバー上に複数のファイルシステムインスタンスを持つことができます。そのようなすべてのインスタンスは互いの複製と見なされます。そのようなレプリカを同時に使用できるかどうかは、11.11.1で同時に説明されているが、それらの間の調整レベル（それらを切り替えるとき）は下記のセクション11.11.2から11.11.8で説明されている。"
    },
    {
      "indent": 3,
      "text": "* When a file system is present in a server's pseudo-fs, but there is no corresponding local file system, it is said to be \"absent\". In such cases, all associated instances will be accessed on other servers.",
      "ja": "* ファイルシステムがサーバーの疑似FSに存在するが、対応するローカルファイルシステムがない場合は、「不在」と言われています。そのような場合、関連付けられているすべてのインスタンスは他のサーバーでアクセスされます。"
    },
    {
      "indent": 3,
      "text": "Regarding the terminology that relates to attributes used in trunking discovery and other multi-server namespace features:",
      "ja": "トランキングディスカバリおよびその他のマルチサーバーネームスペース機能に使用される属性に関連する用語については、次のようにします。"
    },
    {
      "indent": 3,
      "text": "* File system location attributes include the fs_locations and fs_locations_info attributes.",
      "ja": "* ファイルシステムの場所属性には、FS_LOCATIONSとFS_LOCATIONS_INFO属性が含まれます。"
    },
    {
      "indent": 3,
      "text": "* File system location entries provide the individual file system locations within the file system location attributes. Each such entry specifies a server, in the form of a hostname or an address, and an fs name, which designates the location of the file system within the server's local namespace. A file system location entry designates a set of server endpoints to which the client may establish connections. There may be multiple endpoints because a hostname may map to multiple network addresses and because multiple connection types may be used to communicate with a single network address. However, except where explicit port numbers are used to designate a set of servers within a single server node, all such endpoints MUST designate a way of connecting to a single server. The exact form of the location entry varies with the particular file system location attribute used, as described in Section 11.2.",
      "ja": "* ファイルシステムの場所エントリは、ファイルシステムの場所属性内の個々のファイルシステムの場所を提供します。そのような各エントリは、サーバーのローカルネームスペース内のファイルシステムの場所を指定する、ホスト名またはアドレスの形式でサーバーを指定します。ファイルシステムの場所エントリは、クライアントが接続を確立できるサーバエンドポイントのセットを指定する。ホスト名は複数のネットワークアドレスにマッピングされる可能性があるため、複数の接続タイプを使用して単一のネットワークアドレスと通信することができるため、複数のエンドポイントがある可能性があります。ただし、明示的なポート番号が単一のサーバーノード内のサーバーのセットを指定するために使用される場合を除き、そのようなエンドポイントはすべて単一のサーバーへの接続方法を指定する必要があります。位置エントリの正確な形式は、セクション11.2に記載されているように、使用される特定のファイルシステムの場所属性によって異なります。"
    },
    {
      "indent": 6,
      "text": "The network addresses used in file system location entries typically appear without port number indications and are used to designate a server at one of the standard ports for NFS access, e.g., 2049 for TCP or 20049 for use with RPC-over-RDMA. Port numbers may be used in file system location entries to designate servers (typically user-level ones) accessed using other port numbers. In the case where network addresses indicate trunking relationships, the use of an explicit port number is inappropriate since trunking is a relationship between network addresses. See Section 11.5.2 for details.",
      "ja": "ファイルシステムの場所エントリで使用されるネットワークアドレスは通常、ポート番号の表示なしで表示され、RPC-Over-RDMAで使用するためのTCPまたは20049の場合は、NFSアクセスのためのNFSアクセスの標準ポートの1つにサーバーを指定するために使用されます。ポート番号は、ファイルシステムの場所エントリで使用して、他のポート番号を使用してアクセスされるサーバー（通常はユーザーレベルのもの）を指定できます。ネットワークアドレスがトランキング関係を示す場合、トランクはネットワークアドレス間の関係であるため、明示的なポート番号の使用は不適切です。詳細は11.5.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* File system location elements are derived from location entries, and each describes a particular network access path consisting of a network address and a location within the server's local namespace. Such location elements need not appear within a file system location attribute, but the existence of each location element derives from a corresponding location entry. When a location entry specifies an IP address, there is only a single corresponding location element. File system location entries that contain a hostname are resolved using DNS, and may result in one or more location elements. All location elements consist of a location address that includes the IP address of an interface to a server and an fs name, which is the location of the file system within the server's local namespace. The fs name can be empty if the server has no pseudo-fs and only a single exported file system at the root filehandle.",
      "ja": "* ファイルシステムの場所要素は場所エントリから派生し、それぞれはネットワークアドレスとサーバーのローカルネームスペース内の場所からなる特定のネットワークアクセスパスを記述します。そのような場所要素はファイルシステムの場所属性内に表示される必要はなく、各ロケーション要素の存在は対応する場所エントリから派生します。Location EntryがIPアドレスを指定すると、単一の対応するロケーション要素があります。ファイルシステムの場所ホスト名を含むエントリは、DNSを使用して解決され、1つ以上の位置要素になる可能性があります。すべての場所要素は、サーバーへのインターフェイスのIPアドレスとFS名を含む位置アドレスで構成されています。これは、サーバーのローカルネームスペース内のファイルシステムの場所です。サーバーに疑似FSがない場合は、FS名を空にし、ルートファイルハンドルに1つのエクスポートされたファイルシステムだけがあります。"
    },
    {
      "indent": 3,
      "text": "* Two file system location elements are said to be server-trunkable if they specify the same fs name and the location addresses are such that the location addresses are server-trunkable. When the corresponding network paths are used, the client will always be able to use client ID trunking, but will only be able to use session trunking if the paths are also session-trunkable.",
      "ja": "* 2つのファイルシステムの場所要素は、同じFS名を指定し、位置アドレスがServer-Trunkableになるようなものである場合、サーバートランク不能と言われています。対応するネットワークパスが使用されている場合、クライアントは常にクライアントIDのトランキングを使用できますが、パスがセッショントランク不能の場合にのみセッショントランキングを使用できます。"
    },
    {
      "indent": 3,
      "text": "* Two file system location elements are said to be session-trunkable if they specify the same fs name and the location addresses are such that the location addresses are session-trunkable. When the corresponding network paths are used, the client will be able to able to use either client ID trunking or session trunking.",
      "ja": "* 2つのファイルシステムの場所要素は、同じFS名を指定し、位置アドレスがSession-Trunkableになるようなものである場合、Session-Trunkableと言われています。対応するネットワークパスが使用されている場合、クライアントはクライアントIDのトランキングまたはセッションのトランキングを使用できるようになります。"
    },
    {
      "indent": 3,
      "text": "Discussion of the term \"replica\" is complicated by the fact that the term was used in RFC 5661 [66] with a meaning different from that used in this document. In short, in [66] each replica is identified by a single network access path, while in the current document, a set of network access paths that have server-trunkable network addresses and the same root-relative file system pathname is considered to be a single replica with multiple network access paths.",
      "ja": "「レプリカ」という用語の説明は、この用語がRFC 5661で使用されていることが、この文書で使用されているものとは異なる意味で使用されたという事実によって複雑になります。要するに、[66]各レプリカは単一のネットワークアクセスパスによって識別され、現在の文書では、サーバトランクタブルネットワークアドレスと同じルート相対ファイルシステムパス名がある一連のネットワークアクセスパスがあると見なされます。複数のネットワークアクセスパスを持つ単一のレプリカ。"
    },
    {
      "indent": 3,
      "text": "Each set of server-trunkable location elements defines a set of available network access paths to a particular file system. When there are multiple such file systems, each of which containing the same data, these file systems are considered replicas of one another. Logically, such replication is symmetric, since the fs currently in use and an alternate fs are replicas of each other. Often, in other documents, the term \"replica\" is not applied to the fs currently in use, despite the fact that the replication relation is inherently symmetric.",
      "ja": "各セットのサーバートランクオブロケーション要素は、特定のファイルシステムへの利用可能なネットワークアクセスパスのセットを定義します。同じデータを含むそのようなファイルシステムが複数ある場合、これらのファイルシステムは互いのレプリカと見なされます。論理的には、そのようなレプリケーションは、現在使用中のFSと代替FSが互いのレプリカであるため、対称的です。多くの場合、他の文書では、レプリケーション関係が本質的に対称的であるという事実にもかかわらず、「レプリカ」という用語は現在使用されているFSには適用されない。"
    },
    {
      "indent": 0,
      "text": "11.2. File System Location Attributes",
      "section_title": true,
      "ja": "11.2. ファイルシステムの場所属性"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 contains attributes that provide information about how a given file system may be accessed (i.e., at what network address and namespace position). As a result, file systems in the namespace of one server can be associated with one or more instances of that file system on other servers. These attributes contain file system location entries specifying a server address target (either as a DNS name representing one or more IP addresses or as a specific IP address) together with the pathname of that file system within the associated single-server namespace.",
      "ja": "NFSV4.1には、特定のファイルシステムにアクセスされる方法に関する情報（すなわち、どのネットワークアドレスと名前空間位置）に関する情報を提供する属性が含まれています。その結果、1つのサーバーのネームスペース内のファイルシステムを他のサーバー上のそのファイルシステムの1つ以上のインスタンスに関連付けることができます。これらの属性には、サーバーアドレスターゲットを指定するファイルシステムの場所エントリが含まれています（1つ以上のIPアドレスを表すDNS名として、または特定のIPアドレスとして、または特定のIPアドレスとして）、関連するシングルサーバーネームスペース内のそのファイルシステムのパス名と一緒になります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info RECOMMENDED attribute allows specification of one or more file system instance locations where the data corresponding to a given file system may be found. In addition to the specification of file system instance locations, this attribute provides helpful information to do the following:",
      "ja": "fs_locations_info推奨属性により、特定のファイルシステムに対応するデータが見つかるかもしれない1つ以上のファイルシステムインスタンスの場所の指定が可能になります。ファイルシステムインスタンスの場所の仕様に加えて、この属性は次のことを行うために役立つ情報を提供します。"
    },
    {
      "indent": 3,
      "text": "* Guide choices among the various file system instances provided (e.g., priority for use, writability, currency, etc.).",
      "ja": "* 提供される各種ファイルシステムインスタンス（例えば、使用、書き込み可能性、通貨など）の選択"
    },
    {
      "indent": 3,
      "text": "* Help the client efficiently effect as seamless a transition as possible among multiple file system instances, when and if that should be necessary.",
      "ja": "* クライアントが複数のファイルシステムインスタンスの間でできるだけシームレスな遷移として効率的に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "* Guide the selection of the appropriate connection type to be used when establishing a connection.",
      "ja": "* 接続を確立するときに使用する適切な接続タイプの選択をガイドします。"
    },
    {
      "indent": 3,
      "text": "Within the fs_locations_info attribute, each fs_locations_server4 entry corresponds to a file system location entry: the fls_server field designates the server, and the fl_rootpath field of the encompassing fs_locations_item4 gives the location pathname within the server's pseudo-fs.",
      "ja": "fs_locations_info属性内では、各FS_LOCATIONS_SERVER4エントリはファイルシステムの場所エントリに対応します.FLS_SERVERフィールドはサーバーを指定し、包含するFS_LOCATIONS_ITEM4のFL_ROOTPATHフィールドはサーバーの疑似FS内の位置パス名を示します。"
    },
    {
      "indent": 3,
      "text": "The fs_locations attribute defined in NFSv4.0 is also a part of NFSv4.1. This attribute only allows specification of the file system locations where the data corresponding to a given file system may be found. Servers SHOULD make this attribute available whenever fs_locations_info is supported, but client use of fs_locations_info is preferable because it provides more information.",
      "ja": "NFSv4.0で定義されているFS_LOCATIONATION属性もNFSV4.1の一部です。この属性は、特定のファイルシステムに対応するデータが見つかることができるファイルシステムの場所の指定のみを可能にします。サーバーは、FS_LOCATIONS_INFOがサポートされているときはいつでもこの属性を使用可能にする必要がありますが、FS_LOCATIONS_INFOのクライアント使用はより多くの情報を提供するため好ましいです。"
    },
    {
      "indent": 3,
      "text": "Within the fs_locations attribute, each fs_location4 contains a file system location entry with the server field designating the server and the rootpath field giving the location pathname within the server's pseudo-fs.",
      "ja": "fs_locations属性内では、各FS_LOCATIOS4には、サーバーフィールドとRootPathフィールドを指定したファイルシステムの場所エントリが含まれています。"
    },
    {
      "indent": 0,
      "text": "11.3. File System Presence or Absence",
      "section_title": true,
      "ja": "11.3. ファイルシステムの有無"
    },
    {
      "indent": 3,
      "text": "A given location in an NFSv4.1 namespace (typically but not necessarily a multi-server namespace) can have a number of file system instance locations associated with it (via the fs_locations or fs_locations_info attribute). There may also be an actual current file system at that location, accessible via normal namespace operations (e.g., LOOKUP). In this case, the file system is said to be \"present\" at that position in the namespace, and clients will typically use it, reserving use of additional locations specified via the location-related attributes to situations in which the principal location is no longer available.",
      "ja": "NFSV4.1ネームスペース内の特定の場所（通常は必ずしもマルチサーバーネームスペースではありません）には、（FS_LOCATIONSまたはFS_LOCATIONS_INFO属性を介して）関連付けられているファイルシステムインスタンスの場所がいくつかあります。その場所に実際の現在のファイルシステムがあるかもしれません。通常のネームスペース操作（例えば、ルックアップ）を介してアクセスできます。この場合、ファイルシステムはネームスペース内のその位置で「存在する」と言われており、クライアントは通常それを使用し、ロケーション関連の属性を介して指定された追加の場所の使用を担当します。利用可能です。"
    },
    {
      "indent": 3,
      "text": "When there is no actual file system at the namespace location in question, the file system is said to be \"absent\". An absent file system contains no files or directories other than the root. Any reference to it, except to access a small set of attributes useful in determining alternate locations, will result in an error, NFS4ERR_MOVED. Note that if the server ever returns the error NFS4ERR_MOVED, it MUST support the fs_locations attribute and SHOULD support the fs_locations_info and fs_status attributes.",
      "ja": "問題のネームスペース場所に実際のファイルシステムがない場合、ファイルシステムは「不在」と言われています。不在なファイルシステムには、ルート以外のファイルやディレクトリが含まれていません。代替位置を決定するのに役立つ小さい属性セットにアクセスすることを除いて、それを参照して、エラー、NFS4ERR_MOVEDが発生します。サーバーがエラーNFS4ERR_MOUDを返す場合は、FS_LOCATIONS属性をサポートし、FS_LOCATIONS_INFOおよびFS_STATUS属性をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "While the error name suggests that we have a case of a file system that once was present, and has only become absent later, this is only one possibility. A position in the namespace may be permanently absent with the set of file system(s) designated by the location attributes being the only realization. The name NFS4ERR_MOVED reflects an earlier, more limited conception of its function, but this error will be returned whenever the referenced file system is absent, whether it has moved or not.",
      "ja": "エラー名は、かつて存在していたファイルシステムの場合があることを示唆しており、後で存在しないだけですが、これは1つの可能性だけです。ネームスペース内の位置は、位置属性によって指定されたファイルシステムのセットが唯一の実現であることで恒久的に存在していてもよい。NFS4ERR_MOVEDという名前は、その関数の早い、より限定的な概念を反映していますが、このエラーは参照されているファイルシステムが移動しているかどうかはいつでも返されます。"
    },
    {
      "indent": 3,
      "text": "Except in the case of GETATTR-type operations (to be discussed later), when the current filehandle at the start of an operation is within an absent file system, that operation is not performed and the error NFS4ERR_MOVED is returned, to indicate that the file system is absent on the current server.",
      "ja": "後述するGetAttr型の操作（後述）の場合を除いて、操作開始時の現在のファイルハンドルが存在しないファイルシステム内にある場合、その操作は実行されず、エラーNFS4ERR_MOVEDが返され、ファイルが表示されます。システムは現在のサーバーにはありません。"
    },
    {
      "indent": 3,
      "text": "Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.",
      "ja": "現在のFileHandleが不在なファイルシステム内にある場合、GETFHは成功できないため、不在なファイルシステム内のファイルハンドルをクライアントに転送できません。不在のファイルシステム内にクライアントがファイルハンドルを持つと、ファイルシステムが存在していたときにそれらを取得し、その後ファイルシステムが存在しない結果です。"
    },
    {
      "indent": 3,
      "text": "It should be noted that because the check for the current filehandle being within an absent file system happens at the start of every operation, operations that change the current filehandle so that it is within an absent file system will not result in an error. This allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be used to get attribute information, particularly location attribute information, as discussed below.",
      "ja": "現在のファイルシステム内のチェックが存在しないファイルシステム内にあるチェックは、すべての操作の開始時に行われるため、現在のファイルハンドルを変更する操作は、存在しないファイルシステム内にあるため、エラーが発生しません。これにより、putfh-getAttrとlookup-getAttrとの組み合わせが、後述するように、属性情報、特に位置属性情報を取得するために使用されることができます。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED file system attribute fs_status can be used to interrogate the present/absent status of a given file system.",
      "ja": "推奨されるファイルシステム属性FS_Statusを使用して、特定のファイルシステムの現在/欠席状況を問い合わせることができます。"
    },
    {
      "indent": 0,
      "text": "11.4. Getting Attributes for an Absent File System",
      "section_title": true,
      "ja": "11.4. ファイルシステムが不在の属性を取得する"
    },
    {
      "indent": 3,
      "text": "When a file system is absent, most attributes are not available, but it is necessary to allow the client access to the small set of attributes that are available, and most particularly those that give information about the correct current locations for this file system: fs_locations and fs_locations_info.",
      "ja": "ファイルシステムが存在しない場合、ほとんどの属性は利用できませんが、利用可能な小さな属性のセットにクライアントアクセスを許可する必要があります。これは、このファイルシステムの正しい現在地に関する情報を提供するものです.FS_LOCATIONSそしてfs_locations_info。"
    },
    {
      "indent": 0,
      "text": "11.4.1. GETATTR within an Absent File System",
      "section_title": true,
      "ja": "11.4.1. 欠勤システム内のgetAttr"
    },
    {
      "indent": 3,
      "text": "As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least one attribute bit that indicates the client is interested in a result regarding an absent file system: fs_locations, fs_locations_info, or fs_status. If none of these attributes is requested, GETATTR will result in an NFS4ERR_MOVED error.",
      "ja": "上述のように、不在のファイルシステム内のファイルハンドルに対して属性が得られることがあるという点では、getATTRについて例外がなされている。この例外は、属性マスクに、クライアントが存在しないファイルシステム：FS_LOCATIONS、FS_LOCATIONS_INFO、またはFS_STATUSに関する結果に関心があることを示す少なくとも1つの属性ビットが含まれている場合にのみ適用されます。これらの属性が要求されていない場合、getAttrはNFS4ERR_MOUDエラーになります。"
    },
    {
      "indent": 3,
      "text": "When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the attributes mentioned above (fs_locations, fs_locations_info, fs_status), the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.",
      "ja": "japenttrが存在しないファイルシステムで行われると、サポートされている属性のセットは非常に制限されています。通常必須のものを含む多くの属性は、不在なファイルシステムでは利用できません。上記の属性（FS_LOCATIONS、FS_LOCATIONS_INFO、FS_STATUS）に加えて、ファイルシステムが不在の属性を使用できます。推奨される属性の場合、それらは現在のファイルシステムで利用可能であると少なくとも同じ程度に利用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "change_policy: This attribute is useful for absent file systems and can be helpful in summarizing to the client when any of the location-related attributes change.",
      "ja": "change_policy：この属性は、不在のファイルシステムに役立ち、ロケーション関連の属性のいずれかが変更されたときにクライアントに要約するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "fsid: This attribute should be provided so that the client can determine file system boundaries, including, in particular, the boundary between present and absent file systems. This value must be different from any other fsid on the current server and need have no particular relationship to fsids on any particular destination to which the client might be directed.",
      "ja": "FSID：この属性は、クライアントが、特に現在のファイルシステムと不在の境界を含むファイルシステムの境界を決定できるようにする必要があります。この値は、現在のサーバー上の他のどのFSIDとは異なり、クライアントが指示される可能性がある特定の宛先のFSIDとは特に関係ありません。"
    },
    {
      "indent": 3,
      "text": "mounted_on_fileid: For objects at the top of an absent file system, this attribute needs to be available. Since the fileid is within the present parent file system, there should be no need to reference the absent file system to provide this information.",
      "ja": "MACKIT_ON_FILEID：存在しないファイルシステムの上部のオブジェクトの場合、この属性は利用可能である必要があります。fileIDは現在の親ファイルシステム内にあるため、この情報を提供するために不在のファイルシステムを参照する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Other attributes SHOULD NOT be made available for absent file systems, even when it is possible to provide them. The server should not assume that more information is always better and should avoid gratuitously providing additional information.",
      "ja": "他の属性は、それらを提供することが可能であっても、不在のファイルシステムに対して利用可能にされないでください。サーバーは、より多くの情報が常に良くなっていると仮定しておくべきではなく、追加情報を追加することを避けるべきです。"
    },
    {
      "indent": 3,
      "text": "When a GETATTR operation includes a bit mask for one of the attributes fs_locations, fs_locations_info, or fs_status, but where the bit mask includes attributes that are not supported, GETATTR will not return an error, but will return the mask of the actual attributes supported with the results.",
      "ja": "GetAttrの操作には、属性fs_locations、fs_locations_info、またはfs_statusのうちの1つのビットマスクが含まれていますが、ビットマスクにサポートされていない属性が含まれている場合、GetAttrはエラーを返しませんが、でサポートされている実際の属性のマスクは返されません。結果。"
    },
    {
      "indent": 3,
      "text": "Handling of VERIFY/NVERIFY is similar to GETATTR in that if the attribute mask does not include fs_locations, fs_locations_info, or fs_status, the error NFS4ERR_MOVED will result. It differs in that any appearance in the attribute mask of an attribute not supported for an absent file system (and note that this will include some normally REQUIRED attributes) will also cause an NFS4ERR_MOVED result.",
      "ja": "verify / nverifyの処理は、属性マスクにFS_LOCATIONS、FS_LOCATIONS_INFO、またはFS_STATUSが含まれていない場合、Error NFS4ERR_MOVEDが生じるという点で、GetAttrと似ています。存在しないファイルシステムではサポートされていない属性の属性マスク内の外観が異なります（そしてこれには通常必要な属性がいくつか含まれます）もNFS4ERR_MOVED結果を引き起こします。"
    },
    {
      "indent": 0,
      "text": "11.4.2. READDIR and Absent File Systems",
      "section_title": true,
      "ja": "11.4.2. READDIRと不在のファイルシステム"
    },
    {
      "indent": 3,
      "text": "A READDIR performed when the current filehandle is within an absent file system will result in an NFS4ERR_MOVED error, since, unlike the case of GETATTR, no such exception is made for READDIR.",
      "ja": "現在のFileHandleが存在しないファイルシステム内にあるときに実行されるREADDIRは、GetAttrの場合とは異なり、READDIRに対してそのような例外は行われません。"
    },
    {
      "indent": 3,
      "text": "Attributes for an absent file system may be fetched via a READDIR for a directory in a present file system, when that directory contains the root directories of one or more absent file systems. In this case, the handling is as follows:",
      "ja": "欠勤のファイルシステムの属性は、現在のファイルシステム内のディレクトリに対してREADDIRを介してフェッチされ、そのディレクトリが1つ以上の不在のファイルシステムのルートディレクトリを含む場合には、そのディレクトリを使用することができます。この場合、取り扱いは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* If the attribute set requested includes one of the attributes fs_locations, fs_locations_info, or fs_status, then fetching of attributes proceeds normally and no NFS4ERR_MOVED indication is returned, even when the rdattr_error attribute is requested.",
      "ja": "* 要求された属性セットに属性fs_locations、fs_locations_info、またはfs_statusのうちの1つが含まれている場合、属性の取得は正常に進み、RDATTR_ERROR属性が要求されていても、NFS4ERR_MOVED表示は返されません。"
    },
    {
      "indent": 3,
      "text": "* If the attribute set requested does not include one of the attributes fs_locations, fs_locations_info, or fs_status, then if the rdattr_error attribute is requested, each directory entry for the root of an absent file system will report NFS4ERR_MOVED as the value of the rdattr_error attribute.",
      "ja": "* 要求された属性セットに属性fs_locations、fs_locations_info、またはfs_statusが含まれていない場合、rdattr_error属性が要求されている場合、存在しないファイルシステムのルートの各ディレクトリエントリは、rdattr_error属性の値としてNFS4ERR_MOUDを報告します。"
    },
    {
      "indent": 3,
      "text": "* If the attribute set requested does not include any of the attributes fs_locations, fs_locations_info, fs_status, or rdattr_error, then the occurrence of the root of an absent file system within the directory will result in the READDIR failing with an NFS4ERR_MOVED error.",
      "ja": "* 要求された属性セットに属性fs_locations、fs_locations_info、fs_status、またはrdattr_errorのいずれも含まれていない場合、ディレクトリ内の存在しないファイルシステムのルートの発生は、READDIRがNFS4ERR_VOVEDエラーで障害が発生します。"
    },
    {
      "indent": 3,
      "text": "* The unavailability of an attribute because of a file system's absence, even one that is ordinarily REQUIRED, does not result in any error indication. The set of attributes returned for the root directory of the absent file system in that case is simply restricted to those actually available.",
      "ja": "* ファイルシステムの欠席のために、属性の使用不可は、通常必須のものでもエラー表示をもたらさない。その場合の不在のファイルシステムのルートディレクトリに対して返される一連の属性は、実際に利用可能なものに限定されます。"
    },
    {
      "indent": 0,
      "text": "11.5. Uses of File System Location Information",
      "section_title": true,
      "ja": "11.5. ファイルシステムの位置情報の使用"
    },
    {
      "indent": 3,
      "text": "The file system location attributes (i.e., fs_locations and fs_locations_info), together with the possibility of absent file systems, provide a number of important facilities for reliable, manageable, and scalable data access.",
      "ja": "ファイルシステムの場所属性（すなわち、FS_LOCATIONSATIONSおよびFS_LOCATIONS_INFO）は、存在しないファイルシステムの可能性とともに、信頼性の高い、管理可能でスケーラブルなデータアクセスのためにいくつかの重要な機能を提供します。"
    },
    {
      "indent": 3,
      "text": "When a file system is present, these attributes can provide the following:",
      "ja": "ファイルシステムが存在する場合、これらの属性は次のようになります。"
    },
    {
      "indent": 3,
      "text": "* The locations of alternative replicas to be used to access the same data in the event of server failures, communications problems, or other difficulties that make continued access to the current replica impossible or otherwise impractical. Provisioning and use of such alternate replicas is referred to as \"replication\" and is discussed in Section 11.5.4 below.",
      "ja": "* サーバーの障害、通信の問題、または現在のレプリカへの継続的なアクセスが不可能であるか、または実用的ではない困難さが発生した場合に同じデータにアクセスするために使用される代替レプリカの場所。そのような代替レプリカのプロビジョニングおよび使用は「複製」と呼ばれ、以下の11.5.4項で論じられている。"
    },
    {
      "indent": 3,
      "text": "* The network address(es) to be used to access the current file system instance or replicas of it. Client use of this information is discussed in Section 11.5.2 below.",
      "ja": "* 現在のファイルシステムインスタンスまたはレプリカにアクセスするために使用されるネットワークアドレス。この情報のクライアントの使用については、下記の11.5.2項で説明します。"
    },
    {
      "indent": 3,
      "text": "Under some circumstances, multiple replicas may be used simultaneously to provide higher-performance access to the file system in question, although the lack of state sharing between servers may be an impediment to such use.",
      "ja": "状況によっては、複数のレプリカを同時に使用して、問題のファイルシステムへの高性能アクセスを提供することができますが、サーバー間の状態の共有の欠如はそのような使用に障害である可能性があります。"
    },
    {
      "indent": 3,
      "text": "When a file system is present but becomes absent, clients can be given the opportunity to have continued access to their data using a different replica. In this case, a continued attempt to use the data in the now-absent file system will result in an NFS4ERR_MOVED error, and then the successor replica or set of possible replica choices can be fetched and used to continue access. Transfer of access to the new replica location is referred to as \"migration\" and is discussed in Section 11.5.4 below.",
      "ja": "ファイルシステムが存在するが存在しない場合、クライアントには異なるレプリカを使用してデータに継続的にアクセスできる機会を与えることができます。この場合、現在不在のファイルシステムでデータを使用し続けると、NFS4ERR_MOUDエラーが発生し、次に後続のレプリカまたは可能なレプリカの選択のセットをフェッチしてアクセスを続けることができます。新しいレプリカの場所へのアクセスの転送は「移行」と呼ばれ、下記の11.5.4項で説明されています。"
    },
    {
      "indent": 3,
      "text": "When a file system is currently absent, specification of file system location provides a means by which file systems located on one server can be associated with a namespace defined by another server, thus allowing a general multi-server namespace facility. A designation of such a remote instance, in place of a file system not previously present, is called a \"pure referral\" and is discussed in Section 11.5.6 below.",
      "ja": "ファイルシステムが現在不在である場合、ファイルシステムの場所の指定は、1つのサーバー上にあるファイルシステムを別のサーバーによって定義された名前空間に関連付けることができる手段を提供します。そのようなリモートインスタンスの指定は、以前に存在しないファイルシステムの代わりに、「純粋な参照」と呼ばれ、以下の11.5.6項で説明されている。"
    },
    {
      "indent": 3,
      "text": "Because client support for attributes related to file system location is OPTIONAL, a server may choose to take action to hide migration and referral events from such clients, by acting as a proxy, for example. The server can determine the presence of client support from the arguments of the EXCHANGE_ID operation (see Section 18.35.3).",
      "ja": "ファイルシステムの場所に関連する属性のクライアントサポートはオプションであるため、サーバーは、たとえばプロキシとして機能することで、そのようなクライアントから移行および紹介イベントを非表示にすることを選択することができます。サーバーは、Exchange_ID操作の引数からクライアントサポートの存在を判断できます（18.35.3項を参照）。"
    },
    {
      "indent": 0,
      "text": "11.5.1. Combining Multiple Uses in a Single Attribute",
      "section_title": true,
      "ja": "11.5.1. 単一の属性で複数の用途を組み合わせる"
    },
    {
      "indent": 3,
      "text": "A file system location attribute will sometimes contain information relating to the location of multiple replicas, which may be used in different ways:",
      "ja": "ファイルシステムの場所属性には、複数のレプリカの場所に関する情報が含まれている場合があります。これはさまざまな方法で使用できます。"
    },
    {
      "indent": 3,
      "text": "* File system location entries that relate to the file system instance currently in use provide trunking information, allowing the client to find additional network addresses by which the instance may be accessed.",
      "ja": "* 現在使用中のファイルシステムインスタンスに関連するファイルシステムの場所は、トランキング情報を提供し、クライアントがインスタンスにアクセスできる追加のネットワークアドレスを見つけることができます。"
    },
    {
      "indent": 3,
      "text": "* File system location entries that provide information about replicas to which access is to be transferred.",
      "ja": "* ファイルシステムの場所アクセス権を転送するレプリカに関する情報を提供するエントリ。"
    },
    {
      "indent": 3,
      "text": "* Other file system location entries that relate to replicas that are available to use in the event that access to the current replica becomes unsatisfactory.",
      "ja": "* 現在のレプリカへのアクセスが満足できない場合に使用可能なレプリカに関連する他のファイルの場所エントリ。"
    },
    {
      "indent": 3,
      "text": "In order to simplify client handling and to allow the best choice of replicas to access, the server should adhere to the following guidelines:",
      "ja": "クライアント処理を簡素化し、アクセスするためのレプリカの最良の選択を許可するために、サーバーは次のガイドラインに従うべきです。"
    },
    {
      "indent": 3,
      "text": "* All file system location entries that relate to a single file system instance should be adjacent.",
      "ja": "* 単一のファイルシステムインスタンスに関連するすべてのファイルシステムの場所エントリは隣接している必要があります。"
    },
    {
      "indent": 3,
      "text": "* File system location entries that relate to the instance currently in use should appear first.",
      "ja": "* ファイルシステムの場所現在使用中のインスタンスに関連するエントリが最初に表示されます。"
    },
    {
      "indent": 3,
      "text": "* File system location entries that relate to replica(s) to which migration is occurring should appear before replicas that are available for later use if the current replica should become inaccessible.",
      "ja": "* ファイルシステムの場所現在のレプリカにアクセスできない場合には、後で使用できるレプリカの前に表示されるレプリカの前に表示されます。"
    },
    {
      "indent": 0,
      "text": "11.5.2. File System Location Attributes and Trunking",
      "section_title": true,
      "ja": "11.5.2. ファイルシステムの場所属性とトランキング"
    },
    {
      "indent": 3,
      "text": "Trunking is the use of multiple connections between a client and server in order to increase the speed of data transfer. A client may determine the set of network addresses to use to access a given file system in a number of ways:",
      "ja": "トランキングは、データ転送の速度を上げるためにクライアントとサーバー間の複数の接続を使用することです。クライアントは、特定のファイルシステムにアクセスするために使用するネットワークアドレスのセットをいくつかの方法で決定することができます。"
    },
    {
      "indent": 3,
      "text": "* When the name of the server is known to the client, it may use DNS to obtain a set of network addresses to use in accessing the server.",
      "ja": "* サーバーの名前がクライアントに認識されると、サーバーへのアクセスに使用するネットワークアドレスのセットを取得するためにDNSを使用できます。"
    },
    {
      "indent": 3,
      "text": "* The client may fetch the file system location attribute for the file system. This will provide either the name of the server (which can be turned into a set of network addresses using DNS) or a set of server-trunkable location entries. Using the latter alternative, the server can provide addresses it regards as desirable to use to access the file system in question. Although these entries can contain port numbers, these port numbers are not used in determining trunking relationships. Once the candidate addresses have been determined and EXCHANGE_ID done to the proper server, only the value of the so_major_id field returned by the servers in question determines whether a trunking relationship actually exists.",
      "ja": "* クライアントはファイルシステムのファイルシステムの場所属性を取得することができます。これにより、サーバーの名前（DNSを使用している一連のネットワークアドレスに変換することができます）または一連のサーバートラッナー可能な場所エントリがあります。後者の代替案を使用すると、サーバは、問題のファイルシステムにアクセスするために使用することが望ましいと考えるアドレスを提供することができる。これらのエントリにはポート番号を含めることができますが、これらのポート番号はトランキング関係の決定には使用されません。候補アドレスが適切なサーバーに決定された場合、問題のサーバーによって返されたSO_MAJOR_IDフィールドの値のみが、トランキング関係が実際に存在するかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "When the client fetches a location attribute for a file system, it should be noted that the client may encounter multiple entries for a number of reasons, such that when it determines trunking information, it may need to bypass addresses not trunkable with one already known.",
      "ja": "クライアントがファイルシステムの位置属性を取り出すと、クライアントは、トランキング情報を決定するときに、既に知られているものとトランク不能に慣れないアドレスをバイパスする必要があるかもしれない。"
    },
    {
      "indent": 3,
      "text": "The server can provide location entries that include either names or network addresses. It might use the latter form because of DNS-related security concerns or because the set of addresses to be used might require active management by the server.",
      "ja": "サーバーは、名前またはネットワークアドレスを含む場所エントリを提供できます。DNS関連のセキュリティ上の懸念のため、または使用されるアドレスのセットがサーバーによるアクティブな管理を必要とする可能性があるため、後者のフォームを使用する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Location entries used to discover candidate addresses for use in trunking are subject to change, as discussed in Section 11.5.7 below. The client may respond to such changes by using additional addresses once they are verified or by ceasing to use existing ones. The server can force the client to cease using an address by returning NFS4ERR_MOVED when that address is used to access a file system. This allows a transfer of client access that is similar to migration, although the same file system instance is accessed throughout.",
      "ja": "下記の11.5.7項で説明したように、トランキングで使用する候補アドレスを検出するために使用される場所のエントリは変更されることがあります。クライアントは、それらが検証されたか、既存のものを使用することを中止することによって、追加のアドレスを使用することによってそのような変更に応答することができる。サーバーは、そのアドレスがファイルシステムにアクセスするために使用されているときにNFS4ERR_MOVEDを返すことによって、クライアントがアドレスを使用して実行できるようにすることができます。これにより、マイグレーションと似たクライアントアクセスの転送が可能になりますが、同じファイルシステムインスタンスが全体からアクセスされます。"
    },
    {
      "indent": 0,
      "text": "11.5.3. File System Location Attributes and Connection Type Selection",
      "section_title": true,
      "ja": "11.5.3. ファイルシステムの場所属性と接続タイプの選択"
    },
    {
      "indent": 3,
      "text": "Because of the need to support multiple types of connections, clients face the issue of determining the proper connection type to use when establishing a connection to a given server network address. In some cases, this issue can be addressed through the use of the connection \"step-up\" facility described in Section 18.36. However, because there are cases in which that facility is not available, the client may have to choose a connection type with no possibility of changing it within the scope of a single connection.",
      "ja": "複数の種類の接続をサポートする必要があるため、クライアントは、特定のサーバーネットワークアドレスへの接続を確立するときに使用する適切な接続タイプを決定する問題に直面します。場合によっては、この問題は、セクション18.36に記載されている接続「ステップアップ」機能を使用することによって対処できます。ただし、その機能が利用できない場合があるため、クライアントは単一の接続の範囲内で変更する可能性を持たない接続タイプを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The two file system location attributes differ as to the information made available in this regard. The fs_locations attribute provides no information to support connection type selection. As a result, clients supporting multiple connection types would need to attempt to establish connections using multiple connection types until the one preferred by the client is successfully established.",
      "ja": "2つのファイルシステムの場所属性は、この点で利用可能にされた情報に関して異なります。fs_locations属性は、接続タイプの選択をサポートするための情報を提供しません。その結果、複数の接続タイプをサポートするクライアントは、クライアントによって優先されるまでの1つが正常に確立されるまで、複数の接続タイプを使用して接続を確立しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute includes the FSLI4TF_RDMA flag, which is convenient for a client wishing to use RDMA. When this flag is set, it indicates that RPC-over-RDMA support is available using the specified location entry. A client can establish a TCP connection and then convert that connection to use RDMA by using the step-up facility.",
      "ja": "fs_locations_info属性にはFSLI4TF_RDMAフラグが含まれています。これは、RDMAを使用したいクライアントに便利です。このフラグが設定されている場合、指定された場所エントリを使用してRPC-over-RDMAサポートが使用可能であることを示します。クライアントはTCP接続を確立してから、その接続をステップアップ機能を使用してRDMAを使用するように変換できます。"
    },
    {
      "indent": 3,
      "text": "Irrespective of the particular attribute used, when there is no indication that a step-up operation can be performed, a client supporting RDMA operation can establish a new RDMA connection, and it can be bound to the session already established by the TCP connection, allowing the TCP connection to be dropped and the session converted to further use in RDMA mode, if the server supports that.",
      "ja": "使用される特定の属性に関係なく、ステップアップ操作を実行できるという表示がない場合、RDMA操作をサポートするクライアントは新しいRDMA接続を確立でき、TCP接続によってすでに確立されているセッションにバインドできます。Serverがそれをサポートしている場合は、ドロップされるTCP接続とセッションがRDMAモードでさらに使用されていました。"
    },
    {
      "indent": 0,
      "text": "11.5.4. File System Replication",
      "section_title": true,
      "ja": "11.5.4. ファイルシステムのレプリケーション"
    },
    {
      "indent": 3,
      "text": "The fs_locations and fs_locations_info attributes provide alternative file system locations, to be used to access data in place of or in addition to the current file system instance. On first access to a file system, the client should obtain the set of alternate locations by interrogating the fs_locations or fs_locations_info attribute, with the latter being preferred.",
      "ja": "FS_LOCATIONSとFS_LOCATIONS_INFO属性は、現在のファイルシステムインスタンスの代わりにまたはそれに加えてデータにアクセスするために使用される代替のファイルシステムの場所を提供します。ファイルシステムへの最初のアクセス時に、クライアントは、FS_LOCATIONATIONSまたはFS_LOCATIONS_INFO属性を尋問することによって代替位置のセットを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the event that the occurrence of server failures, communications problems, or other difficulties make continued access to the current file system impossible or otherwise impractical, the client can use the alternate locations as a way to get continued access to its data.",
      "ja": "サーバーの障害、通信の問題、またはその他の困難が現在のファイルシステムへのアクセスを不可能または非実用的でない場合、クライアントはそのデータへの継続的なアクセスを取得する方法として、代替の場所を使用できます。"
    },
    {
      "indent": 3,
      "text": "The alternate locations may be physical replicas of the (typically read-only) file system data supplemented by possible asynchronous propagation of updates. Alternatively, they may provide for the use of various forms of server clustering in which multiple servers provide alternate ways of accessing the same physical file system. How the difference between replicas affects file system transitions can be represented within the fs_locations and fs_locations_info attributes, and how the client deals with file system transition issues will be discussed in detail in later sections.",
      "ja": "代替位置は、更新の可能性のある非同期伝播によって補完された（通常は読み取り専用）ファイルシステムの物理レプリカであり得る。あるいは、それらは、複数のサーバが同じ物理ファイルシステムにアクセスするための代替方法を提供する様々な形態のサーバクラスタリングの使用を提供することができる。レプリカ間の差異がファイルシステムの遷移に影響する方法は、FS_LOCATIONSとFS_LOCATIONS_INFO属性内で表現できます。また、クライアントがファイルシステムの遷移の問題をどのように扱うかを詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "Although the location attributes provide some information about the nature of the inter-replica transition, many aspects of the semantics of possible asynchronous updates are not currently described by the protocol, which makes it necessary for clients using replication to switch among replicas undergoing change to familiarize themselves with the semantics of the update approach used. Due to this lack of specificity, many applications may find the use of migration more appropriate because a server can propagate all updates made before an established point in time to the new replica as part of the migration event.",
      "ja": "位置属性はレプリカ間の遷移の性質に関する情報を提供しますが、可能な非同期アップデートのセマンティクスの多くの側面は現在プロトコルによって説明されていません。使用されているアップデートアプローチの意味論を持つものです。この特異性の欠如のために、多くのアプリケーションは、移行イベントの一部として新しいレプリカに確立されたポイントの前に行われたすべての更新を伝播することができるため、多くのアプリケーションが移行の使用をより適切であると考えているかもしれません。"
    },
    {
      "indent": 0,
      "text": "11.5.4.1. File System Trunking Presented as Replication",
      "section_title": true,
      "ja": "11.5.4.1. レプリケーションとして提示されたファイルシステムのトランキング"
    },
    {
      "indent": 3,
      "text": "In some situations, a file system location entry may indicate a file system access path to be used as an alternate location, where trunking, rather than replication, is to be used. The situations in which this is appropriate are limited to those in which both of the following are true:",
      "ja": "状況によっては、ファイルシステムの場所エントリは、レプリケーションではなくトランキングが使用される代替の場所として使用されるファイルシステムアクセスパスを示すことができる。これが適切な状況は、以下の両方が当てはまるものに限定されています。"
    },
    {
      "indent": 3,
      "text": "* The two file system locations (i.e., the one on which the location attribute is obtained and the one specified in the file system location entry) designate the same locations within their respective single-server namespaces.",
      "ja": "* 2つのファイルシステムの位置（すなわち、位置属性が取得され、ファイルシステムの場所エントリに指定されたものがそれらのそれぞれのシングルサーバ名前空間に取得するもの）を指定する。"
    },
    {
      "indent": 3,
      "text": "* The two server network addresses (i.e., the one being used to obtain the location attribute and the one specified in the file system location entry) designate the same server (as indicated by the same value of the so_major_id field of the eir_server_owner field returned in response to EXCHANGE_ID).",
      "ja": "* 2つのサーバネットワークアドレス（すなわち、位置属性を取得するために使用されるもの、およびファイルシステムの場所エントリで指定されたものは、応答に返されたEIR_SERVER_OWNERフィールドのSO_MAJOR_IDフィールドの同じ値で示すように）同じサーバを指定する。Exchange_IDへ。"
    },
    {
      "indent": 3,
      "text": "When these conditions hold, operations using both access paths are generally trunked, although trunking may be disallowed when the attribute fs_locations_info is used:",
      "ja": "これらの条件が保持されると、両方のアクセスパスを使用した操作は一般的にトランクされますが、属性FS_LOCATIONS_INFOが使用されている場合はトランキングが許可されます。"
    },
    {
      "indent": 3,
      "text": "* When the fs_locations_info attribute shows the two entries as not having the same simultaneous-use class, trunking is inhibited, and the two access paths cannot be used together.",
      "ja": "* FS_LOCATIONS_INFO属性が同じ同時使用クラスを持たないように2つのエントリを表示すると、トランキングは禁止され、2つのアクセスパスを一緒に使用できません。"
    },
    {
      "indent": 6,
      "text": "In this case, the two paths can be used serially with no transition activity required on the part of the client, and any transition between access paths is transparent. In transferring access from one to the other, the client acts as if communication were interrupted, establishing a new connection and possibly a new session to continue access to the same file system.",
      "ja": "この場合、2つの経路をクライアントの一部に必要な遷移活動がなく、アクセス経路間の遷移は透明である。1つから他方へのアクセスを転送する場合、クライアントは、通信が中断され、新しい接続を確立し、場合によっては新しいセッションを確立し、同じファイルシステムへのアクセスを続けます。"
    },
    {
      "indent": 3,
      "text": "* Note that for two such location entries, any information within the fs_locations_info attribute that indicates the need for special transition activity, i.e., the appearance of the two file system location entries with different handle, fileid, write-verifier, change, and readdir classes, indicates a serious problem. The client, if it allows transition to the file system instance at all, must not treat any transition as a transparent one. The server SHOULD NOT indicate that these two entries (for the same file system on the same server) belong to different handle, fileid, write-verifier, change, and readdir classes, whether or not the two entries are shown belonging to the same simultaneous-use class.",
      "ja": "* このような2つの場所エントリは、特別な遷移アクティビティの必要性、つまり異なるハンドル、fileID、書き込み検証、変更、およびREADDIRクラスを持つ2つのファイルシステムの場所のエントリの外観を示すFS_LOCATIONS_INFO属性内の情報があることに注意してください。深刻な問題を示します。クライアントは、ファイルシステムインスタンスへの移行をまったく許可する場合は、透過的なものとして遷移を扱ってはいけません。サーバーは、これら2つのエントリ（同じサーバー上の同じファイルシステムの場合）が異なるハンドル、FileID、WRITE-VERIFIER、CHANDE、およびREADDIRクラスに属していることを示すべきではありません.2つのエントリが同じ同時に属するクラス。"
    },
    {
      "indent": 3,
      "text": "These situations were recognized by [66], even though that document made no explicit mention of trunking:",
      "ja": "その文書が闇の明示的な言及をしなかったとしても、これらの状況は[66]によって認識されました："
    },
    {
      "indent": 3,
      "text": "* It treated the situation that we describe as trunking as one of simultaneous use of two distinct file system instances, even though, in the explanatory framework now used to describe the situation, the case is one in which a single file system is accessed by two different trunked addresses.",
      "ja": "* 説明フレームワークでは、状況を説明するために使用されている説明フレームワークでは、2つのファイルシステムが2つの異なる範囲内でアクセスされているものがある場合でも、2つの異なるファイルシステムインスタンスを同時に使用するという状況を扱いました。トランクアドレス。"
    },
    {
      "indent": 3,
      "text": "* It treated the situation in which two paths are to be used serially as a special sort of \"transparent transition\". However, in the descriptive framework now used to categorize transition situations, this is considered a case of a \"network endpoint transition\" (see Section 11.9).",
      "ja": "* 2つの経路が「透明な遷移」の特殊な種類のように直列に使用される状況を扱いました。ただし、遷移状況を分類するために現在説明されているフレームワークでは、これは「ネットワークエンドポイント遷移」の場合と考えられています（セクション11.9を参照）。"
    },
    {
      "indent": 0,
      "text": "11.5.5. File System Migration",
      "section_title": true,
      "ja": "11.5.5. ファイルシステムの移行"
    },
    {
      "indent": 3,
      "text": "When a file system is present and becomes inaccessible using the current access path, the NFSv4.1 protocol provides a means by which clients can be given the opportunity to have continued access to their data. This may involve using a different access path to the existing replica or providing a path to a different replica. The new access path or the location of the new replica is specified by a file system location attribute. The ensuing migration of access includes the ability to retain locks across the transition. Depending on circumstances, this can involve:",
      "ja": "ファイルシステムが存在し、現在のアクセスパスを使用してアクセスできない場合、NFSV4.1プロトコルはクライアントにデータへのアクセスを継続する機会を与えることができる手段を提供します。これは、既存のレプリカへの異なるアクセスパスを使用するか、別のレプリカへのパスを提供することを含み得る。新しいアクセスパスまたは新しいレプリカの場所は、ファイルシステムの場所属性によって指定されます。アクセスの間の移行は、遷移にわたってロックを保持する機能を含む。状況に応じて、これには以下のものがあります。"
    },
    {
      "indent": 3,
      "text": "* The continued use of the existing clientid when accessing the current replica using a new access path.",
      "ja": "* 新しいアクセスパスを使用して現在のレプリカにアクセスするときに既存のClientIDを継続しています。"
    },
    {
      "indent": 3,
      "text": "* Use of lock reclaim, taking advantage of a per-fs grace period.",
      "ja": "* FSごとの猶予期間を利用して、ロック再利用の使用。"
    },
    {
      "indent": 3,
      "text": "* Use of Transparent State Migration.",
      "ja": "* 透明状態移行の使用"
    },
    {
      "indent": 3,
      "text": "Typically, a client will be accessing the file system in question, get an NFS4ERR_MOVED error, and then use a file system location attribute to determine the new access path for the data. When fs_locations_info is used, additional information will be available that will define the nature of the client's handling of the transition to a new server.",
      "ja": "通常、クライアントは問題のファイルシステムにアクセスし、NFS4ERR_VOVEDエラーを取得し、ファイルシステムの場所属性を使用してデータの新しいアクセスパスを決定します。FS_LOCATIONS_INFOが使用されている場合は、クライアントの新しいサーバーへの移行の扱いの性質を定義する追加情報が利用可能になります。"
    },
    {
      "indent": 3,
      "text": "In most instances, servers will choose to migrate all clients using a particular file system to a successor replica at the same time to avoid cases in which different clients are updating different replicas. However, migration of an individual client can be helpful in providing load balancing, as long as the replicas in question are such that they represent the same data as described in Section 11.11.8.",
      "ja": "ほとんどの場合、サーバーは、異なるクライアントが異なるレプリカを更新しているケースを避けるために、特定のファイルシステムをサクセルレプリカに使用してすべてのクライアントを移行することを選択します。しかしながら、個々のクライアントの移行は、問題のレプリカがセクション11.11.8に記載されているものと同じデータを表すものである限り、負荷分散を提供するのに役立ち得る。"
    },
    {
      "indent": 3,
      "text": "* In the case in which there is no transition between replicas (i.e., only a change in access path), there are no special difficulties in using of this mechanism to effect load balancing.",
      "ja": "* レプリカ間の遷移（すなわちアクセス経路の変更のみ）がない場合には、このメカニズムを使用して負荷分散を効果的に影響を与えることに特別な困難はない。"
    },
    {
      "indent": 3,
      "text": "* In the case in which the two replicas are sufficiently coordinated as to allow a single client coherent, simultaneous access to both, there is, in general, no obstacle to the use of migration of particular clients to effect load balancing. Generally, such simultaneous use involves cooperation between servers to ensure that locks granted on two coordinated replicas cannot conflict and can remain effective when transferred to a common replica.",
      "ja": "* 2つのレプリカが単一のクライアントのコヒーレントを可能にするのに十分に調整されている場合、一般に、負荷分散に影響を与えるために特定のクライアントの移動の使用に対する障害はありません。一般に、このような同時使用は、サーバー間の協力を含み、2つの協調レプリカに付与されたロックが競合することができず、共通のレプリカに転送されたときに有効なままである可能性があることを含みます。"
    },
    {
      "indent": 3,
      "text": "* In the case in which a large set of clients is accessing a file system in a read-only fashion, it can be helpful to migrate all clients with writable access simultaneously, while using load balancing on the set of read-only copies, as long as the rules in Section 11.11.8, which are designed to prevent data reversion, are followed.",
      "ja": "* クライアントの大規模なクライアントが読み取り専用の方法でファイルシステムにアクセスしている場合は、読み取り専用コピーのセットでロードバランシングを使用しながら、すべてのクライアントを同時に使用することができます。データの復帰を防ぐように設計されているセクション11.11.8の規則として続いています。"
    },
    {
      "indent": 3,
      "text": "In other cases, the client might not have sufficient guarantees of data similarity or coherence to function properly (e.g., the data in the two replicas is similar but not identical), and the possibility that different clients are updating different replicas can exacerbate the difficulties, making the use of load balancing in such situations a perilous enterprise.",
      "ja": "他の場合には、クライアントは適切に機能するのに十分なデータ類似性またはコヒーレンスを有していない可能性がある（例えば、2つのレプリカのデータは同一ではなく同一ではない）、異なる複製が更新されている可能性が困難である可能性がある。そのような状況で危険にさらされている企業の使用を活用する。"
    },
    {
      "indent": 3,
      "text": "The protocol does not specify how the file system will be moved between servers or how updates to multiple replicas will be coordinated. It is anticipated that a number of different server-to-server coordination mechanisms might be used, with the choice left to the server implementer. The NFSv4.1 protocol specifies the method used to communicate the migration event between client and server.",
      "ja": "プロトコルは、ファイルシステムがサーバー間で移動する方法、または複数のレプリカへの更新方法を調整する方法を指定しません。サーバー実装者に選択肢が残って、さまざまなサーバー間の調整メカニズムが使用される可能性があることが予想されます。NFSV4.1プロトコルは、クライアントとサーバー間の移行イベントの通信に使用されるメソッドを指定します。"
    },
    {
      "indent": 3,
      "text": "In the case of various forms of server clustering, the new location may be another server providing access to the same physical file system. The client's responsibilities in dealing with this transition will depend on whether a switch between replicas has occurred and the means the server has chosen to provide continuity of locking state. These issues will be discussed in detail below.",
      "ja": "さまざまな形式のサーバークラスタリングの場合、新しい場所は同じ物理ファイルシステムへのアクセスを提供する別のサーバーです。この遷移を処理する際のクライアントの責任は、レプリカ間のスイッチが発生したかどうかによって異なり、サーバーがロック状態の継続性を提供することを選択したことを意味します。これらの問題については後で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Although a single successor location is typical, multiple locations may be provided. When multiple locations are provided, the client will typically use the first one provided. If that is inaccessible for some reason, later ones can be used. In such cases, the client might consider the transition to the new replica to be a migration event, even though some of the servers involved might not be aware of the use of the server that was inaccessible. In such a case, a client might lose access to locking state as a result of the access transfer.",
      "ja": "単一の後続の位置は典型的なものであるが、複数の位置が提供されてもよい。複数の場所が提供されると、クライアントは通常、提供された最初のものを使用します。それが何らかの理由でアクセスできない場合、後のものを使用することができます。そのような場合、クライアントは、関与するサーバーの中にはアクセスできないサーバーの使用を認識していない場合でも、クライアントは新しいレプリカに移行イベントに移行することを検討することがあります。そのような場合、アクセス転送の結果としてクライアントがロック状態へのアクセスを失う可能性があります。"
    },
    {
      "indent": 3,
      "text": "When an alternate location is designated as the target for migration, it must designate the same data (with metadata being the same to the degree indicated by the fs_locations_info attribute). Where file systems are writable, a change made on the original file system must be visible on all migration targets. Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, similar requirements apply to the propagation of updates. Any change visible in the original file system must already be effected on all migration targets, to avoid any possibility that a client, in effecting a transition to the migration target, will see any reversion in file system state.",
      "ja": "代替位置が移行の対象として指定されている場合、同じデータを指定する必要があります（メタデータは、FS_LOCATIONS_INFO属性によって示された次数に同じ）。ファイルシステムが書き込み可能な場合、元のファイルシステムで行われた変更はすべての移行ターゲットに表示されなければなりません。ファイルシステムが書き込み可能ではないが、書き込み可能なファイルシステムの読み取り専用コピー（おそらく周期的に更新）を表しますが、更新の伝播に同様の要件が適用されます。元のファイルシステムで表示される変更は、クライアントが移行先への移行を中止する可能性を避けるために、すべての移行ターゲットで既に行われている必要があります。"
    },
    {
      "indent": 0,
      "text": "11.5.6. Referrals",
      "section_title": true,
      "ja": "11.5.6. 紹介"
    },
    {
      "indent": 3,
      "text": "Referrals allow the server to associate a file system namespace entry located on one server with a file system located on another server. When this includes the use of pure referrals, servers are provided a way of placing a file system in a location within the namespace essentially without respect to its physical location on a particular server. This allows a single server or a set of servers to present a multi-server namespace that encompasses file systems located on a wider range of servers. Some likely uses of this facility include establishment of site-wide or organization-wide namespaces, with the eventual possibility of combining such together into a truly global namespace, such as the one provided by AFS (the Andrew File System) [65].",
      "ja": "紹介を使用すると、サーバーは1つのサーバー上にあるファイルシステムネームスペースエントリを別のサーバー上にあるファイルシステムと関連付けることができます。これに純粋な紹介の使用が含まれる場合、サーバは、特定のサーバ上の物理的な場所に対して、ファイルシステム内の位置にファイルシステムを名前空間内の位置に配置する方法を提供する。これにより、単一のサーバーまたはサーバーのセットが、より広い範囲のサーバーにあるファイルシステムを包含するマルチサーバーネームスペースを表示できます。この施設のおそらく使用のある用途には、サイト全体または組織全体の名前空間の確立が含まれ、そのようなものは、AFS（Andrewファイルシステム）によって提供されるものなどの真にグローバルな名前空間に組み合わせることが最終的に可能な可能性を備えています[65]。"
    },
    {
      "indent": 3,
      "text": "Referrals occur when a client determines, upon first referencing a position in the current namespace, that it is part of a new file system and that the file system is absent. When this occurs, typically upon receiving the error NFS4ERR_MOVED, the actual location or locations of the file system can be determined by fetching a locations attribute.",
      "ja": "紹介は、クライアントが現在のネームスペース内の位置を最初に参照すると、新しいファイルシステムの一部であり、ファイルシステムが不在であることを判断したときに発生します。これが発生すると、通常はエラーNFS4ERR_MOUDを受信すると、Locations属性を取得することによって、ファイルシステムの実際の場所または場所を決定できます。"
    },
    {
      "indent": 3,
      "text": "The file system location attribute may designate a single file system location or multiple file system locations, to be selected based on the needs of the client. The server, in the fs_locations_info attribute, may specify priorities to be associated with various file system location choices. The server may assign different priorities to different locations as reported to individual clients, in order to adapt to client physical location or to effect load balancing. When both read-only and read-write file systems are present, some of the read-only locations might not be absolutely up-to-date (as they would have to be in the case of replication and migration). Servers may also specify file system locations that include client-substituted variables so that different clients are referred to different file systems (with different data contents) based on client attributes such as CPU architecture.",
      "ja": "ファイルシステムの場所属性は、クライアントのニーズに基づいて選択される単一のファイルシステムの場所または複数のファイルシステムの場所を指定することができる。fs_locations_info属性のサーバーは、さまざまなファイルシステムの場所の選択に関連付けられる優先順位を指定できます。サーバーは、クライアントの物理的な場所に適応するため、または負荷分散に影響を与えるために、個々のクライアントに報告されているように、さまざまな場所に異なる優先順位を割り当てることができます。読み取り専用ファイルシステムと読み書きファイルシステムの両方が存在する場合、一部の読み取り専用の場所は絶対に最新の場所ではない可能性があります（複製と移行の場合はそうでなければなりません）。サーバーは、クライアント置換変数を含むファイルシステムの場所を指定して、CPUアーキテクチャなどのクライアント属性に基づいて異なるファイルシステム（異なるデータ内容を持つ）を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the fs_locations_info attribute lists multiple possible targets, the relationships among them may be important to the client in selecting which one to use. The same rules specified in Section 11.5.5 below regarding multiple migration targets apply to these multiple replicas as well. For example, the client might prefer a writable target on a server that has additional writable replicas to which it subsequently might switch. Note that, as distinguished from the case of replication, there is no need to deal with the case of propagation of updates made by the current client, since the current client has not accessed the file system in question.",
      "ja": "fs_locations_info属性が複数の可能なターゲットをリストしている場合、それらの間の関係は、使用するものを選択する際にクライアントにとって重要かもしれません。複数の移行ターゲットに関して以下のセクション11.5.5で指定された同じ規則も、これらの複数のレプリカにも適用されます。たとえば、クライアントは、その後に切り替えることができる追加の書き込み可能なレプリカを持つサーバー上の書き込み可能なターゲットを好むことがあります。なお、レプリケーションの場合と区別されるように、現在のクライアントは問題のファイルシステムにアクセスしていないため、現在のクライアントによって行われた更新の伝播の場合に対処する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Use of multi-server namespaces is enabled by NFSv4.1 but is not required. The use of multi-server namespaces and their scope will depend on the applications used and system administration preferences.",
      "ja": "マルチサーバーネームスペースの使用はNFSV4.1によって有効になりますが、必須ではありません。マルチサーバーネームスペースとそのスコープの使用は、使用されるアプリケーションとシステム管理の設定によって異なります。"
    },
    {
      "indent": 3,
      "text": "Multi-server namespaces can be established by a single server providing a large set of pure referrals to all of the included file systems. Alternatively, a single multi-server namespace may be administratively segmented with separate referral file systems (on separate servers) for each separately administered portion of the namespace. The top-level referral file system or any segment may use replicated referral file systems for higher availability.",
      "ja": "マルチサーバー名前空間は、単一のサーバーによって、含まれているすべてのファイルシステムに大きなセットの純粋な紹介を提供することによって確立できます。あるいは、単一のマルチサーバネームスペースを、ネームスペースの各個別に管理された部分ごとに別々の紹介ファイルシステム（別々のサーバ上）で管理上セグメント化することができる。最上位紹介ファイルシステムまたは任意のセグメントは、可用性のために複製された紹介ファイルシステムを使用することがあります。"
    },
    {
      "indent": 3,
      "text": "Generally, multi-server namespaces are for the most part uniform, in that the same data made available to one client at a given location in the namespace is made available to all clients at that namespace location. However, there are facilities provided that allow different clients to be directed to different sets of data, for reasons such as enabling adaptation to such client characteristics as CPU architecture. These facilities are described in Section 11.17.3.",
      "ja": "一般に、マルチサーバーネームスペースは、ネームスペース内の特定の場所にあるクライアントが1つのクライアントで使用可能にされた同じデータが、その名前空間の場所のすべてのクライアントで使用可能にされているという点で、大部分の統一です。しかしながら、CPUアーキテクチャとのこのようなクライアント特性への適合を可能にすることのような理由で、異なるクライアントを異なるデータセットに向けられることを可能にする機能が提供される。これらの施設は11.17.3項で説明されています。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible, when providing a uniform namespace, to provide different location entries to different clients in order to provide each client with a copy of the data physically closest to it or otherwise optimize access (e.g., provide load balancing).",
      "ja": "均一な名前空間を提供するとき、各クライアントを各クライアントに提供するために異なる位置エントリを提供することが可能であることに留意されたい。"
    },
    {
      "indent": 0,
      "text": "11.5.7. Changes in a File System Location Attribute",
      "section_title": true,
      "ja": "11.5.7. ファイルシステムの場所属性の変更"
    },
    {
      "indent": 3,
      "text": "Although clients will typically fetch a file system location attribute when first accessing a file system and when NFS4ERR_MOVED is returned, a client can choose to fetch the attribute periodically, in which case, the value fetched may change over time.",
      "ja": "クライアントは通常ファイルシステムの場所属性をフェッチし、最初にファイルシステムにアクセスし、NFS4ERR_MOVEDが返されると、クライアントが定期的に属性を取得することを選択できます。その場合、取り出した値は時間とともに変化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "For clients not prepared to access multiple replicas simultaneously (see Section 11.11.1), the handling of the various cases of location change are as follows:",
      "ja": "複数のレプリカに同時にアクセスする準備ができていないクライアントの場合（セクション11.11.1参照）、位置変更のさまざまなケースの処理は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Changes in the list of replicas or in the network addresses associated with replicas do not require immediate action. The client will typically update its list of replicas to reflect the new information.",
      "ja": "* レプリカのリストまたはレプリカに関連付けられているネットワークアドレスの変更は、即時の行動を必要としません。クライアントは通常、新しい情報を反映するためにレプリカのリストを更新します。"
    },
    {
      "indent": 3,
      "text": "* Additions to the list of network addresses for the current file system instance need not be acted on promptly. However, to prepare for a subsequent migration event, the client can choose to take note of the new address and then use it whenever it needs to switch access to a new replica.",
      "ja": "* 現在のファイルシステムインスタンスのネットワークアドレスのリストへの追加は、迅速に機能する必要はありません。ただし、後続の移行イベントに準備するために、クライアントは新しいアドレスを注意してから新しいアドレスを取得してから新しいレプリカへのアクセスを切り替える必要がある場合は使用できます。"
    },
    {
      "indent": 3,
      "text": "* Deletions from the list of network addresses for the current file system instance do not require the client to immediately cease use of existing access paths, although new connections are not to be established on addresses that have been deleted. However, clients can choose to act on such deletions by preparing for an eventual shift in access, which becomes unavoidable as soon as the server returns NFS4ERR_MOVED to indicate that a particular network access path is not usable to access the current file system.",
      "ja": "* 現在のファイルシステムインスタンスのネットワークアドレスのリストからの削除は、クライアントが既存のアクセスパスの使用をすぐに使用できるようにする必要はありませんが、削除されたアドレスに新しい接続は確立されません。ただし、クライアントは、アクセスの最終的なシフトを準備することによって、そのような削除に行動することを選択できます。これは、サーバーがNFS4ERR_MOVEDを返し、特定のネットワークアクセスパスが現在のファイルシステムにアクセスするために使用できないことを示します。"
    },
    {
      "indent": 3,
      "text": "For clients that are prepared to access several replicas simultaneously, the following additional cases need to be addressed. As in the cases discussed above, changes in the set of replicas need not be acted upon promptly, although the client has the option of adjusting its access even in the absence of difficulties that would lead to the selection of a new replica.",
      "ja": "複数のレプリカに同時にアクセスする準備ができているクライアントの場合、以下の追加のケースを対処する必要があります。上述した場合と同様に、クライアントは、新しいレプリカの選択につながる困難がない場合でもそのアクセスを調整することができるが、レプリカのセットの変更は迅速に行動する必要はない。"
    },
    {
      "indent": 3,
      "text": "* When a new replica is added, which may be accessed simultaneously with one currently in use, the client is free to use the new replica immediately.",
      "ja": "* 現在使用中の1つと同時にアクセスすることができる新しいレプリカが追加されると、クライアントはすぐに新しいレプリカを使用できます。"
    },
    {
      "indent": 3,
      "text": "* When a replica currently in use is deleted from the list, the client need not cease using it immediately. However, since the server may subsequently force such use to cease (by returning NFS4ERR_MOVED), clients might decide to limit the need for later state transfer. For example, new opens might be done on other replicas, rather than on one not present in the list.",
      "ja": "* 現在使用中のレプリカがリストから削除されると、クライアントはすぐに使用することを解消する必要はありません。ただし、サーバーはそのような使用を中止するために（NFS4ERR_MOVEDを返すことによって）、クライアントが後の状態転送の必要性を制限することを決定することができます。たとえば、リストに存在しないのではなく、他のレプリカで新しいオープンが実行される可能性があります。"
    },
    {
      "indent": 0,
      "text": "11.6. Trunking without File System Location Information",
      "section_title": true,
      "ja": "11.6. ファイルシステムの場所のないトランキング"
    },
    {
      "indent": 3,
      "text": "In situations in which a file system is accessed using two server-trunkable addresses (as indicated by the same value of the so_major_id field of the eir_server_owner field returned in response to EXCHANGE_ID), trunked access is allowed even though there might not be any location entries specifically indicating the use of trunking for that file system.",
      "ja": "ファイルシステムが2つのサーバートラッキタブルアドレスを使用してアクセスされる状況で（Exchange_IDに応答して返されたEIR_SERVER_OWNERフィールドのSO_MAJOR_OWNERフィールドのSO_MAJOR_OWNERフィールド）で示されている場合は、場所エントリがない場合でもトランクアクセスが許可されます。具体的には、そのファイルシステムのトランキングの使用を示す。"
    },
    {
      "indent": 3,
      "text": "This situation was recognized by [66], although that document made no explicit mention of trunking and treated the situation as one of simultaneous use of two distinct file system instances. In the explanatory framework now used to describe the situation, the case is one in which a single file system is accessed by two different trunked addresses.",
      "ja": "この状況は[66]によって認識されましたが、その文書は2つの異なるファイルシステムインスタンスを同時に使用することの一つとしてトランキングを明確に言及し、状況を扱いませんでした。状況を説明するために使用される説明フレームワークでは、ケースは2つの異なるトランクアドレスによって単一のファイルシステムがアクセスされるものである。"
    },
    {
      "indent": 0,
      "text": "11.7. Users and Groups in a Multi-Server Namespace",
      "section_title": true,
      "ja": "11.7. マルチサーバーネームスペース内のユーザーとグループ"
    },
    {
      "indent": 3,
      "text": "As in the case of a single-server environment (see Section 5.9), when an owner or group name of the form \"id@domain\" is assigned to a file, there is an implicit promise to return that same string when the corresponding attribute is interrogated subsequently. In the case of a multi-server namespace, that same promise applies even if server boundaries have been crossed. Similarly, when the owner attribute of a file is derived from the security principal that created the file, that attribute should have the same value even if the interrogation occurs on a different server from the file creation.",
      "ja": "シングルサーバ環境の場合と同様に（セクション5.9を参照）、「id @ domain」フォームの所有者またはグループ名がファイルに割り当てられている場合、対応する属性がその同じ文字列を返すことを暗黙のうちに存在する。その後尋問されています。マルチサーバーネームスペースの場合、サーバーの境界が交差していても同じ約束が適用されます。同様に、ファイルの所有者属性がファイルを作成したセキュリティプリンシパルから派生した場合、その属性はファイル作成から別のサーバー上で尋問が行われても同じ値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, the set of security principals recognized by all the participating servers needs to be the same, with each such principal having the same credentials, regardless of the particular server being accessed.",
      "ja": "同様に、参加しているすべてのサーバーによって認識されるセキュリティプリンシパルのセットは同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to meet these requirements, those setting up multi-server namespaces will need to limit the servers included so that:",
      "ja": "これらの要件を満たすために、マルチサーバーネームスペースを設定することは、次のようにサーバーを制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "* In all cases in which more than a single domain is supported, the requirements stated in RFC 8000 [31] are to be respected.",
      "ja": "* 単一のドメインがサポートされているすべての場合において、RFC 8000 [31]に記載されている要件は尊重されます。"
    },
    {
      "indent": 3,
      "text": "* All servers support a common set of domains that includes all of the domains clients use and expect to see returned as the domain portion of an owner or group in the form \"id@domain\". Note that, although this set most often consists of a single domain, it is possible for multiple domains to be supported.",
      "ja": "* すべてのサーバーは、すべてのドメインクライアントを含む共通のドメインセットをサポートし、 \"id @ domain\"のフォーム内の所有者またはグループのドメイン部分として返される予定です。このセットはほとんどの場合単一のドメインで構成されていますが、複数のドメインをサポートすることが可能です。"
    },
    {
      "indent": 3,
      "text": "* All servers, for each domain that they support, accept the same set of user and group ids as valid.",
      "ja": "* すべてのサーバーは、それらがサポートしている各ドメインに対して、同じユーザーIDとグループIDのセットを有効に受け入れます。"
    },
    {
      "indent": 3,
      "text": "* All servers recognize the same set of security principals. For each principal, the same credential is required, independent of the server being accessed. In addition, the group membership for each such principal is to be the same, independent of the server accessed.",
      "ja": "* すべてのサーバーは同じセキュリティプリンシパルのセットを認識しています。各プリンシパルについて、アクセスされているサーバーとは無関係に、同じ信任状が必要です。さらに、そのような各校長のグループメンバーシップは、アクセスされたサーバーとは無関係であることです。"
    },
    {
      "indent": 3,
      "text": "Note that there is no requirement in general that the users corresponding to particular security principals have the same local representation on each server, even though it is most often the case that this is so.",
      "ja": "一般に、特定のセキュリティプリンシパルに対応するユーザは、ほとんどの場合、これがそうである場合でも、各サーバ上で同じローカル表現を有することが一般的ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When AUTH_SYS is used, the following additional requirements must be met:",
      "ja": "auth_sysが使用されている場合、以下の追加要件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "* Only a single NFSv4 domain can be supported through the use of AUTH_SYS.",
      "ja": "* AUTH_SYSを使用してサポートできるNFSv4ドメインのみがサポートできます。"
    },
    {
      "indent": 3,
      "text": "* The \"local\" representation of all owners and groups must be the same on all servers. The word \"local\" is used here since that is the way that numeric user and group ids are described in Section 5.9. However, when AUTH_SYS or stringified numeric owners or groups are used, these identifiers are not truly local, since they are known to the clients as well as to the server.",
      "ja": "* すべてのサーバーですべての所有者とグループの「ローカル」表現は同じでなければなりません。ここでは「ローカル」という単語が使用されているので、数値のユーザーとグループIDがセクション5.9で説明されている方法です。ただし、auth_sysまたは文字系の所有者またはグループが使用されている場合、これらの識別子は本当にローカルではありません。"
    },
    {
      "indent": 3,
      "text": "Similarly, when stringified numeric user and group ids are used, the \"local\" representation of all owners and groups must be the same on all servers, even when AUTH_SYS is not used.",
      "ja": "同様に、数値ユーザーとグループIDを使用した場合、AUTH_SYSが使用されていなくても、すべての所有者とグループの「ローカル」表現はすべてのサーバーで同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.8. Additional Client-Side Considerations",
      "section_title": true,
      "ja": "11.8. 追加のクライアント側の考慮事項"
    },
    {
      "indent": 3,
      "text": "When clients make use of servers that implement referrals, replication, and migration, care should be taken that a user who mounts a given file system that includes a referral or a relocated file system continues to see a coherent picture of that user-side file system despite the fact that it contains a number of server-side file systems that may be on different servers.",
      "ja": "クライアントが参照、複製、および移行を実装するサーバーを利用する場合、紹介または再配置されたファイルシステムを含む特定のファイルシステムをマウントするユーザーは、そのユーザーサイドファイルシステムのコヒーレント写真を継続し続けるように注意する必要があります。それが異なるサーバー上にあるかもしれない多くのサーバーサイドファイルシステムを含むという事実にもかかわらず。"
    },
    {
      "indent": 3,
      "text": "One important issue is upward navigation from the root of a server-side file system to its parent (specified as \"..\" in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server's single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of sending a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.",
      "ja": "1つの重要な問題は、紹介、移行、またはそのファイルシステムに移行する場合に、サーバー側のファイルシステムのルートからその親への親ナビゲーション（UNIXでは \"..\"として指定されています）です。複製結果としての遷移クライアントがそのような点にあるとき、それが親に上昇する必要がある場合は、Lookupp操作をサーバーに送信するのではなく、マルチサーバーネームスペース内に表示されるように親に戻る必要があります。そのサーバーのシングルサーバーネームスペース。これを行うには、クライアントはそのようなファイルシステムのルートを表すファイルハンドルを覚え、現在のサーバーにLookupp操作を送信する代わりにこれらを使用する必要があります。これにより、クライアントは、上位ナビゲーションと下向きナビゲーションが一貫している一貫したネームスペースをアプリケーションに提示することができます。"
    },
    {
      "indent": 3,
      "text": "Another issue concerns refresh of referral locations. When referrals are used extensively, they may change as server configurations change. It is expected that clients will cache information related to traversing referrals so that future client-side requests are resolved locally without server communication. This is usually rooted in client-side name look up caching. Clients should periodically purge this data for referral points in order to detect changes in location information. When the change_policy attribute changes for directories that hold referral entries or for the referral entries themselves, clients should consider any associated cached referral information to be out of date.",
      "ja": "もう一つの問題は紹介場所の更新に関するものです。紹介が広く使用されている場合は、サーバー構成が変更されたときに変更される可能性があります。クライアントがサーバー通信なしで将来のクライアントサイド要求がローカルに解決されるように、クライアントが通信を通過することに関する情報をキャッシュすることが予想されます。これは通常、クライアントサイドの名前が調べてキャッシュを調べます。位置情報の変更を検出するために、クライアントはこのデータを紹介ポイントに定期的にパージする必要があります。紹介エントリを保持するディレクトリまたは紹介エントリ自体のディレクトリに対してchange_policy属性が変更されると、クライアントは関連付けられているキャッシュされた紹介情報を時代遅れにする必要があります。"
    },
    {
      "indent": 0,
      "text": "11.9. Overview of File Access Transitions",
      "section_title": true,
      "ja": "11.9. ファイルアクセス遷移の概要"
    },
    {
      "indent": 3,
      "text": "File access transitions are of two types:",
      "ja": "ファイルアクセス遷移は2種類のものです。"
    },
    {
      "indent": 3,
      "text": "* Those that involve a transition from accessing the current replica to another one in connection with either replication or migration. How these are dealt with is discussed in Section 11.11.",
      "ja": "* 現在のレプリカへのアクセスから別のレプリカへのアクセスからの移行を含む。これらがどのように対処されるかについては、11.11節で議論されています。"
    },
    {
      "indent": 3,
      "text": "* Those in which access to the current file system instance is retained, while the network path used to access that instance is changed. This case is discussed in Section 11.10.",
      "ja": "* 現在のファイルシステムインスタンスへのアクセスが保持されているものが保持され、インスタンスにアクセスするために使用されるネットワークパスが変更されます。この場合については、11.10項で説明します。"
    },
    {
      "indent": 0,
      "text": "11.10. Effecting Network Endpoint Transitions",
      "section_title": true,
      "ja": "11.10. ネットワークエンドポイント遷移を実行します"
    },
    {
      "indent": 3,
      "text": "The endpoints used to access a particular file system instance may change in a number of ways, as listed below. In each of these cases, the same fsid, client IDs, filehandles, and stateids are used to continue access, with a continuity of lock state. In many cases, the same sessions can also be used.",
      "ja": "特定のファイルシステムインスタンスにアクセスするために使用されるエンドポイントは、以下のようにさまざまな方法で変わる可能性があります。これらの各ケースでは、同じFSID、クライアントID、FileHandles、およびStateIDがロック状態の継続性で、アクセスを継続するために使用されます。多くの場合、同じセッションを使用することもできます。"
    },
    {
      "indent": 3,
      "text": "The appropriate action depends on the set of replacement addresses that are available for use (i.e., server endpoints that are server-trunkable with one previously being used).",
      "ja": "適切なアクションは、使用可能な置換アドレスのセット（すなわち、以前に使用されているものとサーバートランク不能のサーバーエンドポイント）によって異なります。"
    },
    {
      "indent": 3,
      "text": "* When use of a particular address is to cease, and there is also another address currently in use that is server-trunkable with it, requests that would have been issued on the address whose use is to be discontinued can be issued on the remaining address(es). When an address is server-trunkable but not session-trunkable with the address whose use is to be discontinued, the request might need to be modified to reflect the fact that a different session will be used.",
      "ja": "* 特定のアドレスを使用することが解消され、現在使用されているアドレスも使用されているアドレスもあり、その使用が中止されるアドレスに発行された要求は残りのアドレスに発行されます（ES）。アドレスがサーバートランクタブルであるが、使用が中止されるアドレスを持つセッショントランク不能の場合、その要求は、異なるセッションが使用されるという事実を反映するように変更される必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "* When use of a particular connection is to cease, as indicated by receiving NFS4ERR_MOVED when using that connection, but that address is still indicated as accessible according to the appropriate file system location entries, it is likely that requests can be issued on a new connection of a different connection type once that connection is established. Since any two non-port-specific server endpoints that share a network address are inherently session-trunkable, the client can use BIND_CONN_TO_SESSION to access the existing session with the new connection.",
      "ja": "* その接続を使用するときにNFS4ERR_MOVEDを受信したように、特定の接続を使用する場合は、そのアドレスは依然として適切なファイルシステムの場所のエントリに従ってアクセス可能であると示されていますが、そのリクエストが新しい接続で発行される可能性があります。その接続が確立されると別の接続タイプ。ネットワークアドレスを共有する2つの非ポート固有のサーバーエンドポイントは、本質的にセッショントランク不能であるため、クライアントはBIND_CONN_TO_SESSISTを使用して新しい接続で既存のセッションにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "* When there are no potential replacement addresses in use, but there are valid addresses session-trunkable with the one whose use is to be discontinued, the client can use BIND_CONN_TO_SESSION to access the existing session using the new address. Although the target session will generally be accessible, there may be rare situations in which that session is no longer accessible when an attempt is made to bind the new connection to it. In this case, the client can create a new session to enable continued access to the existing instance using the new connection, providing for the use of existing filehandles, stateids, and client ids while supplying continuity of locking state.",
      "ja": "* 使用中に潜在的な交換アドレスがない場合は、使用が廃止されるものを使用して有効なアドレスがある場合、クライアントはBIND_CONN_TO_SESSIONを使用して新しいアドレスを使用して既存のセッションにアクセスできます。ターゲットセッションは一般的にアクセス可能であるが、そのセッションがそれに新しい接続をバインドすることが試みられたときにそのセッションがアクセスできない稀な状況があるかもしれない。この場合、クライアントは新しい接続を使用して既存のインスタンスへの継続的なアクセスを有効にするための新しいセッションを作成し、ロック状態の継続性を供給しながら既存のファイルハンドル、StateID、およびクライアントIDの使用を提供できます。"
    },
    {
      "indent": 3,
      "text": "* When there is no potential replacement address in use, and there are no valid addresses session-trunkable with the one whose use is to be discontinued, other server-trunkable addresses may be used to provide continued access. Although the use of CREATE_SESSION is available to provide continued access to the existing instance, servers have the option of providing continued access to the existing session through the new network access path in a fashion similar to that provided by session migration (see Section 11.12). To take advantage of this possibility, clients can perform an initial BIND_CONN_TO_SESSION, as in the previous case, and use CREATE_SESSION only if that fails.",
      "ja": "* 使用中に潜在的な交換アドレスがない場合、使用が廃止されるものを使用して有効なアドレスがない場合は、その他のサーバートランクアドレスを使用して継続的なアクセスを提供することができます。CREATE_SESSIONの使用は既存のインスタンスへの継続的なアクセスを提供するために使用可能ですが、サーバーは、セッションの移行によって提供されるものと同様の方法で、新しいネットワークアクセスパスを介して既存のセッションへの継続的なアクセスを提供することができます（セクション11.12を参照）。この可能性を利用するために、クライアントは前の場合と同様に、最初のbind_conn_to_sessionを実行し、それが失敗した場合にのみcreate_sessionを使用できます。"
    },
    {
      "indent": 0,
      "text": "11.11. Effecting File System Transitions",
      "section_title": true,
      "ja": "11.11. ファイルシステムの遷移の影響"
    },
    {
      "indent": 3,
      "text": "There are a range of situations in which there is a change to be effected in the set of replicas used to access a particular file system. Some of these may involve an expansion or contraction of the set of replicas used as discussed in Section 11.11.1 below.",
      "ja": "特定のファイルシステムにアクセスするために使用されるレプリカのセットで行われる変更がある範囲の状況がある。これらのうちのいくつかは、以下のセクション11.11で議論されるように使用されるレプリカのセットの伸縮を含み得る。"
    },
    {
      "indent": 3,
      "text": "For reasons explained in that section, most transitions will involve a transition from a single replica to a corresponding replacement replica. When effecting replica transition, some types of sharing between the replicas may affect handling of the transition as described in Sections 11.11.2 through 11.11.8 below. The attribute fs_locations_info provides helpful information to allow the client to determine the degree of inter-replica sharing.",
      "ja": "そのセクションで説明されている理由で、ほとんどの遷移は単一のレプリカから対応する交換レプリカへの移行を伴います。レプリカの遷移を実行すると、レプリカ間の一部の種類の共有は、以下のセクション11.11.2から11.11.8に記載されているように、遷移の処理に影響を与える可能性があります。属性FS_LOCATIONS_INFOは、クライアントがレプリカ間共有の程度を決定できるように役立つ情報を提供します。"
    },
    {
      "indent": 3,
      "text": "With regard to some types of state, the degree of continuity across the transition depends on the occasion prompting the transition, with transitions initiated by the servers (i.e., migration) offering much more scope for a nondisruptive transition than cases in which the client on its own shifts its access to another replica (i.e., replication). This issue potentially applies to locking state and to session state, which are dealt with below as follows:",
      "ja": "いくつかの種類の状態に関しては、遷移にわたる継続性の程度は、遷移を促すことに依存し、サーバによって開始された遷移（すなわち、移行）は、クライアントがそのクライアント上のクライアントが提供する場合よりもはるかに多くの範囲の範囲を提供する。自分自身が別のレプリカにアクセスする（すなわち、複製）。この問題は、次のように下記のように処理されているロック状態およびセッション状態に適用されます。"
    },
    {
      "indent": 3,
      "text": "* An introduction to the possible means of providing continuity in these areas appears in Section 11.11.9 below.",
      "ja": "* これらの分野での継続性を提供する可能性のある手段の紹介は、下のセクション11.11.9に表示されます。"
    },
    {
      "indent": 3,
      "text": "* Transparent State Migration is introduced in Section 11.12. The possible transfer of session state is addressed there as well.",
      "ja": "* 透明状態の移行はセクション11.12で紹介されています。セッション状態の転送可能な転送もそこにアドレス指定されます。"
    },
    {
      "indent": 3,
      "text": "* The client handling of transitions, including determining how to deal with the various means that the server might take to supply effective continuity of locking state, is discussed in Section 11.13.",
      "ja": "* さまざまな方法に対処する方法の決定を含む、サーバーがロック状態の有効な継続的な継続的な継続性を取ることがあることを決定することを含む、遷移のクライアント処理については、11.13項で説明します。"
    },
    {
      "indent": 3,
      "text": "* The source and destination servers' responsibilities in effecting Transparent State Migration of locking and session state are discussed in Section 11.14.",
      "ja": "* ロック状態とセッション状態の透過状態移行をもたらす際のソースサーバと宛先サーバの責任については、11.14項で説明しています。"
    },
    {
      "indent": 0,
      "text": "11.11.1. File System Transitions and Simultaneous Access",
      "section_title": true,
      "ja": "11.11.1. ファイルシステムの遷移と同時アクセス"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute (described in Section 11.17) may indicate that two replicas may be used simultaneously, although some situations in which such simultaneous access is permitted are more appropriately described as instances of trunking (see Section 11.5.4.1). Although situations in which multiple replicas may be accessed simultaneously are somewhat similar to those in which a single replica is accessed by multiple network addresses, there are important differences since locking state is not shared among multiple replicas.",
      "ja": "FS_LOCATIONS_INFO属性（セクション11.17で説明されている）は、このような同時アクセスが許可されている状況があるが、トランキングのインスタンスとしてより適切に説明されるが、2つのレプリカが同時に使用され得ることを示すことができる（セクション11.5.4.1参照）。複数のレプリカが同時にアクセスされる可能性がある状況は、複数のネットワークアドレスによって単一のレプリカがアクセスされるものと多少類似しているが、ロック状態は複数のレプリカ間で共有されないので重要な違いがある。"
    },
    {
      "indent": 3,
      "text": "Because of this difference in state handling, many clients will not have the ability to take advantage of the fact that such replicas represent the same data. Such clients will not be prepared to use multiple replicas simultaneously but will access each file system using only a single replica, although the replica selected might make multiple server-trunkable addresses available.",
      "ja": "この状態処理の違いのために、多くのクライアントは、そのようなレプリカが同じデータを表すという事実を利用する能力を持たないであろう。そのようなクライアントは複数のレプリカを同時に使用する準備はできませんが、1つのレプリカだけを使用して各ファイルシステムにアクセスします。"
    },
    {
      "indent": 3,
      "text": "Clients who are prepared to use multiple replicas simultaneously can divide opens among replicas however they choose. Once that choice is made, any subsequent transitions will treat the set of locking state associated with each replica as a single entity.",
      "ja": "複数のレプリカを同時に使用する準備ができているクライアントは、レプリカの間で分割することができますが、それらが選択します。その選択が行われると、後続の遷移は各レプリカに関連付けられているロック状態のセットを単一のエンティティとして扱います。"
    },
    {
      "indent": 3,
      "text": "For example, if one of the replicas become unavailable, access will be transferred to a different replica, which is also capable of simultaneous access with the one still in use.",
      "ja": "たとえば、レプリカの1つが利用できなくなると、アクセスは別のレプリカに転送されます。これは、まだ使用中の1つと同時アクセスが可能です。"
    },
    {
      "indent": 3,
      "text": "When there is no such replica, the transition may be to the replica already in use. At this point, the client has a choice between merging the locking state for the two replicas under the aegis of the sole replica in use or treating these separately until another replica capable of simultaneous access presents itself.",
      "ja": "そのようなレプリカがない場合、遷移はすでに使用されているレプリカになる可能性があります。この時点で、クライアントは、使用中の唯一のレプリカのAEGISの下にある2つのレプリカのロック状態をマージするか、または同時にアクセスできる別のレプリカがそれ自体を提示することができます。"
    },
    {
      "indent": 0,
      "text": "11.11.2. Filehandles and File System Transitions",
      "section_title": true,
      "ja": "11.11.2. ファイルハンドルとファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "There are a number of ways in which filehandles can be handled across a file system transition. These can be divided into two broad classes depending upon whether the two file systems across which the transition happens share sufficient state to effect some sort of continuity of file system handling.",
      "ja": "ファイルシステムの遷移を介してファイルハンドルを処理できる方法はいくつかあります。これらの遷移が発生する2つのファイルシステムが、ファイルシステム処理のある種の連続性を実行するのに十分な状態を共有するかどうかに応じて、2つの幅広クラスに分割できます。"
    },
    {
      "indent": 3,
      "text": "When there is no such cooperation in filehandle assignment, the two file systems are reported as being in different handle classes. In this case, all filehandles are assumed to expire as part of the file system transition. Note that this behavior does not depend on the fh_expire_type attribute and supersedes the specification of the FH4_VOL_MIGRATION bit, which only affects behavior when fs_locations_info is not available.",
      "ja": "ファイルハンドル割り当てでそのような協力がない場合、2つのファイルシステムは異なるハンドルクラスにあると報告されています。この場合、すべてのファイルハンドルはファイルシステムの遷移の一部として期限切れと見なされます。この動作はfh_expire_type属性には依存せず、FS_LOCATIONS_INFOが利用できない場合の動作にのみ影響するFH4_VOL_MIGRATIONビットの仕様に優先されます。"
    },
    {
      "indent": 3,
      "text": "When there is cooperation in filehandle assignment, the two file systems are reported as being in the same handle classes. In this case, persistent filehandles remain valid after the file system transition, while volatile filehandles (excluding those that are only volatile due to the FH4_VOL_MIGRATION bit) are subject to expiration on the target server.",
      "ja": "FileHandleの割り当てに協力がある場合、2つのファイルシステムは同じハンドルクラスにあると報告されています。この場合、永続的なファイルハンドルはファイルシステムの遷移後に有効なままですが、揮発性のファイルハンドル（FH4_VOL_MIGRATIONビットのために揮発性のみのものを除く）はターゲットサーバー上の有効期限を踏まえます。"
    },
    {
      "indent": 0,
      "text": "11.11.3. Fileids and File System Transitions",
      "section_title": true,
      "ja": "11.11.3. ファイルとファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "In NFSv4.0, the issue of continuity of fileids in the event of a file system transition was not addressed. The general expectation had been that in situations in which the two file system instances are created by a single vendor using some sort of file system image copy, fileids would be consistent across the transition, while in the analogous multi-vendor transitions they would not. This poses difficulties, especially for the client without special knowledge of the transition mechanisms adopted by the server. Note that although fileid is not a REQUIRED attribute, many servers support fileids and many clients provide APIs that depend on fileids.",
      "ja": "NFSv4.0では、ファイルシステム遷移が遷移した場合のfileIDの継続性の問題が解決されていませんでした。一般的な期待は、2つのファイルシステムインスタンスがある種のファイルシステムイメージコピーを使用して単一のベンダーによって作成されている状況では、類似のマルチベンダーの遷移では、ファイルIDは遷移に渡って一貫性があります。これは、サーバーによって採用された遷移メカニズムの特別な知識なしにクライアントのために困難をもたらす。fileIDは必須の属性ではありませんが、多くのサーバーはfileIDSをサポートし、多くのクライアントはfileIDに依存するAPIを提供します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that while clients themselves may have no trouble with a fileid changing as a result of a file system transition event, applications do typically have access to the fileid (e.g., via stat). The result is that an application may work perfectly well if there is no file system instance transition or if any such transition is among instances created by a single vendor, yet be unable to deal with the situation in which a multi-vendor transition occurs at the wrong time.",
      "ja": "クライアント自体がファイルシステム遷移イベントの結果としてFileIDの変更に問題がない可能性があるが、アプリケーションは通常、ファイルID（例えばStat）にアクセスできることに注意することが重要です。その結果、ファイルシステムインスタンスの移行がない場合、または単一のベンダーによって作成されたインスタンスの中にある場合は、アプリケーションが完全にうまく機能する可能性があります。間違った時間。"
    },
    {
      "indent": 3,
      "text": "Providing the same fileids in a multi-vendor (multiple server vendors) environment has generally been held to be quite difficult. While there is work to be done, it needs to be pointed out that this difficulty is partly self-imposed. Servers have typically identified fileid with inode number, i.e. with a quantity used to find the file in question. This identification poses special difficulties for migration of a file system between vendors where assigning the same index to a given file may not be possible. Note here that a fileid is not required to be useful to find the file in question, only that it is unique within the given file system. Servers prepared to accept a fileid as a single piece of metadata and store it apart from the value used to index the file information can relatively easily maintain a fileid value across a migration event, allowing a truly transparent migration event.",
      "ja": "マルチベンダー（複数のサーバーベンダー）環境に同じファイルIDを提供することは、一般に非常に困難であるために開催されました。行われるべき仕事があるが、この困難さが部分的に自己課されることを指摘する必要がある。サーバーは通常、iノード番号、すなわち、問題のファイルを見つけるために使用される数量を持つfileIDを識別しました。この識別は、特定のファイルに同じインデックスを割り当てることができないベンダ間のファイルシステムの移行に特別な困難をもたらす。ここで、fileIDが問題のファイルを見つけるのに便利であることは、指定されたファイルシステム内で一意であることだけです。サーバーは、単一のメタデータとしてFileIDを受け入れ、ファイル情報をインデックスするために使用される値とは別に保存することができます。"
    },
    {
      "indent": 3,
      "text": "In any case, where servers can provide continuity of fileids, they should, and the client should be able to find out that such continuity is available and take appropriate action. Information about the continuity (or lack thereof) of fileids across a file system transition is represented by specifying whether the file systems in question are of the same fileid class.",
      "ja": "いずれにせよ、サーバーはファイルIDの継続性を提供できる場合があり、クライアントはそのような継続性が利用可能であることを調べて適切な行動を取ることができるはずです。ファイルシステム遷移に渡ってファイルシステムの継続性（またはその欠如）に関する情報は、問題のファイルシステムが同じFileIDクラスのものであるかどうかを指定することによって表されます。"
    },
    {
      "indent": 3,
      "text": "Note that when consistent fileids do not exist across a transition (either because there is no continuity of fileids or because fileid is not a supported attribute on one of instances involved), and there are no reliable filehandles across a transition event (either because there is no filehandle continuity or because the filehandles are volatile), the client is in a position where it cannot verify that files it was accessing before the transition are the same objects. It is forced to assume that no object has been renamed, and, unless there are guarantees that provide this (e.g., the file system is read-only), problems for applications may occur. Therefore, use of such configurations should be limited to situations where the problems that this may cause can be tolerated.",
      "ja": "一貫したfileIDが遷移に存在しない場合（ファイルIDの継続性がないため、またはFileIDが含まれるインスタンスの1つのサポート属性ではないため）、遷移イベントにわたって信頼性の高いファイルハンドルはありません。ファイルハンドルの継続性やファイルハンドルが揮発性のためです）、クライアントは、遷移が同じオブジェクトの前にアクセスされているファイルがアクセスしていたことを確認できない位置にあります。オブジェクトが名前変更されていないと仮定し、これを提供する保証がない限り（例えば、ファイルシステムは読み取り専用）、アプリケーションの問題が発生する可能性があります。したがって、そのような構成の使用は、これが引き起こす可能性がある問題が許容される可能性がある状況に限定されるべきです。"
    },
    {
      "indent": 0,
      "text": "11.11.4. Fsids and File System Transitions",
      "section_title": true,
      "ja": "11.11.4. FSIDSとファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "Since fsids are generally only unique on a per-server basis, it is likely that they will change during a file system transition. Clients should not make the fsids received from the server visible to applications since they may not be globally unique, and because they may change during a file system transition event. Applications are best served if they are isolated from such transitions to the extent possible.",
      "ja": "FSIDSは一般的にサーバーごとに一意であるため、ファイルシステムの遷移中に変更される可能性があります。クライアントは、グローバルに一意ではない可能性があるため、サーバーから受信したFSIDをアプリケーションに表示させ、ファイルシステムの遷移イベント中に変更される可能性があるためです。それらが可能な限りそのような遷移から隔離されている場合、アプリケーションは最もよく提供されます。"
    },
    {
      "indent": 3,
      "text": "Although normally a single source file system will transition to a single target file system, there is a provision for splitting a single source file system into multiple target file systems, by specifying the FSLI4F_MULTI_FS flag.",
      "ja": "通常、単一のソースファイルシステムが単一のターゲットファイルシステムに移行するが、FSLI4F_MULTI_FSフラグを指定することによって、単一のソースファイルシステムを複数のターゲットファイルシステムに分割するためのプロビジョニングがある。"
    },
    {
      "indent": 0,
      "text": "11.11.4.1. File System Splitting",
      "section_title": true,
      "ja": "11.11.4.1. ファイルシステム分割"
    },
    {
      "indent": 3,
      "text": "When a file system transition is made and the fs_locations_info indicates that the file system in question might be split into multiple file systems (via the FSLI4F_MULTI_FS flag), the client SHOULD do GETATTRs to determine the fsid attribute on all known objects within the file system undergoing transition to determine the new file system boundaries.",
      "ja": "ファイルシステムの遷移が行われ、FS_LOCATIONS_INFOが問題のファイルシステムが（FSLI4F_MULTI_FSフラグを介して）複数のファイルシステムに分割される可能性があることを示す場合、クライアントはGetAttrsを実行して、実行中のファイルシステム内のすべての既知のオブジェクトのFSID属性を決定する必要があります。新しいファイルシステムの境界を決定するための移行"
    },
    {
      "indent": 3,
      "text": "Clients might choose to maintain the fsids passed to existing applications by mapping all of the fsids for the descendant file systems to the common fsid used for the original file system.",
      "ja": "クライアントは、子孫ファイルシステムのすべてのFSIDを元のファイルシステムに使用される一般的なFSIDにマッピングすることで、既存のアプリケーションに渡されるFSIDを維持することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Splitting a file system can be done on a transition between file systems of the same fileid class, since the fact that fileids are unique within the source file system ensure they will be unique in each of the target file systems.",
      "ja": "ファイルシステムのファイルシステム間の遷移では、ファイルIDがソースファイルシステム内で一意であることを確認しているため、ターゲットファイルシステムの各々で一意になることを確認してください。"
    },
    {
      "indent": 0,
      "text": "11.11.5. The Change Attribute and File System Transitions",
      "section_title": true,
      "ja": "11.11.5. 変更属性とファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "Since the change attribute is defined as a server-specific one, change attributes fetched from one server are normally presumed to be invalid on another server. Such a presumption is troublesome since it would invalidate all cached change attributes, requiring refetching. Even more disruptive, the absence of any assured continuity for the change attribute means that even if the same value is retrieved on refetch, no conclusions can be drawn as to whether the object in question has changed. The identical change attribute could be merely an artifact of a modified file with a different change attribute construction algorithm, with that new algorithm just happening to result in an identical change value.",
      "ja": "変更属性はサーバー固有のものとして定義されているため、1つのサーバーからフェッチされた変更属性は通常別のサーバーで無効になると推定されます。そのような推定は、すべてのキャッシュ変更属性を無効にし、リフェッチを必要とするため、面倒です。さらに中断されている、変更属性の保証された連続性がないことは、同じ値がリフェッチで取得されていても、問題のオブジェクトが変更されたかどうかに関して結論は描かれません。同一の変更属性は、単に異なる変更属性構築アルゴリズムを有する修正されたファイルの成果物であり得、その新しいアルゴリズムはただ起こっているだけで同一の変更値をもたらす。"
    },
    {
      "indent": 3,
      "text": "When the two file systems have consistent change attribute formats, and this fact is communicated to the client by reporting in the same change class, the client may assume a continuity of change attribute construction and handle this situation just as it would be handled without any file system transition.",
      "ja": "2つのファイルシステムが一貫した変更属性フォーマットを持ち、この事実が同じ変更クラスでの報告によってクライアントに伝達されると、クライアントは変更属性の構築の継続性をとり、ファイルなしで処理されるようにこの状況を処理することができます。システム遷移"
    },
    {
      "indent": 0,
      "text": "11.11.6. Write Verifiers and File System Transitions",
      "section_title": true,
      "ja": "11.11.6. 書き込み検証者とファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "In a file system transition, the two file systems might be cooperating in the handling of unstably written data. Clients can determine if this is the case by seeing if the two file systems belong to the same write-verifier class. When this is the case, write verifiers returned from one system may be compared to those returned by the other and superfluous writes can be avoided.",
      "ja": "ファイルシステムの遷移では、2つのファイルシステムは不安定な書き込みデータの処理に協力している可能性があります。クライアントは、2つのファイルシステムが同じWrite-Verifierクラスに属しているかどうかを確認することによって、これが事実であるかどうかを判断できます。この場合、1つのシステムから返された書き込み検証器を他のシステムから返され、余分な書き込みを回避することができる。"
    },
    {
      "indent": 3,
      "text": "When two file systems belong to different write-verifier classes, any verifier generated by one must not be compared to one provided by the other. Instead, the two verifiers should be treated as not equal even when the values are identical.",
      "ja": "2つのファイルシステムがさまざまなWrite Verifierクラスに属している場合、1つによって生成された任意の検証率は、もう一方が提供するものと比較されてはなりません。代わりに、2つの検証因子は、値が同じであっても等しくないように扱われます。"
    },
    {
      "indent": 0,
      "text": "11.11.7. READDIR Cookies and Verifiers and File System Transitions",
      "section_title": true,
      "ja": "11.11.7. READDIRクッキーと検証者とファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "In a file system transition, the two file systems might be consistent in their handling of READDIR cookies and verifiers. Clients can determine if this is the case by seeing if the two file systems belong to the same readdir class. When this is the case, readdir class, READDIR cookies, and verifiers from one system will be recognized by the other, and READDIR operations started on one server can be validly continued on the other simply by presenting the cookie and verifier returned by a READDIR operation done on the first file system to the second.",
      "ja": "ファイルシステムの遷移では、2つのファイルシステムはReadDir CookieとVerifiersの取り扱いに一貫している可能性があります。クライアントは、2つのファイルシステムが同じReadDirクラスに属しているかどうかを確認することによって、これが事実であるかどうかを判断できます。この場合、1つのシステムからのREADDIRクラス、READDIRクッキー、および検証者が他のシステムで認識され、1つのサーバーで開始されたREADDIRの操作は、READDIR操作によって返されるCookieとVerifierを提示するだけで、もう一方のサーバーで開始されます。2番目のファイルシステムで完了しました。"
    },
    {
      "indent": 3,
      "text": "When two file systems belong to different readdir classes, any READDIR cookie and verifier generated by one is not valid on the second and must not be presented to that server by the client. The client should act as if the verifier were rejected.",
      "ja": "2つのファイルシステムが異なるREADDIRクラスに属している場合、1つによって生成されたReadDir CookieとVerifierは2番目に無効であり、クライアントによってそのサーバーに表示されてはいけません。クライアントは、検証者が拒否されたかのように機能する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.11.8. File System Data and File System Transitions",
      "section_title": true,
      "ja": "11.11.8. ファイルシステムデータとファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "When multiple replicas exist and are used simultaneously or in succession by a client, applications using them will normally expect that they contain either the same data or data that is consistent with the normal sorts of changes that are made by other clients updating the data of the file system (with metadata being the same to the degree indicated by the fs_locations_info attribute). However, when multiple file systems are presented as replicas of one another, the precise relationship between the data of one and the data of another is not, as a general matter, specified by the NFSv4.1 protocol. It is quite possible to present as replicas file systems where the data of those file systems is sufficiently different that some applications have problems dealing with the transition between replicas. The namespace will typically be constructed so that applications can choose an appropriate level of support, so that in one position in the namespace, a varied set of replicas might be listed, while in another, only those that are up-to-date would be considered replicas. The protocol does define three special cases of the relationship among replicas to be specified by the server and relied upon by clients:",
      "ja": "複数のレプリカが存在し、クライアントによって同時にまたは連続して使用されている場合、それらを使用しているアプリケーションは通常、他のクライアントによって行われている通常の種類の変更と一致する同じデータまたはデータのいずれかを含むと予想されます。ファイルシステム（メタデータがFS_LOCATIONS_INFO属性によって示される程度に同じ）。ただし、複数のファイルシステムが互いのレプリカとして表示されている場合は、NFSV4.1プロトコルによって指定されている一般的な問題として、1つのデータと他のデータのデータとの間の正確な関係はありません。それらのファイルシステムのデータがレプリカ間の遷移に対処する問題があると、それらのファイルシステムのデータが十分に異なるレプリカファイルシステムとして存在することは非常に可能である。ネームスペースは通常、アプリケーションが適切なレベルのサポートを選択できるように構築され、名前空間内の1つの位置では、さまざまなレプリカのセットがリストされている可能性がありますが、最新のものだけがレプリカと見なされます。このプロトコルは、サーバーによって指定されるレプリカ間の関係の3つの特別なケースを定義し、クライアントによって依存しています。"
    },
    {
      "indent": 3,
      "text": "* When multiple replicas exist and are used simultaneously by a client (see the FSLIB4_CLSIMUL definition within fs_locations_info), they must designate the same data. Where file systems are writable, a change made on one instance must be visible on all instances at the same time, regardless of whether the interrogated instance is the one on which the modification was done. This allows a client to use these replicas simultaneously without any special adaptation to the fact that there are multiple replicas, beyond adapting to the fact that locks obtained on one replica are maintained separately (i.e., under a different client ID). In this case, locks (whether share reservations or byte-range locks) and delegations obtained on one replica are immediately reflected on all replicas, in the sense that access from all other servers is prevented regardless of the replica used. However, because the servers are not required to treat two associated client IDs as representing the same client, it is best to access each file using only a single client ID.",
      "ja": "* 複数のレプリカが存在し、クライアントによって同時に使用されます（FS_LOCATIONS_INFO内のFSLIB4_CLSIMUL定義を参照）、それらは同じデータを指定する必要があります。ファイルシステムが書き込み可能である場合、尋問されたインスタンスが変更が完了したものであるかどうかにかかわらず、1つのインスタンスで行われた変更は、すべてのインスタンスですべてのインスタンスで表示されなければなりません。これにより、1つのレプリカで取得されたロックが別々に維持されるという事実に適応することを超えて、クライアントがこれらのレプリカを同時に使用できます。この場合、ロック（共有予約またはバイトレンジロック）と1つのレプリカで取得された委任がすべてのレプリカにすぐに反映されます。これは、使用されるレプリカに関係なく、他のすべてのサーバーからのアクセスが防止されます。ただし、サーバーは、同じクライアントを表すものとして2つの関連するクライアントIDを扱う必要がないため、単一のクライアントIDのみを使用して各ファイルにアクセスするのが最善です。"
    },
    {
      "indent": 3,
      "text": "* When one replica is designated as the successor instance to another existing instance after the return of NFS4ERR_MOVED (i.e., the case of migration), the client may depend on the fact that all changes written to stable storage on the original instance are written to stable storage of the successor (uncommitted writes are dealt with in Section 11.11.6 above).",
      "ja": "* 1つのレプリカがNFS4ERR_MOVED（つまり、移行の場合）の後に別の既存のインスタンスへの後続インスタンスとして指定されている場合、クライアントは、元のインスタンス上の安定したストレージに書き込まれたすべての変更が安定したストレージに書き込まれるという事実によって異なります。後継者（コミットされていない書き込みは上記の11.11.6節で扱われます）。"
    },
    {
      "indent": 3,
      "text": "* Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, clients have similar requirements with regard to the propagation of updates. They may need a guarantee that any change visible on the original file system instance must be immediately visible on any replica before the client transitions access to that replica, in order to avoid any possibility that a client, in effecting a transition to a replica, will see any reversion in file system state. The specific means of this guarantee varies based on the value of the fss_type field that is reported as part of the fs_status attribute (see Section 11.18). Since these file systems are presumed to be unsuitable for simultaneous use, there is no specification of how locking is handled; in general, locks obtained on one file system will be separate from those on others. Since these are expected to be read-only file systems, this is not likely to pose an issue for clients or applications.",
      "ja": "* ファイルシステムが書き込み可能ではなく、書き込み可能なファイルシステムの読み取り専用コピー（おそらく定期的に更新）を表す場合、クライアントは更新の伝播に関して同様の要件を持っています。クライアントがそのレプリカへのアクセスを回避する前に、元のファイルシステムインスタンスに表示される変更は、クライアントがそのレプリカへのアクセスを妨げる前に、クライアントがレプリカへの移行を招く可能性を避けるために、任意の変更が必要である可能性があります。ファイルシステム状態の復帰を参照してください。この保証の特定の手段は、fs_status属性の一部として報告されているFSS_TYPEフィールドの値に基づいて変化します（セクション11.18を参照）。これらのファイルシステムは同時使用には不適切であると推定されるので、ロックの処理方法の仕様はありません。一般に、1つのファイルシステムで取得されたロックは他のファイルとは別のものとは異なります。これらは読み取り専用のファイルシステムであると予想されるので、これはクライアントまたはアプリケーションに問題を引き起こす可能性は低いです。"
    },
    {
      "indent": 3,
      "text": "When none of these special situations applies, there is no basis within the protocol for the client to make assumptions about the contents of a replica file system or its relationship to previous file system instances. Thus, switching between nominally identical read-write file systems would not be possible because either the client does not use the fs_locations_info attribute, or the server does not support it.",
      "ja": "これらの特別な状況のどれもが適用されない場合、クライアントのプロトコル内には、レプリカファイルシステムの内容または以前のファイルシステムインスタンスとの関係についての仮定を行うためのプロトコル内に基づいていません。したがって、クライアントがFS_LOCATIONS_INFO属性を使用しない、またはサーバーがそれをサポートしていないため、名目上同一の読み書きファイルシステム間の切り替えは不可能であろう。"
    },
    {
      "indent": 0,
      "text": "11.11.9. Lock State and File System Transitions",
      "section_title": true,
      "ja": "11.11.9. ロック状態とファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "While accessing a file system, clients obtain locks enforced by the server, which may prevent actions by other clients that are inconsistent with those locks.",
      "ja": "ファイルシステムにアクセスしている間、クライアントはサーバーによって強制されたロックを取得します。これは、それらのロックと矛盾する他のクライアントによるアクションを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "When access is transferred between replicas, clients need to be assured that the actions disallowed by holding these locks cannot have occurred during the transition. This can be ensured by the methods below. Unless at least one of these is implemented, clients will not be assured of continuity of lock possession across a migration event:",
      "ja": "Accessがレプリカ間で転送されると、これらのロックを保持して許可されていないアクションが遷移中に発生することができないことを保証する必要があります。これは以下の方法で保証することができます。これらのうち少なくとも1つが実装されていない限り、クライアントは移行イベントにわたるロック所有の継続性を保証されません。"
    },
    {
      "indent": 3,
      "text": "* Providing the client an opportunity to re-obtain his locks via a per-fs grace period on the destination server, denying all clients using the destination file system the opportunity to obtain new locks that conflict with those held by the transferred client as long as that client has not completed its per-fs grace period. Because the lock reclaim mechanism was originally defined to support server reboot, it implicitly assumes that filehandles will, upon reclaim, be the same as those at open. In the case of migration, this requires that source and destination servers use the same filehandles, as evidenced by using the same server scope (see Section 2.10.4) or by showing this agreement using fs_locations_info (see Section 11.11.2 above).",
      "ja": "* 宛先サーバ上のFS猶予期間を介して自分のロックを再取得する機会をクライアントに提供し、宛先ファイルシステムを使用してすべてのクライアントを拒否し、転送されたクライアントが保有する新しいロックを取得する機会を拒否するクライアントは、FSごとの猶予期間を完了していません。ロック再生メカニズムはサーバーの再起動をサポートするために最初に定義されていたため、ファイルハンドルが再利用すると、Open At Openと同じであると暗黙的に想定しています。移行の場合、これには、同じサーバーの範囲（セクション2.10.4を参照）を使用するか、またはFS_LOCATIONS_INFOを使用して本契約を示すことによって、ソースサーバーと宛先サーバーが同じファイルハンドルを使用する必要があります（上記の11.11.2項を参照）。"
    },
    {
      "indent": 6,
      "text": "Note that such a grace period can be implemented without interfering with the ability of non-transferred clients to obtain new locks while it is going on. As long as the destination server is aware of the transferred locks, it can distinguish requests to obtain new locks that contrast with existing locks from those that do not, allowing it to treat such client requests without reference to the ongoing grace period.",
      "ja": "そのような猶予期間は、転送されていないクライアントの能力を妨げることなく、それが起こっている間に新しいロックを取得することなく実装できます。宛先サーバーが転送されたロックを認識している限り、リクエストを区別することができ、既存のロックとは対照的な新しいロックを取得することができ、継続的な猶予期間を参照せずにそのようなクライアント要求を扱うことができます。"
    },
    {
      "indent": 3,
      "text": "* Locking state can be transferred as part of the transition by providing Transparent State Migration as described in Section 11.12.",
      "ja": "* ロック状態は、セクション11.12で説明されているように、透過的な状態移行を提供することによって遷移の一部として転送できます。"
    },
    {
      "indent": 3,
      "text": "Of these, Transparent State Migration provides the smoother experience for clients in that there is no need to go through a reclaim process before new locks can be obtained; however, it requires a greater degree of inter-server coordination. In general, the servers taking part in migration are free to provide either facility. However, when the filehandles can differ across the migration event, Transparent State Migration is the only available means of providing the needed functionality.",
      "ja": "これらのうち、透明状態の移行は、新しいロックが得られる前に再利用プロセスを通過する必要がないという点で、クライアントに対するより滑らかな経験を提供する。しかし、それはより高い程度のサーバー間調整を必要とします。一般に、移行に参加したサーバーはどちらの施設も自由に提供できます。ただし、ファイルハンドルが移行イベントで異なる可能性がある場合は、透過状態の移行が必要な機能を提供する唯一の利用可能な手段です。"
    },
    {
      "indent": 3,
      "text": "It should be noted that these two methods are not mutually exclusive and that a server might well provide both. In particular, if there is some circumstance preventing a specific lock from being transferred transparently, the destination server can allow it to be reclaimed by implementing a per-fs grace period for the migrated file system.",
      "ja": "これら2つの方法は相互に排他的ではなく、サーバーが両方を提供する可能性があることに注意してください。特に、特定のロックが透過的に転送されるのを防ぐ状況がある場合、移行先サーバーは移行されたファイルシステムのFSごとの猶予期間を実装することによって再生されることができます。"
    },
    {
      "indent": 0,
      "text": "11.11.9.1. Security Consideration Related to Reclaiming Lock State after File System Transitions",
      "ja": "11.11.9.1. ファイルシステムの遷移後のロック状態の再生に関するセキュリティ検討"
    },
    {
      "indent": 3,
      "text": "Although it is possible for a client reclaiming state to misrepresent its state in the same fashion as described in Section 8.4.2.1.1, most implementations providing for such reclamation in the case of file system transitions will have the ability to detect such misrepresentations. This limits the ability of unauthenticated clients to execute denial-of-service attacks in these circumstances. Nevertheless, the rules stated in Section 8.4.2.1.1 regarding principal verification for reclaim requests apply in this situation as well.",
      "ja": "8.4.2.1.1項で説明したのと同じ方法でクライアント再生状態を誤解させることは可能ですが、ファイルシステム遷移の場合にそのような再生を提供するほとんどの実装はそのような誤表現を検出する能力を持ちます。これにより、認証されていないクライアントがこれらの状況でサービス拒否攻撃を実行する能力が制限されます。それにもかかわらず、8.4.2.1.1節で述べられている規則は、再利用要求の主な検証に関する規則もこの状況でも適用されます。"
    },
    {
      "indent": 3,
      "text": "Typically, implementations that support file system transitions will have extensive information about the locks to be transferred. This is because of the following:",
      "ja": "通常、ファイルシステムの遷移をサポートする実装は、転送されるロックに関する広範な情報を持ちます。これは次の理由のためです。"
    },
    {
      "indent": 3,
      "text": "* Since failure is not involved, there is no need to store locking information in persistent storage.",
      "ja": "* 障害が含まれていないため、永続ストレージにロック情報を保存する必要はありません。"
    },
    {
      "indent": 3,
      "text": "* There is no need, as there is in the failure case, to update multiple repositories containing locking state to keep them in sync. Instead, there is a one-time communication of locking state from the source to the destination server.",
      "ja": "* 失敗した場合にあるので、ロック状態を含む複数のリポジトリを更新して同期に保つ必要はありません。代わりに、ソースから宛先サーバーへのロック状態の1回の通信があります。"
    },
    {
      "indent": 3,
      "text": "* Providing this information avoids potential interference with existing clients using the destination file system by denying them the ability to obtain new locks during the grace period.",
      "ja": "* この情報の提供は、猶予期間中に新しいロックを取得する能力を拒否することによって、宛先ファイルシステムを使用して既存のクライアントとの潜在的な干渉を回避します。"
    },
    {
      "indent": 3,
      "text": "When such detailed locking information, not necessarily including the associated stateids, is available:",
      "ja": "このような詳細なロック情報が、必ずしも関連するStateIDを含めるわけではありませんが、使用可能です。"
    },
    {
      "indent": 3,
      "text": "* It is possible to detect reclaim requests that attempt to reclaim locks that did not exist before the transfer, rejecting them with NFS4ERR_RECLAIM_BAD (Section 15.1.9.4).",
      "ja": "* 転送前に存在しなかったロックを再利用しようとし、NFS4ERR_RECLAIM_BADを拒否しようとするリククライミアクローズ要求を検出することができます（セクション15.1.9.4）。"
    },
    {
      "indent": 3,
      "text": "* It is possible when dealing with non-reclaim requests, to determine whether they conflict with existing locks, eliminating the need to return NFS4ERR_GRACE (Section 15.1.9.2) on non-reclaim requests.",
      "ja": "* reclaim以外のリクエストを処理するときに、既存のロックと競合するかどうかを判断することができ、Reclaim要求を非埋め込み要求にNFS4ERR_GRACE（セクション15.1.9.2）を返す必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "It is possible for implementations of grace periods in connection with file system transitions not to have detailed locking information available at the destination server, in which case, the security situation is exactly as described in Section 8.4.2.1.1.",
      "ja": "宛先サーバーで詳細なロック情報を利用できないファイルシステムの遷移に関連して猶予期間の実装は可能です。その場合、セキュリティの状況はセクション8.4.2.1.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "11.11.9.2. Leases and File System Transitions",
      "section_title": true,
      "ja": "11.11.9.2. リースとファイルシステムの遷移"
    },
    {
      "indent": 3,
      "text": "In the case of lease renewal, the client may not be submitting requests for a file system that has been transferred to another server. This can occur because of the lease renewal mechanism. The client renews the lease associated with all file systems when submitting a request on an associated session, regardless of the specific file system being referenced.",
      "ja": "リース更新の場合、クライアントは別のサーバーに転送されたファイルシステムに対する要求を送信していない可能性があります。これはリース更新機構のために発生する可能性があります。参照されている特定のファイルシステムに関係なく、クライアントは、関連付けられているセッションに対して要求を送信するときに、すべてのファイルシステムに関連付けられているリースを更新します。"
    },
    {
      "indent": 3,
      "text": "In order for the client to schedule renewal of its lease where there is locking state that may have been relocated to the new server, the client must find out about lease relocation before that lease expire. To accomplish this, the SEQUENCE operation will return the status bit SEQ4_STATUS_LEASE_MOVED if responsibility for any of the renewed locking state has been transferred to a new server. This will continue until the client receives an NFS4ERR_MOVED error for each of the file systems for which there has been locking state relocation.",
      "ja": "クライアントが新しいサーバーに移行された可能性があるロック状態がある可能性があるリースの更新をスケジュールするためには、そのリースの有効期限が切れる前にリースの再配置について調べなければなりません。これを達成するために、シーケンス操作は、更新されたロック状態のいずれかの責任が新しいサーバーに転送された場合、ステータスビットSEQ4_STATUS_LEASE_MOUD_MOUDを返します。これは、クライアントが状態の再配置がロックされていたファイルシステムごとにクライアントがNFS4ERR_VOVEDエラーを受信するまで続きます。"
    },
    {
      "indent": 3,
      "text": "When a client receives an SEQ4_STATUS_LEASE_MOVED indication from a server, for each file system of the server for which the client has locking state, the client should perform an operation. For simplicity, the client may choose to reference all file systems, but what is important is that it must reference all file systems for which there was locking state where that state has moved. Once the client receives an NFS4ERR_MOVED error for each such file system, the server will clear the SEQ4_STATUS_LEASE_MOVED indication. The client can terminate the process of checking file systems once this indication is cleared (but only if the client has received a reply for all outstanding SEQUENCE requests on all sessions it has with the server), since there are no others for which locking state has moved.",
      "ja": "クライアントがサーバーからSEQ4_STATUS_LEASE_MOUD_MOVEDを受信すると、クライアントがロック状態があるサーバーの各ファイルシステムに対して、クライアントは操作を実行する必要があります。簡単にするために、クライアントはすべてのファイルシステムを参照することを選択できますが、重要なのは、その状態が移動したロック状態があったすべてのファイルシステムを参照する必要があるということです。そのようなファイルシステムごとにクライアントがNFS4ERR_VOVEDエラーを受信すると、サーバーはSEQ4_STATUS_LEASE_MOUD_MOVED表示を消去します。この表示がクリアされたら、クライアントはファイルシステムをチェックするプロセスを終了できます（ただし、クライアントがサーバーとのすべてのセッションでのすべてのセッションですべての未処理のシーケンス要求に対して返信を受信した場合に限ります）。移動しました。"
    },
    {
      "indent": 3,
      "text": "A client may use GETATTR of the fs_status (or fs_locations_info) attribute on all of the file systems to get absence indications in a single (or a few) request(s), since absent file systems will not cause an error in this context. However, it still must do an operation that receives NFS4ERR_MOVED on each file system, in order to clear the SEQ4_STATUS_LEASE_MOVED indication.",
      "ja": "クライアントは、すべてのファイルシステムでFS_STATUS（またはFS_LOCATIONS_INFO）属性のgetAttrを使用して、存在しないファイルシステムがこのコンテキストでエラーを引き起こすことはないため、単一の（または数少ない）要求に欠席します。ただし、SEQ4_STATUS_LEASE_MOVED_MOVEDをクリアするために、各ファイルシステムでNFS4ERR_VOUDを受信する操作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the set of file systems with transferred locking state has been determined, the client can follow the normal process to obtain the new server information (through the fs_locations and fs_locations_info attributes) and perform renewal of that lease on the new server, unless information in the fs_locations_info attribute shows that no state could have been transferred. If the server has not had state transferred to it transparently, the client will receive NFS4ERR_STALE_CLIENTID from the new server, as described above, and the client can then reclaim locks as is done in the event of server failure.",
      "ja": "転送されたロック状態を持つファイルシステムのセットが決定されると、クライアントは通常のプロセスに従って（FS_LOCATIONATIONSおよびFS_LOCATIONS_INFO属性を介して）新しいサーバー情報を取得し、その中の情報がない限り、新しいサーバー情報を取得し、そのリースの更新を実行できます。fs_locations_info属性は、状態が転送された可能性がないことを示しています。サーバーに透過的に転送されていない場合、上記のようにクライアントは新しいサーバーからNFS4ERR_STALE_CLIENTIDIDを受け取り、サーバーの障害発生時に実行されるようにロックを再利用できます。"
    },
    {
      "indent": 0,
      "text": "11.11.9.3. Transitions and the Lease_time Attribute",
      "section_title": true,
      "ja": "11.11.9.3. トランジションとLEASE_TIME属性"
    },
    {
      "indent": 3,
      "text": "In order that the client may appropriately manage its lease in the case of a file system transition, the destination server must establish proper values for the lease_time attribute.",
      "ja": "ファイルシステム遷移の場合、クライアントがそのリースを適切に管理できるようにするために、宛先サーバはLEASE_TIME属性に適切な値を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source, since this would result in premature expiration of a lease granted by the source server. Upon transitions in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).",
      "ja": "状態が透過的に転送されると、その状態はLEASE_TIME属性の正しい値を含める必要があります。宛先サーバー上のLEASE_TIME属性は、ソースサーバーによって許可されたリースの時期尚早の有効期限があるため、ソースのリースよりも小さいことはありません。状態が透過的に転送される遷移が、クライアントはLEASE_TIME属性を参照していない義務を負い、以前にフェッチされた値を使用し続けることがあります（ソースサーバ上）。"
    },
    {
      "indent": 3,
      "text": "If state has not been transferred transparently, either because the associated servers are shown as having different eir_server_scope strings or because the client ID is rejected when presented to the new server, the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However, the server must respect a grace period of at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their lock before potentially conflicting non-reclaimed locks are granted.",
      "ja": "関連付けられたサーバーが異なるEIR_SERVER_SCOPE文字列を持つものとして表示されていない場合、またはクライアントIDが新しいサーバーに提示されたときに拒否されるため、クライアントは新しいサーバーに拒否されているため、クライアントは新しい（IE、宛先）のLEASE_TIMEの値を取得する必要があります。サーバー、後続のロック要求に使用します。ただし、潜在的に競合していないロックが付与される前に、クライアントが自分のロックを再利用するためにクライアントが自分のロックを再利用するようにするために、サーバーはソースサーバー上のLease_timeの猶予期間を尊重しなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.12. Transferring State upon Migration",
      "section_title": true,
      "ja": "11.12. 移行時の状態を転送する"
    },
    {
      "indent": 3,
      "text": "When the transition is a result of a server-initiated decision to transition access, and the source and destination servers have implemented appropriate cooperation, it is possible to do the following:",
      "ja": "遷移が移行アクセスへのサーバー開始決定の結果、および送信元および宛先サーバーが適切な協力を実行した場合、次のことが可能です。"
    },
    {
      "indent": 3,
      "text": "* Transfer locking state from the source to the destination server in a fashion similar to that provided by Transparent State Migration in NFSv4.0, as described in [69]. Server responsibilities are described in Section 11.14.2.",
      "ja": "* [69]で説明されているように、NFSv4.0で透過状態の移行によって提供されるものと同様の方法で、ソースから宛先サーバーへのロック状態を転送します。サーバーの責任は、11.14.2項で説明されています。"
    },
    {
      "indent": 3,
      "text": "* Transfer session state from the source to the destination server. Server responsibilities in effecting such a transfer are described in Section 11.14.3.",
      "ja": "* ソースから宛先サーバーへのセッション状態を転送します。そのような転送をもたらす際のサーバ責任は、11.14.3項で説明されています。"
    },
    {
      "indent": 3,
      "text": "The means by which the client determines which of these transfer events has occurred are described in Section 11.13.",
      "ja": "クライアントがこれらの転送イベントのどれが発生したかを決定する手段は、セクション11.13で説明されている。"
    },
    {
      "indent": 0,
      "text": "11.12.1. Transparent State Migration and pNFS",
      "section_title": true,
      "ja": "11.12.1. 透明状態の移行とPNFS"
    },
    {
      "indent": 3,
      "text": "When pNFS is involved, the protocol is capable of supporting:",
      "ja": "PNFSが関与している場合、プロトコルはサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "* Migration of the Metadata Server (MDS), leaving the Data Servers (DSs) in place.",
      "ja": "* メタデータサーバ（MDS）の移行、データサーバ（DSS）を所定の位置に残します。"
    },
    {
      "indent": 3,
      "text": "* Migration of the file system as a whole, including the MDS and associated DSs.",
      "ja": "* MDSと関連DSSを含む、ファイルシステム全体としての移行。"
    },
    {
      "indent": 3,
      "text": "* Replacement of one DS by another.",
      "ja": "* あるDSを別のDSによる交換。"
    },
    {
      "indent": 3,
      "text": "* Migration of a pNFS file system to one in which pNFS is not used.",
      "ja": "* PNFSファイルシステムをPNFSが使用されていないものへの移行。"
    },
    {
      "indent": 3,
      "text": "* Migration of a file system not using pNFS to one in which layouts are available.",
      "ja": "* ファイルシステムのマイグレーションは、PNFをレイアウトが利用可能になるものに使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Note that migration, per se, is only involved in the transfer of the MDS function. Although the servicing of a layout may be transferred from one data server to another, this not done using the file system location attributes. The MDS can effect such transfers by recalling or revoking existing layouts and granting new ones on a different data server.",
      "ja": "移行単独では、MDS機能の転送にのみ関与していることに注意してください。レイアウトの処理は1つのデータサーバーから別のデータサーバーに転送される可能性がありますが、これはファイルシステムの場所属性を使用して行われません。MDSは、既存のレイアウトを呼び出したり、異なるデータサーバー上で新しいデータを付与することで、そのような転送を実行できます。"
    },
    {
      "indent": 3,
      "text": "Migration of the MDS function is directly supported by Transparent State Migration. Layout state will normally be transparently transferred, just as other state is. As a result, Transparent State Migration provides a framework in which, given appropriate inter-MDS data transfer, one MDS can be substituted for another.",
      "ja": "MDS関数のマイグレーションは、透過状態の移行によって直接サポートされています。他の状態のように、レイアウト状態は通常透過的に転送されます。その結果、透明状態の移行は、適切なMDS間データ転送を与えられたフレームワークを提供し、それは1つのMDSを別のMDSに置き換えることができる。"
    },
    {
      "indent": 3,
      "text": "Migration of the file system function as a whole can be accomplished by recalling all layouts as part of the initial phase of the migration process. As a result, I/O will be done through the MDS during the migration process, and new layouts can be granted once the client is interacting with the new MDS. An MDS can also effect this sort of transition by revoking all layouts as part of Transparent State Migration, as long as the client is notified about the loss of locking state.",
      "ja": "ファイルシステム機能全体の移行は、移行プロセスの初期フェーズの一部としてすべてのレイアウトを呼び出すことによって実現できます。その結果、移行プロセス中にI / OがMDSを介して行われ、クライアントが新しいMDSと対話していると新しいレイアウトを許可することができます。クライアントがロック状態の損失について通知されている限り、MDSは、クライアントが通知されている限り、すべてのレイアウトを透過状態移行の一部として取り消すことによってこの種の移行を実行することもできます。"
    },
    {
      "indent": 3,
      "text": "In order to allow migration to a file system on which pNFS is not supported, clients need to be prepared for a situation in which layouts are not available or supported on the destination file system and so direct I/O requests to the destination server, rather than depending on layouts being available.",
      "ja": "PNFSがサポートされていないファイルシステムへの移行を可能にするために、レイアウトが利用できない、または宛先ファイルシステムでサポートされている状況に対してクライアントを作成する必要があります。利用可能なレイアウトに依存しています。"
    },
    {
      "indent": 3,
      "text": "Replacement of one DS by another is not addressed by migration as such but can be effected by an MDS recalling layouts for the DS to be replaced and issuing new ones to be served by the successor DS.",
      "ja": "別のDSを交換することは、そのようなものとして移行することによって対処されていないが、後継者DSによって処理されるべきDSのためのMDSリコールレイアウトによって行われ、新しいものを発行することができる。"
    },
    {
      "indent": 3,
      "text": "Migration may transfer a file system from a server that does not support pNFS to one that does. In order to properly adapt to this situation, clients that support pNFS, but function adequately in its absence, should check for pNFS support when a file system is migrated and be prepared to use pNFS when support is available on the destination.",
      "ja": "移行は、PNFSをサポートしていないサーバーからファイルシステムを実行することができます。この状況に適応するために、PNFSをサポートするクライアントが、ファイルシステムが移行されたときにPNFSのサポートをチェックし、宛先でサポートが利用可能な場合はPNFSを使用する準備をしてください。"
    },
    {
      "indent": 0,
      "text": "11.13. Client Responsibilities When Access Is Transitioned",
      "section_title": true,
      "ja": "11.13. アクセスが移行中のクライアントの責任"
    },
    {
      "indent": 3,
      "text": "For a client to respond to an access transition, it must become aware of it. The ways in which this can happen are discussed in Section 11.13.1, which discusses indications that a specific file system access path has transitioned as well as situations in which additional activity is necessary to determine the set of file systems that have been migrated. Section 11.13.2 goes on to complete the discussion of how the set of migrated file systems might be determined. Sections 11.13.3 through 11.13.5 discuss how the client should deal with each transition it becomes aware of, either directly or as a result of migration discovery.",
      "ja": "クライアントがアクセス遷移に応答するためには、それを認識しなければなりません。これが発生する可能性のある方法はセクション11.13.1で議論されています。これは、特定のファイルシステムアクセスパスが移行されたという表示と移行されたファイルシステムのセットを決定するために必要なアクティビティが必要な状況を説明します。セクション11.13.2は、移行されたファイルシステムのセットの決定方法の説明を完了します。セクション11.13.3から11.13.5クライアントが各遷移にどのように対処すべきかについて説明し、直接または移行発見の結果として認識されます。"
    },
    {
      "indent": 3,
      "text": "The following terms are used to describe client activities:",
      "ja": "以下の用語は、クライアントの活動を説明するために使用されます。"
    },
    {
      "indent": 3,
      "text": "* \"Transition recovery\" refers to the process of restoring access to a file system on which NFS4ERR_MOVED was received.",
      "ja": "* 「移行回復」とは、NFS4ERR_MOVEDが受信されたファイルシステムへのアクセスを復元するプロセスを指します。"
    },
    {
      "indent": 3,
      "text": "* \"Migration recovery\" refers to that subset of transition recovery that applies when the file system has migrated to a different replica.",
      "ja": "* 「移行回復」とは、ファイルシステムが別のレプリカに移行されたときに適用される遷移回復のサブセットを指します。"
    },
    {
      "indent": 3,
      "text": "* \"Migration discovery\" refers to the process of determining which file system(s) have been migrated. It is necessary to avoid a situation in which leases could expire when a file system is not accessed for a long period of time, since a client unaware of the migration might be referencing an unmigrated file system and not renewing the lease associated with the migrated file system.",
      "ja": "* 「移行発見」とは、どのファイルシステムが移行されたかを判断するプロセスを指す。移行の認識されていないクライアントがマイグレーションされていないファイルシステムを参照し、移行されたファイルに関連付けられているリースの更新を行っていない可能性があるため、リースが長期間にわたってリースが期限切れになることがある状況を回避することが必要です。システム。"
    },
    {
      "indent": 0,
      "text": "11.13.1. Client Transition Notifications",
      "section_title": true,
      "ja": "11.13.1. クライアント遷移通知"
    },
    {
      "indent": 3,
      "text": "When there is a change in the network access path that a client is to use to access a file system, there are a number of related status indications with which clients need to deal:",
      "ja": "クライアントがファイルシステムにアクセスするために使用するネットワークアクセスパスに変更がある場合、クライアントが取引が必要な関連状況表示がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "* If an attempt is made to use or return a filehandle within a file system that is no longer accessible at the address previously used to access it, the error NFS4ERR_MOVED is returned.",
      "ja": "* アクセスして以前にアクセスしたアドレスでアクセスできないファイルシステム内でファイルハンドルを使用しようとした場合、エラーNFS4ERR_MOUDが返されます。"
    },
    {
      "indent": 6,
      "text": "Exceptions are made to allow such filehandles to be used when interrogating a file system location attribute. This enables a client to determine a new replica's location or a new network access path.",
      "ja": "ファイルシステムの場所属性を尋問するときにそのようなファイルハンドルを使用できるようにする例外があります。これにより、クライアントは新しいレプリカの場所または新しいネットワークアクセスパスを決定できます。"
    },
    {
      "indent": 6,
      "text": "This condition continues on subsequent attempts to access the file system in question. The only way the client can avoid the error is to cease accessing the file system in question at its old server location and access it instead using a different address at which it is now available.",
      "ja": "この条件は、問題のファイルシステムにアクセスしようとした後続の試みに続きます。クライアントがエラーを回避できる唯一の方法は、古いサーバーの場所での問題のファイルシステムへのアクセスを中止し、現在利用可能なさまざまなアドレスを使用してアクセスします。"
    },
    {
      "indent": 3,
      "text": "* Whenever a client sends a SEQUENCE operation to a server that generated state held on that client and associated with a file system no longer accessible on that server, the response will contain the status bit SEQ4_STATUS_LEASE_MOVED, indicating that there has been a lease migration.",
      "ja": "* クライアントがそのクライアント上で保持され、そのクライアントに保存されていてファイルシステムに関連付けられていないサーバーにシーケンス操作を送信するたびに、その応答にステータスビットSEQ4_STATUS_LEASE_MOVEDが含まれ、リースマイグレーションがあったことを示します。"
    },
    {
      "indent": 6,
      "text": "This condition continues until the client acknowledges the notification by fetching a file system location attribute for the file system whose network access path is being changed. When there are multiple such file systems, a location attribute for each such file system needs to be fetched. The location attribute for all migrated file systems needs to be fetched in order to clear the condition. Even after the condition is cleared, the client needs to respond by using the location information to access the file system at its new location to ensure that leases are not needlessly expired.",
      "ja": "この条件は、ネットワークアクセスパスが変更されているファイルシステムのファイルシステムの場所属性を取得して、クライアントが通知を確認するまで続きます。複数のそのようなファイルシステムがある場合、そのようなファイルシステムごとに位置属性を取り出す必要があります。条件をクリアするために、すべての移行されたファイルシステムのLocation属性を取得する必要があります。条件がクリアされた後でさえ、クライアントはロケーション情報を使用して新しい場所でファイルシステムにアクセスすることによって応答する必要があります。リースが不必要に期限切れにならないことを確認します。"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv4.0, in which the corresponding conditions are both errors and thus mutually exclusive, in NFSv4.1 the client can, and often will, receive both indications on the same request. As a result, implementations need to address the question of how to coordinate the necessary recovery actions when both indications arrive in the response to the same request. It should be noted that when processing an NFSv4 COMPOUND, the server will normally decide whether SEQ4_STATUS_LEASE_MOVED is to be set before it determines which file system will be referenced or whether NFS4ERR_MOVED is to be returned.",
      "ja": "NFSv4.0とは異なり、対応する条件は両方ともエラーであり、したがって相互に排他的なNFSV4.1では、クライアントは同じ要求に対して両方の表示を受け取ることができます。その結果、同じ要求に対する応答に到着したときに必要な回復アクションを調整する方法の問題に対処する必要があります。なお、NFSV4コンパウンドを処理する場合、サーバは通常、どのファイルシステムが参照されるか、またはNFS4ERR_MOUDが返されるかを決定する前にSEQ4_STATUS_LEASE_MOUMESを設定するかどうかを決定することに留意されたい。"
    },
    {
      "indent": 3,
      "text": "Since these indications are not mutually exclusive in NFSv4.1, the following combinations are possible results when a COMPOUND is issued:",
      "ja": "これらの指示はNFSV4.1では相互に排他的ではないため、化合物が発行されたときに次の組み合わせが可能です。"
    },
    {
      "indent": 3,
      "text": "* The COMPOUND status is NFS4ERR_MOVED, and SEQ4_STATUS_LEASE_MOVED is asserted.",
      "ja": "* 複合状況はNFS4ERR_MOUXで、SEQ4_STATUS_LEASE_MOUMESがアサートされます。"
    },
    {
      "indent": 6,
      "text": "In this case, transition recovery is required. While it is possible that migration discovery is needed in addition, it is likely that only the accessed file system has transitioned. In any case, because addressing NFS4ERR_MOVED is necessary to allow the rejected requests to be processed on the target, dealing with it will typically have priority over migration discovery.",
      "ja": "この場合、遷移回復が必要です。さらに、移行発見が必要な場合は、アクセスしたファイルシステムのみが移行した可能性があります。いずれにせよ、拒否された要求をターゲット上で処理することを許可するためにアドレス指定する必要があるため、これに対処するためには通常、移行発見に対する優先順位が優先されます。"
    },
    {
      "indent": 3,
      "text": "* The COMPOUND status is NFS4ERR_MOVED, and SEQ4_STATUS_LEASE_MOVED is clear.",
      "ja": "* 複合状況はNFS4ERR_MOUX、SEQ4_STATUS_LEASE_MOUMEDはクリアです。"
    },
    {
      "indent": 6,
      "text": "In this case, transition recovery is also required. It is clear that migration discovery is not needed to find file systems that have been migrated other than the one returning NFS4ERR_MOVED. Cases in which this result can arise include a referral or a migration for which there is no associated locking state. This can also arise in cases in which an access path transition other than migration occurs within the same server. In such a case, there is no need to set SEQ4_STATUS_LEASE_MOVED, since the lease remains associated with the current server even though the access path has changed.",
      "ja": "この場合、遷移回復も必要です。NFS4ER_MOUDを返すもの以外に移行されたファイルシステムを見つけるためにマイグレーション検出が必要ではないことは明らかです。この結果が生じる可能性があるケースには、関連付けられたロック状態がない紹介またはマイグレーションが含まれます。これは、移行以外のアクセスパス遷移が同じサーバ内で発生する場合にも起こり得る。そのような場合、アクセスパスが変更されていても、リースは現在のサーバに関連付けられたままになるので、seq4_status_lease_movedを設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "* The COMPOUND status is not NFS4ERR_MOVED, and SEQ4_STATUS_LEASE_MOVED is asserted.",
      "ja": "* 複合状況はNFS4ERR_MOUXではなく、seq4_status_lease_movedがアサートされています。"
    },
    {
      "indent": 6,
      "text": "In this case, no transition recovery activity is required on the file system(s) accessed by the request. However, to prevent avoidable lease expiration, migration discovery needs to be done.",
      "ja": "この場合、要求によってアクセスされるファイルシステムに遷移回復アクティビティは必要ありません。ただし、避けられないリース期限が切れるのを防ぐために、移行発見を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "* The COMPOUND status is not NFS4ERR_MOVED, and SEQ4_STATUS_LEASE_MOVED is clear.",
      "ja": "* 複合状況はNFS4ERR_MOUDではなく、SEQ4_STATUS_LEASE_MOUMEDは明らかです。"
    },
    {
      "indent": 6,
      "text": "In this case, neither transition-related activity nor migration discovery is required.",
      "ja": "この場合、遷移関連アクティビティもマイグレーションディスカバリも必要とされません。"
    },
    {
      "indent": 3,
      "text": "Note that the specified actions only need to be taken if they are not already going on. For example, when NFS4ERR_MOVED is received while accessing a file system for which transition recovery is already occurring, the client merely waits for that recovery to be completed, while the receipt of the SEQ4_STATUS_LEASE_MOVED indication only needs to initiate migration discovery for a server if such discovery is not already underway for that server.",
      "ja": "指定されたアクションはまだ起動していない場合にのみ取得する必要があります。たとえば、遷移回復がすでに発生しているファイルシステムにアクセスしている間にNFS4ERR_MOUDが受信された場合、クライアントは単にその回復を終了するだけでなく、SEQ4_STATUS_LEASE_MOVED表示の受信はサーバーの移行検出を開始するだけで済みます。そのサーバーにはまだ進行していません。"
    },
    {
      "indent": 3,
      "text": "The fact that a lease-migrated condition does not result in an error in NFSv4.1 has a number of important consequences. In addition to the fact that the two indications are not mutually exclusive, as discussed above, there are number of issues that are important in considering implementation of migration discovery, as discussed in Section 11.13.2.",
      "ja": "リース移行条件がNFSV4.1でエラーを引き起こさないという事実は、いくつかの重要な影響を及ぼします。2つの指示が相互に排他的ではないという事実に加えて、11.13.2項で説明したように、移行発見の実施を考慮する上で重要な問題がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "Because SEQ4_STATUS_LEASE_MOVED is not an error condition, it is possible for file systems whose access paths have not changed to be successfully accessed on a given server even though recovery is necessary for other file systems on the same server. As a result, access can take place while:",
      "ja": "SEQ4_STATUS_LEASE_MOUD_MOUDはエラー状態ではないため、同じサーバー上の他のファイルシステムには回復が必要であっても、アクセスパスが特定のサーバー上で正常にアクセスされていないファイルシステムが可能です。その結果、アクセスが行われる可能性があります。"
    },
    {
      "indent": 3,
      "text": "* The migration discovery process is happening for that server.",
      "ja": "* 移行発見プロセスはそのサーバーで起こっています。"
    },
    {
      "indent": 3,
      "text": "* The transition recovery process is happening for other file systems connected to that server.",
      "ja": "* 遷移回復プロセスは、そのサーバーに接続されている他のファイルシステムの場合に起こります。"
    },
    {
      "indent": 0,
      "text": "11.13.2. Performing Migration Discovery",
      "section_title": true,
      "ja": "11.13.2. 移行発見の実行"
    },
    {
      "indent": 3,
      "text": "Migration discovery can be performed in the same context as transition recovery, allowing recovery for each migrated file system to be invoked as it is discovered. Alternatively, it may be done in a separate migration discovery thread, allowing migration discovery to be done in parallel with one or more instances of transition recovery.",
      "ja": "移行回復と同じコンテキストでマイグレーション検出を実行でき、移行された各ファイルシステムの回復が発見されたときに呼び出されることができます。あるいは、それは別々の移行発見スレッドで行われてもよく、移行回復の1つまたは複数のインスタンスと並行してマイグレーション検出を行うことができる。"
    },
    {
      "indent": 3,
      "text": "In either case, because the lease-migrated indication does not result in an error, other access to file systems on the server can proceed normally, with the possibility that further such indications will be received, raising the issue of how such indications are to be dealt with. In general:",
      "ja": "どちらの場合でも、リース移行指示にエラーが発生しないため、サーバー上のファイルシステムへのその他のファイルシステムへのアクセスは正常に進むことができ、そのような表示が受信される可能性は、そのような指示がどのように受信される可能性があります。対処しました。一般に："
    },
    {
      "indent": 3,
      "text": "* No action needs to be taken for such indications received by any threads performing migration discovery, since continuation of that work will address the issue.",
      "ja": "* その作業の継続は問題に対処するため、移行発見を実行するスレッドによって受信されたそのような指示に対して行動はありません。"
    },
    {
      "indent": 3,
      "text": "* In other cases in which migration discovery is currently being performed, nothing further needs to be done to respond to such lease migration indications, as long as one can be certain that the migration discovery process would deal with those indications. See below for details.",
      "ja": "* 移行発見が現在実行されている他の場合では、移行発見プロセスがそれらの適応症に対処することを確実にすることができる限り、そのようなリース移行指示に応答するためにさらに実行する必要はありません。詳しくは下記参照してください。"
    },
    {
      "indent": 3,
      "text": "* For such indications received in all other contexts, the appropriate response is to initiate or otherwise provide for the execution of migration discovery for file systems associated with the server IP address returning the indication.",
      "ja": "* 他のすべてのコンテキストで受信されたそのような指示のために、適切な応答は、表示を返すサーバIPアドレスに関連するファイルシステムに対する移行発見の実行を開始またはそうでなければ提供することである。"
    },
    {
      "indent": 3,
      "text": "This leaves a potential difficulty in situations in which the migration discovery process is near to completion but is still operating. One should not ignore a SEQ4_STATUS_LEASE_MOVED indication if the migration discovery process is not able to respond to the discovery of additional migrating file systems without additional aid. A further complexity relevant in addressing such situations is that a lease-migrated indication may reflect the server's state at the time the SEQUENCE operation was processed, which may be different from that in effect at the time the response is received. Because new migration events may occur at any time, and because a SEQ4_STATUS_LEASE_MOVED indication may reflect the situation in effect a considerable time before the indication is received, special care needs to be taken to ensure that SEQ4_STATUS_LEASE_MOVED indications are not inappropriately ignored.",
      "ja": "これは、移行発見プロセスが完了の近くにあるがまだ動作している状況において潜在的な困難を残す。移行発見プロセスが追加の援助なしで追加の移行ファイルシステムの発見に応答できない場合、SEQ4_STATUS_LEASE_MOVEDを無視してはいけません。そのような状況に対処することに関連するさらなる複雑さは、リース移動された指示がシーケンス操作が処理された時点でサーバの状態を反映している可能性があるため、応答が受信される時点での効果とは異なる可能性がある。新しい移行イベントがいつでも発生する可能性があるため、SEQ4_STATUS_LEASE_MOVED表示は、表示が受信されるまでにかなりの時間がかなりの時間を反映している可能性があるため、SEQ4_STATUS_LEASE_MOVED表示が不適切でないことを確認するために特別な注意が必要です。"
    },
    {
      "indent": 3,
      "text": "A useful approach to this issue involves the use of separate externally-visible migration discovery states for each server. Separate values could represent the various possible states for the migration discovery process for a server:",
      "ja": "この問題に対する便利なアプローチは、サーバーごとに別々の外部表示された移行発見状態の使用を含みます。別の値は、サーバーの移行検出プロセスのためにさまざまな可能な状態を表すことができます。"
    },
    {
      "indent": 3,
      "text": "* Non-operation, in which migration discovery is not being performed.",
      "ja": "* 移行発見が実行されていない非操作。"
    },
    {
      "indent": 3,
      "text": "* Normal operation, in which there is an ongoing scan for migrated file systems.",
      "ja": "* マイグレーションされたファイルシステムに継続的なスキャンがある通常の操作。"
    },
    {
      "indent": 3,
      "text": "* Completion/verification of migration discovery processing, in which the possible completion of migration discovery processing needs to be verified.",
      "ja": "* 移行発見処理の完了/検証は、移行発見処理の完了が検証される必要がある。"
    },
    {
      "indent": 3,
      "text": "Given that framework, migration discovery processing would proceed as follows:",
      "ja": "そのフレームワークを考えると、移行発見処理は次のように進められます。"
    },
    {
      "indent": 3,
      "text": "* While in the normal-operation state, the thread performing discovery would fetch, for successive file systems known to the client on the server being worked on, a file system location attribute plus the fs_status attribute.",
      "ja": "* 通常動作状態では、サーバ上のクライアントで認識されている連続ファイルシステムの場合、ファイルシステムのロケーション属性とFS_STATUS属性とを処理するために、発見を実行するスレッドはフェッチします。"
    },
    {
      "indent": 3,
      "text": "* If the fs_status attribute indicates that the file system is a migrated one (i.e., fss_absent is true, and fss_type != STATUS4_REFERRAL), then a migrated file system has been found. In this situation, it is likely that the fetch of the file system location attribute has cleared one of the file systems contributing to the lease-migrated indication.",
      "ja": "* fs_status属性がファイルシステムが移行されたものであることを示している場合（すなわち、fss_absentはtrue、およびfss_type！= status4_referral）、移行されたファイルシステムが見つかりました。この状況では、ファイルシステムの場所属性のフェッチが、リース移行表示に寄与するファイルシステムのうちの1つをクリアした可能性があります。"
    },
    {
      "indent": 3,
      "text": "* In cases in which that happened, the thread cannot know whether the lease-migrated indication has been cleared, and so it enters the completion/verification state and proceeds to issue a COMPOUND to see if the SEQ4_STATUS_LEASE_MOVED indication has been cleared.",
      "ja": "* それが起こった場合、スレッドはリースマイグレーションされた指示がクリアされたかどうかを知ることができないため、完了/検証状態に入り、SEQ4_STATUS_LEASE_MOVED表示がクリアされたかどうかを確認するために複合を発行します。"
    },
    {
      "indent": 3,
      "text": "* When the discovery process is in the completion/verification state, if other requests get a lease-migrated indication, they note that it was received. Later, the existence of such indications is used when the request completes, as described below.",
      "ja": "* 検出プロセスが完了/検証状態にあるとき、他の要求がリース移行された表示を受信した場合、それらは受信されたことに注意してください。後に、このような指示の存在は、後述のように、要求が完了するときに使用されます。"
    },
    {
      "indent": 3,
      "text": "When the request used in the completion/verification state completes:",
      "ja": "完了/検証状態で使用された要求が完了したら、"
    },
    {
      "indent": 3,
      "text": "* If a lease-migrated indication is returned, the discovery continues normally. Note that this is so even if all file systems have been traversed, since new migrations could have occurred while the process was going on.",
      "ja": "* リースマイグレーションされた指示が返された場合、発見は正常に続行されます。プロセスが行われている間に新しい移行が発生した可能性があるため、これはすべてのファイルシステムがトラバースされたとしても、これはそうです。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, if there is any record that other requests saw a lease-migrated indication while the request was occurring, that record is cleared, and the verification request is retried. The discovery process remains in the completion/verification state.",
      "ja": "* それ以外の場合、要求が発生している間に他の要求がリースマイグレーションされた表示を見た場合、そのレコードはクリアされ、検証要求が再試行されます。検出プロセスは完了/検証状態のままです。"
    },
    {
      "indent": 3,
      "text": "* If there have been no lease-migrated indications, the work of migration discovery is considered completed, and it enters the non-operating state. Once it enters this state, subsequent lease-migrated indications will trigger a new migration discovery process.",
      "ja": "* リース移行された指示がなかった場合、移行発見の作業は完了したと見なされ、非運転状態に入る。この状態に入ると、その後のリースマイグレーションされた表示は新しい移行検出プロセスをトリガーします。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the process described above is not guaranteed to terminate, as a long series of new migration events might continually delay the clearing of the SEQ4_STATUS_LEASE_MOVED indication. To prevent unnecessary lease expiration, it is appropriate for clients to use the discovery of migrations to effect lease renewal immediately, rather than waiting for the clearing of the SEQ4_STATUS_LEASE_MOVED indication when the complete set of migrations is available.",
      "ja": "上記のプロセスは、長い一連の新しいマイグレーションイベントがSEQ4_STATUS_LEASE_MOVED表示のクリアを遅らせる可能性があるため、終了が保証されていないことに注意してください。不要なリース期限が切れるのを防ぐために、移行の完全な一連のマイグレーションが利用可能な場合は、SEQ4_STATUS_LEASE_MOVED表示のクリアを待っているのではなく、移行の発見を使用するために移行の発見を使用するのに適しています。"
    },
    {
      "indent": 3,
      "text": "Lease discovery needs to be provided as described above. This ensures that the client discovers file system migrations soon enough to renew its leases on each destination server before they expire. Non-renewal of leases can lead to loss of locking state. While the consequences of such loss can be ameliorated through implementations of courtesy locks, servers are under no obligation to do so, and a conflicting lock request may mean that a lock is revoked unexpectedly. Clients should be aware of this possibility.",
      "ja": "リース発見は上記のように提供される必要があります。これにより、クライアントは、期限切れになる前に、各宛先サーバー上のリースを更新するのに十分にすぐにファイルシステムの移行を検出します。リースのノンリニューアルは、ロック状態の損失につながる可能性があります。そのような損失の影響は礼儀のロックの実装によって改善される可能性がありますが、サーバーはそうする義務を負いません、そして矛盾するロック要求は、ロックが予期せずに失効されることを意味するかもしれません。クライアントはこの可能性を認識する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.13.3. Overview of Client Response to NFS4ERR_MOVED",
      "section_title": true,
      "ja": "11.13.3. NFS4ERR_MOVEDへのクライアントレスポンスの概要"
    },
    {
      "indent": 3,
      "text": "This section outlines a way in which a client that receives NFS4ERR_MOVED can effect transition recovery by using a new server or server endpoint if one is available. As part of that process, it will determine:",
      "ja": "このセクションでは、NFS4ERR_MOVEDを受信するクライアントが、新しいサーバーまたはサーバーエンドポイントを使用して遷移リカバリを有効にする方法について説明します。そのプロセスの一部として、それは決定されます。"
    },
    {
      "indent": 3,
      "text": "* Whether the NFS4ERR_MOVED indicates migration has occurred, or whether it indicates another sort of file system access transition as discussed in Section 11.10 above.",
      "ja": "* NFS4ERR_MOUDがマイグレーションが発生したかどうか、または上記のセクション11.10で説明されているように、別の種類のファイルシステムアクセス遷移を示すかどうか。"
    },
    {
      "indent": 3,
      "text": "* In the case of migration, whether Transparent State Migration has occurred.",
      "ja": "* 移行の場合、透過状態の移行が発生したかどうか。"
    },
    {
      "indent": 3,
      "text": "* Whether any state has been lost during the process of Transparent State Migration.",
      "ja": "* 透過状態移行のプロセス中に様子が失われたかどうか。"
    },
    {
      "indent": 3,
      "text": "* Whether sessions have been transferred as part of Transparent State Migration.",
      "ja": "* セッションが透過状態移行の一部として転送されたかどうか。"
    },
    {
      "indent": 3,
      "text": "During the first phase of this process, the client proceeds to examine file system location entries to find the initial network address it will use to continue access to the file system or its replacement. For each location entry that the client examines, the process consists of five steps:",
      "ja": "このプロセスの最初のフェーズの間、クライアントはファイルシステムの場所のエントリを調べて、ファイルシステムまたはその置き換えにアクセスするために使用する最初のネットワークアドレスを見つけるために進行します。クライアントが調べる場所エントリごとに、プロセスは5つのステップで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Performing an EXCHANGE_ID directed at the location address. This operation is used to register the client owner (in the form of a client_owner4) with the server, to obtain a client ID to be used subsequently to communicate with it, to obtain that client ID's confirmation status, and to determine server_owner4 and scope for the purpose of determining if the entry is trunkable with the address previously being used to access the file system (i.e., that it represents another network access path to the same file system and can share locking state with it).",
      "ja": "1. 位置アドレスに向けられたExchange_IDを実行します。この操作は、サーバとのクライアント所有者（Client_OWNER4の形式）をサーバに登録し、その後通信するクライアントIDを取得し、そのクライアントIDの確認ステータスを取得し、Server_Owner4と範囲の範囲を決定する。エントリがファイルシステムにアクセスするために（すなわち、同じファイルシステムへの別のネットワークアクセスパスを表し、それと共にロック状態を共有することができること）。"
    },
    {
      "indent": 3,
      "text": "2. Making an initial determination of whether migration has occurred. The initial determination will be based on whether the EXCHANGE_ID results indicate that the current location element is server-trunkable with that used to access the file system when access was terminated by receiving NFS4ERR_MOVED. If it is, then migration has not occurred. In that case, the transition is dealt with, at least initially, as one involving continued access to the same file system on the same server through a new network address.",
      "ja": "2. 移行が発生したかどうかの最初の決定を行います。最初の決定は、Exchange_IDの結果が、NFS4ERR_MOUDを受信してアクセスが終了したときに、現在の位置要素がファイルシステムにアクセスするために使用されたものでサーバートランク不能であることを示しているかどうかに基づいています。その場合は、移行が発生していません。その場合、新しいネットワークアドレスを介して同じサーバー上の同じファイルシステムへの継続的なアクセスを含むものとして、遷移は少なくとも最初に処理されます。"
    },
    {
      "indent": 3,
      "text": "3. Obtaining access to existing session state or creating new sessions. How this is done depends on the initial determination of whether migration has occurred and can be done as described in Section 11.13.4 below in the case of migration or as described in Section 11.13.5 below in the case of a network address transfer without migration.",
      "ja": "3. 既存のセッション状態へのアクセスまたは新しいセッションを作成すること。これを行う方法は、移行の場合、または移行のないネットワークアドレス転送の場合は、下記の「11.13.5」の場合には、移行が行われたかどうかの最初の決定にかかっています。。"
    },
    {
      "indent": 3,
      "text": "4. Verifying the trunking relationship assumed in step 2 as discussed in Section 2.10.5.1. Although this step will generally confirm the initial determination, it is possible for verification to invalidate the initial determination of network address shift (without migration) and instead determine that migration had occurred. There is no need to redo step 3 above, since it will be possible to continue use of the session established already.",
      "ja": "4. セクション2.10.5.1で説明したように、ステップ2で仮定したトランキング関係を検証します。このステップは一般に初期決定を確認するが、検証を検証することは、（移行なし）ネットワークアドレスシフトの初期決定を無効にし、代わりに移行が発生したと判断することが可能である。すでに確立されたセッションの使用を継続することが可能になるので、上記のステップ3をやり直す必要はありません。"
    },
    {
      "indent": 3,
      "text": "5. Obtaining access to existing locking state and/or re-obtaining it. How this is done depends on the final determination of whether migration has occurred and can be done as described below in Section 11.13.4 in the case of migration or as described in Section 11.13.5 in the case of a network address transfer without migration.",
      "ja": "5. 既存のロック状態へのアクセスを取得したり、再取得してください。これがどのように行われるかは、移行の場合、または移行のないネットワークアドレス転送の場合には、セクション11.13.5で説明されている場合、またはセクション11.13.5で説明されているように、次のようにして行うことができます。"
    },
    {
      "indent": 3,
      "text": "Once the initial address has been determined, clients are free to apply an abbreviated process to find additional addresses trunkable with it (clients may seek session-trunkable or server-trunkable addresses depending on whether they support client ID trunking). During this later phase of the process, further location entries are examined using the abbreviated procedure specified below:",
      "ja": "初期アドレスが決定されたら、クライアントは略語を備えたアドレスを見つけるために自由にトランクされているアドレスを見つけることができます（クライアントIDのトランキングをサポートするかどうかに応じて、セッショントランク不能またはサーバートラッキング可能アドレスを探すことがあります）。プロセスのこの後のフェーズでは、以下に指定された省略形の手順を使用して、さらなる場所のエントリが検査されます。"
    },
    {
      "indent": 3,
      "text": "A: Before the EXCHANGE_ID, the fs name of the location entry is examined, and if it does not match that currently being used, the entry is ignored. Otherwise, one proceeds as specified by step 1 above.",
      "ja": "A：Exchange_IDの前に、場所エントリのFS名が調べられ、現在使用されていると一致しない場合は、エントリは無視されます。それ以外の場合は、上記の手順1で指定されているとおりに進行します。"
    },
    {
      "indent": 3,
      "text": "B: In the case that the network address is session-trunkable with one used previously, a BIND_CONN_TO_SESSION is used to access that session using the new network address. Otherwise, or if the bind operation fails, a CREATE_SESSION is done.",
      "ja": "B：ネットワークアドレスが以前に使用されたものと一緒にセッショントランク不能の場合、bind_conn_to_sessionは新しいネットワークアドレスを使用してそのセッションにアクセスするために使用されます。それ以外の場合、またはバインド操作が失敗した場合、CREATE_SESSIONが行われます。"
    },
    {
      "indent": 3,
      "text": "C: The verification procedure referred to in step 4 above is used. However, if it fails, the entry is ignored and the next available entry is used.",
      "ja": "C：上記のステップ4で参照される検証手順が使用される。ただし、失敗した場合は、エントリは無視され、次の利用可能なエントリが使用されます。"
    },
    {
      "indent": 0,
      "text": "11.13.4. Obtaining Access to Sessions and State after Migration",
      "section_title": true,
      "ja": "11.13.4. 移行後のセッションと状態へのアクセスを取得する"
    },
    {
      "indent": 3,
      "text": "In the event that migration has occurred, migration recovery will involve determining whether Transparent State Migration has occurred. This decision is made based on the client ID returned by the EXCHANGE_ID and the reported confirmation status.",
      "ja": "移行が発生した場合、移行回復には、透過状態の移行が発生したかどうかを判断することが含まれます。この決定は、Exchange_IDから返されたクライアントIDと報告された確認ステータスに基づいて行われます。"
    },
    {
      "indent": 3,
      "text": "* If the client ID is an unconfirmed client ID not previously known to the client, then Transparent State Migration has not occurred.",
      "ja": "* クライアントIDが以前にクライアントに認識されていない未確認クライアントIDである場合は、透過状態の移行が発生していません。"
    },
    {
      "indent": 3,
      "text": "* If the client ID is a confirmed client ID previously known to the client, then any transferred state would have been merged with an existing client ID representing the client to the destination server. In this state merger case, Transparent State Migration might or might not have occurred, and a determination as to whether it has occurred is deferred until sessions are established and the client is ready to begin state recovery.",
      "ja": "* クライアントIDが以前にクライアントに認識されているクライアントIDである場合、転送された状態は、クライアントを宛先サーバに表す既存のクライアントIDとマージされているであろう。この状態合併ケースでは、透過状態の移行が発生した場合、または発生していない可能性があり、セッションが確立され、クライアントが状態復旧を開始する準備ができているかどうかに関する決定が延期されます。"
    },
    {
      "indent": 3,
      "text": "* If the client ID is a confirmed client ID not previously known to the client, then the client can conclude that the client ID was transferred as part of Transparent State Migration. In this transferred client ID case, Transparent State Migration has occurred, although some state might have been lost.",
      "ja": "* クライアントIDが以前にクライアントに認識されていないクライアントIDである場合、クライアントは透過状態移行の一部としてクライアントIDが転送されたと結論付けることができます。この転送されたクライアントIDケースでは、透過状態の移行が発生しましたが、いくつかの状態が失われました。"
    },
    {
      "indent": 3,
      "text": "Once the client ID has been obtained, it is necessary to obtain access to sessions to continue communication with the new server. In any of the cases in which Transparent State Migration has occurred, it is possible that a session was transferred as well. To deal with that possibility, clients can, after doing the EXCHANGE_ID, issue a BIND_CONN_TO_SESSION to connect the transferred session to a connection to the new server. If that fails, it is an indication that the session was not transferred and that a new session needs to be created to take its place.",
      "ja": "クライアントIDが取得されると、新しいサーバーとの通信を続けるためにセッションへのアクセスを取得する必要があります。透過状態の移行が発生した場合のいずれの場合も、セッションが転送された可能性があります。その可能性を扱うために、クライアントはExchange_IDを実行した後に、転送されたセッションを新しいサーバーへの接続に接続するためにbind_conn_to_sessionを発行できます。それが失敗した場合、セッションが転送されず、新しいセッションをその場所にするために作成する必要があることが示されています。"
    },
    {
      "indent": 3,
      "text": "In some situations, it is possible for a BIND_CONN_TO_SESSION to succeed without session migration having occurred. If state merger has taken place, then the associated client ID may have already had a set of existing sessions, with it being possible that the session ID of a given session is the same as one that might have been migrated. In that event, a BIND_CONN_TO_SESSION might succeed, even though there could have been no migration of the session with that session ID. In such cases, the client will receive sequence errors when the slot sequence values used are not appropriate on the new session. When this occurs, the client can create a new a session and cease using the existing one.",
      "ja": "状況によっては、セッションの移行が発生したことなくBIND_CONN_TO_SESSIONが成功することが可能です。状態合併が行われた場合、関連するクライアントIDはすでに既存のセッションのセットを持っていてもよく、特定のセッションのセッションIDが移行された可能性があるものと同じである可能性があります。そのイベントでは、そのセッションIDとのセッションの移行がない場合でも、bind_conn_to_sessionが成功することがあります。そのような場合、使用されるスロットシーケンス値が新しいセッションに適していない場合、クライアントはシーケンスエラーを受け取ります。これが発生すると、クライアントは新しいセッションを作成し、既存のセッションを中止することができます。"
    },
    {
      "indent": 3,
      "text": "Once the client has determined the initial migration status, and determined that there was a shift to a new server, it needs to re-establish its locking state, if possible. To enable this to happen without loss of the guarantees normally provided by locking, the destination server needs to implement a per-fs grace period in all cases in which lock state was lost, including those in which Transparent State Migration was not implemented. Each client for which there was a transfer of locking state to the new server will have the duration of the grace period to reclaim its locks, from the time its locks were transferred.",
      "ja": "クライアントが最初の移行ステータスを決定し、新しいサーバーにシフトがあったと判断されたら、可能であれば、ロック状態を再確立する必要があります。通常ロックによって提供される保証を失うことなくこれを実現することを可能にするために、宛先サーバーは、透過状態の移行が実装されていないものを含む、ロック状態が失われたすべての場合において、FSごとの猶予期間を実装する必要があります。新しいサーバーへのロック状態の転送があった各クライアントは、そのロックが転送された時からそのロックを再利用するための猶予期間の持続時間を持ちます。"
    },
    {
      "indent": 3,
      "text": "Clients need to deal with the following cases:",
      "ja": "クライアントは以下の場合に対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "* In the state merger case, it is possible that the server has not attempted Transparent State Migration, in which case state may have been lost without it being reflected in the SEQ4_STATUS bits. To determine whether this has happened, the client can use TEST_STATEID to check whether the stateids created on the source server are still accessible on the destination server. Once a single stateid is found to have been successfully transferred, the client can conclude that Transparent State Migration was begun, and any failure to transport all of the stateids will be reflected in the SEQ4_STATUS bits. Otherwise, Transparent State Migration has not occurred.",
      "ja": "* 状態合併ケースでは、サーバが透過的な状態移行を試みていない可能性があり、その場合、SEQ4_STATUSビットに反映されずに状態が失われた可能性がある。これが起こったかどうかを判断するために、クライアントはTest_StateIDを使用して、送信元サーバー上に作成されたStateIDが宛先サーバー上でまだアクセス可能かどうかを確認できます。単一のStateIDが正常に転送されたことが判明したら、クライアントは透過的な状態移行が開始され、すべてのStateIDを転送できないと判断できます。それ以外の場合は、透過状態の移行が発生していません。"
    },
    {
      "indent": 3,
      "text": "* In a case in which Transparent State Migration has not occurred, the client can use the per-fs grace period provided by the destination server to reclaim locks that were held on the source server.",
      "ja": "* 透過状態の移行が発生していない場合、クライアントは宛先サーバーによって提供されたFS PER-FS猶予期間を使用して、ソースサーバー上で保持されていたロックを再利用できます。"
    },
    {
      "indent": 3,
      "text": "* In a case in which Transparent State Migration has occurred, and no lock state was lost (as shown by SEQ4_STATUS flags), no lock reclaim is necessary.",
      "ja": "* 透過状態の移行が発生した場合、（SEQ4_STATUSフラグで示すように）ロック状態が失われなかった場合は、ロック再利用は必要ありません。"
    },
    {
      "indent": 3,
      "text": "* In a case in which Transparent State Migration has occurred, and some lock state was lost (as shown by SEQ4_STATUS flags), existing stateids need to be checked for validity using TEST_STATEID, and reclaim used to re-establish any that were not transferred.",
      "ja": "* 透過状態の移行が発生し、一部のロック状態が失われた場合（SEQ4_STATUSフラグで示すように）、TEST_STATEIDを使用して既存のステートリッドを確認する必要があり、転送されなかったものを再確立するために使用されます。"
    },
    {
      "indent": 3,
      "text": "For all of the cases above, RECLAIM_COMPLETE with an rca_one_fs value of TRUE needs to be done before normal use of the file system, including obtaining new locks for the file system. This applies even if no locks were lost and there was no need for any to be reclaimed.",
      "ja": "上記のすべてのケースでは、ファイルシステムの新しいロックを取得するなど、ファイルシステムの通常の使用の前に、RCA_ONE_FS値を持つRECLAIM_COMPLETEを実行する必要があります。ロックがなくなっていなくてもこれは適用され、再生される必要はありませんでした。"
    },
    {
      "indent": 0,
      "text": "11.13.5. Obtaining Access to Sessions and State after Network Address Transfer",
      "ja": "11.13.5. ネットワークアドレス転送後のセッションと状態へのアクセスを取得する"
    },
    {
      "indent": 3,
      "text": "The case in which there is a transfer to a new network address without migration is similar to that described in Section 11.13.4 above in that there is a need to obtain access to needed sessions and locking state. However, the details are simpler and will vary depending on the type of trunking between the address receiving NFS4ERR_MOVED and that to which the transfer is to be made.",
      "ja": "マイグレーションなしで新しいネットワークアドレスへの転送がある場合は、必要なセッションとロック状態へのアクセスを取得する必要があるという点で、上記の11.13.4項で説明されているものと同様です。ただし、詳細は簡単で、NFS4ERR_MOUSDを受信したアドレスと転送を行うものとの間のトランキングの種類によって異なります。"
    },
    {
      "indent": 3,
      "text": "To make a session available for use, a BIND_CONN_TO_SESSION should be used to obtain access to the session previously in use. Only if this fails, should a CREATE_SESSION be done. While this procedure mirrors that in Section 11.13.4 above, there is an important difference in that preservation of the session is not purely optional but depends on the type of trunking.",
      "ja": "使用可能なセッションを使用可能にするには、BIND_CONN_TO_SESSIONを使用して、以前に使用中のセッションへのアクセスを取得する必要があります。これが失敗した場合にのみ、CREATE_SESSIONを実行する必要があります。上記の11.13.4項では、セッションの保存が純粋にオプションではなく、トランキングの種類によって異なります。"
    },
    {
      "indent": 3,
      "text": "Access to appropriate locking state will generally need no actions beyond access to the session. However, the SEQ4_STATUS bits need to be checked for lost locking state, including the need to reclaim locks after a server reboot, since there is always a possibility of locking state being lost.",
      "ja": "適切なロック状態へのアクセスは、一般に、セッションへのアクセスを超えたアクションは必要ありません。ただし、SEQ4_STATUSビットは、ロック状態が失われる可能性が常にロックされる可能性があるため、サーバーの再起動後にロックを再利用する必要性を含め、ロック状態を失ったロック状態についてチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "11.14. Server Responsibilities Upon Migration",
      "section_title": true,
      "ja": "11.14. 移行時のサーバーの責任"
    },
    {
      "indent": 3,
      "text": "In the event of file system migration, when the client connects to the destination server, that server needs to be able to provide the client continued access to the files it had open on the source server. There are two ways to provide this:",
      "ja": "ファイルシステムの移行が発生した場合、クライアントが宛先サーバーに接続している場合、そのサーバーはソースサーバー上で開いていたファイルへのクライアントの継続的なアクセスを提供できる必要があります。これを提供する方法は2つあります。"
    },
    {
      "indent": 3,
      "text": "* By provision of an fs-specific grace period, allowing the client the ability to reclaim its locks, in a fashion similar to what would have been done in the case of recovery from a server restart. See Section 11.14.1 for a more complete discussion.",
      "ja": "* FS固有の猶予期間を提供することによって、クライアントは、サーバーの再起動からの回復の場合に行われたものと同様の方法で、そのロックを再利用することができます。より完全な議論については11.14.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "* By implementing Transparent State Migration possibly in connection with session migration, the server can provide the client immediate access to the state built up on the source server on the destination server.",
      "ja": "* 透過状態移行を実装することで、セッション移行に関連して、サーバーは宛先サーバー上の送信元サーバー上で構築された状態へのクライアントの即時アクセスを提供できます。"
    },
    {
      "indent": 6,
      "text": "These features are discussed separately in Sections 11.14.2 and 11.14.3, which discuss Transparent State Migration and session migration, respectively.",
      "ja": "これらの機能は、それぞれ透過的な状態移行とセッションの移行をそれぞれ説明するセクション11.14.2および11.14.3では別々に説明されています。"
    },
    {
      "indent": 3,
      "text": "All the features described above can involve transfer of lock-related information between source and destination servers. In some cases, this transfer is a necessary part of the implementation, while in other cases, it is a helpful implementation aid, which servers might or might not use. The subsections below discuss the information that would be transferred but do not define the specifics of the transfer protocol. This is left as an implementation choice, although standards in this area could be developed at a later time.",
      "ja": "上記のすべての機能は、ソースサーバーと宛先サーバー間のロック関連情報の転送を含めることができます。場合によっては、この転送は実装の必要な部分ですが、他の場合では、それは役立つ実装援助であり、どのサーバーが使用しないか使用できない可能性があります。以下のサブセクションでは、転送されるが転送プロトコルの詳細を定義しない情報について説明します。これは実装の選択として残されていますが、この領域の標準は後で開発できます。"
    },
    {
      "indent": 0,
      "text": "11.14.1. Server Responsibilities in Effecting State Reclaim after Migration",
      "ja": "11.14.1. 移行後の状態再利用の影響を受けるサーバーの責任"
    },
    {
      "indent": 3,
      "text": "In this case, the destination server needs no knowledge of the locks held on the source server. It relies on the clients to accurately report (via reclaim operations) the locks previously held, and does not allow new locks to be granted on migrated file systems until the grace period expires. Disallowing of new locks applies to all clients accessing these file systems, while grace period expiration occurs for each migrated client independently.",
      "ja": "この場合、宛先サーバーはソースサーバー上に保持されているロックに関する知識を必要としません。それは、クライアントに依存していて、以前に保持されているロックを正確に報告するように依存しており、猶予期間が切れるまで新しいロックを移行したファイルシステムで許可されないようにしていません。新しいロックを禁止するこれらのファイルシステムにアクセスするすべてのクライアントに適用され、一方、猶予期間の有効期限は各移行クライアントに対して独立して発生します。"
    },
    {
      "indent": 3,
      "text": "During this grace period, clients have the opportunity to use reclaim operations to obtain locks for file system objects within the migrated file system, in the same way that they do when recovering from server restart, and the servers typically rely on clients to accurately report their locks, although they have the option of subjecting these requests to verification. If the clients only reclaim locks held on the source server, no conflict can arise. Once the client has reclaimed its locks, it indicates the completion of lock reclamation by performing a RECLAIM_COMPLETE specifying rca_one_fs as TRUE.",
      "ja": "この猶予期間中、クライアントは、サーバーの再起動から回復したときに実行されるのと同じ方法で、移行されたファイルシステム内のファイルシステムオブジェクトのロックを取得する機会があり、サーバーは通常クライアントに正確に報告するように依存しています。ロックしますが、これらの要求を検証にかけるオプションがあります。クライアントがソースサーバー上で保持されているロックのみを再利用する場合、競合は発生しません。クライアントがそのロックを再生したら、RCA_ONE_FSを指定するRECLAIM_COMPLETEを実行して、ロック再生の完了を示します。"
    },
    {
      "indent": 3,
      "text": "While it is not necessary for source and destination servers to cooperate to transfer information about locks, implementations are well advised to consider transferring the following useful information:",
      "ja": "ソースサーバーと宛先サーバーがロックに関する情報を転送するために協力する必要はないが、実装は以下の有用な情報を転送することを検討することをよくお勧めします。"
    },
    {
      "indent": 3,
      "text": "* If information about the set of clients that have locking state for the transferred file system is made available, the destination server will be able to terminate the grace period once all such clients have reclaimed their locks, allowing normal locking activity to resume earlier than it would have otherwise.",
      "ja": "* 転送されたファイルシステムのロック状態を持つクライアントのセットを使用可能にすると、宛先サーバーはそのようなクライアントがすべてのロックを再利用したら猶予期間を終了することができ、通常のロックアクティビティがそれより早く再開できます。そうでなければ。"
    },
    {
      "indent": 3,
      "text": "* Locking summary information for individual clients (at various possible levels of detail) can detect some instances in which clients do not accurately represent the locks held on the source server.",
      "ja": "* 個々のクライアントの要約情報をロックする（さまざまな可能なレベルの詳細レベルで）クライアントがソースサーバー上に保持されているロックを正確に表現しないインスタンスを検出できます。"
    },
    {
      "indent": 0,
      "text": "11.14.2. Server Responsibilities in Effecting Transparent State Migration",
      "ja": "11.14.2. 透過状態移行をもたらす際のサーバ責任"
    },
    {
      "indent": 3,
      "text": "The basic responsibility of the source server in effecting Transparent State Migration is to make available to the destination server a description of each piece of locking state associated with the file system being migrated. In addition to client id string and verifier, the source server needs to provide for each stateid:",
      "ja": "トランスペアレント状態の移行をもたらす際のソースサーバの基本的な責任は、移行されているファイルシステムに関連付けられている各ロック状態の説明を宛先サーバーに使用できるようにすることです。クライアントID文字列と検証者に加えて、ソースサーバーは各StareIDを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The stateid including the current sequence value.",
      "ja": "* 現在のシーケンス値を含むStateID。"
    },
    {
      "indent": 3,
      "text": "* The associated client ID.",
      "ja": "* 関連付けられているクライアントID。"
    },
    {
      "indent": 3,
      "text": "* The handle of the associated file.",
      "ja": "* 関連ファイルのハンドル。"
    },
    {
      "indent": 3,
      "text": "* The type of the lock, such as open, byte-range lock, delegation, or layout.",
      "ja": "* オープン、バイトレンジロック、委任、またはレイアウトなどのロックの種類。"
    },
    {
      "indent": 3,
      "text": "* For locks such as opens and byte-range locks, there will be information about the owner(s) of the lock.",
      "ja": "* オープンやバイトレンジのロックなどのロックの場合は、ロックの所有者に関する情報があります。"
    },
    {
      "indent": 3,
      "text": "* For recallable/revocable lock types, the current recall status needs to be included.",
      "ja": "* リコール/復活可能なロックタイプの場合、現在のリコール状態を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* For each lock type, there will be associated type-specific information. For opens, this will include share and deny mode while for byte-range locks and layouts, there will be a type and a byte-range.",
      "ja": "* ロックタイプごとに、タイプ固有の情報が関連付けられます。OpenSの場合、これにはShareとDenyモードが含まれ、バイトレンジのロックとレイアウトの場合はタイプとバイト範囲があります。"
    },
    {
      "indent": 3,
      "text": "Such information will most probably be organized by client id string on the destination server so that it can be used to provide appropriate context to each client when it makes itself known to the client. Issues connected with a client impersonating another by presenting another client's client id string can be addressed using NFSv4.1 state protection features, as described in Section 21.",
      "ja": "そのような情報は、おそらく宛先サーバー上のクライアントID文字列によって編成され、それがクライアントに知られているときに各クライアントに適切なコンテキストを提供するために使用されることができるようにするでしょう。別のクライアントのクライアントID文字列を提示することによって、別のクライアントID文字列を提示することによって別のクライアントのクライアントID文字列を提示することによって、別のクライアントID文字列を使用して説明することができる。"
    },
    {
      "indent": 3,
      "text": "A further server responsibility concerns locks that are revoked or otherwise lost during the process of file system migration. Because locks that appear to be lost during the process of migration will be reclaimed by the client, the servers have to take steps to ensure that locks revoked soon before or soon after migration are not inadvertently allowed to be reclaimed in situations in which the continuity of lock possession cannot be assured.",
      "ja": "さらなるサーバーの責任は、ファイルシステムの移行のプロセス中に失効されるか、そうでなければ失われるロックに関するものです。移行のプロセス中に失われるように見えるロックはクライアントによって再生されるため、サーバーは、移行が誤って継続的に回復されることが許されないようにするために、ロックがすぐにロックがすぐに取り消されるようにするための手順をとる必要があります。ロック所有は保証できません。"
    },
    {
      "indent": 3,
      "text": "* For locks lost on the source but whose loss has not yet been acknowledged by the client (by using FREE_STATEID), the destination must be aware of this loss so that it can deny a request to reclaim them.",
      "ja": "* ソースでロックされていますが、（free_stateIDを使用することによって）クライアントによってまだ承認されていないが、宛先はそれらを再利用する要求を拒否することができるように、宛先はこの損失を認識する必要があります。"
    },
    {
      "indent": 3,
      "text": "* For locks lost on the destination after the state transfer but before the client's RECLAIM_COMPLETE is done, the destination server should note these and not allow them to be reclaimed.",
      "ja": "* 状態転送の後で宛先でロックが失われたが、クライアントのreclaim_completeが行われる前に、宛先サーバはこれらを記録する必要がなく、それらを再生することはできません。"
    },
    {
      "indent": 3,
      "text": "An additional responsibility of the cooperating servers concerns situations in which a stateid cannot be transferred transparently because it conflicts with an existing stateid held by the client and associated with a different file system. In this case, there are two valid choices:",
      "ja": "協調サーバーの追加の責任は、クライアントによって保持され、別のファイルシステムに関連付けられている既存のStateIDと競合するため、StateDIDを透過的に転送できない状況に関係します。この場合、有効な選択肢が2つあります。"
    },
    {
      "indent": 3,
      "text": "* Treat the transfer, as in NFSv4.0, as one without Transparent State Migration. In this case, conflicting locks cannot be granted until the client does a RECLAIM_COMPLETE, after reclaiming the locks it had, with the exception of reclaims denied because they were attempts to reclaim locks that had been lost.",
      "ja": "* NFSV4.0のように、転送を透過状態の移行なしのものとして扱います。この場合、ロックを再利用した後、クライアントがRECLAIM_COMPLETEを実行するまで競合するロックは、ロックを再利用しようとしていたため、Reclaimを除いて拒否されます。"
    },
    {
      "indent": 3,
      "text": "* Implement Transparent State Migration, except for the lock with the conflicting stateid. In this case, the client will be aware of a lost lock (through the SEQ4_STATUS flags) and be allowed to reclaim it.",
      "ja": "* 競合するStateIDを使用したロックを除いて、透過状態の移行を実装します。この場合、クライアントは（SEQ4_STATUSフラグを介して）ロストロックを認識し、それを再利用することを許可されます。"
    },
    {
      "indent": 3,
      "text": "When transferring state between the source and destination, the issues discussed in Section 7.2 of [69] must still be attended to. In this case, the use of NFS4ERR_DELAY may still be necessary in NFSv4.1, as it was in NFSv4.0, to prevent locking state changing while it is being transferred. See Section 15.1.1.3 for information about appropriate client retry approaches in the event that NFS4ERR_DELAY is returned.",
      "ja": "ソースと宛先の間の状態を転送するとき、[69]のセクション7.2で説明した問題は、まだ参加する必要があります。この場合、転送中にロック状態が変化するのを防ぐために、NFSV4.0であるため、NFS4ER_DELAYの使用はNFSV4.0では必要である可能性があります。NFS4ERR_DELAYが返された場合の適切なクライアントの再試行方法については、セクション15.1.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "There are a number of important differences in the NFS4.1 context:",
      "ja": "NFS4.1のコンテキストには、いくつかの重要な違いがあります。"
    },
    {
      "indent": 3,
      "text": "* The absence of RELEASE_LOCKOWNER means that the one case in which an operation could not be deferred by use of NFS4ERR_DELAY no longer exists.",
      "ja": "* release_lockOwnerの欠如は、NFS4ERR_DELAYを使用して操作を延期できなかった場合の1つのケースが存在しません。"
    },
    {
      "indent": 3,
      "text": "* Sequencing of operations is no longer done using owner-based operation sequences numbers. Instead, sequencing is session-based.",
      "ja": "* 操作のシーケンスは、所有者ベースの操作シーケンス番号を使用して行われなくなりました。代わりに、シーケンスはセッションベースです。"
    },
    {
      "indent": 3,
      "text": "As a result, when sessions are not transferred, the techniques discussed in Section 7.2 of [69] are adequate and will not be further discussed.",
      "ja": "その結果、セッションが転送されない場合、[69]のセクション7.2で説明されている技術は適切であり、これ以上説明しないであろう。"
    },
    {
      "indent": 0,
      "text": "11.14.3. Server Responsibilities in Effecting Session Transfer",
      "section_title": true,
      "ja": "11.14.3. セッション転送を実行するためのサーバ責任"
    },
    {
      "indent": 3,
      "text": "The basic responsibility of the source server in effecting session transfer is to make available to the destination server a description of the current state of each slot with the session, including the following:",
      "ja": "セッション転送を有効にするためのソースサーバーの基本的な責任は、次のものを含む、各スロットの現在の状態の説明を宛先サーバーで使用できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "* The last sequence value received for that slot.",
      "ja": "* そのスロットに対して受信された最後のシーケンス値。"
    },
    {
      "indent": 3,
      "text": "* Whether there is cached reply data for the last request executed and, if so, the cached reply.",
      "ja": "* 最後に実行されたリクエストのキャッシュ返信データがあるかどうか、そうでなければキャッシュされた応答。"
    },
    {
      "indent": 3,
      "text": "When sessions are transferred, there are a number of issues that pose challenges in terms of making the transferred state unmodifiable during the period it is gathered up and transferred to the destination server:",
      "ja": "セッションが転送されたとき、それがまとめられて宛先サーバーに転送された期間中に転送された状態を変更しなくなるという点で課題が多数あるという問題があります。"
    },
    {
      "indent": 3,
      "text": "* A single session may be used to access multiple file systems, not all of which are being transferred.",
      "ja": "* 単一のセッションを使用して複数のファイルシステムにアクセスし、そのすべてが転送されているわけではありません。"
    },
    {
      "indent": 3,
      "text": "* Requests made on a session may, even if rejected, affect the state of the session by advancing the sequence number associated with the slot used.",
      "ja": "* セッション上で行われた要求は、たとえ拒否されても、使用されるスロットに関連するシーケンス番号を前進させることによってセッションの状態に影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "As a result, when the file system state might otherwise be considered unmodifiable, the client might have any number of in-flight requests, each of which is capable of changing session state, which may be of a number of types:",
      "ja": "その結果、ファイルシステムの状態がそうでなければ変更されないと見なされるかもしれない場合、クライアントは任意の数のインフライト要求を有する可能性があり、それぞれがセッション状態を変更することができ、それはいくつかの種類のものであり得る。"
    },
    {
      "indent": 3,
      "text": "1. Those requests that were processed on the migrating file system before migration began.",
      "ja": "1. 移行前に移行ファイルシステムで処理された要求が始まりました。"
    },
    {
      "indent": 3,
      "text": "2. Those requests that received the error NFS4ERR_DELAY because the file system being accessed was in the process of being migrated.",
      "ja": "2. エラーNFS4ERR_DELAYを受信したリクエストは、アクセスされているファイルシステムが移行されたプロセスであった。"
    },
    {
      "indent": 3,
      "text": "3. Those requests that received the error NFS4ERR_MOVED because the file system being accessed had been migrated.",
      "ja": "3. アクセスされているファイルシステムが移行されたため、エラーNFS4ERR_MOVEDを受信した要求。"
    },
    {
      "indent": 3,
      "text": "4. Those requests that accessed the migrating file system in order to obtain location or status information.",
      "ja": "4. ロケーションまたはステータス情報を取得するためにファイルシステムにアクセスした要求。"
    },
    {
      "indent": 3,
      "text": "5. Those requests that did not reference the migrating file system.",
      "ja": "5. 移行ファイルシステムを参照しなかった要求。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the history of any particular slot is likely to include a number of these request classes. In the case in which a session that is migrated is used by file systems other than the one migrated, requests of class 5 may be common and may be the last request processed for many slots.",
      "ja": "特定のスロットの履歴は、いくつかの要求クラスを含む可能性が高いことに注意してください。移行されたセッションが1つの移行されたファイルシステムによって使用される場合、クラス5の要求は一般的であり得、そして多くのスロットに対して処理された最後の要求であり得る。"
    },
    {
      "indent": 3,
      "text": "Since session state can change even after the locking state has been fixed as part of the migration process, the session state known to the client could be different from that on the destination server, which necessarily reflects the session state on the source server at an earlier time. In deciding how to deal with this situation, it is helpful to distinguish between two sorts of behavioral consequences of the choice of initial sequence ID values:",
      "ja": "ロック状態が移行プロセスの一部として修正された後でもセッション状態が変更できるため、クライアントに既知のセッション状態は宛先サーバー上のセッション状態とは異なる可能性があります。時間。この状況に対処する方法を決定する際には、初期シーケンスID値の選択の2種類の行動的影響を区別することが役立ちます。"
    },
    {
      "indent": 3,
      "text": "* The error NFS4ERR_SEQ_MISORDERED is returned when the sequence ID in a request is neither equal to the last one seen for the current slot nor the next greater one.",
      "ja": "* エラーNFS4ERR_SEQ_MISORDEREDは、要求内のシーケンスIDが現在のスロットまたは次の大きい方に見られた最後のものと等しくない場合に返されます。"
    },
    {
      "indent": 6,
      "text": "In view of the difficulty of arriving at a mutually acceptable value for the correct last sequence value at the point of migration, it may be necessary for the server to show some degree of forbearance when the sequence ID is one that would be considered unacceptable if session migration were not involved.",
      "ja": "移行時点での正しい最後のシーケンス値に対して相互に許容される値に到着することの難しさが難しいことから、シーケンスIDが不可能な場合には受け入れられないと見なされる場合にサーバーがある程度の範囲を表示する必要があるかもしれません。移住は含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "* Returning the cached reply for a previously executed request when the sequence ID in the request matches the last value recorded for the slot.",
      "ja": "* リクエスト内のシーケンスIDがスロットに記録されている最後の値と一致する場合に、以前に実行された要求のキャッシュ返信を返す。"
    },
    {
      "indent": 6,
      "text": "In the cases in which an error is returned and there is no possibility of any non-idempotent operation having been executed, it may not be necessary to adhere to this as strictly as might be proper if session migration were not involved. For example, the fact that the error NFS4ERR_DELAY was returned may not assist the client in any material way, while the fact that NFS4ERR_MOVED was returned by the source server may not be relevant when the request was reissued and directed to the destination server.",
      "ja": "エラーが返され、不適合な操作が実行されていない可能性がない場合には、セッションの移行が関与していない場合に適切である可能性があるように、これを厳密に付ける必要はないかもしれません。たとえば、エラーNFS4ERR_DELAYが返されたという事実は、任意の資料の方法でクライアントを支援することはできませんが、要求が再発行されて宛先サーバーに向けられた場合には、NFS4ERR_MOVEDがソースサーバーによって返されていない可能性があります。"
    },
    {
      "indent": 3,
      "text": "An important issue is that the specification needs to take note of all potential COMPOUNDs, even if they might be unlikely in practice. For example, a COMPOUND is allowed to access multiple file systems and might perform non-idempotent operations in some of them before accessing a file system being migrated. Also, a COMPOUND may return considerable data in the response before being rejected with NFS4ERR_DELAY or NFS4ERR_MOVED, and may in addition be marked as sa_cachethis. However, note that if the client and server adhere to rules in Section 15.1.1.3, there is no possibility of non-idempotent operations being spuriously reissued after receiving NFS4ERR_DELAY response.",
      "ja": "重要な問題は、たとえ彼らが実際には起こらないかもしれなくても、仕様はすべての潜在的な化合物に注目する必要があるということです。たとえば、コンパウンドは複数のファイルシステムにアクセスでき、移行されているファイルシステムにアクセスする前に、それらの一部で非IDEmpotent操作を実行できます。また、コンパウンドは、NFS4ERR_DELAYまたはNFS4ERR_MOUDで拒否される前に応答にかなりのデータを返すことができ、さらにSA_CACHETHISとしてマークされている可能性があります。ただし、クライアントとサーバーがセクション15.1.1.3の規則に準拠している場合、NFS4ERR_DELAY応答を受信した後に、非IDEPOTENT操作が誤って再発行されている可能性はありません。"
    },
    {
      "indent": 3,
      "text": "To address these issues, a destination server MAY do any of the following when implementing session transfer:",
      "ja": "これらの問題に対処するために、セッション転送を実装するときに宛先サーバーは次のいずれかを実行できます。"
    },
    {
      "indent": 3,
      "text": "* Avoid enforcing any sequencing semantics for a particular slot until the client has established the starting sequence for that slot on the destination server.",
      "ja": "* クライアントが宛先サーバー上のそのスロットの開始シーケンスを確立するまで、特定のスロットのシーケンスセマンティクスを強制しないでください。"
    },
    {
      "indent": 3,
      "text": "* For each slot, avoid returning a cached reply returning NFS4ERR_DELAY or NFS4ERR_MOVED until the client has established the starting sequence for that slot on the destination server.",
      "ja": "* スロットごとに、クライアントが宛先サーバー上のそのスロットの開始シーケンスを確立するまで、キャッシュされた応答を返信しないでください。"
    },
    {
      "indent": 3,
      "text": "* Until the client has established the starting sequence for a particular slot on the destination server, avoid reporting NFS4ERR_SEQ_MISORDERED or returning a cached reply that contains either NFS4ERR_DELAY or NFS4ERR_MOVED and consists solely of a series of operations where the response is NFS4_OK until the final error.",
      "ja": "* クライアントが宛先サーバー上の特定のスロットの開始シーケンスを確立するまで、NFS4ERR_DEQ_MISORDEREDを報告しないように、NFS4ERR_DELAYまたはNFS4ERR_MOUDを含むキャッシュされた応答を返却し、最後のエラーになるまでNFS4_OKのみの一連の動作のみです。"
    },
    {
      "indent": 3,
      "text": "Because of the considerations mentioned above, including the rules for the handling of NFS4ERR_DELAY included in Section 15.1.1.3, the destination server can respond appropriately to SEQUENCE operations received from the client by adopting the three policies listed below:",
      "ja": "セクション15.1.1.3に含まれるNFS4ERR_DELAYの処理規則を含む上記の考慮事項のために、宛先サーバーは、以下にリストされている3つのポリシーを採用することによってクライアントから受信したシーケンス操作に適切に対応できます。"
    },
    {
      "indent": 3,
      "text": "* Not responding with NFS4ERR_SEQ_MISORDERED for the initial request on a slot within a transferred session because the destination server cannot be aware of requests made by the client after the server handoff but before the client became aware of the shift. In cases in which NFS4ERR_SEQ_MISORDERED would normally have been reported, the request is to be processed normally as a new request.",
      "ja": "* 移行したセッション内のスロット上の最初の要求に対してNFS4ERR_SEQ_MISORDEREDで応答しないでください。宛先サーバーは、サーバーのハンドオフ後であるがクライアントがシフトを認識した前にクライアントによって行われる前に宛先サーバを認識することはできません。NFS4ERR_SEQ_MISORDEREDが通常報告された場合、要求は正常に新しい要求として処理されます。"
    },
    {
      "indent": 3,
      "text": "* Replying as it would for a retry whenever the sequence matches that transferred by the source server, even though this would not provide retry handling for requests issued after the server handoff, under the assumption that, when such requests are issued, they will never be responded to in a state-changing fashion, making retry support for them unnecessary.",
      "ja": "* サーバーのハンドオフ後に発行された要求の再試行処理を提供するたびに、サーバーのハンドオフ後にリトライ処理を提供するたびに、そのような要求が発行された場合には、応答することは決してないであろうとします。状態変化する方法では、リトライサポートを不要にします。"
    },
    {
      "indent": 3,
      "text": "* Once a non-retry SEQUENCE is received for a given slot, using that as the basis for further sequence checking, with no further reference to the sequence value transferred by the source server.",
      "ja": "* 一旦非再試行シーケンスが与えられたスロットに対して受信されると、それをさらなるシーケンスチェックの基礎として使用すると、ソースサーバによって転送されたシーケンス値をそれ以上参照しない。"
    },
    {
      "indent": 0,
      "text": "11.15. Effecting File System Referrals",
      "section_title": true,
      "ja": "11.15. ファイルシステムの紹介を実行します"
    },
    {
      "indent": 3,
      "text": "Referrals are effected when an absent file system is encountered and one or more alternate locations are made available by the fs_locations or fs_locations_info attributes. The client will typically get an NFS4ERR_MOVED error, fetch the appropriate location information, and proceed to access the file system on a different server, even though it retains its logical position within the original namespace. Referrals differ from migration events in that they happen only when the client has not previously referenced the file system in question (so there is nothing to transition). Referrals can only come into effect when an absent file system is encountered at its root.",
      "ja": "承認されていないファイルシステムが見つかったときに紹介は行われ、1つ以上の代替位置がFS_LOCATIONATIONSまたはFS_LOCATIONS_INFO属性によって使用可能にされる。クライアントは通常、NFS4ER_MOUDエラーを取得し、適切な位置情報を取得し、元のネームスペース内でその論理位置を保持していても、別のサーバー上のファイルシステムにアクセスします。紹介は、クライアントが最初に問題のファイルシステムを参照していない場合にのみ、移行イベントとは異なります（遷移するものは何もない）。紹介は、存在しないファイルシステムがそのルートで検出されたときにのみ有効になります。"
    },
    {
      "indent": 3,
      "text": "The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component look up, but will have cached information regarding the upper levels of the name hierarchy. However, these examples are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting into a discussion of the details of how specific clients might choose to cache things.",
      "ja": "以下のセクションに記載されている例は、実際のクライアントが通常マルチコンポーネントルックアップを実行しないが、名前階層の上位レベルに関するキャッシュされた情報を持つことにあるという点で幾分人機があります。しかしながら、これらの例は、特定のクライアントが自分のものをキャッシュすることを選択することができるかの詳細についての詳細については、必要な行動を明確かつ簡単にしやすくすることが選択されています。"
    },
    {
      "indent": 0,
      "text": "11.15.1. Referral Example (LOOKUP)",
      "section_title": true,
      "ja": "11.15.1. 紹介例（ルックアップ）"
    },
    {
      "indent": 3,
      "text": "Let us suppose that the following COMPOUND is sent in an environment in which /this/is/the/path is absent from the target server. This may be for a number of reasons. It may be that the file system has moved, or it may be that the target server is functioning mainly, or solely, to refer clients to the servers on which various file systems are located.",
      "ja": "以下の化合物がターゲットサーバから存在しない環境で送信されると仮定する。これは多くの理由であるかもしれません。ファイルシステムが移動した場合、またはターゲットサーバが主にクライアントを参照すること、または様々なファイルシステムが配置されているサーバに機能している可能性がある可能性がある。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH",
      "ja": "* PUTROOTFH"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\"",
      "ja": "* ルックアップ \"これ\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\"",
      "ja": "* ルックアップは \"です\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\"",
      "ja": "* ルックアップ \"the\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"path\"",
      "ja": "* ルックアップ \"パス\""
    },
    {
      "indent": 3,
      "text": "* GETFH",
      "ja": "* get get"
    },
    {
      "indent": 3,
      "text": "* GETATTR (fsid, fileid, size, time_modify)",
      "ja": "* GetAttr（FSID、FileID、サイズ、time_modify）"
    },
    {
      "indent": 3,
      "text": "Under the given circumstances, the following will be the result.",
      "ja": "与えられた状況下では、結果が結果になります。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH --> NFS_OK. The current fh is now the root of the pseudo-fs.",
      "ja": "* putrootfh  - > nfs_ok。現在のFHは疑似FSのルートです。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "* 「この」 - > NFS_OKのルックアップ。電流FHは/これのためのものであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "* Lookup \"Is\"  - > NFS_OK。電流FHは/この/ ISであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "* ルックアップ \"The\"  - > NFS_OK。電流FHは/この/ / IS /ザのためのものであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"path\" --> NFS_OK. The current fh is for /this/is/the/path and is within a new, absent file system, but ... the client will never see the value of that fh.",
      "ja": "* Lookup \"Path\"  - > NFS_OK。現在のFHは/ this / is / the / pathです。"
    },
    {
      "indent": 3,
      "text": "* GETFH --> NFS4ERR_MOVED. Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH.",
      "ja": "* getfh  - > nfs4err_moved。現在のFHが操作開始時にファイルシステムが不在であるため失敗し、仕様はGETFHの例外を除いていません。"
    },
    {
      "indent": 3,
      "text": "* GETATTR (fsid, fileid, size, time_modify). Not executed because the failure of the GETFH stops processing of the COMPOUND.",
      "ja": "* GetAttr（FSID、FileID、Size、Time_Modify）。GETFHの障害が化合物の処理を停止するため、実行されません。"
    },
    {
      "indent": 3,
      "text": "Given the failure of the GETFH, the client has the job of determining the root of the absent file system and where to find that file system, i.e., the server and path relative to that server's root fh. Note that in this example, the client did not obtain filehandles and attribute information (e.g., fsid) for the intermediate directories, so that it would not be sure where the absent file system starts. It could be the case, for example, that /this/is/the is the root of the moved file system and that the reason that the look up of \"path\" succeeded is that the file system was not absent on that operation but was moved between the last LOOKUP and the GETFH (since COMPOUND is not atomic). Even if we had the fsids for all of the intermediate directories, we could have no way of knowing that /this/is/the/path was the root of a new file system, since we don't yet have its fsid.",
      "ja": "GETFHの障害が発生した場合、クライアントは、欠席しているファイルシステムのルートを決定するジョブと、そのファイルシステム、すなわちそのサーバーのルートFHに対するサーバーとパスを見つけるための場所にあります。この例では、クライアントは中間ディレクトリのファイルハンドルと属性情報（例えば、FSID）を取得しなかったため、不在なファイルシステムがどこに起動している場所がわかりません。たとえば、この場合は、移動したファイルシステムのルートであり、「パス」のルックアップが成功したという理由は、ファイルシステムがその操作に欠けていないという理由である場合があります。最後のルックアップとGETFHの間に移動しました（化合物は原子ではありません）。私たちがすべての中間ディレクトリのためのFSIDを持っていたとしても、我々はまだFSIDを持っていないので、私たちはそのことを知っていない方法は新しいファイルシステムのルートであることを知っていませんでした。"
    },
    {
      "indent": 3,
      "text": "In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations_info at the same time but in most cases the client will have a good guess as to where file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received) making fetching of fs_locations_info unnecessary.",
      "ja": "必要な情報を取得するために、少なくともFSIDを取得するために、getfhsとgetAttrsでルックアップのチェーンを再送信してください。クライアントは、FS_LOCATIONS_INFOを同時に取得することを選択できますが、ほとんどの場合、クライアントはファイルシステムの境界がある場所について（NFS4ERR_MOVEDがあった場合、NOT、受信していなかったため）と同様にFS_LOCATIONS_INFOのフェッチを作成します。"
    },
    {
      "indent": 3,
      "text": "OP01:  PUTROOTFH --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is root of pseudo-fs.",
      "ja": "* 電流FHは疑似FSの根本です。"
    },
    {
      "indent": 3,
      "text": "OP02:  GETATTR(fsid) --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Just for completeness. Normally, clients will know the fsid of the pseudo-fs as soon as they establish communication with a server.",
      "ja": "* 完全性のためだけに。通常、クライアントはサーバーとの通信を確立するとすぐに疑似FSのFSIDを知っています。"
    },
    {
      "indent": 3,
      "text": "OP03:  LOOKUP \"this\" --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OP04:  GETATTR(fsid) --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": "* ファイルシステムの境界がある場所を確認するために現在のFSIDを取得します。この例では、fSIDは疑似FSの場合、境界なしです。"
    },
    {
      "indent": 3,
      "text": "OP05:  GETFH --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this and is within pseudo-fs.",
      "ja": "* 電流FHは/これのためのものであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "OP06:  LOOKUP \"is\" --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this/is and is within pseudo-fs.",
      "ja": "* 電流FHは/この/ ISであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "OP07:  GETATTR(fsid) --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": "* ファイルシステムの境界がある場所を確認するために現在のFSIDを取得します。この例では、fSIDは疑似FSの場合、境界なしです。"
    },
    {
      "indent": 3,
      "text": "OP08:  GETFH --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this/is and is within pseudo-fs.",
      "ja": "* 電流FHは/この/ ISであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "OP09:  LOOKUP \"the\" --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this/is/the and is within pseudo-fs.",
      "ja": "* 電流FHは/この/ / IS /ザであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "OP10:  GETATTR(fsid) --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": "* ファイルシステムの境界がある場所を確認するために現在のFSIDを取得します。この例では、fSIDは疑似FSの場合、境界なしです。"
    },
    {
      "indent": 3,
      "text": "OP11:  GETFH --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this/is/the and is within pseudo-fs.",
      "ja": "* 電流FHは/この/ / IS /ザであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "OP12:  LOOKUP \"path\" --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Current fh is for /this/is/the/path and is within a new, absent file system, but ...",
      "ja": "* 現在のFHは/この/ is / the / pathのためのもので、新しいファイルシステム内ですが、..."
    },
    {
      "indent": 6,
      "text": "* The client will never see the value of that fh.",
      "ja": "* クライアントはそのfhの値を見ることは決してありません。"
    },
    {
      "indent": 3,
      "text": "OP13:  GETATTR(fsid, fs_locations_info) --> NFS_OK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.",
      "ja": "* ファイルシステムの境界がどこにあるのかを知るためにFSIDが知られています。この操作では、FSIDは親ディレクトリのそれとは異なります（これはOP10で取得されました）。与えられているFSIDは必ずしも新しい場所で保存されるわけではありません。そのFSIDが異なる場合があり、実際にはこのファイルシステムのFSIDはその新しいサーバー上の異なるファイルシステムの有効なFSIDかもしれません。"
    },
    {
      "indent": 6,
      "text": "* In this particular case, we are pretty sure anyway that what has moved is /this/is/the/path rather than /this/is/the since we have the fsid of the latter and it is that of the pseudo-fs, which presumably cannot move. However, in other examples, we might not have this kind of information to rely on (e.g., /this/is/the might be a non-pseudo file system separate from /this/is/the/path), so we need to have other reliable source information on the boundary of the file system that is moved. If, for example, the file system /this/is had moved, we would have a case of migration rather than referral, and once the boundaries of the migrated file system was clear we could fetch fs_locations_info.",
      "ja": "* この特定のケースでは、とにかく移動したものではなく/ is / path / phe / the / the / phe / the / phere asidが疑似FSのものです。おそらく動くことができません。ただし、他の例では、このような情報が依存するようにこのような情報を持っていないかもしれません（例えば、/ this / is / the / pseudoファイルシステムは/ this / is / pathとは別の非疑似ファイルシステムであるかもしれません）。移動されたファイルシステムの境界に関する他の信頼できるソース情報を持っています。たとえば、ファイルシステム/が移動した場合は、紹介ではなくマイグレーションの場合があり、移行されたファイルシステムの境界が明確になったら、FS_LOCATIONS_INFOを取得できます。"
    },
    {
      "indent": 6,
      "text": "* We are fetching fs_locations_info because the fact that we got an NFS4ERR_MOVED at this point means that it is most likely that this is a referral and we need the destination. Even if it is the case that /this/is/the is a file system that has migrated, we will still need the location information for that file system.",
      "ja": "* この時点でNFS4ERR_VOVEDが得られたという事実は、これが紹介であり、宛先が必要であることを意味しているため、FS_LOCATIONS_INFOを取り上げています。たとえ/この/ / IS / IS / IS / IS / ISが移行した場合でも、まだそのファイルシステムの位置情報が必要です。"
    },
    {
      "indent": 3,
      "text": "OP14:  GETFH --> NFS4ERR_MOVED",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH. Note that this means the server will never send the client a filehandle from within an absent file system.",
      "ja": "* 現在のFHが操作開始時にファイルシステムが不在であるため失敗し、仕様はGETFHの例外を除いていません。これは、サーバーが存在しないファイルシステム内からクライアントをファイルハンドルに送信しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Given the above, the client knows where the root of the absent file system is (/this/is/the/path) by noting where the change of fsid occurred (between \"the\" and \"path\"). The fs_locations_info attribute also gives the client the actual location of the absent file system, so that the referral can proceed. The server gives the client the bare minimum of information about the absent file system so that there will be very little scope for problems of conflict between information sent by the referring server and information of the file system's home. No filehandles and very few attributes are present on the referring server, and the client can treat those it receives as transient information with the function of enabling the referral.",
      "ja": "上記のことを考えると、クライアントは、FSIDの変更が発生した場所（ \"the\"と \"path\"の間）に、存在しないファイルシステムのルートがどこにあるかを知っています。FS_LOCATIONS_INFO属性は、存在しないファイルシステムの実際の位置をクライアントに提供するので、紹介は続行できます。サーバーはクライアントに欠席しているファイルシステムに関する情報の最小限の情報の最小情報を提供して、参照サーバーによって送信された情報とファイルシステムの家の情報との情報との間の競合の問題に対する範囲がほとんどありません。参照サーバーにはファイルハンドルと非常に少ない属性はありません。クライアントは、紹介を有効にする機能を持つトランジェント情報として受信したものを扱うことができます。"
    },
    {
      "indent": 0,
      "text": "11.15.2. Referral Example (READDIR)",
      "section_title": true,
      "ja": "11.15.2. 紹介例（READDIR）"
    },
    {
      "indent": 3,
      "text": "Another context in which a client may encounter referrals is when it does a READDIR on a directory in which some of the sub-directories are the roots of absent file systems.",
      "ja": "クライアントが紹介を遭遇することができる別のコンテキストは、一部のサブディレクトリが不在のファイルシステムの根であるディレクトリ上のREADDIRを実行する場合である。"
    },
    {
      "indent": 3,
      "text": "Suppose such a directory is read as follows:",
      "ja": "そのようなディレクトリが次のように読み取られるとします。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH",
      "ja": "* PUTROOTFH"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\"",
      "ja": "* ルックアップ \"これ\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\"",
      "ja": "* ルックアップは \"です\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\"",
      "ja": "* ルックアップ \"the\""
    },
    {
      "indent": 3,
      "text": "* READDIR (fsid, size, time_modify, mounted_on_fileid)",
      "ja": "* READDIR（FSID、サイズ、time_modify、mapent_on_fileid）"
    },
    {
      "indent": 3,
      "text": "In this case, because rdattr_error is not requested, fs_locations_info is not requested, and some of the attributes cannot be provided, the result will be an NFS4ERR_MOVED error on the READDIR, with the detailed results as follows:",
      "ja": "この場合、RDATTR_ERRORが要求されていないため、FS_LOCATIONS_INFOは要求されず、一部の属性は提供できません。結果はREADDIR上のNFS4ERR_VOVEDエラーになり、詳細な結果は次のようになります。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "* putrootfh  - > nfs_ok。電流FHは疑似FSの根元にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "* 「この」 - > NFS_OKのルックアップ。電流FHは/これのためのものであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "* Lookup \"Is\"  - > NFS_OK。電流FHは/この/ ISであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "* ルックアップ \"The\"  - > NFS_OK。電流FHは/この/ / IS /ザのためのものであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "* READDIR (fsid, size, time_modify, mounted_on_fileid) --> NFS4ERR_MOVED. Note that the same error would have been returned if /this/is/the had migrated, but it is returned because the directory contains the root of an absent file system.",
      "ja": "* READDIR（FSID、サイズ、TIME_MODIFY、MACKIT_ON_FILEID） - > NFS4ERR_MOUD。/ this / is / theが移行された場合、同じエラーが返されたことに注意してくださいが、ディレクトリに欠席しているファイルシステムのルートが含まれているため返されます。"
    },
    {
      "indent": 3,
      "text": "So now suppose that we re-send with rdattr_error:",
      "ja": "そのため、RDATTR_ERRORに再送信するとします。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH",
      "ja": "* PUTROOTFH"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\"",
      "ja": "* ルックアップ \"これ\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\"",
      "ja": "* ルックアップは \"です\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\"",
      "ja": "* ルックアップ \"the\""
    },
    {
      "indent": 3,
      "text": "* READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid)",
      "ja": "* READDIR（RDATTR_ERROR、FSID、サイズ、TIME_MODIFY、MACKIT_ON_FILEID）"
    },
    {
      "indent": 3,
      "text": "The results will be:",
      "ja": "結果は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "* putrootfh  - > nfs_ok。電流FHは疑似FSの根元にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "* 「この」 - > NFS_OKのルックアップ。電流FHは/これのためのものであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "* Lookup \"Is\"  - > NFS_OK。電流FHは/この/ ISであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "* ルックアップ \"The\"  - > NFS_OK。電流FHは/この/ / IS /ザのためのものであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "* READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid) --> NFS_OK. The attributes for directory entry with the component named \"path\" will only contain rdattr_error with the value NFS4ERR_MOVED, together with an fsid value and a value for mounted_on_fileid.",
      "ja": "* READDIR（RDATTR_ERROR、FSID、サイズ、TIME_MODIFY、MACKIT_ON_FILEID） - > NFS_OK。\"PATH\"というコンポーネントを持つディレクトリエントリの属性は、値NFS4ERR_MOVEDを含むRDATTR_ERRORを、FSID値とMATILE_ON_FILEIDの値とともに含みます。"
    },
    {
      "indent": 3,
      "text": "Suppose we do another READDIR to get fs_locations_info (although we could have used a GETATTR directly, as in Section 11.15.1).",
      "ja": "FS_LOCATIONS_INFOを取得するには、もう1つのReadDirを実行します（セクション11.15.1のように、GetAttrを直接使用できました）。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH",
      "ja": "* PUTROOTFH"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\"",
      "ja": "* ルックアップ \"これ\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\"",
      "ja": "* ルックアップは \"です\""
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\"",
      "ja": "* ルックアップ \"the\""
    },
    {
      "indent": 3,
      "text": "* READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify)",
      "ja": "* READDIR（RDATTR_ERROR、FS_LOCATIONS_INFO、MACKIT_ON_FILEID、FSID、サイズ、time_modify）"
    },
    {
      "indent": 3,
      "text": "The results would be:",
      "ja": "結果は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "* putrootfh  - > nfs_ok。電流FHは疑似FSの根元にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "* 「この」 - > NFS_OKのルックアップ。電流FHは/これのためのものであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "* Lookup \"Is\"  - > NFS_OK。電流FHは/この/ ISであり、疑似FS内にある。"
    },
    {
      "indent": 3,
      "text": "* LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "* ルックアップ \"The\"  - > NFS_OK。電流FHは/この/ / IS /ザのためのものであり、疑似FS内にあります。"
    },
    {
      "indent": 3,
      "text": "* READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify) --> NFS_OK. The attributes will be as shown below.",
      "ja": "* READDIR（RDATTR_ERROR、FS_LOCATIONS_INFO、MACKIT_ON_FILEID、FSID、サイズ、TIME_MODIFY） - > NFS_OK。属性は以下のようになります。"
    },
    {
      "indent": 3,
      "text": "The attributes for the directory entry with the component named \"path\" will only contain:",
      "ja": "\"path\"というコンポーネントを持つディレクトリエントリの属性には、次のものが含まれています。"
    },
    {
      "indent": 3,
      "text": "* rdattr_error (value: NFS_OK)",
      "ja": "* RDATTR_ERROR（値：NFS_OK）"
    },
    {
      "indent": 3,
      "text": "* fs_locations_info",
      "ja": "* fs_locations_info"
    },
    {
      "indent": 3,
      "text": "* mounted_on_fileid (value: unique fileid within referring file system)",
      "ja": "* MACKIT_ON_FILEID（value：参照ファイルシステム内の一意のファイルID）"
    },
    {
      "indent": 3,
      "text": "* fsid (value: unique value within referring server)",
      "ja": "* FSID（値：参照サーバ内の一意の値）"
    },
    {
      "indent": 3,
      "text": "The attributes for entry \"path\" will not contain size or time_modify because these attributes are not available within an absent file system.",
      "ja": "エントリ \"path\"の属性には、これらの属性が不在なファイルシステム内で利用できないため、サイズまたはtime_modifyは含まれません。"
    },
    {
      "indent": 0,
      "text": "11.16. The Attribute fs_locations",
      "section_title": true,
      "ja": "11.16. 属性fs_locations."
    },
    {
      "indent": 3,
      "text": "The fs_locations attribute is structured in the following way:",
      "ja": "fs_locations属性は次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "struct fs_location4 {\n        utf8str_cis     server<>;\n        pathname4       rootpath;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct fs_locations4 {\n        pathname4       fs_root;\n        fs_location4    locations<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fs_location4 data type is used to represent the location of a file system by providing a server name and the path to the root of the file system within that server's namespace. When a set of servers have corresponding file systems at the same path within their namespaces, an array of server names may be provided. An entry in the server array is a UTF-8 string and represents one of a traditional DNS host name, IPv4 address, IPv6 address, or a zero-length string. An IPv4 or IPv6 address is represented as a universal address (see Section 3.3.9 and [12]), minus the netid, and either with or without the trailing \".p1.p2\" suffix that represents the port number. If the suffix is omitted, then the default port, 2049, SHOULD be assumed. A zero-length string SHOULD be used to indicate the current address being used for the RPC call. It is not a requirement that all servers that share the same rootpath be listed in one fs_location4 instance. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location4 entries in the fs_locations attribute.",
      "ja": "FS_LOCATION4データ型は、サーバー名とそのサーバーの名前空間内のファイルシステムのルートへのパスを提供することによって、ファイルシステムの場所を表すために使用されます。セットのサーバーが名前空間内の同じパスに対応するファイルシステムを持つ場合、サーバー名の配列を提供することができます。サーバー配列のエントリはUTF-8文字列で、従来のDNSホスト名、IPv4アドレス、IPv6アドレス、またはゼロ長文字列のいずれかを表します。 IPv4またはIPv6アドレスは、ユニバーサルアドレス（セクション3.3.9および[12]参照）として表されます（セクション3.3.9と[12]を参照）、NETIDをマイナスして、ポート番号を表す末尾の \".p1.p2\"サフィックスの有無にかかわらず。サフィックスが省略されている場合は、デフォルトのポート2049が想定されるべきです。 RPC呼び出しに使用されている現在のアドレスを示すために、長さゼロの文字列を使用する必要があります。同じrootPathを共有するすべてのサーバーを1つのFS_LOCATION4インスタンスにリストしているという要件ではありません。便宜上、サーバー名の配列が提供されています。同じrootPathを共有するサーバーは、fs_locations属性の別々のFS_LOCATION4エントリにリストされてもよい。"
    },
    {
      "indent": 3,
      "text": "The fs_locations4 data type and the fs_locations attribute each contain an array of such locations. Since the namespace of each server may be constructed differently, the \"fs_root\" field is provided. The path represented by fs_root represents the location of the file system in the current server's namespace, i.e., that of the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client by clearly referencing the root of the file system whose locations are being reported, no matter what object within the current file system the current filehandle designates. The fs_root is simply the pathname the client used to reach the object on the current server (i.e., the object to which the fs_locations attribute applies).",
      "ja": "FS_LOCATIONS4データ型とFS_LOCATIONS属性は、それぞれの場所の配列を含みます。各サーバのネームスペースを異なるように構成することができるので、「FS_ROOT」フィールドが提供される。FS_ROOTによって表される経路は、現在のサーバのネームスペース内のファイルシステムの位置、すなわちFS_LOCATIONS属性が取得されたサーバの位置を表す。FS_ROOTパスは、現在のファイルシステム内のどのオブジェクトであっても、現在のファイルハンドルが指定されていても、その場所が報告されているファイルシステムのルートを明確に参照することで、クライアントがクライアントを支援することを目的としています。FS_ROOTは、現在のサーバー上のオブジェクトに到達するために使用されるパス名（すなわち、FS_LOCATIONS属性が適用するオブジェクト）であるパス名です。"
    },
    {
      "indent": 3,
      "text": "When the fs_locations attribute is interrogated and there are no alternate file system locations, the server SHOULD return a zero-length array of fs_location4 structures, together with a valid fs_root.",
      "ja": "fs_locations属性が尋問され、代替のファイルシステムの場所がない場合、サーバーは有効なFS_ROOTとともに、FS_LOCATION4構造のゼロ長さの配列を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "As an example, suppose there is a replicated file system located at two servers (servA and servB). At servA, the file system is located at path /a/b/c. At, servB the file system is located at path /x/y/z. If the client were to obtain the fs_locations value for the directory at /a/b/c/d, it might not necessarily know that the file system's root is located in servA's namespace at /a/b/c. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path /x/y/z/d on servB. To facilitate this, the fs_locations attribute provided by servA would have an fs_root value of /a/b/c and two entries in fs_locations. One entry in fs_locations will be for itself (servA) and the other will be for servB with a path of /x/y/z. With this information, the client is able to substitute /x/y/z for the /a/b/c at the beginning of its access path and construct /x/y/z/d to use for the new server.",
      "ja": "例として、2つのサーバー（サーバーとサーバー）にある複製されたファイルシステムがあるとします。サーバーでは、ファイルシステムはパス/ A / B / Cにあります。AT、サーブBEファイルシステムはパス/ x / y / zにあります。クライアントが/ A / B / C / DのディレクトリのFS_LOCATIONS値を取得する場合、ファイルシステムのルートが/ A / B / Cのサーバーの名前空間にあることが必ずしもわかりません。クライアントがServBに切り替わると、サーバーで最初に参照されたディレクトリがSERVB上のパス/ x / y / z / dによって表されるようになる必要があります。これを容易にするために、サーバーによって提供されるFS_LOCATIOS属性は、/ A / B / CのFS_ROOT値とFS_LOCATIONSの2つのエントリを持ちます。FS_LOCATIONSの1つのエントリは、それ自体（サーバー）のためのものであり、もう1つは/ x / y / zのパスを持つサーブBになります。この情報を使用すると、クライアントは、アクセスパスの先頭に/ a / b / cの場合は/ x / y / zを置き換え、新しいサーバーに使用する/ x / y / z / dを構築することができます。"
    },
    {
      "indent": 3,
      "text": "Note that there is no requirement that the number of components in each rootpath be the same; there is no relation between the number of components in rootpath or fs_root, and none of the components in a rootpath and fs_root have to be the same. In the above example, we could have had a third element in the locations array, with server equal to \"servC\" and rootpath equal to \"/I/II\", and a fourth element in locations with server equal to \"servD\" and rootpath equal to \"/aleph/beth/gimel/daleth/he\".",
      "ja": "各ルートパス内のコンポーネントの数が同じであるという要件はありません。rootPathまたはFS_ROOTのコンポーネントの数との間には関係はありません。また、rootPathとFS_ROOTのコンポーネントは同じである必要はありません。上記の例では、Location Arrayに3番目の要素を持ち、サーバーが \"servc\"とrootpathに等しい \"/ i / ii\"と同じように、 \"servd\"とrootpathに等しいサーバがある4番目の要素を持っていました。「/ ALEPH / Beth / Gimel / Daleth / He」に等しい。"
    },
    {
      "indent": 3,
      "text": "The relationship between fs_root to a rootpath is that the client replaces the pathname indicated in fs_root for the current server for the substitute indicated in rootpath for the new server.",
      "ja": "rootPathへのFS_ROOT間の関係は、クライアントが新しいサーバーのrootPathに示されている代理人のために現在のサーバーのFS_ROOTに示されているパス名を置き換えることです。"
    },
    {
      "indent": 3,
      "text": "For an example of a referred or migrated file system, suppose there is a file system located at serv1. At serv1, the file system is located at /az/buky/vedi/glagoli. The client finds that object at glagoli has migrated (or is a referral). The client gets the fs_locations attribute, which contains an fs_root of /az/buky/vedi/ glagoli, and one element in the locations array, with server equal to serv2, and rootpath equal to /izhitsa/fita. The client replaces /az/buky/vedi/glagoli with /izhitsa/fita, and uses the latter pathname on serv2.",
      "ja": "参照または移行されたファイルシステムの例については、Serv1にあるファイルシステムがあるとします。Serv1では、ファイルシステムは/ AZ / Buky / Vedi / Glagoliにあります。クライアントは、Glagoliのオブジェクトが移行されたことを検索します（または紹介）。クライアントは、/ az / buky / vedi / glagoli、およびlocations配列の1つの要素を含むfs_location属性を取得します。クライアントは/ az / buky / vedi / glagoliと/ izhitsa / fitaを置き換え、serv2の後者のパス名を使用します。"
    },
    {
      "indent": 3,
      "text": "Thus, the server MUST return an fs_root that is equal to the path the client used to reach the object to which the fs_locations attribute applies. Otherwise, the client cannot determine the new path to use on the new server.",
      "ja": "したがって、サーバーは、FS_LOCATIONS属性が適用されるオブジェクトに到達するために使用されたパスに等しいFS_ROOTを返す必要があります。それ以外の場合、クライアントは新しいサーバーで使用する新しいパスを判別できません。"
    },
    {
      "indent": 3,
      "text": "Since the fs_locations attribute lacks information defining various attributes of the various file system choices presented, it SHOULD only be interrogated and used when fs_locations_info is not available. When fs_locations is used, information about the specific locations should be assumed based on the following rules.",
      "ja": "fs_locations属性には、提示されたさまざまなファイルシステムの選択肢のさまざまな属性の定義情報が不足しているため、FS_LOCATIONS_INFOが使用できない場合にのみ尋問し、使用する必要があります。FS_LOCATIONSATIONSを使用する場合、特定の場所に関する情報は次の規則に基づいて想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following rules are general and apply irrespective of the context.",
      "ja": "以下の規則は一般的なものであり、コンテキストに関係なく適用されます。"
    },
    {
      "indent": 3,
      "text": "* All listed file system instances should be considered as of the same handle class, if and only if, the current fh_expire_type attribute does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, filehandle issues do not apply since there can be no filehandles known within the current file system, nor is there any access to the fh_expire_type attribute on the referring (absent) file system.",
      "ja": "* 現在のFH_EXPIRE_TYPE属性にFH4_VOL_MIGRATIONビットが含まれていない場合、リストされているすべてのファイルシステムインスタンスは、同じハンドルクラスの場合と考慮する必要があります。紹介の場合、ファイルハンドルの問題は、現在のファイルシステム内で既知のFileHandlesが存在しないため、FH_EXPIRE_TYPE属性には、参照（不在）ファイルシステムの属性にアクセスできないため、ファイルハンドルの問題は適用されません。"
    },
    {
      "indent": 3,
      "text": "* All listed file system instances should be considered as of the same fileid class if and only if the fh_expire_type attribute indicates persistent filehandles and does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, fileid issues do not apply since there can be no fileids known within the referring (absent) file system, nor is there any access to the fh_expire_type attribute.",
      "ja": "* リストされているすべてのシステムインスタンスは、FH_EXPIRE_TYPE属性が永続的なファイルハンドルを示し、FH4_VOL_MIGRATIONビットを含まない場合に限り、同じFileIDクラスの場合と考慮する必要があります。参照の場合、FileIDの問題は、参照（不在）ファイルシステム内で既知のファイルIDがなく、FH_EXPIRE_TYPE属性へのアクセスもあり得ないため、申請しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "* All file system instances servers should be considered as of different change classes.",
      "ja": "* すべてのファイルシステムインスタンスサーバーは、さまざまな変更クラスと見なされる必要があります。"
    },
    {
      "indent": 3,
      "text": "For other class assignments, handling of file system transitions depends on the reasons for the transition:",
      "ja": "他のクラス割り当ての場合、ファイルシステムの遷移の処理は、遷移の理由によって異なります。"
    },
    {
      "indent": 3,
      "text": "* When the transition is due to migration, that is, the client was directed to a new file system after receiving an NFS4ERR_MOVED error, the target should be treated as being of the same write-verifier class as the source.",
      "ja": "* 移行が移行によるものである場合、つまり、クライアントはNFS4ERR_MOVEDエラーを受信した後に新しいファイルシステムに向けられた場合、ターゲットはソースとして同じWrite-Verifierクラスのものとして扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "* When the transition is due to failover to another replica, that is, the client selected another replica without receiving an NFS4ERR_MOVED error, the target should be treated as being of a different write-verifier class from the source.",
      "ja": "* 遷移が別のレプリカへのフェイルオーバーによる、つまりクライアントがNFS4ERR_VOVEDエラーを受信せずに別のレプリカを選択した場合、ターゲットはソースから別のWrite-Verifierクラスのものとして扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "The specific choices reflect typical implementation patterns for failover and controlled migration, respectively. Since other choices are possible and useful, this information is better obtained by using fs_locations_info. When a server implementation needs to communicate other choices, it MUST support the fs_locations_info attribute.",
      "ja": "特定の選択肢は、それぞれフェールオーバーと制御された移行のための典型的な実装パターンをそれぞれ反映しています。他の選択肢が可能で役立ちますので、この情報はFS_LOCATIONS_INFOを使用して得られます。サーバー実装が他の選択を通信する必要がある場合は、FS_LOCATIONS_INFO属性をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 21 for a discussion on the recommendations for the security flavor to be used by any GETATTR operation that requests the fs_locations attribute.",
      "ja": "FS_LOCATIONS属性を要求する任意のGetAttrオペレーションによって使用されるセキュリティフレーバーの推奨事項についての議論については、セクション21を参照してください。"
    },
    {
      "indent": 0,
      "text": "11.17. The Attribute fs_locations_info",
      "section_title": true,
      "ja": "11.17. 属性FS_LOCATIONS_INFO"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute is intended as a more functional replacement for the fs_locations attribute, which will continue to exist and be supported. Clients can use it to get a more complete set of data about alternative file system locations, including additional network paths to access replicas in use and additional replicas. When the server does not support fs_locations_info, fs_locations can be used to get a subset of the data. A server that supports fs_locations_info MUST support fs_locations as well.",
      "ja": "fs_locations_info属性は、fs_locations属性のためのより機能的な置き換えとして意図されており、これは存在し続けてサポートされます。クライアントは、使用中のレプリカと追加のレプリカにアクセスするための追加のネットワークパスを含む、代替ファイルシステムの場所に関するより完全なデータセットを取得するためにそれを使用できます。サーバーがFS_LOCATIONS_INFOをサポートしていない場合、FS_LOCATIONATIONを使用してデータのサブセットを取得できます。fs_locations_infoをサポートするサーバーは、FS_LOCATIONATIONSもサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "There is additional data present in fs_locations_info that is not available in fs_locations:",
      "ja": "FS_LOCATIONS_INFOには、fs_locations_infoに存在する追加のデータがあります。"
    },
    {
      "indent": 3,
      "text": "* Attribute continuity information. This information will allow a client to select a replica that meets the transparency requirements of the applications accessing the data and to leverage optimizations due to the server guarantees of attribute continuity (e.g., if the change attribute of a file of the file system is continuous between multiple replicas, the client does not have to invalidate the file's cache when switching to a different replica).",
      "ja": "* 属性継続情報この情報は、クライアントがデータにアクセスするアプリケーションの透明度要件を満たすレプリカを選択し、属性連続性のサーバ保証のために（例えば、ファイルシステムのファイルの変更属性が連続している場合）、クライアントを選択することができます。複数のレプリカの複数のレプリカは、別のレプリカに切り替えるときにファイルのキャッシュを無効にする必要はありません。"
    },
    {
      "indent": 3,
      "text": "* File system identity information that indicates when multiple replicas, from the client's point of view, correspond to the same target file system, allowing them to be used interchangeably, without disruption, as distinct synchronized replicas of the same file data.",
      "ja": "* ファイルシステムの識別情報クライアントのビューからの複数のレプリカが同じターゲットファイルシステムに対応し、同じファイルデータの異なる同期レプリカとして、それらを中断することなくそれらを互換的に使用できるようにすることができます。"
    },
    {
      "indent": 6,
      "text": "Note that having two replicas with common identity information is distinct from the case of two (trunked) paths to the same replica.",
      "ja": "一般的な識別情報を持つ2つのレプリカを持つことは、同じレプリカへの2つの（トランク）パスの場合とは異なります。"
    },
    {
      "indent": 3,
      "text": "* Information that will bear on the suitability of various replicas, depending on the use that the client intends. For example, many applications need an absolutely up-to-date copy (e.g., those that write), while others may only need access to the most up-to-date copy reasonably available.",
      "ja": "* クライアントが意図している使用に応じて、さまざまなレプリカの適合性に耐える情報。たとえば、多くのアプリケーションは、絶対に最新のコピー（例えば、書き込み）を必要としていますが、他のアプリケーションは、最新のコピーにのみアクセスできるのみ可能です。"
    },
    {
      "indent": 3,
      "text": "* Server-derived preference information for replicas, which can be used to implement load-balancing while giving the client the entire file system list to be used in case the primary fails.",
      "ja": "* レプリカのサーバー派生環境情報は、クライアントにファイルシステムリスト全体を使用する場合に使用するために使用できます。プライマリが失敗した場合に使用されるファイルシステムリスト全体を使用します。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute is structured similarly to the fs_locations attribute. A top-level structure (fs_locations_info4) contains the entire attribute including the root pathname of the file system and an array of lower-level structures that define replicas that share a common rootpath on their respective servers. The lower-level structure in turn (fs_locations_item4) contains a specific pathname and information on one or more individual network access paths. For that last, lowest level, fs_locations_info has an fs_locations_server4 structure that contains per-server-replica information in addition to the file system location entry. This per-server-replica information includes a nominally opaque array, fls_info, within which specific pieces of information are located at the specific indices listed below.",
      "ja": "fs_locations_info属性は、fs_locations属性と同様に構造化されています。最上位構造（FS_LOCATIOS_INFO4）には、ファイルシステムのルートパス名を含む属性全体と、それぞれのサーバー上の共通のrootPathを共有するレプリカを定義する下位レベルの構造の配列が含まれています。低レベル構造（FS_LOCATIONS_ITEM4）には、特定のパス名と1つ以上のネットワークアクセスパスに関する情報が含まれています。その最後の最低レベルの場合、FS_LOCATIONS_INFOは、ファイルシステムの場所エントリに加えて、サーバーごとの情報を含むFS_LOCATIONS_SERVER4構造を持ちます。このサーバーごとのレプリカ情報には、名目上不透明な配列、FLS_INFOが含まれています。その中に、特定の情報が以下にリストされている特定のインデックスにあります。"
    },
    {
      "indent": 3,
      "text": "Two fs_location_server4 entries that are within different fs_location_item4 structures are never trunkable, while two entries within in the same fs_location_item4 structure might or might not be trunkable. Two entries that are trunkable will have identical identity information, although, as noted above, the converse is not the case.",
      "ja": "異なるFS_LOCATION_ITEM4構造内にある2つのFS_LOCATION_SERVER4エントリはトランクタブルになることはありませんが、同じFS_LOCATION_ITEM4構造内に2つのエントリがトランク不能になる可能性があります。トランクタブルの2つのエントリは同一の識別情報を持ちますが、上記のように、逆の場合はそうではありません。"
    },
    {
      "indent": 3,
      "text": "The attribute will always contain at least a single fs_locations_server entry. Typically, there will be an entry with the FS4LIGF_CUR_REQ flag set, although in the case of a referral there will be no entry with that flag set.",
      "ja": "属性には常に少なくとも単一のFS_LOCATIONS_SERVERエントリが含まれます。通常、FS4LIGF_CUR_REQフラグセットが設定されているため、紹介の場合、そのフラグセットのエントリはありません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that fs_locations_info attributes returned by servers for various replicas may differ for various reasons. One server may know about a set of replicas that are not known to other servers. Further, compatibility attributes may differ. Filehandles might be of the same class going from replica A to replica B but not going in the reverse direction. This might happen because the filehandles are the same, but replica B's server implementation might not have provision to note and report that equivalence.",
      "ja": "さまざまなレプリカのサーバーによって返されるFS_LOCATIONS_INFO属性は、さまざまな理由で異なる場合があります。1つのサーバーは、他のサーバーに認識されていないレプリカのセットについて知ることができます。また、互換性属性が異なる場合があります。FileHandlesは、レプリカAからレプリカBへの同じクラスであるが、逆方向には発生していない可能性があります。これは、ファイルハンドルが同じであるために発生する可能性がありますが、レプリカBのサーバー実装には、メモがプロビジョニングされず、その等価性を報告する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute consists of a root pathname (fli_fs_root, just like fs_root in the fs_locations attribute), together with an array of fs_location_item4 structures. The fs_location_item4 structures in turn consist of a root pathname (fli_rootpath) together with an array (fli_entries) of elements of data type fs_locations_server4, all defined as follows.",
      "ja": "fs_locations_info属性は、FS_LOCATION_ITEM4構造の配列とともに、ルートパス名（FS_LOCATIONS属性のFS_LOOTのようなFS_ROOTのようなFLI_FS_ROOT）で構成されています。FS_LOCATION_ITEM4構造は、データ型FS_LOCATIONS_SERVER4の要素の配列（FLI_ENTRIES）と一緒にルートパス名（FLI_ROTPATH）で構成されています。"
    },
    {
      "indent": 3,
      "text": "/*\n * Defines an individual server access path\n */\nstruct  fs_locations_server4 {\n        int32_t         fls_currency;\n        opaque          fls_info<>;\n        utf8str_cis     fls_server;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Byte indices of items within\n * fls_info: flag fields, class numbers,\n * bytes indicating ranks and orders.\n */\nconst FSLI4BX_GFLAGS            = 0;\nconst FSLI4BX_TFLAGS            = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const FSLI4BX_CLSIMUL           = 2;\nconst FSLI4BX_CLHANDLE          = 3;\nconst FSLI4BX_CLFILEID          = 4;\nconst FSLI4BX_CLWRITEVER        = 5;\nconst FSLI4BX_CLCHANGE          = 6;\nconst FSLI4BX_CLREADDIR         = 7;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const FSLI4BX_READRANK          = 8;\nconst FSLI4BX_WRITERANK         = 9;\nconst FSLI4BX_READORDER         = 10;\nconst FSLI4BX_WRITEORDER        = 11;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Bits defined within the general flag byte.\n */\nconst FSLI4GF_WRITABLE          = 0x01;\nconst FSLI4GF_CUR_REQ           = 0x02;\nconst FSLI4GF_ABSENT            = 0x04;\nconst FSLI4GF_GOING             = 0x08;\nconst FSLI4GF_SPLIT             = 0x10;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Bits defined within the transport flag byte.\n */\nconst FSLI4TF_RDMA              = 0x01;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Defines a set of replicas sharing\n * a common value of the rootpath\n * within the corresponding\n * single-server namespaces.\n */\nstruct  fs_locations_item4 {\n        fs_locations_server4    fli_entries<>;\n        pathname4               fli_rootpath;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Defines the overall structure of\n * the fs_locations_info attribute.\n */\nstruct  fs_locations_info4 {\n        uint32_t                fli_flags;\n        int32_t                 fli_valid_for;\n        pathname4               fli_fs_root;\n        fs_locations_item4      fli_items<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Flag bits in fli_flags.\n */\nconst FSLI4IF_VAR_SUB           = 0x00000001;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef fs_locations_info4 fattr4_fs_locations_info;",
      "ja": "typedef fs_locations_info4 fattr4_fs_locations_info;"
    },
    {
      "indent": 3,
      "text": "As noted above, the fs_locations_info attribute, when supported, may be requested of absent file systems without causing NFS4ERR_MOVED to be returned. It is generally expected that it will be available for both present and absent file systems even if only a single fs_locations_server4 entry is present, designating the current (present) file system, or two fs_locations_server4 entries designating the previous location of an absent file system (the one just referenced) and its successor location. Servers are strongly urged to support this attribute on all file systems if they support it on any file system.",
      "ja": "上記のように、サポートされている場合、FS_LOCATIONS_INFO属性は、NFS4ERR_MOVEDを返すことなく欠勤のファイルシステムを要求することができます。一般に、現在の（現在）ファイルシステムを指定しても、現在の（現在）ファイルシステム、または存在しないファイルシステムの前の場所を指定している2つのFS_LOCATIONATIONS_SERVER4エントリを指定しても、それが現在および欠席のファイルシステムの両方に使用できると予想されます（参照されたものとその後継者の位置。サーバーは、任意のファイルシステムでサポートされている場合は、すべてのファイルシステムでこの属性をサポートするように強く促されます。"
    },
    {
      "indent": 3,
      "text": "The data presented in the fs_locations_info attribute may be obtained by the server in any number of ways, including specification by the administrator or by current protocols for transferring data among replicas and protocols not yet developed. NFSv4.1 only defines how this information is presented by the server to the client.",
      "ja": "FS_LOCATIONS_INFO属性に表示されるデータは、管理者による仕様や、まだ開発されていないレプリカとプロトコルの間でデータを転送するための現在のプロトコルを含む、任意の数の方法でサーバーによって取得されます。NFSV4.1は、この情報がサーバーによってどのように表示されるかを定義します。"
    },
    {
      "indent": 0,
      "text": "11.17.1. The fs_locations_server4 Structure",
      "section_title": true,
      "ja": "11.17.1. fs_locations_server4構造体"
    },
    {
      "indent": 3,
      "text": "The fs_locations_server4 structure consists of the following items in addition to the fls_server field, which specifies a network address or set of addresses to be used to access the specified file system. Note that both of these items (i.e., fls_currency and fls_info) specify attributes of the file system replica and should not be different when there are multiple fs_locations_server4 structures, each specifying a network path to the chosen replica, for the same replica.",
      "ja": "FS_LOCATIONS_SERVER4構造は、指定されたファイルシステムにアクセスするために使用されるネットワークアドレスまたは一連のアドレスを指定するFLS_SERVERフィールドに加えて、以下の項目から構成されています。これらの項目（すなわち、FLS_CURRENCYおよびFLS_INFO）の両方は、ファイルシステムレプリカの属性を指定し、複数のFS_LOCATIONS_SERVER4構造がある場合に異なってはならず、それぞれが選択されたレプリカへのネットワークパスを指定してください。"
    },
    {
      "indent": 3,
      "text": "When these values are different in two fs_locations_server4 structures, a client has no basis for choosing one over the other and is best off simply ignoring both entries, whether these entries apply to migration replication or referral. When there are more than two such entries, majority voting can be used to exclude a single erroneous entry from consideration. In the case in which trunking information is provided for a replica currently being accessed, the additional trunked addresses can be ignored while access continues on the address currently being used, even if the entry corresponding to that path might be considered invalid.",
      "ja": "これらの値が2つのFS_LOCATIONS_SERVER4構造で異なる場合、クライアントはもう一方を選択するための基本を持ち、両方のエントリを無視するだけでなく、これらのエントリが移行複製または紹介に適用されます。そのようなエントリが2つ以上ある場合、大多数の投票を使用して、単一の誤ったエントリを考慮から除外することができます。現在アクセスされているレプリカにトランキング情報が提供されている場合、そのパスに対応するエントリが無効と見なされていても、追加のトランクアドレスを無視することができます。"
    },
    {
      "indent": 3,
      "text": "* An indication of how up-to-date the file system is (fls_currency) in seconds. This value is relative to the master copy. A negative value indicates that the server is unable to give any reasonably useful value here. A value of zero indicates that the file system is the actual writable data or a reliably coherent and fully up-to-date copy. Positive values indicate how out-of-date this copy can normally be before it is considered for update. Such a value is not a guarantee that such updates will always be performed on the required schedule but instead serves as a hint about how far the copy of the data would be expected to be behind the most up-to-date copy.",
      "ja": "* ファイルシステムの最新情報がどのように（fls_currency）の指示を秒単位で表示します。この値はマスターコピーを基準にしています。負の値は、サーバーがここでは合理的に有用な値を与えることができないことを示します。ゼロの値は、ファイルシステムが実際の書き込み可能データまたは確実にコヒーレントで完全に最新のコピーであることを示します。正の値は、このコピーが正常に更新のために考慮されるまでの最新のものであるかを示します。そのような値は、そのような更新が常に必要なスケジュールで実行されるのが保証ではありませんが、代わりにデータのコピーが最新のコピーの背後にあると予想されるかについてのヒントとして機能します。"
    },
    {
      "indent": 3,
      "text": "* A counted array of one-byte values (fls_info) containing information about the particular file system instance. This data includes general flags, transport capability flags, file system equivalence class information, and selection priority information. The encoding will be discussed below.",
      "ja": "* 特定のファイルシステムインスタンスに関する情報を含む1バイト値（FLS_INFO）のカウントされた配列。このデータは、一般フラグ、トランスポート機能フラグ、ファイルシステムの同値クラス情報、および選択優先情報を含む。符号化については後述する。"
    },
    {
      "indent": 3,
      "text": "* The server string (fls_server). For the case of the replica currently being accessed (via GETATTR), a zero-length string MAY be used to indicate the current address being used for the RPC call. The fls_server field can also be an IPv4 or IPv6 address, formatted the same way as an IPv4 or IPv6 address in the \"server\" field of the fs_location4 data type (see Section 11.16).",
      "ja": "* サーバーストリング（FLS_SERVER）。現在アクセスされているレプリカの場合（getAttrをvia via via virce virce）、RPC呼び出しに使用されている現在のアドレスを示すために長さゼロの文字列を使用できます。FLS_SERVERフィールドは、FS_LOCATION4データ型の「サーバ」フィールドのIPv4またはIPv6アドレスと同じ方法でフォーマットされたIPv4またはIPv6アドレスでもあります（セクション11.16を参照）。"
    },
    {
      "indent": 3,
      "text": "With the exception of the transport-flag field (at offset FSLI4BX_TFLAGS with the fls_info array), all of this data defined in this specification applies to the replica specified by the entry, rather than the specific network path used to access it. The classification of data in extensions to this data is discussed below.",
      "ja": "トランスポートフラグフィールド（FLS_INFOアレイを使用したオフセットFSLI4BX_TFLAGSで）を除いて、この仕様で定義されているすべてのデータは、アクセスに使用される特定のネットワークパスではなく、エントリによって指定されたレプリカに適用されます。このデータへの拡張子内のデータの分類については後述する。"
    },
    {
      "indent": 3,
      "text": "Data within the fls_info array is in the form of 8-bit data items with constants giving the offsets within the array of various values describing this particular file system instance. This style of definition was chosen, in preference to explicit XDR structure definitions for these values, for a number of reasons.",
      "ja": "FLS_INFO配列内のデータは、この特定のファイルシステムインスタンスを記述するさまざまな値の配列内のオフセットを与える定数を持つ8ビットのデータ項目の形式です。この定義スタイルは、これらの値の明示的なXDR構造定義を好む、多くの理由で選択されました。"
    },
    {
      "indent": 3,
      "text": "* The kinds of data in the fls_info array, representing flags, file system classes, and priorities among sets of file systems representing the same data, are such that 8 bits provide a quite acceptable range of values. Even where there might be more than 256 such file system instances, having more than 256 distinct classes or priorities is unlikely.",
      "ja": "* 同じデータを表すファイルシステムのセット間のフラグ、ファイルシステムクラス、および優先順位を表すFLS_INFOアレイのデータの種類は、8ビットが非常に許容可能な値を提供するようなものです。256を超える可能性がある場合でも、256を超える異なるクラスまたは優先順位を持つことはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "* Explicit definition of the various specific data items within XDR would limit expandability in that any extension within would require yet another attribute, leading to specification and implementation clumsiness. In the context of the NFSv4 extension model in effect at the time fs_locations_info was designed (i.e., that which is described in RFC 5661 [66]), this would necessitate a new minor version to effect any Standards Track extension to the data in fls_info.",
      "ja": "* XDR内のさまざまな特定のデータ項目の明示的な定義は、任意の拡張機能がさらに別の属性を必要とし、仕様と実装性をもたらすという点で拡張性を制限します。時刻に有効なNFSV4拡張モデルのコンテキストでは、FS_LOCATIONS_INFOが設計されていました（すなわち、RFC 5661 [66]で説明されているもの）、これは新しいマイナーバージョンを必要としています。"
    },
    {
      "indent": 3,
      "text": "The set of fls_info data is subject to expansion in a future minor version or in a Standards Track RFC within the context of a single minor version. The server SHOULD NOT send and the client MUST NOT use indices within the fls_info array or flag bits that are not defined in Standards Track RFCs.",
      "ja": "一連のFLS_INFOデータは、将来のマイナーバージョンまたは標準のマイナーバージョンのコンテキスト内の標準トラックRFCで拡張されます。サーバーは送信しないでください。クライアントは、標準トラックRFCで定義されていないFLS_INFOアレイまたはフラグビット内のインデックスを使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "In light of the new extension model defined in RFC 8178 [67] and the fact that the individual items within fls_info are not explicitly referenced in the XDR, the following practices should be followed when extending or otherwise changing the structure of the data returned in fls_info within the scope of a single minor version:",
      "ja": "RFC 8178で定義されている新しい拡張モデルとFLS_INFO内の個々の項目がXDRで明示的に参照されていないという事実は、FLS_INFOで返されたデータの構造を拡張または変更した場合に次の慣例に従うべきです。単一のマイナーバージョンの範囲内で："
    },
    {
      "indent": 3,
      "text": "* All extensions need to be described by Standards Track documents. There is no need for such documents to be marked as updating RFC 5661 [66] or this document.",
      "ja": "* すべての拡張子は標準トラック文書によって記述される必要があります。このような文書は、RFC 5661 [66]またはこの文書を更新としてマークする必要はありません。"
    },
    {
      "indent": 3,
      "text": "* It needs to be made clear whether the information in any added data items applies to the replica specified by the entry or to the specific network paths specified in the entry.",
      "ja": "* 追加されたデータ項目内の情報がエントリによって指定されたレプリカまたはエントリで指定された特定のネットワークパスに適用されるかどうかを明確にする必要があります。"
    },
    {
      "indent": 3,
      "text": "* There needs to be a reliable way defined to determine whether the server is aware of the extension. This may be based on the length field of the fls_info array, but it is more flexible to provide fs-scope or server-scope attributes to indicate what extensions are provided.",
      "ja": "* サーバーが拡張子を認識しているかどうかを判断するために定義された信頼できる方法が必要です。これはFLS_INFO配列の長さフィールドに基づいていてもよいが、FS-ScopeまたはServer-Scopeの属性を提供するのに柔軟ではありません。"
    },
    {
      "indent": 3,
      "text": "This encoding scheme can be adapted to the specification of multi-byte numeric values, even though none are currently defined. If extensions are made via Standards Track RFCs, multi-byte quantities will be encoded as a range of bytes with a range of indices, with the byte interpreted in big-endian byte order. Further, any such index assignments will be constrained by the need for the relevant quantities not to cross XDR word boundaries.",
      "ja": "このエンコード方式は、現在定義されていなくても、マルチバイト数値の指定に適応できます。標準トラックRFCを介して拡張が行われた場合、マルチバイト数量は、バイトがビッグエンディアンバイトオーダーで解釈された、さまざまなインデックスを持つバイトの範囲としてエンコードされます。さらに、そのようなインデックス割り当ては、XDRワード境界を越えない関連量が必要とされることによって制約されるであろう。"
    },
    {
      "indent": 3,
      "text": "The fls_info array currently contains:",
      "ja": "FLS_INFOアレイには現在含まが含まれています。"
    },
    {
      "indent": 3,
      "text": "* Two 8-bit flag fields, one devoted to general file-system characteristics and a second reserved for transport-related capabilities.",
      "ja": "* 2つの8ビットのフラグフィールド、一般的なファイルシステムの特性と、トランスポート関連の機能のために予約されています。"
    },
    {
      "indent": 3,
      "text": "* Six 8-bit class values that define various file system equivalence classes as explained below.",
      "ja": "* 以下に説明するように、さまざまなファイルシステムの等価クラスを定義する6つの8ビットクラス値。"
    },
    {
      "indent": 3,
      "text": "* Four 8-bit priority values that govern file system selection as explained below.",
      "ja": "* 以下に説明するようにファイルシステムの選択を管理する4つの8ビットの優先値。"
    },
    {
      "indent": 3,
      "text": "The general file system characteristics flag (at byte index FSLI4BX_GFLAGS) has the following bits defined within it:",
      "ja": "一般ファイルシステムの特性フラグ（バイトインデックスのFSLI4BX_GFLAGS）には、次のビットが定義されています。"
    },
    {
      "indent": 3,
      "text": "* FSLI4GF_WRITABLE indicates that this file system target is writable, allowing it to be selected by clients that may need to write on this file system. When the current file system instance is writable and is defined as of the same simultaneous use class (as specified by the value at index FSLI4BX_CLSIMUL) to which the client was previously writing, then it must incorporate within its data any committed write made on the source file system instance. See Section 11.11.6, which discusses the write-verifier class. While there is no harm in not setting this flag for a file system that turns out to be writable, turning the flag on for a read-only file system can cause problems for clients that select a migration or replication target based on the flag and then find themselves unable to write.",
      "ja": "* fsli4gf_writableこのファイルシステムターゲットが書き込み可能であることを示し、このファイルシステムで書き込む必要があるかもしれないクライアントによって選択されることを可能にします。現在のファイルシステムインスタンスが書き込み可能で、クライアントが以前に書き込んだのと同じ同時使用クラス（index fsli4bx_clsimulの値で指定されている）として定義されている場合は、ソースで行われたコミットされた書き込み任意のデータ内に組み込まれている必要があります。ファイルシステムインスタンス。11.11.6項を参照してください。これは、Write-Verifierクラスについて説明します。書き込み可能なファイルシステムのフラグを設定しないことに害はないが、読み取り専用ファイルシステムのフラグをオンにすると、フラグに基づいて移行または複製先を選択するクライアントに問題が発生する可能性があります。自分自身を書くことができないと思います。"
    },
    {
      "indent": 3,
      "text": "* FSLI4GF_CUR_REQ indicates that this replica is the one on which the request is being made. Only a single server entry may have this flag set and, in the case of a referral, no entry will have it set. Note that this flag might be set even if the request was made on a network access path different from any of those specified in the current entry.",
      "ja": "* FSLI4GF_CUR_REQこのレプリカが要求が行われているものであることを示します。このフラグが設定されていて、紹介の場合、エントリは設定されないようにします。このフラグは、現在のエントリで指定された方とは異なるネットワークアクセスパスで要求が行われても設定されている場合があります。"
    },
    {
      "indent": 3,
      "text": "* FSLI4GF_ABSENT indicates that this entry corresponds to an absent file system replica. It can only be set if FSLI4GF_CUR_REQ is set. When both such bits are set, it indicates that a file system instance is not usable but that the information in the entry can be used to determine the sorts of continuity available when switching from this replica to other possible replicas. Since this bit can only be true if FSLI4GF_CUR_REQ is true, the value could be determined using the fs_status attribute, but the information is also made available here for the convenience of the client. An entry with this bit, since it represents a true file system (albeit absent), does not appear in the event of a referral, but only when a file system has been accessed at this location and has subsequently been migrated.",
      "ja": "* FSLI4GF_ABSENTこのエントリは、不在のファイルシステムレプリカに対応することを示します。FSLI4GF_CUR_REQが設定されている場合にのみ設定できます。両方のビットが設定されている場合、ファイルシステムインスタンスが使用できないことを示しますが、エントリ内の情報を使用して、このレプリカから他の可能なレプリカに切り替えるときに使用可能な継続の種類を決定できます。このビットはFSLI4GF_CUR_REQがTRUEの場合にのみ該当するため、値はFS_STATUS属性を使用して決定できますが、その情報はクライアントの利便性のためにここで利用可能にされています。このビットのエントリは、真のファイルシステムを表しているため（不在）以降、紹介の場合には表示されませんが、ファイルシステムがこの場所でアクセスされ、その後移行された場合にのみ表示されます。"
    },
    {
      "indent": 3,
      "text": "* FSLI4GF_GOING indicates that a replica, while still available, should not be used further. The client, if using it, should make an orderly transfer to another file system instance as expeditiously as possible. It is expected that file systems going out of service will be announced as FSLI4GF_GOING some time before the actual loss of service. It is also expected that the fli_valid_for value will be sufficiently small to allow clients to detect and act on scheduled events, while large enough that the cost of the requests to fetch the fs_locations_info values will not be excessive. Values on the order of ten minutes seem reasonable.",
      "ja": "* FSLI4GF_INGは、レプリカがまだ利用可能であることを示していますが、さらに使用しないでください。クライアントは、使用する場合は、できるだけ迅速に別のファイルシステムインスタンスに整然とした転送する必要があります。サービスが不安定になるファイルシステムは、実際のサービスの喪失の前に、FSLI4GF_GOINGとして発表される予定です。また、クライアントがスケジュールされたイベントを検出して行動することができるようにFLI_VALID_FOR値が十分に小さくなると予想されますが、FS_LOCATIONS_INFO値を取得する要求のコストは過度にはなりません。10分程度の値は合理的です。"
    },
    {
      "indent": 6,
      "text": "When this flag is seen as part of a transition into a new file system, a client might choose to transfer immediately to another replica, or it may reference the current file system and only transition when a migration event occurs. Similarly, when this flag appears as a replica in the referral, clients would likely avoid being referred to this instance whenever there is another choice.",
      "ja": "このフラグが新しいファイルシステムへの移行の一部として見られる場合、クライアントはすぐに別のレプリカに転送するか、または移行イベントが発生したときにのみ遷移することができます。同様に、このフラグが紹介でレプリカとして表示されたとき、クライアントは別の選択があるときはいつでもこのインスタンスに参照されるのを避けるでしょう。"
    },
    {
      "indent": 6,
      "text": "This flag, like the other items within fls_info, applies to the replica rather than to a particular path to that replica. When it appears, a transition to a new replica, rather than to a different path to the same replica, is indicated.",
      "ja": "このフラグは、FLS_INFO内の他の項目と同様に、そのレプリカへの特定のパスではなくレプリカに適用されます。表示されると、同じレプリカへの異なるパスではなく新しいレプリカへの移行が示されます。"
    },
    {
      "indent": 3,
      "text": "* FSLI4GF_SPLIT indicates that when a transition occurs from the current file system instance to this one, the replacement may consist of multiple file systems. In this case, the client has to be prepared for the possibility that objects on the same file system before migration will be on different ones after. Note that FSLI4GF_SPLIT is not incompatible with the file systems belonging to the same fileid class since, if one has a set of fileids that are unique within a file system, each subset assigned to a smaller file system after migration would not have any conflicts internal to that file system.",
      "ja": "* FSLI4GF_SPLITは、現在のファイルシステムインスタンスからこの1つのファイルシステムインスタンスに遷移が発生した場合、置き換えは複数のファイルシステムで構成されています。この場合、移行前に同じファイルシステム上のオブジェクトが異なるものになる可能性のためにクライアントを準備する必要があります。ファイルシステム内で一意のファイルIDのセットがある場合は、FSLI4GF_SPLITが同じFileIDクラスに属するファイルシステムと互換性がないため、移行後に小さいファイルシステムに割り当てられている各サブセットは、内部に競合しないであろう。そのファイルシステム"
    },
    {
      "indent": 6,
      "text": "A client, in the case of a split file system, will interrogate existing files with which it has continuing connection (it is free to simply forget cached filehandles). If the client remembers the directory filehandle associated with each open file, it may proceed upward using LOOKUPP to find the new file system boundaries. Note that in the event of a referral, there will not be any such files and so these actions will not be performed. Instead, a reference to a portion of the original file system now split off into other file systems will encounter an fsid change and possibly a further referral.",
      "ja": "クライアントは、スプリットファイルシステムの場合、それが継続的な接続を持つ既存のファイルを問い合わせます（キャッシュされたファイルハンドルを忘れるだけでは自由です）。クライアントが各開閉ファイルに関連付けられているディレクトリファイルハンドルを記憶している場合は、Lookuppを使用して上に進むことができ、新しいファイルシステムの境界を見つけることができます。紹介が発生した場合は、そのようなファイルがないため、これらの操作は実行されません。代わりに、元のファイルシステムの一部への参照は、他のファイルシステムに分割されているようになりました.FSIDの変更やおそらくさらに紹介が発生します。"
    },
    {
      "indent": 6,
      "text": "Once the client recognizes that one file system has been split into two, it can prevent the disruption of running applications by presenting the two file systems as a single one until a convenient point to recognize the transition, such as a restart. This would require a mapping from the server's fsids to fsids as seen by the client, but this is already necessary for other reasons. As noted above, existing fileids within the two descendant file systems will not conflict. Providing non-conflicting fileids for newly created files on the split file systems is the responsibility of the server (or servers working in concert). The server can encode filehandles such that filehandles generated before the split event can be discerned from those generated after the split, allowing the server to determine when the need for emulating two file systems as one is over.",
      "ja": "クライアントが1つのファイルシステムが2つに分割されていることを認識したら、再起動などの遷移を認識する都合の良い点まで、2つのファイルシステムを単一のものとして表示することで、実行中のアプリケーションの中断を防ぐことができます。これにより、クライアントから見たようにサーバーのFSIDからFSIDへのマッピングが必要になりますが、これは他の理由ですでに必要です。上記のように、2つの子孫ファイルシステム内の既存のファイルIDは競合しません。分割ファイルシステム上の新しく作成されたファイルの矛盾しないファイルIDを提供することは、サーバー（またはコンサートで動作するサーバー）の責任です。サーバーは、分割イベントが分割後に生成されたものから生成される前に生成されたファイルハンドルをエンコードでき、サーバーは2つのファイルシステムを終了する必要があるときにサーバーが終了します。"
    },
    {
      "indent": 6,
      "text": "Although it is possible for this flag to be present in the event of referral, it would generally be of little interest to the client, since the client is not expected to have information regarding the current contents of the absent file system.",
      "ja": "このフラグが紹介の場合に存在する可能性がありますが、クライアントは存在しないファイルシステムの現在の内容に関する情報を持つことが期待されていないため、一般的にクライアントにとってほとんど興味がありません。"
    },
    {
      "indent": 3,
      "text": "The transport-flag field (at byte index FSLI4BX_TFLAGS) contains the following bits related to the transport capabilities of the specific network path(s) specified by the entry:",
      "ja": "トランスポートフラグフィールド（バイトインデックスFSLI4BX_TFLAGS）には、エントリによって指定された特定のネットワークパスのトランスポート機能に関連する次のビットが含まれています。"
    },
    {
      "indent": 3,
      "text": "* FSLI4TF_RDMA indicates that any specified network paths provide NFSv4.1 clients access using an RDMA-capable transport.",
      "ja": "* FSLI4TF_RDMAは、指定されたネットワークパスがRDMA対応トランスポートを使用してNFSV4.1クライアントアクセスを提供することを示します。"
    },
    {
      "indent": 3,
      "text": "Attribute continuity and file system identity information are expressed by defining equivalence relations on the sets of file systems presented to the client. Each such relation is expressed as a set of file system equivalence classes. For each relation, a file system has an 8-bit class number. Two file systems belong to the same class if both have identical non-zero class numbers. Zero is treated as non-matching. Most often, the relevant question for the client will be whether a given replica is identical to / continuous with the current one in a given respect, but the information should be available also as to whether two other replicas match in that respect as well.",
      "ja": "属性の継続性とファイルシステムのID情報は、クライアントに提示されたファイルシステムのセットの等価関係を定義することによって表現されます。そのような各関係は、一組のファイルシステムの等価クラスとして表されます。各関係について、ファイルシステムは8ビットクラス番号を持ちます。両方とも同一のゼロ以外のクラス番号がある場合、2つのファイルシステムは同じクラスに属します。ゼロは非マッチングとして扱われます。ほとんどの場合、クライアントに関する関連質問は、特定のレプリカが現在の点で現在のものと同一/連続しているかどうかになりますが、その点でも2つの他のレプリカが一致するかどうかについても利用できます。"
    },
    {
      "indent": 3,
      "text": "The following fields specify the file system's class numbers for the equivalence relations used in determining the nature of file system transitions. See Sections 11.9 through 11.14 and their various subsections for details about how this information is to be used. Servers may assign these values as they wish, so long as file system instances that share the same value have the specified relationship to one another; conversely, file systems that have the specified relationship to one another share a common class value. As each instance entry is added, the relationships of this instance to previously entered instances can be consulted, and if one is found that bears the specified relationship, that entry's class value can be copied to the new entry. When no such previous entry exists, a new value for that byte index (not previously used) can be selected, most likely by incrementing the value of the last class value assigned for that index.",
      "ja": "次のフィールドは、ファイルシステムの遷移の性質の決定に使用される等価関係のためのファイルシステムのクラス番号を指定します。この情報をどのように使用するかについては、11.9から11.14節およびそれらのさまざまなサブセクションを参照してください。サーバーは、同じ値を共有するファイルシステムインスタンスが互いに指定された関係を持つ限り、それらの値を望むように割り当てることができます。逆に、指定された関係が互いに共通のクラス値を共有するファイルシステム。各インスタンスエントリが追加されると、以前に入力されたインスタンスへのこのインスタンスの関係を調べて、指定された関係を持つ場合は、そのエントリのクラス値を新しいエントリにコピーできます。そのような前のエントリが存在しない場合、そのバイトインデックス（以前に使用されていない）の新しい値を選択することができます。これは、そのインデックスに割り当てられた最後のクラス値の値を増やすことによって、最も可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLSIMUL defines the simultaneous-use class for the file system.",
      "ja": "* バイトインデックスfsli4bx_clsimulを持つフィールドは、ファイルシステムの同時使用クラスを定義します。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLHANDLE defines the handle class for the file system.",
      "ja": "* バイトインデックスfsli4bx_clhandleを含むフィールドは、ファイルシステムのハンドルクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLFILEID defines the fileid class for the file system.",
      "ja": "* バイトインデックスfsli4bx_clfileIdを持つフィールドは、ファイルシステムのfileIDクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLWRITEVER defines the write-verifier class for the file system.",
      "ja": "* バイトインデックスfsli4bx_clwriteverを持つフィールドは、ファイルシステムのWrite-Verifierクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLCHANGE defines the change class for the file system.",
      "ja": "* バイトインデックスfsli4bx_clchangeを持つフィールドは、ファイルシステムの変更クラスを定義します。"
    },
    {
      "indent": 3,
      "text": "* The field with byte index FSLI4BX_CLREADDIR defines the readdir class for the file system.",
      "ja": "* バイトインデックスFSLI4BX_CLREADDIRを持つフィールドは、ファイルシステムのREADDIRクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "Server-specified preference information is also provided via 8-bit values within the fls_info array. The values provide a rank and an order (see below) to be used with separate values specifiable for the cases of read-only and writable file systems. These values are compared for different file systems to establish the server-specified preference, with lower values indicating \"more preferred\".",
      "ja": "サーバー指定された嗜好情報も、FLS_INFO配列内の8ビット値を介して提供されます。値は、読み取り専用ファイルシステムと書き込み可能なファイルシステムの場合に指定できる別の値で使用されるランクと順序（下記参照）を提供します。これらの値は、サーバー指定の環境設定を確立するために異なるファイルシステムに対して比較され、「より優先」を示す値は低いです。"
    },
    {
      "indent": 3,
      "text": "Rank is used to express a strict server-imposed ordering on clients, with lower values indicating \"more preferred\". Clients should attempt to use all replicas with a given rank before they use one with a higher rank. Only if all of those file systems are unavailable should the client proceed to those of a higher rank. Because specifying a rank will override client preferences, servers should be conservative about using this mechanism, particularly when the environment is one in which client communication characteristics are neither tightly controlled nor visible to the server.",
      "ja": "ランクは、クライアント上で厳密なサーバー課税を表すために使用され、より低い値を示す「より優先」を示す。クライアントは、より高いランクを持つものを使用する前に、すべてのレプリカを指定されたランクで使用しようとするはずです。クライアントがより高いランクのものに進む必要がある場合にのみ、これらすべてのファイルシステムが利用できない場合にのみ。ランクを指定するとクライアントの設定が上書きされるため、特に環境がクライアント通信特性がサーバーに緊密に制御されても表示されない場合は、このメカニズムの使用に関する保守的であるべきです。"
    },
    {
      "indent": 3,
      "text": "Within a rank, the order value is used to specify the server's preference to guide the client's selection when the client's own preferences are not controlling, with lower values of order indicating \"more preferred\". If replicas are approximately equal in all respects, clients should defer to the order specified by the server. When clients look at server latency as part of their selection, they are free to use this criterion, but it is suggested that when latency differences are not significant, the server-specified order should guide selection.",
      "ja": "ランク内では、注文値は、クライアントの独自の設定が制御されていないときにクライアントの選択をガイドするためのサーバーの設定を指定するために使用され、「より優先」を示す順序の値は低いです。レプリカがすべての点でほぼ等しい場合、クライアントはサーバーによって指定された順序を延期する必要があります。クライアントが選択の一部としてサーバーの待ち時間を調べると、この基準を自由に使用できますが、待ち時間の違いが重要ではない場合、サーバー指定の順序は選択を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "* The field at byte index FSLI4BX_READRANK gives the rank value to be used for read-only access.",
      "ja": "* バイトインデックスFSLI4BX_READRANKのフィールドは、読み取り専用アクセスに使用されるランク値を示します。"
    },
    {
      "indent": 3,
      "text": "* The field at byte index FSLI4BX_READORDER gives the order value to be used for read-only access.",
      "ja": "* バイトインデックスFSLI4BX_READORDERのフィールドは、読み取り専用アクセスに使用される注文値を示します。"
    },
    {
      "indent": 3,
      "text": "* The field at byte index FSLI4BX_WRITERANK gives the rank value to be used for writable access.",
      "ja": "* バイトインデックスFSLI4BX_WRITerankのフィールドは、書き込み可能なアクセスに使用されるランク値を示します。"
    },
    {
      "indent": 3,
      "text": "* The field at byte index FSLI4BX_WRITEORDER gives the order value to be used for writable access.",
      "ja": "* バイトインデックスFSLI4BX_WRITEORDERのフィールドは、書き込み可能なアクセスに使用される注文値を示します。"
    },
    {
      "indent": 3,
      "text": "Depending on the potential need for write access by a given client, one of the pairs of rank and order values is used. The read rank and order should only be used if the client knows that only reading will ever be done or if it is prepared to switch to a different replica in the event that any write access capability is required in the future.",
      "ja": "所与のクライアントによる書き込みアクセスの可能性に応じて、ランクと順位値のペアの1つが使用されます。読み取りランクと順序は、クライアントが読み取りのみが実行されるだけであることを知っている場合、または将来書き込みアクセス機能が必要な場合に異なるレプリカに切り替える準備ができている場合にのみ使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.17.2. The fs_locations_info4 Structure",
      "section_title": true,
      "ja": "11.17.2. fs_locations_info4構造体"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info4 structure, encoding the fs_locations_info attribute, contains the following:",
      "ja": "fs_locations_info属性をエンコードするFS_LOCATIONS_INFO4構造体には、次のものが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The fli_flags field, which contains general flags that affect the interpretation of this fs_locations_info4 structure and all fs_locations_item4 structures within it. The only flag currently defined is FSLI4IF_VAR_SUB. All bits in the fli_flags field that are not defined should always be returned as zero.",
      "ja": "* FLI_FLAGSフィールド。このFS_LOCATIONS_INFO4構造の解釈に影響を与える一般的なフラグと、その中のすべてのFS_LOCATIONS_ITEM4構造。現在定義されている唯一のフラグはfsli4if_var_subです。定義されていないFLI_Flagsフィールドのすべてのビットは常にゼロとして返されるべきです。"
    },
    {
      "indent": 3,
      "text": "* The fli_fs_root field, which contains the pathname of the root of the current file system on the current server, just as it does in the fs_locations4 structure.",
      "ja": "* FLI_FS_ROOTフィールド。現在のサーバー上の現在のファイルシステムのルートのパス名を含むと、FS_LOCATIONS4構造の場合と同じように。"
    },
    {
      "indent": 3,
      "text": "* An array called fli_items of fs_locations4_item structures, which contain information about replicas of the current file system. Where the current file system is actually present, or has been present, i.e., this is not a referral situation, one of the fs_locations_item4 structures will contain an fs_locations_server4 for the current server. This structure will have FSLI4GF_ABSENT set if the current file system is absent, i.e., normal access to it will return NFS4ERR_MOVED.",
      "ja": "* FS_LOCATIONS4_ITEM構造体のFLI_ITEMSと呼ばれる配列。これには、現在のファイルシステムのレプリカに関する情報が含まれています。現在のファイルシステムが実際に存在するか、または存在している、すなわちこれは紹介状況ではなく、FS_LOCATIONS_ITEM4構造のうちの1つは現在のサーバのFS_LOCATIONS_SERVER4を含むであろう。現在のファイルシステムが存在しない場合、すなわち通常のアクセスがNFS4ERR_MOUDを返す場合、この構造はFSLI4GF_ABSENTを設定します。"
    },
    {
      "indent": 3,
      "text": "* The fli_valid_for field specifies a time in seconds for which it is reasonable for a client to use the fs_locations_info attribute without refetch. The fli_valid_for value does not provide a guarantee of validity since servers can unexpectedly go out of service or become inaccessible for any number of reasons. Clients are well-advised to refetch this information for an actively accessed file system at every fli_valid_for seconds. This is particularly important when file system replicas may go out of service in a controlled way using the FSLI4GF_GOING flag to communicate an ongoing change. The server should set fli_valid_for to a value that allows well-behaved clients to notice the FSLI4GF_GOING flag and make an orderly switch before the loss of service becomes effective. If this value is zero, then no refetch interval is appropriate and the client need not refetch this data on any particular schedule. In the event of a transition to a new file system instance, a new value of the fs_locations_info attribute will be fetched at the destination. It is to be expected that this may have a different fli_valid_for value, which the client should then use in the same fashion as the previous value. Because a refetch of the attribute causes information from all component entries to be refetched, the server will typically provide a low value for this field if any of the replicas are likely to go out of service in a short time frame. Note that, because of the ability of the server to return NFS4ERR_MOVED to trigger the use of different paths, when alternate trunked paths are available, there is generally no need to use low values of fli_valid_for in connection with the management of alternate paths to the same replica.",
      "ja": "* FLI_VALID_FORフィールドは、クライアントがリフェッチなしでFS_LOCATIONS_INFO属性を使用するように合理的な時間を秒単位で指定します。 FLI_VALID_FOR値は、サーバーが予期せずにサービスを外したり、任意の理由でアクセスできなくなるため、有効性の保証はありません。クライアントは、すべてのFLI_VALID_FOR秒で積極的にアクセスされたファイルシステムのためにこの情報を参照することをお勧めします。これは、ファイルシステムのレプリカがFSLI4GF_GOINGフラグを使用して制御された方法でサービスを外して継続的な変更を伝えることができる場合に特に重要です。サーバーは、FLI_VALID_FORを設定して、動作不正のクライアントがFSLI4GF_GOINGフラグに気付いて、サービスの損失が有効になる前に整然としたスイッチを作ります。この値がゼロの場合、リフェクト間隔は適切であり、クライアントは特定のスケジュールでこのデータを参照する必要はありません。新しいファイルシステムインスタンスへの移行が発生した場合、FS_LOCATIONS_INFO属性の新しい値が宛先でフェッチされます。これは異なるFLI_VALID_FOR値を持つことができ、クライアントは前の値と同じ方法で使用する必要があります。属性のリフェッチは、すべてのコンポーネントエントリからの情報をリフィッチさせるため、通常は短い時間枠でサービスを外す可能性がある場合、サーバーは通常このフィールドに低い値を提供します。サーバーがNFS4ERR_MOVEDを返す能力のために、異なるパスの使用をトリガーするために、代替トランクパスが使用可能な場合、同じへの代替パスの管理に関連してFLI_VALID_FORの低い値を使用する必要はありません。レプリカ。"
    },
    {
      "indent": 3,
      "text": "The FSLI4IF_VAR_SUB flag within fli_flags controls whether variable substitution is to be enabled. See Section 11.17.3 for an explanation of variable substitution.",
      "ja": "FLI_FLAGS内のFSLI4IF_VAR_SUBフラグは、変数置換を有効にするかどうかを制御します。変数置換の説明については11.17.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "11.17.3. The fs_locations_item4 Structure",
      "section_title": true,
      "ja": "11.17.3. fs_locations_item4構造体"
    },
    {
      "indent": 3,
      "text": "The fs_locations_item4 structure contains a pathname (in the field fli_rootpath) that encodes the path of the target file system replicas on the set of servers designated by the included fs_locations_server4 entries. The precise manner in which this target location is specified depends on the value of the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure.",
      "ja": "fs_locations_item4構造体には、含まれているFS_LOCATIONS_SERVER4エントリによって指定されたサーバーのセットのターゲットファイルシステムレプリカのパスをエンコードするパス名（フィールドFLI_ROOTPATH）が含まれています。このターゲット位置が指定されている正確な方法は、関連するFS_LOCATIONS_INFO4構造内のFSLI4IF_VAR_SUBフラグの値によって異なります。"
    },
    {
      "indent": 3,
      "text": "If this flag is not set, then fli_rootpath simply designates the location of the target file system within each server's single-server namespace just as it does for the rootpath within the fs_location4 structure. When this bit is set, however, component entries of a certain form are subject to client-specific variable substitution so as to allow a degree of namespace non-uniformity in order to accommodate the selection of client-specific file system targets to adapt to different client architectures or other characteristics.",
      "ja": "このフラグが設定されていない場合、FLI_ROOTPATHは、FS_LOCATION4構造内のrootPathと同じように、各サーバーのシングルサーバーネームスペース内のターゲットファイルシステムの場所を単に指定します。しかしながら、このビットが設定されると、ある形式のコンポーネントエントリは、クライアント固有のファイルシステムターゲットの選択に適応するためにある程度の名前空間の不均一性を可能にするためにクライアント固有の変数置換の対象となる。クライアントアーキテクチャまたは他の特性。"
    },
    {
      "indent": 3,
      "text": "When such substitution is in effect, a variable beginning with the string \"${\" and ending with the string \"}\" and containing a colon is to be replaced by the client-specific value associated with that variable. The string \"unknown\" should be used by the client when it has no value for such a variable. The pathname resulting from such substitutions is used to designate the target file system, so that different clients may have different file systems, corresponding to that location in the multi-server namespace.",
      "ja": "そのような置換が有効な場合、文字列 \"$ {\"と文字列 \"}\"で終了し、コロンを含む変数は、その変数に関連したクライアント固有の値に置き換えられます。そのような変数に値がない場合、文字列「不明」はクライアントによって使用されるべきです。そのような置換から生じるパス名は、ターゲットファイルシステムを指定するために使用されるので、さまざまなクライアントは、マルチサーバーネームスペース内のその場所に対応する異なるファイルシステムを持つことができます。"
    },
    {
      "indent": 3,
      "text": "As mentioned above, such substituted pathname variables contain a colon. The part before the colon is to be a DNS domain name, and the part after is to be a case-insensitive alphanumeric string.",
      "ja": "上述のように、そのような置換経路変数は結腸を含む。コロンの前の部分はDNSドメイン名であり、その後の部分は大文字と小文字を区別しない英数字文字列であることです。"
    },
    {
      "indent": 3,
      "text": "Where the domain is \"ietf.org\", only variable names defined in this document or subsequent Standards Track RFCs are subject to such substitution. Organizations are free to use their domain names to create their own sets of client-specific variables, to be subject to such substitution. In cases where such variables are intended to be used more broadly than a single organization, publication of an Informational RFC defining such variables is RECOMMENDED.",
      "ja": "ドメインが \"ietf.org\"である場合、このドキュメントまたは後続の標準トラックRFCで定義されている変数名のみがその代入の対象となります。組織は、そのドメイン名を使用して自分のクライアント固有の変数を作成し、その代入の対象となる独自のセットを作成できます。そのような変数が単一の組織よりも広く使用されることを意図している場合、そのような変数を定義する情報RFCの出版は推奨されます。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:CPU_ARCH} is used to denote that the CPU architecture object files are compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as \"x86\", \"x86_64\", and \"sparc\" would be expected to be used in line with industry practice.",
      "ja": "変数$ {ietf.org：cpu_arch}は、CPUアーキテクチャオブジェクトファイルがコンパイルされていることを示すために使用されます。この仕様は許容値を制限しません（それらが有効なUTF-8文字列でなければならないことを除く）が、「x86」、「x86_64」、および「SPARC」という値は、業界慣行に沿って使用される予定です。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:OS_TYPE} is used to denote the operating system, and thus the kernel and library APIs, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as \"linux\" and \"freebsd\" would be expected to be used in line with industry practice.",
      "ja": "変数$ {ietf.org：os_type}は、オペレーティングシステム、したがってカーネルとライブラリAPIを示すために使用され、したがってコードがコンパイルされる可能性があります。この仕様は許容値を制限しません（それらが有効なUTF-8文字列でなければならないことを除く）が、「Linux」と「FreeBSD」というそのような値は業界慣行に沿って使用されると予想されます。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:OS_VERSION} is used to denote the operating system version, and thus the specific details of versioned interfaces, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings). However, combinations of numbers and letters with interspersed dots would be expected to be used in line with industry practice, with the details of the version format depending on the specific value of the variable ${ietf.org:OS_TYPE} with which it is used.",
      "ja": "変数$ {ietf.org：os_version}は、オペレーティングシステムのバージョン、したがってコード化されたインターフェイスの特定の詳細を示すために使用され、コードがコンパイルされる可能性があります。この仕様は許容値を制限しません（それらが有効なUTF-8文字列でなければならないことを除く）。ただし、数字と文字の組み合わせは、業界の慣習に沿って使用されることが予想され、それが使用されている変数$ {ietf.org:os_type}の特定の値に応じてバージョン形式の詳細は。"
    },
    {
      "indent": 3,
      "text": "Use of these variables could result in the direction of different clients to different file systems on the same server, as appropriate to particular clients. In cases in which the target file systems are located on different servers, a single server could serve as a referral point so that each valid combination of variable values would designate a referral hosted on a single server, with the targets of those referrals on a number of different servers.",
      "ja": "これらの変数を使用すると、同じサーバー上の異なるクライアントの方向が、特定のクライアントに応じて、同じサーバー上のさまざまなファイルシステムへの方向が発生する可能性があります。ターゲットファイルシステムが異なるサーバー上にある場合、単一のサーバーは紹介時点として機能し、変数値の各有効な組み合わせが単一のサーバー上でホストされている紹介を指定し、それらの参照のターゲットを番号に指定することができます。さまざまなサーバーの。"
    },
    {
      "indent": 3,
      "text": "Because namespace administration is affected by the values selected to substitute for various variables, clients should provide convenient means of determining what variable substitutions a client will implement, as well as, where appropriate, providing means to control the substitutions to be used. The exact means by which this will be done is outside the scope of this specification.",
      "ja": "ネームスペース管理はさまざまな変数の代わりに選択された値の影響を受けているため、クライアントはクライアントがどのような変数置換を実行するか、および適切な場合には使用される置換を制御する手段を決定する便利な手段を提供する必要があります。これが行われる正確な手段は、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Although variable substitution is most suitable for use in the context of referrals, it may be used in the context of replication and migration. If it is used in these contexts, the server must ensure that no matter what values the client presents for the substituted variables, the result is always a valid successor file system instance to that from which a transition is occurring, i.e., that the data is identical or represents a later image of a writable file system.",
      "ja": "変数置換は紹介の文脈における使用に最も適していますが、それは複製と移行のコンテキストで使用されるかもしれません。これらのコンテキストで使用されている場合、サーバーは、クライアントが置換変数を紹介する値に関係なく、結果は常に有効な後継ファイルシステムインスタンス、つまり、データがデータの遷移が発生していることから、書き込み可能なファイルシステムの後の画像を同一または表します。"
    },
    {
      "indent": 3,
      "text": "Note that when fli_rootpath is a null pathname (that is, one with zero components), the file system designated is at the root of the specified server, whether or not the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure is set.",
      "ja": "FLI_ROOTPATHがNULLパス名（つまり、コンポーネントをゼロの1つ）である場合、指定されたファイルシステムは指定されたサーバーのルートにあり、関連するFS_LOCATIONS_INFO4構造内のFSLI4IF_VAR_SUBフラグが設定されているかどうか。"
    },
    {
      "indent": 0,
      "text": "11.18. The Attribute fs_status",
      "section_title": true,
      "ja": "11.18. 属性FS_STATUS"
    },
    {
      "indent": 3,
      "text": "In an environment in which multiple copies of the same basic set of data are available, information regarding the particular source of such data and the relationships among different copies can be very helpful in providing consistent data to applications.",
      "ja": "同じ基本データセットの複数のコピーが利用可能である環境では、そのようなデータの特定のソースに関する情報と異なるコピー間の関係は、一貫したデータをアプリケーションに提供するのに非常に役立ちます。"
    },
    {
      "indent": 3,
      "text": "enum fs4_status_type {\n        STATUS4_FIXED = 1,\n        STATUS4_UPDATED = 2,\n        STATUS4_VERSIONED = 3,\n        STATUS4_WRITABLE = 4,\n        STATUS4_REFERRAL = 5\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct fs4_status {\n        bool            fss_absent;\n        fs4_status_type fss_type;\n        utf8str_cs      fss_source;\n        utf8str_cs      fss_current;\n        int32_t         fss_age;\n        nfstime4        fss_version;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The boolean fss_absent indicates whether the file system is currently absent. This value will be set if the file system was previously present and becomes absent, or if the file system has never been present and the type is STATUS4_REFERRAL. When this boolean is set and the type is not STATUS4_REFERRAL, the remaining information in the fs4_status reflects that last valid when the file system was present.",
      "ja": "Boolean FSS_BSENTは、ファイルシステムが現在不在であるかどうかを示します。ファイルシステムが以前に存在していた場合、またはファイルシステムが存在したことがなく、タイプがstatus4_referralの場合、この値は設定されます。このブール値が設定され、タイプがstatus4_referralではない場合、fs4_status内の残りの情報はファイルシステムが存在するときに最後に有効であることを反映しています。"
    },
    {
      "indent": 3,
      "text": "The fss_type field indicates the kind of file system image represented. This is of particular importance when using the version values to determine appropriate succession of file system images. When fss_absent is set, and the file system was previously present, the value of fss_type reflected is that when the file was last present. Five values are distinguished:",
      "ja": "FSS_TYPEフィールドは、表されるファイルシステムイメージの種類を示します。これは、バージョン値を使用してファイルシステムイメージの適切な連続を決定するときに特に重要です。fss_absentが設定されていてファイルシステムが存在すると、FSS_TYPEの値が反映されている場合は、ファイルが最後に存在したときです。5つの値が区別されています。"
    },
    {
      "indent": 3,
      "text": "* STATUS4_FIXED, which indicates a read-only image in the sense that it will never change. The possibility is allowed that, as a result of migration or switch to a different image, changed data can be accessed, but within the confines of this instance, no change is allowed. The client can use this fact to cache aggressively.",
      "ja": "* STATUS4_FIXED。移行または異なる画像への切り替えの結果として、変更されたデータにアクセスすることができるが、このインスタンスの範囲内で変更は許可されないことが可能になる。クライアントはこの事実を使用して積極的にキャッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "* STATUS4_VERSIONED, which indicates that the image, like the STATUS4_UPDATED case, is updated externally, but it provides a guarantee that the server will carefully update an associated version value so that the client can protect itself from a situation in which it reads data from one version of the file system and then later reads data from an earlier version of the same file system. See below for a discussion of how this can be done.",
      "ja": "* status4_versioned.thate4_updatedケースのようなイメージが外部から更新されていることを示すが、それはサーバが関連するバージョン値を慎重に更新することを保証するので、クライアントは1つのバージョンからデータを読み取る状況からそれ自体を保護することができる。ファイルシステムのうち、後で同じファイルシステムの以前のバージョンからデータを読み取ります。これがどのように行うことができるかについての議論については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "* STATUS4_UPDATED, which indicates an image that cannot be updated by the user writing to it but that may be changed externally, typically because it is a periodically updated copy of another writable file system somewhere else. In this case, version information is not provided, and the client does not have the responsibility of making sure that this version only advances upon a file system instance transition. In this case, it is the responsibility of the server to make sure that the data presented after a file system instance transition is a proper successor image and includes all changes seen by the client and any change made before all such changes.",
      "ja": "* STATUS4_UPDATEDは、ユーザーが書くことができないが外部から変更されることがある画像を示しますが、通常は他の書き込み可能なファイルシステムの定期的に更新されたコピーであるため、通常は他の書き込み可能なファイルシステムのコピーであるためです。この場合、バージョン情報は提供されておらず、クライアントはこのバージョンがファイルシステムインスタンス遷移に遷移するだけであることを確認するという責任を負いません。この場合、ファイルシステムインスタンス遷移の後に提示されたデータが適切な後続画像であり、クライアントによって見られるすべての変更とすべての変更の前に行われた変更を含むことが確実にサーバーの責任です。"
    },
    {
      "indent": 3,
      "text": "* STATUS4_WRITABLE, which indicates that the file system is an actual writable one. The client need not, of course, actually write to the file system, but once it does, it should not accept a transition to anything other than a writable instance of that same file system.",
      "ja": "* file systemが実際の書き込み可能なものであることを示します。クライアントは、もちろん、実際にはファイルシステムに書き込む必要はありませんが、一度そうであると、同じファイルシステムの書き込み可能なインスタンス以外のものへの移行を受け入れないでください。"
    },
    {
      "indent": 3,
      "text": "* STATUS4_REFERRAL, which indicates that the file system in question is absent and has never been present on this server.",
      "ja": "* STATUS4_REFERRAL。問題のファイルシステムが不在で、このサーバーに存在していないことを示します。"
    },
    {
      "indent": 3,
      "text": "Note that in the STATUS4_UPDATED and STATUS4_VERSIONED cases, the server is responsible for the appropriate handling of locks that are inconsistent with external changes to delegations. If a server gives out delegations, they SHOULD be recalled before an inconsistent change is made to the data, and MUST be revoked if this is not possible. Similarly, if an OPEN is inconsistent with data that is changed (the OPEN has OPEN4_SHARE_DENY_WRITE/OPEN4_SHARE_DENY_BOTH and the data is changed), that OPEN SHOULD be considered administratively revoked.",
      "ja": "ステータス4_UPDATEDおよびSTATUS4_VERSIVEDケースでは、サーバーは、委任の外部の変更と矛盾するロックの適切な処理を担当します。サーバーが代表団を出す場合は、データに対して矛盾した変更が加えられる前に呼び出す必要があり、これが不可能な場合は取り消される必要があります。同様に、変更が変更されたデータとが矛盾している場合（OpenはOpen4_Share_Deny_Deny_bothとデータを変更され、データが変更されます）、その開いたことは管理上の取り消しと見なされるべきです。"
    },
    {
      "indent": 3,
      "text": "The opaque strings fss_source and fss_current provide a way of presenting information about the source of the file system image being present. It is not intended that the client do anything with this information other than make it available to administrative tools. It is intended that this information be helpful when researching possible problems with a file system image that might arise when it is unclear if the correct image is being accessed and, if not, how that image came to be made. This kind of diagnostic information will be helpful, if, as seems likely, copies of file systems are made in many different ways (e.g., simple user-level copies, file-system-level point-in-time copies, clones of the underlying storage), under a variety of administrative arrangements. In such environments, determining how a given set of data was constructed can be very helpful in resolving problems.",
      "ja": "不透明文字列FSS_SourceとFSS_Currentは、存在しているファイルシステムイメージのソースに関する情報を提示する方法を提供します。クライアントが管理ツールで利用できること以外のこの情報を使用して何かをすることは意図されていません。正しいイメージがアクセスされている場合に発生する可能性があるファイルシステムイメージに関する可能性のある問題を調べ、そうでなければそのイメージがどのように行われるべきかどうかを調べることは、この情報が役立つことが意図されています。このような診断情報は、可能性が高いように、ファイルシステムのコピーがさまざまな方法で行われている場合（例：単純なユーザーレベルのコピー、ファイルシステムレベルのポイントコピー、基礎となるクローンのクローンなど）。さまざまな行政手配の下で保管してください。そのような環境では、特定のデータセットがどのように構築されたかを決定することが問題を解決するのに非常に役立ちます。"
    },
    {
      "indent": 3,
      "text": "The opaque string fss_source is used to indicate the source of a given file system with the expectation that tools capable of creating a file system image propagate this information, when possible. It is understood that this may not always be possible since a user-level copy may be thought of as creating a new data set and the tools used may have no mechanism to propagate this data. When a file system is initially created, it is desirable to associate with it data regarding how the file system was created, where it was created, who created it, etc. Making this information available in this attribute in a human-readable string will be helpful for applications and system administrators and will also serve to make it available when the original file system is used to make subsequent copies.",
      "ja": "不透明ストリングFSS_SOURCEは、ファイルシステムイメージを作成できるツールが可能な限りこの情報を伝播することができるという期待を持つ特定のファイルシステムのソースを示すために使用されます。ユーザレベルのコピーが新しいデータセットを作成すると考えることができ、このデータを伝播するメカニズムがないと考えることができるので、これは必ずしも可能ではないかもしれないことが理解される。ファイルシステムが最初に作成されると、ファイルシステムが作成されたファイルシステムが作成されたか、作成したファイル、作成されたものなどを作成することが望ましいです。この属性でこの属性で使用できるようにするアプリケーションやシステム管理者に役立ち、元のファイルシステムを使用して後続のコピーを作成するときに使用できるようになります。"
    },
    {
      "indent": 3,
      "text": "The opaque string fss_current should provide whatever information is available about the source of the current copy. Such information includes the tool creating it, any relevant parameters to that tool, the time at which the copy was done, the user making the change, the server on which the change was made, etc. All information should be in a human-readable string.",
      "ja": "不透明文字列FSS_CURRENTは、現在のコピーのソースについて利用できる情報を提供する必要があります。このような情報には、そのツールの作成、そのツールへの関連パラメータ、コピーが完了した時刻、変更を行う時間、変更を行ったサーバーなどが含まれます。すべての情報は人間が読めることができます。ストリング。"
    },
    {
      "indent": 3,
      "text": "The field fss_age provides an indication of how out-of-date the file system currently is with respect to its ultimate data source (in case of cascading data updates). This complements the fls_currency field of fs_locations_server4 (see Section 11.17) in the following way: the information in fls_currency gives a bound for how out of date the data in a file system might typically get, while the value in fss_age gives a bound on how out-of-date that data actually is. Negative values imply that no information is available. A zero means that this data is known to be current. A positive value means that this data is known to be no older than that number of seconds with respect to the ultimate data source. Using this value, the client may be able to decide that a data copy is too old, so that it may search for a newer version to use.",
      "ja": "フィールドFSS_AGEは、現在、ファイルシステムがその最終データソースに関してどのようになっているかを示す（データ更新のカスケードの場合）。これは、FS_LOCATIOS_SERVER4（セクション11.17を参照）のFS_CURRENCYフィールドを補完します（セクション11.17を参照）.FSS_AGEの値がどのようにGETがGETであるか、FSS_AGEの値がどのように拘束されるのか、FSS_AGEの値がどのように到達するかについての情報がバインドされます。 - データが実際にあることの最新情報負の値は、情報が利用できないことを意味します。ゼロは、このデータが電流であることがわかっていることを意味します。正の値は、このデータが究極のデータソースに関して秒数よりも古いことであることが知られていることを意味します。この値を使用して、クライアントはデータコピーが古すぎると判断できるように、使用する新しいバージョンを検索することができます。"
    },
    {
      "indent": 3,
      "text": "The fss_version field provides a version identification, in the form of a time value, such that successive versions always have later time values. When the fs_type is anything other than STATUS4_VERSIONED, the server may provide such a value, but there is no guarantee as to its validity and clients will not use it except to provide additional information to add to fss_source and fss_current.",
      "ja": "FSS_Versionフィールドは、連続したバージョンが常に後の時間値を持つように、時間値の形式でバージョン識別を提供します。fs_typeがstatus4_versioned以外のものである場合、サーバーはそのような値を提供することができますが、その有効性に関する保証はありません。"
    },
    {
      "indent": 3,
      "text": "When fss_type is STATUS4_VERSIONED, servers SHOULD provide a value of fss_version that progresses monotonically whenever any new version of the data is established. This allows the client, if reliable image progression is important to it, to fetch this attribute as part of each COMPOUND where data or metadata from the file system is used.",
      "ja": "fss_typeがstatus4_versionedの場合、サーバーは、新しいバージョンのデータが確立されるたびに単調に進むFSS_Versionの値を指定する必要があります。これにより、信頼性の高いイメージの進行が重要な場合は、ファイルシステムからデータまたはメタデータが使用される各化合物の一部としてこの属性を取得することができます。"
    },
    {
      "indent": 3,
      "text": "When it is important to the client to make sure that only valid successor images are accepted, it must make sure that it does not read data or metadata from the file system without updating its sense of the current state of the image. This is to avoid the possibility that the fs_status that the client holds will be one for an earlier image, which would cause the client to accept a new file system instance that is later than that but still earlier than the updated data read by the client.",
      "ja": "有効な後続画像のみが受け入れられていることを確認することがクライアントにとって重要な場合は、画像の現在の状態のセンスを更新せずにファイルシステムからデータやメタデータを読み取らないようにする必要があります。これは、クライアントが保持しているFS_STATUSが以前の画像に対して1つになる可能性を避けるためです。"
    },
    {
      "indent": 3,
      "text": "In order to accept valid images reliably, the client must do a GETATTR of the fs_status attribute that follows any interrogation of data or metadata within the file system in question. Often this is most conveniently done by appending such a GETATTR after all other operations that reference a given file system. When errors occur between reading file system data and performing such a GETATTR, care must be exercised to make sure that the data in question is not used before obtaining the proper fs_status value. In this connection, when an OPEN is done within such a versioned file system and the associated GETATTR of fs_status is not successfully completed, the open file in question must not be accessed until that fs_status is fetched.",
      "ja": "有効な画像を確実に受け入れるためには、クライアントは、問題のファイルシステム内のデータまたはメタデータの任意の問合せに続くFS_STATUS属性のgetAttrを実行する必要があります。多くの場合、これは、特定のファイルシステムを参照する他のすべての操作の後にそのようなgetattrを追加することによって最も便利です。ファイルシステムデータの読み取りとそのようなGetAttrの実行の間でエラーが発生すると、適切なFS_STATUS値を取得する前に問題のデータが使用されないことを確認するために注意を払う必要があります。これに関連して、そのようなバージョン管理されたファイルシステム内で開くと、FS_Statusの関連GetAttrが正常に完了していない場合、問題のオープンファイルはそのfs_statusがフェッチされるまでアクセスしてはいけません。"
    },
    {
      "indent": 3,
      "text": "The procedure above will ensure that before using any data from the file system the client has in hand a newly-fetched current version of the file system image. Multiple values for multiple requests in flight can be resolved by assembling them into the required partial order (and the elements should form a total order within the partial order) and using the last. The client may then, when switching among file system instances, decline to use an instance that does not have an fss_type of STATUS4_VERSIONED or whose fss_version field is earlier than the last one obtained from the predecessor file system instance.",
      "ja": "上記の手順では、ファイルシステムからデータを使用する前に、クライアントが新しくフェッチされた現在のバージョンのファイルシステムイメージを持っていることを確認します。フライト内の複数の要求に対する複数の値は、それらを必要な部分順序に組み立てることによって解決することができます（そして要素は部分的な順序で合計順序を形成する必要があります）および最後のものを使用します。その場合、クライアントは、ファイルシステムのインスタンスを切り替えるときに、Status4_VersionedのFSS_TYPEを持たない、またはFSS_Versionフィールドが先行ファイルシステムインスタンスから取得された最後のものより前のインスタンスを使用するように拒否することができます。"
    },
    {
      "indent": 0,
      "text": "12. Parallel NFS (pNFS)",
      "section_title": true,
      "ja": "12. 並列NFS（PNFS）"
    },
    {
      "indent": 0,
      "text": "12.1. Introduction",
      "section_title": true,
      "ja": "12.1. はじめに"
    },
    {
      "indent": 3,
      "text": "pNFS is an OPTIONAL feature within NFSv4.1; the pNFS feature set allows direct client access to the storage devices containing file data. When file data for a single NFSv4 server is stored on multiple and/or higher-throughput storage devices (by comparison to the server's throughput capability), the result can be significantly better file access performance. The relationship among multiple clients, a single server, and multiple storage devices for pNFS (server and clients have access to all storage devices) is shown in Figure 1.",
      "ja": "PNFSはNFSV4.1内のオプション機能です。PNFS機能セットは、ファイルデータを含むストレージデバイスへの直接クライアントアクセスを可能にします。単一のNFSv4サーバのファイルデータが複数および/または上位スループットの記憶装置に格納されている場合（サーバのスループット機能と比較して）、結果は大幅に優れたファイルアクセス性能になる可能性があります。複数のクライアント、単一サーバー、およびPNFSの複数のストレージデバイス間の関係（サーバーとクライアントはすべてのストレージデバイスにアクセスできます）を図1に示します。"
    },
    {
      "indent": 7,
      "text": "+-----------+\n|+-----------+                                 +-----------+\n||+-----------+                                |           |\n|||           |        NFSv4.1 + pNFS          |           |\n+||  Clients  |<------------------------------>|   Server  |\n +|           |                                |           |\n  +-----------+                                |           |\n       |||                                     +-----------+\n       |||                                           |\n       |||                                           |\n       ||| Storage        +-----------+              |\n       ||| Protocol       |+-----------+             |\n       ||+----------------||+-----------+  Control   |\n       |+-----------------|||           |    Protocol|\n       +------------------+||  Storage  |------------+\n                           +|  Devices  |\n                            +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "In this model, the clients, server, and storage devices are responsible for managing file access. This is in contrast to NFSv4 without pNFS, where it is primarily the server's responsibility; some of this responsibility may be delegated to the client under strictly specified conditions. See Section 12.2.5 for a discussion of the Storage Protocol. See Section 12.2.6 for a discussion of the Control Protocol.",
      "ja": "このモデルでは、クライアント、サーバー、およびストレージデバイスはファイルアクセスの管理を担当します。これは、PNFSなしのNFSv4とは対照的であり、主にサーバーの責任です。この責任のいくつかは、厳密に指定された条件下でクライアントに委任されるかもしれません。ストレージプロトコルの説明については、セクション12.2.5を参照してください。制御プロトコルの説明については、12.2.6項を参照してください。"
    },
    {
      "indent": 3,
      "text": "pNFS takes the form of OPTIONAL operations that manage protocol objects called 'layouts' (Section 12.2.7) that contain a byte-range and storage location information. The layout is managed in a similar fashion as NFSv4.1 data delegations. For example, the layout is leased, recallable, and revocable. However, layouts are distinct abstractions and are manipulated with new operations. When a client holds a layout, it is granted the ability to directly access the byte-range at the storage location specified in the layout.",
      "ja": "PNFSは、バイト範囲および保管場所情報を含む「レイアウト」（セクション12.2.7）というプロトコルオブジェクトを管理するオプションの操作の形式を取ります。レイアウトは、NFSV4.1データの委任と同様の方法で管理されています。たとえば、レイアウトはリース、リコール、および復活可能です。ただし、レイアウトは明確な抽象化であり、新しい操作で操作されます。クライアントがレイアウトを保持すると、レイアウトで指定された保存場所でバイト範囲に直接アクセスできる機能が付与されます。"
    },
    {
      "indent": 3,
      "text": "There are interactions between layouts and other NFSv4.1 abstractions such as data delegations and byte-range locking. Delegation issues are discussed in Section 12.5.5. Byte-range locking issues are discussed in Sections 12.2.9 and 12.5.1.",
      "ja": "レイアウトと他のNFSV4.1のデータ委員とバイトレンジロックなどの相互作用があります。委任の問題は、12.5.5項で議論されています。バイトレンジロックの問題は、12.2.9および12.5.1のセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "12.2. pNFS Definitions",
      "section_title": true,
      "ja": "12.2. PNFSの定義"
    },
    {
      "indent": 3,
      "text": "NFSv4.1's pNFS feature provides parallel data access to a file system that stripes its content across multiple storage servers. The first instantiation of pNFS, as part of NFSv4.1, separates the file system protocol processing into two parts: metadata processing and data processing. Data consist of the contents of regular files that are striped across storage servers. Data striping occurs in at least two ways: on a file-by-file basis and, within sufficiently large files, on a block-by-block basis. In contrast, striped access to metadata by pNFS clients is not provided in NFSv4.1, even though the file system back end of a pNFS server might stripe metadata. Metadata consist of everything else, including the contents of non-regular files (e.g., directories); see Section 12.2.1. The metadata functionality is implemented by an NFSv4.1 server that supports pNFS and the operations described in Section 18; such a server is called a metadata server (Section 12.2.2).",
      "ja": "NFSV4.1のPNFS機能は、複数のストレージサーバー間でその内容をストライプ化するファイルシステムへの並列データアクセスを提供します。NFSV4.1の一部として、PNFSの最初のインスタンス化は、ファイルシステムプロトコル処理を2つの部分に分離します。メタデータ処理とデータ処理。データは、ストレージサーバー間でストライプされている通常のファイルの内容で構成されています。データストライピングは、少なくとも2つの方法で行われます。ファイルごとに、および十分に大きなファイル内でブロックごとに発生します。対照的に、PNFSサーバーのファイルシステムのバックエンドがメタデータをストライプしても、PNFSクライアントによるメタデータへのストライプアクセスはNFSV4.1では提供されません。メタデータは、通常のファイルの内容（例えば、ディレクトリ）を含む他のすべてのもので構成されています。12.2.1項を参照してください。メタデータ機能は、PNFSをサポートするNFSV4.1サーバーとセクション18で説明されている操作によって実装されています。このようなサーバはメタデータサーバと呼ばれます（セクション12.2.2）。"
    },
    {
      "indent": 3,
      "text": "The data functionality is implemented by one or more storage devices, each of which are accessed by the client via a storage protocol. A subset (defined in Section 13.6) of NFSv4.1 is one such storage protocol. New terms are introduced to the NFSv4.1 nomenclature and existing terms are clarified to allow for the description of the pNFS feature.",
      "ja": "データ機能は、1つ以上の記憶装置によって実装され、その各々はストレージプロトコルを介してクライアントによってアクセスされる。NFSV4.1のサブセット（セクション13.6で定義）はそのようなストレージプロトコルの1つです。NFSV4.1命名法に新しい用語が導入され、既存の用語はPNFS機能の説明を可能にするために明確にされます。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Metadata",
      "section_title": true,
      "ja": "12.2.1. メタデータ"
    },
    {
      "indent": 3,
      "text": "Information about a file system object, such as its name, location within the namespace, owner, ACL, and other attributes. Metadata may also include storage location information, and this will vary based on the underlying storage mechanism that is used.",
      "ja": "名前、名前空間内の場所、所有者、ACL、およびその他の属性などのファイルシステムオブジェクトに関する情報。メタデータはまた、格納位置情報を含み得、これは使用される基礎となる記憶機構に基づいて変わる。"
    },
    {
      "indent": 0,
      "text": "12.2.2. Metadata Server",
      "section_title": true,
      "ja": "12.2.2. メタデータサーバー"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 server that supports the pNFS feature. A variety of architectural choices exist for the metadata server and its use of file system information held at the server. Some servers may contain metadata only for file objects residing at the metadata server, while the file data resides on associated storage devices. Other metadata servers may hold both metadata and a varying degree of file data.",
      "ja": "PNFS機能をサポートするNFSV4.1サーバー。メタデータサーバーにはさまざまなアーキテクチャの選択があり、サーバーで保持されているファイルシステム情報の使用が存在します。一部のサーバーは、メタデータサーバーに存在するファイルオブジェクトに対してのみメタデータを含めることができますが、ファイルデータは関連するストレージデバイス上にあります。他のメタデータサーバは、メタデータとさまざまなファイルデータの両方を保持することができます。"
    },
    {
      "indent": 0,
      "text": "12.2.3. pNFS Client",
      "section_title": true,
      "ja": "12.2.3. PNFSクライアント"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 client that supports pNFS operations and supports at least one storage protocol for performing I/O to storage devices.",
      "ja": "PNFS操作をサポートし、記憶装置に入出力を実行するための少なくとも1つのストレージプロトコルをサポートするNFSV4.1クライアント。"
    },
    {
      "indent": 0,
      "text": "12.2.4. Storage Device",
      "section_title": true,
      "ja": "12.2.4. ストレージデバイス"
    },
    {
      "indent": 3,
      "text": "A storage device stores a regular file's data, but leaves metadata management to the metadata server. A storage device could be another NFSv4.1 server, an object-based storage device (OSD), a block device accessed over a System Area Network (SAN, e.g., either FiberChannel or iSCSI SAN), or some other entity.",
      "ja": "記憶装置は通常のファイルのデータを記憶しているが、メタデータ管理をメタデータサーバに格納する。記憶装置は、システム領域ネットワーク（例えば、ファイバチャネルまたはiSCSI SANのいずれか）または他のエンティティを介してアクセスされるブロックデバイスである、他のNFSV4.1サーバ（OSD）、オブジェクトベースの記憶装置（OSD）であり得る。"
    },
    {
      "indent": 0,
      "text": "12.2.5. Storage Protocol",
      "section_title": true,
      "ja": "12.2.5. ストレージプロトコル"
    },
    {
      "indent": 3,
      "text": "As noted in Figure 1, the storage protocol is the method used by the client to store and retrieve data directly from the storage devices.",
      "ja": "図1に記載されているように、ストレージプロトコルは、ストレージデバイスから直接データを格納および取得するためにクライアントによって使用される方法である。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 pNFS feature has been structured to allow for a variety of storage protocols to be defined and used. One example storage protocol is NFSv4.1 itself (as documented in Section 13). Other options for the storage protocol are described elsewhere and include:",
      "ja": "NFSV4.1 PNFS機能は、さまざまなストレージプロトコルを定義して使用できるように構成されています。1つのストレージプロトコルの1つはNFSV4.1それ自体です（セクション13に記載されているように）。ストレージプロトコルの他のオプションは他の場所で説明されています。"
    },
    {
      "indent": 3,
      "text": "* Block/volume protocols such as Internet SCSI (iSCSI) [56] and FCP [57]. The block/volume protocol support can be independent of the addressing structure of the block/volume protocol used, allowing more than one protocol to access the same file data and enabling extensibility to other block/volume protocols. See [48] for a layout specification that allows pNFS to use block/volume storage protocols.",
      "ja": "* インターネットSCSI（iSCSI）[56]、FCPなどのブロック/ボリュームプロトコル[57]。ブロック/ボリュームプロトコルサポートは、使用されるブロック/ボリュームプロトコルのアドレス指定構造とは無関係であり得、複数のプロトコルが同じファイルデータにアクセスし、他のブロック/ボリュームプロトコルへの拡張性を有効にすることができる。PNFSがブロック/ボリュームストレージプロトコルを使用できるようにするレイアウト仕様については、[48]を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Object protocols such as OSD over iSCSI or Fibre Channel [58]. See [47] for a layout specification that allows pNFS to use object storage protocols.",
      "ja": "* ISCSIまたはファイバチャネルのOSDなどのオブジェクトプロトコル[58]。PNFSがオブジェクトストレージプロトコルを使用できるようにするレイアウト仕様について[47]を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is possible that various storage protocols are available to both client and server and it may be possible that a client and server do not have a matching storage protocol available to them. Because of this, the pNFS server MUST support normal NFSv4.1 access to any file accessible by the pNFS feature; this will allow for continued interoperability between an NFSv4.1 client and server.",
      "ja": "クライアントとサーバーの両方にさまざまなストレージプロトコルが利用可能であり、クライアントとサーバーにそれらが利用可能な一致するストレージプロトコルがない可能性があります。このため、PNFSサーバーはPNFS機能によってアクセス可能なファイルへの通常のNFSV4.1アクセスをサポートしている必要があります。これにより、NFSV4.1クライアントとサーバー間の継続的な相互運用性が可能になります。"
    },
    {
      "indent": 0,
      "text": "12.2.6. Control Protocol",
      "section_title": true,
      "ja": "12.2.6. 制御プロトコル"
    },
    {
      "indent": 3,
      "text": "As noted in Figure 1, the control protocol is used by the exported file system between the metadata server and storage devices. Specification of such protocols is outside the scope of the NFSv4.1 protocol. Such control protocols would be used to control activities such as the allocation and deallocation of storage, the management of state required by the storage devices to perform client access control, and, depending on the storage protocol, the enforcement of authentication and authorization so that restrictions that would be enforced by the metadata server are also enforced by the storage device.",
      "ja": "図1に記載されているように、制御プロトコルは、メタデータサーバーとストレージデバイス間のエクスポートされたファイルシステムによって使用されます。そのようなプロトコルの指定は、NFSV4.1プロトコルの範囲外です。そのような制御プロトコルは、ストレージの割り当ておよび割り当て解除、ストレージデバイスがクライアントアクセス制御を実行するために必要な状態の管理、およびストレージプロトコルによっては、制限が制限されるように認証および許可の執行などの活動を制御するために使用されるであろう。メタデータサーバによっても強制されるであろうと記憶装置によって実施されるであろう。"
    },
    {
      "indent": 3,
      "text": "A particular control protocol is not REQUIRED by NFSv4.1 but requirements are placed on the control protocol for maintaining attributes like modify time, the change attribute, and the end-of-file (EOF) position. Note that if pNFS is layered over a clustered, parallel file system (e.g., PVFS [59]), the mechanisms that enable clustering and parallelism in that file system can be considered the control protocol.",
      "ja": "特定の制御プロトコルはNFSV4.1によって必要とされませんが、変更時刻、変更属性、ファイルの終わりの位置などの属性を維持するための制御プロトコルに必要な要件があります。PNFSがクラスタ化された並列ファイルシステム（例えば、PVFS [59]）の上に階層化されている場合、そのファイルシステム内のクラスタリングと並列処理を可能にするメカニズムは、制御プロトコルと見なすことができることに注意してください。"
    },
    {
      "indent": 0,
      "text": "12.2.7. Layout Types",
      "section_title": true,
      "ja": "12.2.7. レイアウトの種類"
    },
    {
      "indent": 3,
      "text": "A layout describes the mapping of a file's data to the storage devices that hold the data. A layout is said to belong to a specific layout type (data type layouttype4, see Section 3.3.13). The layout type allows for variants to handle different storage protocols, such as those associated with block/volume [48], object [47], and file (Section 13) layout types. A metadata server, along with its control protocol, MUST support at least one layout type. A private sub-range of the layout type namespace is also defined. Values from the private layout type range MAY be used for internal testing or experimentation (see Section 3.3.13).",
      "ja": "レイアウトは、データを保持するストレージデバイスへのファイルのデータのマッピングを説明します。レイアウトが特定のレイアウトタイプに属すると言われています（データ型LayoutType4、セクション3.3.13を参照）。レイアウトタイプは、ブロック/ボリューム[48]、オブジェクト[47]、およびファイル（セクション13）のレイアウトタイプに関連付けられているものなど、さまざまなストレージプロトコルを処理することを可能にします。メタデータサーバーは、その制御プロトコルとともに、少なくとも1つのレイアウトタイプをサポートしている必要があります。レイアウトタイプの名前空間のプライベートサブレンジも定義されています。プライベートレイアウトタイプの範囲からの値は、内部テストや実験に使用できます（セクション3.3.13を参照）。"
    },
    {
      "indent": 3,
      "text": "As an example, the organization of the file layout type could be an array of tuples (e.g., device ID, filehandle), along with a definition of how the data is stored across the devices (e.g., striping). A block/volume layout might be an array of tuples that store <device ID, block number, block count> along with information about block size and the associated file offset of the block number. An object layout might be an array of tuples <device ID, object ID> and an additional structure (i.e., the aggregation map) that defines how the logical byte sequence of the file data is serialized into the different objects. Note that the actual layouts are typically more complex than these simple expository examples.",
      "ja": "一例として、ファイルレイアウトタイプの組織は、データがデバイスを介してどのように格納されているか（例えば、ストライピング）の定義と共に、タプル（例えば、デバイスID、ファイルハンドル）の配列であり得る。ブロック/ボリュームレイアウトは、<デバイスID、ブロック番号、ブロック数>をブロックサイズとブロック番号の関連ファイルオフセットとともに格納するタプルの配列であり得る。オブジェクトレイアウトは、ファイルデータの論理バイトシーケンスが異なるオブジェクトにシリアル化される方法を定義するタプル<デバイスID、オブジェクトID>の配列（すなわち、アグリゲーションマップ）であり得る。実際のレイアウトは通常これらの単純なエキソスサイトの例よりも複雑です。"
    },
    {
      "indent": 3,
      "text": "Requests for pNFS-related operations will often specify a layout type. Examples of such operations are GETDEVICEINFO and LAYOUTGET. The response for these operations will include structures such as a device_addr4 or a layout4, each of which includes a layout type within it. The layout type sent by the server MUST always be the same one requested by the client. When a server sends a response that includes a different layout type, the client SHOULD ignore the response and behave as if the server had returned an error response.",
      "ja": "PNFS関連の操作の要求はしばしばレイアウトタイプを指定します。そのような操作の例は、getDeviceInfoとLayoutgetです。これらの操作に対する応答には、Device_ADDR4またはレイアウト4などの構造が含まれ、それぞれがその中にレイアウトタイプを含む。サーバーによって送信されたレイアウトタイプは、常にクライアントによって要求されたものと同じである必要があります。サーバーが別のレイアウトタイプを含む応答を送信すると、クライアントは応答を無視し、サーバーがエラー応答を返したかのように動作します。"
    },
    {
      "indent": 0,
      "text": "12.2.8. Layout",
      "section_title": true,
      "ja": "12.2.8. レイアウト"
    },
    {
      "indent": 3,
      "text": "A layout defines how a file's data is organized on one or more storage devices. There are many potential layout types; each of the layout types are differentiated by the storage protocol used to access data and by the aggregation scheme that lays out the file data on the underlying storage devices. A layout is precisely identified by the tuple <client ID, filehandle, layout type, iomode, range>, where filehandle refers to the filehandle of the file on the metadata server.",
      "ja": "レイアウトは、ファイルのデータが1つ以上のストレージデバイス上でどのように構成されているかを定義します。多くの潜在的なレイアウトタイプがあります。各レイアウトタイプは、データにアクセスするために使用されるストレージプロトコル、および基礎となる記憶装置上のファイルデータをレイアウトする集約方式によって区別される。レイアウトは、Tuple <クライアントID、FileHandle、Layout Type、IOMode、Range>によって正確に識別されます。ここで、FileHandleはメタデータサーバー上のファイルのファイルハンドルを参照します。"
    },
    {
      "indent": 3,
      "text": "It is important to define when layouts overlap and/or conflict with each other. For two layouts with overlapping byte-ranges to actually overlap each other, both layouts must be of the same layout type, correspond to the same filehandle, and have the same iomode. Layouts conflict when they overlap and differ in the content of the layout (i.e., the storage device/file mapping parameters differ). Note that differing iomodes do not lead to conflicting layouts. It is permissible for layouts with different iomodes, pertaining to the same byte-range, to be held by the same client. An example of this would be copy-on-write functionality for a block/volume layout type.",
      "ja": "レイアウトが重なったとき、および/または互いに競合するときに定義することが重要です。重複するバイト範囲が実際に重なる2つのレイアウトの場合、両方のレイアウトは同じレイアウトタイプでなければなりませんが、同じファイルハンドルに対応し、同じIOMODEを持ちます。レイアウトが重なってレイアウトの内容が異なる場合（すなわち、ストレージデバイス/ファイルマッピングパラメータが異なる）と競合する。異なるiomodeが競合するレイアウトにつながらないことに注意してください。同じクライアントによって保持されるのと同じバイト範囲に関連する異なるIMODEを持つレイアウトが許可されています。この例は、ブロック/ボリュームレイアウトタイプのコピーオンライト機能です。"
    },
    {
      "indent": 0,
      "text": "12.2.9. Layout Iomode",
      "section_title": true,
      "ja": "12.2.9. レイアウトiomode"
    },
    {
      "indent": 3,
      "text": "The layout iomode (data type layoutiomode4, see Section 3.3.20) indicates to the metadata server the client's intent to perform either just READ operations or a mixture containing READ and WRITE operations. For certain layout types, it is useful for a client to specify this intent at the time it sends LAYOUTGET (Section 18.43). For example, for block/volume-based protocols, block allocation could occur when a LAYOUTIOMODE4_RW iomode is specified. A special LAYOUTIOMODE4_ANY iomode is defined and can only be used for LAYOUTRETURN and CB_LAYOUTRECALL, not for LAYOUTGET. It specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively.",
      "ja": "レイアウトIOMode（データ型LAYOUTIOMODE4、セクション3.3.20を参照）は、メタデータサーバに、クライアントが読み取り操作だけまたは読み書き操作を含む混合物のいずれかを実行する意図を示す。特定のレイアウトタイプの場合、クライアントがレイアウトを送信する時点でこの意図を指定するのに役立ちます（セクション18.43）。たとえば、ブロック/ボリュームベースのプロトコルの場合、LAYOUTIOMODE4_RW IOMODEが指定されているときにブロック割り当てが発生する可能性があります。特別なlayoutioMode4_any iOModeが定義され、LayoutGet用ではなく、LayoutReturnおよびCB_LAYOUTRecallにのみ使用できます。LayoutIomode4_ReadとLayoutIomode4_RW iomodeの両方に関連するレイアウトがそれぞれ返されているか呼び出しされていることを指定します。"
    },
    {
      "indent": 3,
      "text": "A storage device may validate I/O with regard to the iomode; this is dependent upon storage device implementation and layout type. Thus, if the client's layout iomode is inconsistent with the I/O being performed, the storage device may reject the client's I/O with an error indicating that a new layout with the correct iomode should be obtained via LAYOUTGET. For example, if a client gets a layout with a LAYOUTIOMODE4_READ iomode and performs a WRITE to a storage device, the storage device is allowed to reject that WRITE.",
      "ja": "記憶装置は、IOMODEに関してI / Oを検証することができる。これはストレージデバイスの実装とレイアウトタイプに依存します。したがって、クライアントのレイアウトIOMODEが実行されているI / Oと矛盾している場合、記憶装置は、正しいIOMODEを有する新しいレイアウトをLayoutget経由で取得する必要があることを示すエラーでクライアントのI / Oを拒否することができる。たとえば、クライアントがLayoutIomode4_Read IOModeを使用してレイアウトを取得してストレージデバイスへの書き込みを実行すると、記憶装置はその書き込みを拒否することが許可される。"
    },
    {
      "indent": 3,
      "text": "The use of the layout iomode does not conflict with OPEN share modes or byte-range LOCK operations; open share mode and byte-range lock conflicts are enforced as they are without the use of pNFS and are logically separate from the pNFS layout level. Open share modes and byte-range locks are the preferred method for restricting user access to data files. For example, an OPEN of OPEN4_SHARE_ACCESS_WRITE does not conflict with a LAYOUTGET containing an iomode of LAYOUTIOMODE4_RW performed by another client. Applications that depend on writing into the same file concurrently may use byte-range locking to serialize their accesses.",
      "ja": "レイアウトIOMODEの使用は、オープンシェアモードまたはバイトレンジロック操作と競合しません。オープンシェアモードとバイトレンジロックの競合は、PNFSを使用せずにそのまま強制され、PNFSレイアウトレベルとは論理的に分離されています。オープンシェアモードとバイトレンジロックは、データファイルへのユーザーアクセスを制限するための推奨方法です。たとえば、Open4_Share_access_Writeの開いても、他のクライアントによって実行されたLayoutIomode4_RWのIOMODEを含むレイアウトゲットと競合しません。同じファイルへの書き込みに依存するアプリケーションは同時にバイトレンジロックを使用してアクセスをシリアル化することができます。"
    },
    {
      "indent": 0,
      "text": "12.2.10. Device IDs",
      "section_title": true,
      "ja": "12.2.10. デバイスIDS"
    },
    {
      "indent": 3,
      "text": "The device ID (data type deviceid4, see Section 3.3.14) identifies a group of storage devices. The scope of a device ID is the pair <client ID, layout type>. In practice, a significant amount of information may be required to fully address a storage device. Rather than embedding all such information in a layout, layouts embed device IDs. The NFSv4.1 operation GETDEVICEINFO (Section 18.40) is used to retrieve the complete address information (including all device addresses for the device ID) regarding the storage device according to its layout type and device ID. For example, the address of an NFSv4.1 data server or of an object-based storage device could be an IP address and port. The address of a block storage device could be a volume label.",
      "ja": "デバイスID（データ型DeviceID4、セクション3.3.14参照）は、ストレージデバイスのグループを識別します。デバイスIDの範囲はペア<クライアントID、レイアウトタイプ>です。実際には、記憶装置を完全にアドレス指定するためにかなりの量の情報が必要とされ得る。すべてのそのような情報をレイアウトに埋め込むのではなく、レイアウトはデバイスIDを埋め込む。NFSV4.1操作GetDeviceInfo（セクション18.40）は、そのレイアウトタイプおよびデバイスIDに従って記憶装置に関する完全なアドレス情報（装置IDのすべての機器アドレスを含む）を検索するために使用される。たとえば、NFSV4.1データサーバーまたはオブジェクトベースのストレージデバイスのアドレスは、IPアドレスとポートである可能性があります。ブロック記憶装置のアドレスはボリュームラベルであり得る。"
    },
    {
      "indent": 3,
      "text": "Clients cannot expect the mapping between a device ID and its storage device address(es) to persist across metadata server restart. See Section 12.7.4 for a description of how recovery works in that situation.",
      "ja": "クライアントは、Metadata Server Restartを介してデバイスIDとそのストレージデバイスのアドレスの間のマッピングを期待できません。その状況で回復がどのように機能するかについては、セクション12.7.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "A device ID lives as long as there is a layout referring to the device ID. If there are no layouts referring to the device ID, the server is free to delete the device ID any time. Once a device ID is deleted by the server, the server MUST NOT reuse the device ID for the same layout type and client ID again. This requirement is feasible because the device ID is 16 bytes long, leaving sufficient room to store a generation number if the server's implementation requires most of the rest of the device ID's content to be reused. This requirement is necessary because otherwise the race conditions between asynchronous notification of device ID addition and deletion would be too difficult to sort out.",
      "ja": "デバイスIDを参照するレイアウトがある限り、デバイスIDが存在します。デバイスIDを参照するレイアウトがない場合、サーバーはいつでもデバイスIDを空いています。デバイスIDがサーバーによって削除されると、サーバーは同じレイアウトタイプとクライアントIDのデバイスIDを再度再使用しないでください。この要件は、デバイスIDが16バイトの長さで、サーバーの実装が残りのデバイスIDのコンテンツのほとんどを再利用する必要がある場合に十分なスペースを保存するのに十分なスペースを残します。この要件は、デバイスIDの追加と削除の非同期通知と削除の間のレース条件が整理するのが難しくなるためです。"
    },
    {
      "indent": 3,
      "text": "Device ID to device address mappings are not leased, and can be changed at any time. (Note that while device ID to device address mappings are likely to change after the metadata server restarts, the server is not required to change the mappings.) A server has two choices for changing mappings. It can recall all layouts referring to the device ID or it can use a notification mechanism.",
      "ja": "デバイスアドレスマッピングへのデバイスIDはリースされておらず、いつでも変更できます。（メタデータサーバの再起動後にデバイスアドレスマッピングへのデバイスIDが変更される可能性があるため、サーバはマッピングを変更する必要はありません。）サーバーにはマッピングを変更するための2つの選択肢があります。デバイスIDを参照してすべてのレイアウトを呼び出すことも、通知メカニズムを使用することもできます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol has no optimal way to recall all layouts that referred to a particular device ID (unless the server associates a single device ID with a single fsid or a single client ID; in which case, CB_LAYOUTRECALL has options for recalling all layouts associated with the fsid, client ID pair, or just the client ID).",
      "ja": "NFSV4.1プロトコルは、特定のデバイスIDを参照しているすべてのレイアウトを呼び出すことが最適な方法はありません（サーバーが単一のデバイスIDを単一のDevice IDまたは単一のクライアントIDと関連付ける場合は、CB_LayOutRecallには、すべてのレイアウトを呼び出すためのオプションがあります。FSID、クライアントIDのペア、またはクライアントIDだけに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Via a notification mechanism (see Section 20.12), device ID to device address mappings can change over the duration of server operation without recalling or revoking the layouts that refer to device ID. The notification mechanism can also delete a device ID, but only if the client has no layouts referring to the device ID. A notification of a change to a device ID to device address mapping will immediately or eventually invalidate some or all of the device ID's mappings. The server MUST support notifications and the client must request them before they can be used. For further information about the notification types, see Section 20.12.",
      "ja": "通知メカニズム（セクション20.12を参照）を介して、デバイスIDを参照するレイアウトを呼び出したり、デバイスIDを呼び出したりすることなく、デバイスIDをデバイスアドレスマッピングの実行期間にわたって変更できます。通知メカニズムはデバイスIDを削除することもできますが、クライアントにデバイスIDを参照しているレイアウトがない場合に限ります。デバイスアドレスマッピングへのデバイスIDへの変更の通知は、すぐにまたは最終的にデバイスIDのマッピングの一部または全部を無効にします。サーバーは通知をサポートし、クライアントは使用する前にそれらを要求する必要があります。通知タイプの詳細については、セクション20.12を参照してください。"
    },
    {
      "indent": 0,
      "text": "12.3. pNFS Operations",
      "section_title": true,
      "ja": "12.3. PNFS操作"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 has several operations that are needed for pNFS servers, regardless of layout type or storage protocol. These operations are all sent to a metadata server and summarized here. While pNFS is an OPTIONAL feature, if pNFS is implemented, some operations are REQUIRED in order to comply with pNFS. See Section 17.",
      "ja": "NFSV4.1には、レイアウト型またはストレージプロトコルに関係なく、PNFSサーバーに必要ないくつかの操作があります。これらの操作はすべてメタデータサーバーに送信され、ここにまとめられています。PNFSはオプション機能ですが、PNFSが実装されている場合は、PNFSに準拠するためにいくつかの操作が必要です。セクション17を参照してください。"
    },
    {
      "indent": 3,
      "text": "These are the fore channel pNFS operations:",
      "ja": "これらはFore Channel PNFS操作です。"
    },
    {
      "indent": 3,
      "text": "GETDEVICEINFO (Section 18.40), as noted previously (Section 12.2.10), returns the mapping of device ID to storage device address.",
      "ja": "getDeviceInfo（18.40節）以前に説明したように（セクション12.2.10）、デバイスIDの記憶装置アドレスへのマッピングを返します。"
    },
    {
      "indent": 3,
      "text": "GETDEVICELIST (Section 18.41) allows clients to fetch all device IDs for a specific file system.",
      "ja": "getDeviceList（セクション18.41）は、クライアントが特定のファイルシステムのすべてのデバイスIDを取得できます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTGET (Section 18.43) is used by a client to get a layout for a file.",
      "ja": "Layoutget（セクション18.43）は、ファイルのレイアウトを取得するためにクライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTCOMMIT (Section 18.42) is used to inform the metadata server of the client's intent to commit data that has been written to the storage device (the storage device as originally indicated in the return value of LAYOUTGET).",
      "ja": "LayoutCommit（セクション18.42）は、ストレージデバイスに書き込まれたデータをコミットするデータをクライアントのインテントに通知するために使用されます（元のレイアウトゲットの戻り値に記載されている記憶装置）。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRETURN (Section 18.44) is used to return layouts for a file, a file system ID (FSID), or a client ID.",
      "ja": "LayoutReturn（第18.44節）は、ファイルのレイアウト、ファイルシステムID（FSID）、またはクライアントIDを返すために使用されます。"
    },
    {
      "indent": 3,
      "text": "These are the backchannel pNFS operations:",
      "ja": "これらはBackChannel PNFS操作です。"
    },
    {
      "indent": 3,
      "text": "CB_LAYOUTRECALL (Section 20.3) recalls a layout, all layouts belonging to a file system, or all layouts belonging to a client ID.",
      "ja": "CB_LAYOUTRECALL（セクション20.3）レイアウト、ファイルシステムに属するすべてのレイアウト、またはクライアントIDに属するすべてのレイアウトを呼び出します。"
    },
    {
      "indent": 3,
      "text": "CB_RECALL_ANY (Section 20.6) tells a client that it needs to return some number of recallable objects, including layouts, to the metadata server.",
      "ja": "CB_RECALL_ANY（セクション20.6）は、レイアウトを含むいくつかのリコール可能なオブジェクトをメタデータサーバーに返す必要があることをクライアントに指示します。"
    },
    {
      "indent": 3,
      "text": "CB_RECALLABLE_OBJ_AVAIL (Section 20.7) tells a client that a recallable object that it was denied (in case of pNFS, a layout denied by LAYOUTGET) due to resource exhaustion is now available.",
      "ja": "CB_RECALLABLE_OBJ_AVAIL（セクション20.7）リソースの枯渇のために、拒否されたリコール可能なオブジェクト（PNFSの場合はレイアウトでレイアウトが拒否された）が利用可能になるようにクライアントに指示します。"
    },
    {
      "indent": 3,
      "text": "CB_NOTIFY_DEVICEID (Section 20.12) notifies the client of changes to device IDs.",
      "ja": "cb_notify_deviceId（セクション20.12）クライアントにデバイスIDを変更します。"
    },
    {
      "indent": 0,
      "text": "12.4. pNFS Attributes",
      "section_title": true,
      "ja": "12.4. PNFS属性"
    },
    {
      "indent": 3,
      "text": "A number of attributes specific to pNFS are listed and described in Section 5.12.",
      "ja": "PNFに固有の多数の属性がリストされ、セクション5.12で説明されています。"
    },
    {
      "indent": 0,
      "text": "12.5. Layout Semantics",
      "section_title": true,
      "ja": "12.5. レイアウトセマンティクス"
    },
    {
      "indent": 0,
      "text": "12.5.1. Guarantees Provided by Layouts",
      "section_title": true,
      "ja": "12.5.1. レイアウトによって提供される保証"
    },
    {
      "indent": 3,
      "text": "Layouts grant to the client the ability to access data located at a storage device with the appropriate storage protocol. The client is guaranteed the layout will be recalled when one of two things occur: either a conflicting layout is requested or the state encapsulated by the layout becomes invalid (this can happen when an event directly or indirectly modifies the layout). When a layout is recalled and returned by the client, the client continues with the ability to access file data with normal NFSv4.1 operations through the metadata server. Only the ability to access the storage devices is affected.",
      "ja": "レイアウト適切なストレージプロトコルを使用してストレージデバイスにあるデータにアクセスできる能力をクライアントに付与します。クライアントは、2つのことが発生したときにレイアウトが呼び出されることが保証されます。レイアウトがクライアントによって呼び出されて返されると、クライアントはメタデータサーバーを介した通常のNFSV4.1操作でファイルデータにアクセスできるようになります。ストレージデバイスにアクセスする機能のみが影響を受けます。"
    },
    {
      "indent": 3,
      "text": "The requirement of NFSv4.1 that all user access rights MUST be obtained through the appropriate OPEN, LOCK, and ACCESS operations is not modified with the existence of layouts. Layouts are provided to NFSv4.1 clients, and user access still follows the rules of the protocol as if they did not exist. It is a requirement that for a client to access a storage device, a layout must be held by the client. If a storage device receives an I/O request for a byte-range for which the client does not hold a layout, the storage device SHOULD reject that I/O request. Note that the act of modifying a file for which a layout is held does not necessarily conflict with the holding of the layout that describes the file being modified. Therefore, it is the requirement of the storage protocol or layout type that determines the necessary behavior. For example, block/ volume layout types require that the layout's iomode agree with the type of I/O being performed.",
      "ja": "NFSV4.1の要件は、適切なオープン、ロック、およびアクセス操作を通じて取得されなければならないことが、レイアウトの存在で変更されません。レイアウトはNFSV4.1クライアントに提供され、ユーザーアクセスはまだ存在しないかのようにプロトコルのルールに従います。クライアントがストレージデバイスにアクセスするためには、レイアウトをクライアントによって保持する必要があるという要件です。クライアントがレイアウトを保持していないバイト範囲に対してI / O要求を受信した場合、ストレージデバイスはそのI / O要求を拒否する必要があります。レイアウトが保持されているファイルを修正する行為は、変更されているファイルを記述するレイアウトの保持と必ずしも競合するわけではありません。したがって、必要な動作を決定するストレージプロトコルまたはレイアウトタイプの要件です。たとえば、ブロック/ボリュームレイアウトタイプは、レイアウトのIOMODEが実行されているI / Oの種類と一致することを要求します。"
    },
    {
      "indent": 3,
      "text": "Depending upon the layout type and storage protocol in use, storage device access permissions may be granted by LAYOUTGET and may be encoded within the type-specific layout. For an example of storage device access permissions, see an object-based protocol such as [58]. If access permissions are encoded within the layout, the metadata server SHOULD recall the layout when those permissions become invalid for any reason -- for example, when a file becomes unwritable or inaccessible to a client. Note, clients are still required to perform the appropriate OPEN, LOCK, and ACCESS operations as described above. The degree to which it is possible for the client to circumvent these operations and the consequences of doing so must be clearly specified by the individual layout type specifications. In addition, these specifications must be clear about the requirements and non-requirements for the checking performed by the server.",
      "ja": "使用中のレイアウトタイプとストレージプロトコルに応じて、ストレージデバイスアクセス許可はLayoutGetによって許可されてもよく、タイプ固有のレイアウト内でエンコードされてもよい。ストレージデバイスアクセス権の例については、[58]などのオブジェクトベースのプロトコルを参照してください。アクセス権限がレイアウト内でエンコードされている場合、メタデータサーバーは、それらの権限が何らかの理由で無効になったときにレイアウトを呼び出す必要があります。たとえば、ファイルが解読不可になったり、クライアントにアクセスできなくなったりします。注意して、クライアントは、上記のように適切なオープン、ロック、およびアクセス動作を実行するために依然として必要です。クライアントがこれらの操作を回避することが可能な程度、およびその結果を実行する結果は、個々のレイアウト型の仕様によって明確に指定されなければなりません。さらに、これらの仕様は、サーバーによって実行されるチェックの要件と要件について明確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the presence of pNFS functionality, mandatory byte-range locks MUST behave as they would without pNFS. Therefore, if mandatory file locks and layouts are provided simultaneously, the storage device MUST be able to enforce the mandatory byte-range locks. For example, if one client obtains a mandatory byte-range lock and a second client accesses the storage device, the storage device MUST appropriately restrict I/O for the range of the mandatory byte-range lock. If the storage device is incapable of providing this check in the presence of mandatory byte-range locks, then the metadata server MUST NOT grant layouts and mandatory byte-range locks simultaneously.",
      "ja": "PNFS機能の存在下では、必須のバイトレンジロックはPNFSなしで動作するように動作しなければなりません。したがって、必須のファイルロックとレイアウトが同時に提供されている場合、ストレージデバイスは必須のバイトレンジロックを強制することができなければなりません。たとえば、1つのクライアントが必須のバイトレンジロックを取得し、2番目のクライアントがストレージデバイスにアクセスすると、ストレージデバイスは必須バイトレンジロックの範囲に対してI / Oを適切に制限する必要があります。必須バイトレンジロックの存在下でこのチェックを提供することができない場合、メタデータサーバはレイアウトと必須のバイトレンジロックを同時に付与してはいけません。"
    },
    {
      "indent": 0,
      "text": "12.5.2. Getting a Layout",
      "section_title": true,
      "ja": "12.5.2. レイアウトを取得する"
    },
    {
      "indent": 3,
      "text": "A client obtains a layout with the LAYOUTGET operation. The metadata server will grant layouts of a particular type (e.g., block/volume, object, or file). The client selects an appropriate layout type that the server supports and the client is prepared to use. The layout returned to the client might not exactly match the requested byte-range as described in Section 18.43.3. As needed a client may send multiple LAYOUTGET operations; these might result in multiple overlapping, non-conflicting layouts (see Section 12.2.8).",
      "ja": "クライアントはレイアウト操作でレイアウトを取得します。メタデータサーバは、特定の種類のレイアウト（例えば、ブロック/ボリューム、オブジェクト、またはファイル）のレイアウトを付与します。クライアントは、サーバーがサポートしている適切なレイアウトタイプを選択し、クライアントは使用する準備ができています。クライアントに返されるレイアウトは、18.43.3項で説明されているように、要求されたバイト範囲と正確に一致しない場合があります。必要に応じて、クライアントは複数のレイアウト操作を送信することができます。これらは複数重複していないレイアウト（セクション12.2.8を参照）になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In order to get a layout, the client must first have opened the file via the OPEN operation. When a client has no layout on a file, it MUST present an open stateid, a delegation stateid, or a byte-range lock stateid in the loga_stateid argument. A successful LAYOUTGET result includes a layout stateid. The first successful LAYOUTGET processed by the server using a non-layout stateid as an argument MUST have the \"seqid\" field of the layout stateid in the response set to one. Thereafter, the client MUST use a layout stateid (see Section 12.5.3) on future invocations of LAYOUTGET on the file, and the \"seqid\" MUST NOT be set to zero. Once the layout has been retrieved, it can be held across multiple OPEN and CLOSE sequences. Therefore, a client may hold a layout for a file that is not currently open by any user on the client. This allows for the caching of layouts beyond CLOSE.",
      "ja": "レイアウトを取得するためには、クライアントは最初にオープン操作を介してファイルを開く必要があります。クライアントにファイルにレイアウトがない場合は、Open StateID、委任ステートID、またはloga_stateid引数にあるバイトレンジロックステートIDを紹介する必要があります。LayoutGetの結果が成功すると、レイアウトStateIDが含まれています。引数としてレイアウト以外のStateIDを使用してサーバーによって処理された最初の成功したレイアウトゲットは、レスポンスに設定されているレイアウトStateIDの「seqid」フィールドを持つ必要があります。その後、クライアントはファイル上のレイアウトの将来の呼び出しについてレイアウトStateID（セクション12.5.3を参照）を使用しなければならず、「seqid」をゼロに設定してはいけません。レイアウトが取り出されると、複数の開いたシーケンスと閉じたシーケンスにわたって保持できます。したがって、クライアントは、クライアント上のどのユーザーによっても開かれていないファイルのレイアウトを保持することがあります。これにより、レイアウトのキャッシングが閉じることができます。"
    },
    {
      "indent": 3,
      "text": "The storage protocol used by the client to access the data on the storage device is determined by the layout's type. The client is responsible for matching the layout type with an available method to interpret and use the layout. The method for this layout type selection is outside the scope of the pNFS functionality.",
      "ja": "記憶装置上のデータにアクセスするためにクライアントが使用するストレージプロトコルは、レイアウトの種類によって決定される。クライアントは、レイアウトタイプを利用可能なメソッドと一致させてレイアウトを解釈して使用する責任があります。このレイアウトタイプの選択方法は、PNFS機能の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Although the metadata server is in control of the layout for a file, the pNFS client can provide hints to the server when a file is opened or created about the preferred layout type and aggregation schemes. pNFS introduces a layout_hint attribute (Section 5.12.4) that the client can set at file creation time to provide a hint to the server for new files. Setting this attribute separately, after the file has been created might make it difficult, or impossible, for the server implementation to comply.",
      "ja": "メタデータサーバーはファイルのレイアウトを制御していますが、PNFSクライアントはファイルが開いているときに、優先レイアウトタイプと集計方式について作成または作成されたときにサーバーにヒントを提供できます。PNFSは、新しいファイルのサーバーにヒントを提供するために、クライアントがファイル作成時に設定できるようにすることができるLayout_hint属性（セクション5.12.4）を導入します。この属性を別々に設定すると、ファイルが作成された後に、サーバーの実装が準拠しているか、または不可能になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Because the EXCLUSIVE4 createmode4 does not allow the setting of attributes at file creation time, NFSv4.1 introduces the EXCLUSIVE4_1 createmode4, which does allow attributes to be set at file creation time. In addition, if the session is created with persistent reply caches, EXCLUSIVE4_1 is neither necessary nor allowed. Instead, GUARDED4 both works better and is prescribed. Table 18 in Section 18.16.3 summarizes how a client is allowed to send an exclusive create.",
      "ja": "exclusive4 createMode4はファイル作成時に属性の設定を許可しないため、NFSV4.1はexclusive4_1 createMode4を紹介します。これは、属性をファイル作成時に設定できるようにします。さらに、セッションが永続的な返信キャッシュで作成された場合、exclusive4_1は必要でも許可されていません。代わりに、Guarded4はどちらも良く機能し、規定されています。18.16.3項の表18は、クライアントが排他的作成を送信することが許可されている方法をまとめたものです。"
    },
    {
      "indent": 0,
      "text": "12.5.3. Layout Stateid",
      "section_title": true,
      "ja": "12.5.3. レイアウト州"
    },
    {
      "indent": 3,
      "text": "As with all other stateids, the layout stateid consists of a \"seqid\" and \"other\" field. Once a layout stateid is established, the \"other\" field will stay constant unless the stateid is revoked or the client returns all layouts on the file and the server disposes of the stateid. The \"seqid\" field is initially set to one, and is never zero on any NFSv4.1 operation that uses layout stateids, whether it is a fore channel or backchannel operation. After the layout stateid is established, the server increments by one the value of the \"seqid\" in each subsequent LAYOUTGET and LAYOUTRETURN response, and in each CB_LAYOUTRECALL request.",
      "ja": "他のすべてのStateIDと同様に、レイアウトStateIDは「seqid」と「その他」フィールドで構成されています。レイアウトStateIDが確立されると、stateIDが取り消されていない限り、「その他」フィールドは定数に保たれ、クライアントはファイル上のすべてのレイアウトを返し、サーバーがStateIDのディスプレイを返します。「seqid」フィールドは最初は1に設定されており、レイアウトステーションを使用する任意のNFSv4.1操作ではゼロではありません。レイアウトStateIDが確立された後、サーバは、それ以降の各レイアウトゲットおよびLayoutReturn応答および各CB_LAYOUTRecall要求で、「seqid」の値を1つずつ増加させる。"
    },
    {
      "indent": 3,
      "text": "Given the design goal of pNFS to provide parallelism, the layout stateid differs from other stateid types in that the client is expected to send LAYOUTGET and LAYOUTRETURN operations in parallel. The \"seqid\" value is used by the client to properly sort responses to LAYOUTGET and LAYOUTRETURN. The \"seqid\" is also used to prevent race conditions between LAYOUTGET and CB_LAYOUTRECALL. Given that the processing rules differ from layout stateids and other stateid types, only the pNFS sections of this document should be considered to determine proper layout stateid handling.",
      "ja": "並列処理を提供するためのPNFの設計目標を考えると、レイアウトStateIDは他のStareID型とは異なり、クライアントはレイアウトゲットとLayoutReturnの動作を並行して送信することが予想されます。\"seqid\"値は、LayoutgetとLayOutReturnに応答を正しくソートするためにクライアントによって使用されます。「seqid」は、LayoutGetとCB_LayoutRecallの間の競合条件を防ぐためにも使用されます。処理規則がレイアウトステーションと他のStateID型と異なることを考えると、この文書のPNFSセクションのみが適切なレイアウトSTATEID処理を決定すると見なされるべきです。"
    },
    {
      "indent": 3,
      "text": "Once the client receives a layout stateid, it MUST use the correct \"seqid\" for subsequent LAYOUTGET or LAYOUTRETURN operations. The correct \"seqid\" is defined as the highest \"seqid\" value from responses of fully processed LAYOUTGET or LAYOUTRETURN operations or arguments of a fully processed CB_LAYOUTRECALL operation. Since the server is incrementing the \"seqid\" value on each layout operation, the client may determine the order of operation processing by inspecting the \"seqid\" value. In the case of overlapping layout ranges, the ordering information will provide the client the knowledge of which layout ranges are held. Note that overlapping layout ranges may occur because of the client's specific requests or because the server is allowed to expand the range of a requested layout and notify the client in the LAYOUTRETURN results. Additional layout stateid sequencing requirements are provided in Section 12.5.5.2.",
      "ja": "クライアントがレイアウトStateIDを受信すると、その後のLayoutgetまたはLayoutReturn操作に正しい「seqid」を使用する必要があります。正しい「seqid」は、完全に処理されたLayoutGetまたはLayoutReturn操作または完全に処理されたCB_LAYOUTRecall操作の引数の応答からの最高の \"seqid\"値として定義されています。サーバは各レイアウト操作で「SEQID」値をインクリメントしているので、クライアントは「SEQID」値を検査することによって動作処理の順序を決定することができる。重なり合うレイアウト範囲が重なっている場合、注文情報はクライアントにどのレイアウト範囲が保持されているかに関する知識を提供します。クライアントの特定の要求のため、またはサーバーに要求されたレイアウトの範囲を拡張し、クライアントにレイアウトリュータウの結果を通知することが許可されているため、重複するレイアウト範囲が発生することがあります。追加のレイアウトStateIDシーケンスの要件は、12.5.2項で提供されています。"
    },
    {
      "indent": 3,
      "text": "The client's receipt of a \"seqid\" is not sufficient for subsequent use. The client must fully process the operations before the \"seqid\" can be used. For LAYOUTGET results, if the client is not using the forgetful model (Section 12.5.5.1), it MUST first update its record of what ranges of the file's layout it has before using the seqid. For LAYOUTRETURN results, the client MUST delete the range from its record of what ranges of the file's layout it had before using the seqid. For CB_LAYOUTRECALL arguments, the client MUST send a response to the recall before using the seqid. The fundamental requirement in client processing is that the \"seqid\" is used to provide the order of processing. LAYOUTGET results may be processed in parallel. LAYOUTRETURN results may be processed in parallel. LAYOUTGET and LAYOUTRETURN responses may be processed in parallel as long as the ranges do not overlap. CB_LAYOUTRECALL request processing MUST be processed in \"seqid\" order at all times.",
      "ja": "「SEQID」のクライアントの受信は、その後の使用には十分ではありません。クライアントは、「seqid」を使用する前に操作を完全に処理する必要があります。Layoutgetの結果の場合、クライアントが忘却モデルを使用していない場合（セクション12.5.5.1）、SEQIDを使用する前に、最初にファイルのレイアウトの範囲のレコードを更新する必要があります。LayoutReturnの結果、クライアントは、SEQIDを使用する前に、ファイルのレイアウトの範囲のレコードからその範囲を削除する必要があります。CB_LAYOUTRECALL引数の場合、SEQIDを使用する前に、クライアントはリコールに応答を送信する必要があります。クライアント処理における基本的な要件は、「SEQID」が処理順序を提供するために使用されることである。Layoutgetの結果は並行して処理できます。LayoutReturnの結果は並行して処理できます。レイアウトおよびレイアウトリターン応答は、範囲が重ならない限り並行して処理されます。CB_LAYOUTRECALL要求処理は、常に「seqid」順序で処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a client has no more layouts on a file, the layout stateid is no longer valid and MUST NOT be used. Any attempt to use such a layout stateid will result in NFS4ERR_BAD_STATEID.",
      "ja": "クライアントがファイルにそれ以上レイアウトがなくなると、レイアウトStateIDは無効で、使用しないでください。このようなレイアウトStateIDを使用しようとすると、NFS4ERR_BAD_STATEIDが発生します。"
    },
    {
      "indent": 0,
      "text": "12.5.4. Committing a Layout",
      "section_title": true,
      "ja": "12.5.4. レイアウトをコミットする"
    },
    {
      "indent": 3,
      "text": "Allowing for varying storage protocol capabilities, the pNFS protocol does not require the metadata server and storage devices to have a consistent view of file attributes and data location mappings. Data location mapping refers to aspects such as which offsets store data as opposed to storing holes (see Section 13.4.4 for a discussion). Related issues arise for storage protocols where a layout may hold provisionally allocated blocks where the allocation of those blocks does not survive a complete restart of both the client and server. Because of this inconsistency, it is necessary to resynchronize the client with the metadata server and its storage devices and make any potential changes available to other clients. This is accomplished by use of the LAYOUTCOMMIT operation.",
      "ja": "さまざまなストレージプロトコル機能を変えることを可能にするPNFSプロトコルは、メタデータサーバーおよびストレージデバイスがファイル属性とデータの場所マッピングの一貫したビューを持つ必要はありません。データ位置マッピングは、どのオフセットのような局面を記憶するのか、そのような側面を記憶する（議論のためにセクション13.4.4を参照）。関連する問題は、レイアウトが、それらのブロックの割り当てがクライアントとサーバの両方の完全な再起動を生き残らない仮割り当てブロックを保持することができるストレージプロトコルに対して発生する。この矛盾のために、クライアントをメタデータサーバとその記憶装置に再同期させ、他のクライアントに潜在的な変更を可能にする必要があります。これはLayoutCommit操作を使用することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation is responsible for committing a modified layout to the metadata server. The data should be written and committed to the appropriate storage devices before the LAYOUTCOMMIT occurs. The scope of the LAYOUTCOMMIT operation depends on the storage protocol in use. It is important to note that the level of synchronization is from the point of view of the client that sent the LAYOUTCOMMIT. The updated state on the metadata server need only reflect the state as of the client's last operation previous to the LAYOUTCOMMIT. The metadata server is not REQUIRED to maintain a global view that accounts for other clients' I/O that may have occurred within the same time frame.",
      "ja": "LayoutCommit操作は、変更されたレイアウトをメタデータサーバーにコミットする責任があります。データは、LayoutCommitが発生する前に、適切な記憶装置に書き込まれ、コミットされるべきです。LayoutCommit操作の範囲は、使用中のストレージプロトコルによって異なります。同期のレベルは、LayoutCommitを送信したクライアントの観点からのものであることに注意することが重要です。メタデータサーバ上の更新された状態は、LayoutCommitの前のクライアントの最後の操作の時点を反映するだけでよい。メタデータサーバーは、同じ時間枠内で発生した可能性がある他のクライアントのI / Oを説明するグローバルビューを維持する必要はありません。"
    },
    {
      "indent": 3,
      "text": "For block/volume-based layouts, LAYOUTCOMMIT may require updating the block list that comprises the file and committing this layout to stable storage. For file-based layouts, synchronization of attributes between the metadata and storage devices, primarily the size attribute, is required.",
      "ja": "ブロック/ボリュームベースのレイアウトの場合、LayoutCommitはファイルを含むブロックリストを更新し、このレイアウトを安定したストレージにコミットする必要があります。ファイルベースのレイアウトの場合、メタデータとストレージデバイス間の属性の同期、主にSIZE属性が必要です。"
    },
    {
      "indent": 3,
      "text": "The control protocol is free to synchronize the attributes before it receives a LAYOUTCOMMIT; however, upon successful completion of a LAYOUTCOMMIT, state that exists on the metadata server that describes the file MUST be synchronized with the state that exists on the storage devices that comprise that file as of the client's last sent operation. Thus, a client that queries the size of a file between a WRITE to a storage device and the LAYOUTCOMMIT might observe a size that does not reflect the actual data written.",
      "ja": "制御プロトコルは、レイアウトコミットを受信する前に属性を自由に同期させることができます。ただし、LayoutCommitが正常に完了すると、ファイルを記述するメタデータサーバーに存在する状態は、クライアントの最後の送信操作のようにそのファイルを構成するストレージデバイスに存在する状態と同期している必要があります。したがって、ストレージデバイスへの書き込みとレイアウトコミットとの間にファイルのサイズを問い合わせるクライアントは、書き込まれた実際のデータを反映しないサイズを観察することがあります。"
    },
    {
      "indent": 3,
      "text": "The client MUST have a layout in order to send a LAYOUTCOMMIT operation.",
      "ja": "LayoutCommit操作を送信するには、クライアントにレイアウトが必要です。"
    },
    {
      "indent": 0,
      "text": "12.5.4.1. LAYOUTCOMMIT and change/time_modify",
      "section_title": true,
      "ja": "12.5.4.1. LayoutCommitとChange / Time_Modify"
    },
    {
      "indent": 3,
      "text": "The change and time_modify attributes may be updated by the server when the LAYOUTCOMMIT operation is processed. The reason for this is that some layout types do not support the update of these attributes when the storage devices process I/O operations. If a client has a layout with the LAYOUTIOMODE4_RW iomode on the file, the client MAY provide a suggested value to the server for time_modify within the arguments to LAYOUTCOMMIT. Based on the layout type, the provided value may or may not be used. The server should sanity-check the client-provided values before they are used. For example, the server should ensure that time does not flow backwards. The client always has the option to set time_modify through an explicit SETATTR operation.",
      "ja": "変更とTIME_MODIFY属性は、LayoutCommit操作が処理されたときにサーバーによって更新される可能性があります。この理由は、ストレージデバイスがI / O操作を処理したときに、一部のレイアウト型がこれらの属性の更新をサポートしていないためです。クライアントがファイル上のLayOutioMode4_RW iOModeを持つレイアウトを持つ場合、クライアントはLayoutCommitの引数内でtime_modify for time_modify for serverに推奨される値を提供することができます。レイアウトタイプに基づいて、提供された値が使用されていてもいなくてもよい。サーバーは、使用される前に、クライアント提供の値を確認する必要があります。たとえば、サーバーは時間が後退しないようにする必要があります。クライアントは常に明示的なsetAttr操作を通してtime_modifyを設定することができます。"
    },
    {
      "indent": 3,
      "text": "For some layout protocols, the storage device is able to notify the metadata server of the occurrence of an I/O; as a result, the change and time_modify attributes may be updated at the metadata server. For a metadata server that is capable of monitoring updates to the change and time_modify attributes, LAYOUTCOMMIT processing is not required to update the change attribute. In this case, the metadata server must ensure that no further update to the data has occurred since the last update of the attributes; file-based protocols may have enough information to make this determination or may update the change attribute upon each file modification. This also applies for the time_modify attribute. If the server implementation is able to determine that the file has not been modified since the last time_modify update, the server need not update time_modify at LAYOUTCOMMIT. At LAYOUTCOMMIT completion, the updated attributes should be visible if that file was modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.",
      "ja": "いくつかのレイアウトプロトコルでは、ストレージデバイスは、I / Oの発生のメタデータサーバに通知することができる。その結果、変更属性とtime_modify属性はメタデータサーバで更新されてもよい。変更属性とtime_modify属性への更新を監視することができるメタデータサーバーの場合は、変更属性を更新するためにLayoutCommit処理は必要ありません。この場合、メタデータサーバは、属性の最後の更新以降にデータをさらに更新しなかったことを確認する必要があります。ファイルベースのプロトコルには、この決定を行うのに十分な情報があり、または各ファイルの変更時に変更属性を更新することができます。これはtime_modify属性にも適用されます。サーバー実装が、最後のTIME_MODIFY更新以降にファイルが変更されていないと判断できる場合、サーバーはLayoutCommitでtime_modifyを更新する必要はありません。 LayoutCommitの完了時に、最新の前のLayoutCommitまたはLayoutget以降にそのファイルが変更された場合、更新された属性は表示されます。"
    },
    {
      "indent": 0,
      "text": "12.5.4.2. LAYOUTCOMMIT and size",
      "section_title": true,
      "ja": "12.5.4.2. レイアウトコミットとサイズ"
    },
    {
      "indent": 3,
      "text": "The size of a file may be updated when the LAYOUTCOMMIT operation is used by the client. One of the fields in the argument to LAYOUTCOMMIT is loca_last_write_offset; this field indicates the highest byte offset written but not yet committed with the LAYOUTCOMMIT operation. The data type of loca_last_write_offset is newoffset4 and is switched on a boolean value, no_newoffset, that indicates if a previous write occurred or not. If no_newoffset is FALSE, an offset is not given. If the client has a layout with LAYOUTIOMODE4_RW iomode on the file, with a byte-range (denoted by the values of lo_offset and lo_length) that overlaps loca_last_write_offset, then the client MAY set no_newoffset to TRUE and provide an offset that will update the file size. Keep in mind that offset is not the same as length, though they are related. For example, a loca_last_write_offset value of zero means that one byte was written at offset zero, and so the length of the file is at least one byte.",
      "ja": "レイアウトコミット操作がクライアントによって使用されたときにファイルのサイズを更新することができます。LayoutCommitの引数内のフィールドの1つはloca_last_write_offsetです。このフィールドは、書き込まれた最高のバイトオフセットを示しますが、LayoutCommit操作ではまだコミットされていません。LOCA_LAST_WRITE_OFFSETのデータ型はNewOffSet4で、前の書き込みが発生したかどうかを示すブール値No_newOffsetに切り替わります。no_newoffsetがfalseの場合、オフセットは与えられません。クライアントがファイル上のLayoutIomode4_RW iomodeを持つレイアウトを持つ場合、loca_last_write_offsetを重複するbyte-range（lo_offsetとlo_lengthはlo_offsetとlo_lengthで表されます）で、クライアントはno_newoffsetをtrueに設定し、ファイルサイズを更新するオフセットを提供することができます。。オフセットは長さと同じではないことに注意してください。たとえば、loca_last_write_offset値ゼロの場合は、1バイトがオフセットゼロで書き込まれたため、ファイルの長さは少なくとも1バイトです。"
    },
    {
      "indent": 3,
      "text": "The metadata server may do one of the following:",
      "ja": "メタデータサーバーは次のいずれかを実行できます。"
    },
    {
      "indent": 3,
      "text": "1. Update the file's size using the last write offset provided by the client as either the true file size or as a hint of the file size. If the metadata server has a method available, any new value for file size should be sanity-checked. For example, the file must not be truncated if the client presents a last write offset less than the file's current size.",
      "ja": "1. クライアントから提供された最後の書き込みオフセットをTrueのファイルサイズまたはファイルサイズのヒントとして使用してファイルのサイズを更新します。メタデータサーバーに使用可能なメソッドがある場合、ファイルサイズの新しい値は正常にチェックされるべきです。たとえば、クライアントがファイルの現在のサイズよりも少ない最後の書き込みオフセットを表示している場合は、ファイルを切り捨てないでください。"
    },
    {
      "indent": 3,
      "text": "2. Ignore the client-provided last write offset; the metadata server must have sufficient knowledge from other sources to determine the file's size. For example, the metadata server queries the storage devices with the control protocol.",
      "ja": "2. クライアント提供の最後の書き込みオフセットを無視します。メタデータサーバーは、ファイルのサイズを決定するために他の情報源からの十分な知識を持っている必要があります。たとえば、メタデータサーバーは、Storageデバイスに制御プロトコルを照会します。"
    },
    {
      "indent": 3,
      "text": "The method chosen to update the file's size will depend on the storage device's and/or the control protocol's capabilities. For example, if the storage devices are block devices with no knowledge of file size, the metadata server must rely on the client to set the last write offset appropriately.",
      "ja": "ファイルのサイズを更新するために選択された方法は、ストレージデバイスの機能および/またはコントロールプロトコルの機能によって異なります。たとえば、ストレージデバイスがファイルサイズに関する知識がないブロックデバイスである場合、メタデータサーバーは最後の書き込みオフセットを適切に設定するためにクライアントに依存している必要があります。"
    },
    {
      "indent": 3,
      "text": "The results of LAYOUTCOMMIT contain a new size value in the form of a newsize4 union data type. If the file's size is set as a result of LAYOUTCOMMIT, the metadata server must reply with the new size; otherwise, the new size is not provided. If the file size is updated, the metadata server SHOULD update the storage devices such that the new file size is reflected when LAYOUTCOMMIT processing is complete. For example, the client should be able to read up to the new file size.",
      "ja": "LayoutCommitの結果には、NewSize4 Unionデータ型の形式の新しいサイズ値が含まれています。LayoutCommitの結果としてファイルのサイズが設定されている場合、メタデータサーバーは新しいサイズで返信する必要があります。それ以外の場合は、新しいサイズは提供されません。ファイルサイズが更新された場合、メタデータサーバは、LayoutCommit処理が完了したときに新しいファイルサイズが反映されるように記憶装置を更新する必要があります。たとえば、クライアントは新しいファイルサイズに読み取ることができるはずです。"
    },
    {
      "indent": 3,
      "text": "The client can extend the length of a file or truncate a file by sending a SETATTR operation to the metadata server with the size attribute specified. If the size specified is larger than the current size of the file, the file is \"zero extended\", i.e., zeros are implicitly added between the file's previous EOF and the new EOF. (In many implementations, the zero-extended byte-range of the file consists of unallocated holes in the file.) When the client writes past EOF via WRITE, the SETATTR operation does not need to be used.",
      "ja": "クライアントはファイルの長さを拡張することも、SIZE属性を指定してMetadata ServerにsetAttrオペレーションを送信することでファイルを切り捨てることができます。指定されたサイズがファイルの現在のサイズより大きい場合、ファイルは「ゼロ拡張」、すなわちゼロがファイルの前のEOFと新しいEOFとの間に暗黙的に追加されます。（多くの実装では、ファイルのゼロ拡張バイト範囲はファイル内の未割り当て穴で構成されています。）クライアントがWRITE経由でEOFを書き込むと、SETATTRの動作を使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "12.5.4.3. LAYOUTCOMMIT and layoutupdate",
      "section_title": true,
      "ja": "12.5.4.3. LayoutCommitとLayoutUpdate"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT argument contains a loca_layoutupdate field (Section 18.42.1) of data type layoutupdate4 (Section 3.3.18). This argument is a layout-type-specific structure. The structure can be used to pass arbitrary layout-type-specific information from the client to the metadata server at LAYOUTCOMMIT time. For example, if using a block/volume layout, the client can indicate to the metadata server which reserved or allocated blocks the client used or did not use. The content of loca_layoutupdate (field lou_body) need not be the same layout-type-specific content returned by LAYOUTGET (Section 18.43.2) in the loc_body field of the lo_content field of the logr_layout field. The content of loca_layoutupdate is defined by the layout type specification and is opaque to LAYOUTCOMMIT.",
      "ja": "LayoutCommit引数には、データ型LayoutUpdate4（セクション3.3.18）のloca_layoutupdateフィールド（セクション18.42.1）が含まれています。この引数はレイアウト型固有の構造です。この構造は、レイアウトコミット時にクライアントからメタデータサーバーに任意のレイアウト型固有の情報を渡すために使用できます。たとえば、ブロック/ボリュームレイアウトを使用している場合、クライアントは予約または割り当てられたメタデータサーバーに、使用されているか使用しなかったメタデータサーバーに指定できます。loca_layoutupdate（フィールドlou_body）の内容は、LOGR_LAYOUTフィールドのLO_CONTENTフィールドのloc_bodyフィールドにあるLayoutget（セクション18.43.2）によって返される同じレイアウト型固有のコンテンツである必要はありません。LOCA_LAYOUTUPDATEの内容は、レイアウト型の指定によって定義され、LayoutCommitには不透明です。"
    },
    {
      "indent": 0,
      "text": "12.5.5. Recalling a Layout",
      "section_title": true,
      "ja": "12.5.5. レイアウトを思い出す"
    },
    {
      "indent": 3,
      "text": "Since a layout protects a client's access to a file via a direct client-storage-device path, a layout need only be recalled when it is semantically unable to serve this function. Typically, this occurs when the layout no longer encapsulates the true location of the file over the byte-range it represents. Any operation or action, such as server-driven restriping or load balancing, that changes the layout will result in a recall of the layout. A layout is recalled by the CB_LAYOUTRECALL callback operation (see Section 20.3) and returned with LAYOUTRETURN (see Section 18.44). The CB_LAYOUTRECALL operation may recall a layout identified by a byte-range, all layouts associated with a file system ID (FSID), or all layouts associated with a client ID. Section 12.5.5.2 discusses sequencing issues surrounding the getting, returning, and recalling of layouts.",
      "ja": "レイアウトは直接クライアント記憶装置のパスを介してクライアントのファイルへのアクセスを保護するので、この機能を意味することができない場合にはレイアウトを呼び出す必要があります。通常、これはレイアウトがファイルの真の位置を表すBYTE範囲にわたってカプセル化されなくなったときに発生します。レイアウトを変更するサーバー駆動の除去またはロードバランシングなどの操作またはアクションは、レイアウトのリコールになります。レイアウトは、CB_LAYOUTRECALLコールバック操作（セクション20.3を参照）によって呼び出され、LayoutReturnで返されます（セクション18.44を参照）。CB_LAYOUTRECALL操作は、バイト範囲で識別されるレイアウト、ファイルシステムID（FSID）に関連付けられているすべてのレイアウト、またはクライアントIDに関連付けられているすべてのレイアウトを呼び出します。セクション12.5.5.2では、レイアウトの取得、返却、およびリコールを取り巻くシーケンスの問題について説明します。"
    },
    {
      "indent": 3,
      "text": "An iomode is also specified when recalling a layout. Generally, the iomode in the recall request must match the layout being returned; for example, a recall with an iomode of LAYOUTIOMODE4_RW should cause the client to only return LAYOUTIOMODE4_RW layouts and not LAYOUTIOMODE4_READ layouts. However, a special LAYOUTIOMODE4_ANY enumeration is defined to enable recalling a layout of any iomode; in other words, the client must return both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW layouts.",
      "ja": "レイアウトを呼び出すときにもIOMODEが指定されています。一般に、リコール要求のIOMODEは、返されるレイアウトと一致しなければなりません。たとえば、LayoutIomode4_RWのIOMODEを持つリコールは、クライアントにLayoutIomode4_RWレイアウトを返すことができないため、LayoutIomode4_Readレイアウトを返すようにしてください。ただし、特別なLAYOUTIOMODE4_ANE列挙体は、任意のIOMODEのレイアウトを呼び出すことを可能にするように定義されています。つまり、クライアントはLayoutIomode4_ReadとLayoutIomode4_RWレイアウトの両方を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "A REMOVE operation SHOULD cause the metadata server to recall the layout to prevent the client from accessing a non-existent file and to reclaim state stored on the client. Since a REMOVE may be delayed until the last close of the file has occurred, the recall may also be delayed until this time. After the last reference on the file has been released and the file has been removed, the client should no longer be able to perform I/O using the layout. In the case of a file-based layout, the data server SHOULD return NFS4ERR_STALE in response to any operation on the removed file.",
      "ja": "削除操作により、メタデータサーバーがレイアウトを呼び出して、クライアントが存在しないファイルにアクセスし、クライアントに保存されている状態を再呼び出すことができます。ファイルの最後の近いが発生するまで削除が遅れる可能性があるので、この時間までリコールも遅延される可能性があります。ファイルの最後の参照が解除され、ファイルが削除された後、クライアントはレイアウトを使用してI / Oを実行できなくなります。ファイルベースのレイアウトの場合、データサーバは削除されたファイルに対する任意の操作に応答してNFS4ERR_STALEを返すべきです。"
    },
    {
      "indent": 3,
      "text": "Once a layout has been returned, the client MUST NOT send I/Os to the storage devices for the file, byte-range, and iomode represented by the returned layout. If a client does send an I/O to a storage device for which it does not hold a layout, the storage device SHOULD reject the I/O.",
      "ja": "レイアウトが返されると、クライアントは返されたレイアウトによって表されるファイル、バイト範囲、およびiomodeのためにI / OSをストレージデバイスに送信してはいけません。クライアントがレイアウトを保持していないストレージデバイスにI / Oを送信した場合、ストレージデバイスはI / Oを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Although pNFS does not alter the file data caching capabilities of clients, or their semantics, it recognizes that some clients may perform more aggressive write-behind caching to optimize the benefits provided by pNFS. However, write-behind caching may negatively affect the latency in returning a layout in response to a CB_LAYOUTRECALL; this is similar to file delegations and the impact that file data caching has on DELEGRETURN. Client implementations SHOULD limit the amount of unwritten data they have outstanding at any one time in order to prevent excessively long responses to CB_LAYOUTRECALL. Once a layout is recalled, a server MUST wait one lease period before taking further action. As soon as a lease period has passed, the server may choose to fence the client's access to the storage devices if the server perceives the client has taken too long to return a layout. However, just as in the case of data delegation and DELEGRETURN, the server may choose to wait, given that the client is showing forward progress on its way to returning the layout. This forward progress can take the form of successful interaction with the storage devices or of sub-portions of the layout being returned by the client. The server can also limit exposure to these problems by limiting the byte-ranges initially provided in the layouts and thus the amount of outstanding modified data.",
      "ja": "PNFSはクライアントのファイルデータキャッシング機能、またはその意味を変更していないが、PNFSによって提供される利点を最適化するために一部のクライアントがより積極的な書き込みキャッシュを実行できることを認識している。ただし、書き込みキャッシュは、CB_LAYOUTRecallに応答してレイアウトを返す際のレイテンシに悪影響を及ぼす可能性があります。これはファイルの委任と似ています。ファイルデータキャッシュがDELEGReturnにあるという影響。クライアントの実装は、CB_LAYOUTRecallへの過度に長い応答を防ぐために、それらが未解決の未解決のデータの量を一度に制限する必要があります。レイアウトが呼び出されると、サーバーはさらにアクションを実行する前に1リース期間を待たなければなりません。リース期間が渡されるとすぐに、サーバーがレイアウトを返すのにかかわらず、クライアントがクライアントが実行されていると認識している場合、サーバーはストレージデバイスへのアクセスをフェンスすることを選択できます。ただし、データの委任とDELEGRETURNの場合と同様に、クライアントがレイアウトを返す方法で進行状況を進めることを考えると、サーバーは待機することを選択できます。この進行状況は、記憶装置またはクライアントによって返されるレイアウトのサブ部分との対話が成功することができる。サーバーはまた、レイアウトで最初に提供されたバイト範囲、したがって優れた修正データの量を制限することによって、これらの問題へのエクスポージャーを制限することもできます。"
    },
    {
      "indent": 0,
      "text": "12.5.5.1. Layout Recall Callback Robustness",
      "section_title": true,
      "ja": "12.5.5.1. レイアウトリコールコールバックの堅牢性"
    },
    {
      "indent": 3,
      "text": "It has been assumed thus far that pNFS client state (layout ranges and iomode) for a file exactly matches that of the pNFS server for that file. This assumption leads to the implication that any callback results in a LAYOUTRETURN or set of LAYOUTRETURNs that exactly match the range in the callback, since both client and server agree about the state being maintained. However, it can be useful if this assumption does not always hold. For example:",
      "ja": "これまでのところ、ファイルのPNFSクライアントの状態（レイアウト範囲とIOMode）は、そのファイルのPNFSサーバーのPNFSサーバーと完全に一致することを想定しています。この仮定は、クライアントとサーバの両方が維持されている状態について一致するため、コールバックのレイアウトリターンまたはレイアウトリターンのセットになるという意味がもたらされる。ただし、この仮定が必ずしも保持していない場合は便利です。例えば："
    },
    {
      "indent": 3,
      "text": "* If conflicts that require callbacks are very rare, and a server can use a multi-file callback to recover per-client resources (e.g., via an FSID recall or a multi-file recall within a single CB_COMPOUND), the result may be significantly less client-server pNFS traffic.",
      "ja": "* コールバックを必要とする競合が非常にまれで、サーバーがマルチファイルコールバックを使用してクライアントごとのリソースを回復できない場合（たとえば、FSIDリコールや単一のCB_COMPOUND内のマルチファイルリコールを介して）、結果はかなり少ない場合があります。クライアントサーバーのPNFSトラフィック。"
    },
    {
      "indent": 3,
      "text": "* It may be useful for servers to maintain information about what ranges are held by a client on a coarse-grained basis, leading to the server's layout ranges being beyond those actually held by the client. In the extreme, a server could manage conflicts on a per-file basis, only sending whole-file callbacks even though clients may request and be granted sub-file ranges.",
      "ja": "* サーバーが粗粒度でクライアントによって保持されている範囲に関する情報を維持するのは、サーバーのレイアウトの範囲を維持するために役立ちます。サーバーのレイアウト範囲は、実際にクライアントが保有するものを超えています。極端に、サーバーはファイルごとに競合を管理でき、クライアントが要求し、サブファイルの範囲を要求することができますが、すべてのファイルコールバックを送信できます。"
    },
    {
      "indent": 3,
      "text": "* It may be useful for clients to \"forget\" details about what layouts and ranges the client actually has, leading to the server's layout ranges being beyond those that the client \"thinks\" it has. As long as the client does not assume it has layouts that are beyond what the server has granted, this is a safe practice. When a client forgets what ranges and layouts it has, and it receives a CB_LAYOUTRECALL operation, the client MUST follow up with a LAYOUTRETURN for what the server recalled, or alternatively return the NFS4ERR_NOMATCHING_LAYOUT error if it has no layout to return in the recalled range.",
      "ja": "* クライアントに「忘れる」ために、クライアントが実際に持っているレイアウトと範囲についての詳細を「忘れる」ために便利で、サーバーのレイアウト範囲がクライアントが「考える」となることを超えています。クライアントがサーバーが付与されているものを超えているレイアウトがあると仮定していない限り、これは安全な慣習です。クライアントがどの範囲とレイアウトを持ち、CB_LAYOUTRECALL操作を受信した場合、クライアントはサーバーの呼び出し元のレイアウトリューターフランスでフォローアップしたり、リコールされた範囲に戻るレイアウトがない場合はNFS4ERR_NOMATCHING_LAYOUTエラーを返してください。"
    },
    {
      "indent": 3,
      "text": "* In order to avoid errors, it is vital that a client not assign itself layout permissions beyond what the server has granted, and that the server not forget layout permissions that have been granted. On the other hand, if a server believes that a client holds a layout that the client does not know about, it is useful for the client to cleanly indicate completion of the requested recall either by sending a LAYOUTRETURN operation for the entire requested range or by returning an NFS4ERR_NOMATCHING_LAYOUT error to the CB_LAYOUTRECALL.",
      "ja": "* エラーを回避するために、クライアントがサーバーが付与されたものを超えて自分自身のレイアウト権限を割り当てないこと、およびサーバーが付与されたレイアウト権限を忘れないことは重要です。一方、クライアントがクライアントが知らないレイアウトを保持しているサーバがサーバが信じていると、要求された範囲全体のレイアウトリュータン操作を送信することによって、クライアントが要求されたリコールの完了をきれいに示すのに役立ちます。NFS4ERR_NOMATCHING_LAYOUTエラーをCB_LAYOUTRECALLに戻す。"
    },
    {
      "indent": 3,
      "text": "Thus, in light of the above, it is useful for a server to be able to send callbacks for layout ranges it has not granted to a client, and for a client to return ranges it does not hold. A pNFS client MUST always return layouts that comprise the full range specified by the recall. Note, the full recalled layout range need not be returned as part of a single operation, but may be returned in portions. This allows the client to stage the flushing of dirty data and commits and returns of layouts. Also, it indicates to the metadata server that the client is making progress.",
      "ja": "したがって、上記に照らして、サーバーがクライアントに付与されていないレイアウト範囲にコールバックを送信できるようにするのに役立ち、クライアントが保持されません。PNFSクライアントは常にリコールで指定された全範囲を構成するレイアウトを返す必要があります。なお、全リコールレイアウト範囲は単一の操作の一部として返される必要はなく、部分的に返されてもよい。これにより、クライアントは汚れたデータのフラッシングとコミットとレイアウトのリターンを述べることができます。また、クライアントが進行中のメタデータサーバーを示します。"
    },
    {
      "indent": 3,
      "text": "When a layout is returned, the client MUST NOT have any outstanding I/O requests to the storage devices involved in the layout. Rephrasing, the client MUST NOT return the layout while it has outstanding I/O requests to the storage device.",
      "ja": "レイアウトが返されると、クライアントはレイアウトに含まれるストレージデバイスに優れたI / O要求を持たない必要があります。再フレーズ、クライアントはレイアウトを返さないでください。ストレージデバイスへの優れたI / O要求がありません。"
    },
    {
      "indent": 3,
      "text": "Even with this requirement for the client, it is possible that I/O requests may be presented to a storage device no longer allowed to perform them. Since the server has no strict control as to when the client will return the layout, the server may later decide to unilaterally revoke the client's access to the storage devices as provided by the layout. In choosing to revoke access, the server must deal with the possibility of lingering I/O requests, i.e., I/O requests that are still in flight to storage devices identified by the revoked layout. All layout type specifications MUST define whether unilateral layout revocation by the metadata server is supported; if it is, the specification must also describe how lingering writes are processed. For example, storage devices identified by the revoked layout could be fenced off from the client that held the layout.",
      "ja": "クライアントに対するこの要求でさえ、I / O要求がそれらを実行することができなくなった記憶装置に提示され得ることが可能である。クライアントがレイアウトを返すときにサーバーは、レイアウトによって提供されているように、サーバーは後でサーバーがストレージデバイスへのクライアントのアクセスを一方的に取り消すことを決定することができます。アクセスを取り消すことを選択する際に、サーバーは、I / O要求、すなわち、取り消されたレイアウトによって識別された記憶装置へのフライトであるI / O要求を長くする可能性を扱う必要があります。すべてのレイアウトタイプ指定は、メタデータサーバによる一方的なレイアウト失効がサポートされているかどうかを定義する必要があります。そうであれば、仕様はリンゴ書き込みの処理方法も説明する必要があります。たとえば、レイアウトを保持しているクライアントから、取り消されたレイアウトによって識別されたストレージデバイスをオフにすることができます。"
    },
    {
      "indent": 3,
      "text": "In order to ensure client/server convergence with regard to layout state, the final LAYOUTRETURN operation in a sequence of LAYOUTRETURN operations for a particular recall MUST specify the entire range being recalled, echoing the recalled layout type, iomode, recall/ return type (FILE, FSID, or ALL), and byte-range, even if layouts pertaining to partial ranges were previously returned. In addition, if the client holds no layouts that overlap the range being recalled, the client should return the NFS4ERR_NOMATCHING_LAYOUT error code to CB_LAYOUTRECALL. This allows the server to update its view of the client's layout state.",
      "ja": "レイアウト状態に関してクライアント/サーバのコンバージェンスを確保するために、特定のリコールの一連のレイアウトリターン操作での最後のLayoutReturn操作は、呼び出されている範囲全体を指定し、リコールレイアウトタイプ、IOMODE、リコール/リターンタイプ（ファイル部分範囲に関連するレイアウトが以前に返されたとしても、FSID、またはすべての）、およびバイト範囲。さらに、クライアントが呼び出されている範囲と重複するレイアウトを保持していない場合、クライアントはNFS4ERR_NOMATCHING_LAYOUTエラーコードをCB_LAYOUTRECALLに返す必要があります。これにより、サーバーはクライアントのレイアウト状態のビューを更新できます。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2. Sequencing of Layout Operations",
      "section_title": true,
      "ja": "12.5.5.2. レイアウト操作のシーケンス"
    },
    {
      "indent": 3,
      "text": "As with other stateful operations, pNFS requires the correct sequencing of layout operations. pNFS uses the \"seqid\" in the layout stateid to provide the correct sequencing between regular operations and callbacks. It is the server's responsibility to avoid inconsistencies regarding the layouts provided and the client's responsibility to properly serialize its layout requests and layout returns.",
      "ja": "他のステートフル操作と同様に、PNFSはレイアウト操作の正しいシーケンスを必要とします。PNFSは、レイアウトStareIDの「seqid」を使用して、通常の操作とコールバックの間の正しいシーケンスを提供します。提供されているレイアウトに関する矛盾がなく、クライアントのレイアウト要求とレイアウトの返品を正しくシリアル化する責任を回避するのは、サーバーの責任です。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1. Layout Recall and Return Sequencing",
      "section_title": true,
      "ja": "12.5.5.2.1. レイアウトリコールと返信シーケンス"
    },
    {
      "indent": 3,
      "text": "One critical issue with regard to layout operations sequencing concerns callbacks. The protocol must defend against races between the reply to a LAYOUTGET or LAYOUTRETURN operation and a subsequent CB_LAYOUTRECALL. A client MUST NOT process a CB_LAYOUTRECALL that implies one or more outstanding LAYOUTGET or LAYOUTRETURN operations to which the client has not yet received a reply. The client detects such a CB_LAYOUTRECALL by examining the \"seqid\" field of the recall's layout stateid. If the \"seqid\" is not exactly one higher than what the client currently has recorded, and the client has at least one LAYOUTGET and/or LAYOUTRETURN operation outstanding, the client knows the server sent the CB_LAYOUTRECALL after sending a response to an outstanding LAYOUTGET or LAYOUTRETURN. The client MUST wait before processing such a CB_LAYOUTRECALL until it processes all replies for outstanding LAYOUTGET and LAYOUTRETURN operations for the corresponding file with seqid less than the seqid given by CB_LAYOUTRECALL (lor_stateid; see Section 20.3.)",
      "ja": "レイアウト操作に関する1つの重要な問題は、コールバックに関するものです。プロトコルは、ReplyEgetまたはLayoutReturn操作と後続のCB_LAYOUTRecallへの応答間のレースに対して損害を受けなければなりません。クライアントは、クライアントがまだ返信を受けていない1つまたは複数の未処理のレイアウトゲットまたはLayOutReturn操作を意味するCB_LAYOUTRecallを処理してはいけません。リコールのレイアウトStateIDの「seqid」フィールドを調べて、クライアントはそのようなCB_LAYOUTRecallを検出します。 「seqid」がクライアントが記録しているものよりもまさしく、クライアントが少なくとも1つのレイアウトゲットおよび/またはLayoutReturn操作を未解決している場合、クライアントは、未処理のレイアウトゲットへの応答を送信した後にサーバーがCB_LAYOUTRECALLを送信したことを認識しています。 LayoutReturn。 CB_LAYOUTRECALL（LOR_STATEID; 20.3節を参照）のSEQIDよりもreplice for relayoutgetのすべての返信を処理するまで、クライアントはそのようなCB_LAYOUTRECALLを処理する前に待機しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to the seqid-based mechanism, Section 2.10.6.3 describes the sessions mechanism for allowing the client to detect callback race conditions and delay processing such a CB_LAYOUTRECALL. The server MAY reference conflicting operations in the CB_SEQUENCE that precedes the CB_LAYOUTRECALL. Because the server has already sent replies for these operations before sending the callback, the replies may race with the CB_LAYOUTRECALL. The client MUST wait for all the referenced calls to complete and update its view of the layout state before processing the CB_LAYOUTRECALL.",
      "ja": "SEQIDベースのメカニズムに加えて、セクション2.10.6.3は、クライアントがコールバック競合条件を検出し、そのようなCB_LAYOUTRecallを遅らせるためのセッションメカニズムを説明しています。サーバーは、CB_LAYOUTRecallの前にあるCB_Sequenceで競合する操作を参照することがあります。サーバーはコールバックを送信する前にこれらの操作に対して既に返信を送信しているため、返信はCB_LAYOUTRecallと競合することがあります。CB_LAYOUTRECALLを処理する前に、クライアントは、参照されている呼び出しのすべての呼び出しが完了してレイアウト状態の表示を完了して更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.1. Get/Return Sequencing",
      "section_title": true,
      "ja": "12.5.5.2.1.1. 順序付け/返信シーケンスを取得します"
    },
    {
      "indent": 3,
      "text": "The protocol allows the client to send concurrent LAYOUTGET and LAYOUTRETURN operations to the server. The protocol does not provide any means for the server to process the requests in the same order in which they were created. However, through the use of the \"seqid\" field in the layout stateid, the client can determine the order in which parallel outstanding operations were processed by the server. Thus, when a layout retrieved by an outstanding LAYOUTGET operation intersects with a layout returned by an outstanding LAYOUTRETURN on the same file, the order in which the two conflicting operations are processed determines the final state of the overlapping layout. The order is determined by the \"seqid\" returned in each operation: the operation with the higher seqid was executed later.",
      "ja": "このプロトコルでは、クライアントは同時レイアウトおよびLayoutReturn操作をサーバーに送信できます。プロトコルは、サーバーが作成したのと同じ順序で要求を処理するための手段を提供しません。ただし、レイアウトステーションIDの「SEQID」フィールドを使用することで、クライアントは並列顕著な操作がサーバーによって処理された順序を決定できます。したがって、優れたレイアウト操作によって検索されたレイアウトが同じファイル上の未処理のレイアウトリューターントによって返されたレイアウトと交差すると、2つの競合する操作が処理される順序が重なり合うレイアウトの最終状態を決定します。注文は、各操作で返された「SEQID」によって決定されます。より高いSEQIDの操作は後述した。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to send multiple parallel LAYOUTGET operations for the same file or multiple parallel LAYOUTRETURN operations for the same file or a mix of both.",
      "ja": "クライアントが、同じファイルまたは同じファイルまたは両方の組み合わせに対して、同じファイルまたは複数の並列レイアウトリュータフリュード操作に対して複数の並列レイアウト操作を送信することが許可されています。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to use the current stateid (see Section 16.2.3.1.2) for LAYOUTGET operations, for example, when compounding LAYOUTGETs or compounding OPEN and LAYOUTGETs. It is also permissible to use the current stateid when compounding LAYOUTRETURNs.",
      "ja": "レイアウトまたはアシンディングオープンおよびレイオウトゲットを配合するときなど、クライアントがLayoutGet操作の現在のStateID（16.2.3.1.2項を参照）を使用することは許可されています。LayoutReturnsを配合するときに現在のStateIDを使用することもできます。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to use the current stateid when combining LAYOUTRETURN and LAYOUTGET operations for the same file in the same COMPOUND request since the server MUST process these in order. However, if a client does send such COMPOUND requests, it MUST NOT have more than one outstanding for the same file at the same time, and it MUST NOT have other LAYOUTGET or LAYOUTRETURN operations outstanding at the same time for that same file.",
      "ja": "サーバーがこれらを順番に処理する必要があるため、同じ複合要求内のLayoutReturnとLayoutget操作を組み合わせるときに、クライアントが現在のStateIDを使用することは許可されています。ただし、クライアントがそのような複合要求を送信した場合は、同じファイルに対して複数の未処理を同時に持っていない必要があり、その同じファイルに対して同時に優れた他のLayoutgetまたはLayoutReturn操作を持たない必要があります。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.2. Client Considerations",
      "section_title": true,
      "ja": "12.5.5.2.1.2. クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Consider a pNFS client that has sent a LAYOUTGET, and before it receives the reply to LAYOUTGET, it receives a CB_LAYOUTRECALL for the same file with an overlapping range. There are two possibilities, which the client can distinguish via the layout stateid in the recall.",
      "ja": "レイアウトを送信したPNFSクライアントを検討し、レイアウトへの返信を受信する前に、重複範囲の同じファイルに対してCB_LAYOUTRECALLを受信します。クライアントがリコール内のレイアウトStateIDを区別できる2つの可能性があります。"
    },
    {
      "indent": 3,
      "text": "1. The server processed the LAYOUTGET before sending the recall, so the LAYOUTGET must be waited for because it may be carrying layout information that will need to be returned to deal with the CB_LAYOUTRECALL.",
      "ja": "1. サーバーはリコールを送信する前にレイアウトを処理しているので、CB_LAYOUTRecallに対処するために返す必要があるレイアウト情報を伝送する可能性があるため、レイアウトが待機する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The server sent the callback before receiving the LAYOUTGET. The server will not respond to the LAYOUTGET until the CB_LAYOUTRECALL is processed.",
      "ja": "2. レイアウトを受信する前に、サーバーはコールバックを送信しました。CB_LAYOUTRECALLが処理されるまで、サーバーはレイアウトに応答しません。"
    },
    {
      "indent": 3,
      "text": "If these possibilities cannot be distinguished, a deadlock could result, as the client must wait for the LAYOUTGET response before processing the recall in the first case, but that response will not arrive until after the recall is processed in the second case. Note that in the first case, the \"seqid\" in the layout stateid of the recall is two greater than what the client has recorded; in the second case, the \"seqid\" is one greater than what the client has recorded. This allows the client to disambiguate between the two cases. The client thus knows precisely which possibility applies.",
      "ja": "最初のケースでリコールを処理する前にクライアントがレイアウトの応答を待つ必要があるため、デッドロックが発生する可能性がある場合は、デッドロックが発生する可能性がありますが、リコールが2番目のケースで処理されるまで応答は到着しません。最初に、リコールのレイアウトステートIDの「seqid」は、クライアントが記録したものよりも大きいことに注意してください。2番目の場合、「seqid」は、クライアントが記録したものよりも1つです。これにより、クライアントは2つのケース間で曖昧さを軽減できます。そのため、クライアントは正確にどの可能性が適用されるかを知っています。"
    },
    {
      "indent": 3,
      "text": "In case 1, the client knows it needs to wait for the LAYOUTGET response before processing the recall (or the client can return NFS4ERR_DELAY).",
      "ja": "ケース1では、クライアントは、リコールを処理する前にLayoutgetの応答を待つ必要があることを知っています（またはクライアントがNFS4R_DELAYを返すことができる）。"
    },
    {
      "indent": 3,
      "text": "In case 2, the client will not wait for the LAYOUTGET response before processing the recall because waiting would cause deadlock. Therefore, the action at the client will only require waiting in the case that the client has not yet seen the server's earlier responses to the LAYOUTGET operation(s).",
      "ja": "ケース2では、待機中にデッドロックが発生するため、リコールを処理する前に、クライアントはレイアウトの応答を待機しません。したがって、クライアントのアクションは、クライアントがまだレイアウト操作に対するサーバーの以前の回答を見ていない場合にのみ待機する必要があります。"
    },
    {
      "indent": 3,
      "text": "The recall process can be considered completed when the final LAYOUTRETURN operation for the recalled range is completed. The LAYOUTRETURN uses the layout stateid (with seqid) specified in CB_LAYOUTRECALL. If the client uses multiple LAYOUTRETURNs in processing the recall, the first LAYOUTRETURN will use the layout stateid as specified in CB_LAYOUTRECALL. Subsequent LAYOUTRETURNs will use the highest seqid as is the usual case.",
      "ja": "リコールプロセスは、リコール範囲の最終的なレイアウトリターン操作が完了したときに完了することができます。LayoutReturnは、cb_layoutRecallで指定されたレイアウトstateID（seqidを持つ）を使用します。リコールを処理する際にクライアントが複数のLayoutReturnを使用している場合、最初のLayoutReturnはCB_LAYOUTRecallで指定されているレイアウトステートIDを使用します。その後のLayoutReturnsは通常の場合と同様に最高のSEQIDを使用します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.3. Server Considerations",
      "section_title": true,
      "ja": "12.5.5.2.1.3. サーバーの考慮事項"
    },
    {
      "indent": 3,
      "text": "Consider a race from the metadata server's point of view. The metadata server has sent a CB_LAYOUTRECALL and receives an overlapping LAYOUTGET for the same file before the LAYOUTRETURN(s) that respond to the CB_LAYOUTRECALL. There are three cases:",
      "ja": "メタデータサーバの観点からのレースを考えてみましょう。メタデータサーバーはCB_LAYOUTRECALLを送信し、CB_LAYOUTRecallに応答するLayoutReturnの前に同じファイルに対して重複するレイアウトゲットを受け取りました。3つのケースがあります。"
    },
    {
      "indent": 3,
      "text": "1. The client sent the LAYOUTGET before processing the CB_LAYOUTRECALL. The \"seqid\" in the layout stateid of the arguments of LAYOUTGET is one less than the \"seqid\" in CB_LAYOUTRECALL. The server returns NFS4ERR_RECALLCONFLICT to the client, which indicates to the client that there is a pending recall.",
      "ja": "1. クライアントはCB_LAYOUTRECALLを処理する前にレイアウトゲットを送信しました。LayoutGetの引数のレイアウトステートIDの \"seqid\"は、cb_layoutrecallの \"seqid\"より1小さいです。サーバーはクライアントにNFS4ERR_RECALLCONFLICTを返します。これは、保留中のリコールがあることをクライアントに示すことを示します。"
    },
    {
      "indent": 3,
      "text": "2. The client sent the LAYOUTGET after processing the CB_LAYOUTRECALL, but the LAYOUTGET arrived before the LAYOUTRETURN and the response to CB_LAYOUTRECALL that completed that processing. The \"seqid\" in the layout stateid of LAYOUTGET is equal to or greater than that of the \"seqid\" in CB_LAYOUTRECALL. The server has not received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RECALLCONFLICT.",
      "ja": "2. クライアントはCB_LAYOUTRECALLを処理した後にレイアウトゲットを送信しましたが、その処理が完了したCB_LAYOUTRecallへの応答の前にレイアウトが到着しました。LayoutgetのレイアウトステートIDの \"seqid\"は、CB_LAYOUTRecallの \"seqid\"のそれ以上です。サーバーはCB_LAYOUTRECALLへの応答を受け取っていないため、NFS4ERR_RECALLCONFLICTを返します。"
    },
    {
      "indent": 3,
      "text": "3. The client sent the LAYOUTGET after processing the CB_LAYOUTRECALL; the server received the CB_LAYOUTRECALL response, but the LAYOUTGET arrived before the LAYOUTRETURN that completed that processing. The \"seqid\" in the layout stateid of LAYOUTGET is equal to that of the \"seqid\" in CB_LAYOUTRECALL. The server has received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RETURNCONFLICT.",
      "ja": "3. クライアントはCB_LAYOUTRecallを処理した後にレイアウトゲットを送信しました。サーバーはCB_LAYOUTRECALL応答を受け取りましたが、その処理が完了したLayoutReturnの前にレイアウトが到着しました。LayoutgetのレイアウトステートIDの「seqid」は、CB_LAYOUTRecallの \"seqid\"の \"seqid\"のそれと同じです。サーバーはCB_LAYOUTRECALLへの応答を受け取りましたので、NFS4ERR_RETURNCONFLICTを返します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.4. Wraparound and Validation of Seqid",
      "section_title": true,
      "ja": "12.5.5.2.1.4. SEQIDのラップアラウンドと検証"
    },
    {
      "indent": 3,
      "text": "The rules for layout stateid processing differ from other stateids in the protocol because the \"seqid\" value cannot be zero and the stateid's \"seqid\" value changes in a CB_LAYOUTRECALL operation. The non-zero requirement combined with the inherent parallelism of layout operations means that a set of LAYOUTGET and LAYOUTRETURN operations may contain the same value for \"seqid\". The server uses a slightly modified version of the modulo arithmetic as described in Section 2.10.6.1 when incrementing the layout stateid's \"seqid\". The difference is that zero is not a valid value for \"seqid\"; when the value of a \"seqid\" is 0xFFFFFFFF, the next valid value will be 0x00000001. The modulo arithmetic is also used for the comparisons of \"seqid\" values in the processing of CB_LAYOUTRECALL events as described above in Section 12.5.5.2.1.3.",
      "ja": "「seqid」値はゼロになり、StateIDの \"seqid\"値がcb_layoutRecall操作で変更できないため、レイアウトのルールはプロトコル内の他のStateIDとは異なります。レイアウト操作の固有の並列処理と組み合わされていないゼロ以外の要件は、一連のレイアウトおよびレイアウトリターン操作が「seqid」に同じ値を含めることができることを意味します。レイアウトStateIDの「seqid」を増やすときは、セクション2.10.6.1で説明されているように、サーバーはモジュロ算術演算の少し変更されたバージョンを使用します。違いは、ゼロが \"seqid\"の有効な値ではないということです。「seqid」の値が0xFFFFFFFFの場合、次の有効な値は0x00000001になります。モジュロ算術演算は、第12.5.5.2.1.3項で上述したように、CB_LAYOUTRECALLイベントの処理における「seqid」値の比較にも使用されます。"
    },
    {
      "indent": 3,
      "text": "Just as the server validates the \"seqid\" in the event of CB_LAYOUTRECALL usage, as described in Section 12.5.5.2.1.3, the server also validates the \"seqid\" value to ensure that it is within an appropriate range. This range represents the degree of parallelism the server supports for layout stateids. If the client is sending multiple layout operations to the server in parallel, by definition, the \"seqid\" value in the supplied stateid will not be the current \"seqid\" as held by the server. The range of parallelism spans from the highest or current \"seqid\" to a \"seqid\" value in the past. To assist in the discussion, the server's current \"seqid\" value for a layout stateid is defined as SERVER_CURRENT_SEQID. The lowest \"seqid\" value that is acceptable to the server is represented by PAST_SEQID. And the value for the range of valid \"seqid\"s or range of parallelism is VALID_SEQID_RANGE. Therefore, the following holds: VALID_SEQID_RANGE = SERVER_CURRENT_SEQID - PAST_SEQID. In the following, all arithmetic is the modulo arithmetic as described above.",
      "ja": "セクション12.5.5.2.1.3で説明されているように、サーバはCB_LAYOUTRECALL使用法の場合に「seqid」を検証しているように、サーバは適切な範囲内であることを確認するために「seqid」値を検証します。この範囲は、レイアウトステーションのためのサーバーがサポートする並列度を表します。クライアントが並行して複数のレイアウト操作を並行して送信している場合、定義によって、提供されたStareIDの「seqid」値はサーバーによって保持されている現在の \"seqid\"にならないでしょう。平行度の範囲は、最高または現在の「seqid」から過去の「seqid」値までスパンします。議論を支援するために、レイアウトStateIDのサーバーの現在の「seqid」値はserver_current_seqidとして定義されています。サーバーに許容される最低の「seqid」値はpast_seqidによって表されます。有効な \"seqid\"または並列処理の範囲の値は有効です_seqid_rangeです。したがって、次のことは次のとおりです.valid_seqid_range = server_current_seqid  -  past_seqid。以下では、すべての演算は上述のようなモジュロ演算である。"
    },
    {
      "indent": 3,
      "text": "The server MUST support a minimum VALID_SEQID_RANGE. The minimum is defined as: VALID_SEQID_RANGE = summation over 1..N of (ca_maxoperations(i) - 1), where N is the number of session fore channels and ca_maxoperations(i) is the value of the ca_maxoperations returned from CREATE_SESSION of the i'th session. The reason for \"- 1\" is to allow for the required SEQUENCE operation. The server MAY support a VALID_SEQID_RANGE value larger than the minimum. The maximum VALID_SEQID_RANGE is (2^(32) - 2) (accounting for zero not being a valid \"seqid\" value).",
      "ja": "サーバーは最小限の有効なものをサポートしている必要があります。最小値は、valid_seqid_range = 1..N（CA_MAXOPERATIONS（i） -  1）を超えて定義されます。ここで、nはセッション前チャネルの数、ca_maxoperations（i）はiのcreate_sessionから返されたca_maxoperationsの値です。セッションのセッション「 -  1」の理由は、必要なシーケンス操作を可能にすることです。サーバーは、最小値よりも大きい有効なvalid_seqid_range値をサポートできます。最大有効なvalid_seqid_rangeは（2 ^（32） -  2）です（ゼロが有効ではありません \"seqid\"値）です。"
    },
    {
      "indent": 3,
      "text": "If the server finds the \"seqid\" is zero, the NFS4ERR_BAD_STATEID error is returned to the client. The server further validates the \"seqid\" to ensure it is within the range of parallelism, VALID_SEQID_RANGE. If the \"seqid\" value is outside of that range, the error NFS4ERR_OLD_STATEID is returned to the client. Upon receipt of NFS4ERR_OLD_STATEID, the client updates the stateid in the layout request based on processing of other layout requests and re-sends the operation to the server.",
      "ja": "サーバーが \"seqid\"を見つけた場合、NFS4ERR_BAD_STATEIDエラーがクライアントに返されます。サーバーはさらに「seqid」を検証して、それが並列処理の範囲内であることを確認します。「seqid」値がその範囲外の場合、エラーNFS4ERR_OLD_STATEIDがクライアントに返されます。NFS4ERR_OLD_STATATIDIDを受信すると、クライアントは他のレイアウト要求の処理に基づいてレイアウト要求のSTATEIDを更新し、操作をサーバーに再送信します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.5. Bulk Recall and Return",
      "section_title": true,
      "ja": "12.5.5.2.1.5. バルクリコールとリターン"
    },
    {
      "indent": 3,
      "text": "pNFS supports recalling and returning all layouts that are for files belonging to a particular fsid (LAYOUTRECALL4_FSID, LAYOUTRETURN4_FSID) or client ID (LAYOUTRECALL4_ALL, LAYOUTRETURN4_ALL). There are no \"bulk\" stateids, so detection of races via the seqid is not possible. The server MUST NOT initiate bulk recall while another recall is in progress, or the corresponding LAYOUTRETURN is in progress or pending. In the event the server sends a bulk recall while the client has a pending or in-progress LAYOUTRETURN, CB_LAYOUTRECALL, or LAYOUTGET, the client returns NFS4ERR_DELAY. In the event the client sends a LAYOUTGET or LAYOUTRETURN while a bulk recall is in progress, the server returns NFS4ERR_RECALLCONFLICT. If the client sends a LAYOUTGET or LAYOUTRETURN after the server receives NFS4ERR_DELAY from a bulk recall, then to ensure forward progress, the server MAY return NFS4ERR_RECALLCONFLICT.",
      "ja": "PNFSは、特定のFSID（LayoutRecall4_fsid、LayoutReturn4_fsid）またはクライアントID（LayoutRecall4_all、LayoutReturn4_all）に属するファイル用のすべてのレイアウトをリコールおよび返信します。「バルク」州の状態はありませんので、SEQIDを介したレースの検出はできません。別のリコールが進行中、または対応するLayoutReturnが進行中または保留中にサーバーはバルクリコールを開始してはいけません。クライアントの保留中またはインプロジング内のLayoutReturn、CB_LAYOUTRecall、またはLayoutGetがある間、サーバーがバルクリコールを送信した場合、クライアントはNFS4ERR_DELAYを返します。一括リコールが進行中にクライアントがレイアウトまたはLayOutReturnを送信した場合、サーバーはNFS4ERR_RecallConflictを返します。サーバーがバルクリコールからNFS4ERR_DELAYを受信した後、クライアントがレイアウトまたはLayOutReturnを送信した場合、サーバーはNFS4ERR_RECALLCONFLICTを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "Once a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL is sent, the server MUST NOT allow the client to use any layout stateid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_ALL is sent, all layout stateids granted to the client ID are freed. The client MUST NOT use the layout stateids again. It MUST use LAYOUTGET to obtain new layout stateids.",
      "ja": "LayoutRecall4_allのCB_LAYOUTRECALLが送信されると、サーバーはLayoutCommit操作を除いてクライアントがレイアウトSTATEIDを使用できるようにしてはなりません。クライアントがLayOutRecall4_allのCB_LAYOUTRecallを受信すると、LayoutCommit操作を除いてレイアウトSTATEIDを使用しないでください。LayoutReturn4_allを送信すると、クライアントIDに付与されているすべてのレイアウトステートIDが解放されます。クライアントはレイアウトステーションを再度使用してはいけません。新しいレイアウトステーションを取得するには、Layoutgetを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID is sent, the server MUST NOT allow the client to use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_FSID is sent, all layout stateids granted to the referenced fsid are freed. The client MUST NOT use those freed layout stateids for files with the referenced fsid again. Subsequently, for any file with the referenced fsid, to use a layout, the client MUST first send a LAYOUTGET operation in order to obtain a new layout stateid for that file.",
      "ja": "LayoutRecall4_fsidのCB_LAYOUTRecallが送信されると、サーバーは、レイアウトコミット操作を除いて、指定されたFSIDを持つファイルを参照するレイアウトSTATEIDをクライアントに使用できるようにしてはいけません。クライアントがLAYOUTRECALL4_ALLのCB_LAYOUTRECALLを受信すると、LayoutCommit操作を除いて指定されたFSIDを持つファイルを参照するレイアウトSTATEIDを使用しないでください。LayoutReturn4_FSIDのLayoutReturnが送信されると、参照されているFSIDに付与されているすべてのレイアウトステーションが解放されます。クライアントは、参照されているFSIDを使用してファイルの解放レイアウトステーションを使用してはいけません。その後、参照されているFSIDを持つファイルの場合は、レイアウトを使用するために、クライアントは最初にそのファイルの新しいレイアウトStareIDを取得するためにレイアウト操作を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTGET, or a LAYOUTRETURN with a stateid, the server MUST return NFS4ERR_RECALLCONFLICT. If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTRETURN with an lr_returntype that is not equal to the lor_recalltype of the CB_LAYOUTRECALL, the server MUST return NFS4ERR_RECALLCONFLICT.",
      "ja": "サーバーがバルクCB_LAYOUTRECALLを送信してレイアウトゲット、またはStareIDを使用してレイアウトを受信した場合、サーバーはNFS4ERR_RECALLCONFLICTを返す必要があります。サーバーがBULK CB_LAYOUTRECALLを送信し、CB_LAYOUTRECALLのLR_RECALLTYPEに等しくないLR_RETURNTYPEを使用してLayoutReturnを受信した場合、サーバーはNFS4ERR_RECALLCONFLICTを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "12.5.6. Revoking Layouts",
      "section_title": true,
      "ja": "12.5.6. レイアウトの取り消し"
    },
    {
      "indent": 3,
      "text": "Parallel NFS permits servers to revoke layouts from clients that fail to respond to recalls and/or fail to renew their lease in time. Depending on the layout type, the server might revoke the layout and might take certain actions with respect to the client's I/O to data servers.",
      "ja": "パラレルNFSは、サーバーがリコールに応答できないクライアントからレイアウトを取り消すことを許可します。レイアウトタイプに応じて、サーバーはレイアウトを取り消す可能性があり、クライアントのI / Oに対してデータサーバーに対して特定のアクションを実行する可能性があります。"
    },
    {
      "indent": 0,
      "text": "12.5.7. Metadata Server Write Propagation",
      "section_title": true,
      "ja": "12.5.7. メタデータサーバーライト伝播"
    },
    {
      "indent": 3,
      "text": "Asynchronous writes written through the metadata server may be propagated lazily to the storage devices. For data written asynchronously through the metadata server, a client performing a read at the appropriate storage device is not guaranteed to see the newly written data until a COMMIT occurs at the metadata server. While the write is pending, reads to the storage device may give out either the old data, the new data, or a mixture of new and old. Upon completion of a synchronous WRITE or COMMIT (for asynchronously written data), the metadata server MUST ensure that storage devices give out the new data and that the data has been written to stable storage. If the server implements its storage in any way such that it cannot obey these constraints, then it MUST recall the layouts to prevent reads being done that cannot be handled correctly. Note that the layouts MUST be recalled prior to the server responding to the associated WRITE operations.",
      "ja": "メタデータサーバを介して書き込まれた非同期書き込みは、記憶装置に遅延されている可能性がある。メタデータサーバを介して非同期的に書き込まれたデータの場合、適切な記憶装置で読み取りを実行するクライアントは、メタデータサーバでコミットが発生するまで新たに書き込まれたデータを見ることは保証されていない。書き込みが保留中である間、ストレージデバイスへの読み取りは、古いデータ、新しいデータ、または新旧の混合のいずれかを与えることができます。同期書き込みまたはコミットが完了したら（非同期に書き込まれたデータの場合）、メタデータサーバは、ストレージデバイスが新しいデータを提供し、データが安定したストレージに書き込まれていることを確認する必要があります。これらの制約に従わないようにサーバーがそのストレージを実行する場合は、読み取りが正しく処理できないようにレイアウトを呼び出してください。関連付けられている書き込み操作に応答するサーバーの前にレイアウトを呼び出す必要があります。"
    },
    {
      "indent": 0,
      "text": "12.6. pNFS Mechanics",
      "section_title": true,
      "ja": "12.6. PNFSメカニズム"
    },
    {
      "indent": 3,
      "text": "This section describes the operations flow taken by a pNFS client to a metadata server and storage device.",
      "ja": "このセクションでは、PNFSクライアントがメタデータサーバーとストレージデバイスに取得した操作フローについて説明します。"
    },
    {
      "indent": 3,
      "text": "When a pNFS client encounters a new FSID, it sends a GETATTR to the NFSv4.1 server for the fs_layout_type (Section 5.12.1) attribute. If the attribute returns at least one layout type, and the layout types returned are among the set supported by the client, the client knows that pNFS is a possibility for the file system. If, from the server that returned the new FSID, the client does not have a client ID that came from an EXCHANGE_ID result that returned EXCHGID4_FLAG_USE_PNFS_MDS, it MUST send an EXCHANGE_ID to the server with the EXCHGID4_FLAG_USE_PNFS_MDS bit set. If the server's response does not have EXCHGID4_FLAG_USE_PNFS_MDS, then contrary to what the fs_layout_type attribute said, the server does not support pNFS, and the client will not be able use pNFS to that server; in this case, the server MUST return NFS4ERR_NOTSUPP in response to any pNFS operation.",
      "ja": "PNFSクライアントが新しいFSIDに遭遇すると、FS_LAYOUT_TYPE（セクション5.12.1）属性のNFSV4.1サーバーにGetAttrを送信します。属性が少なくとも1つのレイアウトタイプを返し、返されるレイアウト型がクライアントによってサポートされているセットの中にある場合、クライアントはPNFSがファイルシステムの可能性であることを認識しています。新しいFSIDを返したサーバーから、クライアントにExchgid4_flag_use_pnfs_mdsが返されたExchange_ID結果から取得されたクライアントIDがない場合は、Exchgid4_flag_use_pnfs_mdsビットセットを使用してExchange_idをサーバーに送信する必要があります。サーバーの応答にEXCHGID4_FLAG_USE_PNFS_MDSがない場合は、FS_LAYOUT_TYPE属性とは反対に、サーバーはPNFSをサポートしておらず、クライアントはそのサーバーにPNFSを使用できません。この場合、PNFS操作に応答してサーバーはNFS4ERR_NOTSUPPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The client then creates a session, requesting a persistent session, so that exclusive creates can be done with single round trip via the createmode4 of GUARDED4. If the session ends up not being persistent, the client will use EXCLUSIVE4_1 for exclusive creates.",
      "ja": "その後、クライアントはセッションを作成し、永続的なセッションを要求します。セッションが永続的ではない場合、クライアントはexclusive4_1を排他的作成に使用します。"
    },
    {
      "indent": 3,
      "text": "If a file is to be created on a pNFS-enabled file system, the client uses the OPEN operation. With the normal set of attributes that may be provided upon OPEN used for creation, there is an OPTIONAL layout_hint attribute. The client's use of layout_hint allows the client to express its preference for a layout type and its associated layout details. The use of a createmode4 of UNCHECKED4, GUARDED4, or EXCLUSIVE4_1 will allow the client to provide the layout_hint attribute at create time. The client MUST NOT use EXCLUSIVE4 (see Table 18). The client is RECOMMENDED to combine a GETATTR operation after the OPEN within the same COMPOUND. The GETATTR may then retrieve the layout_type attribute for the newly created file. The client will then know what layout type the server has chosen for the file and therefore what storage protocol the client must use.",
      "ja": "ファイルがPNFS対応のファイルシステム上で作成される場合、クライアントはオープン操作を使用します。作成に使用されるオープンで提供され得る通常の属性セットを使用すると、オプションのLAYOUT_HINT属性があります。クライアントのLAYOUT_HINTの使用により、クライアントはレイアウトタイプとそれに関連付けられたレイアウトの詳細に対する設定を表現できます。UnChecked4、Guarded4、またはExclusive4_1のCreateMode4を使用すると、クライアントはCREATE TIMEでLAYOUT_HINT属性を提供できます。クライアントはexclusive4を使用してはいけません（表18を参照）。クライアントは、同じ化合物内の開いている後にGETATTR操作を組み合わせることをお勧めします。その後、getAttrは新しく作成されたファイルのlayout_type属性を取得することができます。クライアントは、サーバーがファイルを選択したのか、したがってクライアントがどのストレージプロトコルを使用する必要があるのかを知っています。"
    },
    {
      "indent": 3,
      "text": "If the client wants to open an existing file, then it also includes a GETATTR to determine what layout type the file supports.",
      "ja": "クライアントが既存のファイルを開きたい場合は、ファイルがサポートするレイアウトタイプを決定するためのgetAttrも含まれています。"
    },
    {
      "indent": 3,
      "text": "The GETATTR in either the file creation or plain file open case can also include the layout_blksize and layout_alignment attributes so that the client can determine optimal offsets and lengths for I/O on the file.",
      "ja": "ファイル作成またはプレーンファイルオープンケースのgetAttrには、クライアントがファイル上のI / Oの最適なオフセットと長さを決定できるように、LAYOUT_BLKSIZEおよびLAYOUT_ALIGNMINMINMENT属性を含めることもできます。"
    },
    {
      "indent": 3,
      "text": "Assuming the client supports the layout type returned by GETATTR and it chooses to use pNFS for data access, it then sends LAYOUTGET using the filehandle and stateid returned by OPEN, specifying the range it wants to do I/O on. The response is a layout, which may be a subset of the range for which the client asked. It also includes device IDs and a description of how data is organized (or in the case of writing, how data is to be organized) across the devices. The device IDs and data description are encoded in a format that is specific to the layout type, but the client is expected to understand.",
      "ja": "クライアントがgetAttrによって返されたレイアウトタイプをサポートしていると仮定し、データアクセスのためにPNFSを使用することを選択してから、I / O ONを実行したい範囲を指定します。応答はレイアウトで、クライアントが尋ねた範囲のサブセットである可能性があります。デバイスIDと、データがどのように整理されているか（または書き込みの場合、データの編成方法、データの編成がどのように編成するか）の説明を含みます。デバイスIDとデータの説明は、レイアウトタイプに固有の形式でエンコードされていますが、クライアントは理解することが期待されています。"
    },
    {
      "indent": 3,
      "text": "When the client wants to send an I/O, it determines to which device ID it needs to send the I/O command by examining the data description in the layout. It then sends a GETDEVICEINFO to find the device address(es) of the device ID. The client then sends the I/O request to one of device ID's device addresses, using the storage protocol defined for the layout type. Note that if a client has multiple I/Os to send, these I/O requests may be done in parallel.",
      "ja": "クライアントがI / Oを送信したい場合は、レイアウト内のデータ記述を調べてI / Oコマンドを送信する必要があるデバイスIDを決定します。その後、getDeviceInfoを送信してデバイスIDのデバイスアドレスを見つけます。その後、クライアントは、レイアウトタイプに定義されたストレージプロトコルを使用して、I / O要求をデバイスIDのデバイスアドレスの1つに送信します。クライアントが送信する複数のI / Oを持つ場合、これらのI / O要求は並行して行われます。"
    },
    {
      "indent": 3,
      "text": "If the I/O was a WRITE, then at some point the client may want to use LAYOUTCOMMIT to commit the modification time and the new size of the file (if it believes it extended the file size) to the metadata server and the modified data to the file system.",
      "ja": "I / Oが書き込みであった場合は、ある時点で、クライアントは、変更時間とファイルの新しいサイズをコミットしたい場合があります（ファイルサイズがファイルサイズを拡張された場合）、メタデータサーバーと変更されたデータをコミットします。ファイルシステムに。"
    },
    {
      "indent": 0,
      "text": "12.7. Recovery",
      "section_title": true,
      "ja": "12.7. 回復"
    },
    {
      "indent": 3,
      "text": "Recovery is complicated by the distributed nature of the pNFS protocol. In general, crash recovery for layouts is similar to crash recovery for delegations in the base NFSv4.1 protocol. However, the client's ability to perform I/O without contacting the metadata server introduces subtleties that must be handled correctly if the possibility of file system corruption is to be avoided.",
      "ja": "回復はPNFSプロトコルの分散性によって複雑です。一般に、レイアウトのクラッシュリカバリは、ベースNFSV4.1プロトコルの委任のクラッシュ回復と似ています。ただし、メタデータサーバーに連絡せずにI / Oを実行するクライアントの機能は、ファイルシステムの破損の可能性が回避される可能性がある場合に正しく処理されなければならないサプライを導入します。"
    },
    {
      "indent": 0,
      "text": "12.7.1. Recovery from Client Restart",
      "section_title": true,
      "ja": "12.7.1. クライアントの再起動からの回復"
    },
    {
      "indent": 3,
      "text": "Client recovery for layouts is similar to client recovery for other lock and delegation state. When a pNFS client restarts, it will lose all information about the layouts that it previously owned. There are two methods by which the server can reclaim these resources and allow otherwise conflicting layouts to be provided to other clients.",
      "ja": "レイアウトのクライアントの回復は、他のロックと委任状態のクライアントの回復と似ています。PNFSクライアントが再起動すると、以前に所有しているレイアウトに関するすべての情報が失われます。サーバーがこれらのリソースを取り戻すことができ、他のクライアントに競合するレイアウトを提供できるようにする方法は2つあります。"
    },
    {
      "indent": 3,
      "text": "The first is through the expiry of the client's lease. If the client recovery time is longer than the lease period, the client's lease will expire and the server will know that state may be released. For layouts, the server may release the state immediately upon lease expiry or it may allow the layout to persist, awaiting possible lease revival, as long as no other layout conflicts.",
      "ja": "1つ目はクライアントのリースの有効期限を延ばします。クライアントの回復時間がリース期間よりも長い場合、クライアントのリースは期限切れになり、サーバーはその状態が解放される可能性があることを知っています。レイアウトの場合、サーバーはリースの有効期限が切れたときに常時を解放することができ、あるいは他のレイアウトの競合がない限り、レイアウトを持続させることができます。"
    },
    {
      "indent": 3,
      "text": "The second is through the client restarting in less time than it takes for the lease period to expire. In such a case, the client will contact the server through the standard EXCHANGE_ID protocol. The server will find that the client's co_ownerid matches the co_ownerid of the previous client invocation, but that the verifier is different. The server uses this as a signal to release all layout state associated with the client's previous invocation. In this scenario, the data written by the client but not covered by a successful LAYOUTCOMMIT is in an undefined state; it may have been written or it may now be lost. This is acceptable behavior and it is the client's responsibility to use LAYOUTCOMMIT to achieve the desired level of stability.",
      "ja": "2つ目は、リース期間が期限切れになるのにかかる時間が短い時間内に再起動するクライアントを介して行われます。そのような場合、クライアントは標準のExchange_IDプロトコルを介してサーバーに連絡します。サーバーは、クライアントのCO_OWNERIDが前のクライアント呼び出しのCO_OWNERIDと一致するが、検証者が異なることがわかります。サーバーはこれをシグナルとして使用して、クライアントの前の呼び出しに関連付けられているすべてのレイアウト状態を解放します。このシナリオでは、クライアントによって書き込まれていますが、LayoutCommitが成功したデータは未定義の状態にあります。書かれたかもしれませんが、今失われるかもしれません。これは許容される動作であり、希望の安定性を達成するためにLayoutCommitを使用することがクライアントの責任です。"
    },
    {
      "indent": 0,
      "text": "12.7.2. Dealing with Lease Expiration on the Client",
      "section_title": true,
      "ja": "12.7.2. クライアントのリース期限を扱う"
    },
    {
      "indent": 3,
      "text": "If a client believes its lease has expired, it MUST NOT send I/O to the storage device until it has validated its lease. The client can send a SEQUENCE operation to the metadata server. If the SEQUENCE operation is successful, but sr_status_flag has SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, or SEQ4_STATUS_ADMIN_STATE_REVOKED set, the client MUST NOT use currently held layouts. The client has two choices to recover from the lease expiration. First, for all modified but uncommitted data, the client writes it to the metadata server using the FILE_SYNC4 flag for the WRITEs, or WRITE and COMMIT. Second, the client re-establishes a client ID and session with the server and obtains new layouts and device-ID-to-device-address mappings for the modified data ranges and then writes the data to the storage devices with the newly obtained layouts.",
      "ja": "クライアントがリースが期限切れになったと信じている場合は、リースが検証されるまでI / Oをストレージデバイスに送信してはいけません。クライアントはメタデータサーバーにシーケンス操作を送信できます。シーケンス操作が成功したが、sr_status_flagはseq4_status_expired_all_state_revoked、seq4_status_expired_some_state_revoked、またはseq4_status_admin_state_revokedセットを持つセットを持っていますが、クライアントは現在保持されているレイアウトを使用してはいけません。クライアントには、リースの有効期限から回復するための2つの選択肢があります。まず、変更されたすべてのデータではないデータの場合、クライアントは書き込みのためにfile_sync4フラグを使用してメタデータサーバーに書き込みます。第2に、クライアントはサーバーとのクライアントIDとセッションを再確立し、変更されたデータ範囲の新しいレイアウトとデバイスID-to-device-addressマッピングを取得してから、新しく取得されたレイアウトを使用してデータを記憶装置に書き込みます。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags from the metadata server has SEQ4_STATUS_RESTART_RECLAIM_NEEDED set (or SEQUENCE returns NFS4ERR_BAD_SESSION and CREATE_SESSION returns NFS4ERR_STALE_CLIENTID), then the metadata server has restarted, and the client SHOULD recover using the methods described in Section 12.7.4.",
      "ja": "Metadata ServerからSR_STATUS_FLAGSがSEQ4_STATUS_RESTART_RECLAIM_NEEDEDセットを持つ場合（またはSequenceはNFS4ERR_BAD_SESSIONおよびCREATE_SESSIONを返します）、メタデータサーバーが再起動し、クライアントはセクション12.7.4で説明されているメソッドを使用して回復する必要があります。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags from the metadata server has SEQ4_STATUS_LEASE_MOVED set, then the client recovers by following the procedure described in Section 11.11.9.2. After that, the client may get an indication that the layout state was not moved with the file system. The client recovers as in the other applicable situations discussed in the first two paragraphs of this section.",
      "ja": "メタデータサーバからSR_STATUS_FLAGSがSEQ4_STATUS_LEASE_MOVED SETを持つ場合、クライアントはセクション11.11.9.2で説明されている手順に従って回復します。その後、クライアントは、レイアウト状態がファイルシステムと共に移動されなかったことを指示を受けることがある。このセクションの最初の2段落で説明した他の適用状況のようにクライアントが回復します。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags reports no loss of state, then the lease for the layouts that the client has are valid and renewed, and the client can once again send I/O requests to the storage devices.",
      "ja": "SR_STATUS_FLAGSが状態の損失を報告しない場合、クライアントが有効かつ更新されたレイアウトのリース、クライアントは再びI / O要求をストレージデバイスに送信することができます。"
    },
    {
      "indent": 3,
      "text": "While clients SHOULD NOT send I/Os to storage devices that may extend past the lease expiration time period, this is not always possible, for example, an extended network partition that starts after the I/O is sent and does not heal until the I/O request is received by the storage device. Thus, the metadata server and/or storage devices are responsible for protecting themselves from I/Os that are both sent before the lease expires and arrive after the lease expires. See Section 12.7.3.",
      "ja": "クライアントはリースの有効期間を過ぎる可能性があるストレージデバイスにI / Oを送信しないでください。たとえば、I / Oが送信された後に始まる拡張ネットワークパーティションなど、常に可能ではなく、iが治癒しません。/ O要求はストレージデバイスによって受信されます。したがって、メタデータサーバおよび/またはストレージ装置は、リースが期限切れになる前に送信され、リースが期限切れになった後に到着するI / Oから自分自身を保護する責任がある。12.7.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "12.7.3. Dealing with Loss of Layout State on the Metadata Server",
      "section_title": true,
      "ja": "12.7.3. メタデータサーバー上のレイアウト状態の喪失を扱う"
    },
    {
      "indent": 3,
      "text": "This is a description of the case where all of the following are true:",
      "ja": "これは、以下のすべてが当てはまる場合の説明です。"
    },
    {
      "indent": 3,
      "text": "* the metadata server has not restarted",
      "ja": "* メタデータサーバーは再起動していません"
    },
    {
      "indent": 3,
      "text": "* a pNFS client's layouts have been discarded (usually because the client's lease expired) and are invalid",
      "ja": "* PNFSクライアントのレイアウトが破棄されました（通常はクライアントのリースが期限切れになったため）が無効です。"
    },
    {
      "indent": 3,
      "text": "* an I/O from the pNFS client arrives at the storage device",
      "ja": "* PNFSクライアントからのI / Oはストレージデバイスに到着します"
    },
    {
      "indent": 3,
      "text": "The metadata server and its storage devices MUST solve this by fencing the client. In other words, they MUST solve this by preventing the execution of I/O operations from the client to the storage devices after layout state loss. The details of how fencing is done are specific to the layout type. The solution for NFSv4.1 file-based layouts is described in (Section 13.11), and solutions for other layout types are in their respective external specification documents.",
      "ja": "メタデータサーバーとそのストレージデバイスは、クライアントをフェンシングすることによってこれを解決する必要があります。言い換えれば、レイアウト状態損失後にクライアントからストレージ装置への入出力操作の実行を防ぐことによってこれを解決する必要があります。フェンシングがどのように行われるかの詳細はレイアウトタイプに固有のものです。NFSV4.1ファイルベースのレイアウトの解決策は（セクション13.11）に記載されており、他のレイアウトタイプの解決策はそれぞれの外部仕様書にあります。"
    },
    {
      "indent": 0,
      "text": "12.7.4. Recovery from Metadata Server Restart",
      "section_title": true,
      "ja": "12.7.4. メタデータサーバーの再起動からの回復"
    },
    {
      "indent": 3,
      "text": "The pNFS client will discover that the metadata server has restarted via the methods described in Section 8.4.2 and discussed in a pNFS-specific context in Section 12.7.2, Paragraph 2. The client MUST stop using layouts and delete the device ID to device address mappings it previously received from the metadata server. Having done that, if the client wrote data to the storage device without committing the layouts via LAYOUTCOMMIT, then the client has additional work to do in order to have the client, metadata server, and storage device(s) all synchronized on the state of the data.",
      "ja": "PNFSクライアントは、メタデータサーバーがセクション8.4.2で説明されているメソッドを介して再起動し、セクション12.7.2、段落2のPNFS固有のコンテキストで説明されていることを検出します。クライアントはレイアウトの使用を停止し、デバイスIDをデバイスに削除する必要があります。Metadata Serverから以前に受信したアドレスマッピング。クライアントがLayoutCommitを介してレイアウトをコミットせずにクライアントがストレージデバイスにデータを書き込んだ場合、クライアント、メタデータサーバー、およびストレージデバイスをすべて同期させるためにクライアントに追加の作業が行われます。データ。"
    },
    {
      "indent": 3,
      "text": "* If the client has data still modified and unwritten in the client's memory, the client has only two choices.",
      "ja": "* クライアントがクライアントのメモリにデータを変更して解読している場合、クライアントには2つの選択肢しかありません。"
    },
    {
      "indent": 6,
      "text": "1. The client can obtain a layout via LAYOUTGET after the server's grace period and write the data to the storage devices.",
      "ja": "1. クライアントは、サーバーの猶予期間の後にレイアウトを介してレイアウトを取得し、データを記憶装置に書き込むことができます。"
    },
    {
      "indent": 6,
      "text": "2. The client can WRITE that data through the metadata server using the WRITE (Section 18.32) operation, and then obtain layouts as desired.",
      "ja": "2. クライアントは、書き込み（セクション18.32）の操作を使用してメタデータサーバを介してそのデータを書き込み、必要に応じてレイアウトを取得できます。"
    },
    {
      "indent": 3,
      "text": "* If the client asynchronously wrote data to the storage device, but still has a copy of the data in its memory, then it has available to it the recovery options listed above in the previous bullet point. If the metadata server is also in its grace period, the client has available to it the options below in the next bullet point.",
      "ja": "* クライアントが非同期的にデータをストレージデバイスに書き込みたが、まだそのメモリ内のデータのコピーを持っている場合は、前の箇条書きで上記の回復オプションが利用可能になりました。メタデータサーバーが猶予期間内にある場合、クライアントは次の箇条書きポイントの下のオプションで利用可能です。"
    },
    {
      "indent": 3,
      "text": "* The client does not have a copy of the data in its memory and the metadata server is still in its grace period. The client cannot use LAYOUTGET (within or outside the grace period) to reclaim a layout because the contents of the response from LAYOUTGET may not match what it had previously. The range might be different or the client might get the same range but the content of the layout might be different. Even if the content of the layout appears to be the same, the device IDs may map to different device addresses, and even if the device addresses are the same, the device addresses could have been assigned to a different storage device. The option of retrieving the data from the storage device and writing it to the metadata server per the recovery scenario described above is not available because, again, the mappings of range to device ID, device ID to device address, and device address to physical device are stale, and new mappings via new LAYOUTGET do not solve the problem.",
      "ja": "* クライアントにはメモリ内のデータのコピーはありません。メタデータサーバーはまだ猶予期間内にあります。クライアントはレイアウトを再利用してレイアウトを再利用してレイアウトを再利用できません。範囲は異なる場合があります。クライアントは同じ範囲を取得する可能性がありますが、レイアウトの内容が異なる場合があります。レイアウトの内容が同じであっても、デバイスIDは異なるデバイスアドレスにマッピングされ、デバイスアドレスが同じであっても、デバイスアドレスが異なるストレージデバイスに割り当てられている可能性があります。上記の回復シナリオごとにデータを取得してメタデータサーバに書き込むオプションは、デバイスID、デバイスアドレスへのデバイスID、および物理デバイスへのデバイスアドレスの範囲のマッピングを再度使用できないためです。古くなっており、新しいレイアウトを介した新しいマッピングは問題を解決しません。"
    },
    {
      "indent": 6,
      "text": "The only recovery option for this scenario is to send a LAYOUTCOMMIT in reclaim mode, which the metadata server will accept as long as it is in its grace period. The use of LAYOUTCOMMIT in reclaim mode informs the metadata server that the layout has changed. It is critical that the metadata server receive this information before its grace period ends, and thus before it starts allowing updates to the file system.",
      "ja": "このシナリオの唯一の回復オプションはReclaimモードでLayoutCommitを送信することです。これは、メタデータサーバーはその猶予期間内にある限り受け入れます。ReclaimモードでLayoutCommitを使用すると、レイアウトが変更されたことをメタデータサーバーに通知します。メタデータサーバーがその猶予期間が終了する前にこの情報を受信することが重要です。したがって、ファイルシステムへの更新を許可する前に起動します。"
    },
    {
      "indent": 6,
      "text": "To send LAYOUTCOMMIT in reclaim mode, the client sets the loca_reclaim field of the operation's arguments (Section 18.42.1) to TRUE. During the metadata server's recovery grace period (and only during the recovery grace period) the metadata server is prepared to accept LAYOUTCOMMIT requests with the loca_reclaim field set to TRUE.",
      "ja": "ReclaimモードでLayoutCommitを送信するために、クライアントは運用の引数のloca_reclaimフィールド（セクション18.42.1）をtrueに設定します。メタデータサーバーのリカバリ猶予期間中（およびリカバリ猶予期間中のみ）の間に、Metadata ServerはLoca_Reclaimフィールドをtrueに設定してLayoutCommit要求を受け入れる準備ができています。"
    },
    {
      "indent": 6,
      "text": "When loca_reclaim is TRUE, the client is attempting to commit changes to the layout that occurred prior to the restart of the metadata server. The metadata server applies some consistency checks on the loca_layoutupdate field of the arguments to determine whether the client can commit the data written to the storage device to the file system. The loca_layoutupdate field is of data type layoutupdate4 and contains layout-type-specific content (in the lou_body field of loca_layoutupdate). The layout-type-specific information that loca_layoutupdate might have is discussed in Section 12.5.4.3. If the metadata server's consistency checks on loca_layoutupdate succeed, then the metadata server MUST commit the data (as described by the loca_offset, loca_length, and loca_layoutupdate fields of the arguments) that was written to the storage device. If the metadata server's consistency checks on loca_layoutupdate fail, the metadata server rejects the LAYOUTCOMMIT operation and makes no changes to the file system. However, any time LAYOUTCOMMIT with loca_reclaim TRUE fails, the pNFS client has lost all the data in the range defined by <loca_offset, loca_length>. A client can defend against this risk by caching all data, whether written synchronously or asynchronously in its memory, and by not releasing the cached data until a successful LAYOUTCOMMIT. This condition does not hold true for all layout types; for example, file-based storage devices need not suffer from this limitation.",
      "ja": "loca_reclaimがtrueの場合、クライアントはメタデータサーバの再起動前に発生したレイアウトへの変更をコミットしようとしています。メタデータサーバーは、引数のLOCA_LAYOUTUPDATEフィールドに対していくつかの整合性チェックを適用して、クライアントがストレージデバイスに書き込まれたデータをファイルシステムにコミットできるかどうかを判断します。 LOCA_LAYOUTUPDATEフィールドはデータ型のLayoutUpdate4のもので、（Loca_LayoutUpdateのLOU_BODYフィールド）レイアウトタイプ固有のコンテンツが含まれています。 Loca_LayoutUpdateが持っている可能性があるレイアウト型固有の情報については、12.5.4.3項で説明しています。 Metadata Serverの整合性がloca_layoutupdateを成功させる場合、メタデータサーバーは、ストレージデバイスに書き込まれた（引数のloca_offset、loca_length、およびloca_layoutupdateフィールド）データをコミットする必要があります。 Metadata Serverの整合性がloca_layoutupdateに失敗した場合、メタデータサーバーはLayoutCommit操作を拒否し、ファイルシステムを変更しません。ただし、LOCA_RECLAIM TRUEのTIME LAYOUTCOMMは失敗した場合、PNFSクライアントは<LOCA_OFFSET、LOCA_LENGTH>で定義された範囲内のすべてのデータを失いました。クライアントは、そのメモリに同期的にまたは非同期的に書き込まれているかどうか、すべてのデータをキャッシュすることによって、および成功したLayoutCommitまでキャッシュされたデータを解放しないことによって、このリスクを防ぎます。この状態は、すべてのレイアウトタイプに対してTRUEを保持しません。たとえば、ファイルベースのストレージデバイスはこの制限を受けている必要はありません。"
    },
    {
      "indent": 3,
      "text": "* The client does not have a copy of the data in its memory and the metadata server is no longer in its grace period; i.e., the metadata server returns NFS4ERR_NO_GRACE. As with the scenario in the above bullet point, the failure of LAYOUTCOMMIT means the data in the range <loca_offset, loca_length> lost. The defense against the risk is the same -- cache all written data on the client until a successful LAYOUTCOMMIT.",
      "ja": "* クライアントにはメモリ内のデータのコピーはありません。メタデータサーバーは、もはや猶予期間内にありません。すなわち、メタデータサーバはNFS4ERR_NO_GRACEを返します。上記の箇条書き時点でのシナリオと同様に、LayoutCommitの障害は、<LOCA_OFFSET、LOCA_LENGTH>の範囲内のデータを意味します。リスクに対する防御は同じですが、すべてのLayoutCommitまでクライアント上のすべての書き込まれたデータをキャッシュします。"
    },
    {
      "indent": 0,
      "text": "12.7.5. Operations during Metadata Server Grace Period",
      "section_title": true,
      "ja": "12.7.5. メタデータサーバー猶予期間中の操作"
    },
    {
      "indent": 3,
      "text": "Some of the recovery scenarios thus far noted that some operations (namely, WRITE and LAYOUTGET) might be permitted during the metadata server's grace period. The metadata server may allow these operations during its grace period. For LAYOUTGET, the metadata server must reliably determine that servicing such a request will not conflict with an impending LAYOUTCOMMIT reclaim request. For WRITE, the metadata server must reliably determine that servicing the request will not conflict with an impending OPEN or with a LOCK where the file has mandatory byte-range locking enabled.",
      "ja": "これまでのいくつかの回復シナリオは、メタデータサーバの猶予期間中に一部の操作（つまり、書き込みおよびレイアウト）が許可されている可能性があると説明したものもあります。メタデータサーバーは、その猶予期間中にこれらの操作を可能にします。LayoutGetの場合、メタデータサーバーは、そのような要求をサービス処理することは、差し迫ったLayoutCommit Reclaim要求と競合しないことを確実に決定する必要があります。書き込みの場合、メタデータサーバは、リクエストをサービスを受けることが不要なオープンまたはロックと競合しないことを確実に判断する必要があります。ファイルが必須バイトレンジロックが有効になっているロックと競合してください。"
    },
    {
      "indent": 3,
      "text": "As mentioned previously, for expediency, the metadata server might reject some operations (namely, WRITE and LAYOUTGET) during its grace period, because the simplest correct approach is to reject all non-reclaim pNFS requests and WRITE operations by returning the NFS4ERR_GRACE error. However, depending on the storage protocol (which is specific to the layout type) and metadata server implementation, the metadata server may be able to determine that a particular request is safe. For example, a metadata server may save provisional allocation mappings for each file to stable storage, as well as information about potentially conflicting OPEN share modes and mandatory byte-range locks that might have been in effect at the time of restart, and the metadata server may use this information during the recovery grace period to determine that a WRITE request is safe.",
      "ja": "前述のように、利点のために、メタデータサーバーは、最新の正しいアプローチが、NFS4ERR_GRACEエラーを返すことによってすべての非再生PNFS要求および書き込み操作を拒否することができるため、メタデータサーバーはその猶予期間中にいくつかの操作（つまり、ライトとレイアウト）を拒否することがあります。ただし、ストレージプロトコル（レイアウトタイプに固有のもの）とメタデータサーバ実装に応じて、メタデータサーバは特定の要求が安全であると判断できる可能性があります。たとえば、メタデータサーバーは、各ファイルの暫定割り当てマッピングを安定したストレージに保存することができます。また、再起動時に有効になっている可能性がある潜在的に競合するオープンシェアモードとメタデータサーバーに関する情報を保存することがあります。回復猶予期間中にこの情報を使用して、書き込み要求が安全であると判断することができます。"
    },
    {
      "indent": 0,
      "text": "12.7.6. Storage Device Recovery",
      "section_title": true,
      "ja": "12.7.6. ストレージデバイスの回復"
    },
    {
      "indent": 3,
      "text": "Recovery from storage device restart is mostly dependent upon the layout type in use. However, there are a few general techniques a client can use if it discovers a storage device has crashed while holding modified, uncommitted data that was asynchronously written. First and foremost, it is important to realize that the client is the only one that has the information necessary to recover non-committed data since it holds the modified data and probably nothing else does. Second, the best solution is for the client to err on the side of caution and attempt to rewrite the modified data through another path.",
      "ja": "ストレージデバイスの再起動からの回復は、使用中のレイアウトタイプにほとんど依存します。しかしながら、非同期的に書き込まれた修正されていないデータを保持している間に、クライアントが記憶装置がクラッシュした場合にクライアントが使用できる一般的な技術がいくつかある。まず第一に、クライアントが、変更されていないデータを回復するために必要な情報を持つ唯一のものであることを認識することは重要です。第二に、最良の解決策は、クライアントが注意側に誤りを求め、別のパスを介して修正されたデータを書き直そうとします。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD immediately WRITE the data to the metadata server, with the stable field in the WRITE4args set to FILE_SYNC4. Once it does this, there is no need to wait for the original storage device.",
      "ja": "クライアントはすぐにデータをMetadata Serverに書き込むべきです.Rilth4argsの安定フィールドはfile_sync4に設定されています。これを行うと、元のストレージデバイスを待つ必要はありません。"
    },
    {
      "indent": 0,
      "text": "12.8. Metadata and Storage Device Roles",
      "section_title": true,
      "ja": "12.8. メタデータとストレージデバイスのロール"
    },
    {
      "indent": 3,
      "text": "If the same physical hardware is used to implement both a metadata server and storage device, then the same hardware entity is to be understood to be implementing two distinct roles and it is important that it be clearly understood on behalf of which role the hardware is executing at any given time.",
      "ja": "同じ物理ハードウェアがメタデータサーバとストレージデバイスの両方を実装するために使用される場合、同じハードウェアエンティティは2つの異なる役割を実装していると理解されるべきであり、ハードウェアが実行している役割を明確に理解することが重要です。任意の時間に。"
    },
    {
      "indent": 3,
      "text": "Two sub-cases can be distinguished.",
      "ja": "2つのサブケースを区別することができます。"
    },
    {
      "indent": 3,
      "text": "1. The storage device uses NFSv4.1 as the storage protocol, i.e., the same physical hardware is used to implement both a metadata and data server. See Section 13.1 for a description of how multiple roles are handled.",
      "ja": "1. ストレージデバイスは、ストレージプロトコル、すなわち同じ物理ハードウェアを使用してメタデータとデータサーバの両方を実装するために使用される。複数のロールの処理方法については、セクション13.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. The storage device does not use NFSv4.1 as the storage protocol, and the same physical hardware is used to implement both a metadata and storage device. Whether distinct network addresses are used to access the metadata server and storage device is immaterial. This is because it is always clear to the pNFS client and server, from the upper-layer protocol being used (NFSv4.1 or non-NFSv4.1), to which role the request to the common server network address is directed.",
      "ja": "2. ストレージデバイスは、ストレージプロトコルとしてNFSV4.1を使用しません。また、メタデータとストレージデバイスの両方を実装するために同じ物理ハードウェアが使用されます。Metadata ServerとStorageデバイスにアクセスするために異なるネットワークアドレスが使用されているかどうかは重要ではありません。これは、使用されている上位レイヤプロトコル（NFSV4.1またはNFSV4.1）からPNFSクライアントとサーバーには常に明確になり、共通サーバーネットワークアドレスへの要求が指示されている役割を担当します。"
    },
    {
      "indent": 0,
      "text": "12.9. Security Considerations for pNFS",
      "section_title": true,
      "ja": "12.9. PNFSのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "pNFS separates file system metadata and data and provides access to both. There are pNFS-specific operations (listed in Section 12.3) that provide access to the metadata; all existing NFSv4.1 conventional (non-pNFS) security mechanisms and features apply to accessing the metadata. The combination of components in a pNFS system (see Figure 1) is required to preserve the security properties of NFSv4.1 with respect to an entity that is accessing a storage device from a client, including security countermeasures to defend against threats for which NFSv4.1 provides defenses in environments where these threats are considered significant.",
      "ja": "PNFSはファイルシステムのメタデータとデータを区切り、両方へのアクセスを提供します。メタデータへのアクセスを提供するPNFS固有の操作（セクション12.3にリストされています）。既存のNFSV4.1のすべての従来の（PNFS以外の）セキュリティメカニズムと機能は、メタデータへのアクセスに適用されます。PNFSシステム内のコンポーネントの組み合わせ（図1参照）は、NFSV4の脅威に対して守るためのセキュリティ対策を含む、クライアントからのストレージデバイスにアクセスしているエンティティに関するNFSV4.1のセキュリティプロパティを保持するために必要です。1これらの脅威が重要と考えられる環境で防御を提供します。"
    },
    {
      "indent": 3,
      "text": "In some cases, the security countermeasures for connections to storage devices may take the form of physical isolation or a recommendation to avoid the use of pNFS in an environment. For example, it may be impractical to provide confidentiality protection for some storage protocols to protect against eavesdropping. In environments where eavesdropping on such protocols is of sufficient concern to require countermeasures, physical isolation of the communication channel (e.g., via direct connection from client(s) to storage device(s)) and/or a decision to forgo use of pNFS (e.g., and fall back to conventional NFSv4.1) may be appropriate courses of action.",
      "ja": "場合によっては、記憶装置への接続のためのセキュリティ対策は、環境内のPNFSの使用を回避するための物理的分離または推奨の形をとることができる。例えば、盗聴から保護するためにいくつかの記憶プロトコルのための機密保護を提供することは実用的であり得る。そのようなプロトコルを盗聴する環境では、対策、通信チャネルの物理的分離（例えば、記憶装置から記憶装置への直接接続による）および/またはPNFの使用を指すことに十分な懸念がある。例えば、従来のNFSV4.1に戻ることは適切な行動コースであり得る。"
    },
    {
      "indent": 3,
      "text": "Where communication with storage devices is subject to the same threats as client-to-metadata server communication, the protocols used for that communication need to provide security mechanisms as strong as or no weaker than those available via RPCSEC_GSS for NFSv4.1. Except for the storage protocol used for the LAYOUT4_NFSV4_1_FILES layout (see Section 13), i.e., except for NFSv4.1, it is beyond the scope of this document to specify the security mechanisms for storage access protocols.",
      "ja": "Storage Devicesとの通信がクライアントからメタデータサーバー通信と同じ脅威にさらされている場合、その通信に使用されるプロトコルは、NFSV4.1のRPCSEC_GSSを介して使用可能なものよりも安全性の高いものと同じくらい弱いものとして提供する必要があります。Layout4_NFSV4_1_FILESレイアウトに使用されるストレージプロトコル（セクション13参照）を除いて、すなわちNFSv4.1を除く、ストレージアクセスプロトコルのセキュリティメカニズムを指定することがこの文書の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "pNFS implementations MUST NOT remove NFSv4.1's access controls. The combination of clients, storage devices, and the metadata server are responsible for ensuring that all client-to-storage-device file data access respects NFSv4.1's ACLs and file open modes. This entails performing both of these checks on every access in the client, the storage device, or both (as applicable; when the storage device is an NFSv4.1 server, the storage device is ultimately responsible for controlling access as described in Section 13.9.2). If a pNFS configuration performs these checks only in the client, the risk of a misbehaving client obtaining unauthorized access is an important consideration in determining when it is appropriate to use such a pNFS configuration. Such layout types SHOULD NOT be used when client-only access checks do not provide sufficient assurance that NFSv4.1 access control is being applied correctly. (This is not a problem for the file layout type described in Section 13 because the storage access protocol for LAYOUT4_NFSV4_1_FILES is NFSv4.1, and thus the security model for storage device access via LAYOUT4_NFSv4_1_FILES is the same as that of the metadata server.) For handling of access control specific to a layout, the reader should examine the layout specification, such as the NFSv4.1/ file-based layout (Section 13) of this document, the blocks layout [48], and objects layout [47].",
      "ja": "PNFS実装は、NFSv4.1のアクセス制御を削除してはいけません。クライアント、ストレージデバイス、およびメタデータサーバーの組み合わせは、すべてのクライアントへのデバイスファイルのデータアクセスがNFSV4.1のACLおよびファイルオープンモードを尊重することを保証する責任があります。これは、クライアント、ストレージデバイス、またはその両方のアクセスごとにこれらのチェックの両方のチェックを実行することを伴います（該当する場合は、ストレージデバイスがNFSV4.1サーバーである場合、ストレージデバイスは最終的にはセクション13.9で説明されているようにアクセス制御に責任があります。 2）。 PNFS構成がクライアント内でのみこれらのチェックを実行すると、不正アクセスを取得する不正なクライアントのリスクは、そのようなPNFS構成を使用するのが適切であるかどうかを判断することにおいて重要な考慮事項です。このようなレイアウトタイプは、クライアントのみのアクセスチェックにNFSv4.1アクセス制御が正しく適用されているのに十分な保証がない場合は使用しないでください。 （LAYOUT4_NFSV4_1_1_FILEのストレージアクセスプロトコルはNFSV4.1であるため、セクション13で説明されているファイルレイアウトタイプの問題ではありません。レイアウトに固有のアクセス制御の処理、リーダーは、この文書のNFSV4.1 /ファイルベースのレイアウト（セクション13）、ブロックレイアウト[48]、およびオブジェクトレイアウト[47]などのレイアウト指定を調べる必要があります。"
    },
    {
      "indent": 0,
      "text": "13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type",
      "section_title": true,
      "ja": "13. PNFSのストレージプロトコルとしてのNFSV4.1：ファイルレイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "This section describes the semantics and format of NFSv4.1 file-based layouts for pNFS. NFSv4.1 file-based layouts use the LAYOUT4_NFSV4_1_FILES layout type. The LAYOUT4_NFSV4_1_FILES type defines striping data across multiple NFSv4.1 data servers.",
      "ja": "このセクションでは、PNFSのNFSV4.1ファイルベースのレイアウトのセマンティクスとフォーマットについて説明します。NFSV4.1ファイルベースのレイアウトLayout4_nfsv4_1_filesレイアウトタイプを使用します。LAYOUT4_NFSV4_1_FILESタイプは、複数のNFSV4.1データサーバーにわたるストライピングデータを定義します。"
    },
    {
      "indent": 0,
      "text": "13.1. Client ID and Session Considerations",
      "section_title": true,
      "ja": "13.1. クライアントIDとセッションの考慮事項"
    },
    {
      "indent": 3,
      "text": "Sessions are a REQUIRED feature of NFSv4.1, and this extends to both the metadata server and file-based (NFSv4.1-based) data servers.",
      "ja": "セッションはNFSV4.1の必須機能です。これは、メタデータサーバーとファイルベース（NFSV4.1ベース）のデータサーバーの両方に拡張されています。"
    },
    {
      "indent": 3,
      "text": "The role a server plays in pNFS is determined by the result it returns from EXCHANGE_ID. The roles are:",
      "ja": "PNFSでサーバーが再生する役割は、それがExchange_IDから返す結果によって決まります。役割は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Metadata server (EXCHGID4_FLAG_USE_PNFS_MDS is set in the result eir_flags).",
      "ja": "* メタデータサーバー（結果EIR_FLAGSには、EXCHGID4_FLAG_USE_PNFS_MDSが設定されています）。"
    },
    {
      "indent": 3,
      "text": "* Data server (EXCHGID4_FLAG_USE_PNFS_DS).",
      "ja": "* データサーバ（Exchgid4_flag_use_pnfs_ds）。"
    },
    {
      "indent": 3,
      "text": "* Non-metadata server (EXCHGID4_FLAG_USE_NON_PNFS). This is an NFSv4.1 server that does not support operations (e.g., LAYOUTGET) or attributes that pertain to pNFS.",
      "ja": "* 非メタデータサーバー（Exchgid4_flag_use_non_pnfs）。これは、操作（例えば、Layoutget）またはPNFSに関連する属性をサポートしていないNFSV4.1サーバーです。"
    },
    {
      "indent": 3,
      "text": "The client MAY request zero or more of EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_DS, or EXCHGID4_FLAG_USE_PNFS_MDS, even though some combinations (e.g., EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS) are contradictory. However, the server MUST only return the following acceptable combinations:",
      "ja": "クライアントは、いくつかの組み合わせ（例えばExchgid4_flag_use_non_pnfsであっても、exchgid4_flag_use_non_pnfs、exchgid4_flag_use_pnfs_ds、またはExchgid4_flag_use_pnfs_mdsを要求することができる。"
    },
    {
      "indent": 8,
      "text": "+========================================================+\n| Acceptable Results from EXCHANGE_ID                    |\n+========================================================+\n| EXCHGID4_FLAG_USE_PNFS_MDS                             |\n+--------------------------------------------------------+\n| EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS |\n+--------------------------------------------------------+\n| EXCHGID4_FLAG_USE_PNFS_DS                              |\n+--------------------------------------------------------+\n| EXCHGID4_FLAG_USE_NON_PNFS                             |\n+--------------------------------------------------------+\n| EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS |\n+--------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 8",
      "ja": "表8."
    },
    {
      "indent": 3,
      "text": "As the above table implies, a server can have one or two roles. A server can be both a metadata server and a data server, or it can be both a data server and non-metadata server. In addition to returning two roles in the EXCHANGE_ID's results, and thus serving both roles via a common client ID, a server can serve two roles by returning a unique client ID and server owner for each role in each of two EXCHANGE_ID results, with each result indicating each role.",
      "ja": "上の表が暗示するように、サーバーは1つまたは2つの役割を持つことができます。サーバーはメタデータサーバーとデータサーバーの両方にすることも、データサーバーと非メタデータサーバーの両方にすることもできます。Exchange_IDの結果に2つの役割を返すことに加えて、共通のクライアントIDを介して両方の役割を果たすことに加えて、サーバーは2つのExchange_ID結果のそれぞれで各役割について固有のクライアントIDとサーバーの所有者を返すことによって2つの役割を果たすことができます。各役割を示す。"
    },
    {
      "indent": 3,
      "text": "In the case of a server with concurrent pNFS roles that are served by a common client ID, if the EXCHANGE_ID request from the client has zero or a combination of the bits set in eia_flags, the server result should set bits that represent the higher of the acceptable combination of the server roles, with a preference to match the roles requested by the client. Thus, if a client request has (EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) flags set, and the server is both a metadata server and a data server, serving both the roles by a common client ID, the server SHOULD return with (EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) set.",
      "ja": "共通のクライアントIDによって提供される同時PNFSロールを持つサーバーの場合、クライアントからのExchange_ID要求がゼロまたはEIA_FLAGSで設定されたビットの組み合わせがある場合、サーバーの結果は、より高いものを表すビットを設定する必要があります。サーバーロールの許容可能な組み合わせ、クライアントによって要求された役割と一致するように優先されます。したがって、クライアント要求がある場合（exchgid4_flag_use_non_pnfs"
    },
    {
      "indent": 3,
      "text": "In the case of a server that has multiple concurrent pNFS roles, each role served by a unique client ID, if the client specifies zero or a combination of roles in the request, the server results SHOULD return only one of the roles from the combination specified by the client request. If the role specified by the server result does not match the intended use by the client, the client should send the EXCHANGE_ID specifying just the interested pNFS role.",
      "ja": "複数の同時PNFSロールを持つサーバーの場合、各役割は一意のクライアントIDによってサービスを提供しました。クライアントが要求内のゼロまたは役割の組み合わせを指定した場合、サーバーの結果は、指定された組み合わせからの役割のみを返すはずです。クライアント要求によって。サーバー結果で指定された役割がクライアントによる使用目的と一致しない場合、クライアントは関心のあるPNFSロールだけを指定してExchange_idを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a pNFS metadata client gets a layout that refers it to an NFSv4.1 data server, it needs a client ID on that data server. If it does not yet have a client ID from the server that had the EXCHGID4_FLAG_USE_PNFS_DS flag set in the EXCHANGE_ID results, then the client needs to send an EXCHANGE_ID to the data server, using the same co_ownerid as it sent to the metadata server, with the EXCHGID4_FLAG_USE_PNFS_DS flag set in the arguments. If the server's EXCHANGE_ID results have EXCHGID4_FLAG_USE_PNFS_DS set, then the client may use the client ID to create sessions that will exchange pNFS data operations. The client ID returned by the data server has no relationship with the client ID returned by a metadata server unless the client IDs are equal, and the server owners and server scopes of the data server and metadata server are equal.",
      "ja": "PNFSメタデータクライアントがNFSV4.1データサーバに参照するレイアウトを取得した場合、そのデータサーバ上のクライアントIDが必要です。Exchange_IDにexchgid4_flag_use_pnfs_ds_dsフラグを設定したサーバーからまだクライアントIDがない場合、クライアントはMetadata Serverに送信されたものと同じCO_OWNERIDを使用して、Exchangeをデータサーバーに送信する必要があります。Almentsに設定されているEXCHGID4_FLAG_USE_PNFS_DSフラグが設定されています。サーバーのExchange_IDの結果にEXCHGID4_FLAG_USE_PNFS_DSセットが設定されている場合、クライアントはクライアントIDを使用してPNFSデータ操作を交換するセッションを作成できます。データサーバから返されたクライアントIDには、クライアントIDが等しい限り、メタデータサーバから返されたクライアントIDとの関係はありません。また、データサーバとメタデータサーバのサーバ所有者およびサーバスコープは等しい。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, the session ID in the SEQUENCE operation implies the client ID, which in turn might be used by the server to map the stateid to the right client/server pair. However, when a data server is presented with a READ or WRITE operation with a stateid, because the stateid is associated with a client ID on a metadata server, and because the session ID in the preceding SEQUENCE operation is tied to the client ID of the data server, the data server has no obvious way to determine the metadata server from the COMPOUND procedure, and thus has no way to validate the stateid. One RECOMMENDED approach is for pNFS servers to encode metadata server routing and/or identity information in the data server filehandles as returned in the layout.",
      "ja": "NFSv4.1では、シーケンス操作のセッションIDはクライアントIDを意味します。クライアントIDは、StateIDを正しいクライアント/サーバーペアにマッピングするためにサーバーによって使用される可能性があります。ただし、StateIDを使用してデータサーバが読み書き操作で表示されている場合、StateIDはメタデータサーバ上のクライアントIDに関連付けられており、前のシーケンス操作のセッションIDがクライアントIDに関連付けられているためデータサーバ、データサーバは、複合プロシージャからメタデータサーバを決定するための明らかな方法はありませんので、StateIDを検証する方法はありません。1つの推奨アプローチは、PNFSサーバのためのデータサーバファイルハンドル内のメタデータサーバルーティングおよび/またはアイデンティティ情報をレイアウトで返されるようにエンコードすることである。"
    },
    {
      "indent": 3,
      "text": "If metadata server routing and/or identity information is encoded in data server filehandles, when the metadata server identity or location changes, the data server filehandles it gave out will become invalid (stale), and so the metadata server MUST first recall the layouts. Invalidating a data server filehandle does not render the NFS client's data cache invalid. The client's cache should map a data server filehandle to a metadata server filehandle, and a metadata server filehandle to cached data.",
      "ja": "メタデータサーバーのルーティングやアイデンティティ情報がデータサーバーファイルハンドルでエンコードされている場合、メタデータサーバーのIDまたは場所が変更されたときに、データサーバーのファイルハンドルが実行されたときに無効（古い）が表示され、メタデータサーバーは最初にレイアウトを呼び出しなければなりません。データサーバーファイルハンドルを無効にすると、NFSクライアントのデータキャッシュが無効になりません。クライアントのキャッシュは、データサーバファイルハンドルをメタデータサーバファイルハンドルにマッピングする必要があり、データサーバファイルハンドルをキャッシュしたデータをキャッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server is both a metadata server and a data server, the server might need to distinguish operations on files that are directed to the metadata server from those that are directed to the data server. It is RECOMMENDED that the values of the filehandles returned by the LAYOUTGET operation be different than the value of the filehandle returned by the OPEN of the same file.",
      "ja": "サーバーがメタデータサーバーとデータサーバーの両方である場合、サーバーはデータサーバーに向けられたものからメタデータサーバーに送信されているファイルの操作を区別する必要があります。Layoutget操作によって返されるファイルハンドルの値は、同じファイルの開いているファイルハンドルの値とは異なることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Another scenario is for the metadata server and the storage device to be distinct from one client's point of view, and the roles reversed from another client's point of view. For example, in the cluster file system model, a metadata server to one client might be a data server to another client. If NFSv4.1 is being used as the storage protocol, then pNFS servers need to encode the values of filehandles according to their specific roles.",
      "ja": "もう1つのシナリオは、メタデータサーバーとストレージデバイスが1つのクライアントのビューポイントとは異なるためのものであり、役割は別のクライアントのビューポイントから復元されます。たとえば、クラスタファイルシステムモデルでは、1つのクライアントへのメタデータサーバーが別のクライアントへのデータサーバーになる可能性があります。NFSv4.1がストレージプロトコルとして使用されている場合、PNFSサーバーはそれらの特定の役割に従ってファイルハンドルの値をエンコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "13.1.1. Sessions Considerations for Data Servers",
      "section_title": true,
      "ja": "13.1.1. セッションデータサーバの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 2.10.11.2 states that a client has to keep its lease renewed in order to prevent a session from being deleted by the server. If the reply to EXCHANGE_ID has just the EXCHGID4_FLAG_USE_PNFS_DS role set, then (as noted in Section 13.6) the client will not be able to determine the data server's lease_time attribute because GETATTR will not be permitted. Instead, the rule is that any time a client receives a layout referring it to a data server that returns just the EXCHGID4_FLAG_USE_PNFS_DS role, the client MAY assume that the lease_time attribute from the metadata server that returned the layout applies to the data server. Thus, the data server MUST be aware of the values of all lease_time attributes of all metadata servers for which it is providing I/O, and it MUST use the maximum of all such lease_time values as the lease interval for all client IDs and sessions established on it.",
      "ja": "セクション2.10.11.2セッションがサーバーによって削除されないようにするために、クライアントがリースを更新し続ける必要があると述べています。Exchange_idへの返信がExchgid4_flag_use_pnfs_dsロールセットだけを設定している場合、（セクション13.6に記載されているように）GetAttrは許可されないため、クライアントはデータサーバーのLEASE_TIME属性を判断できません。代わりに、クライアントがExchgid4_flag_use_pnfs_dsロールだけを返すデータサーバにクライアントがレイアウトを受信すると、クライアントは、レイアウトを返したメタデータサーバからのLEASE_TIME属性がデータサーバに適用されることを想定していることである。したがって、データサーバは、I / Oを提供しているすべてのメタデータサーバのすべてのLease_time属性の値を知っておく必要があり、それはすべてのクライアントIDとセッションのセッションのリース期間としてそのようなすべてのリース数値の最大値を使用する必要があります。その上。"
    },
    {
      "indent": 3,
      "text": "For example, if one metadata server has a lease_time attribute of 20 seconds, and a second metadata server has a lease_time attribute of 10 seconds, then if both servers return layouts that refer to an EXCHGID4_FLAG_USE_PNFS_DS-only data server, the data server MUST renew a client's lease if the interval between two SEQUENCE operations on different COMPOUND requests is less than 20 seconds.",
      "ja": "たとえば、1つのメタデータサーバに20秒のLEASE_TIME属性がある場合、2番目のメタデータサーバが10秒のLEASE_TIME属性を持ち、両方のサーバがExchgID4_FLAG_USE_PNFS_DS専用データサーバを参照するレイアウトを返す場合、データサーバは更新されなければなりません異なる複合要求に対する2つのシーケンス操作間の間隔が20秒未満の場合、クライアントのリース。"
    },
    {
      "indent": 0,
      "text": "13.2. File Layout Definitions",
      "section_title": true,
      "ja": "13.2. ファイルレイアウトの定義"
    },
    {
      "indent": 3,
      "text": "The following definitions apply to the LAYOUT4_NFSV4_1_FILES layout type and may be applicable to other layout types.",
      "ja": "次の定義は、LAYOUT4_NFSV4_1_FILESレイアウトタイプに適用され、他のレイアウトタイプにも適用できます。"
    },
    {
      "indent": 3,
      "text": "Unit. A unit is a fixed-size quantity of data written to a data server.",
      "ja": "単位。単位は、データサーバに書き込まれた固定量のデータである。"
    },
    {
      "indent": 3,
      "text": "Pattern. A pattern is a method of distributing one or more equal sized units across a set of data servers. A pattern is iterated one or more times.",
      "ja": "パターン。パターンは、一組のデータサーバにわたって1つ以上の等しいサイズのユニットを分配する方法である。パターンは1回以上繰り返されます。"
    },
    {
      "indent": 3,
      "text": "Stripe. A stripe is a set of data distributed across a set of data servers in a pattern before that pattern repeats.",
      "ja": "ストライプ。ストライプは、そのパターンが繰り返される前のパターン内の一連のデータサーバにわたって分散された一連のデータです。"
    },
    {
      "indent": 3,
      "text": "Stripe Count. A stripe count is the number of units in a pattern.",
      "ja": "ストライプ数。ストライプ数は、パターン内の単位の数です。"
    },
    {
      "indent": 3,
      "text": "Stripe Width. A stripe width is the size of a stripe in bytes. The stripe width = the stripe count * the size of the stripe unit.",
      "ja": "ストライプの幅ストライプ幅は、バイト単位のストライプのサイズです。ストライプ幅=ストライプカウント*ストライプユニットのサイズ。"
    },
    {
      "indent": 3,
      "text": "Hereafter, this document will refer to a unit that is a written in a pattern as a \"stripe unit\".",
      "ja": "以下、この文書は、「ストライプユニット」としてパターンで書かれた単位を指す。"
    },
    {
      "indent": 3,
      "text": "A pattern may have more stripe units than data servers. If so, some data servers will have more than one stripe unit per stripe. A data server that has multiple stripe units per stripe MAY store each unit in a different data file (and depending on the implementation, will possibly assign a unique data filehandle to each data file).",
      "ja": "パターンはデータサーバーよりもストライプ単位を持つことができます。もしそうであれば、一部のデータサーバはストライプごとに複数のストライプユニットを持ちます。ストライプごとに複数のストライプユニットを持つデータサーバは各ユニットを異なるデータファイルに格納することができます（そして実装に応じて、各データファイルに固有のデータファイルハンドルを割り当てる可能性があります）。"
    },
    {
      "indent": 0,
      "text": "13.3. File Layout Data Types",
      "section_title": true,
      "ja": "13.3. ファイルレイアウトデータ型"
    },
    {
      "indent": 3,
      "text": "The high level NFSv4.1 layout types are nfsv4_1_file_layouthint4, nfsv4_1_file_layout_ds_addr4, and nfsv4_1_file_layout4.",
      "ja": "高レベルのNFSV4.1レイアウトタイプは、NFSV4_1_FILE_LAYOUST4、NFSV4_1_FILE_LAYOUT_DS_ADDR4、およびNFSV4_1_FILE_LAYOUT4です。"
    },
    {
      "indent": 3,
      "text": "The SETATTR operation supports a layout hint attribute (Section 5.12.4). When the client sets a layout hint (data type layouthint4) with a layout type of LAYOUT4_NFSV4_1_FILES (the loh_type field), the loh_body field contains a value of data type nfsv4_1_file_layouthint4.",
      "ja": "setAttrオペレーションはレイアウトヒント属性をサポートしています（セクション5.12.4）。クライアントがレイアウトヒント（データ型LayouseInt4）をレイアウトタイプのレイアウトタイプ（LOH_TYPEフィールド）で設定した場合、LOH_BODYフィールドにはデータ型NFSV4_1_FILE_LAYOUTHINT4の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "const NFL4_UFLG_MASK            = 0x0000003F;\nconst NFL4_UFLG_DENSE           = 0x00000001;\nconst NFL4_UFLG_COMMIT_THRU_MDS = 0x00000002;\nconst NFL4_UFLG_STRIPE_UNIT_SIZE_MASK\n                                = 0xFFFFFFC0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef uint32_t nfl_util4;",
      "ja": "typedef uint32_t nfl_util4;"
    },
    {
      "indent": 3,
      "text": "enum filelayout_hint_care4 { NFLH4_CARE_DENSE = NFL4_UFLG_DENSE,",
      "ja": "enum filelayout_hint_care4 {nflh4_care_dense = nfl4_uflg_dense、"
    },
    {
      "indent": 11,
      "text": "NFLH4_CARE_COMMIT_THRU_MDS = NFL4_UFLG_COMMIT_THRU_MDS,",
      "ja": "NFLH4_CARE_COMMIT_THRU_MDS = NFL4_UFLG_COMMIT_THRU_MDS、"
    },
    {
      "indent": 11,
      "text": "NFLH4_CARE_STRIPE_UNIT_SIZE = 0x00000040,",
      "ja": "nflh4_care_stripe_unit_size = 0x00000040"
    },
    {
      "indent": 3,
      "text": " NFLH4_CARE_STRIPE_COUNT = 0x00000080 };",
      "ja": "NFLH4_CARE_STRIPE_COUNT = 0x00000080};"
    },
    {
      "indent": 3,
      "text": "/* Encoded in the loh_body field of data type layouthint4: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct nfsv4_1_file_layouthint4 {\n        uint32_t        nflh_care;\n        nfl_util4       nflh_util;\n        count4          nflh_stripe_count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The generic layout hint structure is described in Section 3.3.19. The client uses the layout hint in the layout_hint (Section 5.12.4) attribute to indicate the preferred type of layout to be used for a newly created file. The LAYOUT4_NFSV4_1_FILES layout-type-specific content for the layout hint is composed of three fields. The first field, nflh_care, is a set of flags indicating which values of the hint the client cares about. If the NFLH4_CARE_DENSE flag is set, then the client indicates in the second field, nflh_util, a preference for how the data file is packed (Section 13.4.4), which is controlled by the value of the expression nflh_util & NFL4_UFLG_DENSE (\"&\" represents the bitwise AND operator). If the NFLH4_CARE_COMMIT_THRU_MDS flag is set, then the client indicates a preference for whether the client should send COMMIT operations to the metadata server or data server (Section 13.7), which is controlled by the value of nflh_util & NFL4_UFLG_COMMIT_THRU_MDS. If the NFLH4_CARE_STRIPE_UNIT_SIZE flag is set, the client indicates its preferred stripe unit size, which is indicated in nflh_util & NFL4_UFLG_STRIPE_UNIT_SIZE_MASK (thus, the stripe unit size MUST be a multiple of 64 bytes). The minimum stripe unit size is 64 bytes. If the NFLH4_CARE_STRIPE_COUNT flag is set, the client indicates in the third field, nflh_stripe_count, the stripe count. The stripe count multiplied by the stripe unit size is the stripe width.",
      "ja": "一般的なレイアウトのヒント構造はセクション3.3.19に記載されています。クライアントは、LAYOUT_HINT（セクション5.12.4）属性のレイアウトヒントを使用して、新しく作成されたファイルに使用される優先レイアウトの種類を示します。レイアウトヒントのLAYOUT4_NFSV4_1_FILESレイアウトタイプ固有のコンテンツは、3つのフィールドで構成されています。最初のフィールドNFLH_CAREは、クライアントがどのようなクライアントのどの値を認識するかを示すフラグのセットです。 NFLH4_CARE_DENSEフラグが設定されている場合、クライアントは2番目のフィールド、NFLH_UTILで示されています.NFLH_UTIL＆NFL4_UFLG_DENSE（ \"＆\"の値によって制御されるデータファイル（セクション13.4.4）に設定します。ビット単位と演算子を表します）。 NFLH4_CARE_COMMIT_THRU_MDSフラグが設定されている場合、クライアントは、クライアントがMetadata ServerまたはData Server（セクション13.7）にコミット操作を送信すべきかどうかを示します。これは、NFLH_UTIL＆NFL4_UFLG_COMMIT_THRU_MDSの値によって制御されます。 NFR4_CARE_STRIPE_UNIT_SIZEフラグが設定されている場合、クライアントは、NFLH_UTIL＆NFL4_UFLG_STRIPE_UNIT_SIZE_MASKに示されている優先ストライプ単位サイズを示します（したがって、ストライプ単位サイズは64バイトの倍数でなければなりません）。最小ストライプユニットのサイズは64バイトです。 NFLH4_CARE_STRIPE_COUNTフラグが設定されている場合、クライアントは3番目のフィールド、NFLH_STRIPE_COUNT、ストライプ数を示します。ストライプ単位サイズを掛けたストライプ数はストライプ幅です。"
    },
    {
      "indent": 3,
      "text": "When LAYOUTGET returns a LAYOUT4_NFSV4_1_FILES layout (indicated in the loc_type field of the lo_content field), the loc_body field of the lo_content field contains a value of data type nfsv4_1_file_layout4. Among other content, nfsv4_1_file_layout4 has a storage device ID (field nfl_deviceid) of data type deviceid4. The GETDEVICEINFO operation maps a device ID to a storage device address (type device_addr4). When GETDEVICEINFO returns a device address with a layout type of LAYOUT4_NFSV4_1_FILES (the da_layout_type field), the da_addr_body field contains a value of data type nfsv4_1_file_layout_ds_addr4.",
      "ja": "LayoutGetがLAYOUT4_NFSV4_1_FILESレイアウト（LO_CONTENTフィールドのloc_typeフィールドに表示されている）を返すと、LO_CONTENTフィールドのloc_bodyフィールドにはデータ型NFSV4_1_FILE_LAYOUT4の値が含まれています。他のコンテンツの中でも、NFSV4_1_FILE_LAYOUT4はデータ型DeviceID4の記憶装置ID（フィールドNFL_DEVICEID）を有する。getDeviceInfoオペレーションは、デバイスIDをストレージデバイスアドレスにマッピングします（Type Device_ADDR4）。getDeviceInfoがレイアウトタイプのレイアウトタイプ（DA_LAYOUT_TYPEフィールド）でデバイスアドレスを返す場合、DA_ADDR_BODYフィールドにはデータ型NFSV4_1_FILE_LAYOUT_DS_ADDR4の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "typedef netaddr4 multipath_list4<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Encoded in the da_addr_body field of\n * data type device_addr4:\n */\nstruct nfsv4_1_file_layout_ds_addr4 {\n        uint32_t        nflda_stripe_indices<>;\n        multipath_list4 nflda_multipath_ds_list<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The nfsv4_1_file_layout_ds_addr4 data type represents the device address. It is composed of two fields:",
      "ja": "NFSV4_1_FILE_LAYOUT_DS_ADDR4データ型はデバイスアドレスを表します。2つのフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. nflda_multipath_ds_list: An array of lists of data servers, where each list can be one or more elements, and each element represents a data server address that may serve equally as the target of I/O operations (see Section 13.5). The length of this array might be different than the stripe count.",
      "ja": "1. NFLDA_MULTIPATH_DS_LIST：各リストは1つ以上の要素になることができ、各要素はI / O操作のターゲットと同じように機能する可能性があるデータサーバーアドレスを表します（セクション13.5を参照）。この配列の長さはストライプ数とは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "2. nflda_stripe_indices: An array of indices used to index into nflda_multipath_ds_list. The value of each element of nflda_stripe_indices MUST be less than the number of elements in nflda_multipath_ds_list. Each element of nflda_multipath_ds_list SHOULD be referred to by one or more elements of nflda_stripe_indices. The number of elements in nflda_stripe_indices is always equal to the stripe count.",
      "ja": "2. NFLDA_STRIPE_INDICES：NFLDA_MULTIPATH_LISTに索引付けするために使用されるインデックスの配列。nflda_stripe_indicesの各要素の値は、nflda_multipath_ds_list内の要素数より小さくなければなりません。nflda_multipath_ds_listの各要素は、nflda_stripe_indicesの1つ以上の要素によって参照されるべきです。nflda_stripe_indicesの要素数は常にストライプ数に等しいです。"
    },
    {
      "indent": 3,
      "text": "/*\n * Encoded in the loc_body field of\n * data type layout_content4:\n */\nstruct nfsv4_1_file_layout4 {\n         deviceid4      nfl_deviceid;\n         nfl_util4      nfl_util;\n         uint32_t       nfl_first_stripe_index;\n         offset4        nfl_pattern_offset;\n         nfs_fh4        nfl_fh_list<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The nfsv4_1_file_layout4 data type represents the layout. It is composed of the following fields:",
      "ja": "NFSV4_1_FILE_LAYOUT4データ型はレイアウトを表します。次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. nfl_deviceid: The device ID that maps to a value of type nfsv4_1_file_layout_ds_addr4.",
      "ja": "1. NFL_DEVICEID：タイプNFSV4_1_FILE_LAYOUT_DS_DDR4の値にマッピングされるデバイスID。"
    },
    {
      "indent": 3,
      "text": "2. nfl_util: Like the nflh_util field of data type nfsv4_1_file_layouthint4, a compact representation of how the data on a file on each data server is packed, whether the client should send COMMIT operations to the metadata server or data server, and the stripe unit size. If a server returns two or more overlapping layouts, each stripe unit size in each overlapping layout MUST be the same.",
      "ja": "2. NFL_UTIL：データ型NFSV4_1_FILE_LAYOUST4のNFLH_UTILフィールドのように、各データサーバ上のファイル上のデータがどのようにパックされるかのコンパクトな表現、クライアントがメタデータサーバまたはデータサーバにコミット操作を送信するか、ストライプ単位サイズであるかどうかのコンパクトな表現。サーバーが2つ以上の重複レイアウトを返す場合、各重複レイアウトの各ストライプ単位サイズは同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "3. nfl_first_stripe_index: The index into the first element of the nflda_stripe_indices array to use.",
      "ja": "3. NFL_FIRST_STRIPE_INDEX：使用するNFLDA_Stripe_Indices配列の最初の要素へのインデックス。"
    },
    {
      "indent": 3,
      "text": "4. nfl_pattern_offset: This field is the logical offset into the file where the striping pattern starts. It is required for converting the client's logical I/O offset (e.g., the current offset in a POSIX file descriptor before the read() or write() system call is sent) into the stripe unit number (see Section 13.4.1).",
      "ja": "4. nft_pattern_offset：このフィールドは、ストライピングパターンが起動したファイルへの論理オフセットです。クライアントの論理I / Oオフセット（例えば、読み取り（）またはwrite（）システムコールが送信される前のPOSIXファイル記述子の現在のオフセット）をストライプユニット番号に変換する必要があります（セクション13.4.1を参照）。"
    },
    {
      "indent": 7,
      "text": "If dense packing is used, then nfl_pattern_offset is also needed to convert the client's logical I/O offset to an offset on the file on the data server corresponding to the stripe unit number (see Section 13.4.4).",
      "ja": "密集した梱包が使用されている場合、NFL_Pattern_Offsetは、クライアントの論理I / Oオフセットをストライプユニット番号に対応するデータサーバ上のファイル上のオフセットに変換するためにも必要です（セクション13.4.4を参照）。"
    },
    {
      "indent": 7,
      "text": "Note that nfl_pattern_offset is not always the same as lo_offset. For example, via the LAYOUTGET operation, a client might request a layout starting at offset 1000 of a file that has its striping pattern start at offset zero.",
      "ja": "nfl_pattern_offsetがlo_offsetと必ずしも同じではありません。例えば、レイアウト操作を介して、クライアントは、そのストライピングパターンがオフセットゼロで開始されたファイルのオフセット1000から始まるレイアウトを要求することができる。"
    },
    {
      "indent": 3,
      "text": "5. nfl_fh_list: An array of data server filehandles for each list of data servers in each element of the nflda_multipath_ds_list array. The number of elements in nfl_fh_list depends on whether sparse or dense packing is being used.",
      "ja": "5. NFL_FH_LIST：NFLDA_MULTIPATH_LISTアレイの各要素内のデータサーバの各リストに対するデータサーバファイルハンドルの配列。nfl_fh_list内の要素数は、スパースまたは密集したパッキングが使用されているかどうかによって異なります。"
    },
    {
      "indent": 7,
      "text": "* If sparse packing is being used, the number of elements in nfl_fh_list MUST be one of three values:",
      "ja": "* スパースパッキングが使用されている場合、nfl_fh_list内の要素数は3つの値の1つである必要があります。"
    },
    {
      "indent": 10,
      "text": "- Zero. This means that filehandles used for each data server are the same as the filehandle returned by the OPEN operation from the metadata server.",
      "ja": "- ゼロ。つまり、各データサーバーに使用されているファイルハンドルは、メタデータサーバーからのオープン操作によって返されたFileHandleと同じです。"
    },
    {
      "indent": 10,
      "text": "- One. This means that every data server uses the same filehandle: what is specified in nfl_fh_list[0].",
      "ja": "- 1。つまり、すべてのデータサーバが同じファイルハンドルを使用していることを意味します.NFL_FH_LIST [0]で指定されているもの。"
    },
    {
      "indent": 10,
      "text": "- The same number of elements in nflda_multipath_ds_list. Thus, in this case, when sending an I/O operation to any data server in nflda_multipath_ds_list[X], the filehandle in nfl_fh_list[X] MUST be used.",
      "ja": "- nflda_multipath_ds_listの同じ要素数。したがって、この場合、nflda_multipath_ds_list [x]でI / O操作を任意のデータサーバに送信する際には、nfl_fh_list [x]のファイルハンドルを使用する必要があります。"
    },
    {
      "indent": 10,
      "text": "See the discussion on sparse packing in Section 13.4.4.",
      "ja": "セクション13.4.4のスパースパッキングに関する説明を参照してください。"
    },
    {
      "indent": 7,
      "text": "* If dense packing is being used, the number of elements in nfl_fh_list MUST be the same as the number of elements in nflda_stripe_indices. Thus, when sending an I/O operation to any data server in nflda_multipath_ds_list[nflda_stripe_indices[Y]], the filehandle in nfl_fh_list[Y] MUST be used. In addition, any time there exists i and j, (i != j), such that the intersection of nflda_multipath_ds_list[nflda_stripe_indices[i]] and nflda_multipath_ds_list[nflda_stripe_indices[j]] is not empty, then nfl_fh_list[i] MUST NOT equal nfl_fh_list[j]. In other words, when dense packing is being used, if a data server appears in two or more units of a striping pattern, each reference to the data server MUST use a different filehandle.",
      "ja": "* 密集した梱包が使用されている場合、nfl_fh_list内の要素数はnflda_stripe_indicesの要素数と同じでなければなりません。したがって、nflda_multipath_ds_list [nflda_stripe_indices [y]]のデータサーバにI / O操作を送信する際には、nfl_fh_list [y]のファイルハンドルを使用する必要があります。さらに、nflda_multipath_ds_list [nflda_stripe_indices [i]]とnflda_stripe_indices [j]]の交差点が空でないように、iとj、（i！= j）が存在するときはいつでも存在する。nfl_fh_list [j]。言い換えれば、密集した梱包が使用されているとき、データサーバがストライピングパターンの2つ以上の単位で現れると、データサーバへの各参照は別のファイルハンドルを使用する必要があります。"
    },
    {
      "indent": 10,
      "text": "Indeed, if there are multiple striping patterns, as indicated by the presence of multiple objects of data type layout4 (either returned in one or multiple LAYOUTGET operations), and a data server is the target of a unit of one pattern and another unit of another pattern, then each reference to each data server MUST use a different filehandle.",
      "ja": "実際、データ型レイアウト4の複数のオブジェクトの存在（1つまたは複数のレイアウト操作で返された）とデータサーバが1つのパターンの単位のターゲットと別の単位のターゲットのターゲットである場合、複数のストライピングパターンがある場合パターン、各データサーバーへの各参照は別のファイルハンドルを使用する必要があります。"
    },
    {
      "indent": 10,
      "text": "See the discussion on dense packing in Section 13.4.4.",
      "ja": "セクション13.4.4の密集した梱包に関する説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "The details on the interpretation of the layout are in Section 13.4.",
      "ja": "レイアウトの解釈に関する詳細はセクション13.4です。"
    },
    {
      "indent": 0,
      "text": "13.4. Interpreting the File Layout",
      "section_title": true,
      "ja": "13.4. ファイルレイアウトの解釈"
    },
    {
      "indent": 0,
      "text": "13.4.1. Determining the Stripe Unit Number",
      "section_title": true,
      "ja": "13.4.1. ストライプユニット番号の決定"
    },
    {
      "indent": 3,
      "text": "To find the stripe unit number that corresponds to the client's logical file offset, the pattern offset will also be used. The i'th stripe unit (SUi) is:",
      "ja": "クライアントの論理ファイルオフセットに対応するストライプユニット番号を見つけるには、パターンオフセットも使用されます。i番目のストライプユニット（SUI）は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "relative_offset = file_offset - nfl_pattern_offset;\nSUi = floor(relative_offset / stripe_unit_size);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.4.2. Interpreting the File Layout Using Sparse Packing",
      "section_title": true,
      "ja": "13.4.2. スパースパッキングを使用してファイルレイアウトの解釈"
    },
    {
      "indent": 3,
      "text": "When sparse packing is used, the algorithm for determining the filehandle and set of data-server network addresses to write stripe unit i (SUi) to is:",
      "ja": "スパースパッキングが使用される場合、ストライプユニットI（SUI）を書き込むためのファイルハンドルおよびデータサーバネットワークアドレスのセットを決定するためのアルゴリズム。"
    },
    {
      "indent": 6,
      "text": "stripe_count = number of elements in nflda_stripe_indices;",
      "ja": "stripe_count = nflda_stripe_indicesの要素数。"
    },
    {
      "indent": 6,
      "text": "j = (SUi + nfl_first_stripe_index) % stripe_count;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[j];",
      "ja": "idx = nflda_stripe_indices [j];"
    },
    {
      "indent": 6,
      "text": "fh_count = number of elements in nfl_fh_list;\nds_count = number of elements in nflda_multipath_ds_list;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "switch (fh_count) {\n  case ds_count:\n    fh = nfl_fh_list[idx];\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "case 1:\n  fh = nfl_fh_list[0];\n  break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "case 0:\n  fh = filehandle returned by OPEN;\n  break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "  default:\n    throw a fatal exception;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "address_list = nflda_multipath_ds_list[idx];",
      "ja": "address_list = nflda_multipath_ds_list [idx];"
    },
    {
      "indent": 3,
      "text": "The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.",
      "ja": "その後、クライアントはaddress_listからデータサーバを選択し、FHで指定されたFileHandleを使用して読み取りまたは書き込み操作を送信します。"
    },
    {
      "indent": 3,
      "text": "Consider the following example:",
      "ja": "次の例を考慮してください。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:",
      "ja": "3当量で配置された7つのデータサーバからなるデバイスアドレスがあるとします（セクション13.5）クラス："
    },
    {
      "indent": 6,
      "text": "{ A, B, C, D }, { E }, { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where A through G are network addresses.",
      "ja": "aからgはネットワークアドレスです。"
    },
    {
      "indent": 3,
      "text": "Then",
      "ja": "それから"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "i.e.,",
      "ja": "すなわち、"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[2] = { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suppose the striping index array is:",
      "ja": "ストライピングインデックスアレイが次のとおりとします。"
    },
    {
      "indent": 6,
      "text": "nflda_stripe_indices<> = { 2, 0, 1, 0 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains",
      "ja": "これで、クライアントが上記のデバイスアドレスにマッピングされるデバイスIDを持つレイアウトを取得します。初期インデックスに含まれています"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2,",
      "ja": "NFL_FIRST_STRIPE_INDEX = 2、"
    },
    {
      "indent": 3,
      "text": "and the filehandle list is",
      "ja": "そしてファイルハンドルリスト"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list = { 0x36, 0x87, 0x67 }.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the client wants to write to SU0, the set of valid { network address, filehandle } combinations for SUi are determined by:",
      "ja": "クライアントがSU0に書き込みたい場合は、SUIの有効な{ネットワークアドレス、FileHandle}の組み合わせのセットが次のように決定されます。"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "そう"
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[(0 + 2) % 4]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "= nflda_stripe_indices[2]",
      "ja": "= nflda_stripe_indices [2]"
    },
    {
      "indent": 9,
      "text": "= 1",
      "ja": "= 1"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "そう"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list[1] = { 0x87 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client can thus write SU0 to { 0x87, { E } }.",
      "ja": "したがって、クライアントはSU0を{0x87、{E}}に書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "The destinations of the first 13 storage units are:",
      "ja": "最初の13の記憶装置の目的地は次のとおりです。"
    },
    {
      "indent": 20,
      "text": "+=====+============+==============+\n| SUi | filehandle | data servers |\n+=====+============+==============+\n| 0   | 87         | E            |\n+-----+------------+--------------+\n| 1   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 2   | 67         | F,G          |\n+-----+------------+--------------+\n| 3   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 4   | 87         | E            |\n+-----+------------+--------------+\n| 5   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 6   | 67         | F,G          |\n+-----+------------+--------------+\n| 7   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 8   | 87         | E            |\n+-----+------------+--------------+\n| 9   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 10  | 67         | F,G          |\n+-----+------------+--------------+\n| 11  | 36         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 12  | 87         | E            |\n+-----+------------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 9",
      "ja": "表9."
    },
    {
      "indent": 0,
      "text": "13.4.3. Interpreting the File Layout Using Dense Packing",
      "section_title": true,
      "ja": "13.4.3. 密なパッキングを使用したファイルレイアウトの解釈"
    },
    {
      "indent": 3,
      "text": "When dense packing is used, the algorithm for determining the filehandle and set of data server network addresses to write stripe unit i (SUi) to is:",
      "ja": "密集した梱包が使用されるとき、ストライプユニットi（SUI）を書くためにファイルハンドルとデータサーバネットワークアドレスのセットを決定するためのアルゴリズムは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "stripe_count = number of elements in nflda_stripe_indices;",
      "ja": "stripe_count = nflda_stripe_indicesの要素数。"
    },
    {
      "indent": 6,
      "text": "j = (SUi + nfl_first_stripe_index) % stripe_count;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[j];",
      "ja": "idx = nflda_stripe_indices [j];"
    },
    {
      "indent": 6,
      "text": "fh_count = number of elements in nfl_fh_list;\nds_count = number of elements in nflda_multipath_ds_list;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "switch (fh_count) {\n  case stripe_count:\n    fh = nfl_fh_list[j];\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "  default:\n    throw a fatal exception;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "address_list = nflda_multipath_ds_list[idx];",
      "ja": "address_list = nflda_multipath_ds_list [idx];"
    },
    {
      "indent": 3,
      "text": "The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.",
      "ja": "その後、クライアントはaddress_listからデータサーバを選択し、FHで指定されたFileHandleを使用して読み取りまたは書き込み操作を送信します。"
    },
    {
      "indent": 3,
      "text": "Consider the following example (which is the same as the sparse packing example, except for the filehandle list):",
      "ja": "次の例（ファイルハンドルリストを除く、スパースパッキングの例と同じ）を考えます。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:",
      "ja": "3当量で配置された7つのデータサーバからなるデバイスアドレスがあるとします（セクション13.5）クラス："
    },
    {
      "indent": 6,
      "text": "{ A, B, C, D }, { E }, { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where A through G are network addresses.",
      "ja": "aからgはネットワークアドレスです。"
    },
    {
      "indent": 3,
      "text": "Then",
      "ja": "それから"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "i.e.,",
      "ja": "すなわち、"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[2] = { F, G }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suppose the striping index array is:",
      "ja": "ストライピングインデックスアレイが次のとおりとします。"
    },
    {
      "indent": 6,
      "text": "nflda_stripe_indices<> = { 2, 0, 1, 0 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains",
      "ja": "これで、クライアントが上記のデバイスアドレスにマッピングされるデバイスIDを持つレイアウトを取得します。初期インデックスに含まれています"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2,",
      "ja": "NFL_FIRST_STRIPE_INDEX = 2、"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list = { 0x67, 0x37, 0x87, 0x36 }.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The interesting examples for dense packing are SU1 and SU3 because each stripe unit refers to the same data server list, yet each stripe unit MUST use a different filehandle. If the client wants to write to SU1, the set of valid { network address, filehandle } combinations for SUi are determined by:",
      "ja": "各ストライプユニットは同じデータサーバリストを参照しているので、密集梱包の興味深い例はSU1およびSU3であるが、各ストライプユニットは別のファイルハンドルを使用しなければならない。クライアントがSU1に書き込みたい場合は、有効な{ネットワークアドレス、FileHandle} SUIの組み合わせのセットが次のように決定されます。"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "そう"
    },
    {
      "indent": 6,
      "text": "j = (1 + 2) % 4 = 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "idx = nflda_stripe_indices[j]",
      "ja": "IDX = NFLDA_STRIPE_INDICES [j]"
    },
    {
      "indent": 9,
      "text": "= nflda_stripe_indices[3]",
      "ja": "= nflda_stripe_indices [3]"
    },
    {
      "indent": 9,
      "text": "= 0",
      "ja": "= 0"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "そう"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list[3] = { 0x36 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client can thus write SU1 to { 0x36, { A, B, C, D } }.",
      "ja": "したがって、クライアントはSU1を{0x36、{a、b、c、d}}に書き込むことができる。"
    },
    {
      "indent": 3,
      "text": "For SU3, j = (3 + 2) % 4 = 1, and nflda_stripe_indices[1] = 0.  Then\nnflda_multipath_ds_list[0] = { A, B, C, D }, and nfl_fh_list[1] =\n0x37.  The client can thus write SU3 to { 0x37, { A, B, C, D } }.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The destinations of the first 13 storage units are:",
      "ja": "最初の13の記憶装置の目的地は次のとおりです。"
    },
    {
      "indent": 20,
      "text": "+=====+============+==============+\n| SUi | filehandle | data servers |\n+=====+============+==============+\n| 0   | 87         | E            |\n+-----+------------+--------------+\n| 1   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 2   | 67         | F,G          |\n+-----+------------+--------------+\n| 3   | 37         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 4   | 87         | E            |\n+-----+------------+--------------+\n| 5   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 6   | 67         | F,G          |\n+-----+------------+--------------+\n| 7   | 37         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 8   | 87         | E            |\n+-----+------------+--------------+\n| 9   | 36         | A,B,C,D      |\n+-----+------------+--------------+\n| 10  | 67         | F,G          |\n+-----+------------+--------------+\n| 11  | 37         | A,B,C,D      |\n+-----+------------+--------------+\n+-----+------------+--------------+\n| 12  | 87         | E            |\n+-----+------------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 10",
      "ja": "表10."
    },
    {
      "indent": 0,
      "text": "13.4.4. Sparse and Dense Stripe Unit Packing",
      "section_title": true,
      "ja": "13.4.4. スパースと密なストライプユニットの梱包"
    },
    {
      "indent": 3,
      "text": "The flag NFL4_UFLG_DENSE of the nfl_util4 data type (field nflh_util of the data type nfsv4_1_file_layouthint4 and field nfl_util of data type nfsv4_1_file_layout_ds_addr4) specifies how the data is packed within the data file on a data server. It allows for two different data packings: sparse and dense. The packing type determines the calculation that will be made to map the client-visible file offset to the offset within the data file located on the data server.",
      "ja": "NFL_UTIL4データ型のフラグNFL4_UFLG_DENSE（データ型NFSV4_1_FILE_LAYOUTHINT4、およびデータ型のフィールドNFL_UTILのフィールドNFL_UTIL）データサーバ上のデータファイル内にデータがパックされる方法を指定します。それは2つの異なるデータパッキングを可能にします：スパースと濃い。パッキングタイプは、クライアント可視ファイルオフセットをデータサーバ上にあるデータファイル内のオフセットにマッピングするようにする計算を決定します。"
    },
    {
      "indent": 3,
      "text": "If nfl_util & NFL4_UFLG_DENSE is zero, this means that sparse packing is being used. Hence, the logical offsets of the file as viewed by a client sending READs and WRITEs directly to the metadata server are the same offsets each data server uses when storing a stripe unit. The effect then, for striping patterns consisting of at least two stripe units, is for each data server file to be sparse or \"holey\". So for example, suppose there is a pattern with three stripe units, the stripe unit size is 4096 bytes, and there are three data servers in the pattern. Then, the file in data server 1 will have stripe units 0, 3, 6, 9, ... filled; data server 2's file will have stripe units 1, 4, 7, 10, ... filled; and data server 3's file will have stripe units 2, 5, 8, 11, ... filled. The unfilled stripe units of each file will be holes; hence, the files in each data server are sparse.",
      "ja": "NFL_UTIL＆NFL4_UFLG_DENSEがゼロの場合、これはスパースパッキングが使用されていることを意味します。したがって、クライアントが読み取りを送信してメタデータサーバへの直接書き込みを送信するファイルの論理オフセットは、ストライプユニットを格納するときに各データサーバが使用するのと同じオフセットです。その場合、少なくとも2つのストライプユニットからなるストライピングパターンの場合、各データサーバーファイルがスパースまたは「ホーリー」になることです。したがって、たとえば、3つのストライプ単位のパターンがあるとします。ストライプ単位のサイズは4096バイトで、パターンには3つのデータサーバーがあります。その後、データサーバ1内のファイルはストライプユニット0,3,6,9、...が充填されている。データサーバ2のファイルはストライプユニット1,4,7,10、...が充填されます。データサーバ3のファイルには、ストライプユニット2,5,8,11、...がいっぱいになります。各ファイルの充填されていないストライプ単位は穴になります。したがって、各データサーバーのファイルはスパースです。"
    },
    {
      "indent": 3,
      "text": "If sparse packing is being used and a client attempts I/O to one of the holes, then an error MUST be returned by the data server. Using the above example, if data server 3 received a READ or WRITE operation for block 4, the data server would return NFS4ERR_PNFS_IO_HOLE. Thus, data servers need to understand the striping pattern in order to support sparse packing.",
      "ja": "スパースパッキングが使用されており、クライアントがいずれかの穴にI / Oを試行している場合、エラーはデータサーバによって返されなければならない。上記の例を使用して、データサーバ3がブロック4の読み取りまたは書き込み動作を受信した場合、データサーバはNFS4R_PNFS_IO_HOLEを返す。したがって、データサーバは、スパースパッキングをサポートするためにストライピングパターンを理解する必要がある。"
    },
    {
      "indent": 3,
      "text": "If nfl_util & NFL4_UFLG_DENSE is one, this means that dense packing is being used, and the data server files have no holes. Dense packing might be selected because the data server does not (efficiently) support holey files or because the data server cannot recognize read-ahead unless there are no holes. If dense packing is indicated in the layout, the data files will be packed. Using the same striping pattern and stripe unit size that were used for the sparse packing example, the corresponding dense packing example would have all stripe units of all data files filled as follows:",
      "ja": "NFL_UTIL＆NFL4_UFLG_DENSEが1つである場合、これは密集したパッキングが使用されていることを意味し、データサーバーファイルには穴がありません。データサーバがホーリーファイルをサポートしていないため、またはデータサーバが穴がない限り読み上げを認識できないため、濃密なパッキングを選択することができます。レイアウトに密集したパッキングが表示されている場合、データファイルはパックされます。スパースパッキングの例に使用されたのと同じストライピングパターンとストライプユニットサイズを使用して、対応する密なパッキングの例はすべてのデータファイルのすべてのストライプ単位を次のようにいただきます。"
    },
    {
      "indent": 3,
      "text": "* Logical stripe units 0, 3, 6, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 1.",
      "ja": "* ファイルの論理ストライプユニット0,3,6、...は、データサーバ1のファイルのストライプユニット0,1,2、...に生きるであろう。"
    },
    {
      "indent": 3,
      "text": "* Logical stripe units 1, 4, 7, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 2.",
      "ja": "* ファイルの論理ストライプユニット1,4,7、...は、データサーバ2のファイルのストライプユニット0,1,2、...に生きるであろう。"
    },
    {
      "indent": 3,
      "text": "* Logical stripe units 2, 5, 8, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 3.",
      "ja": "* ファイルの論理ストライプユニット2,5,8、...は、データサーバ3のファイルのストライプユニット0,1,2、...に生きるであろう。"
    },
    {
      "indent": 3,
      "text": "Because dense packing does not leave holes on the data servers, the pNFS client is allowed to write to any offset of any data file of any data server in the stripe. Thus, the data servers need not know the file's striping pattern.",
      "ja": "密集したパッキングはデータサーバに穴を離れないので、PNFSクライアントはストライプ内の任意のデータサーバのデータファイルの任意のオフセットに書き込むことが許可されています。したがって、データサーバーはファイルのストライピングパターンを知る必要はありません。"
    },
    {
      "indent": 3,
      "text": "The calculation to determine the byte offset within the data file for dense data server layouts is:",
      "ja": "Dense Data Serverレイアウトのデータファイル内のバイトオフセットを決定するための計算は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "stripe_width = stripe_unit_size * N; where N = number of elements in nflda_stripe_indices.",
      "ja": "stripe_width = stripe_unit_size * n;n = nflda_stripe_indicesの要素数。"
    },
    {
      "indent": 6,
      "text": "relative_offset = file_offset - nfl_pattern_offset;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "data_file_offset = floor(relative_offset / stripe_width)\n   * stripe_unit_size\n   + relative_offset % stripe_unit_size",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If dense packing is being used, and a data server appears more than once in a striping pattern, then to distinguish one stripe unit from another, the data server MUST use a different filehandle. Let's suppose there are two data servers. Logical stripe units 0, 3, 6 are served by data server 1; logical stripe units 1, 4, 7 are served by data server 2; and logical stripe units 2, 5, 8 are also served by data server 2. Unless data server 2 has two filehandles (each referring to a different data file), then, for example, a write to logical stripe unit 1 overwrites the write to logical stripe unit 2 because both logical stripe units are located in the same stripe unit (0) of data server 2.",
      "ja": "密集した梱包が使用されている場合、データサーバーがストライピングパターンで複数回表示され、1つのストライプユニットを別のストライプユニットと区別するために、データサーバーは別のファイルハンドルを使用する必要があります。2つのデータサーバーがあるとしましょう。論理ストライプユニット0,3,6はデータサーバ1によって提供される。論理ストライプユニット1,4,7はデータサーバ2によって提供される。そして、論理ストライプユニット2,5,8もデータサーバ2によって提供される。データサーバ2には2つのファイルハンドルがある（それぞれ異なるデータファイルを参照）、例えば論理ストライプユニット1への書き込みが書き込みを上書きする。論理ストライプユニット2は、両方の論理ストライプユニットがデータサーバ2の同じストライプユニット（0）内に配置されているため。"
    },
    {
      "indent": 0,
      "text": "13.5. Data Server Multipathing",
      "section_title": true,
      "ja": "13.5. データサーバマルチパス"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 file layout supports multipathing to multiple data server addresses. Data-server-level multipathing is used for bandwidth scaling via trunking (Section 2.10.5) and for higher availability of use in the case of a data-server failure. Multipathing allows the client to switch to another data server address which may be that of another data server that is exporting the same data stripe unit, without having to contact the metadata server for a new layout.",
      "ja": "NFSv4.1ファイルレイアウトは、複数のデータサーバアドレスへのマルチパスをサポートしています。データサーバレベルのマルチパスは、トランキング（セクション2.10.5）を介した帯域幅スケーリング、およびデータサーバ障害の場合の使用の可用性を高めるために使用されます。マルチパスを使用すると、クライアントは新しいレイアウトのためにメタデータサーバに連絡する必要なしに、同じデータストライプユニットをエクスポートしている別のデータサーバの他のデータサーバアドレスに切り替えることができる。"
    },
    {
      "indent": 3,
      "text": "To support data server multipathing, each element of the nflda_multipath_ds_list contains an array of one more data server network addresses. This array (data type multipath_list4) represents a list of data servers (each identified by a network address), with the possibility that some data servers will appear in the list multiple times.",
      "ja": "データサーバマルチパスをサポートするために、nflda_multipath_ds_listの各要素には、1つのデータサーバネットワークアドレスの配列が含まれています。この配列（データ型MULTIPATH_LIST4）は、一部のデータサーバがリストに複数回表示される可能性を持ち、データサーバのリスト（ネットワークアドレスによって識別された）のリストを表します。"
    },
    {
      "indent": 3,
      "text": "The client is free to use any of the network addresses as a destination to send data server requests. If some network addresses are less optimal paths to the data than others, then the MDS SHOULD NOT include those network addresses in an element of nflda_multipath_ds_list. If less optimal network addresses exist to provide failover, the RECOMMENDED method to offer the addresses is to provide them in a replacement device-ID-to-device-address mapping, or a replacement device ID. When a client finds that no data server in an element of nflda_multipath_ds_list responds, it SHOULD send a GETDEVICEINFO to attempt to replace the existing device-ID-to-device-address mappings. If the MDS detects that all data servers represented by an element of nflda_multipath_ds_list are unavailable, the MDS SHOULD send a CB_NOTIFY_DEVICEID (if the client has indicated it wants device ID notifications for changed device IDs) to change the device-ID-to-device-address mappings to the available data servers. If the device ID itself will be replaced, the MDS SHOULD recall all layouts with the device ID, and thus force the client to get new layouts and device ID mappings via LAYOUTGET and GETDEVICEINFO.",
      "ja": "クライアントは、データサーバー要求を送信するために宛先としていずれかのネットワークアドレスを使用できます。ネットワークアドレスが他のネットワークアドレスがデータへの最適なパスではない場合、MDSはNFLDA_MULTIPATH_LISTの要素にそれらのネットワークアドレスを含めないでください。フェイルオーバーを提供するための最適なネットワークアドレスが存在しない場合、アドレスを提供するための推奨される方法は、それらを交換用のデバイスID-ID-Addressマッピング、または置換装置IDに提供することです。クライアントがNFLDA_MULTIPATH_DS_LISTの要素にデータサーバが応答しないことを検索すると、既存のデバイスID  -  ID  -  DEVICEアドレスマッピングの置き換えを試みるためにgetDeviceInfoを送信する必要があります。 MDSがNFLDA_MULTIPATH_SDS_LISTの要素によって表されるすべてのデータサーバが使用不可であることを検出した場合、MDSはCB_NOTIFY_DEVICEIDを送信する必要があります（クライアントが変更されたデバイスIDのデバイスID通知を求めている場合）デバイスID-to-Device-を変更する必要があります。利用可能なデータサーバーへのアドレスマッピング。デバイスID自体が置き換えられると、MDSはデバイスIDを使用してすべてのレイアウトを呼び出し、したがって、クライアントにLayoutGetとGetDeviceInfoを介して新しいレイアウトとデバイスIDマッピングを強制します。"
    },
    {
      "indent": 3,
      "text": "Generally, if two network addresses appear in an element of nflda_multipath_ds_list, they will designate the same data server, and the two data server addresses will support the implementation of client ID or session trunking (the latter is RECOMMENDED) as defined in Section 2.10.5. The two data server addresses will share the same server owner or major ID of the server owner. It is not always necessary for the two data server addresses to designate the same server with trunking being used. For example, the data could be read-only, and the data consist of exact replicas.",
      "ja": "一般に、2つのネットワークアドレスがNFLDA_MULTIPATH_DS_LISTの要素に表示される場合、それらは同じデータサーバを指定し、2つのデータサーバアドレスは、セクション2.10.5で定義されているように、クライアントIDまたはセッショントランキングの実装をサポートする（後者が推奨される）。。2つのデータサーバーアドレスは、サーバー所有者の同じサーバーの所有者または主要IDを共有します。2つのデータサーバーアドレスが使用されているのと同じサーバーを指定するためには必ずしも必要ではありません。たとえば、データは読み取り専用であり、データは正確なレプリカで構成されています。"
    },
    {
      "indent": 0,
      "text": "13.6. Operations Sent to NFSv4.1 Data Servers",
      "section_title": true,
      "ja": "13.6. NFSv4.1データサーバに送信された操作"
    },
    {
      "indent": 3,
      "text": "Clients accessing data on an NFSv4.1 data server MUST send only the NULL procedure and COMPOUND procedures whose operations are taken only from two restricted subsets of the operations defined as valid NFSv4.1 operations. Clients MUST use the filehandle specified by the layout when accessing data on NFSv4.1 data servers.",
      "ja": "NFSV4.1データサーバ上のデータにアクセスするクライアントは、有効なNFSV4.1操作として定義された操作の2つの制限付きサブセットからのみ取られるNULLプロシージャと複合プロシージャのみを送信する必要があります。クライアントは、NFSV4.1データサーバのデータにアクセスするときにレイアウトで指定されたファイルハンドルを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The first of these operation subsets consists of management operations. This subset consists of the BACKCHANNEL_CTL, BIND_CONN_TO_SESSION, CREATE_SESSION, DESTROY_CLIENTID, DESTROY_SESSION, EXCHANGE_ID, SECINFO_NO_NAME, SET_SSV, and SEQUENCE operations. The client may use these operations in order to set up and maintain the appropriate client IDs, sessions, and security contexts involved in communication with the data server. Henceforth, these will be referred to as data-server housekeeping operations.",
      "ja": "これらの操作サブセットの最初のものは、管理操作で構成されています。このサブセットは、backchannel_ctl、bind_conn_to_session、create_session、destroy_clientid、destroy_session、exchange_id、secinfo_no_name、set_ssv、およびsequence操作で構成されています。クライアントは、データサーバとの通信に関与する適切なクライアントID、セッション、およびセキュリティコンテキストを設定および管理するためにこれらの操作を使用することができる。以降、これらはデータサーバーのハウスキーピング操作と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The second subset consists of COMMIT, READ, WRITE, and PUTFH. These operations MUST be used with a current filehandle specified by the layout. In the case of PUTFH, the new current filehandle MUST be one taken from the layout. Henceforth, these will be referred to as data-server I/O operations. As described in Section 12.5.1, a client MUST NOT send an I/O to a data server for which it does not hold a valid layout; the data server MUST reject such an I/O.",
      "ja": "2番目のサブセットは、コミット、読み取り、書き込み、およびPUTFHで構成されています。これらの操作は、レイアウトで指定された現在のファイルハンドルで使用する必要があります。putfhの場合、新しい現在のファイルハンドルはレイアウトから取られている必要があります。以降、これらはデータサーバのI / O操作と呼ばれる。セクション12.5.1で説明されているように、クライアントは有効なレイアウトを保持していないデータサーバにI / Oを送信してはいけません。データサーバーはそのようなI / Oを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless the server has a concurrent non-data-server personality -- i.e., EXCHANGE_ID results returned (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_PNFS_MDS) or (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS) see Section 13.1 -- any attempted use of operations against a data server other than those specified in the two subsets above MUST return NFS4ERR_NOTSUPP to the client.",
      "ja": "サーバーに並行していない非データサーバーパーソナリティがない限り、exchange_idの結果が返されます（exchgid4_flag_use_pnfs_ds"
    },
    {
      "indent": 3,
      "text": "When the server has concurrent data-server and non-data-server personalities, each COMPOUND sent by the client MUST be constructed so that it is appropriate to one of the two personalities, and it MUST NOT contain operations directed to a mix of those personalities. The server MUST enforce this. To understand the constraints, operations within a COMPOUND are divided into the following three classes:",
      "ja": "サーバーに並行データサーバーとデータサーバーのパーソナリティがある場合は、クライアントによって送信された各化合物を2つの個性の1つに適しているように構築する必要があります。。サーバーはこれを強制する必要があります。制約を理解するために、化合物内の操作は次の3つのクラスに分けられます。"
    },
    {
      "indent": 3,
      "text": "1. An operation that is ambiguous regarding its personality assignment. This includes all of the data-server housekeeping operations. Additionally, if the server has assigned filehandles so that the ones defined by the layout are the same as those used by the metadata server, all operations using such filehandles are within this class, with the following exception. The exception is that if the operation uses a stateid that is incompatible with a data-server personality (e.g., a special stateid or the stateid has a non-zero \"seqid\" field, see Section 13.9.1), the operation is in class 3, as described below. A COMPOUND containing multiple class 1 operations (and operations of no other class) MAY be sent to a server with multiple concurrent data server and non-data-server personalities.",
      "ja": "1. 性格割り当てに関してあいまいな操作。これには、すべてのデータサーバーのハウスキーピング操作が含まれます。さらに、レイアウトによって定義されたものがMetadata Serverによって使用されたものと同じになるようにサーバーにファイルハンドルが割り当てられている場合、次の例外を使用して、そのようなファイルハンドルを使用したすべての操作がこのクラス内にあります。例外は、データサーバーの性格と互換性がないStareIDを使用する場合（たとえば、特別なStateID、またはStateIDにはゼロ以外の「SEQID」フィールドがあります。セクション13.9.1を参照）、操作はクラスにあります。以下に説明するように、図3を参照する。複数のクラス1の操作（および他のクラスの操作を含む）を含む化合物は、複数の同時データサーバーおよび非データサーバーの個性を持つサーバーに送信されてもよい。"
    },
    {
      "indent": 3,
      "text": "2. An operation that is unambiguously referable to the data-server personality. This includes data-server I/O operations where the filehandle is one that can only be validly directed to the data-server personality.",
      "ja": "2. データサーバの性格に明確に参照可能な操作。これには、ファイルハンドルがデータサーバーの個性にのみ有効に指示されているものであるデータサーバーのI / O操作が含まれます。"
    },
    {
      "indent": 3,
      "text": "3. An operation that is unambiguously referable to the non-data-server personality. This includes all COMPOUND operations that are neither data-server housekeeping nor data-server I/O operations, plus data-server I/O operations where the current fh (or the one to be made the current fh in the case of PUTFH) is only valid on the metadata server or where a stateid is used that is incompatible with the data server, i.e., is a special stateid or has a non-zero seqid value.",
      "ja": "3. 非データベースの性格で明確に参照可能な操作。これには、データサーバーのハウスキーピングやデータサーバーの入出力操作でもないすべての複合操作と、現在のFH（またはPUTFHの場合は現在のFHが行われるもの）があるデータサーバーI / O操作も含まれます。データサーバと互換性がない、すなわち特別なstateIDであるか、ゼロ以外のSEQID値を有する、メタデータサーバ上でのみ有効またはStateIDが使用されている場合にのみ有効です。"
    },
    {
      "indent": 3,
      "text": "When a COMPOUND first executes an operation from class 3 above, it acts as a normal COMPOUND on any other server, and the data-server personality ceases to be relevant. There are no special restrictions on the operations in the COMPOUND to limit them to those for a data server. When a PUTFH is done, filehandles derived from the layout are not valid. If their format is not normally acceptable, then NFS4ERR_BADHANDLE MUST result. Similarly, current filehandles for other operations do not accept filehandles derived from layouts and are not normally usable on the metadata server. Using these will result in NFS4ERR_STALE.",
      "ja": "上記のクラス3からの複合が最初に操作を実行すると、それは他のサーバー上の通常の化合物として機能し、データサーバーのパーソナリティは関連性がなくなります。それらをデータサーバーのものに限定するためのコンパウンド内の操作に特別な制限はありません。PUTFHが完了すると、レイアウトから派生したファイルハンドルは無効です。フォーマットが正常に許容されない場合は、NFS4ERR_BADHandleが発生する必要があります。同様に、他の操作のための現在のファイルハンドルはレイアウトから派生したファイルハンドルを受け入れず、通常はメタデータサーバ上で使用可能ではありません。これらを使用するとNFS4ERR_STALEが表示されます。"
    },
    {
      "indent": 3,
      "text": "When a COMPOUND first executes an operation from class 2, which would be PUTFH where the filehandle is one from a layout, the COMPOUND henceforth is interpreted with respect to the data-server personality. Operations outside the two classes discussed above MUST result in NFS4ERR_NOTSUPP. Filehandles are validated using the rules of the data server, resulting in NFS4ERR_BADHANDLE and/or NFS4ERR_STALE even when they would not normally do so when addressed to the non-data-server personality. Stateids must obey the rules of the data server in that any use of special stateids or stateids with non-zero seqid values must result in NFS4ERR_BAD_STATEID.",
      "ja": "CLIPENDLEがレイアウトから1つのPUTFHであるPUTFHであるクラス2からの操作を最初に実行すると、その化合物はデータサーバーの個性に関して解釈されます。上記の2つのクラス外の操作には、NFS4ERR_NOTSUPPが必要です。ファイルハンドルは、データサーバの規則を使用して検証され、NFS4ERR_BADHANDLEおよび/またはNFS4ERR_STALE、および非データベースサーバの性格宛であっても、NFS4ERR_BADHANDLEおよび/またはNFS4ERR_STALEを実行します。StateIDSは、ゼロ以外のSEQID値を持つStateIDSがNFS4ERR_BAD_STATEIDをもたらす必要があるという点で、データサーバーの規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Until the server first executes an operation from class 2 or class 3, the client MUST NOT depend on the operation being executed by either the data-server or the non-data-server personality. The server MUST pick one personality consistently for a given COMPOUND, with the only possible transition being a single one when the first operation from class 2 or class 3 is executed.",
      "ja": "サーバーが最初にクラス2またはクラス3からの操作を実行するまで、クライアントはデータサーバーまたはデータサーバーの非データベルティのいずれかによって実行されている操作に依存してはなりません。サーバーは特定の化合物に対して一貫して一貫して1つの個人を選択しなければならず、クラス2またはクラス3からの最初の操作が実行されたときには単一の遷移が1つずつあります。"
    },
    {
      "indent": 3,
      "text": "Because of the complexity induced by assigning filehandles so they can be used on both a data server and a metadata server, it is RECOMMENDED that where the same server can have both personalities, the server assign separate unique filehandles to both personalities. This makes it unambiguous for which server a given request is intended.",
      "ja": "ファイルハンドルを割り当てることによって誘起される複雑さのために、データサーバとメタデータサーバの両方で使用できるため、同じサーバが両方の個性を持つことができる場合、サーバは個別の固有のファイルハンドルを両方の個性に割り当てることをお勧めします。これにより、特定の要求がどのような要求が意図されているかを明確にします。"
    },
    {
      "indent": 3,
      "text": "GETATTR and SETATTR MUST be directed to the metadata server. In the case of a SETATTR of the size attribute, the control protocol is responsible for propagating size updates/truncations to the data servers. In the case of extending WRITEs to the data servers, the new size must be visible on the metadata server once a LAYOUTCOMMIT has completed (see Section 12.5.4.2). Section 13.10 describes the mechanism by which the client is to handle data-server files that do not reflect the metadata server's size.",
      "ja": "getAttrとsetAttrはメタデータサーバーに送信する必要があります。size属性のsetAttrの場合、制御プロトコルはサイズ更新/トランケートをデータサーバに伝播する責任があります。データサーバへの書き込みの拡張の場合、LayoutCommitが完了したら、メタデータサーバに新しいサイズを表示する必要があります（セクション12.5.4.2を参照）。セクション13.10では、クライアントがメタデータサーバーのサイズを反映していないデータサーバーファイルを処理するメカニズムを示しています。"
    },
    {
      "indent": 0,
      "text": "13.7. COMMIT through Metadata Server",
      "section_title": true,
      "ja": "13.7. メタデータサーバーを介してコミットします"
    },
    {
      "indent": 3,
      "text": "The file layout provides two alternate means of providing for the commit of data written through data servers. The flag NFL4_UFLG_COMMIT_THRU_MDS in the field nfl_util of the file layout (data type nfsv4_1_file_layout4) is an indication from the metadata server to the client of the REQUIRED way of performing COMMIT, either by sending the COMMIT to the data server or the metadata server. These two methods of dealing with the issue correspond to broad styles of implementation for a pNFS server supporting the file layout type.",
      "ja": "ファイルレイアウトは、データサーバを介して書き込まれたデータのコミットを提供する2つの代替手段を提供します。ファイルレイアウトのフィールドNFL_UTILのフラグNFL4_UFLG_COMMIT_THRU_MDS（データ型NFSV4_1_FILE_LAYOUT4）は、データサーバまたはメタデータサーバにコミットを送信することによって、メタデータサーバからコミットを実行するために必要な方法のクライアントへの指示である。この問題に対処するこれら2つの方法は、ファイルレイアウトタイプをサポートするPNFSサーバの幅広い実装スタイルに対応しています。"
    },
    {
      "indent": 3,
      "text": "* When the flag is FALSE, COMMIT operations MUST to be sent to the data server to which the corresponding WRITE operations were sent. This approach is sometimes useful when file striping is implemented within the pNFS server (instead of the file system), with the individual data servers each implementing their own file systems.",
      "ja": "* フラグが偽の場合、コミット操作を対応する書き込み操作が送信されたデータサーバに送信する必要があります。このアプローチは、ファイルストライピングが（ファイルシステムの代わりに）PNFSサーバー内で（ファイルシステムの代わりに）PNFSサーバー内に実装されている場合に有用であり、個々のデータサーバーはそれぞれ独自のファイルシステムを実装しています。"
    },
    {
      "indent": 3,
      "text": "* When the flag is TRUE, COMMIT operations MUST be sent to the metadata server, rather than to the individual data servers. This approach is sometimes useful when file striping is implemented within the clustered file system that is the backend to the pNFS server. In such an implementation, each COMMIT to each data server might result in repeated writes of metadata blocks to the detriment of write performance. Sending a single COMMIT to the metadata server can be more efficient when there exists a clustered file system capable of implementing such a coordinated COMMIT.",
      "ja": "* フラグがTRUEの場合、個々のデータサーバよりもコミット操作をメタデータサーバに送信する必要があります。このアプローチは、ファイルストライピングがPNFSサーバへのバックエンドであるクラスタ化ファイルシステム内で実装されている場合に有用である場合があります。そのような実装では、各データサーバへの各コミットは、書き込み性能の損なうにメタデータブロックの書き込みを繰り返す可能性がある。このような調整コミットを実装できるクラスタ化ファイルシステムが存在する場合は、メタデータサーバーに単一のコミットを送信することができます。"
    },
    {
      "indent": 6,
      "text": "If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is TRUE, then in order to maintain the current NFSv4.1 commit and recovery model, the data servers MUST return a common writeverf verifier in all WRITE responses for a given file layout, and the metadata server's COMMIT implementation must return the same writeverf. The value of the writeverf verifier MUST be changed at the metadata server or any data server that is referenced in the layout, whenever there is a server event that can possibly lead to loss of uncommitted data. The scope of the verifier can be for a file or for the entire pNFS server. It might be more difficult for the server to maintain the verifier at the file level, but the benefit is that only events that impact a given file will require recovery action.",
      "ja": "NFL_UTIL＆NFL4_UFLG_COMMIT_THRU_MDSがTRUEの場合、現在のNFSV4.1コミットおよびリカバリモデルを維持するためには、データサーバは特定のファイルレイアウトのすべての書き込み応答で共通のWriteVerf Verifierを返し、メタデータサーバのコミット実装が返さなければなりません。同じwriteverf。WriteVerf Verifierの値は、メタデータサーバーまたはレイアウトで参照されているデータサーバーで変更する必要があります。検証者の範囲は、ファイルまたはPNFSサーバー全体の場合があります。サーバーがファイルレベルで検証者を維持するのが難しいかもしれませんが、与えられたファイルに影響を与えるイベントのみが回復アクションを必要とすることです。"
    },
    {
      "indent": 3,
      "text": "Note that if the layout specified dense packing, then the offset used to a COMMIT to the MDS may differ than that of an offset used to a COMMIT to the data server.",
      "ja": "レイアウトが指定された密集梱包が指定された場合、MDSへのコミットに使用されるオフセットは、データサーバへのコミットに使用されるオフセットのオフセットとは異なる可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The single COMMIT to the metadata server will return a verifier, and the client should compare it to all the verifiers from the WRITEs and fail the COMMIT if there are any mismatched verifiers. If COMMIT to the metadata server fails, the client should re-send WRITEs for all the modified data in the file. The client should treat modified data with a mismatched verifier as a WRITE failure and try to recover by resending the WRITEs to the original data server or using another path to that data if the layout has not been recalled. Alternatively, the client can obtain a new layout or it could rewrite the data directly to the metadata server. If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is FALSE, sending a COMMIT to the metadata server might have no effect. If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is FALSE, a COMMIT sent to the metadata server should be used only to commit data that was written to the metadata server. See Section 12.7.6 for recovery options.",
      "ja": "Metadata Serverへのシングルコミットは検証者を返し、クライアントは書き込みからすべての検証者と比較し、不一致検証者がある場合はコミットを失敗させるべきです。メタデータサーバーに障害が発生した場合、クライアントはファイル内のすべての変更されたデータの書き込みを再送信する必要があります。クライアントは、修正されたデータを書き込み障害として扱い、レイアウトが呼び出されていない場合は、元のデータサーバへの書き込みを再送信するか、またはそのデータへの別のパスを使用して回復しようとしている必要があります。あるいは、クライアントは新しいレイアウトを取得することも、データをメタデータサーバに直接書き換えることもできます。NFL_UTIL＆NFL4_UFLG_COMMIT_THRU_MDSがfalseの場合、メタデータサーバにコミットを送信すると効果がない可能性があります。NFL_UTIL＆NFL4_UFLG_COMMIT_THRU_MDSがfalseの場合、メタデータサーバに送信されたコミットは、メタデータサーバに書き込まれたデータをコミットするためにのみ使用する必要があります。回復オプションについては、セクション12.7.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.8. The Layout Iomode",
      "section_title": true,
      "ja": "13.8. レイアウトIomode"
    },
    {
      "indent": 3,
      "text": "The layout iomode need not be used by the metadata server when servicing NFSv4.1 file-based layouts, although in some circumstances it may be useful. For example, if the server implementation supports reading from read-only replicas or mirrors, it would be useful for the server to return a layout enabling the client to do so. As such, the client SHOULD set the iomode based on its intent to read or write the data. The client may default to an iomode of LAYOUTIOMODE4_RW. The iomode need not be checked by the data servers when clients perform I/O. However, the data servers SHOULD still validate that the client holds a valid layout and return an error if the client does not.",
      "ja": "NFSV4.1ファイルベースのレイアウトを処理するときには、レイアウトIOMODEをメタデータサーバーで使用する必要はありません。状況によっては便利な場合があります。たとえば、サーバー実装が読み取り専用レプリカまたはミラーからの読み取りをサポートしている場合は、サーバーがクライアントが実行できるようにするレイアウトを返すのに役立ちます。そのため、クライアントはデータを読み書きするという意図に基づいてIOMODEを設定する必要があります。クライアントはデフォルトでLayoutIomode4_RWのIOModeになることがあります。クライアントがI / Oを実行すると、IOMODEはデータサーバーによってチェックされる必要はありません。ただし、データサーバーは、クライアントが有効なレイアウトを保持し、クライアントがそうでない場合はエラーを返すことを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9. Metadata and Data Server State Coordination",
      "section_title": true,
      "ja": "13.9. メタデータとデータサーバの状態調整"
    },
    {
      "indent": 0,
      "text": "13.9.1. Global Stateid Requirements",
      "section_title": true,
      "ja": "13.9.1. グローバル州の要件"
    },
    {
      "indent": 3,
      "text": "When the client sends I/O to a data server, the stateid used MUST NOT be a layout stateid as returned by LAYOUTGET or sent by CB_LAYOUTRECALL. Permitted stateids are based on one of the following: an OPEN stateid (the stateid field of data type OPEN4resok as returned by OPEN), a delegation stateid (the stateid field of data types open_read_delegation4 and open_write_delegation4 as returned by OPEN or WANT_DELEGATION, or as sent by CB_PUSH_DELEG), or a stateid returned by the LOCK or LOCKU operations. The stateid sent to the data server MUST be sent with the seqid set to zero, indicating the most current version of that stateid, rather than indicating a specific non-zero seqid value. In no case is the use of special stateid values allowed.",
      "ja": "クライアントがデータサーバにI / Oを送信すると、使用されるStateIDは、Layoutgetによって返されるか、CB_LayOutRecallによって送信されたレイアウトStareIDではありません。許可されたStateIDは、次のいずれかに基づいています。オープンステートID（Openによって返されるデータ型Open4ResokのStateIDフィールド）、委任ステートID（OpenまたはWant_Delegationによって返されるデータ型Open_read_Delegation4とOpen_Write_Delegation4のStateIDフィールド）CB_PUSH_DELEG（CB_PUSH_DELEG）、またはロックまたはロック操作によって返されるStareID。データサーバに送信されたStateIDは、特定の非ゼロのSEQID値を示すのではなく、そのStateIDの最新バージョンを示すSEQIDで送信する必要があります。いいえでは、許可されている特別なStateID値の使用があります。"
    },
    {
      "indent": 3,
      "text": "The stateid used for I/O MUST have the same effect and be subject to the same validation on a data server as it would if the I/O was being performed on the metadata server itself in the absence of pNFS. This has the implication that stateids are globally valid on both the metadata and data servers. This requires the metadata server to propagate changes in LOCK and OPEN state to the data servers, so that the data servers can validate I/O accesses. This is discussed further in Section 13.9.2. Depending on when stateids are propagated, the existence of a valid stateid on the data server may act as proof of a valid layout.",
      "ja": "I / Oに使用されるStareIDは同じ効果を持ち、PNFSがない場合にI / Oがメタデータサーバー自体で実行されている場合と同じ有効化を受けている必要があります。これは、StateIDSがメタデータとデータサーバーの両方でグローバルに有効であるという意味を持っています。これには、メタデータサーバーがロック状態の変更とオープン状態の変更をデータサーバーに伝播する必要があります。そのため、データサーバーはI / Oアクセスを検証できます。これについては、13.9.2項でさらに説明されています。StateIDが伝播されるかに応じて、データサーバ上の有効なStateIDの存在は有効なレイアウトの証明として機能する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. The rules for doing so when referencing data servers are somewhat different from those discussed in Section 8.2.5, which apply when accessing metadata servers.",
      "ja": "I / O操作を実行するクライアントは、クライアントによって保持されているロック（オープンおよび代理を含む）に基づいて適切なStateIDを選択する必要があります。およびI / Oリクエストを送信するさまざまな種類の状態所有者が入荷しています。データサーバを参照するときにそうするための規則は、メタデータサーバにアクセスするときに適用されるセクション8.2.5で説明されているものとは多少異なります。"
    },
    {
      "indent": 3,
      "text": "The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid:",
      "ja": "以下の規則は、優先順位の低下の順に適用され、適切なStareIDの選択を管理します。"
    },
    {
      "indent": 3,
      "text": "* If the client holds a delegation for the file in question, the delegation stateid should be used.",
      "ja": "* クライアントが問題のファイルの委任を保持している場合、委任ステートIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, there must be an OPEN stateid for the current open-owner, and that OPEN stateid for the open file in question is used, unless mandatory locking prevents that. See below.",
      "ja": "* それ以外の場合は、現在のオープンオーナーにOpen StareIDが必要です。必須のロックがそれを防止しない限り、問題のオープンファイルのOpen StareIDが使用されます。下記参照。"
    },
    {
      "indent": 3,
      "text": "* If the data server had previously responded with NFS4ERR_LOCKED to use of the OPEN stateid, then the client should use the byte-range lock stateid whenever one exists for that open file with the current lock-owner.",
      "ja": "* Data Serverが以前にNFS4ERR_LOCKEDを使用してOpen StareIDを使用して応答していた場合、クライアントは現在のロックー所有者を持つその開いているファイルに存在するときはいつでもByte-Range Lock StareIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Special stateids should never be used. If they are used, the data server MUST reject the I/O with an NFS4ERR_BAD_STATEID error.",
      "ja": "* 特別な州は決して使用しないでください。それらが使用されている場合、データサーバはNFS4ERR_BAD_STATEIDエラーでI / Oを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9.2. Data Server State Propagation",
      "section_title": true,
      "ja": "13.9.2. データサーバの状態伝搬"
    },
    {
      "indent": 3,
      "text": "Since the metadata server, which handles byte-range lock and open-mode state changes as well as ACLs, might not be co-located with the data servers where I/O accesses are validated, the server implementation MUST take care of propagating changes of this state to the data servers. Once the propagation to the data servers is complete, the full effect of those changes MUST be in effect at the data servers. However, some state changes need not be propagated immediately, although all changes SHOULD be propagated promptly. These state propagations have an impact on the design of the control protocol, even though the control protocol is outside of the scope of this specification. Immediate propagation refers to the synchronous propagation of state from the metadata server to the data server(s); the propagation must be complete before returning to the client.",
      "ja": "I / Oアクセスが検証されているデータサーバと同様にバイトレンジロックとオープンモードの状態の変化を処理するメタデータサーバは、I / Oアクセスが検証されていることがあるため、サーバの実装は、の伝播の管理を行わなければなりません。この状態データサーバへの状態。データサーバーへの伝播が完了すると、それらの変更の影響が完全に影響を及ぼしている必要があります。ただし、すべての変更を迅速に伝播する必要がありますが、いくつかの状態変更を直ちに伝播する必要はありません。これらの状態伝搬は、制御プロトコルがこの仕様の範囲外にある場合でも、制御プロトコルの設計に影響を与えます。即時の伝播とは、メタデータサーバからデータサーバへの状態の同期伝播を指す。伝播はクライアントに戻る前に完了する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9.2.1. Lock State Propagation",
      "section_title": true,
      "ja": "13.9.2.1. ロック状態伝搬"
    },
    {
      "indent": 3,
      "text": "If the pNFS server supports mandatory byte-range locking, any mandatory byte-range locks on a file MUST be made effective at the data servers before the request that establishes them returns to the caller. The effect MUST be the same as if the mandatory byte-range lock state were synchronously propagated to the data servers, even though the details of the control protocol may avoid actual transfer of the state under certain circumstances.",
      "ja": "PNFSサーバーが必須バイトレンジロックをサポートしている場合は、ファイル上の必須バイトレンジロックをデータサーバーで有効にする必要があります。制御プロトコルの詳細は、特定の状況下での実際の状態の転送を回避することを回避しても、必須バイトレンジロック状態がデータサーバに同期的に伝播された場合と同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "On the other hand, since advisory byte-range lock state is not used for checking I/O accesses at the data servers, there is no semantic reason for propagating advisory byte-range lock state to the data servers. Since updates to advisory locks neither confer nor remove privileges, these changes need not be propagated immediately, and may not need to be propagated promptly. The updates to advisory locks need only be propagated when the data server needs to resolve a question about a stateid. In fact, if byte-range locking is not mandatory (i.e., is advisory) the clients are advised to avoid using the byte-range lock-based stateids for I/O. The stateids returned by OPEN are sufficient and eliminate overhead for this kind of state propagation.",
      "ja": "一方、データサーバでのI / Oアクセスを確認するためにアドバイザリバイトレンジロック状態は使用されていないため、アドバイザリバイトレンジロック状態をデータサーバに伝搬するという意味の理由はない。アドバイザリロックの更新は特権を担当または削除しないので、これらの変更はすぐに伝播される必要はなく、速やかに伝播する必要はありません。アドバイザリロックの更新は、データサーバーがStateIDに関する質問を解決する必要があるときにのみ伝播されるだけです。実際、バイトレンジロックが必須ではない場合（すなわちアドバイザリー）クライアントは、I / OのバイトレンジロックベースのステートIDを使用しないように推奨されます。オープンによって返された州は十分であり、この種の状態伝播のオーバーヘッドを排除します。"
    },
    {
      "indent": 3,
      "text": "If a client gets back an NFS4ERR_LOCKED error from a data server, this is an indication that mandatory byte-range locking is in force. The client recovers from this by getting a byte-range lock that covers the affected range and re-sends the I/O with the stateid of the byte-range lock.",
      "ja": "クライアントがデータサーバーからNFS4ERR_LOCKEDエラーを返す場合、これは必須のバイトレンジロックが有効になっているという表示です。このクライアントは、影響を受ける範囲をカバーするバイトレンジロックを取得し、I / OをバイトレンジロックのStateIDと再送信することによって、これを回復します。"
    },
    {
      "indent": 0,
      "text": "13.9.2.2. Open and Deny Mode Validation",
      "section_title": true,
      "ja": "13.9.2.2. オープンで拒否モード検証"
    },
    {
      "indent": 3,
      "text": "Open and deny mode validation MUST be performed against the open and deny mode(s) held by the data servers. When access is reduced or a deny mode made more restrictive (because of CLOSE or OPEN_DOWNGRADE), the data server MUST prevent any I/Os that would be denied if performed on the metadata server. When access is expanded, the data server MUST make sure that no requests are subsequently rejected because of open or deny issues that no longer apply, given the previous relaxation.",
      "ja": "オープンおよび拒否モード検証は、データサーバーによって保持されているオープンモードと拒否モードに対して実行する必要があります。アクセスが減少するか、拒否モードがより厳密に制限されている場合（CLOSEまたはOPENGRADEのために）、データサーバーはメタデータサーバーで実行された場合に拒否されるI / Oを妨げる必要があります。アクセスが拡張されると、以前のリラクゼーションを考えると、適用されなくなったOpenまたはDenyの問題が発生したため、データサーバは、その後要求が拒否されないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9.2.3. File Attributes",
      "section_title": true,
      "ja": "13.9.2.3. ファイル属性"
    },
    {
      "indent": 3,
      "text": "Since the SETATTR operation has the ability to modify state that is visible on both the metadata and data servers (e.g., the size), care must be taken to ensure that the resultant state across the set of data servers is consistent, especially when truncating or growing the file.",
      "ja": "SETATTRの操作では、メタデータとデータサーバーの両方（サイズ）に表示されている状態を変更することができますので、特に切り捨て時または切り捨てるときに、データサーバーのセットにわたる結果の状態が一貫していることを確認するように注意する必要があります。ファイルを増やします。"
    },
    {
      "indent": 3,
      "text": "As described earlier, the LAYOUTCOMMIT operation is used to ensure that the metadata is synchronized with changes made to the data servers. For the NFSv4.1-based data storage protocol, it is necessary to re-synchronize state such as the size attribute, and the setting of mtime/change/atime. See Section 12.5.4 for a full description of the semantics regarding LAYOUTCOMMIT and attribute synchronization. It should be noted that by using an NFSv4.1-based layout type, it is possible to synchronize this state before LAYOUTCOMMIT occurs. For example, the control protocol can be used to query the attributes present on the data servers.",
      "ja": "前述のように、LayoutCommit操作は、メタデータがデータサーバに加えられた変更と同期されていることを確認するために使用される。NFSV4.1ベースのデータストレージプロトコルの場合、size属性などの状態、およびmtime / change / atimeの設定を再同期する必要があります。LayoutCommitと属性同期に関するセマンティクスの詳細については、12.5.4項を参照してください。なお、NFSV4.1ベースのレイアウトタイプを使用することで、レイアウトコミットが発生する前にこの状態を同期させることが可能です。たとえば、コントロールプロトコルを使用して、データサーバーに存在する属性を照会できます。"
    },
    {
      "indent": 3,
      "text": "Any changes to file attributes that control authorization or access as reflected by ACCESS calls or READs and WRITEs on the metadata server, MUST be propagated to the data servers for enforcement on READ and WRITE I/O calls. If the changes made on the metadata server result in more restrictive access permissions for any user, those changes MUST be propagated to the data servers synchronously.",
      "ja": "アクセスコールまたはメタデータサーバー上の読み取りや書き込みによって反映されているように、許可またはアクセスを制御するファイル属性の変更は、読み取りおよび書き込みI / O呼び出しの施行のためにデータサーバーに伝播する必要があります。メタデータサーバー上で行われた変更がユーザーに対してより制限的なアクセス許可をもたらす場合、それらの変更は同期的にデータサーバーに伝播する必要があります。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation (Section 18.16.4) does not impose any requirement that I/O operations on an open file have the same credentials as the OPEN itself (unless EXCHGID4_FLAG_BIND_PRINC_STATEID is set when EXCHANGE_ID creates the client ID), and so it requires the server's READ and WRITE operations to perform appropriate access checking. Changes to ACLs also require new access checking by READ and WRITE on the server. The propagation of access-right changes due to changes in ACLs may be asynchronous only if the server implementation is able to determine that the updated ACL is not more restrictive for any user specified in the old ACL. Due to the relative infrequency of ACL updates, it is suggested that all changes be propagated synchronously.",
      "ja": "オープン操作（第18.16項）は、オープンファイルに対するI / O操作がOpenそれ自体と同じ認証情報を持つ必要がありません（Exchange_IDがクライアントIDを作成したときにExchgid4_flag_bind_princ_stateIDが設定されていない場合）、サーバーのサーバーを必要とします。適切なアクセスチェックを実行するための読み書き操作。ACLへの変更には、サーバー上の読み取りおよび書き込みによる新しいアクセスチェックが必要です。ACLの変更によるアクセス権の変化によるアクセス権の伝播は、サーバー実装が、更新されたACLが古いACLで指定されたユーザーが制限されていないと判断できる場合にのみ非同期である可能性があります。ACL更新の相対的な頻度のために、すべての変更が同期的に伝播されることが示唆されています。"
    },
    {
      "indent": 0,
      "text": "13.10. Data Server Component File Size",
      "section_title": true,
      "ja": "13.10. データサーバコンポーネントファイルサイズ"
    },
    {
      "indent": 3,
      "text": "A potential problem exists when a component data file on a particular data server has grown past EOF; the problem exists for both dense and sparse layouts. Imagine the following scenario: a client creates a new file (size == 0) and writes to byte 131072; the client then seeks to the beginning of the file and reads byte 100. The client should receive zeroes back as a result of the READ. However, if the striping pattern directs the client to send the READ to a data server other than the one that received the client's original WRITE, the data server servicing the READ may believe that the file's size is still 0 bytes. In that event, the data server's READ response will contain zero bytes and an indication of EOF. The data server can only return zeroes if it knows that the file's size has been extended. This would require the immediate propagation of the file's size to all data servers, which is potentially very costly. Therefore, the client that has initiated the extension of the file's size MUST be prepared to deal with these EOF conditions. When the offset in the arguments to READ is less than the client's view of the file size, if the READ response indicates EOF and/or contains fewer bytes than requested, the client will interpret such a response as a hole in the file, and the NFS client will substitute zeroes for the data.",
      "ja": "特定のデータサーバ上のコンポーネントデータファイルがEOFを過ぎて成長したときに潜在的な問題がある。問題は密なレイアウトと疎の両方のレイアウトに存在します。次のシナリオを想像してみてください。クライアントは新しいファイルを作成します（size == 0）、バイト131072に書き込みます。その後、クライアントはファイルの先頭を求め、バイト100を読み取ります。読み取りの結果として、クライアントはゼロを返します。ただし、ストライピングパターンがクライアントの元の書き込みを受信したもの以外のデータサーバーにクライアントに送信するように指示すると、読み取りにサービスを提供するデータサーバーは、ファイルのサイズがまだ0バイトであると考えられます。その場合、データサーバの読み取り応答にはゼロバイトとEOFの表示が含まれます。データサーバは、ファイルのサイズが拡張されていることを知っている場合にのみゼロを返すことができます。これは、ファイルのサイズの即時伝播をすべてのデータサーバーに伝播する必要があります。これは潜在的に非常に高価です。したがって、ファイルのサイズの拡張を開始したクライアントは、これらのEOF条件に対処するために準備する必要があります。読み取る引数内のオフセットがファイルサイズのクライアントのビューよりも小さい場合、読み取り応答が要求されたよりも/ /またはバイト数が少ない場合、クライアントはそのような応答をファイル内の穴として解釈します。 NFSクライアントはデータのゼロを置き換えます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol only provides close-to-open file data cache semantics; meaning that when the file is closed, all modified data is written to the server. When a subsequent OPEN of the file is done, the change attribute is inspected for a difference from a cached value for the change attribute. For the case above, this means that a LAYOUTCOMMIT will be done at close (along with the data WRITEs) and will update the file's size and change attribute. Access from another client after that point will result in the appropriate size being returned.",
      "ja": "NFSv4.1プロトコルは、開いているファイルデータキャッシュセマンティクスのみを提供します。ファイルが閉じられると、変更されたすべてのデータがサーバーに書き込まれます。その後のファイルが終わると、変更属性のキャッシュ値との差異について変更属性が検査されます。上記の場合、これはLayoutCommitがCLOSE（データ書き込み）で行われ、ファイルのサイズと変更属性を更新します。その点以降の別のクライアントからのアクセスは、適切なサイズが返されます。"
    },
    {
      "indent": 0,
      "text": "13.11. Layout Revocation and Fencing",
      "section_title": true,
      "ja": "13.11. レイアウトの失効とフェンシング"
    },
    {
      "indent": 3,
      "text": "As described in Section 12.7, the layout-type-specific storage protocol is responsible for handling the effects of I/Os that started before lease expiration and extend through lease expiration. The LAYOUT4_NFSV4_1_FILES layout type can prevent all I/Os to data servers from being executed after lease expiration (this prevention is called \"fencing\"), without relying on a precise client lease timer and without requiring data servers to maintain lease timers. The LAYOUT4_NFSV4_1_FILES pNFS server has the flexibility to revoke individual layouts, and thus fence I/O on a per-file basis.",
      "ja": "セクション12.7で説明されているように、レイアウト型固有のストレージプロトコルは、リースの有効期限が切れる前に開始され、リースの有効期限を介して延長するI / Oの影響を担当します。LAYOUT4_NFSV4_1_FILESレイアウトタイプは、リースの有効期限を維持することなく、リースタイマーを維持する必要なしに、リースの有効期限が依存しないように、すべてのI / OへのデータサーバへのすべてのI / Oへの実行が実行されないようにすることができます。LAYOUT4_NFSV4_1_FILES PNFSサーバーは、個々のレイアウトを取り消すための柔軟性を持ち、ファイルごとにI / Oをフェンス単位でフェンスします。"
    },
    {
      "indent": 3,
      "text": "In addition to lease expiration, the reasons a layout can be revoked include: client fails to respond to a CB_LAYOUTRECALL, the metadata server restarts, or administrative intervention. Regardless of the reason, once a client's layout has been revoked, the pNFS server MUST prevent the client from sending I/O for the affected file from and to all data servers; in other words, it MUST fence the client from the affected file on the data servers.",
      "ja": "リースの有効期限に加えて、レイアウトが取り消すことができる理由は次のとおりです。クライアントは、CB_LAYOUTRecall、メタデータサーバの再起動、または管理介入に応答することができません。その理由にかかわらず、クライアントのレイアウトが取り消されると、PNFSサーバは、エクストライバが影響を受けるファイルに対してI / Oを送信しないようにする必要があります。つまり、データサーバ上の影響を受けるファイルからクライアントを囲む必要があります。"
    },
    {
      "indent": 3,
      "text": "Fencing works as follows. As described in Section 13.1, in COMPOUND procedure requests to the data server, the data filehandle provided by the PUTFH operation and the stateid in the READ or WRITE operation are used to ensure that the client has a valid layout for the I/O being performed; if it does not, the I/O is rejected with NFS4ERR_PNFS_NO_LAYOUT. The server can simply check the stateid and, additionally, make the data filehandle stale if the layout specified a data filehandle that is different from the metadata server's filehandle for the file (see the nfl_fh_list description in Section 13.3).",
      "ja": "フェンシングは次のように機能します。セクション13.1に記載されているように、データサーバへの複合手順では、PUTFH操作によって提供されるデータファイルハンドルおよび読み取りまたは書き込み動作のSTATEIDが使用され、クライアントが実行されているI / Oの有効なレイアウトがあることを確実にするために使用される。;そうでない場合、I / OはNFS4ERR_PNFS_NO_LAYOUTで拒否されます。レイアウトがファイルのメタデータサーバのファイルハンドルとは異なるデータファイルハンドルを指定した場合、サーバは単純にStateIDをチェックするだけで、データファイルハンドルがファイルハンドルに指定されている場合（セクション13.3のNFL_FH_LISTの説明を参照）。"
    },
    {
      "indent": 3,
      "text": "Before the metadata server takes any action to revoke layout state given out by a previous instance, it must make sure that all layout state from that previous instance are invalidated at the data servers. This has the following implications.",
      "ja": "メタデータサーバーが前のインスタンスによって指定されたレイアウト状態を取り消すために任意のアクションを実行する前に、その前のインスタンスからのすべてのレイアウト状態がデータサーバで無効になっていることを確認する必要があります。これには以下の意味があります。"
    },
    {
      "indent": 3,
      "text": "* The metadata server must not restripe a file until it has contacted all of the data servers to invalidate the layouts from the previous instance.",
      "ja": "* メタデータサーバーは、前のインスタンスからレイアウトを無効にするためにすべてのデータサーバーに連絡されるまでファイルを制限してはなりません。"
    },
    {
      "indent": 3,
      "text": "* The metadata server must not give out mandatory locks that conflict with layouts from the previous instance without either doing a specific layout invalidation (as it would have to do anyway) or doing a global data server invalidation.",
      "ja": "* メタデータサーバーは、特定のレイアウトの無効化を実行する（とにかく行わなければならないため）、またはグローバルデータサーバーの無効化を行うことなく、前のインスタンスからレイアウトと競合する必須ロックを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "13.12. Security Considerations for the File Layout Type",
      "section_title": true,
      "ja": "13.12. ファイルレイアウトタイプのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 file layout type MUST adhere to the security considerations outlined in Section 12.9. NFSv4.1 data servers MUST make all of the required access checks on each READ or WRITE I/O as determined by the NFSv4.1 protocol. If the metadata server would deny a READ or WRITE operation on a file due to its ACL, mode attribute, open access mode, open deny mode, mandatory byte-range lock state, or any other attributes and state, the data server MUST also deny the READ or WRITE operation. This impacts the control protocol and the propagation of state from the metadata server to the data servers; see Section 13.9.2 for more details.",
      "ja": "NFSV4.1ファイルレイアウトタイプは、セクション12.9で概説されているセキュリティ上の考慮事項に準拠している必要があります。NFSV4.1データサーバは、NFSV4.1プロトコルによって決定された各読み取りまたは書き込みI / Oで必要なアクセスチェックをすべて行わなければなりません。ACL、ODEアクセスモード、オープンアクセスモード、Open Denyモード、必須バイトレンジロック状態、またはその他の属性と状態のために、メタデータサーバーがファイルに対して読み取りまたは書き込み操作を拒否すると、データサーバーも拒否する必要があります。読み取りまたは書き込み操作。これにより、コントロールプロトコルとメタデータサーバーからデータサーバーへの状態の伝播が影響します。詳細については13.9.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The methods for authentication, integrity, and privacy for data servers based on the LAYOUT4_NFSV4_1_FILES layout type are the same as those used by metadata servers. Metadata and data servers use ONC RPC security flavors to authenticate, and SECINFO and SECINFO_NO_NAME to negotiate the security mechanism and services to be used. Thus, when using the LAYOUT4_NFSV4_1_FILES layout type, the impact on the RPC-based security model due to pNFS (as alluded to in Sections 1.8.1 and 1.8.2.2) is zero.",
      "ja": "LAYOUT4_NFSV4_1_FILESレイアウトタイプに基づくデータサーバの認証、整合性、およびプライバシーのためのメソッドは、メタデータサーバによって使用されるものと同じです。メタデータとデータサーバは、ANC RPCセキュリティフレーバーを使用して認証し、SECINFOおよびSECINFO_NO_NAMEを使用して、使用するセキュリティメカニズムとサービスをネゴシエートします。したがって、LAYOUT4_NFSV4_1_FILESレイアウトタイプを使用する場合、PNFSによるRPCベースのセキュリティモデルへの影響（セクション1.8.1および1.8.2.2に示されているように）はゼロです。"
    },
    {
      "indent": 3,
      "text": "For a given file object, a metadata server MAY require different security parameters (secinfo4 value) than the data server. For a given file object with multiple data servers, the secinfo4 value SHOULD be the same across all data servers. If the secinfo4 values across a metadata server and its data servers differ for a specific file, the mapping of the principal to the server's internal user identifier MUST be the same in order for the access-control checks based on ACL, mode, open and deny mode, and mandatory locking to be consistent across on the pNFS server.",
      "ja": "特定のファイルオブジェクトの場合、メタデータサーバーはデータサーバーよりも異なるセキュリティパラメータ（SECINFO4値）を必要とする可能性があります。複数のデータサーバーを持つ特定のファイルオブジェクトの場合、SECINFO4値はすべてのデータサーバーにわたって同じにする必要があります。メタデータサーバーとそのデータサーバー全体のSECINFO4値が特定のファイルに対して異なる場合は、ACL、MODE、OPEN、DENYに基づくアクセス制御チェックの順に、プリンシパルのマッピングがサーバーの内部ユーザー識別子にマッピングする必要があります。MODE、および必須のロックは、PNFSサーバー上で一貫しています。"
    },
    {
      "indent": 3,
      "text": "If an NFSv4.1 implementation supports pNFS and supports NFSv4.1 file layouts, then the implementation MUST support the SECINFO_NO_NAME operation on both the metadata and data servers.",
      "ja": "NFSV4.1の実装がPNFSをサポートしてNFSv4.1ファイルレイアウトをサポートしている場合、実装はメタデータサーバとデータサーバの両方でsecinfo_no_name操作をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "14. Internationalization",
      "section_title": true,
      "ja": "14. 国際化"
    },
    {
      "indent": 3,
      "text": "The primary issue in which NFSv4.1 needs to deal with internationalization, or I18N, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients that use various languages. The UTF-8 encoding of the UCS (Universal Multiple-Octet Coded Character Set) as defined by ISO10646 [18] allows for this type of access and follows the policy described in \"IETF Policy on Character Sets and Languages\", RFC 2277 [19].",
      "ja": "NFSV4.1が国際化、またはI18Nに対処する必要がある主な問題は、プロトコル内で使用されるファイル名およびその他の文字列に関してあります。文字列表現の選択は、さまざまな言語を使用するクライアントへの合理的な名前/文字列アクセスを許可する必要があります。ISO10646 [18]で定義されているUCSのUTF-8エンコーディング[18]では、このタイプのアクセスを許可し、「文字セットと言語のIETFポリシー」、RFC 2277 [19]で説明されているポリシーに従います。]。"
    },
    {
      "indent": 3,
      "text": "RFC 3454 [16], otherwise known as \"stringprep\", documents a framework for using Unicode/UTF-8 in networking protocols so as \"to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world\". A protocol must define a profile of stringprep \"in order to fully specify the processing options\". The remainder of this section defines the NFSv4.1 stringprep profiles. Much of the terminology used for the remainder of this section comes from stringprep.",
      "ja": "「StringPrep」として知られているRFC 3454 [16]は、ネットワークプロトコルでUnicode / UTF-8を使用するためのフレームワークを「String」入力と文字列比較の可能性を高めるための尤度を高めるための尤度を高めることができます。世界\"。プロトコルは、処理オプションを完全に指定するためにStringPrepのプロファイルを定義する必要があります。このセクションの残りの部分は、NFSv4.1 StringPrepプロファイルを定義します。このセクションの残りの部分に使用される用語の多くは、StringPrepから来ています。"
    },
    {
      "indent": 3,
      "text": "There are three UTF-8 string types defined for NFSv4.1: utf8str_cs, utf8str_cis, and utf8str_mixed. Separate profiles are defined for each. Each profile defines the following, as required by stringprep:",
      "ja": "NFSV4.1：utf8str_cs、utf8str_cis、およびutf8str_mixedに定義されている3つのUTF-8文字列型があります。別々のプロファイルがそれぞれに定義されています。各プロファイルは、StringPrepで必要な場合に次のものを定義します。"
    },
    {
      "indent": 3,
      "text": "* The intended applicability of the profile.",
      "ja": "* プロファイルの意図された適用性"
    },
    {
      "indent": 3,
      "text": "* The character repertoire that is the input and output to stringprep (which is Unicode 3.2 for the referenced version of stringprep). However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "* 文字レパートリーは、入力と出力、StringPrep（参照されているバージョンのStringPrepのUnicode 3.2です）です。ただし、NFSV4.1の実装は3.2に限定されません。"
    },
    {
      "indent": 3,
      "text": "* The mapping tables from stringprep used (as described in Section 3 of stringprep).",
      "ja": "* 使用されているStringPrepからのマッピングテーブルは（StringPrepのセクション3で説明されているように）。"
    },
    {
      "indent": 3,
      "text": "* Any additional mapping tables specific to the profile.",
      "ja": "* プロファイルに固有の追加のマッピングテーブル。"
    },
    {
      "indent": 3,
      "text": "* The Unicode normalization used, if any (as described in Section 4 of stringprep).",
      "ja": "* Unicode正規化は、（StringPrepのセクション4のセクション4で説明されているように）使用されています。"
    },
    {
      "indent": 3,
      "text": "* The tables from the stringprep listing of characters that are prohibited as output (as described in Section 5 of stringprep).",
      "ja": "* （StringPrepのセクション5で説明されているように）出力として禁止されている文字のStringPrepリストからのテーブル。"
    },
    {
      "indent": 3,
      "text": "* The bidirectional string testing used, if any (as described in Section 6 of stringprep).",
      "ja": "* いずれかの双方向文字列テスト（StringPrepのセクション6で説明されているように）。"
    },
    {
      "indent": 3,
      "text": "* Any additional characters that are prohibited as output specific to the profile.",
      "ja": "* プロファイルに固有の出力として禁止されている追加の文字。"
    },
    {
      "indent": 3,
      "text": "Stringprep discusses Unicode characters, whereas NFSv4.1 renders UTF-8 characters. Since there is a one-to-one mapping from UTF-8 to Unicode, when the remainder of this document refers to Unicode, the reader should assume UTF-8.",
      "ja": "StringPrepはUnicode文字を説明しますが、NFSV4.1はUTF-8文字をレンダリングします。UTF-8からUnicodeへの1対1のマッピングがあるため、このドキュメントの残りの部分がUnicodeを参照すると、リーダーはUTF-8を想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Much of the text for the profiles comes from RFC 3491 [20].",
      "ja": "プロファイルのテキストの多くは、RFC 3491 [20]から来ています。"
    },
    {
      "indent": 0,
      "text": "14.1. Stringprep Profile for the utf8str_cs Type",
      "section_title": true,
      "ja": "14.1. UTF8STR_CSタイプのStringPrepプロファイル"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_cs type definition in the NFSv4 protocol specification follows the profile named nfs4_cs_prep.",
      "ja": "NFSV4プロトコル仕様のUTF8STR_CS型定義のすべての使用は、NFS4_CS_PREPという名前のプロファイルに従います。"
    },
    {
      "indent": 0,
      "text": "14.1.1. Intended Applicability of the nfs4_cs_prep Profile",
      "section_title": true,
      "ja": "14.1.1. NFS4_CS_PREPプロファイルの意図された適用性"
    },
    {
      "indent": 3,
      "text": "The utf8str_cs type is a case-sensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming components and pathnames. Components and pathnames are stored on the server's file system. Two valid distinct UTF-8 strings might be the same after processing via the utf8str_cs profile. If the strings are two names inside a directory, the NFSv4.1 server will need to either:",
      "ja": "UTF8STR_CS型は、UTF-8文字の大文字と小文字が区別されます。NFSV4.1での主な使用は、コンポーネントとパス名の名前付けです。コンポーネントとパス名はサーバーのファイルシステムに保存されています。2つの有効な異なるUTF-8文字列は、UTF8STR_CSプロファイルを介した処理後に同じになる可能性があります。文字列がディレクトリ内の2つの名前の場合、NFSV4.1サーバーは次のいずれかを必要とします。"
    },
    {
      "indent": 3,
      "text": "* disallow the creation of a second name if its post-processed form collides with that of an existing name, or",
      "ja": "* 後処理フォームが既存の名前のものと衝突した場合、2番目の名前の作成を許可しません。"
    },
    {
      "indent": 3,
      "text": "* allow the creation of the second name, but arrange so that after post-processing, the second name is different than the post-processed form of the first name.",
      "ja": "* 2番目の名前の作成を許可しますが、後処理後に、2番目の名前は最初の名前の後処理形式とは異なります。"
    },
    {
      "indent": 0,
      "text": "14.1.2. Character Repertoire of nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.2. NFS4_CS_Prepの文字レパートリー"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "NFS4_CS_PREPプロファイルは、StringPrepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSV4.1の実装は3.2に限定されません。"
    },
    {
      "indent": 0,
      "text": "14.1.3. Mapping Used by nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.3. NFS4_CS_CREPによって使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "NFS4_CS_PREPプロファイルは、StringPrepから次の表を使用したマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1."
    },
    {
      "indent": 3,
      "text": "Table B.2 is normally not part of the nfs4_cs_prep profile as it is primarily for dealing with case-insensitive comparisons. However, if the NFSv4.1 file server supports the case_insensitive file system attribute, and if case_insensitive is TRUE, the NFSv4.1 server MUST use Table B.2 (in addition to Table B1) when processing utf8str_cs strings, and the NFSv4.1 client MUST assume Table B.2 (in addition to Table B.1) is being used.",
      "ja": "表B.2は通常、NFS4_CS_PREPプロファイルの一部ではありません。これは主に大文字と小文字を区別しない比較を扱うためのものです。ただし、NFSV4.1ファイルサーバーがcase_insensivent file属性をサポートしている場合、case_insensitiveがtrueの場合、utf8str_cs文字列を処理するときに（表B1に加えて）テーブルB.2を使用する必要があります。クライアントは、（表B.1に加えて）テーブルB.2を使用している必要があります。"
    },
    {
      "indent": 3,
      "text": "If the case_preserving attribute is present and set to FALSE, then the NFSv4.1 server MUST use Table B.2 to map case when processing utf8str_cs strings. Whether the server maps from lower to upper case or from upper to lower case is an implementation dependency.",
      "ja": "case_preving属性が存在し、falseに設定されている場合、NFSV4.1サーバーは、utf8str_cs文字列を処理するときにケースをマッピングするためにテーブルB.2をマップする必要があります。サーバーが下から大文字へ、または上限から小文字まで、実装の依存関係があるかどうか。"
    },
    {
      "indent": 0,
      "text": "14.1.4. Normalization used by nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.4. NFS4_CS_Prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile does not specify a normalization form. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize utf8str_cs strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).",
      "ja": "NFS4_CS_PREPプロファイルは正規化フォームを指定しません。この仕様の後半の改訂は、特定の正規化フォームを指定することができます。したがって、サーバーとクライアントは、プロトコル要求と応答内に正規化されていない文字を受信できることを期待できます。動作環境が正規化を必要とする場合、実装は、（クライアント）またはローカルファイルシステム（サーバ）に情報を提示する前に、プロトコル内のutf8str_cs文字列を正規化する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.1.5. Prohibited Output for nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.5. NFS4_CS_Prepの禁止出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile RECOMMENDS prohibiting the use of the following tables from stringprep:",
      "ja": "NFS4_CS_PREPプロファイルは、StringPrepから次のテーブルを使用することを禁止することを推奨します。"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 0,
      "text": "14.1.6. Bidirectional Output for nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.6. NFS4_CS_CREPの双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile does not specify any checking of bidirectional strings.",
      "ja": "NFS4_CS_PREPプロファイルは、双方向文字列のチェックを指定しません。"
    },
    {
      "indent": 0,
      "text": "14.2. Stringprep Profile for the utf8str_cis Type",
      "section_title": true,
      "ja": "14.2. UTF8STR_CISタイプのStringPrepプロファイル"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_cis type definition in the NFSv4.1 protocol specification follows the profile named nfs4_cis_prep.",
      "ja": "NFSV4.1プロトコル仕様のUTF8STR_CIS型定義のすべての使用は、NFS4_CIS_PREPという名前のプロファイルに従います。"
    },
    {
      "indent": 0,
      "text": "14.2.1. Intended Applicability of the nfs4_cis_prep Profile",
      "section_title": true,
      "ja": "14.2.1. NFS4_CIS_PREPプロファイルの意図された適用性"
    },
    {
      "indent": 3,
      "text": "The utf8str_cis type is a case-insensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming NFS servers.",
      "ja": "UTF8STR_CISタイプは、UTF-8文字の大文字と小文字を区別しません。NFSV4.1での主な使用は、NFSサーバーの名前を付けます。"
    },
    {
      "indent": 0,
      "text": "14.2.2. Character Repertoire of nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.2. NFS4_CIS_Prepの文字レパートリー"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "NFS4_CIS_PREPプロファイルは、StringPrepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSV4.1の実装は3.2に限定されません。"
    },
    {
      "indent": 0,
      "text": "14.2.3. Mapping Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.3. NFS4_CIS_Prepで使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "NFS4_CIS_PREPプロファイルは、StringPrepから次の表を使用したマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1."
    },
    {
      "indent": 6,
      "text": "Table B.2",
      "ja": "表B.2"
    },
    {
      "indent": 0,
      "text": "14.2.4. Normalization Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.4. NFS4_CIS_Prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies using Unicode normalization form KC, as described in stringprep.",
      "ja": "NFS4_CIS_PREPプロファイルは、StringPrepで説明されているように、Unicode正規化フォームKCを使用して指定します。"
    },
    {
      "indent": 0,
      "text": "14.2.5. Prohibited Output for nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.5. NFS4_CIS_PREPの禁止出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies prohibiting using the following tables from stringprep:",
      "ja": "NFS4_CIS_PREPプロファイルは、StringPrepから次の表を使用して禁止を指定します。"
    },
    {
      "indent": 6,
      "text": "Table C.1.2",
      "ja": "表C.1.2"
    },
    {
      "indent": 6,
      "text": "Table C.2.2",
      "ja": "表C.2.2"
    },
    {
      "indent": 6,
      "text": "Table C.3",
      "ja": "表C.3"
    },
    {
      "indent": 6,
      "text": "Table C.4",
      "ja": "表C.4"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 6,
      "text": "Table C.7",
      "ja": "表C.7"
    },
    {
      "indent": 6,
      "text": "Table C.8",
      "ja": "表C.8"
    },
    {
      "indent": 6,
      "text": "Table C.9",
      "ja": "表C.9"
    },
    {
      "indent": 0,
      "text": "14.2.6. Bidirectional Output for nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.6. NFS4_CIS_Prepの双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies checking bidirectional strings as described in stringprep's Section 6.",
      "ja": "NFS4_CIS_PREPプロファイルは、StringPrepのセクション6で説明されているように双方向文字列をチェックすることを指定します。"
    },
    {
      "indent": 0,
      "text": "14.3. Stringprep Profile for the utf8str_mixed Type",
      "section_title": true,
      "ja": "14.3. utf8str_mixed型のStringPrepプロファイル"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_mixed type definition in the NFSv4.1 protocol specification follows the profile named nfs4_mixed_prep.",
      "ja": "NFSV4.1プロトコル仕様のutf8str_mixed型定義のすべての使用は、nfs4_mixed_prepという名前のプロファイルに従います。"
    },
    {
      "indent": 0,
      "text": "14.3.1. Intended Applicability of the nfs4_mixed_prep Profile",
      "section_title": true,
      "ja": "14.3.1. NFS4_MIXED_PREPプロファイルの意図された適用性"
    },
    {
      "indent": 3,
      "text": "The utf8str_mixed type is a string of UTF-8 characters, with a prefix that is case sensitive, a separator equal to '@', and a suffix that is a fully qualified domain name. Its primary use in NFSv4.1 is for naming principals identified in an Access Control Entry.",
      "ja": "UTF8STR_MIXEDタイプは、大文字と小文字が区別されるプレフィックス、「@」に等しい区切り文字、完全修飾ドメイン名であるサフィックスを持つ、UTF-8文字の文字列です。NFSV4.1での主な使用は、アクセス制御エントリで識別された命名の原則です。"
    },
    {
      "indent": 0,
      "text": "14.3.2. Character Repertoire of nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.2. NFS4_MIXED_PREPの文字レパートリー"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "NFS4_MIXED_PREPプロファイルは、StringPrepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSV4.1の実装は3.2に限定されません。"
    },
    {
      "indent": 0,
      "text": "14.3.3. Mapping Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.3.3. NFS4_CIS_Prepで使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "For the prefix and the separator of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following table from stringprep:",
      "ja": "utf8str_mixed文字列のプレフィックスと区切り文字の場合、NFS4_MIXED_PREPプロファイルはStringPrepから次の表を使用してマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1."
    },
    {
      "indent": 3,
      "text": "For the suffix of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "UTF8STR_MIXED文字列のサフィックスの場合、NFS4_MIXED_PREPプロファイルはStringPrepから次の表を使用したマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1."
    },
    {
      "indent": 6,
      "text": "Table B.2",
      "ja": "表B.2"
    },
    {
      "indent": 0,
      "text": "14.3.4. Normalization Used by nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.4. NFS4_mixed_prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies using Unicode normalization form KC, as described in stringprep.",
      "ja": "nfs4_mixed_prepプロファイルは、StringPrepで説明されているように、Unicode正規化フォームKCを使用して指定します。"
    },
    {
      "indent": 0,
      "text": "14.3.5. Prohibited Output for nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.5. NFS4_MIXED_PREPのための禁止出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies prohibiting using the following tables from stringprep:",
      "ja": "NFS4_MIXED_PREPプロファイルは、StringPrepから次の表を使用して禁止を指定します。"
    },
    {
      "indent": 6,
      "text": "Table C.1.2",
      "ja": "表C.1.2"
    },
    {
      "indent": 6,
      "text": "Table C.2.2",
      "ja": "表C.2.2"
    },
    {
      "indent": 6,
      "text": "Table C.3",
      "ja": "表C.3"
    },
    {
      "indent": 6,
      "text": "Table C.4",
      "ja": "表C.4"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 6,
      "text": "Table C.7",
      "ja": "表C.7"
    },
    {
      "indent": 6,
      "text": "Table C.8",
      "ja": "表C.8"
    },
    {
      "indent": 6,
      "text": "Table C.9",
      "ja": "表C.9"
    },
    {
      "indent": 0,
      "text": "14.3.6. Bidirectional Output for nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.6. NFS4_MIXED_PREPの双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies checking bidirectional strings as described in stringprep's Section 6.",
      "ja": "NFS4_MIXED_PREPプロファイルは、StringPrepのセクション6で説明されているように双方向文字列をチェックすることを指定します。"
    },
    {
      "indent": 0,
      "text": "14.4. UTF-8 Capabilities",
      "section_title": true,
      "ja": "14.4. UTF-8機能"
    },
    {
      "indent": 3,
      "text": "const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;\nconst FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef uint32_t fs_charset_cap4;",
      "ja": "typedef uint32_t fs_charset_cap4;"
    },
    {
      "indent": 3,
      "text": "Because some operating environments and file systems do not enforce character set encodings, NFSv4.1 supports the fs_charset_cap attribute (Section 5.8.2.11) that indicates to the client a file system's UTF-8 capabilities. The attribute is an integer containing a pair of flags. The first flag is FSCHARSET_CAP4_CONTAINS_NON_UTF8, which, if set to one, tells the client that the file system contains non-UTF-8 characters, and the server will not convert non-UTF characters to UTF-8 if the client reads a symbolic link or directory, neither will operations with component names or pathnames in the arguments convert the strings to UTF-8. The second flag is FSCHARSET_CAP4_ALLOWS_ONLY_UTF8, which, if set to one, indicates that the server will accept (and generate) only UTF-8 characters on the file system. If FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set to one, FSCHARSET_CAP4_CONTAINS_NON_UTF8 MUST be set to zero. FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 SHOULD always be set to one.",
      "ja": "一部のオペレーティング環境とファイルシステムは文字セットエンコーディングを強制しないため、NFSV4.1はクライアントにファイルシステムのUTF-8機能を示すFS_CHARSET_CAP属性（セクション5.8.2.11）をサポートしています。属性は、一対のフラグを含む整数です。最初のフラグはfscharset_cap4_contains_non_utf8です。これは、1に設定されている場合、ファイルシステムにUTF-8文字以外の文字が含まれていることをクライアントに指示し、クライアントがシンボリックリンクを読み取る場合はUTF-8にUTF-8に変換しません。ディレクトリでは、引数内のコンポーネント名またはパス名を操作しません。引数内の文字列をUTF-8に変換しません。2番目のフラグはfscharset_cap4_allows_only_utf8です。これは、1に設定されている場合は、サーバーがファイルシステム上のUTF-8文字のみを受け入れる（および生成）ことを示します。fscharset_cap4_allows_only_utf8が1に設定されている場合、fscharset_cap4_contains_non_utf8はゼロに設定する必要があります。fscharset_cap4_allows_only_utf8は常に1に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.5. UTF-8 Related Errors",
      "section_title": true,
      "ja": "14.5. UTF-8関連エラー"
    },
    {
      "indent": 3,
      "text": "Where the client sends an invalid UTF-8 string, the server should return NFS4ERR_INVAL (see Table 11). This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full UCS character.",
      "ja": "クライアントが無効なUTF-8文字列を送信する場合、サーバーはNFS4ERR_INVALを返す必要があります（表11を参照）。これには、不適切な接頭辞が検出され、COUNTがフルUCS文字を構成しない末尾バイトを含む場合が含まれます。"
    },
    {
      "indent": 3,
      "text": "Where the client-supplied string is valid UTF-8 but contains characters that are not supported by the server as a value for that string (e.g., names containing characters outside of Unicode plane 0 on file systems that fail to support such characters despite their presence in the Unicode standard), the server should return NFS4ERR_BADCHAR.",
      "ja": "クライアント提供の文字列は有効なUTF-8であるが、その文字列の値としてサーバでサポートされていない文字（例えば、そのような文字をサポートできないファイルシステムでは、そのような文字をサポートできないファイルシステムの名前として含む名前）が含まれています。Unicode Standardでは、サーバーはNFS4ERR_BADCHARを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Where a UTF-8 string is used as a file name, and the file system (while supporting all of the characters within the name) does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME (Table 11). This includes situations in which the server file system imposes a normalization constraint on name strings, but will also include such situations as file system prohibitions of \".\" and \"..\" as file names for certain operations, and other such constraints.",
      "ja": "UTF-8文字列がファイル名として使用され、ファイルシステム（名前内のすべての文字をサポートしている間）がその特定の名前を使用することを許可しない場合、サーバーはエラーNFS4ERR_BADNAMEを返す必要があります（表11）。これには、サーバーファイルシステムがネーム文字列に対して正規化制約を課す状況が含まれますが、ファイルシステムの禁止としてのそのような状況も含まれます。特定の操作のファイル名として、その他のその他の制約として「..」。"
    },
    {
      "indent": 0,
      "text": "15. Error Values",
      "section_title": true,
      "ja": "15. エラー値"
    },
    {
      "indent": 3,
      "text": "NFS error numbers are assigned to failed operations within a Compound (COMPOUND or CB_COMPOUND) request. A Compound request contains a number of NFS operations that have their results encoded in sequence in a Compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the Compound request will be terminated.",
      "ja": "NFSエラー番号は、複合（複合またはCB_COMPOUND）要求内の失敗した操作に割り当てられています。複合要求には、複合応答の中で順番に符号化された結果を有する多数のNFS操作が含まれています。成功した操作の結果は、NFS4_OKのステータスとそれに続く操作の符号化結果で構成されます。NFS操作が失敗した場合は、応答にエラーステータスが入力され、複合要求は終了します。"
    },
    {
      "indent": 0,
      "text": "15.1. Error Definitions",
      "section_title": true,
      "ja": "15.1. エラー定義"
    },
    {
      "indent": 4,
      "text": "+===================================+========+===================+\n| Error                             | Number | Description       |\n+===================================+========+===================+\n| NFS4_OK                           | 0      | Section 15.1.3.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ACCESS                    | 13     | Section 15.1.6.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ATTRNOTSUPP               | 10032  | Section 15.1.15.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ADMIN_REVOKED             | 10047  | Section 15.1.5.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BACK_CHAN_BUSY            | 10057  | Section 15.1.12.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADCHAR                   | 10040  | Section 15.1.7.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADHANDLE                 | 10001  | Section 15.1.2.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADIOMODE                 | 10049  | Section 15.1.10.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADLAYOUT                 | 10050  | Section 15.1.10.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADNAME                   | 10041  | Section 15.1.7.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADOWNER                  | 10039  | Section 15.1.15.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADSESSION                | 10052  | Section 15.1.11.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADSLOT                   | 10053  | Section 15.1.11.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADTYPE                   | 10007  | Section 15.1.4.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BADXDR                    | 10036  | Section 15.1.1.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_COOKIE                | 10003  | Section 15.1.1.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_HIGH_SLOT             | 10077  | Section 15.1.11.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_RANGE                 | 10042  | Section 15.1.8.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_SEQID                 | 10026  | Section 15.1.16.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_SESSION_DIGEST        | 10051  | Section 15.1.12.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_BAD_STATEID               | 10025  | Section 15.1.5.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_CB_PATH_DOWN              | 10048  | Section 15.1.11.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_CLID_INUSE                | 10017  | Section 15.1.13.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_CLIENTID_BUSY             | 10074  | Section 15.1.13.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_COMPLETE_ALREADY          | 10054  | Section 15.1.9.1  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_CONN_NOT_BOUND_TO_SESSION | 10055  | Section 15.1.11.6 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DEADLOCK                  | 10045  | Section 15.1.8.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DEADSESSION               | 10078  | Section 15.1.11.5 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DELAY                     | 10008  | Section 15.1.1.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DELEG_ALREADY_WANTED      | 10056  | Section 15.1.14.1 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DELEG_REVOKED             | 10087  | Section 15.1.5.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DENIED                    | 10010  | Section 15.1.8.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DIRDELEG_UNAVAIL          | 10084  | Section 15.1.14.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_DQUOT                     | 69     | Section 15.1.4.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ENCR_ALG_UNSUPP           | 10079  | Section 15.1.13.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_EXIST                     | 17     | Section 15.1.4.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_EXPIRED                   | 10011  | Section 15.1.5.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_FBIG                      | 27     | Section 15.1.4.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_FHEXPIRED                 | 10014  | Section 15.1.2.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_FILE_OPEN                 | 10046  | Section 15.1.4.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_GRACE                     | 10013  | Section 15.1.9.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_HASH_ALG_UNSUPP           | 10072  | Section 15.1.13.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_INVAL                     | 22     | Section 15.1.1.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_IO                        | 5      | Section 15.1.4.6  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ISDIR                     | 21     | Section 15.1.2.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LAYOUTTRYLATER            | 10058  | Section 15.1.10.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LAYOUTUNAVAILABLE         | 10059  | Section 15.1.10.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LEASE_MOVED               | 10031  | Section 15.1.16.2 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LOCKED                    | 10012  | Section 15.1.8.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LOCKS_HELD                | 10037  | Section 15.1.8.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LOCK_NOTSUPP              | 10043  | Section 15.1.8.6  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_LOCK_RANGE                | 10028  | Section 15.1.8.7  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_MINOR_VERS_MISMATCH       | 10021  | Section 15.1.3.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_MLINK                     | 31     | Section 15.1.4.7  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_MOVED                     | 10019  | Section 15.1.2.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NAMETOOLONG               | 63     | Section 15.1.7.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOENT                     | 2      | Section 15.1.4.8  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOFILEHANDLE              | 10020  | Section 15.1.2.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOMATCHING_LAYOUT         | 10060  | Section 15.1.10.5 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOSPC                     | 28     | Section 15.1.4.9  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOTDIR                    | 20     | Section 15.1.2.6  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOTEMPTY                  | 66     | Section 15.1.4.10 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOTSUPP                   | 10004  | Section 15.1.1.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOT_ONLY_OP               | 10081  | Section 15.1.3.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NOT_SAME                  | 10027  | Section 15.1.15.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NO_GRACE                  | 10033  | Section 15.1.9.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_NXIO                      | 6      | Section 15.1.16.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_OLD_STATEID               | 10024  | Section 15.1.5.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_OPENMODE                  | 10038  | Section 15.1.8.8  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_OP_ILLEGAL                | 10044  | Section 15.1.3.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_OP_NOT_IN_SESSION         | 10071  | Section 15.1.3.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_PERM                      | 1      | Section 15.1.6.2  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_PNFS_IO_HOLE              | 10075  | Section 15.1.10.6 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_PNFS_NO_LAYOUT            | 10080  | Section 15.1.10.7 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RECALLCONFLICT            | 10061  | Section 15.1.14.3 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RECLAIM_BAD               | 10034  | Section 15.1.9.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RECLAIM_CONFLICT          | 10035  | Section 15.1.9.5  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_REJECT_DELEG              | 10085  | Section 15.1.14.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_REP_TOO_BIG               | 10066  | Section 15.1.3.6  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_REP_TOO_BIG_TO_CACHE      | 10067  | Section 15.1.3.7  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_REQ_TOO_BIG               | 10065  | Section 15.1.3.8  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RESTOREFH                 | 10030  | Section 15.1.16.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RETRY_UNCACHED_REP        | 10068  | Section 15.1.3.9  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_RETURNCONFLICT            | 10086  | Section 15.1.10.8 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_ROFS                      | 30     | Section 15.1.4.11 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SAME                      | 10009  | Section 15.1.15.4 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SHARE_DENIED              | 10015  | Section 15.1.8.9  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SEQUENCE_POS              | 10064  | Section 15.1.3.10 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SEQ_FALSE_RETRY           | 10076  | Section 15.1.11.7 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SEQ_MISORDERED            | 10063  | Section 15.1.11.8 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SERVERFAULT               | 10006  | Section 15.1.1.6  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_STALE                     | 70     | Section 15.1.2.7  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_STALE_CLIENTID            | 10022  | Section 15.1.13.5 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_STALE_STATEID             | 10023  | Section 15.1.16.5 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_SYMLINK                   | 10029  | Section 15.1.2.8  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_TOOSMALL                  | 10005  | Section 15.1.1.7  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_TOO_MANY_OPS              | 10070  | Section 15.1.3.11 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_UNKNOWN_LAYOUTTYPE        | 10062  | Section 15.1.10.9 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_UNSAFE_COMPOUND           | 10069  | Section 15.1.3.12 |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_WRONGSEC                  | 10016  | Section 15.1.6.3  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_WRONG_CRED                | 10082  | Section 15.1.6.4  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_WRONG_TYPE                | 10083  | Section 15.1.2.9  |\n+-----------------------------------+--------+-------------------+\n| NFS4ERR_XDEV                      | 18     | Section 15.1.4.12 |\n+-----------------------------------+--------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 11: Protocol Error Definitions",
      "ja": "表11：プロトコルエラーの定義"
    },
    {
      "indent": 0,
      "text": "15.1.1. General Errors",
      "section_title": true,
      "ja": "15.1.1. 一般的なエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors that are applicable to a broad set of different purposes.",
      "ja": "このセクションでは、幅広い異なる目的に適用可能なエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.1.1. NFS4ERR_BADXDR (Error Code 10036)",
      "section_title": true,
      "ja": "15.1.1.1. NFS4ERR_BADXDR（エラーコード10036）"
    },
    {
      "indent": 3,
      "text": "The arguments for this operation do not match those specified in the XDR definition. This includes situations in which the request ends before all the arguments have been seen. Note that this error applies when fixed enumerations (these include booleans) have a value within the input stream that is not valid for the enum. A replier may pre-parse all operations for a Compound procedure before doing any operation execution and return RPC-level XDR errors in that case.",
      "ja": "この操作の引数は、XDR定義で指定されているものと一致しません。これには、すべての引数が見られた前に要求が終了する状況が含まれます。このエラーは、固定列挙型（これらのINCLUDE BOOLEANS）が入力ストリーム内に列挙性に有効でない場合に適用されます。絞り目は、操作実行を行う前に、複合手順のすべての操作を事前に解析し、その場合はRPCレベルのXDRエラーを返すことができます。"
    },
    {
      "indent": 0,
      "text": "15.1.1.2. NFS4ERR_BAD_COOKIE (Error Code 10003)",
      "section_title": true,
      "ja": "15.1.1.2. NFS4ERR_BAD_COOKIE（エラーコード10003）"
    },
    {
      "indent": 3,
      "text": "Used for operations that provide a set of information indexed by some quantity provided by the client or cookie sent by the server for an earlier invocation. Where the value cannot be used for its intended purpose, this error results.",
      "ja": "以前の呼び出しに対してサーバーによって送信されたクライアントまたはCookieによって提供される数量によって索引付けされた一連の情報を提供する操作に使用されます。その値を目的の目的に使用できない場合、このエラーは発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.1.3. NFS4ERR_DELAY (Error Code 10008)",
      "section_title": true,
      "ja": "15.1.1.3. NFS4ERR_DELAY（エラーコード10008）"
    },
    {
      "indent": 3,
      "text": "For any of a number of reasons, the replier could not process this operation in what was deemed a reasonable time. The client should wait and then try the request with a new slot and sequence value.",
      "ja": "いくつかの理由のいずれにも、replierは妥当な時間と考えられていたものでこの操作を処理できませんでした。クライアントは待機してから、新しいスロットとシーケンス値で要求を試してください。"
    },
    {
      "indent": 3,
      "text": "Some examples of scenarios that might lead to this situation:",
      "ja": "この状況につながる可能性があるシナリオのいくつかの例："
    },
    {
      "indent": 3,
      "text": "* A server that supports hierarchical storage receives a request to process a file that had been migrated.",
      "ja": "* 階層ストレージをサポートするサーバーは、移行されたファイルを処理するための要求を受け取ります。"
    },
    {
      "indent": 3,
      "text": "* An operation requires a delegation recall to proceed, but the need to wait for this delegation to be recalled and returned makes processing this request in a timely fashion impossible.",
      "ja": "* 操作には委任が回答する必要がありますが、この委任を回収して返却されるのを待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "* A request is being performed on a session being migrated from another server as described in Section 11.14.3, and the lack of full information about the state of the session on the source makes it impossible to process the request immediately.",
      "ja": "* セクション11.14.3で説明されているように別のサーバーから移行されているセッションで要求が実行されており、ソース上のセッションの状態に関する完全な情報の欠如はすぐに要求を処理することを不可能にします。"
    },
    {
      "indent": 3,
      "text": "In such cases, returning the error NFS4ERR_DELAY allows necessary preparatory operations to proceed without holding up requester resources such as a session slot. After delaying for period of time, the client can then re-send the operation in question, often as part of a nearly identical request. Because of the need to avoid spurious reissues of non-idempotent operations and to avoid acting in response to NFS4ERR_DELAY errors returned on responses returned from the replier's reply cache, integration with the session-provided reply cache is necessary. There are a number of cases to deal with, each of which requires different sorts of handling by the requester and replier:",
      "ja": "このような場合は、エラーを返すNFS4ERR_DELAYにより、セッションスロットなどのリクエスタリソースを保持せずに必要な準備操作を進めることができます。その期間を遅らせた後、クライアントは、問題の操作をしばしばほぼ同じ要求の一部として再送信できます。非アイデンティックな操作のスプリアスの再発を避け、レプリアの応答キャッシュから返された応答で返されたNFS4ERR_DELAYエラーに応答してアクションを回避する必要があるため、セッション提供の応答キャッシュとの統合が必要です。対処するための多くのケースがあり、それぞれが要求者とreplierによって異なる種類の処理を必要とします。"
    },
    {
      "indent": 3,
      "text": "* If NFS4ERR_DELAY is returned on a SEQUENCE operation, the request is retried in full with the SEQUENCE operation containing the same slot and sequence values. In this case, the replier MUST avoid returning a response containing NFS4ERR_DELAY as the response to SEQUENCE solely because an earlier instance of the same request returned that error and it was stored in the reply cache. If the replier did this, the retries would not be effective as there would be no opportunity for the replier to see whether the condition that generated the NFS4ERR_DELAY had been rectified during the interim between the original request and the retry.",
      "ja": "* NFS4ERR_DELAYがシーケンス操作で返されると、要求は同じスロット値とシーケンス値を含むシーケンス操作で完全に再試行されます。この場合、レプリタは、同じ要求の以前のインスタンスがそのエラーを返し、それが応答キャッシュに格納されたため、順次の応答としてNFS4ERR_DELAYを含む応答を返信しなければなりません。REPLIERがこれをした場合、REPLIERが元の要求と再試行の間の暫定中にNFS4ERR_DELAYを生成した条件が修正されたかどうかを確認する機会がないため、再試行は有効ではありません。"
    },
    {
      "indent": 3,
      "text": "* If NFS4ERR_DELAY is returned on an operation other than SEQUENCE that validly appears as the first operation of a request, the handling is similar. The request can be retried in full without modification. In this case as well, the replier MUST avoid returning a response containing NFS4ERR_DELAY as the response to an initial operation of a request solely on the basis of its presence in the reply cache. If the replier did this, the retries would not be effective as there would be no opportunity for the replier to see whether the condition that generated the NFS4ERR_DELAY had been rectified during the interim between the original request and the retry.",
      "ja": "* リクエストの最初の操作として有効に表示されるシーケンス以外の操作でNFS4ERR_DELAYが返されると、処理は似ています。リクエストは変更なしで完全に再試行できます。この場合も、レプリタは、返信キャッシュ内のその存在に基づいて、要求の初期操作に対する応答としてNFS4ERR_DELAYを含む応答を返信しなければならない。REPLIERがこれをした場合、REPLIERが元の要求と再試行の間の暫定中にNFS4ERR_DELAYを生成した条件が修正されたかどうかを確認する機会がないため、再試行は有効ではありません。"
    },
    {
      "indent": 3,
      "text": "* If NFS4ERR_DELAY is returned on an operation other than the first in the request, the request when retried MUST contain a SEQUENCE operation that is different than the original one, with either the slot ID or the sequence value different from that in the original request. Because requesters do this, there is no need for the replier to take special care to avoid returning an NFS4ERR_DELAY error obtained from the reply cache. When no non-idempotent operations have been processed before the NFS4ERR_DELAY was returned, the requester should retry the request in full, with the only difference from the original request being the modification to the slot ID or sequence value in the reissued SEQUENCE operation.",
      "ja": "* NFS4ERR_DELAYが最初に要求の最初以外の操作で返された場合、再試行したときの要求には、元の要求とは異なるスロットIDまたはシーケンス値のいずれかで、元のものとは異なるシーケンス操作が含まれている必要があります。リクエスタはこれを行うため、返信キャッシュから取得したNFS4ERR_DELAYエラーを返却しないように、レプリタが特別な注意を払う必要はありません。NFS4ERR_DELAYが返される前に非IDEMPOTENT操作が処理されていない場合、要求者はリクエストを完全に再試行する必要があります。これは、元の要求からの唯一の違いがスロットIDまたはreassuedシーケンス操作でのシーケンス値の変更です。"
    },
    {
      "indent": 3,
      "text": "* When NFS4ERR_DELAY is returned on an operation other than the first within a request and there has been a non-idempotent operation processed before the NFS4ERR_DELAY was returned, reissuing the request as is normally done would incorrectly cause the re-execution of the non-idempotent operation.",
      "ja": "* NFS4ERR_DELAYがリクエスト内の最初の操作で返され、NFS4ERR_DELAYが返される前に処理されていない操作が終了した場合は、通常行われている要求を再発行しています。。"
    },
    {
      "indent": 6,
      "text": "To avoid this situation, the client should reissue the request without the non-idempotent operation. The request still must use a SEQUENCE operation with either a different slot ID or sequence value from the SEQUENCE in the original request. Because this is done, there is no way the replier could avoid spuriously re-executing the non-idempotent operation since the different SEQUENCE parameters prevent the requester from recognizing that the non-idempotent operation is being retried.",
      "ja": "この状況を回避するために、クライアントは非IDEmpotent操作なしで要求を再発行する必要があります。要求は、元の要求内のシーケンスから異なるスロットIDまたはシーケンス値のいずれかでシーケンス操作を使用する必要があります。これが行われるため、レステントパラメータが依頼者が非iDEmPotent操作が再試行されていることを認識できないので、絞り込みで非idempotent演算を再実行することを避けることはできませんでした。"
    },
    {
      "indent": 3,
      "text": "Note that without the ability to return NFS4ERR_DELAY and the requester's willingness to re-send when receiving it, deadlock might result. For example, if a recall is done, and if the delegation return or operations preparatory to delegation return are held up by other operations that need the delegation to be returned, session slots might not be available. The result could be deadlock.",
      "ja": "NFS4ERR_DELAYとリクエスタの受信時にリクエストの意思を返す機能がなく、デッドロックが発生する可能性があります。たとえば、リコールが完了した場合、および委任を返す準備の準備の準備または操作が返されることを必要とする他の操作によって保持されている場合、セッションスロットは利用できない可能性があります。結果はデッドロックになる可能性があります。"
    },
    {
      "indent": 0,
      "text": "15.1.1.4. NFS4ERR_INVAL (Error Code 22)",
      "section_title": true,
      "ja": "15.1.1.4. NFS4ERR_INVAL（エラーコード22）"
    },
    {
      "indent": 3,
      "text": "The arguments for this operation are not valid for some reason, even though they do match those specified in the XDR definition for the request.",
      "ja": "この操作の引数は、要求のXDR定義で指定されたものと一致するとしても、何らかの理由では無効です。"
    },
    {
      "indent": 0,
      "text": "15.1.1.5. NFS4ERR_NOTSUPP (Error Code 10004)",
      "section_title": true,
      "ja": "15.1.1.5. NFS4ERR_NOTSUPP（エラーコード10004）"
    },
    {
      "indent": 3,
      "text": "Operation not supported, either because the operation is an OPTIONAL one and is not supported by this server or because the operation MUST NOT be implemented in the current minor version.",
      "ja": "操作はオプションのものであり、このサーバーではサポートされていないため、または現在のマイナーバージョンで実行されていないため、サポートされていない操作はサポートされていません。"
    },
    {
      "indent": 0,
      "text": "15.1.1.6. NFS4ERR_SERVERFAULT (Error Code 10006)",
      "section_title": true,
      "ja": "15.1.1.6. NFS4ERR_SERVERFAULT（エラーコード10006）"
    },
    {
      "indent": 3,
      "text": "An error occurred on the server that does not map to any of the specific legal NFSv4.1 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.",
      "ja": "特定の有効なNFSV4.1プロトコルエラー値のいずれかにマッピングされないサーバーでエラーが発生しました。クライアントはこれを適切なエラーに変換する必要があります。UNIXクライアントはこれをEIOに翻訳することを選択できます。"
    },
    {
      "indent": 0,
      "text": "15.1.1.7. NFS4ERR_TOOSMALL (Error Code 10005)",
      "section_title": true,
      "ja": "15.1.1.7. NFS4ERR_TOOSMALL（エラーコード10005）"
    },
    {
      "indent": 3,
      "text": "Used where an operation returns a variable amount of data, with a limit specified by the client. Where the data returned cannot be fit within the limit specified by the client, this error results.",
      "ja": "クライアントによって指定された制限で、操作が可変量のデータを返す場合に使用されます。返されたデータがクライアントによって指定された制限内に適合することができない場合、このエラーは結果を生み出します。"
    },
    {
      "indent": 0,
      "text": "15.1.2. Filehandle Errors",
      "section_title": true,
      "ja": "15.1.2. ファイルハンドルエラー"
    },
    {
      "indent": 3,
      "text": "These errors deal with the situation in which the current or saved filehandle, or the filehandle passed to PUTFH intended to become the current filehandle, is invalid in some way. This includes situations in which the filehandle is a valid filehandle in general but is not of the appropriate object type for the current operation.",
      "ja": "これらのエラーは、現在のファイルハンドルになることを目的としたPUTFHに渡されたFileHandleが何らかの形で無効であるという状況を扱います。これには、FileHandleが一般的に有効なファイルハンドルであるが、現在の操作のための適切なオブジェクトタイプではない状況が含まれます。"
    },
    {
      "indent": 3,
      "text": "Where the error description indicates a problem with the current or saved filehandle, it is to be understood that filehandles are only checked for the condition if they are implicit arguments of the operation in question.",
      "ja": "エラー記述が現在または保存されたファイルハンドルに関する問題を示す場合、ファイルハンドルは、問題の操作の暗黙的な引数である場合にのみ条件についてのみチェックされることを理解されたい。"
    },
    {
      "indent": 0,
      "text": "15.1.2.1. NFS4ERR_BADHANDLE (Error Code 10001)",
      "section_title": true,
      "ja": "15.1.2.1. NFS4ERR_BADHANDLE（エラーコード10001）"
    },
    {
      "indent": 3,
      "text": "Illegal NFS filehandle for the current server. The current filehandle failed internal consistency checks. Once accepted as valid (by PUTFH), no subsequent status change can cause the filehandle to generate this error.",
      "ja": "現在のサーバーの不正なNFSファイルハンドル。現在のファイルハンドルが内部整合性チェックに失敗しました。有効（putfhによって）有効で受け入れられたら、その後のステータス変更はこのエラーを生成することはできません。"
    },
    {
      "indent": 0,
      "text": "15.1.2.2. NFS4ERR_FHEXPIRED (Error Code 10014)",
      "section_title": true,
      "ja": "15.1.2.2. NFS4ERR_FHExpired（エラーコード10014）"
    },
    {
      "indent": 3,
      "text": "A current or saved filehandle that is an argument to the current operation is volatile and has expired at the server.",
      "ja": "現在の操作の引数である現在または保存されたファイルハンドルは揮発性であり、サーバーで期限切れです。"
    },
    {
      "indent": 0,
      "text": "15.1.2.3. NFS4ERR_ISDIR (Error Code 21)",
      "section_title": true,
      "ja": "15.1.2.3. NFS4ERR_ISDIR（エラーコード21）"
    },
    {
      "indent": 3,
      "text": "The current or saved filehandle designates a directory when the current operation does not allow a directory to be accepted as the target of this operation.",
      "ja": "現在の操作によってディレクトリがこの操作の対象として受け入れることができない場合、現在または保存されたファイルハンドルはディレクトリを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.4. NFS4ERR_MOVED (Error Code 10019)",
      "section_title": true,
      "ja": "15.1.2.4. NFS4ERR_MOVED（エラーコード10019）"
    },
    {
      "indent": 3,
      "text": "The file system that contains the current filehandle object is not present at the server or is not accessible with the network address used. It may have been made accessible on a different set of network addresses, relocated or migrated to another server, or it may have never been present. The client may obtain the new file system location by obtaining the fs_locations or fs_locations_info attribute for the current filehandle. For further discussion, refer to Section 11.3.",
      "ja": "現在のFileHandleオブジェクトを含むファイルシステムはサーバーに存在しません。または使用されるネットワークアドレスではアクセスできません。他のサーバーに移動または移行された、または別のサーバーに移行された、または存在していない可能性があるか、またはそれが存在していない可能性があります。クライアントは、現在のファイルハンドルのFS_LOCATIONSまたはFS_LOCATIONS_INFO属性を取得することによって、新しいファイルシステムの場所を取得できます。詳細については、11.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "As with the case of NFS4ERR_DELAY, it is possible that one or more non-idempotent operations may have been successfully executed within a COMPOUND before NFS4ERR_MOVED is returned. Because of this, once the new location is determined, the original request that received the NFS4ERR_MOVED should not be re-executed in full. Instead, the client should send a new COMPOUND with any successfully executed non-idempotent operations removed. When the client uses the same session for the new COMPOUND, its SEQUENCE operation should use a different slot ID or sequence.",
      "ja": "NFS4ERR_DELAYの場合と同様に、NFS4ERR_MOUMEDが返される前に、1つまたは複数の非IDEPOTENT操作が複合体内で正常に実行された可能性がある可能性があります。このため、新しい場所が決定されると、NFS4ERR_MOVEDを受信した元の要求は完全に再実行しないでください。代わりに、クライアントは、首尾よく実行された非IDEmpotent操作を削除した状態で新しい化合物を送信する必要があります。クライアントが新しい化合物に対して同じセッションを使用すると、そのシーケンス操作は異なるスロットIDまたはシーケンスを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.1.2.5. NFS4ERR_NOFILEHANDLE (Error Code 10020)",
      "section_title": true,
      "ja": "15.1.2.5. NFS4ERR_NOFILEHANDLE（エラーコード10020）"
    },
    {
      "indent": 3,
      "text": "The logical current or saved filehandle value is required by the current operation and is not set. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires the current filehandle be set).",
      "ja": "論理電流または保存されたファイルハンドル値は、現在の操作によって必要とされ、設定されていません。これは、不正な複合操作の結果であり得る（現在のファイルハンドルを設定する操作の前に、PUTFHまたはPUTROOTFHも設定する前に）。"
    },
    {
      "indent": 0,
      "text": "15.1.2.6. NFS4ERR_NOTDIR (Error Code 20)",
      "section_title": true,
      "ja": "15.1.2.6. NFS4ERR_NOTDIR（エラーコード20）"
    },
    {
      "indent": 3,
      "text": "The current (or saved) filehandle designates an object that is not a directory for an operation in which a directory is required.",
      "ja": "現在の（または保存された）ファイルハンドルは、ディレクトリが必要な操作のためのディレクトリではないオブジェクトを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.7. NFS4ERR_STALE (Error Code 70)",
      "section_title": true,
      "ja": "15.1.2.7. NFS4ERR_STALE（エラーコード70）"
    },
    {
      "indent": 3,
      "text": "The current or saved filehandle value designating an argument to the current operation is invalid. The file referred to by that filehandle no longer exists or access to it has been revoked.",
      "ja": "現在の操作の引数を指定する現在または保存されたファイルハンドル値が無効です。そのファイルハンドルによって参照されていないファイルは、それに存在しなくなりましたが失効されました。"
    },
    {
      "indent": 0,
      "text": "15.1.2.8. NFS4ERR_SYMLINK (Error Code 10029)",
      "section_title": true,
      "ja": "15.1.2.8. NFS4ERR_SYMLINK（エラーコード10029）"
    },
    {
      "indent": 3,
      "text": "The current filehandle designates a symbolic link when the current operation does not allow a symbolic link as the target.",
      "ja": "現在の操作がターゲットとしてシンボリックリンクを許可しない場合、現在のファイルハンドルはシンボリックリンクを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.9. NFS4ERR_WRONG_TYPE (Error Code 10083)",
      "section_title": true,
      "ja": "15.1.2.9. NFS4ERR_WRONG_TYPE（エラーコード10083）"
    },
    {
      "indent": 3,
      "text": "The current (or saved) filehandle designates an object that is of an invalid type for the current operation, and there is no more specific error (such as NFS4ERR_ISDIR or NFS4ERR_SYMLINK) that applies. Note that in NFSv4.0, such situations generally resulted in the less-specific error NFS4ERR_INVAL.",
      "ja": "現在の（または保存された）FileHandleは、現在の操作に無効なタイプのオブジェクトを指定し、適用されるより具体的なエラー（NFS4ER_ISDIRまたはNFS4ERR_SYMLINKなど）はありません。NFSv4.0では、そのような状況では一般的に特定のエラーNFS4ERR_INVALが発生しました。"
    },
    {
      "indent": 0,
      "text": "15.1.3. Compound Structure Errors",
      "section_title": true,
      "ja": "15.1.3. 複合構造エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors that relate to the overall structure of a Compound request (by which we mean to include both COMPOUND and CB_COMPOUND), rather than to particular operations.",
      "ja": "このセクションでは、特定の操作よりもむしろ、複合要求の全体構造に関連するエラーについて説明します。"
    },
    {
      "indent": 3,
      "text": "There are a number of basic constraints on the operations that may appear in a Compound request. Sessions add to these basic constraints by requiring a Sequence operation (either SEQUENCE or CB_SEQUENCE) at the start of the Compound.",
      "ja": "複合要求に現れる可能性がある操作には、いくつかの基本的な制約があります。セッションは、化合物の開始時にシーケンス操作（シーケンスまたはCB_SEQUENCE）を必要とすることによってこれらの基本的な制約に追加します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.1. NFS_OK (Error code 0)",
      "section_title": true,
      "ja": "15.1.3.1. NFS_OK（エラーコード0）"
    },
    {
      "indent": 3,
      "text": "Indicates the operation completed successfully, in that all of the constituent operations completed without error.",
      "ja": "エラーなしですべての構成操作が完了したという点で、操作が完了したことを示します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH (Error code 10021)",
      "section_title": true,
      "ja": "15.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH（エラーコード10021）"
    },
    {
      "indent": 3,
      "text": "The minor version specified is not one that the current listener supports. This value is returned in the overall status for the Compound but is not associated with a specific operation since the results will specify a result count of zero.",
      "ja": "指定されたマイナーバージョンは、現在のリスナーがサポートするものではありません。この値は、化合物の全体的なステータスで返されますが、結果に結果がゼロの結果カウントを指定するため、特定の操作には関連付けられません。"
    },
    {
      "indent": 0,
      "text": "15.1.3.3. NFS4ERR_NOT_ONLY_OP (Error Code 10081)",
      "section_title": true,
      "ja": "15.1.3.3. NFS4ERR_NOT_ONLY_OP（エラーコード10081）"
    },
    {
      "indent": 3,
      "text": "Certain operations, which are allowed to be executed outside of a session, MUST be the only operation within a Compound whenever the Compound does not start with a Sequence operation. This error results when that constraint is not met.",
      "ja": "セッション以外で実行されることが許可されている特定の操作は、複合がシーケンス操作で始まらないときはいつでもコンパウンド内の唯一の操作でなければなりません。このエラーはその制約が満たされていないときに発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.4. NFS4ERR_OP_ILLEGAL (Error Code 10044)",
      "section_title": true,
      "ja": "15.1.3.4. NFS4ERR_OP_ILLEGAL（エラーコード10044）"
    },
    {
      "indent": 3,
      "text": "The operation code is not a valid one for the current Compound procedure. The opcode in the result stream matched with this error is the ILLEGAL value, although the value that appears in the request stream may be different. Where an illegal value appears and the replier pre-parses all operations for a Compound procedure before doing any operation execution, an RPC-level XDR error may be returned.",
      "ja": "操作コードは、現在の複合手順に有効なものではありません。このエラーと一致する結果ストリーム内のオペコードは不正値ですが、要求ストリームに表示される値は異なる場合があります。違法な値が表示され、Replierが操作実行を実行する前に、複合手順のすべての操作を事前に事前解析すると、RPCレベルのXDRエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.5. NFS4ERR_OP_NOT_IN_SESSION (Error Code 10071)",
      "section_title": true,
      "ja": "15.1.3.5. NFS4ERR_OP_NOT_IN_SESSION（エラーコード10071）"
    },
    {
      "indent": 3,
      "text": "Most forward operations and all callback operations are only valid within the context of a session, so that the Compound request in question MUST begin with a Sequence operation. If an attempt is made to execute these operations outside the context of session, this error results.",
      "ja": "ほとんどの前方操作とすべてのコールバック操作はセッションのコンテキスト内でのみ有効であるため、問題の複合要求はシーケンス操作で始める必要があります。セッションのコンテキスト外でこれらの操作を実行しようとすると、このエラーが発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.6. NFS4ERR_REP_TOO_BIG (Error Code 10066)",
      "section_title": true,
      "ja": "15.1.3.6. NFS4ERR_REP_TOO_BIG（エラーコード10066）"
    },
    {
      "indent": 3,
      "text": "The reply to a Compound would exceed the channel's negotiated maximum response size.",
      "ja": "化合物への返信は、チャネルのネゴシエートされた最大応答サイズを超えます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.7. NFS4ERR_REP_TOO_BIG_TO_CACHE (Error Code 10067)",
      "section_title": true,
      "ja": "15.1.3.7. NFS4ERR_REP_TOO_BIG_TO_CACHE（エラーコード10067）"
    },
    {
      "indent": 3,
      "text": "The reply to a Compound would exceed the channel's negotiated maximum size for replies cached in the reply cache when the Sequence for the current request specifies that this request is to be cached.",
      "ja": "現在の要求のシーケンスがこの要求をキャッシュすることを指定している場合、コンパウンドへの返信は、返信キャッシュでキャッシュされた返信のためのChangeのネゴシエートされた最大サイズを超えます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.8. NFS4ERR_REQ_TOO_BIG (Error Code 10065)",
      "section_title": true,
      "ja": "15.1.3.8. NFS4ERR_REQ_TOO_BIG（エラーコード10065）"
    },
    {
      "indent": 3,
      "text": "The Compound request exceeds the channel's negotiated maximum size for requests.",
      "ja": "複合要求は、要求のためのチャネルのネゴシエートされた最大サイズを超えています。"
    },
    {
      "indent": 0,
      "text": "15.1.3.9. NFS4ERR_RETRY_UNCACHED_REP (Error Code 10068)",
      "section_title": true,
      "ja": "15.1.3.9. NFS4ERR_RETRY_UNCACHED_REP（エラーコード10068）"
    },
    {
      "indent": 3,
      "text": "The requester has attempted a retry of a Compound that it previously requested not be placed in the reply cache.",
      "ja": "要求者は、以前に返信キャッシュに配置されていないことを予め要求した化合物のリトライを試みました。"
    },
    {
      "indent": 0,
      "text": "15.1.3.10. NFS4ERR_SEQUENCE_POS (Error Code 10064)",
      "section_title": true,
      "ja": "15.1.3.10. NFS4ERR_SEQUENCE_POS（エラーコード10064）"
    },
    {
      "indent": 3,
      "text": "A Sequence operation appeared in a position other than the first operation of a Compound request.",
      "ja": "複合要求の第1の動作以外の位置にシーケンス動作が現れた。"
    },
    {
      "indent": 0,
      "text": "15.1.3.11. NFS4ERR_TOO_MANY_OPS (Error Code 10070)",
      "section_title": true,
      "ja": "15.1.3.11. NFS4ERR_TOO_MANY_OPS（エラーコード10070）"
    },
    {
      "indent": 3,
      "text": "The Compound request has too many operations, exceeding the count negotiated when the session was created.",
      "ja": "複合要求には、セッションが作成されたときにネゴシエートされたカウントを超えた操作が多すぎます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.12. NFS4ERR_UNSAFE_COMPOUND (Error Code 10068)",
      "section_title": true,
      "ja": "15.1.3.12. NFS4ERR_UNSAFE_COMPOUND（エラーコード10068）"
    },
    {
      "indent": 3,
      "text": "The client has sent a COMPOUND request with an unsafe mix of operations -- specifically, with a non-idempotent operation that changes the current filehandle and that is not followed by a GETFH.",
      "ja": "クライアントは、現在のファイルハンドルを変更し、その後にGETFHを変更していないIDEMPOTENT操作を備えた、具体的には、安全でない操作の組み合わせで複合要求を送信しました。"
    },
    {
      "indent": 0,
      "text": "15.1.4. File System Errors",
      "section_title": true,
      "ja": "15.1.4. ファイルシステムエラー"
    },
    {
      "indent": 3,
      "text": "These errors describe situations that occurred in the underlying file system implementation rather than in the protocol or any NFSv4.x feature.",
      "ja": "これらのエラーは、プロトコルまたはNFSv4.x機能ではなく、基盤となるファイルシステム実装で発生した状況を説明しています。"
    },
    {
      "indent": 0,
      "text": "15.1.4.1. NFS4ERR_BADTYPE (Error Code 10007)",
      "section_title": true,
      "ja": "15.1.4.1. NFS4ERR_BADTYPE（エラーコード10007）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to create an object with an inappropriate type specified to CREATE. This may be because the type is undefined, because the type is not supported by the server, or because the type is not intended to be created by CREATE (such as a regular file or named attribute, for which OPEN is used to do the file creation).",
      "ja": "作成に指定された不適切な型を持つオブジェクトを作成しようとしました。これは、タイプがサーバーでサポートされていないため、またはタイプが作成されていないため、またはそのタイプが作成されていないため（通常のファイルや名前付き属性など、ファイルをファイルの実行するために使用されている場合に使用されている）というため、タイプは不定である可能性があります。作成）。"
    },
    {
      "indent": 0,
      "text": "15.1.4.2. NFS4ERR_DQUOT (Error Code 69)",
      "section_title": true,
      "ja": "15.1.4.2. NFS4ERR_DQUOT（エラーコード69）"
    },
    {
      "indent": 3,
      "text": "Resource (quota) hard limit exceeded. The user's resource limit on the server has been exceeded.",
      "ja": "リソース（クォータ）ハードリミティを超えました。サーバー上のユーザーのリソース制限を超えました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.3. NFS4ERR_EXIST (Error Code 17)",
      "section_title": true,
      "ja": "15.1.4.3. NFS4ERR_EXIST（エラーコード17）"
    },
    {
      "indent": 3,
      "text": "A file of the specified target name (when creating, renaming, or linking) already exists.",
      "ja": "指定されたターゲット名のファイル（作成、名前変更、またはリンク中）が既に存在します。"
    },
    {
      "indent": 0,
      "text": "15.1.4.4. NFS4ERR_FBIG (Error Code 27)",
      "section_title": true,
      "ja": "15.1.4.4. NFS4ERR_FBIG（エラーコード27）"
    },
    {
      "indent": 3,
      "text": "The file is too large. The operation would have caused the file to grow beyond the server's limit.",
      "ja": "ファイルが大きすぎます。操作により、ファイルがサーバーの制限を超えて拡大しました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.5. NFS4ERR_FILE_OPEN (Error Code 10046)",
      "section_title": true,
      "ja": "15.1.4.5. NFS4ERR_FILE_OPEN（エラーコード10046）"
    },
    {
      "indent": 3,
      "text": "The operation is not allowed because a file involved in the operation is currently open. Servers may, but are not required to, disallow linking-to, removing, or renaming open files.",
      "ja": "操作に関与するファイルが現在開いているため、操作はできません。サーバーは、オープンファイルの開いているファイルへのリンクへのリンク、削除、または名前の変更を禁止、禁止、または名前を変更することができます。"
    },
    {
      "indent": 0,
      "text": "15.1.4.6. NFS4ERR_IO (Error Code 5)",
      "section_title": true,
      "ja": "15.1.4.6. NFS4ERR_IO（エラーコード5）"
    },
    {
      "indent": 3,
      "text": "Indicates that an I/O error occurred for which the file system was unable to provide recovery.",
      "ja": "ファイルシステムがリカバリを提供できなかったI / Oエラーが発生したことを示します。"
    },
    {
      "indent": 0,
      "text": "15.1.4.7. NFS4ERR_MLINK (Error Code 31)",
      "section_title": true,
      "ja": "15.1.4.7. NFS4ERR_MLINK（エラーコード31）"
    },
    {
      "indent": 3,
      "text": "The request would have caused the server's limit for the number of hard links a file may have to be exceeded.",
      "ja": "要求は、ファイルを超えなければならないハードリンクの数に対してサーバーの制限を引き起こしました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.8. NFS4ERR_NOENT (Error Code 2)",
      "section_title": true,
      "ja": "15.1.4.8. NFS4ERR_NOENT（エラーコード2）"
    },
    {
      "indent": 3,
      "text": "Indicates no such file or directory. The file or directory name specified does not exist.",
      "ja": "そのようなファイルまたはディレクトリがないことを示します。指定されたファイルまたはディレクトリ名が存在しません。"
    },
    {
      "indent": 0,
      "text": "15.1.4.9. NFS4ERR_NOSPC (Error Code 28)",
      "section_title": true,
      "ja": "15.1.4.9. NFS4ERR_NOSPC（エラーコード28）"
    },
    {
      "indent": 3,
      "text": "Indicates there is no space left on the device. The operation would have caused the server's file system to exceed its limit.",
      "ja": "デバイスにスペースが残っていないことを示します。操作により、サーバーのファイルシステムがその制限を超えました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.10. NFS4ERR_NOTEMPTY (Error Code 66)",
      "section_title": true,
      "ja": "15.1.4.10. NFS4ERR_NOTEMPTY（エラーコード66）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to remove a directory that was not empty.",
      "ja": "空ではないディレクトリを削除しようとしました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.11. NFS4ERR_ROFS (Error Code 30)",
      "section_title": true,
      "ja": "15.1.4.11. NFS4ERR_ROFS（エラーコード30）"
    },
    {
      "indent": 3,
      "text": "Indicates a read-only file system. A modifying operation was attempted on a read-only file system.",
      "ja": "読み取り専用ファイルシステムを示します。読み取り専用ファイルシステムで修正操作が試行されました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.12. NFS4ERR_XDEV (Error Code 18)",
      "section_title": true,
      "ja": "15.1.4.12. NFS4ERR_XDEV（エラーコード18）"
    },
    {
      "indent": 3,
      "text": "Indicates an attempt to do an operation, such as linking, that inappropriately crosses a boundary. This may be due to such boundaries as:",
      "ja": "リンクなど、境界を不適切に交差させる操作を行う試みを示します。これは、次のような境界によるものです。"
    },
    {
      "indent": 3,
      "text": "* that between file systems (where the fsids are different).",
      "ja": "* ファイルシステム間（FSIDが異なる場合）。"
    },
    {
      "indent": 3,
      "text": "* that between different named attribute directories or between a named attribute directory and an ordinary directory.",
      "ja": "* さまざまな名前付き属性ディレクトリ間、または名前付き属性ディレクトリと通常のディレクトリの間のもの。"
    },
    {
      "indent": 3,
      "text": "* that between byte-ranges of a file system that the file system implementation treats as separate (for example, for space accounting purposes), and where cross-connection between the byte-ranges are not allowed.",
      "ja": "* ファイルシステムの実装が別々に扱うファイルシステムのバイト範囲（たとえば、スペースアカウンティング目的のために）、およびバイト範囲間の相互接続が許可されていないことがわかります。"
    },
    {
      "indent": 0,
      "text": "15.1.5. State Management Errors",
      "section_title": true,
      "ja": "15.1.5. 状態管理エラー"
    },
    {
      "indent": 3,
      "text": "These errors indicate problems with the stateid (or one of the stateids) passed to a given operation. This includes situations in which the stateid is invalid as well as situations in which the stateid is valid but designates locking state that has been revoked. Depending on the operation, the stateid when valid may designate opens, byte-range locks, file or directory delegations, layouts, or device maps.",
      "ja": "これらのエラーは、特定の操作に渡されたStateID（またはStateIDの1つ）に関する問題を示しています。これには、StateIDが無効である状況、およびStateIDが有効であるが、取り消されたロック状態を指定する状況が含まれます。操作に応じて、有効なときのStateIDは、オープン、バイトレンジロック、ファイルまたはディレクトリの代表団、レイアウト、またはデバイスマップを指定できます。"
    },
    {
      "indent": 0,
      "text": "15.1.5.1. NFS4ERR_ADMIN_REVOKED (Error Code 10047)",
      "section_title": true,
      "ja": "15.1.5.1. NFS4ERR_ADMIN_REVOKED（エラーコード10047）"
    },
    {
      "indent": 3,
      "text": "A stateid designates locking state of any type that has been revoked due to administrative interaction, possibly while the lease is valid.",
      "ja": "StateIDは、リースが有効な一方で、管理対話のために取り消された任意の型のロック状態を指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.5.2. NFS4ERR_BAD_STATEID (Error Code 10026)",
      "section_title": true,
      "ja": "15.1.5.2. NFS4ERR_BAD_STATEID（エラーコード10026）"
    },
    {
      "indent": 3,
      "text": "A stateid does not properly designate any valid state. See Sections 8.2.4 and 8.2.3 for a discussion of how stateids are validated.",
      "ja": "StateIDは有効な状態を正しく指定しません。StateIDSがどのように検証されるかについての議論については、セクション8.2.4および8.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.5.3. NFS4ERR_DELEG_REVOKED (Error Code 10087)",
      "section_title": true,
      "ja": "15.1.5.3. NFS4ERR_DELEG_REVOKED（エラーコード10087）"
    },
    {
      "indent": 3,
      "text": "A stateid designates recallable locking state of any type (delegation or layout) that has been revoked due to the failure of the client to return the lock when it was recalled.",
      "ja": "StateDIDは、リコール時にクライアントがロックを返すために失敗した任意の種類（委任またはレイアウト）のリソタリングロック状態を指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.5.4. NFS4ERR_EXPIRED (Error Code 10011)",
      "section_title": true,
      "ja": "15.1.5.4. NFS4ERR_EXPIRED（エラーコード10011）"
    },
    {
      "indent": 3,
      "text": "A stateid designates locking state of any type that has been revoked due to expiration of the client's lease, either immediately upon lease expiration, or following a later request for a conflicting lock.",
      "ja": "StateIDは、リースの有効期限の際に、または競合するロックの後の要求に従って、クライアントのリースの有効期限が切れたために失効された任意のタイプのロック状態を指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.5.5. NFS4ERR_OLD_STATEID (Error Code 10024)",
      "section_title": true,
      "ja": "15.1.5.5. NFS4ERR_OLD_STATEID（エラーコード10024）"
    },
    {
      "indent": 3,
      "text": "A stateid with a non-zero seqid value does match the current seqid for the state designated by the user.",
      "ja": "ゼロ以外のSEQID値を持つStareIDは、ユーザーが指定した状態の現在のSEQIDと一致します。"
    },
    {
      "indent": 0,
      "text": "15.1.6. Security Errors",
      "section_title": true,
      "ja": "15.1.6. セキュリティエラー"
    },
    {
      "indent": 3,
      "text": "These are the various permission-related errors in NFSv4.1.",
      "ja": "これらはNFSV4.1のさまざまな権限関連のエラーです。"
    },
    {
      "indent": 0,
      "text": "15.1.6.1. NFS4ERR_ACCESS (Error Code 13)",
      "section_title": true,
      "ja": "15.1.6.1. NFS4ERR_ACCESS（エラーコード13）"
    },
    {
      "indent": 3,
      "text": "Indicates permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM (Section 15.1.6.2), which restricts itself to owner or privileged-user permission failures, and NFS4ERR_WRONG_CRED (Section 15.1.6.4), which deals with appropriate permission to delete or modify transient objects based on the credentials of the user that created them.",
      "ja": "許可が拒否されたことを示します。呼び出し側には、要求された操作を実行するための正しい権限がありません。これは、NFS4ERR_PERM（セクション15.1.6.2）と対照的に、所有者または特権ユーザー権限の失敗、およびNFS4ERR_WRONG_CRED（セクション15.1.6.4）を制限します。これにより、ユーザーの資格情報に基づいて一時的なオブジェクトを削除または変更するための適切な権限を処理します。それを作成しました。"
    },
    {
      "indent": 0,
      "text": "15.1.6.2. NFS4ERR_PERM (Error Code 1)",
      "section_title": true,
      "ja": "15.1.6.2. NFS4ERR_PERM（エラーコード1）"
    },
    {
      "indent": 3,
      "text": "Indicates requester is not the owner. The operation was not allowed because the caller is neither a privileged user (root) nor the owner of the target of the operation.",
      "ja": "要求者が所有者ではないことを示します。発信者は特権ユーザー（ルート）も操作の対象の所有者でもないため、操作は許可されませんでした。"
    },
    {
      "indent": 0,
      "text": "15.1.6.3. NFS4ERR_WRONGSEC (Error Code 10016)",
      "section_title": true,
      "ja": "15.1.6.3. NFS4ERR_WRONGSEC（エラーコード10016）"
    },
    {
      "indent": 3,
      "text": "Indicates that the security mechanism being used by the client for the operation does not match the server's security policy. The client should change the security mechanism being used and re-send the operation (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send). SECINFO and SECINFO_NO_NAME can be used to determine the appropriate mechanism.",
      "ja": "操作のためにクライアントによって使用されているセキュリティメカニズムがサーバーのセキュリティポリシーと一致しないことを示します。クライアントは、使用されているセキュリティメカニズムを変更し、操作を再送信する（ただし、同じスロットIDとシーケンスIDを使用しないでください。再送では、1つまたは両方が異なる必要があります）。SECINFOとSECINFO_NO_NAMEを使用して適切なメカニズムを決定できます。"
    },
    {
      "indent": 0,
      "text": "15.1.6.4. NFS4ERR_WRONG_CRED (Error Code 10082)",
      "section_title": true,
      "ja": "15.1.6.4. NFS4ERR_WRONG_CRED（エラーコード10082）"
    },
    {
      "indent": 3,
      "text": "An operation that manipulates state was attempted by a principal that was not allowed to modify that piece of state.",
      "ja": "州を操作する操作は、その状態を変更することを許可されていなかった校長によって試みられました。"
    },
    {
      "indent": 0,
      "text": "15.1.7. Name Errors",
      "section_title": true,
      "ja": "15.1.7. 名前エラー"
    },
    {
      "indent": 3,
      "text": "Names in NFSv4 are UTF-8 strings. When the strings are not valid UTF-8 or are of length zero, the error NFS4ERR_INVAL results. Besides this, there are a number of other errors to indicate specific problems with names.",
      "ja": "NFSv4の名前はUTF-8文字列です。文字列が無効なUTF-8または長さゼロの場合、エラーNFS4ERR_INVALの結果。これ以外に、名前の特定の問題を示すために他のいくつかのエラーがあります。"
    },
    {
      "indent": 0,
      "text": "15.1.7.1. NFS4ERR_BADCHAR (Error Code 10040)",
      "section_title": true,
      "ja": "15.1.7.1. NFS4ERR_BADCHAR（エラーコード10040）"
    },
    {
      "indent": 3,
      "text": "A UTF-8 string contains a character that is not supported by the server in the context in which it being used.",
      "ja": "UTF-8文字列には、使用されているコンテキスト内のサーバーによってサポートされていない文字が含まれています。"
    },
    {
      "indent": 0,
      "text": "15.1.7.2. NFS4ERR_BADNAME (Error Code 10041)",
      "section_title": true,
      "ja": "15.1.7.2. NFS4ERR_BADNAME（エラーコード10041）"
    },
    {
      "indent": 3,
      "text": "A name string in a request consisted of valid UTF-8 characters supported by the server, but the name is not supported by the server as a valid name for the current operation. An example might be creating a file or directory named \"..\" on a server whose file system uses that name for links to parent directories.",
      "ja": "リクエスト内の名前文字列は、サーバーでサポートされている有効なUTF-8文字で構成されていましたが、名前は現在の操作の有効な名前としてサーバーによってサポートされていません。ファイルシステムが親ディレクトリへのリンクにその名前を使用するサーバー上のファイルまたはディレクトリという名前のファイルまたはディレクトリを作成している可能性があります。"
    },
    {
      "indent": 0,
      "text": "15.1.7.3. NFS4ERR_NAMETOOLONG (Error Code 63)",
      "section_title": true,
      "ja": "15.1.7.3. NFS4ERR_ANMETOOLONG（エラーコード63）"
    },
    {
      "indent": 3,
      "text": "Returned when the filename in an operation exceeds the server's implementation limit.",
      "ja": "オペレーション内のファイル名がサーバーの実装制限を超えると返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.8. Locking Errors",
      "section_title": true,
      "ja": "15.1.8. ロックエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors related to locking, both as to share reservations and byte-range locking. It does not deal with errors specific to the process of reclaiming locks. Those are dealt with in Section 15.1.9.",
      "ja": "このセクションでは、予約とバイトレンジのロックを共有するために、ロックに関連するエラーについて説明します。ロックを再生するプロセスに特有のエラーを処理しません。これらは15.1.9項で対処されています。"
    },
    {
      "indent": 0,
      "text": "15.1.8.1. NFS4ERR_BAD_RANGE (Error Code 10042)",
      "section_title": true,
      "ja": "15.1.8.1. NFS4ERR_BAD_RANGE（エラーコード10042）"
    },
    {
      "indent": 3,
      "text": "The byte-range of a LOCK, LOCKT, or LOCKU operation is not allowed by the server. For example, this error results when a server that only supports 32-bit ranges receives a range that cannot be handled by that server. (See Section 18.10.3.)",
      "ja": "ロック、ロック、またはロック操作のバイト範囲は、サーバーによって許可されていません。たとえば、このエラーは、32ビット範囲のみをサポートするサーバーがそのサーバーによって処理できない範囲を受け取るときに発生します。（セクション18.10.3を参照）"
    },
    {
      "indent": 0,
      "text": "15.1.8.2. NFS4ERR_DEADLOCK (Error Code 10045)",
      "section_title": true,
      "ja": "15.1.8.2. NFS4ERR_DEADLOCK（エラーコード10045）"
    },
    {
      "indent": 3,
      "text": "The server has been able to determine a byte-range locking deadlock condition for a READW_LT or WRITEW_LT LOCK operation.",
      "ja": "サーバーは、READW_LTまたはWRITEW_LTロック操作のバイトレンジロックデッドロック条件を決定できました。"
    },
    {
      "indent": 0,
      "text": "15.1.8.3. NFS4ERR_DENIED (Error Code 10010)",
      "section_title": true,
      "ja": "15.1.8.3. NFS4ERR_DENIED（エラーコード10010）"
    },
    {
      "indent": 3,
      "text": "An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to re-send the lock request (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send) until the lock is accepted. See Section 9.6 for a discussion of the re-send.",
      "ja": "ファイルをロックしようとすると拒否されます。これは一時的な状態である可能性があるので、クライアントはロック要求を再送信することが推奨されます（ただし、同じスロットIDとシーケンスIDでは使用できません。ロックが受け入れられるまで、1つまたは両方が再送信では異なる必要があります）。再送信についての議論については、セクション9.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.8.4. NFS4ERR_LOCKED (Error Code 10012)",
      "section_title": true,
      "ja": "15.1.8.4. NFS4ERR_LOCKED（エラーコード10012）"
    },
    {
      "indent": 3,
      "text": "A READ or WRITE operation was attempted on a file where there was a conflict between the I/O and an existing lock:",
      "ja": "I / Oと既存のロックの間に競合があったファイルに対して、読み取りまたは書き込み操作が試行されました。"
    },
    {
      "indent": 3,
      "text": "* There is a share reservation inconsistent with the I/O being done.",
      "ja": "* I / Oが行われていると矛盾する共有予約があります。"
    },
    {
      "indent": 3,
      "text": "* The range to be read or written intersects an existing mandatory byte-range lock.",
      "ja": "* 読み書きされる範囲は、既存の必須バイトレンジロックと交差します。"
    },
    {
      "indent": 0,
      "text": "15.1.8.5. NFS4ERR_LOCKS_HELD (Error Code 10037)",
      "section_title": true,
      "ja": "15.1.8.5. NFS4ERR_LOCKS_HELD（エラーコード10037）"
    },
    {
      "indent": 3,
      "text": "An operation was prevented by the unexpected presence of locks.",
      "ja": "操作が予期しないロックの存在によって防止されました。"
    },
    {
      "indent": 0,
      "text": "15.1.8.6. NFS4ERR_LOCK_NOTSUPP (Error Code 10043)",
      "section_title": true,
      "ja": "15.1.8.6. NFS4ERR_LOCK_NOTSUPP（エラーコード10043）"
    },
    {
      "indent": 3,
      "text": "A LOCK operation was attempted that would require the upgrade or downgrade of a byte-range lock range already held by the owner, and the server does not support atomic upgrade or downgrade of locks.",
      "ja": "所有者によってすでに保持されているバイトレンジロック範囲のアップグレードまたはダウングレードを必要とするロック操作が試みられ、サーバーはアトミックアップグレードまたはロックのダウングレードをサポートしていません。"
    },
    {
      "indent": 0,
      "text": "15.1.8.7. NFS4ERR_LOCK_RANGE (Error Code 10028)",
      "section_title": true,
      "ja": "15.1.8.7. NFS4ERR_LOCK_RANGE（エラーコード10028）"
    },
    {
      "indent": 3,
      "text": "A LOCK operation is operating on a range that overlaps in part a currently held byte-range lock for the current lock-owner and does not precisely match a single such byte-range lock where the server does not support this type of request, and thus does not implement POSIX locking semantics [21]. See Sections 18.10.4, 18.11.4, and 18.12.4 for a discussion of how this applies to LOCK, LOCKT, and LOCKU respectively.",
      "ja": "ロック操作は、現在のロック所有者の現在保持されているバイトレンジロックの部分で重なる範囲で動作しており、サーバーがこのタイプの要求をサポートしていない単一のバイトレンジロックとは正確に一致しません。POSIXロックセマンティクスを実装していません[21]。これがそれぞれロック、ロック、ロックにどのように適用されるかについては、それぞれ18.10.4,18.11.4、および18.12.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.8.8. NFS4ERR_OPENMODE (Error Code 10038)",
      "section_title": true,
      "ja": "15.1.8.8. NFS4ERR_OPENMODE（エラーコード10038）"
    },
    {
      "indent": 3,
      "text": "The client attempted a READ, WRITE, LOCK, or other operation not sanctioned by the stateid passed (e.g., writing to a file opened for read-only access).",
      "ja": "クライアントは、渡されたStateIDによって認可されていない読み取り、書き込み、ロック、またはその他の操作を試みました（例えば、読み取り専用アクセスのために開かれたファイルへの書き込み）。"
    },
    {
      "indent": 0,
      "text": "15.1.8.9. NFS4ERR_SHARE_DENIED (Error Code 10015)",
      "section_title": true,
      "ja": "15.1.8.9. NFS4ERR_SHARE_DENEDIED（エラーコード10015）"
    },
    {
      "indent": 3,
      "text": "An attempt to OPEN a file with a share reservation has failed because of a share conflict.",
      "ja": "共有予約でファイルを開こうとすると、共有の競合が原因で失敗しました。"
    },
    {
      "indent": 0,
      "text": "15.1.9. Reclaim Errors",
      "section_title": true,
      "ja": "15.1.9. エラーを再生する"
    },
    {
      "indent": 3,
      "text": "These errors relate to the process of reclaiming locks after a server restart.",
      "ja": "これらのエラーは、サーバーの再起動後のロックを再利用するプロセスに関連しています。"
    },
    {
      "indent": 0,
      "text": "15.1.9.1. NFS4ERR_COMPLETE_ALREADY (Error Code 10054)",
      "section_title": true,
      "ja": "15.1.9.1. NFS4ERR_COMPLETE_ALREADY（エラーコード10054）"
    },
    {
      "indent": 3,
      "text": "The client previously sent a successful RECLAIM_COMPLETE operation specifying the same scope, whether that scope is global or for the same file system in the case of a per-fs RECLAIM_COMPLETE. An additional RECLAIM_COMPLETE operation is not necessary and results in this error.",
      "ja": "クライアントは以前に、同じスコープを指定し、そのスコープがグローバルか同じファイルシステムであるかどうか、またはfs reclaim_completeの場合は同じファイルシステムであるかどうかを以前に送信しました。追加のRECLAIM_COMPLETE操作が必要ではなく、このエラーが発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.9.2. NFS4ERR_GRACE (Error Code 10013)",
      "section_title": true,
      "ja": "15.1.9.2. NFS4ERR_GRACE（エラーコード10013）"
    },
    {
      "indent": 3,
      "text": "This error is returned when the server is in its grace period with regard to the file system object for which the lock was requested. In this situation, a non-reclaim locking request cannot be granted. This can occur because either:",
      "ja": "このエラーは、ロックが要求されたファイルシステムオブジェクトに関してサーバーがその猶予期間内にあるときに返されます。この状況では、非再生ロック要求を許可できません。これは発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* The server does not have sufficient information about locks that might be potentially reclaimed to determine whether the lock could be granted.",
      "ja": "* サーバーには、ロックが付与されているかどうかを判断するために潜在的に再生される可能性があるロックに関する十分な情報がありません。"
    },
    {
      "indent": 3,
      "text": "* The request is made by a client responsible for reclaiming its locks that has not yet done the appropriate RECLAIM_COMPLETE operation, allowing it to proceed to obtain new locks.",
      "ja": "* 要求は、適切なRECLAIM_COMPLETE操作をまだ行っていないロックを再利用する責任があるクライアントによって行われ、新しいロックを取得することができます。"
    },
    {
      "indent": 3,
      "text": "In the case of a per-fs grace period, there may be clients (i.e., those currently using the destination file system) who might be unaware of the circumstances resulting in the initiation of the grace period. Such clients need to periodically retry the request until the grace period is over, just as other clients do.",
      "ja": "FSあたりの猶予期間の場合、猶予期間の開始をもたらす状況を認識している可能性があるクライアント（すなわち、現在宛先ファイルシステムを使用しているもの）があり得る。そのようなクライアントは、他のクライアントがするのと同じように、猶予期間が終了するまで要求を定期的に再試行する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.1.9.3. NFS4ERR_NO_GRACE (Error Code 10033)",
      "section_title": true,
      "ja": "15.1.9.3. NFS4ERR_NO_GRACE（エラーコード10033）"
    },
    {
      "indent": 3,
      "text": "A reclaim of client state was attempted in circumstances in which the server cannot guarantee that conflicting state has not been provided to another client. This occurs in any of the following situations:",
      "ja": "サーバーが競合状態が別のクライアントに提供されていないことを保証できない状況で、クライアント状態の再利用が試みられました。これは、次のいずれかの状況で発生します。"
    },
    {
      "indent": 3,
      "text": "* There is no active grace period applying to the file system object for which the request was made.",
      "ja": "* 要求が行われたファイルシステムオブジェクトに適用されるアクティブな猶予期間はありません。"
    },
    {
      "indent": 3,
      "text": "* The client making the request has no current role in reclaiming locks.",
      "ja": "* リクエストを行うクライアントは、ロックを再利用するための現在の役割はありません。"
    },
    {
      "indent": 3,
      "text": "* Previous operations have created a situation in which the server is not able to determine that a reclaim-interfering edge condition does not exist.",
      "ja": "* 以前の操作は、再生干渉エッジ条件が存在しないとサーバーが決定できない状況を作成しました。"
    },
    {
      "indent": 0,
      "text": "15.1.9.4. NFS4ERR_RECLAIM_BAD (Error Code 10034)",
      "section_title": true,
      "ja": "15.1.9.4. NFS4ERR_RECLAIM_BAD（エラーコード10034）"
    },
    {
      "indent": 3,
      "text": "The server has determined that a reclaim attempted by the client is not valid, i.e., the lock specified as being reclaimed could not possibly have existed before the server restart or file system migration event. A server is not obliged to make this determination and will typically rely on the client to only reclaim locks that the client was granted prior to restart. However, when a server does have reliable information to enable it to make this determination, this error indicates that the reclaim has been rejected as invalid. This is as opposed to the error NFS4ERR_RECLAIM_CONFLICT (see Section 15.1.9.5) where the server can only determine that there has been an invalid reclaim, but cannot determine which request is invalid.",
      "ja": "サーバーは、クライアントによって試行された再生が有効ではない、すなわち、再生されているように指定されたロックは、サーバーの再起動またはファイルシステムの移行イベントの前に存在していない可能性があると判断しました。サーバーはこの判断を下す義務付けられておらず、通常、再起動する前にクライアントが付与されたロックを再利用するためにクライアントに依存します。ただし、サーバーに信頼できる情報を使用してこの判断を有効にすると、このエラーはRESLAIMが無効として拒否されたことを示します。これは、エラーNFS4ERR_RECLAIM_CONFLICT（15.1.9.5項参照）とは対照的である（15.1.9.5項）、サーバーが無効な再利用があるがどのリクエストが無効であるかを判別できないことを判断できない。"
    },
    {
      "indent": 0,
      "text": "15.1.9.5. NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)",
      "section_title": true,
      "ja": "15.1.9.5. NFS4ERR_RECLAIM_CONFLICT（エラーコード10035）"
    },
    {
      "indent": 3,
      "text": "The reclaim attempted by the client has encountered a conflict and cannot be satisfied. This potentially indicates a misbehaving client, although not necessarily the one receiving the error. The misbehavior might be on the part of the client that established the lock with which this client conflicted. See also Section 15.1.9.4 for the related error, NFS4ERR_RECLAIM_BAD.",
      "ja": "クライアントが試みた再利用は競合に遭遇し、満たすことはできません。これは、必ずしもエラーを受信するものではないが、不正行動クライアントを示す。このクライアントが矛盾するロックを確立したクライアントの一部に不正行為がある可能性があります。関連エラーのセクション15.1.9.4は、NFS4ERR_RECLAIM_BADも参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10. pNFS Errors",
      "section_title": true,
      "ja": "15.1.10. PNFSエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with pNFS-related errors including those that are associated with using NFSv4.1 to communicate with a data server.",
      "ja": "このセクションでは、NFSV4.1を使用してデータサーバーと通信することに関連付けられているPNFS関連のエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.10.1. NFS4ERR_BADIOMODE (Error Code 10049)",
      "section_title": true,
      "ja": "15.1.10.1. NFS4ERR_BADIOMODE（エラーコード10049）"
    },
    {
      "indent": 3,
      "text": "An invalid or inappropriate layout iomode was specified. For example an inappropriate layout iomode, suppose a client's LAYOUTGET operation specified an iomode of LAYOUTIOMODE4_RW, and the server is neither able nor willing to let the client send write requests to data servers; the server can reply with NFS4ERR_BADIOMODE. The client would then send another LAYOUTGET with an iomode of LAYOUTIOMODE4_READ.",
      "ja": "無効なまたは不適切なレイアウトIOModeが指定されました。たとえば、不適切なレイアウトIOModeなど、クライアントのLayoutGet操作がLayoutIomode4_RWのIOMODEを指定したとし、サーバーはクライアントにデータサーバーに書き込み要求を送信させることもできません。サーバーはNFS4ERR_BADIOMODEで返信できます。その後、クライアントはLayoutIomode4_ReadのiOModeを持つ別のレイアウトゲットを送信します。"
    },
    {
      "indent": 0,
      "text": "15.1.10.2. NFS4ERR_BADLAYOUT (Error Code 10050)",
      "section_title": true,
      "ja": "15.1.10.2. NFS4ERR_BADLAYOUT（エラーコード10050）"
    },
    {
      "indent": 3,
      "text": "The layout specified is invalid in some way. For LAYOUTCOMMIT, this indicates that the specified layout is not held by the client or is not of mode LAYOUTIOMODE4_RW. For LAYOUTGET, it indicates that a layout matching the client's specification as to minimum length cannot be granted.",
      "ja": "指定されたレイアウトは何らかの形で無効です。LayoutCommitの場合、これは指定されたレイアウトがクライアントによって保持されていないか、またはMODE LAYOUTIOMODE4_RWではないことを示しています。LayEoutGetの場合、クライアントの指定に最小の長さに関するレイアウトを付与できないことを示します。"
    },
    {
      "indent": 0,
      "text": "15.1.10.3. NFS4ERR_LAYOUTTRYLATER (Error Code 10058)",
      "section_title": true,
      "ja": "15.1.10.3. NFS4ERR_LAYOUTTRYLATER（エラーコード10058）"
    },
    {
      "indent": 3,
      "text": "Layouts are temporarily unavailable for the file. The client should re-send later (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).",
      "ja": "レイアウトは一時的にファイルに使用できません。クライアントは後で再送信する必要があります（ただし、同じスロットIDとシーケンスIDではありません。再送信では1つまたは両方が異なる必要があります）。"
    },
    {
      "indent": 0,
      "text": "15.1.10.4. NFS4ERR_LAYOUTUNAVAILABLE (Error Code 10059)",
      "section_title": true,
      "ja": "15.1.10.4. NFS4ERR_LAYOUTUNAVAILABLE（エラーコード10059）"
    },
    {
      "indent": 3,
      "text": "Returned when layouts are not available for the current file system or the particular specified file.",
      "ja": "現在のファイルシステムまたは特定のファイルにレイアウトが使用できない場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.10.5. NFS4ERR_NOMATCHING_LAYOUT (Error Code 10060)",
      "section_title": true,
      "ja": "15.1.10.5. NFS4ERR_NOMATCHING_LAYOUT（エラーコード10060）"
    },
    {
      "indent": 3,
      "text": "Returned when layouts are recalled and the client has no layouts matching the specification of the layouts being recalled.",
      "ja": "レイアウトが呼び出され、クライアントにリコールされているレイアウトの指定に一致するレイアウトがない場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.10.6. NFS4ERR_PNFS_IO_HOLE (Error Code 10075)",
      "section_title": true,
      "ja": "15.1.10.6. NFS4ERR_PNFS_IO_HOLE（エラーコード10075）"
    },
    {
      "indent": 3,
      "text": "The pNFS client has attempted to read from or write to an illegal hole of a file of a data server that is using sparse packing. See Section 13.4.4.",
      "ja": "PNFSクライアントは、スパースパッキングを使用しているデータサーバのファイルの不正な穴から読み書きを試みた。13.4.4項を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10.7. NFS4ERR_PNFS_NO_LAYOUT (Error Code 10080)",
      "section_title": true,
      "ja": "15.1.10.7. NFS4ERR_PNFS_NO_LAYOUT（エラーコード10080）"
    },
    {
      "indent": 3,
      "text": "The pNFS client has attempted to read from or write to a file (using a request to a data server) without holding a valid layout. This includes the case where the client had a layout, but the iomode does not allow a WRITE.",
      "ja": "有効なレイアウトを保持せずに、PNFSクライアントはファイルから読み書きまたは書き込みを試みました（データサーバへの要求を使用して）。これには、クライアントにレイアウトがある場合が含まれますが、IOMODEは書き込みを許可しません。"
    },
    {
      "indent": 0,
      "text": "15.1.10.8. NFS4ERR_RETURNCONFLICT (Error Code 10086)",
      "section_title": true,
      "ja": "15.1.10.8. NFS4ERR_RETURNCONFLICT（エラーコード10086）"
    },
    {
      "indent": 3,
      "text": "A layout is unavailable due to an attempt to perform the LAYOUTGET before a pending LAYOUTRETURN on the file has been received. See Section 12.5.5.2.1.3.",
      "ja": "ファイルの保留中のLayoutReturnが受信される前に、レイアウトを実行しようとしたため、レイアウトは使用できません。12.5.5.2.1.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10.9. NFS4ERR_UNKNOWN_LAYOUTTYPE (Error Code 10062)",
      "section_title": true,
      "ja": "15.1.10.9. NFS4ERR_UNKNOWN_LAYOUTTYPE（エラーコード10062）"
    },
    {
      "indent": 3,
      "text": "The client has specified a layout type that is not supported by the server.",
      "ja": "クライアントは、サーバーでサポートされていないレイアウト型を指定しました。"
    },
    {
      "indent": 0,
      "text": "15.1.11. Session Use Errors",
      "section_title": true,
      "ja": "15.1.11. セッション使用エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors encountered when using sessions, that is, errors encountered when a request uses a Sequence (i.e., either SEQUENCE or CB_SEQUENCE) operation.",
      "ja": "このセクションでは、セッションを使用するときに発生したエラー、つまり、リクエストがシーケンス（すなわち、シーケンスまたはCB_Sequence）操作を使用するときにエラーが発生したエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.11.1. NFS4ERR_BADSESSION (Error Code 10052)",
      "section_title": true,
      "ja": "15.1.11.1. NFS4ERR_BADSESSION（エラーコード10052）"
    },
    {
      "indent": 3,
      "text": "The specified session ID is unknown to the server to which the operation is addressed.",
      "ja": "指定されたセッションIDは、操作が宛てられているサーバーに不明です。"
    },
    {
      "indent": 0,
      "text": "15.1.11.2. NFS4ERR_BADSLOT (Error Code 10053)",
      "section_title": true,
      "ja": "15.1.11.2. NFS4ERR_BADSLOT（エラーコード10053）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation that attempted to use a slot the replier does not have in its slot table. It is possible the slot may have been retired.",
      "ja": "リクエスターは、スロットを使用しようとしたシーケンス操作をスロットテーブルに持っていないシーケンス操作を送信しました。スロットが引退した可能性があります。"
    },
    {
      "indent": 0,
      "text": "15.1.11.3. NFS4ERR_BAD_HIGH_SLOT (Error Code 10077)",
      "section_title": true,
      "ja": "15.1.11.3. NFS4ERR_BAD_HIGH_SLOT（エラーコード10077）"
    },
    {
      "indent": 3,
      "text": "The highest_slot argument in a Sequence operation exceeds the replier's enforced highest_slotid.",
      "ja": "シーケンスオペレーション内のhisspslot引数は、replierの施行されたhiss_slotidを超えています。"
    },
    {
      "indent": 0,
      "text": "15.1.11.4. NFS4ERR_CB_PATH_DOWN (Error Code 10048)",
      "section_title": true,
      "ja": "15.1.11.4. NFS4ERR_CB_PATH_DOWN（エラーコード10048）"
    },
    {
      "indent": 3,
      "text": "There is a problem contacting the client via the callback path. The function of this error has been mostly superseded by the use of status flags in the reply to the SEQUENCE operation (see Section 18.46).",
      "ja": "コールバックパスを介してクライアントに連絡している問題があります。このエラーの機能は、シーケンス操作への応答内のステータスフラグを使用することによって主に置き換えられました（セクション18.46を参照）。"
    },
    {
      "indent": 0,
      "text": "15.1.11.5. NFS4ERR_DEADSESSION (Error Code 10078)",
      "section_title": true,
      "ja": "15.1.11.5. NFS4ERR_DeadSession（エラーコード10078）"
    },
    {
      "indent": 3,
      "text": "The specified session is a persistent session that is dead and does not accept new requests or perform new operations on existing requests (in the case in which a request was partially executed before server restart).",
      "ja": "指定されたセッションは永続的なセッションであり、新しい要求を受け入れたり、既存の要求に対して新しい操作を行ったりしたりしたりしたりしたり、サーバーの再起動前に要求が実行された場合は新しい演算を実行したりします。"
    },
    {
      "indent": 0,
      "text": "15.1.11.6. NFS4ERR_CONN_NOT_BOUND_TO_SESSION (Error Code 10055)",
      "section_title": true,
      "ja": "15.1.11.6. NFS4ERR_CONN_NOT_BOUND_TO_SESSION（エラーコード10055）"
    },
    {
      "indent": 3,
      "text": "A Sequence operation was sent on a connection that has not been associated with the specified session, where the client specified that connection association was to be enforced with SP4_MACH_CRED or SP4_SSV state protection.",
      "ja": "シーケンス操作は、指定されたセッションに関連付けられていない接続で送信され、クライアントはConnection AssociationがSP4_MACH_CREDまたはSP4_SSV状態保護で強制されたことを指定しました。"
    },
    {
      "indent": 0,
      "text": "15.1.11.7. NFS4ERR_SEQ_FALSE_RETRY (Error Code 10076)",
      "section_title": true,
      "ja": "15.1.11.7. NFS4ERR_SEQ_FALSE_RETRY（エラーコード10076）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache, but the replier has detected that the retried request is not the same as the original request. See Section 2.10.6.1.3.1.",
      "ja": "リクエスタは、返信キャッシュ内にあるスロットIDとシーケンスIDでシーケンス動作を送信しましたが、再試行要求が元の要求と同じではないことを検出しました。セクション2.10.6.1.3.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.11.8. NFS4ERR_SEQ_MISORDERED (Error Code 10063)",
      "section_title": true,
      "ja": "15.1.11.8. NFS4ERR_SEQ_MISORDERED（エラーコード10063）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation with an invalid sequence ID.",
      "ja": "リクエスターは無効なシーケンスIDでシーケンス操作を送信しました。"
    },
    {
      "indent": 0,
      "text": "15.1.12. Session Management Errors",
      "section_title": true,
      "ja": "15.1.12. セッション管理エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requests used in session management.",
      "ja": "このセクションでは、セッション管理で使用されている要求に関連するエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.12.1. NFS4ERR_BACK_CHAN_BUSY (Error Code 10057)",
      "section_title": true,
      "ja": "15.1.12.1. NFS4ERR_BACK_CHAN_BUSY（エラーコード10057）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to destroy a session when the session cannot be destroyed because the server has callback requests outstanding.",
      "ja": "サーバーにコールバック要求が解決されているため、セッションを破棄できない場合はセッションを破棄しようとしました。"
    },
    {
      "indent": 0,
      "text": "15.1.12.2. NFS4ERR_BAD_SESSION_DIGEST (Error Code 10051)",
      "section_title": true,
      "ja": "15.1.12.2. NFS4ERR_BAD_SESSION_DIGEST（エラーコード10051）"
    },
    {
      "indent": 3,
      "text": "The digest used in a SET_SSV request is not valid.",
      "ja": "set_ssv要求で使用されているダイジェストは無効です。"
    },
    {
      "indent": 0,
      "text": "15.1.13. Client Management Errors",
      "section_title": true,
      "ja": "15.1.13. クライアント管理エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requests used to create and manage client IDs.",
      "ja": "このセクションでは、クライアントIDの作成と管理に使用される要求に関連するエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.13.1. NFS4ERR_CLIENTID_BUSY (Error Code 10074)",
      "section_title": true,
      "ja": "15.1.13.1. NFS4ERR_CLIENTID_BUSY（エラーコード10074）"
    },
    {
      "indent": 3,
      "text": "The DESTROY_CLIENTID operation has found there are sessions and/or unexpired state associated with the client ID to be destroyed.",
      "ja": "Destroy_ClientID操作は、破棄されるクライアントIDに関連付けられているセッションおよび/または期限切れの状態があることを検出しました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.2. NFS4ERR_CLID_INUSE (Error Code 10017)",
      "section_title": true,
      "ja": "15.1.13.2. NFS4ERR_CLID_INUSE（エラーコード10017）"
    },
    {
      "indent": 3,
      "text": "While processing an EXCHANGE_ID operation, the server was presented with a co_ownerid field that matches an existing client with valid leased state, but the principal sending the EXCHANGE_ID operation differs from the principal that established the existing client. This indicates a collision (most likely due to chance) between clients. The client should recover by changing the co_ownerid and re-sending EXCHANGE_ID (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).",
      "ja": "Exchange_ID操作の処理中に、サーバーに有効なリース状態を持つ既存のクライアントと一致するCO_OWNERIDフィールドが表示されましたが、Exchange_ID操作を送信するプリンシパルは既存のクライアントを確立したプリンシパルとは異なります。これは、クライアント間の衝突（偶然の可能性が高いため）を示しています。クライアントは、CO_OWNERIDを変更してExchange_IDを再送信することによって回復する必要があります（ただし、同じスロットIDとシーケンスIDを使用しないでください。再送では、1つまたは両方が異なる必要があります）。"
    },
    {
      "indent": 0,
      "text": "15.1.13.3. NFS4ERR_ENCR_ALG_UNSUPP (Error Code 10079)",
      "section_title": true,
      "ja": "15.1.13.3. NFS4ERR_ENCR_ALG_UNSUPP（エラーコード10079）"
    },
    {
      "indent": 3,
      "text": "An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of encryption algorithms presented by the client did not include any supported by the server.",
      "ja": "Exchange_IDがSSVを介して指定された状態保護、およびクライアントによって提示された暗号化アルゴリズムのセットにサーバーによってサポートされていなかった場合に送信されました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.4. NFS4ERR_HASH_ALG_UNSUPP (Error Code 10072)",
      "section_title": true,
      "ja": "15.1.13.4. NFS4ERR_HASH_ALG_UNSUPP（エラーコード10072）"
    },
    {
      "indent": 3,
      "text": "An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of hashing algorithms presented by the client did not include any supported by the server.",
      "ja": "Exchange_IDがSSVを介して指定された状態保護、およびクライアントによって提示されたハッシュアルゴリズムのセットにサーバーによってサポートされていないセットに送信されました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.5. NFS4ERR_STALE_CLIENTID (Error Code 10022)",
      "section_title": true,
      "ja": "15.1.13.5. NFS4ERR_STALE_CLIENTID（エラーコード10022）"
    },
    {
      "indent": 3,
      "text": "A client ID not recognized by the server was passed to an operation. Note that unlike the case of NFSv4.0, client IDs are not passed explicitly to the server in ordinary locking operations and cannot result in this error. Instead, when there is a server restart, it is first manifested through an error on the associated session, and the staleness of the client ID is detected when trying to associate a client ID with a new session.",
      "ja": "サーバによって認識されないクライアントIDが操作に渡された。NFSv4.0の場合とは異なり、クライアントIDは通常のロック操作でサーバーに明示的に渡されず、このエラーになることはできません。代わりに、サーバーの再起動がある場合は、関連付けられているセッションのエラーを通じて最初に表示され、クライアントIDを新しいセッションと関連付けることを試みるときにクライアントIDのステレミが検出されます。"
    },
    {
      "indent": 0,
      "text": "15.1.14. Delegation Errors",
      "section_title": true,
      "ja": "15.1.14. 委任エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requesting and returning delegations.",
      "ja": "このセクションでは、委任の要求と返却に関連するエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.14.1. NFS4ERR_DELEG_ALREADY_WANTED (Error Code 10056)",
      "section_title": true,
      "ja": "15.1.14.1. NFS4ERR_DELEG_ALREADY_WANTED（エラーコード10056）"
    },
    {
      "indent": 3,
      "text": "The client has requested a delegation when it had already registered that it wants that same delegation.",
      "ja": "クライアントは、それが同じ委任を望んでいることをすでに登録したときに委任を要求しました。"
    },
    {
      "indent": 0,
      "text": "15.1.14.2. NFS4ERR_DIRDELEG_UNAVAIL (Error Code 10084)",
      "section_title": true,
      "ja": "15.1.14.2. NFS4ERR_DIRDELEG_UNAVAIL（エラーコード10084）"
    },
    {
      "indent": 3,
      "text": "This error is returned when the server is unable or unwilling to provide a requested directory delegation.",
      "ja": "このエラーは、サーバーが要求されたディレクトリの委任を提供できないか、不要な場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.14.3. NFS4ERR_RECALLCONFLICT (Error Code 10061)",
      "section_title": true,
      "ja": "15.1.14.3. NFS4ERR_RECALLCONFLICT（エラーコード10061）"
    },
    {
      "indent": 3,
      "text": "A recallable object (i.e., a layout or delegation) is unavailable due to a conflicting recall operation that is currently in progress for that object.",
      "ja": "リコール可能なオブジェクト（すなわち、レイアウトまたは委任）は、現在そのオブジェクトのために現在進行中の矛盾するリコール操作のために利用できない。"
    },
    {
      "indent": 0,
      "text": "15.1.14.4. NFS4ERR_REJECT_DELEG (Error Code 10085)",
      "section_title": true,
      "ja": "15.1.14.4. NFS4ERR_REJECT_DELEG（エラーコード10085）"
    },
    {
      "indent": 3,
      "text": "The callback operation invoked to deal with a new delegation has rejected it.",
      "ja": "新しい委任に対処するために呼び出されたコールバック操作が拒否されました。"
    },
    {
      "indent": 0,
      "text": "15.1.15. Attribute Handling Errors",
      "section_title": true,
      "ja": "15.1.15. 属性処理エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors specific to attribute handling within NFSv4.",
      "ja": "このセクションでは、NFSv4内の属性処理に固有のエラーについて説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.15.1. NFS4ERR_ATTRNOTSUPP (Error Code 10032)",
      "section_title": true,
      "ja": "15.1.15.1. NFS4ERR_ATTRNOTSUPP（エラーコード10032）"
    },
    {
      "indent": 3,
      "text": "An attribute specified is not supported by the server. This error MUST NOT be returned by the GETATTR operation.",
      "ja": "指定された属性はサーバーではサポートされていません。このエラーはGetAttrの動作によって返されてはいけません。"
    },
    {
      "indent": 0,
      "text": "15.1.15.2. NFS4ERR_BADOWNER (Error Code 10039)",
      "section_title": true,
      "ja": "15.1.15.2. NFS4ERR_BADOWNER（エラーコード10039）"
    },
    {
      "indent": 3,
      "text": "This error is returned when an owner or owner_group attribute value or the who field of an ACE within an ACL attribute value cannot be translated to a local representation.",
      "ja": "このエラーは、ACL属性値内のACEの所有者またはowner_group属性値またはACLのWHOフィールドをローカル表現に変換できない場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.15.3. NFS4ERR_NOT_SAME (Error Code 10027)",
      "section_title": true,
      "ja": "15.1.15.3. NFS4ERR_NOT_SAME（エラーコード10027）"
    },
    {
      "indent": 3,
      "text": "This error is returned by the VERIFY operation to signify that the attributes compared were not the same as those provided in the client's request.",
      "ja": "このエラーは、比較された属性がクライアントの要求に示されているものと同じではないことを表すことを確認するための検証操作によって返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.15.4. NFS4ERR_SAME (Error Code 10009)",
      "section_title": true,
      "ja": "15.1.15.4. NFS4ERR_SAME（エラーコード10009）"
    },
    {
      "indent": 3,
      "text": "This error is returned by the NVERIFY operation to signify that the attributes compared were the same as those provided in the client's request.",
      "ja": "このエラーは、比較された属性がクライアントの要求に記載されているものと同じであることを示すために、Nverify操作によって返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.16. Obsoleted Errors",
      "section_title": true,
      "ja": "15.1.16. 廃止されたエラー"
    },
    {
      "indent": 3,
      "text": "These errors MUST NOT be generated by any NFSv4.1 operation. This can be for a number of reasons.",
      "ja": "これらのエラーは、NFSV4.1操作によって生成されてはなりません。これは多くの理由である可能性があります。"
    },
    {
      "indent": 3,
      "text": "* The function provided by the error has been superseded by one of the status bits returned by the SEQUENCE operation.",
      "ja": "* エラーによって提供される機能は、シーケンス操作によって返されたステータスビットのうちの1つによって置き換えられています。"
    },
    {
      "indent": 3,
      "text": "* The new session structure and associated change in locking have made the error unnecessary.",
      "ja": "* 新しいセッション構造と関連するロックの変化は、エラーを不要にしました。"
    },
    {
      "indent": 3,
      "text": "* There has been a restructuring of some errors for NFSv4.1 that resulted in the elimination of certain errors.",
      "ja": "* NFSV4.1のためのいくつかのエラーの再構築は、特定のエラーの排除をもたらしました。"
    },
    {
      "indent": 0,
      "text": "15.1.16.1. NFS4ERR_BAD_SEQID (Error Code 10026)",
      "section_title": true,
      "ja": "15.1.16.1. NFS4ERR_BAD_SEQID（エラーコード10026）"
    },
    {
      "indent": 3,
      "text": "The sequence number (seqid) in a locking request is neither the next expected number or the last number processed. These seqids are ignored in NFSv4.1.",
      "ja": "ロック要求のシーケンス番号（seqid）は、次の予想数または最後の数値でもありません。これらのSEQIDはNFSV4.1では無視されます。"
    },
    {
      "indent": 0,
      "text": "15.1.16.2. NFS4ERR_LEASE_MOVED (Error Code 10031)",
      "section_title": true,
      "ja": "15.1.16.2. NFS4ERR_LEASE_MOVED（エラーコード10031）"
    },
    {
      "indent": 3,
      "text": "A lease being renewed is associated with a file system that has been migrated to a new server. The error has been superseded by the SEQ4_STATUS_LEASE_MOVED status bit (see Section 18.46).",
      "ja": "更新されているリースは、新しいサーバーに移行されたファイルシステムに関連付けられています。エラーは、SEQ4_STATUS_LEASE_MOUD_MOUDステータスビットに置き換えられました（セクション18.46を参照）。"
    },
    {
      "indent": 0,
      "text": "15.1.16.3. NFS4ERR_NXIO (Error Code 5)",
      "section_title": true,
      "ja": "15.1.16.3. NFS4ERR_NXIO（エラーコード5）"
    },
    {
      "indent": 3,
      "text": "I/O error. No such device or address. This error is for errors involving block and character device access, but because NFSv4.1 is not a device-access protocol, this error is not applicable.",
      "ja": "I / Oエラーそのような装置やアドレスはありません。このエラーは、ブロックと文字デバイスのアクセスを含むエラーですが、NFSV4.1はデバイスアクセスプロトコルではないため、このエラーは適用されません。"
    },
    {
      "indent": 0,
      "text": "15.1.16.4. NFS4ERR_RESTOREFH (Error Code 10030)",
      "section_title": true,
      "ja": "15.1.16.4. NFS4ERR_RESTOREFH（エラーコード10030）"
    },
    {
      "indent": 3,
      "text": "The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon. In NFSv4.1, this error has been superseded by NFS4ERR_NOFILEHANDLE.",
      "ja": "RestoreFH操作には、操作するための保存されたファイルハンドル（Savefhによって識別されます）がありません。NFSv4.1では、このエラーはNFS4ERR_NOFILEHANDLEに置き換えられました。"
    },
    {
      "indent": 0,
      "text": "15.1.16.5. NFS4ERR_STALE_STATEID (Error Code 10023)",
      "section_title": true,
      "ja": "15.1.16.5. NFS4ERR_STALE_STATEID（エラーコード10023）"
    },
    {
      "indent": 3,
      "text": "A stateid generated by an earlier server instance was used. This error is moot in NFSv4.1 because all operations that take a stateid MUST be preceded by the SEQUENCE operation, and the earlier server instance is detected by the session infrastructure that supports SEQUENCE.",
      "ja": "以前のサーバーインスタンスによって生成されたStateIDが使用されました。このエラーはNFSv4.1ではmootです。"
    },
    {
      "indent": 0,
      "text": "15.2. Operations and Their Valid Errors",
      "section_title": true,
      "ja": "15.2. 操作とその有効なエラー"
    },
    {
      "indent": 3,
      "text": "This section contains a table that gives the valid error returns for each protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all operations with two important exceptions:",
      "ja": "このセクションには、各プロトコル操作に対して有効なエラーが返されるテーブルが含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、2つの重要な例外を持つすべての操作で返却可能であると理解されるべきです。"
    },
    {
      "indent": 3,
      "text": "* The operations that MUST NOT be implemented: OPEN_CONFIRM, RELEASE_LOCKOWNER, RENEW, SETCLIENTID, and SETCLIENTID_CONFIRM.",
      "ja": "* 実装してはいけない操作：open_confirm、release_lockowner、更新、setclientid、およびsetclientid_confirm。"
    },
    {
      "indent": 3,
      "text": "* The invalid operation: ILLEGAL.",
      "ja": "* 無効な操作：違法です。"
    },
    {
      "indent": 5,
      "text": "+======================+========================================+\n| Operation            | Errors                                 |\n+======================+========================================+\n| ACCESS               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| BACKCHANNEL_CTL      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_NOENT,                         |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| BIND_CONN_TO_SESSION | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,    |\n|                      | NFS4ERR_BAD_SESSION_DIGEST,            |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_INVAL, NFS4ERR_NOT_ONLY_OP,    |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| CLOSE                | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED,     |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OLD_STATEID,                   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| COMMIT               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_IO,         |\n|                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| CREATE               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |\n|                      | NFS4ERR_BADCHAR, NFS4ERR_BADNAME,      |\n|                      | NFS4ERR_BADOWNER, NFS4ERR_BADTYPE,     |\n|                      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_DQUOT,          |\n|                      | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MLINK, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NAMETOOLONG,                   |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |\n|                      | NFS4ERR_NOTDIR,                        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG,     |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_UNSAFE_COMPOUND                |\n+----------------------+----------------------------------------+\n| CREATE_SESSION       | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,    |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_INVAL, NFS4ERR_NOENT,          |\n|                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOSPC,    |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SEQ_MISORDERED,                |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_STALE_CLIENTID,                |\n|                      | NFS4ERR_TOOSMALL,                      |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| DELEGPURGE           | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_NOTSUPP,        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| DELEGRETURN          | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED,                 |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_INVAL, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |\n|                      | NFS4ERR_OLD_STATEID,                   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| DESTROY_CLIENTID     | NFS4ERR_BADXDR, NFS4ERR_CLIENTID_BUSY, |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_NOT_ONLY_OP,                   |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_STALE_CLIENTID,                |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| DESTROY_SESSION      | NFS4ERR_BACK_CHAN_BUSY,                |\n|                      | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,    |\n|                      | NFS4ERR_CB_PATH_DOWN,                  |\n|                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,     |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_NOT_ONLY_OP,                   |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_STALE_CLIENTID,                |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| EXCHANGE_ID          | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_CLID_INUSE,                    |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_ENCR_ALG_UNSUPP,               |\n|                      | NFS4ERR_HASH_ALG_UNSUPP,               |\n|                      | NFS4ERR_INVAL, NFS4ERR_NOENT,          |\n|                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOT_SAME, |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| FREE_STATEID         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_LOCKS_HELD,                    |\n|                      | NFS4ERR_OLD_STATEID,                   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| GET_DIR_DELEGATION   | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DIRDELEG_UNAVAIL,              |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,       |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| GETATTR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| GETDEVICEINFO        | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOTSUPP,        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOOSMALL, |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE             |\n+----------------------+----------------------------------------+\n| GETDEVICELIST        | NFS4ERR_BADXDR, NFS4ERR_BAD_COOKIE,    |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_IO, NFS4ERR_NOFILEHANDLE,      |\n|                      | NFS4ERR_NOTSUPP, NFS4ERR_NOT_SAME,     |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE             |\n+----------------------+----------------------------------------+\n| GETFH                | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_STALE                          |\n+----------------------+----------------------------------------+\n| ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL     |\n+----------------------+----------------------------------------+\n| LAYOUTCOMMIT         | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_ATTRNOTSUPP,                   |\n|                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,  |\n|                      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,  |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_ISDIR NFS4ERR_MOVED,           |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |\n|                      | NFS4ERR_NO_GRACE,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_RECLAIM_BAD,                   |\n|                      | NFS4ERR_RECLAIM_CONFLICT,              |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,  |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_LAYOUTTRYLATER,                |\n|                      | NFS4ERR_LAYOUTUNAVAILABLE,             |\n|                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |\n|                      | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,  |\n|                      | NFS4ERR_OPENMODE,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_RECALLCONFLICT,                |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOOSMALL,                      |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| LAYOUTRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED,                 |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |\n|                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |\n+----------------------+----------------------------------------+\n| LINK                 | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,          |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |\n|                      | NFS4ERR_MLINK, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NAMETOOLONG,                   |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |\n|                      | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,       |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE,  |\n|                      | NFS4ERR_XDEV                           |\n+----------------------+----------------------------------------+\n| LOCK                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,     |\n|                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADLOCK, |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DENIED, NFS4ERR_EXPIRED,       |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_ISDIR,          |\n|                      | NFS4ERR_LOCK_NOTSUPP,                  |\n|                      | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,     |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |\n|                      | NFS4ERR_OPENMODE,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_RECLAIM_BAD,                   |\n|                      | NFS4ERR_RECLAIM_CONFLICT,              |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |\n+----------------------+----------------------------------------+\n| LOCKT                | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_BAD_RANGE,                     |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DENIED, NFS4ERR_FHEXPIRED,     |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_ISDIR, NFS4ERR_LOCK_RANGE,     |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_STALE,           |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |\n+----------------------+----------------------------------------+\n| LOCKU                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,     |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_INVAL, NFS4ERR_LOCK_RANGE,     |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OLD_STATEID,                   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| LOOKUP               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,    |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_WRONGSEC                       |\n+----------------------+----------------------------------------+\n| LOOKUPP              | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,      |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOTDIR,                        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_WRONGSEC                       |\n+----------------------+----------------------------------------+\n| NVERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |\n|                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SAME, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| OPEN                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,  |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,     |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_ALREADY_WANTED,          |\n|                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |\n|                      | NFS4ERR_EXIST, NFS4ERR_EXPIRED,        |\n|                      | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,       |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,         |\n|                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD,     |\n|                      | NFS4ERR_RECLAIM_CONFLICT,              |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_SHARE_DENIED, NFS4ERR_STALE,   |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_UNSAFE_COMPOUND,               |\n|                      | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE   |\n+----------------------+----------------------------------------+\n| OPEN_CONFIRM         | NFS4ERR_NOTSUPP                        |\n+----------------------+----------------------------------------+\n| OPEN_DOWNGRADE       | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_INVAL, NFS4ERR_MOVED,          |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OLD_STATEID,                   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_WRONG_CRED                     |\n+----------------------+----------------------------------------+\n| OPENATTR             | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED,      |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_UNSAFE_COMPOUND,               |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| PUTFH                | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,     |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_MOVED,                         |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |\n+----------------------+----------------------------------------+\n| PUTPUBFH             | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |\n+----------------------+----------------------------------------+\n| PUTROOTFH            | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |\n+----------------------+----------------------------------------+\n| READ                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED,                 |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |\n|                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_PNFS_IO_HOLE,                  |\n|                      | NFS4ERR_PNFS_NO_LAYOUT,                |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| READDIR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_BAD_COOKIE,                    |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |\n|                      | NFS4ERR_NOT_SAME,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS |\n+----------------------+----------------------------------------+\n| READLINK             | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| RECLAIM_COMPLETE     | NFS4ERR_BADXDR,                        |\n|                      | NFS4ERR_COMPLETE_ALREADY,              |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |\n+----------------------+----------------------------------------+\n| RELEASE_LOCKOWNER    | NFS4ERR_NOTSUPP                        |\n+----------------------+----------------------------------------+\n| REMOVE               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,    |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |\n|                      | NFS4ERR_NOTEMPTY,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS    |\n+----------------------+----------------------------------------+\n| RENAME               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,          |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |\n|                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_IO, NFS4ERR_MLINK,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,         |\n|                      | NFS4ERR_NOTEMPTY,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_WRONGSEC, NFS4ERR_XDEV         |\n+----------------------+----------------------------------------+\n| RENEW                | NFS4ERR_NOTSUPP                        |\n+----------------------+----------------------------------------+\n| RESTOREFH            | NFS4ERR_DEADSESSION,                   |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |\n+----------------------+----------------------------------------+\n| SAVEFH               | NFS4ERR_DEADSESSION,                   |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |\n|                      | NFS4ERR_NOFILEHANDLE,                  |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| SECINFO              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |\n|                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |\n|                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOTDIR,                        |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| SECINFO_NO_NAME      | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOENT,          |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |\n|                      | NFS4ERR_NOTSUPP,                       |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,   |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT, |\n|                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,     |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SEQUENCE_POS,                  |\n|                      | NFS4ERR_SEQ_FALSE_RETRY,               |\n|                      | NFS4ERR_SEQ_MISORDERED,                |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| SET_SSV              | NFS4ERR_BADXDR,                        |\n|                      | NFS4ERR_BAD_SESSION_DIGEST,            |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_INVAL,                         |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| SETATTR              | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,  |\n|                      | NFS4ERR_BADOWNER, NFS4ERR_BADXDR,      |\n|                      | NFS4ERR_BAD_STATEID,                   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |\n|                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG,     |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| SETCLIENTID          | NFS4ERR_NOTSUPP                        |\n+----------------------+----------------------------------------+\n| SETCLIENTID_CONFIRM  | NFS4ERR_NOTSUPP                        |\n+----------------------+----------------------------------------+\n| TEST_STATEID         | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY,                         |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT,                   |\n|                      | NFS4ERR_TOO_MANY_OPS                   |\n+----------------------+----------------------------------------+\n| VERIFY               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |\n|                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOT_SAME,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| WANT_DELEGATION      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |\n|                      | NFS4ERR_DELAY,                         |\n|                      | NFS4ERR_DELEG_ALREADY_WANTED,          |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,     |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_RECALLCONFLICT,                |\n|                      | NFS4ERR_RECLAIM_BAD,                   |\n|                      | NFS4ERR_RECLAIM_CONFLICT,              |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+\n| WRITE                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |\n|                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO,             |\n|                      | NFS4ERR_ISDIR, NFS4ERR_LOCKED,         |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |\n|                      | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID,    |\n|                      | NFS4ERR_OPENMODE,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,             |\n|                      | NFS4ERR_PNFS_IO_HOLE,                  |\n|                      | NFS4ERR_PNFS_NO_LAYOUT,                |\n|                      | NFS4ERR_REP_TOO_BIG,                   |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |\n|                      | NFS4ERR_REQ_TOO_BIG,                   |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,            |\n|                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |\n|                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |\n|                      | NFS4ERR_TOO_MANY_OPS,                  |\n|                      | NFS4ERR_WRONG_TYPE                     |\n+----------------------+----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Table 12: Valid Error Returns for Each Protocol Operation",
      "ja": "表12：プロトコル操作ごとに有効なエラー返品"
    },
    {
      "indent": 0,
      "text": "15.3. Callback Operations and Their Valid Errors",
      "section_title": true,
      "ja": "15.3. コールバック操作とその有効なエラー"
    },
    {
      "indent": 3,
      "text": "This section contains a table that gives the valid error returns for each callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all callback operations with the exception of CB_ILLEGAL.",
      "ja": "このセクションには、コールバック操作ごとに有効なエラーが返されるテーブルが含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、CB_ILLEGALを除いて、すべてのコールバック操作によって返信可能であると理解されるべきです。"
    },
    {
      "indent": 4,
      "text": "+=========================+=======================================+\n| Callback Operation      | Errors                                |\n+=========================+=======================================+\n| CB_GETATTR              | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |\n|                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS,                 |\n+-------------------------+---------------------------------------+\n| CB_ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL    |\n+-------------------------+---------------------------------------+\n| CB_LAYOUTRECALL         | NFS4ERR_BADHANDLE, NFS4ERR_BADIOMODE, |\n|                         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,  |\n|                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |\n|                         | NFS4ERR_NOMATCHING_LAYOUT,            |\n|                         | NFS4ERR_NOTSUPP,                      |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_TOO_MANY_OPS,                 |\n|                         | NFS4ERR_UNKNOWN_LAYOUTTYPE,           |\n|                         | NFS4ERR_WRONG_TYPE                    |\n+-------------------------+---------------------------------------+\n| CB_NOTIFY               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |\n|                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |\n|                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_NOTIFY_DEVICEID      | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |\n|                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_NOTIFY_LOCK          | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |\n|                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |\n|                         | NFS4ERR_NOTSUPP,                      |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_PUSH_DELEG           | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |\n|                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |\n|                         | NFS4ERR_NOTSUPP,                      |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REJECT_DELEG,                 |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS,                 |\n|                         | NFS4ERR_WRONG_TYPE                    |\n+-------------------------+---------------------------------------+\n| CB_RECALL               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |\n|                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_RECALL_ANY           | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |\n|                         | NFS4ERR_INVAL,                        |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_RECALLABLE_OBJ_AVAIL | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |\n|                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_RECALL_SLOT          | NFS4ERR_BADXDR,                       |\n|                         | NFS4ERR_BAD_HIGH_SLOT, NFS4ERR_DELAY, |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,  |\n|                         | NFS4ERR_BADXDR,                       |\n|                         | NFS4ERR_BAD_HIGH_SLOT,                |\n|                         | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,    |\n|                         | NFS4ERR_DELAY, NFS4ERR_REP_TOO_BIG,   |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SEQUENCE_POS,                 |\n|                         | NFS4ERR_SEQ_FALSE_RETRY,              |\n|                         | NFS4ERR_SEQ_MISORDERED,               |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+\n| CB_WANTS_CANCELLED      | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |\n|                         | NFS4ERR_NOTSUPP,                      |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,            |\n|                         | NFS4ERR_REP_TOO_BIG,                  |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |\n|                         | NFS4ERR_REQ_TOO_BIG,                  |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,           |\n|                         | NFS4ERR_SERVERFAULT,                  |\n|                         | NFS4ERR_TOO_MANY_OPS                  |\n+-------------------------+---------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Table 13: Valid Error Returns for Each Protocol Callback Operation",
      "ja": "表13：各プロトコルコールバック操作に対する有効なエラー返品"
    },
    {
      "indent": 0,
      "text": "15.4. Errors and the Operations That Use Them",
      "section_title": true,
      "ja": "15.4. エラーとそれらを使用する操作"
    },
    {
      "indent": 3,
      "text": "+===================================+===============================+\n| Error                             | Operations                    |\n+===================================+===============================+\n| NFS4ERR_ACCESS                    | ACCESS, COMMIT, CREATE,       |\n|                                   | GETATTR, GET_DIR_DELEGATION,  |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LINK, LOCK, LOCKT, LOCKU,     |\n|                                   | LOOKUP, LOOKUPP, NVERIFY,     |\n|                                   | OPEN, OPENATTR, READ,         |\n|                                   | READDIR, READLINK, REMOVE,    |\n|                                   | RENAME, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SETATTR,     |\n|                                   | VERIFY, WRITE                 |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ADMIN_REVOKED             | CLOSE, DELEGRETURN,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LOCK, LOCKU,    |\n|                                   | OPEN, OPEN_DOWNGRADE, READ,   |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ATTRNOTSUPP               | CREATE, LAYOUTCOMMIT,         |\n|                                   | NVERIFY, OPEN, SETATTR,       |\n|                                   | VERIFY                        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BACK_CHAN_BUSY            | DESTROY_SESSION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADCHAR                   | CREATE, EXCHANGE_ID, LINK,    |\n|                                   | LOOKUP, NVERIFY, OPEN,        |\n|                                   | REMOVE, RENAME, SECINFO,      |\n|                                   | SETATTR, VERIFY               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADHANDLE                 | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY, CB_NOTIFY_LOCK,    |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | PUTFH                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADIOMODE                 | CB_LAYOUTRECALL,              |\n|                                   | LAYOUTCOMMIT, LAYOUTGET       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADLAYOUT                 | LAYOUTCOMMIT, LAYOUTGET       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADNAME                   | CREATE, LINK, LOOKUP, OPEN,   |\n|                                   | REMOVE, RENAME, SECINFO       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADOWNER                  | CREATE, OPEN, SETATTR         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADSESSION                | BIND_CONN_TO_SESSION,         |\n|                                   | CB_SEQUENCE,                  |\n|                                   | DESTROY_SESSION, SEQUENCE     |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADSLOT                   | CB_SEQUENCE, SEQUENCE         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADTYPE                   | CREATE                        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BADXDR                    | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_ILLEGAL,       |\n|                                   | CB_LAYOUTRECALL, CB_NOTIFY,   |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION, ILLEGAL,  |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | NVERIFY, OPEN, OPENATTR,      |\n|                                   | OPEN_DOWNGRADE, PUTFH, READ,  |\n|                                   | READDIR, RECLAIM_COMPLETE,    |\n|                                   | REMOVE, RENAME, SECINFO,      |\n|                                   | SECINFO_NO_NAME, SEQUENCE,    |\n|                                   | SETATTR, SET_SSV,             |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BAD_COOKIE                | GETDEVICELIST, READDIR        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BAD_HIGH_SLOT             | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | SEQUENCE                      |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BAD_RANGE                 | LOCK, LOCKT, LOCKU            |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BAD_SESSION_DIGEST        | BIND_CONN_TO_SESSION,         |\n|                                   | SET_SSV                       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_BAD_STATEID               | CB_LAYOUTRECALL, CB_NOTIFY,   |\n|                                   | CB_NOTIFY_LOCK, CB_RECALL,    |\n|                                   | CLOSE, DELEGRETURN,           |\n|                                   | FREE_STATEID, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LOCK, LOCKU,    |\n|                                   | OPEN, OPEN_DOWNGRADE, READ,   |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_CB_PATH_DOWN              | DESTROY_SESSION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_CLID_INUSE                | CREATE_SESSION, EXCHANGE_ID   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_CLIENTID_BUSY             | DESTROY_CLIENTID              |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_COMPLETE_ALREADY          | RECLAIM_COMPLETE              |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_CONN_NOT_BOUND_TO_SESSION | CB_SEQUENCE,                  |\n|                                   | DESTROY_SESSION, SEQUENCE     |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DEADLOCK                  | LOCK                          |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DEADSESSION               | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION, CLOSE,  |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DELAY                     | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SEQUENCE,    |\n|                                   | SETATTR, SET_SSV,             |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DELEG_ALREADY_WANTED      | OPEN, WANT_DELEGATION         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DELEG_REVOKED             | DELEGRETURN, LAYOUTCOMMIT,    |\n|                                   | LAYOUTGET, LAYOUTRETURN,      |\n|                                   | OPEN, READ, SETATTR, WRITE    |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DENIED                    | LOCK, LOCKT                   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DIRDELEG_UNAVAIL          | GET_DIR_DELEGATION            |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_DQUOT                     | CREATE, LAYOUTGET, LINK,      |\n|                                   | OPEN, OPENATTR, RENAME,       |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ENCR_ALG_UNSUPP           | EXCHANGE_ID                   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_EXIST                     | CREATE, LINK, OPEN, RENAME    |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_EXPIRED                   | CLOSE, DELEGRETURN,           |\n|                                   | LAYOUTCOMMIT, LAYOUTRETURN,   |\n|                                   | LOCK, LOCKU, OPEN,            |\n|                                   | OPEN_DOWNGRADE, READ,         |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_FBIG                      | LAYOUTCOMMIT, OPEN, SETATTR,  |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_FHEXPIRED                 | ACCESS, CLOSE, COMMIT,        |\n|                                   | CREATE, DELEGRETURN,          |\n|                                   | GETATTR, GETDEVICELIST,       |\n|                                   | GETFH, GET_DIR_DELEGATION,    |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SETATTR, VERIFY,              |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_FILE_OPEN                 | LINK, REMOVE, RENAME          |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_GRACE                     | GETATTR, GET_DIR_DELEGATION,  |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, NVERIFY, OPEN, READ,   |\n|                                   | REMOVE, RENAME, SETATTR,      |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_HASH_ALG_UNSUPP           | EXCHANGE_ID                   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_INVAL                     | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_PUSH_DELEG,                |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY, CREATE,        |\n|                                   | CREATE_SESSION, DELEGRETURN,  |\n|                                   | EXCHANGE_ID, GETATTR,         |\n|                                   | GETDEVICEINFO,                |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | NVERIFY, OPEN,                |\n|                                   | OPEN_DOWNGRADE, READ,         |\n|                                   | READDIR, READLINK,            |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SETATTR,     |\n|                                   | SET_SSV, VERIFY,              |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_IO                        | ACCESS, COMMIT, CREATE,       |\n|                                   | GETATTR, GETDEVICELIST,       |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LINK, LOOKUP, LOOKUPP,        |\n|                                   | NVERIFY, OPEN, OPENATTR,      |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | REMOVE, RENAME, SETATTR,      |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ISDIR                     | COMMIT, LAYOUTCOMMIT,         |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, OPEN, READ, WRITE      |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LAYOUTTRYLATER            | LAYOUTGET                     |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LAYOUTUNAVAILABLE         | LAYOUTGET                     |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LOCKED                    | LAYOUTGET, READ, SETATTR,     |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LOCKS_HELD                | CLOSE, FREE_STATEID           |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LOCK_NOTSUPP              | LOCK                          |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_LOCK_RANGE                | LOCK, LOCKT, LOCKU            |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_MLINK                     | CREATE, LINK, RENAME          |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_MOVED                     | ACCESS, CLOSE, COMMIT,        |\n|                                   | CREATE, DELEGRETURN,          |\n|                                   | GETATTR, GETFH,               |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, READ, READDIR,         |\n|                                   | READLINK, RECLAIM_COMPLETE,   |\n|                                   | REMOVE, RENAME, RESTOREFH,    |\n|                                   | SAVEFH, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SETATTR,     |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NAMETOOLONG               | CREATE, LINK, LOOKUP, OPEN,   |\n|                                   | REMOVE, RENAME, SECINFO       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOENT                     | BACKCHANNEL_CTL,              |\n|                                   | CREATE_SESSION, EXCHANGE_ID,  |\n|                                   | GETDEVICEINFO, LOOKUP,        |\n|                                   | LOOKUPP, OPEN, OPENATTR,      |\n|                                   | REMOVE, RENAME, SECINFO,      |\n|                                   | SECINFO_NO_NAME               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOFILEHANDLE              | ACCESS, CLOSE, COMMIT,        |\n|                                   | CREATE, DELEGRETURN,          |\n|                                   | GETATTR, GETDEVICELIST,       |\n|                                   | GETFH, GET_DIR_DELEGATION,    |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SETATTR, VERIFY,              |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOMATCHING_LAYOUT         | CB_LAYOUTRECALL               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOSPC                     | CREATE, CREATE_SESSION,       |\n|                                   | LAYOUTGET, LINK, OPEN,        |\n|                                   | OPENATTR, RENAME, SETATTR,    |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOTDIR                    | CREATE, GET_DIR_DELEGATION,   |\n|                                   | LINK, LOOKUP, LOOKUPP, OPEN,  |\n|                                   | READDIR, REMOVE, RENAME,      |\n|                                   | SECINFO, SECINFO_NO_NAME      |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOTEMPTY                  | REMOVE, RENAME                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOTSUPP                   | CB_LAYOUTRECALL, CB_NOTIFY,   |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG,                |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_WANTS_CANCELLED,           |\n|                                   | DELEGPURGE, DELEGRETURN,      |\n|                                   | GETDEVICEINFO,                |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK,           |\n|                                   | OPENATTR, OPEN_CONFIRM,       |\n|                                   | RELEASE_LOCKOWNER, RENEW,     |\n|                                   | SECINFO_NO_NAME,              |\n|                                   | SETCLIENTID,                  |\n|                                   | SETCLIENTID_CONFIRM,          |\n|                                   | WANT_DELEGATION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOT_ONLY_OP               | BIND_CONN_TO_SESSION,         |\n|                                   | CREATE_SESSION,               |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION, EXCHANGE_ID  |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NOT_SAME                  | EXCHANGE_ID, GETDEVICELIST,   |\n|                                   | READDIR, VERIFY               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_NO_GRACE                  | LAYOUTCOMMIT, LAYOUTRETURN,   |\n|                                   | LOCK, OPEN, WANT_DELEGATION   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_OLD_STATEID               | CLOSE, DELEGRETURN,           |\n|                                   | FREE_STATEID, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LOCK, LOCKU,    |\n|                                   | OPEN, OPEN_DOWNGRADE, READ,   |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_OPENMODE                  | LAYOUTGET, LOCK, READ,        |\n|                                   | SETATTR, WRITE                |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_OP_ILLEGAL                | CB_ILLEGAL, ILLEGAL           |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_OP_NOT_IN_SESSION         | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT,               |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE, DELEGPURGE,   |\n|                                   | DELEGRETURN, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST, GETFH,         |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SETATTR, SET_SSV,             |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_PERM                      | CREATE, OPEN, SETATTR         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_PNFS_IO_HOLE              | READ, WRITE                   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_PNFS_NO_LAYOUT            | READ, WRITE                   |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_RECALLCONFLICT            | LAYOUTGET, WANT_DELEGATION    |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_RECLAIM_BAD               | LAYOUTCOMMIT, LOCK, OPEN,     |\n|                                   | WANT_DELEGATION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_RECLAIM_CONFLICT          | LAYOUTCOMMIT, LOCK, OPEN,     |\n|                                   | WANT_DELEGATION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_REJECT_DELEG              | CB_PUSH_DELEG                 |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_REP_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_REP_TOO_BIG_TO_CACHE      | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_REQ_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_RETRY_UNCACHED_REP        | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ROFS                      | CREATE, LINK, LOCK, LOCKT,    |\n|                                   | OPEN, OPENATTR,               |\n|                                   | OPEN_DOWNGRADE, REMOVE,       |\n|                                   | RENAME, SETATTR, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SAME                      | NVERIFY                       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SEQUENCE_POS              | CB_SEQUENCE, SEQUENCE         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SEQ_FALSE_RETRY           | CB_SEQUENCE, SEQUENCE         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SEQ_MISORDERED            | CB_SEQUENCE, CREATE_SESSION,  |\n|                                   | SEQUENCE                      |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SERVERFAULT               | ACCESS,                       |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_NOTIFY,        |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKU, LOOKUP, LOOKUPP,       |\n|                                   | NVERIFY, OPEN, OPENATTR,      |\n|                                   | OPEN_DOWNGRADE, PUTFH,        |\n|                                   | PUTPUBFH, PUTROOTFH, READ,    |\n|                                   | READDIR, READLINK,            |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SETATTR, TEST_STATEID,        |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SHARE_DENIED              | OPEN                          |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_STALE                     | ACCESS, CLOSE, COMMIT,        |\n|                                   | CREATE, DELEGRETURN,          |\n|                                   | GETATTR, GETFH,               |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, READ, READDIR,         |\n|                                   | READLINK, RECLAIM_COMPLETE,   |\n|                                   | REMOVE, RENAME, RESTOREFH,    |\n|                                   | SAVEFH, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SETATTR,     |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_STALE_CLIENTID            | CREATE_SESSION,               |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION               |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_SYMLINK                   | COMMIT, LAYOUTCOMMIT, LINK,   |\n|                                   | LOCK, LOCKT, LOOKUP,          |\n|                                   | LOOKUPP, OPEN, READ, WRITE    |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_TOOSMALL                  | CREATE_SESSION,               |\n|                                   | GETDEVICEINFO, LAYOUTGET,     |\n|                                   | READDIR                       |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_TOO_MANY_OPS              | ACCESS, BACKCHANNEL_CTL,      |\n|                                   | BIND_CONN_TO_SESSION,         |\n|                                   | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY,                    |\n|                                   | CB_NOTIFY_DEVICEID,           |\n|                                   | CB_NOTIFY_LOCK,               |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | CB_RECALLABLE_OBJ_AVAIL,      |\n|                                   | CB_RECALL_ANY,                |\n|                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |\n|                                   | CB_WANTS_CANCELLED, CLOSE,    |\n|                                   | COMMIT, CREATE,               |\n|                                   | CREATE_SESSION, DELEGPURGE,   |\n|                                   | DELEGRETURN,                  |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | EXCHANGE_ID, FREE_STATEID,    |\n|                                   | GETATTR, GETDEVICEINFO,       |\n|                                   | GETDEVICELIST,                |\n|                                   | GET_DIR_DELEGATION,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_UNKNOWN_LAYOUTTYPE        | CB_LAYOUTRECALL,              |\n|                                   | GETDEVICEINFO,                |\n|                                   | GETDEVICELIST, LAYOUTCOMMIT,  |\n|                                   | LAYOUTGET, LAYOUTRETURN,      |\n|                                   | NVERIFY, SETATTR, VERIFY      |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_UNSAFE_COMPOUND           | CREATE, OPEN, OPENATTR        |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_WRONGSEC                  | LINK, LOOKUP, LOOKUPP, OPEN,  |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | RENAME, RESTOREFH             |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_WRONG_CRED                | CLOSE, CREATE_SESSION,        |\n|                                   | DELEGPURGE, DELEGRETURN,      |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | FREE_STATEID, LAYOUTCOMMIT,   |\n|                                   | LAYOUTRETURN, LOCK, LOCKT,    |\n|                                   | LOCKU, OPEN_DOWNGRADE,        |\n|                                   | RECLAIM_COMPLETE              |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_WRONG_TYPE                | CB_LAYOUTRECALL,              |\n|                                   | CB_PUSH_DELEG, COMMIT,        |\n|                                   | GETATTR, LAYOUTGET,           |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, NVERIFY, OPEN,         |\n|                                   | OPENATTR, READ, READLINK,     |\n|                                   | RECLAIM_COMPLETE, SETATTR,    |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_XDEV                      | LINK, RENAME                  |\n+-----------------------------------+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 14: Errors and the Operations That Use Them",
      "ja": "表14：エラーとそれらを使用する操作"
    },
    {
      "indent": 0,
      "text": "16. NFSv4.1 Procedures",
      "section_title": true,
      "ja": "16. NFSV4.1手順"
    },
    {
      "indent": 3,
      "text": "Both procedures, NULL and COMPOUND, MUST be implemented.",
      "ja": "手順、NULL、化合物の両方を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "16.1. Procedure 0: NULL - No Operation",
      "section_title": true,
      "ja": "16.1. 手順0：NULL  - オペレーションなし"
    },
    {
      "indent": 0,
      "text": "16.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "16.1.1. 議論"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "16.1.2. RESULTS",
      "section_title": true,
      "ja": "16.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "16.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "16.1.3. description"
    },
    {
      "indent": 3,
      "text": "This is the standard NULL procedure with the standard void argument and void response. This procedure has no functionality associated with it. Because of this, it is sometimes used to measure the overhead of processing a service request. Therefore, the server SHOULD ensure that no unnecessary work is done in servicing this procedure.",
      "ja": "これは標準のvoid引数とvoid応答を持つ標準NULLプロシージャです。この手順にはそれに関連付けられている機能がありません。このため、サービス要求を処理するオーバーヘッドを測定するために使用されることがあります。したがって、サーバーはこの手順を修理する際に不要な作業ができないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "16.1.4. ERRORS",
      "section_title": true,
      "ja": "16.1.4. 誤差"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 0,
      "text": "16.2. Procedure 1: COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "16.2. 手順1：複合 - 複合操作"
    },
    {
      "indent": 0,
      "text": "16.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "16.2.1. 議論"
    },
    {
      "indent": 3,
      "text": "enum nfs_opnum4 {\n OP_ACCESS              = 3,\n OP_CLOSE               = 4,\n OP_COMMIT              = 5,\n OP_CREATE              = 6,\n OP_DELEGPURGE          = 7,\n OP_DELEGRETURN         = 8,\n OP_GETATTR             = 9,\n OP_GETFH               = 10,\n OP_LINK                = 11,\n OP_LOCK                = 12,\n OP_LOCKT               = 13,\n OP_LOCKU               = 14,\n OP_LOOKUP              = 15,\n OP_LOOKUPP             = 16,\n OP_NVERIFY             = 17,\n OP_OPEN                = 18,\n OP_OPENATTR            = 19,\n OP_OPEN_CONFIRM        = 20, /* Mandatory not-to-implement */\n OP_OPEN_DOWNGRADE      = 21,\n OP_PUTFH               = 22,\n OP_PUTPUBFH            = 23,\n OP_PUTROOTFH           = 24,\n OP_READ                = 25,\n OP_READDIR             = 26,\n OP_READLINK            = 27,\n OP_REMOVE              = 28,\n OP_RENAME              = 29,\n OP_RENEW               = 30, /* Mandatory not-to-implement */\n OP_RESTOREFH           = 31,\n OP_SAVEFH              = 32,\n OP_SECINFO             = 33,\n OP_SETATTR             = 34,\n OP_SETCLIENTID         = 35, /* Mandatory not-to-implement */\n OP_SETCLIENTID_CONFIRM = 36, /* Mandatory not-to-implement */\n OP_VERIFY              = 37,\n OP_WRITE               = 38,\n OP_RELEASE_LOCKOWNER   = 39, /* Mandatory not-to-implement */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* new operations for NFSv4.1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " OP_BACKCHANNEL_CTL = 40, OP_BIND_CONN_TO_SESSION = 41, OP_EXCHANGE_ID = 42, OP_CREATE_SESSION = 43, OP_DESTROY_SESSION = 44, OP_FREE_STATEID = 45, OP_GET_DIR_DELEGATION = 46, OP_GETDEVICEINFO = 47, OP_GETDEVICELIST = 48, OP_LAYOUTCOMMIT = 49, OP_LAYOUTGET = 50, OP_LAYOUTRETURN = 51, OP_SECINFO_NO_NAME = 52, OP_SEQUENCE = 53, OP_SET_SSV = 54, OP_TEST_STATEID = 55, OP_WANT_DELEGATION = 56, OP_DESTROY_CLIENTID = 57, OP_RECLAIM_COMPLETE = 58, OP_ILLEGAL = 10044 };",
      "ja": "OP_BACKCHANNEL_CTL=40、OP_BIND_CONN_TO_SESSION=41、=44OP_EXCHANGE_ID=42、=43OP_CREATE_SESSION、OP_DESTROY_SESSION、OP_FREE_STATEID=45、=46OP_GET_DIR_DELEGATION=47OP_GETDEVICEINFO、OP_GETDEVICELIST=48、OP_LAYOUTCOMMIT=49、OP_LAYOUTGET=50、OP_LAYOUTRETURN=51、OP_SECINFO_NO_NAME=52、op_sequence = 53、op_set_ssv = 54、op_test_stateId = 56、op_want_delegation = 56、op_destroy_clientid = 57、op_reclaim_complete = 58、op_illegal = 10044}。"
    },
    {
      "indent": 3,
      "text": "union nfs_argop4 switch (nfs_opnum4 argop) {\n case OP_ACCESS:        ACCESS4args opaccess;\n case OP_CLOSE:         CLOSE4args opclose;\n case OP_COMMIT:        COMMIT4args opcommit;\n case OP_CREATE:        CREATE4args opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;\n case OP_GETATTR:       GETATTR4args opgetattr;\n case OP_GETFH:         void;\n case OP_LINK:          LINK4args oplink;\n case OP_LOCK:          LOCK4args oplock;\n case OP_LOCKT:         LOCKT4args oplockt;\n case OP_LOCKU:         LOCKU4args oplocku;\n case OP_LOOKUP:        LOOKUP4args oplookup;\n case OP_LOOKUPP:       void;\n case OP_NVERIFY:       NVERIFY4args opnverify;\n case OP_OPEN:          OPEN4args opopen;\n case OP_OPENATTR:      OPENATTR4args opopenattr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4args opopen_downgrade;",
      "ja": "ケースOP_OPEN_DOWNGRADE OPEN_DOWNGRADE4ARGS OPOPEN_DOWNGRADE。"
    },
    {
      "indent": 4,
      "text": "case OP_PUTFH:         PUTFH4args opputfh;\ncase OP_PUTPUBFH:      void;\ncase OP_PUTROOTFH:     void;\ncase OP_READ:          READ4args opread;\ncase OP_READDIR:       READDIR4args opreaddir;\ncase OP_READLINK:      void;\ncase OP_REMOVE:        REMOVE4args opremove;\ncase OP_RENAME:        RENAME4args oprename;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RENEW:         RENEW4args oprenew;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_RESTOREFH:     void;\ncase OP_SAVEFH:        void;\ncase OP_SECINFO:       SECINFO4args opsecinfo;\ncase OP_SETATTR:       SETATTR4args opsetattr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID: SETCLIENTID4args opsetclientid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID_CONFIRM: SETCLIENTID_CONFIRM4args\n                               opsetclientid_confirm;\ncase OP_VERIFY:        VERIFY4args opverify;\ncase OP_WRITE:         WRITE4args opwrite;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RELEASE_LOCKOWNER:\n                       RELEASE_LOCKOWNER4args\n                       oprelease_lockowner;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Operations new to NFSv4.1 */\ncase OP_BACKCHANNEL_CTL:\n                       BACKCHANNEL_CTL4args opbackchannel_ctl;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4args opbind_conn_to_session;",
      "ja": "ケースop_bind_conn_to_session：bind_conn_to_session4args opbind_conn_to_session;"
    },
    {
      "indent": 4,
      "text": "case OP_EXCHANGE_ID: EXCHANGE_ID4args opexchange_id;",
      "ja": "ケースop_exchange_id：Exchange_ID4ARGS opExchange_id;"
    },
    {
      "indent": 4,
      "text": "case OP_CREATE_SESSION: CREATE_SESSION4args opcreate_session;",
      "ja": "ケースop_create_session：create_session4args opcreate_session;"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_SESSION: DESTROY_SESSION4args opdestroy_session;",
      "ja": "ケースop_destroy_session：destroy_session4args opdestroy_session;"
    },
    {
      "indent": 4,
      "text": "case OP_FREE_STATEID: FREE_STATEID4args opfree_stateid;",
      "ja": "ケースop_free_stateId：free_stateId4args opFree_StateId;"
    },
    {
      "indent": 4,
      "text": "case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4args opget_dir_delegation;",
      "ja": "ケースop_get_dir_delegation：get_dir_delegation4args opget_dir_delegation;"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICEINFO: GETDEVICEINFO4args opgetdeviceinfo;\ncase OP_GETDEVICELIST: GETDEVICELIST4args opgetdevicelist;\ncase OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4args oplayoutcommit;\ncase OP_LAYOUTGET:     LAYOUTGET4args oplayoutget;\ncase OP_LAYOUTRETURN:  LAYOUTRETURN4args oplayoutreturn;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4args opsecinfo_no_name;",
      "ja": "ケースop_secinfo_no_name：secinfo_no_name4args opsecinfo_no_name;"
    },
    {
      "indent": 4,
      "text": "case OP_SEQUENCE:      SEQUENCE4args opsequence;\ncase OP_SET_SSV:       SET_SSV4args opset_ssv;\ncase OP_TEST_STATEID:  TEST_STATEID4args optest_stateid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_WANT_DELEGATION: WANT_DELEGATION4args opwant_delegation;",
      "ja": "case op_want_delegation：want_delegation4args opwant_delegation。"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_CLIENTID: DESTROY_CLIENTID4args opdestroy_clientid;",
      "ja": "ケースop_destroy_clientid：destroy_clientid4args opdestroy_clientid;"
    },
    {
      "indent": 4,
      "text": "case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4args opreclaim_complete;",
      "ja": "ケースop_reclaim_complete：reclaim_complete4args opreclaim_complete;"
    },
    {
      "indent": 3,
      "text": " /* Operations not new to NFSv4.1 */\n case OP_ILLEGAL:       void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4args {\n        utf8str_cs      tag;\n        uint32_t        minorversion;\n        nfs_argop4      argarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16.2.2. RESULTS",
      "section_title": true,
      "ja": "16.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union nfs_resop4 switch (nfs_opnum4 resop) {\n case OP_ACCESS:        ACCESS4res opaccess;\n case OP_CLOSE:         CLOSE4res opclose;\n case OP_COMMIT:        COMMIT4res opcommit;\n case OP_CREATE:        CREATE4res opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;\n case OP_GETATTR:       GETATTR4res opgetattr;\n case OP_GETFH:         GETFH4res opgetfh;\n case OP_LINK:          LINK4res oplink;\n case OP_LOCK:          LOCK4res oplock;\n case OP_LOCKT:         LOCKT4res oplockt;\n case OP_LOCKU:         LOCKU4res oplocku;\n case OP_LOOKUP:        LOOKUP4res oplookup;\n case OP_LOOKUPP:       LOOKUPP4res oplookupp;\n case OP_NVERIFY:       NVERIFY4res opnverify;\n case OP_OPEN:          OPEN4res opopen;\n case OP_OPENATTR:      OPENATTR4res opopenattr;\n /* Not for NFSv4.1 */\n case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4res opopen_downgrade;",
      "ja": "ケースOP_OPEN_DOWNGRADE OPEN_DOWNGRADE4RES OPOPEN_DOWNGRADE。"
    },
    {
      "indent": 4,
      "text": "case OP_PUTFH:         PUTFH4res opputfh;\ncase OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;\ncase OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;\ncase OP_READ:          READ4res opread;\ncase OP_READDIR:       READDIR4res opreaddir;\ncase OP_READLINK:      READLINK4res opreadlink;\ncase OP_REMOVE:        REMOVE4res opremove;\ncase OP_RENAME:        RENAME4res oprename;\n/* Not for NFSv4.1 */\ncase OP_RENEW:         RENEW4res oprenew;\ncase OP_RESTOREFH:     RESTOREFH4res oprestorefh;\ncase OP_SAVEFH:        SAVEFH4res opsavefh;\ncase OP_SECINFO:       SECINFO4res opsecinfo;\ncase OP_SETATTR:       SETATTR4res opsetattr;\n/* Not for NFSv4.1 */\ncase OP_SETCLIENTID: SETCLIENTID4res opsetclientid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID_CONFIRM:\n                       SETCLIENTID_CONFIRM4res\n                               opsetclientid_confirm;\ncase OP_VERIFY:        VERIFY4res opverify;\ncase OP_WRITE:         WRITE4res opwrite;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RELEASE_LOCKOWNER:\n                       RELEASE_LOCKOWNER4res\n                               oprelease_lockowner;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Operations new to NFSv4.1 */\ncase OP_BACKCHANNEL_CTL:\n                       BACKCHANNEL_CTL4res\n                               opbackchannel_ctl;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4res opbind_conn_to_session;",
      "ja": "ケースop_bind_conn_to_session：bind_conn_to_session4res opbind_conn_to_session;"
    },
    {
      "indent": 4,
      "text": "case OP_EXCHANGE_ID: EXCHANGE_ID4res opexchange_id;",
      "ja": "ケースop_exchange_id：Exchange_ID4Res opExchange_id;"
    },
    {
      "indent": 4,
      "text": "case OP_CREATE_SESSION: CREATE_SESSION4res opcreate_session;",
      "ja": "ケースop_create_session：create_session4res opcreate_session;"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_SESSION: DESTROY_SESSION4res opdestroy_session;",
      "ja": "ケースop_destroy_session：destroy_session4res opdestroy_session;"
    },
    {
      "indent": 4,
      "text": "case OP_FREE_STATEID: FREE_STATEID4res opfree_stateid;",
      "ja": "ケースop_free_stateId：free_stateId4res opFree_StateId;"
    },
    {
      "indent": 4,
      "text": "case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4res opget_dir_delegation;",
      "ja": "ケースop_get_dir_delegation：get_dir_delegation4res opget_dir_delegation;"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICEINFO: GETDEVICEINFO4res opgetdeviceinfo;",
      "ja": "ケースop_getDeviceInfo：getDeviceInfo4res opgetDeviceInfo;"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICELIST: GETDEVICELIST4res opgetdevicelist;",
      "ja": "ケースop_getDeviceList：getDeviceList4res opgetDeviceList;"
    },
    {
      "indent": 4,
      "text": "case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4res oplayoutcommit;\ncase OP_LAYOUTGET:     LAYOUTGET4res oplayoutget;\ncase OP_LAYOUTRETURN:  LAYOUTRETURN4res oplayoutreturn;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4res opsecinfo_no_name;",
      "ja": "ケースOP_SECINFO_NO_NAME：SECINFO_NO_NAME4RES OPSECINFO_NO_NAME;"
    },
    {
      "indent": 4,
      "text": "case OP_SEQUENCE:      SEQUENCE4res opsequence;\ncase OP_SET_SSV:       SET_SSV4res opset_ssv;\ncase OP_TEST_STATEID:  TEST_STATEID4res optest_stateid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_WANT_DELEGATION: WANT_DELEGATION4res opwant_delegation;",
      "ja": "case op_want_delegation：want_delegation4res opwant_delegation;"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_CLIENTID: DESTROY_CLIENTID4res opdestroy_clientid;",
      "ja": "case op_destroy_clientid：destroy_clientid4res opdestroy_clientID。"
    },
    {
      "indent": 4,
      "text": "case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4res opreclaim_complete;",
      "ja": "ケースop_reclaim_complete：reclaim_complete4res opreclaim_complete;"
    },
    {
      "indent": 3,
      "text": " /* Operations not new to NFSv4.1 */\n case OP_ILLEGAL:       ILLEGAL4res opillegal;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4res {\n        nfsstat4        status;\n        utf8str_cs      tag;\n        nfs_resop4      resarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "16.2.3. description"
    },
    {
      "indent": 3,
      "text": "The COMPOUND procedure is used to combine one or more NFSv4 operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or until one of the operations has a status value other than NFS4_OK.",
      "ja": "複合手順は、1つ以上のNFSV4操作を単一のRPC要求に組み合わせるために使用されます。サーバーはそれぞれの操作を順番に解釈します。サーバによって操作が実行され、その操作の状態がNFS4_OKの場合、複合手順における次の操作が実行される。サーバーは、実行される操作がこれ以上実行されない、またはその操作の1つがNFS4_OK以外のステータス値を持つまで、このプロセスを続行します。"
    },
    {
      "indent": 3,
      "text": "In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. See Section 2.10.6.4 for a more detailed discussion.",
      "ja": "複合手順の処理では、サーバは、複合シーケンス内の操作の任意のまたはすべてを実行するための利用可能なリソースを有していないことを検索することができる。より詳細な説明については、2.10.6.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The server will generally choose between two methods of decoding the client's request. The first would be the traditional one-pass XDR decode. If there is an XDR decoding error in this case, the RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode the individual operations; the most interesting is the decode of attributes. In this case, the server may encounter an XDR decode error during the second pass. If it does, the server would return the error NFS4ERR_BADXDR to signify the decode error.",
      "ja": "サーバーは一般に、クライアントの要求を復号する2つの方法の間で選択されます。最初のものは従来のワンパスXDRデコードです。この場合、XDRデコードエラーがある場合は、RPC XDRデコードエラーが返されます。2番目の方法は、基本的な複合要求を復号するための最初のパスを作成し、次にXDRの個々の操作を復号するようにすることです。最も興味深いは属性のデコードです。この場合、サーバーは2回目のパス中にXDRデコードエラーが発生する可能性があります。そうであれば、サーバーはエラーNFS4ERR_BADXDRを返してデコードエラーを表します。"
    },
    {
      "indent": 3,
      "text": "The COMPOUND arguments contain a \"minorversion\" field. For NFSv4.1, the value for this field is 1. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.",
      "ja": "複合引数には、 \"minorVersion\"フィールドが含まれています。NFSV4.1の場合、このフィールドの値は1です。"
    },
    {
      "indent": 3,
      "text": "Contained within the COMPOUND results is a \"status\" field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error then the \"status\" value will be the same error value as is being returned for the operation that failed.",
      "ja": "化合物の結果に含まれるのは「ステータス」フィールドです。結果の配列の長さがゼロ以外の場合、このステータスは、複合手順で実行された最後の操作のステータスと同等でなければなりません。したがって、操作がエラーに発生した場合、 \"Status\"値は失敗した操作に対して返されているのと同じエラー値になります。"
    },
    {
      "indent": 3,
      "text": "Note that operations zero and one are not defined for the COMPOUND procedure. Operation 2 is not defined and is reserved for future definition and use with minor versioning. If the server receives an operation array that contains operation 2 and the minorversion field has a value of zero, an error of NFS4ERR_OP_ILLEGAL, as described in the next paragraph, is returned to the client. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.",
      "ja": "操作ゼロと1つは複合手順には定義されていません。操作2は定義されておらず、将来の定義のために予約されており、マイナーなバージョン管理で使用しています。サーバーが操作2を含む操作アレイを受信し、MinorVersionフィールドはゼロの値を持つ場合、次の段落で説明されているようにNFS4ERR_OPILEGALのエラーがクライアントに返されます。操作アレイが操作2を含む場合、MinorVersionフィールドがゼロ以外で、サーバーがマイナーバージョンをサポートしていない場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHAMCHTのエラーを返します。したがって、NFS4ERR_MINOR_VERS_MISMATCHエラーは、他のすべてのエラーよりも優先されます。"
    },
    {
      "indent": 3,
      "text": "It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER). In this case, the server's response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will be set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure's return results will also be NFS4ERR_OP_ILLEGAL.",
      "ja": "サーバーは、最初の合法的な操作（op_access）よりも小さい操作を含む要求を受け取る可能性があります（op_release_lockowner）。この場合、サーバーの応答は、要求の不正なオペコードではなく、Opcode Op_ILLEGALをエンコードします。不正な戻り結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。複合プロシージャのリターン結果もNFS4ERR_OP_ILLEGALになります。"
    },
    {
      "indent": 3,
      "text": "The definition of the \"tag\" in the request is left to the implementor. It may be used to summarize the content of the Compound request for the benefit of packet-sniffers and engineers debugging implementations. However, the value of \"tag\" in the response SHOULD be the same value as provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.",
      "ja": "要求内の「タグ」の定義は実装者に残されています。それは、パケットスニッファおよびエンジニアのデバッグ実装の利益のための複合要求の内容を要約するために使用され得る。ただし、応答内の「タグ」の値は、要求にあると同じ値である必要があります。これは、CB_COMPOUNDプロシージャのタグフィールドにも適用されます。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1. Current Filehandle and Stateid",
      "section_title": true,
      "ja": "16.2.3.1. 現在のファイルハンドルとStateID"
    },
    {
      "indent": 3,
      "text": "The COMPOUND procedure offers a simple environment for the execution of the operations specified by the client. The first two relate to the filehandle while the second two relate to the current stateid.",
      "ja": "複合手順は、クライアントによって指定された操作を実行するための簡単な環境を提供します。最初の2つはファイルハンドルに関連していますが、2番目の2つは現在のStateIDに関連しています。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1.1. Current Filehandle",
      "section_title": true,
      "ja": "16.2.3.1.1. 現在のファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The current and saved filehandles are used throughout the protocol. Most operations implicitly use the current filehandle as an argument, and many set the current filehandle as part of the results. The combination of client-specified sequences of operations and current and saved filehandle arguments and results allows for greater protocol flexibility. The best or easiest example of current filehandle usage is a sequence like the following:",
      "ja": "現在および保存されたファイルハンドルは、プロトコル全体で使用されます。ほとんどの操作は暗黙的に現在のファイルハンドルを引数として使用し、多くのファイルハンドルを結果の一部として設定します。クライアント指定の操作シーケンスと現在および保存されたファイルハンドル引数と結果の組み合わせにより、プロトコルの柔軟性が向上します。現在のファイルハンドル使用法の最善または最も簡単な例は、次のようなシーケンスです。"
    },
    {
      "indent": 9,
      "text": "PUTFH fh1              {fh1}\nLOOKUP \"compA\"         {fh2}\nGETATTR                {fh2}\nLOOKUP \"compB\"         {fh3}\nGETATTR                {fh3}\nLOOKUP \"compC\"         {fh4}\nGETATTR                {fh4}\nGETFH",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 2",
      "ja": "図2."
    },
    {
      "indent": 3,
      "text": "In this example, the PUTFH (Section 18.19) operation explicitly sets the current filehandle value while the result of each LOOKUP operation sets the current filehandle value to the resultant file system object. Also, the client is able to insert GETATTR operations using the current filehandle as an argument.",
      "ja": "この例では、PUTFH（セクション18.19）操作は現在のFileHandle値を明示的に設定し、各ルックアップ操作の結果が現在のFileHandle値を結果のファイルシステムオブジェクトに設定します。また、クライアントは、現在のFileHandleを引数として使用してGetAttrオペレーションを挿入することができます。"
    },
    {
      "indent": 3,
      "text": "The PUTROOTFH (Section 18.21) and PUTPUBFH (Section 18.20) operations also set the current filehandle. The above example would replace \"PUTFH fh1\" with PUTROOTFH or PUTPUBFH with no filehandle argument in order to achieve the same effect (on the assumption that \"compA\" is directly below the root of the namespace).",
      "ja": "PUTROOTFH（セクション18.21）とPUTPUBFH（セクション18.20）の操作も現在のファイルハンドルを設定します。上記の例では、同じ効果を達成するために（ \"Compa\"がネームスペースのルートの直下の前に）同じ効果を達成するために、fileHandle引数のないputrootfhまたはputpubfhと置き換えられます。"
    },
    {
      "indent": 3,
      "text": "Along with the current filehandle, there is a saved filehandle. While the current filehandle is set as the result of operations like LOOKUP, the saved filehandle must be set directly with the use of the SAVEFH operation. The SAVEFH operation copies the current filehandle value to the saved value. The saved filehandle value is used in combination with the current filehandle value for the LINK and RENAME operations. The RESTOREFH operation will copy the saved filehandle value to the current filehandle value; as a result, the saved filehandle value may be used a sort of \"scratch\" area for the client's series of operations.",
      "ja": "現在のファイルハンドルとともに、保存されたファイルハンドルがあります。現在のファイルハンドルがルックアップのような操作の結果として設定されている間は、保存されたファイルハンドルはSavefh操作を使用して直接設定する必要があります。Savefh操作は現在のFileHandle値を保存値にコピーします。保存されたファイルハンドル値は、リンクと名前の変更のための現在のFileHandle値と組み合わせて使用されます。RestoreFH操作は、保存されたFileHandle値を現在のファイルハンドル値にコピーします。その結果、保存されたファイルハンドル値は、クライアントの一連の操作のために一種の「スクラッチ」領域を使用することができます。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1.2. Current Stateid",
      "section_title": true,
      "ja": "16.2.3.1.2. 現在の州"
    },
    {
      "indent": 3,
      "text": "With NFSv4.1, additions of a current stateid and a saved stateid have been made to the COMPOUND processing environment; this allows for the passing of stateids between operations. There are no changes to the syntax of the protocol, only changes to the semantics of a few operations.",
      "ja": "NFSV4.1では、現在のStateIDと保存されたStateIDの追加が複合処理環境に加えられています。これにより、演算間の州の通過が可能になります。プロトコルの構文に変更はありませんが、いくつかの操作のセマンティクスのみに変更されています。"
    },
    {
      "indent": 3,
      "text": "A \"current stateid\" is the stateid that is associated with the\ncurrent filehandle.  The current stateid may only be changed by an\noperation that modifies the current filehandle or returns a stateid.\nIf an operation returns a stateid, it MUST set the current stateid to\nthe returned value.  If an operation sets the current filehandle but\ndoes not return a stateid, the current stateid MUST be set to the\nall-zeros special stateid, i.e., (seqid, other) = (0, 0).  If an\noperation uses a stateid as an argument but does not return a\nstateid, the current stateid MUST NOT be changed.  For example,\nPUTFH, PUTROOTFH, and PUTPUBFH will change the current server state\nfrom {ocfh, (osid)} to {cfh, (0, 0)}, while LOCK will change the\ncurrent state from {cfh, (osid} to {cfh, (nsid)}.  Operations like\nLOOKUP that transform a current filehandle and component name into a\nnew current filehandle will also change the current state to {0, 0}.\nThe SAVEFH and RESTOREFH operations will save and restore both the\ncurrent filehandle and the current stateid as a set.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following example is the common case of a simple READ operation with a normal stateid showing that the PUTFH initializes the current stateid to (0, 0). The subsequent READ with stateid (sid1) leaves the current stateid unchanged.",
      "ja": "次の例は、PUTFHが現在のStateIDを（0,0）に初期化することを示す通常のStateIDを備えた単純な読み取り操作の一般的な場合です。StareID（SID1）を使用した後続の読み出しは、現在のStareIDを変更しません。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nREAD (sid1), 0, 1024      {fh1, (0, 0)} -> {fh1, (0, 0)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "This next example performs an OPEN with the root filehandle and, as a result, generates stateid (sid1). The next operation specifies the READ with the argument stateid set such that (seqid, other) are equal to (1, 0), but the current stateid set by the previous operation is actually used when the operation is evaluated. This allows correct interaction with any existing, potentially conflicting, locks.",
      "ja": "次の例では、ルートファイルハンドルを使用した開きを実行し、その結果、StateID（SID1）を生成します。次の操作は、（seqid、その他）が（1,0）のように引数StateID Setを持つREADを指定しますが、前回の操作で設定された現在のStateIDは実際に操作が評価されたときに使用されます。これにより、既存の潜在的に競合するロックとの正しい対話が可能になります。"
    },
    {
      "indent": 7,
      "text": "PUTROOTFH                             - -> {fh1, (0, 0)}\nOPEN \"compA\"              {fh1, (0, 0)} -> {fh2, (sid1)}\nREAD (1, 0), 0, 1024      {fh2, (sid1)} -> {fh2, (sid1)}\nCLOSE (1, 0)              {fh2, (sid1)} -> {fh2, (sid2)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "This next example is similar to the second in how it passes the stateid sid2 generated by the LOCK operation to the next READ operation. This allows the client to explicitly surround a single I/ O operation with a lock and its appropriate stateid to guarantee correctness with other client locks. The example also shows how SAVEFH and RESTOREFH can save and later reuse a filehandle and stateid, passing them as the current filehandle and stateid to a READ operation.",
      "ja": "この次の例は、ロック操作によって生成されたStateID SID2を次の読み取り操作に渡す方法の2番目の例に似ています。これにより、クライアントは他のクライアントロックとの正当性を保証するためのロックとその適切なStateIDで単一のI / O操作を明示的に囲むことができます。この例では、savefhとrestorefhを保存して後でファイルハンドルとstateIdを再利用して、現在のファイルハンドルとstateIDとして読み取り操作に渡すことができます。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nLOCK 0, 1024, (sid1)      {fh1, (sid1)} -> {fh1, (sid2)}\nREAD (1, 0), 0, 1024      {fh1, (sid2)} -> {fh1, (sid2)}\nLOCKU 0, 1024, (1, 0)     {fh1, (sid2)} -> {fh1, (sid3)}\nSAVEFH                    {fh1, (sid3)} -> {fh1, (sid3)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "PUTFH fh2                 {fh1, (sid3)} -> {fh2, (0, 0)}\nWRITE (1, 0), 0, 1024     {fh2, (0, 0)} -> {fh2, (0, 0)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "RESTOREFH                 {fh2, (0, 0)} -> {fh1, (sid3)}\nREAD (1, 0), 1024, 1024   {fh1, (sid3)} -> {fh1, (sid3)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "The final example shows a disallowed use of the current stateid. The client is attempting to implicitly pass an anonymous special stateid, (0,0), to the READ operation. The server MUST return NFS4ERR_BAD_STATEID in the reply to the READ operation.",
      "ja": "最後の例は、現在のStateIDの許可されていない使用を示しています。クライアントは、匿名の特殊状態ID（0,0）を読み取り操作に暗黙的に渡すことを試みています。サーバーは、読み取り操作への返信でNFS4ERR_BAD_STATITIDを返す必要があります。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nREAD (1, 0), 0, 1024      {fh1, (0, 0)} -> NFS4ERR_BAD_STATEID",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 0,
      "text": "16.2.4. ERRORS",
      "section_title": true,
      "ja": "16.2.4. 誤差"
    },
    {
      "indent": 3,
      "text": "COMPOUND will of course return every error that each operation on the fore channel can return (see Table 12). However, if COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors COMPOUND will return if it processes zero operations include:",
      "ja": "もちろん、もちろん、前のチャネル上の各操作が戻ることができるすべてのエラーをすべて返します（表12を参照）。ただし、複合がゼロの操作を返す場合は、明らかに複合によって返されたエラーが操作によって返されたエラーとは関係ありません。エラー化合物のリストは、ゼロ操作が含まれている場合、ゼロ操作が含まれている場合に戻ります。"
    },
    {
      "indent": 4,
      "text": "+==============================+==================================+\n| Error                        | Notes                            |\n+==============================+==================================+\n| NFS4ERR_BADCHAR              | The tag argument has a character |\n|                              | the replier does not support.    |\n+------------------------------+----------------------------------+\n| NFS4ERR_BADXDR               |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_DELAY                |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_INVAL                | The tag argument is not in UTF-8 |\n|                              | encoding.                        |\n+------------------------------+----------------------------------+\n| NFS4ERR_MINOR_VERS_MISMATCH  |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_SERVERFAULT          |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_TOO_MANY_OPS         |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REP_TOO_BIG          |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REP_TOO_BIG_TO_CACHE |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REQ_TOO_BIG          |                                  |\n+------------------------------+----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 15: COMPOUND Error Returns",
      "ja": "表15：複合エラー返品"
    },
    {
      "indent": 0,
      "text": "17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL",
      "section_title": true,
      "ja": "17. 操作：必須、推奨、またはオプション"
    },
    {
      "indent": 3,
      "text": "The following tables summarize the operations of the NFSv4.1 protocol and the corresponding designation of REQUIRED, RECOMMENDED, and OPTIONAL to implement or MUST NOT implement. The designation of MUST NOT implement is reserved for those operations that were defined in NFSv4.0 and MUST NOT be implemented in NFSv4.1.",
      "ja": "次の表は、NFSV4.1プロトコルの操作と、実装を実装してはいけません。INFSV4.0で定義されていて、NFSV4.1で実装してはいけません。"
    },
    {
      "indent": 3,
      "text": "For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation for operations sent by the client is for the server implementation. The client is generally required to implement the operations needed for the operating environment for which it serves. For example, a read-only NFSv4.1 client would have no need to implement the WRITE operation and is not required to do so.",
      "ja": "ほとんどの場合、クライアントによって送信された操作のための必要な、推奨、またはオプションの指定は、サーバーの実装用です。クライアントは一般に、それがサービスを提供するオペレーティング環境に必要な操作を実装する必要があります。たとえば、読み取り専用のNFSV4.1クライアントは書き込み操作を実装する必要はなく、そうする必要はありません。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED or OPTIONAL designation for callback operations sent by the server is for both the client and server. Generally, the client has the option of creating the backchannel and sending the operations on the fore channel that will be a catalyst for the server sending callback operations. A partial exception is CB_RECALL_SLOT; the only way the client can avoid supporting this operation is by not creating a backchannel.",
      "ja": "サーバーによって送信されたコールバック操作のための必須またはオプションの指定は、クライアントとサーバーの両方のためのものです。一般に、クライアントにはバックチャネルを作成し、サーバーのコールバック操作のためのCatalystの触媒になる前のチャネルで操作を送信することができます。部分例外はCB_RECALL_SLOTです。クライアントがこの操作をサポートしないようにする唯一の方法は、バックチャネルを作成しないことです。"
    },
    {
      "indent": 3,
      "text": "Since this is a summary of the operations and their designation, there are subtleties that are not presented here. Therefore, if there is a question of the requirements of implementation, the operation descriptions themselves must be consulted along with other relevant explanatory text within this specification.",
      "ja": "これは操作とその指定の概要であるため、ここに提示されていない微妙なものがあります。したがって、実装要件の問題がある場合は、この仕様内の他の関連する説明テキストと一緒に操作の説明自体を参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "The abbreviations used in the second and third columns of the table are defined as follows.",
      "ja": "表の2列目と3列目に使用されている略語は次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "REQ REQUIRED to implement",
      "ja": "実装に必要なREQ"
    },
    {
      "indent": 3,
      "text": "REC RECOMMEND to implement",
      "ja": "recを実装することをお勧めします"
    },
    {
      "indent": 3,
      "text": "OPT OPTIONAL to implement",
      "ja": "実装するためのオプションであるopt."
    },
    {
      "indent": 3,
      "text": "MNI MUST NOT implement",
      "ja": "MNIは実装してはいけません"
    },
    {
      "indent": 3,
      "text": "For the NFSv4.1 features that are OPTIONAL, the operations that support those features are OPTIONAL, and the server would return NFS4ERR_NOTSUPP in response to the client's use of those operations. If an OPTIONAL feature is supported, it is possible that a set of operations related to the feature become REQUIRED to implement. The third column of the table designates the feature(s) and if the operation is REQUIRED or OPTIONAL in the presence of support for the feature.",
      "ja": "オプションのNFSv4.1機能の場合、それらの機能をサポートする操作はオプションであり、サーバーはクライアントのこれらの操作の使用に応答してNFS4ERR_NOTSUPPを返します。オプションの機能がサポートされている場合、その機能に関連する一連の操作が実装に必要になる可能性があります。テーブルの3番目の列は機能を指定し、その機能のサポートの存在下で操作が必要またはオプションである場合。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL features identified and their abbreviations are as follows:",
      "ja": "識別されたオプションの機能とその省略形は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "pNFS Parallel NFS",
      "ja": "PNFSパラレルNFS"
    },
    {
      "indent": 3,
      "text": "FDELG File Delegations",
      "ja": "FDELGファイル代表団"
    },
    {
      "indent": 3,
      "text": "DDELG Directory Delegations",
      "ja": "DDELGディレクトリの代理人"
    },
    {
      "indent": 4,
      "text": "+======================+=============+============+===============+\n| Operation            | REQ, REC,   | Feature    | Definition    |\n|                      | OPT, or MNI | (REQ, REC, |               |\n|                      |             | or OPT)    |               |\n+======================+=============+============+===============+\n| ACCESS               | REQ         |            | Section 18.1  |\n+----------------------+-------------+------------+---------------+\n| BACKCHANNEL_CTL      | REQ         |            | Section 18.33 |\n+----------------------+-------------+------------+---------------+\n| BIND_CONN_TO_SESSION | REQ         |            | Section 18.34 |\n+----------------------+-------------+------------+---------------+\n| CLOSE                | REQ         |            | Section 18.2  |\n+----------------------+-------------+------------+---------------+\n| COMMIT               | REQ         |            | Section 18.3  |\n+----------------------+-------------+------------+---------------+\n| CREATE               | REQ         |            | Section 18.4  |\n+----------------------+-------------+------------+---------------+\n| CREATE_SESSION       | REQ         |            | Section 18.36 |\n+----------------------+-------------+------------+---------------+\n| DELEGPURGE           | OPT         | FDELG      | Section 18.5  |\n|                      |             | (REQ)      |               |\n+----------------------+-------------+------------+---------------+\n| DELEGRETURN          | OPT         | FDELG,     | Section 18.6  |\n|                      |             | DDELG,     |               |\n|                      |             | pNFS (REQ) |               |\n+----------------------+-------------+------------+---------------+\n| DESTROY_CLIENTID     | REQ         |            | Section 18.50 |\n+----------------------+-------------+------------+---------------+\n| DESTROY_SESSION      | REQ         |            | Section 18.37 |\n+----------------------+-------------+------------+---------------+\n| EXCHANGE_ID          | REQ         |            | Section 18.35 |\n+----------------------+-------------+------------+---------------+\n| FREE_STATEID         | REQ         |            | Section 18.38 |\n+----------------------+-------------+------------+---------------+\n| GETATTR              | REQ         |            | Section 18.7  |\n+----------------------+-------------+------------+---------------+\n| GETDEVICEINFO        | OPT         | pNFS (REQ) | Section 18.40 |\n+----------------------+-------------+------------+---------------+\n| GETDEVICELIST        | OPT         | pNFS (OPT) | Section 18.41 |\n+----------------------+-------------+------------+---------------+\n| GETFH                | REQ         |            | Section 18.8  |\n+----------------------+-------------+------------+---------------+\n| GET_DIR_DELEGATION   | OPT         | DDELG      | Section 18.39 |\n|                      |             | (REQ)      |               |\n+----------------------+-------------+------------+---------------+\n| LAYOUTCOMMIT         | OPT         | pNFS (REQ) | Section 18.42 |\n+----------------------+-------------+------------+---------------+\n| LAYOUTGET            | OPT         | pNFS (REQ) | Section 18.43 |\n+----------------------+-------------+------------+---------------+\n| LAYOUTRETURN         | OPT         | pNFS (REQ) | Section 18.44 |\n+----------------------+-------------+------------+---------------+\n| LINK                 | OPT         |            | Section 18.9  |\n+----------------------+-------------+------------+---------------+\n| LOCK                 | REQ         |            | Section 18.10 |\n+----------------------+-------------+------------+---------------+\n| LOCKT                | REQ         |            | Section 18.11 |\n+----------------------+-------------+------------+---------------+\n| LOCKU                | REQ         |            | Section 18.12 |\n+----------------------+-------------+------------+---------------+\n| LOOKUP               | REQ         |            | Section 18.13 |\n+----------------------+-------------+------------+---------------+\n| LOOKUPP              | REQ         |            | Section 18.14 |\n+----------------------+-------------+------------+---------------+\n| NVERIFY              | REQ         |            | Section 18.15 |\n+----------------------+-------------+------------+---------------+\n| OPEN                 | REQ         |            | Section 18.16 |\n+----------------------+-------------+------------+---------------+\n| OPENATTR             | OPT         |            | Section 18.17 |\n+----------------------+-------------+------------+---------------+\n| OPEN_CONFIRM         | MNI         |            | N/A           |\n+----------------------+-------------+------------+---------------+\n| OPEN_DOWNGRADE       | REQ         |            | Section 18.18 |\n+----------------------+-------------+------------+---------------+\n| PUTFH                | REQ         |            | Section 18.19 |\n+----------------------+-------------+------------+---------------+\n| PUTPUBFH             | REQ         |            | Section 18.20 |\n+----------------------+-------------+------------+---------------+\n| PUTROOTFH            | REQ         |            | Section 18.21 |\n+----------------------+-------------+------------+---------------+\n| READ                 | REQ         |            | Section 18.22 |\n+----------------------+-------------+------------+---------------+\n| READDIR              | REQ         |            | Section 18.23 |\n+----------------------+-------------+------------+---------------+\n| READLINK             | OPT         |            | Section 18.24 |\n+----------------------+-------------+------------+---------------+\n| RECLAIM_COMPLETE     | REQ         |            | Section 18.51 |\n+----------------------+-------------+------------+---------------+\n| RELEASE_LOCKOWNER    | MNI         |            | N/A           |\n+----------------------+-------------+------------+---------------+\n| REMOVE               | REQ         |            | Section 18.25 |\n+----------------------+-------------+------------+---------------+\n| RENAME               | REQ         |            | Section 18.26 |\n+----------------------+-------------+------------+---------------+\n| RENEW                | MNI         |            | N/A           |\n+----------------------+-------------+------------+---------------+\n| RESTOREFH            | REQ         |            | Section 18.27 |\n+----------------------+-------------+------------+---------------+\n| SAVEFH               | REQ         |            | Section 18.28 |\n+----------------------+-------------+------------+---------------+\n| SECINFO              | REQ         |            | Section 18.29 |\n+----------------------+-------------+------------+---------------+\n| SECINFO_NO_NAME      | REC         | pNFS file  | Section       |\n|                      |             | layout     | 18.45,        |\n|                      |             | (REQ)      | Section 13.12 |\n+----------------------+-------------+------------+---------------+\n| SEQUENCE             | REQ         |            | Section 18.46 |\n+----------------------+-------------+------------+---------------+\n| SETATTR              | REQ         |            | Section 18.30 |\n+----------------------+-------------+------------+---------------+\n| SETCLIENTID          | MNI         |            | N/A           |\n+----------------------+-------------+------------+---------------+\n| SETCLIENTID_CONFIRM  | MNI         |            | N/A           |\n+----------------------+-------------+------------+---------------+\n| SET_SSV              | REQ         |            | Section 18.47 |\n+----------------------+-------------+------------+---------------+\n| TEST_STATEID         | REQ         |            | Section 18.48 |\n+----------------------+-------------+------------+---------------+\n| VERIFY               | REQ         |            | Section 18.31 |\n+----------------------+-------------+------------+---------------+\n| WANT_DELEGATION      | OPT         | FDELG      | Section 18.49 |\n|                      |             | (OPT)      |               |\n+----------------------+-------------+------------+---------------+\n| WRITE                | REQ         |            | Section 18.32 |\n+----------------------+-------------+------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Table 16: Operations",
      "ja": "表16：業務"
    },
    {
      "indent": 4,
      "text": "+=========================+=============+============+============+\n| Operation               | REQ, REC,   | Feature    | Definition |\n|                         | OPT, or MNI | (REQ, REC, |            |\n|                         |             | or OPT)    |            |\n+=========================+=============+============+============+\n| CB_GETATTR              | OPT         | FDELG      | Section    |\n|                         |             | (REQ)      | 20.1       |\n+-------------------------+-------------+------------+------------+\n| CB_LAYOUTRECALL         | OPT         | pNFS (REQ) | Section    |\n|                         |             |            | 20.3       |\n+-------------------------+-------------+------------+------------+\n| CB_NOTIFY               | OPT         | DDELG      | Section    |\n|                         |             | (REQ)      | 20.4       |\n+-------------------------+-------------+------------+------------+\n| CB_NOTIFY_DEVICEID      | OPT         | pNFS (OPT) | Section    |\n|                         |             |            | 20.12      |\n+-------------------------+-------------+------------+------------+\n| CB_NOTIFY_LOCK          | OPT         |            | Section    |\n|                         |             |            | 20.11      |\n+-------------------------+-------------+------------+------------+\n| CB_PUSH_DELEG           | OPT         | FDELG      | Section    |\n|                         |             | (OPT)      | 20.5       |\n+-------------------------+-------------+------------+------------+\n| CB_RECALL               | OPT         | FDELG,     | Section    |\n|                         |             | DDELG,     | 20.2       |\n|                         |             | pNFS (REQ) |            |\n+-------------------------+-------------+------------+------------+\n| CB_RECALL_ANY           | OPT         | FDELG,     | Section    |\n|                         |             | DDELG,     | 20.6       |\n|                         |             | pNFS (REQ) |            |\n+-------------------------+-------------+------------+------------+\n| CB_RECALL_SLOT          | REQ         |            | Section    |\n|                         |             |            | 20.8       |\n+-------------------------+-------------+------------+------------+\n| CB_RECALLABLE_OBJ_AVAIL | OPT         | DDELG,     | Section    |\n|                         |             | pNFS (REQ) | 20.7       |\n+-------------------------+-------------+------------+------------+\n| CB_SEQUENCE             | OPT         | FDELG,     | Section    |\n|                         |             | DDELG,     | 20.9       |\n|                         |             | pNFS (REQ) |            |\n+-------------------------+-------------+------------+------------+\n| CB_WANTS_CANCELLED      | OPT         | FDELG,     | Section    |\n|                         |             | DDELG,     | 20.10      |\n|                         |             | pNFS (REQ) |            |\n+-------------------------+-------------+------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 17: Callback Operations",
      "ja": "表17：コールバック操作"
    },
    {
      "indent": 0,
      "text": "18. NFSv4.1 Operations",
      "section_title": true,
      "ja": "18. NFSV4.1業務"
    },
    {
      "indent": 0,
      "text": "18.1. Operation 3: ACCESS - Check Access Rights",
      "section_title": true,
      "ja": "18.1. 操作3：アクセス - アクセス権を確認してください"
    },
    {
      "indent": 0,
      "text": "18.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.1.1. 議論"
    },
    {
      "indent": 3,
      "text": "const ACCESS4_READ      = 0x00000001;\nconst ACCESS4_LOOKUP    = 0x00000002;\nconst ACCESS4_MODIFY    = 0x00000004;\nconst ACCESS4_EXTEND    = 0x00000008;\nconst ACCESS4_DELETE    = 0x00000010;\nconst ACCESS4_EXECUTE   = 0x00000020;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ACCESS4args {\n        /* CURRENT_FH: object */\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.1.2. RESULTS",
      "section_title": true,
      "ja": "18.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ACCESS4resok {\n        uint32_t        supported;\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union ACCESS4res switch (nfsstat4 status) {\n case NFS4_OK:\n         ACCESS4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.1.3. description"
    },
    {
      "indent": 3,
      "text": "ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask \"access\". The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, \"supported\", represents the access rights for which the server can verify reliably. The second, \"access\", represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.",
      "ja": "アクセスRPC要求の認証情報によって識別されたユーザーが現在のファイルハンドルで指定されたファイルシステムオブジェクトに対して、ユーザーがユーザーが持っているアクセス権を決定します。クライアントは、ビットマスク「アクセス」でチェックするアクセス権のセットをエンコードします。サーバーはビットマスクでエンコードされた権限を確認します。NFS4_OKのステータスが返されると、応答に2ビットマスクが含まれます。最初の「サポート」は、サーバーが確実に検証できるアクセス権を表します。2番目の「アクセス」は、提供されたファイルハンドルのユーザーが使用できるアクセス権を表します。成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "Note that the reply's supported and access fields MUST NOT contain more values than originally set in the request's access field. For example, if the client sends an ACCESS operation with just the ACCESS4_READ value set and the server supports this value, the server MUST NOT set more than ACCESS4_READ in the supported field even if it could have reliably checked other values.",
      "ja": "Replyのサポートフィールドとアクセスフィールドには、リクエストのアクセスフィールドに最初に設定されているより多くの値を含めることはできません。たとえば、クライアントがAccess4_read値セットだけでアクセス操作を送信し、サーバーがこの値をサポートしている場合、サーバーは他の値を確実にチェックできた場合でも、サポートされているフィールドにACCESS4_READを超えて設定してはなりません。"
    },
    {
      "indent": 3,
      "text": "The reply's access field MUST NOT contain more values than the supported field.",
      "ja": "応答のアクセスフィールドには、サポートされているフィールドよりも多くの値を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask do not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.",
      "ja": "この操作の結果は必然的に本質的に勧められています。NFS4_OKの戻り状態とビットマスクに設定されている適切なビットは、将来そのようなアクセスがファイルシステムオブジェクトに許可されることを意味しません。これは、アクセス権がいつでもサーバーによって取り消すことができるためです。"
    },
    {
      "indent": 3,
      "text": "The following access permissions may be requested:",
      "ja": "次のアクセス権限が要求されることがあります。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_READ Read data from file or read a directory.",
      "ja": "ACCESS4_READファイルからデータを読み取ったり、ディレクトリを読んでください。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).",
      "ja": "access4_lookupディレクトリ内の名前を調べます（無視されないオブジェクトの意味なし）。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.",
      "ja": "access4_modify既存のファイルデータを書き換えるか、既存のディレクトリエントリを変更します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXTEND Write new data or add directory entries.",
      "ja": "access4_extend新しいデータを書き込みまたはディレクトリエントリを追加します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_DELETE Delete an existing directory entry.",
      "ja": "access4_delete既存のディレクトリエントリを削除します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE Execute a regular file (no meaning for a directory).",
      "ja": "access4_execute正規ファイルを実行します（ディレクトリの意味なし）。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE is a challenging semantic to implement because NFS provides remote file access, not remote execution. This leads to the following:",
      "ja": "access4_executeは、NFSがリモート実行ではなくリモートファイルアクセスを提供するため、実装する困難な意味です。これは次のようになります。"
    },
    {
      "indent": 3,
      "text": "* Whether or not a regular file is executable ought to be the responsibility of the NFS client and not the server. And yet the ACCESS operation is specified to seemingly require a server to own that responsibility.",
      "ja": "* 通常のファイルが実行可能であるかどうかは、サーバーではなくNFSクライアントの責任であるべきです。そしてそれでも、アクセス操作は、その責任を所有するためにサーバーがサーバーを必要とするように指定されています。"
    },
    {
      "indent": 3,
      "text": "* When a client executes a regular file, it has to read the file from the server. Strictly speaking, the server should not allow the client to read a file being executed unless the user has read permissions on the file. Requiring explicit read permissions on executable files in order to access them over NFS is not going to be acceptable to some users and storage administrators. Historically, NFS servers have allowed a user to READ a file if the user has execute access to the file.",
      "ja": "* クライアントが通常のファイルを実行すると、サーバーからファイルを読む必要があります。厳密に言えば、サーバーは、ユーザーがファイルに対して読み取り権限を持っていない限り、クライアントが実行中のファイルを読み取ることを許可しないでください。NFSを介してアクセスするために実行可能ファイルに対して明示的な読み取り権限を要求することは、一部のユーザーとストレージ管理者にとって受け入れられることはありません。歴史的に、NFSサーバーは、ユーザーがファイルへのアクセスを実行した場合、ユーザーがファイルを読み取ることを許可しました。"
    },
    {
      "indent": 3,
      "text": "As a practical example, the UNIX specification [60] states that an implementation claiming conformance to UNIX may indicate in the access() programming interface's result that a privileged user has execute rights, even if no execute permission bits are set on the regular file's attributes. It is possible to claim conformance to the UNIX specification and instead not indicate execute rights in that situation, which is true for some operating environments. Suppose the operating environments of the client and server are implementing the access() semantics for privileged users differently, and the ACCESS operation implementations of the client and server follow their respective access() semantics. This can cause undesired behavior:",
      "ja": "実際的な例として、UNIX仕様[60]は、UNIXへの適合性を主張することが、正規ファイルの属性に実行権限ビットが設定されていなくても、特権ユーザーが実行権を持ち、特権ユーザーが実行権限を持つことを示している可能性があることを示しています。。UNIX仕様に準拠を請求することは可能です。代わりに、その状況の実行権を示すものではありません。クライアントとサーバーのオペレーティング環境が特権ユーザーのaccess（）セマンティクスを異なる方法で実装しており、クライアントとサーバーのアクセス操作実装はそれぞれのaccess（）セマンティクスに従います。これは望ましくない行動を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "* Suppose the client's access() interface returns X_OK if the user is privileged and no execute permission bits are set on the regular file's attribute, and the server's access() interface does not return X_OK in that situation. Then the client will be unable to execute files stored on the NFS server that could be executed if stored on a non-NFS file system.",
      "ja": "* クライアントのaccess（）インターフェイスがx_okを返し、正規ファイルの属性に実行許可ビットが実行されず、サーバーのaccess（）インターフェイスはその状況でX_OKを返さないとします。その後、クライアントは、NFS以外のファイルシステムに保存されている場合に実行できるNFSサーバーに保存されているファイルを実行できません。"
    },
    {
      "indent": 3,
      "text": "* Suppose the client's access() interface does not return X_OK if the user is privileged, and no execute permission bits are set on the regular file's attribute, and the server's access() interface does return X_OK in that situation. Then:",
      "ja": "* ユーザーが特権がある場合は、クライアントのaccess（）インターフェイスがX_OKを返さないとします。また、通常のファイルの属性に実行許可ビットが設定されず、サーバーのaccess（）インターフェイスはその状況でX_OKを返します。それから："
    },
    {
      "indent": 6,
      "text": "- The client will be able to execute files stored on the NFS server that could be executed if stored on a non-NFS file system, unless the client's execution subsystem also checks for execute permission bits.",
      "ja": "- クライアントの実行サブシステムも実行権限ビットをチェックすることがない限り、クライアントはNFSサーバーに保存されているファイルをNFSサーバーに保存できるようにすることができます。"
    },
    {
      "indent": 6,
      "text": "- Even if the execution subsystem is checking for execute permission bits, there are more potential issues. For example, suppose the client is invoking access() to build a \"path search table\" of all executable files in the user's \"search path\", where the path is a list of directories each containing executable files. Suppose there are two files each in separate directories of the search path, such that files have the same component name. In the first directory the file has no execute permission bits set, and in the second directory the file has execute bits set. The path search table will indicate that the first directory has the executable file, but the execute subsystem will fail to execute it. The command shell might fail to try the second file in the second directory. And even if it did, this is a potential performance issue. Clearly, the desired outcome for the client is for the path search table to not contain the first file.",
      "ja": "- 実行サブシステムが実行許可ビットをチェックしても、より潜在的な問題があります。たとえば、クライアントがAccess（Access（）を呼び出して、ユーザーの「検索パス」内のすべての実行可能ファイルの「パス検索テーブル」を構築しているとします。パスは、実行可能ファイルを含む各ディレクトリのリストです。ファイルが同じコンポーネント名を持つように、それぞれの検索パスのディレクトリに2つのファイルがあるとします。最初のディレクトリに、ファイルに実行許可ビットが設定されず、2番目のディレクトリにファイルが実行ビットを設定しています。パス検索テーブルは、最初のディレクトリに実行可能ファイルがあることを示しますが、実行サブシステムは実行できません。コマンドシェルは、2番目のディレクトリ内の2番目のファイルを試すことができない可能性があります。たとえそれが行ったとしても、これは潜在的なパフォーマンスの問題です。明らかに、クライアントの望ましい結果は、パス検索テーブルが最初のファイルを含まないためのものです。"
    },
    {
      "indent": 3,
      "text": "To deal with the problems described above, the \"smart client, stupid server\" principle is used. The client owns overall responsibility for determining execute access and relies on the server to parse the execution permissions within the file's mode, acl, and dacl attributes. The rules for the client and server follow:",
      "ja": "上記の問題に対処するために、「スマートクライアント、愚かなサーバー」の原則が使用されています。クライアントは、実行アクセスを決定するための全体的な責任を所有し、ファイルのモード、ACL、およびDACL属性内の実行権限を解析するためにサーバーに依存しています。クライアントとサーバーの規則は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* If the client is sending ACCESS in order to determine if the user can read the file, the client SHOULD set ACCESS4_READ in the request's access field.",
      "ja": "* ユーザーがファイルを読み取ることができるかどうかを判断するためにクライアントがアクセスを送信している場合、クライアントは要求のアクセスフィールドにaccess4_readを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the client's operating environment only grants execution to the user if the user has execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, the client SHOULD send an ACCESS request with ACCESS4_EXECUTE bit set in the request's access field.",
      "ja": "* クライアントのオペレーティング環境が、モード、ACL、およびDACL属性の実行アクセス許可に従ってアクセスを実行した場合にのみユーザーが実行を許可している場合、クライアントが実行アクセスを決定したい場合、クライアントはアクセス要求を送信する必要があります。access4_executeリクエストのアクセスフィールドに設定されています。"
    },
    {
      "indent": 3,
      "text": "* If the client's operating environment grants execution to the user even if the user does not have execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, it SHOULD send an ACCESS request with both the ACCESS4_EXECUTE and ACCESS4_READ bits set in the request's access field. This way, if any read or execute permission grants the user read or execute access (or if the server interprets the user as privileged), as indicated by the presence of ACCESS4_EXECUTE and/or ACCESS4_READ in the reply's access field, the client will be able to grant the user execute access to the file.",
      "ja": "* モード、ACL、DACL属性の実行権限に従ってユーザーが実行アクセス権を実行していなくてもクライアントの動作環境がユーザーに実行を許可している場合、クライアントが実行アクセスを決定したい場合は、アクセス要求を送信する必要があります。access4_executeとaccess4_readビットの両方がリクエストのアクセスフィールドに設定されています。このようにして、Replのアクセスフィールドのaccess4_executeおよび/またはaccess4_readの存在によって示されるように、読み取りまたは実行権限がユーザーが読み取りまたは実行を許可する場合（またはサーバーが特権としてユーザーを非解釈した場合）、クライアントはできるようになります。ユーザーにファイルへのアクセスを実行するには。"
    },
    {
      "indent": 3,
      "text": "* If the server supports execute permission bits, or some other method for denoting executability (e.g., the suffix of the name of the file might indicate execute), it MUST check only execute permissions, not read permissions, when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. The server MUST NOT also examine read permission bits when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. Even if the server's operating environment would grant execute access to the user (e.g., the user is privileged), the server MUST NOT reply with ACCESS4_EXECUTE set in reply's access field unless there is at least one execute permission bit set in the mode, acl, or dacl attributes. In the case of acl and dacl, the \"one execute permission bit\" MUST be an ACE4_EXECUTE bit set in an ALLOW ACE.",
      "ja": "* サーバーが実行権限ビットをサポートしている場合、または実行可能性を表すための他の何らかの方法（ファイルの名前のサフィックスが実行を示している可能性があります）、返信があるかどうかを判断するときは、実行権限をチェックしない、実行権限のみを確認する必要があります。Access4_executeをアクセスフィールドに設定してください。応答がアクセスフィールドに設定されているかどうかを判断するときにサーバーは読み取り権限ビットも調べてはなりません。サーバーのオペレーティング環境がユーザーへの実行アクセスを許可していても（ユーザーが特権が特権があります）場合でも、モードでは少なくとも1つの実行権限ビットが設定されていない限り、サーバーはReplyのアクセスフィールドでセットされているACCESS4_EXECUTEで応答してはいけません。またはDACL属性ACLとDACLの場合、「1つの実行許可ビット」はALLY ACEで設定されたACE4_EXECUTEビットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the server does not support execute permission bits or some other method for denoting executability, it MUST NOT set ACCESS4_EXECUTE in the reply's supported and access fields. If the client set ACCESS4_EXECUTE in the ACCESS request's access field, and ACCESS4_EXECUTE is not set in the reply's supported field, then the client will have to send an ACCESS request with the ACCESS4_READ bit set in the request's access field.",
      "ja": "* サーバーが実行権限ビットまたは実行可能性を表すためのその他の方法をサポートしていない場合は、返信のサポートフィールドとアクセスフィールドにaccess4_executeを設定してはなりません。クライアントセットACCESSフィールドのACCESS4_EXECUTEがREPLYのサポートフィールドにaccess4_executeが設定されていない場合、クライアントはリクエストのアクセスフィールドにACCESS4_READビットを設定してアクセス要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the server supports read permission bits, it MUST only check for read permissions in the mode, acl, and dacl attributes when it receives an ACCESS request with ACCESS4_READ set in the access field. The server MUST NOT also examine execute permission bits when determining whether the reply will have ACCESS4_READ set in the access field or not.",
      "ja": "* サーバーが読み取り権限ビットをサポートしている場合は、AccessフィールドにAccess4_Readを設定したアクセス要求を受信したときのモード、ACL、およびDACL属性の読み取りアクセス許可のみを確認する必要があります。応答がアクセスフィールドにACCESS4_READが設定されているかどうかを判断するときにサーバーは実行権限ビットを調べてはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if the ACCESS reply has ACCESS4_READ or ACCESS_EXECUTE set, then the user also has permissions to OPEN (Section 18.16) or READ (Section 18.22) the file. In other words, if the client sends an ACCESS request with the ACCESS4_READ and ACCESS_EXECUTE set in the access field (or two separate requests, one with ACCESS4_READ set and the other with ACCESS4_EXECUTE set), and the reply has just ACCESS4_EXECUTE set in the access field (or just one reply has ACCESS4_EXECUTE set), then the user has authorization to OPEN or READ the file.",
      "ja": "アクセス応答にaccess4_readまたはaccess_executeセットがある場合、ユーザーはオープンへのアクセス許可（セクション18.16）またはファイルを読み取り（18.22節））。言い換えれば、クライアントがアクセスフィールド（またはAccess4_read Setを搭載した2つの別々の要求（またはAccess4_Execute Setを搭載した2つの別々の要求、または他方の別々の要求）でアクセス要求を送信し、アクセスフィールドにcovel abse4_executeがセットされている場合（または1回の応答だけにaccess4_execute set）、そのユーザーはファイルを開いたり読み取る権限を持っています。"
    },
    {
      "indent": 0,
      "text": "18.1.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.1.4. 実装"
    },
    {
      "indent": 3,
      "text": "In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access-control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client cannot reliably perform an access check with only current file attributes.",
      "ja": "一般に、クライアントは、ファイル属性内のUID、GID、およびMODEフィールドを検査することによって、またはACL属性の内容を解釈しようとすることによって、クライアントがアクセス許可を推測しようとしていません。これは、サーバーがUIDまたはGIDマッピングを実行したり、追加のアクセス制御の制限を強制したりできるためです。サーバーがクライアントと同じIDスペースにない可能性があります。このような場合（およびおそらく他の）、クライアントは現在のファイル属性のみでアクセスチェックを確実に実行することはできません。"
    },
    {
      "indent": 3,
      "text": "In the NFSv2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFSv4.1 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations that will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and a method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case that the UNIX interface access() is used on the client.",
      "ja": "NFSV2プロトコルでは、操作が許可されているかどうかを判断するための唯一の信頼性の高い方法は、試して、成功または失敗したかどうかを確認します。NFSV4.1プロトコルでのアクセス動作を使用して、クライアントは、1つ以上の操作クラスが許可されているかどうかを示すようにサーバーに要求できます。アクセス動作を実行する前にクライアントが確認できるようにするためにアクセス操作が提供されます。オープン操作は、サーバがファイルオブジェクトへのアクセスを検証できる点とその情報をクライアントに返すメソッドを提供します。アクセス動作は、ディレクトリ操作またはUNIXインタフェースアクセス（）がクライアントで使用されている場合にはまだ役立ちます。"
    },
    {
      "indent": 3,
      "text": "The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.",
      "ja": "アクセスコールに応答してサーバーによって返される情報は永続的ではありません。サーバーがチェックを実行しただけでなく、必ずしもその後は正確には正確でした。サーバーはいつでもアクセス許可を取り消すことができます。"
    },
    {
      "indent": 3,
      "text": "The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent READ and WRITE operations.",
      "ja": "クライアントは、アクセス権の決定に使用されるアクセス要求に認証情報を構築するために、ユーザーの有効資格情報を使用する必要があります。これは、後続の読み取りおよび書き込み操作で使用される有効なユーザーおよびグループの資格情報です。"
    },
    {
      "indent": 3,
      "text": "Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.",
      "ja": "多くの実装はaccess4_deleteの許可を直接サポートしていません。UNIXのようなオペレーティングシステムは、ディレクトリ以外のオブジェクト上のアクセス要求に設定されている場合、access4_deleteビットを無視します。これらのシステムでは、ファイルに対する削除許可は、ファイル自体の権限によって決定されるのではなく、ファイルが存在するディレクトリ上のアクセス権によって決定されます。したがって、マスクはどのアクセス権を決定できるかを列挙できるようになると、ACCESS4_DELETE値が0に設定されます。これは、サーバーがその特定のアクセス権をチェックできなかったクライアントを示します。返されたアクセスマスク内のaccess4_deleteビットは、クライアントによって無視されます。"
    },
    {
      "indent": 0,
      "text": "18.2. Operation 4: CLOSE - Close File",
      "section_title": true,
      "ja": "18.2. 操作4：閉じる - ファイルを閉じる"
    },
    {
      "indent": 0,
      "text": "18.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.2.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct CLOSE4args {\n        /* CURRENT_FH: object */\n        seqid4          seqid;\n        stateid4        open_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.2.2. RESULTS",
      "section_title": true,
      "ja": "18.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union CLOSE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         stateid4       open_stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.2.3. description"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE are only those associated with the supplied stateid. State associated with other OPENs is not affected.",
      "ja": "クローズオペレーションは、現在のファイルハンドルで指定されているように、通常または名前付きの属性ファイルの共有予約を解除します。この範囲内の結果としてサーバーでリリースされた共有予約およびその他の状態情報は、提供されたStareIDに関連付けられているものだけです。他のオープンに関連付けられている状態は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure if any locks would exist after the CLOSE.",
      "ja": "バイトレンジロックが保持されている場合、クライアントは閉じる前にすべてのロックを解放する必要があります。サーバーは閉じるすべての未解決のロックを解放することができますが、一部のサーバーはまだバイトレンジロックが保持されているファイルのクローズをサポートしていない可能性があります。クローズ後にロックが存在する場合は、サーバーは失敗を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The argument seqid MAY have any value, and the server MUST ignore seqid.",
      "ja": "引数seqidは任意の値を持ち、サーバーはseqidを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the combination of principal, security flavor, and, if applicable, GSS mechanism that sent the OPEN request also be the one to CLOSE the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send CLOSE.",
      "ja": "サーバーは、プリンシパル、セキュリティフレーバーの組み合わせ、および該当する場合は、オープン要求を送信したGSSメカニズムもファイルを閉じるものにする必要があるかもしれません。これは、プリンシパルの認証情報が使用できなくなった場合は不可能かもしれません。サーバーは、マシンの信任状またはSSVの信任状（セクション18.35を参照）を送信することができます。"
    },
    {
      "indent": 0,
      "text": "18.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE \"shuts down\" the state associated with all OPENs for the file by a single open-owner. As noted above, CLOSE will either release all file-locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for operations that follow. To help find any uses of this stateid by clients, the server SHOULD return the invalid special stateid (the \"other\" value is zero and the \"seqid\" field is NFS4_UINT32_MAX, see Section 8.2.3).",
      "ja": "closeはStateIDを返しても、このStareIDはクライアントには役立ち、非推奨として扱われるべきです。「シャットダウン」を閉じるシングルオープンオーナーでファイルのすべての状態に関連付けられている状態を開きます。上記のように、closeはすべてのファイルロック状態を解放するか、エラーを返します。したがって、CLOSEによって返されるStartIDは、以下の操作には役立ちません。このStateIDの使用をクライアントに検索するために、サーバーは無効な特別なStareIDを返すべきです（「その他の」値はゼロ、「SEQID」フィールドはNFS4_UINT32_MAXである（8.2.3）。"
    },
    {
      "indent": 3,
      "text": "A CLOSE operation may make delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.",
      "ja": "クローズ操作は、彼らが以前に彼らが以前ではなかった場所に委任を与えるかもしれません。保留中の委任が必要な場合、または後で状況に応答しても、サーバーはすぐに応答することを選択できます。"
    },
    {
      "indent": 0,
      "text": "18.3. Operation 5: COMMIT - Commit Cached Data",
      "section_title": true,
      "ja": "18.3. 操作5：コミット - キャッシュデータをコミットする"
    },
    {
      "indent": 0,
      "text": "18.3.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.3.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct COMMIT4args {\n        /* CURRENT_FH: file */\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.3.2. RESULTS",
      "section_title": true,
      "ja": "18.3.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct COMMIT4resok {\n        verifier4       writeverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union COMMIT4res switch (nfsstat4 status) {\n case NFS4_OK:\n         COMMIT4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.3.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.3.3. description"
    },
    {
      "indent": 3,
      "text": "The COMMIT operation forces or flushes uncommitted, modified data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with one or more WRITE operations that had the \"committed\" field of their results field set to UNSTABLE4.",
      "ja": "コミット操作は、現在のFileHandleで指定されたファイルに対して、コミットされていない、変更されたデータの変更を強制またはフラッシュします。フラッシュされたデータは、結果フィールドの「コミットされた」フィールドをUnStable4に設定した1つ以上の書き込み操作で以前に書き込まれたものです。"
    },
    {
      "indent": 3,
      "text": "The offset specifies the position within the file where the flush is to begin. An offset value of zero means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If the count is zero, a flush from the offset to the end of the file is done.",
      "ja": "オフセットは、フラッシュが始まるファイル内の位置を指定します。ゼロのオフセット値は、ファイルの先頭から始まるデータをフラッシュすることを意味します。COUNTは、フラッシュするデータのバイト数を指定します。カウントがゼロの場合、ファイルのオフセットから最後までフラッシュが行われます。"
    },
    {
      "indent": 3,
      "text": "The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted between the initial WRITE operations and the COMMIT. The client does this by comparing the write verifier returned from the initial WRITE operations and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is restarted; however, other events at the server may result in uncommitted data loss as well.",
      "ja": "コミットが正常に完了すると、サーバーは書き込み検証者を返します。ライト検証者は、最初の書き込み操作とコミット間でサーバーが再起動したかどうかを判断するためにクライアントによって使用されます。クライアントは、初期書き込み操作から返された書き込み検証者とコミット操作によって返される検証者とを比較することによってこれを行います。サーバーは、各サーバーイベントまたはインスタンス化で書き込み検証者の値を変更する必要があります。最も一般的には、これはサーバーが再起動されたときに発生します。ただし、サーバーでの他のイベントも、コミットされていないデータ損失も発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.3.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.3.4. 実装"
    },
    {
      "indent": 3,
      "text": "The COMMIT operation is similar in operation and semantics to the POSIX fsync() [22] system interface that synchronizes a file's state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server's disk or stable storage for the specified file. Like fsync(), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server's normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.",
      "ja": "コミット操作は、ファイルの状態をディスクと同期させるシステムインタフェース（ファイルデータとメタデータにはディスクまたは安定したストレージにフラッシュされている）のOSIX FSYNC（）[22]システムインタフェースの操作とセマンティクスが似ています。COMMITは、クライアントに対して同じ操作を実行し、サーバー上の非同期データとメタデータをサーバーのディスクまたは指定されたファイルの安定したストレージにフラッシュします。fsync（）と同様に、いくつかの変更されたデータがあるか、同期させるための修正されたデータがないことであり得る。データは、サーバーの通常の周期的なバッファ同期アクティビティによって同期されている可能性があります。予期しないエラーがない限り、コミットはNFS4_OKを返すべきです。"
    },
    {
      "indent": 3,
      "text": "COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).",
      "ja": "クライアントがファイルの範囲をフラッシュすることが可能であるという点で、COMMITはfsync（）と異なります（ファイルが完全に書かれた前にクライアント上のバッファ再生方式によって引き起こされる可能性が最も高い）。"
    },
    {
      "indent": 3,
      "text": "The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is, starting at offset zero and count zero, it should do the equivalent of applying fsync() to the entire file. Otherwise, it should arrange to have the modified data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.",
      "ja": "コミットのサーバー実装は合理的に簡単です。サーバーがフルファイルコミット要求を受信した場合、つまりオフセットゼロから始めてゼロをカウントしても、ファイル全体にFSYNC（）を適用することと同等のものを実行する必要があります。それ以外の場合は、オフセットで指定された範囲内の変更データを、安定したストレージにフラッシュするカウントに配置する必要があります。どちらの場合も、ファイルに関連付けられているメタデータを返す前に安定したストレージにフラッシュする必要があります。サーバーにフラッシュするものは何もないことがあるのはエラーではありません。つまり、フラッシュする必要があるデータとメタデータは、最後のサーバーの障害時にすでにフラッシュまたは失われていることを意味します。"
    },
    {
      "indent": 3,
      "text": "The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any modified data based on the offset and count, and flushes any modified metadata associated with the file. It then returns the status of the flush and the write verifier. The second reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of zero and count of zero, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.",
      "ja": "コミットのクライアント実装はもう少し複雑です。クライアントバッファを安定したストレージにコミットしたい理由は2つあります。1つ目は、クライアントがバッファを再利用したいということです。この場合、バッファのオフセットとカウントはコミット要求でサーバーに送信されます。その後、サーバーはオフセットとカウントに基づいて修正されたデータをフラッシュし、ファイルに関連付けられている変更されたメタデータをフラッシュします。次に、フラッシュとライト検証者のステータスを返します。クライアントがコミットを生成するための2番目の理由は、完全なファイルフラッシュのためのものです。この場合、コミットされていないデータを含むこのファイルのすべてのバッファーを収集し、ゼロのオフセットとゼロのカウントを使用してコミット操作を行い、それらのバッファすべてを解放します。通常の方法で他のダーティバッファはサーバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "After a buffer is written (via the WRITE operation) by the client with the \"committed\" field in the result of WRITE set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with the \"committed\" field in the result set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.",
      "ja": "書き込みセットの結果で「コミットされた」フィールドを使用してクライアントによってバッファが書き込まれた後、バッファがコミット操作を介してフラッシュされるまで、バッファはクライアントによって変更されていると見なされなければなりません。または結果セット内の「コミットされた」フィールドをfile_sync4またはdata_sync4に書き込んだ書き込み操作を介して書かれています。これは、データをサーバー上の安定したストレージにフラッシュできる前に、バッファが解放され再利用されるのを防ぐために行われます。"
    },
    {
      "indent": 3,
      "text": "When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that differs from that previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should be sent in a WRITE request with the FILE_SYNC4 stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE operations with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. However, if the server repeatably returns from COMMIT a verifier that differs from that returned by WRITE, the only way to ensure progress is to retransmit all of the buffers with WRITE requests with the FILE_SYNC4 stable parameter.",
      "ja": "書き込みまたはコミット操作のいずれかから応答が返され、それはサーバーによって以前に返されたそれとは異なる書き込み検証子を含む場合、クライアントは、コミットされていないデータを含むすべてのバッファをサーバーに再送信する必要があります。これがどのように行われるべきかは、実装者次第です。関心のあるバッファが1つしかない場合は、file_sync4 stableパラメータを使用して書き込み要求で送信する必要があります。複数のバッファがある場合は、安定したパラメータをUnStable4に設定した書き込み操作ですべてのバッファを再送信し、そのコミット操作を再送信し、サーバー上のすべてのデータを安定したストレージにフラッシュするように再送信します。ただし、サーバーが書き込みによって返されるそれとは異なるコミットA検証者から繰り返し戻る場合、進歩を確実にするための唯一の方法は、file_sync4安定したパラメータを使用して書き込み要求を持つすべてのバッファを再送信することです。"
    },
    {
      "indent": 3,
      "text": "The above description applies to page-cache-based systems as well as buffer-cache-based systems. In the former systems, the virtual memory system will need to be modified instead of the buffer cache.",
      "ja": "上記の説明は、ページキャッシュベースのシステムおよびバッファキャッシュベースのシステムに適用されます。前者のシステムでは、バッファキャッシュの代わりに仮想メモリシステムを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.4. Operation 6: CREATE - Create a Non-Regular File Object",
      "section_title": true,
      "ja": "18.4. 操作6：CREATE  - 非正規ファイルオブジェクトを作成する"
    },
    {
      "indent": 0,
      "text": "18.4.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.4.1. 議論"
    },
    {
      "indent": 3,
      "text": "union createtype4 switch (nfs_ftype4 type) {\n case NF4LNK:\n         linktext4 linkdata;\n case NF4BLK:\n case NF4CHR:\n         specdata4 devdata;\n case NF4SOCK:\n case NF4FIFO:\n case NF4DIR:\n         void;\n default:\n         void;  /* server should return NFS4ERR_BADTYPE */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CREATE4args {\n        /* CURRENT_FH: directory for creation */\n        createtype4     objtype;\n        component4      objname;\n        fattr4          createattrs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.4.2. RESULTS",
      "section_title": true,
      "ja": "18.4.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CREATE4resok {\n        change_info4    cinfo;\n        bitmap4         attrset;        /* attributes set */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union CREATE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         /* new CURRENTFH: created object */\n         CREATE4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.4.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.4.3. description"
    },
    {
      "indent": 3,
      "text": "The CREATE operation creates a file object other than an ordinary file in a directory with a given name. The OPEN operation MUST be used to create a regular file or a named attribute.",
      "ja": "作成操作は、指定された名前のディレクトリ内の通常のファイル以外のファイルオブジェクトを作成します。オープン操作は、通常のファイルまたは名前付き属性を作成するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The current filehandle must be a directory: an object of type NF4DIR. If the current filehandle is an attribute directory (type NF4ATTRDIR), the error NFS4ERR_WRONG_TYPE is returned. If the current filehandle designates any other type of object, the error NFS4ERR_NOTDIR results.",
      "ja": "現在のファイルハンドルはディレクトリでなければなりません：NF4DIR型のオブジェクト。現在のファイルハンドルが属性ディレクトリ（タイプNF4ATTRDIR）の場合、エラーNFS4ERR_WRONG_TYPEが返されます。現在のファイルハンドルが他のタイプのオブジェクトを指定すると、エラーNFS4ERR_NOTDIRの結果が得られます。"
    },
    {
      "indent": 3,
      "text": "The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc. If the object type specified is that of an ordinary file, a named attribute, or a named attribute directory, the error NFS4ERR_BADTYPE results.",
      "ja": "objnameは新しいオブジェクトの名前を指定します。objtypeは、指定されたオブジェクトの種類を決定します。ディレクトリ、シンボリンクなどが指定されたオブジェクトタイプは、通常のファイル、名前付き属性、または名前付き属性ディレクトリの場合、エラーNFS4ERR_BADTYPEが発生します。"
    },
    {
      "indent": 3,
      "text": "If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.",
      "ja": "同じ名前のオブジェクトがディレクトリにすでに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.",
      "ja": "新しいファイルオブジェクトが作成されたディレクトリの場合、サーバーはCinfoのchange_info4情報を返します。change_info4データ型のアトミックフィールドを使用すると、サーバーはファイルオブジェクトの作成に対して前後の変更属性がアトミックに取得されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If the objname has a length of zero, or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "objnameの長さがゼロの場合、またはobjnameがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "The current filehandle is replaced by that of the new object.",
      "ja": "現在のファイルハンドルは新しいオブジェクトのそれに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "The createattrs specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.",
      "ja": "CreateAttrsは、オブジェクトの初期属性セットを指定します。一連の属性には、オブジェクトタイプに有効な任意の書き込み可能な属性が含まれます。操作が成功すると、サーバーはクライアントに戻り、オブジェクトのどの属性が正常に設定されたかを署名します。"
    },
    {
      "indent": 3,
      "text": "If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server's file system both supports and requires an owner attribute (or an owner ACE), then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server's operating environment or file system semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server's file system both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC call's credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (e.g., POSIX systems have a user database [23] that has a group identifier for every user identifier), inherited from the directory in which the object is created, or whatever else the server's operating environment or file system semantics dictate. This applies to the OPEN operation too.",
      "ja": "CreateAttrsが所有者の所有者属性もACLを含まない場合、およびサーバーのファイルシステムが所有者属性（または所有者ACE）をサポートしている場合は、サーバーは所有者（または所有者ACE）を導出する必要があります。 。これは通常、呼び出しのRPC認証情報に示されているプリンシパルからのものですが、サーバーの動作環境またはファイルシステムの意味論は他の派生の方法を決定することがあります。同様に、CreateAttrsにGROUP属性もグループACEも含まれていない場合、サーバーのファイルシステムがグループ属性（またはグループACE）の概念をサポートして要求する場合、サーバーはグループ属性（または対応する所有者ACE）を導出する必要があります。ファイルの場合これは、資格情報が認証情報内のプリンシパルに関連付けられているグループ識別子から（例えば、POSIXシステムのユーザーデータベースを持つ[23]の場合、AUTH_SYSなど）のグループプリンシパルなどのRPC呼び出しの認証情報からのものです。オブジェクトが作成されているディレクトリから継承されているすべてのユーザーIDのグループ識別子、またはサーバーの動作環境またはファイルシステムの意味論が指定されています。これもオープン操作にも適用されます。"
    },
    {
      "indent": 3,
      "text": "Conversely, it is possible that the client will specify in createattrs an owner attribute, group attribute, or ACL that the principal indicated the RPC call's credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.",
      "ja": "逆に、クライアントがCreateAttrsで指定された所有者属性、group属性、またはACLで指定されていることは、RPC呼び出しの認証情報にファイルを作成する権限がないことが示されている可能性があります。このインスタンスで返されるエラーはNFS4ERR_PERMです。これもオープン操作にも適用されます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the CREATE operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルが別のクライアントがディレクトリの委任を保持するディレクトリを指定した場合、委任が通知を送信して状況を解決できるようなものでない限り、委任を呼び出す必要があり、作成操作は委任まで続行してはいけません。返されたか失効されます。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.",
      "ja": "現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定すると、これらの代理店がそのような通知を要求すると、この操作の結果としてNotify4_ad_Entryが生成されます。"
    },
    {
      "indent": 3,
      "text": "If the capability FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set (Section 14.4), and a symbolic link is being created, then the content of the symbolic link MUST be in UTF-8 encoding.",
      "ja": "機能fscharset_cap4_allows_only_utf8が設定されている場合（セクション14.4）、シンボリックリンクが作成されている場合、シンボリックリンクの内容はUTF-8エンコーディングでなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.4.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.4.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.",
      "ja": "作成後にクライアントが属性値を設定したい場合は、適切な属性が設定されるように、複合要求にSETATTR操作を追加できます。"
    },
    {
      "indent": 0,
      "text": "18.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery",
      "section_title": true,
      "ja": "18.5. 操作7：DELEGPURGE  - リカバリを待っているパージ代議員"
    },
    {
      "indent": 0,
      "text": "18.5.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.5.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct DELEGPURGE4args {\n        clientid4       clientid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.5.2. RESULTS",
      "section_title": true,
      "ja": "18.5.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DELEGPURGE4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.5.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.5.3. description"
    },
    {
      "indent": 3,
      "text": "This operation purges all of the delegations awaiting recovery for a given client. This is useful for clients that do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.",
      "ja": "この操作は、特定のクライアントの回復を待っているすべての代理店を削除します。これは、代表団情報の回復を待っているサーバーによって競合する要求を遅延させる必要がないことを示すために、委任情報を安定したストレージにコミットしないクライアントに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The client is NOT specified by the clientid field of the request. The client SHOULD set the client field to zero, and the server MUST ignore the clientid field. Instead, the server MUST derive the client ID from the value of the session ID in the arguments of the SEQUENCE operation that precedes DELEGPURGE in the COMPOUND request.",
      "ja": "クライアントは要求のClientIDフィールドによって指定されていません。クライアントはクライアントフィールドをゼロに設定し、サーバーはClientIDフィールドを無視する必要があります。代わりに、複合要求のDELEGPURGEに先行するシーケンス操作の引数内のセッションIDの値から、サーバーはクライアントIDを導出する必要があります。"
    },
    {
      "indent": 3,
      "text": "The DELEGPURGE operation should be used by clients that record delegation information on stable storage on the client. In this case, after the client recovers all delegations it knows of, it should immediately send a DELEGPURGE operation. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients which make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client might be different. The reason for this is that after sending a request that resulted in a delegation, the client might experience a failure before it both received the delegation and committed the delegation to the client's stable storage.",
      "ja": "デリゲプレージ操作は、クライアント上の安定したストレージ上の委任情報を記録するクライアントによって使用されるべきです。この場合、クライアントがそれが知っているすべての代理人を回復した後、それは直ちにデルグプレの操作を送るべきです。そうすることで、クライアントの追加の委任が回復されないように、リソースを解放することができず、回復されていない委任との競合を要求する他のクライアントの遅延を避けることをサーバーに通知されます。サーバーとクライアントに認識されている代表団のセットが異なる場合があります。これは、委任をもたらした要求を送信した後、クライアントは両方とも委任を受け取り、委任をクライアントの安定したストレージにコミットする前に障害が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The server MAY support DELEGPURGE, but if it does not, it MUST NOT support CLAIM_DELEGATE_PREV and MUST NOT support CLAIM_DELEG_PREV_FH.",
      "ja": "サーバーはDELEGPURGEをサポートできますが、そうでない場合は、クレームをサポートしてはならず、クレームをサポートしてはいけません。"
    },
    {
      "indent": 0,
      "text": "18.6. Operation 8: DELEGRETURN - Return Delegation",
      "section_title": true,
      "ja": "18.6. 操作8：DELEGRETURN  - 返品代表団"
    },
    {
      "indent": 0,
      "text": "18.6.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.6.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct DELEGRETURN4args {\n        /* CURRENT_FH: delegated object */\n        stateid4        deleg_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.6.2. RESULTS",
      "section_title": true,
      "ja": "18.6.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DELEGRETURN4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.6.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.6.3. description"
    },
    {
      "indent": 3,
      "text": "The DELEGRETURN operation returns the delegation represented by the current filehandle and stateid.",
      "ja": "DELEGRETURN演算は、現在のFileHandleとStareIDによって表される委任を返します。"
    },
    {
      "indent": 3,
      "text": "Delegations may be returned voluntarily (i.e., before the server has recalled them) or when recalled. In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.",
      "ja": "代表団は自発的に（すなわち、サーバがそれらを呼び戻される前）または呼び戻されることができる。どちらの場合でも、委任を返す前に、クライアントは委任のコンテキストの下で変化した状態をサーバーに正しく伝播する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the delegation also be the one to send DELEGRETURN on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send DELEGRETURN.",
      "ja": "サーバーには、プリンシパル、セキュリティフレーバー、および該当する場合は、GSSメカニズム、委任を取得した組み合わせも、ファイルにDELEGRETURNを送信するためのものであることが必要です。これは、プリンシパルの認証情報が使用できなくなった場合は不可能かもしれません。サーバーでは、マシンの資格情報またはSSVの信任状（セクション18.35を参照）がDELEGRETURTURを送信できます。"
    },
    {
      "indent": 0,
      "text": "18.7. Operation 9: GETATTR - Get Attributes",
      "section_title": true,
      "ja": "18.7. 操作9：getAttr  - 属性を取得します"
    },
    {
      "indent": 0,
      "text": "18.7.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.7.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct GETATTR4args {\n        /* CURRENT_FH: object */\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.7.2. RESULTS",
      "section_title": true,
      "ja": "18.7.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETATTR4resok {\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         GETATTR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.7.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.7.3. description"
    },
    {
      "indent": 3,
      "text": "The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values that it was able to return, which will include all attributes requested by the client that are attributes supported by the server for the target file system. This bitmap is followed by the attribute values ordered lowest attribute number first.",
      "ja": "getAttrの操作は、現在のFileHandleで指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーに返却したい属性値ごとにビットマップ引数のビットを設定します。サーバーは、返された属性値を示す属性ビットマップを返します。これは、ターゲットファイルシステムのサーバーでサポートされている属性であるクライアントによって要求されたすべての属性を含みます。このビットマップの後には、属性値が最初に最小属性番号の順序付けられた属性値が続きます。"
    },
    {
      "indent": 3,
      "text": "The server MUST return a value for each attribute that the client requests if the attribute is supported by the server for the target file system. If the server does not support a particular attribute on the target file system, then it MUST NOT return the attribute value and MUST NOT set the attribute bit in the result bitmap. The server MUST return an error if it supports an attribute on the target but cannot obtain its value. In that case, no attribute values will be returned.",
      "ja": "サーバーは、属性がターゲットファイルシステムのサーバーでサポートされている場合、クライアントが要求する各属性の値を返す必要があります。サーバーがターゲットファイルシステム上の特定の属性をサポートしていない場合は、属性値を返さないでください。結果ビットマップの属性ビットを設定しないでください。ターゲット上の属性がサポートされているがその値を取得できない場合、サーバーはエラーを返す必要があります。その場合、属性値は返されません。"
    },
    {
      "indent": 3,
      "text": "File systems that are absent should be treated as having support for a very small set of attributes as described in Section 11.4.1, even if previously, when the file system was present, more attributes were supported.",
      "ja": "存在しないファイルシステムは、セクション11.4.1で説明されているように、セクション11.4.1で説明されているように、非常に小さい属性のセットをサポートするものとして扱われるべきです。ファイルシステムが存在する場合でも、より多くの属性がサポートされました。"
    },
    {
      "indent": 3,
      "text": "All servers MUST support the REQUIRED attributes as specified in Section 5.6, for all file systems, with the exception of absent file systems.",
      "ja": "すべてのサーバーは、ファイルシステムが不在を除いて、すべてのファイルシステムのセクション5.6で指定されている必須属性をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.7.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.7.4. 実装"
    },
    {
      "indent": 3,
      "text": "Suppose there is an OPEN_DELEGATE_WRITE delegation held by another client for the file in question and size and/or change are among the set of attributes being interrogated. The server has two choices. First, the server can obtain the actual current value of these attributes from the client holding the delegation by using the CB_GETATTR callback. Second, the server, particularly when the delegated client is unresponsive, can recall the delegation in question. The GETATTR MUST NOT proceed until one of the following occurs:",
      "ja": "質問および/または変更内のファイルについて別のクライアントによって保持されているOpen_Delegate_Write代理店があるとします。サーバーには2つの選択肢があります。まず、サーバは、CB_GetATTRコールバックを使用して、委任を保持しているクライアントからこれらの属性の実際の現在の値を取得できます。第二に、サーバは、特に委任されたクライアントが応答しない場合、問題の委任を思い出すことができる。次のいずれかが発生するまで、getAttrは続行してはいけません。"
    },
    {
      "indent": 3,
      "text": "* The requested attribute values are returned in the response to CB_GETATTR.",
      "ja": "* 要求された属性値はCB_GetAttrに応答して返されます。"
    },
    {
      "indent": 3,
      "text": "* The OPEN_DELEGATE_WRITE delegation is returned.",
      "ja": "* Open_Delegate_Writeの委任が返されます。"
    },
    {
      "indent": 3,
      "text": "* The OPEN_DELEGATE_WRITE delegation is revoked.",
      "ja": "* Open_Delegate_Writeの委任が失効されます。"
    },
    {
      "indent": 3,
      "text": "Unless one of the above happens very quickly, one or more NFS4ERR_DELAY errors will be returned while a delegation is outstanding.",
      "ja": "上記のいずれかが非常に迅速に起こらない限り、委任が未解決の間に1つ以上のNFS4ERR_DELAYエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "18.8. Operation 10: GETFH - Get Current Filehandle",
      "section_title": true,
      "ja": "18.8. 操作10：GETFH  - 現在のファイルハンドルを取得します"
    },
    {
      "indent": 0,
      "text": "18.8.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.8.1. 議論"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.8.2. RESULTS",
      "section_title": true,
      "ja": "18.8.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETFH4resok {\n        nfs_fh4         object;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GETFH4res switch (nfsstat4 status) {\n case NFS4_OK:\n        GETFH4resok     resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.8.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.8.3. description"
    },
    {
      "indent": 3,
      "text": "This operation returns the current filehandle value.",
      "ja": "この操作は現在のファイルハンドル値を返します。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.10.6.4, GETFH is REQUIRED or RECOMMENDED to immediately follow certain operations, and servers are free to reject such operations if the client fails to insert GETFH in the request as REQUIRED or RECOMMENDED. Section 18.16.4.1 provides additional justification for why GETFH MUST follow OPEN.",
      "ja": "2.10.6.4項で説明されているように、GETFHが必要または特定の操作に従うために必要または推奨され、必要に応じてクライアントが要求にGETFHを挿入しない場合はそのような操作が自由に拒否されます。セクション18.16.4.1は、GETFHがOpenに従わなければならない理由の追加の正当化を提供します。"
    },
    {
      "indent": 0,
      "text": "18.8.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.8.4. 実装"
    },
    {
      "indent": 3,
      "text": "Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to look up a directory entry and obtain its filehandle, then the following request is needed.",
      "ja": "現在のファイルハンドルを変更または作成する操作は、結果として新しいFileHandleを自動的に返しません。たとえば、クライアントがディレクトリエントリを検索してそのファイルハンドルを取得する必要がある場合は、次の要求が必要です。"
    },
    {
      "indent": 6,
      "text": "PUTFH (directory filehandle)",
      "ja": "putfh（ディレクトリファイルハンドル）"
    },
    {
      "indent": 6,
      "text": "LOOKUP (entry name)",
      "ja": "ルックアップ（エントリ名）"
    },
    {
      "indent": 6,
      "text": "GETFH",
      "ja": "get get"
    },
    {
      "indent": 0,
      "text": "18.9. Operation 11: LINK - Create Link to a File",
      "section_title": true,
      "ja": "18.9. 操作11：リンク - ファイルへのリンクを作成する"
    },
    {
      "indent": 0,
      "text": "18.9.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.9.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct LINK4args {\n        /* SAVED_FH: source object */\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.9.2. RESULTS",
      "section_title": true,
      "ja": "18.9.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LINK4resok {\n        change_info4    cinfo;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.9.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.9.3. description"
    },
    {
      "indent": 3,
      "text": "The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.",
      "ja": "リンク操作は、Savefh操作によって設定された、現在のファイルハンドルによって表されるディレクトリに設定されているファイルハンドルによって表されるファイルの追加の新名を作成します。既存のファイルとターゲットディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功すると、現在のファイルハンドルはターゲットディレクトリになります。新しい名前のターゲットディレクトリにオブジェクトが存在する場合、サーバーはNFS4ERR_EXISTを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバーはCINFOのchange_info4情報を返します。change_info4データ型のアトミックフィールドを使用すると、サーバーはリンク作成に対して前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If the newname has a length of zero, or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "NewNameの長さがゼロの場合、またはNEWNAMEがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.9.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.9.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the LINK operation such that LINK may not be done when the file is open or when that open is done by particular protocols, or with particular options or access modes. When LINK is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "サーバは、ファイルが開いているとき、またはその開いているときにリンクが特定のプロトコル、または特定のオプションまたはアクセスモードによって行われたときにリンクが実行されないように、リンク操作に制限を課すことができる。このような制限のためにリンクが拒否されると、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a link, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. The reason is that when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The LINK operation must be delayed only until a definitive result can be obtained. For example, suppose there are multiple delegations and one of them establishes an open whose presence would prevent the link. Given the server's semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.",
      "ja": "サーバーがそのような制限を実装し、これらの制限にはNFSv4の場合が含まれている場合は、リンクの実行が成功しないために開きます。サーバーは、その決定に関連する開いたオープンの存在を隠すことができる委任を思い出す必要があります。その理由は、クライアントが委任を保持している場合、クライアントが開いてローカルに閉じることがあるため、サーバーはそのクライアントの開封が正確なアカウントを持たない可能性があります。リンク操作は、最終的な結果が得られるまでのみ遅延する必要があります。たとえば、複数の代表団があるとし、そのうちの1つが存在のあるオープンを確立します。サーバーのセマンティクスを考えると、NFS4ERR_FILE_OPENはその委任が返されることなく返されるとすぐに呼び出し元に返されます。同様に、そのようなオープンが代理人に関連付けられていない場合、NFS4ERR_FILE_OPENはすぐに委任リコールが行われずに返されます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot be performed successfully until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルが別のクライアントがディレクトリの委任を保持するディレクトリを指定した場合、委任が通知を送信して状況を解決できるように、委任を呼び出す必要があり、委任が正常に実行できません。返されたか失効されます。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, instead of a recall, NOTIFY4_ADD_ENTRY will be generated as a result of the LINK operation.",
      "ja": "現在のファイルハンドルが1つまたは複数のディレクトリ委任が存在するディレクトリを指定すると、それらの代理店がリコールの代わりにそのような通知を要求すると、リンク操作の結果としてNotify4_ad_Entryが生成されます。"
    },
    {
      "indent": 3,
      "text": "If the current file system supports the numlinks attribute, and other clients have delegations to the file being linked, then those delegations MUST be recalled and the LINK operation MUST NOT proceed until all delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルシステムがnumLinks属性をサポートしており、他のクライアントにリンクされているファイルへの委任がある場合は、それらの代表録を呼び出す必要があり、すべての委任が返されるか取り消されるまでリンク操作を続行しないでください。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "Changes to any property of the \"hard\" linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.",
      "ja": "「ハード」リンクファイルの任意のプロパティへの変更は、リンクされたすべてのファイルに反映されます。リンクがファイルに行われると、ファイルの属性はリンク操作の前の値より1つが大きいNumLinkの値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "The statement \"file and the target directory must reside within the same file system on the server\" means that the fsid fields in the attributes for the objects are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned. This error may be returned by some servers when there is an internal partitioning of a file system that the LINK operation would violate.",
      "ja": "ステートメント「ファイルとターゲージディレクトリはサーバー上の同じファイルシステム内に存在する必要があります」とは、オブジェクトの属性のFSIDフィールドが同じであることを意味します。異なるファイルシステムに存在する場合は、エラーNFS4ERR_XDEVが返されます。このエラーは、リンク操作が違反するファイルシステムの内部分割がある場合、一部のサーバーによって返される可能性があります。"
    },
    {
      "indent": 3,
      "text": "On some servers, \".\" and \"..\" are illegal values for newname and the error NFS4ERR_BADNAME will be returned if they are specified.",
      "ja": "一部のサーバーでは、 \"。\"そして、 \"..\"はnewnameの不正な値であり、エラーnfs4err_badnameが指定されている場合は返されます。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is not a named attribute for the same object, the error NFS4ERR_XDEV MUST be returned. When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory, the error NFS4ERR_XDEV MUST also be returned.",
      "ja": "現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンク対象のオブジェクト（保存されたファイルハンドル）が同じオブジェクトの名前付き属性ではない場合は、エラーNFS4ERR_XDEVを返す必要があります。保存されたファイルハンドルが名前付き属性を指定し、現在のFileHandleが適切な名前付き属性ディレクトリではありませんが、エラーNFS4ERR_XDEVも返す必要があります。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is a named attribute within that directory, the server may return the error NFS4ERR_NOTSUPP.",
      "ja": "現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンクされるオブジェクト（保存されたファイルハンドル）はそのディレクトリ内の名前付き属性である場合、サーバーはエラーNFS4ERR_NOTSUPPを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.",
      "ja": "新しい名前がすでに保存されたファイルハンドルによって表されるファイルにリンクされている場合、サーバーはNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "Note that symbolic links are created with the CREATE operation.",
      "ja": "シンボリックリンクは作成操作で作成されます。"
    },
    {
      "indent": 0,
      "text": "18.10. Operation 12: LOCK - Create Lock",
      "section_title": true,
      "ja": "18.10. 操作12：ロック - ロックを作成します"
    },
    {
      "indent": 0,
      "text": "18.10.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.10.1. 議論"
    },
    {
      "indent": 3,
      "text": "/*\n * For LOCK, transition from open_stateid and lock_owner\n * to a lock stateid.\n */\nstruct open_to_lock_owner4 {\n        seqid4          open_seqid;\n        stateid4        open_stateid;\n        seqid4          lock_seqid;\n        lock_owner4     lock_owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * For LOCK, existing lock stateid continues to request new\n * file lock for the same lock_owner and open_stateid.\n */\nstruct exist_lock_owner4 {\n        stateid4        lock_stateid;\n        seqid4          lock_seqid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union locker4 switch (bool new_lock_owner) {\n case TRUE:\n        open_to_lock_owner4     open_owner;\n case FALSE:\n        exist_lock_owner4       lock_owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * LOCK/LOCKT/LOCKU: Record lock management\n */\nstruct LOCK4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        bool            reclaim;\n        offset4         offset;\n        length4         length;\n        locker4         locker;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.10.2. RESULTS",
      "section_title": true,
      "ja": "18.10.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOCK4denied {\n        offset4         offset;\n        length4         length;\n        nfs_lock_type4  locktype;\n        lock_owner4     owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LOCK4resok {\n        stateid4        lock_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LOCK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LOCK4resok     resok4;\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.10.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.10.3. description"
    },
    {
      "indent": 3,
      "text": "The LOCK operation requests a byte-range lock for the byte-range specified by the offset and length parameters, and lock type specified in the locktype parameter. If this is a reclaim request, the reclaim parameter will be TRUE.",
      "ja": "ロック操作は、オフセットパラメータと長さのパラメータで指定されたバイト範囲のバイトレンジロック、およびlockTypeパラメータで指定されたロックタイプを要求します。これがReclaim要求の場合、Reclaimパラメータはtrueになります。"
    },
    {
      "indent": 3,
      "text": "Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field equal to NFS4_UINT64_MAX. The server MUST return NFS4ERR_INVAL under the following combinations of length and offset:",
      "ja": "ファイル内のバイトは、それらのバイトが現在ファイルに割り当てられていなくてもロックされている可能性があります。ファイルをファイルの終わりからファイルをロックするには（実際にファイルがどのくらいの長さであっても）NFS4_UINT64_MAXに等しい長さフィールドを使用します。サーバーは次の長さとオフセットの組み合わせの下にNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* Length is equal to zero.",
      "ja": "* 長さはゼロに等しい。"
    },
    {
      "indent": 3,
      "text": "* Length is not equal to NFS4_UINT64_MAX, and the sum of length and offset exceeds NFS4_UINT64_MAX.",
      "ja": "* 長さはNFS4_UINT64_MAXに等しくなく、長さとオフセットの合計がNFS4_UINT64_MAXを超えています。"
    },
    {
      "indent": 3,
      "text": "32-bit servers are servers that support locking for byte offsets that fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX). If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX, then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.",
      "ja": "32ビットサーバーは、32ビット内に収まるバイトオフセットのロックをサポートするサーバーです（すなわち、NFS4_UINT32_MAX以下）。クライアントがオフセットNFS4_UINT32_MAXを超えて1つ以上のバイトを超えているがオフセットNFS4_UINT64_MAXで終わらない範囲を指定した場合、そのような32ビットサーバはエラーNFS4ERR_BAD_RANGEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server returns NFS4ERR_DENIED, the owner, offset, and length of a conflicting lock are returned.",
      "ja": "サーバーがNFS4ERR_DENIEDを返す場合、競合するロックの所有者、オフセット、および長さが返されます。"
    },
    {
      "indent": 3,
      "text": "The locker argument specifies the lock-owner that is associated with the LOCK operation. The locker4 structure is a switched union that indicates whether the client has already created byte-range locking state associated with the current open file and lock-owner. In the case in which it has, the argument is just a stateid representing the set of locks associated with that open file and lock-owner, together with a lock_seqid value that MAY be any value and MUST be ignored by the server. In the case where no byte-range locking state has been established, or the client does not have the stateid available, the argument contains the stateid of the open file with which this lock is to be associated, together with the lock-owner with which the lock is to be associated. The open_to_lock_owner case covers the very first lock done by a lock-owner for a given open file and offers a method to use the established state of the open_stateid to transition to the use of a lock stateid.",
      "ja": "locker引数は、ロック操作に関連付けられているロックー所有者を指定します。LOCKER4構造は、クライアントが現在のオープンファイルとLock-Ownerに関連付けられているバイトレンジロック状態をすでに作成しているかどうかを示すスイッチ接続されました。それが持っている場合、引数は、そのオープンファイルとロックー所有者に関連付けられているロックのセットを表す単なるStareIDを、任意の値である可能性があるlock_seqid値とともに、サーバーによって無視される必要があります。バイトレンジロック状態が確立されていない場合、またはクライアントにStateIDが使用可能な場合、引数には、このロックが関連付けられているオープンファイルのStateIDが含まれています。ロックを関連付けることです。Open_To_Lock_Ownerケースは、特定のオープンファイルのロックーオーナーによって完成した非常に最初のロックをカバーし、Open_StateIDの確立された状態を使用してロックステーションIDの使用に移行する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The following fields of the locker parameter MAY be set to any value by the client and MUST be ignored by the server:",
      "ja": "ロッカーパラメータの以下のフィールドは、クライアントによって任意の値に設定されていることができ、サーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "* The clientid field of the lock_owner field of the open_owner field (locker.open_owner.lock_owner.clientid). The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.",
      "ja": "* Open_ownerフィールドのlock_ownerフィールド（locker.open_owner.lock_own_owner.clientID）のclientIDフィールド。サーバーがClientIDフィールドを無視する必要があるのは、サーバーが複合要求のシーケンス操作からセッションIDからクライアントIDを導出する必要があることです。"
    },
    {
      "indent": 3,
      "text": "* The open_seqid and lock_seqid fields of the open_owner field (locker.open_owner.open_seqid and locker.open_owner.lock_seqid).",
      "ja": "* Open_OWNERフィールド（locker.open_owner.open_seqidおよびlocker.open_owner.lock_seqid）のopen_seqidフィールドフィールド。"
    },
    {
      "indent": 3,
      "text": "* The lock_seqid field of the lock_owner field (locker.lock_owner.lock_seqid).",
      "ja": "* lock_ownerフィールドのlock_seqidフィールド（locker.lock_owner.lock_seqid）。"
    },
    {
      "indent": 3,
      "text": "Note that the client ID appearing in a LOCK4denied structure is the actual client associated with the conflicting lock, whether this is the client ID associated with the current session or a different one. Thus, if the server returns NFS4ERR_DENIED, it MUST set the clientid field of the owner field of the denied field.",
      "ja": "LOCK4DENIED構造体に表示されているクライアントIDは、これが現在のセッションに関連付けられているクライアントIDまたは別のものであろうと競合するロックに関連付けられている実際のクライアントです。したがって、サーバーがNFS4ERR_DENIEDを返す場合は、拒否フィールドの所有者フィールドのClientIDフィールドを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルではない場合、エラーがクライアントに返されます。現在のファイルハンドルがNF4DIR型のオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべての場合では、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.10.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.10.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server is unable to determine the exact offset and length of the conflicting byte-range lock, the same offset and length that were provided in the arguments should be returned in the denied results.",
      "ja": "サーバーが競合するバイトレンジロックの正確なオフセットと長さを判別できない場合は、引数に指定された同じオフセットと長さを拒否された結果に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific right and modes required for various types of locks reflect the semantics of the server-exported file system, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for read access, while a POSIX-compliant system does not.",
      "ja": "ロック操作は許可のチェックを受け、関連するファイルのアクセスタイプをチェックすることがあります。ただし、さまざまな種類のロックに必要な特定の権利とモードは、サーバーエクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルによっては指定されていません。たとえば、Windows 2000では、POSIX準拠のシステムではなく、読み取りアクセスのために開くファイルの書き込みロックを許可します。"
    },
    {
      "indent": 3,
      "text": "When the client sends a LOCK operation that corresponds to a range that the lock-owner has locked already (with the same or different lock type), or to a sub-range of such a range, or to a byte-range that includes multiple locks already granted to that lock-owner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock-owner and LOCKU of locks held by that lock-owner (specifying an exactly matching range and type). Similarly, when the client sends a LOCK operation that amounts to upgrading (changing from a READ_LT lock to a WRITE_LT lock) or downgrading (changing from WRITE_LT lock to a READ_LT lock) an existing byte-range lock, and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting LOCK operations from other clients.",
      "ja": "クライアントがロック所有者が既にロックされている（同じまたは異なるロックタイプで）、またはそのような範囲のサブレンジ、または複数のバイト範囲の範囲に対応するロック操作を送信するときそのロック所有者にすでにそのロック所有者に付与されているロック、およびサーバーはそのようなロック操作をサポートしていない（つまり、POSIXロックセマンティクスをサポートしていません）、サーバーはエラーNFS4ERR_LOCK_RANGEを返します。その場合、クライアントはエラーを返すことも、そのロックオーナーによって既にロックされているバイトとそのロック所有者が保持しているロックのロックのロックを含まない範囲のロックのみを使用して、必要な操作をエミュレートすることができます。正確に一致する範囲とタイプ）。同様に、クライアントがアップグレードになるロック操作（READ_LTロックからwrite_LTロックへの変更）またはダウングレード（WRITE_LTロックからREAD_LTロックへの変更）に既存のバイトレンジロックを送信し、サーバーはサポートされていません。ロック、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。そのような操作は、他のクライアントからの競合するロック操作に直面して必要な意味論を完全に反映していない可能性があります。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, the client holding that delegation is assured that there are no opens by other clients. Thus, there can be no conflicting LOCK operations from such clients. Therefore, the client may be handling locking requests locally, without doing LOCK operations on the server. If it does that, it must be prepared to update the lock status on the server, by sending appropriate LOCK and LOCKU operations before returning the delegation.",
      "ja": "クライアントがOpen_Delegate_Writeの委任を保持すると、その委任を保持しているクライアントは、他のクライアントによって開くことができないことを保持します。したがって、そのようなクライアントから矛盾するロック操作はあり得ない。したがって、クライアントは、サーバー上のロック操作を行わずにローカルにロック要求を処理することができます。それがそうであれば、委任を返す前に適切なロックとロック操作を送信することによって、サーバー上のロックステータスを更新する準備をしなければなりません。"
    },
    {
      "indent": 3,
      "text": "When one or more clients hold OPEN_DELEGATE_READ delegations, any LOCK operation where the server is implementing mandatory locking semantics MUST result in the recall of all such delegations. The LOCK operation may not be granted until all such delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding.",
      "ja": "1つ以上のクライアントがOpen_Delegate_readの代表団を保持するとき、サーバーが必須のロックセマンティクスを実装しているロック操作は、そのようなすべての委任を思い出す必要があります。ロック操作は、そのようなすべての委任が返却または失効されるまで認められない可能性があります。これが非常に早く起こる場合を除き、委任が未解決のままである間、1つ以上のNFS4ERR_DELAYエラーが要求された要求に返されます。"
    },
    {
      "indent": 0,
      "text": "18.11. Operation 13: LOCKT - Test for Lock",
      "section_title": true,
      "ja": "18.11. 操作13：ロック - ロックのテスト"
    },
    {
      "indent": 0,
      "text": "18.11.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.11.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct LOCKT4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        offset4         offset;\n        length4         length;\n        lock_owner4     owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.11.2. RESULTS",
      "section_title": true,
      "ja": "18.11.2. 結果"
    },
    {
      "indent": 3,
      "text": "union LOCKT4res switch (nfsstat4 status) {\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n case NFS4_OK:\n         void;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.11.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.11.3. description"
    },
    {
      "indent": 3,
      "text": "The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned. The owner field in the results includes the client ID of the owner of the conflicting lock, whether this is the client ID associated with the current session or a different client ID. If no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.",
      "ja": "LOCKT操作は、引数で指定されているようにロックをテストします。競合するロックが存在する場合は、競合するロックの所有者、オフセット、長さ、およびタイプが返されます。結果の所有者フィールドには、現在のセッションに関連付けられているクライアントIDまたは別のクライアントIDが関連付けられているかどうかにかかわらず、競合するロックの所有者のクライアントIDが含まれています。ロックが保持されていない場合は、NFS4_OK以外の何も返されません。ロックタイプREAD_LTとREADW_LTは、ブロッキングまたはノンブロッキングに関係なく競合するロックテストが行われるという点で同じように処理されます。write_ltとwritew_ltについても同じことが言えます。"
    },
    {
      "indent": 3,
      "text": "The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.",
      "ja": "範囲はロックとして指定されています。NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、ロックと同じ状況で返されます。"
    },
    {
      "indent": 3,
      "text": "The clientid field of the owner MAY be set to any value by the client and MUST be ignored by the server. The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.",
      "ja": "所有者のClientIDフィールドは、クライアントによって任意の値に設定され、サーバーによって無視される必要があります。サーバーがClientIDフィールドを無視する必要があるのは、サーバーが複合要求のシーケンス操作からセッションIDからクライアントIDを導出する必要があることです。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルではない場合、エラーがクライアントに返されます。現在のファイルハンドルがNF4DIR型のオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべての場合では、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.11.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.11.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results.",
      "ja": "サーバーが競合するロックの正確なオフセットと長さを判別できない場合は、引数に指定された同じオフセットと長さを拒否された結果に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "LOCKT uses a lock_owner4 rather a stateid4, as is used in LOCK to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid might not be available.",
      "ja": "LOCKTは、所有者を識別するためにロックで使用されるように、lock_owner4をむしろStateID4を使用します。これは、クライアントがロックの存在をテストするためにファイルを開く必要がないため、StareIDが利用できない可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 18.10.4, some servers may return NFS4ERR_LOCK_RANGE to certain (otherwise non-conflicting) LOCK operations that overlap ranges already granted to the current lock-owner.",
      "ja": "18.10.4項で述べたように、一部のサーバーはNFS4ERR_LOCK_RANGEを特定のロック所有者にすでに付与されている範囲に重複する特定の（そうでない場合は矛盾する）ロック操作にNFS4ERR_LOCK_RANGを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "The LOCKT operation's test for conflicting locks SHOULD exclude locks for the current lock-owner, and thus should return NFS4_OK in such cases. Note that this means that a server might return NFS4_OK to a LOCKT request even though a LOCK operation for the same range and lock-owner would fail with NFS4ERR_LOCK_RANGE.",
      "ja": "競合するロックのためのロック操作のテストは、現在のロック所有者のロックを除外する必要があります。したがって、このような場合にNFS4_OKを返す必要があります。これは、同じ範囲とロック所有者のロック操作がNFS4ERR_LOCK_RANGEで失敗した場合でも、サーバーがLOCKT要求にNFS4_OKを返す可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKT requests will similarly be handled locally.",
      "ja": "クライアントがOpen_Delegate_Writeの委任を保持すると、ロック要求をローカルに処理するために選択できます（18.10.4項を参照）。そのような場合、ロック要求は同様にローカルに処理されます。"
    },
    {
      "indent": 0,
      "text": "18.12. Operation 14: LOCKU - Unlock File",
      "section_title": true,
      "ja": "18.12. 操作14：ロック - ファイルのロックを解除します"
    },
    {
      "indent": 0,
      "text": "18.12.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.12.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct LOCKU4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        stateid4        lock_stateid;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.12.2. RESULTS",
      "section_title": true,
      "ja": "18.12.2. 結果"
    },
    {
      "indent": 3,
      "text": "union LOCKU4res switch (nfsstat4 status) {\n case   NFS4_OK:\n         stateid4       lock_stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.12.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.12.3. description"
    },
    {
      "indent": 3,
      "text": "The LOCKU operation unlocks the byte-range lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.",
      "ja": "ロック操作は、パラメータで指定されたバイトレンジロックをロック解除します。クライアントは、nfs_lock_type4列挙型で有効な任意の値にLockTypeフィールドを設定し、サーバはLockTypeの有効値を受け入れる必要があります。LockTypeの有効な値は、ロック操作の成功または失敗に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.",
      "ja": "範囲はロックとして指定されています。NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、ロックと同じ状況で返されます。"
    },
    {
      "indent": 3,
      "text": "The seqid parameter MAY be any value and the server MUST ignore it.",
      "ja": "seqidパラメーターは任意の値であり、サーバーはそれを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルではない場合、エラーがクライアントに返されます。現在のファイルハンドルがNF4DIR型のオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべての場合では、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that sent a LOCK operation also be the one to send LOCKU on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send LOCKU.",
      "ja": "サーバーは、プリンシパル、セキュリティフレーバー、および該当する場合、GSSメカニズム、ロック操作を送信した組み合わせも、ファイルにロックを送信するためのものである必要があります。これは、プリンシパルの認証情報が使用できなくなった場合は不可能かもしれません。サーバーは、マシンの資格情報またはSSVの信任状（セクション18.35を参照）を使用してロックを送信することができます。"
    },
    {
      "indent": 0,
      "text": "18.12.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.12.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the area to be unlocked does not correspond exactly to a lock actually held by the lock-owner, the server may return the error NFS4ERR_LOCK_RANGE. This includes the case in which the area is not locked, where the area is a sub-range of the area locked, where it overlaps the area locked without matching exactly, or the area specified includes multiple locks held by the lock-owner. In all of these cases, allowed by POSIX locking [21] semantics, a client receiving this error should, if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK operations for the sub-ranges not being unlocked.",
      "ja": "ロック解除される領域がロック所有者によって実際に保持されているロックに正確に対応しない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これには、エリアがロックされていない場合が含まれます。ここで、領域はロックされた領域のサブレンジです。そこでは、正確に一致することなくロックされた領域とロックされた領域にロックオーナーが保持している複数のロックが含まれます。POSIX LOCKING [21]セマンティクスで許可されているすべての場合において、このエラーを受信したクライアントは、そのような操作のサポートが望まれる場合、それが実際に保持されたロックに対応するロックを使用した操作をシミュレートし、その後にロック操作が続くべきです。サブレンジはロック解除されていません。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKU operations will similarly be handled locally.",
      "ja": "クライアントがOpen_Delegate_Writeの委任を保持すると、ロック要求をローカルに処理するために選択できます（18.10.4項を参照）。そのような場合、ロック操作は同様にローカルに処理されます。"
    },
    {
      "indent": 0,
      "text": "18.13. Operation 15: LOOKUP - Lookup Filename",
      "section_title": true,
      "ja": "18.13. 操作15：ルックアップ - ルックアップファイル名"
    },
    {
      "indent": 0,
      "text": "18.13.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.13.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct LOOKUP4args {\n        /* CURRENT_FH: directory */\n        component4      objname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.13.2. RESULTS",
      "section_title": true,
      "ja": "18.13.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOOKUP4res {\n        /* New CURRENT_FH: object */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.13.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.13.3. description"
    },
    {
      "indent": 3,
      "text": "The LOOKUP operation looks up or finds a file system object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists, the current filehandle is replaced with the component's filehandle.",
      "ja": "ルックアップ操作は、現在のファイルハンドルで指定されたディレクトリを使用してファイルシステムオブジェクトを検索または見つけます。ルックアップコンポーネントを評価し、オブジェクトが存在する場合は、現在のファイルハンドルがコンポーネントのFileHandleに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "If the component cannot be evaluated either because it does not exist or because the client does not have permission to evaluate the component, then an error will be returned and the current filehandle will be unchanged.",
      "ja": "コンポーネントを存在しないため、またはクライアントにコンポーネントを評価する権限がないためにコンポーネントを評価できない場合は、エラーが返され、現在のファイルハンドルが変更されません。"
    },
    {
      "indent": 3,
      "text": "If the component is a zero-length string or if any component does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "コンポーネントが長さゼロの文字列である場合、または任意のコンポーネントがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.13.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.13.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client wants to achieve the effect of a multi-component look up, it may construct a COMPOUND request such as (and obtain each filehandle):",
      "ja": "クライアントがマルチコンポーネントルックアップの効果を達成したい場合は、（および各FileHandleを入手する）などの複合要求を構築することができます。"
    },
    {
      "indent": 9,
      "text": "PUTFH (directory filehandle) LOOKUP \"pub\" GETFH LOOKUP \"foo\" GETFH LOOKUP \"bar\" GETFH",
      "ja": "PUTFH（ディレクトリファイルハンドル）ルックアップ \"PUB\" getfh lookup \"foo\" getfh lookup \"bar\" getfh"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, NFSv4.1 allows LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different, then the new directory is a server mountpoint. UNIX clients that detect a mountpoint crossing will need to mount the server's file system. This needs to be done to maintain the file object identity checking mechanisms common to UNIX clients.",
      "ja": "NFSV3、NFSV4.1とは異なり、ルックアップ要求をサーバー上のマウントポイントを渡すことができます。クライアントは、ディレクトリのFSID属性を検索したディレクトリのFSID属性と比較することによってマウントポイント交差点を検出できます。FSIDが異なる場合、新しいディレクトリはサーバーのマウントポイントです。マウントポイント交差点を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のファイルオブジェクトIDチェックメカニズムを維持するために行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers that limit NFS access to \"shared\" or \"exported\" file systems should provide a pseudo file system into which the exported file systems can be integrated, so that clients can browse the server's namespace. The clients view of a pseudo file system will be limited to paths that lead to exported file systems.",
      "ja": "NFSアクセスを「共有」または「エクスポートした」ファイルシステムに制限するサーバは、エクスポートされたファイルシステムを統合できる疑似ファイルシステムを提供する必要があり、クライアントはサーバの名前空間を閲覧することができます。疑似ファイルシステムのクライアントビューは、エクスポートされたファイルシステムにつながるパスに制限されます。"
    },
    {
      "indent": 3,
      "text": "Note: previous versions of the protocol assigned special semantics to the names \".\" and \"..\". NFSv4.1 assigns no special semantics to these names. The LOOKUPP operator must be used to look up a parent directory.",
      "ja": "注：プロトコルの以前のバージョンは、「名前」に特別な意味論を割り当てました。そして「..」。NFSV4.1はこれらの名前に特別な意味を割り当てます。Lookupp演算子を使用して親ディレクトリを検索する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the look up process.",
      "ja": "この操作はシンボリックリンクに従わないことに注意してください。クライアントは、ルックアッププロセス中に発生したシンボリックリンクによって変更されたファイル名を含むファイル名のすべての解析を担当します。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.",
      "ja": "指定された現在のファイルハンドルがディレクトリではなくシンボリックリンクである場合、エラーとしてエラーNFS4ERR_SYMLINKがエラーとして返されます。他のすべてのディレクトリ以外のファイルタイプの場合、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 0,
      "text": "18.14. Operation 16: LOOKUPP - Lookup Parent Directory",
      "section_title": true,
      "ja": "18.14. 操作16：Lookupp  -  Lookup Parent Directory"
    },
    {
      "indent": 0,
      "text": "18.14.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.14.1. 議論"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: object */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.14.2. RESULTS",
      "section_title": true,
      "ja": "18.14.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOOKUPP4res {\n        /* new CURRENT_FH: parent directory */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.14.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.14.3. description"
    },
    {
      "indent": 3,
      "text": "The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory, an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server's file tree.",
      "ja": "現在のファイルハンドルは、通常のディレクトリまたは名前付き属性ディレクトリを参照すると想定されています。Lookupp親ディレクトリのファイルハンドルを現在のファイルハンドルに割り当てます。親ディレクトリがない場合は、NFS4ERR_NOEENTエラーが返されなければなりません。したがって、現在のファイルハンドルがサーバーのファイルツリーのルートまたは上部にあるときに、NFS4ERR_NOENTはサーバーによって返されます。"
    },
    {
      "indent": 3,
      "text": "As is the case with LOOKUP, LOOKUPP will also cross mountpoints.",
      "ja": "ルックアップの場合と同様に、Lookuppもマウントポイントを渡ります。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.",
      "ja": "現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリではない場合、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 3,
      "text": "If the requester's security flavor does not match that configured for the parent directory, then the server SHOULD return NFS4ERR_WRONGSEC (a future minor revision of NFSv4 may upgrade this to MUST) in the LOOKUPP response. However, if the server does so, it MUST support the SECINFO_NO_NAME operation (Section 18.45), so that the client can gracefully determine the correct security flavor.",
      "ja": "リクエスタのセキュリティフレーバーが親ディレクトリに設定されているものと一致しない場合、サーバーはNFS4ERR_WRONGSECを返す必要があります（NFSV4の将来のマイナーリビジョンはこれを必要とするためにこれをアップグレードすることがあります）。ただし、サーバーがそうする場合は、SECINFO_NO_NAME操作（セクション18.45）をサポートしている必要があります。そのため、クライアントは正しいセキュリティフレーバーを正しく判別できます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is a named attribute directory that is associated with a file system object via OPENATTR (i.e., not a sub-directory of a named attribute directory), LOOKUPP SHOULD return the filehandle of the associated file system object.",
      "ja": "現在のファイルハンドルがOpenATTRを介して（すなわち、名前付き属性ディレクトリのサブディレクトリではない）という名前の属性ディレクトリである場合、Lookuppは関連するファイルシステムオブジェクトのファイルハンドルを返すべきです。"
    },
    {
      "indent": 0,
      "text": "18.14.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.14.4. 実装"
    },
    {
      "indent": 3,
      "text": "An issue to note is upward navigation from named attribute directories. The named attribute directories are essentially detached from the namespace, and this property should be safely represented in the client operating environment. LOOKUPP on a named attribute directory may return the filehandle of the associated file, and conveying this to applications might be unsafe as many applications expect the parent of an object to always be a directory. Therefore, the client may want to hide the parent of named attribute directories (represented as \"..\" in UNIX) or represent the named attribute directory as its own parent (as is typically done for the file system root directory in UNIX).",
      "ja": "メモの問題は、名前付き属性ディレクトリからの上向きナビゲーションです。名前付き属性ディレクトリは、名前空間から基本的に切り離されており、このプロパティはクライアントオペレーティング環境で安全に表現する必要があります。名前付き属性ディレクトリのLookuppは関連ファイルのファイルハンドルを返すことができ、これをアプリケーションに伝えることができます。多くのアプリケーションは、オブジェクトの親が常にディレクトリになることを期待しています。したがって、クライアントは、名前付きの属性ディレクトリの親を非表示にしたい（UNIXの \"..\"として表されます）、または名前付き属性ディレクトリをそれ自身の親として表します（UNIXのファイルシステムのルートディレクトリに対して行われるように）。"
    },
    {
      "indent": 0,
      "text": "18.15. Operation 17: NVERIFY - Verify Difference in Attributes",
      "section_title": true,
      "ja": "18.15. 操作17：nverify  - 属性の違いを検証します"
    },
    {
      "indent": 0,
      "text": "18.15.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.15.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct NVERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.15.2. RESULTS",
      "section_title": true,
      "ja": "18.15.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct NVERIFY4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.15.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.15.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some file system object. If all the attributes match, then the error NFS4ERR_SAME MUST be returned.",
      "ja": "この操作は、一部のファイルシステムオブジェクトで1つ以上の属性が変更された場合に実行される一連の操作をプレフィックスするために使用されます。すべての属性が一致する場合は、エラーNFS4ERR_SAMEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.15.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.15.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is useful as a cache validation operator. If the object to which the attributes belong has changed, then the following operations may obtain new data associated with that object, for instance, to check if a file has been changed and obtain new data if it has:",
      "ja": "この操作は、キャッシュ検証演算子として役立ちます。属性が属しているオブジェクトが変更された場合、次の操作はそのオブジェクトに関連付けられている新しいデータを取得して、ファイルが変更されているかどうかを確認して新しいデータが入手されているかどうかを確認できます。"
    },
    {
      "indent": 9,
      "text": "SEQUENCE PUTFH fh NVERIFY attrbits attrs READ 0 32767",
      "ja": "シーケンスputfh fh nverify attrbits attrs 022767"
    },
    {
      "indent": 3,
      "text": "Contrast this with NFSv3, which would first send a GETATTR in one request/reply round trip, and then if attributes indicated that the client's cache was stale, then send a READ in another request/reply round trip.",
      "ja": "NFSV3とは対照的に、最初に1つの要求/返信往復の往復でGetAttrを送信してから、属性がクライアントのキャッシュが古くなったことを示した場合は、読み取りを別のリクエスト/返信往復で送信します。"
    },
    {
      "indent": 3,
      "text": "In the case that a RECOMMENDED attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.",
      "ja": "nverify操作で推奨される属性が指定され、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.",
      "ja": "属性RDATTR_ERRORまたは任意のセット専用属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.16. Operation 18: OPEN - Open a Regular File",
      "section_title": true,
      "ja": "18.16. 操作18：開く - 通常のファイルを開く"
    },
    {
      "indent": 0,
      "text": "18.16.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.16.1. 議論"
    },
    {
      "indent": 3,
      "text": "/*\n * Various definitions for OPEN\n */\nenum createmode4 {\n        UNCHECKED4      = 0,\n        GUARDED4        = 1,\n        /* Deprecated in NFSv4.1. */\n        EXCLUSIVE4      = 2,\n        /*\n         * New to NFSv4.1. If session is persistent,\n         * GUARDED4 MUST be used.  Otherwise, use\n         * EXCLUSIVE4_1 instead of EXCLUSIVE4.\n         */\n        EXCLUSIVE4_1    = 3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct creatverfattr {\n         verifier4      cva_verf;\n         fattr4         cva_attrs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union createhow4 switch (createmode4 mode) {\n case UNCHECKED4:\n case GUARDED4:\n         fattr4         createattrs;\n case EXCLUSIVE4:\n         verifier4      createverf;\n case EXCLUSIVE4_1:\n         creatverfattr  ch_createboth;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum opentype4 {\n        OPEN4_NOCREATE  = 0,\n        OPEN4_CREATE    = 1\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union openflag4 switch (opentype4 opentype) {\n case OPEN4_CREATE:\n         createhow4     how;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Next definitions used for OPEN delegation */\nenum limit_by4 {\n        NFS_LIMIT_SIZE          = 1,\n        NFS_LIMIT_BLOCKS        = 2\n        /* others as needed */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct nfs_modified_limit4 {\n        uint32_t        num_blocks;\n        uint32_t        bytes_per_block;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_space_limit4 switch (limit_by4 limitby) {\n /* limit specified as file size */\n case NFS_LIMIT_SIZE:\n         uint64_t               filesize;\n /* limit specified by number of blocks */\n case NFS_LIMIT_BLOCKS:\n         nfs_modified_limit4    mod_blocks;\n} ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Share Access and Deny constants for open argument\n */\nconst OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* new flags for share_access field of OPEN4args */\nconst OPEN4_SHARE_ACCESS_WANT_DELEG_MASK        = 0xFF00;\nconst OPEN4_SHARE_ACCESS_WANT_NO_PREFERENCE     = 0x0000;\nconst OPEN4_SHARE_ACCESS_WANT_READ_DELEG        = 0x0100;\nconst OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG       = 0x0200;\nconst OPEN4_SHARE_ACCESS_WANT_ANY_DELEG         = 0x0300;\nconst OPEN4_SHARE_ACCESS_WANT_NO_DELEG          = 0x0400;\nconst OPEN4_SHARE_ACCESS_WANT_CANCEL            = 0x0500;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL = 0x10000;",
      "ja": "const open4_share_access_want_signal_deleg_when_resrc_avail = 0x10000;"
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED = 0x20000;",
      "ja": "const open4_share_access_want_push_deleg_when_uncontended = 0x20000;"
    },
    {
      "indent": 3,
      "text": "enum open_delegation_type4 {\n        OPEN_DELEGATE_NONE      = 0,\n        OPEN_DELEGATE_READ      = 1,\n        OPEN_DELEGATE_WRITE     = 2,\n        OPEN_DELEGATE_NONE_EXT  = 3 /* new to v4.1 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum open_claim_type4 { /* * Not a reclaim. */ CLAIM_NULL = 0,",
      "ja": "ENUM OPEN_CLAIM_TYPE4 {/ * * RESLAIMではありません。* /クレーム= 0、"
    },
    {
      "indent": 11,
      "text": "CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3,",
      "ja": "クレーム_previous = 1、クレームDelegate_cur = 2、クレームDelegate_Prev = 3、"
    },
    {
      "indent": 11,
      "text": "/*\n * Not a reclaim.\n *\n * Like CLAIM_NULL, but object identified\n * by the current filehandle.\n */\nCLAIM_FH                = 4, /* new to v4.1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*\n * Like CLAIM_DELEGATE_CUR, but object identified\n * by current filehandle.\n */\nCLAIM_DELEG_CUR_FH      = 5, /* new to v4.1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /*\n         * Like CLAIM_DELEGATE_PREV, but object identified\n         * by current filehandle.\n         */\n        CLAIM_DELEG_PREV_FH     = 6 /* new to v4.1 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct open_claim_delegate_cur4 {\n        stateid4        delegate_stateid;\n        component4      file;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union open_claim4 switch (open_claim_type4 claim) {\n /*\n  * No special rights to file.\n  * Ordinary OPEN of the specified file.\n  */\n case CLAIM_NULL:\n        /* CURRENT_FH: directory */\n        component4      file;\n /*\n  * Right to the file established by an\n  * open previous to server reboot.  File\n  * identified by filehandle obtained at\n  * that time rather than by name.\n  */\n case CLAIM_PREVIOUS:\n        /* CURRENT_FH: file being reclaimed */\n        open_delegation_type4   delegate_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Right to file based on a delegation\n * granted by the server.  File is\n * specified by name.\n */\ncase CLAIM_DELEGATE_CUR:\n       /* CURRENT_FH: directory */\n       open_claim_delegate_cur4        delegate_cur_info;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Right to file based on a delegation\n * granted to a previous boot instance\n * of the client.  File is specified by name.\n */\ncase CLAIM_DELEGATE_PREV:\n        /* CURRENT_FH: directory */\n       component4      file_delegate_prev;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_NULL.  No special rights\n * to file.  Ordinary OPEN of the\n * specified file by current filehandle.\n */\ncase CLAIM_FH: /* new to v4.1 */\n       /* CURRENT_FH: regular file to open */\n       void;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_DELEGATE_PREV.  Right to file based on a\n * delegation granted to a previous boot\n * instance of the client.  File is identified\n * by filehandle.\n */\ncase CLAIM_DELEG_PREV_FH: /* new to v4.1 */\n       /* CURRENT_FH: file being opened */\n       void;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_DELEGATE_CUR.  Right to file based on\n * a delegation granted by the server.\n * File is identified by filehandle.\n */\ncase CLAIM_DELEG_CUR_FH: /* new to v4.1 */\n        /* CURRENT_FH: file being opened */\n        stateid4       oc_delegate_stateid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};",
      "ja": ";;"
    },
    {
      "indent": 3,
      "text": "/*\n * OPEN: Open a file, potentially receiving an OPEN delegation\n */\nstruct OPEN4args {\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n        open_owner4     owner;\n        openflag4       openhow;\n        open_claim4     claim;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.16.2. RESULTS",
      "section_title": true,
      "ja": "18.16.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct open_read_delegation4 {\n stateid4 stateid;    /* Stateid for delegation*/\n bool     recall;     /* Pre-recalled flag for\n                         delegations obtained\n                         by reclaim (CLAIM_PREVIOUS) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " nfsace4 permissions; /* Defines users who don't\n                         need an ACCESS call to\n                         open for read */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct open_write_delegation4 {\n stateid4 stateid;      /* Stateid for delegation */\n bool     recall;       /* Pre-recalled flag for\n                           delegations obtained\n                           by reclaim\n                           (CLAIM_PREVIOUS) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "nfs_space_limit4\n          space_limit; /* Defines condition that\n                          the client must check to\n                          determine whether the\n                          file needs to be flushed\n                          to the server on close.  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " nfsace4   permissions; /* Defines users who don't\n                           need an ACCESS call as\n                           part of a delegated\n                           open. */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum why_no_delegation4 { /* new to v4.1 */\n        WND4_NOT_WANTED         = 0,\n        WND4_CONTENTION         = 1,\n        WND4_RESOURCE           = 2,\n        WND4_NOT_SUPP_FTYPE     = 3,\n        WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,\n        WND4_NOT_SUPP_UPGRADE   = 5,\n        WND4_NOT_SUPP_DOWNGRADE = 6,\n        WND4_CANCELLED          = 7,\n        WND4_IS_DIR             = 8\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union open_none_delegation4 /* new to v4.1 */\nswitch (why_no_delegation4 ond_why) {\n        case WND4_CONTENTION:\n                bool ond_server_will_push_deleg;\n        case WND4_RESOURCE:\n                bool ond_server_will_signal_avail;\n        default:\n                void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union open_delegation4\nswitch (open_delegation_type4 delegation_type) {\n        case OPEN_DELEGATE_NONE:\n                void;\n        case OPEN_DELEGATE_READ:\n                open_read_delegation4 read;\n        case OPEN_DELEGATE_WRITE:\n                open_write_delegation4 write;\n        case OPEN_DELEGATE_NONE_EXT: /* new to v4.1 */\n                open_none_delegation4 od_whynone;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Result flags\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Client must confirm open */\nconst OPEN4_RESULT_CONFIRM      = 0x00000002;\n/* Type of file locking behavior at the server */\nconst OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;\n/* Server will preserve file if removed while open */\nconst OPEN4_RESULT_PRESERVE_UNLINKED = 0x00000008;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Server may use CB_NOTIFY_LOCK on locks\n * derived from this open\n */\nconst OPEN4_RESULT_MAY_NOTIFY_LOCK = 0x00000020;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct OPEN4resok {\n stateid4       stateid;      /* Stateid for open */\n change_info4   cinfo;        /* Directory Change Info */\n uint32_t       rflags;       /* Result flags */\n bitmap4        attrset;      /* attribute set for create*/\n open_delegation4 delegation; /* Info on any open\n                                 delegation */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union OPEN4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* New CURRENT_FH: opened file */\n        OPEN4resok      resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.16.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.16.3. description"
    },
    {
      "indent": 3,
      "text": "The OPEN operation opens a regular file in a directory with the provided name or filehandle. OPEN can also create a file if a name is provided, and the client specifies it wants to create a file. Specification of whether or not a file is to be created, and the method of creation is via the openhow parameter. The openhow parameter consists of a switched union (data type opengflag4), which switches on the value of opentype (OPEN4_NOCREATE or OPEN4_CREATE). If OPEN4_CREATE is specified, this leads to another switched union (data type createhow4) that supports four cases of creation methods: UNCHECKED4, GUARDED4, EXCLUSIVE4, or EXCLUSIVE4_1. If opentype is OPEN4_CREATE, then the claim field of the claim field MUST be one of CLAIM_NULL, CLAIM_DELEGATE_CUR, or CLAIM_DELEGATE_PREV, because these claim methods include a component of a file name.",
      "ja": "オープン操作は、指定された名前またはファイルハンドルを含むディレクトリ内の通常のファイルを開きます。名前が指定されている場合はファイルを作成し、クライアントはファイルを作成したいと指定します。ファイルを作成するかどうかの指定、作成方法はOpenHowパラメータを介して行われます。Openhowパラメータは、OpenType（Open4_NocreateまたはOpen4_Create）の値を切り替えるスイッチ付きUNOUN（データ型OpenGFLAG4）で構成されています。Open4_Createが指定されている場合、これは別のスイッチングUNION（データ型CreateHow4）につながります。これは、unChecked4、Guarded4、Exclusive4、またはExclusive4_1の4つのケースをサポートする別のスイッチングUNION（CreateHow4）につながります。OpenTypeがOpen4_Createである場合、クレーム・フィールドのクレーム・フィールドは、特許請求の範囲のいずれかでなければなりません。これらのクレーム・メソッドはファイル名のコンポーネントを含むためです。"
    },
    {
      "indent": 3,
      "text": "Upon success (which might entail creation of a new file), the current filehandle is replaced by that of the created or existing object.",
      "ja": "成功すると、新しいファイルの作成が完了すると、現在のファイルハンドルは作成されたまたは既存のオブジェクトのそれに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 or EXCLUSIVE4_1 and the current filehandle is a named attribute directory, the server will return EINVAL.",
      "ja": "現在のFileHandleが名前付き属性ディレクトリの場合、開くと、名前付き属性ファイルを作成または開く。指定された属性の排他的作成はサポートされていません。CreateModeがexclusive4またはexclusive4_1で、現在のファイルハンドルが名前付き属性ディレクトリの場合、サーバーはEINVALを返します。"
    },
    {
      "indent": 3,
      "text": "UNCHECKED4 means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED4 create encounters an existing file, the attributes specified by createattrs are not used, except that when createattrs specifies the size attribute with a size of zero, the existing file is truncated.",
      "ja": "UNCECKED4は、その名前のファイルが存在しない場合はファイルを作成し、その名前の既存の通常のファイルが発生している場合はエラーではありません。このタイプの作成では、CreateEattrsはファイルの属性の初期セットを指定します。一連の属性には、通常のファイルに有効な任意の書き込み可能な属性が含まれます。UnCecked4の作成に既存のファイルが存在する場合、CreateAreattrsが指定した場合、CreateAttrsがゼロのサイズ属性を指定している場合、既存のファイルは切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, NFS4ERR_EXIST is returned. If the object does not exist, the request is performed as described for UNCHECKED4.",
      "ja": "Guarded4が指定されている場合、サーバーは作成を実行する前に、重複オブジェクトの存在を名前でチェックします。重複が存在する場合は、NFS4ERR_EXISTが返されます。オブジェクトが存在しない場合は、UNCECKED4について説明したように要求が実行されます。"
    },
    {
      "indent": 3,
      "text": "For the UNCHECKED4 and GUARDED4 cases, where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.",
      "ja": "操作が成功した場合、uncecked4およびguarded4のケースの場合、サーバーはクライアントに戻り、どの属性がオブジェクトに正常に設定されたかを示す属性マスクが表示されます。"
    },
    {
      "indent": 3,
      "text": "EXCLUSIVE4_1 and EXCLUSIVE4 specify that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned.",
      "ja": "exclusive4_1とexclusive4サーバーが排他的な作成セマンティクスに従うことを指定して、検証者を使用してターゲットの排他的作成を確実にします。サーバーは、重複したオブジェクトが名前で存在することを確認する必要があります。オブジェクトが存在しない場合、サーバーはそのオブジェクトを作成し、そのオブジェクトとともに検証者を保存します。オブジェクトが存在し、保存された検証者がクライアント提供の検証者と一致する場合、サーバーは既存のオブジェクトを新しく作成されたオブジェクトとして使用します。保存された検証者が一致しない場合は、NFS4ERR_EXISTのエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If using EXCLUSIVE4, and if the server uses attributes to store the exclusive create verifier, the server will signify which attributes it used by setting the appropriate bits in the attribute mask that is returned in the results. Unlike UNCHECKED4, GUARDED4, and EXCLUSIVE4_1, EXCLUSIVE4 does not support the setting of attributes at file creation, and after a successful OPEN via EXCLUSIVE4, the client MUST send a SETATTR to set attributes to a known state.",
      "ja": "exclusive4を使用している場合、およびサーバーが属性を使用して排他的なCREATE VERIFIERを格納している場合、サーバーは結果に返される属性マスク内の適切なビットを設定して使用した属性を表します。UnCecked4、Guarded4、およびExclusive4_1とは異なり、exclusive4はファイルの作成時の属性の設定はサポートされておりません。exclusive4を介して正常に開いた後、クライアントは属性を既知の状態に設定するためにsetAttrを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, EXCLUSIVE4 has been deprecated in favor of EXCLUSIVE4_1. Unlike EXCLUSIVE4, attributes may be provided in the EXCLUSIVE4_1 case, but because the server may use attributes of the target object to store the verifier, the set of allowable attributes may be fewer than the set of attributes SETATTR allows. The allowable attributes for EXCLUSIVE4_1 are indicated in the suppattr_exclcreat (Section 5.8.1.14) attribute. If the client attempts to set in cva_attrs an attribute that is not in suppattr_exclcreat, the server MUST return NFS4ERR_INVAL. The response field, attrset, indicates both which attributes the server set from cva_attrs and which attributes the server used to store the verifier. As described in Section 18.16.4, the client can compare cva_attrs.attrmask with attrset to determine which attributes were used to store the verifier.",
      "ja": "NFSV4.1では、exclusive4はexclusive4_1を支持して非推奨です。exclusive4とは異なり、属性はexclusive4_1の場合に提供されてもよいが、サーバはターゲットオブジェクトの属性を使用して検証者を格納することができるので、許容属性のセットはSetAttrが許可する属性のセットより少ない場合があります。exclusive4_1の許容属性は、SUPATTR_EXCLCREAT（セクション5.8.1.14）属性に示されています。CVA_ATTRSでCVA_ATTRSで設定しようとすると、SUPPATTR_EXCLCREATにはない属性がNFS4ERR_INVALを返す必要があります。応答フィールドATTSETは、サーバをCVA_ATTRから設定し、サーバが検証者を保存するために使用される属性を属性にします。18.16.4項で説明されているように、クライアントはCVA_ATTRS.ATTRMASKをATTRSETと比較して、検証者を保存するために使用された属性を決定できます。"
    },
    {
      "indent": 3,
      "text": "With the addition of persistent sessions and pNFS, under some conditions EXCLUSIVE4 MUST NOT be used by the client or supported by the server. The following table summarizes the appropriate and mandated exclusive create methods for implementations of NFSv4.1:",
      "ja": "永続的セッションとPNFSの追加を使用すると、一部の条件下でexclusive4はクライアントによって使用されたり、サーバーによってサポートされてはいけません。次の表は、NFSV4.1の実装のための適切かつ義務的な排他的作成方法をまとめたものです。"
    },
    {
      "indent": 5,
      "text": "+=============+==========+==============+=======================+\n| Persistent  | Server   | Server       | Client Allowed        |\n| Reply Cache | Supports | REQUIRED     |                       |\n| Enabled     | pNFS     |              |                       |\n+=============+==========+==============+=======================+\n| no          | no       | EXCLUSIVE4_1 | EXCLUSIVE4_1 (SHOULD) |\n|             |          | and          | or EXCLUSIVE4 (SHOULD |\n|             |          | EXCLUSIVE4   | NOT)                  |\n+-------------+----------+--------------+-----------------------+\n| no          | yes      | EXCLUSIVE4_1 | EXCLUSIVE4_1          |\n+-------------+----------+--------------+-----------------------+\n| yes         | no       | GUARDED4     | GUARDED4              |\n+-------------+----------+--------------+-----------------------+\n| yes         | yes      | GUARDED4     | GUARDED4              |\n+-------------+----------+--------------+-----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 18: Required Methods for Exclusive Create",
      "ja": "表18：排他的作成のための必要な方法"
    },
    {
      "indent": 3,
      "text": "If CREATE_SESSION4_FLAG_PERSIST is set in the results of CREATE_SESSION, the reply cache is persistent (see Section 18.36). If the EXCHGID4_FLAG_USE_PNFS_MDS flag is set in the results from EXCHANGE_ID, the server is a pNFS server (see Section 18.35). If the client attempts to use EXCLUSIVE4 on a persistent session, or a session derived from an EXCHGID4_FLAG_USE_PNFS_MDS client ID, the server MUST return NFS4ERR_INVAL.",
      "ja": "create_sessionの結果にcreate_session4_flag_persistが設定されている場合、応答キャッシュは永続的です（セクション18.36を参照）。Exchgid4_flag_use_pnfs_mdsフラグがExchange_IDの結果に設定されている場合、サーバーはPNFSサーバーです（セクション18.35を参照）。クライアントが永続セッションでexclusive4を使用しようとした場合、またはExchgid4_flag_use_pnfs_mdsクライアントIDから派生したセッションを試みると、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "With persistent sessions, exclusive create semantics are fully achievable via GUARDED4, and so EXCLUSIVE4 or EXCLUSIVE4_1 MUST NOT be used. When pNFS is being used, the layout_hint attribute might not be supported after the file is created. Only the EXCLUSIVE4_1 and GUARDED methods of exclusive file creation allow the atomic setting of attributes.",
      "ja": "永続的なセッションを使用すると、排他的なセマンティクスはGuarded4を介して完全に達成可能で、排他的4またはexclusive4_1を使用してはいけません。PNFSが使用されている場合は、ファイルが作成された後にLAYOUT_HINT属性がサポートされていない可能性があります。排他的なファイル作成の排他的4_1と保護されたメソッドのみが属性のアトミック設定を可能にします。"
    },
    {
      "indent": 3,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバーはCINFOのchange_info4情報を返します。change_info4データ型のアトミックフィールドを使用すると、サーバーはリンク作成に対して前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is OPEN4_SHARE_DENY_NONE. In the case that there is an existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For additional discussion of SHARE semantics, see Section 9.7.",
      "ja": "オープン操作は、開いている引数のshare_accessおよびshare_denyフィールドを使用して、Windows共有予約機能を提供します。クライアントは、必要なSHARE_ACCESSおよびSHARE_DENYモードを開く時を指定します。共有（すなわちUNIX）を直接サポートしていないクライアントの場合、期待される拒否値はopen4_share_deny_noneです。Open要求と競合する既存の共有予約がある場合、サーバーはエラーNFS4ERR_SHARE_DENEDを返します。シェアセマンティクスの詳細については、9.7節を参照してください。"
    },
    {
      "indent": 3,
      "text": "For each OPEN, the client provides a value for the owner field of the OPEN argument. The owner field is of data type open_owner4, and contains a field called clientid and a field called owner. The client can set the clientid field to any value and the server MUST ignore it. Instead, the server MUST derive the client ID from the session ID of the SEQUENCE operation of the COMPOUND request.",
      "ja": "オープンごとに、クライアントはOpen引数の所有者フィールドの値を提供します。所有者フィールドはデータ型Open_OWNER4のものであり、ClientIDと呼ばれるフィールドと所有者と呼ばれるフィールドを含みます。クライアントはClientIDフィールドを任意の値に設定でき、サーバーはそれを無視する必要があります。代わりに、サーバーは複合要求のシーケンス操作のセッションIDからクライアントIDを導出する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"seqid\" field of the request is not used in NFSv4.1, but it MAY be any value and the server MUST ignore it.",
      "ja": "リクエストの「seqid」フィールドはNFSv4.1では使用されませんが、任意の値である可能性があり、サーバーはそれを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.",
      "ja": "クライアントがサーバー障害からの状態を回復している場合、Open引数のクレームフィールドは、要求が以前に保持されている状態の再利用を目的としていることを意味します。"
    },
    {
      "indent": 3,
      "text": "The \"claim\" field of the OPEN argument is used to specify the file to be opened and the state information that the client claims to possess. There are seven claim types as follows:",
      "ja": "開いている引数の「クレーム」フィールドは、開かれるファイルと、クライアントが所有していると主張する状態情報を指定するために使用されます。次のようなクレームタイプが7つあります。"
    },
    {
      "indent": 3,
      "text": "+======================+============================================+\n| open type            | description                                |\n+======================+============================================+\n| CLAIM_NULL, CLAIM_FH | For the client, this is a new OPEN         |\n|                      | request and there is no previous state     |\n|                      | associated with the file for the           |\n|                      | client.  With CLAIM_NULL, the file is      |\n|                      | identified by the current filehandle       |\n|                      | and the specified component name.          |\n|                      | With CLAIM_FH (new to NFSv4.1), the        |\n|                      | file is identified by just the current     |\n|                      | filehandle.                                |\n+----------------------+--------------------------------------------+\n| CLAIM_PREVIOUS       | The client is claiming basic OPEN          |\n|                      | state for a file that was held             |\n|                      | previous to a server restart.              |\n|                      | Generally used when a server is            |\n|                      | returning persistent filehandles; the      |\n|                      | client may not have the file name to       |\n|                      | reclaim the OPEN.                          |\n+----------------------+--------------------------------------------+\n| CLAIM_DELEGATE_CUR,  | The client is claiming a delegation        |\n| CLAIM_DELEG_CUR_FH   | for OPEN as granted by the server.         |\n|                      | Generally, this is done as part of         |\n|                      | recalling a delegation.  With              |\n|                      | CLAIM_DELEGATE_CUR, the file is            |\n|                      | identified by the current filehandle       |\n|                      | and the specified component name.          |\n|                      | With CLAIM_DELEG_CUR_FH (new to            |\n|                      | NFSv4.1), the file is identified by        |\n|                      | just the current filehandle.               |\n+----------------------+--------------------------------------------+\n| CLAIM_DELEGATE_PREV, | The client is claiming a delegation        |\n| CLAIM_DELEG_PREV_FH  | granted to a previous client instance;     |\n|                      | used after the client restarts.  The       |\n|                      | server MAY support CLAIM_DELEGATE_PREV     |\n|                      | and/or CLAIM_DELEG_PREV_FH (new to         |\n|                      | NFSv4.1).  If it does support either       |\n|                      | claim type, CREATE_SESSION MUST NOT        |\n|                      | remove the client's delegation state,      |\n|                      | and the server MUST support the            |\n|                      | DELEGPURGE operation.                      |\n+----------------------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 19",
      "ja": "表19."
    },
    {
      "indent": 3,
      "text": "For OPEN requests that reach the server during the grace period, the server returns an error of NFS4ERR_GRACE. The following claim types are exceptions:",
      "ja": "猶予期間中にサーバーに到達するオープン要求の場合、サーバーはNFS4ERR_GRACEのエラーを返します。次のクレームタイプは例外です。"
    },
    {
      "indent": 3,
      "text": "* OPEN requests specifying the claim type CLAIM_PREVIOUS are devoted to reclaiming opens after a server restart and are typically only valid during the grace period.",
      "ja": "* クレームタイプを指定するオープンリクエストは、サーバーの再起動後に再生開始され、通常は猶予期間中にのみ有効です。"
    },
    {
      "indent": 3,
      "text": "* OPEN requests specifying the claim types CLAIM_DELEGATE_CUR and CLAIM_DELEG_CUR_FH are valid both during and after the grace period. Since the granting of the delegation that they are subordinate to assures that there is no conflict with locks to be reclaimed by other clients, the server need not return NFS4ERR_GRACE when these are received during the grace period.",
      "ja": "* クレームタイプを指定するオープンリクエストASEREGATE_CURおよびクレーム_DELEG_CUR_FHは、猶予期間の間およびその後に有効です。他のクライアントによって再生されるロックとの競合がないことを保証するために従属しているという委任の付与以来、猶予期間中にサーバーはNFS4ERR_GRACEを返す必要はありません。"
    },
    {
      "indent": 3,
      "text": "For any OPEN request, the server may return an OPEN delegation, which allows further opens and closes to be handled locally on the client as described in Section 10.4. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.",
      "ja": "オープン要求の場合、サーバーはオープンな委任を返すことができます。これにより、セクション10.4で説明されているように、さらにオープンしてクライアントにローカルに処理されることができます。委任は決定するためにサーバー次第です。クライアントは、委任が特定のインスタンスで認められないか、委任が認められないと仮定しないでください。どちらの場合も常に準備されるべきです。部分的な例外は、委任タイプが主張されている再利用（クレーム）の場合です。この場合、委任は常に委任状に付与されますが、サーバーは委任構造に即時のリコールを指定できます。"
    },
    {
      "indent": 3,
      "text": "The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.",
      "ja": "成功したオープンによって返されたRFlagsは、サーバーがオープンファイルの処理方法を管理する情報を返すことができます。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_RESULT_CONFIRM is deprecated and MUST NOT be returned by an NFSv4.1 server.",
      "ja": "* Open4_Result_Confirmは推奨されていないため、NFSV4.1サーバーによって返されないでください。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server's byte-range locking behavior supports the complete set of POSIX locking techniques [21]. From this, the client can choose to manage byte-range locking state in a way to handle a mismatch of byte-range locking management.",
      "ja": "* Open4_Result_LockType_Posixは、サーバーのバイトレンジロック動作がPOSIXロック技術の完全なセットをサポートすることを示します[21]。このことから、クライアントはバイトレンジロック管理の不一致を処理する方法でバイトレンジロック状態を管理することを選択できます。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_RESULT_PRESERVE_UNLINKED indicates that the server will preserve the open file if the client (or any other client) removes the file as long as it is open. Furthermore, the server promises to preserve the file through the grace period after server restart, thereby giving the client the opportunity to reclaim its open.",
      "ja": "* Open4_Result_preserve_UnLinkedクライアント（または他のクライアント）が開いている限りファイルを削除した場合、サーバーがオープンファイルを保存することを示します。さらに、サーバーは、サーバーの再起動後の猶予期間を通じてファイルを保存することを約束し、それによってクライアントにそのオープンを再利用する機会を与えます。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_RESULT_MAY_NOTIFY_LOCK indicates that the server may attempt CB_NOTIFY_LOCK callbacks for locks on this file. This flag is a hint only, and may be safely ignored by the client.",
      "ja": "* Open4_Result_May_notify_lockこのファイルのロックのためにサーバーがCB_NOTIFY_LOCKコールバックを試みることがあることを示します。このフラグはヒントだけであり、クライアントによって安全に無視される可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 14.5 for further discussion.",
      "ja": "コンポーネントがゼロの場合、NFS4ERR_INVALが返されます。コンポーネントは、通常のUTF-8、文字サポート、および名前チェックの対象となります。さらなる議論については14.5項を参照してください。"
    },
    {
      "indent": 3,
      "text": "When an OPEN is done and the specified open-owner already has the resulting filehandle open, the result is to \"OR\" together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same open-owner. In this case, the stateid returned as an \"other\" field that matches that of the previous open while the \"seqid\" field is incremented to reflect the change status due to the new open.",
      "ja": "OPENが行われ、指定された開いているOwnerが既に作成されたファイルハンドルを開いている場合、結果は新しい共有と既存のステータスとともにステータスをまとめて \"または拒否されます。この場合、複数のオープンが完了していても、単一のクローズだけを実行する必要があります。このような開いている場合は、正常に新しいオープンを行うための共有予約の確認が正常に進み、同じオープンオーナーによって保持されている既存のオープンの場合は例外はありません。この場合、STATEIDは、新しい開いているため、「seqid」フィールドが増分されている間、前のオープンの「他の」フィールドとして返されます。"
    },
    {
      "indent": 3,
      "text": "If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.",
      "ja": "サーバーの基礎となるファイルシステムが読み取り専用モードでのみアクセス可能で、Open Requestがaccess_writeまたはaccess_bothを指定している場合、サーバーは読み取り専用ファイルシステムを示すためにNFS4ERR_ROFSを返します。"
    },
    {
      "indent": 3,
      "text": "As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server's file system. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs (UNCHECKED4 or GUARDED4) or cva_attrs (EXCLUSIVE4_1) is specified, and includes an owner, owner_group, or ACE that the principal in the RPC call's credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.",
      "ja": "作成操作と同様に、サーバーは、サーバーのファイルシステムによって必要な場合は、所有者、所有者ACE、GROUP、またはGROUP ACEを導出する必要があります。exclusive4 createModeを使用した開いている場合、そのようなオープンコールにCreateAttrsフィールドが含まれていないため、サーバーは選択肢がありません。逆に、CreateAttrs（UnChecked4またはGuarded4）またはCVA_ATTRS（exclusive4_1）が指定されており、RPC呼び出しの資格情報のプリンシパルがファイルを作成する権限がない場合は、サーバーはNFS4ERR_PERMを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "In the case of an OPEN that specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is and are not removed.",
      "ja": "ゼロのサイズ（たとえば、切り捨て）とファイルが指定されたオープンの場合、名前付き属性はそのまま残されずに削除されません。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 gives more precise control to clients over acquisition of delegations via the following new flags for the share_access field of OPEN4args:",
      "ja": "NFSV4.1は、Open4ARGSのSHARE_ACCESSフィールドのための次の新しいフラグを介して、委任を介して委任を求めるクライアントにより正確な制御を提供します。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "open4_share_access_want_read_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "open4_share_access_want_write_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "open4_share_access_want_any_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG",
      "ja": "open4_share_access_want_no_deleg"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "open4_share_access_want_cancel."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL",
      "ja": "open4_share_access_want_signal_deleg_when_resrc_avail."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED",
      "ja": "open4_share_access_want_push_deleg_uncontended"
    },
    {
      "indent": 3,
      "text": "If (share_access & OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) is not zero, then the client will have specified one and only one of:",
      "ja": "（SHARE_ACCESS＆OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）がゼロでない場合、クライアントは次のいずれかを指定しています。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "open4_share_access_want_read_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "open4_share_access_want_write_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "open4_share_access_want_any_deleg."
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG",
      "ja": "open4_share_access_want_no_deleg"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "open4_share_access_want_cancel."
    },
    {
      "indent": 3,
      "text": "Otherwise, the client is neither indicating a desire nor a non-desire for a delegation, and the server MAY or MAY not return a delegation in the OPEN response.",
      "ja": "さもなければ、クライアントは、委任を示すことも、委任に対する非望みを示すものでもなく、サーバはオープンレスポンスで委任を返すこともできない可能性がある。"
    },
    {
      "indent": 3,
      "text": "If the server supports the new _WANT_ flags and the client sends one or more of the new flags, then in the event the server does not return a delegation, it MUST return a delegation type of OPEN_DELEGATE_NONE_EXT. The field ond_why in the reply indicates why no delegation was returned and will be one of:",
      "ja": "サーバーが新しい_want_flagsをサポートし、クライアントが1つ以上の新しいフラグを送信した場合、サーバーが委任を返さない場合は、委任タイプのOpen_Delegate_none_extを返す必要があります。返信のフィールドond_whyは、委任が返されなかった理由を示し、次のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_WANTED The client specified OPEN4_SHARE_ACCESS_WANT_NO_DELEG.",
      "ja": "WND4_NOT_WANTEDクライアントが指定されたOpen4_Share_access_want_no_delegを指定しました。"
    },
    {
      "indent": 3,
      "text": "WND4_CONTENTION There is a conflicting delegation or open on the file.",
      "ja": "WND4_Contention矛盾する委任またはファイルにオープンします。"
    },
    {
      "indent": 3,
      "text": "WND4_RESOURCE Resource limitations prevent the server from granting a delegation.",
      "ja": "WND4_Resourceリソースの制限サーバーが委任を許可しないようにします。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_FTYPE The server does not support delegations on this file type.",
      "ja": "WND4_NOT_SUPP_FTYPEサーバーはこのファイルタイプの委任をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_WRITE_DELEG_NOT_SUPP_FTYPE The server does not support OPEN_DELEGATE_WRITE delegations on this file type.",
      "ja": "WND4_WRITE_DELEG_NOT_SUPP_FTYPEサーバーは、このファイルタイプのOpen_Delegate_Writeの委任をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_UPGRADE The server does not support atomic upgrade of an OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation.",
      "ja": "WND4_NOT_SUPP_UPGRADEサーバは、Open_Delegate_read委任のアトミックアップグレードをOpen_Delegate_Write委任をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_DOWNGRADE The server does not support atomic downgrade of an OPEN_DELEGATE_WRITE delegation to an OPEN_DELEGATE_READ delegation.",
      "ja": "WND4_NOT_SUPP_DOWNGRADE SERVERは、OPEN_DELEGATE_READ委任へのOPEN_DELEGATE_WRITE委任のアトミックダウングレードをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_CANCELED The client specified OPEN4_SHARE_ACCESS_WANT_CANCEL and now any \"want\" for this file object is cancelled.",
      "ja": "WND4_CANCELクライアントが指定されたOpen4_Share_access_want_Cancelを指定し、このファイルオブジェクトの「希望」がキャンセルされました。"
    },
    {
      "indent": 3,
      "text": "WND4_IS_DIR The specified file object is a directory, and the operation is OPEN or WANT_DELEGATION, which do not support delegations on directories.",
      "ja": "WND4_IS_DIR指定されたファイルオブジェクトはディレクトリであり、操作はオープンまたはwant_delegationです。これはディレクトリ上の委任をサポートしません。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG, OPEN_SHARE_ACCESS_WANT_WRITE_DELEG, or OPEN_SHARE_ACCESS_WANT_ANY_DELEG mean, respectively, the client wants an OPEN_DELEGATE_READ, OPEN_DELEGATE_WRITE, or any delegation regardless which of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH is set. If the client has an OPEN_DELEGATE_READ delegation on a file and requests an OPEN_DELEGATE_WRITE delegation, then the client is requesting atomic upgrade of its OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation. If the client has an OPEN_DELEGATE_WRITE delegation on a file and requests an OPEN_DELEGATE_READ delegation, then the client is requesting atomic downgrade to an OPEN_DELEGATE_READ delegation. A server MAY support atomic upgrade or downgrade. If it does, then the returned delegation_type of OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE that is different from the delegation type the client currently has, indicates successful upgrade or downgrade. If the server does not support atomic delegation upgrade or downgrade, then ond_why will be set to WND4_NOT_SUPP_UPGRADE or WND4_NOT_SUPP_DOWNGRADE.",
      "ja": "open4_share_access_want_read_deleg、open_share_access_want_write_deleg、またはopen_share_access_want_any_delegなお、クライアントは、Open4_Share_Access_Read、Open4_Share_Access_Write、Open4_Share_access_bothが設定されている場合に関係なく、open_delegate_read、open_delegate_write、または任意の委任を望みます。クライアントがファイル上にOpen_Delegate_readの委任を持ち、Open_Delegate_Writeの委任を要求している場合、クライアントはそのOpen_Delegate_Read委任をOpen_Delegate_Write委任にアトミックアップグレードしています。クライアントがファイル上にOpen_Delegate_Writeの委任を持ち、Open_Delegate_readの委任を要求している場合、クライアントはAtomic DowngradeをOpen_Delegate_read委任に要求しています。サーバーはアトミックアップグレードまたはダウングレードをサポートできます。そうであれば、クライアントが現在持っている委任タイプとは異なるOpen_Delegate_readまたはOpen_Delegate_Writeの返されたdelegation_typeは、アップグレードまたはダウングレードが成功したことを示します。サーバーがアトミック委任アップグレードまたはダウングレードをサポートしていない場合は、ond_not_supp_uppradeまたはWND4_NOT_SUPP_DOWNGRADEに設定されます。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG means that the client wants no delegation.",
      "ja": "open4_share_access_want_no_delegは、クライアントが委任を望んでいないことを意味します。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL means that the client wants no delegation and wants to cancel any previously registered \"want\" for a delegation.",
      "ja": "open4_share_access_want_cancelは、クライアントが委任がなく、以前に登録された「希望」を委任でキャンセルしたいことを意味します。"
    },
    {
      "indent": 3,
      "text": "The client may set one or both of OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL and OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED. However, they will have no effect unless one of following is set:",
      "ja": "クライアントは、1またはOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAILとOPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDEDの両方を設定することもできます。ただし、以下のいずれかを設定しない限り、エフェクトはありません。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "* open4_share_access_want_read_deleg."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "* open4_share_access_want_write_deleg."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "* open4_share_access_want_any_deleg."
    },
    {
      "indent": 3,
      "text": "If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL, then it wishes to register a \"want\" for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to insufficient resources, the server MAY later inform the client, via the CB_RECALLABLE_OBJ_AVAIL operation, that the resource limitation condition has eased. The server will tell the client that it intends to send a future CB_RECALLABLE_OBJ_AVAIL operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_RESOURCE, and ond_server_will_signal_avail set to TRUE. If ond_server_will_signal_avail is set to TRUE, the server MUST later send a CB_RECALLABLE_OBJ_AVAIL operation.",
      "ja": "クライアントがOpen4_share_access_want_signal_deleg_resrc_availを指定した場合、オープン結果に委任が含まれていない場合に、委任に対して「欲求」を登録したいと思う。もしそうなら、サーバが不十分なリソースのために委任を拒否すると、サーバは後でCB_RECALLABLE_OBJ_AVAIL操作を介してクライアントに通知することができ、リソース制限条件が緩和されたこと。サーバーは、結果にdelegation_typeをopen_delegate_none_ext、ond_resourceに設定して、将来のCB_RECALLABLE_OBJ_AVAILオペレーションを送信することをクライアントに指示します。ond_server_will_signal_availをtrueに設定します。OND_SERVER_WILL_SIGNAL_AVAILがtrueに設定されている場合、サーバーは後でCB_RECALLABLE_OBJ_AVAIL操作を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_UNCONTENDED, then it wishes to register a \"want\" for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to contention, the server MAY later inform the client, via the CB_PUSH_DELEG operation, that the contention condition has eased. The server will tell the client that it intends to send a future CB_PUSH_DELEG operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_CONTENTION, and ond_server_will_push_deleg to TRUE. If ond_server_will_push_deleg is TRUE, the server MUST later send a CB_PUSH_DELEG operation.",
      "ja": "クライアントがOpen4_share_access_want_signal_deleg_signal_deleg_signal_deleg_sign_un_uncontementを指定した場合、オープン結果に委任が含まれていない場合、委任に対して「欲しい」を登録したいと考えています。もしそうであれば、サーバが競合のために委任を拒否すると、サーバは後でCB_PUSH_DELEG動作を介してクライアントに通知することができ、競合条件が緩和された。サーバーは、結果のdelegation_typeをopen_delegate_none_ext、ond_delegate_none_ext、ond_typh_will_push_delegをtrueに設定することによって、将来のCB_PUSH_DELEG操作を送信することをクライアントに指示します。OND_SERVER_WILL_PUSH_DELEGがtrueの場合、サーバーは後でCB_PUSH_DELEG操作を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client has previously registered a want for a delegation on a file, and then sends a request to register a want for a delegation on the same file, the server MUST return a new error: NFS4ERR_DELEG_ALREADY_WANTED. If the client wishes to register a different type of delegation want for the same file, it MUST cancel the existing delegation WANT.",
      "ja": "クライアントが以前に委任を登録した場合は、ファイル上の委任を登録してから、委任を登録する要求を同じファイルに送信する必要があります。サーバーは新しいエラーを返す必要があります.nfs4err_deleg_already_wanted。クライアントが同じファイルに対して異なるタイプの委任を登録したい場合は、既存の委任が必要になる必要があります。"
    },
    {
      "indent": 0,
      "text": "18.16.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.16.4. 実装"
    },
    {
      "indent": 3,
      "text": "In absence of a persistent session, the client invokes exclusive create by setting the how parameter to EXCLUSIVE4 or EXCLUSIVE4_1. In these cases, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.",
      "ja": "永続セッションがない場合、クライアントはexclusive4またはexclusive4_1へのパラメータを設定することによって排他的な作成を呼び出します。このような場合、クライアントは合理的に一意であると予想される検証者を提供します。クライアント識別子、おそらくクライアントネットワークアドレス、およびクライアントによって生成された一意の番号の組み合わせは、おそらくRPCトランザクション識別子が適切であり得る。"
    },
    {
      "indent": 3,
      "text": "If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object's metadata to store the verifier. The verifier MUST be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the server's reply cache for storage of the verifier. A nonpersistent reply cache does not survive a crash and the session and reply cache may be deleted after a network partition that exceeds the lease time, thus opening failure windows.",
      "ja": "オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、その検証者を安定したストレージに保存します。任意のファイル属性を記憶するためのメカニズムを提供しないファイルシステムの場合、サーバは検証者を格納するためにオブジェクトのメタデータの1つ以上の要素を使用することができる。要求の再送信時の誤った障害を防ぐために、検証者を安定したストレージに保存する必要があります。排他的な意味論はアプリケーションにとって重要であるため、排他的作成が実行されていると仮定されています。予期される使用法のため、排他的作成は、検証者の保存のためのサーバーの応答キャッシュだけだけ依存しません。非永続的な返信キャッシュはクラッシュが生き残らず、リース時間を超えるネットワークパーティションの後にセッションおよび応答キャッシュが削除され、したがって失敗ウィンドウを開くことができます。"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 server SHOULD NOT store the verifier in any of the file's RECOMMENDED or REQUIRED attributes. If it does, the server SHOULD use time_modify_set or time_access_set to store the verifier. The server SHOULD NOT store the verifier in the following attributes:",
      "ja": "NFSV4.1サーバーは、ファイルの推奨属性または必須の属性に検証者を保存しないでください。そうであれば、サーバーはtime_modify_setまたはtime_access_setを使用して検証者を保存する必要があります。サーバーは検証者を次の属性に保存しないでください。"
    },
    {
      "indent": 6,
      "text": "acl (it is desirable for access control to be established at creation),",
      "ja": "ACL（アクセス制御が作成時に確立されるのが望ましい）、"
    },
    {
      "indent": 6,
      "text": "dacl (ditto),",
      "ja": "DACL（Ditto）、"
    },
    {
      "indent": 6,
      "text": "mode (ditto),",
      "ja": "モード（同上）、"
    },
    {
      "indent": 6,
      "text": "owner (ditto),",
      "ja": "オーナー（同上）、"
    },
    {
      "indent": 6,
      "text": "owner_group (ditto),",
      "ja": "owner_group（同上）、"
    },
    {
      "indent": 6,
      "text": "retentevt_set (it may be desired to establish retention at creation)",
      "ja": "retentevt_set（作成時の保持を確立することが望ましいかもしれません）"
    },
    {
      "indent": 6,
      "text": "retention_hold (ditto),",
      "ja": "retention_hold（同上）、"
    },
    {
      "indent": 6,
      "text": "retention_set (ditto),",
      "ja": "保持_set（同上）"
    },
    {
      "indent": 6,
      "text": "sacl (it is desirable for auditing control to be established at creation),",
      "ja": "SACL（監査管理が創造時に確立されることが望ましい）"
    },
    {
      "indent": 6,
      "text": "size (on some servers, size may have a limited range of values),",
      "ja": "サイズ（一部のサーバーでは、サイズは限られた範囲の値を持つことがあります）、"
    },
    {
      "indent": 6,
      "text": "mode_set_masked (as with mode),",
      "ja": "mode_set_masked（モードと同様に）、"
    },
    {
      "indent": 9,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "time_creation (a meaningful file creation should be set when the file is created).",
      "ja": "time_creation（ファイルの作成時に意味のあるファイルの作成は設定されます）。"
    },
    {
      "indent": 3,
      "text": "Another alternative for the server is to use a named attribute to store the verifier.",
      "ja": "サーバーの別の代替案は、名前付き属性を使用して検証者を保存することです。"
    },
    {
      "indent": 3,
      "text": "Because the EXCLUSIVE4 create method does not specify initial attributes when processing an EXCLUSIVE4 create, the server",
      "ja": "exclusive4 createメソッドがexclusive4 createを処理するときに初期属性を指定しないため、サーバー"
    },
    {
      "indent": 3,
      "text": "* SHOULD set the owner of the file to that corresponding to the credential of request's RPC header.",
      "ja": "* リクエストのRPCヘッダーの資格情報に対応するファイルの所有者を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "* SHOULD NOT leave the file's access control to anyone but the owner of the file.",
      "ja": "* ファイルの所有者にファイルのアクセス制御を残してはいけません。"
    },
    {
      "indent": 3,
      "text": "If the server cannot support exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error NFS4ERR_NOTSUPP.",
      "ja": "サーバーが排他的なセマンティクスをサポートできない場合は、検証者を安定したストレージにコミットする必要があるため、エラーNFS4ERR_NOTSUPPでオープン要求に失敗するはずです。"
    },
    {
      "indent": 3,
      "text": "During an exclusive CREATE request, if the object already exists, the server reconstructs the object's verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.",
      "ja": "排他的なCREATE要求の間、オブジェクトが既に存在する場合、サーバーはオブジェクトの検証者を再構築し、それを要求の検証者と比較します。一致すると、サーバーは要求を成功として扱います。要求は、返信が失われた、およびサーバーの重複要求キャッシュメカニズムが検出されなかったことが正常に成功した要求が成功したことと推定されます。検証者が一致しない場合、要求はステータスNFS4ERR_EXISTで拒否されます。"
    },
    {
      "indent": 3,
      "text": "After the client has performed a successful exclusive create, the attrset response indicates which attributes were used to store the verifier. If EXCLUSIVE4 was used, the attributes set in attrset were used for the verifier. If EXCLUSIVE4_1 was used, the client determines the attributes used for the verifier by comparing attrset with cva_attrs.attrmask; any bits set in the former but not the latter identify the attributes used to store the verifier. The client MUST immediately send a SETATTR to set attributes used to store the verifier. Until it does so, the attributes used to store the verifier cannot be relied upon. The subsequent SETATTR MUST NOT occur in the same COMPOUND request as the OPEN.",
      "ja": "クライアントが排他的作成を成功させた後、AttrSet Responseは検証者を保存するためにどの属性を使用したかを示します。exclusive4が使用されている場合、ATTRSETに設定されている属性が検証者に使用されました。exclusive4_1が使用されている場合、クライアントは、ATTRSETをCVA_ATTRS.ATTRMASKと比較して、検証者に使用される属性を決定します。前者に設定されていますが、後者は検証者の保管に使用される属性を識別しません。クライアントは、検証者を保存するために使用される属性を設定するためにすぐにsetAttrを送信する必要があります。そうするまでは、検証者を保存するために使用される属性は依頼することはできません。後続のSETATTRは、Openと同じ複合要求には発生してはいけません。"
    },
    {
      "indent": 3,
      "text": "Unless a persistent session is used, use of the GUARDED4 attribute does not provide exactly once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED4 to prevent against a sequence like create, write, create (retransmitted) from occurring.",
      "ja": "永続セッションが使用されていない限り、Guarded4属性の使用は一度だけセマンティクスを提供しません。特に、返信が失われ、サーバーが要求の再送信を検出しない場合は、作成が正常に実行されていても、NFS4ERR_EXISTで動作が失敗する可能性があります。クライアントは、アプリケーションが排他的作成を要求していないが、ファイルが開かれたときにファイルを切り捨てるように依頼した場合にこの動作を使用します。クライアントのタイムアウトが実行され、作成要求を再送信する場合、クライアントはGuarded4を使用して、作成、書き込み、作成（再送信）のようなシーケンスを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "For SHARE reservations, the value of the expression (share_access & ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) MUST be one of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If not, the server MUST return NFS4ERR_INVAL. The value of share_deny MUST be one of OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If not, the server MUST return NFS4ERR_INVAL.",
      "ja": "共有予約の場合、式の値（SHARE_ACCESS＆〜open4_share_access_want_deleg_mask）は、open4_share_access_read、open4_share_access_write、またはopen4_share_access_bothのいずれかでなければなりません。そうでない場合、サーバーはNFS4ERR_INVALを返す必要があります。share_denyの値は、open4_share_deny_none、open4_share_deny_read、open4_share_deny_write、またはopen4_share_deny_bothのいずれかでなければなりません。そうでない場合、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Based on the share_access value (OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH), the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server's decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester's READ or WRITE operation is not authorized (depending on the share_access value), the server MUST return NFS4ERR_ACCESS.",
      "ja": "share_access値（Open4_Share_access_Read、Open4_Share_Access_both、Open4_Share_access_both）に基づいて、クライアントは要求者が指定された操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは一般に、現在のリクエスタ用のファイルにACLアクセスルールを適用した結果です。ただし、アクセス操作と同様に、アクセス権が変更される可能性があるため、クライアントはサーバーの決定を2回目に推測しようとしないでください。リクエスタの読み取りまたは書き込み操作が許可されていない場合（SHARE_ACCESS値によって）、サーバーはNFS4ERR_ACCESSを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that if the client ID was not created with the EXCHGID4_FLAG_BIND_PRINC_STATEID capability set in the reply to EXCHANGE_ID, then the server MUST NOT impose any requirement that READs and WRITEs sent for an open file have the same credentials as the OPEN itself, and the server is REQUIRED to perform access checking on the READs and WRITEs themselves. Otherwise, if the reply to EXCHANGE_ID did have EXCHGID4_FLAG_BIND_PRINC_STATEID set, then with one exception, the credentials used in the OPEN request MUST match those used in the READs and WRITEs, and the stateids in the READs and WRITEs MUST match, or be derived from the stateid from the reply to OPEN. The exception is if SP4_SSV or SP4_MACH_CRED state protection is used, and the spo_must_allow result of EXCHANGE_ID includes the READ and/or WRITE operations. In that case, the machine or SSV credential will be allowed to send READ and/or WRITE. See Section 18.35.",
      "ja": "Exchange_IDへの応答でExchgid4_flag_bind_princ_stateID機能を設定してクライアントIDが作成されなかった場合、サーバーはOpenファイルの読み書きが開いていても、Openそれ自体と同じ認証情報を持ち、サーバーは課されてはいけません。読み取りにアクセスして自分自身を書き込むためにアクセスするために必要です。それ以外の場合、Exchange_IDへの返信がExchgid4_flag_bind_princ_stateIDを設定した場合、1つの例外で、Open要求で使用されている信任状は読み書きで使用されているものと一致しなければならず、読み書きの州は一致するか、またはから派生する必要があります。応答から開くまでのStateID。例外は、SP4_SSVまたはSP4_MACH_CRED状態保護が使用されている場合、Exchange_IDのspo_must_allow結果には、読み取りおよび/または書き込み操作が含まれます。その場合、マシンまたはSSVの信任状は読み取りおよび/または書き込みを送信することが許可されます。18.35節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client, while if it is a directory the error NFS4ERR_ISDIR will be returned. If the component is neither of those but not an ordinary file, the error NFS4ERR_WRONG_TYPE is returned. If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.",
      "ja": "開くように提供されたコンポーネントがシンボリックリンクである場合、エラーNFS4ERR_SYMLINKはクライアントに返されますが、ディレクトリの場合はエラーNFS4ERR_ISDIRが返されます。コンポーネントが通常のファイルではないが、エラーNFS4ERR_WRONG_TYPEが返されません。現在のファイルハンドルがディレクトリではない場合、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 3,
      "text": "The use of the OPEN4_RESULT_PRESERVE_UNLINKED result flag allows a client to avoid the common implementation practice of renaming an open file to \".nfs<unique value>\" after it removes the file. After the server returns OPEN4_RESULT_PRESERVE_UNLINKED, if a client sends a REMOVE operation that would reduce the file's link count to zero, the server SHOULD report a value of zero for the numlinks attribute on the file.",
      "ja": "Open4_Result_preserve_Unlinked結果フラグを使用すると、クライアントがファイルを削除した後にオープンファイルを \".nfs <固有値>\"に名前を変更する一般的な実装方法を回避できます。サーバーがOpen4_Result_preserve_Unlinkedを返した後、クライアントがファイルのリンクカウントをゼロに縮小するための削除操作を送信した場合、サーバーはファイルのnumlinks属性に対してゼロの値を報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "If another client has a delegation of the file being opened that conflicts with open being done (sometimes depending on the share_access or share_deny value specified), the delegation(s) MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding. In the case of an OPEN_DELEGATE_WRITE delegation, any open by a different client will conflict, while for an OPEN_DELEGATE_READ delegation, only opens with one of the following characteristics will be considered conflicting:",
      "ja": "別のクライアントが開かれているファイルの委任が開かれている場合（share_accessまたはshare_deny値が指定されたshare_accessまたはshare_denyの値に依存して）、委任を呼び出す必要があり、そのような各委任が返されるまで操作を続行できません。取り消されました。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。Open_Delegate_Writeの委任の場合、異なるクライアントによって開かれた任意のオープンが競合し、Open_Delegate_readの委任では、次のいずれかの特性を競合すると見なされます。"
    },
    {
      "indent": 3,
      "text": "* The value of share_access includes the bit OPEN4_SHARE_ACCESS_WRITE.",
      "ja": "* share_accessの値には、bit open4_share_access_writeが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The value of share_deny specifies OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH.",
      "ja": "* share_denyの値はOpen4_Share_deny_ReadまたはOpen4_Share_deny_bothを指定します。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_CREATE is specified together with UNCHECKED4, the size attribute is specified as zero (for truncation), and an existing file is truncated.",
      "ja": "* Open4_Createは未チェック4と一緒に指定され、size属性はゼロ（切り捨て用）として指定され、既存のファイルが切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "Open4_Createが指定されていて、ファイルが存在しない場合、現在のファイルハンドルが別のクライアントがディレクトリ委任を保持するディレクトリを指定している場合、委任が通知を送信して状況を解決できるように、委任を呼び出す必要があります。また、委任が返されるか取り消されるまで、操作は進められません。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.",
      "ja": "open4_createが指定されていて、ファイルが存在しない場合、現在のFileHandleが1つ以上のディレクトリ委任が存在するディレクトリを指定した場合、それらの代理店がそのような通知を要求すると、この操作の結果としてNotify4_ad_Entryが生成されます。"
    },
    {
      "indent": 0,
      "text": "18.16.4.1. Warning to Client Implementors",
      "section_title": true,
      "ja": "18.16.4.1. クライアントの実装者への警告"
    },
    {
      "indent": 3,
      "text": "OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore, the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.",
      "ja": "Openは、クライアントが使用するファイルハンドルを生成するという点で検索に似ています。Lookupとは異なり、Openはファイルハンドルにサーバーの状態を作成します。通常の状況では、クライアントはこの状態を閉じるだけで解放できます。閉じる現在のファイルハンドルを使用して、どのファイルを閉じるかを決定します。したがって、クライアントは、同じ複合手順でGETFH操作ですべてのオープン操作に従わなければなりません。これにより、クライアントがクライアントに適切に使用できます。"
    },
    {
      "indent": 3,
      "text": "Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.",
      "ja": "他のクライアントが同じファイルへのアクセスを競合しようとしていない限り、サーバーが状態を無期限に維持できるため、ファイルのリースを待機するだけでは不十分です。"
    },
    {
      "indent": 3,
      "text": "See also Section 2.10.6.4.",
      "ja": "セクション2.10.6.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.17. Operation 19: OPENATTR - Open Named Attribute Directory",
      "section_title": true,
      "ja": "18.17. 操作19：OpenATTR  - 名前付き属性ディレクトリを開く"
    },
    {
      "indent": 0,
      "text": "18.17.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.17.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct OPENATTR4args {\n        /* CURRENT_FH: object */\n        bool    createdir;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.17.2. RESULTS",
      "section_title": true,
      "ja": "18.17.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct OPENATTR4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: named attribute\n         *                   directory\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.17.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.17.3. description"
    },
    {
      "indent": 3,
      "text": "The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will designate objects of type of NF4NAMEDATTR.",
      "ja": "OpenATTRの動作は、現在のFileHandleに関連付けられている名前付き属性ディレクトリのファイルハンドルを取得するために使用されます。openattrの結果は、nf4attrdir型のオブジェクトへのファイルハンドルになります。このファイルハンドルから、ReadDirおよびLookup操作を使用して、元のファイルシステムオブジェクトに関連付けられているさまざまな名前付き属性のファイルハンドルを入手できます。名前付き属性ディレクトリ内に返されるファイルハンドルは、NF4NamedAttrの型のオブジェクトを指定します。"
    },
    {
      "indent": 3,
      "text": "The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created and its filehandle becomes the current filehandle. On the other hand, if createdir has a value of TRUE and the named attribute directory already exists, no error results and the filehandle of the existing directory becomes the current filehandle. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.",
      "ja": "CreatedIR引数は、OpenATTR操作の結果として名前付き属性ディレクトリを作成する必要があるかどうかをクライアントにすることができます。一部のクライアントは、CreatedIrの場合はfalseの値を使用してOpenATTR操作を使用して、名前付き属性がオブジェクトに存在するかどうかを判断できます。存在しない場合は、NFS4ERR_NOENTが返されます。CreateDIRの値がtrueで、名前付き属性ディレクトリが存在しない場合は、作成され、そのファイルハンドルが現在のファイルハンドルになります。一方、CreateDIRがTRUEの値を持ち、名前付き属性ディレクトリが既に存在する場合は、エラー結果と既存のディレクトリのファイルハンドルが現在のファイルハンドルになりません。名前付き属性ディレクトリの作成は、サーバーがこのファッションで属性サポートという名前の名前付きを実装しており、この定義によってそうする必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates an object of type NF4NAMEDATTR (a named attribute) or NF4ATTRDIR (a named attribute directory), an error of NFS4ERR_WRONG_TYPE is returned to the client. Named attributes or a named attribute directory MUST NOT have their own named attributes.",
      "ja": "現在のファイルハンドルがNF4NamedAttr型（名前付き属性）またはNF4AttrDir型（名前付き属性ディレクトリ）のオブジェクトを指定すると、NFS4ERR_WRONG_TYPEのエラーがクライアントに返されます。名前付き属性または名前付き属性ディレクトリには、独自の名前付き属性を持たない必要があります。"
    },
    {
      "indent": 0,
      "text": "18.17.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.17.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.",
      "ja": "サーバーが現在のFileHandleの名前付き属性をサポートしていない場合は、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access",
      "section_title": true,
      "ja": "18.18. 操作21：OPEN_DOWNGRADE  - オープンファイルアクセスを減らす"
    },
    {
      "indent": 0,
      "text": "18.18.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.18.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4args {\n        /* CURRENT_FH: opened file */\n        stateid4        open_stateid;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.18.2. RESULTS",
      "section_title": true,
      "ja": "18.18.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4resok {\n        stateid4        open_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union OPEN_DOWNGRADE4res switch(nfsstat4 status) {\n case NFS4_OK:\n        OPEN_DOWNGRADE4resok    resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.18.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.18.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is used to adjust the access and deny states for a given open. This is necessary when a given open-owner opens the same file multiple times with different access and deny values. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.",
      "ja": "この操作は、特定のオープンのアクセスと拒否状態を調整するために使用されます。これは、指定されたオープンオーナーが異なるアクセスと拒否値で同じファイルを複数回開くときに必要です。この状況では、開くと、開いているSHARE_ACCESSとSHARE_DENYフラグを変更して、開いていないビットを削除することができます。"
    },
    {
      "indent": 3,
      "text": "Valid values for the expression (share_access & ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) are OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.",
      "ja": "式の有効な値（share_access＆〜open4_share_access_want_deleg_mask）は、open4_share_access_read、open4_share_access_both、またはopen4_share_access_bothです。クライアントが他の値を指定した場合、サーバーはNFS4ERR_INVALで返信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Valid values for the share_deny field are OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.",
      "ja": "share_denyフィールドの有効な値はopen4_share_deny_none、open4_share_deny_read、open4_share_deny_both、open4_share_deny_bothです。クライアントが他の値を指定した場合、サーバーはNFS4ERR_INVALで返信する必要があります。"
    },
    {
      "indent": 3,
      "text": "After checking for valid values of share_access and share_deny, the server replaces the current access and deny modes on the file with share_access and share_deny subject to the following constraints:",
      "ja": "SHARE_ACCESSとSHARE_DENYの有効な値を確認した後、サーバーは現在のアクセスとファイル上の拒否モードをSHARE_ACCESSとSHARE_DENYに対象としています。"
    },
    {
      "indent": 3,
      "text": "* The bits in share_access SHOULD equal the union of the share_access bits (not including OPEN4_SHARE_WANT_* bits) specified for some subset of the OPENs in effect for the current open-owner on the current file.",
      "ja": "* Share_accessのビットは、現在のファイルの現在のオープンオーナーに有効なOpenSのいくつかのサブセットに指定されているSHARE_ACCESSビット（Open4_Share_want_ *ビットを含まない）に等しくなります。"
    },
    {
      "indent": 3,
      "text": "* The bits in share_deny SHOULD equal the union of the share_deny bits specified for some subset of the OPENs in effect for the current open-owner on the current file.",
      "ja": "* share_denyのビットは、現在のファイルの現在のオープンオーナーに有効なオープンのいくつかのサブセットに指定されたShare_denyビットの共和国と等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the above constraints are not respected, the server SHOULD return the error NFS4ERR_INVAL. Since share_access and share_deny bits should be subsets of those already granted, short of a defect in the client or server implementation, it is not possible for the OPEN_DOWNGRADE request to be denied because of conflicting share reservations.",
      "ja": "上記の制約が尊重されない場合、サーバーはエラーNFS4ERR_INVALを返すはずです。share_accessとshare_denyのビットは、クライアントまたはサーバーの実装の欠陥の短いものの短いもののサブセットである必要があります。競合する共有予約のため、Open_Downgrade要求を拒否することはできません。"
    },
    {
      "indent": 3,
      "text": "The seqid argument is not used in NFSv4.1, MAY be any value, and MUST be ignored by the server.",
      "ja": "seqid引数はnfsv4.1では使用されません。任意の値でも、サーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.18.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.18.4. 実装"
    },
    {
      "indent": 3,
      "text": "An OPEN_DOWNGRADE operation may make OPEN_DELEGATE_READ delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.",
      "ja": "Open_Downgrade操作は、Open_Delegate_Readの委任を以前にそうでなかった場所に付与できます。保留中の委任が必要な場合、または後で状況に応答しても、サーバーはすぐに応答することを選択できます。"
    },
    {
      "indent": 0,
      "text": "18.19. Operation 22: PUTFH - Set Current Filehandle",
      "section_title": true,
      "ja": "18.19. 操作22：PUTFH  - 現在のファイルハンドルを設定します"
    },
    {
      "indent": 0,
      "text": "18.19.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.19.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct PUTFH4args {\n        nfs_fh4         object;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.19.2. RESULTS",
      "section_title": true,
      "ja": "18.19.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTFH4res {\n        /*\n         * If status is NFS4_OK,\n         *    new CURRENT_FH: argument to PUTFH\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.19.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.19.3. description"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle provided as an argument. It clears the current stateid.",
      "ja": "この操作は、現在のFileHandleを引数として提供されているFileHandleと置き換えます。現在のStateIDを消去します。"
    },
    {
      "indent": 3,
      "text": "If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.",
      "ja": "要求者が使用しているセキュリティメカニズムがこの操作に提供されているファイルハンドルの要件を満たしていない場合、サーバーはNFS4ERR_WRONGSECを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のStateIDの詳細については、16.2.3.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.19.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.19.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、同じ複合要求に続くファイルアクセス操作のコンテキストを設定するためのNFS要求で使用されます。"
    },
    {
      "indent": 0,
      "text": "18.20. Operation 23: PUTPUBFH - Set Public Filehandle",
      "section_title": true,
      "ja": "18.20. 操作23：PUTPUBFH  - パブリックファイルハンドルを設定します"
    },
    {
      "indent": 0,
      "text": "18.20.1. ARGUMENT",
      "section_title": true,
      "ja": "18.20.1. 引数"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.20.2. RESULT",
      "section_title": true,
      "ja": "18.20.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTPUBFH4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: public fh\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.20.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.20.3. description"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle that represents the public filehandle of the server's namespace. This filehandle may be different from the \"root\" filehandle that may be associated with some other directory on the server.",
      "ja": "この操作は、現在のファイルハンドルをサーバーの名前空間のパブリックファイルハンドルを表すファイルハンドルと置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けることができる「ルート」ファイルハンドルとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "PUTPUBFH also clears the current stateid.",
      "ja": "PUTPUBFHも現在のStateIDを消去します。"
    },
    {
      "indent": 3,
      "text": "The public filehandle represents the concepts embodied in RFC 2054 [49], RFC 2055 [50], and RFC 2224 [61]. The intent for NFSv4.1 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing WebNFS server compatibility with NFSv3.",
      "ja": "パブリックファイルハンドルは、RFC 2054 [49]、RFC 2055 [50]、およびRFC 2224 [61]に具現化されている概念を表します。NFSV4.1の意図は、Publ FileHandle（PutPubfh操作で表される）をNFSv3とWebNFSサーバーの互換性を提供する方法として使用されます。"
    },
    {
      "indent": 3,
      "text": "The public filehandle and the root filehandle (represented by the PUTROOTFH operation) SHOULD be equivalent. If the public and root filehandles are not equivalent, then the directory corresponding to the public filehandle MUST be a descendant of the directory corresponding to the root filehandle.",
      "ja": "パブリックファイルハンドルとルートファイルハンドル（PUTROOTFH操作で表される）は同等であるはずです。パブリックファイルハンドルとルートファイルハンドルが同等ではない場合、パブリックファイルハンドルに対応するディレクトリは、ルートファイルハンドルに対応するディレクトリの子孫でなければなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のStateIDの詳細については、16.2.3.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.20.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.20.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、同じ複合要求に続くファイルアクセス操作のコンテキストを設定するためのNFS要求で使用されます。"
    },
    {
      "indent": 3,
      "text": "With the NFSv3 public filehandle, the client is able to specify whether the pathname provided in the LOOKUP should be evaluated as either an absolute path relative to the server's root or relative to the public filehandle. RFC 2224 [61] contains further discussion of the functionality. With NFSv4.1, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute vs. relative are not allowed in NFSv4. Therefore, the client is responsible for constructing its request such that the use of either PUTROOTFH or PUTPUBFH signifies absolute or relative evaluation of an NFS URL, respectively.",
      "ja": "NFSv3パブリックファイルハンドルでは、クライアントは、ルックアップに指定されたパス名をサーバーのルートに対する絶対パスまたはパブリックファイルハンドルに対する相対パスとして評価する必要があるかどうかを指定できます。RFC 2224 [61]は機能性についてのさらなる議論を含む。NFSV4.1では、そのタイプの仕様はルックアップ操作で直接利用できません。その理由は、絶対値Vs.相対値を指定する必要があるコンポーネント区切り文字がNFSV4では許可されていません。したがって、クライアントは、PUTROOTFHまたはPUTPUBFHの使用がそれぞれNFS URLの絶対的または相対的な評価を意味するようにその要求を構築する責任があります。"
    },
    {
      "indent": 3,
      "text": "Note that there are warnings mentioned in RFC 2224 [61] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFSv4.1. It is likely, therefore, that because of server implementation details, an NFSv3 absolute public filehandle look up may behave differently than an NFSv4.1 absolute resolution.",
      "ja": "なお、RFC 2224に記載されている警告は、絶対評価の使用に関してRFC 2224で述べられており、その評価にはその評価がどの程度利用可能にされたかに関してその評価にある可能性があることに注意してください。これらの同じ警告はNFSV4.1に適用されます。したがって、サーバの実装の詳細により、NFSV3絶対パブリックファイルハンドルルックアップはNFSV4.1絶対解像度とは異なる動作をする可能性があります。"
    },
    {
      "indent": 3,
      "text": "There is a form of security negotiation as described in RFC 2755 [62] that uses the public filehandle and an overloading of the pathname. This method is not available with NFSv4.1 as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFSv3. Clients should therefore use the security negotiation mechanisms described in Section 2.6.",
      "ja": "パブリックファイルハンドルとパス名の過負荷を使用するRFC 2755 [62]に記載されているように、セキュリティネゴシエーションの一形態があります。このメソッドは、ファイルハンドルが特別な意味で過負荷になっていないため、NFSV4.1では使用できず、したがってNFSV3と同じフレームワークを提供しません。したがって、クライアントはセクション2.6に記載されているセキュリティネゴシエーションメカニズムを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.21. Operation 24: PUTROOTFH - Set Root Filehandle",
      "section_title": true,
      "ja": "18.21. 操作24：PUTROOTFH  - ルートファイルハンドルを設定します"
    },
    {
      "indent": 0,
      "text": "18.21.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.21.1. 議論"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.21.2. RESULTS",
      "section_title": true,
      "ja": "18.21.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTROOTFH4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: root fh\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.21.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.21.3. description"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle that represents the root of the server's namespace. From this filehandle, a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the \"public\" filehandle that may be associated with some other directory on the server.",
      "ja": "この操作は、現在のファイルハンドルをサーバーの名前空間のルートを表すファイルハンドルに置き換えます。このファイルハンドルから、ルックアップ操作はサーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けることができる「パブリック」ファイルハンドルとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "PUTROOTFH also clears the current stateid.",
      "ja": "Putrootfhは現在のStateIDもクリアされます。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のStateIDの詳細については、16.2.3.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.21.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.21.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、同じ複合要求に続くファイルアクセス操作のコンテキストを設定するためのNFS要求で使用されます。"
    },
    {
      "indent": 0,
      "text": "18.22. Operation 25: READ - Read from File",
      "section_title": true,
      "ja": "18.22. 操作25：ファイルから読み取る"
    },
    {
      "indent": 0,
      "text": "18.22.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.22.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct READ4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.22.2. RESULTS",
      "section_title": true,
      "ja": "18.22.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct READ4resok {\n        bool            eof;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READ4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READ4resok     resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.22.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.22.3. description"
    },
    {
      "indent": 3,
      "text": "The READ operation reads data from the regular file identified by the current filehandle.",
      "ja": "読み取り操作は、現在のファイルハンドルによって識別された通常のファイルからデータを読み取ります。"
    },
    {
      "indent": 3,
      "text": "The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of zero means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status NFS4_OK is returned with a data length set to zero and eof is set to TRUE. The READ is subject to access permissions checking.",
      "ja": "クライアントは、読み取りが開始される場所のオフセット、および読み取られるバイト数のカウントを提供します。ゼロのオフセットは、ファイルの先頭から始まるデータを読み取ることを意味します。オフセットがファイルのサイズ以上である場合、ステータスNFS4_OKはゼロに設定されたデータ長で返され、EOFはtrueに設定されます。読み取りはアクセス許可チェックの対象となります。"
    },
    {
      "indent": 3,
      "text": "If the client specifies a count value of zero, the READ succeeds and returns zero bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.",
      "ja": "クライアントがカウント値ゼロを指定した場合、読み取りは成功し、アクセス許可検査の対象となるデータのゼロバイトを再び返します。サーバーは、クライアントによって指定されたよりも少ないバイトを返すことを選択できます。クライアントはこの状態をチェックし、条件を適切に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Except when special stateids are used, the stateid value for a READ request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).",
      "ja": "特別なStateIDが使用されている場合は、読み取り要求のStateID値は、前のバイトレンジロックまたは共有予約要求または委任に関連付けられたStareIDから返される値を表します。StateIDは、関連するロックがまだ有効であることを確認するためにサーバーによって関連付けられている場合は関連する所有者を識別します（たとえば、失効していません）。"
    },
    {
      "indent": 3,
      "text": "If the read ended at the end-of-file (formally, in a correctly formed READ operation, if offset + count is equal to the size of the file), or the READ operation extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ of an empty file will always return eof as TRUE.",
      "ja": "読み取りがファイルの終わりで終了した場合（正しく形成された読み取り操作では、オフセット数がファイルのサイズに等しい場合）、または読み取り操作がファイルのサイズを超えて拡張された場合（オフセット数がある場合ファイルのサイズより大きい）、EOFはtrueとして返されます。そうでなければ、それは偽です。空のファイルの読み取りが成功すると、常にEOFがTrueとして返されます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルではない場合、エラーがクライアントに返されます。現在のファイルハンドルがNF4DIR型のオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべての場合では、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "For a READ with a stateid value of all bits equal to zero, the server MAY allow the READ to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a READ with a stateid value of all bits equal to one, the server MAY allow READ operations to bypass locking checks at the server.",
      "ja": "ゼロに等しいすべてのビットのStateID値を持つ読み取りの場合、サーバーは、必須のバイトレンジロックまたはファイルの現在の共有拒否モードを受けるように読み取ることを可能にします。1つに等しいすべてのビットのSTATEID値を持つ読み取りの場合、サーバーはサーバーでロックチェックをバイパスするための読み取り操作を可能にします。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.22.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.22.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server returns a \"short read\" (i.e., fewer data than requested and eof is set to FALSE), the client should send another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server reduce the transfer size and so return a short read result. Server resource exhaustion may also occur in a short read.",
      "ja": "サーバーが「短読」を返す場合（すなわち、要求されたより少ないデータがFalseに設定されている）場合、クライアントは残りのデータを取得するために別の読み取りを送信する必要があります。サーバーは、いくつかの状況下で要求されたよりも少ないデータを返すことがあります。ファイルは別のクライアントによって切り捨てられているか、またはサーバー自体の上に切り捨てられ、要求されているクライアントがそうであると考えているものからファイルサイズを変更することができます。これにより、クライアントで利用可能なデータの実際の量が減少します。サーバーが転送サイズを縮小し、短い読み取り結果を返す可能性があります。サーバーリソースの枯渇も短読で発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If mandatory byte-range locking is in effect for the file, and if the byte-range corresponding to the data to be read from the file is WRITE_LT locked by an owner not associated with the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate READ_LT via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the byte-range lock via LOCKU.",
      "ja": "必須のバイトレンジロックがファイルに有効であり、ファイルから読み出されるデータに対応するバイト範囲がWRITEDIDに関連付けられていない所有者によってLORT_LTの場合、サーバーはNFS4ERR_LOCKEDエラーを返します。読み取りを再試行する前に、クライアントはロック操作を介して適切なREAD_LTを取得しようとするはずです。読み出しが完了すると、クライアントはLockuを介してバイトレンジロックを解除する必要があります。"
    },
    {
      "indent": 3,
      "text": "If another client has an OPEN_DELEGATE_WRITE delegation for the file being read, the delegation must be recalled, and the operation cannot proceed until that delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a READ operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a READ to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.",
      "ja": "ファイルが読み取られているファイルに対してopen_delegate_writeの委任がある場合は、委任を呼び出す必要があり、その委任が返されるか取り消されるまで操作を続行できません。これが非常に早く起こる場合を除き、委任が未解決のままである間、1つ以上のNFS4ERR_DELAYエラーが要求された要求に返されます。通常、recallが以前のオープンの結果として呼び出されるため、リコールが発生するため、委任は読み取り操作の結果として呼び出されません。ただし、SPECIAL STATIODIDを使用して読み取りを行うことは可能ですので、クライアントが以前に開いていた場合でも、サーバーはこの場合を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.23. Operation 26: READDIR - Read Directory",
      "section_title": true,
      "ja": "18.23. 操作26：readdir  - ディレクトリの読み取り"
    },
    {
      "indent": 0,
      "text": "18.23.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.23.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct READDIR4args {\n        /* CURRENT_FH: directory */\n        nfs_cookie4     cookie;\n        verifier4       cookieverf;\n        count4          dircount;\n        count4          maxcount;\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.23.2. RESULTS",
      "section_title": true,
      "ja": "18.23.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct entry4 {\n        nfs_cookie4     cookie;\n        component4      name;\n        fattr4          attrs;\n        entry4          *nextentry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct dirlist4 {\n        entry4          *entries;\n        bool            eof;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct READDIR4resok {\n        verifier4       cookieverf;\n        dirlist4        reply;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READDIR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READDIR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.23.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.23.3. description"
    },
    {
      "indent": 3,
      "text": "The READDIR operation retrieves a variable number of entries from a file system directory and returns client-requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.",
      "ja": "READDIR動作は、ファイルシステムディレクトリからの変数のエントリ数を取得し、クライアントが後続のREADDIR内の追加のディレクトリエントリを要求できるようにするために、各エントリに対してクライアント要求された属性を情報と共に返す。"
    },
    {
      "indent": 3,
      "text": "The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of zero for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.",
      "ja": "引数には、READDIRがディレクトリ内で起動する場所を表すCookie値が含まれています。Cookieのゼロの値を使用して、ディレクトリの先頭で読み込みを開始します。後続のREADDIR要求の場合、クライアントは以前のREADDIR要求でサーバーによって提供されるCookie値を指定します。"
    },
    {
      "indent": 3,
      "text": "The request's cookieverf field should be set to 0 zero) when the request's cookie field is zero (first read of the directory). On subsequent requests, the cookieverf field must match the cookieverf returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.",
      "ja": "リクエストのCookieフィールドがゼロのとき（最初にディレクトリ読み取り）の場合は、要求のCookieVerfフィールドを0ゼロに設定する必要があります）。後続のリクエストでは、CookieVerfフィールドは、Cookieが取得されたREADDIRによって返されたCookieVerfと一致しなければなりません。cookieverfがディレクトリに対して有効でなくなったとサーバが実行された場合は、エラーNFS4ERR_NOT_SAMEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The dircount field of the request is a hint of the maximum number of bytes of directory information that should be returned. This value represents the total length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.",
      "ja": "要求のDirCountフィールドは、返されるべきディレクトリ情報の最大バイト数のヒントです。この値は、ディレクトリエントリの名前の合計長とこれらのエントリのCookie値を表します。この長さは、データのXDRエンコーディング（名前とCookie）を表し、サーバーのネイティブ形式の長さではありません。"
    },
    {
      "indent": 3,
      "text": "The maxcount field of the request represents the maximum total size of all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server MAY return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL MUST be returned to the client.",
      "ja": "要求のMAXCountフィールドは、ReadDir4Resok構造内に返されるすべてのデータの最大合計サイズを表し、XDRオーバーヘッドを含みます。サーバーはデータが少ないデータを返すことがあります。サーバーがMAXCOUNT制限内で単一のディレクトリエントリを返すことができない場合は、エラーNFS4ERR_TOOSMALLをクライアントに返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, the request's attr_request field represents the list of attributes to be returned for each directory entry supplied by the server.",
      "ja": "最後に、要求のattr_requestフィールドは、サーバーによって提供された各ディレクトリエントリに対して返される属性のリストを表します。"
    },
    {
      "indent": 3,
      "text": "A successful reply consists of a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The \"eof\" flag has a value of TRUE if there are no more entries in the directory.",
      "ja": "返信が成功すると、ディレクトリエントリのリストで構成されています。これらの各エントリには、ディレクトリエントリの名前、そのエントリのCookie値、および要求された関連属性が含まれています。ディレクトリにさらにエントリがない場合、 \"eof\"フラグにはtrueの値があります。"
    },
    {
      "indent": 3,
      "text": "The cookie value is only meaningful to the server and is used as a cursor for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but MUST NOT be interpreted as such by the client. Ideally, the cookie value SHOULD NOT change if the directory is modified since the client may be caching these values.",
      "ja": "Cookie値はサーバーにとってのみ意味があり、ディレクトリエントリのカーソルとして使用されます。前述のように、このクッキーはその後のREADDIR操作のためにクライアントによって使用され、それはディレクトリを読み続けることができるようにします。クッキーは概念が読み取りオフセットに似ていますが、クライアントによって解釈されてはいけません。理想的には、クライアントがこれらの値をキャッシュしている可能性があるため、Cookieの値は変更されないはずです。"
    },
    {
      "indent": 3,
      "text": "In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute rdattr_error (Section 5.8.1.12). With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.",
      "ja": "場合によっては、ディレクトリエントリの属性を取得している間、サーバはエラーが発生する可能性がある。ReadDir操作全体にエラーを返す代わりに、代わりに属性RDATTR_ERRORを返すことができます（セクション5.8.1.12）。これにより、サーバはクライアントに障害を伝達することができ、一時的な障害がある可能性がある場合のインスタンスの操作全体に失敗することはできません。明らかに、クライアントはこのメソッドのFATTR4_RDATTR_ERROR属性を正しく機能させる必要があります。クライアントが属性を要求しない場合、サーバーにはReadDir操作全体の失敗を返すかどうかはありません。"
    },
    {
      "indent": 3,
      "text": "For some file system environments, the directory entries \".\" and \"..\" have special meaning, and in other environments, they do not. If the server supports these special entries within a directory, they SHOULD NOT be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of zero, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server's response and local representations to enable a fully formed UNIX directory presentation to the application.",
      "ja": "一部のファイルシステム環境では、ディレクトリエントリ \"\"。そして、「..」は特別な意味を持ち、他の環境ではそうではありません。サーバーがディレクトリ内のこれらの特別なエントリをサポートしている場合は、READDIR応答の一部としてクライアントに返されないようにしてください。一部のクライアント環境を有効にするには、Cookie値0,1、および2の値が予約されていると見なされます。UNIXクライアントは、サーバーの応答とローカル表現を組み合わせるときにこれらの値を使用して、アプリケーションへの完全に形成されたUNIXディレクトリプレゼンテーションを可能にすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For READDIR arguments, cookie values of one and two SHOULD NOT be used, and for READDIR results, cookie values of zero, one, and two SHOULD NOT be returned.",
      "ja": "READDIR引数の場合、1と2のCookie値を使用しないでください.READDIRの結果は、Cookie値0、1、および2つのCookie値を返しません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.23.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.23.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server's file system directory representations can differ greatly. A client's programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore, the use of the dircount and maxcount fields are provided to enable the client to provide hints to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response.",
      "ja": "サーバーのファイルシステムディレクトリ表現は大きく異なる可能性があります。クライアントのプログラミングインタフェースは、NFSプロトコルによく変換されないように、ローカルの動作環境にもバインドされる可能性があります。したがって、DirCountフィールドとMAXCountフィールドを使用すると、クライアントがヒントをサーバーに提供できるようにします。クライアントがREADDIR中に属性コレクションについて積極的な場合、サーバーにはエンコードされた応答を制限する方法が考えられます。"
    },
    {
      "indent": 3,
      "text": "If dircount is zero, the server bounds the reply's size based on the request's maxcount field.",
      "ja": "dircountがゼロの場合、サーバーは要求のMAXCOUNTフィールドに基づいて返信のサイズを囲みます。"
    },
    {
      "indent": 3,
      "text": "The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server SHOULD make every effort to avoid this condition since the application at the client might be unable to properly handle this type of failure.",
      "ja": "CookieVerfは、古くなる可能性があるCookie値を管理するのに役立つようにサーバーによって使用される可能性があります。サーバーが提供されたCookie / CookieVeverfのペアでディレクトリを正しく読み続けることができないというまれな出来事であるべきです。クライアントのアプリケーションがこのタイプの障害を適切に処理できないため、この状態を回避するためにサーバーはすべての努力をしてください。"
    },
    {
      "indent": 3,
      "text": "The use of the cookieverf will also protect the client from using READDIR cookie values that might be stale. For example, if the file system has been migrated, the server might or might not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server accepts a cookie value but the underlying directory has changed and the response is invalid from the client's context of its previous READDIR.",
      "ja": "CookieVerfを使用すると、クライアントが古くなる可能性があるREADDIR Cookie値の使用から保護されます。たとえば、ファイルシステムが移行されている場合、サーバーは同じCookie値を使用してREADDIRを使用して使用されているサーバーを使用できない場合があります。クライアントがCookieVerfを提供すると、サーバーはクライアントに適切な応答を提供することができます。これにより、サーバーがCookie値を受け入れる場合を防ぎますが、基礎となるディレクトリが変更され、応答は前のReadDirのクライアントのコンテキストから無効です。"
    },
    {
      "indent": 3,
      "text": "Since some servers will not be returning \".\" and \"..\" entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.",
      "ja": "一部のサーバーが返却しないのでまた、「..」のエントリ以前のバージョンのNFSプロトコルで行われているように、これらのエントリを必要とするクライアントはREADDIR応答に存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.24. Operation 27: READLINK - Read Symbolic Link",
      "section_title": true,
      "ja": "18.24. 操作27：ReadLink  - シンボリックリンクを読みます"
    },
    {
      "indent": 0,
      "text": "18.24.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.24.1. 議論"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: symlink */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.24.2. RESULTS",
      "section_title": true,
      "ja": "18.24.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct READLINK4resok {\n        linktext4       link;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READLINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READLINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.24.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.24.3. description"
    },
    {
      "indent": 3,
      "text": "READLINK reads the data associated with a symbolic link. Depending on the value of the UTF-8 capability attribute (Section 14.4), the data is encoded in UTF-8. Whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted (except possibly to check for proper UTF-8 encoding) when created, but is simply stored.",
      "ja": "ReadLinkはシンボリックリンクに関連付けられているデータを読み取ります。UTF-8機能属性の値に応じて（14.4項）、データはUTF-8でエンコードされます。NFSクライアントによって作成されるか、サーバー上でローカルに作成されたものであれ、シンボリックリンク内のデータは解釈されません（場合によっては適切なUTF-8エンコーディングを確認する場合は）単純に保存されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.24.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.24.4. 実装"
    },
    {
      "indent": 3,
      "text": "A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a pathname that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.",
      "ja": "シンボリックリンクは名目上他のファイルへのポインタです。データは必ずしもサーバーによって解釈されるわけではなく、ファイルに保存されています。クライアント実装は、シンボリックリンク内のサーバーオペレーティングシステムに意味がないパス名を格納することが可能です。ReadLink操作は、解釈のためにクライアントにデータを返します。異なる実装がシンボリックリンクへのアクセスを共有したい場合は、シンボリックリンク内のデータの解釈に同意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error NFS4ERR_WRONG_TYPE if the object is not of type NF4LNK.",
      "ja": "ReadLink操作は、NF4LNK型のオブジェクトに対してのみ許可されています。オブジェクトがnf4lnk型ではない場合、サーバーはエラーNFS4ERR_WRONG_TYPEを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "18.25. Operation 28: REMOVE - Remove File System Object",
      "section_title": true,
      "ja": "18.25. 操作28：削除 - ファイルシステムオブジェクトを削除します"
    },
    {
      "indent": 0,
      "text": "18.25.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.25.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct REMOVE4args {\n        /* CURRENT_FH: directory */\n        component4      target;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.25.2. RESULTS",
      "section_title": true,
      "ja": "18.25.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct REMOVE4resok {\n        change_info4    cinfo;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union REMOVE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         REMOVE4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.25.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.25.3. description"
    },
    {
      "indent": 3,
      "text": "The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed. The directory may be either of type NF4DIR or NF4ATTRDIR.",
      "ja": "削除操作は、現在のFileHandleに対応するディレクトリからfilenameによって指定されたディレクトリエントリを削除（削除）します。ディレクトリ内のエントリが対応するファイルシステムオブジェクトへの最後の参照である場合、そのオブジェクトは破棄される可能性があります。ディレクトリは、nf4dir型またはNF4Attrdir型のどちらでもかまいません。"
    },
    {
      "indent": 3,
      "text": "For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.",
      "ja": "ファイル名が削除されたディレクトリの場合、サーバーはCINFOでchange_info4情報を返します。change_info4データ型のアトミックフィールドを使用すると、サーバーは、前後の変更属性が削除に関して原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If the target has a length of zero, or if the target does not obey the UTF-8 definition (and the server is enforcing UTF-8 encoding; see Section 14.4), the error NFS4ERR_INVAL will be returned.",
      "ja": "ターゲットに長さがゼロの場合、またはターゲットがUTF-8定義に従わない場合（およびサーバーはUTF-8エンコーディングを強制しています。セクション14.4を参照）、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.25.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.25.4. 実装"
    },
    {
      "indent": 3,
      "text": "NFSv3 required a different operator RMDIR for directory removal and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() [24] in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory) because they knew the server would check the file type. NFSv4.1 REMOVE can be used to delete any directory entry independent of its file type. The implementor of an NFSv4.1 client's entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before sending a REMOVE operation. Alternatively, the implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence of operations to verify the file type before a REMOVE operation in the same COMPOUND call.",
      "ja": "NFSV3ディレクトリの削除には異なる演算子RMDIRを必要としました。これにより、クライアントは、ディレクトリ以外の削除システムコール（例：POSIXのunlink（）[24]）に渡されたときにファイルの種類の確認をスキップして、ディレクトリを削除して、逆（例：RMDIR（））非ディレクトリ）サーバーがファイルの種類を確認することを知っているためです。NFSV4.1削除を使用して、そのファイルの種類とは無関係に任意のディレクトリエントリを削除できます。unlink（）およびrmdir（）システムコールからNFSV4.1クライアントのエントリポイントの実装者は、最初にファイルの種類をチェックして、削除操作を送信する前にシステムコールが削除できます。あるいは、実装者は、同じ複合呼び出しでの削除操作の前にファイルタイプを検証するために、ルックアップ/検証操作シーケンスを含む複合呼び出しを生成することができる。"
    },
    {
      "indent": 3,
      "text": "The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. While the traditional mechanism used is to RENAME the file from its old name to a new hidden name, the NFSv4.1 OPEN operation MAY return a result flag, OPEN4_RESULT_PRESERVE_UNLINKED, which indicates to the client that the file will be preserved if the file has an outstanding open (see Section 18.16).",
      "ja": "最後の参照の概念はサーバー固有です。ただし、オブジェクトの前回の属性のNumLinksフィールドが値1を持つ場合、クライアントはファイルハンドルを介してオブジェクトを参照してはいけません。同様に、クライアントは、オブジェクトがすぐに利用可能になって以前に関連付けられていたリソース（ディスク容量、ディレクトリエントリなど）に頼るべきではありません。したがって、削除を使用して削除した後にクライアントがファイルにアクセスできるようにする必要がある場合、クライアントはファイルがまだアクセス可能であることを確認するための手順を実行する必要があります。使用されている従来のメカニズムは、ファイルを古い名前から新しい隠しネームに変更することですが、NFSV4.1オープン操作は結果フラグを返すことができます。未払い開放（18.16節を参照）。"
    },
    {
      "indent": 3,
      "text": "If the server finds that the file is still open when the REMOVE arrives:",
      "ja": "サーバーが、削除が到着したときにファイルが開いていることを確認した場合"
    },
    {
      "indent": 3,
      "text": "* The server SHOULD NOT delete the file's directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.",
      "ja": "* ファイルがopen4_share_deny_writeまたはopen4_share_deny_bothで開かれた場合、サーバーはファイルのディレクトリエントリを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "* If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file's directory entry. However, until last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.",
      "ja": "* ファイルがOpen4_Share_Deny_WriteまたはOpen4_Share_deny_bothで開かれていない場合、サーバーはファイルのディレクトリエントリを削除する必要があります。ただし、ファイルの最後の閉じるまで、サーバーはそのファイルハンドルを介してファイルへのアクセスを許可し続けることがあります。"
    },
    {
      "indent": 3,
      "text": "* The server MUST NOT delete the directory entry if the reply from OPEN had the flag OPEN4_RESULT_PRESERVE_UNLINKED set.",
      "ja": "* Openからの応答がフラグOPEN4_RESULT_PRESERVE_UNLINKEDセットを持っていた場合、サーバーはディレクトリエントリを削除してはいけません。"
    },
    {
      "indent": 3,
      "text": "The server MAY implement its own restrictions on removal of a file while it is open. The server might disallow such a REMOVE (or a removal that occurs as part of RENAME). The conditions that influence the restrictions on removal of a file while it is still open include:",
      "ja": "サーバーは、開いている間にファイルの削除に独自の制限を実装することができます。サーバーはそのような削除（または名前変更の一部として発生する削除）を許可させる可能性があります。それがまだ開いている間のファイルの削除に対する制限に影響を与える条件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Whether certain access protocols (i.e., not just NFS) are holding the file open.",
      "ja": "* 特定のアクセスプロトコル（すなわち、NFSだけでなく）がファイルを開いているかどうか。"
    },
    {
      "indent": 3,
      "text": "* Whether particular options, access modes, or policies on the server are enabled.",
      "ja": "* 特定のオプション、アクセスモード、またはサーバー上のポリシーが有効になっているかどうか。"
    },
    {
      "indent": 3,
      "text": "If a file has an outstanding OPEN and this prevents the removal of the file's directory entry, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "ファイルが未解決の開いていて、これによりファイルのディレクトリエントリの削除が不要になると、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "Where the determination above cannot be made definitively because delegations are being held, they MUST be recalled to allow processing of the REMOVE to continue. When a delegation is held, the server has no reliable knowledge of the status of OPENs for that client, so unless there are files opened with the particular deny modes by clients without delegations, the determination cannot be made until delegations are recalled, and the operation cannot proceed until each sufficient delegation has been returned or revoked to allow the server to make a correct determination.",
      "ja": "代表団が保持されているため、上記の決定を定義的に作成できない場合は、削除の処理を続行できるようにしてください。委任が保持されると、サーバーはそのクライアントの開封のステータスに関する信頼性の高い知識を持たないため、委任なしのクライアントによって特定の拒否モードでオープンされていない限り、委任がリコールされるまで決定でき、操作を行うことはできません。各十分な委任が返されたか、サーバーが正しい決定を下すことができるようにするまで続行できません。"
    },
    {
      "indent": 3,
      "text": "In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while delegations remain outstanding.",
      "ja": "代表団が呼び出されるすべての場合において、対象は未解決のままである間、サーバーは1つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the directory delegation MUST be recalled, and the operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルが別のクライアントがディレクトリ委任を保持するディレクトリを指定した場合、通知を送信して状況を解決できない限り、ディレクトリ委任を呼び出す必要があり、委任が返されたか取り消されるまで操作を続行してはいけません。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.",
      "ja": "現在のFileHandleが1つ以上のディレクトリ委任が存在するディレクトリを指定すると、これらの代理人がそのような通知を要求すると、この操作の結果としてNotify4_Remove_Entryが生成されます。"
    },
    {
      "indent": 3,
      "text": "Note that when a remove occurs as a result of a RENAME, NOTIFY4_REMOVE_ENTRY will only be generated if the removal happens as a separate operation. In the case in which the removal is integrated and atomic with RENAME, the notification of the removal is integrated with notification for the RENAME. See the discussion of the NOTIFY4_RENAME_ENTRY notification in Section 20.4.",
      "ja": "なお、RENAMEの結果として削除が発生した場合、削除が別の操作として発生した場合にのみNOTIFY4_REMOVE_ENTRYが生成されます。削除が変更されて名前が変更されている場合、削除の通知は名前変更の通知と統合されます。セクション20.4のNotify4_Rename_Entry通知の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.26. Operation 29: RENAME - Rename Directory Entry",
      "section_title": true,
      "ja": "18.26. 操作29：RENAME  - ディレクトリエントリの名前を変更します"
    },
    {
      "indent": 0,
      "text": "18.26.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.26.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct RENAME4args {\n        /* SAVED_FH: source directory */\n        component4      oldname;\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.26.2. RESULTS",
      "section_title": true,
      "ja": "18.26.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RENAME4resok {\n        change_info4    source_cinfo;\n        change_info4    target_cinfo;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union RENAME4res switch (nfsstat4 status) {\n case NFS4_OK:\n        RENAME4resok    resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.26.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.26.3. description"
    },
    {
      "indent": 3,
      "text": "The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories MUST reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.",
      "ja": "RENAME操作は、Savefh操作によって設定された保存されたファイルハンドルに対応するソースディレクトリで識別されたオブジェクトを、現在のファイルハンドルに対応するターゲットディレクトリの新名に変更します。操作はクライアントにアトミックである必要があります。ソースディレクトリとターゲットディレクトリは、サーバー上の同じファイルシステム上に存在する必要があります。成功すると、現在のファイルハンドルはターゲットディレクトリになります。"
    },
    {
      "indent": 3,
      "text": "If the target directory already contains an entry with the name newname, the source object MUST be compatible with the target: either both are non-directories or both are directories and the target MUST be empty. If compatible, the existing target is removed before the rename occurs or, preferably, the target is removed atomically as part of the rename. See Section 18.25.4 for client and server actions whenever a target is removed. Note however that when the removal is performed atomically with the rename, certain parts of the removal described there are integrated with the rename. For example, notification of the removal will not be via a NOTIFY4_REMOVE_ENTRY but will be indicated as part of the NOTIFY4_ADD_ENTRY or NOTIFY4_RENAME_ENTRY generated by the rename.",
      "ja": "ターゲットディレクトリにNewNameという名前のエントリがすでに含まれている場合、ソースオブジェクトはターゲットと互換性がある必要があります。両方ともディレクトリ以外またはその両方がディレクトリであり、ターゲットは空でなければなりません。互換性がある場合、既存のターゲットは名前が変更される前に削除されるか、または好ましくは、ターゲットは名前変更の一部としてアトミックに削除される。ターゲットが削除されるたびに、クライアントとサーバーのアクションについては、セクション18.25.4を参照してください。ただし、名前の変更で除去が原子的に行われると、そこに記載されている取り外しの特定の部分は名前の変更と統合されています。たとえば、削除の通知はNOTIFY4_REMOVE_ENTRYを介してはなりませんが、名前変更によって生成されたNotify4_ADD_ENTRYまたはNOTIFY4_RENAME_ENTRYの一部として示されます。"
    },
    {
      "indent": 3,
      "text": "If the source object and the target are not compatible or if the target is a directory but not empty, the server will return the error NFS4ERR_EXIST.",
      "ja": "ソースオブジェクトとターゲットが互換性がない場合、またはターゲットがディレクトリの場合は空ではない場合、サーバーはエラーNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "If oldname and newname both refer to the same file (e.g., they might be hard links of each other), then unless the file is open (see Section 18.26.4), RENAME MUST perform no action and return NFS4_OK.",
      "ja": "OldNameとNewNameの両方が同じファイル（たとえば、互いのハードリンクがある可能性がある場合）を参照してください（18.26.4項を参照）、名前の変更は行動を実行してNFS4_OKを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.",
      "ja": "名前の変更に含まれる両方のディレクトリの場合、サーバーはchange_info4情報を返します。change_info4データ型のアトミックフィールドを使用すると、サーバーは変更された変更属性が名前変更に対して原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If oldname refers to a named attribute and the saved and current filehandles refer to different file system objects, the server will return NFS4ERR_XDEV just as if the saved and current filehandles represented directories on different file systems.",
      "ja": "OldNameが名前付き属性と保存および現在のファイルハンドルを参照している場合、保存されたファイルハンドルと現在のファイルハンドルがさまざまなファイルシステム上のディレクトリを表すかのように、サーバーはNFS4ERR_XDEVを返します。"
    },
    {
      "indent": 3,
      "text": "If oldname or newname has a length of zero, or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "OLDNAMEまたはNEWNAMEの長さがゼロの場合、またはOLDNAMEまたはNEWNAMEがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.26.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.26.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the RENAME operation such that RENAME may not be done when the file being renamed is open or when that open is done by particular protocols, or with particular options or access modes. Similar restrictions may be applied when a file exists with the target name and is open. When RENAME is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "名前が変更されているファイルが開いているとき、またはその開いているとき、または特定のオプションまたはアクセスモードによって行われている場合には、サーバーは名前変更操作に制限を課すことができます。ターゲット名を持つファイルが存在し、開いている場合も同様の制限が適用される場合があります。このような制限のため、名前変更が拒否されると、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "When oldname and rename refer to the same file and that file is open in a fashion such that RENAME would normally be rejected with NFS4ERR_FILE_OPEN if oldname and newname were different files, then RENAME SHOULD be rejected with NFS4ERR_FILE_OPEN.",
      "ja": "OldNameとRenameが同じファイルを参照していて、そのファイルは、NFS4ERR_FILE_OPENがNFS4ERR_FILE_OPENで拒否されるように、OldNameとNewNameがNFS4ERR_FILE_OPENに拒否されると、名前の変更はNFS4ERR_FILE_OPENで拒否されるべきです。"
    },
    {
      "indent": 3,
      "text": "If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a rename, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. This is because when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The RENAME operation need only be delayed until a definitive result can be obtained. For example, if there are multiple delegations and one of them establishes an open whose presence would prevent the rename, given the server's semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.",
      "ja": "サーバーがそのような制限を実装し、これらの制限事項にはNFSv4の場合が含まれている場合は、名前変更の実行が正常に実行されないようにします。サーバーは、その決定に関連する開いたオープンの存在を隠す可能性のある委任を思い出す必要があります。これは、クライアントが委任を保持している場合、クライアントが実行されてローカルに実行される可能性があるため、サーバーはそのクライアントのオープンの正確なアカウントを持たない可能性があります。名前の変更操作は、最終的な結果が得られるまで遅れるだけでよい。たとえば、複数の代表団がある場合、サーバーのセマンティクスを指定して、その名称が名前変更を妨げるオープンを確立した場合、他の委任が返されるのを待たずに、NFS4ERR_FILE_OPENが呼び出し元に返されることがあります。同様に、そのようなオープンが代理人に関連付けられていない場合、NFS4ERR_FILE_OPENはすぐに委任リコールが行われずに返されます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle or the saved filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルまたは保存されたファイルハンドルが、別のクライアントがディレクトリ委任を保持するディレクトリを指定した場合、通知を送信して状況を解決できる場合は、委任が返されるまで操作を進めることはできません。取り消されました。これが非常に迅速に起こる場合を除き、1つ以上のNFS4ERR_DELAYエラーが発生した間に要求に返されますが、委任は未解決のままです。"
    },
    {
      "indent": 3,
      "text": "When the current and saved filehandles are the same and they designate a directory for which one or more directory delegations exist, then, when those delegations request such notifications, a notification of type NOTIFY4_RENAME_ENTRY will be generated as a result of this operation. When oldname and rename refer to the same file, no notification is generated (because, as Section 18.26.3 states, the server MUST take no action). When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_RENAME_ENTRY notification.",
      "ja": "現在および保存されたファイルハンドルが同じで、1つまたは複数のディレクトリ委任が存在するディレクトリを指定した場合、これらの代理委員がそのような通知を要求すると、この操作の結果、タイプNOTIFY4_RENAME_ENTRYの通知が生成されます。OldNameとRenameが同じファイルを参照すると、通知は生成されません（セクション18.26.3として、サーバーはアクションを取らなければならないため）。ターゲットと同じ名前があるため、ファイルが削除されると、その削除が変更された名前の変更が原子的に行われた場合、Notify4_Remove_Entry通知は生成されません。代わりに、ファイルの削除はNotify4_Rename_Entry通知の一部として報告されます。"
    },
    {
      "indent": 3,
      "text": "When the current and saved filehandles are not the same:",
      "ja": "現在および保存されたファイルハンドルが同じではない場合"
    },
    {
      "indent": 3,
      "text": "* If the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation. When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_ADD_ENTRY notification.",
      "ja": "* 現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定すると、これらの代理店がそのような通知を要求すると、この操作の結果としてNotify4_ad_Entryが生成されます。ターゲットと同じ名前があるため、ファイルが削除されると、その削除が変更された名前の変更が原子的に行われた場合、Notify4_Remove_Entry通知は生成されません。代わりに、ファイルの削除はNotify4_Add_Entry通知の一部として報告されます。"
    },
    {
      "indent": 3,
      "text": "* If the saved filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.",
      "ja": "* 保存されたファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定すると、これらの代理人がそのような通知を要求すると、この操作の結果としてNotify4_Remove_Entryが生成されます。"
    },
    {
      "indent": 3,
      "text": "If the object being renamed has file delegations held by clients other than the one doing the RENAME, the delegations MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Note that in the case of multiply linked files, the delegation recall requirement applies even if the delegation was obtained through a different name than the one being renamed. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.",
      "ja": "名前変更されているオブジェクトに名前の変更を行っている1つ以外のクライアントが保持しているファイルの代表が、代表録を呼び出す必要があり、そのような各委任が返されたか取り消されるまで操作は続行できません。乗算ファイルの場合、委任が名前が変更されているものとは異なる名前を介して取得された場合でも、委任リコール要件が適用されます。代表団が呼び出されるすべての場合において、委任が迅速に返される場合は、委任が未解決のままである間は、サーバーは1つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "The RENAME operation must be atomic to the client. The statement \"source and target directories MUST reside on the same file system on the server\" means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned.",
      "ja": "名前の変更操作はクライアントにアトミックでなければなりません。ステートメント「ソースディレクトリとターゲットディレクトリはサーバー上の同じファイルシステムに存在する必要があります」とは、ディレクトリの属性のFSIDフィールドが同じであることを意味します。異なるファイルシステムに存在する場合は、エラーNFS4ERR_XDEVが返されます。"
    },
    {
      "indent": 3,
      "text": "Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.",
      "ja": "オブジェクトのFH_EXPIRE_TYPE属性の値に基づいて、ファイルハンドルは名前変更時に期限切れになるか、無効にしてもしなくてもよい。ただし、サーバーの実装者は、この方法でファイルハンドルを期限切れに保つことを試みることを強く奨励されています。"
    },
    {
      "indent": 3,
      "text": "On some servers, the file names \".\" and \"..\" are illegal as either oldname or newname, and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.",
      "ja": "一部のサーバーでは、ファイル名 \"\"。そして、oldNameまたはnewnameとして違法なものであり、エラーNFS4ERR_BADNAMEになります。さらに、多くのサーバーで、OldNameまたはNewNameがソースディレクトリのエイリアスである場合はチェックされます。このようなサーバーは、これらの場合にエラーNFS4ERR_INVALを返します。"
    },
    {
      "indent": 3,
      "text": "If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.",
      "ja": "ソースファイルまたはターゲットファイルハンドルのいずれかがディレクトリではない場合、サーバーはNFS4ERR_NOTDIRを返します。"
    },
    {
      "indent": 0,
      "text": "18.27. Operation 31: RESTOREFH - Restore Saved Filehandle",
      "section_title": true,
      "ja": "18.27. 操作31：RESTOREFH  - 保存されたファイルハンドルを復元します"
    },
    {
      "indent": 0,
      "text": "18.27.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.27.1. 議論"
    },
    {
      "indent": 3,
      "text": "/* SAVED_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.27.2. RESULTS",
      "section_title": true,
      "ja": "18.27.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RESTOREFH4res {\n        /*\n         * If status is NFS4_OK,\n         *     new CURRENT_FH: value of saved fh\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.27.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.27.3. description"
    },
    {
      "indent": 3,
      "text": "The RESTOREFH operation sets the current filehandle and stateid to the values in the saved filehandle and stateid. If there is no saved filehandle, then the server will return the error NFS4ERR_NOFILEHANDLE.",
      "ja": "RestoreFH操作は、現在のFileHandleとStateIDを保存されたファイルハンドルとStateIDの値に設定します。保存されたファイルハンドルがない場合、サーバーはエラーNFS4ERR_NOFILEHANDLEを返します。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のStateIDの詳細については、16.2.3.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.27.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.27.4. 実装"
    },
    {
      "indent": 3,
      "text": "Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming that the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,",
      "ja": "OpenとLookupのような操作では、現在のファイルハンドルを使用してディレクトリを表し、新しいファイルハンドルと置き換えます。前のファイルハンドルがSavefh演算子で保存されたとすると、前のファイルハンドルを現在のファイルハンドルとして復元できます。これは、ディレクトリの操作後の属性を取得するために一般的に使用されます。"
    },
    {
      "indent": 9,
      "text": "PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits \"foo\" attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)",
      "ja": "PUTFH（ディレクトリFileHandle）Savefh GetAttr attrbits（op Pretr Attrs）optbits \"foo\" attrs getattr attrbits（ファイル属性）restorefh getattr attrbits（Post-op Attrs）"
    },
    {
      "indent": 0,
      "text": "18.28. Operation 32: SAVEFH - Save Current Filehandle",
      "section_title": true,
      "ja": "18.28. 操作32：Savefh  - 現在のファイルハンドルを保存します"
    },
    {
      "indent": 0,
      "text": "18.28.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.28.1. 議論"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.28.2. RESULTS",
      "section_title": true,
      "ja": "18.28.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct SAVEFH4res {\n        /*\n         * If status is NFS4_OK,\n         *    new SAVED_FH: value of current fh\n         */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.28.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.28.3. description"
    },
    {
      "indent": 3,
      "text": "The SAVEFH operation saves the current filehandle and stateid. If a previous filehandle was saved, then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.",
      "ja": "Savefh操作は現在のFileHandleとStateIDを保存します。以前のファイルハンドルが保存された場合は、アクセスできない。保存されたファイルハンドルは、RestoreFH演算子を使用して現在のファイルハンドルとして復元できます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のStateIDの詳細については、16.2.3.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.28.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.28.4. 実装"
    },
    {
      "indent": 0,
      "text": "18.29. Operation 33: SECINFO - Obtain Available Security",
      "section_title": true,
      "ja": "18.29. 操作33：SecInfo  - 利用可能なセキュリティを取得します"
    },
    {
      "indent": 0,
      "text": "18.29.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.29.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct SECINFO4args {\n        /* CURRENT_FH: directory */\n        component4      name;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.29.2. RESULTS",
      "section_title": true,
      "ja": "18.29.2. 結果"
    },
    {
      "indent": 3,
      "text": "/*\n * From RFC 2203\n */\nenum rpc_gss_svc_t {\n        RPC_GSS_SVC_NONE        = 1,\n        RPC_GSS_SVC_INTEGRITY   = 2,\n        RPC_GSS_SVC_PRIVACY     = 3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct rpcsec_gss_info {\n        sec_oid4        oid;\n        qop4            qop;\n        rpc_gss_svc_t   service;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* RPCSEC_GSS has a value of '6' - See RFC 2203 */\nunion secinfo4 switch (uint32_t flavor) {\n case RPCSEC_GSS:\n         rpcsec_gss_info        flavor_info;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef secinfo4 SECINFO4resok<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union SECINFO4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* CURRENTFH: consumed */\n         SECINFO4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.29.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.29.3. description"
    },
    {
      "indent": 3,
      "text": "The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, file name pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to LOOKUP the name, then SECINFO MUST behave the same way and return NFS4ERR_ACCESS.",
      "ja": "SECINFO操作は、特定のディレクトリファイルハンドルファイル名ペアの有効なRPC認証フレーバーのリストを取得するためにクライアントによって使用されます。SecInfoは、名前を評価するときにルックアップに使用される同じアクセス方法を適用する必要があります。したがって、リクエスタに名前を検索するための適切なアクセス権がない場合は、SECINFOが同じ方法で動作し、NFS4ERR_ACCESSを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The result will contain an array that represents the security mechanisms available, with an order corresponding to the server's preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick in the server's preference order the first one it supports. The array entries are represented by the secinfo4 structure. The field 'flavor' will contain a value of AUTH_NONE, AUTH_SYS (as defined in RFC 5531 [3]), or RPCSEC_GSS (as defined in RFC 2203 [4]). The field flavor can also be any other security flavor registered with IANA.",
      "ja": "結果は、利用可能なセキュリティメカニズムを表すアレイを、サーバの設定に対応する順序で、最も好ましいがアレイ内の最も好ましい。クライアントは、それが希望とサポートするセキュリティメカニズムを無料で選択したり、サーバーの優先順位をサポートしているものを選択したりします。配列エントリはsecInfo4構造によって表されます。フィールド 'flavor'には、auth_none、auth_sys（RFC 5531 [3]で定義されているように）、またはRPCSEC_GSSの値が含まれます（RFC 2203 [4]で定義されているように）。フィールドフレーバーは、IANAに登録されているその他のセキュリティフレーバーでもあります。"
    },
    {
      "indent": 3,
      "text": "For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. The same is true of many (if not most) other security flavors, including AUTH_DH. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object identifier (OID, as defined in RFC 2743 [7]), the quality of protection (as defined in RFC 2743 [7]), and the service type (as defined in RFC 2203 [4]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.",
      "ja": "FLAVORS AUTH_NONEおよびAUTH_SYSの場合、追加のセキュリティ情報は返されません。auth_dhを含む他のセキュリティフレーバーの多くのセキュリティフレーバーについても同じことが同じです。RPCSEC_GSSの戻り値については、メカニズム・オブジェクト識別子（RFC 2743 [7]で定義されているOID）、保護品質（RFC 2743 [7]）とサービス・タイプを含むセキュリティトリプルが返されます。（RFC 2203 [4]で定義されているように）。SecInfoは、さまざまなセキュリティトリプル値を持つRPCSEC_GSSに等しいフレーバーで複数のエントリを返すことが可能です。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.",
      "ja": "成功すると、現在のファイルハンドルが消費されます（2.6.3.1.1.8項参照）、およびSecInfo以降の次の操作が現在のFileHandleを使用しようとすると、その操作はステータスNFS4ERR_NOFILEHANDLEで失敗します。"
    },
    {
      "indent": 3,
      "text": "If the name has a length of zero, or if the name does not obey the UTF-8 definition (assuming UTF-8 capabilities are enabled; see Section 14.4), the error NFS4ERR_INVAL will be returned.",
      "ja": "名前に長さがゼロになっている場合、または名前がUTF-8定義に従わない場合（UTF-8機能が有効になっていると仮定します。セクション14.4を参照）、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "See Section 2.6 for additional information on the use of SECINFO.",
      "ja": "SecInfoの使用に関する追加情報については、2.6項を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.29.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.29.4. 実装"
    },
    {
      "indent": 3,
      "text": "The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server's security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.",
      "ja": "NFS4ERR_WRONGSECのエラー値が別のNFS操作から返されると、SECINFOの動作はNFSクライアントによって使用されることが期待されます。これは、サーバーのセキュリティポリシーがクライアントが現在使用しているものとは異なるクライアントを意味します。この時点で、クライアントはセキュリティフレーバーのリストを取得し、そのポリシーに最も適したものを選択することが期待されています。"
    },
    {
      "indent": 3,
      "text": "As mentioned, the server's security policies will determine when a client request receives NFS4ERR_WRONGSEC. See Table 14 for a list of operations that can return NFS4ERR_WRONGSEC. In addition, when READDIR returns attributes, the rdattr_error (Section 5.8.1.12) can contain NFS4ERR_WRONGSEC. Note that CREATE and REMOVE MUST NOT return NFS4ERR_WRONGSEC. The rationale for CREATE is that unless the target name exists, it cannot have a separate security policy from the parent directory, and the security policy of the parent was checked when its filehandle was injected into the COMPOUND request's operations stream (for similar reasons, an OPEN operation that creates the target MUST NOT return NFS4ERR_WRONGSEC). If the target name exists, while it might have a separate security policy, that is irrelevant because CREATE MUST return NFS4ERR_EXIST. The rationale for REMOVE is that while that target might have a separate security policy, the target is going to be removed, and so the security policy of the parent trumps that of the object being removed. RENAME and LINK MAY return NFS4ERR_WRONGSEC, but the NFS4ERR_WRONGSEC error applies only to the saved filehandle (see Section 2.6.3.1.2). Any NFS4ERR_WRONGSEC error on the current filehandle used by LINK and RENAME MUST be returned by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation that injected the current filehandle.",
      "ja": "前述のように、サーバーのセキュリティポリシーは、クライアント要求がNFS4ERR_WRONGSECを受信するかを決定します。 NFS4ERR_WRONGSECを返すことができる操作のリストについては、表14を参照してください。さらに、READDIRが属性を返す場合、rdattr_error（セクション5.8.1.12）にはNFS4ERR_WRONGSECを含めることができます。作成と削除はNFS4ERR_WRONGSECを返さないでください。 CREATEの根拠は、ターゲット名が存在しない限り、親ディレクトリから個別のセキュリティポリシーを持つことはできません。そのファイルハンドルが複合要求の操作ストリームに注入されたときに親のセキュリティポリシーがチェックされます（同様の理由で、ターゲットを作成するオープン操作はNFS4ERR_WRONGSECを返さないでください）。ターゲット名が存在する場合は、セキュリティポリシーが個別に設定されている可能性がありますが、CreateはNFS4ERR_EXISTを返す必要があります。 Removeの根拠は、そのターゲットが別のセキュリティポリシーを持つ可能性があるが、ターゲットは削除される予定であるため、親のセキュリティポリシーは削除されているオブジェクトのセキュリティポリシーが切り捨てられます。名前の変更とリンクはNFS4ERR_WRONGSECを返しますが、NFS4ERR_WRONGSECエラーは保存されたファイルハンドルにのみ適用されます（セクション2.6.3.1.2を参照）。現在のファイルハンドルを注文したPUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFH操作によって、LinkとRenameで使用される現在のFileHandleのNFS4ERR_WRONGSECエラーが返される必要があります。"
    },
    {
      "indent": 3,
      "text": "With the exception of LINK and RENAME, the set of operations that can return NFS4ERR_WRONGSEC represents the point at which the client can inject a filehandle into the \"current filehandle\" at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH), generated as a result of a name-to-filehandle translation (LOOKUP and OPEN), or generated from the saved filehandle via RESTOREFH. As Section 2.6.3.1.1.1 states, a put filehandle operation followed by SAVEFH MUST NOT return NFS4ERR_WRONGSEC. Thus, the RESTOREFH operation, under certain conditions (see Section 2.6.3.1.1), is permitted to return NFS4ERR_WRONGSEC so that security policies can be honored.",
      "ja": "リンクと名前変更を除いて、NFS4ERR_WRONGSECを返すことができる一連の操作は、クライアントがサーバーの「現在のFileHandle」にファイルハンドルを注入できるポイントを表します。FileHandleは、名前からFileHandle変換（ルックアップとオープン）の結果として生成されたクライアント（putfh、putpubfh、putrootfh）によって提供されるか、またはrestorefhを介して保存されたファイルハンドルから生成されます。セクション2.6.3.1.1.1.1状態として、PUTファイルハンドル操作とそれに続くSAVEFHはNFS4ERR_WRONGSECを返さないでください。したがって、特定の条件下でのRestoreFH操作（セクション2.6.3.1.1参照）は、セキュリティポリシーを尊重することができるようにNFS4ERR_WRONGSECを返すことが許可されています。"
    },
    {
      "indent": 3,
      "text": "The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request's security triple did not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.",
      "ja": "READDIRの動作はNFS4ERR_WRONGSECエラーを直接返しません。ただし、READDIR要求に属性の要求が含まれている場合は、READDIR要求のセキュリティトリプルがディレクトリエントリのそれと一致しなかった可能性があります。この場合、クライアントがRDATTR_ERROR属性を要求した場合、サーバーはエントリのRDATTR_ERRORのNFS4ERR_WRONGSECエラーを返します。"
    },
    {
      "indent": 3,
      "text": "To resolve an error return of NFS4ERR_WRONGSEC, the client does the following:",
      "ja": "NFS4ERR_WRONGSECのエラー返品を解決するには、クライアントは次のことを行います。"
    },
    {
      "indent": 3,
      "text": "* For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.",
      "ja": "* ルックアップとオープンの場合、クライアントは元のルックアップで提供されているのと同じ現在のファイルハンドルと名前を持つSecInfoを使用します。また、利用可能なセキュリティトリプルを列挙します。"
    },
    {
      "indent": 3,
      "text": "* For the rdattr_error, the client will use SECINFO with the same current filehandle as provided in the original READDIR. The name passed to SECINFO will be that of the directory entry (as returned from READDIR) that had the NFS4ERR_WRONGSEC error in the rdattr_error attribute.",
      "ja": "* RDATTR_ERRORの場合、クライアントは元のREADDIRで提供されているのと同じ現在のファイルハンドルでSECINFOを使用します。SecInfoに渡された名前は、rdattr_error属性のNFS4ERR_WRONGSECエラーを持つディレクトリエントリ（READDIRから返される）のものになります。"
    },
    {
      "indent": 3,
      "text": "* For PUTFH, PUTROOTFH, PUTPUBFH, RESTOREFH, LINK, and RENAME, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_CURRENT_FH }. The client will prefix the SECINFO_NO_NAME operation with the appropriate PUTFH, PUTPUBFH, or PUTROOTFH operation that provides the filehandle originally provided by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation.",
      "ja": "* PUTFH、PUTROOTFH、PUTPUBF、RESTOREFH、LINK、およびRENAMEの場合、クライアントはsecinfo_no_name {style = secinfo_style4_current_fh}を使用します。クライアントは、PUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFH操作によって最初に提供されたFileHandleを提供する適切なPUTFH、PUTPUBFH、またはPUTROOTFH操作でSECINFO_NO_NAME操作を接頭辞めます。"
    },
    {
      "indent": 6,
      "text": "NOTE: In NFSv4.0, the client was required to use SECINFO, and had to reconstruct the parent of the original filehandle and the component name of the original filehandle. The introduction in NFSv4.1 of SECINFO_NO_NAME obviates the need for reconstruction.",
      "ja": "注：NFSv4.0では、クライアントはSecInfoを使用する必要があり、元のファイルハンドルの親を再構築し、元のファイルハンドルのコンポーネント名を再構築しました。SECINFO_NO_NAMEのNFSV4.1の導入は再構成の必要性を取り除きます。"
    },
    {
      "indent": 3,
      "text": "* For LOOKUPP, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_PARENT } and provide the filehandle that equals the filehandle originally provided to LOOKUPP.",
      "ja": "* Lookuppの場合、クライアントはsecinfo_no_name {style = secinfo_style4_parent}を使用し、Lookuppに提供されたファイルハンドルに等しいファイルハンドルを提供します。"
    },
    {
      "indent": 3,
      "text": "See Section 21 for a discussion on the recommendations for the security flavor used by SECINFO and SECINFO_NO_NAME.",
      "ja": "secinfoとsecinfo_no_nameによって使用されるセキュリティフレーバーの推奨事項についての議論については、セクション21を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.30. Operation 34: SETATTR - Set Attributes",
      "section_title": true,
      "ja": "18.30. 操作34：SETATTR  - 属性を設定します"
    },
    {
      "indent": 0,
      "text": "18.30.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.30.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct SETATTR4args {\n        /* CURRENT_FH: target object */\n        stateid4        stateid;\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.30.2. RESULTS",
      "section_title": true,
      "ja": "18.30.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct SETATTR4res {\n        nfsstat4        status;\n        bitmap4         attrsset;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.30.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.30.3. description"
    },
    {
      "indent": 3,
      "text": "The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.",
      "ja": "setAttrの動作は、ファイルシステムオブジェクトの属性の1つ以上を変更します。新しい属性は、ビットマップとビットマップのビット順に続く属性で指定されます。"
    },
    {
      "indent": 3,
      "text": "The stateid argument for SETATTR is used to provide byte-range locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file's data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies OPEN4_SHARE_DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with byte-range locks, for those cases in which a server is implementing mandatory byte-range locking behavior. A valid stateid SHOULD always be specified. When the file size attribute is not set, the special stateid consisting of all bits equal to zero MAY be passed.",
      "ja": "setAttrのstateID引数は、size属性を設定するsetAttr要求に必要なバイトレンジロックコンテキストを提供するために使用されます。SIZE属性を設定するとファイルのデータが変更されるため、対応する書き込みと同じロック要件があります。size属性を設定するsetAttrは、open4_share_deny_writeを指定する共有予約と互換性がありません。古いファイルの終わりと新しいファイルの最後のファイルの間の領域は、競合のターゲットとして、書き込みのターゲットとして指定されていたのと同じように修正されると見なされます。バイトレンジロック、サーバーが必須バイトレンジロック動作を実装している場合の場合、ロックします。有効なStateIDを常に指定する必要があります。ファイルサイズ属性が設定されていない場合は、ゼロに等しいすべてのビットからなる特別なStareIDを渡すことができます。"
    },
    {
      "indent": 3,
      "text": "On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the attrmask field of the obj_attributes field in the argument.",
      "ja": "操作の成功または失敗のいずれかで、サーバーはattrsSetビットマスクを返して、属性が正常に設定されたことを表します。応答内のattrsSetは、引数内のobj_attributesフィールドのattrmaskフィールドのサブセットです。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.30.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.30.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the request specifies the owner attribute to be set, the server SHOULD allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in a way as to prohibit the setting of the owner attribute unless the requester has privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object (e.g., an exclusive create via OPEN) followed by a SETATTR.",
      "ja": "要求が設定する所有者属性を指定する場合、そのオブジェクトの現在の所有者が要求で指定された値と一致すると、サーバーは操作を成功させるようにしてください。要求者が特権を持たない限り、一部のサーバーは、所有者属性の設定を禁止するように実装されてもよい。この1つの場合一致する所有者値の1例でサーバがLenientである場合、クライアント実装は、オブジェクトを作成した場合（例えば、オープンによる排他的な作成を介したもの）、続いてsetAttrを単純化することができる。"
    },
    {
      "indent": 3,
      "text": "The file size attribute is used to request changes to the size of a file. A value of zero causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using unallocated bytes (holes) or allocated data bytes set to zero. Clients should not make any assumptions regarding a server's implementation of this feature, beyond that the bytes in the affected byte-range returned by READ will be zeroed. Servers MUST support extending the file size via SETATTR.",
      "ja": "ファイルサイズ属性は、ファイルのサイズへの変更を要求するために使用されます。ゼロの値はファイルを切り捨てます。ファイルの現在のサイズよりも小さい値が新しいサイズから破棄されるファイルの終わりにデータを破棄し、そのファイルの現在のサイズより大きいサイズで論理的にゼロにされるファイルの末尾に追加されるデータバイト。サーバーは、未割り当てバイト（穴）またはゼロに設定された割り当てデータバイトを使用してこれを自由に実装できます。クライアントは、この機能のサーバーの実装に関して仮定してはいけません。読み取りによって返される影響を受けるバイト内のバイトはゼロにされます。サーバーはSETATTRを介してファイルサイズの拡張をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "SETATTR is not guaranteed to be atomic. A failed SETATTR may partially change a file's attributes, hence the reason why the reply always includes the status and the list of attributes that were set.",
      "ja": "setAttrはアトミックであることが保証されていません。失敗したSETATTRはファイルの属性を部分的に変更することができます。したがって、応答に常に設定された属性のリストとリストが含まれている理由があります。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being changed has a file delegation that is held by a client other than the one doing the SETATTR, the delegation(s) must be recalled, and the operation cannot proceed to actually change an attribute until each such delegation is returned or revoked. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.",
      "ja": "属性が変更されているオブジェクトにSETATTRを実行しているクライアントによって保持されているファイルの委任がある場合は、委任を呼び出す必要があります。返されたか取り消されました。代表団が呼び出されるすべての場合において、委任が迅速に返される場合は、委任が未解決のままである間は、サーバーは1つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being set is a directory and another client holds a directory delegation for that directory, then if enabled, asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_DIR_ATTRS will be sent to the appropriate client(s), but the SETATTR is not delayed by waiting for these notifications to be sent.",
      "ja": "属性が設定されているオブジェクトがディレクトリであり、別のクライアントはそのディレクトリのディレクトリ委任を保持している場合、変更された場合、変更された一連の属性に属が非NULLの交差がある場合には非同期通知が生成されます。通知が要求されます。Type Notify4_Change_DIR_ATTRの通知は適切なクライアントに送信されますが、SetAttrはこれらの通知を送信するのを待つことによって遅延されません。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being set is a member of the directory for which another client holds a directory delegation, then asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_CHILD_ATTRS will be sent to the appropriate clients, but the SETATTR is not delayed by waiting for these notifications to be sent.",
      "ja": "属性が設定されているオブジェクトが、別のクライアントがディレクトリの委任を保持するディレクトリのメンバーである場合は、変更された属性のセットがNULL以外の交差がある場合に、非同期通知が生成されます。要求されました。Type Notify4_Change_Child_Attrの通知は適切なクライアントに送信されますが、SetAttrはこれらの通知を送信するのを待つことによって遅延されません。"
    },
    {
      "indent": 3,
      "text": "Changing the size of a file with SETATTR indirectly changes the time_modify and change attributes. A client must account for this as size changes can result in data deletion.",
      "ja": "setAttrを使用してファイルのサイズを変更すると、属性の変更と変更属性を間接的に変更します。サイズの変更がデータの削除をもたらす可能性があるため、クライアントはこれを説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.",
      "ja": "属性time_access_setおよびtime_modify_setは、スイッチド共和体として構築された書き込み専用属性であるため、クライアントがサーバーに時間値を設定する際にサーバーに指示できます。交換された共用体がset_to_client_time4を指定した場合、クライアントは操作に使用されるNFSTime4を提供しました。スイッチUNIONがset_to_client_time4を指定しない場合、サーバーはSETATTR操作に現在の時間を使用することです。"
    },
    {
      "indent": 3,
      "text": "If server and client times differ, programs that compare client time to file times can break. A time synchronization protocol should be used to limit client/server time skew.",
      "ja": "サーバーとクライアントの時間が異なる場合は、クライアントタイムをファイルタイムに比較するプログラムが破損する可能性があります。時間同期プロトコルを使用して、クライアント/サーバーの時間スキューを制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFSv3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFSv4 emulation. Therefore, NFSv4.1 servers SHOULD take care to avoid such delays, to the degree possible, when executing such a request.",
      "ja": "変更属性のみを指定することを含む検証操作を含む化合物の使用は、その後にSETATTRを続けることで、クライアントがNFSV3のSetAttrガードメカニズムの機能をエミュレートする要求を指定できる手段を提供します。ガードメカニズムの機能は古い情報に基づいてファイル属性の変更を回避することであるため、NFSV4エミュレーションの対応する遅延がこの関数の侵入を招く可能性があるため、この関数を侵害する可能性があります。。したがって、このような要求を実行するときに、このような遅延を回避するようにNFSV4.1サーバーを注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server does not support an attribute as requested by the client, the server SHOULD return NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバーがクライアントから要求された属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOWPPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "A mask of the attributes actually set is returned by SETATTR in all cases. That mask MUST NOT include attribute bits not requested to be set by the client. If the attribute masks in the request and reply are equal, the status field in the reply MUST be NFS4_OK.",
      "ja": "実際に設定されている属性のマスクは、すべての場合においてsetAttrによって返されます。そのマスクには、クライアントによって設定されていない属性ビットを含める必要がありません。要求と応答内の属性マスクが等しい場合、応答内のステータスフィールドはNFS4_OKでなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.31. Operation 37: VERIFY - Verify Same Attributes",
      "section_title": true,
      "ja": "18.31. 操作37：検証 - 同じ属性を確認します"
    },
    {
      "indent": 0,
      "text": "18.31.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.31.1. 議論"
    },
    {
      "indent": 3,
      "text": "struct VERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.31.2. RESULTS",
      "section_title": true,
      "ja": "18.31.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct VERIFY4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.31.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.31.3. description"
    },
    {
      "indent": 3,
      "text": "The VERIFY operation is used to verify that attributes have the value assumed by the client before proceeding with the following operations in the COMPOUND request. If any of the attributes do not match, then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.",
      "ja": "検証操作は、複合要求で次の操作を進める前に、属性がクライアントによって想定されている値を持つことを確認するために使用されます。いずれかの属性が一致しない場合は、エラーNFS4ERR_NOT_SAMEを返す必要があります。現在のファイルハンドルは、操作が成功した後にその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.31.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.31.4. 実装"
    },
    {
      "indent": 3,
      "text": "One possible use of the VERIFY operation is the following series of operations. With this, the client is attempting to verify that the file being removed will match what the client expects to be removed. This series can help prevent the unintended deletion of a file.",
      "ja": "検証動作の1つの可能な使用は、以下の一連の動作である。これにより、クライアントは削除されているファイルがクライアントが削除される予定のものと一致することを確認しようとしています。このシリーズは、ファイルの意図しない削除を防ぐのに役立ちます。"
    },
    {
      "indent": 9,
      "text": "PUTFH (directory filehandle) LOOKUP (file name) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (file name)",
      "ja": "PUTFH（ディレクトリファイルハンドル）ルックアップ（ファイル名）検証（FileHandle == FH）PUTFH（ディレクトリファイルハンドル）削除（ファイル名）"
    },
    {
      "indent": 3,
      "text": "This series does not prevent a second client from removing and creating a new file in the middle of this sequence, but it does help avoid the unintended result.",
      "ja": "このシリーズでは、このシーケンスの途中で2番目のクライアントが新しいファイルを削除して作成するのを妨げませんが、意図しない結果を回避するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.",
      "ja": "検証操作で推奨される属性が指定され、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.",
      "ja": "属性RDATTR_ERRORまたは任意のセット専用属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.32. Operation 38: WRITE - Write to File",
      "section_title": true,
      "ja": "18.32. 操作38：書き込み - ファイルへの書き込み"
    },
    {
      "indent": 0,
      "text": "18.32.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.32.1. 議論"
    },
    {
      "indent": 3,
      "text": "enum stable_how4 {\n        UNSTABLE4       = 0,\n        DATA_SYNC4      = 1,\n        FILE_SYNC4      = 2\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct WRITE4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        stable_how4     stable;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.32.2. RESULTS",
      "section_title": true,
      "ja": "18.32.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct WRITE4resok {\n        count4          count;\n        stable_how4     committed;\n        verifier4       writeverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union WRITE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         WRITE4resok    resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.32.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.32.3. description"
    },
    {
      "indent": 3,
      "text": "The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of zero specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is zero, the WRITE will succeed and return a count of zero subject to permissions checking. The server MAY write fewer bytes than requested by the client.",
      "ja": "書き込み操作は、通常のファイルにデータを書き込むために使用されます。ターゲットファイルは現在のFileHandleによって指定されます。オフセットは、データが書き込まれるべきオフセットを指定します。ゼロのオフセットは、書き込みがファイルの先頭から始まるように指定されます。不透明データパラメータの一部としてエンコードされたカウントは、書き込まれるデータのバイト数を表します。カウントがゼロの場合、書き込みは成功し、許可検査の対象となるゼロのカウントを返します。サーバーは、クライアントによって要求されたよりも少ないバイトを書くことができます。"
    },
    {
      "indent": 3,
      "text": "The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server MUST commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFSv2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server MUST commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of writeverf and that it will not commit the data and metadata at a level less than that requested by the client.",
      "ja": "クライアントは、安定したパラメータを使用して、データがサーバーによって処理される方法の方法です。 STABLEがfile_sync4の場合、サーバーは結果を返す前に、書き込まれたデータに安定したストレージにデータをコミットする必要があります。これはNFSV2プロトコルセマンティクスに対応しています。その他の動作はプロトコル違反を構成します。 STABLEがDATA_SYNC4の場合、サーバーはすべてのデータを安定したストレージにコミットする必要があり、データを取得する前にデータを取得する必要があります。サーバー実装者は、file_sync4と同じファッションでデータを自由に実装できますが、パフォーマンスが低下します。安定していない場合は、クライアントに返信を返す前に、サーバーはデータの一部とメタデータを安定したストレージにコミットすることができます。未送信のデータがその後安定したストレージにコミットされるかどうかを保証することはありません。サーバーによって行われた唯一の保証は、WriteVerfの値を変更せずにデータを破棄しないことであり、クライアントから要求されたものよりも小さいレベルでデータとメタデータをコミットしないことです。"
    },
    {
      "indent": 3,
      "text": "Except when special stateids are used, the stateid value for a WRITE request represents a value returned from a previous byte-range LOCK or OPEN request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).",
      "ja": "特別なStateIDが使用されている場合、書き込み要求のStateID値は、前のバイトレンジロックまたはオープン要求または委任に関連付けられているStareIDから返される値を表します。StateIDは、関連するロックがまだ有効であることを確認するためにサーバーによって関連付けられている場合は関連する所有者を識別します（たとえば、失効していません）。"
    },
    {
      "indent": 3,
      "text": "Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.",
      "ja": "完了成功すると、次の結果が返されます。カウント結果は、ファイルに書き込まれたデータのバイト数です。サーバーは要求されたよりも少ないバイトを書くことができます。もしそうであれば、場所から始まる実際のバイト数が返されます。"
    },
    {
      "indent": 3,
      "text": "The server also returns an indication of the level of commitment of the data and metadata via committed. Per Table 20,",
      "ja": "サーバーは、コミットされたデータとメタデータのコミットメントレベルの表示も返します。表20にて、"
    },
    {
      "indent": 3,
      "text": "* The server MAY commit the data at a stronger level than requested.",
      "ja": "* サーバーは、要求されたよりも強いレベルでデータをコミットできます。"
    },
    {
      "indent": 3,
      "text": "* The server MUST commit the data at a level at least as high as that committed.",
      "ja": "* サーバーは、少なくともコミットされたものほど高いレベルのレベルでデータをコミットする必要があります。"
    },
    {
      "indent": 12,
      "text": "+============+===================================+\n| stable     | committed                         |\n+============+===================================+\n| UNSTABLE4  | FILE_SYNC4, DATA_SYNC4, UNSTABLE4 |\n+------------+-----------------------------------+\n| DATA_SYNC4 | FILE_SYNC4, DATA_SYNC4            |\n+------------+-----------------------------------+\n| FILE_SYNC4 | FILE_SYNC4                        |\n+------------+-----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 20: Valid Combinations of the Fields Stable in the Request and Committed in the Reply",
      "ja": "表20：リクエストで安定したフィールドの有効な組み合わせと返信でコミット"
    },
    {
      "indent": 3,
      "text": "The final portion of the result is the field writeverf. This field is the write verifier and is a cookie that the client can use to determine whether a server has changed instance state (e.g., server restart) between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie MUST be unchanged during a single instance of the NFSv4.1 server and MUST be unique between instances of the NFSv4.1 server. If the cookie changes, then the client MUST assume that any data written with an UNSTABLE4 value for committed and an old writeverf in the reply has been lost and will need to be recovered.",
      "ja": "結果の最後の部分はフィールドWriteVerfです。このフィールドはWrite Verifierであり、クライアントがサーバーが書き込みの呼び出しと書き込みまたはコミットのどちらの呼び出しを呼び出すかの間でサーバーがインスタンス状態（例えばサーバーの再起動）を変更したかどうかを判断するために使用できるクッキーです。このCookieは、NFSV4.1サーバーの単一のインスタンス中に変更されず、NFSV4.1サーバーのインスタンス間で一意である必要があります。クッキーが変更された場合、クライアントは、コミットされた不安定な値で書かれたデータと返信の古いWRITEVERFが失われていると仮定し、回復する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server's stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.",
      "ja": "クライアントが安定した引数をUNSTABLE4に設定してデータをサーバーに書き込み、応答はDATA_SYNC4またはUNSTABLE4のコミットされた応答を生成します。クライアントは、将来、未解決の非同期データとメタデータを同期させるためのコミット操作を使用して、将来的にはしばらく追従します。サーバーの安定したストレージ、クライアントエラーを除去します。クライアントクラッシュやその他のエラーがサーバーによって受信されないことが可能です。"
    },
    {
      "indent": 3,
      "text": "For a WRITE with a stateid value of all bits equal to zero, the server MAY allow the WRITE to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a WRITE with a stateid value of all bits equal to 1, the server MUST NOT allow the WRITE operation to bypass locking checks at the server and otherwise is treated as if a stateid of all bits equal to zero were used.",
      "ja": "ゼロに等しいすべてのビットのStateID値を使用した書き込みの場合、サーバーは、書き込みを必須のバイトレンジロックまたはファイルの現在の共有拒否モードを受けることを可能にします。1に等しいすべてのビットのSTATEID値を使用した書き込みの場合、サーバーはサーバーでロックチェックをバイパスすることを許可してはならず、そうでなければゼロに等しいすべてのビットのStateIDを使用したかのように扱われます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.32.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.32.4. 実装"
    },
    {
      "indent": 3,
      "text": "It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server SHOULD NOT return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client will need to send another WRITE to write the remaining data.",
      "ja": "サーバーがクライアントから要求されたよりも少ないデータのデータを書き込むことが可能です。この場合、データがまったく書き込まれていない限り、サーバーはエラーを返さないでください。サーバーが指定されたバイト数未満の場合、クライアントは残りのデータを書き込むために別の書き込みを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the act of writing data to a file will cause the time_modified and change attributes of the file to be updated. However, these attributes SHOULD NOT be changed unless the contents of the file are changed. Thus, a WRITE request with count set to zero SHOULD NOT cause the time_modified and change attributes of the file to be updated.",
      "ja": "ファイルにデータを書き込む行為は、ファイルのtime_modifiedおよび変更属性を更新すると仮定する。ただし、ファイルの内容が変更されていない限り、これらの属性を変更しないでください。したがって、カウントセットをゼロに設定したライト要求は、ファイルのtime_modifiedおよび変更属性を更新することはできません。"
    },
    {
      "indent": 3,
      "text": "Stable storage is persistent storage that survives:",
      "ja": "安定したストレージは生き残る永続的な記憶域です。"
    },
    {
      "indent": 3,
      "text": "1. Repeated power failures.",
      "ja": "1. 給電の故障を繰り返します。"
    },
    {
      "indent": 3,
      "text": "2. Hardware failures (of any board, power supply, etc.).",
      "ja": "2. ハードウェアの障害（任意のボード、電源など）。"
    },
    {
      "indent": 3,
      "text": "3. Repeated software crashes and restarts.",
      "ja": "3. 繰り返しソフトウェアがクラッシュして再起動します。"
    },
    {
      "indent": 3,
      "text": "This definition does not address failure of the stable storage module itself.",
      "ja": "この定義は安定した記憶モジュール自体の障害に対処しません。"
    },
    {
      "indent": 3,
      "text": "The verifier is defined to allow a client to detect different instances of an NFSv4.1 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server restarts. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well), the server might not have flushed cached data to stable storage. The burden of recovery is on the client, and the client will need to retransmit the data to the server.",
      "ja": "検証者は、クライアントがキャッシュされていないデータが失われる可能性があるNFSv4.1プロトコルサーバーのさまざまなインスタンスを検出できるように定義されています。最も可能性の高い場合では、検証者はクライアントがサーバーの再起動を検出することを可能にします。この情報は、クライアントがサーバーがキャッシュされたデータを失った可能性があるかどうかを安全に判断できるようにする必要があります。サーバーが予期せずに失敗し、クライアントが以前の書き込み要求からのコミットされていないデータを持っている場合（安定した引数をUNSTABLE4に設定され、結果が不安定な4としてコミットされた結果が実行されていません）、サーバーに安定したストレージへのフラッシュされたデータが含まれていない可能性があります。回復の負担はクライアント上にあり、クライアントはデータをサーバーに再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A suggested verifier would be to use the time that the server was last started (if restarting the server results in lost buffers).",
      "ja": "推奨される検証者は、サーバーが最後に起動された時刻を使用することです（サーバーが失われたバッファを再起動する場合）。"
    },
    {
      "indent": 3,
      "text": "The reply's committed field allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it SHOULD return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.",
      "ja": "返信のコミットフィールドを使用すると、クライアントはより効果的なキャッシュを行うことができます。サーバーがすべての書き込み要求を安定したストレージにコミットしている場合は、引数内の安定フィールドの値に関係なく、File_Sync4にコミットされたセットで戻る必要があります。NVRAMアクセラレータを使用するサーバーは、このポリシーを実装することを選択できます。クライアントはこれを使用して、サーバー上ですでにコミットされているキャッシュデータを破棄することによってキャッシュの有効性を高めることができます。"
    },
    {
      "indent": 3,
      "text": "Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user's quota is exceeded.",
      "ja": "一部の実装は、ユーザーのクォータを超えたときにNFS4ERR_DQUOTの代わりにNFS4ERR_NOSPCを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "In the case that the current filehandle is of type NF4DIR, the server will return NFS4ERR_ISDIR. If the current file is a symbolic link, the error NFS4ERR_SYMLINK will be returned. Otherwise, if the current filehandle does not designate an ordinary file, the server will return NFS4ERR_WRONG_TYPE.",
      "ja": "現在のファイルハンドルがNF4DIR型の場合、サーバーはNFS4ERR_ISDIRを返します。現在のファイルがシンボリックリンクの場合、エラーNFS4ERR_SYMLINKが返されます。それ以外の場合、現在のファイルハンドルが通常のファイルを指定しない場合、サーバーはNFS4ERR_WRONG_TYPEを返します。"
    },
    {
      "indent": 3,
      "text": "If mandatory byte-range locking is in effect for the file, and the corresponding byte-range of the data to be written to the file is READ_LT or WRITE_LT locked by an owner that is not associated with the stateid, the server MUST return NFS4ERR_LOCKED. If so, the client MUST check if the owner corresponding to the stateid used with the WRITE operation has a conflicting READ_LT lock that overlaps with the byte-range that was to be written. If the stateid's owner has no conflicting READ_LT lock, then the client SHOULD try to get the appropriate write byte-range lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client SHOULD release the byte-range lock via LOCKU.",
      "ja": "必須バイトレンジロックがファイルに有効で、ファイルに書き込まれるデータの対応するバイト範囲は、stateIDに関連付けられていない所有者によってロックされているREAD_LTまたはWRITE_LTの場合、サーバーはNFS4ERR_LOCKEDを返す必要があります。もしそうであれば、クライアントは、書き込み操作で使用されるStateIDに対応する所有者に、書き込まれるバイト範囲と重なる矛盾するREAD_LTロックがあるかどうかを確認する必要があります。StateIDの所有者に矛盾するREAD_LTロックがない場合、クライアントは書き込みを再試行する前にロック操作を介して適切な書き込みバイトレンジロックを取得しようとする必要があります。書き込みが完了すると、クライアントはLockuを介してバイトレンジロックを解除する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the stateid's owner had a conflicting READ_LT lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid's owner had a READ_LT lock, either the server attempted to temporarily effectively upgrade this READ_LT lock to a WRITE_LT lock or the server has no upgrade capability. If the server attempted to upgrade the READ_LT lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying to upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.",
      "ja": "StateIDの所有者が矛盾するREAD_LTロックを持っていた場合、クライアントには書き込みを試みたアプリケーションにエラーが返されます。その理由は、StateIDの所有者がREAD_LTロックを持っていたため、サーバーはこのREAD_LTロックをWRITE_LTロックに一時的に効果的にアップグレードしようとしたか、サーバーにアップグレード機能がないことです。サーバーがREAD_LTロックをアップグレードしようとした場合、クライアントがロック操作を介してアップグレードを再試行するのは、クライアントが無効にしてもらうこともあります。2つのクライアントが同じロックをアップグレードしようとしているブロックされている場合、クライアントはデッドロックします。サーバーにアップグレード機能がない場合は、アップグレードするロック操作を試してください。"
    },
    {
      "indent": 3,
      "text": "If one or more other clients have delegations for the file being written, those delegations MUST be recalled, and the operation cannot proceed until those delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a WRITE operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a WRITE to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.",
      "ja": "1つ以上の他のクライアントが書き込まれているファイルの代行がある場合は、それらの代表録を呼び出す必要があり、それらの委任が返されるか取り消されるまで操作は続行できません。これが非常に早く起こる場合を除き、委任が未解決のままである間、1つ以上のNFS4ERR_DELAYエラーが要求された要求に返されます。通常、録音が早く開かれた結果として呼び出されるため、書き込み動作の結果として委任は呼び出されません。ただし、特別なStareIDで書き込みを行うことが可能であるため、クライアントが以前に開いていたが、この場合はサーバはチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control",
      "section_title": true,
      "ja": "18.33. 操作40：backchannel_ctl  -  BackChannel Control"
    },
    {
      "indent": 0,
      "text": "18.33.1. ARGUMENT",
      "section_title": true,
      "ja": "18.33.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef opaque gsshandle4_t<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct gss_cb_handles4 {\n        rpc_gss_svc_t           gcbp_service; /* RFC 2203 */\n        gsshandle4_t            gcbp_handle_from_server;\n        gsshandle4_t            gcbp_handle_from_client;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union callback_sec_parms4 switch (uint32_t cb_secflavor) {\ncase AUTH_NONE:\n        void;\ncase AUTH_SYS:\n        authsys_parms   cbsp_sys_cred; /* RFC 5531 */\ncase RPCSEC_GSS:\n        gss_cb_handles4 cbsp_gss_handles;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct BACKCHANNEL_CTL4args {\n        uint32_t                bca_cb_program;\n        callback_sec_parms4     bca_sec_parms<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.33.2. RESULT",
      "section_title": true,
      "ja": "18.33.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct BACKCHANNEL_CTL4res {\n        nfsstat4                bcr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.33.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.33.3. description"
    },
    {
      "indent": 3,
      "text": "The BACKCHANNEL_CTL operation replaces the backchannel's callback program number and adds (not replaces) RPCSEC_GSS handles for use by the backchannel.",
      "ja": "backchannel_ctl操作はBackChannelのコールバックプログラム番号を置き換え、BackChannelが使用するためのRPCSEC_GSSハンドルを追加します。"
    },
    {
      "indent": 3,
      "text": "The arguments of the BACKCHANNEL_CTL call are a subset of the CREATE_SESSION parameters. In the arguments of BACKCHANNEL_CTL, the bca_cb_program field and bca_sec_parms fields correspond respectively to the csa_cb_program and csa_sec_parms fields of the arguments of CREATE_SESSION (Section 18.36).",
      "ja": "backchannel_ctl呼び出しの引数はcreate_sessionパラメータのサブセットです。backchannel_ctlの引数では、BCA_CB_PROGRAMフィールドとBCA_SEC_PARMSフィールドは、CREATE_SESSIONの引数のCSA_CB_PROGRAMSおよびCSA_SEC_PARMSフィールドにそれぞれ対応します（セクション18.36）。"
    },
    {
      "indent": 3,
      "text": "BACKCHANNEL_CTL MUST appear in a COMPOUND that starts with SEQUENCE.",
      "ja": "backchannel_ctlは、シーケンスで始まる化合物に表示されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server MUST return NFS4ERR_NOENT.",
      "ja": "gcbp_handle_from_serverによって識別されたRPCSEC_GSSハンドルがサーバー上に存在しない場合、サーバーはNFS4ERR_NOENTを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "RPCSEC_GSS HandleがSSVコンテキストを使用している場合（セクション2.10.9を参照）、各SSV RPCSEC_GSSSは共通のSSV GSSコンテキストを共有しているため、セクション2.10.10で説明したこの状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 0,
      "text": "18.34. Operation 41: BIND_CONN_TO_SESSION - Associate Connection with Session",
      "ja": "18.34. 操作41：bind_conn_to_session  - セッションとの関連付けを関連付けます"
    },
    {
      "indent": 0,
      "text": "18.34.1. ARGUMENT",
      "section_title": true,
      "ja": "18.34.1. 引数"
    },
    {
      "indent": 3,
      "text": "enum channel_dir_from_client4 {\n CDFC4_FORE             = 0x1,\n CDFC4_BACK             = 0x2,\n CDFC4_FORE_OR_BOTH     = 0x3,\n CDFC4_BACK_OR_BOTH     = 0x7\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct BIND_CONN_TO_SESSION4args {\n sessionid4     bctsa_sessid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "channel_dir_from_client4 bctsa_dir;",
      "ja": "channel_dir_from_client4 bctsa_dir;"
    },
    {
      "indent": 3,
      "text": " bool           bctsa_use_conn_in_rdma_mode;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.34.2. RESULT",
      "section_title": true,
      "ja": "18.34.2. 結果"
    },
    {
      "indent": 3,
      "text": "enum channel_dir_from_server4 {\n CDFS4_FORE     = 0x1,\n CDFS4_BACK     = 0x2,\n CDFS4_BOTH     = 0x3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct BIND_CONN_TO_SESSION4resok {\n sessionid4     bctsr_sessid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "channel_dir_from_server4 bctsr_dir;",
      "ja": "channel_dir_from_server4 bctsr_dir;"
    },
    {
      "indent": 3,
      "text": " bool           bctsr_use_conn_in_rdma_mode;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union BIND_CONN_TO_SESSION4res switch (nfsstat4 bctsr_status) {",
      "ja": "UNION BIND_CONN_TO_SESSION4RESスイッチ（NFSSTAT4 BCTSR_STATUS）{"
    },
    {
      "indent": 4,
      "text": "case NFS4_OK: BIND_CONN_TO_SESSION4resok bctsr_resok4;",
      "ja": "ケースNFS4_OK：bind_conn_to_session4resok bctsr_resok4;"
    },
    {
      "indent": 3,
      "text": " default:       void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.34.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.34.3. description"
    },
    {
      "indent": 3,
      "text": "BIND_CONN_TO_SESSION is used to associate additional connections with a session. It MUST be used on the connection being associated with the session. It MUST be the only operation in the COMPOUND procedure. If SP4_NONE (Section 18.35) state protection is used, any principal, security flavor, or RPCSEC_GSS context MAY be used to invoke the operation. If SP4_MACH_CRED is used, RPCSEC_GSS MUST be used with the integrity or privacy services, using the principal that created the client ID. If SP4_SSV is used, RPCSEC_GSS with the SSV GSS mechanism (Section 2.10.9) and integrity or privacy MUST be used.",
      "ja": "BIND_CONN_TO_SESSIONは、追加の接続をセッションと関連付けるために使用されます。セッションに関連付けられている接続で使用する必要があります。複合手順の唯一の操作でなければなりません。sp4_none（18.35節）の状態保護が使用されている場合、任意のプリンシパル、セキュリティフレーバー、またはRPCSEC_GSSコンテキストを使用して操作を呼び出すことができます。SP4_MACH_CREDが使用されている場合、クライアントIDを作成したプリンシパルを使用して、rpcsec_gssを整合性またはプライバシーサービスで使用する必要があります。SP4_SSVが使用されている場合、SSV GSSメカニズム（セクション2.10.9）と整合性またはプライバシーを持つRPCSEC_GSSを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If, when the client ID was created, the client opted for SP4_NONE state protection, the client is not required to use BIND_CONN_TO_SESSION to associate the connection with the session, unless the client wishes to associate the connection with the backchannel. When SP4_NONE protection is used, simply sending a COMPOUND request with a SEQUENCE operation is sufficient to associate the connection with the session specified in SEQUENCE.",
      "ja": "クライアントIDが作成されたとき、クライアントはSP4_NONE状態保護を選択した場合、クライアントがバックチャネルとの接続を関連付けることを望まない限り、クライアントはBIND_CONN_TO_SESSIONを使用してセッションとの接続を関連付ける必要はありません。SP4_NONE保護が使用されるとき、シーケンス操作で複合要求を送信するだけで、順番に指定されたセッションとの接続を関連付けるのに十分です。"
    },
    {
      "indent": 3,
      "text": "The field bctsa_dir indicates whether the client wants to associate the connection with the fore channel or the backchannel or both channels. The value CDFC4_FORE_OR_BOTH indicates that the client wants to associate the connection with both the fore channel and backchannel, but will accept the connection being associated to just the fore channel. The value CDFC4_BACK_OR_BOTH indicates that the client wants to associate with both the fore channel and backchannel, but will accept the connection being associated with just the backchannel. The server replies in bctsr_dir which channel(s) the connection is associated with. If the client specified CDFC4_FORE, the server MUST return CDFS4_FORE. If the client specified CDFC4_BACK, the server MUST return CDFS4_BACK. If the client specified CDFC4_FORE_OR_BOTH, the server MUST return CDFS4_FORE or CDFS4_BOTH. If the client specified CDFC4_BACK_OR_BOTH, the server MUST return CDFS4_BACK or CDFS4_BOTH.",
      "ja": "フィールドBCTSA_DIRは、クライアントがその接続を前チャネルまたはバックチャンネルまたは両方のチャンネルと関連付けることを望んでいるかどうかを示します。値cdfc4_fore_or_bothは、クライアントが先頭チャネルとバックチャネルの両方との接続を関連付けることを示していますが、前のチャネルだけに関連付けられている接続を受け入れます。値CDFC4_BACK_OR_BOTSは、クライアントがFore ChannelとBackChannelの両方に関連付けることを示しますが、バックチャネルだけに関連付けられている接続を受け入れます。サーバーは、接続が関連付けられているチャネルがどのチャンネルに関連付けられているかをBCTSR_DIRに返信します。クライアントがCDFC4_FOREを指定した場合、サーバーはCDFS4_FOREを返す必要があります。クライアントがCDFC4_BACKを指定した場合、サーバーはCDFS4_BACKを返す必要があります。クライアントがcdfc4_fore_or_bothの場合、サーバーはCDFS4_FOREまたはCDFS4_BOTHを返す必要があります。クライアントがCDFC4_BACK_OR_BOTHを指定した場合、サーバーはCDFS4_BACKまたはCDFS4_BOTHを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "See the CREATE_SESSION operation (Section 18.36), and the description of the argument csa_use_conn_in_rdma_mode to understand bctsa_use_conn_in_rdma_mode, and the description of csr_use_conn_in_rdma_mode to understand bctsr_use_conn_in_rdma_mode.",
      "ja": "BCTSA_USE_CONN_IN_RDMA_MODEを理解するためのcreate_session操作（セクション18.36）、および引数csa_use_conn_in_rdma_mode、およびbctsr_use_conn_in_rdma_modeを理解するためのCSR_USE_CONN_IN_RDMA_MODEの説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "Invoking BIND_CONN_TO_SESSION on a connection already associated with the specified session has no effect, and the server MUST respond with NFS4_OK, unless the client is demanding changes to the set of channels the connection is associated with. If so, the server MUST return NFS4ERR_INVAL.",
      "ja": "指定されたセッションに既に関連付けられている接続でBIND_CONN_TO_SESSISTを呼び出すことは効果があり、クライアントがConnectionが関連付けられているチャンネルのセットに変更が要求されていない限り、サーバーはNFS4_OKで応答する必要があります。もしそうなら、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "18.34.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.34.4. 実装"
    },
    {
      "indent": 3,
      "text": "If a session's channel loses all connections, depending on the client ID's state protection and type of channel, the client might need to use BIND_CONN_TO_SESSION to associate a new connection. If the server restarted and does not keep the reply cache in stable storage, the server will not recognize the session ID. The client will ultimately have to invoke EXCHANGE_ID to create a new client ID and session.",
      "ja": "セッションのチャンネルがすべての接続を失うと、クライアントIDの状態保護とチャネルの種類に応じて、クライアントは新しい接続を関連付けるためにBIND_CONN_TO_SESSIONを使用する必要があるかもしれません。サーバーが再起動され、返信キャッシュを安定したストレージに保持しない場合、サーバーはセッションIDを認識しません。クライアントは最終的にExchange_IDを呼び出して新しいクライアントIDとセッションを作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose SP4_SSV state protection is being used, and BIND_CONN_TO_SESSION is among the operations included in the spo_must_enforce set when the client ID was created (Section 18.35). If so, there is an issue if SET_SSV is sent, no response is returned, and the last connection associated with the client ID drops. The client, per the sessions model, MUST retry the SET_SSV. But it needs a new connection to do so, and MUST associate that connection with the session via a BIND_CONN_TO_SESSION authenticated with the SSV GSS mechanism. The problem is that the RPCSEC_GSS message integrity codes use a subkey derived from the SSV as the key and the SSV may have changed. While there are multiple recovery strategies, a single, general strategy is described here.",
      "ja": "SP4_SSV状態保護が使用されているとすると、BIND_CONN_TO_SESSIONは、クライアントIDが作成されたときに設定されたSPO_MUST_ENFORCEに含まれる操作の中にある（セクション18.35）。もしそうであれば、set_ssvが送信された場合、応答は返されず、クライアントIDに関連付けられている最後の接続がドロップされます。セッションモデルごとのクライアントは、set_ssvを再試行する必要があります。しかし、それはそれを行うために新しい接続を必要とし、そしてSSV GSSメカニズムで認証されたbind_conn_to_sessionを介してその接続をセッションに関連付ける必要があります。問題は、rpcsec_gssメッセージ整合性コードがキーとしてSSVから派生したサブキーを使用し、SSVが変更された可能性があります。複数の回復戦略があるが、単一の一般的な戦略がここに記載されている。"
    },
    {
      "indent": 3,
      "text": "* The client reconnects.",
      "ja": "* クライアントが再接続します。"
    },
    {
      "indent": 3,
      "text": "* The client assumes that the SET_SSV was executed, and so sends BIND_CONN_TO_SESSION with the subkey (derived from the new SSV, i.e., what SET_SSV would have set the SSV to) used as the key for the RPCSEC_GSS credential message integrity codes.",
      "ja": "* クライアントはSET_SSVが実行されたことを前提としているため、rpcsec_gssクレデンシャルメッセージ整合性コードのキーとして使用されている副作用（SET_SSVから派生したものは、SESVをSSVをSSVに設定した場合）にbind_conn_to_sessionを送信します。"
    },
    {
      "indent": 3,
      "text": "* If the request succeeds, this means that the original attempted SET_SSV did execute successfully. The client re-sends the original SET_SSV, which the server will reply to via the reply cache.",
      "ja": "* 要求が成功した場合、これは元の試行されたset_ssvが正常に実行されたことを意味します。クライアントは元のset_ssvを再送信します。これは、サーバーが返信キャッシュを介して返信します。"
    },
    {
      "indent": 3,
      "text": "* If the server returns an RPC authentication error, this means that the server's current SSV was not changed (and the SET_SSV was likely not executed). The client then tries BIND_CONN_TO_SESSION with the subkey derived from the old SSV as the key for the RPCSEC_GSS message integrity codes.",
      "ja": "* サーバーがRPC認証エラーを返す場合、これはサーバーの現在のSSVが変更されなかったことを意味します（そしてSET_SSVは実行されない可能性があります）。その後、クライアントは、RPCSEC_GSSメッセージ整合性コードのキーとして、古いSSVから派生したサブキーを使用してBIND_CONN_TO_SESSIONを実行します。"
    },
    {
      "indent": 3,
      "text": "* The attempted BIND_CONN_TO_SESSION with the old SSV should succeed. If so, the client re-sends the original SET_SSV. If the original SET_SSV was not executed, then the server executes it. If the original SET_SSV was executed but failed, the server will return the SET_SSV from the reply cache.",
      "ja": "* 古いSSVを使用したBIND_CONN_TO_SESSIONを試みたはずです。もしそうなら、クライアントは元のset_ssvを再送信します。元のset_ssvが実行されなかった場合、サーバーはそれを実行します。元のset_ssvが実行されたが失敗した場合、サーバーは応答キャッシュからset_ssvを返します。"
    },
    {
      "indent": 0,
      "text": "18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID",
      "section_title": true,
      "ja": "18.35. 操作42：Exchange_ID  - クライアントIDをインスタンス化します"
    },
    {
      "indent": 3,
      "text": "The EXCHANGE_ID operation exchanges long-hand client and server identifiers (owners) and provides access to a client ID, creating one if necessary. This client ID becomes associated with the connection on which the operation is done, so that it is available when a CREATE_SESSION is done or when the connection is used to issue a request on an existing session associated with the current client.",
      "ja": "Exchange_ID操作は、ロングハンドクライアントとサーバー識別子（所有者）を交換し、必要に応じて1つを作成してクライアントIDへのアクセスを提供します。このクライアントIDは、操作が行われた接続に関連付けられているため、CREATE_SESSIONが行われたとき、または接続が現在のクライアントに関連付けられている既存のセッションで要求を発行するときに使用可能になります。"
    },
    {
      "indent": 0,
      "text": "18.35.1. ARGUMENT",
      "section_title": true,
      "ja": "18.35.1. 引数"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_SUPP_MOVED_REFER    = 0x00000001;\nconst EXCHGID4_FLAG_SUPP_MOVED_MIGR     = 0x00000002;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_BIND_PRINC_STATEID = 0x00000100;",
      "ja": "const exchgid4_flag_bind_princ_stateId = 0x00000100;"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_USE_NON_PNFS        = 0x00010000;\nconst EXCHGID4_FLAG_USE_PNFS_MDS        = 0x00020000;\nconst EXCHGID4_FLAG_USE_PNFS_DS         = 0x00040000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_MASK_PNFS = 0x00070000;",
      "ja": "const exchgid4_flag_mask_pnfs = 0x00070000;"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_UPD_CONFIRMED_REC_A = 0x40000000;\nconst EXCHGID4_FLAG_CONFIRMED_R         = 0x80000000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct state_protect_ops4 {\n        bitmap4 spo_must_enforce;\n        bitmap4 spo_must_allow;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ssv_sp_parms4 {\n        state_protect_ops4      ssp_ops;\n        sec_oid4                ssp_hash_algs<>;\n        sec_oid4                ssp_encr_algs<>;\n        uint32_t                ssp_window;\n        uint32_t                ssp_num_gss_handles;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum state_protect_how4 {\n        SP4_NONE = 0,\n        SP4_MACH_CRED = 1,\n        SP4_SSV = 2\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union state_protect4_a switch(state_protect_how4 spa_how) {\n        case SP4_NONE:\n                void;\n        case SP4_MACH_CRED:\n                state_protect_ops4      spa_mach_ops;\n        case SP4_SSV:\n                ssv_sp_parms4           spa_ssv_parms;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct EXCHANGE_ID4args {\n        client_owner4           eia_clientowner;\n        uint32_t                eia_flags;\n        state_protect4_a        eia_state_protect;\n        nfs_impl_id4            eia_client_impl_id<1>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.35.2. RESULT",
      "section_title": true,
      "ja": "18.35.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ssv_prot_info4 {\n state_protect_ops4     spi_ops;\n uint32_t               spi_hash_alg;\n uint32_t               spi_encr_alg;\n uint32_t               spi_ssv_len;\n uint32_t               spi_window;\n gsshandle4_t           spi_handles<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union state_protect4_r switch(state_protect_how4 spr_how) {\n case SP4_NONE:\n         void;\n case SP4_MACH_CRED:\n         state_protect_ops4     spr_mach_ops;\n case SP4_SSV:\n         ssv_prot_info4         spr_ssv_info;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct EXCHANGE_ID4resok {\n clientid4        eir_clientid;\n sequenceid4      eir_sequenceid;\n uint32_t         eir_flags;\n state_protect4_r eir_state_protect;\n server_owner4    eir_server_owner;\n opaque           eir_server_scope<NFS4_OPAQUE_LIMIT>;\n nfs_impl_id4     eir_server_impl_id<1>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union EXCHANGE_ID4res switch (nfsstat4 eir_status) {\ncase NFS4_OK:\n EXCHANGE_ID4resok      eir_resok4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "default:\n void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.35.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.35.3. description"
    },
    {
      "indent": 3,
      "text": "The client uses the EXCHANGE_ID operation to register a particular instance of that client with the server, as represented by a client_owner4. However, when the client_owner4 has already been registered by other means (e.g., Transparent State Migration), the client may still use EXCHANGE_ID to obtain the client ID assigned previously.",
      "ja": "クライアントは、client_owner4によって表されるように、Exchange_ID操作を使用して、そのクライアントの特定のインスタンスをサーバーと登録します。しかしながら、CLIENT_OWNER4が既に他の手段（例えば透過状態移行）によって登録されている場合、クライアントは依然としてExchange_IDを使用して以前に割り当てられたクライアントIDを取得することができる。"
    },
    {
      "indent": 3,
      "text": "The client ID returned from this operation will be associated with the connection on which the EXCHANGE_ID is received and will serve as a parent object for sessions created by the client on this connection or to which the connection is bound. As a result of using those sessions to make requests involving the creation of state, that state will become associated with the client ID returned.",
      "ja": "この操作から返されたクライアントIDは、Exchange_IDが受信された接続に関連付けられ、この接続上のクライアントによって作成されたセッションまたは接続がバインドされているセッションの親オブジェクトとして機能します。これらのセッションを使用して、状態の作成を含む要求を作成した結果、その状態は返されたクライアントIDに関連付けられます。"
    },
    {
      "indent": 3,
      "text": "In situations in which the registration of the client_owner has not occurred previously, the client ID must first be used, along with the returned eir_sequenceid, in creating an associated session using CREATE_SESSION.",
      "ja": "CLIENT_OWNERの登録が以前に発生していない状況では、CREATE_SESSIONを使用して関連付けられたセッションを作成する際に、クライアントIDを最初に返されたEIR_SEQUENCEIDIDと共に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the flag EXCHGID4_FLAG_CONFIRMED_R is set in the result, eir_flags, then it is an indication that the registration of the client_owner has already occurred and that a further CREATE_SESSION is not needed to confirm it. Of course, subsequent CREATE_SESSION operations may be needed for other reasons.",
      "ja": "結果にフラグEXCHGID4_FLAG_CONFIRMED_Rが設定されている場合、EIR_FLAGSが設定されている場合は、CLIENT_OWNERの登録がすでに発生していること、およびそれを確認するためにさらにCREATE_SESSIONが必要であることがわかります。もちろん、その後のCreate_Session操作が他の理由で必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "The value eir_sequenceid is used to establish an initial sequence value associated with the client ID returned. In cases in which a CREATE_SESSION has already been done, there is no need for this value, since sequencing of such request has already been established, and the client has no need for this value and will ignore it.",
      "ja": "値EIR_SEQUENCEIDは、返されたクライアントIDに関連付けられた初期シーケンス値を確立するために使用されます。CREATE_SESSIONがすでに行われている場合は、このような要求のシーケンスがすでに確立されているため、この値は必要ありません。クライアントはこの値を必要とせず、それを無視します。"
    },
    {
      "indent": 3,
      "text": "EXCHANGE_ID MAY be sent in a COMPOUND procedure that starts with SEQUENCE. However, when a client communicates with a server for the first time, it will not have a session, so using SEQUENCE will not be possible. If EXCHANGE_ID is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure's request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "Exchange_IDは、シーケンスで始まる複合手順で送信されます。ただし、クライアントが初めてサーバーと通信すると、セッションはありませんので、シーケンスを使用することはできません。Exchange_IDが前のシーケンスなしで送信された場合は、複合プロシージャの要求で唯一の操作である必要があります。そうでない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The eia_clientowner field is composed of a co_verifier field and a co_ownerid string. As noted in Section 2.4, the co_ownerid identifies the client, and the co_verifier specifies a particular incarnation of that client. An EXCHANGE_ID sent with a new incarnation of the client will lead to the server removing lock state of the old incarnation. On the other hand, when an EXCHANGE_ID sent with the current incarnation and co_ownerid does not result in an unrelated error, it will potentially update an existing client ID's properties or simply return information about the existing client_id. The latter would happen when this operation is done to the same server using different network addresses as part of creating trunked connections.",
      "ja": "EIA_ClientOwnerフィールドは、CO_VERIFIERフィールドとCO_OWNERID文字列で構成されています。セクション2.4で述べたように、CO_OWNERIDはクライアントを識別し、CO_VERIFIERはそのクライアントの特定の化身を指定します。クライアントの新しい化身で送信されたExchange_idは、サーバーに旧化身のロック状態を取り除くことにつながります。一方、現在のインカンテーションとCO_OWNERIDで送信されたExchange_idが無関係のエラーになっていない場合は、既存のクライアントIDのプロパティを更新することも、既存のClient_IDに関する情報を返すこともできます。後者は、トランク接続を作成する部分とさまざまなネットワークアドレスを使用して同じサーバーに対してこの操作が行われたときに発生します。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT provide the same client ID to two different incarnations of an eia_clientowner.",
      "ja": "サーバーは、同じクライアントIDをEIA_ClientOwnerの2つの異なる化業に提供してはなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to the client ID and sequence ID, the server returns a server owner (eir_server_owner) and server scope (eir_server_scope). The former field is used in connection with network trunking as described in Section 2.10.5. The latter field is used to allow clients to determine when client IDs sent by one server may be recognized by another in the event of file system migration (see Section 11.11.9 of the current document).",
      "ja": "クライアントIDとシーケンスIDに加えて、サーバーはサーバー所有者（EIR_SERVER_OWNER）とサーバースコープ（EIR_SERVER_SCOPE）を返します。前者のフィールドは、セクション2.10.5に記載されているようにネットワークトランキングに関連して使用されます。後者のフィールドは、1つのサーバーによって送信されたクライアントIDがファイルシステムの移行の場合に別のサーバーによって認識される可能性がある場合にクライアントが決定できるようにするために使用されます（現在のドキュメントのセクション11.11.9を参照）。"
    },
    {
      "indent": 3,
      "text": "The client ID returned by EXCHANGE_ID is only unique relative to the combination of eir_server_owner.so_major_id and eir_server_scope. Thus, if two servers return the same client ID, the onus is on the client to distinguish the client IDs on the basis of eir_server_owner.so_major_id and eir_server_scope. In the event two different servers claim matching server_owner.so_major_id and eir_server_scope, the client can use the verification techniques discussed in Section 2.10.5.1 to determine if the servers are distinct. If they are distinct, then the client will need to note the destination network addresses of the connections used with each server and use the network address as the final discriminator.",
      "ja": "Exchange_IDによって返されたクライアントIDは、EIR_SERVER_OWNER.SO_MAJOR_IDとEIR_SERVER_SCOPEの組み合わせに対して一意の一意です。したがって、2つのサーバーが同じクライアントIDを返す場合、ONUはクライアント上にあり、EIR_SERVER_OWNER.SO_MAIDとEIR_SERVER_SCOPEに基づいてクライアントIDを区別します。2つの異なるサーバがServer_owner.so_MAJOR_IDとEIR_SERVER_SCOPEと一致すると主張する場合、クライアントはセクション2.10.5.1で説明されている検証技術を使用して、サーバーが異なるかどうかを判断できます。それらが異なる場合、クライアントは各サーバーで使用されている接続の宛先ネットワークアドレスに注意して、ネットワークアドレスを最終識別子として使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server, as defined by the unique identity expressed in the so_major_id of the server owner and the server scope, needs to track several properties of each client ID it hands out. The properties apply to the client ID and all sessions associated with the client ID. The properties are derived from the arguments and results of EXCHANGE_ID. The client ID properties include:",
      "ja": "サーバーの所有者のSO_MAJOR_IDで表された一意のIDによって定義されているサーバーは、それが手を出す各クライアントIDのいくつかのプロパティを追跡する必要があります。プロパティは、クライアントIDとクライアントIDに関連付けられているすべてのセッションに適用されます。プロパティは、引数とExchange_IDの結果から派生します。クライアントIDプロパティは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* The capabilities expressed by the following bits, which come from the results of EXCHANGE_ID:",
      "ja": "* Exchange_IDの結果から来る次のビットで表される機能。"
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_SUPP_MOVED_REFER",
      "ja": "- Exchgid4_flag_supp_moved_refer."
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_SUPP_MOVED_MIGR",
      "ja": "- Exchgid4_flag_supp_moved_migr."
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_BIND_PRINC_STATEID",
      "ja": "- ExchgID4_FLAG_BIND_PRINC_STATEID"
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_USE_NON_PNFS",
      "ja": "- EXCHGID4_FLAG_USE_NON_PNFS"
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_USE_PNFS_MDS",
      "ja": "- Exchgid4_flag_use_pnfs_mds"
    },
    {
      "indent": 6,
      "text": "- EXCHGID4_FLAG_USE_PNFS_DS",
      "ja": "- ExchgID4_FLAG_USE_PNFS_DS"
    },
    {
      "indent": 6,
      "text": "These properties may be updated by subsequent EXCHANGE_ID operations on confirmed client IDs though the server MAY refuse to change them.",
      "ja": "これらのプロパティは、サーバーが変更を拒否することを拒否する可能性があるが、確認されたクライアントIDに対するその後のExchange_ID操作によって更新されてもよい。"
    },
    {
      "indent": 3,
      "text": "* The state protection method used, one of SP4_NONE, SP4_MACH_CRED, or SP4_SSV, as set by the spa_how field of the arguments to EXCHANGE_ID. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID operations.",
      "ja": "* Exchange_IDの引数のspa_howフィールドによって設定されているSP4_NONE、SP4_MACH_CRED、またはSP4_SSVのいずれかの状態保護方法。クライアントIDが確認されると、このプロパティは後続のExchange_ID操作によって更新できません。"
    },
    {
      "indent": 3,
      "text": "* For SP4_MACH_CRED or SP4_SSV state protection:",
      "ja": "* SP4_MACH_CREDまたはSP4_SSV状態保護の場合："
    },
    {
      "indent": 6,
      "text": "- The list of operations (spo_must_enforce) that MUST use the specified state protection. This list comes from the results of EXCHANGE_ID.",
      "ja": "- 指定された状態保護を使用する必要がある操作のリスト（SPO_MUST_ENFORCE）。このリストはExchange_IDの結果から来ています。"
    },
    {
      "indent": 6,
      "text": "- The list of operations (spo_must_allow) that MAY use the specified state protection. This list comes from the results of EXCHANGE_ID.",
      "ja": "- 指定された状態保護を使用する可能性のある操作のリスト（spo_must_allow）。このリストはExchange_IDの結果から来ています。"
    },
    {
      "indent": 6,
      "text": "Once the client ID is confirmed, these properties cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "クライアントIDが確認されると、これらのプロパティは後続のExchange_ID要求によって更新できません。"
    },
    {
      "indent": 3,
      "text": "* For SP4_SSV protection:",
      "ja": "* SP4_SSV保護のために："
    },
    {
      "indent": 6,
      "text": "- The OID of the hash algorithm. This property is represented by one of the algorithms in the ssp_hash_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "- ハッシュアルゴリズムのOIDこのプロパティは、Exchange_ID引数のssp_hash_algsフィールドのアルゴリズムの1つによって表されます。クライアントIDが確認されると、このプロパティは後続のExchange_ID要求によって更新できません。"
    },
    {
      "indent": 6,
      "text": "- The OID of the encryption algorithm. This property is represented by one of the algorithms in the ssp_encr_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "- 暗号化アルゴリズムのOIDこのプロパティは、Exchange_ID引数のssp_encr_algsフィールドのアルゴリズムの1つによって表されます。クライアントIDが確認されると、このプロパティは後続のExchange_ID要求によって更新できません。"
    },
    {
      "indent": 6,
      "text": "- The length of the SSV. This property is represented by the spi_ssv_len field in the EXCHANGE_ID results. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID operations.",
      "ja": "- SSVの長さこのプロパティは、Exchange_IDの結果のSPI_SSV_LENフィールドによって表されます。クライアントIDが確認されると、このプロパティは後続のExchange_ID操作によって更新できません。"
    },
    {
      "indent": 9,
      "text": "There are REQUIRED and RECOMMENDED relationships among the length of the key of the encryption algorithm (\"key length\"), the length of the output of hash algorithm (\"hash length\"), and the length of the SSV (\"SSV length\").",
      "ja": "暗号化アルゴリズムのキーの長さ（「キー長」）、ハッシュアルゴリズムの出力の長さ（「ハッシュレングス」）、およびSSVの長さ（「SSV長」）の長さの間には、必須で推奨される関係があります。。"
    },
    {
      "indent": 9,
      "text": "o key length MUST be <= hash length. This is because the keys used for the encryption algorithm are actually subkeys derived from the SSV, and the derivation is via the hash algorithm. The selection of an encryption algorithm with a key length that exceeded the length of the output of the hash algorithm would require padding, and thus weaken the use of the encryption algorithm.",
      "ja": "o キーの長さは<=ハッシュ長さでなければなりません。これは、暗号化アルゴリズムに使用されるキーが実際にSSVから派生したサブキーであり、派生はハッシュアルゴリズムを介して行われるためです。ハッシュアルゴリズムの出力の長さを超えるキー長を有する暗号化アルゴリズムの選択はパディングを必要とし、したがって暗号化アルゴリズムの使用を弱める。"
    },
    {
      "indent": 9,
      "text": "o hash length SHOULD be <= SSV length. This is because the SSV is a key used to derive subkeys via an HMAC, and it is recommended that the key used as input to an HMAC be at least as long as the length of the HMAC's hash algorithm's output (see Section 3 of [52]).",
      "ja": "o ハッシュ長さは<= SSVの長さでなければなりません。これは、SSVがHMACを介してサブキーを導出するために使用されるキーであり、HMACへの入力として使用されるキーが、少なくともHMACのハッシュアルゴリズムの出力の長さと同じ長さであることをお勧めします（[52のセクション3を参照）。]）。"
    },
    {
      "indent": 9,
      "text": "o key length SHOULD be <= SSV length. This is a transitive result of the above two invariants.",
      "ja": "o キーの長さは<= SSVの長さにする必要があります。これは上記の2つの不変量の推移的な結果です。"
    },
    {
      "indent": 9,
      "text": "o key length SHOULD be >= hash length / 2. This is because the subkey derivation is via an HMAC and it is recommended that if the HMAC has to be truncated, it should not be truncated to less than half the hash length (see Section 4 of RFC 2104 [52]).",
      "ja": "o キーの長さは> =ハッシュの長さ/ 2でなければなりません。これは、サブキーの派生がHMACを介しているためです.HMACを切り捨てる必要がある場合は、ハッシュ長さの半分以下に切り捨てないでください（セクション4を参照）。RFC 2104 [52]の。"
    },
    {
      "indent": 6,
      "text": "- Number of concurrent versions of the SSV the client and server will support (see Section 2.10.9). This property is represented by spi_window in the EXCHANGE_ID results. The property may be updated by subsequent EXCHANGE_ID operations.",
      "ja": "- SSVの同時バージョンの数クライアントとサーバーがサポートします（セクション2.10.9を参照）。このプロパティは、Exchange_IDの結果のspi_windowによって表されます。プロパティは、その後のExchange_ID操作によって更新されます。"
    },
    {
      "indent": 3,
      "text": "* The client's implementation ID as represented by the eia_client_impl_id field of the arguments. The property may be updated by subsequent EXCHANGE_ID requests.",
      "ja": "* 引数のEIA_CLIENT_IMPL_IDフィールドによって表されるクライアントの実装ID。プロパティは、後続のExchange_ID要求によって更新されます。"
    },
    {
      "indent": 3,
      "text": "* The server's implementation ID as represented by the eir_server_impl_id field of the reply. The property may be updated by replies to subsequent EXCHANGE_ID requests.",
      "ja": "* 応答のEIR_SERVER_IMPL_IDフィールドによって表されるサーバーの実装ID。プロパティは、後続のExchange_ID要求に対する返信によって更新されます。"
    },
    {
      "indent": 3,
      "text": "The eia_flags passed as part of the arguments and the eir_flags results allow the client and server to inform each other of their capabilities as well as indicate how the client ID will be used. Whether a bit is set or cleared on the arguments' flags does not force the server to set or clear the same bit on the results' side. Bits not defined above cannot be set in the eia_flags field. If they are, the server MUST reject the operation with NFS4ERR_INVAL.",
      "ja": "引数の一部として渡されたEIA_FLAGSは、クライアントIDの使用方法を示すだけでなく、クライアントとサーバーは互いにお互いに通知することを可能にします。引数のフラグでビットが設定またはクリアされているかクリアされているのかは、サーバーに結果の同じビットを設定またはクリアすることはできません。上記で定義されていないビットはEIA_Flagsフィールドに設定できません。もしそうであれば、サーバーはNFS4ERR_INVALを使用して操作を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The EXCHGID4_FLAG_UPD_CONFIRMED_REC_A bit can only be set in eia_flags; it is always off in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R bit can only be set in eir_flags; it is always off in eia_flags. If the server recognizes the co_ownerid and co_verifier as mapping to a confirmed client ID, it sets EXCHGID4_FLAG_CONFIRMED_R in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R flag allows a client to tell if the client ID it is trying to create already exists and is confirmed.",
      "ja": "ExchgID4_FLAG_UPD_CONFIRMED_REC_Aビットは、EIA_FLAGSでのみ設定できます。EIR_FLAGSでは常にオフです。Exchgid4_flag_confirmed_rビットはEIR_FLAGSでのみ設定できます。EIA_FLAGSで常にオフです。サーバーがCO_OWNERIDとCO_VERIFIENを確認されたクライアントIDへのマッピングとして認識した場合は、EIR_FLAGSでEXCHGID4_FLAG_CONFIRMED_Rを設定します。Exchgid4_flag_confirmed_rフラグでは、クライアントが作成しようとしているクライアントIDが既に存在して確認されているかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set in eia_flags, this means that the client is attempting to update properties of an existing confirmed client ID (if the client wants to update properties of an unconfirmed client ID, it MUST NOT set EXCHGID4_FLAG_UPD_CONFIRMED_REC_A). If so, it is RECOMMENDED that the client send the update EXCHANGE_ID operation in the same COMPOUND as a SEQUENCE so that the EXCHANGE_ID is executed exactly once. Whether the client can update the properties of client ID depends on the state protection it selected when the client ID was created, and the principal and security flavor it used when sending the EXCHANGE_ID operation. The situations described in items 6, 7, 8, or 9 of the second numbered list of Section 18.35.4 below will apply. Note that if the operation succeeds and returns a client ID that is already confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_AがEIA_FLAGSで設定されている場合、これはクライアントが既存の確認されたクライアントIDのプロパティを更新しようとしていることを意味します（クライアントが未確認のクライアントIDのプロパティを更新したい場合は、exchgid4_flag_upd_confirmed_rec_aを設定してはいけません）。もしそうであれば、Clientは、Exchange_IDが正確に実行されるように、シーケンスと同じ化合りで更新Exchange_ID操作を送信することをお勧めします。クライアントがクライアントIDのプロパティを更新できるかどうかは、クライアントIDが作成されたときに選択された状態保護、およびExchange_ID操作を送信するときに使用されたプリンシパルとセキュリティの風味によって異なります。下記のセクション18.35.4の2番目の番号リストの項目6,7,8、または9に記載されている状況が適用されます。操作が成功してすでに確認されているクライアントIDを返す場合、サーバーはEIR_FLAGSでExchgid4_flag_confirmed_rビットを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in eia_flags, this means that the client is trying to establish a new client ID; it is attempting to trunk data communication to the server (See Section 2.10.5); or it is attempting to update properties of an unconfirmed client ID. The situations described in items 1, 2, 3, 4, or 5 of the second numbered list of Section 18.35.4 below will apply. Note that if the operation succeeds and returns a client ID that was previously confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_AがEIA_FLAGSで設定されていない場合、これはクライアントが新しいクライアントIDを確立しようとしていることを意味します。データ通信をサーバーにトランクすることを試みます（セクション2.10.5を参照）。または、未確認のクライアントIDのプロパティを更新しようとしています。下記のセクション18.35.4の2番目の番号リストの項目1,2,3,4、または5に記載されている状況が適用されます。操作が成功して以前に確認されたクライアントIDを返す場合、サーバーはEIR_FLAGSでExchgid4_flag_confirmed_rビットを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the EXCHGID4_FLAG_SUPP_MOVED_REFER flag bit is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a referral sequence. When this bit is not set, it is still legal for the server to perform a referral sequence. However, a server may use the fact that the client is incapable of correctly responding to a referral, by avoiding it for that particular client. It may, for instance, act as a proxy for that particular file system, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a referral, it MUST set EXCHGID4_FLAG_SUPP_MOVED_REFER in eir_flags.",
      "ja": "EXCHGID4_FLAG_SUPP_MOVES_REFERフラグ・ビットが設定されている場合、クライアントは紹介シーケンスの一部としてNFS4ERR_MOUDエラーを扱うことができることを示します。このビットが設定されていない場合、サーバーが紹介シーケンスを実行するのはまだ有効です。ただし、サーバーは、クライアントがその特定のクライアントのためにそれを回避することによって、クライアントが紹介に正しく応答することができないという事実を使用することができます。たとえば、その特定のファイルシステムのプロキシとして機能する可能性がありますが、パフォーマンスのあるコストでは、そうする義務がありません。サーバーが照準を実行する可能性がある場合は、EXTR_FLAGSでEXCHGID4_FLAG_SUPP_MOVES_REFERを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the EXCHGID4_FLAG_SUPP_MOVED_MIGR is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a file system migration sequence. When this bit is not set, it is still legal for the server to indicate that a file system has moved, when this in fact happens. However, a server may use the fact that the client is incapable of correctly responding to a migration in its scheduling of file systems to migrate so as to avoid migration of file systems being actively used. It may also hide actual migrations from clients unable to deal with them by acting as a proxy for a migrated file system for particular clients, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a migration, it MUST set EXCHGID4_FLAG_SUPP_MOVED_MIGR in eir_flags.",
      "ja": "Exchgid4_flag_supp_moved_migrが設定されている場合、クライアントはファイルシステムの移行シーケンスの一部としてNFS4ERR_MOUDエラーを扱うことができることを示します。このビットが設定されていない場合、これが実際に起こるときに、サーバーがファイルシステムが移動したことを示すことはまだ有効です。しかしながら、サーバは、積極的に使用されているファイルシステムの移行を避けるために、クライアントがファイルシステムのスケジューリングの移行に正しく応答することができないという事実を使用することができる。それはまた、特定のクライアントの移行されたファイルシステムのプロキシとして行動することができず、パフォーマンスのいくらかのコストで行動することによって、クライアントからの実際の移行を隠すこともできますが、そうすることは義務付けられていません。サーバーが移行を実行する可能性がある場合は、EXTR_FLAGSでexchgid4_flag_supp_moved_migrを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When EXCHGID4_FLAG_BIND_PRINC_STATEID is set, the client indicates that it wants the server to bind the stateid to the principal. This means that when a principal creates a stateid, it has to be the one to use the stateid. If the server will perform binding, it will return EXCHGID4_FLAG_BIND_PRINC_STATEID. The server MAY return EXCHGID4_FLAG_BIND_PRINC_STATEID even if the client does not request it. If an update to the client ID changes the value of EXCHGID4_FLAG_BIND_PRINC_STATEID's client ID property, the effect applies only to new stateids. Existing stateids (and all stateids with the same \"other\" field) that were created with stateid to principal binding in force will continue to have binding in force. Existing stateids (and all stateids with the same \"other\" field) that were created with stateid to principal not in force will continue to have binding not in force.",
      "ja": "Exchgid4_flag_bind_princ_stateIDが設定されている場合、クライアントはサーバーにStateIDをプリンシパルにバインドすることを示します。つまり、プリンシパルがStateIDを作成すると、StateIDを使用するものである必要があります。サーバーがバインディングを実行すると、Exchgid4_flag_bind_princ_stateIDが返されます。クライアントが要求していなくても、サーバーはExchgid4_flag_bind_princ_stateIDを返します。クライアントIDへの更新がExchgid4_flag_bind_princ_stateIDのクライアントIDプロパティの値を変更した場合、その効果は新しいStateIDにのみ適用されます。Force In Force In Force In PribileBindingに登録された既存のStateID（およびすべてのStateID）は、Forceに拘束力のある拘束力を持ち続けます。StateIDを強制的に非公開にして作成された既存のStateID（およびすべてのStateID）は、強制的に拘束力がないと拘束力がないと継続しています。"
    },
    {
      "indent": 3,
      "text": "The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS bits are described in Section 13.1 and convey roles the client ID is to be used for in a pNFS environment. The server MUST set one of the acceptable combinations of these bits (roles) in eir_flags, as specified in that section. Note that the same client owner/server owner pair can have multiple roles. Multiple roles can be associated with the same client ID or with different client IDs. Thus, if a client sends EXCHANGE_ID from the same client owner to the same server owner multiple times, but specifies different pNFS roles each time, the server might return different client IDs. Given that different pNFS roles might have different client IDs, the client may ask for different properties for each role/client ID.",
      "ja": "EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DS_DSビットは、セクション13.1で説明され、クライアントIDをPNFS環境で使用することができます。サーバーは、そのセクションで指定されているように、これらのビット（ロール）の許容可能な組み合わせの1つをEIR_FLAGSに設定する必要があります。同じクライアント所有者/サーバーの所有者のペアに複数の役割を果たすことができます。複数の役割は、同じクライアントIDまたは異なるクライアントIDと関連付けることができます。したがって、クライアントが同じクライアント所有者から同じサーバー所有者にExchange_idを複数回送信しているが、さまざまなPNFSロールを指定しているが、サーバは異なるクライアントIDを返す可能性がある。異なるPNFSロールが異なるクライアントIDを持つ可能性がある場合、クライアントは各役割/クライアントIDに対して異なるプロパティを要求することがあります。"
    },
    {
      "indent": 3,
      "text": "The spa_how field of the eia_state_protect field specifies how the client wants to protect its client, locking, and session states from unauthorized changes (Section 2.10.8.3):",
      "ja": "EIA_STATE_PROTECTフィールドのSPA_HOWフィールドは、クライアントがそのクライアント、ロック、およびセッションの状態を不正な変更から保護する方法を指定します（セクション2.10.8.3）。"
    },
    {
      "indent": 3,
      "text": "* SP4_NONE. The client does not request the NFSv4.1 server to enforce state protection. The NFSv4.1 server MUST NOT enforce state protection for the returned client ID.",
      "ja": "* sp4_none。クライアントは、NFSV4.1サーバーに状態保護を強制することを要求しません。NFSV4.1サーバーは、返されたクライアントIDの状態保護を強制してはいけません。"
    },
    {
      "indent": 3,
      "text": "* SP4_MACH_CRED. If spa_how is SP4_MACH_CRED, then the client MUST send the EXCHANGE_ID operation with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY. If SP4_MACH_CRED is specified, then the client wants to use an RPCSEC_GSS-based machine credential to protect its state. The server MUST note the principal the EXCHANGE_ID operation was sent with, and the GSS mechanism used. These notes collectively comprise the machine credential.",
      "ja": "* SP4_MACH_CRED。spa_howがsp4_mach_credの場合、クライアントはRPCSEC_GSSをSecurityフレーバーとして、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYを使用してExchange_ID操作を送信する必要があります。SP4_MACH_CREDが指定されている場合、クライアントはその状態を保護するためにRPCSEC_GSSベースのマシンの資格情報を使用したいと考えています。サーバーは、Exchange_ID操作が送信され、GSSメカニズムが使用されたプリンシパルに注意しなければなりません。これらのノートはまとめてマシンの信任状を備えています。"
    },
    {
      "indent": 6,
      "text": "After the client ID is confirmed, as long as the lease associated with the client ID is unexpired, a subsequent EXCHANGE_ID operation that uses the same eia_clientowner.co_owner as the first EXCHANGE_ID MUST also use the same machine credential as the first EXCHANGE_ID. The server returns the same client ID for the subsequent EXCHANGE_ID as that returned from the first EXCHANGE_ID.",
      "ja": "クライアントIDが確認された後、クライアントIDに関連付けられているリースが期限切れになっていれば、最初のExchange_IDとして同じEIA_CLINENTOWNER.CO_OWNERを使用する次のExchange_IDオペレーションは、最初のExchange_IDと同じマシンの信任状を使用する必要があります。サーバーは、最初のExchange_IDから返された後続のExchange_IDの同じクライアントIDを返します。"
    },
    {
      "indent": 3,
      "text": "* SP4_SSV. If spa_how is SP4_SSV, then the client MUST send the EXCHANGE_ID operation with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY. If SP4_SSV is specified, then the client wants to use the SSV to protect its state. The server records the credential used in the request as the machine credential (as defined above) for the eia_clientowner.co_owner. The CREATE_SESSION operation that confirms the client ID MUST use the same machine credential.",
      "ja": "* SP4_SSVspa_howがSP4_SSVの場合、クライアントはRPCSEC_GSSをSECURITY FLAVEとして、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYを使用してExchange_ID操作を送信する必要があります。SP4_SSVが指定されている場合、クライアントはSSVを使用してその状態を保護したいと考えています。サーバーは、要求で使用されている資格情報をEIA_CLINTOROWNER.CO_OWNERのマシン認証情報として記録します。クライアントIDを確認するCREATE_SESSION操作は、同じマシン認証情報を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client specifies SP4_MACH_CRED or SP4_SSV, it also provides two lists of operations (each expressed as a bitmap). The first list is spo_must_enforce and consists of those operations the client MUST send (subject to the server confirming the list of operations in the result of EXCHANGE_ID) with the machine credential (if SP4_MACH_CRED protection is specified) or the SSV-based credential (if SP4_SSV protection is used). The client MUST send the operations with RPCSEC_GSS credentials that specify the RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY security service. Typically, the first list of operations includes EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, and DESTROY_CLIENTID. The client SHOULD NOT specify in this list any operations that require a filehandle because the server's access policies MAY conflict with the client's choice, and thus the client would then be unable to access a subset of the server's namespace.",
      "ja": "クライアントがSP4_MACH_CREDまたはSP4_SSVを指定すると、2つの操作のリスト（それぞれがビットマップとして表現）します。最初のリストはSPO_MUST_ENFORCEで、マシンの信任状（SP4_MACH_CRED保護が指定されている場合）またはSSVベースの信任状（SP4_SSVの場合）でクライアントを送信する必要がある操作で構成されています。保護が使用されます。クライアントは、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYセキュリティサービスを指定するRPCSEC_GSS認証情報を使用して操作を送信する必要があります。通常、操作の最初のリストには、Exchange_ID、CREATE_SESSION、DELEGPURGE、DESTORY_SCLENTION、BIND_CONN_TO_SESSION、およびDOREST_CLIENTIDが含まれます。このリストでは、サーバーのアクセスポリシーがクライアントの選択と競合する可能性があるため、このリストでファイルハンドルを必要とする操作を指定しないでください。したがって、クライアントはサーバーのネームスペースのサブセットにアクセスできません。"
    },
    {
      "indent": 3,
      "text": "Note that if SP4_SSV protection is specified, and the client indicates that CREATE_SESSION must be protected with SP4_SSV, because the SSV cannot exist without a confirmed client ID, the first CREATE_SESSION MUST instead be sent using the machine credential, and the server MUST accept the machine credential.",
      "ja": "SP4_SSV保護が指定されていて、クライアントはSP4_SSVでCREATE_SSESSTを保護する必要があることを示し、SSVが確認されたクライアントIDなしでSSVが存在できないため、最初のCREATE_SESSIONはマシンの信任状を使用して送信されなければならず、サーバーはマシンを受け入れる必要があります。資格情報"
    },
    {
      "indent": 3,
      "text": "There is a corresponding result, also called spo_must_enforce, of the operations for which the server will require SP4_MACH_CRED or SP4_SSV protection. Normally, the server's result equals the client's argument, but the result MAY be different. If the client requests one or more operations in the set { EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, DESTROY_CLIENTID }, then the result spo_must_enforce MUST include the operations the client requested from that set.",
      "ja": "サーバーがSP4_MACH_CREDまたはSP4_SSV保護を必要とする操作の、SPO_MUST_ENFORCEとも呼ばれ、対応する結果があります。通常、サーバーの結果はクライアントの引数に等しくなりますが、結果は異なる場合があります。クライアントがセット{exchange_id、create_session、delegpurge、destroy_sclientid}で1つ以上の操作を要求した場合、結果spo_must_enforceはそのセットから要求されたクライアントの操作を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If spo_must_enforce in the results has BIND_CONN_TO_SESSION set, then connection binding enforcement is enabled, and the client MUST use the machine (if SP4_MACH_CRED protection is used) or SSV (if SP4_SSV protection is used) credential on calls to BIND_CONN_TO_SESSION.",
      "ja": "結果のspo_must_enforceにbind_conn_to_sessionセットが設定されている場合は、接続バインディングの強制が有効になり、クライアントはマシン（SP4_MACH_CRED保護が使用されている場合）またはSSV（SP4_SSV保護が使用されている場合）BIND_CONN_TO_SESSISTを呼び出しに使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The second list is spo_must_allow and consists of those operations the client wants to have the option of sending with the machine credential or the SSV-based credential, even if the object the operations are performed on is not owned by the machine or SSV credential.",
      "ja": "2番目のリストはspo_must_allowで、操作が実行されたオブジェクトがマシンまたはSSVの信任状によって所有されていなくても、クライアントはマシンの認証情報またはSSVベースの信任状で送信するオプションを持つ操作で構成されています。"
    },
    {
      "indent": 3,
      "text": "The corresponding result, also called spo_must_allow, consists of the operations the server will allow the client to use SP4_SSV or SP4_MACH_CRED credentials with. Normally, the server's result equals the client's argument, but the result MAY be different.",
      "ja": "SPO_MUST_ALLOWとも呼ばれる対応する結果は、サーバーがクライアントがSP4_SSVまたはSP4_MACH_CRED認証情報を使用できるようにする操作で構成されています。通常、サーバーの結果はクライアントの引数に等しくなりますが、結果は異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "The purpose of spo_must_allow is to allow clients to solve the following conundrum. Suppose the client ID is confirmed with EXCHGID4_FLAG_BIND_PRINC_STATEID, and it calls OPEN with the RPCSEC_GSS credentials of a normal user. Now suppose the user's credentials expire, and cannot be renewed (e.g., a Kerberos ticket granting ticket expires, and the user has logged off and will not be acquiring a new ticket granting ticket). The client will be unable to send CLOSE without the user's credentials, which is to say the client has to either leave the state on the server or re-send EXCHANGE_ID with a new verifier to clear all state, that is, unless the client includes CLOSE on the list of operations in spo_must_allow and the server agrees.",
      "ja": "spo_must_allowの目的は、クライアントが次の漫画障害を解決できるようにすることです。クライアントIDがExchgid4_flag_bind_princ_stateIDで確認され、通常のユーザーのRPCSEC_GSS認証情報でOpenを呼び出します。ユーザーの認証情報が期限切れになり、更新することはできません（例えば、Kerberosチケットは、チケットの有効期限が付与され、ユーザーがログオフし、新しいチケット付与チケットを取得しません）。クライアントがユーザーの認証情報なしで送信できなくなります。これは、クライアントがサーバー上の状態を残したり、すべての状態をクリアしたりするための新しい検証者でExchange_idを再送信したり、クライアントに近いものが含まれていない限りspo_must_allowとサーバーの操作のリストに同意します。"
    },
    {
      "indent": 3,
      "text": "The SP4_SSV protection parameters also have:",
      "ja": "SP4_SSV保護パラメータにもあります。"
    },
    {
      "indent": 3,
      "text": "ssp_hash_algs: This is the set of algorithms the client supports for the purpose of computing the digests needed for the internal SSV GSS mechanism and for the SET_SSV operation. Each algorithm is specified as an object identifier (OID). The REQUIRED algorithms for a server are id-sha1, id-sha224, id-sha256, id-sha384, and id-sha512 [25].",
      "ja": "SSP_HASH_ALGS：これは、クライアントが内部SSV GSSメカニズムおよびSET_SSV操作に必要なダイジェストを計算する目的でクライアントがサポートする一連のアルゴリズムです。各アルゴリズムはオブジェクト識別子（OID）として指定されます。サーバーの必要なアルゴリズムは、ID-SHA1、ID-SHA224、ID-SHA256、ID-SHA384、ID-SHA512 [25]です。"
    },
    {
      "indent": 6,
      "text": "Due to known weaknesses in id-sha1, it is RECOMMENDED that the client specify at least one algorithm within ssp_hash_algs other than id-sha1.",
      "ja": "ID-SHA1の既知の弱点のために、クライアントはID-SHA1以外のSSP_HASH_ALG内で少なくとも1つのアルゴリズムを指定することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "The algorithm the server selects among the set is indicated in spi_hash_alg, a field of spr_ssv_prot_info. The field spi_hash_alg is an index into the array ssp_hash_algs. Because of known the weaknesses in id-sha1, it is RECOMMENDED that it not be selected by the server as long as ssp_hash_algs contains any other supported algorithm.",
      "ja": "サーバーがセット間で選択されているアルゴリズムは、SPI_SSV_PROT_INFOのフィールドであるSPI_HASH_ALGに表示されます。フィールドSPI_HASH_ALGは、配列SSP_HASH_ALGSへのインデックスです。ID-SHA1の弱点が既知のため、SSP_HASH_ALGSに他のサポートされているアルゴリズムが含まれている限り、サーバーによって選択されないことをお勧めします。"
    },
    {
      "indent": 6,
      "text": "If the server does not support any of the offered algorithms, it returns NFS4ERR_HASH_ALG_UNSUPP. If ssp_hash_algs is empty, the server MUST return NFS4ERR_INVAL.",
      "ja": "サーバーが提供されたアルゴリズムをサポートしていない場合は、NFS4ERR_HASH_ALG_UNSUPPを返します。SSP_HASH_ALGSが空の場合、サーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "ssp_encr_algs: This is the set of algorithms the client supports for the purpose of providing privacy protection for the internal SSV GSS mechanism. Each algorithm is specified as an OID. The REQUIRED algorithm for a server is id-aes256-CBC. The RECOMMENDED algorithms are id-aes192-CBC and id-aes128-CBC [26]. The selected algorithm is returned in spi_encr_alg, an index into ssp_encr_algs. If the server does not support any of the offered algorithms, it returns NFS4ERR_ENCR_ALG_UNSUPP. If ssp_encr_algs is empty, the server MUST return NFS4ERR_INVAL. Note that due to previously stated requirements and recommendations on the relationships between key length and hash length, some combinations of RECOMMENDED and REQUIRED encryption algorithm and hash algorithm either SHOULD NOT or MUST NOT be used. Table 21 summarizes the illegal and discouraged combinations.",
      "ja": "ssp_encr_algs：これは、内部SSV GSSメカニズムのプライバシー保護を提供する目的でクライアントがサポートするアルゴリズムのセットです。各アルゴリズムはOIDとして指定されています。サーバーの必要なアルゴリズムはID-AES256-CBCです。推奨されるアルゴリズムはID-AES192-CBCおよびID-AES128-CBC [26]です。選択されたアルゴリズムはspi_encr_alg、indexをssp_encr_algsに返されます。サーバーが提供されたアルゴリズムをサポートしていない場合は、NFS4ERR_ENCR_ALG_UNSUPPを返します。ssp_encr_algsが空の場合、サーバーはNFS4ERR_INVALを返す必要があります。主な長さとハッシュ長の関係についての前述の要件と推奨事項のために、推奨される暗号化アルゴリズムとハッシュアルゴリズムのいくつかの組み合わせは、使用してはいけないか、使用しないでください。表21は、違法で難読化された組み合わせを要約しています。"
    },
    {
      "indent": 3,
      "text": "ssp_window: This is the number of SSV versions the client wants the server to maintain (i.e., each successful call to SET_SSV produces a new version of the SSV). If ssp_window is zero, the server MUST return NFS4ERR_INVAL. The server responds with spi_window, which MUST NOT exceed ssp_window and MUST be at least one. Any requests on the backchannel or fore channel that are using a version of the SSV that is outside the window will fail with an ONC RPC authentication error, and the requester will have to retry them with the same slot ID and sequence ID.",
      "ja": "SSP_Window：これはクライアントがサーバーを保持するSSVバージョンの数です（すなわち、set_ssvの各呼び出しは新しいバージョンのSSVを生成するたびに生成されます）。ssp_windowがゼロの場合、サーバーはNFS4ERR_INVALを返す必要があります。サーバーはspi_windowで応答します。これはssp_windowを超えてはならず、少なくとも1つでなければなりません。ウィンドウ外のバージョンのSSVを使用しているバックチャンネルまたはフォアチャネルに対する要求は、ONC RPC認証エラーで失敗し、リクエスタは同じスロットIDとシーケンスIDでそれらを再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "ssp_num_gss_handles: This is the number of RPCSEC_GSS handles the server should create that are based on the GSS SSV mechanism (see Section 2.10.9). It is not the total number of RPCSEC_GSS handles for the client ID. Indeed, subsequent calls to EXCHANGE_ID will add RPCSEC_GSS handles. The server responds with a list of handles in spi_handles. If the client asks for at least one handle and the server cannot create it, the server MUST return an error. The handles in spi_handles are not available for use until the client ID is confirmed, which could be immediately if EXCHANGE_ID returns EXCHGID4_FLAG_CONFIRMED_R, or upon successful confirmation from CREATE_SESSION.",
      "ja": "ssp_num_gss_handles：これはRPCSEC_GSSの数です。クライアントIDのRPCSEC_GSSハンドルの総数ではありません。確かに、Exchange_IDへの後続の呼び出しはRPCSEC_GSSハンドルを追加します。サーバーはSPI_HANDLESのハンドルのリストで応答します。クライアントが少なくとも1つのハンドルを要求し、サーバーがそれを作成できない場合、サーバーはエラーを返す必要があります。SPI_Handlesのハンドルは、Client IDが確認されるまで使用できません。"
    },
    {
      "indent": 6,
      "text": "While a client ID can span all the connections that are connected to a server sharing the same eir_server_owner.so_major_id, the RPCSEC_GSS handles returned in spi_handles can only be used on connections connected to a server that returns the same the eir_server_owner.so_major_id and eir_server_owner.so_minor_id on each connection. It is permissible for the client to set ssp_num_gss_handles to zero; the client can create more handles with another EXCHANGE_ID call.",
      "ja": "クライアントIDは、同じEIR_SERVER_OWNER.SO_MAJOR_IDを共有するサーバーに接続されているすべての接続にまたがることができますが、SPI_HANDLEで返されたRPCSEC_GSSハンドルは、EIR_SERVER_OWNER.SO_MAID、EIR_SERVER_OWNER.SO_MINOR_IDを返すサーバーに接続されている接続でのみ使用できます。接続ごとに。クライアントがssp_num_gss_handlesをゼロに設定することは許可されています。クライアントは、別のExchange_ID呼び出しでより多くのハンドルを作成できます。"
    },
    {
      "indent": 6,
      "text": "Because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "各SSV RPCSEC_GSSは、共通のSSV GSSコンテキストを共有しているため、セクション2.10.10で説明したこの状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 6,
      "text": "The seq_window (see Section 5.2.3.1 of RFC 2203 [4]) of each RPCSEC_GSS handle in spi_handle MUST be the same as the seq_window of the RPCSEC_GSS handle used for the credential of the RPC request of which the EXCHANGE_ID operation was sent as a part.",
      "ja": "SPI_Handle内の各RPCSEC_GSSハンドルのSEQ_WINDOW（RFC 2203 [4]を参照）は、Exchange_ID操作が部分として送信されたRPC要求の信任状に使用されるRPCSEC_GSSハンドルのSEQ_WINDOWと同じでなければなりません。。"
    },
    {
      "indent": 3,
      "text": "+======================+===========================+===============+\n| Encryption Algorithm | MUST NOT be combined with | SHOULD NOT be |\n|                      |                           | combined with |\n+======================+===========================+===============+\n| id-aes128-CBC        |                           | id-sha384,    |\n|                      |                           | id-sha512     |\n+----------------------+---------------------------+---------------+\n| id-aes192-CBC        | id-sha1                   | id-sha512     |\n+----------------------+---------------------------+---------------+\n| id-aes256-CBC        | id-sha1, id-sha224        |               |\n+----------------------+---------------------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 21",
      "ja": "表21."
    },
    {
      "indent": 3,
      "text": "The arguments include an array of up to one element in length called eia_client_impl_id. If eia_client_impl_id is present, it contains the information identifying the implementation of the client. Similarly, the results include an array of up to one element in length called eir_server_impl_id that identifies the implementation of the server. Servers MUST accept a zero-length eia_client_impl_id array, and clients MUST accept a zero-length eir_server_impl_id array.",
      "ja": "引数は、eia_client_impl_idという長さの最大1つの要素の配列を含みます。EIA_CLIENT_IMPL_IDが存在する場合は、クライアントの実装を識別する情報が含まれています。同様に、結果は、サーバーの実装を識別するEIR_SERVER_IMPL_IDと呼ばれる長さの最大1つの要素の配列を含みます。サーバーはゼロ長さのEIA_CLIENT_IMPL_IDアレイを受け入れ、クライアントはゼロ長EIR_SERVER_IMPL_IDアレイを受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "A possible use for implementation identifiers would be in diagnostic software that extracts this information in an attempt to identify interoperability problems, performance workload behaviors, or general usage statistics. Since the intent of having access to this information is for planning or general diagnosis only, the client and server MUST NOT interpret this implementation identity information in a way that affects how the implementation interacts with its peer. The client and server are not allowed to depend on the peer's manifesting a particular allowed behavior based on an implementation identifier but are required to interoperate as specified elsewhere in the protocol specification.",
      "ja": "実装識別子のための可能な使用可能な使用は、相互運用性の問題、パフォーマンスワークロードの動作、または一般的な使用統計を識別するためにこの情報を抽出する診断ソフトウェアにあります。この情報にアクセスするという意図は計画または一般的な診断のみのためのものであるため、クライアントとサーバーは、実装がそのピアと対話する方法に影響を与える方法でこの実装ID情報を解釈してはなりません。クライアントとサーバーは、実装識別子に基づいて特定の許可された動作を明示しているが、プロトコル仕様の他の場所で相互運用する必要がある。"
    },
    {
      "indent": 3,
      "text": "Because it is possible that some implementations might violate the protocol specification and interpret the identity information, implementations MUST provide facilities to allow the NFSv4 client and server to be configured to set the contents of the nfs_impl_id structures sent to any specified value.",
      "ja": "一部の実装がプロトコル仕様に違反し、ID情報を解釈する可能性があるため、実装はNFSV4クライアントおよびサーバーが指定された値に送信されたNFS_IMPL_ID構造体の内容を設定できるようにするための機能を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.35.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.35.4. 実装"
    },
    {
      "indent": 3,
      "text": "A server's client record is a 5-tuple:",
      "ja": "サーバーのクライアントレコードは5タプルです。"
    },
    {
      "indent": 3,
      "text": "1. co_ownerid:",
      "ja": "1. Co_OwnerID："
    },
    {
      "indent": 7,
      "text": "The client identifier string, from the eia_clientowner structure of the EXCHANGE_ID4args structure.",
      "ja": "Exchange_ID4ARGS構造体のEIA_ClientOwner構造体からのクライアント識別子文字列。"
    },
    {
      "indent": 3,
      "text": "2. co_verifier:",
      "ja": "2. co_verifier："
    },
    {
      "indent": 7,
      "text": "A client-specific value used to indicate incarnations (where a client restart represents a new incarnation), from the eia_clientowner structure of the EXCHANGE_ID4args structure.",
      "ja": "Exchange_ID4ARGS構造体のEIA_CLINTOWNER構造体から、（クライアントの再起動が新しいインカナーを表す場合）を示すために使用されるクライアント固有の値。"
    },
    {
      "indent": 3,
      "text": "3. principal:",
      "ja": "3. 主要な："
    },
    {
      "indent": 7,
      "text": "The principal that was defined in the RPC header's credential and/or verifier at the time the client record was established.",
      "ja": "クライアントレコードが確立された時点で、RPCヘッダーの資格情報および/または検証者で定義された主体。"
    },
    {
      "indent": 3,
      "text": "4. client ID:",
      "ja": "4. クライアントID："
    },
    {
      "indent": 7,
      "text": "The shorthand client identifier, generated by the server and returned via the eir_clientid field in the EXCHANGE_ID4resok structure.",
      "ja": "サーバーによって生成され、Exchange_ID4Resok構造体のEIR_CLIENTIDフィールドを介して返された短絡クライアント識別子。"
    },
    {
      "indent": 3,
      "text": "5. confirmed:",
      "ja": "5. 確認済み："
    },
    {
      "indent": 7,
      "text": "A private field on the server indicating whether or not a client record has been confirmed. A client record is confirmed if there has been a successful CREATE_SESSION operation to confirm it. Otherwise, it is unconfirmed. An unconfirmed record is established by an EXCHANGE_ID call. Any unconfirmed record that is not confirmed within a lease period SHOULD be removed.",
      "ja": "クライアントレコードが確認されたか否かを示すサーバ上のプライベートフィールド。それを確認するためのcreate_session操作が成功した場合は、クライアントレコードが確認されます。そうでなければ、それは未確認です。未確認レコードはExchange_ID呼び出しによって確立されます。リース期間内に確認されていない未確認のレコードを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following identifiers represent special values for the fields in the records.",
      "ja": "次の識別子は、レコード内のフィールドの特殊値を表します。"
    },
    {
      "indent": 3,
      "text": "ownerid_arg: The value of the eia_clientowner.co_ownerid subfield of the EXCHANGE_ID4args structure of the current request.",
      "ja": "ownerId_arg：現在の要求のExchange_ID4ARGS構造のEIA_CLINTEROWNER.co_ownerIDサブフィールドの値。"
    },
    {
      "indent": 3,
      "text": "verifier_arg: The value of the eia_clientowner.co_verifier subfield of the EXCHANGE_ID4args structure of the current request.",
      "ja": "verifier_arg：現在の要求のExchange_ID4ARGS構造のEIAN_CLINTEROWNER.co_verifierサブフィールドの値。"
    },
    {
      "indent": 3,
      "text": "old_verifier_arg: A value of the eia_clientowner.co_verifier field of a client record received in a previous request; this is distinct from verifier_arg.",
      "ja": "old_verifier_arg：前の要求で受信されたクライアントレコードのEIA_ClientOwner.co_verifierフィールドの値。これはVerifier_argとは異なります。"
    },
    {
      "indent": 3,
      "text": "principal_arg: The value of the RPCSEC_GSS principal for the current request.",
      "ja": "principal_arg：現在の要求のRPCSEC_GSSプリンシパルの値。"
    },
    {
      "indent": 3,
      "text": "old_principal_arg: A value of the principal of a client record as defined by the RPC header's credential or verifier of a previous request. This is distinct from principal_arg.",
      "ja": "OLD_PRINCIPAL_ARG：RPCヘッダーの信任状または前回のリクエストの検証者によって定義されているクライアントレコードのプリンシパルの値。これはprincipal_argとは異なります。"
    },
    {
      "indent": 3,
      "text": "clientid_ret: The value of the eir_clientid field the server will return in the EXCHANGE_ID4resok structure for the current request.",
      "ja": "clientID_RET：現在のリクエストのExchange_ID4Resok構造にサーバーが戻るEIR_CLIENTIDフィールドの値。"
    },
    {
      "indent": 3,
      "text": "old_clientid_ret: The value of the eir_clientid field the server returned in the EXCHANGE_ID4resok structure for a previous request. This is distinct from clientid_ret.",
      "ja": "OLD_CLIENTID_RET：Exchange_ID4Resok構造体に戻ったeir_clientIDフィールドの値前回のリクエストの値。これはclientID_RETとは異なります。"
    },
    {
      "indent": 3,
      "text": "confirmed: The client ID has been confirmed.",
      "ja": "確認済み：クライアントIDが確認されました。"
    },
    {
      "indent": 3,
      "text": "unconfirmed: The client ID has not been confirmed.",
      "ja": "未確認：クライアントIDが確認されていません。"
    },
    {
      "indent": 3,
      "text": "Since EXCHANGE_ID is a non-idempotent operation, we must consider the possibility that retries occur as a result of a client restart, network partition, malfunctioning router, etc. Retries are identified by the value of the eia_clientowner field of EXCHANGE_ID4args, and the method for dealing with them is outlined in the scenarios below.",
      "ja": "Exchange_IDは非IDEmpotent演算であるため、クライアントの再起動、ネットワークパーティション、誤動作しているルータなどの結果として再試行が発生する可能性を考慮する必要があります。それらに対処することは、以下のシナリオで概説されています。"
    },
    {
      "indent": 3,
      "text": "The scenarios are described in terms of the client record(s) a server has for a given co_ownerid. Note that if the client ID was created specifying SP4_SSV state protection and EXCHANGE_ID as the one of the operations in spo_must_allow, then the server MUST authorize EXCHANGE_IDs with the SSV principal in addition to the principal that created the client ID.",
      "ja": "シナリオは、サーバーが特定のCO_OWNERID用のクライアントレコードに関して説明されています。spo_must_allowの操作の1つとしてSP4_SSV状態保護とExchange_IDを指定したクライアントIDが作成された場合、サーバーはクライアントIDを作成したプリンシパルに加えてSSVプリンシパルでExchange_IDを承認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. New Owner ID",
      "ja": "1. 新しい所有者ID"
    },
    {
      "indent": 7,
      "text": "If the server has no client records with eia_clientowner.co_ownerid matching ownerid_arg, and EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in the EXCHANGE_ID, then a new shorthand client ID (let us call it clientid_ret) is generated, and the following unconfirmed record is added to the server's state.",
      "ja": "サーバーにEVERONID_ARGと一致するEIA_CLIENTOWNER.CO_OWNERIDを持つクライアントレコードがない場合、Exchangid4_flag_upd_confirmed_rec_aがExchange_IDで設定されていない場合は、新しい短縮クライアントID（IT IT ClientID_RETを呼び出しましょう）が生成され、次の未確認レコードがサーバーの状態に追加されます。。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 7,
      "text": "Subsequently, the server returns clientid_ret.",
      "ja": "その後、サーバーはclientId_retを返します。"
    },
    {
      "indent": 3,
      "text": "2. Non-Update on Existing Client ID",
      "ja": "2. 既存のクライアントIDの未更新"
    },
    {
      "indent": 7,
      "text": "If the server has the following confirmed record, and the request does not have EXCHGID4_FLAG_UPD_CONFIRMED_REC_A set, then the request is the result of a retried request due to a faulty router or lost connection, or the client is trying to determine if it can perform trunking.",
      "ja": "サーバーに次の確認されたレコードがある場合、要求にEXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていない場合、要求は障害のあるルータまたはロスト接続によるリトライ要求の結果であるか、クライアントがトランキングを実行できるかどうかを判断しようとしています。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }",
      "ja": "{OwnerID_ARG、Verifier_arg、Principal_arg、ClientID_RET、確認}"
    },
    {
      "indent": 7,
      "text": "Since the record has been confirmed, the client must have received the server's reply from the initial EXCHANGE_ID request. Since the server has a confirmed record, and since EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, with the possible exception of eir_server_owner.so_minor_id, the server returns the same result it did when the client ID's properties were last updated (or if never updated, the result when the client ID was created). The confirmed record is unchanged.",
      "ja": "レコードが確認されているので、クライアントは最初のExchange_ID要求からサーバーの応答を受信した必要があります。サーバーは確認されたレコードを持っているので、EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていないため、EIR_SERVER_OWNER.SO_MINOR_IDの例外を使用して、サーバーは同じ結果を返し、クライアントIDのプロパティが最後に更新されたとき（または更新されていない場合はその結果、クライアントIDが作成されました）。確認されたレコードは変更されません。"
    },
    {
      "indent": 3,
      "text": "3. Client Collision",
      "ja": "3. クライアントの衝突"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the server has the following confirmed record, then this request is likely the result of a chance collision between the values of the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args for two different clients.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていない場合、およびサーバーに次の確認されたレコードがある場合、この要求は、2つの異なるクライアントのExchange_ID4ARGのEIA_CLINTEROWNER.co_owsサブフィールドの値の偶然の衝突の結果です。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, *, old_principal_arg, old_clientid_ret, confirmed }",
      "ja": "{OWNERID_ARG、*、OLD_PRINCIPAL_ARG、OLD_CLIENTID_RET、確認済み}"
    },
    {
      "indent": 7,
      "text": "If there is currently no state associated with old_clientid_ret, or if there is state but the lease has expired, then this case is effectively equivalent to the New Owner ID case of Section 18.35.4, Paragraph 7, Item 1. The confirmed record is deleted, the old_clientid_ret and its lock state are deleted, a new shorthand client ID is generated, and the following unconfirmed record is added to the server's state.",
      "ja": "現在、OLD_CLIENTID_RETに関連付けられていない場合、またはリースが期限切れになっている場合、この場合は、セクション18.35.4、項7、項目1の新しい所有者IDケースと効果的に同等です。確認されたレコードは削除されました、OLD_CLIENTID_RETとそのロック状態が削除され、新しい省略形クライアントIDが生成され、次の未確認レコードがサーバーの状態に追加されます。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 7,
      "text": "Subsequently, the server returns clientid_ret.",
      "ja": "その後、サーバーはclientId_retを返します。"
    },
    {
      "indent": 7,
      "text": "If old_clientid_ret has an unexpired lease with state, then no state of old_clientid_ret is changed or deleted. The server returns NFS4ERR_CLID_INUSE to indicate that the client should retry with a different value for the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args. The client record is not changed.",
      "ja": "OLD_CLIENTID_RETの状態で期限切れのリースがある場合、OLD_CLIENTID_RETの状態は変更または削除されません。サーバーはNFS4ERR_CLID_INUSEを返して、Exchange_ID4ARGSのEIA_CLIENTOWNER.co_owneridサブフィールドにクライアントが別の値で再試行する必要があることを示します。クライアントレコードは変更されません。"
    },
    {
      "indent": 3,
      "text": "4. Replacement of Unconfirmed Record",
      "ja": "4. 未確認レコードの交換"
    },
    {
      "indent": 7,
      "text": "If the EXCHGID4_FLAG_UPD_CONFIRMED_REC_A flag is not set, and the server has the following unconfirmed record, then the client is attempting EXCHANGE_ID again on an unconfirmed client ID, perhaps due to a retry, a client restart before client ID confirmation (i.e., before CREATE_SESSION was called), or some other reason.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aフラグが設定されていない場合、サーバーに次のような未確認レコードがある場合、クライアントは未確認のクライアントIDで再度Exchange_IDを再度、クライアントIDの確認前のクライアントの再起動（Create_Sessionが呼び出される前に）を再起動しています。）、またはその他の理由。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, *, *, old_clientid_ret, unconfirmed }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "It is possible that the properties of old_clientid_ret are different than those specified in the current EXCHANGE_ID. Whether or not the properties are being updated, to eliminate ambiguity, the server deletes the unconfirmed record, generates a new client ID (clientid_ret), and establishes the following unconfirmed record:",
      "ja": "OLD_CLIENTID_RETのプロパティは、現在のExchange_IDで指定されたものとは異なる可能性があります。曖昧さを排除するためにプロパティが更新されているかどうか、サーバは未確認レコードを削除し、新しいクライアントID（clientID_RET）を生成し、以下の未確認レコードを確立します。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 3,
      "text": "5. Client Restart",
      "ja": "5. クライアントの再起動"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the server has the following confirmed client record, then this request is likely from a previously confirmed client that has restarted.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていない場合、サーバーに次の確認されたクライアントレコードがある場合、この要求は再起動した以前に確認されたクライアントからの可能性があります。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, old_verifier_arg, principal_arg, old_clientid_ret, confirmed }",
      "ja": "{OWNERID_ARG、OLD_VERIFIER_ARG、PRINCIPAL_ARG、OLD_CLIENTID_RET、確認済み}"
    },
    {
      "indent": 7,
      "text": "Since the previous incarnation of the same client will no longer be making requests, once the new client ID is confirmed by CREATE_SESSION, byte-range locks and share reservations should be released immediately rather than forcing the new incarnation to wait for the lease time on the previous incarnation to expire. Furthermore, session state should be removed since if the client had maintained that information across restart, this request would not have been sent. If the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_PREV_FH claim types, associated delegations should be purged as well; otherwise, delegations are retained and recovery proceeds according to Section 10.2.1.",
      "ja": "同じクライアントの以前の化身は、新しいクライアントIDがcreate_sessionによって確認されたら、新しいクライアントIDがCreate_Session、Byte-Range LocksとShareの予約を直ちに解放する必要があります。期限切れのための以前の化身。さらに、クライアントが再起動にわたってその情報を維持した場合、この要求は送信されなかった場合、セッション状態は削除されるべきです。サーバーがクレームのいずれかをサポートしていない場合は、クレーム_deleg_prev_fhもクレーム・タイプもサポートしていない場合、関連付けられている代理人も同様に消去されるべきです。それ以外の場合、委任は保持され、復旧は10.2.1項に従って進行します。"
    },
    {
      "indent": 7,
      "text": "After processing, clientid_ret is returned to the client and this client record is added:",
      "ja": "処理後、clientID_RETがクライアントに返され、このクライアントレコードが追加されます。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 7,
      "text": "The previously described confirmed record continues to exist, and thus the same ownerid_arg exists in both a confirmed and unconfirmed state at the same time. The number of states can collapse to one once the server receives an applicable CREATE_SESSION or EXCHANGE_ID.",
      "ja": "前述の確認されたレコードは存在し続け、したがって、同じOwnerID_argが同時に確認されたものと未確認状態の両方に存在する。サーバーが該当するCreate_SessionまたはExchange_IDを受信すると、状態の数が1つに折りたたまれることがあります。"
    },
    {
      "indent": 7,
      "text": "* If the server subsequently receives a successful CREATE_SESSION that confirms clientid_ret, then the server atomically destroys the confirmed record and makes the unconfirmed record confirmed as described in Section 18.36.3.",
      "ja": "* サーバーがClientID_RETを確認するCreate_Sessionが成功した後に受信された場合、サーバーは確認されたレコードをアトミックに破棄し、節18.36.3で説明されているように未確認レコードを確認します。"
    },
    {
      "indent": 7,
      "text": "* If the server instead subsequently receives an EXCHANGE_ID with the client owner equal to ownerid_arg, one strategy is to simply delete the unconfirmed record, and process the EXCHANGE_ID as described in the entirety of Section 18.35.4.",
      "ja": "* その後、サーバーがClient OwnerをOwnerId_argと等しい場合、サーバーがExchange_IDを受信した場合、1つの戦略は単に未確認レコードを削除し、18.35.4の全体の説明に従ってExchange_IDを処理することです。"
    },
    {
      "indent": 3,
      "text": "6. Update",
      "ja": "6. 更新"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an attempt at an update.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されている場合、サーバーに次の確認レコードがある場合は、この要求は更新時の試みです。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }",
      "ja": "{OwnerID_ARG、Verifier_arg、Principal_arg、ClientID_RET、確認}"
    },
    {
      "indent": 7,
      "text": "Since the record has been confirmed, the client must have received the server's reply from the initial EXCHANGE_ID request. The server allows the update, and the client record is left intact.",
      "ja": "レコードが確認されているので、クライアントは最初のExchange_ID要求からサーバーの応答を受信した必要があります。サーバーが更新を許可し、クライアントレコードはそのまま残されています。"
    },
    {
      "indent": 3,
      "text": "7. Update but No Confirmed Record",
      "ja": "7. 更新されましたが確認されていません"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has no confirmed record corresponding ownerid_arg, then the server returns NFS4ERR_NOENT and leaves any unconfirmed record intact.",
      "ja": "Exchgid4_flag_upd_confirmed_rec_aが設定されており、サーバーに対応する所有者ID_ARGが確認されていない場合、サーバーはNFS4ERR_NOENTを返し、未確認のレコードをそのまま残しています。"
    },
    {
      "indent": 3,
      "text": "8. Update but Wrong Verifier",
      "ja": "8. 更新が間違った検証者"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an illegal attempt at an update, perhaps because of a retry from a previous client incarnation.",
      "ja": "Exchgid4_flag_upd_confirmed_rec_aが設定されていて、サーバーに次の確認されたレコードが設定されている場合、この要求は更新時の不正な試みです。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, old_verifier_arg, *, clientid_ret, confirmed }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "The server returns NFS4ERR_NOT_SAME and leaves the client record intact.",
      "ja": "サーバーはNFS4ERR_NOT_SAMEを返し、クライアントレコードをそのまま残します。"
    },
    {
      "indent": 3,
      "text": "9. Update but Wrong Principal",
      "ja": "9. 更新が間違っているプリンシパル"
    },
    {
      "indent": 7,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an illegal attempt at an update by an unauthorized principal.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMD_REC_Aが設定され、サーバーに次の確認されたレコードがある場合、この要求は不正なプリンシパルによる更新時の不正な試みです。"
    },
    {
      "indent": 7,
      "text": "{ ownerid_arg, verifier_arg, old_principal_arg, clientid_ret, confirmed }",
      "ja": "{OwnerID_arg、Verifier_arg、Old_Principal_arg、ClientID_RET、確認済み}"
    },
    {
      "indent": 7,
      "text": "The server returns NFS4ERR_PERM and leaves the client record intact.",
      "ja": "サーバーはNFS4ERR_PERMを返し、クライアントレコードをそのまま残します。"
    },
    {
      "indent": 0,
      "text": "18.36. Operation 43: CREATE_SESSION - Create New Session and Confirm Client ID",
      "ja": "18.36. 操作43：create_session  - 新しいセッションを作成し、クライアントIDを確認する"
    },
    {
      "indent": 0,
      "text": "18.36.1. ARGUMENT",
      "section_title": true,
      "ja": "18.36.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct channel_attrs4 {\n        count4                  ca_headerpadsize;\n        count4                  ca_maxrequestsize;\n        count4                  ca_maxresponsesize;\n        count4                  ca_maxresponsesize_cached;\n        count4                  ca_maxoperations;\n        count4                  ca_maxrequests;\n        uint32_t                ca_rdma_ird<1>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const CREATE_SESSION4_FLAG_PERSIST              = 0x00000001;\nconst CREATE_SESSION4_FLAG_CONN_BACK_CHAN       = 0x00000002;\nconst CREATE_SESSION4_FLAG_CONN_RDMA            = 0x00000004;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CREATE_SESSION4args {\n        clientid4               csa_clientid;\n        sequenceid4             csa_sequence;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "uint32_t csa_flags;",
      "ja": "UINT32_T CSA_FLAGS;"
    },
    {
      "indent": 11,
      "text": "channel_attrs4          csa_fore_chan_attrs;\nchannel_attrs4          csa_back_chan_attrs;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        uint32_t                csa_cb_program;\n        callback_sec_parms4     csa_sec_parms<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.36.2. RESULT",
      "section_title": true,
      "ja": "18.36.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CREATE_SESSION4resok {\n        sessionid4              csr_sessionid;\n        sequenceid4             csr_sequence;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "uint32_t csr_flags;",
      "ja": "UINT32_T CSR_FLAGS;"
    },
    {
      "indent": 3,
      "text": "        channel_attrs4          csr_fore_chan_attrs;\n        channel_attrs4          csr_back_chan_attrs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union CREATE_SESSION4res switch (nfsstat4 csr_status) {\ncase NFS4_OK:\n        CREATE_SESSION4resok    csr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.36.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.36.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is used by the client to create new session objects on the server.",
      "ja": "この操作は、クライアントがサーバー上に新しいセッションオブジェクトを作成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "CREATE_SESSION can be sent with or without a preceding SEQUENCE operation in the same COMPOUND procedure. If CREATE_SESSION is sent with a preceding SEQUENCE operation, any session created by CREATE_SESSION has no direct relation to the session specified in the SEQUENCE operation, although the two sessions might be associated with the same client ID. If CREATE_SESSION is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure's request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "CREATE_SESSIONは、同じ複合手順で前のシーケンス操作でまたはなく、その有無にかかわらず送信できます。CREATE_SESSIONが前のシーケンス操作で送信された場合、CREATE_SESSIONによって作成されたセッションは、シーケンス操作で指定されたセッションと直接関係はありませんが、2つのセッションは同じクライアントIDに関連付けられます。先行シーケンスなしでcreate_sessionが送信された場合、それは複合プロシージャの要求の唯一の操作でなければなりません。そうでない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to creating a session, CREATE_SESSION has the following effects:",
      "ja": "セッションの作成に加えて、create_sessionには次のような効果があります。"
    },
    {
      "indent": 3,
      "text": "* The first session created with a new client ID serves to confirm the creation of that client's state on the server. The server returns the parameter values for the new session.",
      "ja": "* 新しいクライアントIDで作成された最初のセッションは、サーバー上のそのクライアントの状態の作成を確認するのに役立ちます。サーバーは、新しいセッションのパラメータ値を返します。"
    },
    {
      "indent": 3,
      "text": "* The connection CREATE_SESSION that is sent over is associated with the session's fore channel.",
      "ja": "* 送信されたCREATE_SESSIONは、セッションの先行チャネルに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "The arguments and results of CREATE_SESSION are described as follows:",
      "ja": "create_sessionの引数と結果は次のように説明されています。"
    },
    {
      "indent": 3,
      "text": "csa_clientid: This is the client ID with which the new session will be associated. The corresponding result is csr_sessionid, the session ID of the new session.",
      "ja": "CSA_CLIENTID：これは、新しいセッションが関連付けられるクライアントIDです。対応する結果はCSR_SESSIONID、新しいセッションのセッションIDです。"
    },
    {
      "indent": 3,
      "text": "csa_sequence: Each client ID serializes CREATE_SESSION via a per-client ID sequence number (see Section 18.36.4). The corresponding result is csr_sequence, which MUST be equal to csa_sequence.",
      "ja": "CSA_Sequence：各クライアントIDは、クライアントごとのIDシーケンス番号を介してCREATE_SESSIONをシリアル化します（セクション18.36.4を参照）。対応する結果はCSR_SEQUENCEです。これはCSA_Sequenceに等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the next three arguments, the client offers a value that is to be a property of the session. Except where stated otherwise, it is RECOMMENDED that the server accept the value. If it is not acceptable, the server MAY use a different value. Regardless, the server MUST return the value the session will use (which will be either what the client offered, or what the server is insisting on) to the client.",
      "ja": "次の3つの引数で、クライアントはセッションのプロパティになる値を提供します。それ以外の場合を除いて、サーバーが値を受け入れることをお勧めします。それが許容できない場合、サーバーは別の値を使用することができます。とにかく、サーバーはセッションが使用される値を返す必要があります（これは、クライアントが提供するもの、またはサーバーが主張しているもの）クライアントへのものです。"
    },
    {
      "indent": 3,
      "text": "csa_flags: The csa_flags field contains a list of the following flag bits:",
      "ja": "CSA_FLAGS：CSA_FLAGSフィールドには、次のフラグビットのリストが含まれています。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_PERSIST: If CREATE_SESSION4_FLAG_PERSIST is set, the client wants the server to provide a persistent reply cache. For sessions in which only idempotent operations will be used (e.g., a read-only session), clients SHOULD NOT set CREATE_SESSION4_FLAG_PERSIST. If the server does not or cannot provide a persistent reply cache, the server MUST NOT set CREATE_SESSION4_FLAG_PERSIST in the field csr_flags.",
      "ja": "CREATE_SESSION4_FLAG_PERSIST：CREATE_SESSION4_FLAG_PERSISTが設定されている場合、クライアントはサーバーに永続的な返信キャッシュを提供させたいとします。IDEmPotent操作のみを使用するセッション（例えば、読み取り専用セッション）には、CREATE_SESSION4_FLAG_PERSISTを設定しないでください。サーバーが永続的な返信キャッシュを提供しない、または提供できない場合、サーバーはフィールドCSR_FLAGSにcreate_session4_flag_persistを設定してはいけません。"
    },
    {
      "indent": 9,
      "text": "If the server is a pNFS metadata server, for reasons described in Section 12.5.2 it SHOULD support CREATE_SESSION4_FLAG_PERSIST if it supports the layout_hint (Section 5.12.4) attribute.",
      "ja": "サーバーがPNFSメタデータサーバーである場合は、セクション12.5.2で説明されている理由で、LAYOUT_HINT（セクション5.12.4）属性をサポートしている場合はcreate_session4_flag_persistをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_CONN_BACK_CHAN: If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is set in csa_flags, the client is requesting that the connection over which the CREATE_SESSION operation arrived be associated with the session's backchannel in addition to its fore channel. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_BACK_CHAN in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_BACK_CHAN MUST NOT be set in csr_flags.",
      "ja": "create_session4_flag_conn_back_chan：create_session4_flag_conn_back_chanがcsa_flagsで設定されている場合、クライアントは、その前のチャネルに加えて、CREATE_SESSION操作がセッションのバックチャネルに関連付けられた接続を要求しています。サーバーが同意した場合は、結果フィールドCSR_FLAGSにcreate_session4_flag_conn_back_can_chanを設定します。create_session4_flag_conn_back_chanがcsa_flagsで設定されていない場合、create_session4_flag_conn_back_chanはcsr_flagsに設定してはいけません。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_CONN_RDMA: If CREATE_SESSION4_FLAG_CONN_RDMA is set in csa_flags, and if the connection over which the CREATE_SESSION operation arrived is currently in non-RDMA mode but has the capability to operate in RDMA mode, then the client is requesting that the server \"step up\" to RDMA mode on the connection. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_RDMA in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_RDMA is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_RDMA MUST NOT be set in csr_flags. Note that once the server agrees to step up, it and the client MUST exchange all future traffic on the connection with RPC RDMA framing and not Record Marking ([32]).",
      "ja": "create_session4_flag_conn_rdma：create_session4_flag_conn_rdmaがcsa_flagsに設定されている場合、およびCREATE_SESSION操作が現在到着しているがRDMAモードで動作する機能がある場合、クライアントはRDMAへの「ステップアップ」を要求しています。接続上のモードサーバーが同意した場合は、結果フィールドCSR_FLAGSにcreate_session4_flag_conn_rdmaを設定します。create_session4_flag_conn_rdmaがcsa_flagsで設定されていない場合、create_session4_flag_conn_rdmaをcsr_flagsに設定してはいけません。サーバーがステップアップに同意すると、それとクライアントはRPC RDMAフレーミングとの接続上のすべての将来のトラフィックを交換し、記録マーキング（[32]）を交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "csa_fore_chan_attrs, csa_back_chan_attrs: The csa_fore_chan_attrs and csa_back_chan_attrs fields apply to attributes of the fore channel (which conveys requests originating from the client to the server), and the backchannel (the channel that conveys callback requests originating from the server to the client), respectively. The results are in corresponding structures called csr_fore_chan_attrs and csr_back_chan_attrs. The results establish attributes for each channel, and on all subsequent use of each channel of the session. Each structure has the following fields:",
      "ja": "CSA_FOURE_CHAN_ATTRS、CSA_BACK_CHAN_ATTRS：CSA_FOURE_CHAN_ATTRSフィールドとCSA_BACK_CHAN_ATTRSフィールドは、（クライアントからサーバーに発信された要求を実行します）、バックチャネル（サーバーからクライアントに発信されたコールバック要求を伝えるチャネル）の属性に適用されます。結果は、CSR_FOURE_CHAN_ATTRSとCSR_BACK_CHAN_ATTRと呼ばれる対応する構造にあります。結果は、各チャネルの属性を確立し、セッションの各チャネルの後続のすべての使用になります。各構造には次のフィールドがあります。"
    },
    {
      "indent": 6,
      "text": "ca_headerpadsize: The maximum amount of padding the requester is willing to apply to ensure that write payloads are aligned on some boundary at the replier. For each channel, the server",
      "ja": "CA_HEADERPADSIZE：リクエストの最大量は、ライトペイロードがレプリアの一部の境界で揃っていることを確認するために適用されます。各チャンネルの場合、サーバー"
    },
    {
      "indent": 9,
      "text": "* will reply in ca_headerpadsize with its preferred value, or zero if padding is not in use, and",
      "ja": "* Paddingが使用されていない場合は、CA_HEADERPADSIZE、その推奨値でゼロに応答します。"
    },
    {
      "indent": 9,
      "text": "* MAY decrease this value but MUST NOT increase it.",
      "ja": "* この値を減らすことができますが、それを増やしてはいけません。"
    },
    {
      "indent": 6,
      "text": "ca_maxrequestsize: The maximum size of a COMPOUND or CB_COMPOUND request that will be sent. This size represents the XDR encoded size of the request, including the RPC headers (including security flavor credentials and verifiers) but excludes any RPC transport framing headers. Imagine a request coming over a non-RDMA TCP/ IP connection, and that it has a single Record Marking header preceding it. The maximum allowable count encoded in the header will be ca_maxrequestsize. If a requester sends a request that exceeds ca_maxrequestsize, the error NFS4ERR_REQ_TOO_BIG will be returned per the description in Section 2.10.6.4. For each channel, the server MAY decrease this value but MUST NOT increase it.",
      "ja": "CA_MAXREQUESTSIZE：送信される複合またはCB_COMPOUND要求の最大サイズ。このサイズは、RPCヘッダー（セキュリティフレーバー認証情報と検証者を含む）を含む、要求のXDRエンコードされたサイズを表しますが、RPCトランスポートフレーミングヘッダーを除外します。RDMA以外のTCP / IP接続を介してやってくる要求を想像してください。ヘッダーでエンコードされている最大許容カウントはCA_MAXRequestSizeになります。要求者がCA_MAXRequestSizeを超える要求を送信した場合、セクション2.10.6.4の説明に従ってエラーNFS4ERR_REQ_TOO_BIGが返されます。各チャンネルについて、サーバーはこの値を減らすことができますが、それを増やしてはいけません。"
    },
    {
      "indent": 6,
      "text": "ca_maxresponsesize: The maximum size of a COMPOUND or CB_COMPOUND reply that the requester will accept from the replier including RPC headers (see the ca_maxrequestsize definition). For each channel, the server MAY decrease this value, but MUST NOT increase it. However, if the client selects a value for ca_maxresponsesize such that a replier on a channel could never send a response, the server SHOULD return NFS4ERR_TOOSMALL in the CREATE_SESSION reply. After the session is created, if a requester sends a request for which the size of the reply would exceed this value, the replier will return NFS4ERR_REP_TOO_BIG, per the description in Section 2.10.6.4.",
      "ja": "CA_MAXResponseSize：リクエスタがRPCヘッダーを含むレプリアから受け入れるような複合またはcb_compound応答の最大サイズ（CA_MAXRequestSize定義を参照）。各チャンネルについて、サーバーはこの値を減らすことができますが、それを増やしてはいけません。ただし、クライアントがCA_MAXResponseSizeの値を選択した場合、チャネル上のレプリアが応答を送信できない可能性があるため、サーバーはCREATE_SESSION応答でNFS4ERR_TOOSMALLを返す必要があります。セッションが作成された後、リクエスターが応答のサイズがこの値を超える要求を送信した場合、レプリアは2.10.6.4の説明に従ってNFS4ERR_REP_TOO_BIGを返します。"
    },
    {
      "indent": 6,
      "text": "ca_maxresponsesize_cached: Like ca_maxresponsesize, but the maximum size of a reply that will be stored in the reply cache (Section 2.10.6.1). For each channel, the server MAY decrease this value, but MUST NOT increase it. If, in the reply to CREATE_SESSION, the value of ca_maxresponsesize_cached of a channel is less than the value of ca_maxresponsesize of the same channel, then this is an indication to the requester that it needs to be selective about which replies it directs the replier to cache; for example, large replies from non-idempotent operations (e.g., COMPOUND requests with a READ operation) should not be cached. The requester decides which replies to cache via an argument to the SEQUENCE (the sa_cachethis field, see Section 18.46) or CB_SEQUENCE (the csa_cachethis field, see Section 20.9) operations. After the session is created, if a requester sends a request for which the size of the reply would exceed ca_maxresponsesize_cached, the replier will return NFS4ERR_REP_TOO_BIG_TO_CACHE, per the description in Section 2.10.6.4.",
      "ja": "CA_MAXResponseSize_cached：CA_MAXResponseSizeと同じですが、返信キャッシュに格納される返信の最大サイズ（セクション2.10.6.1）。各チャンネルについて、サーバーはこの値を減らすことができますが、それを増やしてはいけません。 create_sessionへの返信で、チャネルのCA_MAXResponseSize_Cachedの値が同じチャンネルのCA_MAXResponsezeの値より小さい場合、これはリクエスターが選択的になる必要があることを確認する必要があるため、レプリアをキャッシュに指示する;たとえば、非iDEPOTENT操作（例えば、読み取り操作による複合要求）からの大きな応答はキャッシュされてはならない。リクエスタは、順序（SA_CACHETHISフィールド、セクション18.46）またはCB_SEQUENCE（CSA_CACHETHISフィールド、セクション20.9を参照）の順序で引数を介してキャッシュに返信することを決定します。セッションが作成された後、リクエスターが応答のサイズがCA_MAXResponseSize_Cachedを超える要求を送信した場合、2.10.6.4項の説明に従って、レプリアはNFS4ERR_REP_TOO_BIG_TO_TO_CACHEを返します。"
    },
    {
      "indent": 6,
      "text": "ca_maxoperations: The maximum number of operations the replier will accept in a COMPOUND or CB_COMPOUND. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value. After the session is created, if a requester sends a COMPOUND or CB_COMPOUND with more operations than ca_maxoperations, the replier MUST return NFS4ERR_TOO_MANY_OPS.",
      "ja": "CA_MAXOPERATIONATIONS：リプライアが複合またはCB_COMPOUNDで受け入れる最大操作数。BackChannelの場合、サーバーはクライアントが提供する値を変更してはいけません。前のチャネルの場合、サーバーは要求された値を変更することがあります。セッションが作成された後、要求者がCA_MAXOperations以外の操作で複合またはCB_COMPOUNDを送信した場合、レプリアはNFS4ERR_TOO_MANY_OPSを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "ca_maxrequests: The maximum number of concurrent COMPOUND or CB_COMPOUND requests the requester will send on the session. Subsequent requests will each be assigned a slot identifier by the requester within the range zero to ca_maxrequests - 1 inclusive. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value.",
      "ja": "CA_MAXREQUESTS：同時複合またはCB_COMPOUND要求の最大数要求者がセッションで送信されます。後続の要求には、ゼロからCA_MAXRequests  -  1を含む範囲内のリクエスタによってスロット識別子が割り当てられます。BackChannelの場合、サーバーはクライアントが提供する値を変更してはいけません。前のチャネルの場合、サーバーは要求された値を変更することがあります。"
    },
    {
      "indent": 6,
      "text": "ca_rdma_ird: This array has a maximum of one element. If this array has one element, then the element contains the inbound RDMA read queue depth (IRD). For each channel, the server MAY decrease this value, but MUST NOT increase it.",
      "ja": "CA_RDMA_IRD：この配列には最大1つの要素があります。この配列に1つの要素がある場合、その要素にはインバウンドRDMA読み取りキューの深さ（IRD）が含まれています。各チャンネルについて、サーバーはこの値を減らすことができますが、それを増やしてはいけません。"
    },
    {
      "indent": 3,
      "text": "csa_cb_program This is the ONC RPC program number the server MUST use in any callbacks sent through the backchannel to the client. The server MUST specify an ONC RPC program number equal to csa_cb_program and an ONC RPC version number equal to 4 in callbacks sent to the client. If a CB_COMPOUND is sent to the client, the server MUST use a minor version number of 1. There is no corresponding result.",
      "ja": "CSA_CB_PROGROGRこれは、BackChannelを介してクライアントに送信されたコールバックでサーバーが使用する必要があるONC RPCプログラム番号です。サーバーは、CSA_CB_PROGRAMに等しいONC RPCプログラム番号を指定する必要があります。コールバックでは4に等しいONC RPCバージョン番号をクライアントに送信する必要があります。CB_COMPOUNDがクライアントに送信された場合、サーバーはマイナーバージョン番号1を使用する必要があります。対応する結果はありません。"
    },
    {
      "indent": 3,
      "text": "csa_sec_parms The field csa_sec_parms is an array of acceptable security credentials the server can use on the session's backchannel. Three security flavors are supported: AUTH_NONE, AUTH_SYS, and RPCSEC_GSS. If AUTH_NONE is specified for a credential, then this says the client is authorizing the server to use AUTH_NONE on all callbacks for the session. If AUTH_SYS is specified, then the client is authorizing the server to use AUTH_SYS on all callbacks, using the credential specified cbsp_sys_cred. If RPCSEC_GSS is specified, then the server is allowed to use the RPCSEC_GSS context specified in cbsp_gss_parms as the RPCSEC_GSS context in the credential of the RPC header of callbacks to the client. There is no corresponding result.",
      "ja": "CSA_SEC_PARMSフィールドCSA_SEC_PARMSは、サーバーがセッションのBackChannelで使用できる許容できるセキュリティ認証情報の配列です。3つのセキュリティフレーバーがサポートされています：auth_none、auth_sys、およびrpcsec_gss。認証情報のためにauth_noneが指定されている場合、これはクライアントがセッションのすべてのコールバックでauth_noneを使用するようにサーバーの承認を承認しています。AUTH_SYSが指定されている場合、クライアントは、信任状指定されたCBSP_SYS_CREDを使用して、すべてのコールバックでauth_sysを使用するようにサーバーを承認しています。RPCSEC_GSSが指定されている場合、サーバーはCBSP_GSS_PARMSで指定されたRPCSEC_GSSコンテキストをクライアントのRPCヘッダーの認証情報として使用できます。対応する結果はありません。"
    },
    {
      "indent": 6,
      "text": "The RPCSEC_GSS context for the backchannel is specified via a pair of values of data type gsshandle4_t. The data type gsshandle4_t represents an RPCSEC_GSS handle, and is precisely the same as the data type of the \"handle\" field of the rpc_gss_init_res data type defined in \"Context Creation Response - Successful Acceptance\", Section 5.2.3.1 of [4].",
      "ja": "バックチャネルのRPCSEC_GSSコンテキストは、データ型gsshandle4_tの値のペアで指定されています。データ型GSSHANDLE4_Tは、RPCSEC_GSSハンドルを表し、「コンテキスト作成応答 - 成功した受付」で定義されているRPC_GSS_INIT_RESデータ型の「ハンドル」フィールドのデータ型と同じである[4]のセクション5.2.3.1。"
    },
    {
      "indent": 6,
      "text": "The first RPCSEC_GSS handle, gcbp_handle_from_server, is the fore handle the server returned to the client (either in the handle field of data type rpc_gss_init_res or as one of the elements of the spi_handles field returned in the reply to EXCHANGE_ID) when the RPCSEC_GSS context was created on the server. The second handle, gcbp_handle_from_client, is the back handle to which the client will map the RPCSEC_GSS context. The server can immediately use the value of gcbp_handle_from_client in the RPCSEC_GSS credential in callback RPCs. That is, the value in gcbp_handle_from_client can be used as the value of the field \"handle\" in data type rpc_gss_cred_t (see \"Elements of the RPCSEC_GSS Security Protocol\", Section 5 of [4]) in callback RPCs. The server MUST use the RPCSEC_GSS security service specified in gcbp_service, i.e., it MUST set the \"service\" field of the rpc_gss_cred_t data type in RPCSEC_GSS credential to the value of gcbp_service (see \"RPC Request Header\", Section 5.3.1 of [4]).",
      "ja": "最初のRPCSEC_GSSハンドル、GCBP_HANDLE_FROM_SERVERは、RPCSEC_GSSコンテキストが作成されたときに（データ型RPC_GSS_INIT_RESのハンドルフィールド）クライアントに返されるサーバーが（またはExchange_IDへの返信で返信されたSPI_Handlesフィールドの1つとして）クライアントに返される前のハンドルです。サーバー上で。 2番目のハンドル、GCBP_Handle_from_clientは、クライアントがRPCSEC_GSSコンテキストをマッピングするバックハンドルです。サーバーは、コールバックRPCのRPCSEC_GSS認証情報のgcbp_handle_from_clientの値を直ちに使用できます。すなわち、GCBP_handle_from_clientの値は、データ型RPC_GSS_CRED_Tのフィールド「ハンドル」の値として使用できます（「RPCSEC_GSSセキュリティプロトコルの要素」（RPCSEC_GSSセキュリティプロトコルの要素、[4]）、コールバックRPCのセクション5を参照してください。サーバーは、gcbp_serviceで指定されたRPCSEC_GSSセキュリティサービスを使用する必要があります。つまり、RPCSEC_GSSクレデンシャルでRPC_GSS_CRED_Tデータ型の「サービス」フィールドをGCBP_SERVICEの値に設定する必要があります（「RPC要求ヘッダー」の「4.3.1」を参照）。 ]）。"
    },
    {
      "indent": 6,
      "text": "If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server will return NFS4ERR_NOENT.",
      "ja": "gcbp_handle_from_serverによって識別されたRPCSEC_GSSハンドルがサーバー上に存在しない場合、サーバーはNFS4ERR_NOENTを返します。"
    },
    {
      "indent": 6,
      "text": "Within each element of csa_sec_parms, the fore and back RPCSEC_GSS contexts MUST share the same GSS context and MUST have the same seq_window (see Section 5.2.3.1 of RFC 2203 [4]). The fore and back RPCSEC_GSS context state are independent of each other as far as the RPCSEC_GSS sequence number (see the seq_num field in the rpc_gss_cred_t data type of Sections 5 and 5.3.1 of [4]).",
      "ja": "CSA_SEC_PARMSの各要素内で、前後のRPCSEC_GSSコンテキストは同じGSSコンテキストを共有し、同じSEQWINDOWを持つ必要があります（RFC 2203 [4]のセクション5.2.3.1を参照）。前後のrpcsec_gssコンテキスト状態は、RPCSEC_GSSシーケンス番号に関しては互いに独立しています（[4]のセクション5および5.3.1のセクション5および5.3.1のrpc_gss_cred_tデータ型）。"
    },
    {
      "indent": 6,
      "text": "If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "RPCSEC_GSS HandleがSSVコンテキストを使用している場合（セクション2.10.9を参照）、各SSV RPCSEC_GSSSは共通のSSV GSSコンテキストを共有しているため、セクション2.10.10で説明したこの状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Once the session is created, the first SEQUENCE or CB_SEQUENCE received on a slot MUST have a sequence ID equal to 1; if not, the replier MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "セッションが作成されると、スロット上で受信された最初のシーケンスまたはCB_Sequenceは1に等しいシーケンスIDを持たなければなりません。そうでない場合、レプリアはNFS4ERR_SEQ_MISORDEREDを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "18.36.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.36.4. 実装"
    },
    {
      "indent": 3,
      "text": "To describe a possible implementation, the same notation for client records introduced in the description of EXCHANGE_ID is used with the following addition:",
      "ja": "可能な実装を説明するために、Exchange_IDの説明で導入されたクライアントレコードの同じ表記法は、次の追加で使用されます。"
    },
    {
      "indent": 6,
      "text": "clientid_arg: The value of the csa_clientid field of the CREATE_SESSION4args structure of the current request.",
      "ja": "clientID_ARG：現在の要求のcreate_session4args構造のCSA_CLIENTIDフィールドの値。"
    },
    {
      "indent": 3,
      "text": "Since CREATE_SESSION is a non-idempotent operation, we need to consider the possibility that retries may occur as a result of a client restart, network partition, malfunctioning router, etc. For each client ID created by EXCHANGE_ID, the server maintains a separate reply cache (called the CREATE_SESSION reply cache) similar to the session reply cache used for SEQUENCE operations, with two distinctions.",
      "ja": "CREATE_SESSENTは非IDEMOTENT操作であるため、Exchange_IDによって作成されたクライアントIDごとに、クライアントの再起動、ネットワークパーティション、故障したルータなどの結果として再試行が発生する可能性を考慮する必要があります。（Create_Sessionの返信キャッシュと呼ばれます）シーケンス操作に使用されるセッション応答キャッシュと同様に、2つの区別があります。"
    },
    {
      "indent": 3,
      "text": "* First, this is a reply cache just for detecting and processing CREATE_SESSION requests for a given client ID.",
      "ja": "* まず、これは、特定のクライアントIDのCREATE_SESSION要求を検出および処理するための応答キャッシュです。"
    },
    {
      "indent": 3,
      "text": "* Second, the size of the client ID reply cache is of one slot (and as a result, the CREATE_SESSION request does not carry a slot number). This means that at most one CREATE_SESSION request for a given client ID can be outstanding.",
      "ja": "* 第2に、クライアントIDの返信キャッシュのサイズは1スロットのサイズである（そしてその結果、Create_Session要求はスロット番号を持ちません）。つまり、特定のクライアントIDの最大のCREATE_SESSION要求が未解決である可能性があります。"
    },
    {
      "indent": 3,
      "text": "As previously stated, CREATE_SESSION can be sent with or without a preceding SEQUENCE operation. Even if a SEQUENCE precedes CREATE_SESSION, the server MUST maintain the CREATE_SESSION reply cache, which is separate from the reply cache for the session associated with a SEQUENCE. If CREATE_SESSION was originally sent by itself, the client MAY send a retry of the CREATE_SESSION operation within a COMPOUND preceded by a SEQUENCE. If CREATE_SESSION was originally sent in a COMPOUND that started with a SEQUENCE, then the client SHOULD send a retry in a COMPOUND that starts with a SEQUENCE that has the same session ID as the SEQUENCE of the original request. However, the client MAY send a retry in a COMPOUND that either has no preceding SEQUENCE, or has a preceding SEQUENCE that refers to a different session than the original CREATE_SESSION. This might be necessary if the client sends a CREATE_SESSION in a COMPOUND preceded by a SEQUENCE with session ID X, and session X no longer exists. Regardless, any retry of CREATE_SESSION, with or without a preceding SEQUENCE, MUST use the same value of csa_sequence as the original.",
      "ja": "前述のように、CREATE_SESSIONは先行のシーケンス操作の有無にかかわらず送信できます。シーケンスがcreate_sessionの前にある場合でも、サーバーはCreate_Sessionの返信キャッシュを維持する必要があります。これは、シーケンスに関連付けられているセッションの応答キャッシュとは別のものです。 CREATE_SESSIONが最初にそれ自体で送信された場合、クライアントはシーケンスが先行する化合物内でcreate_session操作のリトライを送信することができます。 CREATE_SESSIONが最初にシーケンスで始まった化合物で送信された場合、クライアントは元の要求のシーケンスと同じセッションIDを持つシーケンスで始まる化合物にリトライを送信する必要があります。しかしながら、クライアントは、前のシーケンスを有していないか、または元のCREATE_SESSIONとは異なるセッションを参照する上記のシーケンスを有する化合物に再試行を送信することができる。クライアントがセッションID Xを持つシーケンスが先行する化合物でCREATE_SESSIONを送信し、セッションXが存在しなくなった場合、これは必要になる場合があります。とにかく、前のシーケンスの有無にかかわらず、CREATE_SESSIONの再試行は、元のものとして同じ値のCSA_SEQUENCEを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the client received a reply to an EXCHANGE_ID operation that contains a new, unconfirmed client ID, the server expects the client to follow with a CREATE_SESSION operation to confirm the client ID. The server expects value of csa_sequenceid in the arguments to that CREATE_SESSION to be to equal the value of the field eir_sequenceid that was returned in results of the EXCHANGE_ID that returned the unconfirmed client ID. Before the server replies to that EXCHANGE_ID operation, it initializes the client ID slot to be equal to eir_sequenceid - 1 (accounting for underflow), and records a contrived CREATE_SESSION result with a \"cached\" result of NFS4ERR_SEQ_MISORDERED. With the client ID slot thus initialized, the processing of the CREATE_SESSION operation is divided into four phases:",
      "ja": "クライアントが新しい、未確認のクライアントIDを含むExchange_ID操作への返信を受け取った後、サーバーはクライアントIDを確認するためにクライアントがCreate_Session操作で追従することを期待しています。サーバーは、未確認のクライアントIDを返したExchange_IDの結果で返されたフィールドEIR_SequenceIDの値と等しくなるように引数のCSA_SEQUENCEIDの値を期待しています。サーバーがそのExchange_ID操作に応答する前に、クライアントIDスロットがEIR_SEQUENCEIDID  -  1（アンダーフローのアカウンティング）と等しくなるように初期化し、作成されたCREATE_SESSION結果をNFS4ERR_SEQ_MISORDEREDの「キャッシュされた」結果を記録します。このようにして初期化されたクライアントIDスロットを使用すると、CREATE_SESSION操作の処理は4つのフェーズに分けられます。"
    },
    {
      "indent": 3,
      "text": "1. Client record look up. The server looks up the client ID in its client record table. If the server contains no records with client ID equal to clientid_arg, then most likely the client's state has been purged during a period of inactivity, possibly due to a loss of connectivity. NFS4ERR_STALE_CLIENTID is returned, and no changes are made to any client records on the server. Otherwise, the server goes to phase 2.",
      "ja": "1. クライアントレコードルックアップ。サーバーはクライアントレコードテーブルのクライアントIDを調べます。サーバーにCLIENTID_ARGに等しいクライアントIDを持つレコードが含まれていない場合、おそらく接続性の損失によるクライアントの状態が不活動期間中にパージされています。NFS4ERR_STALE_CLIENTIDが返され、サーバー上のどのクライアントレコードに変更は加えられません。それ以外の場合、サーバーはフェーズ2に進みます。"
    },
    {
      "indent": 3,
      "text": "2. Sequence ID processing. If csa_sequenceid is equal to the sequence ID in the client ID's slot, then this is a replay of the previous CREATE_SESSION request, and the server returns the cached result. If csa_sequenceid is not equal to the sequence ID in the slot, and is more than one greater (accounting for wraparound), then the server returns the error NFS4ERR_SEQ_MISORDERED, and does not change the slot. If csa_sequenceid is equal to the slot's sequence ID + 1 (accounting for wraparound), then the slot's sequence ID is set to csa_sequenceid, and the CREATE_SESSION processing goes to the next phase. A subsequent new CREATE_SESSION call over the same client ID MUST use a csa_sequenceid that is one greater than the sequence ID in the slot.",
      "ja": "2. シーケンスID処理CSA_SequenceIDがクライアントIDのスロットのシーケンスIDと等しい場合、これは前のCREATE_SESSION要求の再生であり、サーバーはキャッシュ結果を返します。CSA_SEQUENCEIDがスロット内のシーケンスIDと等しくなく、1つ以上（ラップアラウンドのアカウンティング）の場合、サーバーはエラーNFS4ERR_SEQ_MISORDEREDを返し、スロットを変更しません。CSA_SEQUENCEIDがスロットのシーケンスID 1（ラップアラウンドのアカウンティング）と等しい場合、スロットのシーケンスIDはCSA_SEQUENCEIDに設定され、CREATE_SESSION処理は次のフェーズになります。同じクライアントIDを介した後続の新しいCREATE_SESSION呼び出しは、スロット内のシーケンスIDより1つ多いCSA_SEQUENCEIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. Client ID confirmation. If this would be the first session for the client ID, the CREATE_SESSION operation serves to confirm the client ID. Otherwise, the client ID confirmation phase is skipped and only the session creation phase occurs. Any case in which there is more than one record with identical values for client ID represents a server implementation error. Operation in the potential valid cases is summarized as follows.",
      "ja": "3. クライアントIDの確認これがクライアントIDの最初のセッションになる場合、Create_Session操作はクライアントIDを確認するのに役立ちます。それ以外の場合、クライアントIDの確認フェーズはスキップされ、セッション作成フェーズのみが発生します。クライアントIDの同じ値を持つ1つ以上のレコードがある場合は、サーバー実装エラーを表します。潜在的な有効な場合の動作は次のようにまとめられています。"
    },
    {
      "indent": 7,
      "text": "* Successful Confirmation",
      "ja": "* 確認成功"
    },
    {
      "indent": 13,
      "text": "If the server has the following unconfirmed record, then this is the expected confirmation of an unconfirmed record.",
      "ja": "サーバーに次の未確認レコードがある場合、これは未確認レコードの予想確認です。"
    },
    {
      "indent": 13,
      "text": "{ ownerid, verifier, principal_arg, clientid_arg, unconfirmed }",
      "ja": "{OwnerID、Verifier、Principal_arg、ClientID_arg、未確認}"
    },
    {
      "indent": 13,
      "text": "As noted in Section 18.35.4, the server might also have the following confirmed record.",
      "ja": "18.35.4項で述べたように、サーバーは以下の確認されたレコードもあります。"
    },
    {
      "indent": 13,
      "text": "{ ownerid, old_verifier, principal_arg, old_clientid, confirmed }",
      "ja": "{OwnerId、Old_verifier、principal_arg、old_clientid、確認済み}"
    },
    {
      "indent": 13,
      "text": "The server schedules the replacement of both records with:",
      "ja": "サーバーは、両方のレコードの置き換えを次のものとします。"
    },
    {
      "indent": 13,
      "text": "{ ownerid, verifier, principal_arg, clientid_arg, confirmed }",
      "ja": "{OwnerID、Verifier、Principal_arg、ClientID_ARG、確認済み}"
    },
    {
      "indent": 13,
      "text": "The processing of CREATE_SESSION continues on to session creation. Once the session is successfully created, the scheduled client record replacement is committed. If the session is not successfully created, then no changes are made to any client records on the server.",
      "ja": "CREATE_SESSIONの処理はセッション作成に続行されます。セッションが正常に作成されると、スケジュールされたクライアントレコードの交換がコミットされます。セッションが正常に作成されなかった場合、サーバー上のクライアントレコードに変更は加えられません。"
    },
    {
      "indent": 7,
      "text": "* Unsuccessful Confirmation",
      "ja": "* 確認の失敗"
    },
    {
      "indent": 13,
      "text": "If the server has the following record, then the client has changed principals after the previous EXCHANGE_ID request, or there has been a chance collision between shorthand client identifiers.",
      "ja": "サーバーに次のレコードがある場合、クライアントは以前のExchange_ID要求の後にプリンシパルを変更しました。または、短距離クライアント識別子間の偶然の衝突がありました。"
    },
    {
      "indent": 13,
      "text": "{ *, *, old_principal_arg, clientid_arg, * }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Neither of these cases is permissible. Processing stops and NFS4ERR_CLID_INUSE is returned to the client. No changes are made to any client records on the server.",
      "ja": "どちらの場合も許容されません。処理停止とNFS4ERR_CLID_INUSEがクライアントに返されます。サーバー上のクライアントレコードに変更はありません。"
    },
    {
      "indent": 3,
      "text": "4. Session creation. The server confirmed the client ID, either in this CREATE_SESSION operation, or a previous CREATE_SESSION operation. The server examines the remaining fields of the arguments.",
      "ja": "4. セッションの作成サーバーは、このCREATE_SESSION操作、または前のCREATE_SESSION操作のいずれかで、クライアントIDを確認しました。サーバーは引数の残りのフィールドを調べます。"
    },
    {
      "indent": 7,
      "text": "The server creates the session by recording the parameter values used (including whether the CREATE_SESSION4_FLAG_PERSIST flag is set and has been accepted by the server) and allocating space for the session reply cache (if there is not enough space, the server returns NFS4ERR_NOSPC). For each slot in the reply cache, the server sets the sequence ID to zero, and records an entry containing a COMPOUND reply with zero operations and the error NFS4ERR_SEQ_MISORDERED. This way, if the first SEQUENCE request sent has a sequence ID equal to zero, the server can simply return what is in the reply cache: NFS4ERR_SEQ_MISORDERED. The client initializes its reply cache for receiving callbacks in the same way, and similarly, the first CB_SEQUENCE operation on a slot after session creation MUST have a sequence ID of one.",
      "ja": "使用されるパラメータ値を記録することによってサーバがセッションを作成し（CREATE_SESSION4_FLAG_PERSISTフラグが設定されているかどうかを含む）、セッションの応答キャッシュのスペースのスペースを割り当てている場合は、サーバーがNFS4R_NOSPCを返します）。返信キャッシュ内のスロットごとに、サーバはシーケンスIDをゼロに設定し、ゼロ操作で誤った演算を含むエントリとエラーNFS4ERR_SEQ_MISORDEREDを記録します。このように、送信された最初のシーケンス要求がゼロに等しいシーケンスIDを持つ場合、サーバーは単に返信キャッシュにあるものを返すことができます.nfs4err_seq_missorded。クライアントは、同じ方法でコールバックを受信するためにその応答キャッシュを初期化します。また、セッション作成後のスロット上の最初のCB_Sequenceオペレーションでは、シーケンスIDが1つあります。"
    },
    {
      "indent": 7,
      "text": "If the session state is created successfully, the server associates the session with the client ID provided by the client.",
      "ja": "セッション状態が正常に作成された場合、サーバーはセッションをクライアントから提供されたクライアントIDと関連付けます。"
    },
    {
      "indent": 7,
      "text": "When a request that had CREATE_SESSION4_FLAG_CONN_RDMA set needs to be retried, the retry MUST be done on a new connection that is in non-RDMA mode. If properties of the new connection are different enough that the arguments to CREATE_SESSION need to change, then a non-retry MUST be sent. The server will eventually dispose of any session that was created on the original connection.",
      "ja": "CREATE_SESSION4_FLAG_CONNN_RDMAセットを再試行する必要がある要求を実行する必要がある場合は、RETRYは、非RDMAモードにある新しい接続で実行する必要があります。CREATE_SESSIONの引数が変更される必要があるという新しい接続のプロパティが異なる場合は、非再試行を送信する必要があります。サーバーは最終的に元の接続に作成されたセッションを廃棄します。"
    },
    {
      "indent": 3,
      "text": "On the backchannel, the client and server might wish to have many slots, in some cases perhaps more that the fore channel, in order to deal with the situations where the network link has high latency and is the primary bottleneck for response to recalls. If so, and if the client provides too few slots to the backchannel, the server might limit the number of recallable objects it gives to the client.",
      "ja": "バックチャネルでは、クライアントとサーバーは、ネットワークリンクが待ち時間が高い状況に対処するために、多くのスロットを持つことをお勧めします。これは、ネットワークリンクが待ち時間が高い状況に対処し、リコール対応のための主なボトルネックです。もしそうなら、クライアントがバックチャネルにスロットが少なすぎる場合、サーバーはそれがクライアントに与えるリコール可能なオブジェクトの数を制限するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Implementing RPCSEC_GSS callback support requires changes to both the client and server implementations of RPCSEC_GSS. One possible set of changes includes:",
      "ja": "RPCSEC_GSSの実装コールバックサポートには、RPCSEC_GSSのクライアント実装とサーバーの両方の実装に変更が必要です。1つの変更の1つの変更には、次のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "* Adding a data structure that wraps the GSS-API context with a reference count.",
      "ja": "* GSS-APIコンテキストを参照カウントでラップするデータ構造を追加します。"
    },
    {
      "indent": 3,
      "text": "* New functions to increment and decrement the reference count. If the reference count is decremented to zero, the wrapper data structure and the GSS-API context it refers to would be freed.",
      "ja": "* 参照カウントを増減させるための新しい機能。参照カウントがゼロに分割された場合、ラッパーデータ構造とそれが参照するGSS-APIコンテキストは解放されます。"
    },
    {
      "indent": 3,
      "text": "* Change RPCSEC_GSS to create the wrapper data structure upon receiving GSS-API context from gss_accept_sec_context() and gss_init_sec_context(). The reference count would be initialized to 1.",
      "ja": "* GSS_ACCEPT_SEC_CONTEXT（）およびGSS_INIT_SEC_CONTEXT（）からGSS-APIコンテキストを受信したときにRPCSEC_GSSを変更してラッパー・データ構造を作成します。参照カウントは1に初期化されます。"
    },
    {
      "indent": 3,
      "text": "* Adding a function to map an existing RPCSEC_GSS handle to a pointer to the wrapper data structure. The reference count would be incremented.",
      "ja": "* 既存のRPCSEC_GSSハンドルをラッパーデータ構造へのポインタにマッピングする機能を追加します。参照カウントはインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "* Adding a function to create a new RPCSEC_GSS handle from a pointer to the wrapper data structure. The reference count would be incremented.",
      "ja": "* ポインタからラッパーデータ構造への新しいRPCSEC_GSSを作成するための関数を追加する。参照カウントはインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "* Replacing calls from RPCSEC_GSS that free GSS-API contexts, with calls to decrement the reference count on the wrapper data structure.",
      "ja": "* RPCSEC_GSSからの呼び出しを、GSS-APIコンテキストを使用して、ラッパー・データ構造の参照カウントを減らすための呼び出しを呼び出します。"
    },
    {
      "indent": 0,
      "text": "18.37. Operation 44: DESTROY_SESSION - Destroy a Session",
      "section_title": true,
      "ja": "18.37. 操作44：Destroy_Session  - セッションを破壊する"
    },
    {
      "indent": 0,
      "text": "18.37.1. ARGUMENT",
      "section_title": true,
      "ja": "18.37.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_SESSION4args {\n        sessionid4      dsa_sessionid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.37.2. RESULT",
      "section_title": true,
      "ja": "18.37.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_SESSION4res {\n        nfsstat4        dsr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.37.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.37.3. description"
    },
    {
      "indent": 3,
      "text": "The DESTROY_SESSION operation closes the session and discards the session's reply cache, if any. Any remaining connections associated with the session are immediately disassociated. If the connection has no remaining associated sessions, the connection MAY be closed by the server. Locks, delegations, layouts, wants, and the lease, which are all tied to the client ID, are not affected by DESTROY_SESSION.",
      "ja": "Destroy_Session操作はセッションを閉じてセッションの応答キャッシュを破棄します。セッションに関連付けられている残りの接続はすぐに関連付けられています。接続に関連するセッションが残っていない場合、接続はサーバーによって閉じられます。ロック、代表団、レイアウト、欲しいリース、すべてクライアントIDに関連付けられているリースは、Destroy_Sessionの影響を受けません。"
    },
    {
      "indent": 3,
      "text": "DESTROY_SESSION MUST be invoked on a connection that is associated with the session being destroyed. In addition, if SP4_MACH_CRED state protection was specified when the client ID was created, the RPCSEC_GSS principal that created the session MUST be the one that destroys the session, using RPCSEC_GSS privacy or integrity. If SP4_SSV state protection was specified when the client ID was created, RPCSEC_GSS using the SSV mechanism (Section 2.10.9) MUST be used, with integrity or privacy.",
      "ja": "Destroy_Sessionは、破棄されているセッションに関連付けられている接続で呼び出す必要があります。さらに、クライアントIDが作成されたときにSP4_MACH_CRED状態保護が指定されている場合、セッションを作成したRPCSEC_GSSプリンシパルは、RPCSEC_GSSプライバシーまたは整合性を使用して、セッションを破棄するものでなければなりません。クライアントIDが作成されたときにSP4_SSV状態保護が指定されている場合、整合性またはプライバシーを使用して、SSVメカニズム（セクション2.10.9）を使用したRPCSEC_GSSを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are the same, then",
      "ja": "複合要求がシーケンスで始まり、順序で指定されたSESSION_SESSIONが同じである場合は、"
    },
    {
      "indent": 3,
      "text": "* DESTROY_SESSION MUST be the final operation in the COMPOUND request.",
      "ja": "* Destroy_Sessionは、複合要求の最終操作でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* It is advisable to avoid placing DESTROY_SESSION in a COMPOUND request with other state-modifying operations, because the DESTROY_SESSION will destroy the reply cache.",
      "ja": "* Destroy_Sessionが返信キャッシュを破壊するため、他の状態変更操作で複合要求にDestroy_Sessionを配置することを避けることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Because the session and its reply cache are destroyed, a client that retries the request may receive an error in reply to the retry, even though the original request was successful.",
      "ja": "* セッションとその返信キャッシュが破壊されるため、元の要求が成功したとしても、リクエストを再試行するクライアントは再試行に応答してエラーを受け取ることがあります。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are different, then DESTROY_SESSION can appear in any position of the COMPOUND request (except for the first position). The two sessionids can belong to different client IDs.",
      "ja": "複合要求がシーケンスで始まり、順番およびDEASTER_SESSIONで指定されたSESSIONIDSIDが異なる場合は、DOREST_SESSIONは複合要求の任意の位置に表示されます（最初の位置を除く）。2つのSessionIdsは、さまざまなクライアントIDに属することができます。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request does not start with SEQUENCE, and if DESTROY_SESSION is not the sole operation, then server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "複合要求がシーケンスで起動しない場合、destroy_sessionがソール操作ではない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If there is a backchannel on the session and the server has outstanding CB_COMPOUND operations for the session which have not been replied to, then the server MAY refuse to destroy the session and return an error. If so, then in the event the backchannel is down, the server SHOULD return NFS4ERR_CB_PATH_DOWN to inform the client that the backchannel needs to be repaired before the server will allow the session to be destroyed. Otherwise, the error CB_BACK_CHAN_BUSY SHOULD be returned to indicate that there are CB_COMPOUNDs that need to be replied to. The client SHOULD reply to all outstanding CB_COMPOUNDs before re-sending DESTROY_SESSION.",
      "ja": "セッションにバックチャネルがある場合、サーバーに返信されていないセッションに対して優れたCB_COMPOUND操作がある場合、サーバーはセッションを破棄してエラーを返すことを拒否できます。もしそうであれば、バックチャネルがダウンした場合、サーバーはNFS4ERR_CB_PATH_DOWNを返して、サーバーがセッションを破棄できるようになる前にバックチャネルを修復する必要があることをクライアントに通知する必要があります。それ以外の場合、エラーcb_back_chan_busyは返信する必要があるCB_COMPOUNDSがあることを示すために返されるべきです。Destroy_Sessionを再送信する前に、クライアントはすべての未解決のCB_COMAUNDSに返信する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.38. Operation 45: FREE_STATEID - Free Stateid with No Locks",
      "section_title": true,
      "ja": "18.38. 操作45：Free_StateID  - ロックなしの無料StateID"
    },
    {
      "indent": 0,
      "text": "18.38.1. ARGUMENT",
      "section_title": true,
      "ja": "18.38.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct FREE_STATEID4args {\n        stateid4        fsa_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.38.2. RESULT",
      "section_title": true,
      "ja": "18.38.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct FREE_STATEID4res {\n        nfsstat4        fsr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.38.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.38.3. description"
    },
    {
      "indent": 3,
      "text": "The FREE_STATEID operation is used to free a stateid that no longer has any associated locks (including opens, byte-range locks, delegations, and layouts). This may be because of client LOCKU operations or because of server revocation. If there are valid locks (of any kind) associated with the stateid in question, the error NFS4ERR_LOCKS_HELD will be returned, and the associated stateid will not be freed.",
      "ja": "Free_StateID操作は、関連するロック（オープン、バイトレンジロック、委任、およびレイアウトを含む）がなくなったStateIDを解放するために使用されます。これは、クライアントLocku操作またはサーバーの失効によるものである可能性があります。問題のStateIDに関連付けられている有効なロックがある場合は、エラーNFS4ERR_LOCKS_HELDが返され、関連するStareIDは解放されません。"
    },
    {
      "indent": 3,
      "text": "When a stateid is freed that had been associated with revoked locks, by sending the FREE_STATEID operation, the client acknowledges the loss of those locks. This allows the server, once all such revoked state is acknowledged, to allow that client again to reclaim locks, without encountering the edge conditions discussed in Section 8.4.2.",
      "ja": "stateIDが失効されたロックに関連付けられていた解放された場合、Free_StateID操作を送信することによって、クライアントはそれらのロックの損失を確認します。これにより、このような失効状態がすべて承認されたら、そのクライアントがロックを再生することを許可すると、セクション8.4.2で説明したエッジ条件に遭遇することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Once a successful FREE_STATEID is done for a given stateid, any subsequent use of that stateid will result in an NFS4ERR_BAD_STATEID error.",
      "ja": "与えられたstateIDに対してfree_stateIDが成功したら、その後のStateIDを使用してもNFS4ERR_BAD_STATEIDエラーになります。"
    },
    {
      "indent": 0,
      "text": "18.39. Operation 46: GET_DIR_DELEGATION - Get a Directory Delegation",
      "section_title": true,
      "ja": "18.39. 操作46：get_dir_delegation  - ディレクトリ委任を取得します"
    },
    {
      "indent": 0,
      "text": "18.39.1. ARGUMENT",
      "section_title": true,
      "ja": "18.39.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef nfstime4 attr_notice4;",
      "ja": "typedef nfstime4 attr_notice4;"
    },
    {
      "indent": 3,
      "text": "struct GET_DIR_DELEGATION4args {\n        /* CURRENT_FH: delegated directory */\n        bool            gdda_signal_deleg_avail;\n        bitmap4         gdda_notification_types;\n        attr_notice4    gdda_child_attr_delay;\n        attr_notice4    gdda_dir_attr_delay;\n        bitmap4         gdda_child_attributes;\n        bitmap4         gdda_dir_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.39.2. RESULT",
      "section_title": true,
      "ja": "18.39.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GET_DIR_DELEGATION4resok {\n        verifier4       gddr_cookieverf;\n        /* Stateid for get_dir_delegation */\n        stateid4        gddr_stateid;\n        /* Which notifications can the server support */\n        bitmap4         gddr_notification;\n        bitmap4         gddr_child_attributes;\n        bitmap4         gddr_dir_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum gddrnf4_status {\n        GDD4_OK         = 0,\n        GDD4_UNAVAIL    = 1\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GET_DIR_DELEGATION4res_non_fatal\n switch (gddrnf4_status gddrnf_status) {\n case GDD4_OK:\n  GET_DIR_DELEGATION4resok      gddrnf_resok4;\n case GDD4_UNAVAIL:\n  bool                          gddrnf_will_signal_deleg_avail;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GET_DIR_DELEGATION4res\n switch (nfsstat4 gddr_status) {\n case NFS4_OK:\n  GET_DIR_DELEGATION4res_non_fatal      gddr_res_non_fatal4;\n default:\n  void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.39.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.39.3. description"
    },
    {
      "indent": 3,
      "text": "The GET_DIR_DELEGATION operation is used by a client to request a directory delegation. The directory is represented by the current filehandle. The client also specifies whether it wants the server to notify it when the directory changes in certain ways by setting one or more bits in a bitmap. The server may refuse to grant the delegation. In that case, the server will return NFS4ERR_DIRDELEG_UNAVAIL. If the server decides to hand out the delegation, it will return a cookie verifier for that directory. If the cookie verifier changes when the client is holding the delegation, the delegation will be recalled unless the client has asked for notification for this event.",
      "ja": "get_dir_delegation操作は、ディレクトリ委任を要求するためにクライアントによって使用されます。ディレクトリは現在のファイルハンドルによって表されます。また、ビットマップに1つ以上のビットを設定することで、ディレクトリが特定の方法で変更されたときにサーバーに通知するかどうかを指定します。サーバーは委任を許可することを拒否することがあります。その場合、サーバーはNFS4ERR_DIRDELEG_UNAVAILを返します。サーバーが委任を引き出すことを決定した場合、そのディレクトリのCookie Verifierを返します。クライアントが委任を保持しているときにCookie Verifierが変更された場合、クライアントがこのイベントの通知を要求していない限り、委任は呼び出されます。"
    },
    {
      "indent": 3,
      "text": "The server will also return a directory delegation stateid, gddr_stateid, as a result of the GET_DIR_DELEGATION operation. This stateid will appear in callback messages related to the delegation, such as notifications and delegation recalls. The client will use this stateid to return the delegation voluntarily or upon recall. A delegation is returned by calling the DELEGRETURN operation.",
      "ja": "GET_DIR_DELEGATION操作の結果として、サーバーはディレクトリ委任StateID GDDR_STATEIDを返します。このStateIDは、通知や委任の呼び出しなど、委任に関連するコールバックメッセージに表示されます。クライアントはこのStateIDを使用して委任を自発的にまたはリコールして返信します。DELEGReturn操作を呼び出すことによって委任が返されます。"
    },
    {
      "indent": 3,
      "text": "The server might not be able to support notifications of certain events. If the client asks for such notifications, the server MUST inform the client of its inability to do so as part of the GET_DIR_DELEGATION reply by not setting the appropriate bits in the supported notifications bitmask, gddr_notification, contained in the reply. The server MUST NOT add bits to gddr_notification that the client did not request.",
      "ja": "サーバーは特定のイベントの通知をサポートできない可能性があります。クライアントがそのような通知を要求した場合、サーバーは、返信に含まれているサポートされている通知ビットマスク、GDDR_Notificationの適切なビットを設定しないことで、get_dir_delegation応答の一部として、クライアントに提供できないことをクライアントに通知する必要があります。サーバーは、クライアントが要求しなかったことをGDDR_Notificationにビットを追加してはいけません。"
    },
    {
      "indent": 3,
      "text": "The GET_DIR_DELEGATION operation can be used for both normal and named attribute directories.",
      "ja": "GET_DIR_DELEGATION操作は、通常の属性ディレクトリと名前付き属性ディレクトリの両方に使用できます。"
    },
    {
      "indent": 3,
      "text": "If client sets gdda_signal_deleg_avail to TRUE, then it is registering with the client a \"want\" for a directory delegation. If the delegation is not available, and the server supports and will honor the \"want\", the results will have gddrnf_will_signal_deleg_avail set to TRUE and no error will be indicated on return. If so, the client should expect a future CB_RECALLABLE_OBJ_AVAIL operation to indicate that a directory delegation is available. If the server does not wish to honor the \"want\" or is not able to do so, it returns the error NFS4ERR_DIRDELEG_UNAVAIL. If the delegation is immediately available, the server SHOULD return it with the response to the operation, rather than via a callback.",
      "ja": "クライアントがgdda_signal_deleg_availをtrueに設定した場合、それはディレクトリ委任に対して「欲しい」をクライアントに登録します。委任が利用できず、サーバーが「希望」をサポートしている場合、結果はGDDRNF_WILL_SIGNAL_DELEG_AVAILをTRUEに設定され、returnにはエラーは表示されません。もしそうであれば、クライアントは将来のcb_recallable_obj_avail操作を期待して、ディレクトリの委任が利用可能であることを示すべきです。サーバーが「希望」を尊重したくないか、そうすることができない場合は、エラーNFS4ERR_DIRDELEG_UNAVAILを返します。委任がすぐに利用可能な場合、サーバーはコールバックを介してではなく、操作に対する応答を返すべきです。"
    },
    {
      "indent": 3,
      "text": "When a client makes a request for a directory delegation while it already holds a directory delegation for that directory (including the case where it has been recalled but not yet returned by the client or revoked by the server), the server MUST reply with the value of gddr_status set to NFS4_OK, the value of gddrnf_status set to GDD4_UNAVAIL, and the value of gddrnf_will_signal_deleg_avail set to FALSE. The delegation the client held before the request remains intact, and its state is unchanged. The current stateid is not changed (see Section 16.2.3.1.2 for a description of the current stateid).",
      "ja": "クライアントがすでにそのディレクトリのディレクトリの委任を保持している間にディレクトリの委任を要求する場合（呼び出されたがまだクライアントによって返されていない場合、またはサーバーによって取り消されていない場合）、サーバーはその値で返信する必要があります。GDD4_OKに設定されているGDDR_STATUSに設定され、GDD4_UNAVAILに設定されたGDDRNF_STATUSの値と、GDDRNF_WILL_SIGNAL_DELEG_AVAILがFALSEに設定されています。委任は、要求が無傷のままであり、その状態は変わらない。現在のStateIDは変更されません（現在のStateIDの説明については、16.2.3.1.2項を参照）。"
    },
    {
      "indent": 0,
      "text": "18.39.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.39.4. 実装"
    },
    {
      "indent": 3,
      "text": "Directory delegations provide the benefit of improving cache consistency of namespace information. This is done through synchronous callbacks. A server must support synchronous callbacks in order to support directory delegations. In addition to that, asynchronous notifications provide a way to reduce network traffic as well as improve client performance in certain conditions.",
      "ja": "ディレクトリの代表団は、名前空間情報のキャッシュの一貫性を改善することの利点を提供します。これは同期コールバックを通して行われます。ディレクトリの委任をサポートするためにサーバーが同期コールバックをサポートしている必要があります。それに加えて、非同期通知はネットワークトラフィックを減らす方法と特定の条件でクライアントのパフォーマンスを向上させる方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Notifications are specified in terms of potential changes to the directory. A client can ask to be notified of events by setting one or more bits in gdda_notification_types. The client can ask for notifications on addition of entries to a directory (by setting the NOTIFY4_ADD_ENTRY in gdda_notification_types), notifications on entry removal (NOTIFY4_REMOVE_ENTRY), renames (NOTIFY4_RENAME_ENTRY), directory attribute changes (NOTIFY4_CHANGE_DIR_ATTRIBUTES), and cookie verifier changes (NOTIFY4_CHANGE_COOKIE_VERIFIER) by setting one or more corresponding bits in the gdda_notification_types field.",
      "ja": "通知はディレクトリへの潜在的な変更点で指定されます。クライアントは、GDDA_Notification_Typesで1つ以上のビットを設定することによってイベントを通知するように依頼することができます。クライアントは、（GDDA_Notification_TypesでNotify4_ADD_ENTRYを設定することによって）ディレクトリへのエントリの追加、エントリ削除（Notify4_Remove_Entry）、名前の変更（Notify4_Remove_Entry）、ディレクトリ属性の変更（Notify4_Change_DIR_ATTRIBUIEFIER）、およびCookie Verifierの変更（Notify4_Chookie_Verifier）gdda_notification_typesフィールドに1つ以上のビットを設定します。"
    },
    {
      "indent": 3,
      "text": "The client can also ask for notifications of changes to attributes of directory entries (NOTIFY4_CHANGE_CHILD_ATTRIBUTES) in order to keep its attribute cache up to date. However, any changes made to child attributes do not cause the delegation to be recalled. If a client is interested in directory entry caching or negative name caching, it can set the gdda_notification_types appropriately to its particular need and the server will notify it of all changes that would otherwise invalidate its name cache. The kind of notification a client asks for may depend on the directory size, its rate of change, and the applications being used to access that directory. The enumeration of the conditions under which a client might ask for a notification is out of the scope of this specification.",
      "ja": "クライアントは、属性キャッシュを最新の状態に保つために、ディレクトリエントリ（Notify4_Change_Child_Attributes）の属性への変更の通知を要求することもできます。ただし、子属性に加えられた変更は、委任を呼び出すことはありません。クライアントがディレクトリエントリキャッシュまたはマイナスネームキャッシュに関心がある場合は、gdda_notification_typesをその特定の必要性に適切に設定し、サーバーはその名前のキャッシュを無効にするであろうすべての変更について通知できます。クライアントは、ディレクトリのサイズ、その変更率、およびそのディレクトリにアクセスするために使用されているアプリケーションによって異なります。クライアントが通知を要求する可能性がある条件の列挙は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "For attribute notifications, the client will set bits in the gdda_dir_attributes bitmap to indicate which attributes it wants to be notified of. If the server does not support notifications for changes to a certain attribute, it SHOULD NOT set that attribute in the supported attribute bitmap specified in the reply (gddr_dir_attributes). The client will also set in the gdda_child_attributes bitmap the attributes of directory entries it wants to be notified of, and the server will indicate in gddr_child_attributes which attributes of directory entries it will notify the client of.",
      "ja": "属性通知の場合、クライアントはGDDA_DIR_ATTRIBUTESビットマップでビットを設定して、通知が必要な属性を示します。サーバーが特定の属性への変更に対する通知をサポートしていない場合は、返信（GDDR_DIR_ATTRIBUTES）で指定されたサポートされている属性ビットマップにその属性を設定しないでください。クライアントはGDDA_CHILD_ATTRIBUTESビットマップに設定されます。通知したいディレクトリエントリの属性、およびサーバーは、ディレクトリエントリの属性をgddr_child_attributesに指定します。"
    },
    {
      "indent": 3,
      "text": "The client will also let the server know if it wants to get the notification as soon as the attribute change occurs or after a certain delay by setting a delay factor; gdda_child_attr_delay is for attribute changes to directory entries and gdda_dir_attr_delay is for attribute changes to the directory. If this delay factor is set to zero, that indicates to the server that the client wants to be notified of any attribute changes as soon as they occur. If the delay factor is set to N seconds, the server will make a best-effort guarantee that attribute updates are synchronized within N seconds. If the client asks for a delay factor that the server does not support or that may cause significant resource consumption on the server by causing the server to send a lot of notifications, the server should not commit to sending out notifications for attributes and therefore must not set the appropriate bit in the gddr_child_attributes and gddr_dir_attributes bitmaps in the response.",
      "ja": "クライアントはまた、属性の変更が発生したらすぐに、または遅延係数を設定することによって特定の遅延の後に通知を取得したいかどうかをサーバに知らせます。GDDA_CHILD_ATTR_DELAYはディレクトリエントリへの属性の変更のためのもので、GDDA_DIR_ATTR_DELAYはディレクトリへの属性の変更です。この遅延係数がゼロに設定されている場合、それはクライアントが発生したらすぐに属性の変更を通知したいサーバに表示されます。遅延係数がn秒に設定されている場合、サーバーは属性の更新がn秒以内に同期されるというベストエフォートを保証します。サーバーがサーバーに多くの通知を送信させてサーバー上でサーバー上で重要なリソース消費を引き起こす可能性がある場合、クライアントがサーバー上で大きなリソース消費を引き起こす可能性がある場合、サーバーは属性の通知の送信をコミットしないでください。応答のGDDR_CHILD_ATTRIBUTESおよびGDDR_DIR_ATTRIBUTESビットマップの適切なビットを設定します。"
    },
    {
      "indent": 3,
      "text": "The client MUST use a security tuple (Section 2.6.1) that the directory or its applicable ancestor (Section 2.6) is exported with. If not, the server MUST return NFS4ERR_WRONGSEC to the operation that both precedes GET_DIR_DELEGATION and sets the current filehandle (see Section 2.6.3.1).",
      "ja": "クライアントは、ディレクトリまたはその該当する先祖（セクション2.6）がエクスポートされているセキュリティタプル（セクション2.6.1）を使用する必要があります。そうでない場合、サーバーはNFS4ERR_WRONGSECを実行しなければなりません。どちらもGET_DIR_DELEGATIONの両方に、現在のFileHandleを設定します（セクション2.6.3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The directory delegation covers all the entries in the directory except the parent entry. That means if a directory and its parent both hold directory delegations, any changes to the parent will not cause a notification to be sent for the child even though the child's parent entry points to the parent directory.",
      "ja": "ディレクトリの委任は、親エントリを除くディレクトリ内のすべてのエントリをカバーします。つまり、ディレクトリとその親の両方がディレクトリの委任を保持している場合は、子の親エントリが親ディレクトリを指していても、親への変更はその子に通知を送信させません。"
    },
    {
      "indent": 0,
      "text": "18.40. Operation 47: GETDEVICEINFO - Get Device Information",
      "section_title": true,
      "ja": "18.40. 操作47：getDeviceInfo  - デバイス情報を取得します"
    },
    {
      "indent": 0,
      "text": "18.40.1. ARGUMENT",
      "section_title": true,
      "ja": "18.40.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICEINFO4args {\n        deviceid4       gdia_device_id;\n        layouttype4     gdia_layout_type;\n        count4          gdia_maxcount;\n        bitmap4         gdia_notify_types;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.40.2. RESULT",
      "section_title": true,
      "ja": "18.40.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICEINFO4resok {\n        device_addr4    gdir_device_addr;\n        bitmap4         gdir_notification;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GETDEVICEINFO4res switch (nfsstat4 gdir_status) {\ncase NFS4_OK:\n        GETDEVICEINFO4resok     gdir_resok4;\ncase NFS4ERR_TOOSMALL:\n        count4                  gdir_mincount;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.40.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.40.3. description"
    },
    {
      "indent": 3,
      "text": "The GETDEVICEINFO operation returns pNFS storage device address information for the specified device ID. The client identifies the device information to be returned by providing the gdia_device_id and gdia_layout_type that uniquely identify the device. The client provides gdia_maxcount to limit the number of bytes for the result. This maximum size represents all of the data being returned within the GETDEVICEINFO4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return any information within the gdia_maxcount limit, the error NFS4ERR_TOOSMALL will be returned. However, if gdia_maxcount is zero, NFS4ERR_TOOSMALL MUST NOT be returned.",
      "ja": "getDeviceInfo操作は、指定された機器IDのPNFS記憶装置のアドレス情報を返します。クライアントは、デバイスを一意に識別するgdia_device_idおよびgdia_layout_typeを提供することによって返されるデバイス情報を識別します。クライアントはGDIA_MAXCOUNTを提供して結果のバイト数を制限します。この最大サイズは、getDeviceInfo4Resok構造内に返されるすべてのデータを表し、XDRオーバーヘッドを含みます。サーバーはデータが少ないデータを返すことがあります。サーバーがGDIA_MAXCOUNT制限内の情報を返すことができない場合は、エラーNFS4ERR_TOOSMALLが返されます。ただし、gdia_maxcountがゼロの場合、NFS4ERR_TOOSMALLは返されてはいけません。"
    },
    {
      "indent": 3,
      "text": "The da_layout_type field of the gdir_device_addr returned by the server MUST be equal to the gdia_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the server returned an error, even if the client does have support for the layout type returned.",
      "ja": "サーバーによって返されるGDIR_DEVICE_ADDRのDA_LAYOUT_TYPEフィールドは、クライアントによって指定されたgdia_layout_typeに等しくなければなりません。等しくない場合、クライアントは無効として応答を無効にし、クライアントが返されたレイアウトタイプのサポートがある場合でも、サーバーがエラーを返した場合と同じくらい動作します。"
    },
    {
      "indent": 3,
      "text": "The client also provides a notification bitmap, gdia_notify_types, for the device ID mapping notification for which it is interested in receiving; the server must support device ID notifications for the notification request to have affect. The notification mask is composed in the same manner as the bitmap for file attributes (Section 3.3.7). The numbers of bit positions are listed in the notify_device_type4 enumeration type (Section 20.12). Only two enumerated values of notify_device_type4 currently apply to GETDEVICEINFO: NOTIFY_DEVICEID4_CHANGE and NOTIFY_DEVICEID4_DELETE (see Section 20.12).",
      "ja": "クライアントはまた、受信に関心があるデバイスIDマッピング通知のために、通知ビットマップgdia_notify_typesを提供します。サーバーは、影響を与えるために通知要求のためのデバイスID通知をサポートする必要があります。通知マスクは、ファイル属性のビットマップと同じ方法で構成されています（セクション3.3.7）。ビット位置の数は、NOTIFY_DEVICE_TYPE4列挙型（セクション20.12）にリストされています。現在GetDeviceInfoに適用されているNOTIFY_DEVICE_TYPE4の列挙された値は2つだけです.NOTIFY_DEVICEID4_CHANGEおよびNOTIFY_DEVICEID4_DELETE（セクション20.12を参照）。"
    },
    {
      "indent": 3,
      "text": "The notification bitmap applies only to the specified device ID. If a client sends a GETDEVICEINFO operation on a deviceID multiple times, the last notification bitmap is used by the server for subsequent notifications. If the bitmap is zero or empty, then the device ID's notifications are turned off.",
      "ja": "通知ビットマップは、指定されたデバイスIDにのみ適用されます。クライアントがDeviceIDで複数回getDeviceInfo操作を送信した場合、最後の通知ビットマップは後続の通知のためにサーバーによって使用されます。ビットマップがゼロまたは空の場合、デバイスIDの通知はオフになります。"
    },
    {
      "indent": 3,
      "text": "If the client wants to just update or turn off notifications, it MAY send a GETDEVICEINFO operation with gdia_maxcount set to zero. In that event, if the device ID is valid, the reply's da_addr_body field of the gdir_device_addr field will be of zero length.",
      "ja": "クライアントが通知を更新またはオフにしたい場合は、GDIA_MAXCOUNTを使用してGetDeviceInfo操作をゼロに送信することができます。その場合、デバイスIDが有効な場合は、GDIR_DEVICE_ADDRフィールドの応答のDA_ADDR_BODYフィールドはゼロの長さになります。"
    },
    {
      "indent": 3,
      "text": "If an unknown device ID is given in gdia_device_id, the server returns NFS4ERR_NOENT. Otherwise, the device address information is returned in gdir_device_addr. Finally, if the server supports notifications for device ID mappings, the gdir_notification result will contain a bitmap of which notifications it will actually send to the client (via CB_NOTIFY_DEVICEID, see Section 20.12).",
      "ja": "未知のデバイスIDがgdia_device_idで指定されている場合、サーバーはNFS4ERR_NOENTを返します。それ以外の場合、デバイスアドレス情報はGDIR_DEVICE_ADDRで返されます。最後に、サーバーがデバイスIDマッピングの通知をサポートしている場合、GDIR_Notificationの結果に、実際に実際にクライアントに送信される通知のビットマップが含まれます（CB_NOTIFY_DEVICEIDを介してセクション20.12を参照）。"
    },
    {
      "indent": 3,
      "text": "If NFS4ERR_TOOSMALL is returned, the results also contain gdir_mincount. The value of gdir_mincount represents the minimum size necessary to obtain the device information.",
      "ja": "nfs4err_toosmallが返されると、結果にgdir_mincountも含まれています。gdir_mincountの値は、デバイス情報を取得するために必要な最小サイズを表します。"
    },
    {
      "indent": 0,
      "text": "18.40.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.40.4. 実装"
    },
    {
      "indent": 3,
      "text": "Aside from updating or turning off notifications, another use case for gdia_maxcount being set to zero is to validate a device ID.",
      "ja": "通知の更新またはオフの電源を切ることから、ゼロに設定されているgdia_maxcountの別のユースケースは、デバイスIDを検証することです。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD request a notification for changes or deletion of a device ID to device address mapping so that the server can allow the client gracefully use a new mapping, without having pending I/O fail abruptly, or force layouts using the device ID to be recalled or revoked.",
      "ja": "クライアントは、I / Oが突然解決されないように、I / Oが突然解決されずにクライアントが新しいマッピングを正常に使用できるように、デバイスIDの変更または削除の通知をデバイスアドレスマッピングに要求する必要があります。リコールまたは取り消されました。"
    },
    {
      "indent": 3,
      "text": "It is possible that GETDEVICEINFO (and GETDEVICELIST) will race with CB_NOTIFY_DEVICEID, i.e., CB_NOTIFY_DEVICEID arrives before the client gets and processes the response to GETDEVICEINFO or GETDEVICELIST. The analysis of the race leverages the fact that the server MUST NOT delete a device ID that is referred to by a layout the client has.",
      "ja": "getDeviceInfo（およびgetDeviceList）がCB_NOTIFY_DEVICEIDとRACEを競合することは、クライアントがGetDeviceInfoまたはGetDeviceListへの応答を取得して処理する前に到着します。レースの分析は、サーバーがクライアントが持っているレイアウトによって参照されるデバイスIDを削除してはいけないという事実を活用します。"
    },
    {
      "indent": 3,
      "text": "* CB_NOTIFY_DEVICEID deletes a device ID. If the client believes it has layouts that refer to the device ID, then it is possible that layouts referring to the deleted device ID have been revoked. The client should send a TEST_STATEID request using the stateid for each layout that might have been revoked. If TEST_STATEID indicates that any layouts have been revoked, the client must recover from layout revocation as described in Section 12.5.6. If TEST_STATEID indicates that at least one layout has not been revoked, the client should send a GETDEVICEINFO operation on the supposedly deleted device ID to verify that the device ID has been deleted.",
      "ja": "* CB_NOTIFY_DEVICEIDデバイスIDを削除します。クライアントがデバイスIDを参照するレイアウトがあると考えている場合は、削除されたデバイスIDを参照しているレイアウトが失効された可能性があります。クライアントは、失効された可能性がある各レイアウトのStateIDを使用してTEST_STATEIDリクエストを送信する必要があります。test_stateIdがレイアウトが失効されたことを示す場合、クライアントはセクション12.5.6で説明されているようにレイアウト失効から回復する必要があります。test_stateIdが少なくとも1つのレイアウトが失効されていないことを示す場合、クライアントは、デバイスIDが削除されたことを確認するために、削除されたデバイスIDに対してGetDeviceInfo操作を送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "If GETDEVICEINFO indicates that the device ID does not exist, then the client assumes the server is faulty and recovers by sending an EXCHANGE_ID operation. If GETDEVICEINFO indicates that the device ID does exist, then while the server is faulty for sending an erroneous device ID deletion notification, the degree to which it is faulty does not require the client to create a new client ID.",
      "ja": "getDeviceInfoがデバイスIDが存在しないことを示す場合、クライアントはサーバーが故障していると見なし、Exchange_ID操作を送信することによって回復します。getDeviceInfoがデバイスIDが存在することを示している場合、サーバーが誤ったデバイスID削除通知を送信するために故障している間に、故障している程度はクライアントが新しいクライアントIDを作成する必要はありません。"
    },
    {
      "indent": 6,
      "text": "If the client does not have layouts that refer to the device ID, no harm is done. The client should mark the device ID as deleted, and when GETDEVICEINFO or GETDEVICELIST results are received that indicate that the device ID has been in fact deleted, the device ID should be removed from the client's cache.",
      "ja": "クライアントにデバイスIDを参照するレイアウトがない場合、害はなくなります。クライアントはデバイスIDを削除済みとしてマークする必要があり、デバイスIDが実際に削除されていることを示すGetDeviceInfoまたはGetDeviceListの結果を受信する必要があります。デバイスIDをクライアントのキャッシュから削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "* CB_NOTIFY_DEVICEID indicates that a device ID's device addressing mappings have changed. The client should assume that the results from the in-progress GETDEVICEINFO will be stale for the device ID once received, and so it should send another GETDEVICEINFO on the device ID.",
      "ja": "* CB_NOTIFY_DEVICEIDデバイスIDのマッピングが変更されたことを示します。クライアントは、In-Progress GetDeviceInfoからの結果が受信したデバイスIDに対して古くなることを前提としているため、デバイスIDに別のgetDeviceInfoを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.41. Operation 48: GETDEVICELIST - Get All Device Mappings for a File System",
      "ja": "18.41. 操作48：getDeviceList  - ファイルシステムのすべてのデバイスマッピングを取得する"
    },
    {
      "indent": 0,
      "text": "18.41.1. ARGUMENT",
      "section_title": true,
      "ja": "18.41.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICELIST4args {\n        /* CURRENT_FH: object belonging to the file system */\n        layouttype4     gdla_layout_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* number of deviceIDs to return */\ncount4          gdla_maxdevices;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        nfs_cookie4     gdla_cookie;\n        verifier4       gdla_cookieverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.41.2. RESULT",
      "section_title": true,
      "ja": "18.41.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICELIST4resok {\n        nfs_cookie4             gdlr_cookie;\n        verifier4               gdlr_cookieverf;\n        deviceid4               gdlr_deviceid_list<>;\n        bool                    gdlr_eof;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {\ncase NFS4_OK:\n        GETDEVICELIST4resok     gdlr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.41.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.41.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is used by the client to enumerate all of the device IDs that a server's file system uses.",
      "ja": "この操作は、サーバーのファイルシステムが使用するすべてのデバイスIDを列挙するためにクライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "The client provides a current filehandle of a file object that belongs to the file system (i.e., all file objects sharing the same fsid as that of the current filehandle) and the layout type in gdia_layout_type. Since this operation might require multiple calls to enumerate all the device IDs (and is thus similar to the READDIR (Section 18.23) operation), the client also provides gdia_cookie and gdia_cookieverf to specify the current cursor position in the list. When the client wants to read from the beginning of the file system's device mappings, it sets gdla_cookie to zero. The field gdla_cookieverf MUST be ignored by the server when gdla_cookie is zero. The client provides gdla_maxdevices to limit the number of device IDs in the result. If gdla_maxdevices is zero, the server MUST return NFS4ERR_INVAL. The server MAY return fewer device IDs.",
      "ja": "クライアントは、ファイルシステムに属するファイルオブジェクトの現在のファイルハンドル（すなわち、現在のファイルハンドルと同じFSIDを共有するすべてのファイルオブジェクト）とgdia_layout_type内のレイアウト型を提供します。この操作にはすべてのデバイスIDを列挙するために複数の呼び出しが必要な場合があります（したがって、READDIR（セクション18.23）操作と似ています）、クライアントはGDIA_COOKIEとGDIA_COOKIEVERFをリスト内の現在のカーソル位置を指定します。クライアントがファイルシステムのデバイスマッピングの先頭から読み込みたい場合は、gdla_cookieをゼロに設定します。gdla_cookieがゼロのとき、フィールドGDLA_CookieVerffはサーバーによって無視される必要があります。クライアントはGDLA_MAXデバイスを提供して結果のデバイスIDの数を制限します。gdla_maxDevicesがゼロの場合、サーバーはNFS4ERR_INVALを返す必要があります。サーバーはより少ないデバイスIDを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "The successful response to the operation will contain the cookie, gdlr_cookie, and the cookie verifier, gdlr_cookieverf, to be used on the subsequent GETDEVICELIST. A gdlr_eof value of TRUE signifies that there are no remaining entries in the server's device list. Each element of gdlr_deviceid_list contains a device ID.",
      "ja": "操作に対する対応の成功には、Cookie、GDLR_COOKIE、およびその後のGetDeviceListで使用されるCookie Verifier GDLR_CookieVerfが含まれます。gdlr_eof値は、サーバーのデバイスリストに残りのエントリがないことを意味します。GDLR_DEVICEID_LISTの各要素には、デバイスIDが含まれています。"
    },
    {
      "indent": 0,
      "text": "18.41.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.41.4. 実装"
    },
    {
      "indent": 3,
      "text": "An example of the use of this operation is for pNFS clients and servers that use LAYOUT4_BLOCK_VOLUME layouts. In these environments it may be helpful for a client to determine device accessibility upon first file system access.",
      "ja": "この操作の使用例は、Layout4_block_Volumeレイアウトを使用するPNFSクライアントおよびサーバー用です。これらの環境では、クライアントが最初のファイルシステムアクセス時にデバイスのアクセシビリティを判断するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a Layout",
      "section_title": true,
      "ja": "18.42. 操作49：LayoutCommit  - レイアウトを使用して行われたコミット書き込み"
    },
    {
      "indent": 0,
      "text": "18.42.1. ARGUMENT",
      "section_title": true,
      "ja": "18.42.1. 引数"
    },
    {
      "indent": 3,
      "text": "union newtime4 switch (bool nt_timechanged) {\ncase TRUE:\n        nfstime4           nt_time;\ncase FALSE:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union newoffset4 switch (bool no_newoffset) {\ncase TRUE:\n        offset4           no_offset;\ncase FALSE:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LAYOUTCOMMIT4args {\n        /* CURRENT_FH: file */\n        offset4                 loca_offset;\n        length4                 loca_length;\n        bool                    loca_reclaim;\n        stateid4                loca_stateid;\n        newoffset4              loca_last_write_offset;\n        newtime4                loca_time_modify;\n        layoutupdate4           loca_layoutupdate;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.42.2. RESULT",
      "section_title": true,
      "ja": "18.42.2. 結果"
    },
    {
      "indent": 3,
      "text": "union newsize4 switch (bool ns_sizechanged) {\ncase TRUE:\n        length4         ns_size;\ncase FALSE:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LAYOUTCOMMIT4resok {\n        newsize4                locr_newsize;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LAYOUTCOMMIT4res switch (nfsstat4 locr_status) {\ncase NFS4_OK:\n        LAYOUTCOMMIT4resok      locr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.42.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.42.3. description"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation commits changes in the layout represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte-range, and stateid. Since layouts are sub-dividable, a smaller portion of a layout, retrieved via LAYOUTGET, can be committed. The byte-range being committed is specified through the byte-range (loca_offset and loca_length). This byte-range MUST overlap with one or more existing layouts previously granted via LAYOUTGET (Section 18.43), each with an iomode of LAYOUTIOMODE4_RW. In the case where the iomode of any held layout segment is not LAYOUTIOMODE4_RW, the server should return the error NFS4ERR_BAD_IOMODE. For the case where the client does not hold matching layout segment(s) for the defined byte-range, the server should return the error NFS4ERR_BAD_LAYOUT.",
      "ja": "LayoutCommitオペレーションは、現在のファイルハンドル、クライアントID（前のシーケンス操作のセッションIDから派生）、バイトレンジ、およびStateIDによって表されるレイアウトの変更をコミットします。レイアウトは副分割可能であるため、レイアウトの小さい部分がレイアウトを介して取得され、コミットすることができます。コミットされているバイトレンジは、バイト範囲（LOCA_OFFSETおよびLOCA_LENGTH）を通して指定されます。このバイト範囲は、それぞれLayOutioMode4_RWのIOMODEを持つ、以前はLayoutgetを介して予め付与された1つ以上の既存のレイアウトと重複していなければなりません（セクション18.43）。保持されているレイアウトセグメントのIOMODEがlayoutioMode4_rwではない場合、サーバーはエラーNFS4ERR_BAD_IOMODEを返す必要があります。クライアントが定義されたバイト範囲に対して一致するレイアウトセグメントを保持していない場合、サーバーはエラーNFS4ERR_BAD_LAYOUTを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation indicates that the client has completed writes using a layout obtained by a previous LAYOUTGET. The client may have only written a subset of the data range it previously requested. LAYOUTCOMMIT allows it to commit or discard provisionally allocated space and to update the server with a new end-of-file. The layout referenced by LAYOUTCOMMIT is still valid after the operation completes and can be continued to be referenced by the client ID, filehandle, byte-range, layout type, and stateid.",
      "ja": "LayoutCommit操作は、前のレイアウトによって取得されたレイアウトを使用してクライアントが書き込みを完了したことを示します。クライアントは、以前に要求されたデータ範囲のサブセットのみを書き込んだことがあります。LayoutCommitでは、仮割り当てスペースをコミットまたは破棄し、新しいファイルの新しい終わりを持つサーバーを更新できます。LayoutCommitによって参照されるレイアウトは、操作が完了した後も有効であり、クライアントID、FileHandle、Byte-Range、Layout Type、およびStareIDによって参照され続けることができます。"
    },
    {
      "indent": 3,
      "text": "If the loca_reclaim field is set to TRUE, this indicates that the client is attempting to commit changes to a layout after the restart of the metadata server during the metadata server's recovery grace period (see Section 12.7.4). This type of request may be necessary when the client has uncommitted writes to provisionally allocated byte-ranges of a file that were sent to the storage devices before the restart of the metadata server. In this case, the layout provided by the client MUST be a subset of a writable layout that the client held immediately before the restart of the metadata server. The value of the field loca_stateid MUST be a value that the metadata server returned before it restarted. The metadata server is free to accept or reject this request based on its own internal metadata consistency checks. If the metadata server finds that the layout provided by the client does not pass its consistency checks, it MUST reject the request with the status NFS4ERR_RECLAIM_BAD. The successful completion of the LAYOUTCOMMIT request with loca_reclaim set to TRUE does NOT provide the client with a layout for the file. It simply commits the changes to the layout specified in the loca_layoutupdate field. To obtain a layout for the file, the client must send a LAYOUTGET request to the server after the server's grace period has expired. If the metadata server receives a LAYOUTCOMMIT request with loca_reclaim set to TRUE when the metadata server is not in its recovery grace period, it MUST reject the request with the status NFS4ERR_NO_GRACE.",
      "ja": "LOCA_RECLAIMフィールドがtrueに設定されている場合、これは、メタデータサーバーの回復猶予期間中にメタデータサーバーの再起動後にクライアントがレイアウトの変更をコミットしようとしていることを示します（セクション12.7.4を参照）。この種の要求は、クライアントがメタデータサーバの再起動の前にストレージデバイスに送信されたファイルの暫定的に割り当てられたファイルのバイト範囲への書き込みを解除したときに必要になるかもしれません。この場合、クライアントによって提供されるレイアウトは、メタデータサーバの再起動の直前にクライアントが保持する書き込み可能なレイアウトのサブセットである必要があります。フィールドLOCA_STATEIDの値は、再起動前にメタデータサーバーが返された値でなければなりません。 Metadata Serverは、独自の内部メタデータの整合性チェックに基づいてこの要求を自由に承認または拒否します。メタデータサーバがクライアントによって提供されたレイアウトがその整合性チェックを渡していないことを検索すると、ステータスNFS4ERR_RECLAIM_BADで要求を拒否する必要があります。 loca_reclaim setをtrueに設定したLayoutCommit要求の正常な完了は、クライアントにファイルのレイアウトを提供しません。これは、Loca_LayoutUpdateフィールドに指定されたレイアウトに変更をコミットします。ファイルのレイアウトを取得するには、サーバーの猶予期間が期限切れになった後に、クライアントはレイアウト要求をサーバーに送信する必要があります。メタデータサーバーがRoca_ReclaimがRECOUTCOMMIT要求を受信した場合、メタデータサーバーがリカバリ猶予期間内に設定されている場合はtrueに設定されている場合は、ステータスNFS4ERR_NO_GRACEを使用して要求を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Setting the loca_reclaim field to TRUE is required if and only if the committed layout was acquired before the metadata server restart. If the client is committing a layout that was acquired during the metadata server's grace period, it MUST set the \"reclaim\" field to FALSE.",
      "ja": "Metadata Serverが再起動する前にコミットされたレイアウトが取得された場合に限り、LOCA_RECLAIMフィールドをtrueに設定する必要があります。メタデータサーバーの猶予期間中に取得されたレイアウトをクライアントにコミットしている場合は、[Reclaim]フィールドをFALSEに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The loca_stateid is a layout stateid value as returned by previously successful layout operations (see Section 12.5.3).",
      "ja": "LOCA_STATEIDは、以前に成功したレイアウト操作によって返されるレイアウト状態ID値です（セクション12.5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The loca_last_write_offset field specifies the offset of the last byte written by the client previous to the LAYOUTCOMMIT. Note that this value is never equal to the file's size (at most it is one byte less than the file's size) and MUST be less than or equal to NFS4_MAXFILEOFF. Also, loca_last_write_offset MUST overlap the range described by loca_offset and loca_length. The metadata server may use this information to determine whether the file's size needs to be updated. If the metadata server updates the file's size as the result of the LAYOUTCOMMIT operation, it must return the new size (locr_newsize.ns_size) as part of the results.",
      "ja": "loca_last_write_offsetフィールドは、LayoutCommit前のクライアントによって書き込まれた最後のバイトのオフセットを指定します。この値はファイルのサイズと等しくないことに注意してください（ほとんどの場合、ファイルのサイズより1バイトの1バイトです）、NFS4_MAXFILEOFF以下でなければなりません。また、LOCA_LAST_WRITE_OFFSETは、LOCA_OFFSETとLOCA_LENGTHによって記述された範囲と重複している必要があります。メタデータサーバーはこの情報を使用して、ファイルのサイズを更新する必要があるかどうかを判断できます。メタデータサーバーがLayoutCommit操作の結果としてファイルのサイズを更新する場合は、結果の一部として新しいサイズ（LOCR_NEWSIZE.NS_SIZE）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The loca_time_modify field allows the client to suggest a modification time it would like the metadata server to set. The metadata server may use the suggestion or it may use the time of the LAYOUTCOMMIT operation to set the modification time. If the metadata server uses the client-provided modification time, it should ensure that time does not flow backwards. If the client wants to force the metadata server to set an exact time, the client should use a SETATTR operation in a COMPOUND right after LAYOUTCOMMIT. See Section 12.5.4 for more details. If the client desires the resultant modification time, it should construct the COMPOUND so that a GETATTR follows the LAYOUTCOMMIT.",
      "ja": "loca_time_modifyフィールドを使用すると、クライアントはメタデータサーバーを設定したい変更時刻を変更できます。メタデータサーバは提案を使用するか、またはそれが変更時間を設定するためにLayoutCommit操作の時刻を使用することができる。メタデータサーバーがクライアント提供の変更時刻を使用している場合は、時間が後退しないようにする必要があります。クライアントがメタデータサーバーに正確な時間を設定したい場合、クライアントはLayoutCommitの直後に複合のSetAttr操作を使用する必要があります。詳細については、12.5.4項を参照してください。クライアントが結果の変更時間を希望する場合は、GetAttrがLayoutCommitに従うように化合物を構築する必要があります。"
    },
    {
      "indent": 3,
      "text": "The loca_layoutupdate argument to LAYOUTCOMMIT provides a mechanism for a client to provide layout-specific updates to the metadata server. For example, the layout update can describe what byte-ranges of the original layout have been used and what byte-ranges can be deallocated. There is no NFSv4.1 file layout-specific layoutupdate4 structure.",
      "ja": "LayoutCommitへのloca_layoutupdate引数は、クライアントがメタデータサーバにレイアウト固有の更新を提供するためのメカニズムを提供します。たとえば、レイアウトアップデートでは、元のレイアウトの何バイト範囲が使用されており、どのバイト範囲を割り当て解除できるかを説明できます。NFSV4.1ファイルレイアウト固有のLayoutUpdate4構造はありません。"
    },
    {
      "indent": 3,
      "text": "The layout information is more verbose for block devices than for objects and files because the latter two hide the details of block allocation behind their storage protocols. At the minimum, the client needs to communicate changes to the end-of-file location back to the server, and, if desired, its view of the file's modification time. For block/volume layouts, it needs to specify precisely which blocks have been used.",
      "ja": "レイアウト情報は、後者の2つがストレージプロトコルの背後にあるブロック割り当ての詳細を非表示にしているため、オブジェクトやファイルの場合よりも冗長なデバイスがより冗長です。最低限、クライアントはファイルの終わりの場所への変更をサーバーに返信する必要があります。必要に応じて、ファイルの修正時刻のビューを表示します。ブロック/ボリュームレイアウトの場合は、どのブロックが使用されているかを正確に指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the layout identified in the arguments does not exist, the error NFS4ERR_BADLAYOUT is returned. The layout being committed may also be rejected if it does not correspond to an existing layout with an iomode of LAYOUTIOMODE4_RW.",
      "ja": "引数で識別されたレイアウトが存在しない場合は、エラーNFS4ERR_BADLAYOUTが返されます。コミットされているレイアウトは、LayoutIomode4_RWのIOMODEを持つ既存のレイアウトに対応していない場合も拒否されてもよい。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value and the current stateid retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持し、現在のStateIDはその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.42.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.42.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client MAY also use LAYOUTCOMMIT with the loca_reclaim field set to TRUE to convey hints to modified file attributes or to report layout-type specific information such as I/O errors for object-based storage layouts, as normally done during normal operation. Doing so may help the metadata server to recover files more efficiently after restart. For example, some file system implementations may require expansive recovery of file system objects if the metadata server does not get a positive indication from all clients holding a LAYOUTIOMODE4_RW layout that they have successfully completed all their writes. Sending a LAYOUTCOMMIT (if required) and then following with LAYOUTRETURN can provide such an indication and allow for graceful and efficient recovery.",
      "ja": "クライアントは、HINTSを修正ファイル属性に伝達するため、またはオブジェクトベースのストレージレイアウトのためのI / Oエラーなどのレイアウトタイプの固有情報を通常、通常動作中に行われるように、loca_reclaimフィールドをtrueに設定することもできます。これを行うと、メタデータサーバーが再起動後も効率的にファイルを回復するのに役立ちます。たとえば、Metadata Serverがすべての書き込みを正常に完了したLayoutIomode4_RWレイアウトを保持しているすべてのクライアントからの正の表示を受け付けていない場合、ファイルシステムの実装によっては、ファイルシステムの実装の一部のファイルシステムオブジェクトの拡張リカバリが必要になる場合があります。LayoutCommit（必要な場合）を送信してから、LayoutReturnを使用してフォローすると、そのような表示を提供し、優雅で効率的な回復を可能にします。"
    },
    {
      "indent": 3,
      "text": "If loca_reclaim is TRUE, the metadata server is free to either examine or ignore the value in the field loca_stateid. The metadata server implementation might or might not encode in its layout stateid information that allows the metadata server to perform a consistency check on the LAYOUTCOMMIT request.",
      "ja": "loca_reclaimがtrueの場合、Metadata Serverはフィールドloca_stateIdの値を調べるか無視しています。メタデータサーバーの実装は、そのレイアウトStareID情報で、メタデータサーバーがLayoutCommit要求の整合性チェックを実行できるようにすることができます。"
    },
    {
      "indent": 0,
      "text": "18.43. Operation 50: LAYOUTGET - Get Layout Information",
      "section_title": true,
      "ja": "18.43. 操作50：Layoutget  - レイアウト情報を取得します"
    },
    {
      "indent": 0,
      "text": "18.43.1. ARGUMENT",
      "section_title": true,
      "ja": "18.43.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct LAYOUTGET4args {\n        /* CURRENT_FH: file */\n        bool                    loga_signal_layout_avail;\n        layouttype4             loga_layout_type;\n        layoutiomode4           loga_iomode;\n        offset4                 loga_offset;\n        length4                 loga_length;\n        length4                 loga_minlength;\n        stateid4                loga_stateid;\n        count4                  loga_maxcount;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.43.2. RESULT",
      "section_title": true,
      "ja": "18.43.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LAYOUTGET4resok {\n        bool               logr_return_on_close;\n        stateid4           logr_stateid;\n        layout4            logr_layout<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LAYOUTGET4res switch (nfsstat4 logr_status) {\ncase NFS4_OK:\n        LAYOUTGET4resok     logr_resok4;\ncase NFS4ERR_LAYOUTTRYLATER:\n        bool                logr_will_signal_layout_avail;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.43.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.43.3. description"
    },
    {
      "indent": 3,
      "text": "The LAYOUTGET operation requests a layout from the metadata server for reading or writing the file given by the filehandle at the byte-range specified by offset and length. Layouts are identified by the client ID (derived from the session ID in the preceding SEQUENCE operation), current filehandle, layout type (loga_layout_type), and the layout stateid (loga_stateid). The use of the loga_iomode field depends upon the layout type, but should reflect the client's data access intent.",
      "ja": "Layoutget操作は、ファイルハンドルによって指定されたファイルをオフセットと長さで指定されたbyte-範囲で読み書きするために、メタデータサーバーからのレイアウトを要求します。レイアウトは、クライアントID（前のシーケンス操作のセッションIDから派生した）、現在のファイルハンドル、レイアウトタイプ（Loga_Layout_Type）、およびレイアウトStateID（Loga_StateID）によって識別されます。loga_iomodeフィールドの使用はレイアウトタイプによって異なりますが、クライアントのデータアクセスの意図を反映する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the metadata server is in a grace period, and does not persist layouts and device ID to device address mappings, then it MUST return NFS4ERR_GRACE (see Section 8.4.2.1).",
      "ja": "メタデータサーバが猶予期間内にあり、レイアウトとデバイスIDをデバイスアドレスマッピングに永続化しない場合は、NFS4ERR_GRACEを返す必要があります（セクション8.4.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTGET operation returns layout information for the specified byte-range: a layout. The client actually specifies two ranges, both starting at the offset in the loga_offset field. The first range is between loga_offset and loga_offset + loga_length - 1 inclusive. This range indicates the desired range the client wants the layout to cover. The second range is between loga_offset and loga_offset + loga_minlength - 1 inclusive. This range indicates the required range the client needs the layout to cover. Thus, loga_minlength MUST be less than or equal to loga_length.",
      "ja": "Layoutget操作は、指定されたバイト範囲のレイアウト情報をレイアウトします。クライアントは実際にはloga_offsetフィールドのオフセットから始めて2つの範囲を指定します。最初の範囲はloga_offsetとloga_offset loga_length  -  1 inclusiveの間です。この範囲は、クライアントがレイアウトをカバーする希望の範囲を示しています。2番目の範囲は、loga_offsetとloga_offset loga_minlength  -  1 inclusiveの間です。この範囲は必要な範囲を示していますクライアントはカバーするレイアウトを必要とするレイアウトを必要とします。したがって、loga_minlengthはloga_length以下でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a length field is set to NFS4_UINT64_MAX, this indicates a desire (when loga_length is NFS4_UINT64_MAX) or requirement (when loga_minlength is NFS4_UINT64_MAX) to get a layout from loga_offset through the end-of-file, regardless of the file's length.",
      "ja": "LengthフィールドがNFS4_UINT64_MAXに設定されている場合、これは、ファイルの長さに関係なく、ファイルの長さに関係なく、ファイルの長さに関係なく、ファイルの長さに関係なく、ファイルの長さに関係なく、ファイルの長さに関係なく、これは（Loga_LengthがNFS4_UINT64_MAXの場合）または要件を示します。"
    },
    {
      "indent": 3,
      "text": "The following rules govern the relationships among, and the minima of, loga_length, loga_minlength, and loga_offset.",
      "ja": "次の規則は、loga_length、loga_minlength、およびloga_offsetの間の関係と、最小値を管理します。"
    },
    {
      "indent": 3,
      "text": "* If loga_length is less than loga_minlength, the metadata server MUST return NFS4ERR_INVAL.",
      "ja": "* loga_lengthがloga_minlengthより小さい場合、メタデータサーバーはNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If loga_minlength is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has \"readily available\". Readily is subjective, and depends on the layout type and the pNFS server implementation. For example, some metadata servers might have to pre-allocate stable storage when they receive a request for a range of a file that goes beyond the file's current length. If loga_minlength is zero and loga_length is greater than zero, this tells the metadata server what range of the layout the client would prefer to have. If loga_length and loga_minlength are both zero, then the client is indicating that it desires a layout of any length with the ending offset of the range no less than the value specified loga_offset, and the starting offset at or below loga_offset. If the metadata server does not have a layout that is readily available, then it MUST return NFS4ERR_LAYOUTTRYLATER.",
      "ja": "* loga_minLengthがゼロの場合、これはメタデータサーバへの指示であり、クライアントはオフセットLoga_Offsetで任意のレイアウトを望む以下、以下のメタデータサーバに「すぐに利用可能」にしたことがある。すぐに主観的であり、レイアウトタイプとPNFSサーバーの実装によって異なります。たとえば、ファイルの現在の長さを超えるファイルの範囲の要求を受信したときに、一部のメタデータサーバーは安定したストレージを事前割り当てる必要があります。loga_minLengthがゼロで、loga_lengthがゼロより大きい場合、これはメタデータサーバーにクライアントが持つことを好むレイアウトの範囲を伝えます。loga_lengthとloga_minlengthがゼロのどちらもゼロの場合、クライアントは、指定されたloga_offsetが指定された値よりも小さい範囲の終了オフセット、およびLoga_Offset以上の開始オフセットを望むことをクライアントであることを示しています。メタデータサーバーにすぐに入手可能なレイアウトがない場合は、NFS4ERR_LAYOUTTRYLATERを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the sum of loga_offset and loga_minlength exceeds NFS4_UINT64_MAX, and loga_minlength is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.",
      "ja": "* loga_offsetとloga_minlengthの合計がNFS4_UINT64_MAXを超え、loga_minlengthがNFS4_UINT64_MAXではない場合、エラーNFS4ERR_INVALが発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the sum of loga_offset and loga_length exceeds NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.",
      "ja": "* loga_offsetとloga_lengthの合計がNFS4_UINT64_MAXを超え、loga_lengthがNFS4_UINT64_MAXではない場合、エラーNFS4ERR_INVALが発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the metadata server has performed the above checks on loga_offset, loga_minlength, and loga_offset, the metadata server MUST return a layout according to the rules in Table 22.",
      "ja": "メタデータサーバーがLoga_Offset、Loga_minLength、およびloga_offsetの上記のチェックを実行した後、メタデータサーバーは表22の規則に従ってレイアウトを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Acceptable layouts based on loga_minlength. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_minlen = loga_minlength.",
      "ja": "loga_minlengthに基づく許容可能なレイアウト。注：U64M = NFS4_UINT64_MAX;A_OFF = LOGA_OFFSET;a_minlen = loga_minLength。"
    },
    {
      "indent": 3,
      "text": "+===========+============+==========+==========+===================+\n| Layout    | Layout     | Layout   | Layout   | Layout length of  |\n| iomode of | a_minlen   | iomode   | offset   | reply             |\n| request   | of request | of reply | of reply |                   |\n+===========+============+==========+==========+===================+\n| _READ     | u64m       | MAY be   | MUST be  | MUST be >= file   |\n|           |            | _READ    | <= a_off | length - layout   |\n|           |            |          |          | offset            |\n+-----------+------------+----------+----------+-------------------+\n| _READ     | u64m       | MAY be   | MUST be  | MUST be u64m      |\n|           |            | _RW      | <= a_off |                   |\n+-----------+------------+----------+----------+-------------------+\n| _READ     | > 0 and <  | MAY be   | MUST be  | MUST be >=        |\n|           | u64m       | _READ    | <= a_off | MIN(file length,  |\n|           |            |          |          | a_minlen + a_off) |\n|           |            |          |          | - layout offset   |\n+-----------+------------+----------+----------+-------------------+\n| _READ     | > 0 and <  | MAY be   | MUST be  | MUST be >= a_off  |\n|           | u64m       | _RW      | <= a_off | - layout offset + |\n|           |            |          |          | a_minlen          |\n+-----------+------------+----------+----------+-------------------+\n| _READ     | 0          | MAY be   | MUST be  | MUST be > 0       |\n|           |            | _READ    | <= a_off |                   |\n+-----------+------------+----------+----------+-------------------+\n| _READ     | 0          | MAY be   | MUST be  | MUST be > 0       |\n|           |            | _RW      | <= a_off |                   |\n+-----------+------------+----------+----------+-------------------+\n| _RW       | u64m       | MUST be  | MUST be  | MUST be u64m      |\n|           |            | _RW      | <= a_off |                   |\n+-----------+------------+----------+----------+-------------------+\n| _RW       | > 0 and <  | MUST be  | MUST be  | MUST be >= a_off  |\n|           | u64m       | _RW      | <= a_off | - layout offset + |\n|           |            |          |          | a_minlen          |\n+-----------+------------+----------+----------+-------------------+\n| _RW       | 0          | MUST be  | MUST be  | MUST be > 0       |\n|           |            | _RW      | <= a_off |                   |\n+-----------+------------+----------+----------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 22",
      "ja": "表22."
    },
    {
      "indent": 3,
      "text": "If loga_minlength is not zero and the metadata server cannot return a layout according to the rules in Table 22, then the metadata server MUST return the error NFS4ERR_BADLAYOUT. If loga_minlength is zero and the metadata server cannot or will not return a layout according to the rules in Table 22, then the metadata server MUST return the error NFS4ERR_LAYOUTTRYLATER. Assuming that loga_length is greater than loga_minlength or equal to zero, the metadata server SHOULD return a layout according to the rules in Table 23.",
      "ja": "loga_minlengthがゼロでなく、メタデータサーバーが表22のルールに従ってレイアウトを返すことができない場合、メタデータサーバーはエラーNFS4ERR_BADLAYOUTを返す必要があります。表22のルールに従ってLOGA_MINLENGTHがゼロでレイアウトを返さない場合、メタデータサーバーはエラーNFS4ERR_LAYOUTTRYLATERを返す必要があります。loga_lengthがloga_minlengthより大きい場合、またはゼロに等しいと仮定すると、メタデータサーバーは表23の規則に従ってレイアウトを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Desired layouts based on loga_length. The rules of Table 22 MUST be applied first. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_len = loga_length.",
      "ja": "loga_lengthに基づく望ましいレイアウト。表22の規則を最初に適用する必要があります。注：U64M = NFS4_UINT64_MAX;A_OFF = LOGA_OFFSET;a_len = loga_length。"
    },
    {
      "indent": 4,
      "text": "+===============+==========+==========+==========+================+\n| Layout iomode | Layout   | Layout   | Layout   | Layout length  |\n| of request    | a_len of | iomode   | offset   | of reply       |\n|               | request  | of reply | of reply |                |\n+===============+==========+==========+==========+================+\n| _READ         | u64m     | MAY be   | MUST be  | SHOULD be u64m |\n|               |          | _READ    | <= a_off |                |\n+---------------+----------+----------+----------+----------------+\n| _READ         | u64m     | MAY be   | MUST be  | SHOULD be u64m |\n|               |          | _RW      | <= a_off |                |\n+---------------+----------+----------+----------+----------------+\n| _READ         | > 0 and  | MAY be   | MUST be  | SHOULD be >=   |\n|               | < u64m   | _READ    | <= a_off | a_off - layout |\n|               |          |          |          | offset + a_len |\n+---------------+----------+----------+----------+----------------+\n| _READ         | > 0 and  | MAY be   | MUST be  | SHOULD be >=   |\n|               | < u64m   | _RW      | <= a_off | a_off - layout |\n|               |          |          |          | offset + a_len |\n+---------------+----------+----------+----------+----------------+\n| _READ         | 0        | MAY be   | MUST be  | SHOULD be >    |\n|               |          | _READ    | <= a_off | a_off - layout |\n|               |          |          |          | offset         |\n+---------------+----------+----------+----------+----------------+\n| _READ         | 0        | MAY be   | MUST be  | SHOULD be >    |\n|               |          | _READ    | <= a_off | a_off - layout |\n|               |          |          |          | offset         |\n+---------------+----------+----------+----------+----------------+\n| _RW           | u64m     | MUST be  | MUST be  | SHOULD be u64m |\n|               |          | _RW      | <= a_off |                |\n+---------------+----------+----------+----------+----------------+\n| _RW           | > 0 and  | MUST be  | MUST be  | SHOULD be >=   |\n|               | < u64m   | _RW      | <= a_off | a_off - layout |\n|               |          |          |          | offset + a_len |\n+---------------+----------+----------+----------+----------------+\n| _RW           | 0        | MUST be  | MUST be  | SHOULD be >    |\n|               |          | _RW      | <= a_off | a_off - layout |\n|               |          |          |          | offset         |\n+---------------+----------+----------+----------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 23",
      "ja": "表23."
    },
    {
      "indent": 3,
      "text": "The loga_stateid field specifies a valid stateid. If a layout is not currently held by the client, the loga_stateid field represents a stateid reflecting the correspondingly valid open, byte-range lock, or delegation stateid. Once a layout is held on the file by the client, the loga_stateid field MUST be a stateid as returned from a previous LAYOUTGET or LAYOUTRETURN operation or provided by a CB_LAYOUTRECALL operation (see Section 12.5.3).",
      "ja": "loga_stateIDフィールドは有効なStateIDを指定します。レイアウトが現在クライアントによって保持されていない場合、loga_stateIDフィールドは、対応して有効なオープン、バイトレンジロック、または委任ステートIDを反映したStateIDを表します。レイアウトがクライアントによってファイルに保持されると、Loga_StateIDフィールドは、前のレイアウトゲットまたはLayoutReturn操作から返されるか、またはCB_LAYOUTRecall操作によって提供されるStateIDでなければなりません（セクション12.5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The loga_maxcount field specifies the maximum layout size (in bytes) that the client can handle. If the size of the layout structure exceeds the size specified by maxcount, the metadata server will return the NFS4ERR_TOOSMALL error.",
      "ja": "loga_maxcountフィールドは、クライアントが処理できる最大レイアウトサイズ（バイト単位）を指定します。レイアウト構造のサイズがMAXCOUNTで指定されたサイズを超えると、メタデータサーバーはNFS4ERR_TOOSMALLエラーを返します。"
    },
    {
      "indent": 3,
      "text": "The returned layout is expressed as an array, logr_layout, with each element of type layout4. If a file has a single striping pattern, then logr_layout SHOULD contain just one entry. Otherwise, if the requested range overlaps more than one striping pattern, logr_layout will contain the required number of entries. The elements of logr_layout MUST be sorted in ascending order of the value of the lo_offset field of each element. There MUST be no gaps or overlaps in the range between two successive elements of logr_layout. The lo_iomode field in each element of logr_layout MUST be the same.",
      "ja": "返されたレイアウトは、レイアウト型の各要素を持つ配列LOGR_LAYOUTとして表されます。ファイルに単一のストライピングパターンがある場合は、LOGR_LAYOUTに1つのエントリを含める必要があります。それ以外の場合、要求された範囲が複数のストライピングパターンを重なっている場合、LOGR_LAYOUTには必要なエントリ数が含まれます。LOGR_LAYOUTの要素は、各要素のLO_OFFSETフィールドの値の昇順でソートする必要があります。LOGR_LAYOUTの2つの連続した要素間の範囲内の隙間や重なりはなければなりません。LOGR_LAYOUTの各要素のLO_IOMODEフィールドは同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Table 22 and Table 23 both refer to a returned layout iomode, offset, and length. Because the returned layout is encoded in the logr_layout array, more description is required.",
      "ja": "表22および表23はどちらも返されたレイアウトIOMode、Offset、およびLengthを指します。返されたレイアウトはLOGR_LAYOUT配列でエンコードされるため、より多くの説明が必要です。"
    },
    {
      "indent": 3,
      "text": "iomode The value of the returned layout iomode listed in Table 22 and Table 23 is equal to the value of the lo_iomode field in each element of logr_layout. As shown in Table 22 and Table 23, the metadata server MAY return a layout with an lo_iomode different from the requested iomode (field loga_iomode of the request). If it does so, it MUST ensure that the lo_iomode is more permissive than the loga_iomode requested. For example, this behavior allows an implementation to upgrade LAYOUTIOMODE4_READ requests to LAYOUTIOMODE4_RW requests at its discretion, within the limits of the layout type specific protocol. A lo_iomode of either LAYOUTIOMODE4_READ or LAYOUTIOMODE4_RW MUST be returned.",
      "ja": "IOMODE表22および表23にリストされている返されたレイアウトIOModeの値は、LOGR_LAYOUTの各要素内のLO_IOMODEフィールドの値に等しい。表22および表23に示すように、メタデータサーバは、要求されたiomode（要求のフィールドloga_iomode）とは異なるLO_IOMODEを用いてレイアウトを返すことができる。そうすると、LO_IOMODEが要求されたLOGA_IOMODEよりも許可されていることを確認する必要があります。たとえば、この動作により、レイアウト型固有のプロトコルの範囲内で、LayoutIomode4_RW要求をその裁量でRayoutIomode4_RW要求にアップグレードすることができます。layoutioMode4_readまたはlayoutioMode4_rwのいずれかのlo_iomodeを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "offset The value of the returned layout offset listed in Table 22 and Table 23 is always equal to the lo_offset field of the first element logr_layout.",
      "ja": "オフセット表22および表23にリストされている返されたレイアウトオフセットの値は、常に最初の要素LOGR_LAYOUTのLO_OFFSETフィールドに等しくなります。"
    },
    {
      "indent": 3,
      "text": "length When setting the value of the returned layout length, the situation is complicated by the possibility that the special layout length value NFS4_UINT64_MAX is involved. For a logr_layout array of N elements, the lo_length field in the first N-1 elements MUST NOT be NFS4_UINT64_MAX. The lo_length field of the last element of logr_layout can be NFS4_UINT64_MAX under some conditions as described in the following list.",
      "ja": "length返されたレイアウト長の値を設定するときは、特殊なレイアウト長値NFS4_UINT64_MAXが含まれる可能性が複雑になります。n個の要素のLOGR_LAYOUT配列の場合、最初のN-1要素のLO_LENGTHフィールドはNFS4_UINT64_MAXにしてはなりません。LOGR_LAYOUTの最後の要素のLO_LENGTHフィールドは、次のリストに記載されている状態では、いくつかの条件下でNFS4_UINT64_MAXにすることができます。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 22 states that the metadata server MUST return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST be NFS4_UINT64_MAX.",
      "ja": "* 表22の該当するルールが、メタデータサーバが長さNFS4_UINT64_MAXのレイアウトを返す必要があると述べている場合、LOGR_LAYOUTの最後の要素のLO_LENGTHフィールドはNFS4_UINT64_MAXでなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 22 states that the metadata server MUST NOT return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST NOT be NFS4_UINT64_MAX.",
      "ja": "* 表22の該当するルールが、メタデータサーバが長さNFS4_UINT64_MAXのレイアウトを返さないであろうと述べている場合、LOGR_LAYOUTの最後の要素のLO_LENGTHフィールドはNFS4_UINT64_MAXにしてはならない。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 23 states that the metadata server SHOULD return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout SHOULD be NFS4_UINT64_MAX.",
      "ja": "* 表23の該当するルールが、メタデータサーバが長さNFS4_UINT64_MAXのレイアウトを返すべきであると述べている場合、LOGR_LAYOUTの最後の要素のLO_LENGTHフィールドはNFS4_UINT64_MAXにする必要があります。"
    },
    {
      "indent": 6,
      "text": "* When the value of the returned layout length of Table 22 and Table 23 is not NFS4_UINT64_MAX, then the returned layout length is equal to the sum of the lo_length fields of each element of logr_layout.",
      "ja": "* テーブル22および表23の返されたレイアウト長の値がNFS4_UINT64_MAXではない場合、返されたレイアウト長はLOGR_LAYOUTの各要素のLO_LENGTHフィールドの合計に等しい。"
    },
    {
      "indent": 3,
      "text": "The logr_return_on_close result field is a directive to return the layout before closing the file. When the metadata server sets this return value to TRUE, it MUST be prepared to recall the layout in the case in which the client fails to return the layout before close. For the metadata server that knows a layout must be returned before a close of the file, this return value can be used to communicate the desired behavior to the client and thus remove one extra step from the client's and metadata server's interaction.",
      "ja": "logr_return_on_close結果フィールドは、ファイルを閉じる前にレイアウトを返すディレクティブです。メタデータサーバがこの戻り値をtrueに設定すると、クライアントがクローズ前にレイアウトを返すことができない場合にレイアウトを呼び出すように準備する必要があります。ファイルの近くの前にレイアウトを知っているメタデータサーバの場合、この戻り値を使用して目的の動作をクライアントに伝達することができ、したがってクライアントとメタデータサーバーの対話から追加のステップを削除できます。"
    },
    {
      "indent": 3,
      "text": "The logr_stateid stateid is returned to the client for use in subsequent layout related operations. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "LOGR_STATEID STATEIDは、後続のレイアウト関連操作で使用するためにクライアントに返されます。さらなる議論と要件については、セクション8.2,12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The format of the returned layout (lo_content) is specific to the layout type. The value of the layout type (lo_content.loc_type) for each of the elements of the array of layouts returned by the metadata server (logr_layout) MUST be equal to the loga_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the metadata server returned an error, even if the client does have support for the layout type returned.",
      "ja": "返されたレイアウトの形式（LO_CONTENT）はレイアウトタイプに固有のものです。メタデータサーバー（LOGR_LAYOUT）によって返されるレイアウトの配列の各要素のレイアウトタイプ（LO_CONTENT.LOC_TYPE）の値は、クライアントによって指定されたloga_layout_typeに等しくなければなりません。等しくない場合、クライアントは無効として応答を無視し、クライアントが返されたレイアウトタイプのサポートがある場合でも、メタデータサーバーがエラーを返しているように動作します。"
    },
    {
      "indent": 3,
      "text": "If neither the requested file nor its containing file system support layouts, the metadata server MUST return NFS4ERR_LAYOUTUNAVAILABLE. If the layout type is not supported, the metadata server MUST return NFS4ERR_UNKNOWN_LAYOUTTYPE. If layouts are supported but no layout matches the client provided layout identification, the metadata server MUST return NFS4ERR_BADLAYOUT. If an invalid loga_iomode is specified, or a loga_iomode of LAYOUTIOMODE4_ANY is specified, the metadata server MUST return NFS4ERR_BADIOMODE.",
      "ja": "要求されたファイルもそのファイルシステムのサポートレイアウトもいない場合、メタデータサーバはNFS4ERR_LAYOUTUNAVAILABLEを返す必要があります。レイアウトの種類がサポートされていない場合、メタデータサーバはNFS4ERR_UNKNOWN_LAYOUTTYPEを返す必要があります。レイアウトがサポートされているがレイアウトが一致しない場合は、レイアウト識別を提供するクライアントに一致しません。メタデータサーバーはNFS4ERR_BADLAYOUTを返す必要があります。無効なloga_iomodeが指定されているか、LayoutIomode4_Anyのloga_iomodeが指定されている場合、メタデータサーバーはNFS4ERR_BADIOMODEを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the layout for the file is unavailable due to transient conditions, e.g., file sharing prohibits layouts, the metadata server MUST return NFS4ERR_LAYOUTTRYLATER.",
      "ja": "過渡条件のためにファイルのレイアウトが使用できない場合は、例えばファイル共有はレイアウトを禁止するため、メタデータサーバはNFS4ERR_LAYOUTTRYLATERを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the layout request is rejected due to an overlapping layout recall, the metadata server MUST return NFS4ERR_RECALLCONFLICT. See Section 12.5.5.2 for details.",
      "ja": "重複するレイアウトリコールのためにレイアウト要求が拒否された場合、メタデータサーバはNFS4ERR_RecallConflictを返す必要があります。詳細は12.5.5.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the layout conflicts with a mandatory byte-range lock held on the file, and if the storage devices have no method of enforcing mandatory locks, other than through the restriction of layouts, the metadata server SHOULD return NFS4ERR_LOCKED.",
      "ja": "レイアウトがファイル上に保持されている必須バイトレンジロックと競合し、レイアウトの制限以外の必須ロックを強制する方法がない場合、メタデータサーバーはNFS4ERR_LOCKEDを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If client sets loga_signal_layout_avail to TRUE, then it is registering with the client a \"want\" for a layout in the event the layout cannot be obtained due to resource exhaustion. If the metadata server supports and will honor the \"want\", the results will have logr_will_signal_layout_avail set to TRUE. If so, the client should expect a CB_RECALLABLE_OBJ_AVAIL operation to indicate that a layout is available.",
      "ja": "クライアントがloga_signal_layout_availをtrueに設定すると、リソースの枯渇のためにレイアウトを取得できない場合には、レイアウトのレイアウトのレイアウトのクライアントに「希望」に登録しています。メタデータサーバーがサポートして「希望」を尊重すると、結果にLOGR_WILL_SIGNAL_LAYOUT_AVAILがTRUEに設定されます。もしそうであれば、クライアントはCB_recallable_obj_avail操作を期待してレイアウトが利用可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value and the current stateid is updated to match the value as returned in the results.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持し、現在のStateIDは結果に返される値と一致するように更新されます。"
    },
    {
      "indent": 0,
      "text": "18.43.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.43.4. 実装"
    },
    {
      "indent": 3,
      "text": "Typically, LAYOUTGET will be called as part of a COMPOUND request after an OPEN operation and results in the client having location information for the file. This requires that loga_stateid be set to the special stateid that tells the metadata server to use the current stateid, which is set by OPEN (see Section 16.2.3.1.2). A client may also hold a layout across multiple OPENs. The client specifies a layout type that limits what kind of layout the metadata server will return. This prevents metadata servers from granting layouts that are unusable by the client.",
      "ja": "通常、レイアウトはオープン操作後に複合要求の一部として呼び出され、クライアントがファイルの位置情報を持つクライアントになります。これは、Openによって設定された現在のStateIDを使用するようにMetadata ServerにPraint Serverに設定されているSpecial StareIDに設定されている必要があります（セクション16.2.3.1.2を参照）。クライアントは複数の開いているレイアウトを保持することもできます。クライアントは、メタデータサーバーがどのような種類のレイアウトを返すかを制限するレイアウト型を指定します。これにより、メタデータサーバーがクライアントによって使用できないレイアウトを付与するのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "As indicated by Table 22 and Table 23, the specification of LAYOUTGET allows a pNFS client and server considerable flexibility. A pNFS client can take several strategies for sending LAYOUTGET. Some examples are as follows.",
      "ja": "表22および表23に示されるように、LayoutGetの仕様はPNFSクライアントおよびサーバをかなりの柔軟性を有することを可能にする。PNFSクライアントは、LayEoutgetを送信するためのいくつかの戦略を取ります。いくつかの例は以下の通りである。"
    },
    {
      "indent": 3,
      "text": "* If LAYOUTGET is preceded by OPEN in the same COMPOUND request and the OPEN requests OPEN4_SHARE_ACCESS_READ access, the client might opt to request a _READ layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to NFS4_UINT64_MAX. If the file has space allocated to it, that space is striped over one or more storage devices, and there is either no conflicting layout or the concept of a conflicting layout does not apply to the pNFS server's layout type or implementation, then the metadata server might return a layout with a starting offset of zero, and a length equal to the length of the file, if not NFS4_UINT64_MAX. If the length of the file is not a multiple of the pNFS server's stripe width (see Section 13.2 for a formal definition), the metadata server might round up the returned layout's length.",
      "ja": "* 同じ複合要求とOpen Requests Open4_Share_Access_Readアクセスの前にLayoutgetが付いている場合、クライアントはLOGA_OFFSETをゼロに設定して_READレイアウトを要求することを選択し、Loga_minLengthはゼロに設定され、loga_lengthがNFS4_UINT64_MAXに設定されます。ファイルにスペースが割り当てられている場合、そのスペースは1つ以上のストレージデバイスを介してストライプされ、競合するレイアウトがなく、競合するレイアウトの概念が適用されない場合は、メタデータサーバに適用されません。NFS4_UINT64_MAXでなければ、ゼロのオフセット、ファイルの長さに等しいレイアウトを返すことがあります。ファイルの長さがPNFSサーバーのストライプ幅の倍数ではない場合（正式な定義のセクション13.2を参照）、メタデータサーバーは返されたレイアウトの長さを切り上げる可能性があります。"
    },
    {
      "indent": 3,
      "text": "* If LAYOUTGET is preceded by OPEN in the same COMPOUND request, and the OPEN requests OPEN4_SHARE_ACCESS_WRITE access and does not truncate the file, the client might opt to request a _RW layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to the file's current length (if known), or NFS4_UINT64_MAX. As with the previous case, under some conditions the metadata server might return a layout that covers the entire length of the file or beyond.",
      "ja": "* 同じ複合要求で開いているレイアウトが開かれ、オープンリクエストOpen4_Share_access_Write Accessがファイルを切り捨てない場合、クライアントはLOGA_OFFSETをゼロに設定して_RWレイアウトを要求することを選択することができます。ファイルの現在の長さ（既知の場合）、またはNFS4_UINT64_MAX。前の場合と同様に、いくつかの条件下では、メタデータサーバはファイルの全長をカバーするレイアウトを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "* This strategy is as above, but the OPEN truncates the file. In this case, the client might anticipate it will be writing to the file from offset zero, and so loga_offset and loga_minlength are set to zero, and loga_length is set to the value of threshold4_write_iosize. The metadata server might return a layout from offset zero with a length at least as long as threshold4_write_iosize.",
      "ja": "* この戦略は上記の通りですが、オープンはファイルを切り捨てます。この場合、クライアントはオフセットゼロからファイルに書き込まれることを予想される可能性があるため、loga_offsetとloga_minlengthはゼロに設定され、loga_lengthがthreshold4_write_iosizeの値に設定されます。メタデータサーバは、少なくともthreshold4_write_iosizeの長さを長さでオフセットゼロからレイアウトを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "* A process on the client invokes a request to read from offset 10000 for length 50000. The client is using buffered I/O, and has buffer sizes of 4096 bytes. The client intends to map the request of the process into a series of READ requests starting at offset 8192. The end offset needs to be higher than 10000 + 50000 = 60000, and the next offset that is a multiple of 4096 is 61440. The difference between 61440 and that starting offset of the layout is 53248 (which is the product of 4096 and 15). The value of threshold4_read_iosize is less than 53248, so the client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 53248, and loga_length set to the file's length (if known) minus 8192 or NFS4_UINT64_MAX (if the file's length is not known). Since this LAYOUTGET request exceeds the metadata server's threshold, it grants the layout, possibly with an initial offset of zero, with an end offset of at least 8192 + 53248 - 1 = 61439, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width.",
      "ja": "* クライアント上のプロセスは、長さ50000のためにオフセット10000から読み取る要求を呼び出す。クライアントはバッファ付きI / Oを使用しており、4096バイトのバッファサイズを有する。クライアントは、オフセット8192から始まる一連の読み出し要求にプロセスの要求をマッピングするつもりである。エンドオフセットは100000000000000 = 60000を超える必要があり、次のオフセットは4096の倍数である。 61440そしてレイアウトの開始オフセットは53248（これは4096と15の製品です）です。 threshold4_read_iosizeの値は53248未満であるため、クライアントはloga_offsetセットを8192に設定され、loga_minlengthを53248に設定し、loga_lengthをファイルの長さ（既知の場合）から8192またはNFS4_UINT64_MAXに設定します（ファイルの長さがわかっていない場合）。 ）。このレイアウト要求はメタデータサーバのしきい値を超えるので、それはおそらく最初のゼロのオフセットで、少なくとも8192 53248  -  1 = 61439の終了オフセットであるが、好ましくはストライプ幅に整列したオフセットを有するレイアウトを付与する。ストライプ幅の倍数の長さ。"
    },
    {
      "indent": 3,
      "text": "* This strategy is as above, but the client is not using buffered I/ O, and instead all internal I/O requests are sent directly to the server. The LAYOUTGET request has loga_offset equal to 10000 and loga_minlength set to 50000. The value of loga_length is set to the length of the file. The metadata server is free to return a layout that fully overlaps the requested range, with a starting offset and length aligned on the stripe width.",
      "ja": "* この戦略は上記の通りですが、クライアントはバッファ付き入出力を使用していないため、すべての内部I / O要求はサーバーに直接送信されます。LayoutGet要求は、10000に等しいloga_offsetを持ち、loga_minlengthは50000に設定されています.loga_lengthの値はファイルの長さに設定されます。メタデータサーバーは、要求された範囲と完全に重なるレイアウトを自由に返すことができます。"
    },
    {
      "indent": 3,
      "text": "* Again, a process on the client invokes a request to read from offset 10000 for length 50000 (i.e. a range with a starting offset of 10000 and an ending offset of 69999), and buffered I/O is in use. The client is expecting that the server might not be able to return the layout for the full I/O range. The client intends to map the request of the process into a series of thirteen READ requests starting at offset 8192, each with length 4096, with a total length of 53248 (which equals 13 * 4096), which fully contains the range that client's process wants to read. Because the value of threshold4_read_iosize is equal to 4096, it is practical and reasonable for the client to use several LAYOUTGET operations to complete the series of READs. The client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 4096, and loga_length set to 53248 or higher. The server will grant a layout possibly with an initial offset of zero, with an end offset of at least 8192 + 4096 - 1 = 12287, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width. This will allow the client to make forward progress, possibly sending more LAYOUTGET operations for the remainder of the range.",
      "ja": "* やはり、クライアント上のプロセスは、長さ50000（すなわち、10000の始動オフセットおよび終了オフセットおよび69999の終了オフセットを有する範囲）から読み取る要求を呼び出し、バッファされたI / Oが使用されている。クライアントは、サーバーがフルI / O範囲のレイアウトを返すことができない可能性があることを期待しています。クライアントは、6092の長さ4096で始まる一連の13個の読み取り要求（13×4096に等しい）で、プロセスの要求を一連の13個の読み出し要求にマッピングするつもりです。読むために。 threshold4_read_iosizeの値は4096に等しいので、クライアントが一連の読み取りを完了するためにいくつかのレイアウト操作を使用するのが実用的かつ合理的です。クライアントは、Loga_Offsetセットを8192に設定されたレイアウト要求を4096に設定し、4096に設定され、Loga_Lengthを53248以上に設定します。サーバーは、おそらく最初のオフセットをゼロの初期オフセットで許可します。幅。これにより、クライアントは進行状況を前進させることができ、残りの範囲に対してより多くのレイアウト操作を送信することができます。"
    },
    {
      "indent": 3,
      "text": "* An NFS client detects a sequential read pattern, and so sends a LAYOUTGET operation that goes well beyond any current or pending read requests to the server. The server might likewise detect this pattern, and grant the LAYOUTGET request. Once the client reads from an offset of the file that represents 50% of the way through the range of the last layout it received, in order to avoid stalling I/O that would wait for a layout, the client sends more operations from an offset of the file that represents 50% of the way through the last layout it received. The client continues to request layouts with byte-ranges that are well in advance of the byte-ranges of recent and/or read requests of processes running on the client.",
      "ja": "* "
    },
    {
      "indent": 3,
      "text": "* This strategy is as above, but the client fails to detect the pattern, but the server does. The next time the metadata server gets a LAYOUTGET, it returns a layout with a length that is well beyond loga_minlength.",
      "ja": "* この戦略は上記の通りですが、クライアントはパターンを検出できませんが、サーバーはします。次回メタデータサーバーがレイアウトを取得するときは、loga_minlengthを超えている長さのレイアウトを返します。"
    },
    {
      "indent": 3,
      "text": "* A client is using buffered I/O, and has a long queue of write-behinds to process and also detects a sequential write pattern. It sends a LAYOUTGET for a layout that spans the range of the queued write-behinds and well beyond, including ranges beyond the filer's current length. The client continues to send LAYOUTGET operations once the write-behind queue reaches 50% of the maximum queue length.",
      "ja": "* "
    },
    {
      "indent": 3,
      "text": "Once the client has obtained a layout referring to a particular device ID, the metadata server MUST NOT delete the device ID until the layout is returned or revoked.",
      "ja": "クライアントが特定のデバイスIDを参照してレイアウトを取得すると、メタデータサーバーはレイアウトが返されるか取り消されるまでデバイスIDを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "CB_NOTIFY_DEVICEID can race with LAYOUTGET. One race scenario is that LAYOUTGET returns a device ID for which the client does not have device address mappings, and the metadata server sends a CB_NOTIFY_DEVICEID to add the device ID to the client's awareness and meanwhile the client sends GETDEVICEINFO on the device ID. This scenario is discussed in Section 18.40.4. Another scenario is that the CB_NOTIFY_DEVICEID is processed by the client before it processes the results from LAYOUTGET. The client will send a GETDEVICEINFO on the device ID. If the results from GETDEVICEINFO are received before the client gets results from LAYOUTGET, then there is no longer a race. If the results from LAYOUTGET are received before the results from GETDEVICEINFO, the client can either wait for results of GETDEVICEINFO or send another one to get possibly more up-to-date device address mappings for the device ID.",
      "ja": "CB_NOTIFY_DEVICEIDはレイアウトとレースできます。1つのレースシナリオは、レイアウトがデバイスアドレスマッピングがないデバイスIDを返し、メタデータサーバーはCB_NOTIFY_DEVICEIDをCB_NOTIFY_DEVICEIDを送信してデバイスIDをクライアントの認識に追加し、その間、クライアントはデバイスIDにGetDeviceInfoを送信します。このシナリオは18.40.4節で議論されています。もう1つのシナリオは、CB_NOTIFY_DEVICEIDがレイアウトの結果を処理する前にクライアントによって処理されることです。クライアントはデバイスIDにgetDeviceInfoを送信します。getDeviceInfoの結果がクライアントがレイアウトから生じる前に受信された場合、レースはもうありません。GetDeviceInfoの結果の前にLayoutgetの結果を受信した場合、クライアントはGetDeviceInfoの結果を待つか、またはデバイスIDの最新のデバイスアドレスマッピングを得るために別のものを送信することができます。"
    },
    {
      "indent": 0,
      "text": "18.44. Operation 51: LAYOUTRETURN - Release Layout Information",
      "section_title": true,
      "ja": "18.44. 操作51：LayoutReturn  - リリースレイアウト情報"
    },
    {
      "indent": 0,
      "text": "18.44.1. ARGUMENT",
      "section_title": true,
      "ja": "18.44.1. 引数"
    },
    {
      "indent": 3,
      "text": "/* Constants used for LAYOUTRETURN and CB_LAYOUTRECALL */\nconst LAYOUT4_RET_REC_FILE      = 1;\nconst LAYOUT4_RET_REC_FSID      = 2;\nconst LAYOUT4_RET_REC_ALL       = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum layoutreturn_type4 {\n        LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE,\n        LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID,\n        LAYOUTRETURN4_ALL  = LAYOUT4_RET_REC_ALL\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct layoutreturn_file4 {\n        offset4         lrf_offset;\n        length4         lrf_length;\n        stateid4        lrf_stateid;\n        /* layouttype4 specific data */\n        opaque          lrf_body<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {\n        case LAYOUTRETURN4_FILE:\n                layoutreturn_file4      lr_layout;\n        default:\n                void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LAYOUTRETURN4args {\n        /* CURRENT_FH: file */\n        bool                    lora_reclaim;\n        layouttype4             lora_layout_type;\n        layoutiomode4           lora_iomode;\n        layoutreturn4           lora_layoutreturn;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.44.2. RESULT",
      "section_title": true,
      "ja": "18.44.2. 結果"
    },
    {
      "indent": 3,
      "text": "union layoutreturn_stateid switch (bool lrs_present) {\ncase TRUE:\n        stateid4                lrs_stateid;\ncase FALSE:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LAYOUTRETURN4res switch (nfsstat4 lorr_status) {\ncase NFS4_OK:\n        layoutreturn_stateid    lorr_stateid;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.44.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.44.3. description"
    },
    {
      "indent": 3,
      "text": "This operation returns from the client to the server one or more layouts represented by the client ID (derived from the session ID in the preceding SEQUENCE operation), lora_layout_type, and lora_iomode. When lr_returntype is LAYOUTRETURN4_FILE, the returned layout is further identified by the current filehandle, lrf_offset, lrf_length, and lrf_stateid. If the lrf_length field is NFS4_UINT64_MAX, all bytes of the layout, starting at lrf_offset, are returned. When lr_returntype is LAYOUTRETURN4_FSID, the current filehandle is used to identify the file system and all layouts matching the client ID, the fsid of the file system, lora_layout_type, and lora_iomode are returned. When lr_returntype is LAYOUTRETURN4_ALL, all layouts matching the client ID, lora_layout_type, and lora_iomode are returned and the current filehandle is not used. After this call, the client MUST NOT use the returned layout(s) and the associated storage protocol to access the file data.",
      "ja": "この操作は、クライアントからサーバーへ戻る（前のシーケンス操作のセッションIDから派生した）、LORA_LAYOUT_TYPE、およびLORA_IOMODEによって表されます。lr_returntypeがlayoutreturn4_fileの場合、返されたレイアウトは現在のFileHandle、LRF_OFFSET、LRF_LENGTH、およびLRF_STATEIDによってさらに識別されます。LRF_LengthフィールドがNFS4_UINT64_MAXの場合、LRF_OFFSETから始まるレイアウトのすべてのバイトが返されます。LR_RETURNTYPEがLayOutReturn4_FSIDの場合、現在のファイルハンドルはファイルシステムを識別し、クライアントIDのすべてのレイアウト、ファイルシステムのFSID、Lora_Layout_Type、およびLora_iomodeを識別します。LR_RETURNTYPEがLAYOUTRETURN4_ALLの場合、クライアントID、LORA_LAYOUT_TYPE、およびLORA_IOMODEと一致するすべてのレイアウトが返され、現在のファイルハンドルが使用されません。この呼び出しの後、クライアントは返されたレイアウトと関連するストレージプロトコルを使用してファイルデータにアクセスしてはいけません。"
    },
    {
      "indent": 3,
      "text": "If the set of layouts designated in the case of LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL is empty, then no error results. In the case of LAYOUTRETURN4_FILE, the byte-range specified is returned even if it is a subdivision of a layout previously obtained with LAYOUTGET, a combination of multiple layouts previously obtained with LAYOUTGET, or a combination including some layouts previously obtained with LAYOUTGET, and one or more subdivisions of such layouts. When the byte-range does not designate any bytes for which a layout is held for the specified file, client ID, layout type and mode, no error results. See Section 12.5.5.2.1.5 for considerations with \"bulk\" return of layouts.",
      "ja": "LayoutReturn4_FSIDまたはLayoutReturn4_allの場合に指定されたレイアウトのセットが空の場合、エラー結果は発生しません。LayoutReturn4_fileの場合、Layoutgetで以前に取得されたレイアウトの細分化であっても、指定されたバイト範囲は返され、レイアウトゲットで以前に取得された複数のレイアウトの組み合わせ、またはLayoutGetで以前に取得されたいくつかのレイアウトを含む組み合わせそのようなレイアウトのより多くの細分化。指定されたファイル、クライアントID、レイアウトの種類、およびモードに対してレイアウトが保持されているバイトが指定されていない場合、エラー結果は発生しません。レイアウトの「バルク」戻る考慮事項については、セクション12.5.5.2.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The layout being returned may be a subset or superset of a layout specified by CB_LAYOUTRECALL. However, if it is a subset, the recall is not complete until the full recalled scope has been returned. Recalled scope refers to the byte-range in the case of LAYOUTRETURN4_FILE, the use of LAYOUTRETURN4_FSID, or the use of LAYOUTRETURN4_ALL. There must be a LAYOUTRETURN with a matching scope to complete the return even if all current layout ranges have been previously individually returned.",
      "ja": "返されるレイアウトは、cb_layoutrecallによって指定されたレイアウトのサブセットまたはスーパーセットです。ただし、サブセットの場合は、リコールされたスコープが返されるまで、リコールは完了しません。Realled Scopeは、LayoutReturn4_file、LayoutReturn4_FSIDの使用、またはLayOutReturn4_allの使用の場合のバイト範囲を指します。現在のレイアウト範囲が以前に個別に返されている場合でも、一致するスコープを一致させるレイアウトリターンが必要です。"
    },
    {
      "indent": 3,
      "text": "For all lr_returntype values, an iomode of LAYOUTIOMODE4_ANY specifies that all layouts that match the other arguments to LAYOUTRETURN (i.e., client ID, lora_layout_type, and one of current filehandle and range; fsid derived from current filehandle; or LAYOUTRETURN4_ALL) are being returned.",
      "ja": "すべてのLR_ReturnType値の場合、LAYOUTIOMODE4_ANのIOMODEは、LayoutReturnに他の引数と一致するすべてのレイアウト（すなわち、クライアントID、LORA_LAYOUT_TYPE、および現在のファイルハンドルおよび範囲の1つ、現在のファイルハンドルから派生したFSID、またはLayOutReturn4_all）が返されていることを指定します。"
    },
    {
      "indent": 3,
      "text": "In the case that lr_returntype is LAYOUTRETURN4_FILE, the lrf_stateid provided by the client is a layout stateid as returned from previous layout operations. Note that the \"seqid\" field of lrf_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "LR_RETURNTYPEがLAYOUTRETURN4_FILEの場合、クライアントによって提供されるLRF_STATEIDは、以前のレイアウト操作から返されるレイアウトSTAIDIDです。LRF_StateIDの「seqid」フィールドはゼロにしてはならないことに注意してください。さらなる議論と要件については、セクション8.2,12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Return of a layout or all layouts does not invalidate the mapping of storage device ID to a storage device address. The mapping remains in effect until specifically changed or deleted via device ID notification callbacks. Of course if there are no remaining layouts that refer to a previously used device ID, the server is free to delete a device ID without a notification callback, which will be the case when notifications are not in effect.",
      "ja": "レイアウトの戻りまたはすべてのレイアウトは、ストレージデバイスIDのストレージデバイスアドレスへのマッピングを無効にしません。マッピングは、デバイスID通知コールバックを介して特に変更または削除されるまで有効です。もちろん、以前に使用されているデバイスIDを参照する残りのレイアウトがない場合、サーバーは通知コールバックなしでデバイスIDを空いています。これは通知が有効になっていない場合になります。"
    },
    {
      "indent": 3,
      "text": "If the lora_reclaim field is set to TRUE, the client is attempting to return a layout that was acquired before the restart of the metadata server during the metadata server's grace period. When returning layouts that were acquired during the metadata server's grace period, the client MUST set the lora_reclaim field to FALSE. The lora_reclaim field MUST be set to FALSE also when lr_layoutreturn is LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL. See LAYOUTCOMMIT (Section 18.42) for more details.",
      "ja": "lora_reclaimフィールドがtrueに設定されている場合、クライアントはメタデータサーバーの猶予期間中にメタデータサーバーの再起動前に取得されたレイアウトを返しようとしています。メタデータサーバーの猶予期間中に取得されたレイアウトを返すとき、クライアントはLora_Reclaimフィールドをfalseに設定する必要があります。LR_LAYOUTReturnがLayOutReturn4_FSIDまたはLayOutReturn4_allの場合にもlora_reclaimフィールドをfalseに設定する必要があります。詳細についてはLayoutCommit（18.42節）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Layouts may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case, the client must properly propagate state changed under the context of the layout to the storage device(s) or to the metadata server before returning the layout.",
      "ja": "リコールまたは自発的に（サーバーがそれらを呼び戻される前に）レイアウトが返されることがあります。どちらの場合でも、レイアウトを返す前に、クライアントはレイアウトのコンテキストまたはメタデータサーバにレイアウトのコンテキストで変化した状態を正しく伝播する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client returns the layout in response to a CB_LAYOUTRECALL where the lor_recalltype field of the clora_recall field was LAYOUTRECALL4_FILE, the client should use the lor_stateid value from CB_LAYOUTRECALL as the value for lrf_stateid. Otherwise, it should use logr_stateid (from a previous LAYOUTGET result) or lorr_stateid (from a previous LAYRETURN result). This is done to indicate the point in time (in terms of layout stateid transitions) when the recall was sent. The client uses the precise lora_recallstateid value and MUST NOT set the stateid's seqid to zero; otherwise, NFS4ERR_BAD_STATEID MUST be returned. NFS4ERR_OLD_STATEID can be returned if the client is using an old seqid, and the server knows the client should not be using the old seqid. For example, the client uses the seqid on slot 1 of the session, receives the response with the new seqid, and uses the slot to send another request with the old seqid.",
      "ja": "CLORA_RECALLフィールドのLOR_RECALLTYPEフィールドがLAIOUTRECALL4_FILEであるCB_LAYOUTRECALLに応答してクライアントを返す場合、クライアントはLRF_STATEIDの値としてCB_LAYOUTRECALLからLOR_STATID値を使用する必要があります。それ以外の場合は、LOGR_STATEID（前のLayRetget結果から）またはLorr_StateID（前のレプリタ結果から）を使用する必要があります。これは、リコールが送信されたときに（レイアウトステーションID遷移）時点（レイアウトステーションID遷移）を示すために行われます。クライアントは正確なLORA_RECALLSTATEID値を使用し、StateIDのSEQIDをゼロに設定してはいけません。それ以外の場合は、NFS4ERR_BAD_STATEIDを返す必要があります。クライアントが古いSEQIDを使用している場合、NFS4ERR_OLD_STATEIDは返され、サーバーはクライアントが古いSEQIDを使用してはいけません。たとえば、クライアントはセッションのスロット1でSEQIDを使用し、新しいSEQIDで応答を受け取り、スロットを使用して古いSEQIDを使用して別の要求を送信します。"
    },
    {
      "indent": 3,
      "text": "If a client fails to return a layout in a timely manner, then the metadata server SHOULD use its control protocol with the storage devices to fence the client from accessing the data referenced by the layout. See Section 12.5.5 for more details.",
      "ja": "クライアントがタイムリーにレイアウトを返すことに失敗した場合、メタデータサーバは、レイアウトによって参照されるデータにアクセスすることから、クライアントがレイアウトによってアクセスされてクライアントにフェンスを与えるようにその制御プロトコルを使用する必要があります。詳細については12.5.5項を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the LAYOUTRETURN request sets the lora_reclaim field to TRUE after the metadata server's grace period, NFS4ERR_NO_GRACE is returned.",
      "ja": "LayoutReturn要求が、メタデータサーバの猶予期間の後にlora_reclaimフィールドをtrueに設定した場合、NFS4ERR_NO_GRACEが返されます。"
    },
    {
      "indent": 3,
      "text": "If the LAYOUTRETURN request sets the lora_reclaim field to TRUE and lr_returntype is set to LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL, NFS4ERR_INVAL is returned.",
      "ja": "LayoutReturn要求がlora_reclaimフィールドをtrueに設定し、LR_ReturnTypeがLayOutReturn4_FSIDまたはLayoutReturn4_allに設定されている場合、NFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "If the client sets the lr_returntype field to LAYOUTRETURN4_FILE, then the lrs_stateid field will represent the layout stateid as updated for this operation's processing; the current stateid will also be updated to match the returned value. If the last byte of any layout for the current file, client ID, and layout type is being returned and there are no remaining pending CB_LAYOUTRECALL operations for which a LAYOUTRETURN operation must be done, lrs_present MUST be FALSE, and no stateid will be returned. In addition, the COMPOUND request's current stateid will be set to the all-zeroes special stateid (see Section 16.2.3.1.2). The server MUST reject with NFS4ERR_BAD_STATEID any further use of the current stateid in that COMPOUND until the current stateid is re-established by a later stateid-returning operation.",
      "ja": "クライアントがLR_RETURNTYPEフィールドをLAROUTRETURN4_FILEに設定した場合、lrs_stateIDフィールドはこの操作の処理の更新されているレイアウトステートIDを表します。現在のStateIDは、戻り値と一致するように更新されます。現在のファイル、クライアントID、およびレイアウトタイプのレイアウトの最後のバイトが返され、LayoutReturn操作を行う必要がある残りの保留中のCB_LAYOUTRECALL操作が残っていない場合は、LRS_PRESENTがFALSEでなければなりません。これは返されません。さらに、複合要求の現在のStateIDは、All-Zeroes Special StareIDに設定されます（セクション16.2.3.1.2を参照）。サーバーは、現在のStateIDが後のStateID戻り操作によって再確立されるまで、現在のStateIDをその化合物のさらなる使用任意の使用を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "If the EXCHGID4_FLAG_BIND_PRINC_STATEID capability is set on the client ID (see Section 18.35), the server will require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the layout also be the one to send LAYOUTRETURN. This might not be possible if credentials for the principal are no longer available. The server will allow the machine credential or SSV credential (see Section 18.35) to send LAYOUTRETURN if LAYOUTRETURN's operation code was set in the spo_must_allow result of EXCHANGE_ID.",
      "ja": "Exchgid4_flag_bind_princ_stateID機能がクライアントIDに設定されている場合（セクション18.35を参照）、サーバーはプリンシパル、セキュリティフレーバー、および該当する場合はGSSメカニズム、レイアウトを取得した組み合わせもLayoutReturnを送信するものである必要があります。これは、プリンシパルの認証情報が使用できなくなった場合は不可能かもしれません。SPO_MUST_ARLOWのspo_must_allow結果にLayoutReturnのオペレーションコードが設定されている場合、サーバーはマシンの信任状またはSSVの信任状（セクション18.35を参照）を送信します。"
    },
    {
      "indent": 0,
      "text": "18.44.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.44.4. 実装"
    },
    {
      "indent": 3,
      "text": "The final LAYOUTRETURN operation in response to a CB_LAYOUTRECALL callback MUST be serialized with any outstanding, intersecting LAYOUTRETURN operations. Note that it is possible that while a client is returning the layout for some recalled range, the server may recall a superset of that range (e.g., LAYOUTRECALL4_ALL); the final return operation for the latter must block until the former layout recall is done.",
      "ja": "CB_LAYOUTRECALLコールバックに応答した最終的なLayoutReturn操作は、既に、交差するLayoutReturn操作でシリアル化されなければなりません。なお、クライアントが何らかのリコール範囲のレイアウトを返送している間に、サーバはその範囲のスーパーセット（例えばLAYOUTRECALL4_ALL）を呼び出すことができることに注意してください。後者の最後の戻り操作は、前者のレイアウトリコールが行われるまでブロックする必要があります。"
    },
    {
      "indent": 3,
      "text": "Returning all layouts in a file system using LAYOUTRETURN4_FSID is typically done in response to a CB_LAYOUTRECALL for that file system as the final return operation. Similarly, LAYOUTRETURN4_ALL is used in response to a recall callback for all layouts. It is possible that the client already returned some outstanding layouts via individual LAYOUTRETURN calls and the call for LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL marks the end of the LAYOUTRETURN sequence. See Section 12.5.5.1 for more details.",
      "ja": "LayoutReturn4_FSIDを使用してファイルシステム内のすべてのレイアウトを返すことは、通常、そのファイルシステムのCB_LAYOUTRecallに応答して最終的なリターン操作として行われます。同様に、LayoutReturn4_allはすべてのレイアウトの呼び出しコールバックに応答して使用されます。クライアントはすでに個々のLayoutReturn呼び出しを介していくつかの未処理のレイアウトを返し、LayoutReturn4_FSIDまたはLayOutReturn4_allの呼び出しはLayoutReturnシーケンスの終わりをマークします。詳細については12.5.5.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Once the client has returned all layouts referring to a particular device ID, the server MAY delete the device ID.",
      "ja": "クライアントが特定のデバイスIDを参照してすべてのレイアウトを返したら、サーバーはデバイスIDを削除できます。"
    },
    {
      "indent": 0,
      "text": "18.45. Operation 52: SECINFO_NO_NAME - Get Security on Unnamed Object",
      "section_title": true,
      "ja": "18.45. 操作52：secinfo_no_name  - 名前なしオブジェクトのセキュリティを取得する"
    },
    {
      "indent": 0,
      "text": "18.45.1. ARGUMENT",
      "section_title": true,
      "ja": "18.45.1. 引数"
    },
    {
      "indent": 3,
      "text": "enum secinfo_style4 {\n        SECINFO_STYLE4_CURRENT_FH       = 0,\n        SECINFO_STYLE4_PARENT           = 1\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: object or child directory */\ntypedef secinfo_style4 SECINFO_NO_NAME4args;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.45.2. RESULT",
      "section_title": true,
      "ja": "18.45.2. 結果"
    },
    {
      "indent": 3,
      "text": "/* CURRENTFH: consumed if status is NFS4_OK */\ntypedef SECINFO4res SECINFO_NO_NAME4res;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.45.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.45.3. description"
    },
    {
      "indent": 3,
      "text": "Like the SECINFO operation, SECINFO_NO_NAME is used by the client to obtain a list of valid RPC authentication flavors for a specific file object. Unlike SECINFO, SECINFO_NO_NAME only works with objects that are accessed by filehandle.",
      "ja": "SECINFO操作と同様に、SECINFO_NO_NAMEは、特定のファイルオブジェクトの有効なRPC認証フレーバーのリストを取得するためにクライアントによって使用されます。SecInfoとは異なり、secinfo_no_nameはFileHandleによってアクセスされるオブジェクトとのみ機能します。"
    },
    {
      "indent": 3,
      "text": "There are two styles of SECINFO_NO_NAME, as determined by the value of the secinfo_style4 enumeration. If SECINFO_STYLE4_CURRENT_FH is passed, then SECINFO_NO_NAME is querying for the required security for the current filehandle. If SECINFO_STYLE4_PARENT is passed, then SECINFO_NO_NAME is querying for the required security of the current filehandle's parent. If the style selected is SECINFO_STYLE4_PARENT, then SECINFO should apply the same access methodology used for LOOKUPP when evaluating the traversal to the parent directory. Therefore, if the requester does not have the appropriate access to LOOKUPP the parent, then SECINFO_NO_NAME must behave the same way and return NFS4ERR_ACCESS.",
      "ja": "SECINFO_STYLE4列挙体の値によって決定された、2つのスタイルのsecinfo_no_nameがあります。secinfo_style4_current_fhが渡された場合、secinfo_no_nameは現在のファイルハンドルに対して必要なセキュリティを照会しています。secinfo_style4_parentが渡されると、secinfo_no_nameは現在のFileHandleの親の必要なセキュリティを照会しています。選択したスタイルがsecinfo_style4_parentの場合、SecInfoは、親ディレクトリへのトラバースを評価するときにLookuppに使用される同じアクセス方法を適用する必要があります。したがって、リクエスタに親をLookuppにLookuppにアクセスできない場合は、SECINFO_NO_NAMEが同じ方法を動作させてNFS4ERR_ACCESSを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH returns NFS4ERR_WRONGSEC, then the client resolves the situation by sending a COMPOUND request that consists of PUTFH, PUTPUBFH, or PUTROOTFH immediately followed by SECINFO_NO_NAME, style SECINFO_STYLE4_CURRENT_FH. See Section 2.6 for instructions on dealing with NFS4ERR_WRONGSEC error returns from PUTFH, PUTROOTFH, PUTPUBFH, or RESTOREFH.",
      "ja": "PUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFHがNFS4ERR_WRONGSECを返す場合、クライアントは、PUTFH、PUTPUBFH、またはPUTROOTFHからなる複合要求を直ちにSECINFO_NO_NAME、スタイルSECINFO_STYLE4_CURRENT_FHを送信することで状況を解決します。NFS4ERR_WRONGSECエラーを対処する方法については、2.6項を参照してください.Putfh、PutRoOTFH、PutPubfh、またはRestoreFHから戻ります。"
    },
    {
      "indent": 3,
      "text": "If SECINFO_STYLE4_PARENT is specified and there is no parent directory, SECINFO_NO_NAME MUST return NFS4ERR_NOENT.",
      "ja": "secinfo_style4_parentが指定されていて、親ディレクトリがない場合、secinfo_no_nameはNFS4ERR_NOENTを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO_NO_NAME tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.",
      "ja": "成功すると、現在のFileHandleが消費されます（2.6.3.1.1.8項参照）、SECINFO_NO_NAME以降の次の操作が現在のファイルハンドルの使用を試行しようとすると、その操作はステータスNFS4ERR_NOFILEHANDLEで失敗します。"
    },
    {
      "indent": 3,
      "text": "Everything else about SECINFO_NO_NAME is the same as SECINFO. See the discussion on SECINFO (Section 18.29.3).",
      "ja": "SECINFO_NO_NAMEについて他のすべてのものはSecInfoと同じです。SecInfoの説明を参照してください（第18.29.3項）。"
    },
    {
      "indent": 0,
      "text": "18.45.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.45.4. 実装"
    },
    {
      "indent": 3,
      "text": "See the discussion on SECINFO (Section 18.29.4).",
      "ja": "SecInfoの説明を参照してください（第18.29.4項）。"
    },
    {
      "indent": 0,
      "text": "18.46. Operation 53: SEQUENCE - Supply Per-Procedure Sequencing and Control",
      "ja": "18.46. 動作53：シーケンス - 手順ごとの配列決定と制御"
    },
    {
      "indent": 0,
      "text": "18.46.1. ARGUMENT",
      "section_title": true,
      "ja": "18.46.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct SEQUENCE4args {\n        sessionid4     sa_sessionid;\n        sequenceid4    sa_sequenceid;\n        slotid4        sa_slotid;\n        slotid4        sa_highest_slotid;\n        bool           sa_cachethis;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.46.2. RESULT",
      "section_title": true,
      "ja": "18.46.2. 結果"
    },
    {
      "indent": 3,
      "text": "const SEQ4_STATUS_CB_PATH_DOWN                  = 0x00000001;\nconst SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING      = 0x00000002;\nconst SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED       = 0x00000004;\nconst SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED     = 0x00000008;\nconst SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED    = 0x00000010;\nconst SEQ4_STATUS_ADMIN_STATE_REVOKED           = 0x00000020;\nconst SEQ4_STATUS_RECALLABLE_STATE_REVOKED      = 0x00000040;\nconst SEQ4_STATUS_LEASE_MOVED                   = 0x00000080;\nconst SEQ4_STATUS_RESTART_RECLAIM_NEEDED        = 0x00000100;\nconst SEQ4_STATUS_CB_PATH_DOWN_SESSION          = 0x00000200;\nconst SEQ4_STATUS_BACKCHANNEL_FAULT             = 0x00000400;\nconst SEQ4_STATUS_DEVID_CHANGED                 = 0x00000800;\nconst SEQ4_STATUS_DEVID_DELETED                 = 0x00001000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SEQUENCE4resok {\n        sessionid4      sr_sessionid;\n        sequenceid4     sr_sequenceid;\n        slotid4         sr_slotid;\n        slotid4         sr_highest_slotid;\n        slotid4         sr_target_highest_slotid;\n        uint32_t        sr_status_flags;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union SEQUENCE4res switch (nfsstat4 sr_status) {\ncase NFS4_OK:\n        SEQUENCE4resok  sr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.46.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.46.3. description"
    },
    {
      "indent": 3,
      "text": "The SEQUENCE operation is used by the server to implement session request control and the reply cache semantics.",
      "ja": "シーケンス動作は、セッション要求制御と応答キャッシュの意味を実装するためにサーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "SEQUENCE MUST appear as the first operation of any COMPOUND in which it appears. The error NFS4ERR_SEQUENCE_POS will be returned when it is found in any position in a COMPOUND beyond the first. Operations other than SEQUENCE, BIND_CONN_TO_SESSION, EXCHANGE_ID, CREATE_SESSION, and DESTROY_SESSION, MUST NOT appear as the first operation in a COMPOUND. Such operations MUST yield the error NFS4ERR_OP_NOT_IN_SESSION if they do appear at the start of a COMPOUND.",
      "ja": "シーケンスは、それが現れる化合物の最初の操作として現れる必要があります。エラーNFS4ERR_SEQUENCE_POSは、最初のものを超えた化合物の任意の位置にあるときに返されます。シーケンス、bind_conn_to_session、Exchange_ID、Create_Session、およびDestroy_Session以外の操作は、コンパウンドの最初の操作として表示されません。そのような操作は、それらが複合の開始時に表示された場合、エラーNFS4ERR_OP_NOT_IN_SESSESTを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE is received on a connection not associated with the session via CREATE_SESSION or BIND_CONN_TO_SESSION, and connection association enforcement is enabled (see Section 18.35), then the server returns NFS4ERR_CONN_NOT_BOUND_TO_SESSION.",
      "ja": "create_sessionまたはbind_conn_to_sessionを介してセッションに関連付けられていない接続でシーケンスが受信され、接続アソシエーション施行が有効になっている場合（セクション18.35を参照）、サーバーはnfs4err_conn_not_bound_to_sessionを返します。"
    },
    {
      "indent": 3,
      "text": "The sa_sessionid argument identifies the session to which this request applies. The sr_sessionid result MUST equal sa_sessionid.",
      "ja": "SA_SESSIONID引数は、この要求が適用されるセッションを識別します。SR_SESSIONIDの結果はSA_SESSIONIDと等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sa_slotid argument is the index in the reply cache for the request. The sa_sequenceid field is the sequence number of the request for the reply cache entry (slot). The sr_slotid result MUST equal sa_slotid. The sr_sequenceid result MUST equal sa_sequenceid.",
      "ja": "SA_SLOTID引数は、要求の応答キャッシュ内のインデックスです。SA_SEQUENCEIDフィールドは、応答キャッシュエントリ（スロット）の要求のシーケンス番号です。SR_SLOTID結果はSA_SLOTIDと等しくなければなりません。SR_SEQUENCEDIDの結果はSA_SEQUENCEIDと等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sa_highest_slotid argument is the highest slot ID for which the client has a request outstanding; it could be equal to sa_slotid. The server returns two \"highest_slotid\" values: sr_highest_slotid and sr_target_highest_slotid. The former is the highest slot ID the server will accept in future SEQUENCE operation, and SHOULD NOT be less than the value of sa_highest_slotid (but see Section 2.10.6.1 for an exception). The latter is the highest slot ID the server would prefer the client use on a future SEQUENCE operation.",
      "ja": "SA_HIGHEST_SLOTID引数は、クライアントが要求を未解決の要求にある最も高いスロットIDです。SA_SLOTIDと等しくなる可能性があります。サーバーは、SR_HIGHEST_SLOTIDとSR_TARGET_HIGHEST_SLOTIDの2つの「hight_slotid」値を返します。前者は、サーバーが将来のシーケンス操作で受け入れる最も高いスロットIDです。後者は最高のスロットIDであるため、サーバーは将来のシーケンス操作でクライアントの使用を好むであろう。"
    },
    {
      "indent": 3,
      "text": "If sa_cachethis is TRUE, then the client is requesting that the server cache the entire reply in the server's reply cache; therefore, the server MUST cache the reply (see Section 2.10.6.1.3). The server MAY cache the reply if sa_cachethis is FALSE. If the server does not cache the entire reply, it MUST still record that it executed the request at the specified slot and sequence ID.",
      "ja": "SA_CACHETHISがTRUEの場合、クライアントはサーバーの応答キャッシュ内の応答全体をキャッシュするように要求しています。したがって、サーバーは返信をキャッシュする必要があります（セクション2.10.6.1.3を参照）。sa_cachethisがfalseの場合、サーバーは返信をキャッシュすることがあります。サーバーが返信全体をキャッシュしない場合は、指定されたスロットとシーケンスIDで要求を実行したことを記録する必要があります。"
    },
    {
      "indent": 3,
      "text": "The response to the SEQUENCE operation contains a word of status flags (sr_status_flags) that can provide to the client information related to the status of the client's lock state and communications paths. Note that any status bits relating to lock state MAY be reset when lock state is lost due to a server restart (even if the session is persistent across restarts; session persistence does not imply lock state persistence) or the establishment of a new client instance.",
      "ja": "シーケンス操作に対する応答は、クライアントのロック状態および通信経路のステータスに関連するクライアント情報に提供することができるステータスフラグ（SR_STATUS_FLAGS）のワードを含む。ロック状態に関連するステータスビットは、サーバの再起動のためにロック状態が失われたときにリセットされることがあります（セッションが再起動中に永続的な場合でも、セッションの持続性は、ロック状態の永続化を意味するものではありません）、または新しいクライアントインスタンスの確立はありません。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_PATH_DOWN When set, indicates that the client has no operational backchannel path for any session associated with the client ID, making it necessary for the client to re-establish one. This bit remains set on all SEQUENCE responses on all sessions associated with the client ID until at least one backchannel is available on any session associated with the client ID. If the client fails to re-establish a backchannel for the client ID, it is subject to having recallable state revoked.",
      "ja": "SEQ4_STATUS_CB_PATH_DOWN SETの場合、クライアントにクライアントIDに関連付けられているセッションのための動作上のバックチャネルパスがないことを示し、クライアントが1つを再確立するのに必要にします。このビットは、クライアントIDに関連付けられているセッションですべてのセッションで利用可能になるまで、クライアントIDに関連付けられているすべてのセッションですべてのシーケンス応答に設定されています。クライアントがクライアントIDのバックチャネルを再確立できない場合は、リコール可能な状態が取り消されることがあります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_PATH_DOWN_SESSION When set, indicates that the session has no operational backchannel. There are two reasons why SEQ4_STATUS_CB_PATH_DOWN_SESSION may be set and not SEQ4_STATUS_CB_PATH_DOWN. First is that a callback operation that applies specifically to the session (e.g., CB_RECALL_SLOT, see Section 20.8) needs to be sent. Second is that the server did send a callback operation, but the connection was lost before the reply. The server cannot be sure whether or not the client received the callback operation, and so, per rules on request retry, the server MUST retry the callback operation over the same session. The SEQ4_STATUS_CB_PATH_DOWN_SESSION bit is the indication to the client that it needs to associate a connection to the session's backchannel. This bit remains set on all SEQUENCE responses of the session until a connection is associated with the session's a backchannel. If the client fails to re-establish a backchannel for the session, it is subject to having recallable state revoked.",
      "ja": "SEQ4_STATUS_CB_PATH_DOWN_DOWNES_DOWNESSセッションの場合、セッションには操作上のバックチャネルがないことを示します。 SEQ4_STATUS_CB_PATH_DOWN_SESSIONを設定し、SEQ4_STATUS_CB_PATH_DOWNではなく2つの理由があります。第1に、セッションに特別に適用されるコールバック操作（例えば、CB_RECALL_SLOT、セクション20.8）を送信する必要があることである。 2つ目は、サーバーがコールバック操作を送信したが、返信前に接続が失われました。サーバーは、クライアントがコールバック操作を受信したかどうかを確認できます。そうすれば、リクエストの再試行時のルールごとにサーバーは、同じセッションでコールバック操作を再試行する必要があります。 SEQ4_STATUS_CB_PATH_DOWN_SESSIONビットは、セッションのBackChannelに接続を関連付ける必要があるクライアントへの表示です。このビットは、セッションがセッションのバックチャネルに関連付けられるまでセッションのすべてのシーケンス応答に設定されたままです。クライアントがセッションのバックチャネルを再確立できない場合は、リコール可能な状態が取り消されることがあります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING When set, indicates that all GSS contexts or RPCSEC_GSS handles assigned to the session's backchannel will expire within a period equal to the lease time. This bit remains set on all SEQUENCE replies until at least one of the following are true:",
      "ja": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRICING SETの場合、セッションのBASSCHANNELに割り当てられているすべてのGSSコンテキストまたはRPCSEC_GSSハンドルがリース時間と同じ期間内に期限切れになることを示します。このビットは、次のいずれかに該当するまで、すべてのシーケンスの返信に設定されたままになります。"
    },
    {
      "indent": 6,
      "text": "* All SSV RPCSEC_GSS handles on the session's backchannel have been destroyed and all non-SSV GSS contexts have expired.",
      "ja": "* セッションのバックチャネル上のすべてのSSV RPCSEC_GSSハンドルが破棄され、すべての非SSV GSSコンテキストが期限切れになっています。"
    },
    {
      "indent": 6,
      "text": "* At least one more SSV RPCSEC_GSS handle has been added to the backchannel.",
      "ja": "* バックチャネルに少なくとも1つのSSV RPCSEC_GSSハンドルが追加されました。"
    },
    {
      "indent": 6,
      "text": "* The expiration time of at least one non-SSV GSS context of an RPCSEC_GSS handle is beyond the lease period from the current time (relative to the time of when a SEQUENCE response was sent)",
      "ja": "* RPCSEC_GSSハンドルの少なくとも1つの非SSV GSSコンテキストの有効期限は、現在の時刻からのリース期間を超えています（シーケンス応答が送信された時点から）。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED When set, indicates all non-SSV GSS contexts and all SSV RPCSEC_GSS handles assigned to the session's backchannel have expired or have been destroyed. This bit remains set on all SEQUENCE replies until at least one non-expired non-SSV GSS context for the session's backchannel has been established or at least one SSV RPCSEC_GSS handle has been assigned to the backchannel.",
      "ja": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED SETの場合、すべての非SSV GSSコンテキストとセッションのバックチャネルに割り当てられているすべてのSSV RPCSEC_GSSハンドルが期限切れまたは破棄されたことを示します。このビットは、セッションのバックチャネルの少なくとも1つの期限切れの非SSV GSSコンテキストが確立されるか、少なくとも1つのSSV RPCSEC_GSSハンドルがバックチャネルに割り当てられているまで、すべてのシーケンス応答に設定されたままになります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED When set, indicates that the lease has expired and as a result the server released all of the client's locking state. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID (see Section 18.38), or by establishing a new client instance by destroying all sessions (via DESTROY_SESSION), the client ID (via DESTROY_CLIENTID), and then invoking EXCHANGE_ID and CREATE_SESSION to establish a new client ID.",
      "ja": "SEQ4_STATUS_EXPIED_ALL_STATE_REVOKED SETの場合、リースが期限切れになっている結果として、サーバーがすべてのクライアントのロック状態を解放したことを示します。このステータスビットは、そのようなロックの損失がFree_StateID（セクション18.38を参照）を使用して確認されるまで、または新しいクライアントインスタンスを確立するまで、または（Destroy_Sessionを介して）、クライアントID（via）を破棄することで新しいクライアントインスタンスを確立することで、すべてのシーケンスのビットが設定されたままになります。Destroy_ClientId）を参照してから、Exchange_idとcreate_sessionを呼び出して新しいクライアントIDを確立します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED When set, indicates that some subset of the client's locks have been revoked due to expiration of the lease period followed by another client's conflicting LOCK operation. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "SEQ4_STATUS_EXPIED_SOME_STATE_REVOKED SETの場合、リース期間の有効期限切れの原因となっているため、クライアントのロックのサブセットが取り消されたことを示します。このようなロックの損失がfree_stateIDの使用によって確認されるまで、このステータスビットはすべてのシーケンスの応答に設定されたままになります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_ADMIN_STATE_REVOKED When set, indicates that one or more locks have been revoked without expiration of the lease period, due to administrative action. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "SEQ4_STATUS_ADMIN_STATE_STATE_REVOKED SETの場合は、管理行動のため、リース期間の有効期限切れなしに1つ以上のロックが取り消されたことを示します。このようなロックの損失がfree_stateIDの使用によって確認されるまで、このステータスビットはすべてのシーケンスの応答に設定されたままになります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_RECALLABLE_STATE_REVOKED When set, indicates that one or more recallable objects have been revoked without expiration of the lease period, due to the client's failure to return them when recalled, which may be a consequence of there being no working backchannel and the client failing to re-establish a backchannel per the SEQ4_STATUS_CB_PATH_DOWN, SEQ4_STATUS_CB_PATH_DOWN_SESSION, or SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED status flags. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "seq4_status_recallable_state_state_state_revokedは、クライアントのリース期間の有効期限が切れていないため、リース期間の有効期限が切れていないことを示します。SEQ4_STATUS_CB_PATH_DOWN、SEQ4_STATUS_CB_PATH_DOWN_SESSION、またはSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDステータスフラグにあたりのバックチャンネルを確立します。このようなロックの損失がfree_stateIDの使用によって確認されるまで、このステータスビットはすべてのシーケンスの応答に設定されたままになります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_LEASE_MOVED When set, indicates that responsibility for lease renewal has been transferred to one or more new servers. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR for the fs_locations or fs_locations_info attribute for an access to each file system for which a lease has been moved to a new server. See Section 11.11.9.2.",
      "ja": "SEQ4_STATUS_LEASE_MOUMES_MOUMESETの場合、リース更新の責任が1つ以上の新しいサーバーに転送されたことを示します。この状態は、クライアントがNFS4ERR_VOUDエラーを受信するまで続き、リースが新しいサーバーに移動された各ファイルシステムへのアクセスのために、次のGetAttrをFS_LOCATIONATIONATIONSまたはFS_LOCATIONS_INFO属性に受け取ります。11.11.9.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_RESTART_RECLAIM_NEEDED When set, indicates that due to server restart, the client must reclaim locking state. Until the client sends a global RECLAIM_COMPLETE (Section 18.51), every SEQUENCE operation will return SEQ4_STATUS_RESTART_RECLAIM_NEEDED.",
      "ja": "SEQ4_STATUS_RESTART_RECLAIM_NEEDED SETの場合、サーバーの再起動のために、クライアントはロック状態を再埋め込む必要があることを示します。クライアントがグローバルRECLAIM_COMPLETEを送信するまで（セクション18.51）、すべてのシーケンス操作はSEQ4_STATUS_RESTART_RECLAIM_NEEDEDを返します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_BACKCHANNEL_FAULT The server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of the sequence ID for a slot in the backchannel). The client MUST stop sending more requests on the session's fore channel, wait for all outstanding requests to complete on the fore and back channel, and then destroy the session.",
      "ja": "SEQ4_STATUS_BACKCHANNEL_FAULTサーバーはバックチャネルを使用して回復不能な障害が発生しました（例えば、バックチャネル内のスロットのシーケンスIDのトラックを失っています）。クライアントはセッションの前のチャンネルでもっと多くの要求を送信するのを停止し、優先順位のすべての要求を前面およびバックチャネルで完了させてからセッションを破壊するのを待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_DEVID_CHANGED The client is using device ID notifications and the server has changed a device ID mapping held by the client. This flag will stay present until the client has obtained the new mapping with GETDEVICEINFO.",
      "ja": "SEQ4_STATUS_DEVID_CHANGEDクライアントはデバイスID通知を使用しており、サーバーはクライアントによって保持されているデバイスIDマッピングを変更しました。このフラグは、クライアントがGetDeviceInfoとの新しいマッピングを取得するまで存在します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_DEVID_DELETED The client is using device ID notifications and the server has deleted a device ID mapping held by the client. This flag will stay in effect until the client sends a GETDEVICEINFO on the device ID with a null value in the argument gdia_notify_types.",
      "ja": "SEQ4_STATUS_DEVID_DELETEDクライアントはデバイスID通知を使用しており、サーバーはクライアントによって保持されているデバイスIDマッピングを削除しました。このフラグは、クライアントがArgument GDIA_NOTIFY_TYPESにNULL値を持つデバイスIDにGetDeviceInfoを送信するまで有効になります。"
    },
    {
      "indent": 3,
      "text": "The value of the sa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.",
      "ja": "スロット上のキャッシュされたシーケンスIDに対するSA_SEQUENCEID引数の値は、3つのケースのいずれかに分類されます。"
    },
    {
      "indent": 3,
      "text": "* If the difference between sa_sequenceid and the server's cached sequence ID at the slot ID is two (2) or more, or if sa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the server MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "* SA_SEQUENCERIDとスロットIDのサーバーのキャッシュシーケンスIDとの差が2つ以上の場合、またはSA_SEQUENCEIDがキャッシュされたシーケンスID（符号なしシーケンスID値のラップアラウンドのアカウンティング）よりも小さい場合、サーバーは返さなければなりません。NFS4ERR_SEQ_MISORDERED"
    },
    {
      "indent": 3,
      "text": "* If sa_sequenceid and the cached sequence ID are the same, this is a retry, and the server replies with what is recorded in the reply cache. The lease is possibly renewed as described below.",
      "ja": "* SA_SEQUENCEDIDとキャッシュされたシーケンスIDが同じ場合、これはリトライです、そしてサーバーは応答キャッシュに記録されているものと応答します。リースは以下のように更新されます。"
    },
    {
      "indent": 3,
      "text": "* If sa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot's sequence ID is incremented. The operations subsequent to SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the SEQUENCE reply in the slot, maintain the session's activity, and possibly renew the lease.",
      "ja": "* SA_SEQUENCEDIDがキャッシュされたシーケンスIDより1大きい（ラップアラウンドのアカウンティング）の場合、これは新しい要求であり、スロットのシーケンスIDはインクリメントされます。シーケンスの後の動作は、あれば処理されます。他の操作がない場合、他の唯一の影響はスロット内のシーケンス応答をキャッシュし、セッションのアクティビティを維持し、リースを更新することです。"
    },
    {
      "indent": 3,
      "text": "If the client reuses a slot ID and sequence ID for a completely different request, the server MAY treat the request as if it is a retry of what it has already executed. The server MAY however detect the client's illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "クライアントが完全に異なる要求のためにスロットIDとシーケンスIDを再利用した場合、サーバーはすでに実行されているものの再試行であるかのように要求を扱うことがあります。ただし、サーバーはクライアントの不正な再利用を検出し、NFS4ERR_SEQ_FALSE_RETRYを返します。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change, and the associated lease MUST NOT be renewed.",
      "ja": "シーケンスがエラーを返す場合、スロットの状態（シーケンスID、キャッシュされた応答）は変更しないでください、そして関連するリースを更新してはいけません。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE returns NFS4_OK, then the associated lease MUST be renewed (see Section 8.3), except if SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED is returned in sr_status_flags.",
      "ja": "sequenceがNFS4_OKを返す場合は、SEQ4_STATUS_EXPIED_ALL_STATE_REVOKEDがSR_STATUS_FLAGSで返される場合を除き、関連するリースを更新する必要があります（セクション8.3を参照）。"
    },
    {
      "indent": 0,
      "text": "18.46.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.46.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MUST maintain a mapping of session ID to client ID in order to validate any operations that follow SEQUENCE that take a stateid as an argument and/or result.",
      "ja": "stareIDを引数や結果として実行する順序に従う任意の操作を検証するために、サーバーはクライアントIDへのセッションIDのマッピングを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client establishes a persistent session, then a SEQUENCE received after a server restart might encounter requests performed and recorded in a persistent reply cache before the server restart. In this case, SEQUENCE will be processed successfully, while requests that were not previously performed and recorded are rejected with NFS4ERR_DEADSESSION.",
      "ja": "クライアントが永続セッションを確立した場合、サーバーの再起動後に受信されたシーケンスは、サーバーの再起動前に永続的な返信キャッシュで実行され、永続的な返信キャッシュに記録される可能性があります。この場合、シーケンスは正常に処理され、以前に実行され記録されていなかった要求はNFS4ERR_DeadSessionで拒否されます。"
    },
    {
      "indent": 3,
      "text": "Depending on which of the operations within the COMPOUND were successfully performed before the server restart, these operations will also have replies sent from the server reply cache. Note that when these operations establish locking state, it is locking state that applies to the previous server instance and to the previous client ID, even though the server restart, which logically happened after these operations, eliminated that state. In the case of a partially executed COMPOUND, processing may reach an operation not processed during the earlier server instance, making this operation a new one and not performable on the existing session. In this case, NFS4ERR_DEADSESSION will be returned from that operation.",
      "ja": "サーバーの再起動前に複合内の操作が正常に実行されたのかによって、これらの操作にはサーバーの応答キャッシュから返信されます。なお、これらの操作がロック状態を確立すると、サーバが再起動したとしても、以前のサーバインスタンスと前のクライアントIDに適用されるロック状態があり、これらの操作の後に論理的に起こり、その状態が解消されます。部分的に実行された化合物の場合、処理は以前のサーバインスタンス中に処理されない操作に達することがあり、この操作を新しいセッションで実行不可能にする。この場合、NFS4ERR_DeadSessionはその操作から返されます。"
    },
    {
      "indent": 0,
      "text": "18.47. Operation 54: SET_SSV - Update SSV for a Client ID",
      "section_title": true,
      "ja": "18.47. 操作54：SET_SSV  - クライアントIDのSSVを更新する"
    },
    {
      "indent": 0,
      "text": "18.47.1. ARGUMENT",
      "section_title": true,
      "ja": "18.47.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct ssa_digest_input4 {\n        SEQUENCE4args sdi_seqargs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SET_SSV4args {\n        opaque          ssa_ssv<>;\n        opaque          ssa_digest<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.47.2. RESULT",
      "section_title": true,
      "ja": "18.47.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ssr_digest_input4 {\n        SEQUENCE4res sdi_seqres;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SET_SSV4resok {\n        opaque          ssr_digest<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union SET_SSV4res switch (nfsstat4 ssr_status) {\ncase NFS4_OK:\n        SET_SSV4resok   ssr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.47.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.47.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is used to update the SSV for a client ID. Before SET_SSV is called the first time on a client ID, the SSV is zero. The SSV is the key used for the SSV GSS mechanism (Section 2.10.9)",
      "ja": "この操作は、クライアントIDのSSVを更新するために使用されます。SET_SSVがクライアントIDで初めて呼び出される前に、SSVはゼロです。SSVはSSV GSSメカニズムに使用される鍵です（セクション2.10.9）。"
    },
    {
      "indent": 3,
      "text": "SET_SSV MUST be preceded by a SEQUENCE operation in the same COMPOUND. It MUST NOT be used if the client did not opt for SP4_SSV state protection when the client ID was created (see Section 18.35); the server returns NFS4ERR_INVAL in that case.",
      "ja": "SET_SSVの前には、同じ化合物のシーケンス操作が必要です。クライアントIDが作成されたときにクライアントがSP4_SSV状態保護を選択しなかった場合は使用しないでください（セクション18.35を参照）。その場合、サーバーはNFS4ERR_INVALを返します。"
    },
    {
      "indent": 3,
      "text": "The field ssa_digest is computed as the output of the HMAC (RFC 2104 [52]) using the subkey derived from the SSV4_SUBKEY_MIC_I2T and current SSV as the key (see Section 2.10.9 for a description of subkeys), and an XDR encoded value of data type ssa_digest_input4. The field sdi_seqargs is equal to the arguments of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.",
      "ja": "フィールドSSA_Digestは、SSV4_SUBKEY_MIC_I2Tおよび現在のSSVから派生したサブキーを使用して、HMACの出力として計算されます（RFC 2104 [52]）（SECT 2.10.9サブキーの説明についてはセクション2.10.9）、およびのXDRエンコードされた値が計算されます。データ型SSA_DIGEST_INPUT4。フィールドSDI_SEQARGSは、set_ssvがその中にある複合手順のシーケンス操作の引数に等しい。"
    },
    {
      "indent": 3,
      "text": "The argument ssa_ssv is XORed with the current SSV to produce the new SSV. The argument ssa_ssv SHOULD be generated randomly.",
      "ja": "引数SSA_SSVは現在のSSVでXされて新しいSSVを作成します。引数SSA_SSVはランダムに生成されるべきです。"
    },
    {
      "indent": 3,
      "text": "In the response, ssr_digest is the output of the HMAC using the subkey derived from SSV4_SUBKEY_MIC_T2I and new SSV as the key, and an XDR encoded value of data type ssr_digest_input4. The field sdi_seqres is equal to the results of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.",
      "ja": "応答では、SSR_DIGESTは、SSV4_SUBKEY_MIC_T2Iおよびキーとして新しいSSVから派生したサブキーを使用したHMACの出力、およびデータ型SSR_DIGEST_INPUT4のXDRエンコードされた値です。フィールドSDI_SEQRESは、set_ssvがその中にある複合手順のシーケンス操作の結果に等しい。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. The client and server each MUST maintain an internal SSV version number, which is set to one the first time SET_SSV executes on the server and the client receives the first SET_SSV reply. Each subsequent SET_SSV increases the internal SSV version number by one. The value of this version number corresponds to the smpt_ssv_seq, smt_ssv_seq, sspt_ssv_seq, and ssct_ssv_seq fields of the SSV GSS mechanism tokens (see Section 2.10.9).",
      "ja": "18.35項で述べたように、クライアントとサーバーはSSVの複数の同時バージョンを維持できます。クライアントとサーバーはそれぞれ、SET_SSVがサーバー上で実行され、クライアントが最初のSET_SSV応答を受信する1つに設定されている内部SSVバージョン番号を維持しなければなりません。後続のSET_SSVは、内部SSVのバージョン番号を1つずつ増加させます。このバージョン番号の値は、SSV GSSメカニズムトークンのsmpt_ssv_seq、smt_ssv_seq、sspt_ssv_seq、およびssct_ssv_seqフィールドに対応します（セクション2.10.9を参照）。"
    },
    {
      "indent": 0,
      "text": "18.47.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.47.4. 実装"
    },
    {
      "indent": 3,
      "text": "When the server receives ssa_digest, it MUST verify the digest by computing the digest the same way the client did and comparing it with ssa_digest. If the server gets a different result, this is an error, NFS4ERR_BAD_SESSION_DIGEST. This error might be the result of another SET_SSV from the same client ID changing the SSV. If so, the client recovers by sending a SET_SSV operation again with a recomputed digest based on the subkey of the new SSV. If the transport connection is dropped after the SET_SSV request is sent, but before the SET_SSV reply is received, then there are special considerations for recovery if the client has no more connections associated with sessions associated with the client ID of the SSV. See Section 18.34.4.",
      "ja": "サーバーがSSA_DIGESTを受信すると、クライアントがSSA_Digestと比較したのと同じ方法でダイジェストを計算することによってダイジェストを検証する必要があります。サーバーが異なる結果を得る場合、これはエラー、NFS4ERR_BAD_SESSION_DIGESTです。このエラーは、SSVを変更するのと同じクライアントIDから別のset_ssvの結果である可能性があります。もしそうであれば、クライアントは、新しいSSVのサブキーに基づいて再計算されたダイジェストを使用して、set_ssv演算を再度送信することによって回復します。set_ssv要求が送信された後にトランスポート接続がドロップされたが、set_ssv応答が受信される前に、クライアントがSSVのクライアントIDに関連付けられているセッションに関連付けられている接続がこれ以上接続されていない場合、コレクションに関する特別な考慮事項があります。18.34.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT send an ssa_ssv that is equal to a previous ssa_ssv, nor equal to a previous or current SSV (including an ssa_ssv equal to zero since the SSV is initialized to zero when the client ID is created).",
      "ja": "クライアントは、以前のSSA_SSVに等しいSSA_SSVを送信したり、クライアントIDが作成されたときにSSVがゼロになるため、SSA_SSVを含むSSA_SSVを含む）と同じです。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD send SET_SSV with RPCSEC_GSS privacy. Servers MUST support RPCSEC_GSS with privacy for any COMPOUND that has { SEQUENCE, SET_SSV }.",
      "ja": "クライアントはset_ssvをrpcsec_gssプライバシーで送信する必要があります。サーバーは、{sequence、set_ssv}を持つ任意の化合物のプライバシーを持つRPCSEC_GSSをサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD NOT send SET_SSV with the SSV GSS mechanism's credential because the purpose of SET_SSV is to seed the SSV from non-SSV credentials. Instead, SET_SSV SHOULD be sent with the credential of a user that is accessing the client ID for the first time (Section 2.10.8.3). However, if the client does send SET_SSV with SSV credentials, the digest protecting the arguments uses the value of the SSV before ssa_ssv is XORed in, and the digest protecting the results uses the value of the SSV after the ssa_ssv is XORed in.",
      "ja": "set_ssvの目的がSSVをSSV以外の認証情報からシードすることであるため、クライアントはSSV GSSメカニズムの信用証明書にSET_SSVを送信しないでください。代わりに、SET_SSVは、初めてクライアントIDにアクセスしているユーザーの資格情報を送信する必要があります（セクション2.10.8.3）。ただし、クライアントがSSV認証情報を使用してSET_SSVを送信した場合、引数を保護するダイジェストはSSA_SSVがXODされる前にSSVの値を使用し、結果を保護するダイジェストはSSA_SSVがXODされた後にSSVの値を使用します。"
    },
    {
      "indent": 0,
      "text": "18.48. Operation 55: TEST_STATEID - Test Stateids for Validity",
      "section_title": true,
      "ja": "18.48. 操作55：TEST_STATEID  - 有効性のためのStateIDSTIDS."
    },
    {
      "indent": 0,
      "text": "18.48.1. ARGUMENT",
      "section_title": true,
      "ja": "18.48.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct TEST_STATEID4args {\n        stateid4        ts_stateids<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.48.2. RESULT",
      "section_title": true,
      "ja": "18.48.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct TEST_STATEID4resok {\n        nfsstat4        tsr_status_codes<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union TEST_STATEID4res switch (nfsstat4 tsr_status) {\n    case NFS4_OK:\n        TEST_STATEID4resok tsr_resok4;\n    default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.48.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.48.3. description"
    },
    {
      "indent": 3,
      "text": "The TEST_STATEID operation is used to check the validity of a set of stateids. It can be used at any time, but the client should definitely use it when it receives an indication that one or more of its stateids have been invalidated due to lock revocation. This occurs when the SEQUENCE operation returns with one of the following sr_status_flags set:",
      "ja": "TEST_STATEID操作は、一連のステーションの有効性を確認するために使用されます。それはいつでも使用できますが、クライアントは、ロックの失効のために1つ以上のStateIDが無効になっているという表示を受信したときに間違いなくそれを使用する必要があります。これは、次のSR_STATUS_FLAGSセットのいずれかでシーケンス操作が戻ったときに発生します。"
    },
    {
      "indent": 3,
      "text": "* SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED",
      "ja": "* SEQ4_STATUS_EXPIED_SOME_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "* SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED",
      "ja": "* SEQ4_STATUS_EXPIED_ADMIN_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "* SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED",
      "ja": "* SEQ4_STATUS_EXPIED_RECALLABLE_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "The client can use TEST_STATEID one or more times to test the validity of its stateids. Each use of TEST_STATEID allows a large set of such stateids to be tested and avoids problems with earlier stateids in a COMPOUND request from interfering with the checking of subsequent stateids, as would happen if individual stateids were tested by a series of corresponding by operations in a COMPOUND request.",
      "ja": "クライアントは、StateIDの有効性をテストするために1回以上の回数を使用できます。TEST_STATEIDの各使用は、個々の州の一連の演算によってテストされた場合に、そのような状態のようなステーションのセットをテストすることを可能にし、その後の州のチェックとの干渉からの妨害の妨害の問題を回避することができます。複合要求"
    },
    {
      "indent": 3,
      "text": "For each stateid, the server returns the status code that would be returned if that stateid were to be used in normal operation. Returning such a status indication is not an error and does not cause COMPOUND processing to terminate. Checks for the validity of the stateid proceed as they would for normal operations with a number of exceptions:",
      "ja": "各StateIDについて、StateIDが通常の操作で使用された場合に返されるステータスコードを返します。このようなステータス指示を返すことはエラーではなく、複合処理を終了させません。StateIDの有効性を確認します。"
    },
    {
      "indent": 3,
      "text": "* There is no check for the type of stateid object, as would be the case for normal use of a stateid.",
      "ja": "* StateIDの通常の使用の場合と同様に、StareIDオブジェクトのタイプのチェックはありません。"
    },
    {
      "indent": 3,
      "text": "* There is no reference to the current filehandle.",
      "ja": "* 現在のファイルハンドルへの参照はありません。"
    },
    {
      "indent": 3,
      "text": "* Special stateids are always considered invalid (they result in the error code NFS4ERR_BAD_STATEID).",
      "ja": "* 特別なStateIDは常に無効と見なされます（エラーコードNFS4ERR_BAD_STATEIDが発生します）。"
    },
    {
      "indent": 3,
      "text": "All stateids are interpreted as being associated with the client for the current session. Any possible association with a previous instance of the client (as stale stateids) is not considered.",
      "ja": "すべてのStateIDは、現在のセッションのクライアントに関連付けられていると解釈されます。クライアントの以前のインスタンスとの関連付け（Stale StateID）との関連付けは考慮されません。"
    },
    {
      "indent": 3,
      "text": "The valid status values in the returned status_code array are NFS4ERR_OK, NFS4ERR_BAD_STATEID, NFS4ERR_OLD_STATEID, NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, and NFS4ERR_DELEG_REVOKED.",
      "ja": "返されたSTATUS_CODEアレイの有効なステータス値は、NFS4ERR_OK、NFS4ERR_BAD_STATEID、NFS4ERR_OLD_STATEID、NFS4ERR_EXPIED、NFS4ERR_ADMIN_REVOKED、およびNFS4ERR_DELEG_REVOKEDです。"
    },
    {
      "indent": 0,
      "text": "18.48.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.48.4. 実装"
    },
    {
      "indent": 3,
      "text": "See Sections 8.2.2 and 8.2.4 for a discussion of stateid structure, lifetime, and validation.",
      "ja": "StateID構造、有効期間、および検証については、セクション8.2.2および8.2.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.49. Operation 56: WANT_DELEGATION - Request Delegation",
      "section_title": true,
      "ja": "18.49. オペレーション56：want_delegation  - 委任を要求します"
    },
    {
      "indent": 0,
      "text": "18.49.1. ARGUMENT",
      "section_title": true,
      "ja": "18.49.1. 引数"
    },
    {
      "indent": 3,
      "text": "union deleg_claim4 switch (open_claim_type4 dc_claim) {\n/*\n * No special rights to object.  Ordinary delegation\n * request of the specified object.  Object identified\n * by filehandle.\n */\ncase CLAIM_FH: /* new to v4.1 */\n        /* CURRENT_FH: object being delegated */\n        void;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Right to file based on a delegation granted\n * to a previous boot instance of the client.\n * File is specified by filehandle.\n */\ncase CLAIM_DELEG_PREV_FH: /* new to v4.1 */\n        /* CURRENT_FH: object being delegated */\n        void;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Right to the file established by an open previous\n * to server reboot.  File identified by filehandle.\n * Used during server reclaim grace period.\n */\ncase CLAIM_PREVIOUS:\n        /* CURRENT_FH: object being reclaimed */\n        open_delegation_type4   dc_delegate_type;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct WANT_DELEGATION4args {\n        uint32_t        wda_want;\n        deleg_claim4    wda_claim;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.49.2. RESULT",
      "section_title": true,
      "ja": "18.49.2. 結果"
    },
    {
      "indent": 3,
      "text": "union WANT_DELEGATION4res switch (nfsstat4 wdr_status) {\ncase NFS4_OK:\n        open_delegation4 wdr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.49.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.49.3. description"
    },
    {
      "indent": 3,
      "text": "Where this description mandates the return of a specific error code for a specific condition, and where multiple conditions apply, the server MAY return any of the mandated error codes.",
      "ja": "この説明は、特定の条件の特定のエラーコードの返却を義務付け、複数の条件が適用される場合、サーバーは必須のエラーコードのいずれかを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "This operation allows a client to:",
      "ja": "この操作により、クライアントが次のようにします。"
    },
    {
      "indent": 3,
      "text": "* Get a delegation on all types of files except directories.",
      "ja": "* ディレクトリ以外のすべての種類のファイルで委任を取得します。"
    },
    {
      "indent": 3,
      "text": "* Register a \"want\" for a delegation for the specified file object, and be notified via a callback when the delegation is available. The server MAY support notifications of availability via callbacks. If the server does not support registration of wants, it MUST NOT return an error to indicate that, and instead MUST return with ond_why set to WND4_CONTENTION or WND4_RESOURCE and ond_server_will_push_deleg or ond_server_will_signal_avail set to FALSE. When the server indicates that it will notify the client by means of a callback, it will either provide the delegation using a CB_PUSH_DELEG operation or cancel its promise by sending a CB_WANTS_CANCELLED operation.",
      "ja": "* 指定されたファイルオブジェクトの委任に対して「欲しい」を登録し、委任が利用可能な場合はコールバックを介して通知されます。サーバーは、コールバックを介して可用性の通知をサポートできます。サーバーが希望の登録をサポートしていない場合は、それを示すためにエラーを返さないでください。サーバーがコールバックによってクライアントに通知されることを示している場合は、CB_PUSH_DELEG操作を使用して委任を提供するか、CB_WANTS_CANCELLED操作を送信することによってその有効期限を取り消します。"
    },
    {
      "indent": 3,
      "text": "* Cancel a want for a delegation.",
      "ja": "* 委任のために欲しいものをキャンセルします。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT set OPEN4_SHARE_ACCESS_READ and SHOULD NOT set OPEN4_SHARE_ACCESS_WRITE in wda_want. If it does, the server MUST ignore them.",
      "ja": "クライアントはOpen4_Share_access_Readを設定してはならず、wda_wantでOpen4_Share_access_Writeを設定しないでください。そうであれば、サーバーはそれらを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The meanings of the following flags in wda_want are the same as they are in OPEN, except as noted below.",
      "ja": "WDA_WANTの次のフラグの意味は、以下のとおりですが、オープンになっているのと同じです。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "* open4_share_access_want_read_deleg."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "* open4_share_access_want_write_deleg."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "* open4_share_access_want_any_deleg."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_NO_DELEG. Unlike the OPEN operation, this flag SHOULD NOT be set by the client in the arguments to WANT_DELEGATION, and MUST be ignored by the server.",
      "ja": "* open4_share_access_want_no_deleg。オープン操作とは異なり、このフラグは引数のクライアントからwant_delegationのクライアントによって設定されてはならず、サーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "* open4_share_access_want_cancel."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL",
      "ja": "* open4_share_access_want_signal_deleg_when_resrc_avail."
    },
    {
      "indent": 3,
      "text": "* OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED",
      "ja": "* open4_share_access_want_push_deleg_uncontended"
    },
    {
      "indent": 3,
      "text": "The handling of the above flags in WANT_DELEGATION is the same as in OPEN. Information about the delegation and/or the promises the server is making regarding future callbacks are the same as those described in the open_delegation4 structure.",
      "ja": "want_delegationの上のフラグの処理はOpenと同じです。委任や約束に関する情報サーバーの情報は、将来のコールバックに関してopen_delegation4構造で説明されているものと同じです。"
    },
    {
      "indent": 3,
      "text": "The successful results of WANT_DELEGATION are of data type open_delegation4, which is the same data type as the \"delegation\" field in the results of the OPEN operation (see Section 18.16.3). The server constructs wdr_resok4 the same way it constructs OPEN's \"delegation\" with one difference: WANT_DELEGATION MUST NOT return a delegation type of OPEN_DELEGATE_NONE.",
      "ja": "want_delegationの成功した結果は、オープン操作の結果の「委任」フィールドと同じデータ型であるデータ型Open_Delegation4です（セクション18.16.3を参照）。サーバーは、1つの違いを持つオープンの「委任」を構築するのと同じ方法でWDR_RESOK4を構成します.lant_delegationは、legationタイプのOpen_Delegate_noneを返さないでください。"
    },
    {
      "indent": 3,
      "text": "If ((wda_want & OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) & ~OPEN4_SHARE_ACCESS_WANT_NO_DELEG) is zero, then the client is indicating no explicit desire or non-desire for a delegation and the server MUST return NFS4ERR_INVAL.",
      "ja": "（（wda_want＆open4_share_access_want_deleg_mask）＆〜open4_share_access_want_no_deleg）がゼロである場合、クライアントは明示的な要望や委任が必要でないことを示し、サーバーはNFS4ER_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The client uses the OPEN4_SHARE_ACCESS_WANT_CANCEL flag in the WANT_DELEGATION operation to cancel a previously requested want for a delegation. Note that if the server is in the process of sending the delegation (via CB_PUSH_DELEG) at the time the client sends a cancellation of the want, the delegation might still be pushed to the client.",
      "ja": "クライアントは、want_delegation操作のOpen4_Share_access_Want_Cancelフラグを使用して、委任のための以前に要求された欲求をキャンセルします。クライアントが希望のキャンセルを送信するときに委任を（CB_PUSH_DELEGを介して）委任を送信するプロセスにある場合、委任はまだクライアントにプッシュされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If WANT_DELEGATION fails to return a delegation, and the server returns NFS4_OK, the server MUST set the delegation type to OPEN4_DELEGATE_NONE_EXT, and set od_whynone, as described in Section 18.16. Write delegations are not available for file types that are not writable. This includes file objects of types NF4BLK, NF4CHR, NF4LNK, NF4SOCK, and NF4FIFO. If the client requests OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG without OPEN4_SHARE_ACCESS_WANT_READ_DELEG on an object with one of the aforementioned file types, the server must set wdr_resok4.od_whynone.ond_why to WND4_WRITE_DELEG_NOT_SUPP_FTYPE.",
      "ja": "want_delegationが委任を返し、サーバーがNFS4_OKを返す場合、サーバーは委任タイプをOpen4_Delegate_none_extに設定し、セクション18.16で説明されているようにOD_WHYNONEを設定する必要があります。書き込み代行は、書き込み可能ではないファイルの種類には使用できません。これには、NF4BLK、NF4CHR、NF4LNK、NF4SOCK、およびNF4FIFO型のファイルオブジェクトが含まれます。クライアントが、前述のファイルタイプの1つを持つオブジェクトのOpen4_Share_access_Want_Read_DelegをOpen4_share_access_want_read_delegを要求した場合、サーバーはWDR_RESOK4.OD_WHYNONE.OND_SUPP_FTYPEにwdr_resok4.od_whynone.ond_supp_ftypeを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.49.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.49.4. 実装"
    },
    {
      "indent": 3,
      "text": "A request for a conflicting delegation is not normally intended to trigger the recall of the existing delegation. Servers may choose to treat some clients as having higher priority such that their wants will trigger recall of an existing delegation, although that is expected to be an unusual situation.",
      "ja": "矛盾する委任の要求は、通常、既存の委任のリコールを引き起こすことを目的としていません。サーバーは、希望の委任が既存の委任のリコールを引き起こすように、より高い優先順位を持つようなクライアントを扱うことを選択できます。"
    },
    {
      "indent": 3,
      "text": "Servers will generally recall delegations assigned by WANT_DELEGATION on the same basis as those assigned by OPEN. CB_RECALL will generally be done only when other clients perform operations inconsistent with the delegation. The normal response to aging of delegations is to use CB_RECALL_ANY, in order to give the client the opportunity to keep the delegations most useful from its point of view.",
      "ja": "サーバーは一般に、Openによって割り当てられたものと同じ基準でwant_delegationによって割り当てられた代表を呼び出します。CB_Recallは通常、他のクライアントが委任と矛盾しない操作を実行する場合にのみ実行されます。代理人の高齢化に対する通常の対応は、顧客に視聴点から最も有用な代理人を維持する機会を与えるために、CB_RECALL_ANYを使用することです。"
    },
    {
      "indent": 0,
      "text": "18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID",
      "section_title": true,
      "ja": "18.50. 操作57：Destroy_ClientID  - クライアントIDを破棄します"
    },
    {
      "indent": 0,
      "text": "18.50.1. ARGUMENT",
      "section_title": true,
      "ja": "18.50.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_CLIENTID4args {\n        clientid4       dca_clientid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.50.2. RESULT",
      "section_title": true,
      "ja": "18.50.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_CLIENTID4res {\n        nfsstat4        dcr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.50.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.50.3. description"
    },
    {
      "indent": 3,
      "text": "The DESTROY_CLIENTID operation destroys the client ID. If there are sessions (both idle and non-idle), opens, locks, delegations, layouts, and/or wants (Section 18.49) associated with the unexpired lease of the client ID, the server MUST return NFS4ERR_CLIENTID_BUSY. DESTROY_CLIENTID MAY be preceded with a SEQUENCE operation as long as the client ID derived from the session ID of SEQUENCE is not the same as the client ID to be destroyed. If the client IDs are the same, then the server MUST return NFS4ERR_CLIENTID_BUSY.",
      "ja": "destroy_clientid操作はクライアントIDを破棄します。セッション（アイドルと非アイドルとの両方）がある場合は、期限切れのクライアントIDの期限切れのリースに関連付けられている（セクション18.49）、サーバーはNFS4ERR_CLIENTID_BUSYを返す必要があります。SequenceのセッションIDから派生したクライアントIDが破棄されるクライアントIDと同じではない限り、SCREEST_CLIENTIDの前にある場合があります。クライアントIDが同じである場合、サーバーはNFS4ERR_CLIENTID_BUSYを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If DESTROY_CLIENTID is not prefixed by SEQUENCE, it MUST be the only operation in the COMPOUND request (otherwise, the server MUST return NFS4ERR_NOT_ONLY_OP). If the operation is sent without a SEQUENCE preceding it, a client that retransmits the request may receive an error in response, because the original request might have been successfully executed.",
      "ja": "destroy_clientIDがシーケンスによって接頭辞されていない場合は、複合要求で唯一の操作でなければなりません（そうでない場合は、サーバーはNFS4ER_NOT_ONLY_OPを返す必要があります）。前のシーケンスなしで操作が送信された場合、元の要求が正常に実行された可能性があるため、要求を再送信するクライアントは応答にエラーを受け取ることがあります。"
    },
    {
      "indent": 0,
      "text": "18.50.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.50.4. 実装"
    },
    {
      "indent": 3,
      "text": "DESTROY_CLIENTID allows a server to immediately reclaim the resources consumed by an unused client ID, and also to forget that it ever generated the client ID. By forgetting that it ever generated the client ID, the server can safely reuse the client ID on a future EXCHANGE_ID operation.",
      "ja": "Destroy_ClientIdを使用すると、サーバーは未使用のクライアントIDによって消費されるリソースをすぐに再利用でき、またクライアントIDを生成したことを忘れます。それがクライアントIDを生成したことを忘れて、サーバーは将来のExchange_ID操作でクライアントIDを安全に再利用できます。"
    },
    {
      "indent": 0,
      "text": "18.51. Operation 58: RECLAIM_COMPLETE - Indicates Reclaims Finished",
      "section_title": true,
      "ja": "18.51. 動作58：RECLAIM_COMPLETE  -  rellaimsが終了していることを示します"
    },
    {
      "indent": 0,
      "text": "18.51.1. ARGUMENT",
      "section_title": true,
      "ja": "18.51.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct RECLAIM_COMPLETE4args {\n        /*\n         * If rca_one_fs TRUE,\n         *\n         *    CURRENT_FH: object in\n         *    file system reclaim is\n         *    complete for.\n         */\n        bool            rca_one_fs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.51.2. RESULTS",
      "section_title": true,
      "ja": "18.51.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RECLAIM_COMPLETE4res {\n        nfsstat4        rcr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.51.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.51.3. description"
    },
    {
      "indent": 3,
      "text": "A RECLAIM_COMPLETE operation is used to indicate that the client has reclaimed all of the locking state that it will recover using reclaim, when it is recovering state due to either a server restart or the migration of a file system to another server. There are two types of RECLAIM_COMPLETE operations:",
      "ja": "RECLAIM_COMPLETE操作は、サーバーの再起動またはファイルシステムの移行があるために、クライアントが再利用を使用して回復しているすべてのロック状態を再生したことを示すために使用されます。RECLAIM_COMPLETE操作には2種類あります。"
    },
    {
      "indent": 3,
      "text": "* When rca_one_fs is FALSE, a global RECLAIM_COMPLETE is being done. This indicates that recovery of all locks that the client held on the previous server instance has been completed. The current filehandle need not be set in this case.",
      "ja": "* RCA_ONE_FSがfalseの場合、グローバルreclaim_completeが行われています。これは、前のサーバーインスタンスに保持されているクライアントが完了したすべてのロックの回復が完了したことを示しています。この場合、現在のファイルハンドルを設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "* When rca_one_fs is TRUE, a file system-specific RECLAIM_COMPLETE is being done. This indicates that recovery of locks for a single fs (the one designated by the current filehandle) due to the migration of the file system has been completed. Presence of a current filehandle is required when rca_one_fs is set to TRUE. When the current filehandle designates a filehandle in a file system not in the process of migration, the operation returns NFS4_OK and is otherwise ignored.",
      "ja": "* RCA_ONE_FSがTRUEの場合、ファイルシステム固有のRECLAIM_COMPLETEが行われています。これは、ファイルシステムの移行により単一のFS（現在のファイルハンドルで指定されたもの）のロックの回復が完了したことを示しています。RCA_ONE_FSがTRUEに設定されている場合、現在のファイルハンドルの存在が必要です。現在のファイルハンドルが移行のプロセスではなくファイルシステムでファイルハンドルを指定すると、操作はNFS4_OKを返し、そうでなければ無視されます。"
    },
    {
      "indent": 3,
      "text": "Once a RECLAIM_COMPLETE is done, there can be no further reclaim operations for locks whose scope is defined as having completed recovery. Once the client sends RECLAIM_COMPLETE, the server will not allow the client to do subsequent reclaims of locking state for that scope and, if these are attempted, will return NFS4ERR_NO_GRACE.",
      "ja": "reclaim_completeが完了すると、スコープがリカバリが完了したと定義されているロックに対してそれ以上の再利用操作はありません。クライアントがreclaim_completeを送信すると、サーバーはそのスコープに対してその後のロック状態の後続のロック状態の再利用を行うことはできません。"
    },
    {
      "indent": 3,
      "text": "Whenever a client establishes a new client ID and before it does the first non-reclaim operation that obtains a lock, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to FALSE, even if there are no locks to reclaim. If non-reclaim locking operations are done before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.",
      "ja": "クライアントが新しいクライアントIDを確立し、ロックを取得する最初の非RECLAIM操作を実行する前に、Reclaimにロックがない場合でも、RCA_ONE_FSをfalseに設定してRECLAIM_COMPLETEを送信する必要があります。RECLAIM_COMPLETEの前にRECLAIMロック操作が行われている場合は、NFS4ERR_GRACEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Similarly, when the client accesses a migrated file system on a new server, before it sends the first non-reclaim operation that obtains a lock on this new server, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to TRUE and current filehandle within that file system, even if there are no locks to reclaim. If non-reclaim locking operations are done on that file system before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.",
      "ja": "同様に、クライアントが新しいサーバー上の移行されたファイルシステムにアクセスすると、この新しいサーバー上のロックを取得する最初の非再利用操作を送信する前に、RCA_ONE_FSがTRUEに設定されているRECLAIM_COMPLETEをそのファイルシステム内で送信する必要があります。、再利用するためのロックがない場合でも。RECLAIM_COMPLETEの前にそのファイルシステムに対して再埋め込まれないロック操作が行われた場合、NFS4ERR_GRACEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "It should be noted that there are situations in which a client needs to issue both forms of RECLAIM_COMPLETE. An example is an instance of file system migration in which the file system is migrated to a server for which the client has no clientid. As a result, the client needs to obtain a clientid from the server (incurring the responsibility to do RECLAIM_COMPLETE with rca_one_fs set to FALSE) as well as RECLAIM_COMPLETE with rca_one_fs set to TRUE to complete the per-fs grace period associated with the file system migration. These two may be done in any order as long as all necessary lock reclaims have been done before issuing either of them.",
      "ja": "クライアントがReclaim_Completeの両方の形式を発行する必要がある状況があることに注意してください。例は、ファイルシステムがクライアントにClientIDがないサーバーに移行されるファイルシステムの移行のインスタンスです。その結果、クライアントはサーバーからClientIDを入手する必要があります（RCA_ONE_FSをfalseに設定されているRECLAIM_COMPLETEを実行する責任を発生させる）、およびファイルシステムの移行に関連したFS Per-FS猶予期間を完了するためにRCA_ONE_FSがTRUEに設定されているRECLAIM_COMPLETE。これら2つは、どちらかの必要なロック再利用が行われている限り、任意の順序で行うことができます。"
    },
    {
      "indent": 3,
      "text": "Any locks not reclaimed at the point at which RECLAIM_COMPLETE is done become non-reclaimable. The client MUST NOT attempt to reclaim them, either during the current server instance or in any subsequent server instance, or on another server to which responsibility for that file system is transferred. If the client were to do so, it would be violating the protocol by representing itself as owning locks that it does not own, and so has no right to reclaim. See Section 8.4.3 of [66] for a discussion of edge conditions related to lock reclaim.",
      "ja": "RECLAIM_COMPLETEが行われている時点では再生されないロックは、再生不可能です。クライアントは、現在のサーバーインスタンス中、またはその後のサーバーインスタンスの間、またはそのファイルシステムに対する責任が転送される別のサーバー上で、それらを再利用しようとしてはなりません。クライアントがそうすることになっている場合は、自分自身が所有していない所有ロックとして表現することでプロトコルに違反しているため、再利用する権利はありません。ロック再利用に関するエッジ条件については、[66]の8.4.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "By sending a RECLAIM_COMPLETE, the client indicates readiness to proceed to do normal non-reclaim locking operations. The client should be aware that such operations may temporarily result in NFS4ERR_GRACE errors until the server is ready to terminate its grace period.",
      "ja": "RECLAIM_COMPLETEを送信することによって、クライアントは通常の非再生ロック操作を実行する準備を示す。クライアントは、サーバーがその猶予期間を終了する準備ができているまで、このような操作がNFS4ERR_GRACEエラーになる可能性があることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.51.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.51.4. 実装"
    },
    {
      "indent": 3,
      "text": "Servers will typically use the information as to when reclaim activity is complete to reduce the length of the grace period. When the server maintains in persistent storage a list of clients that might have had locks, it is able to use the fact that all such clients have done a RECLAIM_COMPLETE to terminate the grace period and begin normal operations (i.e., grant requests for new locks) sooner than it might otherwise.",
      "ja": "猶予期間の長さを短くするために、サーバーは通常、再生アクティビティが完了したときに情報を使用します。サーバーが永続ストレージで維持されている場合、ロックがあった可能性のあるクライアントのリストを使用すると、そのようなクライアントがすべてのクライアントが猶予期間を終了し、通常の操作を開始する（新しいロックの許可）という事実を使用することができます。そうでなければ早くなるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Latency can be minimized by doing a RECLAIM_COMPLETE as part of the COMPOUND request in which the last lock-reclaiming operation is done. When there are no reclaims to be done, RECLAIM_COMPLETE should be done immediately in order to allow the grace period to end as soon as possible.",
      "ja": "最後のロック再生操作が行われる複合要求の一部としてRECLAIM_COMPLETEを実行することで、レイテンシを最小限に抑えることができます。再利用するための再利用がない場合、Reclaim_Completeは猶予期間ができるだけ早く終了することを可能にするためにすぐに行われるべきです。"
    },
    {
      "indent": 3,
      "text": "RECLAIM_COMPLETE should only be done once for each server instance or occasion of the transition of a file system. If it is done a second time, the error NFS4ERR_COMPLETE_ALREADY will result. Note that because of the session feature's retry protection, retries of COMPOUND requests containing RECLAIM_COMPLETE operation will not result in this error.",
      "ja": "reclaim_completeは、サーバーインスタンスごとに1回だけファイルシステムの遷移の場合にのみ実行する必要があります。もう一度行われた場合、エラーNFS4ERR_COMPLETE_ALREADYが生じる。セッション機能のリトライ保護のために、RECLAIM_COMPLETE操作を含む複合要求の再試行はこのエラーにはなりません。"
    },
    {
      "indent": 3,
      "text": "When a RECLAIM_COMPLETE is sent, the client effectively acknowledges any locks not yet reclaimed as lost. This allows the server to re-enable the client to recover locks if the occurrence of edge conditions, as described in Section 8.4.3, had caused the server to disable the client's ability to recover locks.",
      "ja": "RECLAIM_COMPLETEが送信されると、クライアントはまだ失われていないロックを効果的に確認します。これにより、セクション8.4.3で説明されているように、エッジ条件の発生がサーバーがロックを回復する機能を無効にした場合、サーバーはクライアントがロックを回復することができます。"
    },
    {
      "indent": 3,
      "text": "Because previous descriptions of RECLAIM_COMPLETE were not sufficiently explicit about the circumstances in which use of RECLAIM_COMPLETE with rca_one_fs set to TRUE was appropriate, there have been cases in which it has been misused by clients who have issued RECLAIM_COMPLETE with rca_one_fs set to TRUE when it should have not been. There have also been cases in which servers have, in various ways, not responded to such misuse as described above, either ignoring the rca_one_fs setting (treating the operation as a global RECLAIM_COMPLETE) or ignoring the entire operation.",
      "ja": "Reclaim_Completeの以前の説明は、RCA_ONE_FSをTRUEに設定したRECLAIM_COMPLETEの使用が適切である状況について十分に明示的ではなかったため、RCA_ONE_FSを使用したRECLAIM_COMPLETEを発行したクライアントによって誤用されている場合がありました。されていません。また、様々な方法で、RCA_ONE_FS設定（動作をグローバルRECLAIM_COMPLETEとして扱う）または全体の動作を無視しても、サーバがそのような誤用に応答しない場合もありました。"
    },
    {
      "indent": 3,
      "text": "While clients SHOULD NOT misuse this feature, and servers SHOULD respond to such misuse as described above, implementors need to be aware of the following considerations as they make necessary trade-offs between interoperability with existing implementations and proper support for facilities to allow lock recovery in the event of file system migration.",
      "ja": "クライアントはこの機能を誤用しないでください。上記のようにサーバーはそのような誤用に応答する必要がありますが、既存の実装との相互運用性と施設のロック回復を可能にするための施設の適切なサポートとの間で必要なトレードオフを実現する必要があります。ファイルシステムの移行のイベント。"
    },
    {
      "indent": 3,
      "text": "* When servers have no support for becoming the destination server of a file system subject to migration, there is no possibility of a per-fs RECLAIM_COMPLETE being done legitimately, and occurrences of it SHOULD be ignored. However, the negative consequences of accepting such mistaken use are quite limited as long as the client does not issue it before all necessary reclaims are done.",
      "ja": "* 移行の対象となるファイルシステムの宛先サーバーになるためのサポートがない場合は、FS reclaim_completeが正当に行われ、それの発生は無視される可能性がありません。しかしながら、そのような間違いを受け入れることの否定的な結果は、必要なすべての再利用が行われる前にクライアントがそれを発行しない限り、かなり制限されている。"
    },
    {
      "indent": 3,
      "text": "* When a server might become the destination for a file system being migrated, inappropriate use of per-fs RECLAIM_COMPLETE is more concerning. In the case in which the file system designated is not within a per-fs grace period, the per-fs RECLAIM_COMPLETE SHOULD be ignored, with the negative consequences of accepting it being limited, as in the case in which migration is not supported. However, if the server encounters a file system undergoing migration, the operation cannot be accepted as if it were a global RECLAIM_COMPLETE without invalidating its intended use.",
      "ja": "* サーバーが移行されているファイルシステムの宛先になる可能性がある場合は、FSごとのreclaim_completeの不適切な使用がより多くです。指定されたファイルシステムがFS猶予期間内にない場合、移行がサポートされていない場合と同様に、FSごとのRECLAIM_COMPLETEは無視されるべきである。ただし、サーバーがマイグレーションを受けているファイルシステムに遭遇した場合、その操作は、意図された使用を無効にすることなく、グローバルRECLAIM_COMPLETEであるかのように承認できません。"
    },
    {
      "indent": 0,
      "text": "18.52. Operation 10044: ILLEGAL - Illegal Operation",
      "section_title": true,
      "ja": "18.52. 操作10044：違法 - 違法業務"
    },
    {
      "indent": 0,
      "text": "18.52.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.52.1. 議論"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.52.2. RESULTS",
      "section_title": true,
      "ja": "18.52.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ILLEGAL4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.52.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.52.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.",
      "ja": "この操作は、サポートされていないコンパウンド内の操作コードを送信するクライアントのケースを処理するための結果を符号化するためのプレースホルダである。詳細については、複合手順説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.",
      "ja": "ILLEGLAL4RESのステータスフィールドは、NFS4ERR_OP_ILLEGALに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.52.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.52.4. 実装"
    },
    {
      "indent": 3,
      "text": "A client will probably not send an operation with code OP_ILLEGAL but if it does, the response will be ILLEGAL4res just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.",
      "ja": "クライアントはおそらくコードop_illegalで操作を送信しないでしょうが、そうであれば、それが他の無効な操作コードと同じように、応答はIllegal4resになります。サーバーがopilegalalではない不正なオペレーションコードを取得し、XDRデコードフェーズ中にサーバーが法的操作コードをチェックした場合、ILLEGAL4RESは返されません。"
    },
    {
      "indent": 0,
      "text": "19. NFSv4.1 Callback Procedures",
      "section_title": true,
      "ja": "19. NFSV4.1コールバック手順"
    },
    {
      "indent": 3,
      "text": "The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms \"client\" and \"server\" refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.",
      "ja": "コールバックに使用される手順は、次のセクションで定義されています。明確にするために、「クライアント」および「サーバ」という用語は、個々のコールバックRPCのために、これらの用語の意味が正確に反対であるという事実にもかかわらず、NFSクライアントおよびサーバを指す。"
    },
    {
      "indent": 3,
      "text": "Both procedures, CB_NULL and CB_COMPOUND, MUST be implemented.",
      "ja": "手順、CB_NULL、CB_COMPOUNDの両方を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "19.1. Procedure 0: CB_NULL - No Operation",
      "section_title": true,
      "ja": "19.1. 手順0：cb_null  -  operationいいえ"
    },
    {
      "indent": 0,
      "text": "19.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "19.1.1. 議論"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "19.1.2. RESULTS",
      "section_title": true,
      "ja": "19.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "19.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "19.1.3. description"
    },
    {
      "indent": 3,
      "text": "CB_NULL is the standard ONC RPC NULL procedure, with the standard void argument and void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from the server to client.",
      "ja": "CB_NULLは標準のvoid引数とvoid応答を持つ標準のONC RPC NULLプロシージャです。この手順に関連付けられている直接機能がない場合でも、サーバーはCB_NULLを使用して、サーバーからクライアントへのRPCのパスの存在を確認します。"
    },
    {
      "indent": 0,
      "text": "19.1.4. ERRORS",
      "section_title": true,
      "ja": "19.1.4. 誤差"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 0,
      "text": "19.2. Procedure 1: CB_COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "19.2. 手順1：CB_COMPOUND  - 複合演算"
    },
    {
      "indent": 0,
      "text": "19.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "19.2.1. 議論"
    },
    {
      "indent": 3,
      "text": "enum nfs_cb_opnum4 {\n        OP_CB_GETATTR           = 3,\n        OP_CB_RECALL            = 4,\n/* Callback operations new to NFSv4.1 */\n        OP_CB_LAYOUTRECALL      = 5,\n        OP_CB_NOTIFY            = 6,\n        OP_CB_PUSH_DELEG        = 7,\n        OP_CB_RECALL_ANY        = 8,\n        OP_CB_RECALLABLE_OBJ_AVAIL = 9,\n        OP_CB_RECALL_SLOT       = 10,\n        OP_CB_SEQUENCE          = 11,\n        OP_CB_WANTS_CANCELLED   = 12,\n        OP_CB_NOTIFY_LOCK       = 13,\n        OP_CB_NOTIFY_DEVICEID   = 14,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " OP_CB_ILLEGAL = 10044 };",
      "ja": "op_cb_illegal = 10044}。"
    },
    {
      "indent": 3,
      "text": "union nfs_cb_argop4 switch (unsigned argop) {\n case OP_CB_GETATTR:\n      CB_GETATTR4args           opcbgetattr;\n case OP_CB_RECALL:\n      CB_RECALL4args            opcbrecall;\n case OP_CB_LAYOUTRECALL:\n      CB_LAYOUTRECALL4args      opcblayoutrecall;\n case OP_CB_NOTIFY:\n      CB_NOTIFY4args            opcbnotify;\n case OP_CB_PUSH_DELEG:\n      CB_PUSH_DELEG4args        opcbpush_deleg;\n case OP_CB_RECALL_ANY:\n      CB_RECALL_ANY4args        opcbrecall_any;\n case OP_CB_RECALLABLE_OBJ_AVAIL:\n      CB_RECALLABLE_OBJ_AVAIL4args opcbrecallable_obj_avail;\n case OP_CB_RECALL_SLOT:\n      CB_RECALL_SLOT4args       opcbrecall_slot;\n case OP_CB_SEQUENCE:\n      CB_SEQUENCE4args          opcbsequence;\n case OP_CB_WANTS_CANCELLED:\n      CB_WANTS_CANCELLED4args   opcbwants_cancelled;\n case OP_CB_NOTIFY_LOCK:\n      CB_NOTIFY_LOCK4args       opcbnotify_lock;\n case OP_CB_NOTIFY_DEVICEID:\n      CB_NOTIFY_DEVICEID4args   opcbnotify_deviceid;\n case OP_CB_ILLEGAL:            void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4args {\n        utf8str_cs      tag;\n        uint32_t        minorversion;\n        uint32_t        callback_ident;\n        nfs_cb_argop4   argarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19.2.2. RESULTS",
      "section_title": true,
      "ja": "19.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union nfs_cb_resop4 switch (unsigned resop) {\n case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* new NFSv4.1 operations */\ncase OP_CB_LAYOUTRECALL:\n                       CB_LAYOUTRECALL4res\n                                       opcblayoutrecall;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY: CB_NOTIFY4res opcbnotify;",
      "ja": "ケースOP_CB_NOTIFY：CB_NOTIFY4RES OPCBNOTIFY;"
    },
    {
      "indent": 4,
      "text": "case OP_CB_PUSH_DELEG: CB_PUSH_DELEG4res opcbpush_deleg;",
      "ja": "ケースOP_CB_PUSH_DELEG：CB_PUSH_DELEG4RES OPCBPUSH_DELEG。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALL_ANY: CB_RECALL_ANY4res opcbrecall_any;",
      "ja": "ケースop_cb_recall_any：cb_recall_any4res opcbrecall_any;"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALLABLE_OBJ_AVAIL: CB_RECALLABLE_OBJ_AVAIL4res opcbrecallable_obj_avail;",
      "ja": "ケースop_cb_recallable_obj_avail：cb_recallable_obj_avail4res opcbrecallable_obj_avail;"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALL_SLOT: CB_RECALL_SLOT4res opcbrecall_slot;",
      "ja": "ケースOP_CB_RECALL_SLOT：CB_RECALL_SLOT4RES OPCBRECALL_SLOT;"
    },
    {
      "indent": 4,
      "text": "case OP_CB_SEQUENCE: CB_SEQUENCE4res opcbsequence;",
      "ja": "ケースOP_CB_SEQUENCE：CB_SEQUENCE4RES OPCBSEQUENCE。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_WANTS_CANCELLED: CB_WANTS_CANCELLED4res opcbwants_cancelled;",
      "ja": "ケースOP_CB_WANTES_CANCELLED：CB_WANTS_CANCELLED4RES OPCBWANTS_CANCELLED。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY_LOCK: CB_NOTIFY_LOCK4res opcbnotify_lock;",
      "ja": "ケースop_cb_notify_lock：cb_notify_lock4res opcbnotify_lock;"
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY_DEVICEID: CB_NOTIFY_DEVICEID4res opcbnotify_deviceid;",
      "ja": "ケースOP_CB_NOTIFY_DEVICEID：CB_NOTIFY_DEVICEID4RES OPCBNOTIFY_DEVICEID。"
    },
    {
      "indent": 3,
      "text": " /* Not new operation */\n case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4res {\n        nfsstat4 status;\n        utf8str_cs      tag;\n        nfs_cb_resop4   resarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "19.2.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.",
      "ja": "CB_COMPOUND手順は、1つ以上のコールバック手順を単一のRPC要求に組み合わせるために使用されます。メインコールバックRPCプログラムには、CB_NULLとCB_COMPOUND 2つのメインプロシージャがあります。他のすべての操作は、CB_Compoundプロシージャをラッパーとして使用します。"
    },
    {
      "indent": 3,
      "text": "During the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. Refer to Section 2.10.6.4 for details.",
      "ja": "CB_COMPOUNDプロシージャの処理中に、クライアントは、CB_COMPOUNDシーケンス内の操作の任意のまたはすべてを実行するための使用可能なリソースがないことを確認できます。詳細は2.10.6.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The minorversion field of the arguments MUST be the same as the minorversion of the COMPOUND procedure used to create the client ID and session. For NFSv4.1, minorversion MUST be set to 1.",
      "ja": "引数のminorVersionフィールドは、クライアントIDとセッションを作成するために使用される複合プロシージャのマイナーバージョンと同じでなければなりません。NFSV4.1の場合、MinorVersionは1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Contained within the CB_COMPOUND results is a \"status\" field. This status MUST be equal to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error, then the \"status\" value will be the same error value as is being returned for the operation that failed.",
      "ja": "CB_COMPOUND結果に含まれているのは、「ステータス」フィールドです。このステータスは、cb_compoundプロシージャ内で実行された最後の操作のステータスに等しくなければなりません。したがって、操作がエラーに発生した場合、 \"Status\"値は失敗した操作の場合と同じエラー値になります。"
    },
    {
      "indent": 3,
      "text": "The \"tag\" field is handled the same way as that of the COMPOUND procedure (see Section 16.2.3).",
      "ja": "「タグ」フィールドは、複合手順と同じ方法で処理されます（16.2.3項を参照）。"
    },
    {
      "indent": 3,
      "text": "Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.",
      "ja": "違法な操作コードは、複合手順の処理と同じ方法で処理されます。"
    },
    {
      "indent": 0,
      "text": "19.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "19.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.",
      "ja": "CB_COMPOUND手順は、個々の操作を単一のRPC要求に組み合わせるために使用されます。クライアントは各操作を順番に解釈します。クライアントによって操作が実行され、その操作のステータスがNFS4_OKの場合、CB_COMPOUND手順で次の操作が実行されます。実行される操作がもうなく、または操作の1つがNFS4_OK以外のステータス値を持つまで、クライアントはこのプロセスを続行します。"
    },
    {
      "indent": 0,
      "text": "19.2.5. ERRORS",
      "section_title": true,
      "ja": "19.2.5. 誤差"
    },
    {
      "indent": 3,
      "text": "CB_COMPOUND will of course return every error that each operation on the backchannel can return (see Table 13). However, if CB_COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors CB_COMPOUND will return if it processes zero operations includes:",
      "ja": "CB_Compoundはもちろん、バックチャネル上の各操作が戻ることができるすべてのエラーを返します（表13を参照）。ただし、cb_compoundがゼロ動作を返す場合、明らかに複合によって返されたエラーは、操作によって返されたエラーとは関係ありません。Errors CB_COMPOUNDのリストは、それがゼロ操作に含まれる場合に戻ります。"
    },
    {
      "indent": 4,
      "text": "+==============================+==================================+\n| Error                        | Notes                            |\n+==============================+==================================+\n| NFS4ERR_BADCHAR              | The tag argument has a character |\n|                              | the replier does not support.    |\n+------------------------------+----------------------------------+\n| NFS4ERR_BADXDR               |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_DELAY                |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_INVAL                | The tag argument is not in UTF-8 |\n|                              | encoding.                        |\n+------------------------------+----------------------------------+\n| NFS4ERR_MINOR_VERS_MISMATCH  |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_SERVERFAULT          |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_TOO_MANY_OPS         |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REP_TOO_BIG          |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REP_TOO_BIG_TO_CACHE |                                  |\n+------------------------------+----------------------------------+\n| NFS4ERR_REQ_TOO_BIG          |                                  |\n+------------------------------+----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 24: CB_COMPOUND Error Returns",
      "ja": "表24：CB_COMPOUNDエラー返品"
    },
    {
      "indent": 0,
      "text": "20. NFSv4.1 Callback Operations",
      "section_title": true,
      "ja": "20. NFSV4.1コールバック操作"
    },
    {
      "indent": 0,
      "text": "20.1. Operation 3: CB_GETATTR - Get Attributes",
      "section_title": true,
      "ja": "20.1. 操作3：CB_GetAttr  - 属性を取得します"
    },
    {
      "indent": 0,
      "text": "20.1.1. ARGUMENT",
      "section_title": true,
      "ja": "20.1.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_GETATTR4args {\n        nfs_fh4 fh;\n        bitmap4 attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.1.2. RESULT",
      "section_title": true,
      "ja": "20.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_GETATTR4resok {\n        fattr4  obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union CB_GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CB_GETATTR4resok       resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.1.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been OPEN_DELEGATE_WRITE delegated. The size and change attributes are the only ones guaranteed to be serviced by the client. See Section 10.4.3 for a full description of how the client and server are to interact with the use of CB_GETATTR.",
      "ja": "CB_GETATTRの動作は、省略されたファイルの現在の変更された状態を取得するためにサーバーによって使用されます。サイズと変更属性は、クライアントによってサービスを受けることが保証される唯一のものです。クライアントとサーバーがCB_GetAttrの使用と対話する方法の詳細については、10.4.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the filehandle specified is not one for which the client holds an OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたファイルハンドルがOpen_Delegate_Writeの委任を保持するものではない場合は、NFS4ERR_BADハンドルエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "20.1.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.1.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify, and size).",
      "ja": "クライアントはATTRMASKビットと変更属性のみが変更される可能性がある属性（time_modify、およびsize）の属性を返します。"
    },
    {
      "indent": 0,
      "text": "20.2. Operation 4: CB_RECALL - Recall a Delegation",
      "section_title": true,
      "ja": "20.2. 操作4：CB_RECALL  - 代表団を思い出してください"
    },
    {
      "indent": 0,
      "text": "20.2.1. ARGUMENT",
      "section_title": true,
      "ja": "20.2.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL4args {\n        stateid4        stateid;\n        bool            truncate;\n        nfs_fh4         fh;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.2.2. RESULT",
      "section_title": true,
      "ja": "20.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.2.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_RECALL operation is used to begin the process of recalling a delegation and returning it to the server.",
      "ja": "CB_Recall操作は、委任を呼び出してサーバーに返すプロセスを開始するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The truncate flag is used to optimize recall for a file object that is a regular file and is about to be truncated to zero. When it is TRUE, the client is freed of the obligation to propagate modified data for the file to the server, since this data is irrelevant.",
      "ja": "TRUNCATEフラグは、通常のファイルであるファイルオブジェクトの呼び出しを最適化し、ゼロに切り捨てられようとしています。それが真のとき、このデータは無関係であるため、クライアントはファイルの修正されたデータをサーバーに伝播する義務を解放します。"
    },
    {
      "indent": 3,
      "text": "If the handle specified is not one for which the client holds a delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたハンドルがクライアントが委任を保持するものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the stateid specified is not one corresponding to an OPEN delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.",
      "ja": "指定されたstateIDがFileHandleで指定されたファイルのオープン委任に対応していない場合は、NFS4ERR_BAD_STATEIDが返されます。"
    },
    {
      "indent": 0,
      "text": "20.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client SHOULD reply to the callback immediately. Replying does not complete the recall except when the value of the reply's status field is neither NFS4ERR_DELAY nor NFS4_OK. The recall is not complete until the delegation is returned using a DELEGRETURN operation.",
      "ja": "クライアントはすぐにコールバックに返信する必要があります。返信は、返信の[ステータス]フィールドの値がNFS4ERR_DELAYもNFS4_OKでもない場合を除き、リコールを完了しません。委任がDELEGRETURN操作を使用して返されるまで、リコールは完了しません。"
    },
    {
      "indent": 0,
      "text": "20.3. Operation 5: CB_LAYOUTRECALL - Recall Layout from Client",
      "section_title": true,
      "ja": "20.3. 操作5：CB_LAYOUTRECALL  - クライアントからのレイアウトを思い出します"
    },
    {
      "indent": 0,
      "text": "20.3.1. ARGUMENT",
      "section_title": true,
      "ja": "20.3.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * NFSv4.1 callback arguments and results\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum layoutrecall_type4 {\n        LAYOUTRECALL4_FILE = LAYOUT4_RET_REC_FILE,\n        LAYOUTRECALL4_FSID = LAYOUT4_RET_REC_FSID,\n        LAYOUTRECALL4_ALL  = LAYOUT4_RET_REC_ALL\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct layoutrecall_file4 {\n        nfs_fh4         lor_fh;\n        offset4         lor_offset;\n        length4         lor_length;\n        stateid4        lor_stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union layoutrecall4 switch(layoutrecall_type4 lor_recalltype) {\ncase LAYOUTRECALL4_FILE:\n        layoutrecall_file4 lor_layout;\ncase LAYOUTRECALL4_FSID:\n        fsid4              lor_fsid;\ncase LAYOUTRECALL4_ALL:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_LAYOUTRECALL4args {\n        layouttype4             clora_type;\n        layoutiomode4           clora_iomode;\n        bool                    clora_changed;\n        layoutrecall4           clora_recall;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3.2. RESULT",
      "section_title": true,
      "ja": "20.3.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_LAYOUTRECALL4res {\n        nfsstat4        clorr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.3.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_LAYOUTRECALL operation is used by the server to recall layouts from the client; as a result, the client will begin the process of returning layouts via LAYOUTRETURN. The CB_LAYOUTRECALL operation specifies one of three forms of recall processing with the value of layoutrecall_type4. The recall is for one of the following: a specific layout of a specific file (LAYOUTRECALL4_FILE), an entire file system ID (LAYOUTRECALL4_FSID), or all file systems (LAYOUTRECALL4_ALL).",
      "ja": "CB_LAYOUTRECALL操作は、クライアントからレイアウトをリコールするためにサーバーによって使用されます。その結果、クライアントはLayoutReturnを介してレイアウトを返すプロセスを開始します。CB_LAYOUTRECALL操作は、LAYOUTRECALL_TYPE4の値を持つ3つの形式のリコール処理のうちの1つを指定します。リコールは、特定のファイル（LayoutRecall4_file）の特定のレイアウト（LayoutRecall4_file）、ファイルシステムID全体（LAYOUTRECALL4_FSID）、またはすべてのファイルシステム（LAYOUTRECALL4_ALL）です。"
    },
    {
      "indent": 3,
      "text": "The behavior of the operation varies based on the value of the layoutrecall_type4. The value and behaviors are:",
      "ja": "オペレーションの動作は、LAYOUTRECALL_TYPE4の値に基づいて異なります。値と行動は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRECALL4_FILE For a layout to match the recall request, the values of the following fields must match those of the layout: clora_type, clora_iomode, lor_fh, and the byte-range specified by lor_offset and lor_length. The clora_iomode field may have a special value of LAYOUTIOMODE4_ANY. The special value LAYOUTIOMODE4_ANY will match any iomode originally returned in a layout; therefore, it acts as a wild card. The other special value used is for lor_length. If lor_length has a value of NFS4_UINT64_MAX, the lor_length field means the maximum possible file size. If a matching layout is found, it MUST be returned using the LAYOUTRETURN operation (see Section 18.44). An example of the field's special value use is if clora_iomode is LAYOUTIOMODE4_ANY, lor_offset is zero, and lor_length is NFS4_UINT64_MAX, then the entire layout is to be returned.",
      "ja": "レイアウトのLayOutRecall4_fileリコール要求と一致するように、次のフィールドの値は、LAYOUT：CLORA_TYPE、CLORA_IOMODE、LOR_FH、およびLOR_OFFSETおよびLOR_LENGTHで指定されたバイト範囲の値と一致しなければなりません。CLORA_IOMODEフィールドは、LAYOUTIOMODE4_ANYの特別な値を持つことができます。特別な値LayoutIomode4_Anyは、レイアウトで最初に返されたiomode任意のiomodeと一致します。したがって、それはワイルドカードとして機能します。使用される他の特殊値はLOR_LENGTH用です。lor_lengthの値がNFS4_UINT64_MAXの値を持つ場合、LOR_LENGTHフィールドは可能な限り最大ファイルサイズを意味します。一致するレイアウトが見つかった場合は、LayoutReturn操作を使用して返される必要があります（セクション18.44を参照）。フィールドの特殊値の使用例は、clora_iomodeがlayoutioMode4_any、lor_offsetがゼロ、Lor_LengthがNFS4_UINT64_MAXである場合、レイアウト全体が返されることになります。"
    },
    {
      "indent": 6,
      "text": "The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts for the file or if the client does not have any overlapping layouts for the specification in the layout recall.",
      "ja": "NFS4ERR_NOMATCHING_LAYOUTエラーは、クライアントがファイルのレイアウトを保持していない場合、またはクライアントにレイアウトリコール内の仕様に対して重複するレイアウトがない場合にのみ返されます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL If LAYOUTRECALL4_FSID is specified, the fsid specifies the file system for which any outstanding layouts MUST be returned. If LAYOUTRECALL4_ALL is specified, all outstanding layouts MUST be returned. In addition, LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL specify that all the storage device ID to storage device address mappings in the affected file system(s) are also recalled. The respective LAYOUTRETURN with either LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL acknowledges to the server that the client invalidated the said device mappings. See Section 12.5.5.2.1.5 for considerations with \"bulk\" recall of layouts.",
      "ja": "LayOutRecall4_FSIDとLAYOUTRECALL4_ALL LAYOUTRECALL4_FSIDが指定されている場合、FSIDは未処理レイアウトを返す必要があるファイルシステムを指定します。LayOutRecall4_allが指定されている場合は、すべての未処理のレイアウトを返す必要があります。さらに、LAYOUTRECALL4_FSIDとLAYOUTRECALL4_ALLは、影響を受けるファイルシステム内の記憶装置アドレスマッピングへのすべての記憶装置IDを呼び出すように指定してください。LayoutReturn4_FSIDまたはLayOutReturn4_allのいずれかで、それぞれのレイアウトリトチャーは、クライアントが上記デバイスマッピングを無効にしたサーバーに確認します。レイアウトの「バルク」との考慮事項については、12.5.5.2.1.5項を参照してください。"
    },
    {
      "indent": 6,
      "text": "The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts and does not have valid deviceid mappings.",
      "ja": "NFS4ERR_NOMATCHING_LAYOUTエラーは、クライアントがレイアウトを保持しない場合にのみ返され、有効なDeviceIDマッピングがありません。"
    },
    {
      "indent": 3,
      "text": "In processing the layout recall request, the client also varies its behavior based on the value of the clora_changed field. This field is used by the server to provide additional context for the reason why the layout is being recalled. A FALSE value for clora_changed indicates that no change in the layout is expected and the client may write modified data to the storage devices involved; this must be done prior to returning the layout via LAYOUTRETURN. A TRUE value for clora_changed indicates that the server is changing the layout. Examples of layout changes and reasons for a TRUE indication are the following: the metadata server is restriping the file or a permanent error has occurred on a storage device and the metadata server would like to provide a new layout for the file. Therefore, a clora_changed value of TRUE indicates some level of change for the layout and the client SHOULD NOT write and commit modified data to the storage devices. In this case, the client writes and commits data through the metadata server.",
      "ja": "レイアウトリコール要求を処理する際に、クライアントはCLORA_CHANGEDフィールドの値に基づいてその動作を変化させます。このフィールドは、レイアウトがリコールされている理由について追加のコンテキストを提供するためにサーバーによって使用されます。 clora_changedのfalse値は、レイアウトの変更が予想されないことを示し、クライアントは変更されたデータを関連するストレージデバイスに書き込むことができます。これは、レイアウトをLayoutReturn経由で返す前に行わなければなりません。 clora_changedのTrue値は、サーバーがレイアウトを変更していることを示します。レイアウト変更の例と真の指示の理由の例は次のとおりです。メタデータサーバーはファイルを削除しているか、ストレージデバイスで永続的なエラーが発生し、メタデータサーバーはファイルの新しいレイアウトを提供します。したがって、TRUEのCLORA_CHANGED値は、レイアウトのためのある程度の変更レベルを示し、クライアントは変更されたデータを記憶装置に書き込んではないはずです。この場合、クライアントはメタデータサーバーを介してデータを書き込み、コミットします。"
    },
    {
      "indent": 3,
      "text": "See Section 12.5.3 for a description of how the lor_stateid field in the arguments is to be constructed. Note that the \"seqid\" field of lor_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "引数内のLOR_STATEIDフィールドを構築する方法については、セクション12.5.3を参照してください。LOR_STATEIDの「seqid」フィールドはゼロにしてはならないことに注意してください。さらなる議論と要件については、セクション8.2,12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "20.3.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.3.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client's processing for CB_LAYOUTRECALL is similar to CB_RECALL (recall of file delegations) in that the client responds to the request before actually returning layouts via the LAYOUTRETURN operation. While the client responds to the CB_LAYOUTRECALL immediately, the operation is not considered complete (i.e., considered pending) until all affected layouts are returned to the server via the LAYOUTRETURN operation.",
      "ja": "CB_LAYOUTRECALLのクライアントの処理は、クライアントがレイアウトリュータン操作を介して実際にレイアウトを返す前に要求に応答するという点で、CB_Recall（ファイル名称のリコール）と似ています。クライアントはすぐにCB_LAYOUTRECALLに応答している間、すべての影響を受けるレイアウトがLayoutReturn操作を介してサーバーに返されるまで、操作は完全に（すなわち、保留と見なす）とは見なされません。"
    },
    {
      "indent": 3,
      "text": "Before returning the layout to the server via LAYOUTRETURN, the client should wait for the response from in-process or in-flight READ, WRITE, or COMMIT operations that use the recalled layout.",
      "ja": "レイアウトをLayoutReturn経由でサーバーに返す前に、クライアントは、リコールされたレイアウトを使用するインプロセスまたは飛行中の読み取り、書き込み、またはコミット操作からの応答を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client is holding modified data that is affected by a recalled layout, the client has various options for writing the data to the server. As always, the client may write the data through the metadata server. In fact, the client may not have a choice other than writing to the metadata server when the clora_changed argument is TRUE and a new layout is unavailable from the server. However, the client may be able to write the modified data to the storage device if the clora_changed argument is FALSE; this needs to be done before returning the layout via LAYOUTRETURN. If the client were to obtain a new layout covering the modified data's byte-range, then writing to the storage devices is an available alternative. Note that before obtaining a new layout, the client must first return the original layout.",
      "ja": "クライアントがリコールされたレイアウトの影響を受ける変更されたデータを保持している場合、クライアントはデータをサーバーに書き込むためのさまざまなオプションを持ちます。いつものように、クライアントはメタデータサーバーを介してデータを書き込むことができます。実際、クライアントは、clora_changed引数がtrueであり、新しいレイアウトがサーバから利用できないときにメタデータサーバへの書き込み以外の選択肢がないかもしれません。ただし、CLORA_CHANGED引数がfalseの場合、クライアントは変更されたデータをストレージデバイスに書き込むことができます。LayoutReturnを介してレイアウトを返す前に行う必要があります。クライアントが変更されたデータのバイト範囲をカバーする新しいレイアウトを取得する場合、ストレージデバイスへの書き込みは利用可能な代替手段です。新しいレイアウトを取得する前に、クライアントは最初に元のレイアウトを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "In the case of modified data being written while the layout is held, the client must use LAYOUTCOMMIT operations at the appropriate time; as required LAYOUTCOMMIT must be done before the LAYOUTRETURN. If a large amount of modified data is outstanding, the client may send LAYOUTRETURNs for portions of the recalled layout; this allows the server to monitor the client's progress and adherence to the original recall request. However, the last LAYOUTRETURN in a sequence of returns MUST specify the full range being recalled (see Section 12.5.5.1 for details).",
      "ja": "レイアウトが保持されている間に書き込まれているデータが書き込まれている場合、クライアントは適切な時点でLayoutCommit操作を使用する必要があります。必要に応じて、LayoutReturnの前にLayoutCommitを実行する必要があります。大量の修正データが未解決である場合、クライアントはリコールされたレイアウトの一部に対してLayoutReturnを送信することができます。これにより、サーバーはクライアントの進捗状況を元のリコール要求に順守することができます。ただし、リターンのシーケンスの最後のLayoutReturnは、リコールされている全範囲を指定する必要があります（詳細は項12.5.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "If a server needs to delete a device ID and there are layouts referring to the device ID, CB_LAYOUTRECALL MUST be invoked to cause the client to return all layouts referring to the device ID before the server can delete the device ID. If the client does not return the affected layouts, the server MAY revoke the layouts.",
      "ja": "サーバーがデバイスIDを削除し、デバイスIDを参照するレイアウトがある場合は、CB_LAYOUTRECALLを呼び出して、サーバーがデバイスIDを削除する前に、デバイスIDを参照してすべてのレイアウトを返すように呼び出す必要があります。クライアントが影響を受けるレイアウトを返さない場合、サーバーはレイアウトを取り消すことがあります。"
    },
    {
      "indent": 0,
      "text": "20.4. Operation 6: CB_NOTIFY - Notify Client of Directory Changes",
      "section_title": true,
      "ja": "20.4. 操作6：CB_NOTIFY  - ディレクトリの変更のクライアントに通知する"
    },
    {
      "indent": 0,
      "text": "20.4.1. ARGUMENT",
      "section_title": true,
      "ja": "20.4.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * Directory notification types.\n */\nenum notify_type4 {\n        NOTIFY4_CHANGE_CHILD_ATTRS = 0,\n        NOTIFY4_CHANGE_DIR_ATTRS = 1,\n        NOTIFY4_REMOVE_ENTRY = 2,\n        NOTIFY4_ADD_ENTRY = 3,\n        NOTIFY4_RENAME_ENTRY = 4,\n        NOTIFY4_CHANGE_COOKIE_VERIFIER = 5\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Changed entry information.  */\nstruct notify_entry4 {\n        component4      ne_file;\n        fattr4          ne_attrs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Previous entry information */\nstruct prev_entry4 {\n        notify_entry4   pe_prev_entry;\n        /* what READDIR returned for this entry */\n        nfs_cookie4     pe_prev_entry_cookie;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify_remove4 {\n        notify_entry4   nrm_old_entry;\n        nfs_cookie4     nrm_old_entry_cookie;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify_add4 {\n        /*\n         * Information on object\n         * possibly renamed over.\n         */\n        notify_remove4      nad_old_entry<1>;\n        notify_entry4       nad_new_entry;\n        /* what READDIR would have returned for this entry */\n        nfs_cookie4         nad_new_entry_cookie<1>;\n        prev_entry4         nad_prev_entry<1>;\n        bool                nad_last_entry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify_attr4 {\n        notify_entry4   na_changed_entry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify_rename4 {\n        notify_remove4  nrn_old_entry;\n        notify_add4     nrn_new_entry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify_verifier4 {\n        verifier4       nv_old_cookieverf;\n        verifier4       nv_new_cookieverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Objects of type notify_<>4 and\n * notify_device_<>4 are encoded in this.\n */\ntypedef opaque notifylist4<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct notify4 {\n        /* composed from notify_type4 or notify_deviceid_type4 */\n        bitmap4         notify_mask;\n        notifylist4     notify_vals;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY4args {\n        stateid4    cna_stateid;\n        nfs_fh4     cna_fh;\n        notify4     cna_changes<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.4.2. RESULT",
      "section_title": true,
      "ja": "20.4.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY4res {\n        nfsstat4    cnr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.4.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.4.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_NOTIFY operation is used by the server to send notifications to clients about changes to delegated directories. The registration of notifications for the directories occurs when the delegation is established using GET_DIR_DELEGATION. These notifications are sent over the backchannel. The notification is sent once the original request has been processed on the server. The server will send an array of notifications for changes that might have occurred in the directory. The notifications are sent as list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.",
      "ja": "CB_NOTIFY操作は、委任ディレクトリへの変更に関するクライアントに通知を送信するためにサーバーによって使用されます。ディレクトリの通知の登録は、get_dir_delegationを使用して委任が確立されたときに発生します。これらの通知はバックチャネルを介して送信されます。元の要求がサーバー上で処理されると通知が送信されます。サーバーは、ディレクトリに発生した可能性がある変更に対して通知の配列を送信します。通知はビットマップと値のペアのリストとして送信されます。NFSv4.1のビットマップがどのように機能するかについては、3.3.7項を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the server has more notifications than can fit in the CB_COMPOUND request, it SHOULD send a sequence of serial CB_COMPOUND requests so that the client's view of the directory does not become confused. For example, if the server indicates that a file named \"foo\" is added and that the file \"foo\" is removed, the order in which the client receives these notifications needs to be the same as the order in which the corresponding operations occurred on the server.",
      "ja": "サーバーにCB_COMPOUND要求に適合することができるよりも多くの通知がある場合は、ディレクトリのクライアントのビューが混乱しないようにシリアルCB_COM_POUND要求のシーケンスを送信する必要があります。たとえば、サーバーが \"foo\"という名前のファイルが追加され、ファイル \"foo\"が削除されたことを示す場合、クライアントがこれらの通知を受け取る順序は、対応する操作が発生した順序と同じである必要があります。サーバー。"
    },
    {
      "indent": 3,
      "text": "If the client holding the delegation makes any changes in the directory that cause files or sub-directories to be added or removed, the server will notify that client of the resulting change(s). If the client holding the delegation is making attribute or cookie verifier changes only, the server does not need to send notifications to that client. The server will send the following information for each operation:",
      "ja": "委任を保持しているクライアントが、ファイルまたはサブディレクトリを追加または削除させるディレクトリに変更を加えると、その結果、結果の変更のクライアントを通知します。委任を保持しているクライアントが属性またはCookie Verifierを変更している場合、サーバーはそのクライアントに通知を送信する必要はありません。サーバーは各操作に次の情報を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_ADD_ENTRY The server will send information about the new directory entry being created along with the cookie for that entry. The entry information (data type notify_add4) includes the component name of the entry and attributes. The server will send this type of entry when a file is actually being created, when an entry is being added to a directory as a result of a rename across directories (see below), and when a hard link is being created to an existing file. If this entry is added to the end of the directory, the server will set the nad_last_entry flag to TRUE. If the file is added such that there is at least one entry before it, the server will also return the previous entry information (nad_prev_entry, a variable-length array of up to one element. If the array is of zero length, there is no previous entry), along with its cookie. This is to help clients find the right location in their file name caches and directory caches where this entry should be cached. If the new entry's cookie is available, it will be in the nad_new_entry_cookie (another variable-length array of up to one element) field. If the addition of the entry causes another entry to be deleted (which can only happen in the rename case) atomically with the addition, then information on this entry is reported in nad_old_entry.",
      "ja": "NOTIFY4_ADD_ENTRYサーバーは、そのエントリのCookieと共に作成されている新しいディレクトリエントリに関する情報を送信します。エントリ情報（データ型NOTIFY_ADD4）には、エントリと属性のコンポーネント名が含まれています。サーバーは、ディレクトリ間の名前変更の結果としてエントリがディレクトリに追加されているとき（下記参照）、および既存のファイルにハードリンクが作成されている場合に、サーバーがこのタイプのエントリを送信します。 。このエントリがディレクトリの末尾に追加された場合、サーバーはNAD_LAST_ENTRYフラグをtrueに設定します。その前に少なくとも1つのエントリがあるようにファイルが追加された場合、サーバーは前のエントリ情報（NAD_PREV_ENTRY、最大1つの要素の可変長配列です。配列がゼロの場合は、存在する場合はありません。以前のエントリー）、そのクッキーとともに。これは、クライアントがこのエントリをキャッシュする必要があるファイル名キャッシュとディレクトリキャッシュの正しい場所を見つけるのに役立ちます。新しいエントリのCookieが利用可能な場合は、NAD_New_Entry_Cookie（最大1つの要素の別の可変長配列）フィールドになります。エントリを追加すると、別のエントリが追加された場合（名前変更の場合にのみ行われます）アトミックでアトミックで、このエントリの情報はnad_old_entryに報告されます。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_REMOVE_ENTRY The server will send information about the directory entry being deleted. The server will also send the cookie value for the deleted entry so that clients can get to the cached information for this entry.",
      "ja": "Notify4_Remove_Entryサーバーは、削除されているディレクトリエントリに関する情報を送信します。クライアントがこのエントリのキャッシュ情報にアクセスできるように、サーバーは削除されたエントリのCookie値を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_RENAME_ENTRY The server will send information about both the old entry and the new entry. This includes the name and attributes for each entry. In addition, if the rename causes the deletion of an entry (i.e., the case of a file renamed over), then this is reported in nrn_new_new_entry.nad_old_entry. This notification is only sent if both entries are in the same directory. If the rename is across directories, the server will send a remove notification to one directory and an add notification to the other directory, assuming both have a directory delegation.",
      "ja": "Notify4_Rename_Entryサーバーは、古いエントリと新しいエントリの両方に関する情報を送信します。これには、各エントリの名前と属性が含まれます。さらに、名前変更がエントリの削除（すなわちファイルの名前を変更した場合）の場合、これはNRN_NEW_NEW_ENTRY.NAD_OLD_OLD_ENTRYで報告されます。この通知は、両方のエントリが同じディレクトリ内にある場合にのみ送信されます。名前の変更がディレクトリ間である場合、サーバーは1つのディレクトリへの削除を1つのディレクトリに送信し、他のディレクトリへの追加通知はディレクトリの委任を想定しています。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_CHANGE_CHILD_ATTRS/NOTIFY4_CHANGE_DIR_ATTRS The client will use the attribute mask to inform the server of attributes for which it wants to receive notifications. This change notification can be requested for changes to the attributes of the directory as well as changes to any file's attributes in the directory by using two separate attribute masks. The client cannot ask for change attribute notification for a specific file. One attribute mask covers all the files in the directory. Upon any attribute change, the server will send back the values of changed attributes. Notifications might not make sense for some file system-wide attributes, and it is up to the server to decide which subset it wants to support. The client can negotiate the frequency of attribute notifications by letting the server know how often it wants to be notified of an attribute change. The server will return supported notification frequencies or an indication that no notification is permitted for directory or child attributes by setting the dir_notif_delay and dir_entry_notif_delay attributes, respectively.",
      "ja": "notify4_change_child_attrs / notify4_change_dir_attrsクライアントは属性マスクを使用して通知を受け取りたい属性をサーバに知らせます。この変更通知は、ディレクトリの属性への変更、および2つの別々の属性マスクを使用してディレクトリ内の任意のファイルの属性に対する変更に対して要求されます。クライアントは特定のファイルの変更属性通知を求めることができません。 1つの属性マスクは、ディレクトリ内のすべてのファイルをカバーします。属性が変更されると、サーバーは変更された属性の値を送り返します。通知は一部のシステム全体の属性に対して意味がない可能性があり、サポートしたいサブセットを決定するためにサーバー次第です。クライアントは、サーバーに属性変更を通知したいことがどの程度の頻度であるかを知らせることで、属性通知の頻度を交渉できます。サーバーはサポートされている通知周波数を返し、それぞれDIR_NOTIF_DELAYおよびDIR_ENTRY_NOTIF_DELAY属性を設定して、ディレクトリまたは子属性に対して通知が許可されていないことを示します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_CHANGE_COOKIE_VERIFIER If the cookie verifier changes while a client is holding a delegation, the server will notify the client so that it can invalidate its cookies and re-send a READDIR to get the new set of cookies.",
      "ja": "Notify4_Change_Cookie_verifierクライアントが委任を保持している間にCookie Verifierが変更された場合、サーバーはクッキーを無効にしてREADDIRを再送信して新しいCookieのセットを取得できるようにクライアントに通知します。"
    },
    {
      "indent": 0,
      "text": "20.5. Operation 7: CB_PUSH_DELEG - Offer Previously Requested Delegation to Client",
      "ja": "20.5. 操作7：CB_PUSH_DELEG  - 以前に要求された委任をクライアントに提供する"
    },
    {
      "indent": 0,
      "text": "20.5.1. ARGUMENT",
      "section_title": true,
      "ja": "20.5.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_PUSH_DELEG4args {\n        nfs_fh4          cpda_fh;\n        open_delegation4 cpda_delegation;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};",
      "ja": ";;"
    },
    {
      "indent": 0,
      "text": "20.5.2. RESULT",
      "section_title": true,
      "ja": "20.5.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_PUSH_DELEG4res {\n        nfsstat4 cpdr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.5.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.5.3. description"
    },
    {
      "indent": 3,
      "text": "CB_PUSH_DELEG is used by the server both to signal to the client that the delegation it wants (previously indicated via a want established from an OPEN or WANT_DELEGATION operation) is available and to simultaneously offer the delegation to the client. The client has the choice of accepting the delegation by returning NFS4_OK to the server, delaying the decision to accept the offered delegation by returning NFS4ERR_DELAY, or permanently rejecting the offer of the delegation by returning NFS4ERR_REJECT_DELEG. When a delegation is rejected in this fashion, the want previously established is permanently deleted and the delegation is subject to acquisition by another client.",
      "ja": "CB_PUSH_DELEGは、サーバーがクライアントに送信され、それが望む委任が希望する委任（オープンまたはwant_delegation操作から確立された欲求を介して示された）が利用可能であること、および同時に委任をクライアントに提供することができます。クライアントは、NFS4_OKをサーバーに返すことによって委任を受け入れることを選択し、NFS4ERR_DELAYを返すか、またはNFS4ERR_REJECT_DELEGを返すことによって委任のオファーを永久に拒否します。このようにして委任が拒否されると、以前に確立されたほしい物が恒久的に削除され、委任は別のクライアントによる取得の対象となります。"
    },
    {
      "indent": 0,
      "text": "20.5.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.5.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client does return NFS4ERR_DELAY and there is a conflicting delegation request, the server MAY process it at the expense of the client that returned NFS4ERR_DELAY. The client's want will not be cancelled, but MAY be processed behind other delegation requests or registered wants.",
      "ja": "クライアントがNFS4ERR_DELAYを返し、矛盾する委任要求がある場合、サーバーはNFS4ERR_DELAYを返したクライアントを犠牲にして処理できます。クライアントの希望はキャンセルされませんが、他の委任要求または登録済みの希望の背後に処理される可能性があります。"
    },
    {
      "indent": 3,
      "text": "When a client returns a status other than NFS4_OK, NFS4ERR_DELAY, or NFS4ERR_REJECT_DELAY, the want remains pending, although servers may decide to cancel the want by sending a CB_WANTS_CANCELLED.",
      "ja": "クライアントがNFS4_OK、NFS4ERR_DELAY、またはNFS4ERR_REJECT_DELAY以外のステータスを返すと、サーバーはCB_WANTS_CANCELLEDを送信することによって必要なものをキャンセルすることを決定することができますが、必要な場合は保留中です。"
    },
    {
      "indent": 0,
      "text": "20.6. Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects",
      "section_title": true,
      "ja": "20.6. 操作8：CB_RECALL_ANY  -  Nをリコール可能なオブジェクトを保持する"
    },
    {
      "indent": 0,
      "text": "20.6.1. ARGUMENT",
      "section_title": true,
      "ja": "20.6.1. 引数"
    },
    {
      "indent": 3,
      "text": "const RCA4_TYPE_MASK_RDATA_DLG          = 0;\nconst RCA4_TYPE_MASK_WDATA_DLG          = 1;\nconst RCA4_TYPE_MASK_DIR_DLG            = 2;\nconst RCA4_TYPE_MASK_FILE_LAYOUT        = 3;\nconst RCA4_TYPE_MASK_BLK_LAYOUT         = 4;\nconst RCA4_TYPE_MASK_OBJ_LAYOUT_MIN     = 8;\nconst RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;\nconst RCA4_TYPE_MASK_OTHER_LAYOUT_MIN   = 12;\nconst RCA4_TYPE_MASK_OTHER_LAYOUT_MAX   = 15;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct  CB_RECALL_ANY4args      {\n        uint32_t        craa_objects_to_keep;\n        bitmap4         craa_type_mask;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.6.2. RESULT",
      "section_title": true,
      "ja": "20.6.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_ANY4res {\n        nfsstat4        crar_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.6.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.6.3. description"
    },
    {
      "indent": 3,
      "text": "The server may decide that it cannot hold all of the state for recallable objects, such as delegations and layouts, without running out of resources. In such a case, while not optimal, the server is free to recall individual objects to reduce the load.",
      "ja": "サーバーは、リソースを使い果たさずに、委任やレイアウトなど、リコール可能なオブジェクトのすべての状態を保持できないと判断できます。そのような場合は、最適ではないが、サーバーは負荷を軽減するために個々のオブジェクトを呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "Because the general purpose of such recallable objects as delegations is to eliminate client interaction with the server, the server cannot interpret lack of recent use as indicating that the object is no longer useful. The absence of visible use is consistent with a delegation keeping potential operations from being sent to the server. In the case of layouts, while it is true that the usefulness of a layout is indicated by the use of the layout when storage devices receive I/O requests, because there is no mandate that a storage device indicate to the metadata server any past or present use of a layout, the metadata server is not likely to know which layouts are good candidates to recall in response to low resources.",
      "ja": "代表団としてのこのようなリコール可能なオブジェクトの汎用は、サーバとのクライアントの対話を排除することであるため、サーバは最近の使用不足を解釈できないため、オブジェクトが有用ではないことを示すものである。可視使用の欠如は、潜在的な操作をサーバーに送信されるのを防ぐための委任と一致しています。レイアウトの場合、ストレージデバイスがI / O要求を受信したときにレイアウトの有用性が表示され、記憶装置がメタデータサーバに記憶されているため、またはレイアウトの現在の使用、メタデータサーバは、どのレイアウトが低リソースに応答してリコールするかを知る可能性が低い。"
    },
    {
      "indent": 3,
      "text": "In order to implement an effective reclaim scheme for such objects, the server's knowledge of available resources must be used to determine when objects must be recalled with the clients selecting the actual objects to be returned.",
      "ja": "そのようなオブジェクトに対して効果的な再利用方式を実装するために、利用可能なリソースに関するサーバの知識を使用して、返されるべき実際のオブジェクトを選択するクライアントでオブジェクトを呼び出す必要があるかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "Server implementations may differ in their resource allocation requirements. For example, one server may share resources among all classes of recallable objects, whereas another may use separate resource pools for layouts and for delegations, or further separate resources by types of delegations.",
      "ja": "サーバーの実装は、リソース割り当て要件が異なる場合があります。たとえば、1つのサーバーはリコール可能なオブジェクトのすべてのクラスの間でリソースを共有することができますが、別のサーバーはレイアウトや代表団のために別々のリソースプールを使用することができます。"
    },
    {
      "indent": 3,
      "text": "When a given resource pool is over-utilized, the server can send a CB_RECALL_ANY to clients holding recallable objects of the types involved, allowing it to keep a certain number of such objects and return any excess. A mask specifies which types of objects are to be limited. The client chooses, based on its own knowledge of current usefulness, which of the objects in that class should be returned.",
      "ja": "特定のリソースプールがオーバーアルされると、サーバーは関連する型のリコール可能なオブジェクトを保持しているクライアントにCB_RECALL_ANYを送信でき、そのようなオブジェクトを一定のオブジェクトに保つことができ、余分なものを返します。マスクは、どの種類のオブジェクトを制限するかを指定します。クライアントは、現在の有用性に関する独自の知識に基づいて、そのクラスのオブジェクトのうちのどのオブジェクトを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "A number of bits are defined. For some of these, ranges are defined and it is up to the definition of the storage protocol to specify how these are to be used. There are ranges reserved for object-based storage protocols and for other experimental storage protocols. An RFC defining such a storage protocol needs to specify how particular bits within its range are to be used. For example, it may specify a mapping between attributes of the layout (read vs. write, size of area) and the bit to be used, or it may define a field in the layout where the associated bit position is made available by the server to the client.",
      "ja": "いくつかのビットが定義されています。これらのうちのいくつかについては、範囲が定義されており、これらを使用する方法を指定するためにストレージプロトコルの定義次第です。オブジェクトベースのストレージプロトコルおよび他の実験的ストレージプロトコルのために予約されている範囲があります。そのようなストレージプロトコルを定義するRFCは、その範囲内の特定のビットを使用する方法を指定する必要があります。たとえば、レイアウトの属性（読み取り対書き込み、領域のサイズ）と使用されるビットの間のマッピングを指定したり、関連するビット位置がサーバーによって使用可能にされるレイアウト内のフィールドを定義することがあります。クライアントに。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_RDATA_DLG The client is to return OPEN_DELEGATE_READ delegations on non-directory file objects.",
      "ja": "RCA4_TYPE_MASK_RDATA_DLGクライアントは、ディレクトリ以外のファイルオブジェクトにOpen_Delegate_Readの委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_WDATA_DLG The client is to return OPEN_DELEGATE_WRITE delegations on regular file objects.",
      "ja": "RCA4_TYPE_MASK_WDATA_DLGクライアントは、通常のファイルオブジェクトでOpen_Delegate_Writeの委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_DIR_DLG The client is to return directory delegations.",
      "ja": "RCA4_TYPE_MASK_DIR_DLGクライアントはディレクトリ委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_FILE_LAYOUT The client is to return layouts of type LAYOUT4_NFSV4_1_FILES.",
      "ja": "RCA4_TYPE_MASK_FILE_LAYOUTクライアントは、LAYOUT4_NFSV4_1_FILESのレイアウトを返します。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_BLK_LAYOUT See [48] for a description.",
      "ja": "説明については、RCA4_TYPE_MASK_BLK_LAYOUT [48]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_OBJ_LAYOUT_MIN to RCA4_TYPE_MASK_OBJ_LAYOUT_MAX See [47] for a description.",
      "ja": "RCA4_TYPE_MASK_OBJ_LAYOUT_MIN~RCA4_TYPE_MASK_OBJ_LAYOUT_MAX説明については[47]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_OTHER_LAYOUT_MIN to RCA4_TYPE_MASK_OTHER_LAYOUT_MAX This range is reserved for telling the client to recall layouts of experimental or site-specific layout types (see Section 3.3.13).",
      "ja": "RCA4_TYPE_MASK_OTHER_LAYOUT_MIN~RCA4_TYPE_MASK_OTHER_LAYOUT_MAXこの範囲は、実験的またはサイト固有のレイアウト型のレイアウトをリコールするようにクライアントに指示するために予約されています（セクション3.3.13を参照）。"
    },
    {
      "indent": 3,
      "text": "When a bit is set in the type mask that corresponds to an undefined type of recallable object, NFS4ERR_INVAL MUST be returned. When a bit is set that corresponds to a defined type of object but the client does not support an object of the type, NFS4ERR_INVAL MUST NOT be returned. Future minor versions of NFSv4 may expand the set of valid type mask bits.",
      "ja": "未定義のタイプのリコール可能なオブジェクトに対応するタイプマスクにビットが設定されている場合は、NFS4ERR_INVALを返す必要があります。オブジェクトの定義されたタイプに対応するが、クライアントがタイプのオブジェクトをサポートしていないビットが設定されている場合、NFS4ERR_INVALは返されてはいけません。NFSV4の将来のマイナーバージョンは、有効型マスクビットのセットを拡張することができます。"
    },
    {
      "indent": 3,
      "text": "CB_RECALL_ANY specifies a count of objects that the client may keep as opposed to a count that the client must return. This is to avoid a potential race between a CB_RECALL_ANY that had a count of objects to free with a set of client-originated operations to return layouts or delegations. As a result of the race, the client and server would have differing ideas as to how many objects to return. Hence, the client could mistakenly free too many.",
      "ja": "CB_RECALL_ANYクライアントが、クライアントが返却しなければならないカウントとは対照的に保持できるオブジェクトの数を指定します。これは、レイアウトや委任を返すために一連のクライアント発信操作で、オブジェクトの数を含まないCB_RECALL_ANYの間の潜在的なレースを回避することです。レースの結果として、クライアントとサーバーには、返すオブジェクトの数については、異なるアイデアがあります。したがって、クライアントは誤って自由すぎる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If resource demands prompt it, the server may send another CB_RECALL_ANY with a lower count, even if it has not yet received an acknowledgment from the client for a previous CB_RECALL_ANY with the same type mask. Although the possibility exists that these will be received by the client in an order different from the order in which they were sent, any such permutation of the callback stream is harmless. It is the job of the client to bring down the size of the recallable object set in line with each CB_RECALL_ANY received, and until that obligation is met, it cannot be cancelled or modified by any subsequent CB_RECALL_ANY for the same type mask. Thus, if the server sends two CB_RECALL_ANYs, the effect will be the same as if the lower count was sent, whatever the order of recall receipt. Note that this means that a server may not cancel the effect of a CB_RECALL_ANY by sending another recall with a higher count. When a CB_RECALL_ANY is received and the count is already within the limit set or is above a limit that the client is working to get down to, that callback has no effect.",
      "ja": "リソースがプロンプトを要求する場合、同じタイプのマスクを持つ前のCB_RECALL_ANについては、クライアントからの確認応答をまだ受信していない場合でも、サーバーはもう1つのCB_RECALL_ANを送信することができます。この可能性は、これらが送信された順序とは異なる順序でクライアントによって受信される可能性がありますが、コールバックストリームのそのような置換は無害です。受信した各CB_RECALL_ANYに沿って設定されたリコール可能なオブジェクトのサイズを表示するクライアントのジョブであり、その義務が満たされるまで、同じタイプのマスクの後続のCB_RECALL_ANYによってキャンセルまたは変更することはできません。したがって、サーバーが2つのCB_RECALL_ANYSを送信した場合、リコールレシートの順序であっても、その効果は、下位カウントが送信された場合と同じになります。これは、サーバが他のリコールをより高いカウントで送信することによって、サーバがCB_RECALL_ANYの効果をキャンセルしない可能性があることに注意してください。 CB_RECALL_ANYが受信され、カウントが既に制限セット内にある場合、またはクライアントが降下している限界を超えている場合、そのコールバックは効果がありません。"
    },
    {
      "indent": 3,
      "text": "Servers are generally free to deny recallable objects when insufficient resources are available. Note that the effect of such a policy is implicitly to give precedence to existing objects relative to requested ones, with the result that resources might not be optimally used. To prevent this, servers are well advised to make the point at which they start sending CB_RECALL_ANY callbacks somewhat below that at which they cease to give out new delegations and layouts. This allows the client to purge its less-used objects whenever appropriate and so continue to have its subsequent requests given new resources freed up by object returns.",
      "ja": "サーバーは一般に、不十分なリソースが利用可能な場合はリコール可能なオブジェクトを拒否します。そのようなポリシーの効果は、要求されたものと関連して既存のオブジェクトに優先されることを暗黙のうちに、リソースが最適に使用されない可能性があることに注意してください。これを防ぐために、サーバーは、それらが新しい代表団とレイアウトを出すことを停止しているCB_RECALL_ANYコールバックの送信を開始するポイントをよく推奨されています。これにより、クライアントは適切なときに使用されていないオブジェクトを削除することができ、その後、オブジェクトの返品によって新しいリソースが解放された場合にその後の要求を続けることができます。"
    },
    {
      "indent": 0,
      "text": "20.6.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.6.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client can choose to return any type of object specified by the mask. If a server wishes to limit the use of objects of a specific type, it should only specify that type in the mask it sends. Should the client fail to return requested objects, it is up to the server to handle this situation, typically by sending specific recalls (i.e., sending CB_RECALL operations) to properly limit resource usage. The server should give the client enough time to return objects before proceeding to specific recalls. This time should not be less than the lease period.",
      "ja": "クライアントは、マスクで指定された任意の種類のオブジェクトを返すように選択できます。サーバーが特定の型のオブジェクトの使用を制限したい場合は、送信したマスクにそのタイプのみを指定する必要があります。クライアントが要求されたオブジェクトを返すことに失敗すると、通常は特定のリコールを送信する（すなわち、CB_Recall Operationsの送信）を処理するようにサーバー次第です。サーバーは、特定のリコールに進む前に、クライアントにオブジェクトを返すのに十分な時間を与える必要があります。今回はリース期間よりも小さくてはいけません。"
    },
    {
      "indent": 0,
      "text": "20.7. Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal Resources for Recallable Objects",
      "ja": "20.7. 動作9：CB_RECALLABLE_OBJ_AVAIL  - リコール可能なオブジェクトの信号リソース"
    },
    {
      "indent": 0,
      "text": "20.7.1. ARGUMENT",
      "section_title": true,
      "ja": "20.7.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4args;",
      "ja": "typedef cb_recall_any4args cb_recallable_obj_avail4args;"
    },
    {
      "indent": 0,
      "text": "20.7.2. RESULT",
      "section_title": true,
      "ja": "20.7.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALLABLE_OBJ_AVAIL4res {\n        nfsstat4        croa_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.7.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.7.3. description"
    },
    {
      "indent": 3,
      "text": "CB_RECALLABLE_OBJ_AVAIL is used by the server to signal the client that the server has resources to grant recallable objects that might previously have been denied by OPEN, WANT_DELEGATION, GET_DIR_DELEG, or LAYOUTGET.",
      "ja": "CB_RECALLABLE_OBJ_AVAILは、サーバーによって、サーバーが開始された、want_delegation、get_dir_deleg、またはlayoutgetによって以前に拒否された可能性があるリコール可能なオブジェクトを付与するためのリソースがあることをクライアントに通知するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The argument craa_objects_to_keep means the total number of recallable objects of the types indicated in the argument type_mask that the server believes it can allow the client to have, including the number of such objects the client already has. A client that tries to acquire more recallable objects than the server informs it can have runs the risk of having objects recalled.",
      "ja": "引数craa_objects_to_keepは、クライアントがすでに持っているそのようなオブジェクトの数を含めて、サーバーがクライアントが持つことができると考えている引数type_maskに示されているタイプのリコール可能なオブジェクトの総数を意味します。サーバーよりもリコールできないオブジェクトを取得しようとするクライアントは、オブジェクトを呼び出すリスクを実行できるようになります。"
    },
    {
      "indent": 3,
      "text": "The server is not obligated to reserve the difference between the number of the objects the client currently has and the value of craa_objects_to_keep, nor does delaying the reply to CB_RECALLABLE_OBJ_AVAIL prevent the server from using the resources of the recallable objects for another purpose. Indeed, if a client responds slowly to CB_RECALLABLE_OBJ_AVAIL, the server might interpret the client as having reduced capability to manage recallable objects, and so cancel or reduce any reservation it is maintaining on behalf of the client. Thus, if the client desires to acquire more recallable objects, it needs to reply quickly to CB_RECALLABLE_OBJ_AVAIL, and then send the appropriate operations to acquire recallable objects.",
      "ja": "サーバーは、クライアントが現在持っているオブジェクトの数とcraa_objects_to_keepの値との間の差を予約することも、サーバーがリコール可能なオブジェクトのリソースを別の目的のために使用するのを防ぎます。実際、クライアントがCB_RECALLABLE_OBJ_AVAILにゆっくりと応答すると、サーバーはリコール可能なオブジェクトを管理する機能が低下したとして解釈される可能性があります。そのため、クライアントに代わって維持されている予約をキャンセルまたは減らすことができます。したがって、クライアントがよりリソタルなオブジェクトを取得したい場合は、CB_RECALLABLE_OBJ_AVAILに迅速に返信する必要があり、その適切な操作を送信してリコール可能なオブジェクトを取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "20.8. Operation 10: CB_RECALL_SLOT - Change Flow Control Limits",
      "section_title": true,
      "ja": "20.8. 動作10：CB_RECALL_SLOT  - フロー制御の制限を変更します"
    },
    {
      "indent": 0,
      "text": "20.8.1. ARGUMENT",
      "section_title": true,
      "ja": "20.8.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_SLOT4args {\n        slotid4       rsa_target_highest_slotid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.8.2. RESULT",
      "section_title": true,
      "ja": "20.8.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_SLOT4res {\n        nfsstat4   rsr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.8.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.8.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_RECALL_SLOT operation requests the client to return session slots, and if applicable, transport credits (e.g., RDMA credits for connections associated with the operations channel) of the session's fore channel. CB_RECALL_SLOT specifies rsa_target_highest_slotid, the value of the target highest slot ID the server wants for the session. The client MUST then progress toward reducing the session's highest slot ID to the target value.",
      "ja": "CB_RECALL_SLOT操作は、クライアントにセッションスロットを返すように要求し、該当する場合は、セッションの前のチャネルのトランスポートクレジット（例えば、操作チャネルに関連付けられている接続のためのRDMAクレジット）です。CB_RECALL_SLOTは、RSA_TARGET_HIGHEST_SLOTIDを指定します。ターゲットの最高スロットIDの値は、セッションに求められています。その場合、クライアントはセッションの最も高いスロットIDを目標値に縮小するために進歩する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the session has only non-RDMA connections associated with its operations channel, then the client need only wait for all outstanding requests with a slot ID > rsa_target_highest_slotid to complete, then send a single COMPOUND consisting of a single SEQUENCE operation, with the sa_highestslot field set to rsa_target_highest_slotid. If there are RDMA-based connections associated with operation channel, then the client needs to also send enough zero-length \"RDMA Send\" messages to take the total RDMA credit count to rsa_target_highest_slotid + 1 or below.",
      "ja": "セッションがその操作チャネルに関連付けられていない非RDMA接続のみを持っている場合、クライアントはスロットID> RSA_TARGET_HIGHEST_SLOTIDを完了するためのすべての未処理要求を待ってから、SA_HIGHESTSLOTフィールドを使用して、単一のシーケンス操作で構成される単一の化合物を送信するだけです。RSA_TARGET_HIGHEST_SLOTIDに設定してください。操作チャネルに関連付けられているRDMAベースの接続がある場合、クライアントは、RSA_TARGET_HIGHEST_SLOTID 1以下のRDMAクレジットカウントを取得するのに十分なゼロ長 \"RDMA SEND\"メッセージを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "20.8.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.8.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client fails to reduce highest slot it has on the fore channel to what the server requests, the server can force the issue by asserting flow control on the receive side of all connections bound to the fore channel, and then finish servicing all outstanding requests that are in slots greater than rsa_target_highest_slotid. Once that is done, the server can then open the flow control, and any time the client sends a new request on a slot greater than rsa_target_highest_slotid, the server can return NFS4ERR_BADSLOT.",
      "ja": "クライアントがサーバーの要求に最適なスロットを縮小できない場合、サーバーは、フアチャネルにバインドされているすべての接続の受信側のフロー制御をアサートしてから、その問題を強制的に実行できます。これはRSA_TARGET_HIGHEST_SLOTIDよりもスロットです。それが完了すると、サーバーはフロー制御を開くことができ、クライアントがRSA_TARGET_HIGHEST_SLOTIDより大きいスロット上で新しい要求を送信するときはいつでも、サーバーはNFS4ERR_BADSLOTを返すことができます。"
    },
    {
      "indent": 0,
      "text": "20.9. Operation 11: CB_SEQUENCE - Supply Backchannel Sequencing and Control",
      "ja": "20.9. 操作11：CB_SEQUENCE  - バックチャネルシーケンスと制御"
    },
    {
      "indent": 0,
      "text": "20.9.1. ARGUMENT",
      "section_title": true,
      "ja": "20.9.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct referring_call4 {\n        sequenceid4     rc_sequenceid;\n        slotid4         rc_slotid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct referring_call_list4 {\n        sessionid4      rcl_sessionid;\n        referring_call4 rcl_referring_calls<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_SEQUENCE4args {\n        sessionid4           csa_sessionid;\n        sequenceid4          csa_sequenceid;\n        slotid4              csa_slotid;\n        slotid4              csa_highest_slotid;\n        bool                 csa_cachethis;\n        referring_call_list4 csa_referring_call_lists<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.9.2. RESULT",
      "section_title": true,
      "ja": "20.9.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_SEQUENCE4resok {\n        sessionid4         csr_sessionid;\n        sequenceid4        csr_sequenceid;\n        slotid4            csr_slotid;\n        slotid4            csr_highest_slotid;\n        slotid4            csr_target_highest_slotid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union CB_SEQUENCE4res switch (nfsstat4 csr_status) {\ncase NFS4_OK:\n        CB_SEQUENCE4resok   csr_resok4;\ndefault:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.9.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.9.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_SEQUENCE operation is used to manage operational accounting for the backchannel of the session on which a request is sent. The contents include the session ID to which this request belongs, the slot ID and sequence ID used by the server to implement session request control and exactly once semantics, and exchanged slot ID maxima that are used to adjust the size of the reply cache. In each CB_COMPOUND request, CB_SEQUENCE MUST appear once and MUST be the first operation. The error NFS4ERR_SEQUENCE_POS MUST be returned when CB_SEQUENCE is found in any position in a CB_COMPOUND beyond the first. If any other operation is in the first position of CB_COMPOUND, NFS4ERR_OP_NOT_IN_SESSION MUST be returned.",
      "ja": "CB_SEQUENCEの動作は、要求が送信されるセッションのバックチャネルの動作アカウンティングを管理するために使用されます。内容には、この要求が属するセッションID、セッション要求コントロールおよび一度に一度だけセマンティクス、および返信キャッシュのサイズを調整するために使用されるSlot ID Maximaを交換します。各CB_COMPOUND要求では、CB_Sequenceは一度表示されなければならず、最初の操作でなければなりません。最初にCB_COMPOUNDの任意の位置にCB_Sequenceが見つかったときに、エラーNFS4ERR_SEQUENCE_POSを返す必要があります。他の操作がCB_COMPOUNDの最初の位置にある場合は、NFS4ERR_OP_NOT_IN_SESSISTを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 18.46.3 for a description of how slots are processed.",
      "ja": "スロットの処理方法については、セクション18.46.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If csa_cachethis is TRUE, then the server is requesting that the client cache the reply in the callback reply cache. The client MUST cache the reply (see Section 2.10.6.1.3).",
      "ja": "CSA_CACHETHISがTRUEの場合、サーバーはクライアントがコールバック応答キャッシュ内の応答をキャッシュするように要求しています。クライアントは返信をキャッシュする必要があります（セクション2.10.6.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The csa_referring_call_lists array is the list of COMPOUND requests, identified by session ID, slot ID, and sequence ID. These are requests that the client previously sent to the server. These previous requests created state that some operation(s) in the same CB_COMPOUND as the csa_referring_call_lists are identifying. A session ID is included because leased state is tied to a client ID, and a client ID can have multiple sessions. See Section 2.10.6.3.",
      "ja": "CSA_REFERRING_CALL_LISTS配列は、セッションID、スロットID、およびシーケンスIDによって識別される複合要求のリストです。これらは、クライアントが以前にサーバーに送信された要求です。これらの以前の要求は、CSA_REFERRING_CALL_LISTSと同じCB_COMPOUND内のいくつかの操作が識別されていることを作成しました。リース状態がクライアントIDに接続されているため、セッションIDが含まれており、クライアントIDに複数のセッションを持つことができます。セクション2.10.6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The value of the csa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.",
      "ja": "スロット上のキャッシュされたシーケンスIDに対するcsa_sequenceID引数の値は、3つのケースのいずれかに分類されます。"
    },
    {
      "indent": 3,
      "text": "* If the difference between csa_sequenceid and the client's cached sequence ID at the slot ID is two (2) or more, or if csa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the client MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "* スロットIDのCSA_SEQUENCEDIDとクライアントのキャッシュされたシーケンスIDの差が2つ以上の場合、またはCSA_SEQUENCEDIDがキャッシュされたシーケンスIDよりも小さい場合（符号なしシーケンスID値のラップアラウンド）、クライアントは返さなければなりません。NFS4ERR_SEQ_MISORDERED"
    },
    {
      "indent": 3,
      "text": "* If csa_sequenceid and the cached sequence ID are the same, this is a retry, and the client returns the CB_COMPOUND request's cached reply.",
      "ja": "* CSA_SEQUENCEIDとキャッシュされたシーケンスIDが同じ場合、これは再試行です。クライアントはCB_COMPOUNDリクエストのキャッシュ応答を返します。"
    },
    {
      "indent": 3,
      "text": "* If csa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot's sequence ID is incremented. The operations subsequent to CB_SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the CB_SEQUENCE reply in the slot, maintain the session's activity, and when the server receives the CB_SEQUENCE reply, renew the lease of state related to the client ID.",
      "ja": "* CSA_SequenceIDがキャッシュされたシーケンスIDより1大きい（ラップアラウンドのアカウンティング）場合、これは新しい要求であり、スロットのシーケンスIDがインクリメントされます。CB_Sequenceの後の動作があれば処理されます。他の操作がない場合は、他のすべてのエフェクトがスロット内のCB_Sequence Replyをキャッシュし、セッションのアクティビティを維持し、サーバーがCB_Sequence Replyを受信したときに、クライアントIDに関連する状態のリースを更新します。"
    },
    {
      "indent": 3,
      "text": "If the server reuses a slot ID and sequence ID for a completely different request, the client MAY treat the request as if it is a retry of what it has already executed. The client MAY however detect the server's illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "サーバーがまったく異なる要求のスロットIDとシーケンスIDを再利用した場合、クライアントはすでに実行されているものの再試行であるかのように要求を扱うことがあります。ただし、クライアントはサーバーの不正な再利用を検出し、NFS4ERR_SEQ_FALSE_RETRYを返します。"
    },
    {
      "indent": 3,
      "text": "If CB_SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change. See Section 2.10.6.1.3 for the conditions when the error NFS4ERR_RETRY_UNCACHED_REP might be returned.",
      "ja": "CB_Sequenceがエラーを返す場合、スロットの状態（シーケンスID、キャッシュされた応答）は変更してはなりません。エラーNFS4ERR_RETRY_UNCACHED_REPが返される可能性がある場合は、セクション2.10.6.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client returns two \"highest_slotid\" values: csr_highest_slotid and csr_target_highest_slotid. The former is the highest slot ID the client will accept in a future CB_SEQUENCE operation, and SHOULD NOT be less than the value of csa_highest_slotid (but see Section 2.10.6.1 for an exception). The latter is the highest slot ID the client would prefer the server use on a future CB_SEQUENCE operation.",
      "ja": "クライアントは、CSR_HIGHEST_SLOTIDとCSR_TARGET_HIGHEST_SLOTIDの2つの「hight_slotid」値を返します。前者は、クライアントが将来のCB_Sequence操作で受け入れる最も高いスロットIDです。後者は最高のスロットIDであると、クライアントは将来のCB_Sequence操作でサーバー使用を好むであろう。"
    },
    {
      "indent": 0,
      "text": "20.10. Operation 12: CB_WANTS_CANCELLED - Cancel Pending Delegation Wants",
      "ja": "20.10. 操作12：CB_WANTS_CANCELLED  - 保留中の委任が望みます"
    },
    {
      "indent": 0,
      "text": "20.10.1. ARGUMENT",
      "section_title": true,
      "ja": "20.10.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_WANTS_CANCELLED4args {\n        bool cwca_contended_wants_cancelled;\n        bool cwca_resourced_wants_cancelled;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.10.2. RESULT",
      "section_title": true,
      "ja": "20.10.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_WANTS_CANCELLED4res {\n        nfsstat4        cwcr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.10.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.10.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_WANTS_CANCELLED operation is used to notify the client that some or all of the wants it registered for recallable delegations and layouts have been cancelled.",
      "ja": "CB_WANTS_CANCELLED操作は、リコール可能な委任およびレイアウトに登録されている必要があることの一部または全部がキャンセルされたことをクライアントに通知するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If cwca_contended_wants_cancelled is TRUE, this indicates that the server will not be pushing to the client any delegations that become available after contention passes.",
      "ja": "cwca_contended_wantes_cancelledがtrueの場合、これは、サーバーが競合パスが経過した後に利用可能になる委任をクライアントにプッシュしないことを示しています。"
    },
    {
      "indent": 3,
      "text": "If cwca_resourced_wants_cancelled is TRUE, this indicates that the server will not notify the client when there are resources on the server to grant delegations or layouts.",
      "ja": "CWA_RESOURCED_WANTS_CANCELLEDがTRUEの場合、これは、代表団やレイアウトを許可するためにサーバー上のリソースがあるときにサーバーがクライアントに通知しないことを示しています。"
    },
    {
      "indent": 3,
      "text": "After receiving a CB_WANTS_CANCELLED operation, the client is free to attempt to acquire the delegations or layouts it was waiting for, and possibly re-register wants.",
      "ja": "CB_WANTS_CANCELLED操作を受信した後、クライアントは、待っている代表団やレイアウトの取得を自由に試み、必要に応じて望みます。"
    },
    {
      "indent": 0,
      "text": "20.10.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.10.4. 実装"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN, WANT_DELEGATION, or GET_DIR_DELEGATION request outstanding, when a CB_WANTS_CANCELLED is sent, the server may need to make clear to the client whether a promise to signal delegation availability happened before the CB_WANTS_CANCELLED and is thus covered by it, or after the CB_WANTS_CANCELLED in which case it was not covered by it. The server can make this distinction by putting the appropriate requests into the list of referring calls in the associated CB_SEQUENCE.",
      "ja": "クライアントが開いている、want_delegation、またはget_dir_delegation要求を未だに持っている場合、CB_WANTS_CANCELLEDが送信されると、サーバーはCB_WANTS_CANCELLEDの前に委任状の可用性が発生したという約束が発生し、したがってその後に覆われているかどうかをクライアントに明確にする必要があります。CB_WANTS_CANCELLEDその場合それがカバーされていませんでした。サーバーは、適切な要求を関連するCB_Sequence内の参照呼び出しのリストに入れることでこの区別を行うことができます。"
    },
    {
      "indent": 0,
      "text": "20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of Possible Lock Availability",
      "ja": "20.11. 操作13：CB_NOTIFY_LOCK  - 可能なロックの可用性をクライアントに通知する"
    },
    {
      "indent": 0,
      "text": "20.11.1. ARGUMENT",
      "section_title": true,
      "ja": "20.11.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_LOCK4args {\n    nfs_fh4     cnla_fh;\n    lock_owner4 cnla_lock_owner;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.11.2. RESULT",
      "section_title": true,
      "ja": "20.11.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_LOCK4res {\n        nfsstat4        cnlr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.11.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.11.3. description"
    },
    {
      "indent": 3,
      "text": "The server can use this operation to indicate that a byte-range lock for the given file and lock-owner, previously requested by the client via an unsuccessful LOCK operation, might be available.",
      "ja": "サーバーはこの操作を使用して、未実行のロック操作を介してクライアントから要求された特定のファイルとロックー所有者のバイトレンジロックが利用可能になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This callback is meant to be used by servers to help reduce the latency of blocking locks in the case where they recognize that a client that has been polling for a blocking byte-range lock may now be able to acquire the lock. If the server supports this callback for a given file, it MUST set the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to successful opens for that file. This does not commit the server to the use of CB_NOTIFY_LOCK, but the client may use this as a hint to decide how frequently to poll for locks derived from that open.",
      "ja": "このコールバックは、ブロッキングバイトレンジロックをポーリングしていたクライアントがロックを取得できることを認識している場合のブロッキングロックの待ち時間を減らすのに役立つように、サーバーによって使用されることを意味します。サーバーが特定のファイルに対してこのコールバックをサポートしている場合は、そのファイルの成功に応答するとOpen4_Result_May_notify_lockフラグを設定する必要があります。これはサーバーをcb_notify_lockの使用にコミットしませんが、クライアントはこれをヒントとして使用して、そのオープンから派生したロックのポーリングの頻度を決定することができます。"
    },
    {
      "indent": 3,
      "text": "If an OPEN operation results in an upgrade, in which the stateid returned has an \"other\" value matching that of a stateid already allocated, with a new \"seqid\" indicating a change in the lock being represented, then the value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to that new OPEN controls handling from that point going forward. When parallel OPENs are done on the same file and open-owner, the ordering of the \"seqid\" fields of the returned stateids (subject to wraparound) are to be used to select the controlling value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag.",
      "ja": "オープン操作にアップグレードが実行された場合、返されたStateIDが既に割り当てられているSTATEIDの「OTHER」値と一致する「その他」と一致する「SEQID」と表示されている新しい \"SEQID\"が表されます。その新しいオープンコントロールに応答すると、その時点からの処理が進みます。同じファイルと開いている所有者で並列開くと、返されたStateIDの \"seqid\"フィールドの順序（wraparoundの対象）を使用して、Open4_Result_May_notify_lockフラグの制御値を選択します。"
    },
    {
      "indent": 0,
      "text": "20.11.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.11.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT grant the byte-range lock to the client unless and until it receives a LOCK operation from the client. Similarly, the client receiving this callback cannot assume that it now has the lock or that a subsequent LOCK operation for the lock will be successful.",
      "ja": "クライアントからロック操作を受信するまで、サーバーはバイトレンジロックをクライアントに付与してはなりません。同様に、このコールバックを受け取っているクライアントは、ロックがロックされているか、ロックの後続のロック操作が成功すると想定できません。"
    },
    {
      "indent": 3,
      "text": "The server is not required to implement this callback, and even if it does, it is not required to use it in any particular case. Therefore, the client must still rely on polling for blocking locks, as described in Section 9.6.",
      "ja": "サーバーはこのコールバックを実装する必要はありません、そしてそれがそうであってもそれを使用する必要はありません。したがって、クライアントは、セクション9.6で説明されているように、ロックをブロックするためのポーリングに依存している必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, the client is not required to implement this callback, and even it does, is still free to ignore it. Therefore, the server MUST NOT assume that the client will act based on the callback.",
      "ja": "同様に、クライアントはこのコールバックを実装する必要はありません。また、まだ無視できることです。したがって、サーバーは、クライアントがコールバックに基づいて動作すると仮定してはいけません。"
    },
    {
      "indent": 0,
      "text": "20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify Client of Device ID Changes",
      "ja": "20.12. 操作14：CB_NOTIFY_DEVICEID  - デバイスIDの変更をクライアントに通知する"
    },
    {
      "indent": 0,
      "text": "20.12.1. ARGUMENT",
      "section_title": true,
      "ja": "20.12.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * Device notification types.\n */\nenum notify_deviceid_type4 {\n        NOTIFY_DEVICEID4_CHANGE = 1,\n        NOTIFY_DEVICEID4_DELETE = 2\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* For NOTIFY4_DEVICEID4_DELETE */\nstruct notify_deviceid_delete4 {\n        layouttype4     ndd_layouttype;\n        deviceid4       ndd_deviceid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* For NOTIFY4_DEVICEID4_CHANGE */\nstruct notify_deviceid_change4 {\n        layouttype4     ndc_layouttype;\n        deviceid4       ndc_deviceid;\n        bool            ndc_immediate;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_DEVICEID4args {\n        notify4 cnda_changes<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.12.2. RESULT",
      "section_title": true,
      "ja": "20.12.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_DEVICEID4res {\n        nfsstat4        cndr_status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.12.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.12.3. description"
    },
    {
      "indent": 3,
      "text": "The CB_NOTIFY_DEVICEID operation is used by the server to send notifications to clients about changes to pNFS device IDs. The registration of device ID notifications is optional and is done via GETDEVICEINFO. These notifications are sent over the backchannel once the original request has been processed on the server. The server will send an array of notifications, cnda_changes, as a list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.",
      "ja": "CB_NOTIFY_DEVICEID操作は、サーバーがPNFSデバイスIDへの変更に関する通知をクライアントに送信するために使用されます。デバイスID通知の登録はオプションであり、getDeviceInfoを介して行われます。元の要求がサーバー上で処理されると、これらの通知はBackChannelを介して送信されます。サーバーは、ビットマップと値のペアのリストとして、通知の配列CNDA_CHANGESを送信します。NFSv4.1のビットマップがどのように機能するかについては、3.3.7項を参照してください。"
    },
    {
      "indent": 3,
      "text": "As with CB_NOTIFY (Section 20.4.3), it is possible the server has more notifications than can fit in a CB_COMPOUND, thus requiring multiple CB_COMPOUNDs. Unlike CB_NOTIFY, serialization is not an issue because unlike directory entries, device IDs cannot be re-used after being deleted (Section 12.2.10).",
      "ja": "CB_NOTIFY（セクション20.4.3）と同様に、サーバーはCB_COMPOUNDに収まるよりも多くの通知を持っているため、複数のCB_COMOUNDSが必要です。CB_NOTIFYとは異なり、ディレクトリエントリとは異なり、デバイスIDを削除した後に再使用できないため、シリアル化は問題ではありません（セクション12.2.10）。"
    },
    {
      "indent": 3,
      "text": "All device ID notifications contain a device ID and a layout type. The layout type is necessary because two different layout types can share the same device ID, and the common device ID can have completely different mappings for each layout type.",
      "ja": "すべてのデバイスID通知には、デバイスIDとレイアウトタイプが含まれています。2つの異なるレイアウトタイプが同じデバイスIDを共有できるため、レイアウトタイプは必要であり、共通デバイスIDはレイアウトタイプごとに全く異なるマッピングを持つことができます。"
    },
    {
      "indent": 3,
      "text": "The server will send the following notifications:",
      "ja": "サーバーは次の通知を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY_DEVICEID4_CHANGE A previously provided device-ID-to-device-address mapping has changed and the client uses GETDEVICEINFO to obtain the updated mapping. The notification is encoded in a value of data type notify_deviceid_change4. This data type also contains a boolean field, ndc_immediate, which if TRUE indicates that the change will be enforced immediately, and so the client might not be able to complete any pending I/O to the device ID. If ndc_immediate is FALSE, then for an indefinite time, the client can complete pending I/O. After pending I/O is complete, the client SHOULD get the new device-ID-to-device-address mappings before sending new I/ O requests to the storage devices addressed by the device ID.",
      "ja": "Notify_DeviceID4_Change以前に提供されたデバイスID-to-device-addressマッピングが変更され、クライアントはgetDeviceInfoを使用して更新されたマッピングを取得します。通知はデータ型NOTIFY_DEVICEID_CHANGE4の値でエンコードされています。このデータ型には、BooleanフィールドNDC_IMMediateが含まれています。これはTRUEがすぐに変更されることを示しているので、クライアントはデバイスIDに保留中のI / Oを完了できない可能性があります。ndc_immediateがfalseである場合は、不定時間の場合、クライアントは保留中のI / Oを完了できます。保留中のI / Oが完了した後、クライアントは、デバイスIDによってアドレス指定されたストレージデバイスに新しいI / O要求を送信する前に、新しいデバイスID-Addressマッピングを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_DEVICEID_DELETE Deletes a device ID from the mappings. This notification MUST NOT be sent if the client has a layout that refers to the device ID. In other words, if the server is sending a delete device ID notification, one of the following is true for layouts associated with the layout type:",
      "ja": "NOTIFY4_DEVICEID_DELETEは、マッピングからデバイスIDを削除します。クライアントにデバイスIDを参照するレイアウトがある場合、この通知を送信しないでください。つまり、サーバーがDelete Device ID通知を送信している場合は、レイアウトタイプに関連付けられているレイアウトには次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "* The client never had a layout referring to that device ID.",
      "ja": "* クライアントはそのデバイスIDを参照するレイアウトを決してありませんでした。"
    },
    {
      "indent": 6,
      "text": "* The client has returned all layouts referring to that device ID.",
      "ja": "* クライアントは、そのデバイスIDを参照してすべてのレイアウトを返しました。"
    },
    {
      "indent": 6,
      "text": "* The server has revoked all layouts referring to that device ID.",
      "ja": "* サーバーは、そのデバイスIDを参照してすべてのレイアウトを取り消しました。"
    },
    {
      "indent": 6,
      "text": "The notification is encoded in a value of data type notify_deviceid_delete4. After a server deletes a device ID, it MUST NOT reuse that device ID for the same layout type until the client ID is deleted.",
      "ja": "通知はデータ型NOTIFY_DEVICEID_DELETE4の値でエンコードされています。サーバーがデバイスIDを削除した後、クライアントIDが削除されるまで、同じレイアウトタイプに対してそのデバイスIDを再利用しないでください。"
    },
    {
      "indent": 0,
      "text": "20.13. Operation 10044: CB_ILLEGAL - Illegal Callback Operation",
      "section_title": true,
      "ja": "20.13. 操作10044：CB_ILLEGAL  - 不正コールバック操作"
    },
    {
      "indent": 0,
      "text": "20.13.1. ARGUMENT",
      "section_title": true,
      "ja": "20.13.1. 引数"
    },
    {
      "indent": 11,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "20.13.2. RESULT",
      "section_title": true,
      "ja": "20.13.2. 結果"
    },
    {
      "indent": 3,
      "text": "/*\n * CB_ILLEGAL: Response for illegal operation numbers\n */\nstruct CB_ILLEGAL4res {\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.13.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.13.3. description"
    },
    {
      "indent": 3,
      "text": "This operation is a placeholder for encoding a result to handle the case of the server sending an operation code within CB_COMPOUND that is not defined in the NFSv4.1 specification. See Section 19.2.3 for more details.",
      "ja": "この操作は、NFSV4.1仕様で定義されていないCB_COMPOUND内の操作コードを送信するサーバーのケースを処理するための結果をエンコードするためのプレースホルダーです。詳細については19.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.",
      "ja": "CB_ILLEGAL4RESのステータスフィールドは、NFS4ERR_OP_ILLEGALに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "20.13.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.13.4. 実装"
    },
    {
      "indent": 3,
      "text": "A server will probably not send an operation with code OP_CB_ILLEGAL, but if it does, the response will be CB_ILLEGAL4res just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then an instance of data type CB_ILLEGAL4res will not be returned.",
      "ja": "サーバーはおそらくコードOP_CB_ILLEGALで操作を送信しませんが、そうであれば、その応答は他の無効な操作コードと同じようにCB_ILLEGAL4RESになります。クライアントがop_illegalではない不正なオペレーションコードを取得し、クライアントがXDRデコードフェーズ中に有効な操作コードをチェックした場合、データ型CB_ILLEGAL4RESのインスタンスは返されません。"
    },
    {
      "indent": 0,
      "text": "21. Security Considerations",
      "section_title": true,
      "ja": "21. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Historically, the authentication model of NFS was based on the entire machine being the NFS client, with the NFS server trusting the NFS client to authenticate the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client's source network address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same network address and port number to which the request was sent. While such a model is easy to implement and simple to deploy and use, it is unsafe. Thus, NFSv4.1 implementations are REQUIRED to support a security model that uses end-to-end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration is also given to the integrity and privacy of NFS requests and responses. The issues of end-to-end mutual authentication, integrity, and privacy are discussed in Section 2.2.1.1.1. There are specific considerations when using Kerberos V5 as described in Section 2.2.1.1.1.2.1.1.",
      "ja": "歴史的に、NFSの認証モデルは、NFSクライアントであるマシン全体に基づいていました.NFSサーバーは、NFSクライアントを信頼してエンドユーザーを認証します。 NFSサーバーは、クライアントのソースネットワークアドレスによって識別されるように、そのファイルを特定のクライアントにのみ共有しました。このモデルを考慮すると、auth_sys RPCセキュリティフレーバは、クライアントを使用してNFSサーバーにエンドユーザーを識別しました。 NFS応答を処理するとき、クライアントは、応答が要求が送信されたのと同じネットワークアドレスとポート番号から取得されたことを確認しました。そのようなモデルは実装が簡単で展開して使用するのが簡単ですが、安全ではありません。したがって、NFSV4.1の実装は、クライアント上のエンドユーザーが相互に認証されているエンドツーエンド認証を使用するセキュリティモデルをサポートする必要があります（ネットワーク上でパスワードやキーを公開しない暗号化方式を介して）。 NFSサーバー上のプリンシパルに。 NFS要求と応答の整合性とプライバシーについても考慮されています。エンドツーエンドの相互認証、整合性、およびプライバシーの問題については、2.2.1.1.1項で議論されています。セクション2.2.1.1.1.2.1.1に記載されているようにKerberos V5を使用する場合は具体的な考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Note that being REQUIRED to implement does not mean REQUIRED to use; AUTH_SYS can be used by NFSv4.1 clients and servers. However, AUTH_SYS is merely an OPTIONAL security flavor in NFSv4.1, and so interoperability via AUTH_SYS is not assured.",
      "ja": "実装に必要なことは、使用に必要な意味ではありません。AUTH_SYSは、NFSV4.1クライアントおよびサーバーで使用できます。ただし、auth_sysはNFSv4.1ではオプションのセキュリティフレーバーだけであり、auth_sysを介した相互運用性は保証されません。"
    },
    {
      "indent": 3,
      "text": "For reasons of reduced administration overhead, better performance, and/or reduction of CPU utilization, users of NFSv4.1 implementations might decline to use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the user vulnerable to a man-in-the-middle of the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are three operations in particular that warrant the implementation overriding user choices.",
      "ja": "管理オーバーヘッドを減らした理由から、CPU利用率の向上、パフォーマンスの向上、および/または削減のために、NFSV4.1の実装のユーザーは、各リモートプロシージャコールと応答で整合性保護を可能にするセキュリティメカニズムを使用することを遅くする可能性があります。完全性なしのメカニズムの使用は、ユーザーは、RPC要求および/または応答を変更するNFSクライアントおよびサーバーのMAN-IN-THE-MODDEのMAN-in-the-vere-the-the-vere-vise vere-vere-vise and serverに脆弱になります。実装は、より弱いセキュリティメカニズムを使用するためのオプションを自由に提供することができるが、特に実装をオーバーライドされたユーザの選択を保証するための3つの操作がある。"
    },
    {
      "indent": 3,
      "text": "* The first two such operations are SECINFO and SECINFO_NO_NAME. It is RECOMMENDED that the client send both operations such that they are protected with a security flavor that has integrity protection, such as RPCSEC_GSS with either the rpc_gss_svc_integrity or rpc_gss_svc_privacy service. Without integrity protection encapsulating SECINFO and SECINFO_NO_NAME and their results, a man-in-the-middle could modify results such that the client might select a weaker algorithm in the set allowed by the server, making the client and/or server vulnerable to further attacks.",
      "ja": "* 最初の2つのそのような操作はsecinfoとsecinfo_no_nameです。クライアントは、RPC_GSSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYサービスを持つRPCSEC_GSSなど、整合性保護を持つセキュリティ保護を持つセキュリティフレーバーで保護されるように、両方の操作を送信することをお勧めします。SecInfoとSecInfo_no_nameとその結果をカプセル化する整合性保護なしでは、クライアントがサーバーによって許可されているセット内の弱いアルゴリズムを選択し、クライアントやサーバーがさらなる攻撃に対して脆弱になる可能性がある結果を変更できます。。"
    },
    {
      "indent": 3,
      "text": "* The third operation that SHOULD use integrity protection is any GETATTR for the fs_locations and fs_locations_info attributes, in order to mitigate the severity of a man-in-the-middle attack. The attack has two steps. First the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations or fs_locations_info attributes, the attacker modifies the results to cause the client to migrate its traffic to a server controlled by the attacker. With integrity protection, this attack is mitigated.",
      "ja": "* Integrity Protectionを使用する必要がある3番目の操作は、中間攻撃の重大度を軽減するために、FS_LOCATIONSとFS_LOCATIONS_INFO属性の任意のGetAttrです。攻撃には2つのステップがあります。最初に、攻撃者は、NFS4ERR_Movedを返す操作の未保護されていない結果を変更します。第二に、クライアントがFS_LOCATIONSまたはFS_LOCATION_INFO属性のgetAttrでフォローアップすると、攻撃者は結果を修正してクライアントがそのトラフィックを攻撃者によって制御されるサーバーに移行させる。完全性保護では、この攻撃は軽減されます。"
    },
    {
      "indent": 3,
      "text": "Relative to previous NFS versions, NFSv4.1 has additional security considerations for pNFS (see Sections 12.9 and 13.12), locking and session state (see Section 2.10.8.3), and state recovery during grace period (see Section 8.4.2.1.1). With respect to locking and session state, if SP4_SSV state protection is being used, Section 2.10.10 has specific security considerations for the NFSv4.1 client and server.",
      "ja": "以前のNFSバージョンとの関連付けNFSV4.1には、PNFSに関する追加のセキュリティ上の考慮事項（セクション12.9と13.12を参照）、ロック、セッションの状態（セクション2.10.8.3を参照）、および猶予期間中の状態の回復（セクション8.4.2.1.1を参照）があります。。ロック状態とセッションの状態に関して、SP4_SSV状態保護が使用されている場合、セクション2.10.10にはNFSV4.1クライアントとサーバーに関する特定のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Security considerations for lock reclaim differ between the two different situations in which state reclaim is to be done. The server failure situation is discussed in Section 8.4.2.1.1, while the per-fs state reclaim done in support of migration/replication is discussed in Section 11.11.9.1.",
      "ja": "ロック再利用のためのセキュリティ上の考慮事項は、状態再利用が行われる2つの異なる状況によって異なります。サーバーの障害の状況については、セクション8.4.2.1.1で説明されていますが、移行/複製のサポートで行われたFS PER-FS状態の再利用はセクション11.11.9.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "The use of the multi-server namespace features described in Section 11 raises the possibility that requests to determine the set of network addresses corresponding to a given server might be interfered with or have their responses modified in flight. In light of this possibility, the following considerations should be noted:",
      "ja": "セクション11に記載されているマルチサーバネームスペース機能の使用は、所与のサーバに対応するネットワークアドレスのセットを決定する要求が、フライトで修正された応答を妨害することができるという可能性を高める。この可能性を考慮すると、以下の考慮事項を注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "* When DNS is used to convert server names to addresses and DNSSEC [29] is not available, the validity of the network addresses returned generally cannot be relied upon. However, when combined with a trusted resolver, DNS over TLS [30] and DNS over HTTPS [34] can be relied upon to provide valid address resolutions.",
      "ja": "* DNSを使用してサーバー名をアドレスに変換し、DNSSEC [29]は使用できません。返されたネットワークアドレスの有効性は、一般的には信頼できません。ただし、信頼できるレゾルバと組み合わせると、TLS [30]上のDNS [30]、[34]を介してDNS [34]は有効なアドレス解決を提供することに依存できます。"
    },
    {
      "indent": 6,
      "text": "In situations in which the validity of the provided addresses cannot be relied upon and the client uses RPCSEC_GSS to access the designated server, it is possible for mutual authentication to discover invalid server addresses as long as the RPCSEC_GSS implementation used does not use insecure DNS queries to canonicalize the hostname components of the service principal names, as explained in [28].",
      "ja": "指定されたアドレスの有効性が依存できず、クライアントが指定されたサーバーにアクセスするためにRPCSEC_GSSを使用している状況では、使用されているRPCSEC_GSS実装が不安定なDNSクエリを使用しない限り、無効なサーバーアドレスを検出することが可能です。[28]で説明されているように、サービスプリンシパル名のホスト名コンポーネントを正規化します。"
    },
    {
      "indent": 3,
      "text": "* The fetching of attributes containing file system location information SHOULD be performed using integrity protection. It is important to note here that a client making a request of this sort without using integrity protection needs be aware of the negative consequences of doing so, which can lead to invalid hostnames or network addresses being returned. These include cases in which the client is directed to a server under the control of an attacker, who might get access to data written or provide incorrect values for data read. In light of this, the client needs to recognize that using such returned location information to access an NFSv4 server without use of RPCSEC_GSS (i.e., by using AUTH_SYS) poses dangers as it can result in the client interacting with such an attacker-controlled server without any authentication facilities to verify the server's identity.",
      "ja": "* ファイルシステムの場所情報を含む属性のフェッチは、整合性保護を使用して実行されるべきです。ここでは、整合性保護を使用せずにこのソートを要求するクライアントが、そうすることの悪影響を認識することに注意することが重要です。これにより、無効なホスト名またはネットワークアドレスが返される可能性があります。これらには、クライアントが攻撃者の制御下でサーバーに向けられている場合を含み、データの書き込みまたはデータの読み取りに誤った値を提供することがあります。この点を考慮すると、クライアントは、このような返された位置情報を使用してRPCSEC_GSSを使用せずにNFSV4サーバにアクセスすること（すなわち、auth_sysを使用することによって）が、そのような攻撃者制御サーバと対話することができるように危険にさらされることを認識する必要がある。サーバーの身元を確認するための認証機能。"
    },
    {
      "indent": 3,
      "text": "* Despite the fact that it is a requirement that implementations provide \"support\" for use of RPCSEC_GSS, it cannot be assumed that use of RPCSEC_GSS is always available between any particular client-server pair.",
      "ja": "* 実装がRPCSEC_GSSの使用に対して「サポート」を提供するという要件であるにもかかわらず、RPCSEC_GSSの使用は特定のクライアントサーバーペア間で常に使用可能であると仮定することはできません。"
    },
    {
      "indent": 3,
      "text": "* When a client has the network addresses of a server but not the associated hostnames, that would interfere with its ability to use RPCSEC_GSS.",
      "ja": "* クライアントがサーバーのネットワークアドレスを持っているが関連するホスト名ではない場合、それはRPCSEC_GSSを使用する機能を妨害します。"
    },
    {
      "indent": 3,
      "text": "In light of the above, a server SHOULD present file system location entries that correspond to file systems on other servers using a hostname. This would allow the client to interrogate the fs_locations on the destination server to obtain trunking information (as well as replica information) using integrity protection, validating the name provided while assuring that the response has not been modified in flight.",
      "ja": "上記の点を考慮して、サーバは、ホスト名を使用して他のサーバ上のファイルシステムに対応するファイルシステムの場所エントリを提示する必要があります。これにより、クライアントは整合性保護を使用してトランキング情報（およびレプリカ情報）を取得するために、宛先サーバ上のFS_LOCATIONを問い合わせることができ、応答が修正されていないことを保証している間に提供された名前を検証します。"
    },
    {
      "indent": 3,
      "text": "When RPCSEC_GSS is not available on a server, the client needs to be aware of the fact that the location entries are subject to modification in flight and so cannot be relied upon. In the case of a client being directed to another server after NFS4ERR_MOVED, this could vitiate the authentication provided by the use of RPCSEC_GSS on the designated destination server. Even when RPCSEC_GSS authentication is available on the destination, the server might still properly authenticate as the server to which the client was erroneously directed. Without a way to decide whether the server is a valid one, the client can only determine, using RPCSEC_GSS, that the server corresponds to the name provided, with no basis for trusting that server. As a result, the client SHOULD NOT use such unverified location entries as a basis for migration, even though RPCSEC_GSS might be available on the destination.",
      "ja": "RPCSEC_GSSがサーバー上で利用できない場合、クライアントは、場所エントリがフライト内の変更の対象となる事実を認識する必要があります。NFS4ERR_MOVEDの後にクライアントが別のサーバーに向けられている場合、これは指定された宛先サーバー上のRPCSEC_GSSの使用によって提供される認証をバイトすることができます。宛先でRPCSEC_GSS認証が利用可能であっても、サーバーはクライアントが誤って指示されたサーバーとして正しく認証される可能性があります。サーバーが有効なものであるかどうかを判断する方法がない場合、クライアントはRPCSEC_GSSを使用して、サーバーが提供された名前に対応し、そのサーバーを信頼するための基本なしで決定できます。その結果、rpcsec_gssが宛先で利用できる場合でも、クライアントはそのような未確認の場所エントリを移行の基礎として使用しないでください。"
    },
    {
      "indent": 3,
      "text": "When a file system location attribute is fetched upon connecting with an NFS server, it SHOULD, as stated above, be done with integrity protection. When this not possible, it is generally best for the client to ignore trunking and replica information or simply not fetch the location information for these purposes.",
      "ja": "NFSサーバと接続するとファイルシステムの場所属性がフェッチされると、上述のように、整合性保護を実行する必要があります。これが不可能な場合は、クライアントがトランキングおよびレプリカ情報を無視するのに最適であるか、またはこれらの目的のために位置情報を取得しないことが最善です。"
    },
    {
      "indent": 3,
      "text": "When location information cannot be verified, it can be subjected to additional filtering to prevent the client from being inappropriately directed. For example, if a range of network addresses can be determined that assure that the servers and clients using AUTH_SYS are subject to the appropriate set of constraints (e.g., physical network isolation, administrative controls on the operating systems used), then network addresses in the appropriate range can be used with others discarded or restricted in their use of AUTH_SYS.",
      "ja": "位置情報を検証できない場合は、クライアントが不適切に向けられないようにするために追加のフィルタリングを受けることができます。たとえば、AUTH_SYSを使用しているサーバーとクライアントに適切な制約セットのセット（たとえば、使用されているオペレーティングシステムの管理コントロールなど）に対象となるネットワークアドレスの範囲を決定できる場合は、次のようにします。AUTH_SYSの使用において廃棄または制限された他の人と適切な範囲を使用することができます。"
    },
    {
      "indent": 3,
      "text": "To summarize considerations regarding the use of RPCSEC_GSS in fetching location information, we need to consider the following possibilities for requests to interrogate location information, with interrogation approaches on the referring and destination servers arrived at separately:",
      "ja": "RPCSEC_GSSの使用に関する考慮事項位置情報を取得する際の考慮事項は、参照情報を別々に到着したところに尋問された照会アプローチを考慮して、場所情報を問い合わせる要求について次のような可能性を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The use of integrity protection is RECOMMENDED in all cases, since the absence of integrity protection exposes the client to the possibility of the results being modified in transit.",
      "ja": "* 完全性保護がない場合は、積極的保護が存在しないため、輸送中の結果が変更される可能性にさらされるため、完全性保護の使用をお勧めします。"
    },
    {
      "indent": 3,
      "text": "* The use of requests issued without RPCSEC_GSS (i.e., using AUTH_SYS, which has no provision to avoid modification of data in flight), while undesirable and a potential security exposure, may not be avoidable in all cases. Where the use of the returned information cannot be avoided, it is made subject to filtering as described above to eliminate the possibility that the client would treat an invalid address as if it were a NFSv4 server. The specifics will vary depending on the degree of network isolation and whether the request is to the referring or destination servers.",
      "ja": "* RPCSEC_GSSなしで発行された要求の使用は、望ましくなく潜在的なセキュリティ露出がすべての場合において回避できないかもしれない。返された情報の使用を回避することができない場合、それは、クライアントがNFSv4サーバであるかのように無効なアドレスを扱う可能性を排除するために、上述のようにフィルタリングの対象となる。この指定は、ネットワークの分離の程度とリクエストが参照サーバーまたは宛先サーバーへのものであるかによって異なります。"
    },
    {
      "indent": 3,
      "text": "Even if such requests are not interfered with in flight, it is possible for a compromised server to direct the client to use inappropriate servers, such as those under the control of the attacker. It is not clear that being directed to such servers represents a greater threat to the client than the damage that could be done by the compromised server itself. However, it is possible that some sorts of transient server compromises might be exploited to direct a client to a server capable of doing greater damage over a longer time. One useful step to guard against this possibility is to issue requests to fetch location data using RPCSEC_GSS, even if no mapping to an RPCSEC_GSS principal is available. In this case, RPCSEC_GSS would not be used, as it typically is, to identify the client principal to the server, but rather to make sure (via RPCSEC_GSS mutual authentication) that the server being contacted is the one intended.",
      "ja": "そのような要求が飛行中に干渉されていなくても、攻撃者の制御下にあるもののような不適切なサーバーを使用するようにクライアントに指示することが可能である。そのようなサーバーに向けられていることは明確ではありませんが、侵入先のサーバー自体によって行われる可能性がある損害よりも顧客に対する脅威を表すことは明らかではありません。しかしながら、より長い時間にわたってより大きなダメージを与えることができるサーバにクライアントを指示するためにいくつかの種類の一種のサーバの妥協が悪用される可能性がある。この可能性を守るための1つの有用なステップは、RPCSEC_GSSプリンシパルへのマッピングが利用可能であっても、RPCSEC_GSSを使用して位置データをフェッチする要求を発行することです。この場合、RPCSEC_GSSは通常、サーバーへのクライアントプリンシパルを識別するのではなく、サーバーが接続されているサーバーが意図されているものであることを確認する（rpcsec_gss相互認証を介して）rpcsec_gsです。"
    },
    {
      "indent": 3,
      "text": "Similar considerations apply if the threat to be avoided is the redirection of client traffic to inappropriate (i.e., poorly performing) servers. In both cases, there is no reason for the information returned to depend on the identity of the client principal requesting it, while the validity of the server information, which has the capability to affect all client principals, is of considerable importance.",
      "ja": "回避されるべき脅威が、不適切（すなわち、実行不良）サーバへのクライアントトラフィックのリダイレクトである場合も同様の考察が適用される。どちらの場合も、すべてのクライアントのプリンシパルに影響を与える機能を備えたサーバー情報の有効性がかなり重要ですが、それを要求するクライアントプリンシパルの識別情報に依存する理由はありません。"
    },
    {
      "indent": 0,
      "text": "22. IANA Considerations",
      "section_title": true,
      "ja": "22. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section uses terms that are defined in [63].",
      "ja": "このセクションでは、[63]で定義されている用語を使用します。"
    },
    {
      "indent": 0,
      "text": "22.1. IANA Actions",
      "section_title": true,
      "ja": "22.1. IANAの行動"
    },
    {
      "indent": 3,
      "text": "This update does not require any modification of, or additions to, registry entries or registry rules associated with NFSv4.1. However, since this document obsoletes RFC 5661, IANA has updated all registry entries and registry rules references that point to RFC 5661 to point to this document instead.",
      "ja": "このアップデートでは、NFSv4.1に関連付けられているレジストリエントリまたは追加のレジストリルールの変更は不要です。ただし、この文書はRFC 5661を廃止されているため、IANAは代わりにこのドキュメントを指すようにRFC 5661を指すすべてのレジストリエントリとレジストリルールの参照を更新しました。"
    },
    {
      "indent": 3,
      "text": "Previous actions by IANA related to NFSv4.1 are listed in the remaining subsections of Section 22.",
      "ja": "NFSV4.1に関連するIANAによる以前の行動は、セクション22の残りのサブセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "22.2. Named Attribute Definitions",
      "section_title": true,
      "ja": "22.2. 名前付き属性定義"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Named Attribute Definitions Registry\".",
      "ja": "IANAは、 \"NFSV4という名前の属性定義レジストリ\"というレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol supports the association of a file with zero or more named attributes. The namespace identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the namespace for these file attributes. The IANA registry promotes interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.",
      "ja": "NFSv4.1プロトコルは、ファイルの関連付けを0個以上の名前付き属性の関連付けをサポートしています。これらの属性の名前空間識別子は文字列名として定義されています。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義しません。IANAレジストリは、共通の利益が存在する相互運用性を推進しています。アプリケーション開発者は必要に応じて属性を定義して使用することが許可されていますが、それらは属性をIANAに登録することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Such registered named attributes are presumed to apply to all minor versions of NFSv4, including those defined subsequently to the registration. If the named attribute is intended to be limited to specific minor versions, this will be clearly stated in the registry's assignment.",
      "ja": "そのような登録された名前付き属性は、登録に続いて定義されたものを含む、すべてのマイナーバージョンのNFSV4に適用されると推定されます。名前付き属性が特定のマイナーバージョンに制限されることを意図している場合、これはレジストリの割り当てに明確に記載されています。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a First Come First Served basis, per Section 4.4 of [63]. The policy for each assignment is Specification Required, per Section 4.6 of [63].",
      "ja": "レジストリへのすべての割り当ては、[63]のセクション4.4あたりの最初のサービスベースで行われます。各課題の方針は、[63]のセクション4.6ごとに必要な仕様です。"
    },
    {
      "indent": 3,
      "text": "Under the NFSv4.1 specification, the name of a named attribute can in theory be up to 2^(32) - 1 bytes in length, but in practice NFSv4.1 clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a named attribute that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use and Standards Action, the prefixes of \"EXPE\" and \"STDS\" are Reserved. The named attribute with a zero-length name is Reserved.",
      "ja": "NFSV4.1仕様の下では、参照された属性の名前は、理論的には最大2 ^（32） -  1バイトの長さですが、実際にはNFSV4.1クライアントとサーバーは長い文字列を処理できません。IANAは、128 UTF-8文字を超える名前付き属性を使用して割り当て要求を拒否する必要があります。IESGに実験的な使用と標準の行動の課題の設定の柔軟性を与えるために、「expe」と「stds」の接頭辞は予約されています。長さゼロの名前を持つ名前付き属性は予約されています。"
    },
    {
      "indent": 3,
      "text": "The prefix \"PRIV\" is designated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA's registry should use the prefix \"PRIV\" in all of its named attributes.",
      "ja": "プレフィックス「Priv」は私的使用のために指定されています。IANAのレジストリでの割り当てと競合するリスクなしで未登録の名前付き属性を使用したいサイトは、その名前付き属性すべてのプレフィックス \"Priv\"を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because some NFSv4.1 clients and servers have case-insensitive semantics, the fifteen additional lower case and mixed case permutations of each of \"EXPE\", \"PRIV\", and \"STDS\" are Reserved (e.g., \"expe\", \"expE\", \"exPe\", etc. are Reserved). Similarly, IANA must not allow two assignments that would conflict if both named attributes were converted to a common case.",
      "ja": "いくつかのNFSV4.1クライアントとサーバーには大文字と小文字が区別されないセマンティクスがあるため、15回の追加の小文字と「EXPE」、「PRIV」、および「STDS」のそれぞれの大文字と小文字混合順序が予約されています（例：「expe」、「expe」、 \"expe\"などは予約されています）。同様に、両方の名前付き属性が一般的なケースに変換された場合に競合する2つの割り当てを許可してはいけません。"
    },
    {
      "indent": 3,
      "text": "The registry of named attributes is a list of assignments, each containing three fields for each assignment.",
      "ja": "名前付き属性のレジストリは、割り当てのリストです。それぞれは、割り当てごとに3つのフィールドを含みます。"
    },
    {
      "indent": 3,
      "text": "1. A US-ASCII string name that is the actual name of the attribute. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.",
      "ja": "1. 属性の実際の名前であるUS-ASCII文字列名。この名前は一意である必要があります。この文字列名は1から128のUTF-8文字です。"
    },
    {
      "indent": 3,
      "text": "2. A reference to the specification of the named attribute. The reference can consume up to 256 bytes (or more if IANA permits).",
      "ja": "2. 名前付き属性の指定への参照。参照は、最大256バイト（IANAが許す場合はそれ以上）を消費できます。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3. 登録者の接触点。連絡先は、最大256バイト（IANAが許す場合はそれ以上）を消費できます。"
    },
    {
      "indent": 0,
      "text": "22.2.1. Initial Registry",
      "section_title": true,
      "ja": "22.2.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "初期レジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.2.2. Updating Registrations",
      "section_title": true,
      "ja": "22.2.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is always permitted to update the point of contact field. Any other change will require Expert Review or IESG Approval.",
      "ja": "登録者は常に連絡先フィールドのポイントを更新することを許可されています。その他の変更では、エキスパートレビューまたはIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.3. Device ID Notifications",
      "section_title": true,
      "ja": "22.3. デバイスID通知"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Device ID Notifications Registry\".",
      "ja": "IANAは、 \"NFSV4デバイスID通知レジストリ\"と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The potential exists for new notification types to be added to the CB_NOTIFY_DEVICEID operation (see Section 20.12). This can be done via changes to the operations that register notifications, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from the IETF. Another way to add a notification is to specify a new layout type (see Section 22.5).",
      "ja": "CB_NOTIFY_DEVICEID操作に追加する新しい通知タイプには存在します（セクション20.12を参照）。これは、通知を登録する操作への変更、またはNFSv4に新しい操作を追加することによって行うことができます。これにはNFSV4の新しいマイナーバージョンが必要であり、IETFから標準トラック文書が必要です。通知を追加するもう1つの方法は、新しいレイアウトタイプを指定することです（セクション22.5を参照）。"
    },
    {
      "indent": 3,
      "text": "Hence, all assignments to the registry are made on a Standards Action basis per Section 4.6 of [63], with Expert Review required.",
      "ja": "したがって、レジストリへのすべての割り当ては[63]のセクション4.6の標準アクションベースで行われ、エキスパートレビューが必要です。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields per assignment.",
      "ja": "レジストリは割り当てのリストです。それぞれが代入ごとに5つのフィールドを含む。"
    },
    {
      "indent": 3,
      "text": "1. The name of the notification type. This name must have the prefix \"NOTIFY_DEVICEID4_\". This name must be unique.",
      "ja": "1. 通知タイプの名前。この名前には「Notify_DeviceID4_」が付いている必要があります。この名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the notification. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^(32)-1, and should be the next available value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the notification type and its value are added to the NFSv4.1 notify_deviceid_type4 enumerated data type in the NFSv4.1 XDR description [10], the result continues to be a valid XDR description.",
      "ja": "2. 通知の値。IANAはこの番号を割り当て、登録者からの要求は実際の値ではなくTBD1を使用します。IANAは、2 ^（32）-1以下にすることができる整数を使用しなければならず、次に使用可能な値にする必要があります。割り当てられた値は一意である必要があります。指定されたエキスパートを使用して、通知タイプの名前とその値がNFSV4.1 XDRの説明[10]でNFSV4.1 Notify_DeviceId_Type4列挙データ型に追加された場合、結果は有効なXDRの説明になります。。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.",
      "ja": "3. 標準は通知を説明するRFCを追跡します。RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the notification. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "4. RFCが通知を紹介する方法。これは単一のUS-ASCII値で示されています。値がnの場合、NFSV4プロトコルへのマイナーなリビジョンを意味します。値がLの場合は、新しいPNFSレイアウトタイプを意味します。他の値はIESGの承認で使用できます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5. 通知を使用することが許可されているNFSV4のマイナーバージョン。これらは数値である間、IANAはそれらを割り当てて割り当てません。関連するRFCの著者は、IESG承認を割り当てます。NFSV4承認済みのNFSV4の新しいマイナーバージョンがあるたびに、指定されたエキスパートは必要に応じて推奨された更新を行うためにレジストリを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "22.3.1. Initial Registry",
      "section_title": true,
      "ja": "22.3.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 25. Note that the next available value is zero.",
      "ja": "初期レジストリは表25にあります。次の利用可能な値はゼロです。"
    },
    {
      "indent": 3,
      "text": "+=========================+=======+==========+=====+================+\n| Notification Name       | Value | RFC      | How | Minor Versions |\n+=========================+=======+==========+=====+================+\n| NOTIFY_DEVICEID4_CHANGE | 1     | RFC      | N   | 1              |\n|                         |       | 8881     |     |                |\n+-------------------------+-------+----------+-----+----------------+\n| NOTIFY_DEVICEID4_DELETE | 2     | RFC      | N   | 1              |\n|                         |       | 8881     |     |                |\n+-------------------------+-------+----------+-----+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 25: Initial Device ID Notification Assignments",
      "ja": "表25：初期デバイスID通知割り当て"
    },
    {
      "indent": 0,
      "text": "22.3.2. Updating Registrations",
      "section_title": true,
      "ja": "22.3.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新には、指定された専門家のアドバイスに関するIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.4. Object Recall Types",
      "section_title": true,
      "ja": "22.4. オブジェクトリコールタイプ"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Recallable Object Types Registry\".",
      "ja": "IANAは、 \"NFSV4リコールオブジェクト型レジストリ\"というレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The potential exists for new object types to be added to the CB_RECALL_ANY operation (see Section 20.6). This can be done via changes to the operations that add recallable types, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from IETF. Another way to add a new recallable object is to specify a new layout type (see Section 22.5).",
      "ja": "CB_RECALL_ANY操作に追加する新しいオブジェクトタイプに存在する電位が存在します（セクション20.6を参照）。これは、リコール可能な型を追加する操作への変更、またはNFSv4に新しい操作を追加することによって行うことができます。これにはNFSV4の新しいマイナーバージョンが必要であり、IETFから標準トラック文書が必要です。新しいリコール可能なオブジェクトを追加するもう1つの方法は、新しいレイアウトタイプを指定することです（セクション22.5を参照）。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a Standards Action basis per Section 4.9 of [63], with Expert Review required.",
      "ja": "レジストリへのすべての割り当ては、[63]のセクション4.9あたりの標準アクションベースで行われ、エキスパートレビューが必要です。"
    },
    {
      "indent": 3,
      "text": "Recallable object types are 32-bit unsigned numbers. There are no Reserved values. Values in the range 12 through 15, inclusive, are designated for Private Use.",
      "ja": "リコール可能なオブジェクトタイプは32ビットの符号なし番号です。予約済みの値はありません。12から15の範囲の値は、包括的な使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields per assignment.",
      "ja": "レジストリは割り当てのリストです。それぞれが代入ごとに5つのフィールドを含む。"
    },
    {
      "indent": 3,
      "text": "1. The name of the recallable object type. This name must have the prefix \"RCA4_TYPE_MASK_\". The name must be unique.",
      "ja": "1. リコール可能なオブジェクトタイプの名前。この名前には「rca4_type_mask_」が付いている必要があります。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the recallable object type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^(32)-1, and should be the next available value. The value must be unique. A Designated Expert must be used to ensure that when the name of the recallable type and its value are added to the NFSv4 XDR description [10], the result continues to be a valid XDR description.",
      "ja": "2. リコール可能なオブジェクトタイプの値。IANAはこの番号を割り当て、登録者からの要求は実際の値ではなくTBD1を使用します。IANAは、2 ^（32）-1以下にすることができる整数を使用しなければならず、次に使用可能な値にする必要があります。値は一意でなければなりません。指定されたエキスパートを使用して、リコール可能なタイプの名前とその値がNFSV4 XDRの説明[10]に追加されたときに、結果が有効なXDRの説明になります。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the recallable object type. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.",
      "ja": "3. 標準はリコール可能なオブジェクトタイプを記述するRFCを追跡します。RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the recallable object type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "4. RFCがリコール可能なオブジェクトタイプをどのように導入するか。これは単一のUS-ASCII値で示されています。値がnの場合、NFSV4プロトコルへのマイナーなリビジョンを意味します。値がLの場合は、新しいPNFSレイアウトタイプを意味します。他の値はIESGの承認で使用できます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the recallable object type. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5. リコール可能なオブジェクトタイプを使用することが許可されているNFSV4のマイナーバージョン。これらは数値である間、IANAはそれらを割り当てて割り当てません。関連するRFCの著者は、IESG承認を割り当てます。NFSV4承認済みのNFSV4の新しいマイナーバージョンがあるたびに、指定されたエキスパートは必要に応じて推奨された更新を行うためにレジストリを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "22.4.1. Initial Registry",
      "section_title": true,
      "ja": "22.4.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 26. Note that the next available value is five.",
      "ja": "最初のレジストリは表26にあります。次の利用可能な値は5です。"
    },
    {
      "indent": 5,
      "text": "+===============================+=======+======+=====+==========+\n| Recallable Object Type Name   | Value | RFC  | How | Minor    |\n|                               |       |      |     | Versions |\n+===============================+=======+======+=====+==========+\n| RCA4_TYPE_MASK_RDATA_DLG      | 0     | RFC  | N   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_WDATA_DLG      | 1     | RFC  | N   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_DIR_DLG        | 2     | RFC  | N   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_FILE_LAYOUT    | 3     | RFC  | N   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_BLK_LAYOUT     | 4     | RFC  | L   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_OBJ_LAYOUT_MIN | 8     | RFC  | L   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+\n| RCA4_TYPE_MASK_OBJ_LAYOUT_MAX | 9     | RFC  | L   | 1        |\n|                               |       | 8881 |     |          |\n+-------------------------------+-------+------+-----+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 26: Initial Recallable Object Type Assignments",
      "ja": "表26：リコールの初期オブジェクトタイプの割り当て"
    },
    {
      "indent": 0,
      "text": "22.4.2. Updating Registrations",
      "section_title": true,
      "ja": "22.4.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新には、指定された専門家のアドバイスに関するIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.5. Layout Types",
      "section_title": true,
      "ja": "22.5. レイアウトの種類"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"pNFS Layout Types Registry\".",
      "ja": "IANAは \"PNFSレイアウト型レジストリ\"というレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a Standards Action basis, with Expert Review required.",
      "ja": "レジストリへのすべての割り当ては、標準アクションベースで行われ、エキスパートレビューが必要です。"
    },
    {
      "indent": 3,
      "text": "Layout types are 32-bit numbers. The value zero is Reserved. Values in the range 0x80000000 to 0xFFFFFFFF inclusive are designated for Private Use. IANA will assign numbers from the range 0x00000001 to 0x7FFFFFFF inclusive.",
      "ja": "レイアウトタイプは32ビット数です。値ゼロは予約されています。0x80000000から0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFIANAは0x00000001の範囲から0x7FFFFFFFFを含む数字を割り当てます。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields.",
      "ja": "レジストリは、それぞれ5つのフィールドを含む割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the layout type. This name must have the prefix \"LAYOUT4_\". The name must be unique.",
      "ja": "1. レイアウトタイプの名前。この名前には「layout4_」の接頭辞が必要です。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the layout type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the layout type and its value are added to the NFSv4.1 layouttype4 enumerated data type in the NFSv4.1 XDR description [10], the result continues to be a valid XDR description.",
      "ja": "2. レイアウトタイプの値。IANAはこの番号を割り当て、登録者からの要求は実際の値ではなくTBD1を使用します。割り当てられた値は一意である必要があります。NFSV4.1 XDR説明[10]では、レイアウトタイプの名前とその値がNFSV4.1 LayoutType4列挙型データ型に追加されたときに指定されたエキスパートを使用する必要があります[10]、結果は有効なXDR記述になります。。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number. Collectively, the RFC(s) must adhere to the guidelines listed in Section 22.5.3.",
      "ja": "3. 標準は通知を説明するRFCを追跡します。RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。まとめると、RFCは、セクション22.5.3に記載されているガイドラインに従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the layout type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "4. RFCがレイアウトタイプをどのように導入するか。これは単一のUS-ASCII値で示されています。値がnの場合、NFSV4プロトコルへのマイナーなリビジョンを意味します。値がLの場合は、新しいPNFSレイアウトタイプを意味します。他の値はIESGの承認で使用できます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5. 通知を使用することが許可されているNFSV4のマイナーバージョン。これらは数値である間、IANAはそれらを割り当てて割り当てません。関連するRFCの著者は、IESG承認を割り当てます。NFSV4承認済みのNFSV4の新しいマイナーバージョンがあるたびに、指定されたエキスパートは必要に応じて推奨された更新を行うためにレジストリを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "22.5.1. Initial Registry",
      "section_title": true,
      "ja": "22.5.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 27.",
      "ja": "最初のレジストリは表27にあります。"
    },
    {
      "indent": 4,
      "text": "+=======================+=======+==========+=====+================+\n| Layout Type Name      | Value | RFC      | How | Minor Versions |\n+=======================+=======+==========+=====+================+\n| LAYOUT4_NFSV4_1_FILES | 0x1   | RFC 8881 | N   | 1              |\n+-----------------------+-------+----------+-----+----------------+\n| LAYOUT4_OSD2_OBJECTS  | 0x2   | RFC 5664 | L   | 1              |\n+-----------------------+-------+----------+-----+----------------+\n| LAYOUT4_BLOCK_VOLUME  | 0x3   | RFC 5663 | L   | 1              |\n+-----------------------+-------+----------+-----+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 27: Initial Layout Type Assignments",
      "ja": "表27：初期レイアウト型の割り当て"
    },
    {
      "indent": 0,
      "text": "22.5.2. Updating Registrations",
      "section_title": true,
      "ja": "22.5.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新には、指定された専門家のアドバイスに関するIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.5.3. Guidelines for Writing Layout Type Specifications",
      "section_title": true,
      "ja": "22.5.3. レイアウト型の仕様書のガイドライン"
    },
    {
      "indent": 3,
      "text": "The author of a new pNFS layout specification must follow these steps to obtain acceptance of the layout type as a Standards Track RFC:",
      "ja": "新しいPNFSレイアウト仕様の作成者は、レイアウトタイプの承認を標準トラックRFCとして入手するには、次の手順に従ってください。"
    },
    {
      "indent": 3,
      "text": "1. The author devises the new layout specification.",
      "ja": "1. 著者は新しいレイアウト仕様を考案します。"
    },
    {
      "indent": 3,
      "text": "2. The new layout type specification MUST, at a minimum:",
      "ja": "2. 新しいレイアウト型の指定は、最低で、次のようにしてください。"
    },
    {
      "indent": 7,
      "text": "* Define the contents of the layout-type-specific fields of the following data types:",
      "ja": "* 次のデータ型のレイアウト型固有のフィールドの内容を定義します。"
    },
    {
      "indent": 10,
      "text": "- the da_addr_body field of the device_addr4 data type;",
      "ja": "- DEVICE_ADDR4データ型のDA_ADDR_BODYフィールド。"
    },
    {
      "indent": 10,
      "text": "- the loh_body field of the layouthint4 data type;",
      "ja": "- LayouseInt4データ型のLOH_BODYフィールド。"
    },
    {
      "indent": 10,
      "text": "- the loc_body field of layout_content4 data type (which in turn is the lo_content field of the layout4 data type);",
      "ja": "- Layout_Content4データ型のloc_bodyフィールド（順番にLayout4データ型のLO_Contentフィールド）。"
    },
    {
      "indent": 10,
      "text": "- the lou_body field of the layoutupdate4 data type;",
      "ja": "- LayoutUpdate4データ型のlou_bodyフィールド。"
    },
    {
      "indent": 7,
      "text": "* Describe or define the storage access protocol used to access the storage devices.",
      "ja": "* ストレージデバイスにアクセスするために使用されるストレージアクセスプロトコルを説明または定義します。"
    },
    {
      "indent": 7,
      "text": "* Describe whether revocation of layouts is supported.",
      "ja": "* レイアウトの失効がサポートされているかどうかを説明してください。"
    },
    {
      "indent": 7,
      "text": "* At a minimum, describe the methods of recovery from:",
      "ja": "* 最低限、回復の方法を説明します。"
    },
    {
      "indent": 10,
      "text": "1. Failure and restart for client, server, storage device.",
      "ja": "1. クライアント、サーバー、ストレージデバイスの失敗と再起動。"
    },
    {
      "indent": 10,
      "text": "2. Lease expiration from perspective of the active client, server, storage device.",
      "ja": "2. アクティブなクライアント、サーバー、ストレージデバイスの観点から有効期限が切れます。"
    },
    {
      "indent": 10,
      "text": "3. Loss of layout state resulting in fencing of client access to storage devices (for an example, see Section 12.7.3).",
      "ja": "3. レイアウト状態の損失により、ストレージデバイスへのクライアントアクセスのフェンシングが発生します（例は、セクション12.7.3を参照）。"
    },
    {
      "indent": 7,
      "text": "* Include an IANA considerations section, which will in turn include:",
      "ja": "* IANAの考慮事項セクションを含みます。これは次のとおりです。"
    },
    {
      "indent": 10,
      "text": "- A request to IANA for a new layout type per Section 22.5.",
      "ja": "- セクション22.5あたりの新しいレイアウトタイプのためのIANAへの要求。"
    },
    {
      "indent": 10,
      "text": "- A list of requests to IANA for any new recallable object types for CB_RECALL_ANY; each entry is to be presented in the form described in Section 22.4.",
      "ja": "- CB_RECALL_ANYの新しいリコール可能なオブジェクト・タイプについて、IANAへの要求のリスト。各エントリは、セクション22.4に記載されている形式で表示されます。"
    },
    {
      "indent": 10,
      "text": "- A list of requests to IANA for any new notification values for CB_NOTIFY_DEVICEID; each entry is to be presented in the form described in Section 22.3.",
      "ja": "- cb_notify_deviceIdの新しい通知値についてIANAへの要求のリスト。各エントリは、セクション22.3に記載されている形式で表示されます。"
    },
    {
      "indent": 7,
      "text": "* Include a security considerations section. This section MUST explain how the NFSv4.1 authentication, authorization, and access-control models are preserved. That is, if a metadata server would restrict a READ or WRITE operation, how would pNFS via the layout similarly restrict a corresponding input or output operation?",
      "ja": "* セキュリティ上の考慮事項を含めます。このセクションでは、NFSv4.1認証、承認モデル、およびアクセス制御モデルがどのように保持されるかを説明する必要があります。つまり、メタデータサーバーが読み取り操作または書き込み操作を制限すると、レイアウトを介してPNFSがどれほどPNFSが同様に対応する入力または出力操作を制限しますか？"
    },
    {
      "indent": 3,
      "text": "3. The author documents the new layout specification as an Internet-Draft.",
      "ja": "3. 作者は新しいレイアウト仕様をインターネットドラフトとして文書化しています。"
    },
    {
      "indent": 3,
      "text": "4. The author submits the Internet-Draft for review through the IETF standards process as defined in \"The Internet Standards Process-- Revision 3\" (BCP 9 [35]). The new layout specification will be submitted for eventual publication as a Standards Track RFC.",
      "ja": "4. 著者は、「インターネット標準プロセス - リビジョン3」（BCP 9 [35]）で定義されているIETF規格プロセスを通じて、インターネットドラフトを概説します。新しいレイアウト仕様は、標準トラックRFCとして最終的な出版物のために送信されます。"
    },
    {
      "indent": 3,
      "text": "5. The layout specification progresses through the IETF standards process.",
      "ja": "5. レイアウト仕様は、IETF規格プロセスを経て進行します。"
    },
    {
      "indent": 0,
      "text": "22.6. Path Variable Definitions",
      "section_title": true,
      "ja": "22.6. パス変数の定義"
    },
    {
      "indent": 3,
      "text": "This section deals with the IANA considerations associated with the variable substitution feature for location names as described in Section 11.17.3. As described there, variables subject to substitution consist of a domain name and a specific name within that domain, with the two separated by a colon. There are two sets of IANA considerations here:",
      "ja": "このセクションでは、11.17.3項に記載されているように、ロケーション名の変数置換機能に関連するIANAの考慮事項について説明します。そこに記載されているように、置換対象の変数は、ドメイン名とそのドメイン内の特定の名前で構成され、2つはコロンによって分離されています。ここには2組のIANAの考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "1. The list of variable names.",
      "ja": "1. 変数名のリスト。"
    },
    {
      "indent": 3,
      "text": "2. For each variable name, the list of possible values.",
      "ja": "2. 各変数名については、可能な値のリストです。"
    },
    {
      "indent": 3,
      "text": "Thus, there will be one registry for the list of variable names, and possibly one registry for listing the values of each variable name.",
      "ja": "したがって、変数名のリスト、および各変数名の値をリストするための1つのレジストリのレジストリが1つあります。"
    },
    {
      "indent": 0,
      "text": "22.6.1. Path Variables Registry",
      "section_title": true,
      "ja": "22.6.1. パス変数レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Path Variables Registry\".",
      "ja": "IANAは \"NFSV4 PATH変数レジストリ\"と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 0,
      "text": "22.6.1.1. Path Variable Values",
      "section_title": true,
      "ja": "22.6.1.1. パス変数値"
    },
    {
      "indent": 3,
      "text": "Variable names are of the form \"${\", followed by a domain name, followed by a colon (\":\"), followed by a domain-specific portion of the variable name, followed by \"}\". When the domain name is \"ietf.org\", all variables names must be registered with IANA on a Standards Action basis, with Expert Review required. Path variables with registered domain names neither part of nor equal to ietf.org are assigned on a Hierarchical Allocation basis (delegating to the domain owner) and thus of no concern to IANA, unless the domain owner chooses to register a variable name from his domain. If the domain owner chooses to do so, IANA will do so on a First Come First Serve basis. To accommodate registrants who do not have their own domain, IANA will accept requests to register variables with the prefix \"${FCFS.ietf.org:\" on a First Come First Served basis. Assignments on a First Come First Basis do not require Expert Review, unless the registrant also wants IANA to establish a registry for the values of the registered variable.",
      "ja": "変数名は \"$ {\"の後にドメイン名、その後にコロン（ \"：\"）が続き、その後に変数名のドメイン固有の部分が続き、続いて \"}\"が続きます。ドメイン名が \"ietf.org\"の場合、すべての変数名は標準のアクションベースでIANAに登録されなければなりません。エキスパートレビューが必要です。登録されたドメイン名を持つパス変数IETF.orgの一部もietf.orgに等しくない階層割り当てベース（ドメイン所有者に委任）、したがって、ドメインの所有者が自分のドメインから変数名を登録することを選択しない限り、IANAには関係ありません。 。ドメインの所有者がそうすることを選択した場合、IANAは最初に最初のサービスベースでそうすることになります。独自のドメインを持っていない登録者に対応するには、最初のサービスベースで、プレフィックス \"$ {fcfs.ietf.org：\"で変数を登録する要求を受け入れます。登録者が登録された変数の値のレジストリを確立することを望んでいない限り、最初の入り口の割り当てはエキスパートレビューを必要としません。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれが3つのフィールドを含む割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the variable. The name of this variable must start with a \"${\" followed by a registered domain name, followed by \":\", or it must start with \"${FCFS.ietf.org\". The name must be no more than 64 UTF-8 characters long. The name must be unique.",
      "ja": "1. 変数の名前。この変数の名前は、 \"$ {\"の後に登録されたドメイン名、続いて \"：\"で始まっているか、 \"$ {fcfs.ietf.org\"で始める必要があります。名前は64文字以下のUTF-8文字になければなりません。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. For assignments made on Standards Action basis, the Standards Track RFC(s) that describe the variable. If the RFC(s) have not yet been published, the registrant will use RFCTBD1, RFCTBD2, etc. instead of an actual RFC number. Note that the RFCs do not have to be a part of an NFS minor version. For assignments made on a First Come First Serve basis, an explanation (consuming no more than 1024 bytes, or more if IANA permits) of the purpose of the variable. A reference to the explanation can be substituted.",
      "ja": "2. 標準アクションベースで行われた割り当ての場合、標準は変数を記述するRFCを追跡します。RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD1、RFCTBD2などを使用します。RFCSはNFSマイナーバージョンの一部である必要はありません。最初に最初に行われた割り当ては、変数の目的の説明（1024バイト以下、IANAが許す場合はそれ以上の消費）を提供します。説明を参照することができる。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits). For assignments made on a Standards Action basis, the point of contact is always IESG.",
      "ja": "3. 電子メールアドレスを含む連絡先。連絡先は、最大256バイト（IANAが許す場合はそれ以上）を消費できます。標準アクションベースで行われた割り当ての場合、連絡先は常にIESGです。"
    },
    {
      "indent": 0,
      "text": "22.6.1.1.1. Initial Registry",
      "section_title": true,
      "ja": "22.6.1.1.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 28.",
      "ja": "初期レジストリは表28にあります。"
    },
    {
      "indent": 9,
      "text": "+========================+==========+==================+\n| Variable Name          | RFC      | Point of Contact |\n+========================+==========+==================+\n| ${ietf.org:CPU_ARCH}   | RFC 8881 | IESG             |\n+------------------------+----------+------------------+\n| ${ietf.org:OS_TYPE}    | RFC 8881 | IESG             |\n+------------------------+----------+------------------+\n| ${ietf.org:OS_VERSION} | RFC 8881 | IESG             |\n+------------------------+----------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 28: Initial List of Path Variables",
      "ja": "表28：パス変数の初期リスト"
    },
    {
      "indent": 3,
      "text": "IANA has created registries for the values of the variable names ${ietf.org:CPU_ARCH} and ${ietf.org:OS_TYPE}. See Sections 22.6.2 and 22.6.3.",
      "ja": "IANAは、変数名$ {ietf.org：cpu_arch}と$ {ietf.org:os_type}の値の値のレジストリを作成しました。セクション22.6.2および22.6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "For the values of the variable ${ietf.org:OS_VERSION}, no registry is needed as the specifics of the values of the variable will vary with the value of ${ietf.org:OS_TYPE}. Thus, values for ${ietf.org:OS_VERSION} are on a Hierarchical Allocation basis and are of no concern to IANA.",
      "ja": "変数$ {ietf.org：os_version}の値については、変数の値の詳細は$ {ietf.org：os_type}の値によって異なるため、レジストリは必要ありません。したがって、$ {ietf.org：os_version}の値は階層割り当てベースであり、IANAには関係ありません。"
    },
    {
      "indent": 0,
      "text": "22.6.1.1.2. Updating Registrations",
      "section_title": true,
      "ja": "22.6.1.1.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of an assignment made on a Standards Action basis will require IESG Approval on the advice of a Designated Expert.",
      "ja": "標準アクションベースで行われた割り当ての更新は、指定された専門家のアドバイスに関するIESG承認を必要とします。"
    },
    {
      "indent": 3,
      "text": "The registrant can always update the point of contact of an assignment made on a First Come First Serve basis. Any other update will require Expert Review.",
      "ja": "登録者は、最初に最初のサービスベースで行われた割り当ての接触点を常に更新することができる。その他のアップデートでは、エキスパートレビューが必要です。"
    },
    {
      "indent": 0,
      "text": "22.6.2. Values for the ${ietf.org:CPU_ARCH} Variable",
      "section_title": true,
      "ja": "22.6.2. $ {ietf.org：cpu_arch}変数の値"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 ${ietf.org:CPU_ARCH} Value Registry\".",
      "ja": "IANAは、 \"NFSV4 $ {ietf.org：cpu_arch} valueレジストリ\"と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:CPU_ARCH} is Reserved. Values with a prefix of \"PRIV\" are designated for Private Use.",
      "ja": "レジストリへの割り当ては、最初のサービスベースで最初に行われます。$ {ietf.org：cpu_arch}のゼロ長値は予約されています。「Priv」のプレフィックスを持つ値は、プライベート使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれが3つのフィールドを含む割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A value of the ${ietf.org:CPU_ARCH} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.",
      "ja": "1. $ {ietf.org：cpu_arch}変数の値。値は1から32のUTF-8文字でなければなりません。値は一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.",
      "ja": "2. 値がどのCPUアーキテクチャを表すかを説明する（1024バイト以下、IANAが許す場合はそれ以上消費する）。説明を参照することができる。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3. 電子メールアドレスを含む連絡先。連絡先は、最大256バイト（IANAが許す場合はそれ以上）を消費できます。"
    },
    {
      "indent": 0,
      "text": "22.6.2.1. Initial Registry",
      "section_title": true,
      "ja": "22.6.2.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "初期レジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.6.2.2. Updating Registrations",
      "section_title": true,
      "ja": "22.6.2.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is free to update the assignment, i.e., change the explanation and/or point-of-contact fields.",
      "ja": "登録者は、課題、すなわち説明および/またはポイントフィールドを変更することが自由である。"
    },
    {
      "indent": 0,
      "text": "22.6.3. Values for the ${ietf.org:OS_TYPE} Variable",
      "section_title": true,
      "ja": "22.6.3. $ {ietf.org：os_type}変数の値"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 ${ietf.org:OS_TYPE} Value Registry\".",
      "ja": "IANAは \"NFSV4 $ {ietf.org:os_type} valueレジストリ\"と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:OS_TYPE} is Reserved. Values with a prefix of \"PRIV\" are designated for Private Use.",
      "ja": "レジストリへの割り当ては、最初のサービスベースで最初に行われます。$ {ietf.org：os_type}のゼロ長値は予約されています。「Priv」のプレフィックスを持つ値は、プライベート使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれが3つのフィールドを含む割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A value of the ${ietf.org:OS_TYPE} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.",
      "ja": "1. $ {ietf.org：os_type}変数の値。値は1から32のUTF-8文字でなければなりません。値は一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.",
      "ja": "2. 値がどのCPUアーキテクチャを表すかを説明する（1024バイト以下、IANAが許す場合はそれ以上消費する）。説明を参照することができる。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3. 電子メールアドレスを含む連絡先。連絡先は、最大256バイト（IANAが許す場合はそれ以上）を消費できます。"
    },
    {
      "indent": 0,
      "text": "22.6.3.1. Initial Registry",
      "section_title": true,
      "ja": "22.6.3.1. 初期レジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "初期レジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.6.3.2. Updating Registrations",
      "section_title": true,
      "ja": "22.6.3.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is free to update the assignment, i.e., change the explanation and/or point of contact fields.",
      "ja": "登録者は、課題、すなわち説明および/または連絡先フィールドを変更することが自由である。"
    },
    {
      "indent": 0,
      "text": "23. References",
      "section_title": true,
      "ja": "23. 参考文献"
    },
    {
      "indent": 0,
      "text": "23.1. Normative References",
      "section_title": true,
      "ja": "23.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[1] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[2] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <https://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[2] EISLER、M、ED。、「XDR：外部データ表現規格」、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<https：//www.rfc-editor.org/info/rfc4506>。"
    },
    {
      "indent": 3,
      "text": "[3] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <https://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[3] Thurlow、R.、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、<https：//www.rfc-editor.org/info/rfc5531>。"
    },
    {
      "indent": 3,
      "text": "[4] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, DOI 10.17487/RFC2203, September 1997, <https://www.rfc-editor.org/info/rfc2203>.",
      "ja": "[4] EISLER、M.、Chiu、A.、L. LING、「RPCSEC_GSSプロトコル仕様」、RFC 2203、DOI 10.17487 / RFC2203、1997年9月、<https：//www.rfc-editor.org/info/rfc2203>。"
    },
    {
      "indent": 3,
      "text": "[5] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, DOI 10.17487/RFC4121, July 2005, <https://www.rfc-editor.org/info/rfc4121>.",
      "ja": "[5] Zhu、L.、Jaganathan、K。、およびS. Hartman、「Kerberosバージョン5一般セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズム：バージョン2」、RFC 4121、DOI 10.17487 / RFC4121、2005年7月、<HTTPS：//www.rfc-editor.org/info/rfc4121>。"
    },
    {
      "indent": 3,
      "text": "[6] The Open Group, \"Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[6] Open Groupの「オープングループ基本仕様の基本定義の第3章の3.191号：IEEE STD 1003.1、2004版、HTML版」、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[7] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <https://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[7] Linn、J.、 \"Generic Security Service Application Program Interface Version 2、Update 1\"、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<https：//www.rfc-editor.org/info/rfc2743>。"
    },
    {
      "indent": 3,
      "text": "[8] Recio, R., Metzler, B., Culley, P., Hilland, J., and D. Garcia, \"A Remote Direct Memory Access Protocol Specification\", RFC 5040, DOI 10.17487/RFC5040, October 2007, <https://www.rfc-editor.org/info/rfc5040>.",
      "ja": "[8] Recio、R.、Metzler、B.、Culley、P.、Hilland、J.、D. Garcia、「リモートダイレクトメモリアクセスプロトコル仕様」、RFC 5040、DOI 10.17487 / RFC5040、2007年10月、<https：//www.rfc-editor.org/info/rfc5040>。"
    },
    {
      "indent": 3,
      "text": "[9] Eisler, M., \"RPCSEC_GSS Version 2\", RFC 5403, DOI 10.17487/RFC5403, February 2009, <https://www.rfc-editor.org/info/rfc5403>.",
      "ja": "[9] Eisler、M.、 \"RPCSEC_GSSバージョン2\"、RFC 5403、DOI 10.17487 / RFC5403、2009年2月、<https：//www.rfc-editor.org/info/rfc5403>。"
    },
    {
      "indent": 3,
      "text": "[10] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description\", RFC 5662, DOI 10.17487/RFC5662, January 2010, <https://www.rfc-editor.org/info/rfc5662>.",
      "ja": "[10] シザーラ、S、ED。、EISLER、M.、ED。、およびD. Noveck、ED。、「ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）説明」、RFC 5662、DOI10.17487 / RFC5662、2010年1月、<https://www.rfc-editor.org/info/rfc5662>。"
    },
    {
      "indent": 3,
      "text": "[11] The Open Group, \"Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[11] Open Groupの「オープングループ基本仕様の基本定義の第3章の3.372号の第372号」の第6章STD 1003.1,2004版、HTML版、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[12] Eisler, M., \"IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats\", RFC 5665, DOI 10.17487/RFC5665, January 2010, <https://www.rfc-editor.org/info/rfc5665>.",
      "ja": "[12] EISLER、M。、「リモートプロシージャコール（RPC）ネットワーク識別子とユニバーサルアドレスフォーマットのためのIANA考察」、RFC 5665、DOI 10.17487 / RFC5665、2010年1月、<https：//www.rfc-editor.org/info/rfc5665>。"
    },
    {
      "indent": 3,
      "text": "[13] The Open Group, \"Section 'read()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[13] Open Group「Open Group Std 1003.1,2004版」、HTML版、2004年版、html version \"、html version\"、<https://ww.opengroup.org>を開く。"
    },
    {
      "indent": 3,
      "text": "[14] The Open Group, \"Section 'readdir()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[14] Open Group「Open Group Base Speciations Open Group Base Speciationsのシステムインターフェイス」の「section 'readdir（）」号：IEEE STD 1003.1,2004版、HTMLバージョン、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[15] The Open Group, \"Section 'write()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[15] Open Group「SECTION」オープングループベース仕様のシステムインターフェイスのシステムインターフェイスのシステムインターフェースの「write 'write（）」は、IEEE STD 1003.1,2004版、HTMLバージョン、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[16] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, DOI 10.17487/RFC3454, December 2002, <https://www.rfc-editor.org/info/rfc3454>.",
      "ja": "[16] HOFFMAN、P.およびM.BLANCHET、「国際化された文字列の準備（ \"StringPrep\"） \"、RFC 3454、DOI 10.17487 / RFC3454、2002年12月、<https：//www.rfc-editor.org/info/rfc3454>。"
    },
    {
      "indent": 3,
      "text": "[17] The Open Group, \"Section 'chmod()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[17] Open Groupのオープングループ、オープングループベース仕様のシステムインターフェイスの「CHMOD（）」のセクション6 IEEE STD 1003.1、2004版、HTMLバージョン、ISBN 1931624232,2004、<https：//www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[18] International Organization for Standardization, \"Information Technology - Universal Multiple-octet coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane\", ISO Standard 10646-1, May 1993.",
      "ja": "[18] 国際標準化機構、「情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS） - 第1部：アーキテクチャと基本的な平面」、ISO規格10646-1、1993年5月。"
    },
    {
      "indent": 3,
      "text": "[19] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, DOI 10.17487/RFC2277, January 1998, <https://www.rfc-editor.org/info/rfc2277>.",
      "ja": "[19] 1998年1月、<https://www.rfc-editor.org/info/rfc-editor.org/info/rfc2277、<https：//www.rfc-editor.org/info/rfc-editor.org/info/rfc2277、<https：//www.rfc-editor.org/info/rfc-editor.org/info/rfc-editor.org/info/rfc-editor.org/info/rfc2277>。"
    },
    {
      "indent": 3,
      "text": "[20] Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)\", RFC 3491, DOI 10.17487/RFC3491, March 2003, <https://www.rfc-editor.org/info/rfc3491>.",
      "ja": "[20] Hoffman、P.およびM.Blanchet、 \"NamePrep：国際化ドメイン名（IDN）のStringPrepプロファイル（IDN）\"、RFC 3491、DOI 10.17487 / RFC3491、2003年3月、<https://www.rfc-editor.org/info/RFC3491>。"
    },
    {
      "indent": 3,
      "text": "[21] The Open Group, \"Section 'fcntl()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[21] Open Groupの「オープングループ」基本仕様のシステムインタフェースの「fcntl（）」の「section 'fcntl（）」は、IEEE STD 1003.1,2004版、HTMLバージョン、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[22] The Open Group, \"Section 'fsync()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[22] Open Group「Open Group Base Syporitionsのシステムインターフェイス」の「FSYNC（）」の「FSYNC（）」は、IEEE STD 1003.1,2004版、HTMLバージョン、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[23] The Open Group, \"Section 'getpwnam()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[23] Open Group「オープングループ基本仕様のシステムインターフェイス」の「getpwnam（）」の「getpwnam（）」の号：https：//www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[24] The Open Group, \"Section 'unlink()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version\", ISBN 1931624232, 2004, <https://www.opengroup.org>.",
      "ja": "[24] オープングループのオープングループの「セクション 'inclink（）」オープングループベース仕様のシステムインタフェースのシステムインタフェースのOUT 6 IEEE STD 1003.1、2004版、HTMLバージョン、ISBN 1931624232,2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[25] Schaad, J., Kaliski, B., and R. Housley, \"Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 4055, DOI 10.17487/RFC4055, June 2005, <https://www.rfc-editor.org/info/rfc4055>.",
      "ja": "[25] Schaad、J.、Kaliski、B.およびR.housley、 \"Internet X.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイルでのRSA暗号化のための追加アルゴリズムおよび識別子\"、RFC 4055、DOI 10.17487/ RFC4055、2005年6月、<https://www.rfc-editor.org/info/rfc4055>。"
    },
    {
      "indent": 3,
      "text": "[26] National Institute of Standards and Technology, \"Computer Security Objects Register\", May 2016, <https://csrc.nist.gov/projects/computer-security-objects-register/algorithm-registration>.",
      "ja": "[26] 国立標準化学研究所、「コンピュータセキュリティオブジェクトレジスタ」、2016年5月、<https：//csrc.nist.gov/projects/computer-security-Objects-register/Algorithm-Registration>。"
    },
    {
      "indent": 3,
      "text": "[27] Adamson, A. and N. Williams, \"Remote Procedure Call (RPC) Security Version 3\", RFC 7861, DOI 10.17487/RFC7861, November 2016, <https://www.rfc-editor.org/info/rfc7861>.",
      "ja": "[27] Adamson、A.およびN. Williams、「リモートプロシージャコール（RPC）セキュリティバージョン3」、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、<https：//www.rfc-editor.org/info/rfc7861>。"
    },
    {
      "indent": 3,
      "text": "[28] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, DOI 10.17487/RFC4120, July 2005, <https://www.rfc-editor.org/info/rfc4120>.",
      "ja": "[28] Neuman、C、Yu、T.、Hartman、S.、およびK.Raeburn、「Kerberos Network認証サービス（V5）」、RFC 4120、DOI 10.17487 / RFC4120、2005年7月、<https：//www.rfc-editor.org/info/rfc4120>。"
    },
    {
      "indent": 3,
      "text": "[29] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, DOI 10.17487/RFC4033, March 2005, <https://www.rfc-editor.org/info/rfc4033>.",
      "ja": "[29] Rend、R.、Austein、R.、Larson、M.、Massey、D.、およびS. Rose、「DNSセキュリティ紹介および要件」、RFC 4033、DOI 10.17487 / RFC4033、2005年3月、<https：// www.rfc-editor.org / info / rfc4033>。"
    },
    {
      "indent": 3,
      "text": "[30] Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D., and P. Hoffman, \"Specification for DNS over Transport Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May 2016, <https://www.rfc-editor.org/info/rfc7858>.",
      "ja": "[30] HU、Z.、Zhu、L.、Heidemann、J.、Mankin、A.、Wessels、D.、およびP. Hoffman、「トランスポート層セキュリティ（TLS）のDNSの仕様、RFC 7858、DOI 10.17487 / RFC78582016年5月、<https：//www.rfc-editor.org/info/rfc7858>。"
    },
    {
      "indent": 3,
      "text": "[31] Adamson, A. and N. Williams, \"Requirements for NFSv4 Multi-Domain Namespace Deployment\", RFC 8000, DOI 10.17487/RFC8000, November 2016, <https://www.rfc-editor.org/info/rfc8000>.",
      "ja": "[31] Adamson、A.およびN. Williams、「NFSV4マルチドメインネームスペース展開の要件」、RFC 8000、DOI 10.17487 / RFC8000、2016年11月、<https：//www.rfc-editor.org/info/rfc8000>。"
    },
    {
      "indent": 3,
      "text": "[32] Lever, C., Ed., Simpson, W., and T. Talpey, \"Remote Direct Memory Access Transport for Remote Procedure Call Version 1\", RFC 8166, DOI 10.17487/RFC8166, June 2017, <https://www.rfc-editor.org/info/rfc8166>.",
      "ja": "[32] レバー、C、ED。、Simpson、W.、およびT。Talpey、RFC 8166、DOI 10.17487 / RFC8166、2017年6月、<https：// www。rfc-editor.org/info/rfc8166>。"
    },
    {
      "indent": 3,
      "text": "[33] Lever, C., \"Network File System (NFS) Upper-Layer Binding to RPC-over-RDMA Version 1\", RFC 8267, DOI 10.17487/RFC8267, October 2017, <https://www.rfc-editor.org/info/rfc8267>.",
      "ja": "[33] レバー、C.、「ネットワークファイルシステム（NFS）上層バインディング、RFC 8267、DOI 10.17487 / RFC8267、2017年10月、<https：//www.rfc-editor.org/情報/ RFC8267>。"
    },
    {
      "indent": 3,
      "text": "[34] Hoffman, P. and P. McManus, \"DNS Queries over HTTPS (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018, <https://www.rfc-editor.org/info/rfc8484>.",
      "ja": "[34] Hoffman、P.およびP.Mcmanus、「DNS Queries over HTTPS（DOH）」、RFC 8484、DOI 10.17487 / RFC8484、2018年10月、<https：//www.rfc-editor.org/info/rfc8484>。"
    },
    {
      "indent": 3,
      "text": "[35] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP 9, RFC 2026, October 1996.",
      "ja": "[35] Bradner、S.、「インターネット標準プロセス - リビジョン3」、BCP 9、RFC 2026、1996年10月。"
    },
    {
      "indent": 14,
      "text": "Kolkman, O., Bradner, S., and S. Turner, \"Characterization of Proposed Standards\", BCP 9, RFC 7127, January 2014.",
      "ja": "Kolkman、O.、Bradner、S.、S. Turner、「提案基準の特性」、BCP 9、RFC 7127、2014年1月。"
    },
    {
      "indent": 14,
      "text": "Dusseault, L. and R. Sparks, \"Guidance on Interoperation and Implementation Reports for Advancement to Draft Standard\", BCP 9, RFC 5657, September 2009.",
      "ja": "DusseAult、L.およびR. Sparks、2009年9月、BCP 9、RFC 5657、BCP 9、RFC 5657。"
    },
    {
      "indent": 14,
      "text": "Housley, R., Crocker, D., and E. Burger, \"Reducing the Standards Track to Two Maturity Levels\", BCP 9, RFC 6410, October 2011.",
      "ja": "Housley、R.、Crocker、D.、およびE.バーガー、「基準を2つの満期レベルに縮小する」、BCP 9、RFC 6410、2011年10月。"
    },
    {
      "indent": 14,
      "text": "Resnick, P., \"Retirement of the \"Internet Official Protocol Standards\" Summary Document\", BCP 9, RFC 7100, December 2013.",
      "ja": "resnick、p.、「退職」インターネット公式プロトコル標準「サマリードキュメント」、BCP 9、RFC 7100、2013年12月。"
    },
    {
      "indent": 14,
      "text": "Dawkins, S., \"Increasing the Number of Area Directors in an IETF Area\", BCP 9, RFC 7475, March 2015.",
      "ja": "Dawkins、S。、「IETFエリアにおける面積取締役の数を増やす」、BCP 9、RFC 7475、2015年3月。"
    },
    {
      "indent": 14,
      "text": "<https://www.rfc-editor.org/info/bcp9>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "23.2. Informative References",
      "section_title": true,
      "ja": "23.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[36] Roach, A., \"Process for Handling Non-Major Revisions to Existing RFCs\", Work in Progress, Internet-Draft, draft-roach-bis-documents-00, 7 May 2019, <https://tools.ietf.org/html/draft-roach-bis-documents-00>.",
      "ja": "[36] ROACH、A。、「既存のRFCへの非主要な改訂の取り扱いのプロセス」、進行中の作業、インターネットドラフト、ドラフトROACH-BIS-Documents-00、2019年5月7日、<https：//tools.ietf.org/ html / draft-roach-bis-documents-00>。"
    },
    {
      "indent": 3,
      "text": "[37] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, \"Network File System (NFS) version 4 Protocol\", RFC 3530, DOI 10.17487/RFC3530, April 2003, <https://www.rfc-editor.org/info/rfc3530>.",
      "ja": "[37] シザーラ、S。、Callaghan、B.、Robinson、D.、Thurlow、R.、Beame、C、Eisler、M.、D. Noveck、「ネットワークファイルシステム（NFS）バージョン4プロトコル」、RFC 3530、DOI 10.17487 / RFC3530、2003年4月、<https://www.rfc-editor.org/info/rfc3530>。"
    },
    {
      "indent": 3,
      "text": "[38] Callaghan, B., Pawlowski, B., and P. Staubach, \"NFS Version 3 Protocol Specification\", RFC 1813, DOI 10.17487/RFC1813, June 1995, <https://www.rfc-editor.org/info/rfc1813>.",
      "ja": "[38] Callaghan、B.、Pawlowski、B.、およびP.Staubach、 \"NFSバージョン3プロトコル仕様\"、RFC 1813、DOI 10.17487 / RFC1813、1995年6月、<https：//www.rfc-editor.org/info/rfc1813>。"
    },
    {
      "indent": 3,
      "text": "[39] Eisler, M., \"LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM\", RFC 2847, DOI 10.17487/RFC2847, June 2000, <https://www.rfc-editor.org/info/rfc2847>.",
      "ja": "[39] EISLER、M.、「LIPKEY  -  SPKMを使用した低インフラストラクチャ公開鍵メカニズム」、RFC 2847、DOI 10.17487 / RFC2847、2000年6月、<https://www.rfc-editor.org/info/rfc2847>。"
    },
    {
      "indent": 3,
      "text": "[40] Eisler, M., \"NFS Version 2 and Version 3 Security Issues and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\", RFC 2623, DOI 10.17487/RFC2623, June 1999, <https://www.rfc-editor.org/info/rfc2623>.",
      "ja": "[40] EISLER、M.、「NFSバージョン2とバージョン3セキュリティ問題とNFSプロトコルのRPCSEC_GSSとKerberos V5の使用」、RFC 2623、DOI 10.17487 / RFC2623、1999年6月、<https：//www.rfc-editor.org/情報/ RFC2623>。"
    },
    {
      "indent": 3,
      "text": "[41] Juszczak, C., \"Improving the Performance and Correctness of an NFS Server\", USENIX Conference Proceedings, June 1990.",
      "ja": "[41] Juszczak、C。、「NFSサーバーの性能と正確さの向上」、Usenix Conference Expingings、1990年6月。"
    },
    {
      "indent": 3,
      "text": "[42] Reynolds, J., Ed., \"Assigned Numbers: RFC 1700 is Replaced by an On-line Database\", RFC 3232, DOI 10.17487/RFC3232, January 2002, <https://www.rfc-editor.org/info/rfc3232>.",
      "ja": "[42] レイノルズ、J.、ED。、「割り当てられた番号：RFC 1700はオンラインデータベースに置き換えられます」、RFC 3232、DOI 10.17487 / RFC3232、2002年1月、<https：//www.rfc-editor.org/info/RFC3232>。"
    },
    {
      "indent": 3,
      "text": "[43] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, DOI 10.17487/RFC1833, August 1995, <https://www.rfc-editor.org/info/rfc1833>.",
      "ja": "[43] Srinivasan、R.、「ONC RPCバージョン2のバインディングプロトコル」、RFC 1833、DOI 10.17487 / RFC1833、1995年8月、<https：//www.rfc-editor.org/info/rfc1833>。"
    },
    {
      "indent": 3,
      "text": "[44] Werme, R., \"RPC XID Issues\", USENIX Conference Proceedings, February 1996.",
      "ja": "[44] Werme、R.、 \"RPC XID問題\"、1996年2月、Usenix Conference Expingings。"
    },
    {
      "indent": 3,
      "text": "[45] Nowicki, B., \"NFS: Network File System Protocol specification\", RFC 1094, DOI 10.17487/RFC1094, March 1989, <https://www.rfc-editor.org/info/rfc1094>.",
      "ja": "[45] Nowicki、B.、 \"NFS：ネットワークファイルシステムプロトコル仕様書\"、RFC 1094、DOI 10.17487 / RFC1094、1989年3月、<https://www.rfc-editor.org/info/rfc1094>。"
    },
    {
      "indent": 3,
      "text": "[46] Bhide, A., Elnozahy, E. N., and S. P. Morgan, \"A Highly Available Network Server\", USENIX Conference Proceedings, January 1991.",
      "ja": "[46] Bhide、A.、Elnozahy、E. N.、およびS. P. P. Morgan、「高可用性ネットワークサーバー」、Usenix Conference Expingings、1991年1月。"
    },
    {
      "indent": 3,
      "text": "[47] Halevy, B., Welch, B., and J. Zelenka, \"Object-Based Parallel NFS (pNFS) Operations\", RFC 5664, DOI 10.17487/RFC5664, January 2010, <https://www.rfc-editor.org/info/rfc5664>.",
      "ja": "[47] Halevy、B、Welch、B.、J.Zelenka、「オブジェクトベースの並列NFS（PNFS）操作」、RFC 5664、DOI 10.17487 / RFC5664、2010年1月、<https：//www.rfc-editor.org/ info / rfc5664>。"
    },
    {
      "indent": 3,
      "text": "[48] Black, D., Fridella, S., and J. Glasgow, \"Parallel NFS (pNFS) Block/Volume Layout\", RFC 5663, DOI 10.17487/RFC5663, January 2010, <https://www.rfc-editor.org/info/rfc5663>.",
      "ja": "[48] ブラック、D.、Fridella、S.、J.Glasgow、 \"Parallel NFS（PNFS）ブロック/音量レイアウト\"、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、<https：//www.rfc-editor.org/ info / rfc5663>。"
    },
    {
      "indent": 3,
      "text": "[49] Callaghan, B., \"WebNFS Client Specification\", RFC 2054, DOI 10.17487/RFC2054, October 1996, <https://www.rfc-editor.org/info/rfc2054>.",
      "ja": "[49] Callaghan、B.、「WebNFSクライアント仕様」、RFC 2054、DOI 10.17487 / RFC2054、1996年10月、<https：//www.rfc-editor.org/info/rfc2054>。"
    },
    {
      "indent": 3,
      "text": "[50] Callaghan, B., \"WebNFS Server Specification\", RFC 2055, DOI 10.17487/RFC2055, October 1996, <https://www.rfc-editor.org/info/rfc2055>.",
      "ja": "[50] Callagan、B.、「WebNFSサーバー仕様」、RFC 2055、DOI 10.17487 / RFC2055、1996年10月、<https：//www.rfc-editor.org/info/rfc2055>。"
    },
    {
      "indent": 3,
      "text": "[51] IESG, \"IESG Processing of RFC Errata for the IETF Stream\", July 2008, <https://www.ietf.org/about/groups/iesg/statements/ processing-rfc-errata/>.",
      "ja": "[51] 2008年7月、<https://www.ietf.org/about/groups/iesg/statements/ rfc-errata />を処理します./>。"
    },
    {
      "indent": 3,
      "text": "[52] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[52] Krawczyk、H.、Bellare、M.、およびR. Canetti、 \"HMAC：メッセージ認証のための鍵付きハジング\"、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<https：//www.rfc-editor.org/情報/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[53] Shepler, S., \"NFS Version 4 Design Considerations\", RFC 2624, DOI 10.17487/RFC2624, June 1999, <https://www.rfc-editor.org/info/rfc2624>.",
      "ja": "[53] Shepler、S.、 \"NFSバージョン4デザインに関する考慮事項\"、RFC 2624、DOI 10.17487 / RFC2624、1999年6月、<https：//www.rfc-editor.org/info/rfc2624>。"
    },
    {
      "indent": 3,
      "text": "[54] The Open Group, \"Protocols for Interworking: XNFS, Version 3W\", ISBN 1-85912-184-5, February 1998.",
      "ja": "[54] オープングループ「インターワーキングのためのプロトコル：XNFS、バージョン3W」、ISBN 1-85912-184-5、1998年2月。"
    },
    {
      "indent": 3,
      "text": "[55] Floyd, S. and V. Jacobson, \"The Synchronization of Periodic Routing Messages\", IEEE/ACM Transactions on Networking, 2(2), pp. 122-136, April 1994.",
      "ja": "[55] Floyd、S.およびV.Jacobson、「定期的なルーティングメッセージの同期」、NetWorkingのIEEE / ACMトランザクション、2（2）、PP。1994年4月。"
    },
    {
      "indent": 3,
      "text": "[56] Chadalapaka, M., Satran, J., Meth, K., and D. Black, \"Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)\", RFC 7143, DOI 10.17487/RFC7143, April 2014, <https://www.rfc-editor.org/info/rfc7143>.",
      "ja": "[56] Chadalapaka、M.、Satran、J.、Meth、K.、およびD.ブラック、「インターネットスモールコンピュータシステムインタフェース（ISCSI）プロトコル（統合）」、RFC 7143、DOI 10.17487 / RFC7143、2014年4月、<https：//www.rfc-editor.org/info/rfc7143>。"
    },
    {
      "indent": 3,
      "text": "[57] Snively, R., \"Fibre Channel Protocol for SCSI, 2nd Version (FCP-2)\", ANSI/INCITS, 350-2003, October 2003.",
      "ja": "[57] R.、R.、SCSIのファイバチャネルプロトコル、第2版（FCP-2） \"、ANSI / INCITS、350-2003、2003年10月。"
    },
    {
      "indent": 3,
      "text": "[58] Weber, R.O., \"Object-Based Storage Device Commands (OSD)\", ANSI/INCITS, 400-2004, July 2004, <https://www.t10.org/drafts.htm>.",
      "ja": "[58] 2004年7月、<https：//www.t10.org/drafts.htm>をWeber、R.o.o.Octureベースのストレージデバイスコマンド（OSD） \""
    },
    {
      "indent": 3,
      "text": "[59] Carns, P. H., Ligon III, W. B., Ross, R. B., and R. Thakur, \"PVFS: A Parallel File System for Linux Clusters.\", Proceedings of the 4th Annual Linux Showcase and Conference, 2000.",
      "ja": "[59] Carns、P.H.、Ligon III、W. B.、Ross、R. B.、R.Thakur、Linuxクラスター用の並列ファイルシステム。「4回目のLinux Showcase and Conference 2000」の手続き。"
    },
    {
      "indent": 3,
      "text": "[60] The Open Group, \"The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition\", 2004, <https://www.opengroup.org>.",
      "ja": "[60] オープングループ「オープングループベース仕様発行6、IEEE STD 1003.1,2004版」、2004、<https://www.opengroup.org>。"
    },
    {
      "indent": 3,
      "text": "[61] Callaghan, B., \"NFS URL Scheme\", RFC 2224, DOI 10.17487/RFC2224, October 1997, <https://www.rfc-editor.org/info/rfc2224>.",
      "ja": "[61] Callaghan、B.、 \"NFS URLスキーム\"、RFC 2224、DOI 10.17487 / RFC2224、1997年10月、<https：//www.rfc-editor.org/info/rfc2224>。"
    },
    {
      "indent": 3,
      "text": "[62] Chiu, A., Eisler, M., and B. Callaghan, \"Security Negotiation for WebNFS\", RFC 2755, DOI 10.17487/RFC2755, January 2000, <https://www.rfc-editor.org/info/rfc2755>.",
      "ja": "[62] Chiu、A.、Eisler、M.、およびB.Callaghan、「WebNFSのセキュリティ交渉」、RFC 2755、DOI 10.17487 / RFC2755、2000年1月、<https：//www.rfc-editor.org/info/rfc2755>。"
    },
    {
      "indent": 3,
      "text": "[63] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[63] 綿、M.、Leiba、B.およびT.Narten、「RFCのIANAに関する考察のためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：///www.rfc-editor.org/info/rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[64] RFC Errata, Erratum ID 2006, RFC 5661, <https://www.rfc-editor.org/errata/eid2006>.",
      "ja": "[64] RFC errata、Erratum ID 2006、RFC 5661、<https://www.rfc-editor.org/errata/eid2006>。"
    },
    {
      "indent": 3,
      "text": "[65] Spasojevic, M. and M. Satayanarayanan, \"An Empirical Study of a Wide-Area Distributed File System\", ACM Transactions on Computer Systems, Vol. 14, No. 2, pp. 200-222, DOI 10.1145/227695.227698, May 1996, <https://doi.org/10.1145/227695.227698>.",
      "ja": "[65] Spasojevic、M.およびM. Satayanarayanan、「ワイドエリア分散ファイルシステムの実証的研究」、コンピュータシステムのACMトランザクション、Vol。14、No.2、PP。200-222、DOI 10.1145 / 227695.227698、1996年5月、<https：//doi.org/10.1145/227695.227698>。"
    },
    {
      "indent": 3,
      "text": "[66] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <https://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[66] シザーラ、S。、EISLER、M.、ED。、およびD. Noveck、ED。、「ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1プロトコル」、RFC 5661、DOI 10.17487 / RFC5661、2010年1月、<https://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[67] Noveck, D., \"Rules for NFSv4 Extensions and Minor Versions\", RFC 8178, DOI 10.17487/RFC8178, July 2017, <https://www.rfc-editor.org/info/rfc8178>.",
      "ja": "[67] Noveck、D.、「NFSV4拡張およびマイナーバージョンの規則」、RFC 8178、DOI 10.17487 / RFC8178、2017年7月、<https：//www.rfc-editor.org/info/rfc8178>。"
    },
    {
      "indent": 3,
      "text": "[68] Haynes, T., Ed. and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <https://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[68] Haynes、T.、ED。D. Noveck、ED。、「ネットワークファイルシステム（NFS）バージョン4プロトコル」、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<https：//www.rfc-editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[69] Noveck, D., Ed., Shivam, P., Lever, C., and B. Baker, \"NFSv4.0 Migration: Specification Update\", RFC 7931, DOI 10.17487/RFC7931, July 2016, <https://www.rfc-editor.org/info/rfc7931>.",
      "ja": "[69] Noveck、D.、ED。、Shivam、P.、レバー、C、およびB.Baker、 \"NFSV4.0移行：仕様更新\"、RFC 7931、DOI 10.17487 / RFC7931、2016年7月、<https：// www.rfc-editor.org / info / rfc7931>。"
    },
    {
      "indent": 3,
      "text": "[70] Haynes, T., \"Requirements for Parallel NFS (pNFS) Layout Types\", RFC 8434, DOI 10.17487/RFC8434, August 2018, <https://www.rfc-editor.org/info/rfc8434>.",
      "ja": "[70] 2018年8月、<https://www.rfc- editor.org/info/rfc-editor.org/info/rfc8434,2018、<https://www.rfc-editor.org/info/rfc8434>。"
    },
    {
      "indent": 3,
      "text": "[71] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014, <https://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[71] Farrell、S.およびH.Tschofenig、「Pervasive Monitoringは攻撃」、BCP 188、RFC 7258、DOI 10.17487 / RFC7258、<https：//www.rfc-editor.org/info/rfc7258>。"
    },
    {
      "indent": 3,
      "text": "[72] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.",
      "ja": "[72] Rescorla、E.およびB.Korver、「セキュリティに関するRFCテキストを書くためのガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https：//www.rfc-editor.org/info/rfc3552>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. The Need for This Update",
      "section_title": true,
      "ja": "付録A.このアップデートの必要性"
    },
    {
      "indent": 3,
      "text": "This document includes an explanation of how clients and servers are to determine the particular network access paths to be used to access a file system. This includes descriptions of how to handle changes to the specific replica to be used or to the set of addresses to be used to access it, and how to deal transparently with transfers of responsibility that need to be made. This includes cases in which there is a shift between one replica and another and those in which different network access paths are used to access the same replica.",
      "ja": "この文書には、クライアントとサーバーがファイルシステムにアクセスするために使用される特定のネットワークアクセスパスをどのように決定するかについて説明します。これには、使用する特定のレプリカへの変更を処理する方法、またはアクセスするために使用されるアドレスのセット、および作成する必要がある責任の転送を透過的に処理する方法について説明します。これには、1つのレプリカと他のレプリカとの間にシフトがある場合と、同じレプリカにアクセスするためにさまざまなネットワークアクセスパスが使用されている場合が含まれます。"
    },
    {
      "indent": 3,
      "text": "As a result of the following problems in RFC 5661 [66], it was necessary to provide the specific updates that are made by this document. These updates are described in Appendix B.",
      "ja": "RFC 5661の問題の結果として、この文書によって行われる特定の更新を提供する必要があった。これらの更新は付録Bに記載されています。"
    },
    {
      "indent": 3,
      "text": "* RFC 5661 [66], while it dealt with situations in which various forms of clustering allowed coordination of the state assigned by cooperating servers to be used, made no provisions for Transparent State Migration. Within NFSv4.0, Transparent State Migration was first explained clearly in RFC 7530 [68] and corrected and clarified by RFC 7931 [69]. No corresponding explanation for NFSv4.1 had been provided.",
      "ja": "* RFC 5661 [66]は、さまざまな形式のクラスタ化が使用される協力サーバーによって割り当てられた状態の調整を許可されている状況に対処していますが、透過状態の移行の規定はありませんでした。NFSV4.0内では、RFC 7530 [68]では、透明状態の移動が最初に説明され、RFC 7931によって補正され明確化された[69]。NFSV4.1の対応する説明は提供されていません。"
    },
    {
      "indent": 3,
      "text": "* Although NFSv4.1 provided a clear definition of how trunking detection was to be done, there was no clear specification of how trunking discovery was to be done, despite the fact that the specification clearly indicated that this information could be made available via the file system location attributes.",
      "ja": "* NFSV4.1は、トランキング検出を行う方法の明確な定義を提供したが、この情報がファイルシステムを介して利用可能であることを明確に示されたという事実にもかかわらず、走行発見の発見がどのように行われたかについて明確な仕様はなかった。場所属性"
    },
    {
      "indent": 3,
      "text": "* Because the existence of multiple network access paths to the same file system was dealt with as if there were multiple replicas, issues relating to transitions between replicas could never be clearly distinguished from trunking-related transitions between the addresses used to access a particular file system instance. As a result, in situations in which both migration and trunking configuration changes were involved, neither of these could be clearly dealt with, and the relationship between these two features was not seriously addressed.",
      "ja": "* 同じファイルシステムへの複数のネットワークアクセスパスの存在は、複数のレプリカがあるかのように扱われているため、特定のファイルシステムインスタンスにアクセスするために使用されるアドレス間のトランジションとの間のトランジションに関連する問題を明確に区別することはできませんでした。。その結果、マイグレーションとトランキング構成の変化の両方が関与している状況では、これらのどちらも扱われる可能性があり、これら2つの機能の間の関係は深刻な対処されていませんでした。"
    },
    {
      "indent": 3,
      "text": "* Because use of two network access paths to the same file system instance (i.e., trunking) was often treated as if two replicas were involved, it was considered that two replicas were being used simultaneously. As a result, the treatment of replicas being used simultaneously in RFC 5661 [66] was not clear, as it covered the two distinct cases of a single file system instance being accessed by two different network access paths and two replicas being accessed simultaneously, with the limitations of the latter case not being clearly laid out.",
      "ja": "* 同じファイルシステムインスタンス（すなわち、トランキング）への2つのネットワークアクセス経路を使用することが多くの場合、2つのレプリカが含まれているかのように扱われたので、2つのレプリカが同時に使用されていたと考えられた。その結果、RFC 5661で同時に使用されているレプリカの処理は、2つの異なるネットワークアクセスパスと2つのレプリカが同時にアクセスされている1つのファイルシステムインスタンスの2つの異なるケースをカバーしていました。後者の場合の制限は明確にレイアウトされていない。"
    },
    {
      "indent": 3,
      "text": "The majority of the consequences of these issues are dealt with by presenting in Section 11 a replacement for Section 11 of RFC 5661 [66]. This replacement modifies existing subsections within that section and adds new ones as described in Appendix B.1. Also, some existing sections were deleted. These changes were made in order to do the following:",
      "ja": "これらの問題の結果の大部分は、RFC 5661のセクション11のための取り替えをセクション11に提示することによって対処されています[66]。この取り替えはそのセクション内の既存のサブセクションを変更し、付録B.1に記載されているように新しいものを追加します。また、いくつかの既存のセクションが削除されました。これらの変更は、次のようにするために行われました。"
    },
    {
      "indent": 3,
      "text": "* Reorganize the description so that the case of two network access paths to the same file system instance is distinguished clearly from the case of two different replicas since, in the former case, locking state is shared and there also can be sharing of session state.",
      "ja": "* 説明を2つの異なるレプリカの場合のケースが明確に区別され、ロック状態が共有され、セッション状態を共有することができるため、2つの異なるレプリカの場合が明確に区別されるように説明を再編成します。"
    },
    {
      "indent": 3,
      "text": "* Provide a clear statement regarding the desirability of transparent transfer of state between replicas together with a recommendation that either transparent transfer or a single-fs grace period be provided.",
      "ja": "* 透過的な転送または単一のFS猶予期間のいずれかを推奨することと、レプリカ間の状態の透明な状態転送の望ましさの望ましさに関する明確な声明を提供する。"
    },
    {
      "indent": 3,
      "text": "* Specifically delineate how a client is to handle such transfers, taking into account the differences from the treatment in [69] made necessary by the major protocol changes to NFSv4.1.",
      "ja": "* メジャープロトコルがNFSV4.1に変更された[69]の治療との違いを考慮して、クライアントがそのような転送を処理する方法を特に描写します。"
    },
    {
      "indent": 3,
      "text": "* Discuss the relationship between transparent state transfer and Parallel NFS (pNFS).",
      "ja": "* 透明状態転送と並列NFS（PNF）の関係について説明します。"
    },
    {
      "indent": 3,
      "text": "* Clarify the fs_locations_info attribute in order to specify which portions of the provided information apply to a specific network access path and which apply to the replica that the path is used to access.",
      "ja": "* 提供された情報のどの部分が特定のネットワークアクセスパスに適用され、パスがアクセスするために使用されるレプリカに適用されるかを指定するために、FS_LOCATIONS_INFO属性を明確にします。"
    },
    {
      "indent": 3,
      "text": "In addition, other sections of RFC 5661 [66] were updated to correct the consequences of the incorrect assumptions underlying the treatment of multi-server namespace issues. These are described in Appendices B.2 through B.4.",
      "ja": "さらに、RFC 5661の他のセクション[66]は、マルチサーバーの名前空間の問題の治療の基礎となる誤った仮定の結果を訂正するために更新されました。これらは付録B.2からB.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "* A revised introductory section regarding multi-server namespace facilities is provided.",
      "ja": "* マルチサーバーネームスペース機能に関する改訂された紹介セクションが提供されています。"
    },
    {
      "indent": 3,
      "text": "* A more realistic treatment of server scope is provided. This treatment reflects the more limited coordination of locking state adopted by servers actually sharing a common server scope.",
      "ja": "* サーバースコープのより現実的な扱いが提供されています。この処理は、実際に共通のサーバー範囲を共有するサーバーによって採用されているロック状態の方が限られています。"
    },
    {
      "indent": 3,
      "text": "* Some confusing text regarding changes in server_owner has been clarified.",
      "ja": "* Server_Ownerの変更に関する混乱したテキストが明確にされています。"
    },
    {
      "indent": 3,
      "text": "* The description of some existing errors has been modified to more clearly explain certain error situations to reflect the existence of trunking and the possible use of fs-specific grace periods. For details, see Appendix B.3.",
      "ja": "* いくつかの既存のエラーの説明は、トランキングの存在とFS特有の猶予期間の使用可能な使用を反映するように特定のエラー状況をより明確に説明するように修正されています。詳しくは、付録B.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "* New descriptions of certain existing operations are provided, either because the existing treatment did not account for situations that would arise in dealing with Transparent State Migration, or because some types of reclaim issues were not adequately dealt with in the context of fs-specific grace periods. For details, see Appendix B.2.",
      "ja": "* 既存の治療が透明な州の移行に対処する際に発生する状況を説明しなかった場合、またはいくつかの種類の再生問題がFS固有の猶予期間の文脈では適切に扱われなかったため、特定の既存の事業の新しい説明が提供されています。。詳細については、付録B.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Changes in This Update",
      "section_title": true,
      "ja": "付録B.この更新プログラムの変更"
    },
    {
      "indent": 0,
      "text": "B.1. Revisions Made to Section 11 of RFC 5661",
      "section_title": true,
      "ja": "B.1. RFC 5661のセクション11に行われた修正"
    },
    {
      "indent": 3,
      "text": "A number of areas have been revised or extended, in many cases replacing subsections within Section 11 of RFC 5661 [66]:",
      "ja": "多くの場合、RFC 5661のセクション11内のサブセクションを置き換えるいくつかの場合、いくつかのエリアが修正または拡張されました[66]："
    },
    {
      "indent": 3,
      "text": "* New introductory material, including a terminology section, replaces the material in RFC 5661 [66], ranging from the start of the original Section 11 up to and including Section 11.1. The new material starts at the beginning of Section 11 and continues through 11.2.",
      "ja": "* ターミロロジーセクションを含む新しい紹介資料は、オリジナルセクション11の開始からセクション11.1の開始までの範囲のRFC 5661 [66]の材料を置き換えます。新しい材料はセクション11の始めから始まり、11.2を継続します。"
    },
    {
      "indent": 3,
      "text": "* A significant reorganization of the material in Sections 11.4 and 11.5 of RFC 5661 [66] was necessary. The reasons for the reorganization of these sections into a single section with multiple subsections are discussed in Appendix B.1.1 below. This replacement appears as Section 11.5.",
      "ja": "* RFC 5661 [66]のセクション11.4および11.5中の材料の有意な再編成が必要でした。これらのセクションを複数のサブセクションで単一セクションに再編成する理由については、以下の付録B.1.1に説明します。この置換はセクション11.5として表示されます。"
    },
    {
      "indent": 6,
      "text": "New material relating to the handling of the file system location attributes is contained in Sections 11.5.1 and 11.5.7.",
      "ja": "ファイルシステムの場所の属性の処理に関する新しい資料は、セクション11.5.1および11.5.7に含まれています。"
    },
    {
      "indent": 3,
      "text": "* A new section describing requirements for user and group handling within a multi-server namespace has been added as Section 11.7.",
      "ja": "* マルチサーバー名前空間内のユーザーおよびグループ処理の要件を説明する新しいセクションがセクション11.7として追加されました。"
    },
    {
      "indent": 3,
      "text": "* A major replacement for Section 11.7 of RFC 5661 [66], entitled \"Effecting File System Transitions\", appears as Sections 11.9 through 11.14. The reasons for the reorganization of this section into multiple sections are discussed in Appendix B.1.2.",
      "ja": "* 「ファイルシステムの遷移を効果的にする」という権利があるRFC 5661のセクション11.7の主要な置き換えは、セクション11.9から11.14として表示されます。このセクションの複数のセクションへの再編成の理由については、付録B.1.2に議論されています。"
    },
    {
      "indent": 3,
      "text": "* A replacement for Section 11.10 of RFC 5661 [66], entitled \"The Attribute fs_locations_info\", appears as Section 11.17, with Appendix B.1.3 describing the differences between the new section and the treatment within [66]. A revised treatment was necessary because the original treatment did not make clear how the added attribute information relates to the case of trunked paths to the same replica. These issues were not addressed in RFC 5661 [66] where the concepts of a replica and a network path used to access a replica were not clearly distinguished.",
      "ja": "* 「属性FS_LOCATIONS_INFO」のセクション11.10のセクション11.10の代替品はセクション11.17として表示され、付録B.1.3は新しいセクションと[66]内の扱いの違いを説明します。元の治療は、追加された属性情報が同じレプリカへのトランクパスの場合にどのように関連するかを明確にしなかったので、修正された治療が必要でした。レプリカの概念とレプリカにアクセスするために使用されるネットワークパスの概念が明確に区別されていないRFC 5661では、これらの問題は解決されていませんでした[66]。"
    },
    {
      "indent": 0,
      "text": "B.1.1. Reorganization of Sections 11.4 and 11.5 of RFC 5661",
      "section_title": true,
      "ja": "B.1.1. RFC 5661のセクション11.4および11.5の再編成"
    },
    {
      "indent": 3,
      "text": "Previously, issues related to the fact that multiple location entries directed the client to the same file system instance were dealt with in Section 11.5 of RFC 5661 [66]. Because of the new treatment of trunking, these issues now belong within Section 11.5.",
      "ja": "以前は、クライアントがクライアントに同じファイルシステムインスタンスに指示されたという事実に関連する問題は、RFC 5661のセクション11.5で処理されました[66]。トランキングの新しい扱いのために、これらの問題は現在セクション11.5内に属しています。"
    },
    {
      "indent": 3,
      "text": "In this new section, trunking is covered in Section 11.5.2 together with the other uses of file system location information described in Sections 11.5.3 through 11.5.6.",
      "ja": "この新しいセクションでは、Trunkingはセクション11.5.2では、セクション11.5.3から11.5.6に記載されているファイルシステムの場所情報の他の用途とともに章で説明されています。"
    },
    {
      "indent": 3,
      "text": "As a result, Section 11.5, which replaces Section 11.4 of RFC 5661 [66], is substantially different than the section it replaces in that some original sections have been replaced by corresponding sections as described below, while new sections have been added:",
      "ja": "その結果、RFC 5661 [66]のセクション11.4が置き換えられたセクション11.5は、いくつかの元のセクションが以下のように対応するセクションに置き換えられていることに代わるセクションと実質的に異なりますが、新しいセクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "* The material in Section 11.5, exclusive of subsections, replaces the material in Section 11.4 of RFC 5661 [66] exclusive of subsections.",
      "ja": "* 第11.5項の資料は、サブセクションを排除し、RFC 5661のセクション11.4の材料をサブセクション除外する。"
    },
    {
      "indent": 3,
      "text": "* Section 11.5.1 is the new first subsection of the overall section.",
      "ja": "* セクション11.5.1は全体のセクションの新しい最初のサブセクションです。"
    },
    {
      "indent": 3,
      "text": "* Section 11.5.2 is the new second subsection of the overall section.",
      "ja": "* セクション11.5.2は全体のセクションの新しい2番目のサブセクションです。"
    },
    {
      "indent": 3,
      "text": "* Each of the Sections 11.5.4, 11.5.5, and 11.5.6 replaces (in order) one of the corresponding Sections 11.4.1, 11.4.2, and 11.4.3 of RFC 5661 [66].",
      "ja": "* 各セクション11.5.4,11.5.5、および11.5.6は、RFC 5661の対応するセクション11.4.1,11.4.2、および11.4.3のいずれかのセクションの1つを置き換える[66]。"
    },
    {
      "indent": 3,
      "text": "* Section 11.5.7 is the new final subsection of the overall section.",
      "ja": "* セクション11.5.7は全体のセクションの新しい最終サブセクションです。"
    },
    {
      "indent": 0,
      "text": "B.1.2. Reorganization of Material Dealing with File System Transitions",
      "section_title": true,
      "ja": "B.1.2. ファイルシステム遷移を扱う材料の再編成"
    },
    {
      "indent": 3,
      "text": "The material relating to file system transition, previously contained in Section 11.7 of RFC 5661 [66] has been reorganized and augmented as described below:",
      "ja": "RFC 5661のセクション11.7のセクション11.7に含まれていたファイルシステム遷移に関する材料は、以下に説明されるように再編成され拡張されています。"
    },
    {
      "indent": 3,
      "text": "* Because there can be a shift of the network access paths used to access a file system instance without any shift between replicas, a new Section 11.9 distinguishes between those cases in which there is a shift between distinct replicas and those involving a shift in network access paths with no shift between replicas.",
      "ja": "* REPLICAS間のシフトを行わずにファイルシステムインスタンスにアクセスするために使用されるネットワークアクセスパスのシフトがある可能性があるため、新しいセクション11.9は、異なるレプリカ間のシフトがある場合とネットワークアクセスパスのシフトを含むものとの間を区別します。レプリカ間のシフトなしで。"
    },
    {
      "indent": 6,
      "text": "As a result, the new Section 11.10 deals with network address transitions, while the bulk of the original Section 11.7 of RFC 5661 [66] has been extensively modified as reflected in Section 11.11, which is now limited to cases in which there is a shift between two different sets of replicas.",
      "ja": "その結果、新しいセクション11.10はネットワークアドレス遷移を扱い、RFC 5661 [66]の元のセクション11.7の大部分は、11.11節に反映されているとおりに広く修正されており、これは現在シフトがある場合に限定されています。2つの異なるレプリカのセット間。"
    },
    {
      "indent": 3,
      "text": "* The additional Section 11.12 discusses the case in which a shift to a different replica is made and state is transferred to allow the client the ability to have continued access to its accumulated locking state on the new server.",
      "ja": "* 追加のセクション11.12は、異なるレプリカへのシフトが行われ、状態が転送されてクライアントが新しいサーバ上で蓄積されたロック状態へのアクセスを継続することを可能にする場合について説明する。"
    },
    {
      "indent": 3,
      "text": "* The additional Section 11.13 discusses the client's response to access transitions, how it determines whether migration has occurred, and how it gets access to any transferred locking and session state.",
      "ja": "* 追加のセクション11.13は、アクセス遷移へのクライアントの応答、移行が発生したかどうか、および転送されたロックとセッション状態へのアクセス方法をどのように決定するかについて説明します。"
    },
    {
      "indent": 3,
      "text": "* The additional Section 11.14 discusses the responsibilities of the source and destination servers when transferring locking and session state.",
      "ja": "* 追加のセクション11.14は、ロックおよびセッション状態を転送するときの送信元サーバおよび宛先サーバの責任を説明する。"
    },
    {
      "indent": 3,
      "text": "This reorganization has caused a renumbering of the sections within Section 11 of [66] as described below:",
      "ja": "この再編成により、以下に説明するように[66]のセクション11内のセクションの番号が付け加われている。"
    },
    {
      "indent": 3,
      "text": "* The new Sections 11.9 and 11.10 have resulted in the renumbering of existing sections with these numbers.",
      "ja": "* 新しいセクション11.9と11.10は、これらの数字を持つ既存のセクションの番号を変更しました。"
    },
    {
      "indent": 3,
      "text": "* Section 11.7 of [66] has been substantially modified and appears as Section 11.11. The necessary modifications reflect the fact that this section only deals with transitions between replicas, while transitions between network addresses are dealt with in other sections. Details of the reorganization are described later in this section.",
      "ja": "* [66]のセクション11.7は実質的に修正され、セクション11.11として表示されます。必要な変更は、このセクションがレプリカ間の遷移のみを扱うという事実を反映していますが、ネットワークアドレス間の遷移は他のセクションで対処されています。再編成の詳細は後述する。"
    },
    {
      "indent": 3,
      "text": "* Sections 11.12, 11.13, and 11.14 have been added.",
      "ja": "* セクション11.12,11.13、および11.14が追加されました。"
    },
    {
      "indent": 3,
      "text": "* Consequently, Sections 11.8, 11.9, 11.10, and 11.11 in [66] now appear as Sections 11.15, 11.16, 11.17, and 11.18, respectively.",
      "ja": "* したがって、[66]のセクション11.8,11.9,11.10、および11.11は、それぞれセクション11.15,11.16,11.17、および11.18として表示されます。"
    },
    {
      "indent": 3,
      "text": "As part of this general reorganization, Section 11.7 of RFC 5661 [66] has been modified as described below:",
      "ja": "この一般的な再編成の一部として、RFC 5661のセクション11.7 [66]は以下のように修正されています。"
    },
    {
      "indent": 3,
      "text": "* Sections 11.7 and 11.7.1 of RFC 5661 [66] have been replaced by Sections 11.11 and 11.11.1, respectively.",
      "ja": "* RFC 5661のセクション11.7および11.7.1 [66]は、それぞれセクション11.11および11.11.1に置き換えられています。"
    },
    {
      "indent": 3,
      "text": "* Section 11.7.2 of RFC 5661 (and included subsections) has been deleted.",
      "ja": "* RFC 5661（および添付のサブセクション）のセクション11.7.2が削除されました。"
    },
    {
      "indent": 3,
      "text": "* Sections 11.7.3, 11.7.4, 11.7.5, 11.7.5.1, and 11.7.6 of RFC 5661 [66] have been replaced by Sections 11.11.2, 11.11.3, 11.11.4, 11.11.4.1, and 11.11.5 respectively in this document.",
      "ja": "* RFC 5661のセクション11.7.4,11.7.5,11.7.5.1、11.7.6、11.7.6はセクション11.11.2,11.11.3,11.11.4,11.11.4.1、および11.11に置き換えられました。この文書ではそれぞれ。"
    },
    {
      "indent": 3,
      "text": "* Section 11.7.7 of RFC 5661 [66] has been replaced by Section 11.11.9. This subsection has been moved to the end of the section dealing with file system transitions.",
      "ja": "* RFC 5661のセクション11.7.7 [66]はセクション11.11.9に置き換えられました。このサブセクションは、ファイルシステムの遷移を扱うセクションの最後に移動されました。"
    },
    {
      "indent": 3,
      "text": "* Sections 11.7.8, 11.7.9, and 11.7.10 of RFC 5661 [66] have been replaced by Sections 11.11.6, 11.11.7, and 11.11.8 respectively in this document.",
      "ja": "* RFC 5661のセクション11.7.8,11.7.9、および11.7.10 [66]は、このドキュメントでは、それぞれ11.11.6,11.11.7、および11.11.8に置き換えられました。"
    },
    {
      "indent": 0,
      "text": "B.1.3. Updates to the Treatment of fs_locations_info",
      "section_title": true,
      "ja": "B.1.3. FS_LOCATIONS_INFOの扱いの更新"
    },
    {
      "indent": 3,
      "text": "Various elements of the fs_locations_info attribute contain information that applies to either a specific file system replica or to a network path or set of network paths used to access such a replica. The original treatment of fs_locations_info (Section 11.10 of RFC 5661 [66]) did not clearly distinguish these cases, in part because the document did not clearly distinguish replicas from the paths used to access them.",
      "ja": "fs_locations_info属性のさまざまな要素には、特定のファイルシステムレプリカまたはそのようなレプリカにアクセスするために使用されるネットワークパスまたはネットワークパスのセットのいずれかに適用される情報が含まれています。文書がそれらにアクセスするために使用されるパスから複製を明確に区別していないため、FS_LOCATIONS_INFOの元の処理（RFC 5661 [66]）は、これらのケースを明確に区別していませんでした。"
    },
    {
      "indent": 3,
      "text": "In addition, special clarification has been provided with regard to the following fields:",
      "ja": "さらに、以下のフィールドに関して特別な説明が提供されています。"
    },
    {
      "indent": 3,
      "text": "* With regard to the handling of FSLI4GF_GOING, it was clarified that this only applies to the unavailability of a replica rather than to a path to access a replica.",
      "ja": "* FSLI4GF_GOINGの処理に関しては、これがレプリカにアクセスするためのパスにはなく、レプリカの使用不可能性にのみ適用されることが明らかにされました。"
    },
    {
      "indent": 3,
      "text": "* In describing the appropriate value for a server to use for fli_valid_for, it was clarified that there is no need for the client to frequently fetch the fs_locations_info value to be prepared for shifts in trunking patterns.",
      "ja": "* FLI_VALID_FORに使用するサーバの適切な値を記述する際に、トランキングパターンのシフトのために準備するために準備されるFS_LOCATIONS_INFO値を頻繁にフェッチする必要がないことが明らかにされました。"
    },
    {
      "indent": 3,
      "text": "* Clarification of the rules for extensions to the fls_info has been provided. The original treatment reflected the extension model that was in effect at the time RFC 5661 [66] was written, but has been updated in accordance with the extension model described in RFC 8178 [67].",
      "ja": "* FLS_INFOへの拡張の規則の明確化が提供されています。元の処理は、RFC 5661 [66]が書き込まれたが、RFC8178で説明されている拡張モデルに従って更新されたが、更新された延長モデルを反映した。"
    },
    {
      "indent": 0,
      "text": "B.2. Revisions Made to Operations in RFC 5661",
      "section_title": true,
      "ja": "B.2. RFC 5661での操作に加えられた修正"
    },
    {
      "indent": 3,
      "text": "Descriptions have been revised to address issues that arose in effecting necessary changes to multi-server namespace features.",
      "ja": "Multi-Serverネームスペース機能に必要な変更を中止する際の問題に対処するための説明が改訂されました。"
    },
    {
      "indent": 3,
      "text": "* The treatment of EXCHANGE_ID (Section 18.35 of RFC 5661 [66]) assumed that client IDs cannot be created/confirmed other than by the EXCHANGE_ID and CREATE_SESSION operations. Also, the necessary use of EXCHANGE_ID in recovery from migration and related situations was not clearly addressed. A revised treatment of EXCHANGE_ID was necessary, and it appears in Section 18.35, while the specific differences between it and the treatment within [66] are explained in Appendix B.2.1 below.",
      "ja": "* Exchange IDの扱い（RFC 5661のセクション18.35 [66]）は、Exchange_IDとCREATE_SESSION操作によってクライアントIDを作成/確認できないと仮定しました。また、移行と関連状況からの回復時のExchange_IDの必要な使用は明確に対処されていませんでした。Exchange_IDの修正された治療が必要であり、第18.35節に現れ、その間の特定の違いと[66]の治療は下記の付録B.2.1に説明されています。"
    },
    {
      "indent": 3,
      "text": "* The treatment of RECLAIM_COMPLETE in Section 18.51 of RFC 5661 [66] was not sufficiently clear about the purpose and use of the rca_one_fs and how the server was to deal with inappropriate values of this argument. Because the resulting confusion raised interoperability issues, a new treatment of RECLAIM_COMPLETE was necessary, and it appears in Section 18.51, while the specific differences between it and the treatment within RFC 5661 [66] are discussed in Appendix B.2.2 below. In addition, the definitions of the reclaim-related errors have received an updated treatment in Section 15.1.9 to reflect the fact that there are multiple contexts for lock reclaim operations.",
      "ja": "* RFC 5661のセクション18.51のRECLAIM_COMPLETEの扱いは、RCA_ONE_FSの目的と使用、およびサーバーがこの引数の不適切な値をどのように扱うかについて十分に明確ではありませんでした。結果として生じる混乱が相互運用性の問題が発生したため、Reclaim_Completeの新しい扱いが必要であり、それは18.51節に現れ、それは以下の付録B.2.2でそれとの間の具体的な違いを議論している。さらに、Reclaim関連のエラーの定義は、ロック再利用演算に複数のコンテキストがあるという事実を反映するために、セクション15.1.9で更新された処理を受け取りました。"
    },
    {
      "indent": 0,
      "text": "B.2.1. Revision of Treatment of EXCHANGE_ID",
      "section_title": true,
      "ja": "B.2.1. Exchange_IDの治療の改訂"
    },
    {
      "indent": 3,
      "text": "There was a number of issues in the original treatment of EXCHANGE_ID in RFC 5661 [66] that caused problems for Transparent State Migration and for the transfer of access between different network access paths to the same file system instance.",
      "ja": "RFC 5661のExchange_IDの元の扱いには、透過的な状態移行の問題、および異なるネットワークアクセスパス間のアクセスの転送と同じファイルシステムインスタンスへのアクセスの転送がありました。"
    },
    {
      "indent": 3,
      "text": "These issues arose from the fact that this treatment was written:",
      "ja": "これらの問題は、この治療法が書かれたという事実から生まれました。"
    },
    {
      "indent": 3,
      "text": "* Assuming that a client ID can only become known to a server by having been created by executing an EXCHANGE_ID, with confirmation of the ID only possible by execution of a CREATE_SESSION.",
      "ja": "* Exchange_IDを実行して作成されたことによってクライアントIDがサーバに知られることができると仮定すると、CREATE_SESSIONの実行によってのみ可能な限り可能な限りの場合に。"
    },
    {
      "indent": 3,
      "text": "* Considering the interactions between a client and a server only occurring on a single network address.",
      "ja": "* クライアントとサーバーとの間のインタラクションを単一のネットワークアドレスでのみ発生します。"
    },
    {
      "indent": 3,
      "text": "As these assumptions have become invalid in the context of Transparent State Migration and active use of trunking, the treatment has been modified in several respects:",
      "ja": "これらの仮定が透明な状態の移行とトランキングの積極的な使用において無効になっているので、治療はいくつかの点で修正されています。"
    },
    {
      "indent": 3,
      "text": "* It had been assumed that an EXCHANGE_ID executed when the server was already aware that a given client instance was either updating associated parameters (e.g., with respect to callbacks) or dealing with a previously lost reply by retransmitting. As a result, any slot sequence returned by that operation would be of no use. The original treatment went so far as to say that it \"MUST NOT\" be used, although this usage was not in accord with [1]. This created a difficulty when an EXCHANGE_ID is done after Transparent State Migration since that slot sequence would need to be used in a subsequent CREATE_SESSION.",
      "ja": "* サーバーが、特定のクライアントインスタンスが関連パラメータを更新していた（例えば、コールバックに関して）、または再送信によって以前に失われた返信を扱うことが既に認識されている場合に実行されたExchange_idが想定されていました。その結果、その操作によって返されたスロットシーケンスはすべて使用されません。元の治療法は、「1」と一致していませんでしたが、それが使用されてはいけませんでした。これにより、そのスロットシーケンスを後続のCREATE_SESSIONで使用する必要があるため、透過状態の移行後にExchange_IDが実行されたときに問題が発生しました。"
    },
    {
      "indent": 6,
      "text": "In the updated treatment, CREATE_SESSION is a way that client IDs are confirmed, but it is understood that other ways are possible. The slot sequence can be used as needed, and cases in which it would be of no use are appropriately noted.",
      "ja": "更新された治療では、CREATE_SESSIONはクライアントIDが確認された方法ですが、他の方法が可能であることがわかります。スロットシーケンスは必要に応じて使用することができ、そしてそれが使用されていない場合が適切に記録されている。"
    },
    {
      "indent": 3,
      "text": "* It had been assumed that the only functions of EXCHANGE_ID were to inform the server of the client, to create the client ID, and to communicate it to the client. When multiple simultaneous connections are involved, as often happens when trunking, that treatment was inadequate in that it ignored the role of EXCHANGE_ID in associating the client ID with the connection on which it was done, so that it could be used by a subsequent CREATE_SESSION whose parameters do not include an explicit client ID.",
      "ja": "* Exchange_IDの唯一の機能はクライアントのサーバーに通知し、クライアントIDを作成し、クライアントに通信することが想定されていました。複数の同時接続が関与している場合、トランキング時に頻繁に起こるとき、その扱いは、それが行われた接続でクライアントIDを関連付けられた接続と関連付けられているように、その扱いが不十分であるため、パラメータには、明示的なクライアントIDが含まれていません。"
    },
    {
      "indent": 6,
      "text": "The new treatment explicitly discusses the role of EXCHANGE_ID in associating the client ID with the connection so it can be used by CREATE_SESSION and in associating a connection with an existing session.",
      "ja": "新しい治療法は、CREATE_SESSIONで使用できるようにクライアントIDと接続を既存のセッションと関連付けるために使用できるように、CREATE_SESSIONで使用できるように、Exchange_IDの役割を明示的に説明します。"
    },
    {
      "indent": 3,
      "text": "The new treatment can be found in Section 18.35 above. It supersedes the treatment in Section 18.35 of RFC 5661 [66].",
      "ja": "新しい治療法は上記の18.35節にあります。それはRFC 5661の第18.35号の治療に優しています[66]。"
    },
    {
      "indent": 0,
      "text": "B.2.2. Revision of Treatment of RECLAIM_COMPLETE",
      "section_title": true,
      "ja": "B.2.2. reclaim_completeの治療の改訂"
    },
    {
      "indent": 3,
      "text": "The following changes were made to the treatment of RECLAIM_COMPLETE in RFC 5661 [66] to arrive at the treatment in Section 18.51:",
      "ja": "RFC 5661のRECLAIM_COMPLETEの治療には、18.51節の治療に到達するためのreclaim_completeの治療が行われました。"
    },
    {
      "indent": 3,
      "text": "* In a number of places, the text was made more explicit about the purpose of rca_one_fs and its connection to file system migration.",
      "ja": "* いくつかの場所では、テキストはRCA_ONE_FSの目的とファイルシステムの移行への接続について明示的に作成されました。"
    },
    {
      "indent": 3,
      "text": "* There is a discussion of situations in which particular forms of RECLAIM_COMPLETE would need to be done.",
      "ja": "* 特定の形態のreclaim_completeを実行する必要があるという状況についての議論がある。"
    },
    {
      "indent": 3,
      "text": "* There is a discussion of interoperability issues between implementations that may have arisen due to the lack of clarity of the previous treatment of RECLAIM_COMPLETE.",
      "ja": "* Reclaim_Completeの以前の治療の明確さの欠如のために発生した可能性がある実装間の相互運用性の問題についての議論がある。"
    },
    {
      "indent": 0,
      "text": "B.3. Revisions Made to Error Definitions in RFC 5661",
      "section_title": true,
      "ja": "B.3. RFC 5661のエラー定義に行われた改訂"
    },
    {
      "indent": 3,
      "text": "The new handling of various situations required revisions to some existing error definitions:",
      "ja": "さまざまな状況の新しい処理に必要な既存のエラー定義を修正しました。"
    },
    {
      "indent": 3,
      "text": "* Because of the need to appropriately address trunking-related issues, some uses of the term \"replica\" in RFC 5661 [66] became problematic because a shift in network access paths was considered to be a shift to a different replica. As a result, the original definition of NFS4ERR_MOVED (in Section 15.1.2.4 of RFC 5661 [66]) was updated to reflect the different handling of unavailability of a particular fs via a specific network address.",
      "ja": "* トランキング関連の問題に適切にアドレス指定する必要があるため、ネットワークアクセスパスのシフトが異なるレプリカへのシフトであると考えられているため、RFC 5661 [66]の用語「レプリカ」という用語のいくつかの用途が問題になりました。その結果、特定のネットワークアドレスを介した特定のFSの使用不可能性の異なる処理を反映するように、NFS4ERR_MOVED（RFC 5661 [66]のセクション15661のセクション）の元の定義が更新されました。"
    },
    {
      "indent": 6,
      "text": "Since such a situation is no longer considered to constitute unavailability of a file system instance, the description has been changed, even though the set of circumstances in which it is to be returned remains the same. The new paragraph explicitly recognizes that a different network address might be used, while the previous description, misleadingly, treated this as a shift between two replicas while only a single file system instance might be involved. The updated description appears in Section 15.1.2.4.",
      "ja": "このような状況は、ファイルシステムインスタンスの利用不可能を構成するとは考えられないので、返却されるべき状況のセットは同じままであっても説明が変更されました。新しい段落は、異なるネットワークアドレスが使用されている可能性があることを明示的に認識しますが、前の説明は誤解を誤解して、これを2つのレプリカ間のシフトとして処理し、単一のファイルシステムインスタンスのみが関与している可能性があります。更新された説明は、15.1.2.4項に表示されます。"
    },
    {
      "indent": 3,
      "text": "* Because of the need to accommodate the use of fs-specific grace periods, it was necessary to clarify some of the definitions of reclaim-related errors in Section 15 of RFC 5661 [66] so that the text applies properly to reclaims for all types of grace periods. The updated descriptions appear within Section 15.1.9.",
      "ja": "* FS特有の猶予期間の使用に対応する必要があるため、RFC 5661のセクション15の再利用関連エラーの定義の一部を明確にする必要がありました。猶予期間更新された説明はセクション15.1.9に表示されます。"
    },
    {
      "indent": 3,
      "text": "* Because of the need to provide the clarifications in errata report 2006 [64] and to adapt these to properly explain the interaction of NFS4ERR_DELAY with the reply cache, a revised description of NFS4ERR_DELAY appears in Section 15.1.1.3. This errata report, unlike many other RFC 5661 errata reports, is addressed in this document because of the extensive use of NFS4ERR_DELAY in connection with state migration and session migration.",
      "ja": "* Errata Report 2006での明確化を提供し、これらを適応させるためにこれらを適応させて、NFS4ERR_DELAYと応答キャッシュとの対話を適切に説明するために、NFS4ERR_DELAYの改訂された説明がセクション15.1.1.3に表示されます。このエラータレポートは、他の多くのRFC 5661のエラータレポートとは異なり、この文書では、状態移行とセッションの移行に関連してNFS4ERR_DELAYを広く使用しています。"
    },
    {
      "indent": 0,
      "text": "B.4. Other Revisions Made to RFC 5661",
      "section_title": true,
      "ja": "B.4. RFC 5661に行われたその他の改訂"
    },
    {
      "indent": 3,
      "text": "Besides the major reworking of Section 11 of RFC 5661 [66] and the associated revisions to existing operations and errors, there were a number of related changes that were necessary:",
      "ja": "RFC 5661のセクション11のメジャーリワーク（66]と既存の業務とエラーへの関連リビジョンのほかに、必要な変更がいくつかありました。"
    },
    {
      "indent": 3,
      "text": "* The summary in Section 1.7.3.3 of RFC 5661 [66] was revised to reflect the changes made to Section 11 above. The updated summary appears as Section 1.8.3.3 above.",
      "ja": "* RFC 5661のセクション1.7.3.3の概要[66]は、上記のセクション11に加えられた変更を反映するように修正されました。更新された概要は上記のセクション1.8.3.3として表示されます。"
    },
    {
      "indent": 3,
      "text": "* The discussion of server scope in Section 2.10.4 of RFC 5661 [66] was replaced since it appeared to require a level of inter-server coordination incompatible with its basic function of avoiding the need for a globally uniform means of assigning server_owner values. A revised treatment appears in Section 2.10.4.",
      "ja": "* RFC 5661のセクション2.10.4のサーバーの範囲の説明は、Server_owner値を割り当てるためのグローバルに均一な手段の必要性を回避するという基本的な機能と互換性のないレベルのサーバー調整を必要とするように見えたので置き換えられました。修正された治療はセクション2.10.4に表示されます。"
    },
    {
      "indent": 3,
      "text": "* The discussion of trunking in Section 2.10.5 of RFC 5661 [66] was revised to more clearly explain the multiple types of trunking support and how the client can be made aware of the existing trunking configuration. In addition, while the last paragraph (exclusive of subsections) of that section dealing with server_owner changes was literally true, it had been a source of confusion. Since the original paragraph could be read as suggesting that such changes be handled nondisruptively, the issue was clarified in the revised Section 2.10.5.",
      "ja": "* RFC 5661のセクション2.10.5のトランキングの議論は、複数のタイプのトランキングサポートとクライアントが既存のトランキング構成を認識する方法をより明確に説明するように修正されました。さらに、Server_ownerの変更を扱うそのセクションの最後の段落（サブセクションを除く）は文字通り真実でしたが、混乱の原因でした。元の段落は、そのような変更が無断的に処理されることを示唆として読むことができるので、この問題は改訂区間2.10.5で明確にされました。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Security Issues That Need to Be Addressed",
      "section_title": true,
      "ja": "付録C.対処する必要があるセキュリティ上の問題"
    },
    {
      "indent": 3,
      "text": "The following issues in the treatment of security within the NFSv4.1 specification need to be addressed:",
      "ja": "NFSV4.1仕様内のセキュリティの扱い中の以下の問題に対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The Security Considerations Section of RFC 5661 [66] was not written in accordance with RFC 3552 (BCP 72) [72]. Of particular concern was the fact that the section did not contain a threat analysis.",
      "ja": "* RFC 5661のセキュリティ上の考察セクション[66]は、RFC 3552（BCP 72）に従って書かれていません[72]。特定の懸念のうち、セクションに脅威分析が含まれていなかったという事実がありました。"
    },
    {
      "indent": 3,
      "text": "* Initial analysis of the existing security issues with NFSv4.1 has made it likely that a revised Security Considerations section for the existing protocol (one containing a threat analysis) would be likely to conclude that NFSv4.1 does not meet the goal of secure use on the Internet.",
      "ja": "* NFSV4.1に関する既存のセキュリティ問題の初期分析は、既存のプロトコルの修正セキュリティ上の考察セクション（脅威分析を含むもの）がNFSV4.1が安全な使用の目標を満たしていないと結論付ける可能性があります。インターネット。"
    },
    {
      "indent": 3,
      "text": "The Security Considerations section of this document (Section 21) has not been thoroughly revised to correct the difficulties mentioned above. Instead, it has been modified to take proper account of issues related to the multi-server namespace features discussed in Section 11, leaving the incomplete discussion and security weaknesses pretty much as they were.",
      "ja": "本書のセキュリティ上の考察セクション（セクション21）は、上記の困難を修正するために徹底的に改訂されていません。代わりに、セクション11で説明したマルチサーバーネームスペース機能に関連する問題を適切に考慮して、不完全な議論とセキュリティの弱点を残したままにしています。"
    },
    {
      "indent": 3,
      "text": "The following major security issues need to be addressed in a satisfactory fashion before an updated Security Considerations section can be published as part of a bis document for NFSv4.1:",
      "ja": "次の主要なセキュリティ問題は、更新されたセキュリティ上の考慮事項のセクションがNFSV4.1のBISドキュメントの一部として公開できる前に満足のいく方法で対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The continued use of AUTH_SYS and the security exposures it creates need to be addressed. Addressing this issue must not be limited to the questions of whether the designation of this as OPTIONAL was justified and whether it should be changed.",
      "ja": "* AUTH_SYSとセキュリティエクスポージャーを継続して使用する必要があります。この問題を解決するには、オプションの指定が正当化され、変更する必要があるかどうかの質問に限定されてはなりません。"
    },
    {
      "indent": 6,
      "text": "In any event, it may not be possible at this point to correct the security problems created by continued use of AUTH_SYS simply by revising this designation.",
      "ja": "いずれにせよ、この指定を修正するだけで、auth_sysの継続的な使用によって作成されたセキュリティ上の問題を修正することはこの時点では不可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "* The lack of attention within the protocol to the possibility of pervasive monitoring attacks such as those described in RFC 7258 [71] (also BCP 188).",
      "ja": "* RFC 7258で記載されているもののような普及しているモニタリング攻撃の可能性に対する議定書内の注意がない[71]（BCP 188）。"
    },
    {
      "indent": 6,
      "text": "In that connection, the use of CREATE_SESSION without privacy protection needs to be addressed as it exposes the session ID to view by an attacker. This is worrisome as this is precisely the type of protocol artifact alluded to in RFC 7258, which can enable further mischief on the part of the attacker as it enables denial-of-service attacks that can be executed effectively with only a single, normally low-value, credential, even when RPCSEC_GSS authentication is in use.",
      "ja": "その接続では、プライバシー保護なしでCREATE_SESSIONを使用すると、セッションIDが攻撃者によって表示されるためにアドレス指定される必要があります。これは、RFC 7258に参加したプロトコルアーティファクトの種類が正確にあります。-Value、RPCSEC_GSS認証が使用されている場合でも、信任状。"
    },
    {
      "indent": 3,
      "text": "* The lack of effective use of privacy and integrity, even where the infrastructure to support use of RPCSEC_GSS is present, needs to be addressed.",
      "ja": "* RPCSEC_GSSの使用をサポートするインフラストラクチャが存在する場合でも、プライバシーと完全性の効果的な使用の欠如が存在する場合でも、アドレス指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "In light of the security exposures that this situation creates, it is not enough to define a protocol that could address this problem with the provision of sufficient resources. Instead, what is needed is a way to provide the necessary security with very limited performance costs and without requiring security infrastructure, which experience has shown is difficult for many clients and servers to provide.",
      "ja": "この状況が発生するセキュリティエクスポージャーを考慮して、十分なリソースを提供することでこの問題に対処できるプロトコルを定義するのに十分ではありません。代わりに、必要なセキュリティを非常に限られたパフォーマンスコストと共に必要なセキュリティを提供する方法は、セキュリティインフラストラクチャを必要とせずに、どの経験が示されているかが多くのクライアントやサーバーが提供することが困難です。"
    },
    {
      "indent": 3,
      "text": "In trying to provide a major security upgrade for a deployed protocol such as NFSv4.1, the working group and the Internet community are likely to find themselves dealing with a number of considerations such as the following:",
      "ja": "NFSV4.1などのデプロイされたプロトコルのための主要なセキュリティアップグレードを提供しようとすると、ワーキンググループとインターネットコミュニティは、次のようないくつかの考慮事項を扱う可能性があります。"
    },
    {
      "indent": 3,
      "text": "* The need to accommodate existing deployments of protocols specified previously in existing Proposed Standards.",
      "ja": "* 以前に指定されたプロトコルの既存の展開を既存の提案基準に適応させる必要性。"
    },
    {
      "indent": 3,
      "text": "* The difficulty of effecting changes to existing, interoperating implementations.",
      "ja": "* 既存の相互運用実装への変更をもたらすことの難しさ。"
    },
    {
      "indent": 3,
      "text": "* The difficulty of making changes to NFSv4 protocols other than those in the form of OPTIONAL extensions.",
      "ja": "* オプションの拡張子の形式のもの以外のNFSV4プロトコルを変更することの難しさ。"
    },
    {
      "indent": 3,
      "text": "* The tendency of those responsible for existing NFSv4 deployments to ignore security flaws in the context of local area networks under the mistaken impression that network isolation provides, in and of itself, isolation from all potential attackers.",
      "ja": "* 既存のNFSV4展開に責任がある責任のある責任のある傾向は、ネットワークの分離が提供されているという誤った印象のもと、誤った攻撃者からの隔離の誤った印象の下でセキュリティ上の欠陥を無視する傾向があります。"
    },
    {
      "indent": 3,
      "text": "Given that the above-mentioned difficulties apply to minor version zero as well, it may make sense to deal with these security issues in a common document that applies to all NFSv4 minor versions. If that approach is taken, the Security Considerations section of an eventual NFv4.1 bis document would reference that common document, and the defining RFCs for other minor versions might do so as well.",
      "ja": "上記の困難がマイナーバージョンゼロにも当てはまることを考えると、すべてのNFSv4マイナーバージョンに適用される一般的な文書でこれらのセキュリティ上の問題に対処することは理にかなっています。そのアプローチが行われた場合、最終的なNFV4.1 BISドキュメントのセキュリティ上の考慮事項セクションはその一般的な文書を参照し、他のマイナーバージョンの定義RFCも同様にそうする可能性があります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 0,
      "text": "Acknowledgments for This Update",
      "ja": "このアップデートの謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to acknowledge the important role of Andy Adamson of Netapp in clarifying the need for trunking discovery functionality, and exploring the role of the file system location attributes in providing the necessary support.",
      "ja": "著者らは、NetAppのAndy AdamsonのAndy Adamsonの重要な役割を明確にし、必要なサポートを提供する際のファイルシステムの場所属性の役割を調べたいと考えています。"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Tom Haynes of Hammerspace for drawing our attention to the fact that internationalization and security might best be handled in documents dealing with such protocol issues as they apply to all NFSv4 minor versions.",
      "ja": "著者は、国際化とセキュリティがすべてのNFSV4のマイナーバージョンに適用されるときに、国際化とセキュリティがこのようなプロトコルの問題を扱う文書で最もよく処理される可能性があるという事実に注意を描いてくれてありがとうございました。"
    },
    {
      "indent": 3,
      "text": "The authors also wish to acknowledge the work of Xuan Qi of Oracle with NFSv4.1 client and server prototypes of Transparent State Migration functionality.",
      "ja": "著者らはまた、透明状態移行機能のNFSv4.1クライアントおよびサーバープロトタイプを使用して、OracleのXuan QIの作品を承認したいと考えています。"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank others that brought attention to important issues. The comments of Trond Myklebust of Primary Data related to trunking helped to clarify the role of DNS in trunking discovery. Rick Macklem's comments brought attention to problems in the handling of the per-fs version of RECLAIM_COMPLETE.",
      "ja": "著者は重要な問題に注意をもたらした他の人に感謝したいと思います。トランキングに関連する主要データのトランプマイクルバストのコメントは、トランキング発見におけるDNSの役割を明確にするのに役立ちました。Rick Macklemのコメントは、FS PER-FSバージョンのReclaim_Completeの取り扱いの問題に注意をもたらしました。"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Olga Kornievskaia of Netapp for her helpful review comments.",
      "ja": "著者らは、彼女の有用なレビューコメントについてNetAppのOlga Kornievskaiaに感謝します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments for RFC 5661",
      "ja": "RFC 5661の承認"
    },
    {
      "indent": 3,
      "text": "The initial text for the SECINFO extensions were edited by Mike Eisler with contributions from Peng Dai, Sergey Klyushin, and Carl Burnett.",
      "ja": "SECINFO拡張の初期テキストは、Peng Dai、Sergey Klyushin、Carl Burnettからの貢献を持つMike Eislerによって編集されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the SESSIONS extensions were edited by Tom Talpey, Spencer Shepler, Jon Bauman with contributions from Charles Antonelli, Brent Callaghan, Mike Eisler, John Howard, Chet Juszczak, Trond Myklebust, Dave Noveck, John Scott, Mike Stolarchuk, and Mark Wittle.",
      "ja": "Sessions拡張機能の最初のテキストは、Tom Talpey、Spencer Shepler、Jon Bauuman、Brent Callaghan、Mike Eisler、John Howard、Chet Juszczak、Trond Myklebust、Dave Noveck、John Scott、Mark、Markウィットリング。"
    },
    {
      "indent": 3,
      "text": "Initial text relating to multi-server namespace features, including the concept of referrals, were contributed by Dave Noveck, Carl Burnett, and Charles Fan with contributions from Ted Anderson, Neil Brown, and Jon Haswell.",
      "ja": "紹介の概念を含むマルチサーバーネームスペース機能に関連する最初のテキストは、Ted Anderson、Neil Brown、Jon Haswellからの貢献を持つDave Noveck、Carl Burnett、Charles Fanによって貢献されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the Directory Delegations support were contributed by Saadia Khan with input from Dave Noveck, Mike Eisler, Carl Burnett, Ted Anderson, and Tom Talpey.",
      "ja": "ディレクトリ代表団の初期テキストは、Dave Noveck、Mike Eisler、Carl Burnett、Ted Anderson、Tom Talpeyからの入力を伴うSaadia Khanによって貢献されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the ACL explanations were contributed by Sam Falkner and Lisa Week.",
      "ja": "ACLの説明の最初のテキストはSam FalknerとLisa Weekによって寄稿されました。"
    },
    {
      "indent": 3,
      "text": "The pNFS work was inspired by the NASD and OSD work done by Garth Gibson. Gary Grider has also been a champion of high-performance parallel I/O. Garth Gibson and Peter Corbett started the pNFS effort with a problem statement document for the IETF that formed the basis for the pNFS work in NFSv4.1.",
      "ja": "PNFSの作業は、Garth Gibsonによって行われたNASDおよびOSDの仕事に触発されました。ゲイリーグライダーは高性能パラレルI / Oのチャンピオンもありました。Garth GibsonとPeter Corbettは、NFSV4.1でのPNFS作業の基礎を形成したIETFの問題ステートメント文書を用いてPNFSの取り組みを開始しました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the parallel NFS support was edited by Brent Welch and Garth Goodson. Additional authors for those documents were Benny Halevy, David Black, and Andy Adamson. Additional input came from the informal group that contributed to the construction of the initial pNFS drafts; specific acknowledgment goes to Gary Grider, Peter Corbett, Dave Noveck, Peter Honeyman, and Stephen Fridella.",
      "ja": "並列NFSサポートの初期テキストは、Brent WelchとGarth Goodsonによって編集されました。それらの文書の追加作者は、ベニーの空き、デビッドブラック、そしてAndy Adamsonでした。追加の入力は、初期PNFSドラフトの構築に貢献した非公式グループから来ました。具体的な確認応答は、Gary Grider、Peter Corbett、Dave Noveck、Peter Honeyman、およびStephen Fridellaに行きます。"
    },
    {
      "indent": 3,
      "text": "Fredric Isaman found several errors in draft versions of the ONC RPC XDR description of the NFSv4.1 protocol.",
      "ja": "Fredry Isamanは、NFSV4.1プロトコルのONC RPC XDRの説明のドラフトバージョンでいくつかのエラーを見つけました。"
    },
    {
      "indent": 3,
      "text": "Audrey Van Belleghem provided, in numerous ways, essential coordination and management of the process of editing the specification documents.",
      "ja": "Audrey Van Belleghemは、仕様書類を編集するプロセスの例示的な調整と管理を提供しました。"
    },
    {
      "indent": 3,
      "text": "Richard Jernigan gave feedback on the file layout's striping pattern design.",
      "ja": "Richard Jerniganは、ファイルレイアウトのストライピングパターンデザインに関するフィードバックを与えました。"
    },
    {
      "indent": 3,
      "text": "Several formal inspection teams were formed to review various areas of the protocol. All the inspections found significant errors and room for improvement. NFSv4.1's inspection teams were:",
      "ja": "プロトコルのさまざまな分野を見直すために、いくつかの正式な検査チームが形成されました。すべての検査は、改善のために重要なエラーと部屋を見つけました。NFSV4.1の検査チームは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* ACLs, with the following inspectors: Sam Falkner, Bruce Fields, Rahul Iyer, Saadia Khan, Dave Noveck, Lisa Week, Mario Wurzl, and Alan Yoder.",
      "ja": "* ACLは、以下の検査官：Sam Falkner、Bruce Fields、Rahul Iyer、Saadia Khan、Dave Noveck、Lisa Week、Mario Wurzl、およびAlan Yoder。"
    },
    {
      "indent": 3,
      "text": "* Sessions, with the following inspectors: William Brown, Tom Doeppner, Robert Gordon, Benny Halevy, Fredric Isaman, Rick Macklem, Trond Myklebust, Dave Noveck, Karen Rochford, John Scott, and Peter Shah.",
      "ja": "* 以下の検査官：William Brown、Tom Doeppner、Robert Gordon、Robert Gordon、Benny Halevy、Fredric Isaman、Rick Macklem、Trond Myklebust、Dave Noveck、Karen Rochford、John Scott、Peter Shah。"
    },
    {
      "indent": 3,
      "text": "* Initial pNFS inspection, with the following inspectors: Andy Adamson, David Black, Mike Eisler, Marc Eshel, Sam Falkner, Garth Goodson, Benny Halevy, Rahul Iyer, Trond Myklebust, Spencer Shepler, and Lisa Week.",
      "ja": "* 初期PNFS検査、Andy Adamson、David Black、Mike Eisl、Marc Eshel、Sam Falkner、Garth Goodson、Benny Halevy、Rahul Iyer、Trond Myklebust、Spenter Shepler、Lisa Week。"
    },
    {
      "indent": 3,
      "text": "* Global namespace, with the following inspectors: Mike Eisler, Dan Ellard, Craig Everhart, Fredric Isaman, Trond Myklebust, Dave Noveck, Theresa Raj, Spencer Shepler, Renu Tewari, and Robert Thurlow.",
      "ja": "* グローバルな名前空間、次の検査官：Mike Eisler、Dan Ellard、Craig Everhart、Fredric Isaman、Trond Myklebust、Dave Noveck、Raj、Spencerシェアラー、Robert Thurlow。"
    },
    {
      "indent": 3,
      "text": "* NFSv4.1 file layout type, with the following inspectors: Andy Adamson, Marc Eshel, Sam Falkner, Garth Goodson, Rahul Iyer, Trond Myklebust, and Lisa Week.",
      "ja": "* NFSV4.1ファイルレイアウトタイプ、次の検査官：Andy Adamson、Marc Eshel、Sam Falkner、Garth Goodson、Rahul Iyer、Trond Myklebust、Lisa Week。"
    },
    {
      "indent": 3,
      "text": "* NFSv4.1 locking and directory delegations, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Saadia Khan, Eric Kustarz, Dave Noveck, Spencer Shepler, and Amy Weaver.",
      "ja": "* NFSV4.1ロックとディレクトリの代表団、次の検査官：Mike Eisler、Pranoop Erasani、Robert Gordon、Saadia Khan、Eric Kutarz、Dave Noveck、Spencer Shepler、Amy Weaver。"
    },
    {
      "indent": 3,
      "text": "* EXCHANGE_ID and DESTROY_CLIENTID, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Benny Halevy, Fredric Isaman, Saadia Khan, Ricardo Labiaga, Rick Macklem, Trond Myklebust, Spencer Shepler, and Brent Welch.",
      "ja": "* Exchange_IDとDestroy_ClientID、Mike Eisler、Pranoop Erasani、Robert Gordon、Benny Halevy、Fredry Isaman、Saadia Khan、Ricardo Labiaga、Rick Macklem、Trond Myklebust、Spencerシェアラー、Brent Welch。"
    },
    {
      "indent": 3,
      "text": "* Final pNFS inspection, with the following inspectors: Andy Adamson, Mike Eisler, Mark Eshel, Sam Falkner, Jason Glasgow, Garth Goodson, Robert Gordon, Benny Halevy, Dean Hildebrand, Rahul Iyer, Suchit Kaura, Trond Myklebust, Anatoly Pinchuk, Spencer Shepler, Renu Tewari, Lisa Week, and Brent Welch.",
      "ja": "* 以下の検査官を備えた最終的なPNFS検査：Andy Adamson、Mike Eisler、マーク・エシェル、サム・フォルカー、Jason Glasgow、Garth Goodson、Robert Gardon、Benny Halevy、Dean Hildebrand、Rahul Iyer、Spencerシェアラー、Renu Tewari、Lisa Week、Brent Welch。"
    },
    {
      "indent": 3,
      "text": "A review team worked together to generate the tables of assignments of error sets to operations and make sure that each such assignment had two or more people validating it. Participating in the process were Andy Adamson, Mike Eisler, Sam Falkner, Garth Goodson, Robert Gordon, Trond Myklebust, Dave Noveck, Spencer Shepler, Tom Talpey, Amy Weaver, and Lisa Week.",
      "ja": "レビューチームは、エラーセットの割り当てのテーブルを操作に生成し、それぞれのそのような割り当てに2人以上の人々がそれを検証したことを確認しました。このプロセスに参加しているのは、Andy Adamson、Mike Eisler、Sam Falkner、Garth Goodson、Robert Gordon、Trond Myklebust、Dave Noveck、Spencer Shepler、Tom Talpey、Amy Weaver、Lisa Weekです。"
    },
    {
      "indent": 3,
      "text": "Jari Arkko, David Black, Scott Bradner, Lisa Dusseault, Lars Eggert, Chris Newman, and Tim Polk provided valuable review and guidance.",
      "ja": "Jari Arkko、David Black、Scott Bradner、Lisa Dusseault、Lars Eggert、Chris Newman、およびTim Polkは、貴重なレビューとガイダンスを提供しました。"
    },
    {
      "indent": 3,
      "text": "Olga Kornievskaia found several errors in the SSV specification.",
      "ja": "Olga Kornievskaiaは、SSV仕様にいくつかのエラーを見つけました。"
    },
    {
      "indent": 3,
      "text": "Ricardo Labiaga found several places where the use of RPCSEC_GSS was underspecified.",
      "ja": "Ricardo Labiaga RPCSEC_GSSの使用が不明のいくつかの場所を見つけました。"
    },
    {
      "indent": 3,
      "text": "Those who provided miscellaneous comments include: Andy Adamson, Sunil Bhargo, Alex Burlyga, Pranoop Erasani, Bruce Fields, Vadim Finkelstein, Jason Goldschmidt, Vijay K. Gurbani, Sergey Klyushin, Ricardo Labiaga, James Lentini, Anshul Madan, Daniel Muntz, Daniel Picken, Archana Ramani, Jim Rees, Mahesh Siddheshwar, Tom Talpey, and Peter Varga.",
      "ja": "雑多なコメントを提供した人は、Andy Adamson、Sunil Bhargo、Alex Burlyga、Pranoop Erasani、ブルースフィールド、Vadim Finkelstein、Jason Goldschmidt、Vijay K. Gurbani、Ricardo Labiaga、James Lentini、Daniel Muntz、Daniel Picken、Archana Ramani、Jim Rees、Mahesh Siddheshwar、Tom Talpey、Peter Varga。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "David Noveck (editor) NetApp 1601 Trapelo Road, Suite 16 Waltham, MA 02451 United States of America",
      "ja": "David Noveck（編集）NetApp 1601 Trapelo Road、スイート16ウォルサム、MA 02451アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1-781-768-5347\nEmail: dnoveck@netapp.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Charles Lever Oracle Corporation 1015 Granger Avenue Ann Arbor, MI 48104 United States of America",
      "ja": "Charles Lever Oracle Corporation 1015 Granger Avenue Ann Arbor、MI 48104アメリカ"
    },
    {
      "indent": 3,
      "text": "Phone: +1-248-614-5091\nEmail: chuck.lever@oracle.com",
      "raw": true,
      "ja": ""
    }
  ]
}