{
  "title": {
    "text": "RFC 8166 - Remote Direct Memory Access Transport for Remote Procedure Call Version 1",
    "ja": "RFC 8166 - リモートプロシージャコールバージョン1のリモートダイレクトメモリアクセストランスポート"
  },
  "number": 8166,
  "created_at": "2020-08-28 14:57:29.442339+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     C. Lever, Ed.\nRequest for Comments: 8166                                        Oracle\nObsoletes: 5666                                               W. Simpson\nCategory: Standards Track                                        Red Hat\nISSN: 2070-1721                                                T. Talpey\n                                                               Microsoft\n                                                               June 2017",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Remote Direct Memory Access Transport for Remote Procedure Call Version 1",
      "ja": "リモートプロシージャコールバージョン1のリモートダイレクトメモリアクセストランスポート"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a protocol for conveying Remote Procedure Call (RPC) messages on physical transports capable of Remote Direct Memory Access (RDMA). This protocol is referred to as the RPC-over-RDMA version 1 protocol in this document. It requires no revision to application RPC protocols or the RPC protocol itself. This document obsoletes RFC 5666.",
      "ja": "このドキュメントは、リモートダイレクトメモリアクセス（RDMA）が可能な物理トランスポートでリモートプロシージャコール（RPC）メッセージを伝達するためのプロトコルを指定します。このプロトコルは、このドキュメントではRPC-over-RDMAバージョン1プロトコルと呼ばれています。アプリケーションのRPCプロトコルやRPCプロトコル自体を変更する必要はありません。このドキュメントはRFC 5666を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8166.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8166で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。この素材の一部の著作権を管理する人は、IETFトラストにそのような素材の変更を許可する権利を付与していない可能性がありますIETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得しない限り、このドキュメントはIETF標準プロセス外で変更できません。また、その派生物は、IETF標準プロセス外で作成できません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  RPCs on RDMA Transports . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n  2.2.  RPCs  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  2.3.  RDMA  . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n3.  RPC-over-RDMA Protocol Framework  . . . . . . . . . . . . . .  10\n  3.1.  Transfer Models . . . . . . . . . . . . . . . . . . . . .  10\n  3.2.  Message Framing . . . . . . . . . . . . . . . . . . . . .  11\n  3.3.  Managing Receiver Resources . . . . . . . . . . . . . . .  11\n  3.4.  XDR Encoding with Chunks  . . . . . . . . . . . . . . . .  14\n  3.5.  Message Size  . . . . . . . . . . . . . . . . . . . . . .  19\n4.  RPC-over-RDMA in Operation  . . . . . . . . . . . . . . . . .  23\n  4.1.  XDR Protocol Definition . . . . . . . . . . . . . . . . .  23\n  4.2.  Fixed Header Fields . . . . . . . . . . . . . . . . . . .  28\n  4.3.  Chunk Lists . . . . . . . . . . . . . . . . . . . . . . .  30\n  4.4.  Memory Registration . . . . . . . . . . . . . . . . . . .  33\n  4.5.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  34\n  4.6.  Protocol Elements No Longer Supported . . . . . . . . . .  37\n  4.7.  XDR Examples  . . . . . . . . . . . . . . . . . . . . . .  38\n5.  RPC Bind Parameters . . . . . . . . . . . . . . . . . . . . .  39\n6.  ULB Specifications  . . . . . . . . . . . . . . . . . . . . .  41\n  6.1.  DDP-Eligibility . . . . . . . . . . . . . . . . . . . . .  41\n  6.2.  Maximum Reply Size  . . . . . . . . . . . . . . . . . . .  43\n  6.3.  Additional Considerations . . . . . . . . . . . . . . . .  43\n  6.4.  ULP Extensions  . . . . . . . . . . . . . . . . . . . . .  43\n7.  Protocol Extensibility  . . . . . . . . . . . . . . . . . . .  44\n  7.1.  Conventional Extensions . . . . . . . . . . . . . . . . .  44\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  44\n  8.1.  Memory Protection . . . . . . . . . . . . . . . . . . . .  44\n  8.2.  RPC Message Security  . . . . . . . . . . . . . . . . . .  46\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  49\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  50\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  50\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  51\nAppendix A.  Changes from RFC 5666  . . . . . . . . . . . . . . .  53\n  A.1.  Changes to the Specification  . . . . . . . . . . . . . .  53\n  A.2.  Changes to the Protocol . . . . . . . . . . . . . . . . .  53\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  54\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  55",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies the RPC-over-RDMA version 1 protocol, based on existing implementations of RFC 5666 and experience gained through deployment. This document obsoletes RFC 5666.",
      "ja": "このドキュメントでは、RFC 5666の既存の実装と、導入を通じて得られた経験に基づいて、RPC-over-RDMAバージョン1プロトコルを指定します。このドキュメントはRFC 5666を廃止します。"
    },
    {
      "indent": 3,
      "text": "This specification clarifies text that was subject to multiple interpretations and removes support for unimplemented RPC-over-RDMA version 1 protocol elements. It clarifies the role of Upper-Layer Bindings (ULBs) and describes what they are to contain.",
      "ja": "この仕様は、複数の解釈の対象となったテキストを明確にし、実装されていないRPC-over-RDMAバージョン1プロトコル要素のサポートを削除します。上位層バインディング（ULB）の役割を明確にし、それらに何を含めるかを説明します。"
    },
    {
      "indent": 3,
      "text": "In addition, this document describes current practice using RPCSEC_GSS [RFC7861] on RDMA transports.",
      "ja": "さらに、このドキュメントでは、RDMAトランスポートでRPCSEC_GSS [RFC7861]を使用する現在のプラクティスについて説明します。"
    },
    {
      "indent": 3,
      "text": "The protocol version number has not been changed because the protocol specified in this document fully interoperates with implementations of the RPC-over-RDMA version 1 protocol specified in [RFC5666].",
      "ja": "このドキュメントで指定されたプロトコルは、[RFC5666]で指定されたRPC-over-RDMAバージョン1プロトコルの実装と完全に相互運用するため、プロトコルバージョン番号は変更されていません。"
    },
    {
      "indent": 0,
      "text": "1.1. RPCs on RDMA Transports",
      "section_title": true,
      "ja": "1.1. RDMAトランスポート上のRPC"
    },
    {
      "indent": 3,
      "text": "RDMA [RFC5040] [RFC5041] [IBARCH] is a technique for moving data efficiently between end nodes. By directing data into destination buffers as it is sent on a network, and placing it via direct memory access by hardware, the benefits of faster transfers and reduced host overhead are obtained.",
      "ja": "RDMA [RFC5040] [RFC5041] [IBARCH]は、エンドノード間でデータを効率的に移動するための手法です。ネットワーク上で送信されるデータを宛先バッファに送り、ハードウェアによる直接メモリアクセスを介してデータを配置することにより、高速転送とホストオーバーヘッドの削減という利点が得られます。"
    },
    {
      "indent": 3,
      "text": "Open Network Computing Remote Procedure Call (ONC RPC, often shortened in NFSv4 documents to RPC) [RFC5531] is a remote procedure call protocol that runs over a variety of transports. Most RPC implementations today use UDP [RFC768] or TCP [RFC793]. On UDP, RPC messages are encapsulated inside datagrams, while on a TCP byte stream, RPC messages are delineated by a record marking protocol. An RDMA transport also conveys RPC messages in a specific fashion that must be fully described if RPC implementations are to interoperate.",
      "ja": "オープンネットワークコンピューティングリモートプロシージャコール（ONC RPC、NFSv4ドキュメントではRPCに短縮されることが多い）[RFC5531]は、さまざまなトランスポート上で実行されるリモートプロシージャコールプロトコルです。今日のほとんどのRPC実装は、UDP [RFC768]またはTCP [RFC793]を使用しています。 UDPでは、RPCメッセージはデータグラム内にカプセル化されますが、TCPバイトストリームでは、RPCメッセージはレコードマーキングプロトコルによって区別されます。 RDMAトランスポートは、RPC実装を相互運用する場合に完全に説明する必要がある特定の方法でRPCメッセージも伝達します。"
    },
    {
      "indent": 3,
      "text": "RDMA transports present semantics that differ from either UDP or TCP. They retain message delineations like UDP but provide reliable and sequenced data transfer like TCP. They also provide an offloaded bulk transfer service not provided by UDP or TCP. RDMA transports are therefore appropriately viewed as a new transport type by RPC.",
      "ja": "RDMAトランスポートは、UDPまたはTCPとは異なるセマンティクスを提示します。それらは、UDPのようなメッセージの描写を保持しますが、TCPのような信頼できるシーケンスされたデータ転送を提供します。また、UDPまたはTCPでは提供されないオフロードのバルク転送サービスも提供します。したがって、RDMAトランスポートは、RPCによって新しいトランスポートタイプとして適切に見なされます。"
    },
    {
      "indent": 3,
      "text": "In this context, the Network File System (NFS) protocols, as described in [RFC1094], [RFC1813], [RFC7530], [RFC5661], and future NFSv4 minor versions, are all obvious beneficiaries of RDMA transports. A complete problem statement is presented in [RFC5532]. Many other RPC-based protocols can also benefit.",
      "ja": "このコンテキストでは、[RFC1094]、[RFC1813]、[RFC7530]、[RFC5661]、および将来のNFSv4マイナーバージョンで説明されているように、ネットワークファイルシステム（NFS）プロトコルはすべて、RDMAトランスポートの明らかな受益者です。完全な問題ステートメントは[RFC5532]に示されています。他の多くのRPCベースのプロトコルもメリットがあります。"
    },
    {
      "indent": 3,
      "text": "Although the RDMA transport described herein can provide relatively transparent support for any RPC application, this document also describes mechanisms that can optimize data transfer even further, when RPC applications are willing to exploit awareness of RDMA as the transport.",
      "ja": "ここで説明するRDMAトランスポートは、任意のRPCアプリケーションに対して比較的透過的なサポートを提供できますが、このドキュメントでは、RPCアプリケーションがトランスポートとしてのRDMAの認識を活用しようとする場合に、データ転送をさらに最適化できるメカニズムについても説明します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. RPCs",
      "section_title": true,
      "ja": "2.2. RPC"
    },
    {
      "indent": 3,
      "text": "This section highlights key elements of the RPC [RFC5531] and External Data Representation (XDR) [RFC4506] protocols, upon which RPC-over-RDMA version 1 is constructed. Strong grounding with these protocols is recommended before reading this document.",
      "ja": "このセクションでは、RPC-over-RDMAバージョン1が構築されるRPC [RFC5531]および外部データ表現（XDR）[RFC4506]プロトコルの主要な要素に焦点を当てます。このドキュメントを読む前に、これらのプロトコルによる強力な接地を推奨します。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Upper-Layer Protocols",
      "section_title": true,
      "ja": "2.2.1. 上位層プロトコル"
    },
    {
      "indent": 3,
      "text": "RPCs are an abstraction used to implement the operations of an Upper-Layer Protocol (ULP). \"ULP\" refers to an RPC Program and Version tuple, which is a versioned set of procedure calls that comprise a single well-defined API. One example of a ULP is the Network File System Version 4.0 [RFC7530].",
      "ja": "RPCは、Upper-Layer Protocol（ULP）の操作を実装するために使用される抽象概念です。 「ULP」は、RPCプログラムとバージョンタプルを指します。これは、1つの明確に定義されたAPIを構成するバージョン付きのプロシージャコールのセットです。 ULPの1つの例は、Network File System Version 4.0 [RFC7530]です。"
    },
    {
      "indent": 3,
      "text": "In this document, the term \"RPC consumer\" refers to an implementation of a ULP running on an RPC client endpoint.",
      "ja": "このドキュメントでは、「RPCコンシューマー」という用語は、RPCクライアントエンドポイントで実行されるULPの実装を指します。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Requesters and Responders",
      "section_title": true,
      "ja": "2.2.2. 要求者と応答者"
    },
    {
      "indent": 3,
      "text": "Like a local procedure call, every RPC procedure has a set of \"arguments\" and a set of \"results\". A calling context invokes a procedure, passing arguments to it, and the procedure subsequently returns a set of results. Unlike a local procedure call, the called procedure is executed remotely rather than in the local application's execution context.",
      "ja": "ローカルプロシージャコールのように、すべてのRPCプロシージャには、一連の「引数」と一連の「結果」があります。呼び出しコンテキストはプロシージャを呼び出し、それに引数を渡します。その後、プロシージャは一連の結果を返します。ローカルプロシージャコールとは異なり、呼び出されたプロシージャは、ローカルアプリケーションの実行コンテキストではなくリモートで実行されます。"
    },
    {
      "indent": 3,
      "text": "The RPC protocol as described in [RFC5531] is fundamentally a message-passing protocol between one or more clients (where RPC consumers are running) and a server (where a remote execution context is available to process RPC transactions on behalf of those consumers).",
      "ja": "[RFC5531]で説明されているRPCプロトコルは、基本的には1つ以上のクライアント（RPCコンシューマが実行されている）とサーバー（リモート実行コンテキストが利用可能で、これらのコンシューマの代わりにRPCトランザクションを処理できる）間のメッセージ受け渡しプロトコルです。"
    },
    {
      "indent": 3,
      "text": "ONC RPC transactions are made up of two types of messages:",
      "ja": "ONC RPCトランザクションは、次の2種類のメッセージで構成されています。"
    },
    {
      "indent": 3,
      "text": "CALL An \"RPC Call message\" requests that work be done. This type of message is designated by the value zero (0) in the message's msg_type field. An arbitrary unique value is placed in the message's XID field in order to match this RPC Call message to a corresponding RPC Reply message.",
      "ja": "CALL \"RPC Callメッセージ\"は、機能することを要求します。このタイプのメッセージは、メッセージのmsg_typeフィールドの値ゼロ（0）によって指定されます。このRPC呼び出しメッセージを対応するRPC応答メッセージと照合するために、メッセージのXIDフィールドに任意の一意の値が配置されます。"
    },
    {
      "indent": 3,
      "text": "REPLY An \"RPC Reply message\" reports the results of work requested by an RPC Call message. An RPC Reply message is designated by the value one (1) in the message's msg_type field. The value contained in an RPC Reply message's XID field is copied from the RPC Call message whose results are being reported.",
      "ja": "応答「RPC応答メッセージ」は、RPC呼び出しメッセージによって要求された作業の結果を報告します。 RPC応答メッセージは、メッセージのmsg_typeフィールドの値1によって指定されます。 RPC応答メッセージのXIDフィールドに含まれる値は、結果が報告されているRPC呼び出しメッセージからコピーされます。"
    },
    {
      "indent": 3,
      "text": "The RPC client endpoint acts as a \"Requester\". It serializes the procedure's arguments and conveys them to a server endpoint via an RPC Call message. This message contains an RPC protocol header, a header describing the requested upper-layer operation, and all arguments.",
      "ja": "RPCクライアントエンドポイントは「リクエスター」として機能します。プロシージャの引数をシリアル化し、RPC Callメッセージを介してサーバーエンドポイントに伝えます。このメッセージには、RPCプロトコルヘッダー、要求された上位層操作を説明するヘッダー、およびすべての引数が含まれています。"
    },
    {
      "indent": 3,
      "text": "The RPC server endpoint acts as a \"Responder\". It deserializes the arguments and processes the requested operation. It then serializes the operation's results into another byte stream. This byte stream is conveyed back to the Requester via an RPC Reply message. This message contains an RPC protocol header, a header describing the upper-layer reply, and all results.",
      "ja": "RPCサーバーエンドポイントは「レスポンダー」として機能します。引数をデシリアライズし、要求された操作を処理します。次に、操作の結果を別のバイトストリームにシリアル化します。このバイトストリームは、RPC応答メッセージを介してリクエスタに戻されます。このメッセージには、RPCプロトコルヘッダー、上位層の応答を説明するヘッダー、およびすべての結果が含まれます。"
    },
    {
      "indent": 3,
      "text": "The Requester deserializes the results and allows the original caller to proceed. At this point, the RPC transaction designated by the XID in the RPC Call message is complete, and the XID is retired.",
      "ja": "リクエスターは結果をデシリアライズし、元の呼び出し元が続行できるようにします。この時点で、RPC CallメッセージのXIDで指定されたRPCトランザクションは完了し、XIDは廃止されます。"
    },
    {
      "indent": 3,
      "text": "In summary, RPC Call messages are sent by Requesters to Responders to initiate RPC transactions. RPC Reply messages are sent by Responders to Requesters to complete the processing on an RPC transaction.",
      "ja": "要約すると、RPC呼び出しメッセージは、RPCトランザクションを開始するためにリクエスターからレスポンダーに送信されます。 RPC応答メッセージは、RPCトランザクションの処理を完了するために、レスポンダからリクエスタに送信されます。"
    },
    {
      "indent": 0,
      "text": "2.2.3. RPC Transports",
      "section_title": true,
      "ja": "2.2.3. RPCトランスポート"
    },
    {
      "indent": 3,
      "text": "The role of an \"RPC transport\" is to mediate the exchange of RPC messages between Requesters and Responders. An RPC transport bridges the gap between the RPC message abstraction and the native operations of a particular network transport.",
      "ja": "「RPCトランスポート」の役割は、要求側と応答側の間のRPCメッセージの交換を仲介することです。 RPCトランスポートは、RPCメッセージの抽象化と特定のネットワークトランスポートのネイティブ操作の間のギャップを埋めます。"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA is a connection-oriented RPC transport. When a connection-oriented transport is used, clients initiate transport connections, while servers wait passively for incoming connection requests.",
      "ja": "RPC-over-RDMAは、接続指向のRPCトランスポートです。接続指向のトランスポートが使用される場合、クライアントはトランスポート接続を開始し、サーバーは着信接続要求を受動的に待機します。"
    },
    {
      "indent": 0,
      "text": "2.2.4. External Data Representation",
      "section_title": true,
      "ja": "2.2.4. 外部データ表現"
    },
    {
      "indent": 3,
      "text": "One cannot assume that all Requesters and Responders represent data objects the same way internally. RPC uses External Data Representation (XDR) to translate native data types and serialize arguments and results [RFC4506].",
      "ja": "すべてのリクエスタとレスポンダが内部的に同じ方法でデータオブジェクトを表すとは限りません。 RPCは外部データ表現（XDR）を使用して、ネイティブデータ型を変換し、引数と結果をシリアル化します[RFC4506]。"
    },
    {
      "indent": 3,
      "text": "The XDR protocol encodes data independently of the endianness or size of host-native data types, allowing unambiguous decoding of data on the receiving end. RPC Programs are specified by writing an XDR definition of their procedures, argument data types, and result data types.",
      "ja": "XDRプロトコルは、ホストネイティブのデータ型のエンディアンやサイズに関係なくデータをエンコードするため、受信側でデータを明確にデコードできます。 RPCプログラムは、プロシージャ、引数のデータ型、および結果のデータ型のXDR定義を記述することによって指定されます。"
    },
    {
      "indent": 3,
      "text": "XDR assumes that the number of bits in a byte (octet) and their order are the same on both endpoints and on the physical network. The smallest indivisible unit of XDR encoding is a group of four octets. XDR also flattens lists, arrays, and other complex data types so they can be conveyed as a stream of bytes.",
      "ja": "XDRは、バイト（オクテット）のビット数とその順序が、両方のエンドポイントと物理ネットワークで同じであることを前提としています。 XDRエンコーディングの分割不可能な最小単位は、4オクテットのグループです。 XDRは、リスト、配列、およびその他の複雑なデータ型をフラット化して、バイトのストリームとして伝達できるようにします。"
    },
    {
      "indent": 3,
      "text": "A serialized stream of bytes that is the result of XDR encoding is referred to as an \"XDR stream\". A sending endpoint encodes native data into an XDR stream and then transmits that stream to a receiver. A receiving endpoint decodes incoming XDR byte streams into its native data representation format.",
      "ja": "XDRエンコーディングの結果であるシリアライズされたバイトのストリームは、「XDRストリーム」と呼ばれます。送信エンドポイントは、ネイティブデータをXDRストリームにエンコードしてから、そのストリームをレシーバーに送信します。受信エンドポイントは、着信XDRバイトストリームをネイティブデータ表現形式にデコードします。"
    },
    {
      "indent": 0,
      "text": "2.2.4.1. XDR Opaque Data",
      "section_title": true,
      "ja": "2.2.4.1. XDR不透明データ"
    },
    {
      "indent": 3,
      "text": "Sometimes, a data item must be transferred as is: without encoding or decoding. The contents of such a data item are referred to as \"opaque data\". XDR encoding places the content of opaque data items directly into an XDR stream without altering it in any way. ULPs or applications perform any needed data translation in this case. Examples of opaque data items include the content of files or generic byte strings.",
      "ja": "場合によっては、データ項目をそのままエンコードまたはデコードせずに転送する必要があります。このようなデータ項目の内容は、「不透明なデータ」と呼ばれます。 XDRエンコーディングは、不透明なデータ項目のコンテンツを、いかなる方法でも変更せずに直接XDRストリームに配置します。この場合、ULPまたはアプリケーションは必要なデータ変換を実行します。不透明なデータ項目の例には、ファイルのコンテンツまたは汎用バイト文字列が含まれます。"
    },
    {
      "indent": 0,
      "text": "2.2.4.2. XDR Roundup",
      "section_title": true,
      "ja": "2.2.4.2. XDRのまとめ"
    },
    {
      "indent": 3,
      "text": "The number of octets in a variable-length data item precedes that item in an XDR stream. If the size of an encoded data item is not a multiple of four octets, octets containing zero are added after the end of the item; this is the case so that the next encoded data item in the XDR stream starts on a four-octet boundary. The encoded size of the item is not changed by the addition of the extra octets. These extra octets are never exposed to ULPs.",
      "ja": "可変長データアイテムのオクテット数は、XDRストリームのそのアイテムの前にあります。エンコードされたデータ項目のサイズが4オクテットの倍数でない場合、項目の終わりの後にゼロを含むオクテットが追加されます。これは、XDRストリーム内の次のエンコードされたデータアイテムが4オクテットの境界で始まる場合です。アイテムのエンコードされたサイズは、追加のオクテットを追加しても変更されません。これらの追加のオクテットは決してULPに公開されません。"
    },
    {
      "indent": 3,
      "text": "This technique is referred to as \"XDR roundup\", and the extra octets are referred to as \"XDR roundup padding\".",
      "ja": "この手法は「XDR切り上げ」と呼ばれ、追加のオクテットは「XDR切り上げパディング」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "2.3. RDMA",
      "section_title": true,
      "ja": "2.3. RDMA"
    },
    {
      "indent": 3,
      "text": "RPC Requesters and Responders can be made more efficient if large RPC messages are transferred by a third party, such as intelligent network-interface hardware (data movement offload), and placed in the receiver's memory so that no additional adjustment of data alignment has to be made (direct data placement or \"DDP\"). RDMA transports enable both optimizations.",
      "ja": "大規模なRPCメッセージがインテリジェントネットワークインターフェースハードウェア（データ移動オフロード）などのサードパーティによって転送され、レシーバーのメモリに配置される場合、RPCリクエスターとレスポンダーをより効率的にすることができるため、データ配置の追加調整は不要です。作成（直接データ配置または「DDP」）。 RDMAトランスポートは、両方の最適化を可能にします。"
    },
    {
      "indent": 0,
      "text": "2.3.1. DDP",
      "section_title": true,
      "ja": "2.3.1. DDP"
    },
    {
      "indent": 3,
      "text": "Typically, RPC implementations copy the contents of RPC messages into a buffer before being sent. An efficient RPC implementation sends bulk data without copying it into a separate send buffer first.",
      "ja": "通常、RPC実装はRPCメッセージの内容を送信前にバッファにコピーします。効率的なRPC実装は、最初に個別の送信バッファーにコピーせずにバルクデータを送信します。"
    },
    {
      "indent": 3,
      "text": "However, socket-based RPC implementations are often unable to receive data directly into its final place in memory. Receivers often need to copy incoming data to finish an RPC operation: sometimes, only to adjust data alignment.",
      "ja": "ただし、ソケットベースのRPC実装では、データをメモリ内の最終的な場所に直接受信できないことがよくあります。受信者は、RPC操作を完了するために着信データをコピーする必要がある場合が多く、場合によっては、データの配置を調整するだけです。"
    },
    {
      "indent": 3,
      "text": "In this document, \"RDMA\" refers to the physical mechanism an RDMA transport utilizes when moving data. Although this may not be efficient, before an RDMA transfer, a sender may copy data into an intermediate buffer. After an RDMA transfer, a receiver may copy that data again to its final destination.",
      "ja": "このドキュメントでは、「RDMA」はデータを移動するときにRDMAトランスポートが利用する物理メカニズムを指します。これは効率的ではないかもしれませんが、RDMA転送の前に、送信側がデータを中間バッファーにコピーする場合があります。 RDMA転送後、受信者はそのデータを最終的な宛先に再度コピーできます。"
    },
    {
      "indent": 3,
      "text": "In this document, the term \"DDP\" refers to any optimized data transfer where it is unnecessary for a receiving host's CPU to copy transferred data to another location after it has been received.",
      "ja": "このドキュメントでは、「DDP」という用語は、受信したホストのCPUが転送されたデータを受信後に別の場所にコピーする必要がない、最適化されたデータ転送を指します。"
    },
    {
      "indent": 3,
      "text": "Just as [RFC5666] did, this document focuses on the use of RDMA Read and Write operations to achieve both data movement offload and DDP. However, not all RDMA-based data transfer qualifies as DDP, and DDP can be achieved using non-RDMA mechanisms.",
      "ja": "[RFC5666]と同様に、このドキュメントでは、RDMA読み取りおよび書き込み操作を使用して、データ移動のオフロードとDDPの両方を実現することに焦点を当てています。ただし、すべてのRDMAベースのデータ転送がDDPとして認定されるわけではなく、非RDMAメカニズムを使用してDDPを実現できます。"
    },
    {
      "indent": 0,
      "text": "2.3.2. RDMA Transport Requirements",
      "section_title": true,
      "ja": "2.3.2. RDMAトランスポートの要件"
    },
    {
      "indent": 3,
      "text": "To achieve good performance during receive operations, RDMA transports require that RDMA consumers provision resources in advance to receive incoming messages.",
      "ja": "受信操作中に良好なパフォーマンスを実現するために、RDMAトランスポートでは、RDMAコンシューマーが事前にリソースをプロビジョニングして着信メッセージを受信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An RDMA consumer might provide Receive buffers in advance by posting an RDMA Receive Work Request for every expected RDMA Send from a remote peer. These buffers are provided before the remote peer posts RDMA Send Work Requests; thus, this is often referred to as \"pre-posting\" buffers.",
      "ja": "RDMAコンシューマーは、リモートピアからの予想されるすべてのRDMA送信に対してRDMA受信作業要求をポストすることにより、事前に受信バッファーを提供する場合があります。これらのバッファは、リモートピアがRDMA送信作業要求を送信する前に提供されます。したがって、これは「事前転記」バッファと呼ばれることがよくあります。"
    },
    {
      "indent": 3,
      "text": "An RDMA Receive Work Request remains outstanding until hardware matches it to an inbound Send operation. The resources associated with that Receive must be retained in host memory, or \"pinned\", until the Receive completes.",
      "ja": "RDMA受信作業要求は、ハードウェアがそれをインバウンド送信操作と一致させるまで未解決のままです。その受信に関連付けられたリソースは、受信が完了するまでホストメモリに保持するか、「固定」する必要があります。"
    },
    {
      "indent": 3,
      "text": "Given these basic tenets of RDMA transport operation, the RPC-over-RDMA version 1 protocol assumes each transport provides the following abstract operations. A more complete discussion of these operations is found in [RFC5040].",
      "ja": "RDMAトランスポート操作のこれらの基本的な原則を前提として、RPC-over-RDMAバージョン1プロトコルは、各トランスポートが次の抽象的な操作を提供することを前提としています。これらの操作のより完全な議論は[RFC5040]にあります。"
    },
    {
      "indent": 3,
      "text": "Registered Memory Registered memory is a region of memory that is assigned a steering tag that temporarily permits access by the RDMA provider to perform data-transfer operations. The RPC-over-RDMA version 1 protocol assumes that each region of registered memory MUST be identified with a steering tag of no more than 32 bits and memory addresses of up to 64 bits in length.",
      "ja": "レジスタ付きメモリレジスタ付きメモリは、RDMAプロバイダーによるデータ転送操作の実行を一時的に許可するステアリングタグが割り当てられたメモリ領域です。 RPC-over-RDMAバージョン1プロトコルは、登録されたメモリの各領域が32ビット以下のステアリングタグと最大64ビット長のメモリアドレスで識別されなければならないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "RDMA Send The RDMA provider supports an RDMA Send operation, with completion signaled on the receiving peer after data has been placed in a pre-posted buffer. Sends complete at the receiver in the order they were issued at the sender. The amount of data transferred by a single RDMA Send operation is limited by the size of the remote peer's pre-posted buffers.",
      "ja": "RDMA送信RDMAプロバイダーはRDMA送信操作をサポートしており、データが事前にポストされたバッファーに配置された後、受信ピアで完了が通知されます。送信は、送信側で発行された順序で受信側で完了します。 1回のRDMA送信操作で転送されるデータの量は、リモートピアの事前送信されたバッファのサイズによって制限されます。"
    },
    {
      "indent": 3,
      "text": "RDMA Receive The RDMA provider supports an RDMA Receive operation to receive data conveyed by incoming RDMA Send operations. To reduce the amount of memory that must remain pinned awaiting incoming Sends, the amount of pre-posted memory is limited. Flow control to prevent overrunning receiver resources is provided by the RDMA consumer (in this case, the RPC-over-RDMA version 1 protocol).",
      "ja": "RDMA受信RDMAプロバイダーは、着信RDMA送信操作によって伝達されたデータを受信するためのRDMA受信操作をサポートします。着信Sendを待機するために固定されたままにする必要があるメモリの量を減らすために、事前にポストされるメモリの量は制限されています。 RDMAコンシューマー（この場合はRPC-over-RDMAバージョン1プロトコル）により、レシーバーリソースのオーバーランを防止するフロー制御が提供されます。"
    },
    {
      "indent": 3,
      "text": "RDMA Write The RDMA provider supports an RDMA Write operation to place data directly into a remote memory region. The local host initiates an RDMA Write, and completion is signaled there. No completion is signaled on the remote peer. The local host provides a steering tag, memory address, and length of the remote peer's memory region.",
      "ja": "RDMA書き込みRDMAプロバイダーは、データをリモートメモリ領域に直接配置するためのRDMA書き込み操作をサポートしています。ローカルホストがRDMA書き込みを開始し、そこで完了が通知されます。リモートピアでは完了は通知されません。ローカルホストは、ステアリングタグ、メモリアドレス、およびリモートピアのメモリ領域の長さを提供します。"
    },
    {
      "indent": 6,
      "text": "RDMA Writes are not ordered with respect to one another, but are ordered with respect to RDMA Sends. A subsequent RDMA Send completion obtained at the write initiator guarantees that prior RDMA Write data has been successfully placed in the remote peer's memory.",
      "ja": "RDMA書き込みは互いに順序付けられていませんが、RDMA送信に関して順序付けられています。書き込みイニシエーターで取得された後続のRDMA送信完了により、前のRDMA書き込みデータがリモートピアのメモリに正常に配置されていることが保証されます。"
    },
    {
      "indent": 3,
      "text": "RDMA Read The RDMA provider supports an RDMA Read operation to place peer source data directly into the read initiator's memory. The local host initiates an RDMA Read, and completion is signaled there. No completion is signaled on the remote peer. The local host provides steering tags, memory addresses, and a length for the remote source and local destination memory region.",
      "ja": "RDMA読み取りRDMAプロバイダーは、ピアソースデータを読み取りイニシエーターのメモリに直接配置するRDMA読み取り操作をサポートしています。ローカルホストがRDMA読み取りを開始し、そこで完了が通知されます。リモートピアでは完了は通知されません。ローカルホストは、ステアリングタグ、メモリアドレス、およびリモートソースとローカルの宛先メモリ領域の長さを提供します。"
    },
    {
      "indent": 6,
      "text": "The local host signals Read completion to the remote peer as part of a subsequent RDMA Send message. The remote peer can then release steering tags and subsequently free associated source memory regions.",
      "ja": "ローカルホストは、後続のRDMA送信メッセージの一部として、リモートピアに読み取り完了を通知します。その後、リモートピアはステアリングタグを解放し、続いて関連するソースメモリ領域を解放できます。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA version 1 protocol is designed to be carried over RDMA transports that support the above abstract operations. This protocol conveys information sufficient for an RPC peer to direct an RDMA provider to perform transfers containing RPC data and to communicate their result(s).",
      "ja": "RPC-over-RDMAバージョン1プロトコルは、上記の抽象操作をサポートするRDMAトランスポートを介して伝送されるように設計されています。このプロトコルは、RPCピアがRDMAプロバイダーにRPCデータを含む転送を実行し、その結果を伝達するのに十分な情報を伝えます。"
    },
    {
      "indent": 0,
      "text": "3. RPC-over-RDMA Protocol Framework",
      "section_title": true,
      "ja": "3. RPC-over-RDMAプロトコルフレームワーク"
    },
    {
      "indent": 0,
      "text": "3.1. Transfer Models",
      "section_title": true,
      "ja": "3.1. 転送モデル"
    },
    {
      "indent": 3,
      "text": "A \"transfer model\" designates which endpoint exposes its memory and which is responsible for initiating the transfer of data. To enable RDMA Read and Write operations, for example, an endpoint first exposes regions of its memory to a remote endpoint, which initiates these operations against the exposed memory.",
      "ja": "「転送モデル」は、どのエンドポイントがメモリを公開し、どのエンドポイントがデータ転送の開始を担当するかを指定します。たとえば、RDMA読み取りおよび書き込み操作を有効にするには、エンドポイントは最初にそのメモリの領域をリモートエンドポイントに公開し、公開されたメモリに対してこれらの操作を開始します。"
    },
    {
      "indent": 3,
      "text": "Read-Read Requesters expose their memory to the Responder, and the Responder exposes its memory to Requesters. The Responder reads, or pulls, RPC arguments or whole RPC calls from each Requester. Requesters pull RPC results or whole RPC relies from the Responder.",
      "ja": "読み取り-読み取りリクエスターは自分のメモリをレスポンダに公開し、レスポンダはそのメモリをリクエスタに公開します。レスポンダは、各リクエスタからのRPC引数またはRPC呼び出し全体を読み取るか、プルします。リクエスターはRPC結果をプルするか、RPC全体がレスポンダーから依存します。"
    },
    {
      "indent": 3,
      "text": "Write-Write Requesters expose their memory to the Responder, and the Responder exposes its memory to Requesters. Requesters write, or push, RPC arguments or whole RPC calls to the Responder. The Responder pushes RPC results or whole RPC relies to each Requester.",
      "ja": "書き込み書き込みリクエスタはメモリをレスポンダに公開し、レスポンダはそのメモリをリクエスタに公開します。リクエスターは、R​​PC引数またはRPC呼び出し全体をレスポンダーに書き込む、またはプッシュします。レスポンダがRPC結果をプッシュするか、RPC全体が各リクエスタに依存します。"
    },
    {
      "indent": 3,
      "text": "Read-Write Requesters expose their memory to the Responder, but the Responder does not expose its memory. The Responder pulls RPC arguments or whole RPC calls from each Requester. The Responder pushes RPC results or whole RPC relies to each Requester.",
      "ja": "読み取り/書き込みリクエスタは、メモリをレスポンダに公開しますが、レスポンダはそのメモリを公開しません。レスポンダは、各リクエスタからRPC引数またはRPC呼び出し全体を引き出します。レスポンダがRPC結果をプッシュするか、RPC全体が各リクエスタに依存します。"
    },
    {
      "indent": 3,
      "text": "Write-Read The Responder exposes its memory to Requesters, but Requesters do not expose their memory. Requesters push RPC arguments or whole RPC calls to the Responder. Requesters pull RPC results or whole RPC relies from the Responder.",
      "ja": "書き込み-読み取りレスポンダはリクエスタにメモリを公開しますが、リクエスタはメモリを公開しません。リクエスタはRPC引数またはRPC呼び出し全体をレスポンダにプッシュします。リクエスターはRPC結果をプルするか、RPC全体がレスポンダーから依存します。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Framing",
      "section_title": true,
      "ja": "3.2. メッセージのフレーミング"
    },
    {
      "indent": 3,
      "text": "On an RPC-over-RDMA transport, each RPC message is encapsulated by an RPC-over-RDMA message. An RPC-over-RDMA message consists of two XDR streams.",
      "ja": "RPC-over-RDMAトランスポートでは、各RPCメッセージはRPC-over-RDMAメッセージによってカプセル化されます。 RPC-over-RDMAメッセージは、2つのXDRストリームで構成されています。"
    },
    {
      "indent": 3,
      "text": "RPC Payload Stream The \"Payload stream\" contains the encapsulated RPC message being transferred by this RPC-over-RDMA message. This stream always begins with the Transaction ID (XID) field of the encapsulated RPC message.",
      "ja": "RPCペイロードストリーム「ペイロードストリーム」には、このRPC-over-RDMAメッセージによって転送されるカプセル化されたRPCメッセージが含まれています。このストリームは常に、カプセル化されたRPCメッセージのトランザクションID（XID）フィールドで始まります。"
    },
    {
      "indent": 3,
      "text": "Transport Stream The \"Transport stream\" contains a header that describes and controls the transfer of the Payload stream in this RPC-over-RDMA message. This header is analogous to the record marking used for RPC on TCP sockets but is more extensive, since RDMA transports support several modes of data transfer.",
      "ja": "トランスポートストリーム「トランスポートストリーム」には、このRPC-over-RDMAメッセージのペイロードストリームの転送を記述および制御するヘッダーが含まれています。このヘッダーは、TCPソケットでRPCに使用されるレコードマーキングに似ていますが、RDMAトランスポートがいくつかのデータ転送モードをサポートしているため、より広範囲です。"
    },
    {
      "indent": 3,
      "text": "In its simplest form, an RPC-over-RDMA message consists of a Transport stream followed immediately by a Payload stream conveyed together in a single RDMA Send. To transmit large RPC messages, a combination of one RDMA Send operation and one or more other RDMA operations is employed.",
      "ja": "最も単純な形式では、RPC-over-RDMAメッセージは、トランスポートストリームと、その後に続く単一のRDMA送信で一緒に伝達されるペイロードストリームで構成されます。大きなRPCメッセージを送信するには、1つのRDMA送信操作と1つ以上の他のRDMA操作の組み合わせを使用します。"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA framing replaces all other RPC framing (such as TCP record marking) when used atop an RPC-over-RDMA association, even when the underlying RDMA protocol may itself be layered atop a transport with a defined RPC framing (such as TCP).",
      "ja": "RPC-over-RDMAフレーミングは、RPC-over-RDMAアソシエーションの上で使用されると、他のすべてのRPCフレーミング（TCPレコードマーキングなど）を置き換えます。 TCP）。"
    },
    {
      "indent": 3,
      "text": "However, it is possible for RPC-over-RDMA to be dynamically enabled in the course of negotiating the use of RDMA via a ULP exchange. Because RPC framing delimits an entire RPC request or reply, the resulting shift in framing must occur between distinct RPC messages, and in concert with the underlying transport.",
      "ja": "ただし、ULP交換を介してRDMAの使用をネゴシエートする過程で、RPC-over-RDMAを動的に有効にすることができます。 RPCフレーミングはRPC要求または応答全体を区切るので、結果として生じるフレーミングのシフトは、個別のRPCメッセージ間で、および基礎となるトランスポートと協調して発生する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Managing Receiver Resources",
      "section_title": true,
      "ja": "3.3. レシーバーリソースの管理"
    },
    {
      "indent": 0,
      "text": " It is critical to provide RDMA Send flow control for an RDMA connection. If any pre-posted Receive buffer on the connection is not large enough to accept an incoming RDMA Send, or if a pre-posted Receive buffer is not available to accept an incoming RDMA Send, the RDMA connection can be terminated. This is different than conventional TCP/IP networking, in which buffers are allocated dynamically as messages are received.",
      "ja": "RDMA接続にRDMA送信フロー制御を提供することが重要です。接続の事前にポストされた受信バッファーが着信RDMA送信を受け入れるのに十分な大きさでない場合、または事前にポストされた受信バッファーが着信RDMA送信を受け入れることができない場合、RDMA接続を終了できます。これは、メッセージの受信時にバッファが動的に割り当てられる従来のTCP / IPネットワークとは異なります。"
    },
    {
      "indent": 3,
      "text": "The longevity of an RDMA connection mandates that sending endpoints respect the resource limits of peer receivers. To ensure messages can be sent and received reliably, there are two operational parameters for each connection.",
      "ja": "RDMA接続の寿命は、送信エンドポイントがピアレシーバーのリソース制限を尊重することを義務付けています。メッセージを確実に送受信できるようにするために、接続ごとに2つの操作パラメーターがあります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. RPC-over-RDMA Credits",
      "section_title": true,
      "ja": "3.3.1. RPC-over-RDMAクレジット"
    },
    {
      "indent": 3,
      "text": "Flow control for RDMA Send operations directed to the Responder is implemented as a simple request/grant protocol in the RPC-over-RDMA header associated with each RPC message.",
      "ja": "レスポンダに向けられたRDMA送信操作のフロー制御は、各RPCメッセージに関連付けられたRPC-over-RDMAヘッダー内の単純な要求/許可プロトコルとして実装されます。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA version 1 credit is the capability to handle one RPC-over-RDMA transaction. Each RPC-over-RDMA message sent from Requester to Responder requests a number of credits from the Responder. Each RPC-over-RDMA message sent from Responder to Requester informs the Requester how many credits the Responder has granted. The requested and granted values are carried in each RPC-over-RDMA message's rdma_credit field (see Section 4.2.3).",
      "ja": "RPC-over-RDMAバージョン1クレジットは、1つのRPC-over-RDMAトランザクションを処理する機能です。リクエスタからレスポンダに送信される各RPC-over-RDMAメッセージは、レスポンダにいくつかのクレジットを要求します。レスポンダからリクエスタに送信される各RPC-over-RDMAメッセージは、レスポンダが付与したクレジット数をリクエスタに通知します。要求された値と許可された値は、各RPC-over-RDMAメッセージのrdma_creditフィールドで伝達されます（セクション4.2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Practically speaking, the critical value is the granted value. A Requester MUST NOT send unacknowledged requests in excess of the Responder's granted credit limit. If the granted value is exceeded, the RDMA layer may signal an error, possibly terminating the connection. The granted value MUST NOT be zero, since such a value would result in deadlock.",
      "ja": "実際には、重要な値は付与された値です。リクエスタは、レスポンダの許可されたクレジット制限を超える未確認のリクエストを送信してはなりません。許可された値を超えると、RDMA層はエラーを通知し、接続を終了する可能性があります。そのような値はデッドロックを引き起こすので、許可された値はゼロであってはなりません。"
    },
    {
      "indent": 3,
      "text": "RPC calls complete in any order, but the current granted credit limit at the Responder is known to the Requester from RDMA Send ordering properties. The number of allowed new requests the Requester may send is then the lower of the current requested and granted credit values, minus the number of requests in flight. Advertised credit values are not altered when individual RPCs are started or completed.",
      "ja": "RPC呼び出しは任意の順序で完了しますが、レスポンダで現在許可されているクレジット制限は、RDMA送信順序プロパティからリクエスタに認識されます。リクエスタが送信できる許可された新しいリクエストの数は、現在のリクエストおよび付与されたクレジット値から、処理中のリクエストの数を差し引いた数よりも少なくなります。アドバタイズされたクレジット値は、個々のRPCが開始または完了しても変更されません。"
    },
    {
      "indent": 3,
      "text": "The requested and granted credit values MAY be adjusted to match the needs or policies in effect on either peer. For instance, a Responder may reduce the granted credit value to accommodate the available resources in a Shared Receive Queue. The Responder MUST ensure that an increase in receive resources is effected before the next RPC Reply message is sent.",
      "ja": "要求および付与されたクレジット値は、いずれかのピアで有効なニーズまたはポリシーに一致するように調整される場合があります。たとえば、レスポンダは許可されたクレジット値を減らして、共有受信キュー内の使用可能なリソースに対応できます。レスポンダは、次のRPC応答メッセージが送信される前に、受信リソースの増加が行われるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "A Requester MUST maintain enough receive resources to accommodate expected replies. Responders have to be prepared for there to be no receive resources available on Requesters with no pending RPC transactions.",
      "ja": "リクエスタは、予期される応答に対応するために十分な受信リソースを維持する必要があります。保留中のRPCトランザクションがなく、リクエスタで利用可能な受信リソースがないように、レスポンダを準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Certain RDMA implementations may impose additional flow-control restrictions, such as limits on RDMA Read operations in progress at the Responder. Accommodation of such restrictions is considered the responsibility of each RPC-over-RDMA version 1 implementation.",
      "ja": "特定のRDMA実装では、レスポンダで進行中のRDMA読み取り操作に対する制限など、追加のフロー制御制限が課される場合があります。このような制限への対応は、RPC-over-RDMAバージョン1の各実装の責任と見なされます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Inline Threshold",
      "section_title": true,
      "ja": "3.3.2. インラインしきい値"
    },
    {
      "indent": 3,
      "text": "An \"inline threshold\" value is the largest message size (in octets) that can be conveyed in one direction between peer implementations using RDMA Send and Receive. The inline threshold value is the smaller of the largest number of bytes the sender can post via a single RDMA Send operation and the largest number of bytes the receiver can accept via a single RDMA Receive operation. Each connection has two inline threshold values: one for messages flowing from Requester-to-Responder (referred to as the \"call inline threshold\") and one for messages flowing from Responder-to-Requester (referred to as the \"reply inline threshold\").",
      "ja": "「インラインしきい値」の値は、RDMA送信と受信を使用してピア実装間で一方向に伝達できる最大メッセージサイズ（オクテット単位）です。インラインしきい値は、送信者が単一のRDMA送信操作で送信できる最大バイト数と、受信者が単一のRDMA受信操作で受信できる最大バイト数のどちらか小さい方です。各接続には2つのインラインしきい値があります。1つは要求側から応答側へ流れるメッセージ（「呼び出しインラインしきい値」と呼ばれます）ともう1つは応答側から要求側から流れるメッセージ（「応答インラインしきい値」と呼ばれます）です。 ）。"
    },
    {
      "indent": 3,
      "text": "Unlike credit limits, inline threshold values are not advertised to peers via the RPC-over-RDMA version 1 protocol, and there is no provision for inline threshold values to change during the lifetime of an RPC-over-RDMA version 1 connection.",
      "ja": "クレジット制限とは異なり、インラインしきい値はRPC-over-RDMAバージョン1プロトコルを介してピアにアドバタイズされません。また、インラインしきい値がRPC-over-RDMAバージョン1接続の存続期間中に変更されることはありません。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Initial Connection State",
      "section_title": true,
      "ja": "3.3.3. 初期接続状態"
    },
    {
      "indent": 3,
      "text": "When a connection is first established, peers might not know how many receive resources the other has, nor how large the other peer's inline thresholds are.",
      "ja": "接続が最初に確立されたとき、ピアは、他のピアが持っている受信リソースの数も、他のピアのインラインしきい値の大きさも知らない場合があります。"
    },
    {
      "indent": 3,
      "text": "As a basis for an initial exchange of RPC requests, each RPC-over-RDMA version 1 connection provides the ability to exchange at least one RPC message at a time, whose RPC Call and Reply messages are no more than 1024 bytes in size. A Responder MAY exceed this basic level of configuration, but a Requester MUST NOT assume more than one credit is available and MUST receive a valid reply from the Responder carrying the actual number of available credits, prior to sending its next request.",
      "ja": "RPC要求の初期交換の基礎として、各RPC-over-RDMAバージョン1接続は、一度に少なくとも1つのRPCメッセージを交換する機能を提供します。そのRPC呼び出しおよび応答メッセージのサイズは1024バイト以下です。レスポンダはこの基本レベルの構成を超える場合がありますが、リクエスタは複数のクレジットが利用可能であることを想定してはならず、次のリクエストを送信する前に、利用可能なクレジットの実際の数を運ぶレスポンダから有効な応答を受信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Receiver implementations MUST support inline thresholds of 1024 bytes but MAY support larger inline thresholds values. An independent mechanism for discovering a peer's inline thresholds before a connection is established may be used to optimize the use of RDMA Send and Receive operations. In the absence of such a mechanism, senders and receives MUST assume the inline thresholds are 1024 bytes.",
      "ja": "レシーバー実装は1024バイトのインラインしきい値をサポートする必要がありますが、より大きなインラインしきい値をサポートする場合があります（MAY）。接続が確立される前にピアのインラインしきい値を検出するための独立したメカニズムを使用して、RDMA送信および受信操作の使用を最適化できます。このようなメカニズムがない場合、送信側と受信側はインラインしきい値が1024バイトであると想定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. XDR Encoding with Chunks",
      "section_title": true,
      "ja": "3.4. チャンクによるXDRエンコーディング"
    },
    {
      "indent": 3,
      "text": "When a DDP capability is available, the transport places the contents of one or more XDR data items directly into the receiver's memory, separately from the transfer of other parts of the containing XDR stream.",
      "ja": "DDP機能が使用可能な場合、トランスポートは、1つ以上のXDRデータ項目のコンテンツを、それを含むXDRストリームの他の部分の転送とは別に、レシーバーのメモリに直接配置します。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Reducing an XDR Stream",
      "section_title": true,
      "ja": "3.4.1. XDRストリームの削減"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA version 1 provides a mechanism for moving part of an RPC message via a data transfer distinct from an RDMA Send/Receive pair. The sender removes one or more XDR data items from the Payload stream. They are conveyed via other mechanisms, such as one or more RDMA Read or Write operations. As the receiver decodes an incoming message, it skips over directly placed data items.",
      "ja": "RPC-over-RDMAバージョン1は、RDMA送受信ペアとは異なるデータ転送を介してRPCメッセージの一部を移動するメカニズムを提供します。送信者は、ペイロードストリームから1つ以上のXDRデータ項目を削除します。それらは、1つ以上のRDMA読み取りまたは書き込み操作などの他のメカニズムを介して伝達されます。受信側は着信メッセージをデコードするときに、直接配置されたデータ項目をスキップします。"
    },
    {
      "indent": 3,
      "text": "The portion of an XDR stream that is split out and moved separately is referred to as a \"chunk\". In some contexts, data in an RPC-over-RDMA header that describes these split out regions of memory may also be referred to as a \"chunk\".",
      "ja": "XDRストリームの分割されて個別に移動される部分は、「チャンク」と呼ばれます。一部のコンテキストでは、これらのメモリの分割領域を記述するRPC-over-RDMAヘッダー内のデータは、「チャンク」と呼ばれることもあります。"
    },
    {
      "indent": 3,
      "text": "A Payload stream after chunks have been removed is referred to as a \"reduced\" Payload stream. Likewise, a data item that has been removed from a Payload stream to be transferred separately is referred to as a \"reduced\" data item.",
      "ja": "チャンクが削除された後のペイロードストリームは、「削減された」ペイロードストリームと呼ばれます。同様に、ペイロードストリームから削除されて個別に転送されたデータアイテムは、「削減された」データアイテムと呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.4.2. DDP-Eligibility",
      "section_title": true,
      "ja": "3.4.2. DDPの適格性"
    },
    {
      "indent": 3,
      "text": "Not all XDR data items benefit from DDP. For example, small data items or data items that require XDR unmarshaling by the receiver do not benefit from DDP. In addition, it is impractical for receivers to prepare for every possible XDR data item in a protocol to be transferred in a chunk.",
      "ja": "すべてのXDRデータ項目がDDPの恩恵を受けるわけではありません。たとえば、小さいデータアイテムや、受信者によるXDRアンマーシャリングを必要とするデータアイテムは、DDPの恩恵を受けません。さらに、プロトコルで可能なすべてのXDRデータ項目をチャンクで転送する準備をすることは、レシーバにとって非現実的です。"
    },
    {
      "indent": 3,
      "text": "To maintain interoperability on an RPC-over-RDMA transport, a determination must be made of which few XDR data items in each ULP are allowed to use DDP.",
      "ja": "RPC-over-RDMAトランスポートの相互運用性を維持するには、各ULPのどのXDRデータ項目がDDPの使用を許可されているかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is done by additional specifications that describe how ULPs employ DDP. A \"ULB specification\" identifies which specific individual XDR data items in a ULP MAY be transferred via DDP. Such data items are referred to as \"DDP-eligible\". All other XDR data items MUST NOT be reduced.",
      "ja": "これは、ULPがDDPを使用する方法を説明する追加の仕様によって行われます。 「ULB仕様」は、ULP内の特定の個々のXDRデータ項目がDDPを介して転送される可能性があることを識別します。このようなデータ項目は、「DDP対応」と呼ばれます。他のすべてのXDRデータ項目は削減してはなりません。"
    },
    {
      "indent": 3,
      "text": "Detailed requirements for ULBs are provided in Section 6.",
      "ja": "ULBの詳細な要件は、セクション6に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.4.3. RDMA Segments",
      "section_title": true,
      "ja": "3.4.3. RDMAセグメント"
    },
    {
      "indent": 3,
      "text": "When encoding a Payload stream that contains a DDP-eligible data item, a sender may choose to reduce that data item. When it chooses to do so, the sender does not place the item into the Payload stream. Instead, the sender records in the RPC-over-RDMA header the location and size of the memory region containing that data item.",
      "ja": "DDP対応のデータアイテムを含むペイロードストリームをエンコードする場合、送信者はそのデータアイテムを減らすことを選択できます。そうすることを選択した場合、送信者はアイテムをペイロードストリームに配置しません。代わりに、送信者はRPC-over-RDMAヘッダーに、そのデータ項目を含むメモリ領域の場所とサイズを記録します。"
    },
    {
      "indent": 3,
      "text": "The Requester provides location information for DDP-eligible data items in both RPC Call and Reply messages. The Responder uses this information to retrieve arguments contained in the specified region of the Requester's memory or place results in that memory region.",
      "ja": "リクエスターは、R​​PC呼び出しメッセージと応答メッセージの両方で、DDP適格データ項目のロケーション情報を提供します。レスポンダはこの情報を使用して、リクエスタのメモリの指定された領域に含まれる引数を取得するか、結果をそのメモリ領域に配置します。"
    },
    {
      "indent": 3,
      "text": "An \"RDMA segment\", or \"plain segment\", is an RPC-over-RDMA Transport header data object that contains the precise coordinates of a contiguous memory region that is to be conveyed separately from the Payload stream. Plain segments contain the following information:",
      "ja": "「RDMAセグメント」または「プレーンセグメント」は、RPC-over-RDMAトランスポートヘッダーデータオブジェクトであり、ペイロードストリームとは別に伝達される連続したメモリ領域の正確な座標を含みます。プレーンセグメントには、次の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Handle Steering tag (STag) or R_key generated by registering this memory with the RDMA provider.",
      "ja": "このメモリをRDMAプロバイダーに登録して生成されたステアリングタグ（STag）またはR_keyを処理します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the RDMA segment's memory region, in octets. An \"empty segment\" is an RDMA segment with the value zero (0) in its length field.",
      "ja": "長さRDMAセグメントのメモリ領域の長さ（オクテット単位）。 「空のセグメント」は、その長さフィールドに値がゼロ（0）のRDMAセグメントです。"
    },
    {
      "indent": 3,
      "text": "Offset The offset or beginning memory address of the RDMA segment's memory region.",
      "ja": "オフセットRDMAセグメントのメモリ領域のオフセットまたは開始メモリアドレス。"
    },
    {
      "indent": 3,
      "text": "See [RFC5040] for further discussion.",
      "ja": "詳細については、[RFC5040]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.4. Chunks",
      "section_title": true,
      "ja": "3.4.4. チャンク"
    },
    {
      "indent": 3,
      "text": "In RPC-over-RDMA version 1, a \"chunk\" refers to a portion of the Payload stream that is moved independently of the RPC-over-RDMA Transport header and Payload stream. Chunk data is removed from the sender's Payload stream, transferred via separate operations, and then reinserted into the receiver's Payload stream to form a complete RPC message.",
      "ja": "RPC-over-RDMAバージョン1では、「チャンク」とは、RPC-over-RDMAトランスポートヘッダーおよびペイロードストリームとは無関係に移動されるペイロードストリームの一部を指します。チャンクデータは、送信者のペイロードストリームから削除され、個別の操作で転送された後、受信者のペイロードストリームに再挿入されて、完全なRPCメッセージを形成します。"
    },
    {
      "indent": 3,
      "text": "Each chunk is comprised of RDMA segments. Each RDMA segment represents a single contiguous piece of that chunk. A Requester MAY divide a chunk into RDMA segments using any boundaries that are convenient. The length of a chunk is the sum of the lengths of the RDMA segments that comprise it.",
      "ja": "各チャンクはRDMAセグメントで構成されています。各RDMAセグメントは、そのチャンクの単一の連続した部分を表します。リクエスターは、便利な境界を使用してチャンクをRDMAセグメントに分割してもよい（MAY）。チャンクの長さは、チャンクを構成するRDMAセグメントの長さの合計です。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA version 1 transport protocol does not place a limit on chunk size. However, each ULP may cap the amount of data that can be transferred by a single RPC (for example, NFS has \"rsize\" and \"wsize\", which restrict the payload size of NFS READ and WRITE operations). The Responder can use such limits to sanity check chunk sizes before using them in RDMA operations.",
      "ja": "RPC-over-RDMAバージョン1トランスポートプロトコルでは、チャンクサイズに制限はありません。ただし、各ULPは、単一のRPCによって転送できるデータ量を制限する場合があります（たとえば、NFSにはNFSのREADおよびWRITE操作のペイロードサイズを制限する「rsize」と「wsize」があります）。レスポンダは、RDMA操作でチャンクサイズを使用する前に、このような制限を使用してチャンクサイズを検証します。"
    },
    {
      "indent": 0,
      "text": "3.4.4.1. Counted Arrays",
      "section_title": true,
      "ja": "3.4.4.1. カウントされた配列"
    },
    {
      "indent": 3,
      "text": "If a chunk contains a counted array data type, the count of array elements MUST remain in the Payload stream, while the array elements MUST be moved to the chunk. For example, when encoding an opaque byte array as a chunk, the count of bytes stays in the Payload stream, while the bytes in the array are removed from the Payload stream and transferred within the chunk.",
      "ja": "チャンクにカウントされた配列データ型が含まれている場合、配列要素の数はペイロードストリームに残っている必要がありますが、配列要素はチャンクに移動する必要があります。たとえば、不透明なバイト配列をチャンクとしてエンコードする場合、バイトカウントはペイロードストリームに残りますが、配列内のバイトはペイロードストリームから削除され、チャンク内で転送されます。"
    },
    {
      "indent": 3,
      "text": "Individual array elements appear in a chunk in their entirety. For example, when encoding an array of arrays as a chunk, the count of items in the enclosing array stays in the Payload stream, but each enclosed array, including its item count, is transferred as part of the chunk.",
      "ja": "個々の配列要素は、全体がチャンクで表示されます。たとえば、配列の配列をチャンクとしてエンコードする場合、囲んでいる配列の項目数はペイロードストリームに残りますが、項目数を含む囲まれた各配列は、チャンクの一部として転送されます。"
    },
    {
      "indent": 0,
      "text": "3.4.4.2. Optional-Data",
      "section_title": true,
      "ja": "3.4.4.2. オプションデータ"
    },
    {
      "indent": 3,
      "text": "If a chunk contains an optional-data data type, the \"is present\" field MUST remain in the Payload stream, while the data, if present, MUST be moved to the chunk.",
      "ja": "チャンクにオプションのデータデータタイプが含まれている場合、「存在する」フィールドはペイロードストリームに残っている必要がありますが、データが存在する場合は、チャンクに移動する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.4.3. XDR Unions",
      "section_title": true,
      "ja": "3.4.4.3. XDRユニオン"
    },
    {
      "indent": 3,
      "text": "A union data type MUST NOT be made DDP-eligible, but one or more of its arms MAY be DDP-eligible, subject to the other requirements in this section.",
      "ja": "ユニオンデータタイプをDDPに適合させることはできませんが、このセクションの他の要件に従って、そのアームの1つ以上をDDPに適合させることができます（MAY）。"
    },
    {
      "indent": 0,
      "text": "3.4.4.4. Chunk Roundup",
      "section_title": true,
      "ja": "3.4.4.4. チャンクのまとめ"
    },
    {
      "indent": 3,
      "text": "Except in special cases (covered in Section 3.5.3), a chunk MUST contain exactly one XDR data item. This makes it straightforward to reduce variable-length data items without affecting the XDR alignment of data items in the Payload stream.",
      "ja": "特別な場合（セクション3.5.3で説明）を除き、チャンクにはXDRデータ項目を1つだけ含める必要があります。これにより、ペイロードストリーム内のデータアイテムのXDRアラインメントに影響を与えることなく、可変長データアイテムを簡単に削減できます。"
    },
    {
      "indent": 3,
      "text": "When a variable-length XDR data item is reduced, the sender MUST remove XDR roundup padding for that data item from the Payload stream so that data items remaining in the Payload stream begin on four-byte alignment.",
      "ja": "可変長のXDRデータ項目が削減された場合、送信者はそのデータ項目のXDR丸めパディングをペイロードストリームから削除して、ペイロードストリームに残っているデータ項目が4バイトアライメントで始まるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.5. Read Chunks",
      "section_title": true,
      "ja": "3.4.5. チャンクを読み取る"
    },
    {
      "indent": 3,
      "text": "A \"Read chunk\" represents an XDR data item that is to be pulled from the Requester to the Responder.",
      "ja": "「読み取りチャンク」は、リクエスターからレスポンダーにプルされるXDRデータ項目を表します。"
    },
    {
      "indent": 3,
      "text": "A Read chunk is a list of one or more RDMA read segments. An RDMA read segment consists of a Position field followed by a plain segment. See Section 4.1.2 for details.",
      "ja": "読み取りチャンクは、1つ以上のRDMA読み取りセグメントのリストです。 RDMA読み取りセグメントは、位置フィールドとそれに続くプレーンセグメントで構成されます。詳細については、セクション4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Position The byte offset in the unreduced Payload stream where the receiver reinserts the data item conveyed in a chunk. The Position value MUST be computed from the beginning of the unreduced Payload stream, which begins at Position zero. All RDMA read segments belonging to the same Read chunk have the same value in their Position field.",
      "ja": "Positionレシーバーがチャンクで伝達されたデータアイテムを再挿入する、縮小されていないペイロードストリームのバイトオフセット。 Position値は、Position 0から始まる、縮小されていないペイロードストリームの先頭から計算する必要があります。同じ読み取りチャンクに属するすべてのRDMA読み取りセグメントは、位置フィールドに同じ値を持っています。"
    },
    {
      "indent": 3,
      "text": "While constructing an RPC Call message, a Requester registers memory regions that contain data to be transferred via RDMA Read operations. It advertises the coordinates of these regions in the RPC-over-RDMA Transport header of the RPC Call message.",
      "ja": "RPC呼び出しメッセージの作成中に、リクエスターはRDMA読み取り操作で転送されるデータを含むメモリー領域を登録します。 RPC CallメッセージのRPC-over-RDMAトランスポートヘッダーでこれらの領域の座標を通知します。"
    },
    {
      "indent": 3,
      "text": "After receiving an RPC Call message sent via an RDMA Send operation, a Responder transfers the chunk data from the Requester using RDMA Read operations. The Responder reconstructs the transferred chunk data by concatenating the contents of each RDMA segment, in list order, into the received Payload stream at the Position value recorded in that RDMA segment.",
      "ja": "RDMA送信操作を介して送信されたRPC呼び出しメッセージを受信した後、レスポンダーはRDMA読み取り操作を使用してリクエスターからチャンクデータを転送します。レスポンダは、各RDMAセグメントの内容をリスト順に連結して、転送されたチャンクデータを再構築し、そのRDMAセグメントに記録された位置値で受信したペイロードストリームに入れます。"
    },
    {
      "indent": 3,
      "text": "Put another way, the Responder inserts the first RDMA segment in a Read chunk into the Payload stream at the byte offset indicated by its Position field. RDMA segments whose Position field value match this offset are concatenated afterwards, until there are no more RDMA segments at that Position value.",
      "ja": "言い換えると、レスポンダは、読み取りチャンクの最初のRDMAセグメントを、その位置フィールドで示されるバイトオフセットでペイロードストリームに挿入します。位置フィールド値がこのオフセットと一致するRDMAセグメントは、その位置値でRDMAセグメントがなくなるまで、後で連結されます。"
    },
    {
      "indent": 3,
      "text": "The Position field in a read segment indicates where the containing Read chunk starts in the Payload stream. The value in this field MUST be a multiple of four. All segments in the same Read chunk share the same Position value, even if one or more of the RDMA segments have a non-four-byte-aligned length.",
      "ja": "読み取りセグメントのPositionフィールドは、含まれている読み取りチャンクがペイロードストリームのどこから始まるかを示します。このフィールドの値は4の倍数でなければなりません。同じ読み取りチャンク内のすべてのセグメントは、1つ以上のRDMAセグメントの長さが4バイトに揃えられていなくても、同じ位置値を共有します。"
    },
    {
      "indent": 0,
      "text": "3.4.5.1. Decoding Read Chunks",
      "section_title": true,
      "ja": "3.4.5.1. 読み取りチャンクのデコード"
    },
    {
      "indent": 3,
      "text": "While decoding a received Payload stream, whenever the XDR offset in the Payload stream matches that of a Read chunk, the Responder initiates an RDMA Read to pull the chunk's data content into registered local memory.",
      "ja": "受信したペイロードストリームをデコードしている間、ペイロードストリームのXDRオフセットが読み取りチャンクのオフセットと一致すると、レスポンダはRDMA読み取りを開始して、チャンクのデータコンテンツを登録されたローカルメモリにプルします。"
    },
    {
      "indent": 3,
      "text": "The Responder acknowledges its completion of use of Read chunk source buffers when it sends an RPC Reply message to the Requester. The Requester may then release Read chunks advertised in the request.",
      "ja": "レスポンダは、RPC応答メッセージをリクエスタに送信するときに、読み取りチャンクソースバッファの使用の完了を確認します。次に、リクエスタは、リクエストでアドバタイズされた読み取りチャンクを解放できます。"
    },
    {
      "indent": 0,
      "text": "3.4.5.2. Read Chunk Roundup",
      "section_title": true,
      "ja": "3.4.5.2. チャンクのまとめを読む"
    },
    {
      "indent": 3,
      "text": "When reducing a variable-length argument data item, the Requester SHOULD NOT include the data item's XDR roundup padding in the chunk. The length of a Read chunk is determined as follows:",
      "ja": "可変長引数のデータ項目を削減する場合、リクエスターはチャンクにデータ項目のXDR切り上げパディングを含めるべきではありません（SHOULD NOT）。読み取りチャンクの長さは次のように決定されます。"
    },
    {
      "indent": 3,
      "text": "o If the Requester chooses to include roundup padding in a Read chunk, the chunk's total length MUST be the sum of the encoded length of the data item and the length of the roundup padding. The length of the data item that was encoded into the Payload stream remains unchanged.",
      "ja": "o リクエスターが読み取りチャンクに切り上げパディングを含めることを選択した場合、チャンクの全長は、データ項目のエンコードされた長さと切り上げパディングの長さの合計でなければなりません。ペイロードストリームにエンコードされたデータアイテムの長さは変更されません。"
    },
    {
      "indent": 6,
      "text": "The sender can increase the length of the chunk by adding another RDMA segment containing only the roundup padding, or it can do so by extending the final RDMA segment in the chunk.",
      "ja": "送信側は、切り上げパディングのみを含む別のRDMAセグメントを追加してチャンクの長さを増やすか、チャンク内の最後のRDMAセグメントを拡張することでチャンクの長さを増やすことができます。"
    },
    {
      "indent": 3,
      "text": "o If the sender chooses not to include roundup padding in the chunk, the chunk's total length MUST be the same as the encoded length of the data item.",
      "ja": "o 送信者がチャンクに切り上げパディングを含めないことを選択した場合、チャンクの全長は、データ項目のエンコードされた長さと同じでなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Write Chunks",
      "section_title": true,
      "ja": "3.4.6. チャンクを書き込む"
    },
    {
      "indent": 3,
      "text": "While constructing an RPC Call message, a Requester prepares memory regions in which to receive DDP-eligible result data items. A \"Write chunk\" represents an XDR data item that is to be pushed from a Responder to a Requester. It is made up of an array of zero or more plain segments.",
      "ja": "RPC呼び出しメッセージの作成中に、リクエスターはDDPに適格な結果データ項目を受信するためのメモリー領域を準備します。 「書き込みチャンク」は、レスポンダからリクエスタにプッシュされるXDRデータ項目を表します。ゼロ個以上のプレーンセグメントの配列で構成されています。"
    },
    {
      "indent": 3,
      "text": "Write chunks are provisioned by a Requester long before the Responder has prepared the reply Payload stream. A Requester often does not know the actual length of the result data items to be returned, since the result does not yet exist. Thus, it MUST register Write chunks long enough to accommodate the maximum possible size of each returned data item.",
      "ja": "書き込みチャンクは、レスポンダが応答ペイロードストリームを準備するずっと前にリクエスタによってプロビジョニングされます。結果がまだ存在しないため、リクエスターは、返される結果データ項目の実際の長さを知らないことがよくあります。したがって、返された各データ項目の最大可能サイズに対応するのに十分な長さの書き込みチャンクを登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition, the XDR position of DDP-eligible data items in the reply's Payload stream is not predictable when a Requester constructs an RPC Call message. Therefore, RDMA segments in a Write chunk do not have a Position field.",
      "ja": "さらに、リクエスターがRPC呼び出しメッセージを作成するとき、応答のペイロードストリーム内のDDP対応のデータアイテムのXDR位置は予測できません。したがって、書き込みチャンクのRDMAセグメントには位置フィールドがありません。"
    },
    {
      "indent": 3,
      "text": "For each Write chunk provided by a Requester, the Responder pushes one data item to the Requester, filling the chunk contiguously and in segment array order until that data item has been completely written to the Requester. The Responder MUST copy the segment count and all segments from the Requester-provided Write chunk into the RPC Reply message's Transport header. As it does so, the Responder updates each segment length field to reflect the actual amount of data that is being returned in that segment. The Responder then sends the RPC Reply message via an RDMA Send operation.",
      "ja": "リクエスターによって提供された各書き込みチャンクについて、レスポンダーは1つのデータ項目をリクエスターにプッシュし、そのデータ項目がリクエスターに完全に書き込まれるまで、チャンクを連続してセグメント配列順に埋めます。レスポンダは、リクエスタが提供する書き込みチャンクのセグメント数とすべてのセグメントをRPC応答メッセージのトランスポートヘッダーにコピーする必要があります。その際、レスポンダは各セグメントの長さフィールドを更新して、そのセグメントで返される実際のデータ量を反映します。次に、レスポンダはRDMA送信操作を介してRPC応答メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "An \"empty Write chunk\" is a Write chunk with a zero segment count. By definition, the length of an empty Write chunk is zero. An \"unused Write chunk\" has a non-zero segment count, but all of its segments are empty segments.",
      "ja": "「空の書き込みチャンク」は、セグメント数がゼロの書き込みチャンクです。定義により、空の書き込みチャンクの長さはゼロです。 「未使用の書き込みチャンク」のセグメント数はゼロではありませんが、そのセグメントはすべて空のセグメントです。"
    },
    {
      "indent": 0,
      "text": "3.4.6.1. Decoding Write Chunks",
      "section_title": true,
      "ja": "3.4.6.1. 書き込みチャンクのデコード"
    },
    {
      "indent": 3,
      "text": "After receiving the RPC Reply message, the Requester reconstructs the transferred data by concatenating the contents of each segment, in array order, into the RPC Reply message's XDR stream at the known XDR position of the associated DDP-eligible result data item.",
      "ja": "RPC応答メッセージを受信した後、リクエスターは各セグメントの内容を配列順に連結して、関連するDDP対応の結果データ項目の既知のXDR位置にあるRPC応答メッセージのXDRストリームに転送されたデータを再構築します。"
    },
    {
      "indent": 0,
      "text": "3.4.6.2. Write Chunk Roundup",
      "section_title": true,
      "ja": "3.4.6.2. チャンクのまとめ"
    },
    {
      "indent": 3,
      "text": "When provisioning a Write chunk for a variable-length result data item, the Requester SHOULD NOT include additional space for XDR roundup padding. A Responder MUST NOT write XDR roundup padding into a Write chunk, even if the Requester made space available for it. Therefore, when returning a single variable-length result data item, a returned Write chunk's total length MUST be the same as the encoded length of the result data item.",
      "ja": "可変長の結果データ項目の書き込みチャンクをプロビジョニングする場合、リクエスターはXDRの丸めパディングのための追加のスペースを含めるべきではありません（SHOULD NOT）。要求側がスペースを利用可能にした場合でも、レスポンダーはXDRの丸めパディングを書き込みチャンクに書き込んではいけません（MUST NOT）。したがって、単一の可変長の結果データ項目を返す場合、返される書き込みチャンクの全長は、結果データ項目のエンコードされた長さと同じでなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.5. Message Size",
      "section_title": true,
      "ja": "3.5. メッセージサイズ"
    },
    {
      "indent": 3,
      "text": "A receiver of RDMA Send operations is required by RDMA to have previously posted one or more adequately sized buffers. Memory savings are achieved on both Requesters and Responders by posting small Receive buffers. However, not all RPC messages are small. RPC-over-RDMA version 1 provides several mechanisms that allow messages of any size to be conveyed efficiently.",
      "ja": "RDMA送信操作のレシーバーは、RDMAが以前に1つ以上の適切なサイズのバッファーをポストするために必要です。メモリの節約は、小さな受信バッファをポストすることにより、リクエスタとレスポンダの両方で達成されます。ただし、すべてのRPCメッセージが小さいわけではありません。 RPC-over-RDMAバージョン1は、任意のサイズのメッセージを効率的に伝達できるいくつかのメカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Short Messages",
      "section_title": true,
      "ja": "3.5.1. 短いメッセージ"
    },
    {
      "indent": 3,
      "text": "RPC messages are frequently smaller than typical inline thresholds. For example, the NFS version 3 GETATTR operation is only 56 bytes: 20 bytes of RPC header, a 32-byte file handle argument, and 4 bytes for its length. The reply to this common request is about 100 bytes.",
      "ja": "RPCメッセージは、通常のインラインしきい値よりも小さいことがよくあります。たとえば、NFSバージョン3のGETATTR操作はわずか56バイトです。20バイトのRPCヘッダー、32バイトのファイルハンドル引数、および4バイトの長さです。この一般的な要求への応答は約100バイトです。"
    },
    {
      "indent": 3,
      "text": "Since all RPC messages conveyed via RPC-over-RDMA require an RDMA Send operation, the most efficient way to send an RPC message that is smaller than the inline threshold is to append the Payload stream directly to the Transport stream. An RPC-over-RDMA header with a small RPC Call or Reply message immediately following is transferred using a single RDMA Send operation. No other operations are needed.",
      "ja": "RPC-over-RDMAを介して伝達されるすべてのRPCメッセージにはRDMA送信操作が必要であるため、インラインしきい値よりも小さいRPCメッセージを送信する最も効率的な方法は、ペイロードストリームをトランスポートストリームに直接追加することです。直後に小さなRPC CallまたはReplyメッセージを含むRPC-over-RDMAヘッダーは、単一のRDMA送信操作を使用して転送されます。他の操作は必要ありません。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using Short Messages:",
      "ja": "ショートメッセージを使用したRPC-over-RDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5.2. Chunked Messages",
      "section_title": true,
      "ja": "3.5.2. チャンクメッセージ"
    },
    {
      "indent": 3,
      "text": "If DDP-eligible data items are present in a Payload stream, a sender MAY reduce some or all of these items by removing them from the Payload stream. The sender uses a separate mechanism to transfer the reduced data items. The Transport stream with the reduced Payload stream immediately following is then transferred using a single RDMA Send operation.",
      "ja": "ペイロードストリームにDDP対応のデータアイテムが存在する場合、送信者は、これらのアイテムの一部またはすべてをペイロードストリームから削除することにより、それらを削減できます（MAY）。送信者は、別のメカニズムを使用して、削減されたデータ項目を転送します。直後にペイロードストリームが削減されたトランスポートストリームは、単一のRDMA送信操作を使用して転送されます。"
    },
    {
      "indent": 3,
      "text": "After receiving the Transport and Payload streams of an RPC Call message accompanied by Read chunks, the Responder uses RDMA Read operations to move reduced data items in Read chunks. Before sending the Transport and Payload streams of an RPC Reply message containing Write chunks, the Responder uses RDMA Write operations to move reduced data items in Write and Reply chunks.",
      "ja": "読み取りチャンクを伴うRPCコールメッセージのトランスポートストリームとペイロードストリームを受信した後、レスポンダはRDMA読み取り操作を使用して、読み取りチャンク内の削減されたデータ項目を移動します。書き込みチャンクを含むRPC応答メッセージのトランスポートストリームとペイロードストリームを送信する前に、レスポンダーはRDMA書き込み操作を使用して、書き込みチャンクと返信チャンクの削減されたデータ項目を移動します。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction with a Read chunk:",
      "ja": "読み取りチャンクを使用したRPC-over-RDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |        RDMA Read                    |\n     |   <------------------------------   |\n     |        RDMA Response (arg data)     |\n     |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction with a Write chunk:",
      "ja": "書き込みチャンクを使用したRPC-over-RDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Write (result data)     |\n     |   <------------------------------   |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5.3. Long Messages",
      "section_title": true,
      "ja": "3.5.3. 長いメッセージ"
    },
    {
      "indent": 3,
      "text": "When a Payload stream is larger than the receiver's inline threshold, the Payload stream is reduced by removing DDP-eligible data items and placing them in chunks to be moved separately. If there are no DDP-eligible data items in the Payload stream, or the Payload stream is still too large after it has been reduced, the RDMA transport MUST use RDMA Read or Write operations to convey the Payload stream itself. This mechanism is referred to as a \"Long Message\".",
      "ja": "ペイロードストリームがレシーバーのインラインしきい値よりも大きい場合、ペイロードストリームは、DDP対応のデータアイテムを削除し、それらを個別に移動するチャンクに配置することによって削減されます。ペイロードストリームにDDP対応のデータアイテムがない場合、または削減された後もペイロードストリームが大きすぎる場合、RDMAトランスポートはRDMA読み取りまたは書き込み操作を使用して、ペイロードストリーム自体を伝達する必要があります。このメカニズムは「ロングメッセージ」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "To transmit a Long Message, the sender conveys only the Transport stream with an RDMA Send operation. The Payload stream is not included in the Send buffer in this instance. Instead, the Requester provides chunks that the Responder uses to move the Payload stream.",
      "ja": "長いメッセージを送信するために、送信者はRDMA送信操作でトランスポートストリームのみを伝達します。この場合、ペイロードストリームは送信バッファに含まれません。代わりに、リクエスターは、レスポンダーがペイロードストリームを移動するために使用するチャンクを提供します。"
    },
    {
      "indent": 3,
      "text": "Long Call To send a Long Call message, the Requester provides a special Read chunk that contains the RPC Call message's Payload stream. Every RDMA read segment in this chunk MUST contain zero in its Position field. Thus, this chunk is known as a \"Position Zero Read chunk\".",
      "ja": "ロングコールロングコールメッセージを送信するために、リクエスタはRPCコールメッセージのペイロードストリームを含む特別な読み取りチャンクを提供します。このチャンクのすべてのRDMA読み取りセグメントは、その位置フィールドにゼロを含んでいる必要があります。したがって、このチャンクは「位置ゼロ読み取りチャンク」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Long Reply To send a Long Reply, the Requester provides a single special Write chunk in advance, known as the \"Reply chunk\", that will contain the RPC Reply message's Payload stream. The Requester sizes the Reply chunk to accommodate the maximum expected reply size for that upper-layer operation.",
      "ja": "Long Reply Long Replyを送信するために、リクエスタはRPC Replyメッセージのペイロードストリームを含む「Replyチャンク」と呼ばれる単一の特別な書き込みチャンクを事前に提供します。リクエスターは、その上位層操作で予想される最大応答サイズに対応するように、応答チャンクのサイズを決定します。"
    },
    {
      "indent": 3,
      "text": "Though the purpose of a Long Message is to handle large RPC messages, Requesters MAY use a Long Message at any time to convey an RPC Call message.",
      "ja": "長いメッセージの目的は大きなRPCメッセージを処理することですが、要求者はいつでも長いメッセージを使用してRPC呼び出しメッセージを伝えることができます（MAY）。"
    },
    {
      "indent": 3,
      "text": "A Responder chooses which form of reply to use based on the chunks provided by the Requester. If Write chunks were provided and the Responder has a DDP-eligible result, it first reduces the reply Payload stream. If a Reply chunk was provided and the reduced Payload stream is larger than the reply inline threshold, the Responder MUST use the Requester-provided Reply chunk for the reply.",
      "ja": "レスポンダは、リクエスタによって提供されたチャンクに基づいて、使用する応答の形式を選択します。書き込みチャンクが提供され、レスポンダにDDP対応の結果がある場合、最初に返信ペイロードストリームが削減されます。返信チャンクが提供され、削減されたペイロードストリームが返信インラインしきい値より大きい場合、レスポンダはリクエスタが提供する返信チャンクを返信に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "XDR data items may appear in these special chunks without regard to their DDP-eligibility. As these chunks contain a Payload stream, such chunks MUST include appropriate XDR roundup padding to maintain proper XDR alignment of their contents.",
      "ja": "XDRデータ項目は、DDPの適格性に関係なく、これらの特別なチャンクに表示される場合があります。これらのチャンクにはペイロードストリームが含まれているため、そのようなチャンクには、コンテンツの適切なXDRアラインメントを維持するために、適切なXDRラウンドアップパディングを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using a Long Call:",
      "ja": "ロングコールを使用したRPC-over-RDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_NOMSG)       |\nCall |   ------------------------------>   |\n     |        RDMA Read                    |\n     |   <------------------------------   |\n     |        RDMA Response (RPC call)     |\n     |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using a Long Reply:",
      "ja": "Long Replyを使用したRPC-over-RDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Write (RPC reply)       |\n     |   <------------------------------   |\n     |        RDMA Send (RDMA_NOMSG)       |\n     |   <------------------------------   | Reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. RPC-over-RDMA in Operation",
      "section_title": true,
      "ja": "4. 稼働中のRPC-over-RDMA"
    },
    {
      "indent": 3,
      "text": "Every RPC-over-RDMA version 1 message has a header that includes a copy of the message's transaction ID, data for managing RDMA flow-control credits, and lists of RDMA segments describing chunks. All RPC-over-RDMA header content is contained in the Transport stream; thus, it MUST be XDR encoded.",
      "ja": "すべてのRPC-over-RDMAバージョン1メッセージには、メッセージのトランザクションIDのコピー、RDMAフロー制御クレジットを管理するためのデータ、およびチャンクを記述するRDMAセグメントのリストを含むヘッダーがあります。 RPC-over-RDMAヘッダーのコンテンツはすべてトランスポートストリームに含まれています。したがって、XDRエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "RPC message layout is unchanged from that described in [RFC5531] except for the possible reduction of data items that are moved by separate operations.",
      "ja": "RPCメッセージのレイアウトは、[RFC5531]で説明されているものから変更されていませんが、個別の操作によって移動されるデータ項目が削減される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA protocol passes RPC messages without regard to their type (CALL or REPLY). Apart from restrictions imposed by ULBs, each endpoint of a connection MAY send RDMA_MSG or RDMA_NOMSG message header types at any time (subject to credit limits).",
      "ja": "RPC-over-RDMAプロトコルは、タイプ（CALLまたはREPLY）に関係なくRPCメッセージを渡します。 ULBによって課せられる制限とは別に、接続の各エンドポイントは、いつでも（クレジット制限に従って）RDMA_MSGまたはRDMA_NOMSGメッセージヘッダータイプを送信できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "4.1. XDR Protocol Definition",
      "section_title": true,
      "ja": "4.1. XDRプロトコル定義"
    },
    {
      "indent": 3,
      "text": "This section contains a description of the core features of the RPC-over-RDMA version 1 protocol, expressed in the XDR language [RFC4506].",
      "ja": "このセクションでは、RPC-over-RDMAバージョン1プロトコルのコア機能について、XDR言語[RFC4506]で説明しています。"
    },
    {
      "indent": 3,
      "text": "This description is provided in a way that makes it simple to extract into ready-to-compile form. The reader can apply the following shell script to this document to produce a machine-readable XDR description of the RPC-over-RDMA version 1 protocol.",
      "ja": "この説明は、すぐにコンパイルできる形式に簡単に抽出できるように提供されています。読者はこのドキュメントに次のシェルスクリプトを適用して、RPC-over-RDMAバージョン1プロトコルの機械可読なXDR記述を生成できます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh\ngrep '^ *///' | sed 's?^ /// ??' | sed 's?^ *///$??'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " <CODE ENDS> That is, if the above script is stored in a file called \"extract.sh\" and this document is in a file called \"spec.txt\", then the reader can do the following to extract an XDR description file:",
      "ja": "<CODE ENDS>つまり、上記のスクリプトが「extract.sh」というファイルに格納されていて、このドキュメントが「spec.txt」というファイルにある場合、リーダーは次のようにしてXDR記述ファイルを抽出できます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 3,
      "text": "sh extract.sh < spec.txt > rpcrdma_corev1.x",
      "ja": "sh extract.sh <spec.txt> rpcrdma_corev1.x"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 0,
      "text": "4.1.1. Code Component License",
      "section_title": true,
      "ja": "4.1.1. コードコンポーネントライセンス"
    },
    {
      "indent": 3,
      "text": "Code components extracted from this document must include the following license text. When the extracted XDR code is combined with other complementary XDR code, which itself has an identical license, only a single copy of the license text need be preserved.",
      "ja": "このドキュメントから抽出されたコードコンポーネントには、次のライセンステキストが含まれている必要があります。抽出されたXDRコードを、それ自体が同一のライセンスを持つ他の補完的なXDRコードと組み合わせる場合、ライセンステキストの単一のコピーのみを保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Copyright (c) 2010-2017 IETF Trust and the persons\n///  * identified as authors of the code.  All rights reserved.\n///  *\n///  * The authors of the code are:\n///  * B. Callaghan, T. Talpey, and C. Lever\n///  *\n///  * Redistribution and use in source and binary forms, with\n///  * or without modification, are permitted provided that the\n///  * following conditions are met:\n///  *\n///  * - Redistributions of source code must retain the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer.\n///  *\n///  * - Redistributions in binary form must reproduce the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer in the documentation and/or other\n///  *   materials provided with the distribution.\n///  *\n///  * - Neither the name of Internet Society, IETF or IETF\n///  *   Trust, nor the names of specific contributors, may be\n///  *   used to endorse or promote products derived from this\n///  *   software without specific prior written permission.\n///  *\n///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///  *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///  */\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 0,
      "text": "4.1.2. RPC-over-RDMA Version 1 XDR",
      "section_title": true,
      "ja": "4.1.2. RPC-over-RDMAバージョン1 XDR"
    },
    {
      "indent": 3,
      "text": "XDR data items defined in this section encodes the Transport Header Stream in each RPC-over-RDMA version 1 message. Comments identify items that cannot be changed in subsequent versions.",
      "ja": "このセクションで定義されているXDRデータ項目は、各RPC-over-RDMAバージョン1メッセージのトランスポートヘッダーストリームをエンコードします。コメントは、以降のバージョンで変更できないアイテムを示します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<コード開始>"
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Plain RDMA segment (Section 3.4.3)\n///  */\n/// struct xdr_rdma_segment {\n///    uint32 handle;           /* Registered memory handle */\n///    uint32 length;           /* Length of the chunk in bytes */\n///    uint64 offset;           /* Chunk virtual address or offset */\n/// };\n///\n/// /*\n///  * RDMA read segment (Section 3.4.5)\n///  */\n/// struct xdr_read_chunk {\n///    uint32 position;        /* Position in XDR stream */\n///    struct xdr_rdma_segment target;\n/// };\n///\n/// /*\n///  * Read list (Section 4.3.1)\n///  */\n/// struct xdr_read_list {\n///         struct xdr_read_chunk entry;\n///         struct xdr_read_list  *next;\n/// };\n///\n/// /*\n///  * Write chunk (Section 3.4.6)\n///  */\n/// struct xdr_write_chunk {\n///         struct xdr_rdma_segment target<>;\n/// };\n///\n/// /*\n///  * Write list (Section 4.3.2)\n///  */\n/// struct xdr_write_list {\n///         struct xdr_write_chunk entry;\n///         struct xdr_write_list  *next;\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Chunk lists (Section 4.3)\n///  */\n/// struct rpc_rdma_header {\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n///    /* rpc body follows */\n/// };\n///\n/// struct rpc_rdma_header_nomsg {\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n/// };\n///\n/// /* Not to be used */\n/// struct rpc_rdma_header_padded {\n///    uint32                 rdma_align;\n///    uint32                 rdma_thresh;\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n///    /* rpc body follows */\n/// };\n///\n/// /*\n///  * Error handling (Section 4.5)\n///  */\n/// enum rpc_rdma_errcode {\n///    ERR_VERS = 1,       /* Value fixed for all versions */\n///    ERR_CHUNK = 2\n/// };\n///\n/// /* Structure fixed for all versions */\n/// struct rpc_rdma_errvers {\n///    uint32 rdma_vers_low;\n///    uint32 rdma_vers_high;\n/// };\n///\n/// union rpc_rdma_error switch (rpc_rdma_errcode err) {\n///    case ERR_VERS:\n///      rpc_rdma_errvers range;\n///    case ERR_CHUNK:\n///      void;\n/// };\n///\n/// /*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///  * Procedures (Section 4.2.4)\n///  */\n/// enum rdma_proc {\n///    RDMA_MSG = 0,     /* Value fixed for all versions */\n///    RDMA_NOMSG = 1,   /* Value fixed for all versions */\n///    RDMA_MSGP = 2,    /* Not to be used */\n///    RDMA_DONE = 3,    /* Not to be used */\n///    RDMA_ERROR = 4    /* Value fixed for all versions */\n/// };\n///\n/// /* The position of the proc discriminator field is\n///  * fixed for all versions */\n/// union rdma_body switch (rdma_proc proc) {\n///    case RDMA_MSG:\n///      rpc_rdma_header rdma_msg;\n///    case RDMA_NOMSG:\n///      rpc_rdma_header_nomsg rdma_nomsg;\n///    case RDMA_MSGP:   /* Not to be used */\n///      rpc_rdma_header_padded rdma_msgp;\n///    case RDMA_DONE:   /* Not to be used */\n///      void;\n///    case RDMA_ERROR:\n///      rpc_rdma_error rdma_error;\n/// };\n///\n/// /*\n///  * Fixed header fields (Section 4.2)\n///  */\n/// struct rdma_msg {\n///    uint32    rdma_xid;      /* Position fixed for all versions */\n///    uint32    rdma_vers;     /* Position fixed for all versions */\n///    uint32    rdma_credit;   /* Position fixed for all versions */\n///    rdma_body rdma_body;\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 0,
      "text": "4.2. Fixed Header Fields",
      "section_title": true,
      "ja": "4.2. 固定ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA header begins with four fixed 32-bit fields that control the RDMA interaction.",
      "ja": "RPC-over-RDMAヘッダーは、RDMA対話を制御する4つの固定32ビットフィールドで始まります。"
    },
    {
      "indent": 3,
      "text": "The first three words are individual fields in the rdma_msg structure. The fourth word is the first word of the rdma_body union, which acts as the discriminator for the switched union. The contents of this field are described in Section 4.2.4.",
      "ja": "最初の3つの単語は、rdma_msg構造体の個々のフィールドです。 4番目のワードは、rdma_bodyユニオンの最初のワードであり、スイッチドユニオンの弁別子として機能します。このフィールドの内容については、4.2.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "These four fields must remain with the same meanings and in the same positions in all subsequent versions of the RPC-over-RDMA protocol.",
      "ja": "これらの4つのフィールドは、RPC-over-RDMAプロトコルの以降のすべてのバージョンで同じ意味および同じ位置にとどまる必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Transaction ID (XID)",
      "section_title": true,
      "ja": "4.2.1. トランザクションID（XID）"
    },
    {
      "indent": 3,
      "text": "The XID generated for the RPC Call and Reply messages. Having the XID at a fixed location in the header makes it easy for the receiver to establish context as soon as each RPC-over-RDMA message arrives. This XID MUST be the same as the XID in the RPC message. The receiver MAY perform its processing based solely on the XID in the RPC-over-RDMA header, and thereby ignore the XID in the RPC message, if it so chooses.",
      "ja": "RPC CallおよびReplyメッセージ用に生成されたXID。ヘッダー内の固定位置にXIDがあると、各RPC-over-RDMAメッセージが到着するとすぐに、受信者がコンテキストを簡単に確立できます。このXIDは、RPCメッセージのXIDと同じである必要があります。レシーバーは、RPC-over-RDMAヘッダーのXIDのみに基づいて処理を実行する場合があり、RPCメッセージのXIDを選択した場合は無視します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Version Number",
      "section_title": true,
      "ja": "4.2.2. バージョンナンバー"
    },
    {
      "indent": 3,
      "text": "For RPC-over-RDMA version 1, this field MUST contain the value one (1). Rules regarding changes to this transport protocol version number can be found in Section 7.",
      "ja": "RPC-over-RDMAバージョン1の場合、このフィールドには値1が含まれている必要があります。このトランスポートプロトコルのバージョン番号の変更に関するルールについては、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Credit Value",
      "section_title": true,
      "ja": "4.2.3. クレジットバリュー"
    },
    {
      "indent": 3,
      "text": "When sent with an RPC Call message, the requested credit value is provided. When sent with an RPC Reply message, the granted credit value is returned. Further discussion of how the credit value is determined can be found in Section 3.3.",
      "ja": "RPC Callメッセージと共に送信されると、要求されたクレジット値が提供されます。 RPC応答メッセージと共に送信されると、付与されたクレジット値が返されます。クレジット値の決定方法の詳細については、セクション3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Procedure Number",
      "section_title": true,
      "ja": "4.2.4. 手続き番号"
    },
    {
      "indent": 3,
      "text": "RDMA_MSG = 0 indicates that chunk lists and a Payload stream follow. The format of the chunk lists is discussed below.",
      "ja": "RDMA_MSG = 0は、チャンクリストとペイロードストリームが続くことを示します。チャンクリストの形式については、以下で説明します。"
    },
    {
      "indent": 3,
      "text": "RDMA_NOMSG = 1 indicates that after the chunk lists there is no Payload stream. In this case, the chunk lists provide information to allow the Responder to transfer the Payload stream using explicit RDMA operations.",
      "ja": "RDMA_NOMSG = 1は、チャンクリストの後にペイロードストリームがないことを示します。この場合、チャンクリストは、レスポンダーが明示的なRDMA操作を使用してペイロードストリームを転送できるようにするための情報を提供します。"
    },
    {
      "indent": 3,
      "text": "RDMA_MSGP = 2 is reserved.",
      "ja": "RDMA_MSGP = 2は予約されています。"
    },
    {
      "indent": 3,
      "text": "RDMA_DONE = 3 is reserved.",
      "ja": "RDMA_DONE = 3は予約されています。"
    },
    {
      "indent": 3,
      "text": "RDMA_ERROR = 4 is used to signal an encoding error in the RPC-over-RDMA header.",
      "ja": "RDMA_ERROR = 4は、RPC-over-RDMAヘッダーのエンコーディングエラーを通知するために使用されます。"
    },
    {
      "indent": 0,
      "text": " An RDMA_MSG procedure conveys the Transport stream and the Payload stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by the Read and Write lists and the Reply chunk, though any or all three MAY be marked as not present. The Payload stream then follows, beginning with its XID field. If a Read or Write chunk list is present, a portion of the Payload stream has been reduced and is conveyed via separate operations.",
      "ja": "RDMA_MSGプロシージャは、RDMA送信操作を介してトランスポートストリームとペイロードストリームを伝達します。トランスポートストリームには、4つの固定フィールドと、それに続く読み取りリストと書き込みリスト、および返信チャンクが含まれますが、3つのうちいずれかまたはすべてが存在しないものとしてマークされる場合があります。次に、ペイロードストリームがXIDフィールドから始まります。読み取りまたは書き込みチャンクリストが存在する場合、ペイロードストリームの一部が削減されており、個別の操作で伝達されます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_NOMSG procedure conveys the Transport stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by the Read and Write chunk lists and the Reply chunk. Though any of these MAY be marked as not present, one MUST be present and MUST hold the Payload stream for this RPC-over-RDMA message. If a Read or Write chunk list is present, a portion of the Payload stream has been excised and is conveyed via separate operations.",
      "ja": "RDMA_NOMSGプロシージャは、RDMA送信操作を介してトランスポートストリームを伝達します。トランスポートストリームには4つの固定フィールドが含まれ、その後に読み取りおよび書き込みチャンクリストと返信チャンクが続きます。これらのいずれかが存在しないものとしてマークされる場合がありますが、1つは存在しなければならず、このRPC-over-RDMAメッセージのペイロードストリームを保持する必要があります。読み取りまたは書き込みチャンクリストが存在する場合、ペイロードストリームの一部が削除されており、個別の操作で伝達されます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_ERROR procedure conveys the Transport stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by formatted error information. No Payload stream is conveyed in this type of RPC-over-RDMA message.",
      "ja": "RDMA_ERRORプロシージャは、RDMA送信操作を介してトランスポートストリームを伝達します。トランスポートストリームには、4つの固定フィールドと、その後にフォーマットされたエラー情報が含まれています。このタイプのRPC-over-RDMAメッセージでは、ペイロードストリームは伝達されません。"
    },
    {
      "indent": 3,
      "text": "A Requester MUST NOT send an RPC-over-RDMA header with the RDMA_ERROR procedure. A Responder MUST silently discard RDMA_ERROR procedures.",
      "ja": "リクエスタはRDMA_ERRORプロシージャでRPC-over-RDMAヘッダーを送信してはなりません（MUST NOT）。レスポンダはRDMA_ERRORプロシージャをサイレントに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Transport stream and Payload stream can be constructed in separate buffers. However, the total length of the gathered buffers cannot exceed the inline threshold.",
      "ja": "トランスポートストリームとペイロードストリームは、別々のバッファーで構築できます。ただし、収集されたバッファーの合計長は、インラインしきい値を超えることはできません。"
    },
    {
      "indent": 0,
      "text": "4.3. Chunk Lists",
      "section_title": true,
      "ja": "4.3. チャンクリスト"
    },
    {
      "indent": 3,
      "text": "The chunk lists in an RPC-over-RDMA version 1 header are three XDR optional-data fields that follow the fixed header fields in RDMA_MSG and RDMA_NOMSG procedures. Read Section 4.19 of [RFC4506] carefully to understand how optional-data fields work. Examples of XDR-encoded chunk lists are provided in Section 4.7 as an aid to understanding.",
      "ja": "RPC-over-RDMAバージョン1ヘッダーのチャンクリストは、RDMA_MSGおよびRDMA_NOMSGプロシージャの固定ヘッダーフィールドに続く3つのXDRオプションデータフィールドです。 [RFC4506]のセクション4.19を注意深く読み、オプションのデータフィールドがどのように機能するかを理解してください。 XDRエンコードされたチャンクリストの例は、理解を助けるためにセクション4.7に提供されています。"
    },
    {
      "indent": 3,
      "text": "Often, an RPC-over-RDMA message has no associated chunks. In this case, the Read list, Write list, and Reply chunk are all marked \"not present\".",
      "ja": "多くの場合、RPC-over-RDMAメッセージには関連するチャンクがありません。この場合、読み取りリスト、書き込みリスト、および返信チャンクはすべて「存在しない」とマークされます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Read List",
      "section_title": true,
      "ja": "4.3.1. リストを読む"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Read list\". The Read list is a list of zero or more RDMA read segments, provided by the Requester, that are grouped by their Position fields into Read chunks. Each Read chunk advertises the location of argument data the Responder is to pull from the Requester. The Requester has reduced the data items in these chunks from the call's Payload stream.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSGプロシージャには、1つの「読み取りリスト」があります。読み取りリストは、リクエスターによって提供される0個以上のRDMA読み取りセグメントのリストであり、位置フィールドによってグループ化されて読み取りチャンクにグループ化されます。各読み取りチャンクは、レスポンダがリクエスタからプルする引数データの場所を通知します。リクエスターは、これらのチャンクのデータ項目を呼び出しのペイロードストリームから削減しました。"
    },
    {
      "indent": 3,
      "text": "A Requester may transmit the Payload stream of an RPC Call message using a Position Zero Read chunk. If the RPC Call message has no argument data that is DDP-eligible and the Position Zero Read chunk is not being used, the Requester leaves the Read list empty.",
      "ja": "リクエスタは、位置ゼロ読み取りチャンクを使用して、RPCコールメッセージのペイロードストリームを送信できます。 RPC CallメッセージにDDP対応の引数データが​​なく、Position Zero Readチャンクが使用されていない場合、リクエスターはReadリストを空のままにします。"
    },
    {
      "indent": 3,
      "text": "Responders MUST leave the Read list empty in all replies.",
      "ja": "レスポンダは、すべての返信で既読リストを空のままにする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. Matching Read Chunks to Arguments",
      "section_title": true,
      "ja": "4.3.1.1. 読み取りチャンクと引数のマッチング"
    },
    {
      "indent": 3,
      "text": "When reducing a DDP-eligible argument data item, a Requester records the XDR stream offset of that data item in the Read chunk's Position field. The Responder can then tell unambiguously where that chunk is to be reinserted into the received Payload stream to form a complete RPC Call message.",
      "ja": "DDP対応の引数データ項目を削減する場合、リクエスターはそのデータ項目のXDRストリームオフセットを読み取りチャンクの位置フィールドに記録します。レスポンダは、そのチャンクが受信したペイロードストリームに再挿入される場所を明確に通知して、完全なRPC呼び出しメッセージを形成できます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Write List",
      "section_title": true,
      "ja": "4.3.2. リストを書く"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Write list\". The Write list is a list of zero or more Write chunks, provided by the Requester. Each Write chunk is an array of plain segments; thus, the Write list is a list of counted arrays.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSGプロシージャには、1つの「書き込みリスト」があります。書き込みリストは、リクエスタが提供する0個以上の書き込みチャンクのリストです。各書き込みチャンクはプレーンセグメントの配列です。したがって、書き込みリストは、カウントされた配列のリストです。"
    },
    {
      "indent": 3,
      "text": "If an RPC Reply message has no possible DDP-eligible result data items, the Requester leaves the Write list empty. When a Requester provides a Write list, the Responder MUST push data corresponding to DDP-eligible result data items to Requester memory referenced in the Write list. The Responder removes these data items from the reply's Payload stream.",
      "ja": "RPC応答メッセージにDDPに適格な可能性のある結果データ項目がない場合、リクエスターは書き込みリストを空のままにします。リクエスターが書き込みリストを提供する場合、レスポンダーは、DDP対応の結果データ項目に対応するデータを、書き込みリストで参照されるリクエスターのメモリにプッシュする必要があります。レスポンダは、これらのデータ項目を応答のペイロードストリームから削除します。"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Matching Write Chunks to Results",
      "section_title": true,
      "ja": "4.3.2.1. 結果への書き込みチャンクのマッチング"
    },
    {
      "indent": 3,
      "text": "A Requester constructs the Write list for an RPC transaction before the Responder has formulated its reply. When there is only one DDP-eligible result data item, the Requester inserts only a single Write chunk in the Write list. If the returned Write chunk is not an unused Write chunk, the Requester knows with certainty which result data item is contained in it.",
      "ja": "リクエスターは、レスポンダーが応答を作成する前に、RPCトランザクションの書き込みリストを作成します。 DDPに適格な結果データ項目が1つしかない場合、リクエスターは書き込みリストに単一の書き込みチャンクのみを挿入します。返された書き込みチャンクが未使用の書き込みチャンクではない場合、リクエスタはどの結果データ項目が含まれているかを確実に認識します。"
    },
    {
      "indent": 3,
      "text": "When a Requester has provided multiple Write chunks, the Responder fills in each Write chunk with one DDP-eligible result until there are either no more DDP-eligible results or no more Write chunks.",
      "ja": "リクエスターが複数の書き込みチャンクを提供した場合、レスポンダーは、DDPに適格な結果または書き込みチャンクがなくなるまで、各書き込みチャンクに1つのDDP適格な結果を入力します。"
    },
    {
      "indent": 3,
      "text": "The Requester might not be able to predict in advance which DDP-eligible data item goes in which chunk. Thus, the Requester is responsible for allocating and registering Write chunks large enough to accommodate the largest result data item that might be associated with each chunk in the Write list.",
      "ja": "リクエスターは、どのDDP適格データ項目がどのチャンクに入るかを事前に予測できない場合があります。したがって、リクエスタは、書き込みリスト内の各チャンクに関連付けられる可能性のある最大の結果データ項目に対応するのに十分な大きさの書き込みチャンクを割り当てて登録する責任があります。"
    },
    {
      "indent": 3,
      "text": "As a Requester decodes a reply Payload stream, it is clear from the contents of the RPC Reply message which Write chunk contains which result data item.",
      "ja": "リクエスタが応答ペイロードストリームをデコードすると、RPC応答メッセージの内容から、どの書き込みチャンクにどの結果データ項目が含まれるかが明らかになります。"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Unused Write Chunks",
      "section_title": true,
      "ja": "4.3.2.2. 未使用の書き込みチャンク"
    },
    {
      "indent": 3,
      "text": "There are occasions when a Requester provides a non-empty Write chunk but the Responder is not able to use it. For example, a ULP may define a union result where some arms of the union contain a DDP-eligible data item while other arms do not. The Responder is required to use Requester-provided Write chunks in this case, but if the Responder returns a result that uses an arm of the union that has no DDP-eligible data item, that Write chunk remains unconsumed.",
      "ja": "リクエスタが空ではない書き込みチャンクを提供しても、レスポンダがそれを使用できない場合があります。たとえば、ULPはユニオンの結果を定義し、ユニオンの一部のアームにはDDP対応のデータ項目が含まれているが、他のアームには含まれていない場合があります。この場合、レスポンダーはリクエスター提供の書き込みチャンクを使用する必要がありますが、レスポンダーがDDPに適格なデータ項目のないユニオンのアームを使用する結果を返す場合、その書き込みチャンクは未使用のままです。"
    },
    {
      "indent": 3,
      "text": "If there is a subsequent DDP-eligible result data item in the RPC Reply message, it MUST be placed in that unconsumed Write chunk. Therefore, the Requester MUST provision each Write chunk so it can be filled with the largest DDP-eligible data item that can be placed in it.",
      "ja": "RPC応答メッセージに後続のDDP対応の結果データ項目がある場合、それはその未使用の書き込みチャンクに配置する必要があります。したがって、リクエスターは各書き込みチャンクをプロビジョニングして、配置できる最大のDDP適格データ項目で満たすことができるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "If this is the last or only Write chunk available and it remains unconsumed, the Responder MUST return this Write chunk as an unused Write chunk (see Section 3.4.6). The Responder sets the segment count to a value matching the Requester-provided Write chunk, but returns only empty segments in that Write chunk.",
      "ja": "これが利用可能な最後または唯一の書き込みチャンクであり、未使用のままの場合、レスポンダーはこの書き込みチャンクを未使用の書き込みチャンクとして返す必要があります（セクション3.4.6を参照）。レスポンダは、セグメントカウントをリクエスタ提供の書き込みチャンクと一致する値に設定しますが、その書き込みチャンクでは空のセグメントのみを返します。"
    },
    {
      "indent": 3,
      "text": "Unused Write chunks, or unused bytes in Write chunk segments, are returned to the RPC consumer as part of RPC completion. Even if a Responder indicates that a Write chunk is not consumed, the Responder may have written data into one or more segments before choosing not to return that data item. The Requester MUST NOT assume that the memory regions backing a Write chunk have not been modified.",
      "ja": "未使用の書き込みチャンク、または書き込みチャンクセグメント内の未使用のバイトは、RPC完了の一部としてRPCコンシューマーに返されます。レスポンダーが書き込みチャンクが消費されていないことを示した場合でも、レスポンダーはそのデータ項目を返さないことを選択する前に1つ以上のセグメントにデータを書き込んだ可能性があります。リクエスタは、書き込みチャンクをサポートするメモリ領域が変更されていないと想定してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "4.3.2.3. Empty Write Chunks",
      "section_title": true,
      "ja": "4.3.2.3. 空の書き込みチャンク"
    },
    {
      "indent": 3,
      "text": "To force a Responder to return a DDP-eligible result inline, a Requester employs the following mechanism:",
      "ja": "レスポンダがDDP対応の結果をインラインで返すように強制するために、リクエスタは次のメカニズムを使用します。"
    },
    {
      "indent": 3,
      "text": "o When there is only one DDP-eligible result item in an RPC Reply message, the Requester provides an empty Write list.",
      "ja": "o RPC応答メッセージにDDP対応の結果アイテムが1つしかない場合、リクエスターは空の書き込みリストを提供します。"
    },
    {
      "indent": 3,
      "text": "o When there are multiple DDP-eligible result data items and a Requester prefers that a data item is returned inline, the Requester provides an empty Write chunk for that item (see Section 3.4.6). The Responder MUST return the corresponding result data item inline and MUST return an empty Write chunk in that Write list position in the RPC Reply message.",
      "ja": "o 複数のDDP対応の結果データ項目があり、リクエスターがデータ項目がインラインで返されることを希望する場合、リクエスターはその項目に空の書き込みチャンクを提供します（セクション3.4.6を参照）。レスポンダは対応する結果データアイテムをインラインで返し、空の書き込みチャンクをRPC応答メッセージのその書き込みリストの位置に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "As always, a Requester and Responder must prepare for a Long Reply to be used if the resulting RPC Reply might be too large to be conveyed in an RDMA Send.",
      "ja": "いつものように、リクエスターとレスポンダーは、結果のRPC応答が大きすぎてRDMA送信で伝達できない場合に使用される長い応答を準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Reply Chunk",
      "section_title": true,
      "ja": "4.3.3. 返信チャンク"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Reply chunk\" slot. A Requester MUST provide a Reply chunk whenever the maximum possible size of the RPC Reply message's Transport and Payload streams is larger than the inline threshold for messages from Responder to Requester. Otherwise, the Requester marks the Reply chunk as not present.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSGプロシージャには、1つの「応答チャンク」スロットがあります。 RPC応答メッセージのトランスポートおよびペイロードストリームの最大可能サイズが、レスポンダからリクエスタへのメッセージのインラインしきい値よりも大きい場合、リクエスタは応答チャンクを提供する必要があります。それ以外の場合、リクエスタは返信チャンクを存在しないものとしてマークします。"
    },
    {
      "indent": 3,
      "text": "If the Transport stream and Payload stream together are smaller than the reply inline threshold, the Responder MAY return the RPC Reply message as a Short message rather than using the Requester-provided Reply chunk.",
      "ja": "トランスポートストリームとペイロードストリームの合計が応答インラインしきい値よりも小さい場合、レスポンダは、リクエスタ提供の応答チャンクを使用するのではなく、RPC応答メッセージをショートメッセージとして返す場合があります。"
    },
    {
      "indent": 3,
      "text": "When a Requester provides a Reply chunk in an RPC Call message, the Responder MUST copy that chunk into the Transport header of the RPC Reply message. As with Write chunks, the Responder modifies the copied Reply chunk in the RPC Reply message to reflect the actual amount of data that is being returned in the Reply chunk.",
      "ja": "リクエスターがRPC呼び出しメッセージで返信チャンクを提供する場合、レスポンダーはそのチャンクをRPC返信メッセージのトランスポートヘッダーにコピーする必要があります。書き込みチャンクと同様に、レスポンダーはRPC返信メッセージ内のコピーされた返信チャンクを変更して、返信チャンクで返される実際のデータ量を反映します。"
    },
    {
      "indent": 0,
      "text": "4.4. Memory Registration",
      "section_title": true,
      "ja": "4.4. メモリ登録"
    },
    {
      "indent": 3,
      "text": "The cost of registering and invalidating memory can be a significant proportion of the cost of an RPC-over-RDMA transaction. Thus, an important implementation consideration is how to minimize registration activity without exposing system memory needlessly.",
      "ja": "メモリの登録と無効化のコストは、RPC-over-RDMAトランザクションのコストのかなりの部分を占める可能性があります。したがって、重要な実装上の考慮事項は、システムメモリを不必要に公開せずに登録アクティビティを最小限に抑える方法です。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Registration Longevity",
      "section_title": true,
      "ja": "4.4.1. 登録の寿命"
    },
    {
      "indent": 3,
      "text": "Data transferred via RDMA Read and Write can reside in a memory allocation not in the control of the RPC-over-RDMA transport. These memory allocations can persist outside the bounds of an RPC transaction. They are registered and invalidated as needed, as part of each RPC transaction.",
      "ja": "RDMA読み取りおよび書き込みを介して転送されるデータは、RPC-over-RDMAトランスポートの制御ではなく、メモリ割り当てに常駐できます。これらのメモリ割り当ては、RPCトランザクションの範囲外でも持続できます。これらは、各RPCトランザクションの一部として、必要に応じて登録および無効化されます。"
    },
    {
      "indent": 3,
      "text": "The Requester endpoint must ensure that memory regions associated with each RPC transaction are protected from Responder access before allowing upper-layer access to the data contained in them. Moreover, the Requester must not access these memory regions while the Responder has access to them.",
      "ja": "リクエスタエンドポイントは、各RPCトランザクションに関連付けられているメモリ領域がレスポンダアクセスから保護されていることを確認してから、それらに含まれるデータへの上位層アクセスを許可する必要があります。さらに、レスポンダがメモリ領域にアクセスしている間、リクエスタはこれらのメモリ領域にアクセスしてはなりません。"
    },
    {
      "indent": 3,
      "text": "This includes memory regions that are associated with canceled RPCs. A Responder cannot know that the Requester is no longer waiting for a reply, and it might proceed to read or even update memory that the Requester might have released for other use.",
      "ja": "これには、キャンセルされたRPCに関連付けられているメモリ領域が含まれます。レスポンダは、リクエスタが応答を待機していないことを知ることができず、リクエスタが他の使用のために解放した可能性のあるメモリの読み取りまたは更新に進む場合があります。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Communicating DDP-Eligibility",
      "section_title": true,
      "ja": "4.4.2. DDP適格性の伝達"
    },
    {
      "indent": 3,
      "text": "The interface by which a ULP implementation communicates the eligibility of a data item locally to its local RPC-over-RDMA endpoint is not described by this specification.",
      "ja": "ULP実装がローカルでデータアイテムの適格性をローカルのRPC-over-RDMAエンドポイントに伝達するためのインターフェイスは、この仕様では説明されていません。"
    },
    {
      "indent": 3,
      "text": "Depending on the implementation and constraints imposed by ULBs, it is possible to implement reduction transparently to upper layers. Such implementations may lead to inefficiencies, either because they require the RPC layer to perform expensive registration and invalidation of memory \"on the fly\", or they may require using RDMA chunks in RPC Reply messages, along with the resulting additional handshaking with the RPC-over-RDMA peer.",
      "ja": "ULBによって課される実装と制約に応じて、上位層に透過的に削減を実装することが可能です。そのような実装では、RPCレイヤーがメモリの「オンザフライ」で登録と無効化を実行する必要があるため、またはRPC応答メッセージでRDMAチャンクを使用する必要があるため、非効率になる可能性があります。オーバーRDMAピア。"
    },
    {
      "indent": 3,
      "text": "However, these issues are internal and generally confined to the local interface between RPC and its upper layers, one in which implementations are free to innovate. The only requirement, beyond constraints imposed by the ULB, is that the resulting RPC-over-RDMA protocol sent to the peer be valid for the upper layer.",
      "ja": "ただし、これらの問題は内部的なものであり、一般にRPCとその上位層の間のローカルインターフェースに限定されます。その1つでは、実装を自由に革新できます。 ULBによって課せられる制約を超えた唯一の要件は、ピアに送信されるRPC-over-RDMAプロトコルが上位層で有効であることです。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Registration Strategies",
      "section_title": true,
      "ja": "4.4.3. 登録戦略"
    },
    {
      "indent": 3,
      "text": "The choice of which memory registration strategies to employ is left to Requester and Responder implementers. To support the widest array of RDMA implementations, as well as the most general steering tag scheme, an Offset field is included in each RDMA segment.",
      "ja": "使用するメモリ登録戦略の選択は、要求者と応答者の実装者に任されています。最も広い範囲のRDMA実装と最も一般的なステアリングタグスキームをサポートするために、オフセットフィールドが各RDMAセグメントに含まれています。"
    },
    {
      "indent": 3,
      "text": "While zero-based offset schemes are available in many RDMA implementations, their use by RPC requires individual registration of each memory region. For such implementations, this can be a significant overhead. By providing an offset in each chunk, many pre-registration or region-based registrations can be readily supported.",
      "ja": "ゼロベースのオフセットスキームは多くのRDMA実装で使用できますが、RPCで使用するには、各メモリ領域を個別に登録する必要があります。このような実装では、これは大きなオーバーヘッドになる可能性があります。各チャンクにオフセットを提供することにより、多くの事前登録または地域ベースの登録を簡単にサポートできます。"
    },
    {
      "indent": 0,
      "text": "4.5. Error Handling",
      "section_title": true,
      "ja": "4.5. エラー処理"
    },
    {
      "indent": 0,
      "text": " A receiver performs basic validity checks on the RPC-over-RDMA header and chunk contents before it passes the RPC message to the RPC layer. If an incoming RPC-over-RDMA message is not as long as a minimal size RPC-over-RDMA header (28 bytes), the receiver cannot trust the value of the XID field; therefore, it MUST silently discard the message before performing any parsing. If other errors are detected in the RPC-over-RDMA header of an RPC Call message, a Responder MUST send an RDMA_ERROR message back to the Requester. If errors are detected in the RPC-over-RDMA header of an RPC Reply message, a Requester MUST silently discard the message.",
      "ja": "レシーバーは、RPCメッセージをRPCレイヤーに渡す前に、RPC-over-RDMAヘッダーとチャンクの内容に対して基本的な有効性チェックを実行します。着信RPC-over-RDMAメッセージが最小サイズのRPC-over-RDMAヘッダー（28バイト）ほど長くない場合、受信者はXIDフィールドの値を信頼できません。したがって、解析を実行する前に、メッセージを静かに破棄する必要があります。 RPC CallメッセージのRPC-over-RDMAヘッダーで他のエラーが検出された場合、レスポンダはRDMA_ERRORメッセージをリクエスタに送信する必要があります。 RPC応答メッセージのRPC-over-RDMAヘッダーでエラーが検出された場合、リクエスターはメッセージを黙って破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "To form an RDMA_ERROR procedure:",
      "ja": "RDMA_ERRORプロシージャを作成するには："
    },
    {
      "indent": 3,
      "text": "o The rdma_xid field MUST contain the same XID that was in the rdma_xid field in the failing request;",
      "ja": "o rdma_xidフィールドには、失敗したリクエストのrdma_xidフィールドにあったものと同じXIDを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o The rdma_vers field MUST contain the same version that was in the rdma_vers field in the failing request;",
      "ja": "o rdma_versフィールドには、失敗した要求のrdma_versフィールドと同じバージョンを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o The rdma_proc field MUST contain the value RDMA_ERROR; and",
      "ja": "o rdma_procフィールドには値RDMA_ERRORが含まれている必要があります。そして"
    },
    {
      "indent": 3,
      "text": "o The rdma_err field contains a value that reflects the type of error that occurred, as described below.",
      "ja": "o rdma_errフィールドには、以下で説明するように、発生したエラーのタイプを反映する値が含まれています。"
    },
    {
      "indent": 3,
      "text": "An RDMA_ERROR procedure indicates a permanent error. Receipt of this procedure completes the RPC transaction associated with XID in the rdma_xid field. A receiver MUST silently discard an RDMA_ERROR procedure that it cannot decode.",
      "ja": "RDMA_ERRORプロシージャは、永続的なエラーを示します。この手順を受け取ると、rdma_xidフィールドのXIDに関連付けられたRPCトランザクションが完了します。レシーバは、デコードできないRDMA_ERRORプロシージャをサイレントに破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Header Version Mismatch",
      "section_title": true,
      "ja": "4.5.1. ヘッダーバージョンの不一致"
    },
    {
      "indent": 3,
      "text": "When a Responder detects an RPC-over-RDMA header version that it does not support (currently this document defines only version 1), it MUST reply with an RDMA_ERROR procedure and set the rdma_err value to ERR_VERS, also providing the low and high inclusive version numbers it does, in fact, support.",
      "ja": "レスポンダが、サポートしていないRPC-over-RDMAヘッダーバージョンを検出した場合（現在、このドキュメントではバージョン1のみを定義しています）、RDMA_ERRORプロシージャで応答し、rdma_err値をERR_VERSに設定する必要があります。実際にサポートする数です。"
    },
    {
      "indent": 0,
      "text": "4.5.2. XDR Errors",
      "section_title": true,
      "ja": "4.5.2. XDRエラー"
    },
    {
      "indent": 3,
      "text": "A receiver might encounter an XDR parsing error that prevents it from processing the incoming Transport stream. Examples of such errors include an invalid value in the rdma_proc field; an RDMA_NOMSG message where the Read list, Write list, and Reply chunk are marked not present; or the value of the rdma_xid field does not match the value of the XID field in the accompanying RPC message. If the rdma_vers field contains a recognized value, but an XDR parsing error occurs, the Responder MUST reply with an RDMA_ERROR procedure and set the rdma_err value to ERR_CHUNK.",
      "ja": "受信側でXDR解析エラーが発生し、受信トランスポートストリームを処理できない場合があります。このようなエラーの例には、rdma_procフィールドの無効な値が含まれます。読み取りリスト、書き込みリスト、および返信チャンクが存在しないとマークされているRDMA_NOMSGメッセージ。または、rdma_xidフィールドの値が、付随するRPCメッセージのXIDフィールドの値と一致しません。 rdma_versフィールドに認識された値が含まれているが、XDR解析エラーが発生した場合、レスポンダはRDMA_ERRORプロシージャで応答し、rdma_err値をERR_CHUNKに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a Responder receives a valid RPC-over-RDMA header but the Responder's ULP implementation cannot parse the RPC arguments in the RPC Call message, the Responder SHOULD return an RPC Reply message with status GARBAGE_ARGS, using an RDMA_MSG procedure. This type of parsing failure might be due to mismatches between chunk sizes or offsets and the contents of the Payload stream, for example.",
      "ja": "レスポンダが有効なRPC-over-RDMAヘッダーを受信したが、レスポンダのULP実装がRPCコールメッセージのRPC引数を解析できない場合、レスポンダはRDMA_MSGプロシージャを使用して、ステータスGARBAGE_ARGSのRPC応答メッセージを返す必要があります。このタイプの解析の失敗は、たとえば、チャンクサイズまたはオフセットとペイロードストリームの内容との不一致が原因である可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Responder RDMA Operational Errors",
      "section_title": true,
      "ja": "4.5.3. レスポンダーRDMAの操作エラー"
    },
    {
      "indent": 3,
      "text": "In RPC-over-RDMA version 1, the Responder initiates RDMA Read and Write operations that target the Requester's memory. Problems might arise as the Responder attempts to use Requester-provided resources for RDMA operations. For example:",
      "ja": "RPC-over-RDMAバージョン1では、レスポンダはリクエスタのメモリを対象とするRDMA読み取りおよび書き込み操作を開始します。レスポンダーがリクエスター提供のリソースをRDMA操作に使用しようとすると、問題が発生する可能性があります。例えば："
    },
    {
      "indent": 3,
      "text": "o Usually, chunks can be validated only by using their contents to perform data transfers. If chunk contents are invalid (e.g., a memory region is no longer registered or a chunk length exceeds the end of the registered memory region), a Remote Access Error occurs.",
      "ja": "o 通常、チャンクは、その内容を使用してデータ転送を実行することによってのみ検証できます。チャンクの内容が無効な場合（たとえば、メモリ領域が登録されていない、またはチャンクの長さが登録されたメモリ領域の最後を超えているなど）、リモートアクセスエラーが発生します。"
    },
    {
      "indent": 3,
      "text": "o If a Requester's Receive buffer is too small, the Responder's Send operation completes with a Local Length Error.",
      "ja": "o リクエスターの受信バッファーが小さすぎる場合、レスポンダーの送信操作はローカル長エラーで完了します。"
    },
    {
      "indent": 3,
      "text": "o If the Requester-provided Reply chunk is too small to accommodate a large RPC Reply message, a Remote Access Error occurs. A Responder might detect this problem before attempting to write past the end of the Reply chunk.",
      "ja": "o リクエスタが提供する応答チャンクが小さすぎて大きなRPC応答メッセージを収容できない場合、リモートアクセスエラーが発生します。レスポンダーは、応答チャンクの終わりを超えて書き込みを試みる前に、この問題を検出する場合があります。"
    },
    {
      "indent": 3,
      "text": "RDMA operational errors are typically fatal to the connection. To avoid a retransmission loop and repeated connection loss that deadlocks the connection, once the Requester has re-established a connection, the Responder should send an RDMA_ERROR reply with an rdma_err value of ERR_CHUNK to indicate that no RPC-level reply is possible for that XID.",
      "ja": "RDMA操作エラーは通常、接続にとって致命的です。再送信ループと接続のデッドロックを引き起こす接続の喪失の繰り返しを回避するには、リクエスタが接続を再確立した後、レスポンダがRDMA_ERROR応答をERR_CHUNKのrdma_err値とともに送信して、そのXIDに対してRPCレベルの応答が不可能であることを示します。 。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Other Operational Errors",
      "section_title": true,
      "ja": "4.5.4. その他の操作エラー"
    },
    {
      "indent": 3,
      "text": "While a Requester is constructing an RPC Call message, an unrecoverable problem might occur that prevents the Requester from posting further RDMA Work Requests on behalf of that message. As with other transports, if a Requester is unable to construct and transmit an RPC Call message, the associated RPC transaction fails immediately.",
      "ja": "リクエスターがRPC呼び出しメッセージを作成している間に、リクエスターがそのメッセージに代わってさらにRDMA作業要求をポストできないようにする回復不能な問題が発生する可能性があります。他のトランスポートと同様に、リクエスターがRPC呼び出しメッセージを作成および送信できない場合、関連するRPCトランザクションはすぐに失敗します。"
    },
    {
      "indent": 3,
      "text": "After a Requester has received a reply, if it is unable to invalidate a memory region due to an unrecoverable problem, the Requester MUST close the connection to protect that memory from Responder access before the associated RPC transaction is complete.",
      "ja": "リクエスタが応答を受け取った後、回復不可能な問題が原因でメモリ領域を無効化できない場合、リクエスタは接続を閉じて、関連付けられたRPCトランザクションが完了する前にレスポンダアクセスからメモリを保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "While a Responder is constructing an RPC Reply message or error message, an unrecoverable problem might occur that prevents the Responder from posting further RDMA Work Requests on behalf of that message. If a Responder is unable to construct and transmit an RPC Reply or RPC-over-RDMA error message, the Responder MUST close the connection to signal to the Requester that a reply was lost.",
      "ja": "レスポンダがRPC応答メッセージまたはエラーメッセージを作成している間、レスポンダがそのメッセージの代わりにさらにRDMA作業要求を投稿できないようにする回復不能な問題が発生する可能性があります。レスポンダがRPC応答またはRPC-over-RDMAエラーメッセージを作成および送信できない場合、レスポンダは接続を閉じて、応答が失われたことをリクエスタに通知する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.5. RDMA Transport Errors",
      "section_title": true,
      "ja": "4.5.5. RDMAトランスポートエラー"
    },
    {
      "indent": 3,
      "text": "The RDMA connection and physical link provide some degree of error detection and retransmission. iWARP's Marker PDU Aligned (MPA) layer (when used over TCP), the Stream Control Transmission Protocol (SCTP), as well as the InfiniBand [IBARCH] link layer all provide Cyclic Redundancy Check (CRC) protection of the RDMA payload, and CRC-class protection is a general attribute of such transports.",
      "ja": "RDMA接続と物理リンクは、ある程度のエラー検出と再送信を提供します。 iWARPのMarker PDU Aligned（MPA）レイヤー（TCPで使用される場合）、Stream Control Transmission Protocol（SCTP）、およびInfiniBand [IBARCH]リンクレイヤーはすべて、RDMAペイロードの巡回冗長検査（CRC）保護、およびCRCを提供しますクラスの保護は、このようなトランスポートの一般的な属性です。"
    },
    {
      "indent": 3,
      "text": "Additionally, the RPC layer itself can accept errors from the transport and recover via retransmission. RPC recovery can handle complete loss and re-establishment of a transport connection.",
      "ja": "さらに、RPC層自体がトランスポートからのエラーを受け入れ、再送信によって回復できます。 RPC回復は、トランスポート接続の完全な損失と再確立を処理できます。"
    },
    {
      "indent": 3,
      "text": "The details of reporting and recovery from RDMA link-layer errors are described in specific link-layer APIs and operational specifications and are outside the scope of this protocol specification. See Section 8 for further discussion of the use of RPC-level integrity schemes to detect errors.",
      "ja": "RDMAリンク層エラーの報告と回復の詳細は、特定のリンク層APIと運用仕様で説明されており、このプロトコル仕様の範囲外です。 RPCレベルの整合性スキームを使用してエラーを検出する方法の詳細については、セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.6. Protocol Elements No Longer Supported",
      "section_title": true,
      "ja": "4.6. サポートされなくなったプロトコル要素"
    },
    {
      "indent": 3,
      "text": "The following protocol elements are no longer supported in RPC-over-RDMA version 1. Related enum values and structure definitions remain in the RPC-over-RDMA version 1 protocol for backwards compatibility.",
      "ja": "次のプロトコル要素はRPC-over-RDMAバージョン1ではサポートされなくなりました。関連する列挙値と構造体の定義は、下位互換性のためにRPC-over-RDMAバージョン1プロトコルに残ります。"
    },
    {
      "indent": 0,
      "text": "4.6.1. RDMA_MSGP",
      "section_title": true,
      "ja": "4.6.1. RDMA_MSGP"
    },
    {
      "indent": 3,
      "text": "The specification of RDMA_MSGP in Section 3.9 of [RFC5666] is incomplete. To fully specify RDMA_MSGP would require:",
      "ja": "[RFC5666]のセクション3.9のRDMA_MSGPの仕様は不完全です。 RDMA_MSGPを完全に指定するには、以下が必要です。"
    },
    {
      "indent": 3,
      "text": "o Updating the definition of DDP-eligibility to include data items that may be transferred, with padding, via RDMA_MSGP procedures",
      "ja": "o RDP_MSGPプロシージャを介して、パディングを使用して転送される可能性のあるデータ項目を含めるようにDDP適格性の定義を更新"
    },
    {
      "indent": 3,
      "text": "o Adding full operational descriptions of the alignment and threshold fields",
      "ja": "o アライメントおよびしきい値フィールドの完全な操作説明を追加する"
    },
    {
      "indent": 3,
      "text": "o Discussing how alignment preferences are communicated between two peers without using CCP",
      "ja": "o CCPを使用せずに2つのピア間で配置設定がどのように通信されるかについて話し合う"
    },
    {
      "indent": 3,
      "text": "o Describing the treatment of RDMA_MSGP procedures that convey Read or Write chunks",
      "ja": "o 読み取りまたは書き込みチャンクを伝達するRDMA_MSGPプロシージャの処理について説明する"
    },
    {
      "indent": 3,
      "text": "The RDMA_MSGP message type is beneficial only when the padded data payload is at the end of an RPC message's argument or result list. This is not typical for NFSv4 COMPOUND RPCs, which often include a GETATTR operation as the final element of the compound operation array.",
      "ja": "RDMA_MSGPメッセージタイプは、パディングされたデータペイロードがRPCメッセージの引数または結果リストの最後にある場合にのみ有効です。これは、NFSv4 COMPOUND RPCでは一般的ではありません。これには、複合操作配列の最後の要素としてGETATTR操作が含まれていることがよくあります。"
    },
    {
      "indent": 3,
      "text": "Without a full specification of RDMA_MSGP, there has been no fully implemented prototype of it. Without a complete prototype of RDMA_MSGP support, it is difficult to assess whether this protocol element has benefit or can even be made to work interoperably.",
      "ja": "RDMA_MSGPの完全な仕様なしでは、完全に実装されたプロトタイプはありません。 RDMA_MSGPサポートの完全なプロトタイプがないと、このプロトコル要素に利点があるかどうか、または相互運用できるように作成できるかどうかを評価することは困難です。"
    },
    {
      "indent": 3,
      "text": "Therefore, senders MUST NOT send RDMA_MSGP procedures. When receiving an RDMA_MSGP procedure, Responders SHOULD reply with an RDMA_ERROR procedure, setting the rdma_err field to ERR_CHUNK; Requesters MUST silently discard the message.",
      "ja": "したがって、送信者はRDMA_MSGPプロシージャを送信してはなりません（MUST NOT）。 RDMA_MSGPプロシージャを受信すると、レスポンダはRDMA_ERRORプロシージャで応答し、rdma_errフィールドをERR_CHUNKに設定する必要があります。リクエスタはメッセージを静かに破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.2. RDMA_DONE",
      "section_title": true,
      "ja": "4.6.2. RDMA_DONE"
    },
    {
      "indent": 3,
      "text": "Because no implementation of RPC-over-RDMA version 1 uses the Read-Read transfer model, there is never a need to send an RDMA_DONE procedure.",
      "ja": "RPC-over-RDMAバージョン1の実装ではRead-Read転送モデルを使用しないため、RDMA_DONEプロシージャを送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Therefore, senders MUST NOT send RDMA_DONE messages. Receivers MUST silently discard RDMA_DONE messages.",
      "ja": "したがって、送信者はRDMA_DONEメッセージを送信してはなりません（MUST NOT）。受信者はRDMA_DONEメッセージを黙って破棄しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "4.7. XDR Examples",
      "section_title": true,
      "ja": "4.7. XDRの例"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA chunk lists are complex data types. In this section, illustrations are provided to help readers grasp how chunk lists are represented inside an RPC-over-RDMA header.",
      "ja": "RPC-over-RDMAチャンクリストは複雑なデータ型です。このセクションでは、RPC-over-RDMAヘッダー内でチャンクリストがどのように表されるかを読者が理解できるように、図を提供します。"
    },
    {
      "indent": 3,
      "text": "A plain segment is the simplest component, being made up of a 32-bit handle (H), a 32-bit length (L), and 64 bits of offset (OO). Once flattened into an XDR stream, plain segments appear as",
      "ja": "プレーンセグメントは、32ビットのハンドル（H）、32ビットの長さ（L）、64ビットのオフセット（OO）で構成される最も単純なコンポーネントです。 XDRストリームにフラット化すると、プレーンセグメントは次のように表示されます"
    },
    {
      "indent": 6,
      "text": "HLOO",
      "ja": "HLOO"
    },
    {
      "indent": 3,
      "text": "An RDMA read segment has an additional 32-bit position field (P). RDMA read segments appear as",
      "ja": "RDMA読み取りセグメントには、追加の32ビットの位置フィールド（P）があります。 RDMA読み取りセグメントは次のように表示されます"
    },
    {
      "indent": 6,
      "text": "PHLOO",
      "ja": "プルー"
    },
    {
      "indent": 3,
      "text": "A Read chunk is a list of RDMA read segments. Each RDMA read segment is preceded by a 32-bit word containing a one if a segment follows or a zero if there are no more segments in the list. In XDR form, this would look like",
      "ja": "読み取りチャンクは、RDMA読み取りセグメントのリストです。各RDMA読み取りセグメントの前には、セグメントが続く場合は1を含む32ビットワードが、リストにセグメントがそれ以上ない場合は0が続きます。 XDR形式では、これは次のようになります。"
    },
    {
      "indent": 6,
      "text": "1 PHLOO 1 PHLOO 1 PHLOO 0",
      "ja": "1 PHLOO 1 PHLOO 1 PHLOO 0"
    },
    {
      "indent": 3,
      "text": "where P would hold the same value for each RDMA read segment belonging to the same Read chunk.",
      "ja": "ここで、Pは、同じ読み取りチャンクに属する各RDMA読み取りセグメントに対して同じ値を保持します。"
    },
    {
      "indent": 3,
      "text": "The Read list is also a list of RDMA read segments. In XDR form, this would look like a Read chunk, except that the P values could vary across the list. An empty Read list is encoded as a single 32-bit zero.",
      "ja": "読み取りリストは、RDMA読み取りセグメントのリストでもあります。 XDR形式では、P値がリスト全体で異なる可能性があることを除いて、これは読み取りチャンクのように見えます。空の読み取りリストは、単一の32ビットのゼロとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "One Write chunk is a counted array of plain segments. In XDR form, the count would appear as the first 32-bit word, followed by an HLOO for each element of the array. For instance, a Write chunk with three elements would look like",
      "ja": "1つの書き込みチャンクは、プレーンセグメントのカウントされた配列です。 XDR形式では、カウントは最初の32ビットワードとして表示され、その後に配列の各要素のHLOOが続きます。たとえば、3つの要素を持つ書き込みチャンクは次のようになります。"
    },
    {
      "indent": 6,
      "text": "3 HLOO HLOO HLOO",
      "ja": "3年間"
    },
    {
      "indent": 3,
      "text": "The Write list is a list of counted arrays. In XDR form, this is a combination of optional-data and counted arrays. To represent a Write list containing a Write chunk with three segments and a Write chunk with two segments, XDR would encode",
      "ja": "書き込みリストは、カウントされた配列のリストです。 XDR形式では、これはオプションのデータとカウントされた配列の組み合わせです。 3つのセグメントを持つ書き込みチャンクと2つのセグメントを持つ書き込みチャンクを含む書き込みリストを表すために、XDRはエンコードします"
    },
    {
      "indent": 6,
      "text": "1 3 HLOO HLOO HLOO 1 2 HLOO HLOO 0",
      "ja": "1 3年前1"
    },
    {
      "indent": 3,
      "text": "An empty Write list is encoded as a single 32-bit zero.",
      "ja": "空の書き込みリストは、単一の32ビットのゼロとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "The Reply chunk is a Write chunk. However, since it is an optional-data field, there is a 32-bit field in front of it that contains a one if the Reply chunk is present or a zero if it is not. After encoding, a Reply chunk with two segments would look like",
      "ja": "返信チャンクは書き込みチャンクです。ただし、これはオプションのデータフィールドであるため、その前に32ビットフィールドがあり、Replyチャンクが存在する場合は1、存在しない場合はゼロが含まれます。エンコード後、2つのセグメントを持つ返信チャンクは次のようになります。"
    },
    {
      "indent": 6,
      "text": "1 2 HLOO HLOO",
      "ja": "1 2鋼"
    },
    {
      "indent": 3,
      "text": "Frequently, a Requester does not provide any chunks. In that case, after the four fixed fields in the RPC-over-RDMA header, there are simply three 32-bit fields that contain zero.",
      "ja": "多くの場合、リクエスタはチャンクを提供しません。その場合、RPC-over-RDMAヘッダーの4つの固定フィールドの後に、ゼロを含む3つの32ビットフィールドがあります。"
    },
    {
      "indent": 0,
      "text": "5. RPC Bind Parameters",
      "section_title": true,
      "ja": "5. RPCバインドパラメータ"
    },
    {
      "indent": 3,
      "text": "In setting up a new RDMA connection, the first action by a Requester is to obtain a transport address for the Responder. The means used to obtain this address, and to open an RDMA connection, is dependent on the type of RDMA transport and is the responsibility of each RPC protocol binding and its local implementation.",
      "ja": "新しいRDMA接続をセットアップする場合、リクエスターによる最初のアクションは、レスポンダーのトランスポートアドレスを取得することです。このアドレスを取得し、RDMA接続を開くために使用される手段は、RDMAトランスポートのタイプに依存し、各RPCプロトコルバインディングとそのローカル実装の責任です。"
    },
    {
      "indent": 3,
      "text": "RPC services normally register with a portmap or rpcbind service [RFC1833], which associates an RPC Program number with a service address. This policy is no different with RDMA transports. However, a different and distinct service address (port number) might sometimes be required for ULP operation with RPC-over-RDMA.",
      "ja": "RPCサービスは通常、RPCプログラム番号をサービスアドレスに関連付けるポートマップまたはrpcbindサービス[RFC1833]に登録します。このポリシーは、RDMAトランスポートでも同じです。ただし、RPC-over-RDMAでのULP動作には、異なる個別のサービスアドレス（ポート番号）が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "When mapped atop the iWARP transport [RFC5040] [RFC5041], which uses IP port addressing due to its layering on TCP and/or SCTP, port mapping is trivial and consists merely of issuing the port in the connection process. The NFS/RDMA protocol service address has been assigned port 20049 by IANA, for both iWARP/TCP and iWARP/SCTP [RFC5667].",
      "ja": "TCPやSCTPでのレイヤー化によりIPポートアドレッシングを使用するiWARPトランスポート[RFC5040] [RFC5041]の上にマッピングされる場合、ポートマッピングは簡単で、接続プロセスでポートを発行するだけです。 NFS / RDMAプロトコルサービスアドレスには、iWARP / TCPとiWARP / SCTP [RFC5667]の両方について、IANAによってポート20049が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "When mapped atop InfiniBand [IBARCH], which uses a service endpoint naming scheme based on a Group Identifier (GID), a translation MUST be employed. One such translation is described in Annexes A3 (Application Specific Identifiers), A4 (Sockets Direct Protocol (SDP)), and A11 (RDMA IP CM Service) of [IBARCH], which is appropriate for translating IP port addressing to the InfiniBand network. Therefore, in this case, IP port addressing may be readily employed by the upper layer.",
      "ja": "グループ識別子（GID）に基づくサービスエンドポイント命名方式を使用するInfiniBand [IBARCH]の上にマッピングする場合、変換を採用する必要があります。そのような変換の1つは、[IBARCH]の付録A3（Application Specific Identifiers）、A4（Sockets Direct Protocol（SDP））、およびA11（RDMA IP CM Service）で説明されており、IPポートアドレスをInfiniBandネットワークに変換するのに適しています。したがって、この場合、IPポートアドレッシングは上位層で容易に使用できます。"
    },
    {
      "indent": 3,
      "text": "When a mapping standard or convention exists for IP ports on an RDMA interconnect, there are several possibilities for each upper layer to consider:",
      "ja": "RDMA相互接続のIPポートにマッピング標準または規則が存在する場合、各上位層で考慮すべきいくつかの可能性があります。"
    },
    {
      "indent": 3,
      "text": "o One possibility is to have the Responder register its mapped IP port with the rpcbind service under the netid (or netids) defined here. An RPC-over-RDMA-aware Requester can then resolve its desired service to a mappable port and proceed to connect. This is the most flexible and compatible approach, for those upper layers that are defined to use the rpcbind service.",
      "ja": "o 1つの可能性は、ここで定義されたnetid（または複数のnetid）の下でrpcbindサービスにマップされたIPポートをレスポンダーに登録させることです。次に、RPC-over-RDMA対応のリクエスターは、必要なサービスをマップ可能なポートに解決し、接続を続行できます。これは、rpcbindサービスを使用するように定義されている上位層にとって、最も柔軟で互換性のあるアプローチです。"
    },
    {
      "indent": 3,
      "text": "o A second possibility is to have the Responder's portmapper register itself on the RDMA interconnect at a \"well-known\" service address (on UDP or TCP, this corresponds to port 111). A Requester could connect to this service address and use the portmap protocol to obtain a service address in response to a program number, e.g., an iWARP port number or an InfiniBand GID.",
      "ja": "o 2番目の可能性は、「よく知られている」サービスアドレス（UDPまたはTCPの場合、これはポート111に対応します）のRDMA相互接続上のレスポンダーのポートマッパーレジスタ自体を使用することです。リクエスターはこのサービスアドレスに接続し、ポートマッププロトコルを使用して、プログラム番号（iWARPポート番号やInfiniBand GIDなど）に応じてサービスアドレスを取得できます。"
    },
    {
      "indent": 3,
      "text": "o Alternately, the Requester could simply connect to the mapped well-known port for the service itself, if it is appropriately defined. By convention, the NFS/RDMA service, when operating atop such an InfiniBand fabric, uses the same 20049 assignment as for iWARP.",
      "ja": "o あるいは、適切に定義されていれば、リクエスターはサービス自体のマップされた既知のポートに接続するだけで済みます。慣例により、NFS / RDMAサービスは、このようなInfiniBandファブリック上で動作する場合、iWARPと同じ20049割り当てを使用します。"
    },
    {
      "indent": 3,
      "text": "Historically, different RPC protocols have taken different approaches to their port assignment. Therefore, the specific method is left to each RPC-over-RDMA-enabled ULB and is not addressed in this document.",
      "ja": "従来、RPCプロトコルが異なれば、ポートの割り当て方法も異なります。したがって、特定の方法は各RPC-over-RDMA対応のULBに委ねられており、このドキュメントでは扱いません。"
    },
    {
      "indent": 3,
      "text": "In Section 9, this specification defines two new netid values, to be used for registration of upper layers atop iWARP [RFC5040] [RFC5041] and (when a suitable port translation service is available) InfiniBand [IBARCH]. Additional RDMA-capable networks MAY define their own netids, or if they provide a port translation, they MAY share the one defined in this document.",
      "ja": "セクション9では、この仕様は2つの新しいnetid値を定義し、iWARP [RFC5040] [RFC5041]および（適切なポート変換サービスが利用可能な場合）InfiniBand [IBARCH]上の上位層の登録に使用されます。追加のRDMA対応ネットワークは、独自のnetidを定義してもよいし、ポート変換を提供する場合は、このドキュメントで定義されているものを共有してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "6. ULB Specifications",
      "section_title": true,
      "ja": "6. ULB仕様"
    },
    {
      "indent": 3,
      "text": "An ULP is typically defined independently of any particular RPC transport. An ULB (ULB) specification provides guidance that helps the ULP interoperate correctly and efficiently over a particular transport. For RPC-over-RDMA version 1, a ULB may provide:",
      "ja": "ULPは通常、特定のRPCトランスポートとは無関係に定義されます。 ULB（ULB）仕様は、ULPが特定のトランスポート上で正しく効率的に相互運用するのに役立つガイダンスを提供します。 RPC-over-RDMAバージョン1の場合、ULBは以下を提供します。"
    },
    {
      "indent": 3,
      "text": "o A taxonomy of XDR data items that are eligible for DDP",
      "ja": "o DDPの対象となるXDRデータ項目の分類"
    },
    {
      "indent": 3,
      "text": "o Constraints on which upper-layer procedures may be reduced and on how many chunks may appear in a single RPC request",
      "ja": "o 上位層の手順が削減される可能性がある制約、および単一のRPC要求に表示されるチャンクの数に関する制約"
    },
    {
      "indent": 3,
      "text": "o A method for determining the maximum size of the reply Payload stream for all procedures in the ULP",
      "ja": "o ULPのすべてのプロシージャの応答ペイロードストリームの最大サイズを決定する方法"
    },
    {
      "indent": 3,
      "text": "o An rpcbind port assignment for operation of the RPC Program and Version on an RPC-over-RDMA transport",
      "ja": "o RPC-over-RDMAトランスポートでのRPCプログラムとバージョンの操作のためのrpcbindポート割り当て"
    },
    {
      "indent": 3,
      "text": "Each RPC Program and Version tuple that utilizes RPC-over-RDMA version 1 needs to have a ULB specification.",
      "ja": "RPC-over-RDMAバージョン1を利用する各RPCプログラムおよびバージョンタプルには、ULB仕様が必要です。"
    },
    {
      "indent": 0,
      "text": "6.1. DDP-Eligibility",
      "section_title": true,
      "ja": "6.1. DDPの適格性"
    },
    {
      "indent": 3,
      "text": "An ULB designates some XDR data items as eligible for DDP. As an RPC-over-RDMA message is formed, DDP-eligible data items can be removed from the Payload stream and placed directly in the receiver's memory.",
      "ja": "ULBは、一部のXDRデータ項目をDDPの対象として指定します。 RPC-over-RDMAメッセージが形成されると、DDP適格データ項目をペイロードストリームから削除して、受信機のメモリに直接配置できます。"
    },
    {
      "indent": 3,
      "text": "An XDR data item should be considered for DDP-eligibility if there is a clear benefit to moving the contents of the item directly from the sender's memory to the receiver's memory. Criteria for DDP-eligibility include:",
      "ja": "項目のコンテンツを送信者のメモリから受信者のメモリに直接移動することの明らかな利点がある場合、XDRデータ項目はDDP適格性について検討する必要があります。 DDP適格性の基準は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The XDR data item is frequently sent or received, and its size is often much larger than typical inline thresholds.",
      "ja": "o XDRデータ項目は頻繁に送受信され、そのサイズは通常のインラインしきい値よりはるかに大きくなります。"
    },
    {
      "indent": 3,
      "text": "o If the XDR data item is a result, its maximum size must be predictable in advance by the Requester.",
      "ja": "o XDRデータ項目が結果である場合、その最大サイズは、リクエスターによって事前に予測可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Transport-level processing of the XDR data item is not needed. For example, the data item is an opaque byte array, which requires no XDR encoding and decoding of its content.",
      "ja": "o XDRデータ項目のトランスポートレベルの処理は必要ありません。たとえば、データ項目は不透明なバイト配列であり、そのコンテンツのXDRエンコードおよびデコードは必要ありません。"
    },
    {
      "indent": 3,
      "text": "o The content of the XDR data item is sensitive to address alignment. For example, a data copy operation would be required on the receiver to enable the message to be parsed correctly, or to enable the data item to be accessed.",
      "ja": "o XDRデータ項目のコンテンツは、アドレスアライメントの影響を受けます。たとえば、メッセージを正しく解析したり、データ項目にアクセスしたりするには、受信側でデータコピー操作が必要になります。"
    },
    {
      "indent": 3,
      "text": "o The XDR data item does not contain DDP-eligible data items.",
      "ja": "o XDRデータ項目には、DDP対応のデータ項目が含まれていません。"
    },
    {
      "indent": 3,
      "text": "In addition to defining the set of data items that are DDP-eligible, a ULB may also limit the use of chunks to particular upper-layer procedures. If more than one data item in a procedure is DDP-eligible, the ULB may also limit the number of chunks that a Requester can provide for a particular upper-layer procedure.",
      "ja": "ULBは、DDP対応のデータ項目のセットを定義することに加えて、チャンクの使用を特定の上位層の手順に制限することもできます。プロシージャ内の複数のデータ項目がDDPに対応している場合、ULBは、リクエスタが特定の上位層プロシージャに提供できるチャンクの数を制限する場合もあります。"
    },
    {
      "indent": 3,
      "text": "Senders MUST NOT reduce data items that are not DDP-eligible. Such data items MAY, however, be moved as part of a Position Zero Read chunk or a Reply chunk.",
      "ja": "送信者は、DDPに対応していないデータ項目を削減してはなりません。ただし、そのようなデータ項目は、位置ゼロ読み取りチャンクまたは応答チャンクの一部として移動できます。"
    },
    {
      "indent": 3,
      "text": "The programming interface by which an upper-layer implementation indicates the DDP-eligibility of a data item to the RPC transport is not described by this specification. The only requirements are that the receiver can re-assemble the transmitted RPC-over-RDMA message into a valid XDR stream, and that DDP-eligibility rules specified by the ULB are respected.",
      "ja": "上位層の実装がデータ項目のDDP適格性をRPCトランスポートに示すプログラミングインターフェイスは、この仕様では説明されていません。唯一の要件は、受信者が送信されたRPC-over-RDMAメッセージを有効なXDRストリームに再構成できること、およびULBによって指定されたDDP適格性ルールが尊重されることです。"
    },
    {
      "indent": 3,
      "text": "There is no provision to express DDP-eligibility within the XDR language. The only definitive specification of DDP-eligibility is a ULB.",
      "ja": "XDR言語内でDDPの適格性を表現する規定はありません。 DDP適格性の唯一の明確な仕様はULBです。"
    },
    {
      "indent": 3,
      "text": "In general, a DDP-eligibility violation occurs when:",
      "ja": "一般に、DDP資格違反は次の場合に発生します。"
    },
    {
      "indent": 3,
      "text": "o A Requester reduces a non-DDP-eligible argument data item. The Responder MUST NOT process this RPC Call message and MUST report the violation as described in Section 4.5.2.",
      "ja": "o リクエスターは、DDP非対応の引数データ項目を削減します。レスポンダはこのRPC呼び出しメッセージを処理してはならず（MUST NOT）、セクション4.5.2で説明されているように違反を報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A Responder reduces a non-DDP-eligible result data item. The Requester MUST terminate the pending RPC transaction and report an appropriate permanent error to the RPC consumer.",
      "ja": "o レスポンダは、DDP対応でない結果データ項目を削減します。リクエスターは保留中のRPCトランザクションを終了し、適切な永続的なエラーをRPCコンシューマーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A Responder does not reduce a DDP-eligible result data item into an available Write chunk. The Requester MUST terminate the pending RPC transaction and report an appropriate permanent error to the RPC consumer.",
      "ja": "o レスポンダは、DDP対応の結果データ項目を使用可能な書き込みチャンクに削減しません。リクエスタは保留中のRPCトランザクションを終了し、RPCコンシューマに適切な永続的なエラーを報告する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Maximum Reply Size",
      "section_title": true,
      "ja": "6.2. 最大応答サイズ"
    },
    {
      "indent": 3,
      "text": "A Requester provides resources for both an RPC Call message and its matching RPC Reply message. A Requester forms the RPC Call message itself; thus, the Requester can compute the exact resources needed.",
      "ja": "リクエスターは、R​​PC呼び出しメッセージとそれに対応するRPC応答メッセージの両方にリソースを提供します。リクエスターはRPC呼び出しメッセージ自体を形成します。したがって、リクエスタは必要なリソースを正確に計算できます。"
    },
    {
      "indent": 3,
      "text": "A Requester must allocate resources for the RPC Reply message (an RPC-over-RDMA credit, a Receive buffer, and possibly a Write list and Reply chunk) before the Responder has formed the actual reply. To accommodate all possible replies for the procedure in the RPC Call message, a Requester must allocate reply resources based on the maximum possible size of the expected RPC Reply message.",
      "ja": "リクエスターは、実際の応答を形成する前に、RPC応答メッセージ（RPC-over-RDMAクレジット、受信バッファー、および場合によっては書き込みリストと応答チャンク）にリソースを割り当てる必要があります。 RPC呼び出しメッセージの手順に対するすべての可能な応答に対応するには、リクエスターは、予想されるRPC応答メッセージの可能な最大サイズに基づいて応答リソースを割り当てる必要があります。"
    },
    {
      "indent": 3,
      "text": "If there are procedures in the ULP for which there is no clear reply size maximum, the ULB needs to specify a dependable means for determining the maximum.",
      "ja": "明確な応答サイズの最大値がないULPの手順がある場合、ULBは最大値を決定するための信頼できる手段を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Additional Considerations",
      "section_title": true,
      "ja": "6.3. その他の考慮事項"
    },
    {
      "indent": 3,
      "text": "There may be other details provided in a ULB.",
      "ja": "ULBで提供される他の詳細がある場合があります。"
    },
    {
      "indent": 3,
      "text": "o An ULB may recommend inline threshold values or other transport-related parameters for RPC-over-RDMA version 1 connections bearing that ULP.",
      "ja": "o ULBは、そのULPを担うRPC-over-RDMAバージョン1接続のインラインしきい値または他のトランスポート関連パラメーターを推奨する場合があります。"
    },
    {
      "indent": 3,
      "text": "o An ULP may provide a means to communicate these transport-related parameters between peers. Note that RPC-over-RDMA version 1 does not specify any mechanism for changing any transport-related parameter after a connection has been established.",
      "ja": "o ULPは、これらのトランスポート関連パラメーターをピア間で通信する手段を提供します。 RPC-over-RDMAバージョン1では、接続が確立された後、トランスポート関連のパラメーターを変更するメカニズムは指定されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Multiple ULPs may share a single RPC-over-RDMA version 1 connection when their ULBs allow the use of RPC-over-RDMA version 1 and the rpcbind port assignments for the Protocols allow connection sharing. In this case, the same transport parameters (such as inline threshold) apply to all Protocols using that connection.",
      "ja": "o 複数のULPは、ULBがRPC-over-RDMAバージョン1の使用を許可し、プロトコルのrpcbindポート割り当てが接続の共有を許可する場合、単一のRPC-over-RDMAバージョン1接続を共有できます。この場合、同じ転送パラメータ（インラインしきい値など）は、その接続を使用するすべてのプロトコルに適用されます。"
    },
    {
      "indent": 3,
      "text": "Each ULB needs to be designed to allow correct interoperation without regard to the transport parameters actually in use. Furthermore, implementations of ULPs must be designed to interoperate correctly regardless of the connection parameters in effect on a connection.",
      "ja": "各ULBは、実際に使用されているトランスポートパラメータに関係なく、正しい相互運用を可能にするように設計する必要があります。さらに、ULPの実装は、接続で有効な接続パラメーターに関係なく正しく相互運用するように設計する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. ULP Extensions",
      "section_title": true,
      "ja": "6.4. ULP拡張"
    },
    {
      "indent": 3,
      "text": "An RPC Program and Version tuple may be extensible. For instance, there may be a minor versioning scheme that is not reflected in the RPC version number, or the ULP may allow additional features to be specified after the original RPC Program specification was ratified.",
      "ja": "RPCプログラムとバージョンタプルは拡張可能です。たとえば、RPCバージョン番号に反映されていないマイナーバージョン管理スキームがある場合や、ULPにより、元のRPCプログラム仕様の承認後に追加機能を指定できる場合があります。"
    },
    {
      "indent": 3,
      "text": "ULBs are provided for interoperable RPC Programs and Versions by extending existing ULBs to reflect the changes made necessary by each addition to the existing XDR.",
      "ja": "ULBは、既存のXDRへの追加ごとに必要な変更を反映するように既存のULBを拡張することにより、相互運用可能なRPCプログラムおよびバージョン用に提供されます。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Extensibility",
      "section_title": true,
      "ja": "7. プロトコルの拡張性"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA header format is specified using XDR, unlike the message header used with RPC-over-TCP. To maintain a high degree of interoperability among implementations of RPC-over-RDMA, any change to this XDR requires a protocol version number change. New versions of RPC-over-RDMA may be published as separate protocol specifications without updating this document.",
      "ja": "RPC-over-TCPで使用されるメッセージヘッダーとは異なり、RPC-over-RDMAヘッダー形式はXDRを使用して指定されます。 RPC-over-RDMAの実装間で高度な相互運用性を維持するには、このXDRを変更するたびにプロトコルバージョン番号を変更する必要があります。 RPC-over-RDMAの新しいバージョンは、このドキュメントを更新せずに、個別のプロトコル仕様として公開される場合があります。"
    },
    {
      "indent": 3,
      "text": "The first four fields in every RPC-over-RDMA header must remain aligned at the same fixed offsets for all versions of the RPC-over-RDMA protocol. The version number must be in a fixed place to enable implementations to detect protocol version mismatches.",
      "ja": "すべてのRPC-over-RDMAヘッダーの最初の4つのフィールドは、RPC-over-RDMAプロトコルのすべてのバージョンで同じ固定オフセットに揃えておく必要があります。実装がプロトコルバージョンの不一致を検出できるようにするには、バージョン番号を固定の場所に置く必要があります。"
    },
    {
      "indent": 3,
      "text": "For version mismatches to be reported in a fashion that all future version implementations can reliably decode, the rdma_proc field must remain in a fixed place, the value of ERR_VERS must always remain the same, and the field placement in struct rpc_rdma_errvers must always remain the same.",
      "ja": "将来のすべてのバージョン実装が確実にデコードできるようにバージョンの不一致を報告するには、rdma_procフィールドを固定位置に保ち、ERR_VERSの値を常に同じにし、struct rpc_rdma_errversのフィールド配置を常に同じにする必要があります。 。"
    },
    {
      "indent": 0,
      "text": "7.1. Conventional Extensions",
      "section_title": true,
      "ja": "7.1. 従来の拡張機能"
    },
    {
      "indent": 3,
      "text": "Introducing new capabilities to RPC-over-RDMA version 1 is limited to the adoption of conventions that make use of existing XDR (defined in this document) and allowed abstract RDMA operations. Because no mechanism for detecting optional features exists in RPC-over-RDMA version 1, implementations must rely on ULPs to communicate the existence of such extensions.",
      "ja": "RPC-over-RDMAバージョン1への新機能の導入は、既存のXDR（このドキュメントで定義）を利用して抽象RDMA操作を許可する規則の採用に限定されています。 RPC-over-RDMAバージョン1にはオプション機能を検出するメカニズムが存在しないため、実装はULPに依存して、そのような拡張の存在を通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "Such extensions must be specified in a Standards Track RFC with appropriate review by the NFSv4 Working Group and the IESG. An example of a conventional extension to RPC-over-RDMA version 1 is the specification of backward direction message support to enable NFSv4.1 callback operations, described in [RFC8167].",
      "ja": "このような拡張機能は、NFSv4ワーキンググループとIESGによる適切なレビューとともに、Standards Track RFCで指定する必要があります。 [RFC8167]で説明されている、RPC-over-RDMAバージョン1の従来の拡張機能の例は、NFSv4.1コールバック操作を有効にするための逆方向メッセージサポートの仕様です。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Memory Protection",
      "section_title": true,
      "ja": "8.1. メモリ保護"
    },
    {
      "indent": 3,
      "text": "A primary consideration is the protection of the integrity and confidentiality of local memory by an RPC-over-RDMA transport. The use of an RPC-over-RDMA transport protocol MUST NOT introduce vulnerabilities to system memory contents nor to memory owned by user processes.",
      "ja": "主な考慮事項は、RPC-over-RDMAトランスポートによるローカルメモリの整合性と機密性の保護です。 RPC-over-RDMAトランスポートプロトコルを使用しても、システムメモリの内容やユーザープロセスが所有するメモリに脆弱性が生じてはなりません。"
    },
    {
      "indent": 3,
      "text": "It is REQUIRED that any RDMA provider used for RPC transport be conformant to the requirements of [RFC5042] in order to satisfy these protections. These protections are provided by the RDMA layer specifications, and in particular, their security models.",
      "ja": "これらの保護を満たすためには、RPCトランスポートに使用されるすべてのRDMAプロバイダーが[RFC5042]の要件に準拠している必要があります。これらの保護は、RDMAレイヤー仕様、特にセキュリティモデルによって提供されます。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Protection Domains",
      "section_title": true,
      "ja": "8.1.1. 保護ドメイン"
    },
    {
      "indent": 3,
      "text": "The use of Protection Domains to limit the exposure of memory regions to a single connection is critical. Any attempt by an endpoint not participating in that connection to reuse memory handles needs to result in immediate failure of that connection. Because ULP security mechanisms rely on this aspect of Reliable Connection behavior, strong authentication of remote endpoints is recommended.",
      "ja": "保護ドメインを使用して、メモリ領域の露出を単一の接続に制限することが重要です。その接続に参加していないエンドポイントがメモリハンドルを再利用しようとすると、その接続がすぐに失敗する必要があります。 ULPセキュリティメカニズムは高信頼性接続の動作のこの側面に依存しているため、リモートエンドポイントの強力な認証をお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Handle Predictability",
      "section_title": true,
      "ja": "8.1.2. 予測可能性を処理する"
    },
    {
      "indent": 3,
      "text": "Unpredictable memory handles should be used for any operation requiring advertised memory regions. Advertising a continuously registered memory region allows a remote host to read or write to that region even when an RPC involving that memory is not under way. Therefore, implementations should avoid advertising persistently registered memory.",
      "ja": "アドバタイズされたメモリ領域を必要とする操作には、予測できないメモリハンドルを使用する必要があります。継続的に登録されたメモリ領域をアドバタイズすると、そのメモリに関係するRPCが実行されていない場合でも、リモートホストがその領域に対して読み取りまたは書き込みを行うことができます。したがって、実装では、永続的に登録されたメモリのアドバタイズを回避する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Memory Protection",
      "section_title": true,
      "ja": "8.1.3. メモリ保護"
    },
    {
      "indent": 3,
      "text": "Requesters should register memory regions for remote access only when they are about to be the target of an RPC operation that involves an RDMA Read or Write.",
      "ja": "リクエスターは、R​​DMA読み取りまたは書き込みを含むRPC操作のターゲットになる直前にのみ、リモートアクセス用のメモリ領域を登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "Registered memory regions should be invalidated as soon as related RPC operations are complete. Invalidation and DMA unmapping of memory regions should be complete before message integrity checking is done and before the RPC consumer is allowed to continue execution and use or alter the contents of a memory region.",
      "ja": "登録されたメモリ領域は、関連するRPC操作が完了したらすぐに無効にする必要があります。メッセージの整合性チェックが実行される前、およびRPCコンシューマーが実行を続行してメモリ領域の内容を使用または変更できるようになる前に、メモリ領域の無効化とDMAのマッピング解除を完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "An RPC transaction on a Requester might be terminated before a reply arrives if the RPC consumer exits unexpectedly (for example, it is signaled or a segmentation fault occurs). When an RPC terminates abnormally, memory regions associated with that RPC should be invalidated appropriately before the regions are released to be reused for other purposes on the Requester.",
      "ja": "RPCコンシューマが予期せずに終了した場合（たとえば、シグナルが送信された場合やセグメンテーション違反が発生した場合）、リクエスタのRPCトランザクションが応答が到着する前に終了することがあります。 RPCが異常終了した場合、そのRPCに関連付けられたメモリ領域は、リクエスタで他の目的に再利用するために解放される前に、適切に無効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Denial of Service",
      "section_title": true,
      "ja": "8.1.4. サービス拒否"
    },
    {
      "indent": 3,
      "text": "A detailed discussion of denial-of-service exposures that can result from the use of an RDMA transport is found in Section 6.4 of [RFC5042].",
      "ja": "RDMAトランスポートの使用により発生する可能性があるサービス拒否攻撃の詳細については、[RFC5042]のセクション6.4をご覧ください。"
    },
    {
      "indent": 3,
      "text": "A Responder is not obliged to pull Read chunks that are unreasonably large. The Responder can use an RDMA_ERROR response to terminate RPCs with unreadable Read chunks. If a Responder transmits more data than a Requester is prepared to receive in a Write or Reply chunk, the RDMA Network Interface Cards (RNICs) typically terminate the connection. For further discussion, see Section 4.5. Such repeated chunk errors can deny service to other users sharing the connection from the errant Requester.",
      "ja": "レスポンダは、不当に大きい読み取りチャンクをプルする義務はありません。レスポンダは、RDMA_ERROR応答を使用して、読み取り不可の読み取りチャンクを持つRPCを終了できます。レスポンダーがリクエスターが書き込みまたは返信チャンクで受信する準備ができているよりも多くのデータを送信する場合、RDMAネットワークインターフェイスカード（RNIC）は通常、接続を終了します。詳細については、セクション4.5を参照してください。このようなチャンクエラーが繰り返し発生すると、誤ったリクエスタからの接続を共有している他のユーザーへのサービスが拒否される可能性があります。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transport implementation is not responsible for throttling the RPC request rate, other than to keep the number of concurrent RPC transactions at or under the number of credits granted per connection. This is explained in Section 3.3.1. A sender can trigger a self denial of service by exceeding the credit grant repeatedly.",
      "ja": "RPC-over-RDMAトランスポート実装は、同時RPCトランザクションの数を接続ごとに付与されたクレジット数以下に維持することを除いて、RPC要求レートを調整する責任はありません。これについては、セクション3.3.1で説明します。送信者は、クレジット付与を繰り返し超えることにより、自己サービス拒否をトリガーできます。"
    },
    {
      "indent": 3,
      "text": "When an RPC has been canceled due to a signal or premature exit of an application process, a Requester may invalidate the RPC's Write and Reply chunks. Invalidation prevents the subsequent arrival of the Responder's reply from altering the memory regions associated with those chunks after the memory has been reused.",
      "ja": "アプリケーションプロセスのシグナルまたは時期尚早の終了によりRPCがキャンセルされた場合、リクエスタはRPCの書き込みおよび返信チャンクを無効にすることがあります。無効化により、メモリが再利用された後、レスポンダーの応答の後続の到着がそれらのチャンクに関連付けられたメモリ領域を変更することを防ぎます。"
    },
    {
      "indent": 3,
      "text": "On the Requester, a malfunctioning application or a malicious user can create a situation where RPCs are continuously initiated and then aborted, resulting in Responder replies that terminate the underlying RPC-over-RDMA connection repeatedly. Such situations can deny service to other users sharing the connection from that Requester.",
      "ja": "リクエスタでは、誤動作しているアプリケーションまたは悪意のあるユーザーが、RPCが継続的に開始されてから中止される状況を作り出す可能性があり、その結果、基になるRPC-over-RDMA接続を繰り返し終了するレスポンダ応答が返されます。このような状況では、そのリクエスターからの接続を共有している他のユーザーへのサービスが拒否される可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.2. RPC Message Security",
      "section_title": true,
      "ja": "8.2. RPCメッセージセキュリティ"
    },
    {
      "indent": 3,
      "text": "ONC RPC provides cryptographic security via the RPCSEC_GSS framework [RFC7861]. RPCSEC_GSS implements message authentication (rpc_gss_svc_none), per-message integrity checking (rpc_gss_svc_integrity), and per-message confidentiality (rpc_gss_svc_privacy) in the layer above RPC-over-RDMA. The latter two services require significant computation and movement of data on each endpoint host. Some performance benefits enabled by RDMA transports can be lost.",
      "ja": "ONC RPCは、RPCSEC_GSSフレームワーク[RFC7861]を介して暗号化セキュリティを提供します。 RPCSEC_GSSは、RPC-over-RDMAの上のレイヤーにメッセージ認証（rpc_gss_svc_none）、メッセージごとの整合性チェック（rpc_gss_svc_integrity）、およびメッセージごとの機密性（rpc_gss_svc_privacy）を実装します。後者の2つのサービスでは、各エンドポイントホストでデータの大幅な計算と移動が必要です。 RDMAトランスポートによって可能になるパフォーマンス上の利点の一部が失われる可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.2.1. RPC-over-RDMA Protection at Lower Layers",
      "section_title": true,
      "ja": "8.2.1. 下位層でのRPC-over-RDMA保護"
    },
    {
      "indent": 0,
      "text": " For any RPC transport, utilizing RPCSEC_GSS integrity or privacy services has performance implications. Protection below the RPC transport is often more appropriate in performance-sensitive deployments, especially if it, too, can be offloaded. Certain configurations of IPsec can be co-located in RDMA hardware, for example, without change to RDMA consumers and little loss of data movement efficiency. Such arrangements can also provide a higher degree of privacy by hiding endpoint identity or altering the frequency at which messages are exchanged, at a performance cost.",
      "ja": "RPCトランスポートの場合、RPCSEC_GSS整合性またはプライバシーサービスを利用すると、パフォーマンスに影響があります。 RPCトランスポートより下の保護は、特にそれがオフロードできる場合は特に、パフォーマンス重視のデプロイメントでより適切です。 IPsecの特定の構成は、RDMAハードウェアに配置できます。たとえば、RDMAコンシューマーを変更することなく、データ移動効率をほとんど失うことはありません。このような構成では、パフォーマンスコストで、エンドポイントIDを非表示にするか、メッセージが交換される頻度を変更することにより、高度なプライバシーを提供することもできます。"
    },
    {
      "indent": 3,
      "text": "The use of protection in a lower layer MAY be negotiated through the use of an RPCSEC_GSS security flavor defined in [RFC7861] in conjunction with the Channel Binding mechanism [RFC5056] and IPsec Channel Connection Latching [RFC5660]. Use of such mechanisms is REQUIRED where integrity or confidentiality is desired and where efficiency is required.",
      "ja": "下位層での保護の使用は、チャネルバインディングメカニズム[RFC5056]およびIPsecチャネル接続ラッチ[RFC5660]と組み合わせて[RFC7861]で定義されたRPCSEC_GSSセキュリティフレーバーの使用を通じてネゴシエートされる場合があります。このようなメカニズムの使用は、完全性または機密性が要求され、効率が要求される場合に必要です。"
    },
    {
      "indent": 0,
      "text": "8.2.2. RPCSEC_GSS on RPC-over-RDMA Transports",
      "section_title": true,
      "ja": "8.2.2. RPC-over-RDMAトランスポートのRPCSEC_GSS"
    },
    {
      "indent": 3,
      "text": "Not all RDMA devices and fabrics support the above protection mechanisms. Also, per-message authentication is still required on NFS clients where multiple users access NFS files. In these cases, RPCSEC_GSS can protect NFS traffic conveyed on RPC-over-RDMA connections.",
      "ja": "すべてのRDMAデバイスとファブリックが上記の保護メカニズムをサポートしているわけではありません。また、複数のユーザーがNFSファイルにアクセスするNFSクライアントでは、メッセージごとの認証も必要です。これらの場合、RPCSEC_GSSはRPC-over-RDMA接続で伝達されるNFSトラフィックを保護できます。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS extends the ONC RPC protocol [RFC5531] without changing the format of RPC messages. By observing the conventions described in this section, an RPC-over-RDMA transport can convey RPCSEC_GSS-protected RPC messages interoperably.",
      "ja": "RPCSEC_GSSは、RPCメッセージのフォーマットを変更せずにONC RPCプロトコル[RFC5531]を拡張します。このセクションで説明する規則を順守することにより、RPC-over-RDMAトランスポートはRPCSEC_GSSで保護されたRPCメッセージを相互運用的に伝達できます。"
    },
    {
      "indent": 3,
      "text": "As part of the ONC RPC protocol, protocol elements of RPCSEC_GSS that appear in the Payload stream of an RPC-over-RDMA message (such as control messages exchanged as part of establishing or destroying a security context or data items that are part of RPCSEC_GSS authentication material) MUST NOT be reduced.",
      "ja": "ONC RPCプロトコルの一部として、RPC-over-RDMAメッセージのペイロードストリームに表示されるRPCSEC_GSSのプロトコル要素（RPCSEC_GSS認証の一部であるセキュリティコンテキストまたはデータ項目の確立または破棄の一部として交換される制御メッセージなど）材料）削減してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.2.1. RPCSEC_GSS Context Negotiation",
      "section_title": true,
      "ja": "8.2.2.1. RPCSEC_GSSコンテキストネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Some NFS client implementations use a separate connection to establish a Generic Security Service (GSS) context for NFS operation. These clients use TCP and the standard NFS port (2049) for context establishment. To enable the use of RPCSEC_GSS with NFS/RDMA, an NFS server MUST also provide a TCP-based NFS service on port 2049.",
      "ja": "一部のNFSクライアント実装では、別個の接続を使用して、NFS操作用のGeneric Security Service（GSS）コンテキストを確立します。これらのクライアントは、コンテキストの確立にTCPと標準のNFSポート（2049）を使用します。 NFS / RDMAでRPCSEC_GSSを使用できるようにするには、NFSサーバーがポート2049でTCPベースのNFSサービスも提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2.2.2. RPC-over-RDMA with RPCSEC_GSS Authentication",
      "section_title": true,
      "ja": "8.2.2.2. RPCSEC_GSS認証を使用したRPC-over-RDMA"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS authentication service has no impact on the DDP-eligibility of data items in a ULP.",
      "ja": "RPCSEC_GSS認証サービスは、ULP内のデータ項目のDDP適格性に影響を与えません。"
    },
    {
      "indent": 0,
      "text": " However, RPCSEC_GSS authentication material appearing in an RPC message header can be larger than, say, an AUTH_SYS authenticator. In particular, when an RPCSEC_GSS pseudoflavor is in use, a Requester needs to accommodate a larger RPC credential when marshaling RPC Call messages and needs to provide for a maximum size RPCSEC_GSS verifier when allocating reply buffers and Reply chunks.",
      "ja": "ただし、RPCメッセージヘッダーに表示されるRPCSEC_GSS認証資料は、たとえばAUTH_SYSオーセンティケーターよりも大きい場合があります。特に、RPCSEC_GSS疑似フレーバーが使用されている場合、リクエスターはRPC呼び出しメッセージをマーシャリングするときにより大きなRPC資格情報に対応する必要があり、応答バッファーと応答チャンクを割り当てるときに最大サイズのRPCSEC_GSS検証を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "RPC messages, and thus Payload streams, are made larger as a result. ULP operations that fit in a Short Message when a simpler form of authentication is in use might need to be reduced, or conveyed via a Long Message, when RPCSEC_GSS authentication is in use. It is more likely that a Requester provides both a Read list and a Reply chunk in the same RPC-over-RDMA header to convey a Long Call and provision a receptacle for a Long Reply. More frequent use of Long Messages can impact transport efficiency.",
      "ja": "その結果、RPCメッセージ、つまりペイロードストリームが大きくなります。 RPCSEC_GSS認証が使用されている場合、より単純な形式の認証が使用されているときにショートメッセージに適合するULP操作を削減するか、ロングメッセージを介して伝達する必要がある場合があります。リクエスタが同じRPC-over-RDMAヘッダーで読み取りリストと返信チャンクの両方を提供して、ロングコールを伝え、ロングリプライのレセプタクルをプロビジョニングする可能性が高くなります。長いメッセージをより頻繁に使用すると、トランスポート効率に影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.2.2.3. RPC-over-RDMA with RPCSEC_GSS Integrity or Privacy",
      "section_title": true,
      "ja": "8.2.2.3. RPCSEC_GSS整合性またはプライバシーを使用したRPC-over-RDMA"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS integrity service enables endpoints to detect modification of RPC messages in flight. The RPCSEC_GSS privacy service prevents all but the intended recipient from viewing the cleartext content of RPC arguments and results. RPCSEC_GSS integrity and privacy services are end-to-end. They protect RPC arguments and results from application to server endpoint, and back.",
      "ja": "RPCSEC_GSS整合性サービスにより、エンドポイントは、進行中のRPCメッセージの変更を検出できます。 RPCSEC_GSSプライバシーサービスは、意図された受信者以外のすべてがRPC引数および結果のクリアテキストコンテンツを表示できないようにします。 RPCSEC_GSSの整合性とプライバシーサービスはエンドツーエンドです。 RPCの引数と結果をアプリケーションからサーバーエンドポイントに、またその逆に保護します。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS integrity and encryption services operate on whole RPC messages after they have been XDR encoded for transmit, and before they have been XDR decoded after receipt. Both sender and receiver endpoints use intermediate buffers to prevent exposure of encrypted data or unverified cleartext data to RPC consumers. After verification, encryption, and message wrapping has been performed, the transport layer MAY use RDMA data transfer between these intermediate buffers.",
      "ja": "RPCSEC_GSS整合性および暗号化サービスは、送信用にXDRエンコードされた後、受信後にXDRデコードされる前に、RPCメッセージ全体で動作します。送信側と受信側の両方のエンドポイントは、中間バッファーを使用して、暗号化されたデータまたは未検証のクリアテキストデータがRPCコンシューマーに公開されないようにします。検証、暗号化、およびメッセージのラッピングが実行された後、トランスポート層はこれらの中間バッファー間でRDMAデータ転送を使用できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "The process of reducing a DDP-eligible data item removes the data item and its XDR padding from the encoded XDR stream. XDR padding of a reduced data item is not transferred in an RPC-over-RDMA message. After reduction, the Payload stream contains fewer octets than the whole XDR stream did beforehand. XDR padding octets are often zero bytes, but they don't have to be. Thus, reducing DDP-eligible items affects the result of message integrity verification or encryption.",
      "ja": "DDP対応のデータアイテムを削減するプロセスでは、データアイテムとそのXDRパディングがエンコードされたXDRストリームから削除されます。削減されたデータ項目のXDRパディングは、RPC-over-RDMAメッセージでは転送されません。削減後、ペイロードストリームに含まれるオクテットは、事前にXDRストリーム全体よりも少なくなっています。 XDRパディングオクテットは多くの場合0バイトですが、そうである必要はありません。したがって、DDP対応アイテムを減らすと、メッセージの整合性検証または暗号化の結果に影響します。"
    },
    {
      "indent": 3,
      "text": "Therefore, a sender MUST NOT reduce a Payload stream when RPCSEC_GSS integrity or encryption services are in use. Effectively, no data item is DDP-eligible in this situation, and Chunked Messages cannot be used. In this mode, an RPC-over-RDMA transport operates in the same manner as a transport that does not support DDP.",
      "ja": "したがって、RPCSEC_GSS整合性または暗号化サービスが使用されている場合、送信者はペイロードストリームを削減してはなりません（MUST NOT）。事実上、この状況ではDDPに適格なデータ項目はなく、チャンクメッセージは使用できません。このモードでは、RPC-over-RDMAトランスポートは、DDPをサポートしないトランスポートと同じように動作します。"
    },
    {
      "indent": 3,
      "text": "When an RPCSEC_GSS integrity or privacy service is in use, a Requester provides both a Read list and a Reply chunk in the same RPC-over-RDMA header to convey a Long Call and provision a receptacle for a Long Reply.",
      "ja": "RPCSEC_GSS整合性サービスまたはプライバシーサービスが使用されている場合、リクエスタは、同じRPC-over-RDMAヘッダーに読み取りリストと返信チャンクの両方を提供して、ロングコールを伝達し、ロングリプライのレセプタクルをプロビジョニングします。"
    },
    {
      "indent": 0,
      "text": "8.2.2.4. Protecting RPC-over-RDMA Transport Headers",
      "section_title": true,
      "ja": "8.2.2.4. RPC-over-RDMAトランスポートヘッダーの保護"
    },
    {
      "indent": 3,
      "text": "Like the base fields in an ONC RPC message (XID, call direction, and so on), the contents of an RPC-over-RDMA message's Transport stream are not protected by RPCSEC_GSS. This exposes XIDs, connection credit limits, and chunk lists (but not the content of the data items they refer to) to malicious behavior, which could redirect data that is transferred by the RPC-over-RDMA message, result in spurious retransmits, or trigger connection loss.",
      "ja": "ONC RPCメッセージの基本フィールド（XID、呼び出し方向など）と同様に、RPC-over-RDMAメッセージのトランスポートストリームの内容は、RPCSEC_GSSによって保護されません。これにより、XID、接続クレジット制限、およびチャンクリスト（それらが参照するデータアイテムのコンテンツではない）が悪意のある動作にさらされ、RPC-over-RDMAメッセージによって転送されるデータがリダイレクトされ、誤った再送信が行われる、または接続損失をトリガーします。"
    },
    {
      "indent": 3,
      "text": "In particular, if an attacker alters the information contained in the chunk lists of an RPC-over-RDMA header, data contained in those chunks can be redirected to other registered memory regions on Requesters. An attacker might alter the arguments of RDMA Read and RDMA Write operations on the wire to similar effect. If such alterations occur, the use of RPCSEC_GSS integrity or privacy services enable a Requester to detect unexpected material in a received RPC message.",
      "ja": "特に、攻撃者がRPC-over-RDMAヘッダーのチャンクリストに含まれる情報を変更した場合、それらのチャンクに含まれるデータは、リクエスターの他の登録されたメモリ領域にリダイレクトされる可能性があります。攻撃者は、回線上のRDMA読み取りおよびRDMA書き込み操作の引数を変更して、同様の影響を与える可能性があります。このような変更が発生した場合、RPCSEC_GSS整合性またはプライバシーサービスを使用すると、リクエスターは受信したRPCメッセージ内の予期しないコンテンツを検出できます。"
    },
    {
      "indent": 3,
      "text": "Encryption at lower layers, as described in Section 8.2.1, protects the content of the Transport stream. To address attacks on RDMA protocols themselves, RDMA transport implementations should conform to [RFC5042].",
      "ja": "セクション8.2.1で説明されているように、下位層での暗号化は、トランスポートストリームのコンテンツを保護します。 RDMAプロトコル自体への攻撃に対処するには、RDMAトランスポート実装が[RFC5042]に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A set of RPC netids for resolving RPC-over-RDMA services is specified by this document. This is unchanged from [RFC5666].",
      "ja": "RPC-over-RDMAサービスを解決するための一連のRPC netidは、このドキュメントで指定されています。これは[RFC5666]から変更されていません。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA transport has been assigned an RPC netid, which is an rpcbind [RFC1833] string used to describe the underlying protocol in order for RPC to select the appropriate transport framing, as well as the format of the service addresses and ports.",
      "ja": "RPC-over-RDMAトランスポートにはRPC netidが割り当てられています。これは、RPCが適切なトランスポートフレーミングとサービスアドレスとポートのフォーマットを選択するために、基になるプロトコルを記述するために使用されるrpcbind [RFC1833]文字列です。 。"
    },
    {
      "indent": 3,
      "text": "The following netid registry strings are defined for this purpose:",
      "ja": "この目的のために、次のnetidレジストリ文字列が定義されています。"
    },
    {
      "indent": 6,
      "text": "NC_RDMA \"rdma\" NC_RDMA6 \"rdma6\"",
      "ja": "NC_RDMA \"rdma\" NC_RDMA6 \"rdma6\""
    },
    {
      "indent": 3,
      "text": "The \"rdma\" netid is to be used when IPv4 addressing is employed by the underlying transport, and \"rdma6\" for IPv6 addressing. The netid assignment policy and registry are defined in [RFC5665].",
      "ja": "「rdma」netidは、基礎となるトランスポートでIPv4アドレス指定が採用されている場合に使用され、「rdma6」はIPv6アドレス指定に使用されます。 netid割り当てポリシーとレジストリは[RFC5665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "These netids MAY be used for any RDMA network that satisfies the requirements of Section 2.3.2 and that is able to identify service endpoints using IP port addressing, possibly through use of a translation service as described in Section 5.",
      "ja": "これらのnetidは、セクション2.3.2の要件を満たし、おそらくセクション5で説明した変換サービスを使用することにより、IPポートアドレッシングを使用してサービスエンドポイントを識別できる任意のRDMAネットワークに使用できます。"
    },
    {
      "indent": 3,
      "text": "The use of the RPC-over-RDMA protocol has no effect on RPC Program numbers or existing registered port numbers. However, new port numbers MAY be registered for use by RPC-over-RDMA-enabled services, as appropriate to the new networks over which the services will operate.",
      "ja": "RPC-over-RDMAプロトコルを使用しても、RPCプログラム番号や既存の登録済みポート番号には影響しません。ただし、サービスが動作する新しいネットワークに応じて、RPC-over-RDMA対応のサービスで使用するために、新しいポート番号を登録できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "For example, the NFS/RDMA service defined in [RFC5667] has been assigned the port 20049 in the \"Service Name and Transport Protocol Port Number Registry\". This is distinct from the port number defined for NFS on TCP, which is assigned the port 2049 in the same registry. NFS clients use the same RPC Program number for NFS (100003) when using either transport [RFC5531] (see the \"Remote Procedure Call (RPC) Program Numbers\" registry).",
      "ja": "たとえば、[RFC5667]で定義されているNFS / RDMAサービスには、「サービス名とトランスポートプロトコルのポート番号レジストリ」でポート20049が割り当てられています。これは、同じレジストリでポート2049が割り当てられているTCP上のNFS用に定義されたポート番号とは異なります。いずれかのトランスポート[RFC5531]を使用する場合、NFSクライアントはNFSに同じRPCプログラム番号（100003）を使用します（「リモートプロシージャコール（RPC）プログラム番号」レジストリを参照）。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1833] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, DOI 10.17487/RFC1833, August 1995, <http://www.rfc-editor.org/info/rfc1833>.",
      "ja": "[RFC1833] Srinivasan、R。、「Binding Protocols for ONC RPC Version 2」、RFC 1833、DOI 10.17487 / RFC1833、1995年8月、<http://www.rfc-editor.org/info/rfc1833>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <http://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<http://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5042] Pinkerton, J. and E. Deleganes, \"Direct Data Placement Protocol (DDP) / Remote Direct Memory Access Protocol (RDMAP) Security\", RFC 5042, DOI 10.17487/RFC5042, October 2007, <http://www.rfc-editor.org/info/rfc5042>.",
      "ja": "[RFC5042] Pinkerton、J。およびE. Deleganes、「Direct Data Placement Protocol（DDP）/ Remote Direct Memory Access Protocol（RDMAP）Security」、RFC 5042、DOI 10.17487 / RFC5042、2007年10月、<http：// www。 rfc-editor.org/info/rfc5042>。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <http://www.rfc-editor.org/info/rfc5056>.",
      "ja": "[RFC5056]ウィリアムズN.、「セキュアチャネルへのチャネルバインディングの使用について」、RFC 5056、DOI 10.17487 / RFC5056、2007年11月、<http://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5531] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <http://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[RFC5531] Thurlow、R。、「RPC：Remote Procedure Call Protocol Specification Version 2」、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、<http://www.rfc-editor.org/info/rfc5531>。"
    },
    {
      "indent": 3,
      "text": "[RFC5660] Williams, N., \"IPsec Channels: Connection Latching\", RFC 5660, DOI 10.17487/RFC5660, October 2009, <http://www.rfc-editor.org/info/rfc5660>.",
      "ja": "[RFC5660] Williams、N。、「IPsec Channels：Connection Latching」、RFC 5660、DOI 10.17487 / RFC5660、2009年10月、<http://www.rfc-editor.org/info/rfc5660>。"
    },
    {
      "indent": 3,
      "text": "[RFC5665] Eisler, M., \"IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats\", RFC 5665, DOI 10.17487/RFC5665, January 2010, <http://www.rfc-editor.org/info/rfc5665>.",
      "ja": "[RFC5665] Eisler、M。、「リモートプロシージャコール（RPC）ネットワーク識別子とユニバーサルアドレスフォーマットに関するIANAの考慮事項」、RFC 5665、DOI 10.17487 / RFC5665、2010年1月、<http://www.rfc-editor.org/ info / rfc5665>。"
    },
    {
      "indent": 3,
      "text": "[RFC7861] Adamson, A. and N. Williams, \"Remote Procedure Call (RPC) Security Version 3\", RFC 7861, DOI 10.17487/RFC7861, November 2016, <http://www.rfc-editor.org/info/rfc7861>.",
      "ja": "[RFC7861] Adamson、A。およびN. Williams、「Remote Procedure Call（RPC）Security Version 3」、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、<http://www.rfc-editor.org/info/ rfc7861>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「あいまいな大文字と小文字のRFC 2119キーワード」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[IBARCH] InfiniBand Trade Association, \"InfiniBand Architecture Specification Volume 1\", Release 1.3, March 2015, <http://www.infinibandta.org/content/ pages.php?pg=technology_download>.",
      "ja": "[IBARCH] InfiniBand Trade Association、「InfiniBand Architecture Specification Volume 1」、リリース1.3、2015年3月、<http://www.infinibandta.org/content/ pages.php？pg = technology_download>。"
    },
    {
      "indent": 3,
      "text": "[RFC768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <http://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC768] Postel、J。、「User Datagram Protocol」、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、<http://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC1094] Nowicki, B., \"NFS: Network File System Protocol specification\", RFC 1094, DOI 10.17487/RFC1094, March 1989, <http://www.rfc-editor.org/info/rfc1094>.",
      "ja": "[RFC1094] Nowicki、B。、「NFS：Network File System Protocol specification」、RFC 1094、DOI 10.17487 / RFC1094、1989年3月、<http://www.rfc-editor.org/info/rfc1094>。"
    },
    {
      "indent": 3,
      "text": "[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, \"NFS Version 3 Protocol Specification\", RFC 1813, DOI 10.17487/RFC1813, June 1995, <http://www.rfc-editor.org/info/rfc1813>.",
      "ja": "[RFC1813] Callaghan、B.、Pawlowski、B。、およびP. Staubach、「NFSバージョン3プロトコル仕様」、RFC 1813、DOI 10.17487 / RFC1813、1995年6月、<http://www.rfc-editor.org/ info / rfc1813>。"
    },
    {
      "indent": 3,
      "text": "[RFC5040] Recio, R., Metzler, B., Culley, P., Hilland, J., and D. Garcia, \"A Remote Direct Memory Access Protocol Specification\", RFC 5040, DOI 10.17487/RFC5040, October 2007, <http://www.rfc-editor.org/info/rfc5040>.",
      "ja": "[RFC5040] Recio、R.、Metzler、B.、Culley、P.、Hilland、J。、およびD. Garcia、「A Remote Direct Memory Access Protocol Specification」、RFC 5040、DOI 10.17487 / RFC5040、2007年10月、< http://www.rfc-editor.org/info/rfc5040>。"
    },
    {
      "indent": 3,
      "text": "[RFC5041] Shah, H., Pinkerton, J., Recio, R., and P. Culley, \"Direct Data Placement over Reliable Transports\", RFC 5041, DOI 10.17487/RFC5041, October 2007, <http://www.rfc-editor.org/info/rfc5041>.",
      "ja": "[RFC5041] Shah、H.、Pinkerton、J.、Recio、R。、およびP. Culley、「Reliable Transportsを介した直接データ配置」、RFC 5041、DOI 10.17487 / RFC5041、2007年10月、<http：// www。 rfc-editor.org/info/rfc5041>。"
    },
    {
      "indent": 3,
      "text": "[RFC5532] Talpey, T. and C. Juszczak, \"Network File System (NFS) Remote Direct Memory Access (RDMA) Problem Statement\", RFC 5532, DOI 10.17487/RFC5532, May 2009, <http://www.rfc-editor.org/info/rfc5532>.",
      "ja": "[RFC5532] Talpey、T。およびC. Juszczak、「Network File System（NFS）Remote Direct Memory Access（RDMA）Problem Statement」、RFC 5532、DOI 10.17487 / RFC5532、2009年5月、<http：//www.rfc- editor.org/info/rfc5532>。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <http://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 \"Network File System（NFS）Version 4 Minor Version 1 Protocol\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<http://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description\", RFC 5662, DOI 10.17487/RFC5662, January 2010, <http://www.rfc-editor.org/info/rfc5662>.",
      "ja": "[RFC5662] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 \"Network File System（NFS）Version 4 Minor Version 1 External Data Representation Standard（XDR）Description\"、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、<http://www.rfc-editor.org/info/rfc5662>。"
    },
    {
      "indent": 3,
      "text": "[RFC5666] Talpey, T. and B. Callaghan, \"Remote Direct Memory Access Transport for Remote Procedure Call\", RFC 5666, DOI 10.17487/RFC5666, January 2010, <http://www.rfc-editor.org/info/rfc5666>.",
      "ja": "[RFC5666] Talpey、T。およびB. Callaghan、「リモートプロシージャコールのリモートダイレクトメモリアクセストランスポート」、RFC 5666、DOI 10.17487 / RFC5666、2010年1月、<http://www.rfc-editor.org/info/ rfc5666>。"
    },
    {
      "indent": 3,
      "text": "[RFC5667] Talpey, T. and B. Callaghan, \"Network File System (NFS) Direct Data Placement\", RFC 5667, DOI 10.17487/RFC5667, January 2010, <http://www.rfc-editor.org/info/rfc5667>.",
      "ja": "[RFC5667] Talpey、T。およびB. Callaghan、「Network File System（NFS）Direct Data Placement」、RFC 5667、DOI 10.17487 / RFC5667、2010年1月、<http://www.rfc-editor.org/info/ rfc5667>。"
    },
    {
      "indent": 3,
      "text": "[RFC7530] Haynes, T., Ed. and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <http://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[RFC7530]ヘインズ、T。、エド。およびD. Noveck編、「Network File System（NFS）Version 4 Protocol」、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<http://www.rfc-editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[RFC8167] Lever, C., \"Bidirectional Remote Procedure Call on RPC-over-RDMA Transports\", RFC 8167, DOI 10.17487/RFC8167, June 2017, <http://www.rfc-editor.org/info/rfc8167>.",
      "ja": "[RFC8167]レバー、C。、「RPC-over-RDMAトランスポートの双方向リモートプロシージャコール」、RFC 8167、DOI 10.17487 / RFC8167、2017年6月、<http://www.rfc-editor.org/info/rfc8167> 。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Changes from RFC 5666",
      "section_title": true,
      "ja": "付録A. RFC 5666からの変更点"
    },
    {
      "indent": 0,
      "text": "A.1. Changes to the Specification",
      "section_title": true,
      "ja": "A.1. 仕様の変更"
    },
    {
      "indent": 3,
      "text": "The following alterations have been made to the RPC-over-RDMA version 1 specification. The section numbers below refer to [RFC5666].",
      "ja": "RPC-over-RDMAバージョン1仕様には、次の変更が加えられています。以下のセクション番号は[RFC5666]を参照しています。"
    },
    {
      "indent": 3,
      "text": "o Section 2 has been expanded to introduce and explain key RPC [RFC5531], XDR [RFC4506], and RDMA [RFC5040] terminology. These terms are now used consistently throughout the specification.",
      "ja": "o セクション2は、主要なRPC [RFC5531]、XDR [RFC4506]、およびRDMA [RFC5040]の用語を紹介および説明するために拡張されました。これらの用語は、仕様全体で一貫して使用されるようになりました。"
    },
    {
      "indent": 3,
      "text": "o Section 3 has been reorganized and split into subsections to help readers locate specific requirements and definitions.",
      "ja": "o セクション3は再編成され、サブセクションに分割されて、読者が特定の要件と定義を見つけやすくなりました。"
    },
    {
      "indent": 3,
      "text": "o Sections 4 and 5 have been combined to improve the organization of this information.",
      "ja": "o セクション4と5は、この情報の構成を改善するために結合されました。"
    },
    {
      "indent": 3,
      "text": "o The optional Connection Configuration Protocol has never been implemented. The specification of CCP has been deleted from this specification.",
      "ja": "o オプションの接続構成プロトコルは実装されていません。 CCPの仕様はこの仕様から削除されました。"
    },
    {
      "indent": 3,
      "text": "o A section consolidating requirements for ULBs has been added.",
      "ja": "o ULBの要件を統合するセクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "o An XDR extraction mechanism is provided, along with full copyright, matching the approach used in [RFC5662].",
      "ja": "o [RFC5662]で使用されているアプローチと一致するXDR抽出メカニズムが完全な著作権とともに提供されています。"
    },
    {
      "indent": 3,
      "text": "o The \"Security Considerations\" section has been expanded to include a discussion of how RPC-over-RDMA security depends on features of the underlying RDMA transport.",
      "ja": "o 「セキュリティの考慮事項」セクションが拡張され、RPC-over-RDMAのセキュリティが、基になるRDMAトランスポートの機能にどのように依存するかについての説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "o A subsection describing the use of RPCSEC_GSS [RFC7861] with RPC-over-RDMA version 1 has been added.",
      "ja": "o RPC-over-RDMAバージョン1でのRPCSEC_GSS [RFC7861]の使用について説明するサブセクションが追加されました。"
    },
    {
      "indent": 0,
      "text": "A.2. Changes to the Protocol",
      "section_title": true,
      "ja": "A.2. プロトコルの変更"
    },
    {
      "indent": 3,
      "text": "Although the protocol described herein interoperates with existing implementations of [RFC5666], the following changes have been made relative to the protocol described in that document:",
      "ja": "ここで説明されているプロトコルは、[RFC5666]の既存の実装と相互運用できますが、そのドキュメントで説明されているプロトコルに関連して、次の変更が加えられています。"
    },
    {
      "indent": 3,
      "text": "o Support for the Read-Read transfer model has been removed. Read-Read is a slower transfer model than Read-Write. As a result, implementers have chosen not to support it. Removal of Read-Read simplifies explanatory text, and the RDMA_DONE procedure is no longer part of the protocol.",
      "ja": "o 読み取り-読み取り転送モデルのサポートが削除されました。 Read-Readは、Read-Writeよりも遅い転送モデルです。その結果、実装者はそれをサポートしないことを選択しました。 Read-Readを削除すると説明文が簡略化され、RDMA_DONEプロシージャはプロトコルの一部ではなくなりました。"
    },
    {
      "indent": 3,
      "text": "o The specification of RDMA_MSGP in [RFC5666] is not adequate, although some incomplete implementations exist. Even if an adequate specification were provided and an implementation were produced, benefit for protocols such as NFSv4.0 [RFC7530] is doubtful. Therefore, the RDMA_MSGP message type is no longer supported.",
      "ja": "o [RFC5666]のRDMA_MSGPの仕様は適切ではありませんが、不完全な実装がいくつか存在します。適切な仕様が提供され、実装が作成されたとしても、NFSv4.0 [RFC7530]などのプロトコルの利点は疑わしいものです。したがって、RDMA_MSGPメッセージタイプはサポートされなくなりました。"
    },
    {
      "indent": 3,
      "text": "o Technical issues with regard to handling RPC-over-RDMA header errors have been corrected.",
      "ja": "o RPC-over-RDMAヘッダーエラーの処理に関する技術的な問題が修正されました。"
    },
    {
      "indent": 3,
      "text": "o Specific requirements related to implicit XDR roundup and complex XDR data types have been added.",
      "ja": "o 暗黙的なXDRの切り上げと複雑なXDRデータ型に関連する特定の要件が追加されました。"
    },
    {
      "indent": 3,
      "text": "o Explicit guidance is provided related to sizing Write chunks, managing multiple chunks in the Write list, and handling unused Write chunks.",
      "ja": "o 書き込みチャンクのサイジング、書き込みリスト内の複数のチャンクの管理、および未使用の書き込みチャンクの処理に関連する明示的なガイダンスが提供されています。"
    },
    {
      "indent": 3,
      "text": "o Clear guidance about Send and Receive buffer sizes has been introduced. This enables better decisions about when a Reply chunk must be provided.",
      "ja": "o 送信および受信のバッファサイズに関する明確なガイダンスが導入されました。これにより、返信チャンクをいつ提供する必要があるかについてより適切な決定が可能になります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor gratefully acknowledges the work of Brent Callaghan and Tom Talpey on the original RPC-over-RDMA Version 1 specification [RFC5666].",
      "ja": "編集者は、元のRPC-over-RDMAバージョン1仕様[RFC5666]でのBrent CallaghanとTom Talpeyの作業に感謝します。"
    },
    {
      "indent": 3,
      "text": "Dave Noveck provided excellent review, constructive suggestions, and consistent navigational guidance throughout the process of drafting this document. Dave also contributed much of the organization and content of Section 7 and helped the authors understand the complexities of XDR extensibility.",
      "ja": "Dave Noveckは、このドキュメントの草案作成プロセス全体を通じて、優れたレビュー、建設的な提案、および一貫したナビゲーションガイダンスを提供しました。 Daveは、セクション7の組織とコンテンツの多くにも貢献し、XDR拡張性の複雑さを著者が理解するのに役立ちました。"
    },
    {
      "indent": 3,
      "text": "The comments and contributions of Karen Deitke, Dai Ngo, Chunli Zhang, Dominique Martinet, and Mahesh Siddheshwar are accepted with great thanks. The editor also wishes to thank Bill Baker, Greg Marsden, and Matt Benjamin for their support of this work.",
      "ja": "Karen Deitke、Dai Ngo、Chunli Zhang、Dominique Martinet、Mahesh Siddheshwarのコメントと寄稿は、大変感謝しています。編集者は、この作業をサポートしてくれたBill Baker、Greg Marsden、Matt Benjaminにも感謝します。"
    },
    {
      "indent": 3,
      "text": "The extract.sh shell script and formatting conventions were first described by the authors of the NFSv4.1 XDR specification [RFC5662].",
      "ja": "extract.shシェルスクリプトとフォーマット規則は、NFSv4.1 XDR仕様[RFC5662]の作成者によって最初に説明されました。"
    },
    {
      "indent": 3,
      "text": "Special thanks go to Transport Area Director Spencer Dawkins, NFSV4 Working Group Chair and Document Shepherd Spencer Shepler, and NFSV4 Working Group Secretary Thomas Haynes for their support.",
      "ja": "Transport Area Director Spencer Dawkins、NFSV4 Working Group Chair and Document Shepherd Spencer Shepler、およびNFSV4 Working Group Secretary Thomas Haynesのサポートに特に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Charles Lever (editor) Oracle Corporation 1015 Granger Avenue Ann Arbor, MI 48104 United States of America",
      "ja": "Charles Lever（編集者）Oracle Corporation 1015 Granger Avenueアナーバー、MI 48104アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 248 816 6463\nEmail: chuck.lever@oracle.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "William Allen Simpson Red Hat 1384 Fontaine Madison Heights, MI 48071 United States of America",
      "ja": "ウィリアムアレンシンプソンRed Hat 1384 Fontaine Madison Heights、MI 48071アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: william.allen.simpson@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Talpey Microsoft Corp. One Microsoft Way Redmond, WA 98052 United States of America",
      "ja": "Tom Talpey Microsoft Corp. One Microsoft Wayレドモンド、ワシントン州98052アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 704-9945\nEmail: ttalpey@microsoft.com",
      "raw": true,
      "ja": ""
    }
  ]
}