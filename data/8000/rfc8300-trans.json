{
  "title": {
    "text": "RFC 8300 - Network Service Header (NSH)",
    "ja": "RFC 8300 - ネットワークサービスヘッダー（NSH）"
  },
  "number": 8300,
  "created_at": "2020-08-23 17:53:09.874661+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     P. Quinn, Ed.\nRequest for Comments: 8300                                         Cisco\nCategory: Standards Track                                  U. Elzur, Ed.\nISSN: 2070-1721                                                    Intel\n                                                       C. Pignataro, Ed.\n                                                                   Cisco\n                                                            January 2018",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Network Service Header (NSH)",
      "ja": "ネットワークサービスヘッダー（NSH）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a Network Service Header (NSH) imposed on packets or frames to realize Service Function Paths (SFPs). The NSH also provides a mechanism for metadata exchange along the instantiated service paths. The NSH is the Service Function Chaining (SFC) encapsulation required to support the SFC architecture (defined in RFC 7665).",
      "ja": "このドキュメントでは、サービス機能パス（SFP）を実現するためにパケットまたはフレームに課されるネットワークサービスヘッダー（NSH）について説明します。 NSHは、インスタンス化されたサービスパスに沿ったメタデータ交換のメカニズムも提供します。 NSHは、SFCアーキテクチャ（RFC 7665で定義）をサポートするために必要なサービス機能チェーン（SFC）カプセル化です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8300.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8300で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Applicability ..............................................4\n   1.2. Requirements Language ......................................4\n   1.3. Definition of Terms ........................................4\n   1.4. Problem Space ..............................................6\n   1.5. NSH-Based Service Chaining .................................6\n2. Network Service Header ..........................................7\n   2.1. Network Service Header Format ..............................7\n   2.2. NSH Base Header ............................................8\n   2.3. Service Path Header .......................................11\n   2.4. NSH MD Type 1 .............................................12\n   2.5. NSH MD Type 2 .............................................13\n        2.5.1. Optional Variable-Length Metadata ..................13\n3. NSH Actions ....................................................15\n4. NSH Transport Encapsulation ....................................16\n5. Fragmentation Considerations ...................................17\n6. Service Path Forwarding with NSH ...............................18\n   6.1. SFFs and Overlay Selection ................................18\n   6.2. Mapping the NSH to Network Topology .......................21\n   6.3. Service Plane Visibility ..................................21\n   6.4. Service Graphs ............................................22\n7. Policy Enforcement with NSH ....................................22\n   7.1. NSH Metadata and Policy Enforcement .......................22\n   7.2. Updating/Augmenting Metadata ..............................24\n   7.3. Service Path Identifier and Metadata ......................25\n8. Security Considerations ........................................26\n   8.1. NSH Security Considerations from Operators' Environments ..27\n   8.2. NSH Security Considerations from the SFC Architecture .....28\n        8.2.1. Integrity ..........................................29\n        8.2.2. Confidentiality ....................................31\n9. IANA Considerations ............................................32\n   9.1. NSH Parameters ............................................32\n        9.1.1. NSH Base Header Bits ...............................32\n        9.1.2. NSH Version ........................................32\n        9.1.3. NSH MD Types .......................................33\n        9.1.4. NSH MD Class .......................................33\n        9.1.5. NSH IETF-Assigned Optional Variable-Length\n               Metadata Types .....................................34\n        9.1.6. NSH Next Protocol ..................................35\n10. NSH-Related Codepoints ........................................35\n   10.1. NSH Ethertype ............................................35\n11. References ....................................................36\nAcknowledgments ...................................................38\nContributors ......................................................39\nAuthors' Addresses ................................................40",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Service Functions are widely deployed and essential in many networks. These Service Functions provide a range of features such as security, WAN acceleration, and server load balancing. Service Functions may be instantiated at different points in the network infrastructure such as the WAN, data center, and so forth.",
      "ja": "サービス機能は広く展開されており、多くのネットワークで不可欠です。これらのサービス機能は、セキュリティ、WAN高速化、サーバーロードバランシングなどのさまざまな機能を提供します。サービス機能は、WAN、データセンターなどのネットワークインフラストラクチャのさまざまなポイントでインスタンス化できます。"
    },
    {
      "indent": 3,
      "text": "Prior to development of the SFC architecture [RFC7665] and the protocol specified in this document, current Service Function deployment models have been relatively static and bound to topology for insertion and policy selection. Furthermore, they do not adapt well to elastic service environments enabled by virtualization.",
      "ja": "SFCアーキテクチャ[RFC7665]とこのドキュメントで指定されているプロトコルの開発前は、現在のサービス機能展開モデルは比較的静的であり、挿入とポリシー選択のためにトポロジにバインドされていました。さらに、仮想化によって実現される柔軟なサービス環境にうまく適応しません。"
    },
    {
      "indent": 3,
      "text": "New data-center network and cloud architectures require more flexible Service Function deployment models. Additionally, the transition to virtual platforms demands an agile service insertion model that supports dynamic and elastic service delivery. Specifically, the following functions are necessary:",
      "ja": "新しいデータセンターネットワークとクラウドアーキテクチャには、より柔軟なサービス機能展開モデルが必要です。さらに、仮想プラットフォームへの移行には、動的で柔軟なサービス提供をサポートする俊敏なサービス挿入モデルが必要です。具体的には、以下の機能が必要です。"
    },
    {
      "indent": 3,
      "text": "1. The movement of Service Functions and application workloads in the network.",
      "ja": "1. ネットワーク内のサービス機能とアプリケーションワークロードの移動。"
    },
    {
      "indent": 3,
      "text": "2. The ability to easily bind service policy to granular information, such as per-subscriber state.",
      "ja": "2. サービスポリシーを加入者ごとの状態などの詳細情報に簡単にバインドする機能。"
    },
    {
      "indent": 3,
      "text": "3. The capability to steer traffic to the requisite Service Function(s).",
      "ja": "3. 必要なサービス機能にトラフィックを誘導する機能。"
    },
    {
      "indent": 3,
      "text": "This document, the Network Service Header (NSH) specification, defines a new data-plane protocol, which is an encapsulation for SFCs. The NSH is designed to encapsulate an original packet or frame and, in turn, be encapsulated by an outer transport encapsulation (which is used to deliver the NSH to NSH-aware network elements), as shown in Figure 1:",
      "ja": "このドキュメントは、ネットワークサービスヘッダー（NSH）仕様で、SFCのカプセル化である新しいデータプレーンプロトコルを定義しています。図1に示すように、NSHは元のパケットまたはフレームをカプセル化し、次に外部トランスポートカプセル化（NSHをNSH対応ネットワーク要素に配信するために使用される）によってカプセル化されるように設計されています。"
    },
    {
      "indent": 21,
      "text": "+------------------------------+\n|    Transport Encapsulation   |\n+------------------------------+\n| Network Service Header (NSH) |\n+------------------------------+\n|    Original Packet / Frame   |\n+------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 1: Network Service Header Encapsulation",
      "ja": "図1：ネットワークサービスヘッダーのカプセル化"
    },
    {
      "indent": 3,
      "text": "The NSH is composed of the following elements:",
      "ja": "NSHは次の要素で構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Service Function Path identification.",
      "ja": "1. サービス機能パスの識別。"
    },
    {
      "indent": 3,
      "text": "2. Indication of location within a Service Function Path.",
      "ja": "2. サービス機能パス内の場所の表示。"
    },
    {
      "indent": 3,
      "text": "3. Optional, per-packet metadata (fixed-length or variable).",
      "ja": "3. オプションのパケットごとのメタデータ（固定長または変数）。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] provides an overview of a service chaining architecture that clearly defines the roles of the various elements and the scope of a SFC encapsulation. Figure 3 of [RFC7665] depicts the SFC architectural components after classification. The NSH is the SFC encapsulation referenced in [RFC7665].",
      "ja": "[RFC7665]は、さまざまな要素の役割とSFCカプセル化のスコープを明確に定義するサービスチェーンアーキテクチャの概要を提供します。 [RFC7665]の図3は、分類後のSFCアーキテクチャコンポーネントを示しています。 NSHは、[RFC7665]で参照されているSFCカプセル化です。"
    },
    {
      "indent": 0,
      "text": "1.1. Applicability",
      "section_title": true,
      "ja": "1.1. 適用性"
    },
    {
      "indent": 3,
      "text": "The NSH is designed to be easy to implement across a range of devices, both physical and virtual, including hardware platforms.",
      "ja": "NSHは、ハードウェアプラットフォームを含む、物理デバイスと仮想デバイスの両方のデバイスに簡単に実装できるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The intended scope of the NSH is for use within a single provider's operational domain. This deployment scope is deliberately constrained, as explained also in [RFC7665], and limited to a single network administrative domain. In this context, a \"domain\" is a set of network entities within a single administration. For example, a network administrative domain can include a single data center, or an overlay domain using virtual connections and tunnels. A corollary is that a network administrative domain has a well-defined perimeter.",
      "ja": "NSHの意図された範囲は、単一のプロバイダーの運用ドメイン内で使用するためのものです。 [RFC7665]でも説明されているように、この展開スコープは意図的に制限されており、単一のネットワーク管理ドメインに制限されています。この文脈では、「ドメイン」は単一の管理内のネットワークエンティティのセットです。たとえば、ネットワーク管理ドメインには、単一のデータセンター、または仮想接続とトンネルを使用するオーバーレイドメインを含めることができます。結果として、ネットワーク管理ドメインには明確に定義された境界があります。"
    },
    {
      "indent": 3,
      "text": "An NSH-aware control plane is outside the scope of this document.",
      "ja": "NSH対応のコントロールプレーンは、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Language",
      "section_title": true,
      "ja": "1.2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Definition of Terms",
      "section_title": true,
      "ja": "1.3. 用語の定義"
    },
    {
      "indent": 3,
      "text": "Byte: All references to \"bytes\" in this document refer to 8-bit bytes, or octets.",
      "ja": "バイト：このドキュメントでの「バイト」へのすべての言及は、8ビットバイトまたはオクテットを指します。"
    },
    {
      "indent": 3,
      "text": "Classification: Defined in [RFC7665].",
      "ja": "分類：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Classifier: Defined in [RFC7665].",
      "ja": "分類子：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Metadata (MD): Defined in [RFC7665]. The metadata, or context information shared between Classifiers and SFs, and among SFs, is carried on the NSH's Context Headers. It allows summarizing a classification result in the packet itself, avoiding subsequent re-classifications. Examples of metadata include classification information used for policy enforcement and network context for forwarding after service delivery.",
      "ja": "メタデータ（MD）：[RFC7665]で定義されています。メタデータ、つまり分類子とSF間、およびSF間で共有されるコンテキスト情報は、NSHのコンテキストヘッダーで伝達されます。パケット自体の分類結果を要約し、その後の再分類を回避できます。メタデータの例には、ポリシー実施に使用される分類情報や、サービス配信後の転送のネットワークコンテキストが含まれます。"
    },
    {
      "indent": 3,
      "text": "Network Locator: Data-plane address, typically IPv4 or IPv6, used to send and receive network traffic.",
      "ja": "ネットワークロケータ：ネットワークトラフィックの送受信に使用されるデータプレーンアドレス（通常はIPv4またはIPv6）。"
    },
    {
      "indent": 3,
      "text": "Network Node/Element: Device that forwards packets or frames based on an outer header (i.e., transport encapsulation) information.",
      "ja": "ネットワークノード/要素：外部ヘッダー（トランスポートカプセル化）情報に基づいてパケットまたはフレームを転送するデバイス。"
    },
    {
      "indent": 3,
      "text": "Network Overlay: Logical network built on top of an existing network (the underlay). Packets are encapsulated or tunneled to create the overlay network topology.",
      "ja": "ネットワークオーバーレイ：既存のネットワーク（アンダーレイ）の上に構築された論理ネットワーク。パケットはカプセル化またはトンネル化されて、オーバーレイネットワークトポロジが作成されます。"
    },
    {
      "indent": 3,
      "text": "NSH-aware: NSH-aware means SFC-encapsulation-aware, where the NSH provides the SFC encapsulation. This specification uses NSH-aware as a more specific term from the more generic term \"SFC-aware\" [RFC7665].",
      "ja": "NSH対応：NSH対応はSFCカプセル化対応を意味し、NSHはSFCカプセル化を提供します。この仕様では、より一般的な用語「SFC対応」[RFC7665]のより具体的な用語としてNSH対応を使用しています。"
    },
    {
      "indent": 3,
      "text": "Service Classifier: Logical entity providing classification function. Since they are logical, Classifiers may be co-resident with SFC elements such as SFs or SFFs. Service Classifiers perform classification and impose the NSH. The initial Classifier imposes the initial NSH and sends the NSH packet to the first SFF in the path. Non-initial (i.e., subsequent) classification can occur as needed and can alter, or create a new service path.",
      "ja": "サービス分類子：分類機能を提供する論理エンティティ。分類子は論理的であるため、SFやSFFなどのSFC要素と共存できます。サービス分類子は分類を実行し、NSHを課します。最初の分類子は最初のNSHを課し、パスの最初のSFFにNSHパケットを送信します。最初ではない（つまり、後続の）分類は、必要に応じて発生し、新しいサービスパスを変更または作成できます。"
    },
    {
      "indent": 3,
      "text": "Service Function (SF): Defined in [RFC7665].",
      "ja": "サービス機能（SF）：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Service Function Chain (SFC): Defined in [RFC7665].",
      "ja": "サービス機能チェーン（SFC）：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Service Function Forwarder (SFF): Defined in [RFC7665].",
      "ja": "Service Function Forwarder（SFF）：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Service Function Path (SFP): Defined in [RFC7665].",
      "ja": "サービス機能パス（SFP）：[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Service Plane: The collection of SFFs and associated SFs creates a service-plane overlay in which all SFs and SFC Proxies reside [RFC7665].",
      "ja": "サービスプレーン：SFFと関連するSFのコレクションは、すべてのSFとSFCプロキシが存在するサービスプレーンオーバーレイを作成します[RFC7665]。"
    },
    {
      "indent": 3,
      "text": "SFC Proxy: Defined in [RFC7665].",
      "ja": "SFCプロキシ：[RFC7665]で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.4. Problem Space",
      "section_title": true,
      "ja": "1.4. 問題スペース"
    },
    {
      "indent": 3,
      "text": "The NSH addresses several limitations associated with Service Function deployments. [RFC7498] provides a comprehensive review of those issues.",
      "ja": "NSHは、Service Functionデプロイメントに関連するいくつかの制限に対処します。 [RFC7498]は、これらの問題の包括的なレビューを提供します。"
    },
    {
      "indent": 0,
      "text": "1.5. NSH-Based Service Chaining",
      "section_title": true,
      "ja": "1.5. NSHベースのサービスチェーン"
    },
    {
      "indent": 3,
      "text": "The NSH creates a dedicated service plane; more specifically, the NSH enables:",
      "ja": "NSHは専用のサービスプレーンを作成します。より具体的には、NSHは以下を可能にします。"
    },
    {
      "indent": 3,
      "text": "1. Topological Independence: Service forwarding occurs within the service plane, so the underlying network topology does not require modification. The NSH provides an identifier used to select the network overlay for network forwarding.",
      "ja": "1. トポロジの独立性：サービス転送はサービスプレーン内で行われるため、基盤となるネットワークトポロジを変更する必要はありません。 NSHは、ネットワーク転送用のネットワークオーバーレイを選択するために使用される識別子を提供します。"
    },
    {
      "indent": 3,
      "text": "2. Service Chaining: The NSH enables service chaining per [RFC7665]. The NSH contains path identification information needed to realize a service path. Furthermore, the NSH provides the ability to monitor and troubleshoot a service chain, end-to-end via service-specific Operations, Administration, and Maintenance (OAM) messages. The NSH fields can be used by administrators (for example, via a traffic analyzer) to verify the path specifics (e.g., accounting, ensuring correct chaining, providing reports, etc.) of packets being forwarded along a service path.",
      "ja": "2. サービス連鎖：NSHは[RFC7665]に従ってサービス連鎖を可能にします。 NSHには、サービスパスを実現するために必要なパス識別情報が含まれています。さらに、NSHは、サービス固有の運用、管理、および保守（OAM）メッセージを介して、サービスチェーンをエンドツーエンドで監視およびトラブルシューティングする機能を提供します。管理者は、NSHフィールドを使用して（たとえば、トラフィックアナライザーを介して）、サービスパスに沿って転送されるパケットのパスの詳細（アカウンティング、正しいチェーンの確認、レポートの提供など）を確認できます。"
    },
    {
      "indent": 3,
      "text": "3. The NSH provides a mechanism to carry shared metadata between participating entities and Service Functions. The semantics of the shared metadata are communicated via a control plane (which is outside the scope of this document) to participating nodes. Section 3.3 of [SFC-CONTROL-PLANE] provides an example of this. Examples of metadata include classification information used for policy enforcement and network context for forwarding post service delivery. Sharing the metadata allows Service Functions to share initial and intermediate classification results with downstream Service Functions saving re-classification, where enough information was enclosed.",
      "ja": "3. NSHは、参加エンティティとサービス機能の間で共有メタデータを伝送するメカニズムを提供します。共有メタデータのセマンティクスは、コントロールプレーン（このドキュメントの範囲外）を介して参加ノードに伝達されます。 [SFC-CONTROL-PLANE]のセクション3.3は、この例を示しています。メタデータの例には、ポリシーの適用に使用される分類情報や、ポストサービス配信を転送するためのネットワークコンテキストが含まれます。メタデータを共有することで、Service Functionsは初期および中間の分類結果を下流のService Functionsと共有でき、十分な情報が含まれた再分類を保存できます。"
    },
    {
      "indent": 3,
      "text": "4. The NSH offers a common and standards-based header for service chaining to all network and service nodes.",
      "ja": "4. NSHは、すべてのネットワークおよびサービスノードへのサービスチェーンのための共通の標準ベースのヘッダーを提供します。"
    },
    {
      "indent": 0,
      "text": " 5. Transport Encapsulation Agnostic: The NSH is transport encapsulation independent: meaning it can be transported by a variety of encapsulation protocols. An appropriate (for a given deployment) encapsulation protocol can be used to carry NSH-encapsulated traffic. This transport encapsulation may form an overlay network; and if an existing overlay topology provides the required service path connectivity, that existing overlay may be used.",
      "ja": "5.トランスポートカプセル化に依存しない：NSHはトランスポートカプセル化に依存しません。つまり、さまざまなカプセル化プロトコルによってトランスポートできます。 NSHでカプセル化されたトラフィックを伝送するために、適切な（特定のデプロイメントの）カプセル化プロトコルを使用できます。このトランスポートカプセル化は、オーバーレイネットワークを形成する場合があります。また、既存のオーバーレイトポロジが必要なサービスパス接続を提供する場合は、その既存のオーバーレイを使用できます。"
    },
    {
      "indent": 0,
      "text": "2. Network Service Header",
      "section_title": true,
      "ja": "2. ネットワークサービスヘッダー"
    },
    {
      "indent": 3,
      "text": "An NSH is imposed on the original packet/frame. This NSH contains service path information and, optionally, metadata that are added to a packet or frame and used to create a service plane. Subsequently, an outer transport encapsulation is imposed on the NSH, which is used for network forwarding.",
      "ja": "NSHは元のパケット/フレームに課されます。このNSHには、サービスパス情報と、オプションで、パケットまたはフレームに追加され、サービスプレーンの作成に使用されるメタデータが含まれています。続いて、外部転送カプセル化がNSHに課され、ネットワーク転送に使用されます。"
    },
    {
      "indent": 3,
      "text": "A Service Classifier adds the NSH. The NSH is removed by the last SFF in the service chain or by an SF that consumes the packet.",
      "ja": "サービス分類子がNSHを追加します。 NSHは、サービスチェーンの最後のSFF、またはパケットを消費するSFによって削除されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Network Service Header Format",
      "section_title": true,
      "ja": "2.1. ネットワークサービスヘッダーの形式"
    },
    {
      "indent": 3,
      "text": "The NSH is composed of a 4-byte Base Header, a 4-byte Service Path Header, and optional Context Headers, as shown in Figure 2.",
      "ja": "図2に示すように、NSHは4バイトのベースヘッダー、4バイトのサービスパスヘッダー、およびオプションのコンテキストヘッダーで構成されています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Base Header                                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Service Path Header                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                Context Header(s)                              ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 2: Network Service Header",
      "ja": "図2：ネットワークサービスヘッダー"
    },
    {
      "indent": 3,
      "text": "Base Header: Provides information about the service header and the payload protocol.",
      "ja": "ベースヘッダー：サービスヘッダーとペイロードプロトコルに関する情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Service Path Header: Provides path identification and location within a service path.",
      "ja": "サービスパスヘッダー：サービスパス内のパスの識別と場所を提供します。"
    },
    {
      "indent": 3,
      "text": "Context Header: Carries metadata (i.e., context data) along a service path.",
      "ja": "コンテキストヘッダー：サービスパスに沿ってメタデータ（つまり、コンテキストデータ）を運びます。"
    },
    {
      "indent": 0,
      "text": "2.2. NSH Base Header",
      "section_title": true,
      "ja": "2.2. NSHベースヘッダー"
    },
    {
      "indent": 3,
      "text": "Figure 3 depicts the NSH Base Header:",
      "ja": "図3は、NSHベースヘッダーを示しています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 3: NSH Base Header",
      "ja": "図3：NSHベースヘッダー"
    },
    {
      "indent": 3,
      "text": "The field descriptions are as follows:",
      "ja": "フィールドの説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Version: The Version field is used to ensure backward compatibility going forward with future NSH specification updates. It MUST be set to 0x0 by the sender, in this first revision of the NSH. If a packet presumed to carry an NSH header is received at an SFF, and the SFF does not understand the version of the protocol as indicated in the base header, the packet MUST be discarded, and the event SHOULD be logged. Given the widespread implementation of existing hardware that uses the first nibble after an MPLS label stack for Equal-Cost Multipath (ECMP) decision processing, this document reserves version 01b. This value MUST NOT be used in future versions of the protocol. Please see [RFC7325] for further discussion of MPLS-related forwarding requirements.",
      "ja": "バージョン：バージョンフィールドは、将来のNSH仕様の更新に伴う下位互換性を確保するために使用されます。 NSHのこの最初のリビジョンでは、送信者が0x0に設定する必要があります。 NSHヘッダーを運ぶと推定されるパケットがSFFで受信され、SFFがベースヘッダーに示されているプロトコルのバージョンを理解できない場合、パケットは破棄されなければならず、イベントがログに記録されるべきです（SHOULD）。 Equal-Cost Multipath（ECMP）決定処理のMPLSラベルスタックの後に最初のニブルを使用する既存のハードウェアの広範な実装を考慮して、このドキュメントではバージョン01bを予約しています。この値は、プロトコルの将来のバージョンで使用してはなりません（MUST NOT）。 MPLS関連の転送要件の詳細については、[RFC7325]を参照してください。"
    },
    {
      "indent": 3,
      "text": "O bit: Setting this bit indicates an OAM packet (see [RFC6291]). The actual format and processing of SFC OAM packets is outside the scope of this specification (for example, see [SFC-OAM-FRAMEWORK] for one approach).",
      "ja": "Oビット：このビットを設定すると、OAMパケットを示します（[RFC6291]を参照）。 SFC OAMパケットの実際の形式と処理は、この仕様の範囲外です（たとえば、1つのアプローチについては、[SFC-OAM-FRAMEWORK]を参照してください）。"
    },
    {
      "indent": 6,
      "text": "The O bit MUST be set for OAM packets and MUST NOT be set for non-OAM packets. The O bit MUST NOT be modified along the SFP.",
      "ja": "OビットはOAMパケットに設定する必要があり、非OAMパケットに設定してはなりません（MUST NOT）。 Oビットは、SFPに沿って変更してはなりません。"
    },
    {
      "indent": 6,
      "text": "SF/SFF/SFC Proxy/Classifier implementations that do not support SFC OAM procedures SHOULD discard packets with O bit set, but MAY support a configurable parameter to enable forwarding received SFC OAM packets unmodified to the next element in the chain. Forwarding OAM packets unmodified by SFC elements that do not support SFC OAM procedures may be acceptable for a subset of OAM functions, but it can result in unexpected outcomes for others; thus, it is recommended to analyze the impact of forwarding an OAM packet for all OAM functions prior to enabling this behavior. The configurable parameter MUST be disabled by default.",
      "ja": "SFC OAMプロシージャをサポートしないSF / SFF / SFCプロキシ/分類子の実装は、Oビットが設定されたパケットを破棄する必要があります（SHOULD）が、受信したSFC OAMパケットを変更せずにチェーン内の次の要素に転送できるように構成可能なパラメーターをサポートする場合があります（MAY）。 SFC OAMプロシージャをサポートしないSFC要素によって変更されていないOAMパケットの転送は、OAM機能のサブセットでは受け入れられる可能性がありますが、他の予期しない結果になる可能性があります。したがって、この動作を有効にする前に、すべてのOAM機能のOAMパケットを転送する影響を分析することをお勧めします。構成可能パラメーターは、デフォルトで無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "TTL: Indicates the maximum SFF hops for an SFP. This field is used for service-plane loop detection. The initial TTL value SHOULD be configurable via the control plane; the configured initial value can be specific to one or more SFPs. If no initial value is explicitly provided, the default initial TTL value of 63 MUST be used. Each SFF involved in forwarding an NSH packet MUST decrement the TTL value by 1 prior to NSH forwarding lookup. Decrementing by 1 from an incoming value of 0 shall result in a TTL value of 63. The packet MUST NOT be forwarded if TTL is, after decrement, 0.",
      "ja": "TTL：SFPの最大SFFホップを示します。このフィールドは、サービスプレーンループの検出に使用されます。初期TTL値は、コントロールプレーンを介して構成可能である必要があります（SHOULD）。設定された初期値は、1つ以上のSFPに固有である場合があります。初期値が明示的に指定されていない場合は、デフォルトの初期TTL値63を使用する必要があります。 NSHパケットの転送に関与する各SFFは、NSH転送ルックアップの前に、TTL値を1ずつ減らす必要があります。着信値0から1ずつ減少すると、TTL値は63になります。TTLが減少した後、0の場合、パケットを転送してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "This TTL field is the primary loop-prevention mechanism. This TTL mechanism represents a robust complement to the Service Index (see Section 2.3), as the TTL is decremented by each SFF. The handling of an incoming 0 TTL allows for better, although not perfect, interoperation with pre-standard implementations that do not support this TTL field.",
      "ja": "このTTLフィールドは、主要なループ防止メカニズムです。このTTLメカニズムは、TTLが各SFFによって減分されるため、サービスインデックス（セクション2.3を参照）を強力に補完します。着信0 TTLの処理により、完全ではありませんが、このTTLフィールドをサポートしない先行標準実装との相互運用が向上します。"
    },
    {
      "indent": 3,
      "text": "Length: The total length, in 4-byte words, of the NSH including the Base Header, the Service Path Header, the Fixed-Length Context Header, or Variable-Length Context Header(s). The length MUST be 0x6 for MD Type 0x1, and it MUST be 0x2 or greater for MD Type 0x2. The length of the Network Service Header MUST be an integer multiple of 4 bytes; thus, variable-length metadata is always padded out to a multiple of 4 bytes.",
      "ja": "長さ：ベースヘッダー、サービスパスヘッダー、固定長コンテキストヘッダー、または可変長コンテキストヘッダーを含むNSHの4バイトワードでの全長。長さは、MDタイプ0x1の場合は0x6でなければならず、MDタイプ0x2の場合は0x2以上でなければなりません。ネットワークサービスヘッダーの長さは、4バイトの整数倍でなければなりません。したがって、可変長メタデータは常に4バイトの倍数になるように埋め込まれます。"
    },
    {
      "indent": 3,
      "text": "Unassigned bits: All other flag fields, marked U, are unassigned and available for future use; see Section 9.1.1. Unassigned bits MUST be set to zero upon origination, and they MUST be ignored and preserved unmodified by other NSH supporting elements. At reception, all elements MUST NOT modify their actions based on these unknown bits.",
      "ja": "割り当てられていないビット：Uとマークされている他のすべてのフラグフィールドは割り当てられておらず、将来の使用に利用できます。セクション9.1.1を参照してください。割り当てられていないビットは、発信時にゼロに設定する必要があり、他のNSHサポートエレメントによって変更されずに無視および保存される必要があります。受信時には、すべての要素がこれらの不明なビットに基づいてアクションを変更してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Metadata (MD) Type: Indicates the format of the NSH beyond the mandatory NSH Base Header and the Service Path Header. MD Type defines the format of the metadata being carried. Please see the IANA Considerations in Section 9.1.3.",
      "ja": "メタデータ（MD）タイプ：必須のNSHベースヘッダーとサービスパスヘッダー以外のNSHの形式を示します。 MDタイプは、伝送されるメタデータのフォーマットを定義します。セクション9.1.3のIANAに関する考慮事項を参照してください。"
    },
    {
      "indent": 6,
      "text": "This document specifies the following four MD Type values:",
      "ja": "このドキュメントでは、次の4つのMDタイプ値を指定しています。"
    },
    {
      "indent": 6,
      "text": "0x0: This is a reserved value. Implementations SHOULD silently discard packets with MD Type 0x0.",
      "ja": "0x0：これは予約済みの値です。実装は、MDタイプ0x0のパケットをサイレントに破棄する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "0x1: This indicates that the format of the header includes a Fixed-Length Context Header (see Figure 5 below).",
      "ja": "0x1：これは、ヘッダーのフォーマットに固定長のコンテキストヘッダーが含まれていることを示します（下の図5を参照）。"
    },
    {
      "indent": 6,
      "text": "0x2: This does not mandate any headers beyond the Base Header and Service Path Header, but may contain optional Variable-Length Context Header(s). With MD Type 0x2, a length of 0x2 implies there are no Context Headers. The semantics of the Variable-Length Context Header(s) are not defined in this document. The format of the optional Variable-Length Context Headers is provided in Section 2.5.1.",
      "ja": "0x2：これは、ベースヘッダーとサービスパスヘッダー以外のヘッダーを必須にしませんが、オプションの可変長コンテキストヘッダーを含めることができます。 MDタイプ0x2では、長さが0x2の場合、コンテキストヘッダーがないことを意味します。可変長コンテキストヘッダーのセマンティクスは、このドキュメントでは定義されていません。オプションの可変長コンテキストヘッダーの形式については、セクション2.5.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "0xF: This value is reserved for experimentation and testing, as per [RFC3692]. Implementations not explicitly configured to be part of an experiment SHOULD silently discard packets with MD Type 0xF.",
      "ja": "0xF：この値は、[RFC3692]のように、実験とテストのために予約されています。実験の一部として明示的に構成されていない実装は、MDタイプ0xFのパケットをサイレントに破棄する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "The format of the Base Header and the Service Path Header is invariant and not affected by MD Type.",
      "ja": "ベースヘッダーとサービスパスヘッダーの形式は不変であり、MDタイプの影響を受けません。"
    },
    {
      "indent": 6,
      "text": "The NSH MD Type 1 and MD Type 2 are described in detail in Sections 2.4 and 2.5, respectively. NSH implementations MUST support MD Types 0x1 and 0x2 (where the length is 0x2). NSH implementations SHOULD support MD Type 0x2 with length greater than 0x2. Devices that do not support MD Type 0x2 with a length greater than 0x2 MUST ignore any optional Context Headers and process the packet without them; the Base Header Length field can be used to determine the original payload offset if access to the original packet/frame is required. This specification does not disallow the MD Type value from changing along an SFP; however, the specification of the necessary mechanism to allow the MD Type to change along an SFP are outside the scope of this document and would need to be defined for that functionality to be available. Packets with MD Type values not supported by an implementation MUST be silently dropped.",
      "ja": "NSH MD Type 1とMD Type 2については、それぞれセクション2.4と2.5で詳しく説明しています。 NSH実装は、MDタイプ0x1および0x2（長さが0x2）をサポートする必要があります。 NSH実装は、長さが0x2より大きいMDタイプ0x2をサポートする必要があります（SHOULD）。 0x2を超える長さのMD Type 0x2をサポートしないデバイスは、オプションのコンテキストヘッダーを無視し、それらなしでパケットを処理する必要があります。元のパケット/フレームへのアクセスが必要な場合、ベースヘッダー長フィールドを使用して、元のペイロードオフセットを決定できます。この仕様では、MDタイプの値がSFPに沿って変化することを禁止していません。ただし、MDタイプをSFPに沿って変更できるようにするために必要なメカニズムの仕様は、このドキュメントの範囲外であり、その機能を使用できるように定義する必要があります。実装でサポートされていないMDタイプ値を持つパケットは、黙って破棄されなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Next Protocol: Indicates the protocol type of the encapsulated data. The NSH does not alter the inner payload, and the semantics on the inner protocol remain unchanged due to NSH SFC. Please see the IANA Considerations in Section 9.1.6.",
      "ja": "次のプロトコル：カプセル化されたデータのプロトコルタイプを示します。 NSHは内部ペイロードを変更しません。NSHSFCにより、内部プロトコルのセマンティクスは変更されません。セクション9.1.6のIANAに関する考慮事項を参照してください。"
    },
    {
      "indent": 6,
      "text": "This document defines the following Next Protocol values:",
      "ja": "このドキュメントでは、次のNext Protocol値を定義しています。"
    },
    {
      "indent": 0,
      "text": " 0x1: IPv4 0x2: IPv6 0x3: Ethernet 0x4: NSH 0x5: MPLS 0xFE: Experiment 1 0xFF: Experiment 2 The functionality of hierarchical NSH using a Next Protocol value of 0x4 (NSH) is outside the scope of this specification. Packets with Next Protocol values not supported SHOULD be silently dropped by default, although an implementation MAY provide a configuration parameter to forward them. Additionally, an implementation not explicitly configured for a specific experiment [RFC3692] SHOULD silently drop packets with Next Protocol values 0xFE and 0xFF.",
      "ja": "0x1：IPv4 0x2：IPv6 0x3：イーサネット0x4：NSH 0x5：MPLS 0xFE：実験1 0xFF：実験2 0x4（NSH）の次のプロトコル値を使用する階層型NSHの機能は、この仕様の範囲外です。サポートされていない次のプロトコル値を持つパケットは、デフォルトでは通知なしで破棄されるべきです（SHOULD）が、実装はそれらを転送するための構成パラメータを提供する場合があります。さらに、特定の実験用に明示的に構成されていない実装[RFC3692]は、次のプロトコル値0xFEおよび0xFFのパケットをサイレントにドロップする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.3. Service Path Header",
      "section_title": true,
      "ja": "2.3. サービスパスヘッダー"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the format of the Service Path Header:",
      "ja": "図4は、サービスパスヘッダーのフォーマットを示しています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier (SPI)        | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Service Path Identifier (SPI): 24 bits Service Index (SI): 8 bits",
      "ja": "サービスパス識別子（SPI）：24ビットサービスインデックス（SI）：8ビット"
    },
    {
      "indent": 21,
      "text": "Figure 4: NSH Service Path Header",
      "ja": "図4：NSHサービスパスヘッダー"
    },
    {
      "indent": 3,
      "text": "The meaning of these fields is as follows:",
      "ja": "これらのフィールドの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Service Path Identifier (SPI): Uniquely identifies a Service Function Path (SFP). Participating nodes MUST use this identifier for SFP selection. The initial Classifier MUST set the appropriate SPI for a given classification result.",
      "ja": "サービスパス識別子（SPI）：サービス機能パス（SFP）を一意に識別します。参加ノードは、SFPの選択にこの識別子を使用する必要があります。最初の分類子は、特定の分類結果に適切なSPIを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Service Index (SI): Provides location within the SFP. The initial Classifier for a given SFP SHOULD set the SI to 255; however, the control plane MAY configure the initial value of the SI as appropriate (i.e., taking into account the length of the SFP). The Service Index MUST be decremented by a value of 1 by Service Functions or by SFC Proxy nodes after performing required services; the new decremented SI value MUST be used in the egress packet's NSH. The initial Classifier MUST send the packet to the first SFF in the identified SFP for forwarding along an SFP. If re-classification occurs, and that re-classification results in a new SPI, the (re-)Classifier is, in effect, the initial Classifier for the resultant SPI.",
      "ja": "サービスインデックス（SI）：SFP内の場所を提供します。特定のSFPの初期分類子は、SIを255に設定する必要があります（SHOULD）。ただし、コントロールプレーンは、SIの初期値を適切に構成できます（つまり、SFPの長さを考慮に入れます）。必要なサービスを実行した後、サービス関数またはSFCプロキシノードによって、サービスインデックスの値を1ずつ減らす必要があります。新しいデクリメントされたSI値は、出力パケットのNSHで使用する必要があります。最初の分類子は、SFPに沿って転送するために、識別されたSFPの最初のSFFにパケットを送信する必要があります。再分類が発生し、その再分類の結果が新しいSPIになる場合、（再）分類子は事実上、結果のSPIの初期分類子になります。"
    },
    {
      "indent": 0,
      "text": " The SI is used in conjunction with the Service Path Identifier for SFP selection and for determining the next SFF/SF in the path. The SI is also valuable when troubleshooting or reporting service paths. While the TTL provides the primary SFF-based loop prevention for this mechanism, SI decrement by SF serves as a limited loop-prevention mechanism. NSH packets, as described above, are discarded when an SFF decrements the TTL to 0. In addition, an SFF that is not the terminal SFF for an SFP will discard any NSH packet with an SI of 0, as there will be no valid next SF information.",
      "ja": "SIは、SFPの選択およびパス内の次のSFF / SFの決定のために、サービスパス識別子と組み合わせて使用​​されます。 SIは、サービスパスをトラブルシューティングまたはレポートするときにも役立ちます。 TTLはこのメカニズムにSFFベースの主要なループ防止を提供しますが、SFによるSIの減少は、制限されたループ防止メカニズムとして機能します。上記のNSHパケットは、SFFがTTLを0にデクリメントすると破棄されます。さらに、SFPの端末SFFではないSFFは、SIが0のNSHパケットを破棄します。 SF情報。"
    },
    {
      "indent": 0,
      "text": "2.4. NSH MD Type 1",
      "section_title": true,
      "ja": "2.4. NSH MDタイプ1"
    },
    {
      "indent": 3,
      "text": "When the Base Header specifies MD Type 0x1, a Fixed-Length Context Header (16-bytes) MUST be present immediately following the Service Path Header, as per Figure 5. The value of a Fixed-Length Context Header that carries no metadata MUST be set to zero.",
      "ja": "ベースヘッダーがMDタイプ0x1を指定する場合、図5のように、固定長コンテキストヘッダー（16バイト）がサービスパスヘッダーの直後に存在する必要があります。メタデータを持たない固定長コンテキストヘッダーの値は、ゼロに設定します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier              | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Fixed-Length Context Header                   |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 5: NSH MD Type 0x1",
      "ja": "図5：NSH MDタイプ0x1"
    },
    {
      "indent": 3,
      "text": "This specification does not make any assumptions about the content of the 16-byte Context Header that must be present when the MD Type field is set to 1, and it does not describe the structure or meaning of the included metadata.",
      "ja": "この仕様では、MDタイプフィールドが1に設定されている場合に存在する必要がある16バイトのコンテキストヘッダーの内容については何も想定していません。また、含まれているメタデータの構造や意味については説明していません。"
    },
    {
      "indent": 3,
      "text": "An SFC-aware SF or SFC Proxy needs to receive the data structure and semantics first in order to process the data placed in the mandatory context field. The data structure and semantics include both the allocation schema and order as well as the meaning of the included data. How an SFC-aware SF or SFC Proxy gets the data structure and semantics is outside the scope of this specification.",
      "ja": "SFC対応のSFまたはSFCプロキシは、必須コンテキストフィールドに配置されたデータを処理するために、最初にデータ構造とセマンティクスを受信する必要があります。データ構造とセマンティクスには、割り当てスキーマと順序、および含まれるデータの意味の両方が含まれます。 SFC対応のSFまたはSFCプロキシがデータ構造とセマンティクスを取得する方法は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "An SF or SFC Proxy that does not know the format or semantics of the Context Header for an NSH with MD Type 1 MUST discard any packet with such an NSH (i.e., MUST NOT ignore the metadata that it cannot process), and MUST log the event at least once per the SPI for which the event occurs (subject to thresholding).",
      "ja": "MDタイプ1のNSHのコンテキストヘッダーの形式またはセマンティクスを認識しないSFまたはSFCプロキシは、そのようなNSHを持つパケットを破棄しなければならず（つまり、処理できないメタデータを無視してはならない）、イベントが発生するSPIごとに少なくとも1回イベント（しきい値処理の対象）。"
    },
    {
      "indent": 3,
      "text": "[NSH-DC-ALLOCATION] and [NSH-BROADBAND-ALLOCATION] provide specific examples of how metadata can be allocated.",
      "ja": "[NSH-DC-ALLOCATION]と[NSH-BROADBAND-ALLOCATION]は、メタデータの割り当て方法の具体例を示しています。"
    },
    {
      "indent": 0,
      "text": "2.5. NSH MD Type 2",
      "section_title": true,
      "ja": "2.5. NSH MDタイプ2"
    },
    {
      "indent": 3,
      "text": "When the Base Header specifies MD Type 0x2, zero or more Variable-Length Context Headers MAY be added, immediately following the Service Path Header (see Figure 6). Therefore, Length = 0x2, indicates that only the Base Header and Service Path Header are present (and in that order). The optional Variable-Length Context Headers MUST be of an integer number of 4-bytes. The Base Header Length field MUST be used to determine the offset to locate the original packet or frame for SFC nodes that require access to that information.",
      "ja": "ベースヘッダーでMDタイプ0x2が指定されている場合、サービスパスヘッダーの直後に0個以上の可変長コンテキストヘッダーを追加できます（図6を参照）。したがって、長さ= 0x2は、ベースヘッダーとサービスパスヘッダーのみが（この順序で）存在することを示します。オプションの可変長コンテキストヘッダーは、4バイトの整数でなければなりません。 Base Header Lengthフィールドは、その情報へのアクセスを必要とするSFCノードの元のパケットまたはフレームを見つけるためのオフセットを決定するために使用する必要があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier              | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~              Variable-Length Context Headers  (opt.)          ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 6: NSH MD Type 0x2",
      "ja": "図6：NSH MDタイプ0x2"
    },
    {
      "indent": 0,
      "text": "2.5.1. Optional Variable-Length Metadata",
      "section_title": true,
      "ja": "2.5.1. オプションの可変長メタデータ"
    },
    {
      "indent": 3,
      "text": "The format of the optional Variable-Length Context Headers, is as depicted in Figure 7.",
      "ja": "オプションの可変長コンテキストヘッダーの形式は、図7に示すとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Metadata Class       |      Type     |U|    Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Variable-Length Metadata                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 7: Variable-Length Context Headers",
      "ja": "図7：可変長のコンテキストヘッダー"
    },
    {
      "indent": 3,
      "text": "Metadata Class (MD Class): Defines the scope of the Type field to provide a hierarchical namespace. Section 9.1.4 defines how the MD Class values can be allocated to standards bodies, vendors, and others.",
      "ja": "メタデータクラス（MDクラス）：Typeフィールドのスコープを定義して、階層的な名前空間を提供します。セクション9.1.4は、MDクラスの値を標準化団体、ベンダー、その他に割り当てる方法を定義しています。"
    },
    {
      "indent": 3,
      "text": "Type: Indicates the explicit type of metadata being carried. The definition of the Type is the responsibility of the MD Class owner.",
      "ja": "タイプ：伝達されるメタデータの明示的なタイプを示します。タイプの定義は、MDクラスの所有者の責任です。"
    },
    {
      "indent": 3,
      "text": "Unassigned bit: One unassigned bit is available for future use. This bit MUST NOT be set, and it MUST be ignored on receipt.",
      "ja": "未割り当てビット：1つの未割り当てビットは将来の使用に使用できます。このビットは設定してはならず（MUST NOT）、受信時に無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Length: Indicates the length of the variable-length metadata, in bytes. In case the metadata length is not an integer number of 4-byte words, the sender MUST add pad bytes immediately following the last metadata byte to extend the metadata to an integer number of 4-byte words. The receiver MUST round the Length field up to the nearest 4-byte-word boundary, to locate and process the next field in the packet. The receiver MUST access only those bytes in the metadata indicated by the Length field (i.e., actual number of bytes) and MUST ignore the remaining bytes up to the nearest 4-byte-word boundary. The length may be 0 or greater.",
      "ja": "長さ：可変長メタデータの長さをバイト単位で示します。メタデータの長さが4バイトワードの整数でない場合、送信者は最後のメタデータバイトの直後にパッドバイトを追加して、メタデータを整数の4バイトワードに拡張する必要があります。レシーバーは、パケット内の次のフィールドを見つけて処理するために、長さフィールドを最も近い4バイトワード境界に切り上げる必要があります。受信者は、長さフィールド（つまり、実際のバイト数）で示されるメタデータ内のバイトのみにアクセスしなければならず、最も近い4バイトのワード境界までの残りのバイトを無視しなければなりません（MUST）。長さは0以上にすることができます。"
    },
    {
      "indent": 6,
      "text": "A value of 0 denotes a Context Header without a Variable-Length Metadata field.",
      "ja": "値0は、可変長メタデータフィールドのないコンテキストヘッダーを示します。"
    },
    {
      "indent": 3,
      "text": "This specification does not make any assumption about Context Headers that are mandatory to implement or those that are mandatory to process. These considerations are deployment specific. However, the control plane is entitled to instruct SFC-aware SFs with the data structure of the Context Header together with its scoping (see e.g., Section 3.3.3 of [SFC-CONTROL-PLANE]).",
      "ja": "この仕様では、実装が必須のコンテキストヘッダーや処理が必須のコンテキストヘッダーについては想定していません。これらの考慮事項はデプロイメント固有です。ただし、コントロールプレーンは、コンテキストヘッダーのデータ構造とそのスコープ（たとえば、[SFC-CONTROL-PLANE]のセクション3.3.3を参照）を使用して、SFC対応のSFに指示することができます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a packet that belongs to a given SFP, if a mandatory-to-process Context Header is missing in that packet, the SFC-aware SF MUST NOT process the packet and MUST log an error at least once per the SPI for which the mandatory metadata is missing.",
      "ja": "特定のSFPに属するパケットを受信すると、そのパケットに処理する必要のあるコンテキストヘッダーが欠落している場合、SFC対応のSFはパケットを処理してはならず、SPIごとに少なくとも1回エラーをログに記録する必要があります。必須のメタデータがありません。"
    },
    {
      "indent": 3,
      "text": "If multiple mandatory-to-process Context Headers are required for a given SFP, the control plane MAY instruct the SFC-aware SF with the order to consume these Context Headers. If no instructions are provided and the SFC-aware SF will make use of or modify the specific Context Header, then the SFC-aware SF MUST process these Context Headers in the order they appear in an NSH packet.",
      "ja": "特定のSFPに複数の処理が必須のコンテキストヘッダーが必要な場合、コントロールプレーンは、これらのコンテキストヘッダーを使用する順序でSFC対応SFに指示する場合があります。指示が提供されず、SFC対応SFが特定のコンテキストヘッダーを使用または変更する場合、SFC対応SFは、NSHパケットに表示される順序でこれらのコンテキストヘッダーを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple instances of the same metadata are included in an NSH packet, but the definition of that Context Header does not allow for it, the SFC-aware SF MUST process the first instance and ignore subsequent instances. The SFC-aware SF MAY log or increase a counter for this event.",
      "ja": "同じメタデータの複数のインスタンスがNSHパケットに含まれているが、そのコンテキストヘッダーの定義で許可されていない場合、SFC対応SFは最初のインスタンスを処理し、後続のインスタンスを無視する必要があります。 SFC対応のSFは、このイベントのログを記録するか、カウンターを増やします。"
    },
    {
      "indent": 0,
      "text": "3. NSH Actions",
      "section_title": true,
      "ja": "3. NSHアクション"
    },
    {
      "indent": 3,
      "text": "NSH-aware nodes (which include Service Classifiers, SFFs, SFs, and SFC Proxies) may alter the contents of the NSH headers. These nodes have several possible NSH-related actions:",
      "ja": "NSH対応ノード（サービス分類子、SFF、SF、SFCプロキシを含む）は、NSHヘッダーの内容を変更する場合があります。これらのノードには、いくつかの可能なNSH関連のアクションがあります。"
    },
    {
      "indent": 3,
      "text": "1. Insert or remove the NSH: These actions can occur respectively at the start and end of a service path. Packets are classified, and if determined to require servicing, an NSH will be imposed. A",
      "ja": "1. NSHの挿入または削除：これらのアクションは、サービスパスの開始時と終了時にそれぞれ発生する可能性があります。パケットは分類され、サービスが必要であると判断された場合、NSHが課されます。あ"
    },
    {
      "indent": 7,
      "text": "Service Classifier MUST insert an NSH at the start of an SFP. An imposed NSH MUST contain both a valid Base Header and Service Path Header. At the end of an SFP, an SFF MUST remove the NSH before forwarding or delivering the un-encapsulated packet. Therefore, it is the last node operating on the service header.",
      "ja": "サービス分類子は、SFPの先頭にNSHを挿入する必要があります。課されたNSHには、有効なベースヘッダーとサービスパスヘッダーの両方が含まれている必要があります。 SFPの最後に、SFFはカプセル化されていないパケットを転送または配信する前にNSHを削除する必要があります。したがって、これはサービスヘッダーで動作する最後のノードです。"
    },
    {
      "indent": 7,
      "text": "Multiple logical Classifiers may exist within a given service path. Non-initial Classifiers may re-classify data, and that re-classification MAY result in the selection of a different SFP. When the logical Classifier performs re-classification that results in a change of service path, it MUST replace the existing NSH with a new NSH with the Base Header and Service Path Header reflecting the new service path information and MUST set the initial SI. The O bit, the TTL field, and unassigned flags MUST be copied transparently from the old NSH to a new NSH. Metadata MAY be preserved in the new NSH.",
      "ja": "特定のサービスパス内に複数の論理分類子が存在する場合があります。最初以外の分類子はデータを再分類する可能性があり、その再分類により別のSFPが選択される可能性があります。論理分類子が再分類を実行してサービスパスを変更する場合、既存のNSHを、新しいサービスパス情報を反映するベースヘッダーとサービスパスヘッダーを持つ新しいNSHに置き換え、初期SIを設定する必要があります。 Oビット、TTLフィールド、および割り当てられていないフラグは、古いNSHから新しいNSHに透過的にコピーする必要があります。メタデータは新しいNSHで保持される場合があります。"
    },
    {
      "indent": 3,
      "text": "2. Select service path: The Service Path Header provides service path information and is used by SFFs to determine correct service path selection. SFFs MUST use the Service Path Header for selecting the next SF or SFF in the service path.",
      "ja": "2. サービスパスの選択：サービスパスヘッダーはサービスパス情報を提供し、正しいサービスパスの選択を決定するためにSFFによって使用されます。 SFFは、サービスパスの次のSFまたはSFFを選択するためにサービスパスヘッダーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. Update the NSH: SFs MUST decrement the service index by one. If an SFF receives a packet with an SPI and SI that do not correspond to a valid next hop in a valid SFP, that packet MUST be dropped by the SFF.",
      "ja": "3. NSHを更新します。SFはサービスインデックスを1だけ減らす必要があります。 SFFが、有効なSFPの有効なネクストホップに対応しないSPIとSIを持つパケットを受信した場合、そのパケットはSFFによってドロップされる必要があります。"
    },
    {
      "indent": 7,
      "text": "Classifiers MAY update Context Headers if new/updated context is available.",
      "ja": "新しい/更新されたコンテキストが利用可能な場合、分類子はコンテキストヘッダーを更新できます（MAY）。"
    },
    {
      "indent": 7,
      "text": "If an SFC proxy is in use (acting on behalf of an NSH-unaware Service Function for NSH actions), then the proxy MUST update the Service Index and MAY update contexts. When an SFC Proxy receives an NSH-encapsulated packet, it MUST remove the NSH before forwarding it to an NSH-unaware SF. When the SFC Proxy receives a packet back from an NSH-unaware SF, it MUST re-encapsulate it with the correct NSH, and it MUST decrement the Service Index by one.",
      "ja": "SFCプロキシが使用されている場合（NSHアクションのNSH非対応サービス関数に代わって動作）、プロキシはサービスインデックスを更新する必要があり、コンテキストを更新する必要があります（MAY）。 SFCプロキシは、NSHでカプセル化されたパケットを受信すると、NSHを認識しないSFに転送する前にNSHを削除する必要があります。 SFCプロキシは、NSH非対応のSFからパケットを受信すると、正しいNSHで再カプセル化する必要があり、サービスインデックスを1つ減らす必要があります。"
    },
    {
      "indent": 3,
      "text": "4. Service policy selection: Service Functions derive policy (i.e., service actions such as permit or deny) selection and enforcement from the NSH. Metadata shared in the NSH can provide a range of service-relevant information such as traffic classification.",
      "ja": "4. サービスポリシーの選択：サービス機能は、NSHからポリシー（つまり、許可や拒否などのサービスアクション）の選択と適用を導出します。 NSHで共有されるメタデータは、トラフィック分類など、サービスに関連するさまざまな情報を提供できます。"
    },
    {
      "indent": 3,
      "text": "Figure 8 maps each of the four actions above to the components in the SFC architecture that can perform it.",
      "ja": "図8は、上記の4つのアクションのそれぞれを、それを実行できるSFCアーキテクチャのコンポーネントにマップします。"
    },
    {
      "indent": 3,
      "text": "+-----------+-----------------------+-------+---------------+-------+\n|           | Insert, remove, or    |Forward| Update        |Service|\n|           | replace the NSH       |the NSH| the NSH       |policy |\n|           |                       |packets|               |sel.   |\n|Component  +-------+-------+-------+       +-------+-------+       |\n|           |       |       |       |       |Dec.   |Update |       |\n|           |Insert |Remove |Replace|       |Service|Context|       |\n|           |       |       |       |       |Index  |Header |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|           |  +    |       |   +   |       |       |   +   |       |\n|Classifier |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|Service    |       |   +   |       |   +   |       |       |       |\n|Function   |       |       |       |       |       |       |       |\n|Forwarder  |       |       |       |       |       |       |       |\n|(SFF)      |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|Service    |       |       |       |       |   +   |   +   |   +   |\n|Function   |       |       |       |       |       |       |       |\n|(SF)       |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|           |  +    |   +   |       |       |   +   |   +   |       |\n|SFC Proxy  |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 8: NSH Action and Role Mapping",
      "ja": "図8：NSHアクションとロールマッピング"
    },
    {
      "indent": 0,
      "text": "4. NSH Transport Encapsulation",
      "section_title": true,
      "ja": "4. NSHトランスポートカプセル化"
    },
    {
      "indent": 3,
      "text": "Once the NSH is added to a packet, an outer transport encapsulation is used to forward the original packet and the associated metadata to the start of a service chain. The encapsulation serves two purposes:",
      "ja": "NSHがパケットに追加されると、外部トランスポートカプセル化を使用して、元のパケットと関連するメタデータがサービスチェーンの先頭に転送されます。カプセル化には2つの目的があります。"
    },
    {
      "indent": 3,
      "text": "1. Creates a topologically independent services plane. Packets are forwarded to the required services without changing the underlying network topology.",
      "ja": "1. トポロジー的に独立したサービスプレーンを作成します。パケットは、基盤となるネットワークトポロジを変更することなく、必要なサービスに転送されます。"
    },
    {
      "indent": 3,
      "text": "2. Transit network nodes simply forward the encapsulated packets without modification.",
      "ja": "2. トランジットネットワークノードは、カプセル化されたパケットを変更せずに転送するだけです。"
    },
    {
      "indent": 3,
      "text": "The service header is independent of the transport encapsulation used. Existing transport encapsulations can be used. The presence of an NSH is indicated via a protocol type or another indicator in the outer transport encapsulation.",
      "ja": "サービスヘッダーは、使用されるトランスポートカプセル化とは無関係です。既存のトランスポートカプセル化を使用できます。 NSHの存在は、外部トランスポートカプセル化のプロトコルタイプまたは別のインジケーターによって示されます。"
    },
    {
      "indent": 0,
      "text": "5. Fragmentation Considerations",
      "section_title": true,
      "ja": "5. 断片化に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The NSH and the associated transport encapsulation header are \"added\" to the encapsulated packet/frame. This additional information increases the size of the packet.",
      "ja": "NSHおよび関連するトランスポートカプセル化ヘッダーは、カプセル化されたパケット/フレームに「追加」されます。この追加情報により、パケットのサイズが増加します。"
    },
    {
      "indent": 3,
      "text": "Within a managed administrative domain, an operator can ensure that the underlay MTU is sufficient to carry SFC traffic without requiring fragmentation. Given that the intended scope of the NSH is within a single provider's operational domain, that approach is sufficient.",
      "ja": "管理された管理ドメイン内では、オペレーターはアンダーレイMTUが断片化を必要とせずにSFCトラフィックを伝送するのに十分であることを確認できます。 NSHの対象範囲が単一のプロバイダーの運用ドメイン内にあることを考えると、そのアプローチで十分です。"
    },
    {
      "indent": 3,
      "text": "However, although explicitly outside the scope of this specification, there might be cases where the underlay MTU is not large enough to carry the NSH traffic. Since the NSH does not provide fragmentation support at the service plane, the transport encapsulation protocol ought to provide the requisite fragmentation handling. For instance, Section 9 of [RTG-ENCAP] provides exemplary approaches and guidance for those scenarios.",
      "ja": "ただし、明示的にこの仕様の範囲外ですが、アンダーレイMTUがNSHトラフィックを伝送するのに十分な大きさでない場合があります。 NSHはサービスプレーンでフラグメンテーションサポートを提供しないため、トランスポートカプセル化プロトコルは必要なフラグメンテーション処理を提供する必要があります。たとえば、[RTG-ENCAP]のセクション9は、これらのシナリオの例示的なアプローチとガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "When the transport encapsulation protocol supports fragmentation, and fragmentation procedures needs to be used, such fragmentation is part of the transport encapsulation logic. If, as it is common, fragmentation is performed by the endpoints of the transport encapsulation, then fragmentation procedures are performed at the sending NSH entity as part of the transport encapsulation, and reassembly procedures are performed at the receiving NSH entity during transport de-encapsulation handling logic. In no case would such fragmentation result in duplication of the NSH header.",
      "ja": "トランスポートカプセル化プロトコルがフラグメンテーションをサポートし、フラグメンテーション手順を使用する必要がある場合、そのようなフラグメンテーションはトランスポートカプセル化ロジックの一部です。よくあることですが、断片化がトランスポートカプセル化のエンドポイントによって実行される場合、断片化手順はトランスポートカプセル化の一部として送信側のNSHエンティティで実行され、再構成手順はトランスポートのカプセル化解除中に受信側のNSHエンティティで実行されます処理ロジック。このような断片化によってNSHヘッダーが重複することは決してありません。"
    },
    {
      "indent": 3,
      "text": "For example, when the NSH is encapsulated in IP, IP-level fragmentation coupled with Path MTU Discovery (PMTUD) (e.g., [RFC8201]) is used. Since PMTUD relies on ICMP messages, an operator should ensure ICMP packets are not blocked. When, on the other hand, the underlay does not support fragmentation procedures, an error message SHOULD be logged when dropping a packet too big. Lastly, NSH-specific fragmentation and reassembly methods may be defined as well, but these methods are outside the scope of this document and subject for future work.",
      "ja": "たとえば、NSHがIPでカプセル化されている場合、パスMTU検出（PMTUD）（たとえば[RFC8201]）と組み合わせたIPレベルのフラグメンテーションが使用されます。 PMTUDはICMPメッセージに依存しているため、オペレーターはICMPパケットがブロックされないようにする必要があります。一方、アンダーレイがフラグメント化手順をサポートしていない場合、パケットをドロップしすぎるとエラーメッセージがログに記録されるべきです（SHOULD）。最後に、NSH固有の断片化および再構成方法も定義できますが、これらの方法はこのドキュメントの範囲外であり、今後の作業の対象となります。"
    },
    {
      "indent": 0,
      "text": "6. Service Path Forwarding with NSH",
      "section_title": true,
      "ja": "6. NSHによるサービスパス転送"
    },
    {
      "indent": 0,
      "text": "6.1. SFFs and Overlay Selection",
      "section_title": true,
      "ja": "6.1. SFFとオーバーレイの選択"
    },
    {
      "indent": 3,
      "text": "As described above, the NSH contains a Service Path Identifier (SPI) and a Service Index (SI). The SPI is, as per its name, an identifier. The SPI alone cannot be used to forward packets along a service path. Rather, the SPI provides a level of indirection between the service path / topology and the network transport encapsulation. Furthermore, there is no requirement for, or expectation of, an SPI being bound to a predetermined or static network path.",
      "ja": "上記のように、NSHにはサービスパス識別子（SPI）とサービスインデックス（SI）が含まれています。 SPIは、その名前のとおり、識別子です。 SPIだけを使用して、サービスパスに沿ってパケットを転送することはできません。むしろ、SPIはサービスパス/トポロジとネットワークトランスポートカプセル化の間の間接レベルを提供します。さらに、SPIが事前に決定された、または静的なネットワークパスにバインドされている必要はありません。"
    },
    {
      "indent": 3,
      "text": "The Service Index provides an indication of location within a service path. The combination of SPI and SI provides the identification of a logical SF and its order within the service plane. This combination is used to select the appropriate network locator(s) for overlay forwarding. The logical SF may be a single SF or a set of eligible SFs that are equivalent. In the latter case, the SFF provides load distribution amongst the collection of SFs as needed.",
      "ja": "サービスインデックスは、サービスパス内の場所を示します。 SPIとSIの組み合わせにより、サービスプレーン内の論理SFとその順序を識別できます。この組み合わせを使用して、オーバーレイ転送に適切なネットワークロケーターを選択します。論理SFは、単一のSFまたは同等の適格なSFのセットです。後者の場合、SFFは必要に応じてSFのコレクション間で負荷を分散します。"
    },
    {
      "indent": 3,
      "text": "SI serves as a mechanism for detecting invalid SFPs. In particular, an SI value of zero indicates that forwarding is incorrect and the packet must be discarded.",
      "ja": "SIは、無効なSFPを検出するメカニズムとして機能します。特に、SI値がゼロの場合は、転送が正しくなく、パケットを破棄する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "This indirection -- SPI to overlay -- creates a true service plane. That is, the SFF/SF topology is constructed without impacting the network topology, but, more importantly, service-plane-only participants (i.e., most SFs) need not be part of the network overlay topology and its associated infrastructure (e.g., control plane, routing tables, etc.). SFs need to be able to return a packet to an appropriate SFF (i.e., has the requisite NSH information) when service processing is complete. This can be via the overlay or underlay and, in some cases, can require additional configuration on the SF. As mentioned above, an existing overlay topology may be used, provided it offers the requisite connectivity.",
      "ja": "この間接性（オーバーレイするSPI）は、真のサービスプレーンを作成します。つまり、SFF / SFトポロジーはネットワークトポロジーに影響を与えることなく構築されますが、さらに重要なのは、サービスプレーンのみの参加者（つまり、ほとんどのSF）がネットワークオーバーレイトポロジーとそれに関連するインフラストラクチャ（制御など）の一部である必要がないことです。プレーン、ルーティングテーブルなど）。 SFは、サービス処理が完了したときに、パケットを適切なSFFに戻すことができる（つまり、必要なNSH情報を持っている）必要があります。これはオーバーレイまたはアンダーレイを介して行うことができ、場合によっては、SFで追加の構成が必要になることがあります。上記のように、必要な接続を提供する場合は、既存のオーバーレイトポロジを使用できます。"
    },
    {
      "indent": 3,
      "text": "The mapping of SPI to transport encapsulation occurs on an SFF (as discussed above, the first SFF in the path gets an NSH encapsulated packet from the Classifier). The SFF consults the SPI/ID values to determine the appropriate overlay transport encapsulation protocol (several may be used within a given network) and next hop for the requisite SF. Table 1 depicts an example of a single next-hop SPI/ SI-to-network overlay network locator mapping.",
      "ja": "トランスポートカプセル化へのSPIのマッピングはSFFで行われます（前述のように、パスの最初のSFFは分類子からNSHカプセル化パケットを取得します）。 SFFはSPI / ID値を調べて、適切なオーバーレイトランスポートカプセル化プロトコル（特定のネットワーク内でいくつか使用される場合があります）と必要なSFのネクストホップを決定します。表1は、単一のネクストホップSPI / SIからネットワークへのオーバーレイネットワークロケーターマッピングの例を示しています。"
    },
    {
      "indent": 6,
      "text": "+------+------+---------------------+-------------------------+\n| SPI  | SI   | Next Hop(s)         | Transport Encapsulation |\n+------+------+---------------------+-------------------------+\n| 10   | 255  | 192.0.2.1           | VXLAN-gpe               |\n|      |      |                     |                         |\n| 10   | 254  | 198.51.100.10       | GRE                     |\n|      |      |                     |                         |\n| 10   | 251  | 198.51.100.15       | GRE                     |\n|      |      |                     |                         |\n| 40   | 251  | 198.51.100.15       | GRE                     |\n|      |      |                     |                         |\n| 50   | 200  | 01:23:45:67:89:ab   | Ethernet                |\n|      |      |                     |                         |\n| 15   | 212  | Null (end of path)  | None                    |\n+------+------+---------------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 1: SFF NSH Mapping Example",
      "ja": "表1：SFF NSHマッピングの例"
    },
    {
      "indent": 3,
      "text": "Additionally, further indirection is possible: the resolution of the required SF network locator may be a localized resolution on an SFF, rather than an SFC control plane responsibility, as per Tables 2 and 3.",
      "ja": "さらに、さらなる間接化も可能です。必要なSFネットワークロケータの解像度は、表2および3のように、SFCコントロールプレーンの責任ではなく、SFFのローカライズされた解像度になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Please note: VXLAN-gpe and GRE in the above table refer to [VXLAN-GPE] and [RFC2784] [RFC7676], respectively.",
      "ja": "注：上記の表のVXLAN-gpeおよびGREは、それぞれ[VXLAN-GPE]および[RFC2784] [RFC7676]を指します。"
    },
    {
      "indent": 22,
      "text": "+------+-----+----------------+\n| SPI  | SI  | Next Hop(s)    |\n+------+-----+----------------+\n| 10   | 3   | SF2            |\n|      |     |                |\n| 245  | 12  | SF34           |\n|      |     |                |\n| 40   | 9   | SF9            |\n+------+-----+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 2: NSH-to-SF Mapping Example",
      "ja": "表2：NSHからSFへのマッピングの例"
    },
    {
      "indent": 10,
      "text": "+------+-------------------+-------------------------+\n| SF   | Next Hop(s)       | Transport Encapsulation |\n+------+-------------------+-------------------------+\n| SF2  | 192.0.2.2         | VXLAN-gpe               |\n|      |                   |                         |\n| SF34 | 198.51.100.34     | UDP                     |\n|      |                   |                         |\n| SF9  | 2001:db8::1       | GRE                     |\n+------+-------------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 3: SF Locator Mapping Example",
      "ja": "表3：SFロケーターマッピングの例"
    },
    {
      "indent": 3,
      "text": "Since the SPI is a representation of the service path, the lookup may return more than one possible next hop within a service path for a given SF, essentially a series of weighted (equally or otherwise) paths to be used (for load distribution, redundancy, or policy); see Table 4. The metric depicted in Table 4 is an example to help illustrate weighing SFs. In a real network, the metric will range from a simple preference (similar to routing next-hop) to a true dynamic composite metric based on the state of a Service Function (including load, session state, capacity, etc.).",
      "ja": "SPIはサービスパスの表現であるため、ルックアップは、特定のSFのサービスパス内で複数の可能なネクストホップを返す場合があります。基本的に、一連の重み付けされた（等しいまたはその他の）パスが使用されます（負荷分散、冗長性）。 、またはポリシー）;表4を参照してください。表4に示すメトリックは、SFの重み付けを説明するための例です。実際のネットワークでは、メトリックは単純な設定（ルーティングネクストホップと同様）からサービス機能の状態（負荷、セッション状態、容量などを含む）に基づく真の動的複合メトリックまでさまざまです。"
    },
    {
      "indent": 18,
      "text": "+------+-----+--------------+---------+\n| SPI  | SI  | NH           | Metric  |\n+------+-----+--------------+---------+\n| 10   | 3   | 203.0.113.1  | 1       |\n|      |     |              |         |\n|      |     | 203.0.113.2  | 1       |\n|      |     |              |         |\n| 20   | 12  | 192.0.2.1    | 1       |\n|      |     |              |         |\n|      |     | 203.0.113.4  | 1       |\n|      |     |              |         |\n| 30   | 7   | 192.0.2.10   | 10      |\n|      |     |              |         |\n|      |     | 198.51.100.1 | 5       |\n+------+-----+--------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "(encapsulation type omitted for formatting)",
      "ja": "（フォーマットのためにカプセル化タイプは省略）"
    },
    {
      "indent": 20,
      "text": "Table 4: NSH Weighted Service Path",
      "ja": "表4：NSH加重サービスパス"
    },
    {
      "indent": 3,
      "text": "The information contained in Tables 1-4 may be received from the control plane, but the exact mechanism is outside the scope of this document.",
      "ja": "表1〜4に含まれている情報は、コントロールプレーンから受信される場合がありますが、正確なメカニズムはこのドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "6.2. Mapping the NSH to Network Topology",
      "section_title": true,
      "ja": "6.2. NSHをネットワークトポロジにマッピングする"
    },
    {
      "indent": 3,
      "text": "As described above, the mapping of the SPI to network topology may result in a single path, or it might result in a more complex topology. Furthermore, the SPI-to-overlay mapping occurs at each SFF independently. Any combination of topology selection is possible. Please note, there is no requirement to create a new overlay topology if a suitable one already exists. NSH packets can use any (new or existing) overlay, provided the requisite connectivity requirements are satisfied.",
      "ja": "上記のように、SPIをネットワークトポロジにマッピングすると、単一のパスになる場合や、より複雑なトポロジになる場合があります。さらに、SPIからオーバーレイへのマッピングは、各SFFで独立して行われます。トポロジー選択の任意の組み合わせが可能です。適切なトポロジがすでに存在する場合は、新しいオーバーレイトポロジを作成する必要はありません。必要な接続要件が満たされていれば、NSHパケットは（新規または既存の）オーバーレイを使用できます。"
    },
    {
      "indent": 3,
      "text": "Examples of mapping for a topology:",
      "ja": "トポロジーのマッピングの例："
    },
    {
      "indent": 3,
      "text": "1. Next SF is located at SFFb with locator 2001:db8::1 SFFa mapping: SPI=10 --> VXLAN-gpe, dst-ip: 2001:db8::1",
      "ja": "1. 次のSFは、ロケーター2001：db8 :: 1のSFFbにあります。SFFaマッピング：SPI = 10-> VXLAN-gpe、dst-ip：2001：db8 :: 1"
    },
    {
      "indent": 3,
      "text": "2. Next SF is located at SFFc with multiple network locators for load-distribution purposes: SFFb mapping: SPI=10 --> VXLAN-gpe, dst_ip:203.0.113.1, 203.0.113.2, 203.0.113.3, equal cost",
      "ja": "2. 次のSFは、負荷分散のために複数のネットワークロケーターを備えたSFFcにあります。SFFbマッピング：SPI = 10-> VXLAN-gpe、dst_ip：203.0.113.1、203.0.113.2、203.0.113.3、等コスト"
    },
    {
      "indent": 3,
      "text": "3. Next SF is located at SFFd with two paths from SFFc, one for redundancy: SFFc mapping: SPI=10 --> VXLAN-gpe, dst_ip:192.0.2.10 cost=10, 203.0.113.10, cost=20",
      "ja": "3. 次のSFはSFFdにあり、SFFcからの2つのパスがあり、1つは冗長用です。SFFcマッピング：SPI = 10-> VXLAN-gpe、dst_ip：192.0.2.10 cost = 10、203.0.113.10、cost = 20"
    },
    {
      "indent": 3,
      "text": "In the above example, each SFF makes an independent decision about the network overlay path and policy for that path. In other words, there is no a priori mandate about how to forward packets in the network (only the order of services that must be traversed).",
      "ja": "上記の例では、各SFFはネットワークオーバーレイパスとそのパスのポリシーについて独立した決定を行います。言い換えれば、ネットワーク内でパケットを転送する方法についての事前の義務はありません（通過する必要があるサービスの順序のみ）。"
    },
    {
      "indent": 3,
      "text": "The network operator retains the ability to engineer the network paths as required. For example, the overlay path between SFFs may utilize traffic engineering, QoS marking, or ECMP, without requiring complex configuration and network protocol support to be extended to the service path explicitly. In other words, the network operates as expected, and evolves as required, as does the service plane.",
      "ja": "ネットワークオペレーターは、必要に応じてネットワークパスを設計する機能を保持します。たとえば、SFF間のオーバーレイパスは、トラフィックエンジニアリング、QoSマーキング、またはECMPを利用できます。複雑な構成やネットワークプロトコルサポートをサービスパスに明示的に拡張する必要はありません。つまり、サービスプレーンと同様に、ネットワークは期待どおりに動作し、必要に応じて進化します。"
    },
    {
      "indent": 0,
      "text": "6.3. Service Plane Visibility",
      "section_title": true,
      "ja": "6.3. サービスプレーンの可視性"
    },
    {
      "indent": 3,
      "text": "The SPI and SI serve an important function for visibility into the service topology. An operator can determine what service path a packet is \"on\" and its location within that path simply by viewing NSH information (packet capture, IP Flow Information Export (IPFIX), etc.). The information can be used for service scheduling and placement decisions, troubleshooting, and compliance verification.",
      "ja": "SPIとSIは、サービストポロジを可視化するための重要な機能を果たします。オペレーターは、NSH情報（パケットキャプチャ、IPフロー情報エクスポート（IPFIX）など）を表示するだけで、パケットが「オン」になっているサービスパスとそのパス内の場所を特定できます。この情報は、サービスのスケジューリングと配置の決定、トラブルシューティング、およびコンプライアンスの検証に使用できます。"
    },
    {
      "indent": 0,
      "text": "6.4. Service Graphs",
      "section_title": true,
      "ja": "6.4. サービスグラフ"
    },
    {
      "indent": 3,
      "text": "While a given realized SFP is a specific sequence of Service Functions, the service, as seen by a user, can actually be a collection of SFPs, with the interconnection provided by Classifiers (in-service path, non-initial re-classification). These internal re-Classifiers examine the packet at relevant points in the network, and, if needed, SPI and SI are updated (whether this update is a re-write, or the imposition of a new NSH with new values is implementation specific) to reflect the \"result\" of the classification. These Classifiers may, of course, also modify the metadata associated with the packet. Section 2.1 of [RFC7665] describes Service Graphs in detail.",
      "ja": "特定の実現されたSFPはサービス機能の特定のシーケンスですが、ユーザーから見たサービスは実際にはSFPのコレクションであり、分類子によって提供される相互接続（サービス中のパス、初期ではない再分類）を使用できます。これらの内部再分類子は、ネットワークの関連するポイントでパケットを調べ、必要に応じて、SPIおよびSIを更新します（この更新が書き換えであるか、または新しい値を持つ新しいNSHのインポジションが実装固有であるか）。分類の「結果」を反映します。もちろん、これらの分類子は、パケットに関連付けられたメタデータを変更することもできます。 [RFC7665]のセクション2.1では、サービスグラフについて詳しく説明しています。"
    },
    {
      "indent": 0,
      "text": "7. Policy Enforcement with NSH",
      "section_title": true,
      "ja": "7. NSHによるポリシーの実施"
    },
    {
      "indent": 0,
      "text": "7.1. NSH Metadata and Policy Enforcement",
      "section_title": true,
      "ja": "7.1. NSHメタデータとポリシー施行"
    },
    {
      "indent": 3,
      "text": "As described in Section 2, NSH provides the ability to carry metadata along a service path. This metadata may be derived from several sources. Common examples include:",
      "ja": "セクション2で説明したように、NSHはサービスパスに沿ってメタデータを伝送する機能を提供します。このメタデータは、いくつかのソースから取得される場合があります。一般的な例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Network nodes/devices: Information provided by network nodes can indicate network-centric information (such as VPN Routing and Forwarding (VRF) or tenant) that may be used by Service Functions or conveyed to another network node post service path egress.",
      "ja": "ネットワークノード/デバイス：ネットワークノードによって提供される情報は、サービス機能が使用したり、サービスパスの出口のポストを別のネットワークノードに伝達したりできるネットワーク中心の情報（VPNルーティングおよび転送（VRF）またはテナントなど）を示すことができます。"
    },
    {
      "indent": 6,
      "text": "External (to the network) systems: External systems, such as orchestration systems, often contain information that is valuable for Service Function policy decisions. In most cases, this information cannot be deduced by network nodes. For example, a cloud orchestration platform placing workloads \"knows\" what application is being instantiated and can communicate this information to all NSH nodes via metadata carried in the Context Header(s).",
      "ja": "外部（ネットワーク）システム：オーケストレーションシステムなどの外部システムには、サービス機能ポリシーの決定に役立つ情報が含まれていることがよくあります。ほとんどの場合、この情報はネットワークノードによって推定することはできません。たとえば、ワークロードを配置するクラウドオーケストレーションプラットフォームは、インスタンス化されているアプリケーションを「認識」し、コンテキストヘッダーに含まれるメタデータを介してこの情報をすべてのNSHノードに伝達できます。"
    },
    {
      "indent": 6,
      "text": "Service Functions: A Classifier co-resident with Service Functions often performs very detailed and valuable classification.",
      "ja": "サービス機能：サービス機能と共存する分類子は、非常に詳細で価値のある分類を実行することがよくあります。"
    },
    {
      "indent": 3,
      "text": "Regardless of the source, metadata reflects the \"result\" of classification. The granularity of classification may vary. For example, a network switch, acting as a Classifier, might only be able to classify based on a 2-tuple, or based on a 5-tuple, while a Service Function may be able to inspect application information. Regardless of granularity, the classification information can be represented in the NSH.",
      "ja": "ソースに関係なく、メタデータは分類の「結果」を反映しています。分類の粒度は異なる場合があります。たとえば、クラシファイアとして機能するネットワークスイッチは、2タプルまたは5タプルに基づいてのみ分類できる場合がありますが、サービス機能はアプリケーション情報を検査できます。粒度に関係なく、分類情報はNSHで表すことができます。"
    },
    {
      "indent": 3,
      "text": "Once the data is added to the NSH, it is carried along the service path. NSH-aware SFs receive the metadata, and can use that metadata for local decisions and policy enforcement. Figures 9 and 10 highlight the relationship between metadata and policy.",
      "ja": "データがNSHに追加されると、サービスパスに沿って運ばれます。 NSH対応のSFはメタデータを受け取り、そのメタデータをローカルの決定およびポリシーの実施に使用できます。図9および10は、メタデータとポリシーの関係を示しています。"
    },
    {
      "indent": 16,
      "text": "+-------+        +-------+        +-------+\n|  SFF  )------->(  SFF  |------->|  SFF  |\n+---+---+        +---+---+        +---+---+\n    ^                |                |\n  ,-|-.            ,-|-.            ,-|-.\n /     \\          /     \\          /     \\\n( Class )        (  SF1  )        (  SF2  )\n \\ ify /          \\     /          \\     /\n  `---'            `---'            `---'\n 5-tuple:        Permit             Inspect\n Tenant A        Tenant A           AppY\n AppY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 9: Metadata and Policy",
      "ja": "図9：メタデータとポリシー"
    },
    {
      "indent": 14,
      "text": " +-----+           +-----+            +-----+\n | SFF |---------> | SFF |----------> | SFF |\n +--+--+           +--+--+            +--+--+\n    ^                 |                  |\n  ,-+-.             ,-+-.              ,-+-.\n /     \\           /     \\            /     \\\n( Class )         (  SF1  )          (  SF2  )\n \\ ify /           \\     /            \\     /\n  `-+-'             `---'              `---'\n    |              Permit            Deny AppZ\n+---+---+          employees\n|       |\n+-------+\nExternal\nsystem:\nEmployee\nAppZ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 10: External Metadata and Policy",
      "ja": "図10：外部メタデータとポリシー"
    },
    {
      "indent": 3,
      "text": "In both of the examples above, the Service Functions perform policy decisions based on the result of the initial classification: the SFs did not need to perform re-classification; instead, they rely on an antecedent classification for local policy enforcement.",
      "ja": "上記の両方の例で、サービス機能は初期分類の結果に基づいてポリシー決定を実行します。SFは再分類を実行する必要がありませんでした。代わりに、ローカルポリシーの施行を前の分類に依存します。"
    },
    {
      "indent": 0,
      "text": " Depending on the information carried in the metadata, data privacy impact needs to be considered. For example, if the metadata conveys tenant information, that information may need to be authenticated and/or encrypted between the originator and the intended recipients (which may include intended SFs only); one approach to an optional capability to do this is explored in [NSH-ENCRYPT]. The NSH itself does not provide privacy functions, rather it relies on the transport encapsulation/overlay. An operator can select the appropriate set of transport encapsulation protocols to ensure confidentiality (and other security) considerations are met. Metadata privacy and security considerations are a matter for the documents that define metadata format.",
      "ja": "メタデータに含まれる情報に応じて、データのプライバシーへの影響を考慮する必要があります。たとえば、メタデータがテナント情報を伝達する場合、その情報は、発信者と意図された受信者（意図されたSFのみを含む場合がある）の間で認証または暗号化される必要がある場合があります。これを行うオプション機能への1つのアプローチは、[NSH-ENCRYPT]で検討されています。 NSH自体はプライバシー機能を提供せず、トランスポートのカプセル化/オーバーレイに依存します。オペレーターは、適切なトランスポートカプセル化プロトコルのセットを選択して、機密性（およびその他のセキュリティ）の考慮事項を確実に満たすことができます。メタデータのプライバシーとセキュリティに関する考慮事項は、メタデータ形式を定義するドキュメントの問題です。"
    },
    {
      "indent": 0,
      "text": "7.2. Updating/Augmenting Metadata",
      "section_title": true,
      "ja": "7.2. メタデータの更新/拡張"
    },
    {
      "indent": 3,
      "text": "Post-initial metadata imposition (typically, performed during initial service path determination), the metadata may be augmented or updated:",
      "ja": "初期メタデータの面付け（通常、初期サービスパスの決定中に実行されます）、メタデータは拡張または更新されます。"
    },
    {
      "indent": 3,
      "text": "1. Metadata Augmentation: Information may be added to the NSH's existing metadata, as depicted in Figure 11. For example, if the initial classification returns the tenant information, a secondary classification (perhaps co-resident with deep packet inspection (DPI) or server load balancing (SLB)) may augment the tenant classification with application information, and impose that new information in NSH metadata. The tenant classification is still valid and present, but additional information has been added to it.",
      "ja": "1. メタデータの増強：図11に示すように、NSHの既存のメタデータに情報を追加できます。たとえば、最初の分類でテナント情報が返された場合、2番目の分類（ディープパケットインスペクション（DPI）またはサーバーロードバランシングと共存する可能性があります） （SLB））は、テナント分類をアプリケーション情報で補強し、その新しい情報をNSHメタデータに課します。テナントの分類はまだ有効で存在していますが、追加の情報が追加されています。"
    },
    {
      "indent": 3,
      "text": "2. Metadata Update: Subsequent Classifiers may update the initial classification if it is determined to be incorrect or not descriptive enough. For example, the initial Classifier adds metadata that describes the traffic as \"Internet\", but a security Service Function determines that the traffic is really \"attack\". Figure 12 illustrates an example of updating metadata.",
      "ja": "2. メタデータの更新：後続の分類子は、それが正しくない、または十分に説明的でないと判断された場合、最初の分類を更新できます。たとえば、最初の分類子はトラフィックを「インターネット」として説明するメタデータを追加しますが、セキュリティサービス関数はトラフィックが実際に「攻撃」であると判断します。図12は、メタデータの更新の例を示しています。"
    },
    {
      "indent": 14,
      "text": " +-----+           +-----+            +-----+\n | SFF |---------> | SFF |----------> | SFF |\n +--+--+           +--+--+            +--+--+\n    ^                 |                  |\n  ,---.             ,---.              ,---.\n /     \\           /     \\            /     \\\n( Class )         (  SF1  )          (  SF2  )\n \\     /           \\     /            \\     /\n  `-+-'             `---'              `---'\n    |              Inspect           Deny\n+---+---+          employees         employee+\n|       |          Class=AppZ        appZ\n+-------+\nExternal\nsystem:\nEmployee",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 11: Metadata Augmentation",
      "ja": "図11：メタデータの増強"
    },
    {
      "indent": 14,
      "text": "  +-----+           +-----+            +-----+\n  | SFF |---------> | SFF |----------> | SFF |\n  +--+--+           +--+--+            +--+--+\n     ^                 |                  |\n   ,---.             ,---.              ,---.\n  /     \\           /     \\            /     \\\n ( Class )         (  SF1  )          (  SF2  )\n  \\     /           \\     /            \\     /\n   `---'             `---'              `---'\n5-tuple:            Inspect             Deny\nTenant A            Tenant A            attack\n                     --> attack",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 12: Metadata Update",
      "ja": "図12：メタデータの更新"
    },
    {
      "indent": 0,
      "text": "7.3. Service Path Identifier and Metadata",
      "section_title": true,
      "ja": "7.3. サービスパス識別子とメタデータ"
    },
    {
      "indent": 3,
      "text": "Metadata information may influence the service path selection since the Service Path Identifier values can represent the result of classification. A given SPI can be defined based on classification results (including metadata classification). The imposition of the SPI and SI results in the packet being placed on the newly specified SFP at the position indicated by the imposed SPI and SI.",
      "ja": "サービスパス識別子の値は分類の結果を表すことができるため、メタデータ情報はサービスパスの選択に影響を与える可能性があります。特定のSPIは、分類結果（メタデータ分類を含む）に基づいて定義できます。 SPIとSIの強制により、パケットは、強制されたSPIとSIによって示される位置で、新しく指定されたSFPに配置されます。"
    },
    {
      "indent": 0,
      "text": " This relationship provides the ability to create a dynamic service plane based on complex classification, without requiring each node to be capable of such classification or requiring a coupling to the network topology. This yields Service Graph functionality as described in Section 6.4. Figure 13 illustrates an example of this behavior.",
      "ja": "この関係は、複雑な分類に基づいて動的なサービスプレーンを作成する機能を提供します。各ノードがそのような分類ができる必要はなく、ネットワークトポロジーへの結合も必要ありません。これにより、セクション6.4で説明されているService Graph機能が実現します。図13は、この動作の例を示しています。"
    },
    {
      "indent": 13,
      "text": "  +-----+           +-----+            +-----+\n  | SFF |---------> | SFF |------+---> | SFF |\n  +--+--+           +--+--+      |     +--+--+\n     |                 |         |        |\n   ,---.             ,---.       |      ,---.\n  /     \\           / SF1 \\      |     /     \\\n (  SCL  )         (   +   )     |    (  SF2  )\n  \\     /           \\SCL2 /      |     \\     /\n   `---'             `---'    +-----+   `---'\n5-tuple:            Inspect   | SFF |    Original\nTenant A            Tenant A  +--+--+    next SF\n                     --> DoS     |\n                                 V\n                               ,-+-.\n                              /     \\\n                             (  SF10 )\n                              \\     /\n                               `---'\n                                DoS\n                             \"Scrubber\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Legend: SCL = Service Classifier",
      "ja": "凡例：SCL =サービス分類子"
    },
    {
      "indent": 22,
      "text": "Figure 13: Path ID and Metadata",
      "ja": "図13：パスIDとメタデータ"
    },
    {
      "indent": 3,
      "text": "Specific algorithms for mapping metadata to an SPI are outside the scope of this document.",
      "ja": "メタデータをSPIにマッピングするための特定のアルゴリズムは、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "NSH security must be considered in the contexts of the SFC architecture and operators' environments. One important characteristic of NSH is that it is not an end-to-end protocol. As opposed to a protocol that \"starts\" on a host and \"ends\" on a server or another host, NSH is typically imposed by a network device on ingress to the SFC domain and removed at the egress of the SFC domain. As such, and as with any other network-centric protocols (e.g., IP Tunneling, Traffic Engineering, MPLS, or Provider-Provisioned Virtual Private Networks), there is an underlying trust in the network devices responsible for imposing, removing, and acting on NSH information.",
      "ja": "NSHセキュリティは、SFCアーキテクチャーおよびオペレーターの環境のコンテキストで考慮する必要があります。 NSHの重要な特徴の1つは、エンドツーエンドのプロトコルではないことです。ホストで「開始」し、サーバーまたは別のホストで「終了」するプロトコルとは対照的に、NSHは通常、SFCドメインへの入口でネットワークデバイスによって強制され、SFCドメインの出口で削除されます。そのため、他のネットワーク中心のプロトコル（IPトンネリング、トラフィックエンジニアリング、MPLS、プロバイダーによってプロビジョニングされた仮想プライベートネットワークなど）と同様に、課す、削除する、操作する責任を負うネットワークデバイスには根本的な信頼があります。 NSH情報。"
    },
    {
      "indent": 3,
      "text": "The following sections detail an analysis and present a set of requirements and recommendations in those two areas.",
      "ja": "次のセクションでは、分析について詳しく説明し、これら2つの領域の要件と推奨事項を示します。"
    },
    {
      "indent": 0,
      "text": "8.1. NSH Security Considerations from Operators' Environments",
      "section_title": true,
      "ja": "8.1. オペレーターの環境からのNSHセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Trusted Devices",
      "ja": "信頼できるデバイス"
    },
    {
      "indent": 6,
      "text": "All Classifiers, SFFs and SFs (hereinafter referred to as \"SFC devices\") within an operator's environment are assumed to have been selected, vetted, and actively maintained; therefore, they are trusted by that operator. This assumption differs from the oft held view that devices are untrusted, often referred to as the \"zero-trust model\". Operators SHOULD regularly monitor (i.e., continuously audit) these devices to help ensure compliant behavior. This trust, therefore, extends into NSH operations: SFC devices are not, themselves, considered to be attack vectors. This assumption, and the resultant conclusion is reasonable since this is the very basis of an operator posture; the operator depends on this reality to function. If these devices are not trusted, and indeed are compromised, almost the entirety of the operator's standard-based IP and MPLS protocol suites are vulnerable; therefore, the operation of the entire network is compromised. Although there are well-documented monitoring-based methods for detecting compromise (such as included continuous monitoring and audit and log review), these may not be sufficient to contain damage by a completely compromised element.",
      "ja": "オペレーターの環境内のすべての分類子、SFF、およびSF（以下、「SFCデバイス」と呼びます）は、選択され、吟味され、アクティブに保守されていると想定されます。したがって、それらはそのオペレーターによって信頼されます。この仮定は、デバイスが信頼されていないことがよくある見解とは異なり、「ゼロトラストモデル」と呼ばれることがよくあります。オペレーターは、これらのデバイスを定期的に監視（つまり、継続的に監査）して、準拠した動作を保証する必要があります。したがって、この信頼はNSH操作にまで及びます。SFCデバイス自体は、攻撃ベクトルとは見なされません。これはオペレーターの姿勢の基本であるので、この仮定と結果の結論は合理的です。オペレーターはこの現実に依存して機能します。これらのデバイスが信頼されておらず、実際に侵害されている場合、事業者の標準ベースのIPおよびMPLSプロトコルスイートのほぼ全体が脆弱です。したがって、ネットワーク全体の操作が危険にさらされます。妥協点を検出するための十分に文書化された監視ベースの方法（継続的な監視と監査およびログのレビューが含まれているなど）がありますが、これらは完全に危害を加えた要素による損傷を封じ込めるには不十分な場合があります。"
    },
    {
      "indent": 6,
      "text": "Methods and best practices to secure devices are also widely documented and outside the scope of this document.",
      "ja": "デバイスを保護する方法とベストプラクティスも広く文書化されており、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Single Domain Boundary",
      "ja": "単一ドメイン境界"
    },
    {
      "indent": 6,
      "text": "As per [RFC7665], NSH is designed for use within a single administrative domain. This scoping provides two important characteristics:",
      "ja": "[RFC7665]に従い、NSHは単一の管理ドメイン内で使用するように設計されています。このスコープには、2つの重要な特性があります。"
    },
    {
      "indent": 6,
      "text": "i) Clear NSH boundaries",
      "ja": "i) NSH境界をクリア"
    },
    {
      "indent": 6,
      "text": "NSH egress devices MUST strip the NSH headers before they send the users' packets or frames out of the NSH domain.",
      "ja": "NSH出力デバイスは、ユーザーのパケットまたはフレームをNSHドメインから送信する前に、NSHヘッダーを削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "Means to prevent leaking privacy-related information outside an administrative domain are natively supported by the NSH given that the last SFF of a service path will systematically remove the NSH encapsulation before forwarding a packet exiting the service path.",
      "ja": "サービスパスから出るパケットを転送する前に、サービスパスの最後のSFFがNSHカプセル化を体系的に削除する場合、管理ドメインの外にプライバシー関連情報が漏洩するのを防ぐ手段がNSHによってネイティブにサポートされます。"
    },
    {
      "indent": 6,
      "text": "The second step in such prevention is to filter the transport encapsulation protocol used by NSH at the domain edge. The transport encapsulation protocol MUST be filtered and MUST NOT leave the domain edge.",
      "ja": "そのような防止の2番目のステップは、ドメインエッジでNSHによって使用されるトランスポートカプセル化プロトコルをフィルタリングすることです。トランスポートカプセル化プロトコルはフィルタリングする必要があり、ドメインエッジから出てはなりません。"
    },
    {
      "indent": 6,
      "text": "Depending upon the transport encapsulation protocol used for NSH, this can be done either by completely blocking the transport encapsulation (e.g., if MPLS is the chosen NSH transport encapsulation protocol, it is therefore never allowed to leave the domain) or by examining the carried protocol with the transport encapsulation (e.g., if VXLAN-gpe is used as the NSH transport encapsulation protocol, all domain edges need to filter based on the carried protocol in the VXLAN-gpe.)",
      "ja": "これは、NSHに使用されるトランスポートカプセル化プロトコルに応じて、トランスポートカプセル化を完全にブロックする（たとえば、MPLSが選択されたNSHトランスポートカプセル化プロトコルである場合、ドメインを離れることは決してできない）か、実行されたプロトコルを調べることによって実行できます。トランスポートカプセル化（たとえば、VXLAN-gpeがNSHトランスポートカプセル化プロトコルとして使用される場合、すべてのドメインエッジはVXLAN-gpeで実行されるプロトコルに基づいてフィルタリングする必要があります。）"
    },
    {
      "indent": 6,
      "text": "The other consequence of this bounding is that ingress packets MUST also be filtered to prevent attackers from sending in NSH packets with service path identification and metadata of their own selection. The same filters as described above for both the NSH at SFC devices and for the transport encapsulation protocol as general edge protections MUST be applied on ingress.",
      "ja": "この境界のもう1つの結果は、攻撃者がサービスパスIDと独自に選択したメタデータを含むNSHパケットを送信しないように、入力パケットもフィルタリングする必要があることです。 SFCデバイスでのNSHとトランスポートカプセル化プロトコルの両方について上記で説明したものと同じフィルターは、一般的なエッジ保護を入口で適用する必要があります。"
    },
    {
      "indent": 6,
      "text": "In summary, packets originating outside the SFC-enabled domain MUST be dropped if they contain an NSH. Similarly, packets exiting the SFC-enabled domain MUST be dropped if they contain an NSH.",
      "ja": "要約すると、SFCが有効なドメイン外から発信されたパケットは、NSHが含まれている場合はドロップする必要があります。同様に、SFC対応ドメインを出るパケットは、NSHが含まれている場合はドロップする必要があります。"
    },
    {
      "indent": 6,
      "text": "ii) Mitigation of external threats",
      "ja": "ii）外部の脅威の軽減"
    },
    {
      "indent": 6,
      "text": "As per the trusted SFC device points raised above, given that NSH is scoped within an operator's domain, that operator can ensure that the environment and its transitive properties comply with that operator's required security posture. Continuous audits for assurance are recommended with this reliance on a fully trusted environment. The term \"continuous audits\" describes a method (automated or manual) of checking security-control compliance on a regular basis, at some set period of time.",
      "ja": "上記の信頼できるSFCデバイスポイントに従って、NSHがオペレーターのドメイン内にスコープされている場合、そのオペレーターは、環境とその推移的なプロパティがそのオペレーターに必要なセキュリティ体制に準拠していることを確認できます。完全に信頼された環境への依存により、保証のための継続的な監査が推奨されます。 「継続的監査」という用語は、一定の期間に定期的にセキュリティ管理のコンプライアンスをチェックする方法（自動または手動）を表します。"
    },
    {
      "indent": 0,
      "text": "8.2. NSH Security Considerations from the SFC Architecture",
      "section_title": true,
      "ja": "8.2. SFCアーキテクチャからのNSHセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The SFC architecture defines functional roles (e.g., SFF), as well as protocol elements (e.g., Metadata). This section considers each role and element in the context of threats posed in the areas of integrity and confidentiality. As with routing, the distributed computation model assumes a distributed trust model.",
      "ja": "SFCアーキテクチャは、機能的な役割（SFFなど）とプロトコル要素（メタデータなど）を定義します。このセクションでは、整合性と機密性の領域でもたらされる脅威のコンテキストで、各役割と要素を検討します。ルーティングと同様に、分散計算モデルは分散信頼モデルを前提としています。"
    },
    {
      "indent": 3,
      "text": "An important consideration is that NSH contains mandatory-to-mute fields, and further, the SFC architecture describes cases where other fields in NSH change, all on a possible SFP hop-by-hop basis. This means that any cryptographic solution requires complex key distribution and life-cycle operations.",
      "ja": "重要な考慮事項は、NSHにミュート必須フィールドが含まれていること、さらにSFCアーキテクチャでは、NSHの他のフィールドがすべて可能なSFPホップバイホップベースで変更される場合について説明していることです。つまり、暗号化ソリューションには、複雑な鍵の配布とライフサイクルの運用が必要です。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Integrity",
      "section_title": true,
      "ja": "8.2.1. 誠実さ"
    },
    {
      "indent": 3,
      "text": "SFC devices",
      "ja": "SFCデバイス"
    },
    {
      "indent": 6,
      "text": "SFC devices MAY perform various forms of verification on received NSH packets such as only accepting NSH packets from expected devices, checking that NSH SPI and SI values received from expected devices conform to expected values and so on. Implementation of these additional checks are a local matter and, thus, out of scope of this document.",
      "ja": "SFCデバイスは、期待されるデバイスからのNSHパケットのみを受け入れる、期待されるデバイスから受信されるNSH SPIおよびSI値が期待される値に準拠することを確認するなど、受信したNSHパケットに対してさまざまな形式の検証を実行できます（MAY）。これらの追加のチェックの実装はローカルな問題であるため、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "NSH Base and Service Path Headers",
      "ja": "NSHベースおよびサービスパスヘッダー"
    },
    {
      "indent": 6,
      "text": "Attackers who can modify packets within the operator's network may be able to modify the SFP, path position, and/or the metadata associated with a packet.",
      "ja": "オペレーターのネットワーク内でパケットを変更できる攻撃者は、SFP、パスの位置、および/またはパケットに関連付けられたメタデータを変更できる可能性があります。"
    },
    {
      "indent": 6,
      "text": "One specific concern is an attack in which a malicious modification of the SPI/SI results in an alteration of the path to avoid security devices. The options discussed in this section help thwart that attack, and so does the use of the optional \"Proof of Transit\" method [PROOF-OF-TRANSIT].",
      "ja": "具体的な懸念の1つは、SPI / SIの悪意のある変更により、セキュリティデバイスを回避するためにパスが変更される攻撃です。このセクションで説明するオプションは、その攻撃を阻止するのに役立ち、オプションの「Proof of Transit」メソッド[PROOF-OF-TRANSIT]の使用もそうします。"
    },
    {
      "indent": 6,
      "text": "As stated above, SFC devices are trusted; in the case where an SFC device is compromised, NSH integrity protection would be subject to forging (in many cases) as well.",
      "ja": "上記のように、SFCデバイスは信頼されています。 SFCデバイスが危険にさらされている場合、NSHの整合性保護は（多くの場合）偽造の対象にもなります。"
    },
    {
      "indent": 6,
      "text": "NSH itself does not mandate protocol-specific integrity protection. However, if an operator deems protection is required, several options are viable:",
      "ja": "NSH自体は、プロトコル固有の整合性保護を義務付けていません。ただし、オペレーターが保護が必要であると考える場合、いくつかのオプションが実行可能です。"
    },
    {
      "indent": 6,
      "text": "1. SFF/SF NSH verification",
      "ja": "1. SFF / SF NSH検証"
    },
    {
      "indent": 10,
      "text": "Although, strictly speaking, not integrity protection, some of the techniques mentioned above, such as checking expected NSH values are received from expected SFC device(s), can provide a form of verification without incurring the burden of a full-fledged integrity-protection deployment.",
      "ja": "厳密に言うと整合性保護ではありませんが、期待されるNFC値が予期されるSFCデバイスから受信されることの確認など、上記の手法の一部は、完全な整合性保護の負担を負うことなく、検証の形式を提供できます。展開。"
    },
    {
      "indent": 6,
      "text": "2. Transport Security",
      "ja": "2. 輸送セキュリティ"
    },
    {
      "indent": 10,
      "text": "NSH is always encapsulated by an outer transport encapsulation as detailed in Section 4 of this specification, and as depicted in Figure 1. If an operator deems cryptographic integrity protection necessary due to their risk analysis, then an outer transport encapsulation that provides such protection [RFC6071], such as IPsec, MUST be used.",
      "ja": "この仕様のセクション4で詳述されているように、図1に示すように、NSHは常に外部トランスポートカプセル化によってカプセル化されます。オペレーターがリスク分析のために暗号整合性保護が必要であると判断した場合、そのような保護を提供する外部トランスポートカプセル化[RFC6071 ]、IPsecなどを使用する必要があります。"
    },
    {
      "indent": 10,
      "text": "Although the threat model and recommendations of Section 5 of BCP 72 [RFC3552] would normally require cryptographic data origin authentication for the header, this document does not mandate such mechanisms in order to reflect the operational and technical realities of deployment.",
      "ja": "BCP 72 [RFC3552]のセクション5の脅威モデルと推奨事項では、通常、ヘッダーに暗号データ​​の起点認証が必要ですが、このドキュメントでは、運用の技術的展開を反映するためにそのようなメカニズムを義務付けていません。"
    },
    {
      "indent": 10,
      "text": "Given that NSH is transport independent, as mentioned above, a secure transport, such as IPsec can be used for carry NSH. IPsec can be used either alone or in conjunction with other transport encapsulation protocols, in turn, encapsulating NSH.",
      "ja": "前述のように、NSHはトランスポートに依存しないため、IPsecなどの安全なトランスポートを使用してNSHを伝送できます。 IPsecは、単独で使用することも、他のトランスポートカプセル化プロトコルと組み合わせて使用​​して、NSHをカプセル化することもできます。"
    },
    {
      "indent": 10,
      "text": "Operators MUST ensure the selected transport encapsulation protocol can be supported by the transport encapsulation/ underlay of all relevant network segments as well as SFFs, SFs, and SFC Proxies in the service path.",
      "ja": "オペレーターは、選択されたトランスポートカプセル化プロトコルが、関連するすべてのネットワークセグメントのトランスポートカプセル化/アンダーレイ、およびサービスパスのSFF、SF、SFCプロキシによってサポートされることを確認する必要があります。"
    },
    {
      "indent": 10,
      "text": "If connectivity between SFC-enabled devices traverses the public Internet, then such connectivity MUST be secured at the transport encapsulation layer. IPsec is an example of such a transport.",
      "ja": "SFC対応デバイス間の接続がパブリックインターネットを通過する場合、そのような接続はトランスポートカプセル化層で保護する必要があります。 IPsecはそのようなトランスポートの例です。"
    },
    {
      "indent": 6,
      "text": "3. NSH Variable Header-Based Integrity",
      "ja": "3. NSH可変ヘッダーベースの整合性"
    },
    {
      "indent": 10,
      "text": "Lastly, NSH MD Type 2 provides, via variable-length headers, the ability to append cryptographic integrity protection to the NSH packet. The implementation of such a scheme is outside the scope of this document.",
      "ja": "最後に、NSH MD Type 2は、可変長ヘッダーを介して、NSHパケットに暗号化の完全性保護を追加する機能を提供します。このようなスキームの実装は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "NSH metadata",
      "ja": "NSHメタデータ"
    },
    {
      "indent": 6,
      "text": "As with the Base and Service Path Headers, if an operator deems cryptographic integrity protection needed, then an existing, standard transport protocol MUST be used since the integrity protection applies to entire encapsulated NSH packets. As mentioned above, a risk assessment that deems data-plane traffic subject to tampering will apply not only to NSH but to the transport information; therefore, the use of a secure transport is likely needed already to protect the entire stack.",
      "ja": "完全性保護はカプセル化されたNSHパケット全体に適用されるため、ベースおよびサービスパスヘッダーと同様に、オペレーターが暗号化完全性保護が必要であると見なす場合は、既存の標準トランスポートプロトコルを使用する必要があります。上記のように、改ざんの対象となるデータプレーントラフィックと見なすリスク評価は、NSHだけでなくトランスポート情報にも適用されます。したがって、スタック全体を保護するために、安全なトランスポートの使用がすでに必要とされている可能性があります。"
    },
    {
      "indent": 6,
      "text": "If an MD Type 2 variable header integrity scheme is in place, then the integrity of the metadata can be ensured via that mechanism as well.",
      "ja": "MD Type 2可変ヘッダー整合性スキームが導入されている場合、メタデータの整合性はそのメカニズムによっても保証されます。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Confidentiality",
      "section_title": true,
      "ja": "8.2.2. 守秘義務"
    },
    {
      "indent": 3,
      "text": "SFC devices",
      "ja": "SFCデバイス"
    },
    {
      "indent": 6,
      "text": "SFC devices can \"see\" (and need to use) NSH information.",
      "ja": "SFCデバイスはNSH情報を「見る」ことができます（使用する必要があります）。"
    },
    {
      "indent": 3,
      "text": "NSH Base and Service Path Headers",
      "ja": "NSHベースおよびサービスパスヘッダー"
    },
    {
      "indent": 6,
      "text": "SPI and other base / service path information does not typically require confidentiality; however, if an operator does deem confidentiality to be required, then, as with integrity, an existing transport encapsulation that provides encryption MUST be utilized.",
      "ja": "SPIおよびその他のベース/サービスパス情報は通常、機密性を要求しません。ただし、オペレーターが機密性が必要であると考える場合は、整合性と同様に、暗号化を提供する既存のトランスポートカプセル化を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "NSH metadata",
      "ja": "NSHメタデータ"
    },
    {
      "indent": 6,
      "text": "An attacker with access to the traffic in an operator's network can potentially observe the metadata NSH carries with packets, potentially discovering privacy-sensitive information.",
      "ja": "オペレーターのネットワーク内のトラフィックにアクセスできる攻撃者は、NSHがパケットとともに運ぶメタデータを観察する可能性があり、プライバシーに敏感な情報を発見する可能性があります。"
    },
    {
      "indent": 6,
      "text": "Much of the metadata carried by NSH is not sensitive. It often reflects information that can be derived from the underlying packet or frame. Direct protection of such information is not necessary, as the risks are simply those of carrying the underlying packet or frame.",
      "ja": "NSHによって運ばれるメタデータの多くは機密ではありません。それはしばしば、基礎となるパケットまたはフレームから導出できる情報を反映しています。リスクは、基礎となるパケットまたはフレームを運ぶリスクに過ぎないため、このような情報を直接保護する必要はありません。"
    },
    {
      "indent": 6,
      "text": "Implementers and operators MUST be aware that metadata can have privacy implications, and those implications are sometimes hard to predict. Therefore, attached metadata should be limited to that necessary for correct operation of the SFP. Further, [RFC8165] defines metadata considerations that operators can take into account when using NSH.",
      "ja": "メタデータはプライバシーに影響を与える可能性があり、それらの影響を予測することが難しい場合があることを実装者とオペレーターは認識しなければなりません。したがって、添付されたメタデータは、SFPの正常な動作に必要なものに限定する必要があります。さらに、[RFC8165]は、NSHを使用するときにオペレーターが考慮できるメタデータの考慮事項を定義しています。"
    },
    {
      "indent": 6,
      "text": "Protecting NSH metadata information between SFC components can be done using transport encapsulation protocols with suitable security capabilities, along the lines discussed above. If a security analysis deems these protections necessary, then security features in the transport encapsulation protocol (such as IPsec) MUST be used.",
      "ja": "SFCコンポーネント間のNSHメタデータ情報の保護は、上記の説明に従って、適切なセキュリティ機能を備えたトランスポートカプセル化プロトコルを使用して実行できます。セキュリティ分析でこれらの保護が必要であると判断された場合は、トランスポートカプセル化プロトコル（IPsecなど）のセキュリティ機能を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "One useful element of providing privacy protection for sensitive metadata is described under the \"SFC Encapsulation\" area of the Security Considerations of [RFC7665]. Operators can and should use indirect identification for metadata deemed to be sensitive (such as personally identifying information), significantly mitigating the risk of a privacy violation. In particular, subscriber-identifying information should be handled carefully, and, in general, SHOULD be obfuscated.",
      "ja": "機密メタデータのプライバシー保護を提供する1つの有用な要素は、[RFC7665]のセキュリティに関する考慮事項の「SFCカプセル化」領域で説明されています。オペレーターは、機密性が高いと見なされるメタデータ（個人を特定する情報など）に間接的な識別を使用できるため、プライバシー違反のリスクを大幅に軽減できます。特に、加入者を特定する情報は慎重に処理する必要があり、一般に、難読化する必要があります。"
    },
    {
      "indent": 6,
      "text": "For those situations where obfuscation is either inapplicable or judged to be insufficient, an operator can also encrypt the metadata. An approach to an optional capability to do this was explored in [NSH-ENCRYPT]. For other situations where greater assurance is desired, optional mechanisms such as [PROOF-OF-TRANSIT] can be used.",
      "ja": "難読化が適用できないか不十分であると判断される状況では、オペレーターはメタデータを暗号化することもできます。これを行うためのオプション機能へのアプローチは、[NSH-ENCRYPT]で調査されました。より高い保証が望まれる他の状況では、[PROOF-OF-TRANSIT]などのオプションのメカニズムを使用できます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. NSH Parameters",
      "section_title": true,
      "ja": "9.1. NSHパラメータ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new \"Network Service Header (NSH) Parameters\" registry. The following subsections detail new registries within the \"Network Service Header (NSH) Parameters\" registry.",
      "ja": "IANAは新しい「ネットワークサービスヘッダー（NSH）パラメータ」レジストリを作成しました。以下のサブセクションでは、「ネットワークサービスヘッダー（NSH）パラメータ」レジストリ内の新しいレジストリについて詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "9.1.1. NSH Base Header Bits",
      "section_title": true,
      "ja": "9.1.1. NSHベースヘッダービット"
    },
    {
      "indent": 3,
      "text": "There are five unassigned bits (U bits) in the NSH Base Header, and one assigned bit (O bit). New bits are assigned via Standards Action [RFC8126].",
      "ja": "NSHベースヘッダーには5つの未割り当てビット（Uビット）と1つの割り当て済みビット（Oビット）があります。新しいビットは、標準アクション[RFC8126]を介して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Bit 2 - O (OAM) bit Bit 3 - Unassigned Bits 16-19 - Unassigned",
      "ja": "ビット2-O（OAM）ビットビット3-未割り当てビット16〜19-未割り当て"
    },
    {
      "indent": 0,
      "text": "9.1.2. NSH Version",
      "section_title": true,
      "ja": "9.1.2. NSHバージョン"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH Version\" registry. New values are assigned via Standards Action [RFC8126].",
      "ja": "IANAは「NSHバージョン」レジストリを設定しました。新しい値は、標準アクション[RFC8126]を介して割り当てられます。"
    },
    {
      "indent": 7,
      "text": "+-------------+---------------------------------+-----------+\n| Version     | Description                     | Reference |\n+-------------+---------------------------------+-----------+\n| Version 00b | Protocol as defined by RFC 8300 | RFC 8300  |\n| Version 01b | Reserved                        | RFC 8300  |\n| Version 10b | Unassigned                      |           |\n| Version 11b | Unassigned                      |           |\n+-------------+---------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Table 5: NSH Version",
      "ja": "表5：NSHバージョン"
    },
    {
      "indent": 0,
      "text": "9.1.3. NSH MD Types",
      "section_title": true,
      "ja": "9.1.3. NSH MDタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH MD Types\" registry, which contains 4-bit values. MD Type values 0x0, 0x1, 0x2, and 0xF are specified in this document; see Table 6. Registry entries are assigned via the \"IETF Review\" policy defined in RFC 8126 [RFC8126].",
      "ja": "IANAは、4ビットの値を含む「NSH MD Types」レジストリを設定しました。このドキュメントでは、MDタイプ値0x0、0x1、0x2、および0xFが指定されています。表6を参照してください。レジストリエントリは、RFC 8126 [RFC8126]で定義されている「IETFレビュー」ポリシーによって割り当てられます。"
    },
    {
      "indent": 16,
      "text": "+-----------+-----------------+-----------+\n| MD Type   | Description     | Reference |\n+-----------+-----------------+-----------+\n| 0x0       | Reserved        | RFC 8300  |\n|           |                 |           |\n| 0x1       | NSH MD Type 1   | RFC 8300  |\n|           |                 |           |\n| 0x2       | NSH MD Type 2   | RFC 8300  |\n|           |                 |           |\n| 0x3 - 0xE | Unassigned      |           |\n|           |                 |           |\n| 0xF       | Experimentation | RFC 8300  |\n+-----------+-----------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Table 6: MD Type Values",
      "ja": "表6：MDタイプの値"
    },
    {
      "indent": 0,
      "text": "9.1.4. NSH MD Class",
      "section_title": true,
      "ja": "9.1.4. NSH MDクラス"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH MD Class\" registry, which contains 16-bit values. New allocations are to be made according to the following policies:",
      "ja": "IANAは、16ビット値を含む「NSH MD Class」レジストリをセットアップしました。新しい割り当ては、次のポリシーに従って行われます。"
    },
    {
      "indent": 3,
      "text": "0x0000 to 0x01ff: IETF Review 0x0200 to 0xfff5: Expert Review",
      "ja": "0x0000〜0x01ff：IETFレビュー0x0200〜0xfff5：エキスパートレビュー"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the values as follows:",
      "ja": "IANAは次のように値を割り当てました。"
    },
    {
      "indent": 8,
      "text": "+------------------+------------------------+------------+\n| Value            | Meaning                | Reference  |\n+------------------+------------------------+------------+\n| 0x0000           | IETF Base NSH MD Class | RFC 8300   |\n|                  |                        |            |\n| 0xfff6 to 0xfffe | Experimental           | RFC 8300   |\n|                  |                        |            |\n| 0xffff           | Reserved               | RFC 8300   |\n+------------------+------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Table 7: NSH MD Class",
      "ja": "表7：NSH MDクラス"
    },
    {
      "indent": 3,
      "text": "A registry for Types for the MD Class of 0x0000 is defined in Section 9.1.5.",
      "ja": "0x0000のMDクラスのタイプのレジストリは、セクション9.1.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "Designated Experts evaluating new allocation requests from the \"Expert Review\" range should principally consider whether a new MD class is needed compared to adding MD Types to an existing class. The Designated Experts should also encourage the existence of an associated and publicly visible registry of MD Types although this registry need not be maintained by IANA.",
      "ja": "「エキスパートレビュー」の範囲からの新しい割り当てリクエストを評価する指定エキスパートは、MDタイプを既存のクラスに追加するのと比較して、新しいMDクラスが必要かどうかを主に検討する必要があります。 Designated Expertsは、MDタイプの関連付けられた公開されているレジストリの存在を奨励する必要がありますが、このレジストリはIANAで管理する必要はありません。"
    },
    {
      "indent": 3,
      "text": "When evaluating a request for an allocation, the Expert should verify that the allocation plan includes considerations to handle privacy and security issues associated with the anticipated individual MD Types allocated within this class. These plans should consider, when appropriate, alternatives such as indirection, encryption, and limited-deployment scenarios. Information that can't be directly derived from viewing the packet contents should be examined for privacy and security implications.",
      "ja": "割り当てのリクエストを評価するとき、エキスパートは割り当て計画に、このクラス内で割り当てられると予想される個々のMDタイプに関連するプライバシーとセキュリティの問題を処理するための考慮事項が含まれていることを確認する必要があります。これらの計画では、必要に応じて、間接参照、暗号化、制限された展開シナリオなどの代替案を検討する必要があります。パケットの内容の表示から直接取得できない情報は、プライバシーとセキュリティへの影響について調査する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.1.5. NSH IETF-Assigned Optional Variable-Length Metadata Types",
      "section_title": true,
      "ja": "9.1.5. NSH IETFが割り当てたオプションの可変長メタデータタイプ"
    },
    {
      "indent": 3,
      "text": "The Type values within the IETF Base NSH MD Class, i.e., when the MD Class is set to 0x0000 (see Section 9.1.4), are the Types owned by the IETF. Per this document, IANA has created a registry for the Type values for the IETF Base NSH MD Class called the \"NSH IETF-Assigned Optional Variable-Length Metadata Types\" registry, as specified in Section 2.5.1.",
      "ja": "IETFベースNSH MDクラス内のタイプ値、つまりMDクラスが0x0000に設定されている場合（セクション9.1.4を参照）は、IETFが所有するタイプです。このドキュメントに従って、IANAは、セクション2.5.1で指定されている「NSH IETF-Assigned Optional Variable-Length Metadata Types」レジストリと呼ばれるIETF Base NSH MDクラスのType値のレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The type values are assigned via Standards Action [RFC8126].",
      "ja": "タイプ値は、標準アクション[RFC8126]によって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "No initial values are assigned at the creation of the registry.",
      "ja": "レジストリの作成時に初期値は割り当てられません。"
    },
    {
      "indent": 0,
      "text": "9.1.6. NSH Next Protocol",
      "section_title": true,
      "ja": "9.1.6. NSH次のプロトコル"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH Next Protocol\" registry, which contains 8-bit values. Next Protocol values 0, 1, 2, 3, 4, and 5 are defined in this document (see Table 8). New values are assigned via \"Expert Review\" as per [RFC8126].",
      "ja": "IANAは、8ビット値を含む「NSH Next Protocol」レジストリをセットアップしました。次のプロトコル値0、1、2、3、4、および5は、このドキュメントで定義されています（表8を参照）。 [RFC8126]に従って、「エキスパートレビュー」を介して新しい値が割り当てられます。"
    },
    {
      "indent": 15,
      "text": "+---------------+--------------+-----------+\n| Next Protocol | Description  | Reference |\n+---------------+--------------+-----------+\n| 0x00          | Unassigned   |           |\n|               |              |           |\n| 0x01          | IPv4         | RFC 8300  |\n|               |              |           |\n| 0x02          | IPv6         | RFC 8300  |\n|               |              |           |\n| 0x03          | Ethernet     | RFC 8300  |\n|               |              |           |\n| 0x04          | NSH          | RFC 8300  |\n|               |              |           |\n| 0x05          | MPLS         | RFC 8300  |\n|               |              |           |\n| 0x06 - 0xFD   | Unassigned   |           |\n|               |              |           |\n| 0xFE          | Experiment 1 | RFC 8300  |\n|               |              |           |\n| 0xFF          | Experiment 2 | RFC 8300  |\n+---------------+--------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 8: NSH Base Header Next Protocol Values",
      "ja": "表8：NSHベースヘッダーの次のプロトコル値"
    },
    {
      "indent": 3,
      "text": "Expert Review requests MUST include a single codepoint per request. Designated Experts evaluating new allocation requests from this registry should consider the potential scarcity of codepoints for an 8-bit value, and check both for duplications and availability of documentation. If the actual assignment of the Next Protocol field allocation reaches half of the range (that is, when there are 128 unassigned values), IANA needs to alert the IESG. At that point, a new more strict allocation policy SHOULD be considered.",
      "ja": "Expert Reviewリクエストには、リクエストごとに1つのコードポイントを含める必要があります。このレジストリからの新しい割り当て要求を評価する指定エキスパートは、8ビット値のコードポイントの潜在的な不足を考慮し、重複とドキュメントの可用性の両方をチェックする必要があります。 Next Protocolフィールド割り当ての実際の割り当てが範囲の半分に達した場合（つまり、128の未割り当ての値がある場合）、IANAはIESGに警告する必要があります。その時点で、より厳密な新しい割り当てポリシーを検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. NSH-Related Codepoints",
      "section_title": true,
      "ja": "10. NSH関連のコードポイント"
    },
    {
      "indent": 0,
      "text": "10.1. NSH Ethertype",
      "section_title": true,
      "ja": "10.1. NSH Ethertype"
    },
    {
      "indent": 3,
      "text": "An IEEE Ethertype, 0x894F, has been allocated for NSH.",
      "ja": "IEEE Ethertype、0x894FがNSHに割り当てられています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function Chaining (SFC) Architecture\", RFC 7665, DOI 10.17487/RFC7665, October 2015, <https://www.rfc-editor.org/info/rfc7665>.",
      "ja": "[RFC7665] Halpern、J.、Ed。 C. Pignataro、編、「Service Function Chaining（SFC）Architecture」、RFC 7665、DOI 10.17487 / RFC7665、2015年10月、<https://www.rfc-editor.org/info/rfc7665>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]コットン、M。、レイバ、B。、およびT.ナルテン、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[NSH-BROADBAND-ALLOCATION] Napper, J., Kumar, S., Muley, P., Henderickx, W., and M. Boucadair, \"NSH Context Header Allocation -- Broadband\", Work in Progress, draft-napper-sfc-nsh-broadband-allocation-04, November 2017.",
      "ja": "[NSH-BROADBAND-ALLOCATION] Napper、J.、Kumar、S.、Mulley、P.、Henderickx、W。、およびM. Boucadair、「NSH Context Header Allocation-Broadband」、Work in Progress、draft-napper- sfc-nsh-broadband-allocation-04、2017年11月。"
    },
    {
      "indent": 3,
      "text": "[NSH-DC-ALLOCATION] Guichard, J., Smith, M., Kumar, S., Majee, S., Agarwal, P., Glavin, K., Laribi, Y., and T. Mizrahi, \"Network Service Header (NSH) MD Type 1: Context Header Allocation (Data Center)\", Work in Progress, draft-guichard-sfc-nsh-dc-allocation-07, August 2017.",
      "ja": "[NSH-DC-ALLOCATION] Guichard、J.、Smith、M.、Kumar、S.、Majee、S.、Agarwal、P.、Glavin、K.、Laribi、Y。、およびT. Mizrahi、「ネットワークサービスヘッダー（NSH）MDタイプ1：コンテキストヘッダー割り当て（データセンター） \"、作業中、draft-guichard-sfc-nsh-dc-allocation-07、2017年8月。"
    },
    {
      "indent": 3,
      "text": "[NSH-ENCRYPT] Reddy, T., Patil, P., Fluhrer, S., and P. Quinn, \"Authenticated and encrypted NSH service chains\", Work in Progress, draft-reddy-sfc-nsh-encrypt-00, April 2015.",
      "ja": "[NSH-ENCRYPT] Reddy、T.、Patil、P.、Fluhrer、S。、およびP. Quinn、「認証および暗号化されたNSHサービスチェーン」、Work in Progress、draft-reddy-sfc-nsh-encrypt-00、 2015年4月。"
    },
    {
      "indent": 3,
      "text": "[PROOF-OF-TRANSIT] Brockners, F., Bhandari, S., Dara, S., Pignataro, C., Leddy, J., Youell, S., Mozes, D., and T. Mizrahi, \"Proof of Transit\", Work in Progress, draft-brockners-proof-of-transit-04, October 2017.",
      "ja": "[PROOF-OF TRANSIT] Brockners、F.、Bhandari、S.、Dara、S.、Pignataro、C.、Leddy、J.、Youell、S.、Mozes、D.、and T. Mizrahi、 \"Proof of Transit \"、Work in Progress、draft-brockners-proof-of-transit-04、2017年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2784] Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, \"Generic Routing Encapsulation (GRE)\", RFC 2784, DOI 10.17487/RFC2784, March 2000, <https://www.rfc-editor.org/info/rfc2784>.",
      "ja": "[RFC2784] Farinacci、D.、Li、T。、ハンクス、S.、Meyer、D。、およびP. Traina、「Generic Routing Encapsulation（GRE）」、RFC 2784、DOI 10.17487 / RFC2784、2000年3月、<https ：//www.rfc-editor.org/info/rfc2784>。"
    },
    {
      "indent": 3,
      "text": "[RFC3552] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.",
      "ja": "[RFC3552] Rescorla、E。およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストの記述に関するガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/ info / rfc3552>。"
    },
    {
      "indent": 3,
      "text": "[RFC3692] Narten, T., \"Assigning Experimental and Testing Numbers Considered Useful\", BCP 82, RFC 3692, DOI 10.17487/RFC3692, January 2004, <https://www.rfc-editor.org/info/rfc3692>.",
      "ja": "[RFC3692] Narten、T。、「Assigning Testing and Testing Numbers考慮された有用」、BCP 82、RFC 3692、DOI 10.17487 / RFC3692、2004年1月、<https://www.rfc-editor.org/info/rfc3692>。"
    },
    {
      "indent": 3,
      "text": "[RFC6071] Frankel, S. and S. Krishnan, \"IP Security (IPsec) and Internet Key Exchange (IKE) Document Roadmap\", RFC 6071, DOI 10.17487/RFC6071, February 2011, <https://www.rfc-editor.org/info/rfc6071>.",
      "ja": "[RFC6071]フランケルS.およびS.クリシュナン、「IP Security（IPsec）and Internet Key Exchange（IKE）Document Roadmap」、RFC 6071、DOI 10.17487 / RFC6071、2011年2月、<https：//www.rfc-editor .org / info / rfc6071>。"
    },
    {
      "indent": 3,
      "text": "[RFC6291] Andersson, L., van Helvoort, H., Bonica, R., Romascanu, D., and S. Mansfield, \"Guidelines for the Use of the \"OAM\" Acronym in the IETF\", BCP 161, RFC 6291, DOI 10.17487/RFC6291, June 2011, <https://www.rfc-editor.org/info/rfc6291>.",
      "ja": "[RFC6291] Andersson、L.、van Helvoort、H.、Bonica、R.、Romascanu、D。、およびS. Mansfield、「IETFでの「OAM」の頭字語の使用に関するガイドライン」、BCP 161、RFC 6291 、DOI 10.17487 / RFC6291、2011年6月、<https://www.rfc-editor.org/info/rfc6291>。"
    },
    {
      "indent": 3,
      "text": "[RFC7325] Villamizar, C., Ed., Kompella, K., Amante, S., Malis, A., and C. Pignataro, \"MPLS Forwarding Compliance and Performance Requirements\", RFC 7325, DOI 10.17487/RFC7325, August 2014, <https://www.rfc-editor.org/info/rfc7325>.",
      "ja": "[RFC7325] Villamizar、C.、Ed。、Kompella、K.、Amante、S.、Malis、A.、and C. Pignataro、 \"MPLS Forwarding Compliance and Performance Requirements\"、RFC 7325、DOI 10.17487 / RFC7325、August 2014 、<https://www.rfc-editor.org/info/rfc7325>。"
    },
    {
      "indent": 3,
      "text": "[RFC7498] Quinn, P., Ed. and T. Nadeau, Ed., \"Problem Statement for Service Function Chaining\", RFC 7498, DOI 10.17487/RFC7498, April 2015, <https://www.rfc-editor.org/info/rfc7498>.",
      "ja": "[RFC7498]クイン、P。、エド。 T.ナドー編、「サービス機能連鎖の問題ステートメント」、RFC 7498、DOI 10.17487 / RFC7498、2015年4月、<https://www.rfc-editor.org/info/rfc7498>。"
    },
    {
      "indent": 3,
      "text": "[RFC7676] Pignataro, C., Bonica, R., and S. Krishnan, \"IPv6 Support for Generic Routing Encapsulation (GRE)\", RFC 7676, DOI 10.17487/RFC7676, October 2015, <https://www.rfc-editor.org/info/rfc7676>.",
      "ja": "[RFC7676] Pignataro、C.、Bonica、R。、およびS. Krishnan、「IPv6 Support for Generic Routing Encapsulation（GRE）」、RFC 7676、DOI 10.17487 / RFC7676、2015年10月、<https：//www.rfc- editor.org/info/rfc7676>。"
    },
    {
      "indent": 3,
      "text": "[RFC8165] Hardie, T., \"Design Considerations for Metadata Insertion\", RFC 8165, DOI 10.17487/RFC8165, May 2017, <https://www.rfc-editor.org/info/rfc8165>.",
      "ja": "[RFC8165] Hardie、T。、「メタデータ挿入の設計上の考慮事項」、RFC 8165、DOI 10.17487 / RFC8165、2017年5月、<https://www.rfc-editor.org/info/rfc8165>。"
    },
    {
      "indent": 3,
      "text": "[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>.",
      "ja": "[RFC8201] McCann、J.、Deering、S.、Mogul、J。、およびR. Hinden、編、「Path MTU Discovery for IP version 6」、STD 87、RFC 8201、DOI 10.17487 / RFC8201、2017年7月<https://www.rfc-editor.org/info/rfc8201>。"
    },
    {
      "indent": 3,
      "text": "[RTG-ENCAP] Nordmark, E., Tian, A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P., and T. Herbert, \"Encapsulation Considerations\", Work in Progress, draft-ietf-rtgwg-dt-encap-02, October 2016.",
      "ja": "[RTG-ENCAP] Nordmark、E.、Tian、A.、Gross、J.、Hudson、J.、Kreeger、L.、Garg、P.、Thaler、P。、およびT. Herbert、「カプセル化に関する考慮事項」、 Work in Progress、draft-ietf-rtgwg-dt-encap-02、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[SFC-CONTROL-PLANE] Boucadair, M., \"Service Function Chaining (SFC) Control Plane Components & Requirements\", Work in Progress, draft-ietf-sfc-control-plane-08, October 2016.",
      "ja": "[SFC-CONTROL-PLANE] Boucadair、M。、「Service Function Chaining（SFC）Control Plane Components＆Requirements」、Work in Progress、draft-ietf-sfc-control-plane-08、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[SFC-OAM-FRAMEWORK] Aldrin, S., Pignataro, C., Kumar, N., Akiya, N., Krishnan, R., and A. Ghanwani, \"Service Function Chaining (SFC) Operation, Administration and Maintenance (OAM) Framework\", Work in Progress, draft-ietf-sfc-oam-framework-03, September 2017.",
      "ja": "[SFC-OAM-FRAMEWORK] Aldrin、S.、Pignataro、C.、Kumar、N.、Akiya、N.、Krishnan、R。、およびA. Ghanwani、「Service Function Chaining（SFC）Operation、Administration and Maintenance（ OAM）Framework」、Work in Progress、draft-ietf-sfc-oam-framework-03、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[VXLAN-GPE] Maino, F., Kreeger, L., and U. Elzur, \"Generic Protocol Extension for VXLAN\", Work in Progress, draft-ietf-nvo3-vxlan-gpe-05, October 2017.",
      "ja": "[VXLAN-GPE] Maino、F.、Kreeger、L。、およびU. Elzur、「Generic Protocol Extension for VXLAN」、Work in Progress、draft-ietf-nvo3-vxlan-gpe-05、2017年10月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Sunil Vallamkonda, Nagaraj Bagepalli, Abhijit Patra, Peter Bosch, Darrel Lewis, Pritesh Kothari, Tal Mizrahi, and Ken Gray for their detailed reviews, comments, and contributions.",
      "ja": "著者は、詳細なレビュー、コメント、および貢献に対して、Sunil Vallamkonda、Nagaraj Bagepalli、Abhijit Patra、Peter Bosch、Darrel Lewis、Pritesh Kothari、Tal Mizrahi、およびKen Grayに感謝します。"
    },
    {
      "indent": 3,
      "text": "A special thank you goes to David Ward and Tom Edsall for their guidance and feedback.",
      "ja": "指導とフィードバックをいただいたDavid WardとTom Edsallに特に感謝します。"
    },
    {
      "indent": 3,
      "text": "Additionally, the authors would like to thank Larry Kreeger for his invaluable ideas and contributions, which are reflected throughout this document.",
      "ja": "さらに、著者は、このドキュメント全体に反映されている彼の非常に貴重なアイデアと貢献をしてくれたLarry Kreegerに感謝します。"
    },
    {
      "indent": 3,
      "text": "Loa Andersson provided a thorough review and valuable comments; we thank him for that.",
      "ja": "ロア・アンダーソンは徹底的なレビューと貴重なコメントを提供しました。私たちは彼に感謝します。"
    },
    {
      "indent": 3,
      "text": "Reinaldo Penno deserves a particular thank you for his architecture and implementation work that helped guide the protocol concepts and design.",
      "ja": "Reinaldo Pennoは、プロトコルの概念と設計のガイドに役立った彼のアーキテクチャと実装作業に特に感謝するに値します。"
    },
    {
      "indent": 3,
      "text": "The editors also acknowledge comprehensive reviews and respective useful suggestions by Med Boucadair, Adrian Farrel, Juergen Schoenwaelder, Acee Lindem, and Kathleen Moriarty.",
      "ja": "編集者は、Med Boucadair、Adrian Farrel、Juergen Schoenwaelder、Acee Lindem、およびCathleen Moriartyによる包括的なレビューとそれぞれの有用な提案も認めています。"
    },
    {
      "indent": 3,
      "text": "Lastly, David Dolson has provided significant review, feedback, and suggestions throughout the evolution of this document. His contributions are very much appreciated.",
      "ja": "最後に、David Dolsonは、このドキュメントの進化を通じて重要なレビュー、フィードバック、および提案を提供してくれました。彼の貢献は非常に高く評価されています。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "This WG document originated as draft-quinn-sfc-nsh; the following are its coauthors and contributors along with their respective affiliations at the time of WG adoption. The editors of this document would like to thank and recognize them and their contributions. These coauthors and contributors provided invaluable concepts and content for this document's creation.",
      "ja": "このWGドキュメントは、draft-quinn-sfc-nshとして作成されました。以下は、WG採択時の共著者と寄稿者、およびそれぞれの所属です。このドキュメントの編集者は、彼らと彼らの貢献に感謝し、認めたいと思います。これらの共著者と寄稿者は、このドキュメントの作成にかけがえのない概念とコンテンツを提供しました。"
    },
    {
      "indent": 3,
      "text": "o Jim Guichard, Cisco Systems, Inc. o Surendra Kumar, Cisco Systems, Inc. o Michael Smith, Cisco Systems, Inc. o Wim Henderickx, Alcatel-Lucent o Tom Nadeau, Brocade o Puneet Agarwal o Rajeev Manur, Broadcom o Abhishek Chauhan, Citrix o Joel Halpern, Ericsson o Sumandra Majee, F5 o David Melman, Marvell o Pankaj Garg, Microsoft o Brad McConnell, Rackspace o Chris Wright, Red Hat, Inc. o Kevin Glavin, Riverbed o Hong (Cathy) Zhang, Huawei US R&D o Louis Fourie, Huawei US R&D o Ron Parker, Affirmed Networks o Myo Zarny, Goldman Sachs o Andrew Dolganow, Alcatel-Lucent o Rex Fernando, Cisco Systems, Inc. o Praveen Muley, Alcatel-Lucent o Navindra Yadav, Cisco Systems, Inc.",
      "ja": "o シスコシステムズ社、ジムギチャードoシスコシステムズ社、スレンドラクマールoシスコシステムズ社、マイケルスミスoウィムヘンデリック、アルカテルルーセントoトムナドー、ブロケードoプニートアガルワルラジーブマヌール、ブロードコムoアビシェクチャウハン、 Citrix o Joel Halpern、Ericsson o Sumandra Majee、F5 o David Melman、Marvell o Pankaj Garg、Microsoft o Brad McConnell、Rackspace o Chris Wright、Red Hat、Inc. o Kevin Glavin、Riverbed o Hong（Cathy）Zhang、Huawei US R＆D oルイ・フーリー、Huawei US R＆D oロン・パーカー、Affirmed Networks o Myo Zarny、ゴールドマン・サックスoアンドリュー・ドルガノウ、アルカテル・ルーセントoレックス・フェルナンド、シスコシステムズo Praveen Muley、アルカテル・ルーセントo Navindra Yadav、シスコシステムズ。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Quinn (editor) Cisco Systems, Inc.",
      "ja": "Paul Quinn（編集者）Cisco Systems、Inc."
    },
    {
      "indent": 3,
      "text": "Email: paulq@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Uri Elzur (editor) Intel",
      "ja": "うり えｌずｒ （えぢとｒ） いんてｌ"
    },
    {
      "indent": 3,
      "text": "Email: uri.elzur@intel.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Carlos Pignataro (editor) Cisco Systems, Inc.",
      "ja": "Carlos Pignataro（編集者）Cisco Systems、Inc."
    },
    {
      "indent": 3,
      "text": "Email: cpignata@cisco.com",
      "raw": true,
      "ja": ""
    }
  ]
}