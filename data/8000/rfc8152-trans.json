{
  "title": {
    "text": "RFC 8152 - CBOR Object Signing and Encryption (COSE)",
    "ja": "RFC 8152 - CBORオブジェクトの署名と暗号化（COSE）"
  },
  "number": 8152,
  "created_at": "2020-08-28 14:25:18.200903+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         J. Schaad\nRequest for Comments: 8152                                August Cellars\nCategory: Standards Track                                      July 2017\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "CBOR Object Signing and Encryption (COSE)",
      "ja": "CBORオブジェクトの署名と暗号化（COSE）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need for the ability to have basic security services defined for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR.",
      "ja": "簡潔なバイナリオブジェクト表現（CBOR）は、小さなコードサイズと小さなメッセージサイズ用に設計されたデータ形式です。このデータ形式に対して基本的なセキュリティサービスを定義する機能が必要です。このドキュメントでは、CBORオブジェクト署名および暗号化（COSE）プロトコルを定義しています。この仕様では、シリアル化にCBORを使用して、署名、メッセージ認証コード、および暗号化を作成および処理する方法について説明します。この仕様では、CBORを使用して暗号化キーを表す方法についても説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8152.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8152で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Design Changes from JOSE ...................................5\n   1.2. Requirements Terminology ...................................6\n   1.3. CBOR Grammar ...............................................6\n   1.4. CBOR-Related Terminology ...................................7\n   1.5. Document Terminology .......................................8\n2. Basic COSE Structure ............................................8\n3. Header Parameters ..............................................10\n   3.1. Common COSE Headers Parameters ............................12\n4. Signing Objects ................................................16\n   4.1. Signing with One or More Signers ..........................16\n   4.2. Signing with One Signer ...................................18\n   4.3. Externally Supplied Data ..................................19\n   4.4. Signing and Verification Process ..........................20\n   4.5. Computing Counter Signatures ..............................22\n5. Encryption Objects .............................................22\n   5.1. Enveloped COSE Structure ..................................23\n        5.1.1. Content Key Distribution Methods ...................24\n   5.2. Single Recipient Encrypted ................................25\n   5.3. How to Encrypt and Decrypt for AEAD Algorithms ............26\n   5.4. How to Encrypt and Decrypt for AE Algorithms ..............28\n6. MAC Objects ....................................................29\n   6.1. MACed Message with Recipients .............................30\n   6.2. MACed Messages with Implicit Key ..........................31\n   6.3. How to Compute and Verify a MAC ...........................32\n7. Key Objects ....................................................33\n   7.1. COSE Key Common Parameters ................................34\n8. Signature Algorithms ...........................................37\n   8.1. ECDSA .....................................................38\n        8.1.1. Security Considerations ............................40\n   8.2. Edwards-Curve Digital Signature Algorithms (EdDSAs) .......40\n        8.2.1. Security Considerations ............................41\n9. Message Authentication Code (MAC) Algorithms ...................42\n   9.1. Hash-Based Message Authentication Codes (HMACs) ...........42\n        9.1.1. Security Considerations ............................44\n   9.2. AES Message Authentication Code (AES-CBC-MAC) .............44\n        9.2.1. Security Considerations ............................45\n10. Content Encryption Algorithms .................................45\n   10.1. AES GCM ..................................................46\n        10.1.1. Security Considerations ...........................47\n   10.2. AES CCM ..................................................47\n        10.2.1. Security Considerations ...........................50\n   10.3. ChaCha20 and Poly1305 ....................................50\n        10.3.1. Security Considerations ...........................51\n11. Key Derivation Functions (KDFs) ...............................51",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   11.1. HMAC-Based Extract-and-Expand Key Derivation\n         Function (HKDF) ..........................................52\n   11.2. Context Information Structure ............................54\n12. Content Key Distribution Methods ..............................60\n   12.1. Direct Encryption ........................................60\n        12.1.1. Direct Key ........................................61\n        12.1.2. Direct Key with KDF ...............................61\n    12.2. Key Wrap ................................................63\n        12.2.1. AES Key Wrap ......................................64\n    12.3. Key Transport ...........................................65\n    12.4. Direct Key Agreement ....................................65\n        12.4.1. ECDH ..............................................66\n        12.4.2. Security Considerations ...........................69\n   12.5. Key Agreement with Key Wrap ..............................69\n        12.5.1. ECDH ..............................................70\n13. Key Object Parameters .........................................72\n   13.1. Elliptic Curve Keys ......................................73\n        13.1.1. Double Coordinate Curves ..........................73\n   13.2. Octet Key Pair ...........................................74\n   13.3. Symmetric Keys ...........................................75\n14. CBOR Encoder Restrictions .....................................76\n15. Application Profiling Considerations ..........................76\n16. IANA Considerations ...........................................78\n   16.1. CBOR Tag Assignment ......................................78\n   16.2. COSE Header Parameters Registry ..........................78\n   16.3. COSE Header Algorithm Parameters Registry ................79\n   16.4. COSE Algorithms Registry .................................79\n   16.5. COSE Key Common Parameters Registry ......................81\n   16.6. COSE Key Type Parameters Registry ........................81\n   16.7. COSE Key Types Registry ..................................82\n   16.8. COSE Elliptic Curves Registry ............................83\n   16.9. Media Type Registrations .................................84\n        16.9.1. COSE Security Message .............................84\n        16.9.2. COSE Key Media Type ...............................85\n   16.10. CoAP Content-Formats Registry ...........................87\n   16.11. Expert Review Instructions ..............................87\n17. Security Considerations .......................................88\n18. References ....................................................90\n   18.1. Normative References .....................................90\n   18.2. Informative References ...................................92\nAppendix A. Guidelines for External Data Authentication of\n            Algorithms ............................................96\n   A.1. Algorithm Identification ..................................96\n   A.2. Counter Signature without Headers .........................99\nAppendix B. Two Layers of Recipient Information ..................100\nAppendix C. Examples .............................................102\n   C.1. Examples of Signed Messages ..............................103\n        C.1.1. Single Signature ..................................103",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        C.1.2. Multiple Signers ..................................103\n        C.1.3. Counter Signature .................................104\n        C.1.4. Signature with Criticality ........................105\n   C.2. Single Signer Examples ...................................106\n        C.2.1. Single ECDSA Signature  ...........................106\n   C.3. Examples of Enveloped Messages ...........................107\n        C.3.1. Direct ECDH .......................................107\n        C.3.2. Direct Plus Key Derivation ........................108\n        C.3.3. Counter Signature on Encrypted Content ............109\n        C.3.4. Encrypted Content with External Data ..............111\n   C.4. Examples of Encrypted Messages ...........................111\n        C.4.1. Simple Encrypted Message ..........................111\n        C.4.2. Encrypted Message with a Partial IV ...............112\n   C.5. Examples of MACed Messages ...............................112\n        C.5.1. Shared Secret Direct MAC ..........................112\n        C.5.2. ECDH Direct MAC ...................................113\n        C.5.3. Wrapped MAC .......................................114\n        C.5.4. Multi-Recipient MACed Message .....................115\n   C.6. Examples of MAC0 Messages ................................117\n        C.6.1. Shared Secret Direct MAC ..........................117\n   C.7. COSE Keys ................................................117\n        C.7.1. Public Keys .......................................117\n        C.7.2. Private Keys ......................................119\nAcknowledgments ..................................................121\nAuthor's Address .................................................121",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There has been an increased focus on small, constrained devices that make up the Internet of Things (IoT). One of the standards that has come out of this process is \"Concise Binary Object Representation (CBOR)\" [RFC7049]. CBOR extended the data model of the JavaScript Object Notation (JSON) [RFC7159] by allowing for binary data, among other changes. CBOR is being adopted by several of the IETF working groups dealing with the IoT world as their encoding of data structures. CBOR was designed specifically to be both small in terms of messages transport and implementation size and be a schema-free decoder. A need exists to provide message security services for IoT, and using CBOR as the message-encoding format makes sense.",
      "ja": "モノのインターネット（IoT）を構成する制約のある小型デバイスへの関心が高まっています。このプロセスから生まれた標準の1つは、「簡潔なバイナリオブジェクト表現（CBOR）」[RFC7049]です。 CBORは、JavaScriptデータ表記法（JSON）[RFC7159]のデータモデルを拡張し、特にバイナリデータを可能にしました。 CBORは、データ構造のエンコーディングとしてIoTの世界を扱ういくつかのIETFワーキンググループによって採用されています。 CBORは、メッセージ転送と実装サイズの両方の点で小さく、スキーマフリーのデコーダーになるように特別に設計されました。 IoTにメッセージセキュリティサービスを提供する必要があり、メッセージエンコーディングフォーマットとしてCBORを使用することには意味があります。"
    },
    {
      "indent": 0,
      "text": " The JOSE working group produced a set of documents [RFC7515] [RFC7516] [RFC7517] [RFC7518] using JSON that specified how to process encryption, signatures, and Message Authentication Code (MAC) operations and how to encode keys using JSON. This document defines the CBOR Object Signing and Encryption (COSE) standard, which does the same thing for the CBOR encoding format. While there is a strong attempt to keep the flavor of the original JSON Object Signing and Encryption (JOSE) documents, two considerations are taken into account:",
      "ja": "JOSEワーキンググループは、暗号化、署名、およびメッセージ認証コード（MAC）操作の処理方法と、JSONを使用したキーのエンコード方法を指定したJSONを使用して一連のドキュメント[RFC7515] [RFC7516] [RFC7517] [RFC7518]を作成しました。このドキュメントでは、CBOR Object Signing and Encryption（COSE）標準を定義しています。これは、CBORエンコード形式に対して同じことを行います。元のJSON Object Signing and Encryption（JOSE）ドキュメントのフレーバーを維持しようとする強い試みがありますが、2つの考慮事項が考慮されます。"
    },
    {
      "indent": 3,
      "text": "o CBOR has capabilities that are not present in JSON and are appropriate to use. One example of this is the fact that CBOR has a method of encoding binary directly without first converting it into a base64-encoded string.",
      "ja": "o CBORには、JSONにはない機能があり、使用に適しています。この1つの例は、CBORには、最初にbase64でエンコードされた文字列に変換することなく、バイナリを直接エンコードする方法があるという事実です。"
    },
    {
      "indent": 3,
      "text": "o COSE is not a direct copy of the JOSE specification. In the process of creating COSE, decisions that were made for JOSE were re-examined. In many cases, different results were decided on as the criteria were not always the same.",
      "ja": "o COSEはJOSE仕様の直接のコピーではありません。 COSEを作成する過程で、JOSEに対して行われた決定が再検討されました。基準が常に同じではないため、多くの場合、異なる結果が決定されました。"
    },
    {
      "indent": 0,
      "text": "1.1. Design Changes from JOSE",
      "section_title": true,
      "ja": "1.1. JOSEからの設計変更"
    },
    {
      "indent": 3,
      "text": "o Define a single top message structure so that encrypted, signed, and MACed messages can easily be identified and still have a consistent view.",
      "ja": "o 単一のトップメッセージ構造を定義して、暗号化、署名、およびMAC処理されたメッセージを簡単に識別し、一貫したビューを維持できるようにします。"
    },
    {
      "indent": 3,
      "text": "o Signed messages distinguish between the protected and unprotected parameters that relate to the content from those that relate to the signature.",
      "ja": "o 署名付きメッセージは、コンテンツに関連する保護されたパラメーターと保護されていないパラメーターを、署名に関連するパラメーターと区別します。"
    },
    {
      "indent": 3,
      "text": "o MACed messages are separated from signed messages.",
      "ja": "o MAC化されたメッセージは、署名されたメッセージから分離されます。"
    },
    {
      "indent": 3,
      "text": "o MACed messages have the ability to use the same set of recipient algorithms as enveloped messages for obtaining the MAC authentication key.",
      "ja": "o MACedメッセージには、MAC認証キーを取得するためのエンベロープメッセージと同じ受信者アルゴリズムのセットを使用する機能があります。"
    },
    {
      "indent": 3,
      "text": "o Use binary encodings for binary data rather than base64url encodings.",
      "ja": "o バイナリデータには、base64urlエンコーディングではなくバイナリエンコーディングを使用します。"
    },
    {
      "indent": 3,
      "text": "o Combine the authentication tag for encryption algorithms with the ciphertext.",
      "ja": "o 暗号化アルゴリズムの認証タグと暗号文を組み合わせます。"
    },
    {
      "indent": 3,
      "text": "o The set of cryptographic algorithms has been expanded in some directions and trimmed in others.",
      "ja": "o 暗号化アルゴリズムのセットは、いくつかの方向に拡張され、他の方向にトリミングされています。"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Terminology",
      "section_title": true,
      "ja": "1.2. 要件の用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "When the words appear in lowercase, this interpretation does not apply.",
      "ja": "単語が小文字で表示される場合、この解釈は適用されません。"
    },
    {
      "indent": 0,
      "text": "1.3. CBOR Grammar",
      "section_title": true,
      "ja": "1.3. CBOR文法"
    },
    {
      "indent": 3,
      "text": "There is currently no standard CBOR grammar available for use by specifications. The CBOR structures are therefore described in prose.",
      "ja": "現在、仕様で使用できる標準のCBOR文法はありません。したがって、CBOR構造は散文で記述されます。"
    },
    {
      "indent": 3,
      "text": "The document was developed by first working on the grammar and then developing the prose to go with it. An artifact of this is that the prose was written using the primitive type strings defined by CBOR Data Definition Language (CDDL) [CDDL]. In this specification, the following primitive types are used:",
      "ja": "この文書は、最初に文法に取り組み、次にそれに対応する散文を開発することによって作成されました。これのアーティファクトは、散文がCBORデータ定義言語（CDDL）[CDDL]によって定義されたプリミティブ型の文字列を使用して記述されたことです。この仕様では、次のプリミティブ型が使用されます。"
    },
    {
      "indent": 6,
      "text": "any -- non-specific value that permits all CBOR values to be placed here.",
      "ja": "any-すべてのCBOR値をここに配置できる非特定の値。"
    },
    {
      "indent": 6,
      "text": "bool -- a boolean value (true: major type 7, value 21; false: major type 7, value 20).",
      "ja": "bool-ブール値（true：メジャータイプ7、値21; false：メジャータイプ7、値20）。"
    },
    {
      "indent": 6,
      "text": "bstr -- byte string (major type 2).",
      "ja": "bstr-バイト文字列（メジャータイプ2）。"
    },
    {
      "indent": 6,
      "text": "int -- an unsigned integer or a negative integer.",
      "ja": "int-符号なし整数または負の整数。"
    },
    {
      "indent": 6,
      "text": "nil -- a null value (major type 7, value 22).",
      "ja": "nil-null値（メジャータイプ7、値22）。"
    },
    {
      "indent": 6,
      "text": "nint -- a negative integer (major type 1).",
      "ja": "nint-負の整数（メジャータイプ1）。"
    },
    {
      "indent": 6,
      "text": "tstr -- a UTF-8 text string (major type 3).",
      "ja": "tstr-UTF-8テキスト文字列（メジャータイプ3）。"
    },
    {
      "indent": 6,
      "text": "uint -- an unsigned integer (major type 0).",
      "ja": "uint-符号なし整数（メジャータイプ0）。"
    },
    {
      "indent": 3,
      "text": "Two syntaxes from CDDL appear in this document as shorthand. These are:",
      "ja": "このドキュメントでは、CDDLの2つの構文を省略形で示しています。これらは："
    },
    {
      "indent": 6,
      "text": "FOO / BAR -- indicates that either FOO or BAR can appear here.",
      "ja": "FOO / BAR-FOOまたはBARのいずれかをここに表示できることを示します。"
    },
    {
      "indent": 6,
      "text": "[+ FOO] -- indicates that the type FOO appears one or more times in an array.",
      "ja": "[+ FOO]-タイプFOOが配列内に1回以上出現することを示します。"
    },
    {
      "indent": 3,
      "text": "As well as the prose description, a version of a CBOR grammar is presented in CDDL. Since CDDL has not been published in an RFC, this grammar may not work with the final version of CDDL. The CDDL grammar is informational; the prose description is normative.",
      "ja": "散文の説明と同様に、CBOR文法のバージョンがCDDLで提示されます。 CDDLはRFCで公開されていないため、この文法はCDDLの最終バージョンでは機能しない可能性があります。 CDDL文法は情報提供です。散文の記述は規範的です。"
    },
    {
      "indent": 3,
      "text": "The collected CDDL can be extracted from the XML version of this document via the following XPath expression below. (Depending on the XPath evaluator one is using, it may be necessary to deal with &gt; as an entity.)",
      "ja": "収集されたCDDLは、以下のXPath式を使用して、このドキュメントのXMLバージョンから抽出できます。 （使用しているXPathエバリュエーターによっては、エンティティとして＆gt;を処理する必要がある場合があります。）"
    },
    {
      "indent": 3,
      "text": "//artwork[@type='CDDL']/text()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CDDL expects the initial non-terminal symbol to be the first symbol in the file. For this reason, the first fragment of CDDL is presented here.",
      "ja": "CDDLは、最初の非終端記号がファイルの最初の記号であることを想定しています。このため、ここではCDDLの最初のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "start = COSE_Messages / COSE_Key / COSE_KeySet / Internal_Types",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "; This is defined to make the tool quieter:\nInternal_Types = Sig_structure / Enc_structure / MAC_structure /\n        COSE_KDF_Context",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The non-terminal Internal_Types is defined for dealing with the automated validation tools used during the writing of this document. It references those non-terminals that are used for security computations but are not emitted for transport.",
      "ja": "非ターミナルのInternal_Typesは、このドキュメントの作成中に使用された自動検証ツールを処理するために定義されています。これは、セキュリティの計算に使用されるが、トランスポートのために発行されない非端末を参照します。"
    },
    {
      "indent": 0,
      "text": "1.4. CBOR-Related Terminology",
      "section_title": true,
      "ja": "1.4. CBOR関連の用語"
    },
    {
      "indent": 3,
      "text": "In JSON, maps are called objects and only have one kind of map key: a string. In COSE, we use strings, negative integers, and unsigned integers as map keys. The integers are used for compactness of encoding and easy comparison. The inclusion of strings allows for an additional range of short encoded values to be used as well. Since the word \"key\" is mainly used in its other meaning, as a cryptographic key, we use the term \"label\" for this usage as a map key.",
      "ja": "JSONでは、マップはオブジェクトと呼ばれ、文字列という1種類のマップキーしかありません。 COSEでは、文字列、負の整数、および符号なし整数をマップキーとして使用します。整数は、エンコードの簡潔さと比較の容易さのために使用されます。文字列を含めることで、短いエンコード値の追加の範囲も使用できるようになります。 「キー」という言葉は主に他の意味で暗号化キーとして使用されるため、この使用法では「ラベル」という用語をマップキーとして使用します。"
    },
    {
      "indent": 3,
      "text": "The presence of a label in a COSE map that is not a string or an integer is an error. Applications can either fail processing or process messages with incorrect labels; however, they MUST NOT create messages with incorrect labels.",
      "ja": "文字列または整数ではないCOSEマップ内のラベルの存在はエラーです。アプリケーションは処理に失敗するか、誤ったラベルの付いたメッセージを処理する可能性があります。ただし、不正なラベルでメッセージを作成してはなりません。"
    },
    {
      "indent": 3,
      "text": "A CDDL grammar fragment defines the non-terminal 'label', as in the previous paragraph, and 'values', which permits any value to be used.",
      "ja": "CDDL文法フラグメントは、前の段落のように非終端の「ラベル」と、任意の値の使用を許可する「値」を定義します。"
    },
    {
      "indent": 3,
      "text": "label = int / tstr values = any",
      "ja": "ラベル= int / tstr値=任意"
    },
    {
      "indent": 0,
      "text": "1.5. Document Terminology",
      "section_title": true,
      "ja": "1.5. ドキュメントの用語"
    },
    {
      "indent": 3,
      "text": "In this document, we use the following terminology:",
      "ja": "このドキュメントでは、次の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Byte is a synonym for octet.",
      "ja": "バイトはオクテットの同義語です。"
    },
    {
      "indent": 3,
      "text": "Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use in constrained systems. It is defined in [RFC7252].",
      "ja": "制約付きアプリケーションプロトコル（CoAP）は、制約付きシステムで使用するための特殊なWeb転送プロトコルです。 [RFC7252]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Authenticated Encryption (AE) [RFC5116] algorithms are those encryption algorithms that provide an authentication check of the contents algorithm with the encryption service.",
      "ja": "Authenticated Encryption（AE）[RFC5116]アルゴリズムは、コンテンツアルゴリズムの認証チェックを暗号化サービスに提供する暗号化アルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "Authenticated Encryption with Authenticated Data (AEAD) [RFC5116] algorithms provide the same content authentication service as AE algorithms, but they additionally provide for authentication of non-encrypted data as well.",
      "ja": "Authenticated Data with Authenticated Data（AEAD）[RFC5116]アルゴリズムは、AEアルゴリズムと同じコンテンツ認証サービスを提供しますが、非暗号化データの認証も提供します。"
    },
    {
      "indent": 0,
      "text": "2. Basic COSE Structure",
      "section_title": true,
      "ja": "2. 基本的なCOSE構造"
    },
    {
      "indent": 3,
      "text": "The COSE object structure is designed so that there can be a large amount of common code when parsing and processing the different types of security messages. All of the message structures are built on the CBOR array type. The first three elements of the array always contain the same information:",
      "ja": "COSEオブジェクト構造は、さまざまなタイプのセキュリティメッセージを解析および処理するときに大量の共通コードが存在するように設計されています。すべてのメッセージ構造は、CBOR配列タイプに基づいて構築されています。配列の最初の3つの要素には、常に同じ情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "1. The set of protected header parameters wrapped in a bstr.",
      "ja": "1. bstrでラップされた保護されたヘッダーパラメーターのセット。"
    },
    {
      "indent": 3,
      "text": "2. The set of unprotected header parameters as a map.",
      "ja": "2. マップとしての保護されていないヘッダーパラメーターのセット。"
    },
    {
      "indent": 3,
      "text": "3. The content of the message. The content is either the plaintext or the ciphertext as appropriate. The content may be detached, but the location is still used. The content is wrapped in a bstr when present and is a nil value when detached.",
      "ja": "3. メッセージの内容。コンテンツは、平文または暗号文のいずれかです。コンテンツは切り離される可能性がありますが、場所は引き続き使用されます。コンテンツは、存在する場合はbstrでラップされ、分離される場合はnil値になります。"
    },
    {
      "indent": 3,
      "text": "Elements after this point are dependent on the specific message type.",
      "ja": "この時点以降の要素は、特定のメッセージタイプによって異なります。"
    },
    {
      "indent": 3,
      "text": "COSE messages are also built using the concept of layers to separate different types of cryptographic concepts. As an example of how this works, consider the COSE_Encrypt message (Section 5.1). This message type is broken into two layers: the content layer and the recipient layer. In the content layer, the plaintext is encrypted and information about the encrypted message is placed. In the recipient layer, the content encryption key (CEK) is encrypted and information about how it is encrypted for each recipient is placed. A single layer version of the encryption message COSE_Encrypt0 (Section 5.2) is provided for cases where the CEK is pre-shared.",
      "ja": "COSEメッセージは、レイヤーの概念を使用して構築され、異なるタイプの暗号化の概念を分離します。これがどのように機能するかの例として、COSE_Encryptメッセージ（セクション5.1）を検討してください。このメッセージタイプは、コンテンツレイヤーと受信者レイヤーの2つのレイヤーに分かれています。コンテンツ層では、平文が暗号化され、暗号化されたメッセージに関する情報が配置されます。受信者層では、コンテンツ暗号化キー（CEK）が暗号化され、各受信者の暗号化方法に関する情報が配置されます。 CEKが事前共有されている場合のために、暗号化メッセージCOSE_Encrypt0（セクション5.2）の単一層バージョンが提供されています。"
    },
    {
      "indent": 3,
      "text": "Identification of which type of message has been presented is done by the following methods:",
      "ja": "提示されたメッセージのタイプの識別は、次の方法で行われます。"
    },
    {
      "indent": 3,
      "text": "1. The specific message type is known from the context. This may be defined by a marker in the containing structure or by restrictions specified by the application protocol.",
      "ja": "1. 特定のメッセージタイプはコンテキストからわかります。これは、包含構造内のマーカーによって、またはアプリケーションプロトコルによって指定された制限によって定義できます。"
    },
    {
      "indent": 3,
      "text": "2. The message type is identified by a CBOR tag. Messages with a CBOR tag are known in this specification as tagged messages, while those without the CBOR tag are known as untagged messages. This document defines a CBOR tag for each of the message structures. These tags can be found in Table 1.",
      "ja": "2. メッセージタイプはCBORタグで識別されます。この仕様では、CBORタグの付いたメッセージをタグ付きメッセージと呼び、CBORタグのないメッセージをタグなしメッセージと呼びます。このドキュメントでは、各メッセージ構造のCBORタグを定義しています。これらのタグは表1にあります。"
    },
    {
      "indent": 3,
      "text": "3. When a COSE object is carried in a media type of 'application/ cose', the optional parameter 'cose-type' can be used to identify the embedded object. The parameter is OPTIONAL if the tagged version of the structure is used. The parameter is REQUIRED if the untagged version of the structure is used. The value to use with the parameter for each of the structures can be found in Table 1.",
      "ja": "3. COSEオブジェクトが 'application / cose'のメディアタイプで運ばれる場合、オプションのパラメーター 'cose-type'を使用して埋め込みオブジェクトを識別できます。タグ付きバージョンの構造が使用されている場合、パラメーターはオプションです。タグなしバージョンの構造が使用される場合、パラメーターは必須です。各構造のパラメーターで使用する値は、表1に記載されています。"
    },
    {
      "indent": 3,
      "text": "4. When a COSE object is carried as a CoAP payload, the CoAP Content-Format Option can be used to identify the message content. The CoAP Content-Format values can be found in Table 26. The CBOR tag for the message structure is not required as each security message is uniquely identified.",
      "ja": "4. COSEオブジェクトがCoAPペイロードとして伝送される場合、CoAP Content-Format Optionを使用してメッセージコンテンツを識別できます。 CoAP Content-Formatの値は表26にあります。各セキュリティメッセージは一意に識別されるため、メッセージ構造のCBORタグは必要ありません。"
    },
    {
      "indent": 3,
      "text": "+-------+---------------+---------------+---------------------------+\n| CBOR  | cose-type     | Data Item     | Semantics                 |\n| Tag   |               |               |                           |\n+-------+---------------+---------------+---------------------------+\n| 98    | cose-sign     | COSE_Sign     | COSE Signed Data Object   |\n| 18    | cose-sign1    | COSE_Sign1    | COSE Single Signer Data   |\n|       |               |               | Object                    |\n| 96    | cose-encrypt  | COSE_Encrypt  | COSE Encrypted Data       |\n|       |               |               | Object                    |\n| 16    | cose-encrypt0 | COSE_Encrypt0 | COSE Single Recipient     |\n|       |               |               | Encrypted Data Object     |\n| 97    | cose-mac      | COSE_Mac      | COSE MACed Data Object    |\n| 17    | cose-mac0     | COSE_Mac0     | COSE Mac w/o Recipients   |\n|       |               |               | Object                    |\n+-------+---------------+---------------+---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 1: COSE Message Identification",
      "ja": "表1：THINGSメッセージの識別"
    },
    {
      "indent": 3,
      "text": "The following CDDL fragment identifies all of the top messages defined in this document. Separate non-terminals are defined for the tagged and the untagged versions of the messages.",
      "ja": "次のCDDLフラグメントは、このドキュメントで定義されているすべての上位メッセージを示しています。メッセージのタグ付けされたバージョンとタグ付けされていないバージョンに対して、個別の非端末が定義されています。"
    },
    {
      "indent": 3,
      "text": "COSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message",
      "ja": "COSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message"
    },
    {
      "indent": 3,
      "text": "COSE_Untagged_Message = COSE_Sign / COSE_Sign1 /\n    COSE_Encrypt / COSE_Encrypt0 /\n    COSE_Mac / COSE_Mac0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COSE_Tagged_Message = COSE_Sign_Tagged / COSE_Sign1_Tagged /\n    COSE_Encrypt_Tagged / COSE_Encrypt0_Tagged /\n    COSE_Mac_Tagged / COSE_Mac0_Tagged",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Header Parameters",
      "section_title": true,
      "ja": "3. ヘッダーパラメータ"
    },
    {
      "indent": 3,
      "text": "The structure of COSE has been designed to have two buckets of information that are not considered to be part of the payload itself, but are used for holding information about content, algorithms, keys, or evaluation hints for the processing of the layer. These two buckets are available for use in all of the structures except for keys. While these buckets are present, they may not all be usable in all instances. For example, while the protected bucket is defined as part of the recipient structure, some of the algorithms used for recipient structures do not provide for authenticated data. If this is the case, the protected bucket is left empty.",
      "ja": "COSEの構造は、ペイロード自体の一部とは見なされない情報の2つのバケットを持つように設計されていますが、コンテンツ、アルゴリズム、キー、またはレイヤーの処理の評価ヒントに関する情報を保持するために使用されます。これら2つのバケットは、キーを除くすべての構造で使用できます。これらのバケットは存在しますが、すべてのインスタンスで使用できるとは限りません。たとえば、保護されたバケットは受信者構造の一部として定義されていますが、受信者構造に使用されるアルゴリズムの一部は認証されたデータを提供しません。この場合、保護されたバケットは空のままになります。"
    },
    {
      "indent": 3,
      "text": "Both buckets are implemented as CBOR maps. The map key is a 'label' (Section 1.4). The value portion is dependent on the definition for the label. Both maps use the same set of label/value pairs. The integer and string values for labels have been divided into several sections including a standard range, a private range, and a range that is dependent on the algorithm selected. The defined labels can be found in the \"COSE Header Parameters\" IANA registry (Section 16.2).",
      "ja": "両方のバケットは、CBORマップとして実装されます。マップキーは「ラベル」です（セクション1.4）。値の部分は、ラベルの定義に依存します。どちらのマップも同じセットのラベル/値ペアを使用します。ラベルの整数値と文字列値は、標準範囲、プライベート範囲、選択したアルゴリズムに依存する範囲など、いくつかのセクションに分割されています。定義されたラベルは、 \"COSEヘッダーパラメータ\" IANAレジストリ（セクション16.2）にあります。"
    },
    {
      "indent": 3,
      "text": "Two buckets are provided for each layer:",
      "ja": "レイヤーごとに2つのバケットが用意されています。"
    },
    {
      "indent": 0,
      "text": " protected: Contains parameters about the current layer that are to be cryptographically protected. This bucket MUST be empty if it is not going to be included in a cryptographic computation. This bucket is encoded in the message as a binary object. This value is obtained by CBOR encoding the protected map and wrapping it in a bstr object. Senders SHOULD encode a zero-length map as a zero-length string rather than as a zero-length map (encoded as h'a0'). The zero-length binary encoding is preferred because it is both shorter and the version used in the serialization structures for cryptographic computation. After encoding the map, the value is wrapped in the binary object. Recipients MUST accept both a zero-length binary value and a zero-length map encoded in the binary value. The wrapping allows for the encoding of the protected map to be transported with a greater chance that it will not be altered in transit. (Badly behaved intermediates could decode and re-encode, but this will result in a failure to verify unless the re-encoded byte string is identical to the decoded byte string.) This avoids the problem of all parties needing to be able to do a common canonical encoding.",
      "ja": "protected：暗号で保護される現在のレイヤーに関するパラメーターが含まれています。暗号計算に含まれない場合、このバケットは空でなければなりません。このバケットは、メッセージ内でバイナリオブジェクトとしてエンコードされます。この値は、保護されたマップをCBORエンコードしてbstrオブジェクトにラップすることによって取得されます。送信者は、長さゼロのマップを長さゼロのマップ（h'a0 'としてエンコード）ではなく長さゼロの文字列としてエンコードする必要があります（SHOULD）。ゼロ長のバイナリエンコーディングは、暗号化計算のシリアル化構造で使用されるバージョンとバージョンの両方が短いため、推奨されます。マップをエンコードした後、値はバイナリオブジェクトにラップされます。受信者は、長さゼロのバイナリ値とバイナリ値でエンコードされた長さゼロのマップの両方を受け入れる必要があります。ラッピングにより、保護されたマップのエンコードを転送中に転送でき、転送中に変更されない可能性が高くなります。 （不適切に動作する中間体は、デコードおよび再エンコードできますが、再エンコードされたバイト文字列がデコードされたバイト文字列と同一でない限り、検証に失敗します。）これにより、すべての関係者が実行できる必要がある問題が回避されます。一般的な正規エンコーディング。"
    },
    {
      "indent": 3,
      "text": "unprotected: Contains parameters about the current layer that are not cryptographically protected.",
      "ja": "unprotected：暗号で保護されていない現在のレイヤーに関するパラメーターが含まれています。"
    },
    {
      "indent": 3,
      "text": "Only parameters that deal with the current layer are to be placed at that layer. As an example of this, the parameter 'content type' describes the content of the message being carried in the message. As such, this parameter is placed only in the content layer and is not placed in the recipient or signature layers. In principle, one should be able to process any given layer without reference to any other layer. With the exception of the COSE_Sign structure, the only data that needs to cross layers is the cryptographic key.",
      "ja": "現在のレイヤーを処理するパラメーターのみがそのレイヤーに配置されます。この例として、パラメーター 'content type'は、メッセージで運ばれるメッセージのコンテンツを記述します。そのため、このパラメーターはコンテンツレイヤーにのみ配置され、受信者レイヤーまたは署名レイヤーには配置されません。原則として、他のレイヤーを参照せずに、任意のレイヤーを処理できる必要があります。 COSE_Sign構造を除いて、レイヤーを越える必要があるのは暗号化キーだけです。"
    },
    {
      "indent": 3,
      "text": "The buckets are present in all of the security objects defined in this document. The fields in order are the 'protected' bucket (as a CBOR 'bstr' type) and then the 'unprotected' bucket (as a CBOR 'map' type). The presence of both buckets is required. The parameters that go into the buckets come from the IANA \"COSE Header Parameters\" registry (Section 16.2). Some common parameters are defined in the next section, but a number of parameters are defined throughout this document.",
      "ja": "バケットは、このドキュメントで定義されているすべてのセキュリティオブジェクトに存在します。順序どおりのフィールドは、「保護された」バケット（CBORの「bstr」タイプとして）、次に「保護されていない」バケット（CBORの「マップ」タイプとして）です。両方のバケットの存在が必要です。バケットに入るパラメーターは、IANAの「COSEヘッダーパラメーター」レジストリ（セクション16.2）から取得されます。次のセクションではいくつかの一般的なパラメーターを定義しますが、このドキュメント全体でいくつかのパラメーターを定義しています。"
    },
    {
      "indent": 3,
      "text": "Labels in each of the maps MUST be unique. When processing messages, if a label appears multiple times, the message MUST be rejected as malformed. Applications SHOULD verify that the same label does not occur in both the protected and unprotected headers. If the message is not rejected as malformed, attributes MUST be obtained from the protected bucket before they are obtained from the unprotected bucket.",
      "ja": "各マップのラベルは一意である必要があります。メッセージを処理するとき、ラベルが複数回出現する場合、メッセージは不正な形式として拒否される必要があります。アプリケーションは、保護されたヘッダーと保護されていないヘッダーの両方で同じラベルが発生しないことを確認する必要があります。メッセージが不正な形式として拒否されない場合、属性は、保護されていないバケットから取得される前に、保護されたバケットから取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following CDDL fragment represents the two header buckets. A group \"Headers\" is defined in CDDL that represents the two buckets in which attributes are placed. This group is used to provide these two fields consistently in all locations. A type is also defined that represents the map of common headers.",
      "ja": "次のCDDLフラグメントは、2つのヘッダーバケットを表しています。グループ「ヘッダー」は、属性が配置される2つのバケットを表すCDDLで定義されます。このグループは、これら2つのフィールドをすべての場所で一貫して提供するために使用されます。共通ヘッダーのマップを表すタイプも定義されています。"
    },
    {
      "indent": 3,
      "text": "Headers = (\n    protected : empty_or_serialized_map,\n    unprotected : header_map\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "header_map = {\n    Generic_Headers,\n    * label => values\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "empty_or_serialized_map = bstr .cbor header_map / bstr .size 0",
      "ja": "empty_or_serialized_map = bstr .cbor header_map / bstr .size 0"
    },
    {
      "indent": 0,
      "text": "3.1. Common COSE Headers Parameters",
      "section_title": true,
      "ja": "3.1. 一般的なCOSEヘッダーパラメータ"
    },
    {
      "indent": 3,
      "text": "This section defines a set of common header parameters. A summary of these parameters can be found in Table 2. This table should be consulted to determine the value of label and the type of the value.",
      "ja": "このセクションでは、一連の共通ヘッダーパラメータを定義します。これらのパラメーターの要約を表2に示します。この表を参照して、ラベルの値と値のタイプを判別する必要があります。"
    },
    {
      "indent": 3,
      "text": "The set of header parameters defined in this section are:",
      "ja": "このセクションで定義されているヘッダーパラメータのセットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "alg: This parameter is used to indicate the algorithm used for the security processing. This parameter MUST be authenticated where the ability to do so exists. This support is provided by AEAD algorithms or construction (COSE_Sign, COSE_Sign0, COSE_Mac, and COSE_Mac0). This authentication can be done either by placing the header in the protected header bucket or as part of the externally supplied data. The value is taken from the \"COSE Algorithms\" registry (see Section 16.4).",
      "ja": "alg：このパラメーターは、セキュリティー処理に使用されるアルゴリズムを示すために使用されます。このパラメーターは、その機能が存在する場合に認証される必要があります。このサポートは、AEADアルゴリズムまたは構築（COSE_Sign、COSE_Sign0、COSE_Mac、およびCOSE_Mac0）によって提供されます。この認証は、保護されたヘッダーバケットにヘッダーを配置するか、外部から提供されるデータの一部として行うことができます。この値は、「COSEアルゴリズム」レジストリから取得されます（セクション16.4を参照）。"
    },
    {
      "indent": 3,
      "text": "crit: The parameter is used to indicate which protected header labels an application that is processing a message is required to understand. Parameters defined in this document do not need to be included as they should be understood by all implementations. When present, this parameter MUST be placed in the protected header bucket. The array MUST have at least one value in it. Not all labels need to be included in the 'crit' parameter. The rules for deciding which header labels are placed in the array are:",
      "ja": "crit：このパラメーターは、メッセージを処理しているアプリケーションが理解する必要がある保護ヘッダーラベルを示すために使用されます。このドキュメントで定義されているパラメータは、すべての実装で理解される必要があるため、含める必要はありません。存在する場合、このパラメーターは保護されたヘッダーバケットに配置する必要があります。配列には少なくとも1つの値が必要です。すべてのラベルを 'crit'パラメータに含める必要はありません。配列に配置するヘッダーラベルを決定するためのルールは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Integer labels in the range of 0 to 8 SHOULD be omitted.",
      "ja": "* 0から8の範囲の整数ラベルは省略してください。"
    },
    {
      "indent": 6,
      "text": "* Integer labels in the range -1 to -128 can be omitted as they are algorithm dependent. If an application can correctly process an algorithm, it can be assumed that it will correctly process all of the common parameters associated with that algorithm. Integer labels in the range -129 to -65536 SHOULD be included as these would be less common parameters that might not be generally supported.",
      "ja": "* -1〜-128の範囲の整数ラベルは、アルゴリズムに依存するため省略できます。アプリケーションがアルゴリズムを正しく処理できる場合、そのアルゴリズムに関連付けられているすべての共通パラメーターを正しく処理すると想定できます。 -129〜-65536の範囲の整数ラベルを含める必要があります。これらは一般的にサポートされていない一般的なパラメーターではないためです。"
    },
    {
      "indent": 6,
      "text": "* Labels for parameters required for an application MAY be omitted. Applications should have a statement if the label can be omitted.",
      "ja": "* アプリケーションに必要なパラメータのラベルは省略される場合があります。ラベルを省略できる場合は、アプリケーションにステートメントが必要です。"
    },
    {
      "indent": 6,
      "text": "The header parameter values indicated by 'crit' can be processed by either the security library code or an application using a security library; the only requirement is that the parameter is processed. If the 'crit' value list includes a value for which the parameter is not in the protected bucket, this is a fatal error in processing the message.",
      "ja": "「crit」で示されるヘッダーパラメータ値は、セキュリティライブラリコードまたはセキュリティライブラリを使用するアプリケーションのいずれかで処理できます。唯一の要件は、パラメーターが処理されることです。 'crit'値リストに、パラメーターが保護バケット内にない値が含まれている場合、これはメッセージの処理における致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "content type: This parameter is used to indicate the content type of the data in the payload or ciphertext fields. Integers are from the \"CoAP Content-Formats\" IANA registry table [COAP.Formats]. Text values following the syntax of \"<type-name>/<subtype-name>\" where <type-name> and <subtype-name> are defined in Section 4.2 of [RFC6838]. Leading and trailing whitespace is also omitted. Textual content values along with parameters and subparameters can be located using the IANA \"Media Types\" registry. Applications SHOULD provide this parameter if the content structure is potentially ambiguous.",
      "ja": "content type：このパラメータは、ペイロードまたは暗号文フィールドのデータのコンテンツタイプを示すために使用されます。整数は、「CoAP Content-Formats」IANAレジストリテーブル[COAP.Formats]からのものです。 「<type-name> / <subtype-name>」の構文に従うテキスト値。<type-name>と<subtype-name>は、[RFC6838]のセクション4.2で定義されています。先頭と末尾の空白も省略されます。テキストコンテンツ値は、パラメータとサブパラメータとともに、IANAの「メディアタイプ」レジストリを使用して検索できます。コンテンツ構造が曖昧である可能性がある場合、アプリケーションはこのパラメーターを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "kid: This parameter identifies one piece of data that can be used as input to find the needed cryptographic key. The value of this parameter can be matched against the 'kid' member in a COSE_Key structure. Other methods of key distribution can define an equivalent field to be matched. Applications MUST NOT assume that 'kid' values are unique. There may be more than one key with the same 'kid' value, so all of the keys associated with this 'kid' may need to be checked. The internal structure of 'kid' values is not defined and cannot be relied on by applications. Key identifier values are hints about which key to use. This is not a security-critical field. For this reason, it can be placed in the unprotected headers bucket.",
      "ja": "kid：このパラメーターは、必要な暗号鍵を見つけるための入力として使用できるデータの1つの部分を識別します。このパラメーターの値は、COSE_Key構造体の 'kid'メンバーと照合できます。キー配布の他の方法では、一致する同等のフィールドを定義できます。アプリケーションは、「子供」の値が一意であることを想定してはなりません。同じ「キッド」値を持つキーが複数ある可能性があるため、この「キッド」に関連付けられているすべてのキーを確認する必要がある場合があります。 「子供」の値の内部構造は定義されておらず、アプリケーションから信頼することはできません。キー識別子の値は、使用するキーに関するヒントです。これはセキュリティ上重要なフィールドではありません。このため、保護されていないヘッダーバケットに配置できます。"
    },
    {
      "indent": 3,
      "text": "IV: This parameter holds the Initialization Vector (IV) value. For some symmetric encryption algorithms, this may be referred to as a nonce. The IV can be placed in the unprotected header as modifying the IV will cause the decryption to yield plaintext that is readily detectable as garbled.",
      "ja": "IV：このパラメーターは、初期化ベクトル（IV）値を保持します。一部の対称暗号化アルゴリズムでは、これはナンスと呼ばれることがあります。 IVを変更すると、復号化によって、文字化けとして容易に検出可能なプレーンテキストが生成されるため、IVは保護されていないヘッダーに配置できます。"
    },
    {
      "indent": 3,
      "text": "Partial IV: This parameter holds a part of the IV value. When using the COSE_Encrypt0 structure, a portion of the IV can be part of the context associated with the key. This field is used to carry a value that causes the IV to be changed for each message. The IV can be placed in the unprotected header as modifying the IV will cause the decryption to yield plaintext that is readily detectable as garbled. The 'Initialization Vector' and 'Partial Initialization Vector' parameters MUST NOT both be present in the same security layer.",
      "ja": "部分IV：このパラメーターは、IV値の一部を保持します。 COSE_Encrypt0構造を使用する場合、IVの一部をキーに関連付けられたコンテキストの一部にすることができます。このフィールドは、メッセージごとにIVを変更させる値を運ぶために使用されます。 IVを変更すると、復号化によって、文字化けとして容易に検出可能なプレーンテキストが生成されるため、IVは保護されていないヘッダーに配置できます。 「初期化ベクトル」パラメータと「部分初期化ベクトル」パラメータの両方を同じセキュリティレイヤーに存在させることはできません。"
    },
    {
      "indent": 6,
      "text": "The message IV is generated by the following steps:",
      "ja": "メッセージIVは、次の手順で生成されます。"
    },
    {
      "indent": 6,
      "text": "1. Left-pad the Partial IV with zeros to the length of IV.",
      "ja": "1. IVの長さになるまで、部分IVをゼロで左パッドします。"
    },
    {
      "indent": 6,
      "text": "2. XOR the padded Partial IV with the context IV.",
      "ja": "2. パディングされた部分IVとコンテキストIVのXORを実行します。"
    },
    {
      "indent": 3,
      "text": "counter signature: This parameter holds one or more counter signature values. Counter signatures provide a method of having a second party sign some data. The counter signature parameter can occur as an unprotected attribute in any of the following structures: COSE_Sign1, COSE_Signature, COSE_Encrypt, COSE_recipient, COSE_Encrypt0, COSE_Mac, and COSE_Mac0. These structures all have the same beginning elements, so that a consistent calculation of the counter signature can be computed. Details on computing counter signatures are found in Section 4.5.",
      "ja": "カウンター署名：このパラメーターは、1つ以上のカウンター署名値を保持します。カウンター署名は、一部のデータに第三者が署名する方法を提供します。カウンター署名パラメーターは、COSE_Sign1、COSE_Signature、COSE_Encrypt、COSE_recipient、COSE_Encrypt0、COSE_Mac、およびCOSE_Mac0のいずれかの構造で、保護されていない属性として発生する可能性があります。これらの構造はすべて同じ開始要素を持っているため、カウンター署名の一貫した計算を計算できます。カウンター署名の計算の詳細については、セクション4.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+----------------+-------------+----------------+\n| Name      | Label | Value Type     | Value       | Description    |\n|           |       |                | Registry    |                |\n+-----------+-------+----------------+-------------+----------------+\n| alg       | 1     | int / tstr     | COSE        | Cryptographic  |\n|           |       |                | Algorithms  | algorithm to   |\n|           |       |                | registry    | use            |\n| crit      | 2     | [+ label]      | COSE Header | Critical       |\n|           |       |                | Parameters  | headers to be  |\n|           |       |                | registry    | understood     |\n| content   | 3     | tstr / uint    | CoAP        | Content type   |\n| type      |       |                | Content-    | of the payload |\n|           |       |                | Formats or  |                |\n|           |       |                | Media Types |                |\n|           |       |                | registries  |                |\n| kid       | 4     | bstr           |             | Key identifier |\n| IV        | 5     | bstr           |             | Full           |\n|           |       |                |             | Initialization |\n|           |       |                |             | Vector         |\n| Partial   | 6     | bstr           |             | Partial        |\n| IV        |       |                |             | Initialization |\n|           |       |                |             | Vector         |\n| counter   | 7     | COSE_Signature |             | CBOR-encoded   |\n| signature |       | / [+           |             | signature      |\n|           |       | COSE_Signature |             | structure      |\n|           |       | ]              |             |                |\n+-----------+-------+----------------+-------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 2: Common Header Parameters",
      "ja": "表2：一般的なヘッダーパラメータ"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that represents the set of headers defined in this section is given below. Each of the headers is tagged as optional because they do not need to be in every map; headers required in specific maps are discussed above.",
      "ja": "このセクションで定義されているヘッダーのセットを表すCDDLフラグメントを以下に示します。各ヘッダーはすべてのマップにある必要がないため、オプションとしてタグ付けされています。特定のマップで必要なヘッダーについては、上記で説明しています。"
    },
    {
      "indent": 3,
      "text": "Generic_Headers = (\n    ? 1 => int / tstr,  ; algorithm identifier\n    ? 2 => [+label],    ; criticality\n    ? 3 => tstr / int,  ; content type\n    ? 4 => bstr,        ; key identifier\n    ? 5 => bstr,        ; IV\n    ? 6 => bstr,        ; Partial IV\n    ? 7 => COSE_Signature / [+COSE_Signature] ; Counter signature\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Signing Objects",
      "section_title": true,
      "ja": "4. オブジェクトへの署名"
    },
    {
      "indent": 3,
      "text": "COSE supports two different signature structures. COSE_Sign allows for one or more signatures to be applied to the same content. COSE_Sign1 is restricted to a single signer. The structures cannot be converted between each other; as the signature computation includes a parameter identifying which structure is being used, the converted structure will fail signature validation.",
      "ja": "COSEは2つの異なる署名構造をサポートしています。 COSE_Signを使用すると、1つ以上の署名を同じコンテンツに適用できます。 COSE_Sign1は単一の署名者に制限されています。構造は相互に変換できません。署名の計算には、使用されている構造を識別するパラメーターが含まれているため、変換された構造は署名の検証に失敗します。"
    },
    {
      "indent": 0,
      "text": "4.1. Signing with One or More Signers",
      "section_title": true,
      "ja": "4.1. 1人以上の署名者による署名"
    },
    {
      "indent": 3,
      "text": "The COSE_Sign structure allows for one or more signatures to be applied to a message payload. Parameters relating to the content and parameters relating to the signature are carried along with the signature itself. These parameters may be authenticated by the signature, or just present. An example of a parameter about the content is the content type. Examples of parameters about the signature would be the algorithm and key used to create the signature and counter signatures.",
      "ja": "COSE_Sign構造では、1つ以上の署名をメッセージペイロードに適用できます。内容に関連するパラメータと署名に関連するパラメータは、署名自体と一緒に運ばれます。これらのパラメータは、署名によって認証されるか、存在するだけです。コンテンツに関するパラメーターの例は、コンテンツタイプです。署名に関するパラメーターの例は、署名とカウンター署名の作成に使用されるアルゴリズムとキーです。"
    },
    {
      "indent": 3,
      "text": "RFC 5652 indicates that:",
      "ja": "RFC 5652は次のことを示しています。"
    },
    {
      "indent": 6,
      "text": "When more than one signature is present, the successful validation of one signature associated with a given signer is usually treated as a successful signature by that signer. However, there are some application environments where other rules are needed. An application that employs a rule other than one valid signature for each signer must specify those rules. Also, where simple matching of the signer identifier is not sufficient to determine whether the signatures were generated by the same signer, the application specification must describe how to determine which signatures were generated by the same signer. Support for different communities of recipients is the primary reason that signers choose to include more than one signature.",
      "ja": "複数の署名が存在する場合、特定の署名者に関連付けられた1つの署名の検証が成功すると、通常、その署名者は成功した署名として扱います。ただし、他のルールが必要なアプリケーション環境もあります。署名者ごとに1つの有効な署名以外のルールを使用するアプリケーションは、それらのルールを指定する必要があります。また、署名が同じ署名者によって生成されたかどうかを判断するために署名者識別子の単純な照合では不十分な場合、アプリケーション仕様では、同じ署名者によって生成された署名を判断する方法を説明する必要があります。受信者のさまざまなコミュニティのサポートは、署名者が複数の署名を含めることを選択する主な理由です。"
    },
    {
      "indent": 3,
      "text": "For example, the COSE_Sign structure might include signatures generated with the Edwards-curve Digital Signature Algorithm (EdDSA) [RFC8032] and with the Elliptic Curve Digital Signature Algorithm (ECDSA) [DSS]. This allows recipients to verify the signature associated with one algorithm or the other. More-detailed information on multiple signature evaluations can be found in [RFC5752].",
      "ja": "たとえば、COSE_Sign構造には、エドワーズ曲線デジタル署名アルゴリズム（EdDSA）[RFC8032]と楕円曲線デジタル署名アルゴリズム（ECDSA）[DSS]で生成された署名が含まれる場合があります。これにより、受信者はいずれかのアルゴリズムに関連付けられた署名を検証できます。複数の署名評価の詳細については、[RFC5752]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The signature structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Sign structure is identified by the CBOR tag 98. The CDDL fragment that represents this is:",
      "ja": "署名構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Sign構造は、CBORタグ98によって識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Sign_Tagged = #6.98(COSE_Sign)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A COSE Signed Message is defined in two parts. The CBOR object that carries the body and information about the body is called the COSE_Sign structure. The CBOR object that carries the signature and information about the signature is called the COSE_Signature structure. Examples of COSE Signed Messages can be found in Appendix C.1.",
      "ja": "COSE署名付きメッセージは2つの部分で定義されます。本文と本文に関する情報を運ぶCBORオブジェクトは、COSE_Sign構造と呼ばれます。署名と署名に関する情報を運ぶCBORオブジェクトは、COSE_Signature構造と呼ばれます。 COSE署名付きメッセージの例は、付録C.1にあります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Sign structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Sign構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "payload: This field contains the serialized content to be signed. If the payload is not present in the message, the application is required to supply the payload separately. The payload is wrapped in a bstr to ensure that it is transported without changes. If the payload is transported separately (\"detached content\"), then a nil CBOR object is placed in this location, and it is the responsibility of the application to ensure that it will be transported without changes.",
      "ja": "payload：このフィールドには、署名されるシリアル化されたコンテンツが含まれます。ペイロードがメッセージに存在しない場合、アプリケーションはペイロードを個別に提供する必要があります。ペイロードはbstrでラップされ、変更なしで確実に転送されます。ペイロードが個別に転送される場合（「切り離されたコンテンツ」）、nil CBORオブジェクトがこの場所に配置されます。変更なしで転送されることを確認するのはアプリケーションの責任です。"
    },
    {
      "indent": 6,
      "text": "Note: When a signature with a message recovery algorithm is used (Section 8), the maximum number of bytes that can be recovered is the length of the payload. The size of the payload is reduced by the number of bytes that will be recovered. If all of the bytes of the payload are consumed, then the payload is encoded as a zero-length binary string rather than as being absent.",
      "ja": "注：メッセージ回復アルゴリズムを使用した署名を使用する場合（セクション8）、回復できる最大バイト数はペイロードの長さです。ペイロードのサイズは、回復されるバイト数だけ減少します。ペイロードのすべてのバイトが消費された場合、ペイロードは存在しないのではなく、長さがゼロのバイナリ文字列としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "signatures: This field is an array of signatures. Each signature is represented as a COSE_Signature structure.",
      "ja": "署名：このフィールドは署名の配列です。各署名は、COSE_Signature構造として表されます。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that represents the above text for COSE_Sign follows.",
      "ja": "COSE_Signの上記のテキストを表すCDDLフラグメントが続きます。"
    },
    {
      "indent": 3,
      "text": "COSE_Sign = [\n    Headers,\n    payload : bstr / nil,\n    signatures : [+ COSE_Signature]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_Signature structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Signature構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "signature: This field contains the computed signature value. The type of the field is a bstr. Algorithms MUST specify padding if the signature value is not a multiple of 8 bits.",
      "ja": "署名：このフィールドには、計算された署名値が含まれます。フィールドのタイプはbstrです。署名値が8ビットの倍数でない場合、アルゴリズムはパディングを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that represents the above text for COSE_Signature follows.",
      "ja": "COSE_Signatureの上記のテキストを表すCDDLフラグメントが続きます。"
    },
    {
      "indent": 3,
      "text": "COSE_Signature =  [\n    Headers,\n    signature : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Signing with One Signer",
      "section_title": true,
      "ja": "4.2. 1人の署名者による署名"
    },
    {
      "indent": 3,
      "text": "The COSE_Sign1 signature structure is used when only one signature is going to be placed on a message. The parameters dealing with the content and the signature are placed in the same pair of buckets rather than having the separation of COSE_Sign.",
      "ja": "COSE_Sign1署名構造は、1つの署名のみがメッセージに配置される場合に使用されます。コンテンツと署名を処理するパラメーターは、COSE_Signを分離するのではなく、同じバケットのペアに配置されます。"
    },
    {
      "indent": 3,
      "text": "The structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Sign1 structure is identified by the CBOR tag 18. The CDDL fragment that represents this is:",
      "ja": "構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Sign1構造は、CBORタグ18によって識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Sign1_Tagged = #6.18(COSE_Sign1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The CBOR object that carries the body, the signature, and the information about the body and signature is called the COSE_Sign1 structure. Examples of COSE_Sign1 messages can be found in Appendix C.2.",
      "ja": "本文、署名、および本文と署名に関する情報を運ぶCBORオブジェクトは、COSE_Sign1構造と呼ばれます。 COSE_Sign1メッセージの例は、付録C.2にあります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Sign1 structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Sign1構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "payload: This is as described in Section 4.1.",
      "ja": "ペイロード：これは、セクション4.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "signature: This field contains the computed signature value. The type of the field is a bstr.",
      "ja": "署名：このフィールドには、計算された署名値が含まれます。フィールドのタイプはbstrです。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that represents the above text for COSE_Sign1 follows.",
      "ja": "COSE_Sign1の上記のテキストを表すCDDLフラグメントが続きます。"
    },
    {
      "indent": 3,
      "text": "COSE_Sign1 = [\n    Headers,\n    payload : bstr / nil,\n    signature : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3. Externally Supplied Data",
      "section_title": true,
      "ja": "4.3. 外部から提供されるデータ"
    },
    {
      "indent": 3,
      "text": "One of the features offered in the COSE document is the ability for applications to provide additional data to be authenticated, but that is not carried as part of the COSE object. The primary reason for supporting this can be seen by looking at the CoAP message structure [RFC7252], where the facility exists for options to be carried before the payload. Examples of data that can be placed in this location would be the CoAP code or CoAP options. If the data is in the header section, then it is available for proxies to help in performing its operations. For example, the Accept Option can be used by a proxy to determine if an appropriate value is in the proxy's cache. But the sender can prevent a proxy from changing the set of values that it will accept by including that value in the resulting authentication tag. However, it may also be desired to protect these values so that if they are modified in transit, it can be detected.",
      "ja": "COSEドキュメントで提供される機能の1つは、アプリケーションが認証する追加データを提供する機能ですが、これはCOSEオブジェクトの一部としては実行されません。これをサポートする主な理由は、CoAPメッセージ構造[RFC7252]を見るとわかります。ここでは、ペイロードの前に実行されるオプション用のファシリティが存在します。この場所に配置できるデータの例は、CoAPコードまたはCoAPオプションです。データがヘッダーセクションにある場合、プロキシはその操作を実行するのに役立ちます。たとえば、プロキシはAccept Optionを使用して、適切な値がプロキシのキャッシュにあるかどうかを判断できます。ただし、送信者は、結果の認証タグにその値を含めることにより、プロキシが受け入れる値のセットを変更できないようにすることができます。ただし、これらの値を保護して、転送中に変更された場合に検出できるようにすることもできます。"
    },
    {
      "indent": 3,
      "text": "This document describes the process for using a byte array of externally supplied authenticated data; however, the method of constructing the byte array is a function of the application. Applications that use this feature need to define how the externally supplied authenticated data is to be constructed. Such a construction needs to take into account the following issues:",
      "ja": "このドキュメントでは、外部から提供される認証済みデータのバイト配列を使用するプロセスについて説明します。ただし、バイト配列を作成する方法はアプリケーションの機能です。この機能を使用するアプリケーションは、外部から提供された認証済みデータの構築方法を定義する必要があります。このような構造では、次の問題を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": " o If multiple items are included, applications need to ensure that the same byte string is not produced if there are different inputs. This could occur by appending the strings 'AB' and 'CDE' or by appending the strings 'ABC' and 'DE'. This is usually addressed by making fields a fixed width and/or encoding the length of the field as part of the output. Using options from CoAP [RFC7252] as an example, these fields use a TLV structure so they can be concatenated without any problems.",
      "ja": "o複数のアイテムが含まれる場合、アプリケーションは、異なる入力がある場合に同じバイト文字列が生成されないようにする必要があります。これは、文字列「AB」と「CDE」を追加するか、文字列「ABC」と「DE」を追加することで発生する可能性があります。これは通常、フィールドを固定幅にしたり、出力の一部としてフィールドの長さをエンコードしたりすることで対処されます。例としてCoAP [RFC7252]のオプションを使用すると、これらのフィールドはTLV構造を使用するため、問題なく連結できます。"
    },
    {
      "indent": 3,
      "text": "o If multiple items are included, an order for the items needs to be defined. Using options from CoAP as an example, an application could state that the fields are to be ordered by the option number.",
      "ja": "o 複数のアイテムが含まれている場合は、アイテムの順序を定義する必要があります。例としてCoAPのオプションを使用すると、アプリケーションは、フィールドがオプション番号で順序付けられることを示すことができます。"
    },
    {
      "indent": 3,
      "text": "o Applications need to ensure that the byte stream is going to be the same on both sides. Using options from CoAP might give a problem if the same relative numbering is kept. An intermediate node could insert or remove an option, changing how the relative number is done. An application would need to specify that the relative number must be re-encoded to be relative only to the options that are in the external data.",
      "ja": "o アプリケーションは、バイトストリームが両側で同じになるようにする必要があります。 CoAPのオプションを使用すると、同じ相対番号が維持される場合に問題が発生する可能性があります。中間ノードはオプションを挿入または削除し、相対数の実行方法を変更できます。アプリケーションは、相対データが外部データにあるオプションのみに関連するように再エンコードする必要があることを指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Signing and Verification Process",
      "section_title": true,
      "ja": "4.4. 署名と検証のプロセス"
    },
    {
      "indent": 3,
      "text": "In order to create a signature, a well-defined byte stream is needed. The Sig_structure is used to create the canonical form. This signing and verification process takes in the body information (COSE_Sign or COSE_Sign1), the signer information (COSE_Signature), and the application data (external source). A Sig_structure is a CBOR array. The fields of the Sig_structure in order are:",
      "ja": "署名を作成するには、明確に定義されたバイトストリームが必要です。 Sig_structureは、正規フォームを作成するために使用されます。この署名および検証プロセスでは、本文情報（COSE_SignまたはCOSE_Sign1）、署名者情報（COSE_Signature）、およびアプリケーションデータ（外部ソース）を取り込みます。 Sig_structureはCBOR配列です。 Sig_structureのフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. A text string identifying the context of the signature. The context string is:",
      "ja": "1. 署名のコンテキストを識別するテキスト文字列。コンテキスト文字列は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "\"Signature\" for signatures using the COSE_Signature structure.",
      "ja": "COSE_Signature構造を使用した署名の「署名」。"
    },
    {
      "indent": 10,
      "text": "\"Signature1\" for signatures using the COSE_Sign1 structure.",
      "ja": "COSE_Sign1構造を使用する署名の場合は「Signature1」。"
    },
    {
      "indent": 10,
      "text": "\"CounterSignature\" for signatures used as counter signature attributes.",
      "ja": "カウンター署名属性として使用される署名の「CounterSignature」。"
    },
    {
      "indent": 3,
      "text": "2. The protected attributes from the body structure encoded in a bstr type. If there are no protected attributes, a bstr of length zero is used.",
      "ja": "2. bstrタイプでエンコードされた本体構造の保護された属性。保護された属性がない場合は、長さがゼロのbstrが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. The protected attributes from the signer structure encoded in a bstr type. If there are no protected attributes, a bstr of length zero is used. This field is omitted for the COSE_Sign1 signature structure.",
      "ja": "3. bstrタイプでエンコードされた署名者構造の保護された属性。保護された属性がない場合は、長さがゼロのbstrが使用されます。このフィールドは、COSE_Sign1署名構造では省略されます。"
    },
    {
      "indent": 3,
      "text": "4. The protected attributes from the application encoded in a bstr type. If this field is not supplied, it defaults to a zero-length binary string. (See Section 4.3 for application guidance on constructing this field.)",
      "ja": "4. bstrタイプでエンコードされたアプリケーションの保護された属性。このフィールドが指定されていない場合、デフォルトで長さがゼロのバイナリ文字列になります。 （このフィールドの作成に関するアプリケーションガイダンスについては、セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "5. The payload to be signed encoded in a bstr type. The payload is placed here independent of how it is transported.",
      "ja": "5. 署名されるペイロードは、bstrタイプでエンコードされます。ペイロードは、転送方法とは無関係にここに配置されます。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that describes the above text is:",
      "ja": "上記のテキストを説明するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Sig_structure = [\n    context : \"Signature\" / \"Signature1\" / \"CounterSignature\",\n    body_protected : empty_or_serialized_map,\n    ? sign_protected : empty_or_serialized_map,\n    external_aad : bstr,\n    payload : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "How to compute a signature:",
      "ja": "署名を計算する方法："
    },
    {
      "indent": 3,
      "text": "1. Create a Sig_structure and populate it with the appropriate fields.",
      "ja": "1. Sig_structureを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Create the value ToBeSigned by encoding the Sig_structure to a byte string, using the encoding described in Section 14.",
      "ja": "2. セクション14で説明されているエンコードを使用して、Sig_structureをバイト文字列にエンコードすることにより、値ToBeSignedを作成します。"
    },
    {
      "indent": 3,
      "text": "3. Call the signature creation algorithm passing in K (the key to sign with), alg (the algorithm to sign with), and ToBeSigned (the value to sign).",
      "ja": "3. K（署名する鍵）、alg（署名するアルゴリズム）、およびToBeSigned（署名する値）を渡して署名作成アルゴリズムを呼び出します。"
    },
    {
      "indent": 3,
      "text": "4. Place the resulting signature value in the 'signature' field of the array.",
      "ja": "4. 結果の署名値を配列の「署名」フィールドに配置します。"
    },
    {
      "indent": 3,
      "text": "The steps for verifying a signature are:",
      "ja": "署名を確認する手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Create a Sig_structure object and populate it with the appropriate fields.",
      "ja": "1. Sig_structureオブジェクトを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Create the value ToBeSigned by encoding the Sig_structure to a byte string, using the encoding described in Section 14.",
      "ja": "2. セクション14で説明されているエンコードを使用して、Sig_structureをバイト文字列にエンコードすることにより、値ToBeSignedを作成します。"
    },
    {
      "indent": 3,
      "text": "3. Call the signature verification algorithm passing in K (the key to verify with), alg (the algorithm used sign with), ToBeSigned (the value to sign), and sig (the signature to be verified).",
      "ja": "3. K（検証に使用するキー）、alg（署名に使用するアルゴリズム）、ToBeSigned（署名に使用する値）、およびsig（検証する署名）を渡して署名検証アルゴリズムを呼び出します。"
    },
    {
      "indent": 3,
      "text": "In addition to performing the signature verification, the application may also perform the appropriate checks to ensure that the key is correctly paired with the signing identity and that the signing identity is authorized before performing actions.",
      "ja": "署名の検証に加えて、アプリケーションは適切なチェックを実行して、キーが署名IDと正しくペアリングされていること、およびアクションを実行する前に署名IDが承認されていることを確認することもできます。"
    },
    {
      "indent": 0,
      "text": "4.5. Computing Counter Signatures",
      "section_title": true,
      "ja": "4.5. カウンター署名の計算"
    },
    {
      "indent": 3,
      "text": "Counter signatures provide a method of associating a different signature generated by different signers with some piece of content. This is normally used to provide a signature on a signature allowing for a proof that a signature existed at a given time (i.e., a Timestamp). In this document, we allow for counter signatures to exist in a greater number of environments. As an example, it is possible to place a counter signature in the unprotected attributes of a COSE_Encrypt object. This would allow for an intermediary to either verify that the encrypted byte stream has not been modified, without being able to decrypt it, or assert that an encrypted byte stream either existed at a given time or passed through it in terms of routing (i.e., a proxy signature).",
      "ja": "カウンター署名は、さまざまな署名者によって生成されたさまざまな署名をコンテンツの一部に関連付ける方法を提供します。これは通常、署名に署名を提供するために使用され、特定の時間に署名が存在したことを証明できるようにします（タイムスタンプなど）。このドキュメントでは、より多くの環境にカウンター署名が存在することを許可しています。例として、COSE_Encryptオブジェクトの保護されていない属性に副署名を配置することが可能です。これにより、仲介者は、暗号化されたバイトストリームが復号化されずに変更されていないことを確認するか、暗号化されたバイトストリームが特定の時間に存在したか、ルーティングの観点から通過したことをアサートできます（つまり、プロキシ署名）。"
    },
    {
      "indent": 3,
      "text": "An example of a counter signature on a signature can be found in Appendix C.1.3. An example of a counter signature in an encryption object can be found in Appendix C.3.3.",
      "ja": "署名の副署名の例は、付録C.1.3にあります。暗号化オブジェクトの副署名の例は、付録C.3.3にあります。"
    },
    {
      "indent": 3,
      "text": "The creation and validation of counter signatures over the different items relies on the fact that the objects have the same structure. The elements are a set of protected attributes, a set of unprotected attributes, and a body, in that order. This means that the Sig_structure can be used in a uniform manner to get the byte stream for processing a signature. If the counter signature is going to be computed over a COSE_Encrypt structure, the body_protected and payload items can be mapped into the Sig_structure in the same manner as from the COSE_Sign structure.",
      "ja": "さまざまなアイテムに対する副署名の作成と検証は、オブジェクトの構造が同じであるという事実に依存しています。要素は、保護された属性のセット、保護されていない属性のセット、および本文の順序です。これは、署名を処理するためのバイトストリームを取得するためにSig_structureを統一された方法で使用できることを意味します。カウンター署名がCOSE_Encrypt構造を介して計算される場合、body_protectedおよびペイロード項目は、COSE_Sign構造からと同じ方法でSig_structureにマップできます。"
    },
    {
      "indent": 3,
      "text": "It should be noted that only a signature algorithm with appendix (see Section 8) can be used for counter signatures. This is because the body should be able to be processed without having to evaluate the counter signature, and this is not possible for signature schemes with message recovery.",
      "ja": "付録の署名アルゴリズム（セクション8を参照）のみがカウンター署名に使用できることに注意してください。これは、カウンター署名を評価せずに本文を処理できる必要があるためです。これは、メッセージ回復を伴う署名スキームでは不可能です。"
    },
    {
      "indent": 0,
      "text": "5. Encryption Objects",
      "section_title": true,
      "ja": "5. 暗号化オブジェクト"
    },
    {
      "indent": 3,
      "text": "COSE supports two different encryption structures. COSE_Encrypt0 is used when a recipient structure is not needed because the key to be used is known implicitly. COSE_Encrypt is used the rest of the time. This includes cases where there are multiple recipients or a recipient algorithm other than direct is used.",
      "ja": "COSEは2つの異なる暗号化構造をサポートしています。 COSE_Encrypt0は、使用するキーが暗黙的にわかっているために受信者構造が必要ない場合に使用されます。残りの時間はCOSE_Encryptが使用されます。これには、複数の受信者がいる場合や、direct以外の受信者アルゴリズムが使用されている場合が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.1. Enveloped COSE Structure",
      "section_title": true,
      "ja": "5.1. エンベロープTHINGS構造"
    },
    {
      "indent": 3,
      "text": "The enveloped structure allows for one or more recipients of a message. There are provisions for parameters about the content and parameters about the recipient information to be carried in the message. The protected parameters associated with the content are authenticated by the content encryption algorithm. The protected parameters associated with the recipient are authenticated by the recipient algorithm (when the algorithm supports it). Examples of parameters about the content are the type of the content and the content encryption algorithm. Examples of parameters about the recipient are the recipient's key identifier and the recipient's encryption algorithm.",
      "ja": "エンベロープ構造では、メッセージの1人以上の受信者が許可されます。内容に関するパラメータとメッセージで運ばれる受信者情報に関するパラメータの規定があります。コンテンツに関連付けられた保護されたパラメーターは、コンテンツ暗号化アルゴリズムによって認証されます。受信者に関連付けられている保護されたパラメーターは、受信者アルゴリズム（アルゴリズムがサポートしている場合）によって認証されます。コンテンツに関するパラメーターの例は、コンテンツのタイプとコンテンツ暗号化アルゴリズムです。受信者に関するパラメータの例は、受信者のキー識別子と受信者の暗号化アルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "The same techniques and structures are used for encrypting both the plaintext and the keys. This is different from the approach used by both \"Cryptographic Message Syntax (CMS)\" [RFC5652] and \"JSON Web Encryption (JWE)\" [RFC7516] where different structures are used for the content layer and for the recipient layer. Two structures are defined: COSE_Encrypt to hold the encrypted content and COSE_recipient to hold the encrypted keys for recipients. Examples of encrypted messages can be found in Appendix C.3.",
      "ja": "平文とキーの両方を暗号化するために同じテクニックと構造が使用されます。これは、「暗号化メッセージ構文（CMS）」[RFC5652]と「JSON Web暗号化（JWE）」[RFC7516]の両方で使用されるアプローチとは異なり、コンテンツ層と受信者層で異なる構造が使用されます。暗号化されたコンテンツを保持するCOSE_Encryptと、受信者の暗号化された鍵を保持するCOSE_recipientの2つの構造が定義されています。暗号化されたメッセージの例は、付録C.3にあります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Encrypt structure is identified by the CBOR tag 96. The CDDL fragment that represents this is:",
      "ja": "COSE_Encrypt構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Encrypt構造は、CBORタグ96によって識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Encrypt構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "ciphertext: This field contains the ciphertext encoded as a bstr. If the ciphertext is to be transported independently of the control information about the encryption process (i.e., detached content), then the field is encoded as a nil value.",
      "ja": "暗号文：このフィールドには、bstrとしてエンコードされた暗号文が含まれます。暗号化テキストが暗号化プロセスに関する制御情報（つまり、分離されたコンテンツ）とは無関係に転送される場合、フィールドはnil値としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "recipients: This field contains an array of recipient information structures. The type for the recipient information structure is a COSE_recipient.",
      "ja": "受信者：このフィールドには、受信者情報構造の配列が含まれます。受信者情報構造のタイプはCOSE_recipientです。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that corresponds to the above text is:",
      "ja": "上記のテキストに対応するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Encrypt = [\n    Headers,\n    ciphertext : bstr / nil,\n    recipients : [+COSE_recipient]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_recipient structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_recipient構造体はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "ciphertext: This field contains the encrypted key encoded as a bstr. All encoded keys are symmetric keys; the binary value of the key is the content. If there is not an encrypted key, then this field is encoded as a nil value.",
      "ja": "ciphertext：このフィールドには、bstrとしてエンコードされた暗号化キーが含まれます。エンコードされた鍵はすべて対称鍵です。キーのバイナリ値がコンテンツです。暗号化されたキーがない場合、このフィールドはnil値としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "recipients: This field contains an array of recipient information structures. The type for the recipient information structure is a COSE_recipient (an example of this can be found in Appendix B). If there are no recipient information structures, this element is absent.",
      "ja": "受信者：このフィールドには、受信者情報構造の配列が含まれます。受信者情報構造のタイプはCOSE_recipientです（この例は付録Bにあります）。受信者情報構造がない場合、この要素はありません。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that corresponds to the above text for COSE_recipient is:",
      "ja": "上記のCOSE_recipientのテキストに対応するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_recipient = [\n    Headers,\n    ciphertext : bstr / nil,\n    ? recipients : [+COSE_recipient]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.1. Content Key Distribution Methods",
      "section_title": true,
      "ja": "5.1.1. コンテンツキーの配布方法"
    },
    {
      "indent": 3,
      "text": "An encrypted message consists of an encrypted content and an encrypted CEK for one or more recipients. The CEK is encrypted for each recipient, using a key specific to that recipient. The details of this encryption depend on which class the recipient algorithm falls into. Specific details on each of the classes can be found in Section 12. A short summary of the five content key distribution methods is:",
      "ja": "暗号化されたメッセージは、暗号化されたコンテンツと1人以上の受信者用の暗号化されたCEKで構成されます。 CEKは、その受信者に固有のキーを使用して、受信者ごとに暗号化されます。この暗号化の詳細は、受信者アルゴリズムがどのクラスに該当するかによって異なります。各クラスの具体的な詳細については、セクション12を参照してください。5つのコンテンツキー配布方法の簡単な要約は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "direct: The CEK is the same as the identified previously distributed symmetric key or is derived from a previously distributed secret. No CEK is transported in the message.",
      "ja": "直接：CEKは、識別された以前に配布された対称鍵と同じであるか、以前に配布された秘密から導出されます。メッセージではCEKは転送されません。"
    },
    {
      "indent": 3,
      "text": "symmetric key-encryption keys (KEK): The CEK is encrypted using a previously distributed symmetric KEK. Also known as key wrap.",
      "ja": "対称鍵暗号鍵（KEK）：CEKは、以前に配布された対称KEKを使用して暗号化されます。キーラップとも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "key agreement: The recipient's public key and a sender's private key are used to generate a pairwise secret, a Key Derivation Function (KDF) is applied to derive a key, and then the CEK is either the derived key or encrypted by the derived key.",
      "ja": "鍵合意：受信者の公開鍵と送信者の秘密鍵を使用してペアワイズシークレットを生成し、鍵導出関数（KDF）を適用して鍵を導出します。その後、CEKは導出鍵または導出鍵によって暗号化されます。"
    },
    {
      "indent": 3,
      "text": "key transport: The CEK is encrypted with the recipient's public key. No key transport algorithms are defined in this document.",
      "ja": "鍵転送：CEKは受信者の公開鍵で暗号化されます。このドキュメントでは、キー転送アルゴリズムは定義されていません。"
    },
    {
      "indent": 3,
      "text": "passwords: The CEK is encrypted in a KEK that is derived from a password. No password algorithms are defined in this document.",
      "ja": "パスワード：CEKは、パスワードから派生したKEKで暗号化されます。このドキュメントでは、パスワードアルゴリズムは定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.2. Single Recipient Encrypted",
      "section_title": true,
      "ja": "5.2. 暗号化された単一の受信者"
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt0 encrypted structure does not have the ability to specify recipients of the message. The structure assumes that the recipient of the object will already know the identity of the key to be used in order to decrypt the message. If a key needs to be identified to the recipient, the enveloped structure ought to be used.",
      "ja": "COSE_Encrypt0暗号化構造には、メッセージの受信者を指定する機能がありません。この構造は、オブジェクトの受信者がメッセージを復号化するために使用されるキーのIDをすでに知っていることを前提としています。受信者がキーを識別する必要がある場合は、エンベロープ構造を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Examples of encrypted messages can be found in Appendix C.3.",
      "ja": "暗号化されたメッセージの例は、付録C.3にあります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt0 structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Encrypt0 structure is identified by the CBOR tag 16. The CDDL fragment that represents this is:",
      "ja": "COSE_Encrypt0構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Encrypt0構造は、CBORタグ16によって識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Encrypt0_Tagged = #6.16(COSE_Encrypt0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt0 structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Encrypt0構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "ciphertext: This is as described in Section 5.1.",
      "ja": "暗号文：セクション5.1で説明したとおりです。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment for COSE_Encrypt0 that corresponds to the above text is:",
      "ja": "上記のテキストに対応するCOSE_Encrypt0のCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Encrypt0 = [\n    Headers,\n    ciphertext : bstr / nil,\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. How to Encrypt and Decrypt for AEAD Algorithms",
      "section_title": true,
      "ja": "5.3. AEADアルゴリズムの暗号化と復号化の方法"
    },
    {
      "indent": 3,
      "text": "The encryption algorithm for AEAD algorithms is fairly simple. The first step is to create a consistent byte stream for the authenticated data structure. For this purpose, we use an Enc_structure. The Enc_structure is a CBOR array. The fields of the Enc_structure in order are:",
      "ja": "AEADアルゴリズムの暗号化アルゴリズムはかなり単純です。最初のステップは、認証されたデータ構造に対して一貫性のあるバイトストリームを作成することです。この目的のために、Enc_structureを使用します。 Enc_structureはCBOR配列です。 Enc_structureのフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. A text string identifying the context of the authenticated data structure. The context string is:",
      "ja": "1. 認証されたデータ構造のコンテキストを識別するテキスト文字列。コンテキスト文字列は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "\"Encrypt0\" for the content encryption of a COSE_Encrypt0 data structure.",
      "ja": "COSE_Encrypt0データ構造のコンテンツ暗号化のための「Encrypt0」。"
    },
    {
      "indent": 10,
      "text": "\"Encrypt\" for the first layer of a COSE_Encrypt data structure (i.e., for content encryption).",
      "ja": "COSE_Encryptデータ構造の最初のレイヤーの「暗号化」（つまり、コンテンツの暗号化）。"
    },
    {
      "indent": 10,
      "text": "\"Enc_Recipient\" for a recipient encoding to be placed in an COSE_Encrypt data structure.",
      "ja": "\"Enc_Recipient\"は、COSE_Encryptデータ構造に配置される受信者エンコーディングです。"
    },
    {
      "indent": 10,
      "text": "\"Mac_Recipient\" for a recipient encoding to be placed in a MACed message structure.",
      "ja": "MACedメッセージ構造に配置される受信者エンコーディングの「Mac_Recipient」。"
    },
    {
      "indent": 10,
      "text": "\"Rec_Recipient\" for a recipient encoding to be placed in a recipient structure.",
      "ja": "「Rec_Recipient」は、受信者構造に配置される受信者エンコーディングです。"
    },
    {
      "indent": 3,
      "text": "2. The protected attributes from the body structure encoded in a bstr type. If there are no protected attributes, a bstr of length zero is used.",
      "ja": "2. bstrタイプでエンコードされた本体構造の保護された属性。保護された属性がない場合は、長さがゼロのbstrが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. The protected attributes from the application encoded in a bstr type. If this field is not supplied, it defaults to a zero-length bstr. (See Section 4.3 for application guidance on constructing this field.)",
      "ja": "3. bstrタイプでエンコードされたアプリケーションの保護された属性。このフィールドが指定されていない場合、デフォルトで長さがゼロのbstrになります。 （このフィールドの作成に関するアプリケーションガイダンスについては、セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that describes the above text is:",
      "ja": "上記のテキストを説明するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Enc_structure = [\n    context : \"Encrypt\" / \"Encrypt0\" / \"Enc_Recipient\" /\n        \"Mac_Recipient\" / \"Rec_Recipient\",\n    protected : empty_or_serialized_map,\n    external_aad : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "How to encrypt a message:",
      "ja": "メッセージを暗号化する方法："
    },
    {
      "indent": 3,
      "text": "1. Create an Enc_structure and populate it with the appropriate fields.",
      "ja": "1. Enc_structureを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Encode the Enc_structure to a byte stream (Additional Authenticated Data (AAD)), using the encoding described in Section 14.",
      "ja": "2. セクション14で説明されているエンコーディングを使用して、Enc_structureをバイトストリーム（追加認証データ（AAD））にエンコードします。"
    },
    {
      "indent": 3,
      "text": "3. Determine the encryption key (K). This step is dependent on the class of recipient algorithm being used. For:",
      "ja": "3. 暗号化キー（K）を決定します。この手順は、使用されている受信者アルゴリズムのクラスによって異なります。ために："
    },
    {
      "indent": 7,
      "text": "No Recipients: The key to be used is determined by the algorithm and key at the current layer. Examples are key transport keys (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared secrets.",
      "ja": "受信者なし：使用されるキーは、アルゴリズムと現在のレイヤーのキーによって決定されます。例は、キー転送キー（セクション12.3）、キーラップキー（セクション12.2.1）、または事前共有秘密です。"
    },
    {
      "indent": 7,
      "text": "Direct Encryption and Direct Key Agreement: The key is determined by the key and algorithm in the recipient structure. The encryption algorithm and size of the key to be used are inputs into the KDF used for the recipient. (For direct, the KDF can be thought of as the identity operation.) Examples of these algorithms are found in Sections 12.1.2 and 12.4.1.",
      "ja": "直接暗号化と直接鍵合意：鍵は、受信者構造の鍵とアルゴリズムによって決定されます。暗号化アルゴリズムと使用される鍵のサイズは、受信者に使用されるKDFへの入力です。 （直接の場合、KDFは識別演算と考えることができます。）これらのアルゴリズムの例は、セクション12.1.2および12.4.1にあります。"
    },
    {
      "indent": 7,
      "text": "Other: The key is randomly or pseudorandomly generated.",
      "ja": "その他：キーはランダムまたは疑似ランダムに生成されます。"
    },
    {
      "indent": 3,
      "text": "4. Call the encryption algorithm with K (the encryption key), P (the plaintext), and AAD. Place the returned ciphertext into the 'ciphertext' field of the structure.",
      "ja": "4. K（暗号化キー）、P（プレーンテキスト）、およびAADを使用して暗号化アルゴリズムを呼び出します。返された暗号文を構造体の「暗号文」フィールドに配置します。"
    },
    {
      "indent": 3,
      "text": "5. For recipients of the message, recursively perform the encryption algorithm for that recipient, using K (the encryption key) as the plaintext.",
      "ja": "5. メッセージの受信者に対して、平文としてK（暗号化キー）を使用して、その受信者の暗号化アルゴリズムを再帰的に実行します。"
    },
    {
      "indent": 3,
      "text": "How to decrypt a message:",
      "ja": "メッセージを復号化する方法："
    },
    {
      "indent": 3,
      "text": "1. Create an Enc_structure and populate it with the appropriate fields.",
      "ja": "1. Enc_structureを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Encode the Enc_structure to a byte stream (AAD), using the encoding described in Section 14.",
      "ja": "2. セクション14で説明されているエンコーディングを使用して、Enc_structureをバイトストリーム（AAD）にエンコードします。"
    },
    {
      "indent": 3,
      "text": "3. Determine the decryption key. This step is dependent on the class of recipient algorithm being used. For:",
      "ja": "3. 復号化キーを決定します。この手順は、使用されている受信者アルゴリズムのクラスによって異なります。ために："
    },
    {
      "indent": 7,
      "text": "No Recipients: The key to be used is determined by the algorithm and key at the current layer. Examples are key transport keys (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared secrets.",
      "ja": "受信者なし：使用されるキーは、アルゴリズムと現在のレイヤーのキーによって決定されます。例は、キー転送キー（セクション12.3）、キーラップキー（セクション12.2.1）、または事前共有秘密です。"
    },
    {
      "indent": 7,
      "text": "Direct Encryption and Direct Key Agreement: The key is determined by the key and algorithm in the recipient structure. The encryption algorithm and size of the key to be used are inputs into the KDF used for the recipient. (For direct, the KDF can be thought of as the identity operation.) Examples of these algorithms are found in Sections 12.1.2 and 12.4.1.",
      "ja": "直接暗号化と直接鍵合意：鍵は、受信者構造の鍵とアルゴリズムによって決定されます。暗号化アルゴリズムと使用される鍵のサイズは、受信者に使用されるKDFへの入力です。 （直接の場合、KDFは識別演算と考えることができます。）これらのアルゴリズムの例は、セクション12.1.2および12.4.1にあります。"
    },
    {
      "indent": 7,
      "text": "Other: The key is determined by decoding and decrypting one of the recipient structures.",
      "ja": "その他：鍵は、受信者構造の1つを復号化および復号化することによって決定されます。"
    },
    {
      "indent": 3,
      "text": "4. Call the decryption algorithm with K (the decryption key to use), C (the ciphertext), and AAD.",
      "ja": "4. K（使用する復号鍵）、C（暗号文）、およびAADを使用して復号アルゴリズムを呼び出します。"
    },
    {
      "indent": 0,
      "text": "5.4. How to Encrypt and Decrypt for AE Algorithms",
      "section_title": true,
      "ja": "5.4. AEアルゴリズムの暗号化と復号化の方法"
    },
    {
      "indent": 3,
      "text": "How to encrypt a message:",
      "ja": "メッセージを暗号化する方法："
    },
    {
      "indent": 3,
      "text": "1. Verify that the 'protected' field is empty.",
      "ja": "1. 「保護」フィールドが空であることを確認します。"
    },
    {
      "indent": 3,
      "text": "2. Verify that there was no external additional authenticated data supplied for this operation.",
      "ja": "2. この操作に提供された外部の追加認証データがなかったことを確認してください。"
    },
    {
      "indent": 3,
      "text": "3. Determine the encryption key. This step is dependent on the class of recipient algorithm being used. For:",
      "ja": "3. 暗号化キーを決定します。この手順は、使用されている受信者アルゴリズムのクラスによって異なります。ために："
    },
    {
      "indent": 7,
      "text": "No Recipients: The key to be used is determined by the algorithm and key at the current layer. Examples are key transport keys (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared secrets.",
      "ja": "受信者なし：使用されるキーは、アルゴリズムと現在のレイヤーのキーによって決定されます。例は、キー転送キー（セクション12.3）、キーラップキー（セクション12.2.1）、または事前共有秘密です。"
    },
    {
      "indent": 7,
      "text": "Direct Encryption and Direct Key Agreement: The key is determined by the key and algorithm in the recipient structure. The encryption algorithm and size of the key to be used are inputs into the KDF used for the recipient. (For direct, the KDF can be thought of as the identity operation.) Examples of these algorithms are found in Sections 12.1.2 and 12.4.1.",
      "ja": "直接暗号化と直接鍵合意：鍵は、受信者構造の鍵とアルゴリズムによって決定されます。暗号化アルゴリズムと使用される鍵のサイズは、受信者に使用されるKDFへの入力です。 （直接の場合、KDFは識別演算と考えることができます。）これらのアルゴリズムの例は、セクション12.1.2および12.4.1にあります。"
    },
    {
      "indent": 7,
      "text": "Other: The key is randomly generated.",
      "ja": "その他：キーはランダムに生成されます。"
    },
    {
      "indent": 3,
      "text": "4. Call the encryption algorithm with K (the encryption key to use) and P (the plaintext). Place the returned ciphertext into the 'ciphertext' field of the structure.",
      "ja": "4. 暗号化アルゴリズムをK（使用する暗号化キー）とP（プレーンテキスト）で呼び出します。返された暗号文を構造体の「暗号文」フィールドに配置します。"
    },
    {
      "indent": 3,
      "text": "5. For recipients of the message, recursively perform the encryption algorithm for that recipient, using K (the encryption key) as the plaintext.",
      "ja": "5. メッセージの受信者に対して、平文としてK（暗号化キー）を使用して、その受信者の暗号化アルゴリズムを再帰的に実行します。"
    },
    {
      "indent": 3,
      "text": "How to decrypt a message:",
      "ja": "メッセージを復号化する方法："
    },
    {
      "indent": 3,
      "text": "1. Verify that the 'protected' field is empty.",
      "ja": "1. 「保護」フィールドが空であることを確認します。"
    },
    {
      "indent": 3,
      "text": "2. Verify that there was no external additional authenticated data supplied for this operation.",
      "ja": "2. この操作に提供された外部の追加認証データがなかったことを確認してください。"
    },
    {
      "indent": 3,
      "text": "3. Determine the decryption key. This step is dependent on the class of recipient algorithm being used. For:",
      "ja": "3. 復号化キーを決定します。この手順は、使用されている受信者アルゴリズムのクラスによって異なります。ために："
    },
    {
      "indent": 7,
      "text": "No Recipients: The key to be used is determined by the algorithm and key at the current layer. Examples are key transport keys (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared secrets.",
      "ja": "受信者なし：使用されるキーは、アルゴリズムと現在のレイヤーのキーによって決定されます。例は、キー転送キー（セクション12.3）、キーラップキー（セクション12.2.1）、または事前共有秘密です。"
    },
    {
      "indent": 7,
      "text": "Direct Encryption and Direct Key Agreement: The key is determined by the key and algorithm in the recipient structure. The encryption algorithm and size of the key to be used are inputs into the KDF used for the recipient. (For direct, the KDF can be thought of as the identity operation.) Examples of these algorithms are found in Sections 12.1.2 and 12.4.1.",
      "ja": "直接暗号化と直接鍵合意：鍵は、受信者構造の鍵とアルゴリズムによって決定されます。暗号化アルゴリズムと使用される鍵のサイズは、受信者に使用されるKDFへの入力です。 （直接の場合、KDFは識別演算と考えることができます。）これらのアルゴリズムの例は、セクション12.1.2および12.4.1にあります。"
    },
    {
      "indent": 7,
      "text": "Other: The key is determined by decoding and decrypting one of the recipient structures.",
      "ja": "その他：鍵は、受信者構造の1つを復号化および復号化することによって決定されます。"
    },
    {
      "indent": 3,
      "text": "4. Call the decryption algorithm with K (the decryption key to use) and C (the ciphertext).",
      "ja": "4. K（使用する復号鍵）とC（暗号文）を使用して復号アルゴリズムを呼び出します。"
    },
    {
      "indent": 0,
      "text": "6. MAC Objects",
      "section_title": true,
      "ja": "6. MACオブジェクト"
    },
    {
      "indent": 3,
      "text": "COSE supports two different MAC structures. COSE_MAC0 is used when a recipient structure is not needed because the key to be used is implicitly known. COSE_MAC is used for all other cases. These include a requirement for multiple recipients, the key being unknown, and a recipient algorithm of other than direct.",
      "ja": "COSEは2つの異なるMAC構造をサポートしています。 COSE_MAC0は、使用されるキーが暗黙的にわかっているために受信者構造が必要ない場合に使用されます。 COSE_MACは他のすべての場合に使用されます。これらには、複数の受信者の要件、キーが不明であること、および直接以外の受信者アルゴリズムが含まれます。"
    },
    {
      "indent": 3,
      "text": "In this section, we describe the structure and methods to be used when doing MAC authentication in COSE. This document allows for the use of all of the same classes of recipient algorithms as are allowed for encryption.",
      "ja": "このセクションでは、COSEでMAC認証を行うときに使用する構造と方法について説明します。このドキュメントでは、暗号化で許可されているのと同じクラスの受信者アルゴリズムをすべて使用できます。"
    },
    {
      "indent": 0,
      "text": " When using MAC operations, there are two modes in which they can be used. The first is just a check that the content has not been changed since the MAC was computed. Any class of recipient algorithm can be used for this purpose. The second mode is to both check that the content has not been changed since the MAC was computed and to use the recipient algorithm to verify who sent it. The classes of recipient algorithms that support this are those that use a pre-shared secret or do static-static (SS) key agreement (without the key wrap step). In both of these cases, the entity that created and sent the message MAC can be validated. (This knowledge of the sender assumes that there are only two parties involved and that you did not send the message to yourself.) The origination property can be obtained with both of the MAC message structures.",
      "ja": "MACオペレーションを使用する場合、それらを使用できる2つのモードがあります。 1つ目は、MACが計算されてから内容が変更されていないことを確認するだけです。この目的には、任意のクラスの受信者アルゴリズムを使用できます。 2番目のモードは、MACが計算されてからコンテンツが変更されていないことを確認することと、受信者アルゴリズムを使用して誰が送信したかを確認することです。これをサポートする受信者アルゴリズムのクラスは、事前共有秘密を使用するか、静的-静的（SS）鍵合意を行うものです（鍵のラップ手順なし）。これらのどちらの場合でも、メッセージMACを作成して送信したエンティティを検証できます。 （送信者に関するこの知識は、関係する当事者が2つだけであり、メッセージを自分に送信しなかったことを前提としています。）発信プロパティは、両方のMACメッセージ構造で取得できます。"
    },
    {
      "indent": 0,
      "text": "6.1. MACed Message with Recipients",
      "section_title": true,
      "ja": "6.1. 受信者を含むMACedメッセージ"
    },
    {
      "indent": 3,
      "text": "The multiple recipient MACed message uses two structures: the COSE_Mac structure defined in this section for carrying the body and the COSE_recipient structure (Section 5.1) to hold the key used for the MAC computation. Examples of MACed messages can be found in Appendix C.5.",
      "ja": "複数の受信者のMACedメッセージは、本文を運ぶためにこのセクションで定義されたCOSE_Mac構造と、MAC計算に使用される鍵を保持するためのCOSE_recipient構造（セクション5.1）の2つの構造を使用します。 MACedメッセージの例は、付録C.5にあります。"
    },
    {
      "indent": 3,
      "text": "The MAC structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Mac structure is identified by the CBOR tag 97. The CDDL fragment that represents this is:",
      "ja": "MAC構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Mac構造は、CBORタグ97で識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Mac_Tagged = #6.97(COSE_Mac)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_Mac structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Mac構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "payload: This field contains the serialized content to be MACed. If the payload is not present in the message, the application is required to supply the payload separately. The payload is wrapped in a bstr to ensure that it is transported without changes. If the payload is transported separately (i.e., detached content), then a nil CBOR value is placed in this location, and it is the responsibility of the application to ensure that it will be transported without changes.",
      "ja": "ペイロード：このフィールドには、MAC処理されるシリアル化されたコンテンツが含まれます。ペイロードがメッセージに存在しない場合、アプリケーションはペイロードを個別に提供する必要があります。ペイロードはbstrでラップされ、変更なしで確実に転送されます。ペイロードが個別に転送される場合（つまり、分離されたコンテンツ）、nil CBOR値がこの場所に配置されます。変更なしで転送されることを確認するのはアプリケーションの責任です。"
    },
    {
      "indent": 3,
      "text": "tag: This field contains the MAC value.",
      "ja": "タグ：このフィールドにはMAC値が含まれます。"
    },
    {
      "indent": 3,
      "text": "recipients: This is as described in Section 5.1.",
      "ja": "受信者：セクション5.1で説明したとおりです。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that represents the above text for COSE_Mac follows.",
      "ja": "COSE_Macの上記のテキストを表すCDDLフラグメントが続きます。"
    },
    {
      "indent": 3,
      "text": "COSE_Mac = [\n   Headers,\n   payload : bstr / nil,\n   tag : bstr,\n   recipients :[+COSE_recipient]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. MACed Messages with Implicit Key",
      "section_title": true,
      "ja": "6.2. 暗黙のキーを持つMACedメッセージ"
    },
    {
      "indent": 3,
      "text": "In this section, we describe the structure and methods to be used when doing MAC authentication for those cases where the recipient is implicitly known.",
      "ja": "このセクションでは、受信者が暗黙的にわかっている場合にMAC認証を行うときに使用する構造と方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The MACed message uses the COSE_Mac0 structure defined in this section for carrying the body. Examples of MACed messages with an implicit key can be found in Appendix C.6.",
      "ja": "MACedメッセージは、このセクションで定義されたCOSE_Mac0構造を使用して本文を伝送します。暗黙の鍵を持つMAC化されたメッセージの例は、付録C.6にあります。"
    },
    {
      "indent": 3,
      "text": "The MAC structure can be encoded as either tagged or untagged depending on the context it will be used in. A tagged COSE_Mac0 structure is identified by the CBOR tag 17. The CDDL fragment that represents this is:",
      "ja": "MAC構造は、それが使用されるコンテキストに応じて、タグ付きまたはタグなしとしてエンコードできます。タグ付きCOSE_Mac0構造は、CBORタグ17で識別されます。これを表すCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Mac0_Tagged = #6.17(COSE_Mac0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The COSE_Mac0 structure is a CBOR array. The fields of the array in order are:",
      "ja": "COSE_Mac0構造はCBOR配列です。配列のフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "protected: This is as described in Section 3.",
      "ja": "保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "unprotected: This is as described in Section 3.",
      "ja": "非保護：これはセクション3で説明されています。"
    },
    {
      "indent": 3,
      "text": "payload: This is as described in Section 6.1.",
      "ja": "ペイロード：これは、セクション6.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "tag: This field contains the MAC value.",
      "ja": "タグ：このフィールドにはMAC値が含まれます。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that corresponds to the above text is:",
      "ja": "上記のテキストに対応するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Mac0 = [\n   Headers,\n   payload : bstr / nil,\n   tag : bstr,\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3. How to Compute and Verify a MAC",
      "section_title": true,
      "ja": "6.3. MACを計算して検証する方法"
    },
    {
      "indent": 3,
      "text": "In order to get a consistent encoding of the data to be authenticated, the MAC_structure is used to have a canonical form. The MAC_structure is a CBOR array. The fields of the MAC_structure in order are:",
      "ja": "認証されるデータの一貫したエンコーディングを取得するために、MAC_structureを使用して正規の形式にします。 MAC_structureはCBOR配列です。 MAC_structureのフィールドの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. A text string that identifies the structure that is being encoded. This string is \"MAC\" for the COSE_Mac structure. This string is \"MAC0\" for the COSE_Mac0 structure.",
      "ja": "1. エンコードされている構造を識別するテキスト文字列。この文字列は、COSE_Mac構造の「MAC」です。この文字列は、COSE_Mac0構造の「MAC0」です。"
    },
    {
      "indent": 3,
      "text": "2. The protected attributes from the COSE_MAC structure. If there are no protected attributes, a zero-length bstr is used.",
      "ja": "2. COSE_MAC構造の保護された属性。保護された属性がない場合は、長さがゼロのbstrが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. The protected attributes from the application encoded as a bstr type. If this field is not supplied, it defaults to a zero-length binary string. (See Section 4.3 for application guidance on constructing this field.)",
      "ja": "3. bstrタイプとしてエンコードされたアプリケーションからの保護された属性。このフィールドが指定されていない場合、デフォルトで長さがゼロのバイナリ文字列になります。 （このフィールドの作成に関するアプリケーションガイダンスについては、セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "4. The payload to be MACed encoded in a bstr type. The payload is placed here independent of how it is transported.",
      "ja": "4. bstrタイプでエンコードされたMACedのペイロード。ペイロードは、転送方法とは無関係にここに配置されます。"
    },
    {
      "indent": 3,
      "text": "The CDDL fragment that corresponds to the above text is:",
      "ja": "上記のテキストに対応するCDDLフラグメントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "MAC_structure = [\n     context : \"MAC\" / \"MAC0\",\n     protected : empty_or_serialized_map,\n     external_aad : bstr,\n     payload : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The steps to compute a MAC are:",
      "ja": "MACを計算する手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Create a MAC_structure and populate it with the appropriate fields.",
      "ja": "1. MAC_structureを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Create the value ToBeMaced by encoding the MAC_structure to a byte stream, using the encoding described in Section 14.",
      "ja": "2. セクション14で説明したエンコードを使用して、MAC_structureをバイトストリームにエンコードすることにより、値ToBeMacedを作成します。"
    },
    {
      "indent": 3,
      "text": "3. Call the MAC creation algorithm passing in K (the key to use), alg (the algorithm to MAC with), and ToBeMaced (the value to compute the MAC on).",
      "ja": "3. K（使用するキー）、alg（MACを使用するアルゴリズム）、およびToBeMaced（MACを計算する値）を渡してMAC作成アルゴリズムを呼び出します。"
    },
    {
      "indent": 3,
      "text": "4. Place the resulting MAC in the 'tag' field of the COSE_Mac or COSE_Mac0 structure.",
      "ja": "4. 結果のMACをCOSE_MacまたはCOSE_Mac0構造の「タグ」フィールドに配置します。"
    },
    {
      "indent": 3,
      "text": "5. Encrypt and encode the MAC key for each recipient of the message.",
      "ja": "5. メッセージの各受信者のMACキーを暗号化およびエンコードします。"
    },
    {
      "indent": 3,
      "text": "The steps to verify a MAC are:",
      "ja": "MACを確認する手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Create a MAC_structure object and populate it with the appropriate fields.",
      "ja": "1. MAC_structureオブジェクトを作成し、適切なフィールドを入力します。"
    },
    {
      "indent": 3,
      "text": "2. Create the value ToBeMaced by encoding the MAC_structure to a byte stream, using the encoding described in Section 14.",
      "ja": "2. セクション14で説明したエンコードを使用して、MAC_structureをバイトストリームにエンコードすることにより、値ToBeMacedを作成します。"
    },
    {
      "indent": 3,
      "text": "3. Obtain the cryptographic key from one of the recipients of the message.",
      "ja": "3. メッセージの受信者の1人から暗号化キーを取得します。"
    },
    {
      "indent": 3,
      "text": "4. Call the MAC creation algorithm passing in K (the key to use), alg (the algorithm to MAC with), and ToBeMaced (the value to compute the MAC on).",
      "ja": "4. K（使用するキー）、alg（MACを使用するアルゴリズム）、およびToBeMaced（MACを計算する値）を渡してMAC作成アルゴリズムを呼び出します。"
    },
    {
      "indent": 3,
      "text": "5. Compare the MAC value to the 'tag' field of the COSE_Mac or COSE_Mac0 structure.",
      "ja": "5. MAC値をCOSE_MacまたはCOSE_Mac0構造体の「タグ」フィールドと比較します。"
    },
    {
      "indent": 0,
      "text": "7. Key Objects",
      "section_title": true,
      "ja": "7. 主要なオブジェクト"
    },
    {
      "indent": 3,
      "text": "A COSE Key structure is built on a CBOR map object. The set of common parameters that can appear in a COSE Key can be found in the IANA \"COSE Key Common Parameters\" registry (Section 16.5). Additional parameters defined for specific key types can be found in the IANA \"COSE Key Type Parameters\" registry (Section 16.6).",
      "ja": "COSEキー構造は、CBORマップオブジェクトに基づいて構築されます。 COSEキーに表示できる共通パラメーターのセットは、IANAの「COSEキーの共通パラメーター」レジストリ（セクション16.5）にあります。特定のキータイプに対して定義されている追加のパラメータは、IANAの「COSEキータイプパラメータ」レジストリ（セクション16.6）にあります。"
    },
    {
      "indent": 3,
      "text": "A COSE Key Set uses a CBOR array object as its underlying type. The values of the array elements are COSE Keys. A COSE Key Set MUST have at least one element in the array. Examples of COSE Key Sets can be found in Appendix C.7.",
      "ja": "COSEキーセットは、基になる型としてCBOR配列オブジェクトを使用します。配列要素の値はCOSEキーです。 COSEキーセットは、配列に少なくとも1つの要素を持っている必要があります。 COSEキーセットの例は、付録C.7にあります。"
    },
    {
      "indent": 3,
      "text": "Each element in a COSE Key Set MUST be processed independently. If one element in a COSE Key Set is either malformed or uses a key that is not understood by an application, that key is ignored and the other keys are processed normally.",
      "ja": "COSEキーセットの各要素は、個別に処理する必要があります。 COSEキーセットの1つの要素の形式が正しくないか、アプリケーションが理解できないキーを使用している場合、そのキーは無視され、他のキーは通常どおり処理されます。"
    },
    {
      "indent": 3,
      "text": "The element \"kty\" is a required element in a COSE_Key map.",
      "ja": "要素「kty」は、COSE_Keyマップの必須要素です。"
    },
    {
      "indent": 3,
      "text": "The CDDL grammar describing COSE_Key and COSE_KeySet is:",
      "ja": "COSE_KeyおよびCOSE_KeySetを記述するCDDL文法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "COSE_Key = {\n    1 => tstr / int,          ; kty\n    ? 2 => bstr,              ; kid\n    ? 3 => tstr / int,        ; alg\n    ? 4 => [+ (tstr / int) ], ; key_ops\n    ? 5 => bstr,              ; Base IV\n    * label => values\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COSE_KeySet = [+COSE_Key]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1. COSE Key Common Parameters",
      "section_title": true,
      "ja": "7.1. COSEの主要な共通パラメーター"
    },
    {
      "indent": 3,
      "text": "This document defines a set of common parameters for a COSE Key object. Table 3 provides a summary of the parameters defined in this section. There are also parameters that are defined for specific key types. Key-type-specific parameters can be found in Section 13.",
      "ja": "このドキュメントでは、COSEキーオブジェクトの共通パラメーターのセットを定義します。表3は、このセクションで定義されているパラメーターの要約です。特定のキータイプに対して定義されているパラメータもあります。キータイプ固有のパラメータについては、セクション13を参照してください。"
    },
    {
      "indent": 3,
      "text": "+---------+-------+----------------+------------+-------------------+\n| Name    | Label | CBOR Type      | Value      | Description       |\n|         |       |                | Registry   |                   |\n+---------+-------+----------------+------------+-------------------+\n| kty     | 1     | tstr / int     | COSE Key   | Identification of |\n|         |       |                | Common     | the key type      |\n|         |       |                | Parameters |                   |\n|         |       |                |            |                   |\n| kid     | 2     | bstr           |            | Key               |\n|         |       |                |            | identification    |\n|         |       |                |            | value -- match to |\n|         |       |                |            | kid in message    |\n|         |       |                |            |                   |\n| alg     | 3     | tstr / int     | COSE       | Key usage         |\n|         |       |                | Algorithms | restriction to    |\n|         |       |                |            | this algorithm    |\n|         |       |                |            |                   |\n| key_ops | 4     | [+ (tstr/int)] |            | Restrict set of   |\n|         |       |                |            | permissible       |\n|         |       |                |            | operations        |\n|         |       |                |            |                   |\n| Base IV | 5     | bstr           |            | Base IV to be     |\n|         |       |                |            | xor-ed with       |\n|         |       |                |            | Partial IVs       |\n+---------+-------+----------------+------------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Table 3: Key Map Labels",
      "ja": "表3：キーマップラベル"
    },
    {
      "indent": 3,
      "text": "kty: This parameter is used to identify the family of keys for this structure and, thus, the set of key-type-specific parameters to be found. The set of values defined in this document can be found in Table 21. This parameter MUST be present in a key object. Implementations MUST verify that the key type is appropriate for the algorithm being processed. The key type MUST be included as part of the trust decision process.",
      "ja": "kty：このパラメーターは、この構造のキーのファミリーを識別するために使用されます。したがって、検索されるキータイプ固有のパラメーターのセットを識別します。このドキュメントで定義されている値のセットは、表21にあります。このパラメーターは、キーオブジェクトに存在する必要があります。実装は、キータイプが処理されるアルゴリズムに適切であることを確認する必要があります。鍵タイプは、信頼決定プロセスの一部として含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "alg: This parameter is used to restrict the algorithm that is used with the key. If this parameter is present in the key structure, the application MUST verify that this algorithm matches the algorithm for which the key is being used. If the algorithms do not match, then this key object MUST NOT be used to perform the cryptographic operation. Note that the same key can be in a different key structure with a different or no algorithm specified; however, this is considered to be a poor security practice.",
      "ja": "alg：このパラメーターは、キーで使用されるアルゴリズムを制限するために使用されます。このパラメーターがキー構造に存在する場合、アプリケーションは、このアルゴリズムがキーが使用されているアルゴリズムと一致することを確認する必要があります。アルゴリズムが一致しない場合は、このキーオブジェクトを使用して暗号化操作を実行してはなりません（MUST NOT）。同じ鍵が、異なるアルゴリズムが指定された、または指定されていない異なる鍵構造内にある可能性があることに注意してください。ただし、これは不十分なセキュリティ慣行と見なされます。"
    },
    {
      "indent": 3,
      "text": "kid: This parameter is used to give an identifier for a key. The identifier is not structured and can be anything from a user-provided string to a value computed on the public portion of the key. This field is intended for matching against a 'kid' parameter in a message in order to filter down the set of keys that need to be checked.",
      "ja": "kid：このパラメータは、キーの識別子を与えるために使用されます。識別子は構造化されておらず、ユーザー指定の文字列から、キーの公開部分で計算された値まで何でもかまいません。このフィールドは、チェックする必要のあるキーのセットをフィルタリングするために、メッセージの「子供」パラメータと照合することを目的としています。"
    },
    {
      "indent": 3,
      "text": "key_ops: This parameter is defined to restrict the set of operations that a key is to be used for. The value of the field is an array of values from Table 4. Algorithms define the values of key ops that are permitted to appear and are required for specific operations. The set of values matches that in [RFC7517] and [W3C.WebCrypto].",
      "ja": "key_ops：このパラメーターは、キーが使用される一連の操作を制限するために定義されます。フィールドの値は、表4の値の配列です。アルゴリズムは、表示が許可され、特定の操作に必要なキー操作の値を定義します。値のセットは、[RFC7517]および[W3C.WebCrypto]の値と一致します。"
    },
    {
      "indent": 3,
      "text": "Base IV: This parameter is defined to carry the base portion of an IV. It is designed to be used with the Partial IV header parameter defined in Section 3.1. This field provides the ability to associate a Partial IV with a key that is then modified on a per message basis with the Partial IV.",
      "ja": "ベースIV：このパラメーターは、IVのベース部分を伝送するために定義されます。これは、セクション3.1で定義されているPartial IVヘッダーパラメータと共に使用するように設計されています。このフィールドは、パーシャルIVをキーに関連付け、メッセージごとにパーシャルIVで変更されるキーを関連付ける機能を提供します。"
    },
    {
      "indent": 6,
      "text": "Extreme care needs to be taken when using a Base IV in an application. Many encryption algorithms lose security if the same IV is used twice.",
      "ja": "アプリケーションでBase IVを使用する場合は、細心の注意を払う必要があります。同じIVを2回使用すると、多くの暗号化アルゴリズムはセキュリティを失います。"
    },
    {
      "indent": 6,
      "text": "If different keys are derived for each sender, using the same Base IV with Partial IVs starting at zero is likely to ensure that the IV would not be used twice for a single key. If different keys are derived for each sender, starting at the same Base IV is likely to satisfy this condition. If the same key is used for multiple senders, then the application needs to provide for a method of dividing the IV space up between the senders. This could be done by providing a different base point to start from or a different Partial IV to start with and restricting the number of messages to be sent before rekeying.",
      "ja": "送信者ごとに異なるキーが生成される場合、ゼロから始まる部分IVで同じベースIVを使用すると、IVが1つのキーに対して2回使用されないことが保証されます。送信者ごとに異なるキーが生成される場合、同じBase IVから開始すると、この条件を満たす可能性があります。同じキーが複数の送信者に使用されている場合、アプリケーションはIVスペースを送信者間で分割する方法を提供する必要があります。これは、開始する別のベースポイントまたは開始する別のパーシャルIVを提供し、鍵の再生成の前に送信されるメッセージの数を制限することで実行できます。"
    },
    {
      "indent": 3,
      "text": "+---------+-------+-------------------------------------------------+\n| Name    | Value | Description                                     |\n+---------+-------+-------------------------------------------------+\n| sign    | 1     | The key is used to create signatures.  Requires |\n|         |       | private key fields.                             |\n| verify  | 2     | The key is used for verification of signatures. |\n| encrypt | 3     | The key is used for key transport encryption.   |\n| decrypt | 4     | The key is used for key transport decryption.   |\n|         |       | Requires private key fields.                    |\n| wrap    | 5     | The key is used for key wrap encryption.        |\n| key     |       |                                                 |\n| unwrap  | 6     | The key is used for key wrap decryption.        |\n| key     |       | Requires private key fields.                    |\n| derive  | 7     | The key is used for deriving keys.  Requires    |\n| key     |       | private key fields.                             |\n| derive  | 8     | The key is used for deriving bits not to be     |\n| bits    |       | used as a key.  Requires private key fields.    |\n| MAC     | 9     | The key is used for creating MACs.              |\n| create  |       |                                                 |\n| MAC     | 10    | The key is used for validating MACs.            |\n| verify  |       |                                                 |\n+---------+-------+-------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 4: Key Operation Values",
      "ja": "表4：主な操作値"
    },
    {
      "indent": 0,
      "text": "8. Signature Algorithms",
      "section_title": true,
      "ja": "8. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "There are two signature algorithm schemes. The first is signature with appendix. In this scheme, the message content is processed and a signature is produced; the signature is called the appendix. This is the scheme used by algorithms such as ECDSA and the RSA Probabilistic Signature Scheme (RSASSA-PSS). (In fact, the SSA in RSASSA-PSS stands for Signature Scheme with Appendix.)",
      "ja": "2つの署名アルゴリズムスキームがあります。 1つ目は、付録付きの署名です。このスキームでは、メッセージのコンテンツが処理され、署名が生成されます。署名は付録と呼ばれます。これは、ECDSAやRSA確率的署名方式（RSASSA-PSS）などのアルゴリズムで使用される方式です。 （実際、RSASSA-PSSのSSAは、付録付きの署名スキームを表しています。）"
    },
    {
      "indent": 3,
      "text": "The signature functions for this scheme are:",
      "ja": "このスキームの署名関数は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "signature = Sign(message content, key)",
      "ja": "signature = Sign（メッセージの内容、キー）"
    },
    {
      "indent": 6,
      "text": "valid = Verification(message content, key, signature)",
      "ja": "有効=検証（メッセージの内容、キー、署名）"
    },
    {
      "indent": 0,
      "text": " The second scheme is signature with message recovery (an example of such an algorithm is [PVSig]). In this scheme, the message content is processed, but part of it is included in the signature. Moving bytes of the message content into the signature allows for smaller signatures; the signature size is still potentially large, but the message content has shrunk. This has implications for systems implementing these algorithms and for applications that use them. The first is that the message content is not fully available until after a signature has been validated. Until that point, the part of the message contained inside of the signature is unrecoverable. The second is that the security analysis of the strength of the signature is very much based on the structure of the message content. Messages that are highly predictable require additional randomness to be supplied as part of the signature process. In the worst case, it becomes the same as doing a signature with appendix. Finally, in the event that multiple signatures are applied to a message, all of the signature algorithms are going to be required to consume the same number of bytes of message content. This means that the mixing of the different schemes in a single message is not supported, and if a recovery signature scheme is used, then the same amount of content needs to be consumed by all of the signatures.",
      "ja": "2番目の方式は、メッセージ回復を伴う署名です（そのようなアルゴリズムの例は[PVSig]です）。このスキームでは、メッセージのコンテンツが処理されますが、その一部は署名に含まれています。メッセージコンテンツのバイトを署名に移動すると、署名を小さくすることができます。署名のサイズは依然として大きい可能性がありますが、メッセージの内容は縮小しています。これは、これらのアルゴリズムを実装するシステムと、それらを使用するアプリケーションに影響を与えます。 1つ目は、署名が検証されるまでメッセージの内容を完全に利用できないことです。その時点まで、署名の内部に含まれるメッセージの一部は回復できません。 2つ目は、署名の強度のセキュリティ分析は、メッセージコンテンツの構造に非常に基づいていることです。高度に予測可能なメッセージには、署名プロセスの一部として追加のランダム性を提供する必要があります。最悪の場合、付録で署名するのと同じになります。最後に、複数の署名がメッセージに適用される場合、すべての署名アルゴリズムが同じバイト数のメッセージコンテンツを消費する必要があります。これは、単一のメッセージでの異なるスキームの混合はサポートされておらず、回復署名スキームが使用される場合、同じ量のコンテンツがすべての署名によって消費される必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "The signature functions for this scheme are:",
      "ja": "このスキームの署名関数は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "signature, message sent = Sign(message content, key)",
      "ja": "署名、送信されたメッセージ= Sign（メッセージの内容、キー）"
    },
    {
      "indent": 4,
      "text": "valid, message content = Verification(message sent, key, signature)",
      "ja": "有効、メッセージの内容=検証（送信されたメッセージ、キー、署名）"
    },
    {
      "indent": 3,
      "text": "Signature algorithms are used with the COSE_Signature and COSE_Sign1 structures. At this time, only signatures with appendixes are defined for use with COSE; however, considerable interest has been expressed in using a signature with message recovery algorithm due to the effective size reduction that is possible. Implementations will need to keep this in mind for later possible integration.",
      "ja": "署名アルゴリズムは、COSE_SignatureおよびCOSE_Sign1構造で使用されます。現時点では、付録を含むシグネチャのみがCOSEで使用するために定義されています。ただし、有効なサイズ削減が可能なため、メッセージ回復アルゴリズムで署名を使用することにかなりの関心が寄せられています。実装では、後で可能な統合のためにこれを覚えておく必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1. ECDSA",
      "section_title": true,
      "ja": "8.1. ECDSA"
    },
    {
      "indent": 3,
      "text": "ECDSA [DSS] defines a signature algorithm using ECC. Implementations SHOULD use a deterministic version of ECDSA such as the one defined in [RFC6979]. The use of a deterministic signature algorithm allows for systems to avoid relying on random number generators in order to avoid generating the same value of 'k' (the per-message random value). Biased generation of the value 'k' can be attacked, and collisions of this value leads to leaked keys. It additionally allows for doing deterministic tests for the signature algorithm. The use of deterministic ECDSA does not lessen the need to have good random number generation when creating the private key.",
      "ja": "ECDSA [DSS]は、ECCを使用して署名アルゴリズムを定義します。実装では、[RFC6979]で定義されているようなECDSAの確定的バージョンを使用する必要があります（SHOULD）。確定的署名アルゴリズムを使用すると、同じ値の「k」（メッセージごとのランダム値）の生成を回避するために、システムが乱数ジェネレーターに依存することを回避できます。バイアスされた値「k」の生成は攻撃される可能性があり、この値の衝突はリークされたキーにつながります。さらに、署名アルゴリズムの確定的テストを実行できます。確定的ECDSAを使用しても、秘密鍵を作成するときに乱数を適切に生成する必要性が減ることはありません。"
    },
    {
      "indent": 3,
      "text": "The ECDSA signature algorithm is parameterized with a hash function (h). In the event that the length of the hash function output is greater than the group of the key, the leftmost bytes of the hash output are used.",
      "ja": "ECDSA署名アルゴリズムは、ハッシュ関数（h）でパラメーター化されます。ハッシュ関数の出力の長さがキーのグループよりも長い場合、ハッシュ出力の左端のバイトが使用されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 5.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表5にあります。"
    },
    {
      "indent": 14,
      "text": "+-------+-------+---------+------------------+\n| Name  | Value | Hash    | Description      |\n+-------+-------+---------+------------------+\n| ES256 | -7    | SHA-256 | ECDSA w/ SHA-256 |\n| ES384 | -35   | SHA-384 | ECDSA w/ SHA-384 |\n| ES512 | -36   | SHA-512 | ECDSA w/ SHA-512 |\n+-------+-------+---------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 5: ECDSA Algorithm Values",
      "ja": "表5：ECDSAアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "This document defines ECDSA to work only with the curves P-256, P-384, and P-521. This document requires that the curves be encoded using the 'EC2' (2 coordinate elliptic curve) key type. Implementations need to check that the key type and curve are correct when creating and verifying a signature. Other documents can define it to work with other curves and points in the future.",
      "ja": "このドキュメントでは、ECDSAが曲線P-256、P-384、およびP-521でのみ機能するように定義しています。このドキュメントでは、「EC2」（2座標楕円曲線）キータイプを使用して曲線をエンコードする必要があります。実装では、署名を作成および検証するときに、キーのタイプと曲線が正しいことを確認する必要があります。他のドキュメントでは、将来的に他の曲線や点で機能するように定義できます。"
    },
    {
      "indent": 3,
      "text": "In order to promote interoperability, it is suggested that SHA-256 be used only with curve P-256, SHA-384 be used only with curve P-384, and SHA-512 be used with curve P-521. This is aligned with the recommendation in Section 4 of [RFC5480].",
      "ja": "相互運用性を促進するために、SHA-256は曲線P-256でのみ使用し、SHA-384は曲線P-384でのみ使用し、SHA-512は曲線P-521で使用することをお勧めします。これは、[RFC5480]のセクション4の推奨事項と一致しています。"
    },
    {
      "indent": 3,
      "text": "The signature algorithm results in a pair of integers (R, S). These integers will be the same length as the length of the key used for the signature process. The signature is encoded by converting the integers into byte strings of the same length as the key size. The length is rounded up to the nearest byte and is left padded with zero bits to get to the correct length. The two integers are then concatenated together to form a byte string that is the resulting signature.",
      "ja": "署名アルゴリズムにより、整数のペア（R、S）が生成されます。これらの整数は、署名プロセスに使用されるキーの長さと同じ長さになります。署名は、整数をキーサイズと同じ長さのバイト文字列に変換することによってエンコードされます。長さは最も近いバイトに切り上げられ、正しい長さになるようにゼロビットが埋め込まれます。次に、2つの整数を連結して、結果の署名であるバイト文字列を形成します。"
    },
    {
      "indent": 3,
      "text": "Using the function defined in [RFC8017], the signature is:\nSignature = I2OSP(R, n) | I2OSP(S, n)\nwhere n = ceiling(key_length / 8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'EC2'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「EC2」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the ECDSA signature algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されているECDSA署名アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'sign' when creating an ECDSA signature.",
      "ja": "o 「key_ops」フィールドが存在する場合、ECDSA署名を作成するときに「sign」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'verify' when verifying an ECDSA signature.",
      "ja": "o 「key_ops」フィールドが存在する場合、ECDSA署名を検証するときに「verify」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Security Considerations",
      "section_title": true,
      "ja": "8.1.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security strength of the signature is no greater than the minimum of the security strength associated with the bit length of the key and the security strength of the hash function.",
      "ja": "署名のセキュリティ強度は、キーのビット長に関連するセキュリティ強度とハッシュ関数のセキュリティ強度の最小値以下です。"
    },
    {
      "indent": 3,
      "text": "Note: Use of this technique is a good idea even when good random number generation exists. Doing so both reduces the possibility of having the same value of 'k' in two signature operations and allows for reproducible signature values, which helps testing.",
      "ja": "注：この手法は、適切な乱数生成が存在する場合でも使用することをお勧めします。そうすることで、2つの署名操作で「k」の値が同じになる可能性が低くなり、再現可能な署名値が可能になり、テストに役立ちます。"
    },
    {
      "indent": 3,
      "text": "There are two substitution attacks that can theoretically be mounted against the ECDSA signature algorithm.",
      "ja": "ECDSA署名アルゴリズムに対して理論的に実装できる2つの置換攻撃があります。"
    },
    {
      "indent": 3,
      "text": "o Changing the curve used to validate the signature: If one changes the curve used to validate the signature, then potentially one could have two messages with the same signature, each computed under a different curve. The only requirement on the new curve is that its order be the same as the old one and it be acceptable to the client. An example would be to change from using the curve secp256r1 (aka P-256) to using secp256k1. (Both are 256-bit curves.) We currently do not have any way to deal with this version of the attack except to restrict the overall set of curves that can be used.",
      "ja": "o 署名の検証に使用される曲線の変更：署名の検証に使用される曲線を変更すると、同じ署名を持つ2つのメッセージがそれぞれ異なる曲線で計算される可能性があります。新しい曲線の唯一の要件は、その順序が古い曲線と同じであり、クライアントに受け入れられることです。例として、曲線secp256r1（別名P-256）の使用からsecp256k1の使用に変更します。 （どちらも256ビットの曲線です。）現在、使用できる曲線の全体的なセットを制限することを除いて、このバージョンの攻撃に対処する方法はありません。"
    },
    {
      "indent": 3,
      "text": "o Change the hash function used to validate the signature: If one either has two different hash functions of the same length or can truncate a hash function down, then one could potentially find collisions between the hash functions rather than within a single hash function (for example, truncating SHA-512 to 256 bits might collide with a SHA-256 bit hash value). As the hash algorithm is part of the signature algorithm identifier, this attack is mitigated by including a signature algorithm identifier in the protected header.",
      "ja": "o 署名の検証に使用するハッシュ関数を変更します。同じ長さの2つの異なるハッシュ関数があるか、ハッシュ関数を切り捨てることができる場合、単一のハッシュ関数内ではなく、ハッシュ関数間の衝突を見つける可能性があります（たとえば、 、SHA-512を256ビットに切り捨てると、SHA-256ビットのハッシュ値と衝突する可能性があります。ハッシュアルゴリズムは署名アルゴリズム識別子の一部であるため、保護されたヘッダーに署名アルゴリズム識別子を含めることにより、この攻撃は軽減されます。"
    },
    {
      "indent": 0,
      "text": "8.2. Edwards-Curve Digital Signature Algorithms (EdDSAs)",
      "section_title": true,
      "ja": "8.2. エドワーズカーブデジタル署名アルゴリズム（EdDSA）"
    },
    {
      "indent": 0,
      "text": " [RFC8032] describes the elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA). In that document, the signature algorithm is instantiated using parameters for edwards25519 and edwards448 curves. The document additionally describes two variants of the EdDSA algorithm: Pure EdDSA, where no hash function is applied to the content before signing, and HashEdDSA, where a hash function is applied to the content before signing and the result of that hash function is signed. For EdDSA, the content to be signed (either the message or the pre-hash value) is processed twice inside of the signature algorithm. For use with COSE, only the pure EdDSA version is used. This is because it is not expected that extremely large contents are going to be needed and, based on the arrangement of the message structure, the entire message is going to need to be held in memory in order to create or verify a signature. This means that there does not appear to be a need to be able to do block updates of the hash, followed by eliminating the message from memory. Applications can provide the same features by defining the content of the message as a hash value and transporting the COSE object (with the hash value) and the content as separate items.",
      "ja": "[RFC8032]は、楕円曲線署名スキームEdwards-curve Digital Signature Algorithm（EdDSA）について説明しています。そのドキュメントでは、署名アルゴリズムはedwards25519およびedwards448曲線のパラメーターを使用してインスタンス化されています。このドキュメントではさらに、EdDSAアルゴリズムの2つのバリアントについて説明します。署名前にハッシュ関数がコンテンツに適用されないPure EdDSAと、署名前にコンテンツにハッシュ関数が適用され、そのハッシュ関数の結果が署名されるHashEdDSAです。 EdDSAの場合、署名されるコンテンツ（メッセージまたはプリハッシュ値のいずれか）は、署名アルゴリズム内で2回処理されます。 COSEで使用する場合、純粋なEdDSAバージョンのみが使用されます。これは、極端に大きなコンテンツが必要になることは想定されておらず、メッセージ構造の配置に基づいて、署名を作成または検証するためにメッセージ全体をメモリに保持する必要があるためです。これは、ハッシュのブロック更新を実行する必要があるように見えないので、メモリからメッセージを削除することを意味します。アプリケーションは、メッセージのコンテンツをハッシュ値として定義し、COSEオブジェクト（ハッシュ値を含む）とコンテンツを別個のアイテムとして転送することにより、同じ機能を提供できます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 6. A single signature algorithm is defined, which can be used for multiple curves.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表6にあります。複数の曲線に使用できる単一の署名アルゴリズムが定義されています。"
    },
    {
      "indent": 22,
      "text": "+-------+-------+-------------+\n| Name  | Value | Description |\n+-------+-------+-------------+\n| EdDSA | -8    | EdDSA       |\n+-------+-------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 6: EdDSA Algorithm Values",
      "ja": "表6：EdDSAアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "[RFC8032] describes the method of encoding the signature value.",
      "ja": "[RFC8032]は、署名値をエンコードする方法を説明しています。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'OKP' (Octet Key Pair).",
      "ja": "o 「kty」フィールドが存在しなければならず、「OKP」（オクテットキーペア）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The 'crv' field MUST be present, and it MUST be a curve defined for this signature algorithm.",
      "ja": "o 'crv'フィールドが存在しなければならず、この署名アルゴリズムに対して定義された曲線でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match 'EdDSA'.",
      "ja": "o 「alg」フィールドが存在する場合、「EdDSA」と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'sign' when creating an EdDSA signature.",
      "ja": "o 「key_ops」フィールドが存在する場合、EdDSA署名を作成するときに「sign」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'verify' when verifying an EdDSA signature.",
      "ja": "o 「key_ops」フィールドが存在する場合、EdDSA署名を検証するときに「verify」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Security Considerations",
      "section_title": true,
      "ja": "8.2.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "How public values are computed is not the same when looking at EdDSA and Elliptic Curve Diffie-Hellman (ECDH); for this reason, they should not be used with the other algorithm.",
      "ja": "EdDSAと楕円曲線Diffie-Hellman（ECDH）を見る場合、パブリック値の計算方法は同じではありません。このため、他のアルゴリズムでは使用しないでください。"
    },
    {
      "indent": 3,
      "text": "If batch signature verification is performed, a well-seeded cryptographic random number generator is REQUIRED. Signing and non-batch signature verification are deterministic operations and do not need random numbers of any kind.",
      "ja": "バッチ署名検証を実行する場合は、適切にシードされた暗号化乱数ジェネレーターが必要です。署名と非バッチ署名の検証は確定的な操作であり、いかなる種類の乱数も必要としません。"
    },
    {
      "indent": 0,
      "text": "9. Message Authentication Code (MAC) Algorithms",
      "section_title": true,
      "ja": "9. メッセージ認証コード（MAC）アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Message Authentication Codes (MACs) provide data authentication and integrity protection. They provide either no or very limited data origination. A MAC, for example, can be used to prove the identity of the sender to a third party.",
      "ja": "メッセージ認証コード（MAC）は、データ認証と整合性保護を提供します。データの発信元がまったくないか、非常に限られています。たとえば、MACは、送信者の身元を第三者に証明するために使用できます。"
    },
    {
      "indent": 3,
      "text": "MACs use the same scheme as signature with appendix algorithms. The message content is processed and an authentication code is produced. The authentication code is frequently called a tag.",
      "ja": "MACは、付録アルゴリズムでの署名と同じスキームを使用します。メッセージのコンテンツが処理され、認証コードが生成されます。認証コードはしばしばタグと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The MAC functions are:",
      "ja": "MAC関数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "tag = MAC_Create(message content, key)",
      "ja": "タグ= MAC_Create（メッセージ内容、キー）"
    },
    {
      "indent": 3,
      "text": "valid = MAC_Verify(message content, key, tag)",
      "ja": "有効= MAC_Verify（メッセージの内容、キー、タグ）"
    },
    {
      "indent": 3,
      "text": "MAC algorithms can be based on either a block cipher algorithm (i.e., AES-MAC) or a hash algorithm (i.e., a Hash-based Message Authentication Code (HMAC)). This document defines a MAC algorithm using each of these constructions.",
      "ja": "MACアルゴリズムは、ブロック暗号化アルゴリズム（AES-MACなど）またはハッシュアルゴリズム（ハッシュベースのメッセージ認証コード（HMAC））に基づいています。このドキュメントでは、これらの各構成を使用してMACアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "MAC algorithms are used in the COSE_Mac and COSE_Mac0 structures.",
      "ja": "MACアルゴリズムは、COSE_MacおよびCOSE_Mac0構造で使用されます。"
    },
    {
      "indent": 0,
      "text": "9.1. Hash-Based Message Authentication Codes (HMACs)",
      "section_title": true,
      "ja": "9.1. ハッシュベースのメッセージ認証コード（HMAC）"
    },
    {
      "indent": 3,
      "text": "HMAC [RFC2104] [RFC4231] was designed to deal with length extension attacks. The algorithm was also designed to allow for new hash algorithms to be directly plugged in without changes to the hash function. The HMAC design process has been shown as solid since, while the security of hash algorithms such as MD5 has decreased over time; the security of HMAC combined with MD5 has not yet been shown to be compromised [RFC6151].",
      "ja": "HMAC [RFC2104] [RFC4231]は、長さ拡張攻撃に対処するように設計されました。このアルゴリズムは、ハッシュ関数を変更せずに、新しいハッシュアルゴリズムを直接プラグインできるようにも設計されています。それ以来、HMAC設計プロセスは堅実であることが示されてきましたが、MD5などのハッシュアルゴリズムのセキュリティは、時間とともに低下しました。 MD5と組み合わせたHMACのセキュリティは、まだ侵害されていないことが示されています[RFC6151]。"
    },
    {
      "indent": 3,
      "text": "The HMAC algorithm is parameterized by an inner and outer padding, a hash function (h), and an authentication tag value length. For this specification, the inner and outer padding are fixed to the values set in [RFC2104]. The length of the authentication tag corresponds to the difficulty of producing a forgery. For use in constrained environments, we define a set of HMAC algorithms that are truncated.",
      "ja": "HMACアルゴリズムは、内側と外側のパディング、ハッシュ関数（h）、および認証タグ値の長さによってパラメーター化されます。この仕様では、内側と外側のパディングは[RFC2104]で設定された値に固定されています。認証タグの長さは、偽造の作成の難しさに対応しています。制約のある環境で使用するために、切り詰められたHMACアルゴリズムのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "There are currently no known issues with truncation; however, the security strength of the message tag is correspondingly reduced in strength. When truncating, the leftmost tag length bits are kept and transmitted.",
      "ja": "現在、切り捨てに関する既知の問題はありません。ただし、メッセージタグのセキュリティ強度は、それに応じて強度が低下します。切り捨ての際、左端のタグ長ビットが保持されて送信されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 7.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表7にあります。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+---------+----------+--------------------------+\n| Name      | Value | Hash    | Tag      | Description              |\n|           |       |         | Length   |                          |\n+-----------+-------+---------+----------+--------------------------+\n| HMAC      | 4     | SHA-256 | 64       | HMAC w/ SHA-256          |\n| 256/64    |       |         |          | truncated to 64 bits     |\n| HMAC      | 5     | SHA-256 | 256      | HMAC w/ SHA-256          |\n| 256/256   |       |         |          |                          |\n| HMAC      | 6     | SHA-384 | 384      | HMAC w/ SHA-384          |\n| 384/384   |       |         |          |                          |\n| HMAC      | 7     | SHA-512 | 512      | HMAC w/ SHA-512          |\n| 512/512   |       |         |          |                          |\n+-----------+-------+---------+----------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 7: HMAC Algorithm Values",
      "ja": "表7：HMACアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "Some recipient algorithms carry the key while others derive a key from secret data. For those algorithms that carry the key (such as AES Key Wrap), the size of the HMAC key SHOULD be the same size as the underlying hash function. For those algorithms that derive the key (such as ECDH), the derived key MUST be the same size as the underlying hash function.",
      "ja": "一部の受信者アルゴリズムはキーを持ち、他のアルゴリズムは秘密データからキーを導出します。鍵を運ぶアルゴリズム（AES鍵ラップなど）の場合、HMAC鍵のサイズは、基礎となるハッシュ関数と同じサイズにする必要があります（SHOULD）。キー（ECDHなど）を導出するアルゴリズムの場合、派生キーは、基になるハッシュ関数と同じサイズでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the HMAC algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されているHMACアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'MAC create' when creating an HMAC authentication tag.",
      "ja": "o 「key_ops」フィールドが存在する場合、HMAC認証タグを作成するときに「MAC create」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'MAC verify' when verifying an HMAC authentication tag.",
      "ja": "o 「key_ops」フィールドが存在する場合、HMAC認証タグを検証するときに「MAC検証」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "MAC値を作成および検証する実装は、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.1.1. Security Considerations",
      "section_title": true,
      "ja": "9.1.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "HMAC has proved to be resistant to attack even when used with weakened hash algorithms. The current best known attack is to brute force the key. This means that key size is going to be directly related to the security of an HMAC operation.",
      "ja": "HMACは、弱められたハッシュアルゴリズムで使用された場合でも、攻撃に対して耐性があることが証明されています。現在最もよく知られている攻撃は、ブルートフォースキーです。これは、キーサイズがHMAC操作のセキュリティに直接関係することを意味します。"
    },
    {
      "indent": 0,
      "text": "9.2. AES Message Authentication Code (AES-CBC-MAC)",
      "section_title": true,
      "ja": "9.2. AESメッセージ認証コード（AES-CBC-MAC）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is defined in [MAC]. (Note that this is not the same algorithm as AES Cipher-Based Message Authentication Code (AES-CMAC) [RFC4493].)",
      "ja": "AES-CBC-MACは[MAC]で定義されています。 （これはAES暗号ベースのメッセージ認証コード（AES-CMAC）[RFC4493]と同じアルゴリズムではないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is parameterized by the key length, the authentication tag length, and the IV used. For all of these algorithms, the IV is fixed to all zeros. We provide an array of algorithms for various key lengths and tag lengths. The algorithms defined in this document are found in Table 8.",
      "ja": "AES-CBC-MACは、キーの長さ、認証タグの長さ、および使用されるIVによってパラメーター化されます。これらのすべてのアルゴリズムで、IVはすべてゼロに固定されます。さまざまなキーの長さとタグの長さのアルゴリズムの配列を提供します。このドキュメントで定義されているアルゴリズムを表8に示します。"
    },
    {
      "indent": 3,
      "text": "+-------------+-------+----------+----------+-----------------------+\n| Name        | Value | Key      | Tag      | Description           |\n|             |       | Length   | Length   |                       |\n+-------------+-------+----------+----------+-----------------------+\n| AES-MAC     | 14    | 128      | 64       | AES-MAC 128-bit key,  |\n| 128/64      |       |          |          | 64-bit tag            |\n| AES-MAC     | 15    | 256      | 64       | AES-MAC 256-bit key,  |\n| 256/64      |       |          |          | 64-bit tag            |\n| AES-MAC     | 25    | 128      | 128      | AES-MAC 128-bit key,  |\n| 128/128     |       |          |          | 128-bit tag           |\n| AES-MAC     | 26    | 256      | 128      | AES-MAC 256-bit key,  |\n| 256/128     |       |          |          | 128-bit tag           |\n+-------------+-------+----------+----------+-----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 8: AES-MAC Algorithm Values",
      "ja": "表8：AES-MACアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained either from a key structure or from a recipient structure. Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。 MAC値を作成および検証する実装は、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the AES-MAC algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されているAES-MACアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'MAC create' when creating an AES-MAC authentication tag.",
      "ja": "o 「key_ops」フィールドが存在する場合、AES-MAC認証タグを作成するときに「MAC作成」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'MAC verify' when verifying an AES-MAC authentication tag.",
      "ja": "o 「key_ops」フィールドが存在する場合、AES-MAC認証タグを検証するときに「MAC検証」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Security Considerations",
      "section_title": true,
      "ja": "9.2.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A number of attacks exist against Cipher Block Chaining Message Authentication Code (CBC-MAC) that need to be considered.",
      "ja": "考慮が必要な暗号ブロック連鎖メッセージ認証コード（CBC-MAC）に対する攻撃がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "o A single key must only be used for messages of a fixed and known length. If this is not the case, an attacker will be able to generate a message with a valid tag given two message and tag pairs. This can be addressed by using different keys for messages of different lengths. The current structure mitigates this problem, as a specific encoding structure that includes lengths is built and signed. (CMAC also addresses this issue.)",
      "ja": "o 単一のキーは、固定された既知の長さのメッセージにのみ使用する必要があります。これが当てはまらない場合、攻撃者は2つのメッセージとタグのペアを指定して、有効なタグを持つメッセージを生成することができます。これは、異なる長さのメッセージに異なるキーを使用することで対処できます。長さを含む特定のエンコーディング構造が構築および署名されるため、現在の構造はこの問題を軽減します。 （CMACもこの問題に対処しています。）"
    },
    {
      "indent": 3,
      "text": "o Cipher Block Chaining (CBC) mode, if the same key is used for both encryption and authentication operations, an attacker can produce messages with a valid authentication code.",
      "ja": "o 暗号ブロックチェーン（CBC）モード。暗号化と認証の両方の操作に同じキーが使用されている場合、攻撃者は有効な認証コードを含むメッセージを生成できます。"
    },
    {
      "indent": 3,
      "text": "o If the IV can be modified, then messages can be forged. This is addressed by fixing the IV to all zeros.",
      "ja": "o IVを変更できる場合、メッセージが偽造される可能性があります。これは、IVをすべてゼロに固定することで対処されます。"
    },
    {
      "indent": 0,
      "text": "10. Content Encryption Algorithms",
      "section_title": true,
      "ja": "10. コンテンツ暗号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Content encryption algorithms provide data confidentiality for potentially large blocks of data using a symmetric key. They provide integrity on the data that was encrypted; however, they provide either no or very limited data origination. (One cannot, for example, be used to prove the identity of the sender to a third party.) The ability to provide data origination is linked to how the CEK is obtained.",
      "ja": "コンテンツ暗号化アルゴリズムは、対称鍵を使用して、潜在的に大きなデータブロックにデータの機密性を提供します。暗号化されたデータの整合性を提供します。ただし、提供されるデータはまったくないか、非常に限られています。 （たとえば、第三者に送信者の身元を証明するために使用することはできません。）データの発信元を提供する機能は、CEKの取得方法に関連しています。"
    },
    {
      "indent": 3,
      "text": "COSE restricts the set of legal content encryption algorithms to those that support authentication both of the content and additional data. The encryption process will generate some type of authentication value, but that value may be either explicit or implicit in terms of the algorithm definition. For simplicity's sake, the authentication code will normally be defined as being appended to the ciphertext stream. The encryption functions are:",
      "ja": "COSEは、合法的なコンテンツ暗号化アルゴリズムのセットを、コンテンツと追加データの両方の認証をサポートするものに制限します。暗号化プロセスは、あるタイプの認証値を生成しますが、その値は、アルゴリズム定義の観点から明示的または暗黙的のいずれかです。簡単にするために、認証コードは通常、暗号文ストリームに付加されるものとして定義されます。暗号化関数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ciphertext = Encrypt(message content, key, additional data)",
      "ja": "ciphertext = Encrypt（メッセージコンテンツ、キー、追加データ）"
    },
    {
      "indent": 0,
      "text": " valid, message content = Decrypt(cipher text, key, additional data) Most AEAD algorithms are logically defined as returning the message content only if the decryption is valid. Many but not all",
      "ja": "有効、メッセージの内容= Decrypt（暗号文、キー、追加データ）ほとんどのAEADアルゴリズムは、復号が有効な場合にのみメッセージの内容を返すように論理的に定義されています。多くではなくすべて"
    },
    {
      "indent": 3,
      "text": "implementations will follow this convention. The message content MUST NOT be used if the decryption does not validate.",
      "ja": "実装はこの規則に従います。復号化が検証されない場合、メッセージコンテンツを使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "These algorithms are used in COSE_Encrypt and COSE_Encrypt0.",
      "ja": "これらのアルゴリズムは、COSE_EncryptおよびCOSE_Encrypt0で使用されます。"
    },
    {
      "indent": 0,
      "text": "10.1. AES GCM",
      "section_title": true,
      "ja": "10.1. AES GCM"
    },
    {
      "indent": 3,
      "text": "The Galois/Counter Mode (GCM) mode is a generic authenticated encryption block cipher mode defined in [AES-GCM]. The GCM mode is combined with the AES block encryption algorithm to define an AEAD cipher.",
      "ja": "ガロア/カウンターモード（GCM）モードは、[AES-GCM]で定義されている一般的な認証済み暗号化ブロック暗号モードです。 GCMモードをAESブロック暗号化アルゴリズムと組み合わせて、AEAD暗号を定義します。"
    },
    {
      "indent": 3,
      "text": "The GCM mode is parameterized by the size of the authentication tag and the size of the nonce. This document fixes the size of the nonce at 96 bits. The size of the authentication tag is limited to a small set of values. For this document however, the size of the authentication tag is fixed at 128 bits.",
      "ja": "GCMモードは、認証タグのサイズとナンスのサイズによってパラメーター化されます。このドキュメントでは、nonceのサイズを96ビットに修正しています。認証タグのサイズは、小さな値のセットに制限されています。ただし、このドキュメントでは、認証タグのサイズは128ビットに固定されています。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document are in Table 9.",
      "ja": "このドキュメントで定義されているアルゴリズムのセットを表9に示します。"
    },
    {
      "indent": 6,
      "text": "+---------+-------+------------------------------------------+\n| Name    | Value | Description                              |\n+---------+-------+------------------------------------------+\n| A128GCM | 1     | AES-GCM mode w/ 128-bit key, 128-bit tag |\n| A192GCM | 2     | AES-GCM mode w/ 192-bit key, 128-bit tag |\n| A256GCM | 3     | AES-GCM mode w/ 256-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 9: Algorithm Value for AES-GCM",
      "ja": "表9：AES-GCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained either from a key structure or from a recipient structure. Implementations encrypting and decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化と復号化の実装では、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the AES-GCM algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されているAES-GCMアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'encrypt' or 'wrap key' when encrypting.",
      "ja": "o 'key_ops'フィールドが存在する場合は、暗号化時に 'encrypt'または 'wrap key'を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'decrypt' or 'unwrap key' when decrypting.",
      "ja": "o 「key_ops」フィールドが存在する場合、復号化するときに「decrypt」または「unwrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1.1. Security Considerations",
      "section_title": true,
      "ja": "10.1.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-GCM, the following restrictions MUST be enforced:",
      "ja": "AES-GCMを使用する場合は、次の制限を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The key and nonce pair MUST be unique for every message encrypted.",
      "ja": "o キーとノンスのペアは、暗号化されたすべてのメッセージに対して一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "o The total amount of data encrypted for a single key MUST NOT exceed 2^39 - 256 bits. An explicit check is required only in environments where it is expected that it might be exceeded.",
      "ja": "o 単一のキーに対して暗号化されたデータの総量は、2 ^ 39-256ビットを超えてはなりません。明示的なチェックは、超過することが予想される環境でのみ必要です。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to supporting smaller tag values; the constrained community would desire tag sizes in the 64-bit range. Doing so drastically changes both the maximum messages size (generally not an issue) and the number of times that a key can be used. Given that Counter with CBC-MAC (CCM) is the usual mode for constrained environments, restricted modes are not supported.",
      "ja": "より小さいタグ値をサポートすることを検討しました。制約のあるコミュニティは、64ビットの範囲のタグサイズを望んでいます。これにより、メッセージの最大サイズ（通常は問題ではありません）とキーを使用できる回数の両方が大幅に変更されます。 Counter with CBC-MAC（CCM）は制約された環境の通常のモードであるため、制限付きモードはサポートされていません。"
    },
    {
      "indent": 0,
      "text": "10.2. AES CCM",
      "section_title": true,
      "ja": "10.2. AES CCM"
    },
    {
      "indent": 3,
      "text": "CCM is a generic authentication encryption block cipher mode defined in [RFC3610]. The CCM mode is combined with the AES block encryption algorithm to define a commonly used content encryption algorithm used in constrained devices.",
      "ja": "CCMは、[RFC3610]で定義されている一般的な認証暗号化ブロック暗号モードです。 CCMモードは、AESブロック暗号化アルゴリズムと組み合わせて、制約のあるデバイスで使用される一般的に使用されるコンテンツ暗号化アルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "The CCM mode has two parameter choices. The first choice is M, the size of the authentication field. The choice of the value for M involves a trade-off between message growth (from the tag) and the probability that an attacker can undetectably modify a message. The second choice is L, the size of the length field. This value requires a trade-off between the maximum message size and the size of the Nonce.",
      "ja": "CCMモードには2つのパラメーターの選択肢があります。最初の選択は、認証フィールドのサイズであるMです。 Mの値の選択には、（タグからの）メッセージの増加と、攻撃者がメッセージを検出できないほど変更できる確率との間のトレードオフが含まれます。 2番目の選択肢は、長さフィールドのサイズであるLです。この値には、最大メッセージサイズとNonceのサイズの間のトレードオフが必要です。"
    },
    {
      "indent": 3,
      "text": "It is unfortunate that the specification for CCM specified L and M as a count of bytes rather than a count of bits. This leads to possible misunderstandings where AES-CCM-8 is frequently used to refer to a version of CCM mode where the size of the authentication is 64 bits and not 8 bits. These values have traditionally been specified as bit counts rather than byte counts. This document will follow the convention of using bit counts so that it is easier to compare the different algorithms presented in this document.",
      "ja": "残念ながら、CCMの仕様では、LとMをビット数ではなくバイト数として指定しています。これは、AES-CCM-8が認証のサイズが8ビットではなく64ビットであるCCMモードのバージョンを参照するために頻繁に使用されるという誤解を招く可能性があります。これらの値は、伝統的にバイトカウントではなくビットカウントとして指定されていました。このドキュメントは、このドキュメントで提示されているさまざまなアルゴリズムを比較しやすくするために、ビット数を使用する規則に従います。"
    },
    {
      "indent": 0,
      "text": " We define a matrix of algorithms in this document over the values of L and M. Constrained devices are usually operating in situations where they use short messages and want to avoid doing recipient-specific cryptographic operations. This favors smaller values of both L and M. Less-constrained devices will want to be able to use larger messages and are more willing to generate new keys for every operation. This favors larger values of L and M.",
      "ja": "このドキュメントでは、LとMの値についてアルゴリズムのマトリックスを定義します。制約付きデバイスは通常、ショートメッセージを使用し、受信者固有の暗号化操作の実行を避けたい状況で動作しています。これにより、LとMの両方の値が小さくなります。制約の少ないデバイスは、より大きなメッセージを使用できるようになり、すべての操作で新しいキーを生成する用意があります。これにより、LとMの値が大きくなります。"
    },
    {
      "indent": 3,
      "text": "The following values are used for L:",
      "ja": "Lには次の値が使用されます。"
    },
    {
      "indent": 3,
      "text": "16 bits (2): This limits messages to 2^16 bytes (64 KiB) in length. This is sufficiently long for messages in the constrained world. The nonce length is 13 bytes allowing for 2^(13*8) possible values of the nonce without repeating.",
      "ja": "16ビット（2）：これにより、メッセージの長さが2 ^ 16バイト（64 KiB）に制限されます。これは、制約された世界のメッセージには十分な長さです。 nonceの長さは13バイトで、繰り返さずにnonceの2 ^（13 * 8）の可能な値を可能にします。"
    },
    {
      "indent": 3,
      "text": "64 bits (8): This limits messages to 2^64 bytes in length. The nonce length is 7 bytes allowing for 2^56 possible values of the nonce without repeating.",
      "ja": "64ビット（8）：これにより、メッセージの長さが2 ^ 64バイトに制限されます。 nonceの長さは7バイトで、繰り返さずにnonceの2 ^ 56の可能な値を可能にします。"
    },
    {
      "indent": 3,
      "text": "The following values are used for M:",
      "ja": "Mには次の値が使用されます。"
    },
    {
      "indent": 3,
      "text": "64 bits (8): This produces a 64-bit authentication tag. This implies that there is a 1 in 2^64 chance that a modified message will authenticate.",
      "ja": "64ビット（8）：64ビット認証タグを生成します。これは、変更されたメッセージが認証される可能性が2の64分の1の確率であることを意味します。"
    },
    {
      "indent": 3,
      "text": "128 bits (16): This produces a 128-bit authentication tag. This implies that there is a 1 in 2^128 chance that a modified message will authenticate.",
      "ja": "128ビット（16）：128ビットの認証タグを生成します。これは、変更されたメッセージが認証される2 ^ 128分の1の確率があることを意味します。"
    },
    {
      "indent": 3,
      "text": "+--------------------+-------+----+-----+-----+---------------------+\n| Name               | Value | L  | M   | k   | Description         |\n+--------------------+-------+----+-----+-----+---------------------+\n| AES-CCM-16-64-128  | 10    | 16 | 64  | 128 | AES-CCM mode        |\n|                    |       |    |     |     | 128-bit key, 64-bit |\n|                    |       |    |     |     | tag, 13-byte nonce  |\n| AES-CCM-16-64-256  | 11    | 16 | 64  | 256 | AES-CCM mode        |\n|                    |       |    |     |     | 256-bit key, 64-bit |\n|                    |       |    |     |     | tag, 13-byte nonce  |\n| AES-CCM-64-64-128  | 12    | 64 | 64  | 128 | AES-CCM mode        |\n|                    |       |    |     |     | 128-bit key, 64-bit |\n|                    |       |    |     |     | tag, 7-byte nonce   |\n| AES-CCM-64-64-256  | 13    | 64 | 64  | 256 | AES-CCM mode        |\n|                    |       |    |     |     | 256-bit key, 64-bit |\n|                    |       |    |     |     | tag, 7-byte nonce   |\n| AES-CCM-16-128-128 | 30    | 16 | 128 | 128 | AES-CCM mode        |\n|                    |       |    |     |     | 128-bit key,        |\n|                    |       |    |     |     | 128-bit tag,        |\n|                    |       |    |     |     | 13-byte nonce       |\n| AES-CCM-16-128-256 | 31    | 16 | 128 | 256 | AES-CCM mode        |\n|                    |       |    |     |     | 256-bit key,        |\n|                    |       |    |     |     | 128-bit tag,        |\n|                    |       |    |     |     | 13-byte nonce       |\n| AES-CCM-64-128-128 | 32    | 64 | 128 | 128 | AES-CCM mode        |\n|                    |       |    |     |     | 128-bit key,        |\n|                    |       |    |     |     | 128-bit tag, 7-byte |\n|                    |       |    |     |     | nonce               |\n| AES-CCM-64-128-256 | 33    | 64 | 128 | 256 | AES-CCM mode        |\n|                    |       |    |     |     | 256-bit key,        |\n|                    |       |    |     |     | 128-bit tag, 7-byte |\n|                    |       |    |     |     | nonce               |\n+--------------------+-------+----+-----+-----+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 10: Algorithm Values for AES-CCM",
      "ja": "表10：AES-CCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained either from a key structure or from a recipient structure. Implementations encrypting and decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化と復号化の実装では、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the AES-CCM algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合は、使用されているAES-CCMアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'encrypt' or 'wrap key' when encrypting.",
      "ja": "o 'key_ops'フィールドが存在する場合は、暗号化時に 'encrypt'または 'wrap key'を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'decrypt' or 'unwrap key' when decrypting.",
      "ja": "o 「key_ops」フィールドが存在する場合、復号化するときに「decrypt」または「unwrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.1. Security Considerations",
      "section_title": true,
      "ja": "10.2.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-CCM, the following restrictions MUST be enforced:",
      "ja": "AES-CCMを使用する場合、次の制限を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The key and nonce pair MUST be unique for every message encrypted. Note that the value of L influences the number of unique nonces.",
      "ja": "o キーとノンスのペアは、暗号化されたすべてのメッセージに対して一意である必要があります。 Lの値は一意のナンスの数に影響することに注意してください。"
    },
    {
      "indent": 3,
      "text": "o The total number of times the AES block cipher is used MUST NOT exceed 2^61 operations. This limitation is the sum of times the block cipher is used in computing the MAC value and in performing stream encryption operations. An explicit check is required only in environments where it is expected that it might be exceeded.",
      "ja": "o AESブロック暗号が使用される合計回数は、2 ^ 61回の操作を超えてはなりません。この制限は、ブロック暗号がMAC値の計算とストリーム暗号化操作の実行に使用される時間の合計です。明示的なチェックは、超過することが予想される環境でのみ必要です。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] additionally calls out one other consideration of note. It is possible to do a pre-computation attack against the algorithm in cases where portions of the plaintext are highly predictable. This reduces the security of the key size by half. Ways to deal with this attack include adding a random portion to the nonce value and/or increasing the key size used. Using a portion of the nonce for a random value will decrease the number of messages that a single key can be used for. Increasing the key size may require more resources in the constrained device. See Sections 5 and 10 of [RFC3610] for more information.",
      "ja": "[RFC3610]は、さらにもう1つの注意事項を示しています。平文の一部が非常に予測可能である場合、アルゴリズムに対して事前計算攻撃を行うことが可能です。これにより、キーサイズのセキュリティが半分になります。この攻撃に対処する方法には、ナンス値にランダムな部分を追加すること、および/または使用されるキーサイズを増やすことが含まれます。 nonceの一部をランダムな値に使用すると、単一のキーを使用できるメッセージの数が減ります。キーのサイズを大きくすると、制約されたデバイスでより多くのリソースが必要になる場合があります。詳細については、[RFC3610]のセクション5および10を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.3. ChaCha20 and Poly1305",
      "section_title": true,
      "ja": "10.3. ChaCha20およびPoly1305"
    },
    {
      "indent": 3,
      "text": "ChaCha20 and Poly1305 combined together is an AEAD mode that is defined in [RFC7539]. This is an algorithm defined to be a cipher that is not AES and thus would not suffer from any future weaknesses found in AES. These cryptographic functions are designed to be fast in software-only implementations.",
      "ja": "ChaCha20とPoly1305を組み合わせると、[RFC7539]で定義されているAEADモードになります。これは、AESではない暗号であると定義されたアルゴリズムであり、AESで見つかった将来の弱点に悩まされることはありません。これらの暗号化機能は、ソフトウェアのみの実装で高速になるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The ChaCha20/Poly1305 AEAD construction defined in [RFC7539] has no parameterization. It takes a 256-bit key and a 96-bit nonce, as well as the plaintext and additional data as inputs and produces the ciphertext as an option. We define one algorithm identifier for this algorithm in Table 11.",
      "ja": "[RFC7539]で定義されているChaCha20 / Poly1305 AEAD構造には、パラメーター化がありません。 256ビットの鍵と96ビットのナンス、および平文と追加データを入力として受け取り、オプションとして暗号文を生成します。このアルゴリズムのアルゴリズム識別子を表11で定義します。"
    },
    {
      "indent": 3,
      "text": "+-------------------+-------+---------------------------------------+\n| Name              | Value | Description                           |\n+-------------------+-------+---------------------------------------+\n| ChaCha20/Poly1305 | 24    | ChaCha20/Poly1305 w/ 256-bit key,     |\n|                   |       | 128-bit tag                           |\n+-------------------+-------+---------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 11: Algorithm Value for AES-GCM",
      "ja": "表11：AES-GCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained either from a key structure or from a recipient structure. Implementations encrypting and decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化と復号化の実装では、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the ChaCha20/Poly1305 algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合は、使用されているChaCha20 / Poly1305アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'encrypt' or 'wrap key' when encrypting.",
      "ja": "o 'key_ops'フィールドが存在する場合は、暗号化時に 'encrypt'または 'wrap key'を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'decrypt' or 'unwrap key' when decrypting.",
      "ja": "o 「key_ops」フィールドが存在する場合、復号化するときに「decrypt」または「unwrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.1. Security Considerations",
      "section_title": true,
      "ja": "10.3.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The key and nonce values MUST be a unique pair for every invocation of the algorithm. Nonce counters are considered to be an acceptable way of ensuring that they are unique.",
      "ja": "キーとノンス値は、アルゴリズムの呼び出しごとに一意のペアである必要があります。ナンスカウンターは、カウンターが一意であることを確認するための許容できる方法であると見なされます。"
    },
    {
      "indent": 0,
      "text": "11. Key Derivation Functions (KDFs)",
      "section_title": true,
      "ja": "11. 鍵導出関数（KDF）"
    },
    {
      "indent": 3,
      "text": "KDFs are used to take some secret value and generate a different one. The secret value comes in three flavors:",
      "ja": "KDFは、秘密の値を取得して別の値を生成するために使用されます。秘密の価値には3つの種類があります。"
    },
    {
      "indent": 3,
      "text": "o Secrets that are uniformly random: This is the type of secret that is created by a good random number generator.",
      "ja": "o 一様にランダムなシークレット：これは、優れた乱数ジェネレーターによって作成されるタイプのシークレットです。"
    },
    {
      "indent": 3,
      "text": "o Secrets that are not uniformly random: This is type of secret that is created by operations like key agreement.",
      "ja": "o 一様にランダムではない秘密：これは、鍵合意などの操作によって作成されるタイプの秘密です。"
    },
    {
      "indent": 3,
      "text": "o Secrets that are not random: This is the type of secret that people generate for things like passwords.",
      "ja": "o ランダムでない秘密：これは、人々がパスワードなどのために生成するタイプの秘密です。"
    },
    {
      "indent": 3,
      "text": "General KDFs work well with the first type of secret, can do reasonably well with the second type of secret, and generally do poorly with the last type of secret. None of the KDFs in this section are designed to deal with the type of secrets that are used for passwords. Functions like PBES2 [RFC8018] need to be used for that type of secret.",
      "ja": "一般的なKDFは、最初のタイプのシークレットでうまく機能し、2番目のタイプのシークレットである程度うまく機能し、通常、最後のタイプのシークレットではうまく機能しません。このセクションのKDFはいずれも、パスワードに使用される秘密のタイプを処理するように設計されていません。 PBES2 [RFC8018]のような関数は、そのタイプのシークレットに使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The same KDF can be set up to deal with the first two types of secrets in a different way. The KDF defined in Section 11.1 is such a function. This is reflected in the set of algorithms defined for the HMAC-based Extract-and-Expand Key Derivation Function (HKDF).",
      "ja": "同じKDFを設定して、最初の2種類のシークレットを異なる方法で処理することができます。セクション11.1で定義されているKDFはそのような関数です。これは、HMACベースの抽出および拡張鍵導出関数（HKDF）に対して定義された一連のアルゴリズムに反映されています。"
    },
    {
      "indent": 3,
      "text": "When using KDFs, one component that is included is context information. Context information is used to allow for different keying information to be derived from the same secret. The use of context-based keying material is considered to be a good security practice.",
      "ja": "KDFを使用する場合、含まれる1つのコンポーネントはコンテキスト情報です。コンテキスト情報を使用して、同じ秘密から別のキー情報を派生させることができます。コンテキストベースのキー情報の使用は、優れたセキュリティ慣行と見なされています。"
    },
    {
      "indent": 3,
      "text": "This document defines a single context structure and a single KDF. These elements are used for all of the recipient algorithms defined in this document that require a KDF process. These algorithms are defined in Sections 12.1.2, 12.4.1, and 12.5.1.",
      "ja": "このドキュメントでは、単一のコンテキスト構造と単一のKDFを定義しています。これらの要素は、このドキュメントで定義されている、KDFプロセスを必要とするすべての受信者アルゴリズムに使用されます。これらのアルゴリズムは、セクション12.1.2、12.4.1、および12.5.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "11.1. HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)",
      "section_title": true,
      "ja": "11.1. HMACベースの抽出および拡張キー導出関数（HKDF）"
    },
    {
      "indent": 3,
      "text": "The HKDF key derivation algorithm is defined in [RFC5869].",
      "ja": "HKDFキー導出アルゴリズムは[RFC5869]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The HKDF algorithm takes these inputs:",
      "ja": "HKDFアルゴリズムは次の入力を取ります。"
    },
    {
      "indent": 6,
      "text": "secret -- a shared value that is secret. Secrets may be either previously shared or derived from operations like a Diffie-Hellman (DH) key agreement.",
      "ja": "secret-秘密の共有値。シークレットは、以前に共有されているか、Diffie-Hellman（DH）鍵合意などの操作から導出されます。"
    },
    {
      "indent": 6,
      "text": "salt -- an optional value that is used to change the generation process. The salt value can be either public or private. If the salt is public and carried in the message, then the 'salt' algorithm header parameter defined in Table 13 is used. While [RFC5869] suggests that the length of the salt be the same as the length of the underlying hash value, any amount of salt will improve the security as different key values will be generated. This parameter is protected by being included in the key computation and does not need to be separately authenticated. The salt value does not need to be unique for every message sent.",
      "ja": "salt-生成プロセスを変更するために使用されるオプションの値。ソルト値は、パブリックまたはプライベートのいずれかです。ソルトがパブリックであり、メッセージに含まれている場合、表13で定義されている「ソルト」アルゴリズムヘッダーパラメーターが使用されます。 [RFC5869]はソルトの長さが基礎となるハッシュ値の長さと同じであることを示唆していますが、さまざまなキー値が生成されるため、ソルトをいくらでも使用するとセキュリティが向上します。このパラメーターは、キーの計算に含まれることで保護されており、個別に認証する必要はありません。ソルト値は、送信されるすべてのメッセージに対して一意である必要はありません。"
    },
    {
      "indent": 6,
      "text": "length -- the number of bytes of output that need to be generated.",
      "ja": "length-生成する必要がある出力のバイト数。"
    },
    {
      "indent": 6,
      "text": "context information -- Information that describes the context in which the resulting value will be used. Making this information specific to the context in which the material is going to be used ensures that the resulting material will always be tied to that usage. The context structure defined in Section 11.2 is used by the KDFs in this document.",
      "ja": "コンテキスト情報-結果の値が使用されるコンテキストを説明する情報。この情報を、マテリアルが使用される状況に固有のものにすることで、結果のマテリアルが常にその用途に関連付けられるようになります。セクション11.2で定義されたコンテキスト構造は、このドキュメントのKDFによって使用されます。"
    },
    {
      "indent": 6,
      "text": "PRF -- The underlying pseudorandom function to be used in the HKDF algorithm. The PRF is encoded into the HKDF algorithm selection.",
      "ja": "PRF-HKDFアルゴリズムで使用される基になる擬似ランダム関数。 PRFは、HKDFアルゴリズム選択にエンコードされます。"
    },
    {
      "indent": 3,
      "text": "HKDF is defined to use HMAC as the underlying PRF. However, it is possible to use other functions in the same construct to provide a different KDF that is more appropriate in the constrained world. Specifically, one can use AES-CBC-MAC as the PRF for the expand step, but not for the extract step. When using a good random shared secret of the correct length, the extract step can be skipped. For the AES algorithm versions, the extract step is always skipped.",
      "ja": "HKDFは、基礎となるPRFとしてHMACを使用するように定義されています。ただし、同じ構成で他の関数を使用して、制約のある世界でより適切な別のKDFを提供することは可能です。具体的には、AES-CBC-MACを展開ステップのPRFとして使用できますが、抽出ステップでは使用できません。正しい長さの適切なランダム共有シークレットを使用する場合、抽出ステップをスキップできます。 AESアルゴリズムバージョンの場合、抽出ステップは常にスキップされます。"
    },
    {
      "indent": 3,
      "text": "The extract step cannot be skipped if the secret is not uniformly random, for example, if it is the result of an ECDH key agreement step. This implies that the AES HKDF version cannot be used with ECDH. If the extract step is skipped, the 'salt' value is not used as part of the HKDF functionality.",
      "ja": "シークレットが一様にランダムでない場合、たとえばECDH鍵合意ステップの結果である場合、抽出ステップをスキップできません。これは、AES HKDFバージョンをECDHで使用できないことを意味します。抽出ステップがスキップされる場合、 'salt'値はHKDF機能の一部として使用されません。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document are found in Table 12.",
      "ja": "このドキュメントで定義されているアルゴリズムを表12に示します。"
    },
    {
      "indent": 3,
      "text": "+---------------+-----------------+---------------------------------+\n| Name          | PRF             | Description                     |\n+---------------+-----------------+---------------------------------+\n| HKDF SHA-256  | HMAC with       | HKDF using HMAC SHA-256 as the  |\n|               | SHA-256         | PRF                             |\n| HKDF SHA-512  | HMAC with       | HKDF using HMAC SHA-512 as the  |\n|               | SHA-512         | PRF                             |\n| HKDF AES-     | AES-CBC-MAC-128 | HKDF using AES-MAC as the PRF   |\n| MAC-128       |                 | w/ 128-bit key                  |\n| HKDF AES-     | AES-CBC-MAC-256 | HKDF using AES-MAC as the PRF   |\n| MAC-256       |                 | w/ 256-bit key                  |\n+---------------+-----------------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Table 12: HKDF Algorithms",
      "ja": "表12：HKDFアルゴリズム"
    },
    {
      "indent": 3,
      "text": "+------+-------+------+-------------------------------+-------------+\n| Name | Label | Type | Algorithm                     | Description |\n+------+-------+------+-------------------------------+-------------+\n| salt | -20   | bstr | direct+HKDF-SHA-256, direct   | Random salt |\n|      |       |      | +HKDF-SHA-512, direct+HKDF-   |             |\n|      |       |      | AES-128, direct+HKDF-AES-256, |             |\n|      |       |      | ECDH-ES+HKDF-256, ECDH-       |             |\n|      |       |      | ES+HKDF-512, ECDH-            |             |\n|      |       |      | SS+HKDF-256, ECDH-            |             |\n|      |       |      | SS+HKDF-512, ECDH-ES+A128KW,  |             |\n|      |       |      | ECDH-ES+A192KW, ECDH-         |             |\n|      |       |      | ES+A256KW, ECDH-SS+A128KW,    |             |\n|      |       |      | ECDH-SS+A192KW, ECDH-         |             |\n|      |       |      | SS+A256KW                     |             |\n+------+-------+------+-------------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 13: HKDF Algorithm Parameters",
      "ja": "表13：HKDFアルゴリズムのパラメーター"
    },
    {
      "indent": 0,
      "text": "11.2. Context Information Structure",
      "section_title": true,
      "ja": "11.2. コンテキスト情報構造"
    },
    {
      "indent": 3,
      "text": "The context information structure is used to ensure that the derived keying material is \"bound\" to the context of the transaction. The context information structure used here is based on that defined in [SP800-56A]. By using CBOR for the encoding of the context information structure, we automatically get the same type and length separation of fields that is obtained by the use of ASN.1. This means that there is no need to encode the lengths for the base elements, as it is done by the encoding used in JOSE (Section 4.6.2 of [RFC7518]).",
      "ja": "コンテキスト情報構造は、派生したキー情報がトランザクションのコンテキストに確実に「バインド」されるようにするために使用されます。ここで使用されるコンテキスト情報構造は、[SP800-56A]で定義されたものに基づいています。コンテキスト情報構造のエンコードにCBORを使用することにより、ASN.1を使用して得られるフィールドと同じタイプと長さの分離が自動的に得られます。つまり、JOSEで使用されているエンコーディング（[RFC7518]のセクション4.6.2）で行われているように、基本要素の長さをエンコードする必要はありません。"
    },
    {
      "indent": 3,
      "text": "The context information structure refers to PartyU and PartyV as the two parties that are doing the key derivation. Unless the application protocol defines differently, we assign PartyU to the entity that is creating the message and PartyV to the entity that is receiving the message. By doing this association, different keys will be derived for each direction as the context information is different in each direction.",
      "ja": "コンテキスト情報構造は、PartyUとPartyVを、キーの導出を行っている2つのパーティとして参照します。アプリケーションプロトコルの定義が異なる場合を除き、PartyUはメッセージを作成するエンティティに、PartyVはメッセージを受信するエンティティに割り当てます。この関連付けを行うと、コンテキスト情報が方向ごとに異なるため、方向ごとに異なるキーが生成されます。"
    },
    {
      "indent": 3,
      "text": "The context structure is built from information that is known to both entities. This information can be obtained from a variety of sources:",
      "ja": "コンテキスト構造は、両方のエンティティに既知の情報から構築されています。この情報は、さまざまなソースから取得できます。"
    },
    {
      "indent": 3,
      "text": "o Fields can be defined by the application. This is commonly used to assign fixed names to parties, but it can be used for other items such as nonces.",
      "ja": "o フィールドはアプリケーションで定義できます。これは通常、固定名をパーティーに割り当てるために使用されますが、ナンスなどの他のアイテムに使用できます。"
    },
    {
      "indent": 3,
      "text": "o Fields can be defined by usage of the output. Examples of this are the algorithm and key size that are being generated.",
      "ja": "o フィールドは、出力の使用法によって定義できます。この例は、生成されるアルゴリズムとキーサイズです。"
    },
    {
      "indent": 3,
      "text": "o Fields can be defined by parameters from the message. We define a set of parameters in Table 14 that can be used to carry the values associated with the context structure. Examples of this are identities and nonce values. These parameters are designed to be placed in the unprotected bucket of the recipient structure; they do not need to be in the protected bucket since they already are included in the cryptographic computation by virtue of being included in the context structure.",
      "ja": "o フィールドは、メッセージのパラメーターによって定義できます。表14で、コンテキスト構造に関連付けられた値を運ぶために使用できる一連のパラメーターを定義します。これの例は、アイデンティティとノンス値です。これらのパラメーターは、受信者構造の保護されていないバケットに配置されるように設計されています。コンテキスト構造に含まれているため、暗号化計算にすでに含まれているため、保護バケットに入れる必要はありません。"
    },
    {
      "indent": 3,
      "text": "+----------+-------+------+---------------------------+-------------+\n| Name     | Label | Type | Algorithm                 | Description |\n+----------+-------+------+---------------------------+-------------+\n| PartyU   | -21   | bstr | direct+HKDF-SHA-256,      | Party U     |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |\n|          |       |      |                           |             |\n| PartyU   | -22   | bstr | direct+HKDF-SHA-256,      | Party U     |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |\n|          |       |      |                           |             |\n| PartyU   | -23   | bstr | direct+HKDF-SHA-256,      | Party U     |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| PartyV   | -24   | bstr | direct+HKDF-SHA-256,      | Party V     |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |\n|          |       |      |                           |             |\n| PartyV   | -25   | bstr | direct+HKDF-SHA-256,      | Party V     |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |\n|          |       |      |                           |             |\n| PartyV   | -26   | bstr | direct+HKDF-SHA-256,      | Party V     |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n|          |       |      | ES+HKDF-512, ECDH-        |             |\n|          |       |      | SS+HKDF-256, ECDH-        |             |\n|          |       |      | SS+HKDF-512, ECDH-        |             |\n|          |       |      | ES+A128KW, ECDH-          |             |\n|          |       |      | ES+A192KW, ECDH-          |             |\n|          |       |      | ES+A256KW, ECDH-          |             |\n|          |       |      | SS+A128KW, ECDH-          |             |\n|          |       |      | SS+A192KW, ECDH-SS+A256KW |             |\n+----------+-------+------+---------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 14: Context Algorithm Parameters",
      "ja": "表14：コンテキストアルゴリズムのパラメーター"
    },
    {
      "indent": 3,
      "text": "We define a CBOR object to hold the context information. This object is referred to as COSE_KDF_Context. The object is based on a CBOR array type. The fields in the array are:",
      "ja": "コンテキスト情報を保持するCBORオブジェクトを定義します。このオブジェクトはCOSE_KDF_Contextと呼ばれます。オブジェクトはCBOR配列型に基づいています。配列のフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "AlgorithmID: This field indicates the algorithm for which the key material will be used. This normally is either a key wrap algorithm identifier or a content encryption algorithm identifier. The values are from the \"COSE Algorithms\" registry. This field is required to be present. The field exists in the context information so that if the same environment is used for different algorithms, then completely different keys will be generated for each of those algorithms. This practice means if algorithm A is broken and thus is easier to find, the key derived for algorithm B will not be the same as the key derived for algorithm A.",
      "ja": "AlgorithmID：このフィールドは、鍵素材が使用されるアルゴリズムを示します。これは通常、キーラップアルゴリズム識別子またはコンテンツ暗号化アルゴリズム識別子のいずれかです。値は、「COSEアルゴリズム」レジストリからのものです。このフィールドは必須です。このフィールドはコンテキスト情報に存在するため、同じ環境が異なるアルゴリズムに使用されている場合、それらのアルゴリズムごとに完全に異なるキーが生成されます。これは、アルゴリズムAが壊れていて見つけやすい場合、アルゴリズムBに導出されたキーはアルゴリズムAに導出されたキーと同じにならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "PartyUInfo: This field holds information about party U. The PartyUInfo is encoded as a CBOR array. The elements of PartyUInfo are encoded in the order presented. The elements of the PartyUInfo array are:",
      "ja": "PartyUInfo：このフィールドは、パーティーUに関する情報を保持します。PartyUInfoは、CBOR配列としてエンコードされます。 PartyUInfoの要素は、表示されている順にエンコードされます。 PartyUInfo配列の要素は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "identity: This contains the identity information for party U. The identities can be assigned in one of two manners. First, a protocol can assign identities based on roles. For example, the roles of \"client\" and \"server\" may be assigned to different entities in the protocol. Each entity would then use the correct label for the data they send or receive. The second way for a protocol to assign identities is to use a name based on a naming system (i.e., DNS, X.509 names).",
      "ja": "identity：パーティーUのID情報が含まれています。IDは2つの方法のいずれかで割り当てることができます。まず、プロトコルはロールに基づいてIDを割り当てることができます。たとえば、「クライアント」と「サーバー」の役割は、プロトコルの異なるエンティティに割り当てることができます。次に、各エンティティは、送受信するデータに正しいラベルを使用します。プロトコルがIDを割り当てる2番目の方法は、ネーミングシステムに基づいた名前を使用することです（DNS、X.509名など）。"
    },
    {
      "indent": 9,
      "text": "We define an algorithm parameter 'PartyU identity' that can be used to carry identity information in the message. However, identity information is often known as part of the protocol and can thus be inferred rather than made explicit. If identity information is carried in the message, applications SHOULD have a way of validating the supplied identity information. The identity information does not need to be specified and is set to nil in that case.",
      "ja": "メッセージでID情報を伝達するために使用できるアルゴリズムパラメーター 'PartyU ID'を定義します。ただし、ID情報はプロトコルの一部としてよく知られているため、明示的にするのではなく、推測することができます。 ID情報がメッセージに含まれている場合、アプリケーションには、提供されたID情報を検証する方法が必要です（SHOULD）。 ID情報を指定する必要はなく、その場合はnilに設定されます。"
    },
    {
      "indent": 6,
      "text": "nonce: This contains a nonce value. The nonce can either be implicit from the protocol or be carried as a value in the unprotected headers.",
      "ja": "nonce：これはnonce値を含みます。 nonceは、プロトコルから暗黙的に指定することも、保護されていないヘッダーの値として伝達することもできます。"
    },
    {
      "indent": 9,
      "text": "We define an algorithm parameter 'PartyU nonce' that can be used to carry this value in the message; however, the nonce value could be determined by the application and the value determined from elsewhere.",
      "ja": "メッセージでこの値を伝えるために使用できるアルゴリズムパラメータ「PartyU nonce」を定義します。ただし、ノンス値はアプリケーションによって決定され、値は他の場所から決定されます。"
    },
    {
      "indent": 9,
      "text": "This option does not need to be specified and is set to nil in that case.",
      "ja": "このオプションを指定する必要はなく、その場合はnilに設定されます。"
    },
    {
      "indent": 6,
      "text": "other: This contains other information that is defined by the protocol. This option does not need to be specified and is set to nil in that case.",
      "ja": "other：これには、プロトコルで定義されている他の情報が含まれています。このオプションを指定する必要はなく、その場合はnilに設定されます。"
    },
    {
      "indent": 3,
      "text": "PartyVInfo: This field holds information about party V. The content of the structure is the same as for the PartyUInfo but for party V.",
      "ja": "PartyVInfo：このフィールドは、パーティーVに関する情報を保持します。構造の内容はPartyUInfoと同じですが、パーティーVのものです。"
    },
    {
      "indent": 3,
      "text": "SuppPubInfo: This field contains public information that is mutually known to both parties.",
      "ja": "SuppPubInfo：このフィールドには、両方の当事者が相互に知っている公開情報が含まれています。"
    },
    {
      "indent": 6,
      "text": "keyDataLength: This is set to the number of bits of the desired output value. This practice means if algorithm A can use two different key lengths, the key derived for longer key size will not contain the key for shorter key size as a prefix.",
      "ja": "keyDataLength：これは、目的の出力値のビット数に設定されます。これは、アルゴリズムAが2つの異なるキー長を使用できる場合、長いキーサイズ用に派生したキーには、短いキーサイズ用のキーがプレフィックスとして含まれないことを意味します。"
    },
    {
      "indent": 6,
      "text": "protected: This field contains the protected parameter field. If there are no elements in the protected field, then use a zero-length bstr.",
      "ja": "protected：このフィールドには、保護されたパラメーターフィールドが含まれます。保護されたフィールドに要素がない場合は、長さ0のbstrを使用します。"
    },
    {
      "indent": 6,
      "text": "other: This field is for free form data defined by the application. An example is that an application could define two different strings to be placed here to generate different keys for a data stream versus a control stream. This field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "その他：このフィールドは、アプリケーションによって定義された自由形式のデータ用です。例として、アプリケーションが2つの異なる文字列をここに配置して、データストリームと制御ストリームの異なるキーを生成するように定義できます。このフィールドはオプションであり、アプリケーションがこの情報の構造を定義する場合にのみ存在します。これを定義するアプリケーションは、タイプと長さが正しく含まれるようにCBORを使用してデータをエンコードする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "SuppPrivInfo: This field contains private information that is mutually known private information. An example of this information would be a preexisting shared secret. (This could, for example, be used in combination with an ECDH key agreement to provide a secondary proof of identity.) The field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "SuppPrivInfo：このフィールドには、相互に既知の個人情報である個人情報が含まれます。この情報の例は、既存の共有秘密です。 （たとえば、これはECDH鍵合意と組み合わせて使用​​され、IDの2次的な証明を提供します。）このフィールドはオプションであり、アプリケーションがこの情報の構造を定義する場合にのみ存在します。これを定義するアプリケーションは、タイプと長さが正しく含まれるようにCBORを使用してデータをエンコードする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The following CDDL fragment corresponds to the text above.",
      "ja": "次のCDDLフラグメントは、上記のテキストに対応しています。"
    },
    {
      "indent": 3,
      "text": "PartyInfo = (\n    identity : bstr / nil,\n    nonce : bstr / int / nil,\n    other : bstr / nil\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COSE_KDF_Context = [\n    AlgorithmID : int / tstr,\n    PartyUInfo : [ PartyInfo ],\n    PartyVInfo : [ PartyInfo ],\n    SuppPubInfo : [\n        keyDataLength : uint,\n        protected : empty_or_serialized_map,\n        ? other : bstr\n    ],\n    ? SuppPrivInfo : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12. Content Key Distribution Methods",
      "section_title": true,
      "ja": "12. コンテンツキーの配布方法"
    },
    {
      "indent": 3,
      "text": "Content key distribution methods (recipient algorithms) can be defined into a number of different classes. COSE has the ability to support many classes of recipient algorithms. In this section, a number of classes are listed, and then a set of algorithms are specified for each of the classes. The names of the recipient algorithm classes used here are the same as those defined in [RFC7516]. Other specifications use different terms for the recipient algorithm classes or do not support some of the recipient algorithm classes.",
      "ja": "コンテンツキーの配布方法（受信者アルゴリズム）は、さまざまなクラスに定義できます。 COSEには、多くのクラスの受信者アルゴリズムをサポートする機能があります。このセクションでは、いくつかのクラスがリストされ、アルゴリズムのセットがクラスごとに指定されます。ここで使用される受信者アルゴリズムクラスの名前は、[RFC7516]で定義されているものと同じです。他の仕様では、受信者アルゴリズムクラスに異なる用語を使用しているか、一部の受信者アルゴリズムクラスをサポートしていません。"
    },
    {
      "indent": 0,
      "text": "12.1. Direct Encryption",
      "section_title": true,
      "ja": "12.1. 直接暗号化"
    },
    {
      "indent": 3,
      "text": "The direct encryption class algorithms share a secret between the sender and the recipient that is used either directly or after manipulation as the CEK. When direct encryption mode is used, it MUST be the only mode used on the message.",
      "ja": "直接暗号化クラスアルゴリズムは、送信者と受信者の間で、直接または操作後にCEKとして使用される秘密を共有します。直接暗号化モードが使用される場合、メッセージで使用される唯一のモードである必要があります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Recipient structure for the recipient is organized as follows:",
      "ja": "受信者のCOSE_Recipient構造は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o The 'protected' field MUST be a zero-length item unless it is used in the computation of the content key.",
      "ja": "o 「保護された」フィールドは、コンテンツキーの計算に使用されない限り、長さがゼロの項目である必要があります。"
    },
    {
      "indent": 3,
      "text": "o The 'alg' parameter MUST be present.",
      "ja": "o 「alg」パラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A parameter identifying the shared secret SHOULD be present.",
      "ja": "o 共有シークレットを識別するパラメータが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The 'ciphertext' field MUST be a zero-length item.",
      "ja": "o 「暗号文」フィールドは長さがゼロの項目でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The 'recipients' field MUST be absent.",
      "ja": "o 「受信者」フィールドは存在しない必要があります。"
    },
    {
      "indent": 0,
      "text": "12.1.1. Direct Key",
      "section_title": true,
      "ja": "12.1.1. ダイレクトキー"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm is the simplest; the identified key is directly used as the key for the next layer down in the message. There are no algorithm parameters defined for this algorithm. The algorithm identifier value is assigned in Table 15.",
      "ja": "この受信者アルゴリズムは最も単純です。識別されたキーは、メッセージ内の次のレイヤーのキーとして直接使用されます。このアルゴリズムに定義されているアルゴリズムパラメータはありません。アルゴリズム識別子の値は、表15で割り当てられています。"
    },
    {
      "indent": 3,
      "text": "When this algorithm is used, the protected field MUST be zero length. The key type MUST be 'Symmetric'.",
      "ja": "このアルゴリズムを使用する場合、保護フィールドは長さがゼロでなければなりません。鍵タイプは「対称」でなければなりません。"
    },
    {
      "indent": 18,
      "text": "+--------+-------+-------------------+\n| Name   | Value | Description       |\n+--------+-------+-------------------+\n| direct | -6    | Direct use of CEK |\n+--------+-------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Table 15: Direct Key",
      "ja": "表15：ダイレクトキー"
    },
    {
      "indent": 0,
      "text": "12.1.1.1. Security Considerations",
      "section_title": true,
      "ja": "12.1.1.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm has several potential problems that need to be considered:",
      "ja": "この受信者アルゴリズムには、考慮する必要があるいくつかの潜在的な問題があります。"
    },
    {
      "indent": 3,
      "text": "o These keys need to have some method to be regularly updated over time. All of the content encryption algorithms specified in this document have limits on how many times a key can be used without significant loss of security.",
      "ja": "o これらのキーには、時間の経過とともに定期的に更新される何らかのメソッドが必要です。このドキュメントで指定されているすべてのコンテンツ暗号化アルゴリズムには、セキュリティを大幅に損なうことなくキーを使用できる回数に制限があります。"
    },
    {
      "indent": 3,
      "text": "o These keys need to be dedicated to a single algorithm. There have been a number of attacks developed over time when a single key is used for multiple different algorithms. One example of this is the use of a single key for both the CBC encryption mode and the CBC-MAC authentication mode.",
      "ja": "o これらのキーは、単一のアルゴリズム専用にする必要があります。単一のキーが複数の異なるアルゴリズムに使用されると、時間の経過とともに多くの攻撃が発生しました。この1つの例は、CBC暗号化モードとCBC-MAC認証モードの両方に単一のキーを使用することです。"
    },
    {
      "indent": 3,
      "text": "o Breaking one message means all messages are broken. If an adversary succeeds in determining the key for a single message, then the key for all messages is also determined.",
      "ja": "o 1つのメッセージを分割すると、すべてのメッセージが分割されます。攻撃者が単一のメッセージのキーを決定することに成功した場合、すべてのメッセージのキーも決定されます。"
    },
    {
      "indent": 0,
      "text": "12.1.2. Direct Key with KDF",
      "section_title": true,
      "ja": "12.1.2. KDFを使用したダイレクトキー"
    },
    {
      "indent": 3,
      "text": "These recipient algorithms take a common shared secret between the two parties and applies the HKDF function (Section 11.1), using the context structure defined in Section 11.2 to transform the shared",
      "ja": "これらの受信者アルゴリズムは、2つの当事者間で共通の共有秘密を取得し、セクション11.2で定義されたコンテキスト構造を使用してHKDF関数（セクション11.1）を適用し、共有された"
    },
    {
      "indent": 3,
      "text": "secret into the CEK. The 'protected' field can be of non-zero length. Either the 'salt' parameter of HKDF or the 'PartyU nonce' parameter of the context structure MUST be present. The salt/nonce parameter can be generated either randomly or deterministically. The requirement is that it be a unique value for the shared secret in question.",
      "ja": "CEKに秘密。 「保護」フィールドの長さはゼロ以外にすることができます。 HKDFの「salt」パラメーターまたはコンテキスト構造の「PartyU nonce」パラメーターのいずれかが存在する必要があります。 salt / nonceパラメータは、ランダムまたは確定的に生成できます。要件は、それが問題の共有秘密の一意の値であることです。"
    },
    {
      "indent": 3,
      "text": "If the salt/nonce value is generated randomly, then it is suggested that the length of the random value be the same length as the hash function underlying HKDF. While there is no way to guarantee that it will be unique, there is a high probability that it will be unique. If the salt/nonce value is generated deterministically, it can be guaranteed to be unique, and thus there is no length requirement.",
      "ja": "salt / nonce値がランダムに生成される場合、ランダム値の長さは、HKDFの基礎となるハッシュ関数と同じ長さであることが推奨されます。一意であることを保証する方法はありませんが、一意になる可能性が高くなります。ソルト/ノンス値が確定的に生成される場合、一意であることが保証されるため、長さの要件はありません。"
    },
    {
      "indent": 3,
      "text": "A new IV must be used for each message if the same key is used. The IV can be modified in a predictable manner, a random manner, or an unpredictable manner (i.e., encrypting a counter).",
      "ja": "同じキーを使用する場合は、メッセージごとに新しいIVを使用する必要があります。 IVは、予測可能な方法、ランダムな方法、または予測不可能な方法（つまり、カウンターの暗号化）で変更できます。"
    },
    {
      "indent": 3,
      "text": "The IV used for a key can also be generated from the same HKDF functionality as the key is generated. If HKDF is used for generating the IV, the algorithm identifier is set to \"IV-GENERATION\".",
      "ja": "キーに使用されるIVは、キーが生成されるのと同じHKDF機能から生成することもできます。 IVの生成にHKDFが使用される場合、アルゴリズム識別子は「IV-GENERATION」に設定されます。"
    },
    {
      "indent": 3,
      "text": "When these algorithms are used, the key type MUST be 'symmetric'.",
      "ja": "これらのアルゴリズムを使用する場合、鍵のタイプは「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document can be found in Table 16.",
      "ja": "このドキュメントで定義されているアルゴリズムのセットは、表16にあります。"
    },
    {
      "indent": 3,
      "text": "+---------------------+-------+-------------+-----------------------+\n| Name                | Value | KDF         | Description           |\n+---------------------+-------+-------------+-----------------------+\n| direct+HKDF-SHA-256 | -10   | HKDF        | Shared secret w/ HKDF |\n|                     |       | SHA-256     | and SHA-256           |\n| direct+HKDF-SHA-512 | -11   | HKDF        | Shared secret w/ HKDF |\n|                     |       | SHA-512     | and SHA-512           |\n| direct+HKDF-AES-128 | -12   | HKDF AES-   | Shared secret w/ AES- |\n|                     |       | MAC-128     | MAC 128-bit key       |\n| direct+HKDF-AES-256 | -13   | HKDF AES-   | Shared secret w/ AES- |\n|                     |       | MAC-256     | MAC 256-bit key       |\n+---------------------+-------+-------------+-----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 16: Direct Key with KDF",
      "ja": "表16：KDFを使用したダイレクトキー"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されているアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'deriveKey' or 'deriveBits'.",
      "ja": "o 「key_ops」フィールドが存在する場合、「deriveKey」または「deriveBits」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "12.1.2.1. Security Considerations",
      "section_title": true,
      "ja": "12.1.2.1. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method to be regularly updated over time. The shared secret forms the basis of trust. Although not used directly, it should still be subject to scheduled rotation.",
      "ja": "共有シークレットには、時間の経過とともに定期的に更新される何らかのメソッドが必要です。共有秘密は信頼の基礎を形成します。直接は使用されませんが、スケジュールされたローテーションの対象となる必要があります。"
    },
    {
      "indent": 3,
      "text": "While these methods do not provide for perfect forward secrecy, as the same shared secret is used for all of the keys generated, if the key for any single message is discovered, only the message (or series of messages) using that derived key are compromised. A new key derivation step will generate a new key that requires the same amount of work to get the key.",
      "ja": "これらの方法では完全な転送秘密が提供されませんが、生成されたすべてのキーに同じ共有シークレットが使用されるため、単一のメッセージのキーが発見された場合、その派生キーを使用するメッセージ（または一連のメッセージ）のみが侵害されます。新しい鍵導出ステップは、鍵を取得するために同じ量の作業を必要とする新しい鍵を生成します。"
    },
    {
      "indent": 0,
      "text": "12.2. Key Wrap",
      "section_title": true,
      "ja": "12.2. キーラップ"
    },
    {
      "indent": 3,
      "text": "In key wrap mode, the CEK is randomly generated and that key is then encrypted by a shared secret between the sender and the recipient. All of the currently defined key wrap algorithms for COSE are AE algorithms. Key wrap mode is considered to be superior to direct encryption if the system has any capability for doing random key generation. This is because the shared key is used to wrap random data rather than data that has some degree of organization and may in fact be repeating the same content. The use of key wrap loses the weak data origination that is provided by the direct encryption algorithms.",
      "ja": "キーラップモードでは、CEKがランダムに生成され、そのキーは送信者と受信者の間の共有秘密によって暗号化されます。現在定義されているCOSEのキーラップアルゴリズムはすべてAEアルゴリズムです。キーラップモードは、システムにランダムキー生成を実行する機能がある場合、直接暗号化よりも優れていると見なされます。これは、共有キーは、ある程度の編成があり、実際には同じコンテンツを繰り返す可能性のあるデータではなく、ランダムデータをラップするために使用されるためです。キーラップを使用すると、直接暗号化アルゴリズムによって提供される弱いデータ発信が失われます。"
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt structure for the recipient is organized as follows:",
      "ja": "受信者のCOSE_Encrypt構造は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o The 'protected' field MUST be absent if the key wrap algorithm is an AE algorithm.",
      "ja": "o キーラップアルゴリズムがAEアルゴリズムの場合、 'protected'フィールドは存在しない必要があります。"
    },
    {
      "indent": 3,
      "text": "o The 'recipients' field is normally absent, but can be used. Applications MUST deal with a recipient field being present, not being able to decrypt that recipient is an acceptable way of dealing with it. Failing to process the message is not an acceptable way of dealing with it.",
      "ja": "o 「受信者」フィールドは通常ありませんが、使用できます。アプリケーションは、存在する受信者フィールドを処理する必要があり、その受信者を復号化できないことは、それを処理する許容できる方法です。メッセージの処理に失敗すると、それに対処するための許容できる方法ではありません。"
    },
    {
      "indent": 3,
      "text": "o The plaintext to be encrypted is the key from next layer down (usually the content layer).",
      "ja": "o 暗号化されるプレーンテキストは、次のレイヤー（通常はコンテンツレイヤー）からのキーです。"
    },
    {
      "indent": 3,
      "text": "o At a minimum, the 'unprotected' field MUST contain the 'alg' parameter and SHOULD contain a parameter identifying the shared secret.",
      "ja": "o 少なくとも、「無保護」フィールドには「alg」パラメーターが含まれている必要があり、共有秘密を識別するパラメーターが含まれている必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "12.2.1. AES Key Wrap",
      "section_title": true,
      "ja": "12.2.1. AESキーラップ"
    },
    {
      "indent": 3,
      "text": "The AES Key Wrap algorithm is defined in [RFC3394]. This algorithm uses an AES key to wrap a value that is a multiple of 64 bits. As such, it can be used to wrap a key for any of the content encryption algorithms defined in this document. The algorithm requires a single fixed parameter, the initial value. This is fixed to the value specified in Section 2.2.3.1 of [RFC3394]. There are no public parameters that vary on a per-invocation basis. The protected header field MUST be empty.",
      "ja": "AESキーラップアルゴリズムは、[RFC3394]で定義されています。このアルゴリズムは、AESキーを使用して64ビットの倍数である値をラップします。そのため、このドキュメントで定義されている任意のコンテンツ暗号化アルゴリズムのキーをラップするために使用できます。アルゴリズムには、単一の固定パラメーターである初期値が必要です。これは、[RFC3394]のセクション2.2.3.1で指定された値に固定されています。呼び出しごとに異なるパブリックパラメータはありません。保護されたヘッダーフィールドは空である必要があります。"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained either from a key structure or from a recipient structure. Implementations encrypting and decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化と復号化の実装では、鍵のタイプ、鍵の長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'Symmetric'.",
      "ja": "o 「kty」フィールドは存在しなければならず、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the AES Key Wrap algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、それは使用されているAESキーラップアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'encrypt' or 'wrap key' when encrypting.",
      "ja": "o 'key_ops'フィールドが存在する場合は、暗号化時に 'encrypt'または 'wrap key'を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'decrypt' or 'unwrap key' when decrypting.",
      "ja": "o 「key_ops」フィールドが存在する場合、復号化するときに「decrypt」または「unwrap key」を含める必要があります。"
    },
    {
      "indent": 8,
      "text": "+--------+-------+----------+-----------------------------+\n| Name   | Value | Key Size | Description                 |\n+--------+-------+----------+-----------------------------+\n| A128KW | -3    | 128      | AES Key Wrap w/ 128-bit key |\n| A192KW | -4    | 192      | AES Key Wrap w/ 192-bit key |\n| A256KW | -5    | 256      | AES Key Wrap w/ 256-bit key |\n+--------+-------+----------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 17: AES Key Wrap Algorithm Values",
      "ja": "表17：AESキーラップアルゴリズムの値"
    },
    {
      "indent": 0,
      "text": "12.2.1.1. Security Considerations for AES-KW",
      "section_title": true,
      "ja": "12.2.1.1. AES-KWのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method to be regularly updated over time. The shared secret is the basis of trust.",
      "ja": "共有シークレットには、時間の経過とともに定期的に更新される何らかのメソッドが必要です。共有秘密は信頼の基礎です。"
    },
    {
      "indent": 0,
      "text": "12.3. Key Transport",
      "section_title": true,
      "ja": "12.3. キートランスポート"
    },
    {
      "indent": 3,
      "text": "Key transport mode is also called key encryption mode in some standards. Key transport mode differs from key wrap mode in that it uses an asymmetric encryption algorithm rather than a symmetric encryption algorithm to protect the key. This document does not define any key transport mode algorithms.",
      "ja": "キー転送モードは、一部の規格ではキー暗号化モードとも呼ばれます。キートランスポートモードは、対称暗号化アルゴリズムではなく非対称暗号化アルゴリズムを使用してキーを保護するという点で、キーラップモードとは異なります。このドキュメントでは、主要なトランスポートモードアルゴリズムを定義していません。"
    },
    {
      "indent": 3,
      "text": "When using a key transport algorithm, the COSE_Encrypt structure for the recipient is organized as follows:",
      "ja": "キー転送アルゴリズムを使用する場合、受信者のCOSE_Encrypt構造は次のように編成されます。"
    },
    {
      "indent": 3,
      "text": "o The 'protected' field MUST be absent.",
      "ja": "o 「保護された」フィールドは存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The plaintext to be encrypted is the key from the next layer down (usually the content layer).",
      "ja": "o 暗号化されるプレーンテキストは、次のレイヤー（通常はコンテンツレイヤー）からのキーです。"
    },
    {
      "indent": 3,
      "text": "o At a minimum, the 'unprotected' field MUST contain the 'alg' parameter and SHOULD contain a parameter identifying the asymmetric key.",
      "ja": "o 少なくとも、「保護されていない」フィールドには「alg」パラメータが含まれている必要があり、非対称キーを識別するパラメータが含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4. Direct Key Agreement",
      "section_title": true,
      "ja": "12.4. 直接鍵協定"
    },
    {
      "indent": 3,
      "text": "The 'direct key agreement' class of recipient algorithms uses a key agreement method to create a shared secret. A KDF is then applied to the shared secret to derive a key to be used in protecting the data. This key is normally used as a CEK or MAC key, but could be used for other purposes if more than two layers are in use (see Appendix B).",
      "ja": "受信者アルゴリズムの「直接鍵合意」クラスは、鍵合意方式を使用して共有秘密を作成します。次に、KDFが共有シークレットに適用され、データの保護に使用されるキーが導出されます。このキーは通常CEKキーまたはMACキーとして使用されますが、3つ以上のレイヤーが使用されている場合は他の目的で使用できます（付録Bを参照）。"
    },
    {
      "indent": 3,
      "text": "The most commonly used key agreement algorithm is Diffie-Hellman, but other variants exist. Since COSE is designed for a store and forward environment rather than an online environment, many of the DH variants cannot be used as the receiver of the message cannot provide any dynamic key material. One side effect of this is that perfect forward secrecy (see [RFC4949]) is not achievable. A static key will always be used for the receiver of the COSE object.",
      "ja": "最も一般的に使用される鍵合意アルゴリズムはDiffie-Hellmanですが、他のバリアントも存在します。 COSEはオンライン環境ではなくストアアンドフォワード環境向けに設計されているため、メッセージの受信者が動的なキーマテリアルを提供できないため、DHバリアントの多くは使用できません。これの1つの副作用は、完全な前方秘密性（[RFC4949]を参照）が実現できないことです。静的キーは常にCOSEオブジェクトの受信者に使用されます。"
    },
    {
      "indent": 3,
      "text": "Two variants of DH that are supported are:",
      "ja": "サポートされているDHの2つのバリアントは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Ephemeral-Static (ES) DH: where the sender of the message creates a one-time DH key and uses a static key for the recipient. The use of the ephemeral sender key means that no additional random input is needed as this is randomly generated for each message.",
      "ja": "Ephemeral-Static（ES）DH：メッセージの送信者が1回限りのDHキーを作成し、受信者に静的キーを使用します。エフェメラル送信者キーを使用すると、メッセージごとにランダムに生成されるため、追加のランダム入力は必要ありません。"
    },
    {
      "indent": 6,
      "text": "Static-Static DH: where a static key is used for both the sender and the recipient. The use of static keys allows for the recipient to get a weak version of data origination for the message. When static-static key agreement is used, then some piece of unique data for the KDF is required to ensure that a different key is created for each message.",
      "ja": "Static-Static DH：静的キーは送信者と受信者の両方に使用されます。静的キーを使用すると、受信者はメッセージのデータ発信の弱いバージョンを取得できます。静的-静的キー合意を使用する場合、各メッセージに対して異なるキーが作成されるようにするために、KDFの一意のデータの一部が必要です。"
    },
    {
      "indent": 3,
      "text": "When direct key agreement mode is used, there MUST be only one recipient in the message. This method creates the key directly, and that makes it difficult to mix with additional recipients. If multiple recipients are needed, then the version with key wrap needs to be used.",
      "ja": "ダイレクトキーアグリーメントモードを使用する場合、メッセージ内の受信者は1人だけでなければなりません。この方法では、キーが直接作成されるため、追加の受信者と混在させることが困難になります。複数の受信者が必要な場合は、キーラップ付きのバージョンを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The COSE_Encrypt structure for the recipient is organized as follows:",
      "ja": "受信者のCOSE_Encrypt構造は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o At a minimum, headers MUST contain the 'alg' parameter and SHOULD contain a parameter identifying the recipient's asymmetric key.",
      "ja": "o 少なくとも、ヘッダーには「alg」パラメーターを含める必要があり、受信者の非対称鍵を識別するパラメーターを含める必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o The headers SHOULD identify the sender's key for the static-static versions and MUST contain the sender's ephemeral key for the ephemeral-static versions.",
      "ja": "o ヘッダーは、静的静的バージョンの送信者のキーを識別して（SHOULD）、一時的静的バージョンの送信者の一時キーを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4.1. ECDH",
      "section_title": true,
      "ja": "12.4.1. そのように"
    },
    {
      "indent": 3,
      "text": "The mathematics for ECDH can be found in [RFC6090]. In this document, the algorithm is extended to be used with the two curves defined in [RFC7748].",
      "ja": "ECDHの数学は[RFC6090]にあります。このドキュメントでは、アルゴリズムが拡張されて、[RFC7748]で定義された2つの曲線で使用されます。"
    },
    {
      "indent": 3,
      "text": "ECDH is parameterized by the following:",
      "ja": "ECDHは以下によってパラメーター化されます。"
    },
    {
      "indent": 3,
      "text": "o Curve Type/Curve: The curve selected controls not only the size of the shared secret, but the mathematics for computing the shared secret. The curve selected also controls how a point in the curve is represented and what happens for the identity points on the curve. In this specification, we allow for a number of different curves to be used. A set of curves are defined in Table 22. The math used to obtain the computed secret is based on the curve selected and not on the ECDH algorithm. For this reason, a new algorithm does not need to be defined for each of the curves.",
      "ja": "o 曲線タイプ/曲線：選択した曲線は、共有秘密のサイズだけでなく、共有秘密を計算するための数学も制御します。選択された曲線は、曲線内の点がどのように表されるか、および曲線上の恒等点に対して何が起こるかを制御します。この仕様では、さまざまなカーブを使用できるようにしています。一連の曲線が表22で定義されています。計算された秘密を取得するために使用される計算は、ECDHアルゴリズムではなく、選択された曲線に基づいています。このため、曲線ごとに新しいアルゴリズムを定義する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o Computed Secret to Shared Secret: Once the computed secret is known, the resulting value needs to be converted to a byte string to run the KDF. The x-coordinate is used for all of the curves defined in this document. For curves X25519 and X448, the resulting value is used directly as it is a byte string of a known length. For the P-256, P-384, and P-521 curves, the x-coordinate is run through the I2OSP function defined in [RFC8017], using the same computation for n as is defined in Section 8.1.",
      "ja": "o 計算された秘密から共有秘密：計算された秘密がわかったら、KDFを実行するために、結果の値をバイト文字列に変換する必要があります。 x座標は、このドキュメントで定義されているすべての曲線に使用されます。曲線X25519およびX448の場合、結果の長さは既知の長さのバイト文字列であるため、結果の値が直接使用されます。 P-256、P-384、およびP-521曲線の場合、x座標は、セクション8.1で定義されているのと同じ計算を使用して、[RFC8017]で定義されているI2OSP関数を介して実行されます。"
    },
    {
      "indent": 3,
      "text": "o Ephemeral-Static or Static-Static: The key agreement process may be done using either a static or an ephemeral key for the sender's side. When using ephemeral keys, the sender MUST generate a new ephemeral key for every key agreement operation. The ephemeral key is placed in the 'ephemeral key' parameter and MUST be present for all algorithm identifiers that use ephemeral keys. When using static keys, the sender MUST either generate a new random value or create a unique value. For the KDFs used, this means either the 'salt' parameter for HKDF (Table 13) or the 'PartyU nonce' parameter for the context structure (Table 14) MUST be present (both can be present if desired). The value in the parameter MUST be unique for the pair of keys being used. It is acceptable to use a global counter that is incremented for every static-static operation and use the resulting value. When using static keys, the static key should be identified to the recipient. The static key can be identified either by providing the key ('static key') or by providing a key identifier for the static key ('static key id'). Both of these parameters are defined in Table 19.",
      "ja": "o エフェメラル静的または静的静的：キー合意プロセスは、送信者側の静的キーまたは一時キーのいずれかを使用して実行できます。エフェメラルキーを使用する場合、送信者はすべてのキー合意操作に対して新しいエフェメラルキーを生成する必要があります。エフェメラルキーは「エフェメラルキー」パラメータに配置され、エフェメラルキーを使用するすべてのアルゴリズム識別子に存在する必要があります。静的キーを使用する場合、送信者は新しいランダム値を生成するか、一意の値を作成する必要があります。使用されるKDFの場合、これは、HKDFの「salt」パラメーター（表13）またはコンテキスト構造の「PartyU nonce」パラメーター（表14）のいずれかが存在する必要があることを意味します（必要に応じて両方とも存在できます）。パラメータの値は、使用されているキーのペアに対して一意である必要があります。すべての静的/静的操作に対して増分されるグローバルカウンターを使用し、結果の値を使用することは許容されます。静的キーを使用する場合、静的キーは受信者に識別される必要があります。静的キーは、キー（「静的キー」）を提供するか、静的キーのキー識別子（「静的キーID」）を提供することによって識別できます。これらのパラメーターは両方とも表19で定義されています。"
    },
    {
      "indent": 3,
      "text": "o Key Derivation Algorithm: The result of an ECDH key agreement process does not provide a uniformly random secret. As such, it needs to be run through a KDF in order to produce a usable key. Processing the secret through a KDF also allows for the introduction of context material: how the key is going to be used and one-time material for static-static key agreement. All of the algorithms defined in this document use one of the HKDF algorithms defined in Section 11.1 with the context structure defined in Section 11.2.",
      "ja": "o 鍵導出アルゴリズム：ECDH鍵合意プロセスの結果は、一様にランダムな秘密を提供しません。そのため、使用可能なキーを生成するために、KDFを実行する必要があります。 KDFを介してシークレットを処理することで、コンテキストマテリアルの導入も可能になります。つまり、キーの使用方法と、静的/静的なキー合意のための1回限りのマテリアルです。このドキュメントで定義されているすべてのアルゴリズムは、セクション11.1で定義されているHKDFアルゴリズムの1つとセクション11.2で定義されているコンテキスト構造を使用しています。"
    },
    {
      "indent": 3,
      "text": "o Key Wrap Algorithm: No key wrap algorithm is used. This is represented in Table 18 as 'none'. The key size for the context structure is the content layer encryption algorithm size.",
      "ja": "o キーラップアルゴリズム：キーラップアルゴリズムは使用されません。これは、表18で「なし」として表されています。コンテキスト構造のキーサイズは、コンテンツレイヤー暗号化アルゴリズムのサイズです。"
    },
    {
      "indent": 3,
      "text": "The set of direct ECDH algorithms defined in this document are found in Table 18.",
      "ja": "このドキュメントで定義されている直接ECDHアルゴリズムのセットは、表18にあります。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+---------+------------+--------+---------------+\n| Name      | Value | KDF     | Ephemeral- | Key    | Description   |\n|           |       |         | Static     | Wrap   |               |\n+-----------+-------+---------+------------+--------+---------------+\n| ECDH-ES + | -25   | HKDF -  | yes        | none   | ECDH ES w/    |\n| HKDF-256  |       | SHA-256 |            |        | HKDF -        |\n|           |       |         |            |        | generate key  |\n|           |       |         |            |        | directly      |\n| ECDH-ES + | -26   | HKDF -  | yes        | none   | ECDH ES w/    |\n| HKDF-512  |       | SHA-512 |            |        | HKDF -        |\n|           |       |         |            |        | generate key  |\n|           |       |         |            |        | directly      |\n| ECDH-SS + | -27   | HKDF -  | no         | none   | ECDH SS w/    |\n| HKDF-256  |       | SHA-256 |            |        | HKDF -        |\n|           |       |         |            |        | generate key  |\n|           |       |         |            |        | directly      |\n| ECDH-SS + | -28   | HKDF -  | no         | none   | ECDH SS w/    |\n| HKDF-512  |       | SHA-512 |            |        | HKDF -        |\n|           |       |         |            |        | generate key  |\n|           |       |         |            |        | directly      |\n+-----------+-------+---------+------------+--------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 18: ECDH Algorithm Values",
      "ja": "表18：ECDHアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+----------+---------------------+--------------+\n| Name      | Label | Type     | Algorithm           | Description  |\n+-----------+-------+----------+---------------------+--------------+\n| ephemeral | -1    | COSE_Key | ECDH-ES+HKDF-256,   | Ephemeral    |\n| key       |       |          | ECDH-ES+HKDF-512,   | public key   |\n|           |       |          | ECDH-ES+A128KW,     | for the      |\n|           |       |          | ECDH-ES+A192KW,     | sender       |\n|           |       |          | ECDH-ES+A256KW      |              |\n| static    | -2    | COSE_Key | ECDH-SS+HKDF-256,   | Static       |\n| key       |       |          | ECDH-SS+HKDF-512,   | public key   |\n|           |       |          | ECDH-SS+A128KW,     | for the      |\n|           |       |          | ECDH-SS+A192KW,     | sender       |\n|           |       |          | ECDH-SS+A256KW      |              |\n| static    | -3    | bstr     | ECDH-SS+HKDF-256,   | Static       |\n| key id    |       |          | ECDH-SS+HKDF-512,   | public key   |\n|           |       |          | ECDH-SS+A128KW,     | identifier   |\n|           |       |          | ECDH-SS+A192KW,     | for the      |\n|           |       |          | ECDH-SS+A256KW      | sender       |\n+-----------+-------+----------+---------------------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 19: ECDH Algorithm Parameters",
      "ja": "表19：ECDHアルゴリズムのパラメーター"
    },
    {
      "indent": 3,
      "text": "This document defines these algorithms to be used with the curves P-256, P-384, P-521, X25519, and X448. Implementations MUST verify that the key type and curve are correct. Different curves are restricted to different key types. Implementations MUST verify that the curve and algorithm are appropriate for the entities involved.",
      "ja": "このドキュメントでは、これらのアルゴリズムを曲線P-256、P-384、P-521、X25519、およびX448で使用することを定義しています。実装では、キーのタイプと曲線が正しいことを確認する必要があります。異なるカーブは異なるキータイプに制限されます。実装は、曲線とアルゴリズムが関係するエンティティに適切であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'EC2' or 'OKP'.",
      "ja": "o 「kty」フィールドが存在しなければならず、「EC2」または「OKP」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the key agreement algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されている鍵合意アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'derive key' or 'derive bits' for the private key.",
      "ja": "o 「key_ops」フィールドが存在する場合は、秘密鍵の「派生鍵」または「派生ビット」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST be empty for the public key.",
      "ja": "o 「key_ops」フィールドが存在する場合、公開鍵の場合は空にする必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4.2. Security Considerations",
      "section_title": true,
      "ja": "12.4.2. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There is a method of checking that points provided from external entities are valid. For the 'EC2' key format, this can be done by checking that the x and y values form a point on the curve. For the 'OKP' format, there is no simple way to do point validation.",
      "ja": "外部エンティティから提供されたポイントが有効であることを確認する方法があります。 「EC2」キー形式の場合、これは、x値とy値が曲線上の点を形成していることを確認することで実行できます。 「OKP」形式の場合、ポイントの検証を行う簡単な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to requiring that the public keys of both entities be provided as part of the key derivation process (as recommended in Section 6.1 of [RFC7748]). This was not done as COSE is used in a store and forward format rather than in online key exchange. In order for this to be a problem, either the receiver public key has to be chosen maliciously or the sender has to be malicious. In either case, all security evaporates anyway.",
      "ja": "両方のエンティティの公開鍵を鍵導出プロセスの一部として提供するよう要求することを検討しました（[RFC7748]のセクション6.1で推奨）。 COSEはオンラインの鍵交換ではなくストアアンドフォワード形式で使用されるため、これは行われませんでした。これが問題になるためには、受信者の公開鍵が悪意を持って選択されるか、送信者が悪意を持つ必要があります。どちらの場合でも、すべてのセキュリティがとにかく蒸発します。"
    },
    {
      "indent": 3,
      "text": "A proof of possession of the private key associated with the public key is recommended when a key is moved from untrusted to trusted (either by the end user or by the entity that is responsible for making trust statements on keys).",
      "ja": "公開鍵に関連付けられた秘密鍵を所有していることの証明は、鍵が信頼できないものから信頼できるものに移動した場合に推奨されます（エンドユーザーまたは鍵に信頼ステートメントを作成する責任があるエンティティによって）。"
    },
    {
      "indent": 0,
      "text": "12.5. Key Agreement with Key Wrap",
      "section_title": true,
      "ja": "12.5. キーラップとの主な合意"
    },
    {
      "indent": 3,
      "text": "Key Agreement with Key Wrap uses a randomly generated CEK. The CEK is then encrypted using a key wrap algorithm and a key derived from the shared secret computed by the key agreement algorithm. The function for this would be:",
      "ja": "キーラップとのキーアグリーメントは、ランダムに生成されたCEKを使用します。次に、CEKは、鍵ラップアルゴリズムと、鍵合意アルゴリズムによって計算された共有秘密から導出された鍵を使用して暗号化されます。このための関数は次のとおりです。"
    },
    {
      "indent": 0,
      "text": " encryptedKey = KeyWrap(KDF(DH-Shared, context), CEK) The COSE_Encrypt structure for the recipient is organized as follows:",
      "ja": "encryptedKey = KeyWrap（KDF（DH-Shared、context）、CEK）受信者のCOSE_Encrypt構造は次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o The 'protected' field is fed into the KDF context structure.",
      "ja": "o 「保護された」フィールドは、KDFコンテキスト構造に入力されます。"
    },
    {
      "indent": 3,
      "text": "o The plaintext to be encrypted is the key from the next layer down (usually the content layer).",
      "ja": "o 暗号化されるプレーンテキストは、次のレイヤー（通常はコンテンツレイヤー）からのキーです。"
    },
    {
      "indent": 3,
      "text": "o The 'alg' parameter MUST be present in the layer.",
      "ja": "o 「alg」パラメーターはレイヤーに存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A parameter identifying the recipient's key SHOULD be present. A parameter identifying the sender's key SHOULD be present.",
      "ja": "o 受信者のキーを識別するパラメータが存在する必要があります。送信者のキーを識別するパラメータが存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.5.1. ECDH",
      "section_title": true,
      "ja": "12.5.1. そのように"
    },
    {
      "indent": 3,
      "text": "These algorithms are defined in Table 20.",
      "ja": "これらのアルゴリズムは、表20で定義されています。"
    },
    {
      "indent": 3,
      "text": "ECDH with Key Agreement is parameterized by the same parameters as for ECDH; see Section 12.4.1, with the following modifications:",
      "ja": "鍵合意を伴うECDHは、ECDHと同じパラメーターによってパラメーター化されます。セクション12.4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Key Wrap Algorithm: Any of the key wrap algorithms defined in Section 12.2.1 are supported. The size of the key used for the key wrap algorithm is fed into the KDF. The set of identifiers are found in Table 20.",
      "ja": "o キーラップアルゴリズム：セクション12.2.1で定義されているすべてのキーラップアルゴリズムがサポートされています。キーラップアルゴリズムに使用されるキーのサイズは、KDFに送られます。識別子のセットは表20にあります。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+---------+------------+--------+---------------+\n| Name      | Value | KDF     | Ephemeral- | Key    | Description   |\n|           |       |         | Static     | Wrap   |               |\n+-----------+-------+---------+------------+--------+---------------+\n| ECDH-ES + | -29   | HKDF -  | yes        | A128KW | ECDH ES w/    |\n| A128KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 128-bit key   |\n|           |       |         |            |        |               |\n| ECDH-ES + | -30   | HKDF -  | yes        | A192KW | ECDH ES w/    |\n| A192KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 192-bit key   |\n|           |       |         |            |        |               |\n| ECDH-ES + | -31   | HKDF -  | yes        | A256KW | ECDH ES w/    |\n| A256KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 256-bit key   |\n|           |       |         |            |        |               |\n| ECDH-SS + | -32   | HKDF -  | no         | A128KW | ECDH SS w/    |\n| A128KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 128-bit key   |\n|           |       |         |            |        |               |\n| ECDH-SS + | -33   | HKDF -  | no         | A192KW | ECDH SS w/    |\n| A192KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 192-bit key   |\n|           |       |         |            |        |               |\n| ECDH-SS + | -34   | HKDF -  | no         | A256KW | ECDH SS w/    |\n| A256KW    |       | SHA-256 |            |        | Concat KDF    |\n|           |       |         |            |        | and AES Key   |\n|           |       |         |            |        | Wrap w/       |\n|           |       |         |            |        | 256-bit key   |\n+-----------+-------+---------+------------+--------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 20: ECDH Algorithm Values with Key Wrap",
      "ja": "表20：キーラップによるECDHアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCODEキーを使用すると、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o The 'kty' field MUST be present, and it MUST be 'EC2' or 'OKP'.",
      "ja": "o 「kty」フィールドが存在しなければならず、「EC2」または「OKP」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the 'alg' field is present, it MUST match the key agreement algorithm being used.",
      "ja": "o 「alg」フィールドが存在する場合、使用されている鍵合意アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST include 'derive key' or 'derive bits' for the private key.",
      "ja": "o 「key_ops」フィールドが存在する場合は、秘密鍵の「派生鍵」または「派生ビット」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the 'key_ops' field is present, it MUST be empty for the public key.",
      "ja": "o 「key_ops」フィールドが存在する場合、公開鍵の場合は空にする必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Key Object Parameters",
      "section_title": true,
      "ja": "13. 主要なオブジェクトパラメータ"
    },
    {
      "indent": 3,
      "text": "The COSE_Key object defines a way to hold a single key object. It is still required that the members of individual key types be defined. This section of the document is where we define an initial set of members for specific key types.",
      "ja": "COSE_Keyオブジェクトは、単一のキーオブジェクトを保持する方法を定義します。個々のキータイプのメンバーを定義する必要があります。ドキュメントのこのセクションでは、特定のキータイプのメンバーの初期セットを定義します。"
    },
    {
      "indent": 3,
      "text": "For each of the key types, we define both public and private members. The public members are what is transmitted to others for their usage. Private members allow for the archival of keys by individuals. However, there are some circumstances in which private keys may be distributed to entities in a protocol. Examples include: entities that have poor random number generation, centralized key creation for multi-cast type operations, and protocols in which a shared secret is used as a bearer token for authorization purposes.",
      "ja": "キーの種類ごとに、パブリックメンバーとプライベートメンバーの両方を定義します。パブリックメンバーは、その使用のために他のユーザーに送信されるものです。プライベートメンバーは、個人によるキーのアーカイブを許可します。ただし、プライベートキーがプロトコルのエンティティに配布される場合があります。例としては、乱数の生成が不十分なエンティティ、マルチキャストタイプの操作用の集中型のキー作成、共有シークレットが認証目的のベアラートークンとして使用されるプロトコルなどがあります。"
    },
    {
      "indent": 3,
      "text": "Key types are identified by the 'kty' member of the COSE_Key object. In this document, we define four values for the member:",
      "ja": "キータイプは、COSE_Keyオブジェクトの「kty」メンバーによって識別されます。このドキュメントでは、メンバーに4つの値を定義します。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------+-----------------------------------------------+\n| Name      | Value | Description                                   |\n+-----------+-------+-----------------------------------------------+\n| OKP       | 1     | Octet Key Pair                                |\n| EC2       | 2     | Elliptic Curve Keys w/ x- and y-coordinate    |\n|           |       | pair                                          |\n| Symmetric | 4     | Symmetric Keys                                |\n| Reserved  | 0     | This value is reserved                        |\n+-----------+-------+-----------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Table 21: Key Type Values",
      "ja": "表21：キータイプの値"
    },
    {
      "indent": 0,
      "text": "13.1. Elliptic Curve Keys",
      "section_title": true,
      "ja": "13.1. 楕円曲線キー"
    },
    {
      "indent": 3,
      "text": "Two different key structures are defined for elliptic curve keys. One version uses both an x-coordinate and a y-coordinate, potentially with point compression ('EC2'). This is the traditional EC point representation that is used in [RFC5480]. The other version uses only the x-coordinate as the y-coordinate is either to be recomputed or not needed for the key agreement operation ('OKP').",
      "ja": "楕円曲線キーには、2つの異なるキー構造が定義されています。 1つのバージョンは、x座標とy座標の両方を使用し、場合によってはポイント圧縮（ 'EC2'）を使用します。これは、[RFC5480]で使用される従来のECポイント表現です。他のバージョンは、y座標が再計算されるか、または鍵合意操作（ 'OKP'）に必要ないため、x座標のみを使用します。"
    },
    {
      "indent": 3,
      "text": "Applications MUST check that the curve and the key type are consistent and reject a key if they are not.",
      "ja": "アプリケーションは、カーブとキータイプが一致していることを確認し、一致していない場合はキーを拒否する必要があります。"
    },
    {
      "indent": 4,
      "text": "+---------+-------+----------+------------------------------------+\n| Name    | Value | Key Type | Description                        |\n+---------+-------+----------+------------------------------------+\n| P-256   | 1     | EC2      | NIST P-256 also known as secp256r1 |\n| P-384   | 2     | EC2      | NIST P-384 also known as secp384r1 |\n| P-521   | 3     | EC2      | NIST P-521 also known as secp521r1 |\n| X25519  | 4     | OKP      | X25519 for use w/ ECDH only        |\n| X448    | 5     | OKP      | X448 for use w/ ECDH only          |\n| Ed25519 | 6     | OKP      | Ed25519 for use w/ EdDSA only      |\n| Ed448   | 7     | OKP      | Ed448 for use w/ EdDSA only        |\n+---------+-------+----------+------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Table 22: Elliptic Curves",
      "ja": "表22：楕円曲線"
    },
    {
      "indent": 0,
      "text": "13.1.1. Double Coordinate Curves",
      "section_title": true,
      "ja": "13.1.1. 二重座標曲線"
    },
    {
      "indent": 3,
      "text": "The traditional way of sending ECs has been to send either both the x-coordinate and y-coordinate or the x-coordinate and a sign bit for the y-coordinate. The latter encoding has not been recommended in the IETF due to potential IPR issues. However, for operations in constrained environments, the ability to shrink a message by not sending the y-coordinate is potentially useful.",
      "ja": "ECを送信する従来の方法は、x座標とy座標の両方、またはx座標とy座標の符号ビットのいずれかを送信することでした。後者のエンコーディングは、潜在的なIPRの問題のため、IETFでは推奨されていません。ただし、制約のある環境での操作では、y座標を送信しないことでメッセージを縮小できる機能が役立つ可能性があります。"
    },
    {
      "indent": 3,
      "text": "For EC keys with both coordinates, the 'kty' member is set to 2 (EC2). The key parameters defined in this section are summarized in Table 23. The members that are defined for this key type are:",
      "ja": "両方の座標を持つECキーの場合、「kty」メンバーは2（EC2）に設定されます。このセクションで定義されている主要なパラメーターは、表23に要約されています。このキーの種類に対して定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv: This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 22. Other curves may be registered in the future, and private curves can be used as well.",
      "ja": "crv：これには、キーで使用される曲線の識別子が含まれます。このドキュメントでこのキータイプに対して定義されている曲線は、表22にあります。将来、他の曲線が登録される可能性があり、プライベート曲線も使用できます。"
    },
    {
      "indent": 3,
      "text": "x: This contains the x-coordinate for the EC point. The integer is converted to an octet string as defined in [SEC1]. Leading zero octets MUST be preserved.",
      "ja": "x：ECポイントのx座標が含まれます。整数は、[SEC1]で定義されているオクテット文字列に変換されます。先頭のゼロオクテットは保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "y: This contains either the sign bit or the value of the y-coordinate for the EC point. When encoding the value y, the integer is converted to an octet string (as defined in [SEC1]) and encoded as a CBOR bstr. Leading zero octets MUST be preserved. The compressed point encoding is also supported. Compute the sign bit as laid out in the Elliptic-Curve-Point-to-Octet-String Conversion function of [SEC1]. If the sign bit is zero, then encode y as a CBOR false value; otherwise, encode y as a CBOR true value. The encoding of the infinity point is not supported.",
      "ja": "y：これには、ECビットの符号ビットまたはy座標の値のいずれかが含まれます。値yをエンコードするとき、整数はオクテット文字列（[SEC1]で定義されているとおり）に変換され、CBOR bstrとしてエンコードされます。先頭のゼロオクテットは保持する必要があります。圧縮ポイントエンコーディングもサポートされています。 [SEC1]の楕円曲線ポイントからオクテット文字列への変換関数でレイアウトされた符号ビットを計算します。符号ビットがゼロの場合、yをCBOR偽値としてエンコードします。それ以外の場合は、yをCBORの真の値としてエンコードします。無限遠点のエンコードはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "d: This contains the private key.",
      "ja": "d：これには秘密鍵が含まれます。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that 'crv', 'x', and 'y' be present in the structure. For private keys, it is REQUIRED that 'crv' and 'd' be present in the structure. For private keys, it is RECOMMENDED that 'x' and 'y' also be present, but they can be recomputed from the required elements and omitting them saves on space.",
      "ja": "公開鍵の場合、「crv」、「x」、および「y」が構造内に存在することが必要です。秘密鍵の場合、「crv」と「d」が構造に存在することが必要です。秘密鍵の場合、「x」と「y」も存在することをお勧めしますが、必要な要素から再計算して、省くとスペースを節約できます。"
    },
    {
      "indent": 3,
      "text": "+-------+------+-------+--------+-----------------------------------+\n| Key   | Name | Label | CBOR   | Description                       |\n| Type  |      |       | Type   |                                   |\n+-------+------+-------+--------+-----------------------------------+\n| 2     | crv  | -1    | int /  | EC identifier - Taken from the    |\n|       |      |       | tstr   | \"COSE Elliptic Curves\" registry   |\n| 2     | x    | -2    | bstr   | x-coordinate                      |\n| 2     | y    | -3    | bstr / | y-coordinate                      |\n|       |      |       | bool   |                                   |\n| 2     | d    | -4    | bstr   | Private key                       |\n+-------+------+-------+--------+-----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 23: EC Key Parameters",
      "ja": "表23：ECキーパラメータ"
    },
    {
      "indent": 0,
      "text": "13.2. Octet Key Pair",
      "section_title": true,
      "ja": "13.2. オクテットキーペア"
    },
    {
      "indent": 3,
      "text": "A new key type is defined for Octet Key Pairs (OKP). Do not assume that keys using this type are elliptic curves. This key type could be used for other curve types (for example, mathematics based on hyper-elliptic surfaces).",
      "ja": "Octet Key Pairs（OKP）に新しいキータイプが定義されています。このタイプを使用するキーが楕円曲線であると想定しないでください。このキータイプは、他のカーブタイプ（たとえば、超楕円曲面に基づく数学）に使用できます。"
    },
    {
      "indent": 3,
      "text": "The key parameters defined in this section are summarized in Table 24. The members that are defined for this key type are:",
      "ja": "このセクションで定義されている主要なパラメーターは、表24に要約されています。このキーの種類に対して定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv: This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 22. Other curves may be registered in the future and private curves can be used as well.",
      "ja": "crv：これには、キーで使用される曲線の識別子が含まれます。このドキュメントでこのキータイプに対して定義されているカーブは、表22にあります。将来、他のカーブが登録され、プライベートカーブを使用することもできます。"
    },
    {
      "indent": 3,
      "text": "x: This contains the x-coordinate for the EC point. The octet string represents a little-endian encoding of x.",
      "ja": "x：ECポイントのx座標が含まれます。オクテット文字列は、xのリトルエンディアンエンコーディングを表します。"
    },
    {
      "indent": 3,
      "text": "d: This contains the private key.",
      "ja": "d：これには秘密鍵が含まれます。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that 'crv' and 'x' be present in the structure. For private keys, it is REQUIRED that 'crv' and 'd' be present in the structure. For private keys, it is RECOMMENDED that 'x' also be present, but it can be recomputed from the required elements and omitting it saves on space.",
      "ja": "公開鍵の場合、「crv」と「x」が構造に存在する必要があります。秘密鍵の場合、「crv」と「d」が構造に存在することが必要です。秘密鍵の場合、「x」も存在することをお勧めしますが、必要な要素から再計算して、省くとスペースを節約できます。"
    },
    {
      "indent": 3,
      "text": "+------+-------+-------+--------+-----------------------------------+\n| Name | Key   | Label | Type   | Description                       |\n|      | Type  |       |        |                                   |\n+------+-------+-------+--------+-----------------------------------+\n| crv  | 1     | -1    | int /  | EC identifier - Taken from the    |\n|      |       |       | tstr   | \"COSE Key Common Parameters\"      |\n|      |       |       |        | registry                          |\n| x    | 1     | -2    | bstr   | x-coordinate                      |\n| d    | 1     | -4    | bstr   | Private key                       |\n+------+-------+-------+--------+-----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 24: Octet Key Pair Parameters",
      "ja": "表24：オクテットキーペアのパラメーター"
    },
    {
      "indent": 0,
      "text": "13.3. Symmetric Keys",
      "section_title": true,
      "ja": "13.3. 対称キー"
    },
    {
      "indent": 3,
      "text": "Occasionally it is required that a symmetric key be transported between entities. This key structure allows for that to happen.",
      "ja": "対称鍵をエンティティ間で転送する必要がある場合があります。この重要な構造により、それが可能になります。"
    },
    {
      "indent": 3,
      "text": "For symmetric keys, the 'kty' member is set to 4 ('Symmetric'). The member that is defined for this key type is:",
      "ja": "対称鍵の場合、「kty」メンバーは4（「対称」）に設定されます。このキータイプに定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "k: This contains the value of the key.",
      "ja": "k：これにはキーの値が含まれます。"
    },
    {
      "indent": 3,
      "text": "This key structure does not have a form that contains only public members. As it is expected that this key structure is going to be transmitted, care must be taken that it is never transmitted accidentally or insecurely. For symmetric keys, it is REQUIRED that 'k' be present in the structure.",
      "ja": "このキー構造には、パブリックメンバーのみを含むフォームはありません。このキー構造が送信されることが予想されるため、誤ってまたは安全に送信されないように注意する必要があります。対称鍵の場合、構造に「k」が存在する必要があります。"
    },
    {
      "indent": 13,
      "text": "+------+----------+-------+------+-------------+\n| Name | Key Type | Label | Type | Description |\n+------+----------+-------+------+-------------+\n| k    | 4        | -1    | bstr | Key Value   |\n+------+----------+-------+------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 25: Symmetric Key Parameters",
      "ja": "表25：対称キーパラメータ"
    },
    {
      "indent": 0,
      "text": "14. CBOR Encoder Restrictions",
      "section_title": true,
      "ja": "14. CBORエンコーダーの制限"
    },
    {
      "indent": 3,
      "text": "There has been an attempt to limit the number of places where the document needs to impose restrictions on how the CBOR Encoder needs to work. We have managed to narrow it down to the following restrictions:",
      "ja": "ドキュメントがCBORエンコーダーの動作方法に制限を課す必要がある場所の数を制限する試みがありました。次の制限に絞り込むことができました。"
    },
    {
      "indent": 3,
      "text": "o The restriction applies to the encoding of the Sig_structure, the Enc_structure, and the MAC_structure.",
      "ja": "o この制限は、Sig_structure、Enc_structure、およびMAC_structureのエンコードに適用されます。"
    },
    {
      "indent": 3,
      "text": "o The rules for \"Canonical CBOR\" (Section 3.9 of RFC 7049) MUST be used in these locations. The main rule that needs to be enforced is that all lengths in these structures MUST be encoded such that they are using definite lengths, and the minimum length encoding is used.",
      "ja": "o これらの場所では、「Canonical CBOR」（RFC 7049のセクション3.9）のルールを使用する必要があります。実施する必要のある主なルールは、これらの構造体のすべての長さは、それらが明確な長さを使用するようにエンコードする必要があり、最小長のエンコーディングが使用されることです。"
    },
    {
      "indent": 3,
      "text": "o Applications MUST NOT generate messages with the same label used twice as a key in a single map. Applications MUST NOT parse and process messages with the same label used twice as a key in a single map. Applications can enforce the parse and process requirement by using parsers that will fail the parse step or by using parsers that will pass all keys to the application, and the application can perform the check for duplicate keys.",
      "ja": "o アプリケーションは、単一のマップでキーとして2回使用された同じラベルのメッセージを生成してはなりません（MUST NOT）。アプリケーションは、1つのマップでキーとして2回使用された同じラベルのメッセージを解析および処理してはなりません（MUST NOT）。アプリケーションは、解析ステップに失敗するパーサーを使用するか、すべてのキーをアプリケーションに渡すパーサーを使用することにより、解析と処理の要件を適用でき、アプリケーションは重複キーのチェックを実行できます。"
    },
    {
      "indent": 0,
      "text": "15. Application Profiling Considerations",
      "section_title": true,
      "ja": "15. アプリケーションプロファイリングに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is designed to provide a set of security services, but not implementation requirements for specific usage. The interoperability requirements are provided for how each of the individual services are used and how the algorithms are to be used for interoperability. The requirements about which algorithms and which services are needed are deferred to each application.",
      "ja": "このドキュメントは、一連のセキュリティサービスを提供するように設計されていますが、特定の使用法の実装要件ではありません。相互運用性の要件は、個々のサービスのそれぞれの使用方法と、相互運用性のためのアルゴリズムの使用方法について提供されています。どのアルゴリズムとどのサービスが必要かに関する要件は、各アプリケーションに委ねられます。"
    },
    {
      "indent": 3,
      "text": "An example of a profile can be found in [OSCOAP] where two profiles are being developed. One is for carrying content by itself, and the other is for carrying content in combination with CoAP headers.",
      "ja": "プロファイルの例は、2つのプロファイルが開発されている[OSCOAP]にあります。 1つはコンテンツを単独で運ぶためのもので、もう1つはCoAPヘッダーと組み合わせてコンテンツを運ぶためのものです。"
    },
    {
      "indent": 3,
      "text": "It is intended that a profile of this document be created that defines the interoperability requirements for that specific application. This section provides a set of guidelines and topics that need to be considered when profiling this document.",
      "ja": "特定のアプリケーションの相互運用性要件を定義するこのドキュメントのプロファイルを作成することを目的としています。このセクションでは、このドキュメントをプロファイリングするときに考慮する必要がある一連のガイドラインとトピックを提供します。"
    },
    {
      "indent": 3,
      "text": "o Applications need to determine the set of messages defined in this document that they will be using. The set of messages corresponds fairly directly to the set of security services that are needed and to the security levels needed.",
      "ja": "o アプリケーションは、このドキュメントで定義されている、使用する一連のメッセージを決定する必要があります。メッセージのセットは、必要なセキュリティサービスのセットと必要なセキュリティレベルにかなり直接対応しています。"
    },
    {
      "indent": 3,
      "text": "o Applications may define new header parameters for a specific purpose. Applications will often times select specific header parameters to use or not to use. For example, an application would normally state a preference for using either the IV or the Partial IV parameter. If the Partial IV parameter is specified, then the application would also need to define how the fixed portion of the IV would be determined.",
      "ja": "o アプリケーションは、特定の目的のために新しいヘッダーパラメータを定義できます。多くの場合、アプリケーションは特定のヘッダーパラメータを選択して、使用するかしないかを選択します。たとえば、アプリケーションは通常、IVパラメータまたはPartial IVパラメータのいずれかを使用するための設定を記述します。 Partial IVパラメータが指定されている場合、アプリケーションは、IVの固定部分がどのように決定されるかを定義する必要もあります。"
    },
    {
      "indent": 3,
      "text": "o When applications use externally defined authenticated data, they need to define how that data is encoded. This document assumes that the data will be provided as a byte stream. More information can be found in Section 4.3.",
      "ja": "o アプリケーションは、外部で定義された認証済みデータを使用する場合、そのデータのエンコード方法を定義する必要があります。このドキュメントでは、データがバイトストリームとして提供されることを前提としています。詳細については、セクション4.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Applications need to determine the set of security algorithms that are to be used. When selecting the algorithms to be used as the mandatory-to-implement set, consideration should be given to choosing different types of algorithms when two are chosen for a specific purpose. An example of this would be choosing HMAC-SHA512 and AES-CMAC as different MAC algorithms; the construction is vastly different between these two algorithms. This means that a weakening of one algorithm would be unlikely to lead to a weakening of the other algorithms. Of course, these algorithms do not provide the same level of security and thus may not be comparable for the desired security functionality.",
      "ja": "o アプリケーションは、使用される一連のセキュリティアルゴリズムを決定する必要があります。実装に必須のセットとして使用するアルゴリズムを選択する場合、特定の目的で2つのアルゴリズムを選択する場合は、異なるタイプのアルゴリズムを選択することを検討する必要があります。この例として、HMAC-SHA512とAES-CMACを異なるMACアルゴリズムとして選択する方法があります。これらの2つのアルゴリズムでは、構成が大きく異なります。これは、あるアルゴリズムの弱化が他のアルゴリズムの弱化につながる可能性が低いことを意味します。もちろん、これらのアルゴリズムは同じレベルのセキュリティを提供しないため、必要なセキュリティ機能については比較できない場合があります。"
    },
    {
      "indent": 3,
      "text": "o Applications may need to provide some type of negotiation or discovery method if multiple algorithms or message structures are permitted. The method can be as simple as requiring preconfiguration of the set of algorithms to providing a discovery method built into the protocol. S/MIME provided a number of different ways to approach the problem that applications could follow:",
      "ja": "o 複数のアルゴリズムまたはメッセージ構造が許可されている場合、アプリケーションは、ある種のネゴシエーションまたは検出方法を提供する必要がある場合があります。この方法は、プロトコルに組み込まれたディスカバリー方法を提供するために、アルゴリズムのセットの事前構成を必要とするほど単純なものにすることができます。 S / MIMEは、アプリケーションが従う可能性がある問題に取り組むためのさまざまな方法を提供しました。"
    },
    {
      "indent": 6,
      "text": "* Advertising in the message (S/MIME capabilities) [RFC5751].",
      "ja": "* メッセージのアドバタイズ（S / MIME機能）[RFC5751]。"
    },
    {
      "indent": 6,
      "text": "* Advertising in the certificate (capabilities extension) [RFC4262].",
      "ja": "* 証明書の広告（機能拡張）[RFC4262]。"
    },
    {
      "indent": 6,
      "text": "* Minimum requirements for the S/MIME, which have been updated over time [RFC2633] [RFC5751] (note that [RFC2633] has been obsoleted by [RFC5751]).",
      "ja": "* S / MIMEの最小要件は、時間の経過とともに更新されています[RFC2633] [RFC5751]（[RFC2633]は[RFC5751]に置き換えられていることに注意してください）。"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "ja": "16. IANAに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "16.1. CBOR Tag Assignment",
      "section_title": true,
      "ja": "16.1. CBORタグの割り当て"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the following tags from the \"CBOR Tags\" registry. The tags for COSE_Sign1, COSE_Encrypt0, and COSE_Mac0 were assigned in the 1 to 23 value range (one byte long when encoded). The tags for COSE_Sign, COSE_Encrypt, and COSE_Mac were assigned in the 24 to 255 value range (two bytes long when encoded).",
      "ja": "IANAは、「CBORタグ」レジストリから次のタグを割り当てました。 COSE_Sign1、COSE_Encrypt0、およびCOSE_Mac0のタグは、1〜23の値の範囲で割り当てられました（エンコード時は1バイト長）。 COSE_Sign、COSE_Encrypt、およびCOSE_Macのタグは、24〜255の値の範囲（エンコードされた場合、2バイト長）で割り当てられました。"
    },
    {
      "indent": 3,
      "text": "The tags assigned are in Table 1.",
      "ja": "割り当てられたタグは、表1にあります。"
    },
    {
      "indent": 0,
      "text": "16.2. COSE Header Parameters Registry",
      "section_title": true,
      "ja": "16.2. COSEヘッダーパラメータレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Header Parameters\". The registry has been created to use the \"Expert Review Required\" registration procedure [RFC8126]. Guidelines for the experts are provided in Section 16.11. It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.",
      "ja": "IANAは、「COSEヘッダーパラメータ」というタイトルの新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要」の登録手順[RFC8126]を使用するために作成されました。専門家向けのガイドラインはセクション16.11に記載されています。専門家によるレビューに加えて、レジストリの一部には、仕様（場合によってはStandards Track RFC）も提供する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are:",
      "ja": "レジストリの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: The name is present to make it easier to refer to and discuss the registration entry. The value is not used in the protocol. Names are to be unique in the table.",
      "ja": "名前：名前は、登録エントリの参照と議論を容易にするために存在します。この値はプロトコルでは使用されません。名前はテーブル内で一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "Label: This is the value used for the label. The label can be either an integer or a string. Registration in the table is based on the value of the label requested. Integer values between 1 and 255 and strings of length 1 are designated as \"Standards Action\". Integer values from 256 to 65535 and strings of length 2 are designated as \"Specification Required\". Integer values of greater than 65535 and strings of length greater than 2 are designated as \"Expert Review\". Integer values in the range -1 to -65536 are \"delegated to the COSE Header Algorithm Parameters registry\". Integer values less than -65536 are marked as private use.",
      "ja": "ラベル：これはラベルに使用される値です。ラベルは整数または文字列のいずれかです。テーブルへの登録は、要求されたラベルの値に基づいています。 1〜255の整数値と長さが1の文字列は、「標準アクション」として指定されます。 256〜65535の整数値と長さ2の文字列は、「指定が必要」として指定されます。 65535を超える整数値と2を超える長さの文字列は、「エキスパートレビュー」として指定されます。 -1〜-65536の範囲の整数値は、「COSEヘッダーアルゴリズムパラメーターレジストリに委任されます」。 -65536未満の整数値は、私的使用としてマークされます。"
    },
    {
      "indent": 3,
      "text": "Value Type: This contains the CBOR type for the value portion of the label.",
      "ja": "値タイプ：これには、ラベルの値部分のCBORタイプが含まれます。"
    },
    {
      "indent": 3,
      "text": "Value Registry: This contains a pointer to the registry used to contain values where the set is limited.",
      "ja": "値レジストリ：これには、セットが制限されている値を含めるために使用されるレジストリへのポインタが含まれています。"
    },
    {
      "indent": 3,
      "text": "Description: This contains a brief description of the header field.",
      "ja": "説明：ヘッダーフィールドの簡単な説明が含まれます。"
    },
    {
      "indent": 3,
      "text": "Reference: This contains a pointer to the specification defining the header field (where public).",
      "ja": "参照：これには、ヘッダーフィールド（パブリックの場合）を定義する仕様へのポインターが含まれます。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry can be found in Tables 2 and 27. All of the entries in the \"References\" column of this registry point to this document.",
      "ja": "レジストリの初期の内容は、表2および27にあります。このレジストリの「参照」列のすべてのエントリは、このドキュメントを指しています。"
    },
    {
      "indent": 3,
      "text": "Additionally, the label of 0 is to be marked as 'Reserved'.",
      "ja": "さらに、0のラベルは「予約済み」としてマークされます。"
    },
    {
      "indent": 0,
      "text": "16.3. COSE Header Algorithm Parameters Registry",
      "section_title": true,
      "ja": "16.3. COSEヘッダーアルゴリズムパラメーターレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Header Algorithm Parameters\". The registry uses the \"Expert Review Required\" registration procedure. Expert review guidelines are provided in Section 16.11.",
      "ja": "IANAは、「COSEヘッダーアルゴリズムパラメーター」という新しいレジストリを作成しました。レジストリは「エキスパートレビューが必要です」登録手順を使用します。専門家によるレビューのガイドラインは、セクション16.11に記載されています。"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are:",
      "ja": "レジストリの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: The name is present to make it easier to refer to and discuss the registration entry. The value is not used in the protocol.",
      "ja": "名前：名前は、登録エントリの参照と議論を容易にするために存在します。この値はプロトコルでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Algorithm: The algorithm(s) that this registry entry is used for. This value is taken from the \"COSE Algorithms\" registry. Multiple algorithms can be specified in this entry. For the table, the algorithm/label pair MUST be unique.",
      "ja": "アルゴリズム：このレジストリエントリが使用されるアルゴリズム。この値は、「COSEアルゴリズム」レジストリから取得されます。このエントリでは複数のアルゴリズムを指定できます。テーブルの場合、アルゴリズムとラベルのペアは一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "Label: This is the value used for the label. The label is an integer in the range of -1 to -65536.",
      "ja": "ラベル：これはラベルに使用される値です。ラベルは、-1〜-65536の範囲の整数です。"
    },
    {
      "indent": 3,
      "text": "Type: This contains the CBOR type for the value portion of the label.",
      "ja": "タイプ：これには、ラベルの値部分のCBORタイプが含まれます。"
    },
    {
      "indent": 3,
      "text": "Description: This contains a brief description of the header field.",
      "ja": "説明：ヘッダーフィールドの簡単な説明が含まれます。"
    },
    {
      "indent": 3,
      "text": "Reference: This contains a pointer to the specification defining the header field (where public).",
      "ja": "参照：これには、ヘッダーフィールド（パブリックの場合）を定義する仕様へのポインターが含まれます。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry can be found in Tables 13, 14, and 19. All of the entries in the \"References\" column of this registry point to this document.",
      "ja": "レジストリの最初の内容は、表13、14、および19にあります。このレジストリの「参照」列のすべてのエントリは、このドキュメントを指しています。"
    },
    {
      "indent": 0,
      "text": "16.4. COSE Algorithms Registry",
      "section_title": true,
      "ja": "16.4. THINGSアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Algorithms\". The registry has been created to use the \"Expert Review Required\" registration procedure. Guidelines for the experts are provided in",
      "ja": "IANAは、「COSEアルゴリズム」という新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要です」登録手順を使用するために作成されました。専門家向けのガイドラインは、"
    },
    {
      "indent": 3,
      "text": "Section 16.11. It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.",
      "ja": "セクション16.11専門家によるレビューに加えて、レジストリの一部には、仕様（場合によってはStandards Track RFC）も提供する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are:",
      "ja": "レジストリの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: A value that can be used to identify an algorithm in documents for easier comprehension. The name SHOULD be unique. However, the 'Value' field is what is used to identify the algorithm, not the 'name' field.",
      "ja": "名前：理解を容易にするためにドキュメント内のアルゴリズムを識別するために使用できる値。名前は一意である必要があります。ただし、「値」フィールドはアルゴリズムの識別に使用されるものであり、「名前」フィールドではありません。"
    },
    {
      "indent": 3,
      "text": "Value: The value to be used to identify this algorithm. Algorithm values MUST be unique. The value can be a positive integer, a negative integer, or a string. Integer values between -256 and 255 and strings of length 1 are designated as \"Standards Action\". Integer values from -65536 to 65535 and strings of length 2 are designated as \"Specification Required\". Integer values greater than 65535 and strings of length greater than 2 are designated as \"Expert Review\". Integer values less than -65536 are marked as private use.",
      "ja": "値：このアルゴリズムを識別するために使用される値。アルゴリズム値は一意である必要があります。値は正の整数、負の整数、または文字列です。 -256から255までの整数値と長さ1の文字列は、「標準アクション」として指定されます。 -65536〜65535の整数値と長さ2の文字列は、「指定が必要」として指定されます。 65535より大きい整数値と2より大きい長さの文字列は、「エキスパートレビュー」として指定されます。 -65536未満の整数値は、私的使用としてマークされます。"
    },
    {
      "indent": 3,
      "text": "Description: A short description of the algorithm.",
      "ja": "説明：アルゴリズムの短い説明。"
    },
    {
      "indent": 3,
      "text": "Reference: A document where the algorithm is defined (if publicly available).",
      "ja": "参照：アルゴリズムが定義されているドキュメント（公開されている場合）。"
    },
    {
      "indent": 3,
      "text": "Recommended: Does the IETF have a consensus recommendation to use the algorithm? The legal values are 'Yes', 'No', and 'Deprecated'.",
      "ja": "推奨：IETFには、アルゴリズムを使用するためのコンセンサス推奨事項がありますか？有効な値は、「はい」、「いいえ」、および「非推奨」です。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry can be found in Tables 5, 6, 7, 8, 9, 10, 11, 15, 16, 17, 18, and 20. All of the entries in the \"References\" column of this registry point to this document. All of the entries in the \"Recommended\" column are set to \"Yes\".",
      "ja": "レジストリの初期の内容は、表5、6、7、8、9、10、11、15、16、17、18、および20にあります。このレジストリポイントの「参照」列のすべてのエントリこのドキュメントに。 「推奨」列のエントリはすべて「はい」に設定されています。"
    },
    {
      "indent": 3,
      "text": "Additionally, the label of 0 is to be marked as 'Reserved'.",
      "ja": "さらに、0のラベルは「予約済み」としてマークされます。"
    },
    {
      "indent": 3,
      "text": "NOTE: The assignment of algorithm identifiers in this document was done so that positive numbers were used for the first layer objects (COSE_Sign, COSE_Sign1, COSE_Encrypt, COSE_Encrypt0, COSE_Mac, and COSE_Mac0). Negative numbers were used for second layer objects (COSE_Signature and COSE_recipient). Expert reviewers should consider this practice, but are not expected to be restricted by this precedent.",
      "ja": "注：このドキュメントのアルゴリズム識別子の割り当ては、最初のレイヤーオブジェクト（COSE_Sign、COSE_Sign1、COSE_Encrypt、COSE_Encrypt0、COSE_Mac、およびCOSE_Mac0）に正の数が使用されるように行われました。 2番目のレイヤーオブジェクト（COSE_SignatureおよびCOSE_recipient）には負の数が使用されました。専門家の査読者はこの慣行を検討する必要がありますが、この先例によって制限されることは期待されていません。"
    },
    {
      "indent": 0,
      "text": "16.5. COSE Key Common Parameters Registry",
      "section_title": true,
      "ja": "16.5. COSEキーの共通パラメーターレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Key Common Parameters\". The registry has been created to use the \"Expert Review Required\" registration procedure. Guidelines for the experts are provided in Section 16.11. It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.",
      "ja": "IANAは、「COSE Key Common Parameters」という新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要です」登録手順を使用するために作成されました。専門家向けのガイドラインはセクション16.11に記載されています。専門家によるレビューに加えて、レジストリの一部には、仕様（場合によってはStandards Track RFC）も提供する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are:",
      "ja": "レジストリの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: This is a descriptive name that enables easier reference to the item. It is not used in the encoding.",
      "ja": "名前：これは、アイテムを簡単に参照できるようにする説明的な名前です。エンコードでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Label: The value to be used to identify this algorithm. Key map labels MUST be unique. The label can be a positive integer, a negative integer, or a string. Integer values between 0 and 255 and strings of length 1 are designated as \"Standards Action\". Integer values from 256 to 65535 and strings of length 2 are designated as \"Specification Required\". Integer values of greater than 65535 and strings of length greater than 2 are designated as \"Expert Review\". Integer values in the range -65536 to -1 are \"used for key parameters specific to a single algorithm delegated to the COSE Key Type Parameters registry\". Integer values less than -65536 are marked as private use.",
      "ja": "ラベル：このアルゴリズムを識別するために使用される値。キーマップラベルは一意である必要があります。ラベルは、正の整数、負の整数、または文字列にすることができます。 0から255までの整数値と長さ1の文字列は、「標準アクション」として指定されます。 256〜65535の整数値と長さ2の文字列は、「指定が必要」として指定されます。 65535を超える整数値と2を超える長さの文字列は、「エキスパートレビュー」として指定されます。 -65536から-1の範囲の整数値は、「COSEキータイプパラメータレジストリに委任された単一のアルゴリズムに固有のキーパラメータに使用されます」。 -65536未満の整数値は、私的使用としてマークされます。"
    },
    {
      "indent": 3,
      "text": "CBOR Type: This field contains the CBOR type for the field.",
      "ja": "CBORタイプ：このフィールドには、フィールドのCBORタイプが含まれます。"
    },
    {
      "indent": 3,
      "text": "Value Registry: This field denotes the registry that values come from, if one exists.",
      "ja": "値レジストリ：このフィールドは、値が存在する場合、値の取得元のレジストリを示します。"
    },
    {
      "indent": 3,
      "text": "Description: This field contains a brief description for the field.",
      "ja": "説明：このフィールドには、フィールドの簡単な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "Reference: This contains a pointer to the public specification for the field if one exists.",
      "ja": "参照：これには、フィールドの公開仕様へのポインターが含まれます（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "This registry has been initially populated by the values in Table 3. All of the entries in the \"References\" column of this registry point to this document.",
      "ja": "このレジストリには、最初に表3の値が入力されています。このレジストリの「参照」列のすべてのエントリは、このドキュメントを指しています。"
    },
    {
      "indent": 0,
      "text": "16.6. COSE Key Type Parameters Registry",
      "section_title": true,
      "ja": "16.6. COSEキータイプパラメータレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Key Type Parameters\". The registry has been created to use the \"Expert Review Required\" registration procedure. Expert review guidelines are provided in Section 16.11.",
      "ja": "IANAは、「COSEキータイプパラメータ」という新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要です」登録手順を使用するために作成されました。専門家によるレビューのガイドラインは、セクション16.11に記載されています。"
    },
    {
      "indent": 3,
      "text": "The columns of the table are:",
      "ja": "テーブルの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Key Type: This field contains a descriptive string of a key type. This should be a value that is in the \"COSE Key Common Parameters\" registry and is placed in the 'kty' field of a COSE Key structure.",
      "ja": "キータイプ：このフィールドには、キータイプの説明文字列が含まれます。これは、「COSEキーの共通パラメーター」レジストリーにあり、COSEキー構造の「kty」フィールドに配置される値である必要があります。"
    },
    {
      "indent": 3,
      "text": "Name: This is a descriptive name that enables easier reference to the item. It is not used in the encoding.",
      "ja": "名前：これは、アイテムを簡単に参照できるようにする説明的な名前です。エンコードでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Label: The label is to be unique for every value of key type. The range of values is from -65536 to -1. Labels are expected to be reused for different keys.",
      "ja": "ラベル：ラベルは、キータイプのすべての値に対して一意です。値の範囲は-65536〜-1です。ラベルは別のキーに再利用されることが期待されています。"
    },
    {
      "indent": 3,
      "text": "CBOR Type: This field contains the CBOR type for the field.",
      "ja": "CBORタイプ：このフィールドには、フィールドのCBORタイプが含まれます。"
    },
    {
      "indent": 3,
      "text": "Description: This field contains a brief description for the field.",
      "ja": "説明：このフィールドには、フィールドの簡単な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "Reference: This contains a pointer to the public specification for the field if one exists.",
      "ja": "参照：これには、フィールドの公開仕様へのポインターが含まれます（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "This registry has been initially populated by the values in Tables 23, 24, and 25. All of the entries in the \"References\" column of this registry point to this document.",
      "ja": "このレジストリには、表23、24、および25の値が最初に入力されています。このレジストリの「参照」列のすべてのエントリは、このドキュメントを指しています。"
    },
    {
      "indent": 0,
      "text": "16.7. COSE Key Types Registry",
      "section_title": true,
      "ja": "16.7. COSEキータイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Key Types\". The registry has been created to use the \"Expert Review Required\" registration procedure. Expert review guidelines are provided in Section 16.11.",
      "ja": "IANAは、「COSEキータイプ」というタイトルの新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要です」登録手順を使用するために作成されました。専門家によるレビューのガイドラインは、セクション16.11に記載されています。"
    },
    {
      "indent": 3,
      "text": "The columns of this table are:",
      "ja": "この表の列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: This is a descriptive name that enables easier reference to the item. The name MUST be unique. It is not used in the encoding.",
      "ja": "名前：これは、アイテムを簡単に参照できるようにする説明的な名前です。名前は一意である必要があります。エンコードでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Value: This is the value used to identify the curve. These values MUST be unique. The value can be a positive integer, a negative integer, or a string.",
      "ja": "値：これは、曲線を識別するために使用される値です。これらの値は一意である必要があります。値は正の整数、負の整数、または文字列です。"
    },
    {
      "indent": 3,
      "text": "Description: This field contains a brief description of the curve.",
      "ja": "説明：このフィールドには、曲線の簡単な説明が含まれます。"
    },
    {
      "indent": 3,
      "text": "References: This contains a pointer to the public specification for the curve if one exists.",
      "ja": "参照：これには、曲線の公開仕様へのポインタが含まれます（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "This registry has been initially populated by the values in Table 21. The specification column for all of these entries will be this document.",
      "ja": "このレジストリには、表21の値が最初に入力されています。これらのすべてのエントリの仕様列は、このドキュメントになります。"
    },
    {
      "indent": 0,
      "text": "16.8. COSE Elliptic Curves Registry",
      "section_title": true,
      "ja": "16.8. COSE楕円曲線レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"COSE Elliptic Curves\". The registry has been created to use the \"Expert Review Required\" registration procedure. Guidelines for the experts are provided in Section 16.11. It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.",
      "ja": "IANAは、「COSE Elliptic Curves」というタイトルの新しいレジストリを作成しました。レジストリは、「エキスパートレビューが必要です」登録手順を使用するために作成されました。専門家向けのガイドラインはセクション16.11に記載されています。専門家によるレビューに加えて、レジストリの一部には、仕様（場合によってはStandards Track RFC）も提供する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The columns of the table are:",
      "ja": "テーブルの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: This is a descriptive name that enables easier reference to the item. It is not used in the encoding.",
      "ja": "名前：これは、アイテムを簡単に参照できるようにする説明的な名前です。エンコードでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Value: This is the value used to identify the curve. These values MUST be unique. The integer values from -256 to 255 are designated as \"Standards Action\". The integer values from 256 to 65535 and -65536 to -257 are designated as \"Specification Required\". Integer values over 65535 are designated as \"Expert Review\". Integer values less than -65536 are marked as private use.",
      "ja": "値：これは、曲線を識別するために使用される値です。これらの値は一意である必要があります。 -256〜255の整数値は、「標準アクション」として指定されます。 256〜65535および-65536〜-257の整数値は、「指定が必要」として指定されます。 65535を超える整数値は、「エキスパートレビュー」として指定されます。 -65536未満の整数値は、私的使用としてマークされます。"
    },
    {
      "indent": 3,
      "text": "Key Type: This designates the key type(s) that can be used with this curve.",
      "ja": "キータイプ：これは、このカーブで使用できるキータイプを指定します。"
    },
    {
      "indent": 3,
      "text": "Description: This field contains a brief description of the curve.",
      "ja": "説明：このフィールドには、曲線の簡単な説明が含まれます。"
    },
    {
      "indent": 3,
      "text": "Reference: This contains a pointer to the public specification for the curve if one exists.",
      "ja": "参照：これには、曲線の公開仕様へのポインタが含まれます（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "Recommended: Does the IETF have a consensus recommendation to use the algorithm? The legal values are 'Yes', 'No', and 'Deprecated'.",
      "ja": "推奨：IETFには、アルゴリズムを使用するためのコンセンサス推奨事項がありますか？有効な値は、「はい」、「いいえ」、および「非推奨」です。"
    },
    {
      "indent": 3,
      "text": "This registry has been initially populated by the values in Table 22. All of the entries in the \"References\" column of this registry point to this document. All of the entries in the \"Recommended\" column are set to \"Yes\".",
      "ja": "このレジストリには、最初に表22の値が入力されています。このレジストリの「参照」列のすべてのエントリは、このドキュメントを指しています。 「推奨」列のエントリはすべて「はい」に設定されています。"
    },
    {
      "indent": 0,
      "text": "16.9. Media Type Registrations",
      "section_title": true,
      "ja": "16.9. メディアタイプ登録"
    },
    {
      "indent": 0,
      "text": "16.9.1. COSE Security Message",
      "section_title": true,
      "ja": "16.9.1. THINGSセキュリティメッセージ"
    },
    {
      "indent": 3,
      "text": "This section registers the 'application/cose' media type in the \"Media Types\" registry. These media types are used to indicate that the content is a COSE message.",
      "ja": "このセクションでは、「application / cose」メディアタイプを「Media Types」レジストリに登録します。これらのメディアタイプは、コンテンツがCOSEメッセージであることを示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 6,
      "text": "Subtype name: cose",
      "ja": "サブタイプ名：もの"
    },
    {
      "indent": 6,
      "text": "Required parameters: N/A",
      "ja": "必須パラメーター：なし"
    },
    {
      "indent": 6,
      "text": "Optional parameters: cose-type",
      "ja": "オプションのパラメーター：cose-type"
    },
    {
      "indent": 6,
      "text": "Encoding considerations: binary",
      "ja": "エンコーディングに関する考慮事項：バイナリ"
    },
    {
      "indent": 6,
      "text": "Security considerations: See the Security Considerations section of RFC 8152.",
      "ja": "セキュリティに関する考慮事項：RFC 8152のセキュリティに関する考慮事項のセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する考慮事項：N / A"
    },
    {
      "indent": 6,
      "text": "Published specification: RFC 8152",
      "ja": "公開された仕様：RFC 8152"
    },
    {
      "indent": 6,
      "text": "Applications that use this media type: IoT applications sending security content over HTTP(S) transports.",
      "ja": "このメディアタイプを使用するアプリケーション：HTTP（S）トランスポートを介してセキュリティコンテンツを送信するIoTアプリケーション。"
    },
    {
      "indent": 6,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：なし"
    },
    {
      "indent": 6,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "* Deprecated alias names for this type: N/A",
      "ja": "* このタイプの非推奨のエイリアス名：N / A"
    },
    {
      "indent": 6,
      "text": "* Magic number(s): N/A",
      "ja": "* マジックナンバー：N / A"
    },
    {
      "indent": 6,
      "text": "* File extension(s): cbor",
      "ja": "* ファイル拡張子：cbor"
    },
    {
      "indent": 6,
      "text": "* Macintosh file type code(s): N/A",
      "ja": "* Macintoshファイルタイプコード：N / A"
    },
    {
      "indent": 6,
      "text": "Person & email address to contact for further information: iesg@ietf.org",
      "ja": "詳細について連絡する人とメールアドレス：iesg@ietf.org"
    },
    {
      "indent": 6,
      "text": "Intended usage: COMMON",
      "ja": "使用目的：COMMON"
    },
    {
      "indent": 6,
      "text": "Restrictions on usage: N/A",
      "ja": "使用上の制限：N / A"
    },
    {
      "indent": 0,
      "text": " Author: Jim Schaad, ietf@augustcellars.com Change Controller: IESG",
      "ja": "作成者：Jim Schaad、ietf @ augustcellars.com変更管理者：IESG"
    },
    {
      "indent": 6,
      "text": "Provisional registration? No",
      "ja": "仮登録？番号"
    },
    {
      "indent": 0,
      "text": "16.9.2. COSE Key Media Type",
      "section_title": true,
      "ja": "16.9.2. THINGSキーメディアタイプ"
    },
    {
      "indent": 3,
      "text": "This section registers the 'application/cose-key' and 'application/ cose-key-set' media types in the \"Media Types\" registry. These media types are used to indicate, respectively, that content is a COSE_Key or COSE_KeySet object.",
      "ja": "このセクションでは、「メディアタイプ」レジストリに「application / cose-key」および「application / cose-key-set」メディアタイプを登録します。これらのメディアタイプは、それぞれコンテンツがCOSE_KeyまたはCOSE_KeySetオブジェクトであることを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "The template for registering 'application/cose-key' is:",
      "ja": "「application / cose-key」を登録するためのテンプレートは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 6,
      "text": "Subtype name: cose-key",
      "ja": "サブタイプ名：cose-key"
    },
    {
      "indent": 6,
      "text": "Required parameters: N/A",
      "ja": "必須パラメーター：なし"
    },
    {
      "indent": 6,
      "text": "Optional parameters: N/A",
      "ja": "オプションのパラメーター：N / A"
    },
    {
      "indent": 6,
      "text": "Encoding considerations: binary",
      "ja": "エンコーディングに関する考慮事項：バイナリ"
    },
    {
      "indent": 6,
      "text": "Security considerations: See the Security Considerations section of RFC 8152.",
      "ja": "セキュリティに関する考慮事項：RFC 8152のセキュリティに関する考慮事項のセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する考慮事項：N / A"
    },
    {
      "indent": 6,
      "text": "Published specification: RFC 8152",
      "ja": "公開された仕様：RFC 8152"
    },
    {
      "indent": 6,
      "text": "Applications that use this media type: Distribution of COSE based keys for IoT applications.",
      "ja": "このメディアタイプを使用するアプリケーション：IoTアプリケーション用のCOSEベースのキーの配布。"
    },
    {
      "indent": 6,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：なし"
    },
    {
      "indent": 6,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "* Deprecated alias names for this type: N/A",
      "ja": "* このタイプの非推奨のエイリアス名：N / A"
    },
    {
      "indent": 6,
      "text": "* Magic number(s): N/A",
      "ja": "* マジックナンバー：N / A"
    },
    {
      "indent": 6,
      "text": "* File extension(s): cbor",
      "ja": "* ファイル拡張子：cbor"
    },
    {
      "indent": 6,
      "text": "* Macintosh file type code(s): N/A",
      "ja": "* Macintoshファイルタイプコード：N / A"
    },
    {
      "indent": 0,
      "text": " Person & email address to contact for further information: iesg@ietf.org Intended usage: COMMON",
      "ja": "詳細について連絡する人とメールアドレス：iesg@ietf.org使用目的：共通"
    },
    {
      "indent": 6,
      "text": "Restrictions on usage: N/A",
      "ja": "使用上の制限：N / A"
    },
    {
      "indent": 6,
      "text": "Author: Jim Schaad, ietf@augustcellars.com",
      "ja": "作成者：Jim Schaad、ietf @ augustcellars.com"
    },
    {
      "indent": 6,
      "text": "Change Controller: IESG",
      "ja": "コントローラーの変更：IESG"
    },
    {
      "indent": 6,
      "text": "Provisional registration? No",
      "ja": "仮登録？番号"
    },
    {
      "indent": 3,
      "text": "The template for registering 'application/cose-key-set' is:",
      "ja": "「application / cose-key-set」を登録するためのテンプレートは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 6,
      "text": "Subtype name: cose-key-set",
      "ja": "サブタイプ名：cose-key-set"
    },
    {
      "indent": 6,
      "text": "Required parameters: N/A",
      "ja": "必須パラメーター：なし"
    },
    {
      "indent": 6,
      "text": "Optional parameters: N/A",
      "ja": "オプションのパラメーター：N / A"
    },
    {
      "indent": 6,
      "text": "Encoding considerations: binary",
      "ja": "エンコーディングに関する考慮事項：バイナリ"
    },
    {
      "indent": 6,
      "text": "Security considerations: See the Security Considerations section of RFC 8152.",
      "ja": "セキュリティに関する考慮事項：RFC 8152のセキュリティに関する考慮事項のセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する考慮事項：N / A"
    },
    {
      "indent": 6,
      "text": "Published specification: RFC 8152",
      "ja": "公開された仕様：RFC 8152"
    },
    {
      "indent": 6,
      "text": "Applications that use this media type: Distribution of COSE based keys for IoT applications.",
      "ja": "このメディアタイプを使用するアプリケーション：IoTアプリケーション用のCOSEベースのキーの配布。"
    },
    {
      "indent": 6,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：なし"
    },
    {
      "indent": 6,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "* Deprecated alias names for this type: N/A",
      "ja": "* このタイプの非推奨のエイリアス名：N / A"
    },
    {
      "indent": 6,
      "text": "* Magic number(s): N/A",
      "ja": "* マジックナンバー：N / A"
    },
    {
      "indent": 6,
      "text": "* File extension(s): cbor",
      "ja": "* ファイル拡張子：cbor"
    },
    {
      "indent": 6,
      "text": "* Macintosh file type code(s): N/A",
      "ja": "* Macintoshファイルタイプコード：N / A"
    },
    {
      "indent": 6,
      "text": "Person & email address to contact for further information: iesg@ietf.org",
      "ja": "詳細について連絡する人とメールアドレス：iesg@ietf.org"
    },
    {
      "indent": 0,
      "text": " Intended usage: COMMON Restrictions on usage: N/A",
      "ja": "使用目的：一般的な使用制限：なし"
    },
    {
      "indent": 6,
      "text": "Author: Jim Schaad, ietf@augustcellars.com",
      "ja": "作成者：Jim Schaad、ietf @ augustcellars.com"
    },
    {
      "indent": 6,
      "text": "Change Controller: IESG",
      "ja": "コントローラーの変更：IESG"
    },
    {
      "indent": 6,
      "text": "Provisional registration? No",
      "ja": "仮登録？番号"
    },
    {
      "indent": 0,
      "text": "16.10. CoAP Content-Formats Registry",
      "section_title": true,
      "ja": "16.10. CoAPコンテンツ形式レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entries to the \"CoAP Content-Formats\" registry.",
      "ja": "IANAは、「CoAP Content-Formats」レジストリに次のエントリを追加しました。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------------+----------+-----+-----------+\n| Media Type                           | Encoding | ID  | Reference |\n+--------------------------------------+----------+-----+-----------+\n| application/cose; cose-type=\"cose-   |          | 98  | [RFC8152] |\n| sign\"                                |          |     |           |\n| application/cose; cose-type=\"cose-   |          | 18  | [RFC8152] |\n| sign1\"                               |          |     |           |\n| application/cose; cose-type=\"cose-   |          | 96  | [RFC8152] |\n| encrypt\"                             |          |     |           |\n| application/cose; cose-type=\"cose-   |          | 16  | [RFC8152] |\n| encrypt0\"                            |          |     |           |\n| application/cose; cose-type=\"cose-   |          | 97  | [RFC8152] |\n| mac\"                                 |          |     |           |\n| application/cose; cose-type=\"cose-   |          | 17  | [RFC8152] |\n| mac0\"                                |          |     |           |\n| application/cose-key                 |          | 101 | [RFC8152] |\n| application/cose-key-set             |          | 102 | [RFC8152] |\n+--------------------------------------+----------+-----+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 26: CoAP Content-Formats for COSE",
      "ja": "表26：COSEのCoAPコンテンツ形式"
    },
    {
      "indent": 0,
      "text": "16.11. Expert Review Instructions",
      "section_title": true,
      "ja": "16.11. エキスパートレビューの手順"
    },
    {
      "indent": 3,
      "text": "All of the IANA registries established in this document are defined as expert review. This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason, so they should be given substantial latitude.",
      "ja": "このドキュメントで確立されたすべてのIANAレジストリは、専門家によるレビューとして定義されています。このセクションでは、専門家が何を探すべきかについてのいくつかの一般的なガイドラインを示しますが、彼らは理由のために専門家として指定されているため、かなりの自由度を与える必要があります。"
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take into consideration the following points:",
      "ja": "専門家レビューアは、次の点を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": " o Point squatting should be discouraged. Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate one that is already registered, and that the point is likely to be used in deployments. The zones tagged as private use are intended for testing purposes and closed environments; code points in other ranges should not be assigned for testing.",
      "ja": "oポイントしゃがむことはお勧めできません。レビュー担当者は、登録リクエストの十分な情報を取得して、使用法がすでに登録されているものと重複しないこと、およびポイントが展開で使用される可能性があることを確認することをお勧めします。私的使用としてタグ付けされたゾーンは、テスト目的および閉鎖環境用です。他の範囲のコードポイントをテストに割り当てないでください。"
    },
    {
      "indent": 3,
      "text": "o Specifications are required for the standards track range of point assignment. Specifications should exist for specification required ranges, but early assignment before a specification is available is considered to be permissible. Specifications are needed for the first-come, first-serve range if they are expected to be used outside of closed environments in an interoperable way. When specifications are not provided, the description provided needs to have sufficient information to identify what the point is being used for.",
      "ja": "o ポイント割り当ての標準トラック範囲には仕様が必要です。仕様が必要な範囲の仕様が存在する必要がありますが、仕様が利用可能になる前の早期の割り当ては許容できると見なされます。相互運用可能な方法で閉鎖環境外で使用されることが予想される場合は、先着順の仕様が必要です。仕様が提供されていない場合、提供される説明には、ポイントが何のために使用されているのかを識別するための十分な情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o Experts should take into account the expected usage of fields when approving point assignment. The fact that there is a range for standards track documents does not mean that a standards track document cannot have points assigned outside of that range. The length of the encoded value should be weighed against how many code points of that length are left, the size of device it will be used on, and the number of code points left that encode to that size.",
      "ja": "o 専門家は、ポイントの割り当てを承認するときに、フィールドの予想される使用法を考慮する必要があります。標準トラックドキュメントに範囲があるという事実は、標準トラックドキュメントがその範囲外に割り当てられたポイントを持つことができないことを意味しません。エンコードされた値の長さは、その長さのコードポイントがいくつ残っているか、それが使用されるデバイスのサイズ、およびそのサイズにエンコードされた残りのコードポイントの数と比較検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When algorithms are registered, vanity registrations should be discouraged. One way to do this is to require registrations to provide additional documentation on security analysis of the algorithm. Another thing that should be considered is requesting an opinion on the algorithm from the Crypto Forum Research Group (CFRG). Algorithms that do not meet the security requirements of the community and the messages structures should not be registered.",
      "ja": "o アルゴリズムを登録するときは、虚栄心の登録はお勧めできません。これを行う1つの方法は、アルゴリズムのセキュリティ分析に関する追加のドキュメントを提供するために登録を要求することです。考慮すべきもう1つのことは、暗号フォーラム研究グループ（CFRG）にアルゴリズムに関する意見を求めることです。コミュニティのセキュリティ要件およびメッセージ構造を満たさないアルゴリズムは登録しないでください。"
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "ja": "17. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of security considerations that need to be taken into account by implementers of this specification. The security considerations that are specific to an individual algorithm are placed next to the description of the algorithm. While some considerations have been highlighted here, additional considerations may be found in the documents listed in the references.",
      "ja": "この仕様の実装者が考慮する必要のあるセキュリティ上の考慮事項がいくつかあります。個々のアルゴリズムに固有のセキュリティに関する考慮事項は、アルゴリズムの説明の横に配置されています。ここではいくつかの考慮事項が強調表示されていますが、参考文献に記載されているドキュメントで追加の考慮事項が見つかる場合があります。"
    },
    {
      "indent": 3,
      "text": "Implementations need to protect the private key material for any individuals. There are some cases in this document that need to be highlighted on this issue.",
      "ja": "実装では、個人の秘密鍵マテリアルを保護する必要があります。このドキュメントでは、この問題について強調する必要があるいくつかのケースがあります。"
    },
    {
      "indent": 3,
      "text": "o Using the same key for two different algorithms can leak information about the key. It is therefore recommended that keys be restricted to a single algorithm.",
      "ja": "o 2つの異なるアルゴリズムに同じキーを使用すると、キーに関する情報が漏洩する可能性があります。したがって、キーを単一のアルゴリズムに制限することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Use of 'direct' as a recipient algorithm combined with a second recipient algorithm exposes the direct key to the second recipient.",
      "ja": "o 2番目の受信者アルゴリズムと組み合わせた受信者アルゴリズムとして「direct」を使用すると、2番目の受信者にダイレクトキーが公開されます。"
    },
    {
      "indent": 3,
      "text": "o Several of the algorithms in this document have limits on the number of times that a key can be used without leaking information about the key.",
      "ja": "o このドキュメントのアルゴリズムのいくつかは、キーに関する情報を漏らすことなくキーを使用できる回数に制限があります。"
    },
    {
      "indent": 3,
      "text": "The use of ECDH and direct plus KDF (with no key wrap) will not directly lead to the private key being leaked; the one way function of the KDF will prevent that. There is, however, a different issue that needs to be addressed. Having two recipients requires that the CEK be shared between two recipients. The second recipient therefore has a CEK that was derived from material that can be used for the weak proof of origin. The second recipient could create a message using the same CEK and send it to the first recipient; the first recipient would, for either static-static ECDH or direct plus KDF, make an assumption that the CEK could be used for proof of origin even though it is from the wrong entity. If the key wrap step is added, then no proof of origin is implied and this is not an issue.",
      "ja": "ECDHとダイレクトプラスKDF（キーラップなし）を使用しても、秘密キーが直接漏洩することはありません。 KDFの一方通行機能はそれを防ぎます。ただし、対処する必要のある別の問題があります。 2人の受信者がいる場合、CEKを2人の受信者間で共有する必要があります。したがって、2番目の受信者には、弱い出所証明に使用できる資料から派生したCEKがあります。 2番目の受信者は、同じCEKを使用してメッセージを作成し、最初の受信者に送信できます。最初の受信者は、静的-静的ECDHまたはダイレクトプラスKDFのいずれかで、間違ったエンティティからのものであっても、CEKを発信元の証明に使用できると想定します。キーラップステップが追加された場合、出所の証明は暗示されず、これは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "Although it has been mentioned before, the use of a single key for multiple algorithms has been demonstrated in some cases to leak information about a key, provide the opportunity for attackers to forge integrity tags, or gain information about encrypted content. Binding a key to a single algorithm prevents these problems. Key creators and key consumers are strongly encouraged not only to create new keys for each different algorithm, but to include that selection of algorithm in any distribution of key material and strictly enforce the matching of algorithms in the key structure to algorithms in the message structure. In addition to checking that algorithms are correct, the key form needs to be checked as well. Do not use an 'EC2' key where an 'OKP' key is expected.",
      "ja": "前述のように、複数のアルゴリズムで単一のキーを使用すると、キーに関する情報が漏洩したり、攻撃者が整合性タグを偽造したり、暗号化されたコンテンツに関する情報を入手したりできる場合があります。キーを単一のアルゴリズムにバインドすると、これらの問題を回避できます。鍵の作成者と鍵の利用者は、異なるアルゴリズムごとに新しい鍵を作成するだけでなく、その選択したアルゴリズムを鍵素材の配布に含め、鍵構造のアルゴリズムとメッセージ構造のアルゴリズムのマッチングを厳密に実施することを強くお勧めします。アルゴリズムが正しいことを確認することに加えて、キーフォームも確認する必要があります。 「OKP」キーが必要な場所で「EC2」キーを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Before using a key for transmission, or before acting on information received, a trust decision on a key needs to be made. Is the data or action something that the entity associated with the key has a right to see or a right to request? A number of factors are associated with this trust decision. Some of the ones that are highlighted here are:",
      "ja": "送信に鍵を使用する前、または受信した情報に基づいて行動する前に、鍵の信頼性の決定を行う必要があります。データまたはアクションは、キーに関連付けられたエンティティが見る権利または要求する権利を持つものですか？この信頼の決定には、いくつかの要因が関係しています。ここで強調表示されているもののいくつかは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o What are the permissions associated with the key owner?",
      "ja": "o 鍵の所有者に関連付けられている権限は何ですか？"
    },
    {
      "indent": 3,
      "text": "o Is the cryptographic algorithm acceptable in the current context?",
      "ja": "o 暗号アルゴリズムは現在の状況で受け入れられますか？"
    },
    {
      "indent": 3,
      "text": "o Have the restrictions associated with the key, such as algorithm or freshness, been checked and are they correct?",
      "ja": "o アルゴリズムや鮮度など、キーに関連する制限がチェックされていますか、それらは正しいですか？"
    },
    {
      "indent": 3,
      "text": "o Is the request something that is reasonable, given the current state of the application?",
      "ja": "o アプリケーションの現在の状態を考えると、要求は妥当なものですか？"
    },
    {
      "indent": 3,
      "text": "o Have any security considerations that are part of the message been enforced (as specified by the application or 'crit' parameter)?",
      "ja": "o メッセージの一部であるセキュリティ上の考慮事項が適用されていますか（アプリケーションまたは「crit」パラメーターで指定されているとおり）？"
    },
    {
      "indent": 3,
      "text": "There are a large number of algorithms presented in this document that use nonce values. For all of the nonces defined in this document, there is some type of restriction on the nonce being a unique value either for a key or for some other conditions. In all of these cases, there is no known requirement on the nonce being both unique and unpredictable; under these circumstances, it's reasonable to use a counter for creation of the nonce. In cases where one wants the pattern of the nonce to be unpredictable as well as unique, one can use a key created for that purpose and encrypt the counter to produce the nonce value.",
      "ja": "このドキュメントには、ナンス値を使用する多数のアルゴリズムがあります。このドキュメントで定義されているすべてのノンスについて、ナンスがキーまたは他のいくつかの条件のいずれかで一意の値であることには、いくつかの種類の制限があります。これらのすべてのケースで、ナンスが一意で予測不能であるという既知の要件はありません。このような状況では、ナンスの作成にカウンターを使用するのが妥当です。 nonceのパターンを予測不可能かつ一意にしたい場合は、その目的のために作成されたキーを使用し、カウンターを暗号化してnonce値を生成できます。"
    },
    {
      "indent": 3,
      "text": "One area that has been starting to get exposure is doing traffic analysis of encrypted messages based on the length of the message. This specification does not provide for a uniform method of providing padding as part of the message structure. An observer can distinguish between two different strings (for example, 'YES' and 'NO') based on the length for all of the content encryption algorithms that are defined in this document. This means that it is up to the applications to document how content padding is to be done in order to prevent or discourage such analysis. (For example, the strings could be defined as 'YES' and 'NO '.)",
      "ja": "公開され始めている1つの領域は、メッセージの長さに基づいて暗号化されたメッセージのトラフィック分析を行うことです。この仕様は、メッセージ構造の一部としてパディングを提供する統一された方法を提供しません。オブザーバーは、このドキュメントで定義されているすべてのコンテンツ暗号化アルゴリズムの長さに基づいて、2つの異なる文字列（「YES」と「NO」など）を区別できます。つまり、そのような分析を防止または阻止するためにコンテンツのパディングがどのように行われるかを文書化するのはアプリケーション次第です。 （たとえば、ストリングは「YES」および「NO」として定義できます。）"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18. 参考文献"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "ja": "18.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES-GCM] National Institute of Standards and Technology, \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\", NIST Special Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November 2007, <https://csrc.nist.gov/publications/nistpubs/800- 38D/SP-800-38D.pdf>.",
      "ja": "[AES-GCM] National Institute of Standards and Technology、「Recommendation for Block Cipher Modes of Operation：Galois / Counter Mode（GCM）and GMAC」、NIST Special Publication 800-38D、DOI 10.6028 / NIST.SP.800-38D、 2007年11月、<https://csrc.nist.gov/publications/nistpubs/800- 38D / SP-800-38D.pdf>。"
    },
    {
      "indent": 3,
      "text": "[COAP.Formats] IANA, \"Constrained RESTful Environments (CoRE) Parameters\", <http://www.iana.org/assignments/core-parameters/>.",
      "ja": "[COAP.Formats] IANA、「Constrained RESTful Environments（CoRE）Parameters」、<http://www.iana.org/assignments/core-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[DSS]      National Institute of Standards and Technology, \"Digital\n           Signature Standard (DSS)\", FIPS PUB 186-4,\n           DOI 10.6028/NIST.FIPS.186-4, July 2013,\n           <http://nvlpubs.nist.gov/nistpubs/FIPS/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "NIST.FIPS.186-4.pdf>.",
      "ja": "NIST.FIPS.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MAC] National Institute of Standards and Technology, \"Computer Data Authentication\", FIPS PUB 113, May 1985, <http://csrc.nist.gov/publications/fips/fips113/ fips113.html>.",
      "ja": "[MAC]国立標準技術研究所、「コンピュータデータ認証」、FIPS PUB 113、1985年5月、<http://csrc.nist.gov/publications/fips/fips113/ fips113.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<http：//www.rfc-editor .org / info / rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3394] Schaad, J. and R. Housley, \"Advanced Encryption Standard (AES) Key Wrap Algorithm\", RFC 3394, DOI 10.17487/RFC3394, September 2002, <http://www.rfc-editor.org/info/rfc3394>.",
      "ja": "[RFC3394] Schaad、J。およびR. Housley、「Advanced Encryption Standard（AES）Key Wrap Algorithm」、RFC 3394、DOI 10.17487 / RFC3394、2002年9月、<http://www.rfc-editor.org/info/ rfc3394>。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] Whiting, D., Housley, R., and N. Ferguson, \"Counter with CBC-MAC (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September 2003, <http://www.rfc-editor.org/info/rfc3610>.",
      "ja": "[RFC3610] Whiting、D.、Housley、R。、およびN. Ferguson、「Counter with CBC-MAC（CCM）」、RFC 3610、DOI 10.17487 / RFC3610、2003年9月、<http：//www.rfc-editor .org / info / rfc3610>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <http://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー導出関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<http：//www.rfc-editor .org / info / rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「Fundamental Elliptic Curve Cryptography Algorithms」、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/ info / rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC6979] Pornin, T., \"Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August 2013, <http://www.rfc-editor.org/info/rfc6979>.",
      "ja": "[RFC6979]ポルノ、T。、「デジタル署名アルゴリズム（DSA）と楕円曲線デジタル署名アルゴリズム（ECDSA）の決定論的使用法」、RFC 6979、DOI 10.17487 / RFC6979、2013年8月、<http：//www.rfc- editor.org/info/rfc6979>。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", RFC 7049, DOI 10.17487/RFC7049, October 2013, <http://www.rfc-editor.org/info/rfc7049>.",
      "ja": "[RFC7049] Bormann、C。およびP. Hoffman、「簡潔なバイナリオブジェクト表現（CBOR）」、RFC 7049、DOI 10.17487 / RFC7049、2013年10月、<http://www.rfc-editor.org/info/rfc7049> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7539] Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF Protocols\", RFC 7539, DOI 10.17487/RFC7539, May 2015, <http://www.rfc-editor.org/info/rfc7539>.",
      "ja": "[RFC7539] Nir、Y。およびA. Langley、「IETFプロトコル用のChaCha20およびPoly1305」、RFC 7539、DOI 10.17487 / RFC7539、2015年5月、<http://www.rfc-editor.org/info/rfc7539>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <http://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A。、ハンブルク、M。、およびS.ターナー、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<http://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 3,
      "text": "[RFC8032] Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital Signature Algorithm (EdDSA)\", RFC 8032, DOI 10.17487/RFC8032, January 2017, <http://www.rfc-editor.org/info/rfc8032>.",
      "ja": "[RFC8032] Josefsson、S。およびI. Liusvaara、「Edwards-Curve Digital Signature Algorithm（EdDSA）」、RFC 8032、DOI 10.17487 / RFC8032、2017年1月、<http://www.rfc-editor.org/info/ rfc8032>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「あいまいな大文字と小文字のRFC 2119キーワード」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[SEC1] Certicom Research, \"SEC 1: Elliptic Curve Cryptography\", Standards for Efficient Cryptography, Version 2.0, May 2009, <http://www.secg.org/sec1-v2.pdf>.",
      "ja": "[SEC1] Certicom Research、「SEC 1：Elliptic Curve Cryptography」、Standards for Efficient Cryptography、バージョン2.0、2009年5月、<http://www.secg.org/sec1-v2.pdf>。"
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "ja": "18.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CDDL] Vigano, C. and H. Birkholz, \"CBOR data definition language (CDDL): a notational convention to express CBOR data structures\", Work in Progress, draft-greevenbosch-appsawg-cbor-cddl-09, March 2017.",
      "ja": "[CDDL] Vigano、C。およびH. Birkholz、「CBORデータ定義言語（CDDL）：CBORデータ構造を表現するための表記規則」、作業中、draft-greevenbosch-appsawg-cbor-cddl-09、2017年3月。"
    },
    {
      "indent": 3,
      "text": "[OSCOAP] Selander, G., Mattsson, J., Palombini, F., and L. Seitz, \"Object Security of CoAP (OSCOAP)\", Work in Progress, draft-ietf-core-object-security-03, May 2017.",
      "ja": "[OSCOAP] Selander、G.、Mattsson、J.、Palombini、F。、およびL. Seitz、「Object Security of CoAP（OSCOAP）」、Work in Progress、draft-ietf-core-object-security-03、May 2017。"
    },
    {
      "indent": 3,
      "text": "[PVSig] Brown, D. and D. Johnson, \"Formal Security Proofs for a Signature Scheme with Partial Message Recovery\", DOI 10.1007/3-540-45353-9_11, LNCS Volume 2020, June 2000.",
      "ja": "[PVSig]ブラウン、D。、およびD.ジョンソン、「部分的なメッセージ回復を伴う署名方式の正式なセキュリティ証明」、DOI 10.1007 / 3-540-45353-9_11、LNCS Volume 2020、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2633] Ramsdell, B., Ed., \"S/MIME Version 3 Message Specification\", RFC 2633, DOI 10.17487/RFC2633, June 1999, <http://www.rfc-editor.org/info/rfc2633>.",
      "ja": "[RFC2633] Ramsdell、B。、編、「S / MIMEバージョン3メッセージ仕様」、RFC 2633、DOI 10.17487 / RFC2633、1999年6月、<http://www.rfc-editor.org/info/rfc2633>。"
    },
    {
      "indent": 3,
      "text": "[RFC4231] Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\", RFC 4231, DOI 10.17487/RFC4231, December 2005, <http://www.rfc-editor.org/info/rfc4231>.",
      "ja": "[RFC4231] Nystrom、M。、「HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、およびHMAC-SHA-512の識別子とテストベクトル」、RFC 4231、DOI 10.17487 / RFC4231、2005年12月、<http://www.rfc-editor.org/info/rfc4231>。"
    },
    {
      "indent": 3,
      "text": "[RFC4262] Santesson, S., \"X.509 Certificate Extension for Secure/ Multipurpose Internet Mail Extensions (S/MIME) Capabilities\", RFC 4262, DOI 10.17487/RFC4262, December 2005, <http://www.rfc-editor.org/info/rfc4262>.",
      "ja": "[RFC4262] Santesson、S。、「X / 509 Certificate Extension for Secure / Multipurpose Internet Mail Extensions（S / MIME）Capabilities」、RFC 4262、DOI 10.17487 / RFC4262、2005年12月、<http：//www.rfc-editor .org / info / rfc4262>。"
    },
    {
      "indent": 3,
      "text": "[RFC4493] Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June 2006, <http://www.rfc-editor.org/info/rfc4493>.",
      "ja": "[RFC4493] Song、JH。、Poovendran、R.、Lee、J.、T。Iwata、「The AES-CMAC Algorithm」、RFC 4493、DOI 10.17487 / RFC4493、2006年6月、<http：//www.rfc -editor.org/info/rfc4493>。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <http://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<http://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5480] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, \"Elliptic Curve Cryptography Subject Public Key Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009, <http://www.rfc-editor.org/info/rfc5480>.",
      "ja": "[RFC5480]ターナー、S。、ブラウン、D。、ユウ、K。、ハウズリー、R。、およびT.ポーク、「楕円曲線暗号化サブジェクト公開鍵情報」、RFC 5480、DOI 10.17487 / RFC5480、2009年3月、< http://www.rfc-editor.org/info/rfc5480>。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, <http://www.rfc-editor.org/info/rfc5652>.",
      "ja": "[RFC5652] Housley、R。、「Cryptographic Message Syntax（CMS）」、STD 70、RFC 5652、DOI 10.17487 / RFC5652、2009年9月、<http://www.rfc-editor.org/info/rfc5652>。"
    },
    {
      "indent": 3,
      "text": "[RFC5751] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification\", RFC 5751, DOI 10.17487/RFC5751, January 2010, <http://www.rfc-editor.org/info/rfc5751>.",
      "ja": "[RFC5751] Ramsdell、B。およびS. Turner、「Secure / Multipurpose Internet Mail Extensions（S / MIME）Version 3.2 Message Specification」、RFC 5751、DOI 10.17487 / RFC5751、2010年1月、<http：//www.rfc- editor.org/info/rfc5751>。"
    },
    {
      "indent": 3,
      "text": "[RFC5752] Turner, S. and J. Schaad, \"Multiple Signatures in Cryptographic Message Syntax (CMS)\", RFC 5752, DOI 10.17487/RFC5752, January 2010, <http://www.rfc-editor.org/info/rfc5752>.",
      "ja": "[RFC5752]ターナー、S。およびJ.シャード、「暗号化メッセージ構文（CMS）の複数の署名」、RFC 5752、DOI 10.17487 / RFC5752、2010年1月、<http://www.rfc-editor.org/info/ rfc5752>。"
    },
    {
      "indent": 3,
      "text": "[RFC5990] Randall, J., Kaliski, B., Brainard, J., and S. Turner, \"Use of the RSA-KEM Key Transport Algorithm in the Cryptographic Message Syntax (CMS)\", RFC 5990, DOI 10.17487/RFC5990, September 2010, <http://www.rfc-editor.org/info/rfc5990>.",
      "ja": "[RFC5990] Randall、J.、Kaliski、B.、Brainard、J。、およびS. Turner、「RSA-KEMキー転送アルゴリズムの暗号化メッセージ構文（CMS）での使用」、RFC 5990、DOI 10.17487 / RFC5990 、2010年9月、<http://www.rfc-editor.org/info/rfc5990>。"
    },
    {
      "indent": 3,
      "text": "[RFC6151] Turner, S. and L. Chen, \"Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151, DOI 10.17487/RFC6151, March 2011, <http://www.rfc-editor.org/info/rfc6151>.",
      "ja": "[RFC6151]ターナーS.およびL.チェン、「MD5メッセージダイジェストおよびHMAC-MD5アルゴリズムの更新されたセキュリティに関する考慮事項」、RFC 6151、DOI 10.17487 / RFC6151、2011年3月、<http：//www.rfc- editor.org/info/rfc6151>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <http://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「Media Type Specifications and Registration Procedures」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<http：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T。、編、「JavaScript Object Notation（JSON）データ交換フォーマット」、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<http://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252] Shelby、Z.、Hartke、K。、およびC. Bormann、「The Constrained Application Protocol（CoAP）」、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<http：//www.rfc-editor。 org / info / rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <http://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515]ジョーンズ、M。、ブラッドリー、J。、およびN.崎村、「JSON Web Signature（JWS）」、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、<http://www.rfc-editor.org / info / rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M。およびJ.ヒルデブランド、「JSON Web Encryption（JWE）」、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<http://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <http://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M。、「JSON Web Key（JWK）」、RFC 7517、DOI 10.17487 / RFC7517、2015年5月、<http://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC7518] Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518, DOI 10.17487/RFC7518, May 2015, <http://www.rfc-editor.org/info/rfc7518>.",
      "ja": "[RFC7518]ジョーンズ、M。、「JSON Web Algorithms（JWA）」、RFC 7518、DOI 10.17487 / RFC7518、2015年5月、<http://www.rfc-editor.org/info/rfc7518>。"
    },
    {
      "indent": 3,
      "text": "[RFC8017] Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch, \"PKCS #1: RSA Cryptography Specifications Version 2.2\", RFC 8017, DOI 10.17487/RFC8017, November 2016, <http://www.rfc-editor.org/info/rfc8017>.",
      "ja": "[RFC8017] Moriarty、K.、Ed。、Kaliski、B.、Jonsson、J.、and A. Rusch、 \"PKCS＃1：RSA Cryptography Specifications Version 2.2\"、RFC 8017、DOI 10.17487 / RFC8017、November 2016、< http://www.rfc-editor.org/info/rfc8017>。"
    },
    {
      "indent": 3,
      "text": "[RFC8018] Moriarty, K., Ed., Kaliski, B., and A. Rusch, \"PKCS #5: Password-Based Cryptography Specification Version 2.1\", RFC 8018, DOI 10.17487/RFC8018, January 2017, <http://www.rfc-editor.org/info/rfc8018>.",
      "ja": "[RFC8018] Moriarty、K.、Ed。、Kaliski、B。、およびA. Rusch、「PKCS＃5：Password-Based Cryptography Specification Version 2.1」、RFC 8018、DOI 10.17487 / RFC8018、2017年1月、<http：/ /www.rfc-editor.org/info/rfc8018>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <http://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]コットン、M。、レイバ、B。、およびT.ナルテン、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<http：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Chen, L., Roginsky, A., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography\", NIST Special Publication 800-56A, Revision 2, DOI 10.6028/NIST.SP.800-56Ar2, May 2013, <http://nvlpubs.nist.gov/nistpubs/SpecialPublications/ NIST.SP.800-56Ar2.pdf>.",
      "ja": "[SP800-56A] Barker、E.、Chen、L.、Roginsky、A。、およびM. Smid、「離散対数暗号化を使用したペアワイズキー確立スキームの推奨」、NIST Special Publication 800-56A、Revision 2 DOI 10.6028 / NIST.SP.800-56Ar2、2013年5月、<http://nvlpubs.nist.gov/nistpubs/SpecialPublications/ NIST.SP.800-56Ar2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[W3C.WebCrypto] Watson, M., \"Web Cryptography API\", W3C Recommendation, January 2017, <https://www.w3.org/TR/WebCryptoAPI/>.",
      "ja": "[W3C.WebCrypto] Watson、M。、「Web Cryptography API」、W3C勧告、2017年1月、<https://www.w3.org/TR/WebCryptoAPI/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Guidelines for External Data Authentication of Algorithms",
      "section_title": true,
      "ja": "付録A.アルゴリズムの外部データ認証のガイドライン"
    },
    {
      "indent": 3,
      "text": "A portion of the working group has expressed a strong desire to relax the rule that the algorithm identifier be required to appear in each level of a COSE object. There are two basic reasons that have been advanced to support this position. First, the resulting message will be smaller if the algorithm identifier is omitted from the most common messages in a CoAP environment. Second, there is a potential bug that will arise if full checking is not done correctly between the different places that an algorithm identifier could be placed (the message itself, an application statement, the key structure that the sender possesses, and the key structure the recipient possesses).",
      "ja": "ワーキンググループの一部は、アルゴリズム識別子をCOSEオブジェクトの各レベルに表示する必要があるというルールを緩和する強い要望を表明しています。このポジションをサポートするために進められてきた2つの基本的な理由があります。まず、CoAP環境で最も一般的なメッセージからアルゴリズム識別子を省略した場合、結果のメッセージは小さくなります。次に、アルゴリズム識別子を配置できるさまざまな場所（メッセージ自体、アプリケーションステートメント、送信者が所有するキー構造、およびキー構造）の間で完全なチェックが正しく行われない場合に発生する可能性のあるバグがあります。受信者が所有しています）。"
    },
    {
      "indent": 3,
      "text": "This appendix lays out how such a change can be made and the details that an application needs to specify in order to use this option. Two different sets of details are specified: those needed to omit an algorithm identifier and those needed to use a variant on the counter signature attribute that contains no attributes about itself.",
      "ja": "この付録では、このような変更を行う方法と、このオプションを使用するためにアプリケーションが指定する必要がある詳細について説明します。詳細の2つの異なるセットが指定されています。アルゴリズム識別子を省略するために必要なものと、それ自体に関する属性を含まない副署名属性のバリアントを使用するために必要なものです。"
    },
    {
      "indent": 0,
      "text": "A.1. Algorithm Identification",
      "section_title": true,
      "ja": "A.1. アルゴリズムの識別"
    },
    {
      "indent": 3,
      "text": "In this section, three sets of recommendations are laid out. The first set of recommendations apply to having an implicit algorithm identified for a single layer of a COSE object. The second set of recommendations apply to having multiple implicit algorithms identified for multiple layers of a COSE object. The third set of recommendations apply to having implicit algorithms for multiple COSE object constructs.",
      "ja": "このセクションでは、3セットの推奨事項を示します。最初の推奨事項のセットは、COSEオブジェクトの単一の層に対して特定された暗黙のアルゴリズムを持つことに適用されます。 2番目の推奨事項は、COSEオブジェクトの複数のレイヤーに対して複数の暗黙的なアルゴリズムを特定する場合に適用されます。 3番目の推奨事項は、複数のCOSEオブジェクト構成の暗黙的なアルゴリズムを持つ場合に適用されます。"
    },
    {
      "indent": 3,
      "text": "The key words from RFC 2119 are deliberately not used here. This specification can provide recommendations, but it cannot enforce them.",
      "ja": "RFC 2119のキーワードは、ここでは意図的に使用されていません。この仕様は推奨事項を提供できますが、強制することはできません。"
    },
    {
      "indent": 3,
      "text": "This set of recommendations applies to the case where an application is distributing a fixed algorithm along with the key information for use in a single COSE object. This normally applies to the smallest of the COSE objects, specifically COSE_Sign1, COSE_Mac0, and COSE_Encrypt0, but could apply to the other structures as well.",
      "ja": "この一連の推奨事項は、アプリケーションが単一のCOSEオブジェクトで使用するための主要な情報と共に固定アルゴリズムを配布している場合に適用されます。これは通常、最小のCOSEオブジェクト、具体的にはCOSE_Sign1、COSE_Mac0、およびCOSE_Encrypt0に適用されますが、他の構造にも適用できます。"
    },
    {
      "indent": 3,
      "text": "The following items should be taken into account:",
      "ja": "次の項目を考慮に入れる必要があります。"
    },
    {
      "indent": 0,
      "text": " o Applications need to list the set of COSE structures that implicit algorithms are to be used in. Applications need to require that the receipt of an explicit algorithm identifier in one of these structures will lead to the message being rejected. This requirement is stated so that there will never be a case where there is any ambiguity about the question of which algorithm should be used, the implicit or the explicit one. This applies even if the transported algorithm identifier is a protected attribute. This applies even if the transported algorithm is the same as the implicit algorithm.",
      "ja": "アプリケーションは、暗黙のアルゴリズムが使用されるCOSE構造のセットをリストする必要があります。アプリケーションは、これらの構造の1つで明示的なアルゴリズム識別子を受信すると、メッセージが拒否されるようにする必要があります。この要件は、どのアルゴリズムを使用するか、つまり暗黙的または明示的なアルゴリズムを使用する必要があるかどうかについてあいまいさが生じないようにするために記載されています。これは、転送されたアルゴリズム識別子が保護された属性であっても適用されます。これは、転送されるアルゴリズムが暗黙的なアルゴリズムと同じであっても適用されます。"
    },
    {
      "indent": 3,
      "text": "o Applications need to define the set of information that is to be considered to be part of a context when omitting algorithm identifiers. At a minimum, this would be the key identifier (if needed), the key, the algorithm, and the COSE structure it is used with. Applications should restrict the use of a single key to a single algorithm. As noted for some of the algorithms in this document, the use of the same key in different related algorithms can lead to leakage of information about the key, leakage about the data or the ability to perform forgeries.",
      "ja": "o アプリケーションは、アルゴリズム識別子を省略したときにコンテキストの一部と見なされる一連の情報を定義する必要があります。少なくとも、これはキー識別子（必要な場合）、キー、アルゴリズム、およびそれが使用されるCOSE構造になります。アプリケーションは、単一の鍵の使用を単一のアルゴリズムに制限する必要があります。このドキュメントの一部のアルゴリズムで述べたように、関連するさまざまなアルゴリズムで同じキーを使用すると、キーに関する情報の漏えい、データに関する漏えい、または偽造を実行できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "o In many cases, applications that make the algorithm identifier implicit will also want to make the context identifier implicit for the same reason. That is, omitting the context identifier will decrease the message size (potentially significantly depending on the length of the identifier). Applications that do this will need to describe the circumstances where the context identifier is to be omitted and how the context identifier is to be inferred in these cases. (An exhaustive search over all of the keys would normally not be considered to be acceptable.) An example of how this can be done is to tie the context to a transaction identifier. Both would be sent on the original message, but only the transaction identifier would need to be sent after that point as the context is tied into the transaction identifier. Another way would be to associate a context with a network address. All messages coming from a single network address can be assumed to be associated with a specific context. (In this case, the address would normally be distributed as part of the context.)",
      "ja": "o 多くの場合、アルゴリズム識別子を暗黙的にするアプリケーションは、同じ理由でコンテキスト識別子も暗黙的にしたいと思うでしょう。つまり、コンテキスト識別子を省略すると、メッセージのサイズが小さくなります（識別子の長さに応じて大幅に変わる可能性があります）。これを行うアプリケーションは、コンテキスト識別子が省略される状況と、これらの場合にコンテキスト識別子がどのように推論されるかを説明する必要があります。 （通常、すべてのキーに対する徹底的な検索は許容できるとは見なされません。）これを行う方法の例は、コンテキストをトランザクション識別子に関連付けることです。どちらも元のメッセージで送信されますが、コンテキストがトランザクション識別子に結び付けられているため、その後はトランザクション識別子のみを送信する必要があります。別の方法は、コンテキストをネットワークアドレスに関連付けることです。単一のネットワークアドレスから送信されるすべてのメッセージは、特定のコンテキストに関連付けられていると想定できます。 （この場合、アドレスは通常、コンテキストの一部として配布されます。）"
    },
    {
      "indent": 3,
      "text": "o Applications cannot rely on key identifiers being unique unless they take significant efforts to ensure that they are computed in such a way as to create this guarantee. Even when an application does this, the uniqueness might be violated if the application is run in different contexts (i.e., with a different context provider) or if the system combines the security contexts from different applications together into a single store.",
      "ja": "o アプリケーションは、この保証を作成するような方法で計算されることを保証するために多大な努力を払わない限り、キー識別子が一意であることを信頼することはできません。アプリケーションがこれを行う場合でも、アプリケーションが異なるコンテキストで（つまり、異なるコンテキストプロバイダーを使用して）実行される場合、またはシステムが異なるアプリケーションのセキュリティコンテキストを1つのストアに結合する場合、一意性が損なわれる可能性があります。"
    },
    {
      "indent": 0,
      "text": " o Applications should continue the practice of protecting the algorithm identifier. Since this is not done by placing it in the protected attributes field, applications should define an application-specific external data structure that includes this value. This external data field can be used as such for content encryption, MAC, and signature algorithms. It can be used in the SuppPrivInfo field for those algorithms that use a KDF to derive a key value. Applications may also want to protect other information that is part of the context structure as well. It should be noted that those fields, such as the key or a Base IV, are protected by virtue of being used in the cryptographic computation and do not need to be included in the external data field.",
      "ja": "oアプリケーションは、アルゴリズム識別子を保護する慣行を継続する必要があります。これは、保護属性フィールドに配置することでは行われないため、アプリケーションは、この値を含むアプリケーション固有の外部データ構造を定義する必要があります。この外部データフィールドは、コンテンツの暗号化、MAC、署名アルゴリズムなどに使用できます。これは、KDFを使用してキー値を導出するアルゴリズムのSuppPrivInfoフィールドで使用できます。アプリケーションは、コンテキスト構造の一部である他の情報も保護したい場合があります。鍵やBase IVなどのフィールドは、暗号化計算で使用されることによって保護され、外部データフィールドに含める必要がないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The second case is having multiple implicit algorithm identifiers specified for a multiple layer COSE object. An example of how this would work is the encryption context that an application specifies, which contains a content encryption algorithm, a key wrap algorithm, a key identifier, and a shared secret. The sender omits sending the algorithm identifier for both the content layer and the recipient layer leaving only the key identifier. The receiver then uses the key identifier to get the implicit algorithm identifiers.",
      "ja": "2番目のケースは、複数のレイヤーのCOSEオブジェクトに対して複数の暗黙的なアルゴリズム識別子が指定されている場合です。これが機能する方法の例は、コンテンツ暗号化アルゴリズム、キーラップアルゴリズム、キー識別子、および共有シークレットを含む、アプリケーションが指定する暗号化コンテキストです。送信者は、コンテンツレイヤーと受信者レイヤーの両方のアルゴリズム識別子の送信を省略し、キー識別子のみを残します。次に、受信者はキー識別子を使用して、暗黙のアルゴリズム識別子を取得します。"
    },
    {
      "indent": 3,
      "text": "The following additional items need to be taken into consideration:",
      "ja": "次の追加項目を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Applications that want to support this will need to define a structure that allows for, and clearly identifies, both the COSE structure to be used with a given key and the structure and algorithm to be used for the secondary layer. The key for the secondary layer is computed as normal from the recipient layer.",
      "ja": "o これをサポートするアプリケーションでは、特定のキーで使用するCOSE構造と、セカンダリレイヤーで使用する構造とアルゴリズムの両方を許可し、明確に識別する構造を定義する必要があります。セカンダリレイヤーのキーは、受信者レイヤーから通常どおりに計算されます。"
    },
    {
      "indent": 3,
      "text": "The third case is having multiple implicit algorithm identifiers, but targeted at potentially unrelated layers or different COSE objects. There are a number of different scenarios where this might be applicable. Some of these scenarios are:",
      "ja": "3番目のケースは、複数の暗黙的なアルゴリズム識別子を持っていますが、潜在的に無関係なレイヤーまたは異なるCOSEオブジェクトを対象としています。これが当てはまる可能性のあるさまざまなシナリオがいくつかあります。これらのシナリオの一部は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Two contexts are distributed as a pair. Each of the contexts is for use with a COSE_Encrypt message. Each context will consist of distinct secret keys and IVs and potentially even different algorithms. One context is for sending messages from party A to party B, and the second context is for sending messages from party B to party A. This means that there is no chance for a reflection attack to occur as each party uses different secret keys to send its messages; a message that is reflected back to it would fail to decrypt.",
      "ja": "o 2つのコンテキストがペアで配布されます。各コンテキストは、COSE_Encryptメッセージで使用するためのものです。各コンテキストは、個別の秘密鍵とIV、および場合によっては異なるアルゴリズムで構成されます。 1つのコンテキストは、パーティーAからパーティーBにメッセージを送信するためのもので、2番目のコンテキストは、パーティーBからパーティーAにメッセージを送信するためのものです。これは、各パーティーが異なる秘密鍵を使用して送信するため、リフレクション攻撃が発生する可能性がないことを意味します。そのメッセージ;反映されたメッセージは、復号化に失敗します。"
    },
    {
      "indent": 3,
      "text": "o Two contexts are distributed as a pair. The first context is used for encryption of the message, and the second context is used to place a counter signature on the message. The intention is that the second context can be distributed to other entities independently of the first context. This allows these entities to validate that the message came from an individual without being able to decrypt the message and see the content.",
      "ja": "o 2つのコンテキストがペアで配布されます。最初のコンテキストはメッセージの暗号化に使用され、2番目のコンテキストはメッセージに副署名を付けるために使用されます。その意図は、2番目のコンテキストを最初のコンテキストとは無関係に他のエンティティーに配布できることです。これにより、これらのエンティティは、メッセージを復号化してコンテンツを表示することなく、メッセージが個人からのものであることを検証できます。"
    },
    {
      "indent": 3,
      "text": "o Two contexts are distributed as a pair. The first context contains a key for dealing with MACed messages, and the second context contains a key for dealing with encrypted messages. This allows for a unified distribution of keys to participants for different types of messages that have different keys, but where the keys may be used in a coordinated manner.",
      "ja": "o 2つのコンテキストがペアで配布されます。最初のコンテキストにはMACedメッセージを処理するためのキーが含まれ、2番目のコンテキストには暗号化されたメッセージを処理するためのキーが含まれます。これにより、異なるキーを持つさまざまなタイプのメッセージの参加者へのキーの統一された配布が可能になりますが、キーは調整された方法で使用できます。"
    },
    {
      "indent": 3,
      "text": "For these cases, the following additional items need to be considered:",
      "ja": "これらの場合、次の追加項目を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Applications need to ensure that the multiple contexts stay associated. If one of the contexts is invalidated for any reason, all of the contexts associated with it should also be invalidated.",
      "ja": "o アプリケーションは、複数のコンテキストが関連付けられたままであることを確認する必要があります。いずれかのコンテキストが何らかの理由で無効化された場合、それに関連付けられているすべてのコンテキストも無効化する必要があります。"
    },
    {
      "indent": 0,
      "text": "A.2. Counter Signature without Headers",
      "section_title": true,
      "ja": "A.2. ヘッダーなしの副署名"
    },
    {
      "indent": 3,
      "text": "There is a group of people who want to have a counter signature parameter that is directly tied to the value being signed, and thus the authenticated and unauthenticated buckets can be removed from the message being sent. The focus on this is an even smaller size, as all of the information on the process of creating the counter signature is implicit rather than being explicitly carried in the message. This includes not only the algorithm identifier as presented above, but also items such as the key identification, which is always external to the signature structure. This means that the entities that are doing the validation of the counter signature are required to infer which key is to be used from context rather than being explicit. One way of doing this would be to presume that all data coming from a specific port (or to a specific URL) is to be validated by a specific key. (Note that this does not require that the key identifier be part of the value signed as it does not serve a cryptographic purpose. If the key validates the counter signature, then it should be presumed that the entity associated with that key produced the signature.)",
      "ja": "署名される値に直接関連付けられているカウンター署名パラメーターを必要とする人々のグループがあるため、認証されたバケットと認証されていないバケットを送信されるメッセージから削除できます。カウンター署名の作成プロセスに関するすべての情報は、メッセージで明示的に伝えられるのではなく暗黙的であるため、これに重点が置かれます。これには、上記のアルゴリズム識別子だけでなく、常に署名構造の外部にあるキーIDなどの項目も含まれます。つまり、カウンター署名の検証を行うエンティティは、明示的にではなく、コンテキストから使用するキーを推測する必要があります。これを行う1つの方法は、特定のポート（または特定のURL）からのすべてのデータが特定のキーによって検証されると想定することです。 （これは、暗号化の目的を果たさないため、キー識別子が署名された値の一部である必要はないことに注意してください。キーがカウンター署名を検証する場合、そのキーに関連付けられたエンティティが署名を生成したと推定する必要があります。 ）"
    },
    {
      "indent": 3,
      "text": "When computing the signature for the bare counter signature header, the same Sig_structure defined in Section 4.4 is used. The sign_protected field is omitted, as there is no protected header field in this counter signature header. The value of \"CounterSignature0\" is placed in the context field of the Sig_stucture.",
      "ja": "ベアカウンターシグネチャヘッダーのシグネチャを計算するときは、セクション4.4で定義された同じSig_structureが使用されます。この副署名ヘッダーには保護ヘッダーフィールドがないため、sign_protectedフィールドは省略されています。 「CounterSignature0」の値は、Sig_stuctureのコンテキストフィールドに配置されます。"
    },
    {
      "indent": 3,
      "text": "+-------------------+-------+-------+-------+-----------------------+\n| Name              | Label | Value | Value | Description           |\n|                   |       | Type  |       |                       |\n+-------------------+-------+-------+-------+-----------------------+\n| CounterSignature0 | 9     | bstr  |       | Counter signature     |\n|                   |       |       |       | with implied signer   |\n|                   |       |       |       | and headers           |\n+-------------------+-------+-------+-------+-----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 27: Header Parameter for CounterSignature0",
      "ja": "表27：CounterSignature0のヘッダーパラメーター"
    },
    {
      "indent": 0,
      "text": "Appendix B. Two Layers of Recipient Information",
      "section_title": true,
      "ja": "付録B. 2層の受信者情報"
    },
    {
      "indent": 3,
      "text": "All of the currently defined recipient algorithm classes only use two layers of the COSE_Encrypt structure. The first layer is the message content, and the second layer is the content key encryption. However, if one uses a recipient algorithm such as the RSA Key Encapsulation Mechanism (RSA-KEM) (see Appendix A of RSA-KEM [RFC5990]), then it makes sense to have three layers of the COSE_Encrypt structure.",
      "ja": "現在定義されているすべての受信者アルゴリズムクラスは、COSE_Encrypt構造の2つのレイヤーのみを使用します。最初の層はメッセージコンテンツで、2番目の層はコンテンツキーの暗号化です。ただし、RSAキーカプセル化メカニズム（RSA-KEM）などの受信者アルゴリズム（RSA-KEM [RFC5990]の付録Aを参照）を使用する場合、COSE_Encrypt構造の3つの層があることは意味があります。"
    },
    {
      "indent": 3,
      "text": "These layers would be:",
      "ja": "これらのレイヤーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Layer 0: The content encryption layer. This layer contains the payload of the message.",
      "ja": "o レイヤー0：コンテンツ暗号化レイヤー。この層には、メッセージのペイロードが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Layer 1: The encryption of the CEK by a KEK.",
      "ja": "o レイヤー1：KEKによるCEKの暗号化。"
    },
    {
      "indent": 3,
      "text": "o Layer 2: The encryption of a long random secret using an RSA key and a key derivation function to convert that secret into the KEK.",
      "ja": "o レイヤー2：RSAキーとキー導出関数を使用して長いランダムシークレットを暗号化し、そのシークレットをKEKに変換します。"
    },
    {
      "indent": 3,
      "text": "This is an example of what a triple layer message would look like. The message has the following layers:",
      "ja": "これは、3層メッセージの例です。メッセージには次のレイヤーがあります。"
    },
    {
      "indent": 3,
      "text": "o Layer 0: Has a content encrypted with AES-GCM using a 128-bit key.",
      "ja": "o レイヤー0：128ビットキーを使用してAES-GCMで暗号化されたコンテンツがあります。"
    },
    {
      "indent": 3,
      "text": "o Layer 1: Uses the AES Key Wrap algorithm with a 128-bit key.",
      "ja": "o レイヤー1：AESキーラップアルゴリズムと128ビットキーを使用します。"
    },
    {
      "indent": 3,
      "text": "o Layer 2: Uses ECDH Ephemeral-Static direct to generate the layer 1 key.",
      "ja": "o レイヤー2：ECDH Ephemeral-Static directを使用してレイヤー1キーを生成します。"
    },
    {
      "indent": 3,
      "text": "In effect, this example is a decomposed version of using the ECDH-ES+A128KW algorithm.",
      "ja": "実際、この例はECDH-ES + A128KWアルゴリズムを使用した分解バージョンです。"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 183 bytes",
      "ja": "バイナリファイルのサイズは183バイト"
    },
    {
      "indent": 3,
      "text": "96(\n  [\n    / protected / h'a10101' / {\n        \\ alg \\ 1:1 \\ AES-GCM 128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'02d1f7e6f26c43d4868d87ce'\n    },\n    / ciphertext / h'64f84d913ba60a76070a9a48f26e97e863e2852948658f0\n811139868826e89218a75715b',\n    / recipients / [\n      [\n        / protected / h'',\n        / unprotected / {\n          / alg / 1:-3 / A128KW /\n        },\n        / ciphertext / h'dbd43c4e9d719c27c6275c67d628d493f090593db82\n18f11',\n        / recipients / [\n          [\n            / protected / h'a1013818' / {\n                \\ alg \\ 1:-25 \\ ECDH-ES + HKDF-256 \\\n              } / ,\n            / unprotected / {\n              / ephemeral / -1:{\n                / kty / 1:2,\n                / crv / -1:1,\n                / x / -2:h'b2add44368ea6d641f9ca9af308b4079aeb519f11\ne9b8a55a600b21233e86e68',\n                / y / -3:false\n              },\n              / kid / 4:'meriadoc.brandybuck@buckland.example'\n            },\n            / ciphertext / h''\n          ]\n        ]\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples",
      "section_title": true,
      "ja": "付録C.例"
    },
    {
      "indent": 3,
      "text": "This appendix includes a set of examples that show the different features and message types that have been defined in this document. To make the examples easier to read, they are presented using the extended CBOR diagnostic notation (defined in [CDDL]) rather than as a binary dump.",
      "ja": "この付録には、このドキュメントで定義されているさまざまな機能とメッセージタイプを示す一連の例が含まれています。例を読みやすくするために、バイナリダンプではなく拡張CBOR診断表記法（[CDDL]で定義）を使用して示しています。"
    },
    {
      "indent": 3,
      "text": "A GitHub project has been created at <https://github.com/cose-wg/ Examples> that contains not only the examples presented in this document, but a more complete set of testing examples as well. Each example is found in a JSON file that contains the inputs used to create the example, some of the intermediate values that can be used in debugging the example and the output of the example presented in both a hex and a CBOR diagnostic notation format. Some of the examples at the site are designed failure testing cases; these are clearly marked as such in the JSON file. If errors in the examples in this document are found, the examples on GitHub will be updated, and a note to that effect will be placed in the JSON file.",
      "ja": "<https://github.com/cose-wg/Examples>にGitHubプロジェクトが作成され、このドキュメントに示されている例だけでなく、より完全な一連のテスト例も含まれています。各例は、例の作成に使用された入力、例のデバッグに使用できるいくつかの中間値、および16進数とCBORの両方の診断表記形式で示された例の出力を含むJSONファイルにあります。サイトの例の一部は、設計された障害テストケースです。これらは、JSONファイルでそのように明確にマークされています。このドキュメントの例にエラーが見つかった場合、GitHubの例が更新され、その影響に関するメモがJSONファイルに配置されます。"
    },
    {
      "indent": 3,
      "text": "As noted, the examples are presented using the CBOR's diagnostic notation. A Ruby-based tool exists that can convert between the diagnostic notation and binary. This tool can be installed with the command line:",
      "ja": "前述のように、例はCBORの診断表記法を使用して示されています。診断表記とバイナリを変換できるRubyベースのツールが存在します。このツールはコマンドラインでインストールできます："
    },
    {
      "indent": 3,
      "text": "gem install cbor-diag",
      "ja": "gem install cbor-diag"
    },
    {
      "indent": 3,
      "text": "The diagnostic notation can be converted into binary files using the following command line:",
      "ja": "診断表記は、次のコマンドラインを使用してバイナリファイルに変換できます。"
    },
    {
      "indent": 3,
      "text": "diag2cbor.rb < inputfile > outputfile",
      "ja": "diag2cbor.rb <inputfile> outputfile"
    },
    {
      "indent": 3,
      "text": "The examples can be extracted from the XML version of this document via an XPath expression as all of the artwork is tagged with the attribute type='CBORdiag'. (Depending on the XPath evaluator one is using, it may be necessary to deal with &gt; as an entity.)",
      "ja": "すべてのアートワークに属性type = 'CBORdiag'がタグ付けされているため、XPath式を介してこのドキュメントのXMLバージョンから例を抽出できます。 （使用しているXPathエバリュエーターによっては、エンティティとして＆gt;を処理する必要がある場合があります。）"
    },
    {
      "indent": 3,
      "text": "//artwork[@type='CDDL']/text()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1. Examples of Signed Messages",
      "section_title": true,
      "ja": "C.1. 署名付きメッセージの例"
    },
    {
      "indent": 0,
      "text": "C.1.1. Single Signature",
      "section_title": true,
      "ja": "C.1.1. 単一の署名"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o Signature Algorithm: ECDSA w/ SHA-256, Curve P-256",
      "ja": "o 署名アルゴリズム：ECDSA with / SHA256、Curve P-256"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 103 bytes",
      "ja": "バイナリファイルのサイズは103バイトです"
    },
    {
      "indent": 3,
      "text": "98(\n  [\n    / protected / h'',\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / signatures / [\n      [\n        / protected / h'a10126' / {\n            \\ alg \\ 1:-7 \\ ECDSA 256 \\\n          } / ,\n        / unprotected / {\n          / kid / 4:'11'\n        },\n        / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n98f53afd2fa0f30a'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.2. Multiple Signers",
      "section_title": true,
      "ja": "C.1.2. 複数の署名者"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o Signature Algorithm: ECDSA w/ SHA-256, Curve P-256",
      "ja": "o 署名アルゴリズム：ECDSA with / SHA256、Curve P-256"
    },
    {
      "indent": 0,
      "text": " o Signature Algorithm: ECDSA w/ SHA-512, Curve P-521 Size of binary file is 277 bytes",
      "ja": "o署名アルゴリズム：ECDSA w / SHA-512、曲線P-521バイナリファイルのサイズは277バイト"
    },
    {
      "indent": 3,
      "text": "98(\n  [\n    / protected / h'',\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / signatures / [\n      [\n        / protected / h'a10126' / {\n            \\ alg \\ 1:-7 \\ ECDSA 256 \\\n          } / ,\n        / unprotected / {\n          / kid / 4:'11'\n        },\n        / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n98f53afd2fa0f30a'\n      ],\n      [\n        / protected / h'a1013823' / {\n            \\ alg \\ 1:-36\n          } / ,\n        / unprotected / {\n          / kid / 4:'bilbo.baggins@hobbiton.example'\n        },\n        / signature / h'00a2d28a7c2bdb1587877420f65adf7d0b9a06635dd1\nde64bb62974c863f0b160dd2163734034e6ac003b01e8705524c5c4ca479a952f024\n7ee8cb0b4fb7397ba08d009e0c8bf482270cc5771aa143966e5a469a09f613488030\nc5b07ec6d722e3835adb5b2d8c44e95ffb13877dd2582866883535de3bb03d01753f\n83ab87bb4f7a0297'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.3. Counter Signature",
      "section_title": true,
      "ja": "C.1.3. 副署名"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o Signature Algorithm: ECDSA w/ SHA-256, Curve P-256",
      "ja": "o 署名アルゴリズム：ECDSA with / SHA256、Curve P-256"
    },
    {
      "indent": 3,
      "text": "o The same parameters are used for both the signature and the counter signature.",
      "ja": "o 署名と副署名の両方に同じパラメーターが使用されます。"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 180 bytes",
      "ja": "バイナリファイルのサイズは180バイト"
    },
    {
      "indent": 3,
      "text": "98(\n  [\n    / protected / h'',\n    / unprotected / {\n      / countersign / 7:[\n        / protected / h'a10126' / {\n            \\ alg \\ 1:-7 \\ ECDSA 256 \\\n          } / ,\n        / unprotected / {\n          / kid / 4:'11'\n        },\n        / signature / h'5ac05e289d5d0e1b0a7f048a5d2b643813ded50bc9e4\n9220f4f7278f85f19d4a77d655c9d3b51e805a74b099e1e085aacd97fc29d72f887e\n8802bb6650cceb2c'\n      ]\n    },\n    / payload / 'This is the content.',\n    / signatures / [\n      [\n        / protected / h'a10126' / {\n            \\ alg \\ 1:-7 \\ ECDSA 256 \\\n          } / ,\n        / unprotected / {\n          / kid / 4:'11'\n        },\n        / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n98f53afd2fa0f30a'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.4. Signature with Criticality",
      "section_title": true,
      "ja": "C.1.4. 重要度のある署名"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o Signature Algorithm: ECDSA w/ SHA-256, Curve P-256",
      "ja": "o 署名アルゴリズム：ECDSA with / SHA256、Curve P-256"
    },
    {
      "indent": 0,
      "text": " o There is a criticality marker on the \"reserved\" header parameter Size of binary file is 125 bytes",
      "ja": "o「予約済み」ヘッダーパラメータに重要度マーカーがあります。バイナリファイルのサイズは125バイトです"
    },
    {
      "indent": 3,
      "text": "98(\n  [\n    / protected / h'a2687265736572766564f40281687265736572766564' /\n{\n        \"reserved\":false,\n        \\ crit \\ 2:[\n          \"reserved\"\n        ]\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / signatures / [\n      [\n        / protected / h'a10126' / {\n            \\ alg \\ 1:-7 \\ ECDSA 256 \\\n          } / ,\n        / unprotected / {\n          / kid / 4:'11'\n        },\n        / signature / h'3fc54702aa56e1b2cb20284294c9106a63f91bac658d\n69351210a031d8fc7c5ff3e4be39445b1a3e83e1510d1aca2f2e8a7c081c7645042b\n18aba9d1fad1bd9c'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. Single Signer Examples",
      "section_title": true,
      "ja": "C.2. シングル署名者の例"
    },
    {
      "indent": 0,
      "text": "C.2.1. Single ECDSA Signature",
      "section_title": true,
      "ja": "C.2.1. 単一のECDSA署名"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 0,
      "text": " o Signature Algorithm: ECDSA w/ SHA-256, Curve P-256 Size of binary file is 98 bytes",
      "ja": "o署名アルゴリズム：ECDSA w / SHA-256、Curve P-256バイナリファイルのサイズは98バイト"
    },
    {
      "indent": 3,
      "text": "18(\n  [\n    / protected / h'a10126' / {\n        \\ alg \\ 1:-7 \\ ECDSA 256 \\\n      } / ,\n    / unprotected / {\n      / kid / 4:'11'\n    },\n    / payload / 'This is the content.',\n    / signature / h'8eb33e4ca31d1c465ab05aac34cc6b23d58fef5c083106c4\nd25a91aef0b0117e2af9a291aa32e14ab834dc56ed2a223444547e01f11d3b0916e5\na4c345cacb36'\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3. Examples of Enveloped Messages",
      "section_title": true,
      "ja": "C.3. エンベロープメッセージの例"
    },
    {
      "indent": 0,
      "text": "C.3.1. Direct ECDH",
      "section_title": true,
      "ja": "C.3.1. 直接ECDH"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o CEK: AES-GCM w/ 128-bit key",
      "ja": "o CEK：AES-GCM w / 128ビットキー"
    },
    {
      "indent": 0,
      "text": " o Recipient class: ECDH Ephemeral-Static, Curve P-256 Size of binary file is 151 bytes",
      "ja": "o受信者クラス：ECDH Ephemeral-Static、Curve P-256バイナリファイルのサイズは151バイトです。"
    },
    {
      "indent": 3,
      "text": "96(\n  [\n    / protected / h'a10101' / {\n        \\ alg \\ 1:1 \\ AES-GCM 128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'c9cf4df2fe6c632bf7886413'\n    },\n    / ciphertext / h'7adbe2709ca818fb415f1e5df66f4e1a51053ba6d65a1a0\nc52a357da7a644b8070a151b0',\n    / recipients / [\n      [\n        / protected / h'a1013818' / {\n            \\ alg \\ 1:-25 \\ ECDH-ES + HKDF-256 \\\n          } / ,\n        / unprotected / {\n          / ephemeral / -1:{\n            / kty / 1:2,\n            / crv / -1:1,\n            / x / -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbf\nbf054e1c7b4d91d6280',\n            / y / -3:true\n          },\n          / kid / 4:'meriadoc.brandybuck@buckland.example'\n        },\n        / ciphertext / h''\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3.2. Direct Plus Key Derivation",
      "section_title": true,
      "ja": "C.3.2. ダイレクトプラスキーの派生"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o CEK: AES-CCM w/ 128-bit key, truncate the tag to 64 bits",
      "ja": "o CEK：AES-CCM（128ビットキー付き）、タグを64ビットに切り捨て"
    },
    {
      "indent": 3,
      "text": "o Recipient class: Use HKDF on a shared secret with the following implicit fields as part of the context.",
      "ja": "o 受信者クラス：コンテキストの一部として次の暗黙的なフィールドを含む共有シークレットでHKDFを使用します。"
    },
    {
      "indent": 6,
      "text": "* salt: \"aabbccddeeffgghh\"",
      "ja": "* ソルト：「aabbccddeeffgghh」"
    },
    {
      "indent": 6,
      "text": "* PartyU identity: \"lighting-client\"",
      "ja": "* PartyU ID：「照明クライアント」"
    },
    {
      "indent": 6,
      "text": "* PartyV identity: \"lighting-server\"",
      "ja": "* PartyV ID：「照明サーバー」"
    },
    {
      "indent": 6,
      "text": "* Supplementary Public Other: \"Encryption Example 02\"",
      "ja": "* 補足公開その他：「暗号化の例02」"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 91 bytes",
      "ja": "バイナリファイルのサイズは91バイト"
    },
    {
      "indent": 3,
      "text": "96(\n  [\n    / protected / h'a1010a' / {\n        \\ alg \\ 1:10 \\ AES-CCM-16-64-128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'89f52f65a1c580933b5261a76c'\n    },\n    / ciphertext / h'753548a19b1307084ca7b2056924ed95f2e3b17006dfe93\n1b687b847',\n    / recipients / [\n      [\n        / protected / h'a10129' / {\n            \\ alg \\ 1:-10\n          } / ,\n        / unprotected / {\n          / salt / -20:'aabbccddeeffgghh',\n          / kid / 4:'our-secret'\n        },\n        / ciphertext / h''\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3.3. Counter Signature on Encrypted Content",
      "section_title": true,
      "ja": "C.3.3. 暗号化されたコンテンツの副署名"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o CEK: AES-GCM w/ 128-bit key",
      "ja": "o CEK：AES-GCM w / 128ビットキー"
    },
    {
      "indent": 0,
      "text": " o Recipient class: ECDH Ephemeral-Static, Curve P-256 Size of binary file is 326 bytes",
      "ja": "o受信者クラス：ECDH Ephemeral-Static、Curve P-256バイナリファイルのサイズは326バイトです。"
    },
    {
      "indent": 3,
      "text": "96(\n  [\n    / protected / h'a10101' / {\n        \\ alg \\ 1:1 \\ AES-GCM 128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'c9cf4df2fe6c632bf7886413',\n      / countersign / 7:[\n        / protected / h'a1013823' / {\n            \\ alg \\ 1:-36\n          } / ,\n        / unprotected / {\n          / kid / 4:'bilbo.baggins@hobbiton.example'\n        },\n        / signature / h'00929663c8789bb28177ae28467e66377da12302d7f9\n594d2999afa5dfa531294f8896f2b6cdf1740014f4c7f1a358e3a6cf57f4ed6fb02f\ncf8f7aa989f5dfd07f0700a3a7d8f3c604ba70fa9411bd10c2591b483e1d2c31de00\n3183e434d8fba18f17a4c7e3dfa003ac1cf3d30d44d2533c4989d3ac38c38b71481c\nc3430c9d65e7ddff'\n      ]\n    },\n    / ciphertext / h'7adbe2709ca818fb415f1e5df66f4e1a51053ba6d65a1a0\nc52a357da7a644b8070a151b0',\n    / recipients / [\n      [\n        / protected / h'a1013818' / {\n            \\ alg \\ 1:-25 \\ ECDH-ES + HKDF-256 \\\n          } / ,\n        / unprotected / {\n          / ephemeral / -1:{\n            / kty / 1:2,\n            / crv / -1:1,\n            / x / -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbf\nbf054e1c7b4d91d6280',\n            / y / -3:true\n          },\n          / kid / 4:'meriadoc.brandybuck@buckland.example'\n        },\n        / ciphertext / h''\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3.4. Encrypted Content with External Data",
      "section_title": true,
      "ja": "C.3.4. 外部データを含む暗号化されたコンテンツ"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o CEK: AES-GCM w/ 128-bit key",
      "ja": "o CEK：AES-GCM w / 128ビットキー"
    },
    {
      "indent": 3,
      "text": "o Recipient class: ECDH static-Static, Curve P-256 with AES Key Wrap",
      "ja": "o 受信者クラス：ECDH静的-静的、AESキーラップ付きの曲線P-256"
    },
    {
      "indent": 3,
      "text": "o Externally Supplied AAD: h'0011bbcc22dd44ee55ff660077'",
      "ja": "o 外部供給AAD：h'0011bbcc22dd44ee55ff660077 '"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 173 bytes",
      "ja": "バイナリファイルのサイズは173バイト"
    },
    {
      "indent": 3,
      "text": "96(\n  [\n    / protected / h'a10101' / {\n        \\ alg \\ 1:1 \\ AES-GCM 128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'02d1f7e6f26c43d4868d87ce'\n    },\n    / ciphertext / h'64f84d913ba60a76070a9a48f26e97e863e28529d8f5335\ne5f0165eee976b4a5f6c6f09d',\n    / recipients / [\n      [\n        / protected / h'a101381f' / {\n            \\ alg \\ 1:-32 \\ ECHD-SS+A128KW \\\n          } / ,\n        / unprotected / {\n          / static kid / -3:'peregrin.took@tuckborough.example',\n          / kid / 4:'meriadoc.brandybuck@buckland.example',\n          / U nonce / -22:h'0101'\n        },\n        / ciphertext / h'41e0d76f579dbd0d936a662d54d8582037de2e366fd\ne1c62'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.4. Examples of Encrypted Messages",
      "section_title": true,
      "ja": "C.4. 暗号化されたメッセージの例"
    },
    {
      "indent": 0,
      "text": "C.4.1. Simple Encrypted Message",
      "section_title": true,
      "ja": "C.4.1. 単純な暗号化されたメッセージ"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 0,
      "text": " o CEK: AES-CCM w/ 128-bit key and a 64-bit tag Size of binary file is 52 bytes",
      "ja": "o CEK：128ビットキーと64ビットタグ付きのAES-CCMバイナリファイルのサイズは52バイト"
    },
    {
      "indent": 3,
      "text": "16(\n  [\n    / protected / h'a1010a' / {\n        \\ alg \\ 1:10 \\ AES-CCM-16-64-128 \\\n      } / ,\n    / unprotected / {\n      / iv / 5:h'89f52f65a1c580933b5261a78c'\n    },\n    / ciphertext / h'5974e1b99a3a4cc09a659aa2e9e7fff161d38ce71cb45ce\n460ffb569'\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.4.2. Encrypted Message with a Partial IV",
      "section_title": true,
      "ja": "C.4.2. 部分IVの暗号化メッセージ"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o CEK: AES-CCM w/ 128-bit key and a 64-bit tag",
      "ja": "o CEK：AES-CCM（128ビットキーと64ビットタグ付き）"
    },
    {
      "indent": 3,
      "text": "o Prefix for IV is 89F52F65A1C580933B52",
      "ja": "o IVのプレフィックスは89F52F65A1C580933B52です"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 41 bytes",
      "ja": "バイナリファイルのサイズは41バイトです。"
    },
    {
      "indent": 3,
      "text": "16(\n  [\n    / protected / h'a1010a' / {\n        \\ alg \\ 1:10 \\ AES-CCM-16-64-128 \\\n      } / ,\n    / unprotected / {\n      / partial iv / 6:h'61a7'\n    },\n    / ciphertext / h'252a8911d465c125b6764739700f0141ed09192de139e05\n3bd09abca'\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5. Examples of MACed Messages",
      "section_title": true,
      "ja": "C.5. MACedメッセージの例"
    },
    {
      "indent": 0,
      "text": "C.5.1. Shared Secret Direct MAC",
      "section_title": true,
      "ja": "C.5.1. 共有秘密直接MAC"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o MAC: AES-CMAC, 256-bit key, truncated to 64 bits",
      "ja": "o MAC：AES-CMAC、256ビットキー、64ビットに切り捨て"
    },
    {
      "indent": 0,
      "text": " o Recipient class: direct shared secret Size of binary file is 57 bytes",
      "ja": "o受信者クラス：直接共有秘密バイナリファイルのサイズは57バイトです"
    },
    {
      "indent": 3,
      "text": "97(\n  [\n    / protected / h'a1010f' / {\n        \\ alg \\ 1:15 \\ AES-CBC-MAC-256//64 \\\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / tag / h'9e1226ba1f81b848',\n    / recipients / [\n      [\n        / protected / h'',\n        / unprotected / {\n          / alg / 1:-6 / direct /,\n          / kid / 4:'our-secret'\n        },\n        / ciphertext / h''\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5.2. ECDH Direct MAC",
      "section_title": true,
      "ja": "C.5.2. ECDHダイレクトMAC"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o MAC: HMAC w/SHA-256, 256-bit key",
      "ja": "o MAC：HMAC with / SHA-256、256ビットキー"
    },
    {
      "indent": 3,
      "text": "o Recipient class: ECDH key agreement, two static keys, HKDF w/ context structure",
      "ja": "o 受信者クラス：ECDHキー合意、2つの静的キー、HKDF（コンテキスト構造あり）"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 214 bytes",
      "ja": "バイナリファイルのサイズは214バイトです。"
    },
    {
      "indent": 3,
      "text": "97(\n  [\n    / protected / h'a10105' / {\n        \\ alg \\ 1:5 \\ HMAC 256//256 \\\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / tag / h'81a03448acd3d305376eaa11fb3fe416a955be2cbe7ec96f012c99\n4bc3f16a41',\n    / recipients / [\n      [\n        / protected / h'a101381a' / {\n            \\ alg \\ 1:-27 \\ ECDH-SS + HKDF-256 \\\n          } / ,\n        / unprotected / {\n          / static kid / -3:'peregrin.took@tuckborough.example',\n          / kid / 4:'meriadoc.brandybuck@buckland.example',\n          / U nonce / -22:h'4d8553e7e74f3c6a3a9dd3ef286a8195cbf8a23d\n19558ccfec7d34b824f42d92bd06bd2c7f0271f0214e141fb779ae2856abf585a583\n68b017e7f2a9e5ce4db5'\n        },\n        / ciphertext / h''\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5.3. Wrapped MAC",
      "section_title": true,
      "ja": "C.5.3. ラップされたMAC"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o MAC: AES-MAC, 128-bit key, truncated to 64 bits",
      "ja": "o MAC：AES-MAC、128ビットキー、64ビットに切り捨て"
    },
    {
      "indent": 0,
      "text": " o Recipient class: AES Key Wrap w/ a pre-shared 256-bit key Size of binary file is 109 bytes",
      "ja": "o受信者クラス：AESキーラップ（事前共有256ビットキー付き）バイナリファイルのサイズは109バイト"
    },
    {
      "indent": 3,
      "text": "97(\n  [\n    / protected / h'a1010e' / {\n        \\ alg \\ 1:14 \\ AES-CBC-MAC-128//64 \\\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / tag / h'36f5afaf0bab5d43',\n    / recipients / [\n      [\n        / protected / h'',\n        / unprotected / {\n          / alg / 1:-5 / A256KW /,\n          / kid / 4:'018c0ae5-4d9b-471b-bfd6-eef314bc7037'\n        },\n        / ciphertext / h'711ab0dc2fc4585dce27effa6781c8093eba906f227\nb6eb0'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5.4. Multi-Recipient MACed Message",
      "section_title": true,
      "ja": "C.5.4. 複数の受信者のMACedメッセージ"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o MAC: HMAC w/ SHA-256, 128-bit key",
      "ja": "o MAC：HMAC with / SHA256、128ビットキー"
    },
    {
      "indent": 3,
      "text": "o Recipient class: Uses three different methods",
      "ja": "o 受信者クラス：3つの異なるメソッドを使用します"
    },
    {
      "indent": 6,
      "text": "1. ECDH Ephemeral-Static, Curve P-521, AES Key Wrap w/ 128-bit key",
      "ja": "1. ECDHエフェメラルスタティック、カーブP-521、AESキーラップ、128ビットキー"
    },
    {
      "indent": 6,
      "text": "2. AES Key Wrap w/ 256-bit key",
      "ja": "2. 256ビットキーを使用したAESキーラップ"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 309 bytes",
      "ja": "バイナリファイルのサイズは309バイトです"
    },
    {
      "indent": 3,
      "text": "97(\n  [\n    / protected / h'a10105' / {\n        \\ alg \\ 1:5 \\ HMAC 256//256 \\\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / tag / h'bf48235e809b5c42e995f2b7d5fa13620e7ed834e337f6aa43df16\n1e49e9323e',\n    / recipients / [\n      [\n        / protected / h'a101381c' / {\n            \\ alg \\ 1:-29 \\ ECHD-ES+A128KW \\\n          } / ,\n        / unprotected / {\n          / ephemeral / -1:{\n            / kty / 1:2,\n            / crv / -1:3,\n            / x / -2:h'0043b12669acac3fd27898ffba0bcd2e6c366d53bc4db\n71f909a759304acfb5e18cdc7ba0b13ff8c7636271a6924b1ac63c02688075b55ef2\nd613574e7dc242f79c3',\n            / y / -3:true\n          },\n          / kid / 4:'bilbo.baggins@hobbiton.example'\n        },\n        / ciphertext / h'339bc4f79984cdc6b3e6ce5f315a4c7d2b0ac466fce\na69e8c07dfbca5bb1f661bc5f8e0df9e3eff5'\n      ],\n      [\n        / protected / h'',\n        / unprotected / {\n          / alg / 1:-5 / A256KW /,\n          / kid / 4:'018c0ae5-4d9b-471b-bfd6-eef314bc7037'\n        },\n        / ciphertext / h'0b2c7cfce04e98276342d6476a7723c090dfdd15f9a\n518e7736549e998370695e6d6a83b4ae507bb'\n      ]\n    ]\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.6. Examples of MAC0 Messages",
      "section_title": true,
      "ja": "C.6. MAC0メッセージの例"
    },
    {
      "indent": 0,
      "text": "C.6.1. Shared Secret Direct MAC",
      "section_title": true,
      "ja": "C.6.1. 共有秘密直接MAC"
    },
    {
      "indent": 3,
      "text": "This example uses the following:",
      "ja": "この例では、以下を使用します。"
    },
    {
      "indent": 3,
      "text": "o MAC: AES-CMAC, 256-bit key, truncated to 64 bits",
      "ja": "o MAC：AES-CMAC、256ビットキー、64ビットに切り捨て"
    },
    {
      "indent": 3,
      "text": "o Recipient class: direct shared secret",
      "ja": "o 受信者クラス：直接共有秘密"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 37 bytes",
      "ja": "バイナリファイルのサイズは37バイト"
    },
    {
      "indent": 3,
      "text": "17(\n  [\n    / protected / h'a1010f' / {\n        \\ alg \\ 1:15 \\ AES-CBC-MAC-256//64 \\\n      } / ,\n    / unprotected / {},\n    / payload / 'This is the content.',\n    / tag / h'726043745027214f'\n  ]\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this example uses the same inputs as Appendix C.5.1.",
      "ja": "この例では、付録C.5.1と同じ入力を使用しています。"
    },
    {
      "indent": 0,
      "text": "C.7. COSE Keys",
      "section_title": true,
      "ja": "C.7. COSEキー"
    },
    {
      "indent": 0,
      "text": "C.7.1. Public Keys",
      "section_title": true,
      "ja": "C.7.1. 公開鍵"
    },
    {
      "indent": 3,
      "text": "This is an example of a COSE Key Set. This example includes the public keys for all of the previous examples.",
      "ja": "これは、COSEキーセットの例です。この例には、前のすべての例の公開鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "In order the keys are:",
      "ja": "キーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"meriadoc.brandybuck@buckland.example\"",
      "ja": "o 「meriadoc.brandybuck@buckland.example」のキッドを持つECキー"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"peregrin.took@tuckborough.example\"",
      "ja": "o 「peregrin.took@tuckborough.example」のキッドを持つECキー"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"bilbo.baggins@hobbiton.example\"",
      "ja": "o 「bilbo.baggins@hobbiton.example」のキッドを持つECキー"
    },
    {
      "indent": 0,
      "text": " o An EC key with a kid of \"11\" Size of binary file is 481 bytes",
      "ja": "o「11」の子供を持つECキーバイナリファイルのサイズは481バイトです"
    },
    {
      "indent": 3,
      "text": "[\n  {\n    -1:1,\n    -2:h'65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c0\n8551d',\n    -3:h'1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd008\n4d19c',\n    1:2,\n    2:'meriadoc.brandybuck@buckland.example'\n  },\n  {\n    -1:1,\n    -2:h'bac5b11cad8f99f9c72b05cf4b9e26d244dc189f745228255a219a86d6a\n09eff',\n    -3:h'20138bf82dc1b6d562be0fa54ab7804a3a64b6d72ccfed6b6fb6ed28bbf\nc117e',\n    1:2,\n    2:'11'\n  },\n  {\n    -1:3,\n    -2:h'0072992cb3ac08ecf3e5c63dedec0d51a8c1f79ef2f82f94f3c737bf5de\n7986671eac625fe8257bbd0394644caaa3aaf8f27a4585fbbcad0f2457620085e5c8\nf42ad',\n    -3:h'01dca6947bce88bc5790485ac97427342bc35f887d86d65a089377e247e\n60baa55e4e8501e2ada5724ac51d6909008033ebc10ac999b9d7f5cc2519f3fe1ea1\nd9475',\n    1:2,\n    2:'bilbo.baggins@hobbiton.example'\n  },\n  {\n    -1:1,\n    -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbfbf054e1c7b4d91\nd6280',\n    -3:h'f01400b089867804b8e9fc96c3932161f1934f4223069170d924b7e03bf\n822bb',\n    1:2,\n    2:'peregrin.took@tuckborough.example'\n  }\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.7.2. Private Keys",
      "section_title": true,
      "ja": "C.7.2. 秘密鍵"
    },
    {
      "indent": 3,
      "text": "This is an example of a COSE Key Set. This example includes the private keys for all of the previous examples.",
      "ja": "これは、COSEキーセットの例です。この例には、前のすべての例の秘密鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "In order the keys are:",
      "ja": "キーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"meriadoc.brandybuck@buckland.example\"",
      "ja": "o 「meriadoc.brandybuck@buckland.example」のキッドを持つECキー"
    },
    {
      "indent": 3,
      "text": "o A shared-secret key with a kid of \"our-secret\"",
      "ja": "o 「私たちの秘密」の子供との共有秘密鍵"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"peregrin.took@tuckborough.example\"",
      "ja": "o 「peregrin.took@tuckborough.example」のキッドを持つECキー"
    },
    {
      "indent": 3,
      "text": "o A shared-secret key with a kid of \"018c0ae5-4d9b-471b-bfd6-eef314bc7037\"",
      "ja": "o 「018c0ae5-4d9b-471b-bfd6-eef314bc7037」のキッドを持つ共有秘密鍵"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"bilbo.baggins@hobbiton.example\"",
      "ja": "o 「bilbo.baggins@hobbiton.example」のキッドを持つECキー"
    },
    {
      "indent": 3,
      "text": "o An EC key with a kid of \"11\"",
      "ja": "o 「11」の子供を持つECキー"
    },
    {
      "indent": 3,
      "text": "Size of binary file is 816 bytes",
      "ja": "バイナリファイルのサイズは816バイト"
    },
    {
      "indent": 3,
      "text": "[\n  {\n    1:2,\n    2:'meriadoc.brandybuck@buckland.example',\n    -1:1,\n    -2:h'65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c0\n8551d',\n    -3:h'1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd008\n4d19c',\n    -4:h'aff907c99f9ad3aae6c4cdf21122bce2bd68b5283e6907154ad911840fa\n208cf'\n  },\n  {\n    1:2,\n    2:'11',\n    -1:1,\n    -2:h'bac5b11cad8f99f9c72b05cf4b9e26d244dc189f745228255a219a86d6a\n09eff',\n    -3:h'20138bf82dc1b6d562be0fa54ab7804a3a64b6d72ccfed6b6fb6ed28bbf\nc117e',\n    -4:h'57c92077664146e876760c9520d054aa93c3afb04e306705db609030850\n7b4d3'\n  },\n  {\n    1:2,\n    2:'bilbo.baggins@hobbiton.example',",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    -1:3,\n    -2:h'0072992cb3ac08ecf3e5c63dedec0d51a8c1f79ef2f82f94f3c737bf5de\n7986671eac625fe8257bbd0394644caaa3aaf8f27a4585fbbcad0f2457620085e5c8\nf42ad',\n    -3:h'01dca6947bce88bc5790485ac97427342bc35f887d86d65a089377e247e\n60baa55e4e8501e2ada5724ac51d6909008033ebc10ac999b9d7f5cc2519f3fe1ea1\nd9475',\n    -4:h'00085138ddabf5ca975f5860f91a08e91d6d5f9a76ad4018766a476680b\n55cd339e8ab6c72b5facdb2a2a50ac25bd086647dd3e2e6e99e84ca2c3609fdf177f\neb26d'\n  },\n  {\n    1:4,\n    2:'our-secret',\n    -1:h'849b57219dae48de646d07dbb533566e976686457c1491be3a76dcea6c4\n27188'\n  },\n  {\n    1:2,\n    -1:1,\n    2:'peregrin.took@tuckborough.example',\n    -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbfbf054e1c7b4d91\nd6280',\n    -3:h'f01400b089867804b8e9fc96c3932161f1934f4223069170d924b7e03bf\n822bb',\n    -4:h'02d1f7e6f26c43d4868d87ceb2353161740aacf1f7163647984b522a848\ndf1c3'\n  },\n  {\n    1:4,\n    2:'our-secret2',\n    -1:h'849b5786457c1491be3a76dcea6c4271'\n  },\n  {\n    1:4,\n    2:'018c0ae5-4d9b-471b-bfd6-eef314bc7037',\n    -1:h'849b57219dae48de646d07dbb533566e976686457c1491be3a76dcea6c4\n27188'\n  }\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a product of the COSE working group of the IETF.",
      "ja": "このドキュメントは、IETFのCOSEワーキンググループの製品です。"
    },
    {
      "indent": 3,
      "text": "The following individuals are to blame for getting me started on this project in the first place: Richard Barnes, Matt Miller, and Martin Thomson.",
      "ja": "最初にこのプロジェクトに着手したのは、Richard Barnes、Matt Miller、およびMartin Thomsonです。"
    },
    {
      "indent": 3,
      "text": "The initial version of the specification was based to some degree on the outputs of the JOSE and S/MIME working groups.",
      "ja": "仕様の最初のバージョンは、JOSEおよびS / MIMEワーキンググループの出力にある程度基づいていました。"
    },
    {
      "indent": 3,
      "text": "The following individuals provided input into the final form of the document: Carsten Bormann, John Bradley, Brain Campbell, Michael B. Jones, Ilari Liusvaara, Francesca Palombini, Ludwig Seitz, and Goran Selander.",
      "ja": "次の個人がドキュメントの最終フォームに入力を提供しました：カーステンボルマン、ジョンブラッドリー、ブレインキャンベル、マイケルB.ジョーンズ、イラリリスヴァーラ、フランチェスカパロンビーニ、ルートヴィヒザイツ、ゴランセランダー。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jim Schaad August Cellars",
      "ja": "ジムシャードアウグストセラーズ"
    },
    {
      "indent": 3,
      "text": "Email: ietf@augustcellars.com",
      "raw": true,
      "ja": ""
    }
  ]
}