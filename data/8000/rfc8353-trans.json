{
  "title": {
    "text": "RFC 8353 - Generic Security Service API Version 2: Java Bindings Update",
    "ja": "RFC 8353 - Generic Security Service APIバージョン2：Javaバインディングの更新"
  },
  "number": 8353,
  "created_at": "2020-08-23 16:45:35.187040+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       M. Upadhyay\nRequest for Comments: 8353                                        Google\nObsoletes: 5653                                               S. Malkani\nCategory: Standards Track                                  ActivIdentity\nISSN: 2070-1721                                                  W. Wang\n                                                                  Oracle\n                                                                May 2018",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Generic Security Service API Version 2: Java Bindings Update",
      "ja": "Generic Security Service APIバージョン2：Javaバインディングの更新"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Generic Security Services Application Programming Interface (GSS-API) offers application programmers uniform access to security services atop a variety of underlying cryptographic mechanisms. This document updates the Java bindings for the GSS-API that are specified in \"Generic Security Service API Version 2: Java Bindings Update\" (RFC 5653). This document obsoletes RFC 5653 by adding a new output token field to the GSSException class so that when the initSecContext or acceptSecContext methods of the GSSContext class fail, it has a chance to emit an error token that can be sent to the peer for debugging or informational purpose. The stream-based GSSContext methods are also removed in this version.",
      "ja": "Generic Security Servicesアプリケーションプログラミングインターフェイス（GSS-API）は、アプリケーションプログラマーに、さまざまな基盤となる暗号化メカニズムの上にあるセキュリティサービスへの統一的なアクセスを提供します。このドキュメントは、「Generic Security Service APIバージョン2：Javaバインディングの更新」（RFC 5653）で指定されているGSS-APIのJavaバインディングを更新します。このドキュメントでは、GSSExceptionクラスに新しい出力トークンフィールドを追加することでRFC 5653を廃止し、GSSContextクラスのinitSecContextまたはacceptSecContextメソッドが失敗したときに、デバッグまたは情報提供のためにピアに送信できるエラートークンを発行する機会を提供しています目的。このバージョンでは、ストリームベースのGSSContextメソッドも削除されています。"
    },
    {
      "indent": 3,
      "text": "The GSS-API is described at a language-independent conceptual level in \"Generic Security Service Application Program Interface Version 2, Update 1\" (RFC 2743). The GSS-API allows a caller application to authenticate a principal identity, to delegate rights to a peer, and to apply security services such as confidentiality and integrity on a per-message basis. Examples of security mechanisms defined for GSS-API are \"The Simple Public-Key GSS-API Mechanism (SPKM)\" (RFC 2025) and \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\" (RFC 4121).",
      "ja": "GSS-APIは、「Generic Security Service Application Program Interface Version 2、Update 1」（RFC 2743）で言語に依存しない概念レベルで記述されています。 GSS-APIを使用すると、呼び出し元アプリケーションはプリンシパルIDを認証し、ピアに権限を委任し、メッセージごとに機密性や整合性などのセキュリティサービスを適用できます。 GSS-APIに定義されているセキュリティメカニズムの例は、「単純な公開鍵GSS-APIメカニズム（SPKM）」（RFC 2025）と「Kerberosバージョン5汎用セキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）メカニズム：バージョン2」です。 （RFC 4121）。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8353.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8353で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。 IETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得せずに、このドキュメントをIETF標準プロセス外で変更したり、その派生物をIETF標準プロセス外で作成したりすることはできません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   6\n2.  Notational Conventions  . . . . . . . . . . . . . . . . . . .   7\n3.  GSS-API Operational Paradigm  . . . . . . . . . . . . . . . .   7\n4.  Additional Controls . . . . . . . . . . . . . . . . . . . . .   9\n  4.1.  Delegation  . . . . . . . . . . . . . . . . . . . . . . .  10\n  4.2.  Mutual Authentication . . . . . . . . . . . . . . . . . .  11\n  4.3.  Replay and Out-of-Sequence Detection  . . . . . . . . . .  11\n  4.4.  Anonymous Authentication  . . . . . . . . . . . . . . . .  12\n  4.5.  Integrity and Confidentiality . . . . . . . . . . . . . .  13\n  4.6.  Inter-process Context Transfer  . . . . . . . . . . . . .  13\n  4.7.  The Use of Incomplete Contexts  . . . . . . . . . . . . .  14\n5.  Calling Conventions . . . . . . . . . . . . . . . . . . . . .  15\n  5.1.  Package Name  . . . . . . . . . . . . . . . . . . . . . .  15\n  5.2.  Provider Framework  . . . . . . . . . . . . . . . . . . .  15\n  5.3.  Integer Types . . . . . . . . . . . . . . . . . . . . . .  16\n  5.4.  Opaque Data Types . . . . . . . . . . . . . . . . . . . .  16\n  5.5.  Strings . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.6.  Object Identifiers  . . . . . . . . . . . . . . . . . . .  16\n  5.7.  Object Identifier Sets  . . . . . . . . . . . . . . . . .  17\n  5.8.  Credentials . . . . . . . . . . . . . . . . . . . . . . .  17\n  5.9.  Contexts  . . . . . . . . . . . . . . . . . . . . . . . .  19\n  5.10. Authentication Tokens . . . . . . . . . . . . . . . . . .  20\n  5.11. Inter-process Tokens  . . . . . . . . . . . . . . . . . .  20\n  5.12. Error Reporting . . . . . . . . . . . . . . . . . . . . .  20\n    5.12.1.  GSS Status Codes . . . . . . . . . . . . . . . . . .  21\n    5.12.2.  Mechanism-Specific Status Codes  . . . . . . . . . .  23\n    5.12.3.  Supplementary Status Codes . . . . . . . . . . . . .  23\n  5.13. Names . . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  5.14. Channel Bindings  . . . . . . . . . . . . . . . . . . . .  27\n  5.15. Optional Parameters . . . . . . . . . . . . . . . . . . .  28\n6.  Introduction to GSS-API Classes and Interfaces  . . . . . . .  28\n  6.1.  GSSManager Class  . . . . . . . . . . . . . . . . . . . .  28\n  6.2.  GSSName Interface . . . . . . . . . . . . . . . . . . . .  29\n  6.3.  GSSCredential Interface . . . . . . . . . . . . . . . . .  30\n  6.4.  GSSContext Interface  . . . . . . . . . . . . . . . . . .  31\n  6.5.  MessageProp Class . . . . . . . . . . . . . . . . . . . .  32\n  6.6.  GSSException Class  . . . . . . . . . . . . . . . . . . .  32\n  6.7.  Oid Class . . . . . . . . . . . . . . . . . . . . . . . .  32\n  6.8.  ChannelBinding Class  . . . . . . . . . . . . . . . . . .  33\n7.  Detailed GSS-API Class Description  . . . . . . . . . . . . .  33\n  7.1.  public abstract class GSSManager  . . . . . . . . . . . .  33\n    7.1.1.  getInstance . . . . . . . . . . . . . . . . . . . . .  34\n    7.1.2.  getMechs  . . . . . . . . . . . . . . . . . . . . . .  34\n    7.1.3.  getNamesForMech . . . . . . . . . . . . . . . . . . .  35\n    7.1.4.  getMechsForName . . . . . . . . . . . . . . . . . . .  35\n    7.1.5.  createName  . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  7.1.6.  createName  . . . . . . . . . . . . . . . . . . . . .  36\n  7.1.7.  createName  . . . . . . . . . . . . . . . . . . . . .  36\n  7.1.8.  createName  . . . . . . . . . . . . . . . . . . . . .  37\n  7.1.9.  createCredential  . . . . . . . . . . . . . . . . . .  38\n  7.1.10. createCredential  . . . . . . . . . . . . . . . . . .  38\n  7.1.11. createCredential  . . . . . . . . . . . . . . . . . .  39\n  7.1.12. createContext . . . . . . . . . . . . . . . . . . . .  39\n  7.1.13. createContext . . . . . . . . . . . . . . . . . . . .  40\n  7.1.14. createContext . . . . . . . . . . . . . . . . . . . .  40\n  7.1.15. addProviderAtFront  . . . . . . . . . . . . . . . . .  41\n    7.1.15.1.  addProviderAtFront Example Code  . . . . . . . .  42\n  7.1.16. addProviderAtEnd  . . . . . . . . . . . . . . . . . .  43\n    7.1.16.1.  addProviderAtEnd Example Code  . . . . . . . . .  43\n  7.1.17. Example Code  . . . . . . . . . . . . . . . . . . . .  44\n7.2.  public interface GSSName  . . . . . . . . . . . . . . . .  45\n  7.2.1.  Static Constants  . . . . . . . . . . . . . . . . . .  45\n  7.2.2.  equals  . . . . . . . . . . . . . . . . . . . . . . .  46\n  7.2.3.  equals  . . . . . . . . . . . . . . . . . . . . . . .  46\n  7.2.4.  canonicalize  . . . . . . . . . . . . . . . . . . . .  47\n  7.2.5.  export  . . . . . . . . . . . . . . . . . . . . . . .  47\n  7.2.6.  toString  . . . . . . . . . . . . . . . . . . . . . .  47\n  7.2.7.  getStringNameType . . . . . . . . . . . . . . . . . .  47\n  7.2.8.  isAnonymous . . . . . . . . . . . . . . . . . . . . .  47\n  7.2.9.  isMN  . . . . . . . . . . . . . . . . . . . . . . . .  48\n  7.2.10. Example Code  . . . . . . . . . . . . . . . . . . . .  48\n7.3.  public interface GSSCredential implements Cloneable . . .  49\n  7.3.1.  Static Constants  . . . . . . . . . . . . . . . . . .  50\n  7.3.2.  dispose . . . . . . . . . . . . . . . . . . . . . . .  50\n  7.3.3.  getName . . . . . . . . . . . . . . . . . . . . . . .  50\n  7.3.4.  getName . . . . . . . . . . . . . . . . . . . . . . .  51\n  7.3.5.  getRemainingLifetime  . . . . . . . . . . . . . . . .  51\n  7.3.6.  getRemainingInitLifetime  . . . . . . . . . . . . . .  51\n  7.3.7.  getRemainingAcceptLifetime  . . . . . . . . . . . . .  51\n  7.3.8.  getUsage  . . . . . . . . . . . . . . . . . . . . . .  52\n  7.3.9.  getUsage  . . . . . . . . . . . . . . . . . . . . . .  52\n  7.3.10. getMechs  . . . . . . . . . . . . . . . . . . . . . .  52\n  7.3.11. add . . . . . . . . . . . . . . . . . . . . . . . . .  52\n  7.3.12. equals  . . . . . . . . . . . . . . . . . . . . . . .  53\n  7.3.13. Example Code  . . . . . . . . . . . . . . . . . . . .  54\n7.4.  public interface GSSContext . . . . . . . . . . . . . . .  54\n  7.4.1.  Static Constants  . . . . . . . . . . . . . . . . . .  55\n  7.4.2.  initSecContext  . . . . . . . . . . . . . . . . . . .  56\n  7.4.3.  acceptSecContext  . . . . . . . . . . . . . . . . . .  56\n  7.4.4.  isEstablished . . . . . . . . . . . . . . . . . . . .  57\n  7.4.5.  dispose . . . . . . . . . . . . . . . . . . . . . . .  57\n  7.4.6.  getWrapSizeLimit  . . . . . . . . . . . . . . . . . .  58\n  7.4.7.  wrap  . . . . . . . . . . . . . . . . . . . . . . . .  58\n  7.4.8.  unwrap  . . . . . . . . . . . . . . . . . . . . . . .  59",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  7.4.9.  getMIC  . . . . . . . . . . . . . . . . . . . . . . .  60\n  7.4.10. verifyMIC . . . . . . . . . . . . . . . . . . . . . .  61\n  7.4.11. export  . . . . . . . . . . . . . . . . . . . . . . .  62\n  7.4.12. requestMutualAuth . . . . . . . . . . . . . . . . . .  62\n  7.4.13. requestReplayDet  . . . . . . . . . . . . . . . . . .  63\n  7.4.14. requestSequenceDet  . . . . . . . . . . . . . . . . .  63\n  7.4.15. requestCredDeleg  . . . . . . . . . . . . . . . . . .  63\n  7.4.16. requestAnonymity  . . . . . . . . . . . . . . . . . .  64\n  7.4.17. requestConf . . . . . . . . . . . . . . . . . . . . .  64\n  7.4.18. requestInteg  . . . . . . . . . . . . . . . . . . . .  64\n  7.4.19. requestLifetime . . . . . . . . . . . . . . . . . . .  64\n  7.4.20. setChannelBinding . . . . . . . . . . . . . . . . . .  65\n  7.4.21. getCredDelegState . . . . . . . . . . . . . . . . . .  65\n  7.4.22. getMutualAuthState  . . . . . . . . . . . . . . . . .  65\n  7.4.23. getReplayDetState . . . . . . . . . . . . . . . . . .  65\n  7.4.24. getSequenceDetState . . . . . . . . . . . . . . . . .  66\n  7.4.25. getAnonymityState . . . . . . . . . . . . . . . . . .  66\n  7.4.26. isTransferable  . . . . . . . . . . . . . . . . . . .  66\n  7.4.27. isProtReady . . . . . . . . . . . . . . . . . . . . .  66\n  7.4.28. getConfState  . . . . . . . . . . . . . . . . . . . .  66\n  7.4.29. getIntegState . . . . . . . . . . . . . . . . . . . .  67\n  7.4.30. getLifetime . . . . . . . . . . . . . . . . . . . . .  67\n  7.4.31. getSrcName  . . . . . . . . . . . . . . . . . . . . .  67\n  7.4.32. getTargName . . . . . . . . . . . . . . . . . . . . .  67\n  7.4.33. getMech . . . . . . . . . . . . . . . . . . . . . . .  67\n  7.4.34. getDelegCred  . . . . . . . . . . . . . . . . . . . .  68\n  7.4.35. isInitiator . . . . . . . . . . . . . . . . . . . . .  68\n  7.4.36. Example Code  . . . . . . . . . . . . . . . . . . . .  68\n7.5.  public class MessageProp  . . . . . . . . . . . . . . . .  70\n  7.5.1.  Constructors  . . . . . . . . . . . . . . . . . . . .  70\n  7.5.2.  getQOP  . . . . . . . . . . . . . . . . . . . . . . .  71\n  7.5.3.  getPrivacy  . . . . . . . . . . . . . . . . . . . . .  71\n  7.5.4.  getMinorStatus  . . . . . . . . . . . . . . . . . . .  71\n  7.5.5.  getMinorString  . . . . . . . . . . . . . . . . . . .  71\n  7.5.6.  setQOP  . . . . . . . . . . . . . . . . . . . . . . .  71\n  7.5.7.  setPrivacy  . . . . . . . . . . . . . . . . . . . . .  72\n  7.5.8.  isDuplicateToken  . . . . . . . . . . . . . . . . . .  72\n  7.5.9.  isOldToken  . . . . . . . . . . . . . . . . . . . . .  72\n  7.5.10. isUnseqToken  . . . . . . . . . . . . . . . . . . . .  72\n  7.5.11. isGapToken  . . . . . . . . . . . . . . . . . . . . .  72\n  7.5.12. setSupplementaryStates  . . . . . . . . . . . . . . .  72\n7.6.  public class ChannelBinding . . . . . . . . . . . . . . .  73\n  7.6.1.  Constructors  . . . . . . . . . . . . . . . . . . . .  73\n  7.6.2.  getInitiatorAddress . . . . . . . . . . . . . . . . .  74\n  7.6.3.  getAcceptorAddress  . . . . . . . . . . . . . . . . .  74\n  7.6.4.  getApplicationData  . . . . . . . . . . . . . . . . .  74\n  7.6.5.  equals  . . . . . . . . . . . . . . . . . . . . . . .  75",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  7.7.  public class Oid  . . . . . . . . . . . . . . . . . . . .  75\n    7.7.1.  Constructors  . . . . . . . . . . . . . . . . . . . .  75\n    7.7.2.  toString  . . . . . . . . . . . . . . . . . . . . . .  76\n    7.7.3.  equals  . . . . . . . . . . . . . . . . . . . . . . .  76\n    7.7.4.  getDER  . . . . . . . . . . . . . . . . . . . . . . .  76\n    7.7.5.  containedIn . . . . . . . . . . . . . . . . . . . . .  77\n  7.8.  public class GSSException extends Exception . . . . . . .  77\n    7.8.1.  Static Constants  . . . . . . . . . . . . . . . . . .  77\n    7.8.2.  Constructors  . . . . . . . . . . . . . . . . . . . .  80\n    7.8.3.  getMajor  . . . . . . . . . . . . . . . . . . . . . .  81\n    7.8.4.  getMinor  . . . . . . . . . . . . . . . . . . . . . .  81\n    7.8.5.  getMajorString  . . . . . . . . . . . . . . . . . . .  81\n    7.8.6.  getMinorString  . . . . . . . . . . . . . . . . . . .  81\n    7.8.7.  getOutputToken  . . . . . . . . . . . . . . . . . . .  82\n    7.8.8.  setMinor  . . . . . . . . . . . . . . . . . . . . . .  82\n    7.8.9.  toString  . . . . . . . . . . . . . . . . . . . . . .  82\n    7.8.10. getMessage  . . . . . . . . . . . . . . . . . . . . .  82\n8.  Sample Applications . . . . . . . . . . . . . . . . . . . . .  83\n  8.1.  Simple GSS Context Initiator  . . . . . . . . . . . . . .  83\n  8.2.  Simple GSS Context Acceptor . . . . . . . . . . . . . . .  87\n9.  Security Considerations . . . . . . . . . . . . . . . . . . .  90\n10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  91\n11. Changes since RFC 5653  . . . . . . . . . . . . . . . . . . .  91\n12. Changes since RFC 2853  . . . . . . . . . . . . . . . . . . .  93\n13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  94\n  13.1.  Normative References . . . . . . . . . . . . . . . . . .  94\n  13.2.  Informative References . . . . . . . . . . . . . . . . .  95\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  96\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  96",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies Java language bindings for the Generic Security Services Application Programming Interface (GSS-API) version 2. GSS-API version 2 is described in a language-independent format in RFC 2743 [RFC2743]. The GSS-API allows a caller application to authenticate a principal identity, delegate rights to a peer, and apply security services such as confidentiality and integrity on a per-message basis.",
      "ja": "このドキュメントでは、Generic Security Services Application Programming Interface（GSS-API）バージョン2のJava言語バインディングを指定します。GSS-APIバージョン2は、RFC 2743 [RFC2743]で言語に依存しない形式で記述されています。 GSS-APIを使用すると、呼び出し元のアプリケーションはプリンシパルIDを認証し、ピアに権限を委任し、メッセージごとに機密性や整合性などのセキュリティサービスを適用できます。"
    },
    {
      "indent": 3,
      "text": "This document and its predecessors, RFC 2853 [RFC2853] and RFC 5653 [RFC5653], leverage the work done by the working group (WG) in the area of RFC 2743 [RFC2743] and the C-bindings of RFC 2744 [RFC2744]. Whenever appropriate, text has been used from the C-bindings document (RFC 2744) to explain generic concepts and provide direction to the implementors.",
      "ja": "このドキュメントとその前身であるRFC 2853 [RFC2853]およびRFC 5653 [RFC5653]は、RFC 2743 [RFC2743]およびRFC 2744 [RFC2744]のCバインディングの領域でワーキンググループ（WG）によって行われた作業を活用します。適切な場合は常に、Cバインディングドキュメント（RFC 2744）のテキストを使用して、一般的な概念を説明し、実装者に指示を提供しています。"
    },
    {
      "indent": 3,
      "text": "The design goals of this API have been to satisfy all the functionality defined in RFC 2743 [RFC2743] and to provide these services in an object-oriented method. The specification also aims to satisfy the needs of both types of Java application developers, those who would like access to a \"system-wide\" GSS-API implementation, as well as those who would want to provide their own \"custom\" implementation.",
      "ja": "このAPIの設計目標は、RFC 2743 [RFC2743]で定義されているすべての機能を満たし、オブジェクト指向の方法でこれらのサービスを提供することです。また、この仕様は、「システム全体の」GSS-API実装へのアクセスを希望する人と、独自の「カスタム」実装を提供したい人の両方のタイプのJavaアプリケーション開発者のニーズを満たすことも目的としています。"
    },
    {
      "indent": 3,
      "text": "A system-wide implementation is one that is available to all applications in the form of a library package. It may be the standard package in the Java runtime environment (JRE) being used, or it may be additionally installed and accessible to any application via the CLASSPATH.",
      "ja": "システム全体の実装は、すべてのアプリケーションがライブラリパッケージの形で利用できる実装です。これは、使用されているJavaランタイム環境（JRE）の標準パッケージである場合と、追加でインストールされ、CLASSPATHを介して任意のアプリケーションにアクセスできる場合があります。"
    },
    {
      "indent": 3,
      "text": "A custom implementation of the GSS-API, on the other hand, is one that would, in most cases, be bundled with the application during distribution. It is expected that such an implementation would be meant to provide for some particular need of the application, such as support for some specific mechanism.",
      "ja": "一方、GSS-APIのカスタム実装は、ほとんどの場合、配布中にアプリケーションにバンドルされるものです。このような実装は、特定のメカニズムのサポートなど、アプリケーションの特定の必要性を提供することを目的とすることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The design of this API also aims to provide a flexible framework to add and manage GSS-API mechanisms. GSS-API leverages the Java Cryptography Architecture (JCA) provider model to support the plugability of mechanisms. Mechanisms can be added on a system-wide basis, where all users of the framework will have them available. The specification also allows for the addition of mechanisms per instance of the GSS-API.",
      "ja": "このAPIの設計は、GSS-APIメカニズムを追加および管理するための柔軟なフレームワークを提供することも目的としています。 GSS-APIは、Java暗号化アーキテクチャー（JCA）プロバイダーモデルを利用して、メカニズムのプラグ可能性をサポートします。メカニズムはシステム全体に追加でき、フレームワークのすべてのユーザーがメカニズムを使用できるようになります。この仕様では、GSS-APIのインスタンスごとにメカニズムを追加することもできます。"
    },
    {
      "indent": 3,
      "text": "Lastly, this specification presents an API that will naturally fit within the operation environment of the Java platform. Readers are assumed to be familiar with both the GSS-API and the Java platform.",
      "ja": "最後に、この仕様は、Javaプラットフォームの動作環境に自然に適合するAPIを示しています。読者は、GSS-APIとJavaプラットフォームの両方に精通していることを前提としています。"
    },
    {
      "indent": 0,
      "text": "2. Notational Conventions",
      "section_title": true,
      "ja": "2. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. GSS-API Operational Paradigm",
      "section_title": true,
      "ja": "3. GSS-API運用パラダイム"
    },
    {
      "indent": 3,
      "text": "\"Generic Security Service Application Programming Interface, Version 2\" [RFC2743] defines a generic security API to calling applications. It allows a communicating application to authenticate the user associated with another application, to delegate rights to another application, and to apply security services such as confidentiality and integrity on a per-message basis.",
      "ja": "「汎用セキュリティサービスアプリケーションプログラミングインターフェイス、バージョン2」[RFC2743]は、アプリケーションを呼び出すための汎用セキュリティAPIを定義しています。これにより、通信アプリケーションは、別のアプリケーションに関連付けられたユーザーを認証し、別のアプリケーションに権限を委任し、メッセージごとに機密性や整合性などのセキュリティサービスを適用できます。"
    },
    {
      "indent": 3,
      "text": "There are four stages to using GSS-API:",
      "ja": "GSS-APIの使用には4つの段階があります。"
    },
    {
      "indent": 3,
      "text": "1) The application acquires a set of credentials with which it may prove its identity to other processes. The application's credentials vouch for its global identity, which may or may not be related to any local username under which it may be running.",
      "ja": "1）アプリケーションは、他のプロセスに対してIDを証明できる一連の資格情報を取得します。アプリケーションの資格情報は、そのグローバルIDを保証します。これは、アプリケーションが実行されている可能性のあるローカルのユーザー名に関連付けられている場合と関連付けられていない場合があります。"
    },
    {
      "indent": 3,
      "text": "2) A pair of communicating applications establish a joint security context using their credentials. The security context encapsulates shared state information, which is required in order that per-message security services may be provided. Examples of state information that might be shared between applications as part of a security context are cryptographic keys and message sequence numbers. As part of the establishment of a security context, the context initiator is authenticated to the responder and may require that the responder is authenticated back to the initiator. The initiator may optionally give the responder the right to initiate further security contexts, acting as an agent or delegate of the initiator. This transfer of rights is termed \"delegation\" and is achieved by creating a set of credentials, similar to those used by the initiating application, but which may be used by the responder.",
      "ja": "2）通信するアプリケーションのペアは、資格情報を使用して共同セキュリティコンテキストを確立します。セキュリティコンテキストは、メッセージごとのセキュリティサービスを提供するために必要な共有状態情報をカプセル化します。セキュリティコンテキストの一部としてアプリケーション間で共有される可能性のある状態情報の例は、暗号化キーとメッセージシーケンス番号です。セキュリティコンテキストの確立の一環として、コンテキストイニシエータはレスポンダに対して認証され、レスポンダが認証されてイニシエータに戻ることを要求する場合があります。イニシエータは、オプションとして、イニシエータのエージェントまたはデリゲートとして機能し、追加のセキュリティコンテキストを開始する権利をレスポンダに与えることができます。この権利の譲渡は「委任」と呼ばれ、開始アプリケーションが使用するものと同様の資格情報のセットを作成することによって実現されますが、レスポンダが使用することもできます。"
    },
    {
      "indent": 6,
      "text": "A GSSContext object is used to establish and maintain the shared information that makes up the security context. Certain GSSContext methods will generate a token, which applications treat as cryptographically protected, opaque data. The caller of such a GSSContext method is responsible for transferring the token to the peer application, encapsulated if necessary in an application-to-application protocol. On receipt of such a token, the peer application should pass it to a corresponding GSSContext method, which will decode the token and extract the information, updating the security context state information accordingly.",
      "ja": "GSSContextオブジェクトは、セキュリティコンテキストを構成する共有情報を確立および維持するために使用されます。特定のGSSContextメソッドはトークンを生成し、アプリケーションはそれを暗号で保護された不透明なデータとして扱います。このようなGSSContextメソッドの呼び出し元は、トークンをピアアプリケーションに転送し、必要に応じてアプリケーション間プロトコルでカプセル化します。そのようなトークンを受信すると、ピアアプリケーションは対応するGSSContextメソッドにトークンを渡し、トークンをデコードして情報を抽出し、それに応じてセキュリティコンテキストの状態情報を更新します。"
    },
    {
      "indent": 3,
      "text": "3) Per-message services are invoked on a GSSContext object to apply either:",
      "ja": "3）GSSContextオブジェクトでメッセージごとのサービスが呼び出され、次のいずれかが適用されます。"
    },
    {
      "indent": 6,
      "text": "integrity and data origin authentication, or",
      "ja": "整合性とデータ発信元認証、または"
    },
    {
      "indent": 6,
      "text": "confidentiality, integrity, and data origin authentication",
      "ja": "機密性、完全性、およびデータ発信元認証"
    },
    {
      "indent": 0,
      "text": " to application data, which are treated by GSS-API as arbitrary octet strings. An application transmitting a message that it wishes to protect will call the appropriate GSSContext method (getMIC or wrap) to apply protection before sending the resulting token to the receiving application. The receiver will pass the received token (and, in the case of data protected by getMIC, the accompanying message data) to the corresponding decoding method of the GSSContext interface (verifyMIC or unwrap) to remove the protection and validate the data.",
      "ja": "GSS-APIによって任意のオクテット文字列として扱われるアプリケーションデータに。保護したいメッセージを送信するアプリケーションは、適切なGSSContextメソッド（getMICまたはwrap）を呼び出して、結果のトークンを受信アプリケーションに送信する前に保護を適用します。受信側は、受信したトークン（およびgetMICで保護されたデータの場合は、付随するメッセージデータ）をGSSContextインターフェースの対応するデコードメソッド（verifyMICまたはunwrap）に渡して、保護を解除し、データを検証します。"
    },
    {
      "indent": 3,
      "text": "4) At the completion of a communications session (which may extend across several transport connections), each application uses a GSSContext method to invalidate the security context and release any system or cryptographic resources held. Multiple contexts may also be used (either successively or simultaneously) within a single communications association, at the discretion of the applications.",
      "ja": "4）通信セッション（複数のトランスポート接続にまたがる場合があります）の完了時に、各アプリケーションはGSSContextメソッドを使用してセキュリティコンテキストを無効にし、保持されているシステムリソースまたは暗号化リソースを解放します。アプリケーションの裁量で、単一の通信アソシエーション内で複数のコンテキストを（連続的または同時に）使用することもできます。"
    },
    {
      "indent": 0,
      "text": "4. Additional Controls",
      "section_title": true,
      "ja": "4. 追加のコントロール"
    },
    {
      "indent": 3,
      "text": "This section discusses the OPTIONAL services that a context initiator may request of the GSS-API before the context establishment. Each of these services is requested by calling the appropriate mutator method in the GSSContext object before the first call to init is performed. Only the context initiator can request context flags.",
      "ja": "このセクションでは、コンテキストの開始前にコンテキストの開始者がGSS-APIに要求できるオプションのサービスについて説明します。これらの各サービスは、initへの最初の呼び出しが実行される前に、GSSContextオブジェクトの適切なミューテーターメソッドを呼び出すことによって要求されます。コンテキストイニシエーターのみがコンテキストフラグを要求できます。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL services defined are:",
      "ja": "定義されているオプションのサービスは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Delegation: The (usually temporary) transfer of rights from initiator to acceptor, enabling the acceptor to authenticate itself as an agent of the initiator.",
      "ja": "委任：イニシエーターからアクセプターへの権利の（通常は一時的な）転送。アクセプターがイニシエーターのエージェントとして自身を認証できるようにします。"
    },
    {
      "indent": 6,
      "text": "Mutual Authentication: In addition to the initiator authenticating its identity to the context acceptor, the context acceptor SHOULD also authenticate itself to the initiator.",
      "ja": "相互認証：イニシエーターがコンテキストアクセプターに対してIDを認証することに加えて、コンテキストアクセプターはイニシエーターに対して自身を認証する必要があります。"
    },
    {
      "indent": 6,
      "text": "Replay Detection: In addition to providing message integrity services, GSSContext per-message operations of getMIC and wrap SHOULD include message numbering information to enable verifyMIC and unwrap to detect if a message has been duplicated.",
      "ja": "リプレイ検出：メッセージ整合性サービスの提供に加えて、getMICとラップSHOWLDのGSSContextのメッセージごとの操作には、verifyMICおよびunwrapを有効にしてメッセージが重複しているかどうかを検出できるようにするメッセージ番号情報が含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "Out-of-Sequence Detection: In addition to providing message integrity services, GSSContext per-message operations (getMIC and wrap) SHOULD include message sequencing information to enable verifyMIC and unwrap to detect if a message has been received out of sequence.",
      "ja": "シーケンス外検出：メッセージ整合性サービスの提供に加えて、GSSContextのメッセージごとの操作（getMICとラップ）には、verifyMICを有効にするメッセージシーケンス情報を含め、メッセージがシーケンス外で受信されたかどうかを検出するためにアンラップする必要があります。"
    },
    {
      "indent": 6,
      "text": "Anonymous Authentication: The establishment of the security context SHOULD NOT reveal the initiator's identity to the context acceptor.",
      "ja": "匿名認証：セキュリティコンテキストの確立は、コンテキストの受け入れ側に開始者のIDを明らかにすべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 0,
      "text": " Some mechanisms may not support all OPTIONAL services, and some mechanisms may only support some services in conjunction with others. The GSSContext interface offers query methods to allow the verification by the calling application of which services will be available from the context when the establishment phase is complete. In general, if the security mechanism is capable of providing a requested service, it SHOULD do so even if additional services must be enabled in order to provide the requested service. If the mechanism is incapable of providing a requested service, it SHOULD proceed without the service leaving the application to abort the context establishment process if it considers the requested service to be mandatory.",
      "ja": "一部のメカニズムはすべてのOPTIONALサービスをサポートしない場合があり、一部のメカニズムは他のサービスと組み合わせて一部のサービスしかサポートしない場合があります。 GSSContextインタフェースは、確立フェーズが完了したときにコンテキストから利用可能なサービスを呼び出すアプリケーションによる検証を可能にするクエリメソッドを提供します。一般に、セキュリティメカニズムが要求されたサービスを提供できる場合は、要求されたサービスを提供するために追加のサービスを有効にする必要がある場合でも、それを行う必要があります。メカニズムが要求されたサービスを提供できない場合、要求されたサービスが必須であると見なした場合、サービスがアプリケーションを離れずにコンテキスト確立プロセスを中止することなく続行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some mechanisms MAY specify that support for some services is optional and that implementors of the mechanism need not provide it. This is most commonly true of the confidentiality service, often because of legal restrictions on the use of data encryption, but it may apply to any of the services. Such mechanisms are required to send at least one token from acceptor to initiator during context establishment when the initiator indicates a desire to use such a service, so that the initiating GSS-API can correctly indicate whether the service is supported by the acceptor's GSS-API.",
      "ja": "一部のメカニズムは、一部のサービスのサポートがオプションであり、メカニズムの実装者がそれを提供する必要がないことを指定する場合があります。これは通常、機密性サービスに当てはまります。多くの場合、データ暗号化の使用に関する法的制限が原因ですが、どのサービスにも適用される場合があります。開始側のGSS-APIがサービスがアクセプターのGSS-APIによってサポートされているかどうかを正しく示すことができるように、イニシエーターがそのようなサービスを使用する意向を示す場合、コンテキスト確立中にアクセプターからイニシエーターに少なくとも1つのトークンを送信するために、このようなメカニズムが必要です。 。"
    },
    {
      "indent": 0,
      "text": "4.1. Delegation",
      "section_title": true,
      "ja": "4.1. 委任"
    },
    {
      "indent": 3,
      "text": "The GSS-API allows delegation to be controlled by the initiating application via the requestCredDeleg method before the first call to init has been issued. Some mechanisms do not support delegation, and for such mechanisms, attempts by an application to enable delegation are ignored.",
      "ja": "GSS-APIを使用すると、initへの最初の呼び出しが発行される前に、requestCredDelegメソッドを介して開始アプリケーションによって委任を制御できます。一部のメカニズムは委任をサポートしていません。そのようなメカニズムでは、アプリケーションによる委任を有効にする試みは無視されます。"
    },
    {
      "indent": 3,
      "text": "The acceptor of a security context, for which the initiator enabled delegation, can check if delegation was enabled by using the getCredDelegState method of the GSSContext interface. In cases when it is enabled, the delegated credential object can be obtained by calling the getDelegCred method. The obtained GSSCredential object may then be used to initiate subsequent GSS-API security contexts as an agent or delegate of the initiator. If the original initiator's identity is \"A\" and the delegate's identity is \"B\", then, depending on the underlying mechanism, the identity embodied by the delegated credential may be either \"A\" or \"B acting for A\".",
      "ja": "開始者が委任を有効にしたセキュリティコンテキストの受け入れ側は、GSSContextインタフェースのgetCredDelegStateメソッドを使用して委任が有効になっているかどうかを確認できます。有効になっている場合、委任された資格情報オブジェクトは、getDelegCredメソッドを呼び出すことで取得できます。次に、取得したGSSCredentialオブジェクトを使用して、後続のGSS-APIセキュリティコンテキストをエージェントまたはイニシエータのデリゲートとして開始できます。元の開始者のIDが \"A\"で、デリゲートのIDが \"B\"の場合、基になるメカニズムに応じて、委任された資格情報によって具体化されるIDは、 \"A\"または \"Aの代わりに動作するB\"になります。"
    },
    {
      "indent": 0,
      "text": " For many mechanisms that support delegation, a simple boolean does not provide enough control. Examples of additional aspects of delegation control that a mechanism might provide to an application are duration of delegation, network addresses from which delegation is valid, and constraints on the tasks that may be performed by a delegate. Such controls are presently outside the scope of the GSS-API. GSS-API implementations supporting mechanisms offering additional controls SHOULD provide extension routines that allow these controls to be exercised (perhaps by modifying the initiator's GSS-API credential object prior to its use in establishing a context). However, the simple delegation control provided by GSS-API SHOULD always be able to override other mechanism-specific delegation controls. If the application instructs the GSSContext object that delegation is not desired, then the implementation MUST NOT permit delegation to occur. This is an exception to the general rule that a mechanism may enable services even if they are not requested -- delegation may only be provided at the explicit request of the application.",
      "ja": "委任をサポートする多くのメカニズムでは、単純なブール値では十分な制御ができません。メカニズムがアプリケーションに提供する可能性がある委任制御の追加の側面の例は、委任の期間、委任が有効になるネットワークアドレス、および委任によって実行される可能性があるタスクに対する制約です。このような制御は現在、GSS-APIの範囲外です。追加のコントロールを提供するメカニズムをサポートするGSS-API実装は、これらのコントロールを実行できる拡張ルーチンを提供する必要があります（おそらく、コンテキストの確立に使用する前に、イニシエーターのGSS-API資格オブジェクトを変更することにより）。ただし、GSS-APIによって提供される単純な委任制御は、常に他のメカニズム固有の委任制御をオーバーライドできる必要があります（SHOULD）。アプリケーションがGSSContextオブジェクトに委任が望ましくないことを指示する場合、実装は委任の発生を許可してはなりません（MUST NOT）。これは、メカニズムが要求されていなくてもメカニズムがサービスを有効にする可能性があるという一般的な規則の例外です。アプリケーションの明示的な要求でのみ委任を提供できます。"
    },
    {
      "indent": 0,
      "text": "4.2. Mutual Authentication",
      "section_title": true,
      "ja": "4.2. 相互認証"
    },
    {
      "indent": 3,
      "text": "Usually, a context acceptor will require that a context initiator authenticate itself so that the acceptor may make an access-control decision prior to performing a service for the initiator. In some cases, the initiator may also request that the acceptor authenticate itself. GSS-API allows the initiating application to request this mutual authentication service by calling the requestMutualAuth method of the GSSContext interface with a \"true\" parameter before making the first call to init. The initiating application is informed as to whether or not the context acceptor has authenticated itself. Note that some mechanisms may not support mutual authentication, and other mechanisms may always perform mutual authentication, whether or not the initiating application requests it. In particular, mutual authentication may be required by some mechanisms in order to support replay or out-of-sequence message detection, and for such mechanisms, a request for either of these services will automatically enable mutual authentication.",
      "ja": "通常、コンテキストアクセプターは、コンテキストイニシエーターが自身を認証することを要求します。これにより、アクセプターは、イニシエーターのサービスを実行する前にアクセス制御の決定を行うことができます。場合によっては、イニシエーターは、アクセプターが自分自身を認証することを要求することもあります。 GSS-APIを使用すると、initを最初に呼び出す前に、「true」パラメーターを指定してGSSContextインターフェースのrequestMutualAuthメソッドを呼び出すことにより、開始アプリケーションがこの相互認証サービスを要求できます。開始アプリケーションは、コンテキストの受け入れ側が自身を認証したかどうかについて通知されます。開始アプリケーションが要求するかどうかに関係なく、一部のメカニズムは相互認証をサポートしない場合があり、他のメカニズムは常に相互認証を実行する場合があることに注意してください。特に、一部のメカニズムでは、再生またはシーケンス外のメッセージ検出をサポートするために相互認証が必要になる場合があり、そのようなメカニズムでは、これらのサービスのいずれかを要求すると、自動的に相互認証が有効になります。"
    },
    {
      "indent": 0,
      "text": "4.3. Replay and Out-of-Sequence Detection",
      "section_title": true,
      "ja": "4.3. リプレイおよびシーケンス外検出"
    },
    {
      "indent": 3,
      "text": "The GSS-API MAY provide detection of mis-ordered messages once a security context has been established. Protection MAY be applied to messages by either application, by calling either getMIC or wrap methods of the GSSContext interface, and verified by the peer application by calling verifyMIC or unwrap for the peer's GSSContext object.",
      "ja": "GSS-APIは、セキュリティコンテキストが確立されると、誤った順序のメッセージを検出できる場合があります。保護は、GSSContextインターフェースのgetMICまたはwrapメソッドのいずれかを呼び出すことによって、いずれかのアプリケーションによってメッセージに適用され、ピアのGSSContextオブジェクトに対してverifyMICまたはunwrapを呼び出すことによってピアアプリケーションによって検証される場合があります。"
    },
    {
      "indent": 3,
      "text": "The getMIC method calculates a cryptographic checksum (authentication tag) of an application message, and returns that checksum in a token. The application SHOULD pass both the token and the message to the peer application, which presents them to the verifyMIC method of the peer's GSSContext object.",
      "ja": "getMICメソッドは、アプリケーションメッセージの暗号化チェックサム（認証タグ）を計算し、そのチェックサムをトークンで返します。アプリケーションは、トークンとメッセージの両方をピアアプリケーションに渡す必要があります。ピアアプリケーションは、それらをピアのGSSContextオブジェクトのverifyMICメソッドに提示します。"
    },
    {
      "indent": 3,
      "text": "The wrap method calculates a cryptographic checksum of an application message, and places both the checksum and the message inside a single token. The application SHOULD pass the token to the peer application, which presents it to the unwrap method of the peer's GSSContext object to extract the message and verify the checksum.",
      "ja": "wrapメソッドは、アプリケーションメッセージの暗号化チェックサムを計算し、チェックサムとメッセージの両方を単一のトークン内に配置します。アプリケーションは、トークンをピアアプリケーションに渡す必要があります。ピアアプリケーションは、トークンをピアのGSSContextオブジェクトのunwrapメソッドに提示して、メッセージを抽出し、チェックサムを確認します。"
    },
    {
      "indent": 3,
      "text": "Either pair of routines may be capable of detecting out-of-sequence message delivery or the duplication of messages. Details of such mis-ordered messages are indicated through supplementary query methods of the MessageProp object that is filled in by each of these routines.",
      "ja": "どちらのルーチンのペアも、シーケンス外のメッセージ配信またはメッセージの重複を検出できる場合があります。そのような誤った順序のメッセージの詳細は、これらの各ルーチンによって入力されるMessagePropオブジェクトの補足クエリメソッドを通じて示されます。"
    },
    {
      "indent": 3,
      "text": "A mechanism need not maintain a list of all tokens that have been processed in order to support these status codes. A typical mechanism might retain information about only the most recent \"N\" tokens processed, allowing it to distinguish duplicates and missing tokens within the most recent \"N\" messages; the receipt of a token older than the most recent \"N\" would result in the isOldToken method of the instance of MessageProp to return \"true\".",
      "ja": "メカニズムは、これらのステータスコードをサポートするために処理されたすべてのトークンのリストを維持する必要はありません。典型的なメカニズムは、処理された最新の「N」トークンのみに関する情報を保持し、最新の「N」メッセージ内の重複トークンと欠落トークンを区別できるようにします。最新の「N」より古いトークンを受信すると、MessagePropのインスタンスのisOldTokenメソッドが「true」を返します。"
    },
    {
      "indent": 0,
      "text": "4.4. Anonymous Authentication",
      "section_title": true,
      "ja": "4.4. 匿名認証"
    },
    {
      "indent": 3,
      "text": "In certain situations, an application may wish to initiate the authentication process to authenticate a peer, without revealing its own identity. As an example, consider an application providing access to a database containing medical information and offering unrestricted access to the service. A client of such a service might wish to authenticate the service (in order to establish trust in any information retrieved from it), but might not wish the service to be able to obtain the client's identity (perhaps due to privacy concerns about the specific inquiries, or perhaps simply to avoid being placed on mailing-lists).",
      "ja": "特定の状況では、アプリケーションは、自身のIDを明かさずに、ピアを認証するための認証プロセスを開始したい場合があります。例として、医療情報を含むデータベースへのアクセスを提供し、サービスへの無制限のアクセスを提供するアプリケーションを考えてみましょう。このようなサービスのクライアントは、サービスからの情報の信頼を確立するためにサービスを認証することを望むかもしれませんが、サービスがクライアントのアイデンティティを取得することを望まないかもしれません（おそらく、特定の問い合わせに関するプライバシーの懸念のため） 、またはおそらく単にメーリングリストに掲載されないようにするため）。"
    },
    {
      "indent": 3,
      "text": "In normal use of the GSS-API, the initiator's identity is made available to the acceptor as a result of the context establishment process. However, context initiators may request that their identity not be revealed to the context acceptor. Many mechanisms do not support anonymous authentication, and for such mechanisms, the request will not be honored. An authentication token will still be generated, but the application is always informed if a requested service is unavailable, and has the option to abort context establishment if anonymity is valued above the other security services that would require a context to be established.",
      "ja": "GSS-APIの通常の使用では、コンテキスト確立プロセスの結果として、イニシエーターのIDがアクセプターに利用可能になります。ただし、コンテキスト起動側は、自分のIDをコンテキスト受け入れ側に公開しないよう要求する場合があります。多くのメカニズムは匿名認証をサポートしていません。そのようなメカニズムでは、要求は受け付けられません。認証トークンは引き続き生成されますが、要求されたサービスが利用できない場合は常にアプリケーションに通知され、コンテキストの確立を必要とする他のセキュリティサービスよりも匿名性が重視される場合は、コンテキストの確立を中止するオプションがあります。"
    },
    {
      "indent": 0,
      "text": " In addition to informing the application that a context is established anonymously (via the isAnonymous method of the GSSContext class), the getSrcName method of the acceptor's GSSContext object will, for such contexts, return a reserved internal-form name, defined by the implementation.",
      "ja": "コンテキストが匿名で（GSSContextクラスのisAnonymousメソッドを介して）確立されたことをアプリケーションに通知することに加えて、アクセプターのGSSContextオブジェクトのgetSrcNameメソッドは、そのようなコンテキストに対して、実装によって定義された予約済み内部フォーム名を返します。"
    },
    {
      "indent": 3,
      "text": "The toString method for a GSSName object representing an anonymous entity will return a printable name. The returned value will be syntactically distinguishable from any valid principal name supported by the implementation. The associated name-type Object Identifier (OID) will be an OID representing the value of NT_ANONYMOUS. This name-type OID will be defined as a public, static Oid object of the GSSName class. The printable form of an anonymous name SHOULD be chosen such that it implies anonymity, since this name may appear in, for example, audit logs. For example, the string \"<anonymous>\" might be a good choice, if no valid printable names supported by the implementation can begin with \"<\" and end with \">\".",
      "ja": "匿名エンティティを表すGSSNameオブジェクトのtoStringメソッドは、印刷可能な名前を返します。戻り値は、実装でサポートされている有効なプリンシパル名と構文的に区別できます。関連する名前タイプのオブジェクト識別子（OID）は、NT_ANONYMOUSの値を表すOIDになります。この名前タイプのOIDは、GSSNameクラスのパブリックな静的Oidオブジェクトとして定義されます。匿名名の印刷可能な形式は、匿名性を意味するように選択する必要があります（SHOULD）。この名前は、たとえば監査ログに表示される場合があるためです。たとえば、実装でサポートされている有効な印刷可能な名前が「<」で始まり、「>」で終わることができない場合は、文字列「<anonymous>」が適切な選択になる場合があります。"
    },
    {
      "indent": 3,
      "text": "When using the equal method of the GSSName interface, and one of the operands is a GSSName instance representing an anonymous entity, the method MUST return \"false\".",
      "ja": "GSSNameインターフェースのequalメソッドを使用し、オペランドの1つが匿名エンティティを表すGSSNameインスタンスである場合、メソッドは「false」を返さなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "4.5. Integrity and Confidentiality",
      "section_title": true,
      "ja": "4.5. 誠実さと機密性"
    },
    {
      "indent": 3,
      "text": "If a GSSContext supports the integrity service, the getMic method may be used to create message integrity check tokens on application messages.",
      "ja": "GSSContextが整合性サービスをサポートしている場合、getMicメソッドを使用して、アプリケーションメッセージにメッセージ整合性チェックトークンを作成できます。"
    },
    {
      "indent": 3,
      "text": "If a GSSContext supports the confidentiality service, the wrap method may be used to encrypt application messages. Messages are selectively encrypted, under the control of the setPrivacy method of the MessageProp object used in the wrap method. Confidentiality will be applied if the privacy state is set to true.",
      "ja": "GSSContextが機密性サービスをサポートしている場合、wrapメソッドを使用してアプリケーションメッセージを暗号化できます。メッセージは、wrapメソッドで使用されるMessagePropオブジェクトのsetPrivacyメソッドの制御下で、選択的に暗号化されます。プライバシー状態がtrueに設定されている場合、機密性が適用されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Inter-process Context Transfer",
      "section_title": true,
      "ja": "4.6. プロセス間コンテキスト転送"
    },
    {
      "indent": 3,
      "text": "GSS-APIv2 provides functionality that allows a security context to be transferred between processes on a single machine. These are implemented using the export method of GSSContext and a byte array constructor of the same class. The most common use for such a feature is a client-server design where the server is implemented as a single process that accepts incoming security contexts, which then launches child processes to deal with the data on these contexts. In such a design, the child processes must have access to the security context object created within the parent so that they can use per-message protection services and delete the security context when the communication session ends.",
      "ja": "GSS-APIv2は、単一のマシン上のプロセス間でセキュリティコンテキストを転送できるようにする機能を提供します。これらは、GSSContextのエクスポートメソッドと同じクラスのバイト配列コンストラクタを使用して実装されます。このような機能の最も一般的な用途は、サーバーが着信セキュリティコンテキストを受け入れる単一のプロセスとして実装され、子プロセスを起動してこれらのコンテキストのデータを処理するクライアント/サーバー設計です。このような設計では、子プロセスは、メッセージセッション保護サービスを使用し、通信セッションの終了時にセキュリティコンテキストを削除できるように、親内に作成されたセキュリティコンテキストオブジェクトにアクセスできる必要があります。"
    },
    {
      "indent": 0,
      "text": " Since the security context data structure is expected to contain sequencing information, it is impractical in general to share a context between processes. Thus, the GSSContext interface provides an export method that the process, which currently owns the context, can call to declare that it has no intention to use the context subsequently and to create an inter-process token containing information needed by the adopting process to successfully recreate the context. After successful completion of export, the original security context is made inaccessible to the calling process by GSS-API, and any further usage of this object will result in failures. The originating process transfers the inter-process token to the adopting process, which creates a new GSSContext object using the byte array constructor. The properties of the context are equivalent to that of the original context.",
      "ja": "セキュリティコンテキストのデータ構造にはシーケンス情報が含まれていることが予想されるため、プロセス間でコンテキストを共有することは一般的に非現実的です。したがって、GSSContextインターフェースは、現在コンテキストを所有しているプロセスが呼び出すことができるエクスポートメソッドを提供し、その後コンテキストを使用する意図がないことを宣言し、採用プロセスが正常に実行するために必要な情報を含むプロセス間トークンを作成します。コンテキストを再作成します。エクスポートが正常に完了すると、元のセキュリティコンテキストはGSS-APIによって呼び出しプロセスにアクセスできなくなり、このオブジェクトをさらに使用すると失敗します。元のプロセスは、プロセス間トークンを採用プロセスに転送します。採用プロセスは、バイト配列コンストラクタを使用して新しいGSSContextオブジェクトを作成します。コンテキストのプロパティは、元のコンテキストのプロパティと同等です。"
    },
    {
      "indent": 3,
      "text": "The inter-process token MAY contain sensitive data from the original security context (including cryptographic keys). Applications using inter-process tokens to transfer security contexts MUST take appropriate steps to protect these tokens in transit.",
      "ja": "プロセス間トークンには、元のセキュリティコンテキスト（暗号化キーを含む）の機密データが含まれる場合があります。プロセス間トークンを使用してセキュリティコンテキストを転送するアプリケーションは、送信中にこれらのトークンを保護するために適切な手順を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations are not required to support the inter-process transfer of security contexts. Calling the isTransferable method of the GSSContext interface will indicate if the context object is transferable.",
      "ja": "セキュリティコンテキストのプロセス間転送をサポートするための実装は必要ありません。 GSSContextインターフェースのisTransferableメソッドを呼び出すと、コンテキストオブジェクトが転送可能かどうかがわかります。"
    },
    {
      "indent": 0,
      "text": "4.7. The Use of Incomplete Contexts",
      "section_title": true,
      "ja": "4.7. 不完全なコンテキストの使用"
    },
    {
      "indent": 3,
      "text": "Some mechanisms may allow the per-message services to be used before the context establishment process is complete. For example, a mechanism may include sufficient information in its initial context-level tokens for the context acceptor to immediately decode messages protected with wrap or getMIC. For such a mechanism, the initiating application need not wait until subsequent context-level tokens have been sent and received before invoking the per-message protection services.",
      "ja": "メカニズムによっては、コンテキスト確立プロセスが完了する前にメッセージごとのサービスを使用できる場合があります。たとえば、メカニズムでは、ラップまたはgetMICで保護されたメッセージをコンテキストアクセプターが即座にデコードできるように、初期コンテキストレベルトークンに十分な情報を含めることができます。このようなメカニズムの場合、開始アプリケーションは、メッセージごとの保護サービスを呼び出す前に、後続のコンテキストレベルのトークンが送受信されるまで待機する必要はありません。"
    },
    {
      "indent": 3,
      "text": "An application can invoke the isProtReady method of the GSSContext class to determine if the per-message services are available in advance of complete context establishment. Applications wishing to use per-message protection services on partially established contexts SHOULD query this method before attempting to invoke wrap or getMIC.",
      "ja": "アプリケーションは、GSSContextクラスのisProtReadyメソッドを呼び出して、完全なコンテキストが確立される前にメッセージごとのサービスが利用可能かどうかを判断できます。部分的に確立されたコンテキストでメッセージごとの保護サービスを使用するアプリケーションは、wrapまたはgetMICを呼び出す前に、このメソッドにクエリを実行する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5. Calling Conventions",
      "section_title": true,
      "ja": "5. 呼び出し規約"
    },
    {
      "indent": 3,
      "text": "Java provides the implementors with not just a syntax for the language but also an operational environment. For example, memory is automatically managed and does not require application intervention. These language features have allowed for a simpler API and have led to the elimination of certain GSS-API functions.",
      "ja": "Javaは、言語の構文だけでなく運用環境も実装者に提供します。たとえば、メモリは自動的に管理され、アプリケーションの介入は必要ありません。これらの言語機能により、より単純なAPIが可能になり、特定のGSS-API関数が削除されました。"
    },
    {
      "indent": 3,
      "text": "Moreover, the JCA defines a provider model that allows for implementation-independent access to security services. Using this model, applications can seamlessly switch between different implementations and dynamically add new services. The GSS-API specification leverages these concepts by the usage of providers for the mechanism implementations.",
      "ja": "さらに、JCAは、セキュリティサービスへの実装に依存しないアクセスを可能にするプロバイダーモデルを定義します。このモデルを使用すると、アプリケーションは異なる実装をシームレスに切り替えて、新しいサービスを動的に追加できます。 GSS-API仕様では、メカニズムの実装にプロバイダーを使用することにより、これらの概念を活用しています。"
    },
    {
      "indent": 0,
      "text": "5.1. Package Name",
      "section_title": true,
      "ja": "5.1. パッケージ名"
    },
    {
      "indent": 3,
      "text": "The classes and interfaces defined in this document reside in the package called \"org.ietf.jgss\". Applications that wish to make use of this API should import this package name as shown in Section 8.",
      "ja": "このドキュメントで定義されているクラスとインターフェースは、「org.ietf.jgss」というパッケージにあります。このAPIを使用するアプリケーションは、セクション8に示すように、このパッケージ名をインポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Provider Framework",
      "section_title": true,
      "ja": "5.2. プロバイダーフレームワーク"
    },
    {
      "indent": 3,
      "text": "Java security APIs use a provider architecture that allows applications to be implementation independent and security API implementations to be modular and extensible. The java.security.Provider class is an abstract class that a vendor extends. This class maps various properties that represent different security services that are available to the names of the actual vendor classes that implement those services. When requesting a service, an application simply specifies the desired provider, and the API delegates the request to service classes available from that provider.",
      "ja": "JavaセキュリティーAPIは、アプリケーションを実装に依存しないようにしたり、セキュリティーAPI実装をモジュール式にしたり拡張したりできるようにするプロバイダーアーキテクチャーを使用します。 java.security.Providerクラスは、ベンダーが拡張する抽象クラスです。このクラスは、利用可能なさまざまなセキュリティサービスを表すさまざまなプロパティを、それらのサービスを実装する実際のベンダークラスの名前にマッピングします。サービスをリクエストするとき、アプリケーションは単に希望のプロバイダーを指定し、APIはそのプロバイダーから利用可能なサービスクラスにリクエストを委任します。"
    },
    {
      "indent": 3,
      "text": "Using the Java security provider model insulates applications from implementation details of the services they wish to use. Applications can switch between providers easily, and new providers can be added as needed, even at runtime.",
      "ja": "Javaセキュリティプロバイダーモデルを使用すると、アプリケーションを、使用したいサービスの実装の詳細から隔離できます。アプリケーションはプロバイダーを簡単に切り替えることができ、新しいプロバイダーは実行時でも必要に応じて追加できます。"
    },
    {
      "indent": 3,
      "text": "The GSS-API may use providers to find components for specific underlying security mechanisms. For instance, a particular provider might contain components that will allow the GSS-API to support the Kerberos v5 mechanism [RFC4121], and another might contain components to support the Simple Public-Key GSS-API Mechanism (SPKM) [RFC2025]. By delegating mechanism-specific functionality to the components obtained from providers, the GSS-API can be extended to support an arbitrary list of mechanisms.",
      "ja": "GSS-APIは、プロバイダーを使用して、特定の基本的なセキュリティメカニズムのコンポーネントを検索できます。たとえば、特定のプロバイダーには、GSS-APIがKerberos v5メカニズム[RFC4121]をサポートできるようにするコンポーネントが含まれ、別のプロバイダーには、シンプルな公開鍵GSS-APIメカニズム（SPKM）[RFC2025]をサポートするコンポーネントが含まれる場合があります。メカニズム固有の機能をプロバイダから取得したコンポーネントに委任することにより、GSS-APIを拡張して、メカニズムの任意のリストをサポートできます。"
    },
    {
      "indent": 3,
      "text": "How the GSS-API locates and queries these providers is beyond the scope of this document and is being deferred to a Service Provider Interface (SPI) specification. The availability of such an SPI specification is not mandatory for the adoption of this API specification nor is it mandatory to use providers in the implementation of a GSS-API framework. However, by using the provider framework together with an SPI specification, one can create an extensible and implementation-independent GSS-API framework.",
      "ja": "GSS-APIがこれらのプロバイダーを見つけて照会する方法は、このドキュメントの範囲外であり、サービスプロバイダーインターフェース（SPI）仕様に委ねられています。そのようなSPI仕様の可用性は、このAPI仕様の採用に必須ではなく、GSS-APIフレームワークの実装でプロバイダーを使用することも必須ではありません。ただし、SPI仕様と共にプロバイダーフレームワークを使用することにより、拡張可能で実装に依存しないGSS-APIフレームワークを作成できます。"
    },
    {
      "indent": 0,
      "text": "5.3. Integer Types",
      "section_title": true,
      "ja": "5.3. 整数型"
    },
    {
      "indent": 3,
      "text": "All numeric values are declared as the \"int\" primitive Java type. The Java specification guarantees that this will be a 32-bit two's complement signed number.",
      "ja": "すべての数値は、「int」プリミティブJava型として宣言されます。 Java仕様では、これが32ビットの2の補数の符号付き数値になることが保証されています。"
    },
    {
      "indent": 3,
      "text": "Throughout this API, the \"boolean\" primitive Java type is used wherever a boolean value is required or returned.",
      "ja": "このAPI全体を通して、ブール値が必要な場合、または返される場合は常に、「ブール」プリミティブJavaタイプが使用されます。"
    },
    {
      "indent": 0,
      "text": "5.4. Opaque Data Types",
      "section_title": true,
      "ja": "5.4. 不透明なデータ型"
    },
    {
      "indent": 3,
      "text": "Java byte arrays are used to represent opaque data types that are consumed and produced by the GSS-API in the form of tokens. Java arrays contain a length field that enables the users to easily determine their size. The language has automatic garbage collection that alleviates the need by developers to release memory and simplifies buffer ownership issues.",
      "ja": "Javaバイト配列は、GSS-APIによってトークンの形式で消費および生成される不透明なデータ型を表すために使用されます。 Java配列には、ユーザーがサイズを簡単に決定できる長さフィールドが含まれています。この言語には、開発者がメモリを解放する必要性を軽減し、バッファの所有権の問題を簡素化する自動ガベージコレクションがあります。"
    },
    {
      "indent": 0,
      "text": "5.5. Strings",
      "section_title": true,
      "ja": "5.5. 文字列"
    },
    {
      "indent": 3,
      "text": "The String object will be used to represent all textual data. The Java String object transparently treats all characters as two-byte Unicode characters, which allows support for many locals. All routines returning or accepting textual data will use the String object.",
      "ja": "Stringオブジェクトは、すべてのテキストデータを表すために使用されます。 Java Stringオブジェクトは、すべての文字を2バイトのUnicode文字として透過的に処理するため、多くのローカルをサポートできます。テキストデータを返すまたは受け入れるすべてのルーチンは、Stringオブジェクトを使用します。"
    },
    {
      "indent": 0,
      "text": "5.6. Object Identifiers",
      "section_title": true,
      "ja": "5.6. オブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "An Oid object will be used to represent Universal Object Identifiers (OIDs). OIDs are ISO-defined, hierarchically globally interpretable identifiers used within the GSS-API framework to identify security mechanisms and name formats. The Oid object can be created from a string representation of its dot notation (e.g., \"1.3.6.1.5.6.2\") as well as from its ASN.1 DER encoding. Methods are also provided to test equality and provide the DER representation for the object.",
      "ja": "Oidオブジェクトは、ユニバーサルオブジェクト識別子（OID）を表すために使用されます。 OIDはISOで定義された、階層的にグローバルに解釈可能な識別子であり、GSS-APIフレームワーク内で使用されて、セキュリティメカニズムと名前の形式を識別します。 Oidオブジェクトは、そのドット表記の文字列表現（「1.3.6.1.5.6.2」など）と、ASN.1 DERエンコーディングから作成できます。等価性をテストし、オブジェクトのDER表現を提供するメソッドも提供されます。"
    },
    {
      "indent": 3,
      "text": "An important feature of the Oid class is that its instances are immutable -- i.e., there are no methods defined that allow one to change the contents of an Oid object. This property allows one to treat these objects as \"statics\" without the need to perform copies.",
      "ja": "Oidクラスの重要な機能は、そのインスタンスが不変であることです。つまり、Oidオブジェクトの内容を変更できるメソッドが定義されていません。このプロパティにより、コピーを実行する必要なく、これらのオブジェクトを「静的」として扱うことができます。"
    },
    {
      "indent": 3,
      "text": "Certain routines allow the usage of a default OID. A \"null\" value can be used in those cases.",
      "ja": "特定のルーチンでは、デフォルトのOIDを使用できます。これらの場合、「null」値を使用できます。"
    },
    {
      "indent": 0,
      "text": "5.7. Object Identifier Sets",
      "section_title": true,
      "ja": "5.7. オブジェクト識別子セット"
    },
    {
      "indent": 3,
      "text": "The Java bindings represent Object Identifier sets as arrays of Oid objects. All Java arrays contain a length field, which allows for easy manipulation and reference.",
      "ja": "Javaバインディングは、オブジェクトIDセットをOidオブジェクトの配列として表します。すべてのJava配列には長さフィールドが含まれているため、簡単に操作および参照できます。"
    },
    {
      "indent": 3,
      "text": "In order to support the full functionality of RFC 2743 [RFC2743], the Oid class includes a method that checks for existence of an Oid object within a specified array. This is equivalent in functionality to gss_test_oid_set_member. The use of Java arrays and Java's automatic garbage collection has eliminated the need for the following routines: gss_create_empty_oid_set, gss_release_oid_set, and gss_add_oid_set_member. Java GSS-API implementations will not contain them. Java's automatic garbage collection and the immutable property of the Oid object eliminates the memory management issues of the C counterpart.",
      "ja": "RFC 2743 [RFC2743]のすべての機能をサポートするために、Oidクラスには、指定された配列内のOidオブジェクトの存在をチェックするメソッドが含まれています。これはgss_test_oid_set_memberと機能的に同等です。 Java配列とJavaの自動ガベージコレクションを使用することで、gss_create_empty_oid_set、gss_release_oid_set、gss_add_oid_set_memberの各ルーチンが不要になりました。 Java GSS-API実装には含まれません。 Javaの自動ガベージコレクションとOidオブジェクトの不変のプロパティにより、Cの対応するメモリ管理の問題が解消されます。"
    },
    {
      "indent": 3,
      "text": "Whenever a default value for an Object Identifier set is required, a \"null\" value can be used. Please consult the detailed method description for details.",
      "ja": "オブジェクト識別子セットのデフォルト値が必要な場合は常に、「null」値を使用できます。詳細については、メソッドの詳細説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Credentials",
      "section_title": true,
      "ja": "5.8. 資格情報"
    },
    {
      "indent": 3,
      "text": "GSS-API credentials are represented by the GSSCredential interface. The interface contains several constructs to allow for the creation of most common credential objects for the initiator and the acceptor. Comparisons are performed using the interface's \"equals\" method. The following general description of GSS-API credentials is included from the C-bindings specification [RFC2744]:",
      "ja": "GSS-API資格は、GSSCredentialインターフェースによって表されます。インターフェースには、イニシエーターとアクセプターの最も一般的な資格情報オブジェクトの作成を可能にするいくつかの構成要素が含まれています。比較は、インターフェースの「等しい」メソッドを使用して実行されます。以下のGSS-API資格の一般的な説明は、Cバインディング仕様[RFC2744]に含まれています。"
    },
    {
      "indent": 0,
      "text": " GSS-API credentials can contain mechanism-specific principal authentication data for multiple mechanisms. A GSS-API credential is composed of a set of credential-elements, each of which is applicable to a single mechanism. A credential may contain at most one credential-element for each supported mechanism. A credential-element identifies the data needed by a single mechanism to authenticate a single principal, and conceptually contains two credential-references that describe the actual mechanism-specific authentication data, one to be used by GSS-API for initiating contexts, and one to be used for accepting contexts. For mechanisms that do not distinguish between acceptor and initiator credentials, both references would point to the same underlying mechanism-specific authentication data.",
      "ja": "GSS-API資格には、複数のメカニズムのメカニズム固有のプリンシパル認証データを含めることができます。 GSS-API資格は、credential-elementsのセットで構成され、それぞれが単一のメカニズムに適用できます。信任状には、サポートされるメカニズムごとに最大1つのcredential-elementを含めることができます。 credential-elementは、単一のプリンシパルを認証するために単一のメカニズムで必要なデータを識別し、概念的には実際のメカニズム固有の認証データを記述する2つの資格情報参照を含みます。1つはGSS-APIがコンテキストの開始に使用し、もう1つはコンテキストを受け入れるために使用されます。アクセプターとイニシエーターの資格情報を区別しないメカニズムの場合、どちらの参照も、同じメカニズム固有の認証データを指します。"
    },
    {
      "indent": 3,
      "text": "Credentials describe a set of mechanism-specific principals and give their holder the ability to act as any of those principals. All principal identities asserted by a single GSS-API credential SHOULD belong to the same entity, although enforcement of this property is an implementation-specific matter. A single GSSCredential object represents all the credential elements that have been acquired.",
      "ja": "資格情報は、メカニズム固有のプリンシパルのセットを記述し、それらの所有者にそれらのプリンシパルのいずれかとして機能する能力を与えます。このプロパティの適用は実装固有の問題ですが、単一のGSS-APIクレデンシャルによってアサートされるすべてのプリンシパルIDは同じエンティティに属している必要があります（SHOULD）。単一のGSSCredentialオブジェクトは、取得されたすべての資格情報要素を表します。"
    },
    {
      "indent": 3,
      "text": "The creation of a GSSContext object allows the value of \"null\" to be specified as the GSSCredential input parameter. This will indicate a desire by the application to act as a default principal. While individual GSS-API implementations are free to determine such default behavior as appropriate to the mechanism, the following default behavior by these routines is RECOMMENDED for portability:",
      "ja": "GSSContextオブジェクトを作成すると、「null」の値をGSSCredential入力パラメーターとして指定できます。これは、デフォルトのプリンシパルとして機能することをアプリケーションが望んでいることを示します。個々のGSS-API実装は、このようなデフォルトの動作をメカニズムに応じて自由に決定できますが、これらのルーチンによる次のデフォルトの動作は、移植性のために推奨されています。"
    },
    {
      "indent": 3,
      "text": "For the initiator side of the context:",
      "ja": "コンテキストの開始者側の場合："
    },
    {
      "indent": 3,
      "text": "1) If there is only a single principal capable of initiating security contexts for the chosen mechanism that the application is authorized to act on behalf of, then that principal shall be used; otherwise,",
      "ja": "1）アプリケーションが代わりに動作することを許可されている、選択されたメカニズムのセキュリティコンテキストを開始できるプリンシパルが1つだけの場合、そのプリンシパルが使用されます。さもないと、"
    },
    {
      "indent": 3,
      "text": "2) If the platform maintains a concept of a default network identity for the chosen mechanism, and if the application is authorized to act on behalf of that identity for the purpose of initiating security contexts, then the principal corresponding to that identity shall be used; otherwise,",
      "ja": "2）プラットフォームが選択したメカニズムのデフォルトのネットワークIDの概念を維持し、アプリケーションがそのIDに代わってセキュリティコンテキストを開始する目的で動作することを許可されている場合、そのIDに対応するプリンシパルが使用されます。さもないと、"
    },
    {
      "indent": 3,
      "text": "3) If the platform maintains a concept of a default local identity, and provides a means to map local identities into network identities for the chosen mechanism, and if the application is authorized to act on behalf of the network-identity image of the default local identity for the purpose of initiating security contexts using the chosen mechanism, then the principal corresponding to that identity shall be used; otherwise,",
      "ja": "3）プラットフォームがデフォルトのローカルIDの概念を維持し、ローカルIDを選択したメカニズムのネットワークIDにマッピングする手段を提供し、アプリケーションがデフォルトローカルIDのネットワークIDイメージに代わって動作することを許可されている場合選択されたメカニズムを使用してセキュリティコンテキストを開始するためのアイデンティティ。そのアイデンティティに対応するプリンシパルが使用されます。さもないと、"
    },
    {
      "indent": 3,
      "text": "4) A user-configurable default identity should be used.",
      "ja": "4）ユーザーが構成可能なデフォルトのIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the acceptor side of the context:",
      "ja": "コンテキストの受け入れ側について："
    },
    {
      "indent": 3,
      "text": "1) If there is only a single authorized principal identity capable of accepting security contexts for the chosen mechanism, then that principal shall be used; otherwise,",
      "ja": "1）選択されたメカニズムのセキュリティコンテキストを受け入れることができる承認されたプリンシパルIDが1つしかない場合、そのプリンシパルが使用されます。さもないと、"
    },
    {
      "indent": 3,
      "text": "2) If the mechanism can determine the identity of the target principal by examining the context-establishment token processed during the accept method, and if the accepting application is authorized to act as that principal for the purpose of accepting security contexts using the chosen mechanism, then that principal identity shall be used; otherwise,",
      "ja": "2）メカニズムが、acceptメソッド中に処理されたコンテキスト確立トークンを調べることによってターゲットプリンシパルのIDを決定できる場合、および選択したメカニズムを使用してセキュリティコンテキストを受け入れる目的で、プリンシパルとして動作することが承認アプリケーションに許可されている場合、次に、そのプリンシパルIDが使用されます。さもないと、"
    },
    {
      "indent": 3,
      "text": "3) If the mechanism supports context acceptance by any principal, and if mutual authentication was not requested, any principal that the application is authorized to accept security contexts under using the chosen mechanism may be used; otherwise,",
      "ja": "3）メカニズムがプリンシパルによるコンテキストの受け入れをサポートし、相互認証が要求されなかった場合、選択されたメカニズムを使用してアプリケーションがセキュリティコンテキストを受け入れることを許可されているプリンシパルを使用できます。さもないと、"
    },
    {
      "indent": 3,
      "text": "4) A user-configurable default identity shall be used.",
      "ja": "4）ユーザー設定可能なデフォルトのアイデンティティが使用されます。"
    },
    {
      "indent": 3,
      "text": "The purpose of the above rules is to allow security contexts to be established by both initiator and acceptor using the default behavior whenever possible. Applications requesting default behavior are likely to be more portable across mechanisms and implementations than ones that instantiate a GSSCredential object representing a specific identity.",
      "ja": "上記のルールの目的は、可能な場合は常にデフォルトの動作を使用して、イニシエーターとアクセプターの両方がセキュリティコンテキストを確立できるようにすることです。デフォルトの動作を要求するアプリケーションは、特定のIDを表すGSSCredentialオブジェクトをインスタンス化するものよりも、メカニズムや実装全体で移植性が高い可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.9. Contexts",
      "section_title": true,
      "ja": "5.9. コンテキスト"
    },
    {
      "indent": 3,
      "text": "The GSSContext interface is used to represent one end of a GSS-API security context, storing state information appropriate to that end of the peer communication, including cryptographic state information. The instantiation of the context object is done differently by the initiator and the acceptor. After the context has been instantiated, the initiator MAY choose to set various context options that will determine the characteristics of the desired security context. When all the application-desired characteristics have been set, the initiator will call the initSecContext method, which will produce a token for consumption by the peer's acceptSecContext method. It is the responsibility of the application to deliver the authentication token(s) between the peer applications for processing. Upon completion of the context-establishment phase, context attributes can be retrieved, by both the initiator and acceptor, using the accessor methods. These will reflect the actual attributes of the established context and might not match the initiator-requested values. If any retrieved attribute does not match the desired value but it is necessary for the application protocol, the application SHOULD destroy the security context and not use it for application traffic. Otherwise, at this point, the context can be used by the application to apply cryptographic services to its data.",
      "ja": "GSSContextインタフェースは、GSS-APIセキュリティコンテキストの一方の端を表すために使用され、暗号状態情報を含む、ピア通信のその端に適した状態情報を格納します。コンテキストオブジェクトのインスタンス化は、イニシエーターとアクセプターによって異なる方法で行われます。コンテキストがインスタンス化された後、イニシエーターは、目的のセキュリティコンテキストの特性を決定するさまざまなコンテキストオプションを設定することを選択できます（MAY）。アプリケーションで必要なすべての特性が設定されると、イニシエーターはinitSecContextメソッドを呼び出し、ピアのacceptSecContextメソッドで使用するためのトークンを生成します。処理のためにピアアプリケーション間で認証トークンを配信するのは、アプリケーションの責任です。コンテキスト確立フェーズが完了すると、アクセサメソッドを使用して、イニシエータとアクセプタの両方がコンテキスト属性を取得できます。これらは確立されたコンテキストの実際の属性を反映し、イニシエーターが要求した値と一致しない場合があります。取得した属性が目的の値と一致しないが、アプリケーションプロトコルに必要な場合、アプリケーションはセキュリティコンテキストを破棄し、アプリケーショントラフィックには使用しないでください（SHOULD）。それ以外の場合、この時点で、アプリケーションはデータに暗号化サービスを適用するためにコンテキストを使用できます。"
    },
    {
      "indent": 0,
      "text": "5.10. Authentication Tokens",
      "section_title": true,
      "ja": "5.10. 認証トークン"
    },
    {
      "indent": 3,
      "text": "A token is a caller-opaque type that GSS-API uses to maintain synchronization between each end of the GSS-API security context. The token is a cryptographically protected octet string, generated by the underlying mechanism at one end of a GSS-API security context for use by the peer mechanism at the other end. Encapsulation (if required) within the application protocol and transfer of the token are the responsibility of the peer applications.",
      "ja": "トークンは、GSS-APIがGSS-APIセキュリティコンテキストの両端間の同期を維持するために使用する呼び出し元不透明タイプです。トークンは、暗号で保護されたオクテット文字列であり、GSS-APIセキュリティコンテキストの一方の端にあるメカニズムによって生成され、もう一方の端にあるピアメカニズムで使用されます。アプリケーションプロトコル内でのカプセル化（必要な場合）およびトークンの転送は、ピアアプリケーションの責任です。"
    },
    {
      "indent": 3,
      "text": "Java GSS-API uses byte arrays to represent authentication tokens.",
      "ja": "Java GSS-APIはバイト配列を使用して認証トークンを表します。"
    },
    {
      "indent": 0,
      "text": "5.11. Inter-process Tokens",
      "section_title": true,
      "ja": "5.11. プロセス間トークン"
    },
    {
      "indent": 3,
      "text": "Certain GSS-API routines are intended to transfer data between processes in multi-process programs. These routines use a caller-opaque octet string, generated by the GSS-API in one process for use by the GSS-API in another process. The calling application is responsible for transferring such tokens between processes. Note that, while GSS-API implementors are encouraged to avoid placing sensitive information within inter-process tokens, or to cryptographically protect them, many implementations will be unable to avoid placing key material or other sensitive data within them. It is the application's responsibility to ensure that inter-process tokens are protected in transit and transferred only to processes that are trustworthy. An inter-process token is represented using a byte array emitted from the export method of the GSSContext interface. The receiver of the inter-process token would initialize a GSSContext object with this token to create a new context. Once a context has been exported, the GSSContext object is invalidated and is no longer available.",
      "ja": "特定のGSS-APIルーチンは、マルチプロセスプログラムのプロセス間でデータを転送することを目的としています。これらのルーチンは、GSS-APIが別のプロセスで使用するために、あるプロセスのGSS-APIによって生成された発信者に不透明なオクテット文字列を使用します。呼び出し側のアプリケーションは、プロセス間でそのようなトークンを転送する責任があります。 GSS-APIの実装者は、プロセス間トークン内に機密情報を配置したり、それらを暗号で保護したりすることをお勧めしますが、多くの実装では、キーマテリアルやその他の機密データを配置することを回避できません。プロセス間トークンが転送中に保護され、信頼できるプロセスにのみ転送されるようにするのは、アプリケーションの責任です。プロセス間トークンは、GSSContextインターフェースのエクスポートメソッドから発行されたバイト配列を使用して表されます。プロセス間トークンの受信者は、このトークンでGSSContextオブジェクトを初期化して、新しいコンテキストを作成します。コンテキストがエクスポートされると、GSSContextオブジェクトは無効になり、使用できなくなります。"
    },
    {
      "indent": 0,
      "text": "5.12. Error Reporting",
      "section_title": true,
      "ja": "5.12. エラー報告"
    },
    {
      "indent": 3,
      "text": "RFC 2743 [RFC2743] defined the usage of major and minor status values for the signaling of GSS-API errors. The major code, also called the GSS status code, is used to signal errors at the GSS-API level, independent of the underlying mechanism(s). The minor status value or Mechanism status code, is a mechanism-defined error value indicating a mechanism-specific error code.",
      "ja": "RFC 2743 [RFC2743]は、GSS-APIエラーのシグナリングのためのメジャーおよびマイナーステータス値の使用を定義しました。主要なコードはGSSステータスコードとも呼ばれ、基盤となるメカニズムに関係なく、GSS-APIレベルでエラーを通知するために使用されます。マイナーステータス値またはメカニズムステータスコードは、メカニズム固有のエラーコードを示すメカニズム定義のエラー値です。"
    },
    {
      "indent": 0,
      "text": " Java GSS-API uses exceptions implemented by the GSSException class to signal both minor and major error values. Both mechanism-specific errors and GSS-API level errors are signaled through instances of this class. The usage of exceptions replaces the need for major and minor codes to be used within the API calls. The GSSException class also contains methods to obtain textual representations for both the major and minor values, which is equivalent to the functionality of gss_display_status. A GSSException object MAY also include an output token that SHOULD be sent to the peer.",
      "ja": "Java GSS-APIは、GSSExceptionクラスによって実装された例外を使用して、マイナーおよびメジャーの両方のエラー値を通知します。メカニズム固有のエラーとGSS-APIレベルのエラーの両方が、このクラスのインスタンスを通じて通知されます。例外の使用により、API呼び出し内で使用されるメジャーコードとマイナーコードの必要性が置き換えられます。 GSSExceptionクラスには、メジャー値とマイナー値の両方のテキスト表現を取得するメソッドも含まれています。これは、gss_display_statusの機能と同等です。 GSSExceptionオブジェクトには、ピアに送信する必要がある出力トークンを含めることもできます（MAY）。"
    },
    {
      "indent": 3,
      "text": "If an exception is thrown during context establishment, the context negotiation has failed and the GSSContext object MUST be abandoned. If it is thrown in a per-message call, the context MAY remain useful.",
      "ja": "コンテキストの確立中に例外がスローされた場合、コンテキストのネゴシエーションは失敗し、GSSContextオブジェクトを破棄する必要があります。メッセージごとの呼び出しでスローされた場合、コンテキストは引き続き有用です。"
    },
    {
      "indent": 0,
      "text": "5.12.1. GSS Status Codes",
      "section_title": true,
      "ja": "5.12.1. GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS status codes indicate errors that are independent of the underlying mechanism(s) used to provide the security service. The errors that can be indicated via a GSS status code are generic API routine errors (errors that are defined in the GSS-API specification). These bindings take advantage of the Java exceptions mechanism, thus eliminating the need for calling errors.",
      "ja": "GSSステータスコードは、セキュリティサービスを提供するために使用される基本的なメカニズムに依存しないエラーを示します。 GSSステータスコードを介して示される可能性のあるエラーは、一般的なAPIルーチンエラー（GSS-API仕様で定義されているエラー）です。これらのバインディングは、Java例外メカニズムを利用するため、呼び出しエラーの必要性を排除します。"
    },
    {
      "indent": 3,
      "text": "A GSS status code indicates a single fatal generic API error from the routine that has thrown the GSSException. Using exceptions announces that a fatal error has occurred during the execution of the method. The GSS-API operational model also allows for the signaling of supplementary status information from the per-message calls. These need to be handled as return values since using exceptions is not appropriate for informatory or warning-like information. The methods that are capable of producing supplementary information are the two per-message methods GSSContext.verifyMIC() and GSSContext.unwrap(). These methods fill the supplementary status codes in the MessageProp object that was passed in.",
      "ja": "GSSステータスコードは、GSSExceptionをスローしたルーチンからの単一の致命的な汎用APIエラーを示します。例外を使用すると、メソッドの実行中に致命的なエラーが発生したことが通知されます。 GSS-API運用モデルでは、メッセージごとの呼び出しからの補足ステータス情報のシグナリングも可能です。例外を使用することは、情報や警告のような情報には適していないため、これらは戻り値として処理する必要があります。補足情報を生成できるメソッドは、メッセージごとの2つのメソッドGSSContext.verifyMIC()およびGSSContext.unwrap()です。これらのメソッドは、渡されたMessagePropオブジェクトの補足ステータスコードを入力します。"
    },
    {
      "indent": 0,
      "text": " A GSSException object, along with providing the functionality for setting the various error codes and translating them into textual representation, also contains the definitions of all the numeric error values. The following table lists the definitions of error codes: Table: GSS Status Codes",
      "ja": "GSSExceptionオブジェクトは、さまざまなエラーコードを設定してテキスト表現に変換する機能を提供するとともに、すべての数値エラー値の定義も含みます。次の表に、エラーコードの定義を示します。表：GSSステータスコード"
    },
    {
      "indent": 0,
      "text": "   +----------------------+-------+------------------------------------+\n   | Name                 | Value | Meaning                            |\n   +----------------------+-------+------------------------------------+\n   | BAD_BINDINGS         | 1     | Incorrect channel bindings were    |\n   |                      |       | supplied.                          |\n   | BAD_MECH             | 2     | An unsupported mechanism was       |\n   |                      |       | requested.                         |\n   | BAD_NAME             | 3     | An invalid name was supplied.      |\n   | BAD_NAMETYPE         | 4     | A supplied name was of an          |\n   |                      |       | unsupported type.                  |\n   | BAD_STATUS           | 5     | An invalid status code was         |\n   |                      |       | supplied.                          |\n   | BAD_MIC              | 6     | A token had an invalid MIC.        |\n   | CONTEXT_EXPIRED      | 7     | The context has expired.           |\n   | CREDENTIALS_EXPIRED  | 8     | The referenced credentials have    |\n   |                      |       | expired.                           |\n   | DEFECTIVE_CREDENTIAL | 9     | A supplied credential was invalid. |\n   | DEFECTIVE_TOKEN      | 10    | A supplied token was invalid.      |\n   | FAILURE              | 11    | Miscellaneous failure, unspecified |\n   |                      |       | at the GSS-API level.              |\n   | NO_CONTEXT           | 12    | Invalid context has been supplied. |\n   | NO_CRED              | 13    | No credentials were supplied, or   |\n   |                      |       | the credentials were unavailable   |\n   |                      |       | or inaccessible.                   |\n   | BAD_QOP              | 14    | The quality of protection (QOP)    |\n   |                      |       | requested could not be provided.   |\n   | UNAUTHORIZED         | 15    | The operation is forbidden by the  |\n   |                      |       | local security policy.             |\n   | UNAVAILABLE          | 16    | The operation or option is         |\n   |                      |       | unavailable.                       |\n   | DUPLICATE_ELEMENT    | 17    | The requested credential element   |\n   |                      |       | already exists.                    |\n   | NAME_NOT_MN          | 18    | The provided name was not a        |\n   |                      |       | mechanism name.                    |\n   +----------------------+-------+------------------------------------+\n   The following four status codes (DUPLICATE_TOKEN, OLD_TOKEN,\n   UNSEQ_TOKEN, and GAP_TOKEN) are contained in a GSSException only if\n   detected during context establishment, in which case it is a fatal\n   error.  (During per-message calls, these values are indicated as\n   supplementary information contained in the MessageProp object.)  They\n   are:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "+-----------------+-------+-----------------------------------------+\n| Name            | Value | Meaning                                 |\n+-----------------+-------+-----------------------------------------+\n| DUPLICATE_TOKEN | 19    | The token was a duplicate of an earlier |\n|                 |       | version.                                |\n| OLD_TOKEN       | 20    | The token's validity period has         |\n|                 |       | expired.                                |\n| UNSEQ_TOKEN     | 21    | A later token has already been          |\n|                 |       | processed.                              |\n| GAP_TOKEN       | 22    | The expected token was not received.    |\n+-----------------+-------+-----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The GSS major status code of FAILURE is used to indicate that the underlying mechanism detected an error for which no specific GSS status code is defined. The mechanism-specific status code can provide more details about the error.",
      "ja": "FAILUREのGSSメジャーステータスコードは、基になるメカニズムが特定のGSSステータスコードが定義されていないエラーを検出したことを示すために使用されます。メカニズム固有のステータスコードは、エラーの詳細を提供します。"
    },
    {
      "indent": 3,
      "text": "The different major status codes that can be contained in the GSSException object thrown by the methods in this specification are the same as the major status codes returned by the corresponding calls in RFC 2743 [RFC2743].",
      "ja": "この仕様のメソッドによってスローされるGSSExceptionオブジェクトに含まれる可能性のあるさまざまなメジャーステータスコードは、RFC 2743 [RFC2743]の対応する呼び出しによって返されるメジャーステータスコードと同じです。"
    },
    {
      "indent": 0,
      "text": "5.12.2. Mechanism-Specific Status Codes",
      "section_title": true,
      "ja": "5.12.2. メカニズム固有のステータスコード"
    },
    {
      "indent": 3,
      "text": "Mechanism-specific status codes are communicated in two ways: they are part of any GSSException thrown from the mechanism-specific layer to signal a fatal error, or they are part of the MessageProp object that the per-message calls use to signal non-fatal errors.",
      "ja": "メカニズム固有のステータスコードは、2つの方法で通信されます。これらは、メカニズム固有のレイヤーからスローされるGSSExceptionの一部で致命的なエラーを通知するか、メッセージごとの呼び出しが致命的でないことを通知するために使用するMessagePropオブジェクトの一部ですエラー。"
    },
    {
      "indent": 3,
      "text": "A default value of 0 in either the GSSException object or the MessageProp object will be used to represent the absence of any mechanism-specific status code.",
      "ja": "GSSExceptionオブジェクトまたはMessagePropオブジェクトのデフォルト値0は、メカニズム固有のステータスコードがないことを表すために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.12.3. Supplementary Status Codes",
      "section_title": true,
      "ja": "5.12.3. 補足ステータスコード"
    },
    {
      "indent": 3,
      "text": "Supplementary status codes are confined to the per-message methods of the GSSContext interface. Because of the informative nature of these errors, it is not appropriate to use exceptions to signal them. Instead, the per-message operations of the GSSContext interface return these values in a MessageProp object.",
      "ja": "補足ステータスコードは、GSSContextインターフェースのメッセージごとのメソッドに限定されます。これらのエラーは情報を提供する性質があるため、例外を使用してエラーを通知することは適切ではありません。代わりに、GSSContextインターフェースのメッセージごとの操作は、これらの値をMessagePropオブジェクトで返します。"
    },
    {
      "indent": 3,
      "text": "The MessageProp class defines query methods that return boolean values indicating the following supplementary states:",
      "ja": "MessagePropクラスは、次の補足状態を示すブール値を返すクエリメソッドを定義します。"
    },
    {
      "indent": 3,
      "text": "Table: Supplementary Status Methods",
      "ja": "表：補足ステータスメソッド"
    },
    {
      "indent": 3,
      "text": "+------------------+------------------------------------------------+\n| Method Name      | Meaning when \"true\" is returned                |\n+------------------+------------------------------------------------+\n| isDuplicateToken | The token was a duplicate of an earlier token. |\n| isOldToken       | The token's validity period has expired.       |\n| isUnseqToken     | A later token has already been processed.      |\n| isGapToken       | An expected per-message token was not          |\n|                  | received.                                      |\n+------------------+------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A \"true\" return value for any of the above methods indicates that the token exhibited the specified property. The application MUST determine the appropriate course of action for these supplementary values. They are not treated as errors by the GSS-API.",
      "ja": "上記のメソッドのいずれかの「true」戻り値は、トークンが指定されたプロパティを示したことを示します。アプリケーションは、これらの補足値に対する適切な一連のアクションを決定する必要があります。これらは、GSS-APIではエラーとして扱われません。"
    },
    {
      "indent": 0,
      "text": "5.13. Names",
      "section_title": true,
      "ja": "5.13. お名前"
    },
    {
      "indent": 3,
      "text": "A name is used to identify a person or entity. GSS-API authenticates the relationship between a name and the entity claiming the name.",
      "ja": "名前は、個人またはエンティティを識別するために使用されます。 GSS-APIは、名前と、その名前を主張するエンティティとの関係を認証します。"
    },
    {
      "indent": 3,
      "text": "Since different authentication mechanisms may employ different namespaces for identifying their principals, GSS-API's naming support is necessarily complex in multi-mechanism environments (or even in some single-mechanism environments where the underlying mechanism supports multiple namespaces).",
      "ja": "異なる認証メカニズムはプリンシパルを識別するために異なる名前空間を使用する可能性があるため、GSS-APIの命名サポートは、マルチメカニズム環境（または、基礎となるメカニズムが複数の名前空間をサポートする一部の単一メカニズム環境）でも必然的に複雑になります。"
    },
    {
      "indent": 3,
      "text": "Two distinct conceptual representations are defined for names:",
      "ja": "名前には、2つの異なる概念表現が定義されています。"
    },
    {
      "indent": 3,
      "text": "1) A GSS-API form represented by implementations of the GSSName interface: A single GSSName object MAY contain multiple names from different namespaces, but all names SHOULD refer to the same entity. An example of such an internal name would be the name returned from a call to the getName method of the GSSCredential interface, when applied to a credential containing credential elements for multiple authentication mechanisms employing different namespaces. This GSSName object will contain a distinct name for the entity for each authentication mechanism.",
      "ja": "1）GSSNameインターフェースの実装によって表されるGSS-APIフォーム：単一のGSSNameオブジェクトには、異なる名前空間からの複数の名前を含めることができますが、すべての名前は同じエンティティを参照する必要があります（SHOULD）。このような内部名の例は、GSSCredentialインターフェースのgetNameメソッドの呼び出しから返される名前であり、異なる名前空間を使用する複数の認証メカニズムの資格情報要素を含む資格情報に適用されます。このGSSNameオブジェクトには、各認証メカニズムのエンティティの個別の名前が含まれます。"
    },
    {
      "indent": 6,
      "text": "For GSS-API implementations supporting multiple namespaces, GSSName implementations MUST contain sufficient information to determine the namespace to which each primitive name belongs.",
      "ja": "複数の名前空間をサポートするGSS-API実装の場合、GSSName実装には、各プリミティブ名が属する名前空間を決定するための十分な情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "2) Mechanism-specific contiguous byte array and string forms: Different GSSName initialization methods are provided to handle both byte array and string formats and to accommodate various calling applications and name types. These formats are capable of containing only a single name (from a single namespace). Contiguous string names are always accompanied by an Object Identifier specifying the namespace to which the name belongs, and their format is dependent on the authentication mechanism that employs that name. The string name forms are assumed to be printable and may therefore be used by GSS-API applications for communication with their users. The byte array name formats are assumed to be in non-printable formats (e.g., the byte array returned from the export method of the GSSName interface).",
      "ja": "2）メカニズム固有の連続したバイト配列と文字列形式：バイト配列と文字列形式の両方を処理し、さまざまな呼び出しアプリケーションと名前タイプに対応するために、さまざまなGSSName初期化メソッドが提供されています。これらのフォーマットは、単一の名前空間からの単一の名前のみを含むことができます。連続する文字列名には、常にその名前が属する名前空間を指定するオブジェクト識別子が付いており、その形式はその名前を使用する認証メカニズムに依存しています。文字列名の形式は印刷可能であると想定されているため、GSS-APIアプリケーションでユーザーとの通信に使用できます。バイト配列名の形式は、印刷不可能な形式（GSSNameインターフェースのエクスポートメソッドから返されるバイト配列など）であると見なされます。"
    },
    {
      "indent": 3,
      "text": "A GSSName object can be converted to a contiguous representation by using the toString method. This will guarantee that the name will be converted to a printable format. Different initialization methods in the GSSName interface are defined to allow support for multiple syntaxes for each supported namespace and to allow users the freedom to choose a preferred name representation. The toString method SHOULD use an implementation-chosen printable syntax for each supported name type. To obtain the printable name type, the getStringNameType method can be used.",
      "ja": "GSSNameオブジェクトは、toStringメソッドを使用して、連続した表現に変換できます。これにより、名前が印刷可能な形式に変換されることが保証されます。 GSSNameインターフェースのさまざまな初期化メソッドが定義されており、サポートされている名前空間ごとに複数の構文をサポートし、ユーザーが自由に好みの名前表現を選択できるようにしています。 toStringメソッドは、サポートされている名前タイプごとに、実装で選択された印刷可能な構文を使用する必要があります（SHOULD）。印刷可能な名前タイプを取得するには、getStringNameTypeメソッドを使用できます。"
    },
    {
      "indent": 3,
      "text": "There is no guarantee that calling the toString method on the GSSName interface will produce the same string form as the original imported string name. Furthermore, it is possible that the name was not even constructed from a string representation. The same applies to namespace identifiers, which may not necessarily survive unchanged after a journey through the internal name form. An example of this might be a mechanism that authenticates X.500 names but provides an algorithmic mapping of Internet DNS names into X.500. That mechanism's implementation of GSSName might, when presented with a DNS name, generate an internal name that contained both the original DNS name and the equivalent X.500 name. Alternatively, it might only store the X.500 name. In the latter case, the toString method of GSSName would most likely generate a printable X.500 name, rather than the original DNS name.",
      "ja": "GSSNameインターフェースでtoStringメソッドを呼び出しても、インポートされた元の文字列名と同じ文字列形式が生成される保証はありません。さらに、名前が文字列表現から構築されていなかった可能性もあります。同じことが名前空間識別子にも当てはまり、内部の名前形式をたどった後も、名前空間識別子が変わらないとは限りません。この例として、X.500名を認証するメカニズムがありますが、インターネットDNS名のアルゴリズムマッピングをX.500に提供します。そのメカニズムのGSSNameの実装は、DNS名が提示されると、元のDNS名と同等のX.500名の両方を含む内部名を生成する可能性があります。または、X.500名のみを保存する場合もあります。後者の場合、GSSNameのtoStringメソッドは、元のDNS名ではなく、印刷可能なX.500名を生成する可能性があります。"
    },
    {
      "indent": 0,
      "text": " The context acceptor can obtain a GSSName object representing the entity performing the context initiation (through the usage of the getSrcName method). Since this name has been authenticated by a single mechanism, it contains only a single name (even if the internal name presented by the context initiator to the GSSContext object had multiple components). Such names are termed internal-mechanism names (or MNs), and the names emitted by the GSSContext interface's getSrcName and getTargName methods are always of this type. Since some applications may require MNs without wanting to incur the overhead of an authentication operation, creation methods are provided that take not only the name buffer and name type but also the mechanism OID for which this name should be created. When dealing with an existing GSSName object, the canonicalize method may be invoked to convert a general internal name into an MN.",
      "ja": "コンテキスト受け入れ側は、（getSrcNameメソッドを使用して）コンテキスト開始を実行するエンティティを表すGSSNameオブジェクトを取得できます。この名前は単一のメカニズムによって認証されているため、コンテキストイニシエーターによってGSSContextオブジェクトに提示された内部名に複数のコンポーネントがあったとしても、単一の名前しか含まれていません。このような名前は内部メカニズム名（またはMN）と呼ばれ、GSSContextインターフェースのgetSrcNameメソッドとgetTargNameメソッドによって発行される名前は常にこのタイプです。一部のアプリケーションは、認証操作のオーバーヘッドを発生させたくないMNを必要とする場合があるため、名前バッファーと名前タイプだけでなく、この名前が作成されるメカニズムOIDも使用する作成メソッドが提供されます。既存のGSSNameオブジェクトを処理する場合、canonicalizeメソッドを呼び出して、一般的な内部名をMNに変換できます。"
    },
    {
      "indent": 3,
      "text": "GSSName objects can be compared using their equal method, which returns \"true\" if the two names being compared refer to the same entity. This is the preferred way to perform name comparisons instead of using the printable names that a given GSS-API implementation may support. Since GSS-API assumes that all primitive names contained within a given internal name refer to the same entity, equal can return \"true\" if the two names have at least one primitive name in common. If the implementation embodies knowledge of equivalence relationships between names taken from different namespaces, this knowledge may also allow successful comparisons of internal names containing no overlapping primitive elements. However, applications SHOULD note that to avoid surprising behavior, it is best to ensure that the names being compared are either both mechanism names for the same mechanism or both internal names that are not mechanism names. This holds whether the equals method is used directly or the export method is used to generate byte strings that are then compared byte-by-byte.",
      "ja": "GSSNameオブジェクトは、比較される2つの名前が同じエンティティを参照している場合に「true」を返すequalメソッドを使用して比較できます。これは、特定のGSS-API実装がサポートしている印刷可能な名前を使用する代わりに、名前の比較を実行するための推奨される方法です。 GSS-APIは、特定の内部名に含まれるすべてのプリミティブ名が同じエンティティを参照すると想定しているため、2つの名前に少なくとも1つのプリミティブ名が共通している場合、equalは「true」を返すことができます。実装が異なる名前空間から取得された名前間の同値関係の知識を具体化している場合、この知識により、重複するプリミティブ要素を含まない内部名の比較を成功させることもできます。ただし、アプリケーションは、予期しない動作を避けるために、比較される名前が同じメカニズムの両方のメカニズム名か、メカニズム名ではない両方の内部名であることを確認するのが最善であることに注意する必要があります。これは、equalsメソッドを直接使用するか、exportメソッドを使用してバイト文字列を生成し、バイトごとに比較するかを保持します。"
    },
    {
      "indent": 3,
      "text": "When used in large access control lists, the overhead of creating a GSSName object on each name and invoking the equal method on each name from the Access Control List (ACL) may be prohibitive. As an alternative way of supporting this case, GSS-API defines a special form of the contiguous byte array name, which MAY be compared directly (byte by byte). Contiguous names suitable for comparison are generated by the export method. Exported names MAY be re-imported by using the byte array constructor and specifying the NT_EXPORT_NAME as the name type Object Identifier. The resulting GSSName name will also be an MN.",
      "ja": "大規模なアクセス制御リストで使用する場合、各名前にGSSNameオブジェクトを作成し、アクセス制御リスト（ACL）から各名前にequalメソッドを呼び出すオーバーヘッドが非常に大きくなる場合があります。このケースをサポートする別の方法として、GSS-APIは連続したバイト配列名の特別な形式を定義します。これは直接比較できます（バイト単位）。比較に適した連続した名前は、exportメソッドによって生成されます。エクスポートされた名前は、バイト配列コンストラクターを使用し、NT_EXPORT_NAMEを名前タイプのオブジェクトIDとして指定することにより、再インポートされる場合があります。結果のGSSName名もMNになります。"
    },
    {
      "indent": 3,
      "text": "The GSSName interface defines public static Oid objects representing the standard name types. Structurally, an exported name object consists of a header containing an OID identifying the mechanism that authenticated the name, and a trailer containing the name itself, where the syntax of the trailer is defined by the individual mechanism specification. Detailed description of the format is specified in the language-independent GSS-API specification [RFC2743].",
      "ja": "GSSNameインターフェースは、標準の名前タイプを表すpublic static Oidオブジェクトを定義します。構造的に、エクスポートされた名前オブジェクトは、名前を認証したメカニズムを識別するOIDを含むヘッダーと、名前自体を含むトレーラーで構成されます。トレーラーの構文は、個々のメカニズム仕様によって定義されます。形式の詳細な説明は、言語に依存しないGSS-API仕様[RFC2743]で指定されています。"
    },
    {
      "indent": 0,
      "text": " Note that the results obtained by using the equals method will in general be different from those obtained by invoking canonicalize and export and then comparing the byte array output. The first series of operation determines whether two (unauthenticated) names identify the same principal; the second determines whether a particular mechanism would authenticate them as the same principal. These two operations will in general give the same results only for MNs.",
      "ja": "equalsメソッドを使用して得られた結果は、一般的に、canonicalizeとexportを呼び出してからバイト配列出力を比較して得られた結果とは異なることに注意してください。最初の一連の操作は、2つの（認証されていない）名前が同じプリンシパルを識別するかどうかを決定します。 2番目は、特定のメカニズムがそれらを同じプリンシパルとして認証するかどうかを決定します。これら2つの操作は、通常、MNに対してのみ同じ結果をもたらします。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the above are guidelines as to how GSSName implementations SHOULD behave and are not intended to be specific requirements of how name objects must be implemented. The mechanism designers are free to decide on the details of their implementations of the GSSName interface as long as the behavior satisfies the above guidelines.",
      "ja": "上記はGSSNameの実装がどのように動作するかについてのガイドラインであり、名前オブジェクトの実装方法の特定の要件を意図したものではないことに注意することが重要です。メカニズムの設計者は、動作が上記のガイドラインを満たす限り、GSSNameインターフェースの実装の詳細を自由に決定できます。"
    },
    {
      "indent": 0,
      "text": "5.14. Channel Bindings",
      "section_title": true,
      "ja": "5.14. チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "GSS-API supports the use of user-specified tags to identify a given context to the peer application. These tags are intended to be used to identify the particular communications channel that carries the context. Channel bindings are communicated to the GSS-API using the ChannelBinding object. The application MAY use byte arrays as well as instances of InetAddress to specify the application data to be used in the channel binding. The InetAddress for the initiator and/ or acceptor can be used within an instance of a ChannelBinding. ChannelBinding can be set for the GSSContext object using the setChannelBinding method before the first call to init or accept has been performed. Unless the setChannelBinding method has been used to set the ChannelBinding for a GSSContext object, \"null\" ChannelBinding will be assumed. InetAddress is currently the only address type defined within the Java platform and as such, it is the only one supported within the ChannelBinding class. Applications that use other types of addresses can include them as part of the application-specific data.",
      "ja": "GSS-APIは、ピアアプリケーションへの特定のコンテキストを識別するために、ユーザー指定のタグの使用をサポートしています。これらのタグは、コンテキストを運ぶ特定の通信チャネルを識別するために使用することを目的としています。チャネルバインディングは、ChannelBindingオブジェクトを使用してGSS-APIに伝達されます。アプリケーションはバイト配列とInetAddressのインスタンスを使用して、チャネルバインディングで使用するアプリケーションデータを指定できます（MAY）。イニシエーターまたはアクセプター、あるいはその両方のInetAddressは、ChannelBindingのインスタンス内で使用できます。 ChannelBindingは、最初のinitまたはacceptの呼び出しが実行される前に、setChannelBindingメソッドを使用してGSSContextオブジェクトに設定できます。 setChannelBindingメソッドを使用してGSSContextオブジェクトのChannelBindingを設定していない限り、「null」のChannelBindingが想定されます。 InetAddressは現在、Javaプラットフォーム内で定義されている唯一のアドレスタイプであるため、ChannelBindingクラス内でサポートされている唯一のアドレスタイプです。他のタイプのアドレスを使用するアプリケーションは、それらをアプリケーション固有のデータの一部として含めることができます。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the GSS-API concatenates the initiator and acceptor address information and the application-supplied byte array to form an octet string. The mechanism calculates a Message Integrity Code (MIC) over this octet string and binds the MIC to the context establishment token emitted by the init method of the GSSContext interface. The same bindings are set by the context acceptor for its GSSContext object, and during processing of the accept method, a MIC is calculated in the same way. The calculated MIC is compared with that found in the token, and if the MICs differ, accept will throw a GSSException with the major code set to BAD_BINDINGS, and the context will not be established. Some mechanisms may include the actual channel-binding data in the token (rather than just a MIC); applications SHOULD therefore not use confidential data as channel-binding components.",
      "ja": "概念的には、GSS-APIはイニシエーターとアクセプターのアドレス情報とアプリケーション提供のバイト配列を連結して、オクテット文字列を形成します。このメカニズムは、このオクテット文字列に対してメッセージ整合性コード（MIC）を計算し、MICをGSSContextインターフェースのinitメソッドによって発行されたコンテキスト確立トークンにバインドします。同じバインディングがGSSContextオブジェクトのコンテキストアクセプターによって設定され、acceptメソッドの処理中にMICが同じ方法で計算されます。計算されたMICはトークンで検出されたものと比較され、MICが異なる場合、acceptはメジャーコードがBAD_BINDINGSに設定されたGSSExceptionをスローし、コンテキストは確立されません。一部のメカニズムでは、（MICだけでなく）実際のチャネルバインディングデータがトークンに含まれる場合があります。したがって、アプリケーションは機密データをチャネルバインディングコンポーネントとして使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Individual mechanisms may impose additional constraints on addresses that may appear in channel bindings. For example, a mechanism may verify that the initiator address field of the channel binding contains the correct network address of the host system. Portable applications SHOULD therefore ensure that they either provide correct information for the address fields or omit the setting of the addressing information.",
      "ja": "個々のメカニズムによって、チャネルバインディングに表示される可能性のあるアドレスに追加の制約が課される場合があります。たとえば、メカニズムは、チャネルバインディングのイニシエーターアドレスフィールドにホストシステムの正しいネットワークアドレスが含まれていることを確認します。したがって、移植可能なアプリケーションは、アドレスフィールドに正しい情報を提供するか、アドレス指定情報の設定を省略してください。"
    },
    {
      "indent": 0,
      "text": "5.15. Optional Parameters",
      "section_title": true,
      "ja": "5.15. オプションのパラメーター"
    },
    {
      "indent": 3,
      "text": "Whenever the application wishes to omit an optional parameter, the \"null\" value SHALL be used. The detailed method descriptions indicate which parameters are optional. Method overloading has also been used as a technique to indicate default parameters.",
      "ja": "アプリケーションがオプションのパラメーターを省略したいときはいつでも、「null」値を使用する必要があります。メソッドの詳細な説明は、オプションのパラメーターを示しています。メソッドのオーバーロードは、デフォルトのパラメータを示す手法としても使用されています。"
    },
    {
      "indent": 0,
      "text": "6. Introduction to GSS-API Classes and Interfaces",
      "section_title": true,
      "ja": "6. GSS-APIクラスとインターフェースの紹介"
    },
    {
      "indent": 3,
      "text": "This section presents a brief description of the classes and interfaces that constitute the GSS-API. The implementations of these are obtained from the CLASSPATH defined by the application. If Java GSS becomes part of the standard Java APIs, then these classes will be available by default on all systems as part of the JRE's system classes.",
      "ja": "この節では、GSS-APIを構成するクラスとインタフェースについて簡単に説明します。これらの実装は、アプリケーションによって定義されたCLASSPATHから取得されます。 Java GSSが標準のJava APIの一部になると、これらのクラスは、JREのシステムクラスの一部として、すべてのシステムでデフォルトで使用できるようになります。"
    },
    {
      "indent": 3,
      "text": "This section also shows the corresponding RFC 2743 [RFC2743] functionality implemented by each of the classes. Detailed description of these classes and their methods is presented in Section 7.",
      "ja": "このセクションでは、各クラスによって実装される対応するRFC 2743 [RFC2743]機能も示します。これらのクラスとそのメソッドの詳細については、セクション7で説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. GSSManager Class",
      "section_title": true,
      "ja": "6.1. GSSManagerクラス"
    },
    {
      "indent": 3,
      "text": "This abstract class serves as a factory to instantiate implementations of the GSS-API interfaces and also provides methods to make queries about underlying security mechanisms.",
      "ja": "この抽象クラスは、GSS-APIインタフェースの実装をインスタンス化するファクトリとして機能し、基礎となるセキュリティメカニズムに関するクエリを行うメソッドも提供します。"
    },
    {
      "indent": 3,
      "text": "A default implementation can be obtained using the static method getInstance(). Applications that desire to provide their own implementation of the GSSManager class can simply extend the abstract class themselves.",
      "ja": "デフォルトの実装は、静的メソッドgetInstance()を使用して取得できます。 GSSManagerクラスの独自の実装を提供することを望むアプリケーションは、抽象クラス自体を単純に拡張できます。"
    },
    {
      "indent": 3,
      "text": "This class contains equivalents of the following RFC 2743 [RFC2743] routines:",
      "ja": "このクラスには、次のRFC 2743 [RFC2743]ルーチンに相当するものが含まれています。"
    },
    {
      "indent": 3,
      "text": "+----------------------------+-------------------------+------------+\n| RFC 2743 Routine           | Function                | Section(s) |\n+----------------------------+-------------------------+------------+\n| gss_import_name            | Create an internal name | 7.1.5 -    |\n|                            | from the supplied       | 7.1.8      |\n|                            | information.            |            |\n| gss_acquire_cred           | Acquire credential for  | 7.1.9 -    |\n|                            | use.                    | 7.1.11     |\n| gss_import_sec_context     | Create a previously     | 7.1.14     |\n|                            | exported context.       |            |\n| gss_indicate_mechs         | List the mechanisms     | 7.1.2      |\n|                            | supported by this GSS-  |            |\n|                            | API implementation.     |            |\n| gss_inquire_mechs_for_name | List the mechanisms     | 7.1.4      |\n|                            | supporting the          |            |\n|                            | specified name type.    |            |\n| gss_inquire_names_for_mech | List the name types     | 7.1.3      |\n|                            | supported by the        |            |\n|                            | specified mechanism.    |            |\n+----------------------------+-------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. GSSName Interface",
      "section_title": true,
      "ja": "6.2. GSSNameインターフェース"
    },
    {
      "indent": 3,
      "text": "GSS-API names are represented in the Java bindings through the GSSName interface. Different name formats and their definitions are identified with Universal OIDs. The format of the names can be derived based on the unique OID of each name type. The following GSS-API routines are provided by the GSSName interface:",
      "ja": "GSS-API名は、GSSNameインターフェースを介してJavaバインディングで表されます。さまざまな名前の形式とその定義は、ユニバーサルOIDで識別されます。名前の形式は、各名前タイプの一意のOIDに基づいて導出できます。次のGSS-APIルーチンは、GSSNameインターフェースによって提供されます。"
    },
    {
      "indent": 3,
      "text": "+-----------------------+------------------------------+------------+\n| RFC 2743 Routine      | Function                     | Section(s) |\n+-----------------------+------------------------------+------------+\n| gss_display_name      | Convert internal name        | 7.2.6      |\n|                       | representation to text       |            |\n|                       | format.                      |            |\n| gss_compare_name      | Compare two internal names.  | 7.2.2,     |\n|                       |                              | 7.2.3      |\n| gss_release_name      | Release resources associated | N/A        |\n|                       | with the internal name.      |            |\n| gss_canonicalize_name | Convert an internal name to  | 7.2.4      |\n|                       | a mechanism name.            |            |\n| gss_export_name       | Convert a mechanism name to  | 7.2.5      |\n|                       | export format.               |            |\n| gss_duplicate_name    | Create a copy of the         | N/A        |\n|                       | internal name.               |            |\n+-----------------------+------------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The gss_release_name call is not provided as Java does its own garbage collection. The gss_duplicate_name call is also redundant; the GSSName interface has no mutator methods that can change the state of the object, so it is safe for sharing across threads.",
      "ja": "Javaは独自のガベージコレクションを行うため、gss_release_name呼び出しは提供されません。 gss_duplicate_name呼び出しも冗長です。 GSSNameインターフェースには、オブジェクトの状態を変更できるミューテーターメソッドがないため、スレッド間で共有しても安全です。"
    },
    {
      "indent": 0,
      "text": "6.3. GSSCredential Interface",
      "section_title": true,
      "ja": "6.3. GSSCredentialインターフェース"
    },
    {
      "indent": 3,
      "text": "The GSSCredential interface is responsible for the encapsulation of GSS-API credentials. Credentials identify a single entity and provide the necessary cryptographic information to enable the creation of a context on behalf of that entity. A single credential may contain multiple mechanism-specific credentials, each referred to as a credential element. The GSSCredential interface provides the functionality of the following GSS-API routines:",
      "ja": "GSSCredentialインターフェースは、GSS-API資格情報のカプセル化を担当します。クレデンシャルは単一のエンティティを識別し、そのエンティティに代わってコンテキストを作成できるようにするために必要な暗号情報を提供します。単一の資格情報には、複数のメカニズム固有の資格情報が含まれる場合があり、それぞれ資格情報要素と呼ばれます。 GSSCredentialインターフェースは、以下のGSS-APIルーチンの機能を提供します。"
    },
    {
      "indent": 3,
      "text": "+--------------------------+---------------------------+------------+\n| RFC 2743 Routine         | Function                  | Section(s) |\n+--------------------------+---------------------------+------------+\n| gss_add_cred             | Constructs credentials    | 7.3.11     |\n|                          | incrementally.            |            |\n| gss_inquire_cred         | Obtain information about  | 7.3.3 -    |\n|                          | credential.               | 7.3.10     |\n| gss_inquire_cred_by_mech | Obtain per-mechanism      | 7.3.4 -    |\n|                          | information about a       | 7.3.9      |\n|                          | credential.               |            |\n| gss_release_cred         | Dispose of credentials    | 7.3.2      |\n|                          | after use.                |            |\n+--------------------------+---------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.4. GSSContext Interface",
      "section_title": true,
      "ja": "6.4. GSSContextインターフェース"
    },
    {
      "indent": 3,
      "text": "This interface encapsulates the functionality of context-level calls required for security context establishment and management between peers as well as the per-message services offered to applications. A context is established between a pair of peers and allows the usage of security services on a per-message basis on application data. It is created over a single security mechanism. The GSSContext interface provides the functionality of the following GSS-API routines:",
      "ja": "このインターフェイスは、ピア間のセキュリティコンテキストの確立と管理、およびアプリケーションに提供されるメッセージごとのサービスに必要なコンテキストレベルの呼び出しの機能をカプセル化します。コンテキストはピアのペア間で確立され、アプリケーションデータに基づいてメッセージごとにセキュリティサービスを使用できるようにします。単一のセキュリティメカニズム上に作成されます。 GSSContextインタフェースは、次のGSS-APIルーチンの機能を提供します。"
    },
    {
      "indent": 3,
      "text": "+------------------------+-----------------------------+------------+\n| RFC 2743 Routine       | Function                    | Section(s) |\n+------------------------+-----------------------------+------------+\n| gss_init_sec_context   | Initiate the creation of a  | 7.4.2      |\n|                        | security context with a     |            |\n|                        | peer.                       |            |\n| gss_accept_sec_context | Accept a security context   | 7.4.3      |\n|                        | initiated by a peer.        |            |\n| gss_delete_sec_context | Destroy a security context. | 7.4.5      |\n| gss_context_time       | Obtain remaining context    | 7.4.30     |\n|                        | time.                       |            |\n| gss_inquire_context    | Obtain context              | 7.4.21 -   |\n|                        | characteristics.            | 7.4.35     |\n| gss_wrap_size_limit    | Determine token-size limit  | 7.4.6      |\n|                        | for gss_wrap.               |            |\n| gss_export_sec_context | Transfer security context   | 7.4.11     |\n|                        | to another process.         |            |\n| gss_get_mic            | Calculate a cryptographic   | 7.4.9      |\n|                        | Message Integrity Code      |            |\n|                        | (MIC) for a message.        |            |\n| gss_verify_mic         | Verify integrity on a       | 7.4.10     |\n|                        | received message.           |            |\n| gss_wrap               | Attach a MIC to a message   | 7.4.7      |\n|                        | and optionally encrypt the  |            |\n|                        | message content.            |            |\n| gss_unwrap             | Obtain a previously wrapped | 7.4.8      |\n|                        | application message         |            |\n|                        | verifying its integrity and |            |\n|                        | optionally decrypting it.   |            |\n+------------------------+-----------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " The functionality offered by the gss_process_context_token routine has not been included in the Java bindings specification. The corresponding functionality of gss_delete_sec_context has also been modified to not return any peer tokens. This has been proposed in accordance to the recommendations stated in RFC 2743 [RFC2743]. GSSContext does offer the functionality of destroying the locally stored context information.",
      "ja": "gss_process_context_tokenルーチンが提供する機能は、Javaバインディング仕様には含まれていません。 gss_delete_sec_contextの対応する機能も、ピアトークンを返さないように変更されました。これは、RFC 2743 [RFC2743]に記載されている推奨事項に従って提案されています。 GSSContextは、ローカルに保存されたコンテキスト情報を破棄する機能を提供します。"
    },
    {
      "indent": 0,
      "text": "6.5. MessageProp Class",
      "section_title": true,
      "ja": "6.5. MessagePropクラス"
    },
    {
      "indent": 3,
      "text": "This helper class is used in the per-message operations on the context. An instance of this class is created by the application and then passed into the per-message calls. In some cases, the application conveys information to the GSS-API implementation through this object, and in other cases, the GSS-API returns information to the application by setting it in this object. See the description of the per-message operations wrap, unwrap, getMIC, and verifyMIC in the GSSContext interfaces for details.",
      "ja": "このヘルパークラスは、コンテキストのメッセージごとの操作で使用されます。このクラスのインスタンスはアプリケーションによって作成され、メッセージごとの呼び出しに渡されます。場合によっては、アプリケーションがこのオブジェクトを介してGSS-API実装に情報を伝達することもあれば、GSS-APIがこのオブジェクトに設定することによって情報をアプリケーションに返すこともあります。詳細については、GSSContextインタフェースのメッセージごとの操作wrap、unwrap、getMIC、およびverifyMICの説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.6. GSSException Class",
      "section_title": true,
      "ja": "6.6. GSSExceptionクラス"
    },
    {
      "indent": 3,
      "text": "Exceptions are used in the Java bindings to signal fatal errors to the calling applications. This replaces the major and minor codes used in the C-bindings specification as a method of signaling failures. The GSSException class handles both minor and major codes, as well as their translation into textual representation. All GSS-API methods are declared as throwing this exception.",
      "ja": "例外はJavaバインディングで使用され、呼び出し元のアプリケーションに致命的なエラーを通知します。これは、障害を通知する方法として、Cバインディング仕様で使用されているメジャーコードとマイナーコードを置き換えます。 GSSExceptionクラスは、マイナーコードとメジャーコードの両方を処理し、それらをテキスト表現に変換します。すべてのGSS-APIメソッドは、この例外をスローするものとして宣言されています。"
    },
    {
      "indent": 3,
      "text": "+--------------------+----------------------------+-----------------+\n| RFC 2743 Routine   | Function                   | Section         |\n+--------------------+----------------------------+-----------------+\n| gss_display_status | Retrieve textual           | 7.8.5, 7.8.6,   |\n|                    | representation of error    | 7.8.9, 7.8.10   |\n|                    | codes.                     |                 |\n+--------------------+----------------------------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.7. Oid Class",
      "section_title": true,
      "ja": "6.7. Oidクラス"
    },
    {
      "indent": 3,
      "text": "This utility class is used to represent Universal Object Identifiers and their associated operations. GSS-API uses Object Identifiers to distinguish between security mechanisms and name types. This class, aside from being used whenever an Object Identifier is needed, implements the following GSS-API functionality:",
      "ja": "このユーティリティクラスは、ユニバーサルオブジェクト識別子とそれに関連する操作を表すために使用されます。 GSS-APIはオブジェクト識別子を使用して、セキュリティメカニズムと名前タイプを区別します。このクラスは、オブジェクト識別子が必要な場合は常に使用されるほか、次のGSS-API機能を実装します。"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-------------------------------+---------+\n| RFC 2743 Routine        | Function                      | Section |\n+-------------------------+-------------------------------+---------+\n| gss_test_oid_set_member | Determine if the specified    | 7.7.5   |\n|                         | OID is part of a set of OIDs. |         |\n+-------------------------+-------------------------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.8. ChannelBinding Class",
      "section_title": true,
      "ja": "6.8. ChannelBindingクラス"
    },
    {
      "indent": 3,
      "text": "An instance of this class is used to specify channel-binding information to the GSSContext object before the start of a security context establishment. The application may use a byte array to specify application data to be used in the channel binding as well as to use instances of the InetAddress. InetAddress is currently the only address type defined within the Java platform and as such, it is the only one supported within the ChannelBinding class. Applications that use other types of addresses can include them as part of the application data.",
      "ja": "このクラスのインスタンスは、セキュリティコンテキストの確立を開始する前に、GSSContextオブジェクトへのチャネルバインディング情報を指定するために使用されます。アプリケーションはバイト配列を使用して、チャネルバインディングで使用するアプリケーションデータを指定したり、InetAddressのインスタンスを使用したりできます。 InetAddressは現在、Javaプラットフォーム内で定義されている唯一のアドレスタイプであるため、ChannelBindingクラス内でサポートされている唯一のアドレスタイプです。他のタイプのアドレスを使用するアプリケーションは、それらをアプリケーションデータの一部として含めることができます。"
    },
    {
      "indent": 0,
      "text": "7. Detailed GSS-API Class Description",
      "section_title": true,
      "ja": "7. 詳細なGSS-APIクラスの説明"
    },
    {
      "indent": 3,
      "text": "This section lists a detailed description of all the public methods that each of the GSS-API classes and interfaces MUST provide.",
      "ja": "このセクションでは、GSS-APIクラスとインターフェースのそれぞれが提供しなければならないすべてのパブリックメソッドの詳細な説明をリストします。"
    },
    {
      "indent": 0,
      "text": "7.1. public abstract class GSSManager",
      "section_title": true,
      "ja": "7.1. パブリック抽象クラスGSSManager"
    },
    {
      "indent": 3,
      "text": "The GSSManager class is an abstract class that serves as a factory for three GSS interfaces: GSSName, GSSCredential, and GSSContext. It also provides methods for applications to determine what mechanisms are available from the GSS implementation and what name types these mechanisms support. An instance of the default GSSManager subclass MAY be obtained through the static method getInstance(), but applications are free to instantiate other subclasses of GSSManager.",
      "ja": "GSSManagerクラスは、GSSName、GSSCredential、およびGSSContextの3つのGSSインターフェースのファクトリとして機能する抽象クラスです。また、アプリケーションがGSS実装から利用できるメカニズムと、これらのメカニズムがサポートする名前のタイプを判別するためのメソッドも提供します。デフォルトのGSSManagerサブクラスのインスタンスは、静的メソッドgetInstance()を介して取得できますが、アプリケーションはGSSManagerの他のサブクラスを自由にインスタンス化できます。"
    },
    {
      "indent": 3,
      "text": "All but one method in this class are declared abstract. This means that subclasses have to provide the complete implementation for those methods. The only exception to this is the static method getInstance(), which will have platform-specific code to return an instance of the default subclass.",
      "ja": "このクラスの1つを除くすべてのメソッドは、抽象として宣言されています。つまり、サブクラスはこれらのメソッドの完全な実装を提供する必要があります。これに対する唯一の例外は、静的メソッドgetInstance()です。これには、デフォルトのサブクラスのインスタンスを返すプラットフォーム固有のコードが含まれます。"
    },
    {
      "indent": 3,
      "text": "Platform providers of GSS are REQUIRED not to add any constructors to this class, whether the constructor is private, public, or protected. This will ensure that all subclasses invoke only the default constructor provided to the base class by the compiler.",
      "ja": "GSSのプラットフォームプロバイダーは、コンストラクターがプライベート、パブリック、または保護されているかに関係なく、このクラスにコンストラクターを追加しないようにする必要があります。これにより、すべてのサブクラスが、コンパイラーによって基本クラスに提供されたデフォルトのコンストラクターのみを呼び出すようになります。"
    },
    {
      "indent": 3,
      "text": "A subclass extending the GSSManager abstract class MAY be implemented as a modular provider-based layer that utilizes some well-known service provider specification. The GSSManager API provides the application with methods to set provider preferences on such an implementation. These methods also allow the implementation to throw a well-defined exception in case provider-based configuration is not supported. Applications that expect to be portable SHOULD be aware of this and recover cleanly by catching the exception.",
      "ja": "GSSManager抽象クラスを拡張するサブクラスは、いくつかのよく知られたサービスプロバイダー仕様を利用するモジュールプロバイダーベースのレイヤーとして実装される場合があります。 GSSManager APIは、そのような実装でプロバイダー設定を設定するメソッドをアプリケーションに提供します。これらのメソッドを使用すると、プロバイダーベースの構成がサポートされていない場合に、実装が明確に定義された例外をスローすることもできます。移植性を期待しているアプリケーションは、これを認識し、例外をキャッチすることで完全に回復する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "It is envisioned that there will be three most common ways in which providers will be used:",
      "ja": "プロバイダーが使用される最も一般的な方法は3つあると想定されています。"
    },
    {
      "indent": 3,
      "text": "1) The application does not care about what provider is used (the default case).",
      "ja": "1）アプリケーションは、使用されるプロバイダー（デフォルトのケース）を気にしません。"
    },
    {
      "indent": 3,
      "text": "2) The application wants a particular provider to be used preferentially, either for a particular mechanism or all the time, irrespective of the mechanism.",
      "ja": "2）アプリケーションは、メカニズムに関係なく、特定のメカニズムに対して、または常時、特定のプロバイダーを優先的に使用することを望んでいます。"
    },
    {
      "indent": 3,
      "text": "3) The application wants to use the locally configured providers as far as possible, but if support is missing for one or more mechanisms, then it wants to fall back on its own provider.",
      "ja": "3）アプリケーションは、ローカルで構成されたプロバイダーを可能な限り使用したいが、1つ以上のメカニズムのサポートが不足している場合は、独自のプロバイダーにフォールバックしたい。"
    },
    {
      "indent": 3,
      "text": "The GSSManager class has two methods that enable these modes of usage: addProviderAtFront() and addProviderAtEnd(). These methods have the effect of creating an ordered list of <provider, OID> pairs where each pair indicates a preference of provider for a given OID.",
      "ja": "GSSManagerクラスには、これらの使用モードを有効にする2つのメソッド、addProviderAtFront()とaddProviderAtEnd()があります。これらのメソッドには、<プロバイダー、OID>ペアの順序付きリストを作成する効果があります。各ペアは、特定のOIDに対するプロバイダーの設定を示します。"
    },
    {
      "indent": 3,
      "text": "The use of these methods does not require any knowledge of whatever service provider specification the GSSManager subclass follows. It is hoped that these methods will serve the needs of most applications. Additional methods MAY be added to an extended GSSManager that could be part of a service provider specification that is standardized later.",
      "ja": "これらのメソッドの使用には、GSSManagerサブクラスが従うサービスプロバイダーの仕様に関する知識は必要ありません。これらのメソッドがほとんどのアプリケーションのニーズに役立つことが期待されます。追加のメソッドは、後で標準化されるサービスプロバイダー仕様の一部である可能性がある拡張GSSManagerに追加される場合があります。"
    },
    {
      "indent": 3,
      "text": "When neither of the methods is called, the implementation SHOULD choose a default provider for each mechanism it supports.",
      "ja": "どちらのメソッドも呼び出されない場合、実装は、サポートするメカニズムごとにデフォルトのプロバイダーを選択する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "7.1.1. getInstance",
      "section_title": true,
      "ja": "7.1.1. getInstance"
    },
    {
      "indent": 3,
      "text": "public static GSSManager getInstance()",
      "ja": "public static GSSManager getInstance()"
    },
    {
      "indent": 3,
      "text": "Returns the default GSSManager implementation.",
      "ja": "デフォルトのGSSManager実装を返します。"
    },
    {
      "indent": 0,
      "text": "7.1.2. getMechs",
      "section_title": true,
      "ja": "7.1.2. getMechs"
    },
    {
      "indent": 3,
      "text": "public abstract Oid[] getMechs()",
      "ja": "パブリック抽象Oid [] getMechs()"
    },
    {
      "indent": 3,
      "text": "Returns an array of Oid objects indicating the mechanisms available to GSS-API callers. A \"null\" value is returned when no mechanisms are available (an example of this would be when mechanisms are dynamically configured, and currently no mechanisms are installed).",
      "ja": "GSS-API呼び出し元が使用できるメカニズムを示すOidオブジェクトの配列を返します。メカニズムが使用できない場合は「null」値が返されます（この例としては、メカニズムが動的に構成されていて、現在メカニズムがインストールされていない場合など）。"
    },
    {
      "indent": 0,
      "text": "7.1.3. getNamesForMech",
      "section_title": true,
      "ja": "7.1.3. getNamesForMech"
    },
    {
      "indent": 3,
      "text": "public abstract Oid[] getNamesForMech(Oid mech) throws GSSException",
      "ja": "public abstract Oid [] getNamesForMech（Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns name type OIDs supported by the specified mechanism.",
      "ja": "指定されたメカニズムでサポートされている名前タイプOIDを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mech The Oid object for the mechanism to query.",
      "ja": "mechクエリするメカニズムのOidオブジェクト。"
    },
    {
      "indent": 0,
      "text": "7.1.4. getMechsForName",
      "section_title": true,
      "ja": "7.1.4. getMechsForName"
    },
    {
      "indent": 3,
      "text": "public abstract Oid[] getMechsForName(Oid nameType)",
      "ja": "パブリック抽象Oid [] getMechsForName（Oid nameType）"
    },
    {
      "indent": 3,
      "text": "Returns an array of Oid objects corresponding to the mechanisms that support the specific name type. \"null\" is returned when no mechanisms are found to support the specified name type.",
      "ja": "特定の名前タイプをサポートするメカニズムに対応するOidオブジェクトの配列を返します。 「null」は、指定された名前タイプをサポートするメカニズムが見つからない場合に返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "nameType The Oid object for the name type.",
      "ja": "nameType名前タイプのOidオブジェクト。"
    },
    {
      "indent": 0,
      "text": "7.1.5. createName",
      "section_title": true,
      "ja": "7.1.5. createName"
    },
    {
      "indent": 3,
      "text": "public abstract GSSName createName(String nameStr, Oid nameType) throws GSSException",
      "ja": "public abstract GSSName createName（String nameStr、Oid nameType）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method to convert a contiguous string name from the specified namespace to a GSSName object. In general, the GSSName object created will not be an MN; two examples that are exceptions to this are when the namespace type parameter indicates NT_EXPORT_NAME or when the GSS-API implementation does not support multiple mechanisms.",
      "ja": "連続する文字列名を指定された名前空間からGSSNameオブジェクトに変換するファクトリメソッド。一般に、作成されたGSSNameオブジェクトはMNではありません。これの例外となる2つの例は、名前空間タイプパラメータがNT_EXPORT_NAMEを示している場合、またはGSS-API実装が複数のメカニズムをサポートしていない場合です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "nameStr The string representing a printable form of the name to create.",
      "ja": "nameStr作成する名前の印刷可能な形式を表す文字列。"
    },
    {
      "indent": 3,
      "text": "nameType The OID specifying the namespace of the printable name is supplied. Note that nameType serves to describe and qualify the interpretation of the input nameStr; it does not necessarily imply a type for the output GSSName implementation. The \"null\" value can be used to specify that a mechanism-specific default printable syntax SHOULD be assumed by each mechanism that examines nameStr.",
      "ja": "nameType印刷可能な名前の名前空間を指定するOIDが提供されます。 nameTypeは、入力nameStrの解釈を説明および修飾するために役立つことに注意してください。出力GSSName実装のタイプを必ずしも意味するわけではありません。 「null」値を使用して、メカニズム固有のデフォルトの印刷可能な構文がnameStrを検査する各メカニズムによって想定される必要があることを指定できます。"
    },
    {
      "indent": 0,
      "text": "7.1.6. createName",
      "section_title": true,
      "ja": "7.1.6. createName"
    },
    {
      "indent": 3,
      "text": "public abstract GSSName createName(byte[] name, Oid nameType) throws GSSException",
      "ja": "public abstract GSSName createName（byte [] name、Oid nameType）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method to convert a contiguous byte array containing a name from the specified namespace to a GSSName object. In general, the GSSName object created will not be an MN; two examples that are exceptions to this are when the namespace type parameter indicates NT_EXPORT_NAME or when the GSS-API implementation is not a multi-mechanism.",
      "ja": "名前を含む連続したバイト配列を、指定された名前空間からGSSNameオブジェクトに変換するファクトリメソッド。一般に、作成されたGSSNameオブジェクトはMNではありません。これの例外である2つの例は、名前空間タイプパラメータがNT_EXPORT_NAMEを示す場合、またはGSS-API実装がマルチメカニズムではない場合です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "name The byte array containing the name to create.",
      "ja": "name作成する名前を含むバイト配列。"
    },
    {
      "indent": 3,
      "text": "nameType The OID specifying the namespace of the name supplied in the byte array. Note that nameType serves to describe and qualify the interpretation of the input name byte array; it does not necessarily imply a type for the output GSSName implementation. The \"null\" value can be used to specify that a mechanism-specific default syntax SHOULD be assumed by each mechanism that examines the byte array.",
      "ja": "nameTypeバイト配列で提供される名前の名前空間を指定するOID。 nameTypeは、入力名バイト配列の解釈を記述および修飾する役割を果たすことに注意してください。出力GSSName実装のタイプを必ずしも意味するわけではありません。 「null」値を使用して、バイト配列を検査するメカニズムごとに、メカニズム固有のデフォルト構文を想定する必要があることを指定できます。"
    },
    {
      "indent": 0,
      "text": "7.1.7. createName",
      "section_title": true,
      "ja": "7.1.7. createName"
    },
    {
      "indent": 3,
      "text": "public abstract GSSName createName(String nameStr, Oid nameType, Oid mech) throws GSSException",
      "ja": "public abstract GSSName createName（String nameStr、Oid nameType、Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Factory method to convert a contiguous string name from the specified namespace to a GSSName object that is a mechanism name (MN). In other words, this method is a utility that does the equivalent of two steps: the createName described in Section 7.1.5 and also the GSSName.canonicalize() described in Section 7.2.4.",
      "ja": "指定された名前空間からメカニズム名（MN）であるGSSNameオブジェクトに連続した文字列名を変換するファクトリメソッド。言い換えると、このメソッドは、2つのステップに相当するユーティリティです。セクション7.1.5で説明されているcreateNameと、セクション7.2.4で説明されているGSSName.canonicalize()です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "nameStr The string representing a printable form of the name to create.",
      "ja": "nameStr作成する名前の印刷可能な形式を表す文字列。"
    },
    {
      "indent": 3,
      "text": "nameType The OID specifying the namespace of the printable name supplied. Note that nameType serves to describe and qualify the interpretation of the input nameStr; it does not necessarily imply a type for the output GSSName implementation. The \"null\" value can be used to specify that a mechanism-specific default printable syntax SHOULD be assumed when the mechanism examines nameStr.",
      "ja": "nameType指定された印刷可能な名前の名前空間を指定するOID。 nameTypeは、入力nameStrの解釈を説明および修飾するために役立つことに注意してください。出力GSSName実装のタイプを必ずしも意味するわけではありません。 「null」値を使用して、メカニズムがnameStrを検査するときに、メカニズム固有のデフォルトの印刷可能な構文を想定する必要があることを指定できます。"
    },
    {
      "indent": 3,
      "text": "mech OID specifying the mechanism for which this name should be created.",
      "ja": "この名前を作成するメカニズムを指定するmech OID。"
    },
    {
      "indent": 0,
      "text": "7.1.8. createName",
      "section_title": true,
      "ja": "7.1.8. createName"
    },
    {
      "indent": 3,
      "text": "public abstract GSSName createName(byte[] name, Oid nameType, Oid mech) throws GSSException",
      "ja": "public abstract GSSName createName（byte [] name、Oid nameType、Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Factory method to convert a contiguous byte array containing a name from the specified namespace to a GSSName object that is an MN. In other words, this method is a utility that does the equivalent of two steps: the createName described in Section 7.1.6 and also the GSSName.canonicalize() described in Section 7.2.4.",
      "ja": "名前を含む連続したバイト配列を指定された名前空間からMNであるGSSNameオブジェクトに変換するファクトリメソッド。つまり、このメソッドは、2.Stepに相当するユーティリティです。セクション7.1.6で説明されているcreateNameと、セクション7.2.4で説明されているGSSName.canonicalize()です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "name The byte array representing the name to create.",
      "ja": "name作成する名前を表すバイト配列。"
    },
    {
      "indent": 3,
      "text": "nameType The OID specifying the namespace of the name supplied in the byte array. Note that nameType serves to describe and qualify the interpretation of the input name byte array; it does not necessarily imply a type for the output GSSName implementation. The \"null\" value can be used to specify that a mechanism-specific default syntax SHOULD be assumed by each mechanism that examines the byte array.",
      "ja": "nameTypeバイト配列で提供される名前の名前空間を指定するOID。 nameTypeは、入力名バイト配列の解釈を記述および修飾する役割を果たすことに注意してください。出力GSSName実装のタイプを必ずしも意味するわけではありません。 「null」値を使用して、バイト配列を検査するメカニズムごとに、メカニズム固有のデフォルト構文を想定する必要があることを指定できます。"
    },
    {
      "indent": 3,
      "text": "mech OID specifying the mechanism for which this name should be created.",
      "ja": "この名前を作成するメカニズムを指定するmech OID。"
    },
    {
      "indent": 0,
      "text": "7.1.9. createCredential",
      "section_title": true,
      "ja": "7.1.9. createCredential"
    },
    {
      "indent": 3,
      "text": "public abstract GSSCredential createCredential(int usage) throws GSSException",
      "ja": "パブリック抽象GSSCredential createCredential（int usage）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Factory method for acquiring default credentials. This will cause the GSS-API to use system-specific defaults for the set of mechanisms, name, and a DEFAULT lifetime.",
      "ja": "デフォルトの認証情報を取得するためのファクトリメソッド。これにより、GSS-APIは、メカニズムのセット、名前、およびデフォルトの存続期間にシステム固有のデフォルトを使用します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "usage The intended usage for this credential object. The value of this parameter MUST be one of:",
      "ja": "usageこの資格オブジェクトの使用目的。このパラメーターの値は、次のいずれかである必要があります。"
    },
    {
      "indent": 23,
      "text": "GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2)",
      "ja": "GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）"
    },
    {
      "indent": 0,
      "text": "7.1.10. createCredential",
      "section_title": true,
      "ja": "7.1.10. createCredential"
    },
    {
      "indent": 3,
      "text": "public abstract GSSCredential createCredential(GSSName aName, int lifetime, Oid mech, int usage) throws GSSException",
      "ja": "public abstract GSSCredential createCredential（GSSName aName、int lifetime、Oid mech、int usage）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method for acquiring a single-mechanism credential.",
      "ja": "単一メカニズムの資格情報を取得するためのファクトリメソッド。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "aName Name of the principal for whom this credential is to be acquired. Use \"null\" to specify the default principal.",
      "ja": "aNameこの資格を取得するプリンシパルの名前。 「null」を使用してデフォルトのプリンシパルを指定します。"
    },
    {
      "indent": 3,
      "text": "lifetime The number of seconds that credentials should remain valid. Use GSSCredential.INDEFINITE_LIFETIME to request that the credentials have the maximum permitted lifetime. Use GSSCredential.DEFAULT_LIFETIME to request default credential lifetime.",
      "ja": "ライフタイムクレデンシャルが有効であり続ける秒数。 GSSCredential.INDEFINITE_LIFETIMEを使用して、認証情報に許可されている最大の有効期間を要求します。 GSSCredential.DEFAULT_LIFETIMEを使用して、デフォルトの認証情報の有効期間をリクエストします。"
    },
    {
      "indent": 3,
      "text": "mech The OID of the desired mechanism. Use \"(Oid) null\" to request the default mechanism.",
      "ja": "mech目的のメカニズムのOID。 「（Oid）null」を使用して、デフォルトのメカニズムを要求します。"
    },
    {
      "indent": 3,
      "text": "usage The intended usage for this credential object. The value of this parameter MUST be one of:",
      "ja": "usageこの資格オブジェクトの使用目的。このパラメーターの値は、次のいずれかである必要があります。"
    },
    {
      "indent": 23,
      "text": "GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2)",
      "ja": "GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）"
    },
    {
      "indent": 0,
      "text": "7.1.11. createCredential",
      "section_title": true,
      "ja": "7.1.11. createCredential"
    },
    {
      "indent": 3,
      "text": "public abstract GSSCredential createCredential(GSSName aName, int lifetime, Oid[] mechs, int usage) throws GSSException",
      "ja": "public abstract GSSCredential createCredential（GSSName aName、int lifetime、Oid [] mechs、int usage）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method for acquiring credentials over a set of mechanisms. Acquires credentials for each of the mechanisms specified in the array called mechs. To determine the list of mechanisms for which the acquisition of credentials succeeded, the caller should use the GSSCredential.getMechs() method.",
      "ja": "一連のメカニズムで認証情報を取得するためのファクトリメソッド。 mechsと呼ばれる配列で指定された各メカニズムの資格情報を取得します。資格の取得に成功したメカニズムのリストを判別するには、呼び出し元はGSSCredential.getMechs()メソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "aName Name of the principal for whom this credential is to be acquired. Use \"null\" to specify the default principal.",
      "ja": "aNameこの資格を取得するプリンシパルの名前。 「null」を使用してデフォルトのプリンシパルを指定します。"
    },
    {
      "indent": 3,
      "text": "lifetime The number of seconds that credentials should remain valid. Use GSSCredential.INDEFINITE_LIFETIME to request that the credentials have the maximum permitted lifetime. Use GSSCredential.DEFAULT_LIFETIME to request default credential lifetime.",
      "ja": "ライフタイムクレデンシャルが有効であり続ける秒数。 GSSCredential.INDEFINITE_LIFETIMEを使用して、認証情報に許可されている最大の有効期間を要求します。 GSSCredential.DEFAULT_LIFETIMEを使用して、デフォルトの認証情報の有効期間をリクエストします。"
    },
    {
      "indent": 3,
      "text": "mechs The array of mechanisms over which the credential is to be acquired. Use \"(Oid[]) null\" for requesting a system-specific default set of mechanisms.",
      "ja": "mechs資格情報を取得するための一連のメカニズム。システム固有のデフォルトのメカニズムのセットを要求するには、「（Oid []）null」を使用します。"
    },
    {
      "indent": 3,
      "text": "usage The intended usage for this credential object. The value of this parameter MUST be one of:",
      "ja": "usageこの資格オブジェクトの使用目的。このパラメーターの値は、次のいずれかである必要があります。"
    },
    {
      "indent": 23,
      "text": "GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2)",
      "ja": "GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）"
    },
    {
      "indent": 0,
      "text": "7.1.12. createContext",
      "section_title": true,
      "ja": "7.1.12. createContext"
    },
    {
      "indent": 3,
      "text": "public abstract GSSContext createContext(GSSName peer, Oid mech, GSSCredential myCred, int lifetime) throws GSSException",
      "ja": "public abstract GSSContext createContext（GSSName peer、Oid mech、GSSCredential myCred、int lifetime）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method for creating a context on the initiator's side. Context flags may be modified through the mutator methods prior to calling GSSContext.initSecContext().",
      "ja": "イニシエータ側でコンテキストを作成するためのファクトリメソッド。 GSSContext.initSecContext()を呼び出す前に、ミューテーターメソッドを使用してコンテキストフラグを変更できます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "peer Name of the target peer.",
      "ja": "peerターゲットピアの名前。"
    },
    {
      "indent": 3,
      "text": "mech OID of the desired mechanism. Use \"(Oid) null\" to request the default mechanism.",
      "ja": "目的のメカニズムのmech OID。 「（Oid）null」を使用して、デフォルトのメカニズムを要求します。"
    },
    {
      "indent": 3,
      "text": "myCred Credentials of the initiator. Use \"null\" to act as a default initiator principal.",
      "ja": "イニシエーターのmyCred資格情報。デフォルトのイニシエータープリンシパルとして機能するには、「null」を使用します。"
    },
    {
      "indent": 3,
      "text": "lifetime The request lifetime, in seconds, for the context. Use GSSContext.INDEFINITE_LIFETIME and GSSContext.DEFAULT_LIFETIME to request indefinite or default context lifetime.",
      "ja": "lifetimeコンテキストのリクエストライフタイム（秒単位）。 GSSContext.INDEFINITE_LIFETIMEおよびGSSContext.DEFAULT_LIFETIMEを使用して、無期限またはデフォルトのコンテキスト存続時間を要求します。"
    },
    {
      "indent": 0,
      "text": "7.1.13. createContext",
      "section_title": true,
      "ja": "7.1.13. createContext"
    },
    {
      "indent": 3,
      "text": "public abstract GSSContext createContext(GSSCredential myCred) throws GSSException",
      "ja": "パブリック抽象GSSContext createContext（GSSCredential myCred）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Factory method for creating a context on the acceptor's side. The context's properties will be determined from the input token supplied to the accept method.",
      "ja": "アクセプター側でコンテキストを作成するためのファクトリメソッド。コンテキストのプロパティは、acceptメソッドに提供される入力トークンから決定されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "myCred Credentials for the acceptor. Use \"null\" to act as a default acceptor principal.",
      "ja": "アクセプターのmyCred資格。 「null」を使用すると、デフォルトのアクセプタープリンシパルとして機能します。"
    },
    {
      "indent": 0,
      "text": "7.1.14. createContext",
      "section_title": true,
      "ja": "7.1.14. createContext"
    },
    {
      "indent": 3,
      "text": "public abstract GSSContext createContext(byte[] interProcessToken) throws GSSException",
      "ja": "パブリック抽象GSSContext createContext（byte [] interProcessToken）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Factory method for importing a previously exported context. The context properties will be determined from the input token and can't be modified through the set methods.",
      "ja": "以前にエクスポートされたコンテキストをインポートするためのファクトリメソッド。コンテキストプロパティは入力トークンから決定され、setメソッドを使用して変更することはできません。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "interProcessToken The token previously emitted from the export method.",
      "ja": "interProcessToken以前にエクスポートメソッドから発行されたトークン。"
    },
    {
      "indent": 0,
      "text": "7.1.15. addProviderAtFront",
      "section_title": true,
      "ja": "7.1.15. addProviderAtFront"
    },
    {
      "indent": 3,
      "text": "public abstract void addProviderAtFront(Provider p, Oid mech) throws GSSException",
      "ja": "public abstract void addProviderAtFront（Provider p、Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "This method is used to indicate to the GSSManager that the application would like a particular provider to be used ahead of all others when support is desired for the given mechanism. When a value of \"null\" is used instead of an Oid object for the mechanism, the GSSManager MUST use the indicated provider ahead of all others no matter what the mechanism is. Only when the indicated provider does not support the needed mechanism should the GSSManager move on to a different provider.",
      "ja": "このメソッドは、特定のメカニズムのサポートが必要な場合に、アプリケーションが特定のプロバイダーを他のすべてのプロバイダーよりも先に使用することをGSSManagerに指示するために使用されます。メカニズムのOidオブジェクトの代わりに「null」の値が使用される場合、GSSManagerは、メカニズムが何であっても、他のすべてのプロバイダーよりも先に、示されたプロバイダーを使用する必要があります。示されたプロバイダーが必要なメカニズムをサポートしていない場合にのみ、GSSManagerは別のプロバイダーに移動する必要があります。"
    },
    {
      "indent": 3,
      "text": "Calling this method repeatedly preserves the older settings but lowers them in preference thus forming an ordered list of provider and OID pairs that grows at the top.",
      "ja": "このメソッドを呼び出すと、古い設定が繰り返し保存されますが、優先的に低く設定されるため、上位に拡大するプロバイダーとOIDのペアの順序付きリストが形成されます。"
    },
    {
      "indent": 3,
      "text": "Calling addProviderAtFront with a null Oid will remove all previous preferences that were set for this provider in the GSSManager instance. Calling addProviderAtFront with a non-null Oid will remove any previous preference that was set using this mechanism and this provider together.",
      "ja": "null OidでaddProviderAtFrontを呼び出すと、GSSManagerインスタンスでこのプロバイダーに設定されていた以前のすべての設定が削除されます。 null以外のOidでaddProviderAtFrontを呼び出すと、このメカニズムとこのプロバイダーを一緒に使用して設定された以前の設定が削除されます。"
    },
    {
      "indent": 3,
      "text": "If the GSSManager implementation does not support an SPI with a pluggable provider architecture, it SHOULD throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.",
      "ja": "GSSManager実装がプラガブルプロバイダーアーキテクチャのSPIをサポートしない場合、GSSExceptionをステータスコードGSSException.UNAVAILABLEとともにスローして、操作が利用できないことを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "p The provider instance that should be used whenever support is needed for mech.",
      "ja": "p mechのサポートが必要なときにいつでも使用する必要があるプロバイダーインスタンス。"
    },
    {
      "indent": 3,
      "text": "mech The mechanism for which the provider is being set.",
      "ja": "mechプロバイダーが設定されているメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.1.15.1. addProviderAtFront Example Code",
      "section_title": true,
      "ja": "7.1.15.1. addProviderAtFrontサンプルコード"
    },
    {
      "indent": 3,
      "text": "Suppose an application desired that provider A always be checked first when any mechanism is needed, it would call:",
      "ja": "アプリケーションが、メカニズムが必要な場合は常にプロバイダーAを最初にチェックすることを望んでいるとします。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();\n// mgr may at this point have its own pre-configured list\n// of provider preferences.  The following will prepend to\n// any such list:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "mgr.addProviderAtFront(A, null);\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Now if it also desired that the mechanism of OID m1 always be obtained from provider B before the previous set A was checked, it would call:",
      "ja": "ここで、前のセットAがチェックされる前にOID m1のメカニズムを常にプロバイダーBから取得することも必要な場合は、次を呼び出します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtFront(B, m1);\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The GSSManager would then first check with B if m1 was needed. In case B did not provide support for m1, the GSSManager would continue on to check with A. If any mechanism m2 is needed where m2 is different from m1, then the GSSManager would skip B and check with A directly.",
      "ja": "次に、GSSManagerは、m1が必要かどうかを最初にBで確認します。 Bがm1のサポートを提供しなかった場合、GSSManagerは引き続きAで確認します。m2がm1と異なるメカニズムm2が必要な場合、GSSManagerはBをスキップして直接Aで確認します。"
    },
    {
      "indent": 3,
      "text": "Suppose, at a later time, the following call is made to the same GSSManager instance:",
      "ja": "後で、同じGSSManagerインスタンスに対して次の呼び出しが行われたとします。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtFront(B, null)\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "then the previous setting with the pair (B, m1) is subsumed by this and SHOULD be removed. Effectively, the list of preferences now becomes {(B, null), (A, null), ... //followed by the pre-configured list}.",
      "ja": "次に、ペア（B、m1）の以前の設定がこれに包含され、削除する必要があります（SHOULD）。事実上、設定のリストは{（B、null）、（A、null）、... //その後に事前設定されたリストが続く}になります。"
    },
    {
      "indent": 3,
      "text": "Please note, however, that the following call:",
      "ja": "ただし、次の呼び出しは注意してください。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtFront(A, m3)\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "does not subsume the previous setting of (A, null), and the list will effectively become {(A, m3), (B, null), (A, null), ...}",
      "ja": "（A、null）の以前の設定は含まれず、リストは実質的に{（A、m3）、（B、null）、（A、null）、...}になります"
    },
    {
      "indent": 0,
      "text": "7.1.16. addProviderAtEnd",
      "section_title": true,
      "ja": "7.1.16. addProviderAtEnd"
    },
    {
      "indent": 3,
      "text": "public abstract void addProviderAtEnd(Provider p, Oid mech) throws GSSException",
      "ja": "public abstract void addProviderAtEnd（Provider p、Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "This method is used to indicate to the GSSManager that the application would like a particular provider to be used if no other provider can be found that supports the given mechanism. When a value of \"null\" is used instead of an Oid object for the mechanism, the GSSManager MUST use the indicated provider for any mechanism.",
      "ja": "このメソッドは、特定のメカニズムをサポートする他のプロバイダーが見つからない場合に、アプリケーションが特定のプロバイダーを使用することをGSSManagerに指示するために使用されます。メカニズムのOidオブジェクトの代わりに「null」の値を使用する場合、GSSManagerは、指定されたプロバイダーをメカニズムに使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Calling this method repeatedly preserves the older settings but raises them above newer ones in preference, thus forming an ordered list of providers and OID pairs that grows at the bottom. Thus, the older provider settings will be utilized first before this one is.",
      "ja": "このメソッドを呼び出すと、古い設定が繰り返し保存されますが、優先的に新しい設定よりも上に引き上げられるため、プロバイダーとOIDペアの順序付きリストが形成され、下部に拡大します。したがって、これよりも前に古いプロバイダー設定が最初に使用されます。"
    },
    {
      "indent": 3,
      "text": "If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager SHOULD ignore this request.",
      "ja": "ここで設定されている設定と競合する既存の設定がある場合、GSSManagerはこの要求を無視する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If the GSSManager implementation does not support an SPI with a pluggable provider architecture, it SHOULD throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.",
      "ja": "GSSManager実装がプラガブルプロバイダーアーキテクチャのSPIをサポートしない場合、GSSExceptionをステータスコードGSSException.UNAVAILABLEとともにスローして、操作が利用できないことを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "p The provider instance that should be used whenever support is needed for mech.",
      "ja": "p mechのサポートが必要なときにいつでも使用する必要があるプロバイダーインスタンス。"
    },
    {
      "indent": 3,
      "text": "mech The mechanism for which the provider is being set.",
      "ja": "mechプロバイダーが設定されているメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.1.16.1. addProviderAtEnd Example Code",
      "section_title": true,
      "ja": "7.1.16.1. addProviderAtEndサンプルコード"
    },
    {
      "indent": 3,
      "text": "Suppose an application desired that when a mechanism of OID m1 is needed, the system default providers always be checked first, and only when they do not support m1 should a provider A be checked. It would then make the call:",
      "ja": "OID m1のメカニズムが必要な場合は常にシステムのデフォルトプロバイダーを最初にチェックし、m1をサポートしていない場合にのみプロバイダーAをチェックする必要があるアプリケーションを想定します。次に、呼び出しを行います。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " mgr.addProviderAtEnd(A, m1); <CODE ENDS> Now, if it also desired that provider B be checked for all mechanisms after all configured providers have been checked, it would then call:",
      "ja": "mgr.addProviderAtEnd（A、m1）; <CODE ENDS>これで、構成済みのすべてのプロバイダーがチェックされた後に、プロバイダーBもすべてのメカニズムについてチェックされることが望まれる場合は、次を呼び出します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtEnd(B, null);\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Effectively, the list of preferences now becomes {..., (A, m1), (B, null)}.",
      "ja": "事実上、設定のリストは{...、（A、m1）、（B、null）}になります。"
    },
    {
      "indent": 3,
      "text": "Suppose, at a later time, the following call is made to the same GSSManager instance:",
      "ja": "後で、同じGSSManagerインスタンスに対して次の呼び出しが行われたとします。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtEnd(B, m2)\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "then the previous setting with the pair (B, null) subsumes this; therefore, this request SHOULD be ignored. The same would happen if a request is made for the already existing pairs of (A, m1) or (B, null).",
      "ja": "次に、ペア（B、null）を含む以前の設定はこれを包含します。したがって、このリクエストは無視してください。 （A、m1）または（B、null）の既存のペアに対してリクエストが行われた場合も同様です。"
    },
    {
      "indent": 3,
      "text": "Please note, however, that the following call:",
      "ja": "ただし、次の呼び出しは注意してください。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nmgr.addProviderAtEnd(A, null)\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is not subsumed by the previous setting of (A, m1), and the list will effectively become {..., (A, m1), (B, null), (A, null)}.",
      "ja": "（A、m1）の以前の設定によって包含されず、リストは実質的に{...、（A、m1）、（B、null）、（A、null）}になります。"
    },
    {
      "indent": 0,
      "text": "7.1.17. Example Code",
      "section_title": true,
      "ja": "7.1.17. コード例"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// What mechs are available to us?",
      "ja": "//どのようなメカニズムを利用できますか？"
    },
    {
      "indent": 3,
      "text": "Oid[] supportedMechs = mgr.getMechs();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Set a preference for the provider to be used when support\n// is needed for the mechanisms:\n//  \"1.2.840.113554.1.2.2\" and \"1.3.6.1.5.5.1.1\".",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oid krb = new Oid(\"1.2.840.113554.1.2.2\");\nOid spkm1 = new Oid(\"1.3.6.1.5.5.1.1\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Provider p = (Provider) (new com.foo.security.Provider());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "mgr.addProviderAtFront(p, krb);\nmgr.addProviderAtFront(p, spkm1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// What name types does this spkm implementation support?\nOid[] nameTypes = mgr.getNamesForMech(spkm1);\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. public interface GSSName",
      "section_title": true,
      "ja": "7.2. パブリックインターフェースGSSName"
    },
    {
      "indent": 3,
      "text": "This interface encapsulates a single GSS-API principal entity. Different name formats and their definitions are identified with Universal OIDs. The format of the names can be derived based on the unique OID of its namespace type.",
      "ja": "このインタフェースは、単一のGSS-API主体エンティティをカプセル化します。さまざまな名前の形式とその定義は、ユニバーサルOIDで識別されます。名前の形式は、その名前空間タイプの一意のOIDに基づいて導出できます。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Static Constants",
      "section_title": true,
      "ja": "7.2.1. 静的定数"
    },
    {
      "indent": 3,
      "text": "public static final Oid NT_HOSTBASED_SERVICE",
      "ja": "public static final Oid NT_HOSTBASED_SERVICE"
    },
    {
      "indent": 3,
      "text": "OID indicating a host-based service name form. It is used to represent services associated with host computers. This name form is constructed using two elements, \"service\" and \"hostname\", as follows:",
      "ja": "ホストベースのサービス名形式を示すOID。ホストコンピュータに関連付けられたサービスを表すために使用されます。この名前形式は、次のように、「service」と「hostname」の2つの要素を使用して構築されます。"
    },
    {
      "indent": 6,
      "text": "service@hostname",
      "ja": "service @ hostname"
    },
    {
      "indent": 3,
      "text": "Values for the \"service\" element are registered with the IANA.  It\nrepresents the following value: { iso(1) member-body(2) United\nStates(840) mit(113554) infosys(1) gssapi(2) generic(1)\nservice_name(4) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "public static final Oid NT_USER_NAME",
      "ja": "public static final Oid NT_USER_NAME"
    },
    {
      "indent": 3,
      "text": "Name type to indicate a named user on a local system.  It represents\nthe following value: { iso(1) member-body(2) United States(840)\nmit(113554) infosys(1) gssapi(2) generic(1) user_name(1) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "public static final Oid NT_MACHINE_UID_NAME",
      "ja": "public static final Oid NT_MACHINE_UID_NAME"
    },
    {
      "indent": 3,
      "text": "Name type to indicate a numeric user identifier corresponding to a\nuser on a local system (e.g., Uid).  It represents the following\nvalue: { iso(1) member-body(2) United States(840) mit(113554)\ninfosys(1) gssapi(2) generic(1) machine_uid_name(2) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "public static final Oid NT_STRING_UID_NAME",
      "ja": "public static final Oid NT_STRING_UID_NAME"
    },
    {
      "indent": 0,
      "text": "   Name type to indicate a string of digits representing the numeric\n   user identifier of a user on a local system.  It represents the\n   following value: { iso(1) member-body(2) United States(840)\n   mit(113554) infosys(1) gssapi(2) generic(1) string_uid_name(3) }\n   public static final Oid NT_ANONYMOUS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Name type for representing an anonymous entity.  It represents the\nfollowing value: { iso(1), org(3), dod(6), internet(1), security(5),\nnametypes(6), gss-anonymous-name(3) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "public static final Oid NT_EXPORT_NAME",
      "ja": "public static final Oid NT_EXPORT_NAME"
    },
    {
      "indent": 3,
      "text": "Name type used to indicate an exported name produced by the export\nmethod.  It represents the following value: { iso(1), org(3), dod(6),\ninternet(1), security(5), nametypes(6), gss-api-exported-name(4) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.2. equals",
      "section_title": true,
      "ja": "7.2.2. 等しい"
    },
    {
      "indent": 3,
      "text": "public boolean equals(GSSName another) throws GSSException",
      "ja": "public boolean equals（GSSName another）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Compares two GSSName objects to determine whether they refer to the same entity. This method MAY throw a GSSException when the names cannot be compared. If either of the names represents an anonymous entity, the method will return \"false\".",
      "ja": "2つのGSSNameオブジェクトを比較して、同じエンティティを参照しているかどうかを判断します。名前を比較できない場合、このメソッドはGSSExceptionをスローする場合があります。名前のいずれかが匿名エンティティを表す場合、メソッドは「false」を返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "another GSSName object with which to compare.",
      "ja": "比較する別のGSSNameオブジェクト"
    },
    {
      "indent": 0,
      "text": "7.2.3. equals",
      "section_title": true,
      "ja": "7.2.3. 等しい"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object another)",
      "ja": "public boolean equals（Object another）"
    },
    {
      "indent": 3,
      "text": "A variation of the equals method, described in Section 7.2.2, that is provided to override the Object.equals() method that the implementing class will inherit. The behavior is exactly the same as that in Section 7.2.2 except that no GSSException is thrown; instead, \"false\" will be returned in the situation where an error occurs. (Note that the Java language specification requires that two objects that are equal according to the equals(Object) method MUST return the same integer result when the hashCode() method is called on them.)",
      "ja": "実装クラスが継承するObject.equals()メソッドをオーバーライドするために提供されている、セクション7.2.2で説明されているequalsメソッドのバリエーション。この動作は、GSSExceptionがスローされないことを除いて、セクション7.2.2とまったく同じです。代わりに、エラーが発生した場合は「false」が返されます。 （Java言語仕様では、hashCode()メソッドが呼び出されたときに、equals（Object）メソッドに従って等しい2つのオブジェクトが同じ整数の結果を返す必要があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "another GSSName object with which to compare.",
      "ja": "比較する別のGSSNameオブジェクト"
    },
    {
      "indent": 0,
      "text": "7.2.4. canonicalize",
      "section_title": true,
      "ja": "7.2.4. 正規化する"
    },
    {
      "indent": 3,
      "text": "public GSSName canonicalize(Oid mech) throws GSSException",
      "ja": "public GSSName canonicalize（Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Creates an MN from an arbitrary internal name. This is equivalent to using the factory methods described in Sections 7.1.7 or 7.1.8 that take the mechanism name as one of their parameters.",
      "ja": "任意の内部名からMNを作成します。これは、セクション7.1.7または7.1.8で説明されている、メカニズム名をパラメーターの1つとして取るファクトリメソッドを使用することと同等です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mech The OID for the mechanism for which the canonical form of the name is requested.",
      "ja": "mech名前の正規形が要求されるメカニズムのOID。"
    },
    {
      "indent": 0,
      "text": "7.2.5. export",
      "section_title": true,
      "ja": "7.2.5. 書き出す"
    },
    {
      "indent": 3,
      "text": "public byte[] export() throws GSSException",
      "ja": "public byte [] export()がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns a canonical contiguous byte representation of an MN, suitable for direct, byte-by-byte comparison by authorization functions. If the name is not an MN, implementations MAY throw a GSSException with the NAME_NOT_MN status code. If an implementation chooses not to throw an exception, it SHOULD use some system-specific default mechanism to canonicalize the name and then export it. The format of the header of the output buffer is specified in RFC 2743 [RFC2743].",
      "ja": "認可関数によるバイトごとの直接比較に適した、MNの正規の連続したバイト表現を返します。名前がMNではない場合、実装はNAME_NOT_MNステータスコードとともにGSSExceptionをスローする場合があります。実装が例外をスローしないことを選択した場合、システム固有のデフォルトメカニズムを使用して名前を正規化し、エクスポートする必要があります（SHOULD）。出力バッファーのヘッダーの形式は、RFC 2743 [RFC2743]で指定されています。"
    },
    {
      "indent": 0,
      "text": "7.2.6. toString",
      "section_title": true,
      "ja": "7.2.6. toString"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public String toString()"
    },
    {
      "indent": 3,
      "text": "Returns a textual representation of the GSSName object. To retrieve the printed name format, which determines the syntax of the returned string, the getStringNameType method can be used.",
      "ja": "GSSNameオブジェクトのテキスト表現を返します。返される文字列の構文を決定する印刷された名前の形式を取得するには、getStringNameTypeメソッドを使用できます。"
    },
    {
      "indent": 0,
      "text": "7.2.7. getStringNameType",
      "section_title": true,
      "ja": "7.2.7. getStringNameType"
    },
    {
      "indent": 3,
      "text": "public Oid getStringNameType() throws GSSException",
      "ja": "public Oid getStringNameType()がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns the OID representing the type of name returned through the toString method. Using this OID, the syntax of the printable name can be determined.",
      "ja": "toStringメソッドを通じて返された名前のタイプを表すOIDを返します。このOIDを使用して、印刷可能な名前の構文を決定できます。"
    },
    {
      "indent": 0,
      "text": "7.2.8. isAnonymous",
      "section_title": true,
      "ja": "7.2.8. isAnonymous"
    },
    {
      "indent": 3,
      "text": "public boolean isAnonymous()",
      "ja": "パブリックブールisAnonymous()"
    },
    {
      "indent": 3,
      "text": "Tests if this name object represents an anonymous entity. Returns \"true\" if this is an anonymous name.",
      "ja": "この名前オブジェクトが匿名エンティティを表すかどうかをテストします。これが匿名名の場合、「true」を返します。"
    },
    {
      "indent": 0,
      "text": "7.2.9. isMN",
      "section_title": true,
      "ja": "7.2.9. 太った"
    },
    {
      "indent": 3,
      "text": "public boolean isMN()",
      "ja": "パブリックブールisMN()"
    },
    {
      "indent": 3,
      "text": "Tests if this name object contains only one mechanism element and is thus a mechanism name as defined by RFC 2743 [RFC2743].",
      "ja": "この名前オブジェクトにメカニズム要素が1つしか含まれていないかどうか、つまりRFC 2743 [RFC2743]で定義されているメカニズム名であるかどうかをテストします。"
    },
    {
      "indent": 0,
      "text": "7.2.10. Example Code",
      "section_title": true,
      "ja": "7.2.10. コード例"
    },
    {
      "indent": 3,
      "text": "Included below are code examples utilizing the GSSName interface. The code below creates a GSSName, converts it to an MN, performs a comparison, obtains a printable representation of the name, exports it, and then re-imports to obtain a new GSSName.",
      "ja": "GSSNameインターフェースを利用したコード例を以下に示します。以下のコードは、GSSNameを作成し、それをMNに変換し、比較を実行し、名前の印刷可能な表現を取得し、それをエクスポートしてから、再インポートして新しいGSSNameを取得します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// create a host-based service name\nGSSName name = mgr.createName(\"service@host\",\n                GSSName.NT_HOSTBASED_SERVICE);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oid krb5 = new Oid(\"1.2.840.113554.1.2.2\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "GSSName mechName = name.canonicalize(krb5);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// the above two steps are equivalent to the following\nGSSName mechName = mgr.createName(\"service@host\",\n                GSSName.NT_HOSTBASED_SERVICE, krb5);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// perform name comparison\nif (name.equals(mechName))\n        print(\"Names are equals.\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// obtain textual representation of name and its printable\n// name type\nprint(mechName.toString() +\n      mechName.getStringNameType().toString());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// export the name\nbyte[] exportName = mechName.export();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// create a new name object from the exported buffer\nGSSName newName = mgr.createName(exportName,\n                  GSSName.NT_EXPORT_NAME);\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3. public interface GSSCredential implements Cloneable",
      "section_title": true,
      "ja": "7.3. 公開インターフェースGSSCredentialはCloneableを実装します"
    },
    {
      "indent": 3,
      "text": "This interface encapsulates the GSS-API credentials for an entity. A credential contains all the necessary cryptographic information to enable the creation of a context on behalf of the entity that it represents. It MAY contain multiple, distinct, mechanism-specific credential elements, each containing information for a specific security mechanism, but all referring to the same entity.",
      "ja": "このインターフェースは、エンティティーのGSS-API資格をカプセル化します。信任状には、それが表すエンティティーに代わってコンテキストを作成できるようにするために必要なすべての暗号化情報が含まれています。複数の異なるメカニズム固有の資格情報要素を含めることができます。それぞれに特定のセキュリティメカニズムの情報が含まれますが、すべて同じエンティティを参照しています。"
    },
    {
      "indent": 3,
      "text": "A credential MAY be used to perform context initiation, acceptance, or both.",
      "ja": "信任状は、コンテキストの開始、受け入れ、またはその両方を実行するために使用できます。"
    },
    {
      "indent": 3,
      "text": "GSS-API implementations MUST impose a local access-control policy on callers to prevent unauthorized callers from acquiring credentials to which they are not entitled. GSS-API credential creation is not intended to provide a \"login to the network\" function, as such a function would involve the creation of new credentials rather than merely acquiring a handle to existing credentials. Such functions, if required, SHOULD be defined in implementation-specific extensions to the API.",
      "ja": "GSS-API実装は、権限のない呼び出し元が資格のない資格情報を取得するのを防ぐために、呼び出し元にローカルアクセス制御ポリシーを課さなければなりません（MUST）。 GSS-API資格情報の作成は、「ネットワークへのログイン」機能を提供することを目的としていません。そのような機能には、既存の資格情報へのハンドルを取得するだけでなく、新しい資格情報の作成が含まれるためです。このような関数は、必要に応じて、APIの実装固有の拡張で定義する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If credential acquisition is time-consuming for a mechanism, the mechanism MAY choose to delay the actual acquisition until the credential is required (e.g., by GSSContext). Such mechanism-specific implementation decisions SHOULD be invisible to the calling application; thus, the query methods immediately following the creation of a credential object MUST return valid credential data and may therefore incur the overhead of a deferred credential acquisition.",
      "ja": "メカニズムで資格情報の取得に時間がかかる場合、メカニズムは、資格情報が必要になるまで（GSSContextなどによって）実際の取得を遅らせることを選択できます（MAY）。このようなメカニズム固有の実装決定は、呼び出し側アプリケーションから見えないようにする必要があります。したがって、資格オブジェクトの作成直後のクエリメソッドは、有効な資格データを返さなければならず（MUST）、したがって、延期された資格取得のオーバーヘッドが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Applications will create a credential object passing the desired parameters. The application can then use the query methods to obtain specific information about the instantiated credential object (equivalent to the gss_inquire routines). When the credential is no longer needed, the application SHOULD call the dispose (equivalent to gss_release_cred) method to release any resources held by the credential object and to destroy any cryptographically sensitive information.",
      "ja": "アプリケーションは、必要なパラメーターを渡して資格情報オブジェクトを作成します。次に、アプリケーションはクエリメソッドを使用して、インスタンス化された資格情報オブジェクト（gss_inquireルーチンに相当）に関する特定の情報を取得できます。資格情報が不要になった場合、アプリケーションはdispose（gss_release_credと同等）メソッドを呼び出して、資格情報オブジェクトが保持しているリソースを解放し、暗号化された機密情報を破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Classes implementing this interface also implement the Cloneable interface. This indicates that the class will support the clone() method that will allow the creation of duplicate credentials. This is useful when called just before the add() call to retain a copy of the original credential.",
      "ja": "このインターフェースを実装するクラスは、Cloneableインターフェースも実装します。これは、クラスがclone()メソッドをサポートすることを示します。これにより、重複する資格情報を作成できます。これは、元の資格情報のコピーを保持するためにadd()呼び出しの直前に呼び出される場合に役立ちます。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Static Constants",
      "section_title": true,
      "ja": "7.3.1. 静的定数"
    },
    {
      "indent": 3,
      "text": "public static final int INITIATE_AND_ACCEPT",
      "ja": "public static final int INITIATE_AND_ACCEPT"
    },
    {
      "indent": 3,
      "text": "Credential usage flag requesting that it be able to be used for both context initiation and acceptance. The value of this constant is 0.",
      "ja": "コンテキストの開始と受け入れの両方に使用できることを要求する資格情報使用フラグ。この定数の値は0です。"
    },
    {
      "indent": 3,
      "text": "public static final int INITIATE_ONLY",
      "ja": "public static final int INITIATE_ONLY"
    },
    {
      "indent": 3,
      "text": "Credential usage flag requesting that it be able to be used for context initiation only. The value of this constant is 1.",
      "ja": "コンテキストの開始にのみ使用できることを要求する資格情報使用フラグ。この定数の値は1です。"
    },
    {
      "indent": 3,
      "text": "public static final int ACCEPT_ONLY",
      "ja": "public static final int ACCEPT_ONLY"
    },
    {
      "indent": 3,
      "text": "Credential usage flag requesting that it be able to be used for context acceptance only. The value of this constant is 2.",
      "ja": "資格情報の使用フラグ。コンテキストの受け入れにのみ使用できることを要求します。この定数の値は2です。"
    },
    {
      "indent": 3,
      "text": "public static final int DEFAULT_LIFETIME",
      "ja": "public static final int DEFAULT_LIFETIME"
    },
    {
      "indent": 3,
      "text": "A lifetime constant representing the default credential lifetime. The value of this constant is 0.",
      "ja": "デフォルトの認証情報の有効期間を表す有効期間定数。この定数の値は0です。"
    },
    {
      "indent": 3,
      "text": "public static final int INDEFINITE_LIFETIME",
      "ja": "public static final int INDEFINITE_LIFETIME"
    },
    {
      "indent": 3,
      "text": "A lifetime constant representing indefinite credential lifetime. The value of this constant is the maximum integer value in Java -- Integer.MAX_VALUE.",
      "ja": "資格情報の寿命が無期限であることを表す寿命定数。この定数の値は、Javaの最大整数値であるInteger.MAX_VALUEです。"
    },
    {
      "indent": 0,
      "text": "7.3.2. dispose",
      "section_title": true,
      "ja": "7.3.2. 廃棄"
    },
    {
      "indent": 3,
      "text": "public void dispose() throws GSSException",
      "ja": "public void dispose()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Releases any sensitive information that the GSSCredential object may be containing. Applications SHOULD call this method as soon as the credential is no longer needed to minimize the time any sensitive information is maintained.",
      "ja": "GSSCredentialオブジェクトに含まれている可能性のある機密情報をすべて解放します。機密情報が保持される時間を最小限に抑えるために資格情報が不要になったらすぐに、アプリケーションはこのメソッドを呼び出す必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.3. getName",
      "section_title": true,
      "ja": "7.3.3. getName"
    },
    {
      "indent": 3,
      "text": "public GSSName getName() throws GSSException",
      "ja": "public GSSName getName()はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Retrieves the name of the entity that the credential asserts.",
      "ja": "資格情報が表明するエンティティーの名前を取得します。"
    },
    {
      "indent": 0,
      "text": "7.3.4. getName",
      "section_title": true,
      "ja": "7.3.4. getName"
    },
    {
      "indent": 3,
      "text": "public GSSName getName(Oid mechOID) throws GSSException",
      "ja": "public GSSName getName（Oid mechOID）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Retrieves a mechanism name of the entity that the credential asserts. Equivalent to calling canonicalize() on the name returned by Section 7.3.3.",
      "ja": "資格が表明するエンティティーのメカニズム名を取得します。セクション7.3.3で返された名前に対してcanonicalize()を呼び出すのと同じです。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mechOID The mechanism for which information should be returned.",
      "ja": "mechOID情報が返されるメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.3.5. getRemainingLifetime",
      "section_title": true,
      "ja": "7.3.5. getRemainingLifetime"
    },
    {
      "indent": 3,
      "text": "public int getRemainingLifetime() throws GSSException",
      "ja": "public int getRemainingLifetime()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the remaining lifetime in seconds for a credential. The remaining lifetime is the minimum lifetime for any of the underlying credential mechanisms. A return value of GSSCredential.INDEFINITE_LIFETIME indicates that the credential does not expire. A return value of 0 indicates that the credential is already expired.",
      "ja": "クレデンシャルの残りのライフタイムを秒単位で返します。残りのライフタイムは、基盤となる資格メカニズムの最小ライフタイムです。 GSSCredential.INDEFINITE_LIFETIMEの戻り値は、資格情報の有効期限が切れていないことを示します。戻り値0は、資格情報が既に期限切れであることを示します。"
    },
    {
      "indent": 0,
      "text": "7.3.6. getRemainingInitLifetime",
      "section_title": true,
      "ja": "7.3.6. getRemainingInitLifetime"
    },
    {
      "indent": 3,
      "text": "public int getRemainingInitLifetime(Oid mech) throws GSSException",
      "ja": "public int getRemainingInitLifetime（Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the remaining lifetime in seconds for the credential to remain capable of initiating security contexts under the specified mechanism. A return value of GSSCredential.INDEFINITE_LIFETIME indicates that the credential does not expire for context initiation. A return value of 0 indicates that the credential is already expired.",
      "ja": "資格が指定されたメカニズムでセキュリティコンテキストを開始できる状態を維持する残りのライフタイムを秒単位で返します。 GSSCredential.INDEFINITE_LIFETIMEの戻り値は、資格情報がコンテキストの開始に対して期限切れにならないことを示します。戻り値0は、資格情報が既に期限切れであることを示します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mechOID The mechanism for which information should be returned.",
      "ja": "mechOID情報が返されるメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.3.7. getRemainingAcceptLifetime",
      "section_title": true,
      "ja": "7.3.7. getRemainingAcceptLifetime"
    },
    {
      "indent": 3,
      "text": "public int getRemainingAcceptLifetime(Oid mech) throws GSSException",
      "ja": "public int getRemainingAcceptLifetime（Oid mech）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the remaining lifetime in seconds for the credential to remain capable of accepting security contexts under the specified mechanism. A return value of GSSCredential.INDEFINITE_LIFETIME indicates that the credential does not expire for context acceptance. A return value of 0 indicates that the credential is already expired.",
      "ja": "資格が指定されたメカニズムでセキュリティコンテキストを受け入れることができる状態を維持するための残りのライフタイムを秒単位で返します。 GSSCredential.INDEFINITE_LIFETIMEの戻り値は、資格情報がコンテキストの受け入れのために期限切れにならないことを示します。戻り値0は、資格情報が既に期限切れであることを示します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mechOID The mechanism for which information should be returned.",
      "ja": "mechOID情報が返されるメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.3.8. getUsage",
      "section_title": true,
      "ja": "7.3.8. getUsage"
    },
    {
      "indent": 3,
      "text": "public int getUsage() throws GSSException",
      "ja": "public int getUsage()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the credential usage flag as a union over all mechanisms. The return value will be one of GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2).",
      "ja": "資格使用フラグをすべてのメカニズムの和集合として返します。戻り値は、GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "Specifically, GSSCredential.INITIATE_AND_ACCEPT(0) SHOULD be returned as long as there exists one credential element allowing context initiation and one credential element allowing context acceptance. These two credential elements are not necessarily the same one, nor do they need to use the same mechanism(s).",
      "ja": "具体的には、コンテキストの開始を許可する1つの資格要素とコンテキストの受け入れを許可する1つの資格要素が存在する限り、GSSCredential.INITIATE_AND_ACCEPT（0）を返す必要があります。これらの2つの資格情報要素は必ずしも同じものではなく、同じメカニズムを使用する必要もありません。"
    },
    {
      "indent": 0,
      "text": "7.3.9. getUsage",
      "section_title": true,
      "ja": "7.3.9. getUsage"
    },
    {
      "indent": 3,
      "text": "public int getUsage(Oid mechOID) throws GSSException",
      "ja": "public int getUsage（Oid mechOID）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the credential usage flag for the specified mechanism only. The return value will be one of GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2).",
      "ja": "指定されたメカニズムのみの資格情報使用フラグを返します。戻り値は、GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "mechOID The mechanism for which information should be returned.",
      "ja": "mechOID情報が返されるメカニズム。"
    },
    {
      "indent": 0,
      "text": "7.3.10. getMechs",
      "section_title": true,
      "ja": "7.3.10. getMechs"
    },
    {
      "indent": 3,
      "text": "public Oid[] getMechs() throws GSSException",
      "ja": "public Oid [] getMechs()がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns an array of mechanisms supported by this credential.",
      "ja": "この資格情報でサポートされているメカニズムの配列を返します。"
    },
    {
      "indent": 0,
      "text": "7.3.11. add",
      "section_title": true,
      "ja": "7.3.11. 追加"
    },
    {
      "indent": 3,
      "text": "public void add(GSSName aName, int initLifetime, int acceptLifetime, Oid mech, int usage) throws GSSException",
      "ja": "public void add（GSSName aName、int initLifetime、int acceptLifetime、Oid mech、int usage）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Adds a mechanism-specific credential element to an existing credential. This method allows the construction of credentials one mechanism at a time.",
      "ja": "メカニズム固有の資格情報要素を既存の資格情報に追加します。この方法では、一度に1つのメカニズムで資格情報を作成できます。"
    },
    {
      "indent": 3,
      "text": "This routine is envisioned to be used mainly by context acceptors during the creation of acceptance credentials, which are to be used with a variety of clients using different security mechanisms.",
      "ja": "このルーチンは、主に、さまざまなセキュリティメカニズムを使用するさまざまなクライアントで使用される、受け入れ資格情報の作成時にコンテキスト受け入れ側が使用することを想定しています。"
    },
    {
      "indent": 3,
      "text": "This routine adds the new credential element \"in-place\". To add the element in a new credential, first call clone() to obtain a copy of this credential, then call its add() method.",
      "ja": "このルーチンは、新しい資格要素を「インプレース」で追加します。要素を新しい資格情報に追加するには、最初にclone()を呼び出してこの資格情報のコピーを取得してから、そのadd()メソッドを呼び出します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "aName Name of the principal for whom this credential is to be acquired. Use \"null\" to specify the default principal.",
      "ja": "aNameこの資格を取得するプリンシパルの名前。 「null」を使用してデフォルトのプリンシパルを指定します。"
    },
    {
      "indent": 3,
      "text": "initLifetime The number of seconds that credentials should remain valid for initiating security contexts. Use GSSCredential.INDEFINITE_LIFETIME to request that the credentials have the maximum permitted lifetime. Use GSSCredential.DEFAULT_LIFETIME to request default credential lifetime.",
      "ja": "initLifetime資格情報がセキュリティコンテキストを開始するために有効であり続ける秒数。 GSSCredential.INDEFINITE_LIFETIMEを使用して、認証情報に許可されている最大の有効期間を要求します。 GSSCredential.DEFAULT_LIFETIMEを使用して、デフォルトの認証情報の有効期間をリクエストします。"
    },
    {
      "indent": 3,
      "text": "acceptLifetime The number of seconds that credentials should remain valid for accepting security contexts.",
      "ja": "acceptLifetime資格情報がセキュリティコンテキストを受け入れるために有効な状態を維持する秒数。"
    },
    {
      "indent": 23,
      "text": "Use GSSCredential.INDEFINITE_LIFETIME to request that the credentials have the maximum permitted lifetime. Use GSSCredential.DEFAULT_LIFETIME to request default credential lifetime.",
      "ja": "GSSCredential.INDEFINITE_LIFETIMEを使用して、認証情報に許可されている最大の有効期間を要求します。 GSSCredential.DEFAULT_LIFETIMEを使用して、デフォルトの認証情報の有効期間をリクエストします。"
    },
    {
      "indent": 3,
      "text": "mech The mechanisms over which the credential is to be acquired.",
      "ja": "mech信任状が取得されるメカニズム。"
    },
    {
      "indent": 3,
      "text": "usage The intended usage for this credential object. The value of this parameter MUST be one of:",
      "ja": "usageこの資格オブジェクトの使用目的。このパラメーターの値は、次のいずれかである必要があります。"
    },
    {
      "indent": 23,
      "text": "GSSCredential.INITIATE_AND_ACCEPT(0), GSSCredential.INITIATE_ONLY(1), or GSSCredential.ACCEPT_ONLY(2)",
      "ja": "GSSCredential.INITIATE_AND_ACCEPT（0）、GSSCredential.INITIATE_ONLY（1）、またはGSSCredential.ACCEPT_ONLY（2）"
    },
    {
      "indent": 0,
      "text": "7.3.12. equals",
      "section_title": true,
      "ja": "7.3.12. 等しい"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object another)",
      "ja": "public boolean equals（Object another）"
    },
    {
      "indent": 0,
      "text": " Tests if this GSSCredential refers to the same entity as the supplied object. The two credentials MUST be acquired over the same mechanisms and MUST refer to the same principal. Returns \"true\" if the two GSSCredentials refer to the same entity, or \"false\" otherwise. (Note that the Java language specification [JLS] requires that two objects that are equal according to the equals(Object) method MUST return the same integer result when the hashCode() method is called on them.)",
      "ja": "このGSSCredentialが、指定されたオブジェクトと同じエンティティを参照しているかどうかをテストします。 2つの資格情報は、同じメカニズムで取得する必要があり、同じプリンシパルを参照する必要があります。 2つのGSSCredentialが同じエンティティを参照している場合は「true」を返し、そうでない場合は「false」を返します。 （Java言語仕様[JLS]では、equals（Object）メソッドに従って等しい2つのオブジェクトが、hashCode()メソッドが呼び出されたときに同じ整数の結果を返さなければならないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "another Another GSSCredential object for comparison.",
      "ja": "比較のための別のGSSCredentialオブジェクト。"
    },
    {
      "indent": 0,
      "text": "7.3.13. Example Code",
      "section_title": true,
      "ja": "7.3.13. コード例"
    },
    {
      "indent": 3,
      "text": "This example code demonstrates the creation of a GSSCredential implementation for a specific entity, querying of its fields, and its release when it is no longer needed.",
      "ja": "このサンプルコードは、特定のエンティティのGSSCredential実装の作成、そのフィールドのクエリ、および不要になったリリースを示しています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// start by creating a name object for the entity\nGSSName name = mgr.createName(\"userName\", GSSName.NT_USER_NAME);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// now acquire credentials for the entity GSSCredential cred = mgr.createCredential(name, GSSCredential.INDEFINITE_LIFETIME, (Oid[])null, GSSCredential.ACCEPT_ONLY);",
      "ja": "//エンティティの認証情報を取得しますGSSCredential cred = mgr.createCredential（name、GSSCredential.INDEFINITE_LIFETIME、（Oid []）null、GSSCredential.ACCEPT_ONLY）;"
    },
    {
      "indent": 3,
      "text": "// display credential information - name, remaining lifetime,\n// and the mechanisms it has been acquired over\nprint(cred.getName().toString());\nprint(cred.getRemainingLifetime());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oid[] mechs = cred.getMechs();\nif (mechs != null) {\n   for (int i = 0; i < mechs.length; i++)\n       print(mechs[i].toString());\n}\n// release system resources held by the credential\ncred.dispose();\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4. public interface GSSContext",
      "section_title": true,
      "ja": "7.4. パブリックインターフェースGSSContext"
    },
    {
      "indent": 0,
      "text": " This interface encapsulates the GSS-API security context and provides the security services (wrap, unwrap, getMIC, and verifyMIC) that are available over the context. Security contexts are established between peers using locally acquired credentials. Multiple contexts may exist simultaneously between a pair of peers, using the same or different set of credentials. GSS-API functions in a manner independent of the underlying transport protocol and depends on its calling application to transport its tokens between peers.",
      "ja": " This interface encapsulates the GSS-API security context and provides the security services (wrap, unwrap, getMIC, and verifyMIC) that are available over the context. Security contexts are established between peers using locally acquired credentials. Multiple contexts may exist simultaneously between a pair of peers, using the same or different set of credentials. GSS-API functions in a manner independent of the underlying transport protocol and depends on its calling application to transport its tokens between peers."
    },
    {
      "indent": 3,
      "text": "Before the context establishment phase is initiated, the context initiator may request specific characteristics desired of the established context. These can be set using the set methods. After the context is established, the caller can check the actual characteristic and services offered by the context using the query methods.",
      "ja": "Before the context establishment phase is initiated, the context initiator may request specific characteristics desired of the established context. These can be set using the set methods. After the context is established, the caller can check the actual characteristic and services offered by the context using the query methods."
    },
    {
      "indent": 3,
      "text": "The context establishment phase begins with the first call to the init method by the context initiator. During this phase, the initSecContext and acceptSecContext methods will produce GSS-API authentication tokens, which the calling application needs to send to its peer. If an error occurs at any point, an exception will get thrown and the code will start executing in a catch block where the exception may contain an output token that should be sent to the peer for debugging or informational purpose. If not, the normal flow of code continues, and the application can make a call to the isEstablished() method. If this method returns \"false\", it indicates that a token is needed from its peer in order to continue the context establishment phase. A return value of \"true\" signals that the local end of the context is established. This may still require that a token be sent to the peer, if one is produced by GSS-API. During the context establishment phase, the isProtReady() method may be called to determine if the context can be used for the per-message operations. This allows applications to use per-message operations on contexts that aren't fully established.",
      "ja": "コンテキスト確立フェーズは、コンテキスト開始者によるinitメソッドの最初の呼び出しから始まります。このフェーズでは、initSecContextメソッドとacceptSecContextメソッドがGSS-API認証トークンを生成します。これは、呼び出し側アプリケーションがピアに送信する必要があるトークンです。いずれかの時点でエラーが発生すると、例外がスローされ、コードはキャッチブロックで実行を開始します。例外には、デバッグまたは情報提供のためにピアに送信する必要がある出力トークンが含まれる場合があります。そうでない場合は、通常のコードフローが続行され、アプリケーションはisEstablished()メソッドを呼び出すことができます。このメソッドが「false」を返す場合、コンテキスト確立フェーズを続行するには、ピアからトークンが必要であることを示します。 「true」の戻り値は、コンテキストのローカルエンドが確立されたことを示します。トークンがGSS-APIによって生成されている場合は、トークンをピアに送信する必要があります。コンテキスト確立フェーズ中にisProtReady()メソッドを呼び出して、メッセージごとの操作にコンテキストを使用できるかどうかを判断できます。これにより、アプリケーションは、完全に確立されていないコンテキストでメッセージごとの操作を使用できます。"
    },
    {
      "indent": 3,
      "text": "After the context has been established or the isProtReady() method returns \"true\", the query routines can be invoked to determine the actual characteristics and services of the established context. The application can also start using the per-message methods of wrap and getMIC to obtain cryptographic operations on application-supplied data.",
      "ja": "コンテキストが確立された後、またはisProtReady()メソッドが「true」を返した後、クエリルーチンを呼び出して、確立されたコンテキストの実際の特性とサービスを確認できます。アプリケーションは、wrapおよびgetMICのメッセージごとのメソッドの使用を開始して、アプリケーション提供のデータに対する暗号化操作を取得することもできます。"
    },
    {
      "indent": 3,
      "text": "When the context is no longer needed, the application SHOULD call dispose to release any system resources the context may be using.",
      "ja": "コンテキストが不要になった場合、アプリケーションはdisposeを呼び出して、コンテキストが使用しているシステムリソースを解放する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Static Constants",
      "section_title": true,
      "ja": "7.4.1. 静的定数"
    },
    {
      "indent": 3,
      "text": "public static final int DEFAULT_LIFETIME",
      "ja": "public static final int DEFAULT_LIFETIME"
    },
    {
      "indent": 3,
      "text": "A lifetime constant representing the default context lifetime. The value of this constant is 0.",
      "ja": "デフォルトのコンテキストライフタイムを表すライフタイム定数。この定数の値は0です。"
    },
    {
      "indent": 3,
      "text": "public static final int INDEFINITE_LIFETIME",
      "ja": "public static final int INDEFINITE_LIFETIME"
    },
    {
      "indent": 3,
      "text": "A lifetime constant representing indefinite context lifetime. The value of this constant is the maximum integer value in Java -- Integer.MAX_VALUE.",
      "ja": "不定のコンテキスト存続期間を表す存続期間定数。この定数の値は、Javaの最大整数値であるInteger.MAX_VALUEです。"
    },
    {
      "indent": 0,
      "text": "7.4.2. initSecContext",
      "section_title": true,
      "ja": "7.4.2. initSecContext"
    },
    {
      "indent": 3,
      "text": "public byte[] initSecContext(byte[] inputBuf, int offset, int len) throws GSSException",
      "ja": "public byte [] initSecContext（byte [] inputBuf、int offset、int len）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Called by the context initiator to start the context creation process. This method MAY return an output token that the application will need to send to the peer for processing by the accept call. The application can call isEstablished() to determine if the context establishment phase is complete for this peer. A return value of \"false\" from isEstablished() indicates that more tokens are expected to be supplied to the initSecContext() method. Note that it is possible that the initSecContext() method will return a token for the peer and isEstablished() will return \"true\" also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.",
      "ja": "コンテキスト作成プロセスを開始するためにコンテキスト開始者によって呼び出されます。このメソッドは、アプリケーションが受け入れ呼び出しによる処理のためにピアに送信する必要がある出力トークンを返す場合があります。アプリケーションはisEstablished()を呼び出して、このピアのコンテキスト確立フェーズが完了したかどうかを判断できます。 isEstablished()からの戻り値が「false」の場合、より多くのトークンがinitSecContext()メソッドに提供されると予想されます。 initSecContext()メソッドがピアのトークンを返し、isEstablished()が「true」を返す可能性があることに注意してください。これは、トークンをピアに送信する必要があるが、コンテキストのローカルエンドが完全に確立されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "Upon completion of the context establishment, the available context options may be queried through the get methods.",
      "ja": "コンテキストの確立が完了すると、getメソッドを介して、使用可能なコンテキストオプションを照会できます。"
    },
    {
      "indent": 3,
      "text": "A GSSException will be thrown if the call fails. Users SHOULD call its getOutputToken() method to find out if there is a token that can be sent to the acceptor to communicate the reason for the error.",
      "ja": "呼び出しが失敗した場合、GSSExceptionがスローされます。ユーザーはgetOutputToken()メソッドを呼び出して、エラーの理由を伝えるためにアクセプターに送信できるトークンがあるかどうかを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inputBuf Token generated by the peer. This parameter is ignored on the first call.",
      "ja": "inputBuf Token generated by the peer. This parameter is ignored on the first call."
    },
    {
      "indent": 3,
      "text": "offset The offset within the inputBuf where the token begins.",
      "ja": "offsetトークンが始まるinputBuf内のオフセット。"
    },
    {
      "indent": 3,
      "text": "len The length of the token within the inputBuf (starting at the offset).",
      "ja": "len The length of the token within the inputBuf (starting at the offset)."
    },
    {
      "indent": 0,
      "text": "7.4.3. acceptSecContext",
      "section_title": true,
      "ja": "7.4.3. acceptSecContext"
    },
    {
      "indent": 3,
      "text": "public byte[] acceptSecContext(byte[] inTok, int offset, int len) throws GSSException",
      "ja": "public byte [] acceptSecContext（byte [] inTok、int offset、int len）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Called by the context acceptor upon receiving a token from the peer.",
      "ja": "ピアからトークンを受信すると、コンテキストアクセプターによって呼び出されます。"
    },
    {
      "indent": 3,
      "text": "This method MAY return an output token that the application will need to send to the peer for further processing by the init call.",
      "ja": "このメソッドは、アプリケーションがinit呼び出しでさらに処理するためにピアに送信する必要がある出力トークンを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "The \"null\" return value indicates that no token needs to be sent to the peer. The application can call isEstablished() to determine if the context establishment phase is complete for this peer. A return value of \"false\" from isEstablished() indicates that more tokens are expected to be supplied to this method.",
      "ja": "「null」戻り値は、トークンをピアに送信する必要がないことを示します。アプリケーションはisEstablished()を呼び出して、このピアのコンテキスト確立フェーズが完了したかどうかを判断できます。 isEstablished()からの「false」の戻り値は、このメソッドに追加のトークンが提供されることが予想されることを示します。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible that acceptSecContext() will return a token for the peer and isEstablished() will return \"true\" also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.",
      "ja": "acceptSecContext()がピアのトークンを返し、isEstablished()も「true」を返す可能性があることに注意してください。これは、トークンをピアに送信する必要があるが、コンテキストのローカルエンドが完全に確立されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "Upon completion of the context establishment, the available context options may be queried through the get methods.",
      "ja": "コンテキストの確立が完了すると、getメソッドを介して、使用可能なコンテキストオプションを照会できます。"
    },
    {
      "indent": 3,
      "text": "A GSSException will be thrown if the call fails. Users SHOULD call its getOutputToken() method to find out if there is a token that can be sent to the initiator to communicate the reason for the error.",
      "ja": "呼び出しが失敗した場合、GSSExceptionがスローされます。ユーザーは、そのgetOutputToken()メソッドを呼び出して、エラーの理由を伝えるためにイニシエーターに送信できるトークンがあるかどうかを確認する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inTok Token generated by the peer.",
      "ja": "ピアによって生成されたinTokトークン。"
    },
    {
      "indent": 3,
      "text": "offset The offset within the inTok where the token begins.",
      "ja": "offsetトークンが始まるinTok内のオフセット。"
    },
    {
      "indent": 3,
      "text": "len The length of the token within the inTok (starting at the offset).",
      "ja": "len inTok内のトークンの長さ（オフセットから開始）。"
    },
    {
      "indent": 0,
      "text": "7.4.4. isEstablished",
      "section_title": true,
      "ja": "7.4.4. 確立されています"
    },
    {
      "indent": 3,
      "text": "public boolean isEstablished()",
      "ja": "public boolean isEstablished()"
    },
    {
      "indent": 3,
      "text": "Used during context establishment to determine the state of the context. Returns \"true\" if this is a fully established context on the caller's side and no more tokens are needed from the peer. Should be called after a call to initSecContext() or acceptSecContext() when no GSSException is thrown.",
      "ja": "コンテキストの確立中に、コンテキストの状態を判別するために使用されます。これが呼び出し側で完全に確立されたコンテキストであり、ピアからのトークンがこれ以上必要ない場合は、「true」を返します。 GSSExceptionがスローされない場合、initSecContext()またはacceptSecContext()の呼び出しの後に呼び出す必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.5. dispose",
      "section_title": true,
      "ja": "7.4.5. 廃棄"
    },
    {
      "indent": 3,
      "text": "public void dispose() throws GSSException",
      "ja": "public void dispose()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Releases any system resources and cryptographic information stored in the context object. This will invalidate the context.",
      "ja": "コンテキストオブジェクトに保存されているシステムリソースと暗号化情報を解放します。これはコンテキストを無効にします。"
    },
    {
      "indent": 0,
      "text": "7.4.6. getWrapSizeLimit",
      "section_title": true,
      "ja": "7.4.6. getWrapSizeLimit"
    },
    {
      "indent": 3,
      "text": "public int getWrapSizeLimit(int qop, boolean confReq, int maxTokenSize) throws GSSException",
      "ja": "public int getWrapSizeLimit（int qop、boolean confReq、int maxTokenSize）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the maximum message size that, if presented to the wrap method with the same confReq and qop parameters, will result in an output token containing no more than the maxTokenSize bytes.",
      "ja": "同じconfReqおよびqopパラメーターを使用してwrapメソッドに提示された場合に、maxTokenSizeバイト以下を含む出力トークンとなる最大メッセージサイズを返します。"
    },
    {
      "indent": 3,
      "text": "This call is intended for use by applications that communicate over protocols that impose a maximum message size. It enables the application to fragment messages prior to applying protection.",
      "ja": "この呼び出しは、最大メッセージサイズを課すプロトコルを介して通信するアプリケーションによる使用を目的としています。これにより、アプリケーションは保護を適用する前にメッセージをフラグメント化できます。"
    },
    {
      "indent": 3,
      "text": "GSS-API implementations are RECOMMENDED but not required to detect invalid QOP values when getWrapSizeLimit is called. This routine guarantees only a maximum message size, not the availability of specific QOP values for message protection.",
      "ja": "GSS-API実装は推奨されますが、getWrapSizeLimitが呼び出されたときに無効なQOP値を検出する必要はありません。このルーチンは、メッセージ保護のための特定のQOP値の可用性ではなく、最大メッセージサイズのみを保証します。"
    },
    {
      "indent": 3,
      "text": "Successful completion of this call does not guarantee that wrap will be able to protect a message of the computed length, since this ability may depend on the availability of system resources at the time that wrap is called. However, if the implementation itself imposes an upper limit on the length of messages that may be processed by wrap, the implementation SHOULD NOT return a value that is greater than this length.",
      "ja": "この機能は、wrapが呼び出されたときのシステムリソースの可用性に依存する可能性があるため、この呼び出しが正常に完了しても、wrapが計算された長さのメッセージを保護できるとは限りません。ただし、実装自体がラップによって処理されるメッセージの長さに上限を課す場合、実装はこの長さより大きい値を返すべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "qop Indicates the level of protection wrap will be asked to provide.",
      "ja": "qop提供するように要求される保護ラップのレベルを示します。"
    },
    {
      "indent": 3,
      "text": "confReq Indicates if wrap will be asked to provide privacy service.",
      "ja": "confReqラップがプライバシーサービスの提供を要求されるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "maxTokenSize The desired maximum size of the token emitted by wrap.",
      "ja": "maxTokenSize wrapが発行するトークンの望ましい最大サイズ。"
    },
    {
      "indent": 0,
      "text": "7.4.7. wrap",
      "section_title": true,
      "ja": "7.4.7. ラップ"
    },
    {
      "indent": 3,
      "text": "public byte[] wrap(byte[] inBuf, int offset, int len, MessageProp msgProp) throws GSSException",
      "ja": "public byte [] wrap（byte [] inBuf、int offset、int len、MessageProp msgProp）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Applies per-message security services over the established security context. The method will return a token with a cryptographic MIC and MAY optionally encrypt the specified inBuf. The returned byte array will contain both the MIC and the message.",
      "ja": "確立されたセキュリティコンテキストにメッセージごとのセキュリティサービスを適用します。このメソッドは暗号化MICを含むトークンを返し、オプションで指定されたinBufを暗号化できます（MAY）。返されるバイト配列には、MICとメッセージの両方が含まれます。"
    },
    {
      "indent": 3,
      "text": "The MessageProp object is instantiated by the application and used to specify a QOP value that selects cryptographic algorithms and a privacy service to optionally encrypt the message. The underlying mechanism that is used in the call may not be able to provide the privacy service. It sets the actual privacy service that it does provide in this MessageProp object, which the caller SHOULD then query upon return. If the mechanism is not able to provide the requested QOP, it throws a GSSException with the BAD_QOP code.",
      "ja": "MessagePropオブジェクトはアプリケーションによってインスタンス化され、オプションでメッセージを暗号化する暗号化アルゴリズムとプライバシーサービスを選択するQOP値を指定するために使用されます。呼び出しで使用される基本的なメカニズムは、プライバシーサービスを提供できない場合があります。それは、このMessagePropオブジェクトで提供する実際のプライバシーサービスを設定します。呼び出し側は、戻り時に照会する必要があります。メカニズムが要求されたQOPを提供できない場合、メカニズムはBAD_QOPコードでGSSExceptionをスローします。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by wrap to provide \"secure framing\", implementations SHOULD support the wrapping of zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルでは、wrapによって発行されたトークンを使用して「安全なフレーミング」を提供したい場合があるため、実装では長さ0のメッセージのラップをサポートする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The application will be responsible for sending the token to the peer.",
      "ja": "アプリケーションは、トークンをピアに送信する責任があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inBuf Application data to be protected.",
      "ja": "保護するinBufアプリケーションデータ。"
    },
    {
      "indent": 3,
      "text": "offset The offset within the inBuf where the data begins.",
      "ja": "offsetデータが始まるinBuf内のオフセット。"
    },
    {
      "indent": 3,
      "text": "len The length of the data within the inBuf (starting at the offset).",
      "ja": "len inBuf内のデータの長さ（オフセットから開始）。"
    },
    {
      "indent": 3,
      "text": "msgProp Instance of MessageProp that is used by the application to set the desired QOP and privacy state. Set the desired QOP to 0 to request the default QOP. Upon return from this method, this object will contain the actual privacy state that was applied to the message by the underlying mechanism.",
      "ja": "msgProp必要なQOPおよびプライバシー状態を設定するためにアプリケーションによって使用されるMessagePropのインスタンス。目的のQOPを0に設定して、デフォルトのQOPを要求します。このメソッドから戻ると、このオブジェクトには、基になるメカニズムによってメッセージに適用された実際のプライバシー状態が含まれます。"
    },
    {
      "indent": 0,
      "text": "7.4.8. unwrap",
      "section_title": true,
      "ja": "7.4.8. アンラップ"
    },
    {
      "indent": 3,
      "text": "public byte[] unwrap(byte[] inBuf, int offset, int len, MessageProp msgProp) throws GSSException",
      "ja": "public byte [] unwrap（byte [] inBuf、int offset、int len、MessageProp msgProp）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Used by the peer application to process tokens generated with the wrap call. The method will return the message supplied in the peer application to the wrap call, verifying the embedded MIC.",
      "ja": "wrap呼び出しで生成されたトークンを処理するためにピアアプリケーションによって使用されます。このメソッドは、ピアアプリケーションで提供されたメッセージをラップ呼び出しに返し、埋め込まれたMICを確認します。"
    },
    {
      "indent": 3,
      "text": "The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP, whether confidentiality was applied to the message, and other supplementary message state information.",
      "ja": "MessagePropオブジェクトはアプリケーションによってインスタンス化され、QOP、機密性がメッセージに適用されたかどうか、およびその他の補足的なメッセージ状態情報などの情報を呼び出し元に返すために、基盤となるメカニズムによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by wrap to provide \"secure framing\", implementations SHOULD support the wrapping and unwrapping of zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、wrapによって発行されたトークンを使用して「安全なフレーミング」を提供したい場合があるため、実装では長さゼロのメッセージのラップとアンラップをサポートする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inBuf GSS-API wrap token received from peer.",
      "ja": "ピアから受信したinBuf GSS-APIラップトークン。"
    },
    {
      "indent": 3,
      "text": "offset The offset within the inBuf where the token begins.",
      "ja": "offsetトークンが始まるinBuf内のオフセット。"
    },
    {
      "indent": 3,
      "text": "len The length of the token within the inBuf (starting at the offset).",
      "ja": "len inBuf内のトークンの長さ（オフセットから開始）。"
    },
    {
      "indent": 3,
      "text": "msgProp Upon return from the method, this object will contain the applied QOP, the privacy state of the message, and supplementary information, described in Section 5.12.3, stating whether the token was a duplicate, old, out of sequence, or arriving after a gap.",
      "ja": "msgProp Upon return from the method, this object will contain the applied QOP, the privacy state of the message, and supplementary information, described in Section 5.12.3, stating whether the token was a duplicate, old, out of sequence, or arriving after a gap."
    },
    {
      "indent": 0,
      "text": "7.4.9. getMIC",
      "section_title": true,
      "ja": "7.4.9. getMIC"
    },
    {
      "indent": 3,
      "text": "public byte[] getMIC(byte[] inMsg, int offset, int len, MessageProp msgProp) throws GSSException",
      "ja": "public byte [] getMIC（byte [] inMsg、int offset、int len、MessageProp msgProp）がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns a token containing a cryptographic MIC for the supplied message for transfer to the peer application. Unlike wrap, which encapsulates the user message in the returned token, only the message MIC is returned in the output token.",
      "ja": "ピアアプリケーションに転送するために、指定されたメッセージの暗号化MICを含むトークンを返します。返されたトークンにユーザーメッセージをカプセル化するラップとは異なり、出力トークンにはメッセージMICのみが返されます。"
    },
    {
      "indent": 3,
      "text": "Note that privacy can only be applied through the wrap call.",
      "ja": "プライバシーはラップコールを通じてのみ適用できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by getMIC to provide \"secure framing\", implementations SHOULD support derivation of MICs from zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、getMICによって発行されたトークンを使用して「安全なフレーミング」を提供したい場合があるため、実装では長さゼロのメッセージからのMICの導出をサポートする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inMsg Message over which to generate MIC.",
      "ja": "inMsg MICを生成するメッセージ。"
    },
    {
      "indent": 3,
      "text": "offset The offset within the inMsg where the token begins.",
      "ja": "offsetトークンが始まるinMsg内のオフセット。"
    },
    {
      "indent": 3,
      "text": "len The length of the token within the inMsg (starting at the offset).",
      "ja": "len The length of the token within the inMsg (starting at the offset)."
    },
    {
      "indent": 3,
      "text": "msgProp Instance of MessageProp that is used by the application to set the desired QOP. Set the desired QOP to 0 in msgProp to request the default QOP. Alternatively, pass in \"null\" for msgProp to request default QOP.",
      "ja": "msgProp必要なQOPを設定するためにアプリケーションが使用するMessagePropのインスタンス。 msgPropで目的のQOPを0に設定して、デフォルトのQOPを要求します。または、msgPropに「null」を渡して、デフォルトのQOPを要求します。"
    },
    {
      "indent": 0,
      "text": "7.4.10. verifyMIC",
      "section_title": true,
      "ja": "7.4.10. verifyMIC"
    },
    {
      "indent": 3,
      "text": "public void verifyMIC(byte[] inTok, int tokOffset, int tokLen, byte[] inMsg, int msgOffset, int msgLen, MessageProp msgProp) throws GSSException",
      "ja": "public void verifyMIC（byte [] inTok、int tokOffset、int tokLen、byte [] inMsg、int msgOffset、int msgLen、MessageProp msgProp）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Verifies the cryptographic MIC, contained in the token parameter, over the supplied message.",
      "ja": "提供されたメッセージに対して、トークンパラメータに含まれている暗号化MICを確認します。"
    },
    {
      "indent": 3,
      "text": "The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP indicating the strength of protection that was applied to the message and other supplementary message state information.",
      "ja": "MessagePropオブジェクトはアプリケーションによってインスタンス化され、メッセージに適用された保護の強さを示すQOPなどの情報とその他の補足メッセージ状態情報を呼び出し元に返すために、基になるメカニズムによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by getMIC to provide \"secure framing\", implementations SHOULD support the calculation and verification of MICs over zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルでは、getMICによって発行されたトークンを使用して「安全なフレーミング」を提供したい場合があるため、実装では長さがゼロのメッセージに対するMICの計算と検証をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "inTok Token generated by peer's getMIC method.",
      "ja": "ピアのgetMICメソッドによって生成されたinTokトークン。"
    },
    {
      "indent": 3,
      "text": "tokOffset The offset within the inTok where the token begins.",
      "ja": "tokOffsetトークンが始まるinTok内のオフセット。"
    },
    {
      "indent": 3,
      "text": "tokLen The length of the token within the inTok (starting at the offset).",
      "ja": "tokLen inTok内のトークンの長さ（オフセットから開始）。"
    },
    {
      "indent": 3,
      "text": "inMsg Application message over which to verify the cryptographic MIC.",
      "ja": "inMsg暗号化MICを検証するためのアプリケーションメッセージ。"
    },
    {
      "indent": 3,
      "text": "msgOffset The offset within the inMsg where the message begins.",
      "ja": "msgOffsetメッセージが始まるinMsg内のオフセット。"
    },
    {
      "indent": 3,
      "text": "msgLen The length of the message within the inMsg (starting at the offset).",
      "ja": "msgLen inMsg内のメッセージの長さ（オフセットから開始）。"
    },
    {
      "indent": 3,
      "text": "msgProp Upon return from the method, this object will contain the applied QOP and supplementary information, described in Section 5.12.3, stating whether the token was a duplicate, old, out of sequence, or arriving after a gap. The confidentiality state will be set to \"false\".",
      "ja": "msgPropメソッドから戻ると、このオブジェクトには、適用されたQOPと5.12.3で説明されている補足情報が含まれ、トークンが重複しているか、古いか、順序が間違っているか、ギャップの後に到着したかを示します。機密性の状態は「false」に設定されます。"
    },
    {
      "indent": 0,
      "text": "7.4.11. export",
      "section_title": true,
      "ja": "7.4.11. 書き出す"
    },
    {
      "indent": 3,
      "text": "public byte[] export() throws GSSException",
      "ja": "public byte [] export()がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Provided to support the sharing of work between multiple processes. This routine will typically be used by the context acceptor, in an application where a single process receives incoming connection requests and accepts security contexts over them, then passes the established context to one or more other processes for message exchange.",
      "ja": "複数のプロセス間での作業の共有をサポートするために提供されています。このルーチンは通常、単一のプロセスが着信接続要求を受信し、それらを介してセキュリティコンテキストを受け入れ、メッセージ交換のために確立されたコンテキストを1つ以上の他のプロセスに渡すアプリケーションで、コンテキストアクセプターによって使用されます。"
    },
    {
      "indent": 3,
      "text": "This method deactivates the security context and creates an inter-process token that, when passed to the byte array constructor of the GSSContext interface in another process, will re-activate the context in the second process. Only a single instantiation of a given context may be active at any one time; a subsequent attempt by a context exporter to access the exported security context will fail.",
      "ja": "このメソッドは、セキュリティコンテキストを非アクティブ化し、別のプロセスのGSSContextインタフェースのバイト配列コンストラクタに渡されると、2番目のプロセスのコンテキストを再アクティブ化するプロセス間トークンを作成します。特定のコンテキストのインスタンス化は、一度に1つしかアクティブにできません。エクスポートされたセキュリティコンテキストにアクセスするためのコンテキストエクスポータによる後続の試行は失敗します。"
    },
    {
      "indent": 3,
      "text": "The implementation MAY constrain the set of processes by which the inter-process token may be imported, either as a function of local security policy or as a result of implementation decisions. For example, some implementations may constrain contexts to be passed only between processes that run under the same account, or which are part of the same process group.",
      "ja": "実装は、ローカルセキュリティポリシーの関数として、または実装決定の結果として、プロセス間トークンをインポートできるプロセスのセットを制約してもよい（MAY）。たとえば、一部の実装では、同じアカウントで実行されるプロセス間、または同じプロセスグループの一部であるプロセス間でのみコンテキストが渡されるように制約する場合があります。"
    },
    {
      "indent": 3,
      "text": "The inter-process token MAY contain security-sensitive information (for example, cryptographic keys). While mechanisms are encouraged either to avoid placing such sensitive information within inter-process tokens or to encrypt the token before returning it to the application, in a typical GSS-API implementation, this may not be possible. Thus, the application MUST take care to protect the inter-process token and ensure that any process to which the token is transferred is trustworthy.",
      "ja": "プロセス間トークンには、セキュリティ上重要な情報（暗号化キーなど）が含まれている場合があります。このような機密情報をプロセス間トークン内に配置しないようにするか、トークンをアプリケーションに返す前に暗号化するメカニズムが推奨されますが、一般的なGSS-API実装では、これができない場合があります。したがって、アプリケーションはプロセス間トークンを保護し、トークンの転送先のプロセスが信頼できることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.12. requestMutualAuth",
      "section_title": true,
      "ja": "7.4.12. requestMutualAuth"
    },
    {
      "indent": 3,
      "text": "public void requestMutualAuth(boolean state) throws GSSException",
      "ja": "public void requestMutualAuth（boolean state）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the request state of the mutual authentication flag for the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "コンテキストの相互認証フラグの要求状態を設定します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean representing if mutual authentication should be requested during context establishment.",
      "ja": "コンテキストの確立中に相互認証を要求するかどうかを表すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.13. requestReplayDet",
      "section_title": true,
      "ja": "7.4.13. requestReplayDet"
    },
    {
      "indent": 3,
      "text": "public void requestReplayDet(boolean state) throws GSSException",
      "ja": "public void requestReplayDet（boolean state）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the request state of the replay detection service for the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "コンテキストのリプレイ検出サービスの要求状態を設定します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean representing if replay detection is desired over the established context.",
      "ja": "確立されたコンテキストでリプレイ検出が必要かどうかを表すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.14. requestSequenceDet",
      "section_title": true,
      "ja": "7.4.14. requestSequenceDet"
    },
    {
      "indent": 3,
      "text": "public void requestSequenceDet(boolean state) throws GSSException",
      "ja": "public void requestSequenceDet（boolean state）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the request state for the sequence-checking service of the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "コンテキストのシーケンスチェックサービスの要求状態を設定します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean representing if sequence detection is desired over the established context.",
      "ja": "確立されたコンテキストでシーケンス検出が必要かどうかを表すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.15. requestCredDeleg",
      "section_title": true,
      "ja": "7.4.15. requestCredDeleg"
    },
    {
      "indent": 3,
      "text": "public void requestCredDeleg(boolean state) throws GSSException",
      "ja": "public void requestCredDeleg（boolean state）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the request state for the credential delegation flag for the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "コンテキストの資格情報委任フラグの要求状態を設定します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean representing if credential delegation is desired.",
      "ja": "資格の委任が必要かどうかを表すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.16. requestAnonymity",
      "section_title": true,
      "ja": "7.4.16. requestAnonymity"
    },
    {
      "indent": 3,
      "text": "public void requestAnonymity(boolean state) throws GSSException",
      "ja": "public void requestAnonymity（boolean state）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Requests anonymous support over the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "コンテキストで匿名サポートを要求します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean representing if anonymity support is requested.",
      "ja": "匿名サポートが要求されているかどうかを表すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.17. requestConf",
      "section_title": true,
      "ja": "7.4.17. requestConf"
    },
    {
      "indent": 3,
      "text": "public void requestConf(boolean state) throws GSSException",
      "ja": "public void requestConf（boolean state）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Requests that confidentiality service be available over the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "機密情報サービスをコンテキスト全体で利用できるように要求します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean indicating if confidentiality services are to be requested for the context.",
      "ja": "コンテキストに対して機密性サービスが要求されるかどうかを示すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.18. requestInteg",
      "section_title": true,
      "ja": "7.4.18. requestInteg"
    },
    {
      "indent": 3,
      "text": "public void requestInteg(boolean state) throws GSSException",
      "ja": "public void requestInteg（boolean state）はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Requests that integrity services be available over the context. This method is only valid before the context creation process begins and only for the initiator.",
      "ja": "整合性サービスがコンテキスト全体で利用可能であることを要求します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "state Boolean indicating if integrity services are to be requested for the context.",
      "ja": "完全性サービスがコンテキストに対して要求されるかどうかを示すブール値。"
    },
    {
      "indent": 0,
      "text": "7.4.19. requestLifetime",
      "section_title": true,
      "ja": "7.4.19. requestLifetime"
    },
    {
      "indent": 3,
      "text": "public void requestLifetime(int lifetime) throws GSSException",
      "ja": "public void requestLifetime（int lifetime）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the desired lifetime for the context in seconds. This method is only valid before the context creation process begins and only for the initiator. Use GSSContext.INDEFINITE_LIFETIME and GSSContext.DEFAULT_LIFETIME to request indefinite or default context lifetime.",
      "ja": "コンテキストに必要な有効期間を秒単位で設定します。このメソッドは、コンテキスト作成プロセスが開始する前、およびイニシエーターに対してのみ有効です。 GSSContext.INDEFINITE_LIFETIMEおよびGSSContext.DEFAULT_LIFETIMEを使用して、無期限またはデフォルトのコンテキスト存続時間を要求します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "lifetime The desired context lifetime in seconds.",
      "ja": "lifetime必要なコンテキストのライフタイム（秒単位）。"
    },
    {
      "indent": 0,
      "text": "7.4.20. setChannelBinding",
      "section_title": true,
      "ja": "7.4.20. せｔちゃんえｌびんぢんｇ"
    },
    {
      "indent": 3,
      "text": "public void setChannelBinding(ChannelBinding cb) throws GSSException",
      "ja": "public void setChannelBinding（ChannelBinding cb）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Sets the channel bindings to be used during context establishment. This method is only valid before the context creation process begins.",
      "ja": "コンテキストの確立中に使用されるチャネルバインディングを設定します。このメソッドは、コンテキスト作成プロセスが開始する前にのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "cb Channel bindings to be used.",
      "ja": "cb使用するチャネルバインディング。"
    },
    {
      "indent": 0,
      "text": "7.4.21. getCredDelegState",
      "section_title": true,
      "ja": "7.4.21. getCredDelegState"
    },
    {
      "indent": 3,
      "text": "public boolean getCredDelegState()",
      "ja": "public boolean getCredDelegState()"
    },
    {
      "indent": 3,
      "text": "Returns the state of the delegated credentials for the context. When issued before context establishment is completed or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストの委任された資格情報の状態を返します。コンテキストの確立が完了する前に発行されるか、isProtReadyメソッドが「false」を返すと、目的の状態が返されます。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.22. getMutualAuthState",
      "section_title": true,
      "ja": "7.4.22. getMutualAuthState"
    },
    {
      "indent": 3,
      "text": "public boolean getMutualAuthState()",
      "ja": "public boolean getMutualAuthState()"
    },
    {
      "indent": 3,
      "text": "Returns the state of the mutual authentication option for the context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストの相互認証オプションの状態を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.23. getReplayDetState",
      "section_title": true,
      "ja": "7.4.23. getReplayDetState"
    },
    {
      "indent": 3,
      "text": "public boolean getReplayDetState()",
      "ja": "public boolean getReplayDetState()"
    },
    {
      "indent": 3,
      "text": "Returns the state of the replay detection option for the context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストのリプレイ検出オプションの状態を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.24. getSequenceDetState",
      "section_title": true,
      "ja": "7.4.24. getSequenceDetState"
    },
    {
      "indent": 3,
      "text": "public boolean getSequenceDetState()",
      "ja": "public boolean getSequenceDetState()"
    },
    {
      "indent": 3,
      "text": "Returns the state of the sequence detection option for the context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストのシーケンス検出オプションの状態を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.25. getAnonymityState",
      "section_title": true,
      "ja": "7.4.25. getAnonymityState"
    },
    {
      "indent": 3,
      "text": "public boolean getAnonymityState()",
      "ja": "public boolean getAnonymityState()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if this is an anonymous context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "これが匿名コンテキストの場合、「true」を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.26. isTransferable",
      "section_title": true,
      "ja": "7.4.26. isTransferable"
    },
    {
      "indent": 3,
      "text": "public boolean isTransferable() throws GSSException",
      "ja": "public boolean isTransferable()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if the context is transferable to other processes through the use of the export method. This call is only valid on fully established contexts.",
      "ja": "エクスポートメソッドを使用してコンテキストを他のプロセスに転送できる場合は、「true」を返します。この呼び出しは、完全に確立されたコンテキストでのみ有効です。"
    },
    {
      "indent": 0,
      "text": "7.4.27. isProtReady",
      "section_title": true,
      "ja": "7.4.27. isProtReady"
    },
    {
      "indent": 3,
      "text": "public boolean isProtReady()",
      "ja": "パブリックブールisProtReady()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if the per-message operations can be applied over the context. Some mechanisms may allow the usage of per-message operations before the context is fully established. This will also indicate that the get methods will return actual context state characteristics instead of the desired ones.",
      "ja": "メッセージごとの操作をコンテキストに適用できる場合は「true」を返します。一部のメカニズムでは、コンテキストが完全に確立される前にメッセージごとの操作を使用できます。これは、getメソッドが、希望するものではなく実際のコンテキスト状態特性を返すことも示します。"
    },
    {
      "indent": 0,
      "text": "7.4.28. getConfState",
      "section_title": true,
      "ja": "7.4.28. getConfState"
    },
    {
      "indent": 3,
      "text": "public boolean getConfState()",
      "ja": "パブリックブールgetConfState()"
    },
    {
      "indent": 3,
      "text": "Returns the confidentiality service state over the context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストを介して機密性サービスの状態を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.29. getIntegState",
      "section_title": true,
      "ja": "7.4.29. getIntegState"
    },
    {
      "indent": 3,
      "text": "public boolean getIntegState()",
      "ja": "public boolean getIntegState()"
    },
    {
      "indent": 3,
      "text": "Returns the integrity service state over the context. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired state; otherwise, it will indicate the actual state over the established context.",
      "ja": "コンテキストで整合性サービスの状態を返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の状態を返します。それ以外の場合は、確立されたコンテキストでの実際の状態を示します。"
    },
    {
      "indent": 0,
      "text": "7.4.30. getLifetime",
      "section_title": true,
      "ja": "7.4.30. getLifetime"
    },
    {
      "indent": 3,
      "text": "public int getLifetime()",
      "ja": "public int getLifetime()"
    },
    {
      "indent": 3,
      "text": "Returns the context lifetime in seconds. When issued before context establishment completes or when the isProtReady method returns \"false\", it returns the desired lifetime; otherwise, it will indicate the remaining lifetime for the context.",
      "ja": "コンテキストの有効期間を秒単位で返します。コンテキストの確立が完了する前に発行された場合、またはisProtReadyメソッドが「false」を返した場合、目的の有効期間を返します。それ以外の場合は、コンテキストの残りのライフタイムを示します。"
    },
    {
      "indent": 0,
      "text": "7.4.31. getSrcName",
      "section_title": true,
      "ja": "7.4.31. getSrcName"
    },
    {
      "indent": 3,
      "text": "public GSSName getSrcName() throws GSSException",
      "ja": "public GSSName getSrcName()はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns the name of the context initiator. This call is valid only after the context is fully established or the isProtReady method returns \"true\". It is guaranteed to return an MN.",
      "ja": "コンテキスト起動側の名前を返します。この呼び出しは、コンテキストが完全に確立されるか、isProtReadyメソッドが「true」を返した後にのみ有効です。 MNを返すことが保証されています。"
    },
    {
      "indent": 0,
      "text": "7.4.32. getTargName",
      "section_title": true,
      "ja": "7.4.32. げったｒｇなめ"
    },
    {
      "indent": 3,
      "text": "public GSSName getTargName() throws GSSException",
      "ja": "public GSSName getTargName()はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns the name of the context target (acceptor). This call is valid only after the context is fully established or the isProtReady method returns \"true\". It is guaranteed to return an MN.",
      "ja": "コンテキストターゲット（アクセプター）の名前を返します。この呼び出しは、コンテキストが完全に確立されるか、isProtReadyメソッドが「true」を返した後にのみ有効です。 MNを返すことが保証されています。"
    },
    {
      "indent": 0,
      "text": "7.4.33. getMech",
      "section_title": true,
      "ja": "7.4.33. getMech"
    },
    {
      "indent": 3,
      "text": "public Oid getMech() throws GSSException",
      "ja": "public Oid getMech()がGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns the mechanism OID for this context. This method MAY be called before the context is fully established, but the mechanism returned MAY change on successive calls in a negotiated mechanism case.",
      "ja": "このコンテキストのメカニズムOIDを返します。このメソッドは、コンテキストが完全に確立される前に呼び出すことができますが、メカニズムは、ネゴシエートされたメカニズムの場合、連続する呼び出しで変更を返す場合があります。"
    },
    {
      "indent": 0,
      "text": "7.4.34. getDelegCred",
      "section_title": true,
      "ja": "7.4.34. getDelegCred"
    },
    {
      "indent": 3,
      "text": "public GSSCredential getDelegCred() throws GSSException",
      "ja": "public GSSCredential getDelegCred()がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Returns the delegated credential object on the acceptor's side. To check for availability of delegated credentials, call getDelegCredState. This call is only valid on fully established contexts.",
      "ja": "受け入れ側の委任された資格情報オブジェクトを返します。委任された資格情報の可用性を確認するには、getDelegCredStateを呼び出します。この呼び出しは、完全に確立されたコンテキストでのみ有効です。"
    },
    {
      "indent": 0,
      "text": "7.4.35. isInitiator",
      "section_title": true,
      "ja": "7.4.35. isInitiator"
    },
    {
      "indent": 3,
      "text": "public boolean isInitiator() throws GSSException",
      "ja": "public boolean isInitiator()はGSSExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if this is the initiator of the context. This call is only valid after the context creation process has started.",
      "ja": "これがコンテキストのイニシエータである場合、「true」を返します。この呼び出しは、コンテキスト作成プロセスが開始した後でのみ有効です。"
    },
    {
      "indent": 0,
      "text": "7.4.36. Example Code",
      "section_title": true,
      "ja": "7.4.36. コード例"
    },
    {
      "indent": 3,
      "text": "The example code presented below demonstrates the usage of the GSSContext interface for the initiating peer. Different operations on the GSSContext object are presented, including: object instantiation, setting of desired flags, context establishment, query of actual context flags, per-message operations on application data, and finally context deletion.",
      "ja": "以下に示すサンプルコードは、開始ピアのGSSContextインターフェースの使用法を示しています。オブジェクトのインスタンス化、必要なフラグの設定、コンテキストの確立、実際のコンテキストフラグのクエリ、アプリケーションデータに対するメッセージごとの操作、最後にコンテキストの削除など、GSSContextオブジェクトに対するさまざまな操作が示されています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nGSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// start by creating the name for a service entity\nGSSName targetName = mgr.createName(\"service@host\",\n                     GSSName.NT_HOSTBASED_SERVICE);\n// create a context using default credentials for the above entity\n// and the implementation-specific default mechanism\nGSSContext context = mgr.createContext(targetName,\n                null,   /* default mechanism */\n                null,   /* default credentials */\n                GSSContext.INDEFINITE_LIFETIME);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// set desired context options - all others are \"false\" by default\ncontext.requestConf(true);\ncontext.requestMutualAuth(true);\ncontext.requestReplayDet(true);\ncontext.requestSequenceDet(true);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// establish a context between peers - using byte arrays\nbyte[] inTok = new byte[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "try {\n    do {\n        byte[] outTok = context.initSecContext(inTok, 0,\n                                              inTok.length);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "// send the token if present\nif (outTok != null)\n    sendToken(outTok);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "// check if we should expect more tokens if (context.isEstablished()) break;",
      "ja": "//（context.isEstablished()）がブレークした場合、さらにトークンが必要かどうかを確認します。"
    },
    {
      "indent": 11,
      "text": "// another token expected from peer\ninTok = readToken();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "} while (true);",
      "ja": "} while（true）;"
    },
    {
      "indent": 3,
      "text": "} catch (GSSException e) {\n    print(\"GSSAPI error: \" + e.getMessage());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// If the exception contains an output token,\n// it should be sent to the acceptor.\nbyte[] outTok = e.getOutputToken();\nif (outTok != null) {\n    sendToken(outTok);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// display context information\nprint(\"Remaining lifetime in seconds = \" + context.getLifetime());\nprint(\"Context mechanism = \" + context.getMech().toString());\nprint(\"Initiator = \" + context.getSrcName().toString());\nprint(\"Acceptor = \" + context.getTargName().toString());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if (context.getConfState()) print(\"Confidentiality security service available\");",
      "ja": "if（context.getConfState()）print（ \"Confidentiality security service available\"）;"
    },
    {
      "indent": 3,
      "text": "if (context.getIntegState()) print(\"Integrity security service available\");",
      "ja": "if（context.getIntegState()）print（ \"Integrity security service available\"）;"
    },
    {
      "indent": 3,
      "text": "// perform wrap on an application-supplied message, appMsg, // using QOP = 0, and requesting privacy service byte[] appMsg ...",
      "ja": "//アプリケーション提供のメッセージappMsgでラップを実行し、// QOP = 0を使用してプライバシーサービスバイト[] appMsgを要求します..."
    },
    {
      "indent": 3,
      "text": "MessageProp mProp = new MessageProp(0, true);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "byte[] tok = context.wrap(appMsg, 0, appMsg.length, mProp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if (mProp.getPrivacy()) print(\"Message protected with privacy.\");",
      "ja": "if（mProp.getPrivacy()）print（ \"プライバシーで保護されたメッセージ\"）;"
    },
    {
      "indent": 3,
      "text": "sendToken(tok);",
      "ja": "sendToken（tok）;"
    },
    {
      "indent": 3,
      "text": "// release the local end of the context\ncontext.dispose();\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5. public class MessageProp",
      "section_title": true,
      "ja": "7.5. パブリッククラスMessageProp"
    },
    {
      "indent": 3,
      "text": "This is a utility class used within the per-message GSSContext methods to convey per-message properties.",
      "ja": "これは、メッセージごとのプロパティを伝えるためにメッセージごとのGSSContextメソッド内で使用されるユーティリティクラスです。"
    },
    {
      "indent": 3,
      "text": "When used with the GSSContext interface's wrap and getMIC methods, an instance of this class is used to indicate the desired QOP and to request if confidentiality services are to be applied to caller-supplied data (wrap only). To request default QOP, the value of 0 should be used for QOP. A QOP is an integer value defined by an mechanism.",
      "ja": "GSSContextインターフェースのwrapメソッドとgetMICメソッドで使用する場合、このクラスのインスタンスを使用して、目的のQOPを示し、呼び出し元が提供するデータに機密性サービスを適用するかどうかを要求します（ラップのみ）。デフォルトのQOPを要求するには、QOPに値0を使用する必要があります。 QOPは、メカニズムによって定義された整数値です。"
    },
    {
      "indent": 3,
      "text": "When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message. In the case of verifyMIC, the confidentiality state will always be \"false\". Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token. The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens, or duplicate tokens.",
      "ja": "GSSContextインターフェースのunwrapおよびverifyMICメソッドで使用される場合、このクラスのインスタンスは、提供されたメッセージに適用されるQOPおよび機密性サービスを示すために使用されます。 verifyMICの場合、機密性の状態は常に「false」になります。これらのメソッドから戻ると、このオブジェクトには、処理されたトークンに適用可能な補足ステータス値も含まれます。補足ステータス値は、古いトークン、順不同トークン、ギャップトークン、または重複トークンを示します。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Constructors",
      "section_title": true,
      "ja": "7.5.1. コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public MessageProp(boolean privState)",
      "ja": "public MessageProp（boolean privState）"
    },
    {
      "indent": 3,
      "text": "Constructor that sets QOP to 0 indicating that the default QOP is requested.",
      "ja": "デフォルトのQOPが要求されていることを示すQOPを0に設定するコンストラクター。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "privState The desired privacy state. \"true\" for privacy and \"false\" for integrity only.",
      "ja": "privState必要なプライバシー状態。プライバシーの場合は「true」、整合性の場合のみ「false」。"
    },
    {
      "indent": 3,
      "text": "public MessageProp(int qop, boolean privState)",
      "ja": "public MessageProp（int qop、boolean privState）"
    },
    {
      "indent": 3,
      "text": "Constructor that sets the values for the QOP and privacy state.",
      "ja": "QOPおよびプライバシー状態の値を設定するコンストラクター。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "qop The desired QOP. Use 0 to request a default QOP.",
      "ja": "qop必要なQOP。デフォルトのQOPを要求するには、0を使用します。"
    },
    {
      "indent": 3,
      "text": "privState The desired privacy state. \"true\" for privacy and \"false\" for integrity only.",
      "ja": "privState必要なプライバシー状態。プライバシーの場合は「true」、整合性の場合のみ「false」。"
    },
    {
      "indent": 0,
      "text": "7.5.2. getQOP",
      "section_title": true,
      "ja": "7.5.2. getQOP"
    },
    {
      "indent": 3,
      "text": "public int getQOP()",
      "ja": "public int getQOP()"
    },
    {
      "indent": 3,
      "text": "Retrieves the QOP value.",
      "ja": "QOP値を取得します。"
    },
    {
      "indent": 0,
      "text": "7.5.3. getPrivacy",
      "section_title": true,
      "ja": "7.5.3. getPrivacy"
    },
    {
      "indent": 3,
      "text": "public boolean getPrivacy()",
      "ja": "パブリックブールgetPrivacy()"
    },
    {
      "indent": 3,
      "text": "Retrieves the privacy state.",
      "ja": "プライバシー状態を取得します。"
    },
    {
      "indent": 0,
      "text": "7.5.4. getMinorStatus",
      "section_title": true,
      "ja": "7.5.4. getMinorStatus"
    },
    {
      "indent": 3,
      "text": "public int getMinorStatus()",
      "ja": "public int getMinorStatus()"
    },
    {
      "indent": 3,
      "text": "Retrieves the minor status that the underlying mechanism might have set.",
      "ja": "基になるメカニズムが設定した可能性のあるマイナーステータスを取得します。"
    },
    {
      "indent": 0,
      "text": "7.5.5. getMinorString",
      "section_title": true,
      "ja": "7.5.5. getMinorString"
    },
    {
      "indent": 3,
      "text": "public String getMinorString()",
      "ja": "パブリック文字列getMinorString()"
    },
    {
      "indent": 3,
      "text": "Returns a string explaining the mechanism-specific error code. \"null\" will be returned when no mechanism error code has been set.",
      "ja": "メカニズム固有のエラーコードを説明する文字列を返します。機構エラーコードが設定されていない場合は「null」を返します。"
    },
    {
      "indent": 0,
      "text": "7.5.6. setQOP",
      "section_title": true,
      "ja": "7.5.6. сетяоп"
    },
    {
      "indent": 3,
      "text": "public void setQOP(int qopVal)",
      "ja": "public void setQOP（int qopVal）"
    },
    {
      "indent": 3,
      "text": "Sets the QOP value.",
      "ja": "QOP値を設定します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "qopVal The QOP value to be set. Use 0 to request a default QOP value.",
      "ja": "qopVal設定するQOP値。デフォルトのQOP値を要求するには、0を使用します。"
    },
    {
      "indent": 0,
      "text": "7.5.7. setPrivacy",
      "section_title": true,
      "ja": "7.5.7. setPrivacy"
    },
    {
      "indent": 3,
      "text": "public void setPrivacy(boolean privState)",
      "ja": "public void setPrivacy（boolean privState）"
    },
    {
      "indent": 3,
      "text": "Sets the privacy state.",
      "ja": "プライバシー状態を設定します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "privState The privacy state to set.",
      "ja": "privState設定するプライバシー状態。"
    },
    {
      "indent": 0,
      "text": "7.5.8. isDuplicateToken",
      "section_title": true,
      "ja": "7.5.8. isDuplicateToken"
    },
    {
      "indent": 3,
      "text": "public boolean isDuplicateToken()",
      "ja": "パブリックブールisDuplicateToken()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if this is a duplicate of an earlier token.",
      "ja": "これが以前のトークンと重複している場合は「true」を返します。"
    },
    {
      "indent": 0,
      "text": "7.5.9. isOldToken",
      "section_title": true,
      "ja": "7.5.9. isOldToken"
    },
    {
      "indent": 3,
      "text": "public boolean isOldToken()",
      "ja": "パブリックブールisOldToken()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if the token's validity period has expired.",
      "ja": "トークンの有効期限が切れている場合は「true」を返します。"
    },
    {
      "indent": 0,
      "text": "7.5.10. isUnseqToken",
      "section_title": true,
      "ja": "7.5.10. いすんせやとけん"
    },
    {
      "indent": 3,
      "text": "public boolean isUnseqToken()",
      "ja": "パブリックブールisUnseqToken()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if a later token has already been processed.",
      "ja": "後のトークンがすでに処理されている場合は「true」を返します。"
    },
    {
      "indent": 0,
      "text": "7.5.11. isGapToken",
      "section_title": true,
      "ja": "7.5.11. isGapToken"
    },
    {
      "indent": 3,
      "text": "public boolean isGapToken()",
      "ja": "パブリックブールisGapToken()"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if an expected per-message token was not received.",
      "ja": "予想されるメッセージごとのトークンが受信されなかった場合、「true」を返します。"
    },
    {
      "indent": 0,
      "text": "7.5.12. setSupplementaryStates",
      "section_title": true,
      "ja": "7.5.12. setSupplementaryStates"
    },
    {
      "indent": 3,
      "text": "public void setSupplementaryStates(boolean duplicate, boolean old, boolean unseq, boolean gap, int minorStatus, String minorString)",
      "ja": "public void setSupplementaryStates（boolean duplicate、boolean old、boolean unseq、boolean gap、int minorStatus、String minorString）"
    },
    {
      "indent": 3,
      "text": "This method sets the state for the supplementary information flags and the minor status in MessageProp. It is not used by the application but by the GSS implementation to return this information to the caller of a per-message context method.",
      "ja": "このメソッドは、補足情報フラグの状態とMessagePropのマイナーステータスを設定します。アプリケーションでは使用されませんが、GSS実装では、メッセージごとのコンテキストメソッドの呼び出し元にこの情報を返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "duplicate \"true\" if the token was a duplicate of an earlier token; otherwise, \"false\".",
      "ja": "トークンが以前のトークンの複製である場合は「true」を複製します。それ以外の場合は「false」。"
    },
    {
      "indent": 3,
      "text": "old \"true\" if the token's validity period has expired; otherwise, \"false\".",
      "ja": "トークンの有効期限が切れている場合は古い「true」。それ以外の場合は「false」。"
    },
    {
      "indent": 3,
      "text": "unseq \"true\" if a later token has already been processed; otherwise, \"false\".",
      "ja": "後のトークンがすでに処理されている場合、unseq \"true\"。それ以外の場合は「false」。"
    },
    {
      "indent": 3,
      "text": "gap \"true\" if one or more predecessor tokens have not yet been successfully processed; otherwise, \"false\".",
      "ja": "1つ以上の先行トークンがまだ正常に処理されていない場合、ギャップは「true」です。それ以外の場合は「false」。"
    },
    {
      "indent": 3,
      "text": "minorStatus The integer minor status code that the underlying mechanism wants to set.",
      "ja": "minorStatus基になるメカニズムが設定する整数のマイナーステータスコード。"
    },
    {
      "indent": 3,
      "text": "minorString The textual representation of the minorStatus value.",
      "ja": "minorString minorStatus値のテキスト表現。"
    },
    {
      "indent": 0,
      "text": "7.6. public class ChannelBinding",
      "section_title": true,
      "ja": "7.6. パブリッククラスChannelBinding"
    },
    {
      "indent": 3,
      "text": "The GSS-API accommodates the concept of caller-provided channel-binding information. Channel bindings are used to strengthen the quality with which peer entity authentication is provided during context establishment. They enable the GSS-API callers to bind the establishment of the security context to relevant characteristics like addresses or to application-specific data.",
      "ja": "GSS-APIは、呼び出し元が提供するチャネルバインディング情報の概念に対応しています。チャネルバインディングは、コンテキストの確立中にピアエンティティ認証が提供される品質を強化するために使用されます。これにより、GSS-APIの呼び出し元は、セキュリティコンテキストの確立を、アドレスなどの関連する特性やアプリケーション固有のデータにバインドできます。"
    },
    {
      "indent": 3,
      "text": "The caller initiating the security context MUST determine the appropriate channel-binding values to set in the GSSContext object. The acceptor MUST provide an identical binding in order to validate that received tokens possess correct channel-related characteristics.",
      "ja": "セキュリティコンテキストを開始する呼び出し元は、GSSContextオブジェクトに設定する適切なチャネルバインディング値を決定する必要があります。アクセプターは、受信したトークンが正しいチャネル関連の特性を持っていることを検証するために、同じバインディングを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of channel bindings is OPTIONAL in GSS-API. Since channel-binding information may be transmitted in context establishment tokens, applications SHOULD therefore not use confidential data as channel-binding components.",
      "ja": "GSS-APIでは、チャネルバインディングの使用はオプションです。チャネルバインディング情報はコンテキスト確立トークンで送信される可能性があるため、アプリケーションはチャネルバインディングコンポーネントとして機密データを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "7.6.1. Constructors",
      "section_title": true,
      "ja": "7.6.1. コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public ChannelBinding(InetAddress initAddr, InetAddress acceptAddr, byte[] appData)",
      "ja": "public ChannelBinding（InetAddress initAddr、InetAddress acceptAddr、byte [] appData）"
    },
    {
      "indent": 3,
      "text": "Create a ChannelBinding object with user-supplied address information and data. \"null\" values can be used for any fields that the application does not want to specify.",
      "ja": "ユーザー提供のアドレス情報とデータを使用してChannelBindingオブジェクトを作成します。 「null」値は、アプリケーションが指定したくないフィールドに使用できます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "initAddr The address of the context initiator. The \"null\" value can be supplied to indicate that the application does not want to set this value.",
      "ja": "initAddrコンテキスト起動側のアドレス。 「null」値を指定して、アプリケーションがこの値を設定したくないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "acceptAddr The address of the context acceptor. The \"null\" value can be supplied to indicate that the application does not want to set this value.",
      "ja": "acceptAddrコンテキスト受け入れ側のアドレス。 「null」値を指定して、アプリケーションがこの値を設定したくないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "appData Application-supplied data to be used as part of the channel bindings. The \"null\" value can be supplied to indicate that the application does not want to set this value.",
      "ja": "appDataチャネルバインディングの一部として使用されるアプリケーション提供のデータ。 「null」値を指定して、アプリケーションがこの値を設定したくないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "public ChannelBinding(byte[] appData)",
      "ja": "public ChannelBinding（byte [] appData）"
    },
    {
      "indent": 3,
      "text": "Creates a ChannelBinding object without any addressing information.",
      "ja": "アドレス指定情報なしでChannelBindingオブジェクトを作成します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "appData Application-supplied data to be used as part of the channel bindings.",
      "ja": "appDataチャネルバインディングの一部として使用されるアプリケーション提供のデータ。"
    },
    {
      "indent": 0,
      "text": "7.6.2. getInitiatorAddress",
      "section_title": true,
      "ja": "7.6.2. getInitiatorAddress"
    },
    {
      "indent": 3,
      "text": "public InetAddress getInitiatorAddress()",
      "ja": "public InetAddress getInitiatorAddress()"
    },
    {
      "indent": 3,
      "text": "Returns the initiator's address for this channel binding. \"null\" is returned if the address has not been set.",
      "ja": "このチャネルバインディングのイニシエーターのアドレスを返します。アドレスが設定されていない場合は「null」が返されます。"
    },
    {
      "indent": 0,
      "text": "7.6.3. getAcceptorAddress",
      "section_title": true,
      "ja": "7.6.3. getAcceptorAddress"
    },
    {
      "indent": 3,
      "text": "public InetAddress getAcceptorAddress()",
      "ja": "public InetAddress getAcceptorAddress()"
    },
    {
      "indent": 3,
      "text": "Returns the acceptor's address for this channel binding. \"null\" is returned if the address has not been set.",
      "ja": "このチャネルバインディングのアクセプターのアドレスを返します。アドレスが設定されていない場合は「null」が返されます。"
    },
    {
      "indent": 0,
      "text": "7.6.4. getApplicationData",
      "section_title": true,
      "ja": "7.6.4. getApplicationData"
    },
    {
      "indent": 3,
      "text": "public byte[] getApplicationData()",
      "ja": "public byte [] getApplicationData()"
    },
    {
      "indent": 3,
      "text": "Returns application data being used as part of the ChannelBinding. \"null\" is returned if no application data has been specified for the channel binding.",
      "ja": "ChannelBindingの一部として使用されているアプリケーションデータを返します。チャネルバインディングにアプリケーションデータが指定されていない場合は、「null」が返されます。"
    },
    {
      "indent": 0,
      "text": "7.6.5. equals",
      "section_title": true,
      "ja": "7.6.5. 等しい"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object obj)",
      "ja": "public boolean equals（Object obj）"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if two channel bindings match. (Note that the Java language specification requires that two objects that are equal according to the equals(Object) method MUST return the same integer result when the hashCode() method is called on them.)",
      "ja": "2つのチャネルバインディングが一致する場合は「true」を返します。 （Java言語仕様では、hashCode()メソッドが呼び出されたときに、equals（Object）メソッドに従って等しい2つのオブジェクトが同じ整数の結果を返す必要があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "obj Another channel binding with which to compare.",
      "ja": "obj比較する別のチャネルバインディング。"
    },
    {
      "indent": 0,
      "text": "7.7. public class Oid",
      "section_title": true,
      "ja": "7.7. パブリッククラスOid"
    },
    {
      "indent": 3,
      "text": "This class represents Universal OIDs and their associated operations.",
      "ja": "このクラスは、ユニバーサルOIDとそれに関連する操作を表します。"
    },
    {
      "indent": 3,
      "text": "OIDs are hierarchically globally interpretable identifiers used within the GSS-API framework to identify mechanisms and name formats.",
      "ja": "OIDは、GSS-APIフレームワーク内でメカニズムと名前の形式を識別するために使用される、階層的にグローバルに解釈可能な識別子です。"
    },
    {
      "indent": 3,
      "text": "The structure and encoding of OIDs is defined in ISOIEC-8824 [ISOIEC-8824] and ISOIEC-8825 [ISOIEC-8825]. For example, the OID representation of the Kerberos v5 mechanism is \"1.2.840.113554.1.2.2\".",
      "ja": "OIDの構造とエンコーディングは、ISOIEC-8824 [ISOIEC-8824]およびISOIEC-8825 [ISOIEC-8825]で定義されています。たとえば、Kerberos v5メカニズムのOID表現は「1.2.840.113554.1.2.2」です。"
    },
    {
      "indent": 3,
      "text": "The GSSName name class contains public static Oid objects representing the standard name types defined in GSS-API.",
      "ja": "GSSName名前クラスには、GSS-APIで定義されている標準の名前タイプを表すパブリック静的Oidオブジェクトが含まれています。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Constructors",
      "section_title": true,
      "ja": "7.7.1. コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public Oid(String strOid) throws GSSException",
      "ja": "public Oid（String strOid）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Creates an Oid object from a string representation of its integer components (e.g., \"1.2.840.113554.1.2.2\").",
      "ja": "整数コンポーネントの文字列表現からOidオブジェクトを作成します（例：「1.2.840.113554.1.2.2」）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "strOid The string representation for the OID.",
      "ja": "strOid OIDの文字列表現。"
    },
    {
      "indent": 3,
      "text": "public Oid(InputStream derOid) throws GSSException",
      "ja": "public Oid（InputStream derOid）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Creates an Oid object from its DER encoding. This refers to the full encoding including tag and length. The structure and encoding of OIDs is defined in ISOIEC-8824 [ISOIEC-8824] and ISOIEC-8825 [ISOIEC-8825]. This method is identical in functionality to its byte array counterpart.",
      "ja": "DERエンコーディングからOidオブジェクトを作成します。これは、タグと長さを含む完全なエンコーディングを指します。 OIDの構造とエンコーディングは、ISOIEC-8824 [ISOIEC-8824]およびISOIEC-8825 [ISOIEC-8825]で定義されています。このメソッドの機能は、対応するバイト配列と同じです。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "derOid Stream containing the DER-encoded OID.",
      "ja": "derOid DERエンコードされたOIDを含むストリーム。"
    },
    {
      "indent": 3,
      "text": "public Oid(byte[] derOid) throws GSSException",
      "ja": "public Oid（byte [] derOid）がGSSExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "Creates an Oid object from its DER encoding. This refers to the full encoding including tag and length. The structure and encoding of OIDs is defined in ISOIEC-8824 [ISOIEC-8824] and ISOIEC-8825 [ISOIEC-8825]. This method is identical in functionality to its byte array counterpart.",
      "ja": "DERエンコーディングからOidオブジェクトを作成します。これは、タグと長さを含む完全なエンコーディングを指します。 OIDの構造とエンコーディングは、ISOIEC-8824 [ISOIEC-8824]およびISOIEC-8825 [ISOIEC-8825]で定義されています。このメソッドの機能は、対応するバイト配列と同じです。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "derOid Byte array storing a DER-encoded OID.",
      "ja": "derOid DERエンコードされたOIDを格納するバイト配列。"
    },
    {
      "indent": 0,
      "text": "7.7.2. toString",
      "section_title": true,
      "ja": "7.7.2. toString"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public String toString()"
    },
    {
      "indent": 3,
      "text": "Returns a string representation of the OID's integer components in dot-separated notation (e.g., \"1.2.840.113554.1.2.2\").",
      "ja": "OIDの整数コンポーネントの文字列表現をドット区切り表記で返します（例：「1.2.840.113554.1.2.2」）。"
    },
    {
      "indent": 0,
      "text": "7.7.3. equals",
      "section_title": true,
      "ja": "7.7.3. 等しい"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object Obj)",
      "ja": "public boolean equals（Object Obj）"
    },
    {
      "indent": 3,
      "text": "Returns \"true\" if the two Oid objects represent the same OID value. (Note that the Java language specification [JLS] requires that two objects that are equal according to the equals(Object) method MUST return the same integer result when the hashCode() method is called on them.)",
      "ja": "2つのOidオブジェクトが同じOID値を表す場合、「true」を返します。 （Java言語仕様[JLS]では、equals（Object）メソッドに従って等しい2つのオブジェクトが、hashCode()メソッドが呼び出されたときに同じ整数の結果を返さなければならないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "obj Another Oid object with which to compare.",
      "ja": "obj比較する別のOidオブジェクト。"
    },
    {
      "indent": 0,
      "text": "7.7.4. getDER",
      "section_title": true,
      "ja": "7.7.4. getDER"
    },
    {
      "indent": 3,
      "text": "public byte[] getDER()",
      "ja": "public byte [] getDER()"
    },
    {
      "indent": 3,
      "text": "Returns the full ASN.1 DER encoding for this Oid object, which includes the tag and length.",
      "ja": "タグと長さを含む、このOidオブジェクトの完全なASN.1 DERエンコーディングを返します。"
    },
    {
      "indent": 0,
      "text": "7.7.5. containedIn",
      "section_title": true,
      "ja": "7.7.5. に含まれます"
    },
    {
      "indent": 3,
      "text": "public boolean containedIn(Oid[] oids)",
      "ja": "public boolean containedIn(Oid[] oids)"
    },
    {
      "indent": 3,
      "text": "A utility method to test if an Oid object is contained within the supplied Oid object array.",
      "ja": "A utility method to test if an Oid object is contained within the supplied Oid object array."
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "oids An array of OIDs to search.",
      "ja": "oids検索するOIDの配列。"
    },
    {
      "indent": 0,
      "text": "7.8. public class GSSException extends Exception",
      "section_title": true,
      "ja": "7.8. パブリッククラスGSSExceptionが例外を拡張しています"
    },
    {
      "indent": 3,
      "text": "This exception is thrown whenever a fatal GSS-API error occurs including mechanism-specific errors. It MAY contain both, the major and minor, GSS-API status codes. The mechanism implementors are responsible for setting appropriate minor status codes when throwing this exception. Aside from delivering the numeric error code(s) to the caller, this class performs the mapping from their numeric values to textual representations. This exception MAY also include an output token that SHOULD be sent to the peer. For example, when an initSecContext call fails due to a fatal error, the mechanism MAY define an error token that SHOULD be sent to the peer for debugging or informational purposes. All Java GSS-API methods are declared throwing this exception.",
      "ja": "This exception is thrown whenever a fatal GSS-API error occurs including mechanism-specific errors. It MAY contain both, the major and minor, GSS-API status codes. The mechanism implementors are responsible for setting appropriate minor status codes when throwing this exception. Aside from delivering the numeric error code(s) to the caller, this class performs the mapping from their numeric values to textual representations. This exception MAY also include an output token that SHOULD be sent to the peer. For example, when an initSecContext call fails due to a fatal error, the mechanism MAY define an error token that SHOULD be sent to the peer for debugging or informational purposes. All Java GSS-API methods are declared throwing this exception."
    },
    {
      "indent": 3,
      "text": "All implementations are encouraged to use the Java internationalization techniques to provide local translations of the message strings.",
      "ja": "すべての実装では、Java国際化手法を使用して、メッセージ文字列のローカル翻訳を提供することが推奨されています。"
    },
    {
      "indent": 0,
      "text": "7.8.1. Static Constants",
      "section_title": true,
      "ja": "7.8.1. 静的定数"
    },
    {
      "indent": 3,
      "text": "All valid major GSS-API error code values are declared as constants in this class.",
      "ja": "すべての有効な主要なGSS-APIエラーコード値は、このクラスで定数として宣言されます。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_BINDINGS",
      "ja": "public static final int BAD_BINDINGS"
    },
    {
      "indent": 3,
      "text": "Channel-bindings mismatch error. The value of this constant is 1.",
      "ja": "Channel-bindings mismatch error. The value of this constant is 1."
    },
    {
      "indent": 3,
      "text": "public static final int BAD_MECH",
      "ja": "public static final int BAD_MECH"
    },
    {
      "indent": 3,
      "text": "Unsupported mechanism requested error. The value of this constant is 2.",
      "ja": "サポートされていないメカニズムがエラーを要求しました。この定数の値は2です。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_NAME",
      "ja": "public static final int BAD_NAME"
    },
    {
      "indent": 3,
      "text": "Invalid name provided error. The value of this constant is 3.",
      "ja": "無効な名前でエラーが発生しました。この定数の値は3です。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_NAMETYPE",
      "ja": "public static final int BAD_NAMETYPE"
    },
    {
      "indent": 3,
      "text": "Name of unsupported type provided error. The value of this constant is 4.",
      "ja": "サポートされていないタイプによって提供されたエラーの名前。この定数の値は4です。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_STATUS",
      "ja": "public static final int BAD_STATUS"
    },
    {
      "indent": 3,
      "text": "Invalid status code error - this is the default status value. The value of this constant is 5.",
      "ja": "無効なステータスコードエラー-これはデフォルトのステータス値です。この定数の値は5です。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_MIC",
      "ja": "public static final int BAD_MIC"
    },
    {
      "indent": 3,
      "text": "Token had invalid integrity check error. The value of this constant is 6.",
      "ja": "トークンに無効な整合性チェックエラーがありました。この定数の値は6です。"
    },
    {
      "indent": 3,
      "text": "public static final int CONTEXT_EXPIRED",
      "ja": "public static final int CONTEXT_EXPIRED"
    },
    {
      "indent": 3,
      "text": "Specified security context expired error. The value of this constant is 7.",
      "ja": "指定されたセキュリティコンテキストの期限切れエラー。この定数の値は7です。"
    },
    {
      "indent": 3,
      "text": "public static final int CREDENTIALS_EXPIRED",
      "ja": "public static final int CREDENTIALS_EXPIRED"
    },
    {
      "indent": 3,
      "text": "Expired credentials detected error. The value of this constant is 8.",
      "ja": "期限切れの資格情報がエラーを検出しました。この定数の値は8です。"
    },
    {
      "indent": 3,
      "text": "public static final int DEFECTIVE_CREDENTIAL",
      "ja": "public static final int DEFECTIVE_CREDENTIAL"
    },
    {
      "indent": 3,
      "text": "Defective credential error. The value of this constant is 9.",
      "ja": "資格情報エラー。この定数の値は9です。"
    },
    {
      "indent": 3,
      "text": "public static final int DEFECTIVE_TOKEN",
      "ja": "public static final int DEFECTIVE_TOKEN"
    },
    {
      "indent": 3,
      "text": "Defective token error. The value of this constant is 10.",
      "ja": "トークンエラー。この定数の値は10です。"
    },
    {
      "indent": 3,
      "text": "public static final int FAILURE",
      "ja": "public static final int FAILURE"
    },
    {
      "indent": 3,
      "text": "General failure, unspecified at GSS-API level. The value of this constant is 11.",
      "ja": "GSS-APIレベルでは特定されていない一般的な障害。この定数の値は11です。"
    },
    {
      "indent": 3,
      "text": "public static final int NO_CONTEXT",
      "ja": "public static final int NO_CONTEXT"
    },
    {
      "indent": 3,
      "text": "Invalid security context error. The value of this constant is 12.",
      "ja": "無効なセキュリティコンテキストエラー。この定数の値は12です。"
    },
    {
      "indent": 3,
      "text": "public static final int NO_CRED",
      "ja": "public static final int NO_CRED"
    },
    {
      "indent": 3,
      "text": "Invalid credentials error. The value of this constant is 13.",
      "ja": "資格情報が無効です。この定数の値は13です。"
    },
    {
      "indent": 3,
      "text": "public static final int BAD_QOP",
      "ja": "public static final int BAD_QOP"
    },
    {
      "indent": 3,
      "text": "Unsupported QOP value error. The value of this constant is 14.",
      "ja": "サポートされていないQOP値エラー。この定数の値は14です。"
    },
    {
      "indent": 3,
      "text": "public static final int UNAUTHORIZED",
      "ja": "public static final int UNAUTHORIZED"
    },
    {
      "indent": 3,
      "text": "Operation unauthorized error. The value of this constant is 15.",
      "ja": "操作不正エラー。この定数の値は15です。"
    },
    {
      "indent": 3,
      "text": "public static final int UNAVAILABLE",
      "ja": "public static final int UNAVAILABLE"
    },
    {
      "indent": 3,
      "text": "Operation unavailable error. The value of this constant is 16.",
      "ja": "操作不可エラー。この定数の値は16です。"
    },
    {
      "indent": 3,
      "text": "public static final int DUPLICATE_ELEMENT",
      "ja": "public static final int DUPLICATE_ELEMENT"
    },
    {
      "indent": 3,
      "text": "Duplicate credential element requested error. The value of this constant is 17.",
      "ja": "Duplicate credential element requested error. The value of this constant is 17."
    },
    {
      "indent": 3,
      "text": "public static final int NAME_NOT_MN",
      "ja": "public static final int NAME_NOT_MN"
    },
    {
      "indent": 3,
      "text": "Name contains multi-mechanism elements error. The value of this constant is 18.",
      "ja": "名前にマルチメカニズム要素エラーが含まれています。この定数の値は18です。"
    },
    {
      "indent": 3,
      "text": "public static final int DUPLICATE_TOKEN",
      "ja": "public static final int DUPLICATE_TOKEN"
    },
    {
      "indent": 3,
      "text": "The token was a duplicate of an earlier token. This is contained in an exception only when detected during context establishment, in which case it is considered a fatal error. (Non-fatal supplementary codes are indicated via the MessageProp object.) The value of this constant is 19.",
      "ja": "The token was a duplicate of an earlier token. This is contained in an exception only when detected during context establishment, in which case it is considered a fatal error. (Non-fatal supplementary codes are indicated via the MessageProp object.) The value of this constant is 19."
    },
    {
      "indent": 3,
      "text": "public static final int OLD_TOKEN",
      "ja": "public static final int OLD_TOKEN"
    },
    {
      "indent": 3,
      "text": "The token's validity period has expired. This is contained in an exception only when detected during context establishment, in which case it is considered a fatal error. (Non-fatal supplementary codes are indicated via the MessageProp object.) The value of this constant is 20.",
      "ja": "トークンの有効期限が切れています。これは、コンテキストの確立中に検出された場合にのみ例外に含まれます。この場合、致命的なエラーと見なされます。 （致命的でない補足コードはMessagePropオブジェクトを介して示されます。）この定数の値は20です。"
    },
    {
      "indent": 3,
      "text": "public static final int UNSEQ_TOKEN",
      "ja": "public static final int UNSEQ_TOKEN"
    },
    {
      "indent": 3,
      "text": "A later token has already been processed. This is contained in an exception only when detected during context establishment, in which case it is considered a fatal error. (Non-fatal supplementary codes are indicated via the MessageProp object.) The value of this constant is 21.",
      "ja": "後のトークンはすでに処理されています。これは、コンテキストの確立中に検出された場合にのみ例外に含まれます。この場合、致命的なエラーと見なされます。 （致命的でない補足コードはMessagePropオブジェクトを介して示されます。）この定数の値は21です。"
    },
    {
      "indent": 3,
      "text": "public static final int GAP_TOKEN",
      "ja": "public static final int GAP_TOKEN"
    },
    {
      "indent": 3,
      "text": "An expected per-message token was not received. This is contained in an exception only when detected during context establishment, in which case it is considered a fatal error. (Non-fatal supplementary codes are indicated via the MessageProp object.) The value of this constant is 22.",
      "ja": "予想されるメッセージごとのトークンが受信されませんでした。これは、コンテキストの確立中に検出された場合にのみ例外に含まれます。この場合、致命的なエラーと見なされます。 （致命的でない補足コードはMessagePropオブジェクトを介して示されます。）この定数の値は22です。"
    },
    {
      "indent": 0,
      "text": "7.8.2. Constructors",
      "section_title": true,
      "ja": "7.8.2. Constructors"
    },
    {
      "indent": 3,
      "text": "public GSSException(int majorCode)",
      "ja": "public GSSException（int majorCode）"
    },
    {
      "indent": 3,
      "text": "Creates a GSSException object with a specified major code.",
      "ja": "指定されたメジャーコードでGSSExceptionオブジェクトを作成します。"
    },
    {
      "indent": 3,
      "text": "Calling this constructor is equivalent to calling GSSException(majorCode, null, 0, null, null).",
      "ja": "このコンストラクタを呼び出すことは、GSSException（majorCode、null、0、null、null）を呼び出すことと同じです。"
    },
    {
      "indent": 3,
      "text": "public GSSException(int majorCode, int minorCode, String minorString)",
      "ja": "パブリックGSSException（int majorCode、int minorCode、String minorString）"
    },
    {
      "indent": 3,
      "text": "Creates a GSSException object with the specified major code, minor code, and minor code textual explanation. This constructor is to be used when the exception is originating from the security mechanism. It allows to specify the GSS code and the mechanism code.",
      "ja": "指定されたメジャーコード、マイナーコード、およびマイナーコードのテキストによる説明でGSSExceptionオブジェクトを作成します。このコンストラクタは、例外がセキュリティメカニズムから発生した場合に使用されます。 GSSコードとメカニズムコードを指定できます。"
    },
    {
      "indent": 3,
      "text": "Calling this constructor is equivalent to calling GSSException(majorCode, null, minorCode, minorString, null).",
      "ja": "このコンストラクタを呼び出すことは、GSSException（majorCode、null、minorCode、minorString、null）を呼び出すことと同じです。"
    },
    {
      "indent": 3,
      "text": "public GSSException(int majorCode, String majorString, int minorCode, String minorString, byte[] outputToken)",
      "ja": "public GSSException（int majorCode、String majorString、int minorCode、String minorString、byte [] outputToken）"
    },
    {
      "indent": 3,
      "text": "Creates a GSSException object with the specified major code, major code textual explanation, minor code, minor code textual explanation, and an output token. This is a general-purpose constructor that can be used to create any type of GSSException.",
      "ja": "指定されたメジャーコード、メジャーコードテキストの説明、マイナーコード、マイナーコードテキストの説明、および出力トークンを使用して、GSSExceptionオブジェクトを作成します。これは、あらゆるタイプのGSSExceptionを作成するために使用できる汎用コンストラクタです。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "majorCode The GSS error code causing this exception to be thrown.",
      "ja": "majorCode The GSS error code causing this exception to be thrown."
    },
    {
      "indent": 3,
      "text": "majorString The textual explanation of the GSS error code. If null is provided, a default explanation that matches the majorCode will be set.",
      "ja": "majorString GSSエラーコードのテキストによる説明。 nullを指定すると、majorCodeに一致するデフォルトの説明が設定されます。"
    },
    {
      "indent": 3,
      "text": "minorCode The mechanism error code causing this exception to be thrown. Can be 0 if no mechanism error code is available.",
      "ja": "minorCodeこの例外をスローする原因となるメカニズムエラーコード。メカニズムエラーコードが利用できない場合は0になります。"
    },
    {
      "indent": 3,
      "text": "minorString The textual explanation of the mechanism error code. Can be null if no textual explanation is available.",
      "ja": "minorStringメカニズムエラーコードのテキストによる説明。テキストによる説明がない場合はnullにできます。"
    },
    {
      "indent": 3,
      "text": "outputToken The output token that SHOULD be sent to the peer. Can be null if no such token is available. It MUST NOT be an empty array. When provided, the array will be cloned to protect against subsequent modifications.",
      "ja": "outputTokenピアに送信する必要がある出力トークン。そのようなトークンが利用できない場合はnullになる可能性があります。空の配列であってはなりません。指定すると、その後の変更から保護するためにアレイが複製されます。"
    },
    {
      "indent": 0,
      "text": "7.8.3. getMajor",
      "section_title": true,
      "ja": "7.8.3. getMajor"
    },
    {
      "indent": 3,
      "text": "public int getMajor()",
      "ja": "public int getMajor()"
    },
    {
      "indent": 3,
      "text": "Returns the major code representing the GSS error code that caused this exception to be thrown.",
      "ja": "この例外がスローされる原因となったGSSエラーコードを表すメジャーコードを返します。"
    },
    {
      "indent": 0,
      "text": "7.8.4. getMinor",
      "section_title": true,
      "ja": "7.8.4. getMinor"
    },
    {
      "indent": 3,
      "text": "public int getMinor()",
      "ja": "public int getMinor()"
    },
    {
      "indent": 3,
      "text": "Returns the mechanism error code that caused this exception. The minor code is set by the underlying mechanism. The value of 0 indicates that the mechanism error code is not set.",
      "ja": "この例外の原因となったメカニズムエラーコードを返します。マイナーコードは、基になるメカニズムによって設定されます。値0は、メカニズムエラーコードが設定されていないことを示します。"
    },
    {
      "indent": 0,
      "text": "7.8.5. getMajorString",
      "section_title": true,
      "ja": "7.8.5. getMajorString"
    },
    {
      "indent": 3,
      "text": "public String getMajorString()",
      "ja": "public String getMajorString()"
    },
    {
      "indent": 3,
      "text": "Returns a string explaining the GSS major error code causing this exception to be thrown.",
      "ja": "この例外がスローされる原因となったGSSメジャーエラーコードを説明する文字列を返します。"
    },
    {
      "indent": 0,
      "text": "7.8.6. getMinorString",
      "section_title": true,
      "ja": "7.8.6. getMinorString"
    },
    {
      "indent": 3,
      "text": "public String getMinorString()",
      "ja": "public String getMinorString()"
    },
    {
      "indent": 3,
      "text": "Returns a string explaining the mechanism-specific error code. \"null\" will be returned when no string explaining the mechanism error code has been set.",
      "ja": "メカニズム固有のエラーコードを説明する文字列を返します。機構エラーコードを説明する文字列が設定されていない場合は「null」を返します。"
    },
    {
      "indent": 0,
      "text": "7.8.7. getOutputToken",
      "section_title": true,
      "ja": "7.8.7. getOutputToken"
    },
    {
      "indent": 3,
      "text": "public byte[] getOutputToken",
      "ja": "public byte [] getOutputToken"
    },
    {
      "indent": 3,
      "text": "Returns the output token in a new byte array.",
      "ja": "出力トークンを新しいバイト配列で返します。"
    },
    {
      "indent": 3,
      "text": "If the method (for example, GSSContext#initSecContext) that throws this GSSException needs to generate an output token that SHOULD be sent to the peer, that token will be stored in this GSSException and can be retrieved with this method.",
      "ja": "このGSSExceptionをスローするメソッド（たとえば、GSSContext＃initSecContext）がピアに送信する必要がある出力トークンを生成する必要がある場合、そのトークンはこのGSSExceptionに格納され、このメソッドで取得できます。"
    },
    {
      "indent": 3,
      "text": "The return value MUST be null if no such token is generated. It MUST NOT be an empty byte array.",
      "ja": "そのようなトークンが生成されない場合、戻り値はnullでなければなりません。空のバイト配列であってはなりません。"
    },
    {
      "indent": 0,
      "text": "7.8.8. setMinor",
      "section_title": true,
      "ja": "7.8.8. setMinor"
    },
    {
      "indent": 3,
      "text": "public void setMinor(int minorCode, String message)",
      "ja": "public void setMinor（int minorCode、String message）"
    },
    {
      "indent": 3,
      "text": "Used internally by the GSS-API implementation and the underlying mechanisms to set the minor code and its textual representation.",
      "ja": "GSS-API実装と基礎となるメカニズムによって内部的に使用され、マイナーコードとそのテキスト表現を設定します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minorCode The mechanism-specific error code.",
      "ja": "minorCodeメカニズム固有のエラーコード。"
    },
    {
      "indent": 3,
      "text": "message A textual explanation of the mechanism error code.",
      "ja": "メッセージメカニズムのエラーコードのテキストによる説明。"
    },
    {
      "indent": 0,
      "text": "7.8.9. toString",
      "section_title": true,
      "ja": "7.8.9. toString"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public String toString()"
    },
    {
      "indent": 3,
      "text": "Returns a textual representation of both the major and minor status codes.",
      "ja": "Returns a textual representation of both the major and minor status codes."
    },
    {
      "indent": 0,
      "text": "7.8.10. getMessage",
      "section_title": true,
      "ja": "7.8.10. getMessage"
    },
    {
      "indent": 3,
      "text": "public String getMessage()",
      "ja": "public String getMessage()"
    },
    {
      "indent": 3,
      "text": "Returns a detailed message of this exception. Overrides Throwable.getMessage. It is customary in Java to use this method to obtain exception information.",
      "ja": "この例外の詳細メッセージを返します。 Throwable.getMessageをオーバーライドします。 Javaでは、このメソッドを使用して例外情報を取得するのが一般的です。"
    },
    {
      "indent": 0,
      "text": "8. Sample Applications",
      "section_title": true,
      "ja": "8. Sample Applications"
    },
    {
      "indent": 0,
      "text": "8.1. Simple GSS Context Initiator",
      "section_title": true,
      "ja": "8.1. シンプルなGSSコンテキストイニシエーター"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nimport org.ietf.jgss.*;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/**\n * This is a partial sketch for a simple client program that acts\n * as a GSS context initiator.  It illustrates how to use the Java\n * bindings for the GSS-API specified in RFC 8353.\n *\n *\n * This code sketch assumes the existence of a GSS-API\n * implementation that supports the mechanism that it will need\n * and is present as a library package (org.ietf.jgss) either as\n * part of the standard JRE or in the CLASSPATH the application\n * specifies.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "public class SimpleClient {",
      "ja": "公開クラスSimpleClient {"
    },
    {
      "indent": 8,
      "text": "private String serviceName; // name of peer (i.e., server)\nprivate GSSCredential clientCred = null;\nprivate GSSContext context = null;\nprivate Oid mech; // underlying mechanism to use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "private GSSManager mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "... ...",
      "ja": "。。。 。。。"
    },
    {
      "indent": 8,
      "text": "private void clientActions() {\n   initializeGSS();\n   establishContext();\n   doCommunication();\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * Acquire credentials for the client.\n */\nprivate void initializeGSS() {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "try {",
      "ja": "{を試す"
    },
    {
      "indent": 0,
      "text": "               clientCred = mgr.createCredential(null /*default princ*/,\n                   GSSCredential.INDEFINITE_LIFETIME /* max lifetime */,\n                   mech /* mechanism to use */,\n                   GSSCredential.INITIATE_ONLY /* init context */);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        print(\"GSSCredential created for \" +\n              clientCred.getName().toString());\n        print(\"Credential lifetime (sec)=\" +\n              clientCred.getRemainingLifetime());\n    } catch (GSSException e) {\n        print(\"GSS-API error in credential acquisition: \"\n              + e.getMessage());\n        ...\n        ...\n    }\n    ...\n    ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * Does the security context establishment with the\n * server.\n */\nprivate void establishContext() {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "byte[] inToken = new byte[0];\nbyte[] outToken = null;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "try {",
      "ja": "{を試す"
    },
    {
      "indent": 15,
      "text": "GSSName peer = mgr.createName(serviceName,\n                      GSSName.NT_HOSTBASED_SERVICE);\ncontext = mgr.createContext(peer, mech, clientCred,\n       GSSContext.INDEFINITE_LIFETIME/*lifetime*/);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "// Will need to support confidentiality\ncontext.requestConf(true);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "while (!context.isEstablished()) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "outToken = context.initSecContext(inToken, 0, inToken.length);",
      "ja": "outToken = context.initSecContext（inToken、0、inToken.length）;"
    },
    {
      "indent": 19,
      "text": "if (outToken != null)\n    writeGSSToken(outToken);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "    if (!context.isEstablished())\n        inToken = readGSSToken();\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "peer = context.getTargName();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    print(\"Security context established with \" + peer +\n          \" using underlying mechanism \" + mech.toString());\n} catch (GSSException e) {\n     print(\"GSS-API error during context establishment: \"\n           + e.getMessage());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "         // If the exception contains an output token,\n         // it should be sent to the acceptor.\n         byte[] outTok = e.getOutputToken();\n         if (outTok != null) {\n             writeGSSToken(outTok);\n         }\n         ...\n         ...\n    }\n    ...\n    ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * Sends some data to the server and reads back the\n * response.\n */\nprivate void doCommunication()  {\n    byte[] inToken = null;\n    byte[] outToken = null;\n    byte[] buffer;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "// Container for multiple input-output arguments to and\n// from the per-message routines (e.g., wrap/unwrap).\nMessageProp messgInfo = new MessageProp(true);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "try {",
      "ja": "{を試す"
    },
    {
      "indent": 15,
      "text": "/*\n * Now send some bytes to the server to be\n * processed.  They will be integrity protected\n * but not encrypted for privacy.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "buffer = readFromFile();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "// Set privacy to \"false\" and use the default QOP\nmessgInfo.setPrivacy(false);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "outToken = context.wrap(buffer, 0, buffer.length, messgInfo);",
      "ja": "outToken = context.wrap（buffer、0、buffer.length、messgInfo）;"
    },
    {
      "indent": 15,
      "text": "writeGSSToken(outToken);",
      "ja": "writeGSSToken（outToken）;"
    },
    {
      "indent": 15,
      "text": "/*\n * Now read the response from the server.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "inToken = readGSSToken();\nbuffer = context.unwrap(inToken, 0,\n              inToken.length, messgInfo);\n// All ok if no exception was thrown!",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "GSSName peer = context.getTargName();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        print(\"Message from \"  + peer.toString()\n              + \" arrived.\");\n        print(\"Was it encrypted? \"  +\n              messgInfo.getPrivacy());\n        print(\"Duplicate Token? \"   +\n              messgInfo.isDuplicateToken());\n        print(\"Old Token? \"         +\n              messgInfo.isOldToken());\n        print(\"Unsequenced Token? \" +\n              messgInfo.isUnseqToken());\n        print(\"Gap Token? \"         +\n              messgInfo.isGapToken());\n        ...\n        ...\n    } catch (GSSException e) {\n        print(\"GSS-API error in per-message calls: \"\n              + e.getMessage());\n        ...\n        ...\n    }\n    ...\n    ...\n} // end of doCommunication method",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "... ...",
      "ja": "。。。 。。。"
    },
    {
      "indent": 3,
      "text": "} // end of class SimpleClient\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Simple GSS Context Acceptor",
      "section_title": true,
      "ja": "8.2. 単純なGSSコンテキストアクセプター"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nimport org.ietf.jgss.*;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/**\n * This is a partial sketch for a simple server program that acts\n * as a GSS context acceptor.  It illustrates how to use the Java\n * bindings for the GSS-API specified in\n * Generic Security Service API Version 2 : Java Bindings.\n *\n * This code sketch assumes the existence of a GSS-API\n * implementation that supports the mechanisms that it will need\n * and is present as a library package (org.ietf.jgss) either as\n * part of the standard JRE or in the CLASSPATH the application\n * specifies.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "import org.ietf.jgss.*;",
      "ja": "import org.ietf.jgss。*;"
    },
    {
      "indent": 3,
      "text": "public class SimpleServer {",
      "ja": "パブリッククラスSimpleServer {"
    },
    {
      "indent": 7,
      "text": "private String serviceName;\nprivate GSSName name;\nprivate GSSCredential cred;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "private GSSManager mgr;",
      "ja": "プライベートGSSManagerマネージャー。"
    },
    {
      "indent": 7,
      "text": "... ...",
      "ja": "... ..."
    },
    {
      "indent": 7,
      "text": "/**\n * Wait for client connections, establish security contexts,\n * and provide service.\n */\nprivate void loop() throws Exception {\n    ...\n    ...\n    mgr = GSSManager.getInstance();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "name = mgr.createName(serviceName, GSSName.NT_HOSTBASED_SERVICE);",
      "ja": "name = mgr.createName(serviceName, GSSName.NT_HOSTBASED_SERVICE);"
    },
    {
      "indent": 11,
      "text": "cred = mgr.createCredential(name, GSSCredential.INDEFINITE_LIFETIME, (Oid[])null, GSSCredential.ACCEPT_ONLY);",
      "ja": "cred = mgr.createCredential（name、GSSCredential.INDEFINITE_LIFETIME、（Oid []）null、GSSCredential.ACCEPT_ONLY）;"
    },
    {
      "indent": 11,
      "text": "// Loop infinitely\nwhile (true) {\n    Socket s = serverSock.accept();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        // Start a new thread to serve this connection\n        Thread serverThread = new ServerThread(s);\n        serverThread.start();\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * Inner class ServerThread whose run() method provides the\n * secure service to a connection.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "private class ServerThread extends Thread {",
      "ja": "プライベートクラスServerThreadはスレッド{"
    },
    {
      "indent": 11,
      "text": "... ...",
      "ja": "。。。 。。。"
    },
    {
      "indent": 11,
      "text": "/**\n * Deals with the connection from one client.  It also\n * handles all GSSException's thrown while talking to\n * this client.\n */\npublic void run() {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "byte[] inToken = null;\nbyte[] outToken = null;\nbyte[] buffer;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "// Container for multiple input-output arguments to\n// and from the per-message routines\n// (i.e., wrap/unwrap).\nMessageProp supplInfo = new MessageProp(true);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "try {\n    // Now do the context establishment loop\n    GSSContext context = mgr.createContext(cred);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "while (!context.isEstablished()) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "inToken = readGSSToken();\noutToken = context.acceptSecContext(inToken,\n                         0, inToken.length);\nif (outToken != null)\n    writeGSSToken(outToken);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 19,
      "text": "// SimpleServer wants confidentiality to be\n// available.  Check for it.\nif (!context.getConfState()){\n    ...\n    ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "GSSName peer = context.getSrcName();\nOid mech = context.getMech();\nprint(\"Security context established with \" +\n       peer.toString() +\n      \" using underlying mechanism \" +\n      mech.toString());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Now read the bytes sent by the client to be\n// processed.\ninToken = readGSSToken();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Unwrap the message\nbuffer = context.unwrap(inToken, 0,\n            inToken.length, supplInfo);\n// All ok if no exception was thrown!",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Print other supplementary per-message status // information.",
      "ja": "//他の補足的なメッセージごとのステータス情報を//表示します。"
    },
    {
      "indent": 19,
      "text": "print(\"Message from \" +\n        peer.toString() + \" arrived.\");\nprint(\"Was it encrypted? \" +\n        supplInfo.getPrivacy());\nprint(\"Duplicate Token? \" +\n        supplInfo.isDuplicateToken());\nprint(\"Old Token? \"  + supplInfo.isOldToken());\nprint(\"Unsequenced Token? \" +\n        supplInfo.isUnseqToken());\nprint(\"Gap Token? \"  + supplInfo.isGapToken());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "/*\n * Now process the bytes and send back an\n * encrypted response.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "buffer = serverProcess(buffer);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encipher it and send it across",
      "ja": "//暗号化して送信します"
    },
    {
      "indent": 19,
      "text": "supplInfo.setPrivacy(true); // privacy requested\nsupplInfo.setQOP(0); // default QOP\noutToken = context.wrap(buffer, 0, buffer.length,\n                           supplInfo);\nwriteGSSToken(outToken);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "} catch (GSSException e) {\n    print(\"GSS-API Error: \" + e.getMessage());\n    // Alternatively, could call e.getMajorMessage()\n    // and e.getMinorMessage()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "        // If the exception contains an output token,\n        // it should be sent to the initiator.\n        byte[] outTok = e.getOutputToken();\n        if (outTok != null) {\n            writeGSSToken(outTok);\n        }\n        print(\"Abandoning security context.\");\n        ...\n        ...\n    }\n    ...\n    ...\n} // end of run method in ServerThread",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "} // end of inner class ServerThread",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "... ...",
      "ja": "。。。 。。。"
    },
    {
      "indent": 3,
      "text": "} // end of class SimpleServer\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The Java language security model allows platform providers to have policy-based fine-grained access control over any resource that an application wants. When using a Java security manager (such as, but not limited to, the case of applets running in browsers), the application code is in a sandbox by default.",
      "ja": "Java言語のセキュリティモデルにより、プラットフォームプロバイダーは、アプリケーションが必要とするすべてのリソースに対して、ポリシーベースのきめ細かいアクセス制御を行うことができます。 Javaセキュリティーマネージャー（ブラウザーで実行されているアプレットの場合など）を使用する場合、アプリケーションコードはデフォルトでサンドボックスにあります。"
    },
    {
      "indent": 0,
      "text": " Administrators of the platform JRE determine what permissions, if any, are to be given to source from different codebases. Thus, the administrator has to be aware of any special requirements that the GSS provider might have for system resources. For instance, a Kerberos provider might wish to make a network connection to the Key Distribution Center (KDC) to obtain initial credentials. This would not be allowed under the sandbox unless the administrator had granted permissions for this. Also, note that this granting and checking of permissions happens transparently to the application and is outside the scope of this document.",
      "ja": " Administrators of the platform JRE determine what permissions, if any, are to be given to source from different codebases. Thus, the administrator has to be aware of any special requirements that the GSS provider might have for system resources. For instance, a Kerberos provider might wish to make a network connection to the Key Distribution Center (KDC) to obtain initial credentials. This would not be allowed under the sandbox unless the administrator had granted permissions for this. Also, note that this granting and checking of permissions happens transparently to the application and is outside the scope of this document."
    },
    {
      "indent": 3,
      "text": "The Java language allows administrators to pre-configure a list of security service providers in the <JRE>/lib/security/java.security file. At runtime, the system approaches these providers in order of preference when looking for security-related services. Applications have a means to modify this list through methods in the \"Security\" class in the \"java.security\" package. However, since these modifications would be visible in the entire Java Virtual Machine (JVM) and thus affect all code executing in it, this operation is not available in the sandbox and requires special permissions to perform. Thus, when a GSS application has special needs that are met by a particular security provider, it has two choices:",
      "ja": "Java言語を使用すると、管理者は<JRE> /lib/security/java.securityファイルでセキュリティサービスプロバイダーのリストを事前設定できます。実行時に、セキュリティ関連のサービスを探すときに、システムはこれらのプロバイダーに優先順にアプローチします。アプリケーションには、「java.security」パッケージの「Security」クラスのメソッドを介してこのリストを変更する手段があります。ただし、これらの変更はJava仮想マシン（JVM）全体に表示され、そこで実行されるすべてのコードに影響するため、この操作はサンドボックスでは使用できず、実行するには特別な権限が必要です。したがって、GSSアプリケーションに特定のセキュリティプロバイダーが満たす特別なニーズがある場合、次の2つの選択肢があります。"
    },
    {
      "indent": 3,
      "text": "1) Install the provider on a JVM-wide basis using the java.security.Security class and then depend on the system to find the right provider automatically when the need arises. (This would require the application to be granted a \"insertProvider SecurityPermission\".)",
      "ja": "1）java.security.Securityクラスを使用してJVM全体にプロバイダーをインストールし、システムに依存して、必要に応じて適切なプロバイダーを自動的に見つけます。 （これには、アプリケーションに「insertProvider SecurityPermission」が付与されている必要があります。）"
    },
    {
      "indent": 3,
      "text": "2) Pass an instance of the provider to the local instance of GSSManager so that only factory calls going through that GSSManager use the desired provider. (This would not require any permissions.)",
      "ja": "2）プロバイダのインスタンスをGSSManagerのローカルインスタンスに渡して、GSSManagerを通過するファクトリコールのみが目的のプロバイダを使用するようにします。 （これには権限は必要ありません。）"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "11. Changes since RFC 5653",
      "section_title": true,
      "ja": "11. RFC 5653以降の変更"
    },
    {
      "indent": 3,
      "text": "This document has following changes:",
      "ja": "このドキュメントには、次の変更点があります。"
    },
    {
      "indent": 3,
      "text": "1) New error token embedded in GSSException",
      "ja": "1）GSSExceptionに埋め込まれた新しいエラートークン"
    },
    {
      "indent": 6,
      "text": "There is a design flaw in the initSecContext and acceptSecContext methods of the GSSContext class defined in \"Generic Security Service API Version 2: Java Bindings Update\" [RFC5653].",
      "ja": "「Generic Security Service API Version 2：Java Bindings Update」[RFC5653]で定義されているGSSContextクラスのinitSecContextメソッドとacceptSecContextメソッドに設計上の欠陥があります。"
    },
    {
      "indent": 0,
      "text": " The methods could either return a token (possibly null if no more tokens are needed) when the call succeeds or throw a GSSException if there is a failure, but NOT both. On the other hand, the C-bindings of GSS-API [RFC2744] can return both; that is to say, a call to the GSS_Init_sec_context() function can return a major status code, and at the same time, fill in the output_token argument if there is one.",
      "ja": "メソッドは、呼び出しが成功したときにトークン（トークンが不要な場合はnull）を返すか、失敗した場合はGSSExceptionをスローしますが、両方を返すことはできません。一方、GSS-API [RFC2744]のCバインディングは両方を返すことができます。つまり、GSS_Init_sec_context()関数を呼び出すと、メジャーステータスコードが返されると同時に、output_token引数が存在する場合はそれを入力します。"
    },
    {
      "indent": 6,
      "text": "Without the ability to emit an error token when there is a failure, a Java application has no mechanism to tell the other side what the error is. For example, a \"reject\" NegTokenResp token can never be transmitted for the SPNEGO mechanism [RFC4178].",
      "ja": "障害が発生したときにエラートークンを発行する機能がないと、Javaアプリケーションには、エラーが何であるかを相手側に通知するメカニズムがありません。たとえば、SPNEGOメカニズム[RFC4178]では、「拒否」NegTokenRespトークンを送信することはできません。"
    },
    {
      "indent": 6,
      "text": "While a Java method can never return a value and throw an exception at the same time, we can embed the error token inside the exception so that the caller has a chance to retrieve it. This update adds a new GSSException constructor to include this token inside a GSSException object and a getOutputToken() method to retrieve the token. The specification for the initSecContext and acceptSecContext methods are updated to describe the new behavior. Various examples are also updated.",
      "ja": "Javaメソッドは決して値を返さず、同時に例外をスローすることはできませんが、エラートークンを例外内に埋め込んで、呼び出し元が値を取得できるようにすることができます。このアップデートでは、GSSExceptionオブジェクト内にこのトークンを含めるための新しいGSSExceptionコンストラクタと、トークンを取得するためのgetOutputToken()メソッドが追加されています。 initSecContextメソッドとacceptSecContextメソッドの仕様が更新され、新しい動作が説明されています。さまざまな例も更新されます。"
    },
    {
      "indent": 6,
      "text": "New JGSS programs SHOULD make use of this new feature, but it is not mandatory. A program that intends to run with both old and new GSS Java bindings can use reflection to check the availability of this new method and call it accordingly.",
      "ja": "新しいJGSSプログラムはこの新機能を使用する必要があります（SHOULD）が、これは必須ではありません。新旧両方のGSS Javaバインディングで実行する予定のプログラムは、リフレクションを使用して、この新しいメソッドの可用性を確認し、それに応じて呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "2) Removing Stream-Based GSSContext Methods",
      "ja": "2）ストリームベースのGSSContextメソッドの削除"
    },
    {
      "indent": 6,
      "text": "The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 [RFC5653] are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library). These methods include initSecContext (Section 7.4.5 of RFC 5653 [RFC5653]), acceptSecContext (Section 7.4.9 of RFC 5653 [RFC5653]), wrap (Section 7.4.15 of RFC 5653 [RFC5653]), unwrap (Section 7.4.17 of RFC 5653 [RFC5653]), getMIC (Section 7.4.19 of RFC 5653 [RFC5653]), and verifyMIC (Section 7.4.21 of RFC 5653 [RFC5653]).",
      "ja": "RFC 5653 [RFC5653]のセクション5.15で説明されているように、認証とメッセージごとのGSS-APIトークンを伝達する手段として入力ストリームと出力ストリームを使用するGSSContextのオーバーロードメソッドは、ワイヤープロトコルがライブラリではなくアプリケーション。トークンに自己フレーミングがない場合（終了を判別できない場合）、またはライブラリにトークン形式の知識がない場合（たとえば、別のGSSライブラリと通信するブリッジとして）、これらのメソッドを正しく実装することも不可能です。これらのメソッドには、initSecContext（RFC 5653 [RFC5653]のセクション7.4.5）、acceptSecContext（RFC 5653 [RFC5653]のセクション7.4.9）、wrap（RFC 5653 [RFC5653]のセクション7.4.15）、unwrap（セクション7.4。 RFC 5653 [RFC5653]の17）、getMIC（RFC 5653 [RFC5653]のセクション7.4.19））、およびverifyMIC（RFC 5653 [RFC5653]のセクション7.4.21）。"
    },
    {
      "indent": 0,
      "text": "12. Changes since RFC 2853",
      "section_title": true,
      "ja": "12. RFC 2853以降の変更"
    },
    {
      "indent": 3,
      "text": "This document has the following changes:",
      "ja": "このドキュメントには、次の変更点があります。"
    },
    {
      "indent": 3,
      "text": "1) Major GSS Status Code Constant Values",
      "ja": "1）主要なGSSステータスコードの定数値"
    },
    {
      "indent": 6,
      "text": "RFC 2853 listed all the GSS status code values in two different sections: Section 4.12.1 defined numeric values for them, and Section 6.8.1 defined them as static constants in the GSSException class without assigning any values. Due to an inconsistent ordering between these two sections, all of the GSS major status codes resulted in misalignment and a subsequent disagreement between deployed implementations.",
      "ja": "RFC 2853では、すべてのGSSステータスコード値を2つのセクションにリストしました。セクション4.12.1はそれらの数値を定義し、セクション6.8.1は値を割り当てずにGSSExceptionクラスの静的定数として定義しました。これら2つのセクション間の順序に一貫性がないため、GSSの主要なステータスコードはすべて、配置された実装間で不整合とその後の不一致をもたらしました。"
    },
    {
      "indent": 6,
      "text": "This document defines the numeric values of the GSS status codes in both sections, while maintaining the original ordering from Section 6.8.1 of RFC 2853 [RFC2853], and it obsoletes the GSS status code values defined in Section 4.12.1. The relevant sections in this document are Sections 5.12.1 and 7.8.1.",
      "ja": "このドキュメントでは、RFC 2853 [RFC2853]のセクション6.8.1からの元の順序を維持しながら、両方のセクションでGSSステータスコードの数値を定義し、セクション4.12.1で定義されたGSSステータスコード値を廃止します。このドキュメントの関連セクションは、セクション5.12.1および7.8.1です。"
    },
    {
      "indent": 3,
      "text": "2) GSS Credential Usage Constant Values",
      "ja": "2）GSS資格情報使用定数値"
    },
    {
      "indent": 6,
      "text": "RFC 2853, Section 6.3.2 defines static constants for the GSSCredential usage flags. However, the values of these constants were not defined anywhere in RFC 2853 [RFC2853].",
      "ja": "RFC 2853、セクション6.3.2では、GSSCredential使用フラグの静的定数を定義しています。ただし、これらの定数の値はRFC 2853 [RFC2853]のどこにも定義されていません。"
    },
    {
      "indent": 6,
      "text": "This document defines the credential usage values in Section 7.3.1. The original ordering of these values from Section 6.3.2 of RFC 2853 [RFC2853] is maintained.",
      "ja": "このドキュメントでは、セクション7.3.1の資格情報の使用法の値を定義しています。 RFC 2853 [RFC2853]のセクション6.3.2からのこれらの値の元の順序は維持されます。"
    },
    {
      "indent": 3,
      "text": "3) GSS Host-Based Service Name",
      "ja": "3）GSSホストベースのサービス名"
    },
    {
      "indent": 6,
      "text": "RFC 2853 [RFC2853], Section 6.2.2 defines the static constant for the GSS host-based service OID NT_HOSTBASED_SERVICE, using a deprecated OID value.",
      "ja": "RFC 2853 [RFC2853]のセクション6.2.2では、非推奨のOID値を使用して、GSSホストベースのサービスOID NT_HOSTBASED_SERVICEの静的定数を定義しています。"
    },
    {
      "indent": 6,
      "text": "This document updates the NT_HOSTBASED_SERVICE OID value in Section 7.2.1 to be consistent with the C-bindings in RFC 2744 [RFC2744].",
      "ja": "このドキュメントは、RFC 2744 [RFC2744]のCバインディングと一致するように、セクション7.2.1のNT_HOSTBASED_SERVICE OID値を更新します。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2025] Adams, C., \"The Simple Public-Key GSS-API Mechanism (SPKM)\", RFC 2025, DOI 10.17487/RFC2025, October 1996, <https://www.rfc-editor.org/info/rfc2025>.",
      "ja": "[RFC2025] Adams、C。、「The Simple Public-Key GSS-API Mechanism（SPKM）」、RFC 2025、DOI 10.17487 / RFC2025、1996年10月、<https://www.rfc-editor.org/info/rfc2025 >。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <https://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[RFC2743] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<https://www.rfc-editor.org/info/rfc2743> 。"
    },
    {
      "indent": 3,
      "text": "[RFC2744] Wray, J., \"Generic Security Service API Version 2 : C-bindings\", RFC 2744, DOI 10.17487/RFC2744, January 2000, <https://www.rfc-editor.org/info/rfc2744>.",
      "ja": "[RFC2744] Wray、J。、「Generic Security Service API Version 2：C-bindings」、RFC 2744、DOI 10.17487 / RFC2744、2000年1月、<https://www.rfc-editor.org/info/rfc2744>。"
    },
    {
      "indent": 3,
      "text": "[RFC2853] Kabat, J. and M. Upadhyay, \"Generic Security Service API Version 2 : Java Bindings\", RFC 2853, DOI 10.17487/RFC2853, June 2000, <https://www.rfc-editor.org/info/rfc2853>.",
      "ja": "[RFC2853] Kabat、J。およびM. Upadhyay、「Generic Security Service API Version 2：Java Bindings」、RFC 2853、DOI 10.17487 / RFC2853、2000年6月、<https://www.rfc-editor.org/info/ rfc2853>。"
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, DOI 10.17487/RFC4121, July 2005, <https://www.rfc-editor.org/info/rfc4121>.",
      "ja": "[RFC4121] Zhu、L.、Jaganathan、K。、およびS. Hartman、「The Kerberos Version 5 Generic Security Service Application Program Interface（GSS-API）Mechanism：Version 2」、RFC 4121、DOI 10.17487 / RFC4121、2005年7月、<https://www.rfc-editor.org/info/rfc4121>。"
    },
    {
      "indent": 3,
      "text": "[RFC4178] Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, \"The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism\", RFC 4178, DOI 10.17487/RFC4178, October 2005, <https://www.rfc-editor.org/info/rfc4178>.",
      "ja": "[RFC4178] Zhu、L.、Leach、P.、Jaganathan、K。、およびW. Ingersoll、「The Simple and Protected Generic Security Service Application Program Interface（GSS-API）Negotiation Mechanism」、RFC 4178、DOI 10.17487 / RFC4178 、2005年10月、<https://www.rfc-editor.org/info/rfc4178>。"
    },
    {
      "indent": 3,
      "text": "[RFC5653] Upadhyay, M. and S. Malkani, \"Generic Security Service API Version 2: Java Bindings Update\", RFC 5653, DOI 10.17487/RFC5653, August 2009, <https://www.rfc-editor.org/info/rfc5653>.",
      "ja": "[RFC5653] Upadhyay、M。およびS. Malkani、「Generic Security Service API Version 2：Java Bindings Update」、RFC 5653、DOI 10.17487 / RFC5653、2009年8月、<https://www.rfc-editor.org/info / rfc5653>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ISOIEC-8824] International Organization for Standardization, \"Information technology -- Abstract Syntax Notation One (ASN.1): Specification of basic notation\", ISO/ IEC 8824-1:2014, November 2015, <https://www.iso.org/standard/68350.html>.",
      "ja": "[ISOIEC-8824]国際標準化機構、「情報技術-抽象構文記法1（ASN.1）：基本記法の仕様」、ISO / IEC 8824-1：2014、2015年11月、<https：// www。 iso.org/standard/68350.html>。"
    },
    {
      "indent": 3,
      "text": "[ISOIEC-8825] International Organization for Standardization, \"Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ISO/IEC 8825-1:2015, November 2015, <https://www.iso.org/standard/68345.html>.",
      "ja": "[ISOIEC-8825]国際標準化機構、「情報技術-ASN.1エンコーディングルール：基本エンコーディングルール（BER）、正規エンコーディングルール（CER）およびDistinguished Encodingルール（DER）の仕様」、ISO / IEC 8825- 1：2015、2015年11月、<https://www.iso.org/standard/68345.html>。"
    },
    {
      "indent": 3,
      "text": "[JLS] Gosling, J., Joy, B., Steele, G., Bracha, G., Buckley, A., and D. Smith, \"The Java Language Specification\", Java SE 10 Edition, February 2018, <https://docs.oracle.com/javase/specs/jls/se10/html/ index.html>.",
      "ja": "[JLS]ゴスリング、J。、ジョイ、B。、スティール、G。、ブラチャ、G。、バックリー、A。、およびD.スミス、「Java言語仕様」、Java SE 10 Edition、2018年2月、<https ：//docs.oracle.com/javase/specs/jls/se10/html/ index.html>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Mike Eisler, Lin Ling, Ram Marti, Michael Saltz, and other members of Sun's development team for their helpful input, comments, and suggestions.",
      "ja": "Mike Eisler、Lin Ling、Ram Marti、Michael Saltz、およびSunの開発チームの他のメンバーの有益な情報、コメント、提案に感謝します。"
    },
    {
      "indent": 3,
      "text": "We would also like to thank Greg Hudson, Benjamin Kaduk, Joe Salowey and Michael Smith for many insightful ideas and suggestions that have contributed to this document.",
      "ja": "このドキュメントに貢献してくれた多くの洞察に満ちたアイデアや提案を提供してくれたGreg Hudson、Benjamin Kaduk、Joe Salowey、Michael Smithにも感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mayank D. Upadhyay Google Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States of America",
      "ja": "Mayank D. Upadhyay Google Inc. 1600 Amphitheatre Parkway Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: m.d.upadhyay+ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Seema Malkani ActivIdentity Corp. 6623 Dumbarton Circle Fremont, California 94555 United States of America",
      "ja": "Seema Malkani ActivIdentity Corp. 6623ダンバートンサークルフリーモント、カリフォルニア94555アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: Seema.Malkani@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Weijun Wang Oracle Building No. 24, Zhongguancun Software Park Beijing 100193 China",
      "ja": "Weijun Wang Oracleビル24、Zマクロインチソフトウェアパーク北京100193中国"
    },
    {
      "indent": 3,
      "text": "Email: weijun.wang@oracle.com",
      "raw": true,
      "ja": ""
    }
  ]
}