{
  "title": {
    "text": "RFC 8257 - Data Center TCP (DCTCP): TCP Congestion Control for Data Centers",
    "ja": "RFC 8257 - データセンターTCP（DCTCP）：データセンターのTCP輻輳制御"
  },
  "number": 8257,
  "created_at": "2020-08-25 18:24:56.320057+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        S. Bensley\nRequest for Comments: 8257                                     D. Thaler\nCategory: Informational                               P. Balasubramanian\nISSN: 2070-1721                                                Microsoft\n                                                               L. Eggert\n                                                                  NetApp\n                                                                 G. Judd\n                                                          Morgan Stanley\n                                                            October 2017",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Data Center TCP (DCTCP): TCP Congestion Control for Data Centers",
      "ja": "データセンターTCP（DCTCP）：データセンターのTCP輻輳制御"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This Informational RFC describes Data Center TCP (DCTCP): a TCP congestion control scheme for data-center traffic. DCTCP extends the Explicit Congestion Notification (ECN) processing to estimate the fraction of bytes that encounter congestion rather than simply detecting that some congestion has occurred. DCTCP then scales the TCP congestion window based on this estimate. This method achieves high-burst tolerance, low latency, and high throughput with shallow-buffered switches. This memo also discusses deployment issues related to the coexistence of DCTCP and conventional TCP, discusses the lack of a negotiating mechanism between sender and receiver, and presents some possible mitigations. This memo documents DCTCP as currently implemented by several major operating systems. DCTCP, as described in this specification, is applicable to deployments in controlled environments like data centers, but it must not be deployed over the public Internet without additional measures.",
      "ja": "この情報RFCは、データセンターTCP（DCTCP）について説明しています。データセンタートラフィックのTCP輻輳制御方式です。 DCTCPは、明示的輻輳通知（ECN）処理を拡張して、単に輻輳が発生したことを検出するのではなく、輻輳が発生したバイトの割合を推定します。次に、DCTCPはこの推定に基づいてTCP輻輳ウィンドウをスケーリングします。この方法は、浅いバッファのスイッチで高バースト耐性、低遅延、高スループットを実現します。このメモでは、DCTCPと従来のTCPの共存に関連する展開の問題についても説明し、送信側と受信側の間のネゴシエーションメカニズムの欠如について説明し、いくつかの可能な軽減策を示します。このメモは、いくつかの主要なオペレーティングシステムによって現在実装されているDCTCPについて説明しています。この仕様で説明されているように、DCTCPはデータセンターなどの制御された環境での展開に適用できますが、追加の手段なしにパブリックインターネット経由で展開しないでください。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8257.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8257で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限について説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  DCTCP Algorithm . . . . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  Marking Congestion on the L3 Switches and Routers . . . .   5\n  3.2.  Echoing Congestion Information on the Receiver  . . . . .   5\n  3.3.  Processing Echoed Congestion Indications on the Sender  .   7\n  3.4.  Handling of Congestion Window Growth  . . . . . . . . . .   8\n  3.5.  Handling of Packet Loss . . . . . . . . . . . . . . . . .   8\n  3.6.  Handling of SYN, SYN-ACK, and RST Packets . . . . . . . .   9\n4.  Implementation Issues . . . . . . . . . . . . . . . . . . . .   9\n  4.1.  Configuration of DCTCP  . . . . . . . . . . . . . . . . .   9\n  4.2.  Computation of DCTCP.Alpha  . . . . . . . . . . . . . . .  10\n5.  Deployment Issues . . . . . . . . . . . . . . . . . . . . . .  11\n6.  Known Issues  . . . . . . . . . . . . . . . . . . . . . . . .  12\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  12\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  13\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  14\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  16\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Large data centers necessarily need many network switches to interconnect their many servers. Therefore, a data center can greatly reduce its capital expenditure by leveraging low-cost switches. However, such low-cost switches tend to have limited queue capacities; thus, they are more susceptible to packet loss due to congestion.",
      "ja": "大規模なデータセンターでは、多くのサーバーを相互接続するために、必然的に多くのネットワークスイッチが必要になります。したがって、データセンターは低コストのスイッチを活用することにより、設備投資を大幅に削減できます。ただし、このような低コストのスイッチでは、キューの容量が制限される傾向があります。そのため、輻輳によるパケット損失の影響を受けやすくなります。"
    },
    {
      "indent": 3,
      "text": "Network traffic in a data center is often a mix of short and long flows, where the short flows require low latencies and the long flows require high throughputs. Data centers also experience incast bursts, where many servers send traffic to a single server at the same time. For example, this traffic pattern is a natural consequence of the MapReduce [MAPREDUCE] workload: the worker nodes complete at approximately the same time, and all reply to the master node concurrently.",
      "ja": "データセンターのネットワークトラフィックは、多くの場合、短いフローと長いフローの混合であり、短いフローには低いレイテンシが必要であり、長いフローには高いスループットが必要です。また、データセンターではインキャストバーストが発生し、多くのサーバーが同時に1つのサーバーにトラフィックを送信します。たとえば、このトラフィックパターンはMapReduce [MAPREDUCE]ワークロードの当然の結果です。ワーカーノードはほぼ同時に完了し、すべてがマスターノードに同時に応答します。"
    },
    {
      "indent": 3,
      "text": "These factors place some conflicting demands on the queue occupancy of a switch:",
      "ja": "これらの要因により、スイッチのキュー占有率にいくつかの矛盾する要求が課されます。"
    },
    {
      "indent": 3,
      "text": "o The queue must be short enough that it does not impose excessive latency on short flows.",
      "ja": "o キューは、短いフローに過度のレイテンシを課さないように十分に短くする必要があります。"
    },
    {
      "indent": 3,
      "text": "o The queue must be long enough to buffer sufficient data for the long flows to saturate the path capacity.",
      "ja": "o キューは、長いフローがパス容量を飽和させるのに十分なデータをバッファリングするのに十分な長さである必要があります。"
    },
    {
      "indent": 3,
      "text": "o The queue must be long enough to absorb incast bursts without excessive packet loss.",
      "ja": "o キューは、過度のパケット損失なしでインキャストバーストを吸収するのに十分な長さでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Standard TCP congestion control [RFC5681] relies on packet loss to detect congestion. This does not meet the demands described above. First, short flows will start to experience unacceptable latencies before packet loss occurs. Second, by the time TCP congestion control kicks in on the senders, most of the incast burst has already been dropped.",
      "ja": "標準TCP輻輳制御[RFC5681]は、パケット損失に依存して輻輳を検出します。これは、上記の要求を満たしていません。まず、短いフローでは、パケット損失が発生する前に許容できない待機時間が発生し始めます。第2に、TCPの輻輳制御が送信側で開始されるまでに、ほとんどのインキャストバーストはすでにドロップされています。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] describes a mechanism for using Explicit Congestion Notification (ECN) from the switches for detection of congestion. However, this method only detects the presence of congestion, not its extent. In the presence of mild congestion, the TCP congestion window is reduced too aggressively, and this unnecessarily reduces the throughput of long flows.",
      "ja": "[RFC3168]は、輻輳の検出のためにスイッチからの明示的輻輳通知（ECN）を使用するためのメカニズムについて説明しています。ただし、この方法では輻輳の存在のみが検出され、範囲は検出されません。穏やかな輻輳が存在する場合、TCP輻輳ウィンドウがあまりにも積極的に縮小され、これにより長いフローのスループットが不必要に低下します。"
    },
    {
      "indent": 0,
      "text": " Data Center TCP (DCTCP) changes traditional ECN processing by estimating the fraction of bytes that encounter congestion rather than simply detecting that some congestion has occurred. DCTCP then scales the TCP congestion window based on this estimate. This method achieves high-burst tolerance, low latency, and high throughput with shallow-buffered switches. DCTCP is a modification to the processing of ECN by a conventional TCP and requires that standard TCP congestion control be used for handling packet loss.",
      "ja": "データセンターTCP（DCTCP）は、単に輻輳が発生したことを検出するのではなく、輻輳が発生したバイトの割合を推定することにより、従来のECN処理を変更します。次に、DCTCPはこの推定に基づいてTCP輻輳ウィンドウをスケーリングします。この方法は、浅いバッファのスイッチで高バースト耐性、低遅延、高スループットを実現します。 DCTCPは、従来のTCPによるECNの処理に対する変更であり、パケット損失の処理に標準のTCP輻輳制御を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "DCTCP should only be deployed in an intra-data-center environment where both endpoints and the switching fabric are under a single administrative domain. DCTCP MUST NOT be deployed over the public Internet without additional measures, as detailed in Section 5.",
      "ja": "DCTCPは、エンドポイントとスイッチングファブリックの両方が単一の管理ドメインの下にあるデータセンター内環境にのみ展開する必要があります。セクション5で説明されているように、DCTCPは追加の手段なしに公衆インターネット上に展開してはなりません。"
    },
    {
      "indent": 3,
      "text": "The objective of this Informational RFC is to document DCTCP as a new approach (which is known to be widely implemented and deployed) to address TCP congestion control in data centers. The IETF TCPM Working Group reached consensus regarding the fact that a DCTCP standard would require further work. A precise documentation of running code enables follow-up Experimental or Standards Track RFCs through the IETF stream.",
      "ja": "このInformational RFCの目的は、DCTCPをデータセンターのTCP輻輳制御に対処するための新しいアプローチ（広く実装および展開されていることが知られている）として文書化することです。 IETF TCPMワーキンググループは、DCTCP標準にはさらに作業が必要であるという事実に関して合意に達しました。実行中のコードの正確なドキュメントにより、IETFストリームを介したフォローアップの実験的または標準トラックRFCが可能になります。"
    },
    {
      "indent": 3,
      "text": "This document describes DCTCP as implemented in Microsoft Windows Server 2012 [WINDOWS]. The Linux [LINUX] and FreeBSD [FREEBSD] operating systems have also implemented support for DCTCP in a way that is believed to follow this document. Deployment experiences with DCTCP have been documented in [MORGANSTANLEY].",
      "ja": "このドキュメントでは、Microsoft Windows Server 2012 [WINDOWS]に実装されているDCTCPについて説明します。 Linux [LINUX]およびFreeBSD [FREEBSD]オペレーティングシステムも、このドキュメントに従うと考えられる方法でDCTCPのサポートを実装しています。 DCTCPの配備経験は[MORGANSTANLEY]に文書化されています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Normative language is used to describe how necessary the various aspects of a DCTCP implementation are for interoperability, but even compliant implementations without the measures in Sections 4-6 would still only be safe to deploy in controlled environments, i.e., not over the public Internet.",
      "ja": "DCTCP実装のさまざまな側面が相互運用性にどれほど必要かを規定するために規範的な言語が使用されていますが、セクション4から6の対策を講じていない準拠実装でも、安全な管理環境でのみ、つまりパブリックインターネット経由でのみ展開できます。"
    },
    {
      "indent": 0,
      "text": "3. DCTCP Algorithm",
      "section_title": true,
      "ja": "3. DCTCPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "There are three components involved in the DCTCP algorithm:",
      "ja": "DCTCPアルゴリズムには3つのコンポーネントが含まれます。"
    },
    {
      "indent": 3,
      "text": "o The switches (or other intermediate devices in the network) detect congestion and set the Congestion Encountered (CE) codepoint in the IP header.",
      "ja": "o スイッチ（またはネットワーク内の他の中間デバイス）は、輻輳を検出し、IPヘッダーにCongestion Encountered（CE）コードポイントを設定します。"
    },
    {
      "indent": 3,
      "text": "o The receiver echoes the congestion information back to the sender, using the ECN-Echo (ECE) flag in the TCP header.",
      "ja": "o 受信側は、TCPヘッダーのECN-Echo（ECE）フラグを使用して、輻輳情報を送信側にエコーします。"
    },
    {
      "indent": 3,
      "text": "o The sender computes a congestion estimate and reacts by reducing the TCP congestion window (cwnd) accordingly.",
      "ja": "o 送信側は、輻輳推定を計算し、それに応じてTCP輻輳ウィンドウ（cwnd）を減らすことで対応します。"
    },
    {
      "indent": 0,
      "text": "3.1. Marking Congestion on the L3 Switches and Routers",
      "section_title": true,
      "ja": "3.1. L3スイッチとルーターでの輻輳のマーキング"
    },
    {
      "indent": 3,
      "text": "The Layer 3 (L3) switches and routers in a data-center fabric indicate congestion to the end nodes by setting the CE codepoint in the IP header as specified in Section 5 of [RFC3168]. For example, the switches may be configured with a congestion threshold. When a packet arrives at a switch and its queue length is greater than the congestion threshold, the switch sets the CE codepoint in the packet. For example, Section 3.4 of [DCTCP10] suggests threshold marking with a threshold of K > (RTT * C)/7, where C is the link rate in packets per second. In typical deployments, the marking threshold is set to be a small value to maintain a short average queueing delay. However, the actual algorithm for marking congestion is an implementation detail of the switch and will generally not be known to the sender and receiver. Therefore, the sender and receiver should not assume that a particular marking algorithm is implemented by the switching fabric.",
      "ja": "データセンターファブリックのレイヤ3（L3）スイッチとルーターは、[RFC3168]のセクション5で指定されているように、IPヘッダーにCEコードポイントを設定することにより、エンドノードの輻輳を示します。たとえば、スイッチに輻輳しきい値を設定できます。パケットがスイッチに到着し、そのキューの長さが輻輳しきい値よりも大きい場合、スイッチはパケットにCEコードポイントを設定します。たとえば、[DCTCP10]のセクション3.4は、しきい値がK>（RTT * C）/ 7のしきい値マーキングを提案しています。ここで、Cは1秒あたりのパケット数でのリンクレートです。一般的な展開では、短い平均キューイング遅延を維持するために、マーキングしきい値は小さな値に設定されています。ただし、輻輳をマークするための実際のアルゴリズムはスイッチの実装の詳細であり、一般に送信者と受信者にはわかりません。したがって、送信側と受信側は、特定のマーキングアルゴリズムがスイッチングファブリックによって実装されていると想定しないでください。"
    },
    {
      "indent": 0,
      "text": "3.2. Echoing Congestion Information on the Receiver",
      "section_title": true,
      "ja": "3.2. 受信機での輻輳情報のエコー"
    },
    {
      "indent": 3,
      "text": "According to Section 6.1.3 of [RFC3168], the receiver sets the ECE flag if any of the packets being acknowledged had the CE codepoint set. The receiver then continues to set the ECE flag until it receives a packet with the Congestion Window Reduced (CWR) flag set. However, the DCTCP algorithm requires more-detailed congestion information. In particular, the sender must be able to determine the number of bytes sent that encountered congestion. Thus, the scheme described in [RFC3168] does not suffice.",
      "ja": "[RFC3168]のセクション6.1.3によれば、確認応答されているパケットのいずれかにCEコードポイントが設定されている場合、受信者はECEフラグを設定します。次に、受信者は、輻輳ウィンドウ削減（CWR）フラグが設定されたパケットを受信するまで、ECEフラグを設定し続けます。ただし、DCTCPアルゴリズムには、より詳細な輻輳情報が必要です。特に、送信者は、輻輳に遭遇した送信バイト数を判別できる必要があります。したがって、[RFC3168]で説明されているスキームでは不十分です。"
    },
    {
      "indent": 3,
      "text": "One possible solution is to ACK every packet and set the ECE flag in the ACK if and only if the CE codepoint was set in the packet being acknowledged. However, this prevents the use of delayed ACKs, which are an important performance optimization in data centers. If the delayed ACK frequency is n, then an ACK is generated every n packets.",
      "ja": "考えられる解決策の1つは、確認応答されるパケットにCEコードポイントが設定されている場合にのみ、すべてのパケットにACKを送信し、ACKにECEフラグを設定することです。ただし、これにより、データセンターでの重要なパフォーマンス最適化である遅延ACKの使用が防止されます。遅延ACK頻度がnの場合、ACKはnパケットごとに生成されます。"
    },
    {
      "indent": 3,
      "text": "The typical value of n is 2, but it could be affected by ACK throttling or packet-coalescing techniques designed to improve performance.",
      "ja": "nの一般的な値は2ですが、パフォーマンスを向上させるために設計されたACKスロットリングまたはパケット結合技法の影響を受ける可能性があります。"
    },
    {
      "indent": 3,
      "text": "Instead, DCTCP introduces a new Boolean TCP state variable, DCTCP Congestion Encountered (DCTCP.CE), which is initialized to false and stored in the Transmission Control Block (TCB). When sending an ACK, the ECE flag MUST be set if and only if DCTCP.CE is true. When receiving packets, the CE codepoint MUST be processed as follows:",
      "ja": "代わりに、DCTCPは新しいブールTCP状態変数DCTCP Congestion Encountered（DCTCP.CE）を導入します。これはfalseに初期化され、伝送制御ブロック（TCB）に格納されます。 ACKを送信する場合、DCTCP.CEがtrueの場合にのみ、ECEフラグを設定する必要があります。パケットを受信するとき、CEコードポイントは次のように処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If the CE codepoint is set and DCTCP.CE is false, set DCTCP.CE to true and send an immediate ACK.",
      "ja": "1. CEコードポイントが設定され、DCTCP.CEがfalseの場合、DCTCP.CEをtrueに設定して、即時ACKを送信します。"
    },
    {
      "indent": 3,
      "text": "2. If the CE codepoint is not set and DCTCP.CE is true, set DCTCP.CE to false and send an immediate ACK.",
      "ja": "2. CEコードポイントが設定されておらず、DCTCP.CEがtrueの場合、DCTCP.CEをfalseに設定して、即時ACKを送信します。"
    },
    {
      "indent": 3,
      "text": "3. Otherwise, ignore the CE codepoint.",
      "ja": "3. それ以外の場合は、CEコードポイントを無視します。"
    },
    {
      "indent": 3,
      "text": "Since the immediate ACK reflects the new DCTCP.CE state, it may acknowledge any previously unacknowledged packets in the old state. This can lead to an incorrect rate computation at the sender per Section 3.3. To avoid this, an implementation MAY choose to send two ACKs: one for previously unacknowledged packets and another acknowledging the most recently received packet.",
      "ja": "即時ACKは新しいDCTCP.CE状態を反映しているため、以前の未確認のパケットを古い状態で確認応答する場合があります。これにより、セクション3.3の送信者でのレート計算が不正確になる可能性があります。これを回避するために、実装は2つのACKを送信することを選択できます。1つは以前に確認応答されなかったパケット用で、もう1つは最近受信したパケットを確認応答します。"
    },
    {
      "indent": 3,
      "text": "Receiver handling of the CWR bit is also per [RFC3168] (including [Err3639]). That is, on receipt of a segment with both the CE and CWR bits set, CWR is processed first and then CE is processed.",
      "ja": "CWRビットのレシーバー処理も[RFC3168]に準拠しています（[Err3639]を含む）。つまり、CEビットとCWRビットの両方が設定されたセグメントを受信すると、CWRが最初に処理され、次にCEが処理されます。"
    },
    {
      "indent": 4,
      "text": "                         Send immediate\n                         ACK with ECE=0\n             .-----.     .--------------.     .-----.\nSend 1 ACK  /      v     v              |     |      \\\n for every |     .------------.    .------------.     | Send 1 ACK\n n packets |     | DCTCP.CE=0 |    | DCTCP.CE=1 |     | for every\nwith ECE=0 |     '------------'    '------------'     | n packets\n            \\      |     |              ^     ^      /  with ECE=1\n             '-----'     '--------------'     '-----'\n                          Send immediate\n                          ACK with ECE=1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 1: ACK Generation State Machine",
      "ja": "図1：ACK生成ステートマシン"
    },
    {
      "indent": 0,
      "text": "3.3. Processing Echoed Congestion Indications on the Sender",
      "section_title": true,
      "ja": "3.3. 送信者でのエコーされた輻輳表示の処理"
    },
    {
      "indent": 3,
      "text": "The sender estimates the fraction of bytes sent that encountered congestion. The current estimate is stored in a new TCP state variable, DCTCP.Alpha, which is initialized to 1 and SHOULD be updated as follows:",
      "ja": "送信者は、輻輳が発生した送信バイトの割合を推定します。現在の推定値は、1に初期化された新しいTCP状態変数DCTCP.Alphaに格納され、次のように更新する必要があります。"
    },
    {
      "indent": 6,
      "text": "DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "o g is the estimation gain, a real number between 0 and 1. The selection of g is left to the implementation. See Section 4 for further considerations.",
      "ja": "o gは推定ゲインで、0〜1の実数です。gの選択は実装に任されます。詳細については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o M is the fraction of bytes sent that encountered congestion during the previous observation window, where the observation window is chosen to be approximately the Round-Trip Time (RTT). In particular, an observation window ends when all bytes in flight at the beginning of the window have been acknowledged.",
      "ja": "o Mは、前の観測ウィンドウ中に輻輳に遭遇した送信バイトの割合です。観測ウィンドウは、ほぼ往復時間（RTT）になるように選択されています。特に、監視ウィンドウは、ウィンドウの先頭で飛行中のすべてのバイトが確認されると終了します。"
    },
    {
      "indent": 3,
      "text": "In order to update DCTCP.Alpha, the TCP state variables defined in [RFC0793] are used, and three additional TCP state variables are introduced:",
      "ja": "DCTCP.Alphaを更新するために、[RFC0793]で定義されたTCP状態変数が使用され、3つの追加のTCP状態変数が導入されます。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.WindowEnd: the TCP sequence number threshold when one observation window ends and another is to begin; initialized to SND.UNA.",
      "ja": "o DCTCP.WindowEnd：1つの監視ウィンドウが終了し、別の監視ウィンドウが開始するときのTCPシーケンス番号しきい値。 SND.UNAに初期化されます。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.BytesAcked: the number of sent bytes acknowledged during the current observation window; initialized to 0.",
      "ja": "o DCTCP.BytesAcked：現在の監視ウィンドウ中に確認応答された送信バイト数。 0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.BytesMarked: the number of bytes sent during the current observation window that encountered congestion; initialized to 0.",
      "ja": "o DCTCP.BytesMarked：輻輳が発生した現在の監視ウィンドウ中に送信されたバイト数。 0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "The congestion estimator on the sender MUST process acceptable ACKs as follows:",
      "ja": "送信側の輻輳推定器は、次のように受け入れ可能なACKを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Compute the bytes acknowledged (TCP Selective Acknowledgment (SACK) options [RFC2018] are ignored for this computation):",
      "ja": "1. 確認応答されたバイトを計算します（TCP選択的確認応答（SACK）オプション[RFC2018]はこの計算では無視されます）。"
    },
    {
      "indent": 10,
      "text": "BytesAcked = SEG.ACK - SND.UNA",
      "ja": "BytesAcked = SEG.ACK-SND.UNA"
    },
    {
      "indent": 3,
      "text": "2. Update the bytes sent:",
      "ja": "2. 送信されたバイトを更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesAcked += BytesAcked",
      "ja": "DCTCP.BytesAcked + = BytesAcked"
    },
    {
      "indent": 3,
      "text": "3. If the ECE flag is set, update the bytes marked:",
      "ja": "3. ECEフラグが設定されている場合は、マークされたバイトを更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesMarked += BytesAcked",
      "ja": "DCTCP.BytesMarked + = BytesAcked"
    },
    {
      "indent": 3,
      "text": "4. If the acknowledgment number is less than or equal to DCTCP.WindowEnd, stop processing. Otherwise, the end of the observation window has been reached, so proceed to update the congestion estimate as follows:",
      "ja": "4. 確認応答番号がDCTCP.WindowEnd以下の場合、処理を停止します。それ以外の場合は、観測ウィンドウの終わりに達したため、次のように輻輳推定を更新します。"
    },
    {
      "indent": 3,
      "text": "5. Compute the congestion level for the current observation window:",
      "ja": "5. 現在の観測ウィンドウの輻輳レベルを計算します。"
    },
    {
      "indent": 10,
      "text": "M = DCTCP.BytesMarked / DCTCP.BytesAcked",
      "ja": "M = DCTCP.BytesMarked / DCTCP.BytesAcked"
    },
    {
      "indent": 3,
      "text": "6. Update the congestion estimate:",
      "ja": "6. 混雑推定を更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "7. Determine the end of the next observation window:",
      "ja": "7. 次の観測ウィンドウの終わりを決定します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.WindowEnd = SND.NXT",
      "ja": "DCTCP.WindowEnd = SND.NXT"
    },
    {
      "indent": 3,
      "text": "8. Reset the byte counters:",
      "ja": "8. バイトカウンターをリセットします。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesAcked = DCTCP.BytesMarked = 0",
      "ja": "DCTCP.BytesAcked = DCTCP.BytesMarked = 0"
    },
    {
      "indent": 3,
      "text": "9. Rather than always halving the congestion window as described in [RFC3168], the sender SHOULD update cwnd as follows:",
      "ja": "9. [RFC3168]で説明されているように、輻輳ウィンドウを常に半分にするのではなく、送信者は次のようにcwndを更新する必要があります（SHOULD）。"
    },
    {
      "indent": 10,
      "text": "cwnd = cwnd * (1 - DCTCP.Alpha / 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Just as specified in [RFC3168], DCTCP does not react to congestion indications more than once for every window of data. The setting of the CWR bit is also as per [RFC3168]. This is required for interoperation with classic ECN receivers due to potential misconfigurations.",
      "ja": "[RFC3168]で指定されているように、DCTCPはデータのウィンドウごとに2回以上の輻輳表示に反応しません。 CWRビットの設定も[RFC3168]と同じです。これは、構成ミスの可能性があるため、従来のECNレシーバーとの相互運用に必要です。"
    },
    {
      "indent": 0,
      "text": "3.4. Handling of Congestion Window Growth",
      "section_title": true,
      "ja": "3.4. 輻輳ウィンドウの増加の処理"
    },
    {
      "indent": 3,
      "text": "A DCTCP sender grows its congestion window in the same way as conventional TCP. Slow start and congestion avoidance algorithms are handled as specified in [RFC5681].",
      "ja": "DCTCP送信側は、従来のTCPと同じ方法で輻輳ウィンドウを拡大します。スロースタートおよび輻輳回避アルゴリズムは、[RFC5681]で指定されているように処理されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Handling of Packet Loss",
      "section_title": true,
      "ja": "3.5. パケット損失の処理"
    },
    {
      "indent": 0,
      "text": " A DCTCP sender MUST react to loss episodes in the same way as conventional TCP, including fast retransmit and fast recovery algorithms, as specified in [RFC5681]. For cases where the packet loss is inferred and not explicitly signaled by ECN, the cwnd and other state variables like ssthresh MUST be changed in the same way that a conventional TCP would have changed them. As with ECN, a DCTCP sender will only reduce the cwnd once per window of data across all loss signals. Just as specified in [RFC5681], upon a timeout, the cwnd MUST be set to no more than the loss window (1 full-sized segment), regardless of previous cwnd reductions in a given window of data.",
      "ja": "DCTCP送信者は、[RFC5681]で指定されているように、高速再送信および高速回復アルゴリズムを含む、従来のTCPと同じ方法で損失エピソードに反応する必要があります。パケット損失が推測され、ECNによって明示的に通知されない場合、従来のTCPが変更していたのと同じ方法で、cwndおよびssthreshなどの他の状態変数を変更する必要があります。 ECNと同様に、DCTCP送信側は、すべての損失信号にわたってデータのウィンドウごとに1回だけcwndを削減します。 [RFC5681]で指定されているように、タイムアウト時に、cwndは、指定されたデータウィンドウでの以前のcwnd削減に関係なく、損失ウィンドウ（1フルサイズセグメント）以下に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6. Handling of SYN, SYN-ACK, and RST Packets",
      "section_title": true,
      "ja": "3.6. SYN、SYN-ACK、およびRSTパケットの処理"
    },
    {
      "indent": 3,
      "text": "If SYN, SYN-ACK, and RST packets for DCTCP connections have the ECN-Capable Transport (ECT) codepoint set in the IP header, they will receive the same treatment as other DCTCP packets when forwarded by a switching fabric under load. Lack of ECT in these packets can result in a higher drop rate, depending on the switching fabric configuration. Hence, for DCTCP connections, the sender SHOULD set ECT for SYN, SYN-ACK, and RST packets. A DCTCP receiver ignores CE codepoints set on any SYN, SYN-ACK, or RST packets.",
      "ja": "DCTCP接続のSYN、SYN-ACK、およびRSTパケットのIPヘッダーにECN対応トランスポート（ECT）コードポイントが設定されている場合、負荷のかかったスイッチングファブリックによって転送されたときに、他のDCTCPパケットと同じ扱いを受けます。これらのパケットにECTがないと、スイッチングファブリックの構成によっては、ドロップ率が高くなる可能性があります。したがって、DCTCP接続の場合、送信者はSYN、SYN-ACK、およびRSTパケットにECTを設定する必要があります（SHOULD）。 DCTCPレシーバーは、SYN、SYN-ACK、またはRSTパケットに設定されたCEコードポイントを無視します。"
    },
    {
      "indent": 0,
      "text": "4. Implementation Issues",
      "section_title": true,
      "ja": "4. 実装の問題"
    },
    {
      "indent": 0,
      "text": "4.1. Configuration of DCTCP",
      "section_title": true,
      "ja": "4.1. DCTCPの構成"
    },
    {
      "indent": 3,
      "text": "An implementation needs to know when to use DCTCP. Data-center servers may need to communicate with endpoints outside the data center, where DCTCP is unsuitable or unsupported. Thus, a global configuration setting to enable DCTCP will generally not suffice. DCTCP provides no mechanism for negotiating its use. Thus, additional management and configuration functionality is needed to ensure that DCTCP is not used with non-DCTCP endpoints.",
      "ja": "実装では、DCTCPをいつ使用するかを知る必要があります。データセンターサーバーは、DCTCPが不適切またはサポートされていないデータセンター外のエンドポイントと通信する必要がある場合があります。したがって、DCTCPを有効にするためのグローバル構成設定は、通常は十分ではありません。 DCTCPは、その使用をネゴシエートするメカニズムを提供しません。したがって、DCTCPが非DCTCPエンドポイントで使用されないようにするには、追加の管理および構成機能が必要です。"
    },
    {
      "indent": 3,
      "text": "Known solutions rely on either configuration or heuristics. Heuristics need to allow endpoints to individually enable DCTCP to ensure a DCTCP sender is always paired with a DCTCP receiver. One approach is to enable DCTCP based on the IP address of the remote endpoint. Another approach is to detect connections that transmit within the bounds of a data center. For example, an implementation could support automatic selection of DCTCP if the estimated RTT is less than a threshold (like 10 msec) and ECN is successfully negotiated under the assumption that if the RTT is low, then the two endpoints are likely in the same data-center network.",
      "ja": "既知のソリューションは、構成またはヒューリスティックスに依存しています。ヒューリスティックでは、エンドポイントが個別にDCTCPを有効にして、DCTCP送信者が常にDCTCP受信者とペアになるようにする必要があります。 1つのアプローチは、リモートエンドポイントのIPアドレスに基づいてDCTCPを有効にすることです。別のアプローチは、データセンターの境界内で送信する接続を検出することです。たとえば、実装は、推定RTTがしきい値（10ミリ秒など）未満の場合、DCTCPの自動選択をサポートし、RTTが低い場合、2つのエンドポイントは同じデータ内にある可能性が高いという仮定の下でECNが正常にネゴシエートされます。 -センターネットワーク。"
    },
    {
      "indent": 0,
      "text": " [RFC3168] forbids the ECN-marking of pure ACK packets because of the inability of TCP to mitigate ACK-path congestion. RFC 3168 also forbids ECN-marking of retransmissions, window probes, and RSTs. However, dropping all these control packets -- rather than ECN-marking them -- has considerable performance disadvantages. It is RECOMMENDED that an implementation provide a configuration knob that will cause ECT to be set on such control packets, which can be used in environments where such concerns do not apply. See [ECN-EXPERIMENTATION] for details.",
      "ja": "[RFC3168]は、TCPがACKパスの輻輳を緩和できないため、純粋なACKパケットのECNマーキングを禁止しています。 RFC 3168では、再送信、ウィンドウプローブ、およびRSTのECNマーキングも禁止されています。ただし、これらの制御パケットをすべて（ECNマーキングではなく）ドロップすると、パフォーマンスが著しく低下します。そのような制御パケットにECTを設定させる構成ノブを実装が提供することをお勧めします。これは、そのような懸念が適用されない環境で使用できます。詳細については、[ECN-EXPERIMENTATION]を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is useful to implement DCTCP as an additional action on top of an existing congestion control algorithm like Reno [RFC5681]. The DCTCP implementation MAY also allow configuration of resetting the value of DCTCP.Alpha as part of processing any loss episodes.",
      "ja": "Reno [RFC5681]のような既存の輻輳制御アルゴリズムの上に追加のアクションとしてDCTCPを実装すると便利です。 DCTCP実装は、損失エピソードの処理の一部としてDCTCP.Alphaの値をリセットする構成も許可する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Computation of DCTCP.Alpha",
      "section_title": true,
      "ja": "4.2. DCTCP.Alphaの計算"
    },
    {
      "indent": 3,
      "text": "As noted in Section 3.3, the implementation will need to choose a suitable estimation gain. [DCTCP10] provides a theoretical basis for selecting the gain. However, it may be more practical to use experimentation to select a suitable gain for a particular network and workload. A fixed estimation gain of 1/16 is used in some implementations. (It should be noted that values of 0 or 1 for g result in problematic behavior; g=0 fixes DCTCP.Alpha to its initial value, and g=1 sets it to M without any smoothing.)",
      "ja": "セクション3.3で述べたように、実装では適切な推定ゲインを選択する必要があります。 [DCTCP10]は、ゲインを選択するための理論的な基礎を提供します。ただし、実験を使用して特定のネットワークとワークロードに適したゲインを選択する方が現実的です。一部の実装では、1/16の固定推定ゲインが使用されます。 （gの値が0または1の場合、問題のある動作が発生することに注意してください。g= 0はDCTCP.Alphaを初期値に修正し、g = 1は平滑化なしでMに設定します。）"
    },
    {
      "indent": 3,
      "text": "The DCTCP.Alpha computation as per the formula in Section 3.3 involves fractions. An efficient kernel implementation MAY scale the DCTCP.Alpha value for efficient computation using shift operations. For example, if the implementation chooses g as 1/16, multiplications of DCTCP.Alpha by g become right-shifts by 4. A scaling implementation SHOULD ensure that DCTCP.Alpha is able to reach 0 once it falls below the smallest shifted value (16 in the above example). At the other extreme, a scaled update needs to ensure DCTCP.Alpha does not exceed the scaling factor, which would be equivalent to greater than 100% congestion. So, DCTCP.Alpha MUST be clamped after an update.",
      "ja": "セクション3.3の式によるDCTCP.Alpha計算には、分数が含まれます。効率的なカーネル実装は、シフト操作を使用した効率的な計算のために、DCTCP.Alpha値をスケーリングできます（MAY）。たとえば、実装がgを1/16として選択した場合、DCTCP.Alphaのgによる乗算は4だけ右シフトになります。スケーリング実装は、DCTCP.Alphaが最小のシフト値を下回ったときに0に到達できることを保証する必要があります（上記の例では16）。逆に、スケーリングされた更新では、DCTCP.Alphaが100％を超える輻輳に相当するスケーリング係数を超えないようにする必要があります。したがって、DCTCP.Alphaは更新後にクランプする必要があります。"
    },
    {
      "indent": 3,
      "text": "This results in the following computations replacing steps 5 and 6 in Section 3.3, where SCF is the chosen scaling factor (65536 in the example), and SHF is the shift factor (4 in the example):",
      "ja": "これにより、セクション3.3のステップ5と6に代わる次の計算が行われます。SCFは選択されたスケーリング係数（例では65536）であり、SHFはシフト係数（例では4）です。"
    },
    {
      "indent": 3,
      "text": "1. Compute the congestion level for the current observation window:",
      "ja": "1. 現在の観測ウィンドウの輻輳レベルを計算します。"
    },
    {
      "indent": 10,
      "text": "ScaledM = SCF * DCTCP.BytesMarked / DCTCP.BytesAcked",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "2. Update the congestion estimate:",
      "ja": "2. 混雑推定を更新します。"
    },
    {
      "indent": 10,
      "text": "if (DCTCP.Alpha >> SHF) == 0, then DCTCP.Alpha = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "DCTCP.Alpha += (ScaledM >> SHF) - (DCTCP.Alpha >> SHF)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "if DCTCP.Alpha > SCF, then DCTCP.Alpha = SCF",
      "ja": "DCTCP.Alpha> SCFの場合、DCTCP.Alpha = SCF"
    },
    {
      "indent": 0,
      "text": "5. Deployment Issues",
      "section_title": true,
      "ja": "5. 展開の問題"
    },
    {
      "indent": 3,
      "text": "DCTCP and conventional TCP congestion control do not coexist well in the same network. In typical DCTCP deployments, the marking threshold in the switching fabric is set to a very low value to reduce queueing delay, and a relatively small amount of congestion will exceed the marking threshold. During such periods of congestion, conventional TCP will suffer packet loss and quickly and drastically reduce cwnd. DCTCP, on the other hand, will use the fraction of marked packets to reduce cwnd more gradually. Thus, the rate reduction in DCTCP will be much slower than that of conventional TCP, and DCTCP traffic will gain a larger share of the capacity compared to conventional TCP traffic traversing the same path. If the traffic in the data center is a mix of conventional TCP and DCTCP, it is RECOMMENDED that DCTCP traffic be segregated from conventional TCP traffic. [MORGANSTANLEY] describes a deployment that uses the IP Differentiated Services Codepoint (DSCP) bits to segregate the network such that Active Queue Management (AQM) [RFC7567] is applied to DCTCP traffic, whereas TCP traffic is managed via drop-tail queueing.",
      "ja": "DCTCPと従来のTCP輻輳制御は、同じネットワーク内でうまく共存しません。通常のDCTCP展開では、スイッチングファブリックのマーキングしきい値は非常に低い値に設定されており、キューイングの遅延を減らし、比較的少量の輻輳がマーキングしきい値を超えます。このような輻輳の期間中、従来のTCPはパケット損失を被り、cwndを迅速かつ大幅に削減します。一方、DCTCPはマークされたパケットの一部を使用して、cwndを徐々に減らします。したがって、DCTCPのレート削減は従来のTCPのレート削減よりもはるかに遅くなり、DCTCPトラフィックは、同じパスを通過する従来のTCPトラフィックと比較して、容量の大きなシェアを獲得します。データセンターのトラフィックが従来のTCPとDCTCPの混合である場合、DCTCPトラフィックを従来のTCPトラフィックから分離することをお勧めします。 [MORGANSTANLEY]は、IP差別化サービスコードポイント（DSCP）ビットを使用してネットワークを分離し、Active Queue Management（AQM）[RFC7567]がDCTCPトラフィックに適用されるのに対し、TCPトラフィックはドロップテールキューイングによって管理される配備を説明しています。"
    },
    {
      "indent": 3,
      "text": "Deployments should take into account segregation of non-TCP traffic as well. Today's commodity switches allow configuration of different marking/drop profiles for non-TCP and non-IP packets. Non-TCP and non-IP packets should be able to pass through such switches, unless they really run out of buffer space.",
      "ja": "展開では、TCP以外のトラフィックの分離も考慮する必要があります。今日のコモディティスイッチでは、非TCPパケットと非IPパケットに異なるマーキング/ドロッププロファイルを設定できます。非TCPおよび非IPパケットは、実際にバッファスペースが不足しない限り、そのようなスイッチを通過できるはずです。"
    },
    {
      "indent": 3,
      "text": "Since DCTCP relies on congestion marking by the switches, DCTCP's potential can only be realized in data centers where the entire network infrastructure supports ECN. The switches may also support configuration of the congestion threshold used for marking. The proposed parameterization can be configured with switches that implement Random Early Detection (RED) [RFC2309]. [DCTCP10] provides a theoretical basis for selecting the congestion threshold, but, as with the estimation gain, it may be more practical to rely on experimentation or simply to use the default configuration of the device. DCTCP will revert to loss-based congestion control when packet loss is experienced (e.g., when transiting a congested drop-tail link, or a link with an AQM drop behavior).",
      "ja": "DCTCPはスイッチによる輻輳マーキングに依存しているため、DCTCPの可能性は、ネットワークインフラストラクチャ全体がECNをサポートするデータセンターでのみ実現できます。スイッチは、マーキングに使用される輻輳しきい値の構成もサポートする場合があります。提案されたパラメーター化は、ランダム早期検出（RED）[RFC2309]を実装するスイッチで構成できます。 [DCTCP10]は、輻輳しきい値を選択するための理論的な基礎を提供しますが、推定ゲインと同様に、実験に依存するか、単にデバイスのデフォルト構成を使用する方が実際的かもしれません。 DCTCPは、パケット損失が発生すると（たとえば、輻輳したドロップテールリンク、またはAQMドロ​​ップ動作を持つリンクを通過するときに）、損失ベースの輻輳制御に戻ります。"
    },
    {
      "indent": 3,
      "text": "DCTCP requires changes on both the sender and the receiver, so both endpoints must support DCTCP. Furthermore, DCTCP provides no mechanism for negotiating its use, so both endpoints must be configured through some out-of-band mechanism to use DCTCP. A variant of DCTCP that can be deployed unilaterally and that only requires standard ECN behavior has been described in [ODCTCP] and [BSDCAN], but it requires additional experimental evaluation.",
      "ja": "DCTCPは送信側と受信側の両方で変更を必要とするため、両方のエンドポイントがDCTCPをサポートする必要があります。さらに、DCTCPはその使用をネゴシエートするメカニズムを提供しないため、DCTCPを使用するには、両方のエンドポイントを帯域外メカニズムを介して構成する必要があります。一方的に展開でき、標準のECN動作のみが必要なDCTCPのバリアントは、[ODCTCP]および[BSDCAN]で説明されていますが、追加の実験的評価が必要です。"
    },
    {
      "indent": 0,
      "text": "6. Known Issues",
      "section_title": true,
      "ja": "6. 既知の問題点"
    },
    {
      "indent": 3,
      "text": "DCTCP relies on the sender's ability to reconstruct the stream of CE codepoints received by the remote endpoint. To accomplish this, DCTCP avoids using a single ACK packet to acknowledge segments received both with and without the CE codepoint set. However, if one or more ACK packets are dropped, it is possible that a subsequent ACK will cumulatively acknowledge a mix of CE and non-CE segments. This will, of course, result in a less-accurate congestion estimate. There are some potential considerations:",
      "ja": "DCTCPは、リモートエンドポイントが受信したCEコードポイントのストリームを再構築する送信者の機能に依存しています。これを達成するために、DCTCPは、単一のACKパケットを使用して、CEコードポイントが設定されている場合と設定されていない場合の両方で受信したセグメントを確認することを回避します。ただし、1つ以上のACKパケットがドロップされると、後続のACKがCEセグメントと非CEセグメントの混合を累積的に確認する可能性があります。もちろん、これは混雑推定の精度を低下させます。考えられる考慮事項がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "o Even with an inaccurate congestion estimate, DCTCP may still perform better than [RFC3168].",
      "ja": "o 不正確な輻輳推定があっても、DCTCPは[RFC3168]よりもパフォーマンスが優れている場合があります。"
    },
    {
      "indent": 3,
      "text": "o If the estimation gain is small relative to the packet loss rate, the estimate may not be too inaccurate.",
      "ja": "o 推定ゲインがパケット損失率に比べて小さい場合は、推定が不正確にならない可能性があります。"
    },
    {
      "indent": 3,
      "text": "o If ACK packet loss mostly occurs under heavy congestion, most drops will occur during an unbroken string of CE packets, and the estimate will be unaffected.",
      "ja": "o ACKパケットの損失が大規模な輻輳下でほとんど発生する場合、ほとんどのドロップはCEパケットの途切れのない文字列の間に発生し、推定は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "However, the effect of packet drops on DCTCP under real-world conditions has not been analyzed.",
      "ja": "ただし、実際の条件下でのDCTCPに対するパケットドロップの影響は分析されていません。"
    },
    {
      "indent": 3,
      "text": "DCTCP provides no mechanism for negotiating its use. The effect of using DCTCP with a standard ECN endpoint has been analyzed in [ODCTCP] and [BSDCAN]. Furthermore, it is possible that other implementations may also modify behavior in the [RFC3168] style without negotiation, causing further interoperability issues.",
      "ja": "DCTCPは、その使用をネゴシエートするメカニズムを提供しません。標準のECNエンドポイントでDCTCPを使用する効果は、[ODCTCP]と[BSDCAN]で分析されています。さらに、他の実装もネゴシエーションなしで[RFC3168]スタイルの動作を変更し、相互運用性の問題を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Much like standard TCP, DCTCP is biased against flows with longer RTTs. A method for improving the RTT fairness of DCTCP has been proposed in [ADCTCP], but it requires additional experimental evaluation.",
      "ja": "標準TCPと同様に、DCTCPはより長いRTTを持つフローに対してバイアスされます。 DCTCPのRTT公平性を改善する方法は[ADCTCP]で提案されていますが、追加の実験的評価が必要です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "DCTCP enhances ECN; thus, it inherits the general security considerations discussed in [RFC3168], although additional mitigation options exist due to the limited intra-data-center deployment of DCTCP.",
      "ja": "DCTCPはECNを拡張します。したがって、それは[RFC3168]で説明されている一般的なセキュリティの考慮事項を継承しますが、DCTCPのデータセンター内の展開が限られているため、追加の緩和オプションが存在します。"
    },
    {
      "indent": 3,
      "text": "The processing changes introduced by DCTCP do not exacerbate the considerations in [RFC3168] or introduce new ones. In particular, with either algorithm, the network infrastructure or the remote endpoint can falsely report congestion and, thus, cause the sender to reduce cwnd. However, this is no worse than what can be achieved by simply dropping packets.",
      "ja": "DCTCPによって導入された処理の変更は、[RFC3168]の考慮事項を悪化させたり、新しいものを導入したりしません。特に、どちらのアルゴリズムでも、ネットワークインフラストラクチャまたはリモートエンドポイントが誤って輻輳を報告し、送信者にcwndを削減させる可能性があります。ただし、これは単にパケットをドロップすることで実現できることよりも悪いことではありません。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] requires that a compliant TCP must not set ECT on SYN or SYN-ACK packets. [RFC5562] proposes setting ECT on SYN-ACK packets but maintains the restriction of no ECT on SYN packets. Both these RFCs prohibit ECT in SYN packets due to security concerns regarding malicious SYN packets with ECT set. However, these RFCs are intended for general Internet use; they do not directly apply to a controlled data-center environment. The security concerns addressed by both of these RFCs might not apply in controlled environments like data centers, and it might not be necessary to account for the presence of non-ECN servers. Beyond the security considerations related to virtual servers, additional security can be imposed in the physical servers to intercept and drop traffic resembling an attack.",
      "ja": "[RFC3168]は、準拠するTCPがSYNまたはSYN-ACKパケットにECTを設定してはならないことを要求します。 [RFC5562]は、SYN-ACKパケットにECTを設定することを提案していますが、SYNパケットにECTがないという制限を維持しています。これらのRFCは両方とも、ECTが設定された悪意のあるSYNパケットに関するセキュリティ上の懸念により、SYNパケットでのECTを禁止しています。ただし、これらのRFCは一般的なインターネット使用を目的としています。制御されたデータセンター環境には直接適用されません。これらの両方のRFCによって対処されるセキュリティの懸念は、データセンターなどの制御された環境には適用されない可能性があり、非ECNサーバーの存在を考慮する必要がない場合があります。仮想サーバーに関連するセキュリティの考慮事項に加えて、物理サーバーに追加のセキュリティを課して、攻撃に似たトラフィックを傍受してドロップすることができます。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントでは、IANAアクションは必要ありません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC0793] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<https://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, DOI 10.17487/RFC2018, October 1996, <https://www.rfc-editor.org/info/rfc2018>.",
      "ja": "[RFC2018] Mathis、M.、Madhavi、J.、Floyd、S。、およびA. Romanow、「TCP選択的確認応答オプション」、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、<https：//www.rfc- editor.org/info/rfc2018>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：// www。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC5562] Kuzmanovic, A., Mondal, A., Floyd, S., and K. Ramakrishnan, \"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets\", RFC 5562, DOI 10.17487/RFC5562, June 2009, <https://www.rfc-editor.org/info/rfc5562>.",
      "ja": "[RFC5562]クズマノビッチ、A。、モンダル、A。、フロイド、S。、およびK.ラマクリシュナン、「TCPのSYN / ACKパケットへの明示的輻輳通知（ECN）機能の追加」、RFC 5562、DOI 10.17487 / RFC5562、2009年6月、<https://www.rfc-editor.org/info/rfc5562>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681] Allman、M.、Paxson、V。、およびE. Blanton、「TCP Congestion Control」、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<https://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ADCTCP] Alizadeh, M., Javanmard, A., and B. Prabhakar, \"Analysis of DCTCP: Stability, Convergence, and Fairness\", DOI 10.1145/1993744.1993753, Proceedings of the ACM SIGMETRICS Joint International Conference on Measurement and Modeling of Computer Systems, June 2011, <https://dl.acm.org/citation.cfm?id=1993753>.",
      "ja": "[ADCTCP] Alizadeh、M.、Javanmard、A。、およびB. Prabhakar、「DCTCPの分析：安定性、収束、および公平性」、DOI 10.1145 / 1993744.1993753、Proceedings of the ACM SIGMETRICS Joint International Conference on Computer of Measurement and Computerシステム、2011年6月、<https://dl.acm.org/citation.cfm?id=1993753>。"
    },
    {
      "indent": 3,
      "text": "[BSDCAN] Kato, M., Eggert, L., Zimmermann, A., van Meter, R., and H. Tokuda, \"Extensions to FreeBSD Datacenter TCP for Incremental Deployment Support\", BSDCan 2015, June 2015, <https://www.bsdcan.org/2015/schedule/events/559.en.html>.",
      "ja": "[BSDCAN]加藤M.、エガート、L。、ジマーマン、A。、ファンメーター、R。、およびH.徳田、「インクリメンタルデプロイメントサポートのためのFreeBSDデータセンターTCPの拡張」、BSDCan 2015、2015年6月、<https： //www.bsdcan.org/2015/schedule/events/559.en.html>。"
    },
    {
      "indent": 3,
      "text": "[DCTCP10] Alizadeh, M., Greenberg, A., Maltz, D., Padhye, J., Patel, P., Prabhakar, B., Sengupta, S., and M. Sridharan, \"Data Center TCP (DCTCP)\", DOI 10.1145/1851182.1851192, Proceedings of the ACM SIGCOMM 2010 Conference, August 2010, <http://dl.acm.org/citation.cfm?doid=1851182.1851192>.",
      "ja": "[DCTCP10] Alizadeh、M.、Greenberg、A.、Maltz、D.、Padhye、J.、Patel、P.、Prabhakar、B.、Sengupta、S。、およびM. Sridharan、「Data Center TCP（DCTCP） \"、DOI 10.1145 / 1851182.1851192、Proceedings of the ACM SIGCOMM 2010 Conference、2010年8月、<http://dl.acm.org/citation.cfm?doid=1851182.1851192>。"
    },
    {
      "indent": 3,
      "text": "[ECN-EXPERIMENTATION] Black, D., \"Explicit Congestion Notification (ECN) Experimentation\", Work in Progress, draft-ietf-tsvwg-ecn-experimentation-06, September 2017.",
      "ja": "[ECN-EXPERIMENTATION]ブラック、D。、「明示的輻輳通知（ECN）実験」、進行中の作業、draft-ietf-tsvwg-ecn-experimentation-06、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[Err3639] RFC Errata, Erratum ID 3639, RFC 3168, <https://www.rfc-editor.org/errata/eid3639>.",
      "ja": "[Err3639] RFC Errata、Erratum ID 3639、RFC 3168、<https://www.rfc-editor.org/errata/eid3639>。"
    },
    {
      "indent": 3,
      "text": "[FREEBSD] Kato, M. and H. Panchasara, \"DCTCP (Data Center TCP) implementation\", January 2015, <https://github.com/freebsd/freebsd/ commit/8ad879445281027858a7fa706d13e458095b595f>.",
      "ja": "[FREEBSD] Kato、M.、H。Panchasara、「DCTCP（Data Center TCP）implementation」、2015年1月、<https://github.com/freebsd/freebsd/commit/8ad879445281027858a7fa706d13e458095b595f>。"
    },
    {
      "indent": 3,
      "text": "[LINUX] Borkmann, D., Westphal, F., and Glenn. Judd, \"net: tcp: add DCTCP congestion control algorithm\", LINUX DCTCP Patch, September 2014, <https://git.kernel.org/cgit/linux/ kernel/git/davem/net-next.git/commit/ ?id=e3118e8359bb7c59555aca60c725106e6d78c5ce>.",
      "ja": "[LINUX] Borkmann、D.、Westphal、F.、Glenn。 Judd、「net：tcp：add DCTCP congestion control algorithm」、LINUX DCTCP Patch、2014年9月、<https://git.kernel.org/cgit/linux/ kernel / git / davem / net-next.git / commit / ？id = e3118e8359bb7c59555aca60c725106e6d78c5ce>。"
    },
    {
      "indent": 3,
      "text": "[MAPREDUCE] Dean, J. and S. Ghemawat, \"MapReduce: Simplified Data Processing on Large Clusters\", Proceedings of the 6th ACM/USENIX Symposium on Operating Systems Design and Implementation, October 2004, <https://www.usenix.org/ legacy/publications/library/proceedings/osdi04/tech/ dean.html>.",
      "ja": "[MAPREDUCE] Dean、J。およびS. Ghemawat、「MapReduce：Simplified Data Processing on Large Clusters」、Proceedings of the 6th ACM / USENIX Symposium on Operating Systems Design and Implementation、2004年10月、<https：//www.usenix。 org / legacy / publications / library / proceedings / osdi04 / tech / dean.html>。"
    },
    {
      "indent": 3,
      "text": "[MORGANSTANLEY] Judd, G., \"Attaining the Promise and Avoiding the Pitfalls of TCP in the Datacenter\", Proceedings of the 12th USENIX Symposium on Networked Systems Design and Implementation, May 2015, <https://www.usenix.org/conference/nsdi15/ technical-sessions/presentation/judd>.",
      "ja": "[MORGANSTANLEY]ジャッドG.、「データセンターでのTCPの約束の達成と落とし穴の回避」、ネットワークシステムの設計と実装に関する第12回USENIXシンポジウムの議事録、2015年5月、<https://www.usenix.org/会議/ nsdi15 /テクニカルセッション/プレゼンテーション/ジャッド>。"
    },
    {
      "indent": 3,
      "text": "[ODCTCP] Kato, M., \"Improving Transmission Performance with One-Sided Datacenter TCP\", M.S. Thesis, Keio University, 2013, <http://eggert.org/students/kato-thesis.pdf>.",
      "ja": "[ODCTCP]加藤雅明、「片面データセンターTCPによる伝送パフォーマンスの向上」、M.S。論文、慶應義塾大学、2013年、<http://eggert.org/students/kato-thesis.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, \"Recommendations on Queue Management and Congestion Avoidance in the Internet\", RFC 2309, DOI 10.17487/RFC2309, April 1998, <https://www.rfc-editor.org/info/rfc2309>.",
      "ja": "[RFC2309]ブレーデン、B。、クラーク、D。、クロウクロフト、J。、デイビー、B。、ディアリング、S。、エストリン、D。、フロイド、S。、ジェイコブソン、V。、ミンシャル、G。、パートリッジ、 C.、Peterson、L.、Ramakrishnan、K.、Shenker、S.、Wroclawski、J。、およびL. Zhang、「インターネットでのキュー管理と輻輳回避に関する推奨事項」、RFC 2309、DOI 10.17487 / RFC2309、4月1998、<https://www.rfc-editor.org/info/rfc2309>。"
    },
    {
      "indent": 3,
      "text": "[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., \"IETF Recommendations Regarding Active Queue Management\", BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, <https://www.rfc-editor.org/info/rfc7567>.",
      "ja": "[RFC7567]ベイカー、F。、エド。およびG.フェアハースト編、「アクティブキュー管理に関するIETFの推奨事項」、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、<https://www.rfc-editor.org/info/rfc7567>。"
    },
    {
      "indent": 3,
      "text": "[WINDOWS] Microsoft, \"Data Center Transmission Control Protocol (DCTCP)\", May 2012, <https://technet.microsoft.com/ en-us/library/hh997028(v=ws.11).aspx>.",
      "ja": "[Windows] Microsoft、「Data Center Transmission Control Protocol（DCTCP）」、2012年5月、<https://technet.microsoft.com/ en-us / library / hh997028（v = ws.11）.aspx>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The DCTCP algorithm was originally proposed and analyzed in [DCTCP10] by Mohammad Alizadeh, Albert Greenberg, Dave Maltz, Jitu Padhye, Parveen Patel, Balaji Prabhakar, Sudipta Sengupta, and Murari Sridharan.",
      "ja": "DCTCPアルゴリズムは、もともと[DCTCP10]でモハマドアリザデ、アルバートグリーンバーグ、デイブマルツ、ジトゥパディ、パルヴィーンパテル、バラジプラバカール、スディプタセンガプタ、ムラリスリダーランによって提案され、分析されました。"
    },
    {
      "indent": 3,
      "text": "We would like to thank Andrew Shewmaker for identifying the problem of clamping DCTCP.Alpha and proposing a solution for it.",
      "ja": "DCTCP.Alphaのクランプの問題を特定して解決策を提案してくれたAndrew Shewmakerに感謝します。"
    },
    {
      "indent": 3,
      "text": "Lars Eggert has received funding from the European Union's Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644866 (\"SSICLOPS\"). This document reflects only the authors' views and the European Commission is not responsible for any use that may be made of the information it contains.",
      "ja": "Lars Eggertは、EUのHorizo​​n 2020研究およびイノベーションプログラム2014-2018から、助成金契約番号644866（「SSICLOPS」）の下で資金を受け取りました。この文書は著者の見解のみを反映しており、欧州委員会はそれが含む情報のいかなる利用についても責任を負いません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stephen Bensley Microsoft One Microsoft Way Redmond, WA 98052 United States of America",
      "ja": "Ｓてｐへん べんｓぇｙ みｃろそｆｔ おね みｃろそｆｔ わｙ れｄもんｄ、 わ ９８０５２ うにてｄ Ｓたてｓ おｆ あめりか"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 703 5570\nEmail: sbens@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dave Thaler Microsoft",
      "ja": "デイブターラーマイクロソフト"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 703 8835\nEmail: dthaler@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Praveen Balasubramanian Microsoft",
      "ja": "Praveen Balasubramanian Microsoft"
    },
    {
      "indent": 0,
      "text": " Phone: +1 425 538 2782 Email: pravb@microsoft.com Lars Eggert NetApp Sonnenallee 1 Kirchheim 85551 Germany",
      "ja": "電話：+1 425 538 2782メール：pravb@microsoft.com Lars Eggert NetApp Sonnenallee 1キルヒハイム85551ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 151 120 55791\nEmail: lars@netapp.com\nURI:   http://eggert.org/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Glenn Judd Morgan Stanley",
      "ja": "グレンジャッドモーガンスタンレー"
    },
    {
      "indent": 3,
      "text": "Phone: +1 973 979 6481\nEmail: glenn.judd@morganstanley.com",
      "raw": true,
      "ja": ""
    }
  ]
}