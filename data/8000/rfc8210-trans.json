{
  "title": {
    "text": "RFC 8210 - The Resource Public Key Infrastructure (RPKI) to Router Protocol, Version 1",
    "ja": "RFC 8210 - Resource Public Key Infrastructure（RPKI）to Router Protocol、Version 1"
  },
  "number": 8210,
  "created_at": "2020-08-28 11:36:45.439298+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Bush\nRequest for Comments: 8210                     Internet Initiative Japan\nUpdates: 6810                                                 R. Austein\nCategory: Standards Track                           Dragon Research Labs\nISSN: 2070-1721                                           September 2017",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Resource Public Key Infrastructure (RPKI) to Router Protocol, Version 1",
      "ja": "Resource Public Key Infrastructure（RPKI）to Router Protocol、Version 1"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems and Autonomous System Paths of BGP announcements, routers need a simple but reliable mechanism to receive Resource Public Key Infrastructure (RFC 6480) prefix origin data and router keys from a trusted cache. This document describes a protocol to deliver them.",
      "ja": "BGPアナウンスの元の自律システムと自律システムパスを検証可能に検証するには、信頼できるキャッシュからリソース公開鍵インフラストラクチャ（RFC 6480）プレフィックスの元データとルーターキーを受信するためのシンプルで信頼性の高いメカニズムがルーターに必要です。このドキュメントでは、それらを配信するためのプロトコルについて説明します。"
    },
    {
      "indent": 3,
      "text": "This document describes version 1 of the RPKI-Router protocol. RFC 6810 describes version 0. This document updates RFC 6810.",
      "ja": "このドキュメントでは、RPKI-Routerプロトコルのバージョン1について説明します。 RFC 6810はバージョン0について説明しています。このドキュメントはRFC 6810を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8210.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8210で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4\n  1.2.  Changes from RFC 6810 . . . . . . . . . . . . . . . . . .   4\n2.  Glossary  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Deployment Structure  . . . . . . . . . . . . . . . . . . . .   5\n4.  Operational Overview  . . . . . . . . . . . . . . . . . . . .   6\n5.  Protocol Data Units (PDUs)  . . . . . . . . . . . . . . . . .   7\n  5.1.  Fields of a PDU . . . . . . . . . . . . . . . . . . . . .   7\n  5.2.  Serial Notify . . . . . . . . . . . . . . . . . . . . . .  10\n  5.3.  Serial Query  . . . . . . . . . . . . . . . . . . . . . .  10\n  5.4.  Reset Query . . . . . . . . . . . . . . . . . . . . . . .  12\n  5.5.  Cache Response  . . . . . . . . . . . . . . . . . . . . .  12\n  5.6.  IPv4 Prefix . . . . . . . . . . . . . . . . . . . . . . .  13\n  5.7.  IPv6 Prefix . . . . . . . . . . . . . . . . . . . . . . .  14\n  5.8.  End of Data . . . . . . . . . . . . . . . . . . . . . . .  15\n  5.9.  Cache Reset . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.10. Router Key  . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.11. Error Report  . . . . . . . . . . . . . . . . . . . . . .  17\n6.  Protocol Timing Parameters  . . . . . . . . . . . . . . . . .  18\n7.  Protocol Version Negotiation  . . . . . . . . . . . . . . . .  20\n8.  Protocol Sequences  . . . . . . . . . . . . . . . . . . . . .  21\n  8.1.  Start or Restart  . . . . . . . . . . . . . . . . . . . .  21\n  8.2.  Typical Exchange  . . . . . . . . . . . . . . . . . . . .  22\n  8.3.  No Incremental Update Available . . . . . . . . . . . . .  23\n  8.4.  Cache Has No Data Available . . . . . . . . . . . . . . .  23\n9.  Transport . . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  9.1.  SSH Transport . . . . . . . . . . . . . . . . . . . . . .  25\n  9.2.  TLS Transport . . . . . . . . . . . . . . . . . . . . . .  26\n  9.3.  TCP MD5 Transport . . . . . . . . . . . . . . . . . . . .  26\n  9.4.  TCP-AO Transport  . . . . . . . . . . . . . . . . . . . .  27\n10. Router-Cache Setup  . . . . . . . . . . . . . . . . . . . . .  27\n11. Deployment Scenarios  . . . . . . . . . . . . . . . . . . . .  28\n12. Error Codes . . . . . . . . . . . . . . . . . . . . . . . . .  29\n13. Security Considerations . . . . . . . . . . . . . . . . . . .  30\n14. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  31\n15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  32\n  15.1.  Normative References . . . . . . . . . . . . . . . . . .  32\n  15.2.  Informative References . . . . . . . . . . . . . . . . .  34\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  35\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems (ASes) and AS paths of BGP announcements, routers need a simple but reliable mechanism to receive cryptographically validated Resource Public Key Infrastructure (RPKI) [RFC6480] prefix origin data and router keys from a trusted cache. This document describes a protocol to deliver them. The design is intentionally constrained to be usable on much of the current generation of ISP router platforms.",
      "ja": "BGPアナウンスの起点自律システム（AS）とASパスを検証可能に検証するために、ルーターは、信頼できるキャッシュから暗号で検証されたリソース公開鍵インフラストラクチャ（RPKI）[RFC6480]接頭辞起点データとルーターキーを受信するシンプルで信頼できるメカニズムを必要とします。このドキュメントでは、それらを配信するためのプロトコルについて説明します。この設計は、現在の世代のISPルータープラットフォームの多くで使用できるように意図的に制限されています。"
    },
    {
      "indent": 3,
      "text": "This document updates [RFC6810].",
      "ja": "このドキュメントは[RFC6810]を更新します。"
    },
    {
      "indent": 3,
      "text": "Section 3 describes the deployment structure, and Section 4 then presents an operational overview. The binary payloads of the protocol are formally described in Section 5, and the expected Protocol Data Unit (PDU) sequences are described in Section 8. The transport protocol options are described in Section 9. Section 10 details how routers and caches are configured to connect and authenticate. Section 11 describes likely deployment scenarios. The traditional security and IANA considerations end the document.",
      "ja": "セクション3では配備構造について説明し、セクション4では操作の概要を示します。プロトコルのバイナリペイロードについては、セクション5で正式に説明し、予想されるプロトコルデータユニット（PDU）シーケンスについては、セクション8で説明します。トランスポートプロトコルオプションについては、セクション9で説明します。セクション10では、ルーターとキャッシュを構成して接続する方法を詳しく説明しています。そして認証します。セクション11では、考えられる展開シナリオについて説明します。従来のセキュリティとIANAの考慮事項により、ドキュメントは終了します。"
    },
    {
      "indent": 3,
      "text": "The protocol is extensible in order to support new PDUs with new semantics, if deployment experience indicates that they are needed. PDUs are versioned should deployment experience call for change.",
      "ja": "展開の経験から必要とされる場合、プロトコルは新しいセマンティクスで新しいPDUをサポートするために拡張可能です。 PDUは、展開の経験から変更が必要になった場合にバージョン管理されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Changes from RFC 6810",
      "section_title": true,
      "ja": "1.2. RFC 6810からの変更"
    },
    {
      "indent": 3,
      "text": "This section summarizes the significant changes between [RFC6810] and the protocol described in this document.",
      "ja": "このセクションでは、[RFC6810]とこのドキュメントで説明されているプロトコルとの間の重要な変更を要約します。"
    },
    {
      "indent": 3,
      "text": "o New Router Key PDU type (Section 5.10) added.",
      "ja": "o 新しいルーターキーPDUタイプ（セクション5.10）が追加されました。"
    },
    {
      "indent": 3,
      "text": "o Explicit timing parameters (Section 5.8, Section 6) added.",
      "ja": "o 明示的なタイミングパラメータ（セクション5.8、セクション6）が追加されました。"
    },
    {
      "indent": 3,
      "text": "o Protocol version number incremented from 0 (zero) to 1 (one).",
      "ja": "o 0（ゼロ）から1（1）に増分されたプロトコルバージョン番号。"
    },
    {
      "indent": 3,
      "text": "o Protocol version number negotiation (Section 7) added.",
      "ja": "o プロトコルバージョン番号のネゴシエーション（セクション7）が追加されました。"
    },
    {
      "indent": 0,
      "text": "2. Glossary",
      "section_title": true,
      "ja": "2. 用語集"
    },
    {
      "indent": 3,
      "text": "The following terms are used with special meaning.",
      "ja": "以下の用語は特別な意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers at the IANA, Regional Internet Registries (RIRs), National Internet Registries (NIRs), and ISPs; see [RFC6481].",
      "ja": "グローバルRPKI：RPKIの信頼できるデータは、IANA、地域インターネットレジストリ（RIR）、国内インターネットレジストリ（NIR）、およびISPのサーバーの分散セットで公開されます。 [RFC6481]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Cache: A cache is a coalesced copy of the published Global RPKI data, periodically fetched or refreshed, directly or indirectly, using the rsync protocol [RFC5781] or some successor. Relying Party software is used to gather and validate the distributed data of the RPKI into a cache. Trusting this cache further is a matter between the provider of the cache and a Relying Party.",
      "ja": "キャッシュ：キャッシュは、公開されたグローバルRPKIデータの結合コピーであり、rsyncプロトコル[RFC5781]またはその後継を使用して、直接または間接的に定期的にフェッチまたはリフレッシュされます。証明書利用者ソフトウェアは、RPKIの分散データを収集してキャッシュに検証するために使用されます。このキャッシュをさらに信頼することは、キャッシュのプロバイダーと依拠当事者の間の問題です。"
    },
    {
      "indent": 3,
      "text": "Serial Number: \"Serial Number\" is a 32-bit strictly increasing unsigned integer which wraps from 2^32-1 to 0. It denotes the logical version of a cache. A cache increments the value when it successfully updates its data from a parent cache or from primary RPKI data. While a cache is receiving updates, new incoming data and implicit deletes are associated with the new serial but MUST NOT be sent until the fetch is complete. A Serial Number is not commensurate between different caches or different protocol versions, nor need it be maintained across resets of the cache server. See [RFC1982] on DNS Serial Number Arithmetic for too much detail on the topic.",
      "ja": "シリアル番号：「シリアル番号」は、32ビットの厳密に増加する符号なし整数で、2 ^ 32-1から0にラップされます。これは、キャッシュの論理バージョンを示します。キャッシュは、親キャッシュまたはプライマリRPKIデータからデータを正常に更新すると、値をインクリメントします。キャッシュが更新を受信して​​いる間、新しい着信データと暗黙的な削除は新しいシリアルに関連付けられますが、フェッチが完了するまで送信してはなりません。シリアル番号は、異なるキャッシュ間または異なるプロトコルバージョン間で釣り合いが取れておらず、キャッシュサーバーのリセット間で維持する必要もありません。このトピックの詳細については、DNSシリアル番号演算の[RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Session ID: When a cache server is started, it generates a Session ID to uniquely identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache.",
      "ja": "セッションID：キャッシュサーバーが起動すると、キャッシュのインスタンスを一意に識別し、キャッシュインスタンスが生成するシリアル番号のシーケンスにバインドするためのセッションIDを生成します。これにより、ルーターは、使用しているシリアル番号がキャッシュのシリアル番号に対応していることを認識して、失敗したセッションを再開できます。"
    },
    {
      "indent": 3,
      "text": "Payload PDU: A payload PDU is a protocol message which contains data for use by the router, as opposed to a PDU which conveys the control mechanisms of this protocol. Prefixes and Router Keys are examples of payload PDUs.",
      "ja": "ペイロードPDU：ペイロードPDUは、このプロトコルの制御メカニズムを伝達するPDUとは対照的に、ルーターが使用するデータを含むプロトコルメッセージです。プレフィックスとルーターキーは、ペイロードPDUの例です。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Structure",
      "section_title": true,
      "ja": "3. 展開構造"
    },
    {
      "indent": 3,
      "text": "Deployment of the RPKI to reach routers has a three-level structure as follows:",
      "ja": "ルーターに到達するためのRPKIの展開は、次の3つのレベルの構造になっています。"
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers at the IANA, RIRs, NIRs, and ISPs (see [RFC6481]).",
      "ja": "グローバルRPKI：RPKIの信頼できるデータは、IANA、RIR、NIR、およびISPのサーバーの分散セットで公開されます（[RFC6481]を参照）。"
    },
    {
      "indent": 3,
      "text": "Local Caches: Local caches are a local set of one or more collected and verified caches of RPKI data. A Relying Party, e.g., router or other client, MUST have a trust relationship with, and a trusted transport channel to, any cache(s) it uses.",
      "ja": "ローカルキャッシュ：ローカルキャッシュは、RPKIデータの1つ以上の収集および検証されたキャッシュのローカルセットです。依存パーティ、たとえばルーターや他のクライアントは、それが使用するすべてのキャッシュとの信頼関係と信頼されたトランスポートチャネルを持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "Routers: A router fetches data from a local cache using the protocol described in this document. It is said to be a client of the cache. There MAY be mechanisms for the router to assure itself of the authenticity of the cache and to authenticate itself to the cache (see Section 9).",
      "ja": "ルーター：ルーターは、このドキュメントで説明されているプロトコルを使用して、ローカルキャッシュからデータをフェッチします。キャッシュのクライアントと言われています。ルータがキャッシュ自体の信頼性を保証し、キャッシュに対して自身を認証するためのメカニズムが存在する場合があります（セクション9を参照）。"
    },
    {
      "indent": 0,
      "text": "4. Operational Overview",
      "section_title": true,
      "ja": "4. 運用の概要"
    },
    {
      "indent": 3,
      "text": "A router establishes and keeps open a connection to one or more caches with which it has client/server relationships. It is configured with a semi-ordered list of caches and establishes a connection to the most preferred cache, or set of caches, which accept the connections.",
      "ja": "ルーターは、クライアント/サーバー関係を持つ1つ以上のキャッシュへの接続を確立し、開いたままにします。キャッシュの半順序リストで構成され、接続を受け入れる最も優先されるキャッシュまたはキャッシュのセットへの接続を確立します。"
    },
    {
      "indent": 3,
      "text": "The router MUST choose the most preferred, by configuration, cache or set of caches so that the operator may control load on their caches and the Global RPKI.",
      "ja": "オペレーターは、キャッシュとグローバルRPKIの負荷を制御できるように、ルーターは構成、キャッシュ、またはキャッシュのセットによって最も好ましいものを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Periodically, the router sends to the cache the most recent Serial Number for which it has received data from that cache, i.e., the router's current Serial Number, in the form of a Serial Query. When a router establishes a new session with a cache or wishes to reset a current relationship, it sends a Reset Query.",
      "ja": "定期的に、ルーターはキャッシュからデータを受け取った最新のシリアル番号、つまりルーターの現在のシリアル番号をシリアルクエリの形式でキャッシュに送信します。ルーターがキャッシュとの新しいセッションを確立したり、現在の関係をリセットしたりすると、リセットクエリが送信されます。"
    },
    {
      "indent": 3,
      "text": "The cache responds to the Serial Query with all data changes which took place since the given Serial Number. This may be the null set, in which case the End of Data PDU (Section 5.8) is still sent. Note that the Serial Number comparison used to determine \"since the given Serial Number\" MUST take wrap-around into account; see [RFC1982].",
      "ja": "キャッシュは、指定されたシリアル番号以降に行われたすべてのデータ変更でシリアルクエリに応答します。これはnullセットである場合があります。その場合、End of Data PDU（セクション5.8）は引き続き送信されます。 「指定されたシリアル番号以降」を決定するために使用されるシリアル番号の比較では、ラップアラウンドを考慮する必要があることに注意してください。 [RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When the router has received all data records from the cache, it sets its current Serial Number to that of the Serial Number in the received End of Data PDU.",
      "ja": "ルーターは、キャッシュからすべてのデータレコードを受信すると、現在のシリアル番号を、受信したデータの終わりPDUのシリアル番号に設定します。"
    },
    {
      "indent": 3,
      "text": "When the cache updates its database, it sends a Notify PDU to every currently connected router. This is a hint that now would be a good time for the router to poll for an update, but it is only a hint. The protocol requires the router to poll for updates periodically in any case.",
      "ja": "キャッシュがデータベースを更新すると、現在接続されているすべてのルーターに通知PDUが送信されます。これは、ルーターが更新をポーリングする良いタイミングですが、それは単なるヒントにすぎません。このプロトコルでは、ルーターが更新を定期的にポーリングする必要があります。"
    },
    {
      "indent": 0,
      "text": " Strictly speaking, a router could track a cache simply by asking for a complete data set every time it updates, but this would be very inefficient. The Serial-Number-based incremental update mechanism allows an efficient transfer of just the data records which have changed since the last update. As with any update protocol based on incremental transfers, the router must be prepared to fall back to a full transfer if for any reason the cache is unable to provide the necessary incremental data. Unlike some incremental transfer protocols, this protocol requires the router to make an explicit request to start the fallback process; this is deliberate, as the cache has no way of knowing whether the router has also established sessions with other caches that may be able to provide better service.",
      "ja": "厳密に言えば、ルーターは更新するたびに完全なデータセットを要求するだけでキャッシュを追跡できますが、これは非常に非効率的です。シリアル番号ベースの増分更新メカニズムにより、前回の更新以降に変更されたデータレコードのみを効率的に転送できます。インクリメンタル転送に基づく更新プロトコルと同様に、何らかの理由でキャッシュが必要なインクリメンタルデータを提供できない場合、ルーターはフル転送にフォールバックする準備をする必要があります。一部のインクリメンタル転送プロトコルとは異なり、このプロトコルでは、ルーターがフォールバックプロセスを開始するための明示的な要求を行う必要があります。これは意図的なものです。キャッシュには、ルーターが他のキャッシュとのセッションも確立しているかどうかを知る方法がないため、より良いサービスを提供できる可能性があるからです。"
    },
    {
      "indent": 3,
      "text": "As a cache server must evaluate certificates and ROAs (Route Origin Authorizations; see [RFC6480]), which are time dependent, servers' clocks MUST be correct to a tolerance of approximately an hour.",
      "ja": "キャッシュサーバーは、時間に依存する証明書とROA（Route Origin Authorizations; [RFC6480]を参照）を評価する必要があるため、サーバーのクロックは約1時間の許容誤差で正確でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Protocol Data Units (PDUs)",
      "section_title": true,
      "ja": "5. プロトコルデータユニット（PDU）"
    },
    {
      "indent": 3,
      "text": "The exchanges between the cache and the router are sequences of exchanges of the following PDUs according to the rules described in Section 8.",
      "ja": "キャッシュとルーター間の交換は、セクション8で説明されているルールに従って、次のPDUの交換シーケンスです。"
    },
    {
      "indent": 3,
      "text": "Reserved fields (marked \"zero\" in PDU diagrams) MUST be zero on transmission and MUST be ignored on receipt.",
      "ja": "予約済みフィールド（PDUダイアグラムで「ゼロ」とマークされている）は、送信時にはゼロである必要があり、受信時には無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Fields of a PDU",
      "section_title": true,
      "ja": "5.1. PDUのフィールド"
    },
    {
      "indent": 3,
      "text": "PDUs contain the following data elements:",
      "ja": "PDUには、次のデータ要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "Protocol Version: An 8-bit unsigned integer, currently 1, denoting the version of this protocol.",
      "ja": "プロトコルバージョン：8ビットの符号なし整数。現在は1で、このプロトコルのバージョンを示します。"
    },
    {
      "indent": 3,
      "text": "PDU Type: An 8-bit unsigned integer, denoting the type of the PDU, e.g., IPv4 Prefix.",
      "ja": "PDUタイプ：8ビットの符号なし整数。IPv4プレフィックスなど、PDUのタイプを示します。"
    },
    {
      "indent": 3,
      "text": "Serial Number: The Serial Number of the RPKI cache when this set of PDUs was received from an upstream cache server or gathered from the Global RPKI. A cache increments its Serial Number when completing a rigorously validated update from a parent cache or the Global RPKI.",
      "ja": "シリアル番号：この一連のPDUが上流のキャッシュサーバーから受信されたとき、またはグローバルRPKIから収集されたときのRPKIキャッシュのシリアル番号。キャッシュは、親キャッシュまたはグローバルRPKIから厳密に検証された更新を完了すると、シリアル番号をインクリメントします。"
    },
    {
      "indent": 0,
      "text": " Session ID: A 16-bit unsigned integer. When a cache server is started, it generates a Session ID to identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache. If, at any time after the protocol version has been negotiated (Section 7), either the router or the cache finds that the value of the Session ID is not the same as the other's, the party which detects the mismatch MUST immediately terminate the session with an Error Report PDU with code 0 (\"Corrupt Data\"), and the router MUST flush all data learned from that cache.",
      "ja": "セッションID：16ビットの符号なし整数。キャッシュサーバーが起動すると、キャッシュのインスタンスを識別し、それをキャッシュインスタンスが生成するシリアル番号のシーケンスにバインドするためのセッションIDを生成します。これにより、ルーターは、使用しているシリアル番号がキャッシュのシリアル番号に対応していることを認識して、失敗したセッションを再開できます。プロトコルバージョンがネゴシエートされた後（セクション7）、ルーターまたはキャッシュのいずれかがセッションIDの値が他のものと同じでないことを検出した場合、不一致を検出したパーティは直ちにセッションを終了する必要があります。コード0（「破損データ」）のエラーレポートPDUを使用し、ルーターはそのキャッシュから学習したすべてのデータをフラッシュする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that sessions are specific to a particular protocol version. That is, if a cache server supports multiple versions of this protocol, happens to use the same Session ID value for multiple protocol versions, and further happens to use the same Serial Number values for two or more sessions using the same Session ID but different Protocol Version values, the Serial Numbers are not commensurate. The full test for whether Serial Numbers are commensurate requires comparing Protocol Version, Session ID, and Serial Number. To reduce the risk of confusion, cache servers SHOULD NOT use the same Session ID across multiple protocol versions, but even if they do, routers MUST treat sessions with different Protocol Version fields as separate sessions even if they do happen to have the same Session ID.",
      "ja": "セッションは特定のプロトコルバージョンに固有であることに注意してください。つまり、キャッシュサーバーがこのプロトコルの複数のバージョンをサポートし、複数のプロトコルバージョンに同じセッションID値を使用し、さらに、同じセッションIDを使用するが異なるプロトコルを使用する2つ以上のセッションに同じシリアル番号値を使用する場合バージョン値、シリアル番号は相応ではありません。シリアル番号が釣り合っているかどうかを完全にテストするには、プロトコルバージョン、セッションID、シリアル番号を比較する必要があります。混乱のリスクを減らすために、キャッシュサーバーは複数のプロトコルバージョン間で同じセッションIDを使用しないでください（SHOULD NOT）。ただし、たとえそれらが使用されたとしても、ルーターは、たとえ同じセッションIDがたまたまあるとしても、異なるプロトコルバージョンフィールドを持つセッションを別個のセッションとして扱わなければなりません。"
    },
    {
      "indent": 6,
      "text": "Should a cache erroneously reuse a Session ID so that a router does not realize that the session has changed (old Session ID and new Session ID have the same numeric value), the router may become confused as to the content of the cache. The time it takes the router to discover that it is confused will depend on whether the Serial Numbers are also reused. If the Serial Numbers in the old and new sessions are different enough, the cache will respond to the router's Serial Query with a Cache Reset, which will solve the problem. If, however, the Serial Numbers are close, the cache may respond with a Cache Response, which may not be enough to bring the router into sync. In such cases, it's likely but not certain that the router will detect some discrepancy between the state that the cache expects and its own state. For example, the Cache Response may tell the router to drop a record which the router does not hold or may tell the router to add a record which the router already has. In such cases, a router will detect the error and reset the session. The one case in which the router may stay out of sync is when nothing in the Cache Response contradicts any data currently held by the router.",
      "ja": "キャッシュが誤ってセッションIDを再利用して、ルーターがセッションの変更を認識しない場合（古いセッションIDと新しいセッションIDの数値が同じ）、ルーターはキャッシュの内容に関して混乱する可能性があります。ルーターが混乱していることをルーターが検出するのにかかる時間は、シリアル番号も再利用されるかどうかによって異なります。古いセッションと新しいセッションのシリアル番号が十分に異なる場合、キャッシュはルーターのシリアルクエリにキャッシュリセットで応答し、問題を解決します。ただし、シリアル番号が近い場合、キャッシュはキャッシュ応答で応答する可能性があり、ルーターを同期させるのに十分ではない可能性があります。このような場合、キャッシュが予期する状態とそれ自身の状態との間の何らかの不一致をルーターが検出する可能性は高いですが、確実ではありません。たとえば、キャッシュ応答は、ルーターが保持していないレコードをドロップするようにルーターに指示したり、ルーターがすでに持っているレコードを追加するようにルーターに指示したりする場合があります。このような場合、ルーターはエラーを検出してセッションをリセットします。ルーターが同期していない可能性がある1つのケースは、キャッシュ応答の何も現在ルーターが保持しているデータと矛盾しない場合です。"
    },
    {
      "indent": 6,
      "text": "Using persistent storage for the Session ID or a clock-based scheme for generating Session IDs should avoid the risk of Session ID collisions.",
      "ja": "セッションIDの永続的なストレージ、またはセッションIDの生成に時間ベースのスキームを使用すると、セッションIDの衝突のリスクを回避できます。"
    },
    {
      "indent": 6,
      "text": "The Session ID might be a pseudorandom value, a strictly increasing value if the cache has reliable storage, et cetera. A seconds-since-epoch timestamp value such as the POSIX time() function makes a good Session ID value.",
      "ja": "セッションIDは、疑似ランダム値である可能性があります。キャッシュに信頼できるストレージがある場合、厳密に増加する値などです。 POSIX time()関数などの秒からのエポックタイムスタンプ値は、適切なセッションID値になります。"
    },
    {
      "indent": 3,
      "text": "Length: A 32-bit unsigned integer which has as its value the count of the bytes in the entire PDU, including the 8 bytes of header which includes the length field.",
      "ja": "長さ：32ビットの符号なし整数。その値として、長さフィールドを含むヘッダーの8バイトを含む、PDU全体のバイト数が含まれます。"
    },
    {
      "indent": 3,
      "text": "Flags: The lowest-order bit of the Flags field is 1 for an announcement and 0 for a withdrawal. For a Prefix PDU (IPv4 or IPv6), the flag indicates whether this PDU announces a new right to announce the prefix or withdraws a previously announced right; a withdraw effectively deletes one previously announced Prefix PDU with the exact same Prefix, Length, Max-Len, and Autonomous System Number (ASN). Similarly, for a Router Key PDU, the flag indicates whether this PDU announces a new Router Key or deletes one previously announced Router Key PDU with the exact same AS Number, subjectKeyIdentifier, and subjectPublicKeyInfo.",
      "ja": "フラグ：フラグフィールドの最下位ビットは、アナウンスの場合は1、取り下げの場合は0です。プレフィックスPDU（IPv4またはIPv6）の場合、フラグは、このPDUがプレフィックスを発表する新しい権利を発表するか、以前に発表された権利を撤回するかを示します。 withdrawは、プレフィックス、長さ、最大長、および自律システム番号（ASN）がまったく同じ、以前に発表された1つのプレフィックスPDUを効果的に削除します。同様に、ルーターキーPDUの場合、フラグは、このPDUが新しいルーターキーをアナウンスするか、まったく同じAS番号、subjectKeyIdentifier、subjectPublicKeyInfoを持つ以前にアナウンスされたルーターキーPDUを削除するかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "The remaining bits in the Flags field are reserved for future use. In protocol version 1, they MUST be zero on transmission and MUST be ignored on receipt.",
      "ja": "Flagsフィールドの残りのビットは、将来の使用のために予約されています。プロトコルバージョン1では、送信時にゼロでなければならず、受信時に無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix Length: An 8-bit unsigned integer denoting the shortest prefix allowed by the Prefix element.",
      "ja": "接頭辞の長さ：Prefix要素で許可される最短の接頭辞を示す8ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Max Length: An 8-bit unsigned integer denoting the longest prefix allowed by the Prefix element. This MUST NOT be less than the Prefix Length element.",
      "ja": "最大長：Prefix要素で許可される最長のプレフィックスを示す8ビットの符号なし整数。これは、接頭辞の長さの要素より短くしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix: The IPv4 or IPv6 prefix of the ROA.",
      "ja": "プレフィックス：ROAのIPv4またはIPv6プレフィックス。"
    },
    {
      "indent": 3,
      "text": "Autonomous System Number: A 32-bit unsigned integer representing an ASN allowed to announce a prefix or associated with a router key.",
      "ja": "自律システム番号：プレフィックスのアナウンスが許可されている、またはルーターのキーに関連付けられているASNを表す32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Subject Key Identifier: 20-octet Subject Key Identifier (SKI) value of a router key, as described in [RFC6487].",
      "ja": "[RFC6487]で説明されているように、サブジェクトキー識別子：ルータキーの20オクテットサブジェクトキー識別子（SKI）値。"
    },
    {
      "indent": 3,
      "text": "Subject Public Key Info: A router key's subjectPublicKeyInfo value, as described in [RFC8208]. This is the full ASN.1 DER encoding of the subjectPublicKeyInfo, including the ASN.1 tag and length values of the subjectPublicKeyInfo SEQUENCE.",
      "ja": "[RFC8208]で説明されているように、サブジェクト公開鍵情報：ルーターキーのsubjectPublicKeyInfo値。これは、subjectPublicKeyInfoの完全なASN.1 DERエンコードであり、subjectPublicKeyInfo SEQUENCEのASN.1タグと長さの値を含みます。"
    },
    {
      "indent": 3,
      "text": "Refresh Interval: Interval between normal cache polls. See Section 6.",
      "ja": "リフレッシュ間隔：通常のキャッシュポーリングの間隔。セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Retry Interval: Interval between cache poll retries after a failed cache poll. See Section 6.",
      "ja": "再試行間隔：失敗したキャッシュポーリング後のキャッシュポーリングの再試行間隔。セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Expire Interval: Interval during which data fetched from a cache remains valid in the absence of a successful subsequent cache poll. See Section 6.",
      "ja": "Expire Interval：後続のキャッシュポーリングが成功しない場合に、キャッシュからフェッチされたデータが有効なままになる間隔。セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2. Serial Notify",
      "section_title": true,
      "ja": "5.2. シリアル通知"
    },
    {
      "indent": 3,
      "text": "The cache notifies the router that the cache has new data.",
      "ja": "キャッシュは、キャッシュに新しいデータがあることをルーターに通知します。"
    },
    {
      "indent": 3,
      "text": "The Session ID reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、シリアル番号が釣り合っていること、つまりキャッシュセッションが変更されていないことをルーターに保証します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a Serial Notify PDU, the router MAY issue an immediate Serial Query (Section 5.3) or Reset Query (Section 5.4) without waiting for the Refresh Interval timer (see Section 6) to expire.",
      "ja": "ルーターは、シリアル通知PDUを受信すると、リフレッシュ間隔タイマー（セクション6を参照）が期限切れになるのを待たずに、即時シリアルクエリ（セクション5.3）またはリセットクエリ（セクション5.4）を発行できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "Serial Notify is the only message that the cache can send that is not in response to a message from the router.",
      "ja": "シリアル通知は、ルーターからのメッセージに応答しない、キャッシュが送信できる唯一のメッセージです。"
    },
    {
      "indent": 3,
      "text": "If the router receives a Serial Notify PDU during the initial startup period where the router and cache are still negotiating to agree on a protocol version, the router MUST simply ignore the Serial Notify PDU, even if the Serial Notify PDU is for an unexpected protocol version. See Section 7 for details.",
      "ja": "ルーターとキャッシュがプロトコルバージョンについて合意するためにまだ交渉している最初の起動期間中にルーターがシリアル通知PDUを受信する場合、シリアル通知PDUが予期しないプロトコルバージョン用であっても、ルーターはシリアル通知PDUを単に無視しなければなりません（MUST）。 。詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    0     |                     |\n+-------------------------------------------+\n|                                           |\n|                Length=12                  |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. Serial Query",
      "section_title": true,
      "ja": "5.3. シリアルクエリ"
    },
    {
      "indent": 3,
      "text": "The router sends a Serial Query to ask the cache for all announcements and withdrawals which have occurred since the Serial Number specified in the Serial Query.",
      "ja": "ルータはシリアルクエリを送信して、シリアルクエリで指定されたシリアル番号以降に発生したすべてのアナウンスと引き出しをキャッシュに要求します。"
    },
    {
      "indent": 3,
      "text": "The cache replies to this query with a Cache Response PDU (Section 5.5) if the cache has a (possibly null) record of the changes since the Serial Number specified by the router, followed by zero or more payload PDUs and an End Of Data PDU (Section 5.8).",
      "ja": "キャッシュには、ルーターによって指定されたシリアル番号以降の変更の（おそらくnull）レコードがあり、その後に0個以上のペイロードPDUとデータの終わりPDUが続く場合、キャッシュ応答PDU（セクション5.5）でこのクエリに応答します。 （セクション5.8）。"
    },
    {
      "indent": 3,
      "text": "When replying to a Serial Query, the cache MUST return the minimum set of changes needed to bring the router into sync with the cache. That is, if a particular prefix or router key underwent multiple changes between the Serial Number specified by the router and the cache's current Serial Number, the cache MUST merge those changes to present the simplest possible view of those changes to the router. In general, this means that, for any particular prefix or router key, the data stream will include at most one withdrawal followed by at most one announcement, and if all of the changes cancel out, the data stream will not mention the prefix or router key at all.",
      "ja": "シリアルクエリに応答する場合、キャッシュは、ルーターをキャッシュと同期させるために必要な変更の最小セットを返す必要があります。つまり、特定のプレフィックスまたはルーターのキーがルーターによって指定されたシリアル番号とキャッシュの現在のシリアル番号との間で複数の変更を受けた場合、キャッシュはそれらの変更をマージして、ルーターに対するそれらの変更の可能な最も単純なビューを提示する必要があります。一般に、これは、特定のプレフィックスまたはルーターキーの場合、データストリームには最大で1つの撤回とそれに続く最大1つのアナウンスが含まれ、すべての変更がキャンセルされた場合、データストリームにはプレフィックスまたはルーターが含まれないまったくキー。"
    },
    {
      "indent": 3,
      "text": "The rationale for this approach is that the entire purpose of the RPKI-Router protocol is to offload work from the router to the cache, and it should therefore be the cache's job to simplify the change set, thus reducing work for the router.",
      "ja": "このアプローチの理論的根拠は、RPKI-Routerプロトコルの全体の目的がルーターからキャッシュへの作業の負荷を軽減することであり、したがって、変更セットを単純化してルーターの作業を減らすのはキャッシュの仕事であるべきです。"
    },
    {
      "indent": 3,
      "text": "If the cache does not have the data needed to update the router, perhaps because its records do not go back to the Serial Number in the Serial Query, then it responds with a Cache Reset PDU (Section 5.9).",
      "ja": "ルータの更新に必要なデータがキャッシュにない場合、おそらくそのクエリがシリアルクエリのシリアル番号に戻らないため、キャッシュリセットPDUで応答します（セクション5.9）。"
    },
    {
      "indent": 3,
      "text": "The Session ID tells the cache what instance the router expects to ensure that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、シリアル番号が釣り合っていることを保証するためにルーターが期待するインスタンスをキャッシュに通知します。つまり、キャッシュセッションは変更されていません。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    1     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=12                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.4. Reset Query",
      "section_title": true,
      "ja": "5.4. クエリをリセット"
    },
    {
      "indent": 3,
      "text": "The router tells the cache that it wants to receive the total active, current, non-withdrawn database. The cache responds with a Cache Response PDU (Section 5.5), followed by zero or more payload PDUs and an End of Data PDU (Section 5.8).",
      "ja": "ルーターは、アクティブで現在の非撤回データベースの合計を受信することをキャッシュに通知します。キャッシュは、キャッシュ応答PDU（セクション5.5）で応答し、その後に0個以上のペイロードPDUとデータの終わりPDU（セクション5.8）が続きます。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    2     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.5. Cache Response",
      "section_title": true,
      "ja": "5.5. キャッシュ応答"
    },
    {
      "indent": 3,
      "text": "The cache responds to queries with zero or more payload PDUs. When replying to a Serial Query (Section 5.3), the cache sends the set of announcements and withdrawals that have occurred since the Serial Number sent by the client router. When replying to a Reset Query (Section 5.4), the cache sends the set of all data records it has; in this case, the withdraw/announce field in the payload PDUs MUST have the value 1 (announce).",
      "ja": "キャッシュは、0個以上のペイロードPDUでクエリに応答します。シリアルクエリ（セクション5.3）に応答するとき、キャッシュは、クライアントルーターが送信したシリアル番号以降に発生した一連のアナウンスと取り消しを送信します。リセットクエリ（セクション5.4）に応答するとき、キャッシュはキャッシュにあるすべてのデータレコードのセットを送信します。この場合、ペイロードPDUのwithdraw / announceフィールドの値は1（announce）である必要があります。"
    },
    {
      "indent": 3,
      "text": "In response to a Reset Query, the new value of the Session ID tells the router the instance of the cache session for future confirmation. In response to a Serial Query, the Session ID being the same reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "リセットクエリに応答して、セッションIDの新しい値は、将来の確認のためにキャッシュセッションのインスタンスをルーターに通知します。シリアルクエリに応じて、セッションIDが同じであることにより、シリアル番号が釣り合っていること、つまりキャッシュセッションが変更されていないことをルーターに保証します。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    3     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.6. IPv4 Prefix",
      "section_title": true,
      "ja": "5.6. IPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    4     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=20                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |   0..32  |   0..32  |          |\n+-------------------------------------------+\n|                                           |\n|                IPv4 Prefix                |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The lowest-order bit of the Flags field is 1 for an announcement and 0 for a withdrawal.",
      "ja": "Flagsフィールドの最下位ビットは、アナウンスの場合は1、取り下げの場合は0です。"
    },
    {
      "indent": 3,
      "text": "In the RPKI, nothing prevents a signing certificate from issuing two identical ROAs. In this case, there would be no semantic difference between the objects, merely a process redundancy.",
      "ja": "RPKIでは、署名証明書が2つの同一のROAを発行することを妨げるものはありません。この場合、オブジェクト間に意味的な違いはなく、単にプロセスの冗長性があります。"
    },
    {
      "indent": 3,
      "text": "In the RPKI, there is also an actual need for what might appear to a router as identical IPvX PDUs. This can occur when an upstream certificate is being reissued or there is an address ownership transfer up the validation chain. The ROA would be identical in the router sense, i.e., have the same {Prefix, Len, Max-Len, ASN}, but it would have a different validation path in the RPKI. This is important to the RPKI but not to the router.",
      "ja": "RPKIでは、同一のIPvX PDUとしてルーターから見えるものに対する実際のニーズもあります。これは、上流の証明書が再発行されている場合、または検証チェーンの上位にアドレス所有権が転送されている場合に発生する可能性があります。 ROAはルーターの意味で同一、つまり{Prefix、Len、Max-Len、ASN}は同じですが、RPKIでの検証パスは異なります。これはRPKIにとって重要ですが、ルーターにとっては重要ではありません。"
    },
    {
      "indent": 3,
      "text": "The cache server MUST ensure that it has told the router client to have one and only one IPvX PDU for a unique {Prefix, Len, Max-Len, ASN} at any one point in time. Should the router client receive an IPvX PDU with a {Prefix, Len, Max-Len, ASN} identical to one it already has active, it SHOULD raise a Duplicate Announcement Received error.",
      "ja": "キャッシュサーバーは、ルータークライアントに一意の{Prefix、Len、Max-Len、ASN}のIPvX PDUを1つだけ持つように指示したことを確認する必要があります。ルータクライアントが、すでにアクティブになっているものと同じ{Prefix、Len、Max-Len、ASN}を持つIPvX PDUを受信した場合、Duplicate Announcement Receivedエラーを発生させる必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7. IPv6 Prefix",
      "section_title": true,
      "ja": "5.7. IPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    6     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=32                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |  0..128  |  0..128  |          |\n+-------------------------------------------+\n|                                           |\n+---                                     ---+\n|                                           |\n+---            IPv6 Prefix              ---+\n|                                           |\n+---                                     ---+\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Analogous to the IPv4 Prefix PDU, it has 96 more bits and no magic.",
      "ja": "IPv4プレフィックスPDUと同様に、96ビット以上あり、魔法はありません。"
    },
    {
      "indent": 0,
      "text": "5.8. End of Data",
      "section_title": true,
      "ja": "5.8. データの終わり"
    },
    {
      "indent": 3,
      "text": "The cache tells the router it has no more data for the request.",
      "ja": "キャッシュは、要求に対してデータがなくなったことをルーターに通知します。"
    },
    {
      "indent": 3,
      "text": "The Session ID and Protocol Version MUST be the same as that of the corresponding Cache Response which began the (possibly null) sequence of payload PDUs.",
      "ja": "セッションIDとプロトコルバージョンは、ペイロードPDUのシーケンス（nullの可能性があります）を開始した対応するキャッシュ応答のものと同じでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    7     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=24                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Refresh Interval             |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Retry Interval              |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Expire Interval              |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Refresh Interval, Retry Interval, and Expire Interval are all 32-bit elapsed times measured in seconds. They express the timing parameters which the cache expects the router to use in deciding when to send subsequent Serial Query or Reset Query PDUs to the cache. See Section 6 for an explanation of the use and the range of allowed values for these parameters.",
      "ja": "更新間隔、再試行間隔、および有効期限間隔はすべて、秒単位で測定される32ビットの経過時間です。これらは、キャッシュがルーターに後続のシリアルクエリPDUまたはリセットクエリPDUをキャッシュに送信するタイミングを決定する際に使用することを期待するタイミングパラメータを表します。これらのパラメーターの使用法と許容値の範囲については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.9. Cache Reset",
      "section_title": true,
      "ja": "5.9. キャッシュリセット"
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query informing the router that the cache cannot provide an incremental update starting from the Serial Number specified by the router. The router must decide whether to issue a Reset Query or switch to a different cache.",
      "ja": "キャッシュは、ルーターが指定したシリアル番号から始まるインクリメンタルアップデートを提供できないことをルーターに通知するシリアルクエリに応答する場合があります。ルーターは、リセットクエリを発行するか、別のキャッシュに切り替えるかを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    8     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.10. Router Key",
      "section_title": true,
      "ja": "5.10. ルーターキー"
    },
    {
      "indent": 0,
      "text": "   0          8          16         24        31\n   .-------------------------------------------.\n   | Protocol |   PDU    |          |          |\n   | Version  |   Type   |   Flags  |   zero   |\n   |    1     |    9     |          |          |\n   +-------------------------------------------+\n   |                                           |\n   |                  Length                   |\n   |                                           |\n   +-------------------------------------------+\n   |                                           |\n   +---                                     ---+\n   |          Subject Key Identifier           |\n   +---                                     ---+\n   |                                           |\n   +---                                     ---+\n   |                (20 octets)                |\n   +---                                     ---+\n   |                                           |\n   +-------------------------------------------+\n   |                                           |\n   |                 AS Number                 |\n   |                                           |\n   +-------------------------------------------+\n   |                                           |\n   |          Subject Public Key Info          |\n   |                                           |\n   `-------------------------------------------'\n   The lowest-order bit of the Flags field is 1 for an announcement and\n   0 for a withdrawal.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache server MUST ensure that it has told the router client to have one and only one Router Key PDU for a unique {SKI, ASN, Subject Public Key} at any one point in time. Should the router client receive a Router Key PDU with a {SKI, ASN, Subject Public Key} identical to one it already has active, it SHOULD raise a Duplicate Announcement Received error.",
      "ja": "キャッシュサーバーは、ルータークライアントに、一意の{SKI、ASN、サブジェクト公開キー}のルーターキーPDUを1つだけ持つように指示したことを確認する必要があります。ルータークライアントが、既にアクティブになっているものと同じ{SKI、ASN、サブジェクト公開キー}を含むルーターキーPDUを受信した場合、Duplicate Announcement Receivedエラーを発生させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that a particular ASN may appear in multiple Router Key PDUs with different Subject Public Key values, while a particular Subject Public Key value may appear in multiple Router Key PDUs with different ASNs. In the interest of keeping the announcement and withdrawal semantics as simple as possible for the router, this protocol makes no attempt to compress either of these cases.",
      "ja": "特定のASNが異なるサブジェクト公開キー値を持つ複数のルーターキーPDUに表示される場合がある一方、特定のサブジェクト公開キー値が異なるASNを持つ複数のルーターキーPDUに表示される場合があることに注意してください。アナウンスと取り消しのセマンティクスをルーターで可能な限りシンプルに保つために、このプロトコルはこれらのどちらのケースも圧縮しようとしません。"
    },
    {
      "indent": 3,
      "text": "Also note that it is possible, albeit very unlikely, for multiple distinct Subject Public Key values to hash to the same SKI. For this reason, implementations MUST compare Subject Public Key values as well as SKIs when detecting duplicate PDUs.",
      "ja": "また、非常にまれですが、複数の異なるサブジェクト公開鍵の値が同じSKIにハッシュされる可能性があることにも注意してください。このため、実装では、重複するPDUを検出するときに、サブジェクトの公開鍵の値とSKIを比較する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.11. Error Report",
      "section_title": true,
      "ja": "5.11. エラーレポート"
    },
    {
      "indent": 3,
      "text": "This PDU is used by either party to report an error to the other.",
      "ja": "このPDUは、どちらか一方が他方にエラーを報告するために使用します。"
    },
    {
      "indent": 3,
      "text": "Error reports are only sent as responses to other PDUs, not to report errors in Error Report PDUs.",
      "ja": "エラーレポートは他のPDUへの応答としてのみ送信され、エラーレポートPDUでエラーを報告することはありません。"
    },
    {
      "indent": 3,
      "text": "Error codes are described in Section 12.",
      "ja": "エラーコードについては、セクション12で説明します。"
    },
    {
      "indent": 3,
      "text": "If the error is generic (e.g., \"Internal Error\") and not associated with the PDU to which it is responding, the Erroneous PDU field MUST be empty and the Length of Encapsulated PDU field MUST be zero.",
      "ja": "エラーが一般的であり（「内部エラー」など）、それが応答しているPDUに関連付けられていない場合、エラーのあるPDUフィールドは空でなければならず、カプセル化されたPDUフィールドの長さはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An Error Report PDU MUST NOT be sent for an Error Report PDU. If an erroneous Error Report PDU is received, the session SHOULD be dropped.",
      "ja": "Error Report PDUに対してError Report PDUを送信してはならない（MUST NOT）。誤ったエラーレポートPDUを受信した場合、セッションをドロップする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If the error is associated with a PDU of excessive length, i.e., too long to be any legal PDU other than another Error Report, or a possibly corrupt length, the Erroneous PDU field MAY be truncated.",
      "ja": "エラーが長すぎるPDU、つまり長すぎて別のエラーレポート以外の正当なPDUにならない場合、または長さが破損している可能性がある場合、エラーPDUフィールドは切り捨てられる場合があります。"
    },
    {
      "indent": 3,
      "text": "The diagnostic text is optional; if not present, the Length of Error Text field MUST be zero. If error text is present, it MUST be a string in UTF-8 encoding (see [RFC3629]).",
      "ja": "診断テキストはオプションです。存在しない場合、Length of Error Textフィールドはゼロでなければなりません。エラーテキストが存在する場合は、UTF-8エンコーディングの文字列である必要があります（[RFC3629]を参照）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Error Code      |\n|    1     |    10    |                     |\n+-------------------------------------------+\n|                                           |\n|                  Length                   |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|       Length of Encapsulated PDU          |\n|                                           |\n+-------------------------------------------+\n|                                           |\n~               Erroneous PDU               ~\n|                                           |\n+-------------------------------------------+\n|                                           |\n|           Length of Error Text            |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Arbitrary Text               |\n|                    of                     |\n~          Error Diagnostic Message         ~\n|                                           |\n`-------------------------------------------'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Protocol Timing Parameters",
      "section_title": true,
      "ja": "6. プロトコルタイミングパラメータ"
    },
    {
      "indent": 3,
      "text": "Since the data the cache distributes via the RPKI-Router protocol are retrieved from the Global RPKI system at intervals which are only known to the cache, only the cache can really know how frequently it makes sense for the router to poll the cache, or how long the data are likely to remain valid (or, at least, unchanged). For this reason, as well as to allow the cache some control over the load placed on it by its client routers, the End Of Data PDU includes three values that allow the cache to communicate timing parameters to the router:",
      "ja": "RPKI-Routerプロトコルを介してキャッシュが配信するデータは、グローバルRPKIシステムから、キャッシュだけが認識している間隔で取得されるため、ルーターがキャッシュをポーリングする頻度、またはデータが有効なままである可​​能性が高い（または、少なくとも変更されていない）。このため、クライアントのルーターによってキャッシュにかかる負荷をキャッシュである程度制御できるようにするために、データの終わりPDUには、キャッシュがルーターにタイミングパラメーターを通信できるようにする3つの値が含まれています。"
    },
    {
      "indent": 0,
      "text": " Refresh Interval: This parameter tells the router how long to wait before next attempting to poll the cache and between subsequent attempts, using a Serial Query or Reset Query PDU. The router SHOULD NOT poll the cache sooner than indicated by this parameter. Note that receipt of a Serial Notify PDU overrides this interval and suggests that the router issue an immediate query without waiting for the Refresh Interval to expire. Countdown for this timer starts upon receipt of the containing End Of Data PDU.",
      "ja": "更新間隔：このパラメーターは、シリアルクエリPDUまたはリセットクエリPDUを使用して、次回のキャッシュポーリングを試行するまで、および後続の試行の間に待機する時間をルーターに指示します。ルータは、このパラメータで示されるよりも早くキャッ​​シュをポーリングするべきではありません。シリアル通知PDUの受信はこの間隔を上書きし、ルーターが更新間隔の期限が切れるのを待たずに即時クエリを発行することを提案することに注意してください。このタイマーのカウントダウンは、含まれているデータの終わりPDUを受信すると開始されます。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 1 second.",
      "ja": "最小許容値：1秒。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 86400 seconds (1 day).",
      "ja": "最大許容値：86400秒（1日）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 3600 seconds (1 hour).",
      "ja": "推奨デフォルト：3600秒（1時間）。"
    },
    {
      "indent": 3,
      "text": "Retry Interval: This parameter tells the router how long to wait before retrying a failed Serial Query or Reset Query. The router SHOULD NOT retry sooner than indicated by this parameter. Note that a protocol version mismatch overrides this interval: if the router needs to downgrade to a lower protocol version number, it MAY send the first Serial Query or Reset Query immediately. Countdown for this timer starts upon failure of the query and restarts after each subsequent failure until a query succeeds.",
      "ja": "再試行間隔：このパラメータは、失敗したシリアルクエリまたはリセットクエリを再試行する前に待機する時間をルータに指示します。ルータは、このパラメータで示されるよりも早く再試行すべきではありません。プロトコルバージョンの不一致がこの間隔を上書きすることに注意してください。ルーターをより低いプロトコルバージョン番号にダウングレードする必要がある場合、最初のシリアルクエリまたはリセットクエリをすぐに送信できます（MAY）。このタイマーのカウントダウンは、クエリが失敗すると開始され、クエリが成功するまで、その後の失敗ごとに再開されます。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 1 second.",
      "ja": "最小許容値：1秒。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 7200 seconds (2 hours).",
      "ja": "最大許容値：7200秒（2時間）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 600 seconds (10 minutes).",
      "ja": "推奨デフォルト：600秒（10分）。"
    },
    {
      "indent": 3,
      "text": "Expire Interval: This parameter tells the router how long it can continue to use the current version of the data while unable to perform a successful subsequent query. The router MUST NOT retain the data past the time indicated by this parameter. Countdown for this timer starts upon receipt of the containing End Of Data PDU.",
      "ja": "Expire Interval：このパラメータは、後続のクエリを正常に実行できずに、現在のバージョンのデータを継続して使用できる時間をルータに通知します。ルーターは、このパラメーターで示された時間を過ぎたデータを保持してはなりません（MUST NOT）。このタイマーのカウントダウンは、含まれているデータの終わりPDUを受信すると開始されます。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 600 seconds (10 minutes).",
      "ja": "最小許容値：600秒（10分）。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 172800 seconds (2 days).",
      "ja": "最大許容値：172800秒（2日）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 7200 seconds (2 hours).",
      "ja": "推奨デフォルト：7200秒（2時間）。"
    },
    {
      "indent": 3,
      "text": "If the router has never issued a successful query against a particular cache, it SHOULD retry periodically using the default Retry Interval, above.",
      "ja": "ルータが特定のキャッシュに対して成功したクエリを発行したことがない場合、上記のデフォルトの再試行間隔を使用して定期的に再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Caches MUST set Expire Interval to a value larger than either Refresh Interval or Retry Interval.",
      "ja": "キャッシュは、有効期限間隔を更新間隔または再試行間隔よりも大きい値に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Version Negotiation",
      "section_title": true,
      "ja": "7. プロトコルバージョンネゴシエーション"
    },
    {
      "indent": 3,
      "text": "A router MUST start each transport connection by issuing either a Reset Query or a Serial Query. This query will tell the cache which version of this protocol the router implements.",
      "ja": "ルーターは、リセットクエリまたはシリアルクエリを発行して、各トランスポート接続を開始する必要があります。このクエリは、ルーターが実装するこのプロトコルのバージョンをキャッシュに通知します。"
    },
    {
      "indent": 3,
      "text": "If a cache which supports version 1 receives a query from a router which specifies version 0, the cache MUST downgrade to protocol version 0 [RFC6810] or send a version 1 Error Report PDU with Error Code 4 (\"Unsupported Protocol Version\") and terminate the connection.",
      "ja": "バージョン1をサポートするキャッシュがバージョン0を指定するルーターからクエリを受信する場合、キャッシュはプロトコルバージョン0 [RFC6810]にダウングレードするか、エラーコード4（「サポートされていないプロトコルバージョン」）でバージョン1エラーレポートPDUを送信して終了する必要があります。接続。"
    },
    {
      "indent": 3,
      "text": "If a router which supports version 1 sends a query to a cache which only supports version 0, one of two things will happen:",
      "ja": "バージョン1をサポートするルーターが、バージョン0のみをサポートするキャッシュにクエリを送信すると、次の2つのいずれかが発生します。"
    },
    {
      "indent": 3,
      "text": "1. The cache may terminate the connection, perhaps with a version 0 Error Report PDU. In this case, the router MAY retry the connection using protocol version 0.",
      "ja": "1. キャッシュは、おそらくバージョン0のエラーレポートPDUで接続を終了する可能性があります。この場合、ルーターはプロトコルバージョン0を使用して接続を再試行する場合があります。"
    },
    {
      "indent": 3,
      "text": "2. The cache may reply with a version 0 response. In this case, the router MUST either downgrade to version 0 or terminate the connection.",
      "ja": "2. キャッシュはバージョン0応答で応答する場合があります。この場合、ルーターはバージョン0にダウングレードするか、接続を終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "In any of the downgraded combinations above, the new features of version 1 will not be available, and all PDUs will have 0 in their version fields.",
      "ja": "上記のダウングレードされた組み合わせのいずれでも、バージョン1の新機能は使用できなくなり、すべてのPDUのバージョンフィールドに0が含まれます。"
    },
    {
      "indent": 3,
      "text": "If either party receives a PDU containing an unrecognized Protocol Version (neither 0 nor 1) during this negotiation, it MUST either downgrade to a known version or terminate the connection, with an Error Report PDU unless the received PDU is itself an Error Report PDU.",
      "ja": "このネゴシエーション中にいずれかの当事者が認識されないプロトコルバージョン（0でも1でもない）を含むPDUを受信した場合、受信したPDU自体がエラーレポートPDUでない限り、既知のバージョンにダウングレードするか、接続を終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "The router MUST ignore any Serial Notify PDUs it might receive from the cache during this initial startup period, regardless of the Protocol Version field in the Serial Notify PDU. Since Session ID and Serial Number values are specific to a particular protocol version, the values in the notification are not useful to the router. Even if these values were meaningful, the only effect that processing the notification would have would be to trigger exactly the same Reset Query or Serial Query that the router has already sent as part of the not-yet-complete version negotiation process, so there is nothing to be gained by processing notifications until version negotiation completes.",
      "ja": "ルーターは、シリアル通知PDUのプロトコルバージョンフィールドに関係なく、この初期起動期間中にキャッシュから受信するシリアル通知PDUを無視する必要があります。セッションIDとシリアル番号の値は特定のプロトコルバージョンに固有であるため、通知の値はルーターには役立ちません。これらの値に意味がある場合でも、通知を処理することによる唯一の影響は、ルーターがまだ完了していないバージョンネゴシエーションプロセスの一部として送信したものとまったく同じリセットクエリまたはシリアルクエリをトリガーすることだけなので、バージョンネゴシエーションが完了するまで通知を処理しても何も得られません。"
    },
    {
      "indent": 3,
      "text": "Caches SHOULD NOT send Serial Notify PDUs before version negotiation completes. Routers, however, MUST handle such notifications (by ignoring them) for backwards compatibility with caches serving protocol version 0.",
      "ja": "キャッシュは、バージョンネゴシエーションが完了する前にシリアル通知PDUを送信してはなりません（SHOULD NOT）。ただし、ルーターは、プロトコルバージョン0を提供するキャッシュとの下位互換性のために、そのような通知を（無視して）処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the cache and router have agreed upon a Protocol Version via the negotiation process above, that version is stable for the life of the session. See Section 5.1 for a discussion of the interaction between Protocol Version and Session ID.",
      "ja": "キャッシュとルーターが上記のネゴシエーションプロセスを介してプロトコルバージョンに合意すると、そのバージョンはセッションの存続期間中安定します。プロトコルバージョンとセッションIDの相互作用については、セクション5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "If either party receives a PDU for a different Protocol Version once the above negotiation completes, that party MUST drop the session; unless the PDU containing the unexpected Protocol Version was itself an Error Report PDU, the party dropping the session SHOULD send an Error Report with an error code of 8 (\"Unexpected Protocol Version\").",
      "ja": "上記のネゴシエーションが完了した後、いずれかのパーティが異なるプロトコルバージョンのPDUを受信した場合、そのパーティはセッションをドロップする必要があります。予期しないプロトコルバージョンを含むPDU自体がエラーレポートPDUでない限り、セッションをドロップする側はエラーコード8（「予期しないプロトコルバージョン」）を含むエラーレポートを送信する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "8. Protocol Sequences",
      "section_title": true,
      "ja": "8. プロトコルシーケンス"
    },
    {
      "indent": 3,
      "text": "The sequences of PDU transmissions fall into four conversations as follows:",
      "ja": "PDU送信のシーケンスは、次の4つの会話に分類されます。"
    },
    {
      "indent": 0,
      "text": "8.1. Start or Restart",
      "section_title": true,
      "ja": "8.1. 開始または再起動"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <----- Reset Query -------- | R requests data (or Serial Query)\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When a transport connection is first established, the router MUST send either a Reset Query or a Serial Query. A Serial Query would be appropriate if the router has significant unexpired data from a broken session with the same cache and remembers the Session ID of that session, in which case a Serial Query containing the Session ID from the previous session will allow the router to bring itself up to date while ensuring that the Serial Numbers are commensurate and that the router and cache are speaking compatible versions of the protocol. In all other cases, the router lacks the necessary data for fast resynchronization and therefore MUST fall back to a Reset Query.",
      "ja": "トランスポート接続が最初に確立されるとき、ルータはリセットクエリまたはシリアルクエリを送信する必要があります。ルーターが同じキャッシュで壊れたセッションからの有効期限の切れていない有効なデータを保持し、そのセッションのセッションIDを記憶している場合、シリアルクエリが適切です。この場合、前のセッションのセッションIDを含むシリアルクエリにより、ルーターはシリアル番号が釣り合っていること、およびルーターとキャッシュがプロトコルの互換性のあるバージョンを話していることを確認しながら、それ自体を最新の状態にします。他のすべてのケースでは、ルータは高速再同期に必要なデータを欠いているため、リセットクエリにフォールバックする必要があります。"
    },
    {
      "indent": 3,
      "text": "The Reset Query sequence is also used when the router receives a Cache Reset, chooses a new cache, or fears that it has otherwise lost its way.",
      "ja": "リセットクエリシーケンスは、ルータがキャッシュリセットを受信したとき、新しいキャッシュを選択したとき、または別の方法で失われたのではないかと心配したときにも使用されます。"
    },
    {
      "indent": 3,
      "text": "See Section 7 for details on version negotiation.",
      "ja": "バージョンネゴシエーションの詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep the data necessary to generate incremental updates, a router MUST send either a Serial Query or a Reset Query periodically. This also acts as a keep-alive at the application layer. See Section 6 for details on the required polling frequency.",
      "ja": "増分更新を生成するために必要なデータをキャッシュが保持しなければならない時間の長さを制限するには、ルーターはシリアルクエリまたはリセットクエリのいずれかを定期的に送信する必要があります。これは、アプリケーション層でのキープアライブとしても機能します。必要なポーリング頻度の詳細については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.2. Typical Exchange",
      "section_title": true,
      "ja": "8.2. 典型的な交換"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | -------- Notify ----------> |  (optional)\n  |                             |\n  | <----- Serial Query ------- | R requests data\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache server SHOULD send a Notify PDU with its current Serial Number when the cache's serial changes, with the expectation that the router MAY then issue a Serial Query earlier than it otherwise might. This is analogous to DNS NOTIFY in [RFC1996]. The cache MUST rate-limit Serial Notifies to no more frequently than one per minute.",
      "ja": "キャッシュサーバーは、キャッシュのシリアルが変更されたときに、現在のシリアル番号を使用してNotify PDUを送信する必要があります（SHOULD）。そうしないと、ルーターがシリアルクエリを発行するよりも早くなる可能性があります。これは、[RFC1996]のDNS NOTIFYに類似しています。キャッシュは、シリアル通知を1分あたり1回以下にレート制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the transport layer is up and either a timer has gone off in the router or the cache has sent a Notify PDU, the router queries for new data by sending a Serial Query, and the cache sends all data newer than the serial in the Serial Query.",
      "ja": "トランスポート層が起動し、ルーターのタイマーがオフになったか、キャッシュがNotify PDUを送信した場合、ルーターはシリアルクエリを送信して新しいデータを照会し、キャッシュはシリアル内のシリアルよりも新しいすべてのデータを送信しますクエリ。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep old withdraws, a router MUST send either a Serial Query or a Reset Query periodically. See Section 6 for details on the required polling frequency.",
      "ja": "キャッシュが古いwithdrawsを保持しなければならない時間の長さを制限するために、ルーターはシリアルクエリまたはリセットクエリのいずれかを定期的に送信する必要があります。必要なポーリング頻度の詳細については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.3. No Incremental Update Available",
      "section_title": true,
      "ja": "8.3. 増分更新はありません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Serial Query ------ | R requests data\n  | ------- Cache Reset ------> | C cannot supply update\n  |                             |   from specified serial\n  | <------ Reset Query ------- | R requests new data\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query with a Cache Reset, informing the router that the cache cannot supply an incremental update from the Serial Number specified by the router. This might be because the cache has lost state, or because the router has waited too long between polls and the cache has cleaned up old data that it no longer believes it needs, or because the cache has run out of storage space and had to expire some old data early. Regardless of how this state arose, the cache replies with a Cache Reset to tell the router that it cannot honor the request. When a router receives this, the router SHOULD attempt to connect to any more-preferred caches in its cache list. If there are no more-preferred caches, it MUST issue a Reset Query and get an entire new load from the cache.",
      "ja": "キャッシュはシリアルクエリにキャッシュリセットで応答し、ルーターが指定したシリアル番号からの増分更新をキャッシュが提供できないことをルーターに通知します。これは、キャッシュの状態が失われたか、ルーターがポーリングの間に長すぎてキャッシュが古いデータをクリーンアップしたため、必要と思わなくなったためか、キャッシュの記憶域が不足して期限切れになったことが原因である可能性がありますいくつかの古いデータが早い。この状態がどのように発生したかに関係なく、キャッシュはキャッシュリセットで応答し、要求を受け入れることができないことをルーターに通知します。ルータがこれを受信すると、ルータはそのキャッシュリスト内のより優先されるキャッシュへの接続を試みる必要があります（SHOULD）。優先キャッシュがない場合は、リセットクエリを発行して、キャッシュから新しいロード全体を取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4. Cache Has No Data Available",
      "section_title": true,
      "ja": "8.4. キャッシュに使用可能なデータがありません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Serial Query ------ | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Reset Query ------- | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " The cache may respond to either a Serial Query or a Reset Query informing the router that the cache cannot supply any update at all. The most likely cause is that the cache has lost state, perhaps due to a restart, and has not yet recovered. While it is possible that a cache might go into such a state without dropping any of its active sessions, a router is more likely to see this behavior when it initially connects and issues a Reset Query while the cache is still rebuilding its database.",
      "ja": "キャッシュは、シリアルクエリまたはリセットクエリに応答して、キャッシュが更新をまったく提供できないことをルータに通知します。最も可能性の高い原因は、おそらく再起動が原因でキャッシュの状態が失われ、まだ回復していないことです。キャッシュがアクティブなセッションをドロップせずにそのような状態になる可能性はありますが、ルーターが最初に接続し、キャッシュがデータベースを再構築しているときにリセットクエリを発行すると、この動作が発生する可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "When a router receives this kind of error, the router SHOULD attempt to connect to any other caches in its cache list, in preference order. If no other caches are available, the router MUST issue periodic Reset Queries until it gets a new usable load from the cache.",
      "ja": "ルーターがこの種のエラーを受信した場合、ルーターは、キャッシュリスト内の他のキャッシュに優先順に接続する必要があります（SHOULD）。他に使用可能なキャッシュがない場合、ルーターは、キャッシュから新しい使用可能なロードを取得するまで、定期的にリセットクエリを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Transport",
      "section_title": true,
      "ja": "9. 輸送"
    },
    {
      "indent": 3,
      "text": "The transport-layer session between a router and a cache carries the binary PDUs in a persistent session.",
      "ja": "ルーターとキャッシュ間のトランスポート層セッションは、永続的なセッションでバイナリPDUを伝送します。"
    },
    {
      "indent": 3,
      "text": "To prevent cache spoofing and DoS attacks by illegitimate routers, it is highly desirable that the router and the cache be authenticated to each other. Integrity protection for payloads is also desirable to protect against monkey-in-the-middle (MITM) attacks. Unfortunately, there is no protocol to do so on all currently used platforms. Therefore, as of the writing of this document, there is no mandatory-to-implement transport which provides authentication and integrity protection.",
      "ja": "不正なルーターによるキャッシュスプーフィングやDoS攻撃を防ぐには、ルーターとキャッシュが相互に認証されることが非常に望ましいです。ペイロードの完全性保護は、中間者攻撃（MITM）攻撃から保護するためにも望ましいです。残念ながら、現在使用されているすべてのプラットフォームでこれを行うプロトコルはありません。したがって、このドキュメントの執筆時点では、認証と整合性の保護を提供する必須から実装へのトランスポートはありません。"
    },
    {
      "indent": 3,
      "text": "To reduce exposure to dropped but non-terminated sessions, both caches and routers SHOULD enable keep-alives when available in the chosen transport protocol.",
      "ja": "ドロップされたが終了していないセッションへの露出を減らすために、キャッシュとルーターの両方で、選択されたトランスポートプロトコルで利用可能な場合にキープアライブを有効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that, when the TCP Authentication Option (TCP-AO) [RFC5925] is available on all platforms deployed by operators, it will become the mandatory-to-implement transport.",
      "ja": "オペレーターが展開したすべてのプラットフォームでTCP認証オプション（TCP-AO）[RFC5925]が利用できる場合、それは必須から実装へのトランスポートになることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MUST implement unprotected transport over TCP using a port, rpki-rtr (323); see Section 14. Operators SHOULD use procedural means, e.g., access control lists (ACLs), to reduce the exposure to authentication issues.",
      "ja": "キャッシュとルーターは、ポートrpki-rtr（323）を使用して、TCPを介した保護されていないトランスポートを実装する必要があります。セクション14を参照してください。オペレーターは、アクセス制御リスト（ACL）などの手続き的な手段を使用して、認証の問題が発生する可能性を減らす必要があります。"
    },
    {
      "indent": 3,
      "text": "If unprotected TCP is the transport, the cache and routers MUST be on the same trusted and controlled network.",
      "ja": "保護されていないTCPがトランスポートである場合、キャッシュとルーターは同じ信頼され制御されたネットワーク上になければなりません。"
    },
    {
      "indent": 3,
      "text": "If available to the operator, caches and routers MUST use one of the following more protected protocols:",
      "ja": "オペレーターが利用できる場合、キャッシュとルーターは、次のより保護されたプロトコルのいずれかを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers SHOULD use TCP-AO transport [RFC5925] over the rpki-rtr port.",
      "ja": "o キャッシュとルーターは、rpki-rtrポートでTCP-AOトランスポート[RFC5925]を使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use Secure Shell version 2 (SSHv2) transport [RFC4252] using the normal SSH port. For an example, see Section 9.1.",
      "ja": "o キャッシュとルーターは、通常のSSHポートを使用して、Secure Shellバージョン2（SSHv2）トランスポート[RFC4252]を使用する場合があります。例については、セクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use TCP MD5 transport [RFC2385] using the rpki-rtr port. Note that TCP MD5 has been obsoleted by TCP-AO [RFC5925].",
      "ja": "o キャッシュとルーターは、rpki-rtrポートを使用してTCP MD5トランスポート[RFC2385]を使用してもよい（MAY）。 TCP MD5はTCP-AO [RFC5925]によって廃止されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use TCP over IPsec transport [RFC4301] using the rpki-rtr port.",
      "ja": "o キャッシュとルーターは、rpki-rtrポートを使用して、TCP over IPsecトランスポート[RFC4301]を使用してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use Transport Layer Security (TLS) transport [RFC5246] using port rpki-rtr-tls (324); see Section 14.",
      "ja": "o キャッシュとルーターはポートrpki-rtr-tls（324）を使用してトランスポート層セキュリティ（TLS）トランスポート[RFC5246]を使用してもよい（MAY）。セクション14を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. SSH Transport",
      "section_title": true,
      "ja": "9.1. SSHトランスポート"
    },
    {
      "indent": 3,
      "text": "To run over SSH, the client router first establishes an SSH transport connection using the SSHv2 transport protocol, and the client and server exchange keys for message integrity and encryption. The client then invokes the \"ssh-userauth\" service to authenticate the application, as described in the SSH authentication protocol [RFC4252]. Once the application has been successfully authenticated, the client invokes the \"ssh-connection\" service, also known as the SSH connection protocol.",
      "ja": "SSHを介して実行するには、クライアントルーターは最初にSSHv2トランスポートプロトコルを使用してSSHトランスポート接続を確立し、クライアントとサーバーはメッセージの整合性と暗号化のために鍵を交換します。次に、SSH認証プロトコル[RFC4252]で説明されているように、クライアントは \"ssh-userauth\"サービスを呼び出してアプリケーションを認証します。アプリケーションが正常に認証されると、クライアントは「ssh-connection」サービス（SSH接続プロトコルとも呼ばれます）を呼び出します。"
    },
    {
      "indent": 3,
      "text": "After the ssh-connection service is established, the client opens a channel of type \"session\", which results in an SSH session.",
      "ja": "ssh-connectionサービスが確立されると、クライアントは「セッション」タイプのチャネルを開き、SSHセッションが発生します。"
    },
    {
      "indent": 3,
      "text": "Once the SSH session has been established, the application invokes the application transport as an SSH subsystem called \"rpki-rtr\". Subsystem support is a feature of SSHv2 and is not included in SSHv1. Running this protocol as an SSH subsystem avoids the need for the application to recognize shell prompts or skip over extraneous information, such as a system message that is sent at shell startup.",
      "ja": "SSHセッションが確立されると、アプリケーションは「rpki-rtr」と呼ばれるSSHサブシステムとしてアプリケーショントランスポートを呼び出します。サブシステムサポートはSSHv2の機能であり、SSHv1には含まれていません。このプロトコルをSSHサブシステムとして実行すると、アプリケーションがシェルプロンプトを認識したり、シェルの起動時に送信されるシステムメッセージなどの無関係な情報をスキップしたりする必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the router and cache have exchanged keys out of band by some reasonably secured means.",
      "ja": "ルーターとキャッシュは、ある程度安全な方法で帯域外の鍵を交換したと想定されています。"
    },
    {
      "indent": 3,
      "text": "Cache servers supporting SSH transport MUST accept RSA authentication and SHOULD accept Elliptic Curve Digital Signature Algorithm (ECDSA) authentication. User authentication MUST be supported; host authentication MAY be supported. Implementations MAY support password authentication. Client routers SHOULD verify the public key of the cache to avoid MITM attacks.",
      "ja": "SSHトランスポートをサポートするキャッシュサーバーは、RSA認証を受け入れる必要があり、楕円曲線デジタル署名アルゴリズム（ECDSA）認証を受け入れる必要があります（SHOULD）。ユーザー認証をサポートする必要があります。ホスト認証がサポートされる場合があります。実装はパスワード認証をサポートしてもよい（MAY）。クライアントルータは、MITM攻撃を回避するためにキャッシュの公開鍵を検証する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "9.2. TLS Transport",
      "section_title": true,
      "ja": "9.2. TLSトランスポート"
    },
    {
      "indent": 3,
      "text": "Client routers using TLS transport MUST present client-side certificates to authenticate themselves to the cache in order to allow the cache to manage the load by rejecting connections from unauthorized routers. In principle, any type of certificate and Certification Authority (CA) may be used; however, in general, cache operators will wish to create their own small-scale CA and issue certificates to each authorized router. This simplifies credential rollover; any unrevoked, unexpired certificate from the proper CA may be used.",
      "ja": "TLSトランスポートを使用するクライアントルーターは、不正なルーターからの接続を拒否してキャッシュが負荷を管理できるようにするために、クライアント側の証明書を提示してキャッシュに対して認証する必要があります。原則として、あらゆる種類の証明書と認証局（CA）を使用できます。ただし、一般に、キャッシュオペレーターは独自の小規模CAを作成し、承認された各ルーターに証明書を発行します。これにより、資格情報のロールオーバーが簡素化されます。適切なCAからの失効していない有効期限のない証明書を使用できます。"
    },
    {
      "indent": 3,
      "text": "Certificates used to authenticate client routers in this protocol MUST include a subjectAltName extension [RFC5280] containing one or more iPAddress identities; when authenticating the router's certificate, the cache MUST check the IP address of the TLS connection against these iPAddress identities and SHOULD reject the connection if none of the iPAddress identities match the connection.",
      "ja": "このプロトコルでクライアントルーターの認証に使用される証明書には、1つ以上のiPAddress IDを含むsubjectAltName拡張[RFC5280]が含まれている必要があります。ルーターの証明書を認証するとき、キャッシュはこれらのiPAddress IDに対してTLS接続のIPアドレスをチェックしなければならず、どのiPAddress IDも接続と一致しない場合は接続を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Routers MUST also verify the cache's TLS server certificate, using subjectAltName dNSName identities as described in [RFC6125], to avoid MITM attacks. The rules and guidelines defined in [RFC6125] apply here, with the following considerations:",
      "ja": "ルータは、MITM攻撃を回避するために、[RFC6125]で説明されているように、subjectAltName dNSName IDを使用して、キャッシュのTLSサーバー証明書も検証する必要があります。 [RFC6125]で定義されているルールとガイドラインは、次の点を考慮してここに適用されます。"
    },
    {
      "indent": 3,
      "text": "o Support for the DNS-ID identifier type (that is, the dNSName identity in the subjectAltName extension) is REQUIRED in rpki-rtr server and client implementations which use TLS. Certification authorities which issue rpki-rtr server certificates MUST support the DNS-ID identifier type, and the DNS-ID identifier type MUST be present in rpki-rtr server certificates.",
      "ja": "o DNS-ID識別子タイプ（つまり、subjectAltName拡張のdNSNameアイデンティティ）のサポートは、TLSを使用するrpki-rtrサーバーおよびクライアントの実装で必須です。 rpki-rtrサーバー証明書を発行する認証局は、DNS-ID識別子タイプをサポートする必要があり、DNS-ID識別子タイプは、rpki-rtrサーバー証明書に存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o DNS names in rpki-rtr server certificates SHOULD NOT contain the wildcard character \"*\".",
      "ja": "o rpki-rtrサーバー証明書のDNS名には、ワイルドカード文字「*」を含めないでください。"
    },
    {
      "indent": 3,
      "text": "o rpki-rtr implementations which use TLS MUST NOT use Common Name (CN-ID) identifiers; a CN field may be present in the server certificate's subject name but MUST NOT be used for authentication within the rules described in [RFC6125].",
      "ja": "o TLSを使用するrpki-rtr実装は、共通名（CN-ID）識別子を使用してはならない（MUST NOT）。 CNフィールドはサーバー証明書のサブジェクト名に存在する場合がありますが、[RFC6125]で説明されているルール内の認証に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o The client router MUST set its \"reference identifier\" to the DNS name of the rpki-rtr cache.",
      "ja": "o クライアントルータは、その「参照識別子」をrpki-rtrキャッシュのDNS名に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3. TCP MD5 Transport",
      "section_title": true,
      "ja": "9.3. TCP MD5トランスポート"
    },
    {
      "indent": 3,
      "text": "If TCP MD5 is used, implementations MUST support key lengths of at least 80 printable ASCII bytes, per Section 4.5 of [RFC2385]. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits.",
      "ja": "TCP MD5を使用する場合、実装は[RFC2385]のセクション4.5に従って、少なくとも80の印刷可能なASCIIバイトのキー長をサポートする必要があります。実装は、少なくとも32文字、つまり128ビットの16進シーケンスもサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Key rollover with TCP MD5 is problematic. Cache servers SHOULD support [RFC4808].",
      "ja": "TCP MD5でのキーロールオーバーには問題があります。キャッシュサーバーは[RFC4808]をサポートする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "9.4. TCP-AO Transport",
      "section_title": true,
      "ja": "9.4. TCP-AOトランスポート"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support key lengths of at least 80 printable ASCII bytes. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits. Message Authentication Code (MAC) lengths of at least 96 bits MUST be supported, per Section 5.1 of [RFC5925].",
      "ja": "実装では、少なくとも80の印刷可能なASCIIバイトのキー長をサポートする必要があります。実装は、少なくとも32文字、つまり128ビットの16進シーケンスもサポートする必要があります。 [RFC5925]のセクション5.1に従って、少なくとも96ビットのメッセージ認証コード（MAC）の長さがサポートされている必要があります。"
    },
    {
      "indent": 3,
      "text": "The cryptographic algorithms and associated parameters described in [RFC5926] MUST be supported.",
      "ja": "[RFC5926]で説明されている暗号化アルゴリズムと関連パラメータをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Router-Cache Setup",
      "section_title": true,
      "ja": "10. ルーターキャッシュの設定"
    },
    {
      "indent": 3,
      "text": "A cache has the public authentication data for each router it is configured to support.",
      "ja": "キャッシュには、サポートするように構成されている各ルーターのパブリック認証データがあります。"
    },
    {
      "indent": 3,
      "text": "A router may be configured to peer with a selection of caches, and a cache may be configured to support a selection of routers. Each must have the name of, and authentication data for, each peer. In addition, in a router, this list has a non-unique preference value for each server. This preference merely denotes proximity, not trust, preferred belief, et cetera. The client router attempts to establish a session with each potential serving cache in preference order and then starts to load data from the most preferred cache to which it can connect and authenticate. The router's list of caches has the following elements:",
      "ja": "ルーターは、選択したキャッシュとピアリングするように構成でき、キャッシュは、選択したルーターをサポートするように構成できます。各ピアには、各ピアの名前と認証データが必要です。さらに、ルーターでは、このリストには各サーバーの一意でない優先値があります。この好みは、信頼性、優先信念などではなく、単に近接性を示します。クライアントルーターは、提供される可能性のある各キャッシュとのセッションを優先順に確立しようと試み、接続および認証できる最も優先されるキャッシュからデータのロードを開始します。ルータのキャッシュリストには、次の要素があります。"
    },
    {
      "indent": 3,
      "text": "Preference: An unsigned integer denoting the router's preference to connect to that cache; the lower the value, the more preferred.",
      "ja": "設定：そのキャッシュに接続するルーターの設定を示す符号なし整数。値が小さいほど優先されます。"
    },
    {
      "indent": 3,
      "text": "Name: The IP address or fully qualified domain name of the cache.",
      "ja": "名前：キャッシュのIPアドレスまたは完全修飾ドメイン名。"
    },
    {
      "indent": 3,
      "text": "Cache Credential(s): Any credential (such as a public key) needed to authenticate the cache's identity to the router.",
      "ja": "キャッシュ資格情報：ルーターのキャッシュIDを認証するために必要な資格情報（公開キーなど）。"
    },
    {
      "indent": 3,
      "text": "Router Credential(s): Any credential (such as a private key or certificate) needed to authenticate the router's identity to the cache.",
      "ja": "ルーター資格情報：ルーターのIDをキャッシュに対して認証するために必要な資格情報（秘密キーや証明書など）。"
    },
    {
      "indent": 3,
      "text": "Due to the distributed nature of the RPKI, caches simply cannot be rigorously synchronous. A client may hold data from multiple caches but MUST keep the data marked as to source, as later updates MUST affect the correct data.",
      "ja": "RPKIは分散されているため、キャッシュを厳密に同期させることはできません。クライアントは複数のキャッシュからのデータを保持できますが、後の更新は正しいデータに影響を与える必要があるため、データをソースとしてマークしておく必要があります。"
    },
    {
      "indent": 3,
      "text": "Just as there may be more than one covering ROA from a single cache, there may be multiple covering ROAs from multiple caches. The results are as described in [RFC6811].",
      "ja": "単一のキャッシュからカバーする複数のROAがあるように、複数のキャッシュからカバーする複数のROAがある場合があります。結果は[RFC6811]で説明されているとおりです。"
    },
    {
      "indent": 3,
      "text": "If data from multiple caches are held, implementations MUST NOT distinguish between data sources when performing validation of BGP announcements.",
      "ja": "複数のキャッシュからのデータが保持されている場合、実装はBGPアナウンスの検証を実行するときにデータソースを区別してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "When a more-preferred cache becomes available, if resources allow, it would be prudent for the client to start fetching from that cache.",
      "ja": "より優先されるキャッシュが利用可能になったときに、リソースが許せば、クライアントがそのキャッシュからフェッチを開始するのが賢明です。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD attempt to maintain at least one set of data, regardless of whether it has chosen a different cache or established a new connection to the previous cache.",
      "ja": "クライアントは、別のキャッシュを選択したか、前のキャッシュへの新しい接続を確立したかに関係なく、少なくとも1セットのデータを維持しようとする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A client MAY drop the data from a particular cache when it is fully in sync with one or more other caches.",
      "ja": "クライアントは、1つ以上の他のキャッシュと完全に同期しているときに、特定のキャッシュからデータを削除する場合があります。"
    },
    {
      "indent": 3,
      "text": "See Section 6 for details on what to do when the client is not able to refresh from a particular cache.",
      "ja": "クライアントが特定のキャッシュから更新できない場合の対処方法については、セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a client loses connectivity to a cache it is using or otherwise decides to switch to a new cache, it SHOULD retain the data from the previous cache until it has a full set of data from one or more other caches. Note that this may already be true at the point of connection loss if the client has connections to more than one cache.",
      "ja": "クライアントが使用しているキャッシュへの接続を失うか、別の方法で新しいキャッシュに切り替えることを決定した場合、クライアントは、1つ以上の他のキャッシュからのデータの完全なセットを持つまで、以前のキャッシュのデータを保持する必要があります。クライアントが複数のキャッシュへの接続を持っている場合、これは接続が失われた時点ですでに当てはまる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11. Deployment Scenarios",
      "section_title": true,
      "ja": "11. 導入シナリオ"
    },
    {
      "indent": 3,
      "text": "For illustration, we present three likely deployment scenarios:",
      "ja": "説明のために、3つの考えられる展開シナリオを示します。"
    },
    {
      "indent": 3,
      "text": "Small End Site: The small multihomed end site may wish to outsource the RPKI cache to one or more of their upstream ISPs. They would exchange authentication material with the ISP using some out-of-band mechanism, and their router(s) would connect to the cache(s) of one or more upstream ISPs. The ISPs would likely deploy caches intended for customer use separately from the caches with which their own BGP speakers peer.",
      "ja": "小規模なエンドサイト：小規模なマルチホームのエンドサイトは、RPKIキャッシュを1つまたは複数の上流ISPにアウトソーシングしたい場合があります。彼らは何らかのアウトオブバンドメカニズムを使用してISPと認証情報を交換し、ルーターは1つ以上の上流ISPのキャッシュに接続します。 ISPは、顧客の使用を意図したキャッシュを、自社のBGPスピーカーがピアリングするキャッシュとは別に展開する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Large End Site: A larger multihomed end site might run one or more caches, arranging them in a hierarchy of client caches, each fetching from a serving cache which is closer to the Global RPKI. They might configure fallback peerings to upstream ISP caches.",
      "ja": "大規模なエンドサイト：大規模なマルチホームのエンドサイトは、1つ以上のキャッシュを実行し、それらをクライアントキャッシュの階層に配置して、それぞれがグローバルRPKIに近いサービングキャッシュからフェッチする場合があります。アップストリームISPキャッシュへのフォールバックピアリングを構成する場合があります。"
    },
    {
      "indent": 3,
      "text": "ISP Backbone: A large ISP would likely have one or more redundant caches in each major point of presence (PoP), and these caches would fetch from each other in an ISP-dependent topology so as not to place undue load on the Global RPKI.",
      "ja": "ISPバックボーン：大規模なISPは、各主要拠点（PoP）に1つ以上の冗長キャッシュを備えている可能性が高く、これらのキャッシュは、グローバルRPKIに過度の負荷をかけないように、ISP依存トポロジで互いにフェッチします。"
    },
    {
      "indent": 3,
      "text": "Experience with large DNS cache deployments has shown that complex topologies are ill-advised, as it is easy to make errors in the graph, e.g., not maintain a loop-free condition.",
      "ja": "大規模なDNSキャッシュの展開の経験から、ループのない状態を維持できないなど、グラフでエラーが発生しやすいため、複雑なトポロジは不適切であることがわかっています。"
    },
    {
      "indent": 3,
      "text": "Of course, these are illustrations, and there are other possible deployment strategies. It is expected that minimizing load on the Global RPKI servers will be a major consideration.",
      "ja": "もちろん、これらは例示であり、他の可能な展開戦略があります。グローバルRPKIサーバーの負荷を最小限に抑えることが重要な検討事項になると予想されます。"
    },
    {
      "indent": 3,
      "text": "To keep load on Global RPKI services from unnecessary peaks, it is recommended that primary caches which load from the distributed Global RPKI not do so all at the same times, e.g., on the hour. Choose a random time, perhaps the ISP's AS number modulo 60, and jitter the inter-fetch timing.",
      "ja": "不要なピークからグローバルRPKIサービスへの負荷を維持するために、分散グローバルRPKIからロードする一次キャッシュが同時に、たとえば1時間にそうしないことをお勧めします。ランダムな時間、おそらくISPのAS番号モジュロ60を選択し、フェッチ間タイミングをジッターさせます。"
    },
    {
      "indent": 0,
      "text": "12. Error Codes",
      "section_title": true,
      "ja": "12. エラーコード"
    },
    {
      "indent": 3,
      "text": "This section contains a preliminary list of error codes. The authors expect additions to the list during development of the initial implementations. There is an IANA registry where valid error codes are listed; see Section 14. Errors which are considered fatal MUST cause the session to be dropped.",
      "ja": "このセクションには、エラーコードの暫定的なリストが含まれています。著者は、初期実装の開発中にリストに追加されることを期待しています。有効なエラーコードがリストされているIANAレジストリがあります。セクション14を参照してください。致命的と見なされるエラーにより、セッションがドロップされる必要があります。"
    },
    {
      "indent": 3,
      "text": "0: Corrupt Data (fatal): The receiver believes the received PDU to be corrupt in a manner not specified by another error code.",
      "ja": "0：データの破損（致命的）：受信側は、受信したPDUが別のエラーコードで指定されていない方法で破損していると考えています。"
    },
    {
      "indent": 3,
      "text": "1: Internal Error (fatal): The party reporting the error experienced some kind of internal error unrelated to protocol operation (ran out of memory, a coding assertion failed, et cetera).",
      "ja": "1：内部エラー（致命的）：エラーを報告した当事者が、プロトコル操作に関係のない何らかの内部エラーを経験しました（メモリ不足、コーディングアサーションの失敗など）。"
    },
    {
      "indent": 3,
      "text": "2: No Data Available: The cache believes itself to be in good working order but is unable to answer either a Serial Query or a Reset Query because it has no useful data available at this time. This is likely to be a temporary error and most likely indicates that the cache has not yet completed pulling down an initial current data set from the Global RPKI system after some kind of event that invalidated whatever data it might have previously held (reboot, network partition, et cetera).",
      "ja": "2：使用可能なデータがない：キャッシュは正常に動作していると考えていますが、現時点で使用できる有用なデータがないため、シリアルクエリまたはリセットクエリのいずれにも応答できません。これは一時的なエラーである可能性が高く、以前に保持していた可能性のあるデータ（リブート、ネットワークパーティション）を無効化した何らかのイベントの後、キャッシュがグローバルRPKIシステムから初期の現在のデータセットのプルダウンをまだ完了していないことを示しています、など）。"
    },
    {
      "indent": 3,
      "text": "3: Invalid Request (fatal): The cache server believes the client's request to be invalid.",
      "ja": "3：無効なリクエスト（致命的）：キャッシュサーバーは、クライアントのリクエストが無効であると考えています。"
    },
    {
      "indent": 3,
      "text": "4: Unsupported Protocol Version (fatal): The Protocol Version is not known by the receiver of the PDU.",
      "ja": "4：サポートされていないプロトコルバージョン（致命的）：プロトコルバージョンはPDUの受信者に認識されていません。"
    },
    {
      "indent": 3,
      "text": "5: Unsupported PDU Type (fatal): The PDU Type is not known by the receiver of the PDU.",
      "ja": "5：サポートされていないPDUタイプ（致命的）：PDUタイプは、PDUの受信側に認識されていません。"
    },
    {
      "indent": 3,
      "text": "6: Withdrawal of Unknown Record (fatal): The received PDU has Flag=0, but a matching record ({Prefix, Len, Max-Len, ASN} tuple for an IPvX PDU or {SKI, ASN, Subject Public Key} tuple for a Router Key PDU) does not exist in the receiver's database.",
      "ja": "6：不明なレコードの撤回（致命的）：受信したPDUにはFlag = 0がありますが、一致するレコード（{Prefix、Len、Max-Len、ASN}タプル（IPvX PDUの場合）または{SKI、ASN、Subject Public Key}タプル）ルーターキーPDUの場合）は、受信者のデータベースに存在しません。"
    },
    {
      "indent": 3,
      "text": "7: Duplicate Announcement Received (fatal): The received PDU has Flag=1, but a matching record ({Prefix, Len, Max-Len, ASN} tuple for an IPvX PDU or {SKI, ASN, Subject Public Key} tuple for a Router Key PDU) is already active in the router.",
      "ja": "7：重複したアナウンスを受信しました（致命的）：受信したPDUにはFlag = 1がありますが、一致するレコード（IPvX PDUの場合は{Prefix、Len、Max-Len、ASN}タプルまたは{SKI、ASN、Subject Public Key}タプルの場合ルーターキーPDU）はルーターで既にアクティブになっています。"
    },
    {
      "indent": 3,
      "text": "8: Unexpected Protocol Version (fatal): The received PDU has a Protocol Version field that differs from the protocol version negotiated in Section 7.",
      "ja": "8：予期しないプロトコルバージョン（致命的）：受信したPDUには、セクション7でネゴシエートされたプロトコルバージョンとは異なるプロトコルバージョンフィールドがあります。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As this document describes a security protocol, many aspects of security interest are described in the relevant sections. This section points out issues which may not be obvious in other sections.",
      "ja": "このドキュメントではセキュリティプロトコルについて説明しているので、関連するセクションでは、セキュリティに関する多くの側面について説明します。このセクションでは、他のセクションでは明らかでない可能性がある問題を指摘します。"
    },
    {
      "indent": 3,
      "text": "Cache Validation: In order for a collection of caches as described in Section 11 to guarantee a consistent view, they need to be given consistent trust anchors to use in their internal validation process. Distribution of a consistent trust anchor is assumed to be out of band.",
      "ja": "キャッシュの検証：セクション11で説明したキャッシュのコレクションが一貫したビューを保証するためには、内部の検証プロセスで使用する一貫したトラストアンカーをキャッシュに与える必要があります。一貫したトラストアンカーの配布は、帯域外であると見なされます。"
    },
    {
      "indent": 3,
      "text": "Cache Peer Identification: The router initiates a transport connection to a cache, which it identifies by either IP address or fully qualified domain name. Be aware that a DNS or address spoofing attack could make the correct cache unreachable. No session would be established, as the authorization keys would not match.",
      "ja": "キャッシュピアの識別：ルーターはキャッシュへのトランスポート接続を開始します。キャッシュは、IPアドレスまたは完全修飾ドメイン名で識別されます。 DNSまたはアドレスのなりすまし攻撃により、正しいキャッシュに到達できなくなる可能性があることに注意してください。認証キーが一致しないため、セッションは確立されません。"
    },
    {
      "indent": 3,
      "text": "Transport Security: The RPKI relies on object, not server or transport, trust. That is, the IANA root trust anchor is distributed to all caches through some out-of-band means and can then be used by each cache to validate certificates and ROAs all the way down the tree. The inter-cache relationships are based on this object security model; hence, the inter-cache transport can be lightly protected.",
      "ja": "トランスポートセキュリティ：RPKIは、サーバーやトランスポートではなくオブジェクトの信頼に依存しています。つまり、IANAルートトラストアンカーは、帯域外の手段を介してすべてのキャッシュに配布され、各キャッシュが証明書とROAをツリー全体で検証するために使用できます。キャッシュ間の関係は、このオブジェクトセキュリティモデルに基づいています。したがって、キャッシュ間トランスポートを軽く保護できます。"
    },
    {
      "indent": 6,
      "text": "However, this protocol document assumes that the routers cannot do the validation cryptography. Hence, the last link, from cache to router, is secured by server authentication and transport-level security. This is dangerous, as server authentication and transport have very different threat models than object security.",
      "ja": "ただし、このプロトコルドキュメントは、ルーターが検証暗号化を実行できないことを前提としています。したがって、キャッシュからルーターへの最後のリンクは、サーバー認証とトランスポートレベルのセキュリティによって保護されます。サーバーの認証と転送にはオブジェクトのセキュリティとは非常に異なる脅威モデルがあるため、これは危険です。"
    },
    {
      "indent": 6,
      "text": "So the strength of the trust relationship and the transport between the router(s) and the cache(s) are critical. You're betting your routing on this.",
      "ja": "したがって、信頼関係の強さと、ルーターとキャッシュの間のトランスポートが重要です。あなたはこれにあなたのルーティングを賭けています。"
    },
    {
      "indent": 6,
      "text": "While we cannot say the cache must be on the same LAN, if only due to the issue of an enterprise wanting to offload the cache task to their upstream ISP(s), locality, trust, and control are very critical issues here. The cache(s) really SHOULD be as close, in the sense of controlled and protected (against DDoS, MITM) transport, to the router(s) as possible. It also SHOULD be topologically close so that a minimum of validated routing data are needed to bootstrap a router's access to a cache.",
      "ja": "キャッシュが同じLAN上にある必要があるとは言えませんが、企業がキャッシュタスクをアップストリームISPにオフロードしたいという問題がある場合に限り、ここでは局所性、信頼、および制御が非常に重要な問題です。キャッシュは、（DDoS、MITMに対して）制御および保護されたトランスポートの意味で、ルーターにできる限り近い必要があります。また、トポロジー的に近い必要があるため、キャッシュからルーターへのアクセスをブートストラップするには、検証済みのルーティングデータを最小限に抑える必要があります。"
    },
    {
      "indent": 6,
      "text": "The identity of the cache server SHOULD be verified and authenticated by the router client, and vice versa, before any data are exchanged.",
      "ja": "キャッシュサーバーのIDは、データが交換される前に、ルータークライアントによって検証および認証される必要があり、その逆も同様です。"
    },
    {
      "indent": 6,
      "text": "Transports which cannot provide the necessary authentication and integrity (see Section 9) must rely on network design and operational controls to provide protection against spoofing/ corruption attacks. As pointed out in Section 9, TCP-AO is the long-term plan. Protocols which provide integrity and authenticity SHOULD be used, and if they cannot, i.e., TCP is used as the transport, the router and cache MUST be on the same trusted, controlled network.",
      "ja": "必要な認証と整合性（セクション9を参照）を提供できないトランスポートは、スプーフィング/破損攻撃に対する保護を提供するために、ネットワーク設計と運用制御に依存する必要があります。セクション9で指摘したように、TCP-AOは長期計画です。整合性と信頼性を提供するプロトコルを使用する必要があります（SHOULD）。プロトコルが使用できない場合、つまり、TCPがトランスポートとして使用される場合、ルーターとキャッシュは同じ信頼できる制御されたネットワーク上になければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section only discusses updates required in the existing IANA protocol registries to accommodate version 1 of this protocol. See [RFC6810] for IANA considerations from the original (version 0) protocol.",
      "ja": "このセクションでは、このプロトコルのバージョン1に対応するために既存のIANAプロトコルレジストリで必要な更新についてのみ説明します。元の（バージョン0）プロトコルからのIANAの考慮事項については、[RFC6810]を参照してください。"
    },
    {
      "indent": 3,
      "text": "All existing entries in the IANA \"rpki-rtr-pdu\" registry remain valid for protocol version 0. All of the PDU types allowed in protocol version 0 are also allowed in protocol version 1, with the addition of the new Router Key PDU. To reduce the likelihood of confusion, the PDU number used by the Router Key PDU in protocol version 1 is hereby registered as reserved (and unused) in protocol version 0.",
      "ja": "IANA \"rpki-rtr-pdu\"レジストリの既存のエントリはすべて、プロトコルバージョン0でも有効です。プロトコルバージョン0で許可されているすべてのPDUタイプは、プロトコルバージョン1でも許可され、新しいルーターキーPDUが追加されています。混乱の可能性を減らすために、プロトコルバージョン1でルーターキーPDUによって使用されるPDU番号は、プロトコルバージョン0で予約済み（および未使用）として登録されます。"
    },
    {
      "indent": 3,
      "text": "The policy for adding to the registry is RFC Required per [RFC8126]; the document must be either Standards Track or Experimental.",
      "ja": "レジストリに追加するためのポリシーは、[RFC8126]によるRFC必須です。ドキュメントは、Standards TrackまたはExperimentalのいずれかである必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"rpki-rtr-pdu\" registry has been updated as follows:",
      "ja": "「rpki-rtr-pdu」レジストリが次のように更新されました。"
    },
    {
      "indent": 14,
      "text": "Protocol   PDU\nVersion    Type  Description\n--------   ----  ---------------\n   0-1       0   Serial Notify\n   0-1       1   Serial Query\n   0-1       2   Reset Query\n   0-1       3   Cache Response\n   0-1       4   IPv4 Prefix\n   0-1       6   IPv6 Prefix\n   0-1       7   End of Data\n   0-1       8   Cache Reset\n    0        9   Reserved\n    1        9   Router Key\n   0-1      10   Error Report\n   0-1     255   Reserved",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All existing entries in the IANA \"rpki-rtr-error\" registry remain valid for all protocol versions. Protocol version 1 adds one new error code:",
      "ja": "IANAの「rpki-rtr-error」レジストリの既存のエントリはすべて、すべてのプロトコルバージョンで引き続き有効です。プロトコルバージョン1では、1つの新しいエラーコードが追加されています。"
    },
    {
      "indent": 14,
      "text": "Error\nCode    Description\n-----   ---------------------------\n    8   Unexpected Protocol Version",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, DOI 10.17487/RFC1982, August 1996, <https://www.rfc-editor.org/info/rfc1982>.",
      "ja": "[RFC1982] Elz、R. and R. Bush、 \"Serial Number Arithmetic\"、RFC 1982、DOI 10.17487 / RFC1982、August 1996、<https://www.rfc-editor.org/info/rfc1982>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2385] Heffernan, A., \"Protection of BGP Sessions via the TCP MD5 Signature Option\", RFC 2385, DOI 10.17487/RFC2385, August 1998, <https://www.rfc-editor.org/info/rfc2385>.",
      "ja": "[RFC2385] Heffernan、A。、「TCP MD5署名オプションによるBGPセッションの保護」、RFC 2385、DOI 10.17487 / RFC2385、1998年8月、<https://www.rfc-editor.org/info/rfc2385>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4252] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Authentication Protocol\", RFC 4252, DOI 10.17487/RFC4252, January 2006, <https://www.rfc-editor.org/info/rfc4252>.",
      "ja": "[RFC4252] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Authentication Protocol」、RFC 4252、DOI 10.17487 / RFC4252、2006年1月、<https://www.rfc-editor.org/ info / rfc4252>。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, DOI 10.17487/RFC4301, December 2005, <https://www.rfc-editor.org/info/rfc4301>.",
      "ja": "[RFC4301] Kent、S。およびK. Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、DOI 10.17487 / RFC4301、2005年12月、<https://www.rfc-editor.org/info/rfc4301>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル\"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5925] Touch, J., Mankin, A., and R. Bonica, \"The TCP Authentication Option\", RFC 5925, DOI 10.17487/RFC5925, June 2010, <https://www.rfc-editor.org/info/rfc5925>.",
      "ja": "[RFC5925] Touch、J.、Mankin、A。、およびR. Bonica、「The TCP Authentication Option」、RFC 5925、DOI 10.17487 / RFC5925、2010年6月、<https://www.rfc-editor.org/info / rfc5925>。"
    },
    {
      "indent": 3,
      "text": "[RFC5926] Lebovitz, G. and E. Rescorla, \"Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)\", RFC 5926, DOI 10.17487/RFC5926, June 2010, <https://www.rfc-editor.org/info/rfc5926>.",
      "ja": "[RFC5926] Lebovitz、G。およびE. Rescorla、「TCP Authentication Option（TCP-AO）の暗号化アルゴリズム」、RFC 5926、DOI 10.17487 / RFC5926、2010年6月、<https://www.rfc-editor.org / info / rfc5926>。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6487] Huston, G., Michaelson, G., and R. Loomans, \"A Profile for X.509 PKIX Resource Certificates\", RFC 6487, DOI 10.17487/RFC6487, February 2012, <https://www.rfc-editor.org/info/rfc6487>.",
      "ja": "[RFC6487] Huston、G.、Michaelson、G。、およびR. Loomans、「X.509 PKIXリソース証明書のプロファイル」、RFC 6487、DOI 10.17487 / RFC6487、2012年2月、<https：//www.rfc- editor.org/info/rfc6487>。"
    },
    {
      "indent": 3,
      "text": "[RFC6810] Bush, R. and R. Austein, \"The Resource Public Key Infrastructure (RPKI) to Router Protocol\", RFC 6810, DOI 10.17487/RFC6810, January 2013, <https://www.rfc-editor.org/info/rfc6810>.",
      "ja": "[RFC6810] Bush、R。およびR. Austein、「The Resource Public Key Infrastructure（RPKI）to Router Protocol」、RFC 6810、DOI 10.17487 / RFC6810、2013年1月、<https://www.rfc-editor.org/ info / rfc6810>。"
    },
    {
      "indent": 3,
      "text": "[RFC6811] Mohapatra, P., Scudder, J., Ward, D., Bush, R., and R. Austein, \"BGP Prefix Origin Validation\", RFC 6811, DOI 10.17487/RFC6811, January 2013, <https://www.rfc-editor.org/info/rfc6811>.",
      "ja": "[RFC6811] Mohapatra、P.、Scudder、J.、Ward、D.、Bush、R。、およびR. Austein、「BGP Prefix Origin Validation」、RFC 6811、DOI 10.17487 / RFC6811、2013年1月、<https：/ /www.rfc-editor.org/info/rfc6811>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]コットン、M。、レイバ、B。、およびT.ナルテン、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8208] Turner, S. and O. Borchert, \"BGPsec Algorithms, Key Formats, and Signature Formats\", RFC 8208, DOI 10.17487/RFC8208, September 2017, <http://www.rfc-editor.org/info/rfc8208>.",
      "ja": "[RFC8208]ターナー、S。およびO.ボーチャート、「BGPsecアルゴリズム、キー形式、および署名形式」、RFC 8208、DOI 10.17487 / RFC8208、2017年9月、<http://www.rfc-editor.org/info/ rfc8208>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC1996] Vixie, P., \"A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)\", RFC 1996, DOI 10.17487/RFC1996, August 1996, <https://www.rfc-editor.org/info/rfc1996>.",
      "ja": "[RFC1996] Vixie、P。、「ゾーン変更の迅速な通知のためのメカニズム（DNS NOTIFY）」、RFC 1996、DOI 10.17487 / RFC1996、1996年8月、<https://www.rfc-editor.org/info/rfc1996 >。"
    },
    {
      "indent": 3,
      "text": "[RFC4808] Bellovin, S., \"Key Change Strategies for TCP-MD5\", RFC 4808, DOI 10.17487/RFC4808, March 2007, <https://www.rfc-editor.org/info/rfc4808>.",
      "ja": "[RFC4808] Bellovin、S。、「TCP-MD5の主要な変更戦略」、RFC 4808、DOI 10.17487 / RFC4808、2007年3月、<https://www.rfc-editor.org/info/rfc4808>。"
    },
    {
      "indent": 3,
      "text": "[RFC5781] Weiler, S., Ward, D., and R. Housley, \"The rsync URI Scheme\", RFC 5781, DOI 10.17487/RFC5781, February 2010, <https://www.rfc-editor.org/info/rfc5781>.",
      "ja": "[RFC5781] Weiler、S.、Ward、D。、およびR. Housley、「The rsync URI Scheme」、RFC 5781、DOI 10.17487 / RFC5781、2010年2月、<https://www.rfc-editor.org/info / rfc5781>。"
    },
    {
      "indent": 3,
      "text": "[RFC6480] Lepinski, M. and S. Kent, \"An Infrastructure to Support Secure Internet Routing\", RFC 6480, DOI 10.17487/RFC6480, February 2012, <https://www.rfc-editor.org/info/rfc6480>.",
      "ja": "[RFC6480] Lepinski、M。およびS. Kent、「安全なインターネットルーティングをサポートするインフラストラクチャ」、RFC 6480、DOI 10.17487 / RFC6480、2012年2月、<https://www.rfc-editor.org/info/rfc6480> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6481] Huston, G., Loomans, R., and G. Michaelson, \"A Profile for Resource Certificate Repository Structure\", RFC 6481, DOI 10.17487/RFC6481, February 2012, <https://www.rfc-editor.org/info/rfc6481>.",
      "ja": "[RFC6481] Huston、G.、Loomans、R。、およびG. Michaelson、「リソース証明書リポジトリ構造のプロファイル」、RFC 6481、DOI 10.17487 / RFC6481、2012年2月、<https：//www.rfc-editor。 org / info / rfc6481>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Nils Bars, Steve Bellovin, Tim Bruijnzeels, Rex Fernando, Richard Hansen, Paul Hoffman, Fabian Holler, Russ Housley, Pradosh Mohapatra, Keyur Patel, David Mandelberg, Sandy Murphy, Robert Raszuk, Andreas Reuter, Thomas C. Schmidt, John Scudder, Ruediger Volk, Matthias Waehlisch, and David Ward. Particular thanks go to Hannes Gredler for showing us the dangers of unnecessary fields.",
      "ja": "著者は、Nils Bars、Steve Bellovin、Tim Bruijnzeels、Rex Fernando、Richard Hansen、Paul Hoffman、Fabian Holler、Russ Housley、Pradosh Mohapatra、Keyur Patel、David Mandelberg、Sandy Murphy、Robert Raszuk、Andreas Reuter、Thomas Cに感謝します。シュミット、ジョン・スカダー、ルーディガー・フォルク、マティアス・ウェーリッシュ、デビッド・ウォード。不要なフィールドの危険性を示してくれたHannes Gredlerに特に感謝します。"
    },
    {
      "indent": 3,
      "text": "No doubt this list is incomplete. We apologize to any contributor whose name we missed.",
      "ja": "間違いなくこのリストは不完全です。名前を忘れてしまった投稿者には謝罪します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randy Bush Internet Initiative Japan 5147 Crystal Springs Bainbridge Island, Washington 98110 United States of America",
      "ja": "ランディブッシュインターネットイニシアチブ日本5147 Crystal Springsベインブリッジ島、ワシントン98110アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: randy@psg.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rob Austein Dragon Research Labs",
      "ja": "ロブオースタインドラゴン研究所"
    },
    {
      "indent": 3,
      "text": "Email: sra@hactrn.net",
      "raw": true,
      "ja": ""
    }
  ]
}