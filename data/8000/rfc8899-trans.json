{
  "title": {
    "text": "RFC 8899 - Packetization Layer Path MTU Discovery for Datagram Transports",
    "ja": "RFC 8899 - データグラムトランスポートのためのパケット化レイヤパスMTUディスカバリ"
  },
  "number": 8899,
  "created_at": "2021-03-28 13:00:03.194204+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      G. Fairhurst\nRequest for Comments: 8899                                      T. Jones\nUpdates: 4821, 4960, 6951, 8085, 8261             University of Aberdeen\nCategory: Standards Track                                       M. Tüxen\nISSN: 2070-1721                                              I. Rüngeler\n                                                               T. Völker\n                                  Münster University of Applied Sciences\n                                                          September 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Packetization Layer Path MTU Discovery for Datagram Transports",
      "ja": "データグラムトランスポートのためのパケット化レイヤパスMTUディスカバリ"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies Datagram Packetization Layer Path MTU Discovery (DPLPMTUD). This is a robust method for Path MTU Discovery (PMTUD) for datagram Packetization Layers (PLs). It allows a PL, or a datagram application that uses a PL, to discover whether a network path can support the current size of datagram. This can be used to detect and reduce the message size when a sender encounters a packet black hole. It can also probe a network path to discover whether the maximum packet size can be increased. This provides functionality for datagram transports that is equivalent to the PLPMTUD specification for TCP, specified in RFC 4821, which it updates. It also updates the UDP Usage Guidelines to refer to this method for use with UDP datagrams and updates SCTP.",
      "ja": "このドキュメントはデータグラムパケット化レイヤパスMTU検出（DPLPMTUD）を指定します。これは、データグラムパケット化レイヤ（PLS）に対するパスMTU発見（PMTUD）のための堅牢な方法です。それはPL、またはPLを使用するデータグラムアプリケーションを許可して、ネットワークパスが現在のデータグラムの現在のサイズをサポートできるかどうかを検出できます。これは、送信者がパケットブラックホールを遭遇したときにメッセージサイズを検出して削減するために使用できます。最大パケットサイズを増やすかどうかを発見するためのネットワークパスを調べることもできます。これは、更新されるRFC 4821で指定されているTCPのPLPMTUD仕様と同等のデータグラムトランスポートの機能を提供します。また、UDPデータグラムとSCTPを更新するために、この方法を参照するためにUDPの使用上のガイドラインを更新します。"
    },
    {
      "indent": 3,
      "text": "The document provides implementation notes for incorporating Datagram PMTUD into IETF datagram transports or applications that use datagram transports.",
      "ja": "この文書は、データグラムPMTUDをIETFデータグラムトランスポートまたはデータグラムトランスポートを使用するアプリケーションに組み込むための実装ノートを提供します。"
    },
    {
      "indent": 3,
      "text": "This specification updates RFC 4960, RFC 4821, RFC 6951, RFC 8085, and RFC 8261.",
      "ja": "この仕様は、RFC 4960、RFC 4821、RFC 6951、RFC 8085、およびRFC 8261を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット規格のトラック文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8899.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法については、https：//www.rfc-editor.org/info/rfc8899で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（C）2020 IETFの信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Classical Path MTU Discovery\n  1.2.  Packetization Layer Path MTU Discovery\n  1.3.  Path MTU Discovery for Datagram Services\n2.  Terminology\n3.  Features Required to Provide Datagram PLPMTUD\n4.  DPLPMTUD Mechanisms\n  4.1.  PLPMTU Probe Packets\n  4.2.  Confirmation of Probed Packet Size\n  4.3.  Black Hole Detection and Reducing the PLPMTU\n  4.4.  The Maximum Packet Size (MPS)\n  4.5.  Disabling the Effect of PMTUD\n  4.6.  Response to PTB Messages\n    4.6.1.  Validation of PTB Messages\n    4.6.2.  Use of PTB Messages\n5.  Datagram Packetization Layer PMTUD\n  5.1.  DPLPMTUD Components\n    5.1.1.  Timers\n    5.1.2.  Constants\n    5.1.3.  Variables\n    5.1.4.  Overview of DPLPMTUD Phases\n  5.2.  State Machine\n  5.3.  Search to Increase the PLPMTU\n    5.3.1.  Probing for a Larger PLPMTU\n    5.3.2.  Selection of Probe Sizes\n    5.3.3.  Resilience to Inconsistent Path Information\n  5.4.  Robustness to Inconsistent Paths\n6.  Specification of Protocol-Specific Methods\n  6.1.  Application Support for DPLPMTUD with UDP or UDP-Lite\n    6.1.1.  Application Request\n    6.1.2.  Application Response\n    6.1.3.  Sending Application Probe Packets\n    6.1.4.  Initial Connectivity\n    6.1.5.  Validating the Path\n    6.1.6.  Handling of PTB Messages\n  6.2.  DPLPMTUD for SCTP\n    6.2.1.  SCTP/IPv4 and SCTP/IPv6\n      6.2.1.1.  Initial Connectivity\n      6.2.1.2.  Sending SCTP Probe Packets\n      6.2.1.3.  Validating the Path with SCTP\n      6.2.1.4.  PTB Message Handling by SCTP\n    6.2.2.  DPLPMTUD for SCTP/UDP\n      6.2.2.1.  Initial Connectivity\n      6.2.2.2.  Sending SCTP/UDP Probe Packets\n      6.2.2.3.  Validating the Path with SCTP/UDP\n      6.2.2.4.  Handling of PTB Messages by SCTP/UDP\n    6.2.3.  DPLPMTUD for SCTP/DTLS\n      6.2.3.1.  Initial Connectivity\n      6.2.3.2.  Sending SCTP/DTLS Probe Packets\n      6.2.3.3.  Validating the Path with SCTP/DTLS\n      6.2.3.4.  Handling of PTB Messages by SCTP/DTLS\n  6.3.  DPLPMTUD for QUIC\n7.  IANA Considerations\n8.  Security Considerations\n9.  References\n  9.1.  Normative References\n  9.2.  Informative References\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The IETF has specified datagram transport using UDP, Stream Control Transmission Protocol (SCTP), and Datagram Congestion Control Protocol (DCCP), as well as protocols layered on top of these transports (e.g., SCTP/UDP, DCCP/UDP, QUIC/UDP) and direct datagram transport over the IP network layer. This document describes a robust method for Path MTU Discovery (PMTUD) that can be used with these transport protocols (or the applications that use their transport service) to discover an appropriate size of packet to use across an Internet path.",
      "ja": "IETFは、UDP、Stream Control Transmission Protocol（SCTP）、およびデータグラム輻輳制御プロトコル（DCCP）を使用してデータグラムトランスポートを指定し、これらのトランスポートの上に階層化されたプロトコル（例：SCTP / UDP、DCCP / UDP、QUIC / UDP））およびIPネットワーク層の上の直接データグラムトランスポート。このドキュメントでは、インターネットパス全体で使用する適切なサイズのパケットを検出するために、これらのトランスポートプロトコル（またはトランスポートサービスを使用するアプリケーション）で使用できるPATU MTU Discovery（PMTU）の堅牢な方法について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Classical Path MTU Discovery",
      "section_title": true,
      "ja": "1.1. クラシックパスMTUディスカバリー"
    },
    {
      "indent": 3,
      "text": "Classical Path Maximum Transmission Unit Discovery (PMTUD) can be used with any transport that is able to process ICMP Packet Too Big (PTB) messages (e.g., [RFC1191] and [RFC8201]). In this document, the term PTB message is applied to both IPv4 ICMP Unreachable messages (Type 3) that carry the error Fragmentation Needed (Type 3, Code 4) [RFC0792] and ICMPv6 Packet Too Big messages (Type 2) [RFC4443]. When a sender receives a PTB message, it reduces the effective MTU to the value reported as the link MTU in the PTB message. Classical PMTUD specifies a method of periodically increasing the packet size in an attempt to discover an increase in the supported PMTU. The packets sent with a size larger than the current effective PMTU are known as probe packets.",
      "ja": "クラシックパス最大伝送ユニットディスカバリ（PMTUD）は、ICMPパケットが大きすぎるメッセージ（例えば、[RFC1191]、[RFC8201]）を処理することができるあらゆるトランスポートで使用できます。この文書では、PTBメッセージという用語は、必要なエラーフラグメンテーション（タイプ3、コード4）[RFC0792] [RFC0792]とICMPv6パケットの両方のIPv4 ICMP到達不能メッセージ（RFC0792]（タイプ2）[RFC4443]。送信者がPTBメッセージを受信すると、PTBメッセージのリンクMTUとして報告された値への有効なMTUが短縮されます。Classical PMTUDサポートされているPMTUの増加を発見しようとしてパケットサイズを定期的に増やす方法を指定します。現在の有効なPMTUよりも大きいサイズで送信されたパケットは、プローブパケットとして知られています。"
    },
    {
      "indent": 3,
      "text": "Packets not intended as probe packets are either fragmented to the current effective PMTU, or the attempt to send fails with an error code. Applications can be provided with a primitive to let them read the Maximum Packet Size (MPS), which is derived from the current effective PMTU.",
      "ja": "プローブパケットが現在の有効なPMTUに断片化されていないパケットは、エラーコードで失敗します。アプリケーションには、現在の有効なPMTUから派生した最大パケットサイズ（MPS）を読み取ることができるプリミティブを提供できます。"
    },
    {
      "indent": 3,
      "text": "Classical PMTUD is subject to protocol failures. One failure arises when traffic using a packet size larger than the actual PMTU is black-holed (all datagrams larger than the actual PMTU are discarded). This could arise when the PTB messages are not sent back to the sender for some reason (for example, see [RFC2923]).",
      "ja": "古典的なPMTUDはプロトコル障害の影響を受けます。実際のPMTUよりも大きいパケットサイズを使用したトラフィックがブラックホール（実際のPMTUよりも大きいすべてのデータグラム）の場合、1つの失敗が発生します。これは、PTBメッセージが何らかの理由で送信者に送信されない場合に発生する可能性があります（たとえば、[RFC2923]を参照）。"
    },
    {
      "indent": 3,
      "text": "Examples of where PTB messages are not delivered include the following:",
      "ja": "PTBメッセージに配信されていない場所の例は、次のものを含みます。"
    },
    {
      "indent": 3,
      "text": "* The generation of ICMP messages is usually rate limited. This could result in no PTB messages being generated to the sender (see Section 2.4 of [RFC4443]).",
      "ja": "* ICMPメッセージの生成は通常レート制限です。これにより、送信者にPTBメッセージが生成されない可能性があります（[RFC4443]のセクション2.4を参照）。"
    },
    {
      "indent": 3,
      "text": "* ICMP messages can be filtered by middleboxes, including firewalls [RFC4890]. A firewall could be configured with a policy to block incoming ICMP messages, which would prevent reception of PTB messages by a sending endpoint behind this firewall.",
      "ja": "* ICMPメッセージは、ファイアウォール[RFC4890]を含むミドルボックスでフィルタリングできます。このファイアウォールの背後にある送信エンドポイントによるPTBメッセージの受信を防ぐために、ファイアウォールをポリシーで構成することができます。"
    },
    {
      "indent": 3,
      "text": "* When the router issuing the ICMP message drops a tunneled packet, the resulting ICMP message is directed to the tunnel ingress. This tunnel endpoint is responsible for forwarding the ICMP message, processing the quoted packet within the payload field to remove the effect of the tunnel and returning a correctly formatted ICMP message to the sender [TUNNELS]. Failure to do this prevents the PTB message from reaching the original sender.",
      "ja": "* ICMPメッセージを発行するルータがトンネリングパケットをドロップすると、結果のICMPメッセージはトンネルの入力に向けられます。このトンネルエンドポイントは、ICMPメッセージを転送し、ペイロードフィールド内の引用符付きパケットを処理してトンネルの効果を削除し、送信者[トンネル]に正しくフォーマットされたICMPメッセージを返す。これを行うことができないと、PTBメッセージが元の送信者に到達するのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "* Asymmetry in forwarding can result in there being no return route to the original sender, which would prevent an ICMP message from being delivered to the sender. This issue can also arise when either policy-based or Equal-Cost Multipath (ECMP) routing is used or when a middlebox acts as an application load balancer. An example of which is an ECMP router choosing a path toward the server based on the bytes in the IP payload. In this case, if a packet sent by the server encounters a problem after the ECMP router, then the ECMP router needs to direct any resulting ICMP message toward the original sender.",
      "ja": "* 転送中の非対称性は、元の送信者へのリターンルートがない可能性があり、これはICMPメッセージが送信者に配信されないようにするであろう。この問題は、ポリシーベースまたは等価コストのマルチパス（ECMP）ルーティングが使用されている場合、またはMiddleBoxがアプリケーションロードバランサとして機能する場合にも発生する可能性があります。その一例は、IPペイロード内のバイトに基づいてサーバーへのパスを選択するECMPルーターです。この場合、ECMPルータの後にサーバによって送信されたパケットが問題に遭遇した場合、ECMPルータは結果として生じるICMPメッセージを元の送信者に向けて送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "* There are additional cases where the next-hop destination fails to receive a packet because of its size. This could be due to misconfiguration of the layer 2 path between nodes, for instance the MTU configured in a layer 2 switch, or misconfiguration of the Maximum Receive Unit (MRU). If a packet is dropped by the link, this will not cause a PTB message to be sent to the original sender.",
      "ja": "* サイズのためにネクストホップの宛先がパケットを受信できない場合があります。これは、ノード間のレイヤ2パスの誤構成、例えば、レイヤ2スイッチで構成されたMTU、または最大受信ユニット（MRU）の誤構成が原因である可能性があります。パケットがリンクによってドロップされた場合、これはPTBメッセージを元の送信者に送信させることはありません。"
    },
    {
      "indent": 3,
      "text": "Another failure could result if a node that is not on the network path sends a PTB message that attempts to force a sender to change the effective PMTU [RFC8201]. A sender can protect itself from reacting to such messages by utilizing the quoted packet within a PTB message payload to validate that the received PTB message was generated in response to a packet that had actually originated from the sender. However, there are situations where a sender would be unable to provide this validation. Examples where the validation of the PTB message is not possible include the following:",
      "ja": "ネットワークパス上にないノードが、送信者に有効なPMTU [RFC8201]を変更するよう強制しようとするPTBメッセージを送信すると、もう1つの障害が発生する可能性があります。送信者は、PTBメッセージペイロード内の引用符付きパケットを利用して、受信したPTBメッセージが送信者から発生したパケットに応答して生成されたことを検証することによって、そのようなメッセージに反応することを保護することができる。ただし、送信者がこの検証を提供できない場合があります。PTBメッセージの検証が不可能な例としては、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "* When a router issuing the ICMP message implements RFC 792 [RFC0792], it is only required to include the first 64 bits of the IP payload of the packet within the quoted payload. There could be insufficient bytes remaining for the sender to interpret the quoted transport information.",
      "ja": "* ICMPメッセージを発行するルータがRFC 792 [RFC0792]を実装すると、引用符付きペイロード内のパケットのIPペイロードの最初の64ビットを含める必要があります。引用符付きトランスポート情報を解釈するために送信者が残っているのが不十分である可能性があります。"
    },
    {
      "indent": 6,
      "text": "Note: The recommendation in RFC 1812 [RFC1812] is that IPv4 routers return a quoted packet with as much of the original datagram as possible without the length of the ICMP datagram exceeding 576 bytes. IPv6 routers include as much of the invoking packet as possible without the ICMPv6 packet exceeding 1280 bytes [RFC4443].",
      "ja": "注：RFC 1812 [RFC1812]の推奨事項は、IPv4ルーターがICMPデータグラムを576バイトを超える長さがなくても、できるだけ多くの元のデータグラムで引用符付きのパケットを返すことです。IPv6ルータには、ICMPv6パケットが1280バイト[RFC4443]を超えることなくできるだけ多くの呼び出しパケットが含まれます。"
    },
    {
      "indent": 3,
      "text": "* The use of tunnels and/or encryption can reduce the size of the quoted packet returned to the original source address, increasing the risk that there could be insufficient bytes remaining for the sender to interpret the quoted transport information.",
      "ja": "* トンネルや暗号化の使用は、元の送信元アドレスに返された引用符付きパケットのサイズを減らすことができ、送信者が引用符付きトランスポート情報を解釈するために残っているバイトが不十分である可能性があるリスクを高めます。"
    },
    {
      "indent": 3,
      "text": "* Even when the PTB message includes sufficient bytes of the quoted packet, the network layer could lack sufficient context to validate the message because validation depends on information about the active transport flows at an endpoint node (e.g., the socket/address pairs being used and other protocol header information).",
      "ja": "* PTBメッセージが引用符付きパケットの十分なバイトを含む場合であっても、検証はエンドポイントノードにおけるアクティブトランスポートフローに関する情報に依存するので、ネットワーク層はメッセージを検証するのに十分なコンテキストを欠くことができる（例えば、使用されているソケット/アドレスペア。プロトコルヘッダ情報）。"
    },
    {
      "indent": 3,
      "text": "* When a packet is encapsulated/tunneled over an encrypted transport, the tunnel/encapsulation ingress might have insufficient context, or computational power, to reconstruct the transport header that would be needed to perform validation.",
      "ja": "* パケットが暗号化されたトランスポートを介してカプセル化/トンネリングされている場合、トンネル/カプセル化入力は不十分なコンテキスト、または計算電力を持ち、検証を実行するために必要とされるトランスポートヘッダーを再構築することができます。"
    },
    {
      "indent": 3,
      "text": "* When an ICMP message is generated by a router in a network segment that has inserted a header into a packet, the quoted packet could contain additional protocol header information that was not included in the original sent packet and that the PL sender does not process or may not know how to process. This could disrupt the ability of the sender to validate this PTB message.",
      "ja": "* ICMPメッセージがパケットにヘッダを挿入したネットワークセグメント内のルータによって生成されると、引用符付きパケットは、元の送信パケットに含まれていない追加のプロトコルヘッダ情報を含み、PL送信者が処理しないか、または処理方法がわからない。これにより、送信者がこのPTBメッセージを検証する機能を妨害する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* A Network Address Translation (NAT) device that translates a packet header ought to also translate ICMP messages and update the ICMP-quoted packet [RFC5508] in that message. If this is not correctly translated, then the sender would not be able to associate the message with the PL that originated the packet, and hence this ICMP message cannot be validated.",
      "ja": "* パケットヘッダーを変換するネットワークアドレス変換（NAT）デバイスは、ICMPメッセージを変換し、そのメッセージでICMP Quoted Packet [RFC5508]を更新することもできます。これが正しく翻訳されていない場合、送信者はパケットを発信したPLにメッセージを関連付けることができず、このICMPメッセージを検証できません。"
    },
    {
      "indent": 0,
      "text": "1.2. Packetization Layer Path MTU Discovery",
      "section_title": true,
      "ja": "1.2. パケット化レイヤパスMTU発見"
    },
    {
      "indent": 3,
      "text": "The term Packetization Layer (PL) has been introduced to describe the layer that is responsible for placing data blocks into the payload of IP packets and selecting an appropriate MPS. This function is often performed by a transport protocol (e.g., DCCP, RTP, SCTP, QUIC) but can also be performed by other encapsulation methods working above the transport layer.",
      "ja": "パケット化層（PL）という用語は、データブロックをIPパケットのペイロードに配置し、適切なMPを選択する責任がある層を記述するために導入されている。この関数は、多くの場合、トランスポートプロトコル（例えば、DCCP、RTP、SCTP、QUIC）によって実行されますが、トランスポート層の上に作動する他のカプセル化方法によって実行できます。"
    },
    {
      "indent": 3,
      "text": "In contrast to PMTUD, Packetization Layer Path MTU Discovery (PLPMTUD) [RFC4821] introduces a method that does not rely upon reception and validation of PTB messages. It is therefore more robust than Classical PMTUD. This has become the recommended approach for implementing discovery of the PMTU [BCP145].",
      "ja": "PMTUDとは対照的に、パケット化レイヤパスMTUディスカバリ（PLPMTUD）[RFC4821]は、PTBメッセージの受信および検証に頼らない方法を紹介します。したがって、古典的なPMTUDよりも堅牢です。これはPMTUの発見を実施するための推奨されるアプローチとなっています[BCP145]。"
    },
    {
      "indent": 3,
      "text": "This document updates [RFC4821] to specify the PLPMTUD method for datagram PLs and also updates [BCP145] to refer to the method specified in this document for use with UDP datagrams instead of the method in [RFC4821].",
      "ja": "このドキュメントは、[RFC4821]をデータグラムPLSのPLPMTUDメソッドを指定し、[RFC4821]メソッドの代わりにUDPデータグラムで使用するためにこのドキュメントで指定された方法を参照するために[BCP145]も参照してください。"
    },
    {
      "indent": 3,
      "text": "It uses a general strategy in which the PL sends probe packets to search for the largest size of unfragmented datagram that can be sent over a network path. Probe packets are sent to explore using a larger packet size. If a probe packet is successfully delivered (as determined by the PL), then the PLPMTU is raised to the size of the successful probe. If a black hole is detected (e.g., where packets of size PLPMTU are consistently not received), the method reduces the PLPMTU.",
      "ja": "PLがネットワークパスを介して送信できる最大のデータグラムの最大サイズを検索するためにPROEパケットを送信する一般的な戦略を使用します。プローブパケットは、より大きなパケットサイズを使用して探索するように送信されます。プローブパケットが正常に配信された場合（PLによって決定されたとおり）、PLPMTUは成功したプローブのサイズに上げられます。ブラックホールが検出された場合（例えば、サイズPLPMTUのパケットが一貫して受信されない場合）、この方法はPLPMTUを減少させる。"
    },
    {
      "indent": 3,
      "text": "Datagram PLPMTUD introduces flexibility in implementation. At one extreme, it can be configured to only perform black hole detection and recovery with increased robustness compared to Classical PMTUD. At the other extreme, all PTB processing can be disabled, and PLPMTUD replaces Classical PMTUD.",
      "ja": "データグラムPLPMTUDは実装に柔軟性を紹介します。極端には、古典的なPMTUDと比較して、ブラックホール検出と回復のみを実行するように構成できます。他の極端には、すべてのPTB処理を無効にすることができ、PLPMTUDは古典的なPMTUDを置き換えます。"
    },
    {
      "indent": 3,
      "text": "PLPMTUD can also include additional consistency checks without increasing the risk that data is lost when probing to discover the Path MTU. For example, information available at the PL, or higher layers, enables received PTB messages to be validated before being utilized.",
      "ja": "PLPMTUDは、パスMTUを発見するプロービング時にデータが失われる危険性を高めることなく、追加の一貫性チェックを含めることもできます。例えば、PL、または上位層で利用可能な情報は、利用される前に受信されたPTBメッセージを検証することを可能にする。"
    },
    {
      "indent": 0,
      "text": "1.3. Path MTU Discovery for Datagram Services",
      "section_title": true,
      "ja": "1.3. データグラムサービスのためのパスMTUディスカバリー"
    },
    {
      "indent": 3,
      "text": "Section 5 of this document presents a set of algorithms for datagram protocols to discover the largest size of unfragmented datagram that can be sent over a network path. The method relies upon features of the PL described in Section 3 and applies to transport protocols operating over IPv4 and IPv6. It does not require cooperation from the lower layers, although it can utilize PTB messages when these received messages are made available to the PL.",
      "ja": "この文書のセクション5は、データグラムプロトコルのための一連のアルゴリズムを示して、ネットワークパスを介して送信できる排除されていないデータグラムの最大サイズを発見します。この方法は、セクション3に記載されているPLの機能に依存し、IPv4およびIPv6を介して動作するトランスポートプロトコルに適用されます。これらの受信メッセージがPLに利用可能になったときにPTBメッセージを利用することができるが、下位層からの協力は必要ありません。"
    },
    {
      "indent": 3,
      "text": "The message size guidelines in Section 3.2 of the UDP Usage Guidelines [BCP145] state that \"an application SHOULD either use the Path MTU information provided by the IP layer or implement Path MTU Discovery (PMTUD)\" but do not provide a mechanism for discovering the largest size of unfragmented datagram that can be used on a network path. The present document updates RFC 8085 to specify this method in place of PLPMTUD [RFC4821] and provides a mechanism for sharing the discovered largest size as the MPS (see Section 4.4).",
      "ja": "UDP使用ガイドライン[BCP145]のセクション3.2のメッセージサイズのガイドライン[IPレイヤによって提供されたパスMTU情報を使用するか、PATU Discovery（PMTU）を実行する必要があるが、検出するためのメカニズムを提供しないでください。ネットワーク経路で使用できる未盗作データグラムの最大サイズ。本文書は、PLPMTUD [RFC4821]の代わりにこのメソッドを指定するようにRFC 8085を更新し、発見された最大サイズをMPSとして共有するためのメカニズムを提供します（セクション4.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Section 10.2 of [RFC4821] recommended a PLPMTUD probing method for the Stream Control Transport Protocol (SCTP). SCTP utilizes probe packets consisting of a minimal-sized HEARTBEAT chunk bundled with a PAD chunk as defined in [RFC4820]. However, RFC 4821 did not provide a complete specification. The present document replaces that description by providing a complete specification.",
      "ja": "[RFC4821]のセクション10.2ストリーム制御トランスポートプロトコル（SCTP）のPLPMTUDプロービング方法を推奨します。SCTPは、[RFC4820]で定義されているパッドチャンクを束ねた最小サイズのハートビートチャンクからなるプローブパケットを利用します。しかし、RFC 4821は完全な仕様を提供しませんでした。現在の文書は、その説明を完全な仕様を提供することによって置き換えます。"
    },
    {
      "indent": 3,
      "text": "The Datagram Congestion Control Protocol (DCCP) [RFC4340] requires implementations to support Classical PMTUD and states that a DCCP sender \"MUST maintain the MPS allowed for each active DCCP session\". It also defines the current congestion control MPS (CCMPS) supported by a network path. This recommends use of PMTUD and suggests use of control packets (DCCP-Sync) as path probe packets because they do not risk application data loss. The method defined in this specification can be used with DCCP.",
      "ja": "データグラム輻輳制御プロトコル（DCCP）[RFC4340]には、クラシックPMTUDをサポートするための実装が必要であり、DCCP送信者が各アクティブなDCCPセッションに対して許可されているMPSを維持する必要があります。ネットワークパスでサポートされている現在の輻輳制御MPS（CCMPS）も定義します。これにより、PMTUDの使用を推奨し、アプリケーションデータの損失が危険にさらさないため、PATEプローブパケットとしての制御パケット（DCCP-SYNC）の使用を提案します。本明細書で定義されている方法はDCCPで使用できます。"
    },
    {
      "indent": 3,
      "text": "Section 4 and Section 5 define the protocol mechanisms and specification for Datagram Packetization Layer Path MTU Discovery (DPLPMTUD).",
      "ja": "セクション4およびセクション5は、データグラムパケット化レイヤパスMTUディスカバリ（DPLPMTUD）のプロトコルメカニズムおよび仕様を定義します。"
    },
    {
      "indent": 3,
      "text": "Section 6 specifies the method for datagram transports and provides information to enable the implementation of PLPMTUD with other datagram transports and applications that use datagram transports.",
      "ja": "セクション6は、データグラムトランスポートの方法を指定し、データグラムトランスポートを使用する他のデータグラムトランスポートおよびアプリケーションとのPLPMTUDの実装を可能にするための情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 6 also provides recommendations for SCTP endpoints, updating [RFC4960], [RFC6951], and [RFC8261] to use the method specified in this document instead of the method in [RFC4821].",
      "ja": "また、STCTPエンドポイント、[RFC4960]、[RFC6951]、[RFC8261]の更新、[RFC4821]ではなく、このドキュメントで指定された方法を使用するための推奨事項もあります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "The following terminology is defined. Relevant terms are directly copied from [RFC4821], and the definitions in [RFC1122] apply.",
      "ja": "次の用語が定義されています。関連用語は[RFC4821]から直接コピーされ、[RFC1122]の定義が適用されます。"
    },
    {
      "indent": 3,
      "text": "Acknowledged PL: A PL that includes a mechanism that can confirm successful delivery of datagrams to the remote PL endpoint (e.g., SCTP). Typically, the PL receiver returns acknowledgments corresponding to the received datagrams, which can be utilized to detect black-holing of packets (c.f., Unacknowledged PL).",
      "ja": "承認PL：リモートPLエンドポイントへのデータグラムの成功の成功を確認できるメカニズムを含むPL（例えば、SCTP）。典型的には、PL受信機は受信データグラムに対応する肯定応答を返し、それはパケットのブラックホールを検出するために利用することができる（C.F.未確認PL）。"
    },
    {
      "indent": 3,
      "text": "Actual PMTU: The actual PMTU is the PMTU of a network path between a sender PL and a destination PL, which the DPLPMTUD algorithm seeks to determine.",
      "ja": "実際のPMTU：実際のPMTUは、送信者PLと宛先PLとの間のネットワーク経路のPMTUであり、DPLPMTUDアルゴリズムは決定しようとしている。"
    },
    {
      "indent": 3,
      "text": "Black Hole: A black hole is encountered when a sender is unaware that packets are not being delivered to the destination endpoint. Two types of black hole are relevant to DPLPMTUD:",
      "ja": "ブラックホール：送信者が宛先エンドポイントに配信されていないことを送信者が認識していない場合、ブラックホールが発生します。2種類のブラックホールがDPLPMTUDに関連しています。"
    },
    {
      "indent": 6,
      "text": "* Packets encounter a packet black hole when packets are not delivered to the destination endpoint (e.g., when the sender transmits packets of a particular size with a previously known effective PMTU, and they are discarded by the network).",
      "ja": "* パケットは、パケットが宛先エンドポイントに配信されない場合（例えば、送信者が以前に知られている有効なPMTUで特定のサイズのパケットを送信し、それらがネットワークによって破棄される）。"
    },
    {
      "indent": 6,
      "text": "* An ICMP black hole is encountered when the sender is unaware that packets are not delivered to the destination endpoint because PTB messages are not received by the originating PL sender.",
      "ja": "* PTBメッセージが発信元のPL送信者によって受信されないため、送信者が送信側のエンドポイントに配信されないことを送信者が認識されていない場合にICMPブラックホールが発生します。"
    },
    {
      "indent": 3,
      "text": "Classical Path MTU Discovery: Classical PMTUD is a process described in [RFC1191] and [RFC8201] in which nodes rely on PTB messages to learn the largest size of unfragmented packet that can be used across a network path.",
      "ja": "クラシックパスMTUディスカバリ：クラシックPMTUDは[RFC1191]と[RFC8201]で説明されているプロセスで、ノードはネットワークパスを介して使用できる最大の競合パケットの最大サイズを学習するためのPTBメッセージに依存しています。"
    },
    {
      "indent": 3,
      "text": "Datagram: A datagram is a transport-layer protocol data unit, transmitted in the payload of an IP packet.",
      "ja": "データグラム：データグラムは、IPパケットのペイロードで送信されたトランスポート層プロトコルデータユニットです。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD: Datagram Packetization Layer Path MTU Discovery (DPLPMTUD), PLPMTUD performed using a datagram transport protocol.",
      "ja": "DPLPMTUD：データグラムパケット化レイヤパスMTUディスカバリ（DPLPMTUD）、PLPMTUDデータグラムトランスポートプロトコルを使用して実行されます。"
    },
    {
      "indent": 3,
      "text": "Effective PMTU: The effective PMTU is the current estimated value for PMTU that is used by a PMTUD. This is equivalent to the PLPMTU derived by PLPMTUD plus the size of any headers added below the PL, including the IP layer headers.",
      "ja": "効果的なPMTU：実効PMTUはPMTUによって使用されるPMTUの現在の推定値です。これは、PLPMTUDとIPレイヤヘッダーを含むPLの下に追加されたヘッダーのサイズと派生したPLPMTUと同等です。"
    },
    {
      "indent": 3,
      "text": "EMTU_S: The effective MTU for sending (EMTU_S) is defined in [RFC1122] as \"the maximum IP datagram size that may be sent, for a particular combination of IP source and destination addresses...\".",
      "ja": "emtu_s：（emtu_s）を送信するための有効なMTUは、[RFC1122]で「送信される可能性がある最大IPデータグラムサイズ、IPソースアドレスと宛先アドレスの特定の組み合わせ...」で定義されています。"
    },
    {
      "indent": 3,
      "text": "EMTU_R: The effective MTU for receiving (EMTU_R) is designated in [RFC1122] as \"the largest datagram size that can be reassembled\".",
      "ja": "EMTU_R：[RFC1122]で[RFC1122]で有効なMTUを「再組み立てることができる最大のデータグラム・サイズ」として指定します。"
    },
    {
      "indent": 3,
      "text": "Link: A link is a communication facility or medium over which nodes can communicate at the link layer, i.e., a layer below the IP layer. Examples are Ethernet LANs and Internet (or higher) layer tunnels.",
      "ja": "リンク：リンクは、ノードがリンク層、すなわちIP層の下のレイヤで通信できる通信機能または媒体である。例としては、イーサネットLANとインターネット（またはより高い）レイヤトンネルです。"
    },
    {
      "indent": 3,
      "text": "Link MTU: The link Maximum Transmission Unit (MTU) is the size in bytes of the largest IP packet, including the IP header and payload, that can be transmitted over a link. Note that this could more properly be called the IP MTU, to be consistent with how other standards organizations use the acronym. This includes the IP header but excludes link layer headers and other framing that is not part of IP or the IP payload. Other standards organizations generally define the link MTU to include the link layer headers. This specification continues the requirement in [RFC4821] that states, \"All links MUST enforce their MTU: links that might non-deterministically deliver packets that are larger than their rated MTU MUST consistently discard such packets.\"",
      "ja": "リンクMTU：リンク最大伝送ユニット（MTU）は、リンクを介して送信できるIPヘッダとペイロードを含む最大のIPパケットのサイズ単位である。これは、他の標準組織が頭字語を使用する方法と一致するように、これがIP MTUと呼ばれる可能性があることに注意してください。これにはIPヘッダーが含まれていますが、IPまたはIPペイロードの一部ではないリンクレイヤのヘッダーやその他のフレーミングを除外します。他の標準組織は、一般に、リンク層ヘッダを含むようにリンクMTUを定義する。この仕様は、「RFC4821」の要件を継続しています。この状態は、「すべてのリンクは、定格MTUよりも大きいパケットを超えるパケットを非管理に配信する可能性があるリンクに強制する必要があります。"
    },
    {
      "indent": 3,
      "text": "MAX_PLPMTU: The MAX_PLPMTU is the largest size of PLPMTU that DPLPMTUD will attempt to use (see the constants defined in Section 5.1.2).",
      "ja": "MAX_PLPMTU：MAX_PLPMTUは、DPLPMTUDが使用しようとするPLPMTUの最大サイズです（セクション5.1.2で定義されている定数を参照）。"
    },
    {
      "indent": 3,
      "text": "MIN_PLPMTU: The MIN_PLPMTU is the smallest size of PLPMTU that DPLPMTUD will attempt to use (see the constants defined in Section 5.1.2).",
      "ja": "MIN_PLPMTU：MIN_PLPMTUは、DPLPMTUDが使用しようとするPLPMTUの最小サイズです（セクション5.1.2で定義されている定数を参照）。"
    },
    {
      "indent": 3,
      "text": "MPS: The Maximum Packet Size (MPS) is the largest size of application data block that can be sent across a network path by a PL using a single datagram (see Section 4.4).",
      "ja": "MPS：最大パケットサイズ（MPS）は、単一のデータグラムを使用してPLによってネットワークパスを介して送信できるアプリケーションデータブロックの最大サイズです（セクション4.4を参照）。"
    },
    {
      "indent": 3,
      "text": "MSL: The Maximum Segment Lifetime (MSL) is the maximum delay a packet is expected to experience across a path, taken as 2 minutes [BCP145].",
      "ja": "MSL：最大セグメントの有効期間（MSL）は最大遅延です。パケットは、2分~2分とされているパス全体で発生すると予想されます。"
    },
    {
      "indent": 3,
      "text": "Packet: A packet is the IP header(s) and any extension headers/ options plus the IP payload.",
      "ja": "パケット：パケットはIPヘッダーと拡張ヘッダー/オプションとIPペイロードです。"
    },
    {
      "indent": 3,
      "text": "Packetization Layer (PL): The PL is a layer of the network stack that places data into packets and performs transport protocol functions. Examples of a PL include TCP, SCTP, SCTP over UDP, SCTP over DTLS, or QUIC.",
      "ja": "Packetization Layer（PL）：PLは、データをパケットに配置し、トランスポートプロトコル機能を実行するネットワークスタックのレイヤです。PLの例には、TCP、SCTP、SCTPがUDP、SCTP、DTL、またはQUICなどがあります。"
    },
    {
      "indent": 3,
      "text": "Path: The path is the set of links and routers traversed by a packet between a source node and a destination node by a particular flow.",
      "ja": "パス：パスは、ソースノードと宛先ノードとの間のパケットが特定のフローによってトラバースされたリンクのセットです。"
    },
    {
      "indent": 3,
      "text": "Path MTU (PMTU): The Path MTU (PMTU) is the minimum of the link MTU of all the links forming a network path between a source node and a destination node, as used by PMTUD.",
      "ja": "パスMTU（PMTU）：PATU（PMTU）は、PMTUDによって使用されるように、ソースノードと宛先ノードとの間のネットワーク経路を構成する全てのリンクのリンクMTUの最小値である。"
    },
    {
      "indent": 3,
      "text": "PTB: In this document, the term PTB message is applied to both IPv4 ICMP Unreachable messages (Type 3) that carry the error Fragmentation Needed (Type 3, Code 4) [RFC0792] and ICMPv6 Packet Too Big messages (Type 2) [RFC4443].",
      "ja": "PTB：このドキュメントでは、PTBメッセージという用語は、必要なエラーフラグメンテーション（タイプ3、コード4）[RFC0792] [RFC0792]とICMPv6パケットの両方のIPv4 ICMP到達不能メッセージ（RFC0792]（タイプ2）[RFC4443）に適用されます。]。"
    },
    {
      "indent": 3,
      "text": "PTB_SIZE: The PTB_SIZE is a value reported in a validated PTB message that indicates next-hop link MTU of a router along the path.",
      "ja": "PTB_SIZE：PTB_SIZEは、パスに沿ったルータのネクストホップリンクMTUを示す検証済みのPTBメッセージで報告された値です。"
    },
    {
      "indent": 3,
      "text": "PL_PTB_SIZE: The size reported in a validated PTB message, reduced by the size of all headers added by layers below the PL.",
      "ja": "pl_ptb_size：検証済みのPTBメッセージで報告されたサイズは、PLの下にある層によって追加されたすべてのヘッダーのサイズによって減少しました。"
    },
    {
      "indent": 3,
      "text": "PLPMTU: The Packetization Layer PMTU is an estimate of the largest size of PL datagram that can be sent by a path, controlled by PLPMTUD.",
      "ja": "PLPMTU：パケット化レイヤPMTUは、PLPMTUDによって制御されたパスによって送信され得るPLデータグラムの最大サイズの推定値です。"
    },
    {
      "indent": 3,
      "text": "PLPMTUD: Packetization Layer Path MTU Discovery (PLPMTUD), the method described in this document for datagram PLs, which is an extension to Classical PMTU Discovery.",
      "ja": "PLPMTUD：パケット化レイヤパスMTUディスカバリ（PLPMTUD）、この文書に記載されているメソッドは、古典的なPMTUディスカバリーの拡張です。"
    },
    {
      "indent": 3,
      "text": "Probe packet: A probe packet is a datagram sent with a purposely chosen size (typically the current PLPMTU or larger) to detect if packets of this size can be successfully sent end-to-end across the network path.",
      "ja": "プローブパケット：プローブパケットは、このサイズのパケットがネットワークパスを介してエンドツーエンドで正常に送信されることができるかどうかを検出するための意図的に選択されたサイズ（通常は現在のPLPMTU以上）で送信されたデータグラムです。"
    },
    {
      "indent": 3,
      "text": "Unacknowledged PL: A PL that does not itself provide a mechanism to confirm delivery of datagrams to the remote PL endpoint (e.g., UDP), and therefore requires DPLPMTUD to provide a mechanism to detect black-holing of packets (c.f., Acknowledged PL).",
      "ja": "未確認PL：それ自体がそれ自体がリモートPLエンドポイント（例えば、UDP）への配信を確認するためのメカニズムを提供しないため、パケットのブラックホリングを検出するためのメカニズムを提供するためにDPLPMTUD（ack.pl）を提供するためのメカニズムが必要である。"
    },
    {
      "indent": 0,
      "text": "3. Features Required to Provide Datagram PLPMTUD",
      "section_title": true,
      "ja": "3. データグラムPLPMTUDを提供するために必要な機能"
    },
    {
      "indent": 3,
      "text": "The principles expressed in [RFC4821] apply to the use of the technique with any PL. TCP PLPMTUD has been defined using standard TCP protocol mechanisms. Unlike TCP, a datagram PL requires additional mechanisms and considerations to implement PLPMTUD.",
      "ja": "[RFC4821]で表される原理は、任意のPLとの技術の使用に適用されます。TCP PLPMTUDは標準的なTCPプロトコルメカニズムを使用して定義されています。TCPとは異なり、データグラムPLはPLPMTUDを実装するための追加のメカニズムと考慮事項を必要とします。"
    },
    {
      "indent": 3,
      "text": "The requirements for datagram PLPMTUD are:",
      "ja": "データグラムPLPMTUDの要件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Managing the PLPMTU: For datagram PLs, the PLPMTU is managed by DPLPMTUD. A PL MUST NOT send a datagram (other than a probe packet) with a size at the PL that is larger than the current PLPMTU.",
      "ja": "1. PLPMTUの管理：データグラムPLSの場合、PLPMTUはDPLPMTUDによって管理されています。PLは、現在のPLPMTUよりも大きいPLのサイズでデータグラム（プローブパケット以外）を送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "2. Probe packets: The network interface below the PL is REQUIRED to provide a way to transmit a probe packet that is larger than the PLPMTU. In IPv4, a probe packet MUST be sent with the Don't Fragment (DF) bit set in the IP header and without network layer endpoint fragmentation. In IPv6, a probe packet is always sent without source fragmentation (as specified in Section 5.4 of [RFC8201]).",
      "ja": "2. プローブパケット：PLの下のネットワークインターフェースは、PLPMTUよりも大きいプローブパケットを送信する方法を提供するために必要です。IPv4では、プローブパケットは、IPヘッダーに設定されていないフラグメント（DF）ビットを送信し、ネットワーク層のエンドポイントの断片化なしで送信する必要があります。IPv6では、プローブパケットは常にソースの断片化なしで送信されます（[RFC8201]のセクション5.4で指定）。"
    },
    {
      "indent": 3,
      "text": "3. Reception feedback: The destination PL endpoint is REQUIRED to provide a feedback method that indicates to the DPLPMTUD sender when a probe packet has been received by the destination PL endpoint. Section 6 provides examples of how a PL can provide this acknowledgment of received probe packets.",
      "ja": "3. 受信フィードバック：宛先PLエンドポイントは、プローブパケットが宛先PLエンドポイントによって受信されたときにDPLPMTUD送信側を示すフィードバック方法を提供する必要があります。セクション6は、PLが受信したプローブパケットのこの確認応答をどのように提供できるかの例を示しています。"
    },
    {
      "indent": 3,
      "text": "4. Probe loss recovery: It is RECOMMENDED to use probe packets that do not carry any user data that would require retransmission if lost. Most datagram transports permit this. If a probe packet contains user data requiring retransmission in case of loss, the PL (or layers above) is REQUIRED to arrange any retransmission and/or repair of any resulting loss. The PL is REQUIRED to be robust in the case where probe packets are lost due to other reasons (including link transmission error, congestion).",
      "ja": "4. プローブ損失の回復：失われた場合に再送信を必要とするユーザーデータを持たないプローブパケットを使用することをお勧めします。ほとんどのデータグラムトランスポートはこれを許可します。プローブパケットが損失の場合に再送を必要とするユーザーデータを含む場合、結果として生じる損失の再送信および/または修理を調整するためには、PL（または上記の層）が必要です。PLは、プローブパケットが他の理由から失われる場合（リンク伝送誤差、輻輳を含む）の場合には堅牢であることが必要です。"
    },
    {
      "indent": 3,
      "text": "5. PMTU parameters: A DPLPMTUD sender is RECOMMENDED to utilize information about the maximum size of packet that can be transmitted by the sender on the local link (e.g., the local link MTU). A PL sender MAY utilize similar information about the maximum size of network-layer packet that a receiver can accept when this is supplied (note this could be less than EMTU_R). This avoids implementations trying to send probe packets that cannot be transferred by the local link. Too high of a value could reduce the efficiency of the search algorithm. Some applications also have a maximum transport protocol data unit (PDU) size, in which case there is no benefit from probing for a size larger than this (unless a transport allows multiplexing multiple applications' PDUs into the same datagram).",
      "ja": "5. PMTUパラメータ：DPLPMTUD送信者は、ローカルリンク（例えば、ローカルリンクMTU）上の送信者によって送信され得るパケットの最大サイズに関する情報を利用することを推奨する。PL送信者は、これが提供されたときに受信者が受け入れることができるネットワーク層パケットの最大サイズに関する同様の情報を利用することができる（これはEMTU_Rより小さい可能性がある）。これにより、ローカルリンクによって転送できないプローブパケットを送信しようとする実装が回避されます。値が高すぎると、検索アルゴリズムの効率が低下する可能性があります。一部のアプリケーションには、最大トランスポートプロトコルデータユニット（PDU）サイズもあります。その場合、この場合、これよりも大きいサイズのプロービングからの利点はありません（トランスポートが複数のアプリケーションのPDUを同じデータグラムに多重化することを許可しない限り）。"
    },
    {
      "indent": 3,
      "text": "6. Processing PTB messages: A DPLPMTUD sender MAY optionally utilize PTB messages received from the network layer to help identify when a network path does not support the current size of probe packet. Any received PTB message MUST be validated before it is used to update the PLPMTU discovery information [RFC8201]. This validation confirms that the PTB message was sent in response to a packet originated by the sender and needs to be performed before the PLPMTU discovery method reacts to the PTB message. A PTB message MUST NOT be used to increase the PLPMTU [RFC8201] but could trigger a probe to test for a larger PLPMTU. A valid PTB_SIZE is converted to a PL_PTB_SIZE before it is to be used in the DPLPMTUD state machine. A PL_PTB_SIZE that is greater than that currently probed SHOULD be ignored. (This PTB message ought to be discarded without further processing but could be utilized as an input that enables a resilience mode).",
      "ja": "6. PTBメッセージの処理：DPLPMTUD送信側は、ネットワーク層から受信したPTBメッセージをオプションで利用して、ネットワークパスが現在のサイズのプローブパケットのサイズをサポートしない場合に識別するのに役立ちます。受信されたPTBメッセージは、PLPMTU検出情報[RFC8201]を更新する前に検証されなければなりません。この検証は、PTBメッセージが送信者によって発信されたパケットに応答して送信され、PLPMTU検出方法がPTBメッセージに反応する前に実行される必要があることを確認します。PTBメッセージを使用してPLPMTU [RFC8201]を増やすことはできませんが、PLPMTUが大きいプローブをテストするためのプローブをトリガーする可能性があります。有効なPTB_SIZEは、DPLPMTUDステートマシンで使用される前にPL_PTB_SIZEに変換されます。現在プローブされているものよりも大きいpl_ptb_sizeは無視されるべきです。（このPTBメッセージは、さらなる処理なしで破棄されるべきであるが、回復力モードを可能にする入力として利用することができる。"
    },
    {
      "indent": 3,
      "text": "7. Probing and congestion control: A PL MAY use a congestion controller to decide when to send a probe packet. If transmission of probe packets is limited by the congestion controller, this could result in transmission of probe packets being delayed or suspended during congestion. When the transmission of probe packets is not controlled by the congestion controller, the interval between probe packets MUST be at least one RTT. Loss of a probe packet SHOULD NOT be treated as an indication of congestion and SHOULD NOT trigger a congestion control reaction [RFC4821] because this could result in unnecessary reduction of the sending rate. An update to the PLPMTU (or MPS) MUST NOT increase the congestion window measured in bytes [RFC4821]. Therefore, an increase in the packet size does not cause an increase in the data rate in bytes per second. A PL that maintains the congestion window in terms of a limit to the number of outstanding fixed-size packets SHOULD adapt this limit to compensate for the size of the actual packets. The transmission of probe packets can interact with the operation of a PL that performs burst mitigation or pacing, and the PL could need transmission of probe packets to be regulated by these methods.",
      "ja": "7. プロービングと輻輳制御：PLは、プローブパケットをいつ送信するかを決定するために輻輳コントローラを使用することができます。プローブパケットの送信が輻輳コントローラによって制限されている場合、これは輻輳時に遅延または中断されているプローブパケットの送信をもたらす可能性がある。プローブパケットの送信が輻輳コントローラによって制御されない場合、プローブパケット間の間隔は少なくとも1つのRTTでなければなりません。プローブパケットの損失は輻輳の指示として扱われるべきではなく、輻輳制御反応を起動するべきではありません[RFC4821]は、送信速度の不必要な減少をもたらす可能性があるため、[RFC4821]。 PLPMTU（またはMPS）への更新は、バイトで測定された輻輳ウィンドウを増やしてはいけません[RFC4821]。したがって、パケットサイズの増加は、1秒あたりのデータレートの増加をバイト単位で増加させない。渋滞ウィンドウを抜群の固定サイズのパケットの数に制限の点で維持するPLは、実際のパケットのサイズを補償するためにこの制限を適応させる必要があります。プローブパケットの送信は、バースト緩和またはペーシングを実行するPLの動作と対話することができ、PLはこれらの方法によって調整されるべきプローブパケットの伝送を必要とする可能性がある。"
    },
    {
      "indent": 3,
      "text": "8. Probing and flow control: Flow control at the PL concerns the end-to-end flow of data using the PL service. Flow control SHOULD NOT apply to DPLPMTU when probe packets use a design that does not carry user data to the remote application.",
      "ja": "8. プロービングとフロー制御PLのフロー制御PLサービスを使用したデータのエンドツーエンドのデータの流れが関係しています。プローブパケットがユーザーデータをリモートアプリケーションに伝送しないデザインを使用すると、フロー制御はDPLPMTUに適用しないでください。"
    },
    {
      "indent": 3,
      "text": "9. Shared PLPMTU state: The PMTU value calculated from the PLPMTU MAY also be stored with the corresponding entry associated with the destination in the IP layer cache and used by other PL instances. The specification of PLPMTUD [RFC4821] states, \"If PLPMTUD updates the MTU for a particular path, all Packetization Layer sessions that share the path representation (as described in Section 5.2) SHOULD be notified to make use of the new MTU\". Such methods MUST be robust to the wide variety of underlying network forwarding behaviors. Section 5.2 of [RFC8201] provides guidance on the caching of PMTU information and also the relation to IPv6 flow labels.",
      "ja": "9. 共有PLPMTU状態：PLPMTUから計算されたPMTU値は、IPレイヤキャッシュ内の宛先に関連付けられている対応するエントリと共に、他のPLインスタンスによって使用されることもある。PLPMTUD [RFC4821]の仕様「PLPMTUDが特定のパスについてMTUを更新する場合は、（セクション5.2で説明したように）パス表現を共有するすべてのパケット化層セッションを新しいMTUを利用するように通知する必要があります。そのような方法は、さまざまな根本的なネットワーク転送行動に堅牢でなければなりません。[RFC8201]のセクション5.2は、PMTU情報のキャッシングとIPv6フローラベルとの関係に関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "In addition, the following principles are stated for design of a DPLPMTUD method:",
      "ja": "さらに、DPLPMTUD法の設計には、以下の原則が記載されています。"
    },
    {
      "indent": 3,
      "text": "* A PL MAY be designed to segment data blocks larger than the MPS into multiple datagrams. However, not all datagram PLs support segmentation of data blocks. It is RECOMMENDED that methods avoid forcing an application to use an arbitrary small MPS for transmission while the method is searching for the currently supported PLPMTU. A reduced MPS can adversely impact the performance of an application.",
      "ja": "* PLは、MPよりも大きいデータブロックを複数のデータグラムにセグメント化するように設計されてもよい。ただし、すべてのデータグラムPLSがデータブロックのセグメンテーションをサポートしているわけではありません。方法が現在サポートされているPLPMTUを検索している間に、送信に任意の小MPを使用するようにアプリケーションを強制的に回避することをお勧めします。縮小されたMPSはアプリケーションの性能に悪影響を及ぼす可能性があります。"
    },
    {
      "indent": 3,
      "text": "* To assist applications in choosing a suitable data block size, the PL is RECOMMENDED to provide a primitive that returns the MPS derived from the PLPMTU to the higher layer using the PL. The value of the MPS can change following a change in the path or loss of probe packets.",
      "ja": "* 適切なデータブロックサイズを選択する際のアプリケーションを支援するために、PLを使用してPLPMTUから派生したMPSを上位レイヤに返すプリミティブを提供することをお勧めします。MPSの値は、プローブパケットの経路の変化または損失の後に変化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* Path validation: It is RECOMMENDED that methods are robust to path changes that could have occurred since the path characteristics were last confirmed and to the possibility of inconsistent path information being received.",
      "ja": "* パス検証：パス特性が最後に確認されたため、経路情報が矛盾している可能性と受信されている可能性があるため、メソッドが経路変更に堅牢であることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Datagram reordering: A method is REQUIRED to be robust to the possibility that a flow encounters reordering or that the traffic (including probe packets) is divided over more than one network path.",
      "ja": "* データグラムの並べ替え：メソッドは、フローが並べ替えに遭遇する可能性が堅牢であること、またはトラフィック（プローブパケットを含む）が複数のネットワークパスに分割されている可能性が必要です。"
    },
    {
      "indent": 3,
      "text": "* Datagram delay and duplication: The feedback mechanism is REQUIRED to be robust to the possibility that packets could be significantly delayed or duplicated along a network path.",
      "ja": "* データグラムの遅延と重複：フィードバックメカニズムは、パケットがネットワーク経路に沿って大幅に遅れるか複製される可能性に堅牢であることが必要です。"
    },
    {
      "indent": 3,
      "text": "* When to probe: It is RECOMMENDED that methods determine whether the path has changed since it last measured the path. This can help determine when to probe the path again.",
      "ja": "* プローブするとき：パスを最後に測定してからパスが変更されたかどうかをメソッドが判断することをお勧めします。これにより、パスをもう一度プローブするかを決定するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4. DPLPMTUD Mechanisms",
      "section_title": true,
      "ja": "4. DPLPMTUDメカニズム"
    },
    {
      "indent": 3,
      "text": "This section lists the protocol mechanisms used in this specification.",
      "ja": "このセクションでは、この仕様で使用されているプロトコルメカニズムを示します。"
    },
    {
      "indent": 0,
      "text": "4.1. PLPMTU Probe Packets",
      "section_title": true,
      "ja": "4.1. PLPMTUプローブパケット"
    },
    {
      "indent": 3,
      "text": "The DPLPMTUD method relies upon the PL sender being able to generate probe packets with a specific size. TCP is able to generate these probe packets by choosing to appropriately segment data being sent [RFC4821]. In contrast, a datagram PL that constructs a probe packet has to either request an application to send a data block that is larger than that generated by an application, or to utilize padding functions to extend a datagram beyond the size of the application data block. Protocols that permit exchange of control messages (without an application data block) can generate a probe packet by extending a control message with padding data. The total size of a probe packet includes all headers and padding added to the payload data being sent (e.g., including protocol option fields, security-related fields such as an Authenticated Encryption with Associated Data (AEAD) tag, and TLS record layer padding).",
      "ja": "DPLPMTUDメソッドは、PL送信者が特定のサイズのプローブパケットを生成することができるように依存しています。TCPは、送信されているデータを適切にセグメント化することを選択することによってこれらのプローブパケットを生成することができます[RFC4821]。対照的に、プローブパケットを構築するデータグラムPLは、アプリケーションによって生成されたものよりも大きいデータブロックを送信するか、またはアプリケーションデータブロックのサイズを超えてデータグラムを拡張するためのパディング関数を利用するためのアプリケーションを要求する必要がある。制御メッセージの交換を許可するプロトコル（アプリケーションデータブロック）は、パディングデータを含む制御メッセージを拡張することによってプローブパケットを生成することができる。プローブパケットの合計サイズには、送信されているペイロードデータに追加されたすべてのヘッダとパディングが含まれています（たとえば、プロトコルオプションのフィールド、関連するデータ（AED）タグを含む認証された暗号化などのセキュリティ関連のフィールド、およびTLSレコードのパディングなど）。"
    },
    {
      "indent": 3,
      "text": "A receiver is REQUIRED to be able to distinguish an in-band data block from any added padding. This is needed to ensure that any added padding is not passed on to an application at the receiver.",
      "ja": "受信機は、帯域内データブロックを任意の追加されたパディングと区別できることが要求される。これは、追加されたパディングが受信機でアプリケーションに渡されないようにするために必要です。"
    },
    {
      "indent": 3,
      "text": "This results in three possible ways that a sender can create a probe packet:",
      "ja": "これにより、送信者がプローブパケットを作成できる3つの方法があります。"
    },
    {
      "indent": 3,
      "text": "Probing using padding data: A probe packet that contains only control information together with any padding, which is needed to inflate to the size of the probe packet. Since these probe packets do not carry an application-supplied data block, they do not typically require retransmission, although they do still consume network capacity and incur endpoint processing.",
      "ja": "パディングデータを使用したプロービング：プローブパケットのサイズに膨張するのに必要な任意のパディングと一緒に制御情報のみを含むプローブパケット。これらのプローブパケットはアプリケーション提供のデータブロックを搬送しないので、それらは通常再送を必要としないが、それでもネットワーク容量を消費し、エンドポイント処理を生み出す。"
    },
    {
      "indent": 3,
      "text": "Probing using application data and padding data: A probe packet that contains a data block supplied by an application that is combined with padding to inflate the length of the datagram to the size of the probe packet.",
      "ja": "アプリケーションデータとパディングデータを使用したプロービング：データグラムの長さをプローブパケットのサイズに膨張させるためにパディングと組み合わされるアプリケーションによって提供されるデータブロックを含むプローブパケット。"
    },
    {
      "indent": 3,
      "text": "Probing using application data: A probe packet that contains a data block supplied by an application that matches the size of the probe packet. This method requests the application to issue a data block of the desired probe size.",
      "ja": "アプリケーションデータを使用したプロービングプローブパケットのサイズと一致するアプリケーションによって提供されるデータブロックを含むプローブパケット。このメソッドは、アプリケーションに、目的のプローブサイズのデータブロックを発行するように要求します。"
    },
    {
      "indent": 3,
      "text": "A PL that uses a probe packet carrying application data and that needs protection from the loss of this probe packet could perform transport-layer retransmission/repair of the data block (e.g., by retransmitting after loss is detected or by duplicating the data block in a datagram without the padding data). This retransmitted data block might possibly need to be sent using a smaller PLPMTU, which could force the PL to use a smaller packet size to traverse the end-to-end path. (This could utilize endpoint network-layer fragmentation or a PL that can resegment the data block into multiple datagrams).",
      "ja": "アプリケーションデータを搬送するプローブパケットを使用し、このプローブパケットの損失から保護を必要とするPLは、データブロックのトランスポート層再送信/修復を実行することができる（例えば、損失が検出された後に再送信することによって、またはデータブロックを複製することによって）。パディングデータなしのデータグラム）。この再送データブロックは、小さいPLPMTUを使用して送信される可能性がある可能性があります。（これは、データブロックを複数のデータグラムに引き出すことができるエンドポイントネットワーク層の断片化またはPLを利用できます）。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD MAY choose to use only one of these methods to simplify the implementation.",
      "ja": "DPLPMTUDは、実装を単純化するためにこれらの方法のうちの1つだけを使用することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Probe messages sent by a PL MUST contain enough information to uniquely identify the probe within the Maximum Segment Lifetime (e.g., including a unique identifier from the PL or the DPLPMTUD implementation), while being robust to reordering and replay of probe response and PTB messages.",
      "ja": "PLによって送信されたプローブメッセージは、プローブ応答およびPTBメッセージの並べ替えおよび再生に堅牢でありながら、最大セグメント寿命（例えば、PLまたはDPLPMTUD実装からの一意の識別子を含む）内のプローブを一意に識別するのに十分な情報を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Confirmation of Probed Packet Size",
      "section_title": true,
      "ja": "4.2. プローブされたパケットサイズの確認"
    },
    {
      "indent": 3,
      "text": "The PL needs a method to determine (confirm) when probe packets have been successfully received end-to-end across a network path.",
      "ja": "PLは、プローブパケットがネットワーク経路を介してエンドツーエンドに正常に受信されたときに（確認）する方法が必要です。"
    },
    {
      "indent": 3,
      "text": "Transport protocols can include end-to-end methods that detect and report reception of specific datagrams that they send (e.g., DCCP, SCTP, and QUIC provide keep-alive/heartbeat features). When supported, this mechanism MAY also be used by DPLPMTUD to acknowledge reception of a probe packet.",
      "ja": "トランスポートプロトコルには、送信する特定のデータグラムの受信を検出して報告するエンドツーエンドのメソッドが含まれます（例えば、DCCP、SCTP、およびQUICは、キープアライブ/ハートビート機能を提供します）。サポートされると、このメカニズムは、プローブパケットの受信を確認するためにDPLPMTUDによっても使用され得る。"
    },
    {
      "indent": 3,
      "text": "A PL that does not acknowledge data reception (e.g., UDP and UDP-Lite) is unable itself to detect when the packets that it sends are discarded because their size is greater than the actual PMTU. These PLs need to rely on an application protocol to detect this loss.",
      "ja": "データ受信（例えば、UDPおよびUDP-Lite）を確認しないPLは、それが送信するパケットが実際のPMTUより大きいので破棄されるのを検出することができません。この損失を検出するために、これらのPLSはアプリケーションプロトコルに頼る必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 6 specifies this function for a set of IETF-specified protocols.",
      "ja": "セクション6は、一連のIETF規定プロトコルの機能を指定します。"
    },
    {
      "indent": 0,
      "text": "4.3. Black Hole Detection and Reducing the PLPMTU",
      "section_title": true,
      "ja": "4.3. ブラックホール検出とPLPMTUの減少"
    },
    {
      "indent": 3,
      "text": "The description that follows uses the set of constants defined in Section 5.1.2 and variables defined in Section 5.1.3.",
      "ja": "以下の説明は、セクション5.1.2で定義されている一連の定数とセクション5.1.3で定義されている変数を使用します。"
    },
    {
      "indent": 3,
      "text": "Black hole detection is triggered by an indication that the network path could be unable to support the current PLPMTU size.",
      "ja": "ブラックホール検出は、ネットワークパスが現在のPLPMTUサイズをサポートできない可能性があるという表示によってトリガされます。"
    },
    {
      "indent": 3,
      "text": "There are three indicators that can be used to detect black holes:",
      "ja": "ブラックホールを検出するために使用できる3つの指標があります。"
    },
    {
      "indent": 3,
      "text": "* A validated PTB message can be received that indicates a PL_PTB_SIZE less than the current PLPMTU. A DPLPMTUD method MUST NOT rely solely on this method.",
      "ja": "* 現在のPLPMTUよりも小さいPL_PTB_SIZEを示す有効なPTBメッセージを受信することができる。DPLPMTUDメソッドは、この方法のみに依存してはいけません。"
    },
    {
      "indent": 3,
      "text": "* A PL can use the DPLPMTUD probing mechanism to periodically generate probe packets of the size of the current PLPMTU (e.g., using the CONFIRMATION_TIMER, Section 5.1.1). A timer tracks whether acknowledgments are received. Successive loss of probes is an indication that the current path no longer supports the PLPMTU (e.g., when the number of probe packets sent without receiving an acknowledgment, PROBE_COUNT, becomes greater than MAX_PROBES).",
      "ja": "* PLは、DPLPMTUDプロービングメカニズムを使用して、現在のPLPMTUのサイズのプローブパケットを周期的に（例えば、confiral_timer、セクション5.1.1を使用）。承認を受信したかどうかをトラックします。連続するプローブの損失は、現在の経路がPLPMTUをサポートしなくなったこと（例えば、確認応答を受信せずに送信されたプローブパケットの数がMAX_PROBEよりも大きくなる場合）という指標である。"
    },
    {
      "indent": 3,
      "text": "* A PL can utilize an event that indicates the network path no longer sustains the sender's PLPMTU size. This could use a mechanism implemented within the PL to detect excessive loss of data sent with a specific packet size and then conclude that this excessive loss could be a result of an invalid PLPMTU (as in PLPMTUD for TCP [RFC4821]).",
      "ja": "* PLは、ネットワークパスが送信者のPLPMTUサイズを持続しなくなったことを示すイベントを利用できます。これは、PL内に実装されたメカニズムを使用して、特定のパケットサイズで送信されたデータの過度の損失を検出し、次にこの過剰な損失が無効なPLPMTUの結果であると結論付けることができます（TCP [RFC4821のPLPMTUD]）。"
    },
    {
      "indent": 3,
      "text": "The three methods can result in different transmission patterns for packet probes and are expected to result in different responsiveness following a change in the actual PMTU.",
      "ja": "3つの方法は、パケットプローブのための異なる伝送パターンをもたらし、実際のPMTUの変化に続く応答性が異なると予想される。"
    },
    {
      "indent": 3,
      "text": "A PL MAY inhibit sending probe packets when no application data has been sent since the previous probe packet. A PL that resumes sending user data MAY continue PLPMTU discovery for each path. This allows it to use an up-to-date PLPMTU. However, this could result in additional packets being sent.",
      "ja": "PLは、前のプローブパケット以降にアプリケーションデータが送信されていないときにプローブパケットを送信することを禁止することができる。ユーザデータの送信を再開するPLは、各パスに対してPLPMTUディスカバリを継続する可能性がある。これにより、最新のPLPMTUを使用できます。ただし、これにより追加のパケットが送信される可能性があります。"
    },
    {
      "indent": 3,
      "text": "When the method detects that the current PLPMTU is not supported, DPLPMTUD sets a lower PLPMTU and a lower MPS. The PL then confirms that the new PLPMTU can be successfully used across the path. A probe packet could need to be smaller than the size of the data block generated by the application.",
      "ja": "現在のPLPMTUがサポートされていないことをメソッドが検出した場合、DPLPMTUDは下位PLPMTUと低いMPSを設定します。PLは、新しいPLPMTUがパス全体で正常に使用できることを確認します。プローブパケットは、アプリケーションによって生成されたデータブロックのサイズより小さくする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. The Maximum Packet Size (MPS)",
      "section_title": true,
      "ja": "4.4. 最大パケットサイズ（MPS）"
    },
    {
      "indent": 3,
      "text": "The result of probing determines a usable PLPMTU, which is used to set the MPS used by the application. The MPS is smaller than the PLPMTU because it is reduced by the size of PL headers (including the overhead of security-related fields such as an AEAD tag and TLS record layer padding). The relationship between the MPS and the PLPMTUD is illustrated in Figure 1.",
      "ja": "プロービングの結果は、アプリケーションによって使用されるMPSを設定するために使用される使用可能なPLPMTUを決定します。MPSはPLPMTUよりも小さくなります（AEADタグやTLSレコードレイヤパディングなどのセキュリティ関連フィールドのオーバーヘッドを含む）。MPとPLPMTUDとの関係を図1に示す。"
    },
    {
      "indent": 3,
      "text": "Any additional\n  headers         .--- MPS -----.\n         |        |             |\n         v        v             v\n  +------------------------------+\n  | IP | ** | PL | protocol data |\n  +------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "           <----- PLPMTU ----->\n<---------- PMTU -------------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 1: Relationship between MPS and PLPMTU",
      "ja": "図1：MPSとPLPMTUの関係"
    },
    {
      "indent": 3,
      "text": "A PL is unable to send a packet (other than a probe packet) with a size larger than the current PLPMTU at the network layer. To avoid this, a PL MAY be designed to segment data blocks larger than the MPS into multiple datagrams.",
      "ja": "PLは、ネットワーク層の現在のPLPMTUよりも大きいサイズのパケット（プローブパケット以外）を送信することができない。これを回避するために、PLは、MPよりも大きいデータブロックを複数のデータグラムにセグメント化するように設計されてもよい。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD seeks to avoid IP fragmentation. An attempt to send a data block larger than the MPS will therefore fail if a PL is unable to segment data. To determine the largest data block that can be sent, a PL SHOULD provide applications with a primitive that returns the MPS, derived from the current PLPMTU.",
      "ja": "DPLPMTUDはIPフラグメンテーションを避けようとしています。したがって、MPSより大きいデータブロックを送信しようとすると、PLがデータをセグメント化できない場合は失敗します。送信できる最大のデータブロックを決定するために、PLは現在のPLPMTUから派生したMPSを返すプリミティブをアプリケーションに提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "If DPLPMTUD results in a change to the MPS, the application needs to adapt to the new MPS. A particular case can arise when packets have been sent with a size less than the MPS and the PLPMTU was subsequently reduced. If these packets are lost, the PL MAY segment the data using the new MPS. If a PL is unable to resegment a previously sent datagram (e.g., [RFC4960]), then the sender either discards the datagram or could perform retransmission using network-layer fragmentation to form multiple IP packets not larger than the PLPMTU. For IPv4, the use of endpoint fragmentation by the sender is preferred over clearing the DF bit in the IPv4 header. Operational experience reveals that IP fragmentation can reduce the reliability of Internet communication [RFC8900], which may reduce the probability of successful retransmission.",
      "ja": "DPLPMTUDがMPSへの変更をもたらす場合、アプリケーションは新しいMPに適応する必要があります。パケットがMPSよりも小さいサイズで送信され、その後PLPMTUが減少したときに特定のケースが発生する可能性があります。これらのパケットが失われると、PLは新しいMPSを使用してデータをセグメント化することができます。PLが以前に送信されたデータグラム（例えば[RFC4960]）を引き出すことができない場合、送信者はデータグラムを破棄し、またはネットワーク層の断片化を使用して再送信を実行してPLPMTU以下の複数のIPパケットを形成することができる。IPv4の場合、送信者によるエンドポイントフラグメンテーションの使用は、IPv4ヘッダー内のDFビットをクリアするよりも優先されます。運用経験は、IPフラグメンテーションがインターネット通信の信頼性を低下させる可能性があることを明らかにしており、これにより再送信が成功した可能性が低下する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.5. Disabling the Effect of PMTUD",
      "section_title": true,
      "ja": "4.5. PMTUDの効果を無効にします"
    },
    {
      "indent": 3,
      "text": "A PL implementing this specification MUST suspend network layer processing of outgoing packets that enforces a PMTU [RFC1191][RFC8201] for each flow utilizing DPLPMTUD and instead use DPLPMTUD to control the size of packets that are sent by a flow. This removes the need for the network layer to drop or to fragment sent packets that have a size greater than the PMTU.",
      "ja": "この仕様を実装するPLは、DPLPMTUDを利用した各フローに対してPMTU [RFC1191] [RFC8201]を強制する発信パケットのネットワーク層処理を一時停止しなければならず、代わりにDPLPMTUDを使用してフローによって送信されるパケットのサイズを制御します。これにより、ネットワーク層がPMTUよりも大きいサイズを持つ送信されたパケットを削除またはフラグメント化する必要がなくなります。"
    },
    {
      "indent": 0,
      "text": "4.6. Response to PTB Messages",
      "section_title": true,
      "ja": "4.6. PTBメッセージへの応答"
    },
    {
      "indent": 3,
      "text": "This method requires the DPLPMTUD sender to validate any received PTB message before using the PTB information. The response to a PTB message depends on the PL_PTB_SIZE calculated from the PTB_SIZE in the PTB message, the state of the PLPMTUD state machine, and the IP protocol being used.",
      "ja": "この方法では、DPLPMTUD送信者がPTB情報を使用する前に受信したPTBメッセージを検証する必要があります。PTBメッセージに対する応答は、PTBメッセージのPTB_SIZE、PLPMTUDステートマシンの状態、および使用されているIPプロトコルから計算されたPL_PTB_SIZEによって異なります。"
    },
    {
      "indent": 3,
      "text": "Section 4.6.1 describes validation for both IPv4 ICMP Unreachable messages (Type 3) and ICMPv6 Packet Too Big messages, both of which are referred to as PTB messages in this document.",
      "ja": "セクション4.6.1は、両方のIPv4 ICMP到達不能メッセージ（タイプ3）およびICMPv6パケットの両方の検証を説明し、どちらもこのドキュメントのPTBメッセージと呼ばれます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Validation of PTB Messages",
      "section_title": true,
      "ja": "4.6.1. PTBメッセージの検証"
    },
    {
      "indent": 3,
      "text": "This section specifies utilization and validation of PTB messages.",
      "ja": "このセクションでは、PTBメッセージの使用率と検証を指定します。"
    },
    {
      "indent": 3,
      "text": "* A simple implementation MAY ignore received PTB messages, and in this case, the PLPMTU is not updated when a PTB message is received.",
      "ja": "* 簡単な実装では受信されたPTBメッセージを無視することができ、この場合、PTBメッセージを受信したときにPLPMTUは更新されない。"
    },
    {
      "indent": 3,
      "text": "* A PL that supports PTB messages MUST validate these messages before they are further processed.",
      "ja": "* PTBメッセージをサポートするPLは、さらに処理される前にこれらのメッセージを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "A PL that receives a PTB message from a router or middlebox performs ICMP validation (see Section 4 of [RFC8201] and Section 5.2 of [BCP145]). Because DPLPMTUD operates at the PL, the PL needs to check that each received PTB message is received in response to a packet transmitted by the endpoint PL performing DPLPMTUD.",
      "ja": "ルータまたはミドルボックスからPTBメッセージを受信するPLはICMP検証を実行します（[RFC8201]のセクション4と[BCP145]のセクション5.2）。DPLPMTUDはPLで動作するので、PLは、DPLPMTUDを実行するエンドポイントPLによって送信されたパケットに応答して、受信した各PTBメッセージが受信されていることを確認する必要がある。"
    },
    {
      "indent": 3,
      "text": "The PL MUST check the protocol information in the quoted packet carried in an ICMP PTB message payload to validate the message originated from the sending node. This validation includes determining that the combination of the IP addresses, the protocol, the source port, and destination port match those returned in the quoted packet -- this is also necessary for the PTB message to be passed to the corresponding PL.",
      "ja": "PLは、送信ノードから発信されたメッセージを検証するためにICMP PTBメッセージペイロードで実行されている引用符付きパケット内のプロトコル情報をチェックしなければならない。この検証は、IPアドレス、プロトコル、送信元ポート、および宛先ポートの組み合わせが、引用符付きパケットに返されたものと一致することを決定することを含む。これは、PTBメッセージが対応するPLに渡されるためにも必要である。"
    },
    {
      "indent": 3,
      "text": "The validation SHOULD utilize information that is not simple for an off-path attacker to determine [BCP145]. For example, it could check the value of a protocol header field known only to the two PL endpoints. A datagram application that uses well-known source and destination ports ought to also rely on other information to complete this validation.",
      "ja": "検証は、オフパスの攻撃者が簡単ではない情報を利用して[BCP145]を決定する必要があります。たとえば、2つのPLエンドポイントにのみ既知のプロトコルヘッダフィールドの値を確認できます。よく知られている送信元ポートと宛先ポートを使用するデータグラムアプリケーションは、この検証を完了するために他の情報にも依存する必要があります。"
    },
    {
      "indent": 3,
      "text": "These checks are intended to provide protection from packets that originate from a node that is not on the network path. A PTB message that does not complete the validation MUST NOT be further utilized by the DPLPMTUD method, as discussed in the Security Considerations section (Section 8).",
      "ja": "これらのチェックは、ネットワークパス上にないノードから発生するパケットからの保護を提供することを目的としています。セキュリティ上の考慮事項のセクションで説明したように、検証を完了しないPTBメッセージは、DPLPMTUDメソッドによってさらに利用されてはならない（セクション8）。"
    },
    {
      "indent": 3,
      "text": "Section 4.6.2 describes this processing of PTB messages.",
      "ja": "セクション4.6.2では、このPTBメッセージの処理について説明します。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Use of PTB Messages",
      "section_title": true,
      "ja": "4.6.2. PTBメッセージの使用"
    },
    {
      "indent": 3,
      "text": "PTB messages that have been validated MAY be utilized by the DPLPMTUD algorithm but MUST NOT be used directly to set the PLPMTU.",
      "ja": "検証されたPTBメッセージは、DPLPMTUDアルゴリズムによって利用されてもよいが、PLPMTUを設定するために直接使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Before using the size reported in the PTB message, it must first be converted to a PL_PTB_SIZE. The PL_PTB_SIZE is smaller than the PTB_SIZE because it is reduced by headers below the PL, including any IP options or extensions added to the PL packet.",
      "ja": "PTBメッセージに報告されているサイズを使用する前に、まずPL_PTB_SIZEに変換する必要があります。PL_PTB_SIZEは、PLの下のヘッダーに縮小されているため、PLパケットに追加されたIPオプションや拡張子を含めて、PLの下のヘッダーよりも小さくなります。"
    },
    {
      "indent": 3,
      "text": "A method that utilizes these PTB messages can improve the speed at which the algorithm detects an appropriate PLPMTU by triggering an immediate probe for the PL_PTB_SIZE (resulting in a network-layer packet of size PTB_SIZE), compared to one that relies solely on probing using a timer-based search algorithm.",
      "ja": "これらのPTBメッセージを利用する方法は、PL_PTB_SIZEのための即時プローブをトリガすることによってアルゴリズムが適切なPLPMTUを検出する速度を向上させることができる（サイズPTB_SIZEのネットワーク層パケットをもたらす）。タイマーベースの検索アルゴリズム"
    },
    {
      "indent": 3,
      "text": "A set of checks are intended to provide protection from a router that reports an unexpected PTB_SIZE. The PL also needs to check that the indicated PL_PTB_SIZE is less than the size used by probe packets and at least the minimum size accepted.",
      "ja": "一連のチェックは、予期しないPTB_SIZEを報告するルータからの保護を提供することを目的としています。PLはまた、示されたPL_PTB_SIZEがプローブパケットによって使用されるサイズより小さく、少なくとも最小サイズが受け入れられていることを確認する必要がある。"
    },
    {
      "indent": 3,
      "text": "This section provides a summary of how PTB messages can be utilized, using the set of constants defined in Section 5.1.2. This processing depends on the PL_PTB_SIZE and the current value of a set of variables:",
      "ja": "このセクションでは、セクション5.1.2で定義されている一連の定数を使用して、PTBメッセージを使用できる方法の概要を説明します。この処理は、PL_PTB_SIZEと変数のセットの現在の値によって異なります。"
    },
    {
      "indent": 3,
      "text": "PL_PTB_SIZE < MIN_PLPMTU * Invalid PL_PTB_SIZE, see Section 4.6.1.",
      "ja": "pl_ptb_size <min_plpmtu *無効なpl_ptb_sizeは、セクション4.6.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "* PTB message ought to be discarded without further processing (i.e., PLPMTU is not modified).",
      "ja": "* PTBメッセージは、さらなる処理なしに廃棄されるべきである（すなわち、PLPMTUは変更されていない）。"
    },
    {
      "indent": 6,
      "text": "* The information could be utilized as an input that triggers the enabling of a resilience mode (see Section 5.3.3).",
      "ja": "* 情報は、回復力モードの有効化を引き起こす入力として利用することができます（セクション5.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "MIN_PLPMTU < PL_PTB_SIZE < BASE_PLPMTU * A robust PL MAY enter an error state (see Section 5.2) for an IPv4 path when the PL_PTB_SIZE reported in the PTB message is larger than or equal to 68 bytes [RFC0791] and when this is less than the BASE_PLPMTU.",
      "ja": "MIN_PLPMTU <PL_PTB_SIZE <BASE_PLPMTU * PTBメッセージに報告されたPL_PTB_SIZEが68バイト以上のPL_PTB_SIZEが68バイト以上の場合、およびこれがbase_plpmtuよりも小さい場合に、エラー状態（5.2を参照）を入力することができます。。"
    },
    {
      "indent": 6,
      "text": "* A robust PL MAY enter an error state (see Section 5.2) for an IPv6 path when the PL_PTB_SIZE reported in the PTB message is larger than or equal to 1280 bytes [RFC8200] and when this is less than the BASE_PLPMTU.",
      "ja": "* PTBメッセージに報告されているPL_PTB_SIZEが1280バイト以上であり、これがbase_plpmtuよりも小さい場合、robust PLは、IPv6パスについてエラー状態（5.2節を参照）を入力することができる。"
    },
    {
      "indent": 3,
      "text": "BASE_PLPMTU <= PL_PTB_SIZE < PLPMTU * This could be an indication of a black hole. The PLPMTU SHOULD be set to BASE_PLPMTU (the PLPMTU is reduced to the BASE_PLPMTU to avoid unnecessary packet loss when a black hole is encountered).",
      "ja": "base_plpmtu <= pl_ptb_size <plpmtu *これはブラックホールの表示です。PLPMTUはbase_plpmtuに設定する必要があります（Base_PLPMTUに縮小されて、ブラックホールに遭遇したときの不要なパケット損失を防ぐため）。"
    },
    {
      "indent": 6,
      "text": "* The PL ought to start a search to quickly discover the new PLPMTU. The PL_PTB_SIZE reported in the PTB message can be used to initialize a search algorithm.",
      "ja": "* PLは新しいPLPMTUをすばやく発見するための検索を開始するべきです。PTBメッセージで報告されているPL_PTB_SIZEを使用して検索アルゴリズムを初期化できます。"
    },
    {
      "indent": 3,
      "text": "PLPMTU < PL_PTB_SIZE < PROBED_SIZE * The PLPMTU continues to be valid, but the size of a packet used to search (PROBED_SIZE) was larger than the actual PMTU.",
      "ja": "PLPMTU <PL_PTB_SIZE <probed_size * PLPMTUは有効であるが、検索に使用されるパケットのサイズ（probed_size）は実際のPMTUよりも大きかった。"
    },
    {
      "indent": 6,
      "text": "* The PLPMTU is not updated.",
      "ja": "* PLPMTUは更新されません。"
    },
    {
      "indent": 6,
      "text": "* The PL can use the reported PL_PTB_SIZE from the PTB message as the next search point when it resumes the search algorithm.",
      "ja": "* PLは、検索アルゴリズムを再開すると、次の検索ポイントとしてPTBメッセージから報告されたPL_PTB_SIZEを使用できます。"
    },
    {
      "indent": 3,
      "text": "PL_PTB_SIZE >= PROBED_SIZE * Inconsistent network signal.",
      "ja": "pl_ptb_size> = probed_size *矛盾するネットワーク信号。"
    },
    {
      "indent": 6,
      "text": "* PTB message ought to be discarded without further processing (i.e., PLPMTU is not modified).",
      "ja": "* PTBメッセージは、さらなる処理なしに廃棄されるべきである（すなわち、PLPMTUは変更されていない）。"
    },
    {
      "indent": 6,
      "text": "* The information could be utilized as an input to trigger the enabling of a resilience mode.",
      "ja": "* 情報は、回復力モードの有効化をトリガするための入力として利用することができる。"
    },
    {
      "indent": 0,
      "text": "5. Datagram Packetization Layer PMTUD",
      "section_title": true,
      "ja": "5. データグラムパケット化レイヤPMTUD"
    },
    {
      "indent": 3,
      "text": "This section specifies Datagram PLPMTUD (DPLPMTUD). The method can be introduced at various points (as indicated with * in Figure 2) in the IP protocol stack to discover the PLPMTU so that an application can utilize an appropriate MPS for the current network path.",
      "ja": "このセクションでは、データグラムPLPMTUD（DPLPMTUD）を指定します。アプリケーションが現在のネットワークパスに適切なMPを利用できるように、PLPMTUを発見するためにPLPMTUを検出するためにPLPMTUを発見するためにPLPMTUを発見するためにこの方法を様々なポイントで導入することができる。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD SHOULD only be performed at one layer between a pair of endpoints. Therefore, an upper PL or application should avoid using DPLPMTUD when this is already enabled in a lower layer. A PL MUST adjust the MPS indicated by DPLPMTUD to account for any additional overhead introduced by the PL.",
      "ja": "DPLPMTUDは、一対のエンドポイントの間に1つの層でのみ実行されるべきです。したがって、上位PLまたはアプリケーションは、これが下位レイヤで既に有効になっているときにDPLPMTUDを使用しないでください。PLは、PLによって導入された追加のオーバーヘッドを考慮してDPLPMTUDによって示されるMPを調整しなければなりません。"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application*     |\n+-----+------------+---+\n      |            |\n  +---+--+      +--+--+\n  | QUIC*|      |SCTP*|\n  +---+--+      +-+-+-+\n      |           | |\n      +---+  +----+ |\n          |  |      |\n        +-+--+-+    |\n        | UDP  |    |\n        +---+--+    |\n            |       |\n+-----------+-------+--+\n|  Network Interface   |\n+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 2: Examples Where DPLPMTUD Can Be Implemented",
      "ja": "図2：DPLPMTUDを実装できる例"
    },
    {
      "indent": 3,
      "text": "The central idea of DPLPMTUD is probing by a sender. Probe packets are sent to find the maximum size of user message that can be completely transferred across the network path from the sender to the destination.",
      "ja": "DPLPMTUDの中心的な概念は、送信者によるプロービングです。プローブパケットは送信されて送信されて、送信者から宛先へのネットワークパスを介して完全に転送できるユーザーメッセージのサイズが見つかります。"
    },
    {
      "indent": 3,
      "text": "The following sections identify the components needed for implementation, provide an overview of the phases of operation, and specify the state machine and search algorithm.",
      "ja": "次のセクションでは、実装に必要なコンポーネントを識別し、操作の段階の概要を示し、ステートマシンと検索アルゴリズムを指定します。"
    },
    {
      "indent": 0,
      "text": "5.1. DPLPMTUD Components",
      "section_title": true,
      "ja": "5.1. DPLPMTUDコンポーネント"
    },
    {
      "indent": 3,
      "text": "This section describes the timers, constants, and variables of DPLPMTUD.",
      "ja": "このセクションでは、DPLPMTUDのタイマー、定数、および変数について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Timers",
      "section_title": true,
      "ja": "5.1.1. タイマー"
    },
    {
      "indent": 3,
      "text": "The method utilizes up to three timers:",
      "ja": "この方法は最大3つのタイマーを利用しています。"
    },
    {
      "indent": 3,
      "text": "PROBE_TIMER: The PROBE_TIMER is configured to expire after a period longer than the maximum time to receive an acknowledgment to a probe packet. This value MUST NOT be smaller than 1 second and SHOULD be larger than 15 seconds. Guidance on the selection of the timer value is provided in Section 3.1.1 of the UDP Usage Guidelines [BCP145].",
      "ja": "probe_timer：probe_timerは、プローブパケットへの確認応答を受け取る最大時間より長い期間の後に期限切れになるように構成されています。この値は1秒を超えてはならず、15秒を超える必要があります。タイマー値の選択に関するガイダンスは、UDP使用上のガイドライン[BCP145]のセクション3.1.1で提供されています。"
    },
    {
      "indent": 3,
      "text": "PMTU_RAISE_TIMER: The PMTU_RAISE_TIMER is configured to the period a sender will continue to use the current PLPMTU, after which it reenters the Search Phase. This timer has a period of 600 seconds, as recommended by PLPMTUD [RFC4821].",
      "ja": "PMTU_RAISE_TIMER：PMTU_RAISE_TIMERは、送信者が現在のPLPMTUを引き続き使用し続ける期間に設定され、その後検索段階を再入力します。PLPMTUD [RFC4821]が推奨されるように、このタイマーには600秒の期間があります。"
    },
    {
      "indent": 6,
      "text": "DPLPMTUD MAY inhibit sending probe packets when no application data has been sent since the previous probe packet. A PL preferring to use an up-to-date PMTU once user data is sent again can choose to continue PMTU discovery for each path. However, this will result in sending additional packets.",
      "ja": "DPLPMTUDは、以前のプローブパケット以降にアプリケーションデータが送信されていないときにプローブパケットの送信を禁止できます。ユーザーデータが再度送信されると、最新のPMTUを使用することを好むPLは、各パスのPMTU検出を続けることを選択できます。ただし、これにより追加のパケットを送信する可能性があります。"
    },
    {
      "indent": 3,
      "text": "CONFIRMATION_TIMER: When an acknowledged PL is used, this timer MUST NOT be used. For other PLs, the CONFIRMATION_TIMER is configured to the period a PL sender waits before confirming the current PLPMTU is still supported. This is less than the PMTU_RAISE_TIMER and used to decrease the PLPMTU (e.g., when a black hole is encountered). Confirmation needs to be frequent enough when data is flowing that the sending PL does not black hole extensive amounts of traffic. Guidance on selection of the timer value are provided in Section 3.1.1 of the UDP Usage Guidelines [BCP145].",
      "ja": "confirm_timer：確認されたPLが使用されている場合、このタイマーは使用してはいけません。他のPLSの場合、confirmation_timerはPL送信側が送信される前にPL送信者が待機する期間に設定されています。これはPMTU_RAISE_TIMERよりも小さく、PLPMTU（例えば、ブラックホールが遭遇すると）を減らすために使用される。データの送信PLがブラックホールが広範囲のトラフィックではない場合、確認は十分に頻繁に頻度である必要があります。タイマー値の選択に関するガイダンスは、UDP使用ガイドライン[BCP145]のセクション3.1.1に提供されています。"
    },
    {
      "indent": 6,
      "text": "DPLPMTUD MAY inhibit sending probe packets when no application data has been sent since the previous probe packet. A PL preferring to use an up-to-date PMTU once user data is sent again, can choose to continue PMTU discovery for each path. However, this could result in sending additional packets.",
      "ja": "DPLPMTUDは、以前のプローブパケット以降にアプリケーションデータが送信されていないときにプローブパケットの送信を禁止できます。ユーザーデータが再び送信されると、最新のPMTUを使用することを好むPLは、各パスについてPMTU検出を継続することを選択できます。ただし、これにより追加のパケットを送信する可能性があります。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD specifies various timers; however, an implementation could choose to realize these timer functions using a single timer.",
      "ja": "dplpmtudさまざまなタイマーを指定します。ただし、実装は、シングルタイマーを使用してこれらのタイマー機能を実現することを選択できます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Constants",
      "section_title": true,
      "ja": "5.1.2. 定数"
    },
    {
      "indent": 3,
      "text": "The following constants are defined:",
      "ja": "以下の定数が定義されています。"
    },
    {
      "indent": 3,
      "text": "MAX_PROBES: The MAX_PROBES is the maximum value of the PROBE_COUNT counter (see Section 5.1.3). MAX_PROBES represents the limit for the number of consecutive probe attempts of any size. Search algorithms benefit from a MAX_PROBES value greater than 1 because this can provide robustness to isolated packet loss. The default value of MAX_PROBES is 3.",
      "ja": "MAX_PROBES：MAX_PROBESはPROBE_COUNTカウンタの最大値です（セクション5.1.3を参照）。max_probesは、任意のサイズの連続プローブ試行回数の制限を表します。検索アルゴリズムは、絶縁パケット損失に堅牢性を提供できるため、1より大きいMAX_PROBES値から利点があります。MAX_PROBESのデフォルト値は3です。"
    },
    {
      "indent": 3,
      "text": "MIN_PLPMTU: The MIN_PLPMTU is the smallest size of PLPMTU that DPLPMTUD will attempt to use. An endpoint could need to configure the MIN_PLPMTU to provide space for extension headers and other encapsulations at layers below the PL. This value can be interface and path dependent. For IPv6, this size is greater than or equal to the size at the PL that results in an 1280-byte IPv6 packet, as specified in [RFC8200]. For IPv4, this size is greater than or equal to the size at the PL that results in an 68-byte IPv4 packet. Note: An IPv4 router is required to be able to forward a datagram of 68 bytes without further fragmentation. This is the combined size of an IPv4 header and the minimum fragment size of 8 bytes. In addition, receivers are required to be able to reassemble fragmented datagrams at least up to 576 bytes, as stated in Section 3.3.3 of [RFC1122].",
      "ja": "min_plpmtu：min_plpmtuは、dplpmtudが使用しようとするPLPMTUの最小サイズです。エンドポイントは、PLの下のレイヤで拡張ヘッダーおよびその他のカプセル化のためのスペースを提供するためにMIN_PLPMTUを設定する必要があります。この値はインタフェースとパスに依存することができます。IPv6の場合、このサイズはPLのサイズ以上で、[RFC8200]で指定されている1280バイトのIPv6パケットをもたらす。IPv4の場合、このサイズはPLのサイズ以上で、68バイトのIPv4パケットをもたらす。注：IPv4ルータは、さらに断片化なしで68バイトのデータグラムを転送できるようにする必要があります。これはIPv4ヘッダーの合計サイズと8バイトの最小フラグメントサイズです。さらに、[RFC1122]のセクション3.3.3に記載されているように、断片化されたデータグラムを少なくとも最大576バイト以上に再組み立てできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "MAX_PLPMTU: The MAX_PLPMTU is the largest size of PLPMTU. This has to be less than or equal to the maximum size of the PL packet that can be sent on the outgoing interface (constrained by the local interface MTU). When known, this also ought to be less than the maximum size of PL packet that can be received by the remote endpoint (constrained by EMTU_R). It can be limited by the design or configuration of the PL being used. An application, or PL, MAY choose a smaller MAX_PLPMTU when there is no need to send packets larger than a specific size.",
      "ja": "MAX_PLPMTU：MAX_PLPMTUはPLPMTUの最大サイズです。これは、発信インターフェース上で送信できるPLパケットの最大サイズ以下でなければならない（ローカルインタフェースMTUによって制約されます）。知られている場合、これはまた、リモートエンドポイントによって受信され得るPLパケットの最大サイズよりも小さい（EMTU_Rによって制約）するべきである。それは使用されているPLの設計または構成によって制限されることができます。アプリケーション、またはPLは、特定のサイズよりも大きいパケットを送信する必要がない場合、MAX_PLPMTUを小さくすることができます。"
    },
    {
      "indent": 3,
      "text": "BASE_PLPMTU: The BASE_PLPMTU is a configured size expected to work for most paths. The size is equal to or larger than the MIN_PLPMTU and smaller than the MAX_PLPMTU. For most PLs, a suitable BASE_PLPMTU will be larger than 1200 bytes. When using IPv4, there is no currently equivalent size specified, and a default BASE_PLPMTU of 1200 bytes is RECOMMENDED.",
      "ja": "base_plpmtu：base_plpmtuは、ほとんどのパスで動作すると予想される構成サイズです。サイズはmin_plpmtu以上で、max_plpmtuよりも小さいです。ほとんどのPLSでは、適切なbase_plpmtuが1200バイトを超えるでしょう。IPv4を使用する場合、現在は同等のサイズが指定されていないため、1200バイトのデフォルトのbase_plpmtuが推奨されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Variables",
      "section_title": true,
      "ja": "5.1.3. 変数"
    },
    {
      "indent": 3,
      "text": "This method utilizes a set of variables:",
      "ja": "この方法は一連の変数を利用します。"
    },
    {
      "indent": 3,
      "text": "PROBED_SIZE: The PROBED_SIZE is the size of the current probe packet as determined at the PL. This is a tentative value for the PLPMTU, which is awaiting confirmation by an acknowledgment.",
      "ja": "probed_size：probed_sizeは、PLで決定された現在のプローブパケットのサイズです。これはPLPMTUの暫定的な値です。これは確認応答による確認を待っています。"
    },
    {
      "indent": 3,
      "text": "PROBE_COUNT: The PROBE_COUNT is a count of the number of successive unsuccessful probe packets that have been sent. Each time a probe packet is acknowledged, the value is set to zero. (Some probe loss is expected while searching, therefore loss of a single probe is not an indication of a PMTU problem.)",
      "ja": "probe_count：probe_countは、送信された連続した失敗したプローブパケットの数の数です。プローブパケットが確認されるたびに、値はゼロに設定されます。（検索中にプローブの損失によっては予想されるため、単一のプローブの損失はPMTUの問題の表示ではありません。）"
    },
    {
      "indent": 3,
      "text": "Figure 3 illustrates the relationship between the packet size constants and variables at a point of time when the DPLPMTUD algorithm performs path probing to increase the size of the PLPMTU. A probe packet has been sent of size PROBED_SIZE. Once this is acknowledged, the PLPMTU will raise to PROBED_SIZE, allowing the DPLPMTUD algorithm to further increase PROBED_SIZE toward sending a probe with the size of the actual PMTU.",
      "ja": "図3は、DPLPMTUDアルゴリズムがPLPMTUのサイズを増大させるためのパスプロービングを実行した時点でのパケットサイズ定数と変数の関係を示しています。プローブパケットがsize probed_sizeに送信されました。これが確認されると、PLPMTUはPROBED_SIZEに上昇し、DPLPMTUDアルゴリズムが実際のPMTUのサイズでプローブを送信するようにProbed_Sizeをさらに増加させることができます。"
    },
    {
      "indent": 8,
      "text": "MIN_PLPMTU                                MAX_PLPMTU\n  <------------------------------------------->\n                 |        |     |\n                 v        |     |\n           BASE_PLPMTU    |     v\n                          |  PROBED_SIZE\n                          v\n                        PLPMTU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 3: Relationships between Packet Size Constants and Variables",
      "ja": "図3：パケットサイズ定数と変数間の関係"
    },
    {
      "indent": 0,
      "text": "5.1.4. Overview of DPLPMTUD Phases",
      "section_title": true,
      "ja": "5.1.4. DPLPMTUDフェーズの概要"
    },
    {
      "indent": 3,
      "text": "This section provides a high-level, informative view of the DPLPMTUD method, by describing the movement of the method through several phases of operation. More detail is available in the state machine, Section 5.2.",
      "ja": "このセクションでは、いくつかの操作段階を通じて方法の移動を説明することによって、DPLPMTUDメソッドの高レベルの有益なビューを提供します。State Machine、セクション5.2でより詳細な詳細があります。"
    },
    {
      "indent": 3,
      "text": "                    +------+\n           +------->| Base |-----------------+ Connectivity\n           |        +------+                 | or BASE_PLPMTU\n           |           |                     | confirmation failed\n           |           |                     v\n           |           | Connectivity    +-------+\n           |           | and BASE_PLPMTU | Error |\n           |           | confirmed       +-------+\n           |           |                     | Consistent\n           |           v                     | connectivity\nBlack Hole |       +--------+                | and BASE_PLPMTU\n detected  |       | Search |<---------------+ confirmed\n           |       +--------+\n           |          ^  |\n           |          |  |\n           |    Raise |  | Search\n           |    timer |  | algorithm\n           |  expired |  | completed\n           |          |  |\n           |          |  v\n           |   +-----------------+\n           +---| Search Complete |\n               +-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 4: DPLPMTUD Phases",
      "ja": "図4：DPLPMTUDフェーズ"
    },
    {
      "indent": 3,
      "text": "Base: The Base Phase confirms connectivity to the remote peer using packets of the BASE_PLPMTU. The confirmation of connectivity is implicit for a connection-oriented PL (where it can be performed in a PL connection handshake). A connectionless PL sends a probe packet and uses acknowledgment of this probe packet to confirm that the remote peer is reachable.",
      "ja": "基本：基本フェーズは、base_plpmtuのパケットを使用してリモートピアへの接続を確認します。接続性の確認は、接続指向PL（PL接続ハンドシェイクで実行できる場合）に暗黙的です。コネクションレスPLはプローブパケットを送信し、このプローブパケットの確認応答を使用して、リモートピアが到達可能であることを確認します。"
    },
    {
      "indent": 6,
      "text": "The sender also confirms that BASE_PLPMTU is supported across the network path. This may be achieved by using a PL mechanism (e.g., using a handshake packet of size BASE_PLPMTU) or by sending a probe packet of size BASE_PLPMTU and confirming that this is received.",
      "ja": "送信者はまた、base_plpmtuがネットワークパスでサポートされていることを確認します。これは、PL機構を（例えば、サイズ基本_PLPMTUのハンドシェイクパケットを使用する）、またはサイズBASE_PLPMTUのプローブパケットを送信し、これが受信されたことを確認することによって達成することができる。"
    },
    {
      "indent": 6,
      "text": "A probe packet of size BASE_PLPMTU can be sent immediately on the initial entry to the Base Phase (following a connectivity check). A PL that does not wish to support a path with a PLPMTU less than BASE_PLPMTU can simplify the phase into a single step by performing the connectivity checks with a probe of the BASE_PLPMTU size.",
      "ja": "Size Base_PLPMTUのプローブパケットは、（接続性チェックに従って）基本フェーズへの初期エントリですぐに送信できます。base_plpmtuよりも小さいパスをサポートしたくないPLは、base_plpmtuサイズのプローブとの接続性チェックを実行することによって、フェーズを単一のステップに単純化することができる。"
    },
    {
      "indent": 6,
      "text": "Once confirmed, DPLPMTUD enters the Search Phase. If the Base Phase fails to confirm the BASE_PLPMTU, DPLPMTUD enters the Error Phase.",
      "ja": "確認されると、DPLPMTUDは検索段階に入ります。基本フェーズがbase_plpmtuの確認に失敗した場合、DPLPMTUDはエラー・フェーズを入力します。"
    },
    {
      "indent": 3,
      "text": "Search: The Search Phase utilizes a search algorithm to send probe packets to seek to increase the PLPMTU. The algorithm concludes when it has found a suitable PLPMTU by entering the Search Complete Phase.",
      "ja": "検索：検索フェーズは検索アルゴリズムを利用してプローブパケットを送信してPLPMTUを増やすことを求めます。このアルゴリズムは、検索完了フェーズを入力することによって適切なPLPMTUを見つけたときに終了します。"
    },
    {
      "indent": 6,
      "text": "A PL could respond to PTB messages using the PTB to advance or terminate the search, see Section 4.6.",
      "ja": "PLはPTBを使用してPTBメッセージに応答して検索を進めたり、セクション4.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Search Complete: The Search Complete Phase is entered when the PLPMTU is supported across the network path. A PL can use a CONFIRMATION_TIMER to periodically repeat a probe packet for the current PLPMTU size. If the sender is unable to confirm reachability (e.g., if the CONFIRMATION_TIMER expires) or the PL signals a lack of reachability, a black hole has been detected and DPLPMTUD enters the Base Phase.",
      "ja": "検索完了：PLPMTUがネットワークパスを介してサポートされているときに検索完了フェーズが入力されます。PLは、confirmation_timerを使用して、現在のPLPMTUサイズのプローブパケットを定期的に繰り返すことができます。送信者が到達可能性を確認できない場合（例えば、確認済みが期限切れになった場合）、またはPLが到達可能性の欠如を示している場合、ブラックホールが検出され、DPLPMTUDが基本フェーズに入る。"
    },
    {
      "indent": 6,
      "text": "The PMTU_RAISE_TIMER is used to periodically resume the Search Phase to discover if the PLPMTU can be raised. Black hole detection causes the sender to enter the Base Phase.",
      "ja": "PMTU_RAISE_TIMERは、PLPMTUを上げることができるかどうかを発見するために検索段階を定期的に再開するために使用されます。ブラックホール検出により、送信者は基本フェーズに入ります。"
    },
    {
      "indent": 3,
      "text": "Error: The Error Phase is entered when there is conflicting or invalid PLPMTU information for the path (e.g., a failure to support the BASE_PLPMTU) that causes DPLPMTUD to be unable to progress, and the PLPMTU is lowered.",
      "ja": "エラー：DPLPMTUDが進行できなくなるパスの競合（例えば、Base_PLPMTUをサポートできない障害）のPLPMTU情報がある場合にエラーフェーズが入力され、PLPMTUが低下します。"
    },
    {
      "indent": 6,
      "text": "DPLPMTUD remains in the Error Phase until a consistent view of the path can be discovered and it has also been confirmed that the path supports the BASE_PLPMTU (or DPLPMTUD is suspended).",
      "ja": "パスの一貫したビューが発見されるまで、DPLPMTUDはエラーフェーズに残り、パスがbase_plpmtu（またはdplpmtudが中断されている）をサポートすることも確認されています。"
    },
    {
      "indent": 3,
      "text": "A method that only reduces the PLPMTU to a suitable size would be sufficient to ensure reliable operation but can be very inefficient when the actual PMTU changes or when the method (for whatever reason) makes a suboptimal choice for the PLPMTU.",
      "ja": "PLPMTUを適切なサイズに縮小する方法は、信頼性の高い動作を確実にするのに十分であるが、実際のPMTUが変更されたとき、またはメソッドがPLPMTUに最適な選択をするときには非常に非効率的であり得る。"
    },
    {
      "indent": 3,
      "text": "A full implementation of DPLPMTUD provides an algorithm enabling the DPLPMTUD sender to increase the PLPMTU following a change in the characteristics of the path, such as when a link is reconfigured with a larger MTU, or when there is a change in the set of links traversed by an end-to-end flow (e.g., after a routing or path failover decision).",
      "ja": "DPLPMTUDの完全実装は、リンクがより大きなMTUで再構成されているときなど、PLPMTUをPLPMTUを増やすことを可能にするアルゴリズムを提供する、またはトラバースされたリンクのセットに変化がある場合エンドツーエンドのフロー（例えば、ルーティングまたはパスフェイルオーバー決定後）によって。"
    },
    {
      "indent": 0,
      "text": "5.2. State Machine",
      "section_title": true,
      "ja": "5.2. ステートマシン"
    },
    {
      "indent": 3,
      "text": "A state machine for DPLPMTUD is depicted in Figure 5. If multipath or multihoming is supported, a state machine is needed for each path.",
      "ja": "図5にDPLPMTUDのための状態機械が示されている。マルチパスまたはマルチホームがサポートされている場合は、各パスにステートマシンが必要です。"
    },
    {
      "indent": 3,
      "text": "Note: Not all changes are shown to simplify the diagram.",
      "ja": "注：ダイアグラムを単純化するためにすべての変更が表示されているわけではありません。"
    },
    {
      "indent": 3,
      "text": "   |         |\n   | Start   | PL indicates loss\n   |         |  of connectivity\n   v         v\n+---------------+                                   +---------------+\n|    DISABLED   |                                   |     ERROR     |\n+---------------+               PROBE_TIMER expiry: +---------------+\n        | PL indicates     PROBE_COUNT = MAX_PROBES or    ^      |\n        | connectivity  PTB: PL_PTB_SIZE < BASE_PLPMTU    |      |\n        +--------------------+         +------------------+      |\n                             |         |                         |\n                             v         |       BASE_PLPMTU Probe |\n                          +---------------+          acked       |\n                          |      BASE     |--------------------->+\n                          +---------------+                      |\n                             ^ |    ^  ^                         |\n         Black hole detected | |    |  | Black hole detected     |\n        +--------------------+ |    |  +--------------------+    |\n        |                      +----+                       |    |\n        |                PROBE_TIMER expiry:                |    |\n        |             PROBE_COUNT < MAX_PROBES              |    |\n        |                                                   |    |\n        |               PMTU_RAISE_TIMER expiry             |    |\n        |    +-----------------------------------------+    |    |\n        |    |                                         |    |    |\n        |    |                                         v    |    v\n+---------------+                                   +---------------+\n|SEARCH_COMPLETE|                                   |   SEARCHING   |\n+---------------+                                   +---------------+\n   |    ^    ^                                         |    |    ^\n   |    |    |                                         |    |    |\n   |    |    +-----------------------------------------+    |    |\n   |    |            MAX_PLPMTU Probe acked or              |    |\n   |    |  PROBE_TIMER expiry: PROBE_COUNT = MAX_PROBES or  |    |\n   +----+            PTB: PL_PTB_SIZE = PLPMTU              +----+\nCONFIRMATION_TIMER expiry:                        PROBE_TIMER expiry:\nPROBE_COUNT < MAX_PROBES or               PROBE_COUNT < MAX_PROBES or\n     PLPMTU Probe acked                           Probe acked or PTB:\n                                   PLPMTU < PL_PTB_SIZE < PROBED_SIZE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 5: State Machine for Datagram PLPMTUD",
      "ja": "図5：データグラムPLPMTUDのステートマシン"
    },
    {
      "indent": 3,
      "text": "The following states are defined:",
      "ja": "以下の状態が定義されています。"
    },
    {
      "indent": 3,
      "text": "DISABLED: The DISABLED state is the initial state before probing has started. It is also entered from any other state, when the PL indicates loss of connectivity. This state is left once the PL indicates connectivity to the remote PL. When transitioning to the BASE state, a probe packet of size BASE_PLPMTU can be sent immediately.",
      "ja": "無効：プロービングが開始される前の初期状態です。PLが接続性の損失を示したときに、他の状態からも入力されます。PLがリモートPLへの接続を示すと、この状態は残ります。基本状態に移行する場合、サイズbase_plpmtuのプローブパケットをすぐに送信することができます。"
    },
    {
      "indent": 3,
      "text": "BASE: The BASE state is used to confirm that the BASE_PLPMTU size is supported by the network path and is designed to allow an application to continue working when there are transient reductions in the actual PMTU. It also seeks to avoid long periods when a sender searching for a larger PLPMTU is unaware that packets are not being delivered due to a packet or ICMP black hole.",
      "ja": "基本：基本状態は、Base_PLPMTUサイズがネットワークパスによってサポートされていることを確認するために使用され、実際のPMTUに過渡的な削減があるときにアプリケーションが作業を続けるように設計されています。また、より大きなPLPMTUを検索する送信者がパケットやICMPブラックホールのためにパケットが配信されていないことを認識していない場合は、長期間を回避しようとしています。"
    },
    {
      "indent": 6,
      "text": "On entry, the PROBED_SIZE is set to the BASE_PLPMTU size, and the PROBE_COUNT is set to zero.",
      "ja": "エントリでは、probed_sizeはbase_plpmtu sizeに設定され、probe_countはゼロに設定されます。"
    },
    {
      "indent": 6,
      "text": "Each time a probe packet is sent, the PROBE_TIMER is started. The state is exited when the probe packet is acknowledged, and the PL sender enters the SEARCHING state.",
      "ja": "プローブパケットが送信されるたびに、probe_timerが起動されます。プローブパケットが確認されたときに状態は終了し、PL送信側は検索状態に入ります。"
    },
    {
      "indent": 6,
      "text": "The state is also left when the PROBE_COUNT reaches MAX_PROBES or a received PTB message is validated. This causes the PL sender to enter the ERROR state.",
      "ja": "probe_countがmax_probesに到達したとき、または受信したPTBメッセージが検証されると、状態も残されます。これにより、PL送信者はエラー状態を入力します。"
    },
    {
      "indent": 3,
      "text": "SEARCHING: The SEARCHING state is the main probing state. This state is entered when probing for the BASE_PLPMTU completes.",
      "ja": "検索：検索状態は主なプロービング状態です。base_plpmtuのプロービングが完了するとこの状態が入力されます。"
    },
    {
      "indent": 6,
      "text": "Each time a probe packet is acknowledged, the PROBE_COUNT is set to zero, the PLPMTU is set to the PROBED_SIZE, and then the PROBED_SIZE is increased using the search algorithm (as described in Section 5.3).",
      "ja": "プローブパケットが確認されるたびに、PROBE_COUNTがゼロに設定され、PLPMTUがprobed_sizeに設定され、次に検索アルゴリズムを使用してprobed_sizeが増加します（セクション5.3で説明されているように）。"
    },
    {
      "indent": 6,
      "text": "When a probe packet is sent and not acknowledged within the period of the PROBE_TIMER, the PROBE_COUNT is incremented, and a new probe packet is transmitted.",
      "ja": "プローブパケットが送信され、probe_timerの期間内に承認されない場合、probe_countがインクリメントされ、新しいプローブパケットが送信される。"
    },
    {
      "indent": 6,
      "text": "The state is exited to enter SEARCH_COMPLETE when the PROBE_COUNT reaches MAX_PROBES, a validated PTB is received that corresponds to the last successfully probed size (PL_PTB_SIZE = PLPMTU), or a probe of size MAX_PLPMTU is acknowledged (PLPMTU = MAX_PLPMTU).",
      "ja": "search_probesに到達すると、search_completeに入るように終了します。"
    },
    {
      "indent": 6,
      "text": "When a black hole is detected in the SEARCHING state, this causes the PL sender to enter the BASE state.",
      "ja": "検索状態でブラックホールが検出されると、PL送信者はベース状態に入る。"
    },
    {
      "indent": 3,
      "text": "SEARCH_COMPLETE: The SEARCH_COMPLETE state indicates that a search has completed. This is the normal maintenance state, where the PL is not probing to update the PLPMTU. DPLPMTUD remains in this state until either the PMTU_RAISE_TIMER expires or a black hole is detected.",
      "ja": "search_complete：search_complete状態は、検索が完了したことを示します。これは通常のメンテナンス状態です。ここで、PLはPLPMTUを更新することを確認していません。PMTU_RAISE_TIMERの有効期限が切れるかブラックホールが検出されるまで、DPLPMTUDはこの状態のままである。"
    },
    {
      "indent": 6,
      "text": "When DPLPMTUD uses an unacknowledged PL and is in the SEARCH_COMPLETE state, a CONFIRMATION_TIMER periodically resets the PROBE_COUNT and schedules a probe packet with the size of the PLPMTU. If MAX_PROBES successive PLPMTUD-sized probes fail to be acknowledged, the method enters the BASE state. When used with an acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD NOT continue to generate PLPMTU probes in this state.",
      "ja": "DPLPMTUDが未確認PLを使用してSEARCH_COMPLETE状態にあるとき、confirm_timerはPROBE_COUNTを定期的にリセットし、PLPMTUのサイズでプローブパケットをスケジュールします。max_probesの連続するPLPMTUDサイズのプローブが確認されない場合、このメソッドは基本状態になります。確認されたPL（例えば、SCTP）と共に使用されると、DPLPMTUDはこの状態でPLPMTUプローブを生成し続けるべきではありません。"
    },
    {
      "indent": 3,
      "text": "ERROR: The ERROR state represents the case where either the network path is not known to support a PLPMTU of at least the BASE_PLPMTU size or when there is contradictory information about the network path that would otherwise result in excessive variation in the MPS signaled to the higher layer. The state implements a method to mitigate oscillation in the state-event engine. It signals a conservative value of the MPS to the higher layer by the PL. The state is exited when packet probes no longer detect the error. The PL sender then enters the SEARCHING state.",
      "ja": "エラー：エラー状態は、ネットワークパスが少なくともBASE_PLPMTUサイズのPLPMTUをサポートすることが知られていない場合、またはそうでなければ上にシグナリングされたMPSの変動をもたらすネットワークパスに関する矛盾する情報がある場合を表します。層。状態は、状態イベントエンジンの発振を軽減するための方法を実装しています。それはPLによって上位層へのMPSの保守的な値を知らせます。パケットプローブがエラーを検出しなくなったときに状態が終了します。PL送信者は検索状態に入る。"
    },
    {
      "indent": 6,
      "text": "Implementations are permitted to enable endpoint fragmentation if the DPLPMTUD is unable to validate MIN_PLPMTU within PROBE_COUNT probes. If DPLPMTUD is unable to validate MIN_PLPMTU, the implementation will transition to the DISABLED state.",
      "ja": "DPLPMTUDがprobe_countプローブ内でmin_plpmtuを検証できない場合、実装はエンドポイントのフラグメンテーションを有効にすることが許可されています。DPLPMTUDがmin_plpmtuを検証できない場合、実装は無効状態に移行します。"
    },
    {
      "indent": 6,
      "text": "Note: MIN_PLPMTU could be identical to BASE_PLPMTU, simplifying the actions in this state.",
      "ja": "注：min_plpmtuはbase_plpmtuと同じで、この状態のアクションを簡素化します。"
    },
    {
      "indent": 0,
      "text": "5.3. Search to Increase the PLPMTU",
      "section_title": true,
      "ja": "5.3. PLPMTUを増やすために検索します"
    },
    {
      "indent": 3,
      "text": "This section describes the algorithms used by DPLPMTUD to search for a larger PLPMTU.",
      "ja": "このセクションでは、より大きなPLPMTUを検索するためにDPLPMTUDが使用するアルゴリズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Probing for a Larger PLPMTU",
      "section_title": true,
      "ja": "5.3.1. より大きなPLPMTUのためのプロービング"
    },
    {
      "indent": 3,
      "text": "Implementations use a search algorithm across the search range to determine whether a larger PLPMTU can be supported across a network path.",
      "ja": "実装は検索範囲を横切って検索アルゴリズムを使用して、より大きなPLPMTUがネットワークパスを介してサポートされ得るかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "The method discovers the search range by confirming the minimum PLPMTU and then using the probe method to select a PROBED_SIZE less than or equal to MAX_PLPMTU. MAX_PLPMTU is the minimum of the local MTU and EMTU_R (when this is learned from the remote endpoint). The MAX_PLPMTU MAY be reduced by an application that sets a maximum to the size of datagrams it will send.",
      "ja": "この方法は、最小のPLPMTUを確認し、次にプローブ法を使用してMAX_PLPMTU以下のprobed_sizeを選択することによって検索範囲を検出します。MAX_PLPMTUは、ローカルMTUとEMTU_Rの最小値です（これがリモートエンドポイントから学習された場合）。MAX_PLPMTUは、送信されるデータグラムのサイズに最大を設定するアプリケーションによって減らすことができます。"
    },
    {
      "indent": 3,
      "text": "The PROBE_COUNT is initialized to zero when the first probe with a size greater than or equal to PLPMTU is sent. Each probe packet successfully sent to the remote peer is confirmed by acknowledgment at the PL (see Section 4.1).",
      "ja": "PLPMTU以上のサイズを持つ最初のプローブが送信されると、PROBE_COUNTがゼロに初期化されます。リモートピアに正常に送信された各プローブパケットは、PLの確認応答によって確認されます（セクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Each time a probe packet is sent to the destination, the PROBE_TIMER is started. The timer is canceled when the PL receives acknowledgment that the probe packet has been successfully sent across the path (Section 4.1). This confirms that the PROBED_SIZE is supported, and the PROBED_SIZE value is then assigned to the PLPMTU. The search algorithm can continue to send subsequent probe packets of an increasing size.",
      "ja": "プローブパケットが宛先に送信されるたびに、probe_timerが起動されます。PLがパス全体で正常に送信されたことを確認応答を受信したときに、タイマーはキャンセルされます（セクション4.1）。これにより、probed_sizeがサポートされており、probed_size値がPLPMTUに割り当てられていることを確認します。検索アルゴリズムは、後続のサイズのプローブパケットを引き続き送信することができます。"
    },
    {
      "indent": 3,
      "text": "If the timer expires before a probe packet is acknowledged, the probe has failed to confirm the PROBED_SIZE. Each time the PROBE_TIMER expires, the PROBE_COUNT is incremented, the PROBE_TIMER is reinitialized, and a new probe of the same size or any other size (determined by the search algorithm) can be sent. The maximum number of consecutive failed probes is configured (MAX_PROBES). If the value of the PROBE_COUNT reaches MAX_PROBES, probing will stop, and the PL sender enters the SEARCH_COMPLETE state.",
      "ja": "プローブパケットが確認される前にタイマーが期限切れになると、プローブはprobed_sizeを確認できませんでした。probe_timerが期限切れになるたびに、probe_countがインクリメントされ、probe_timerが再初期化され、同じサイズまたは他のサイズの新しいプローブ（検索アルゴリズムによって決まり）を送信することができます。連続した障害のあるプローブの最大数は設定されています（MAX_PROBES）。probe_countの値がmax_probesに達すると、プロービングは停止し、PL送信者はsearch_complete状態に入ります。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Selection of Probe Sizes",
      "section_title": true,
      "ja": "5.3.2. プローブサイズの選択"
    },
    {
      "indent": 3,
      "text": "The search algorithm determines a minimum useful gain in PLPMTU. It would not be constructive for a PL sender to attempt to probe for all sizes. This would incur unnecessary load on the path. Implementations SHOULD select the set of probe packet sizes to maximize the gain in PLPMTU from each search step.",
      "ja": "検索アルゴリズムは、PLPMTUの最小有用なゲインを決定します。PL Senderがすべてのサイズを探索しようとするのは建設的ではありません。これにより、パス上の不要な負荷がかかるでしょう。実装は、各検索ステップからPLPMTUのゲインを最大化するためにプローブパケットサイズのセットを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations could optimize the search procedure by selecting step sizes from a table of common PMTU sizes. When selecting the appropriate next size to search, an implementer ought to also consider that there can be common sizes of MPS that applications seek to use, and there could be common sizes of MTU used within the network.",
      "ja": "実装は、一般的なPMTUサイズのテーブルからステップサイズを選択することによって検索手順を最適化することができます。検索するには適切な次のサイズを選択すると、実装者はまた、アプリケーションが使用しようとするMPの一般的なサイズがあることを考慮する必要があり、ネットワーク内で使用されるMTUの一般的なサイズがある可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Resilience to Inconsistent Path Information",
      "section_title": true,
      "ja": "5.3.3. 矛盾した道情報への回復力"
    },
    {
      "indent": 3,
      "text": "A decision to increase the PLPMTU needs to be resilient to the possibility that information learned about the network path is inconsistent. A path is inconsistent when, for example, probe packets are lost due to other reasons (i.e., not packet size) or due to frequent path changes. Frequent path changes could occur by unexpected \"flapping\" -- where some packets from a flow pass along one path, but other packets follow a different path with different properties.",
      "ja": "PLPMTUを増やすという決定は、ネットワーク経路について学んだ情報が矛盾する可能性に弾力的である必要がある。たとえば、プローブパケットが他の理由（すなわち、パケットサイズではない）または頻繁なパス変更のために失われると、パスが矛盾している。頻繁なパスの変更は予期しない「フラッピング」によって発生する可能性があります。フローからのパケットは1つのパスに渡されたが、他のパケットは異なるプロパティで異なるパスに従います。"
    },
    {
      "indent": 3,
      "text": "A PL sender is able to detect inconsistency either from the sequence of PLPMTU probes that are acknowledged or from the sequence of PTB messages that it receives. When inconsistent path information is detected, a PL sender could use an alternate search mode that clamps the offered MPS to a smaller value for a period of time. This avoids unnecessary loss of packets.",
      "ja": "PL送信者は、確認されているPLPMTUプローブのシーケンスまたは受信したPTBメッセージのシーケンスから矛盾を検出することができます。矛盾したパス情報が検出されると、PL送信者は、提供されたMPを一定期間でより小さい値にクランプする代替検索モードを使用することができる。これにより、不要なパケットの損失が回避されます。"
    },
    {
      "indent": 0,
      "text": "5.4. Robustness to Inconsistent Paths",
      "section_title": true,
      "ja": "5.4. 矛盾した道への堅牢性"
    },
    {
      "indent": 3,
      "text": "Some paths could be unable to sustain packets of the BASE_PLPMTU size. The Error State could be implemented to provide robustness to such paths. This allows fallback to a smaller than desired PLPMTU rather than suffer connectivity failure. This could utilize methods such as endpoint IP fragmentation to enable the PL sender to communicate using packets smaller than the BASE_PLPMTU.",
      "ja": "いくつかのパスは、base_plpmtu sizeのパケットをサスインできない可能性があります。そのような経路に頑健性を提供するために誤差状態を実施することができる。これにより、接続不良を被るのではなく、望ましいPLPMTUよりも小さいフォールバックが可能になる。これは、Endpoint IPフラグメンテーションなどのメソッドを利用して、PL送信者がBase_PLPMTUよりも小さいパケットを使用して通信できるようにします。"
    },
    {
      "indent": 0,
      "text": "6. Specification of Protocol-Specific Methods",
      "section_title": true,
      "ja": "6. プロトコル固有の方法の指定"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD requires protocol-specific details to be specified for each PL that is used.",
      "ja": "DPLPMTUDでは、使用される各PLに対してプロトコル固有の詳細を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The first subsection provides guidance on how to implement the DPLPMTUD method as a part of an application using UDP or UDP-Lite. The guidance also applies to other datagram services that do not include a specific transport protocol (such as a tunnel encapsulation). The following subsections describe how DPLPMTUD can be implemented as a part of the transport service, allowing applications using the service to benefit from discovery of the PLPMTU without themselves needing to implement this method when using SCTP and QUIC.",
      "ja": "最初のサブセクションでは、UDPまたはUDP-Liteを使用してアプリケーションの一部としてDPLPMTUDメソッドを実装する方法に関するガイダンスを提供します。ガイダンスは、特定のトランスポートプロトコル（トンネルカプセル化など）を含まない他のデータグラムサービスにも適用されます。次のサブセクションでは、DPLPMTUDがトランスポートサービスの一部として実装できる方法について説明し、SCTPとQUICを使用するときにこのメソッドを実装する必要がありませんPLPMTUの検出を利用するためにサービスを使用してアプリケーションを使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.1. Application Support for DPLPMTUD with UDP or UDP-Lite",
      "section_title": true,
      "ja": "6.1. UDPまたはUDP-Liteを使用したDPLPMTUDのアプリケーションサポート"
    },
    {
      "indent": 3,
      "text": "The current specifications of UDP [RFC0768] and UDP-Lite [RFC3828] do not define a method in the RFC series that supports PLPMTUD. In particular, the UDP transport does not provide the transport features needed to implement datagram PLPMTUD.",
      "ja": "UDP [RFC0768]とUDP-Lite [RFC3828]の現在の仕様は、PLPMTUDをサポートするRFCシリーズのメソッドを定義していません。特に、UDPトランスポートは、データグラムPLPMTUDを実装するために必要なトランスポート機能を提供しません。"
    },
    {
      "indent": 3,
      "text": "The DPLPMTUD method can be implemented as a part of an application built directly or indirectly on UDP or UDP-Lite but relies on higher-layer protocol features to implement the method [BCP145].",
      "ja": "DPLPMTUDメソッドは、UDPまたはUDP-Liteで直接または間接的に構築されたアプリケーションの一部として実装できますが、メソッド[BCP145]を実装するための上位層のプロトコル機能に依存できます。"
    },
    {
      "indent": 3,
      "text": "Some primitives used by DPLPMTUD might not be available via the Datagram API (e.g., the ability to access the PLPMTU from the IP-layer cache or to interpret received PTB messages).",
      "ja": "DPLPMTUDによって使用されるプリミティブによっては、データグラムAPI（例えば、IP層キャッシュからPLPMTUにアクセスする機能、または受信したPTBメッセージの解釈）を介して利用できない可能性があります。"
    },
    {
      "indent": 3,
      "text": "In addition, it is recommended that PMTU discovery is not performed by multiple protocol layers. An application SHOULD avoid using DPLPMTUD when the underlying transport system provides this capability. A common method for managing the PLPMTU has benefits, both in the ability to share state between different processes and in opportunities to coordinate probing for different PL instances.",
      "ja": "また、PMTUディスカバリは複数のプロトコルレイヤによって実行されないことをお勧めします。基礎となるトランスポートシステムがこの機能を提供するとき、アプリケーションはDPLPMTUDを使用しないでください。PLPMTUを管理するための一般的な方法は、さまざまなプロセス間の状態を共有する能力と、さまざまなPLインスタンスのプロービングを調整する機会の両方で利益をもたらします。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Application Request",
      "section_title": true,
      "ja": "6.1.1. アプリケーションリクエスト"
    },
    {
      "indent": 3,
      "text": "An application needs an application-layer protocol mechanism (such as a message acknowledgment method) that solicits a response from a destination endpoint. The method SHOULD allow the sender to check the value returned in the response to provide additional protection from off-path insertion of data [BCP145]. Suitable methods include a parameter known only to the two endpoints, such as a session ID or initialized sequence number.",
      "ja": "アプリケーションは、宛先エンドポイントからの応答を称えるアプリケーション層プロトコルメカニズム（メッセージ確認方法など）を必要とします。この方法では、送信者が応答で返された値を確認して、データのオフパス挿入から追加の保護を提供することができます[BCP145]。適切な方法は、セッションIDまたは初期化シーケンス番号などの2つのエンドポイントのみが知られているパラメータを含む。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Application Response",
      "section_title": true,
      "ja": "6.1.2. アプリケーションの応答"
    },
    {
      "indent": 3,
      "text": "An application needs an application-layer protocol mechanism to communicate the response from the destination endpoint. This response could indicate successful reception of the probe across the path but could also indicate that some (or all packets) have failed to reach the destination.",
      "ja": "アプリケーションは、宛先エンドポイントからの応答を通信するためのアプリケーション層プロトコルメカニズムを必要とします。この応答は、パス全体のプローブの受信が成功したことを示している可能性がありますが、一部（またはすべてのパケット）が宛先に到達できなかったことを示している可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Sending Application Probe Packets",
      "section_title": true,
      "ja": "6.1.3. アプリケーションプローブパケットの送信"
    },
    {
      "indent": 3,
      "text": "A probe packet can carry an application data block, but the successful transmission of this data is at risk when used for probing. Some applications might prefer to use a probe packet that does not carry an application data block to avoid disruption of data transfer.",
      "ja": "プローブパケットはアプリケーションデータブロックを搬送することができますが、このデータの正常な送信はプロービングに使用される危険性があります。データ転送の中断を避けるために、アプリケーションデータブロックを搭載していないプローブパケットを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Initial Connectivity",
      "section_title": true,
      "ja": "6.1.4. 初期接続"
    },
    {
      "indent": 3,
      "text": "An application that does not have other higher-layer information confirming connectivity with the remote peer SHOULD implement a connectivity mechanism using acknowledged probe packets before entering the BASE state.",
      "ja": "リモートピアとの接続を確認する他の上位の情報を持たないアプリケーションは、基本状態に入る前に確認されたプローブパケットを使用して接続性メカニズムを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.5. Validating the Path",
      "section_title": true,
      "ja": "6.1.5. パスを検証します"
    },
    {
      "indent": 3,
      "text": "An application that does not have other higher-layer information confirming correct delivery of datagrams SHOULD implement the CONFIRMATION_TIMER to periodically send probe packets while in the SEARCH_COMPLETE state.",
      "ja": "データグラムの正しい配信を確認する他の上位層の情報を持っていないアプリケーションは、search_complete状態の間にプローブパケットを定期的に送信するようにchenting_timerを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.6. Handling of PTB Messages",
      "section_title": true,
      "ja": "6.1.6. PTBメッセージの処理"
    },
    {
      "indent": 3,
      "text": "An application that is able and wishes to receive PTB messages MUST perform ICMP validation as specified in Section 5.2 of [BCP145]. This requires that the application checks each received PTB message to validate that it was is received in response to transmitted traffic and that the reported PL_PTB_SIZE is less than the current probed size (see Section 4.6.2). A validated PTB message MAY be used as input to the DPLPMTUD algorithm but MUST NOT be used directly to set the PLPMTU.",
      "ja": "PTBメッセージを受信できるアプリケーションは、[BCP145]のセクション5.2で指定されているようにICMP検証を実行する必要があります。これには、送信トラフィックに応答して受信されたことを確認するために、アプリケーションが受信したPTBメッセージが確認され、報告されたPL_PTB_SIZEが現在のプローブサイズよりも小さいことを確認する必要があります（セクション4.6.2を参照）。検証されたPTBメッセージをDPLPMTUDアルゴリズムへの入力として使用することができますが、PLPMTUを設定するために直接使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "6.2. DPLPMTUD for SCTP",
      "section_title": true,
      "ja": "6.2. SCTPのためのDPLPMTUD"
    },
    {
      "indent": 3,
      "text": "Section 10.2 of [RFC4821] specifies a recommended PLPMTUD probing method for SCTP, and Section 7.3 of [RFC4960] recommends an endpoint apply the techniques in RFC 4821 on a per-destination-address basis. The specification for DPLPMTUD continues the practice of using the PL to discover the PMTU but updates RFC4960 with a recommendation to use the method specified in this document: The RECOMMENDED method for generating probes is to add a chunk consisting only of padding to an SCTP message. The PAD chunk defined in [RFC4820] SHOULD be attached to a minimum-length HEARTBEAT (HB) chunk to build a probe packet. This enables probing without affecting the transfer of user messages and without being limited by congestion control or flow control. This is preferred to using DATA chunks (with padding as required) as path probes.",
      "ja": "[RFC4821]のセクション10.2のSCTPのPLPMTUDプロービング方法を指定し、[RFC4960]のセクション7.3は、宛先ごとのアドレスごとにRFC 4821のテクニックを適用することを推奨しています。DPLPMTUDの仕様はPMTUを発見するためのPLを使用することを継続しますが、この文書で指定された方法を使用する方法でRFC4960を更新します。プローブを生成するための推奨される方法は、SCTPメッセージへのパディングのみからなるチャンクを追加することです。[RFC4820]で定義されているパッドチャンクは、プローブパケットを構築するために最小長ハートビート（HB）チャンクに接続する必要があります。これにより、ユーザメッセージの転送に影響を与えず、輻輳制御やフロー制御によって制限されずにプロービングが可能になります。これは、パスプローブとして（必要に応じてパディングを伴う）データチャンクを使用することが好ましい。"
    },
    {
      "indent": 3,
      "text": "Section 6.9 of [RFC4960] describes dividing the user messages into DATA chunks sent by the PL when using SCTP. This notes that once an SCTP message has been sent, it cannot be resegmented. [RFC4960] describes the method for retransmitting DATA chunks when the MPS has been reduced, and Section 6.9 of [RFC4960] describes use of IP fragmentation for this case. This is unchanged by this document.",
      "ja": "[RFC4960]のセクション6.9は、SCTPを使用するときにPLによって送信されたデータチャンクにユーザーメッセージを分割しています。これは、SCTPメッセージが送信されたら、再配置することはできません。[RFC4960] MPSが削減されたときにデータチャンクを再送信する方法で、[RFC4960]のセクション6.9はこの場合のIPフラグメンテーションの使用を説明しています。これはこの文書によって変更されていません。"
    },
    {
      "indent": 0,
      "text": "6.2.1. SCTP/IPv4 and SCTP/IPv6",
      "section_title": true,
      "ja": "6.2.1. SCTP / IPv4とSCTP / IPv6"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Initial Connectivity",
      "section_title": true,
      "ja": "6.2.1.1. 初期接続"
    },
    {
      "indent": 3,
      "text": "The base protocol is specified in [RFC4960]. This provides an acknowledged PL. A sender can therefore enter the BASE state as soon as connectivity has been confirmed.",
      "ja": "基本プロトコルは[RFC4960]で指定されています。これにより、確認されたPLが提供されます。したがって、接続が確認されたらすぐに送信者が基本状態を入力することができます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.2. Sending SCTP Probe Packets",
      "section_title": true,
      "ja": "6.2.1.2. SCTPプローブパケットを送信します"
    },
    {
      "indent": 3,
      "text": "Probe packets consist of an SCTP common header followed by a HEARTBEAT chunk and a PAD chunk. The PAD chunk is used to control the length of the probe packet. The HEARTBEAT chunk is used to trigger the sending of a HEARTBEAT ACK chunk. The reception of the HEARTBEAT ACK chunk acknowledges reception of a successful probe. A successful probe updates the association and path counters, but an unsuccessful probe is discounted (assumed to be a result of choosing too large a PLPMTU).",
      "ja": "プローブパケットは、SCTP共通ヘッダーとそれに続くハートビートチャンクとパッドチャンクで構成されています。パッドチャンクはプローブパケットの長さを制御するために使用されます。ハートビートチャンクは、ハートビートACKチャンクの送信をトリガーするために使用されます。ハートビートACKチャンクの受信は、成功したプローブの受信を確認します。成功したプローブは、関連付けおよびパスカウンタを更新しますが、プローブが失敗したプローブは割引されます（PLPMTUが大きすぎることがある結果とする）。"
    },
    {
      "indent": 3,
      "text": "The SCTP sender needs to be able to determine the total size of a probe packet. The HEARTBEAT chunk could carry a Heartbeat Information parameter that includes, besides the information suggested in [RFC4960], the probe size to help an implementation associate a HEARTBEAT ACK with the size of probe that was sent. The sender could also use other methods, such as sending a nonce and verifying the information returned also contains the corresponding nonce. The length of the PAD chunk is computed by reducing the probing size by the size of the SCTP common header and the HEARTBEAT chunk. The payload of the PAD chunk contains arbitrary data. When transmitted at the IP layer, the PMTU size also includes the IPv4 or IPv6 header(s).",
      "ja": "SCTP送信者は、プローブパケットの合計サイズを決定できる必要があります。ハートビートチャンクは、[RFC4960]で示唆された情報の他に、実装がハートビートACKを送信されたプローブのサイズと関連付けるのを助けるプローブサイズを含むハートビート情報パラメータを運ぶことができる。送信者は、Nonceの送信や返される情報の検証などの他のメソッドを使用することもできます。パッドチャンクの長さは、SCTP共通ヘッダーとハートビートチャンクのサイズによってプロービングサイズを小さくすることによって計算されます。パッドチャンクのペイロードには任意のデータが含まれています。IP層で送信されると、PMTUサイズにはIPv4またはIPv6ヘッダーも含まれています。"
    },
    {
      "indent": 3,
      "text": "Probing can start directly after the PL handshake; this can be done before data is sent. Assuming this behavior (i.e., the PMTU is smaller than or equal to the interface MTU), this process will take several round-trip time periods, dependent on the number of DPLPMTUD probes sent. The Heartbeat timer can be used to implement the PROBE_TIMER.",
      "ja": "プロービングはPLハンドシェイクの直後に始めることができます。これはデータが送信される前に行うことができます。この動作（すなわち、PMTUがインターフェースMTUよりも小さい）であると仮定すると、このプロセスは送信されたDPLPMTUDプローブの数に応じていくつかの往復期間をとる。ハートビートタイマーを使用してProBE_TIMERを実装できます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3. Validating the Path with SCTP",
      "section_title": true,
      "ja": "6.2.1.3. SCTPのパスを検証する"
    },
    {
      "indent": 3,
      "text": "Since SCTP provides an acknowledged PL, a sender MUST NOT implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE state.",
      "ja": "SCTPは確認されたPLを提供するので、送信者はsearch_complete状態にある間にchender_timerを実装してはいけません。"
    },
    {
      "indent": 0,
      "text": "6.2.1.4. PTB Message Handling by SCTP",
      "section_title": true,
      "ja": "6.2.1.4. SCTPによるPTBメッセージ処理"
    },
    {
      "indent": 3,
      "text": "Normal ICMP validation MUST be performed as specified in Appendix C of [RFC4960]. This requires that the first 8 bytes of the SCTP common header are quoted in the payload of the PTB message, which can be the case for ICMPv4 and is normally the case for ICMPv6.",
      "ja": "[RFC4960]の付録Cで指定されているように、通常のICMP検証を実行する必要があります。これには、SCTP共通ヘッダーの最初の8バイトがPTBメッセージのペイロードで引用されていることを必要とします。これは、ICMPv4の場合は通常ICMPv6の場合です。"
    },
    {
      "indent": 3,
      "text": "When a PTB message has been validated, the PL_PTB_SIZE calculated from the PTB_SIZE reported in the PTB message SHOULD be used with the DPLPMTUD algorithm, provided that the reported PL_PTB_SIZE is less than the current probe size (see Section 4.6).",
      "ja": "PTBメッセージが検証されている場合、報告されたPL_PTB_SIZEが現在のプローブサイズより小さい場合は、PTBメッセージで報告されたPTB_SIZEから計算されたPL_PTB_SIZEをDPLPMTUDアルゴリズムで使用する必要があります（セクション4.6を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.2. DPLPMTUD for SCTP/UDP",
      "section_title": true,
      "ja": "6.2.2. SCTP / UDPのためのDPLPMTUD"
    },
    {
      "indent": 3,
      "text": "The UDP encapsulation of SCTP is specified in [RFC6951].",
      "ja": "SCTPのUDPカプセル化は[RFC6951]に指定されています。"
    },
    {
      "indent": 3,
      "text": "This specification updates the reference to RFC 4821 in Section 5.6 of RFC 6951 to refer to this document (RFC 8899). RFC 6951 is updated by the addition of the following sentence at the end of Section 5.6:",
      "ja": "この仕様は、このドキュメント（RFC 8899）を参照するために、RFC 6951のセクション5.6のRFC 4821への参照を更新します。RFC 6951は、セクション5.6の最後に次の文を追加することによって更新されます。"
    },
    {
      "indent": 3,
      "text": "| The RECOMMENDED method for determining the MTU of the path is | specified in RFC 8899.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2.2.1. Initial Connectivity",
      "section_title": true,
      "ja": "6.2.2.1. 初期接続"
    },
    {
      "indent": 3,
      "text": "A sender can enter the BASE state as soon as SCTP connectivity has been confirmed.",
      "ja": "SCTP接続が確認され次第、送信者は基本状態を入力できます。"
    },
    {
      "indent": 0,
      "text": "6.2.2.2. Sending SCTP/UDP Probe Packets",
      "section_title": true,
      "ja": "6.2.2.2. SCTP / UDPプローブパケットの送信"
    },
    {
      "indent": 3,
      "text": "Packet probing can be performed as specified in Section 6.2.1.2. The size of the probe packet includes the 8 bytes of UDP header. This has to be considered when filling the probe packet with the PAD chunk.",
      "ja": "6.2.1.2項で指定されているように、パケットプロービングを実行できます。プローブパケットのサイズには、8バイトのUDPヘッダーが含まれています。これは、プローブパケットをパッドチャンクと埋めるときに考慮されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.2.3. Validating the Path with SCTP/UDP",
      "section_title": true,
      "ja": "6.2.2.3. SCTP / UDPでパスを検証します"
    },
    {
      "indent": 3,
      "text": "SCTP provides an acknowledged PL; therefore, a sender does not implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE state.",
      "ja": "SCTPは認められたPLを提供します。したがって、送信者はsearch_complete状態にある間にchenting_timerを実装しません。"
    },
    {
      "indent": 0,
      "text": "6.2.2.4. Handling of PTB Messages by SCTP/UDP",
      "section_title": true,
      "ja": "6.2.2.4. SCTP / UDPによるPTBメッセージの処理"
    },
    {
      "indent": 3,
      "text": "ICMP validation MUST be performed for PTB messages as specified in Appendix C of [RFC4960]. This requires that the first 8 bytes of the SCTP common header are contained in the PTB message, which can be the case for ICMPv4 (but note the UDP header also consumes a part of the quoted packet header) and is normally the case for ICMPv6. When the validation is completed, the PL_PTB_SIZE calculated from the PTB_SIZE in the PTB message SHOULD be used with the DPLPMTUD providing that the reported PL_PTB_SIZE is less than the current probe size.",
      "ja": "[RFC4960]の付録Cで指定されているように、PTBメッセージに対してICMP検証を実行する必要があります。これには、SCTP共通ヘッダーの最初の8バイトがPTBメッセージに含まれていることを必要とします。検証が完了すると、PTBメッセージ内のPTB_SIZEから計算されたPL_PTB_SIZEは、報告されたPL_PTB_SIZEが現在のプローブサイズより小さいことを提供するDPLPMTUDと共に使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.2.3. DPLPMTUD for SCTP/DTLS",
      "section_title": true,
      "ja": "6.2.3. SCTP / DTLS用のDPLPMTUD"
    },
    {
      "indent": 3,
      "text": "The Datagram Transport Layer Security (DTLS) encapsulation of SCTP is specified in [RFC8261]. This is used for data channels in WebRTC implementations. This specification updates the reference to RFC 4821 in Section 5 of RFC 8261 to refer to this document (RFC 8899).",
      "ja": "SCTPのデータグラムトランスポート層セキュリティ（DTLS）カプセル化は[RFC8261]に指定されています。これはWebRTC実装のデータチャネルに使用されます。この仕様は、この文書を参照するために、RFC 8261のセクション5のRFC 4821への参照を更新します（RFC 8899）。"
    },
    {
      "indent": 0,
      "text": "6.2.3.1. Initial Connectivity",
      "section_title": true,
      "ja": "6.2.3.1. 初期接続"
    },
    {
      "indent": 3,
      "text": "A sender can enter the BASE state as soon as SCTP connectivity has been confirmed.",
      "ja": "SCTP接続が確認され次第、送信者は基本状態を入力できます。"
    },
    {
      "indent": 0,
      "text": "6.2.3.2. Sending SCTP/DTLS Probe Packets",
      "section_title": true,
      "ja": "6.2.3.2. SCTP / DTLSプローブパケットを送信します"
    },
    {
      "indent": 3,
      "text": "Packet probing can be done as specified in Section 6.2.1.2. The maximum payload is reduced by the size of the DTLS headers, which has to be considered when filling the PAD chunk. The size of the probe packet includes the DTLS PL headers. This has to be considered when filling the probe packet with the PAD chunk.",
      "ja": "パケットプロービングは、6.2.1.2項で指定されているように行うことができます。最大ペイロードは、パッドチャンクを埋めるときに考慮されなければならないDTLSヘッダーのサイズによって減少します。プローブパケットのサイズはDTLS PLヘッダーを含む。これは、プローブパケットをパッドチャンクと埋めるときに考慮されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.3.3. Validating the Path with SCTP/DTLS",
      "section_title": true,
      "ja": "6.2.3.3. SCTP / DTLSでパスを検証します"
    },
    {
      "indent": 3,
      "text": "Since SCTP provides an acknowledged PL, a sender MUST NOT implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE state.",
      "ja": "SCTPは確認されたPLを提供するので、送信者はsearch_complete状態にある間にchender_timerを実装してはいけません。"
    },
    {
      "indent": 0,
      "text": "6.2.3.4. Handling of PTB Messages by SCTP/DTLS",
      "section_title": true,
      "ja": "6.2.3.4. SCTP / DTLSによるPTBメッセージの処理"
    },
    {
      "indent": 3,
      "text": "[RFC4960] does not specify a way to validate SCTP/DTLS ICMP message payload and neither does this document. This can prevent processing of PTB messages at the PL.",
      "ja": "[RFC4960] SCTP / DTLS ICMPメッセージペイロードを検証する方法は指定されておらず、このドキュメントはありません。これにより、PLでのPTBメッセージの処理を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "6.3. DPLPMTUD for QUIC",
      "section_title": true,
      "ja": "6.3. 熟練のためのdplpmtud"
    },
    {
      "indent": 3,
      "text": "QUIC [QUIC] is a UDP-based PL that provides reception feedback. The UDP payload includes a QUIC packet header, a protected payload, and any authentication fields. It supports padding and packet coalescence that can be used to construct probe packets. From the perspective of DPLPMTUD, QUIC can function as an acknowledged PL. [QUIC] describes the method for using DPLPMTUD with QUIC packets.",
      "ja": "QUIC [QUIC]は、受信フィードバックを提供するUDPベースのPLです。UDPペイロードには、QUICパケットヘッダー、保護されたペイロード、および任意の認証フィールドが含まれています。プローブパケットを構築するために使用できるパディングとパケットの合体をサポートします。DPLPMTUDの観点からは、QUICは認証されたPLとして機能することができます。[QUIC] QUICパケットを使用してDPLPMTUDを使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAの行動がありません。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security considerations for the use of UDP and SCTP are provided in the referenced RFCs.",
      "ja": "UDPおよびSCTPを使用するためのセキュリティ上の考慮事項は、参照されているRFCに提供されています。"
    },
    {
      "indent": 3,
      "text": "To avoid excessive load, the interval between individual probe packets MUST be at least one RTT, and the interval between rounds of probing is determined by the PMTU_RAISE_TIMER.",
      "ja": "過度の負荷を回避するために、個々のプローブパケット間の間隔は少なくとも1つのRTTでなければならず、プロービングのラウンド間の間隔はPMTU_RAISE_TIMERによって決定されます。"
    },
    {
      "indent": 3,
      "text": "A PL sender needs to ensure that the method used to confirm reception of probe packets protects from off-path attackers injecting packets into the path. This protection is provided in IETF-defined protocols (e.g., TCP, SCTP) using a randomly initialized sequence number. A description of one way to do this when using UDP is provided in Section 5.1 of [BCP145]).",
      "ja": "PL送信者は、プローブパケットの受信を確認するために使用される方法が、パケットをパスに注入するオフパス攻撃者から保護することを保証する必要があります。この保護は、ランダムに初期化されたシーケンス番号を使用して、IETF定義プロトコル（例えば、TCP、SCTP）に提供されます。UDPを使用するときにこれを行う1つの方法の説明は、セクション5.1の[BCP145]）に提供されています。"
    },
    {
      "indent": 3,
      "text": "There are cases where ICMP Packet Too Big (PTB) messages are not delivered due to policy, configuration, or equipment design (see Section 1.1). This method therefore does not rely upon PTB messages being received but is able to utilize these when they are received by the sender. PTB messages could potentially be used to cause a node to inappropriately reduce the PLPMTU. A node supporting DPLPMTUD MUST therefore appropriately validate the payload of PTB messages to ensure these are received in response to transmitted traffic (i.e., a reported error condition that corresponds to a datagram actually sent by the path layer, see Section 4.6.1).",
      "ja": "ポリシー、構成、または機器の設計により、ICMPパケットが大きすぎる（PTB）メッセージが配信されない場合があります（セクション1.1を参照）。したがって、この方法は受信されているPTBメッセージに頼らないが、それらが送信者によって受信されたときにこれらを利用することができる。PTBメッセージは、ノードにPLPMTUを不適切に減少させるために潜在的に使用される可能性があります。したがって、DPLPMTUDをサポートするノードは、送信トラフィック（すなわち、パス層によって実際に送信されたデータグラムに対応する報告されたエラー状態、セクション4.6.1を参照）に応答してこれらが受信されることを確実にするためにPTBメッセージのペイロードを適切に検証する必要がある。"
    },
    {
      "indent": 3,
      "text": "An on-path attacker able to create a PTB message could forge PTB messages that include a valid quoted IP packet. Such an attack could be used to drive down the PLPMTU. An on-path device could similarly force a reduction of the PLPMTU by implementing a policy that drops packets larger than a configured size. There are two ways this method can be mitigated against such attacks: first, by ensuring that a PL sender never reduces the PLPMTU below the base size solely in response to receiving a PTB message. This is achieved by first entering the BASE state when such a message is received. Second, the design does not require processing of PTB messages; a PL sender could therefore suspend processing of PTB messages (e.g., in a robustness mode after detecting that subsequent probes actually confirm that a size larger than the PTB_SIZE is supported by a path).",
      "ja": "PTBメッセージを作成できるオンパス攻撃者は、有効な引用符付きIPパケットを含むPTBメッセージを符号化することができる。そのような攻撃はPLPMTUを駆動するために使用され得る。オンパス装置は同様に構成されたサイズよりも大きいパケットをドロップするポリシーを実装することによってPLPMTUの減少を強制することができる。この方法は、この方法がそのような攻撃に対して軽減できる方法が2つあります。最初に、PL送信者がPTBメッセージの受信に応答してベースサイズの下のPLPMTUを短くすることを確実にすることによって。このようなメッセージが受信されたときに最初に基本状態に入ることによって達成される。第二に、設計はPTBメッセージの処理を必要としません。したがって、PL送信者は、PTBメッセージの処理を中断し（例えば、後続のプローブが実際にPTB_SIZEよりも大きいサイズが経路によってサポートされていることを実際に確認した後に堅牢性モードで）。"
    },
    {
      "indent": 3,
      "text": "Parsing the quoted packet inside a PTB message can introduce additional per-packet processing at the PL sender. This processing SHOULD be limited to avoid a denial-of-service attack when arbitrary headers are included. Rate-limiting the processing could result in PTB messages not being received by a PL; however, the DPLPMTUD method is robust to such loss.",
      "ja": "PTBメッセージ内の引用符付きパケットの解析PL送信者に追加のパケットごとの処理を導入できます。この処理は、任意のヘッダが含まれている場合のサービス拒否攻撃を回避するために限定されるべきである。レート制限処理はPLによって受信されていないPTBメッセージを受信する可能性があります。しかしながら、DPLPMTUD法はそのような損失に対して堅牢である。"
    },
    {
      "indent": 3,
      "text": "The successful processing of an ICMP message can trigger a probe when the reported PTB size is valid, but this does not directly update the PLPMTU for the path. This prevents a message attempting to black hole data by indicating a size larger than supported by the path.",
      "ja": "ICMPメッセージの処理が成功すると、報告されたPTBサイズが有効なときにプローブがトリガーできますが、これはパスのPLPMTUを直接更新しません。これにより、パスによってサポートされているよりも大きいサイズを示すことによってブラックホールデータを試みることが防止されます。"
    },
    {
      "indent": 3,
      "text": "It is possible that the information about a path is not stable. This could be a result of forwarding across more than one path that has a different actual PMTU or a single path presents a varying PMTU. The design of a PLPMTUD implementation SHOULD consider how to mitigate the effects of varying path information. One possible mitigation is to provide robustness (see Section 5.4) in the method that avoids oscillation in the MPS.",
      "ja": "パスに関する情報が安定していない可能性があります。これは、異なる実際のPMTUまたは単一のパスを持つ複数のパスにわたる転送の結果である可能性があります。PLPMTUD実装の設計は、さまざまなパス情報の影響を軽減する方法を検討する必要があります。1つの可能な緩和は、MPSにおける振動を回避する方法で堅牢性（5.4節を参照）を提供することです。"
    },
    {
      "indent": 3,
      "text": "DPLPMTUD methods can introduce padding data to inflate the length of the datagram to the total size required for a probe packet. The total size of a probe packet includes all headers and padding added to the payload data being sent (e.g., including security-related fields such as an AEAD tag and TLS record layer padding). The value of the padding data does not influence the DPLPMTUD search algorithm, and therefore needs to be set consistent with the policy of the PL.",
      "ja": "DPLPMTUDメソッドは、データグラムの長さをプローブパケットに必要な合計サイズに膨張させるためにパディングデータを導入できます。プローブパケットの合計サイズは、送信されているペイロードデータに追加されたすべてのヘッダとパディングを含み、（例えば、AEADタグやTLSレコード層パディングなどのセキュリティ関連のフィールドを含む）。パディングデータの値はDPLPMTUD検索アルゴリズムに影響を与えず、したがってPLのポリシーと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a PL can make use of cryptographic confidentiality or data-integrity mechanisms, then the design ought to avoid adding anything (e.g., padding) to DPLPMTUD probe packets that is not also protected by those cryptographic mechanisms.",
      "ja": "PLが暗号化機密性またはデータ完全性メカニズムを利用することができる場合、デザインは、それらの暗号メカニズムによっても保護されていないDPLPMTUDプローブパケットに何も追加する（例えば、パディング）、追加を回避するべきである。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BCP145] Eggert, L., Fairhurst, G., and G. Shepherd, \"UDP Usage Guidelines\", BCP 145, RFC 8085, March 2017, <https://www.rfc-editor.org/info/bcp145>.",
      "ja": "[BCP145] eggert、L.、FairHurst、G.、G.Shepherd、 \"UDP使用ガイドライン\"、BCP 145、RFC 8085、2017年3月、<https：//www.rfc-editor.org/info/bcp145>。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <https://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC0768] Postel、J.、 \"User Datagram Protocol\"、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、<https://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <https://www.rfc-editor.org/info/rfc791>.",
      "ja": "[RFC0791] Postel、J.、「インターネットプロトコル」、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<https://www.rfc-editor.org/info/rfc791>。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, DOI 10.17487/RFC1191, November 1990, <https://www.rfc-editor.org/info/rfc1191>.",
      "ja": "[RFC1191] Mogul、J.およびS.Theering、 \"Path Mtu Discovery\"、RFC 1191、DOI 10.17487 / RFC1191、1990年11月、<https：//www.rfc-editor.org/info/rfc1191>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed., and G. Fairhurst, Ed., \"The Lightweight User Datagram Protocol (UDP-Lite)\", RFC 3828, DOI 10.17487/RFC3828, July 2004, <https://www.rfc-editor.org/info/rfc3828>.",
      "ja": "[RFC3828] Larzon、LA、Degermark、M.、Pink、S.、Jonsson、Le。、Ed。、およびG. FairHurst、「軽量ユーザーデータグラムプロトコル（UDP-Lite）」、RFC 3828、DOI 10.17487 / RFC3828、2004年7月、<https://www.rfc-editor.org/info/rfc3828>。"
    },
    {
      "indent": 3,
      "text": "[RFC4820] Tuexen, M., Stewart, R., and P. Lei, \"Padding Chunk and Parameter for the Stream Control Transmission Protocol (SCTP)\", RFC 4820, DOI 10.17487/RFC4820, March 2007, <https://www.rfc-editor.org/info/rfc4820>.",
      "ja": "[RFC4820] Tuexen、M.、Stewart、R.およびP.Lei、「ストリーム制御伝送プロトコルのパラメータ（SCTP）」、RFC 4820、DOI 10.17487 / RFC4820、2007年3月、<https：//www.rfc-editor.org/info/rfc4820>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <https://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960] Stewart、R.、Ed。、「ストリーム制御伝送プロトコル」、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<https：//www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC6951] Tuexen, M. and R. Stewart, \"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication\", RFC 6951, DOI 10.17487/RFC6951, May 2013, <https://www.rfc-editor.org/info/rfc6951>.",
      "ja": "[RFC6951] Tuexen、M.およびR.Stewart、「エンドホストへのストリーム制御伝送プロトコル（SCTP）パケットの「UDPカプセル化」、RFC 6951、DOI 10.17487 / RFC6951、2013年5月、<https：//www.rfc-editor.org/info/rfc6951>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] The'th、S.およびR.hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https：//www.rfc-editor.org/ info / rfc8200>。"
    },
    {
      "indent": 3,
      "text": "[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>.",
      "ja": "[RFC8201] McCann、J.、Theer、S.、Mogul、J.、およびR. Hinden、Ed。、「IPバージョン6のためのパスMTUディスカバリー」、STD 87、RFC 8201、DOI 10.17487 / RFC8201、2017年7月、<https://www.rfc-editor.org/info/rfc8201>。"
    },
    {
      "indent": 3,
      "text": "[RFC8261] Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, \"Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets\", RFC 8261, DOI 10.17487/RFC8261, November 2017, <https://www.rfc-editor.org/info/rfc8261>.",
      "ja": "[RFC8261] Tuexen、M.、Stewart、R.、Jesup、R.、およびS. Loreto、SCTPパケットの「データグラムトランスポート層セキュリティ（DTLS）カプセル化」、RFC 8261、DOI 10.17487 / RFC8261、2017年11月、<HTTPS：//www.rfc-editor.org/info/rfc8261>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[QUIC] Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based Multiplexed and Secure Transport\", Work in Progress, Internet-Draft, draft-ietf-quic-transport-29, 10 June 2020, <https://tools.ietf.org/html/draft-ietf-quic-transport-29>.",
      "ja": "[QUIC] Iyngar、J.、ED。M. Thomson、Ed。「QUIC：UDPベースの多重化および安全な輸送」、進行中の作業、インターネットドラフト、ドラフトIETF-Quic-Transport-29、<https：//ツール。ietf.org/html/draft-ietf-kic-transport-29>。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <https://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC0792] Postel、J.、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<https：//www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122] Braden、R.、ED。、「インターネットホストの要求 - 通信層の要求」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https：//www.rfc-editor.org/info/RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., Ed., \"Requirements for IP Version 4 Routers\", RFC 1812, DOI 10.17487/RFC1812, June 1995, <https://www.rfc-editor.org/info/rfc1812>.",
      "ja": "[RFC1812] Baker、F.、ED。、「IPバージョン4ルータの要件」、RFC 1812、DOI 10.17487 / RFC1812、1995年6月、<https：//www.rfc-editor.org/info/rfc1812>。"
    },
    {
      "indent": 3,
      "text": "[RFC2923] Lahey, K., \"TCP Problems with Path MTU Discovery\", RFC 2923, DOI 10.17487/RFC2923, September 2000, <https://www.rfc-editor.org/info/rfc2923>.",
      "ja": "[RFC2923] Lahey、K。、「Path MTU DiscoveryのTCP問題」、RFC 2923、DOI 10.17487 / RFC2923、2000年9月、<https：//www.rfc-editor.org/info/rfc2923>。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, DOI 10.17487/RFC4340, March 2006, <https://www.rfc-editor.org/info/rfc4340>.",
      "ja": "[RFC4340] Kohler、E.、Handley、M.、S. Floyd、「データグラム輻輳制御プロトコル（DCCP）」、RFC 4340、DOI 10.17487 / RFC4340、2006年3月、<https：//www.rfc-編集者。ORG / INFO / RFC4340>。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006, <https://www.rfc-editor.org/info/rfc4443>.",
      "ja": "[RFC4443] Conta、A.、Theering、S.およびM.Gupta、Internet Protocol Version 6（IPv6）仕様のICMPv6（ICMPv6）、STD 89、RFC 4443、DOI 10.17487 /RFC4443、2006年3月、<https://www.rfc-editor.org/info/rfc4443>。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <https://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821] Mathis、M.およびJ.Heffner、 \"Packetization Layer Path MTU Discovery\"、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<https：//www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC4890] Davies, E. and J. Mohacsi, \"Recommendations for Filtering ICMPv6 Messages in Firewalls\", RFC 4890, DOI 10.17487/RFC4890, May 2007, <https://www.rfc-editor.org/info/rfc4890>.",
      "ja": "[RFC4890] Davies、E.およびJ.Mohacsi、「ファイアウォールのICMPv6メッセージをフィルタリングするための推奨事項」、RFC 4890、DOI 10.17487 / RFC4890、2007年5月、<https：//ww.rfc-editor.org/info/rfc4890>。"
    },
    {
      "indent": 3,
      "text": "[RFC5508] Srisuresh, P., Ford, B., Sivakumar, S., and S. Guha, \"NAT Behavioral Requirements for ICMP\", BCP 148, RFC 5508, DOI 10.17487/RFC5508, April 2009, <https://www.rfc-editor.org/info/rfc5508>.",
      "ja": "[RFC5508] SRISURESH、P.、FORD、B.、Sivakumar、S.、およびS.Guha、「ICMPのNAT行動要件」、BCP 148、RFC 5508、DOI 10.17487 / RFC5508、2009年4月、<https：//www.rfc-editor.org/info/rfc5508>。"
    },
    {
      "indent": 3,
      "text": "[RFC8900] Bonica, R., Baker, F., Huston, G., Hinden, R., Troan, O., and F. Gont, \"IP Fragmentation Considered Fragile\", RFC 8900, BCP 230, September 2020, <https://www.rfc-editor.org/info/rfc8900>.",
      "ja": "[RFC8900]ボニャ、R.、Baker、F.、Huston、G.、Hinden、R.、Troan、O.、およびF.ゴント、「IPフラグメンテーションと見なされる脆弱」、RFC 8900、BCP 230、2020年9月、<https://www.rfc-editor.org/info/rfc8900>。"
    },
    {
      "indent": 3,
      "text": "[TUNNELS] Touch, J. and M. Townsley, \"IP Tunnels in the Internet Architecture\", Work in Progress, Internet-Draft, draft-ietf-intarea-tunnels-10, 12 September 2019, <https://tools.ietf.org/html/draft-ietf-intarea-tunnels-10>.",
      "ja": "[Tunnels] Touch、J.およびM. Townsley、「インターネットアーキテクチャのIPトンネル」、進捗状況、インターネットドラフト、Draft-IETF-Intarea-Tunnels-10,12、<https：//ツール。ietf.org/html/draft-ietf-intarea-tunnels-10>"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This work was partially funded by the European Union Horizon 2020 Research and Innovation Programme under grant agreement No. 644334, \"A New, Evolutive API and Transport-Layer Architecture for the Internet\" (NEAT). The views expressed are solely those of the author(s).",
      "ja": "この作品は、助成金協定の下で、欧州連合ホライズン2020研究およびイノベーションプログラムによって部分的に資金提供されており、「インターネットのための新しく進化するAPIおよびトランスポート層アーキテクチャ」（きちんと）。表現されたビューは著者のものだけです。"
    },
    {
      "indent": 3,
      "text": "Thanks to all who have commented or contributed, the TSVWG and QUIC working groups, and Mathew Calder and Julius Flohr for providing early implementations.",
      "ja": "早期実装を提供するために、TSVWG、およびQUICワーキンググループ、およびMathew CalderとJulius Flohrのおかげで、すべての早期実装を提供しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Godred Fairhurst University of Aberdeen School of Engineering Fraser Noble Building Aberdeen AB24 3UE United Kingdom",
      "ja": "アバディーン大学アバディーン大学エンジニアリングフレイザーノーブルビルアバディーンAB24 3UEイギリス"
    },
    {
      "indent": 3,
      "text": "Email: gorry@erg.abdn.ac.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Jones University of Aberdeen School of Engineering Fraser Noble Building Aberdeen AB24 3UE United Kingdom",
      "ja": "トムジョーンズ大学アバディーン大学エンジニアリングフレイザーノーブルビルアバディーンAB24 3UEイギリス"
    },
    {
      "indent": 3,
      "text": "Email: tom@erg.abdn.ac.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Tüxen Münster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany",
      "ja": "MichaelTüxenMünster大学応用科学大学Stegerwaldstrasse 39 48565 Steinfurtドイツ"
    },
    {
      "indent": 3,
      "text": "Email: tuexen@fh-muenster.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Irene Rüngeler Münster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany",
      "ja": "IreneRüngelerMünster大学Stegerwaldstrasse 39 48565 Steinfurtドイツ"
    },
    {
      "indent": 3,
      "text": "Email: i.ruengeler@fh-muenster.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Timo Völker Münster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany",
      "ja": "TimoVölkerMünster大学応用科学大学Stegerwaldstrasse 39 48565 Steinfurtドイツ"
    },
    {
      "indent": 3,
      "text": "Email: timo.voelker@fh-muenster.de",
      "raw": true,
      "ja": ""
    }
  ]
}