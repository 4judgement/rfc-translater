{
  "title": {
    "text": "RFC 8382 - Shared Bottleneck Detection for Coupled Congestion Control for RTP Media",
    "ja": "RFC 8382 - RTPメディアの結合輻輳制御のための共有ボトルネック検出"
  },
  "number": 8382,
  "created_at": "2020-08-23 14:58:09.250207+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     D. Hayes, Ed.\nRequest for Comments: 8382                                     S. Ferlin\nCategory: Experimental                        Simula Research Laboratory\nISSN: 2070-1721                                                 M. Welzl\n                                                               K. Hiorth\n                                                      University of Oslo\n                                                               June 2018",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Shared Bottleneck Detection for Coupled Congestion Control for RTP Media",
      "ja": "RTPメディアの結合輻輳制御のための共有ボトルネック検出"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism to detect whether end-to-end data flows share a common bottleneck. This mechanism relies on summary statistics that are calculated based on continuous measurements and used as input to a grouping algorithm that runs wherever the knowledge is needed.",
      "ja": "このドキュメントでは、エンドツーエンドのデータフローが共通のボトルネックを共有しているかどうかを検出するメカニズムについて説明します。このメカニズムは、継続的な測定に基づいて計算され、知識が必要なときに実行されるグループ化アルゴリズムへの入力として使用される要約統計に依存しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補であるとは限りません。 RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8382.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8382で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. The Basic Mechanism ........................................4\n   1.2. The Signals ................................................4\n        1.2.1. Packet Loss .........................................4\n        1.2.2. Packet Delay ........................................5\n        1.2.3. Path Lag ............................................5\n2. Definitions .....................................................6\n   2.1. Parameters and Their Effects ...............................7\n   2.2. Recommended Parameter Values ...............................8\n3. Mechanism .......................................................9\n   3.1. SBD Feedback Requirements .................................10\n        3.1.1. Feedback When All the Logic Is Placed at\n               the Sender .........................................10\n        3.1.2. Feedback When the Statistics Are Calculated at the\n               Receiver and SBD Is Performed at the Sender ........11\n        3.1.3. Feedback When Bottlenecks Can Be Determined\n               at Both Senders and Receivers ......................11\n   3.2. Key Metrics and Their Calculation .........................12\n        3.2.1. Mean Delay .........................................12\n        3.2.2. Skewness Estimate ..................................12\n        3.2.3. Variability Estimate ...............................13\n        3.2.4. Oscillation Estimate ...............................13\n        3.2.5. Packet Loss ........................................14\n   3.3. Flow Grouping .............................................14\n        3.3.1. Flow-Grouping Algorithm ............................14\n        3.3.2. Using the Flow Group Signal ........................18\n4. Enhancements to the Basic SBD Algorithm ........................18\n   4.1. Reducing Lag and Improving Responsiveness .................18\n        4.1.1. Improving the Response of the Skewness Estimate ....19\n        4.1.2. Improving the Response of the Variability\n               Estimate ...........................................20\n   4.2. Removing Oscillation Noise ................................21\n5. Measuring OWD ..................................................21\n   5.1. Timestamp Resolution ......................................21\n   5.2. Clock Skew ................................................22\n6. Expected Feedback from Experiments .............................22\n7. IANA Considerations ............................................22\n8. Security Considerations ........................................22\n9. References .....................................................23\n   9.1. Normative References ......................................23\n   9.2. Informative References ....................................23\nAcknowledgments ...................................................25\nAuthors' Addresses ................................................25",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In the Internet, it is not normally known whether flows (e.g., TCP connections or UDP data streams) traverse the same bottlenecks. Even flows that have the same sender and receiver may take different paths and may or may not share a bottleneck. Flows that share a bottleneck link usually compete with one another for their share of the capacity. This competition has the potential to increase packet loss and delays. This is especially relevant for interactive applications that communicate simultaneously with multiple peers (such as multi-party video). For RTP media applications such as RTCWEB, [RTP-COUPLED-CC] describes a scheme that combines the congestion controllers of flows in order to honor their priorities and avoid unnecessary packet loss as well as delay. This mechanism relies on some form of Shared Bottleneck Detection (SBD); here, a measurement-based SBD approach is described.",
      "ja": "インターネットでは、フロー（TCP接続やUDPデータストリームなど）が同じボトルネックを通過するかどうかは通常はわかりません。送信側と受信側が同じフローでも、経路が異なり、ボトルネックを共有する場合としない場合があります。ボトルネックリンクを共有するフローは、通常、容量のシェアをめぐって互いに競合します。この競争は、パケットの損失と遅延を増加させる可能性があります。これは、複数のピアと同時に通信するインタラクティブアプリケーション（マルチパーティビデオなど）に特に関係します。 RTCWEBなどのRTPメディアアプリケーションの場合、[RTP-COUPLED-CC]は、フローの輻輳コントローラを組み合わせて、それらの優先順位を守り、不要なパケット損失や遅延を回避するスキームについて説明しています。このメカニズムは、何らかの形の共有ボトルネック検出（SBD）に依存しています。ここでは、測定ベースのSBDアプローチについて説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. The Basic Mechanism",
      "section_title": true,
      "ja": "1.1. 基本的なメカニズム"
    },
    {
      "indent": 3,
      "text": "The mechanism groups flows that have similar statistical characteristics together. Section 3.3.1 describes a simple method for achieving this; however, a major part of this document is concerned with collecting suitable statistics for this purpose.",
      "ja": "このメカニズムは、類似した統計特性を持つフローをグループ化します。セクション3.3.1では、これを実現する簡単な方法について説明します。ただし、このドキュメントの主要な部分は、この目的に適した統計の収集に関係しています。"
    },
    {
      "indent": 0,
      "text": "1.2. The Signals",
      "section_title": true,
      "ja": "1.2. 信号"
    },
    {
      "indent": 3,
      "text": "The current Internet is unable to explicitly inform endpoints as to which flows share bottlenecks, so endpoints need to infer this from whatever information is available to them. The mechanism described here currently utilizes packet loss and packet delay but is not restricted to these. As Explicit Congestion Notification (ECN) becomes more prevalent, it too will become a valuable base signal that can be correlated to detect shared bottlenecks.",
      "ja": "現在のインターネットでは、どのフローがボトルネックを共有しているかをエンドポイントに明示的に通知できないため、エンドポイントは、エンドポイントが利用できる情報からこれを推測する必要があります。ここで説明するメカニズムは現在、パケット損失とパケット遅延を利用していますが、これらに限定されません。明示的輻輳通知（ECN）が普及すると、共有ボトルネックを検出するために相関できる貴重な基本信号になります。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Packet Loss",
      "section_title": true,
      "ja": "1.2.1. パケットロス"
    },
    {
      "indent": 3,
      "text": "Packet loss is often a relatively infrequent indication that a flow traverses a bottleneck. Therefore, on its own it is of limited use for SBD; however, it is a valuable supplementary measure when it is more prevalent (refer to [RFC7680], Section 2.5 for measuring packet loss).",
      "ja": "多くの場合、パケット損失は、フローがボトルネックを通過することを示す比較的まれな指標です。したがって、それだけではSBDの使用は制限されます。ただし、より一般的である場合、これは価値のある補足的な測定です（パケット損失の測定については[RFC7680]、セクション2.5を参照してください）。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Packet Delay",
      "section_title": true,
      "ja": "1.2.2. パケット遅延"
    },
    {
      "indent": 3,
      "text": "End-to-end delay measurements include noise from every device along the path, in addition to the delay perturbation at the bottleneck device. The noise is often significantly increased if the round-trip time is used. The cleanest signal is obtained by using One-Way Delay (OWD) (refer to [RFC7679], Section 3 for a definition of OWD).",
      "ja": "エンドツーエンドの遅延測定には、ボトルネックデバイスでの遅延の摂動に加えて、パスに沿ったすべてのデバイスからのノイズが含まれます。往復時間を使用すると、ノイズが大幅に増加することがよくあります。最もクリーンな信号は、一方向遅延（OWD）を使用して取得されます（OWDの定義については、[RFC7679]のセクション3を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Measuring absolute OWD is difficult, since it requires both the sender and receiver clocks to be synchronized. However, since the statistics being collected are relative to the mean OWD, a relative OWD measurement is sufficient. Clock skew is not usually significant over the time intervals used by this SBD mechanism (see [RFC6817], Appendix A.2 for a discussion on clock skew and OWD measurements). However, in circumstances where it is significant, Section 5.2 outlines a way of adjusting the calculations to cater to it.",
      "ja": "送信機と受信機の両方のクロックを同期させる必要があるため、絶対OWDの測定は困難です。ただし、収集される統計は平均OWDに関連しているため、相対OWD測定で十分です。通常、このSBDメカニズムで使用される時間間隔では、クロックスキューは重要ではありません（クロックスキューとOWD測定の説明については、[RFC6817]、付録A.2を参照してください）。ただし、それが重要な状況では、セクション5.2で計算を調整してそれに対応する方法の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "Each packet arriving at the bottleneck buffer may experience very different queue lengths and, therefore, different waiting times. A single OWD sample does not, therefore, characterize the path well. However, multiple OWD measurements do reflect the distribution of delays experienced at the bottleneck.",
      "ja": "ボトルネックバッファーに到着する各パケットは、非常に異なるキューの長さを経験する可能性があるため、異なる待機時間が発生する可能性があります。したがって、単一のOWDサンプルは、パスを適切に特徴付けません。ただし、複数のOWD測定は、ボトルネックで発生した遅延の分布を反映しています。"
    },
    {
      "indent": 0,
      "text": "1.2.3. Path Lag",
      "section_title": true,
      "ja": "1.2.3. 道を進む"
    },
    {
      "indent": 3,
      "text": "Flows that share a common bottleneck may traverse different paths, and these paths will often have different base delays. This makes it difficult to correlate changes in delay or loss. This technique uses the long-term shape of the delay distribution as a base for comparison to counter this.",
      "ja": "共通のボトルネックを共有するフローは異なるパスを通過する可能性があり、これらのパスは多くの場合、異なるベース遅延を持ちます。これにより、遅延または損失の変化を関連付けることが困難になります。この手法は、これに対抗するための比較のベースとして、遅延分布の長期的な形状を使用します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Acronyms used in this document:",
      "ja": "このドキュメントで使用される頭字語："
    },
    {
      "indent": 6,
      "text": "OWD - One-Way Delay",
      "ja": "OWD-一方向遅延"
    },
    {
      "indent": 6,
      "text": "MAD - Mean Absolute Deviation",
      "ja": "MAD-平均絶対偏差"
    },
    {
      "indent": 6,
      "text": "SBD - Shared Bottleneck Detection",
      "ja": "SBD-共有ボトルネック検出"
    },
    {
      "indent": 3,
      "text": "Conventions used in this document:",
      "ja": "このドキュメントで使用される規則："
    },
    {
      "indent": 6,
      "text": "T the base time interval over which measurements are made",
      "ja": "T測定が行われる基本時間間隔"
    },
    {
      "indent": 6,
      "text": "N the number of base time, T, intervals used in some calculations",
      "ja": "Nは、いくつかの計算で使用されるベース時間、T、間隔の数"
    },
    {
      "indent": 6,
      "text": "M the number of base time, T, intervals used in some calculations, where M <= N",
      "ja": "Mは、いくつかの計算で使用される基本時間Tの間隔の数で、M <= N"
    },
    {
      "indent": 6,
      "text": "sum(...) summation of terms of the variable in parentheses",
      "ja": "sum（...）括弧内の変数の項の合計"
    },
    {
      "indent": 6,
      "text": "sum_T(...) summation of all the measurements of the variable in parentheses taken over the interval T",
      "ja": "sum_T（...）間隔Tで取得された括弧内の変数のすべての測定値の合計"
    },
    {
      "indent": 6,
      "text": "sum_NT(...) summation of all measurements taken over the interval N*T",
      "ja": "sum_NT（...）間隔N * Tで行われたすべての測定の合計"
    },
    {
      "indent": 6,
      "text": "sum_MT(...) summation of all measurements taken over the interval M*T",
      "ja": "sum_MT（...）間隔M * Tで取得されたすべての測定の合計"
    },
    {
      "indent": 6,
      "text": "E_T(...) the expectation or mean of the measurements of the variable in parentheses over T",
      "ja": "E_T（...）T上の括弧内の変数の測定値の期待値または平均"
    },
    {
      "indent": 6,
      "text": "E_N(...) the expectation or mean of the last N values of the variable in parentheses",
      "ja": "E_N（...）括弧内の変数の最後のN値の期待値または平均"
    },
    {
      "indent": 6,
      "text": "E_M(...) the expectation or mean of the last M values of the variable in parentheses",
      "ja": "E_M（...）括弧内の変数の最後のM値の期待値または平均"
    },
    {
      "indent": 6,
      "text": "num_T(...) the count of measurements of the variable in parentheses taken in the interval T",
      "ja": "num_T（...）間隔Tで取得された括弧内の変数の測定数"
    },
    {
      "indent": 6,
      "text": "num_MT(...) the count of measurements of the variable in parentheses taken in the interval M*T",
      "ja": "num_MT（...）間隔M * Tで取得された括弧内の変数の測定数"
    },
    {
      "indent": 6,
      "text": "PB a boolean variable indicating that the particular flow was identified transiting a bottleneck in the previous interval T (i.e., \"Previously Bottleneck\")",
      "ja": "PB特定のフローが前のインターバルTでボトルネックを通過していることが識別されたことを示すブール変数（つまり、「以前はボトルネック」）"
    },
    {
      "indent": 6,
      "text": "skew_est a measure of skewness in an OWD distribution",
      "ja": "skew_est OWD分布の歪度の測定値"
    },
    {
      "indent": 6,
      "text": "skew_base_T a variable used as an intermediate step in calculating skew_est",
      "ja": "skew_base_T skew_estの計算の中間ステップとして使用される変数"
    },
    {
      "indent": 6,
      "text": "var_est a measure of variability in OWD measurements",
      "ja": "var_est OWD測定の変動性の尺度"
    },
    {
      "indent": 6,
      "text": "var_base_T a variable used as an intermediate step in calculating var_est",
      "ja": "var_base_T var_estを計算する際の中間ステップとして使用される変数"
    },
    {
      "indent": 6,
      "text": "freq_est a measure of low-frequency oscillation in the OWD measurements",
      "ja": "freq_est OWD測定における低周波振動の測定"
    },
    {
      "indent": 6,
      "text": "pkt_loss a measure of the proportion of packets lost",
      "ja": "pkt_lossは、失われたパケットの割合の指標"
    },
    {
      "indent": 6,
      "text": "p_l, p_f, p_mad, c_s, c_h, p_s, p_d, p_v various thresholds used in the mechanism",
      "ja": "p_l、p_f、p_mad、c_s、c_h、p_s、p_d、p_vメカニズムで使用されるさまざまなしきい値"
    },
    {
      "indent": 6,
      "text": "M and F number of values related to N",
      "ja": "Nに関連するMおよびF個の値"
    },
    {
      "indent": 0,
      "text": "2.1. Parameters and Their Effects",
      "section_title": true,
      "ja": "2.1. パラメータとその影響"
    },
    {
      "indent": 3,
      "text": "T T should be long enough so that there are enough packets received during T for a useful estimate of the short-term mean OWD and variation statistics. Making T too large can limit the efficacy of freq_est. It will also increase the response time of the mechanism. Making T too small will make the metrics noisier.",
      "ja": "T Tは、短期平均OWDおよび変動統計の有用な推定のためにT中に十分なパケットが受信されるように、十分に長くなければなりません。 Tを大きくしすぎると、freq_estの効果が制限される可能性があります。また、メカニズムの応答時間も長くなります。 Tを小さくしすぎると、メトリックのノイズが大きくなります。"
    },
    {
      "indent": 3,
      "text": "N and M N should be large enough to provide a stable estimate of oscillations in OWD. Often, M=N is just fine, though having M<N may be beneficial in certain circumstances. M*T needs to be long enough to provide stable estimates of skewness and MAD.",
      "ja": "NおよびM Nは、OWDの振動の安定した推定を提供するのに十分な大きさにする必要があります。多くの場合、M = Nで十分ですが、特定の状況ではM <Nにすることが有益な場合があります。 M * Tは、歪度とMADの安定した推定を提供するのに十分な長さである必要があります。"
    },
    {
      "indent": 3,
      "text": "F F determines the number of intervals over which statistics are considered to be equally weighted. When F=M, recent and older measurements are considered equal. Making F<M can increase the responsiveness of the SBD mechanism. If F is too small, statistics will be too noisy.",
      "ja": "F Fは、統計が均等に重み付けされていると見なされる間隔の数を決定します。 F = Mの場合、最近の測定値と古い測定値は等しいと見なされます。 F <Mにすると、SBDメカニズムの応答性が向上します。 Fが小さすぎる場合、統計はノイズが多すぎます。"
    },
    {
      "indent": 3,
      "text": "c_s c_s is the threshold in skew_est used for determining whether a flow is transiting a bottleneck or not. Lower values of c_s require bottlenecks to be more congested to be considered for grouping by the mechanism. c_s should be set within the range of +0.2 to -0.1 -- low enough so that lightly loaded paths do not give a false indication.",
      "ja": "c_s c_sは、フローがボトルネックを通過しているかどうかを判断するために使用されるskew_estのしきい値です。 c_sの値が低いほど、メカニズムによるグループ化を検討するためにボトルネックをより密集させる必要があります。 c_sは+0.2から-0.1の範囲内で設定する必要があります-負荷が軽いパスが誤った指示を与えないように十分に低くします。"
    },
    {
      "indent": 3,
      "text": "p_l p_l is the threshold in pkt_loss used for determining whether a flow is transiting a bottleneck or not. When pkt_loss is high, it becomes a better indicator of congestion than skew_est.",
      "ja": "p_l p_lは、フローがボトルネックを通過しているかどうかを判別するために使用されるpkt_lossのしきい値です。 pkt_lossが高い場合、輻輳の指標としてskew_estよりも優れています。"
    },
    {
      "indent": 3,
      "text": "c_h c_h adds hysteresis to the bottleneck determination. It should be large enough to avoid constant switching in the determination but low enough to ensure that grouping is not attempted when there is no bottleneck and the delay and loss signals cannot be relied upon.",
      "ja": "c_h c_hは、ボトルネックの決定にヒステリシスを追加します。これは、決定での絶え間ない切り替えを回避するのに十分な大きさである必要がありますが、ボトルネックがなく、遅延信号と損失信号に依存できない場合にグループ化が試行されないように十分に低くなければなりません。"
    },
    {
      "indent": 3,
      "text": "p_v p_v determines the sensitivity of freq_est to noise. Making it smaller will yield higher but noisier values for freq_est. Making it too large will render it ineffective for determining groups.",
      "ja": "p_v p_vは、freq_estのノイズに対する感度を決定します。小さくすると、freq_estの値は高くなりますが、ノイズが大きくなります。大きくしすぎると、グループの決定に効果がなくなります。"
    },
    {
      "indent": 3,
      "text": "p_* Flows are separated when the skew_est|var_est|freq_est|pkt_loss measure is greater than p_s|p_mad|p_f|p_d. Adjusting these is a compromise between false grouping of flows that do not share a bottleneck and false splitting of flows that do. Making them larger can help if the measures are very noisy, but reducing the noise in the statistical measures by adjusting T and N|M may be a better solution.",
      "ja": "p_ * skew_est | var_est | freq_est | pkt_lossメジャーがp_s | p_mad | p_f | p_dより大きい場合、フローは分離されます。これらの調整は、ボトルネックを共有しないフローの誤ったグループ化と、フローを共有するフローの誤った分割との間の妥協です。それらを大きくすることは、測定値が非常に騒々しい場合に役立ちますが、TとN | Mを調整して統計測定値のノイズを減らすことは、より良い解決策になる場合があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Recommended Parameter Values",
      "section_title": true,
      "ja": "2.2. 推奨パラメーター値"
    },
    {
      "indent": 3,
      "text": "[Hayes-LCN14] uses T=350ms and N=50. The other parameters have been tightened to reflect minor enhancements to the algorithm outlined in Section 4: c_s=0.1, p_f=p_d=0.1, p_s=0.15, p_mad=0.1, p_v=0.7. M=30, F=20, and c_h=0.3 are additional parameters defined in that document. These are values that seem to work well over a wide range of practical Internet conditions.",
      "ja": "[Hayes-LCN14]はT = 350msとN = 50を使用します。他のパラメータは、セクション4で概説されているアルゴリズムのマイナーな機能強化を反映するように引き締められました。c_s= 0.1、p_f = p_d = 0.1、p_s = 0.15、p_mad = 0.1、p_v = 0.7。 M = 30、F = 20、およびc_h = 0.3は、そのドキュメントで定義されている追加のパラメーターです。これらは、実際のインターネット条件の広い範囲でうまく機能すると思われる値です。"
    },
    {
      "indent": 0,
      "text": "3. Mechanism",
      "section_title": true,
      "ja": "3. 機構"
    },
    {
      "indent": 3,
      "text": "The mechanism described in this document is based on the observation that when flows traverse a common bottleneck, each flow's distribution of packet delay measurements has similar shape characteristics. These shape characteristics are described using three key summary statistics --",
      "ja": "このドキュメントで説明されているメカニズムは、フローが共通のボトルネックを通過するとき、各フローのパケット遅延測定値の分布が同様の形状特性を持っているという観察に基づいています。これらの形状特性は、3つの主要な要約統計を使用して記述されます-"
    },
    {
      "indent": 3,
      "text": "1. variability estimate (var_est; see Section 3.2.3)",
      "ja": "1. 変動推定（var_est;セクション3.2.3を参照）"
    },
    {
      "indent": 3,
      "text": "2. skewness estimate (skew_est; see Section 3.2.2)",
      "ja": "2. 歪度推定（skew_est;セクション3.2.2を参照）"
    },
    {
      "indent": 3,
      "text": "3. oscillation estimate (freq_est; see Section 3.2.4)",
      "ja": "3. 振動推定（freq_est;セクション3.2.4を参照）"
    },
    {
      "indent": 3,
      "text": "-- with packet loss (pkt_loss; see Section 3.2.5) used as a supplementary statistic.",
      "ja": "-補足統計として使用されるパケット損失（pkt_loss;セクション3.2.5を参照）。"
    },
    {
      "indent": 3,
      "text": "Summary statistics help to address both the noise and the path lag problems by describing the general shape over a relatively long period of time. Each summary statistic portrays a \"view\" of the bottleneck link characteristics, and when used together, they provide a robust discrimination for grouping flows. An RTP media device may be both a sender and a receiver. SBD can be performed at either a sender or a receiver, or both.",
      "ja": "要約統計は、比較的長い期間にわたる一般的な形状を記述することにより、ノイズとパスラグの両方の問題に対処するのに役立ちます。各要約統計は、ボトルネックリンク特性の「ビュー」を描写し、一緒に使用すると、フローをグループ化するための強力な識別を提供します。 RTPメディアデバイスは、送信者と受信者の両方になる場合があります。 SBDは、送信側または受信側、あるいはその両方で実行できます。"
    },
    {
      "indent": 3,
      "text": "In Figure 1, there are two possible locations for shared bottleneck detection: the sender side and the receiver side.",
      "ja": "図1では、共有ボトルネック検出の2つの可能な場所があります。送信側と受信側です。"
    },
    {
      "indent": 25,
      "text": "         +----+\n         | H2 |\n         +----+\n            |\n            | L2\n            |\n+----+  L1  |  L3  +----+\n| H1 |------|------| H3 |\n+----+             +----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A network with three hosts (H1, H2, H3) and three links (L1, L2, L3)",
      "ja": "3つのホスト（H1、H2、H3）と3つのリンク（L1、L2、L3）を持つネットワーク"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "1. Sender side: Consider a situation where host H1 sends media streams to hosts H2 and H3, and L1 is a shared bottleneck. H2 and H3 measure the OWD and packet loss and periodically send either this raw data or the calculated summary statistics to H1 every T. H1, having this knowledge, can determine the shared bottleneck and accordingly control the send rates.",
      "ja": "1. 送信側：ホストH1がホストH2およびH3にメディアストリームを送信し、L1が共有ボトルネックである状況を考えます。 H2とH3はOWDとパケット損失を測定し、この生データまたは計算された要約統計のいずれかをTごとにH1に定期的に送信します。H1はこの知識を持っているため、共有ボトルネックを特定し、それに応じて送信レートを制御できます。"
    },
    {
      "indent": 3,
      "text": "2. Receiver side: Consider that H2 is also sending media to H3, and L3 is a shared bottleneck. If H3 sends summary statistics to H1 and H2, neither H1 nor H2 alone obtains enough knowledge to detect this shared bottleneck; H3 can, however, determine it by combining the summary statistics related to H1 and H2, respectively.",
      "ja": "2. 受信側：H2もH3にメディアを送信しており、L3が共有ボトルネックであることを考慮してください。 H3がサマリー統計をH1とH2に送信する場合、H1もH2もこの共有ボトルネックを検出するのに十分な知識を取得しません。ただし、H3は、H1とH2にそれぞれ関連する要約統計を組み合わせることで、それを決定できます。"
    },
    {
      "indent": 0,
      "text": "3.1. SBD Feedback Requirements",
      "section_title": true,
      "ja": "3.1. SBDフィードバック要件"
    },
    {
      "indent": 3,
      "text": "There are three possible scenarios, each with different feedback requirements:",
      "ja": "3つの可能なシナリオがあり、それぞれ異なるフィードバック要件があります。"
    },
    {
      "indent": 3,
      "text": "1. Both summary statistic calculations and SBD are performed at senders only. When sender-based congestion control is implemented, this method is RECOMMENDED.",
      "ja": "1. 要約統計量計算とSBDの両方が送信者でのみ実行されます。送信者ベースの輻輳制御が実装されている場合、このメソッドは推奨されます。"
    },
    {
      "indent": 3,
      "text": "2. Summary statistics are calculated on the receivers, and SBD is performed at the senders.",
      "ja": "2. 要約統計量は受信側で計算され、SBDは送信側で実行されます。"
    },
    {
      "indent": 3,
      "text": "3. Summary statistic calculations are performed on receivers, and SBD is performed at both senders and receivers (beyond the scope of this document, but allows cooperative detection of bottlenecks).",
      "ja": "3. 要約統計量の計算は受信側で実行され、SBDは送信側と受信側の両方で実行されます（このドキュメントの範囲を超えていますが、ボトルネックを協調して検出できます）。"
    },
    {
      "indent": 3,
      "text": "All three possibilities are discussed for completeness in this document; however, it is expected that feedback will take the form of scenario 1 and operate in conjunction with sender-based congestion control mechanisms.",
      "ja": "このドキュメントでは、3つの可能性すべてを完全にするために説明しています。ただし、フィードバックはシナリオ1の形式をとり、送信者ベースの輻輳制御メカニズムと連携して動作することが予想されます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Feedback When All the Logic Is Placed at the Sender",
      "section_title": true,
      "ja": "3.1.1. すべてのロジックが送信側に配置されたときのフィードバック"
    },
    {
      "indent": 3,
      "text": "Having the sender calculate the summary statistics and determine the shared bottlenecks based on them has the advantage of placing most of the functionality in one place -- the sender.",
      "ja": "送信者に要約統計量を計算させ、それらに基づいて共有ボトルネックを決定させると、ほとんどの機能を1つの場所（送信者）に配置できるという利点があります。"
    },
    {
      "indent": 3,
      "text": "For every packet, the sender requires accurate relative OWD measurements of adequate precision, along with an indication of lost packets (or the proportion of packets lost over an interval). A method to provide such measurement data with the RTP Control Protocol (RTCP) is described in [RTCP-CC-FEEDBACK].",
      "ja": "送信者は、すべてのパケットについて、失われたパケット（または間隔で失われたパケットの割合）を示すとともに、適切な精度の正確な相対OWD測定を必要とします。このような測定データをRTP制御プロトコル（RTCP）で提供する方法は、[RTCP-CC-FEEDBACK]で説明されています。"
    },
    {
      "indent": 3,
      "text": "Sums, var_base_T, and skew_base_T are calculated incrementally as relative OWD measurements are determined from the feedback messages. When the mechanism has received sufficient measurements to cover the base time interval T for all flows, the summary statistics (see Section 3.2) are calculated for that T interval and flows are grouped (see Section 3.3.1). The exact timing of these calculations will depend on the frequency of the feedback message.",
      "ja": "合計、var_base_T、およびskew_base_Tは、フィードバックメッセージから相対OWD測定値が決定されると、増分的に計算されます。メカニズムがすべてのフローの基本時間間隔Tをカバーするのに十分な測定値を受信すると、そのT間隔について要約統計（セクション3.2を参照）が計算され、フローがグループ化されます（セクション3.3.1を参照）。これらの計算の正確なタイミングは、フィードバックメッセージの頻度によって異なります。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Feedback When the Statistics Are Calculated at the Receiver and SBD Is Performed at the Sender",
      "ja": "3.1.2. 統計が受信側で計算され、SBDが送信側で実行されるときのフィードバック"
    },
    {
      "indent": 3,
      "text": "This scenario minimizes feedback but requires receivers to send selected summary statistics at an agreed-upon regular interval. We envisage the following exchange of information to initialize the system:",
      "ja": "このシナリオでは、フィードバックを最小限に抑えますが、受信者は、合意された定期的な間隔で選択した要約統計を送信する必要があります。システムを初期化するために、以下の情報交換を想定しています。"
    },
    {
      "indent": 3,
      "text": "o An initialization message from the sender to the receiver will contain the following information:",
      "ja": "o 送信者から受信者への初期化メッセージには、次の情報が含まれます。"
    },
    {
      "indent": 6,
      "text": "* A list of which key metrics should be collected and relayed back to the sender out of a possibly extensible set (pkt_loss, var_est, skew_est, and freq_est). The grouping algorithm described in this document requires all four of these metrics, and receivers MUST be able to provide them, but future algorithms may be able to exploit other metrics (e.g., metrics based on explicit network signals).",
      "ja": "* 拡張可能なセット（pkt_loss、var_est、skew_est、freq_est）から、主要なメトリックを収集して送信者に中継する必要があるリスト。このドキュメントで説明されているグループ化アルゴリズムは、これらの4つのメトリックすべてを必要とし、受信者はそれらを提供できなければなりませんが、将来のアルゴリズムは他のメトリック（たとえば、明示的なネットワーク信号に基づくメトリック）を利用できる可能性があります。"
    },
    {
      "indent": 6,
      "text": "* The values of T, N, and M, and the necessary resolution and precision of the relayed statistics.",
      "ja": "* T、N、およびMの値、およびリレーされた統計に必要な解像度と精度。"
    },
    {
      "indent": 3,
      "text": "o A response message from the receiver acknowledges this message with a list of key metrics it supports (subset of the sender's list) and is able to relay back to the sender.",
      "ja": "o 受信者からの応答メッセージは、サポートする主要なメトリックのリスト（送信者のリストのサブセット）を使用してこのメ​​ッセージを確認し、送信者にリレーバックできます。"
    },
    {
      "indent": 3,
      "text": "This initialization exchange may be repeated to finalize the set of metrics that will be used. All agreed-upon metrics need to be supported by all receivers. It is also recommended that an identifier for the SBD algorithm version be included in the initialization message from the sender, so that potential advances in SBD technology can be easily deployed. For reference, the mechanism outlined in this document has the identifier \"SBD=01\".",
      "ja": "この初期化交換は、使用されるメトリックのセットを確定するために繰り返される場合があります。すべての合意されたメトリックは、すべての受信者によってサポートされる必要があります。また、SBDアルゴリズムのバージョンの識別子を送信者からの初期化メッセージに含めることをお勧めします。これにより、SBDテクノロジの潜在的な進歩を簡単に展開できます。参考までに、このドキュメントで説明するメカニズムの識別子は「SBD = 01」です。"
    },
    {
      "indent": 3,
      "text": "After initialization, the agreed-upon summary statistics are fed back to the sender (nominally every T).",
      "ja": "初期化後、合意された要約統計が送信者にフィードバックされます（通常はすべてのT）。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Feedback When Bottlenecks Can Be Determined at Both Senders and Receivers",
      "ja": "3.1.3. 送信者と受信者の両方でボトルネックを特定できる場合のフィードバック"
    },
    {
      "indent": 3,
      "text": "This type of mechanism is currently beyond the scope of the SBD algorithm described in this document. It is mentioned here to ensure that sender/receiver cooperative shared bottleneck determination mechanisms that are more advanced remain possible in the future.",
      "ja": "このタイプのメカニズムは現在、このドキュメントで説明されているSBDアルゴリズムの範囲を超えています。ここでは、より高度な送信側/受信側の協調共有ボトルネック決定メカニズムが将来も可能であることを保証するために言及します。"
    },
    {
      "indent": 3,
      "text": "It is envisaged that such a mechanism would be initialized in a manner similar to that described in Section 3.1.2.",
      "ja": "このようなメカニズムは、セクション3.1.2で説明されているのと同様の方法で初期化されることが想定されています。"
    },
    {
      "indent": 3,
      "text": "After initialization, both summary statistics and shared bottleneck determinations should be exchanged, nominally every T.",
      "ja": "初期化後、要約統計と共有ボトルネック決定の両方を、名目上すべてのTで交換する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Key Metrics and Their Calculation",
      "section_title": true,
      "ja": "3.2. 主要な指標とその計算"
    },
    {
      "indent": 3,
      "text": "Measurements are calculated over a base interval (T) and summarized over N or M such intervals. All summary statistics can be calculated incrementally.",
      "ja": "測定値は基本間隔（T）で計算され、NまたはMのそのような間隔で要約されます。すべての要約統計量は段階的に計算できます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Mean Delay",
      "section_title": true,
      "ja": "3.2.1. 平均遅延"
    },
    {
      "indent": 3,
      "text": "The mean delay is not a useful signal for comparisons between flows, since flows may traverse quite different paths and clocks will not necessarily be synchronized. However, it is a base measure for the three summary statistics. The mean delay, E_T(OWD), is the average OWD measured over T.",
      "ja": "フローはまったく異なるパスを通過する可能性があり、クロックは必ずしも同期されないため、平均遅延はフロー間の比較に有用な信号ではありません。ただし、これは3つの要約統計量の基本的な指標です。平均遅延E_T（OWD）は、Tにわたって測定された平均OWDです。"
    },
    {
      "indent": 3,
      "text": "To facilitate the other calculations, the last N E_T(OWD) values will need to be stored in a cyclic buffer along with the moving average of E_T(OWD):",
      "ja": "他の計算を容易にするために、最後のN個のE_T（OWD）値は、E_T（OWD）の移動平均とともに循環バッファーに格納する必要があります。"
    },
    {
      "indent": 6,
      "text": "mean_delay = E_M(E_T(OWD)) = sum_M(E_T(OWD)) / M",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where M <= N. Setting M to be less than N allows the mechanism to be more responsive to changes, but potentially at the expense of a higher error rate (see Section 4.1 for a discussion on improving the responsiveness of the mechanism).",
      "ja": "ここで、M <= Nです。MをN未満に設定すると、メカニズムの変更に対する応答性が高くなりますが、エラー率が高くなります（メカニズムの応答性の向上に関する説明については、セクション4.1を参照）。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Skewness Estimate",
      "section_title": true,
      "ja": "3.2.2. 歪度推定"
    },
    {
      "indent": 3,
      "text": "Skewness is difficult to calculate efficiently and accurately. Ideally, it should be calculated over the entire period (M*T) from the mean OWD over that period. However, this would require storing every delay measurement over the period. Instead, an estimate is made over M*T based on a calculation every T using the previous T's calculation of mean_delay.",
      "ja": "歪度を効率的かつ正確に計算することは困難です。理想的には、期間全体の平均OWDから期間全体（M * T）で計算する必要があります。ただし、これには期間全体のすべての遅延測定値を保存する必要があります。代わりに、前のTのmean_delayの計算を使用して、Tごとの計算に基づいてM * Tで推定が行われます。"
    },
    {
      "indent": 3,
      "text": "The base for the skewness calculation is estimated using a counter initialized every T. It increments for OWD samples below the mean and decrements for OWD above the mean. So, for each OWD sample:",
      "ja": "歪度計算のベースは、Tごとに初期化されたカウンターを使用して推定されます。これは、平均を下回るOWDサンプルで増加し、平均を上回るOWDで減少します。したがって、OWDサンプルごとに、"
    },
    {
      "indent": 6,
      "text": "if (OWD < mean_delay) skew_base_T++",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (OWD > mean_delay) skew_base_T--",
      "ja": "if（OWD> mean_delay）skew_base_T--"
    },
    {
      "indent": 3,
      "text": "mean_delay does not include the mean of the current T interval to enable it to be calculated iteratively.",
      "ja": "mean_delayには、現在のT間隔の平均が含まれていないため、反復的に計算できます。"
    },
    {
      "indent": 3,
      "text": "skew_est = sum_MT(skew_base_T) / num_MT(OWD)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "where skew_est is a number between -1 and 1.",
      "ja": "ここで、skew_estは-1から1までの数値です。"
    },
    {
      "indent": 3,
      "text": "Note: Care must be taken when implementing the comparisons to ensure that rounding does not bias skew_est. It is important that the mean is calculated with a higher precision than the samples.",
      "ja": "注：比較を実装するときは、丸めによってskew_estが偏らないように注意する必要があります。平均がサンプルよりも高い精度で計算されることが重要です。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Variability Estimate",
      "section_title": true,
      "ja": "3.2.3. 変動推定"
    },
    {
      "indent": 3,
      "text": "Mean Absolute Deviation (MAD) is a robust variability measure that copes well with different send rates. It can be implemented in an online manner as follows:",
      "ja": "平均絶対偏差（MAD）は、さまざまな送信レートに適切に対処できる堅牢な変動性の尺度です。次のようにオンラインで実装できます。"
    },
    {
      "indent": 6,
      "text": "var_base_T = sum_T(|OWD - E_T(OWD)|)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "where",
      "ja": "ただし"
    },
    {
      "indent": 12,
      "text": "|x| is the absolute value of x",
      "ja": "| x | xの絶対値"
    },
    {
      "indent": 12,
      "text": "E_T(OWD) is the mean OWD calculated in the previous T",
      "ja": "E_T（OWD）は、前のTで計算された平均OWDです"
    },
    {
      "indent": 6,
      "text": "var_est = MAD_MT = sum_MT(var_base_T) / num_MT(OWD)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.4. Oscillation Estimate",
      "section_title": true,
      "ja": "3.2.4. 振動推定"
    },
    {
      "indent": 3,
      "text": "An estimate of the low-frequency oscillation of the delay signal is calculated by counting and normalizing the significant mean, E_T(OWD), crossings of mean_delay:",
      "ja": "遅延信号の低周波振動の推定値は、mean_delayの交差の有意平均E_T（OWD）をカウントして正規化することによって計算されます。"
    },
    {
      "indent": 6,
      "text": "freq_est = number_of_crossings / N",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "where we define a significant mean crossing as a crossing that extends p_v * var_est from mean_delay. In our experiments, we have found that p_v = 0.7 is a good value.",
      "ja": "ここで、有意平均交差を、mean_delayからp_v * var_estを拡張する交差として定義します。私たちの実験では、p_v = 0.7が適切な値であることがわかりました。"
    },
    {
      "indent": 3,
      "text": "freq_est is a number between 0 and 1. freq_est can be approximated incrementally as follows:",
      "ja": "freq_estは0〜1の数値です。freq_estは次のように漸増的に概算できます。"
    },
    {
      "indent": 3,
      "text": "o With each new calculation of E_T(OWD), a decision is made as to whether this value of E_T(OWD) significantly crosses the current long-term mean, mean_delay, with respect to the previous significant mean crossing.",
      "ja": "o E_T（OWD）の新しい計算ごとに、このE_T（OWD）の値が、以前の有意な平均交差に対して、現在の長期平均であるmean_delayを大幅に交差するかどうかについて決定が行われます。"
    },
    {
      "indent": 3,
      "text": "o A cyclic buffer, last_N_crossings, records a 1 if there is a significant mean crossing; otherwise, it records a 0.",
      "ja": "o 循環バッファーlast_N_crossingsは、有意な平均交差がある場合、1を記録します。それ以外の場合は、0を記録します。"
    },
    {
      "indent": 3,
      "text": "o The counter, number_of_crossings, is incremented when there is a significant mean crossing and decremented when a non-zero value is removed from the last_N_crossings.",
      "ja": "o カウンターnumber_of_crossingsは、有意な平均交差がある場合に増加し、0以外の値がlast_N_crossingsから削除される場合に減少します。"
    },
    {
      "indent": 3,
      "text": "This approximation of freq_est was not used in [Hayes-LCN14], which calculated freq_est every T using the current E_N(E_T(OWD)). Our tests show that this approximation of freq_est yields results that are almost identical to when the full calculation is performed every T.",
      "ja": "このfreq_estの近似値は、現在のE_N（E_T（OWD））を使用してTごとにfreq_estを計算する[Hayes-LCN14]では使用されませんでした。私たちのテストでは、freq_estのこの近似により、Tごとに完全な計算を実行した場合とほぼ同じ結果が得られることが示されています。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Packet Loss",
      "section_title": true,
      "ja": "3.2.5. パケットロス"
    },
    {
      "indent": 3,
      "text": "The proportion of packets lost over the period NT is used as a supplementary measure:",
      "ja": "期間NTで失われたパケットの割合は、補足的な指標として使用されます。"
    },
    {
      "indent": 6,
      "text": "pkt_loss = sum_NT(lost packets) / sum_NT(total packets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: When pkt_loss is low, it is very variable; however, when pkt_loss is high, it becomes a stable measure for making grouping decisions.",
      "ja": "注：pkt_lossが低い場合、非常に変動します。ただし、pkt_lossが高い場合、グループ化の決定を行うための安定した指標になります。"
    },
    {
      "indent": 0,
      "text": "3.3. Flow Grouping",
      "section_title": true,
      "ja": "3.3. フローのグループ化"
    },
    {
      "indent": 0,
      "text": "3.3.1. Flow-Grouping Algorithm",
      "section_title": true,
      "ja": "3.3.1. フローグループ化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The following grouping algorithm is RECOMMENDED for the use of SBD with coupled congestion control for RTP media [RTP-COUPLED-CC] and is sufficient and efficient for small to moderate numbers of flows. For very large numbers of flows (e.g., hundreds), a more complex clustering algorithm may be substituted.",
      "ja": "次のグループ化アルゴリズムは、RTPメディア[RTP-COUPLED-CC]の結合輻輳制御を備えたSBDの使用に推奨され、フローの数が少ないから中程度の場合には十分かつ効率的です。非常に多数のフロー（たとえば、数百）の場合は、より複雑なクラスタリングアルゴリズムに置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "Since no single metric is precise enough to group flows (due to noise), the algorithm uses multiple metrics. Each metric offers a different \"view\" of the bottleneck link characteristics, and used together they enable a more precise grouping of flows than would otherwise be possible.",
      "ja": "（ノイズのため）フローをグループ化するほど正確な単一のメトリックはないため、アルゴリズムは複数のメトリックを使用します。各メトリックは、ボトルネックリンク特性の異なる「ビュー」を提供し、それらを一緒に使用すると、他の場合よりも正確なフローのグループ化が可能になります。"
    },
    {
      "indent": 3,
      "text": "Flows determined to be transiting a bottleneck are successively divided into groups based on freq_est, var_est, skew_est, and pkt_loss.",
      "ja": "ボトルネックを通過していると判断されたフローは、freq_est、var_est、skew_est、pkt_lossに基づいて、グループに順次分割されます。"
    },
    {
      "indent": 3,
      "text": "The first step is to determine which flows are transiting a bottleneck. This is important, since if a flow is not transiting a bottleneck its delay-based metrics will not describe the bottleneck but will instead describe the \"noise\" from the rest of the path. Skewness, with the proportion of packet loss as a supplementary measure, is used to do this:",
      "ja": "最初のステップは、どのフローがボトルネックを通過しているかを判別することです。フローがボトルネックを通過していない場合、フローの遅延ベースのメトリックはボトルネックを記述せず、代わりにパスの残りからの「ノイズ」を記述するため、これは重要です。これを行うために、補足的な手段としてパケット損失の割合を伴う歪度が使用されます。"
    },
    {
      "indent": 3,
      "text": "1. Grouping will be performed on flows that are inferred to be traversing a bottleneck by:",
      "ja": "1. グループ化は、次の方法でボトルネックを通過していると推定されるフローで実行されます。"
    },
    {
      "indent": 10,
      "text": "skew_est < c_s",
      "ja": "skew_est <c_s"
    },
    {
      "indent": 13,
      "text": "|| ( skew_est < c_h & PB ) || pkt_loss > p_l",
      "ja": "|| （skew_est <c_h＆PB）|| pkt_loss> p_l"
    },
    {
      "indent": 7,
      "text": "The parameter c_s controls how sensitive the mechanism is in detecting a bottleneck. c_s = 0.0 was used in [Hayes-LCN14]. A value of c_s = 0.1 is a little more sensitive, and c_s = -0.1 is a little less sensitive. c_h controls the hysteresis on flows that were grouped as transiting a bottleneck the previous time. If the test result is TRUE, PB=TRUE; otherwise, PB=FALSE.",
      "ja": "パラメータc_sは、メカニズムがボトルネックを検出する際の感度を制御します。 c_s = 0.0は[Hayes-LCN14]で使用されました。 c_s = 0.1の値は少し感度が高く、c_s = -0.1は少し感度が低くなります。 c_hは、前回ボトルネックを通過するものとしてグループ化されたフローのヒステリシスを制御します。テスト結果がTRUEの場合、PB = TRUE。それ以外の場合、PB = FALSE。"
    },
    {
      "indent": 3,
      "text": "These flows (i.e., flows transiting a bottleneck) are then progressively divided into groups based on the freq_est, var_est, and skew_est summary statistics. The process proceeds according to the following steps:",
      "ja": "これらのフロー（つまり、ボトルネックを通過するフロー）は、freq_est、var_est、およびskew_estサマリー統計に基づいて、グループに段階的に分割されます。プロセスは次のステップに従って進行します。"
    },
    {
      "indent": 3,
      "text": "2. Group flows whose difference in sorted freq_est is less than a threshold:",
      "ja": "2. 並べ替えられたfreq_estの差がしきい値より小さいグループフロー："
    },
    {
      "indent": 10,
      "text": "diff(freq_est) < p_f",
      "ja": "diff（freq_est）<p_f"
    },
    {
      "indent": 3,
      "text": "3. Subdivide the groups obtained in step 2 by grouping flows whose difference in sorted E_M(var_est) (highest to lowest) is less than a threshold:",
      "ja": "3. ステップ2で取得したグループを、ソートされたE_M（var_est）の差（最大から最小）がしきい値未満であるフローをグループ化することにより、さらに分割します。"
    },
    {
      "indent": 10,
      "text": "diff(var_est) < (p_mad * var_est)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "The threshold, (p_mad * var_est), is with respect to the highest value in the difference.",
      "ja": "しきい値（p_mad * var_est）は、差の最大値を基準にしています。"
    },
    {
      "indent": 3,
      "text": "4. Subdivide the groups obtained in step 3 by grouping flows whose difference in sorted skew_est is less than a threshold:",
      "ja": "4. ソートされたskew_estの差がしきい値未満であるフローをグループ化することにより、手順3で取得したグループを細分割します。"
    },
    {
      "indent": 10,
      "text": "diff(skew_est) < p_s",
      "ja": "diff（skew_est）<p_s"
    },
    {
      "indent": 3,
      "text": "5. When packet loss is high enough to be reliable (pkt_loss > p_l), subdivide the groups obtained in step 4 by grouping flows whose difference is less than a threshold:",
      "ja": "5. パケット損失が信頼できるほど十分に高い場合（pkt_loss> p_l）、ステップ4で取得したグループを、しきい値未満の差を持つフローをグループ化することによって細分割します。"
    },
    {
      "indent": 10,
      "text": "diff(pkt_loss) < (p_d * pkt_loss)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "The threshold, (p_d * pkt_loss), is with respect to the highest value in the difference.",
      "ja": "しきい値（p_d * pkt_loss）は、差の最大値を基準にしています。"
    },
    {
      "indent": 3,
      "text": "This procedure involves sorting estimates from highest to lowest. It is simple to implement and is efficient for small numbers of flows (up to 10-20). Figure 2 illustrates this algorithm.",
      "ja": "この手順では、推定値を最高から最低に並べ替えます。実装は簡単で、少数のフロー（最大10〜20）に対して効率的です。図2は、このアルゴリズムを示しています。"
    },
    {
      "indent": 3,
      "text": "                                     *********\n                                     * Flows *\n                                     ***.**.**\n                                       /    '\n                                      /     '--.\n                                     /          \\\n                                .---v--.    .----v---.\n1. Flows traversing             | Cong |    | UnCong |\n   a bottleneck                 '-.--.-'    '--------'\n                                 /    \\\n                                /      \\\n                               /        \\\n                           .--v--.       v-----.\n2. Divide by               | g_1 |  ...  | g_n |\n   freq_est                '---.-.       '----..\n                              /   \\          /  \\\n                             /     '--.     v    '------.\n                            /          \\                 \\\n                      .----v-.        .-v----.        .---v--.\n3. Divide by          | g_1a |  ...   | g_1z |   ...  | g_nz |\n   var_est            '---.-.'        '-----..        '-.-.--'\n                         /   \\             /  \\        /  |\n                        /     '-----.     v    v      v   |\n                       /             \\                    |\n                    .-v-----.       .-v-----.         .---v---.\n4. Divide by        | g_1ai |  ...  | g_1ax |   ...   | g_nzx |\n   skew_est         '----.-.'       '------..         '-.-.---'\n                        /   \\             /  \\         /  |\n                       /     '--.        v    v       v   |\n                      /          \\                        |\n               .-----v--.       .-v------.           .----v---.\n5. Divide by   | g_1aiA |  ...  | g_1aiZ |    ...    | g_nzxZ |\n   pkt_loss    '--------'       '--------'           '--------'\n   (when applicable)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Simple grouping algorithm",
      "ja": "単純なグループ化アルゴリズム"
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 0,
      "text": "3.3.2. Using the Flow Group Signal",
      "section_title": true,
      "ja": "3.3.2. フローグループ信号の使用"
    },
    {
      "indent": 3,
      "text": "Grouping decisions can be made every T from the second T; however, they will not attain their full design accuracy until after the 2*Nth T interval. We recommend that grouping decisions not be made until 2*M T intervals.",
      "ja": "グループ化の決定は、2番目のTからTごとに行うことができます。ただし、2 * N番目のT間隔が経過するまで、設計の完全な精度は得られません。グループ化の決定は、2 * M T間隔になるまで行わないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Network conditions, and even the congestion controllers, can cause bottlenecks to fluctuate. A coupled congestion controller MAY decide only to couple groups that remain stable, say grouped together 90% of the time, depending on its objectives. Recommendations concerning this are beyond the scope of this document and will be specific to the coupled congestion controller's objectives.",
      "ja": "ネットワークの状態、さらには輻輳コントローラーでさえ、ボトルネックが変動する可能性があります。結合された輻輳コントローラーは、その目的に応じて、安定したままのグループ、つまり90％の時間でグループ化されるグループのみを結合することを決定する場合があります。これに関する推奨事項は、このドキュメントの範囲を超えており、結合された輻輳コントローラーの目的に固有のものです。"
    },
    {
      "indent": 0,
      "text": "4. Enhancements to the Basic SBD Algorithm",
      "section_title": true,
      "ja": "4. 基本的なSBDアルゴリズムの機能強化"
    },
    {
      "indent": 3,
      "text": "The SBD algorithm as specified in Section 3 was found to work well for a broad variety of conditions. The following enhancements to the basic mechanisms have been found to significantly improve the algorithm's performance under some circumstances and SHOULD be implemented. These \"tweaks\" are described separately to keep the main description succinct.",
      "ja": "セクション3で指定されているSBDアルゴリズムは、さまざまな条件でうまく機能することがわかっています。以下の基本メカニズムの拡張により、状況によってはアルゴリズムのパフォーマンスが大幅に向上することがわかっているため、実装する必要があります。これらの「調整」は、メインの説明を簡潔にするために個別に説明されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Reducing Lag and Improving Responsiveness",
      "section_title": true,
      "ja": "4.1. ラグの削減と応答性の向上"
    },
    {
      "indent": 3,
      "text": "This section describes how to improve the responsiveness of the basic algorithm.",
      "ja": "このセクションでは、基本的なアルゴリズムの応答性を向上させる方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Measurement-based shared bottleneck detection makes decisions in the present based on what has been measured in the past. This means that there is always a lag in responding to changing conditions. This mechanism is based on summary statistics taken over (N*T) seconds. This mechanism can be made more responsive to changing conditions by:",
      "ja": "測定ベースの共有ボトルネック検出は、過去に測定されたものに基づいて現在の決定を行います。これは、変化する状況への対応に常に遅れがあることを意味します。このメカニズムは、（N * T）秒かけて取得された要約統計に基づいています。このメカニズムは、次のようにすることで、変化する状態に対してより敏感にすることができます。"
    },
    {
      "indent": 3,
      "text": "1. Reducing N and/or M, but at the expense of having metrics that are less accurate, and/or",
      "ja": "1. Nおよび/またはMを削減するが、精度の低いメトリックを使用することを犠牲にして、および/または"
    },
    {
      "indent": 3,
      "text": "2. Exploiting the fact that measurements that are more recent are more valuable than older measurements and weighting them accordingly.",
      "ja": "2. 最近の測定値は古い測定値よりも価値があり、それに応じて重み付けするという事実を利用します。"
    },
    {
      "indent": 0,
      "text": " Although measurements that are more recent are more valuable, older measurements are still needed to gain an accurate estimate of the distribution descriptor we are measuring. Unfortunately, the simple exponentially weighted moving average weights drop off too quickly for our requirements and have an infinite tail. A simple linearly declining weighted moving average also does not provide enough weight to the measurements that are most recent. We propose a piecewise linear distribution of weights, such that the first section (samples 1:F) is flat as in a simple moving average, and the second section (samples F+1:M) is linearly declining weights to the end of the averaging window. We choose integer weights; this allows incremental calculation without introducing rounding errors.",
      "ja": "最近の測定値の方が価値がありますが、測定している分布記述子の正確な推定値を取得するには、古い測定値が必要です。残念ながら、単純な指数的に重み付けされた移動平均重みは、要件に対して急速に低下し、無限の裾を持っています。単純な線形減少加重移動平均も、最新の測定値に十分な加重を提供しません。最初のセクション（サンプル1：F）が単純な移動平均のようにフラットであり、2番目のセクション（サンプルF + 1：M）が線形の終わりまで重みを線形的に減少させるような、重みの区分線形分布を提案します。平均化ウィンドウ。整数の重みを選択します。これにより、丸め誤差を導入せずに増分計算が可能になります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Improving the Response of the Skewness Estimate",
      "section_title": true,
      "ja": "4.1.1. 歪度推定の応答の改善"
    },
    {
      "indent": 3,
      "text": "The weighted moving average for skew_est, based on skew_est as defined in Section 3.2.2, can be calculated as follows:",
      "ja": "セクション3.2.2で定義されているskew_estに基づくskew_estの加重移動平均は、次のように計算できます。"
    },
    {
      "indent": 6,
      "text": "skew_est = ((M-F+1)*sum(skew_base_T(1:F))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "+ sum([(M-F):1].*skew_base_T(F+1:M)))",
      "ja": "+ sum（[（M-F）：1]。* skew_base_T（F + 1：M）））"
    },
    {
      "indent": 17,
      "text": "/ ((M-F+1)*sum(numsampT(1:F))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "+ sum([(M-F):1].*numsampT(F+1:M)))",
      "ja": "+ sum（[（M-F）：1]。* numsampT（F + 1：M）））"
    },
    {
      "indent": 3,
      "text": "where numsampT is an array of the number of OWD samples in each T (i.e., num_T(OWD)), and numsampT(1) is the most recent; skew_base_T(1) is the most recent calculation of skew_base_T; 1:F refers to the integer values 1 through to F, and [(M-F):1] refers to an array of the integer values (M-F) declining through to 1; and \".*\" is the array scalar dot product operator.",
      "ja": "ここで、numsampTは各TのOWDサンプル数の配列（つまり、num_T（OWD））であり、numsampT（1）は最新です。 skew_base_T（1）は、skew_base_Tの最新の計算です。 1：Fは1からFまでの整数値を参照し、[（M-F）：1]は1まで減少する整数値（M-F）の配列を参照します。 「。*」は配列スカラードット積演算子です。"
    },
    {
      "indent": 3,
      "text": "To calculate this weighted skew_est incrementally:",
      "ja": "この加重skew_estを段階的に計算するには："
    },
    {
      "indent": 3,
      "text": "Notation:    F_ = flat portion, D_ = declining portion,\n             W_ = weighted component",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialize:  sum_skewbase = 0, F_skewbase = 0, W_D_skewbase = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "skewbase_hist = buffer of length M, initialized to 0",
      "ja": "skewbase_hist =長さMのバッファー、0に初期化"
    },
    {
      "indent": 16,
      "text": "numsampT = buffer of length M, initialized to 0",
      "ja": "numsampT =長さMのバッファー、0に初期化"
    },
    {
      "indent": 3,
      "text": "Steps per iteration:",
      "ja": "反復あたりのステップ："
    },
    {
      "indent": 3,
      "text": "1. old_skewbase = skewbase_hist(M)",
      "ja": "1. old_skewbase = skewbase_hist（M）"
    },
    {
      "indent": 3,
      "text": "2. old_numsampT = numsampT(M)",
      "ja": "2. old_numsampT = numsampT（M）"
    },
    {
      "indent": 3,
      "text": "3. cycle(skewbase_hist)",
      "ja": "3. サイクル（skewbase_hist）"
    },
    {
      "indent": 3,
      "text": "4. cycle(numsampT)",
      "ja": "4. サイクル（numsampT）"
    },
    {
      "indent": 0,
      "text": "   5.   numsampT(1) = num_T(OWD)\n   6.   skewbase_hist(1) = skew_base_T",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "7. F_skewbase = F_skewbase + skew_base_T - skewbase_hist(F+1)",
      "ja": "7. F_skewbase = F_skewbase + skew_base_T-skewbase_hist（F + 1）"
    },
    {
      "indent": 3,
      "text": "8. W_D_skewbase = W_D_skewbase + (M-F)*skewbase_hist(F+1) - sum_skewbase",
      "ja": "8. W_D_skewbase = W_D_skewbase +（M-F）* skewbase_hist（F + 1）-sum_skewbase"
    },
    {
      "indent": 3,
      "text": "9. W_D_numsamp = W_D_numsamp + (M-F)*numsampT(F+1) - sum_numsamp + F_numsamp",
      "ja": "9. W_D_numsamp = W_D_numsamp +（M-F）* numsampT（F + 1）-sum_numsamp + F_numsamp"
    },
    {
      "indent": 3,
      "text": "10. F_numsamp = F_numsamp + numsampT(1) - numsampT(F+1)",
      "ja": "10. F_numsamp = F_numsamp + numsampT（1）-numsampT（F + 1）"
    },
    {
      "indent": 3,
      "text": "11. sum_skewbase = sum_skewbase + skewbase_hist(F+1) - old_skewbase",
      "ja": "11. sum_skewbase = sum_skewbase + skewbase_hist（F + 1）-old_skewbase"
    },
    {
      "indent": 3,
      "text": "12. sum_numsamp = sum_numsamp + numsampT(1) - old_numsampT",
      "ja": "12. sum_numsamp = sum_numsamp + numsampT（1）-old_numsampT"
    },
    {
      "indent": 3,
      "text": "13. skew_est = ((M-F+1)*F_skewbase + W_D_skewbase) / ((M-F+1)*F_numsamp+W_D_numsamp)",
      "ja": "13. skew_est =（（M-F + 1）* F_skewbase + W_D_skewbase）/（（M-F + 1）* F_numsamp + W_D_numsamp）"
    },
    {
      "indent": 3,
      "text": "where cycle(...) refers to the operation on a cyclic buffer where the start of the buffer is now the next element in the buffer.",
      "ja": "ここで、cycle（...）は、バッファーの先頭がバッファー内の次の要素になる循環バッファーでの操作を指します。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Improving the Response of the Variability Estimate",
      "section_title": true,
      "ja": "4.1.2. 変動推定の応答の改善"
    },
    {
      "indent": 3,
      "text": "Similarly, the weighted moving average for var_est can be calculated as follows:",
      "ja": "同様に、var_estの加重移動平均は次のように計算できます。"
    },
    {
      "indent": 6,
      "text": "var_est = ((M-F+1)*sum(var_base_T(1:F))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "+ sum([(M-F):1].*var_base_T(F+1:M)))",
      "ja": "+ sum（[（M-F）：1]。* var_base_T（F + 1：M）））"
    },
    {
      "indent": 16,
      "text": "/ ((M-F+1)*sum(numsampT(1:F))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "+ sum([(M-F):1].*numsampT(F+1:M)))",
      "ja": "+ sum（[（M-F）：1]。* numsampT（F + 1：M）））"
    },
    {
      "indent": 3,
      "text": "where numsampT is an array of the number of OWD samples in each T (i.e., num_T(OWD)), and numsampT(1) is the most recent; skew_base_T(1) is the most recent calculation of skew_base_T; 1:F refers to the integer values 1 through to F, and [(M-F):1] refers to an array of the integer values (M-F) declining through to 1; and \".*\" is the array scalar dot product operator. When removing oscillation noise (see Section 4.2), this calculation must be adjusted to allow for invalid var_base_T records.",
      "ja": "ここで、numsampTは各TのOWDサンプル数の配列（つまり、num_T（OWD））であり、numsampT（1）は最新です。 skew_base_T（1）は、skew_base_Tの最新の計算です。 1：Fは1からFまでの整数値を参照し、[（M-F）：1]は1まで減少する整数値（M-F）の配列を参照します。 「。*」は配列スカラードット積演算子です。発振ノイズを除去する場合（セクション4.2を参照）、無効なvar_base_Tレコードを許可するようにこの計算を調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "var_est can be calculated incrementally in the same way as skew_est as shown in Section 4.1.1. However, note that the buffer numsampT is used for both calculations, so the operations on it should not be repeated.",
      "ja": "var_estは、4.1.1項に示すように、skew_estと同じ方法で増分計算できます。ただし、バッファnumsampTは両方の計算に使用されるため、その操作を繰り返さないでください。"
    },
    {
      "indent": 0,
      "text": "4.2. Removing Oscillation Noise",
      "section_title": true,
      "ja": "4.2. 振動ノイズの除去"
    },
    {
      "indent": 3,
      "text": "When a path has no bottleneck, var_est will be very small and the recorded significant mean crossings will be the result of path noise. Thus, up to N-1 meaningless mean crossings can be a source of error at the point where a link becomes a bottleneck and flows traversing it begin to be grouped.",
      "ja": "パスにボトルネックがない場合、var_estは非常に小さく、記録された有意な平均交差はパスノイズの結果です。したがって、リンクがボトルネックになり、それを通過するフローがグループ化され始めるポイントでは、最大N-1個の無意味な平均交差がエラーの原因になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "To remove this source of noise from freq_est:",
      "ja": "このノイズソースをfreq_estから削除するには："
    },
    {
      "indent": 3,
      "text": "1. Set the current var_base_T = NaN (a value representing an invalid record, i.e., Not a Number) for flows that are deemed to not be transiting a bottleneck by the first grouping test that is based on skew_est (see Section 3.3.1).",
      "ja": "1. skew_estに基づく最初のグループ化テスト（セクション3.3.1を参照）によってボトルネックを通過していないと見なされるフローに対して、現在のvar_base_T = NaN（無効なレコードを表す値、つまり非数値）を設定します。"
    },
    {
      "indent": 3,
      "text": "2. Then, var_est = sum_MT(var_base_T != NaN) / num_MT(OWD).",
      "ja": "2. 次に、var_est = sum_MT（var_base_T！= NaN）/ num_MT（OWD）。"
    },
    {
      "indent": 3,
      "text": "3. For freq_est, only record a significant mean crossing if a given flow is deemed to be transiting a bottleneck.",
      "ja": "3. freq_estの場合、特定のフローがボトルネックを通過していると見なされる場合にのみ、有意な平均交差を記録します。"
    },
    {
      "indent": 3,
      "text": "These three changes can help to remove the non-bottleneck noise from freq_est.",
      "ja": "これらの3つの変更は、freq_estから非ボトルネックノイズを取り除くのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "5. Measuring OWD",
      "section_title": true,
      "ja": "5. OWDの測定"
    },
    {
      "indent": 3,
      "text": "This section discusses the OWD measurements required for this algorithm to detect shared bottlenecks.",
      "ja": "このセクションでは、このアルゴリズムが共有ボトルネックを検出するために必要なOWD測定について説明します。"
    },
    {
      "indent": 3,
      "text": "The SBD mechanism described in this document relies on differences between OWD measurements to avoid the practical problems with measuring absolute OWD (see [Hayes-LCN14], Section III.C). Since all summary statistics are relative to the mean OWD and sender/receiver clock offsets should be approximately constant over the measurement periods, the offset is subtracted out in the calculation.",
      "ja": "このドキュメントで説明されているSBDメカニズムは、絶対OWDの測定に関する実際的な問題を回避するために、OWD測定間の違いに依存しています（[Hayes-LCN14]、セクションIII.Cを参照）。すべての要約統計量は平均OWDに関連しており、送信側/受信側のクロックオフセットは測定期間全体でほぼ一定である必要があるため、計算ではオフセットが差し引かれます。"
    },
    {
      "indent": 0,
      "text": "5.1. Timestamp Resolution",
      "section_title": true,
      "ja": "5.1. タイムスタンプの解決"
    },
    {
      "indent": 3,
      "text": "The SBD mechanism requires timing information precise enough to be able to make comparisons. As a rule of thumb, the time resolution should be less than one hundredth of a typical path's range of delays. In general, the coarser the time resolution, the more care that needs to be taken to ensure that rounding errors do not bias the skewness calculation. Frequent timing information in millisecond resolution as described by [RTCP-CC-FEEDBACK] should be sufficient for the sender to calculate relative OWD.",
      "ja": "SBDメカニズムには、比較を行うことができるほど正確なタイミング情報が必要です。経験則として、時間分解能は一般的なパスの遅延範囲の100分の1未満でなければなりません。一般に、時間分解能が粗いほど、丸め誤差が歪度計算にバイアスをかけないように注意する必要があります。送信者が相対OWDを計算するには、[RTCP-CC-FEEDBACK]で説明されているように、ミリ秒単位の頻繁なタイミング情報で十分です。"
    },
    {
      "indent": 0,
      "text": "5.2. Clock Skew",
      "section_title": true,
      "ja": "5.2. クロックスキュー"
    },
    {
      "indent": 3,
      "text": "Generally, sender and receiver clock skew will be too small to cause significant errors in the estimators. skew_est and freq_est are the most sensitive to this type of noise due to their use of a mean OWD calculated over a longer interval. In circumstances where clock skew is high, basing skew_est only on the previous T's mean and ignoring freq_est provide a noisier but reliable signal.",
      "ja": "一般に、送信側と受信側のクロックスキューは小さすぎて、推定量に重大なエラーを引き起こしません。 skew_estとfreq_estは、より長い間隔で計算された平均OWDを使用するため、このタイプのノイズに最も敏感です。クロックスキューが高い状況では、skew_estを以前のTの平均のみに基づいて設定し、freq_estを無視すると、ノイズは多くなりますが信頼性の高い信号が得られます。"
    },
    {
      "indent": 3,
      "text": "A more sophisticated method is to estimate the effect the clock skew is having on the summary statistics and then adjust statistics accordingly. There are a number of techniques in the literature, including [Zhang-Infocom02].",
      "ja": "より高度な方法は、クロックスキューがサマリー統計に与える影響を推定し、それに応じて統計を調整することです。文献には、[Zhang-Infocom02]を含むいくつかのテクニックがあります。"
    },
    {
      "indent": 0,
      "text": "6. Expected Feedback from Experiments",
      "section_title": true,
      "ja": "6. 実験からの予想されるフィードバック"
    },
    {
      "indent": 3,
      "text": "The algorithm described in this memo has so far been evaluated using simulations and small-scale experiments. Real network tests using RTP Media Congestion Avoidance Techniques (RMCAT) congestion control algorithms will help confirm the default parameter choice. For example, the time interval T may need to be made longer if the packet rate is very low. Implementers and testers are invited to document their findings in an Internet-Draft.",
      "ja": "このメモで説明されているアルゴリズムは、これまでシミュレーションと小規模な実験を使用して評価されてきました。 RTPメディア輻輳回避技術（RMCAT）輻輳制御アルゴリズムを使用した実際のネットワークテストは、デフォルトのパラメーターの選択を確認するのに役立ちます。たとえば、パケットレートが非常に低い場合は、時間間隔Tを長くする必要があります。実装者とテスターは、発見したことをインターネットドラフトに文書化することができます。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security considerations of RFC 3550 [RFC3550], RFC 4585 [RFC4585], and RFC 5124 [RFC5124] are expected to apply.",
      "ja": "RFC 3550 [RFC3550]、RFC 4585 [RFC4585]、およびRFC 5124 [RFC5124]のセキュリティに関する考慮事項が適用されることが期待されています。"
    },
    {
      "indent": 3,
      "text": "Non-authenticated RTCP packets carrying OWD measurements, shared bottleneck indications, and/or summary statistics could allow attackers to alter the bottleneck-sharing characteristics for private gain or disruption of other parties' communication. When using SBD for coupled congestion control as described in [RTP-COUPLED-CC], the security considerations of [RTP-COUPLED-CC] apply.",
      "ja": "OWD測定、共有ボトルネック表示、および/または要約統計を運ぶ認証されていないRTCPパケットにより、攻撃者は、プライベートゲインまたは他のパーティの通信の中断のボトルネック共有特性を変更する可能性があります。 [RTP-COUPLED-CC]で説明されているように、SBDを結合輻輳制御に使用する場合、[RTP-COUPLED-CC]のセキュリティに関する考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Hayes-LCN14]\n           Hayes, D., Ferlin, S., and M. Welzl, \"Practical Passive\n           Shared Bottleneck Detection using Shape Summary\n           Statistics\", Proc. IEEE Local Computer Networks (LCN),\n           pp. 150-158, DOI 10.1109/LCN.2014.6925767, September 2014,\n           <http://heim.ifi.uio.no/davihay/\n           hayes14__pract_passiv_shared_bottl_detec-abstract.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <https://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <https://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <https://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C。、およびJ. Rey、「​​リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック用の拡張RTPプロファイル（RTP / AVPF） \"、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<https://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC5124] Ott, J. and E. Carrara, \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\", RFC 5124, DOI 10.17487/RFC5124, February 2008, <https://www.rfc-editor.org/info/rfc5124>.",
      "ja": "[RFC5124] Ott、J。およびE. Carrara、「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<https ：//www.rfc-editor.org/info/rfc5124>。"
    },
    {
      "indent": 3,
      "text": "[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, \"Low Extra Delay Background Transport (LEDBAT)\", RFC 6817, DOI 10.17487/RFC6817, December 2012, <https://www.rfc-editor.org/info/rfc6817>.",
      "ja": "[RFC6817] Shalunov、S.、Hazel、G.、Iyengar、J。、およびM. Kuehlewind、「Low Extra Delay Background Transport（LEDBAT）」、RFC 6817、DOI 10.17487 / RFC6817、2012年12月、<https：// www.rfc-editor.org/info/rfc6817>。"
    },
    {
      "indent": 3,
      "text": "[RFC7679] Almes, G., Kalidindi, S., Zekauskas, M., and A. Morton, Ed., \"A One-Way Delay Metric for IP Performance Metrics (IPPM)\", STD 81, RFC 7679, DOI 10.17487/RFC7679, January 2016, <https://www.rfc-editor.org/info/rfc7679>.",
      "ja": "[RFC7679] Almes、G.、Kalidindi、S.、Zekauskas、M。、およびA. Morton、編、「IPパフォーマンスメトリック（IPPM）の片方向遅延メトリック」、STD 81、RFC 7679、DOI 10.17487 / RFC7679、2016年1月、<https://www.rfc-editor.org/info/rfc7679>。"
    },
    {
      "indent": 3,
      "text": "[RFC7680] Almes, G., Kalidindi, S., Zekauskas, M., and A. Morton, Ed., \"A One-Way Loss Metric for IP Performance Metrics (IPPM)\", STD 82, RFC 7680, DOI 10.17487/RFC7680, January 2016, <https://www.rfc-editor.org/info/rfc7680>.",
      "ja": "[RFC7680] Almes、G.、Kalidindi、S.、Zekauskas、M。、およびA. Morton、編、「IP Performance Metrics（IPPM）の一方向損失メトリック」、STD 82、RFC 7680、DOI 10.17487 / RFC7680、2016年1月、<https://www.rfc-editor.org/info/rfc7680>。"
    },
    {
      "indent": 3,
      "text": "[RTCP-CC-FEEDBACK] Sarker, Z., Perkins, C., Singh, V., and M. Ramalho, \"RTP Control Protocol (RTCP) Feedback for Congestion Control\", Work in Progress, draft-ietf-avtcore-cc-feedback-message-01, March 2018.",
      "ja": "[RTCP-CC-FEEDBACK] Sarker、Z.、Perkins、C.、Singh、V。、およびM. Ramalho、「輻輳制御のためのRTP制御プロトコル（RTCP）フィードバック」、作業中、draft-ietf-avtcore- cc-feedback-message-01、2018年3月。"
    },
    {
      "indent": 3,
      "text": "[RTP-COUPLED-CC] Islam, S., Welzl, M., and S. Gjessing, \"Coupled congestion control for RTP media\", Work in Progress, draft-ietf-rmcat-coupled-cc-07, September 2017.",
      "ja": "[RTP-COUPLED-CC] Islam、S.、Welzl、M.、and S. Gjessing、 \"Coupled congestion control for RTP media\"、Work in Progress、draft-ietf-rmcat-coupled-cc-07、September 2017。"
    },
    {
      "indent": 3,
      "text": "[Zhang-Infocom02] Zhang, L., Liu, Z., and H. Xia, \"Clock synchronization algorithms for network measurements\", Proc. IEEE International Conference on Computer Communications (INFOCOM), pp. 160-169, DOI 10.1109/INFCOM.2002.1019257, September 2002.",
      "ja": "[Zhang-Infocom02] Zhang、L.、Liu、Z。、およびH. Xia、「ネットワーク測定のクロック同期アルゴリズム」、Proc。コンピュータ通信に関するIEEE国際会議（INFOCOM）、pp。160-169、DOI 10.1109 / INFCOM.2002.1019257、2002年9月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This work was partially funded by the European Community under its Seventh Framework Programme through the Reducing Internet Transport Latency (RITE) project (ICT-317700). The views expressed are solely those of the authors.",
      "ja": "この作業は、その第7フレームワークプログラムの下で、インターネットトランスポートレイテンシの削減（RITE）プロジェクト（ICT-317700）を通じて欧州共同体によって部分的に資金提供されました。表明された見解は、著者の見解のみです。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David Hayes (editor) Simula Research Laboratory P.O. Box 134 Lysaker 1325 Norway",
      "ja": "デビッド・ヘイズ（編集者）Simula Research Laboratory P.O. Box 134 Lysaker 1325ノルウェー"
    },
    {
      "indent": 3,
      "text": "Email: davidh@simula.no",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simone Ferlin Simula Research Laboratory P.O. Box 134 Lysaker 1325 Norway",
      "ja": "Simone Ferlin Simula Research Laboratory P.O. Box 134 Lysaker 1325ノルウェー"
    },
    {
      "indent": 3,
      "text": "Email: simone@ferlin.io",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Welzl University of Oslo P.O. Box 1080 Blindern Oslo N-0316 Norway",
      "ja": "マイケルウェルツル大学オスロP.O. Box 1080 Blindern Oslo N-0316ノルウェー"
    },
    {
      "indent": 3,
      "text": "Email: michawe@ifi.uio.no",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kristian Hiorth University of Oslo P.O. Box 1080 Blindern Oslo N-0316 Norway",
      "ja": "オスロクリスティアンヒオス大学P.O. Box 1080 Blindern Oslo N-0316ノルウェー"
    },
    {
      "indent": 3,
      "text": "Email: kristahi@ifi.uio.no",
      "raw": true,
      "ja": ""
    }
  ]
}