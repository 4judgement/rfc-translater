{
  "title": {
    "text": "RFC 8305 - Happy Eyeballs Version 2: Better Connectivity Using Concurrency",
    "ja": "RFC 8305 - Happy Eyeballsバージョン2：並行性を使用した接続性の向上"
  },
  "number": 8305,
  "created_at": "2020-08-23 18:04:52.900706+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       D. Schinazi\nRequest for Comments: 8305                                      T. Pauly\nObsoletes: 6555                                               Apple Inc.\nCategory: Standards Track                                  December 2017\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Happy Eyeballs Version 2: Better Connectivity Using Concurrency",
      "ja": "Happy Eyeballsバージョン2：並行性を使用した接続性の向上"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Many communication protocols operating over the modern Internet use hostnames. These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics. Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly. This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm, referred to as \"Happy Eyeballs\". This document obsoletes the original algorithm description in RFC 6555.",
      "ja": "現代のインターネット上で動作する多くの通信プロトコルはホスト名を使用しています。これらは多くの場合、複数のIPアドレスに解決され、それぞれに異なるパフォーマンスと接続特性がある場合があります。特定のアドレスまたはアドレスファミリ（IPv4またはIPv6）は、ネットワーク上でブロック、破損、または最適化されていない可能性があるため、複数の接続を同時に試行するクライアントは、接続をより迅速に確立できる可能性があります。このドキュメントでは、このユーザーに表示される遅延を削減するアルゴリズムの要件を指定し、「ハッピーアイボール」と呼ばれるアルゴリズムの例を示します。このドキュメントは、RFC 6555の元のアルゴリズムの説明を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8305.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8305で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3\n2.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Hostname Resolution Query Handling  . . . . . . . . . . . . .   4\n  3.1.  Handling Multiple DNS Server Addresses  . . . . . . . . .   5\n4.  Sorting Addresses . . . . . . . . . . . . . . . . . . . . . .   6\n5.  Connection Attempts . . . . . . . . . . . . . . . . . . . . .   7\n6.  DNS Answer Changes during Happy Eyeballs Connection Setup . .   8\n7.  Supporting IPv6-Only Networks with NAT64 and DNS64  . . . . .   8\n  7.1.  IPv4 Address Literals . . . . . . . . . . . . . . . . . .   8\n  7.2.  Hostnames with Broken AAAA Records  . . . . . . . . . . .   9\n  7.3.  Virtual Private Networks  . . . . . . . . . . . . . . . .  10\n8.  Summary of Configurable Values  . . . . . . . . . . . . . . .  10\n9.  Limitations . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  9.1.  Path Maximum Transmission Unit Discovery  . . . . . . . .  11\n  9.2.  Application Layer . . . . . . . . . . . . . . . . . . . .  11\n  9.3.  Hiding Operational Issues . . . . . . . . . . . . . . . .  11\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  12\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12\n12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n  12.1.  Normative References . . . . . . . . . . . . . . . . . .  12\n  12.2.  Informative References . . . . . . . . . . . . . . . . .  13\nAppendix A.  Differences from RFC 6555  . . . . . . . . . . . . .  14\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  15\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  15",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Many communication protocols operating over the modern Internet use hostnames. These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics. Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly. This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm.",
      "ja": "現代のインターネット上で動作する多くの通信プロトコルはホスト名を使用しています。これらは多くの場合、複数のIPアドレスに解決され、それぞれに異なるパフォーマンスと接続特性がある場合があります。特定のアドレスまたはアドレスファミリ（IPv4またはIPv6）は、ネットワーク上でブロック、破損、または最適化されていない可能性があるため、複数の接続を同時に試行するクライアントは、接続をより迅速に確立できる可能性があります。このドキュメントでは、このユーザーに表示される遅延を削減するアルゴリズムの要件を指定し、アルゴリズムの例を示します。"
    },
    {
      "indent": 3,
      "text": "This document defines the algorithm for \"Happy Eyeballs\", a technique for reducing user-visible delays on dual-stack hosts. This definition obsoletes the original description in [RFC6555]. Now that this approach has been deployed at scale and measured for several years, the algorithm specification can be refined to improve its reliability and general applicability.",
      "ja": "このドキュメントでは、「ハッピーアイボール」のアルゴリズムを定義します。これは、デュアルスタックホストでユーザーから見える遅延を減らすための手法です。この定義は、[RFC6555]の元の説明を廃止します。このアプローチが大規模に展開され、数年にわたって測定されたので、アルゴリズムの仕様を改良して、信頼性と一般的な適用性を向上させることができます。"
    },
    {
      "indent": 3,
      "text": "The Happy Eyeballs algorithm of racing connections to resolved addresses has several stages to avoid delays to the user whenever possible, while preferring the use of IPv6. This document discusses how to handle DNS queries when starting a connection on a dual-stack client, how to create an ordered list of destination addresses to which to attempt connections, and how to race the connection attempts.",
      "ja": "解決されたアドレスへの接続の競合のHappy Eyeballsアルゴリズムには、IPv6の使用を優先しながら、可能な限りユーザーへの遅延を回避するためのいくつかの段階があります。このドキュメントでは、デュアルスタッククライアントで接続を開始するときにDNSクエリを処理する方法、接続を試行する宛先アドレスの順序付きリストを作成する方法、および接続試行を競合させる方法について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL \"このドキュメントでは、[RFC2119] [RFC8174]で説明されているように解釈される必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2. 概観"
    },
    {
      "indent": 3,
      "text": "This document defines a method of connection establishment, named the \"Happy Eyeballs Connection Setup\". This approach has several distinct phases:",
      "ja": "このドキュメントでは、「Happy Eyeballs Connection Setup」という名前の接続確立方法を定義しています。このアプローチには、いくつかの異なるフェーズがあります。"
    },
    {
      "indent": 3,
      "text": "1. Initiation of asynchronous DNS queries [Section 3]",
      "ja": "1. 非同期DNSクエリの開始[セクション3]"
    },
    {
      "indent": 3,
      "text": "2. Sorting of resolved destination addresses [Section 4]",
      "ja": "2. 解決された宛先アドレスのソート[セクション4]"
    },
    {
      "indent": 3,
      "text": "3. Initiation of asynchronous connection attempts [Section 5]",
      "ja": "3. 非同期接続試行の開始[セクション5]"
    },
    {
      "indent": 3,
      "text": "4. Establishment of one connection, which cancels all other attempts [Section 5]",
      "ja": "4. 他のすべての試みをキャンセルする1つの接続の確立[セクション5]"
    },
    {
      "indent": 3,
      "text": "Note that this document assumes that the preference policy for the host destination address favors IPv6 over IPv4. IPv6 has many desirable properties designed to be improvements over IPv4 [RFC8200]. If the host is configured to have a different preference, the recommendations in this document can be easily adapted.",
      "ja": "このドキュメントでは、ホスト宛先アドレスの優先ポリシーがIPv4よりもIPv6を優先することを前提としています。 IPv6には、IPv4 [RFC8200]を改善するために設計された多くの望ましい特性があります。ホストが異なる設定を持つように構成されている場合、このドキュメントの推奨事項は簡単に適応できます。"
    },
    {
      "indent": 0,
      "text": "3. Hostname Resolution Query Handling",
      "section_title": true,
      "ja": "3. ホスト名解決クエリの処理"
    },
    {
      "indent": 3,
      "text": "When a client has both IPv4 and IPv6 connectivity and is trying to establish a connection with a named host, it needs to send out both AAAA and A DNS queries. Both queries SHOULD be made as soon after one another as possible, with the AAAA query made first and immediately followed by the A query.",
      "ja": "クライアントにIPv4とIPv6の両方の接続があり、名前付きホストとの接続を確立しようとしている場合、クライアントはAAAAクエリとA DNSクエリの両方を送信する必要があります。 AAAAクエリが最初に行われ、その直後にAクエリが続く、両方のクエリは、可能な限りすぐ後に行われる必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD NOT wait for both families of answers to return before attempting connection establishment. If one query fails to return or takes significantly longer to return, waiting for the second address family can significantly delay the connection establishment of the first one. Therefore, the client SHOULD treat DNS resolution as asynchronous. Note that if the platform does not offer an asynchronous DNS API, this behavior can be simulated by making two separate synchronous queries on different threads, one per address family.",
      "ja": "実装は、接続の確立を試みる前に、両方のファミリーの応答が戻るのを待ってはなりません。 1つのクエリが返らないか、返るのにかなり時間がかかる場合、2番目のアドレスファミリを待機すると、最初のクエリの接続確立が大幅に遅れることがあります。したがって、クライアントはDNS解決を非同期として扱う必要があります（SHOULD）。プラットフォームが非同期DNS APIを提供しない場合、この動作は、アドレスファミリごとに1つずつ、異なるスレッドで2つの別個の同期クエリを実行することによってシミュレートできます。"
    },
    {
      "indent": 0,
      "text": " The algorithm proceeds as follows: if a positive AAAA response (a response with at least one valid AAAA record) is received first, the first IPv6 connection attempt is immediately started. If a positive A response is received first due to reordering, the client SHOULD wait a short time for the AAAA response to ensure that preference is given to IPv6 (it is common for the AAAA response to follow the A response by a few milliseconds). This delay will be referred to as the \"Resolution Delay\". The recommended value for the Resolution Delay is 50 milliseconds. If a positive AAAA response is received within the Resolution Delay period, the client immediately starts the IPv6 connection attempt. If a negative AAAA response (no error, no data) is received within the Resolution Delay period or the AAAA response has not been received by the end of the Resolution Delay period, the client SHOULD proceed to sorting addresses (see Section 4) and staggered connection attempts (see Section 5) using any IPv4 addresses returned so far. If the AAAA response arrives while these connection attempts are in progress but before any connection has been established, then the newly received IPv6 addresses are incorporated into the list of available candidate addresses (see Section 6) and the process of connection attempts will continue with the IPv6 addresses added, until one connection is established.",
      "ja": "アルゴリズムは次のように進行します。肯定のAAAA応答（少なくとも1つの有効なAAAAレコードのある応答）が最初に受信された場合、最初のIPv6接続の試行がすぐに開始されます。並べ替えにより最初に肯定的なA応答が受信された場合、クライアントは、AAAA応答がIPv6に優先されることを保証するために、しばらく待つ必要があります（AAAA応答がA応答に数ミリ秒続くことが一般的です）。この遅延は、「解決遅延」と呼ばれます。解決遅延の推奨値は50ミリ秒です。解決遅延期間内に正のAAAA応答が受信されると、クライアントはすぐにIPv6接続の試行を開始します。解決遅延期間内に否定のAAAA応答（エラーなし、データなし）が受信された場合、または解決遅延期間の終わりまでにAAAA応答が受信されなかった場合、クライアントはアドレスのソート（セクション4を参照）に進み、時間差をとる必要があります（SHOULD）。これまでに返されたIPv4アドレスを使用した接続試行（セクション5を参照）。これらの接続試行の進行中に接続が確立される前にAAAA応答が到着した場合、新しく受信されたIPv6アドレスが使用可能な候補アドレスのリストに組み込まれ（セクション6を参照）、接続試行のプロセスは1つの接続が確立されるまで、IPv6アドレスが追加されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Handling Multiple DNS Server Addresses",
      "section_title": true,
      "ja": "3.1. 複数のDNSサーバーアドレスの処理"
    },
    {
      "indent": 3,
      "text": "If multiple DNS server addresses are configured for the current network, the client may have the option of sending its DNS queries over IPv4 or IPv6. In keeping with the Happy Eyeballs approach, queries SHOULD be sent over IPv6 first (note that this is not referring to the sending of AAAA or A queries, but rather the address of the DNS server itself and IP version used to transport DNS messages). If DNS queries sent to the IPv6 address do not receive responses, that address may be marked as penalized and queries can be sent to other DNS server addresses.",
      "ja": "現在のネットワークに複数のDNSサーバーアドレスが構成されている場合、クライアントには、IPv4またはIPv6を介してDNSクエリを送信するオプションがあります。 Happy Eyeballsのアプローチに従い、クエリは最初にIPv6を介して送信する必要があります（これはAAAAまたはAクエリの送信ではなく、DNSサーバー自体のアドレスとDNSメッセージの転送に使用されるIPバージョンを指すことに注意してください）。 IPv6アドレスに送信されたDNSクエリが応答を受信しない場合、そのアドレスはペナルティ付きとしてマークされ、クエリを他のDNSサーバーアドレスに送信できます。"
    },
    {
      "indent": 3,
      "text": "As native IPv6 deployments become more prevalent and IPv4 addresses are exhausted, it is expected that IPv6 connectivity will have preferential treatment within networks. If a DNS server is configured to be accessible over IPv6, IPv6 should be assumed to be the preferred address family.",
      "ja": "ネイティブIPv6展開が普及し、IPv4アドレスが使い果たされると、IPv6接続がネットワーク内で優先的に処理されることが予想されます。 DNSサーバーがIPv6経由でアクセスできるように構成されている場合、IPv6が優先アドレスファミリーであると想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Client systems SHOULD NOT have an explicit limit to the number of DNS servers that can be configured, either manually or by the network. If such a limit is required by hardware limitations, the client SHOULD use at least one address from each address family from the available list.",
      "ja": "クライアントシステムは、手動またはネットワークで構成できるDNSサーバーの数に明示的な制限を設定しないでください。ハードウェアの制限によってそのような制限が必要な場合、クライアントは、使用可能なリストの各アドレスファミリから少なくとも1つのアドレスを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "4. Sorting Addresses",
      "section_title": true,
      "ja": "4. 住所の並べ替え"
    },
    {
      "indent": 3,
      "text": "Before attempting to connect to any of the resolved destination addresses, the client should define the order in which to start the attempts. Once the order has been defined, the client can use a simple algorithm for racing each option after a short delay (see Section 5). It is important that the ordered list involve all addresses from both families that have been received by this point, as this allows the client to get the racing effect of Happy Eyeballs for the entire list, not just the first IPv4 and first IPv6 addresses.",
      "ja": "解決された宛先アドレスのいずれかに接続する前に、クライアントは試行を開始する順序を定義する必要があります。注文が定義されると、クライアントは簡単なアルゴリズムを使用して、少し遅れて各オプションを競争できます（セクション5を参照）。これにより、クライアントは最初のIPv4アドレスと最初のIPv6アドレスだけでなく、リスト全体でHappy Eyeballsのレーシング効果を得ることができるため、順序付きリストには、この時点で受信された両方のファミリーからのすべてのアドレスが含まれていることが重要です。"
    },
    {
      "indent": 3,
      "text": "First, the client MUST sort the addresses received up to this point using Destination Address Selection ([RFC6724], Section 6).",
      "ja": "まず、クライアントは、宛先アドレスの選択（[RFC6724]、セクション6）を使用して、この時点までに受信したアドレスをソートする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client is stateful and has a history of expected round-trip times (RTTs) for the routes to access each address, it SHOULD add a Destination Address Selection rule between rules 8 and 9 that prefers addresses with lower RTTs. If the client keeps track of which addresses it used in the past, it SHOULD add another Destination Address Selection rule between the RTT rule and rule 9, which prefers used addresses over unused ones. This helps servers that use the client's IP address during authentication, as is the case for TCP Fast Open [RFC7413] and some Hypertext Transport Protocol (HTTP) cookies. This historical data MUST NOT be used across different network interfaces and SHOULD be flushed whenever a device changes the network to which it is attached.",
      "ja": "クライアントがステートフルで、ルートが各アドレスにアクセスするために予想されるラウンドトリップ時間（RTT）の履歴がある場合、RTTがより低いアドレスを優先するルール8と9の間に宛先アドレス選択ルールを追加する必要があります。クライアントが過去に使用したアドレスを追跡している場合は、RTTルールとルール9の間に別の宛先アドレス選択ルールを追加してください。これにより、未使用のアドレスよりも使用されているアドレスが優先されます。これは、TCP Fast Open [RFC7413]および一部のハイパーテキストトランスポートプロトコル（HTTP）Cookieの場合と同様に、認証中にクライアントのIPアドレスを使用するサーバーに役立ちます。この履歴データは、異なるネットワークインターフェイス間で使用してはならず（MUST NOT）、デバイスが接続されているネットワークをデバイスが変更するたびにフラッシュする必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Next, the client SHOULD modify the ordered list to interleave address families. Whichever address family is first in the list should be followed by an address of the other address family; that is, if the first address in the sorted list is IPv6, then the first IPv4 address should be moved up in the list to be second in the list. An implementation MAY want to favor one address family more by allowing multiple addresses of that family to be attempted before trying the other family. The number of contiguous addresses of the first address family will be referred to as the \"First Address Family Count\" and can be a configurable value. This is performed to avoid waiting through a long list of addresses from a given address family if connectivity over that address family is impaired.",
      "ja": "次に、クライアントはアドレスファミリをインターリーブするように順序付きリストを変更する必要があります（SHOULD）。リストの最初にあるアドレスファミリの後には、他のアドレスファミリのアドレスが続く必要があります。つまり、並べ替えられたリストの最初のアドレスがIPv6の場合、最初のIPv4アドレスをリストの上位に移動して、リストの2番目にする必要があります。実装は、他のファミリを試行する前に、そのファミリの複数のアドレスを試行できるようにすることで、1つのアドレスファミリをより優先する場合があります。最初のアドレスファミリの連続したアドレスの数は、「最初のアドレスファミリカウント」と呼ばれ、設定可能な値にすることができます。これは、そのアドレスファミリを介した接続が損なわれている場合に、特定のアドレスファミリからの長いアドレスリストを待機しないようにするために実行されます。"
    },
    {
      "indent": 3,
      "text": "Note that the address selection described in this section only applies to destination addresses; Source Address Selection ([RFC6724], Section 5) is performed once per destination address and is out of scope of this document.",
      "ja": "このセクションで説明するアドレス選択は、宛先アドレスにのみ適用されることに注意してください。送信元アドレスの選択（[RFC6724]、セクション5）は、送信先アドレスごとに1回実行され、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "5. Connection Attempts",
      "section_title": true,
      "ja": "5. 接続試行"
    },
    {
      "indent": 3,
      "text": "Once the list of addresses received up to this point has been constructed, the client will attempt to make connections. In order to avoid unreasonable network load, connection attempts SHOULD NOT be made simultaneously. Instead, one connection attempt to a single address is started first, followed by the others in the list, one at a time. Starting a new connection attempt does not affect previous attempts, as multiple connection attempts may occur in parallel. Once one of the connection attempts succeeds (generally when the TCP handshake completes), all other connections attempts that have not yet succeeded SHOULD be canceled. Any address that was not yet attempted as a connection SHOULD be ignored. At that time, the asynchronous DNS query MAY be canceled as new addresses will not be used for this connection. However, the DNS client resolver SHOULD still process DNS replies from the network for a short period of time (recommended to be 1 second), as they will populate the DNS cache and can be used for subsequent connections.",
      "ja": "この時点までに受信したアドレスのリストが作成されると、クライアントは接続を試みます。不当なネットワーク負荷を回避するために、接続試行を同時に行うべきではありません。代わりに、単一のアドレスへの1つの接続試行が最初に開始され、リスト内の他の接続が1つずつ続きます。複数の接続試行が並行して発生する可能性があるため、新しい接続試行を開始しても以前の試行には影響しません。接続試行の1つが成功すると（通常はTCPハンドシェイクが完了したとき）、まだ成功していない他のすべての接続試行をキャンセルする必要があります（SHOULD）。接続としてまだ試行されていないアドレスは無視してください。そのとき、新しいアドレスはこの接続に使用されないため、非同期DNSクエリはキャンセルされる場合があります。ただし、DNSクライアントリゾルバは、ネットワークからのDNS応答を短時間（1秒にすることをお勧めします）処理します。これは、DNSキャッシュにデータが入力され、後続の接続に使用できるためです。"
    },
    {
      "indent": 3,
      "text": "A simple implementation can have a fixed delay for how long to wait before starting the next connection attempt. This delay is referred to as the \"Connection Attempt Delay\". One recommended value for a default delay is 250 milliseconds. A more nuanced implementation's delay should correspond to the time when the previous attempt is sending its second TCP SYN, based on the TCP's retransmission timer [RFC6298]. If the client has historical RTT data gathered from other connections to the same host or prefix, it can use this information to influence its delay. Note that this algorithm should only try to approximate the time of the first SYN retransmission, and not any further retransmissions that may be influenced by exponential timer back off.",
      "ja": "単純な実装では、次の接続試行を開始するまでの待機時間を固定することができます。この遅延は、「接続試行遅延」と呼ばれます。デフォルトの遅延の推奨値の1つは250ミリ秒です。より微妙な実装の遅延は、TCPの再送信タイマー[RFC6298]に基づいて、前の試行が2番目のTCP SYNを送信している時間に対応する必要があります。同じホストまたはプレフィックスへの他の接続から収集された履歴RTTデータがある場合、クライアントはこの情報を使用して遅延に影響を与えることができます。このアルゴリズムは、最初のSYN再送信の時間を概算することだけを試みるべきであり、指数タイマーバックオフの影響を受ける可能性のあるそれ以降の再送信は試行しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Connection Attempt Delay MUST have a lower bound, especially if it is computed using historical data. More specifically, a subsequent connection MUST NOT be started within 10 milliseconds of the previous attempt. The recommended minimum value is 100 milliseconds, which is referred to as the \"Minimum Connection Attempt Delay\". This minimum value is required to avoid congestion collapse in the presence of high packet-loss rates. The Connection Attempt Delay SHOULD have an upper bound, referred to as the \"Maximum Connection Attempt Delay\". The current recommended value is 2 seconds.",
      "ja": "接続試行遅延には、特に履歴データを使用して計算される場合は、下限がある必要があります。より具体的には、前の試行から10ミリ秒以内に後続の接続を開始してはなりません（MUST NOT）。推奨される最小値は100ミリ秒で、これは「最小接続試行遅延」と呼ばれます。この最小値は、パケット損失率が高い場合に輻輳が崩壊しないようにするために必要です。接続試行遅延には、「最大接続試行遅延」と呼ばれる上限があります。現在の推奨値は2秒です。"
    },
    {
      "indent": 0,
      "text": "6. DNS Answer Changes during Happy Eyeballs Connection Setup",
      "section_title": true,
      "ja": "6. Happy Eyeballs接続セットアップ中のDNS回答の変更"
    },
    {
      "indent": 3,
      "text": "If, during the course of connection establishment, the DNS answers change by either adding resolved addresses (for example due to DNS push notifications [DNS-PUSH]) or removing previously resolved addresses (for example, due to expiry of the TTL on that DNS record), the client should react based on its current progress.",
      "ja": "接続確立の過程で、解決されたアドレスを追加する（たとえば、DNSプッシュ通知[DNS-PUSH]による）または以前に解決されたアドレスを削除する（たとえば、そのDNSのTTLの期限切れのため）記録）、クライアントは現在の進捗状況に基づいて対応する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an address is removed from the list that already had a connection attempt started, the connection attempt SHOULD NOT be canceled, but rather be allowed to continue. If the removed address had not yet had a connection attempt started, it SHOULD be removed from the list of addresses to try.",
      "ja": "既に接続試行が開始されているリストからアドレスが削除された場合、接続試行はキャンセルされるべきではなく、続行することが許可されるべきです（SHOULD NOT）。削除されたアドレスがまだ接続試行を開始していない場合は、試行するアドレスのリストから削除する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If an address is added to the list, it should be sorted into the list of addresses not yet attempted according to the rules above (see Section 4).",
      "ja": "アドレスがリストに追加された場合、上記のルール（セクション4を参照）に従ってまだ試行されていないアドレスのリストにソートする必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Supporting IPv6-Only Networks with NAT64 and DNS64",
      "section_title": true,
      "ja": "7. NAT64およびDNS64によるIPv6のみのネットワークのサポート"
    },
    {
      "indent": 3,
      "text": "While many IPv6 transition protocols have been standardized and deployed, most are transparent to client devices. The combined use of NAT64 [RFC6146] and DNS64 [RFC6147] is a popular solution that is being deployed and requires changes in client devices. One possible way to handle these networks is for the client device networking stack to implement 464XLAT [RFC6877]. 464XLAT has the advantage of not requiring changes to user space software; however, it requires per-packet translation if the application is using IPv4 literals and does not encourage client application software to support native IPv6. On platforms that do not support 464XLAT, the Happy Eyeballs engine SHOULD follow the recommendations in this section to properly support IPv6-only networks with NAT64 and DNS64.",
      "ja": "多くのIPv6移行プロトコルが標準化および導入されていますが、ほとんどはクライアントデバイスに対して透過的です。 NAT64 [RFC6146]とDNS64 [RFC6147]を組み合わせて使用​​することは、展開されている一般的なソリューションであり、クライアントデバイスでの変更が必要です。これらのネットワークを処理する1つの可能な方法は、クライアントデバイスのネットワークスタックが464XLAT [RFC6877]を実装することです。 464XLATには、ユーザー空間ソフトウェアを変更する必要がないという利点があります。ただし、アプリケーションがIPv4リテラルを使用している場合は、パケットごとの変換が必要であり、クライアントアプリケーションソフトウェアがネイティブIPv6をサポートすることは推奨されません。 464XLATをサポートしないプラットフォームでは、Happy Eyeballsエンジンは、NAT64およびDNS64でIPv6のみのネットワークを適切にサポートするために、このセクションの推奨に従う必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The features described in this section SHOULD only be enabled when the host detects one of these networks. A simple heuristic to achieve that is to check if the network offers routable IPv6 addressing, does not offer routable IPv4 addressing, and offers a DNS resolver address.",
      "ja": "このセクションで説明する機能は、ホストがこれらのネットワークの1つを検出した場合にのみ有効にする必要があります（SHOULD）。そのための簡単なヒューリスティックは、ネットワークがルーティング可能なIPv6アドレッシングを提供し、ルーティング可能なIPv4アドレッシングを提供せず、DNSリゾルバーアドレスを提供するかどうかを確認することです。"
    },
    {
      "indent": 0,
      "text": "7.1. IPv4 Address Literals",
      "section_title": true,
      "ja": "7.1. IPv4アドレスリテラル"
    },
    {
      "indent": 3,
      "text": "If client applications or users wish to connect to IPv4 address literals, the Happy Eyeballs engine will need to perform NAT64 address synthesis for them. The solution is similar to \"Bump-in-the-Host\" [RFC6535] but is implemented inside the Happy Eyeballs library.",
      "ja": "クライアントアプリケーションまたはユーザーがIPv4アドレスリテラルに接続する場合、Happy Eyeballsエンジンはそれらに対してNAT64アドレス合成を実行する必要があります。このソリューションは「Bump-in-the-Host」[RFC6535]に似ていますが、Happy Eyeballsライブラリ内に実装されています。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 address is passed into the library instead of a hostname, the device queries the network for the NAT64 prefix using \"Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis\" [RFC7050] and then synthesizes an appropriate IPv6 address (or several) using the encoding described in \"IPv6 Addressing of IPv4/ IPv6 Translators\" [RFC6052]. The synthesized addresses are then inserted into the list of addresses as if they were results from DNS queries; connection attempts follow the algorithm described above (see Section 5).",
      "ja": "IPv4アドレスがホスト名ではなくライブラリに渡されると、デバイスは「IPv6アドレス合成に使用されるIPv6プレフィックスの検出」[RFC7050]を使用してネットワークにNAT64プレフィックスを照会し、適切なIPv6アドレス（またはいくつか）を合成します。 「IPv4 / IPv6トランスレータのIPv6アドレッシング」[RFC6052]で説明されているエンコーディングを使用します。合成されたアドレスは、あたかもDNSクエリの結果であるかのように、アドレスのリストに挿入されます。接続の試行は、上記のアルゴリズムに従います（セクション5を参照）。"
    },
    {
      "indent": 0,
      "text": "7.2. Hostnames with Broken AAAA Records",
      "section_title": true,
      "ja": "7.2. 壊れたAAAAレコードのあるホスト名"
    },
    {
      "indent": 3,
      "text": "At the time of writing, there exist a small but non-negligible number of hostnames that resolve to valid A records and broken AAAA records, which we define as AAAA records that contain seemingly valid IPv6 addresses but those addresses never reply when contacted on the usual ports. These can be, for example, caused by:",
      "ja": "執筆の時点では、有効なAレコードと壊れたAAAAレコードに解決される少数の無視できない数のホスト名が存在します。これらは、一見有効なIPv6アドレスを含むAAAAレコードとして定義されますが、これらのアドレスは通常の方法で接続されたときに応答しませんポート。これらは、たとえば、次の原因が考えられます。"
    },
    {
      "indent": 3,
      "text": "o Mistyping of the IPv6 address in the DNS zone configuration",
      "ja": "o DNSゾーン構成でのIPv6アドレスの入力ミス"
    },
    {
      "indent": 3,
      "text": "o Routing black holes",
      "ja": "o ブラックホールのルーティング"
    },
    {
      "indent": 3,
      "text": "o Service outages",
      "ja": "o サービス停止"
    },
    {
      "indent": 3,
      "text": "While an algorithm complying with the other sections of this document would correctly handle such hostnames on a dual-stack network, they will not necessarily function correctly on IPv6-only networks with NAT64 and DNS64. Since DNS64 recursive resolvers rely on the authoritative name servers sending negative (\"no error no answer\") responses for AAAA records in order to synthesize, they will not synthesize records for these particular hostnames and will instead pass through the broken AAAA record.",
      "ja": "このドキュメントの他のセクションに準拠するアルゴリズムは、デュアルスタックネットワークでそのようなホスト名を正しく処理しますが、NAT64およびDNS64を使用するIPv6のみのネットワークでは必ずしも正しく機能しません。 DNS64再帰リゾルバは、権威のあるネームサーバーがAAAAレコードの否定（ \"no error no answer\"）応答を送信して合成するため、これらの特定のホスト名のレコードを合成せず、代わりに壊れたAAAAレコードを通過します。"
    },
    {
      "indent": 3,
      "text": "In order to support these scenarios, the client device needs to query the DNS for the A record and then perform local synthesis. Since these types of hostnames are rare and, in order to minimize load on DNS servers, this A query should only be performed when the client has given up on the AAAA records it initially received. This can be achieved by using a longer timeout, referred to as the \"Last Resort Local Synthesis Delay\"; the delay is recommended to be 2 seconds. The timer is started when the last connection attempt is fired. If no connection attempt has succeeded when this timer fires, the device queries the DNS for the IPv4 address and, on reception of a valid A record, treats it as if it were provided by the application (see Section 7.1).",
      "ja": "これらのシナリオをサポートするために、クライアントデバイスはDNSにAレコードを照会し、ローカル合成を実行する必要があります。これらのタイプのホスト名はまれであり、DNSサーバーの負荷を最小限に抑えるために、このAクエリは、クライアントが最初に受信したAAAAレコードをあきらめた場合にのみ実行する必要があります。これは、「最後のリゾートローカル合成遅延」と呼ばれる、より長いタイムアウトを使用することで実現できます。遅延は2秒にすることをお勧めします。タイマーは、最後の接続試行が発生したときに開始されます。このタイマーが作動したときに接続試行が成功しなかった場合、デバイスはIPv4アドレスのDNSを照会し、有効なAレコードを受信すると、アプリケーションによって提供されたものとして処理します（セクション7.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.3. Virtual Private Networks",
      "section_title": true,
      "ja": "7.3. 仮想プライベートネットワーク"
    },
    {
      "indent": 3,
      "text": "Some Virtual Private Networks (VPNs) may be configured to handle DNS queries from the device. The configuration could encompass all queries or a subset such as \"*.internal.example.com\". These VPNs can also be configured to only route part of the IPv4 address space, such as 192.0.2.0/24. However, if an internal hostname resolves to an external IPv4 address, these can cause issues if the underlying network is IPv6-only. As an example, let's assume that \"www.internal.example.com\" has exactly one A record, 198.51.100.42, and no AAAA records. The client will send the DNS query to the company's recursive resolver and that resolver will reply with these records. The device now only has an IPv4 address to connect to and no route to that address. Since the company's resolver does not know the NAT64 prefix of the underlying network, it cannot synthesize the address. Similarly, the underlying network's DNS64 recursive resolver does not know the company's internal addresses, so it cannot resolve the hostname. Because of this, the client device needs to resolve the A record using the company's resolver and then locally synthesize an IPv6 address, as if the resolved IPv4 address were provided by the application (Section 7.1).",
      "ja": "一部の仮想プライベートネットワーク（VPN）は、デバイスからのDNSクエリを処理するように構成されている場合があります。構成には、すべてのクエリまたは「* .internal.example.com」などのサブセットを含めることができます。これらのVPNは、192.0.2.0 / 24など、IPv4アドレス空間の一部のみをルーティングするように構成することもできます。ただし、内部ホスト名が外部IPv4アドレスに解決される場合、基盤となるネットワークがIPv6のみの場合、問題が発生する可能性があります。例として、「www.internal.example.com」に1つのAレコード198.51.100.42があり、AAAAレコードがないと仮定します。クライアントはDNSクエリを会社の再帰リゾルバに送信し、そのリゾルバはこれらのレコードで応答します。デバイスには、接続するIPv4アドレスのみがあり、そのアドレスへのルートはありません。会社のリゾルバは、基盤となるネットワークのNAT64プレフィックスを認識していないため、アドレスを合成できません。同様に、基盤となるネットワークのDNS64再帰リゾルバーは会社の内部アドレスを認識しないため、ホスト名を解決できません。このため、クライアントデバイスは、会社のリゾルバーを使用してAレコードを解決し、解決されたIPv4アドレスがアプリケーションによって提供されたかのように、ローカルでIPv6アドレスを合成する必要があります（セクション7.1）。"
    },
    {
      "indent": 0,
      "text": "8. Summary of Configurable Values",
      "section_title": true,
      "ja": "8. 構成可能な値の概要"
    },
    {
      "indent": 3,
      "text": "The values that may be configured as defaults on a client for use in Happy Eyeballs are as follows:",
      "ja": "Happy Eyeballsで使用するためにクライアントのデフォルトとして設定できる値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Resolution Delay (Section 3): The time to wait for a AAAA response after receiving an A response. Recommended to be 50 milliseconds.",
      "ja": "o 解決遅延（セクション3）：A応答を受信した後、AAAA応答を待機する時間。 50ミリ秒にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o First Address Family Count (Section 4): The number of addresses belonging to the first address family (such as IPv6) that should be attempted before attempting another address family. Recommended to be 1; 2 may be used to more aggressively favor a particular address family.",
      "ja": "o 最初のアドレスファミリカウント（セクション4）：別のアドレスファミリを試行する前に試行する必要がある最初のアドレスファミリ（IPv6など）に属するアドレスの数。 1にすることをお勧めします。 2は、特定のアドレスファミリをより積極的に優先するために使用できます。"
    },
    {
      "indent": 3,
      "text": "o Connection Attempt Delay (Section 5): The time to wait between connection attempts in the absence of RTT data. Recommended to be 250 milliseconds.",
      "ja": "o 接続試行遅延（セクション5）：RTTデータがない場合に接続試行の間に待機する時間。 250ミリ秒にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Minimum Connection Attempt Delay (Section 5): The minimum time to wait between connection attempts. Recommended to be 100 milliseconds. MUST NOT be less than 10 milliseconds.",
      "ja": "o 最小接続試行遅延（セクション5）：接続試行間で待機する最小時間。 100ミリ秒にすることをお勧めします。 10ミリ秒未満であってはなりません。"
    },
    {
      "indent": 3,
      "text": "o Maximum Connection Attempt Delay (Section 5): The maximum time to wait between connection attempts. Recommended to be 2 seconds.",
      "ja": "o 最大接続試行遅延（セクション5）：接続試行間で待機する最大時間。 2秒にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Last Resort Local Synthesis Delay (Section 7.2): The time to wait after starting the last IPv6 attempt and before sending the A query. Recommended to be 2 seconds.",
      "ja": "o Last Resort Local Synthesis Delay（Section 7.2）：最後のIPv6試行を開始してからAクエリを送信するまでの待機時間。 2秒にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The delay values described in this section were determined empirically by measuring the timing of connections on a very wide set of production devices. They were picked to reduce wait times noticed by users while minimizing load on the network. As time passes, it is expected that the properties of networks will evolve. For that reason, it is expected that these values will change over time. Implementors should feel welcome to use different values without changing this specification. Since IPv6 issues are expected to be less common, the delays SHOULD be increased with time as client software is updated.",
      "ja": "このセクションで説明する遅延値は、非常に幅広い製品デバイスの接続のタイミングを測定することにより、経験的に決定されました。これらは、ネットワークの負荷を最小限に抑えながら、ユーザーが気づく待機時間を減らすために選ばれました。時間の経過とともに、ネットワークの特性が進化することが予想されます。そのため、これらの値は時間の経過とともに変化することが予想されます。実装者は、この仕様を変更することなく、さまざまな値を使用することを歓迎します。 IPv6の問題はあまり一般的ではないと予想されるため、クライアントソフトウェアが更新されるにつれて、遅延は時間とともに増加する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "9. Limitations",
      "section_title": true,
      "ja": "9. 制限事項"
    },
    {
      "indent": 3,
      "text": "Happy Eyeballs will handle initial connection failures at the TCP/IP layer; however, other failures or performance issues may still affect the chosen connection.",
      "ja": "Happy Eyeballsは、TCP / IP層での初期接続障害を処理します。ただし、他の障害やパフォーマンスの問題が、選択した接続に影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "9.1. Path Maximum Transmission Unit Discovery",
      "section_title": true,
      "ja": "9.1. パス最大転送ユニットの検出"
    },
    {
      "indent": 3,
      "text": "Since Happy Eyeballs is only active during the initial handshake and TCP does not pass the initial handshake, issues related to MTU can be masked and go unnoticed during Happy Eyeballs. Solving this issue is out of scope of this document. One solution is to use \"Packetization Layer Path MTU Discovery\" [RFC4821].",
      "ja": "Happy Eyeballsは最初のハンドシェイク中にのみアクティブであり、TCPは最初のハンドシェイクを通過しないため、MTUに関連する問題はマスクされ、Happy Eyeballs中に気付かれない可能性があります。この問題の解決は、このドキュメントの範囲外です。 1つの解決策は、「Packetization Layer Path MTU Discovery」[RFC4821]を使用することです。"
    },
    {
      "indent": 0,
      "text": "9.2. Application Layer",
      "section_title": true,
      "ja": "9.2. アプリケーション層"
    },
    {
      "indent": 3,
      "text": "If the DNS returns multiple addresses for different application servers, the application itself may not be operational and functional on all of them. Common examples include Transport Layer Security (TLS) and HTTP.",
      "ja": "DNSが異なるアプリケーションサーバーの複数のアドレスを返す場合、アプリケーション自体がすべてのサーバーで動作および機能していない可能性があります。一般的な例には、トランスポート層セキュリティ（TLS）およびHTTPが含まれます。"
    },
    {
      "indent": 0,
      "text": "9.3. Hiding Operational Issues",
      "section_title": true,
      "ja": "9.3. 運用上の問題を隠す"
    },
    {
      "indent": 3,
      "text": "It has been observed in practice that Happy Eyeballs can hide issues in networks. For example, if a misconfiguration causes IPv6 to consistently fail on a given network while IPv4 is still functional, Happy Eyeballs may impair the operator's ability to notice the issue. It is recommended that network operators deploy external means of monitoring to ensure functionality of all address families.",
      "ja": "ハッピーアイボールはネットワークの問題を隠すことができることが実際に観察されています。たとえば、IPv4がまだ機能しているときに、構成の誤りによりIPv6が特定のネットワークで一貫して失敗する場合、ハッピーアイボールはオペレーターが問題に気付く能力を損なう可能性があります。すべてのアドレスファミリの機能を確保するために、ネットワークオペレータは外部監視手段を導入することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Note that applications should not rely upon a stable hostname-to-address mapping to ensure any security properties, since DNS results may change between queries. Happy Eyeballs may make it more likely that subsequent connections to a single hostname use different IP addresses.",
      "ja": "DNSの結果はクエリ間で変わる可能性があるため、アプリケーションはセキュリティプロパティを保証するために、安定したホスト名からアドレスへのマッピングに依存すべきではないことに注意してください。 Happy Eyeballsは、単一のホスト名への後続の接続で異なるIPアドレスを使用する可能性を高めます。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントでは、IANAアクションは必要ありません。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <https://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<https://www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC6052] Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, \"IPv6 Addressing of IPv4/IPv6 Translators\", RFC 6052, DOI 10.17487/RFC6052, October 2010, <https://www.rfc-editor.org/info/rfc6052>.",
      "ja": "[RFC6052] Bao、C.、Huitema、C.、Bagnulo、M.、Boucadair、M。、およびX. Li、「IPv4 / IPv6トランスレータのIPv6アドレッシング」、RFC 6052、DOI 10.17487 / RFC6052、2010年10月、< https://www.rfc-editor.org/info/rfc6052>。"
    },
    {
      "indent": 3,
      "text": "[RFC6146] Bagnulo, M., Matthews, P., and I. van Beijnum, \"Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers\", RFC 6146, DOI 10.17487/RFC6146, April 2011, <https://www.rfc-editor.org/info/rfc6146>.",
      "ja": "[RFC6146] Bagnulo、M.、Matthews、P。、およびI. van Beijnum、「ステートフルNAT64：IPv6クライアントからIPv4サーバーへのネットワークアドレスおよびプロトコル変換」、RFC 6146、DOI 10.17487 / RFC6146、2011年4月、<https： //www.rfc-editor.org/info/rfc6146>。"
    },
    {
      "indent": 3,
      "text": "[RFC6147] Bagnulo, M., Sullivan, A., Matthews, P., and I. van Beijnum, \"DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers\", RFC 6147, DOI 10.17487/RFC6147, April 2011, <https://www.rfc-editor.org/info/rfc6147>.",
      "ja": "[RFC6147] Bagnulo、M.、Sullivan、A.、Matthews、P。、およびI. van Beijnum、「DNS64：IPv6クライアントからIPv4サーバーへのネットワークアドレス変換のためのDNS拡張機能」、RFC 6147、DOI 10.17487 / RFC6147、4月2011、<https://www.rfc-editor.org/info/rfc6147>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「Computing TCP's Retransmission Timer」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<https：//www.rfc- editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[RFC6535] Huang, B., Deng, H., and T. Savolainen, \"Dual-Stack Hosts Using \"Bump-in-the-Host\" (BIH)\", RFC 6535, DOI 10.17487/RFC6535, February 2012, <https://www.rfc-editor.org/info/rfc6535>.",
      "ja": "[RFC6535] Huang、B.、Deng、H。、およびT. Savolainen、「Bump-in-the-Host（BIH）を使用したデュアルスタックホスト」、RFC 6535、DOI 10.17487 / RFC6535、2012年2月、< https://www.rfc-editor.org/info/rfc6535>。"
    },
    {
      "indent": 3,
      "text": "[RFC6555] Wing, D. and A. Yourtchenko, \"Happy Eyeballs: Success with Dual-Stack Hosts\", RFC 6555, DOI 10.17487/RFC6555, April 2012, <https://www.rfc-editor.org/info/rfc6555>.",
      "ja": "[RFC6555] Wing、D。およびA. Yourtchenko、「Happy Eyeballs：Success with Dual-Stack Hosts」、RFC 6555、DOI 10.17487 / RFC6555、2012年4月、<https://www.rfc-editor.org/info/ rfc6555>。"
    },
    {
      "indent": 3,
      "text": "[RFC6724] Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown, \"Default Address Selection for Internet Protocol Version 6 (IPv6)\", RFC 6724, DOI 10.17487/RFC6724, September 2012, <https://www.rfc-editor.org/info/rfc6724>.",
      "ja": "[RFC6724] Thaler、D.、Ed。、Draves、R.、Matsumoto、A。、およびT. Chown、「インターネットプロトコルバージョン6（IPv6）のデフォルトアドレス選択」、RFC 6724、DOI 10.17487 / RFC6724、2012年9月、<https://www.rfc-editor.org/info/rfc6724>。"
    },
    {
      "indent": 3,
      "text": "[RFC7050] Savolainen, T., Korhonen, J., and D. Wing, \"Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis\", RFC 7050, DOI 10.17487/RFC7050, November 2013, <https://www.rfc-editor.org/info/rfc7050>.",
      "ja": "[RFC7050] Savolainen、T.、Korhonen、J。、およびD. Wing、「IPv6アドレス合成に使用されるIPv6プレフィックスの発見」、RFC 7050、DOI 10.17487 / RFC7050、2013年11月、<https：//www.rfc -editor.org/info/rfc7050>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[DNS-PUSH] Pusateri, T. and S. Cheshire, \"DNS Push Notifications\", Work in Progress, draft-ietf-dnssd-push-13, October 2017.",
      "ja": "[DNS-PUSH] Pusateri、T。およびS. Cheshire、「DNS Push Notifications」、Work in Progress、draft-ietf-dnssd-push-13、2017年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6877] Mawatari, M., Kawashima, M., and C. Byrne, \"464XLAT: Combination of Stateful and Stateless Translation\", RFC 6877, DOI 10.17487/RFC6877, April 2013, <https://www.rfc-editor.org/info/rfc6877>.",
      "ja": "[RFC6877] Mawatari、M.、Kawashima、M。、およびC. Byrne、「464XLAT：Combination of Stateful and Stateless Translation」、RFC 6877、DOI 10.17487 / RFC6877、2013年4月、<https：//www.rfc-editor .org / info / rfc6877>。"
    },
    {
      "indent": 3,
      "text": "[RFC7413] Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP Fast Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014, <https://www.rfc-editor.org/info/rfc7413>.",
      "ja": "[RFC7413] Cheng、Y.、Chu、J.、Radhakrishnan、S。、およびA. Jain、「TCP Fast Open」、RFC 7413、DOI 10.17487 / RFC7413、2014年12月、<https：//www.rfc-editor .org / info / rfc7413>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https://www.rfc-editor.org / info / rfc8200>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Differences from RFC 6555",
      "section_title": true,
      "ja": "付録A. RFC 6555との違い"
    },
    {
      "indent": 3,
      "text": "\"Happy Eyeballs: Success with Dual-Stack Hosts\" [RFC6555] mostly concentrates on how to stagger connections to a hostname that has a AAAA and an A record. This document additionally discusses:",
      "ja": "「Happy Eyeballs：Success with Dual-Stack Hosts [RFC6555]」は、AAAAとAレコードを持つホスト名への接続をずらす方法に主に集中しています。このドキュメントでは、さらに以下について説明します。"
    },
    {
      "indent": 3,
      "text": "o how to perform DNS queries to obtain these addresses",
      "ja": "o DNSクエリを実行してこれらのアドレスを取得する方法"
    },
    {
      "indent": 3,
      "text": "o how to handle multiple addresses from each address family",
      "ja": "o 各アドレスファミリの複数のアドレスを処理する方法"
    },
    {
      "indent": 3,
      "text": "o how to handle DNS updates while connections are being raced",
      "ja": "o 接続が競合している間にDNS更新を処理する方法"
    },
    {
      "indent": 3,
      "text": "o how to leverage historical information",
      "ja": "o 履歴情報を活用する方法"
    },
    {
      "indent": 3,
      "text": "o how to support IPv6-only networks with NAT64 and DNS64",
      "ja": "o NAT64およびDNS64でIPv6のみのネットワークをサポートする方法"
    },
    {
      "indent": 3,
      "text": "Note that a simple implementation of the algorithm described in this document is still compliant with the previous specification [RFC6555]. Implementations should take the new considerations into account when applicable to optimize their behavior.",
      "ja": "このドキュメントで説明されているアルゴリズムの単純な実装は、以前の仕様[RFC6555]に引き続き準拠しています。実装は、動作を最適化するために適用可能な場合、新しい考慮事項を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors thank Dan Wing, Andrew Yourtchenko, and everyone else who worked on the original Happy Eyeballs design [RFC6555], Josh Graessley, Stuart Cheshire, and the rest of team at Apple that helped implement and instrument this algorithm, and Jason Fesler and Paul Saab who helped measure and refine this algorithm. The authors would also like to thank Fred Baker, Nick Chettle, Lorenzo Colitti, Igor Gashinsky, Geoff Huston, Jen Linkova, Paul Hoffman, Philip Homburg, Warren Kumari, Erik Nygren, Jordi Palet Martinez, Rui Paulo, Stephen Strowes, Jinmei Tatuya, Dave Thaler, Joe Touch, and James Woodyatt for their input and contributions.",
      "ja": "著者は、Dan Wing、Andrew Yourtchenko、および元のHappy Eyeballsデザイン[RFC6555]、Josh Graessley、Stuart Cheshire、およびこのアルゴリズムの実装と計測を支援したAppleのその他のチーム、およびJason FeslerとPaulに感謝したこのアルゴリズムの測定と改善に貢献したサーブ。著者は、フレッド・ベイカー、ニック・チェトル、ロレンゾ・コリッティ、イゴール・ガシンスキー、ジェフ・ヒューストン、ジェン・リンコヴァ、ポール・ホフマン、フィリップ・ホンバーグ、ウォーレン・クマリ、エリック・ニグレン、ジョルディ・パレ・マルティネス、ルイ・パウロ、スティーブン・ストローズ、ジンメイ・タトゥヤ、 Dave Thaler、Joe Touch、James Woodyattからの情報提供と貢献。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David Schinazi Apple Inc. 1 Infinite Loop Cupertino, California 95014 United States of America",
      "ja": "David Schinazi Apple Inc. 1 Infinite Loop Cupertino、California 95014アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dschinazi@apple.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tommy Pauly Apple Inc. 1 Infinite Loop Cupertino, California 95014 United States of America",
      "ja": "トミーポーリーアップル社1無限ループクパチーノ、カリフォルニア95014アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: tpauly@apple.com",
      "raw": true,
      "ja": ""
    }
  ]
}