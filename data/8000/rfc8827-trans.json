{
  "title": {
    "text": "RFC 8827 - WebRTC Security Architecture",
    "ja": "RFC 8827 - WebRTCセキュリティアーキテクチャ"
  },
  "number": 8827,
  "created_at": "2021-02-28 15:28:44.830996+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       E. Rescorla\nRequest for Comments: 8827                                       Mozilla\nCategory: Standards Track                                   January 2021\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "WebRTC Security Architecture",
      "ja": "WebRTCセキュリティアーキテクチャ"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines the security architecture for WebRTC, a protocol suite intended for use with real-time applications that can be deployed in browsers -- \"real-time communication on the Web\".",
      "ja": "このドキュメントでは、ブラウザにデプロイできるリアルタイムアプリケーションでの使用を目的としたプロトコルスイートであるWebRTCのセキュリティアーキテクチャを定義します。これは「Webでのリアルタイム通信」です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です。これは、IETFコミュニティのコンセンサスを表しています。パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました。インターネット標準の詳細については、RFC7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8827.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8827で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2021 IETFTrustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれている場合があります。この資料の一部の著作権を管理している人は、IETFトラストにそのような資料の変更を許可する権利を付与していない可能性があります。IETF標準プロセスの外部。そのような資料の著作権を管理する人から適切なライセンスを取得しない限り、このドキュメントをIETF標準プロセスの外部で変更したり、その派生物をIETF標準プロセスの外部で作成したりすることはできません。RFCとして公開するか、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n3.  Trust Model\n  3.1.  Authenticated Entities\n  3.2.  Unauthenticated Entities\n4.  Overview\n  4.1.  Initial Signaling\n  4.2.  Media Consent Verification\n  4.3.  DTLS Handshake\n  4.4.  Communications and Consent Freshness\n5.  SDP Identity Attribute\n  5.1.  Offer/Answer Considerations\n    5.1.1.  Generating the Initial SDP Offer\n    5.1.2.  Generating an SDP Answer\n    5.1.3.  Processing an SDP Offer or Answer\n    5.1.4.  Modifying the Session\n6.  Detailed Technical Description\n  6.1.  Origin and Web Security Issues\n  6.2.  Device Permissions Model\n  6.3.  Communications Consent\n  6.4.  IP Location Privacy\n  6.5.  Communications Security\n7.  Web-Based Peer Authentication\n  7.1.  Trust Relationships: IdPs, APs, and RPs\n  7.2.  Overview of Operation\n  7.3.  Items for Standardization\n  7.4.  Binding Identity Assertions to JSEP Offer/Answer\n        Transactions\n    7.4.1.  Carrying Identity Assertions\n  7.5.  Determining the IdP URI\n    7.5.1.  Authenticating Party\n    7.5.2.  Relying Party\n  7.6.  Requesting Assertions\n  7.7.  Managing User Login\n8.  Verifying Assertions\n  8.1.  Identity Formats\n9.  Security Considerations\n  9.1.  Communications Security\n  9.2.  Privacy\n  9.3.  Denial of Service\n  9.4.  IdP Authentication Mechanism\n    9.4.1.  PeerConnection Origin Check\n    9.4.2.  IdP Well-Known URI\n    9.4.3.  Privacy of IdP-Generated Identities and the Hosting\n            Site\n    9.4.4.  Security of Third-Party IdPs\n      9.4.4.1.  Confusable Characters\n    9.4.5.  Web Security Feature Interactions\n      9.4.5.1.  Popup Blocking\n      9.4.5.2.  Third Party Cookies\n10. IANA Considerations\n11. References\n  11.1.  Normative References\n  11.2.  Informative References\nAcknowledgements\nAuthor's Address",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Real-Time Communications on the Web (RTCWEB) Working Group standardized protocols for real-time communications between Web browsers, generally called \"WebRTC\" [RFC8825]. The major use cases for WebRTC technology are real-time audio and/or video calls, Web conferencing, and direct data transfer. Unlike most conventional real-time systems (e.g., SIP-based [RFC3261] soft phones), WebRTC communications are directly controlled by some Web server, via a JavaScript (JS) API as shown in Figure 1.",
      "ja": "Web上のリアルタイム通信（RTCWEB）ワーキンググループは、一般に「WebRTC」[RFC8825]と呼ばれるWebブラウザ間のリアルタイム通信用のプロトコルを標準化しました。WebRTCテクノロジーの主な使用例は、リアルタイムの音声通話やビデオ通話、Web会議、および直接データ転送です。ほとんどの従来のリアルタイムシステム（SIPベースの[RFC3261]ソフトフォンなど）とは異なり、WebRTC通信は、図1に示すように、JavaScript（JS）APIを介して一部のWebサーバーによって直接制御されます。"
    },
    {
      "indent": 18,
      "text": "          +----------------+\n          |                |\n          |   Web Server   |\n          |                |\n          +----------------+\n              ^        ^\n             /          \\\n     HTTP   /            \\   HTTP\n           /              \\\n          /                \\\n         v                  v\n      JS API              JS API\n+-----------+            +-----------+\n|           |    Media   |           |\n|  Browser  |<---------->|  Browser  |\n|           |            |           |\n+-----------+            +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 1: A Simple WebRTC System",
      "ja": "図1：単純なWebRTCシステム"
    },
    {
      "indent": 3,
      "text": "A more complicated system might allow for inter-domain calling, as shown in Figure 2. The protocol to be used between the domains is not standardized by WebRTC, but given the installed base and the form of the WebRTC API is likely to be something SDP-based like SIP or something like the Extensible Messaging and Presence Protocol (XMPP) [RFC6120].",
      "ja": "図2に示すように、より複雑なシステムではドメイン間呼び出しが可能になる場合があります。ドメイン間で使用されるプロトコルはWebRTCによって標準化されていませんが、インストールベースとWebRTC APIの形式を考えると、SDPのようなものになる可能性があります。-SIPまたはExtensibleMessaging and Presence Protocol（XMPP）[RFC6120]のようなものに基づいています。"
    },
    {
      "indent": 13,
      "text": "+--------------+                +--------------+\n|              | SIP, XMPP, ... |              |\n|  Web Server  |<-------------->|  Web Server  |\n|              |                |              |\n+--------------+                +--------------+\n       ^                                ^\n       |                                |\n HTTP  |                                |  HTTP\n       |                                |\n       v                                v\n       JS API                       JS API\n +-----------+                     +-----------+\n |           |        Media        |           |\n |  Browser  |<------------------->|  Browser  |\n |           |                     |           |\n +-----------+                     +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 2: A Multidomain WebRTC System",
      "ja": "図2：マルチドメインWebRTCシステム"
    },
    {
      "indent": 3,
      "text": "This system presents a number of new security challenges, which are analyzed in [RFC8826]. This document describes a security architecture for WebRTC which addresses the threats and requirements described in that document.",
      "ja": "このシステムは、[RFC8826]で分析されている多くの新しいセキュリティの課題を提示します。このドキュメントでは、そのドキュメントで説明されている脅威と要件に対処するWebRTCのセキュリティアーキテクチャについて説明します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すように、すべて大文字で表示される場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Trust Model",
      "section_title": true,
      "ja": "3. 信頼モデル"
    },
    {
      "indent": 3,
      "text": "The basic assumption of this architecture is that network resources exist in a hierarchy of trust, rooted in the browser, which serves as the user's Trusted Computing Base (TCB). Any security property which the user wishes to have enforced must be ultimately guaranteed by the browser (or transitively by some property the browser verifies). Conversely, if the browser is compromised, then no security guarantees are possible. Note that there are cases (e.g., Internet kiosks) where the user can't really trust the browser that much. In these cases, the level of security provided is limited by how much they trust the browser.",
      "ja": "このアーキテクチャの基本的な前提は、ネットワークリソースが、ユーザーのトラステッドコンピューティングベース（TCB）として機能するブラウザに根ざした信頼の階層に存在することです。ユーザーが適用したいセキュリティプロパティは、最終的にブラウザによって保証される必要があります（または、ブラウザが検証するプロパティによって推移的に保証される必要があります）。逆に、ブラウザが危険にさらされている場合、セキュリティの保証はできません。ユーザーがブラウザをそれほど信頼できない場合があることに注意してください（インターネットキオスクなど）。このような場合、提供されるセキュリティのレベルは、ブラウザをどれだけ信頼するかによって制限されます。"
    },
    {
      "indent": 3,
      "text": "Optimally, we would not rely on trust in any entities other than the browser. However, this is unfortunately not possible if we wish to have a functional system. Other network elements fall into two categories: those which can be authenticated by the browser and thus can be granted permissions to access sensitive resources, and those which cannot be authenticated and thus are untrusted.",
      "ja": "最適には、ブラウザ以外のエンティティへの信頼に依存しません。ただし、機能的なシステムが必要な場合は、残念ながらこれは不可能です。その他のネットワーク要素は、ブラウザで認証できるため機密リソースへのアクセス許可を付与できるものと、認証できないため信頼できないものの2つに分類されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Authenticated Entities",
      "section_title": true,
      "ja": "3.1. 認証されたエンティティ"
    },
    {
      "indent": 3,
      "text": "There are two major classes of authenticated entities in the system:",
      "ja": "システムには、認証されたエンティティの2つの主要なクラスがあります。"
    },
    {
      "indent": 3,
      "text": "Calling services: Web sites whose origin we can verify (optimally via HTTPS, but in some cases because we are on a topologically restricted network, such as behind a firewall, and can infer authentication from firewall behavior).",
      "ja": "通話サービス：発信元を確認できるWebサイト（HTTPS経由が最適ですが、ファイアウォールの背後など、トポロジ的に制限されたネットワーク上にあり、ファイアウォールの動作から認証を推測できる場合もあります）。"
    },
    {
      "indent": 3,
      "text": "Other users: WebRTC peers whose origin we can verify cryptographically (optimally via DTLS-SRTP).",
      "ja": "その他のユーザー：起源を暗号で検証できるWebRTCピア（最適にはDTLS-SRTPを介して）。"
    },
    {
      "indent": 3,
      "text": "Note that merely being authenticated does not make these entities trusted. For instance, just because we can verify that <https://www.example.org/> is owned by Dr. Evil does not mean that we can trust Dr. Evil to access our camera and microphone. However, it gives the user an opportunity to determine whether they wish to trust Dr. Evil or not; after all, if they desire to contact Dr. Evil (perhaps to arrange for ransom payment), it's safe to temporarily give them access to the camera and microphone for the purpose of the call, but they don't want Dr. Evil to be able to access their camera and microphone other than during the call. The point here is that we must first identify other elements before we can determine whether and how much to trust them. Additionally, sometimes we need to identify the communicating peer before we know what policies to apply.",
      "ja": "認証されただけでは、これらのエンティティは信頼されないことに注意してください。たとえば、<https://www.example.org/>がDr. Evilによって所有されていることを確認できたからといって、Dr。Evilがカメラとマイクにアクセスすることを信頼できるとは限りません。ただし、ユーザーはDr.Evilを信頼するかどうかを判断する機会が与えられます。結局のところ、彼らがDr. Evilに連絡したい場合（おそらく身代金の支払いを手配するため）、通話の目的で一時的にカメラとマイクへのアクセスを許可するのは安全ですが、Dr。Evilになりたくないのです。通話中以外はカメラとマイクにアクセスできます。ここでのポイントは、他の要素を信頼するかどうか、そしてどれだけ信頼するかを決定する前に、まず他の要素を特定する必要があるということです。さらに、適用するポリシーを知る前に、通信しているピアを特定する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Unauthenticated Entities",
      "section_title": true,
      "ja": "3.2. 認証されていないエンティティ"
    },
    {
      "indent": 3,
      "text": "Other than the above entities, we are not generally able to identify other network elements; thus, we cannot trust them. This does not mean that it is not possible to have any interaction with them, but it means that we must assume that they will behave maliciously and design a system which is secure even if they do so.",
      "ja": "上記のエンティティ以外では、通常、他のネットワーク要素を特定することはできません。したがって、私たちはそれらを信頼することはできません。これは、彼らとのやり取りが不可能であることを意味するものではありませんが、彼らが悪意を持って行動することを想定し、たとえそうしても安全なシステムを設計する必要があることを意味します。"
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "ja": "4. 概要概要"
    },
    {
      "indent": 3,
      "text": "This section describes a typical WebRTC session and shows how the various security elements interact and what guarantees are provided to the user. The example in this section is a \"best case\" scenario in which we provide the maximal amount of user authentication and media privacy with the minimal level of trust in the calling service. Simpler versions with lower levels of security are also possible and are noted in the text where applicable. It's also important to recognize the tension between security (or performance) and privacy. The example shown here is aimed towards settings where we are more concerned about secure calling than about privacy, but as we shall see, there are settings where one might wish to make different tradeoffs -- this architecture is still compatible with those settings.",
      "ja": "このセクションでは、一般的なWebRTCセッションについて説明し、さまざまなセキュリティ要素がどのように相互作用し、どのような保証がユーザーに提供されるかを示します。このセクションの例は、呼び出しサービスへの最小レベルの信頼で最大量のユーザー認証とメディアプライバシーを提供する「ベストケース」シナリオです。セキュリティレベルの低い単純なバージョンも可能であり、該当する場合は本文に記載されています。セキュリティ（またはパフォーマンス）とプライバシーの間の緊張を認識することも重要です。ここに示す例は、プライバシーよりも安全な通話を重視する設定を対象としていますが、後で説明するように、さまざまなトレードオフを行う必要がある設定があります。このアーキテクチャは、これらの設定と互換性があります。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this example, we assume the topology shown in the figures below. This topology is derived from the topology shown in Figure 1, but separates Alice's and Bob's identities from the process of signaling. Specifically, Alice and Bob have relationships with some Identity Provider (IdP) that supports a protocol (such as OpenID Connect) that can be used to demonstrate their identity to other parties. For instance, Alice might have an account with a social network which she can then use to authenticate to other Web sites without explicitly having an account with those sites; this is a fairly conventional pattern on the Web. Section 7.1 provides an overview of IdPs and the relevant terminology. Alice and Bob might have relationships with different IdPs as well. Note: The IdP mechanism described here has not seen wide adoption. See Section 7 for more on the status of IdP-based authentication.",
      "ja": "この例では、次の図に示すトポロジを想定しています。このトポロジは、図1に示すトポロジから派生していますが、アリスとボブのIDをシグナリングのプロセスから分離しています。具体的には、アリスとボブは、他の関係者にIDを示すために使用できるプロトコル（OpenID Connectなど）をサポートするIDプロバイダー（IdP）と関係があります。たとえば、アリスはソーシャルネットワークのアカウントを持っている場合があります。このアカウントを使用して、他のWebサイトのアカウントを明示的に持たなくても、他のWebサイトへの認証に使用できます。これは、Web上ではかなり一般的なパターンです。セクション7.1は、IdPの概要と関連する用語を提供します。アリスとボブは、異なるIdPとも関係がある可能性があります。注：ここで説明するIdPメカニズムは、広く採用されていません。IdPベースの認証のステータスの詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "This separation of identity provision and signaling isn't particularly important in \"closed world\" cases where Alice and Bob are users on the same social network and have identities based on that domain (Figure 3). However, there are important settings where that is not the case, such as federation (calls from one domain to another; see Figure 4) and calling on untrusted sites, such as where two users who have a relationship via a given social network want to call each other on another, untrusted, site, such as a poker site.",
      "ja": "アリスとボブが同じソーシャルネットワーク上のユーザーであり、そのドメインに基づくIDを持っている「クローズドワールド」の場合、IDの提供とシグナリングのこの分離は特に重要ではありません（図3）。ただし、フェデレーション（あるドメインから別のドメインへの呼び出し。図4を参照）や、特定のソーシャルネットワークを介して関係を持つ2人のユーザーが必要とする信頼できないサイトへの呼び出しなど、そうでない重要な設定があります。ポーカーサイトなど、信頼できない別のサイトでお互いに電話をかけます。"
    },
    {
      "indent": 3,
      "text": "Note that the servers themselves are also authenticated by an external identity service, the SSL/TLS certificate infrastructure (not shown). As is conventional in the Web, all identities are ultimately rooted in that system. For instance, when an IdP makes an identity assertion, the Relying Party consuming that assertion is able to verify because it is able to connect to the IdP via HTTPS.",
      "ja": "サーバー自体も、外部IDサービスであるSSL / TLS証明書インフラストラクチャ（図には示されていません）によって認証されることに注意してください。Webで一般的であるように、すべてのIDは最終的にそのシステムに根ざしています。たとえば、IdPがIDアサーションを作成すると、そのアサーションを消費する証明書利用者は、HTTPS経由でIdPに接続できるため、検証できます。"
    },
    {
      "indent": 15,
      "text": "                +----------------+\n                |                |\n                |     Signaling  |\n                |     Server     |\n                |                |\n                +----------------+\n                    ^        ^\n                   /          \\\n           HTTPS  /            \\   HTTPS\n                 /              \\\n                /                \\\n               v                  v\n            JS API              JS API\n      +-----------+            +-----------+\n      |           |    Media   |           |\nAlice |  Browser  |<---------->|  Browser  | Bob\n      |           | (DTLS+SRTP)|           |\n      +-----------+            +-----------+\n            ^      ^--+     +--^     ^\n            |         |     |        |\n            v         |     |        v\n      +-----------+   |     |  +-----------+\n      |           |<--------+  |           |\n      |   IdP1    |   |        |    IdP2   |\n      |           |   +------->|           |\n      +-----------+            +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 3: A Call with IdP-Based Identity",
      "ja": "図3：IdPベースのIDを使用した呼び出し"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows essentially the same calling scenario but with a call between two separate domains (i.e., a federated case), as in Figure 2. As mentioned above, the domains communicate by some unspecified protocol, and providing separate signaling and identity allows for calls to be authenticated regardless of the details of the inter-domain protocol.",
      "ja": "図4は、基本的に同じ呼び出しシナリオを示していますが、図2のように、2つの別々のドメイン間で呼び出しがあります（つまり、フェデレーションの場合）。前述のように、ドメインは不特定のプロトコルで通信し、別々のシグナリングとIDを提供することで呼び出しが可能になります。ドメイン間プロトコルの詳細に関係なく認証されます。"
    },
    {
      "indent": 5,
      "text": "      +----------------+    Unspecified    +----------------+\n      |                |      protocol     |                |\n      |    Signaling   |<----------------->|    Signaling   |\n      |    Server      |  (SIP, XMPP, ...) |    Server      |\n      |                |                   |                |\n      +----------------+                   +----------------+\n               ^                                   ^\n               |                                   |\n         HTTPS |                                   | HTTPS\n               |                                   |\n               |                                   |\n               v                                   v\n            JS API                               JS API\n      +-----------+                             +-----------+\n      |           |             Media           |           |\nAlice |  Browser  |<--------------------------->|  Browser  | Bob\n      |           |           DTLS+SRTP         |           |\n      +-----------+                             +-----------+\n            ^      ^--+                      +--^     ^\n            |         |                      |        |\n            v         |                      |        v\n      +-----------+   |                      |  +-----------+\n      |           |<-------------------------+  |           |\n      |   IdP1    |   |                         |    IdP2   |\n      |           |   +------------------------>|           |\n      +-----------+                             +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 4: A Federated Call with IdP-Based Identity",
      "ja": "図4：IdPベースのIDを使用したフェデレーションコール"
    },
    {
      "indent": 0,
      "text": "4.1. Initial Signaling",
      "section_title": true,
      "ja": "4.1. 初期シグナリング"
    },
    {
      "indent": 3,
      "text": "For simplicity, assume the topology in Figure 3. Alice and Bob are both users of a common calling service; they both have approved the calling service to make calls (we defer the discussion of device access permissions until later). They are both connected to the calling service via HTTPS and so know the origin with some level of confidence. They also have accounts with some IdP. This sort of identity service is becoming increasingly common in the Web environment (with technologies such as Federated Google Login, Facebook Connect, OAuth, OpenID, WebFinger), and is often provided as a side effect service of a user's ordinary accounts with some service. In this example, we show Alice and Bob using a separate identity service, though the identity service may be the same entity as the calling service or there may be no identity service at all.",
      "ja": "簡単にするために、図3のトポロジを想定します。アリスとボブはどちらも共通の呼び出しサービスのユーザーです。彼らは両方とも電話をかけるために通話サービスを承認しました（私たちは後でまでデバイスアクセス許可の議論を延期します）。どちらもHTTPS経由で通話サービスに接続されているため、ある程度の信頼性を持って発信元を認識しています。また、いくつかのIdPのアカウントもあります。この種のIDサービスは、Web環境（Federated Google Login、Facebook Connect、OAuth、OpenID、WebFingerなどのテクノロジーを使用）でますます一般的になりつつあり、ユーザーの通常のアカウントの副作用サービスとして提供されることがよくあります。この例では、アリスとボブが別々のIDサービスを使用していることを示していますが、IDサービスは呼び出し元サービスと同じエンティティである場合もあれば、IDサービスがまったくない場合もあります。"
    },
    {
      "indent": 3,
      "text": "Alice is logged onto the calling service and decides to call Bob. She can see from the calling service that he is online and the calling service presents a JS UI in the form of a button next to Bob's name which says \"Call\". Alice clicks the button, which initiates a JS callback that instantiates a PeerConnection object. This does not require a security check: JS from any origin is allowed to get this far.",
      "ja": "アリスは通話サービスにログオンし、ボブに電話することにしました。彼女は通話サービスから彼がオンラインであることがわかり、通話サービスは「通話」と書かれたボブの名前の横にあるボタンの形でJSUIを表示します。アリスはボタンをクリックします。これにより、PeerConnectionオブジェクトをインスタンス化するJSコールバックが開始されます。これにはセキュリティチェックは必要ありません。どのオリジンのJSもここまで到達できます。"
    },
    {
      "indent": 3,
      "text": "Once the PeerConnection is created, the calling service JS needs to set up some media. Because this is an audio/video call, it creates a MediaStream with two MediaStreamTracks, one connected to an audio input and one connected to a video input. At this point, the first security check is required: untrusted origins are not allowed to access the camera and microphone, so the browser prompts Alice for permission.",
      "ja": "PeerConnectionが作成されると、呼び出し元サービスJSはいくつかのメディアをセットアップする必要があります。これはオーディオ/ビデオ通話であるため、2つのMediaStreamTracksを使用してMediaStreamを作成します。1つはオーディオ入力に接続され、もう1つはビデオ入力に接続されます。この時点で、最初のセキュリティチェックが必要です。信頼できない発信元はカメラとマイクにアクセスできないため、ブラウザはアリスに許可を求めます。"
    },
    {
      "indent": 3,
      "text": "In the current W3C API, once some streams have been added, Alice's browser + JS generates a signaling message [RFC8829] containing:",
      "ja": "現在のW3CAPIでは、いくつかのストリームが追加されると、アリスのブラウザJSは以下を含むシグナリングメッセージ[RFC8829]を生成します。"
    },
    {
      "indent": 3,
      "text": "* Media channel information",
      "ja": "* メディアチャンネル情報"
    },
    {
      "indent": 3,
      "text": "* Interactive Connectivity Establishment (ICE) [RFC8445] candidates",
      "ja": "* Interactive Connectivity Establishment（ICE）[RFC8445]候補"
    },
    {
      "indent": 3,
      "text": "* A \"fingerprint\" attribute binding the communication to a key pair [RFC5763]. Note that this key may simply be ephemerally generated for this call or specific to this domain, and Alice may have a large number of such keys.",
      "ja": "* 通信をキーペアにバインドする「フィンガープリント」属性[RFC5763]。このキーは、この呼び出しに対して一時的に生成されるか、このドメインに固有である可能性があり、アリスはそのようなキーを多数持っている可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Prior to sending out the signaling message, the PeerConnection code contacts the identity service and obtains an assertion binding Alice's identity to her fingerprint. The exact details depend on the identity service (though as discussed in Section 7 PeerConnection can be agnostic to them), but for now it's easiest to think of as an OAuth token. The assertion may bind other information to the identity besides the fingerprint, but at minimum it needs to bind the fingerprint.",
      "ja": "シグナリングメッセージを送信する前に、PeerConnectionコードはIDサービスに接続し、アリスのIDを指紋にバインドするアサーションを取得します。正確な詳細はIDサービスによって異なります（セクション7で説明したように、PeerConnectionはそれらに依存しない場合があります）が、今のところ、OAuthトークンと考えるのが最も簡単です。アサーションは、フィンガープリント以外の他の情報をIDにバインドする場合がありますが、少なくともフィンガープリントをバインドする必要があります。"
    },
    {
      "indent": 3,
      "text": "This message is sent to the signaling server, e.g., by fetch() [fetch] or by WebSockets [RFC6455], over TLS [RFC8446]. The signaling server processes the message from Alice's browser, determines that this is a call to Bob, and sends a signaling message to Bob's browser (again, the format is currently undefined). The JS on Bob's browser processes it, and alerts Bob to the incoming call and to Alice's identity. In this case, Alice has provided an identity assertion and so Bob's browser contacts Alice's IdP (again, this is done in a generic way so the browser has no specific knowledge of the IdP) to verify the assertion. It is also possible to have IdPs with which the browser has a specific trust relationship, as described in Section 7.1. This allows the browser to display a trusted element in the browser chrome indicating that a call is coming in from Alice. If Alice is in Bob's address book, then this interface might also include her real name, a picture, etc. The calling site will also provide some user interface element (e.g., a button) to allow Bob to answer the call, though this is most likely not part of the trusted UI.",
      "ja": "このメッセージは、TLS [RFC8446]を介して、たとえば、fetch（）[fetch]またはWebSockets [RFC6455]によってシグナリングサーバーに送信されます。シグナリングサーバーは、アリスのブラウザからのメッセージを処理し、これがボブへの呼び出しであると判断し、シグナリングメッセージをボブのブラウザに送信します（ここでも、形式は現在定義されていません）。ボブのブラウザのJSはそれを処理し、ボブに着信とアリスのIDを警告します。この場合、アリスはIDアサーションを提供しているため、ボブのブラウザーはアリスのIdPに接続し（これも一般的な方法で行われるため、ブラウザーはIdPに関する特定の知識を持ちません）、アサーションを検証します。セクション7.1で説明されているように、ブラウザが特定の信頼関係を持つIdPを持つことも可能です。これにより、ブラウザは、アリスからの呼び出しが着信していることを示す信頼できる要素をブラウザのクロムに表示できます。アリスがボブの名簿に載っている場合、このインターフェイスには彼女の本名や写真なども含まれる可能性があります。呼び出し元のサイトには、ボブが電話に応答できるようにするためのユーザーインターフェイス要素（ボタンなど）も用意されています。ほとんどの場合、信頼できるUIの一部ではありません。"
    },
    {
      "indent": 3,
      "text": "If Bob agrees, a PeerConnection is instantiated with the message from Alice's side. Then, a similar process occurs as on Alice's browser: Bob's browser prompts him for device permission, the media streams are created, and a return signaling message containing media information, ICE candidates, and a fingerprint is sent back to Alice via the signaling service. If Bob has a relationship with an IdP, the message will also come with an identity assertion.",
      "ja": "ボブが同意すると、PeerConnectionはアリス側からのメッセージでインスタンス化されます。次に、アリスのブラウザと同様のプロセスが発生します。ボブのブラウザがデバイスの許可を求め、メディアストリームが作成され、メディア情報、ICE候補、および指紋を含む信号メッセージが信号サービスを介してアリスに返送されます。ボブがIdPと関係を持っている場合、メッセージにはIDアサーションも含まれます。"
    },
    {
      "indent": 3,
      "text": "At this point, Alice and Bob each know that the other party wants to have a secure call with them. Based purely on the interface provided by the signaling server, they know that the signaling server claims that the call is from Alice to Bob. This level of security is provided merely by having the fingerprint in the message and having that message received securely from the signaling server. Because the far end sent an identity assertion along with their message, they know that this is verifiable from the IdP as well. Note that if the call is federated, as shown in Figure 4, then Alice is able to verify Bob's identity in a way that is not mediated by either her signaling server or Bob's. Rather, she verifies it directly with Bob's IdP.",
      "ja": "この時点で、アリスとボブはそれぞれ、相手が安全な通話を望んでいることを知っています。シグナリングサーバーによって提供されるインターフェイスのみに基づいて、シグナリングサーバーがアリスからボブへの呼び出しであると主張していることを彼らは知っています。このレベルのセキュリティは、メッセージにフィンガープリントを含め、そのメッセージをシグナリングサーバーから安全に受信することによってのみ提供されます。遠端はメッセージとともにIDアサーションを送信したため、これはIdPからも検証可能であることがわかります。図4に示すように、コールがフェデレーションされている場合、アリスは、シグナリングサーバーまたはボブのいずれによっても仲介されない方法でボブのIDを確認できることに注意してください。むしろ、彼女はそれをボブのIdPで直接検証します。"
    },
    {
      "indent": 3,
      "text": "Of course, the call works perfectly well if either Alice or Bob doesn't have a relationship with an IdP; they just get a lower level of assurance. I.e., they simply have whatever information their calling site claims about the caller/callee's identity. Moreover, Alice might wish to make an anonymous call through an anonymous calling site, in which case she would of course just not provide any identity assertion and the calling site would mask her identity from Bob.",
      "ja": "もちろん、アリスまたはボブのいずれかがIdPと関係がない場合、呼び出しは完全に機能します。彼らはより低いレベルの保証を得るだけです。つまり、発信者/着信者のIDについて発信サイトが主張する情報を持っているだけです。さらに、アリスは匿名の発信サイトを介して匿名の通話を発信したい場合があります。その場合、もちろん彼女はIDアサーションを提供せず、発信サイトはボブから自分のIDをマスクします。"
    },
    {
      "indent": 0,
      "text": "4.2. Media Consent Verification",
      "section_title": true,
      "ja": "4.2. メディアの同意の検証"
    },
    {
      "indent": 3,
      "text": "As described in [RFC8826], Section 4.2, media consent verification is provided via ICE. Thus, Alice and Bob perform ICE checks with each other. At the completion of these checks, they are ready to send non-ICE data.",
      "ja": "[RFC8826]のセクション4.2で説明されているように、メディアの同意の確認はICEを介して提供されます。したがって、アリスとボブは互いにICEチェックを実行します。これらのチェックが完了すると、ICE以外のデータを送信する準備が整います。"
    },
    {
      "indent": 3,
      "text": "At this point, Alice knows that (a) Bob (assuming he is verified via his IdP) or someone else who the signaling service is claiming is Bob is willing to exchange traffic with her and (b) either Bob is at the IP address which she has verified via ICE or there is an attacker who is on-path to that IP address detouring the traffic. Note that it is not possible for an attacker who is on-path between Alice and Bob but not attached to the signaling service to spoof these checks because they do not have the ICE credentials. Bob has the same security guarantees with respect to Alice.",
      "ja": "この時点で、アリスは、（a）ボブ（IdPを介して検証されていると仮定）またはシグナリングサービスが主張している他の誰かがボブが彼女とトラフィックを交換する意思があること、および（b）ボブがIPアドレスにいることを知っています。彼女はICEを介して確認したか、トラフィックを迂回してそのIPアドレスへのパス上にいる攻撃者がいます。アリスとボブの間を通過しているが、シグナリングサービスに接続していない攻撃者は、ICE資格情報を持っていないため、これらのチェックをスプーフィングすることはできないことに注意してください。ボブは、アリスに関して同じセキュリティ保証を持っています。"
    },
    {
      "indent": 0,
      "text": "4.3. DTLS Handshake",
      "section_title": true,
      "ja": "4.3. DTLSハンドシェイク"
    },
    {
      "indent": 3,
      "text": "Once the requisite ICE checks have completed, Alice and Bob can set up a secure channel or channels. This is performed via DTLS [RFC6347] and DTLS-SRTP [RFC5763] keying for SRTP [RFC3711] for the media channel and the Stream Control Transmission Protocol (SCTP) over DTLS [RFC8261] for data channels. Specifically, Alice and Bob perform a DTLS handshake on every component which has been established by ICE. The total number of channels depends on the amount of muxing; in the most likely case, we are using both RTP/RTCP mux and muxing multiple media streams on the same channel, in which case there is only one DTLS handshake. Once the DTLS handshake has completed, the keys are exported [RFC5705] and used to key SRTP for the media channels.",
      "ja": "必要なICEチェックが完了すると、アリスとボブは1つまたは複数の安全なチャネルを設定できます。これは、メディアチャネルのSRTP [RFC3711]のDTLS [RFC6347]およびDTLS-SRTP [RFC5763]キーイングと、データチャネルのDTLS [RFC8261]を介したストリーム制御伝送プロトコル（SCTP）を介して実行されます。具体的には、アリスとボブは、ICEによって確立されたすべてのコンポーネントに対してDTLSハンドシェイクを実行します。チャネルの総数は、多重化の量によって異なります。最も可能性の高いケースでは、RTP / RTCPマルチプレクサと同じチャネル上の複数のメディアストリームのマルチプレクサの両方を使用しています。この場合、DTLSハンドシェイクは1つだけです。DTLSハンドシェイクが完了すると、キーがエクスポートされ[RFC5705]、メディアチャネルのSRTPのキーイングに使用されます。"
    },
    {
      "indent": 3,
      "text": "At this point, Alice and Bob know that they share a set of secure data and/or media channels with keys which are not known to any third-party attacker. If Alice and Bob authenticated via their IdPs, then they also know that the signaling service is not mounting a man-in-the-middle attack on their traffic. Even if they do not use an IdP, as long as they have minimal trust in the signaling service not to perform a man-in-the-middle attack, they know that their communications are secure against the signaling service as well (i.e., that the signaling service cannot mount a passive attack on the communications).",
      "ja": "この時点で、アリスとボブは、サードパーティの攻撃者に知られていないキーと安全なデータやメディアチャネルのセットを共有していることを知っています。アリスとボブがIdPを介して認証された場合、シグナリングサービスがトラフィックに中間者攻撃を仕掛けていないこともわかります。IdPを使用しない場合でも、中間者攻撃を実行しないようにシグナリングサービスに最小限の信頼を置いている限り、通信はシグナリングサービスに対しても安全であることを知っています（つまり、シグナリングサービスは、通信に受動的攻撃を仕掛けることはできません）。"
    },
    {
      "indent": 0,
      "text": "4.4. Communications and Consent Freshness",
      "section_title": true,
      "ja": "4.4. コミュニケーションと同意の鮮度"
    },
    {
      "indent": 3,
      "text": "From a security perspective, everything from here on in is a little anticlimactic: Alice and Bob exchange data protected by the keys negotiated by DTLS. Because of the security guarantees discussed in the previous sections, they know that the communications are encrypted and authenticated.",
      "ja": "セキュリティの観点から、これ以降のすべては少し反気候的です。アリスとボブは、DTLSによってネゴシエートされたキーによって保護されたデータを交換します。前のセクションで説明したセキュリティ保証により、通信が暗号化および認証されていることがわかります。"
    },
    {
      "indent": 3,
      "text": "The one remaining security property we need to establish is \"consent freshness\", i.e., allowing Alice to verify that Bob is still prepared to receive her communications so that Alice does not continue to send large traffic volumes to entities which went abruptly offline. ICE specifies periodic Session Traversal Utilities for NAT (STUN) keepalives but only if media is not flowing. Because the consent issue is more difficult here, we require WebRTC implementations to periodically send keepalives using the consent freshness mechanism specified in [RFC7675]. If a keepalive fails and no new ICE channels can be established, then the session is terminated.",
      "ja": "確立する必要のある残りのセキュリティプロパティの1つは、「同意の鮮度」です。つまり、アリスが突然オフラインになったエンティティに大量のトラフィックを送信し続けないように、ボブが通信を受信する準備ができていることをアリスが確認できるようにします。ICEは、NAT（STUN）キープアライブの定期的なセッショントラバーサルユーティリティを指定しますが、メディアが流れていない場合に限ります。ここでは同意の問題がより難しいため、[RFC7675]で指定されている同意の鮮度メカニズムを使用してキープアライブを定期的に送信するWebRTC実装が必要です。キープアライブが失敗し、新しいICEチャネルを確立できない場合、セッションは終了します。"
    },
    {
      "indent": 0,
      "text": "5. SDP Identity Attribute",
      "section_title": true,
      "ja": "5. SDPIdentity属性"
    },
    {
      "indent": 3,
      "text": "The SDP \"identity\" attribute is a session-level attribute that is used by an endpoint to convey its identity assertion to its peer. The identity-assertion value is encoded as base64, as described in Section 4 of [RFC4648].",
      "ja": "SDPの「identity」属性は、エンドポイントがIDアサーションをピアに伝達するために使用するセッションレベルの属性です。[RFC4648]のセクション4で説明されているように、IDアサーション値はbase64としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "The procedures in this section are based on the assumption that the identity assertion of an endpoint is bound to the fingerprints of the endpoint. This does not preclude the definition of alternative means of binding an assertion to the endpoint, but such means are outside the scope of this specification.",
      "ja": "このセクションの手順は、エンドポイントのIDアサーションがエンドポイントのフィンガープリントにバインドされているという前提に基づいています。これは、アサーションをエンドポイントにバインドする代替手段の定義を排除するものではありませんが、そのような手段はこの仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "The semantics of multiple \"identity\" attributes within an offer or answer are undefined. Implementations SHOULD only include a single \"identity\" attribute in an offer or answer, and Relying Parties MAY elect to ignore all but the first \"identity\" attribute.",
      "ja": "オファーまたはアンサー内の複数の「ID」属性のセマンティクスは定義されていません。実装は、オファーまたはアンサーに単一の「アイデンティティ」属性のみを含める必要があり、依拠当事者は、最初の「アイデンティティ」属性を除くすべてを無視することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Name: identity",
      "ja": "名前：アイデンティティ"
    },
    {
      "indent": 3,
      "text": "Value: identity-assertion",
      "ja": "値：アイデンティティアサーション"
    },
    {
      "indent": 3,
      "text": "Usage Level: session",
      "ja": "使用レベル：セッション"
    },
    {
      "indent": 3,
      "text": "Charset Dependent: no",
      "ja": "文字セットに依存：いいえ"
    },
    {
      "indent": 3,
      "text": "Default Value: N/A",
      "ja": "デフォルト値：N / A"
    },
    {
      "indent": 3,
      "text": "Syntax:",
      "ja": "構文："
    },
    {
      "indent": 4,
      "text": "identity-assertion       = identity-assertion-value\n                           *(SP identity-extension)\nidentity-assertion-value = base64\nidentity-extension       = extension-name [ \"=\" extension-value ]\nextension-name           = token\nextension-value          = 1*(%x01-09 / %x0b-0c / %x0e-3a / %x3c-ff)\n                           ; byte-string from [RFC4566]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "<ALPHA and DIGIT as defined in [RFC4566]>\n<base64 as defined in [RFC4566]>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 4,
      "text": "a=identity:\\\n  eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\\\n  In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\\\n  IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\\\n  aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "|  Note that long lines in the example are folded to meet the\n|  column width constraints of this document; the backslash (\"\\\")\n|  at the end of a line, the carriage return that follows, and\n|  whitespace shall be ignored.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This specification does not define any extensions for the attribute.",
      "ja": "この仕様では、属性の拡張は定義されていません。"
    },
    {
      "indent": 3,
      "text": "The identity-assertion value is a JSON encoded string [RFC8259]. The JSON object contains two keys: \"assertion\" and \"idp\". The \"assertion\" key value contains an opaque string that is consumed by the IdP. The \"idp\" key value contains a dictionary with one or two further values that identify the IdP. See Section 7.6 for more details.",
      "ja": "アイデンティティアサーション値は、JSONでエンコードされた文字列[RFC8259]です。JSONオブジェクトには、「assertion」と「idp」の2つのキーが含まれています。「アサーション」キー値には、IdPによって消費される不透明な文字列が含まれています。「idp」キー値には、IdPを識別する1つまたは2つの追加値を持つディクショナリが含まれています。詳細については、セクション7.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1. Offer/Answer Considerations",
      "section_title": true,
      "ja": "5.1. オファー/回答の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section defines the SDP offer/answer [RFC3264] considerations for the SDP \"identity\" attribute.",
      "ja": "このセクションでは、SDPの「ID」属性に関するSDPオファー/アンサー[RFC3264]の考慮事項を定義します。"
    },
    {
      "indent": 3,
      "text": "Within this section, 'initial offer' refers to the first offer in the SDP session that contains an SDP \"identity\" attribute.",
      "ja": "このセクション内で、「最初のオファー」とは、SDP「ID」属性を含むSDPセッションの最初のオファーを指します。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Generating the Initial SDP Offer",
      "section_title": true,
      "ja": "5.1.1. 最初のSDPオファーの生成"
    },
    {
      "indent": 3,
      "text": "When an offerer sends an offer, in order to provide its identity assertion to the peer, it includes an \"identity\" attribute in the offer. In addition, the offerer includes one or more SDP \"fingerprint\" attributes. The \"identity\" attribute MUST be bound to all the \"fingerprint\" attributes in the session description.",
      "ja": "オファー側がオファーを送信すると、そのIDアサーションをピアに提供するために、オファーに「identity」属性が含まれます。さらに、提供者には1つ以上のSDP「フィンガープリント」属性が含まれます。「identity」属性は、セッション記述のすべての「fingerprint」属性にバインドする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Generating an SDP Answer",
      "section_title": true,
      "ja": "5.1.2. SDP回答の生成"
    },
    {
      "indent": 3,
      "text": "If the answerer elects to include an \"identity\" attribute, it follows the same steps as those in Section 5.1.1. The answerer can choose to include or omit an \"identity\" attribute independently, regardless of whether the offerer did so.",
      "ja": "回答者が「ID」属性を含めることを選択した場合、回答者はセクション5.1.1と同じ手順に従います。回答者は、提供者がそうしたかどうかに関係なく、「ID」属性を個別に含めるか省略するかを選択できます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Processing an SDP Offer or Answer",
      "section_title": true,
      "ja": "5.1.3. SDPオファーまたはアンサーの処理"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives an offer or answer that contains an \"identity\" attribute, the answerer can use the attribute information to contact the IdP and verify the identity of the peer. If the identity requires a third-party IdP as described in Section 7.1, then that IdP will need to have been specifically configured. If the identity verification fails, the answerer MUST discard the offer or answer as malformed.",
      "ja": "エンドポイントが「ID」属性を含むオファーまたはアンサーを受信すると、アンサーは属性情報を使用してIdPに接続し、ピアのIDを確認できます。セクション7.1で説明されているようにIDにサードパーティのIdPが必要な場合は、そのIdPを特別に構成する必要があります。本人確認が失敗した場合、回答者はオファーを破棄するか、不正な形式で回答する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Modifying the Session",
      "section_title": true,
      "ja": "5.1.4. セッションの変更"
    },
    {
      "indent": 3,
      "text": "When modifying a session, if the set of fingerprints is unchanged, then the sender MAY send the same \"identity\" attribute. In this case, the established identity MUST be applied to existing DTLS connections as well as new connections established using one of those fingerprints. Note that [RFC8829], Section 5.2.1 requires that each media section use the same set of fingerprints. If a new \"identity\" attribute is received, then the receiver MUST apply that identity to all existing connections.",
      "ja": "セッションを変更するときに、フィンガープリントのセットが変更されていない場合、送信者は同じ「ID」属性を送信できます（MAY）。この場合、確立されたIDは、既存のDTLS接続と、それらのフィンガープリントの1つを使用して確立された新しい接続に適用する必要があります。[RFC8829]のセクション5.2.1では、各メディアセクションで同じ指紋のセットを使用する必要があることに注意してください。新しい「ID」属性を受信した場合、受信者はそのIDを既存のすべての接続に適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the set of fingerprints changes, then the sender MUST either send a new \"identity\" attribute or none at all. Because a change in fingerprints also causes a new DTLS connection to be established, the receiver MUST discard all previously established identities.",
      "ja": "フィンガープリントのセットが変更された場合、送信者は新しい「ID」属性を送信するか、まったく送信しない必要があります。フィンガープリントの変更により新しいDTLS接続も確立されるため、受信者は以前に確立されたIDをすべて破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Detailed Technical Description",
      "section_title": true,
      "ja": "6. 詳細な技術的説明"
    },
    {
      "indent": 0,
      "text": "6.1. Origin and Web Security Issues",
      "section_title": true,
      "ja": "6.1. オリジンとWebセキュリティの問題"
    },
    {
      "indent": 3,
      "text": "The basic unit of permissions for WebRTC is the origin [RFC6454]. Because the security of the origin depends on being able to authenticate content from that origin, the origin can only be securely established if data is transferred over HTTPS [RFC2818]. Thus, clients MUST treat HTTP and HTTPS origins as different permissions domains. Note: This follows directly from the origin security model and is stated here merely for clarity.",
      "ja": "WebRTCのアクセス許可の基本単位は、オリジン[RFC6454]です。オリジンのセキュリティは、そのオリジンからのコンテンツを認証できるかどうかに依存するため、データがHTTPS [RFC2818]を介して転送される場合にのみ、オリジンを安全に確立できます。したがって、クライアントはHTTPとHTTPSの発信元を異なるアクセス許可ドメインとして扱わなければなりません。注：これはオリジンセキュリティモデルに直接準拠しており、わかりやすくするためにここで説明しています。"
    },
    {
      "indent": 3,
      "text": "Many Web browsers currently forbid by default any active mixed content on HTTPS pages. That is, when JavaScript is loaded from an HTTP origin onto an HTTPS page, an error is displayed and the HTTP content is not executed unless the user overrides the error. Any browser which enforces such a policy will also not permit access to WebRTC functionality from mixed content pages (because they never display mixed content). Browsers which allow active mixed content MUST nevertheless disable WebRTC functionality in mixed content settings.",
      "ja": "現在、多くのWebブラウザーは、HTTPSページ上のアクティブな混合コンテンツをデフォルトで禁止しています。つまり、JavaScriptがHTTPオリジンからHTTPSページにロードされると、エラーが表示され、ユーザーがエラーをオーバーライドしない限り、HTTPコンテンツは実行されません。このようなポリシーを適用するブラウザーは、混合コンテンツページからのWebRTC機能へのアクセスも許可しません（混合コンテンツが表示されないため）。それでも、アクティブな混合コンテンツを許可するブラウザは、混合コンテンツ設定でWebRTC機能を無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible for a page which was not mixed content to become mixed content during the duration of the call. The major risk here is that the newly arrived insecure JS might redirect media to a location controlled by the attacker. Implementations MUST either choose to terminate the call or display a warning at that point.",
      "ja": "混合コンテンツではなかったページが、通話中に混合コンテンツになる可能性があることに注意してください。ここでの主なリスクは、新しく到着した安全でないJSが、攻撃者によって制御されている場所にメディアをリダイレクトする可能性があることです。実装は、呼び出しを終了するか、その時点で警告を表示するかを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Also note that the security architecture depends on the keying material not being available to move between origins. However, it is assumed that the identity assertion can be passed to anyone that the page cares to.",
      "ja": "また、セキュリティアーキテクチャは、オリジン間を移動するために使用できないキー情報に依存していることに注意してください。ただし、IDアサーションは、ページが関係するすべての人に渡すことができると想定されています。"
    },
    {
      "indent": 0,
      "text": "6.2. Device Permissions Model",
      "section_title": true,
      "ja": "6.2. デバイス権限モデル"
    },
    {
      "indent": 3,
      "text": "Implementations MUST obtain explicit user consent prior to providing access to the camera and/or microphone. Implementations MUST at minimum support the following two permissions models for HTTPS origins.",
      "ja": "実装は、カメラやマイクへのアクセスを提供する前に、明示的なユーザーの同意を取得する必要があります。実装は、HTTPSオリジンに対して少なくとも次の2つのアクセス許可モデルをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "* Requests for one-time camera/microphone access.",
      "ja": "* カメラ/マイクのワンタイムアクセスのリクエスト。"
    },
    {
      "indent": 3,
      "text": "* Requests for permanent access.",
      "ja": "* 永続的なアクセスのリクエスト。"
    },
    {
      "indent": 3,
      "text": "Because HTTP origins cannot be securely established against network attackers, implementations MUST refuse all permissions grants for HTTP origins.",
      "ja": "HTTPオリジンはネットワーク攻撃者に対して安全に確立できないため、実装はHTTPオリジンに対するすべてのアクセス許可の付与を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition, they SHOULD support requests for access that promise that media from this grant will be sent to a single communicating peer (obviously there could be other requests for other peers), e.g., \"Call customerservice@example.org\". The semantics of this request are that the media stream from the camera and microphone will only be routed through a connection which has been cryptographically verified (through the IdP mechanism or an X.509 certificate in the DTLS-SRTP handshake) as being associated with the stated identity. Note that it is unlikely that browsers would have X.509 certificates, but servers might. Browsers servicing such requests SHOULD clearly indicate that identity to the user when asking for permission. The idea behind this type of permissions is that a user might have a fairly narrow list of peers they are willing to communicate with, e.g., \"my mother\" rather than \"anyone on Facebook\". Narrow permissions grants allow the browser to do that enforcement.",
      "ja": "さらに、「Call customerservice@example.org」のように、この許可からのメディアが単一の通信ピアに送信されることを約束するアクセス要求をサポートする必要があります（明らかに他のピアに対して他の要求がある可能性があります）。このリクエストのセマンティクスは、カメラとマイクからのメディアストリームが、（IdPメカニズムまたはDTLS-SRTPハンドシェイクのX.509証明書を介して）暗号的に検証された接続を介してのみルーティングされることです。アイデンティティを述べた。ブラウザにX.509証明書がある可能性は低いですが、サーバーにはあることに注意してください。このようなリクエストを処理するブラウザは、許可を求めるときにユーザーにそのIDを明確に示す必要があります。このタイプの権限の背後にある考え方は、ユーザーが通信することをいとわないピアのリストがかなり狭い場合があるということです。たとえば、「Facebookの誰でも」ではなく「私の母」です。狭い権限の付与により、ブラウザはその強制を行うことができます。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST provide a mechanism for the requesting JS to relinquish the ability to see or modify the media (e.g., via MediaStream.record()). Combined with secure authentication of the communicating peer, this allows a user to be sure that the calling site is not accessing or modifying their conversion.",
      "ja": "API要件：APIは、要求するJSがメディアを表示または変更する機能を放棄するためのメカニズムを提供する必要があります（たとえば、MediaStream.record（）を介して）。通信するピアの安全な認証と組み合わせることで、ユーザーは、呼び出し元のサイトが変換にアクセスしたり変更したりしていないことを確認できます。"
    },
    {
      "indent": 3,
      "text": "UI Requirement: The UI MUST clearly indicate when the user's camera and microphone are in use. This indication MUST NOT be suppressible by the JS and MUST clearly indicate how to terminate device access, and provide a UI means to immediately stop camera/ microphone input without the JS being able to prevent it.",
      "ja": "UI要件：UIは、ユーザーのカメラとマイクがいつ使用されているかを明確に示す必要があります。この表示はJSによって抑制可能であってはならず、デバイスアクセスを終了する方法を明確に示し、JSがそれを防ぐことができずにカメラ/マイク入力を即座に停止するUI手段を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "UI Requirement: If the UI indication of camera/microphone use is displayed in the browser such that minimizing the browser window would hide the indication, or the JS creating an overlapping window would hide the indication, then the browser SHOULD stop camera and microphone input when the indication is hidden. (Note: This may not be necessary in systems that are non-windows-based but that have good notifications support, such as phones.)",
      "ja": "UI要件：カメラ/マイクの使用のUI表示がブラウザーに表示され、ブラウザーウィンドウを最小化すると表示が非表示になる場合、またはウィンドウを重ねて作成するJSが表示を非表示にする場合、ブラウザーは次の場合にカメラとマイクの入力を停止する必要があります。表示は非表示です。（注：これは、Windowsベースではないが、電話などの通知を適切にサポートしているシステムでは必要ない場合があります。）"
    },
    {
      "indent": 3,
      "text": "* Browsers MUST NOT permit permanent screen or application sharing permissions to be installed as a response to a JS request for permissions. Instead, they must require some other user action such as a permissions setting or an application install experience to grant permission to a site.",
      "ja": "* ブラウザは、JSの権限要求への応答として、永続的な画面またはアプリケーション共有権限のインストールを許可してはなりません（MUSTNOT）。代わりに、サイトにアクセス許可を付与するには、アクセス許可の設定やアプリケーションのインストールエクスペリエンスなどの他のユーザーアクションが必要です。"
    },
    {
      "indent": 3,
      "text": "* Browsers MUST provide a separate dialog request for screen/ application sharing permissions even if the media request is made at the same time as the request for camera and microphone permissions.",
      "ja": "* メディア要求がカメラとマイクの許可の要求と同時に行われた場合でも、ブラウザは画面/アプリケーション共有の許可に対して個別のダイアログ要求を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The browser MUST indicate any windows which are currently being shared in some unambiguous way. Windows which are not visible MUST NOT be shared even if the application is being shared. If the screen is being shared, then that MUST be indicated.",
      "ja": "* ブラウザは、現在共有されているウィンドウを明確な方法で表示する必要があります。表示されていないウィンドウは、アプリケーションが共有されている場合でも共有してはなりません。画面が共有されている場合は、それを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Browsers MAY permit the formation of data channels without any direct user approval. Because sites can always tunnel data through the server, further restrictions on the data channel do not provide any additional security. (See Section 6.3 for a related issue.)",
      "ja": "ブラウザは、ユーザーの直接の承認なしにデータチャネルの形成を許可する場合があります。サイトは常にサーバーを介してデータをトンネリングできるため、データチャネルをさらに制限しても、追加のセキュリティは提供されません。（関連する問題については、セクション6.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "Implementations which support some form of direct user authentication SHOULD also provide a policy by which a user can authorize calls only to specific communicating peers. Specifically, the implementation SHOULD provide the following interfaces/controls:",
      "ja": "何らかの形式の直接ユーザー認証をサポートする実装は、ユーザーが特定の通信ピアに対してのみ通話を許可できるポリシーも提供する必要があります。具体的には、実装は次のインターフェイス/コントロールを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Allow future calls to this verified user.",
      "ja": "* この確認済みユーザーへの今後の呼び出しを許可します。"
    },
    {
      "indent": 3,
      "text": "* Allow future calls to any verified user who is in my system address book (this only works with address book integration, of course).",
      "ja": "* システムのアドレス帳に登録されている確認済みユーザーへの今後の呼び出しを許可します（もちろん、これはアドレス帳の統合でのみ機能します）。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD also provide a different user interface indication when calls are in progress to users whose identities are directly verifiable. Section 6.5 provides more on this.",
      "ja": "実装は、IDが直接検証可能なユーザーに対して通話が進行中の場合に、異なるユーザーインターフェイス表示も提供する必要があります。セクション6.5でこれについて詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "6.3. Communications Consent",
      "section_title": true,
      "ja": "6.3. 通信同意"
    },
    {
      "indent": 3,
      "text": "Browser client implementations of WebRTC MUST implement ICE. Server gateway implementations which operate only at public IP addresses MUST implement either full ICE or ICE-Lite [RFC8445].",
      "ja": "WebRTCのブラウザクライアント実装はICEを実装する必要があります。パブリックIPアドレスでのみ動作するサーバーゲートウェイの実装は、完全なICEまたはICE-Liteのいずれかを実装する必要があります[RFC8445]。"
    },
    {
      "indent": 3,
      "text": "Browser implementations MUST verify reachability via ICE prior to sending any non-ICE packets to a given destination. Implementations MUST NOT provide the ICE transaction ID to JavaScript during the lifetime of the transaction (i.e., during the period when the ICE stack would accept a new response for that transaction). The JS MUST NOT be permitted to control the local ufrag and password, though it of course knows it.",
      "ja": "ブラウザの実装では、ICE以外のパケットを特定の宛先に送信する前に、ICEを介して到達可能性を確認する必要があります。実装は、トランザクションの存続期間中（つまり、ICEスタックがそのトランザクションの新しい応答を受け入れる期間中）にICEトランザクションIDをJavaScriptに提供してはなりません（MUSTNOT）。JSは、もちろんそれを知っていますが、ローカルのufragとパスワードを制御することを許可されてはなりません。"
    },
    {
      "indent": 3,
      "text": "While continuing consent is required, the ICE [RFC8445], Section 11 keepalives use STUN Binding Indications, which are one-way and therefore not sufficient. The current WG consensus is to use ICE Binding Requests for continuing consent freshness. ICE already requires that implementations respond to such requests, so this approach is maximally compatible. A separate document will profile the ICE timers to be used; see [RFC7675].",
      "ja": "継続的な同意が必要ですが、ICE [RFC8445]のセクション11キープアライブでは、STUNバインディング表示が使用されます。これは一方向であるため、十分ではありません。現在のWGのコンセンサスは、同意の鮮度を継続するためにICEバインディングリクエストを使用することです。ICEは、実装がそのような要求に応答することをすでに要求しているため、このアプローチは最大限の互換性があります。別のドキュメントで、使用するICEタイマーのプロファイルを示します。[RFC7675]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.4. IP Location Privacy",
      "section_title": true,
      "ja": "6.4. IPロケーションプライバシー"
    },
    {
      "indent": 3,
      "text": "A side effect of the default ICE behavior is that the peer learns one's IP address, which leaks large amounts of location information. This has negative privacy consequences in some circumstances. The API requirements in this section are intended to mitigate this issue. Note that these requirements are not intended to protect the user's IP address from a malicious site. In general, the site will learn at least a user's server-reflexive address from any HTTP transaction. Rather, these requirements are intended to allow a site to cooperate with the user to hide the user's IP address from the other side of the call. Hiding the user's IP address from the server requires some sort of explicit privacy-preserving mechanism on the client (e.g., Tor Browser <https://www.torproject.org/projects/torbrowser.html.en>) and is out of scope for this specification.",
      "ja": "デフォルトのICE動作の副作用は、ピアが自分のIPアドレスを学習することです。これにより、大量のロケーション情報がリークされます。これは、状況によってはプライバシーに悪影響を及ぼします。このセクションのAPI要件は、この問題を軽減することを目的としています。これらの要件は、悪意のあるサイトからユーザーのIPアドレスを保護することを目的としたものではないことに注意してください。一般に、サイトはHTTPトランザクションから少なくともユーザーのサーバー再帰アドレスを学習します。むしろ、これらの要件は、サイトがユーザーと協力して、ユーザーのIPアドレスを通話の反対側から隠すことを可能にすることを目的としています。サーバーからユーザーのIPアドレスを隠すには、クライアント上で何らかの明示的なプライバシー保護メカニズム（Tor Browser <https://www.torproject.org/projects/torbrowser.html.en>など）が必要であり、範囲外です。この仕様の場合。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST provide a mechanism to allow the JS to suppress ICE negotiation (though perhaps to allow candidate gathering) until the user has decided to answer the call. (Note: Determining when the call has been answered is a question for the JS.) This enables a user to prevent a peer from learning their IP address if they elect not to answer a call and also from learning whether the user is online.",
      "ja": "API要件：APIは、ユーザーが呼び出しに応答することを決定するまで、JSがICEネゴシエーションを抑制できるようにするメカニズムを提供する必要があります（おそらく候補者の収集を許可するため）。（注：通話に応答したかどうかを判断することはJSの質問です。）これにより、ユーザーは、通話に応答しないことを選択した場合にピアがIPアドレスを学習するのを防ぎ、ユーザーがオンラインであるかどうかを学習することもできません。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST provide a mechanism for the calling application JS to indicate that only TURN candidates are to be used. This prevents the peer from learning one's IP address at all. This mechanism MUST also permit suppression of the related address field, since that leaks local addresses.",
      "ja": "API要件：APIは、呼び出し元のアプリケーションJSが、TURN候補のみが使用されることを示すメカニズムを提供する必要があります。これにより、ピアが自分のIPアドレスをまったく学習できなくなります。このメカニズムは、ローカルアドレスをリークするため、関連するアドレスフィールドの抑制も許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST provide a mechanism for the calling application to reconfigure an existing call to add non-TURN candidates. Taken together, this and the previous requirement allow ICE negotiation to start immediately on incoming call notification, thus reducing post-dial delay, but also to avoid disclosing the user's IP address until they have decided to answer. They also allow users to completely hide their IP address for the duration of the call. Finally, they allow a mechanism for the user to optimize performance by reconfiguring to allow non-TURN candidates during an active call if the user decides they no longer need to hide their IP address.",
      "ja": "API要件：APIは、呼び出し元のアプリケーションが既存の呼び出しを再構成して非TURN候補を追加するためのメカニズムを提供する必要があります。まとめると、この要件と前の要件により、着信コール通知でICEネゴシエーションをすぐに開始できるため、ダイヤル後の遅延が減少しますが、応答するまでユーザーのIPアドレスが開示されることも回避できます。また、ユーザーは通話中にIPアドレスを完全に隠すことができます。最後に、ユーザーがIPアドレスを非表示にする必要がなくなったと判断した場合に、アクティブな通話中に非TURN候補を許可するように再構成することにより、ユーザーがパフォーマンスを最適化するメカニズムを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note that some enterprises may operate proxies and/or NATs designed to hide internal IP addresses from the outside world. WebRTC provides no explicit mechanism to allow this function. Either such enterprises need to proxy the HTTP/HTTPS and modify the SDP and/or the JS, or there needs to be browser support to set the \"TURN-only\" policy regardless of the site's preferences.",
      "ja": "一部の企業は、内部IPアドレスを外部から隠すように設計されたプロキシやNATを運用している場合があることに注意してください。WebRTCは、この機能を可能にする明示的なメカニズムを提供していません。このような企業は、HTTP / HTTPSをプロキシして、SDPやJSを変更するか、サイトの設定に関係なく「TURN-only」ポリシーを設定するためのブラウザサポートが必要です。"
    },
    {
      "indent": 3,
      "text": "Note: These requirements are intended to allow sites to conceal the user's IP address from the peer. For guidance on concealing the user's IP address from the calling site see [RFC8828].",
      "ja": "注：これらの要件は、サイトがユーザーのIPアドレスをピアから隠すことができるようにすることを目的としています。発信側サイトからユーザーのIPアドレスを隠すためのガイダンスについては、[RFC8828]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.5. Communications Security",
      "section_title": true,
      "ja": "6.5. 通信セキュリティ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support SRTP [RFC3711]. Implementations MUST support DTLS [RFC6347] and DTLS-SRTP [RFC5763] [RFC5764] for SRTP keying. Implementations MUST support SCTP over DTLS [RFC8261].",
      "ja": "実装はSRTP [RFC3711]をサポートする必要があります。実装は、SRTPキーイング用にDTLS [RFC6347]およびDTLS-SRTP [RFC5763] [RFC5764]をサポートする必要があります。実装は、SCTP over DTLS [RFC8261]をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "All media channels MUST be secured via SRTP and the Secure Real-time Transport Control Protocol (SRTCP). Media traffic MUST NOT be sent over plain (unencrypted) RTP or RTCP; that is, implementations MUST NOT negotiate cipher suites with NULL encryption modes. DTLS-SRTP MUST be offered for every media channel. WebRTC implementations MUST NOT offer SDP security descriptions [RFC4568] or select it if offered. An SRTP Master Key Identifier (MKI) MUST NOT be used.",
      "ja": "すべてのメディアチャネルは、SRTPおよびSecure Real-time Transport Control Protocol（SRTCP）を介して保護する必要があります。メディアトラフィックは、プレーンな（暗号化されていない）RTPまたはRTCPを介して送信してはなりません。つまり、実装はNULL暗号化モードで暗号スイートをネゴシエートしてはなりません（MUSTNOT）。DTLS-SRTPは、すべてのメディアチャネルに提供する必要があります。WebRTC実装は、SDPセキュリティ記述[RFC4568]を提供したり、提供されている場合はそれを選択したりしてはなりません（MUSTNOT）。SRTPマスターキー識別子（MKI）は使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "All data channels MUST be secured via DTLS.",
      "ja": "すべてのデータチャネルは、DTLSを介して保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "All implementations MUST support DTLS 1.2 with the TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 cipher suite and the P-256 curve [FIPS186]. Earlier drafts of this specification required DTLS 1.0 with the cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, and at the time of this writing some implementations do not support DTLS 1.2; endpoints which support only DTLS 1.2 might encounter interoperability issues. The DTLS-SRTP protection profile SRTP_AES128_CM_HMAC_SHA1_80 MUST be supported for SRTP. Implementations MUST favor cipher suites which support Forward Secrecy (FS) over non-FS cipher suites and SHOULD favor Authenticated Encryption with Associated Data (AEAD) over non-AEAD cipher suites. Note: the IETF is in the process of standardizing DTLS 1.3 [TLS-DTLS13].",
      "ja": "すべての実装は、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256暗号スイートとP-256曲線[FIPS186]を備えたDTLS1.2をサポートする必要があります。この仕様の以前のドラフトでは、暗号スイートTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHAを備えたDTLS 1.0が必要でした。この記事の執筆時点では、一部の実装はDTLS1.2をサポートしていません。DTLS 1.2のみをサポートするエンドポイントでは、相互運用性の問題が発生する可能性があります。DTLS-SRTP保護プロファイルSRTP_AES128_CM_HMAC_SHA1_80はSRTPでサポートされている必要があります。実装は、非FS暗号スイートよりもForward Secrecy（FS）をサポートする暗号スイートを優先する必要があり、非AEAD暗号スイートよりも認証付き暗号化と関連データ（AEAD）を優先する必要があります。注：IETFは、DTLS 1.3 [TLS-DTLS13]の標準化を進めています。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST NOT implement DTLS renegotiation and MUST reject it with a \"no_renegotiation\" alert if offered.",
      "ja": "実装はDTLS再ネゴシエーションを実装してはならず、提供された場合は「no_renegotiation」アラートで拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Endpoints MUST NOT implement TLS False Start [RFC7918].",
      "ja": "エンドポイントはTLS不正スタート[RFC7918]を実装してはならない[MUSTNOT]。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST generate a new authentication key pair for every new call by default. This is intended to allow for unlinkability.",
      "ja": "API要件：APIは、デフォルトで、新しい呼び出しごとに新しい認証キーペアを生成する必要があります。これは、リンク解除を可能にすることを目的としています。"
    },
    {
      "indent": 3,
      "text": "API Requirement: The API MUST provide a means to reuse a key pair for calls. This can be used to enable key continuity-based authentication, and could be used to amortize key generation costs.",
      "ja": "API要件：APIは、呼び出しにキーペアを再利用する手段を提供する必要があります。これは、キーの継続性に基づく認証を有効にするために使用でき、キー生成コストを償却するために使用できます。"
    },
    {
      "indent": 3,
      "text": "API Requirement: Unless the user specifically configures an external key pair, different key pairs MUST be used for each origin. (This avoids creating a super-cookie.)",
      "ja": "API要件：ユーザーが外部キーペアを特別に構成しない限り、オリジンごとに異なるキーペアを使用する必要があります。（これにより、スーパーCookieの作成が回避されます。）"
    },
    {
      "indent": 3,
      "text": "API Requirement: When DTLS-SRTP is used, the API MUST NOT permit the JS to obtain the negotiated keying material. This requirement preserves the end-to-end security of the media.",
      "ja": "API要件：DTLS-SRTPを使用する場合、APIは、JSがネゴシエートされたキー情報を取得することを許可してはなりません（MUSTNOT）。この要件は、メディアのエンドツーエンドのセキュリティを維持します。"
    },
    {
      "indent": 3,
      "text": "UI Requirements: A user-oriented client MUST provide an \"inspector\" interface which allows the user to determine the \"security characteristics\" of the media.",
      "ja": "UI要件：ユーザー指向のクライアントは、ユーザーがメディアの「セキュリティ特性」を決定できるようにする「インスペクター」インターフェースを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "The following properties SHOULD be displayed \"up-front\" in the browser chrome, i.e., without requiring the user to ask for them:",
      "ja": "次のプロパティは、ブラウザのChromeで「事前に」表示する必要があります。つまり、ユーザーがプロパティを要求する必要はありません。"
    },
    {
      "indent": 6,
      "text": "* A client MUST provide a user interface through which a user may determine the \"security characteristics\" for currently displayed audio and video stream(s).",
      "ja": "* クライアントは、ユーザーが現在表示されているオーディオおよびビデオストリームの「セキュリティ特性」を決定するためのユーザーインターフェイスを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A client MUST provide a user interface through which a user may determine the \"security characteristics\" for transmissions of their microphone audio and camera video.",
      "ja": "* クライアントは、ユーザーがマイクオーディオとカメラビデオの送信の「セキュリティ特性」を決定するためのユーザーインターフェイスを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the far endpoint was directly verified, either via a third-party verifiable X.509 certificate or via a Web IdP mechanism (see Section 7), the \"security characteristics\" MUST include the verified information. X.509 identities and Web IdP identities have similar semantics and should be displayed in a similar way.",
      "ja": "* サードパーティの検証可能なX.509証明書またはWebIdPメカニズム（セクション7を参照）のいずれかを介して遠方エンドポイントが直接検証された場合、「セキュリティ特性」には検証済みの情報を含める必要があります。X.509IDとWebIdP IDのセマンティクスは類似しているため、同様の方法で表示する必要があります。"
    },
    {
      "indent": 6,
      "text": "The following properties are more likely to require some \"drill-down\" from the user:",
      "ja": "次のプロパティでは、ユーザーによる「ドリルダウン」が必要になる可能性が高くなります。"
    },
    {
      "indent": 6,
      "text": "* The \"security characteristics\" MUST indicate the cryptographic algorithms in use (for example, \"AES-CBC\").",
      "ja": "* 「セキュリティ特性」は、使用中の暗号化アルゴリズム（たとえば、「AES-CBC」）を示さなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The \"security characteristics\" MUST indicate whether FS is provided.",
      "ja": "* 「セキュリティ特性」は、FSが提供されているかどうかを示さなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The \"security characteristics\" MUST include some mechanism to allow an out-of-band verification of the peer, such as a certificate fingerprint or a Short Authentication String (SAS). These are compared by the peers to authenticate one another.",
      "ja": "* 「セキュリティ特性」には、証明書フィンガープリントやShort Authentication String（SAS）など、ピアの帯域外検証を可能にするメカニズムが含まれている必要があります。これらは、相互に認証するためにピアによって比較されます。"
    },
    {
      "indent": 0,
      "text": "7. Web-Based Peer Authentication",
      "section_title": true,
      "ja": "7. Webベースのピア認証"
    },
    {
      "indent": 3,
      "text": "NOTE: The mechanism described in this section was designed relatively early in the RTCWEB process. In retrospect, the WG was too optimistic about the enthusiasm for this kind of mechanism. At the time of publication, it has not been widely adopted or implemented. It appears in this document as a description of the state of the art as of this writing.",
      "ja": "注：このセクションで説明するメカニズムは、RTCWEBプロセスの比較的早い段階で設計されました。振り返ってみると、WGはこの種のメカニズムへの熱意について楽観的すぎました。公開時点では、広く採用または実装されていません。このドキュメントには、この記事の執筆時点での最新技術の説明として記載されています。"
    },
    {
      "indent": 3,
      "text": "In a number of cases, it is desirable for the endpoint (i.e., the browser) to be able to directly identify the endpoint on the other side without trusting the signaling service to which they are connected. For instance, users may be making a call via a federated system where they wish to get direct authentication of the other side. Alternately, they may be making a call on a site which they minimally trust (such as a poker site) but to someone who has an identity on a site they do trust (such as a social network).",
      "ja": "多くの場合、エンドポイント（つまり、ブラウザ）は、接続先のシグナリングサービスを信頼せずに、反対側のエンドポイントを直接識別できることが望ましいです。たとえば、ユーザーが連合システムを介して電話をかけ、相手側の直接認証を取得したい場合があります。または、信頼性が最小限のサイト（ポーカーサイトなど）で電話をかけているが、信頼しているサイト（ソーシャルネットワークなど）でIDを持っている人に電話をかけている場合もあります。"
    },
    {
      "indent": 3,
      "text": "Recently, a number of Web-based identity technologies (OAuth, Facebook Connect, etc.) have been developed. While the details vary, what these technologies share is that they have a Web-based (i.e., HTTP/HTTPS) IdP which attests to Alice's identity. For instance, if Alice has an account at example.org, Alice could use the example.org IdP to prove to others that Alice is alice@example.org. The development of these technologies allows us to separate calling from identity provision: Alice could call you on a poker site but identify herself as alice@example.org.",
      "ja": "最近、多くのWebベースのIDテクノロジー（OAuth、Facebook Connectなど）が開発されました。詳細はさまざまですが、これらのテクノロジーが共有しているのは、アリスのIDを証明するWebベース（つまり、HTTP / HTTPS）のIdPがあることです。たとえば、アリスがexample.orgにアカウントを持っている場合、アリスはexample.org IdPを使用して、アリスがalice@example.orgであることを他の人に証明できます。これらのテクノロジーの開発により、通話とIDの提供を分離することができます。アリスはポーカーサイトであなたに電話をかけることができますが、自分をalice@example.orgとして識別します。"
    },
    {
      "indent": 3,
      "text": "Whatever the underlying technology, the general principle is that the party which is being authenticated is NOT the signaling site but rather the user (and their browser). Similarly, the Relying Party is the browser and not the signaling site. Thus, the browser MUST generate the input to the IdP assertion process and display the results of the verification process to the user in a way which cannot be imitated by the calling site.",
      "ja": "基盤となるテクノロジーが何であれ、一般的な原則は、認証される当事者はシグナリングサイトではなく、ユーザー（およびそのブラウザー）であるということです。同様に、証明書利用者はブラウザであり、シグナリングサイトではありません。したがって、ブラウザはIdPアサーションプロセスへの入力を生成し、呼び出し元のサイトでは模倣できない方法で検証プロセスの結果をユーザーに表示する必要があります。"
    },
    {
      "indent": 3,
      "text": "The mechanisms defined in this document do not require the browser to implement any particular identity protocol or to support any particular IdP. Instead, this document provides a generic interface which any IdP can implement. Thus, new IdPs and protocols can be introduced without change to either the browser or the calling service. This avoids the need to make a commitment to any particular identity protocol, although browsers may opt to directly implement some identity protocols in order to provide superior performance or UI properties.",
      "ja": "このドキュメントで定義されているメカニズムでは、ブラウザが特定のIDプロトコルを実装したり、特定のIdPをサポートしたりする必要はありません。代わりに、このドキュメントは、任意のIdPが実装できる汎用インターフェイスを提供します。したがって、新しいIdPとプロトコルは、ブラウザまたは呼び出し元サービスに変更を加えることなく導入できます。これにより、特定のIDプロトコルにコミットする必要がなくなりますが、ブラウザーは、優れたパフォーマンスまたはUIプロパティを提供するために、一部のIDプロトコルを直接実装することを選択できます。"
    },
    {
      "indent": 0,
      "text": "7.1. Trust Relationships: IdPs, APs, and RPs",
      "section_title": true,
      "ja": "7.1. 信頼関係：IdP、AP、およびRP"
    },
    {
      "indent": 3,
      "text": "Any federated identity protocol has three major participants:",
      "ja": "フェデレーションIDプロトコルには、次の3つの主要な参加者がいます。"
    },
    {
      "indent": 3,
      "text": "Authenticating Party (AP): The entity which is trying to establish its identity.",
      "ja": "認証者（AP）：IDを確立しようとしているエンティティ。"
    },
    {
      "indent": 3,
      "text": "Identity Provider (IdP): The entity which is vouching for the AP's identity.",
      "ja": "IDプロバイダー（IdP）：APのIDを保証しているエンティティ。"
    },
    {
      "indent": 3,
      "text": "Relying Party (RP): The entity which is trying to verify the AP's identity.",
      "ja": "証明書利用者（RP）：APのIDを確認しようとしているエンティティ。"
    },
    {
      "indent": 3,
      "text": "The AP and the IdP have an account relationship of some kind: the AP registers with the IdP and is able to subsequently authenticate directly to the IdP (e.g., with a password). This means that the browser must somehow know which IdP(s) the user has an account relationship with. This can either be something that the user configures into the browser or that is configured at the calling site and then provided to the PeerConnection by the Web application at the calling site. The use case for having this information configured into the browser is that the user may \"log into\" the browser to bind it to some identity. This is becoming common in new browsers. However, it should also be possible for the IdP information to simply be provided by the calling application.",
      "ja": "APとIdPには、ある種のアカウント関係があります。APはIdPに登録し、その後、IdPに対して直接認証できます（パスワードなど）。つまり、ブラウザは、ユーザーがアカウント関係にあるIdPを何らかの方法で認識している必要があります。これは、ユーザーがブラウザーに構成するものか、呼び出し側サイトで構成されてから、呼び出し側サイトのWebアプリケーションによってPeerConnectionに提供されるもののいずれかです。この情報をブラウザに設定するユースケースは、ユーザーがブラウザに「ログイン」して、ブラウザを特定のIDにバインドできることです。これは新しいブラウザで一般的になりつつあります。ただし、IdP情報が呼び出し元のアプリケーションによって単純に提供されることも可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "At a high level, there are two kinds of IdPs:",
      "ja": "大まかに言うと、IdPには次の2種類があります。"
    },
    {
      "indent": 3,
      "text": "Authoritative: IdPs which have verifiable control of some section of the identity space. For instance, in the realm of email, the operator of \"example.com\" has complete control of the namespace ending in \"@example.com\". Thus, \"alice@example.com\" is whoever the operator says it is. Examples of systems with authoritative IdPs include DNSSEC, an identity system for SIP (see [RFC8224]), and Facebook Connect (Facebook identities only make sense within the context of the Facebook system).",
      "ja": "権威：アイデンティティスペースの一部のセクションを検証可能な制御を持つIdP。たとえば、電子メールの領域では、「example.com」のオペレーターが「@ example.com」で終わる名前空間を完全に制御できます。したがって、「alice@example.com」は、オペレーターが言う人です。権限のあるIdPを備えたシステムの例には、DNSSEC、SIPのIDシステム（[RFC8224]を参照）、およびFacebook Connect（Facebook IDはFacebookシステムのコンテキスト内でのみ意味があります）が含まれます。"
    },
    {
      "indent": 3,
      "text": "Third-Party: IdPs which don't have control of their section of the identity space but instead verify users' identities via some unspecified mechanism and then attest to it. Because the IdP doesn't actually control the namespace, RPs need to trust that the IdP is correctly verifying AP identities, and there can potentially be multiple IdPs attesting to the same section of the identity space. Probably the best-known example of a third-party IdP is SSL/TLS certificates, where there are a large number of certificate authorities (CAs) all of whom can attest to any domain name.",
      "ja": "サードパーティ：IDスペースのセクションを制御できないが、代わりに不特定のメカニズムを介してユーザーのIDを検証し、それを証明するIdP。IdPは実際には名前空間を制御しないため、RPはIdPがAP IDを正しく検証していることを信頼する必要があり、IDスペースの同じセクションを証明する複数のIdPが存在する可能性があります。おそらく、サードパーティのIdPの最もよく知られている例は、SSL / TLS証明書です。この証明書には、任意のドメイン名を証明できる多数の認証局（CA）があります。"
    },
    {
      "indent": 3,
      "text": "If an AP is authenticating via an authoritative IdP, then the RP does not need to explicitly configure trust in the IdP at all. The identity mechanism can directly verify that the IdP indeed made the relevant identity assertion (a function provided by the mechanisms in this document), and any assertion it makes about an identity for which it is authoritative is directly verifiable. Note that this does not mean that the IdP might not lie, but that is a trustworthiness judgement that the user can make at the time they look at the identity.",
      "ja": "APが信頼できるIdPを介して認証している場合、RPはIdPの信頼を明示的に構成する必要はまったくありません。IDメカニズムは、IdPが実際に関連するIDアサーション（このドキュメントのメカニズムによって提供される機能）を作成したことを直接検証でき、権限のあるIDについて作成したアサーションは直接検証できます。これは、IdPが嘘をつかない可能性があることを意味するものではありませんが、ユーザーがIDを確認するときに行うことができる信頼性の判断であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "By contrast, if an AP is authenticating via a third-party IdP, the RP needs to explicitly trust that IdP (hence the need for an explicit trust anchor list in PKI-based SSL/TLS clients). The list of trustable IdPs needs to be configured directly into the browser, either by the user or potentially by the browser manufacturer. This is a significant advantage of authoritative IdPs and implies that if third-party IdPs are to be supported, the potential number needs to be fairly small.",
      "ja": "対照的に、APがサードパーティのIdPを介して認証している場合、RPはそのIdPを明示的に信頼する必要があります（したがって、PKIベースのSSL / TLSクライアントで明示的なトラストアンカーリストが必要です）。信頼できるIdPのリストは、ユーザーが、または場合によってはブラウザーの製造元が、ブラウザーに直接構成する必要があります。これは信頼できるIdPの重要な利点であり、サードパーティのIdPをサポートする場合は、潜在的な数をかなり少なくする必要があることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.2. Overview of Operation",
      "section_title": true,
      "ja": "7.2. 操作の概要"
    },
    {
      "indent": 3,
      "text": "In order to provide security without trusting the calling site, the PeerConnection component of the browser must interact directly with the IdP. The details of the mechanism are described in the W3C API specification, but the general idea is that the PeerConnection component downloads JS from a specific location on the IdP dictated by the IdP domain name. That JS (the \"IdP proxy\") runs in an isolated security context within the browser, and the PeerConnection talks to it via a secure message passing channel.",
      "ja": "呼び出し元のサイトを信頼せずにセキュリティを提供するには、ブラウザのPeerConnectionコンポーネントがIdPと直接対話する必要があります。メカニズムの詳細はW3CAPI仕様に記載されていますが、一般的な考え方は、PeerConnectionコンポーネントがIdPドメイン名で指定されたIdP上の特定の場所からJSをダウンロードすることです。そのJS（「IdPプロキシ」）はブラウザ内の分離されたセキュリティコンテキストで実行され、PeerConnectionは安全なメッセージパッシングチャネルを介してJSと通信します。"
    },
    {
      "indent": 3,
      "text": "Note that there are two logically separate functions here:",
      "ja": "ここには、論理的に分離された2つの関数があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "* Identity assertion generation.",
      "ja": "* IDアサーションの生成。"
    },
    {
      "indent": 3,
      "text": "* Identity assertion verification.",
      "ja": "* IDアサーションの検証。"
    },
    {
      "indent": 3,
      "text": "The same IdP JS \"endpoint\" is used for both functions, but of course a given IdP might behave differently and load new JS to perform one function or the other.",
      "ja": "同じIdPJS「エンドポイント」が両方の機能に使用されますが、もちろん、特定のIdPの動作が異なり、新しいJSをロードしていずれかの機能を実行する場合があります。"
    },
    {
      "indent": 8,
      "text": "+--------------------------------------+\n| Browser                              |\n|                                      |\n| +----------------------------------+ |\n| | https://calling-site.example.com | |\n| |                                  | |\n| |        Calling JS Code           | |\n| |               ^                  | |\n| +---------------|------------------+ |\n|                 | API Calls          |\n|                 v                    |\n|          PeerConnection              |\n|                 ^                    |\n|                 | API Calls          |\n|     +-----------|-------------+      |   +---------------+\n|     |           v             |      |   |               |\n|     |       IdP Proxy         |<-------->|   Identity    |\n|     |                         |      |   |   Provider    |\n|     | https://idp.example.org |      |   |               |\n|     +-------------------------+      |   +---------------+\n|                                      |\n+--------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the PeerConnection object wants to interact with the IdP, the sequence of events is as follows:",
      "ja": "PeerConnectionオブジェクトがIdPと対話する場合、イベントのシーケンスは次のようになります。"
    },
    {
      "indent": 3,
      "text": "1. The browser (the PeerConnection component) instantiates an IdP proxy. This allows the IdP to load whatever JS is necessary into the proxy. The resulting code runs in the IdP's security context.",
      "ja": "1. ブラウザ（PeerConnectionコンポーネント）はIdPプロキシをインスタンス化します。これにより、IdPは必要なJSをプロキシにロードできます。結果のコードは、IdPのセキュリティコンテキストで実行されます。"
    },
    {
      "indent": 3,
      "text": "2. The IdP registers an object with the browser that conforms to the API defined in [webrtc-api].",
      "ja": "2. IdPは、[webrtc-api]で定義されているAPIに準拠するオブジェクトをブラウザーに登録します。"
    },
    {
      "indent": 3,
      "text": "3. The browser invokes methods on the object registered by the IdP proxy to create or verify identity assertions.",
      "ja": "3. ブラウザは、IdPプロキシによって登録されたオブジェクトのメソッドを呼び出して、IDアサーションを作成または検証します。"
    },
    {
      "indent": 3,
      "text": "This approach allows us to decouple the browser from any particular IdP; the browser need only know how to load the IdP's JavaScript -- the location of which is determined based on the IdP's identity -- and to call the generic API for requesting and verifying identity assertions. The IdP provides whatever logic is necessary to bridge the generic protocol to the IdP's specific requirements. Thus, a single browser can support any number of identity protocols, including being forward compatible with IdPs which did not exist at the time the browser was written.",
      "ja": "このアプローチにより、ブラウザを特定のIdPから切り離すことができます。ブラウザは、IdPのJavaScript（その場所はIdPのIDに基づいて決定されます）をロードする方法と、IDアサーションを要求および検証するための汎用APIを呼び出す方法を知っているだけで済みます。IdPは、汎用プロトコルをIdPの特定の要件にブリッジするために必要なロジックを提供します。したがって、単一のブラウザーは、ブラウザーの作成時に存在しなかったIdPとの上位互換性を含め、任意の数のIDプロトコルをサポートできます。"
    },
    {
      "indent": 0,
      "text": "7.3. Items for Standardization",
      "section_title": true,
      "ja": "7.3. 標準化項目"
    },
    {
      "indent": 3,
      "text": "There are two parts to this work:",
      "ja": "この作業には2つの部分があります。"
    },
    {
      "indent": 3,
      "text": "* The precise information from the signaling message that must be cryptographically bound to the user's identity and a mechanism for carrying assertions in JavaScript Session Establishment Protocol (JSEP) messages. This is specified in Section 7.4.",
      "ja": "* ユーザーのIDに暗号的にバインドする必要があるシグナリングメッセージからの正確な情報と、JavaScriptセッション確立プロトコル（JSEP）メッセージでアサーションを伝送するためのメカニズム。これはセクション7.4で指定されています。"
    },
    {
      "indent": 3,
      "text": "* The interface to the IdP, which is defined in the companion W3C WebRTC API specification [webrtc-api].",
      "ja": "* コンパニオンW3CWebRTCAPI仕様[webrtc-api]で定義されているIdPへのインターフェース。"
    },
    {
      "indent": 3,
      "text": "The WebRTC API specification also defines JavaScript interfaces that the calling application can use to specify which IdP to use. That API also provides access to the assertion-generation capability and the status of the validation process.",
      "ja": "WebRTC API仕様では、呼び出し側アプリケーションが使用するIdPを指定するために使用できるJavaScriptインターフェースも定義されています。このAPIは、アサーション生成機能と検証プロセスのステータスへのアクセスも提供します。"
    },
    {
      "indent": 0,
      "text": "7.4. Binding Identity Assertions to JSEP Offer/Answer Transactions",
      "section_title": true,
      "ja": "7.4. IDアサーションをJSEPオファー/アンサートランザクションにバインドする"
    },
    {
      "indent": 3,
      "text": "An identity assertion binds the user's identity (as asserted by the IdP) to the SDP offer/answer exchange and specifically to the media. In order to achieve this, the PeerConnection must provide the DTLS-SRTP fingerprint to be bound to the identity. This is provided as a JavaScript object (also known as a dictionary or hash) with a single \"fingerprint\" key, as shown below:",
      "ja": "IDアサーションは、ユーザーのID（IdPによってアサーションされたもの）をSDPオファー/アンサー交換、特にメディアにバインドします。これを実現するには、PeerConnectionがIDにバインドされるDTLS-SRTPフィンガープリントを提供する必要があります。これは、以下に示すように、単一の「フィンガープリント」キーを持つJavaScriptオブジェクト（辞書またはハッシュとも呼ばれます）として提供されます。"
    },
    {
      "indent": 3,
      "text": "{\n  \"fingerprint\":\n    [\n      { \"algorithm\": \"sha-256\",\n        \"digest\": \"4A:AD:B9:B1:3F:...:E5:7C:AB\" },\n      { \"algorithm\": \"sha-1\",\n        \"digest\": \"74:E9:76:C8:19:...:F4:45:6B\" }\n    ]\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"fingerprint\" value is an array of objects. Each object in the array contains \"algorithm\" and \"digest\" values, which correspond directly to the algorithm and digest values in the \"fingerprint\" attribute of the SDP [RFC8122].",
      "ja": "「指紋」値はオブジェクトの配列です。配列内の各オブジェクトには、SDP [RFC8122]の「fingerprint」属性のアルゴリズムとダイジェスト値に直接対応する「algorithm」と「digest」の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "This object is encoded in a JSON [RFC8259] string for passing to the IdP. The identity assertion returned by the IdP, which is encoded in the \"identity\" attribute, is a JSON object that is encoded as described in Section 7.4.1.",
      "ja": "このオブジェクトは、IdPに渡すためにJSON [RFC8259]文字列でエンコードされます。「identity」属性でエンコードされたIdPによって返されるIDアサーションは、セクション7.4.1で説明されているようにエンコードされたJSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "This structure does not need to be interpreted by the IdP or the IdP proxy. It is consumed solely by the RP's browser. The IdP merely treats it as an opaque value to be attested to. Thus, new parameters can be added to the assertion without modifying the IdP.",
      "ja": "この構造は、IdPまたはIdPプロキシによって解釈される必要はありません。RPのブラウザによってのみ消費されます。IdPは、それを証明される不透明な値として扱うだけです。したがって、IdPを変更せずに、新しいパラメータをアサーションに追加できます。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Carrying Identity Assertions",
      "section_title": true,
      "ja": "7.4.1. IDアサーションの実行"
    },
    {
      "indent": 3,
      "text": "Once an IdP has generated an assertion (see Section 7.6), it is attached to the SDP offer/answer message. This is done by adding a new \"identity\" attribute to the SDP. The sole contents of this value is the identity assertion. The identity assertion produced by the IdP is encoded into a UTF-8 JSON text, then base64-encoded [RFC4648] to produce this string. For example:",
      "ja": "IdPがアサーションを生成すると（セクション7.6を参照）、SDPオファー/アンサーメッセージに添付されます。これは、SDPに新しい「ID」属性を追加することによって行われます。この値の唯一の内容は、IDアサーションです。IdPによって生成されたIDアサーションは、UTF-8 JSONテキストにエンコードされ、次にbase64エンコード[RFC4648]されて、この文字列が生成されます。例えば："
    },
    {
      "indent": 3,
      "text": "v=0 o=- 1181923068 1181923196 IN IP4 ua1.example.com s=example1 c=IN IP4 ua1.example.com a=fingerprint:sha-1 \\ 4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB a=identity:\\ eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\\ In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\\ IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\\ aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9 a=... t=0 0 m=audio 6056 RTP/SAVP 0 a=sendrecv ...",
      "ja": "v = 0 o = -1181923068 1181923196 IN IP4 ua1.example.com s = example1 c = IN IP4 ua1.example.com a = fingerprint：sha-1 \\ 4A：AD：B9：B1：3F：82：18：3B：54：02：12：DF：3E：5D：49：6B：19：E5：7C：AB=アイデンティティ：\\eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\\In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\\IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\\aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9A= ...T=0、M =オーディオ6056RTP/ SAVP 0 a = sendrecv..。"
    },
    {
      "indent": 6,
      "text": "|  Note that long lines in the example are folded to meet the\n|  column width constraints of this document; the backslash (\"\\\")\n|  at the end of a line, the carriage return that follows, and\n|  whitespace shall be ignored.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"identity\" attribute attests to all \"fingerprint\" attributes in the session description. It is therefore a session-level attribute.",
      "ja": "「identity」属性は、セッションの説明にあるすべての「fingerprint」属性を証明します。したがって、これはセッションレベルの属性です。"
    },
    {
      "indent": 3,
      "text": "Multiple \"fingerprint\" values can be used to offer alternative certificates for a peer. The \"identity\" attribute MUST include all \"fingerprint\" values that are included in \"fingerprint\" attributes of the session description.",
      "ja": "複数の「フィンガープリント」値を使用して、ピアに代替証明書を提供できます。「identity」属性には、セッション記述の「fingerprint」属性に含まれるすべての「fingerprint」値が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "The RP browser MUST verify that the in-use certificate for a DTLS connection is in the set of fingerprints returned from the IdP when verifying an assertion.",
      "ja": "RPブラウザーは、アサーションを検証するときに、DTLS接続の使用中の証明書がIdPから返されるフィンガープリントのセットに含まれていることを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5. Determining the IdP URI",
      "section_title": true,
      "ja": "7.5. IdPURIの決定"
    },
    {
      "indent": 3,
      "text": "In order to ensure that the IdP is under control of the domain owner rather than someone who merely has an account on the domain owner's server (e.g., in shared hosting scenarios), the IdP JavaScript is hosted at a deterministic location based on the IdP's domain name. Each IdP proxy instance is associated with two values:",
      "ja": "IdPがドメイン所有者のサーバーにアカウントを持っているだけの人ではなくドメイン所有者の管理下にあることを保証するために（共有ホスティングシナリオなど）、IdPJavaScriptはIdPのドメインに基づいて決定論的な場所でホストされます名前。各IdPプロキシインスタンスは、次の2つの値に関連付けられています。"
    },
    {
      "indent": 3,
      "text": "authority: The authority [RFC3986] at which the IdP's service is hosted.",
      "ja": "権限：IdPのサービスがホストされている権限[RFC3986]。"
    },
    {
      "indent": 3,
      "text": "protocol: The specific IdP protocol which the IdP is using. This is a completely opaque IdP-specific string, but allows an IdP to implement two protocols in parallel. This value may be the empty string. If no value for protocol is provided, a value of \"default\" is used.",
      "ja": "プロトコル：IdPが使用している特定のIdPプロトコル。これは完全に不透明なIdP固有の文字列ですが、IdPが2つのプロトコルを並行して実装できるようにします。この値は空の文字列である可能性があります。プロトコルの値が指定されていない場合は、「デフォルト」の値が使用されます。"
    },
    {
      "indent": 3,
      "text": "Each IdP MUST serve its initial entry page (i.e., the one loaded by the IdP proxy) from a well-known URI [RFC8615]. The well-known URI for an IdP proxy is formed from the following URI components:",
      "ja": "各IdPは、既知のURI [RFC8615]から最初のエントリページ（つまり、IdPプロキシによってロードされたページ）を提供する必要があります。IdPプロキシの既知のURIは、次のURIコンポーネントから形成されます。"
    },
    {
      "indent": 3,
      "text": "1. The scheme, \"https:\". An IdP MUST be loaded using HTTPS [RFC2818].",
      "ja": "1. スキーム、「https：」。IdPは、HTTPS [RFC2818]を使用してロードする必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The authority [RFC3986]. As noted above, the authority MAY contain a non-default port number or userinfo sub-component. Both are removed when determining if an asserted identity matches the name of the IdP.",
      "ja": "2. 権限[RFC3986]。上記のように、機関にはデフォルト以外のポート番号またはuserinfoサブコンポーネントが含まれる場合があります。アサートされたIDがIdPの名前と一致するかどうかを判断するときに、両方が削除されます。"
    },
    {
      "indent": 3,
      "text": "3. The path, starting with \"/.well-known/idp-proxy/\" and appended with the IdP protocol. Note that the separator characters '/' (%2F) and '\\' (%5C) MUST NOT be permitted in the protocol field, lest an attacker be able to direct requests outside of the controlled \"/.well-known/\" prefix. Query and fragment values MAY be used by including '?' or '#' characters.",
      "ja": "3. 「/.well-known/idp-proxy/」で始まり、IdPプロトコルが追加されたパス。攻撃者が制御された「/.well-known/」プレフィックスの外にリクエストを送信できないように、区切り文字「/」（/）および「\\」（\\）をプロトコルフィールドで許可してはならないことに注意してください。クエリ値とフラグメント値は、「？」を含めることで使用できます。または「＃」文字。"
    },
    {
      "indent": 3,
      "text": "For example, for the IdP \"identity.example.com\" and the protocol \"example\", the URL would be:",
      "ja": "たとえば、IdP「identity.example.com」とプロトコル「example」の場合、URLは次のようになります。"
    },
    {
      "indent": 3,
      "text": "https://identity.example.com/.well-known/idp-proxy/example",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The IdP MAY redirect requests to this URL, but they MUST retain the \"https:\" scheme. This changes the effective origin of the IdP, but not the domain of the identities that the IdP is permitted to assert and validate. I.e., the IdP is still regarded as authoritative for the original domain.",
      "ja": "IdPはリクエストをこのURLにリダイレクトできますが、「https：」スキームを保持する必要があります。これにより、IdPの有効な発信元が変更されますが、IdPがアサートおよび検証することを許可されているIDのドメインは変更されません。つまり、IdPは引き続き元のドメインに対して権限があると見なされます。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Authenticating Party",
      "section_title": true,
      "ja": "7.5.1. 認証パーティ"
    },
    {
      "indent": 3,
      "text": "How an AP determines the appropriate IdP domain is out of scope of this specification. In general, however, the AP has some actual account relationship with the IdP, as this identity is what the IdP is attesting to. Thus, the AP somehow supplies the IdP information to the browser. Some potential mechanisms include:",
      "ja": "APが適切なIdPドメインを決定する方法は、この仕様の範囲外です。ただし、一般に、APはIdPと実際のアカウント関係を持っています。これは、このIDがIdPが証明しているものであるためです。したがって、APはどういうわけかIdP情報をブラウザに提供します。いくつかの潜在的なメカニズムは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Provided by the user directly.",
      "ja": "* ユーザーが直接提供します。"
    },
    {
      "indent": 3,
      "text": "* Selected from some set of IdPs known to the calling site (e.g., a button that shows \"Authenticate via Facebook Connect\").",
      "ja": "* 呼び出し元サイトに認識されているIdPのセットから選択されます（たとえば、「Facebook Connect経由で認証」を示すボタン）。"
    },
    {
      "indent": 0,
      "text": "7.5.2. Relying Party",
      "section_title": true,
      "ja": "7.5.2. 依拠当事者"
    },
    {
      "indent": 3,
      "text": "Unlike the AP, the RP need not have any particular relationship with the IdP. Rather, it needs to be able to process whatever assertion is provided by the AP. As the assertion contains the IdP's identity in the \"idp\" field of the JSON-encoded object (see Section 7.6), the URI can be constructed directly from the assertion, and thus the RP can directly verify the technical validity of the assertion with no user interaction. Authoritative assertions need only be verifiable. Third-party assertions also MUST be verified against local policy, as described in Section 8.1.",
      "ja": "APとは異なり、RPはIdPと特別な関係を持つ必要はありません。むしろ、APによって提供されるアサーションを処理できる必要があります。アサーションのJSONエンコードオブジェクトの「idp」フィールドにIdPのIDが含まれているため（セクション7.6を参照）、URIはアサーションから直接構築でき、RPはアサーションの技術的有効性を直接検証できます。ユーザーの操作。信頼できるアサーションは検証可能である必要があります。セクション8.1で説明されているように、サードパーティのアサーションもローカルポリシーに対して検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Requesting Assertions",
      "section_title": true,
      "ja": "7.6. アサーションのリクエスト"
    },
    {
      "indent": 3,
      "text": "The input to the identity assertion generation process is the JSON-encoded object described in Section 7.4 that contains the set of certificate fingerprints the browser intends to use. This string is treated as opaque from the perspective of the IdP.",
      "ja": "IDアサーション生成プロセスへの入力は、セクション7.4で説明されているJSONエンコードされたオブジェクトであり、ブラウザーが使用する予定の証明書フィンガープリントのセットが含まれています。この文字列は、IdPの観点からは不透明として扱われます。"
    },
    {
      "indent": 3,
      "text": "The browser also identifies the origin that the PeerConnection is run in, which allows the IdP to make decisions based on who is requesting the assertion.",
      "ja": "ブラウザは、PeerConnectionが実行されているオリジンも識別します。これにより、IdPは、誰がアサーションを要求しているかに基づいて決定を下すことができます。"
    },
    {
      "indent": 3,
      "text": "An application can optionally provide a user identifier hint when specifying an IdP. This value is a hint that the IdP can use to select amongst multiple identities, or to avoid providing assertions for unwanted identities. The \"username\" is a string that has no meaning to any entity other than the IdP; it can contain any data the IdP needs in order to correctly generate an assertion.",
      "ja": "アプリケーションは、IdPを指定するときに、オプションでユーザーIDヒントを提供できます。この値は、IdPが複数のIDから選択するため、または不要なIDにアサーションを提供しないようにするために使用できるヒントです。「ユーザー名」は、IdP以外のエンティティには意味のない文字列です。アサーションを正しく生成するためにIdPが必要とする任意のデータを含めることができます。"
    },
    {
      "indent": 3,
      "text": "An identity assertion that is successfully provided by the IdP consists of the following information:",
      "ja": "IdPによって正常に提供されるIDアサーションは、次の情報で構成されます。"
    },
    {
      "indent": 3,
      "text": "idp: The domain name of an IdP and the protocol string. This MAY identify a different IdP or protocol from the one that generated the assertion.",
      "ja": "idp：IdPのドメイン名とプロトコル文字列。これは、アサーションを生成したものとは異なるIdPまたはプロトコルを識別する場合があります。"
    },
    {
      "indent": 3,
      "text": "assertion: An opaque value containing the assertion itself. This is only interpretable by the identified IdP or the IdP code running in the client.",
      "ja": "アサーション：アサーション自体を含む不透明な値。これは、識別されたIdPまたはクライアントで実行されているIdPコードによってのみ解釈できます。"
    },
    {
      "indent": 3,
      "text": "Figure 5 shows an example assertion formatted as JSON. In this case, the message has presumably been digitally signed/MACed in some way that the IdP can later verify it, but this is an implementation detail and out of scope of this document.",
      "ja": "図5は、JSONとしてフォーマットされたアサーションの例を示しています。この場合、メッセージはおそらく、IdPが後で確認できるように、何らかの方法でデジタル署名/ MAC処理されていますが、これは実装の詳細であり、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "{\n  \"idp\":{\n    \"domain\": \"example.org\",\n    \"protocol\": \"bogus\"\n  },\n  \"assertion\": \"{\\\"identity\\\":\\\"bob@example.org\\\",\n                 \\\"contents\\\":\\\"abcdefghijklmnopqrstuvwyz\\\",\n                 \\\"signature\\\":\\\"010203040506\\\"}\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 5: Example Assertion",
      "ja": "図5：アサーションの例"
    },
    {
      "indent": 3,
      "text": "For use in signaling, the assertion is serialized into JSON, base64-encoded [RFC4648], and used as the value of the \"identity\" attribute. IdPs SHOULD ensure that any assertions they generate cannot be interpreted in a different context. E.g., they should use a distinct format or have separate cryptographic keys for assertion generation and other purposes. Line breaks are inserted solely for readability.",
      "ja": "シグナリングで使用するために、アサーションはJSONにシリアル化され、base64でエンコードされ[RFC4648]、「identity」属性の値として使用されます。IdPは、生成するアサーションが別のコンテキストで解釈されないようにする必要があります。たとえば、アサーションの生成やその他の目的のために、個別の形式を使用するか、個別の暗号化キーを使用する必要があります。改行は読みやすさのためだけに挿入されています。"
    },
    {
      "indent": 0,
      "text": "7.7. Managing User Login",
      "section_title": true,
      "ja": "7.7. ユーザーログインの管理"
    },
    {
      "indent": 3,
      "text": "In order to generate an identity assertion, the IdP needs proof of the user's identity. It is common practice to authenticate users (using passwords or multi-factor authentication), then use cookies [RFC6265] or HTTP authentication [RFC7617] for subsequent exchanges.",
      "ja": "IDアサーションを生成するために、IdPはユーザーのIDの証明を必要とします。（パスワードまたは多要素認証を使用して）ユーザーを認証し、その後の交換にCookie [RFC6265]またはHTTP認証[RFC7617]を使用するのが一般的な方法です。"
    },
    {
      "indent": 3,
      "text": "The IdP proxy is able to access cookies, HTTP authentication data, or other persistent session data because it operates in the security context of the IdP origin. Therefore, if a user is logged in, the IdP could have all the information needed to generate an assertion.",
      "ja": "IdPプロキシは、IdPオリジンのセキュリティコンテキストで動作するため、Cookie、HTTP認証データ、またはその他の永続的なセッションデータにアクセスできます。したがって、ユーザーがログインしている場合、IdPはアサーションを生成するために必要なすべての情報を持っている可能性があります。"
    },
    {
      "indent": 3,
      "text": "An IdP proxy is unable to generate an assertion if the user is not logged in, or the IdP wants to interact with the user to acquire more information before generating the assertion. If the IdP wants to interact with the user before generating an assertion, the IdP proxy can fail to generate an assertion and instead indicate a URL where login should proceed.",
      "ja": "ユーザーがログインしていない場合、またはIdPがユーザーと対話してアサーションを生成する前に詳細情報を取得したい場合、IdPプロキシはアサーションを生成できません。IdPがアサーションを生成する前にユーザーと対話したい場合、IdPプロキシはアサーションの生成に失敗し、代わりにログインを続行するURLを示すことができます。"
    },
    {
      "indent": 3,
      "text": "The application can then load the provided URL to enable the user to enter credentials. The communication between the application and the IdP is described in [webrtc-api].",
      "ja": "次に、アプリケーションは提供されたURLをロードして、ユーザーが資格情報を入力できるようにします。アプリケーションとIdP間の通信については、[webrtc-api]で説明されています。"
    },
    {
      "indent": 0,
      "text": "8. Verifying Assertions",
      "section_title": true,
      "ja": "8. アサーションの検証"
    },
    {
      "indent": 3,
      "text": "The input to identity validation is the assertion string taken from a decoded \"identity\" attribute.",
      "ja": "ID検証への入力は、デコードされた「ID」属性から取得されたアサーション文字列です。"
    },
    {
      "indent": 3,
      "text": "The IdP proxy verifies the assertion. Depending on the identity protocol, the proxy might contact the IdP server or other servers. For instance, an OAuth-based protocol will likely require using the IdP as an oracle, whereas with a signature-based scheme it might be able to verify the assertion without contacting the IdP, provided that it has cached the relevant public key.",
      "ja": "IdPプロキシはアサーションを検証します。IDプロトコルによっては、プロキシがIdPサーバーまたは他のサーバーに接続する場合があります。たとえば、OAuthベースのプロトコルではIdPをオラクルとして使用する必要がありますが、署名ベースのスキームでは、関連する公開鍵がキャッシュされていれば、IdPに接続せずにアサーションを検証できる場合があります。"
    },
    {
      "indent": 3,
      "text": "Regardless of the mechanism, if verification succeeds, a successful response from the IdP proxy consists of the following information:",
      "ja": "メカニズムに関係なく、検証が成功した場合、IdPプロキシからの正常な応答は次の情報で構成されます。"
    },
    {
      "indent": 3,
      "text": "identity: The identity of the AP from the IdP's perspective. Details of this are provided in Section 8.1.",
      "ja": "アイデンティティ：IdPの観点から見たAPのアイデンティティ。詳細はセクション8.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "contents: The original unmodified string provided by the AP as input to the assertion generation process.",
      "ja": "内容：アサーション生成プロセスへの入力としてAPによって提供された元の変更されていない文字列。"
    },
    {
      "indent": 3,
      "text": "Figure 6 shows an example response, which is JSON-formatted.",
      "ja": "図6は、JSON形式の応答例を示しています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"identity\": \"bob@example.org\",\n  \"contents\": \"{\\\"fingerprint\\\":[ ... ]}\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 6: Example Verification Result",
      "ja": "図6：検証結果の例"
    },
    {
      "indent": 0,
      "text": "8.1. Identity Formats",
      "section_title": true,
      "ja": "8.1. アイデンティティフォーマット"
    },
    {
      "indent": 3,
      "text": "The identity provided from the IdP to the RP browser MUST consist of a string representing the user's identity. This string is in the form \"<user>@<domain>\", where \"user\" consists of any character, and domain is an internationalized domain name [RFC5890] encoded as a sequence of U-labels.",
      "ja": "IdPからRPブラウザに提供されるIDは、ユーザーのIDを表す文字列で構成されている必要があります。この文字列は「<user> @ <domain>」の形式です。「user」は任意の文字で構成され、domainはUラベルのシーケンスとしてエンコードされた国際化ドメイン名[RFC5890]です。"
    },
    {
      "indent": 3,
      "text": "The PeerConnection API MUST check this string as follows:",
      "ja": "PeerConnection APIは、この文字列を次のようにチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If the \"domain\" portion of the string is equal to the domain name of the IdP proxy, then the assertion is valid, as the IdP is authoritative for this domain. Comparison of domain names is done using the label equivalence rule defined in Section 2.3.2.4 of [RFC5890].",
      "ja": "1. 文字列の「ドメイン」部分がIdPプロキシのドメイン名と等しい場合、IdPはこのドメインに対して権限があるため、アサーションは有効です。ドメイン名の比較は、[RFC5890]のセクション2.3.2.4で定義されているラベル同等性ルールを使用して行われます。"
    },
    {
      "indent": 3,
      "text": "2. If the \"domain\" portion of the string is not equal to the domain name of the IdP proxy, then the PeerConnection object MUST reject the assertion unless both:",
      "ja": "2. 文字列の「ドメイン」部分がIdPプロキシのドメイン名と等しくない場合、PeerConnectionオブジェクトは、次の両方がない限り、アサーションを拒否する必要があります。"
    },
    {
      "indent": 7,
      "text": "1. the IdP domain is trusted as an acceptable third-party IdP; and",
      "ja": "1. IdPドメインは、受け入れ可能なサードパーティのIdPとして信頼されています。そして"
    },
    {
      "indent": 7,
      "text": "2. local policy is configured to trust this IdP domain for the domain portion of the identity string.",
      "ja": "2. ローカルポリシーは、ID文字列のドメイン部分に対してこのIdPドメインを信頼するように構成されています。"
    },
    {
      "indent": 3,
      "text": "Any '@' or '%' characters in the \"user\" portion of the identity MUST be escaped according to the \"percent-encoding\" rules defined in Section 2.1 of [RFC3986]. Characters other than '@' and '%' MUST NOT be percent-encoded. For example, with a \"user\" of \"user@133\" and a \"domain\" of \"identity.example.com\", the resulting string will be encoded as \"user%40133@identity.example.com\".",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementations are cautioned to take care when displaying user identities containing escaped '@' characters. If such characters are unescaped prior to display, implementations MUST distinguish between the domain of the IdP proxy and any domain that might be implied by the portion of the \"<user>\" portion that appears after the escaped \"@\" sign.",
      "ja": "エスケープされた「@」文字を含むユーザーIDを表示する場合、実装には注意が必要です。そのような文字が表示前にエスケープされていない場合、実装は、IdPプロキシのドメインと、エスケープされた「@」記号の後に表示される「<user>」部分の部分によって暗示される可能性のあるドメインを区別する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Much of the security analysis of RTCWEB is contained in [RFC8826] or in the discussion of the particular issues above. In order to avoid repetition, this section focuses on (a) residual threats that are not addressed by this document and (b) threats produced by failure/ misbehavior of one of the components in the system.",
      "ja": "RTCWEBのセキュリティ分析の多くは、[RFC8826]または上記の特定の問題の説明に含まれています。繰り返しを避けるために、このセクションでは、（a）このドキュメントで対処されていない残留脅威、および（b）システム内のコンポーネントの1つの障害/誤動作によって生成される脅威に焦点を当てます。"
    },
    {
      "indent": 0,
      "text": "9.1. Communications Security",
      "section_title": true,
      "ja": "9.1. 通信セキュリティ"
    },
    {
      "indent": 3,
      "text": "If HTTPS is not used to secure communications to the signaling server, and the identity mechanism used in Section 7 is not used, then any on-path attacker can replace the DTLS-SRTP fingerprints in the handshake and thus substitute its own identity for that of either endpoint.",
      "ja": "シグナリングサーバーへの通信を保護するためにHTTPSが使用されておらず、セクション7で使用されているIDメカニズムが使用されていない場合、パス上の攻撃者はハンドシェイクのDTLS-SRTPフィンガープリントを置き換えて、自身のIDをいずれかのエンドポイント。"
    },
    {
      "indent": 3,
      "text": "Even if HTTPS is used, the signaling server can potentially mount a man-in-the-middle attack unless implementations have some mechanism for independently verifying keys. The UI requirements in Section 6.5 are designed to provide such a mechanism for motivated/security conscious users, but are not suitable for general use. The identity service mechanisms in Section 7 are more suitable for general use. Note, however, that a malicious signaling service can strip off any such identity assertions, though it cannot forge new ones. Note that all of the third-party security mechanisms available (whether X.509 certificates or a third-party IdP) rely on the security of the third party -- this is of course also true of the user's connection to the Web site itself. Users who wish to assure themselves of security against a malicious IdP can only do so by verifying peer credentials directly, e.g., by checking the peer's fingerprint against a value delivered out of band.",
      "ja": "HTTPSが使用されている場合でも、実装にキーを個別に検証するメカニズムがない限り、シグナリングサーバーはman-in-the-middle攻撃を仕掛ける可能性があります。セクション6.5のUI要件は、意欲的でセキュリティを重視するユーザーにそのようなメカニズムを提供するように設計されていますが、一般的な使用には適していません。セクション7のIDサービスメカニズムは、一般的な使用に適しています。ただし、悪意のあるシグナリングサービスは、新しいIDアサーションを偽造することはできませんが、そのようなIDアサーションを取り除くことができることに注意してください。利用可能なすべてのサードパーティのセキュリティメカニズム（X.509証明書またはサードパーティのIdP）は、サードパーティのセキュリティに依存していることに注意してください。これは、もちろん、Webサイト自体へのユーザーの接続にも当てはまります。悪意のあるIdPに対するセキュリティを確保したいユーザーは、ピアの資格情報を直接確認することによってのみ行うことができます。たとえば、ピアのフィンガープリントを帯域外で配信された値と照合することによってのみ可能です。"
    },
    {
      "indent": 3,
      "text": "In order to protect against malicious content JavaScript, that JavaScript MUST NOT be allowed to have direct access to -- or perform computations with -- DTLS keys. For instance, if content JS were able to compute digital signatures, then it would be possible for content JS to get an identity assertion for a browser's generated key and then use that assertion plus a signature by the key to authenticate a call protected under an ephemeral Diffie-Hellman (DH) key controlled by the content JS, thus violating the security guarantees otherwise provided by the IdP mechanism. Note that it is not sufficient merely to deny the content JS direct access to the keys, as some have suggested doing with the WebCrypto API [webcrypto]. The JS must also not be allowed to perform operations that would be valid for a DTLS endpoint. By far the safest approach is simply to deny the ability to perform any operations that depend on secret information associated with the key. Operations that depend on public information, such as exporting the public key, are of course safe.",
      "ja": "悪意のあるコンテンツのJavaScriptから保護するために、そのJavaScriptがDTLSキーに直接アクセスしたり、DTLSキーを使用して計算を実行したりすることを許可してはなりません（MUSTNOT）。たとえば、コンテンツJSがデジタル署名を計算できた場合、コンテンツJSは、ブラウザで生成されたキーのIDアサーションを取得し、そのアサーションとキーによる署名を使用して、エフェメラルで保護された通話を認証することができます。コンテンツJSによって制御されるDiffie-Hellman（DH）キー。したがって、IdPメカニズムによって提供されるセキュリティ保証に違反します。 WebCrypto API [webcrypto]を使用することを提案しているように、コンテンツJSがキーに直接アクセスすることを拒否するだけでは不十分であることに注意してください。また、JSは、DTLSエンドポイントに有効な操作の実行を許可されてはなりません。最も安全なアプローチは、キーに関連付けられた秘密情報に依存する操作を実行する機能を拒否することです。もちろん、公開鍵のエクスポートなど、公開情報に依存する操作は安全です。"
    },
    {
      "indent": 0,
      "text": "9.2. Privacy",
      "section_title": true,
      "ja": "9.2. プライバシー"
    },
    {
      "indent": 3,
      "text": "The requirements in this document are intended to allow:",
      "ja": "このドキュメントの要件は、次のことを可能にすることを目的としています。"
    },
    {
      "indent": 3,
      "text": "* Users to participate in calls without revealing their location.",
      "ja": "* ユーザーは自分の場所を明かさずに通話に参加できます。"
    },
    {
      "indent": 3,
      "text": "* Potential callees to avoid revealing their location and even presence status prior to agreeing to answer a call.",
      "ja": "* 潜在的な着信者は、電話に応答することに同意する前に、自分の場所やプレゼンスステータスを明らかにすることを避けます。"
    },
    {
      "indent": 3,
      "text": "However, these privacy protections come at a performance cost in terms of using TURN relays and, in the latter case, delaying ICE. Sites SHOULD make users aware of these tradeoffs.",
      "ja": "ただし、これらのプライバシー保護には、TURNリレーの使用、および後者の場合はICEの遅延という点でパフォーマンスが犠牲になります。サイトは、ユーザーにこれらのトレードオフを認識させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the protections provided here assume a non-malicious calling service. As the calling service always knows the user's status and (absent the use of a technology like Tor) their IP address, they can violate the user's privacy at will. Users who wish privacy against the calling sites they are using must use separate privacy-enhancing technologies such as Tor. Combined WebRTC/Tor implementations SHOULD arrange to route the media as well as the signaling through Tor. Currently this will produce very suboptimal performance.",
      "ja": "ここで提供される保護は、悪意のない通話サービスを想定していることに注意してください。呼び出し側サービスは常にユーザーのステータスと（Torなどのテクノロジーを使用しない場合）IPアドレスを知っているため、ユーザーのプライバシーを自由に侵害する可能性があります。使用している通話サイトに対するプライバシーを希望するユーザーは、Torなどの個別のプライバシー強化テクノロジーを使用する必要があります。WebRTC / Torを組み合わせた実装では、メディアとシグナリングをTor経由でルーティングするように調整する必要があります。現在、これは非常に最適ではないパフォーマンスを生み出します。"
    },
    {
      "indent": 3,
      "text": "Additionally, any identifier which persists across multiple calls is potentially a problem for privacy, especially for anonymous calling services. Such services SHOULD instruct the browser to use separate DTLS keys for each call and also to use TURN throughout the call. Otherwise, the other side will learn linkable information that would allow them to correlate the browser across multiple calls. Additionally, browsers SHOULD implement the privacy-preserving CNAME generation mode of [RFC7022].",
      "ja": "さらに、複数の通話にわたって存続する識別子は、プライバシー、特に匿名の通話サービスにとって潜在的に問題になります。このようなサービスは、呼び出しごとに個別のDTLSキーを使用し、呼び出し全体でTURNを使用するようにブラウザーに指示する必要があります。それ以外の場合、反対側は、複数の呼び出しにわたってブラウザを相互に関連付けることを可能にするリンク可能な情報を学習します。さらに、ブラウザは[RFC7022]のプライバシー保護CNAME生成モードを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3. Denial of Service",
      "section_title": true,
      "ja": "9.3. サービス拒否"
    },
    {
      "indent": 3,
      "text": "The consent mechanisms described in this document are intended to mitigate denial-of-service (DoS) attacks in which an attacker uses clients to send large amounts of traffic to a victim without the consent of the victim. While these mechanisms are sufficient to protect victims who have not implemented WebRTC at all, WebRTC implementations need to be more careful.",
      "ja": "このドキュメントで説明されている同意メカニズムは、攻撃者がクライアントを使用して被害者の同意なしに大量のトラフィックを被害者に送信するサービス拒否（DoS）攻撃を軽減することを目的としています。これらのメカニズムは、WebRTCをまったく実装していない被害者を保護するのに十分ですが、WebRTCの実装にはもっと注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Consider the case of a call center which accepts calls via WebRTC. An attacker proxies the call center's front-end and arranges for multiple clients to initiate calls to the call center. Note that this requires user consent in many cases, but because the data channel does not need consent, they can use that directly. Since ICE will complete, browsers can then be induced to send large amounts of data to the victim call center if it supports the data channel at all. Preventing this attack requires that automated WebRTC implementations implement sensible flow control and have the ability to triage out (i.e., stop responding to ICE probes on) calls which are behaving badly, and especially to be prepared to remotely throttle the data channel in the absence of plausible audio and video (which the attacker cannot control).",
      "ja": "WebRTCを介して通話を受け入れるコールセンターの場合を考えてみましょう。攻撃者はコールセンターのフロントエンドをプロキシし、複数のクライアントがコールセンターへの通話を開始するように手配します。多くの場合、これにはユーザーの同意が必要ですが、データチャネルは同意を必要としないため、ユーザーはそれを直接使用できます。ICEが完了するので、ブラウザがデータチャネルをサポートしている場合は、被害者のコールセンターに大量のデータを送信するように誘導できます。この攻撃を防ぐには、自動化されたWebRTC実装が適切なフロー制御を実装し、動作が悪いコールをトリアージする（つまり、ICEプローブへの応答を停止する）機能を備えている必要があります。特に、データチャネルがない場合にリモートでスロットルする準備ができている必要があります。もっともらしいオーディオとビデオ（攻撃者は制御できません）。"
    },
    {
      "indent": 3,
      "text": "Another related attack is for the signaling service to swap the ICE candidates for the audio and video streams, thus forcing a browser to send video to the sink that the other victim expects will contain audio (perhaps it is only expecting audio!), potentially causing overload. Muxing multiple media flows over a single transport makes it harder to individually suppress a single flow by denying ICE keepalives. Either media-level (RTCP) mechanisms must be used or the implementation must deny responses entirely, thus terminating the call.",
      "ja": "別の関連する攻撃は、シグナリングサービスがICE候補をオーディオストリームとビデオストリームに交換することです。これにより、他の被害者がオーディオを含むと予想する（おそらくオーディオのみを期待している）シンクにビデオを送信するようにブラウザに強制し、潜在的に原因となります。過負荷。単一のトランスポートで複数のメディアフローを多重化すると、ICEキープアライブを拒否することによって単一のフローを個別に抑制することが難しくなります。メディアレベル（RTCP）メカニズムを使用するか、実装が応答を完全に拒否して、呼び出しを終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "Yet another attack, suggested by Magnus Westerlund, is for the attacker to cross-connect offers and answers as follows. It induces the victim to make a call and then uses its control of other users' browsers to get them to attempt a call to someone. It then translates their offers into apparent answers to the victim, which looks like large-scale parallel forking. The victim still responds to ICE responses, and now the browsers all try to send media to the victim. Implementations can defend themselves from this attack by only responding to ICE Binding Requests for a limited number of remote ufrags (this is the reason for the requirement that the JS not be able to control the ufrag and password). [RFC8834], Section 13 documents a number of potential RTCP-based DoS attacks and countermeasures.",
      "ja": "Magnus Westerlundによって提案されたさらに別の攻撃は、攻撃者が次のようにオファーと回答を相互接続することです。被害者に電話をかけるように誘導し、他のユーザーのブラウザの制御を使用して、誰かに電話をかけさせます。次に、彼らの申し出を被害者への明白な答えに変換します。これは、大規模な並列フォークのように見えます。被害者は依然としてICEの応答に応答し、ブラウザはすべて被害者にメディアを送信しようとします。実装は、限られた数のリモートufragに対するICEバインディング要求にのみ応答することで、この攻撃から身を守ることができます（これが、JSがufragとパスワードを制御できないという要件の理由です）。[RFC8834]、セクション13には、RTCPベースのDoS攻撃とその対策の可能性がいくつか記載されています。"
    },
    {
      "indent": 3,
      "text": "Note that attacks based on confusing one end or the other about consent are possible even in the face of the third-party identity mechanism as long as major parts of the signaling messages are not signed. On the other hand, signing the entire message severely restricts the capabilities of the calling application, so there are difficult tradeoffs here.",
      "ja": "シグナリングメッセージの主要部分が署名されていない限り、サードパーティのIDメカニズムに直面しても、同意について一方または他方を混乱させることに基づく攻撃が可能であることに注意してください。一方、メッセージ全体に署名すると、呼び出し元のアプリケーションの機能が大幅に制限されるため、ここでは難しいトレードオフがあります。"
    },
    {
      "indent": 0,
      "text": "9.4. IdP Authentication Mechanism",
      "section_title": true,
      "ja": "9.4. IdP認証メカニズム"
    },
    {
      "indent": 3,
      "text": "This mechanism relies for its security on the IdP and on the PeerConnection correctly enforcing the security invariants described above. At a high level, the IdP is attesting that the user identified in the assertion wishes to be associated with the assertion. Thus, it must not be possible for arbitrary third parties to get assertions tied to a user or to produce assertions that RPs will accept.",
      "ja": "このメカニズムは、IdPおよびPeerConnectionのセキュリティに依存しており、上記のセキュリティ不変条件を正しく適用します。大まかに言えば、IdPは、アサーションで識別されたユーザーがアサーションに関連付けられることを望んでいることを証明しています。したがって、任意のサードパーティがアサーションをユーザーに関連付けたり、RPが受け入れるアサーションを生成したりすることができないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "9.4.1. PeerConnection Origin Check",
      "section_title": true,
      "ja": "9.4.1. PeerConnectionオリジンチェック"
    },
    {
      "indent": 3,
      "text": "Fundamentally, the IdP proxy is just a piece of HTML and JS loaded by the browser, so nothing stops a Web attacker from creating their own IFRAME, loading the IdP proxy HTML/JS, and requesting a signature over their own keys rather than those generated in the browser. However, that proxy would be in the attacker's origin, not the IdP's origin. Only the browser itself can instantiate a context that (a) is in the IdP's origin and (b) exposes the correct API surface. Thus, the IdP proxy on the sender's side MUST ensure that it is running in the IdP's origin prior to issuing assertions.",
      "ja": "基本的に、IdPプロキシはブラウザによってロードされるHTMLとJSの一部であるため、Web攻撃者が独自のIFRAMEを作成し、IdPプロキシHTML / JSをロードし、生成されたキーではなく独自のキーを介して署名を要求することを妨げるものはありません。ブラウザで。ただし、そのプロキシは、IdPのオリジンではなく、攻撃者のオリジンにあります。（a）IdPのオリジンにあり、（b）正しいAPIサーフェスを公開するコンテキストをインスタンス化できるのは、ブラウザー自体だけです。したがって、送信者側のIdPプロキシは、アサーションを発行する前に、IdPのオリジンで実行されていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this check only asserts that the browser (or some other entity with access to the user's authentication data) attests to the request and hence to the fingerprint. It does not demonstrate that the browser has access to the associated private key, and therefore an attacker can attach their own identity to another party's keying material, thus making a call which comes from Alice appear to come from the attacker. See [RFC8844] for defenses against this form of attack.",
      "ja": "このチェックは、ブラウザ（またはユーザーの認証データにアクセスできる他のエンティティ）がリクエストを証明し、したがってフィンガープリントを証明することのみを表明することに注意してください。ブラウザが関連付けられた秘密鍵にアクセスできることを示していないため、攻撃者は自分のIDを他の当事者の鍵素材に添付して、アリスからの呼び出しを攻撃者からのように見せることができます。この形式の攻撃に対する防御策については、[RFC8844]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.4.2. IdP Well-Known URI",
      "section_title": true,
      "ja": "9.4.2. IdPよく知られているURI"
    },
    {
      "indent": 3,
      "text": "As described in Section 7.5, the IdP proxy HTML/JS landing page is located at a well-known URI based on the IdP's domain name. This requirement prevents an attacker who can write some resources at the IdP (e.g., on one's Facebook wall) from being able to impersonate the IdP.",
      "ja": "セクション7.5で説明したように、IdPプロキシHTML / JSランディングページは、IdPのドメイン名に基づいて既知のURIに配置されます。この要件により、IdP（Facebookの壁など）で一部のリソースを書き込むことができる攻撃者がIdPになりすますことができなくなります。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Privacy of IdP-Generated Identities and the Hosting Site",
      "section_title": true,
      "ja": "9.4.3. IdPで生成されたIDとホスティングサイトのプライバシー"
    },
    {
      "indent": 3,
      "text": "Depending on the structure of the IdP's assertions, the calling site may learn the user's identity from the perspective of the IdP. In many cases, this is not an issue because the user is authenticating to the site via the IdP in any case -- for instance, when the user has logged in with Facebook Connect and is then authenticating their call with a Facebook identity. However, in other cases, the user may not have already revealed their identity to the site. In general, IdPs SHOULD either verify that the user is willing to have their identity revealed to the site (e.g., through the usual IdP permissions dialog) or arrange that the identity information is only available to known RPs (e.g., social graph adjacencies) but not to the calling site. The \"domain\" field of the assertion request can be used to check that the user has agreed to disclose their identity to the calling site; because it is supplied by the PeerConnection it can be trusted to be correct.",
      "ja": "IdPのアサーションの構造によっては、呼び出し側サイトがIdPの観点からユーザーのIDを学習する場合があります。多くの場合、ユーザーはIdPを介してサイトに認証しているため、これは問題ではありません。たとえば、ユーザーがFacebook Connectでログインし、FacebookIDで通話を認証している場合などです。ただし、その他の場合、ユーザーはまだ自分のIDをサイトに公開していない可能性があります。一般に、IdPは、ユーザーが自分のIDをサイトに公開する意思があることを確認するか（たとえば、通常のIdPアクセス許可ダイアログを介して）、ID情報を既知のRP（たとえば、ソーシャルグラフの隣接関係）のみが利用できるように調整する必要があります。発信サイトではありません。アサーション要求の「ドメイン」フィールドを使用して、ユーザーが自分のIDを呼び出し元のサイトに開示することに同意したことを確認できます。PeerConnectionによって提供されるため、正しいと信頼できます。"
    },
    {
      "indent": 0,
      "text": "9.4.4. Security of Third-Party IdPs",
      "section_title": true,
      "ja": "9.4.4. サードパーティのIdPのセキュリティ"
    },
    {
      "indent": 3,
      "text": "As discussed above, each third-party IdP represents a new universal trust point and therefore the number of these IdPs needs to be quite limited. Most IdPs, even those which issue unqualified identities such as Facebook, can be recast as authoritative IdPs (e.g., 123456@facebook.com). However, in such cases, the user interface implications are not entirely desirable. One intermediate approach is to have special (potentially user configurable) UI for large authoritative IdPs, thus allowing the user to instantly grasp that the call is being authenticated by Facebook, Google, etc.",
      "ja": "上で説明したように、各サードパーティIdPは新しいユニバーサルトラストポイントを表すため、これらのIdPの数をかなり制限する必要があります。ほとんどのIdPは、Facebookなどの修飾されていないIDを発行するものであっても、信頼できるIdP（123456@facebook.comなど）として再キャストできます。ただし、このような場合、ユーザーインターフェイスへの影響は完全には望ましくありません。中間的なアプローチの1つは、大規模な信頼できるIdP用の特別な（ユーザーが構成できる可能性のある）UIを用意することです。これにより、ユーザーは、通話がFacebookやGoogleなどによって認証されていることを即座に把握できます。"
    },
    {
      "indent": 0,
      "text": "9.4.4.1. Confusable Characters",
      "section_title": true,
      "ja": "9.4.4.1. 紛らわしいキャラクター"
    },
    {
      "indent": 3,
      "text": "Because a broad range of characters are permitted in identity strings, it may be possible for attackers to craft identities which are confusable with other identities (see [RFC6943] for more on this topic). This is a problem with any identifier space of this type (e.g., email addresses). Those minting identifiers should avoid mixed scripts and similar confusable characters. Those presenting these identifiers to a user should consider highlighting cases of mixed script usage (see [RFC5890], Section 4.4). Other best practices are still in development.",
      "ja": "ID文字列にはさまざまな文字が許可されているため、攻撃者が他のIDと混同しやすいIDを作成する可能性があります（このトピックの詳細については、[RFC6943]を参照してください）。これは、このタイプの識別子スペース（メールアドレスなど）の問題です。これらのミンティング識別子は、スクリプトの混合や同様の紛らわしい文字を避ける必要があります。これらの識別子をユーザーに提示する場合は、スクリプトが混在するケースを強調することを検討する必要があります（[RFC5890]のセクション4.4を参照）。他のベストプラクティスはまだ開発中です。"
    },
    {
      "indent": 0,
      "text": "9.4.5. Web Security Feature Interactions",
      "section_title": true,
      "ja": "9.4.5. Webセキュリティ機能の相互作用"
    },
    {
      "indent": 3,
      "text": "A number of optional Web security features have the potential to cause issues for this mechanism, as discussed below.",
      "ja": "以下で説明するように、オプションのWebセキュリティ機能の多くは、このメカニズムに問題を引き起こす可能性があります。"
    },
    {
      "indent": 0,
      "text": "9.4.5.1. Popup Blocking",
      "section_title": true,
      "ja": "9.4.5.1. ポップアップブロッキング"
    },
    {
      "indent": 3,
      "text": "When popup blocking is in use, the IdP proxy is unable to generate popup windows, dialogs, or any other form of user interactions. This prevents the IdP proxy from being used to circumvent user interaction. The \"LOGINNEEDED\" message allows the IdP proxy to inform the calling site of a need for user login, providing the information necessary to satisfy this requirement without resorting to direct user interaction from the IdP proxy itself.",
      "ja": "ポップアップブロッキングが使用されている場合、IdPプロキシはポップアップウィンドウ、ダイアログ、またはその他の形式のユーザーインタラクションを生成できません。これにより、IdPプロキシがユーザーの操作を回避するために使用されるのを防ぎます。「LOGINNEEDED」メッセージを使用すると、IdPプロキシは、ユーザーログインの必要性を呼び出し元サイトに通知し、IdPプロキシ自体からの直接のユーザー操作に頼ることなく、この要件を満たすために必要な情報を提供できます。"
    },
    {
      "indent": 0,
      "text": "9.4.5.2. Third Party Cookies",
      "section_title": true,
      "ja": "9.4.5.2. サードパーティのCookie"
    },
    {
      "indent": 3,
      "text": "Some browsers allow users to block third party cookies (cookies associated with origins other than the top-level page) for privacy reasons. Any IdP which uses cookies to persist logins will be broken by third-party cookie blocking. One option is to accept this as a limitation; another is to have the PeerConnection object disable third-party cookie blocking for the IdP proxy.",
      "ja": "一部のブラウザでは、プライバシー上の理由から、ユーザーがサードパーティのCookie（トップレベルページ以外のオリジンに関連付けられたCookie）をブロックできます。ログインを永続化するためにCookieを使用するIdPは、サードパーティのCookieブロックによって破壊されます。1つのオプションは、これを制限として受け入れることです。もう1つは、PeerConnectionオブジェクトでIdPプロキシのサードパーティCookieブロッキングを無効にすることです。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification defines the \"identity\" SDP attribute per the procedures of Section 8.2.4 of [RFC4566]. The required information for the registration is included here:",
      "ja": "この仕様は、[RFC4566]のセクション8.2.4の手順に従って「ID」SDP属性を定義します。登録に必要な情報はここに含まれています："
    },
    {
      "indent": 3,
      "text": "Contact Name: IESG (iesg@ietf.org)",
      "ja": "連絡先名：IESG（iesg@ietf.org）"
    },
    {
      "indent": 3,
      "text": "Attribute Name: identity",
      "ja": "属性名：アイデンティティ"
    },
    {
      "indent": 3,
      "text": "Long Form: identity",
      "ja": "長い形式：アイデンティティ"
    },
    {
      "indent": 3,
      "text": "Type of Attribute: session",
      "ja": "属性のタイプ：セッション"
    },
    {
      "indent": 3,
      "text": "Charset Considerations: This attribute is not subject to the charset attribute.",
      "ja": "文字セットに関する考慮事項：この属性は、文字セット属性の対象ではありません。"
    },
    {
      "indent": 3,
      "text": "Purpose: This attribute carries an identity assertion, binding an identity to the transport-level security session.",
      "ja": "目的：この属性はIDアサーションを伝送し、IDをトランスポートレベルのセキュリティセッションにバインドします。"
    },
    {
      "indent": 3,
      "text": "Appropriate Values: See Section 5 of RFC 8827.",
      "ja": "適切な値：RFC8827のセクション5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Mux Category: NORMAL",
      "ja": "Muxカテゴリー：NORMAL"
    },
    {
      "indent": 3,
      "text": "This section registers the \"idp-proxy\" well-known URI from [RFC8615].",
      "ja": "このセクションでは、[RFC8615]の「idp-proxy」既知のURIを登録します。"
    },
    {
      "indent": 3,
      "text": "URI suffix: idp-proxy",
      "ja": "URIサフィックス：idp-proxy"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "コントローラーの変更：IETF"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS186] National Institute of Standards and Technology (NIST), \"Digital Signature Standard (DSS)\", NIST PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <https://doi.org/10.6028/NIST.FIPS.186-4>.",
      "ja": "[FIPS186]米国国立標準技術研究所（NIST）、「デジタル署名標準（DSS）」、NIST PUB 186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月、<https://doi.org/10.6028/NIST.FIPS.186-4>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <https://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818] Rescorla、E。、「HTTP Over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<https://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, DOI 10.17487/RFC3264, June 2002, <https://www.rfc-editor.org/info/rfc3264>.",
      "ja": "[RFC3264] Rosenberg、J。およびH. Schulzrinne、「Session Description Protocol（SDP）を使用したオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org/ info / rfc3264>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月2004年、<https://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<https：//www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <https://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566] Handley、M.、Jacobson、V。、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/info / rfc4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4568] Andreasen, F., Baugher, M., and D. Wing, \"Session Description Protocol (SDP) Security Descriptions for Media Streams\", RFC 4568, DOI 10.17487/RFC4568, July 2006, <https://www.rfc-editor.org/info/rfc4568>.",
      "ja": "[RFC4568] Andreasen、F.、Baugher、M。、およびD. Wing、「Media Streamsのセッション記述プロトコル（SDP）セキュリティ記述」、RFC 4568、DOI 10.17487 / RFC4568、2006年7月、<https：// www。rfc-editor.org/info/rfc4568>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5763] Fischl, J., Tschofenig, H., and E. Rescorla, \"Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)\", RFC 5763, DOI 10.17487/RFC5763, May 2010, <https://www.rfc-editor.org/info/rfc5763>.",
      "ja": "[RFC5763] Fischl、J.、Tschofenig、H。、およびE. Rescorla、「Datagram Transport Layer Security（DTLS）を使用してセキュアなReal-time Transport Protocol（SRTP）セキュリティコンテキストを確立するためのフレームワーク」、RFC 5763、DOI 10.17487 /RFC5763、2010年5月、<https://www.rfc-editor.org/info/rfc5763>。"
    },
    {
      "indent": 3,
      "text": "[RFC5764] McGrew, D. and E. Rescorla, \"Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)\", RFC 5764, DOI 10.17487/RFC5764, May 2010, <https://www.rfc-editor.org/info/rfc5764>.",
      "ja": "[RFC5764] McGrew、D。およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのDatagram Transport Layer Security（DTLS）Extension」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<https：//www.rfc-editor.org/info/rfc5764>。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, DOI 10.17487/RFC5890, August 2010, <https://www.rfc-editor.org/info/rfc5890>.",
      "ja": "[RFC5890] Klensin、J。、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、<https://www.rfc-editor.org/info/rfc5890>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <https://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454] Barth、A。、「The Web Origin Concept」、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<https://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC7022] Begen, A., Perkins, C., Wing, D., and E. Rescorla, \"Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)\", RFC 7022, DOI 10.17487/RFC7022, September 2013, <https://www.rfc-editor.org/info/rfc7022>.",
      "ja": "[RFC7022] Begen、A.、Perkins、C.、Wing、D。、およびE. Rescorla、「RTP制御プロトコル（RTCP）正規名（CNAME）を選択するためのガイドライン」、RFC 7022、DOI 10.17487 / RFC7022、2013年9月、<https://www.rfc-editor.org/info/rfc7022>。"
    },
    {
      "indent": 3,
      "text": "[RFC7675] Perumal, M., Wing, D., Ravindranath, R., Reddy, T., and M. Thomson, \"Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness\", RFC 7675, DOI 10.17487/RFC7675, October 2015, <https://www.rfc-editor.org/info/rfc7675>.",
      "ja": "[RFC7675] Perumal、M.、Wing、D.、Ravindranath、R.、Reddy、T.、and M. Thomson、 \"Session Traversal Utilities for NAT（STUN）Usage for Consent Freshness\"、RFC 7675、DOI 10.17487 / RFC7675、2015年10月、<https://www.rfc-editor.org/info/rfc7675>。"
    },
    {
      "indent": 3,
      "text": "[RFC7918] Langley, A., Modadugu, N., and B. Moeller, \"Transport Layer Security (TLS) False Start\", RFC 7918, DOI 10.17487/RFC7918, August 2016, <https://www.rfc-editor.org/info/rfc7918>.",
      "ja": "[RFC7918] Langley、A.、Modadugu、N。、およびB. Moeller、「Transport Layer Security（TLS）False Start」、RFC 7918、DOI 10.17487 / RFC7918、2016年8月、<https：//www.rfc-editor.org / info / rfc7918>。"
    },
    {
      "indent": 3,
      "text": "[RFC8122] Lennox, J. and C. Holmberg, \"Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)\", RFC 8122, DOI 10.17487/RFC8122, March 2017, <https://www.rfc-editor.org/info/rfc8122>.",
      "ja": "[RFC8122] Lennox、J。and C. Holmberg、 \"Connection-Oriented Media Transport over the Transport Layer Security（TLS）Protocol in the Session Description Protocol（SDP）\"、RFC 8122、DOI 10.17487 / RFC8122、March 2017、<https：//www.rfc-editor.org/info/rfc8122>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードにおける大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、Ed。、 \"The JavaScript Object Notation（JSON）Data Interchange Format\"、STD 90、RFC 8259、DOI 10.17487 / RFC8259、December 2017、<https://www.rfc-editor.org/ info / rfc8259>。"
    },
    {
      "indent": 3,
      "text": "[RFC8261] Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, \"Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets\", RFC 8261, DOI 10.17487/RFC8261, November 2017, <https://www.rfc-editor.org/info/rfc8261>.",
      "ja": "[RFC8261] Tuexen、M.、Stewart、R.、Jesup、R。、およびS. Loreto、「SCTPパケットのデータグラムトランスポート層セキュリティ（DTLS）カプセル化」、RFC 8261、DOI 10.17487 / RFC8261、2017年11月、<https：//www.rfc-editor.org/info/rfc8261>。"
    },
    {
      "indent": 3,
      "text": "[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal\", RFC 8445, DOI 10.17487/RFC8445, July 2018, <https://www.rfc-editor.org/info/rfc8445>.",
      "ja": "[RFC8445] Keranen、A.、Holmberg、C。、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、<https://www.rfc-editor.org/info/rfc8445>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8615] Nottingham, M., \"Well-Known Uniform Resource Identifiers (URIs)\", RFC 8615, DOI 10.17487/RFC8615, May 2019, <https://www.rfc-editor.org/info/rfc8615>.",
      "ja": "[RFC8615] Nottingham、M。、「Well-Known Uniform Resource Identifiers（URI）」、RFC 8615、DOI 10.17487 / RFC8615、2019年5月、<https://www.rfc-editor.org/info/rfc8615>。"
    },
    {
      "indent": 3,
      "text": "[RFC8825] Alvestrand, H., \"Overview: Real-Time Protocols for Browser-Based Applications\", RFC 8825, DOI 10.17487/RFC8825, January 2021, <https://www.rfc-editor.org/info/rfc8825>.",
      "ja": "[RFC8825] Alvestrand、H。、「Overview：Real-Time Protocols for Browser-Based Applications」、RFC 8825、DOI 10.17487 / RFC8825、2021年1月、<https://www.rfc-editor.org/info/rfc8825>。"
    },
    {
      "indent": 3,
      "text": "[RFC8826] Rescorla, E., \"Security Considerations for WebRTC\", RFC 8826, DOI 10.17487/RFC8826, January 2021, <https://www.rfc-editor.org/info/rfc8826>.",
      "ja": "[RFC8826] Rescorla、E。、「WebRTCのセキュリティに関する考慮事項」、RFC 8826、DOI 10.17487 / RFC8826、2021年1月、<https://www.rfc-editor.org/info/rfc8826>。"
    },
    {
      "indent": 3,
      "text": "[RFC8829] Uberti, J., Jennings, C., and E. Rescorla, Ed., \"JavaScript Session Establishment Protocol (JSEP)\", RFC 8829, DOI 10.17487/RFC8829, January 2021, <https://www.rfc-editor.org/info/rfc8829>.",
      "ja": "[RFC8829] Uberti、J.、Jennings、C。、およびE. Rescorla、Ed。、「JavaScript Session Establishment Protocol（JSEP）」、RFC 8829、DOI 10.17487 / RFC8829、2021年1月、<https：//www.rfc-editor.org/info/rfc8829>。"
    },
    {
      "indent": 3,
      "text": "[RFC8834] Perkins, C., Westerlund, M., and J. Ott, \"Media Transport and Use of RTP in WebRTC\", RFC 8834, DOI 10.17487/RFC8834, January 2021, <https://www.rfc-editor.org/info/rfc8834>.",
      "ja": "[RFC8834] Perkins、C.、Westerlund、M。、およびJ. Ott、「Media Transport and Use of RTP in WebRTC」、RFC 8834、DOI 10.17487 / RFC8834、2021年1月、<https：//www.rfc-editor.org / info / rfc8834>。"
    },
    {
      "indent": 3,
      "text": "[RFC8844] Thomson, M. and E. Rescorla, \"Unknown Key-Share Attacks on Uses of TLS with the Session Description Protocol (SDP)\", RFC 8844, DOI 10.17487/RFC8844, January 2021, <https://www.rfc-editor.org/info/rfc8844>.",
      "ja": "[RFC8844] Thomson、M。and E. Rescorla、 \"Unknown Key-Share Attacks on Uses of TLS with the Session Description Protocol（SDP）\"、RFC 8844、DOI 10.17487 / RFC8844、January 2021、<https：// www。rfc-editor.org/info/rfc8844>。"
    },
    {
      "indent": 3,
      "text": "[webcrypto] Watson, M., \"Web Cryptography API\", W3C Recommendation, 26 January 2017, <https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/>.",
      "ja": "[webcrypto] Watson、M。、「Web Cryptography API」、W3C勧告、2017年1月26日、<https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/>。"
    },
    {
      "indent": 3,
      "text": "[webrtc-api] Jennings, C., Boström, H., and J-I. Bruaroey, \"WebRTC 1.0: Real-time Communication Between Browsers\", W3C Proposed Recommendation, <https://www.w3.org/TR/webrtc/>.",
      "ja": "[webrtc-api] Jennings、C.、Boström、H。、およびJ-I。Bruaroey、「WebRTC 1.0：ブラウザ間のリアルタイム通信」、W3C提案の推奨事項、<https://www.w3.org/TR/webrtc/>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[fetch] van Kesteren, A., \"Fetch\", <https://fetch.spec.whatwg.org/>.",
      "ja": "[フェッチ] van Kesteren、A。、「Fetch」、<https://fetch.spec.whatwg.org/>。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SessionInitiationProtocol」、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC5705] Rescorla, E., \"Keying Material Exporters for Transport Layer Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705, March 2010, <https://www.rfc-editor.org/info/rfc5705>.",
      "ja": "[RFC5705] Rescorla、E。、「Keying Material Exporters for Transport Layer Security（TLS）」、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、<https://www.rfc-editor.org/info/rfc5705>。"
    },
    {
      "indent": 3,
      "text": "[RFC6120] Saint-Andre, P., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 6120, DOI 10.17487/RFC6120, March 2011, <https://www.rfc-editor.org/info/rfc6120>.",
      "ja": "[RFC6120] Saint-Andre、P。、「Extensible Messaging and Presence Protocol（XMPP）：Core」、RFC 6120、DOI 10.17487 / RFC6120、2011年3月、<https://www.rfc-editor.org/info/rfc6120>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011, <https://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265] Barth、A。、「HTTP State Management Mechanism」、RFC 6265、DOI 10.17487 / RFC6265、2011年4月、<https://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6455] Fette, I. and A. Melnikov, \"The WebSocket Protocol\", RFC 6455, DOI 10.17487/RFC6455, December 2011, <https://www.rfc-editor.org/info/rfc6455>.",
      "ja": "[RFC6455] Fette、I。およびA. Melnikov、「The WebSocket Protocol」、RFC 6455、DOI 10.17487 / RFC6455、2011年12月、<https://www.rfc-editor.org/info/rfc6455>。"
    },
    {
      "indent": 3,
      "text": "[RFC6943] Thaler, D., Ed., \"Issues in Identifier Comparison for Security Purposes\", RFC 6943, DOI 10.17487/RFC6943, May 2013, <https://www.rfc-editor.org/info/rfc6943>.",
      "ja": "[RFC6943] Thaler、D.、Ed。、 \"Issues in Identifier Comparison for Security Purposes\"、RFC 6943、DOI 10.17487 / RFC6943、May 2013、<https://www.rfc-editor.org/info/rfc6943>。"
    },
    {
      "indent": 3,
      "text": "[RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, DOI 10.17487/RFC7617, September 2015, <https://www.rfc-editor.org/info/rfc7617>.",
      "ja": "[RFC7617] Reschke、J。、「The'Basic 'HTTP Authentication Scheme」、RFC 7617、DOI 10.17487 / RFC7617、2015年9月、<https://www.rfc-editor.org/info/rfc7617>。"
    },
    {
      "indent": 3,
      "text": "[RFC8224] Peterson, J., Jennings, C., Rescorla, E., and C. Wendt, \"Authenticated Identity Management in the Session Initiation Protocol (SIP)\", RFC 8224, DOI 10.17487/RFC8224, February 2018, <https://www.rfc-editor.org/info/rfc8224>.",
      "ja": "[RFC8224] Peterson、J.、Jennings、C.、Rescorla、E。、およびC. Wendt、「セッション開始プロトコル（SIP）での認証済みID管理」、RFC 8224、DOI 10.17487 / RFC8224、2018年2月、<https：//www.rfc-editor.org/info/rfc8224>。"
    },
    {
      "indent": 3,
      "text": "[RFC8828] Uberti, J. and G. Shieh, \"WebRTC IP Address Handling Requirements\", RFC 8828, DOI 10.17487/RFC8828, January 2021, <https://www.rfc-editor.org/info/rfc8828>.",
      "ja": "[RFC8828] Uberti、J。およびG. Shieh、「WebRTC IPアドレス処理要件」、RFC 8828、DOI 10.17487 / RFC8828、2021年1月、<https://www.rfc-editor.org/info/rfc8828>。"
    },
    {
      "indent": 3,
      "text": "[TLS-DTLS13] Rescorla, E., Tschofenig, H., and N. Modadugu, \"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3\", Work in Progress, Internet-Draft, draft-ietf-tls-dtls13-39, 2 November 2020, <https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>.",
      "ja": "[TLS-DTLS13] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラムトランスポート層セキュリティ（DTLS）プロトコルバージョン1.3」、進行中の作業、インターネットドラフト、draft-ietf-tls-dtls13-39、2020年11月2日、<https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Bernard Aboba, Harald Alvestrand, Richard Barnes, Dan Druta, Cullen Jennings, Hadriel Kaplan, Matthew Kaufman, Jim McEachern, Martin Thomson, Magnus Westerlund. Matthew Kaufman provided the UI material in Section 6.5. Christer Holmberg provided the initial version of Section 5.1.",
      "ja": "Bernard Aboba、Harald Alvestrand、Richard Barnes、Dan Druta、Cullen Jennings、Hadriel Kaplan、Matthew Kaufman、Jim McEachern、Martin Thomson、Magnus WesterlundMatthew Kaufmanは、セクション6.5でUI資料を提供しました。Christer Holmbergは、セクション5.1の初期バージョンを提供しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla Mozilla",
      "ja": "エリックレスコーラMozilla"
    },
    {
      "indent": 3,
      "text": "Email: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    }
  ]
}