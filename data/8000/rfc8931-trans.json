{
  "title": {
    "text": "RFC 8931 - IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery",
    "ja": "RFC 8931 - 低電力無線パーソナルエリアネットワーク（6LOWPAN）選択的フラグメントリカバリのIPv6"
  },
  "number": 8931,
  "created_at": "2021-04-11 05:59:07.087073+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   P. Thubert, Ed.\nRequest for Comments: 8931                                 Cisco Systems\nUpdates: 4944                                              November 2020\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery",
      "ja": "低電力無線パーソナルエリアネットワーク（6LOWPAN）選択的フラグメントリカバリのIPv6"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document updates RFC 4944 with a protocol that forwards individual fragments across a route-over mesh and recovers them end to end, with congestion control capabilities to protect the network.",
      "ja": "この文書は、ルートオーバーメッシュを介して個々のフラグメントを転送し、ネットワークを保護するための輻輳制御機能を伴って、それらを終了し、それらを復元するプロトコルでRFC 4944を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット規格のトラック文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8931.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/frfc8931で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（C）2020 IETFの信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n  2.1.  Requirements Language\n  2.2.  Background\n  2.3.  Other Terms\n3.  Updating RFC 4944\n4.  Extending RFC 8930\n  4.1.  Slack in the First Fragment\n  4.2.  Gap between Frames\n  4.3.  Congestion Control\n  4.4.  Modifying the First Fragment\n5.  New Dispatch Types and Headers\n  5.1.  Recoverable Fragment Dispatch Type and Header\n  5.2.  RFRAG Acknowledgment Dispatch Type and Header\n6.  Fragment Recovery\n  6.1.  Forwarding Fragments\n    6.1.1.  Receiving the First Fragment\n    6.1.2.  Receiving the Next Fragments\n  6.2.  Receiving RFRAG Acknowledgments\n  6.3.  Aborting the Transmission of a Fragmented Packet\n  6.4.  Applying Recoverable Fragmentation along a Diverse Path\n7.  Management Considerations\n  7.1.  Protocol Parameters\n  7.2.  Observing the Network\n8.  Security Considerations\n9.  IANA Considerations\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  Rationale\nAppendix B.  Requirements\nAppendix C.  Considerations on Congestion Control\nAcknowledgments\nAuthor's Address",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In most Low-Power and Lossy Network (LLN) applications, the bulk of the traffic consists of small chunks of data (on the order of a few bytes to a few tens of bytes) at a time. Given that an IEEE Std 802.15.4 [IEEE.802.15.4] frame can carry a payload of 74 bytes or more, fragmentation is usually not required. However, and though this happens only occasionally, a number of mission-critical applications do require the capability to transfer larger chunks of data, for instance, to support the firmware upgrade of the LLN nodes or the extraction of logs from LLN nodes.",
      "ja": "ほとんどの低電力および非損失ネットワーク（LLN）アプリケーションでは、トラフィックの大部分は、一度に（数バイトから数十バイトに数バイト程度の）データの小さなチャンクからなる。IEEE STD 802.15.4 [IEEE.802.15.4]フレームが74バイト以上のペイロードを持つことができることを考えると、断片化は通常必要ありません。ただし、これは時折しか起こりませんが、多くのミッションクリティカルなアプリケーションでは、LLNノードのファームウェアのアップグレードまたはLLNノードからのログの抽出をサポートするための、より大きなデータのチャンクを転送する機能が必要です。"
    },
    {
      "indent": 3,
      "text": "In the former case, the large chunk of data is transferred to the LLN node, whereas in the latter case, the large chunk flows away from the LLN node. In both cases, the size can be on the order of 10 KB or more, and an end-to-end reliable transport is required.",
      "ja": "前者の場合、データの大きなチャンクがLLNノードに転送されますが、後者の場合、大きなチャンクはLLNノードから流れます。どちらの場合も、サイズは10 KB以上のオーダーであり、エンドツーエンドの信頼できる輸送が必要です。"
    },
    {
      "indent": 3,
      "text": "\"Transmission of IPv6 Packets over IEEE 802.15.4 Networks\" [RFC4944] defines the original IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) datagram fragmentation mechanism for LLNs. One critical issue with this original design is that routing an IPv6 [RFC8200] packet across a route-over mesh requires the reassembly of the packet at each hop. \"An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4\" [6TiSCH] indicates that this may cause latency along a path and impact critical resources such as memory and battery; to alleviate those undesirable effects, it recommends using a 6LoWPAN Fragment Forwarding (6LFF) technique.",
      "ja": "「IEEE 802.15.4ネットワーク上のIPv6パケットの送信」[RFC4944]は、LLN用の低電力無線パーソナルエリアネットワーク（6LOWPAN）データグラム断片化メカニズムを介した元のIPv6を定義します。このオリジナルデザインに関する1つの重要な問題は、経路オーバーメッシュ全体でIPv6 [RFC8200]パケットをルーティングすることで、各ホップでパケットの再組み立てが必要です。「IEEE 802.15.4のTSCHモードを介したIPv6のアーキテクチャは、これがパスに沿って待ち時間を引き起こし、メモリやバッテリなどの重要なリソースに影響を与える可能性があることを示しています。これらの望ましくない効果を軽減するために、6lowpanフラグメント転送（6LFF）技術を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "\"On Forwarding 6LoWPAN Fragments over a Multihop IPv6 Network\" [RFC8930] specifies the generic behavior that all 6LFF techniques including this specification follow, and it presents the associated caveats. In particular, the routing information is fully indicated in the first fragment, which is always forwarded first. With this specification, the first fragment is identified by a Sequence of 0 as opposed to a dispatch type in [RFC4944]. A state is formed and used to forward all the next fragments along the same path. The Datagram_Tag is locally significant to the Layer 2 source of the packet and is swapped at each hop; see Section 6. This specification encodes the Datagram_Tag in 1 byte, which will saturate if more than 256 datagrams transit in fragmented form over a single hop at the same time. This is not realistic at the time of this writing. Should this happen in a new 6LoWPAN technology, a node will need to use several link-layer addresses to increase its indexing capacity.",
      "ja": "「マルチホップIPv6ネットワーク経由で6lowpanフラグメントを転送する」[RFC8930]は、この仕様を含むすべての6LFF技術が続く一般的な動作を指定し、関連する警告を提示します。特に、ルーティング情報は最初のフラグメントに完全に示されており、これは常に最初に転送されます。本明細書では、[RFC4944]のディスパッチタイプとは対照的に、最初のフラグメントが0のシーケンスで識別されます。状態が形成され、同じ経路に沿ってすべての次のフラグメントを転送するために使用される。Datagram_tagは、パケットのレイヤ2のソースにローカルに重要であり、各ホップでスワップされます。セクション6を参照してください。この仕様は、1バイトでデータグラムを符号化します。これは、256以上のデータグラムが断片化された形式で断片化された形式でシングルホップで同時に遷移するかどうかを彩度します。これはこの書き込み時に現実的ではありません。これが新しい6LOWPANテクノロジで発生する場合、ノードは索引付け容量を増やすためにいくつかのリンク層アドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "\"Virtual reassembly buffers in 6LoWPAN\" [LWIG-FRAG] proposes a 6LFF technique that is compatible with [RFC4944] without the need to define a new protocol. However, adding that capability alone to the local implementation of the original 6LoWPAN fragmentation would not address the inherent fragility of fragmentation (see [RFC8900]), in particular, the issues of resources locked on the reassembling endpoint and the wasted transmissions due to the loss of a single fragment in a whole datagram. [Kent] compares the unreliable delivery of fragments with a mechanism it calls \"selective acknowledgments\" that recovers the loss of a fragment individually. The paper illustrates the benefits that can be derived from such a method; see Figures 1, 2, and 3 in Section 2.3 of [Kent]. [RFC4944] has no selective recovery, and the whole datagram fails when one fragment is not delivered to the reassembling endpoint. Constrained memory resources are blocked on the reassembling endpoint until it times out, possibly causing the loss of subsequent packets that cannot be received for the lack of buffers.",
      "ja": "「6lowpanの仮想再構成バッファ」[LWIG-Frag]は、新しいプロトコルを定義する必要なしに[RFC4944]と互換性のある6LFFテクニックを提案しています。ただし、オリジナルの6LOWPANフラグメンテーションの局所実装に単独でのみを追加すると、断片化の固有の脆弱性に対処しない（[RFC8900]参照）、特に、再組み立てエンドポイントにロックされたリソースの問題と損失による無駄な送信の問題があります。データグラム全体の単一のフラグメントの。 [ケント]は、フラグメントの信頼性の低い配信を、フラグメントの損失を個別に回復する「選択的承認」と呼びます。この論文は、そのような方法から導き出すことができる利点を説明する。 [ケント]のセクション2.3の図1,2、および3を参照してください。 [RFC4944]は選択的な回復をしていないため、1つのフラグメントが再組み立てエンドポイントに配信されない場合、データグラム全体は失敗します。制約されたメモリリソースは、それがタイムアウトするまで、再組み立てエンドポイントでブロックされ、バッファの欠如に対して受信できない後続のパケットの損失を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "That problem is exacerbated when forwarding fragments over multiple hops since a loss at an intermediate hop will not be discovered by either the fragmenting or the reassembling endpoints. Should this happen, the source will keep on sending fragments, wasting even more resources in the network since the datagram cannot arrive in its entirety, which possibly contributes to the condition that caused the loss. [RFC4944] is lacking a congestion control to avoid participating in a saturation that may have caused the loss of the fragment. It has no signaling to abort a multi-fragment transmission at any time and from either end, and if the capability to forward fragments is implemented, clean up the related state in the network.",
      "ja": "中間ホップでの損失は、断片化または再組み立てエンドポイントのいずれかによって発見されないので、その問題は複数のホップにわたってフラグメントを転送するときに悪化される。これが起こると、ソースはフラグメントを送信し続け、データグラム全体が到着できないため、ネットワーク内でさらに多くのリソースを無駄にします。これはおそらく損失を引き起こした状態に貢献します。[RFC4944]は、フラグメントの損失を引き起こした可能性がある飽和に参加しないように輻輳制御を欠いています。マルチフラグメント伝送をいつでも中止するシグナリングはありません。どちらの端からも、フラグメントを転送する機能が実装されている場合は、ネットワーク内の関連状態をクリーンアップします。"
    },
    {
      "indent": 3,
      "text": "This specification provides a method to forward fragments over, typically, a few hops in a route-over 6LoWPAN mesh and a selective acknowledgment to recover individual fragments between 6LoWPAN endpoints. The method can help limit the congestion loss in the network and addresses the requirements in Appendix B. Flow control is out of scope since the endpoints are expected to be able to store the full datagram. Deployments are expected to be managed and homogeneous, and an incremental transition requires a flag day.",
      "ja": "この仕様は、典型的には、6LOWPANメッシュ内の数のホップ、および6LOWPANエンドポイント間で個々のフラグメントを回復するための選択的確認応答を順に転送する方法を提供する。この方法は、ネットワーク内の輻輳損失を制限し、付録Bの要件に対処するのに役立ちます。エンドポイントは全データグラムを保存できると予想されるため、フロー制御は範囲外です。展開は管理されていて均質になると予想され、増分遷移はフラグの日を必要とします。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Background",
      "section_title": true,
      "ja": "2.2. バックグラウンド"
    },
    {
      "indent": 3,
      "text": "This document uses 6LoWPAN terms and concepts that are presented in\n\"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs):\nOverview, Assumptions, Problem Statement, and Goals\" [RFC4919];\n\"Transmission of IPv6 Packets over IEEE 802.15.4 Networks\" [RFC4944];\nand \"Problem Statement and Requirements for IPv6 over Low-Power\nWireless Personal Area Network (6LoWPAN) Routing\" [RFC6606].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8930] discusses the generic concept of a Virtual Reassembly Buffer (VRB) and specifies behaviors and caveats that are common to a large family of 6LFF techniques including the mechanism specified by this document, which is fully inherited from that specification. It also defines terms used in this document: Compressed Form, Datagram_Tag, Datagram_Size, Fragment_Offset, and 6LoWPAN Fragment Forwarding endpoint (commonly abbreviated as only \"endpoint\").",
      "ja": "[RFC8930]仮想再構成バッファ（VRB）の一般的な概念について説明し、この文書で指定されたメカニズムを含む、6LFF技術の大ファミリに共通の動作と警告を指定します。これはその仕様から完全に継承されています。また、この文書で使用されている用語を定義します。圧縮形式、Datagram_tag、Datagram_size、fragmant_offset、および6lowpanフラグメント転送エンドポイント（一般に「エンドポイント」と同様に略）します。"
    },
    {
      "indent": 3,
      "text": "Past experience with fragmentation has shown that misassociated or lost fragments can lead to poor network behavior and, occasionally, trouble at the application layer. The reader is encouraged to read \"IPv4 Reassembly Errors at High Data Rates\" [RFC4963] and follow the references for more information. That experience led to the definition of the \"Path MTU Discovery for IP version 6\" [RFC8201] protocol that limits fragmentation over the Internet. Specifically, in the case of UDP, valuable additional information can be found in \"UDP Usage Guidelines\" [RFC8085].",
      "ja": "フラグメンテーションの過去の経験が、誤解されたまたは失われたフラグメントが、ネットワークの動作が悪く、時々、アプリケーション層でのトラブルにつながる可能性があることが示されています。リーダーは、「IPv4の再構成エラーが高いデータレートで読み込む」[RFC4963]を読み、詳細については参照に従ってください。その経験は、インターネット上の断片化を制限する「IPバージョン6のPATH MTUディスカバリ」の定義をもたらしました。具体的には、UDPの場合、「UDP使用上のガイドライン」[RFC8085]に貴重な追加情報を見つけることができます。"
    },
    {
      "indent": 3,
      "text": "\"The Benefits of Using Explicit Congestion Notification (ECN)\" [RFC8087] provides useful information on the potential benefits and pitfalls of using ECN.",
      "ja": "「明示的輻輳通知（ECN）を使用することの利点は、[RFC8087]はECNを使用する潜在的な利益と落とし穴に関する有用な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Quoting \"Multiprotocol Label Switching Architecture\" [RFC3031]:",
      "ja": "\"Multiprotocol Label Switche Architecture\"の引用[RFC3031]："
    },
    {
      "indent": 3,
      "text": "|  With MPLS, \"packets are \"labeled\" before they are forwarded [along\n|  a Label Switched Path (LSP)].  At subsequent hops, there is no\n|  further analysis of the packet's network layer header.  Rather,\n|  the label is used as an index into a table which specifies the\n|  next hop, and a new label\".",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8930] leverages MPLS to forward fragments that actually do not have a network-layer header, since the fragmentation occurs below IP, and this specification makes it reversible so the reverse path can be followed as well.",
      "ja": "[RFC8930]実際にネットワーク層ヘッダを持たないフラグメントを順番に活用し、断片化がIPを下回るため、この仕様にはリバースパスに従うことができます。"
    },
    {
      "indent": 0,
      "text": "2.3. Other Terms",
      "section_title": true,
      "ja": "2.3. その他の用語"
    },
    {
      "indent": 3,
      "text": "This specification uses the following terms:",
      "ja": "この仕様は以下の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "RFRAG: Recoverable Fragment",
      "ja": "RFRAG：回収可能な断片"
    },
    {
      "indent": 3,
      "text": "RFRAG-ACK: Recoverable Fragment Acknowledgment",
      "ja": "RFRAG-ACK：回復可能なフラグメント確認"
    },
    {
      "indent": 3,
      "text": "RFRAG Acknowledgment Request: An RFRAG with the Acknowledgment Request flag (\"X\" flag) set.",
      "ja": "RFRAG確認応答要求：確認応答要求フラグ（ \"X\"フラグ）を設定したRFRAG。"
    },
    {
      "indent": 3,
      "text": "NULL bitmap: Refers to a bitmap with all bits set to zero.",
      "ja": "NULLビットマップ：すべてのビットがゼロに設定されたビットマップを参照します。"
    },
    {
      "indent": 3,
      "text": "FULL bitmap: Refers to a bitmap with all bits set to one.",
      "ja": "フルビットマップ：すべてのビットを1つに設定したビットマップを参照します。"
    },
    {
      "indent": 3,
      "text": "Reassembling endpoint: The receiving endpoint.",
      "ja": "エンドポイントを再組み立てする：受信エンドポイント。"
    },
    {
      "indent": 3,
      "text": "Fragmenting endpoint: The sending endpoint.",
      "ja": "フラグメントエンドポイント：送信エンドポイント。"
    },
    {
      "indent": 3,
      "text": "Forward direction: The direction of a path, which is followed by the RFRAG.",
      "ja": "順方向：経路の方向に続くRFRAGが続く。"
    },
    {
      "indent": 3,
      "text": "Reverse direction: The reverse direction of a path, which is taken by the RFRAG-ACK.",
      "ja": "逆方向：RFRAG-ACKによって取られる経路の逆方向。"
    },
    {
      "indent": 0,
      "text": "3. Updating RFC 4944",
      "section_title": true,
      "ja": "3. RFC 4944を更新する"
    },
    {
      "indent": 3,
      "text": "This specification updates the fragmentation mechanism that is specified in [RFC4944] for use in route-over LLNs by providing a model where fragments can be forwarded end to end across a 6LoWPAN LLN and where fragments that are lost on the way can be recovered individually. A new format for fragments is introduced, and new dispatch types are defined in Section 5.",
      "ja": "この仕様は、6LOWPAN LLNを介して終了し、途中で途中で失われるフラグメントを個別に回復できるように、経路上LLNで使用するために[RFC4944]で指定されている断片化メカニズムを更新します。フラグメントのための新しいフォーマットが導入され、新しいディスパッチタイプがセクション5で定義されています。"
    },
    {
      "indent": 3,
      "text": "[RFC8138] allows modifying the size of a packet en route by removing the consumed hops in a compressed Routing Header. This requires that Fragment_Offset and Datagram_Size (defined in Section 5.1) also be modified en route, which is difficult to do in the uncompressed form. This specification expresses those fields in the compressed form and allows modifying them en route easily (more in Section 4.4).",
      "ja": "[RFC8138]圧縮されたルーティングヘッダーに消費されたホップを削除することで、Packet ENルートのサイズを変更できます。これには、fragment_offsetとdatagram_size（セクション5.1で定義）も修正されていない途中で、非圧縮形式では困難です。この仕様は、圧縮された形式でそれらのフィールドを表し、それらを簡単に変更することを可能にします（4.4節）。"
    },
    {
      "indent": 3,
      "text": "To be consistent with Section 2 of [RFC6282], for the fragmentation mechanism described in Section 5.3 of [RFC4944], any header that cannot fit within the first fragment MUST NOT be compressed when using the fragmentation mechanism described in this specification.",
      "ja": "[RFC4944]のセクション5.3に記載されているフラグメンテーションメカニズムのセクション2のセクション2と一致するために、この仕様で説明したフラグメンテーションメカニズムを使用すると、最初のフラグメント内に収まることができないヘッダーを圧縮してはいけません。"
    },
    {
      "indent": 0,
      "text": "4. Extending RFC 8930",
      "section_title": true,
      "ja": "4. RFC 8930を拡張する"
    },
    {
      "indent": 3,
      "text": "This specification implements the generic 6LFF technique defined in [RFC8930] and provides end-to-end fragment recovery and congestion control mechanisms.",
      "ja": "この仕様は[RFC8930]で定義されている一般的な6LFF手法を実装し、エンドツーエンドのフラグメントリカバリと輻輳制御メカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. Slack in the First Fragment",
      "section_title": true,
      "ja": "4.1. 最初の断片でたるみます"
    },
    {
      "indent": 3,
      "text": "[RFC8930] allows for a refragmentation operation in intermediate nodes, whereby the trailing bytes from a given fragment may be left in the VRB to be added as the heading bytes in the next fragment. This solves the case when the outgoing fragment needs more space than the incoming fragment; that case may arise when the 6LoWPAN header compression is not as efficient on the outgoing link or if the Link MTU is reduced.",
      "ja": "[RFC8930]中間ノードでのリフレージ処理を可能にし、それによって所与のフラグメントからの後続バイトを次のフラグメント内の見出しバイトとして追加するVRB内に残すことができる。これは、発信フラグメントが入力フラグメントよりも多くのスペースを必要とする場合を解決する。その場合、6LOWPANヘッダ圧縮が発信リンク上でも効率的ではない場合、またはリンクMTUが縮小されている場合に発生する可能性がある。"
    },
    {
      "indent": 3,
      "text": "This specification cannot allow that refragmentation operation since the fragments are recovered end to end based on a sequence number. The Fragment_Size MUST be tailored to fit the minimal MTU along the path, and the first fragment that contains a 6LoWPAN compressed header MUST have enough slack to enable a less-efficient compression in the next hops to still fit within the Link MTU.",
      "ja": "この仕様は、フラグメントがシーケンス番号に基づいて終了して末尾に回復されるため、そのためのその他の停止動作を許可することはできません。fragment_sizeは、パスに沿って最小のMTUを合わせるように調整されなければならず、6lowpan圧縮ヘッダーを含む最初のフラグメントは、次のホップ内の効率的な圧縮を依然としてリンクMTU内に収まるように可能にするのに十分なスラックを持っていなければなりません。"
    },
    {
      "indent": 3,
      "text": "For instance, if the fragmenting endpoint is also the 6LoWPAN compression endpoint, it will elide the Interface ID (IID) of the source IPv6 address when it matches the link-layer address [RFC6282]. In that case, it MUST leave slack in the first fragment as the if MTU on the first hop was 8 bytes less, so the next hop can expand the IID within the same fragment within MTU.",
      "ja": "たとえば、フラグメント化エンドポイントが6LOWPAN圧縮エンドポイントでもある場合は、リンクレイヤアドレス[RFC6282]と一致すると、ソースIPv6アドレスのインターフェイスID（IID）を除外します。その場合、最初のホップ上のIF MTUが8バイト少なかったため、最初のフラグメントにスラックを残す必要があるため、次のホップはMTU内の同じフラグメント内でIIDを拡張できます。"
    },
    {
      "indent": 0,
      "text": "4.2. Gap between Frames",
      "section_title": true,
      "ja": "4.2. フレーム間のギャップ"
    },
    {
      "indent": 3,
      "text": "[RFC8930] requires that a configurable interval of time be inserted between transmissions to the same next hop and, in particular, between fragments of a same datagram. In the case of half duplex interfaces, this inter-frame gap ensures that the next hop is done forwarding the previous frame and is capable of receiving the next one.",
      "ja": "[RFC8930]同じ時間の間隔を同じネクストホップ、特に同じデータグラムのフラグメント間の間に挿入することができます。半二重インタフェースの場合、このフレーム間ギャップは次のホップが前のフレームを転送し、次のホップを受信することができることを保証します。"
    },
    {
      "indent": 3,
      "text": "In the case of a mesh operating at a single frequency with omnidirectional antennas, a larger inter-frame gap is required to protect the frame against hidden terminal collisions with the previous frame of the same flow that is still progressing along a common path.",
      "ja": "全方向性アンテナを用いて単一周波数で動作するメッシュの場合、フレーム間ギャップは、隠れた端子衝突に対してフレームを共通の経路に沿って進行中の同じフローの前のフレームと保護するために必要とされる。"
    },
    {
      "indent": 3,
      "text": "The inter-frame gap is useful even for unfragmented datagrams, but it becomes a necessity for fragments that are typically generated in a fast sequence and are all sent over the exact same path.",
      "ja": "フレーム間ギャップは、折り返しされていないデータグラムに対してさえも有用であるが、それは典型的には高速シーケンスで生成されるフラグメントに対する必要性となり、全てまったく同じ経路を介して送信される。"
    },
    {
      "indent": 0,
      "text": "4.3. Congestion Control",
      "section_title": true,
      "ja": "4.3. 渋滞管理"
    },
    {
      "indent": 3,
      "text": "The inter-frame gap is the only protection that [RFC8930] imposes by default. This document enables grouping fragments in windows and requesting intermediate acknowledgments, so the number of in-flight fragments can be bounded. This document also adds an ECN mechanism that can be used to protect the network by adapting the size of the window, the size of the fragments, and/or the inter-frame gap.",
      "ja": "フレーム間ギャップは、デフォルトで[RFC8930]が課す唯一の保護です。このドキュメントは、Windowsでフラグメントをグループ化し、中間確認応答を要求することを可能にします。したがって、飛行中のフラグメントの数を制限することができます。この文書はまた、ウィンドウのサイズ、フラグメントのサイズ、および/またはフレーム間ギャップを適応させることによってネットワークを保護するために使用できるECNメカニズムを追加します。"
    },
    {
      "indent": 3,
      "text": "This specification enables the fragmenting endpoint to apply a congestion control mechanism to tune those parameters, but the mechanism itself is out of scope. In most cases, the expectation is that most datagrams will require only a few fragments, and that only the last fragment will be acknowledged. A basic implementation of the fragmenting endpoint is NOT REQUIRED to vary the size of the window, the duration of the inter-frame gap, or the size of a fragment in the middle of the transmission of a datagram, and it MAY ignore the ECN signal or simply reset the window to 1 (see Appendix C) until the end of this datagram upon detecting a congestion.",
      "ja": "この仕様では、フラグメント化エンドポイントがそれらのパラメータを調整するために輻輳制御メカニズムを適用することを可能にしますが、メカニズム自体は範囲外です。ほとんどの場合、期待はほとんどのデータグラムがいくつかのフラグメントしか必要としないことであり、最後のフラグメントだけが確認されます。断片化エンドポイントの基本的な実装は、ウィンドウのサイズ、フレーム間ギャップの持続時間、またはデータグラムの送信の中央のフラグメントのサイズを変える必要はなく、それはECN信号を無視することができる。または、輻輳を検出すると、このデータグラムの終わりまでウィンドウを1（付録Cを参照）にリセットするだけです。"
    },
    {
      "indent": 3,
      "text": "An intermediate node that experiences a congestion MAY set the ECN bit in a fragment, and the reassembling endpoint echoes the ECN bit at most once at the next opportunity to acknowledge back.",
      "ja": "輻輳を経験する中間ノードは、フラグメント内のECNビットを設定し、再組み立てエンドポイントは次の機会に答えるために一度にECNビットをエコーします。"
    },
    {
      "indent": 3,
      "text": "The size of the fragments is typically computed from the Link MTU to maximize the size of the resulting frames. The size of the window and the duration of the inter-frame gap SHOULD be configurable, to reduce the chances of congestion and to follow the general recommendations in [RFC8930], respectively.",
      "ja": "フラグメントのサイズは通常、結果として得られるフレームのサイズを最大にするためにリンクMTUから計算されます。ウィンドウのサイズとフレーム間ギャップの持続時間は、それぞれ輻輳の可能性を減らし、[RFC8930]の一般的な推奨事項に従うことができます。"
    },
    {
      "indent": 0,
      "text": "4.4. Modifying the First Fragment",
      "section_title": true,
      "ja": "4.4. 最初のフラグメントを変更します"
    },
    {
      "indent": 3,
      "text": "The compression of the hop limit, of the source and destination addresses in the IPv6 header, and of the Routing Header, which are all in the first fragment, may change en route in a route-over mesh LLN. If the size of the first fragment is modified, then the intermediate node MUST adapt the Datagram_Size, encoded in the Fragment_Size field, to reflect that difference.",
      "ja": "IPv6ヘッダーのソースアドレスおよび宛先アドレスの圧縮、および最初のフラグメント内のルーティングヘッダーの圧縮は、経路上のメッシュLLN内のENルートを変更することができる。最初のフラグメントのサイズが変更された場合、中間ノードはその違いを反映するために、fragment_sizeフィールドにエンコードされたDatagram_Sizeを適応させる必要があります。"
    },
    {
      "indent": 3,
      "text": "The intermediate node MUST also save the difference of Datagram_Size of the first fragment in the VRB and add it to the Fragment_Offset of all the subsequent fragments that it forwards for that datagram. In the case of a Source Routing Header 6LoWPAN Routing Header (SRH-6LoRH) [RFC8138] being consumed and thus reduced, that difference is negative, meaning that the Fragment_Offset is decremented by the number of bytes that were consumed.",
      "ja": "中間ノードはまた、VRB内の最初のフラグメントのデータグラム拡大の違いを保存し、それをそのデータグラムに対して転送したすべての後続のフラグメントのfragment_offsetに追加する必要があります。ソースルーティングヘッダ6lowpanルーティングヘッダ（SRH  -  6138）[RFC8138]が消費され、したがって減少すると、その差は負であり、その差は消費されたバイト数によってデクリメントされることを意味する。"
    },
    {
      "indent": 0,
      "text": "5. New Dispatch Types and Headers",
      "section_title": true,
      "ja": "5. 新しいディスパッチタイプとヘッダー"
    },
    {
      "indent": 3,
      "text": "This document specifies an alternative to the 6LoWPAN fragmentation sub-layer [RFC4944] to emulate a Link MTU up to 2048 bytes for the upper layer, which can be the 6LoWPAN header compression sub-layer that is defined in \"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks\" [RFC6282]. This specification also provides a reliable transmission of the fragments over a multi-hop 6LoWPAN route-over mesh network and a minimal congestion control to reduce the chances of congestion loss.",
      "ja": "このドキュメントは、6lowpanフラグメンテーションサブレイヤー[RFC4944]の代わりを指定して、「IPv6データグラムの圧縮形式」で定義されている6LOWPANヘッダー圧縮サブレイヤーである6LOWPANヘッダー圧縮サブレイヤーになることができます。IEEE 802.15.4ベースのネットワーク[RFC6282]。この仕様は、マルチホップ6LOWPANルートオーバーメッシュネットワーク上でのフラグメントの信頼性の高い送信と、輻輳損失の可能性を低減するための最小限の輻輳制御を提供します。"
    },
    {
      "indent": 3,
      "text": "A 6LoWPAN Fragment Forwarding [RFC8930] technique derived from MPLS enables the forwarding of individual fragments across a 6LoWPAN route-over mesh without reassembly at each hop. The Datagram_Tag is used as a label; it is locally unique to the node that owns the source link-layer address of the fragment, so together the link-layer address and the label can identify the fragment globally within the lifetime of the datagram. A node may build the Datagram_Tag in its own locally significant way, as long as the chosen Datagram_Tag stays unique to the particular datagram for its lifetime. The result is that the label does not need to be globally unique, but it must be swapped at each hop as the source link-layer address changes.",
      "ja": "MPLSから導出された6LOWPANフラグメント転送[RFC8930]技術は、各ホップでの再組み立てなしで6LOWPANルートオーバーメッシュを横切る個々のフラグメントを転送することを可能にする。Datagram_tagはラベルとして使用されます。フラグメントのソースリンク層アドレスを所有するノードにローカルに固有のものであるので、リンク層アドレスとラベルはデータグラムの存続期間内にグローバルに識別することができます。選択されたDatagram_tagがその生涯のために特定のデータグラムに固有のままである限り、ノードはそれ自体でDatagram_tagを構築することができる。その結果、ラベルはグローバルに一意である必要がないが、ソースリンク層アドレスが変更されると各ホップでスワップされなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the following sections, a Datagram_Tag extends the semantics defined in \"Fragmentation Type and Header\" (see Section 5.3 of [RFC4944]). The Datagram_Tag is a locally unique identifier for the datagram from the perspective of the sender. This means that the Datagram_Tag identifies a datagram uniquely in the network when associated with the source of the datagram. As the datagram gets forwarded, the source changes, and the Datagram_Tag must be swapped as detailed in [RFC8930].",
      "ja": "次のセクションでは、datagram_tagは \"fragmentation typeとheader\"で定義されているセマンティクスを拡張します（[RFC4944]のセクション5.3を参照）。datagram_tagは、送信者の観点からデータグラムのローカルに一意の識別子です。つまり、Datagram_tagは、データグラムのソースに関連付けられているときにネットワーク内でデータグラムを一意に識別することを意味します。データグラムが転送されると、ソースが変わり、Datagram_tagは[RFC8930]に詳述されているようにスワップする必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification extends [RFC4944] with two new dispatch types for RFRAG and the RFRAG-ACK that is received back. The new 6LoWPAN dispatch types are taken from [RFC8025], as indicated in Table 1 of Section 9.",
      "ja": "この仕様は、RFRAGの2つの新しいディスパッチタイプとRFRAG-ACKの2つの新しいディスパッチタイプとともに、受信されたRFC4944です。セクション9の表1に示すように、新しい6LOWPANディスパッチタイプが[RFC8025]から取得されます。"
    },
    {
      "indent": 0,
      "text": "5.1. Recoverable Fragment Dispatch Type and Header",
      "section_title": true,
      "ja": "5.1. 回復可能なフラグメントディスパッチタイプとヘッダー"
    },
    {
      "indent": 3,
      "text": "In this specification, if the packet is compressed, the size and offset of the fragments are expressed with respect to the compressed form of the packet, as opposed to the uncompressed (native) form.",
      "ja": "本明細書では、パケットが圧縮されている場合、圧縮されていない（ネイティブ）フォームとは対照的に、フラグメントのサイズおよびオフセットは、パケットの圧縮形式に関して表現される。"
    },
    {
      "indent": 3,
      "text": "The format of the fragment header is shown in Figure 1. It is the same for all fragments even though the Fragment_Offset is overloaded. The format has a length and an offset, as well as a Sequence field. This would be redundant if the offset was computed as the product of the Sequence by the length, but this is not the case. The position of a fragment in the reassembly buffer is correlated with neither the value of the Sequence field nor the order in which the fragments are received. This enables splitting fragments to cope with an MTU deduction; see the example of fragment Sequence 5 that is retried end to end as smaller fragment Sequences 13 and 14 in Section 6.2.",
      "ja": "フラグメントヘッダーのフォーマットを図1に示します.fragment_offsetがオーバーロードされていても、すべてのフラグメントで同じです。フォーマットは、シーケンスフィールドと同様に長さとオフセットを持ちます。オフセットがシーケンスの積として長さによって計算された場合、これは冗長になりますが、これはそうではありません。再構成バッファ内のフラグメントの位置は、シーケンスフィールドの値もフラグメントが受信される順序でも相関していません。これにより、分割フラグメントをMTU控除に対処することができます。セクション6.2では、より小さなフラグメント配列13および14として終了する断片配列5の例を参照のこと。"
    },
    {
      "indent": 3,
      "text": "The first fragment is recognized by a Sequence of 0; it carries its Fragment_Size and the Datagram_Size of the compressed packet before it is fragmented, whereas the other fragments carry their Fragment_Size and Fragment_Offset. The last fragment for a datagram is recognized when its Fragment_Offset and its Fragment_Size add up to the stored Datagram_Size of the packet identified by the sender link-layer address and the Datagram_Tag.",
      "ja": "第1の断片は0のシーケンスによって認識される。それは断片化される前に、そのfragment_sizeと圧縮パケットのデータグラムズサイズを描画しますが、他のフラグメントはそれらのfragment_sizeとfragment_offsetを持ちます。データグラムの最後のフラグメントは、そのfragment_offsetとそのfragment_sizeが、送信者リンク層アドレスとDatagram_tagによって識別されたパケットの格納されたデータグラム拡張に追加されるときに認識されます。"
    },
    {
      "indent": 7,
      "text": "                       1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |1 1 1 0 1 0 0|E|  Datagram_Tag |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|X| Sequence|   Fragment_Size   |       Fragment_Offset         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 48,
      "text": "X set == Ack-Request",
      "ja": "x set == ack-request."
    },
    {
      "indent": 18,
      "text": "Figure 1: RFRAG Dispatch Type and Header",
      "ja": "図1：RFRAGディスパッチタイプとヘッダー"
    },
    {
      "indent": 3,
      "text": "X: 1 bit; Ack-Request. When set, the fragmenting endpoint requires an RFRAG Acknowledgment from the reassembling endpoint.",
      "ja": "x：1ビット。ACK要求設定すると、断片化エンドポイントは、再組み立てエンドポイントからRFRAG確認応答を必要とします。"
    },
    {
      "indent": 3,
      "text": "E: 1 bit; Explicit Congestion Notification. The \"E\" flag is cleared by the source of the fragment and set by intermediate routers to signal that this fragment experienced congestion along its path.",
      "ja": "E：1ビット。明示的な輻輳通知「E」フラグはフラグメントのソースによってクリアされ、中間ルータによって設定されてこのフラグメントがそのパスに沿って輻輳を経験したことを知らせる。"
    },
    {
      "indent": 3,
      "text": "Fragment_Size: 10-bit unsigned integer. The size of this fragment in a unit that depends on link-layer technology. Unless overridden by a more specific specification, that unit is the byte, which allows fragments up to 1023 bytes.",
      "ja": "fragment_size：10ビットの符号なし整数。リンク層技術に依存するユニット内のこのフラグメントのサイズ。より具体的な仕様によって上書きされない限り、その単位はバイトです。これは最大1023バイトのフラグメントを可能にします。"
    },
    {
      "indent": 3,
      "text": "Datagram_Tag: 8 bits. An identifier of the datagram that is locally unique to the link-layer sender.",
      "ja": "Datagram_tag：8ビットリンク層送信者にローカルに固有のデータグラムの識別子。"
    },
    {
      "indent": 3,
      "text": "Sequence: 5-bit unsigned integer. The sequence number of the fragment in the acknowledgment bitmap. Fragments are numbered as [0..N], where N is in [0..31]. A Sequence of 0 indicates the first fragment in a datagram, but non-zero values are not indicative of the position in the reassembly buffer.",
      "ja": "シーケンス：5ビット符号なし整数。確認応答ビットマップ内のフラグメントのシーケンス番号。フラグメントは[0..N]として番号付けされ、ここでNは[0..31]にある。1のシーケンスはデータグラム内の最初のフラグメントを示しますが、ゼロ以外の値は再組み立てバッファ内の位置を示していません。"
    },
    {
      "indent": 3,
      "text": "Fragment_Offset: 16-bit unsigned integer.",
      "ja": "fragment_offset：16ビットの符号なし整数。"
    },
    {
      "indent": 6,
      "text": "When the Fragment_Offset is set to a non-zero value, its semantics depend on the value of the Sequence field as follows:",
      "ja": "fragment_offsetがゼロ以外の値に設定されている場合、そのセマンティクスは次のようにシーケンスフィールドの値によって異なります。"
    },
    {
      "indent": 6,
      "text": "* For a first fragment (i.e., with a Sequence of 0), this field indicates the Datagram_Size of the compressed datagram, to help the reassembling endpoint allocate an adapted buffer for the reception and reassembly operations. The fragment may be stored for local reassembly. Alternatively, it may be routed based on the destination IPv6 address. In that case, a VRB state must be installed as described in Section 6.1.1.",
      "ja": "* 第1のフラグメント（すなわち、0のシーケンスを有する）の場合、このフィールドは圧縮データグラムのデータグラムを示し、エンドポイントの再組み立てが受信および再構成演算のために適合されたバッファを割り当てるのを助ける。フラグメントは局所的な再構成のために記憶されてもよい。あるいは、宛先IPv6アドレスに基づいてルーティングされてもよい。その場合、6.1.1項の説明に従ってVRB状態をインストールする必要があります。"
    },
    {
      "indent": 6,
      "text": "* When the Sequence is not 0, this field indicates the offset of the fragment in the compressed form of the datagram. The fragment may be added to a local reassembly buffer or forwarded based on an existing VRB as described in Section 6.1.2.",
      "ja": "* シーケンスが0ではない場合、このフィールドはデータグラムの圧縮形式のフラグメントのオフセットを示します。フラグメントは、セクション6.1.2に記載されているように、既存のVRBに基づいてローカルの再構成バッファに追加されてもよい。"
    },
    {
      "indent": 6,
      "text": "A Fragment_Offset that is set to a value of 0 indicates an abort condition, and all states regarding the datagram should be cleaned up once the processing of the fragment is complete; the processing of the fragment depends on whether there is a VRB already established for this datagram and if the next hop is still reachable:",
      "ja": "値0に設定されているfragment_offsetは中止状態を示し、データグラムに関するすべての状態はフラグメントの処理が完了するとクリーンアップされる必要があります。フラグメントの処理は、このデータグラムに対してすでに確立されているVRBがあるかどうかによって、次のホップがまだ到達可能である場合に依存します。"
    },
    {
      "indent": 6,
      "text": "* if a VRB already exists and the next hop is still reachable, the fragment is to be forwarded along the associated LSP as described in Section 6.1.2, without checking the value of the Sequence field.",
      "ja": "* VRBがすでに存在し、次のホップが依然として到達可能である場合、そのフラグメントは、シーケンスフィールドの値をチェックすることなく、セクション6.1.2で説明されているように関連するLSPに沿って転送されます。"
    },
    {
      "indent": 6,
      "text": "* else, if the Sequence is 0, then the fragment is to be routed as described in Section 6.1.1, but no state is conserved afterwards. In that case, the session, if it exists, is aborted, and the packet is also forwarded in an attempt to clean up the next hops along the path indicated by the IPv6 header (possibly including a Routing Header).",
      "ja": "* そうでなければ、シーケンスが0の場合、そのフラグメントはセクション6.1.1で説明されているようにルーティングされますが、その後状態は保存されません。その場合、セッションが存在する場合は中止され、パケットはIPv6ヘッダー（ある場合もルーティングヘッダーを含む）が示すパスに沿って次のホップをクリーンアップしようとする試みに転送されます。"
    },
    {
      "indent": 6,
      "text": "* else (the Sequence is non-zero and either no VRB exists or the next hop is unavailable), the fragment cannot be forwarded or routed; the fragment is discarded and an abort RFRAG-ACK is sent back to the source as described in Section 6.1.2.",
      "ja": "* そうでなければ（シーケンスはゼロ以外で、VRBが存在しないか、次のホップが使用できない）、フラグメントは転送またはルーティングされません。フラグメントは破棄され、ABORT RFRAG-ACKがセクション6.1.2に記載されているようにソースに送り返されます。"
    },
    {
      "indent": 3,
      "text": "Recoverable Fragments are sequenced, and a bitmap is used in the RFRAG Acknowledgment to indicate the received fragments by setting the individual bits that correspond to their sequence.",
      "ja": "回復可能なフラグメントがシーケンスされ、ビットマップがRFRAG確認応答で使用され、それらの配列に対応する個々のビットを設定することによって受信された断片を示す。"
    },
    {
      "indent": 3,
      "text": "There is no requirement on the reassembling endpoint to check that the received fragments are consecutive and non-overlapping. This may be useful, in particular, in the case where the MTU changes and a fragment Sequence is retried with a smaller Fragment_Size, with the remainder of the original fragment being retried with new Sequence values. The fragmenting endpoint knows that the datagram is fully received when the acknowledged fragments cover the whole datagram, which is implied by a FULL bitmap.",
      "ja": "受信したフラグメントが連続して非重複していることを確認するために、エンドポイントを再割り当てにする必要はありません。これは、特に、MTUが変更され、フラグメントシーケンスがより小さなfragment_sizeで再試行され、残りの部分は新しいシーケンス値で再試行される場合に有用であり得る。断片化エンドポイントは、認証されたフラグメントがデータグラム全体をカバーしたときにデータグラムが完全に受信され、これは全ビットマップによって暗黙的に受信されます。"
    },
    {
      "indent": 0,
      "text": "5.2. RFRAG Acknowledgment Dispatch Type and Header",
      "section_title": true,
      "ja": "5.2. RFRAG承認ディスパッチタイプとヘッダー"
    },
    {
      "indent": 3,
      "text": "This specification also defines a 4-byte RFRAG Acknowledgment Bitmap that is used by the reassembling endpoint to selectively confirm the reception of individual fragments. A given offset in the bitmap maps one to one with a given sequence number and indicates which fragment is acknowledged as follows:",
      "ja": "この仕様はまた、個々のフラグメントの受信を選択的に確認するために再組み立てエンドポイントによって使用される4バイトのRFRAG確認応答ビットマップを定義します。ビットマップ内の与えられたオフセットは、あるシーケンス番号を持つ1対1にマッピングされ、次のようにどのフラグメントが確認されているかを示します。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           RFRAG Acknowledgment Bitmap                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n ^                 ^\n |                 |    bitmap indicating whether:\n |                 +----- Fragment with Sequence 9 was received\n +----------------------- Fragment with Sequence 0 was received",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 2: RFRAG Acknowledgment Bitmap Encoding",
      "ja": "図2：RFRAG肯定応答ビットマップエンコーディング"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows an example RFRAG Acknowledgment Bitmap that indicates that all fragments from Sequence 0 to 20 were received, except for fragments 1, 2, and 16, which were lost and must be retried.",
      "ja": "図3は、失われた断片1,2、および16を除いて、シーケンス0から20のすべてのフラグメントが受信されたことを示す例示的なRFRAG確認応答ビットマップを示す。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1|0|0|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 3: Example RFRAG Acknowledgment Bitmap",
      "ja": "図3：RFRAG確認応答ビットマップの例"
    },
    {
      "indent": 3,
      "text": "The RFRAG Acknowledgment Bitmap is included in an RFRAG Acknowledgment header, as follows:",
      "ja": "RFrag確認応答ビットマップは、次のようにRFrag確認応答ヘッダに含まれています。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |1 1 1 0 1 0 1|E|  Datagram_Tag |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          RFRAG Acknowledgment Bitmap (32 bits)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 4: RFRAG Acknowledgment Dispatch Type and Header",
      "ja": "図4：RFRAG確認応答ディスパッチタイプとヘッダー"
    },
    {
      "indent": 3,
      "text": "E: 1 bit; Explicit Congestion Notification Echo.",
      "ja": "E：1ビット。明示的な輻輳通知エコー。"
    },
    {
      "indent": 6,
      "text": "When set, the fragmenting endpoint indicates that at least one of the acknowledged fragments was received with an Explicit Congestion Notification, indicating that the path followed by the fragments is subject to congestion. See more details in Appendix C.",
      "ja": "設定すると、断片化エンドポイントは、承認されたフラグメントの少なくとも1つが明示的な輻輳通知で受信され、その後のフラグメントが輻輳の対象となることを示します。付録Cの詳細を参照してください。"
    },
    {
      "indent": 3,
      "text": "Datagram_Tag: 8 bits; an identifier of the datagram that is locally unique to the link-layer recipient.",
      "ja": "Datagram_tag：8ビットリンク層受信者にローカルに固有のデータグラムの識別子。"
    },
    {
      "indent": 3,
      "text": "RFRAG Acknowledgment Bitmap: An RFRAG Acknowledgment Bitmap, whereby setting the bit at offset x indicates that fragment x was received, as shown in Figure 2. A NULL bitmap indicates that the fragmentation process is aborted. A FULL bitmap indicates that the fragmentation process is complete; all fragments were received at the reassembly endpoint.",
      "ja": "RFRAG肯定応答ビットマップ：rFRAG肯定応答ビットマップ。図2に示すように、オフセットXのビットを設定することを示す。フルビットマップは、フラグメンテーションプロセスが完了したことを示します。すべてのフラグメントは再組み立てエンドポイントで受信されました。"
    },
    {
      "indent": 0,
      "text": "6. Fragment Recovery",
      "section_title": true,
      "ja": "6. フラグメントの回復"
    },
    {
      "indent": 3,
      "text": "The RFRAG header is used to transport a fragment and optionally request an RFRAG-ACK that confirms the reception of one or more fragments. An RFRAG-ACK is carried as a standalone fragment header (i.e., with no 6LoWPAN payload) in a message that is propagated back to the fragmenting endpoint. To achieve this, each hop that performed an MPLS-like operation on fragments reverses that operation for the RFRAG-ACK by sending a frame from the next hop to the previous hop as known by its link-layer address in the VRB. The Datagram_Tag in the RFRAG-ACK is unique to the reassembling endpoint and is enough information for an intermediate hop to locate the VRB that contains the Datagram_Tag used by the previous hop and the Layer 2 information associated with it (interface and link-layer address).",
      "ja": "RFRAGヘッダは、フラグメントを輸送し、任意選択で1つ以上のフラグメントの受信を確認するRFRAG  -  ACKを要求するために使用される。RFRAG-ACKは、断片化エンドポイントに伝播されるメッセージに、スタンドアロンフラグメントヘッダー（すなわち6LOWPANペイロードのない）として搬送される。これを達成するために、フラグメントに対してMPLS様操作を実行した各ホップは、VRB内のリンク層アドレスによって知られているように、RFRAG  -  ACKの動作をrFRAG  -  ACKの動作を元に戻す。RFRAG-ACKのDatagram_tagは、再組み立てエンドポイントに固有のもので、前のホップで使用されているDATRAMGRAM_TAGを含むVRBを見つけるのに十分な情報であり、それに関連したレイヤ2の情報（インタフェースとリンク層アドレス）。"
    },
    {
      "indent": 3,
      "text": "The fragmenting endpoint (i.e., the node that fragments the packets at the 6LoWPAN level) also controls the number of acknowledgments by setting the Ack-Request flag in the RFRAG packets.",
      "ja": "断片化エンドポイント（すなわち、6LOWPANレベルのパケットをフラグメント化するノード）も、RFRAGパケット内のack要求フラグを設定することによって肯定応答の数を制御する。"
    },
    {
      "indent": 3,
      "text": "The fragmenting endpoint may set the Ack-Request flag on any fragment to perform congestion control by limiting the number of outstanding fragments, which are the fragments that have been sent but for which reception or loss was not positively confirmed by the reassembling endpoint. The maximum number of outstanding fragments is controlled by the Window-Size. It is configurable and may vary in case of ECN notification. When the endpoint that reassembles the packets at the 6LoWPAN level receives a fragment with the Ack-Request flag set, it MUST send an RFRAG-ACK back to the originator to confirm reception of all the fragments it has received so far.",
      "ja": "断片化エンドポイントは、送信されたフラグメントであるが、受信または損失が再割り当てエンドポイントによって積極的に確認されていなかった、輻輳制御を実行するために任意のフラグメント上にack要求フラグを設定することができる。未解決のフラグメントの最大数は、ウィンドウサイズによって制御されます。それは設定可能で、ECN通知の場合にはさまざまです。6LOWPANレベルのパケットにアセスポイントを再組み立てするエンドポイントがACK要求フラグセットを含むフラグメントを受信すると、これまでに受信したすべてのフラグメントの受信を確認するために、RFRAG-ACKをオリジネータに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Ack-Request (\"X\") set in an RFRAG marks the end of a window. This flag MUST be set on the last fragment if the fragmenting endpoint wishes to perform an automatic repeat request (ARQ) process for the datagram, and it MAY be set in any intermediate fragment for the purpose of congestion control.",
      "ja": "RFRAGに設定されているACK要求（ \"x\"）はウィンドウの終わりをマークします。断片化エンドポイントがデータグラムに対して自動繰り返し要求（ARQ）プロセスを実行したい場合は、最後のフラグメントに設定する必要があり、輻輳制御の目的で任意の中間フラグメントに設定することができます。"
    },
    {
      "indent": 3,
      "text": "This ARQ process MUST be protected by a Retransmission Timeout (RTO) timer, and the fragment that carries the \"X\" flag MAY be retried upon a timeout for a configurable number of times (see Section 7.1) with an exponential backoff. Upon exhaustion of the retries, the fragmenting endpoint may either abort the transmission of the datagram or resend the first fragment with an \"X\" flag set in order to establish a new path for the datagram and obtain the list of fragments that were received over the old path in the acknowledgment bitmap. When the fragmenting endpoint knows that an underlying link-layer mechanism protects the fragments, it may refrain from using the RFRAG Acknowledgment mechanism and never set the Ack-Request bit.",
      "ja": "このARQプロセスは再送信タイムアウト（RTO）タイマーによって保護されなければならず、指数関数的なバックオフで構成可能な回数のタイムアウト時にタイムアウト時に再試行されてもよい。再試行の枯渇時に、断片化エンドポイントはデータグラムの送信を中止したり、データグラムのための新しいパスを確立したり、受信されたフラグメントのリストを取得するためにセットされた「x」フラグを持つ最初のフラグメントを再送することができます。確認応答ビットマップの古いパス。断片化エンドポイントが、基礎となるリンク層メカニズムがフラグメントを保護することを知っている場合、RFRAG確認応答メカニズムを使用し、ACK要求ビットを設定しないことを控えることができます。"
    },
    {
      "indent": 3,
      "text": "The reassembling endpoint MAY issue unsolicited acknowledgments. An unsolicited acknowledgment signals to the fragmenting endpoint that it can resume sending in case it has reached its maximum number of outstanding fragments. Another use is to inform the fragmenting endpoint that the reassembling endpoint aborted the processing of an individual datagram.",
      "ja": "再組み立てエンドポイントは、迷惑な承認を発行することができます。それが最大数の未解決のフラグメント数に達した場合に送信を再開できる断片化エンドポイントへの迷惑な確認応答信号。もう1つの使用は、再組み立てエンドポイントが個々のデータグラムの処理を中止したことを断片化したエンドポイントに通知することです。"
    },
    {
      "indent": 3,
      "text": "The RFRAG Acknowledgment carries an ECN indication for congestion control (see Appendix C). The reassembling endpoint of a fragment with the \"E\" (ECN) flag set MUST echo that information at most once by setting the \"E\" (ECN) flag in the next RFRAG-ACK.",
      "ja": "RFRAG確認応答は、輻輳制御のためのECN表示を担当します（付録Cを参照）。「E」（ECN）フラグセットを有するフラグメントのアンセミングエンドポイントは、次のRFRAG  -  ACKに「E」（ECN）フラグを設定することによって、その情報を最大1回要請する必要がある。"
    },
    {
      "indent": 3,
      "text": "In order to protect the datagram, the fragmenting endpoint transfers a controlled number of fragments and flags to the last fragment of a window with an RFRAG Acknowledgment Request. The reassembling endpoint MUST acknowledge a fragment with the acknowledgment request bit set. If any fragment immediately preceding an acknowledgment request is still missing, the reassembling endpoint MAY intentionally delay its acknowledgment to allow in-transit fragments to arrive. Because it might defeat the round-trip time computation, delaying the acknowledgment should be configurable and not enabled by default.",
      "ja": "データグラムを保護するために、断片化エンドポイントは、RFrag確認応答要求を使用して、制御された数のフラグメントとフラグをウィンドウの最後のフラグメントに転送します。再組み立てエンドポイントは、確認応答要求ビットセットを含むフラグメントを承認する必要があります。肯定応答要求の直前のフラグメントがまだ欠落している場合、再割り当てエンドポイントは意図的にその確認を遅らせて遷移のフラグメントを到着させることができる。往復時間の計算を倒す可能性があるため、確認応答を遅らせる必要があり、デフォルトでは有効になっていないはずです。"
    },
    {
      "indent": 3,
      "text": "When enough fragments are received to cover the whole datagram, the reassembling endpoint reconstructs the packet, passes it to the upper layer, sends an RFRAG-ACK on the reverse path with a FULL bitmap, and arms a short timer, e.g., on the order of an average round-trip time in the network. The FULL bitmap is used as opposed to a bitmap that acknowledges only the received fragments to let the intermediate nodes know that the datagram is fully received. As the timer runs, the reassembling endpoint absorbs the fragments that were still in flight for that datagram without creating a new state, acknowledging the ones that bear an Ack-Request with an FRAG Acknowledgment and the FULL bitmap. The reassembling endpoint aborts the communication if fragments with a matching source and Datagram-Tag continue to be received after the timer expires.",
      "ja": "データグラム全体をカバーするのに十分な断片を受信すると、再組み立てエンドポイントはパケットを再構成し、それを上位層に渡し、完全なビットマップとの逆パスにRFRAG-ACKを送信し、短いタイマー、例えば順番に短いタイマーを駆動します。ネットワークにおける平均往復時間の。フルビットマップは、データグラムが完全に受信されていることを中間ノードに知らせるために受信したフラグメントのみを確認するビットマップとは対照的に使用されます。タイマーが実行されると、再組み立てエンドポイントは、新しい状態を作成せずにまだそのデータグラムのフライト内にあるフラグメントを吸収し、agk-requestおよびfull bitmapを使用してACK-Requestを獲得するものを認めます。一致するソースとデータグラムタグを持つフラグメントが期限切れになった後に継続して受信され続ける場合、再組み立てエンドポイントは通信を中止します。"
    },
    {
      "indent": 3,
      "text": "Note that acknowledgments might consume precious resources, so the use of unsolicited acknowledgments SHOULD be configurable and not enabled by default.",
      "ja": "確認応答は貴重なリソースを消費する可能性があるため、迷惑な確認応答を使用することで、デフォルトで有効になっていない必要があります。"
    },
    {
      "indent": 3,
      "text": "An observation is that streamlining the forwarding of fragments generally reduces the latency over the LLN mesh, providing room for retries within existing upper-layer reliability mechanisms. The fragmenting endpoint protects the transmission over the LLN mesh with a retry timer that is configured for a use case and may be adapted dynamically, e.g., according to the method detailed in [RFC6298]. It is expected that the upper-layer retry mechanism obeys the recommendations in [RFC8085], in which case a single round of fragment recovery should fit within the upper-layer recovery timers.",
      "ja": "観察は、フラグメントの転送を合理化することは一般にLLNメッシュに対する待ち時間を減少させることであり、既存の上層信頼性メカニズム内の再試行のための部屋を提供する。断片化エンドポイントは、使用例のために構成されているリトライタイマと共にLLNメッシュを介して送信を保護し、例えば、[RFC6298]に詳述された方法に従って動的に適合させることができる。上位層の再試行メカニズムは[RFC8085]で推奨事項に従うことが予想され、その場合、単一ラウンドのフラグメントリカバリが上位リカバリタイマに適合するはずです。"
    },
    {
      "indent": 3,
      "text": "Fragments MUST be sent in a round-robin fashion: the sender MUST send all the fragments for a first time before it retries any lost fragment; lost fragments MUST be retried in sequence, oldest first. This mechanism enables the receiver to acknowledge fragments that were delayed in the network before they are retried.",
      "ja": "フラグメントはラウンドロビンファッションで送信する必要があります。送信者は、失われたフラグメントを再試行する前に、すべてのフラグメントを初めて送信する必要があります。失われたフラグメントは、最も古く、最も古い順番に再試行する必要があります。このメカニズムにより、受信側はネットワーク内で遅延されたフラグメントを再試行する前に確認できます。"
    },
    {
      "indent": 3,
      "text": "When a single radio frequency is used by contiguous hops, the fragmenting endpoint SHOULD insert a delay between the frames (e.g., carrying fragments) that are sent to the same next hop. The delay SHOULD cover multiple transmissions so as to let a frame progress a few hops and avoid hidden terminal issues. This precaution is not required on channel hopping technologies such as Time-Slotted Channel Hopping (TSCH) [RFC6554], where nodes that communicate at Layer 2 are scheduled to send and receive, respectively, and different hops operate on different channels.",
      "ja": "単一の無線周波数が連続ホップによって使用されるとき、フラグメント化エンドポイントは、同じネクストホップに送信されるフレーム（例えば、フラグメント）間の遅延を挿入するべきである。フレームが数ホップを進行させ、隠された端末の問題を回避できるように、遅延は複数の送信をカバーする必要があります。この予防措置は、タイムスロットチャネルホッピング（TSCH）[RFC6554]などのチャネルホッピング技術では必要ありません。ここで、レイヤ2で通信するノードはそれぞれ送信および受信がスケジュールされ、異なるホップが異なるチャンネルで動作します。"
    },
    {
      "indent": 0,
      "text": "6.1. Forwarding Fragments",
      "section_title": true,
      "ja": "6.1. 転送フラグメント"
    },
    {
      "indent": 3,
      "text": "This specification inherits from [RFC8930] and proposes a Virtual Reassembly Buffer technique to forward fragments with no intermediate reconstruction of the entire datagram.",
      "ja": "この仕様は[RFC8930]から継承し、データグラム全体の中間再構成なしでフラグメントを転送するための仮想再構成バッファ技術を提案します。"
    },
    {
      "indent": 3,
      "text": "The IPv6 header MUST be placed in the first fragment in full to enable the routing decision. The first fragment is routed and creates an LSP from the fragmenting endpoint to the reassembling endpoint. The next fragments are label switched along that LSP. As a consequence, the next fragments can only follow the path that was set up by the first fragment; they cannot follow an alternate route. The Datagram_Tag is used to carry the label, which is swapped in each hop.",
      "ja": "ルーティング決定を可能にするために、IPv6ヘッダーを最初のフラグメントに置く必要があります。最初のフラグメントはルーティングされ、断片化エンドポイントから再組み立てエンドポイントへLSPを作成します。次のフラグメントはそのLSPに沿ってラベルが切り替わります。結果として、次のフラグメントは、最初のフラグメントによって設定されたパスにのみ従うことができます。彼らは代替経路をたどることができません。Datagram_tagは、各ホップにスワップされているラベルを伝送するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the first fragment is too large for the path MTU, it will repeatedly fail and never establish an LSP. In that case, the fragmenting endpoint MAY retry the same datagram with a smaller Fragment_Size, in which case it MUST abort the original attempt and use a new Datagram_Tag for the new attempt.",
      "ja": "PATH MTUにとって最初のフラグメントが大きすぎると、それは繰り返し失敗し、LSPを確立することはありません。その場合、フラグメント化エンドポイントは同じデータグラムを小さなfragment_sizeで再試行することができ、その場合、元の試みを中止し、新しい試みのために新しいDatagram_tagを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Receiving the First Fragment",
      "section_title": true,
      "ja": "6.1.1. 最初の断片を受け取る"
    },
    {
      "indent": 3,
      "text": "In route-over mode, the source and destination link-layer addresses in a frame change at each hop. The label that is formed and placed in the Datagram_Tag by the sender is associated with the source link-layer address and only valid (and temporarily unique) for that source link-layer address.",
      "ja": "ルートオーバーモードでは、各ホップでフレームの変更内の送信元リンク層と宛先のリンク層がアドレス指定されます。送信者によって形成されデータグラムτに配置されたラベルは、ソースリンク層アドレスに関連付けられ、そのソースリンク層アドレスに対してのみ有効（そして一時的に一意）に関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the first fragment (i.e., with a Sequence of 0), an intermediate router creates a VRB and the associated LSP state indexed by the incoming interface, the previous-hop link-layer address, and the Datagram_Tag and forwards the fragment along the IPv6 route that matches the destination IPv6 address in the IPv6 header until it reaches the reassembling endpoint, as prescribed by [RFC8930]. The LSP state enables matching the next incoming fragments of a datagram to the abstract forwarding information of the next interface, source and next-hop link-layer addresses, and the swapped Datagram_Tag.",
      "ja": "第1のフラグメント（すなわち、0のシーケンスを有する）を受信すると、中間ルータは、着信インターフェース、前のホップ層アドレス、およびデータグラムτによって索引付けされたVRBおよび関連するLSP状態を作成し、その断片を転送する。[RFC8930]で規定されているように、IPv6ヘッダーの宛先IPv6アドレスと一致するIPv6ルート。LSP状態は、データグラムの次の着信フラグメントを次のインターフェイス、ソースリンク層アドレス、スワップされたDatagram_tagの抽象転送情報と一致させることができます。"
    },
    {
      "indent": 3,
      "text": "In addition, the router also forms a reverse LSP state indexed by the interface to the next hop, the link-layer address the router uses as source for that datagram, and the swapped Datagram_Tag. This reverse LSP state enables matching the tuple (interface, destination link-layer address, Datagram_Tag) found in an RFRAG-ACK to the abstract forwarding information (previous interface, previous link-layer address, Datagram_Tag) used to forward the RFRAG-ACK back to the fragmenting endpoint.",
      "ja": "さらに、ルータは、インターフェイスによってインデックスされたリバースLSP状態をネクストホップに挿入し、ルータがそのデータグラムのソースとして使用され、スワップされたDatagram_tagが使用されます。この逆LSP状態により、RFRAG-ACKで見つかったTUPLE（インタフェース、宛先リンク層アドレス、Datagram_tag）をRFRAG-ACKの転送に使用される抽象転送情報（前のインタフェース、前のリンクレイヤアドレス、Datagram_tag）にマッチングできます。断片化の終点に。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Receiving the Next Fragments",
      "section_title": true,
      "ja": "6.1.2. 次のフラグメントを受信します"
    },
    {
      "indent": 3,
      "text": "Upon receiving the next fragment (i.e., with a non-zero Sequence), an intermediate router looks up an LSP indexed by the tuple (incoming interface, previous-hop link-layer address, Datagram_Tag) found in the fragment. If it is found, the router forwards the fragment using the associated VRB as prescribed by [RFC8930].",
      "ja": "次のフラグメントを受信すると（すなわち、非ゼロシーケンスを有する）、中間ルータは、フラグメント内に見つかったタプル（着信インターフェース、前のホップリンク層アドレス、データグラム名）によって索引付けされたLSPを検索する。見つかった場合、ルータは[RFC8930]で規定されているように関連するVRBを使用してフラグメントを転送します。"
    },
    {
      "indent": 3,
      "text": "If the VRB for the tuple is not found, the router builds an RFRAG-ACK to abort the transmission of the packet. The resulting message has the following information:",
      "ja": "タプルのVRBが見つからない場合、ルータはパケットの送信を中止するためにRFRAG-ACKを構築します。結果のメッセージには次の情報があります。"
    },
    {
      "indent": 3,
      "text": "* The source and destination link-layer addresses are swapped from those found in the fragment, and the same interface is used",
      "ja": "* ソースおよび宛先のリンク層アドレスはフラグメント内のものからスワップされ、同じインターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "* The Datagram_Tag is set to the Datagram_Tag found in the fragment",
      "ja": "* datagram_tagは、フラグメント内にあるdatagram_tagに設定されています"
    },
    {
      "indent": 3,
      "text": "* A NULL bitmap is used to signal the abort condition",
      "ja": "* ヌルビットマップは中止状態を知らせるために使用されます"
    },
    {
      "indent": 3,
      "text": "At this point, the router is all set and can send the RFRAG-ACK back to the previous router. The RFRAG-ACK should normally be forwarded all the way to the source using the reverse LSP state in the VRBs in the intermediate routers as described in the next section.",
      "ja": "この時点で、ルータはすべて設定されており、RFRAG-ACKを前のルータに送り返すことができます。次のセクションで説明されているように、RFRAG-ACKは通常、中間ルータ内のVRBSの逆LSP状態を使用してソースにすべて転送されます。"
    },
    {
      "indent": 3,
      "text": "[RFC8930] indicates that the reassembling endpoint stores \"the actual packet data from the fragments received so far, in a form that makes it possible to detect when the whole packet has been received and can be processed or forwarded\". How this is computed is implementation specific, but it relies on receiving all the bytes up to the Datagram_Size indicated in the first fragment. An implementation may receive overlapping fragments as the result of retries after an MTU change.",
      "ja": "[RFC8930]アプライを受信したフラグメントからの実際のパケットデータを、パケット全体が受信され、処理または転送できるようにすることができるようにするための形式で、再検査エンドポイントが「実際のパケットデータ」を記憶することを示している。これがどのように計算されているかは実装固有ですが、最初のフラグメントに示されているDatagram_Sizeまでのすべてのバイトを受信することに依存しています。実装は、MTUの変更後の再試行の結果として重複フラグメントを受信することができる。"
    },
    {
      "indent": 0,
      "text": "6.2. Receiving RFRAG Acknowledgments",
      "section_title": true,
      "ja": "6.2. RFRAG承認を受信します"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an RFRAG-ACK, the router looks up a reverse LSP indexed by the interface and destination link-layer address of the received frame and the received Datagram_Tag in the RFRAG-ACK. If it is found, the router forwards the fragment using the associated VRB as prescribed by [RFC8930], but it uses the reverse LSP so that the RFRAG-ACK flows back to the fragmenting endpoint.",
      "ja": "RFRAG  -  ACKを受信すると、ルータは、受信フレームのインタフェースおよび宛先リンク層アドレスおよびRFRAG  -  ACK内の受信データグラムτによって索引付けされた逆LSPを検索する。見つかった場合、ルータは[RFC8930]で規定されているように関連するVRBを使用してフラグメントを転送しますが、RFRAG-ACKが断片化エンドポイントに戻ってリバースLSPを使用します。"
    },
    {
      "indent": 3,
      "text": "If the reverse LSP is not found, the router MUST silently drop the RFRAG-ACK message.",
      "ja": "リバースLSPが見つからない場合、ルータはRFRAG-ACKメッセージを黙ってドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "Either way, if the RFRAG-ACK indicates that the fragment was entirely received (FULL bitmap), it arms a short timer, and upon timeout, the VRB and all the associated states are destroyed. Until the timer elapses, fragments of that datagram may still be received, e.g., if the RFRAG-ACK was lost on the path back, and the source retried the last fragment. In that case, the router generates an RFRAG-ACK with a FULL bitmap back to the fragmenting endpoint if an acknowledgment was requested; else, it silently drops the fragment.",
      "ja": "どちらの方法でも、rfrag-ackがフラグメントが完全に受信されたことを示している場合（フルビットマップ）、それは短いタイマーをアームし、タイムアウト時に、VRBとすべての関連状態が破壊されます。タイマーが経過するまで、そのデータグラムのフラグメントは、rfrag-ackがパス上に失われた場合、およびソースが最後のフラグメントを再試行するかもしれません。その場合、肯定応答が要求された場合、ルータはフルビットマップを断片化エンドポイントに戻すRFRAG-ACKを生成します。そうでなければ、それは静かに断片を落とします。"
    },
    {
      "indent": 3,
      "text": "This specification does not provide a method to discover the number of hops or the minimal value of MTU along those hops. In a typical case, the MTU is constant and is the same across the network. But should the minimal MTU along the path decrease, it is possible to retry a long fragment (say a Sequence of 5) with several shorter fragments with a Sequence that was not used before (e.g., 13 and 14). Fragment 5 is marked as abandoned and will not be retried anymore. Note that when this mechanism is in place, it is hard to predict the total number of fragments that will be needed or the final shape of the bitmap that would cover the whole packet. This is why the FULL bitmap is used when the reassembling endpoint gets the whole datagram regardless of which fragments were actually used to do so. Intermediate nodes will know unambiguously that the process is complete. Note that Path MTU Discovery is out of scope for this document.",
      "ja": "この仕様は、ホップ数またはそれらのホップに沿ってMTUの最小値を発見する方法を提供しません。典型的な場合では、MTUは一定であり、ネットワーク全体で同じです。しかし、経路に沿った最小のMTUが減少する場合、前に（例えば、13および14）使用されなかった配列を有するいくつかの短い断片を有する長いフラグメント（5のシーケンス）を再試行することが可能である。フラグメント5は放棄されたとマークされており、もう再試行されません。このメカニズムが整っているときは、パケット全体をカバーするビットマップの最終形状または最終形状の合計数を予測するのが困難です。これが、どのフラグメントが実際に使用されているかにかかわらず、再組み立てエンドポイントがデータグラム全体を取得するときにフルビットマップが使用される理由です。中間ノードは、プロセスが完了したことを明確に知っています。PATU MTUディスカバリーはこの文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6.3. Aborting the Transmission of a Fragmented Packet",
      "section_title": true,
      "ja": "6.3. 断片化されたパケットの送信を中止する"
    },
    {
      "indent": 3,
      "text": "A reset is signaled on the forward path with a pseudo fragment that has the Fragment_Offset set to 0. The sender of a reset SHOULD also set the Sequence and Fragment_Size field to 0.",
      "ja": "リセットは、Fragment_Offsetが0に設定されている疑似フラグメントを使用して順方向経路上にシグナリングされます。リセットの送信者は、シーケンスとfragment_sizeフィールドも0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the fragmenting endpoint or a router on the path decides that a packet should be dropped and the fragmentation process aborted, it generates a reset pseudo fragment and forwards it down the fragment path.",
      "ja": "断片化エンドポイントまたはパス上のルータがドロップされ、フラグメンテーションプロセスが中止されるべきであることを決定すると、リセット疑似フラグメントを生成し、それをフラグメントパスを転送します。"
    },
    {
      "indent": 3,
      "text": "Each router along the path forwards the pseudo fragment in turn based on the VRB state. If an acknowledgment is not requested, the VRB and all associated states are destroyed.",
      "ja": "経路に沿った各ルータは、VRB状態に基づいて擬似フラグメントを順番に転送します。確認応答が要求されていない場合は、VRBとすべての関連状態が破棄されます。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the pseudo fragment, the reassembling endpoint cleans up all resources for the packet associated with the Datagram_Tag. If an acknowledgment is requested, the reassembling endpoint responds with a NULL bitmap.",
      "ja": "疑似フラグメントを受信すると、reacsemblingエンドポイントはDatagram_tagに関連付けられているパケットのすべてのリソースをクリーンアップします。確認応答が要求されている場合は、再組み立てエンドポイントはNULLビットマップで応答します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the reassembling endpoint might need to abort the processing of a fragmented packet for internal reasons, for instance, if it is out of reassembly buffers, already uses all 256 possible values of the Datagram_Tag, or keeps receiving fragments beyond a reasonable time while it considers that this packet is already fully reassembled and was passed to the upper layer. In that case, the reassembling endpoint SHOULD indicate so to the fragmenting endpoint with a NULL bitmap in an RFRAG-ACK.",
      "ja": "一方、再組み立てエンドポイントは、内部理由で断片化されたパケットの処理を中止する必要があるかもしれません。たとえば、再組み立てバッファの不可能な場合は、既にDatagram_tagのすべての256個の可能な値を使用するか、または妥当ながらフラグメントを受け取ります。このパケットがすでに完全に再組み立てされていると考える間、上位層に渡されたことがわかります。その場合、Reassemblingエンドポイントは、RFRAG-ACKのNULLビットマップを使用してフラグメント化エンドポイントに指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The RFRAG-ACK is forwarded all the way back to the source of the packet and cleans up all resources on the path. Upon an acknowledgment with a NULL bitmap, the fragmenting endpoint MUST abort the transmission of the fragmented datagram with one exception: in the particular case of the first fragment, it MAY decide to retry via an alternate next hop instead.",
      "ja": "RFRAG-ACKはパケットの送信元に戻り、パス上のすべてのリソースを消去します。NULLビットマップを使用して確認応答すると、フラグメント化エンドポイントは、1つの例外を持つフラグメント化されたデータグラムの送信を中止しなければなりません。最初のフラグメントの特定のケースでは、代わりに代替の次のホップを介して再試行することを決定します。"
    },
    {
      "indent": 0,
      "text": "6.4. Applying Recoverable Fragmentation along a Diverse Path",
      "section_title": true,
      "ja": "6.4. 多様な経路に沿って回収可能な断片化を適用する"
    },
    {
      "indent": 3,
      "text": "The text above can be read with the assumption of a serial path between a source and a destination. The IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH) architecture (see Section 4.5.3 of [6TiSCH]) defines the concept of a Track that can be a complex path between a source and a destination with Packet ARQ, Replication, Elimination, and Overhearing (PAREO) along the Track. This specification can be used along any subset of the complex Track where the first fragment is flooded. The last RFRAG Acknowledgment is flooded on that same subset in the reverse direction. Intermediate RFRAG Acknowledgments can be flooded on any sub-subset of that reverse subset that reaches back to the source.",
      "ja": "上記のテキストは、ソースと宛先の間のシリアルパスを想定して読み取ることができます。IEEE 802.15.4E（6Tisch）アーキテクチャのTSCHモード（[6tisch）のTSCHモードでIPv6（[6tisch]のセクション4.5.3を参照）は、パケットARQ、レプリケーション、レプリケーションを使用して、ソースと宛先の間の複雑なパスになることができるトラックの概念を定義します。トラックに沿った除去、過熱（パレオ）。この仕様は、最初のフラグメントがフラッディングされている複素トラックの任意のサブセットに沿って使用できます。最後のRFRAG確認応答は、その同じサブセットに逆方向にあふれています。中間RFRAG肯定応答は、ソースに戻るその逆のサブセットの任意のサブサブセットにフラッディングできます。"
    },
    {
      "indent": 0,
      "text": "7. Management Considerations",
      "section_title": true,
      "ja": "7. 管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification extends [RFC8930] and requires the same parameters in the reassembling endpoint and on intermediate nodes. There is no new parameter as echoing ECN is always on. These parameters typically include the reassembly timeout at the reassembling endpoint, an inactivity cleanup timer on the intermediate nodes, and the number of messages that can be processed in parallel in all nodes.",
      "ja": "この仕様は[RFC8930]を拡張し、再組み立てエンドポイントと中間ノードに同じパラメータを必要とします。エコーECNが常にオンになっているので、新しいパラメータはありません。これらのパラメータは通常、再組み立てエンドポイントでの再構成タイムアウト、中間ノード上の非アクティブクリーンアップタイマ、およびすべてのノードで並列に処理できるメッセージの数を含みます。"
    },
    {
      "indent": 3,
      "text": "The configuration settings introduced by this specification only apply to the fragmenting endpoint, which is in full control of the transmission. LLNs vary a lot in size (there can be thousands of nodes in a mesh), in speed (from 10 Kbps to several Mbps at the PHY layer), in traffic density, and in optimizations that are desired (e.g., the selection of a Routing Protocol for LLNs (RPL) [RFC6550] Objective Function [RFC6552] impacts the shape of the routing graph).",
      "ja": "この仕様によって導入された構成設定は、送信を完全に制御する断片化エンドポイントにのみ適用されます。LLNSは大きさが多い（メッシュ内に数千のノードがある可能性がある）、トラフィック密度、および望まれる最適化（例えば、の選択など）の速度（10kbpsから数Mbpsまで）LLNS（RPL）のルーティングプロトコル[RFC6550]目標関数[RFC6552]は、ルーティンググラフの形状に影響します。"
    },
    {
      "indent": 3,
      "text": "For that reason, only very generic guidance can be given on the settings of the fragmenting endpoint and on whether complex algorithms are needed to perform congestion control or to estimate the round-trip time. To cover the most complex use cases, this specification enables the fragmenting endpoint to vary the fragment size, the window size, and the inter-frame gap based on the number of losses, the observed variations of the round-trip time, and the setting of the ECN bit.",
      "ja": "そのため、断片化エンドポイントの設定と、複雑なアルゴリズムが輻輳制御を実行するため、または往復時間を推定するのかについて、非常に一般的なガイダンスのみを与えることができます。最も複雑なユースケースをカバーするために、この仕様では、フラグメント化エンドポイントは、損失数、幅の幅の変動、往復時間のバリエーション、および設定に基づいて、フラグメントサイズ、ウィンドウサイズ、およびフレーム間ギャップを変えることができます。ECNビットの。"
    },
    {
      "indent": 0,
      "text": "7.1. Protocol Parameters",
      "section_title": true,
      "ja": "7.1. プロトコルパラメータ"
    },
    {
      "indent": 3,
      "text": "The management system SHOULD be capable of providing the parameters listed in this section, and an implementation MUST abide by those parameters and, in particular, never exceed the minimum and maximum configured boundaries.",
      "ja": "管理システムはこのセクションにリストされているパラメータを提供することができ、実装はそれらのパラメータによって従う必要があり、特に最小および最大構成の境界を超えないようにしてください。"
    },
    {
      "indent": 3,
      "text": "An implementation should consider the generic recommendations from the IETF in the matter of congestion control and rate management for IP datagrams in [RFC8085]. An implementation may perform congestion control by using a dynamic value of the window size (Window_Size), adapting the fragment size (Fragment_Size), and potentially reducing the load by inserting an inter-frame gap that is longer than necessary. In a large network where nodes contend for the bandwidth, a larger Fragment_Size consumes less bandwidth but also reduces fluidity and incurs higher chances of loss in transmission.",
      "ja": "実装は、[RFC8085]のIPデータグラムの輻輳制御とレート管理の問題のIETFからの一般的な推奨事項を考慮する必要があります。実装は、ウィンドウサイズ（window_size）の動的値を使用し、フラグメントサイズ（fragment_size）を適合させ、必要以上に長いフレーム間ギャップを挿入することによって負荷を潜在的に低減することによって輻輳制御を実行することができる。ノードが帯域幅に競合する大規模ネットワークでは、より大きなフラグメント_SIZEは帯域幅が少ないだけでなく、流動性を低下させ、伝送中の損失の可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "This is controlled by the following parameters:",
      "ja": "これは次のパラメータによって制御されます。"
    },
    {
      "indent": 3,
      "text": "inter-frame gap: The inter-frame gap indicates the minimum amount of time between transmissions. The inter-frame gap controls the rate at which fragments are sent, the ratio of air time, and the amount of memory in intermediate nodes that a particular datagram will use. It can be used as a flow control, a congestion control, and/ or a collision control measure. It MUST be set at a minimum to a value that protects the propagation of one transmission against collision with next [RFC8930]. In a wireless network that uses the same frequency along a path, this may represent the time for a frame to progress over multiple hops (see more in Section 4.2). It SHOULD be augmented beyond this as necessary to protect the network against congestion.",
      "ja": "フレーム間ギャップ：フレーム間ギャップは、送信間の最小時間を示します。フレーム間ギャップは、特定のデータグラムが使用する中間ノードにおけるフラグメント、空気時間の比、およびメモリの量を制御する。それはフロー制御、輻輳制御、および/または衝突制御尺度として使用することができる。次の[RFC8930]との衝突に対する1つの伝送の伝播を保護する値まで最小限に設定する必要があります。パスに沿って同じ周波数を使用する無線ネットワークでは、これはフレームの時間を複数のホップにわたって進行させる時間を表すことができる（セクション4.2を参照）。ネットワークを輻輳から保護するために必要に応じてこれを超えて増強する必要があります。"
    },
    {
      "indent": 3,
      "text": "MinFragmentSize: The MinFragmentSize is the minimum value for the Fragment_Size. It MUST be lower than the minimum value of smallest 1-hop MTU that can be encountered along the path.",
      "ja": "MinFragmentsize：MinFragmentsizeはfragment_sizeの最小値です。パスに沿って遭遇する可能性がある最小1ホップMTUの最小値より低い必要があります。"
    },
    {
      "indent": 3,
      "text": "OptFragmentSize: The OptFragmentSize is the value for the Fragment_Size that the fragmenting endpoint should use to start with. It is greater than or equal to MinFragmentSize. It is less than or equal to MaxFragmentSize. For the first fragment, it must account for the expansion of the IPv6 addresses and of the Hop Limit field within MTU. For all fragments, it is a balance between the expected fluidity and the overhead of link-layer and 6LoWPAN headers. For a small MTU, the idea is to keep it close to the maximum, whereas for larger MTUs, it might make sense to keep it short enough so that the duty cycle of the transmitter is bounded, e.g., to transmit at least 10 frames per second.",
      "ja": "OptFragmentsize：OptFragmentsizeは、フラグメント化されたエンドポイントが起動するために使用するfragment_sizeの値です。それはMinFragansize以上です。それはMaxFragmentsize以下のものです。最初のフラグメントでは、IPv6アドレスの拡張とMTU内のホップリミットフィールドの拡張を説明する必要があります。すべてのフラグメントについては、予想される流動性とリンク層と6lowpanヘッダーのオーバーヘッドのバランスです。小さなMTUの場合、その考えはそれを最大に近づけることですが、より大きなMTUのためには、トランスミッタのデューティサイクルが境界が制限されるように理性があるかもしれません。第二。"
    },
    {
      "indent": 3,
      "text": "MaxFragmentSize: The MaxFragmentSize is the maximum value for the Fragment_Size. It MUST be lower than the maximum value of the smallest 1-hop MTU that can be encountered along the path. A large value augments the chances of buffer bloat and transmission loss. The value MUST be less than 512 if the unit that is defined for the PHY layer is the byte.",
      "ja": "MaxFragmentsize：maxFragmentsizeはfragment_sizeの最大値です。パスに沿って遭遇する可能性がある最小の1ホップMTUの最大値より低くなければなりません。大きな値は、バッファぼけと伝送損失の可能性を増大させる。PHYレイヤに定義されている単位がバイトである場合、値は512未満でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Window_Size: The Window_Size MUST be at least 1 and less than 33.",
      "ja": "window_size：window_sizeは1以上33未満でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the round-trip time is known, the Window_Size SHOULD be set to the round-trip time divided by the time per fragment; that is, the time to transmit a fragment plus the inter-frame gap.",
      "ja": "* 往復時間がわかっている場合、window_sizeはフラグメントあたりの時間で割った往復時間に設定する必要があります。つまり、フラグメントとフレーム間ギャップを送信する時間。"
    },
    {
      "indent": 6,
      "text": "Otherwise:",
      "ja": "さもないと："
    },
    {
      "indent": 6,
      "text": "* A window_size of 32 indicates that only the last fragment is to be acknowledged in each round. This is the RECOMMENDED value in a half-duplex LLN where the fragment acknowledgment consumes roughly the same bandwidth on the same links as the fragments themselves.",
      "ja": "* 32のwindow_sizeは、最後のフラグメントのみが各ラウンドで確認されることを示します。これは、フラグメント確認応答がフラグメント自体と同じリンク上でほぼ同じ帯域幅を消費する半二重LLNの推奨値です。"
    },
    {
      "indent": 6,
      "text": "* If it is set to a smaller value, more acks are generated. In a full-duplex network, the load on the forward path will be lower, and a small value of 3 SHOULD be configured.",
      "ja": "* 小さい値に設定されている場合は、より多くのACKが生成されます。全二重ネットワークでは、順方向パスの負荷が低くなり、3つの小さい値を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation may perform its estimate of the RTO or use a configured one. The ARQ process is controlled by the following parameters:",
      "ja": "実装はRTOの推定値を実行するか、または設定されたものを使用することができる。ARQプロセスは、次のパラメータによって制御されます。"
    },
    {
      "indent": 3,
      "text": "MinARQTimeOut: The minimum amount of time a node should wait for an RFRAG Acknowledgment before it takes the next action. It MUST be more than the maximum expected round-trip time in the respective network.",
      "ja": "MinarqTimeout：ノードが次のアクションを実行する前に、ノードがRFRAG確認を待機する最小時間。それはそれぞれのネットワークにおける最大予想往復時間以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "OptARQTimeOut: The initial value of the RTO, which is the amount of time that a fragmenting endpoint should wait for an RFRAG Acknowledgment before it takes the next action. It is greater than or equal to MinARQTimeOut. It is less than or equal to MaxARQTimeOut. See Appendix C for recommendations on computing the round-trip time. By default, a value of 3 times the maximum expected round-trip time in the respective network is RECOMMENDED.",
      "ja": "OptarqTimeout：RTOの初期値。フラグメントエンドポイントが次のアクションを取る前にRFRAG確認応答を待つ時間です。それはMinarqTimeout以上です。maxarqtimeout以下である。往復時間の計算に関する推奨事項については、付録Cを参照してください。デフォルトでは、各ネットワーク内の最大予想往復時間の3倍の値をお勧めします。"
    },
    {
      "indent": 3,
      "text": "MaxARQTimeOut: The maximum amount of time a node should wait for the RFRAG Acknowledgment before it takes the next action. It must cover the longest expected round-trip time and be several times less than the timeout that covers the recomposition buffer at the reassembling endpoint, which is typically on the order of the minute. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.",
      "ja": "maxarqtimeout：ノードが次のアクションを取得する前に、ノードがRFRAG確認応答を待つ最大時間。それは最長の予想される往復時間をカバーしなければなりません、そして、再組み立てエンドポイントで再構成バッファをカバーするタイムアウトより数倍小さい、これは通常は分のオーダーです。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。"
    },
    {
      "indent": 3,
      "text": "MaxFragRetries: The maximum number of retries for a particular fragment. A default value of 3 is RECOMMENDED. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.",
      "ja": "MaxFragraties：特定のフラグメントの再試行回数の最大数。デフォルト値3をお勧めします。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。"
    },
    {
      "indent": 3,
      "text": "MaxDatagramRetries: The maximum number of retries from scratch for a particular datagram. A default value of 1 is RECOMMENDED. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.",
      "ja": "MaxDatagramRetries：特定のデータグラムのスクラッチからの再試行回数。デフォルト値1をお勧めします。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。"
    },
    {
      "indent": 3,
      "text": "An implementation may be capable of performing congestion control based on ECN; see Appendix C. This is controlled by the following parameter:",
      "ja": "実装は、ECNに基づいて輻輳制御を実行することができる。付録Cを参照してください。これは次のパラメータによって制御されます。"
    },
    {
      "indent": 3,
      "text": "UseECN: Indicates whether the fragmenting endpoint should react to ECN. The fragmenting endpoint may react to ECN by varying the Window_Size between MinWindowSize and MaxWindowSize, varying the Fragment_Size between MinFragmentSize and MaxFragmentSize, and/or increasing or reducing the inter-frame gap. With this specification, if UseECN is set and a fragmenting endpoint detects a congestion, it may apply a congestion control method until the end of the datagram, whereas if UseECN is reset, the endpoint does not react to congestion. Future specifications may provide additional parameters and capabilities.",
      "ja": "USEECN：フラグメント化エンドポイントがECNに反応するかどうかを示します。断片化エンドポイントは、MinWindowsizeとMaxWindowsizeとの間のwindow_sizeを変えることによってECNに反応して、MinFragmentsizeとMaxFragmentsizeとの間のfragment_sizeを変え、フレーム間ギャップを増減させることができます。この仕様では、useecnが設定され、断片化エンドポイントが輻輳を検出した場合、データグラムの終わりまで輻輳制御方法を適用することができますが、USEECNがリセットされている場合、エンドポイントは輻輳に反応しません。将来の仕様は、追加のパラメータと機能を提供し得る。"
    },
    {
      "indent": 0,
      "text": "7.2. Observing the Network",
      "section_title": true,
      "ja": "7.2. ネットワークを観察する"
    },
    {
      "indent": 3,
      "text": "The management system should monitor the number of retries and ECN settings that can be observed from the perspective of the fragmenting endpoint with respect to the reassembling endpoint and reciprocally. It may then tune the optimum size of Fragment_Size and of Window_Size, OptFragmentSize, and OptWindowSize, respectively, at the fragmenting endpoint towards a particular reassembling endpoint, which is applicable to the next datagrams. It will preferably tune the inter-frame gap to increase the spacing between fragments of the same datagram and reduce the buffer bloat in the intermediate node that holds one or more fragments of that datagram.",
      "ja": "管理システムは、再組み立てエンドポイントに関して断片化エンドポイントの観点から見た再試行およびECN設定の数を監視する必要があります。次に、フラグメント化されたエンドポイントに断片化されたエンドポイントで、Fragment_Sizeの最適なサイズとwindow_size、optfragmentsize、およびoptwindowsizeを調整することができます。これは次のデータグラムに適用されます。それは、同じデータグラムのフラグメント間の間隔を増加させ、そのデータグラムの1つまたは複数のフラグメントを保持する中間ノード内のバッファぼりを減らすために、フレーム間ギャップを調整することが好ましい。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document specifies an instantiation of a 6LFF technique and inherits from the generic description in [RFC8930]. The considerations in the Security Considerations section of [RFC8930] equally apply to this document.",
      "ja": "このドキュメントは6LFFテクニックのインスタンス化を指定し、[RFC8930]の一般的な説明から継承します。[RFC8930]の[セキュリティ上の考慮事項]セクションの考慮事項は、この文書にも同様に適用されます。"
    },
    {
      "indent": 3,
      "text": "In addition to the threats detailed therein, an attacker that is on path can prematurely end the transmission of a datagram by sending a RFRAG Acknowledgment to the fragmenting endpoint. It can also cause extra transmissions of fragments by resetting bits in the RFRAG Acknowledgment Bitmap and of RFRAG Acknowledgments by forcing the Ack-Request bit in fragments that it forwards.",
      "ja": "そこに詳述されている脅威に加えて、経路上にある攻撃者は、断片化エンドポイントにRFRAG確認応答を送信することによってデータグラムの送信を時期尚早に終了させることができる。それはまた、RFRAG確認応答ビットマップのビットをリセットすることによってフラグメントの追加的な送信を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "As indicated in [RFC8930], secure joining and link-layer security are REQUIRED to protect against those attacks, as the fragmentation protocol does not include any native security mechanisms.",
      "ja": "[RFC8930]に示されているように、断片化プロトコルにはネイティブのセキュリティメカニズムが含まれていないため、安全な参加とリンク層のセキュリティはこれらの攻撃から保護するために必要です。"
    },
    {
      "indent": 3,
      "text": "This specification does not recommend a particular algorithm for the estimation of the duration of the RTO that covers the detection of the loss of a fragment with the \"X\" flag set; regardless, an attacker on the path may slow down or discard packets, which in turn can affect the throughput of fragmented packets.",
      "ja": "この仕様は、「X」フラグセットを用いたフラグメントの損失の検出を網羅するRTOの持続時間を推定するための特定のアルゴリズムを推奨するものではない。とにかく、パス上の攻撃者はパケットを遅くまたは破棄することができ、それは断片化されたパケットのスループットに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Compared to [RFC4944], this specification reduces the Datagram_Tag to 8 bits, and the tag wraps faster than with [RFC4944]. But for a constrained network where a node is expected to be able to hold only one or a few large packets in memory, 256 is still a large number. Also, the acknowledgment mechanism allows cleaning up the state rapidly once the packet is fully transmitted or aborted.",
      "ja": "[RFC4944]と比較して、この仕様はDatagram_tagを8ビットに縮小し、タグは[RFC4944]よりも速くラップされます。しかし、ノードがメモリ内の1つか数つの大きなパケットだけを保持できるようになると予想される制約付きネットワークでは、256はまだ大きい数です。また、肯定応答メカニズムは、パケットが完全に送信または中止されると、状態を迅速にクリーンアップすることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The abstract Virtual Recovery Buffer from [RFC8930] may be used to perform a Denial-of-Service (DoS) attack against the intermediate routers since the routers need to maintain a state per flow. The particular VRB implementation technique described in [LWIG-FRAG] allows realigning which data goes in which fragment; this causes the intermediate node to store a portion of the data, which adds an attack vector that is not present with this specification. With this specification, the data that is transported in each fragment is conserved, and the state to keep does not include any data that would not fit in the previous fragment.",
      "ja": "[RFC8930]からの抽象仮想回復バッファを使用して、ルータはフローごとに状態を維持する必要があるため、中間ルータに対してサービス拒否（DOS）攻撃を実行できます。[lwig-frag]で説明されている特定のVRB実装手法では、どのデータがどのフラグメントになるかを実現できます。これにより、中間ノードはデータの一部を格納し、この仕様には存在しない攻撃ベクトルを追加します。この仕様では、各フラグメントで転送されるデータは保存され、保持する状態には、前のフラグメントに収まらないデータは含まれません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document allocates two patterns for a total of four dispatch values for Recoverable Fragments from the \"Dispatch Type Field\" registry that was created by [RFC4944] and reformatted by \"IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging Dispatch\" [RFC8025].",
      "ja": "この文書は、[RFC4944]によって作成され、[RFC4944]によって作成され、「IPv6を介した[IPv6）によって作成された「Dispatch Typeフィールド」レジストリの合計4つのパターンを割り当てます。[6LOWPAN）ページングディスパッチ \"RFC8025]。"
    },
    {
      "indent": 3,
      "text": "+-------------+------+----------------------------------+-----------+\n| Bit Pattern | Page | Header Type                      | Reference |\n+-------------+------+----------------------------------+-----------+\n| 11 10100x   | 0    | RFRAG - Recoverable Fragment     | RFC 8931  |\n+-------------+------+----------------------------------+-----------+\n| 11 10100x   | 1-14 | Unassigned                       |           |\n+-------------+------+----------------------------------+-----------+\n| 11 10100x   | 15   | Reserved for Experimental Use    | RFC 8025  |\n+-------------+------+----------------------------------+-----------+\n| 11 10101x   | 0    | RFRAG-ACK - RFRAG                | RFC 8931  |\n|             |      | Acknowledgment                   |           |\n+-------------+------+----------------------------------+-----------+\n| 11 10101x   | 1-14 | Unassigned                       |           |\n+-------------+------+----------------------------------+-----------+\n| 11 10101x   | 15   | Reserved for Experimental Use    | RFC 8025  |\n+-------------+------+----------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 1: Additional Dispatch Value Bit Patterns",
      "ja": "表1：追加のディスパッチ値ビットパターン"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4919] Kushalnagar, N., Montenegro, G., and C. Schumacher, \"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals\", RFC 4919, DOI 10.17487/RFC4919, August 2007, <https://www.rfc-editor.org/info/rfc4919>.",
      "ja": "[RFC4919] Kushalnagar、N.、Montenegro、G.、Schumacher、C. Schumacher、「低電力無線パーソナルエリアネットワーク（6lowpans）：概要、仮定、問題ステートメント、および目標、RFC 4919、DOI 10.17487 / RFC49192007年8月、<https：//www.rfc-editor.org/info/rfc4919>。"
    },
    {
      "indent": 3,
      "text": "[RFC4944] Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler, \"Transmission of IPv6 Packets over IEEE 802.15.4 Networks\", RFC 4944, DOI 10.17487/RFC4944, September 2007, <https://www.rfc-editor.org/info/rfc4944>.",
      "ja": "[RFC4944]モンテネグロ、G.、Kushalnagar、N.、Hui、J.、およびD.Culler、「IEEE 802.15.4ネットワーク上のIPv6パケットの送信」、RFC 4944、DOI 10.17487 / RFC4944、2007年9月、<https：//www.rfc-editor.org/info/rfc4944>。"
    },
    {
      "indent": 3,
      "text": "[RFC6282] Hui, J., Ed. and P. Thubert, \"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks\", RFC 6282, DOI 10.17487/RFC6282, September 2011, <https://www.rfc-editor.org/info/rfc6282>.",
      "ja": "[RFC6282] HUI、J.、ED。2011年9月、2011年9月、2011年9月、<https：//www.rfc-editor.org/info/rfc6282、<https：//www.rfc-editor.org/info/rfc6282>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J.、およびM.Sargent、「コンピューティングTCPの再送信タイマー」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<https：///www.rfc-editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[RFC6606] Kim, E., Kaspar, D., Gomez, C., and C. Bormann, \"Problem Statement and Requirements for IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing\", RFC 6606, DOI 10.17487/RFC6606, May 2012, <https://www.rfc-editor.org/info/rfc6606>.",
      "ja": "[RFC6606] KIM、E.、KASPAR、D.、Gomez、C、およびC. Bormann、「低電力無線パーソナルエリアネットワーク（6LOWPAN）ルーティングにおけるIPv6の要件」、RFC 6606、DOI 10.17487 /rfc6606、2012年5月、<https://www.rfc-editor.org/info/rfc6606>。"
    },
    {
      "indent": 3,
      "text": "[RFC8025] Thubert, P., Ed. and R. Cragie, \"IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging Dispatch\", RFC 8025, DOI 10.17487/RFC8025, November 2016, <https://www.rfc-editor.org/info/rfc8025>.",
      "ja": "[RFC8025] Thubert、P.、ED。そしてR. Cragie、「低電力無線パーソナルエリアネットワーク（6lowpan）ページングディスパッチ」、RFC 8025、DOI 10.17487 / RFC8025、2016年11月、<https：//www.rfc-editor.org/info/rfc8025>。"
    },
    {
      "indent": 3,
      "text": "[RFC8138] Thubert, P., Ed., Bormann, C., Toutain, L., and R. Cragie, \"IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing Header\", RFC 8138, DOI 10.17487/RFC8138, April 2017, <https://www.rfc-editor.org/info/rfc8138>.",
      "ja": "[RFC8138] Thubert、P.、ED。、Bormann、C、Toutain、L.、R. Cragie、R.Cragie、「低電力無線パーソナルエリアネットワーク（6LOWPAN）ルーティングヘッダ」、RFC 8138、DOI 10.17487 / RFC8138、2017年4月、<https://www.rfc-editor.org/info/rfc8138>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] The'th、S.およびR.hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https：//www.rfc-editor.org/ info / rfc8200>。"
    },
    {
      "indent": 3,
      "text": "[RFC8930] Watteyne, T., Ed., Thubert, P., Ed., and C. Bormann, \"On Forwarding 6LoWPAN (IPv6 over Low-Power Wireless Personal Area Network) Fragments over a Multi-Hop IPv6 Network\", RFC 8930, DOI 10.17487/RFC8930, November 2020, <https://www.rfc-editor.org/info/rfc8930>.",
      "ja": "[RFC8930] Watteyne、T.、ED。、Thubert、P.、Ed。、およびC. Bormann、Multi-Hop IPv6ネットワーク上での転送6LOWPAN（低電力無線パーソナルエリアネットワーク上のIPv6）フラグメント \"、RFC8930、DOI 10.17487 / RFC8930、2020年11月、<https：//www.rfc-editor.org/info/rfc8930>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[6TiSCH] Thubert, P., \"An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4\", Work in Progress, Internet-Draft, draft-ietf-6tisch-architecture-29, 27 August 2020, <https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29>.",
      "ja": "[6tisch] Thubert、P.、「IEEE 802.15.4のTSCHモードでのIPv6のためのアーキテクチャーのためのアーキテクチャ」、インターネットドラフト、ドラフト -  IETF-6Tisch-Architecture-29,29,27、<https：//tools.ietf.org/html/draft-ietf-6tisch-Architecture-29>。"
    },
    {
      "indent": 3,
      "text": "[IEEE.802.15.4] IEEE, \"IEEE Standard for Low-Rate Wireless Networks\", IEEE Standard 802.15.4-2015, DOI 10.1109/IEEESTD.2016.7460875, April 2016, <http://ieeexplore.ieee.org/document/7460875/>.",
      "ja": "[IEEE.802.15.4] IEEE、「低速ワイヤレスネットワークのためのIEEE規格」、IEEEスタンダード802.15.4-2015、DOI 10.1109 / IEEESTD.2016.7460875、<http://ieeexplore.ieee.org/document/ 7460875 />。"
    },
    {
      "indent": 3,
      "text": "[Kent] Kent, C. and J. Mogul, \"Fragmentation Considered Harmful\", SIGCOMM '87: Proceedings of the ACM workshop on Frontiers in computer communications technology, pp. 390-401, DOI 10.1145/55483.55524, August 1987, <http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf>.",
      "ja": "[ケント]ケント、C.およびJ.Mogul、「フラグメンテーションは有害と見なす」、SIGCOMM '87：コンピュータ通信技術のフロンティアのACMワークショップの議事録、PP。390-401、DOI 10.1145 / 55483.55524、<http：//www.hpl.hp.com/techreports/compaq-dec/wrl-87-3.pdf>。"
    },
    {
      "indent": 3,
      "text": "[LWIG-FRAG] Bormann, C. and T. Watteyne, \"Virtual reassembly buffers in 6LoWPAN\", Work in Progress, Internet-Draft, draft-ietf-lwig-6lowpan-virtual-reassembly-02, 9 March 2020, <https://tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02>.",
      "ja": "[lwig-frag] Bormann、C.およびT.Watteyne、「6lowpanでの仮想再構成バッファ」、進行中の作業、インターネットドラフト、ドラフト -  LWIG-6LOWPAN-Virtual-Reassembly-02,202月9日、<HTTPS：//tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02>。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000, <https://www.rfc-editor.org/info/rfc2914>.",
      "ja": "[RFC2914] Floyd、S.、「輻輳制御原理」、BCP 41、RFC 2914、DOI 10.17487 / RFC2914、2000年9月、<https：//www.rfc-editor.org/info/rfc2914>。"
    },
    {
      "indent": 3,
      "text": "[RFC3031] Rosen, E., Viswanathan, A., and R. Callon, \"Multiprotocol Label Switching Architecture\", RFC 3031, DOI 10.17487/RFC3031, January 2001, <https://www.rfc-editor.org/info/rfc3031>.",
      "ja": "[RFC3031]ローゼン、E.、Viswanathan、A.およびR.Callon、 \"Multiprotocol Label Switche Architecture\"、RFC 3031、DOI 10.17487 / RFC3031、2001年1月、<https：//www.rfc-editor.org/info/ RFC3031>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "[RFC3168] Ramakrishnan、K.、Floyd、S.、およびD. Black、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：// www。rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC4963] Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly Errors at High Data Rates\", RFC 4963, DOI 10.17487/RFC4963, July 2007, <https://www.rfc-editor.org/info/rfc4963>.",
      "ja": "[RFC4963] Heffner、J.、Mathis、M.およびB.Chandler、2007年7月、<https：///www.rfc-編集者。ORG / INFO / RFC4963>。"
    },
    {
      "indent": 3,
      "text": "[RFC5033] Floyd, S. and M. Allman, \"Specifying New Congestion Control Algorithms\", BCP 133, RFC 5033, DOI 10.17487/RFC5033, August 2007, <https://www.rfc-editor.org/info/rfc5033>.",
      "ja": "[RFC5033] Floyd、S.およびM. Allman、「新しい輻輳制御アルゴリズムの指定」、BCP 133、RFC 5033、DOI 10.17487 / RFC5033、2007年8月、<https：//www.rfc-editor.org/info/rfc5033>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681] Allman、M.、Paxson、V.およびE.Blanton、「TCP輻輳制御」、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<https：//www.rfc-editor.org/info/RFC5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC6550] Winter, T., Ed., Thubert, P., Ed., Brandt, A., Hui, J., Kelsey, R., Levis, P., Pister, K., Struik, R., Vasseur, JP., and R. Alexander, \"RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks\", RFC 6550, DOI 10.17487/RFC6550, March 2012, <https://www.rfc-editor.org/info/rfc6550>.",
      "ja": "[RFC6550]冬、T.、ED。、Thubert、P.、Ed。、Brandt、A.、Hui、J.、Kelsey、R.、Levis、P.、Pister、K.、Struik、R.、Vasseur、JP。、およびR.RPL：低消費電力ネットワークの「RPL：IPv6ルーティングプロトコル」、RFC 6550、DOI 10.17487 / RFC6550、2012年3月、<https：//www.rfc-editor.org/info/RFC6550>。"
    },
    {
      "indent": 3,
      "text": "[RFC6552] Thubert, P., Ed., \"Objective Function Zero for the Routing Protocol for Low-Power and Lossy Networks (RPL)\", RFC 6552, DOI 10.17487/RFC6552, March 2012, <https://www.rfc-editor.org/info/rfc6552>.",
      "ja": "[RFC6552] Thubert、P.、ED。、「低消費電力および非損失ネットワーク（RPL）」、RFC 6552、DOI 10.17487 / RFC6552、2012年3月、<https：///www.rfcのための客観的関数ゼロ-editor.org/info/rfc6552>。"
    },
    {
      "indent": 3,
      "text": "[RFC6554] Hui, J., Vasseur, JP., Culler, D., and V. Manral, \"An IPv6 Routing Header for Source Routes with the Routing Protocol for Low-Power and Lossy Networks (RPL)\", RFC 6554, DOI 10.17487/RFC6554, March 2012, <https://www.rfc-editor.org/info/rfc6554>.",
      "ja": "[RFC6554] HUI、J.、Vasseur、JP、Culler、D.、およびV. Manral、「低電力および非損失ネットワーク（RPL）」（RPL） \"、RFC 6554を備えたソースルート用のIPv6ルーティングヘッダー。DOI 10.17487 / RFC6554、2012年3月、<https：//www.rfc-editor.org/info/rfc6554>。"
    },
    {
      "indent": 3,
      "text": "[RFC7554] Watteyne, T., Ed., Palattella, M., and L. Grieco, \"Using IEEE 802.15.4e Time-Slotted Channel Hopping (TSCH) in the Internet of Things (IoT): Problem Statement\", RFC 7554, DOI 10.17487/RFC7554, May 2015, <https://www.rfc-editor.org/info/rfc7554>.",
      "ja": "[RFC7554] Watteyne、T.、ED。、Palattella、M.、およびL.Grieco、「IEEE 802.15.4Eタイムスロットチャンネルホッピング（TSCH）（IoT）：問題声明 \"、RFC 7554、DOI 10.17487 / RFC7554、2015年5月、<https://www.rfc-editor.org/info/rfc7554>。"
    },
    {
      "indent": 3,
      "text": "[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., \"IETF Recommendations Regarding Active Queue Management\", BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, <https://www.rfc-editor.org/info/rfc7567>.",
      "ja": "[RFC7567] Baker、F.、ED。G. FairHurst、Ed。、「アクティブキュー管理に関するIETF勧告」、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、<https：//www.rfc-editor.org/info/rfc7567>。"
    },
    {
      "indent": 3,
      "text": "[RFC8085] Eggert, L., Fairhurst, G., and G. Shepherd, \"UDP Usage Guidelines\", BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017, <https://www.rfc-editor.org/info/rfc8085>.",
      "ja": "[RFC8085] eggert、L.、Fairhurst、G.、およびG.Shepherd、 \"UDP使用ガイドライン\"、BCP 145、RFC 8085、DOI 10.17487 / RFC8085、2017年3月、<https：//www.rfc-editor.org/ info / rfc8085>。"
    },
    {
      "indent": 3,
      "text": "[RFC8087] Fairhurst, G. and M. Welzl, \"The Benefits of Using Explicit Congestion Notification (ECN)\", RFC 8087, DOI 10.17487/RFC8087, March 2017, <https://www.rfc-editor.org/info/rfc8087>.",
      "ja": "[RFC8087] FairHurst、G.およびM. Welzl、「明示的輻輳通知（ECN）を使用する利点」、RFC 8087、DOI 10.17487 / RFC8087、2017年3月、<https：//www.rfc-editor.org/info/ RFC8087>。"
    },
    {
      "indent": 3,
      "text": "[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>.",
      "ja": "[RFC8201] McCann、J.、Theer、S.、Mogul、J.、およびR. Hinden、Ed。、「IPバージョン6のためのパスMTUディスカバリー」、STD 87、RFC 8201、DOI 10.17487 / RFC8201、2017年7月、<https://www.rfc-editor.org/info/rfc8201>。"
    },
    {
      "indent": 3,
      "text": "[RFC8900] Bonica, R., Baker, F., Huston, G., Hinden, R., Troan, O., and F. Gont, \"IP Fragmentation Considered Fragile\", BCP 230, RFC 8900, DOI 10.17487/RFC8900, September 2020, <https://www.rfc-editor.org/info/rfc8900>.",
      "ja": "[RFC8900]ボニャ、R.、Baker、F.、Huston、G.、Hinden、R.、Troan、O.、F.ゴント、「IPフラグメンテーションと見なす」、BCP 230、RFC 8900、DOI 10.17487 / RFC8900、2020年9月、<https://www.rfc-editor.org/info/rfc8900>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Rationale",
      "section_title": true,
      "ja": "付録A.根拠"
    },
    {
      "indent": 3,
      "text": "There are a number of uses for large packets in Wireless Sensor Networks. Such usages may not be the most typical or represent the largest amount of traffic over the LLN; however, the associated functionality can be critical enough to justify extra care for ensuring effective transport of large packets across the LLN.",
      "ja": "無線センサネットワーク内の大型パケットには多くの用途があります。そのような用途は、最も典型的ではないか、またはLLNを介して最大のトラフィックを表すことができます。ただし、関連する機能性は、LLN全体で大きなパケットの効果的なトランスポートを確保するための特別な注意を正当化するのに十分なほど重要です。"
    },
    {
      "indent": 3,
      "text": "The list of those usages includes:",
      "ja": "これらの用途のリストには以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "Towards the LLN node:",
      "ja": "LLNノードに向かって："
    },
    {
      "indent": 6,
      "text": "Firmware update: For example, a new version of the LLN node software is downloaded from a system manager over unicast or multicast services. Such a reflashing operation typically involves updating a large number of similar LLN nodes over a relatively short period of time.",
      "ja": "ファームウェアアップデート：たとえば、新しいバージョンのLLNノードソフトウェアは、UnicastまたはMulticast Servicesを介したシステムマネージャからダウンロードされます。そのようなリフレッシュ動作は、典型的には、比較的短い期間にわたって多数の類似のLLNノードを更新することを含む。"
    },
    {
      "indent": 6,
      "text": "Packages of commands: A number of commands or a full configuration can be packaged as a single message to ensure consistency and enable atomic execution or complete rollback. Until such commands are fully received and interpreted, the intended operation will not take effect.",
      "ja": "コマンドのパッケージ：いくつかのコマンドまたは完全な構成を単一のメッセージとしてパッケージ化することができ、一貫性を確保し、アトミック実行または完全なロールバックを有効にすることができます。そのようなコマンドが完全に受信され解釈されるまで、意図された操作は有効になりません。"
    },
    {
      "indent": 3,
      "text": "From the LLN node:",
      "ja": "LLNノードから："
    },
    {
      "indent": 6,
      "text": "Waveform captures: A number of consecutive samples are measured at a high rate for a short time and then are transferred from a sensor to a gateway or an edge server as a single large report.",
      "ja": "波形キャプチャ：いくつかの連続したサンプルが短時間で高速で測定され、次いでセンサーからゲートウェイへ、またはエッジサーバーからエッジサーバーに転送されます。"
    },
    {
      "indent": 6,
      "text": "Data logs: LLN nodes may generate large logs of sampled data for later extraction. LLN nodes may also generate system logs to assist in diagnosing problems on the node or network.",
      "ja": "データログ：LLNノードは、後で抽出するためにサンプリングされたデータの大きなログを生成することがあります。LLNノードはまた、ノードまたはネットワーク上の問題の診断を支援するためにシステムログを生成することができる。"
    },
    {
      "indent": 6,
      "text": "Large data packets: Rich data types might require more than one fragment.",
      "ja": "大きなデータパケット：豊富なデータ型には、複数のフラグメントが必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Uncontrolled firmware download or waveform upload can easily result in a massive increase of the traffic and saturate the network.",
      "ja": "制御されていないファームウェアのダウンロードまたは波形のアップロードは、トラフィックの大幅な増加とネットワークを飽和させることができます。"
    },
    {
      "indent": 3,
      "text": "When a fragment is lost in transmission, the lack of recovery in the original fragmentation system of RFC 4944 implies that all fragments would need to be resent, further contributing to the congestion that caused the initial loss and potentially leading to congestion collapse.",
      "ja": "フラグメントが送信中に失われると、RFC 4944の元のフラグメンテーションシステムにおける回復の欠如は、すべてのフラグメントを再送信する必要があることを意味し、初期損失を引き起こし、潜在的に輻輳崩壊につながる潜在的に輻輳に貢献することを意味します。"
    },
    {
      "indent": 3,
      "text": "This saturation may lead to excessive radio interference or random early discard (leaky bucket) in relaying nodes. Additional queuing and memory congestion may result while waiting for a low-power next hop to emerge from its sleep state.",
      "ja": "この飽和は、中継ノード内の過度の無線干渉またはランダム早期廃棄（漏れ型バケット）をもたらし得る。低電力の次ホップがそのスリープ状態から出現するのを待っている間、追加のキューイングおよびメモリの輻輳が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Considering that RFC 4944 defines an MTU as 1280 bytes, and that in most incarnations (except 802.15.4g) an IEEE Std 802.15.4 frame can limit the link-layer payload to as few as 74 bytes, a packet might be fragmented into at least 18 fragments at the 6LoWPAN shim layer. Taking into account the worst-case header overhead for 6LoWPAN Fragmentation and Mesh Addressing headers will increase the number of required fragments to around 32. This level of fragmentation is much higher than that traditionally experienced over the Internet with IPv4 fragments. At the same time, the use of radios increases the probability of transmission loss, and mesh-under techniques compound that risk over multiple hops.",
      "ja": "RFC 4944が1280バイトとしてMTUを定義し、ほとんどの場合（802.15.4Gを除く）IEEE STD 802.15.4フレームがリンクレイヤペイロードを74バイトに限定することができることを考えると、パケットが断片化される可能性があります。6lowpanシム層での最低18のフラグメント。6LOWPANフラグメンテーションおよびメッシュアドレス指定ヘッダのための最悪のケースのヘッダオーバーヘッドを考慮すると、必要なフラグメントの数が約32に増加する。このレベルの断片化は、伝統的にIPv4フラグメントを介して経験されたものよりはるかに高い。同時に、無線機の使用は伝送損失の可能性を高め、そして複数のホップにわたって危険にさらすメッシュ下技術。"
    },
    {
      "indent": 3,
      "text": "Mechanisms such as TCP or application-layer segmentation could be used to support end-to-end reliable transport. One option to support bulk data transfer over a frame-size-constrained LLN is to set the Maximum Segment Size to fit within the link maximum frame size. However, doing so can add significant header overhead to each 802.15.4 frame and cause extraneous acknowledgments across the LLN compared to the method in this specification.",
      "ja": "TCPやアプリケーション層のセグメンテーションなどのメカニズムを使用して、エンドツーエンドの信頼できる輸送をサポートできます。フレームサイズの制約付きLLNを介してバルクデータ転送をサポートする1つの選択肢は、リンク最大フレームサイズ内に適合する最大セグメントサイズを設定することです。しかしながら、そうすることで、各802.15.4フレームに大きなヘッダオーバーヘッドを追加し、この仕様の方法と比較してLLN全体で無関係な確認応答を引き起こす可能性がある。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Requirements",
      "section_title": true,
      "ja": "付録B.要件"
    },
    {
      "indent": 3,
      "text": "For one-hop communications, a number of LLN link layers propose a local acknowledgment mechanism that is enough to detect and recover the loss of fragments. In a multi-hop environment, an end-to-end fragment recovery mechanism might be a good complement to a hop-by-hop Medium Access Control (MAC) recovery. This document introduces a simple protocol to recover individual fragments between 6LFF endpoints that may be multiple hops away.",
      "ja": "1ホップ通信のために、いくつかのLLNリンク層は、フラグメントの損失を検出および回復するのに十分な局所確認メカニズムを提案する。マルチホップ環境では、エンドツーエンドフラグメントリカバリメカニズムは、ホップバイホップ媒体アクセス制御（MAC）リカバリへの優れた補完的であり得る。この文書は、複数のホップである可能性がある6LFFエンドポイント間で個々のフラグメントを回復するための簡単なプロトコルを紹介します。"
    },
    {
      "indent": 3,
      "text": "The method addresses the following requirements of an LLN:",
      "ja": "メソッドは、LLNの以下の要件に対処します。"
    },
    {
      "indent": 3,
      "text": "Number of fragments: The recovery mechanism must support highly fragmented packets, with a maximum of 32 fragments per packet.",
      "ja": "フラグメント数：リカバリメカニズムは、高度に断片化されたパケットをサポートしなければなりません。パケットごとに最大32のフラグメントがあります。"
    },
    {
      "indent": 3,
      "text": "Minimum acknowledgment overhead: Because the radio is half duplex, and because of silent time spent in the various medium access mechanisms, an acknowledgment consumes roughly as many resources as a data fragment.",
      "ja": "最小肯定応答オーバーヘッド：ラジオが半二重で、さまざまな媒体アクセスメカニズムに費やされた静かな時間のために、確認応答はデータフラグメントとほぼ多くのリソースを消費します。"
    },
    {
      "indent": 6,
      "text": "The new end-to-end fragment recovery mechanism should be able to acknowledge multiple fragments in a single message and not require an acknowledgment at all if fragments are already protected at a lower layer.",
      "ja": "新しいエンドツーエンドフラグメントリカバリメカニズムは、単一のメッセージ内の複数のフラグメントを確認できるはずであり、フラグメントが既に下位レイヤで保護されている場合は、肯定応答を必要としません。"
    },
    {
      "indent": 3,
      "text": "Controlled latency: The recovery mechanism must succeed or give up within the time boundary imposed by the recovery process of the upper-layer protocols.",
      "ja": "制御された待ち時間：回復メカニズムは、上層プロトコルの回復プロセスによって課される時間境界内に成功またはあきらめる必要があります。"
    },
    {
      "indent": 3,
      "text": "Optional congestion control: The aggregation of multiple concurrent flows may lead to the saturation of the radio network and congestion collapse.",
      "ja": "オプションの輻輳制御：複数の同時フローの集約は、無線ネットワークの彩度と輻輳崩壊につながる可能性があります。"
    },
    {
      "indent": 6,
      "text": "The recovery mechanism should provide means for controlling the number of fragments in transit over the LLN.",
      "ja": "回復メカニズムは、LLNの輸送中のフラグメント数を制御するための手段を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Considerations on Congestion Control",
      "section_title": true,
      "ja": "付録C C.輻輳制御に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Considering that a multi-hop LLN can be a very sensitive environment due to the limited queuing capabilities of a large population of its nodes, this document recommends a simple and conservative approach to congestion control, based on TCP congestion avoidance.",
      "ja": "マルチホップLLNが、そのノードの大きな人口の限られたキューイング機能のために非常に敏感な環境になる可能性があることを考えると、この文書はTCPの輻輳回避に基づいて、輻輳制御へのシンプルで保守的なアプローチを推奨しています。"
    },
    {
      "indent": 3,
      "text": "Congestion on the forward path is assumed in case of packet loss, and packet loss is assumed upon timeout. This document allows controlling the number of outstanding fragments that have been transmitted, but for which an acknowledgment was not yet received, and that are still covered by the ARQ timer.",
      "ja": "パケット損失の場合には、順方向パスの輻輳が想定され、パケット損失はタイムアウト時に想定されます。この文書では、送信された未解決のフラグメントの数を制御することができますが、確認応答がまだ受信されていないため、まだARQタイマーによってカバーされています。"
    },
    {
      "indent": 3,
      "text": "Congestion on the forward path can also be indicated by an ECN mechanism. Though whether and how ECN [RFC3168] is carried out over the LoWPAN is out of scope, this document provides a way for the destination endpoint to echo an ECN indication back to the fragmenting endpoint in an acknowledgment message as represented in Figure 4 in Section 5.2.",
      "ja": "順方向経路上の輻輳は、ECNメカニズムによっても示され得る。ECN [RFC3168]がローパンの上でどのように実行されているかは範囲外であるかどうかは、セクション5.2の図4に示すように、宛先エンドポイントが肯定応答メッセージの断片化エンドポイントにECN表示をエコーする方法を提供します。。"
    },
    {
      "indent": 3,
      "text": "While the support of echoing the ECN at the reassembling endpoint is mandatory, this specification only provides a minimalistic behavior on the fragmenting endpoint. If an \"E\" flag is received, the window SHOULD be reduced at least by 1 and at max to 1. Halving the window for each \"E\" flag received could be a good compromise, but it needs further experimentation. A very simple implementation may just reset the window to 1, so the fragments are sent and acknowledged one by one.",
      "ja": "再組み立てエンドポイントでECNをエコーするサポートは必須ですが、この仕様は断片化エンドポイントで最小限の動作を提供します。「E」フラグが受信された場合、ウィンドウは少なくとも1で最大1までに減少されるべきである。非常に単純な実装では、ウィンドウを1にリセットするだけで、フラグメントは1つずつ送信され、確認されます。"
    },
    {
      "indent": 3,
      "text": "Note that any action that has been performed upon detection of congestion only applies for the transmission of one datagram, and the next datagram starts with the configured Window_Size again.",
      "ja": "輻輳の検出時に実行されたアクションは、1つのデータグラムの送信にのみ適用され、次のデータグラムは再度構成されたwindow_sizeで始まります。"
    },
    {
      "indent": 3,
      "text": "The exact use of the Acknowledgment Request flag and of the window are left to implementation. An optimistic implementation could send all the fragments up to Window_Size, setting the Acknowledgment Request \"X\" flag only on the last fragment; wait for the bitmap, which means a gap of half a round-trip time; and resend the losses. A pessimistic implementation could set the \"X\" flag on the first fragment to check that the path works and open the window only upon receiving the RFRAG-ACK. It could then set an \"X\" flag again on the second fragment and use the window as a credit to send up to Window_Size before it is blocked. In that case, if the RFRAG-ACK comes back before the window starves, the gating factor is the inter-frame gap. If the RFRAG-ACK does not arrive in time, the Window_Size is the gating factor, and the transmission of the datagram is delayed.",
      "ja": "確認応答要求フラグとウィンドウの正確な使用は実装に残されています。楽観的な実装では、window_sizeまでのすべてのフラグメントを送信し、肯定応答要求 \"x\"フラグを最後のフラグメントでのみ設定できます。ビットマップを待ちます。つまり、半分の往復時間のギャップを意味します。そして損失を再開します。悲観的な実装は、最初のフラグメント上の \"x\"フラグを設定して、パスがrfrag-ackを受信したときにのみウィンドウを開くことを確認することができます。その後、2番目のフラグメントで「X」フラグを再度設定し、ブロックされる前にWindow_Sizeに送信するためにウィンドウとしてウィンドウを使用することができます。その場合、rFRAG-ACKがウィンドウの枯渇前に戻ってくると、ゲーティング係数はフレーム間ギャップです。RFRAG-ACKが時間内に到着しない場合、window_sizeはゲーティングファクタであり、データグラムの送信は遅延されます。"
    },
    {
      "indent": 3,
      "text": "It must be noted that even though the inter-frame gap can be used as a flow control or a congestion control measure, it also plays a critical role in wireless collision avoidance. In particular, when a mesh operates on the same channel over multiple hops, the forwarding of a fragment over a certain hop may collide with the forwarding of the next fragment that is following over a previous hop but that is in the same interference domain. To prevent this, the fragmenting endpoint is required to pace individual fragments within a transmit window with an inter-frame gap. This is needed to ensure that a given fragment is sent only when the previous fragment has had a chance to progress beyond the interference domain of this hop. In the case of 6TiSCH [6TiSCH], which operates over the Time-Slotted Channel Hopping (TSCH) mode of operation of IEEE 802.15.4 [RFC7554], a fragment is forwarded over a different channel at a different time, and it makes full sense to transmit the next fragment as soon as the previous fragment has had its chance to be forwarded at the next hop.",
      "ja": "フレーム間ギャップをフロー制御または輻輳制御尺度として使用することができるとしても、それはまた無線衝突回避において重要な役割を果たすことに留意されたい。特に、メッシュが複数のホップを介して同じチャネル上で動作するとき、特定のホップ上のフラグメントの転送は、前のホップを超えるが、同じ干渉ドメイン内にある次のフラグメントの転送と衝突する可能性がある。これを防ぐために、フラグメント化エンドポイントは、フレーム間ギャップを使用して送信ウィンドウ内の個々のフラグメントをペースするために必要とされる。これは、前のフラグメントがこのホップの干渉ドメインを超えて進行する機会がある場合にのみ、特定のフラグメントが送信されるようにするために必要です。 IEEE 802.15.4 [RFC7554]のタイムスロットチャネルホッピング（TSCH）動作モードで動作する6tisch [6tisch]の場合、フラグメントは異なる時間で異なるチャネルを介して転送され、それは完全になります前のフラグメントが次のホップで転送される可能性があるとすぐに次のフラグメントを送信することを意味します。"
    },
    {
      "indent": 3,
      "text": "Depending on the setting of the Window_Size and the inter-frame gap, how the window is used, and the number of hops, the Window_Size may or may not become the gating factor that blocks the transmission. If the sender uses the Window_Size as a credit:",
      "ja": "window_sizeとフレーム間ギャップの設定、ウィンドウの使用方法、およびホップ数、Window_Sizeは、送信をブロックするゲーティングファクタにならない場合があります。送信者がクレジットとしてwindow_sizeを使用している場合"
    },
    {
      "indent": 3,
      "text": "* a conservative Window_Size of, say, 3 will be the gating factor that limits the transmission rate of the sender -- and causes transmission gaps longer than the inter-frame gap -- as soon as the number of hops exceeds 3 in a TSCH network and 5-9 in a single frequency mesh. The more hops the more the starving window will add to latency of the transmission.",
      "ja": "* 保守的なWINDOR_SIZEは、SENDERの伝送速度を制限するゲーティング係数となり、HOPの数がTSCHネットワークで3を超えるとすぐに、フレーム間ギャップよりも長い伝送ギャップを引き起こす。5-9単一の周波数メッシュ。より多くのホップが多いほど、飢え窓が変速機の待ち時間に加えられる。"
    },
    {
      "indent": 3,
      "text": "* The recommendation to align the Window-Size to the round-trip time divided by the time per fragment aligns the Window-Size to the time it takes to get the RFAG_ACK before the window starves. A Window-Size that is higher than that increases the chances of a congestion but does not improve the forward throughput. Considering that the RFRAG-ACK takes the same path as the fragment with the assumption that it travels at roughly the same speed, an inter-frame gap that separates fragments by 2 hops leads to a Window_Size that is roughly the number of hops.",
      "ja": "* ウィンドウサイズをフラグメントあたりの時間で割った丸いトリップ時間に分割する推奨事項は、ウィンドウの星を星の前にRFAG_ACKを取得するのにかかる時間に整列させます。それよりも高いウィンドウサイズは、輻輳の可能性を高めますが、前方スループットを向上させません。RFRAG-ACKが概略で同じ速度で移動すると仮定してフラグメントと同じ経路をとることを考えると、フラグメントを2ホップに分離するフレーム間ギャップは、おおよそホップ数であるWINDOW_SIZEにつながります。"
    },
    {
      "indent": 3,
      "text": "* Setting the Window-Size to 32 minimizes the cost of the acknowledgment in a constrained network and frees bandwidth for the fragments in a half-duplex network. Using it increases the risk of congestion if a bottleneck forms, but it optimizes the use of resources under normal conditions. When it is used, the only protection for the network is the inter-frame gap, which must be chosen wisely to prevent the formation of a bottleneck.",
      "ja": "* ウィンドウサイズを32に設定すると、拘束ネットワーク内の確認応答のコストが最小化され、半二重ネットワーク内のフラグメントの帯域幅を解放します。それを使用すると、ボトルネックの場合は輻輳のリスクが高まりますが、通常の条件下でのリソースの使用を最適化します。使用されると、ネットワークの唯一の保護はフレーム間ギャップです。これはボトルネックの形成を防ぐために賢明に選択されなければなりません。"
    },
    {
      "indent": 3,
      "text": "From the standpoint of a source 6LoWPAN endpoint, an outstanding fragment is a fragment that was sent but for which no explicit acknowledgment was yet received. This means that the fragment might be on the path or received but not yet acknowledged, or the acknowledgment might be on the path back. It is also possible that either the fragment or the acknowledgment was lost on the way.",
      "ja": "ソース6LOWPANエンドポイントの観点から、優れたフラグメントは送信されたフラグメントですが、明示的な確認応答がまだ受信されていません。つまり、フラグメントはパス上にあるか受信されていないがまだ認識されていないこと、または確認応答がパス上にある場合があります。途中でフラグメントまたは確認応答のいずれかが失われたことも可能です。"
    },
    {
      "indent": 3,
      "text": "From the fragmenting endpoint standpoint, all outstanding fragments might still be in the network and contribute to its congestion. There is an assumption, though, that after a certain amount of time, a frame is either received or lost, so it is not causing congestion anymore. This amount of time can be estimated based on the round-trip time between the 6LoWPAN endpoints. For the lack of a more adapted technique, the method detailed in \"Computing TCP's Retransmission Timer\" [RFC6298] may be used for that computation.",
      "ja": "断片化エンドポイントの観点からは、未解決のフラグメントはすべてネットワーク内にある可能性があり、その輻輳に貢献します。ただし、一定時間後、フレームが受信または紛失しているため、輻輳が発生していないという仮定があります。この時間は、6LOWPANエンドポイント間の往復時間に基づいて推定できます。より適応な技術がないために、「TCPの再送信タイマの計算」[RFC6298]に詳述されている方法をその計算に使用することができる。"
    },
    {
      "indent": 3,
      "text": "This specification provides the necessary tools for the fragmenting endpoint to take congestion control actions and protect the network, but it leaves the implementation free to select the action to be taken. The intention is to use it to build experience and specify more precisely the congestion control actions in one or more future specifications. \"Congestion Control Principles\" [RFC2914] and \"Specifying New Congestion Control Algorithms\" [RFC5033] provide indications and wisdom that should help through this process.",
      "ja": "この仕様では、断片化エンドポイントに輻輳制御アクションを実行してネットワークを保護するための必要なツールが提供されていますが、実行するアクションを選択することができます。その意図は、それを使用して経験を構築し、1つ以上の将来の仕様でより正確に輻輳制御の行動を指定することです。「輻輳制御原則」[RFC2914]と「新しい輻輳制御アルゴリズムの指定」[RFC5033]このプロセスを支援する必要がある適応と知恵を提供します。"
    },
    {
      "indent": 3,
      "text": "[RFC7567] and [RFC5681] provide deeper information on why congestion control is needed and how TCP handles it. Basically, the goal here is to manage the number of fragments present in the network; this is achieved by reducing the number of outstanding fragments over a congested path by throttling the sources.",
      "ja": "[RFC7567]および[RFC5681]は、輻輳制御が必要なのか、およびTCPがどのように処理するかについてのより深い情報を提供します。基本的に、ここでの目標は、ネットワーク内に存在するフラグメントの数を管理することです。これは、ソースを調整することによって輻輳している経路上の優れたフラグメントの数を減らすことによって達成されます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author wishes to thank Michel Veillette, Dario Tedeschi, Laurent Toutain, Carles Gomez Montenegro, Thomas Watteyne, and Michael Richardson for their in-depth reviews and comments. Also, many thanks to Roman Danyliw, Peter Yee, Colin Perkins, Tirumaleswar Reddy.K, Éric Vyncke, Warren Kumari, Magnus Westerlund, Erik Nordmark, and especially Benjamin Kaduk and Mirja Kühlewind for their careful reviews and help during the IETF Last Call and IESG review process. Thanks to Jonathan Hui, Jay Werb, Christos Polyzois, Soumitri Kolavennu, Pat Kinney, Margaret Wasserman, Richard Kelsey, Carsten Bormann, and Harry Courtice for their various contributions in the long process that lead to this document.",
      "ja": "著者は、Michel Veillette、Dario Tedeschi、Laurent Toutain、Carles Gomez Montenegro、Thomas Watteyne、およびMichael Richardson、およびその詳細なレビューとコメントをお寄せいただきありがとうございます。また、Roman Danyliw、Peter Yee、Colin Perkins、Tirumaleswar reddy.k、ÉricVyncke、Agren Westerlund、Erik Nordmark、Erik Nordmark、特にBenjamin KadukとMirjaKühlewindのおかげで、IETFの最後のコールの間、IESGレビュープロセスJonathan Hui、Jay Werb、Christos Polyzois、Soumitri Kolavennu、Pat Kinney、Margaret Wasserman、Richard Kelsey、Carsten Borsten Bormann、およびハリーコレツツのために、この文書につながります。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Pascal Thubert (editor) Cisco Systems, Inc. Building D 45 Allee des Ormes - BP1200 06254 MOUGINS - Sophia Antipolis France",
      "ja": "Pascal Thubert（編集）Cisco Systems、Inc。Cisco Systems、Inc。建物D 45 Allee Des Ormes  -  BP1200 06254 Mougins  -  Sophia Antipolis France"
    },
    {
      "indent": 3,
      "text": "Phone: +33 497 23 26 34\nEmail: pthubert@cisco.com",
      "raw": true,
      "ja": ""
    }
  ]
}