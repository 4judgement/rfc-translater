{
  "title": {
    "text": "RFC 8767 - Serving Stale Data to Improve DNS Resiliency",
    "ja": "RFC 8767 - 古いデータを提供してDNSの復元力を向上させる"
  },
  "number": 8767,
  "created_at": "2020-08-16 21:59:36.341830+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       D. Lawrence\nRequest for Comments: 8767                                        Oracle\nUpdates: 1034, 1035, 2181                                      W. Kumari\nCategory: Standards Track                                        P. Sood\nISSN: 2070-1721                                                   Google\n                                                              March 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Serving Stale Data to Improve DNS Resiliency",
      "ja": "古いデータを提供してDNSの復元力を向上させる"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines a method (serve-stale) for recursive resolvers to use stale DNS data to avoid outages when authoritative nameservers cannot be reached to refresh expired data. One of the motivations for serve-stale is to make the DNS more resilient to DoS attacks and thereby make them less attractive as an attack vector. This document updates the definitions of TTL from RFCs 1034 and 1035 so that data can be kept in the cache beyond the TTL expiry; it also updates RFC 2181 by interpreting values with the high-order bit set as being positive, rather than 0, and suggests a cap of 7 days.",
      "ja": "このドキュメントでは、再帰リゾルバが失効したDNSデータを使用して、信頼できるネームサーバーにアクセスして期限切れのデータを更新できない場合の停止を回避する方法（serve-stale）を定義します。 serve-staleの動機の1つは、DNSをDoS攻撃に対する耐性を高め、攻撃ベクトルとしての魅力を少なくすることです。このドキュメントでは、TTLの定義をRFC 1034および1035から更新して、TTLの有効期限が切れてもデータをキャッシュに保持できるようにします。また、上位ビットが0ではなく正であると設定された値を解釈することによってRFC 2181を更新し、7日の上限を提案します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはInternet Standards Trackドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8767.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8767で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETFトラストおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n3.  Background\n4.  Standards Action\n5.  Example Method\n6.  Implementation Considerations\n7.  Implementation Caveats\n8.  Implementation Status\n9.  EDNS Option\n10. Security Considerations\n11. Privacy Considerations\n12. NAT Considerations\n13. IANA Considerations\n14. References\n  14.1.  Normative References\n  14.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Traditionally, the Time To Live (TTL) of a DNS Resource Record (RR) has been understood to represent the maximum number of seconds that a record can be used before it must be discarded, based on its description and usage in [RFC1035] and clarifications in [RFC2181].",
      "ja": "従来、DNSリソースレコード（RR）の存続可能時間（TTL）は、[RFC1035]の説明と使用法に基づいて、レコードが破棄されるまでに使用できる最大秒数を表すと理解されてきました。 [RFC2181]の説明。"
    },
    {
      "indent": 3,
      "text": "This document expands the definition of the TTL to explicitly allow for expired data to be used in the exceptional circumstance that a recursive resolver is unable to refresh the information. It is predicated on the observation that authoritative answer unavailability can cause outages even when the underlying data those servers would return is typically unchanged.",
      "ja": "このドキュメントでは、TTLの定義を拡張して、再帰リゾルバーが情報を更新できないという例外的な状況で期限切れのデータを明示的に使用できるようにしています。これらのサーバーが返す基になるデータが通常は変更されていない場合でも、信頼できる回答が得られない場合に障害が発生する可能性があるという観察に基づいています。"
    },
    {
      "indent": 3,
      "text": "We describe a method below for this use of stale data, balancing the competing needs of resiliency and freshness.",
      "ja": "古くなったデータをこのように使用する方法を以下に説明し、回復力と鮮度の競合するニーズのバランスをとります。"
    },
    {
      "indent": 3,
      "text": "This document updates the definitions of TTL from [RFC1034] and [RFC1035] so that data can be kept in the cache beyond the TTL expiry; it also updates [RFC2181] by interpreting values with the high-order bit set as being positive, rather than 0, and also suggests a cap of 7 days.",
      "ja": "このドキュメントでは、TTLの定義を[RFC1034]および[RFC1035]から更新して、TTLの有効期限が切れてもデータをキャッシュに保持できるようにします。また、上位ビットが0ではなく正であると設定された値を解釈して[RFC2181]を更新し、7日の上限を提案します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "For a glossary of DNS terms, please see [RFC8499].",
      "ja": "DNS用語集については、[RFC8499]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Background",
      "section_title": true,
      "ja": "3. バックグラウンド"
    },
    {
      "indent": 3,
      "text": "There are a number of reasons why an authoritative server may become unreachable, including Denial-of-Service (DoS) attacks, network issues, and so on. If a recursive server is unable to contact the authoritative servers for a query but still has relevant data that has aged past its TTL, that information can still be useful for generating an answer under the metaphorical assumption that \"stale bread is better than no bread.\"",
      "ja": "サービス拒否（DoS）攻撃、ネットワークの問題など、権限のあるサーバーが到達不能になる理由はいくつかあります。再帰サーバーが信頼できるサーバーに問い合わせることができなくても、TTLを超えて古くなった関連データがある場合、その情報は、「古くなったパンはパンがないよりはましだ」という比喩的な仮定の下で答えを生成するのに役立ちます。 」"
    },
    {
      "indent": 3,
      "text": "[RFC1035], Section 3.2.1 says that the TTL \"specifies the time interval that the resource record may be cached before the source of the information should again be consulted.\" [RFC1035], Section 4.1.3 further says that the TTL \"specifies the time interval (in seconds) that the resource record may be cached before it should be discarded.\"",
      "ja": "[RFC1035]、セクション3.2.1は、TTLが「情報のソースを再度参照する前にリソースレコードがキャッシュされる時間間隔を指定する」と述べています。 [RFC1035]、セクション4.1.3はさらに、TTLが「リソースレコードが破棄される前にキャッシュされる可能性がある時間間隔（秒単位）を指定する」と述べています。"
    },
    {
      "indent": 3,
      "text": "A natural English interpretation of these remarks would seem to be clear enough that records past their TTL expiration must not be used. However, [RFC1035] predates the more rigorous terminology of [RFC2119], which softened the interpretation of \"may\" and \"should\".",
      "ja": "これらの発言の自然な英語の解釈は、TTLの有効期限を過ぎたレコードを使用してはならないほど十分明確であるように思われます。ただし、[RFC1035]は[RFC2119]のより厳密な用語よりも前から存在しており、「may」と「should」の解釈をやわらげていました。"
    },
    {
      "indent": 3,
      "text": "[RFC2181] aimed to provide \"the precise definition of the Time to Live,\" but Section 8 of [RFC2181] was mostly concerned with the numeric range of values rather than data expiration behavior. It does, however, close that section by noting, \"The TTL specifies a maximum time to live, not a mandatory time to live.\" This wording again does not contain BCP 14 key words [RFC2119], but it does convey the natural language connotation that data becomes unusable past TTL expiry.",
      "ja": "[RFC2181]は「生存時間の正確な定義」を提供することを目的としましたが、[RFC2181]のセクション8は、データの有効期限の動作ではなく、数値の範囲に主に関係していました。ただし、「TTLは、必須の生存時間ではなく、最大の生存時間を指定する」と記して、そのセクションを閉じます。この表現にもBCP 14キーワード[RFC2119]は含まれていませんが、TTLの有効期限が過ぎるとデータが使用できなくなるという自然言語の意味合いを伝えています。"
    },
    {
      "indent": 3,
      "text": "As of the time of this writing, several large-scale operators use stale data for answers in some way. A number of recursive resolver packages, including BIND, Knot Resolver, OpenDNS, and Unbound, provide options to use stale data. Apple macOS can also use stale data as part of the Happy Eyeballs algorithms in mDNSResponder. The collective operational experience is that using stale data can provide significant benefit with minimal downside.",
      "ja": "この記事の執筆時点では、いくつかの大規模なオペレーターが何らかの方法で古いデータを使用して回答を書き込んでいます。 BIND、Knot Resolver、OpenDNS、Unboundなどの多くの再帰リゾルバーパッケージは、古いデータを使用するオプションを提供します。 Apple macOSは、mDNSResponderのHappy Eyeballsアルゴリズムの一部として古いデータを使用することもできます。集合的な運用経験では、古いデータを使用することで、マイナス面を最小限に抑えながら大きなメリットを得ることができます。"
    },
    {
      "indent": 0,
      "text": "4. Standards Action",
      "section_title": true,
      "ja": "4. 標準アクション"
    },
    {
      "indent": 3,
      "text": "The definition of TTL in Sections 3.2.1 and 4.1.3 of [RFC1035] is amended to read:",
      "ja": "[RFC1035]のセクション3.2.1および4.1.3におけるTTLの定義は、次のように修正されます。"
    },
    {
      "indent": 3,
      "text": "TTL a 32-bit unsigned integer number of seconds that specifies the duration that the resource record MAY be cached before the source of the information MUST again be consulted. Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached. Values SHOULD be capped on the order of days to weeks, with a recommended cap of 604,800 seconds (7 days). If the data is unable to be authoritatively refreshed when the TTL expires, the record MAY be used as though it is unexpired. See Sections 5 and 6 of [RFC8767] for details.",
      "ja": "TTL 32ビットの符号なし整数秒。リソースレコードをキャッシュしてから、情報のソースを再度参照する必要がある（MAY）。ゼロの値は、RRが進行中のトランザクションにのみ使用でき、キャッシュしないことを意味すると解釈されます。値は、日から週のオーダーで上限を設定する必要があります（推奨上限は604,800秒（7日））。 TTLの有効期限が切れたときにデータを正式に更新できない場合、レコードは有効期限が切れていないかのように使用できます（MAY）。詳細については、[RFC8767]のセクション5および6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interpreting values that have the high-order bit set as being positive, rather than 0, is a change from [RFC2181], the rationale for which is explained in Section 6. Suggesting a cap of 7 days, rather than the 68 years allowed by the full 31 bits of Section 8 of [RFC2181], reflects the current practice of major modern DNS resolvers.",
      "ja": "上位ビットが0ではなく正であると設定されている値を解釈することは、[RFC2181]からの変更であり、その根拠はセクション6で説明されています。 [RFC2181]のセクション8の31ビット全体は、主要な最新のDNSリゾルバーの現在の慣行を反映しています。"
    },
    {
      "indent": 3,
      "text": "When returning a response containing stale records, a recursive resolver MUST set the TTL of each expired record in the message to a value greater than 0, with a RECOMMENDED value of 30 seconds. See Section 6 for explanation.",
      "ja": "古いレコードを含む応答を返す場合、再帰リゾルバは、メッセージ内の期限切れの各レコードのTTLを0より大きい値に、推奨値を30秒に設定する必要があります。説明については、セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Answers from authoritative servers that have a DNS response code of either 0 (NoError) or 3 (NXDomain) and the Authoritative Answer (AA) bit set MUST be considered to have refreshed the data at the resolver. Answers from authoritative servers that have any other response code SHOULD be considered a failure to refresh the data and therefore leave any previous state intact. See Section 6 for a discussion.",
      "ja": "DNS応答コードが0（NoError）または3（NXDomain）であり、Authoritative Answer（AA）ビットが設定されている権限のあるサーバーからの回答は、リゾルバーでデータを更新したと見なす必要があります。他の応答コードを持つ信頼できるサーバーからの応答は、データの更新に失敗したと見なして、以前の状態をそのままにしておく必要があります（SHOULD）。説明については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Example Method",
      "section_title": true,
      "ja": "5. メソッドの例"
    },
    {
      "indent": 3,
      "text": "There is more than one way a recursive resolver could responsibly implement this resiliency feature while still respecting the intent of the TTL as a signal for when data is to be refreshed.",
      "ja": "再帰リゾルバが責任を持ってこの復元機能を実装しながら、TTLの意図をデータを更新するタイミングの信号として尊重する方法は複数あります。"
    },
    {
      "indent": 3,
      "text": "In this example method, four notable timers drive considerations for the use of stale data:",
      "ja": "この方法例では、4つの注目すべきタイマーが古いデータの使用に関する考慮事項を推進します。"
    },
    {
      "indent": 3,
      "text": "* A client response timer, which is the maximum amount of time a recursive resolver should allow between the receipt of a resolution request and sending its response.",
      "ja": "* クライアント応答タイマー。これは、再帰リゾルバーが解決要求を受信して​​から応答を送信するまでの間に許可する必要がある最大時間です。"
    },
    {
      "indent": 3,
      "text": "* A query resolution timer, which caps the total amount of time a recursive resolver spends processing the query.",
      "ja": "* クエリ解決タイマー。再帰リゾルバがクエリの処理に費やす合計時間を制限します。"
    },
    {
      "indent": 3,
      "text": "* A failure recheck timer, which limits the frequency at which a failed lookup will be attempted again.",
      "ja": "* 失敗したルックアップが再試行される頻度を制限する失敗再チェックタイマー。"
    },
    {
      "indent": 3,
      "text": "* A maximum stale timer, which caps the amount of time that records will be kept past their expiration.",
      "ja": "* 最大失効タイマー。これは、レコードが有効期限を過ぎて保持される時間を制限します。"
    },
    {
      "indent": 3,
      "text": "Most recursive resolvers already have the query resolution timer and, effectively, some kind of failure recheck timer. The client response timer and maximum stale timer are new concepts for this mechanism.",
      "ja": "ほとんどの再帰リゾルバにはすでにクエリ解決タイマーがあり、事実上、ある種の障害再確認タイマーがあります。クライアント応答タイマーと最大失効タイマーは、このメカニズムの新しい概念です。"
    },
    {
      "indent": 3,
      "text": "When a recursive resolver receives a request, it should start the client response timer. This timer is used to avoid client timeouts. It should be configurable, with a recommended value of 1.8 seconds as being just under a common timeout value of 2 seconds while still giving the resolver a fair shot at resolving the name.",
      "ja": "再帰リゾルバーが要求を受信すると、クライアント応答タイマーを開始する必要があります。このタイマーは、クライアントのタイムアウトを回避するために使用されます。名前を解決する際にリゾルバに公平なショットを与えながら、2秒の一般的なタイムアウト値のほんの少しとして推奨値1.8秒で、設定可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "The resolver then checks its cache for any unexpired records that satisfy the request and returns them if available. If it finds no relevant unexpired data and the Recursion Desired flag is not set in the request, it should immediately return the response without consulting the cache for expired records. Typically, this response would be a referral to authoritative nameservers covering the zone, but the specifics are implementation dependent.",
      "ja": "次に、リゾルバーはキャッシュをチェックして、要求を満たす満了していないレコードがないか確認し、利用可能な場合はそれらを返します。関連する有効期限が切れていないデータが見つからず、リクエストにRecursion Desiredフラグが設定されていない場合、期限切れのレコードのキャッシュを調べずに、すぐに応答を返す必要があります。通常、この応答は、ゾーンをカバーする権威あるネームサーバーへの紹介ですが、詳細は実装に依存します。"
    },
    {
      "indent": 3,
      "text": "If iterative lookups will be done, then the failure recheck timer is consulted. Attempts to refresh from non-responsive or otherwise failing authoritative nameservers are recommended to be done no more frequently than every 30 seconds. If this request was received within this period, the cache may be immediately consulted for stale data to satisfy the request.",
      "ja": "反復ルックアップが行われる場合、失敗の再チェックタイマーが調べられます。応答しない、または失敗した権威ネームサーバーからリフレッシュする試みは、30秒おきに実行することをお勧めします。この要求がこの期間内に受信された場合、キャッシュは、要求を満たすために失効したデータがないかすぐに調べられます。"
    },
    {
      "indent": 3,
      "text": "Outside the period of the failure recheck timer, the resolver should start the query resolution timer and begin the iterative resolution process. This timer bounds the work done by the resolver when contacting external authorities and is commonly around 10 to 30 seconds. If this timer expires on an attempted lookup that is still being processed, the resolution effort is abandoned.",
      "ja": "失敗の再チェックタイマーの期間外に、リゾルバーはクエリ解決タイマーを開始し、反復解決プロセスを開始する必要があります。このタイマーは、外部機関に連絡するときにリゾルバーによって実行される作業の範囲を定め、通常は約10〜30秒です。まだ処理されている試行されたルックアップでこのタイマーが期限切れになると、解決作業は中止されます。"
    },
    {
      "indent": 3,
      "text": "If the answer has not been completely determined by the time the client response timer has elapsed, the resolver should then check its cache to see whether there is expired data that would satisfy the request. If so, it adds that data to the response message with a TTL greater than 0 (as specified in Section 4). The response is then sent to the client while the resolver continues its attempt to refresh the data.",
      "ja": "クライアントの応答タイマーが経過するまでに応答が完全に決定されなかった場合、リゾルバーはキャッシュをチェックして、要求を満たす期限切れのデータがあるかどうかを確認する必要があります。その場合、0より大きいTTLを持つ応答メッセージにそのデータを追加します（セクション4で指定）。次に、リゾルバーがデータのリフレッシュを試みている間に、応答がクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": "When no authorities are able to be reached during a resolution attempt, the resolver should attempt to refresh the delegation and restart the iterative lookup process with the remaining time on the query resolution timer. This resumption should be done only once per resolution effort.",
      "ja": "解決の試行中に権限に到達できない場合、リゾルバーは委任を更新し、クエリ解決タイマーの残り時間を使用して反復ルックアッププロセスを再開する必要があります。この再開は、解決作業ごとに1回だけ行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Outside the resolution process, the maximum stale timer is used for cache management and is independent of the query resolution process. This timer is conceptually different from the maximum cache TTL that exists in many resolvers, the latter being a clamp on the value of TTLs as received from authoritative servers and recommended to be 7 days in the TTL definition in Section 4. The maximum stale timer should be configurable. It defines the length of time after a record expires that it should be retained in the cache. The suggested value is between 1 and 3 days.",
      "ja": "解決プロセスの外では、最大古くなったタイマーがキャッシュ管理に使用され、クエリ解決プロセスとは無関係です。このタイマーは、多くのリゾルバーに存在する最大キャッシュTTLとは概念的に異なります。後者は、権限のあるサーバーから受信したTTLの値に対するクランプであり、セクション4のTTL定義で7日であることが推奨されています。構成可能です。これは、レコードの有効期限が切れてからキャッシュに保持される期間を定義します。推奨値は1〜3日です。"
    },
    {
      "indent": 0,
      "text": "6. Implementation Considerations",
      "section_title": true,
      "ja": "6. 実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document mainly describes the issues behind serving stale data and intentionally does not provide a formal algorithm. The concept is not overly complex, and the details are best left to resolver authors to implement in their codebases. The processing of serve-stale is a local operation, and consistent variables between deployments are not needed for interoperability. However, we would like to highlight the impact of various implementation choices, starting with the timers involved.",
      "ja": "このドキュメントでは主に古いデータを提供する背後にある問題について説明し、意図的に正式なアルゴリズムを提供していません。概念は過度に複雑ではなく、詳細はリゾルバの作成者がコードベースに実装するのが最善です。 serve-staleの処理はローカル操作であり、相互運用性のためにデプロイメント間の一貫した変数は必要ありません。ただし、関連するタイマーから始めて、さまざまな実装の選択の影響を強調したいと思います。"
    },
    {
      "indent": 3,
      "text": "The most obvious of these is the maximum stale timer. If this variable is too large, it could cause excessive cache memory usage, but if it is too small, the serve-stale technique becomes less effective, as the record may not be in the cache to be used if needed. Shorter values, even less than a day, can effectively handle the vast majority of outages. Longer values, as much as a week, give time for monitoring systems to notice a resolution problem and for human intervention to fix it; operational experience has been that sometimes the right people can be hard to track down and unfortunately slow to remedy the situation.",
      "ja": "これらの中で最も明白なのは、最大の古くなったタイマーです。この変数が大きすぎると、キャッシュメモリが過剰に使用される可能性がありますが、小さすぎると、レコードが必要に応じて使用されるキャッシュにない可能性があるため、serve-stale手法の効果が低下します。値が1日未満であっても、ほとんどの停止を効果的に処理できます。 1週間程度の長い値は、監視システムが解決の問題に気づき、人間の介入がそれを修正するための時間を与えます。運用経験では、適切な人が追跡することが困難な場合があり、残念ながら状況の改善に時間がかかる場合があります。"
    },
    {
      "indent": 3,
      "text": "Increased memory consumption could be mitigated by prioritizing removal of stale records over non-expired records during cache exhaustion. Eviction strategies could consider additional factors, including the last time of use or the popularity of a record, to retain active but stale records. A feature to manually flush only stale records could also be useful.",
      "ja": "キャッシュの枯渇時に期限切れになっていないレコードより古いレコードの削除を優先することにより、メモリ消費の増加を軽減できます。エビクション戦略では、アクティブなレコードを古くするために、最後の使用時間やレコードの人気度などの追加の要素を考慮することができます。古いレコードのみを手動でフラッシュする機能も役立ちます。"
    },
    {
      "indent": 3,
      "text": "The client response timer is another variable that deserves consideration. If this value is too short, there exists the risk that stale answers may be used even when the authoritative server is actually reachable but slow; this may result in undesirable answers being returned. Conversely, waiting too long will negatively impact user experience.",
      "ja": "クライアント応答タイマーは、考慮に値するもう1つの変数です。この値が短すぎると、権限のあるサーバーに実際に到達できるが遅い場合でも、古い応答が使用されるリスクがあります。これにより、望ましくない回答が返される可能性があります。逆に、待機時間が長すぎると、ユーザーエクスペリエンスに悪影響を及ぼします。"
    },
    {
      "indent": 3,
      "text": "The balance for the failure recheck timer is responsiveness in detecting the renewed availability of authorities versus the extra resource use for resolution. If this variable is set too large, stale answers may continue to be returned even after the authoritative server is reachable; per [RFC2308], Section 7, this should be no more than 5 minutes. If this variable is too small, authoritative servers may be targeted with a significant amount of excess traffic.",
      "ja": "失敗の再チェックタイマーのバランスは、権限の更新された可用性と解決のための追加のリソースの使用を検出する際の応答性です。この変数の設定が大きすぎると、権限のあるサーバーに到達した後でも、古い応答が引き続き返されることがあります。 [RFC2308]、セクション7に従い、これは5分以内にする必要があります。この変数が小さすぎると、権限のあるサーバーが大量の過剰なトラフィックの対象になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Regarding the TTL to set on stale records in the response, historically TTLs of 0 seconds have been problematic for some implementations, and negative values can't effectively be communicated to existing software. Other very short TTLs could lead to congestive collapse as TTL-respecting clients rapidly try to refresh. The recommended value of 30 seconds not only sidesteps those potential problems with no practical negative consequences, it also rate-limits further queries from any client that honors the TTL, such as a forwarding resolver.",
      "ja": "応答の古いレコードに設定するTTLに関して、歴史的には0秒のTTLは一部の実装で問題があり、負の値は既存のソフトウェアに効果的に伝達できません。その他の非常に短いTTLは、TTLを尊重するクライアントが迅速に更新しようとするため、輻輳による崩壊につながる可能性があります。推奨値である30秒は、これらの潜在的な問題を回避して実用的な悪影響を与えるだけでなく、転送リゾルバーなどのTTLを尊重するクライアントからの以降のクエリをレート制限します。"
    },
    {
      "indent": 3,
      "text": "As for the change to treat a TTL with the high-order bit set as positive and then clamping it, as opposed to [RFC2181] treating it as zero, the rationale here is basically one of engineering simplicity versus an inconsequential operational history. Negative TTLs had no rational intentional meaning that wouldn't have been satisfied by just sending 0 instead, and similarly there was realistically no practical purpose for sending TTLs of 2^25 seconds (1 year) or more. There's also no record of TTLs in the wild having the most significant bit set in the DNS Operations, Analysis, and Research Center's (DNS-OARC's) \"Day in the Life\" samples [DITL]. With no apparent reason for operators to use them intentionally, that leaves either errors or non-standard experiments as explanations as to why such TTLs might be encountered, with neither providing an obviously compelling reason as to why having the leading bit set should be treated differently from having any of the next eleven bits set and then capped per Section 4.",
      "ja": "[RFC2181]がゼロとして扱うのとは対照的に、高位ビットを正として設定してからクランプするTTLを扱うための変更に関して、ここでの理論的根拠は、基本的にエンジニアリングの単純さと重要でない運用履歴の1つです。負のTTLには、代わりに0を送信するだけでは満足できない合理的な意図的な意味はありませんでした。同様に、2 ^ 25秒（1年）以上のTTLを送信する実用的な目的は実際にはありませんでした。また、DNS運用、分析、および研究センター（DNS-OARC）の「Day in the Life」のサンプル[DITL]で設定された最上位ビットを持つ、TTLの実態はありません。オペレーターが意図的にそれらを使用する明確な理由がないため、そのようなTTLが発生する理由の説明としてエラーまたは非標準の実験のいずれかが残され、先行ビットセットを異なる方法で処理する必要があることについての明白な説得力のある理由も提供されていません次の11ビットのいずれかを設定し、セクション4に従って上限を設けることから。"
    },
    {
      "indent": 3,
      "text": "Another implementation consideration is the use of stale nameserver addresses for lookups. This is mentioned explicitly because, in some resolvers, getting the addresses for nameservers is a separate path from a normal cache lookup. If authoritative server addresses are not able to be refreshed, resolution can possibly still be successful if the authoritative servers themselves are up. For instance, consider an attack on a top-level domain that takes its nameservers offline; serve-stale resolvers that had expired glue addresses for subdomains within that top-level domain would still be able to resolve names within those subdomains, even those it had not previously looked up.",
      "ja": "実装に関するもう1つの考慮事項は、ルックアップに古いネームサーバーアドレスを使用することです。一部のリゾルバーでは、ネームサーバーのアドレスの取得が通常のキャッシュ検索とは別のパスであるため、これは明示的に言及されています。権限のあるサーバーのアドレスを更新できない場合でも、権限のあるサーバー自体が起動していれば、解決が成功する可能性があります。たとえば、ネームサーバーをオフラインにするトップレベルドメインへの攻撃を考えてみます。そのトップレベルドメイン内のサブドメインのグルーアドレスの有効期限が切れていた古いサービスリゾルバは、以前にルックアップしていなかった場合でも、それらのサブドメイン内の名前を解決できます。"
    },
    {
      "indent": 3,
      "text": "The directive in Section 4 that only NoError and NXDomain responses should invalidate any previously associated answer stems from the fact that no other RCODEs that a resolver normally encounters make any assertions regarding the name in the question or any data associated with it. This comports with existing resolver behavior where a failed lookup (say, during prefetching) doesn't impact the existing cache state. Some authoritative server operators have said that they would prefer stale answers to be used in the event that their servers are responding with errors like ServFail instead of giving true authoritative answers. Implementers MAY decide to return stale answers in this situation.",
      "ja": "NoErrorおよびNXDomain応答のみが以前に関連付けられた回答を無効にする必要があるというセクション4のディレクティブは、リゾルバーが通常遭遇する他のRCODEが質問の名前またはそれに関連付けられたデータに関するアサーションを作成しないという事実から生じます。これは、ルックアップの失敗（たとえば、プリフェッチ中）が既存のキャッシュの状態に影響を与えない、既存のリゾルバーの動作に対応しています。一部の信頼できるサーバーオペレーターは、サーバーが真の信頼できる応答を返すのではなく、ServFailなどのエラーで応答する場合に、古い応答を使用することを望んでいると述べています。実装者は、この状況で古い回答を返すことを決定する場合があります。"
    },
    {
      "indent": 3,
      "text": "Since the goal of serve-stale is to provide resiliency for all obvious errors to refresh data, these other RCODEs are treated as though they are equivalent to not getting an authoritative response. Although NXDomain for a previously existing name might well be an error, it is not handled that way because there is no effective way to distinguish operator intent for legitimate cases versus error cases.",
      "ja": "serve-staleの目的は、すべての明らかなエラーに回復力を与えてデータを更新することなので、これらの他のRCODEは、信頼できる応答を取得しないことに相当するものとして扱われます。以前に存在した名前のNXDomainはエラーになる可能性がありますが、正当な場合とエラーの場合のオペレーターの意図を区別する効果的な方法がないため、そのようには処理されません。"
    },
    {
      "indent": 3,
      "text": "During discussion in the IETF, it was suggested that, if all authorities return responses with an RCODE of Refused, it may be an explicit signal to take down the zone from servers that still have the zone's delegation pointed to them. Refused, however, is also overloaded to mean multiple possible failures that could represent transient configuration failures. Operational experience has shown that purposely returning Refused is a poor way to achieve an explicit takedown of a zone compared to either updating the delegation or returning NXDomain with a suitable SOA for extended negative caching. Implementers MAY nonetheless consider whether to treat all authorities returning Refused as preempting the use of stale data.",
      "ja": "IETFでの議論中に、すべての機関が拒否されたRCODEで応答を返す場合、ゾーンの委任がまだ指し示されているサーバーからゾーンを削除することは、明示的なシグナルである可能性があることが示唆されました。ただし、拒否された場合も過負荷になり、一時的な構成エラーを表す可能性のある複数のエラーが発生する可能性があります。運用経験から、意図的にRefusedを返すことは、委任を更新したり、拡張ネガティブキャッシュに適したSOAでNXDomainを返すことと比較して、ゾーンの明示的な削除を達成するには不十分な方法であることがわかっています。それでも、実装者は、Refusedを返すすべての機関を古いデータの使用を先取りするものとして扱うかどうかを検討する場合があります。"
    },
    {
      "indent": 0,
      "text": "7. Implementation Caveats",
      "section_title": true,
      "ja": "7. 実装に関する警告"
    },
    {
      "indent": 3,
      "text": "Stale data is used only when refreshing has failed in order to adhere to the original intent of the design of the DNS and the behavior expected by operators. If stale data were to always be used immediately and then a cache refresh attempted after the client response has been sent, the resolver would frequently be sending data that it would have had no trouble refreshing. Because modern resolvers use techniques like prefetching and request coalescing for efficiency, it is not necessary that every client request needs to trigger a new lookup flow in the presence of stale data, but rather that a good-faith effort has been recently made to refresh the stale data before it is delivered to any client.",
      "ja": "古くなったデータは、DNSの設計の本来の目的とオペレーターが期待する動作に準拠するために更新が失敗した場合にのみ使用されます。古くなったデータが常にすぐに使用され、クライアントの応答が送信された後にキャッシュの更新が試みられた場合、リゾルバーは頻繁に更新に問題のないデータを送信します。最新のリゾルバーは効率を上げるためにプリフェッチやリクエストの合体などの手法を使用しているため、すべてのクライアントリクエストが古いデータの存在下で新しいルックアップフローをトリガーする必要はありませんが、最近では、誠実な努力がリフレッシュされてクライアントに配信される前の古いデータ。"
    },
    {
      "indent": 3,
      "text": "It is important to continue the resolution attempt after the stale response has been sent, until the query resolution timeout, because some pathological resolutions can take many seconds to succeed as they cope with unavailable servers, bad networks, and other problems. Stopping the resolution attempt when the response with expired data has been sent would mean that answers in these pathological cases would never be refreshed.",
      "ja": "古い応答が送信された後、クエリの解決がタイムアウトするまで、解決の試行を続けることが重要です。一部の病理学的解決は、使用できないサーバー、不良ネットワーク、およびその他の問題に対処するため、成功するまでに数秒かかることがあります。期限切れのデータを含む応答が送信されたときに解決の試行を停止すると、これらの病理学的なケースでの回答が更新されることはありません。"
    },
    {
      "indent": 3,
      "text": "The continuing prohibition against using data with a 0-second TTL beyond the current transaction explicitly extends to it being unusable even for stale fallback, as it is not to be cached at all.",
      "ja": "現在のトランザクションを超えて0秒TTLのデータを使用することに対する継続的な禁止は、まったくキャッシュされないため、古くなったフォールバックに対しても使用できなくなることを明示的に拡大します。"
    },
    {
      "indent": 3,
      "text": "Be aware that Canonical Name (CNAME) and DNAME records [RFC6672] mingled in the expired cache with other records at the same owner name can cause surprising results. This was observed with an initial implementation in BIND when a hostname changed from having an IPv4 Address (A) record to a CNAME. The version of BIND being used did not evict other types in the cache when a CNAME was received, which in normal operations is not a significant issue. However, after both records expired and the authorities became unavailable, the fallback to stale answers returned the older A instead of the newer CNAME.",
      "ja": "正規名（CNAME）およびDNAMEレコード[RFC6672]が期限切れのキャッシュに同じ所有者名の他のレコードと混在していると、予期しない結果が生じる可能性があることに注意してください。これは、ホスト名がIPv4アドレス（A）レコードからCNAMEに変更されたときに、BINDの初期実装で観察されました。使用されているBINDのバージョンは、CNAMEが受信されたときにキャッシュ内の他のタイプを排除しませんでした。これは、通常の操作では重要な問題ではありません。ただし、両方のレコードの有効期限が切れて当局が利用できなくなった後、古い回答へのフォールバックにより、新しいCNAMEではなく古いAが返されました。"
    },
    {
      "indent": 0,
      "text": "8. Implementation Status",
      "section_title": true,
      "ja": "8. 実施状況"
    },
    {
      "indent": 3,
      "text": "The algorithm described in Section 5 was originally implemented as a patch to BIND 9.7.0. It has been in use on Akamai's production network since 2011; it effectively smoothed over transient failures and longer outages that would have resulted in major incidents. The patch was contributed to the Internet Systems Consortium, and the functionality is now available in BIND 9.12 and later via the options stale-answer-enable, stale-answer-ttl, and max-stale-ttl.",
      "ja": "セクション5で説明されているアルゴリズムは、もともとBIND 9.7.0へのパッチとして実装されていました。 2011年以降、アカマイの生産ネットワークで使用されています。これにより、重大なインシデントにつながる一時的な障害や長時間の停止が効果的に解消されました。このパッチはInternet Systems Consortiumに寄贈され、機能はBIND 9.12以降でオプションstale-answer-enable、stale-answer-ttl、およびmax-stale-ttlを介して利用できるようになりました。"
    },
    {
      "indent": 3,
      "text": "Unbound has a similar feature for serving stale answers and will respond with stale data immediately if it has recently tried and failed to refresh the answer by prefetching. Starting from version 1.10.0, Unbound can also be configured to follow the algorithm described in Section 5. Both behaviors can be configured and fine-tuned with the available serve-expired-* options.",
      "ja": "Unboundには、古い回答を提供するための同様の機能があり、プリフェッチによる回答の更新を最近試みて失敗した場合、古いデータですぐに応答します。バージョン1.10.0以降、セクション5で説明されているアルゴリズムに従うようにUnboundを構成することもできます。どちらの動作も、使用可能なserve-expired- *オプションを使用して構成および微調整できます。"
    },
    {
      "indent": 3,
      "text": "Knot Resolver has a demo module here: <https://knot-resolver.readthedocs.io/en/stable/modules-serve_stale.html>.",
      "ja": "Knot Resolverには、<https://knot-resolver.readthedocs.io/en/stable/modules-serve_stale.html>のデモモジュールがあります。"
    },
    {
      "indent": 3,
      "text": "Apple's system resolvers are also known to use stale answers, but the details are not readily available.",
      "ja": "Appleのシステムリゾルバーは古い応答を使用することも知られていますが、詳細はすぐには入手できません。"
    },
    {
      "indent": 3,
      "text": "In the research paper \"When the Dike Breaks: Dissecting DNS Defenses During DDoS\" [DikeBreaks], the authors detected some use of stale answers by resolvers when authorities came under attack. Their research results suggest that more widespread adoption of the technique would significantly improve resiliency for the large number of requests that fail or experience abnormally long resolution times during an attack.",
      "ja": "研究論文「Dike Breaks：Dissecting DNS Defenses during DDoS」[DikeBreaks]の研究では、当局が攻撃を受けたときに、リゾルバーによる古い回答の使用を検出しました。彼らの研究結果は、この技術をより広く採用することで、失敗したり、攻撃中に異常に長い解決時間を経験したりする多数の要求に対する回復力を大幅に向上させることを示唆しています。"
    },
    {
      "indent": 0,
      "text": "9. EDNS Option",
      "section_title": true,
      "ja": "9. アドオンオプション"
    },
    {
      "indent": 3,
      "text": "During the discussion of serve-stale in the IETF, it was suggested that an EDNS option [RFC6891] should be available. One proposal was to use it to opt in to getting data that is possibly stale, and another was to signal when stale data has been used for a response.",
      "ja": "IETFでのサーブスタイルの議論中に、EDNSオプション[RFC6891]が利用可能であることが提案されました。 1つは、古くなっている可能性のあるデータの取得をオプトインすることで、もう1つは、古くなったデータが応答に使用されたときに通知することです。"
    },
    {
      "indent": 3,
      "text": "The opt-in use case was rejected, as the technique was meant to be immediately useful in improving DNS resiliency for all clients.",
      "ja": "この手法はすべてのクライアントのDNS復元力を向上させるのにすぐに役立つことを意図していたため、オプトインの使用例は拒否されました。"
    },
    {
      "indent": 3,
      "text": "The reporting case was ultimately also rejected because even the simpler version of a proposed option was still too much bother to implement for too little perceived value.",
      "ja": "提案されたオプションのより単純なバージョンでさえ、知覚された値が少なすぎるために実装するにはあまりに面倒だったため、最終的に報告事例も却下されました。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The most obvious security issue is the increased likelihood of DNSSEC validation failures when using stale data because signatures could be returned outside their validity period. Stale negative records can increase the time window where newly published TLSA or DS RRs may not be used due to cached NSEC or NSEC3 records. These scenarios would only be an issue if the authoritative servers are unreachable (the only time the techniques in this document are used), and thus serve-stale does not introduce a new failure in place of what would have otherwise been success.",
      "ja": "最も明白なセキュリティの問題は、署名が有効期間外に返される可能性があるため、古いデータを使用するときにDNSSEC検証エラーが発生する可能性が高くなることです。古くなった負のレコードは、NSECまたはNSEC3レコードがキャッシュされているために、新しく公開されたTLSAまたはDS RRが使用されない可能性がある時間枠を増やす可能性があります。これらのシナリオは、権限のあるサーバーに到達できない場合（このドキュメントの手法が使用される場合のみ）にのみ問題となり、したがって、サーブスタイルは、そうでなければ成功したはずの代わりに新しい障害を引き起こしません。"
    },
    {
      "indent": 3,
      "text": "Additionally, bad actors have been known to use DNS caches to keep records alive even after their authorities have gone away. The serve-stale feature potentially makes the attack easier, although without introducing a new risk. In addition, attackers could combine this with a DDoS attack on authoritative servers with the explicit intent of having stale information cached for a longer period of time. But if attackers have this capacity, they probably could do much worse than prolonging the life of old data.",
      "ja": "さらに、不正行為者は、当局が去った後でもDNSキャッシュを使用してレコードを存続させることが知られています。新しい機能を導入しなくても、サービスが古くなった機能により攻撃が容易になる可能性があります。さらに、攻撃者はこれを、信頼できるサーバーに対するDDoS攻撃と組み合わせて、古くなった情報を長期間キャッシュする明示的な意図を持つことができます。しかし、攻撃者がこの能力を持っている場合、おそらく古いデータの寿命を延ばすよりもはるかに悪いことになるでしょう。"
    },
    {
      "indent": 3,
      "text": "In [CloudStrife], it was demonstrated how stale DNS data, namely hostnames pointing to addresses that are no longer in use by the owner of the name, can be used to co-opt security -- for example, to get domain-validated certificates fraudulently issued to an attacker. While this document does not create a new vulnerability in this area, it does potentially enlarge the window in which such an attack could be made. A proposed mitigation is that certificate authorities should fully look up each name starting at the DNS root for every name lookup. Alternatively, certificate authorities should use a resolver that is not serving stale data.",
      "ja": "[CloudStrife]では、失効したDNSデータ、つまり名前の所有者が使用していないアドレスを指すホスト名を使用して、ドメイン検証済みの証明書を取得するなど、セキュリティを選択する方法が示されました攻撃者に不正に発行されました。このドキュメントはこの領域に新しい脆弱性を作成しませんが、そのような攻撃が行われる可能性のあるウィンドウを拡大する可能性があります。軽減策として、認証機関は、名前の検索ごとにDNSルートから始まる各名前を完全に検索する必要があります。または、認証局は古いデータを提供しないリゾルバを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. Privacy Considerations",
      "section_title": true,
      "ja": "11. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not add any practical new privacy issues.",
      "ja": "このドキュメントでは、実用的な新しいプライバシーの問題は追加されていません。"
    },
    {
      "indent": 0,
      "text": "12. NAT Considerations",
      "section_title": true,
      "ja": "12. NATに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The method described here is not affected by the use of NAT devices.",
      "ja": "ここで説明する方法は、NATデバイスの使用による影響を受けません。"
    },
    {
      "indent": 0,
      "text": "13. IANA Considerations",
      "section_title": true,
      "ja": "13. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14. 参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987, <https://www.rfc-editor.org/info/rfc1034>.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、DOI 10.17487 / RFC1034、1987年11月、<https://www.rfc-editor.org/info/rfc1034>。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <https://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名-実装および仕様」、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、<https://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2181] Elz, R. and R. Bush, \"Clarifications to the DNS Specification\", RFC 2181, DOI 10.17487/RFC2181, July 1997, <https://www.rfc-editor.org/info/rfc2181>.",
      "ja": "[RFC2181] Elz、R。およびR. Bush、「Clarifications to the DNS Specification」、RFC 2181、DOI 10.17487 / RFC2181、1997年7月、<https://www.rfc-editor.org/info/rfc2181>。"
    },
    {
      "indent": 3,
      "text": "[RFC2308] Andrews, M., \"Negative Caching of DNS Queries (DNS NCACHE)\", RFC 2308, DOI 10.17487/RFC2308, March 1998, <https://www.rfc-editor.org/info/rfc2308>.",
      "ja": "[RFC2308]アンドリュース、M。、「DNSクエリのネガティブキャッシング（DNS NCACHE）」、RFC 2308、DOI 10.17487 / RFC2308、1998年3月、<https://www.rfc-editor.org/info/rfc2308>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CloudStrife] Borgolte, K., Fiebig, T., Hao, S., Kruegel, C., and G. Vigna, \"Cloud Strife: Mitigating the Security Risks of Domain-Validated Certificates\", DOI 10.1145/3232755.3232859, ACM 2018 Applied Networking Research Workshop, July 2018, <https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_06A-4_Borgolte_paper.pdf>.",
      "ja": "[CloudStrife] Borgolte、K.、Fiebig、T.、Hao、S.、Kruegel、C。、およびG. Vigna、「Cloud Strife：Mitigating the Security Risks of Domain-Validated Certificates」、DOI 10.1145 / 3232755.3232859、ACM 2018 Applied Networking Research Workshop、2018年7月、<https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_06A-4_Borgolte_paper.pdf>。"
    },
    {
      "indent": 3,
      "text": "[DikeBreaks] Moura, G.C.M., Heidemann, J., Müller, M., Schmidt, R. de O., and M. Davids, \"When the Dike Breaks: Dissecting DNS Defenses During DDoS\", DOI 10.1145/3278532.3278534, ACM 2018 Internet Measurement Conference, October 2018, <https://www.isi.edu/~johnh/PAPERS/Moura18b.pdf>.",
      "ja": "[DikeBreaks] Moura、GCM、Heidemann、J.、Muller、M.、Schmidt、R。de O.、およびM. Davids、「Dike Breaks：Dissecting DNS Defenses中にDDoS」、DOI 10.1145 / 3278532.3278534、ACM 2018インターネット測定会議、2018年10月、<https://www.isi.edu/~johnh/PAPERS/Moura18b.pdf>。"
    },
    {
      "indent": 3,
      "text": "[DITL] DNS-OARC, \"DITL Traces and Analysis\", January 2018, <https://www.dns-oarc.net/oarc/data/ditl>.",
      "ja": "[DITL] DNS-OARC、「DITL Traces and Analysis」、2018年1月、<https://www.dns-oarc.net/oarc/data/ditl>。"
    },
    {
      "indent": 3,
      "text": "[RFC6672] Rose, S. and W. Wijngaards, \"DNAME Redirection in the DNS\", RFC 6672, DOI 10.17487/RFC6672, June 2012, <https://www.rfc-editor.org/info/rfc6672>.",
      "ja": "[RFC6672] Rose、S。およびW. Wijngaards、「DNSでのDNAMEリダイレクション」、RFC 6672、DOI 10.17487 / RFC6672、2012年6月、<https://www.rfc-editor.org/info/rfc6672>。"
    },
    {
      "indent": 3,
      "text": "[RFC6891] Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms for DNS (EDNS(0))\", STD 75, RFC 6891, DOI 10.17487/RFC6891, April 2013, <https://www.rfc-editor.org/info/rfc6891>.",
      "ja": "[RFC6891] Damas、J.、Graff、M。、およびP. Vixie、「DNSの拡張メカニズム（EDNS（0））」、STD 75、RFC 6891、DOI 10.17487 / RFC6891、2013年4月、<https：// www.rfc-editor.org/info/rfc6891>。"
    },
    {
      "indent": 3,
      "text": "[RFC8499] Hoffman, P., Sullivan, A., and K. Fujiwara, \"DNS Terminology\", BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019, <https://www.rfc-editor.org/info/rfc8499>.",
      "ja": "[RFC8499]ホフマン、P。、サリバン、A。、およびK.藤原、「DNS用語」、BCP 219、RFC 8499、DOI 10.17487 / RFC8499、2019年1月、<https://www.rfc-editor.org/ info / rfc8499>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Brian Carpenter, Vladimir Cunat, Robert Edmonds, Tony Finch, Bob Harold, Tatuya Jinmei, Matti Klock, Jason Moreau, Giovane Moura, Jean Roy, Mukund Sivaraman, Davey Song, Paul Vixie, Ralf Weber, and Paul Wouters for their review and feedback. Paul Hoffman deserves special thanks for submitting a number of Pull Requests.",
      "ja": "著者は、ブライアン・カーペンター、ウラジミール・クナット、ロバート・エドモンズ、トニー・フィンチ、ボブ・ハロルド、タトゥヤ・ジンメイ、マティ・クロック、ジェイソン・モロー、ジョヴァン・モウラ、ジャン・ロイ、ムクンド・シヴァラマン、デイヴィー・ソング、ポール・ヴィクシー、ラルフ・ウェーバー、ポール・ウタースに感謝します彼らのレビューとフィードバックのために。 Paul Hoffmanは、多数のプルリクエストを送信してくださったことに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thank you also to the following members of the IESG for their final review: Roman Danyliw, Benjamin Kaduk, Suresh Krishnan, Mirja Kühlewind, and Adam Roach.",
      "ja": "IESGの最終レビューを行ったメンバー、Roman Danyliw、Benjamin Kaduk、Suresh Krishnan、MirjaKühlewind、およびAdam Roachにも感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David C Lawrence Oracle",
      "ja": "デビッドCローレンスオラクル"
    },
    {
      "indent": 3,
      "text": "Email: tale@dd.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Warren \"Ace\" Kumari Google 1600 Amphitheatre Parkway Mountain View, CA 94043 United States of America",
      "ja": "Warren \"Ace\" Kumari Google 1600 Amphitheatre Parkway Mountain View、CA 94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: warren@kumari.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Puneet Sood Google",
      "ja": "Puneet Sood Google"
    },
    {
      "indent": 3,
      "text": "Email: puneets@google.com",
      "raw": true,
      "ja": ""
    }
  ]
}